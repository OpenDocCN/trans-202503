# 第七章：C 语言深度解析：探索汇编

*Under the C, under the C Don’t you know it’s better Dealing with registers And assembly?

—塞巴斯蒂安，可能*

![image](img/common.jpg)

在编译器发明之前的计算机早期，许多程序员使用*汇编语言*进行编码，汇编语言直接指定计算机在执行过程中遵循的指令集。汇编语言是程序员在不直接编写 1 和 0 的代码的情况下，最接近机器级编码的方式，也是*机器代码*的一种可读形式。为了编写高效的汇编代码，程序员必须深入理解底层机器架构的运作。

编译器的发明从根本上改变了程序员编写代码的方式。*编译器*将人类可读的编程语言（通常使用英语单词编写）翻译成计算机能够理解的语言（即机器代码）。编译器使用编程语言的规则、操作系统的规范和机器的指令集，将人类可读的代码翻译成机器代码，并在过程中提供错误检测和类型检查。大多数现代编译器生成的汇编代码与过去手写的汇编代码一样高效。

### 学习汇编语言的好处

尽管编译器有很多好处，但学习汇编语言的价值可能并不明显。然而，学习和理解汇编代码有几个非常有说服力的理由。以下是一些例子。

#### 高层抽象掩盖了程序中的宝贵细节

高级编程语言提供的抽象对于减少编程的复杂性是一大福音。同时，这种简化使得程序员在做设计决策时，可能并没有完全理解他们选择在机器级上的实际影响。缺乏汇编语言的知识往往会阻止程序员理解程序运行中的宝贵信息，并限制他们了解代码实际执行情况的能力。

作为例子，请看下面的程序：

```
#include <stdio.h>

int adder() {

    int a;

    return a + 2;

}

int assign() {

    int y = 40;

    return y;

}

int main() {

    int x;

    assign();

    x = adder();

    printf("x is: %d\n", x);

    return 0;

}
```

这个程序的输出是什么？乍一看，`assign`函数似乎没有任何效果，因为它的返回值没有被`main`中的任何变量存储。`adder`函数返回`a + 2`的值，尽管变量`a`没有初始化（不过在某些机器上，编译器会将`a`初始化为 0）。打印`x`应该会得到一个未定义的值。然而，在大多数 64 位机器上编译并运行该程序时，结果总是`42`：

```
$ gcc -o example example.c

$ ./example

x is: 42
```

这个程序的输出乍一看似乎毫无意义，因为`adder`和`assign`函数似乎没有连接在一起。理解栈帧和函数是如何在幕后执行的，将帮助你理解为什么答案是`42`。我们将在接下来的章节中重新审视这个例子。

#### 一些计算机系统由于资源限制，无法使用编译器

最常见的“计算机”是那些我们无法直接识别为计算机的设备。这些设备无处不在，从汽车、咖啡机到洗衣机和智能手表。传感器、微控制器和其他嵌入式处理器在我们的生活中扮演着越来越重要的角色，并且所有这些设备都需要软件来运行。然而，这些设备中所含的处理器通常非常小，以至于无法执行由高级编程语言编写的编译代码。在许多情况下，这些设备需要独立的汇编程序，而这些程序不依赖于常见编程语言所需的运行时库。

#### 漏洞分析

一部分安全专业人员的工作是尝试识别各种计算机系统中的漏洞。许多攻击程序的途径涉及程序如何存储其运行时信息。学习汇编语言使安全专家能够理解漏洞是如何产生的，以及如何被利用。

其他安全专家则花时间“逆向工程”恶意代码，例如恶意软件中的代码。掌握汇编语言的基本知识对这些软件工程师至关重要，能够帮助他们迅速开发对策，保护系统免受攻击。最后，缺乏对自己编写的代码如何转换为汇编语言的理解的开发人员，可能会无意中编写出有漏洞的代码。

#### 系统级软件中的关键代码序列

最后，计算机系统中有些组件是编译器无法充分优化的，必须手写汇编代码。一些系统层次中，存在手写的汇编代码，这些代码在需要进行详细的机器特定优化以提升性能的区域中至关重要。例如，所有计算机的引导序列都是用汇编语言编写的。操作系统通常包含手写的汇编代码，用于线程或进程上下文切换。在这些短小且对性能至关重要的代码序列中，人类通常能够写出比编译器更优化的汇编代码。

### 你将在接下来的章节中学到什么

接下来的三章将介绍三种不同风格的汇编语言。第七章和第八章介绍 x86-64 及其早期版本 IA32。 第九章介绍 ARMv8-A 汇编语言，这是大多数现代 ARM 设备的指令集架构（ISA），包括像 Raspberry Pi 这样的单板计算机。第十章总结了学习汇编的要点和一些关键的收获。

每种不同风格的汇编实现了不同的指令集架构（ISA）。回想一下，*ISA*（参见第五章）定义了指令及其二进制编码、CPU 寄存器的集合，以及执行指令时对 CPU 和内存状态的影响。

在接下来的三章中，你将看到所有 ISA 之间的普遍相似性，包括 CPU 寄存器作为许多指令的操作数，并且每个 ISA 提供类似类型的指令：

+   用于计算算术和逻辑运算的指令，例如加法或按位与。

+   用于控制流的指令，这些指令用于实现分支操作，如 if–else、循环和函数调用与返回。

+   用于数据移动的指令，这些指令在 CPU 寄存器和内存之间加载和存储值。

+   用于从栈中推送和弹出值的指令。这些指令用于实现执行调用栈，当函数被调用时，一个新的栈帧（存储运行函数的局部变量和参数）会被添加到栈顶，而函数返回时，栈顶的栈帧会被移除。

一个 C 语言编译器将 C 源代码翻译为特定的 ISA 指令集。编译器将 C 语句，包括循环、`if`–`else`、函数调用和变量访问，翻译成由 ISA 定义并由设计来执行该 ISA 指令的 CPU 实现的特定指令集。例如，编译器将 C 语言翻译为 x86 指令，以便在 Intel x86 处理器上执行，或将 C 语言翻译为 ARM 指令，以便在 ARM 处理器上执行。

当你阅读本书汇编部分的章节时，你可能会注意到一些关键术语被重新定义，并且一些图表被重复展示。为了更好地帮助其他计算机科学教育工作者，我们设计了每章可以在特定的高校和大学独立使用。虽然每一章中的大部分内容都是独特的，但我们希望章节之间的共性有助于加强读者对不同汇编风格之间相似性的理解。

准备好学习汇编语言了吗？让我们直接开始吧！
