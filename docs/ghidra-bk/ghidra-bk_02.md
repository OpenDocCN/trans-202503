## 第二章：反汇编简介**

![Image](img/com.jpg)

你可能会好奇一本专门介绍 Ghidra 的书会是什么样子。虽然这本书显然是以 Ghidra 为中心，但并不打算让它显得像是*Ghidra 用户手册*。相反，我们打算将 Ghidra 作为工具，来讨论逆向工程技巧，这些技巧将帮助你分析各种软件，从易受攻击的应用程序到恶意软件。当适当时，我们将提供在 Ghidra 中执行特定任务的详细步骤。因此，我们将通过 Ghidra 的功能进行一个相当曲折的探索，从你在初步检查文件时想要执行的基本任务开始，直到更具挑战性的逆向工程问题时，如何使用和定制 Ghidra。我们不会尝试覆盖 Ghidra 的所有功能。然而，我们会涵盖那些在应对你的逆向工程挑战时最有用的功能。这本书将帮助你将 Ghidra 打造成你工具库中最强大的武器。

在深入探讨任何 Ghidra 的细节之前，我们将介绍一些反汇编过程的基本概念，并回顾其他可用于逆向工程已编译代码的工具。虽然这些工具可能无法匹配 Ghidra 的全部功能，但每个工具都涵盖了 Ghidra 功能的特定子集，并且提供了对某些 Ghidra 特性的有价值的见解。本章的其余部分将专注于从高层次理解反汇编过程。

### 反汇编理论

任何曾花时间研究编程语言的人，可能已经学过各种语言的世代，但这里为那些可能还不熟悉的读者做了简要总结：

**第一代语言** 这些是最低级的语言，通常由一和零组成，或者是像十六进制这样的简写形式，仅能被二进制高手读取。在这一层级中，区分数据和指令非常困难，因为所有内容看起来都相同。第一代语言也可以称为*机器语言*，在某些情况下也称为*字节码*，而机器语言程序通常被称为*二进制文件*。

**第二代语言** 也叫*汇编语言*，第二代语言与机器语言仅一步之遥，通常将特定的比特模式或操作码（opcodes）映射到简短而易记的字符序列，称为*助记符*。这些助记符帮助程序员记住它们所对应的指令。*汇编器*是程序员用来将他们的汇编语言程序翻译成适合执行的机器语言的工具。除了指令助记符外，完整的汇编语言通常还包括一些*指令*，用于告诉汇编器代码和数据在最终二进制文件中的内存布局。

**第三代语言** 这些语言通过引入关键词和结构，使程序员可以使用它们作为程序的构建模块，从而进一步接近自然语言的表达能力。第三代语言通常是平台无关的，尽管使用它们编写的程序可能因使用特定操作系统的特性而与平台相关。常见的第三代语言包括 FORTRAN、C 和 Java。程序员通常使用编译器将其程序转换为汇编语言，或者直接转换为机器语言（或某种粗略等效的字节码）。

**第四代语言** 尽管存在，但不相关于本书，因此不作讨论。

### 反汇编的基本概念

在传统软件开发模型中，编译器、汇编器和链接器单独或组合使用来创建可执行程序。为了向后操作（或逆向工程程序），我们使用工具来撤销汇编和编译过程。毫不奇怪，这些工具被称为*反汇编器*和*反编译器*，它们基本上做了它们名称所示的事情。反汇编器撤销汇编过程，因此我们应该期望输出汇编语言（从而输入机器语言）。反编译器旨在在给定汇编甚至机器语言作为输入时生成高级语言的输出。

在竞争激烈的软件市场中，“源代码恢复”的承诺始终具有吸引力，因此可用的反编译器的开发仍然是计算机科学中一个活跃的研究领域。以下是一些解释反编译困难的原因：

**编译过程存在信息损失。** 在机器语言级别上，不存在变量或函数名称，变量类型信息仅能通过数据使用方式来确定，而非显式类型声明。当观察到传输 32 位数据时，您需要进行一些调查工作来确定这 32 位数据是表示整数、32 位浮点值还是 32 位指针。

**编译是一对多的操作。** 这意味着源程序可以以许多不同的方式翻译成汇编语言，而机器语言可以以许多不同的方式翻译回源代码。因此，编译文件然后立即反编译它通常会产生与原始文件大不相同的源文件。

**反编译器依赖于语言和库。** 使用设计为生成 C 代码的反编译器处理由 Delphi 编译器生成的二进制文件可能会产生非常奇怪的结果。同样地，将经过编译的 Windows 二进制文件输入到没有 Windows 编程 API 知识的反编译器中可能得不到任何有用的结果。

**为了准确地反编译一个二进制文件，几乎完美的反汇编能力是必需的。** 反汇编阶段的任何错误或遗漏几乎肯定会传播到反编译后的代码中。可以通过适当的处理器参考手册验证反汇编代码的正确性；然而，没有权威的参考手册可用于验证反编译器输出的正确性。

Ghidra 内置了反编译器，这是第十九章的主题。

### 反汇编的意义

反汇编工具的目的通常是为了在源代码不可用时帮助理解程序。使用反汇编的常见情况包括以下几种：

+   恶意软件分析

+   封闭源代码软件的漏洞分析

+   封闭源代码软件的互操作性分析

+   分析编译器生成的代码以验证编译器的性能或正确性

+   调试时程序指令的显示

后续部分将更详细地解释每种情况。

#### *恶意软件分析*

除非你正在处理基于脚本的恶意软件，否则恶意软件作者通常不会提供他们创作的源代码。没有源代码，你面临的选项非常有限，用于发现恶意软件具体行为的方式也很有限。恶意软件分析的两种主要技术是动态分析和静态分析。*动态分析*涉及在精心控制的环境（沙箱）中运行恶意软件，并通过使用各种系统工具记录其行为的每个可观察方面。与此相对，*静态分析*尝试仅通过阅读程序代码来理解程序的行为，在恶意软件的情况下，程序代码通常仅由反汇编清单和可能的反编译器清单组成。

#### *漏洞分析*

为了简化，我们将整个安全审计过程分为三个步骤：漏洞发现、漏洞分析和漏洞利用开发。无论是否有源代码，步骤是相同的；然而，当你只有二进制文件时，所需的工作量会大大增加。该过程的第一步是发现程序中可能被利用的条件。这通常是通过动态技术（如模糊测试）完成的，^(1)，但也可以通过静态分析（通常需要更多的努力）来完成。一旦发现问题，通常需要进一步分析以确定问题是否可以被利用，如果可以，被利用的条件是什么。

识别可以被攻击者利用的变量是发现漏洞的一个重要早期步骤。反汇编清单提供了理解编译器如何分配程序变量所需的详细信息。例如，知道程序员声明的 70 字节字符数组在编译器分配时被四舍五入为 80 字节可能是有用的。反汇编清单还提供了唯一的方式来确定编译器如何选择对所有全局或函数内声明的变量进行排序。了解变量之间的空间关系通常是开发利用程序时的关键。最终，通过结合使用反汇编器和调试器，可能会开发出一个漏洞利用程序。

#### *软件互操作性*

当软件仅以二进制形式发布时，竞争对手很难开发能够与之互操作的软件，或为该软件提供插件替代品。一个常见的例子是仅在一个平台上支持的硬件发布的驱动程序代码。当厂商在支持或更糟糕的是，拒绝支持其硬件与其他平台的兼容性时，可能需要大量的逆向工程工作才能开发出支持该硬件的软件驱动程序。在这些情况下，静态代码分析几乎是唯一的解决办法，并且通常需要超越软件驱动程序，以了解嵌入式固件。

#### *编译器验证*

由于编译器（或汇编器）的目的是生成机器语言，通常需要良好的反汇编工具来验证编译器是否按照设计规范执行其任务。分析人员可能还会关注寻找优化编译器输出的其他机会，并且从安全角度出发，确定编译器本身是否已被破坏，是否可能将后门代码插入到生成的代码中。

#### *调试显示*

也许反汇编器最常见的用途之一是生成调试器中的清单。不幸的是，嵌入调试器中的反汇编器通常缺乏复杂性。它们通常不能批量反汇编，有时在无法确定函数边界时会停止反汇编。这也是为什么最好将调试器与高质量的反汇编器结合使用，以提供更好的情境意识和调试过程中的上下文。

### 反汇编的原理

现在，既然您已经熟悉了反汇编的目的，是时候了解这个过程的实际操作了。考虑反汇编器面临的一个典型而艰巨的任务：*处理这 100KB，区分代码和数据，将代码转换为汇编语言并显示给用户，并且请在整个过程中不要遗漏任何部分。* 我们可以附加任何数量的特殊请求，比如要求反汇编器定位函数、识别跳转表、识别局部变量，使得反汇编器的工作更加困难。

为了满足我们所有的需求，任何反汇编器在处理我们输入的文件时，都需要从各种算法中挑选合适的算法。生成的反汇编列表的质量将直接与所使用算法的质量以及它们的实现效果相关。

在本节中，我们讨论当前用于反汇编机器代码的两种基本算法。在介绍这些算法时，我们还将指出它们的不足之处，以便让您为反汇编器可能出现的失败情况做好准备。通过理解反汇编器的局限性，您将能够手动干预，以提高反汇编输出的整体质量。

#### *基本反汇编算法*

首先，让我们开发一个简单的算法，用于接受机器语言作为输入，并生成汇编语言作为输出。在此过程中，您将了解自动化反汇编过程背后的挑战、假设和折衷：

1.  反汇编过程的第一步是确定要反汇编的代码区域。这并不总是看起来那么简单。指令通常与数据混合在一起，因此区分它们非常重要。在最常见的情况下，反汇编可执行文件时，文件将遵循常见的可执行文件格式，如 Windows 上使用的*可移植可执行（PE）*格式和许多 Unix 系统上常用的*可执行与可链接格式（ELF）*。这些格式通常包含机制（通常以分层文件头的形式）来定位包含代码的文件部分及其入口点。^(2)

1.  给定一条指令的地址，下一步是读取该地址（或文件偏移量）处的值，并执行表查找，将二进制操作码值与其汇编语言助记符匹配。根据所反汇编指令集的复杂性，这可能是一个简单的过程，也可能涉及一些额外的操作，例如理解可能修改指令行为的前缀，并确定指令所需的操作数。对于具有可变长度指令的指令集，例如 Intel x86 指令集，可能需要检索额外的指令字节，以完全反汇编一条指令。

1.  一旦指令被取出并解码了所需的操作数，它的汇编语言等效指令将被格式化并输出，作为反汇编列表的一部分。可能可以选择多种汇编语言输出语法。例如，x86 汇编语言的两种主要格式是 Intel 格式和 AT&T 格式。

1.  在输出一条指令后，我们需要推进到下一条指令，并重复之前的过程，直到我们反汇编完文件中的每一条指令。

**X86 汇编语法：AT&T 与 Intel**

汇编源代码主要使用两种语法：AT&T 和 Intel。尽管它们都是二代语言，但两者在语法上差异很大——从变量、常量和寄存器访问，到段和指令大小重写，再到间接寻址和偏移。AT&T 汇编语法的特点是使用 `%` 符号作为所有寄存器名称的前缀，使用 `$` 作为字面常量（也称为 *立即数操作数*）的前缀，以及操作数顺序，其中源操作数位于左侧，目标操作数位于右侧。使用 AT&T 语法，将 4 加到 `EAX` 寄存器的指令是 `add $0x4,%eax`。GNU 汇编器（`as`）和许多其他 GNU 工具（包括 `gcc` 和 `gdb`）默认使用 AT&T 语法。

Intel 语法与 AT&T 的区别在于，它不需要寄存器或字面量前缀，操作数的顺序也被颠倒，源操作数出现在右侧，目标操作数出现在左侧。使用 Intel 语法的相同 `add` 指令将是 `add eax,0x4`。采用 Intel 语法的汇编器包括 Microsoft 汇编器（MASM）和 Netwide 汇编器（NASM）。

存在多种算法用于确定从哪里开始反汇编，如何选择下一条要反汇编的指令，如何区分代码与数据，以及如何判断最后一条指令是否已经反汇编完成。两种主要的反汇编算法是线性扫描和递归下降。

#### *线性扫描反汇编*

*线性扫描*反汇编算法采用一种非常直接的方法来定位需要反汇编的指令：一条指令结束后，另一条指令开始。因此，最困难的决策是从哪里开始以及何时停止。通常的解决方案是假设程序中标记为代码的部分（通常由程序文件的头部指定）包含机器语言指令。反汇编从代码段中的第一个字节开始，以线性方式遍历该段，逐条反汇编指令，直到到达该段的末尾。不会尝试通过识别非线性指令（如跳转）来理解程序的控制流。

在反汇编过程中，可以保持一个指针来标记当前正在反汇编的指令的起始位置。作为反汇编过程的一部分，会计算每条指令的长度，并用它来确定下一条指令的位置。对于固定长度指令集（例如 MIPS），反汇编相对容易一些，因为定位后续指令很直接。

线性扫描算法的主要优点在于它可以完全覆盖程序的代码段。线性扫描方法的一个主要缺点是，它未能考虑可能与代码混合的数据。这在清单 1-1 中得到了体现，该清单展示了使用线性扫描反汇编器反汇编的一个函数的输出。

```
    40123f:   55                       push ebp

    401240:   8b ec                    mov ebp,esp

    401242:   33 c0                    xor eax,eax

    401244:   8b 55 08                 mov edx,DWORD PTR [ebp+8]

    401247:   83 fa 0c                 cmp edx,0xc

    40124a:   0f 87 90 00 00 00        ja 0x4012e0

    401250:   ff 24 95 57 12 40 00     jmp DWORD PTR [edx*4+0x401257]➊

➋  401257:   e0 12                    loopne 0x40126b

    401259:   40                       inc eax

    40125a:   00 8b 12 40 00 90        add BYTE PTR [ebx-0x6fffbfee],cl

    401260:   12 40 00                 adc al,BYTE PTR [eax]

    401263:   95                       xchg ebp,eax

    401264:   12 40 00                 adc al,BYTE PTR [eax]

    401267:   9a 12 40 00 a2 12 40     call 0x4012:0xa2004012

    40126e:   00 aa 12 40 00 b2        add BYTE PTR [edx-0x4dffbfee],ch

    401274:   12 40 00                 adc al,BYTE PTR [eax]

    401277:   ba 12 40 00 c2           mov edx,0xc2004012

    40127c:   12 40 00                 adc al,BYTE PTR [eax]

    40127f:   ca 12 40                 lret 0x4012

    401282:   00 d2                    add dl,dl

    401284:   12 40 00                 adc al,BYTE PTR [eax]

    401287:   da 12                    ficom DWORD PTR [edx]

    401289:   40                       inc eax

    40128a:   00 8b 45 0c eb 50        add BYTE PTR [ebx+0x50eb0c45],cl

    401290:   8b 45 10                 mov eax,DWORD PTR [ebp+16]

    401293:   eb 4b                    jmp 0x4012e0
```

*清单 1-1：线性扫描反汇编*

这个函数包含了一个 `switch` 语句，并且在此案例中使用的编译器选择通过跳转表来实现 `switch`，以解析 case 标签目标。此外，编译器选择将跳转表嵌入到函数内部。`jmp` 语句 ➊ 引用了一个地址表 ➋。遗憾的是，反汇编器将地址表当作一系列指令来处理，并错误地生成了以下的汇编语言表示。

如果我们将跳转表 ➋ 中的连续 4 字节组视为小端值^(3)，我们会发现每个值代表一个指向附近地址的指针，而这些地址实际上是多个跳转的目的地（`004012e0`、`0040128b`、`00401290`，等等）。因此，`loopne` 指令 ➋ 根本不是一条指令。相反，它表明线性扫描算法未能正确区分嵌入的数据和代码。

线性扫描被 GNU 调试器（gdb）、微软的 WinDbg 调试器和 `objdump` 工具所使用。

#### *递归下降反汇编*

*递归下降* 反汇编算法采取不同的方法来定位指令：它侧重于控制流的概念，决定是否应当反汇编某条指令，依据的是它是否被其他指令引用。要理解递归下降，帮助理解的一个方法是根据指令如何影响指令指针来分类指令。

##### 顺序流指令

*顺序流指令* 将执行传递给紧跟其后的指令。顺序流指令的例子包括简单的算术指令，如 `add`；寄存器到内存的转移指令，如 `mov`；以及栈操作，如 `push` 和 `pop`。对于这些指令，反汇编过程与线性扫描相同。

##### 条件分支指令

*条件跳转指令*，如 x86 的`jnz`，提供两条可能的执行路径。如果条件为真，则跳转被执行，程序计数器必须更改为反映跳转目标。然而，如果条件为假，执行将继续按线性方式进行，并且可以使用线性扫描方法来反汇编下一条指令。由于在静态环境中通常无法确定条件测试的结果，递归下降算法会反汇编两条路径，通过将目标指令的地址添加到待反汇编的地址列表中，推迟对跳转目标指令的反汇编。

##### 无条件跳转指令

*无条件跳转*不遵循线性流模型，因此递归下降算法会以不同的方式处理它们。与顺序流指令一样，执行可以流向只有一条指令；然而，该指令不一定紧接着跳转指令。实际上，如示例 1-1 所示，没有要求指令必须紧跟在无条件跳转后。因此，没有理由立即反汇编紧随无条件跳转后的字节。

递归下降反汇编器尝试确定无条件跳转的目标，并在目标地址继续反汇编。不幸的是，一些无条件跳转会给递归下降反汇编器带来问题。当跳转指令的目标依赖于运行时值时，可能无法通过静态分析确定跳转的目的地。x86 指令`jmp` `rax`就演示了这个问题。只有在程序实际运行时，`rax`寄存器才包含一个值。由于在静态分析期间寄存器没有值，我们无法确定跳转指令的目标，因此也无法确定继续反汇编的地方。

##### 函数调用指令

*函数调用指令*的操作方式类似于无条件跳转指令（包括反汇编器无法确定像`call rax`这样的指令目标），但额外的期望是，在函数完成后，执行通常会返回到紧接在调用指令之后的指令。在这一点上，它们与条件跳转指令相似，因为它们生成两个执行路径。调用指令的目标地址会被添加到待定反汇编的地址列表中，而紧随调用指令的指令则按线性扫描的方式反汇编。

如果程序在从调用的函数返回时没有按照预期行为执行，递归下降可能会失败。例如，函数中的代码可以故意修改该函数的返回地址，以便在完成后，控制返回到一个不同于反汇编器预期的地址。以下是不正确的列表示例，其中函数`badfunc`在返回调用者之前，仅仅将返回地址加 1：

```
badfunc proc near

48 FF 04 24  inc qword ptr [rsp] ; increments saved return addr

C3           retn

badfunc endp

 ; -------------------------------------

label:

E8 F6 FF FF FF   call badfunc

05 48 89 45 F8   add eax, F8458948h➊
```

结果是，控制并没有实际传递到`add`指令➊，它位于调用`badfunc`之后。接下来是正确的反汇编：

```
badfunc proc near

48 FF 04 24  inc qword ptr [rsp]

C3           retn

badfunc endp

; -------------------------------------

label:

E8 F6 FF FF FF  call badfunc

05              db 5        ;formerly the first byte of the add instruction

48 89 45 F8     mov [rbp-8], rax➊
```

这个列表更清晰地展示了程序的流程，其中`badfunc`函数实际上返回到`mov`指令➊。理解这一点很重要：线性扫描反汇编器也无法正确地反汇编这段代码，尽管原因略有不同。

##### 返回指令

在某些情况下，递归下降算法会走到无路可走的地步。一个函数的*返回指令*（例如 x86 的`ret`）并没有提供有关下一条指令的信息。如果程序真的在运行，地址会从运行时堆栈的顶部获取，并在该地址恢复执行。反汇编器无法访问堆栈，因此反汇编过程会突然中断。在这一点上，递归下降反汇编器会转向它之前保留的待反汇编地址列表。一个地址从该列表中移除，反汇编过程会从该地址继续。这就是递归过程，赋予了反汇编算法其名称。

递归下降算法的主要优势之一是它在区分代码和数据方面的卓越能力。作为一种基于控制流的算法，它不太可能错误地将数据值反汇编为代码。递归下降的主要缺点是无法跟踪间接代码路径，例如使用指针表查找目标地址的跳转或调用。然而，通过加入一些启发式方法来识别指向代码的指针，递归下降反汇编器可以提供非常完整的代码覆盖，并且能够很好地区分代码和数据。列表 1-2 展示了使用 Ghidra 递归下降反汇编器对前面列表 1-1 中展示的相同 switch 语句的输出。

```
0040123f  PUSH   EBP

00401240  MOV    EBP,ESP

00401242  XOR    EAX,EAX

00401244  MOV    EDX,dword ptr [EBP + param_1]

00401247  CMP    EDX,0xc

0040124a  JA     switchD_00401250::caseD_0

        switchD_00401250::switchD

00401250  JMP    dword ptr [EDX*0x4 + ->switchD_00401250::caseD_0] = 004012e0

        switchD_00401250::switchdataD_00401257

00401257  addr   switchD_00401250::caseD_0

0040125b  addr   switchD_00401250::caseD_1

0040125f  addr   switchD_00401250::caseD_2

00401263  addr   switchD_00401250::caseD_3

00401267  addr   switchD_00401250::caseD_4

0040126b  addr   switchD_00401250::caseD_5

0040126f  addr   switchD_00401250::caseD_6

 00401273  addr   switchD_00401250::caseD_7

00401277  addr   switchD_00401250::caseD_8

0040127b  addr   switchD_00401250::caseD_9

0040127f  addr   switchD_00401250::caseD_a

00401283  addr   switchD_00401250::caseD_b

00401287  addr   switchD_00401250::caseD_c

        switchD_00401250::caseD_1

0040128b  MOV    EAX,dword ptr [EBP + param_2]

0040128e  JMP    switchD_00401250::caseD_00040128E
```

*列表 1-2：递归下降反汇编*

请注意，这段二进制代码已被识别为一个 switch 语句，并进行了相应的格式化。理解递归下降过程将帮助我们识别 Ghidra 可能产生不尽人意的反汇编情况，并允许我们开发策略来改善 Ghidra 的输出。

### 总结

在使用反汇编器时，深入理解反汇编算法是否必要？不。是否有用？是的！在进行逆向工程时，和工具作斗争是你最不希望花时间做的事。Ghidra 的众多优点之一是，作为一个交互式反汇编器，它提供了大量的机会让你引导和覆盖它的决策。最终的结果往往是一个既全面又准确的反汇编。

在下一章中，我们将回顾一些在许多逆向工程场景中非常有用的现有工具。虽然这些工具与 Ghidra 没有直接关系，但它们中的许多对 Ghidra 产生了影响，并且帮助解释了 Ghidra 用户界面中各种信息展示的多样性。
