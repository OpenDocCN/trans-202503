# 第八章：**跨站请求伪造攻击**

![image](img/common01.jpg)

在上一章中，你看到攻击者如何通过跨站脚本攻击将 JavaScript 注入用户的网页浏览器，通常通过评论区、搜索结果或 URL 等页面元素。现在，你将看到攻击者如何利用恶意链接来入侵用户。

没有任何网站是孤立的。由于你的网站有一个公共 URL，其他站点会频繁地链接到它，作为站点所有者，你通常应当鼓励这种行为。更多指向你网站的外部链接意味着更多的流量和更好的搜索引擎排名。

然而，并不是所有链接到你网站的行为都是出于好意。攻击者可以诱使用户点击一个恶意链接，这个链接会触发不希望发生的或意外的副作用。这就是所谓的 *跨站请求伪造 (CSRF 或 XSRF)*。安全研究人员有时将 CSRF 发音为“海浪”。

CSRF 是一种非常常见的漏洞，几乎所有主流网站在某一时刻都曾暴露过这种问题。攻击者利用 CSRF 窃取 Gmail 联系人列表、在亚马逊上触发一键购买操作、甚至更改路由器配置。本章将探讨 CSRF 攻击通常是如何运作的，并展示一些能防范此类攻击的编码实践。

### CSRF 攻击的结构

攻击者通常通过利用那些实现 `GET` 请求并且能够改变网站服务器状态的网站发起 CSRF 攻击。`GET` 请求在受害者点击链接时触发，允许攻击者将误导性链接嵌入目标站点，从而执行意想不到的操作。`GET` 请求是唯一一种将请求的所有内容都包含在 URL 中的 HTTP 请求，因此它们在 CSRF 攻击中具有独特的脆弱性。

在 Twitter 的早期版本中，你可以通过 `GET` 请求创建推文，而不是现在网站使用的 `POST` 请求。这一疏忽使得 Twitter 易受 CSRF 攻击：攻击者可以创建 URL 链接，当点击这些链接时，会在用户的时间线上发布内容。列表 8-1 展示了其中一个这样的 URL 链接。

```
https://twitter.com/share/update?status=in%20ur%20twitter%20CSRF-ing%20ur%20tweets
```

*列表 8-1：一个链接，在某一时刻，点击后会通过 Twitter 进行 CSRF 攻击，将文本* 发送到受害者的时间线 *上*

一名机智的黑客利用这个漏洞在 Twitter 上创建了一个病毒式的 *蠕虫*。由于他们可以通过一个 `GET` 请求发送推文，他们构造了一个恶意链接，点击后会发布一条包含猥亵信息的推文 *并且* 带有相同的恶意链接。当推文的读者点击第一个受害者推文中的链接时，他们也会被欺骗并发送相同内容的推文。

黑客欺骗了一些受害者点击了恶意链接，这些受害者在时间线上发出了意外的推文。随着越来越多的用户阅读这些原始推文并出于好奇点击了其中的嵌入链接，他们也发出了相同的内容。很快，成千上万的 Twitter 用户被诱骗发表了他们想要骚扰山羊的愿望（最初推文的内容）。第一个 Twitter 蠕虫诞生了，Twitter 开发团队忙于修补这个安全漏洞，以防事态失控。

### 缓解措施 1：遵循 REST 原则

为了保护你的用户免受 CSRF 攻击，确保你的`GET`请求不会改变服务器的状态。你的网站应该仅使用`GET`请求来获取网页或其他资源。你应该通过`PUT`、`POST`或`DELETE`请求执行那些改变服务器状态的操作——例如，用户登录或登出、重置密码、发布帖子或关闭账户。这种设计理念，被称为*表现层状态转移（REST）*，除了防范 CSRF 攻击外，还有许多其他好处。

REST 原则要求你根据操作的意图，将网站操作映射到适当的 HTTP 方法。你应该使用`GET`请求获取数据或页面，使用`PUT`请求在服务器上创建新对象（例如评论、上传或消息），使用`POST`请求修改服务器上的对象，使用`DELETE`请求删除对象。

并不是所有的操作都有明显对应的 HTTP 方法。例如，当用户登录时，是否认为用户是在创建一个新会话还是修改他们的状态，这个问题是一个哲学讨论。然而，在防止 CSRF 攻击方面，关键是避免将会改变服务器状态的操作分配给`GET`请求。

保护你的`GET`请求并不意味着其他类型的请求就没有漏洞，正如我们在第二个缓解措施中看到的那样。

### 缓解措施 2：实现反 CSRF Cookies

关闭你的`GET`请求可以防止大多数 CSRF 攻击，但你仍然需要防范使用其他 HTTP 方法的请求。使用这些方法的攻击比基于`GET`的 CSRF 攻击要少得多，且需要更多的工作，但如果攻击者认为收益足够，他们可能会尝试这些攻击。

例如，黑客可以通过让受害者提交一个托管在第三方网站上的恶意表单或脚本来欺骗用户发起一个`POST`请求。如果你的站点在响应`POST`请求时执行敏感操作，那么你需要使用反 CSRF cookies 来确保这些请求仅在你的站点内发起。敏感操作应该仅通过你自己的网站登录表单和 JavaScript 触发，而不是通过可能欺骗用户执行意外操作的恶意页面。

*反-CSRF cookie* 是一个随机化的字符串 token，Web 服务器将其写入名为 cookie 参数的字段。回想一下，cookies 是通过 HTTP 头在浏览器和 Web 服务器之间传递的小块文本。如果 Web 服务器返回一个包含头部值的 HTTP 响应，例如 `Set-Cookie: _xsrf=5978e29d4ef434a1`，则浏览器将在下一个 HTTP 请求中以 `Cookie: _xsrf=5978e29d4ef434a1` 的形式返回相同的信息。

安全的网站使用反-CSRF cookies 来验证 `POST` 请求是否来源于托管在相同 Web 域上的页面。网站上的 HTML 页面将相同的字符串 token 作为 `<input type="hidden" name="_xsrf" value="5978e29d4ef434a1">` 元素添加到任何用于生成 `POST` 请求的 HTML 表单中。当用户提交表单到服务器时，如果返回的 cookie 中的 `_xsrf` 值与请求体中的 `_xsrf` 值不匹配，服务器会完全拒绝该请求。通过这种方式，服务器验证并确保请求来自站点内部，而不是来自恶意的第三方网站；只有当网页从相同的域加载时，浏览器才会发送所需的 cookie。

大多数现代 Web 服务器都支持反-CSRF cookies。请确保查阅你所选 Web 服务器的安全文档，了解它们如何实现这些 cookies，因为不同的 Web 服务器语法稍有不同。清单 8-2 显示了一个包含反-CSRF 保护的 Tornado Web 服务器模板文件。

```
<form action="/new_message" method="post">
❶ {% module xsrf_form_html() %}
   <input type="text" name="message"/>
   <input type="submit" value="Post"/>
</form>
```

*清单 8-2：一个包含反-CSRF 保护的 Tornado Web 服务器 Python 模板文件*

在这个例子中，`xsrf_form_html()` 函数 ❶ 生成一个随机化的 token，并将其作为 `<input type="hidden" name="_xsrf" value="5978e29d4ef434a1">` 元素写入 HTML 表单中。然后，Tornado Web 服务器将在 HTTP 响应头中写出相同的 token，格式为 `Set-Cookie: _xsrf=5978e29d4ef434a1`。当用户提交表单时，Web 服务器会验证表单中的 token 和返回的 `Cookie` 头中的 token 是否匹配。浏览器的安全模型将根据 *同源策略* 返回 cookies，因此这些 cookie 的值只能由 Web 服务器设置。因此，服务器可以确认 `POST` 请求是从主机网站发出的。

你应该使用反-CSRF cookies 来验证通过 JavaScript 发出的 HTTP 请求，这样你也可以保护 `PUT` 和 `DELETE` 请求。JavaScript 需要从 HTML 中提取反-CSRF token，并将其传递回服务器以进行 HTTP 请求。

在实现反-CSRF cookies 后，你的网站应该更加安全。现在你需要关闭最后一个漏洞，确保攻击者无法窃取你的反-CSRF token 并将其嵌入恶意代码中。

### 缓解措施 3：使用 SameSite Cookie 属性

你必须实现的最终防护措施是，在设置 cookie 时指定`SameSite`属性。默认情况下，当浏览器向你的网站发送请求时，它会将网站上最后设置的 cookie 附加到请求中，无论请求的来源是什么。这意味着恶意的跨站请求仍然会携带你之前设置的任何安全 cookie。单靠这一点并不能完全破坏防 CSRF 措施，但如果攻击者从你的 HTML 表单中窃取了安全令牌，并将其安装到自己的恶意表单中，他们仍然可以发起 CSRF 攻击。

在设置 cookie 时指定`SameSite`属性，告诉浏览器当请求来自外部域（如攻击者设立的恶意网站）时，应该剥离 cookie。通过在示例 8-3 中设置`SameSite=Strict`语法，可以确保浏览器仅在来自你自己网站的请求中发送 cookie。

```
Set-Cookie: _xsrf=5978e29d4ef434a1; SameSite=Strict;
```

*示例 8-3：将 SameSite 属性设置为我们的防 CSRF cookie，确保该 cookie 仅附加到来自我们网站的请求。*

在所有的 cookie 上设置`SameSite`属性是个好主意，不仅仅是那些用于 CSRF 保护的 cookie。然而有一个警告：如果你使用 cookie 进行会话管理，将`SameSite`属性设置到你的会话 cookie 上，会使得所有来自其他网站的请求无法携带该 cookie。这意味着任何指向你网站的外部链接都会迫使用户重新登录。

对于已经在你网站上打开会话的用户来说，这种行为可能会让人有些恼火。试想，如果每次有人分享视频，你都需要重新登录 Facebook，那该有多烦人？为了防止这种情况，示例 8-4 展示了`SameSite`属性的一个更实用的值，`Lax`，它只允许来自其他网站的`GET`请求发送 cookie。

```
Set-Cookie: session_id=82938d911e13f3; SameSite=Lax;
```

*示例 8-4：在 HTTP cookie 上设置 SameSite 属性可以使 cookie 仅在 GET 请求时生效。*

这使得你的网站可以无缝链接，但剥夺了攻击者伪造恶意操作（如`POST`请求）的能力。只要你的`GET`请求没有副作用，这个设置就同样安全。

### 奖金缓解：要求重新认证敏感操作

你可能会注意到，当你执行敏感操作时，一些网站会强制要求你重新确认登录信息，例如更改密码或发起支付。这被称为*重新认证*，它是防止 CSRF 攻击的一种常见方式，因为它明确地提示用户你即将执行一些重要且可能危险的操作。

重新认证还有一个积极的副作用，即保护用户免受在共享或被盗设备上不小心保持登录状态的风险。如果你的网站处理金融交易或机密数据，你应该强烈考虑在用户执行敏感操作时强制要求他们重新输入凭据。

### 总结

攻击者可以通过其他网站的网络请求诱使用户执行不希望的操作。解决这种跨站请求伪造（CSRF）攻击的方法有三种。

首先，确保你的`GET`请求没有副作用，这样当用户点击恶意链接时，服务器状态不会发生变化。其次，使用反 CSRF cookies 来保护其他类型的请求。第三，设置这些 cookies 时，使用`SameSite`属性，以便从由其他网站生成的请求中剥离 cookies。

对于你网站上的一些非常敏感的操作，要求用户在执行这些操作时重新认证自己是一个好主意。这为防御 CSRF 攻击增加了一层额外的保护，并且如果用户不小心在共享或被盗的设备上保持登录状态，也能保护他们。

在下一章中，你将学习黑客如何在认证过程中利用漏洞。
