## **10**

**会话劫持**

![image](img/common01.jpg)

当一个网站成功验证用户身份时，浏览器和服务器会打开一个会话。*会话*是一个 HTTP 会话，其中浏览器发送一系列与用户操作对应的 HTTP 请求，web 服务器识别它们来自同一个已验证的用户，而无需用户在每个请求中重新登录。

如果黑客能够访问或伪造浏览器发送的会话信息，他们就能够访问你网站上任何用户的账户。幸运的是，现代的网络服务器包含了安全的会话管理代码，这使得攻击者几乎不可能操控或伪造会话。然而，即便服务器的会话管理功能没有漏洞，黑客仍然可以在会话进行中窃取其他用户的有效会话；这被称为*会话劫持*。

会话劫持漏洞通常比前一章讨论的身份验证漏洞更具风险，因为它们允许攻击者访问任何用户的账户。这是一个极具诱惑力的前景，黑客们已经找到了许多劫持会话的方法。

在本章中，你将首先了解网站如何实现会话管理。然后，你将了解黑客劫持会话的三种方式：窃取 Cookie、会话固定和利用弱会话 ID。

### **会话的工作原理**

要理解攻击者如何劫持会话，首先你需要了解用户与 web 服务器打开会话时发生了什么。

当用户在 HTTP 下进行身份验证时，web 服务器会在登录过程中为其分配一个会话标识符。*会话标识符（会话 ID）*—通常是一个大而随机生成的数字—是浏览器在每次随后的 HTTP 请求中需要传输的最小信息，以便服务器能够继续与已验证的用户进行 HTTP 会话。web 服务器识别随每个请求提供的会话 ID，将其映射到相应的用户，并代表该用户执行操作。

请注意，会话 ID 必须是临时分配的值，并且与用户名不同。如果浏览器使用的会话 ID 仅仅是用户名，黑客就可以假装成任何他们想要的用户。设计上，只有极少数可能的会话 ID 应该与服务器上有效的会话相对应。（如果不是这样，网络服务器就表现出一个弱会话漏洞，我们将在本章后面讨论这个问题。）

除了用户名外，web 服务器通常会将其他*会话状态*与会话 ID 一起存储，包含有关用户最近活动的相关信息。例如，会话状态可能包含用户访问过的页面列表，或当前放入购物车的商品。

现在我们了解了当用户和 web 服务器打开会话时发生了什么，让我们来看看网站是如何实现这些会话的。通常有两种常见的实现方式，通常被描述为服务器端会话和客户端会话。让我们回顾一下这些方法是如何工作的，这样你就能看到漏洞发生的地方。

#### ***服务器端会话***

在传统的会话管理模型中，web 服务器将会话状态保存在内存中，且 web 服务器和浏览器来回传递会话标识符。这被称为*服务器端会话*。Listing 10-1 展示了 Ruby on Rails 实现的服务器端会话。

```
# Get a session from the cache.
def find_session(env, sid)
  unless sid && (session = @cache.read(cache_key(sid))❸)
 sid, session = generate_sid❶, {}
  end
  [sid, session]
end

# Set a session in the cache.
def write_session(env, sid, session, options)
  key = cache_key(sid)
  if session
  ❷ @cache.write(key, session, expires_in: options[:expire_after])
  else
    @cache.delete(key)
  end
  sid
end
```

*Listing 10-1: Ruby on Rails 使用会话 ID (sid) 实现服务器端会话。*

会话对象在 ❶ 创建，写入服务器内存 ❷，然后从内存重新加载 ❸。

从历史上看，web 服务器曾尝试过多种方式传递会话 ID：要么在 URL 中，要么作为 HTTP 头部，要么在 HTTP 请求的主体中。到目前为止，web 开发社区普遍认同的最常见（且可靠）机制是将会话 ID 作为会话 cookie 发送。当使用*会话 cookies*时，web 服务器会在 HTTP 响应的 `Set-Cookie` 头部返回会话 ID，浏览器则使用 `Cookie` 头部将相同的信息附加到随后的 HTTP 请求中。

自从 1995 年 Netscape 首次引入 cookies 以来，cookies 就一直是超文本传输协议的一部分。与 HTTP 原生身份验证不同，它们几乎被所有网站使用。（由于欧盟的立法，你应该对此非常了解：根据欧盟法律，网站必须通知你它们正在使用 cookies。）

服务器端会话已被广泛实现，通常非常安全。然而，它们确实有扩展性限制，因为 web 服务器必须将会话状态保存在内存中。

这意味着，在身份验证时，只有*一个* web 服务器会知道已经建立的会话。如果随后的相同用户的 web 请求被定向到*不同*的 web 服务器，新的 web 服务器需要能够识别回访的用户，因此 web 服务器需要有一种共享会话信息的方式。

通常，这需要将会话状态写入共享缓存或数据库中，每次请求时，且每个 web 服务器在收到新的 HTTP 请求时都需要读取缓存的会话状态。这两者都是时间和资源消耗型的操作，可能会限制拥有大量用户群体的网站的响应能力，因为每增加一个用户，就会给会话存储带来显著的负担。

#### ***客户端会话***

由于服务器端会话被证明难以扩展到大型网站，Web 服务器开发者发明了客户端会话。实现*客户端会话*的 Web 服务器会将所有会话状态放入 cookie，而不是仅仅在 `Set-Cookie` 头中传递会话 ID。服务器在设置会话状态到 HTTP 头之前，会将会话状态序列化为文本。通常，Web 服务器会将会话状态编码为 JavaScript 对象表示法（JSON），并在返回服务器时进行反序列化。列表 10-2 展示了 Ruby on Rails 实现客户端会话的一个示例。

```
def set_cookie(request, session_id, cookie)
  cookie_jar(request)[@key] = cookie
end

def get_cookie(req)
  cookie_jar(req)[@key]
end

def cookie_jar(request)
  request.cookie_jar.signed_or_encrypted
end
```

*列表 10-2：Ruby on Rails 代码将会话数据存储为客户端 cookie*

通过使用客户端会话，网站的 Web 服务器不再需要共享状态。每个 Web 服务器都有重新建立会话所需的所有信息，只要接收到 HTTP 请求。这在你试图扩展到成千上万的并发用户时是一个巨大的优势！

然而，客户端会话确实会带来一个明显的安全问题。对于客户端会话的简单实现，恶意用户可以轻松地篡改会话 cookie 的内容，甚至完全伪造它们。这意味着 Web 服务器必须以一种防止干扰的方式来编码会话状态。

一种保护客户端会话 cookie 的常见方式是，在发送给客户端之前加密序列化后的 cookie。然后，当浏览器返回该 cookie 时，Web 服务器解密它。这种方法使得会话状态在客户端完全不可见。任何试图篡改或伪造 cookie 的行为都会破坏已编码的会话，并使 cookie 无法读取。服务器将简单地注销恶意用户，并将其重定向到错误页面。

另一种稍微轻量级的保护会话 cookie 的方法是，在发送 cookie 时为其添加数字签名。*数字签名*充当某些输入数据的唯一“指纹”——在这种情况下，就是序列化的会话状态——任何人只要拥有最初用于生成签名的签名密钥，就可以轻松地重新计算它。对 cookie 进行数字签名可以让 Web 服务器检测到尝试篡改会话状态的行为，因为如果有篡改，服务器会计算出不同的签名值，并拒绝该会话。

相比加密 cookie，签名 cookie 仍然允许一个好奇的用户在浏览器调试器中读取会话数据。如果你在存储关于用户的数据——比如跟踪信息——并且不希望他们看到这些数据时，请牢记这一点！

### **攻击者如何劫持会话**

现在我们已经讨论了会话以及网站如何实现它们，接下来看看攻击者如何劫持会话。攻击者通常通过三种主要方法来劫持会话：cookie 偷窃、会话固定攻击以及利用弱会话 ID。

#### ***Cookie 偷窃***

随着 cookies 的广泛使用，攻击者通常通过窃取经过身份验证的用户的 `Cookie` 头的值来实现会话劫持。攻击者通常通过三种技术之一窃取 cookies：在用户与网站交互时注入恶意 JavaScript（跨站脚本攻击）、嗅探网络流量以拦截 HTTP 头部（中间人攻击），或在用户已认证后触发意外的 HTTP 请求（跨站请求伪造）。

幸运的是，现代浏览器实现了简单的安全措施，可以保护您的会话 cookies 免受这三种技术的攻击。您只需通过向服务器返回的 `Set-Cookie` 响应头添加关键字，就可以启用这些安全措施，如清单 10-3 所示。

```
Set-Cookie: session_id=278283910977381992837; HttpOnly; Secure; SameSite=Lax
```

*清单 10-3：通过关键字指令组合保护的会话 cookie 出现在 HTTP 响应中，防止会话劫持*

让我们回顾一下三种 cookie 被盗的技术，以及可以缓解它们的关键字。

##### **跨站脚本攻击**

攻击者通常使用*跨站脚本攻击*（我们在第七章中详细讨论过）来窃取会话 cookie。攻击者会尝试利用注入到用户浏览器中的 JavaScript 来读取用户的 cookies，并将它们发送到攻击者控制的外部 Web 服务器。攻击者随后会在 Web 服务器的日志文件中*收集*这些 cookies，然后将 cookie 值复制粘贴到浏览器会话中——更可能的是，将它们添加到脚本中——以在被劫持用户的会话下执行操作。

为了通过跨站脚本攻击来防止会话劫持，请在 Set-Cookie 响应头中将所有 cookies 标记为 `HttpOnly`。这会告诉浏览器不要将 cookies 提供给 JavaScript 代码。在 `Set-Cookie` 响应头中附加 `HttpOnly` 关键字，如清单 10-4 所示。

```
 Set-Cookie: session_id=278283910977381992837; HttpOnly
```

*清单 10-4：将您的 cookies 标记为 HttpOnly，以防止 JavaScript 访问它们。*

允许客户端 JavaScript 访问 cookies 的理由非常少，因此这种方法几乎没有什么缺点。

##### **中间人攻击**

攻击者还可以通过使用*中间人攻击*来窃取 cookies：攻击者找到一种方法，坐在浏览器和 Web 服务器之间，读取来回传输的网络流量。为了防止通过中间人攻击窃取 cookies，您的网站应该使用 HTTPS。您将在第十三章中学习如何启用 HTTPS。

在您启用 Web 服务器上的 HTTPS 后，您应该将 cookies 标记为 `Secure`，如清单 10-5 所示，这样浏览器就会知道永远不会通过 HTTP 发送未加密的 cookies。

```
Set-Cookie: session_id=278283910977381992837; Secure
```

*清单 10-5：将 cookies 标记为 secure 意味着将 Secure 关键字添加到 Set-Cookie 响应头中。*

大多数 web 服务器被配置为响应 HTTP 和 HTTPS，但会将 HTTP URL 重定向到 HTTPS 对应的 URL。将 cookies 标记为 `Secure` 会在重定向发生之前，防止浏览器传输 cookie 数据。

##### **跨站请求伪造**

攻击者劫持会话的最终方式是通过 *跨站请求伪造*（在第八章中详细介绍）。使用 CSRF 的攻击者不需要访问用户的会话 cookie。相反，他们只需要诱使受害者点击指向你网站的链接。如果用户已经在你的网站上保持会话，浏览器会随着链接触发的 HTTP 请求一起发送会话 cookie，这可能导致用户无意中执行某些敏感操作（例如点赞攻击者试图推广的项目）。

为了防止 CSRF 攻击，你可以在 cookies 中标记 `SameSite` 属性，这会指示浏览器仅在由 *你* 的网站生成的 HTTP 请求中发送会话 cookies。浏览器会从其他 HTTP 请求中剥离会话 cookies，比如那些通过点击电子邮件中的链接触发的请求。

`SameSite` 属性有两个设置：`Strict` 和 `Lax`。如示例 10-6 所示，`Strict` 设置的优点是从所有由外部网站触发的 HTTP 请求中剥离 cookies。

```
Set-Cookie: session_id=278283910977381992837; SameSite=Strict
```

*示例 10-6：Strict 设置将剥离从外部网站生成的请求中的 cookies。*

`Strict` 设置如果用户通过社交媒体分享你的内容，可能会让人感到烦恼，因为该设置会强制任何点击链接的人重新登录才能查看内容。为了解决这个问题，你可以通过使用 `SameSite=Lax` 设置，配置浏览器仅在 `GET` 请求中允许 cookies，如示例 10-7 所示。

```
Set-Cookie: session_id=278283910977381992837; SameSite=Lax
```

*示例 10-7：Lax 设置可以在社交媒体上无痛地分享链接，同时仍然防止通过 CSRF 劫持会话的攻击。*

这个 `SameSite=Lax` 设置指示浏览器将 cookies 附加到传入的 `GET` 请求中，同时从其他类型的请求中剥离 cookies。因为网站通常通过 `POST`、`PUT` 或 `DELETE` 请求执行敏感操作（例如写内容或发送消息），所以攻击者无法诱使受害者执行这些类型的敏感操作。

#### ***会话固定***

在互联网的早期历史中，许多浏览器没有实现 cookies，因此 web 服务器找到了其他传递会话 ID 的方法。最流行的方法是 *URL 重写*——将会话 ID 附加到用户访问的每个 URL 后面。直到今天，*Java Servlet 规范*仍描述了当 cookies 不可用时，开发人员如何将会话 ID 添加到 URL 的末尾。示例 10-8 展示了一个包含会话 ID 的 URL 重写示例。

```
http://www.example.com/catalog/index.html;jsessionid=1234
```

*示例 10-8：一个传递会话 ID 1234 的 URL 示例*

现在所有浏览器都支持 cookie，因此 URL 重写已经成为一种过时的做法。然而，遗留的网页堆栈可能仍然配置为接受这种方式的会话 ID，这就引入了几个重大的安全问题。

首先，将会话 ID 写入 URL 会导致它们在日志文件中泄漏。攻击者如果访问到你的日志文件，只需将这些类型的 URL 放入浏览器，就可以劫持用户的会话。

第二个问题是一个名为*会话固定（session fixation）*的漏洞。当存在会话固定漏洞的网页服务器在 URL 中遇到一个未知的会话 ID 时，它们会要求用户进行身份验证，然后在提供的会话 ID 下建立一个会话。

这使得黑客能够*预先固定*会话 ID，向受害者发送诱人的链接（通常是在未经请求的电子邮件或站点评论区的垃圾邮件中），链接中包含了固定的会话 ID。任何点击该链接的用户都会被劫持会话，因为攻击者只需在自己的浏览器中使用相同的 URL，在预先固定的会话 ID 下进行操作。点击链接并登录的动作会将虚假的会话 ID 转换为一个真实的会话 ID——一个黑客已经知道的 ID。

如果你的网页服务器支持将 URL 重写作为会话跟踪的方式，你应该通过相关的配置选项禁用它。它没有任何实际用途，并且使你暴露在会话固定攻击下。列表 10-9 展示了如何通过编辑*web.xml*配置文件来禁用 Apache Tomcat 7.0 版本中的 URL 重写。

```
<session-config>
     <tracking-mode>COOKIE</tracking-mode>
</session-config>
```

*列表 10-9：指定使用 COOKIE 模式的会话跟踪，在 Apache Tomcat 7.0 中将禁用 URL 重写。*

#### ***利用弱会话 ID***

正如我们之前讨论的，如果攻击者获得了会话 ID，他们可以劫持用户的会话。攻击者可以通过窃取会话 cookie 或通过预先为支持 URL 重写的服务器固定会话来实现这一点。然而，更为粗暴的方法是直接*猜测*会话 ID。由于会话 ID 通常只是数字，如果这些数字足够小或可预测，攻击者可以编写脚本来枚举可能的会话 ID，并与网页服务器进行测试，直到找到有效的会话。

生成真正的随机数在软件中是很困难的。大多数随机数生成算法使用环境因素（例如系统的时钟时间）作为*种子*来生成随机数。如果攻击者能够确定足够的种子值（或者将其减少到合理的潜在值范围），他们可以枚举可能的有效会话 ID 并与服务器进行测试。

早期版本的标准 Apache Tomcat 服务器被发现容易受到这种类型的攻击。安全研究人员发现，随机会话 ID 生成算法的种子是系统时间和内存中的对象的哈希码。研究人员能够利用这些种子来缩小潜在的输入值范围，从而可靠地猜测出会话 ID。

查阅你的 web 服务器文档，确保它使用无法猜测的大型会话 ID，这些 ID 应由强大的随机数生成算法生成。由于安全研究人员常常在攻击者利用之前发现弱的会话 ID 算法，因此你还需要关注安全公告，及时了解何时需要修补 web 堆栈中的漏洞。

### **总结**

当一个网站成功验证用户身份时，浏览器和服务器之间会建立一个会话。会话状态可以存储在服务器端，或者以加密或数字签名的 cookie 形式存储在客户端。

黑客会尝试窃取你的会话 cookie，因此你应该确保它们得到保护。为了防止通过跨站脚本攻击（XSS）进行会话劫持，确保你的 cookie 对 JavaScript 代码不可访问。为了防止通过中间人攻击（MITM）进行会话劫持，确保你的 cookie 仅通过 HTTPS 连接传递。为了防止通过跨站请求伪造（CSRF）进行会话劫持，确保在跨站请求中去除 cookie。你可以通过在 HTTP 响应中的 `Set-Cookie` 头部使用 `HttpOnly`、`SecureOnly` 和 `SameSite` 这几个关键词来添加这些保护。

较旧的 web 服务器可能容易受到会话固定攻击，因此一定要禁用通过 URL 重写传递会话 ID 的方式。有时，web 服务器会使用可猜测的会话 ID，因此要时刻关注软件堆栈的安全公告，并根据需要进行修补。

在下一章中，你将学习如何正确实现访问控制，以便防止恶意用户访问你的内容或执行他们不应执行的操作。
