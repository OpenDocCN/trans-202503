# 前言

> ![没有标题的图片](img/httpatomoreillycomsourcenostarchimages1853819.png.jpg)
> 
> *从远处看似复杂的东西，仔细看往往会发现其实非常简单。*

初看之下，学习如何使用 Ruby 似乎相当简单。世界各地的开发者都认为 Ruby 的语法优雅而直接。你可以以非常自然的方式表达算法，然后只需在命令行中输入`ruby`并按下回车，你的 Ruby 脚本就开始运行了。

然而，Ruby 的语法是*表面上*简单的；实际上，Ruby 运用了来自复杂语言如 Lisp 和 Smalltalk 的复杂思想。在此基础上，Ruby 是动态的；通过元编程，Ruby 程序可以自我检查并修改自己。在这层看似简单的外壳下，Ruby 是一个非常复杂的工具。

通过仔细观察 Ruby——通过学习 Ruby 本身是如何在内部工作的——你会发现一些重要的计算机科学概念支撑着 Ruby 的众多特性。通过学习这些概念，你将更深入地理解在使用该语言时，内部到底发生了什么。在这个过程中，你将了解到构建 Ruby 的团队是如何*期望*你使用这门语言的。

*Ruby 显微镜下*将向你展示，当你运行一个简单的程序时，Ruby 内部发生了什么。你将学到 Ruby 是如何理解和执行你的代码的，并且通过大量的图示，你将建立一个关于 Ruby 在创建对象或调用块时所做的事情的心理模型。

# 适合谁阅读本书

*Ruby 显微镜下*并不是一本面向初学者的 Ruby 学习指南。我假设你已经知道如何编写 Ruby 程序，并且每天都在使用它。已经有许多优秀的书籍教 Ruby 基础知识；世界不需要再来一本。

尽管 Ruby 本身是用 C 语言编写的，这是一种混乱且底层的语言，但阅读本书并不需要任何 C 语言的编程知识。*Ruby 显微镜下*将为你提供 Ruby 工作原理的高级概念理解，而无需你了解如何编写 C 语言程序。在本书中，你会看到数百个图示，这些图示使得 Ruby 内部实现的底层细节变得易于理解。

### 注意

*熟悉 C 的读者将会发现一些 C 代码片段，这些片段能更具体地帮助你理解 Ruby 内部发生了什么。我还会告诉你这些代码的来源，帮助你更容易地开始研究 C 代码。如果你对 C 代码的细节不感兴趣，可以跳过这些部分。*

# 使用 Ruby 来进行自我测试

> 不管你的理论多么美丽，不管你多么聪明。如果它与实验不符，那它就是错的。
> 
> — 理查德·费曼

想象一下，如果整个世界像一个大型计算机程序一样运作。为了解释自然现象或实验结果，像理查德·费曼这样的物理学家只需查阅这个程序。（科学家的梦想成真！）但当然，宇宙并非如此简单。

幸运的是，要发现 Ruby 是如何工作的，我们只需要阅读它的内部 C 源代码：这是一种描述 Ruby 行为的理论物理学。就像麦克斯韦方程式解释电力和磁性一样，Ruby 的内部 C 源代码解释了当你传递一个参数给方法或将模块包含在类中时发生了什么。

然而，像科学家一样，我们需要进行实验，确保我们的假设是正确的。在了解 Ruby 内部实现的每一部分之后，我们将进行实验，使用 Ruby 来测试自己！我们将运行小的 Ruby 测试脚本，查看它们是否产生预期的输出，或者是否以我们预期的速度运行。我们将找出 Ruby 是否真的按理论中所说的那样表现。而且，由于这些实验是用 Ruby 编写的，你可以自己尝试。

# 哪种 Ruby 实现？

Ruby 由松本行弘（Yukihiro “Matz” Matsumoto）于 1993 年发明，原始的标准版本 Ruby 通常被称为 *Matz 的 Ruby 解释器（MRI）*。本书的大部分内容将讨论 MRI 是如何工作的；基本上，我们将学习 Matz 是如何实现自己的语言的。

多年来，许多 Ruby 的替代实现被编写出来。一些实现，如 RubyMotion、MacRuby 和 IronRuby，是为了在特定平台上运行而设计的。其他实现，如 Topaz 和 JRuby，是用 C 以外的编程语言构建的。有一个版本，Rubinius，是用 Ruby 本身构建的。现在，Matz 本人正在开发一个名为 *mruby* 的更小版本 Ruby，旨在嵌入到其他应用程序中运行。

我在**第十章**、**第十一章** 和 **第十二章** 中详细探讨了 Ruby 的实现 JRuby 和 Rubinius。你将了解它们如何使用不同的技术和理念来实现同一种语言。通过研究这些替代 Ruby，你将对 MRI 的实现获得更多的视角。

# 概述

在**第一章**中，你将学习 Ruby 如何解析你的 Ruby 程序。这是计算机科学中最吸引人的领域之一：计算机语言如何足够智能，理解你给它的代码？这种智能到底由什么组成？

**第二章** 解释了 Ruby 如何使用编译器将你的程序转换成另一种语言，然后再运行它。

**第三章** 讲解了 Ruby 用来运行你的程序的虚拟机。这个机器里面是什么？它是如何工作的？我们将深入研究这个虚拟机，找出答案。

**第四章** 继续描述 Ruby 的虚拟机，着重讲解 Ruby 如何实现控制结构，如`if...else`语句和`while...end`循环。还探讨了 Ruby 是如何实现方法调用的。

**第五章** 讨论了 Ruby 中对象与类的实现。对象和类是如何关联的？我们在一个 Ruby 对象内部会发现什么？

**第六章** 考察了 Ruby 模块及其与类的关系。你将学会 Ruby 如何在你的代码中查找方法和常量。

**第七章** 探索了 Ruby 对哈希表的实现。事实证明，MRI 使用哈希表来存储大量的内部数据，而不仅仅是你在 Ruby 哈希对象中保存的数据。

**第八章** 揭示了 Ruby 最优雅且最有用的特性之一——块，是基于最初为 Lisp 开发的一个理念。

**第九章** 讨论了 Ruby 开发者面临的最难题之一。通过研究 Ruby 如何在内部实现元编程，你将学会如何有效地使用元编程。

**第十章** 介绍了 JRuby，这是一个用 Java 实现的 Ruby 版本。你将学到如何通过 Java 虚拟机（JVM）使你的 Ruby 程序运行得更快。

**第十一章** 讲解了 Ruby 最有趣、最具创新性的实现之一：Rubinius。你将学会如何定位并修改 Rubinius 中的 Ruby 代码，查看特定 Ruby 方法的工作原理。

**第十二章** 以垃圾回收（GC）为主题作结，这是计算机科学中最神秘、最令人困惑的话题之一。你将看到 Rubinius 和 JRuby 使用与 MRI 不同的 GC 算法。

通过研究 Ruby 内部实现的所有这些方面，你将更深入地理解当你使用 Ruby 复杂的功能集时，发生了什么。就像安东尼·范·列文虎克在 17 世纪通过早期显微镜首次看到微生物和细胞一样，深入 Ruby 内部，你将发现一系列有趣的结构和算法。加入我，跟随我一探究竟，看看是什么赋予了 Ruby 生命！
