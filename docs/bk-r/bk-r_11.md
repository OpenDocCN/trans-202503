## **9**

**调用函数**

![image](img/common-01.jpg)

在你开始编写自己的 R 函数之前，了解函数在 R 会话中的调用和解释方式非常有用。首先，你将查看 R 中变量名是如何被划分的。你将了解 R 对参数和对象命名的规则，以及在调用函数时，R 如何查找参数和其他变量。然后，你将了解调用函数时指定参数的几种替代方法。

### **9.1 作用域**

首先，理解 R 的 *作用域规则* 很重要，它决定了语言如何划分对象并在给定的会话中检索它们。这个框架还定义了可以同时存在重复对象名称的情况。例如，在调用 `matrix` 时，你使用了 `data` 作为参数(第 3.1 节)，但 `data` 也是一个现成的函数名称，用于加载来自贡献包的数据集(第 8.1.2 节)。在本节中，你将对 R 在这些情况下的内部行为有一个初步的了解，这将帮助你在以后编写和执行你自己以及其他包的函数时。

#### ***9.1.1 环境***

R 通过虚拟 *环境* 强制执行作用域规则。你可以将环境视为存储数据结构和函数的独立隔间。它们允许 R 区分与不同作用域相关的相同名称，并因此存储在不同的环境中。环境是动态实体——可以创建新的环境，也可以操作或删除现有的环境。

**注意**

*严格来说，环境并不包含项目。相反，它们有指向计算机内存中这些项目位置的* 指针 *。但是，使用“隔间”这一隐喻，并将对象“归属于”这些隔间，在你初步理解环境如何工作的过程中是很有用的。*

有三种重要的环境：全局环境、包环境和命名空间，以及局部或词法环境。

##### **全局环境**

*全局环境*是为用户定义的对象保留的隔间。到目前为止，你创建或重写的每个对象都驻留在当前 R 会话的全局环境中。在第 1.3.1 节中，我提到过，调用 `ls()` 会列出活动工作空间中的所有对象、变量和用户定义的函数——更准确地说，`ls()` 会打印当前全局环境中的所有内容。

从一个新的 R 工作空间开始，以下代码创建了两个对象并确认它们在全局环境中的存在：

```
R> foo <- 4+5
R> bar <- "stringtastic"
R> ls()
[1] "bar" "foo"
```

那么，所有现成的对象和函数呢？为什么它们没有和`foo`、`bar`一起作为这个环境的成员打印出来呢？事实上，这些对象和函数属于特定的包环境，接下来会进行描述。

##### **包环境与命名空间**

为了简便起见，我会宽泛地使用*包环境*一词，指代 R 中每个包所提供的项目。实际上，R 包的作用域结构要复杂得多。每个包环境实际上代表了多个环境，这些环境控制着对给定对象搜索的不同方面。例如，包的*命名空间*基本上定义了其函数的可见性。（一个包可以有可见函数，用户可以使用这些函数，也可以有不可见函数，这些函数为可见函数提供内部支持。）包环境的另一个部分处理*导入*指定，涉及包需要从其他库导入的任何函数或对象，以实现其自身功能。

为了更清楚地说明这一点，你可以将本书中你正在使用的所有现成函数和对象视为属于特定的包环境。同样，任何你通过调用`library`显式加载的贡献包的函数和对象也是如此。你可以使用`ls`列出包环境中的项目，方法如下：

```
R> ls("package:graphics")
 [1] "abline"          "arrows"          "assocplot"       "axis"
 [5] "Axis"            "axis.Date"       "axis.POSIXct"    "axTicks"
 [9] "barplot"         "barplot.default" "box"             "boxplot"
[13] "boxplot.default" "boxplot.matrix"  "bxp"             "cdplot"
[17] "clip"            "close.screen"    "co.intervals"    "contour"
[21] "contour.default" "coplot"          "curve"           "dotchart"
[25] "erase.screen"    "filled.contour"  "fourfoldplot"    "frame"
[29] "grconvertX"      "grconvertY"      "grid"            "hist"
[33] "hist.default"    "identify"        "image"           "image.default"
[37] "layout"          "layout.show"     "lcm"             "legend"
[41] "lines"           "lines.default"   "locator"         "matlines"
[45] "matplot"         "matpoints"       "mosaicplot"      "mtext"
[49] "pairs"           "pairs.default"   "panel.smooth"    "par"
[53] "persp"           "pie"             "plot"            "plot.default"
[57] "plot.design"     "plot.function"   "plot.new"        "plot.window"
[61] "plot.xy"         "points"          "points.default"  "polygon"
[65] "polypath"        "rasterImage"     "rect"            "rug"
[69] "screen"          "segments"        "smoothScatter"   "spineplot"
[73] "split.screen"    "stars"           "stem"            "strheight"
[77] "stripchart"      "strwidth"        "sunflowerplot"   "symbols"
[81] "text"            "text.default"    "title"           "xinch"
[85] "xspline"         "xyinch"          "yinch"
```

`ls`命令列出了`graphics`包环境中所有可见的对象。请注意，这个列表包括你在第七章中使用的部分函数，例如`arrows`、`plot`和`segments`。

##### **局部环境**

每当在 R 中调用一个函数时，都会创建一个新的环境，称为*局部环境*，有时也被称为*词法环境*。这个局部环境包含所有在函数内部创建的、且该函数可以访问的对象和变量，包括你在执行函数时传入的任何参数。正是这个特性使得在给定的工作空间中，函数参数名可以与其他可访问对象名相同。

例如，假设你调用`matrix`并传入参数`data`，如下所示：

```
R> youthspeak <- matrix(data=c("OMG","LOL","WTF","YOLO"),nrow=2,ncol=2)
R> youthspeak
     [,1]  [,2]
[1,] "OMG" "WTF"
[2,] "LOL" "YOLO"
```

调用此函数会创建一个包含`data`向量的局部环境。当你执行函数时，它首先会在该局部环境中查找`data`。这意味着 R 不会受到其他环境中名为`data`的对象或函数的干扰（例如，自动从`utils`包环境中加载的`data`函数）。如果在局部环境中找不到所需的项，R 才会开始扩大搜索范围（我将在第 9.1.2 节中进一步讨论这个特性）。一旦函数执行完成，该局部环境会自动被移除。对于`nrow`和`ncol`参数，也适用相同的说明。

#### ***9.1.2 搜索路径***

要访问来自非直接全局环境的数据结构和函数，R 会遵循一个*搜索路径*。搜索路径列出了当前 R 会话可用的所有环境。

搜索路径基本上是 R 在请求对象时会搜索的环境列表。如果某个环境中没有找到对象，R 会继续搜索下一个环境。你可以随时使用`search()`查看 R 的搜索路径。

```
R> search()
 [1] ".GlobalEnv"        "tools:RGUI"         "package:stats"
 [4] "package:graphics"  "package:grDevices"  "package:utils"
 [7] "package:datasets"  "package:methods"    "Autoloads"
[10] "package:base"
```

从命令提示符来看，这条路径始终从全局用户环境（`.GlobalEnv`）开始，并在`base`包环境（`package:base`）之后结束。你可以将这些环境视为属于一个层次结构，每对环境之间有一条从左到右的箭头指示。在我当前的会话中，如果我在 R 提示符下请求某个对象，程序将依次检查`.GlobalEnv` → `tools:RGUI` → `package:stats` → ... → `package:base`，当找到所需对象并检索后就停止搜索。请注意，根据你的操作系统以及是否使用内置 GUI，`tools:RGUI`可能不包括在你的搜索路径中。

如果 R 通过搜索路径中的各个环境没有找到所需的对象，便会到达*空环境*。空环境不会在`search()`的输出中显式列出，但它总是`package:base`之后的最终目的地。这个环境很特殊，因为它标志着搜索路径的结束。

例如，如果你调用以下内容，内部会发生一些事情：

```
R> baz <- seq(from=0,to=3,length.out=5)
R> baz
[1] 0.00 0.75 1.50 2.25 3.00
```

R 首先在全局环境中搜索名为`seq`的函数，当找不到时，它会继续在封闭环境中搜索，这是搜索路径中下一层的环境（如前所述，从左到右的箭头表示）。如果在那里也找不到，R 会继续沿路径搜索，查找已加载的包（无论是自动加载还是手动加载），直到找到所需的内容。在这个例子中，R 在内置的`base`包环境中找到了`seq`。然后，它执行`seq`函数（创建一个临时的局部环境），并将结果分配给一个新的对象`baz`，该对象位于全局环境中。在随后的`print(baz)`调用中，R 首先在全局环境中搜索，立即找到了请求的对象。

你可以使用`environment`查找任何函数的封闭环境，方法如下：

```
R> environment(seq)
<environment: namespace:base>
R> environment(arrows)
<environment: namespace:graphics>
```

在这里，我已将`base`包的命名空间标识为`seq`函数的拥有者，并将`graphics`包标识为`arrows`函数的拥有者。

每个环境都有一个*父环境*，用于指导搜索路径的顺序。通过检查之前`search()`调用的输出，您可以看到例如`package:stats`的父环境是`package:graphics`。这种父子结构是动态的，意味着当加载额外的库或数据框被`attach`时，搜索路径会发生变化。当您通过`library`调用加载一个贡献包时，它基本上会将所需的包插入到搜索路径中。例如，在练习 8.1 中，您安装了贡献包`car`。加载此包后，您的搜索路径将包括它的内容。

```
R> library("car")
R> search()
 [1] ".GlobalEnv"         "package:car"        "tools:RGUI"
 [4] "package:stats"      "package:graphics"   "package:grDevices"
 [7] "package:utils"      "package:datasets"   "package:methods"
[10] "Autoloads"          "package:base"
```

请注意`car`包环境在路径中的位置——它直接插入在全局环境之后。这是每个后续加载的包将被放置的位置（接着是它依赖的其他包）。

如前所述，一旦 R 搜索完所有路径并到达空环境，它将停止搜索。如果您请求一个未定义的函数或对象，或者是可能在一个您忘记加载的贡献包中（这是一个常见的小错误），那么会抛出错误。这些“找不到”的错误无论是对于函数还是其他对象都可以识别。

```
R> neither.here()
Error: could not find function "neither.here"
R> nor.there
Error: object 'nor.there' not found
```

环境有助于将 R 中的大量功能进行隔离。当搜索路径中不同包中有相同名称的函数时，这一点尤其重要。此时，*掩蔽*，如第 12.3 节所讨论的那样，便开始起作用。

随着您对 R 的熟悉，您可能希望更精确地控制其操作，因此值得全面调查 R 如何处理环境。关于这一点的更多技术细节，Gupta（2012）提供了一篇特别精彩的在线文章。

#### ***9.1.3 保留和受保护的名称***

R 中有一些关键术语严格禁止用作对象名称。这些*保留*名称是为了保护语言中经常使用的基本操作和数据类型。

以下标识符是保留的：

• `if` 和 `else`

• `for`、`while` 和 `in`

• `function`

• `repeat`、`break` 和 `next`

• `TRUE` 和 `FALSE`

• `Inf` 和 `-Inf`

• `NA`、`NaN` 和 `NULL`

我还没有覆盖这个列表中的一些术语。这些条目代表了 R 语言编程的核心工具，您将在接下来的章节中开始探索它们。最后三个项目包括熟悉的逻辑值（第 4.1 节）和用于表示无限大和缺失条目的特殊术语（第 6.1 节）。

如果您尝试为这些保留术语分配新值，会发生错误。

```
R> NaN <- 5
Error in NaN <- 5 : invalid (do_set) left-hand side to assignment
```

由于 R 是区分大小写的，可能会给保留名称的任何大小写变体赋值，但这可能会导致混淆，通常不建议这样做。

```
R> False <- "confusing"
R> nan <- "this is"
R> cat(nan,False)
this is confusing
```

另外，要小心不要给`T`和`F`赋值，这两个是`TRUE`和`FALSE`的简写。完整的标识符`TRUE`和`FALSE`是保留的，但简写版本不是。

```
R> T <- 42
R> F <- TRUE
R> F&&TRUE
[1] TRUE
```

以这种方式给`T`和`F`赋值将影响任何后续的代码，这些代码意图使用`T`和`F`来表示`TRUE`和`FALSE`。第二个赋值（`F <- TRUE`）在 R 看来是完全合法的，但鉴于`F`通常作为简写，它会非常令人困惑：这一行`F&&TRUE`现在表示的是一个`TRUE&&TRUE`的比较！最好避免这种类型的赋值。

如果你一直在跟随 R 控制台中的示例，建议此时清空全局环境（从工作区删除对象`False`、`nan`、`T`和`F`）。可以使用`rm`函数，如下所示。使用`ls()`时，提供一个包含全局环境中所有对象的字符向量作为`list`参数。

```
R> ls()
[1] "bar"        "baz"        "F"       "False"     "foo"        "nan"
[7] "T"          "youthspeak"
R> rm(list=ls())
R> ls()
character(0)
```

现在，全局环境为空，调用`ls()`返回一个空的字符向量（`character(0)`）。

**练习 9.1**

1.  识别内置并自动加载的`methods`包中的前 20 个项目。总共有多少个项目？

1.  确定以下每个函数所属的环境：

    1.  `read.table`

    1.  `data`

    1.  `matrix`

    1.  `jpeg`

1.  使用`ls`和字符字符串相等性测试来确认`smoothScatter`函数属于`graphics`包。

### **9.2 参数匹配**

另一组决定 R 如何解释函数调用的规则涉及*参数匹配*。参数匹配条件允许你通过简写的名称或完全不带名称的方式向函数提供参数。

#### ***9.2.1 精确匹配***

到目前为止，你主要在使用*精确*匹配参数，其中每个参数标签都写出完整。这是调用函数时最详尽的方式。当你初次学习 R 或新函数时，写出完整的参数名是非常有帮助的。

精确匹配的其他好处包括：

• 与其他匹配方式相比，精确匹配更不容易出错。

• 参数的提供顺序无关紧要。

• 当一个函数有多个可能的参数，但你只想指定其中一部分时，精确匹配非常有用。

精确匹配的主要缺点很明显：

• 对于相对简单的操作来说，这可能显得笨重。

• 精确匹配要求用户记住或查找完整的、区分大小写的标签。

作为示例，在第 6.2.1 节中，你使用了精确匹配来执行以下操作：

```
R> bar <- matrix(data=1:9,nrow=3,ncol=3,dimnames=list(c("A","B","C"),
                                                      c("D","E","F")))
R> bar
  D E F
A 1 4 7
B 2 5 8
C 3 6 9
```

这会创建一个 3 × 3 的矩阵对象 `bar`，并为行和列设置 `dimnames` 属性。由于参数标签已完全指定，参数的顺序并不重要。你可以交换参数，函数仍然能获得它所需的所有信息。

```
R> bar <- matrix(nrow=3,dimnames=list(c("A","B","C"),c("D","E","F")),ncol=3,
                 data=1:9)
R> bar
  D E F
A 1 4 7
B 2 5 8
C 3 6 9
```

这与之前的函数调用行为相同。为了保持一致性，通常在每次调用函数时你不会交换参数，但这个例子展示了精确匹配的一个好处：你不需要担心任何可选参数的顺序或跳过它们。

#### ***9.2.2 部分匹配***

*部分*匹配让你能够通过缩写标签来识别参数。这可以缩短代码，同时仍然允许你以任意顺序提供参数。

这里是另一种调用 `matrix` 的方式，它利用了部分匹配：

```
R> bar <- matrix(nr=3,di=list(c("A","B","C"),c("D","E","F")),nc=3,dat=1:9)
R> bar
  D E F
A 1 4 7
B 2 5 8
C 3 6 9
```

请注意，我已将 `nrow`、`dimnames` 和 `ncol` 的参数标签缩短为前两个字母，并将 `data` 参数缩短为前三个字母。对于部分匹配，你不必提供固定数量的字母，只要每个参数对于被调用的函数仍然是唯一可识别的。部分匹配有以下优点：

• 它比精确匹配需要的代码更少。

• 参数标签仍然可见（这减少了误配的可能性）。

• 提供的参数顺序仍然不重要。

但部分匹配也有一些局限性。首先，如果有多个参数的标签以相同的字母开头，情况会变得更加复杂。这里有一个例子：

```
R> bar <- matrix(nr=3,di=list(c("A","B","C"),c("D","E","F")),nc=3,d=1:9)
Error in matrix(nr = 3, di = list(c("A", "B", "C"), c("D", "E", "F")), :
  argument 4 matches multiple formal arguments
```

发生了错误。第四个参数标签仅指定为 `d`，代表 `data`。这是不合法的，因为另一个参数 `dimnames` 也以 `d` 开头。即使 `dimnames` 在同一行中稍早前已单独指定为 `di`，这个调用仍然无效。

部分匹配的缺点包括以下几点：

• 用户必须意识到其他可能被缩短标签匹配的参数（即使它们没有在调用中指定或已分配了默认值）。

• 每个标签必须有唯一的标识符，这可能很难记住。

#### ***9.2.3 位置匹配***

R 中最紧凑的函数调用方式是*位置匹配*。这是指你在没有标签的情况下提供参数，R 会仅根据它们的顺序来解释它们。

位置匹配通常用于相对简单的函数，这些函数只有少量参数，或者是用户非常熟悉的函数。对于这种类型的匹配，你*必须*了解每个参数的精确位置。你可以在函数帮助文件的“Usage”部分找到该信息，或者可以通过 `args` 函数将其打印到控制台。这里有一个例子：

```
R> args(matrix)
function (data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)
NULL
```

这显示了 `matrix` 函数的参数定义顺序，以及每个参数的默认值。要使用位置匹配构造矩阵 `bar`，请执行以下操作：

```
R> bar <- matrix(1:9,3,3,F,list(c("A","B","C"),c("D","E","F")))
R> bar
  D E F
A 1 4 7
B 2 5 8
C 3 6 9
```

位置匹配的好处如下：

• 更简短、更清晰的代码，特别是对于常规任务

• 不需要记住特定的参数标签。

注意，在使用精确匹配和部分匹配时，你不需要为`byrow`参数提供任何内容，因为默认情况下它被设置为`FALSE`。而在位置匹配时，你必须为`byrow`提供一个值（这里为`F`），作为第四个参数，因为 R 仅通过位置来解释函数调用。如果你省略了这个参数，就会出现如下错误：

```
R> bar <- matrix(1:9,3,3,list(c("A","B","C"),c("D","E","F")))
Error in matrix(1:9, 3, 3, list(c("A", "B", "C"), c("D", "E", "F"))) :
  invalid 'byrow' argument
```

这里 R 试图将第四个参数（你原本打算用于`dimnames`的列表）赋值给逻辑值`byrow`的参数。这引出了位置匹配的缺点：

• 你必须查找并精确匹配已定义的参数顺序。

• 阅读别人写的代码可能更困难，尤其是当代码中包含不熟悉的函数时。

#### ***9.2.4 混合匹配***

由于每种匹配方式都有优缺点，因此在一次函数调用中混合使用这三种匹配方式是非常常见且完全合法的。

例如，你可以像下面这样避免之前示例中的错误：

```
R> bar <- matrix(1:9,3,3,dim=list(c("A","B","C"),c("D","E","F")))
R> bar
  D E F
A 1 4 7
B 2 5 8
C 3 6 9
```

在这里，我为前三个参数使用了位置匹配，这些参数你现在已经熟悉了。同时，我使用了部分匹配，明确告诉 R 该列表是作为`dimnames`值，而不是`byrow`。

#### ***9.2.5 点点点：省略号的使用***

许多函数展示了*可变参数*行为。也就是说，它们可以接受任意数量的参数，由用户决定提供多少个参数。函数`c`、`data.frame`和`list`都是如此。当你调用像`data.frame`这样的函数时，你可以指定任意数量的成员作为参数。

这种灵活性是在 R 中通过特殊的*点点点*符号（`...`）实现的，也叫做*省略号*。这种构造允许用户提供任意数量的数据向量（这些向量将成为最终数据框中的列）。你可以通过查看函数的帮助页面或使用`args`来判断函数是否使用了省略号。在`data.frame`中，可以看到第一个参数位置是一个省略号：

```
R> args(data.frame)
function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE,
    stringsAsFactors = default.stringsAsFactors())
NULL
```

当你调用一个函数并提供一个无法与函数定义的参数标签匹配的参数时，通常这会导致一个错误。但是，如果函数是用省略号定义的，任何未与其他参数标签匹配的参数将会匹配到省略号。

使用省略号的函数通常分为两类。第一类包括像`c`、`data.frame`和`list`这样的函数，其中省略号始终表示函数调用中的“主要成分”。也就是说，函数的目的是将省略号中的内容用于结果对象或输出中。第二类函数则是将省略号作为*补充*或*潜在*的可选参数存储库。这种情况通常出现在某个感兴趣的函数调用了其他*子函数*，这些子函数根据最初提供的参数可能需要额外的参数。为了避免将子函数需要的所有参数显式复制到“父”函数的参数列表中，父函数可以通过定义一个省略号来实现，之后将其提供给子函数。

这是一个使用省略号传递补充参数的例子，出现在通用的`plot`函数中：

```
R> args(plot)
function (x, y, ...)
NULL
```

从检查参数来看，很明显如果提供了点大小（参数标签`cex`）或线型（参数标签`lty`）等可选参数，它们将与省略号匹配。这些可选参数随后会传递给函数，用于调整图形参数的各种方法。

省略号是编写可变参数函数或函数时一个方便的编程工具，其中可以传入未知数量的参数。当你开始在第十一章编写自己的函数时，这一点将变得更加清晰。然而，在编写这样的函数时，重要的是要正确记录`...`的预期用途，这样函数的潜在用户才能确切知道哪些参数可以传递给它，以及这些参数在执行过程中将如何使用。

**练习 9.2**

1.  使用位置匹配和`seq`创建一个从-4 到 4 的值序列，步长为 0.2。

1.  在接下来的每一行代码中，识别使用的是哪种参数匹配方式：精确匹配、部分匹配、位置匹配或混合匹配。如果是混合匹配，请确定每种方式中指定了哪些参数。

    1.  `array(8:1,dim=c(2,2,2))`

    1.  `rep(1:2,3)`

    1.  `seq(from=10,to=8,length=5)`

    1.  `sort(decreasing=T,x=c(2,1,1,2,0.3,3,1.3))`

    1.  `which(matrix(c(T,F,T,T),2,2))`

    1.  `which(matrix(c(T,F,T,T),2,2),a=T)`

1.  假设你显式运行了绘图函数`plot.default`并为参数`type`、`pch`、`xlab`、`ylab`、`lwd`、`lty`和`col`提供了值。使用函数文档来确定这些参数中哪些属于省略号的范畴。

##### **本章中的重要代码**

| **函数/运算符** | **简要描述** | **首次出现** |
| --- | --- | --- |
| `ls` | 检查环境对象 | 第 9.1.1 节，第 167 页 |
| `search` | 当前搜索路径 | 第 9.1.2 节，第 168 页 |
| `environment` | 函数环境属性 | 第 9.1.2 节，第 169 页 |
| `rm` | 删除工作区中的对象 | 第 9.1.3 节，第 171 页 |
| `args` | 显示函数参数 | 第 9.2.3 节，第 174 页 |
