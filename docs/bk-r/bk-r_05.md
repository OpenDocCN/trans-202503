## **4**

**非数值类型**

![image](img/common-01.jpg)

到目前为止，你几乎只在处理数值类型。但统计编程也需要非数值类型。在本章中，我们将考虑三种重要的非数值数据类型：逻辑值、字符和因子。这些数据类型在有效使用 R 时起着重要作用，特别是当我们进入第二部分的更复杂的 R 编程时。

### **4.1 逻辑值**

逻辑值（也叫做*逻辑型*）基于一个简单的前提：逻辑值对象只能是`TRUE`或`FALSE`。这些可以解释为是/否、1/0、满足/不满足，等等。这是一个出现在所有编程语言中的概念，逻辑值有许多重要的用途。通常，它们用来表示某个条件是否已满足，或者某个参数是否应该开启或关闭。

你在使用第 2.3.2 节中的`sort`函数和第 3.1 节中的`matrix`函数时，简要地接触过逻辑值。在使用`sort`时，设置`decreasing=TRUE`返回一个从大到小排序的向量，`decreasing=FALSE`则将向量按相反顺序排序。类似地，在构造矩阵时，`byrow=TRUE`按行填充矩阵条目；否则，矩阵按列填充。现在，我们将更详细地探讨如何使用逻辑值。

#### ***4.1.1 TRUE 还是 FALSE？***

R 中的逻辑值完全写作`TRUE`和`FALSE`，但通常缩写为`T`或`F`。缩写版对代码执行没有影响，因此，例如，使用`decreasing=T`与在`sort`函数中使用`decreasing=TRUE`等效。（但是，如果你想利用这种便捷性，千万不要创建名为`T`或`F`的对象——参见第 9.1.3 节）。 

将逻辑值赋给一个对象与赋给数值相同。

```
R> foo <- TRUE
R> foo
[1] TRUE
R> bar <- F
R> bar
[1] FALSE
```

这将给你一个值为`TRUE`的对象和一个值为`FALSE`的对象。类似地，向量也可以用逻辑值填充。

```
R> baz <- c(T,F,F,F,T,F,T,T,T,F,T,F)
R> baz
 [1]  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE
R> length(x=baz)
[1] 12
```

矩阵（和其他高维数组）也可以用这些值创建。使用之前的`foo`和`baz`，你可以构造类似这样的内容：

```
R> qux <- matrix(data=baz,nrow=3,ncol=4,byrow=foo)
R> qux
     [,1]  [,2]  [,3]  [,4]
[1,] TRUE FALSE FALSE FALSE
[2,] TRUE FALSE  TRUE  TRUE
[3,] TRUE FALSE  TRUE FALSE
```

#### ***4.1.2 逻辑结果：关系运算符***

逻辑值通常用于检查值之间的关系。例如，你可能想知道某个数字*a*是否大于预定义的阈值*b*。为此，你可以使用表 4-1 中显示的标准*关系运算符*，它们的结果是逻辑值。

**表 4-1：** 关系运算符

| **运算符** | **解释** |
| --- | --- |
| `==` | 等于 |
| `!=` | 不等于 |
| `>` | 大于 |
| `<` | 小于 |
| `>=` | 大于或等于 |
| `<=` | 小于或等于 |

通常，这些操作符用于数值型数据（尽管你将在第 4.2.1 节中查看其他可能性）。这里是一个例子：

```
R> 1==2
[1] FALSE
R> 1>2
[1] FALSE
R> (2-1)<=2
[1] TRUE
R> 1!=(2+3)
[1] TRUE
```

结果应该不令人惊讶：`1` 等于 `2` 是 `FALSE`，而 `1` 大于 `2` 也是 `FALSE`，但 `2-1` 小于或等于 `2` 的结果是 `TRUE`，同样，`1` 不等于 `5`（`2+3`）也是 `TRUE`。这种类型的操作在处理某些方式可变的数字时更加有用，正如你稍后会看到的那样。

当你使用向量时，R 的按元素行为你已经很熟悉。当使用关系运算符时，规则相同。为了说明这一点，让我们先创建两个向量，并再次检查它们的长度是否相等。

```
R> foo <- c(3,2,1,4,1,2,1,-1,0,3)
R> bar <- c(4,1,2,1,1,0,0,3,0,4)
R> length(x=foo)==length(x=bar)
[1] TRUE
```

现在考虑以下四个评估：

```
R> foo==bar
 [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE
R> foo<bar
 [1]  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE
R> foo<=bar
 [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE
R> foo<=(bar+10)
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
```

第一行检查 `foo` 中的条目是否等于 `bar` 中的对应条目，只有第 5 和第 9 个条目为 `TRUE`。返回的向量将包含每对元素的逻辑结果，因此它将与正在比较的向量长度相同。第二行以相同的方式比较 `foo` 和 `bar`，这次检查 `foo` 中的条目是否小于 `bar` 中的条目。与第三个比较结果对比，第三个比较检查条目是否小于*或等于*彼此。最后，第四行检查 `foo` 的成员是否小于或等于 `bar`，当 `bar` 的元素增加 `10` 时。自然地，结果都是 `TRUE`。

向量回收也适用于逻辑值。我们使用之前的 `foo`，以及一个较短的向量 `baz`。

```
R> baz <- foo[c(10,3)]
R> baz
[1] 3 1
```

这里你创建了 `baz`，它是一个长度为 2 的向量，包含了 `foo` 的第 10 和第 3 个元素。现在考虑以下内容：

```
R> foo>baz
 [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE
```

在这里，`baz` 的两个元素会被回收，并与 `foo` 的 10 个元素进行比较。`foo` 的第 1 和第 2 个元素与 `baz` 的第 1 和第 2 个元素进行比较，`foo` 的第 3 和第 4 个元素与 `baz` 的第 1 和第 2 个元素进行比较，依此类推。你也可以将向量的所有值与单一值进行比较。这里是一个例子：

```
R> foo<3
 [1] FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE
```

这是在 R 中处理数据集时的典型操作。

现在让我们将 `foo` 和 `bar` 的内容重写为一个 5 × 2 的列填充矩阵。

```
R> foo.mat <- matrix(foo,nrow=5,ncol=2)
R> foo.mat
     [,1] [,2]
[1,]    3    2
[2,]    2    1
[3,]    1   -1
[4,]    4    0
[5,]    1    3
R> bar.mat <- matrix(bar,nrow=5,ncol=2)
R> bar.mat
     [,1] [,2]
[1,]    4    0
[2,]    1    0
[3,]    2    3
[4,]    1    0
[5,]    1    4
```

这里同样应用按元素行为；如果你比较矩阵，你将得到一个大小相同、填充了逻辑值的矩阵。

```
R> foo.mat<=bar.mat
      [,1]  [,2]
[1,]  TRUE FALSE
[2,] FALSE FALSE
[3,]  TRUE  TRUE
[4,] FALSE  TRUE
[5,]  TRUE  TRUE
R> foo.mat<3
      [,1]  [,2]
[1,] FALSE  TRUE
[2,]  TRUE  TRUE
[3,]  TRUE  TRUE
[4,] FALSE  TRUE
[5,]  TRUE FALSE
```

这种评估也适用于多维数组。

你可以使用两个有用的函数来快速检查逻辑值的集合：`any` 和 `all`。在检查一个向量时，如果向量中的任何一个逻辑值为 `TRUE`，则 `any` 返回 `TRUE`，否则返回 `FALSE`。函数 `all` 只有在*所有*逻辑值都为 `TRUE` 时才返回 `TRUE`，否则返回 `FALSE`。作为一个快速示例，我们来处理在本节开头通过比较 `foo` 和 `bar` 形成的两个逻辑向量。

```
R> qux <- foo==bar
R> qux
 [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE
R> any(qux)
[1] TRUE
R> all(qux)
[1] FALSE
```

在这里，`qux` 包含两个 `TRUE`，其余为 `FALSE`——因此，`any` 的结果自然是 `TRUE`，但 `all` 的结果是 `FALSE`。按照相同的规则，你会得到以下结果：

```
R> quux <- foo<=(bar+10)
R> quux
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
R> any(quux)
[1] TRUE
R> all(quux)
[1] TRUE
```

`any` 和 `all` 函数对逻辑值的矩阵和数组执行相同的操作。

**练习 4.1**

1.  将以下包含 15 个值的向量存储为工作空间中的一个对象：`c(6,9,7,3,6,7,9,6,3,6,6,7,1,9,1)`。识别以下元素：

    1.  这些等于 6 的元素

    1.  这些大于或等于 6 的元素

    1.  这些小于 6 + 2 的元素

    1.  这些不等于 6 的元素

1.  从（a）中使用的向量创建一个新向量，通过删除其前 3 个元素。使用这个新向量，填充一个 2 × 2 × 3 的数组。检查数组中的以下条目：

    1.  这些小于或等于 6 除以 2 后加 4 的元素

    1.  这些小于或等于 6 除以 2 后加 4 的元素，*在*将数组中的每个元素增加 2 后

1.  确认在 10 × 10 单位矩阵 *I[10]* 中等于 0 的元素的具体位置（参见 第 3.3 节）。

1.  检查在（b）中创建的逻辑数组中的*任何*值是否为 `TRUE`。如果是，检查它们是否*全部*为 `TRUE`。

1.  通过提取在（c）中创建的逻辑矩阵的对角元素，使用 `any` 来确认没有 `TRUE` 条目。

#### ***4.1.3 多重比较：逻辑运算符***

逻辑值特别有用，当你想检查多个条件是否都满足时。通常，你希望只有在满足多个不同条件的情况下执行某些操作。

上一节介绍了关系运算符，用于比较存储的 R 对象的字面值（即数值或其他）。现在，你将学习 *逻辑运算符*，它们用于比较两个 `TRUE` 或 `FALSE` 对象。这些运算符基于 AND 和 OR 语句。表 4-2 总结了 R 语法和逻辑运算符的行为。AND 和 OR 运算符各自有“单一”和“逐元素”版本——稍后你会看到它们的不同。

**表 4-2：** 比较两个逻辑值的逻辑运算符

| **运算符** | **解释** | **结果** |
| --- | --- | --- |

| `&` | 与（逐元素） | `TRUE & TRUE` 为 `TRUE`，`TRUE & FALSE` 为 `FALSE` |

`FALSE & TRUE` 为 `FALSE`

`FALSE & FALSE` 为 `FALSE` |

| `&&` | 与（单一比较） | 与上面的 `&` 相同 |
| --- | --- | --- |

| `&#124;` | 或（逐元素） | `TRUE&#124;TRUE` 为 `TRUE`，`TRUE&#124;FALSE` 为 `TRUE` |

`FALSE&#124;TRUE` 为 `TRUE`

`FALSE&#124;FALSE` 为 `FALSE` |

| `&#124;&#124;` | 或（单一比较） | 与上面的 `&#124;` 相同 |
| --- | --- | --- |
| `!` | 非 | `!TRUE` 为 `FALSE`，`!FALSE` 为 `TRUE` |

使用任何逻辑运算符的结果都是一个逻辑值。只有当*两个*逻辑值都为 `TRUE` 时，AND 比较才为真。当 OR 比较时，只要至少有一个逻辑值为 `TRUE`，结果就为真。NOT 运算符（`!`）简单地返回它所作用的逻辑值的相反值。你可以将这些运算符组合起来，一次检查多个条件。

```
R> FALSE||((T&&TRUE)||FALSE)
[1] TRUE
R> !TRUE&&TRUE
[1] FALSE
R> (T&&(TRUE||F))&&FALSE
[1] FALSE
R> (6<4)||(3!=1)
[1] TRUE
```

与数字算术一样，R 中的逻辑运算也有优先级。AND 语句的优先级高于 OR 语句。将每对比较项放入括号中有助于保留正确的运算顺序，并使代码更具可读性。你可以在这段代码的第一行看到这一点，其中最内层的比较是首先执行的：`T&&TRUE`的结果是`TRUE`；然后它作为下一个括号比较中的逻辑值之一参与计算，其中`TRUE||FALSE`的结果是`TRUE`。最后的比较是`FALSE||TRUE`，结果为`TRUE`，并打印到控制台。第二行表示 NOT `TRUE` AND `TRUE`，结果当然是`FALSE`。在第三行，再次是最内层的配对首先被计算：`TRUE||F`为`TRUE`；`T&&TRUE`为`TRUE`；最后`TRUE&&FALSE`为`FALSE`。第四个也是最后一个例子比较了两个括号中的条件，然后使用逻辑运算符进行比较。由于`6<4`为`FALSE`，而`3!=1`为`TRUE`，所以得到逻辑比较`FALSE||TRUE`，最终结果是`TRUE`。

在表 4-2 中，有 AND 和 OR 运算符的简短版本（`&`，`|`）和长版本（`&&`，`||`）。简短版本用于逐元素比较，其中你有两个逻辑向量，并且希望得到多个逻辑值作为结果。长版本，正如你到目前为止所使用的，是用于比较两个单独的值并返回单一逻辑值的。当你在 R 中编写条件判断语句时（在第十章中会介绍），这是非常重要的。使用简短版本也可以比较一对逻辑值，尽管当只需要一个`TRUE`或`FALSE`结果时，通常推荐使用长版本。

让我们来看一些逐元素比较的例子。假设你有两个等长的向量，`foo` 和 `bar`：

```
R> foo <- c(T,F,F,F,T,F,T,T,T,F,T,F)
R> foo
 [1]  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE
```

和

```
R> bar <- c(F,T,F,T,F,F,F,F,T,T,T,T)
R> bar
 [1] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
```

逻辑运算符的简短版本通过位置匹配每对元素，并返回比较的结果。

```
R> foo&bar
 [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE
R> foo|bar
 [1]  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
```

使用运算符的长版本意味着 R 只对两个向量中的第一个逻辑对进行比较。

```
R> foo&&bar
[1] FALSE
R> foo||bar
[1] TRUE
```

注意，最后两个结果与使用逻辑运算符简短版本得到的向量的第一个条目相匹配。

**练习 4.2**

1.  将向量`c(7,1,7,10,5,9,10,3,10,8)`存储为`foo`。识别大于 5 或等于 2 的元素。

1.  将向量`c(8,8,4,4,5,1,5,6,6,8)`存储为`bar`。识别小于或等于 6 并且不等于 4 的元素。

1.  在`foo`中识别满足（a）并且在`bar`中满足（b）的元素。

1.  存储一个名为`baz`的第三个向量，该向量等于`foo`和`bar`的逐元素和。确定以下内容：

    1.  `baz`中大于或等于 14 但不等于 15 的元素。

    1.  通过对`baz`除以`foo`进行逐元素除法得到的向量，其中元素大于 4 或小于等于 2

1.  确认在之前的所有练习中使用长版本时，只执行了第一个比较（即，结果与之前获得的向量的第一个条目相匹配）。

#### ***4.1.4 逻辑值就是数字！***

由于逻辑值的二元性质，它们通常用`TRUE`表示为 1，`FALSE`表示为 0。实际上，在 R 中，如果对逻辑值进行基本的数值运算，`TRUE`会被当作`1`，而`FALSE`会被当作`0`。

```
R> TRUE+TRUE
[1] 2
R> FALSE-TRUE
[1] -1
R> T+T+F+T+F+F+T
[1] 4
```

这些操作的结果与直接使用数字 1 和 0 相同。在某些情况下，当你使用逻辑值时，可以用数字值来替代。

```
R> 1&&1
[1] TRUE
R> 1||0
[1] TRUE
R> 0&&1
[1] FALSE
```

能够将逻辑值解释为零和一，意味着你可以使用多种函数来总结逻辑向量，你将在第三部分中进一步探索这个问题。

#### ***4.1.5 逻辑子集化和提取***

逻辑值也可以用于提取和子集化向量及其他对象中的元素，方式与之前使用索引向量相同。你可以用逻辑*标志*向量来替代显式索引，当标志向量中相应位置的值为`TRUE`时，该元素就会被提取。因此，逻辑标志向量应该与正在访问的向量具有相同的长度（不过，对于较短的标志向量，R 会进行回收，如后面的示例所示）。

在第 2.3.3 节的开头，你定义了一个长度为 10 的向量，如下所示：

```
R> myvec <- c(5,-2.3,4,4,4,6,8,10,40221,-8)
```

如果你想提取两个负数元素，可以输入`myvec[c(2,10)]`，或者你也可以使用逻辑标志来做如下操作：

```
R> myvec[c(F,T,F,F,F,F,F,F,F,T)]
[1] -2.3 -8.0
```

这个特定的例子可能看起来过于繁琐，难以在实际中使用。然而，当你想要基于某个条件（或多个条件）提取元素时，它会变得非常有用。例如，你可以轻松地使用逻辑值通过应用条件`<0`来找到`myvec`中的负数元素。

```
R> myvec<0
 [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
```

这是一个完全有效的标志向量，你可以使用它对子集化`myvec`，并得到与之前相同的结果。

```
R> myvec[myvec<0]
[1] -2.3 -8.0
```

如前所述，如果标志向量太短，R 会对其进行回收。要从`myvec`中提取每隔一个元素，从第一个元素开始，你可以输入以下内容：

```
R> myvec[c(T,F)]
[1]     5     4     4     8 40221
```

你可以使用关系运算符和逻辑运算符进行更复杂的提取，例如：

```
R> myvec[(myvec>0)&(myvec<1000)]
[1]  5  4  4  4  6  8 10
```

这会返回小于 1,000 的正数元素。你还可以像使用索引向量一样，使用逻辑标志向量来覆盖特定元素。

```
R> myvec[myvec<0] <- -200
R> myvec
 [1]     5  -200     4     4     4     6     8     10 40221  -200
```

这会将所有现有的负值条目替换为−200。请注意，你不能直接使用负逻辑标志向量来删除特定的元素；只能使用数字索引向量来做到这一点。

如你所见，逻辑值在元素提取中非常有用。你不需要事先知道要返回的具体索引位置，因为条件检查可以为你找到它们。当你处理大型数据集时，特别是在需要检查记录或重新编码符合特定条件的条目时，这尤其有价值。

在某些情况下，你可能希望将逻辑标志向量转换为数值索引向量。当你需要明确标记为`TRUE`的元素的索引时，这非常有用。R 函数`which`接受一个逻辑向量作为参数`x`，并返回对应于所有`TRUE`条目的位置的索引。

```
R> which(x=c(T,F,F,T,T))
[1] 1 4 5
```

你可以用它来识别`myvec`中满足某些条件的索引位置；例如，包含负数的那些元素：

```
R> which(x=myvec<0)
[1]  2 10
```

对于你实验过的其他`myvec`选择项，也可以执行相同的操作。请注意，像`myvec[which(x=myvec<0)]`这样的代码行是多余的，因为提取可以仅使用条件本身进行，即通过`myvec[myvec<0]`，无需使用`which`。另一方面，使用`which`可以让你基于逻辑标志向量删除元素。你可以简单地使用`which`来识别要删除的数值索引，并将它们设为负数。要省略`myvec`中的负数条目，你可以执行以下操作：

```
R> myvec[-which(x=myvec<0)]
[1]     5     4     4     4     6     8     10 40221
```

对矩阵和其他数组也可以做同样的操作。在第 3.2 节中，你按照以下方式存储了一个 3×3 的矩阵：

```
R> A <- matrix(c(0.3,4.5,55.3,91,0.1,105.5,-4.2,8.2,27.9),nrow=3,ncol=3)
R> A
     [,1]  [,2] [,3]
[1,]  0.3  91.0 -4.2
[2,]  4.5   0.1  8.2
[3,] 55.3 105.5 27.9
```

若要使用数值索引提取`A`的第一行的第二列和第三列元素，你可以执行`A[1,2:3]`。要使用逻辑标志来实现这一点，你可以输入以下内容：

```
R> A[c(T,F,F),c(F,T,T)]
[1] 91.0 -4.2
```

然而，通常你不会显式地指定逻辑向量。假设你想将`A`中所有小于 1 的元素替换为−7。使用数值索引来执行此操作相当繁琐。使用以下方式创建逻辑标志矩阵要容易得多：

```
R> A<1
      [,1]  [,2]  [,3]
[1,]  TRUE FALSE  TRUE
[2,] FALSE  TRUE FALSE
[3,] FALSE FALSE FALSE
```

你可以将这个逻辑矩阵提供给方括号操作符，替换过程如下：

```
R> A[A<1] <- -7
R> A
     [,1]  [,2] [,3]
[1,] -7.0  91.0 -7.0
[2,]  4.5  -7.0  8.2
[3,] 55.3 105.5 27.9
```

这是你第一次在不需要在方括号内列出行或列位置的情况下对子集化矩阵，使用逗号分隔维度（参见第 3.2 节）。这是因为标志矩阵的行列数与目标矩阵相同，从而提供了所有相关的结构信息。

如果你使用`which`基于逻辑标志结构来识别数值索引，那么在处理二维或更高维对象时你必须小心一些。假设你想要大于 25 的元素的索引位置。适当的逻辑矩阵如下所示。

```
R> A>25
      [,1]  [,2]  [,3]
[1,] FALSE  TRUE FALSE
[2,] FALSE FALSE FALSE
[3,]  TRUE  TRUE  TRUE
```

现在，假设你询问 R 以下问题：

```
R> which(x=A>25)
[1] 3 4 6 9
```

这会返回四个满足关系检查的元素的索引，但它们作为标量值提供。这些如何对应于矩阵的行/列位置呢？

答案在 R 的`which`函数的默认行为中，该函数本质上将多维对象视为一个单一向量（按列堆叠），然后返回对应的索引向量。假设矩阵`A`通过首先将第一列到第三列按列堆叠，形成一个向量`c(A[,1],A[,2],A[,3])`。那么返回的索引就更有意义了。

```
R> which(x=c(A[,1],A[,2],A[,3])>25)
[1] 3 4 6 9
```

将列按顺序排列时，返回`TRUE`的元素是列表中的第三、第四、第六和第九个元素。然而，这种情况可能较难解释，尤其是在处理高维数组时。在这种情况下，你可以通过使用可选参数`arr.ind`（数组索引），使`which`返回特定维度的索引。默认情况下，这个参数设置为`FALSE`，这会导致返回一个转换后的向量索引。而将`arr.ind`设置为`TRUE`时，R 会将对象视为矩阵或数组，而不是向量，从而为你提供所请求元素的行和列位置。

```
R> which(x=A>25,arr.ind=T)
     row col
[1,]   3   1
[2,]   1   2
[3,]   3   2
[4,]   3   3
```

返回的对象现在是一个矩阵，其中每一行表示一个满足逻辑比较的元素，每一列提供该元素的位置。将这里的输出与`A`进行比较，你会发现这些位置确实对应于`A > 25`的元素。

两种输出版本（`arr.ind=T`或`arr.ind=F`）都可能有用——正确的选择取决于具体应用。

**练习 4.3**

1.  存储这个 10 个值的向量：`foo <- c(7,5,6,1,2,10,8,3,8,2)`。然后，执行以下操作：

    1.  提取大于或等于 5 的元素，并将结果存储为`bar`。

    1.  显示包含那些从`foo`中去除所有大于或等于 5 的元素后剩下的元素的向量。

1.  使用(a)(i)中的`bar`构造一个 2×3 的矩阵，称为`baz`，按行填充。然后，执行以下操作：

    1.  将任何等于 8 的元素替换为`baz`中第 1 行第 2 列元素的*平方*值。

    1.  确认`baz`中的*所有*值现在都小于或等于 25 且大于 4。

1.  使用以下 18 个值的向量`c(10,5,1,4,7,4,3,3,1,3,4,3,1,7,8,3,7,3)`创建一个 3×2×3 的数组，称为`qux`。然后，执行以下操作：

    1.  确定元素值为 3 或 4 的维度特定索引位置。

    1.  将`qux`中所有小于 3 或大于等于 7 的元素替换为 100。

1.  从(a)返回到`foo`。使用向量`c(F,T)`从`foo`中提取每隔一个的值。在第 4.1.4 节中，你已经看到，在某些情况下，可以将`TRUE`和`FALSE`替换为`0`和`1`。你能使用向量`c(0,1)`从`foo`中执行相同的提取操作吗？为什么或为什么不？在这种情况下，R 会返回什么？

### **4.2 字符**

字符串是另一种常见的数据类型，用于表示文本。在 R 中，字符串常用于指定文件夹位置或软件选项（如第 1.2 节简要所示）；传递函数参数；以及注释存储的对象、提供文本输出或帮助澄清绘图和图形。简单来说，它们也可以用来定义构成分类变量的不同组，尽管正如你将在第 4.3 节中看到的，*因子*更适合用于此目的。

**注意**

*R 环境中有三种不同的字符串格式。默认的字符串格式叫做*扩展正则表达式*；其他变种分别被称为*Perl*和*字面正则表达式*。这些变种的复杂性超出了本书的范围，因此从这里开始提到的字符字符串都指的是扩展正则表达式。有关其他字符串格式的更多技术细节，请在提示符下输入*`?regex`*。*

#### ***4.2.1 创建字符串***

字符串由双引号`"`表示。要创建一个字符串，只需在一对引号之间输入文本。

```
R> foo <- "This is a character string!"
R> foo
[1] "This is a character string!"
R> length(x=foo)
[1] 1
```

R 将字符串视为一个单独的实体。换句话说，`foo`是一个长度为 1 的向量，因为 R 只计算不同字符串的总数，而不是单个的单词或字符。要计算单个字符的数量，可以使用`nchar`函数。以下是一个使用`foo`的示例：

```
R> nchar(x=foo)
[1] 27
```

几乎任何字符组合，包括数字，都可以是有效的字符字符串。

```
R> bar <- "23.3"
R> bar
[1] "23.3"
```

请注意，在这种形式下，字符串没有数值含义，它不会像数字 23.3 一样被处理。例如，尝试将其乘以 2 会导致错误。

```
R> bar*2
Error in bar * 2 : non-numeric argument to binary operator
```

这个错误发生是因为`*`期望对两个数值进行操作（而不是一个数字和一个字符串，这没有意义）。

字符串可以通过多种方式进行比较，最常见的比较是检查是否相等。

```
R> "alpha"=="alpha"
[1] TRUE
R> "alpha"!="beta"
[1] TRUE
R> c("alpha","beta","gamma")=="beta"
[1] FALSE  TRUE FALSE
```

其他关系运算符的行为如你所料。例如，R 认为字母表中后面的字母大于前面的字母，这意味着它可以根据字母表顺序判断一个字符串是否大于另一个字符串。

```
R> "alpha"<="beta"
[1] TRUE
R> "gamma">"Alpha"
[1] TRUE
```

此外，大写字母被视为大于小写字母。

```
R> "Alpha">"alpha"
[1] TRUE
R> "beta">="bEtA"
[1] FALSE
```

大多数符号也可以在字符串中使用。例如，以下字符串是有效的：

```
R> baz <- "&4 _ 3 **%.? $ymbolic non$en$e ,; "
R> baz
[1] "&4 _ 3 **%.? $ymbolic non$en$e ,; "
```

一个重要的例外是反斜杠`\`，也称为*转义符*。当反斜杠在字符串的引号内使用时，它启动了一些简单的控制，用于控制字符串本身的打印或显示。你将在第 4.2.3 节中看到这一点。首先，让我们看一下两个用于合并字符串的有用函数。

#### ***4.2.2 拼接***

有两个主要函数用于*连接*（或将多个字符串粘合在一起）：`cat`和`paste`。这两者之间的区别在于它们如何返回内容。第一个函数，`cat`，将其输出直接发送到控制台屏幕，并且不正式*返回*任何内容。`paste`函数将其内容连接起来，然后将最终的字符字符串作为可用的 R 对象返回。当字符串连接的结果需要传递给另一个函数或以某种二次方式使用时，这非常有用，而不仅仅是显示出来。考虑以下字符字符串的向量：

```
R> qux <- c("awesome","R","is")
R> length(x=qux)
[1] 3
R> qux
[1] "awesome" "R"       "is"
```

与数字和逻辑值一样，您也可以将任意数量的字符串存储在矩阵或数组结构中，前提是您愿意这样做。

当调用`cat`或`paste`时，您按希望的顺序将参数传递给函数进行合并。以下几行展示了这两个函数的相同用法，但输出类型有所不同：

```
R> cat(qux[2],qux[3],"totally",qux[1],"!")
R is totally awesome !
R> paste(qux[2],qux[3],"totally",qux[1],"!")
[1] "R is totally awesome !"
```

在这里，您使用了`qux`的三个元素以及两个附加字符串`"totally"`和`"!"`，以生成最终的连接字符串。在输出中，请注意，`cat`只是将文本连接并打印到屏幕上。这意味着您不能直接将结果赋值给一个新变量，并将其作为字符字符串使用。而对于`paste`，输出左侧的`[1]`以及`"`引号的存在表明返回的项是一个包含字符字符串的向量，且可以将其赋值给对象并在其他函数中使用。

**注意**

*在使用 R GUI 时，OS X 和 Windows 在默认的字符串连接处理上有所不同。在 Windows 中调用`cat`后，新 R 提示符会出现在与打印字符串同一行，在这种情况下，您可以直接按*ENTER*键进入下一行，或者使用*转义序列*，您将在第 4.2.3 节中学习到。在 OS X 中，新提示符照常出现在下一行。*

这两个函数都有一个可选参数`sep`，用于在字符串连接时作为分隔符。您将字符字符串传递给`sep`，它将在您传递给`paste`或`cat`的所有其他字符串之间插入该字符串。例如：

```
R> paste(qux[2],qux[3],"totally",qux[1],"!",sep="---")
[1] "R---is---totally---awesome---!"
R> paste(qux[2],qux[3],"totally",qux[1],"!",sep="")
[1] "Ristotallyawesome!"
```

对于`cat`，也会发生相同的行为。请注意，如果您不想要任何分隔，可以将`sep=""`（一个空字符串）设置为分隔符，如第二个示例所示。空字符串分隔符可以用于正确的句子间距；请注意，在您首次使用`paste`和`cat`时，`awesome`和感叹号之间的间隙。如果没有包含`sep`参数，R 默认会在字符串之间插入空格。

例如，您可以手动插入必要的空格，编写如下代码：

```
R> cat("Do you think ",qux[2]," ",qux[3]," ",qux[1],"?",sep="")
Do you think R is awesome?
```

当你想要简洁地总结某个函数或一组计算的结果时，连接操作非常有用。许多类型的 R 对象可以直接传递给`paste`或`cat`函数；软件会尝试自动*强制转换*这些项为字符字符串。这意味着 R 会将输入转换为字符串，以便将值包含在最终的连接字符串中。对于数值对象，这种方式尤其有效，以下示例可以证明这一点：

```
R> a <- 3
R> b <- 4.4
R> cat("The value stored as 'a' is ",a,".",sep="")
The value stored as 'a' is 3.
R> paste("The value stored as 'b' is ",b,".",sep="")
[1] "The value stored as 'b' is 4.4."
R> cat("The result of a+b is ",a,"+",b,"=",a+b,".",sep="")
The result of a+b is 3+4.4=7.4.
R> paste("Is ",a+b," less than 10? That's totally ",a+b<10,".",sep="")
[1] "Is 7.4 less than 10? That's totally TRUE."
```

在这里，非字符串对象的值被放置在你希望它们出现在最终字符串输出中的位置。计算结果也可以作为字段显示，如算术运算`a+b`和逻辑比较`a+b<10`所示。你将在第 6.2.4 节看到更多关于一种类型的值强制转换为另一种类型的细节。

#### ***4.2.3 转义序列***

在第 4.2.1 节中，我提到过独立的反斜杠在字符串中不像普通字符那样起作用。`\\`用于调用*转义序列*。转义序列允许你输入控制字符串格式和间距的字符，而不是被解释为普通文本。表 4-3 描述了一些最常见的转义序列，完整列表可以通过在提示符下输入`?Quotes`来查找。

**表 4-3：** 常用的字符字符串转义序列

| **转义序列** | **结果** |
| --- | --- |
| `\n` | 开始换行 |
| `\t` | 水平制表符 |
| `\b` | 调用退格 |
| `\\` | 用作单个反斜杠 |
| `\"` | 包含双引号 |

转义序列为字符字符串的显示增加了灵活性，这在结果汇总和图表注释中非常有用。你可以精确地在想要的地方输入这些序列。我们来看一个例子。

```
R> cat("here is a string\nsplit\tto neww\b\n\n\tlines")
here is a string
split    to new

    lines
```

由于转义符号是`\`，而字符串的开始和结束符号是`"`，如果你希望这些字符之一包含在字符串中，必须使用转义符号让它们被解释为普通字符。

```
R> cat("I really want a backslash: \\\nand a double quote: \"")
I really want a backslash: \
and a double quote: "
```

这些转义序列意味着你不能在 R 中使用独立的反斜杠来表示文件路径字符串。如第 1.2.3 节中所述（你曾使用`getwd`打印当前工作目录，使用`setwd`更改工作目录），文件夹分隔符必须使用正斜杠`/`，而不是反斜杠。

```
R> setwd("/folder1/folder2/folder3/")
```

文件路径的指定在读取和写入文件时经常出现，你将在第八章中深入探索。

#### ***4.2.4 子字符串和匹配***

*模式匹配*让你检查给定的字符串，以识别其中的较小字符串。

函数`substr`接受一个字符串`x`并提取字符串中两个字符位置之间的部分（包括这两个位置），这两个位置由作为`start`和`stop`参数传递的数字指定。让我们试一下第 4.2.1 节中的对象`foo`。

```
R> foo <- "This is a character string!"
R> substr(x=foo,start=21,stop=27)
[1] "string!"
```

在这里，你提取了第 21 个字符到第 27 个字符之间的部分，得到`"string!"`。`substr`函数也可以与赋值运算符一起使用，直接替换为一组新的字符。在这种情况下，替换字符串应包含与选定区域相同数量的字符。

```
R> substr(x=foo,start=1,stop=4) <- "Here"
R> foo
[1] "Here is a character string!"
```

如果替换字符串的长度超过`start`和`stop`指示的字符数，则仍然会进行替换，从`start`位置开始，到`stop`位置结束。它会截断任何超过替换字符数的部分。如果字符串短于替换的字符数，则替换在字符串完全插入时结束，原始字符保持不变，直到`stop`位置。

使用`sub`和`gsub`函数进行替换更加灵活。`sub`函数会在给定的字符串`x`中搜索包含的小字符串`pattern`，然后用新的字符串（作为`replacement`参数）替换第一个匹配项。`gsub`函数做的是相同的事情，但它会替换*每个*匹配的`pattern`。以下是一个例子：

```
R> bar <- "How much wood could a woodchuck chuck"
R> sub(pattern="chuck",replacement="hurl",x=bar)
[1] "How much wood could a woodhurl chuck"
R> gsub(pattern="chuck",replacement="hurl",x=bar)
[1] "How much wood could a woodhurl hurl"
```

使用`sub`和`gsub`时，`replacement`值的字符数不需要与要替换的`pattern`相同。这些函数还具有像大小写敏感度这样的搜索选项。帮助文件`?substr`和`?sub`有更多详细信息，还列出了其他一些模式匹配函数和技术。你可能还想查看`grep`命令及其变体；请参阅相关的帮助文件`?grep`。

**练习 4.4**

1.  完全重新创建以下输出：

    ```
    "The quick brown fox
        jumped over
            the lazy dogs"
    ```

1.  假设你已经存储了值`num1 <- 4`和`num2 <- 0.75`。写一行 R 代码，返回以下字符串：

    ```
    [1] "The result of multiplying 4 by 0.75 is 3"
    ```

    确保你的代码能够生成正确的乘法结果，适用于存储在`num1`和`num2`中的*任何*两个数字。

1.  在我的本地机器上，我在 R 中为这本书的工作指定的目录是`"/Users/tdavies/Documents/RBook/"`。假设这是你的机器——写一行代码，将这个字符串中的`tdavies`替换为你的名字首字母和姓氏。

1.  在第 4.2.4 节中，你存储了以下字符串：

    ```
    R> bar <- "How much wood could a woodchuck chuck"
    ```

    1.  通过将`"if a woodchuck could chuck wood"`这句话粘贴到`bar`后，存储一个新字符串。

    1.  在(i)的结果中，将所有`wood`替换为`metal`。

1.  存储字符串`"Two 6-packs for $12.99"`。然后执行以下操作：

    1.  使用相等性检查，确认从字符 5 开始，到字符 10 结束的子字符串是`"6-pack"`。

    1.  通过将价格更改为$10.99，使其成为更好的交易。

### **4.3 因子**

在这一节中，你将学习一些与创建、处理和检查*因子*相关的简单函数。因子是 R 表示仅属于有限类别的离散数据点的最自然方式，而不是属于连续体的数据。像这样的分类数据在数据科学中扮演着重要角色，你将在第十三章中从统计学的角度再次详细学习因子。

#### ***4.3.1 确定类别***

为了了解因子的工作原理，让我们从一个简单的数据集开始。假设你找到八个人，并记录下他们的名字、性别和出生月份，见表 4-4。

**表 4-4：** 八个个体的示例数据集

| **姓名** | **性别** | **出生月份** |
| --- | --- | --- |
| Liz | Female | April |
| Jolene | Female | January |
| Susan | Female | December |
| Boris | Male | September |
| Rochelle | Female | November |
| Tim | Male | July |
| Simon | Male | July |
| Amy | Female | June |

事实上，表示每个人姓名的合理方式只有一种——作为字符字符串的向量。

```
R> firstname <- c("Liz","Jolene","Susan","Boris","Rochelle","Tim","Simon",
                  "Amy")
```

然而，在记录性别时，你有更多的灵活性。将女性编码为 0，男性编码为 1，数值选项如下：

```
R> sex.num <- c(0,0,0,1,0,1,1,0)
```

当然，也可以使用字符字符串，许多人更喜欢这种方式，因为你不需要记住每个组的数字代码。

```
R> sex.char <- c("female","female","female","male","female","male","male",
                 "female")
```

然而，存储个人姓名和性别数据时，有一个根本性的区别。个人姓名是一个独特的标识符，可以有无限多种可能性，而记录性别通常只有两种选择。这类数据，即所有可能的值都属于有限的类别时，最适合使用 R 中的因子来表示。

因子通常是从数值向量或字符向量中创建的（请注意，你不能使用因子值来填充矩阵或多维数组；因子只能以向量的形式存在）。要创建因子向量，可以使用`factor`函数，下面是一个使用`sex.num`和`sex.char`的示例：

```
R> sex.num.fac <- factor(x=sex.num)
R> sex.num.fac
[1] 0 0 0 1 0 1 1 0
Levels: 0 1
R> sex.char.fac <- factor(x=sex.char)
R> sex.char.fac
[1] female female female male   female male male female
Levels: female male
```

在这里，你可以得到存储性别值的两个向量的因子版本。

乍一看，这些对象看起来与它们所创建的字符向量和数值向量没什么不同。事实上，因子对象的工作方式与向量非常相似，只不过附加了一些额外的信息（R 内部表示因子对象的方式也略有不同）。例如，像`length`和`which`这样的函数在因子对象上的工作方式与在向量上的使用方式是一样的。

因子对象包含的最重要的额外信息（或*属性*；见第 6.2.1 节）是其*水平*，即存储因子中可能值的部分。这些水平会打印在每个因子向量的底部。你可以使用`levels`函数提取这些水平作为字符字符串的向量。

```
R> levels(x=sex.num.fac)
[1] "0" "1"
R> levels(x=sex.char.fac)
[1] "female" "male"
```

你也可以使用`levels`重新标记因子。下面是一个示例：

```
R> levels(x=sex.num.fac) <- c("1","2")
R> sex.num.fac
[1] 1 1 1 2 1 2 2 1
Levels: 1 2
```

这将重新标记女性为`1`，男性为`2`。

因子值向量的子集提取与其他任何向量的子集提取方式相同。

```
R> sex.char.fac[2:5]
[1] female female male   female
Levels: female male
R> sex.char.fac[c(1:3,5,8)]
[1] female female female female female
Levels: female male
```

请注意，在对子集化的因子对象进行子集提取后，即使某些层次不再出现在子集对象中，该对象仍然会继续存储*所有*已定义的层次。

如果你想通过逻辑标志向量从因子中提取子集，请记住，即使原始数据向量是数值型的，因子的层次是以字符字符串形式存储的，因此在请求或测试特定层次时，需要使用字符串。例如，要使用新标记的`sex.num.fac`来识别所有男性，可以使用以下代码：

```
R> sex.num.fac=="2"
[1] FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE
```

由于`firstname`和`sex`中的元素在它们的因子向量中有相应的位置，你可以使用这个逻辑向量来获取所有男性的名字（这次使用的是`"male"`/`"female"`因子向量）。

```
R> firstname[sex.char.fac=="male"]
[1] "Boris" "Tim"   "Simon"
```

当然，这种简单的子集提取方式也可以通过原始的数字向量`sex.num`或原始的字符向量`sex.char`以类似的方式实现。在下一节中，你将探索将分类数据表示为 R 中的因子所带来的一些更独特的优势。

#### ***4.3.2 定义和排序层次***

上一节中的性别因子表示了最简单的因子变量——它只有两个可能的层次，并且没有顺序，因为一个层次并不直观地被认为是“高于”或“跟随”另一个层次。在这里，你将查看具有逻辑顺序的因子层次；例如，出生月份（MOB），其中有 12 个层次，它们有自然的顺序。让我们将之前观察到的 MOB 数据存储为字符向量。

```
R> mob <- c("Apr","Jan","Dec","Sep","Nov","Jul","Jul","Jun")
```

这个向量中的数据存在两个问题。首先，并非所有可能的类别都有表示，因为`mob`只包含七个独特的月份。其次，这个向量没有反映月份的自然顺序。如果你比较一月和十二月，看看哪个更大，你会得到：

```
R> mob[2]
[1] "Jan"
R> mob[3]
[1] "Dec"
R> mob[2]<mob[3]
[1] FALSE
```

按字母顺序排列，这个结果当然是正确的——*J*显然不会出现在*D*之前。但从日历月份的顺序来看，也就是我们感兴趣的部分，`FALSE`的结果就是不正确的。

如果你从这些值创建一个因子对象，你可以通过向`factor`函数提供额外的参数来解决这两个问题。你可以通过向`levels`参数提供一个包含所有可能值的字符向量来定义额外的层次，然后通过将`ordered`参数设置为`TRUE`，指示 R 按`levels`中出现的顺序精确排列这些值。

```
R> ms <- c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov",
           "Dec")
R> mob.fac <- factor(x=mob,levels=ms,ordered=TRUE)
R> mob.fac
[1] Apr Jan Dec Sep Nov Jul Jul Jun
Levels: Jan < Feb < Mar < Apr < May < Jun < Jul < Aug < Sep < Oct < Nov < Dec
```

在这里，`mob.fac`向量包含了与之前的`mob`向量相同的单独条目，并且它们处于相同的索引位置。但请注意，这个变量有 12 个水平，尽管你并没有为`"Feb"`、`"Mar"`、`"May"`、`"Aug"`和`"Oct"`这些水平进行任何观测。（请注意，如果你的 R 控制台窗口太窄，无法显示所有的水平，你可能会看到`...`，表示有更多的输出被隐藏了。只需调整窗口宽度并重新打印对象，就可以看到隐藏的水平。）此外，这些水平的严格顺序通过对象输出中的`<`符号显示。使用这个新的因子对象，你可以执行之前的关系比较，并得到你预期的结果。

```
R> mob.fac[2]
[1] Jan
Levels: Jan < Feb < Mar < Apr < May < Jun < Jul < Aug < Sep < Oct < Nov < Dec
R> mob.fac[3]
[1] Dec
Levels: Jan < Feb < Mar < Apr < May < Jun < Jul < Aug < Sep < Oct < Nov < Dec
R> mob.fac[2]<mob.fac[3]
[1] TRUE
```

这些改进远不仅仅是外观上的。举个例子，具有某些类别零观测值的数据集，与最初定义时类别较少的同一数据集之间，存在很大区别。是否指示 R 正式对因子向量进行排序，也可能对各种统计方法的实现产生重要影响，例如回归和其他类型的建模。

#### ***4.3.3 合并与切割***

如你所见，通常使用`c`函数将多个相同类型的向量（无论是数值型、逻辑型还是字符型）合并起来都很简单。这里有一个例子：

```
R> foo <- c(5.1,3.3,3.1,4)
R> bar <- c(4.5,1.2)
R> c(foo,bar)
[1] 5.1 3.3 3.1 4.0 4.5 1.2
```

这将把两个数值向量合并成一个。

然而，`c`函数在处理因子值向量时并不像处理其他向量那样工作。让我们看看当你在表 4-4 的数据和 MOB 因子向量`mob.fac`（来自 4.3.2 节）上使用它时会发生什么。假设现在你再观察了三个新的个体，其 MOB 值分别是`"Oct"`、`"Feb"`和`"Feb"`，这些值作为因子对象存储，如下所示。

```
R> new.values <- factor(x=c("Oct","Feb","Feb"),levels=levels(mob.fac),
                        ordered=TRUE)
R> new.values
[1] Oct Feb Feb
Levels: Jan < Feb < Mar < Apr < May < Jun < Jul < Aug < Sep < Oct < Nov < Dec
```

现在你有了带有原始八个观测值的`mob.fac`和包含三个额外观测值的`new.values`。它们都是因子对象，定义了相同的、有序的水平。你可能会认为可以通过`c`函数将两者合并，如下所示。

```
R> c(mob.fac,new.values)
 [1]  4  1 12  9 11  7  7  6 10  2  2
```

显然，这并没有达到你想要的效果。将这两个因子对象合并后得到了一个数值向量。这是因为`c`函数将因子解释为整数。通过与已定义的水平进行比较，你可以看到这些数字对应于有序水平中每个月的索引位置。

```
R> levels(mob.fac)
 [1] "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"
```

这意味着你可以使用这些整数与`levels(mob.fac)`结合，获取一个完整的字符向量，包含所有观测数据——原始的八个观测值加上额外的三个。

```
R> levels(mob.fac)[c(mob.fac,new.values)]
 [1] "Apr" "Jan" "Dec" "Sep" "Nov" "Jul" "Jul" "Jun" "Oct" "Feb" "Feb"
```

现在你已经将所有的观测值存储在一个向量中，但它们目前是作为字符串存储的，而不是因子值。最后一步是将这个向量转换为因子对象。

```
R> mob.new <- levels(mob.fac)[c(mob.fac,new.values)]
R> mob.new.fac <- factor(x=mob.new,levels=levels(mob.fac),ordered=TRUE)
R> mob.new.fac
 [1] Apr Jan Dec Sep Nov Jul Jul Jun Oct Feb Feb
Levels: Jan < Feb < Mar < Apr < May < Jun < Jul < Aug < Sep < Oct < Nov < Dec
```

正如这个例子所示，合并因素要求你实际上拆解这两个对象，获取每个条目相对于因素级别的数值索引位置，然后将它们重新组合在一起。这有助于确保级别的一致性，并确保最终产品中的观察值有效。

因素通常也是从原本在连续范围内测量的数据中创建的，例如一组成年人的体重或给患者服用的药物量。有时候，你需要将这些类型的观察值分组（或*分箱*）成不同的类别，比如小/中/大或低/高。在 R 中，你可以使用 `cut` 函数将这类数据转化为离散的因素类别。考虑以下长度为 10 的数值向量：

```
R> Y <- c(0.53,5.4,1.5,3.33,0.45,0.01,2,4.2,1.99,1.01)
```

假设你想按以下方式对数据进行分箱：*小*表示区间[0,2)，*中*表示[2,4)，*大*表示[4,6]。方括号表示*包含*其最接近的值，圆括号表示*排除*，所以如果 0 ≤ *y* < 2，观察值 *y* 将落入小区间；如果 2 ≤ *y* < 4，则落入中区间；如果 4 ≤ *y* ≤ 6，则落入大区间。为此，你可以使用 `cut` 并将所需的分界区间传递给 `breaks` 参数：

```
R> br <- c(0,2,4,6)
R> cut(x=Y,breaks=br)
 [1] (0,2] (4,6] (0,2] (2,4] (0,2] (0,2] (0,2] (4,6] (0,2] (0,2]
Levels: (0,2] (2,4] (4,6]
```

这会给你一个因素，每个观察值现在被分配了一个区间。然而，注意到你的边界区间是颠倒的——你希望边界级别位于左侧，例如 [0,2)，而不是默认情况下位于右侧的 (0,2]。你可以通过将逻辑参数 `right` 设置为 `FALSE` 来修正这个问题。

```
R> cut(x=Y,breaks=br,right=F)
 [1] [0,2) [4,6) [0,2) [2,4) [0,2) [0,2) [2,4) [4,6) [0,2) [0,2)
Levels: [0,2) [2,4) [4,6)
```

现在你交换了哪些边界是包含的，哪些是排除的。这很重要，因为它会改变哪些类别值落入。注意第七个观察值的类别已经发生了变化。但是，仍然存在一个问题：当前的最后一个区间*排除了* 6，而你希望这个最大值能够*包含*在最高的级别中。你可以通过另一个逻辑参数来修正这个问题：`include.lowest`。尽管它被称为“`include.lowest`”，但如果 `right` 设置为 `FALSE`，这个参数也可以用来包含*最高*值，正如帮助文件 `?cut` 中所指出的那样。

```
R> cut(x=Y,breaks=br,right=F,include.lowest=T)
 [1] [0,2) [4,6] [0,2) [2,4) [0,2) [0,2) [2,4) [4,6] [0,2) [0,2)
Levels: [0,2) [2,4) [4,6]
```

现在，区间已经按你想要的方式定义好了。最后，你希望为类别添加更好的标签，而不是使用 R 默认应用的区间级别，可以通过将一个字符向量传递给 `labels` 参数来实现。标签的顺序必须与因素对象中的级别顺序匹配。

```
R> lab <- c("Small","Medium","Large")
R> cut(x=Y,breaks=br,right=F,include.lowest=T,labels=lab)
 [1] Small  Large  Small  Medium Small  Small  Medium Large  Small  Small
Levels: Small Medium Large
```

**练习 4.5**

新西兰政府由国家党、工党、绿党和毛利党组成，还有几个较小的党派统称为其他。假设你问了 20 位新西兰人他们最认同哪个党派，并获得了以下数据：

• 有 12 个男性和 8 个女性；编号为 1、5–7、12、14–16 的个体为女性。

• 编号为 1、4、12、15、16 和 19 的个体认同工党；没有人认同毛利党；编号为 6、9 和 11 的个体认同绿党；10 和 20 认同其他党派；其余认同国民党。

1.  运用你对向量的知识（例如，子集和重写）创建两个字符向量：`sex`，其中包含`"M"`（男性）和`"F"`（女性）；`party`，其中包含`"National"`（国民党）、`"Labour"`（工党）、`"Greens"`（绿党）、`"Maori"`（毛利党）和`"Other"`（其他党派）。确保条目按照前面概述的正确位置放置。

1.  创建两个不同的因子向量，分别基于`sex`和`party`。在这两种情况下使用`ordered=TRUE`是否有意义？R 是如何排列这些水平的？

1.  使用因子子集来执行以下操作：

    1.  返回仅包含男性参与者所选政党的因子向量。

    1.  返回选择国民党参与者的性别因子向量。

1.  又有六人加入了调查，偏好的政党结果是`c("National","Maori","Maori","Labour","Greens","Labour")`，性别为`c("M","M","F","F","F","M")`。将这些结果与(b)中的原始因子结合起来。

假设你还要求所有参与者陈述他们对工党在下一次选举中获得比国民党更多议席的信心，并为这种信心附加一个主观百分比。以下是获得的 26 个结果：93，55，29，100，52，84，56，0，33，52，35，53，55，46，40，40，56，45，64，31，10，29，40，95，18，61。

1.  创建一个表示信心水平的因子，信心水平如下：低为百分比在[0,30]之间；中等为百分比在(30,70]之间；高为百分比在(70,100]之间。

1.  从(e)中提取出那些最初表示认同工党的个体所对应的水平。也为国民党提取相应的水平。你注意到什么了吗？

##### **本章重要代码**

| **函数/运算符** | **简要描述** | **首次出现** |
| --- | --- | --- |
| `TRUE`, `FALSE` | 保留的逻辑值 | 第 4.1.1 节，第 60 页 |
| `T`, `F` | 上述的非保留版本 | 第 4.1.1 节，第 60 页 |
| `==`, `!=`, `>`, `<`, `>=`, `<=` | 关系运算符 | 第 4.1.2 节，第 61 页 |
| `any` | 检查是否有任何条目为`TRUE` | 第 4.1.2 节，第 63 页 |
| `all` | 检查所有条目是否为`TRUE` | 第 4.1.2 节，第 63 页 |
| `&&`, `&`, `&#124;&#124;`, `&#124;`, `!` | 逻辑运算符 | 第 4.1.3 节，第 65 页 |
| `which` | 确定`TRUE`值的索引 | 第 4.1.5 节，第 69 页 |
| `" "` | 创建一个字符字符串 | 第 4.2.1 节，第 73 页 |
| `nchar` | 获取字符串中的字符数 | 第 4.2.1 节, 第 73 页 |
| `cat` | 拼接字符串（无返回值） | 第 4.2.2 节, 第 74 页 |
| `paste` | 拼接字符串（返回一个字符串） | 第 4.2.2 节, 第 74 页 |
| `\` | 字符串转义 | 第 4.2.3 节, 第 76 页 |
| `substr` | 提取字符串子集 | 第 4.2.4 节, 第 77 页 |
| `sub`, `gsub` | 字符串匹配与替换 | 第 4.2.4 节, 第 78 页 |
| `factor` | 创建因子向量 | 第 4.3.1 节, 第 80 页 |
| `levels` | 获取因子的水平 | 第 4.3.1 节, 第 81 页 |
| `cut` | 从连续型数据创建因子 | 第 4.3.3 节, 第 85 页 |
