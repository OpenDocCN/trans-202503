# 前言

![](img/opener-img.png)

根据《C#语言规范》，“C#旨在成为一种简单、现代、通用、面向对象的编程语言。” C#表面上看起来简单，但即使在其最基本的特性中也隐藏着深度。类型系统是 C#的核心元素，是所有 C#程序构建的基础。从 C#的早期版本开始，这一点就一直成立，并且随着语言的发展，这一特性仍然适用。*C#类型系统* 不是一个展示最新语言特性的画廊，我们也不会深入探讨最新版本的每个细节，因为 C#在不断进步；相反，我们将重点关注语言丰富的自定义类型创建支持，并探讨如何最佳利用类型系统来改进设计，编写更清晰、更简单、更高效的程序。

许多语言允许用户定义自己的类型，但 C#不同，它在类（引用类型）和值类型之间做出了明确的区分。*类* 是在 C#中实现设计的默认选择，是自定义类型的通用机制，因为它支持 C#所提供的所有面向对象功能。相比之下，*值类型* 更为专门化，这也是它们常常被误解和忽视的原因，认为它们是一个只对少数应用程序有用的高级特性。确实，值类型并不适用于应用程序中的许多自定义类型，也不一定在每个设计中都是必须的，但它们有几个常被低估的优点。

通过典型的实际案例，本书将引导你有效且高效地定义和实现值类型，使其能够与应用程序中的其他类型成功协作。具体来说，我们将探讨以下内容：

+   为什么 C#区分值类型和引用类型，以及这在实践中的含义

+   值类型与其他类型在语法和语义上的不同之处

+   如何将值类型融入代码中，提升代码质量，并帮助你更清晰地表达设计

+   除了语言定义的那些之外，值类型的哪些特征对它们在应用程序中的角色最为重要

+   在哪里可以使用值类型来提升应用程序的性能

## 谁应该阅读本书

如果你已经学习了 C#的基础知识，并希望扩展对语言的理解，成为更好的程序员，那么本书适合你。接下来的章节没有特别高级的内容，但它们旨在帮助你理解一些 C#编程中的基本特性、原则和概念。我希望本书能帮助你超越仅仅使用正确的 C#语法编写可运行的程序，能够编写出同事们能够轻松理解的地道而高效的 C#程序。

要跟随本书中的示例，你需要有创建自己类的经验；熟悉构造函数、方法和属性；并且对虚方法如何被派生类重写有基本的理解。对于异常的处理和使用，也需要一些实践经验，这将对管理错误有所帮助。虽然并非必需，但理解如何定义泛型类型和方法的机制也会有所帮助；特别是，如果你有使用标准库中提供的泛型集合类的经验，会帮助你深入理解 C# 中泛型的工作原理。《C# 类型系统》不是一本面向初学者的指南，它不会讨论如何编译和运行代码，但你不必了解语言的每个细节。尽管如此，我希望本书的某些部分能够娱乐并可能令更高级的用户感到惊讶。

当某些特性变得基础时，我们有时会对它们产生自满情绪。考虑到这一点，本书的许多章节涵盖了经验丰富的 C# 程序员可能认为是入门内容的细节。这些内容的目的是为一些依赖于这些基础知识的较少被理解的概念奠定基础。

如果你对 C# 代码有较深的了解，或者有 Java 或 C++ 等其他面向对象语言的经验，我希望这里的示例和评论能帮助你更好地理解 C# 的语法和语义，并更好地理解为什么 C# 会发展成今天的样子。

本书并没有覆盖 C# 编程的所有方面，重点是值类型与引用类型之间的交互。在这个讨论中，我们将简单介绍 C# 泛型、集合、语言集成查询（LINQ）和线程，但只是皮毛。我们*不会*讨论 不安全 代码或 C# 指针。（实际上，这里提到过一次*托管*指针。除此之外，内容非常稳定。）

我们不会讨论如何创建 Web 服务、与数据库交互或编写用于云或微服务应用程序的分布式程序，但本书中介绍的 C# 技巧和基本原理将有助于提升你在这些领域以及其他领域所创建的应用程序。

如果你曾经问过自己或别人，为什么在 C# 程序中值类型比引用类型更合适，并且发现自己无法给出令人满意的回答，那么你应该会觉得这本书非常有用。

## 组织结构与要求

本书分为八章，每一章展示了值类型在实际中的不同应用：

**第一章: 最大化类型系统的利用**   考察了用户定义值类型的重要性，并且分析了在应用程序中引入即使是简单类型如何使代码更容易阅读和理解。它涵盖了精确命名的重要性、封装特定应用行为的好处，以及如何让自己的类型直观且易于使用。

**第二章: 值类型与引用类型**   分析了为什么 C# 同时存在引用类型和值类型，并详细比较了它们。我们考虑了不同类型的对象如何使用内存，这对它们的生命周期意味着什么，以及类型之间的差异如何影响构造、相等性和复制。我们回顾了可空值类型，并将其与更新的可空引用类型特性进行了比较。

**第三章: 引用与值参数**   考察了四种方法参数类型以及如何将参数传递给它们，并且分析了值类型和引用类型在传递行为上的差异。我们区分了传递引用类型变量与按引用传递参数，探讨了这一点与可变性和副作用之间的关系。我们还考虑了如何通过不可变引用传递值类型实例以优化性能。

**第四章: 隐式与显式复制**   讨论了程序中如何复制值，以及值类型和引用类型之间复制行为的差异如何在代码中产生意想不到的后果。特别地，我们区分了变量和数值，探讨了使值类型不可变如何帮助防止一些常见的复制相关错误。我们还研究了如何减轻复制可能引入的低效问题。

**第五章: 相等性的类型**   介绍了值如何进行相等性比较的不同方式，以及在这些比较过程中幕后发生了什么。实现基于值的相等性比较是常见的错误源，因此我们将演示如何安全且正确地实现这一点，以及如何利用编译器为此目的提供的设施。

**第六章: 值的本质**   概述了应用程序中不同类型的特点和角色，以及值类型的角色不仅仅是作为存储数据的方便方式。我们研究了*值语义*的含义，以及使一个对象成为值类型的条件。我们还讨论了对象排序的重要性，并区分了相等性和等价性。

**第七章: 值类型与多态**   探讨了为什么继承并不是值类型的合适多态形式，通过一个示例展示了可能出现的问题。我们详细了解了子类化与子类型化之间的差异，并讨论了其他类型的多态性如何更适合处理值。

**第八章：性能与效率**   探讨不同类型如何影响应用程序的性能，以及如何精确测量性能，从而做出基于证据的决策。本章还讨论了接受默认行为如何对代码性能产生不利影响，并澄清了一些关于编译器生成代码和效率的常见误区。

许多代码片段使用简单的测试来演示某种行为或语言特性。示例中使用了 NUnit 流式风格断言，它提供了一种常见且简洁的方式来表达正在讨论的概念。C# 也有多种其他单元测试框架，你应该能轻松地将 NUnit 测试片段转换为其他风格。

你很快就会发现，单独的代码示例通常无法以其展示的形式编译。为了简洁起见，某些细节（如导入命名空间或定义 Main）被省略。代码示例旨在引导你关注某个概念，而非展示一个合法的程序。

## 现代特性

近年来，语言设计者在提升 C# 支持高效、高性能应用程序开发方面付出了大量努力。虽然语言的核心思想保持不变，但已经增加了许多新功能，尤其是在简单值类型方面，并引入了新特性，使得 C# 程序员能够利用值类型来最大化应用程序性能。本书探讨了其中的一些特性，但主要是在*经典* C# 编程的背景下，而不仅仅是高性能计算。这些特性不仅能使程序对人类读者更清晰，还能提高运行时效率。

本书中的大多数代码示例展示了多个 C# 版本中广泛使用的概念，有些使用了自 C# 1.0 起就已存在的特性。对于最近引入的特性，书中会指明所需的最低编译器版本。

在应用程序中有效地使用值类型需要你额外思考，不仅仅是关于这些类型的设计，还需要考虑它们的使用方式。*C# 类型系统*详细描述了值类型在各种场景中的行为，帮助你以现代、惯用且高效的方式编写 C# 代码。深入理解值类型如何融入 C# 类型系统，将帮助你丰富设计并编写更好的程序。

## 为什么选择值类型？

虽然*类*是面向对象编程和设计的代表，但谦逊的*值类型*常常被忽视。然而，合理使用值类型可以带来许多好处，包括更好的性能。值类型实例不会单独分配到堆上，也不需要进行垃圾回收。将对象分配到堆上会带来轻微的性能损失，因为垃圾回收器必须检查内存中的每个对象，无论它是否正在使用，以确定它是否符合回收条件。

减少程序基于堆的内存使用可能意味着垃圾回收器运行的次数减少，并且每次运行时需要做的工作也更少。减少堆内存压力有可能提高你编写的代码的执行速度。尽管垃圾回收算法已被精心调整，以最小化对运行中程序的影响，但完全避免垃圾回收会更加高效。

把所有对象都转换成值类型几乎肯定不会神奇地提高程序的性能，但值类型的故事远不止性能，就像源代码不仅仅是一个程序，编程也不仅仅是敲代码。理解值语义可以帮助你决定在设计中哪些地方可以使用值类型，以及如何实施它们以最有效地实现目标。同样重要的是，理解值语义能帮助你判断在哪些地方值类型*不*合适。

在本书的过程中，你将学习值语义对 C#程序的意义，以及如何成功高效地使用值类型。在这个过程中，我们将详细了解值类型的行为以及为什么它们会这样表现。不过，首先我们将探讨如何使用简单的值类型来使代码更容易为人类理解。让我们开始吧。
