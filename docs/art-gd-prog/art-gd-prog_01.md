# 第一章：绘制基础

![](img/chapterart.png)

## 草图 1：一个圆

在 C 或 Java 中绘制一个圆需要相当多的代码，但在 Processing 中，它是最简单的程序之一。Processing 中没有圆形函数，因此为了绘制一个圆，我们绘制一个宽度和高度相等的椭圆，这与圆形是一样的。

### 示例 A

`setup()` 函数调用预定义的 `size()` 函数来打开一个宽度为 400 像素，高度为 300 像素的草图窗口 1。

`draw()` 函数每次被调用时（默认每秒 60 次）都会绘制一个圆形，使用 `ellipse()` 函数，它有四个参数。前两个参数指定椭圆中心的像素坐标。后两个参数指定椭圆的宽度和高度。调用 `ellipse (200, 150, 50, 50)` 2 绘制一个中心位于 (200, 100) 的椭圆，宽度和高度都是 50 像素，实际上是一个直径为 50 像素的圆。

默认情况下，背景颜色设置为中灰色，填充圆形的颜色为白色。圆形的轮廓由黑色线条勾画。

### 示例 B

这个示例与示例 A 很相似，但现在背景颜色设置为白色，填充圆圈（以及其他任何基本的闭合形状）的颜色设置为黑色。

`background()` 函数 1 用一个单一的数字参数指定背景颜色，范围从 0 到 255，表示灰度级别，其中 0 为黑色，255 为白色。范围之外的数值是非法的。在这个例子中，颜色设置为白色（`255`）。`background()` 函数在 `draw()` 函数中被调用，这样每次都会重新绘制背景。如果 `background()` 在 `setup()` 中被调用，背景只会在执行开始时绘制一次。

`fill()` 函数 2 指定基本闭合形状的填充颜色，使用与 `background()` 函数相同的单一数字参数。在这个例子中，填充颜色设置为黑色（`0`），直到通过另一次调用 `fill()` 改变。因此，`fill()` 本可以仅在 `setup()` 中调用一次，效果也将相同。

### 示例 C

在这个例子中，背景颜色（白色 = `255`）1 和填充颜色（黑色 = `0`）2 在 `setup()` 中被指定。这个草图在 `draw()` 函数中绘制了两个椭圆，而不是圆形，以展示宽度和高度参数是如何使用的。第一次调用 `ellipse()` 3 绘制最左边的椭圆，宽度为 100 像素，高度为 50 像素。第二次调用 `ellipse()` 4 绘制最右边的椭圆，宽度为 50 像素，高度为 100 像素。

`noFill()` 函数使得椭圆和其他对象绘制时没有填充颜色，以便背景颜色能够显示在物体内部。

## 草图 2：颜色

我们可以通过单一的数值分量来指定灰色的色调，但我们也可以通过提供三个数值分量来指定颜色，这些分量的顺序是传统的：红色、绿色、蓝色。每个分量都占用一个字节（8 位），并且它由一个范围从 0 到 255 的数字表示，决定了该分量的色调。数值越小，颜色越暗。

数字（255, 0, 0）指定了最亮的红色，而数字（254, 0, 0）指定了稍微暗一点的红色。绿色是（0, 255, 0），蓝色是（0, 0, 255）。黄色是红色和绿色的组合，因此黄色的 RGB 坐标是（255, 255, 0）。品红色是红色和蓝色的组合，因此它表示为（255, 0, 255）。灰色的值则是三个分量几乎相等的情况。

这是颜色的 RGB 表示法。还有其他的表示方法。

### 示例 A

这个草图绘制了不同颜色的圆圈。在 `draw()` 函数中，前三次调用 `fill()` 和 `ellipse()` 绘制了第一行圆圈：红色 1、绿色 2 和蓝色 3。每次绘制圆圈之前，填充颜色都会发生变化。

第二行的圆圈分别填充了黄色 4、品红色 5 和青色 6。每种颜色都有两个非零的色值。

最后一行包含一组填充颜色逐渐变亮的灰色圆圈 7。这里的每种颜色都有三个相等的色值。

### 示例 B

我们还可以使用第四个颜色分量来表示透明度，通常称为 alpha 通道。分量（255, 0, 0, 128）表示红色是 255，绿色和蓝色是 0，透明度是 128，或 50%。数值越大，透明度越低。我们可以为任何颜色指定任何合法的透明度值，除了 R、G 和 B 分量。

这个草图绘制了一些重叠的红色、绿色和蓝色圆圈来展示透明度。

在 `draw()` 函数中，前三次调用 `fill()` 和 `ellipse()` 绘制左上方的一组圆圈，填充颜色的透明度值为 20\。

后三次调用绘制右上方的一组圆圈，透明度值为 100\。

第三次调用 3 绘制了左下方的一组圆圈，透明度值为 180。

最后三次调用 4 绘制了右下方的一组圆圈，透明度值为 255，这意味着颜色是完全不透明的。

## 草图 3：if 语句—有条件地改变颜色

在日常生活中，人们经常处理有条件的行为，虽然很少有意识地去思考这个概念。我们当然用人类语言表达这些条件：

1.  “如果下雨，我们看电视；如果是晴天，我们去滑雪。”

1.  “如果红灯亮了，那就停；如果绿灯亮了，那就继续开。”

我们在编程时也可以使用条件动作。如果某种情况为真，我们执行某段代码。条件或情况必须以数字形式表达，结果是`true`或`false`。这样的条件通常是数字之间比较的结果，比如“*i*是否等于 10”或“x 坐标是否小于宽度”。

条件代码通过`if`语句来处理，其语法如下：

```
if ( condition ) code ; 
```

条件可以是数字之间的比较，因此以下都是条件：

```
(x > 2)      (P < q+1)     (width == 640)     (width != height)
```

这里有一些特殊符号在使用。`=`符号表示赋值，因此要比较是否相等，必须使用另一个符号：Processing 使用`==`。要比较不相等，使用符号`!=`，表示“不等于”。

### 示例 A

这个草图使用`if`语句，每次调用`draw()`时增加一个整数变量`count`，并在`count`达到 100 时将背景颜色从红色变为绿色。

### 示例 B

之前的英语条件示例展示了另一种常见的使用方式：否则。一个例子是“如果下雨，我们就看电视；如果是晴天，我们就去滑雪。”这个例子也可以这样表达：“如果下雨，我们就看电视；否则我们就去滑雪，”意思是如果没有下雨，我们就去滑雪。在大多数编程语言中，这通常写作`else`部分，作为`if`语句的附加部分，语法如下：

```
if ( condition ) code ;
else code;
```

示例 B 使用`else`来实现与示例 A 相同的任务。

### 示例 C

第三个代码示例在每次调用`draw()`时交替使用红色和绿色，产生一个颜色闪烁效果。

## 草图 4：循环——绘制 20 个圆

程序员通常需要反复执行相同的代码，有时会有一些小的变化。一个绘制 50 个椭圆的程序可以写成五十次调用`ellipse()`函数，每次绘制一个椭圆。另一种方法是使用一个语句调用`ellipse()`，并在循环中执行 50 次。

程序中的循环是一个语句集合，它从第一个语句执行到最后一个语句，并且按相同的顺序重复执行。你必须指定一个条件，来决定循环何时退出。通常情况下，你知道循环应该执行多少次，比如绘制 50 个椭圆的例子。有时你不知道次数，但可以通过计算来得出，那么循环将执行*N*次，*N*取决于其他因素。在这两种情况下，计数循环在 Processing 中称为`for`循环，因为预留字`for`用于开始循环。例如：

```
for (i=0; i<10; i=i+1)  statementA ;
```

这个循环执行 10 次：当变量`i=0`时执行一次，当`i=1`时再执行一次，当`i=2`时再执行一次，依此类推直到`i=9`。当`i`为 10 时，条件（`i<10`）变为假，循环结束。因此，`statementA`执行了 10 次，每次对应`i`从 0 到 9 的值。

`for`循环有四个部分：

1.  `i=0` 初始化操作在循环的第一次执行时进行。

1.  `i<10` 只要循环条件为真，循环将继续执行。

1.  `i=i+1` 在每次迭代结束时，语句执行完后，递增操作会执行。

1.  `statementA` 这是反复执行的代码。

如果在开始时条件为假，则循环一次也不会执行。

执行的语句可以是复合语句，即一组由大括号括起来的语句。事实上，每当我提到*语句*时，它都可以指代复合语句。

### 示例 A

在 Processing 中，一个简单的循环可以绘制 20 个椭圆，起点为(20, 40)，终点为(210, 40)。这些椭圆是圆形的，并且彼此相邻。`draw()`函数存在但不执行任何操作。

### 示例 B

我们可以通过使用复合语句来使每个圆的颜色发生变化。每次绘制一个圆时，将绿色值增加 10，从`green = 10`开始。红色和蓝色的值保持在最大值 255。循环中的代码需要设置填充颜色、绘制圆形，并在下一次迭代时调整填充颜色。

循环会执行 20 次，即`i`的值从 0 到 19（包括 19）。如果我们展开代码以展示执行的内容，它会如下所示：

```
(i=0);  fill (255, 10, 255);  ellipse (20, 40, 10, 10);  g = 20;
(i=1);  fill (255, 20, 255);  ellipse (30, 40, 10, 10);  g = 30;
(i=2);  fill (255, 30, 255);  ellipse (40, 40, 10, 10);  g = 40;
`--snip--`
(i=19);	 fill (255, 190, 255); ellipse (210, 40, 10, 10); g = 200;
```

## 草图 5：线条

绘制线条是图形绘制中的基本操作。在 Processing 中，线条实际上是线段，通过标识两个要连接的端点来指定。绘制线条的函数名为`line()`，它接受两个端点的坐标作为参数（共四个参数）。调用`line (10,10, 20,20)`将在窗口中绘制一条从坐标(10, 10)到(20, 20)的线。

### 示例 A

让我们来画一些便签纸。我们可以通过以下调用绘制一条水平线，这条线将横跨整个草图窗口的宽度，`y`表示垂直位置：

```
line (0, y, width, y);
```

窗口的宽度由变量`width`给出，窗口的高度由变量`height`给出。线的起点是`(0, y)`，位于图像窗口的左侧，距离顶部`y`像素；线的终点是`(width, y)`，位于窗口的右侧，且`y`值保持不变。

绘制线条的颜色可以通过调用`stroke()`并传入颜色参数来指定。例如，`stroke (255,0,0)` 表示将绘制红色线条。

### 示例 B

Processing 会通过内建变量`mouseX`和`mouseY` 1 告诉你鼠标光标在窗口中的位置。每当按下鼠标按钮时，Processing 会调用一个名为`mousePressed()`的函数（如果它存在）。如果你希望使用鼠标，必须编写这个函数。当鼠标按钮释放时，Processing 会调用`mouseReleased()`函数 2。你也必须编写这个函数。`mousePressed()`和`mouseReleased()`函数被称为回调函数，它们提供了一种非常简单的方式来访问按钮按下事件。此外，按下和释放操作相当于触摸屏设备上的触摸操作，因此该程序也可以在触摸屏设备上运行。

这个例子使用鼠标点击（按下和释放）来绘制线条。第一次鼠标点击定义了线条的起点（`x0`，`y0`）3。第二次点击（当`x1 < 0`时）4 定义了线条的终点。第三次点击（当`x1 >= 0`时）5 清除终点并重新开始。

## 草图 6：数组——绘制多个圆形

变量可以保存一个值，比如一个数字。如果我们需要更多的值，可以使用更多的变量。例如，若要绘制两个圆形，我们可以有两组坐标变量，分别是`x0`、`y0`和`x1`、`y1`，然后我们可以通过两次调用来绘制这两个圆形：

```
ellipse (x0, y0, 10, 10);
ellipse (x1, y1, 10, 10);
```

但是，如果我们希望每次点击鼠标时都绘制一个圆形，并且把圆形绘制在光标所在的屏幕位置呢？我们无法提前知道要绘制多少个圆形，因此也不知道要声明多少个变量。相反，我们可以使用 Processing 所称的数组来跟踪*x*和*y*。数组是一个包含相同类型值的集合。声明数组的语法是

```
int [] x = new int[100];
```

这个声明定义了一个名为`x`的数组，它可以存储 100 个整数。`int [] x`表示“定义一个名为 x 的新数组”，`new int[100]`表示数组的大小，其中 100 可以被任何常量替代。上述声明也可以分两部分进行：

```
int [] x;
x = new int[100];
```

你通过索引访问数组中的值，索引是一个数字，用来指定你想要的值，索引从 0 开始：`x[0]`是数组中的第一个元素（值），索引为`0`，`x[1]`是第二个元素，索引为`1`，以此类推，直到最后一个元素`x[99]`。

示例草图使用了两个数组，一个用于`x`，一个用于`y`，并在鼠标点击（按下和释放）时绘制圆圈的坐标。最初在`setup()`中，`x`和`y`数组的每个元素被赋值为-1 1。这称为哨兵值，它表示该索引位置没有定义圆圈。`ncircles`变量表示已经定义了多少个圆圈，即记录了多少次鼠标点击；它从 0 开始，并递增至最大圆圈数量（`MAXCIRCLES`，一个定义为 100 的常量）。当鼠标按钮释放时，系统调用`mouseReleased()`回调函数 3，保存当前鼠标坐标的值到`x`和`y`数组的当前位点（`ncircles`），并将`ncircles`增加 1。如果`ncircles`等于`MAXCIRCLES`，它会被重置为 0 4，这意味着新的圆圈将覆盖最早绘制的圆圈。旧的圆圈自然会丢失。

`draw()`函数首先设置背景，然后在鼠标坐标处绘制一个圆圈。接着检查`x`数组的所有元素，如果元素`i`的值大于 0，就会使用以下调用在`x[i], y[i]`的位置绘制一个圆圈：

```
ellipse (x[i], y[i], 18, 18);
```

常量值`MAXCIRCLES`在声明时使用特殊的`final`属性进行定义：

```
final int MAXCIRCLES = 100;
```

`MAXCIRCLES`的值在程序中不能被更改，因为它是`final`。它可以（并且应该）用于定义两个数组的大小：

```
int x[] = new int[MAXCIRCLES];
```

使用常量定义数组的大小意味着，要增加允许的圆圈数量，只需要更改`MAXCIRCLES`的值。

## 草图 7：带有橡皮筋的线条

我们将再次使用鼠标绘制线条。一条线由一个起点和一个终点组成，每个点都有 x 和 y 坐标。我们之前在鼠标点击屏幕上的起点和终点时绘制了一条线，但它只绘制了*一*条线。如果我们想能够像这样绘制多条线，该怎么办呢？

我们可以像之前一样，当鼠标按下时定义起点 3，释放按钮时定义终点 4。但现在我们可以将这些点存储在数组中，并在每次屏幕更新时绘制它们。数组`x0`保存线条的起始 x 坐标，`y0`保存对应的 y 坐标。数组`x1`和`y1`将存储终点坐标。当鼠标按下时，我们保存起点(`x0[n]`, `y0[n]`)，当鼠标释放时，我们保存终点为`x1[n]`和`y1[n]`，并将`n`的值递增。由于数组的固定大小，该程序将允许我们绘制 256 条线。

当起始点被选择后，我们从该点画一条线到当前的鼠标坐标，以显示这条线*应该*如何呈现。这被称为橡皮带效果，因为线条在鼠标移动时看起来像是伸展和收缩。当鼠标按钮被释放时，我们确定最终坐标并画出最终的线条。

在每一帧中（默认是每秒 30 帧），我们通过调用 `line (x0[i], y0[i], x1[i], y1[i])` 来绘制所有保存的线条，`i` 从 `0` 到 `n-1`。然后，如果鼠标按钮当前被按下（当 `down` 被设置为 `true` 时），我们将绘制橡皮带线。在 `mousePressed` 中设置 `down` 为 `true`，在 `mouseReleased` 中将其设置为 `false`。如果 `down` 为 `true`，则从最后选定的点到鼠标坐标之间绘制一条线：

```
line (x0[n], y0[n], mouseX, mouseY);
```

这实现了橡皮带效果。

作为一种新功能，草图实现了一个 *擦除* 特性。如果用户按下退格键，最近的线条将被删除。当系统检测到按键时，Processing 会调用一个用户定义的名为 `keyPressed()` 的函数。一个名为 `key` 的变量提供了被按下的键的值，因此在 `keyPressed()` 内，我们检查按下的键是否是退格键，如果是，则将变量 `n`（到目前为止的线条数）减 1。结果是，最后一条线不会被绘制，下一条线将覆盖被擦除的线条在坐标数组中的位置。

## 草图 8：随机圆圈

这个草图在屏幕上随机位置绘制圆圈，并使用随机颜色。随机性指的是不可预测性，它是一个复杂的概念。如果你尝试用铅笔画直线，那么不可能有两条完全相同的直线。总会有些微小的变化，导致每条线有所不同。画画时也一样，笔触不会完全一致。没有两个人类活动会完全相同，差异虽不可预测，但是显而易见的。

使用计算机时，随机数生成器会创建彼此间相对随机的数字。随机数可用于模拟游戏中的随机事件，比如骰子或扑克牌，用来做一些用户难以预测的事情，或模拟复杂的现实世界情境。例如，道路上车辆之间的间距以及窗户上雨滴的出现看似随机，因为我们并不了解所有涉及到的复杂因素。

Processing 中的随机数生成器被命名为 `random`。调用 `random (100)` 将生成一个介于 0 和 100 之间的实数，但不包括 100。调用 `random (10, 20)` 将返回一个介于 10 和 20 之间的实数，但小于 20。调用 `random (0, width)` 会生成一个介于 0 和窗口宽度之间的随机 *x* 坐标，而 `random (0, height)` 会生成一个介于 0 和窗口高度之间的随机 *y* 坐标。

像 Sketch 6 一样，这个草图将坐标存储在数组中，并通过调用 `ellipse()` 来绘制圆形，但不是在点击鼠标时绘制圆形，而是每秒自动创建一个新的圆形。为此，我们在 `setup()` 中通过调用 `frameRate(1)` 将 `draw()` 的调用频率设置为 1。每次调用 `draw()` 时，我们使用 `random()` 生成一个新的 x 和 y 坐标，并将其保存在 `x` 和 `y` 数组中：

```
x[ncircles] = (int)random(0, width); 
y[ncircles] = (int)random(0, height);
```

调用 `random` 时前面的 `(int)` 将结果（`float` 类型）转换为新类型 `int`。这叫做类型转换，我们将浮点值转换为整数，因为不能使用带小数点的值作为坐标。也可以使用调用函数 `int()` 来实现这一点：

```
x[ncircles] = int(random(0, width)); 
y[ncircles] = int(random(0, height));
```

## 草图 9：一个矩形

你可以通过绘制四条代表矩形边缘的线来绘制一个矩形，但 Processing 系统不会认为这是一种矩形；它无法知道这四条线是一个单独的对象。相反，Processing 提供了一个绘制矩形的函数，叫做 `rect()`。矩形会使用当前的填充颜色，就像绘制圆形时一样。

指定矩形的默认方式是 `CORNER` 模式，在这种模式下，你提供的前两个参数是矩形左上角的坐标，后面跟着矩形的宽度和高度（以像素为单位）。如果你指定 `CENTER` 模式，前两个参数是矩形中心的坐标。`CORNERS` 模式指定的是第一个角的坐标，然后是对角线另一角的坐标。你可以使用以下调用之一来更改模式：

```
rectMode(CORNER);
rectMode(CENTER);
rectMode(CORNERS);
```

在这个草图中，我们将使用 `CORNERS` 模式 1，正如在 `setup` 函数中指定的那样，并将矩形填充为一种紫色的色调：（`200, 0, 160`）。与之前的草图一样，当鼠标按钮被按下时，`mousePressed()` 函数将布尔值 `flag` 变量设置为 `true` 3，而 `mouseReleased()` 则清除该变量（将其设置为 `false`） 5。

全局变量 `x` 和 `y` 代表矩形的第一个角，并初始化为 -1。当鼠标按钮被按下时，我们将 `x` 和 `y` 设置为当前的 `mouseX` 和 `mouseY` 值 4，并将 `flag` 变量设置为表示 `x` 已设置。然后，`draw()` 函数将绘制一个矩形，以 `(x, y)` 作为一个角，当前鼠标位置 `(mouseX, mouseY)` 作为另一个角 2。这样就实现了橡皮筋效果。

全局变量 `x1` 和 `y1` 是矩形第二个角的坐标。当鼠标释放时，我们将 `x1` 和 `y1` 的值设置为当前鼠标坐标 6，这样矩形就完成了。`draw()` 函数将使用 `x1` 和 `y1` 作为对角线的另一角来绘制矩形，因为 `flag` 现在为假。

## 草图 10：三角形与运动

就像使用内置的`rect()`函数绘制矩形一样，三角形是通过内置的`triangle()`函数绘制的。三角形不能通过高度和宽度来绘制；它们的形状由三个角度决定。因此，`triangle()`函数有六个参数：三个顶点（角点）的 x, y 坐标。

这个草图使用鼠标绘制三角形。与前面绘制矩形和线条的草图一样，这个草图使用`mouseReleased()` 3 来确定何时选择一个点。经过三次点击后，三角形将使用这三个选择的点作为顶点绘制出来。

三角形绘制完成后，它开始向下移动，好像被轻轻推了一下。它继续向下移动，直到碰到草图窗口的底部边界，在那里它消失了。

我们通过在每次绘制三角形后，将一个小值 1（`delta` = 1）添加到三角形的 y 坐标来实现这个运动。这样，三角形会在窗口中依次绘制在较低的位置，直到它似乎越过了窗口的底边。事实上，三角形仍然存在于 Processing 系统中，尽管它无法被看到，其坐标仍在更新。

如果该程序的用户在三角形绘制后点击鼠标，三角形会消失，绘图过程重新开始。我们通过将所有顶点重新初始化为−1 4 来重新启动绘图过程，这表示它们还没有被定义。

以下代码行在`draw()`内部被注释掉：

```
2 // delta = delta + 1;
```

如果你删除行首的`//`，该行代码将会执行，三角形将会加速下落，就像受到某种力（例如重力）的作用一样。也删除`mouseReleased()`末尾附近的`//`，这样每次绘制新的三角形时，初始速度将重置为 1。

## 草图 11：显示文本

文本在几乎所有实用的计算程序中都是必不可少的，在许多生成艺术和网络艺术程序中也是如此。文本是人类沟通的主要方式，尽管我们常说“一张图胜过千言万语”，但实际上，几句精心挑选的话常常能把一幅本来难以理解的图像变成有价值的沟通工具。例如，想想图表轴上的标签。

我们在草图窗口中绘制文本的方式与绘制线条和椭圆的方式相同，使用一个简单的函数。首先，你需要知道的是，文本的绘制是从特定的(*x*, *y*)位置开始的，其中 *x* 和 *y* 表示包围文本的框的左下角的坐标（*不考虑下行字形*）。像 *y* 和 *j* 这样的字符会延伸到这个框的下方，因此它们的 *y* 值大于指定的值。

我们将通过调用`text()`函数来绘制文本 2：

```
text ("This is a string to be drawn", 100, 20);
```

在这种情况下，字符串左下角的坐标是`(100, 20)`。初始字体和大小是默认值，这些默认值依赖于系统。可以使用`textSize(n)`函数轻松指定大小，传递所需的字符大小*以像素为单位*（不是点数）。绘制文本的颜色是当前的填充颜色，而不是描边颜色。

文本的对齐可以通过调用`textAlign()`函数来指定。水平对齐可以是`LEFT`、`CENTER`或`RIGHT`，相对于在`text()`函数调用中指定的 x 和 y 坐标；默认值是`LEFT`。垂直对齐可以是`TOP`、`CENTER`、`BOTTOM`或`BASELINE`，相对于在`text()`函数调用中指定的 x 和 y 坐标；默认值是`BASELINE`。`BOTTOM`是定义任何字符最低*y*值的行，例如下降部分的底部。`BASELINE`定义了没有下降部分的典型字符的最低点。因此，调用

```
textAlign (CENTER, BOTTOM);
```

会使当前文本从左到右居中（指定的*x*值是字符串的中心），并使其对齐，以便指定的*y*值是字符串的底部。

示例 A 展示了如何以两种不同的大小显示文本。示例 B 显示了一条在每个 x 坐标上水平绘制并在每个 y 坐标上垂直绘制的线。它展示了文本相对于指定坐标的对齐情况。

## 示例 12：操作文本字符串

前面的示例实际上是对字符字符串的介绍，字符字符串是一种人与计算机交流的自然方式。字符串是字符的序列；单词、句子或段落也是如此。从高层次来看，字符串由按特定顺序排列的字符集合组成。它有第一个字符、第二个字符，以此类推，直到到达最后一个字符。这个序列中字符的数量就是字符串的长度。

字符串常量是用双引号括起来的字符序列，如：`"To be or not to be"`。我们可以使用字符串常量声明`String`类型的变量并为其赋值。例如，在 1 中，我们声明了两个字符串变量并为其赋值字符串常量：

```
String s1 = "To be or not to be"
String s2 = "that is the question."
```

字符串可以通过将其他字符串拼接在一起来构造。当对字符串应用`+`运算符时，意味着连接或附加，因此可以通过拼接这两个字符串来完成引号：

```
s1 = s1 + s2;
```

这使得`s1`变成了`"To be or not to bethat is the question."` 不幸的是，这样不太对，因为我们需要在两个字符串之间加上一个逗号和一个空格。这样会更好：

```
2 s1 = s1 + ", " + s2;
```

这个新字符串中的第一个字符“T”在索引位置 0，意味着它在字符串的第 0 位置。字符“o”在位置 1，以此类推。

子字符串是由索引指定的字符串中的字符序列。`s1`从索引 6 到 11 的子字符串是字符串`"or not"`，可以在 Processing 中如下找到：

```
s1.substring (6,12)
```

这个字符串的长度是六个字符，`length()`函数返回这个长度：

```
s1.substring(6,12).length()
```

可以使用`charAt()`函数在特定位置找到字符。例如，`s1.charAt(3)`是“b”，`s1.charAt(18)`是“,”。

字符串不能使用标准的关系运算符进行比较（因为它们实际上是类实例，稍后会讨论）。相反，有用于比较的函数。比较`s1`和`s2`可以通过以下方式实现：

```
if (s1.equals(s2)) ...;
```

这个草图展示了一些字符串操作及其结果，这些操作是使用第 11 个草图中讨论的`text()`函数绘制的。草图包括`length()` 3、`charAt()` 4 和`substring()` 5 的示例。
