## 8

库接口版本控制与运行时动态链接

*偶尔他会碰到真相，但总是匆忙站起来，像什么也没发生一样继续前进。*

—温斯顿·丘吉尔爵士，在《无法抑制的丘吉尔》中引用

![Image](img/common.jpg)

在上一章中，我解释了动态加载共享库的概念。我还展示了如何轻松地将 Libtool 共享库功能和灵活性添加到你的项目中，无论你的项目是提供共享库、静态库、便利档案，还是这些的某种混合体。我们仍然有两个主要的 Libtool 话题需要讨论。第一个是库版本控制，第二个涉及使用 Libtool 的*ltdl*库，在你的项目中便捷地构建和使用动态加载模块。

当我谈到一个库的版本时，我特指库公共接口的版本，但我需要在此上下文中清楚地定义*接口*这一术语。*共享库接口*指的是共享库与外界所有的连接方面。除了库导出的函数和数据签名之外，这些连接还包括文件和文件格式、网络连接和数据格式、IPC 通道和协议等等。在考虑是否为共享库分配一个新版本时，你应当仔细检查库与外部世界的所有交互，以确定变动是否会导致库在用户角度上的表现发生变化。

Libtool 试图隐藏共享库平台之间的差异，其设计如此巧妙，以至于如果你一直使用 Libtool 来构建共享库，你可能甚至没有意识到不同平台之间共享库版本控制的方式存在显著差异。

### 系统特定的版本控制

让我们来看看在几个不同的系统上共享库版本控制是如何工作的，从而为 Libtool 抽象提供一些背景。

共享库版本控制可以是内部的也可以是外部的。*内部版本控制*意味着库的名称与其版本没有任何关联。因此，内部版本控制意味着某种形式的可执行文件头信息向链接器提供适当的函数调用，以满足所请求的*应用程序二进制接口（ABI）*。这也意味着所有版本的库的函数调用都保存在同一个共享库文件中。Libtool 支持根据平台要求使用内部版本控制，但它更倾向于使用外部版本控制。在*外部版本控制*中，版本信息直接在文件名中指定。

除了库级别的版本控制，在这种控制中，特定的版本号或字符串表示整个库接口，许多 Unix 系统还支持一种导出级别或符号级别的版本控制，其中共享库导出多个具有命名或编号版本的相同函数或全局数据项。虽然 Libtool 不会妨碍在每个系统上使用这种导出级别的版本控制方案，但它也没有为其提供任何特定的可移植性支持。因此，我不会详细讨论这个话题。

#### *Linux 和 Solaris 库版本控制*

现代 Linux 借鉴了 Oracle Solaris 操作系统 9 版的库版本控制系统。^(1)这些系统使用一种外部库版本控制形式，其中版本信息编码在共享库的文件名中，遵循特定的模式或模板。我们来看一下典型 Linux 系统中*/usr/lib/x86_64-linux-gnu*目录的部分目录列表——特别是与一个相当典型的库*libcurl*相关的文件：

```
   $ ls -lr /usr/lib/x86_64-linux-gnu/libcurl*
➊ -rw-r--r-- ... 947448 ... libcurl.a
   lrwxrwxrwx ...     19 ... libcurl-gnutls.so.3 -> libcurl-gnutls.so.4
   lrwxrwxrwx ...     23 ... libcurl-gnutls.so.4 -> libcurl-gnutls.so.4.4.0
   -rw-r--r-- ... 444800 ... libcurl-gnutls.so.4.4.0
   -rw-r--r-- ...    953 ... libcurl.la
➋ lrwxrwxrwx ...     16 ... libcurl.so -> libcurl.so.4.4.0
   lrwxrwxrwx ...     12 ... libcurl.so.3 -> libcurl.so.4
➌ lrwxrwxrwx ...     16 ... libcurl.so.4 -> libcurl.so.4.4.0
➍ -rw-r--r-- ... 452992 ... libcurl.so.4.4.0
   $
```

**注意**

*此控制台目录列表中的内容特定于我的系统，该系统基于 Debian 发行版。如果您的发行版不是基于 Debian 的，您可能会看到稍微不同的目录列表——甚至可能会有显著不同。在这种情况下，请不要试图在您的系统上跟随操作。相反，阅读以下描述时，只需按照我的示例进行。这里讨论的重点是概念，而不是文件名*。

Linux 系统上的库名称遵循标准格式：*lib*name*.so.*X*.*Y。格式中的 X*.*Y 部分表示版本信息，其中 X 是主版本号（始终是一个数字），Y 是次版本号（可能包含多个由点分隔的部分）。一般规则是，X 的变化表示对库的 ABI 的非向后兼容的更改，而 Y 的变化表示向后兼容的修改，包括库接口的孤立添加和不干扰的错误修复。

通常，您会看到一个看起来像是第三个编号组件的部分。例如，4 号位置的条目表示实际的*curl*共享库，*libcurl.so.4.4.0*。在这个例子中，最后两个数字（*4.0*）实际上只是代表一个两部分的次版本号。次版本号中的这种附加数字信息有时被称为库的*补丁级别*。^(2)

➌ 处的 *libcurl.so.4* 条目被称为库的 *共享对象名称（soname）*^(3)，实际上是一个软链接，指向二进制文件。soname 是消费程序和库在内部引用的格式——也就是说，链接器在构建时将此名称嵌入到消费程序或库中。软链接由 `ldconfig` 工具创建，`ldconfig` 除了其他功能外，还确保适当的 soname 可以定位到已安装库的最新次版本。`ldconfig` 通常由安装后脚本以及 RPM 和 Debian 包的触发器执行。因此，尽管 soname 不是通过 `make install` 目标创建或安装的，但它通常是由发行版安装包创建的，因此也由 Linux 打包工具创建。

注意，这种版本管理方案如何允许不同主版本的多个 soname 以及多个具有不同主版本和次版本的二进制文件在同一目录中共存。

库的开发包（以 *-dev* 或 *-devel* 结尾）通常还会安装一个所谓的 *链接器名称* 条目（在 ➋ 处）。链接器名称是一个仅以 *.so* 结尾的软链接，通常指向 soname，尽管在某些情况下（如本例）它可能直接指向二进制共享库。链接器名称是链接器命令行中引用库的名称。开发库使得你可以运行那些链接到库的最新版本的程序，但在较旧版本的库上进行开发，反之亦然。

➊ 处的条目指的是库的静态归档形式，在 Linux 和 Solaris 系统上具有 *.a* 扩展名。其余条目表示为特定于 *curl* 包生成的 *curl* 库集的其他形式。

*curl* 库已经成为现代 Linux 系统中不可或缺的一部分；它被许多其他安装在系统上的程序使用，其中一些程序尚未升级到最新的主版本。维护者声明，主版本 4 向后兼容主版本 3。因此，指向版本 3 的 soname 会在安装了版本 4 的系统上指向版本 4 的库文件。这并不一定是常见的做法，但在这种情况下它是有效的。

从此开始，外部和内部共享库版本管理技术的奇怪阵列使得问题变得复杂。这些不太直观的系统每一个都是为了克服多年来在 Solaris 系统中发现的一些基本问题而设计的。^(4)让我们看一下其中的一些。

#### *IBM AIX 库版本管理*

传统上，IBM 的 AIX 使用一种内部版本控制形式，将所有库代码存储在一个单独的归档文件中，该文件遵循 *lib*name.*a* 的模式。这个文件实际上可能同时包含静态和共享形式的代码，以及 32 位和 64 位代码。内部来说，所有共享库代码都存储在归档文件中的一个单一逻辑共享对象文件中，而静态库对象则存储为归档文件中的单独逻辑对象文件。

我说“传统上”是因为更近期的 AIX 版本（包括所有 64 位版本）现在支持直接从物理 *.so* 文件加载共享库代码的概念。

Libtool 在 AIX 上使用这两种方案生成共享库代码。如果命令行上指定了 AIX `-brtl` 本地链接器标志，Libtool 会生成带有 *.so* 扩展名的共享库。否则，它会生成遵循旧版单文件方案的合并库。^(5)

在 AIX 上使用 *.so* 文件方案时，Libtool 会生成采用 Linux/Solaris 命名模式的库，以便与这些更流行的平台保持一定程度的兼容性。然而，无论使用哪种共享库扩展名，版本信息仍然不会存储在文件名中；它存储在库和使用的可执行文件内部。就我所知，Libtool 会确保创建正确的内部结构，以反映共享库头文件中的正确版本信息。它通过将适当的标志传递给本地链接器，嵌入由 Libtool 版本字符串派生的版本信息来实现这一点。

大多数 Unix 系统上的可执行文件也支持嵌入式运行时库搜索路径的概念（在 AIX 上称为 *`LIBPATH`*），通常指定一组用冒号分隔的文件系统路径，用于搜索共享库依赖项。你可以使用 Libtool 的 `-R` 命令行选项来为程序和库指定一个库搜索路径。Libtool 会将此选项转换为适当的 GNU 或本地链接器选项，适用于任何给定的系统。

我说可执行文件*通常*支持这个选项，因为在 AIX 上有一些细微差别。如果 `LIBPATH` 中指定的所有目录都是真实目录，一切按预期工作——也就是说，`LIBPATH` 仅作为库搜索路径。然而，如果 `LIBPATH` 的第一个部分不是一个真实的文件系统条目，它就充当所谓的*加载器域*，本质上是某个特定共享库的命名空间。因此，同名的多个共享库可以存储在同一个 AIX 档案（*.a*）文件中，每个都被分配（通过链接器选项）到不同的加载器域。与 `LIBPATH` 中指定的加载器域匹配的库将从档案中加载。如果你通过 `LIBPATH` 分配了一个加载器域，后来恰好成为一个真实的文件系统条目，这可能会产生不良副作用。另一方面，你也可以在 `LIBPATH` 中指定一个搜索目录，恰好与共享库中的某个加载器域匹配。如果该目录后来被删除，你将无意中开始使用该加载器域。正如你所想，奇怪的行为随之而来。AIX 开发人员通过确保加载器域字符串与文件系统路径完全不同，解决了大部分这些问题。

在 AIX 系统上，所有代码，无论是静态的还是共享的，都是以位置独立代码（PIC）形式编译的，因为 AIX 只曾移植到 PowerPC 和 RS/6000 处理器上。这些处理器的架构仅支持 PIC 代码，因此 AIX 编译器无法生成非 PIC 代码。

#### *微软 DLL 版本管理*

考虑微软 Windows 的*动态链接库（DLL）*，它们在所有意义上都是共享库，并提供了适当的应用程序编程接口（API）。但不幸的是，微软过去并未提供集成的 DLL 接口版本管理方案。因此，Windows 开发人员常常将 DLL 版本管理问题（我相信他们开玩笑的）称为*DLL 地狱*。

作为解决此问题的临时补救方法，Windows 系统上的 DLL 可以安装到与使用它们的程序相同的目录中。Windows 操作系统加载器总是会尝试先使用本地副本，然后才会在系统路径中查找副本。这在一定程度上缓解了问题，因为它允许你与需要该库的包一起安装特定版本的库。尽管这是一个合理的解决方案，但并不是一个理想的解决方案，因为共享库的主要优点之一是它们可以共享——无论是在磁盘上还是在内存中。如果每个应用程序都有自己的一份不同版本的库副本，那么共享库的这一优点就会丧失——无论是在磁盘上还是在内存中。

自从多年前引入这一部分解决方案以来，微软对 DLL 共享效率问题并未给予太多关注。原因包括对磁盘空间和 RAM 消耗的轻视态度，以及实现 Windows DLL 时的技术问题。微软的系统架构师没有生成位置无关代码，而是选择将 DLL 与特定的基地址链接，然后在库镜像头部的基表中列出所有的绝对地址引用。当 DLL 无法在期望的基地址加载时（因为与另一个 DLL 发生冲突），加载器会*重定位*该 DLL，通过选择一个新的基地址并更改代码段中基表所引用的所有绝对地址。当 DLL 以这种方式被重定位时，它只能与那些恰好将 DLL 重定位到相同地址的进程共享。尤其是对于包含许多 DLL 组件的应用程序，偶然遇到这种情况的几率是相当小的。

最近，微软发明了*并行缓存*（有时称为*SxS*）的概念，它允许开发人员将一个唯一的标识值（实际上是一个 GUID）与安装在系统位置的特定版本的 DLL 关联。该位置目录的名称是从 DLL 名称和版本标识符派生出来的。基于 SxS 版本库构建的应用程序，其可执行文件头中会存储元数据，指示它们所需的特定版本的 DLL。如果在 SxS 缓存中找到正确的版本（通过更新的操作系统加载器），那么它会被加载。根据 EXE 头部元数据中的策略，加载器可以回退到旧的方案，即先查找本地副本，然后查找全局副本的 DLL。这比早期的解决方案有了极大的改进，并提供了一个非常灵活的版本控制系统。

并行缓存实际上将 Windows 的 DLL 架构向 Unix 管理共享库的方式更靠近一步。可以把 SxS 看作是库的系统安装位置——就像 Unix 系统中的*/usr/lib*目录一样。与 Unix 类似，相同的 DLL 的多个版本可以并行安装在并行缓存中。

尽管有相似之处，但由于 DLL 使用的是重定位技术，而不是 PIC 代码，针对管理大量共享库的应用程序，并行缓存仍然是一个相当温和的效率提升。SxS 实际上是为许多应用程序可能会使用的系统库设计的。这些库通常位于不同的地址上，因此发生冲突（进而需要重定位）的可能性降低，但并没有完全消除。

共享库的整个基础方法的主要缺点是，程序的地址空间可能会变得相当分散，因为系统加载器会在 32 位地址空间中随机选择基址并予以处理。幸运的是，64 位寻址在这一领域帮助巨大，因此在 64 位 Windows 系统上，你可能会发现并排缓存对于提高内存使用效率更为有效，而如今 64 位系统已是常态。

#### *HP-UX/AT&T SVR4 库版本管理*

惠普的 Unix 版本（自 HP-UX 10.0 版本以来）增加了一种库级版本管理方式，这与 AT&T UNIX System V Release 4 中使用的版本管理非常相似。对于我们的目的，你可以认为这两种系统的工作方式几乎相同。

本地链接器会根据基础名称和*.sl*扩展名查找指定的库。然而，使用的程序和库包含对该库*内部名称*的引用。内部名称是通过链接器命令行选项分配给库的，并且应该包含该库的接口版本号。

实际的库仅以主要接口版本号作为扩展名命名，并且创建一个软链接，指向具有*.sl*扩展名的库。因此，在这些系统上，共享库将遵循以下模式：

```
libname.X
libname.sl -> libname.X
```

我们所能使用的唯一版本信息是一个主要版本号，用于表示从一个版本到下一个版本之间的不兼容更改。由于没有像 Linux 或 Solaris 那样的次要版本号，我们不能保留特定接口版本的多个修订版。唯一的选择是，如果进行了错误修复或向后兼容的增强（即对接口的非侵入性添加），则用更新后的版本零替换版本零。

然而，我们仍然可以共同安装多个主要版本的库，Libtool 充分利用了这些系统上可用的功能。

### Libtool 库版本管理方案

Libtool 的作者们努力提供一个可以映射到任何 Libtool 平台所使用的任何版本管理方案的方案。Libtool 版本管理方案被设计得足够灵活，以便与现有 Libtool 平台的合理未来更改兼容，甚至可以兼容新的 Libtool 平台。

然而，这并不是万灵药。当 Libtool 扩展到一种新的共享库平台时，已经发生了（并且仍然会发生）一些需要认真评估的情况。没有人能成为所有系统的专家，因此 Libtool 开发者非常依赖外部贡献，以创建从 Libtool 版本管理方案到新平台或潜在 Libtool 平台方案的正确映射。

#### *库版本管理即接口版本管理*

你应该有意识地避免将库版本号（无论是 Libtool 的版本号，还是特定平台的版本号）看作是产品的*主版本*、*次版本*和*修订版*（也叫做*补丁*或*微版本*）。事实上，这些版本值对操作系统加载器有非常具体的含义，它们必须在每个新版本的库中正确更新，以避免混淆加载器。一个混淆的加载器可能会根据分配给库的错误版本信息加载错误的库版本。

几年前，我和公司内部的版本控制委员会一起，为整个公司制定软件版本管理政策。委员会希望工程师们确保我们共享库名称中的版本号与公司软件版本管理策略保持一致。花了我大半天时间才说服他们，共享库版本与产品版本没有任何关系，也不应该由他们或任何其他人建立或强制这种关系。

这是为什么：共享库上的版本号实际上并不是库版本，而是接口版本。我这里提到的*接口*是指库向用户展示的应用程序二进制接口，另一个程序员希望调用由该接口提供的函数。一个可执行程序有一个单一、明确、标准的入口点（通常在 C 语言中称为 `main`）。但共享库有多个入口点，这些入口点通常没有被广泛理解的标准化方式。这使得判断特定版本的库是否与同一库的另一个版本接口兼容变得更加困难。

在 Libtool 的版本控制方案中，共享库被认为支持一系列接口版本，每个版本由一个唯一的整数值标识。如果接口的任何公开可见部分在公开发布之间发生变化，就不能再认为它是同一个接口；它因此成为一个新的接口，由一个新的整数标识符标识。每次公开发布库时，如果接口发生了变化，就会获得下一个连续的接口版本号。那些在发布之间以向后兼容的方式发生变化的库被认为同时支持旧接口和新接口；因此，一个特定的库版本可能支持版本 2 到 5 之间的接口。

Libtool 库版本信息通过 `libtool` 命令行中的 `-version-info` 选项进行指定，如清单 8-1 所示。

```
libname_la_LDFLAGS = -version-info 0:0:0
```

*清单 8-1：在* Makefile.am *文件中设置共享库版本信息*

Libtool 开发者明智地选择了冒号作为分隔符，而不是使用句点，以避免开发者试图将 Libtool 的版本字符串值与各个平台上共享库文件末尾附加的版本号直接关联。版本字符串中的三个值分别称为接口的*当前*、*修订版*和*年龄*值。

*当前*值表示当前接口的版本号。当接口自上次库的公共发布以来以某种公开可见的方式发生变化时，就必须声明新的接口版本，且此值会发生变化。根据约定，库中的第一个接口版本号为零。假设在一个共享库中，开发者自上次公共发布以来添加了一个新函数到该库暴露的函数集中。由于多了一个新函数，这个版本的接口不再和上一个版本相同。因此，*当前*值必须从零增加到一。

*年龄*值表示共享库支持的回溯版本的数量。从数学角度来看，可以认为库支持的接口范围是 *current − age* 到 *current*。在我刚才给出的例子中，由于向库中添加了一个新函数，所以这个版本的库接口与之前的版本不同。然而，之前的版本仍然完全支持，因为旧接口是当前接口的一个适当子集。因此，*年龄*值应该从零增加到一。

*修订版*值仅表示当前接口的一个序列修订版本。也就是说，如果在两个发布版本之间，库的接口没有任何公开可见的更改——可能只是优化了一个内部函数——那么库的名称应该以某种方式发生变化，至少是为了区分这两个版本。但是，*当前*值和*年龄*值将保持不变，因为从用户的角度来看，接口没有发生变化。因此，*修订版*值会增加，以反映这是相同接口的新版本。在前面的例子中，*修订版*值将保持为零，因为其他两个值之一或两者都已经增加。

为了简化共享库的发布过程，应遵循 Libtool 版本算法，逐步处理每个即将公开发布的库的新版本：^(6)

1.  对于每个新的 Libtool 库，版本信息从 0:0:0 开始。（如果你从传递给 `libtool` 脚本的链接器标志列表中省略 `-version-info` 选项，这一过程会自动完成。）对于现有库，从之前的公共发布的 Libtool 版本信息开始。

1.  如果自上次更新以来，库的源代码有任何更改，那么*修订版*（*c*:*r*:*a*变为*c*:*r*+1:*a*）。

1.  如果自上次更新以来，任何导出的函数或数据有添加、删除或更改，增加 *current* 并将 *revision* 设置为 0。

1.  如果自上次公开发布以来，任何导出的函数或数据有添加，增加 *age*。

1.  如果自上次公开发布以来，任何导出的函数或数据被删除，设置 *age* 为 0。

请记住，这是一个算法；因此，它设计为逐步执行，而不是直接跳到看似适用于你情况的步骤。例如，如果你自上次发布以来删除了一个 API 函数，你不会简单地跳到最后一步并将 *age* 设置为零。而是，你需要遵循所有步骤直到最后一步，然后 *再* 设置 *age* 为零。

**注意**

*记住，仅在软件的公开发布之前立即更新版本信息。更频繁的更新是不必要的，并且只会确保 *current* 接口编号变得更大更快*。

我们来看一个例子。假设这是库的第二个发布版本，而第一个发布版本使用了 `-version-info` 字符串 `0:0:0`。在这个开发周期中，向库接口添加了一个新功能，并删除了一个现有功能。这个新发布版本的版本信息字符串将如下所示：

1.  从上一个版本信息开始：`0:0:0`。

1.  `0:0:0` 变为 `0:1:0`（库的源代码发生了变化）。

1.  `0:1:0` 变为 `1:0:0`（库的接口已被修改）。

1.  `1:0:0` 变为 `1:0:1`（添加了一个新功能）。

1.  `1:0:1` 变为 `1:0:0`（删除了一个旧功能）。

到现在为止应该很清楚，Libtool 的 *current*、*revision* 和 *age* 值与 Linux 的主要版本、次要版本和可选补丁级别之间没有 *直接* 的关联。相反，使用映射规则将一个方案中的值转换为另一个方案中的值。

返回到前面的例子，其中库的第二个发布版本添加了一个功能并删除了一个功能，我们最终得到了一个新的 Libtool 版本字符串 `1:0:0`。版本字符串 `1:0:0` 表示该库与之前的版本不兼容（*age* 为零），因此 Linux 共享库文件将命名为 *lib*name.*so.1.0.0*。这看起来像是 Libtool 版本字符串——但不要被迷惑。这种常见的巧合可能是 Libtool 版本化抽象中最让人困惑的方面之一。

我们稍微修改一下例子，假设我们添加了一个新的库接口功能，但没有删除任何东西。重新从原始版本信息 `0:0:0` 开始，并遵循算法：

1.  从上一个版本信息开始：`0:0:0`。

1.  `0:0:0` 变为 `0:1:0`（库的源代码发生了变化）。

1.  `0:1:0` 变为 `1:0:0`（库的接口已被修改）。

1.  `1:0:0` 变为 `1:0:1`（添加了一个新功能）。

1.  不适用（没有删除任何东西）。

这次，我们得到了一个 Libtool 版本字符串 `1:0:1`，但生成的 Linux 或 Solaris 共享库文件名是 *lib*name.*so.0.1.0*。考虑一下，在主要版本、次要版本和补丁级别值的情况下，Libtool 版本字符串中有一个非零的 *age* 值意味着什么。一个 *age* 值为 1（如本例所示）意味着我们实际上仍然支持 Linux 主版本为零，因为这个新版本的库与之前的版本完全向后兼容。共享库文件名中的次要版本从零增加到一，以表明这实际上是 soname 的更新版本，*lib*name.*so.0*。补丁级别值保持为零，因为这个值表示对某个 soname 的特定次版本的错误修复。

一旦你完全理解了 Libtool 版本控制，你会发现即使这个算法也无法涵盖所有可能的接口修改场景。例如，假设你维护的共享库版本信息为 `0:0:0`。现在假设你为下一个公开版本添加了一个新函数。第二个版本正确地定义了版本信息为 `1:0:1`，因为该库支持接口版本 0 和 1。然而，在库的第三个版本发布之前，你意识到实际上并不需要那个新函数，所以你将其移除。这是本次发布中唯一公开可见的库接口更改。按照算法，版本信息字符串应该设置为 `2:0:0`。但实际上，你只是移除了第二个接口，现在又重新呈现了原始接口。从技术上讲，这个库应该配置为版本信息字符串 `0:1:0`，因为它展示了共享库接口版本 0 的第二次发布。这个故事的寓意是，你需要充分理解 Libtool 版本控制的工作方式，然后根据理解决定适当的下一个版本值应该是什么。

我还想指出，*GNU Libtool 手册*很少描述接口在不同版本的库之间可能存在的各种差异。接口版本不仅表示功能语义，还表示 API 语法。如果你更改了一个函数的语义方式，但保持函数签名不变，那么你仍然改变了这个函数。如果你更改了由共享库发送的数据的网络线格式，那么从消费代码的角度来看，这实际上就不再是相同的共享库了。当操作系统加载器试图确定加载哪个库时，唯一关心的问题是，*这个库能像那个库一样正常工作吗？* 在这些情况下，答案肯定是否定的，因为即使 API 接口是相同的，两个库在公开可见的方式上做事的方式却不相同。

#### *当库版本控制不足以满足需求时*

对库接口的这些更改非常复杂，以至于项目维护者通常会直接重命名库，从而完全避免了库版本问题。一种很好的重命名库的方法是使用 Libtool 的 `-release` 标志。此标志将库版本信息作为一个独立的类别添加到库的基本名称中，从操作系统加载器的角度来看，这实际上使它成为一个全新的库。`-release` 标志的使用方式如 列表 8-2 中所示。

```
libname_la_LDFLAGS = -release 2.9.0 -version-info 0:0:0
```

*列表 8-2：在* Makefile.am *文件中设置共享库发布信息*

在这个例子中，我在同一组 Libtool 标志中同时使用了 `-release` 和 `-version-info`，只是为了向你展示它们可以一起使用。你会注意到，发布字符串被指定为一系列用点分隔的值。在这种情况下，你的 Linux 或 Solaris 共享库的最终名称将是 *lib*name-*2.9.0.so.0.0.0*。

开发人员选择使用发布字符串的另一个原因是为了在不同平台之间提供某种程度的库版本关联。如前所示，特定的 Libtool 版本信息字符串可能会导致不同平台上库名称的不同，因为 Libtool 将版本信息以不同的方式映射到库名称中，具体取决于平台。发布信息在各平台间保持稳定，但你应该仔细考虑如何在共享库中使用发布字符串和版本信息，因为你选择的使用方式将影响库版本之间的二进制兼容性。如果两个版本的库有不同的发布字符串，操作系统加载器将不会认为它们兼容，无论这些字符串的值如何。

### 使用 libltdl

现在让我们继续讨论 Libtool 的 *ltdl* 库。同样，我们需要为 Jupiter 项目添加一些功能，以便说明这些概念。这里的目标是创建一个插件接口，`jupiter` 程序可以使用该接口根据最终用户的策略选择修改输出。

#### *必要的基础设施*

当前，`jupiter` 输出 *Hello from jupiter!*（实际上，打印的名称更可能是一个长而难看的路径，包含一些 Libtool 目录垃圾和 *jupiter* 的某些衍生名称，但现在假装它打印的是 *jupiter*）。我们将为 *common* 静态库方法 `print_routine` 添加一个名为 `salutation` 的额外参数。这个参数也将是 `char` 类型的指针，包含 `jupiter` 问候语中的前导词或短语——即问候语。

列表 8-3 和 8-4 指出了我们需要对 *common* 子目录中的文件进行的更改。

Git 标签 8.0

```
--snip--
static void * print_it(void * data)
{
    const char ** strings = data;
    printf("%s from %s!\n", strings[0], strings[1]);
    return 0;
}

int print_routine(const char * salutation, const char * name)
{
    const char * strings[] = {salutation, name};
#if ASYNC_EXEC
    pthread_t tid;
    pthread_create(&tid, 0, print_it, strings);
    pthread_join(tid, 0);
#else
    print_it(strings);
#endif
    return 0;
}
```

*列表 8-3:* common/print.c: *向 `print_routine` 函数添加问候语*

```
int print_routine(const char * salutation, const char * name);
```

*列表 8-4:* common/jupcommon.h: *向 `print_routine` 原型添加问候语*

列表 8-5 和 8-6 显示了我们需要对 *libjup* 和 *include* 子目录中的文件进行的更改。

```
--snip--
int jupiter_print(const char * salutation, const char * name)
{
    print_routine(salutation, name);
}
```

*列表 8-5:* libjup/jup_print.c: *向 `jupiter_print` 函数添加问候语*

```
--snip--
int jupiter_print(const char * salutation, const char * name);
--snip--
```

*列表 8-6:* include/libjupiter.h: *向 `jupiter_print` 原型添加问候语*

最后，列表 8-7 显示了我们需要在 *src* 目录下的 *main.c* 中所做的更改。

```
--snip--
#define DEFAULT_SALUTATION "Hello"

int main(int argc, char * argv[])
{
    const char * salutation = DEFAULT_SALUTATION;
    return jupiter_print(salutation, argv[0]);
}
```

*列表 8-7:* src/main.c: *向 `jupiter_print` 传递问候语*

需要明确的是，我们所做的实际上只是将问候语参数化到打印程序中。这样，我们可以从 `main` 中指定我们想使用的问候语。我将默认问候语设置为 *Hello*，以便从用户的角度看，什么都没有改变。因此，这些更改的整体效果是无害的。还需要注意的是，这些都是源代码级的更改——我们没有对构建系统做任何更改。我想将这些更改独立出来，以免将这种必要的重构与我们为添加新的模块加载功能所做的构建系统改动混淆。

在做出这些更改后，是否应该更新这个共享库的版本号？这取决于你在做出更改之前是否已经发布过这个库（即发布了一个 tarball）。版本控制的目的是保持对公共接口的一定控制——但是如果只有你一个人看过它，那么更改版本号就没有意义了。

#### *添加插件接口*

我希望能够通过简单地改变运行时加载的插件模块来更改显示的问候语。我们需要对代码和构建系统做的所有更改，将仅限于 *configure.ac* 文件以及 *src* 目录及其子目录中的文件。

首先，我们需要定义实际的插件接口。我们将通过在 *src* 目录下创建一个新的私有头文件 *module.h* 来完成这项工作。这个文件如 列表 8-8 所示。

Git 标签 8.1

```
   #ifndef MODULE_H_INCLUDED
   #define MODULE_H_INCLUDED

➊ #define GET_SALUTATION_SYM "get_salutation"

➋ typedef const char * get_salutation_t(void);
➌ const char * get_salutation(void);

   #endif /* MODULE_H_INCLUDED */
```

*列表 8-8:* src/module.h: *该文件的初始内容*

这个头文件有许多有趣的方面。首先，让我们来看位于 ➊ 的预处理器定义 `GET_SALUTATION_SYM`。这个字符串表示你需要从插件模块导入的函数名。我喜欢在头文件中定义这些，这样所有需要对齐的信息都能集中在一个地方。在这种情况下，符号名称、函数类型定义和函数原型必须保持一致，你可以用这个单一的定义来处理所有三个部分。

另一个有趣的项是位于 ➋ 的类型定义^(7)。如果我们不提供一个类型定义，用户就必须自己发明一个，或者在 `dlsym` 函数的返回值上使用复杂的类型转换。因此，我们将在这里提供它，以确保一致性和便捷性。

最后，看看 ➌ 处的函数原型。这不仅是为了调用者，而是为了模块本身。提供此函数的模块应包含此头文件，以便编译器能捕捉到潜在的函数名拼写错误。

#### *传统方式操作*

对于第一次尝试，让我们使用 Solaris/Linux *libdl.so* 库提供的 *dl* 接口。在下一节中，我们将把这段代码转换为 Libtool *ltdl* 接口，以提高移植性。

为了正确完成此操作，我们需要在 *configure.ac* 中添加检查，寻找 *libdl* 库和 *dlfcn.h* 头文件。这些对 *configure.ac* 的更改在 清单 8-9 中突出显示。

```
   --snip--
   # Checks for header files.
➊ AC_CHECK_HEADERS([stdlib.h dlfcn.h])
   --snip--
   # Checks for libraries.

   # Checks for typedefs, structures, and compiler characteristics.

   # Checks for library functions.
➋ AC_SEARCH_LIBS([dlopen], [dl])
   --snip--
   cat << EOF
   -------------------------------------------------

   ${PACKAGE_NAME} Version ${PACKAGE_VERSION}

   Prefix: '${prefix}'.
   Compiler: '${CC} ${CFLAGS} ${CPPFLAGS}'
➌ Libraries: '${LIBS}'
   --snip--
```

*清单 8-9:* configure.ac: *添加对* dl *库和公共头文件的检查*

在 ➊ 处，我将 *dlfcn.h* 头文件添加到传递给 `AC_CHECK_HEADERS` 宏的文件列表中，然后在 ➋ 处，我检查了 *dl* 库中的 `dlopen` 函数。这里需要注意的是，`AC_SEARCH_LIBS` 宏会在库列表中查找一个函数，因此此调用属于“库函数检查”部分，而非“库检查”部分。为了帮助我们查看实际链接的库，我还在文件末尾的 `cat` 命令中添加了一行。 ➌ 处的 `Libraries:` 行显示了 `LIBS` 变量的内容，该变量由 `AC_SEARCH_LIBS` 宏修改。

**注意**

*`LT_INIT`* 宏也会检查 *dlfcn.h* 头文件的存在，但我在这里显式地进行检查，以便观察者能明确看到我希望使用这个头文件。这是一个很好的经验法则，只要它不会对性能造成太大影响。由于 Autoconf 会缓存检查的结果，因此这种情况不太可能发生。你可以通过查看 *`configure`* 输出中出现的 *`(cached) ...`* 来知道这正在发生。

添加模块需要做几个更改，所以我们将一起进行这些更改，首先执行以下命令：

```
$ mkdir -p src/modules/hithere
$
```

我创建了两个新的子目录。第一个是 *modules*，位于 *src* 目录下，第二个是 *hithere*，位于 *modules* 目录下。每个新增的模块都将在 *modules* 目录下有自己的子目录。*hithere* 模块将提供问候语 *Hi there*。

清单 8-10 说明了如何将 `SUBDIRS` 变量添加到 *src/Makefile.am* 文件中，以确保构建系统能够处理 *modules/hithere* 目录。

```
➊ SUBDIRS = modules/hithere

   bin_PROGRAMS = jupiter
➋ jupiter_SOURCES = main.c module.h
   --snip--
   greptest.sh:
➌ echo './jupiter | grep ".* from .*jupiter!"' > greptest.sh
   --snip--
```

*清单 8-10:* src/Makefile.am: *向此* Makefile.am *文件添加 `SUBDIRS` 变量*

我在 ➊ 使用 `SUBDIRS` 的方式引入了一个新概念。到目前为止，Jupiter 的 *Makefile.am* 文件只引用了当前目录的直接子目录，但正如你所见，这并非严格必要。事实上，对于 Jupiter，*modules* 目录只会包含额外的子目录，因此提供一个 *modules/Makefile.am* 文件只是为了引用其子目录没有太大意义。

在编辑文件时，您应该将新的*module.h*头文件添加到`SOURCES`变量中，如➋所示。如果不这样做，`jupiter`仍然会为您作为维护者正确编译和构建，但`distcheck`目标将失败，因为没有任何*Makefile.am*文件提到*module.h*。

我们还需要改变`greptest.sh`脚本的构建方式，以便它能够测试任何类型的问候语。只需在➌处简单修改正则表达式即可。

我在新的*hithere*子目录中创建了一个*Makefile.am*文件，里面包含了如何构建*hithere.c*源文件的指令，然后我将*hithere.c*源文件添加到该目录中。这些文件分别显示在列表 8-11 和 8-12 中。

```
   pkglib_LTLIBRARIES = hithere.la
   hithere_la_SOURCES = hithere.c
➊ hithere_la_LDFLAGS = -module -avoid-version
```

*列表 8-11:* src/modules/hithere/Makefile.am: *该文件的初始版本*

```
#include "../../module.h"

const char * get_salutation(void)
{
    return "Hi there";
}
```

*列表 8-12:* src/modules/hithere/hithere.c: *该文件的初始版本*

*hithere.c*源文件通过双引号相对路径引用半私有的*module.h*头文件。由于 Automake 会自动将`-I$(srcdir)`添加到使用的*include*路径列表中，C 预处理器将正确处理相对路径。然后，文件定义了`get_salutation`函数，其原型位于*module.h*头文件中。该实现简单地返回指向静态字符串的指针，只要库被加载，调用者就可以访问该字符串。然而，调用者必须注意插件模块返回的数据引用的作用域；否则，程序可能会在调用者完成使用之前卸载该模块。

*hithere/Makefile.am*的最后一行（在列表 8-11 中的➊处）需要一些解释。在这里，我们在`hithere_la_LDFLAGS`变量上使用了`-module`选项。这是 Libtool 的一个选项，告诉 Libtool 您希望将库命名为*hithere*，而不是*libhithere*。*GNU Libtool 手册*中指出，模块不需要以*lib*为前缀。而且，由于您的代码将手动加载这些模块，因此不必担心确定和正确使用特定平台的库名称前缀。

如果您不关心对动态加载的（`dlopen`加载的）模块使用版本控制，可以尝试使用 Libtool 的`-avoid-version`选项。此选项使 Libtool 生成一个共享库，库的名称是*lib*name.*so*，而不是*lib*name.*so.0.0.0*。它还会抑制生成*lib*name.*so.0*和*lib*name.*so*的软链接，这些链接指向二进制镜像。因为我同时使用了这两个选项，所以我的模块将简单地命名为*hithere.so*。

为了使这个模块能够构建，我们需要将新的*hithere*模块的 makefile 添加到*configure.ac*中的`AC_CONFIG_FILES`宏中，如列表 8-13 所示。

```
--snip--
AC_CONFIG_FILES([Makefile
                 common/Makefile
                 include/Makefile
                 libjup/Makefile
                 src/Makefile
                src/modules/hithere/Makefile])
--snip--
```

*列表 8-13:* configure.ac: *将* hithere *目录的 makefile 添加到`AC_CONFIG_FILES`中*

最后，为了使用该模块，我们需要修改*src/main.c*以便加载模块、导入符号并调用它。这些对*src/main.c*的更改在清单 8-14 中以粗体显示。

```
   #include "config.h"

   #include "libjupiter.h"
➊ #include "module.h"

➋ #if HAVE_DLFCN_H
   # include <dlfcn.h>
   #endif

   #define DEFAULT_SALUTATION "Hello"

   int main(int argc, char * argv[])
   {
       int rv;
       const char * salutation = DEFAULT_SALUTATION;
➌ #if HAVE_DLFCN_H
       void * module;
       get_salutation_t * get_salutation_fp = 0;
    ➍ module = dlopen("./module.so", RTLD_NOW);
       if (module != 0)
       {
           get_salutation_fp = (get_salutation_t *)dlsym(
                     module, GET_SALUTATION_SYM);
           if (get_salutation_fp != 0)
               salutation = get_salutation_fp();
       }
   #endif

       rv = jupiter_print(salutation, argv[0]);

➎ #if HAVE_DLFCN_H
       if (module != 0)
           dlclose(module);
   #endif

       return rv;
   }
```

*清单 8-14:* src/main.c：*从`main`函数使用新的插件模块*

我在➊处包含了新的私有*module.h*头文件，并且在➋处添加了一个预处理指令，以有条件地包含*dlfcn.h*。最后，我在原始调用`jupiter_print`的前后分别添加了两段代码（分别在➌和➎处）。这两段代码都是基于动态加载器的存在条件编译的，这使得代码能够在没有提供*libdl*库的系统上正确构建和运行。

我决定是否进行条件编译时使用的一般哲学是：如果`configure`因缺少某个库或头文件而失败，那么我不需要有条件地编译使用`configure`检查项的代码。如果我在`configure`中检查某个库或头文件，但允许它缺失而继续，那么我最好使用条件编译。

关于使用*dl*接口函数，还有一些小细节需要提及。首先，在➍处，`dlopen`接受两个参数：一个文件名或*路径*（绝对路径或相对路径）和一个*flags*标志，它是你选择的多个在*dlfcn.h*中定义的标志值的按位组合。可以查看`dlopen`的手册页，了解更多关于这些标志位的信息。如果使用路径，`dlopen`会完全遵循该路径，但如果使用文件名，则会在库搜索路径中查找模块。通过在文件名前加上*./*，我们告诉`dlopen`不要搜索库路径。

我们希望能够配置`jupiter`使用哪个模块，因此我们加载了一个通用名称，*module.so*。事实上，构建后的模块位于构建树中*src*目录下的多个子目录中，因此我们需要在当前目录创建一个名为*module.so*的软链接，指向我们希望加载的模块。这是一种相对简陋的 Jupiter 配置方式，但它有效。在实际应用中，你会通过某种配置文件中定义的策略来指定要加载的模块，但在这个示例中，为了简便起见，我忽略了这些细节。

**注意**

*我在清单 8-14 中忽略了一些错误处理。在生产代码中，如果模块未能加载或模块未导出符号，你可能希望记录或显示某些信息。*

以下命令序列展示了我们可加载模块的工作情况：

```
$ autoreconf -i
--snip--
$ ./configure && make
--snip--
$ cd src
$ ./jupiter
Hello from ...jupiter!
$
$ ln -s modules/hithere/.libs/hithere.so module.so
$ ./jupiter
Hi there from ...jupiter!
$
```

**注意**

*符号链接*`module.so`*指向一个隐藏的* .libs *目录中的文件。可执行文件和库由 Autotools 构建系统生成，并存放在关联源目录内的* .libs *目录中*。

### 转换为 Libtool 的 ltdl 库

Libtool 提供了一个名为*ltdl*的包装库，它抽象并隐藏了在多个不同平台上使用共享库时遇到的一些可移植性问题。大多数应用程序因为使用它时的复杂性而忽略了*ltdl*库，但实际上需要处理的问题并不多。我将在这里列出这些问题，并在后续详细讲解。

+   *ltdl*函数遵循基于*dl*库的命名约定。经验法则是，*ltdl*库中的*dl*函数以`lt_`为前缀。例如，`dlopen`被命名为`lt_dlopen`。

+   与*dl*库不同，*ltdl*库必须在应用程序中适当的位置进行初始化和终止。

+   应用程序应该使用`-dlopen` *`modulename`*选项在链接器命令行中进行构建（在`*_LDFLAGS`变量中）。这告诉 Libtool 在没有共享库的平台或静态链接时，将模块代码链接到应用程序中。

+   `LTDL_SET_PRELOADED_SYMBOLS()`宏应在程序源代码的适当位置使用，以确保在非共享库平台或构建仅静态配置时，模块代码能够被访问。

+   设计为使用*dlopen*加载的共享库模块应在链接器命令行中使用`-module`选项（可选地，还可以使用`-avoid-version`选项）（在`*_LDFLAGS`变量中）。

+   *ltdl*库提供了超出*dl*库的广泛功能；这可能会让人感觉有些吓人，但请知道，所有这些额外的功能都是可选的。

让我们来看看如何修改 Jupiter 项目的构建系统，以便使用*ltdl*库。首先，我们需要修改*configure.ac*文件，去查找*ltdl.h*头文件并搜索`lt_dlopen`函数。这意味着需要修改在`AC_CHECK_HEADERS`和`AC_SEARCH_LIBS`宏中对*dlfcn.h*和*dl*库的引用，如示例 8-15 所示。

Git 标签 8.2

```
--snip--
# Checks for header files.
AC_CHECK_HEADERS([stdlib.h ltdl.h])
--snip--
# Checks for libraries.

# Checks for typedefs, structures, and compiler characteristics.

# Checks for library functions.
AC_SEARCH_LIBS([lt_dlopen], [ltdl])
--snip--
```

*示例 8-15:* configure.ac：*在 configure.ac 中从`dl`切换到`ltdl`*

即使我们使用了 Libtool，我们仍然需要检查*ltdl.h*和*libltdl*，因为*ltdl*是一个独立的库，必须安装在最终用户的系统上。它应该像任何其他所需的第三方库一样对待。通过在用户的系统中搜索这些已安装的资源，并在找不到时失败配置，或者在源代码中正确使用预处理器定义，你可以提供与使用其他第三方资源时相同的配置体验。

我希望你能意识到，这是我们第一次看到用户需要在其系统上安装 Autotools 软件包的要求——这正是大多数人避免使用 *ltdl* 的原因。《*GNU Libtool 手册*》提供了详细的描述，说明如何将 *ltdl* 库与项目一起打包，以便在构建和安装你的软件包时，它会在用户系统上构建并安装。^(8)

有趣的是，将 *ltdl* 库的源代码随你的软件包一起发布是让你的程序与 *ltdl* 库进行*静态*链接的唯一方法。与 *ltdl* 静态链接的副作用是，不需要用户在他们的系统上安装 *ltdl* 库，因为该库会成为项目可执行文件的一部分。然而，有一些警告需要注意。如果你的项目还使用了一个动态链接到 *ltdl* 的第三方库，你将会遇到共享版和静态版 *ltdl* 库之间的符号冲突。^(9)

我们需要进行的下一个重大更改是在源代码中——在这种情况下，仅限于 *src/main.c*，并在 清单 8-16 中突出显示。

```
#include "config.h"

#include "libjupiter.h"
#include "module.h"

#if HAVE_LTDL_H
# include <ltdl.h>
#endif

#define DEFAULT_SALUTATION "Hello"

int main(int argc, char * argv[])
{
    int rv;
    const char * salutation = DEFAULT_SALUTATION;

#if HAVE_LTDL_H
    int ltdl;
  ➊ lt_dlhandle module;
     get_salutation_t * get_salutation_fp = 0;

  ➋ LTDL_SET_PRELOADED_SYMBOLS();

  ➌ ltdl = lt_dlinit();
     if (ltdl == 0)
     {
      ➍ module = lt_dlopen("modules/hithere/hithere.la");
         if (module != 0)
         {
             get_salutation_fp = (get_salutation_t *)lt_dlsym(
                       module, GET_SALUTATION_SYM);
             if (get_salutation_fp != 0)
                 salutation = get_salutation_fp();
         }
      }
#endif

    rv = jupiter_print(salutation, argv[0]);

#if HAVE_LTDL_H
    if (ltdl == 0)
    {
 if (module != 0)
            lt_dlclose(module);
        lt_dlexit();
    }
#endif

    return rv;
}
```

*清单 8-16:* src/main.c: *在源代码中从`dl`切换到`ltdl`*

这些更改在原始代码中是非常对称的。通常，之前提到 `DL` 或 `dl` 的地方现在变成了提到 `LTDL` 或 `lt_dl`。例如，`#if HAVE_DLFCN_H` 变成了 `#if HAVE_LTDL_H`，等等。

一个重要的变化是，*ltdl* 库必须在➌处通过调用 `lt_dlinit` 进行初始化，而 *dl* 库则不需要初始化。在一个较大的程序中，调用 `lt_dlinit` 和 `lt_dlexit` 的开销会在更大的代码基础中得到摊销。

另一个重要细节是在➋处添加了 `LTDL_SET_PRELOADED_SYMBOLS` 宏调用。该宏配置了 `lt_dlopen` 和 `lt_dlsym` 函数所需的全局变量，适用于不支持共享库的系统，或者在终端用户特别要求静态库的情况下。对于使用共享库的系统，这个调用是无害的。

最后一项细节是，`dlopen` 的返回类型是 `void *`，即通用指针，而 `lt_dlopen` 的返回类型是 `lt_dlhandle`（见 ➊ 和 ➍）。这种抽象的存在是为了让 *ltdl* 可以移植到使用与通用指针不兼容的返回类型的系统上。

当系统不支持共享库时，Libtool 实际上会将所有可能加载的模块直接链接到程序中。因此，`jupiter` 程序的链接器（`libtool`）命令行必须包含对这些模块的某种形式的引用。这是通过使用 `-dlopen` *`modulename`* 构造来完成的，如 清单 8-17 所示。

```
--snip--
jupiter_LDADD = ../libjup/libjupiter.la -dlopen modules/hithere/hithere.la
--snip--
```

*清单 8-17:* src/Makefile.am: *在 `LDADD` 行中添加 `-dlopen` 选项*

如果你忘记了将这个内容添加到*src/Makefile.am*中，你将得到一个关于未定义符号的链接器错误——类似于`lt__PROGRAM__LTX_preloaded _symbols`。如果 Libtool 没有检测到任何模块被链接到应用程序中，它不会将符号污染程序的全局符号空间，这些符号永远不会被引用；如果符号表为空，*ltdl*库所需的符号将会缺失。

看起来*ltdl*在指定`lt_dlopen`时可以引用模块的路径信息方面不如*dl*灵活。为了解决这个问题，我将正确的相对路径（*modules/hithere/hithere.la*）硬编码到*main.c*中。此外，这个示例对当前工作目录很敏感。如果你从另一个目录运行`jupiter`，它也会无法找到该模块。一个真正的程序无疑会使用更健壮的配置方法，比如包含目标模块名称绝对路径的配置文件。^(10)

#### *预加载多个模块*

如果 Libtool 在没有共享库支持的系统上将多个模块链接到一个程序中，并且这些模块各自提供自己的`get_salutation`版本，那么在程序的全局符号空间中就会出现公共符号冲突。这是因为所有这些模块的符号都成为程序全局符号空间的一部分，而链接器通常不允许将两个同名的符号添加到可执行符号表中。应该尊重哪个模块的`get_salutation`函数呢？不幸的是，解决这个冲突没有一个好的启发式方法。*GNU Libtool 手册*通过定义一种约定来解决这种情况，从而保持符号命名的唯一性：

+   所有导出的接口符号应该以*`modulename`*`_LTX _`（例如，`hithere_LTX_get_salutation`）作为前缀。

+   所有剩余的非静态符号应当具有合理的唯一性。Libtool 建议的方法是以*`_modulename_`*（例如`_jupiter_`*`somefunction`*）作为前缀。

+   即使模块在不同的目录中构建，它们的命名也应当不同。

尽管手册中没有明确说明，`lt_dlsym`函数首先会以*`modulename`*`_LTX_`*`symbolname`*的形式查找指定的符号，如果找不到带前缀的符号，它接着会查找完全相同的*`symbolname`*。可以看出，这一约定是必要的，但仅仅在 Libtool 可能会将这些可加载模块静态链接到不支持共享库的系统上的应用程序中时，才需要此约定。在不支持共享库的系统上，Libtool 所提供的共享库的幻象代价相当高，但它是为了在所有平台上获得相同的可加载模块功能所必须支付的代价。

要修复*hithere*模块的源代码，使其符合这一约定，我们需要对*hithere.c*进行一次更改，如列表 8-18 所示。

```
➊ #define get_salutation hithere_LTX_get_salutation
➋ #include "../../module.h"

   const char * get_salutation(void)
   {
      return "Hi there";
   }
```

*示例 8-18:* src/modules/hithere/hithere.c: *在使用 `ltdl` 时确保公共符号唯一*

通过在➊位置定义 `get_salutation` 的替代版本，并在➋位置包含 *module.h* 头文件，我们还能够修改头文件中的原型，使其与修改后的函数名称版本匹配。由于 C 预处理器的工作方式，这种替换仅影响 *module.h* 中的函数原型，而不会影响引号中的符号字符串或类型定义。此时，你可能想回去查看 *module.h* 的写法，以证明这一点确实有效。

#### *检查所有内容*

你可以通过在 `configure` 命令行上使用 `--disable-shared` 选项来测试你的程序和模块，测试静态和动态共享库系统，如下所示：

```
   $ make clean
   --snip--
   $ autoreconf
   $ ./configure --disable-shared && make
   --snip--
   $ cd src
   $ ls -1p modules/hithere/.libs
➊ hithere.a
   hithere.la
   hithere.lai
   $
   $ ./jupiter
➋ Hi there, from ./jupiter!
   $
   $ cd ..
   $ make clean
   --snip--
   $ ./configure && make
   $ cd src
   $ ls -1p modules/hithere/.libs
   hithere.a
   hithere.la
   hithere.lai
   hithere.o
   hithere.so
   $
   $ ./jupiter
➌ Hi there, from ...jupiter!
   $
```

如你所见，➋ 和 ➌ 位置的输出都包含了 *hithere* 模块的问候语，但在➊位置的文件列表显示，在 `--disable-shared` 版本中，根本不存在共享库。看起来 *ltdl* 正在发挥它的作用。

**注意**

*你可能已经注意到，示例中两次执行 *`jupiter`* 的输出有所不同。在第一次情况下，输出显示程序名称为 *`./jupiter`*，而在第二次情况下，显示的是 *`...jupiter`*。这是我尝试去除输出中由 Libtool 重定向共享库版本所造成的冗余信息——指向实际程序的 *`lt-jupiter`*——位于 jupiter /src/.libs 目录中。Libtool 使用一个包装器来链接到构建共享库的程序，以简化未安装程序找到其依赖的共享库。*

Jupiter 代码库变得相当脆弱，因为我忽视了运行时如何找到共享库的问题。正如我之前提到的，你最终必须在实际程序中解决这个问题。但鉴于我已经完成了向你展示如何正确使用 Libtool *ltdl* 库的任务，我会把这个问题留给你作为练习。

### 摘要

使用共享库的决定带来了许多问题，如果你追求最大兼容性，你必须处理每一个问题。*ltdl* 库并不是解决所有问题的万能钥匙。它解决了一些问题，但也带来了其他问题。可以说，使用 *ltdl* 有其权衡，如果你不介意额外的维护工作，它是为你的可加载模块项目增加最大兼容性的一种好方法。

我希望通过花时间完成本书中的练习，你能够理解 Autotools 的基本概念，知道它们如何工作以及它们为你做了什么。此时，你应该非常熟悉如何将 *autotool* 应用到你自己的项目中——至少是在基础层面上。

在接下来的章节中，我将讨论一些额外的工具和实用程序，这些工具也被认为是 GNU 工具箱的一部分（还有一两个不是）。我还将向你展示如何将一个真实世界的项目从手动编码的构建系统转换为更加简洁、可能更加正确的 Autotools 构建系统。
