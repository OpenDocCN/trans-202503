## 前言

![Image](img/common.jpg)

很少有开源软件开发者会否认，GNU Autoconf、Automake 和 Libtool（即*Autotools*）已经彻底改变了开源软件的世界。然而，尽管有成千上万的 Autotools 支持者，也有许多软件开发者*讨厌*Autotools，甚至怀有强烈的反感。我认为这种对 Autotools 的恐惧源于，当你在没有理解它们管理的底层基础设施的情况下使用它们时，你会发现自己正在与系统对抗。

本书通过首先提供一个框架，帮助读者理解 Autotools 的底层基础设施，然后在此基础上采用基于教程的方式，按逻辑顺序讲解 Autotools 概念，从而解决了这一问题。

### 谁应该阅读本书

本书主要面向那些希望成为 Autotools 专家的开源软件包维护者。不过，本书也为希望了解下载、解压和构建由 Autotools 管理的构建过程的软件包的最终用户提供了指导。现有的相关资料主要限于 GNU Autotools 手册和一些基于互联网的教程。多年来，绝大多数实际问题都通过 Autotools 邮件列表得到了回答，但邮件列表的教学效率较低，因为同样的问题会一遍又一遍地被回答。本书提供了一种类似食谱的方式，涵盖了在真实项目中遇到的实际问题。

### 本书的组织结构

本书从最终用户的角度介绍了 Autotools，接着从高层次的开发构建概念讲解到中层的用例和示例，最后以更高级的细节和示例做总结。就像学习算术一样，我们将从一些基础数学——代数和三角学开始，然后逐步深入到解析几何和微积分。

第一章提供了关于 Autotools 的最终用户视角。它涵盖了 Linux 高级用户所需了解的主题，虽然他们不一定是软件开发者，但为了充分利用 Autotools 管理的源包（所谓的“tarballs”）的功能，了解这些内容是必要的。这些源包可能包含用户想要尝试的软件的最新 beta 版本，通常从项目网站下载。Linux 用户常常发现，解决软件问题的办法是更新到包含修复的版本，但结果却发现所需的版本太新，以至于他们选择的 Linux 发行版的任何软件包仓库中都没有该版本的 RPM 或 Debian 包。第一章为需要了解如何处理包含`configure`脚本和所有*.c*源文件的*tar.gz*文件的新手提供了帮助。

第二章开始讨论对软件开发者感兴趣的概念。它概述了被认为是 GNU Autotools 一部分的各个软件包。本章描述了这些软件包之间的交互关系，以及每个软件包所使用和生成的文件。在每个案例中，图示展示了从手工编写的输入到最终输出文件的数据流动。

第三章介绍了开源软件项目的结构和组织。本章还详细讨论了*GNU 编码标准 (GCS)* 和 *文件系统层次标准 (FHS)*，这两个标准在 GNU Autotools 的设计中起到了至关重要的作用。本章展示了一些设计每个 Autotools 的基本原则。有了这些概念，你将更好地理解 Autotools 设计师在架构决策背后的理论。

在本章中，我们还将从头到尾设计一个简单的项目——Jupiter，使用手工编写的 makefile。随着我们发现可以简化任务并为开源软件用户提供期望功能的功能，我们将一步步添加到 Jupiter 项目中。

第四章和第五章介绍了 GNU Autoconf 工程师为简化创建和维护可移植、功能性项目配置脚本所设计的框架。GNU Autoconf 包提供了创建复杂配置脚本的基础，项目维护者只需提供几行信息即可。

在这些章节中，我们将快速将手工编写的 makefile 转换为 Autoconf *Makefile.in* 模板，并开始向其中添加内容，以便获得一些最重要的 Autoconf 好处。第四章讨论了生成配置脚本的基础知识，而第五章则介绍了更高级的 Autoconf 主题、特性和应用。

第六章从将 Jupiter 项目的 *Makefile.in* 模板转换为 Automake *Makefile.am* 文件开始。在这里，你将发现 Automake 对于 makefile 就像 Autoconf 对于配置脚本一样。 本章介绍了 Automake 的主要特性，以一种随着 Automake 新版本发布而不至于过时的方式呈现。

第七章和第八章解释了共享库的基本概念，并展示了如何使用 Libtool 构建共享库——这是一个用于共享库功能的独立抽象，可与其他 Autotools 一起使用。第七章从共享库简介开始，接着介绍了一些基本的 Libtool 扩展，使得 Libtool 成为可以替代 Automake 提供的更基础的库生成功能的现成工具。第八章则介绍了库版本管理和 Libtool 提供的运行时动态模块管理抽象。

第九章介绍了 Autotools 中的一个相对较新的功能——autotest。Autoconf 中的 autotest 功能使你能够轻松创建和管理集成测试执行框架。在之前的章节中，我们已经讨论了单个 makefile 中的单元测试。autotest 提供了一种机制，用于添加更多依赖于项目多个组件的全局测试。说实话，autotest 可以用于几乎任何你想要的测试。我们将重点介绍如何添加 autotest 测试套件，以确保你的项目按预期自动运行。

第十章讨论了查找编译时和链接时依赖关系的概念，并将适当的引用添加到构建工具命令行中。具体来说，本章介绍了`pkg-config`，它已成为 Linux 软件开发中的事实标准，提供了一个框架，便于查找和使用你的软件包依赖的组件。本章向你展示了如何使用`pkg-config`的*.pc*文件来查找依赖关系，以及如何为你的项目提供*.pc*文件，遵循良好的实践。

第十一章和第十二章分别讨论了国际化（缩写为*i18n*）和本地化（*l10n*）——在你的项目中轻松管理文本字符串和其他与地区相关的属性（如数字、货币和日期的引用），这些内容在本地化版本的项目中应有所不同。

第十三章讨论了通过使用 Gnulib，在你的项目中获得最大的可移植性。

第十四章和第十五章展示了如何将一个已有的、相对复杂的开源项目（FLAIM）从使用手工构建系统转变为使用 Autotools 构建系统的过程。这个例子将帮助你理解如何将你自己的现有项目进行*autoconfiscate*（即自动配置化）。

第十六章概述了与深入理解 Autoconf 相关的 M4 宏处理器的功能。本章还讨论了编写自己 Autoconf 宏的过程。

第十七章讨论了使用 Autotools 构建旨在运行在 Microsoft Windows 平台上的软件。我将向你展示如何在 Linux 上为 Windows 进行交叉编译，以及如何安装和使用三种最流行的基于 Windows 的 POSIX 平台——Cygwin、Msys2 和 MinGW——使用 GNU 工具，包括 Autotools，来构建 Windows 软件。

微软提供了一套很棒的免费工具，用于构建 Windows 软件，但如果你的软件包已经在 Linux 上运行并使用 POSIX 构建工具进行构建，使用 Autotools 构建 Windows 软件可以让你快速启动并运行。在此基础上，你可以决定你现有的工具是否足够好，或者是否需要为 Windows 提供一个原生的构建环境。

第十八章是关于 Autotools 问题的技巧、窍门和可重用解决方案的汇编。本章中的解决方案以一组独立的主题或条目呈现，每个条目可以在没有上下文的情况下单独理解。

第三章至第九章围绕 Jupiter 项目构建。第十四章和第十五章介绍 FLAIM 项目。第十一章和第十二章讨论 gettext 项目，第十三章讨论 b64 项目。这些项目可以在 GitHub 的 NSP-Autotools 站点找到，链接是* [`github.com/NSP-Autotools`](https://github.com/NSP-Autotools)*。

除了 FLAIM 项目外，每个这些仓库都有标记，标记的提交表示主题的过渡。这些标签在相关章节的边缘被标出。当你在书中看到标签时，你可以通过检查仓库中的标记提交来轻松跟随。

### 本书中使用的约定

本书包含数百个程序列表，大致分为两类：控制台示例和文件列表。控制台示例没有标题，用户输入部分是加粗的。

通常，我会使用 Linux 的`ls`命令并加上各种选项，在进行更改前或更改后显示目录内容。不同的 Linux 发行版通常默认启用`ls`的别名。我正在使用 Linux Mint 18 和 Cinnamon 桌面编写本书；我为`ls`定义的别名是：

```
$ alias
--snip--
alias ls='ls --color=auto'
$
```

你可能会发现你的系统上有一个`ls`别名，它提供了不同的默认功能，这可能会影响你精确复制我控制台示例的尝试。只需了解这些可能差异的原因。

文件列表包含文中讨论的文件的完整或部分列表。所有命名的列表都提供在关联的 git 仓库中。我尽力为修改过的部分提供足够的上下文，这样你就能轻松看到哪些行被添加或更改。然而，有一些列表中删除了行。在这些情况下，我在靠近列表的文本中指出了删除的行。

没有文件名的列表完全包含在打印的列表中，应该独立地看待这些内容，而不是作为提供的源代码库的一部分。一般来说，和之前列出的文件版本保持一致的文本会被灰色显示，而修改过的部分则会用黑色文本显示。

对于与 Jupiter 和 FLAIM 项目相关的列表，标题首先指定文件相对于项目根目录的路径，然后提供该文件在列表中所做的更改描述。

在整本书中，我将 GNU/Linux 操作系统简称为 *Linux*。应理解的是，使用 *Linux* 一词时，我指的是 GNU/Linux，它的正式名称。我使用 *Linux* 仅仅是作为该正式名称的缩写。

### 本书中使用的 Autotools 版本

Autotools 一直在更新——平均而言，三个最重要工具（Autoconf、Automake 和 Libtool）的每次重大更新大约每一年半发布一次，且小更新每三到六个月发布一次。Autotools 开发者会尽力保持新版本的合理向后兼容性，但偶尔会有重大内容被破坏，旧文档因此变得过时。最近，Autotools 被认为已经成熟完整；发布周期变慢，重大变化也很少发生。这对社区和你作为读者来说都是好事，因为这意味着你在本书中找到的内容将在很长一段时间内保持相关性。

虽然我描述了最近发布的 Autotools 版本的新特性，但为了让本书更具长久性，我尽量坚持描述一些已经广泛使用多年的 Autotools 特性（例如 Autoconf 宏）。细节偶尔会有所变化，但一般使用方法在多个版本中保持一致。

在本书的适当位置，我提到了我使用的 Autotools 版本，但在这里我将做一个总结。我使用了版本 2.69 的 Autoconf，版本 1.15 的 Automake（截至写作时，最新版本实际上是 1.16.1），以及版本 2.4.6 的 Libtool。在出版过程中，我能够做出一些小的修正，并随着新版本发布进行更新。

此外，我使用了版本 0.19.7 的 GNU gettext（最新版本为 0.20.1）和版本 0.29.1 的 `pkg-config`（最新版本为 0.29.2）。GNU 可移植性库 Gnulib 不是以软件包形式发布，而是作为一组代码片段，直接从 GNU 网站下载（[*https://www.gnu.org/software/gnulib/*](https://www.gnu.org/software/gnulib/)）。
