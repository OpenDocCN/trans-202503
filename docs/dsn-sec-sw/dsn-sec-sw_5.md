# 第二章：A

示例设计文档

![](img/chapterart.png)

以下文档为假设性设计，旨在说明如何对实际设计执行安全设计评审（SDR）。作为学习工具，它省略了在真实设计中会出现的许多细节，重点放在安全方面。因此，它并不是一个完整的真实软件设计文档示例。

## 标题 – 私有数据日志记录组件设计文档

**目录**

1.  第一部分 – 产品描述

1.  第二部分 – 概述

    1.  2.1 目的

    1.  2.2 范围

    1.  2.3 概念

    1.  2.4 需求

    1.  2.5 非目标

    1.  2.6 未解决的问题

    1.  2.7 替代设计

1.  第三部分 – 用例

1.  第四部分 – 系统架构

1.  第五部分 – 数据设计

1.  第六部分 – API

    1.  6.1 Hello 请求

    1.  6.2 架构定义请求

    1.  6.3 事件日志请求

    1.  6.4 Goodbye 请求

1.  第七部分 – 用户界面设计

1.  第八部分 – 技术设计

1.  第九部分 – 配置

1.  第十部分 – 参考文献

## 第一部分 – 产品描述

本文档描述了一个日志记录组件（以下简称为 Logger），该组件提供标准的软件事件日志记录功能，以支持审计、系统监控和调试，旨在减少无意信息泄露的风险。**Logger 将明确处理日志中的私有数据，以便非私有数据可以自由访问进行常规使用。在少数情况下，当这种访问级别不足时，可以提供对受保护的私有日志数据的有限访问，但需经过明确批准，并采取限制措施以最小化潜在的暴露风险。**

*在日志记录系统中明确单独处理私有数据的概念是安全为中心的设计思维的一个例子。与从一开始就设计此功能相比，将其添加到现有系统中将效率较低，并且需要大量的代码修改。*

## 第二部分 – 概述

有关基础项目设计假设，请参见第十部分中列出的文档。

### 2.1 目的

数据中心中的所有应用程序需要记录重要软件事件的详细信息，由于这些日志可能包含私有数据，因此需要实施严格的访问控制。Logger 提供了生成日志、存储日志以及对授权人员执行适当访问控制的标准组件，同时保持对发生的访问行为可靠且**不可否认**的记录。由于系统的日志记录、访问和保留要求各不相同，Logger 基于简单的策略配置运行，并指定访问策略。

### 2.2 范围

本文档解释了 Logger 软件组件的设计，但并未强制要求选择实现语言、部署或操作考虑因素。

### 2.3 概念

日志的过滤视图的概念是设计的核心。其想法是允许相对自由地检查日志，同时过滤掉所有私密细节，这种访问级别应适用于大多数用途。此外，在需要时，可以检查记录的敏感数据，需经过额外授权。访问事件也会被记录下来，确保检查过程是可审计的。这种分级访问允许应用程序记录重要的私密细节，同时最大程度地减少这些数据在内部员工的合法使用中暴露的方式。对于那些敏感到绝不应出现在日志中的数据，根本就不应该将其记录在日志中。

例如，Web 应用程序通常会记录 HTTPS 请求，作为系统使用的记录以及其他许多原因。这些日志通常包含私密信息（包括 IP 地址、Cookie 以及更多），这些信息必须捕获，但很少需要。例如，IP 地址在调查恶意攻击时非常有用（用来识别攻击的来源），但对于其他用途并不重要。日志的过滤视图隐藏或“包装”私密数据，同时显示非敏感数据。在过滤视图中指定的化名可以显示，例如，所有标记为“IP7”的事件的 IP 地址是相同的，而不披露实际地址。这样的过滤视图通常为监控、统计收集或调试提供足够的信息。如果是这种情况，避免暴露任何私密数据是有利的。日志仍然包含完整的数据，在少数情况下，当需要保护的信息时，可以在经过适当授权的情况下以控制方式访问未过滤的视图。

假设一个 Web 应用程序接收到一个用户登录尝试，触发了一个错误，导致过程崩溃。以下是日志可能包含的简化示例：

```
2022/10/19 08:09:10 66.77.88.99 POST login.htm {user: "SAM", password: ">1<}2{]3[\4/"}
```

此日志中的项包括：时间戳（不敏感）、IP 地址（敏感）、HTTP 动词和 URL（不敏感）、用户名（敏感）以及密码（非常敏感）。调查时可能需要考虑所有这些信息以重现错误，但除非绝对必要，否则不应以明文显示这些数据，且只有授权的人员才能查看。

为了满足各种系统的安全需求，各种日志数据的敏感度应该是可配置的，且日志系统应仅选择性地揭示机密数据。例如，作为最佳实践，URL 不应包含敏感信息，但一个旧系统可能被认为违反了这一经验规则，需要额外的保护，而这种保护通常是不必要的——这使得过滤后的视图在某些调试时不太有用。在 URL 的情况下，正则表达式可以帮助配置某些 URL 为比其他 URL 更加敏感。

之前示例日志的过滤视图，省略或包装敏感数据，可能看起来是这样的：

```
2022/10/19 08:09:10 US1(v4) POST login.htm {user: USER1(3), password: PW1(12)} 
```

IP 地址、用户名和密码都被包装为标识符以隐藏数据，但替代的标识符可以在上下文中用于查询其他具有匹配值的请求。例如，`US1`表示美国的 IP 地址；`USER1`表示与事件关联的用户名，但不具体透露；`PW1`表示提交的密码。括号中的后缀表示实际数据的格式或长度，添加了一个提示而不透露具体细节：我们可以看到它是一个 IPv4 地址，用户名有 3 个字符，密码有 12 个字符。**例如，如果一个过长的密码导致了问题，仅凭其惊人的长度就能显现这一点。知道密码的长度会泄露一些信息，但在实际操作中不应构成安全威胁。**

当过滤后的视图不足以完成当前任务时，可以发出额外请求来解包标识符，如`US1`。这使得查看敏感数据成为一个明确的选择，并允许逐步揭示数据。例如，如果只需要 IP 地址，则用户名和密码的值将保持不公开。

### 2.4 要求

日志可靠存储，在获得授权后可以立即访问，并在保留期结束后销毁。为了支持高频使用，日志捕获接口必须快速，一旦报告成功，生成应用程序可以合理地保证日志已存储。

可以在不知道私人详情的情况下监控日志，因此可以广泛提供过滤后的日志视图供大多数用途使用，仅在绝对必要时，才需要特殊授权才能查看完整数据（包括私人数据）。

该设计的一个重要目标是允许记录非常敏感的私人数据，这些数据可以用于调查可能的安全事件，或在极少数情况下，用于调试仅在生产环境中发生的问题。完全防范内部攻击是不切实际的目标，但采取所有合理的预防措施并保留可靠的审计跟踪作为威慑是非常重要的。

日志存储经过加密，以防止在物理介质被盗的情况下泄露。

生成日志的软件完全信任；它必须正确识别私人数据，以便 Logger 能正确处理它。

### 2.5 非目标

由于 Logger 是为管理员使用而设计的，因此无需华丽的用户界面。

**内部攻击，例如代码篡改或滥用管理员 root 权限，超出了本设计的范围。**

**为了有效，Logger 需要仔细的配置和监督。如何实现这一点必须由系统管理定义，但应包括审查过程和检查与平衡的审计。**

### 2.6 未解决的问题

日志访问配置、用户认证和未过滤访问授权的授予细节尚待确定。

**查询加密的私密数据本身是很慢的。该设计设想日志数据量足够小，能够通过暴力破解（即不依赖索引）按需解密记录，并保持良好的性能。未来一个更为雄心勃勃的版本可能会解决加密数据的索引和快速查询问题。**

需要识别错误情况并指定处理方法。

Logger 未来版本可以考虑的增强功能包括：

+   定义提供更多或更少详细信息的过滤视图级别

+   提供一种设施来捕获日志的部分内容进行长期安全存储，最终会定期删除

### 2.7 替代设计

**最终选择的设计是完全信任 Logger 来存储所有敏感信息在日志中，”把所有鸡蛋放在一个篮子里“。曾考虑过一个替代方案，允许根据来源对敏感信息进行隔离。这种方案未被采纳，原因有几点（简要解释如下），这些原因似乎与重要的使用场景不兼容，但值得注意的是，这种方案可能会是一个更安全的日志记录解决方案。**

**替代设计**

1.  日志源将创建一对非对称加密密钥，并使用该密钥加密日志记录中敏感数据部分后发送给 Logger。如果小心处理，Logger 可能仍然能够为过滤后的视图生成化名（例如，将某个美国 IP 地址映射为`US1`）。授权访问未过滤视图则需要使用私钥来解密数据。这种方法的主要优点是，存储的日志数据泄露不会泄露已加密的敏感数据，且 Logger 甚至没有必要的密钥。

**未选择的原因**

1.  该设计将加密和密钥管理的责任放在日志源和授权访问者身上。数据敏感性及其如何进行分区的定义由日志源决定，并在那个时候固定。通过将信任集中在 Logger 上，可以根据需要重新配置这两个方面，并通过认证日志查看者来控制精细的访问权限。

## 第三部分 – 使用场景

数据中心的应用程序使用 Logger 生成重要软件事件的日志。常规监控软件和适当的操作人员可以访问过滤后的数据（无任何私密数据披露）以完成常规任务。操作统计数据，包括流量水平、活跃用户、错误率等，均来自过滤后的日志视图。

在少数情况下，当支持或调试需要访问未过滤的日志时，授权的人员可以根据策略获得有限的访问权限。访问请求指定所需日志的子集、它们的时间窗口以及访问原因。一旦批准，发放一个令牌，允许访问，并且会记录用于审计。完成后，请求者会添加一条描述调查结果的备注，审批人会审查该备注以确保合规性。

生成报告，详细总结请求、批准、审计审查、日志量趋势以及已过期日志数据删除的确认，以便向管理层提供信息。

## 第四部分 – 系统架构

在数据中心内，Logger 服务的**实例运行在物理上独立的机器上，与它们所服务的应用程序独立运行**，通过标准的发布/订阅协议进行通信。Logger 由三个新服务组成，组织如下：

**Logger Recorder**

1.  一个日志存储服务。应用程序通过**加密通道**将日志事件数据流式传输到 Logger Recorder 服务，在那里它们被写入持久化存储。可以配置一个实例来处理多个应用程序的日志。

**Logger Viewer**

1.  一个 web 应用程序，技术人员使用它手动检查过滤后的日志，并且根据策略授权可以显示未过滤的视图。

**Logger Root Recorder**

*1.  Logger Recorder 的一个特殊实例，用于记录 Logger Recorder 和 Viewer 的事件。*为了简化，我们省略了这个日志的过滤和未过滤视图的细节。*

## 第五部分 – 数据设计

日志数据直接从应用程序收集，应用程序决定哪些事件以及哪些详细信息应该被记录。**日志是只追加的记录，记录软件事件，除了在过期时被删除外，从不被修改。**

应用程序定义了日志事件类型的模式，其中包含零个或多个预配置的数据项，如以下示例所示。所有日志事件必须具有时间戳和至少一个其他标识数据项。

```
{LogTypes: [login, logout, ...]}
{LogType: login, timestamp: time, IP: IPaddress, http: string, 
 URL: string, user: string, password: string, cookies: string}
{LogType: logout, timestamp: time, IP: IPaddress, http: string, 
 URL: string, user: string, cookies: string}
{Filters: {timestamp: minute, IP: country, verb: 0, URL: 0, 
 user: private, password: private, cookies: private}}
```

*关于内建类型、格式化等的许多细节被省略，因为这些内容如何定义的基本思路应该从这个部分示例中可以清楚地看出。*

**请求和响应必须是 UTF-8 编码的有效 JSON 表达式，且长度不得超过 100 万字符。单个字段值的最大长度为 10,000 字符。**

第一行（`LogTypes`）列出了该应用程序将产生的日志事件类型。对于每种类型，带有相应 `LogType` 条目的 JSON 记录（第二行是 `LogType: login`）列出了可以随日志提供的允许数据项。

第四行（`Filters`）声明了每个数据项的处理方式：`0` 表示非敏感数据，`private` 表示要“包装”的私密数据，以及其他特殊类型的数据处理，包括：

**`minute`**

1.  时间值四舍五入到最接近的分钟（遮蔽了精确时间）

**`country`**

1.  在过滤视图中，IP 地址会映射到原始国家。

过滤器应通过可插拔组件定义，并且容易扩展以支持各种应用程序所需的自定义数据类型。

**请注意，“非敏感”数据仅应供有限的内部查看；此标签并不意味着这些数据应公开披露。** 所有数据项必须声明，包括处置方式（私密或公开），这一要求是为了确保在应用程序上下文中对每项数据做出明确的决策。**这些定义及其任何更新必须经过仔细审查，以确保日志处理的完整性。**

这是该模式在未过滤视图中的日志条目示例：

```
2022/10/19 08:09:10 66.77.88.99 POST login.html {user: "SAM", password: ">1<}2{]3[\4/"}
```

这是相应的过滤视图：

```
2022/10/19 08:09 US1(v4) POST login.html {user: USER1(3), password: PW1(12)}
```

数据会被持久存储，并且在策略配置的到期日期之前可用，时间以事件日志时间戳为基准。

日志仅为瞬时数据，旨在用于监控、调试或在发生安全漏洞时进行取证，因此只会保留有限的时间。**通过将数据存储在专用机器上，并使用 RAID（或类似）磁盘阵列进行冗余持久存储，可以降低潜在的数据丢失风险。日志作为短期存储用于审计和诊断目的。任何此类数据的长期存储应单独存储。**

## 第六部分 – API

Logger 记录器的网络接口接受以下远程过程调用：

**你好**

1.  必须是会话的第一个 API 调用；标识应用程序和版本

**模式**

1.  定义日志数据模式（参见第五部分）

**日志**

1.  发送事件数据（参见第五部分）以记录到指定的日志中

**再见**

1.  当应用程序终止时发送，结束会话

每个应用程序通过专用通道连接到其日志服务。**HTTPS 通过认证的端点确保 API 调用的安全；预配置的服务器名称通过其数字证书验证客户端是否连接到有效的 Logger 服务实例。** 以下是请求类型。

### 6.1 你好请求

任何将使用 Logger 服务的进程都需要发送此请求以启动日志记录：

```
{"verb": "Hello", "source": "Sample application", "version": "1"}
```

以下响应确认请求并提供 OK 或错误消息，并为会话提供一个字符串令牌：

```
{"status": "OK", "service": "Logger", "version": "1", "token": "XYZ123"}
```

该令牌用于后续请求中，以识别与 `你好` 对应的启动应用程序的上下文。**令牌是随机生成的，具有足够的复杂性和熵以避免猜测：推荐的最小令牌大小为 120 位，或约 20 个字符的 base64 编码。为了简洁起见，这里使用了较短的令牌。**

### 6.2 模式定义请求

本请求定义了后续日志记录的数据模式，如第五部分所述：

```
{"verb": "Schema", "token": "XYZ123", ...}
```

*为了简洁，省略了此请求的详细信息。*

架构定义了将在日志内容中出现的字段名称、类型和其他属性，如下节中显示的示例事件日志请求所示（其中包括字段`timestamp`、`ipaddr`、`http`、`url`和`error`）。

### 6.3 事件日志请求

此请求实际上会记录一个条目到 Logger 服务中：

```
{"verb": "Event", "token": "XYZ123", "log": {
 "timestamp": 1234567890, "ipaddr": "12.34.56.78", 
 "http": "POST", "url": "example", "error": "404"}}
```

`log` JSON 展示需要记录到日志中的内容，必须符合架构要求。

响应确认请求，返回 OK 或错误消息：

```
{"status": "OK"}
```

*为了简洁，错误详情被省略。* **日志错误（例如，存储空间不足）是严重的，需要立即处理，因为在没有日志记录的情况下，系统操作无法审核。**

### 6.4 告别请求

此请求完成了日志记录的一个会话：

```
{"verb": "Goodbye", "token": "XYZ123"}
```

响应确认请求，返回 OK 或错误消息：

```
{"status": "OK"}
```

之后的令牌将不再有效。要恢复日志记录，客户端必须首先发送`Hello`请求。

## 第七部分 - 用户界面设计

日志记录器的用户界面是由 Logger Viewer 提供的 Web 界面，用于查看日志。**Web 应用程序仅限授权操作人员访问，并通过企业单点登录进行身份验证。** 经过身份验证的用户将看到他们被允许访问的日志，并可通过链接浏览或搜索最新的过滤日志条目，或者在允许的情况下，请求访问未过滤的日志，需经批准。

*为简洁起见，本文仅提供 Web 界面的高层描述。*

审批请求排队等待处理，Web 表单提供基本信息：

+   请求访问的原因，包括如客户问题票号等具体信息

+   请求的访问范围（通常是特定的用户账户或 IP 地址）

审批请求会触发自动邮件，发送给审批人，并提供一个链接，指向 Web 应用页面以审查这些请求。当每个决定作出时，系统会通过邮件通知请求者，内容如下：

+   审批或拒绝

+   拒绝的原因（如果适用）

+   批准访问的时间窗口

过滤和未过滤的日志在与每个日志对应的页面上可见。可以输入查询，指定要查看哪些日志条目。空查询显示最近的条目，并带有“下一页/上一页”链接，用于翻阅结果。

查询指定日志条目字段和值，并结合布尔运算符选择匹配的日志条目。默认情况下，最先显示最新的条目，除非查询中明确指定排序顺序。*为简洁起见，查询语法的详细内容被省略。*

过滤后的日志使用符号标识符显示（参见第 2.3 节），而不是原始日志内容。查询可以使用过滤日志内容中的符号标识符；例如，如果一个过滤后的日志条目显示 IP 地址`US1`，则查询`[IP = US1]`将找到来自该 IP 地址的其他日志，而不会透露实际的 IP 地址。

**对过滤日志的查询必须禁止对具有精确值的过滤字段进行搜索。例如，即使 IP 地址未显示，如果用户能够猜到** `[IP = 1.1.1.1]` **（等等），他们最终可能会找到一条日志条目，其中显示为** **USA888，然后能够推断出实际值。**

即使批准了未过滤的访问，用户也必须选择一个选项才能开始未过滤的查看和查询。**最佳实践是最大限度地使用过滤日志，仅在需要时才揭示过滤后的值，且重要的是用户界面应鼓励这种做法。**

用户在任务完成后可以放弃对未过滤日志的访问权。用户界面应在一段时间不活跃后提示此操作，以减少不必要访问的风险。

**显示日志内容的网页不应被用户代理本地缓存，以避免无意的泄露，并确保在过期后，日志数据不再可用。**

## 第八部分 – 技术设计

Logger Recorder 服务包括一个仅写接口，用于让应用程序流式传输日志事件数据，并将其写入持久化存储，同时提供查询接口以查看这些日志。存储是一个按顺序写入追加的文件序列，包含 UTF-8 文本行，每行代表一个日志事件。日志数据根据相关模式（见上文）映射到/从规范表示作为文本。*格式化的细节在本示例中省略。*

**受过滤影响的日志数据字段应存储为过滤后的表示形式，并与使用服务生成的 AES 密钥加密的原始数据一起保存，每天使用一个新的密钥。使用硬件密钥存储或其他合适的方式来安全保护这些密钥。**

由于存储空间耗尽会导致日志服务发生致命错误，因此写入速率是基于可用空间进行衡量的（`free_storage_MB` / `avg_logging_MB_per_hour`），如果空间不足以存储 10 小时的数据（假设写入量恒定），则会触发优先级操作警报（此警报的小时数可以配置）。

为了提高性能，可以考虑使用 SQL 数据库记录过滤后的日志事件信息（时间戳、日志类型、文件名和偏移量），以补充实际的日志文件，便于高效访问。

过滤日志通过符号标识符隐藏私人数据（例如，`US1`代表美国的 IP 地址）。**为了避免存储未过滤的私人数据，这些映射从未过滤数据值的安全摘要映射到过滤后的标识符。** 这种映射是临时的，由 Logger Viewer 根据每个日志的用户上下文单独维护。用户可以清除映射以重新开始，或者在 24 小时不使用后，它们会自动清除，以防止随着时间的推移积累无用数据。

## 第九部分 – 配置

日志保留配置如下。**数据将在保留期结束后自动、安全并永久删除（不仅仅是移至回收站；请使用`shred(1)`命令或类似工具）。**

```
Retention: {
  "Log1": {"days": 10},
  "Log2": {"hours": 24},
}
```

通过配置授权用户列表来授予日志访问权限：

```
Access: {
  "Log1": {"filtered": ["u1", "u2", "u3", . . .],
           "unfiltered": ["x1", "x2", "x3", . . .]},
           "approval": ["a1", "a2", "a3", . . .]},
}
```

被允许过滤访问名为`Log1`的日志的用户将以括号表示，如上所示（例如，`u1`，`u2`，`u3`）。被允许不经过过滤访问的用户将以类似方式列出。这些用户只有在批准请求后才能获得访问权限。最后，有权授予有限不经过过滤访问权限的用户将以相同的方式列出。

## 第十部分 – 参考文献

以下文档对于理解本设计文档非常有用。

*这些是虚构的。*

+   企业基线设计假设文档（在第二部分中引用）

+   企业一般数据保护政策和指南

+   发布/订阅协议设计文档（在第四部分中引用）

## 文件结束*
