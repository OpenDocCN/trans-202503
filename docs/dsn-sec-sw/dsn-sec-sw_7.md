# 第四章：C

练习

> 探索是推动创新的引擎。
> 
> —埃迪丝·威德尔

![](img/chapterart.png)

本附录包含一些进一步探索的思路、未解的问题和挑战，适合那些希望超越本书内容的读者。

**第一章：基础**

+   本书侧重于传统计算机系统中的信息安全，但家电和设备也运行软件，并且这些设备越来越多地与互联网连接。我们如何将 C-I-A 等原则扩展到与物理世界互动的安全软件中？

**第二章：威胁**

+   对现有的软件设计进行威胁建模，或者仅对大型系统中的一个组件进行建模。

+   为了好玩，进行一个威胁建模，选择你最喜欢的电影或书中的场景，在那里对手为了争夺珍贵资产而展开激烈斗争。

**第三章：缓解措施**

+   编写帮助函数，限制内存中敏感数据的暴露，如第 47 页“最小化数据暴露”中所述。

+   故意编写一个混淆代理（Confused Deputy）并尝试利用它，或者挑战同事来做这件事。修复漏洞并确认代码安全。

+   设计一个库，强制执行现有数据访问 API 的可扩展访问策略。

**第四章：模式**

+   选取现有设计，或开展新的设计，看看你能使用本章中多少模式，将其做到尽可能安全。

+   你能想到哪些额外的安全模式和反模式？保持一个持续更新的清单，加入本章中提到的模式，并与同事分享。

+   白名单（allowlist）总比黑名单（blocklist）更好吗？想想有没有例外，或者解释为什么没有例外。

**第五章：加密学**

+   一种轻松体验真实加密工具的方法是使用 OpenSSL 命令行工具（[`wiki.openssl.org/index.php/Main_Page`](https://wiki.openssl.org/index.php/Main_Page)）。你可以用它实验对称和非对称加密、MAC（在`openssl(1)`中称为*摘要*），甚至创建和检查你自己的证书。

+   找到一个高质量的加密库，并尝试用它实现本章中描述的基本操作。它的 API 使用起来如何？你对自己的实现安全性有多有信心？

+   如果前面的练习感觉困难，如何重新设计 API，让它更易用，同时也更加防错？

+   编写你想到的加密 API 改进，或者将原始库包装成提供更好 API 的形式。

**第六章：安全设计**

+   探索谷歌的设计文档写作指南（[`www.industrialempathy.com/posts/design-docs-at-google/`](https://www.industrialempathy.com/posts/design-docs-at-google/)）。

+   如果你以前没有编写过软件设计文档，下一次有机会时可以尝试编写（可以尽量简洁高层次）。

+   如果您正在处理一个没有书面设计文档的代码库，请回溯性地创建一个。对于大型系统，可以一次创建一个组件的设计，重点关注对安全最重要或其他感兴趣的组件。

**第七章：安全设计评审**

+   查找现有设计并作为学习练习进行评审。不要仅仅寻找漏洞；要对设计的优势和弱点进行广泛评估，包括安全最重要的地方、设计如何增强安全性、缓解方案的替代方法，以及如何改进安全性或使其更易用。

+   与同事分享并讨论前面练习中的发现。

**第八章：安全编程**

+   为了感受现实世界中安全漏洞的例子，可以寻找已经在您的代码库或开源软件项目中发现并修复的安全漏洞。我建议专注于开源项目，因为漏洞通常会详细描述，并且您可以看到代码。美国国土安全部赞助了一个大型的公开已知漏洞数据库（[`cve.mitre.org/`](https://cve.mitre.org/)）。Chromium 漏洞数据库是另一个很好的公开漏洞来源（[`bugs.chromium.org/p/chromium/issues/list/`](https://bugs.chromium.org/p/chromium/issues/list/)）。一个好的起点是过滤这些数据库中已修复的安全漏洞，以便查看实际的代码更改。

+   *隐蔽编码*，也称为*混淆编码*，是一种使用“脚枪”和其他诡计编写代码的精湛艺术，这些代码的行为与代码表面上的检查结果不同。隐蔽编码比赛挑战程序员展示他们在推动编程语言极限方面的创造力。但同样的技术也可以用来掩盖恶意代码，甚至如果不小心碰到，可能会成为“脚枪”。查看这些网站作为开始，或者尝试自己创作：[`www.underhanded-c.org/`](http://www.underhanded-c.org/) 和 [`underhandedcrypto.com/`](https://underhandedcrypto.com/)。

**第九章：低级编码缺陷**

+   为什么提供定宽整数类型的语言没有提供任何检测溢出的机制？这样做有帮助吗？如果有，您将如何扩展 C 语言以利用这一点？

+   探索像 Valgrind 这样的分析工具如何检测内存管理问题（[`valgrind.org/docs/manual/mc-manual.html`](https://valgrind.org/docs/manual/mc-manual.html)）。

+   编写一个小程序，其中包含几种类型的内存管理漏洞，例如读写缓冲区溢出。使用类似 Valgrind 的工具查看它是否能检测到漏洞。尝试变更代码，使其更难被工具分析，并查看是否能让漏洞躲过工具的检测。

**第十章：不受信任的输入**

+   确定你所从事系统的主要攻击面上的不受信任输入，并检查输入验证的实现和测试是否足够全面。

+   如果你发现不受信任的输入可能代表漏洞，请实现输入验证。

+   通常，系统的输入验证是重复的。寻找机会使用公共代码或辅助函数来可靠地处理它。考虑将输入验证嵌入到框架中，以防止它被意外遗漏。

**第十一章：网页安全**

+   为创建和验证网页会话的组件编写安全要求。设计并进行威胁建模，找个朋友做安全审查。

+   将你的网页会话实现构建成一个简单的网页应用。尝试模拟另一个会话，或窃取必要的会话状态。更好的是，找一个朋友来“攻击”你的实现。

+   为组件添加 CSRF 保护机制，并在你的网页应用中进行测试。

+   探索不使用 cookies 来保护网页会话的方法，作为实验以理解安全挑战的本质。

+   查找一个网页框架的源代码（最好还有一个书面设计文档），了解它如何实现会话，防止 XSS 和 CSRF 漏洞，并确保 HTTPS 安全所有网页交互。通过威胁建模或其他方法，你能找到任何漏洞吗？如果想尝试攻击它，可以搭建一个自己的测试服务器进行测试。

**第十二章：安全测试**

+   在你选择的代码库中，找到一个安全性重要的区域，寻找应该添加的额外安全测试用例。编写并贡献新的安全测试用例。

+   考虑一下在 GotoFail 中漏洞的另一个示例，安全测试写得很不错，但它无法捕捉到这个漏洞——在额外的`goto fail;`语句中，实际上应该插入这一行：

    ```
    if (expected_hash[0] == 0x23) goto fail;
    ```

+   这种技术可能被用来偷偷地引入一个需要特定触发器的漏洞，作为一种后门。要检测这个漏洞，需要一个测试用例，其预期的哈希值的第一个字节是 0x23。你能写出测试用例来检测这种漏洞而不知道具体细节吗？

+   查看一个已知漏洞的开源软件项目的旧版本。运行测试套件并确保所有测试通过。编写一个安全回归测试以确认漏洞。同步到修复漏洞的下一个版本，合并回归测试。你的安全回归测试现在应该通过；如果没有，修复它。然后，在最新版本中检查是否存在其他相关漏洞。

**第十三章：安全开发最佳实践**

+   探索一些简单的方法来逐步提高代码质量，例如使用 lint 或代码扫描工具，以及检查错误和异常处理的测试覆盖率。

+   查看代码库中安全方面的文档化情况，并进行必要的改进。

+   每当进行代码审查时，适时地再戴上安全帽，做一次额外的检查。

+   在进行缺陷分类时要考虑安全性，或者在浏览你的缺陷数据库时要牢记安全性，看看是否有涉及安全问题的缺陷被忽视了。

**后记**

+   寻找机会在结论中提到的方向上进行改进，即使这意味着采取小步骤：更广泛的安全参与、更早地融入安全视角和策略、减少或管理复杂性、提高关于安全实践的透明度等等。

+   识别一个独特的安全挑战，并设计和开发一个可重用的组件来解决它。

+   寻找其他自己的想法，提升安全标准并传播这一理念。
