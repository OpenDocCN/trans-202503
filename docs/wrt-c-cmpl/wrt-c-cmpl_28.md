<hgroup>

# <samp class="SANS_Dogma_OT_Bold_B_11">索引</samp>

</hgroup>

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">符号</samp>

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> （加法）运算符。*参见* 加法运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> （加法赋值）运算符， 113

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> （地址）运算符。*参见* 地址运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> （与）运算符。*参见* 与运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> （赋值）运算符。*参见* 赋值表达式

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> （按位与）运算符， 67

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">&=</samp> （按位与赋值）运算符， 113

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> （按位补码）运算符。*参见* 按位补码运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> （按位或）运算符， 67

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">|=</samp> （按位或赋值）运算符， 113

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">?:</samp> （条件）运算符， 121–124。*另见* 条件表达式

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> （自减）运算符， 31–32， 33， 113

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> （解引用）运算符。*参见* 解引用运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> （除法）运算符。*参见* 除法运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp> （除法赋值）运算符， 113

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> （等于）运算符。*参见* 等于运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp> （大于）运算符。*参见* 大于运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> （大于或等于）运算符。*参见* 大于或等于运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> （自增）运算符， 113

+   <samp class="SANS_TheSansMonoCd_W5Regular_11"><<</samp> （左移）运算符， 67

+   <samp class="SANS_TheSansMonoCd_W5Regular_11"><<=</samp> （左移赋值）运算符， 67

+   <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> （小于）运算符。*参见* 小于运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> （小于或等于）运算符。*参见* 小于或等于运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>（乘法）运算符。*参见* 乘法运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp>（乘法赋值）运算符，113

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>（否定）运算符。*参见* 否定运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>（非）运算符。*参见* 非运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>（不等于）运算符。*参见* 不等于运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>（或）运算符。*参见* 或运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>（余数）运算符。*参见* 余数运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">%=</samp>（余数赋值）运算符，113

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">>></samp>（右移）运算符，67

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">>>=</samp>（右移赋值）运算符，113

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>（结构体成员）运算符。*参见* 结构体成员运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>（结构体指针）运算符。*参见* 结构体指针运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>（下标）运算符。*参见* 下标运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>（减法）运算符。*参见* 减法运算符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>（减法赋值）运算符，113

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>（异或）运算符，67

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">^=</samp>（异或赋值）运算符，113

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">A</samp>

+   ABI（应用二进制接口），184。*另见* System V x64 ABI

+   抽象声明符，361–363

+   抽象数组声明符，395–396

+   抽象语法树（AST），4，10–14

+   添加循环标签，150

+   添加类型信息，252–253

+   AST 类型问题，253

+   其他资源，21–22

+   汇编，18，40

+   常量表示，248，276，306

+   结构体决定计算顺序，49

+   TACKY，36–37

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge</samp> 函数，579–580

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> 指令，60，62–63

+   发射，66，270

+   修复，64，268

+   加法（<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>）运算符，47–50

+   汇编，60，62–63

+   浮点数，315

+   解析，50–55

+   指针加法，387–390

+   TACKY 用于，406–408

+   类型检查，400，472

+   TACKY 用于，58

+   类型检查，254–255

+   加法赋值（<samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp>）运算符，113

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">add_pseudoregisters</samp>，632，633，637

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> 指令，406–408

+   汇编，414–415

+   省略，517

+   使用结构成员访问，514–517

+   地址（<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>）运算符，349，353

+   汇编，376

+   对...的限制，364，474

+   解析，354–355

+   TACKY 用于，370–372，374，514，516–517

+   类型检查，364–365

+   地址获取分析，600–601

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> 表达式，354。*参见* 地址运算符

+   数组衰退实现，398–399，409–410，441

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp> 指令，311–312

+   修复，337

+   *高级编译器设计与实现*（Muchnick），669

+   聚合类型，384

+   阿尔弗雷德·V·阿霍（Aho），611，670

+   别名分析，601

+   额外资源，611

+   别名变量，599–602，609，637

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp> 指令，221，238–239

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp> 函数，461

+   分配的存储持续时间, 213, 461

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> 指令, 40, 42, 44, 268

+   AMD64。*见* x64 指令集

+   AND (<samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>) 运算符, 71–77

+   短路, 72

+   TACKY for, 75–77, 259

+   类型检查, 255, 470

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> 指令, 323–325, 337, 341

+   Appel, Andrew, 22, 670

+   Apple Silicon, xxxv

+   应用程序二进制接口 (ABI), 184. *另见* System V x64 ABI

+   算术运算。*另见各个运算符的名称*

+   在汇编中, 60–63

+   浮点数, 296

+   在汇编中, 311–312, 315–316, 327–328

+   舍入行为, 301

+   优先级值, 50, 55

+   类型检查, 254–255, 476–477

+   算术类型, 347, 476–477

+   通常的算术转换, 254, 279–280, 308, 435

+   ARM, xxvii, 672

+   数组声明符, 357–358

+   抽象, 361–362, 395–396

+   解析, 394–396

+   数组, 384–399

+   对齐, 415

+   汇编类型, 413

+   衰变, 386–387

+   声明, 384–385. *另见* 数组声明符

+   元素比较, 389–390

+   元素类型, 384

+   完整, 471–473

+   函数声明中的数组类型, 390–391

+   隐式转换为指针。*见* 数组到指针的衰变

+   初始化器, 385. *另见* 复合初始化器

+   字符串字面量作为, 425–426, 437–438, 440–441

+   内存布局, 385–386

+   多维的, 384–385, 386–389, 393

+   下标, 408–410

+   类型检查，在 398–399，402–405，471，472–473

+   变量长度，在 391

+   数组到指针的衰减，在 386–387

+   使用<samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>实现，在 398–399，409–410，441

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>操作数不受影响，在 462

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>表达式，在 495。*另请参见* 结构指针操作符

+   ASCII，在 10，204，426–427，449–450

+   转义序列的值，在 429

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp>指令，在 426–427，449–450

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp>指令，在 426–427，449–450

+   ASDL（Zephyr 抽象语法描述语言），在 13–14，22，171

+   字段名称，在 14

+   产品类型，在 171

+   总和类型，在 171

+   汇编器指令，在 5。*另请参见各个指令条目*

+   汇编器，在 xxviii，5

+   GNU 汇编器（GAS），在 268，338

+   调用，在 7

+   LLVM 汇编器，在 268，338

+   汇编代码，在 xxvii，4–7

+   算术运算，在 60–63

+   浮点数，在 311–312，315–316，327–328

+   AT&T 与 Intel 语法，在 6，244，570

+   位操作补码，在 26–27，40–41

+   注释，在 20

+   比较运算，在 78–81，82–83，85–86

+   无符号，在 283–285，287–288

+   浮点数，在 317，328

+   调试，在 675–697

+   使用 GDB，在 677–687

+   使用 LLDB，在 687–698

+   除法运算，在 60–63

+   无符号，在 286，288

+   浮点数，在 310–336

+   函数调用，在 161，184–199，312–315，519–528

+   跳转，83–87

+   链接到，168–169，220–223

+   长整型，244–246，261–264

+   取反，26–27，40–41，315–316，327–328

+   存储持续时间，220–223

+   字符串，426–429，450

+   类型转换，244–245，317–324

+   浮点数，317–324，328–329，445

+   符号扩展，244–245，263，444

+   截断，245，263，444

+   零扩展，286–288，443–444

+   汇编生成，4，17–19

+   编译器过程，39

+   参考表，700–701，704–711

+   汇编指令，5–6，17–18。*另请参见单个指令的名称*

+   汇编 AST，18

+   流式 SIMD 扩展，310–312

+   后缀，6，269，311，427，443–444

+   汇编类型，261–262，265–266

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>，443

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>，413

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>，324

+   八字节，536–537

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>，261

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>，261

+   后缀，269–271，340–341，443

+   赋值表达式，94–95

+   AST 定义，97–98

+   操作符，97，101

+   优先级值，103

+   解析，100–103

+   解析变量，107

+   TACKY，110，371–374，516

+   类型检查，256，368，399

+   验证左值，107，399

+   结合性，50–51

+   AST。*参见* 抽象语法树

+   AT&T 语法, 6, 244, 570

+   自动存储持续时间, 212–213, 217

+   数组初始化, 440

+   自动变量, 208

+   在符号表中, 229–230

+   类型检查, 233, 257

+   AVX 指令集扩展, 318

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">B</samp>

+   后端符号表, 266–267

+   不完全类型, 530, 546

+   寄存器使用追踪, 621–622, 635, 637, 647

+   返回值传递信息追踪, 546, 550

+   顶层常量, 327, 339, 446

+   向后分析, 584, 604

+   迭代算法, 607–608

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.balign</samp> 指令, 238–289

+   Ballman, Aaron, 475

+   基址指针, 29

+   基本块, 576–578

+   创建, 578–579

+   空的, 583

+   不可达, 581–582

+   基本源字符集, 430

+   基本类型, 356

+   Bendersky, Eli, 21, 68, 222, 611

+   二元表达式

+   AST 定义, 48

+   形式文法, 51, 52

+   解析, 50–55

+   随着优先级提升, 51–55

+   使用递归下降, 50–51

+   操作数，未排序, 58–59

+   TACKY 用于, 58

+   类型检查, 254–255

+   二进制小数, 297

+   二元运算符。*请参见* 二元表达式 *和单个运算符的名称*

+   按位与（<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>）运算符, 67

+   按位与赋值（<samp class="SANS_TheSansMonoCd_W5Regular_11">&=</samp>）运算符, 113

+   按位取反（<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>）运算符, 26

+   汇编, 26–27, 40–41

+   解析, 33–34

+   TACKY 用于, 36–37

+   令牌, 31–32

+   类型检查，254，308，369，435

+   按位或（<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>）运算符，67

+   按位或赋值（<samp class="SANS_TheSansMonoCd_W5Regular_11">|=</samp>）运算符，113

+   块，132，135

+   复合语句作为，132

+   解析，136

+   在中解析变量，136–139

+   块作用域声明，208–217。*参见* 作用域

+   无效，220

+   解析标识符，228–229

+   类型检查，232–233

+   博格沃尔德，迈克尔，343

+   中断标签，155–158

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 语句，146–148

+   注解，150，151，152–154

+   解析，149–150

+   TACKY 用于，155–156

+   布里格斯，普雷斯顿，669

+   布里格斯测试，656–659，666–667

+   额外资源，669–670

+   限制，661–663

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.bss</samp> 指令，222

+   BSS 段，222

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 后缀，427，443

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">build_graph</samp> 函数，631–632

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.byte</samp> 指令，450

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">C</samp>

+   调用者保存和被调用者保存的寄存器，185，648–649

+   汇编 AST 中的被调用者保存的寄存器，620–621

+   在图着色算法中，645–646

+   保存与恢复，187，193–194，196–197，648–649

+   跟踪被调用者保存的寄存器使用情况，646–647

+   调用约定，161，184。*参见* System V x64 调用约定

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> 指令，186，189–190

+   发射，201–202

+   生成，198–199

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp> 函数，461

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> 语句，159

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Cast</samp> 表达式, 248

+   隐式类型转换, 255

+   强制类型转换表达式。*参见* 类型转换

+   解析, 247–249, 464–466

+   指针类型作为操作数, 351–352

+   TACKY for, 259–260, 281–283, 309–310, 375, 440, 479

+   类型检查, 254, 369, 402, 471, 505

+   转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, 459, 471, 479

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp> 指令, 61–63, 262

+   发射, 66, 269

+   Chaitin, Gregory, 669

+   Chaitin-Briggs 算法, 669–670

+   字符常量, 424

+   词法分析, 429–431

+   解析, 433

+   类型的, 424

+   UTF–8, 424

+   字符类型, 423–424

+   汇编类型, 443

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, 423–424

+   整型提升, 424, 435

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, 423–424

+   指定符, 解析, 433

+   静态初始化器, 436

+   类型转换

+   汇编, 443–445

+   TACKY for, 440

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>, 423–424

+   宽, 424

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 关键字, 429

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型, 423–424

+   符号性, 424

+   静态初始化器, 436–438

+   Chu, Andy, 68

+   Ciechanowski, Bartosz, 345

+   Clang, xxxiv–xxxv, 4–5

+   浮点支持, 296–297, 317–318, 344

+   安装, xxxiv

+   使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> 命令调用, xxxv, 4

+   语言扩展，395，401，471

+   System V ABI 违规，444–445

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>，处理，474–475

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp> 函数，329–330，534–536

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp> 函数，532–533，537–538

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp> 函数，533–534

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> 指令，79–80，85–86，262

+   发射，90，270

+   修复，88，268

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp> 函数，665–666

+   在 build-coalesce 循环中，663

+   代码发射，4，19–20。*另见各个指令和语言构造的条目*

+   浮点常量，338–339

+   函数名，201

+   函数序言和尾声，43–44

+   指令大小后缀，269–271，340–341，443

+   本地标签，89，339，450

+   非可执行堆栈说明，19

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">@PLT</samp> 后缀，201–202

+   参考表

+   第一部分，702–704

+   第二部分，711–715

+   第三部分，716–724

+   寄存器别名，88，90，203

+   字符串字面量，449–450

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">color_graph</samp> 函数，644–646

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> 指令，317，324，328

+   发射，341

+   修复，337

+   通用实数类型，254–255，279–280，308，435

+   比较，78–83。*另见* 指针比较；关系运算符

+   浮点数，317，328

+   无符号，283–286

+   编译器，xxvii

+   阶段，3–4

+   编译器驱动程序，xxviii，7–8

+   命令行选项，8

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp>，169–170

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">--codegen</samp>，8，43

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">--eliminate-dead-stores</samp>，570

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">--eliminate-unreachable-code</samp>，569

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">--fold-constants</samp>，569

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp>，301

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">--lex</samp>，8

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">--optimize</samp>，570

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">--parse</samp>，8

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">--propagate-copies</samp>，569

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">-S</samp>，569

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">--tacky</samp>，38

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">--validate</samp>，109

+   生成汇编文件，569

+   生成目标文件，169

+   链接共享库，301

+   编译器浏览器（Godbolt），xxxvi

+   *编译器：原理、技术与工具*，第二版（Aho 等），611，670

+   完整类型，461–462

+   必需，471–473，477–478，488，491

+   结构体类型，486–487

+   复合赋值运算符，113–114

+   复合初始化器，385

+   汇编，413，418–419

+   AST 定义，393

+   未实现，391–392

+   解析，396

+   静态，404–405，509–511

+   对于结构体，492

+   对于 TACKY，406，410–411，517–518

+   类型检查，403–405，509–511

+   复合字面量，391

+   复合语句，131

+   作为块，132

+   解析，135–136

+   解析变量，136–139

+   由…确定的作用域，131–134

+   对于 TACKY，140

+   具体语法树, 14

+   条件 (<samp class="SANS_TheSansMonoCd_W5Regular_11">?:</samp>) 运算符, 121–124

+   条件表达式, 117

+   分隔符令牌, 118

+   解析, 121–125

+   解析变量, 125–126

+   TACKY 的 for, 127, 479–480

+   类型检查, 256, 368, 467, 470, 476, 508

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 操作数, 459, 476

+   条件跳转指令。*请参见* 跳转指令（汇编）; 跳转指令（TACKY）

+   条件设置指令, 82–83

+   发射, 88–90

+   生成, 85–86

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp>, 85–86

+   条件码, 85–86, 285, 287–288

+   后缀, 90, 291

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">conservative_coalesceable</samp> 函数, 666–667

+   保守合并, 653, 656, 670

+   常量折叠, 561, 573–576

+   与其他优化结合, 569

+   常量传播, 563

+   常量字符串, 425–426

+   在汇编中, 428, 446

+   发射, 449–451

+   在符号表中, 437–439, 441

+   在 TACKY 中, 441–442

+   类型检查, 436, 437–439

+   常量令牌, 8–10

+   字符, 429–431

+   浮动点数, 302–303

+   四舍五入, 300

+   长整数, 247

+   正则表达式, 304

+   无符号整数, 275

+   无符号长整数, 275

+   continue 标签, 155–158

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句, 146–150

+   注释, 150, 151, 152–154

+   解析, 149–150

+   TACKY 的 for, 155–156

+   控制流图, 570, 576–581

+   控制流保护, 5

+   控制表达式， 118–119

+   循环， 144–145

+   类型检查， 352, 470

+   控制结构， 117

+   类型转换等级， 279

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp> 函数， 368, 469, 504–505

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_function_call</samp> 函数， 197–199, 263, 331–333, 538–541

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_unop</samp> 函数， 37–38

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_val</samp> 函数， 198

+   Cooper, Keith， 669–670

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_from_reg</samp> 函数， 543–544

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp> 函数， 541–543

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> 指令， 512–513

+   汇编语言， 532, 548

+   结构体成员访问， 513–514, 516

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令， 75–77, 110

+   汇编语言， 86

+   使用非标量操作数， 531

+   类型转换， 282, 574

+   复制传播， 563–564, 585–602。*另见* 到达拷贝分析

+   额外资源， 611

+   与其他优化结合， 569

+   使用第二部分 TACKY 程序， 599–602

+   重写指令， 598–599, 602

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> 指令， 406–407

+   汇编语言， 414

+   使用非标量操作数， 531–532

+   使用初始化聚合对象， 410–411, 440–441, 517–518

+   结构体成员访问， 514, 516

+   Cordes, Peter， 445

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">cqo</samp> 指令， 269

+   C 标准， xxxvi

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>（地址）运算符应用于解引用指针， 353

+   数组衰减， 386–387

+   基本源字符集, 430

+   C17, xxxvi–xxxvii, 164

+   C23 标准, xxxvi–xxxvii

+   检查的整数运算, 82

+   十进制浮点类型, 300

+   空初始化器, 519

+   空参数列表, 164

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp>, 565

+   已删除的旧式函数定义, 164

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp> 字符常量, 424

+   声明符, 358

+   转义序列, 429

+   求值顺序, 59

+   短路操作符, 72

+   浮点类型, 296

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环，缺少控制表达式, 158

+   实现定义的行为, 245

+   不完全类型, 461

+   链接, 167–168, 210–212

+   左值, 348

+   可观察的行为, 560

+   预处理标记, 303

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句，缺失, 111–112

+   存储持续时间, 212

+   严格别名规则, 352

+   结构体成员声明, 488–489

+   临时生命周期, 508

+   类型转换, 244, 274

+   整数常量的类型, 278

+   类型说明符, 278

+   未定义行为, 80, 91, 107, 112

+   无符号溢出, 285

+   常见算术转换, 254, 279–280

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, 458, 473–475

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.cstring</samp> 指令, 428, 450

+   Cuoq, Pascal, 344

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp> 指令, 320–321, 324, 329

+   字符类型转换, 445

+   修正, 337

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp> 指令, 317–318, 324

+   字符类型转换, 445

+   修正，337

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">D</samp>

+   悬挂 else 歧义，120–121

+   数据流分析，563，584–585

+   额外资源，611

+   活跃性分析，604–609

+   汇编程序，633–636

+   达到副本分析，589–598

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> 操作数，236–238

+   常量，326，339

+   偏移，529，550，551

+   数据段，221

+   戴森，布鲁斯，344

+   死代码消除，564–565，603–609

+   与其他优化结合，569

+   活跃性分析，604–609

+   迭代算法，607–608

+   meet 操作符，606–607

+   传递函数，605–606

+   使用第二部分 TACKY 程序，608–609

+   安全影响，566

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">DeallocateStack</samp> 指令，194–195，198–199，202，264

+   调试器，xxxiv，675–698

+   GDB（GNU 调试器），xxxiv–xxxv，677–687

+   LLDB（LLVM 调试器），xxxv，687–698

+   声明，94，162–163，208–220。*另见* 函数声明；变量声明

+   与定义，214–216

+   隐藏，133

+   链接，166–168，209–212

+   范围，131–134，208–209

+   与语句，98–99

+   结构类型，486–491

+   声明符，356–361

+   摘要，361–363，395–396

+   数组，357–358，394–396

+   在 C 标准中，358

+   函数，357

+   解析，358–361，362–363，394–396

+   指针，356，361

+   递减（<samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>）操作符，31–32，33，113

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> 语句，159

+   度数，638

+   度数 < *k* 规则，638

+   解引用 (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>) 操作符，349–350

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> 操作符应用于结果，353

+   解析，354–355

+   指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 的指针作为操作数，473–475

+   TACKY for，371–374

+   类型检查，364–365

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp> 构造，372–374，408，410，515–517

+   派生类型，354

+   不相交集合数据结构，663–664

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp> 指令，286，287–288

+   修正，290

+   除法 (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>) 操作符，47–48

+   汇编 for，60–63

+   浮点，315，327

+   无符号，286，288

+   解析，50–55

+   TACKY for，58

+   类型检查，254–255，369

+   除法赋值 (<samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp>) 操作符，113

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">divsd</samp> 指令，315

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">DivDouble</samp>，324–325

+   修正，337

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> 语句，144，148–151，152–155，156

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp> 操作符，495。*另见* 结构成员操作符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.double</samp> 指令，312，338–339

+   双精度扩展浮点格式，299

+   双精度浮点格式，297–299

+   双精度舍入误差，306

+   额外资源，344

+   类型转换与，320–323

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp> 指令，309–310

+   汇编 for，317–318

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp> 指令, 309–310

+   汇编语言 for, 318–320

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类型, 295–301。*另见* 浮动点常量；浮动点运算

+   对齐, 336

+   汇编语言类型, 324

+   转换。*参见* 整数类型中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 的转换；<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 的类型转换

+   在函数调用中, 312–315, 329–333

+   表示, 297–299

+   精度, 301

+   四舍五入, 299–301

+   大小, 336

+   谓词, 302, 305, 306–307

+   静态初始化器 for, 308–309, 340

+   类型检查, 308–309

+   Drysdale, David, 21

+   D’Silva, Vijay, 611

+   动态链接器, 202

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">E</samp>

+   EAX 寄存器, 5–6, 40–41, 60–62, 185, 193, 525

+   EBNF。*参见* 扩展巴科斯-诺尔范式表示法

+   EDX 寄存器, 60–64, 185, 525

+   有效类型, 352

+   *计算机系统的元素*, *The*（Nisan 和 Schocken），45

+   ELF（可执行和可链接格式）, 201

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> 子句, 118–121, 126–127

+   悬挂 else 歧义, 120–121

+   *编译器工程学*, 第 2 版（Cooper 和 Torczon），669–670

+   等于 (<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>) 操作符, 71–74

+   汇编语言 for, 85–87

+   浮动点, 317, 328

+   指针比较, 352

+   TACKY for, 75–76, 77

+   类型检查, 254–255, 366–367, 476–477

+   转义序列, 429–431

+   在汇编语言中, 449–450

+   可执行和可链接格式（ELF）, 201

+   可执行栈, 19

+   额外资源, 22

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>函数，16

+   表达式，14

+   转换为 TACKY，38

+   完整，374

+   左值与非左值，348

+   解析，34。*另见* 优先级提升

+   解析变量，107

+   类型检查，251–256

+   结果类型，251

+   无类型，459–460

+   表达式语句，95，98，110

+   扩展巴科斯-诺尔范式（EBNF）符号，15

+   可选序列，101

+   重复序列，100

+   至少一次，225

+   外部链接，167–168，209–211

+   外部变量，208

+   解析，227–229

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>说明符，207，208，210–212，213，214–217

+   在不完整类型的声明上，474，505

+   在标识符解析中，228–229

+   解析，225–226

+   在类型检查器中，230–233

+   额外学分特性，xxxii–xxxiii

+   位运算符，67

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>语句，159

+   复合赋值运算符，113–114

+   自减（<samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>）运算符，113

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>语句，159

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>语句，128

+   自增（<samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>）运算符，113

+   标记语句，128

+   NaN，342–343

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>语句，159

+   联合类型，552–553

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">F</samp>

+   取指令-执行周期，84

+   文件作用域，207–208

+   文件作用域变量声明，208–217

+   解析标识符，227–228

+   类型检查，231–232

+   菲利，托马斯，45

+   浮动点常量

+   汇编，311–312

+   发射，338–339

+   生成，324–327

+   局部标签，312，326–327，339

+   AST 表示，305–306

+   十六进制，302，338–339，345

+   词法分析，302–304

+   十进制常量的舍入，300，306

+   浮点格式，296–299

+   十进制，300

+   双精度扩展精度，299

+   双精度，297–298

+   IEEE 754，296–299

+   单精度，299

+   《浮点指南》（网站），343

+   浮点指令。*参见* 流式 SIMD 扩展指令

+   浮点运算

+   算术运算，296

+   在汇编中，311–312，315–316，327–328

+   舍入行为，301

+   比较

+   在汇编中，317，328

+   与 NaN，299，317，342

+   与负零，298，317

+   使用流式 SIMD 扩展指令，310–312

+   类型转换

+   在汇编中，317–324，328–329，445

+   舍入行为，300–301

+   在 TACKY 中，309–310，440

+   浮点寄存器。*参见* XMM 寄存器

+   浮点值

+   汇编类型，324

+   在函数调用中，312–315，329–333

+   表示，297–299

+   之间的间隙，300–301，322，344

+   归一化浮点数，298

+   精度，301

+   特殊值，298–299

+   无穷大，298

+   NaN，299，342–343

+   负零，298

+   非标准数，298

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> 类型，295，299

+   Fog, Agner，553–554

+   形式语法，14–15

+   模糊性，50，120

+   对于二元表达式，51，52

+   左递归，50

+   对于一元表达式，33，397，465

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 语句，144–145，148–151，152，154，157–158

+   头文件，限制条件，172，220

+   缺少控制表达式的，158

+   前向数据流分析，584

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> 函数，460–461

+   Friedl，Steve，358

+   前端符号表，266。*参见* 编译器内部的符号表

+   完整表达式，374

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> 指令，182–183

+   汇编语言中的。*参见* 汇编中的*函数调用*

+   在活跃性分析中，605–606

+   可选目标，479，482

+   在达到副本分析中，591–592，601–602

+   函数调用，165

+   参数，165

+   在汇编中，161，184–194，197–199

+   带浮动点值的，312–315，329–333

+   带四字节参数，263

+   结构体中的，519–528，532–544

+   带 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 返回类型的，482

+   AST 定义，171

+   解析，172–173

+   解析标识符中的，175–176

+   TACKY 循环，182–183，479

+   类型检查，179，181–182，256

+   函数声明，162–163

+   数组类型中的，390–391

+   AST 定义，171，224，247–248

+   标识符解析中的，174，176–178

+   不完整类型，505

+   链接，166–169，209–212

+   解析，172–173，226–227

+   类型检查，179–181，230–231，257，402–403

+   带 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 参数的，466

+   函数定义，162–163

+   在汇编中，195

+   访问函数参数，195–197

+   分配栈空间，200

+   转换为 TACKY，110–111，182–183

+   嵌套，163

+   旧式，164

+   函数指针，164，359–361，364

+   函数序言和尾声，26–27，29–31

+   发射，43–44

+   函数，161–169

+   参数，165

+   调用约定，161，184–194，312–315，519–528

+   声明符，357

+   参数，162–163，165，177

+   类型，178–179，247–248

+   可变参数，191

+   带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 返回类型，458，469–470，479，482

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">G</samp>

+   GAS（GNU 汇编器），268，338

+   GCC，xxxiv–xxxv，4–5

+   浮点数支持，296–297，317–318，344

+   实现定义的类型转换，245

+   安装，xxxiv–xxxv

+   语言扩展，395，401，471

+   窄参数的处理，445

+   优化，27，558–559

+   未定义行为检测器，672

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 的处理，474–475

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> 命令，4–5

+   使用 Clang 调用，xxxv，4

+   GDB（GNU 调试器）

+   调试汇编代码，677–687

+   安装，xxxiv–xxxv

+   通用寄存器，311

+   George，Lal，670

+   George 测试，659–663

+   其他资源，670

+   限制，661–663

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp> 指令，370–372，374

+   别名分析和，599–601

+   汇编，376

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp> 函数，366–368，468

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_type</samp> 函数，254–255，280，308，435

+   Ghuloum, Abdulaziz, xxvi

+   Gibbons, Phillip, 611，670

+   全局偏移表（GOT），223

+   全局符号，5，168–169

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl</samp> 指令，5，20，168–169，221，238

+   GNU 汇编器（GAS），268，338

+   Goldberg, David, 343

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> 语句，128

+   图着色，622–646

+   算法，638–646

+   度数 < *k* 规则，638

+   乐观着色，669

+   溢出寄存器，627–630，642–644，646

+   大于 (<samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>) 操作符，71–74

+   汇编，见 85–87

+   浮点，317，328

+   无符号，287–288

+   指针比较，389–390

+   TACKY for，75–76，77

+   类型检查，254–255，401

+   大于或等于 (<samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>) 操作符，71–74

+   汇编，见 85–87

+   浮点，317，328

+   无符号，287–288

+   指针比较，389–390

+   TACKY for，75–76，77

+   类型检查，254–255，401

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">H</samp>

+   Hailperin, Max, 670

+   “Hello, World!” 程序，204，451–453

+   十六进制浮点常量，302，338–339，345

+   Hilfinger, Paul, 611

+   Hyde, Randall, 199

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">I</samp>

+   标识符解析，174–178，227–229，364。 *另见* 变量解析

+   从变量解析重命名，174

+   结构标签，498–500

+   标识符，8

+   自动生成, 37–38, 105–106

+   词法分析, 8–10

+   连接, 167–169, 209–212

+   范围, 131–134, 208–209

+   结构标签, 486–488, 489–490

+   在符号表中, 179–181, 229–233, 257–258

+   类型, 178–179

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> 指令, 60–65, 262

+   生成, 66, 270

+   IEEE 754 标准, 296–299

+   额外资源, 343–344

+   双精度格式, 297–299

+   浮点格式, 296–299

+   舍入模式, 299

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句, 117–121

+   AST 定义, 118–119

+   解析, 118–121

+   悬挂的 else 歧义, 120–121

+   解析变量, 125–126

+   TACKY 的, 126–127

+   立即数, 18, 268

+   作为函数参数, 198–199

+   推断大小, 266

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm</samp> 操作数, 18–20

+   实现定义行为, 245–246

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 的符号性, 424

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">ptrdiff_t</samp>, 400

+   舍入行为, 307

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>, 460

+   源字符集, 430

+   类型转换, 245, 352

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp> 指令, 60, 62–63

+   生成, 66, 270

+   修正, 64–65, 268

+   不完整类型, 461–462

+   在后端符号表中, 530, 546

+   在函数声明中, 505

+   指针指向, 461–462, 471–472, 473, 505

+   结构类型, 486–487, 505–506

+   类型检查, 471–473, 505–506

+   增量（<samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>）运算符，113

+   不确定顺序的求值，58–59，82

+   索引寻址，412

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">索引</samp> 操作数，412–415

+   发射，419

+   初始化器，94。*另见* 复合初始化器；静态初始化器

+   数组，385，425，440

+   字符串字面量，425–426，437–438，440–441

+   无效的，220

+   解析标识符，105–106

+   结构类型，492

+   针对的 TACKY，110，440–441

+   在其自身中使用变量，106–107

+   指令修复阶段，42–43

+   临时寄存器，42，64–65，325，337

+   指令指针（IP），84。*另见* RIP 寄存器

+   指令寄存器，84

+   整型类，519

+   整型常量，6，8。*另见* 字符常量

+   解析，250–251，278

+   正则表达式，304

+   在抽象语法树中的表示，248，276

+   针对的标记，8，247，275，304

+   整型溢出，78–82

+   整型提升，424，435

+   整型

+   公共实型，254–255，279–280

+   之间的转换，244–245，274–275，279–280

+   在汇编中，244–245，263，286–288，443–444

+   转换等级，279

+   在 TACKY 中，259–260，281–283

+   转换为和从 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类型

+   在汇编中，317–324，328–329，445

+   舍入行为，300–301

+   在 TACKY 中，309–310，440

+   解析说明符，249–250，277–278

+   英特尔 64 软件开发者手册，xxxvi，344

+   英特尔语法，6

+   交互设备，560

+   中间表示（IRs），35–36

+   控制流图，570，576–581

+   内部链接，209–212

+   跨过程优化，570

+   内部过程优化，570

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp> 指令，309–310

+   汇编，320

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型

+   对齐，246

+   大小，244

+   静态初始化器，257

+   指令指针（IP），84

+   迭代寄存器合并，663

+   迭代算法，585

+   拷贝传播，593–599

+   死存储消除，607–608

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">J</samp>

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">je</samp> 指令，84–85

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">JmpCC</samp> 指令，85–86，89

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> 指令，83–84，85

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> 指令，85

+   乔尔·琼斯，21

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp> 指令，75–76

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> 指令，75–76

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> 指令，75–76

+   跳转指令（汇编），83–85

+   在汇编生成中，85–87

+   条件，84–85

+   发出，89

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">je</samp>，84–85

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>，83–84，85

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">JmpCC</samp>，85–86，89

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp>，85

+   无条件跳转指令，83

+   跳转指令（TACKY），75–77，126–127，155–158

+   汇编，转换为，86–87，328

+   条件，75–76

+   常量折叠，561，573–576

+   移除无用的，582–583

+   无条件跳转指令，75–76

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">K</samp>

+   *k*-可着色图，622，624–625，627

+   Kell，Stephen，474

+   关键字，9–10

+   被杀死的副本，587

+   被杀死的变量，603

+   Korn，Jeff，22

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">L</samp>

+   带标签语句，128

+   带标签的语句（汇编），5，83–87

+   发射，88–89

+   本地，89，326–327，450

+   对于静态变量，221–222

+   标签（TACKY），75–77，86，126–127，155–158

+   避免命名冲突，77

+   移除无用的，582–583

+   懒绑定，202

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp>（加载有效地址）指令，376–379

+   左结合操作，50，53

+   左移（<samp class="SANS_TheSansMonoCd_W5Regular_11"><<</samp>）运算符，67

+   左移赋值（<samp class="SANS_TheSansMonoCd_W5Regular_11"><<</samp>）运算符，67

+   小于（<samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>）运算符，71–74

+   汇编语言 for，85–87

+   浮点，317，328

+   无符号，287–288

+   指针比较，389–390

+   TACKY for，75–76，77

+   类型检查，254–255，401

+   小于或等于（<samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>）运算符，71–74

+   汇编语言 for，85–87

+   浮点，317，328

+   无符号，287–288

+   指针比较，389–390

+   TACKY for，75–76，77

+   类型检查，254–255，401

+   Levien，Raph，91

+   词法分析器，4，8–10。*另见* 标记

+   对象的生命周期，212–213，461，508

+   行标记，7

+   连接，166–168，209–212

+   在汇编中，168–169，220–221

+   冲突，176，217–219，228–229，230–232

+   外部，167–168，209–211

+   标识符解析和，175–177，227–229

+   内部，209–212

+   类型检查和，229–233

+   链接器，xxviii，5–6

+   额外资源，21

+   动态，202

+   和标识符链接，168–169

+   调用，7

+   重定位，6

+   和共享库，202，301

+   符号解析，6，174

+   符号，5

+   符号表，5，89

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.literal8</samp> 指令，312

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.literal16</samp> 指令，312

+   小端，86

+   活跃性分析，584

+   汇编程序，633–636

+   meet 操作符，633–634

+   传输函数，634–636

+   用于死存储消除，604–609

+   迭代算法，607–608

+   meet 操作符，606–607

+   传输函数，605–606

+   活跃范围，625–626

+   Linux，xxxiv

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp> 指令，221

+   本地标签前缀，89

+   程序链接表（PLT），201

+   只读数据段，339

+   设置指令，xxxiv–xxxv

+   LLDB，xxxv，687–698

+   LLVM 编译器框架，36，599

+   汇编器，268，338

+   Clang，xxxiv–xxxv，4

+   复制传播，611

+   中间表示，599

+   LLDB，xxxv，687–698

+   加载有效地址（<samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp>）指令，376–379

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> 指令，370–371，374–375

+   汇编用于，376，531

+   局部标签，89

+   用于汇编常量，312，326–327，339，450

+   局部变量，93–95。*另见* 变量声明

+   赋值，94–95，107，110

+   声明，94，98，105–106，110

+   初始化器，94，106–107，110

+   链接，167–168，209

+   解析，104–108，136–139，178，228–229

+   在堆栈上，29

+   存储持续时间，214

+   未定义行为，96

+   逻辑运算符，71。*另见各个运算符的名称*

+   解析，73–75

+   优先级值，74

+   短路运算，72

+   TACKY for，75–77，259

+   用于的标记，72

+   类型检查，255，369，470

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.long</samp> 指令，221

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> 类型，295，299

+   长整型，243。*另见* <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 类型

+   在汇编中，244–246，261–264

+   汇编类型，261

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> 类型，273–281

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 关键字，247

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 类型，243

+   对齐，246

+   常量的，247–248，250–251，254

+   转换，244–245，274–275

+   大小，244

+   静态初始化器，257–258

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp> 汇编类型，261–262

+   长字，6，244，267，270

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> 后缀，60

+   循环，144–148

+   分析, 638, 670

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp>, 144–146, 148–151, 154, 156

+   对溢出成本的影响, 638

+   封闭循环, 146, 151, 153

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>, 144–145, 148–151, 152, 154, 157–158

+   标记, 150, 152–155

+   解析中的变量, 151–152

+   TACKY for, 155–158

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>, 144, 148–150, 151–155, 157

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp> 前缀, 89。*另见* 局部标签

+   l 值, 95, 348, 349–350

+   转换, 348, 350

+   字符串字面量, 425, 436

+   结构成员, 491, 507–508

+   在 TACKY 中, 371–374, 515–517

+   验证, 107, 364, 365, 399, 436, 507–508

+   和 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, 474–475

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">M</samp>

+   机器相关优化, 558

+   与机器无关的优化, 557–558

+   常量折叠, 561, 573–576

+   复制传播, 563–564, 585–602

+   死存储消除, 564–565, 603–609

+   不可达代码消除, 561–562, 581–584

+   机器指令, 5–6

+   Mach-O 文件格式, 201

+   macOS, xxxiv

+   局部标签前缀, 89

+   平台特定指令, 221, 238–239, 312, 339, 428, 450

+   用户定义名称的前缀, 19, 201, 238

+   设置说明, xxxiv–xxxv

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数，4，6，169

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">make_tacky_variable</samp> 函数，261

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">make_temporary</samp> 函数，37–38

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 函数，460

+   尾数，297

+   meet 操作符，585

+   活跃性分析，606–607

+   汇编程序，633–634

+   复制分析，592–593

+   成员访问操作符。*参见* 结构成员操作符；结构指针操作符

+   MEMORY 类，519

+   内存管理函数，457–458，460–461

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>，461

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>，461

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>，460–461

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>，460

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>，461

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> 操作数，375–379

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令，5–6，18，261–262

+   发射，20

+   修正，42，268，270

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp> 指令，311–312

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp> 指令，244–245，261，263，444

+   发射，269，450–451

+   修正，267

+   符号扩展，263

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp> 指令，287–289，443–444

+   转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，329，445

+   发射，450–451

+   修正，290，449

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp> 指令，443，449

+   斯蒂芬·马许尼克（Steven Muchnick），669

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">mulsd</samp> 指令，315

+   发射，参见 341–342

+   修复，参见 337

+   多维数组，参见 384–385，386–389，393

+   乘法(<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>)运算符，参见 47–48

+   汇编，参见 60，62–63

+   浮动点，参见 315，327

+   解析，参见 50–55

+   TACKY for, 58

+   类型检查，参见 254–255，369

+   乘法赋值(<samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp>)运算符，参见 113

+   Myers, Joseph，参见 218

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">N</samp>

+   NaN（非数值），参见 299，342–343

+   比较，参见 299，317，342

+   额外学分，参见 342

+   安静，参见 299

+   信号，参见 299

+   否定(<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>)运算符，参见 26

+   汇编，参见 26–27，40–41

+   浮动点，参见 315–316，327–328

+   解析，参见 33–34

+   TACKY for, 36–38

+   标记，参见 31–32

+   类型检查，参见 254，369，435

+   负无穷，参见 298

+   负零，参见 298，317，326，340

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp> 指令，参见 26–27，40–41，44

+   发射，参见 44，270

+   嵌套函数定义，参见 163

+   Nisan, Noam，参见 45

+   非标量类型，参见 470–471

+   非终结符号，参见 15

+   NOT (<samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>)运算符，参见 71–74

+   汇编，参见 86，328

+   TACKY for, 75–76, 77

+   类型检查，参见 254，369，470

+   不等于(<samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>)运算符，参见 71–74

+   汇编，参见 85–87

+   浮动点，参见 317，328

+   指针比较，参见 352

+   TACKY for, 75–76, 77

+   类型检查, 254–255, 366–367

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> 指令, 26–27, 40–41

+   发射, 44, 270

+   空指针, 351–352

+   比较, 352

+   常量, 351, 366–368, 401

+   作为静态初始化器, 369

+   空语句, 98, 110

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">O</samp>

+   对象代码, xxviii

+   对象文件, xxviii, 5

+   生成, 169–170

+   部分, 5

+   BSS, 222, 340, 418

+   数据, 221–222

+   只读数据, 311–312, 339

+   文本, 5

+   对象, 348

+   生命周期, 212–213, 461, 508

+   可观察行为, 558–560

+   OF. *参见* 溢出标志

+   乐观着色, 669

+   优化管道, 570–573, 600–601

+   优化。*另见* 与机器无关的优化*和单个优化条目*

+   常量折叠, 561, 573–576

+   复制传播, 563–564, 585–602

+   死存储消除, 564–565, 603–609

+   跨过程, 570

+   过程内, 570

+   机器相关, 558

+   安全性, 558

+   安全影响, 564–565

+   不可达代码消除, 561–562, 581–584

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">optimize</samp> 函数, 570–573, 601

+   终止, 572–573

+   或（<samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>）运算符, 71–77

+   短路, 72

+   针对的 TACKY, 75–77, 259

+   类型检查, 255, 470

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp> 指令, 323–325, 337, 341

+   溢出, 78–82

+   溢出标志（OF）, 78–80, 83

+   不适用，284–285，317

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">P</samp>

+   打包操作数，310，316

+   参数传递寄存器，185，312

+   参数，162–163，165，177，195–197

+   奇偶标志（PF），342

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> 函数，16，34，51–57，101–102，124

+   解析器生成器，11

+   解析器，4，10–17。*参见* 递归下降解析

+   手写，11

+   优先级爬升，51–57

+   预测，16

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_type</samp> 函数，249–250，277，307，433，466

+   模式匹配，xxxiii–xxxiv

+   Payer, Mathias，611

+   PF（奇偶标志），342

+   阶段排序问题，573

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand</samp> 构造，372–374

+   PLT（过程链接表），201–202

+   指针分析，601

+   指针算术，387–390

+   加法，387–390

+   汇编，414–415

+   与下标操作符的关系，387–389

+   减法，388–390

+   TACKY for，406–408

+   类型检查，400–401，472

+   未定义行为，388，390

+   指针比较，352–353，389–390

+   汇编，377，415

+   类型检查，366–367，401

+   TACKY for，375，408

+   指针，347，349–353。*参见* 空指针

+   转换到与从，351–352，460

+   指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 的指针，467–469

+   TACKY for，375

+   类型检查，367–369，467–469

+   声明符，356，361

+   解引用, 349–350

+   到不完整类型, 461–462, 471–472, 473, 505

+   对其的操作, 349–353

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">指针初始化</samp>, 437, 450

+   引用类型, 354

+   静态初始化器, 369–370, 428–429, 437, 438–439

+   类型检查, 364–370, 400–402, 467–469, 471–472

+   类型

+   AST 定义, 354

+   解析, 356–364

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">弹出</samp>指令, 27–28, 30–31, 620–621, 648

+   发射, 44, 649

+   正无穷大, 298

+   后缀运算符, 113, 396–397, 498

+   后序遍历, 49

+   优先级提升, 47, 51–57

+   额外资源, 68

+   与递归下降解析结合, 52–53

+   示例, 55–57

+   伪代码, 54

+   与赋值运算符, 102

+   使用条件运算符, 124

+   右结合运算符, 101–102

+   优先级值

+   算术运算符, 55

+   赋值运算符, 103

+   条件运算符, 123

+   逻辑运算符, 74

+   关系运算符, 74

+   预着色寄存器干扰图, 625

+   预测分析器, 16

+   前缀运算符, 113, 396

+   预处理器, xxviii, 7

+   格式化打印机, 17

+   程序链接表 (PLT), 201–202

+   产生式规则, 15

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">伪内存</samp>操作数, 412–414

+   替换, 417–418

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">伪</samp>操作数, 40–42

+   伪寄存器, 40–41

+   替换, 42, 237, 267

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">推送</samp>指令, 27–30, 194–195

+   发射， 43， 203

+   修复， 378–379

+   传递参数， 188–189， 198–199， 263， 332

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp> 函数， 204

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> 函数， 451–453

+   Python， xxxiv

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Q</samp>

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp> 指令， 246， 270， 428， 450

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> 汇编类型， 261–262

+   四字组， 6

+   参数， 263

+   指令， 244， 261–262

+   后缀， 6， 269

+   伪寄存器， 267

+   静态，246

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">R</samp>

+   RAX 寄存器， 5–6， 40–41， 60–62， 185， 193， 525

+   RBP 寄存器， 29–30， 375

+   RDX 寄存器， 60–64， 185， 525

+   达到拷贝， 589

+   达到拷贝分析， 584， 589–599

+   迭代算法， 593–599

+   meet 操作符， 592–593

+   传输函数， 589–592， 601–602

+   只读数据区， 311–312， 339

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> 函数， 461

+   递归下降解析， 15–17

+   带回溯， 17

+   二元运算， 50–51

+   与优先级提升结合， 52–53

+   处理悬挂的 else 歧义， 120–121

+   声明符， 359

+   优先级和结合性问题， 50–51

+   雷根，里克， 344–345

+   雷吉尔，约翰， 91

+   寄存器分配， 613–619。*参见* 溢出

+   附加资源， 669–670

+   图着色， 622–646

+   算法， 638–646

+   degree < *k* 规则， 638

+   处理多种类型， 631， 637

+   寄存器合并，618–619，651–668

+   迭代，663

+   顶层算法，630

+   寄存器合并，614，618–619，651–653，663–667

+   保守合并，653，656，670

+   布里格斯测试，657–659，661–663，666–667，669–670

+   乔治测试，659–663，666–667，670

+   迭代，663

+   更新图表时，653–656，663，666

+   寄存器干扰图，622–626

+   建筑，631–637

+   着色，622–625，638–646

+   预着色，625

+   检测干扰，623–624，626–627

+   更新，653–656，666

+   寄存器，5–6

+   别名，40

+   汇编 AST 定义，18，40，62，620–621

+   参数传递寄存器，195

+   RBP 寄存器，375

+   RSP 寄存器，264

+   XMM 寄存器，325

+   调用者保存和被调用者保存，185，620–621，645–646，648–649

+   通用，311

+   指令，84

+   参数传递，185，195，312

+   XMM，311–312，316，325

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp> 操作数，40

+   关系运算符，71。*另见各个运算符名称*

+   汇编，85–88

+   浮动点，317，328

+   无符号，285，287–288

+   解析，73–75

+   优先级值，74

+   指针操作数，352，389–390

+   TACKY，75–76

+   令牌，72

+   类型检查，254–255，366–367，401，476–477

+   余数（<samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>）运算符, 47–48

+   汇编, 60–63

+   无符号, 288

+   解析, 50–55

+   TACKY for, 58

+   类型检查, 254–255, 308, 369

+   余数赋值（<samp class="SANS_TheSansMonoCd_W5Regular_11">%=</samp>）运算符, 113

+   替换伪寄存器, 42

+   不同类型, 267

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> 操作数, 417–418

+   静态存储周期, 237

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> 指令, 6, 18

+   发射, 20, 44

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句, 4

+   汇编, 18, 333, 482, 545–546

+   AST 定义, 13–14

+   缺失, 111–113, 458

+   解析, 14–17

+   无返回值, 458, 469–470, 479, 482

+   TACKY for, 36–38, 479

+   类型检查, 256–257, 469–470

+   返回值, 4–6, 14

+   缺失, 458, 469–470, 479, 482

+   分类, 537–538. *另见* <samp class="SANS_TheSansMonoCd_W5Regular_11">classify _return_value</samp> 函数

+   浮点类型, 312–313, 333

+   结构类型, 525–528, 537–541, 545–546

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">rewrite_coalesced</samp> 函数, 667–668

+   RFLAGS 寄存器, 78

+   右结合运算符, 50, 101–102, 123–124

+   右移（<samp class="SANS_TheSansMonoCd_W5Regular_11">>></samp>）运算符, 67

+   右移赋值（<samp class="SANS_TheSansMonoCd_W5Regular_11">>>=</samp>）运算符, 113

+   RIP 寄存器, 83–84, 189–190, 222

+   RIP 相对寻址，222，223，311，376，529

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">数据</samp>操作数，236–238

+   Ritchie, Dennis，390

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.rodata</samp>指令，311–312，339，428，450

+   Rosetta 2，xxxv

+   四舍五入模式，299，320

+   四舍五入至最近偶数，299，321，575

+   四舍五入至奇数，322–324

+   RSP 寄存器，27–30，43–44，185，264

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">S</samp>

+   优化的安全性，558

+   标量类型，384，470–471

+   Schocken, Shimon，45

+   作用域，131–134，208–209

+   块作用域，208

+   复合语句的确定，131–134

+   文件作用域，207–208

+   与存储持续时间的比较，213

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.section .rodata</samp>指令，311–312

+   语义分析，93，103–104

+   标识符解析（即变量解析），104–109，174–178，227–229

+   循环标记，150，152–155

+   类型检查，178–182，251–258

+   Serra, Christopher，22

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp>指令，85–87

+   发射，89–90

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">set_up_parameters</samp>函数，544–545

+   SF（符号标志），78–80，83

+   左移（<samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>）指令，529–530，541–543，551

+   右移（<samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>）指令，320–321，323–325，529

+   双操作数形式，529，543，551

+   短路运算符，72，76–77

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> 类型，423–424

+   有符号整数，243

+   溢出，78–82

+   表示，26，61，244

+   类型转换，244–246，274–275

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> 关键字，275

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp> 指令，259–260，263，282–283

+   符号扩展，61，244–245，275

+   在汇编中，263，444

+   在 TACKY 中， 259–260，282–283

+   符号标志（SF），78–80，83

+   重要程度，638

+   单精度格式，299

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 运算符，458，462–466，471，477–478，480–481

+   Song, Dawn，611

+   源字符集，430

+   源文件，xxviii，7–8，208

+   特殊字符，429，450

+   特殊序列（EBNF），15

+   溢出，616，627–630，642–644，646

+   候选，642

+   溢出代码，616，620

+   溢出成本，630–631，638，642，644–645

+   SSA（静态单一赋值）形式，672

+   SSE。*参见* 流式 SIMD 扩展指令

+   SSE 类，519

+   堆栈，19，27–31

+   对齐，185，197–198，648–649

+   可执行文件，19

+   附加资源，22

+   帧，29–31

+   分配，42，197–199，200–201

+   指针，27

+   堆栈帧，29–31

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> 操作数，40，42，44

+   被替换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> 操作数，375

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp> 构造（汇编），324，326，336，446

+   发射，340

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp> 构造（TACKY），442，446

+   静态初始化器，213–214。*另见* <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> 构造

+   在汇编中，221–222，238–239

+   对于字符，436

+   复合，404–405

+   在汇编中，418–419

+   对于结构体，509–511

+   对于 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类型，308–309，340

+   对于长整型，246，257–258，270

+   对于指针，369–370，428–429，437，438–439

+   空指针作为，369

+   字符串作为，437–439

+   在符号表中，257

+   类型检查，257–258

+   对于无符号整数，280–281

+   静态单一赋值（SSA）形式，672

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> 说明符，208，209–211，213，216–217，230–233

+   静态存储持续时间，213–214。*另见* 静态变量

+   使用替代寄存器，237

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> 构造（汇编），235–236，263–264，413

+   发射，238–239

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> 构造（TACKY），234–235，258–259，406

+   静态变量，213–214

+   汇编，221–222，235–239，246

+   初始化，213–214。*另见* 静态初始化器

+   在 TACKY 中，234–235

+   类型检查，229–230，231–233

+   状态标志，78–80

+   进位，284–285，317

+   溢出，78–80，83

+   奇偶性，342

+   符号, 78–80, 83  

+   零, 78–80, 83  

+   Sterbenz 引理, 319  

+   存储类别说明符, 207–208, 223  

+   效果, 209–217  

+   解析, 225–226  

+   存储持续时间, 207, 212–213  

+   已分配, 213, 461  

+   在汇编中, 221–222  

+   自动, 212–213, 217  

+   vs. 范围, 213  

+   静态, 213–214, 237  

+   在符号表中, 229–230  

+   线程, 213  

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> 指令, 370–374

+   及活跃性分析, 609  

+   及到达副本分析, 599–600, 601–602  

+   流式 SIMD 扩展 (SSE) 指令, 310–312  

+   算术, 315–316  

+   比较, 317  

+   类型转换, 317, 320  

+   严格别名规则, 352  

+   字符串字面量, 425–426  

+   作为数组初始化器, 425, 426  

+   TACKY for, 440–441  

+   类型检查, 437–438  

+   在汇编中, 426–429  

+   AST 定义, 324  

+   发射, 449–450  

+   指定常量字符串, 425–426  

+   TACKY for, 441–442  

+   类型检查, 436, 438–439  

+   词法分析, 429–431  

+   左值, 425, 436  

+   解析, 433  

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> 关键字, 494  

+   结构成员 (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>) 运算符, 491, 495  

+   解析, 497–498  

+   TACKY for, 513–517  

+   for 词法单元, 494  

+   类型检查, 506–508  

+   结构体指针 (<samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>) 运算符, 491, 495  

+   解析, 497–498  

+   TACKY for, 514–515, 517  

+   for 词法单元, 494  

+   类型检查, 506–507  

+   结构标签, 486–488, 489–490  

+   解析， 498–500

+   结构体类型

+   分类， 519–522， 533–534

+   完整， 486–487， 503

+   复制， 531–532

+   声明， 486–491

+   定义， 486

+   在类型表中， 501–502

+   验证， 501

+   在函数调用中， 519–528， 532–546

+   不完整， 486–487， 490， 503， 505–506

+   初始化器， 492

+   TACKY for， 517–518

+   类型检查， 509–511

+   内存中的布局， 492–494

+   未实现， 490–491

+   操作， 491–492。 *参见* 结构体成员操作符； 结构体指针操作符

+   填充， 493， 510–511， 518–519

+   返回值， 525–528， 545–546

+   格式化符， 498

+   标签， 486–488， 489–490

+   解析， 498–500

+   类型检查， 500–511

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> 指令， 29–30， 60， 62–63

+   发射， 66， 270

+   修复， 64， 268

+   非规格化数， 298

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> 构造， 515–517

+   下标（<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>）操作符， 389

+   AST 定义， 393

+   生成， 408

+   解析， 396–397

+   TACKY for， 408–410

+   类型检查， 399， 401–402， 471–472

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">subsd</samp> 指令， 315

+   修复， 337

+   减法（<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>）操作符， 47–48

+   汇编， 60， 62–63

+   浮点数， 315， 327

+   解析， 50–55

+   指针减法， 388–390

+   TACKY for， 406–408

+   类型检查， 400–401， 472

+   TACKY for， 58

+   类型检查，254–255

+   减法赋值（<samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>）操作符，113

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句，159

+   符号（汇编），5

+   全局与局部，168–169

+   符号表，5，89

+   编译器内部的符号表，174–175，179–181。*另见* 后端符号表

+   从中生成 TACKY 顶级定义，234–235，442

+   标识符属性，229–233，257–258，438

+   重命名为前端符号表，266

+   临时变量，260–261

+   临时定义，229–230，235

+   对象文件中的符号表，5，89

+   System V x64 ABI，xxxvi，184。*另见* System V x64 调用约定

+   数组的对齐，415

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>，符号的有符号性，424

+   Clang 对此的违规，444–445

+   浮动点格式，296，297

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>

+   对齐，246

+   大小，244

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>，定义，460

+   结构体的大小和对齐，493

+   System V x64 调用约定，184–194

+   其他资源，344，553–554

+   值的分类，519

+   浮动点值，312–315

+   狭义参数，444–445

+   结构体，519–528

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">T</samp>

+   TAC（三地址码），35–36

+   TACKY，36–38

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp> 操作数，36

+   生成，37–38

+   地址（<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>）操作符，370–372，374，514，516–517

+   赋值表达式，110，371–374，516

+   二元表达式，58

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句，155–156

+   类型转换表达式，259–260，281–283，309–310，375，440，479

+   复合初始化器，406，410–411，517–518

+   复合语句，140

+   条件表达式，127，479–480

+   解引用（<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>）运算符，371–374

+   函数调用，182–183，479

+   函数定义，182–183

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句，126–127

+   循环，155–158

+   指针运算，406–408

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句，36–38，479

+   短路运算符，76–77

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 运算符，480–481

+   静态变量，234–235

+   结构体成员访问运算符，513–517

+   下标（<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>）运算符，408

+   一元表达式，37–38

+   指令，42–43

+   lvalue 转换，371–374，515–517

+   临时变量，36–38，260–261

+   顶层常量，442

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> 操作数，36

+   Taylor, Ian Lance，21，22

+   临时生命周期，508

+   临时变量，36–38

+   命名，38

+   在栈上，29

+   符号表中，260–261

+   暂定定义，215–216

+   转换为 TACKY，235

+   在符号表中，229–230，235，411

+   类型检查，231–232

+   未定义行为，219–220

+   终结符，15

+   三元运算符，121。*另见* 条件表达式

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.text</samp> 指令，238

+   文字段，5，283

+   线程存储持续时间，213

+   三地址码 (TAC)，35–36。*另见* TACKY

+   标记，3，8–10

+   常量，8–10

+   字符，429

+   浮点数，302–304

+   整数，8，247，275，304

+   标识符，8–10

+   字符串字面量，429

+   托尔宗，琳达，669–670

+   转换函数，584–585

+   活跃性分析，605–606

+   汇编代码，634–636

+   与第二部分类型一起使用，608–609

+   可达副本分析，589–592

+   与第二部分类型一起使用，601–602

+   翻译单元，167，208

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">截断</samp>指令，259–260，263，282

+   二补数，26，45，78，274

+   类型检查，178–182，251–258

+   数组，398–399，402–405，471，472–473

+   复合初始化器，403–405，509–511

+   声明，179–181，230–233，257–258，402–403

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，308–309

+   表达式，253–256

+   算术运算符，254–255，369，435，476–477

+   赋值，256，368，399

+   按位取反（<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>）运算符，308，369，435

+   类型转换，254，369，402，471，505

+   条件，256，368，467，470，476，508

+   逻辑运算符，254–255，470

+   指针运算，400–401，472

+   关系运算符, 254–255, 366–367, 401, 476–477

+   余数 (<samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>) 运算符, 254–255, 308, 369

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 运算符, 477–478

+   结构成员访问运算符, 506–507

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">subscript</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>) 运算符<samp class="SANS_TheSansMonoCd_W5Regular_11">, 399, 401–402</samp>, 471–472

+   文件作用域变量声明, 231–232

+   函数调用, 179, 181–182, 256

+   不完整类型, 471–473, 505–506

+   指针, 364–370, 400–402, 467–469, 471–472

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句, 256–257, 469–470

+   字符串字面量, 436–439

+   结构类型, 500–511

+   类型错误, 174

+   类型转换

+   在汇编中, 244–245, 317–324

+   浮点数, 317–324, 328–329

+   符号扩展, 244–245, 444

+   截断, 245, 263, 444

+   零扩展, 286–288, 443–444

+   字符, 443–445

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, 317–324

+   从字符类型转换, 445

+   四舍五入行为, 300–301

+   未定义, 308, 371

+   实现定义, 245, 352

+   隐式, 254–255, 279, 351, 467–469

+   像赋值那样, 368, 468–469, 504–505

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Cast</samp> 表达式表示, 255

+   常规算术转换, 254–255, 279–280, 308, 435

+   整数, 244–245, 274–275

+   指针, 351–352, 460

+   在 TACKY 中, 259–260, 281–283, 309–310

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>, 259–260

+   到和从 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, 309–310

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>, 259–260

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>, 259–260

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp>, 281–283

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> 声明, 108–109

+   类型错误, 174. *另见* 类型检查

+   类型名称, 361–363, 462, 465–466

+   类型, 178–179. *另见* 字符类型; 整数类型; <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 类型

+   聚合, 384

+   算术, 347, 476–477

+   数组, 384–392

+   派生, 354

+   在 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> 节点上, 252–253

+   浮点数, 295–299

+   函数, 178–179, 247–248

+   不完整, 461–462

+   非标量, 470–471

+   指针, 347, 349–353

+   标量, 384, 470–471

+   类型说明符

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, 429

+   字符, 433

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, 302, 306–307

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, 8

+   整数, 249–250, 277–278

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, 247

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>, 275

+   结构体, 498

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>, 275

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, 8

+   类型表, 500–502, 503–504, 506–507, 509–511, 515, 517–518

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">U</samp>

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp> 指令，309–310

+   汇编，320–324

+   乌尔曼，杰弗里，611

+   一元表达式，25–27，31–38

+   AST 定义，33

+   解析，33–34

+   格式文法，33，397，465

+   TACKY for，36–38

+   类型检查，254

+   一元运算符。*参见* 一元表达式 *和单个运算符名称*

+   无条件跳转指令。*参见* 跳转指令（汇编）；跳转指令（TACKY）

+   未声明的变量，104，107，134

+   未定义行为，80–82

+   额外资源，91

+   冲突链接，218–219

+   安全处理，672

+   整数溢出，80–82

+   缺少 <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句，111–112

+   修改对象，425–426，508

+   越界类型转换，308，317

+   指针运算，388，390

+   指针解引用，351–352

+   临时定义，219–220

+   变量访问，96，106–107

+   未定义行为检测器，672

+   联合类型，552–553

+   通用字符名称，10

+   不可达代码消除，561–562，581–584

+   与其他优化相结合，569

+   无序计算，58–59，82

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> 类型，424

+   无符号整数，273–289

+   在汇编中，283–289

+   汇编类型，287

+   无符号比较，283–285，287–288

+   无符号除法，286，288

+   常量，275–278

+   正则表达式，304

+   静态初始化器，280–281

+   类型转换，274–275，279–280，282–283

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> 类型，273–281

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> 类型，273–281

+   环绕，79，285–286，575

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> 关键字，275

+   常规算术转换，254–255，279–280，308，435

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">V</samp>

+   值，348

+   变量声明，94–95，208–220

+   数组类型，384–385

+   AST 定义，98，171

+   连接，209–212

+   解析，100–101，224–227

+   解析标识符，105–106，138–139，227–229

+   范围，131–134，208–209

+   块范围，208

+   文件范围，208

+   存储持续时间，212–214

+   类型检查，179–180，231–233，257–258

+   变量解析，104–108，136–139，227–229

+   条件表达式，125–126

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句，125–126

+   循环，151–152

+   多重范围，136–139

+   重命名标识符解析，174

+   变量，93–97，208–222。*另见* 静态变量

+   别名，599–602，609，637

+   自动，208

+   外部，208，227–229

+   活跃，603

+   局部，93–95

+   解析，104–107，227–229

+   范围，131–134，208–209

+   在 TACKY 中，36–38，110

+   临时，36–38，260–261

+   类型检查，181，253

+   变量解析，107

+   可变参数函数，191

+   void 表达式，459

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 关键字，8–9

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">as 参数列表，162，459，466–467</samp>

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 类型，458–460

+   强制转换到，459，471，479

+   使用条件表达式，459，476，479–480

+   在 C 标准中，458，474–475

+   返回函数，458，469–470，479，482

+   指针，460–461，475

+   转换到和从，467–469

+   对于，473–476

+   当有效时，473–475

+   易变对象，560

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">W</samp>

+   王丹尼尔，22

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 语句，144，148–150，151–155，157

+   空白字符，9–10

+   宽字符类型，424

+   Windows 子系统 for Linux (WSL)，xxxiv

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp> 后缀，28

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">X</samp>

+   x64 指令集，xxvii。*参见* 汇编代码 *及单个指令名称*

+   AT&T 与 Intel 语法，6，244，570

+   文档，xxxvi

+   流式 SIMD 扩展指令，310–312

+   x64 处理器，xxxiv

+   小端序，86

+   内存地址大小，28

+   x86-64。*参见* x64 指令集；x64 处理器

+   Xcode，xxxiv–xxxv

+   XMM 寄存器，311–312，325

+   分配，631

+   构建寄存器干扰图，637

+   在函数调用中，312–315，329–333，519，532–541，545–546

+   清零，316

+   XOR（<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>）运算符，67

+   XOR 赋值（<samp class="SANS_TheSansMonoCd_W5Regular_11">^=</samp>）运算符，113

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> 指令，316，324–325，328

+   发射，341

+   修复，337

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Y</samp>

+   杨爱德华，253

+   杨兆茂，611

+   <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Z</samp>

+   Zephyr 抽象语法描述语言。*参见* ASDL

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp>指令，222

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp>指令，281–283，288

+   零扩展，274，281–282，286–288，443–444

+   零标志（ZF），78–80，83

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>，由，317

+   在无符号比较中，284–285

+   <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>构造，405

+   发射，418–419

+   初始化填充，510–511

+   初始化标量变量，405

+   初始化暂时定义的数组，411

流程图展示了编译过程的各个步骤。

1\. 过程从 C 源代码（文本）开始。

2\. 预处理器将源代码转化为预处理后的源代码（文本）。

3\. 编译器将预处理后的源代码转化为汇编代码（文本）。

4\. 汇编器将汇编代码转化为目标文件（二进制文件）。

5\. 链接器将目标文件和另外两个目标文件（二进制文件）转化为可执行文件（也是二进制文件）。

返回正文

流程图展示了编译器的各个阶段。

1\. 词法分析器将 program.c 转化为标记列表。

2\. 解析器将标记列表转化为抽象语法树。

3\. 汇编生成将抽象语法树转化为汇编代码。

4\. 代码发射将汇编代码写入 program.s。

返回正文

树形图展示了抽象语法树（AST）。

· 根节点是"If(condition, then)"。

● 根节点的"condition"子节点是"Binary(operator, left, right)"。

○ "左"子节点是"Var(a)"。

○ "operator"子节点是"LessThan"。

○ "右"子节点是"Var(b)"。

● 根节点的"then"子节点是"Return(exp)"。

○ "exp"子节点是"Binary(operator, left, right)"。

■ "左"子节点是"Constant(2)"。

■ "operator"子节点是"Add"。

■ "右"子节点是"Constant(2)"。

返回正文

树形图展示了抽象语法树（AST）。每个节点只有一个子节点。

· 根节点是"Program(function_definition)"。

● "function_definition"子节点是"Function(main, body)"。

■ "body"子节点是"Return(exp)"。

● "exp"子节点是"Constant(2)"。

返回正文

流程图展示了编译器的各个阶段。

1\. 词法分析器将 program.c 转化为标记列表。

2\. 解析器将标记列表转化为抽象语法树。

3\. TACKY 生成（一个新阶段）将抽象语法树转化为 TACKY。

4\. 汇编生成将 TACKY 转换为汇编。它有三个步骤（全部是新的）：

a. 将 TACKY 转换为汇编

b. 替换伪寄存器

c. 指令修正

5\. 代码发射将汇编写入 `program.s`。

返回文本

该图展示了 `push` 指令执行前后的系统状态。

· 在 `push` 前，栈的内容从上到下如下：

● 地址 0x7ffeea685918 处的 "a"

● 地址 0x7ffeea685920 处的 "b"

● 地址 0x7ffeea685928 处的 "c"

RSP 保存地址 0x7ffeea685918，并指向 "a"。

· 执行 `push` 后，栈的内容从上到下如下：

● 地址 0x7ffeea685910 处的 3

● 地址 0x7ffeea685918 处的 "a"

● 地址 0x7ffeea685920 处的 "b"

● 地址 0x7ffeea685928 处的 "c"

RSP 保存地址 0x7ffeea685910，并指向 3。

返回文本

四个图展示了函数开始时以及函数序言中每条指令执行后的系统状态。

· 在函数开始时，调用者栈帧从栈顶的地址 0x7ffeea685918 开始，延伸至地址 0x7ffeea685960。RSP 保存地址 0x7ffeea685918，并指向调用者栈帧的顶部。RBP 保存地址 0x7ffeea685960，并指向调用者栈帧的底部。

· 执行 `pushq %rbp` 后，栈的内容从上到下如下：

● 地址 0x7ffeea685910 处的值 0x7ffeea685960

● 调用者栈帧，从地址 0x7ffeea685918 开始，延伸至地址 0x7ffeea685960。

RSP 保存地址 0x7ffeea685910，并指向栈顶的值。RBP 保存地址 0x7ffeea685960，并指向调用者栈帧的底部。

· 执行 `movq %rsp, %rbp` 后，栈的内容从上到下如下：

● 地址 0x7ffeea685910 处的值 0x7ffeea685960

● 调用者栈帧，从地址 0x7ffeea685918 开始，延伸至地址 0x7ffeea685960。

RSP 和 RBP 都保存地址 0x7ffeea685910，并指向栈顶的值。

· 执行 `subq $24, %rsp` 后，栈的内容从上到下如下：

● 地址 0x7ffeea6858f8 开始的 24 字节未使用内存

● 地址 0x7ffeea685910 处的值 0x7ffeea685960

● 调用者栈帧，从地址 0x7ffeea685918 开始，延伸至地址 0x7ffeea685960。

RSP 保存地址 0x7ffeea6858f8，并指向未使用内存的起始位置。

RBP 保存地址 0x7ffeea685910，并指向未使用内存下方的值 0x7ffeea685960。

返回文本

三个图展示了函数开始时以及函数序言中每条指令执行后的系统状态。

· 在尾声开始时，栈的内容从上到下如下：

● 从地址 0x7ffeea6858f8 开始的 24 字节局部变量。

● 地址 0x7ffeea685910 处的值 0x7ffeea685960

● 调用者栈帧，从地址 0x7ffeea685918 开始，延伸至地址 0x7ffeea685960。

RSP 保存地址 0x7ffeea6858f8，指向存储局部变量的内存开始处。

RBP 保存地址 0x7ffeea685910，指向局部变量下方的值 0x7ffeea685960。

· 执行 movq %rbp, %rsp 后，栈的内容如下，从上到下：

● 地址 0x7ffeea685910 处的值为 0x7ffeea685960

● 调用者栈帧从地址 0x7ffeea685918 开始，到地址 0x7ffeea685960 结束。

RSP 和 RBP 都保存地址 0x7ffeea685910，指向栈顶的值 0x7ffeea685960。

· 在执行 popq %rbp 后，调用者栈帧从栈顶地址 0x7ffeea685918 开始，到地址 0x7ffeea685960 结束。RSP 保存地址 0x7ffeea685918，指向调用者栈帧栈的顶部。RBP 保存地址 0x7ffeea685960，指向调用者栈帧的底部。

返回文本

流程图展示了编译器的各个阶段。

● 词法分析器将 program.c 转换为令牌列表。

● 解析器将令牌列表转换为抽象语法树。

● TACKY 生成将抽象语法树转换为 TACKY。

● 汇编生成将 TACKY 转换为汇编。它有三个步骤：

● 将 TACKY 转换为汇编

● 替换伪寄存器

● 指令修正

● 代码发射将汇编写入 program.s。

返回文本

树形图展示了抽象语法树（AST）。

● 根节点是 +。它有两个子节点。

● 根节点的第一个子节点是 1。

● 根节点的第二个子节点是 *。它有两个子节点。

● 第一个子节点是 2。

● 第二个子节点是 3。

返回文本

树形图展示了抽象语法树（AST）。

● 根节点是 *。它有两个子节点。

● 根节点的第一个子节点是 +。它有两个子节点。

● 第一个子节点是 1。

● 第二个子节点是 2。

● 根节点的第二个子节点是 3。

返回文本

流程图展示了编译器的各个阶段。

1\. 词法分析器将 program.c 转换为令牌列表。

2\. 解析器将令牌列表转换为抽象语法树。

3\. TACKY 生成将抽象语法树转换为 TACKY。

4\. 汇编生成将 TACKY 转换为汇编。它有三个步骤：

a. 将 TACKY 转换为汇编

b. 替换伪寄存器

c. 指令修正

5\. 代码发射将汇编写入 program.s。

返回文本

流程图展示了编译器的各个阶段，包括一个新阶段。

1\. 词法分析器将 program.c 转换为令牌列表。

2\. 解析器将令牌列表转换为抽象语法树。

3\. 语义分析（新阶段）将 AST 转换为转换后的 AST。它有一个步骤：

a. 变量解析

4\. TACKY 生成将转换后的 AST 转换为 TACKY。

5\. 汇编生成将 TACKY 转换为汇编。它有三个步骤：

a. 将 TACKY 转换为汇编

b. 替换伪寄存器

c. 指令修正

6\. 代码发射将汇编写入 program.s。

返回文本

流程图展示了编译器的各个阶段。

1\. 词法分析器将 program.c 转换为标记列表。

2\. 解析器将标记列表转换为抽象语法树。

3\. 语义分析将 AST 转换为转换后的 AST。它有一个步骤：

a. 变量解析

4\. TACKY 生成将转换后的 AST 转换为 TACKY。

5\. 汇编生成将 TACKY 转换为汇编。它有三个步骤：

a. 将 TACKY 转换为汇编

b. 替换伪寄存器

c. 指令修正

6\. 代码发射将汇编写入 program.s。

返回文本

一个流程图显示了编译器的各个阶段。

1\. 词法分析器将 program.c 转换为标记列表。

2\. 解析器将标记列表转换为抽象语法树。

3\. 语义分析将 AST 转换为转换后的 AST。它有一个步骤：

a. 变量解析

4\. TACKY 生成将转换后的 AST 转换为 TACKY。

5\. 汇编生成将 TACKY 转换为汇编。它有三个步骤：

a. 将 TACKY 转换为汇编

b. 替换伪寄存器

c. 指令修正

6\. 代码发射将汇编写入 program.s。

返回文本

一个流程图显示了编译器的各个阶段，包括语义分析阶段中新增加的一个步骤。

1\. 词法分析器将 program.c 转换为标记列表。

2\. 解析器将标记列表转换为抽象语法树。

3\. 语义分析将 AST 转换为转换后的 AST。它有两个步骤：

a. 变量解析

b. 循环标记（新增步骤）

4\. TACKY 生成将转换后的 AST 转换为 TACKY。

5\. 汇编生成将 TACKY 转换为汇编。它有三个步骤：

a. 将 TACKY 转换为汇编

b. 替换伪寄存器

c. 指令修正

6\. 代码发射将汇编写入 program.s。

返回文本

一个流程图显示了编译器的各个阶段，包括语义分析阶段中新增加的一个步骤。

1\. 词法分析器将 program.c 转换为标记列表。

2\. 解析器将标记列表转换为抽象语法树。

3\. 语义分析将 AST 转换为转换后的 AST。它有三个步骤：

a. 标识符解析

b. 类型检查（新增步骤）

c. 循环标记

4\. TACKY 生成将转换后的 AST 转换为 TACKY。

5\. 汇编生成将 TACKY 转换为汇编。它有三个步骤：

a. 将 TACKY 转换为汇编

b. 替换伪寄存器

c. 指令修正

6\. 代码发射将汇编写入 program.s。

返回文本

● 左列：寄存器和堆栈并排显示。堆栈顶部的值是先前堆栈帧的保存基地址。先前的堆栈帧紧随其下。

RSP 和 RBP 指向堆栈顶部保存的基地址。RDI 保存值 15\. RSI、RDX、RCX、R8、R9 和 RAX 尚未初始化。

堆栈的内容从上到下列出：

○ 值 0x7000000000160 存储在地址 0x7000000000110

○ 先前的堆栈帧从地址 0x7000000000118 扩展到 0x7000000000160

寄存器的内容如下表所示。

| 寄存器 | 内容 |
| --- | --- |
| RSP | 0x7000000000110 |
| RBP | 0x7000000000110 |
| RDI | 15 |
| RSI | 未初始化 |
| RDX | 未初始化 |
| RCX | 未初始化 |
| R8 | 未初始化 |
| R9 | 未初始化 |
| RAX | 未初始化 |

● 右栏：调用 fun 的汇编指令，来自列出 9-27，已存储在从地址 0x10000000 开始的内存中。RIP 保存地址 0x10000000，并指向第一条指令，“pushq %rdi”。指令及其地址列在以下表中。

| 指令地址 | 指令 |
| --- | --- |
| 0x10000000 | pushq %rdi |
| 0x10000001 | subq $8, %rsp |
| 0x10000002 | movl $1, %edi |
| 0x10000003 | movl $2, %esi |
| 0x10000004 | movl $3, %edx |
| 0x10000005 | movl $4, %ecx |
| 0x10000006 | movl $5, %r8d |
| 0x10000007 | movl $6, %r9d |
| 0x10000008 | pushq $8 |
| 0x10000009 | pushq $7 |
| 0x1000000a | call fun |
| 0x1000000b | addq $24, %rsp |
| 0x1000000c | popq %rdi |

返回文本

● 左栏：寄存器和栈并排显示，如图 9-1 所示。四个新项已推送到栈上。这些项从上到下分别是：值 7、值 8、填充和值 15。接下来是之前栈帧的保存基地址，再之后是之前的栈帧，如之前一样。

现在，RSP 指向栈顶的值 7。RBP 指向之前栈帧的保存基地址，如之前一样。RDI、RSI、RDX、RCX、R8 和 R9 分别保存着值 1 到 6，而 RAX 尚未初始化。

栈中的内容从上到下列出：

○ 地址 0x70000000000f0 处的值 7

○ 值 8

○ 填充

○ 值 15

○ 地址 0x7000000000110 处的值 0x7000000000160

○ 之前的栈帧，地址范围从 0x7000000000118 到 0x7000000000160

寄存器的内容如下表所示。

| 寄存器 | 内容 |
| --- | --- |
| RSP | 0x70000000000f0 |
| RBP | 0x7000000000110 |
| RDI | 1 |
| RSI | 2 |
| RDX | 3 |
| RCX | 4 |
| R8 | 5 |
| R9 | 6 |
| RAX | 未初始化 |

● 右栏：调用 fun 的汇编指令，来自列出 9-27，已存储在从地址 0x10000000 开始的内存中。RIP 保存地址 0x1000000a，并指向第十一条指令，“call fun”。指令及其地址列在以下表中。

| 指令地址 | 指令 |
| --- | --- |
| 0x10000000 | pushq %rdi |
| 0x10000001 | subq $8, %rsp |
| 0x10000002 | movl $1, %edi |
| 0x10000003 | movl $2, %esi |
| 0x10000004 | movl $3, %edx |
| 0x10000005 | movl $4, %ecx |
| 0x10000006 | movl $5, %r8d |
| 0x10000007 | movl $6, %r9d |
| 0x10000008 | pushq $8 |
| 0x10000009 | pushq $7 |
| 0x1000000a | call fun |
| 0x1000000b | addq $24, %rsp |
| 0x1000000c | popq %rdi |

返回文本

● 左列：寄存器和堆栈并排显示，如图 9-2 所示。堆栈上推入了一个新值：0x1000000b，它是调用指令后面汇编指令的地址。RSP 指向这个新值。其余寄存器和堆栈内容与图 9-2 相同。

堆栈的内容从上到下列出：

○ 地址 0x70000000000e8 处的值 0x1000000b

○ 地址 0x70000000000f0 处的值 7

○ 值 8

○ 填充

○ 值 15

○ 地址 0x7000000000110 处的值 0x7000000000160

○ 先前的堆栈帧，从地址 0x7000000000118 延伸到 0x7000000000160

寄存器的内容在下表中列出。

| 寄存器 | 内容 |
| --- | --- |
| RSP | 0x70000000000e8 |
| RBP | 0x7000000000110 |
| RDI | 1 |
| RSI | 2 |
| RDX | 3 |
| RCX | 4 |
| R8 | 5 |
| R9 | 6 |
| RAX | 未初始化 |

● 右列：调用`fun`的汇编指令，来自清单 9-27，存储在从地址 0x10000000 开始的内存中。这些指令在图中以灰色显示。

来自清单 9-26 的`fun`函数的汇编指令存储在从地址 0x10000100 开始的内存中。RIP 保存地址 0x10000100 并指向`fun`函数中的第一条指令“pushq %rbp”。

调用`fun`的指令及其地址在下表中列出。

| 指令地址 | 指令 |
| --- | --- |
| 0x10000000 | pushq %rdi |
| 0x10000001 | subq $8, %rsp |
| 0x10000002 | movl $1, %edi |
| 0x10000003 | movl $2, %esi |
| 0x10000004 | movl $3, %edx |
| 0x10000005 | movl $4, %ecx |
| 0x10000006 | movl $5, %r8d |
| 0x10000007 | movl $6, %r9d |
| 0x10000008 | pushq $8 |
| 0x10000009 | pushq $7 |
| 0x1000000a | call fun |
| 0x1000000b | addq $24, %rsp |
| 0x1000000c | popq %rdi |

“fun”函数中的指令及其地址在下表中列出。

| 指令地址 | 指令 |
| --- | --- |
| 0x10000100 | pushq %rbp |
| 0x10000101 | movq %rsp, %rbp |
| 0x10000102 | movl %edi, %eax |
| 0x10000103 | addl 24(%rbp), %eax |
| 0x10000104 | movq %rbp, %rsp |
| 0x10000105 | popq %rbp |
| 0x10000106 | ret |

返回文本

● 左列：寄存器和堆栈并排显示，如图 9-3 所示。堆栈上推入了一个新值：0x7000000000110，它是 RBP 的先前值。RSP 和 RBP 都指向这个新值。其余寄存器和堆栈内容与图 9-3 相同。

堆栈被三种不同的背景色阴影标记，以指示不同的区域。堆栈的内容从上到下列出，按区域组织。

○ 白色区域包含一项：在地址 0x70000000000e0 处的值 0x7000000000110

○ 浅灰色区域包含六个项：

■ 地址 0x70000000000e8 处的值 0x1000000b

■ 地址 0x70000000000f0 处的值 7

■ 值 8

■ 填充

■ 值 15

■ 地址 0x7000000000110 处的值 0x7000000000160

○ 深灰色区域是先前的栈帧，扩展从地址 0x7000000000118 到 0x7000000000160

寄存器的内容列在下表中。

| 寄存器 | 内容 |
| --- | --- |
| RSP | 0x70000000000e0 |
| RBP | 0x70000000000e0 |
| RDI | 1 |
| RSI | 2 |
| RDX | 3 |
| RCX | 4 |
| R8 | 5 |
| R9 | 6 |
| RAX | 未初始化 |

● 右列：调用 fun 的汇编指令，来自清单 9-27，存储在从地址 0x10000000 开始的内存中。这些指令在该图中被灰色标出。

来自清单 9-26 的 fun 函数的汇编指令存储在从地址 0x10000100 开始的内存中。RIP 保存地址 0x10000102，并指向 fun 中的第三条指令，“movl %edi, %eax”。

调用 fun 的指令及其地址列在下表中。

| 指令地址 | 指令 |
| --- | --- |
| 0x10000000 | pushq %rdi |
| 0x10000001 | subq $8, %rsp |
| 0x10000002 | movl $1, %edi |
| 0x10000003 | movl $2, %esi |
| 0x10000004 | movl $3, %edx |
| 0x10000005 | movl $4, %ecx |
| 0x10000006 | movl $5, %r8d |
| 0x10000007 | movl $6, %r9d |
| 0x10000008 | pushq $8 |
| 0x10000009 | pushq $7 |
| 0x1000000a | call fun |
| 0x1000000b | addq $24, %rsp |
| 0x1000000c | popq %rdi |

“fun” 函数中的指令及其地址列在下表中。

| 指令地址 | 指令 |
| --- | --- |
| 0x10000100 | pushq %rbp |
| 0x10000101 | movq %rsp, %rbp |
| 0x10000102 | movl %edi, %eax |
| 0x10000103 | addl 24(%rbp), %eax |
| 0x10000104 | movq %rbp, %rsp |
| 0x10000105 | popq %rbp |
| 0x10000106 | ret |

返回文本

● 左列：寄存器和栈并排显示，如图 9-4 所示。RBP 的保存值 0x7000000000110 已从栈顶弹出。栈内容与图 9-4 中相同。

RSP 指向值 0x1000000b，即当前位于栈顶的返回地址。RBP 指向先前栈帧的保存基址，它是栈顶第六项。RAX 保存值 9。其他寄存器与图 9-4 中的状态相同。

栈的内容按从上到下的顺序列出：

○ 地址 0x70000000000e8 处的值 0x1000000b

○ 地址 0x70000000000f0 处的值 7

○ 值 8

○ 填充

○ 值 15

○ 地址 0x7000000000110 处的值 0x7000000000160

○ 先前的栈帧，扩展从地址 0x7000000000118 到 0x7000000000160

寄存器的内容列在下表中。

| 寄存器 | 内容 |
| --- | --- |
| RSP | 0x70000000000e8 |
| RBP | 0x7000000000110 |
| RDI | 1 |
| RSI | 2 |
| RDX | 3 |
| RCX | 4 |
| R8 | 5 |
| R9 | 6 |
| RAX | 9 |

● 右列：调用 fun 的汇编指令，来自清单 9-27，存储在从地址 0x10000000 开始的内存中。这些指令在该图中被灰色标出。

来自列表 9-26 的 fun 汇编指令存储在从地址 0x10000100 开始的内存中。RIP 寄存器存储地址 0x10000106，并指向 fun 中的第七条也是最后一条指令，“ret”。

调用 fun 的指令及其地址列在下表中。

| 指令地址 | 指令 |
| --- | --- |
| 0x10000000 | pushq %rdi |
| 0x10000001 | subq $8, %rsp |
| 0x10000002 | movl $1, %edi |
| 0x10000003 | movl $2, %esi |
| 0x10000004 | movl $3, %edx |
| 0x10000005 | movl $4, %ecx |
| 0x10000006 | movl $5, %r8d |
| 0x10000007 | movl $6, %r9d |
| 0x10000008 | pushq $8 |
| 0x10000009 | pushq $7 |
| 0x1000000a | call fun |
| 0x1000000b | addq $24, %rsp |
| 0x1000000c | popq %rdi |

“fun”函数中的指令及其地址列在下表中。

| 指令地址 | 指令 |
| --- | --- |
| 0x10000100 | pushq %rbp |
| 0x10000101 | movq %rsp, %rbp |
| 0x10000102 | movl %edi, %eax |
| 0x10000103 | addl 24(%rbp), %eax |
| 0x10000104 | movq %rbp, %rsp |
| 0x10000105 | popq %rbp |
| 0x10000106 | ret |

返回文本

● 左侧列：寄存器和栈并排显示，如图 9-5 所示。返回地址 0x1000000b 已从栈顶弹出。栈内容与图 9-5 相同，未发生变化。

RSP 指向栈顶，现在栈顶的值是 7。其他寄存器的内容与图 9-5 中相同。

栈的内容按从上到下的顺序列出：

○ 地址 0x70000000000f0 处的值 7

○ 值 8

○ 填充

○ 值 15

○ 地址 0x7000000000110 处的值 0x7000000000160

○ 先前的栈帧，地址范围从 0x7000000000118 到 0x7000000000160

寄存器的内容列在下表中。

| 寄存器 | 内容 |
| --- | --- |
| RSP | 0x70000000000f0 |
| RBP | 0x7000000000110 |
| RDI | 1 |
| RSI | 2 |
| RDX | 3 |
| RCX | 4 |
| R8 | 5 |
| R9 | 6 |
| RAX | 9 |

● 右侧列：用于调用 fun 的汇编指令，来自列表 9-27，存储在从地址 0x10000000 开始的内存中。这些指令不再是灰色的。RIP 存储地址 0x1000000b，并指向第十二条指令，“addq $24, %rsp”。

调用 fun 的指令及其地址列在下表中。

| 指令地址 | 指令 |
| --- | --- |
| 0x10000000 | pushq %rdi |
| 0x10000001 | subq $8, %rsp |
| 0x10000002 | movl $1, %edi |
| 0x10000003 | movl $2, %esi |
| 0x10000004 | movl $3, %edx |
| 0x10000005 | movl $4, %ecx |
| 0x10000006 | movl $5, %r8d |
| 0x10000007 | movl $6, %r9d |
| 0x10000008 | pushq $8 |
| 0x10000009 | pushq $7 |
| 0x1000000a | call fun |
| 0x1000000b | addq $24, %rsp |
| 0x1000000c | popq %rdi |

返回文本

● 左栏：显示寄存器和栈的内容，类似图 9-6。栈顶已移除四个值，先前栈帧的保存基地址现在位于栈顶，先前栈帧紧接其下。

RSP 和 RBP 指向栈顶保存的基地址。RDI 保存值 15\. RAX 保存值 9，其余寄存器保存从 2 到 6 的值，如图 9-6 所示。

栈的内容从上到下列出：

○ 值 0x7000000000160 位于地址 0x7000000000110

○ 先前的栈帧，范围从地址 0x7000000000118 到 0x7000000000160

以下表格给出了寄存器的内容。

| 寄存器 | 内容 |
| --- | --- |
| RSP | 0x7000000000110 |
| RBP | 0x7000000000110 |
| RDI | 15 |
| RSI | 2 |
| RDX | 3 |
| RCX | 4 |
| R8 | 5 |
| R9 | 6 |
| RAX | 9 |

● 右栏：调用 fun 的汇编指令，来自清单 9-27，存储在从地址 0x10000000 开始的内存中。RIP 保存地址 0x1000000d，并指向“popq %rdi”之后的未指定指令。

调用 fun 的指令及其地址在下表中给出。

| 指令地址 | 指令 |
| --- | --- |
| 0x10000000 | pushq %rdi |
| 0x10000001 | subq $8, %rsp |
| 0x10000002 | movl $1, %edi |
| 0x10000003 | movl $2, %esi |
| 0x10000004 | movl $3, %edx |
| 0x10000005 | movl $4, %ecx |
| 0x10000006 | movl $5, %r8d |
| 0x10000007 | movl $6, %r9d |
| 0x10000008 | pushq $8 |
| 0x10000009 | pushq $7 |
| 0x1000000a | call fun |
| 0x1000000b | addq $24, %rsp |
| 0x1000000c | popq %rdi |
| 0x1000000d | ... |

返回文本

一张流程图展示了编译器的各个阶段。

1\. 词法分析器将 program.c 转换为一个标记列表。

2\. 解析器将标记列表转化为抽象语法树（AST）。

3\. 语义分析将抽象语法树（AST）转化为变换后的抽象语法树（AST）。它有三个步骤：

a. 标识符解析

b. 类型检查

c. 循环标签化

4\. TACKY 生成将变换后的抽象语法树（AST）转化为 TACKY。

5\. 汇编生成将 TACKY 转换为汇编代码。它有三个步骤：

a. 将 TACKY 转换为汇编代码

b. 替换伪寄存器

c. 指令修复

6\. 代码生成将汇编写入 program.s。

返回文本

一张流程图展示了编译器的各个阶段。

1\. 词法分析器将 program.c 转换为一个标记列表。

2\. 解析器将标记列表转化为抽象语法树（AST）。

3\. 语义分析将抽象语法树（AST）转化为变换后的抽象语法树（AST）。它有三个步骤：

a. 标识符解析

b. 类型检查

c. 循环标签化

4\. TACKY 生成将变换后的抽象语法树（AST）转化为 TACKY。

5\. 汇编生成将 TACKY 转换为汇编代码。它有三个步骤：

a. 将 TACKY 转换为汇编代码

b. 替换伪寄存器

c. 指令修复

6\. 代码生成将汇编写入 program.s。

返回文本

一张流程图展示了编译器的各个阶段。

1. 词法分析器将 program.c 转换为标记列表。

2. 解析器将标记列表转化为抽象语法树（AST）。

3. 语义分析将 AST 转化为变换后的 AST。它包含三个步骤：

a. 标识符解析

b. 类型检查

c. 循环标号

4. TACKY 生成将变换后的 AST 转化为 TACKY。

5. 汇编生成将 TACKY 转换为汇编。它包含三个步骤：

a. 将 TACKY 转换为汇编

b. 替换伪寄存器

c. 指令修正

6. 代码生成将汇编写入 program.s。

返回文本

一个流程图展示了编译器的各个阶段。

1. 词法分析器将 program.c 转换为标记列表。

2. 解析器将标记列表转化为抽象语法树（AST）。

3. 语义分析将 AST 转化为变换后的 AST。它包含三个步骤：

a. 标识符解析

b. 类型检查

c. 循环标号

4. TACKY 生成将变换后的 AST 转化为 TACKY。

5. 汇编生成将 TACKY 转换为汇编。它包含三个步骤：

a. 将 TACKY 转换为汇编

b. 替换伪寄存器

c. 指令修正

6. 代码生成将汇编写入 program.s。

返回文本

一个图示展示了双精度格式中的三个字段。

● 分数部分是 52 位，位于第 0 到 51 位。

● 指数部分是 11 位，位于第 62 到 52 位。

● 符号位是 1 位，位于第 63 位。

返回文本

图示展示了通用寄存器和浮点寄存器的内容。这里它们的内容呈现为两个列表。

通用寄存器：

● RDI: i1

● RSI: i2

● RDX: i3

● RCX: i4

● R8: i5

● R9: 未使用

浮点寄存器：

● XMM0: d1

● XMM1: d2

● XMM2: d3

● XMM3 到 XMM7 未使用。

返回文本

图示展示了通用寄存器、浮点寄存器和栈的内容。这里它们的内容呈现为三个列表。

通用寄存器：

● RDI: i1

● RSI: i2

● RDX: i3

● RCX: i4

● R8: i5

● R9: i6

浮点寄存器：

● XMM0: d1

● XMM1: d2

● XMM2: d3

● XMM3: d4

● XMM4 到 XMM7 未使用。

栈内容（从栈顶到底部）：

● i7

● i8

● 调用者栈帧

RSP 指向栈顶的 i7。

返回文本

图示展示了通用寄存器、浮点寄存器和栈的内容。这里它们的内容呈现为三个列表。

通用寄存器：

● RDI: i1

● RSI: i2

● RDX: i3

● RCX: i4

● R8: i5

● R9: i6

浮点寄存器：

● XMM0: d1

● XMM1: d2

● XMM2: d3

● XMM3: d4

● XMM4: d5

● XMM5: d6

● XMM6: d7

● XMM7: d8

栈内容（从栈顶到底部）：

● d9

● d10

● i7

● d11

● i8

● i9

● 调用者栈帧

RSP 指向栈顶的 d9。

返回文本

一个数字线展示了 4,611,686,018,427,388,416.5 四舍五入到最接近的双精度数的正确和错误方法。数字线上有四个标记：

1. 4,611,686,018,427,387,904.0

2. 4,611,686,018,427,388,416

3\. 4,611,686,018,427,388,416.5

4\. 4,611,686,018,427,388,928.0。

一个虚线箭头从 4,611,686,018,427,388,416.5（原始值）指向 4,611,686,018,427,388,928.0。

一个实心箭头从 4,611,686,018,427,388,416.5 向下指向 4,611,686,018,427,388,416，第二个实心箭头从那里指向 4,611,686,018,427,387,904.0。

返回文本

四条数字线展示了不同的奇数舍入情况。每条数字线从 4,611,686,018,427,387,904.0 开始，直到 4,611,686,018,427,388,928.0。每条数字线的标签间隔为 0.5，从 4,611,686,018,427,388,414.5 到 4,611,686,018,427,388,417。

● 在第一种情况下，我们将 4,611,686,018,427,388,416.5 向上舍入到 4,611,686,018,427,388,417，然后从那里向上舍入到 4,611,686,018,427,388,928.0。

● 在第二种情况下，我们只进行一次舍入，将 4,611,686,018,427,388,416 向下舍入到 4,611,686,018,427,387,904.0。

● 在第三种情况下，我们将 4,611,686,018,427,388,415.5 向下舍入到 4,611,686,018,427,388,415，然后从那里向下舍入到 4,611,686,018,427,387,904.0。

● 在第四种情况下，我们将 4,611,686,018,427,388,414.5 向上舍入到 4,611,686,018,427,388,415，然后从那里向下舍入到 4,611,686,018,427,387,904.0。

返回文本

一个流程图展示了编译器的各个阶段。

1\. 词法分析器将 program.c 转换为令牌列表。

2\. 解析器将令牌列表转换为抽象语法树（AST）。

3\. 语义分析将 AST 转换为转换后的 AST，包含三个步骤：

a. 标识符解析

b. 类型检查

c. 循环标签化

4\. TACKY 生成将转换后的 AST 转换为 TACKY。

5\. 汇编生成将 TACKY 转换为汇编，包含三个步骤：

a. 将 TACKY 转换为汇编

b. 替换伪寄存器

c. 指令修正

6\. 代码生成将汇编写入 program.s。

返回文本

栈内容，从上到下：

● 值 0 位于地址 0x7ffeee67b938（变量 x）

● 值 0x7ffeee67b938 位于地址 0x7ffeee67b940（变量 ptr）

返回文本

栈内容，从上到下：

● 值 4 位于地址 0x7ffeee67b938（变量 x）

● 值 0x7ffeee67b938 位于地址 0x7ffeee67b940（变量 ptr）

返回文本

一个流程图展示了编译器的各个阶段。

1\. 词法分析器将 program.c 转换为令牌列表。

2\. 解析器将令牌列表转换为抽象语法树（AST）。

3\. 语义分析将 AST 转换为转换后的 AST，包含三个步骤：

a. 标识符解析

b. 类型检查

c. 循环标签化

4\. TACKY 生成将转换后的 AST 转换为 TACKY。

5\. 汇编生成将 TACKY 转换为汇编，包含三个步骤：

a. 将 TACKY 转换为汇编

b. 替换伪操作数

c. 指令修正

6\. 代码生成将汇编写入 program.s。

返回文本

内存内容如下表所示。

| 内存地址 | 内存内容 |
| --- | --- |
| 0x10 | 1 |
| 0x14 | 2 |
| 0x18 | 3 |
| 0x1c | 4 |
| 0x20 | 5 |
| 0x24 | 6 |

返回文本

显示了编译器的各个阶段的流程图。

1\. 词法分析器将 program.c 转化为令牌列表。

2\. 解析器将令牌列表转化为抽象语法树。

3\. 语义分析将 AST 转化为转换后的 AST。它有三个步骤：

a. 标识符解析

b. 类型检查

c. 循环标记

4\. TACKY 生成将转换后的 AST 转化为 TACKY。

5\. 汇编生成将 TACKY 转化为汇编。它有三个步骤：

a. 将 TACKY 转化为汇编

b. 替换伪操作数

c. 指令修正

6\. 代码生成将汇编写入 program.s。

返回文本

显示了编译器的各个阶段的流程图。

1\. 词法分析器将 program.c 转化为令牌列表。

2\. 解析器将令牌列表转化为抽象语法树。

3\. 语义分析将 AST 转化为转换后的 AST。它有三个步骤：

a. 标识符解析

b. 类型检查

c. 循环标记

4\. TACKY 生成将转换后的 AST 转化为 TACKY。

5\. 汇编生成将 TACKY 转化为汇编。它有三个步骤：

a. 将 TACKY 转化为汇编

b. 替换伪操作数

c. 指令修正

6\. 代码生成将汇编写入 program.s。

返回文本

显示了编译器的各个阶段的流程图。

1\. 词法分析器将 program.c 转化为令牌列表。

2\. 解析器将令牌列表转化为抽象语法树。

3\. 语义分析将 AST 转化为转换后的 AST。它有三个步骤：

a. 标识符解析

b. 类型检查

c. 循环标记

4\. TACKY 生成将转换后的 AST 转化为 TACKY。

5\. 汇编生成将 TACKY 转化为汇编。它有三个步骤：

a. 将 TACKY 转化为汇编

b. 替换伪操作数

c. 指令修正

6\. 代码生成将汇编写入 program.s。

返回文本

结构中成员和填充的位置以列表形式给出。

● 字节 0 到 3 包含 member1。

● 字节 4 到 7 包含填充。

● 字节 8 到 15 包含 member2。

● 字节 16 到 18 包含数组。字节 16 包含数组元素 0，字节 17 包含数组元素 1，字节 18 包含数组元素 2。

● 字节 19 到 23 包含填充。

返回文本

字节 0 到 7 是第一个八字节。字节 8 到 11 是第二个八字节。结构中成员和填充的位置以列表形式给出。

● 字节 0 到 3 包含 i。

● 字节 4 到 11 包含 arr。字节 4 包含 arr 的元素 0，字节 5 包含 arr 的元素 1，依此类推，直到字节 11，它包含 arr 的元素 7。

返回文本

字节 0 到 7 是第一个八字节。字节 8 到 11 是第二个八字节。结构中成员和填充的位置以列表形式给出。

● 字节 0 包含 ch1。

● 字节 1 到 3 包含填充。

● 字节 4 到 11 包含嵌套。在嵌套中：

○ 第 4 到第 7 字节包含 i。

○ 第 8 字节包含 ch2。

○ 第 9 到第 11 字节包含填充数据。

返回文本

四个图示展示了在函数调用中的不同点栈的内容，来自 Listing 18-46。在这些图示中，栈被不同的背景色阴影标识为三个区域。第一，函数调用前的调用者栈帧。第二，调用者在函数调用期间压入栈的值。第三，被调用者的栈帧。在每个图示中，栈的内容按区域从上到下列出（不是每个区域在每个图示中都有）。

四个图示如下：

● 在参数传递之前，栈的内容如下：

○ 调用者的栈帧：

■ 地址为−16(%rbp)的一个局部变量

■ 地址为−8(%rbp)的另一个局部变量

■ 地址为 0(%rbp)的 RBP 的旧值

● 在第一次执行 pushq 指令后，栈的内容如下，从上到下：

○ 调用时压入的内容：

■ 地址为−24(%rbp)的 arg.b

○ 调用者的栈帧：

■ 地址为−16(%rbp)的一个局部变量

■ 地址为−8(%rbp)的另一个局部变量

■ 地址为 0(%rbp)的 RBP 的旧值

● 在第二次执行 pushq 指令后，栈的内容如下：

○ 调用时压入的内容：

■ 地址为−32(%rbp)的 arg.a

■ 地址为−24(%rbp)的 arg.b

○ 调用者的栈帧：

■ 地址为−16(%rbp)的一个局部变量

■ 地址为−8(%rbp)的另一个局部变量

■ 地址为 0(%rbp)的 RBP 的旧值

● 在被调用者的序言后，RBP 指向栈顶。请注意，这会改变现有项相对于 RBP 的地址，尽管它们的绝对地址相同。栈的内容如下：

○ 被调用者的栈帧：

■ 地址为 0(%rbp)的调用者 RBP

○ 调用时压入的内容：

■ 地址为 8(%rbp)的返回地址

■ 地址为 16(%rbp)的 arg.a

■ 地址为 24(%rbp)的 arg.b

○ 调用者的栈帧：

■ 一个局部变量

■ 另一个局部变量

■ RBP 的旧值

返回文本

栈的内容按从上到下的顺序列出：

● 8 字节的填充数据

● 24 字节（或 3 个八字节栈槽）的未初始化内存，保留给 caller_result。

● 之前的 RBP

● 先前的栈帧

栈寄存器的内容在此图下方的文字中做了总结。以下是详细说明：

● RSP 保存地址 0x70000000000f0，并指向栈顶的填充区域。

● RDI 保存地址 0x70000000000f8，并指向为 caller_result 保留的内存的起始位置

● RBP 保存地址 0x7000000000110，并指向之前的 RBP

● RSI 保存值 10。

● 剩余的寄存器（RDX、RCX、R8、R9 和 RAX）未初始化。

返回文本

栈被不同的背景色阴影标识，以指示不同的栈帧。

栈的内容按从上到下的顺序列出，按栈帧组织。

● 被调用者的栈帧：

○ 8 字节的填充数据

○ 值为 0

○ 值 1

○ 值 10

○ 值 0x7000000000110

被叫者栈帧中保存值 0、1 和 10 的部分标记为 callee_result。

● 调用者的栈帧：

○ 返回地址

○ 8 个字节的填充

○ 值 0

○ 值 1

○ 值 10

○ 之前的 RBP

调用者栈帧中保存值 0、1 和 10 的部分标记为 caller_result。

● 之前的栈帧，未显示单独项。

寄存器的内容如下列表所示：

● RSP 保存地址 0x70000000000c0，并指向栈顶的填充部分

● RBP 保存地址 0x70000000000e0，并指向被叫者栈帧底部的值 x7000000000110

● RAX 保存值 0x70000000000f8，并指向调用者栈帧中的值 0，这是 caller_result 中的第一个值。

● RDI 还保存值 0x70000000000f8，并指向调用者栈帧中的值 0。

● RSI 保存值 10。

● 其余的寄存器（RDX、RCX、R8、R9 和 RAX）未初始化。

返回文本

五个图表展示了每一步 RDI 的内容。这里每个图表以表格形式呈现，其中每个单元格包含一个字节。表头标明了每个字节所包含的寄存器别名。字节按从左到右、从最重要到最不重要的顺序列出。

● 在 movb x+2(%rip), %dil 之后

| RDI | RDI 和 EDI | RDI、EDI 和 DIL |
| --- | --- | --- |
| 00 | 00 | 00 | 00 | 00 | 00 | 00 | 03 |

● 在 shlq $8, %rdi 之后

| RDI | RDI 和 EDI | RDI、EDI 和 DIL |
| --- | --- | --- |
| 00 | 00 | 00 | 00 | 00 | 00 | 03 | 00 |

● 在 movb x+1(%rip), %dil 之后

| RDI | RDI 和 EDI | RDI、EDI 和 DIL |
| --- | --- | --- |
| 00 | 00 | 00 | 00 | 00 | 00 | 03 | 02 |

● 在 shlq $8, %rdi 之后

| RDI | RDI 和 EDI | RDI、EDI 和 DIL |
| --- | --- | --- |
| 00 | 00 | 00 | 00 | 00 | 03 | 02 | 00 |

● 在 movb x (%rip), %dil 之后

| RDI | RDI 和 EDI | RDI、EDI 和 DIL |
| --- | --- | --- |
| 00 | 00 | 00 | 00 | 00 | 03 | 02 | 01 |

返回文本

内存的内容如下表所示。

| 内存地址 | 内存内容 |
| --- | --- |
| -4(%rbp) | 0x01 |
| -3(%rbp) | 0x02 |
| -2(%rbp) | 0x03 |
| -1(%rbp) | 0x00 |

返回文本

一张流程图展示了编译器的各个阶段，包括一个新的优化阶段。

1\. 词法分析器将 program.c 转换为一个标记列表。

2\. 解析器将标记列表转换为抽象语法树（AST）。

3\. 语义分析将抽象语法树（AST）转换为转换后的 AST。它有三个步骤：

a. 标识符解析

b. 类型检查

c. 循环标签化

4\. TACKY 生成将转换后的 AST 转换为 TACKY。

5\. 优化（一个新阶段）将 TACKY 转换为优化后的 TACKY。它有四个步骤：

a. 常量折叠

b. 无法访问代码消除

c. 复制传播

d. 死存储消除

一条箭头指向每一步的下一步。另一条箭头则将死存储消除连接回常量折叠。

6\. 汇编生成将优化后的 TACKY 转换为汇编代码。它有三个步骤：

a. 转换 TACKY 为汇编

b. 替换伪操作数

c. 指令修正

7\. 代码生成将汇编写入 program.s。

返回文本

这里，控制流图中的节点以列表形式展示。基本块标记为 B0、B1 等。我们给出每个节点的内容，然后列出其外部边缘。

1\. ENTRY

边缘列表：

● B0

2\. B0

LoopStart:

input = get_input()

JumpIfNotZero(input, ProcessIt)

边缘列表：

● B1

● B2

3\. B1

返回(-1)

边缘列表：

● EXIT

4\. B2

ProcessIt:

done = process_input(input)

JumpIfNotZero(done, LoopStart)

边缘列表：

● B0

● B3

5\. B3

返回(0)

边缘列表：

● EXIT

6\. EXIT. 无外部边缘。

返回文本

这里，控制流图中的节点以列表形式展示。我们给出每个节点的内容，然后列出其外部边缘。

● ENTRY

边缘列表：

○ B0

● B0

x = 5

Jump(Target)

边缘列表：

○ B2

● B1

x = my_function()

边缘列表：

○ B2

● B2

Target:

返回(x)

边缘列表：

● EXIT

● EXIT. 无外部边缘。

返回文本

这里，控制流图中的节点以列表形式展示。我们给出每个节点的内容，然后列出其外部边缘。

1\. ENTRY

边缘列表：

● B0

2\. B0

x = foo()

JumpIfNotZero(arg, End)

边缘列表：

● B1

● B2

3\. B1

x = 2

边缘列表：

● B2

4\. B2

End:

返回(x)

边缘列表：

● EXIT

5\. EXIT. 无外部边缘。

返回文本

这里，控制流图中的节点以列表形式展示。我们给出每个节点的内容，然后列出其外部边缘。

1\. ENTRY

边缘列表：

● B0

2\. B0

x = 2

JumpIfNotZero(arg, End)

边缘列表：

● B1

● B2

3\. B1

do_something()

边缘列表：

● B2

4\. B2

End:

返回(x)

边缘列表：

● EXIT

6\. EXIT. 无外部边缘。

返回文本

这里，控制流图中的节点以列表形式展示。我们给出每个节点的内容，然后列出其外部边缘。

1\. ENTRY

边缘列表：

● B0

2\. B0

JumpIfNotZero(arg, A)

边缘列表：

● B1

● B2

3\. B1

y = 20

x = y

Jump(End)

边缘列表：

● BL2>B3

4\. B2

A:

y = 100

x = y

边缘列表：

● B3

5\. B3

End:

返回(x)

边缘列表：

● EXIT

6\. EXIT. 无外部边缘。

返回文本

这里，控制流图中的节点以列表形式展示。我们给出每个节点的内容，然后列出其外部边缘。

1\. ENTRY

边缘列表：

● B0

2\. B0

y = foo()

x = y

JumpIfNotZero(arg, End)

边缘列表：

● B1

● B2

3\. B1

y = 10

边缘列表：

● B2

4\. B2

End:

返回(x)

边缘列表：

● EXIT

5\. EXIT. 无外部边缘。

返回文本

这里，控制流图中的节点以列表形式展示。我们给出每个节点的内容，然后列出其外部边缘。

1\. ENTRY

边缘列表：

● B0

2\. B0

y = 3

边缘列表：

● B1

3\. B1

Loop:

x = process(y)

y = 4

JumpIfNotZero(x, Loop)

边缘列表：

● B1

● B2

4\. B2

返回(x)

边缘列表：

● EXIT

5\. EXIT. 无外部边缘。

返回文本

这里控制流图中的节点以列表形式呈现。我们给出每个节点的内容，然后是其注释，再列出其外向边。

1\. ENTRY

注释：空集

边列表：

● B0

2\. B0

y = 3

注释：{ y = 3 }

边列表：

● B1

3\. B1

Loop:

x = process(y)

y = 4

JumpIfNotZero(x, Loop)

注释：{ y = 3, y = 4 }

边列表：

● B1

● B2

4\. B2

Return(x)

注释：{ y = 3, y = 4 }

边列表：

● EXIT

5\. EXIT。没有注释。没有外向边。

返回文本

这里控制流图中的节点以列表形式呈现。我们给出每个节点的内容，然后是其注释，再列出其外向边。

1\. ENTRY

注释：空集

边列表：

● B0

2\. B0

y = 3

注释：{ y = 3 }

边列表：

● B1

3\. B1

Loop:

x = process(y)

y = 4

JumpIfNotZero(x, Loop)

注释：{ y = 4 }

边列表：

● B1

● B2

4\. B2

Return(x)

注释：{ y = 4 }

边列表：

● EXIT

5\. EXIT。没有注释。没有外向边。

返回文本

这里控制流图中的节点以列表形式呈现。我们给出每个节点的内容，然后列出其外向边。

1\. ENTRY

边列表：

● B0

2\. B0

x = 10

JumpIfNotZero(arg, A)

边列表：

● B1

● B2

3\. B1

Return(0)

边列表：

● EXIT

4\. B2

A:

Return(x)

边列表：

● EXIT

5\. EXIT。没有外向边。

返回文本

这里控制流图中的节点以列表形式呈现。我们给出每个节点的内容，然后列出其外向边。

1\. ENTRY

边列表：

● B0

2\. B0

x = 10

JumpIfNotZero(arg, A)

边列表：

● B1

● B2

3\. B1

x = f()

Return(x)

边列表：

● EXIT

4\. B2

A:

x = g()

Return(x)

边列表：

● EXIT

5\. EXIT。没有外向边。

返回文本

一个流程图展示了编译器的各个阶段，包括汇编生成阶段中新增加的步骤。

1\. 词法分析器将 program.c 转换为标记列表。

2\. 解析器将标记列表转换为抽象语法树。

3\. 语义分析将 AST 转换为转换后的 AST。它有三个步骤：

a. 标识符解析

b. 类型检查

c. 循环标记

4\. TACKY 生成将转换后的 AST 转换为 TACKY。

5\. 优化将 TACKY 转变为优化后的 TACKY。它有四个步骤：

a. 常量折叠

b. 不可达代码消除

c. 复制传播

d. 死存储消除

一个箭头从每个步骤指向下一个步骤。另一个箭头从死存储消除回到常量折叠。

6\. 汇编生成将优化后的 TACKY 转换为汇编。它有三个步骤：

a. 将 TACKY 转换为汇编

b. 寄存器分配（一个新步骤）

c. 替换伪操作数

d. 指令修正

7\. 代码生成将汇编写入 program.s。

返回文本

一个无向图，包含五个节点，标记为 A 到 E。每个节点被涂成黑色、白色或灰色。C 位于中心。A、B、D 和 E 被排列在 C 的四周。A 在上方，B 在左侧，D 在右侧，E 在下方。围绕 C 的四个节点形成菱形，并且都与 C 相连。C 为黑色。A 和 E 为白色。B 和 D 为灰色。

图形在此也以节点列表的形式呈现。每个节点的邻居及其颜色都列在下面。

● A，白色，上方。邻居：

○ B，灰色

○ C，黑色

○ D，灰色

● B，灰色，左侧。邻居：

○ A，白色

○ C，黑色

○ E，白色

● C，黑色，中心。邻居：

○ A，白色

○ B，灰色

○ D，灰色

○ E，白色

● D，灰色，右侧。邻居：

○ A，白色

○ C，黑色

○ E，白色

● E，白色，下方。邻居：

○ B，灰色

○ C，黑色

○ D，灰色

返回文本

一个无向图，包含七个节点。四个硬件寄存器：EDI、ESI、EAX 和 EDX。三个伪寄存器：a、b 和 tmp。

所有节点除了 tmp 都排列成一个圆圈。a 和 b 在圆圈的右侧。tmp 位于 b 的右侧。图后的文字总结了边的情况。

这里图被展示为一个节点列表。每个节点的邻居被列在它下面。

● EDI。邻居：

○ ESI

○ EAX

○ EDX

● ESI。邻居：

○ EDI

○ EAX

○ EDX

○ a

● EAX。邻居：

○ EDI

○ ESI

○ EDX

○ b

● EDX。邻居：

○ ESI

○ EDI

○ EAX

○ b

● a。邻居：

○ ESI

○ b

● b. 邻居：

○ EAX

○ EDX

○ a

○ tmp

● tmp。邻居：

○ b

返回文本

三个图。每个图展示了图 20-2 中的图形，并为节点着色。颜色有黑色、白色、灰色和条纹色。对于每个图，我们总结了节点的颜色，然后列出每个节点、它的颜色以及它的邻居的颜色。

● 第一个图。EDI 和 b 为条纹色。ESI 为黑色。EAX 和 tmp 为白色。EDX 和 a 为灰色。

○ EDI，条纹色。邻居：

● ESI，黑色

● EAX，白色

● EDX，灰色

○ ESI，黑色。邻居：

● EDI，条纹色

● EAX，白色

● EDX，灰色

● a，灰色

○ EAX，白色。邻居：

● EDI，条纹色

● ESI，黑色

● EDX，灰色

● b，条纹色

○ EDX，灰色。邻居：

● EDI，条纹色

● ESI，黑色

● EAX，白色

● b，条纹色

○ a，灰色。邻居：

● ESI，黑色

● b，条纹色

○ b，条纹色。邻居：

● EAX，白色

● EDX，灰色

● a，灰色

● tmp，白色

○ tmp，白色。邻居：

● b，条纹色

● 第二个图。EDI 为黑色。ESI 和 b 为灰色。EAX、a 和 tmp 为条纹色。EDX 为白色。

○ EDI，黑色。邻居：

● ESI，灰色

● EAX，条纹色

● EDX，白色

○ ESI，灰色。邻居：

● EDI，黑色

● EAX，条纹色

● EDX，白色

● a，条纹色

○ EAX，条纹色。邻居：

● EDI，黑色

● ESI，灰色

● EDX，白色

● b，灰色

○ EDX，白色。邻居：

● EDI，黑色

● ESI，灰色

● EAX，条纹色

● b，灰色

○ a，条纹色。邻居：

● ESI，灰色

● b，灰色

○ b，灰色。邻居：

● EAX，条纹色

● EDX，白色

● a，条纹色

● tmp，条纹色

○ tmp，条纹色。邻居：

● b，灰色

● 第三个图。EDI 和 a 为灰色。ESI 和 b 为白色。EAX 为条纹色。EDX 和 tmp 为黑色。

○ EDI，灰色。邻居：

● ESI，白色

● EAX，条纹色

● EDX，黑色

○ ESI，白色。邻居：

● EDI，灰色

● EAX，条纹

● EDX，黑色

● a，灰色

○ EAX，条纹。邻居：

● EDI，灰色

● ESI，白色

● EDX，黑色

● b，白色

○ EDX，黑色。邻居：

● EDI，灰色

● ESI，白色

● EAX，条纹

● b，白色

○ a，灰色。邻居：

● ESI，白色

● b，白色

○ b，白色。邻居：

● EAX，条纹

● EDX，黑色

● a，灰色

● tmp，黑色

○ tmp，黑色。邻居：

● b，白色

返回文本

一个无向图，包含七个节点。四个硬件寄存器：EDI、ESI、EAX 和 EDX，三个伪寄存器：arg1、arg2 和 tmp。

节点排列在四行中。第一行：EDI 和 ESI。第二行：EAX 和 EDX。第三行：arg1 和 arg2。最后一行：tmp。

所有四个硬件寄存器都是邻居。EAX 和 EDX 都是三个伪寄存器的邻居。这三个伪寄存器是邻居。arg1 还与 ESI 相邻。

图形也以节点列表的形式呈现。

● EDI. 邻居：

○ ESI

○ EAX

○ EDX

● ESI. 邻居：

○ EDI

○ EAX

○ EDX

○ arg1

● EAX. 邻居：

○ EDI

○ ESI

○ EDX

○ arg1

○ arg2

○ tmp

● EDX. 邻居：

○ EDI

○ ESI

○ EAX

○ arg1

○ arg2

○ tmp

● arg1

○ ESI

○ EAX

○ EDX

○ arg2

○ tmp

● arg2

○ EAX

○ EDX

○ arg1

○ tmp

● tmp

○ EAX

○ EDX

○ arg1

○ arg2

返回文本

从图 20-4 中删除 tmp 后的图形。每个剩余的节点都有颜色。EDI 和 arg1 是白色的，ESI 和 arg2 是灰色的，EAX 是黑色的，EDX 是条纹的。

所有四个硬件寄存器都是邻居。EAX 和 EDX 都是 arg1 和 arg2 的邻居。arg1 和 arg2 是邻居。arg1 还与 ESI 相邻。

图形也以节点列表的形式呈现。

● EDI，白色。邻居：

○ ESI，灰色

○ EAX，黑色

○ EDX，条纹

● ESI，灰色。邻居：

○ EDI，白色

○ EAX，黑色

○ EDX，条纹

○ arg1，白色

● EAX，黑色

○ EDI，白色

○ ESI，灰色

○ EDX，条纹

○ arg1，白色

○ arg2，灰色

● EDX，条纹。邻居：

○ EDI，白色

○ ESI，灰色

○ EAX，黑色

○ arg1，白色

○ arg2，灰色

● arg1，白色

○ ESI，灰色

○ EAX，黑色

○ EDX，条纹

○ arg2，灰色

● arg2，灰色

○ EAX，黑色

○ EDX，条纹

○ arg1，白色

返回文本

图形有十二个节点，按圆形排列，每个寄存器一个。每个寄存器与其他 11 个寄存器互相干扰。

返回文本

图形中有八个节点，标记为 A 到 H。它们按顺序排列成三行。第一行包含 A 和 B，第二行包含 C、D 和 E，第三行包含 F、G 和 H。

图形以节点列表的形式呈现。

● A. 邻居：

○ B

○ C

○ D

○ E

● B. 邻居：

○ A

○ E

● C. 邻居：

○ A

○ D

● D. 邻居：

○ A

○ C

○ E

○ F

○ G

● E. 邻居：

○ A

○ B

○ D

○ G

● F. 邻居：

○ D

○ G

● G. 邻居：

○ D

○ E

○ F

○ H

● H. 邻居：

○ G

返回文本

图中的所有节点和边都与图 20-7 中的位置相同。剪枝的节点是带虚线边框的圆圈。任何端点已被剪枝的边是虚线。剩余的节点是带实线边框的圆圈，剩余的边是实线。

A、D、E 和 G 保留在图中。在剩余的图中，A、D 和 E 都是邻居，D 和 E 也是 G 的邻居。

包括已修剪节点在内的完整图呈现为列表。

● A，剩余。邻居：

○ B，已修剪

○ C，已修剪

○ D，剩余

○ E，剩余

● B，已修剪。邻居：

○ A，剩余

○ E，剩余

● C，已修剪。邻居：

○ A，剩余

○ D，剩余

● D，剩余。邻居：

○ A，剩余

○ C，已修剪

○ E，剩余

○ F，已修剪

○ G，剩余

● E，剩余。邻居：

○ A，剩余

○ B，已修剪

○ D，剩余

○ G，剩余

● F，已修剪。邻居：

○ D，剩余

○ G，剩余

● G，剩余。邻居：

○ D，剩余

○ E，剩余

○ F，已修剪

○ H，已修剪

● H，已修剪。邻居：

○ G，剩余

堆栈内容，从上到下：

● H

● F

● C

● B

返回文本

图中的所有节点和边与图 20-7 中的位置相同。修剪过的节点有虚线边框。任何端点被修剪的边为虚线。剩余节点有实线边框，剩余的边为实线。

D 和 E 保留在图中。它们是邻居。

包括已修剪节点在内的完整图呈现为列表。

● A，已修剪。邻居：

○ B，已修剪

○ C，已修剪

○ D，剩余

○ E，剩余

● B，已修剪。邻居：

○ A，已修剪

○ E，剩余

● C，已修剪。邻居：

○ A，已修剪

○ D，剩余

● D，剩余。邻居：

○ A，已修剪

○ C，已修剪

○ E，剩余

○ F，已修剪

○ G，已修剪

● E，剩余。邻居：

○ A，已修剪

○ B，已修剪

○ D，剩余

○ G，已修剪

● F，已修剪。邻居：

○ D，剩余

○ G，已修剪

● G，已修剪。邻居：

○ D，剩余

○ E，剩余

○ F，已修剪

○ H，已修剪

● H，已修剪。邻居：

○ G，已修剪

堆栈内容，从上到下：

● G

● A

● H

● F

● C

● B

返回文本

图中的所有节点和边与图 20-7 中的位置相同。所有节点的边框为虚线，所有边为虚线，表示它们已从图中修剪。

堆栈内容，从上到下：

● E

● D

● G

● A

● H

● F

● C

● B

返回文本

显示了九张图。每张图都展示了图和堆栈。在每张图中，图中的所有节点和边都与图 20-7 中的位置相同。修剪的节点有虚线边框，任何端点被修剪的边为虚线。

被放回的节点为白色、黑色或灰色，并具有实线边框。两个端点都被放回的边为实线。对于每张图，我们给出一个总结。然后描述完整的图，包括修剪过的节点。接着描述堆栈。

● 第一张图。该图与图 20-10 完全相同。所有节点已被修剪。

堆栈内容，从上到下：

○ E

○ D

○ G

○ A

○ H

○ F

○ C

○ B

● 第二张图。E 被弹出堆栈。E 是图中唯一的节点，它是白色的。

完整图，以列表形式展示：

○ A，已修剪。邻居：

● B，已修剪

● C，已修剪

● D，已修剪

● E，白色

○ B，已修剪。邻居：

● A，已修剪

● E, 白色

○ C, 剪枝。邻居：

● A, 剪枝

● D, 剪枝

○ D, 剪枝。邻居：

● A, 剪枝

● C, 剪枝

● E, 白色

● F, 剪枝

● G, 剪枝

○ E, 白色。邻居：

● A, 剪枝

● B, 剪枝

● D, 剪枝

● G, 剪枝

○ F, 剪枝。邻居：

● D, 剪枝

● G, 剪枝

○ G, 剪枝。邻居：

● D, 剪枝

● E, 白色

● F, 剪枝

● H, 剪枝

○ H, 剪枝。邻居：

● G, 剪枝

栈内容，从上到下：

○ D

○ G

○ A

○ H

○ F

○ C

○ B

第三个图。D 被弹出栈。图中有两个节点：D 为灰色，E 为白色。它们是邻居。

完整图，作为列表：

○ A, 剪枝。邻居：

● B, 剪枝

● C, 剪枝

● D, 灰色

● E, 白色

○ B, 剪枝。邻居：

● A, 剪枝

● E, 白色

○ C, 剪枝。邻居：

● A, 剪枝

● D, 灰色

○ D, 灰色。邻居：

● A, 剪枝

● C, 剪枝

● E, 白色

● F, 剪枝

● G, 剪枝

○ E, 白色。邻居：

● A, 剪枝

● B, 剪枝

● D, 灰色

● G, 剪枝

○ F, 剪枝。邻居：

● D, 灰色

● G, 剪枝

○ G, 剪枝。邻居：

● D, 灰色

● E, 白色

● F, 剪枝

● H, 剪枝

○ H, 剪枝。邻居：

● G, 剪枝

栈内容，从上到下：

○ G

○ A

○ H

○ F

○ C

○ B

第四个图。G 被弹出栈。图中有三个节点：G 为黑色，D 为灰色，E 为白色。它们是彼此的邻居。

完整图，作为列表：

○ A, 剪枝。邻居：

● B, 剪枝

● C, 剪枝

● D, 灰色

● E, 白色

○ B, 剪枝。邻居：

● A, 剪枝

● E, 白色

○ C, 剪枝。邻居：

● A, 剪枝

● D, 灰色

○ D, 灰色。邻居：

● A, 剪枝

● C, 剪枝

● E, 白色

● F, 剪枝

● G, 黑色

○ E, 白色。邻居：

● A, 剪枝

● B, 剪枝

● D, 灰色

● G, 黑色

○ F, 剪枝。邻居：

● D, 灰色

● G, 黑色

○ G, 黑色。邻居：

● D, 灰色

● E, 白色

● F, 剪枝

● H, 剪枝

○ H, 剪枝。邻居：

● G, 黑色

栈内容，从上到下：

○ A

○ H

○ F

○ C

○ B

第五个图。A 被弹出栈并添加到图中。A 为黑色。它与 D（灰色）和 E（白色）相邻。与之前的图没有其他变化。

完整图，作为列表：

○ A, 黑色。邻居：

● B, 剪枝

● C, 剪枝

● D, 灰色

● E, 白色

○ B, 剪枝。邻居：

● A, 黑色

● E, 白色

○ C, 剪枝。邻居：

● A, 黑色

● D, 灰色

○ D, 灰色。邻居：

● A, 黑色

● C, 剪枝

● E, 白色

● F, 剪枝

● G, 黑色

○ E, 白色。邻居：

● A, 黑色

● B, 剪枝

● D, 灰色

● G, 黑色

○ F, 剪枝。邻居：

● D, 灰色

● G, 黑色

○ G, 黑色。邻居：

● D, 灰色

● E, 白色

● F, 剪枝

● H, 剪枝

○ H, 剪枝。邻居：

● G, 黑色

栈内容，从上到下：

○ H

○ F

○ C

○ B

第六个图。H 被弹出栈并添加到图中。H 为白色。它与 G（黑色）相邻。与之前的图没有其他变化。

完整图，作为列表：

○ A, 黑色。邻居：

● B, 剪枝

● C, 剪枝

● D, 灰色

● E, 白色

○ B, 剪枝。邻居：

● A, 黑色

● E, 白色

○ C, 剪枝。邻居：

● A, 黑色

● D, 灰色

○ D, 灰色。邻居：

● A, 黑色

● C, 剪枝

● E, 白色

● F, 剪枝

● G, 黑色

○ E, 白色。邻居：

● A, 黑色

● B, 剪枝

● D, 灰色

● G, 黑色

○ F, 剪枝。邻居：

● D, 灰色

● G, 黑色

○ G, 黑色。邻居：

● D，灰色

● E，白色

● F，已修剪

● H，白色

○ H，白色。邻居：

● G，黑色

栈内容，从上到下：

○ F

○ C

○ B

● 第七个图。F 从栈中弹出并添加到图中，变为白色。它的邻居是 D（灰色）和 G（黑色）。与上一个图相比没有其他变化。

完整图，作为列表：

○ A，黑色。邻居：

● B，已修剪

● C，已修剪

● D，灰色

● E，白色

○ B，已修剪。邻居：

● A，黑色

● E，白色

○ C，已修剪。邻居：

● A，黑色

● D，灰色

○ D，灰色。邻居：

● A，黑色

● C，已修剪

● E，白色

● F，白色

● G，黑色

○ E，白色。邻居：

● A，黑色

● B，已修剪

● D，灰色

● G，黑色

○ F，白色。邻居：

● D，灰色

● G，黑色

○ G，黑色。邻居：

● D，灰色

● E，白色

● F，白色

● H，白色

○ H，白色。邻居：

● G，黑色

栈内容，从上到下：

○ C

○ B

● 第八个图。C 从栈中弹出并添加到图中，变为白色。它的邻居是 A（黑色）和 D（灰色）。与上一个图相比没有其他变化。

完整图，作为列表：

○ A，黑色。邻居：

● B，已修剪

● C，白色

● D，灰色

● E，白色

○ B，已修剪。邻居：

● A，黑色

● E，白色

○ C，白色。邻居：

● A，黑色

● D，灰色

○ D，灰色。邻居：

● A，黑色

● C，白色

● E，白色

● F，白色

● G，黑色

○ E，白色。邻居：

● A，黑色

● B，已修剪

● D，灰色

● G，黑色

○ F，白色。邻居：

● D，灰色

● G，黑色

○ G，黑色。邻居：

● D，灰色

● E，白色

● F，白色

● H，白色

○ H，白色。邻居：

● G，黑色

栈内容：

○ B

● 第九个图。B 从栈中弹出并添加到图中，变为灰色。它的邻居是 A（黑色）和 E（白色）。与上一个图相比没有其他变化。

完整图，作为列表：

○ A，黑色。邻居：

● B，灰色

● C，白色

● D，灰色

● E，白色

○ B，灰色。邻居：

● A，黑色

● E，白色

○ C，白色。邻居：

● A，黑色

● D，灰色

○ D，灰色。邻居：

● A，黑色

● C，白色

● E，白色

● F，白色

● G，黑色

○ E，白色。邻居：

● A，黑色

● B，灰色

● D，灰色

● G，黑色

○ F，白色。邻居：

● D，灰色

● G，黑色

○ G，黑色。邻居：

● D，灰色

● E，白色

● F，白色

● H，白色

○ H，白色。邻居：

● G，黑色

栈为空。

返回文本

一个无向图，有六个节点，标记为 A 到 F。A、B、D 和 E 围绕 C 排列。

A 在顶部，B 在左侧，D 在右侧，E 在底部。F 在 E 下方。围绕 C 的四个节点连接成菱形。所有四个节点也都与 C 相连。F 与 B、D 和 E 相连。

作为节点列表：

● A。邻居：

○ B

○ C

○ D

● B。邻居：

○ A

○ C

○ E

○ F

○ C。邻居：

○ A

○ B

○ D

○ E

● D。邻居：

○ A

○ C

○ E

● E。邻居：

○ B

○ C

○ D

○ F

● F。邻居：

○ B

○ D

○ E

返回文本

显示了六个图。每个图都展示了图和栈的状态。在每个图中，图中的所有节点和边都与图 20-12 中的位置相同。

已修剪的节点有虚线边框。任何端点已修剪的边缘是虚线。已恢复的节点是白色、黑色或灰色，并且具有实线边框。两端都恢复的边缘是实线。

对于每张图，我们给出一个总结。然后我们描述完整的图形，包括已修剪的节点。然后我们描述栈。

● 第一张图。所有节点都有虚线边框，所有边缘都是虚线，表示它们已经从图形中修剪掉。

完整图形，作为列表：

○ A，已修剪。邻居：

● B，已修剪

● C，已修剪

● D，已修剪

○ B，已修剪。邻居：

● A，已修剪

● C，已修剪

● E，已修剪

● F，已修剪

○ C，已修剪。邻居：

● A，已修剪

● B，已修剪

● D，已修剪

● E，已修剪

○ D，已修剪。邻居：

● A，已修剪

● C，已修剪

● E，已修剪

● F，已修剪

○ E，已修剪。邻居：

● B，已修剪

● C，已修剪

● D，已修剪

● F，已修剪

○ F，已修剪。邻居：

● B，已修剪

● D，已修剪

● E，已修剪

栈内容，从上到下：

○ F

○ E

○ D

○ B

○ A

○ C

● 第二张图。F 从栈中弹出。它是图中唯一的节点，且为白色。

完整图形，作为列表：

○ A，已修剪。邻居：

● B，已修剪

● C，已修剪

● D，已修剪

○ B，已修剪。邻居：

● A，已修剪

● C，已修剪

● E，已修剪

● F，白色

○ C，已修剪。邻居：

● A，已修剪

● B，已修剪

● D，已修剪

● E，已修剪

○ D，已修剪。邻居：

● A，已修剪

● C，已修剪

● E，已修剪

● F，白色

○ E，已修剪。邻居：

● B，已修剪

● C，已修剪

● D，已修剪

● F，白色

○ F，白色。邻居：

● B，已修剪

● D，已修剪

● E，已修剪

栈内容，从上到下：

○ E

○ D

○ B

○ A

○ C

● 第三张图。E 从栈中弹出，图中有两个节点：E，灰色，和 F，白色。它们是邻居。

完整图形，作为列表：

○ A，已修剪。邻居：

● B，已修剪

● C，已修剪

● D，已修剪

○ B，已修剪。邻居：

● A，已修剪

● C，已修剪

● E，灰色

● F，白色

○ C，已修剪。邻居：

● A，已修剪

● B，已修剪

● D，已修剪

● E，灰色

○ D，已修剪。邻居：

● A，已修剪

● C，已修剪

● E，灰色

● F，白色

○ E，灰色。邻居：

● B，已修剪

● C，已修剪

● D，已修剪

● F，白色

○ F，白色。邻居：

● B，已修剪

● D，已修剪

● E，灰色

栈内容，从上到下：

○ D

○ B

○ A

○ C

● 第四张图。D 从栈中弹出，图中有三个节点：D，黑色，E，灰色，以及 F，白色。它们是邻居。

完整图形，作为列表：

○ A，已修剪。邻居：

● B，已修剪

● C，已修剪

● D，黑色

○ B，已修剪。邻居：

● A，已修剪

● C，已修剪

● E，灰色

● F，白色

○ C，已修剪。邻居：

● A，已修剪

● B，已修剪

● D，黑色

● E，灰色

○ D，黑色。邻居：

● A，已修剪

● C，已修剪

● E，灰色

● F，白色

○ E，灰色。邻居：

● B，已修剪

● C，已修剪

● D，黑色

● F，白色

○ F，白色。邻居：

● B，已修剪

● D，黑色

● E，灰色

栈内容，从上到下：

○ B

○ A

○ C

● 第五张图。B 从栈中弹出并加入图中。它是黑色的。它与 E，灰色，和 F，白色是邻居。与上一张图没有其他变化。

完整图形，作为列表：

○ A，已修剪。邻居：

● B，黑色

● C，已修剪

● D，黑色

○ B，黑色。邻居节点：

● A，已修剪

● C，已修剪

● E，灰色

● F，白色

○ C，已修剪。邻居节点：

● A，已修剪

● B，黑色

● D，黑色

● E，灰色

○ D，黑色。邻居节点：

● A，已修剪

● C，已修剪

● E，灰色

● F，白色

○ E，灰色。邻居节点：

● B，黑色

● C，已修剪

● D，黑色

● F，白色

○ F，白色。邻居节点：

● B，黑色

● D，黑色

● E，灰色

栈内容，从上到下：

○ A

○ C

● 第六个图示。A 被从栈中弹出并加入到图中。它是白色的。它是 B，黑色的邻居，也是 D，黑色的邻居。与前一个图示相比没有其他变化。

完整图示，列表形式：

○ A，白色。邻居节点：

● B，黑色

● C，已修剪

● D，黑色

○ B，黑色。邻居节点：

● A，白色

● C，已修剪

● E，灰色

● F，白色

○ C，已修剪。邻居节点：

● A，白色

● B，黑色

● D，黑色

● E，灰色

○ D，黑色。邻居节点：

● A，白色

● C，已修剪

● E，灰色

● F，白色

○ E，灰色。邻居节点：

● B，黑色

● C，已修剪

● D，黑色

● F，白色

○ F，白色。邻居节点：

● B，黑色

● D，黑色

● E，灰色

栈内容：

○ C

返回文本

展示了七个图示。每个图示都显示了图和栈。在每个图示中，所有节点和边的位置与图 20-12 中相同。

已放回的节点被标记为白色、黑色或灰色。已修剪和已上色的节点与图 20-13 中的表示方式相同。

对于每个图示，我们提供了总结。然后描述完整图示，包括已修剪的节点。接着描述栈内容。

● 第一个图示。所有节点的边框为虚线，所有边为虚线，表示它们已从图中修剪掉。

栈内容，从上到下：

○ D

○ E

○ F

○ B

○ A

○ C

● 第二个图示。D 被从栈中弹出。它是图中唯一的节点，颜色为白色。

完整图示，列表形式：

○ A，已修剪。邻居节点：

● B，已修剪

● C，已修剪

● D，白色

○ B，已修剪。邻居节点：

● A，已修剪

● C，已修剪

● E，已修剪

● F，已修剪

○ C，已修剪。邻居节点：

● A，已修剪

● B，已修剪

● D，白色

● E，已修剪

○ D，白色。邻居节点：

● A，已修剪

● C，已修剪

● E，已修剪

● F，已修剪

○ E，已修剪。邻居节点：

● B，已修剪

● C，已修剪

● D，白色

● F，已修剪

○ F，已修剪。邻居节点：

● B，已修剪

● D，白色

● E，已修剪

栈内容，从上到下：

○ E

○ F

○ B

○ A

○ C

● 第三个图示。E 被从栈中弹出。图中有两个节点：E，灰色和 D，白色。它们是邻居节点。

完整图示，列表形式：

○ A，已修剪。邻居节点：

● B，已修剪

● C，已修剪

● D，白色

○ B，已修剪。邻居节点：

● A，已修剪

● C，已修剪

● E，灰色

● F，已修剪

○ C，已修剪。邻居节点：

● A，已修剪

● B，已修剪

● D，白色

● E，灰色

○ D，白色。邻居节点：

● A，已修剪

● C，已修剪

● E，灰色

● F，已修剪

○ E，灰色。邻居节点：

● B，已修剪

● C，已修剪

● D，白色

● F，已修剪

○ F，已修剪。邻居节点：

● B，已修剪

● D，白色

● E，灰色

栈内容，从上到下：

○ F

○ B

○ A

○ C

● 第四个图示。F 被从栈中弹出。图中有三个节点：F，黑色；E，灰色；D，白色。它们都是邻居节点。

完整图示，列表形式：

○ A，已修剪。邻居节点：

● B，已修剪

● C，已修剪

● D，白色

○ B，已修剪。邻居节点：

● A，已修剪

● C, 剪枝

● E, 灰色

● F, 黑色

○ C, 剪枝。邻居：

● A, 剪枝

● B, 剪枝

● D, 白色

● E, 灰色

○ D, 白色。邻居：

● A, 剪枝

● C, 剪枝

● E, 灰色

● F, 黑色

○ E, 灰色。邻居：

● B, 剪枝

● C, 剪枝

● D, 白色

● F, 黑色

○ F, 黑色。邻居：

● B, 剪枝

● D, 白色

● E, 灰色

栈内容，从上到下：

○ B

○ A

○ C

● 第五个图。B 被从栈中弹出并添加到图中。它是白色的。它的邻居是 E（灰色）和 F（黑色）。与前一个图没有其他变化。

完整图，列表形式：

○ A, 剪枝。邻居：

● B, 白色

● C, 剪枝

● D, 白色

○ B, 白色。邻居：

● A, 剪枝

● C, 剪枝

● E, 灰色

● F, 黑色

○ C, 剪枝。邻居：

● A, 剪枝

● B, 白色

● D, 白色

● E, 灰色

○ D, 白色。邻居：

● A, 剪枝

● C, 剪枝

● E, 灰色

● F, 黑色

○ E, 灰色。邻居：

● B, 白色

● C, 剪枝

● D, 白色

● F, 黑色

○ F, 黑色。邻居：

● B, 白色

● D, 白色

● E, 灰色

栈内容，从上到下：

○ A

○ C

● 第六个图。A 被从栈中弹出并添加到图中。它是灰色的。它的邻居是 B（白色）和 D（白色）。与前一个图没有其他变化。

完整图，列表形式：

○ A, 灰色。邻居：

● B, 白色

● C, 剪枝

● D, 白色

○ B, 白色。邻居：

● A, 灰色

● C, 剪枝

● E, 灰色

● F, 黑色

○ C, 剪枝。邻居：

● A, 灰色

● B, 白色

● D, 白色

● E, 灰色

○ D, 白色。邻居：

● A, 灰色

● C, 剪枝

● E, 灰色

● F, 黑色

○ E, 灰色。邻居：

● B, 白色

● C, 剪枝

● D, 白色

● F, 黑色

○ F, 黑色。邻居：

● B, 白色

● D, 白色

● E, 灰色

栈内容，从上到下：

○ C

● 第七个图。C 被从栈中弹出并添加到图中。它是黑色的。它的邻居是 A（灰色）、B（白色）、D（白色）和 E（灰色）。与前一个图没有其他变化。

完整图，列表形式：

○ A, 灰色。邻居：

● B, 白色

● C, 黑色

● D, 白色

○ B, 白色。邻居：

● A, 灰色

● C, 黑色

● E, 灰色

● F, 黑色

○ C, 黑色。邻居：

● A, 灰色

● B, 白色

● D, 白色

● E, 灰色

○ D, 白色。邻居：

● A, 灰色

● C, 黑色

● E, 灰色

● F, 黑色

○ E, 灰色。邻居：

● B, 白色

● C, 黑色

● D, 白色

● F, 黑色

○ F, 黑色。邻居：

● B, 白色

● D, 白色

● E, 灰色

栈为空。

返回文本

一个无向图，包含四个节点：EDI、EAX、tmp 和 arg。EDI 与 EAX 相邻。EAX 也与 tmp 相邻。tmp 也与 arg 相邻。

返回文本

一个无向图，包含三个节点：EDI、EAX 和 tmp。三个节点互为邻居。

返回文本

两个图显示了合并前后的干扰图。

● 原始干扰图。一个无向图，包含七个节点。三个硬寄存器：EDI、ESI 和 EAX。四个伪寄存器：tmp1、tmp2、tmp3 和 tmp4。

左边，EDI、ESI 和 EAX 被排列成一个三角形。在它们的右侧，tmp1、tmp2、tmp3 和 tmp4 被排列成一个方形。所有三个硬寄存器都是邻居。EDI 还与 tmp1 相邻。tmp1 还与 tmp2 相邻。tmp2 还与 tmp3 相邻。tmp3 还与 tmp4 相邻。

作为节点列表：

○ EDI。邻居：

● ESI

● EAX

● tmp1

○ ESI。邻居：

● EDI

● EAX

○ EAX。邻居：

● EDI

● ESI

○ tmp1。邻居：

● EDI

● tmp2

○ tmp2。邻居：

● tmp1

● tmp3

○ tmp3。邻居：

● tmp2

● tmp4

○ tmp4。邻居：

● tmp3

● 在将 tmp2 合并到 EAX 后，之前的图发生了三次变化。首先，tmp2 被移除。第二，添加了一条从 tmp1 到 EAX 的边。第三，添加了一条从 tmp3 到 EAX 的边。

图以列表形式展示：

○ EDI。邻居：

● ESI

● EAX

● tmp1

○ ESI。邻居：

● EDI

● EAX

○ EAX。邻居：

● EDI

● ESI

● tmp1

● tmp3

○ tmp1。邻居：

● EDI

● EAX

○ tmp3。邻居：

● EAX

● tmp4

○ tmp4。邻居：

● tmp3

返回文本

两个图展示了合并前后的干扰图。

● 原始干扰图。一个包含五个节点的无向图。三个硬件寄存器：EDI、ESI 和 EAX。两个伪寄存器：tmp1 和 tmp2。在左侧，EDI、ESI 和 EAX 形成一个三角形。它们都是邻居。在右侧，tmp1 位于 tmp2 之上。它们是邻居。

作为节点列表：

○ EDI。邻居：

● ESI

● EAX

○ ESI。邻居：

● EDI

● EAX

○ EAX。邻居：

● EDI

● ESI

○ tmp1。邻居：

● tmp2

○ tmp2。邻居：

● tmp1

● 在将 tmp1 合并到 EDI 后，之前的图发生了两个变化。首先，tmp1 被移除。其次，添加了一条从 tmp2 到 EDI 的边。

图以列表形式展示：

○ EDI。邻居：

● ESI

● EAX

● tmp2

○ ESI。邻居：

● EDI

● EAX

○ EAX。邻居：

● EDI

● ESI

○ tmp2。邻居：

● EDI

返回文本

一个包含七个节点的无向图。三个硬件寄存器：EDI、ESI、EAX。四个伪寄存器：a、x、y 和 z。

EAX、ESI 和 EDI 排列成一个三角形。在它们的右侧，x、y 和 z 排成一个三角形。a 位于图形的顶部。

三个硬件寄存器都是邻居。z 与 x 和 y 为邻。y 也与 EDI 为邻。x、ESI 和 a 都是邻居。

作为节点列表：

● EDI。邻居：

○ ESI

○ EAX

○ y

● ESI。邻居：

○ EDI

○ EAX

○ a

○ x

● EAX。邻居：

○ EDI

○ ESI

● a。邻居：

○ ESI

○ x

● x。邻居：

○ ESI

○ a

○ z

● y。邻居：

○ EDI

○ z

● z。邻居：

○ x

○ y

返回文本

图 20-19 中的图形，发生了三次变化。首先，x 被移除。第二，添加了一条从 a 到 y 的边。第三，添加了一条从 ESI 到 y 的边。

图以节点列表的形式展示。

● EDI。邻居：

○ ESI

○ EAX

○ y

● ESI。邻居：

○ EDI

○ EAX

○ a

○ y

● EAX。邻居：

○ EDI

○ ESI

● a。邻居：

○ ESI

○ y

● y。邻居：

○ EDI

○ ESI

○ a

○ z

● z。邻居：

○ y

返回文本

图以节点列表的形式展示。

● EDI。邻居：

○ ESI

○ EAX

○ a

○ y

● ESI。邻居：

○ EDI

○ EAX

○ a

○ x

● EAX。邻居：

○ EDI

○ ESI

● a。邻居：

○ EDI

○ ESI

○ x

● x。邻居：

○ ESI

○ a

○ z

● y。邻居：

○ EDI

○ z

● z。邻居：

○ x

○ y

返回文本

来自图 20-21 的图，包含三个变化。首先，x 被移除。其次，a 到 y 之间添加了一条边。第三，ESI 到 y 之间添加了一条边。

图以节点列表的形式呈现。

● EDI. 邻居：

○ ESI

○ EAX

○ a

○ y

● ESI. 邻居：

○ EDI

○ EAX

○ a

○ y

● EAX. 邻居：

○ EDI

○ ESI

● a. 邻居：

○ EDI

○ ESI

○ y

● y. 邻居：

○ EDI

○ ESI

○ a

○ z

● z. 邻居：

○ y

返回文本

一个包含五个节点的无向图。三个硬寄存器：EDI、ESI 和 EAX。两个伪寄存器：tmp1 和 tmp2\. EDI、ESI、EAX 和 tmp1 都是邻居。tmp2 和 ESI、EAX 是邻居。

作为节点列表：

● EDI. 邻居：

○ ESI

○ EAX

○ tmp1

● ESI. 邻居：

○ EDI

○ EAX

○ tmp1

○ tmp2

● EAX. 邻居：

○ EDI

○ ESI

○ tmp1

○ tmp2

● tmp1\. 邻居：

○ EDI

○ ESI

○ EAX

● tmp2\. 邻居：

○ ESI

○ EAX

返回文本

一个包含十个节点的无向图。三个硬寄存器：EDI、ESI、EAX。七个伪寄存器：a、b、c、d、x、y 和 z。

EAX、ESI 和 EDI 排成一个三角形。在它们的右侧，x、y 和 z 排成一个三角形。在图的顶部，a 被 b、c 和 d 围绕。

所有三个硬寄存器都是邻居。z 和 x、y 是邻居。y 也和 EDI 是邻居。x、ESI 和 a 都是邻居。a 还与 b、c 和 d 是邻居。

作为节点列表：

● EDI. 邻居：

○ ESI

○ EAX

○ y

● ESI. 邻居：

○ EDI

○ EAX

○ a

○ x

● EAX. 邻居：

○ EDI

○ ESI

● a. 邻居：

○ ESI

○ b

○ c

○ d

○ x

● b. 邻居：

○ a

● c. 邻居：

○ a

● d. 邻居：

○ a

● x. 邻居：

○ ESI

○ a

○ z

● y. 邻居：

○ EDI

○ z

● z. 邻居：

○ x

○ y

返回文本

上述图有三个变化。首先，x 被移除。其次，a 到 y 之间添加了一条边。第三，ESI 到 y 之间添加了一条边。

图以节点列表的形式呈现。

● EDI. 邻居：

○ ESI

○ EAX

○ y

● ESI. 邻居：

○ EDI

○ EAX

○ a

○ y

● EAX. 邻居：

○ EDI

○ ESI

● a. 邻居：

○ ESI

○ b

○ c

○ d

○ y

● b. 邻居：

○ a

● c. 邻居：

○ a

● d. 邻居：

○ a

● y. 邻居：

○ EDI

○ ESI

○ a

○ z

● z. 邻居：

○ y

返回文本

一个终端的截图。顶部窗口显示“寄存器值不可用”的消息。中间窗口显示了来自列表 A-1 的前十条指令及其内存地址。底部窗口显示了刚刚输入的“layout reg”命令。

返回文本

一个终端的截图。顶部窗口显示了八字节通用寄存器和一些其他寄存器的值，以十进制和十六进制表示。中间窗口显示了来自列表 A-1 的前十条指令及其内存地址。第三条指令，“sub $0x10, %rsp”，被高亮显示。底部窗口显示了前两条命令及其输出。

返回文本
