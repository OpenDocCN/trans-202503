<hgroup>

# <samp class="SANS_Dogma_OT_Bold_B_11">下一步</samp>

</hgroup>

![](img/opener-img.jpg)

编程语言的世界很广阔，你还有很多东西可以探索。自己扩展编译器是一个很好的方式，继续学习你最感兴趣的主题。

我将给你一些思路，帮助你开始。

## <samp class="SANS_Futura_Std_Bold_B_11">添加一些缺失的特性</samp>

最明显的下一步是实现这本书没有涵盖的 C 的主要部分。如果你已经有了特别想要添加的特性列表，从那些开始。然后，如果你想继续下去，选择一个实际的 C 程序——想想一个小的程序，不是 Linux 内核——并扩展你的编译器，直到它能够成功编译该程序。你可以选择另一个程序，并重复这个过程，直到你对自己实现的语言部分感到满意。确保一次添加一个新的语言特性，在继续下一个之前彻底测试每一个。

## <samp class="SANS_Futura_Std_Bold_B_11">安全处理未定义行为</samp>

我们已经看到，C 编译器可以随意处理未定义行为。但仅仅因为你*可以*做某件事，并不意味着你*应该*做。以一种清晰、可预测的方式处理未定义行为有巨大的好处：它使 C 程序更加安全，调试更加容易，并且总体上不那么可怕。例如，你可以保证有符号整数溢出总是会回绕（这就是 <samp class="SANS_TheSansMonoCd_W5Regular_11">-fwrapv</samp> 编译器选项的作用）。或者你可以让程序在遇到未定义行为时抛出错误并退出；Clang 和 GCC 都有一个叫做 UndefinedBehaviorSanitizer 的特性，支持这种错误处理（*[`<wbr>clang<wbr>.llvm<wbr>.org<wbr>/docs<wbr>/UndefinedBehaviorSanitizer<wbr>.html`](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html)*）。

想想我们在本书中讨论过的一些未定义行为的例子。你认为你的编译器应该如何处理这些？这会如何影响你实现的任何优化？某些类型的未定义行为很难检测，但其他类型则不太难处理；选择一个看起来可以处理的例子，看看你是否能干净地处理它。

## <samp class="SANS_Futura_Std_Bold_B_11">编写更多 TACKY 优化</samp>

第十九章仅介绍了你在生产级编译器中会遇到的一些 IR 优化。如果你愿意，你可以自己实现更多。做一些关于常见编译器优化的研究，并挑选出最有趣的那些。如果你走这条路，你可能想将你的 TACKY 代码转换为*静态单赋值（SSA）形式*，在这种形式下，每个变量只会被定义一次。SSA 形式在现实世界的编译器中被广泛使用，包括 Clang 和 GCC，因为它使得许多优化的实现更加容易。

## <samp class="SANS_Futura_Std_Bold_B_11">支持另一个目标架构</samp>

大多数生产级编译器都有多个不同的后端，以支持不同的目标架构。

你可以使用相同的策略，根据你所针对的系统将 TACKY 转换为不同的汇编代码。如果你使用 Windows 或 ARM 系统，并且需要一个虚拟化或仿真层来完成这个项目，一个新的后端将让你编译出能在本机上原生运行的代码。

如果你为 Windows 添加了支持，你将能够重用大部分现有的代码生成过程。唯一不同的就是 ABI。添加 ARM 后端是一个更具挑战性的项目；你需要学习一个全新的指令集。

## <samp class="SANS_Futura_Std_Bold_B_11">为一个开源编程语言项目做贡献</samp>

改进你自己的编译器是学习的好方法，但也可以考虑扩展到其他项目上。许多广泛使用的编译器都是开源的，并欢迎新的贡献者。其他相关项目，比如解释器、代码检查工具和静态分析工具，也都如此。选择一个你喜欢的，了解如何参与进来。这是一个很好的方式来应用你学到的新技能，也许还能让你最喜欢的编程语言变得更快、更安全、更易用，或者更容易学习。

## <samp class="SANS_Futura_Std_Bold_B_11">结束语！</samp>

我希望这本书为你打下了继续构建编译器和编程语言的基础。我也希望它改变了你对日常使用的编程语言的看法。现在你会更能欣赏那些编程语言背后所投入的心血、努力和独创性，当遇到问题时，你也不会害怕深入了解语言内部，弄清楚到底发生了什么。编译器不再看起来像魔法，而是变得像一些更有趣的东西：普通的软件。
