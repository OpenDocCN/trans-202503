## 第十二章：DIFFIE–HELLMAN

![image](img/common01.jpg)

1976 年 11 月，斯坦福大学的研究人员 Whitfield Diffie 和 Martin Hellman 发表了一篇名为《密码学的新方向》的研究论文，彻底改变了密码学。在他们的论文中，他们提出了公钥加密和签名的概念，尽管他们实际上没有这些方案；他们只是提出了他们所称的 *公钥分配方案*，这是一种协议，允许两个当事方通过交换可被窃听者看到的信息来建立共享的秘密。这个协议现在被称为 *Diffie–Hellman（DH）协议*。

在 Diffie–Hellman 之前，建立共享秘密需要执行繁琐的程序，例如手动交换密封信封。一旦通信方通过 DH 协议建立了共享的秘密值，这个秘密可以用于通过将秘密转换为一个或多个对称密钥来建立 *安全通道*，然后用这些密钥对后续通信进行加密和认证。因此，DH 协议及其变体被称为密钥协商协议。

在本章的第一部分，我回顾了 Diffie–Hellman 协议的数学基础，包括 DH 依赖于的计算问题，以便实现其神奇功能。然后，在本章的第二部分，我描述了用于创建安全通道的不同版本的 Diffie–Hellman 协议。最后，由于 Diffie–Hellman 方案只有在参数选择得当时才是安全的，我通过检查 Diffie–Hellman 可能失败的场景来结束本章。

**注意**

*Diffie 和 Hellman 因发明了公钥密码学和数字签名而在 2015 年获得了声望卓著的图灵奖，但也有其他人应得的荣誉。早在 1974 年，即 Diffie–Hellman 论文发表的两年前，计算机科学家 Ralph Merkle 就提出了公钥密码学的概念，并创造了现在称为 Merkle 迷题的东西。大约在同一时期，GCHQ（政府通信总部，英国相当于美国国家安全局）的一些研究人员也发现了 RSA 和 Diffie–Hellman 密钥协商背后的原理，尽管这一事实直到数十年后才解密。*

### Diffie–Hellman 函数

为了理解 DH 密钥协商协议，你必须首先理解它们的核心操作，即 *DH* *函数*。DH 函数通常与以 **Z**[*p*]^* 表示的群体一起工作。回想一下第九章，这些群体是由模素数 *p* 的非零整数构成的。另一个公共参数是 *基数*，*g*。所有算术运算都是在 *p* 模下进行的。

DH 函数涉及两个由通信双方从群体 **Z**[*p*]^* 随机选择的私有值，分别表示为 *a* 和 *b*。私有值 *a* 具有一个与之相关的公共值 *A* = *g*^(*a*) mod *p*，即 *g* 的 *a* 次方模 *p*。这个值通过一个可被窃听者看到的消息发送给另一方。与 *b* 相关的公共值是 *B* = *g*^(*b*) mod *p*，即 *g* 的 *b* 次方模 *p*，这个值通过一个公开可读的消息发送给 *a* 的拥有者。

DH 的神奇之处在于将一个公共值与另一个私有值结合，从而使结果在两种情况下相同：*A*^(*b*) = (*g*^(*a*))^(*b*) = *g*^(*ab*) 和 *B*^(*a*) = (*g*^(*b*))^(*a*) = *g*^(*ba*) = *g*^(*ab*)。得到的值 *g*^(*ab*) 就是 *共享秘密*；然后它被传递给 *密钥派生函数 (KDF)*，以生成一个或多个共享的对称密钥。KDF 是一种哈希函数，它会返回一个随机看似的字符串，大小为所需密钥长度。

就这样了。像许多伟大的科学发现一样（如引力、相对论、量子计算或 RSA），Diffie–Hellman 的技巧事后看是极其简单的。

然而，Diffie–Hellman 的简洁性可能具有误导性。例如，它不能与任何素数 *p* 或基数 *g* 一起工作。举例来说，一些 *g* 的值会将共享的秘密 *g*^(*ab*) 限制在一小部分可能的值之内，而你期望的应该是与 **Z**[*p*]^* 中的元素数量大致相同的可能值，从而共享秘密的可能值也应该是如此。为了确保最高的安全性，安全的 DH 参数应与一个素数 *p* 一起工作，使得 (*p* – 1) / 2 也是素数。这样的 *安全素数* 保证了该群体不会有小的子群，从而使 DH 更容易被破解。使用安全素数时，DH 可以特别地与 *g* = 2 一起工作，这使得计算略微加快。但生成一个安全素数 *p* 的时间比生成一个完全随机的素数要长。

例如，OpenSSL 工具包的`dhparam`命令只会生成安全的 DH 参数，但算法中内置的额外检查会显著增加执行时间，正如示例 11-1 所示。

```
$ time openssl dhparam 2048
Generating DH parameters, 2048 bit long safe prime, generator 2
This is going to take a long time
--snip--
-----BEGIN DH PARAMETERS-----
MIIBCAKCAQEAoSIbyA9e844q7V89rcoEV8vd/l2svwhIIjG9EPwWWr7FkfYhYkU9
fRNttmilGCTfxc9EDf+4dzw+AbRBc6oOL9gxUoPnOd1/G/YDYgyplF5M3xeswqea
SD+B7628pWTaCZGKZham7vmiN8azGeaYAucckTkjVWceHVIVXe5fvU74k7+C2wKk
iiyMFm8th2zm9W/shiKNV2+SsHtD6r3ZC2/hfu7XdOI4iT6ise83YicU/cRaDmK6
zgBKn3SlCjwL4M3+m1J+Vh0UFz/nWTJ1IWAVC+aoLK8upqRgApOgHkVqzP/CgwBw
XAOE8ncQqroJ0mUSB5eLqfpAvyBWpkrwQwIBAg==
-----END DH PARAMETERS-----
openssl dhparam 2048  154.53s user 0.86s system 99% cpu 2:36.85 total
```

*示例 11-1：使用 OpenSSL 工具包生成 2048 位 Diffie–Hellman 参数的执行时间测量*

正如你在示例 11-1 中看到的，使用 OpenSSL 工具包生成 DH 参数花费了 154.53 秒。现在，为了进行比较，示例 11-2 显示了在相同系统上生成相同大小的 RSA 参数（即两个素数 *p* 和 *q*，每个素数的大小是用于 DH 的 *p* 的一半）所需的时间。

```
$ time openssl genrsa 2048
Generating RSA private key, 2048 bit long modulus
...................................................+++
.............................................................+++
e is 65537 (0x10001)
-----BEGIN RSA PRIVATE KEY-----
--snip--
-----END RSA PRIVATE KEY-----
openssl genrsa 2048  0.16s user 0.01s system 95% cpu 0.171 total
```

*示例 11-2：生成 2048 位 RSA 参数并测量执行时间*

生成 DH 参数的时间大约是生成相同安全级别的 RSA 参数的 1000 倍，主要是由于在生成用于创建 DH 参数的素数时施加的额外约束。

### Diffie–Hellman 问题

DH 协议的安全性依赖于计算问题的难度，特别是依赖于第九章中介绍的离散对数问题(DLP)的难度。显然，通过从公共值 *g*^(*a*) 中恢复私有值 *a*，可以破解 DH 协议，这本质上就是解决 DLP 实例。但当我们使用 DH 计算共享秘密时，我们不仅关心离散对数问题。我们还关心两个与 DH 特定相关的问题，如下所述。

#### *计算 Diffie–Hellman 问题*

*计算 Diffie–Hellman (CDH)*问题是指在仅知道公共值 *g*^(*a*) 和 *g*^(*b*)，而不知道任何秘密值 *a* 或 *b* 的情况下，计算共享秘密 *g*^(*ab*) 的问题。其动机显然是确保即使窃听者捕获了 *g*^(*a*) 和 *g*^(*b*)，他们也无法确定共享秘密 *g*^(*ab*)。

如果你能够解决 DLP 问题，那么你也能够解决 CDH 问题；简而言之，如果你能够解决 DLP 问题，那么在给定 *g*^(*a*) 和 *g*^(*b*) 的情况下，你将能够推导出 *a* 和 *b*，从而计算出 *g*^(*ab*)。换句话说，DLP 问题至少和 CDH 问题一样难。但我们并不确定 CDH 问题是否至少和 DLP 问题一样难，这将使得这两个问题具有相同的难度。换句话说，DLP 问题对于 CDH 问题就像因式分解问题对于 RSA 问题一样。（回想一下，因式分解能够解决 RSA 问题，但不一定能够反过来解决。）

Diffie–Hellman 与 RSA 有一个相似之处，即对于给定的模数大小，DH 将提供与 RSA 相同的安全级别。例如，具有 2048 位素数 *p* 的 DH 协议将为你提供与具有 2048 位模数 *n* 的 RSA 大致相同的安全性，即大约 90 位。事实上，破解 CDH 的最快方法是通过一种称为*数域筛法*的算法来解决 DLP 问题，这种方法类似但不完全相同于破解 RSA 的最快方法：一般数域筛法（GNFS）。

#### *决策 Diffie–Hellman 问题*

有时候，我们需要比 CDH 难度假设更强的假设。例如，假设攻击者能够在给定 2048 位的 *g*^(*a*) 和 *g*^(*b*) 的情况下计算出 *g*^(*ab*) 的前 32 位，但无法计算出所有 2048 位。虽然由于 32 位不足以完全恢复 *g*^(*ab*)，CDH 仍然是安全的，但攻击者仍然可能已经学到了一些关于共享秘密的信息，这可能会让他们突破应用的安全性。

为了确保攻击者无法得知任何关于共享密钥 *g*^(*ab*) 的信息，这个值只需要与一个随机群元素无法区分，就像加密方案在密文无法区分于随机字符串时才是安全的。正式化这一直觉的计算问题被称为 *判定性 Diffie–Hellman（DDH）* 问题。给定 *g*^(*a*), *g*^(*b*)，以及一个值，它是 *g*^(*ab*) 或 *g*^(*c*)，其中 *c* 是一个随机数（每个有 1/2 的概率），DDH 问题的任务是确定是否选择了 *g*^(*ab*)（对应于 *g*^(*a*) 和 *g*^(*b*) 的共享秘密）。假设没有攻击者可以高效地解决 DDH，这个假设被称为 *判定性 Diffie–Hellman 假设*。

如果 DDH 是困难的，那么 CDH 也同样困难，你无法从中学到任何关于 *g*^(*ab*) 的信息。但如果你能解决 CDH，那么你也能解决 DDH：给定一个三元组 (*g*^(*a*), *g*^(*b*), *g*^(*c*)), 你就可以从 *g*^(*a*) 和 *g*^(*b*) 中推导出 *g*^(*ab*)，并检查结果是否与给定的 *g*^(*c*) 相等。底线是，DDH 在本质上比 CDH 更简单，但 DDH 的难度是加密学中的一个基本假设，并且是最研究的课题之一。我们可以确信，当 Diffie–Hellman 参数选择得当时，CDH 和 DDH 都很难。

#### *更多的 Diffie–Hellman 问题*

有时，加密学家设计新的方案，并证明它们至少与解决与 CDH 或 DDH 相关的问题一样困难，但并不完全与这两者相同。理想情况下，我们希望证明破解一个加密系统的难度与解决 CDH 或 DDH 的难度相同，但这并不总是可以通过先进的加密机制实现，通常是因为这些方案涉及比基本的 Diffie–Hellman 协议更复杂的操作。

例如，在一个类似于 DH 的问题中，给定 *g*^(*a*)，攻击者会尝试计算 *g*^(1/*a*)，其中 1/*a*是群中*a*的逆元（通常是 **Z**[*p*]^*，其中 *p* 是某个素数）。在另一个问题中，攻击者可能会区分 (*g*^(*a*), *g*^(*b*)) 和 (*g*^(*a*), *g*^(1/*a*)) 这两对随机的 *a* 和 *b*。最后，在所谓的 *双重 Diffie–Hellman 问题* 中，给定 *g*^(*a*), *g*^(*b*) 和 *g*^(*c*)，攻击者会尝试计算两个值 *g*^(*ab*) 和 *g*^(*ac*)。有时这些 DH 变种与 CDH 或 DDH 一样困难，有时它们本质上更容易——因此提供的安全保障较低。作为练习，尝试找出这些问题的难度与 CDH 和 DDH 之间的关系。（双重 Diffie–Hellman 实际上与 CDH *一样困难*，但这并不容易证明！）

### 密钥协议

Diffie–Hellman 问题旨在构建安全的密钥协议——这些协议旨在保护通过网络进行通信的两个或多个参与方之间的通信，并利用共享秘密进行保护。这个秘密被转化为一个或多个 *会话密钥*——用于加密和验证会话期间交换的信息的对称密钥。在研究实际的 DH 协议之前，你应该了解是什么使密钥协议安全或不安全，以及简单协议是如何工作的。我们将从一个广泛使用的密钥协议开始，它不依赖于 DH。

#### *非 DH 密钥协议示例*

为了让你了解密钥协议是如何工作的，以及它安全意味着什么，我们来看看在 3G 和 4G 电信标准中用于建立 SIM 卡与电信运营商之间通信的协议。这个协议通常被称为 *AKA*，即 *认证密钥协议*。它不使用 Diffie–Hellman 函数，而是仅使用对称密钥操作。细节可能有点枯燥，但本质上，这个协议如图 11-1 所示。

![image](img/f11-01.jpg)

*图 11-1：3G 和 4G 电信中的认证密钥协议*

在这个协议的实现中，SIM 卡拥有一个秘密密钥 *K*，这是运营商所知道的。运营商通过选择一个随机值 *R* 开始会话，然后基于两个伪随机函数 **PRF**0 和 **PRF**1 计算两个值 *SK* 和 *V*[1]。接下来，运营商向 SIM 卡发送一个包含 *R* 和 *V*[1] 的消息，这些值对攻击者可见。一旦 SIM 卡获得 *R*，它就具备计算 *SK* 所需的信息，使用 **PRF**0 完成此操作。会话中的两个参与方最终共享一个密钥 *SK*，攻击者无法通过查看双方交换的消息，甚至修改消息或注入新消息来确定该密钥。SIM 卡通过重新计算 *V*[1]，使用 **PRF**1、*K* 和 *R* 作为输入，来验证自己是否在与运营商通信，然后检查计算出的 *V*[1] 是否与运营商发送的 *V*[1] 匹配。然后，SIM 卡使用新函数 **PRF**2、*K* 和 *R* 计算验证值 *V*[2]，并将 *V*[2] 发送给运营商。运营商通过计算 *V*[2] 并检查计算结果是否与接收到的 *V*[2] 匹配，来验证 SIM 卡是否知道 *K*。

但这个协议并非对所有攻击免疫：原则上，有一种方法可以通过重放攻击欺骗 SIM 卡。基本上，如果攻击者捕获到一对 (*R*, *V*[1])，他们可能将其发送给 SIM 卡，并欺骗 SIM 卡相信该对来自一个知道 *K* 的合法运营商。为了防止这种攻击，协议包括了额外的检查，以确保同一个 *R* 不会被重用。

如果*K*被泄露，也可能会出现问题。例如，攻击者如果掌握了*K*，就可以进行中间人攻击，并监听所有明文通信。这样的攻击者可能在两方之间发送消息，同时伪装成合法的 SIM 卡运营商和 SIM 卡。更大的风险是，攻击者可以记录通信内容以及在密钥协商过程中交换的任何消息，并且稍后可以使用捕获的*R*值解密这些通信。攻击者可以由此推算出过去的会话密钥，并使用它们解密录制的流量。

#### *密钥协商协议的攻击模型*

对于密钥协商协议，并没有单一的安全定义，无法在没有上下文和不考虑攻击模型以及安全目标的情况下说某个密钥协议是完全安全的。例如，你可以说之前的 3G/4G 协议是安全的，因为被动攻击者不会找到会话密钥，但你也可以说它不安全，因为一旦密钥*K*泄漏，那么所有以前和未来的通信都会受到威胁。

在密钥协商协议中有不同的安全概念，以及三个主要的攻击模型，这些模型取决于协议泄露的信息。从最弱到最强，这些模型分别是*窃听者*、*数据泄漏*和*漏洞*：

**窃听者** 这个攻击者观察两个合法方之间交换的消息，并可以记录、修改、丢弃或注入消息。为了防止窃听者，密钥协商协议必须确保不泄露任何关于共享秘密的信息。

**数据泄漏** 在这个模型中，攻击者通过一次或多次协议执行获取会话密钥和所有*临时*秘密（例如前面讨论的电信协议示例中的*SK*），但没有获取长期密钥（例如同一协议中的*K*）。

**漏洞（或破坏）** 在这个模型中，攻击者获得了一个或多个方的长期密钥。一旦发生漏洞，安全性就不再可得，因为攻击者可以在协议的后续会话中冒充一方或双方。然而，攻击者不应能够从收集密钥之前执行的会话中恢复秘密。

现在我们已经看过攻击模型并了解了攻击者可以做些什么，接下来我们来探讨安全目标——也就是协议应提供的安全保障。密钥协商协议可以设计来满足多个安全目标。这里描述了四个最相关的目标，按从简单到复杂的顺序排列。

**身份验证** 每一方都应该能够验证另一方的身份。也就是说，协议应允许进行*相互身份验证*。认证密钥协商（AKA）发生在协议认证了双方身份时。

**关键控制** 无论哪一方都不应该能够选择最终的共享密钥或将其强迫在某个特定子集内。前面讨论的 3G/4G 密钥协商协议缺乏这一特性，因为运营商选择了*R*的值，这完全决定了最终共享密钥。

**前向保密性** 这是指即使所有长期密钥都被暴露，之前执行协议时的共享密钥也无法被计算出来，即使攻击者记录了所有之前的执行，或能够注入或修改之前执行中的消息。*前向保密*协议保证，即使你必须将设备和它们的秘密交给某个机构或其他地方，它们也无法解密你之前加密的通信。（3G/4G 密钥协商协议不提供前向保密性。）

**抗密钥泄露伪装（KCI）** KCI 发生在攻击者泄露了一方的长期密钥，并能够用它冒充另一方。例如，3G/4G 密钥协商协议允许简单的密钥泄露伪装，因为双方共享相同的密钥*K*。理想的密钥协商协议应该防止这种攻击。

#### *性能*

要有用，一个密钥协商协议不仅应该是安全的，还应该是高效的。考虑到密钥协商协议的效率时，应该考虑多个因素，包括交换的消息数量、消息的长度和数量、实现协议的计算工作量，以及是否可以进行预计算以节省时间。如果交换的消息较少且较短，且最好保持最小的交互性，以便双方不必等待接收到消息后才发送下一个消息，那么协议通常会更高效。协议效率的常见衡量标准是以*往返*时间计算，或发送一条消息并接收回应的时间。

往返时间通常是协议中延迟的主要原因，但要执行的计算量也很重要；所需的计算越少越好，并且可以提前完成的预计算越多越好。

例如，前面讨论的 3G/4G 密钥协商协议交换了两条几百比特的消息，且必须按照特定顺序发送。此协议可以使用预计算来节省时间，因为运营商可以提前选择多个*R*值；预计算出匹配的*SK*、*V*[1]和*V*[2]值；并将它们存储在数据库中。在这种情况下，预计算的优势是减少了长期密钥的暴露。

### 迪菲-赫尔曼协议

Diffie–Hellman 函数是大多数已部署的公钥协议的核心。然而，并没有单一的 Diffie–Hellman 协议，而是多种方式使用 DH 函数来建立共享密钥。接下来的章节中，我们将回顾其中三种协议。在每次讨论中，我将坚持使用常见的加密占位符名称，称两方为 Alice 和 Bob，攻击者为 Eve。我将写*g*为用于算术运算的群体基数，这是一个固定值，Alice 和 Bob 事先都已知晓。

#### *匿名 Diffie–Hellman*

*匿名 Diffie–Hellman*是所有 Diffie–Hellman 协议中最简单的一种。之所以称为“匿名”，是因为它没有认证；参与者没有可以被另一方验证的身份，也没有持有长期密钥。Alice 无法向 Bob 证明她就是 Alice，反之亦然。

在匿名 Diffie–Hellman 协议中，每一方选择一个随机值（*a*为 Alice，*b*为 Bob）作为私钥，并将相应的公钥发送给另一方。图 11-2 展示了这个过程的详细情况。

![image](img/f11-02.jpg)

*图 11-2：匿名 Diffie–Hellman 协议*

如你所见，Alice 使用她的指数*a*和群体基数*g*计算*A* = *g*^(*a*)，并将其发送给 Bob。Bob 收到*A*后计算*A*^(*b*)，这等于(*g*^(*a*))^(*b*)。Bob 现在获得了值*g*^(*ab*)，并通过他的随机指数*b*和基数*g*计算出*B*。然后，他将*B*发送给 Alice，Alice 利用它计算*g*^(*ab*)。经过类似的操作，Alice 和 Bob 最终得到相同的值*g*^(*ab*)，这涉及将*g*和接收到的值分别升到各自私有指数的幂次。简单纯粹，但仅对最懒惰的攻击者有效。

匿名 DH 协议可以通过中间人攻击被破解。窃听者只需要拦截消息并伪装成 Bob（对 Alice）或伪装成 Alice（对 Bob），如图 11-3 所示。

![image](img/f11-03.jpg)

*图 11-3：中间人攻击在匿名 Diffie–Hellman 协议中的应用*

与前面的交换相似，Alice 和 Bob 各自选择随机指数*a*和*b*。Alice 现在计算并发送*A*，但 Eve 拦截并丢弃了消息。Eve 接着选择一个随机指数*c*，并计算*C* = *g*^(*c*)，发送给 Bob。由于这个协议没有认证，Bob 认为他收到了 Alice 的*C*并继续计算*g*^(*bc*)。然后，Bob 计算出*B*并将该值发送给 Alice，但 Eve 再次拦截并丢弃了消息。Eve 现在计算*g*^(*bc*)，选择一个新的指数*d*，计算*g*^(*ad*)，通过*g*^(*d*)计算出*D*，并将*D*发送给 Alice。Alice 随后也计算出*g*^(*ad*)。

由于这一攻击，攻击者 Eve 最终与 Alice 共享了一个秘密(*g*^(*ad*))，并与 Bob 共享另一个秘密(*g*^(*bc*))，尽管 Alice 和 Bob 以为他们之间共享的是一个单一的秘密。完成协议执行后，Alice 将从*g*^(*ad*)中推导出对称密钥，以加密发送给 Bob 的数据，但 Eve 将截获加密消息，解密后再使用从*g*^(*bc*)中推导出的另一组密钥重新加密并发送给 Bob——在此过程中可能会修改明文。所有这些发生时，Alice 和 Bob 对此一无所知。也就是说，他们已经注定失败。

为了防止此类攻击，你需要一种方法来认证各方，以便 Alice 可以证明她自己是真正的 Alice，Bob 也可以证明他自己是真正的 Bob。幸运的是，确实有一种方法可以做到这一点。

#### *认证 Diffie–Hellman*

*认证 Diffie–Hellman*是为了解决可能影响匿名 DH 的中间人攻击而开发的。认证 DH 为双方提供了私钥和公钥，从而允许 Alice 和 Bob 签署他们的消息，以阻止 Eve 代表他们发送消息。在这里，签名不是通过 DH 函数计算的，而是使用像 RSA-PSS 这样的公钥签名方案。因此，为了成功地代表 Alice 发送消息，攻击者需要伪造一个有效的签名，而使用安全签名方案则使这一点变得不可能。

图 11-4 展示了认证过的 DH 如何工作。

![image](img/f11-04.jpg)

*图 11-4：认证 Diffie–Hellman 协议*

第一行中的**Alice** (*priv*[*A*], *pub*[*B*])标签意味着 Alice 持有她自己的私钥*priv*[*A*]，以及 Bob 的公钥*pub*[*B*]。这种*priv*/*pub*密钥对被称为*长期密钥*，因为它是事先固定的，并且在协议的连续运行中保持不变。当然，这些长期私钥应该保密，而公钥被认为是攻击者已知的。

Alice 和 Bob 首先像在匿名 DH 中那样选择随机指数，*a*和*b*。然后，Alice 计算出*A*和一个基于她的签名函数**sign**、她的私钥*priv*[*A*]以及*A*的签名*sig*[*A*]。现在，Alice 将*A*和*sig*[*A*]发送给 Bob，Bob 使用她的公钥*pub*[*A*]来验证*sig*[*A*]。如果签名无效，Bob 就知道消息不是来自 Alice，他会丢弃*A*。

如果签名正确，Bob 将从*A*和他的随机指数*b*计算出*g*^(*ab*)。然后，他将从**sign**函数、他的私钥*priv*[*B*]和*B*的组合中计算出*B*和他自己的签名。现在他将*B*和*sig*[*B*]发送给 Alice，Alice 将尝试使用 Bob 的公钥*pub*[*B*]来验证*sig*[*B*]。只有当 Bob 的签名被成功验证时，Alice 才会计算出*g*^(*ab*)。

##### 防止窃听者攻击

经过认证的 DH 能够防止窃听者攻击，因为攻击者无法获取任何关于共享秘密 *g*^(*ab*) 的信息，因为他们忽略了 DH 指数。经过认证的 DH 还提供前向保密性：即使攻击者在某个时刻篡改了某一方，就如之前讨论的 *breach* 攻击模型那样，他们将只能获取私钥签名信息，而无法获得任何瞬时的 DH 指数；因此，他们无法获知任何先前共享的秘密。

经过认证的 DH 还可以防止任何一方控制共享秘密的值。Alice 无法通过构造一个特殊的 *a* 值来预测 *g*^(*ab*) 的值，因为她无法控制 *b*，而 *b* 对 *g*^(*ab*) 的影响和 *a* 一样大。（唯一的例外是如果 Alice 选择 *a* = 0，这样无论 *b* 为何，都会有 *g*^(*ab*) = 1。但 0 不是一个有效值，协议应拒绝此选择。）

尽管如此，经过认证的 DH 并不能防止所有类型的攻击。例如，Eve 可以记录 *A* 和 *sig*[*A*] 的先前值，并稍后将其重放给 Bob，从而伪装成 Alice。此时，Bob 会相信他正在与 Alice 分享一个秘密，尽管实际上他并没有，而 Eve 也无法得知这个秘密。通过添加一个名为 *密钥确认* 的过程，可以在实践中消除这一风险，在这个过程中，Alice 和 Bob 互相证明他们拥有共享的秘密。例如，Alice 和 Bob 可以通过发送 **Hash**(*pub*[*A*] || *pub*[*B*], *g*^(*ab*)) 和 **Hash**(*pub*[*B*] || *pub*[*A*], *g*^(*ab*)) 来进行密钥确认，使用某个哈希函数 **Hash**；当 Bob 收到 **Hash**(*pub*[*A*] || *pub*[*B*], *g*^(*ab*))，而 Alice 收到 **Hash**(*pub*[*B*] || *pub*[*A*], *g*^(*ab*)) 时，两者可以使用 *pub*[*A*]、*pub*[*B*] 和 *g*^(*ab*) 验证这些哈希值的正确性。公钥的不同顺序（*pub*[*A*] || *pub*[*B*] 和 *pub*[*B*] || *pub*[*A*]）确保了 Alice 和 Bob 会发送不同的值，且攻击者不能通过复制 Bob 的哈希值伪装成 Alice。

##### 数据泄露防护

经过认证的 DH 对数据泄露攻击的脆弱性更为令人关注。在这种类型的攻击中，攻击者会获得短期瞬时秘密的值（即指数 *a* 和 *b*），并利用这些信息冒充通信的一方。如果 Eve 能够获取指数 *a* 的值，并获得发送给 Bob 的 *A* 和 *sig*[*A*] 的匹配值，她就可以发起协议的新一轮执行，并冒充 Alice，如 图 11-5 所示。

![image](img/f11-05.jpg)

*图 11-5：经过认证的 Diffie–Hellman 协议的冒充攻击*

在这个攻击场景中，Eve 获取了 *a* 的值，并重新播放对应的 *A* 及其签名 *sig*[*A*]，伪装成 Alice。Bob 验证签名并从 *A* 计算 *g*^(*ab*)，然后发送 *B* 和 *sig*[*B*]，Eve 使用这些信息，利用偷来的 *a* 计算 *g*^(*ab*)。这样两者之间就有了一个共享的密钥。Bob 现在认为自己在和 Alice 交流。

一种使认证 DH 协议在泄露临时密钥时仍能保证安全的方法是将长期密钥整合进共享密钥的计算中，这样在不知道长期密钥的情况下，就无法确定共享密钥。

#### *Menezes–Qu–Vanstone (MQV)*

*Menezes–Qu–Vanstone (MQV)* 协议是基于 DH 协议的一个里程碑。MQV 协议设计于 1998 年，后来被纳入美国国家安全局（NSA）的 Suite B 中，这是一套保护机密信息的算法集。该协议经过批准，用于保护大多数关键资产。（NSA 最终取消了 MQV，原因据称是它没有得到广泛使用。稍后我会讨论具体原因。）

MQV 是增强版的 Diffie–Hellman。它比认证的 DH 更安全，并且在性能上优于认证的 DH。特别地，MQV 允许用户仅发送两个消息，彼此独立，顺序任意。其他好处是，用户可以发送比认证 DH 更短的消息，并且不需要发送明确的签名或验证消息。换句话说，用户不需要在 Diffie–Hellman 功能之外再使用签名方案。

与认证的 DH 一样，在 MQV 中，Alice 和 Bob 各自持有一个长期私钥以及对方的长期公钥。不同之处在于，MQV 中的密钥不是签名密钥：MQV 中使用的密钥由私有指数 *x* 和公有值 *g*^(*x*) 组成。图 11-6 展示了 MQV 协议的操作过程。

![image](img/f11-06.jpg)

*图 11-6：MQV 协议*

在 图 11-6 中的 *x* 和 *y* 分别是 Alice 和 Bob 的长期私钥，而 *X* 和 *Y* 是他们的公钥。Bob 和 Alice 从各自的私钥以及对方的公钥开始计算，这些公钥是 *g* 的私钥次方。每人选择一个随机的指数，然后 Alice 计算 *A* 并将其发送给 Bob。Bob 随后计算 *B* 并发送给 Alice。一旦 Alice 获取到 Bob 的临时公钥 *B*，她就将其与自己的长期私钥 *x*、临时私钥 *a* 以及 Bob 的长期公钥 *Y* 结合，通过计算 (*B* × *Y*^(*B*))^((*a* + *xA*)) 的结果，如 图 11-6 中所定义。展开该表达式后，我们得到以下结果：

(*B* × *Y^B*)^((*a* + *xA*)) = (*g^b* × (*g^y*)^(*B*))^((*a* + *xA*)) = (*g*^(*b* + *yB*))^((*a* + *xA*)) = *g*^((*b* + *yB*)(*a* + *xA*))

与此同时，Bob 计算 (*A* × *X*^(*A*))^((*b* + *yB*)) 的结果，我们可以验证它与 Alice 计算的值相等：

(*A* × *X^A*)^((*b* + *yB*)) = (*g^a* × (*g^x*)^(*A*))^((*b* + *yB*)) = (*g*^(*a* + *xA*))^((*b* + *yB*)) = *g*^((*a* + *xA*)(*b* + *yB*)) = *g*^((*b* + *yB*)(*a* + *xA*))

如你所见，我们得到了 Alice 和 Bob 相同的值，即 *g*^((*b* + *yB*)(*a* + *xA*)）。这告诉我们 Alice 和 Bob 共享相同的秘密。

与认证 DH 不同，MQV 不能仅通过泄露临时秘密而被攻破。知道 *a* 或 *b* 不会让攻击者确定最终的共享秘密，因为他们还需要长期私钥来计算它。

在最强的攻击模型——泄密模型下，长期密钥被破解时会发生什么？如果 Eve 破解了 Alice 的长期私钥 *x*，先前建立的共享秘密是安全的，因为它们的计算也涉及了 Alice 的临时私钥。

然而，MQV 并不能提供 *完美*的前向保密性，因为存在以下攻击。例如，假设 Eve 拦截了 Alice 的 *A* 消息，并将其替换为她的 *A* = *g*^(*a*)，其中 *a* 是 Eve 选择的一个值。与此同时，Bob 向 Alice 发送 *B*（Eve 记录了 *B* 的值）并计算共享密钥。如果 Eve 后来破解了 Alice 的长期私钥 *x*，她就可以确定 Bob 在本次会话中计算出的密钥。这破坏了前向保密性，因为 Eve 现在恢复了协议之前一次执行的共享秘密。然而，实际上，通过一个密钥确认步骤可以消除这一风险，Alice 和 Bob 会意识到他们不共享相同的密钥，因此会在派生任何会话密钥之前中止协议。

尽管 MQV 在优雅性和安全性上有优势，但在实际中却很少使用。一个原因是它曾被专利限制，这阻碍了它的广泛应用。另一个原因是，实际应用中正确实现 MQV 比看起来要困难。事实上，与其增加的复杂性相比，MQV 的安全性好处通常被认为低于更简单的认证 DH。

### 错误的发生方式

Diffie–Hellman 协议可能以多种方式惨败。我将在接下来的章节中突出一些最常见的失败方式。

#### *不对共享秘密进行哈希处理*

我曾提到，结束一个 DH 会话交换的共享秘密（我们例子中的 *g*^(*ab*)）被用作输入来派生会话密钥，但它本身并不是一个密钥，而且不应该是。对称密钥应该看起来是随机的，每一位应该有相同的概率为 0 或 1。但 *g*^(*ab*) 不是一个随机字符串；它是某个数学群内的一个随机元素，其位可能偏向 0 或 1。而随机群元素与随机的位字符串是不同的。

比如，假设我们在乘法群 **Z**[13]^* = {1, 2, 3, … , 12} 中工作，使用 *g* = 2 作为该群的生成元，这意味着 *g*^(*i*) 会遍历 **Z**[13]^* 中所有的值，其中 *i* 取值为 1, 2, … 12：*g*¹ = 2, *g*² = 4, *g*³ = 8, *g*⁴ = 13，依此类推。如果 *g* 的指数是随机的，你将得到 **Z**[13]^* 的一个随机元素，但 **Z**[13]^* 元素的 4 位字符串编码不会是均匀随机的：并不是所有的位都有相同的概率是 0 或 1。在 **Z**[13]^* 中，七个值的最重要的位是 0（即群中的 1 到 7 的数字），但只有五个值的最重要的位是 1（即 8 到 12）。也就是说，这个位是 0 的概率为 7 / 12 ≈ 0.58，而理想情况下，一个随机位应该有 0.5 的概率为 0。更糟的是，4 位序列 1101、1110 和 1111 永远不会出现。

为了避免来自 DH 共享秘密中生成的会话密钥的偏差，应该使用加密哈希函数，如 BLAKE2 或 SHA-3，或者更好的是，使用密钥派生函数（KDF）。KDF 构造的一个例子是 HKDF 或基于 HMAC 的 KDF（如 RFC 5869 中所指定），但如今 BLAKE2 和 SHA-3 都提供了专门的模式来充当 KDF。

#### *TLS 中的遗留 Diffie–Hellman*

TLS 协议是 HTTPS 安全网站以及安全邮件传输协议（SMTP）背后的安全机制。TLS 涉及多个参数，包括它将使用的 Diffie–Hellman 协议类型，尽管大多数 TLS 实现仍然出于兼容性原因支持匿名 DH，尽管它并不安全。

#### *不安全的群参数*

2016 年 1 月，OpenSSL 工具包的维护者修复了一个高严重性的漏洞（CVE-2016-0701），该漏洞允许攻击者利用不安全的 Diffie–Hellman 参数。漏洞的根本原因在于 OpenSSL 允许用户使用不安全的 DH 群参数（即不安全的素数 *p*），而不是在执行任何算术运算之前抛出错误并完全中止协议。

本质上，OpenSSL 接受了一个素数 *p*，其乘法群 **Z**[*p*]^*（所有 DH 操作都在此进行）包含了小的子群。正如你在本章开始时所学，密码协议中较大群体内存在小的子群是有害的，因为它会将共享的秘密限制在一个比使用整个群体 **Z**[*p*]^* 时更小的可能值集合中。更糟糕的是，攻击者可以构造一个 DH 指数 *x*，当与受害者的公钥 *g*^(*y*) 结合时，会泄露私钥 *y* 的信息，最终泄露其全部内容。

虽然实际的漏洞出现在 2016 年，但该攻击所使用的原理可追溯到 1997 年 Lim 和 Lee 的论文《基于素数阶子群的离散对数方案的密钥恢复攻击》。修复该漏洞的方法很简单：在接受素数*p*作为群体模数时，协议必须检查*p*是否为安全素数，方法是验证(*p* – 1) / 2 也为素数，以确保群体**Z**[*p*]^*不会有小子群，并且对该漏洞的攻击会失败。

### 深入阅读

以下是一些我在本章中未涉及，但有助于进一步学习的内容。

你可以通过阅读一些标准和官方出版物进一步深入了解 DH 密钥交换协议，包括 ANSI X9.42、RFC 2631 和 RFC 5114、IEEE 1363，以及 NIST SP 800-56A。这些文献作为参考，确保互操作性，并提供群体参数的建议。

若要进一步了解高级 DH 协议（如 MQV 及其相关协议 HMQV 和 OAKE 等）及其安全概念（如未知密钥共享攻击和群体表示攻击），请阅读 Hugo Krawczyk 于 2005 年发布的文章《HMQV：一种高效的安全 Diffie-Hellman 协议》(*[`eprint.iacr.org/2005/176/`](https://eprint.iacr.org/2005/176/)*)，以及 Andrew C. Yao 和 Yunlei Zhao 于 2011 年发布的文章《一种新的隐式认证 Diffie-Hellman 协议家族》(*[`eprint.iacr.org/2011/035/`](https://eprint.iacr.org/2011/035/)*)。你会发现这些文章中的 Diffie-Hellman 操作与本章中的表示方式不同。例如，代替*g*^(*x*), 你会看到共享密钥表示为*xP*。通常，你会看到乘法被加法替代，指数运算被乘法替代。原因是这些协议通常不是在整数群体上定义的，而是在*椭圆曲线*上定义的，如第十二章所讨论。
