## 第四章：加密安全

![image](img/common01.jpg)

密码学的安全性定义与通用计算机安全性定义并不相同。软件安全与密码学安全的主要区别在于，后者可以被*量化*。与软件世界中通常将应用程序视为安全或不安全不同，在密码学世界中，往往可以计算出破解一个密码算法所需的努力程度。此外，软件安全侧重于防止攻击者滥用程序的代码，而密码学安全的目标是使得明确的问题无法解决。

密码学问题涉及数学概念，但不是复杂的数学——至少在本书中不是。 本章将引导你了解这些安全概念以及它们如何应用于解决实际问题。在接下来的部分中，我将讨论如何量化加密安全，既符合理论逻辑，又具有实际相关性。我将讨论信息安全与计算安全、位安全与完整攻击成本、可证明安全与启发式安全、对称与非对称密钥生成的概念。最后，我会通过实际的密码学失败示例来总结本章内容。

### 定义不可行

在第一章中，我描述了密码的安全性相对于攻击者的能力和目标，并认为如果给定攻击者已知的能力，无法实现这些目标，则该密码是安全的。但在这种语境下，*不可行*到底是什么意思呢？

密码学中“不可行”的概念由两个概念定义：信息安全和计算安全。粗略地说，*信息安全*是关于理论上的不可能，而*计算安全*则是关于实际的不可能。信息安全并不量化安全性，因为它将密码视为要么安全，要么不安全，没有中间地带；因此，虽然在理论密码学中发挥着重要作用，但在实践中它是没有用的。计算安全则是衡量密码强度的更相关和实际的标准。

#### *理论中的安全性：信息安全*

信息安全的基础不是看破解密码有多难，而是看是否可以想象破解它。只有在即使给定无限的计算时间和内存也无法破解时，密码才被认为是信息上安全的。即使对一个密码的成功攻击需要几万亿年的时间，这样的密码也是信息上*不*安全的。

例如，第一章 中介绍的一次性密码本是信息安全的。回想一下，一次性密码本将明文 *P* 加密为密文 *C* = *P* ⊕ *K*，其中 *K* 是一个对每个明文唯一的随机比特串。这个密码在信息安全上是安全的，因为给定一个密文和无限的时间去尝试所有可能的密钥 *K* 并计算对应的明文 *P*，你仍然无法确定正确的 *K*，因为可能的 *P* 的数量与 *K* 的数量一样多。

#### *实践中的安全：计算安全性*

与信息安全不同，计算安全性认为一个密码在 *合理* 时间内无法被破解，且使用合理的资源，如内存、硬件、预算、能源等，就可以认为它是安全的。计算安全性是一种量化密码或任何加密算法安全性的方法。

例如，考虑一个密码 **E**，你知道一个明文–密文对 (*P*, *C*)，但不知道用于计算 *C* = **E**(*K*, *P*) 的 128 位密钥 *K*。这个密码在信息安全上是不安全的，因为你可以尝试 2¹²⁸ 个可能的 128 位密钥 *K*，直到找到一个满足 **E**(*K*, *P*) = *C* 的密钥。但实际上，即使每秒测试 1000 亿个密钥，仍然需要超过 100,000,000,000,000,000,000 年才能破解。换句话说，从合理的角度看，这个密码是计算上安全的，因为它几乎不可能被破解。

计算安全有时用两个值来表示：

+   *t*，它是攻击者执行的操作次数的上限

+   ε（称为“epsilon”），它是攻击成功概率的上限

我们接着说，如果一个加密方案是 (*t,* ε)*-安全* 的，那么执行最多 *t* 次操作的攻击者——无论这些操作是什么——成功的概率不高于 ε，其中 ε 至少为 0，至多为 1。计算安全性给出了破解一个加密算法的难度上限。

在这里，需要知道的是 *t* 和 ε 只是上限：如果一个密码是 (*t,* ε)*-安全* 的，那么执行少于 *t* 次操作的攻击者将不会成功（概率为 ε）。但这并不意味着执行正好 *t* 次操作的攻击者就会成功，也没有告诉你需要多少操作，可能比 *t* 要大得多。我们说 *t* 是所需计算工作量的 *下限*，因为至少需要 *t* 次操作才能破坏安全性。

我们有时能精确知道破解密码需要多少努力；在这种情况下，我们说 (*t*, ε*)-安全* 给出了一个 *紧界*，当存在一个攻击能够以 ε 的概率用正好 *t* 次操作破解密码时。

例如，考虑一个使用 128 位密钥的对称加密算法。理想情况下，该加密算法应该是(*t, t/2*¹²⁸)*-安全*，对于 *t* 的任何值，范围在 1 到 2¹²⁸ 之间。最佳攻击方法应是 *暴力破解*（尝试所有密钥直到找到正确的密钥）。任何更好的攻击方法必须利用加密算法中的某些缺陷，因此我们努力创建那些暴力破解是最佳攻击方法的加密算法。

假设我们有(*t*, *t*/*2*¹²⁸)*-安全*，让我们来分析三种可能的攻击成功概率：

+   在第一种情况下，*t* = 1，攻击者尝试一个密钥并成功，成功的概率为 ε = 1/2¹²⁸。

+   在第二种情况下，*t* = 2¹²⁸，攻击者尝试所有 2¹²⁸ 个密钥，最终会成功。因此，成功的概率 ε = 1（如果攻击者尝试所有密钥，显然正确的密钥一定会被尝试到）。

+   在第三种情况下，攻击者只尝试 *t* = 2⁶⁴ 个密钥，并成功的概率为 ε = 2⁶⁴/2¹²⁸ = 2^(−64)。当攻击者只尝试部分密钥时，成功的概率与尝试的密钥数量成正比。

我们可以得出结论，一个密钥长度为 *n* 位的加密算法，在最好的情况下，其安全性为 (*t, t/2*^(*n*))*-安全*，对于任何 *t* 的值，范围从 1 到 2^(*n*)，因为无论加密算法多么强大，针对它的暴力破解攻击最终总会成功。因此，密钥需要足够长，以有效抵御暴力破解攻击。

**注意**

*在这个例子中，我们计算的是加密算法的评估次数，而不是绝对时间或处理器时钟周期数。计算安全性不依赖于技术，这一点很好：今天是*（t, ε）-安全*的加密算法明天依然是*（t, ε）-安全*的，但今天在实践中被认为是安全的，明天可能就不再被认为是安全的。*

### 量化安全性

当发现一种攻击时，你首先想知道的是它在理论上的效率如何，以及它在实践中是否可行。同样，给定一个被认为是安全的加密算法，你也想知道它能够承受多少工作量。为了回答这些问题，我将解释如何用位数来衡量密码学安全性（理论视角）以及哪些因素影响攻击的实际成本。

#### *以位数衡量安全性*

在计算安全性时，我们说一个加密算法是 *t-安全* 的，当一个成功的攻击至少需要 *t* 次操作。因此，我们通过假设成功概率 ε 接近 1 来避免不直观的 (*t*, ε) 符号，这也正是我们在实际中关心的。然后，我们用位数表示安全性，其中“*n*-位安全”意味着需要大约 2^(*n*) 次操作来破解某个特定的安全概念。

如果你大概知道破解一个密码需要多少操作，你可以通过对操作次数取二进制对数来确定其安全级别：如果需要 1000000 次操作，安全级别就是 log2 个可能的密钥进行暴力攻击总是会成功的。但密钥的大小并不总是与安全级别相匹配——它只是提供了一个*上界*，即最高可能的安全级别。

安全级别可能小于密钥大小，原因有两个：

+   一种攻击方法用比预期更少的操作破解了密码——例如，使用一种通过尝试不全部 2^(*n*)个密钥，而只是其中一个子集来恢复密钥的方法。

+   密码的安全级别故意与密钥大小不同，就像大多数公钥算法一样。例如，RSA 算法使用 2048 位的秘密密钥提供的安全性不到 100 位。

位安全性在比较密码的安全级别时非常有用，但它并没有提供足够的信息来判断攻击的实际成本。它有时是一个过于简单的抽象，因为它只是假设一个*n*位安全的密码需要 2^(*n*)次操作来破解，不管这些操作是什么。因此，两个具有相同位安全级别的密码，在考虑到攻击者实际攻击成本时，可能在现实世界中的安全级别差异巨大。

假设我们有两个密码，每个密码都使用 128 位密钥和 128 位安全性。每个密码都需要进行 2¹²⁸次评估才能被破解，只是第二个密码的速度比第一个慢 100 倍。因此，评估第二个密码 2¹²⁸次所需的时间与 100 × 2¹²⁸ ≈ 2^(134.64)次评估第一个密码所需的时间相同。如果我们以第一个较快的密码为基准，那么破解较慢的密码需要 2^(134.64)次操作。如果我们以第二个较慢的密码为基准，则只需要 2¹²⁸次操作。那么我们是否可以说第二个密码比第一个密码更强？原则上是的，但我们很少看到常用密码之间有如此百倍的性能差异。

操作的不一致定义在比较攻击效率时引发了更多困难。一些攻击声称通过执行 2¹²⁰次某种操作而不是 2¹²⁸次密码评估来降低密码的安全性，但分析中没有考虑每种攻击类型的速度。2¹²⁰次操作的攻击并不总是比 2¹²⁸次暴力攻击更快。

然而，只要操作定义合理——即大致与密码评估的速度相当——位安全性仍然是一个有用的概念。毕竟，在现实生活中，判断一个安全级别是否足够，只需要一个数量级的比较。

#### *完整攻击成本*

位安全性通过估算成功执行攻击所需操作数的数量级来表示对密码的最快攻击成本。但是，其他因素也会影响攻击的成本，在估算实际安全性时必须考虑这些因素。我将解释其中的四个主要因素：并行性、内存、预计算和目标数量。

##### 并行性

第一个要考虑的因素是计算并行性。例如，考虑两种每种都包含 2⁵⁶ 操作的攻击。两者的区别在于，第二种攻击可以并行化，而第一种攻击则不能：第一种攻击执行的是 2⁵⁶ *顺序依赖*的操作，例如 *x*[*i* + 1] = *f**i*，其中 *x*[0] 和一些函数 *f*[*i*]（*i* 从 1 到 2⁵⁶）；而第二种攻击执行的是 2⁵⁶ *独立*的操作，例如 *x*[*i*] = *f**i*，其中 *x* 和 *i* 从 1 到 2⁵⁶，可以并行执行。并行处理的速度可以比顺序处理快几个数量级。例如，如果你有 2¹⁶ = 65536 个处理器可用，你可以将并行攻击的工作负载划分为 2¹⁶ 个独立任务，每个任务执行 2⁵⁶ / 2¹⁶ = 2⁴⁰ 次操作。然而，第一种攻击无法从多个核心的可用性中受益，因为每个操作都依赖于前一个操作的结果。因此，即使两者执行的操作数量相同，平行攻击也将比顺序攻击快 65536 倍。

**注意**

*当* N *个核心可用时，攻击速度提高* N *倍的算法被称为*极其并行的，*我们称它们的执行时间*与计算核心的数量*呈线性缩放关系。*

##### 内存

确定攻击成本的第二个因素是内存。密码分析攻击应根据其时间和空间的使用来评估：它们在执行过程中进行多少操作，消耗了多少内存或空间，如何利用它们所占用的空间，以及可用内存的速度有多快？不幸的是，位安全性仅关注执行攻击所需的时间。

关于空间的使用方式，重要的是考虑执行攻击时需要多少内存查找、内存访问的速度（读取和写入之间可能有所不同）、访问的数据的大小、访问模式（连续的或随机的内存地址）以及数据在内存中的结构。例如，在今天的一些通用 CPU 上，从寄存器读取数据需要一个周期，而从 CPU 的缓存内存（L3 缓存）读取大约需要 20 个周期，从 DRAM 读取通常至少需要 100 个周期。100 倍的差异可能意味着从一天到三个月的时间差。

##### 预计算

预计算操作是指那些只需要执行一次，并且可以在后续的攻击执行中重复使用的操作。预计算有时被称为攻击的*离线阶段*。

例如，考虑时间-内存权衡攻击。在执行这种攻击时，攻击者进行一次巨大的计算，生成大量的查找表，然后将其存储并在实际攻击中重复使用。例如，某次针对 2G 移动加密的攻击花费了两个月的时间来构建两个 TB 大小的表格，这些表格随后被用来破解 2G 加密，并在几秒钟内恢复一个秘密会话密钥。

##### 目标数量

最后，我们来看看攻击的目标数量。目标数量越大，攻击面越广，攻击者能够了解的密钥信息也就越多。

例如，考虑暴力破解密钥搜索：如果你仅仅针对一个*n*位的密钥，破解正确密钥需要进行 2^(*n*)次尝试。但如果你同时针对多个*n*位密钥——假设数量为*M*——并且对于每一个单独的*P*你有*M*个不同的密文，其中*C* = **E**(*K*, *P*)表示你要找的*M*个密钥(*K*)的加密结果，那么破解每个密钥依然需要 2^(*n*)次尝试。但如果你只关心*至少一个*密钥，而不是每一个密钥，那么成功的平均尝试次数将是 2^(*n*) / *M*。例如，要破解一个 128 位的密钥，在 2¹⁶ = 65536 个目标密钥中，平均需要 2^(128 − 16) = 2¹¹²次对加密算法的评估。也就是说，随着目标数量的增加，攻击的成本（和速度）会减少。

#### *选择与评估安全性等级*

选择安全性等级通常涉及在 128 位和 256 位安全性之间做出选择，因为大多数标准加密算法和实现都提供这两种安全性等级。在 128 位以下，你会找到 64 位或 80 位的安全方案，但这些方案通常不足以在实际环境中使用。

从高层次来看，128 位的安全性意味着你需要执行大约 2¹²⁸次操作才能破解该加密系统。为了让你理解这个数字的含义，可以考虑这样一个事实：宇宙大约有 2⁸⁸纳秒的历史（每秒有十亿纳秒）。由于今天的技术下，测试一个密钥至少需要一纳秒，如果测试一个密钥需要一纳秒，那么成功破解攻击所需的时间将是宇宙年龄的几倍（准确来说是 2⁴⁰倍）。

但是，难道并行性和多个目标不能大幅度减少完成一次成功攻击所需的时间吗？其实不完全是。假设你希望破解其中任意一个百万个目标，并且你有一百万个并行核心可用。这样，搜索时间就从 2¹²⁸缩短到(2¹²⁸ / 2²⁰) / 2²⁰ = 2⁸⁸，这相当于仅仅一个宇宙的生命周期。

另一个在评估安全等级时需要考虑的因素是技术的进步。摩尔定律指出，计算效率大约每两年翻一番。我们可以将其视为每两年损失一个位的安全性：如果今天 1000 美元的预算能在一小时内破解一个 40 位的密钥，那么根据摩尔定律，两年后，你可以用同样的 1000 美元破解一个 41 位的密钥（我在简化）。我们可以从中推断，根据摩尔定律，与今天相比，80 年后我们将失去 40 个位的安全性。换句话说，在 80 年后，执行 2¹²⁸次操作的成本可能与今天执行 2⁸⁸次操作的成本相当。考虑到并行处理和多个目标，如之前讨论的那样，我们的计算时间降到 2⁴⁸纳秒，约为三天。但这一推算是非常不准确的，因为摩尔定律不可能如此扩展。然而，你可以理解：今天看起来不可行的事情，可能在一个世纪后变得现实。

有时低于 128 位的安全等级是可以接受的。例如，当你只需要短时间的安全保护，且实施更高安全等级的成本会对系统的成本或可用性产生负面影响时。一个现实的例子是付费电视系统，其中的加密密钥为 48 位或 64 位。听起来这似乎低得可笑，但这是足够的安全等级，因为密钥每 5 秒或 10 秒就会刷新一次。

然而，为了确保长期安全，你应该选择 256 位安全性或者稍低一些的安全性。即使是在最坏的情况下——量子计算机的出现，见第十四章——256 位安全方案在可预见的未来也不太可能被破解。超过 256 位的安全性实际上是不必要的，除非作为一种营销手段。

正如 NIST 的密码学家约翰·凯尔西曾经说过的：“80 位和 128 位密钥的搜索差异，就像是一次火星任务和一次阿尔法·仙女座任务之间的差异。据我所知，192 位和 256 位密钥在实际暴力破解攻击中的差异并没有什么意义；不可能就是不可能。”

### 实现安全性

一旦选择了安全等级，就必须确保你的加密方案能够维持这一等级。换句话说，你需要*信心*，而不仅仅是希望和不确定性，确保事情会按照计划始终如一地进行。

在建立对加密算法安全性的信心时，你可以依赖数学证明，这是一种称为*可证明安全性*的方法，或者依赖算法未被攻破的证据，这种方法我称之为*启发式安全性*（尽管它有时也被称为*可能的*安全性）。这两种方法是互补的，并没有哪一个比另一个更好，正如你将看到的那样。

#### *可证明安全性*

可证明的安全性是指证明破解你的加密方案至少和解决另一个已知困难的问题一样困难。这样的*安全性证明*保证了只要困难问题仍然困难，加密就会保持安全。这种类型的证明叫做*简化*，它来自于复杂性理论领域。如果解决问题 X 的任何方法也能提供破解某个加密算法的方法，那么我们就说破解某个加密算法可以简化为问题 X。

安全性证明有两种类型，取决于所使用的假定困难问题：与数学问题相关的证明和与加密问题相关的证明。

##### 与数学问题相关的证明

许多安全性证明（例如公共密钥加密的证明）表明，破解一个加密方案至少和解决某个困难的数学问题一样困难。我们讨论的是那些已知有解并且一旦知道其解就容易验证，但计算上很难找到解的问题。

**注意**

*没有真正的证明表明看似困难的数学问题确实是困难的。实际上，证明这一点对于某些特定类型的问题是复杂性理论领域的最大挑战之一，正如我写这段话时，Clay 数学研究所为任何能解决这个问题的人提供 100 万美元的奖金。这一点将在第九章中详细讨论。*

例如，考虑解决*分解问题*的挑战，这是加密中最著名的数学问题：给定一个已知是两个质数的乘积（*n* = *pq*）的数字，找出这两个质数。例如，如果 *n* = 15，答案是 3 和 5。对于一个小数字来说，这是容易的，但随着数字大小的增加，问题变得指数级地困难。例如，如果一个数字 *n* 长度为 3000 位（大约 900 个十进制数字）或更多，分解被认为在实际中是不可行的。

RSA 是最著名的依赖于分解问题的加密方案：RSA 通过计算 *C* = *P*^(*e*) mod *n* 加密一个明文 *P*，其中 *e* 和 *n* = *pq* 是公钥。解密则通过计算 *P* = *C*^(*d*) mod *n* 从密文恢复明文，其中 *d* 是与 *e* 和 *n* 相关联的私钥。如果我们能够分解 *n*，就能破解 RSA（通过从公钥恢复私钥），如果我们能获得私钥，就可以分解 *n*；换句话说，恢复 RSA 私钥和分解 *n* 是等价的困难问题。这就是我们在可证明安全性中寻找的那种简化。然而，没有保证恢复 RSA 明文与分解 *n* 同样困难，因为知道明文并不会揭示私钥。

##### 另一个加密问题相关的证明

你可以通过将一个加密方案与另一个加密方案进行比较，并证明只有在能够破解第一个的情况下，才能破解第二个来进行比较，而不是将加密方案与一个数学问题进行比较。对对称加密算法的安全证明通常采用这种方法。

例如，如果你只有一个置换算法，那么你可以通过将对置换的调用与各种输入类型相结合，构建对称加密算法、随机位生成器和其他加密对象（如哈希函数）（正如你将在第六章中看到的）。然后，证明表明，如果置换算法是安全的，那么新创建的方案也是安全的。换句话说，我们可以确信新创建的算法*不弱于*原始算法。这类证明通常通过在较大的组件上进行攻击来展示较小组件的攻击——也就是通过展示一种简化的方式。

当你证明一个加密算法不比另一个弱时，主要的好处是减少了攻击面：你可以只分析新加密算法的核心算法，而不必分析核心算法和组合的两者。具体来说，如果你写了一个使用新开发的置换和新组合的加密算法，你可以证明该组合在安全性上不弱于核心算法。因此，要破解该组合，你需要破解新的置换算法。

##### 警告

密码学研究人员在很大程度上依赖于安全证明，无论是针对数学问题方案还是其他加密方案。然而，安全证明的存在并不保证一个加密方案是完美的，也不能成为忽视实现中更实际方面的借口。毕竟，正如密码学家拉尔斯·克努森曾经说过的，“如果它被证明是安全的，那它可能并不安全”，这意味着安全证明不应被视为安全的绝对保障。更糟糕的是，存在多种原因导致一个“可证明安全”的方案可能会导致安全失败。

一个问题在于“安全证明”这个词本身。在数学中，证明是展示*绝对真理*，但在密码学中，证明仅仅是展示*相对真理*。例如，证明你的加密算法像计算离散对数问题一样难以破解——给定*g*和*g*^(*x*) mod *n*，找出数字*x*——可以保证如果你的加密算法失败，那么很多其他的加密算法也会失败，而且如果最坏的情况发生了，没人会责怪你。

另一个警告是，安全证明通常是相对于单一的安全概念来证明的。例如，你可能证明恢复加密算法的私钥和因式分解问题一样困难。但是，如果你能够在没有密钥的情况下从密文中恢复明文，那么你就绕过了证明，而恢复密钥就不再重要。

然而，证明并不总是正确的，破解一个算法可能比最初想象的更容易。

**注意**

*不幸的是，很少有研究人员会仔细检查安全证明，这些证明通常长达几十页，因此增加了质量控制的复杂性。也就是说，证明不正确并不一定意味着证明的目标完全错误；如果结果是正确的，可能通过纠正错误来挽救证明。*

另一个重要的考虑因素是，某些困难的数学问题有时可能比预期的更容易解决。例如，某些弱参数使得破解 RSA 变得简单。或者数学问题在某些情况下很难，但平均来看却并不难，这种情况通常发生在参考问题是新的且尚未完全理解时。1978 年，Merkle 和 Hellman 提出的背包加密方案就发生了这种情况，后来它被通过格减法技术完全破解。

最后，虽然一个算法的安全性证明可能没问题，但该算法的实现可能存在漏洞。例如，攻击者可能利用侧信道信息，如功耗或执行时间，来了解算法的内部操作，从而破解它，绕过安全证明。或者实现者可能错误地使用了加密方案：如果算法过于复杂，配置选项过多，用户或开发者出错的可能性就会增加，这可能会使算法变得完全不安全。

#### *启发式安全性*

可证明的安全性是增加对加密方案信心的一个伟大工具，但并不适用于所有类型的算法。事实上，大多数对称加密算法没有安全性证明。例如，我们每天依赖高级加密标准（AES）通过手机、笔记本电脑和台式计算机安全地进行通信，但 AES 并没有可证明的安全性；没有证据表明它像一些著名的问题那样难以破解。AES 不能与一个数学问题或其他算法关联，因为它本身就是一个难题。

在不可证明安全的情况下，唯一能信任一个密码的原因是因为许多经验丰富的人尝试过破解它并且失败了。这有时被称为*启发式安全性*。

那么我们何时能够确定一个密码是安全的呢？我们永远无法完全确定，但我们可以相当有信心地认为，当成百上千名经验丰富的密码分析师各自花费数百小时试图破解某个算法并发布了他们的研究结果——通常是通过攻击*简化版*的密码（通常是减少操作步骤或减少*轮数*，轮数是密码通过若干次操作来混合位的过程）——该算法不会被破解。

在分析新的密码时，密码分析师首先尝试破解一轮，然后是两轮、三轮，或尽可能多的轮数。*安全余量*就是总轮数与成功攻击的轮数之间的差距。当经过多年的研究后，某个密码的安全余量仍然很高时，我们就能相当有信心地认为它是（可能是）安全的。

### 生成密钥

如果你计划加密某些东西，你必须生成密钥，无论是临时的“会话密钥”（就像浏览 HTTPS 网站时生成的那种）还是长期的公钥。回想一下第二章，秘密密钥是加密安全的关键，应该通过随机生成以确保其不可预测性和保密性。

例如，当你浏览 HTTPS 网站时，浏览器接收该站点的公钥，并利用它建立一个仅在当前会话有效的对称密钥，而该站点的公钥及其相关的私钥可能会有效多年。因此，它最好对于攻击者来说难以找到。但是，生成一个秘密密钥并不总是像提取足够多的伪随机比特那么简单。加密密钥可能通过以下三种方式之一生成：

+   *随机地*，使用伪随机数生成器（PRNG），并在需要时，使用密钥生成算法。

+   从一个*密码*出发，使用密钥派生函数（KDF），将用户提供的密码转化为密钥。

+   通过*密钥协商协议*，这是两个或更多方之间的一系列消息交换，最终建立共享密钥。

现在，我将解释最简单的方法：随机生成。

#### *生成对称密钥*

对称密钥是由两方共享的秘密密钥，它们是最简单生成的。它们通常与它们所提供的安全级别长度相同：128 位密钥提供 128 位的安全性，任何 2¹²⁸个可能的密钥都是有效的，并且能够与其他任何密钥一样完成任务。

要使用加密 PRNG 生成一个*n*位的对称密钥，你只需向它请求*n*个伪随机比特，并将这些比特用作密钥。就这样。例如，你可以使用 OpenSSL 工具包通过提取伪随机字节来生成一个随机的对称密钥，如下命令所示（显然，你的结果与我的会有所不同）：

```
$ openssl rand 16 -hex
65a4400ea649d282b855bd2e246812c6
```

#### *生成非对称密钥*

与对称密钥不同，非对称密钥通常比它们所提供的安全级别更长。但这不是主要问题。非对称密钥比对称密钥更难生成，因为你不能仅仅从伪随机数生成器（PRNG）中提取*n*位并期望得到有效结果。非对称密钥不仅仅是原始的比特序列；它们代表一种特定类型的对象，比如具有特定属性的大数字（在 RSA 中是两个质数的积）。一个随机的比特串（因此也是一个随机数）不太可能具备所需的特定属性，因此不会是一个有效的密钥。

为了生成一个非对称密钥，你将伪随机位作为种子发送给*密钥生成算法*。这个密钥生成算法以一个至少与预定安全级别相同长度的种子值为输入，然后从中构建出私钥及其相应的公钥，确保两者都满足所有必要的标准。例如，一个简单的 RSA 密钥生成算法会生成一个数字 *n* = *pq*，通过使用一个算法生成两个大约相同长度的随机素数。该算法会随机选择数字，直到其中一个恰好是素数——因此，你还需要一个算法来测试一个数字是否是素数。

为了避免手动实现密钥生成算法的负担，你可以使用 OpenSSL 生成一个 4096 位的 RSA 私钥，像这样：

```
$ openssl genrsa 4096
Generating RSA private key, 4096 bit long modulus
..............................................................................
...............................++
...............................................++
e is 65537 (0x10001)
-----BEGIN RSA PRIVATE KEY-----
MIIJKQIBAAKCAgEA3Qgm6OjMy61YVstaGawk22A9LyMXhiQUU4N8F5QZXEef2Pjq
vTtAIA1hzpK2AJsv16INpNkYcTjNmechAJ0xHraftO6cp2pZFP85dvknsMfUoe8u
btKXZiYvJwpS0fQQ4tzlDtH45Gj8sMHcwFxTO3HSIx0XV0owfJTLMzZbSE3TDlN+
JdW8d9Xd5UVB+o9gUCI8tSfnOjF2dHlLNiOhlfT4w0Rf+G35USIyUJZtOQ0Dh8M+
--snip--
zO/dbYtqRkMT8Ubb/0Q1IW0q8e0WnFetzkwPzAIjwZGXT0kWJu3RYj1OXbTYDr2c
xBRVC/ujoDL6O3NaqPxkWY5HJVmkyKIE5pC04RFNyaQ8+o4APyobabPMylQq5Vo5
N5L2c4mhy1/OH8fvKBRDuvCk2oZinjdoKUo8ZA5DOa4pdvIQfR+b4/4Jjsx4
-----END RSA PRIVATE KEY-----
```

请注意，密钥是以特定格式呈现的——即，在 `BEGIN RSA PRIVATE KEY` 和 `END RSA PRIVATE KEY` 标记之间的 base64 编码数据。这是大多数系统支持的标准编码格式，系统将此表示形式转换为原始字节数据。开始处的点序列是一种进度条，`e 是 65537（0x10001）` 表示加密时使用的参数（记住，RSA 通过计算 *C* = *P*^(*e*) mod *n* 来加密）。

#### *保护密钥*

一旦你拥有了一个秘密密钥，你需要保持它的机密性，同时确保在需要时可以使用它。有三种方法可以解决这个问题。

**密钥封装（使用第二个密钥加密密钥）**

这种方法的问题在于，第二个密钥必须在你需要解密受保护的密钥时可用。实际上，这个第二个密钥通常是由用户在需要使用受保护的密钥时提供的密码生成的。这就是如何保护安全外壳协议（SSH）中私钥的方式。

**从密码实时生成**

在这里，不需要存储加密文件，因为密钥直接来自密码。像 miniLock 这样的现代系统使用这种方法。尽管这种方法比密钥封装更直接，但它的应用不如密钥封装广泛，部分原因是它更容易受到弱密码的攻击。例如，如果攻击者截获了某个加密消息：如果使用了密钥封装，攻击者首先需要获取受保护的密钥文件，而该文件通常存储在用户的本地文件系统中，因此不容易访问。但如果使用了实时生成，攻击者可以通过尝试用候选密码解密加密消息，直接搜索正确的密码。如果密码较弱，密钥就会被破解。

**将密钥存储在硬件令牌（智能卡或 USB 加密狗）上**

在这种方法中，密钥存储在安全内存中，即使计算机被攻破，它仍然保持安全。这是最安全的密钥存储方法，但也是最昂贵且最不方便的，因为它要求你随身携带硬件令牌，并且有丢失的风险。智能卡和 USB 加密狗通常需要输入密码来解锁存储在安全内存中的密钥。

**注意**

*无论使用何种方法，在交换密钥时务必确保不要将私钥误认为公钥，也不要通过电子邮件或源代码意外发布私钥。（我实际上在 GitHub 上发现过私钥。）*

要测试密钥包装，请运行此处显示的 OpenSSL 命令，并使用参数`-aes128`告诉 OpenSSL 用 AES-128（128 位密钥的 AES 加密）来加密密钥：

```
$ openssl genrsa -aes128 4096
Generating RSA private key, 4096 bit long modulus
..........++
.............................................................................................................................++
e is 65537 (0x10001)
Enter pass phrase:
```

系统将要求输入密码短语，用于加密新创建的密钥。

### 事物如何出错

密码学安全可能以多种方式出错。最大的风险是，当我们因为安全证明或经过充分研究的协议而产生虚假的安全感时，如以下两个例子所示。

#### *错误的安全证明*

即便是知名研究人员的安全证明也可能是错误的。最令人震惊的错误证明之一是*最优非对称加密填充（OAEP）*，这是一种使用 RSA 的安全加密方法，已被应用于许多应用程序。然而，OAEP 对抗选择密文攻击者的安全性证明曾被错误地接受为有效长达七年，直到 2001 年一位研究员发现了其中的缺陷。不仅证明是错的，结论也是错的。后来一个新的证明显示，OAEP 对选择密文攻击者几乎是安全的。我们现在必须相信这个新的证明，并希望它是无懈可击的。（更多详情，请参见 Victor Shoup 2001 年的论文《OAEP 重新审视》）。

#### *为兼容旧版支持使用短密钥*

2015 年，研究人员发现一些 HTTPS 网站和 SSH 服务器支持比预期更短的公钥加密：即 512 位，而不是至少 2048 位。请记住，在公钥方案中，安全性水平并不等同于密钥大小，对于 HTTPS 来说，512 位密钥的安全性约为 60 位。这些密钥在仅使用 72 个处理器的集群计算大约两周后就能被破解。许多网站受到了影响，包括 FBI 的网站。尽管软件最终得到了修复（得益于 OpenSSL 和其他软件的补丁），但这个问题仍然是一个令人不快的惊讶。

### 进一步阅读

要了解更多关于对称密码算法的可证明安全性，请阅读海绵函数文档（* [`sponge.noekeon.org/`](http://sponge.noekeon.org/) *）。海绵函数引入了基于置换的方法来进行对称加密，描述了如何仅使用一种置换构造一系列不同的加密函数。

关于攻击的实际成本，一些必读文献包括 Bernstein 于 2005 年发表的论文《理解暴力破解》和 Wiener 于 2004 年发表的论文《密码分析攻击的全部成本》，两篇文章都可以在线免费获取。

要确定给定密钥长度的安全级别，请访问 *[`www.keylength.com/`](http://www.keylength.com/)*。该网站还提供了关于常见加密工具（如 SSH、OpenSSL、GnuPG 等）中如何保护私钥的解释。

最后，作为一个练习，选择一个应用程序（如安全消息传递应用程序），并识别其加密方案、密钥长度和相应的安全级别。你常常会发现一些出乎意料的不一致性，例如，第一个方案提供 256 位的安全级别，而第二个方案仅提供 100 位安全级别。整个系统的安全性通常只与其最弱组件的安全性相当。
