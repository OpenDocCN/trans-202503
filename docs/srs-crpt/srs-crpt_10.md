## 第十章：难题

![image](img/common01.jpg)

困难的计算问题是现代密码学的基石。它们是描述起来简单，但实际上几乎不可能解决的问题。这些问题即使是最好的算法，也无法在太阳熄灭之前找到解决方案。

在 1970 年代，对难题的严格研究催生了一个新的科学领域——计算复杂性理论，它将对密码学以及许多其他领域产生深远影响，包括经济学、物理学和生物学。在本章中，我将为你提供理解密码安全基础所需的复杂性理论概念工具，并介绍公共密钥方案（如 RSA 加密和 Diffie–Hellman 密钥协议）背后的难题。我们将涉及一些深奥的概念，但我会尽量减少技术细节，只做表面探讨。不过，我希望你能看到密码学如何利用计算复杂性理论来最大化安全性之美。

### 计算难度

计算问题是通过足够的计算来回答的问题，例如，“2017 是质数吗？”或“在*incomprehensibilities*中有多少个*i*字母？”*计算难度*是指某些计算问题没有任何算法能在合理的时间内运行完成。这类问题也被称为*难解问题*，通常在实践中几乎不可能解决。

令人惊讶的是，计算难度与所使用的计算设备类型无关，无论是通用 CPU、集成电路，还是机械图灵机。事实上，计算复杂性理论的最初发现之一是，所有计算模型都是等效的。如果一个问题能在某个计算设备上高效解决，那么通过将算法移植到其他设备的语言上，也能在任何其他设备上高效解决——量子计算机是一个例外，但它们尚未问世（至少目前还没有）。因此，在讨论计算难度时，我们不需要指定底层计算设备或硬件，而是直接讨论算法。

为了评估难度，我们首先需要找到一种衡量算法复杂度或运行时间的方法。然后，我们将运行时间分为困难或容易。

#### *运行时间的测量*

大多数开发者都熟悉*计算复杂度*，即算法执行的操作次数，通常是输入大小的函数。大小通常以比特数或输入元素的数量来衡量。例如，以下是清单 9-1 中展示的伪代码。它在包含*n*个元素的数组中查找一个值*x*，然后返回其索引位置。

```
search(x, array, n):
    for i from 1 to n {
        if (array[i] == x) {
            return i;
        }
    }
    return 0;
}
```

*列表 9-1：一个简单的搜索算法，采用伪代码编写，复杂度与数组长度*n*成线性关系。*该算法返回在[1，*n*]中找到的值*x*的索引，如果找不到*x*，则返回 0。*

在这个算法中，我们使用`for`循环通过遍历数组来查找特定值*x*。每次迭代时，我们将变量*i*赋值为从 1 开始的数字。然后我们检查`array`中位置*i*的值是否等于*x*的值。如果是，我们返回位置*i*。否则，我们增加*i*并尝试下一个位置，直到我们到达*n*，即数组的长度，此时返回 0。

对于这种算法，我们将复杂度定义为`for`循环的迭代次数：最佳情况为 1（如果*x*等于`array[1]`），最坏情况为*n*（如果*x*等于`array[n]`，或者*x*在`array`中找不到），平均情况下为*n*/2（如果*x*随机分布在数组的*n*个单元格中的某一个）。如果数组的大小是原来的 10 倍，算法的速度将变慢 10 倍。因此，复杂度与*n*成正比，或者说是*n*的“线性”复杂度。*n*的线性复杂度被认为是快速的，与*n*呈指数增长的复杂度相对。尽管处理更大输入值会变慢，但对于大多数实际应用来说，差异通常只有几秒钟。

但许多有用的算法比这慢，并且具有高于线性复杂度的复杂度。教科书中的例子是排序算法：给定一组随机排列的*n*个值，通常需要*n* × log *n*次基本操作来排序该列表，这通常被称为*线性对数复杂度*。由于*n* × log *n*的增长速度快于*n*，排序的速度将比*n*的比例增长得更慢。然而，这些排序算法仍然属于*实用*计算领域，或者是能够在合理时间内完成的计算。

在某些时候，我们将遇到即使对于相对较小的输入长度也无法完成的上限。以密码分析中的最简单例子为例：暴力破解一个密钥。从第一章回顾，当给定明文*P*和密文*C* = **E**(*K*, *P*)时，恢复一个*n*位对称密钥最多需要 2^(*n*)次尝试，因为存在 2^(*n*)种可能的密钥——这是一个增长呈指数级的复杂度的例子。对于复杂度理论家来说，*指数复杂度*意味着一个问题几乎不可能解决，因为随着*n*的增长，努力迅速变得不可行。

你可能会反驳，我们这里比较的是苹果和橘子：在清单 9-1 中的 `search()` 函数里，我们统计了 `if (array[i] == x)` 操作的次数，而密钥恢复则统计了加密次数，每次加密的速度比一次 `==` 比较慢几千倍。若比较两种非常相似复杂度的算法，这种不一致可能会有所不同，但大多数时候它无关紧要，因为操作次数对结果的影响要大于单个操作的成本。而且，复杂度估算忽略了 *常数因子*：当我们说一个算法需要大约 *n*³ 次操作时间（即 *二次复杂度*），它实际上可能需要 41 × *n*³ 次操作，或者 12345 × *n*³ 次操作——但随着 *n* 增长，常数因子的影响会变得微不足道，以至于我们可以忽略它们。复杂度分析关注的是输入大小函数的理论难度；它不关心在你的计算机上需要多少个 CPU 周期。

你经常会看到 *O*() 符号（“大 O”）用于表示复杂度。例如，*O*(*n*³) 意味着复杂度增长不超过 *n*³，忽略潜在的常数因子。*O*() 表示算法复杂度的 *上界*。符号 *O*(1) 意味着一个算法在 *常数时间* 内运行——也就是说，运行时间不依赖于输入的长度！例如，判断一个整数的奇偶性的算法，通过检查其最低有效位（LSB），如果是零则返回“偶数”，否则返回“奇数”，无论整数的长度如何，它都会以相同的代价做同样的事情。

要查看线性、二次和指数时间复杂度之间的区别，可以参见图 9-1，比较 *O*(*n*)（线性）、*O*(*n*²)（二次）与 *O*(2^(*n*))（指数）的复杂度增长。

![image](img/f09-01.jpg)

*图 9-1：指数、二次和线性复杂度的增长，从最快到最慢增长*

指数复杂度意味着问题几乎不可能解决，而线性复杂度意味着解决方案是可行的，二次复杂度介于两者之间。

#### *多项式时间与超多项式时间*

上一节讨论的 *O*(*n*²) 复杂度（图 9-1 中的中间曲线）是更广泛的多项式复杂度类别的特例，或者 *O*(*n*^(*k*)), 其中 *k* 是一些固定数字，如 3、2.373、7/10 或 17 的平方根。多项式时间算法在复杂度理论和密码学中非常重要，因为它们是实际可行性的定义。当一个算法在 *多项式时间*（或简称 *poly**time*）内运行时，即使输入量很大，它也能在合理的时间内完成。这就是为什么多项式时间对于复杂度理论学家和密码学家来说是“高效”的代名词。

相比之下，运行在*超多项式* *时间*中的算法——即在*O*(*f*(*n*))中，其中*f*(*n*)是任何比任何多项式增长得更快的函数——被认为是不可行的。我这里说的是超多项式，而不仅仅是指数，因为在多项式和著名的指数复杂度*O*(2^(*n*))之间还有一些复杂度，例如*O*(*n*^(log(*n*)))，如图 9-2 所示。

![image](img/f09-02.jpg)

*图 9-2：2^n、n^(log(n)) 和 n² 函数的增长，从增长最快到最慢*

**注意**

*指数复杂度* O(2^n) *并不是最差的情况。有些复杂度增长得更快，从而使得算法计算变得更慢——例如，复杂度* O(n^n) *或* 指数阶乘 O(n^(f(n – 1)))，*其中对于任何* x，*函数* f *通过递归定义为* f(x) = x^(f(x – 1))。*实际上，你永远不会遇到如此荒谬复杂度的算法。*

*O*(*n*²) 或 *O*(*n*³) 可能是高效的，但 *O*(*n*⁹⁹⁹⁹⁹⁹⁹⁹⁹⁹⁹) 显然不是。换句话说，只要指数不太大，多项式时间就是快速的。幸运的是，所有被发现能解决实际问题的多项式时间算法都有较小的指数。例如，*O*(*n*^(1.465)) 是两个 *n* 位整数相乘的时间，或 *O*(*n*^(2.373)) 是两个 *n* × *n* 矩阵相乘的时间。2002 年突破性的多项式时间算法用于识别素数，最初的复杂度是 *O*(*n*¹²)，但后来改进为 *O*(*n*⁶)。因此，多项式时间可能不是算法实际时间的完美定义，但它是我们所能拥有的最佳定义。

进一步来说，无法通过多项式时间算法解决的问题被认为是不可行的，或称为*困难*。例如，对于简单的密钥搜索，除非加密算法被某种方式攻破，否则无法突破*O*(2^(*n*))的复杂度。

我们可以确定，对于暴力破解密钥搜索的*O*(2^(*n*))复杂度（只要加密算法是安全的），没有办法突破，但我们并不总是知道解决问题的最快方法。复杂性理论中的大量研究工作都是关于证明给定问题求解算法的复杂度*界限*。为了简化工作，复杂性理论家将计算问题按解决它们所需的努力程度划分为不同的组，或称为*类别*。

### 复杂度类别

在数学中，*类*是具有某些相似属性的对象的集合。例如，所有能在时间 *O*(*n*²) 内解决的计算问题，复杂度理论学者通常用 **TIME**(*n*²) 表示，它们属于同一个类。同样，**TIME**(*n*³) 是在时间 *O*(*n*³) 内能解决的问题类，**TIME**(2^(*n*)) 是在时间 *O*(2^(*n*)) 内能解决的问题类，依此类推。就像一台超级计算机能够计算任何一台笔记本电脑能计算的内容一样，任何在 *O*(*n*²) 内能解决的问题也能在 *O*(*n*³) 内解决。因此，**TIME**(*n*²) 类中的任何问题也属于 **TIME**(*n*³) 类，而这两个类都属于 **TIME**(*n*⁴) 类，依此类推。所有这些问题类的并集，**TIME**(*n*^(*k*)), 其中 *k* 是常数，被称为 **P**，表示多项式时间。

如果你曾经编写过计算机程序，你就会知道，看似快速的算法可能仍然因为消耗了所有的内存资源而导致系统崩溃。在选择算法时，你不仅要考虑它的时间复杂度，还要考虑它使用了多少内存，或者它的 *空间复杂度*。这尤其重要，因为单次内存访问通常比 CPU 中的基本算术操作慢得多。

正式来说，你可以将算法的内存消耗定义为其输入长度 *n* 的一个函数，方式和我们定义时间复杂度一样。使用 *f*(*n*) 位内存能够解决的问题类是 **SPACE**(*f*(*n*)）。例如，**SPACE**(*n*³) 是使用大约 *n*³ 位内存能够解决的问题类。就像我们有 **P** 作为所有 **TIME**(*n*^(*k*)) 的并集一样，所有 **SPACE**(*n*^(*k*)) 问题的并集被称为 **PSPACE**。

显然，内存越低越好，但多项式量级的内存并不一定意味着算法是实用的。为什么？举个例子，比如暴力破解密钥搜索：它只需要微不足道的内存，但速度极慢。更一般地说，即使一个算法只使用了少量内存，它也可能需要很长时间才能完成。

任何能在时间 *f*(*n*) 内解决的问题，最多只需要 *f*(*n*) 的内存，因此 **TIME**(*f*(*n*)) 包含于 **SPACE**(*f*(*n*)）。在时间 *f*(*n*) 内，你只能写入最多 *f*(*n*) 位的内容，不能更多，因为写（或读）1 位假设需要一个时间单位；因此，任何在 **TIME**(*f*(*n*)) 内能解决的问题，不能使用超过 *f*(*n*) 的空间。因此，**P** 是 **PSPACE** 的子集。

#### *非确定性多项式时间*

**NP** 是第二重要的复杂度类，仅次于 **P** 类（所有多项式时间算法的类）。不，**NP** 并不代表非多项式时间，而是代表 *非确定性* 多项式时间。这是什么意思呢？

**NP**是一个问题类，其中的解可以在多项式时间内验证——也就是说，即使解可能很难找到，也能高效地验证。所谓的*验证*是指，给定一个潜在的解，你可以运行某个多项式时间的算法来验证你是否找到了一个实际的解。例如，通过已知明文恢复密钥的问题属于**NP**，因为给定*P*，*C* = **E**(*K*, *P*)，以及某个候选密钥*K*[0]，你可以通过验证**E**(*K*[0], *P*)是否等于*C*来检查*K*[0]是否是正确的密钥。找到潜在的密钥（解）本身不能在多项式时间内完成，但验证密钥是否正确是通过多项式时间的算法来进行的。

现在来看一个反例：已知密文攻击怎么样？这次，你只得到一些**E**(*K*, *P*)的值，分别对应于随机未知的明文*P*。如果你不知道这些*P*是什么，那么就无法验证一个潜在密钥*K*[0]是否是正确的。换句话说，已知密文攻击下的密钥恢复问题不在**NP**中（更不用说在**P**中了）。

另一个不在**NP**中的问题是验证问题的*不存在*解。验证解是否正确归结为计算某个算法，输入候选解，然后检查返回值。然而，要验证*没有*解的存在性，你可能需要遍历所有可能的输入。如果输入的数量是指数级的，你就无法高效地证明没有解存在。对于**NP**类中最难的问题——即所谓的**NP**-完全问题，证明解不存在是非常困难的，我们接下来会讨论这些问题。

#### *NP-完全问题*

**NP**类中最难的问题被称为**NP**-完全问题；我们不知道如何在多项式时间内解决这些问题。正如复杂性理论家在 1970 年代开发**NP**-完全性理论时所发现的那样，**NP**类最难的问题都是一样难的。这一点已经通过证明任何一个**NP**-完全问题的高效解法都可以转化为另一个**NP**-完全问题的高效解法来证明。换句话说，如果你能高效地解决任何一个**NP**-完全问题，那么你就能解决所有**NP**-完全问题，以及所有**NP**中的问题。怎么做到的呢？

**NP**-完全问题有不同的表现形式，但从数学角度来看，它们本质上是相似的。实际上，你可以将任何一个**NP**-完全问题化简为另一个**NP**-完全问题，使得解决第一个问题依赖于解决第二个问题。

以下是一些**NP**-完全问题的示例：

**旅行商问题** 给定地图上的一组点（城市、地址或其他地理位置）以及每两个点之间的距离，找出一条访问所有点的路径，使得总距离小于给定的*x*。

**团问题** 给定一个数字 *x* 和一个图（如图 9-3 所示，图是由一组通过边连接的节点组成），确定是否存在一个由 *x* 个或更少的点组成的集合，使得这些点彼此之间都连接。

**背包问题** 给定两个数字 *x* 和 *y*，以及一组物品，每个物品都有已知的价值和重量，能否挑选出一组物品，使得总价值至少为 *x*，且总重量不超过 *y*？

![image](img/f09-03.jpg)

*图 9-3：包含四个点的团的图。寻找一个给定大小的团（所有节点互相连接的集合）在图中的一般问题是**NP**-完全的。*

这种**NP**-完全问题无处不在，从调度问题（给定某些优先级和持续时间的工作，和一个或多个处理器，分配工作到处理器，同时尊重优先级并最小化总执行时间）到约束满足问题（确定满足一组数学约束的值，例如逻辑方程）。甚至在某些视频游戏中获胜的任务有时也被证明是**NP**-完全的（例如，*俄罗斯方块*、*超级马里奥兄弟*、*宝可梦*和*糖果传奇*等著名游戏）。例如，文章《经典任天堂游戏是（计算上）困难的》（*[`arxiv.org/abs/1203.1895`](https://arxiv.org/abs/1203.1895)*）考虑了“可达性决策问题”，即判断是否可以从某个特定起点到达目标点。

这些视频游戏问题中的一些实际上比**NP**-完全问题还要难，称为**NP**-*困难*。我们说一个问题是**NP**-困难的，当它至少和**NP**-完全问题一样难。更正式地说，如果解决一个问题所需的步骤能够证明同时解决**NP**-完全问题，那么这个问题就是**NP**-困难的。

我必须提到一个重要的警告，并非所有**NP**-完全问题的*实例*都确实难以解决。一些特定的实例，因为它们较小或者具有特定的结构，可能会高效地解决。以图 9-3 中的图为例，仅仅观察几秒钟，你就能找到那个团，它就是顶部四个连接的节点——尽管前述的团问题是**NP**-困难的，但在这里并不困难。因此，**NP**-完全并不意味着所有给定问题的实例都很难，而是随着问题规模的增长，很多问题变得难以解决。

#### *P vs. NP 问题*

如果你能在多项式时间内解决最难的 **NP** 问题，那么你也可以在多项式时间内解决 *所有* **NP** 问题，因此 **NP** 将等于 **P**。这听起来荒谬；难道不明显吗，某些问题的解决方案容易验证却难以找到？例如，难道不明显，指数时间的暴力破解是恢复对称密码密钥的最快方法，因此这个问题不可能在 **P** 中吗？事实证明，尽管有高达百万美元的奖金，听起来多么荒谬，但至今没有人证明 **P** 不等于 **NP**。

克雷数学研究所将向任何证明 **P** ≠ **NP** 或 **P** = **NP** 的人颁发这笔奖金。这个问题，被称为 **P** 与 **NP** 问题，曾被著名的复杂性理论学家斯科特·阿伦森称为“人类有史以来提出的最深刻的问题之一”。想一想：如果 **P** 等于 **NP**，那么任何容易验证的解决方案也会很容易找到。所有实际使用的加密技术将不再安全，因为你可以有效地恢复对称密钥并反转哈希函数。

![image](img/f09-04.jpg)

*图 9-4：**NP**、**P** 类及 **NP**-完全问题集合*

但不要恐慌：大多数复杂性理论学家相信 **P** 不等于 **NP**，因此 **P** 是 **NP** 的严格子集，正如图 9-4 所示，**NP**-完全问题是 **NP** 的另一个子集，与 **P** 不重叠。换句话说，看起来难的问题实际上确实很难。只是很难从数学上证明这一点。虽然证明 **P** = **NP** 只需要为 **NP**-完全问题提供一个多项式时间的算法，但证明不存在这样的算法从根本上来说更为困难。但这并没有阻止一些古怪的数学家提出简单的证明，尽管这些证明通常显然是错误的，但常常成为有趣的阅读材料；例如，参见“**P** 与 **NP** 页面” (*[`www.win.tue.nl/~gwoegi/P-versus-NP.htm`](https://www.win.tue.nl/~gwoegi/P-versus-NP.htm)*)。

如果我们几乎可以确定确实存在难题，那么如何利用这些难题来构建强大且可证明安全的加密呢？想象一下，如果某个加密算法的破解被证明是 **NP**-完全的，那么只要 **P** 不等于 **NP**，该加密算法就无法破解。但现实令人失望：**NP**-完全问题已经被证明在加密领域很难应用，因为正是使其在一般情况下困难的结构，在特定情况下可能使它们变得容易——这些情况有时会出现在加密中。相反，加密技术通常依赖于*可能不是* **NP**-困难的问题。

### 因式分解问题

因式分解问题的目标是给定一个大数字 *N* = *p* × *q*，找到质数 *p* 和 *q*。广泛使用的 RSA 算法就基于因式分解数字的困难性。事实上，因式分解问题的难度正是使 RSA 加密和签名方案得以安全的原因。但在我们看到 RSA 如何在第十章中利用因式分解问题之前，我想先说服你，相信这个问题确实很难，但可能不是**NP**-完全的。

首先，来点幼儿园数学。一个*质数*是指不能被其他任何数字整除，除了它本身和 1。例如，数字 3、7 和 11 是质数；数字 4 = 2 × 2，6 = 2 × 3，和 12 = 2 × 2 × 3 则不是质数。数论中的一个基本定理表明，任何整数都可以唯一地表示为质数的乘积，这种表示被称为该数字的*因式分解*。例如，123456 的因式分解是 2⁶ × 3 × 643；1234567 的因式分解是 127 × 9721；依此类推。任何整数都有唯一的因式分解，或者说唯一的质数乘积表示。那么我们怎么知道给定的因式分解只包含质数，或者某个数字是否是质数呢？答案可以通过多项式时间质数性测试算法找到，这些算法使我们能够高效地测试一个给定的数字是否为质数。然而，从一个数字到其质因数的过程则是另一个问题。

#### *大数因式分解的实践*

那么，我们如何从一个数字出发，得到它的因式分解——即它作为质数乘积的分解呢？因式分解一个数字 *N* 最基本的方法是尝试将它除以所有小于它的数字，直到找到一个数字 *x*，使得 *x* 能整除 *N*。然后尝试用下一个数字 *x* + 1 来除 *N*，依此类推。最终你将得到 *N* 的因子列表。这个过程的时间复杂度是多少呢？首先，记住我们通常是将复杂度表示为输入的*长度*的函数。数字 *N* 的比特长度是 *n* = log[2] *N*。根据对数的基本定义，这意味着 *N* = 2^(*n*)。因为所有小于 *N*/2 的数字都可以作为 *N* 的可能因子，所以总共有大约 *N*/2 = 2^(*n*)/2 个值可以尝试。因此，我们朴素的因式分解算法的复杂度是 *O*(2^(*n*))，在 *O*()符号中忽略 1/2 的系数。

当然，许多数字很容易通过先找到一些小因子（如 2、3、5 等），然后反复分解其他非质因子来因式分解。但这里我们关注的是类似 *N* = *p* × *q* 这种形式的数字，其中 *p* 和 *q* 都是较大的数字，这在密码学中很常见。

我们可以稍微聪明一点。我们不需要测试所有小于*N*/2 的数字，而只需要测试质数，我们可以从测试小于*N*平方根的质数开始。实际上，如果*N*不是质数，那么它必须至少有一个小于其平方根√*N*的因数。这是因为如果*N*的两个因数*p*和*q*都大于√*N*，那么它们的乘积将大于√*N* × √*N* = *N*，这是不可能的。例如，如果我们说*N* = 100，那么它的因数*p*和*q*不能都大于 10，因为这样会导致乘积大于 100。*p*或*q*必须小于√*N*。

那么，仅测试小于√*N*的质数的复杂度是多少？*质数定理*表明，小于*N*的质数大约有*N*/log *N*个。因此，小于√*N*的质数大约有√*N*/log √*N*个。表达这个值，我们得到大约 2^(*n*/2)/*n*个可能的质因数，因此复杂度为*O*(2^(*n*/2)/*n*)，因为√*N* = 2^(*n*/2)，且 1/log√*N* = 1/(*n*/2) = 2*n*。这种方法比测试所有质数要快，但仍然非常慢——对于一个 256 位数字，大约需要 2¹²⁰次操作。这是一个相当不切实际的计算量。

最快的因式分解算法是*一般数域筛法（GNFS）*，我这里不描述它，因为它需要介绍几个高级数学概念。GNFS 的复杂度的大致估算是 exp(1.91 × *n*^(1/3) (log *n*)^(2/3))，其中 exp(…)只是指数函数*e^x*的不同表示法，*e*是指数常数，约等于 2.718。然而，很难准确估算 GNFS 对于特定数字大小的实际复杂度。因此，我们必须依赖启发式复杂度估算，它显示了随着*n*增大，安全性是如何增加的。例如：

+   对一个**1024 位**的数字进行因式分解，其中会有两个大约为 500 位的质因数，这将需要大约 2⁷⁰次基本操作。

+   对一个**2048 位**的数字进行因式分解，其中会有两个大约为 1000 位的质因数，这将需要大约 2⁹⁰次基本操作，比 1024 位数字要慢大约百万倍。

我们估计，至少需要 4096 位才能达到 128 位的安全性。请注意，这些值应该谨慎对待，研究人员对这些估算并不总是达成一致。可以查看这些实验结果，看看因式分解的实际成本：

+   2005 年，在约 18 个月的计算之后——并且得益于一个由 80 个处理器组成的集群，其计算总量相当于在单一处理器上进行 75 年的计算——一组研究人员成功地对一个**663 位**（200 十进制数字）的数字进行了因式分解。

+   2009 年，在大约两年的时间里，使用了数百个处理器，计算量相当于在单个处理器上进行约 2000 年的计算，另一个研究小组成功地因式分解了一个**768 位**（232 位十进制数字）的数字。

如你所见，学术研究者实际因式分解的数字比实际应用中的要短，后者至少是 1024 位，通常超过 2048 位。当我写这篇文章时，没有人报告过因式分解 1024 位的数字，但许多人猜测像 NSA 这样的资金充足的组织可能能够做到。

总之，1024 位 RSA 应视为不安全，RSA 至少应使用 2048 位的密钥——最好使用 4096 位的密钥以确保更高的安全性。

#### *因式分解是 NP 完全吗？*

我们不知道如何高效地因式分解大数，这表明因式分解问题不属于**P**类。然而，因式分解显然属于**NP**类，因为给定一个因式分解结果，我们可以通过检查所有因子是否为质数来验证解决方案，得益于上述的质数检测算法，并且当将这些因子相乘时，结果确实是期望的数字。例如，要检查 3 × 5 是否是 15 的因式分解，你需要检查 3 和 5 是否都是质数，并且 3 乘以 5 确实等于 15。

因此，我们有一个属于**NP**类且看起来很难的问题，但它真的像最难的**NP**问题一样难吗？换句话说，因式分解是**NP**完全的吗？剧透：很可能不是。

因式分解是否是**NP**完全问题没有数学证明，但我们有一些软证据。首先，所有已知的**NP**完全问题可能有一个解，但也可能有多个解，或者根本没有解。相比之下，因式分解总是只有一个解。并且，因式分解问题具有一种数学结构，使得 GNFS 算法能显著优于朴素算法，这种结构是**NP**完全问题所不具备的。如果我们有一台*量子计算机*，一种利用量子力学现象运行不同算法的计算模型，它能够高效地因式分解大数（不是因为它能更快地运行算法，而是因为它能够运行专门为因式分解大数设计的量子算法）。然而，量子计算机目前还不存在——并且可能永远也不会出现。无论如何，量子计算机在解决**NP**完全问题时也将毫无用处，因为它的速度与经典计算机并无不同（见第十四章）。

因此，在理论上，因式分解问题可能比**NP**完全问题稍微容易些，但就密码学而言，它已经足够难，而且比**NP**完全问题更可靠。事实上，在因式分解问题上构建密码系统比在**NP**完全问题上构建密码系统更容易，因为很难准确知道破解基于某些**NP**完全问题的密码系统有多难——换句话说，就是难以确定你能获得多少位的安全性。

因式分解问题只是密码学中作为*困难假设*使用的多个问题之一，*困难假设*是指某个问题在计算上是困难的。这个假设在证明破解密码系统的安全性至少与解决该问题一样困难时被使用。另一个作为困难假设使用的问题是*离散对数问题（DLP）*，实际上它是一个问题家族，接下来我们将讨论它。

### 离散对数问题

DLP 在密码学的官方历史中早于因式分解问题。RSA 虽然出现在 1977 年，但第二个密码学突破——Diffie–Hellman 密钥交换（见第十一章）——出现在大约一年前，其安全性建立在 DLP 的困难性之上。与因式分解问题一样，DLP 也涉及大数，但它稍微不那么直接——理解它可能需要几分钟，而不是几秒钟，并且它需要比因式分解更多的数学知识。所以让我介绍一下在离散对数的上下文中，*群*的数学概念。

#### *什么是群？*

在数学上下文中，*群*是一个元素的集合（通常是数字），这些元素根据某些明确的规则彼此相关。群的一个例子是非零整数集合（介于 1 和*p* – 1 之间），模某个质数*p*运算，我们将其表示为**Z**[*p*]^*。当*p* = 5 时，我们得到群**Z**[5]^* = {1,2,3,4}。在群**Z**[5]^*中，运算是在模 5 的情况下进行的；因此，我们不会得到 3 × 4 = 12，而是得到 3 × 4 = 2，因为 12 mod 5 = 2。我们依然使用与普通整数乘法相同的符号（×）。同样，我们也使用指数表示法来表示群元素与自身模*p*的乘法，这是密码学中常见的操作。例如，在**Z**[5]^*的上下文中，2³ = 2 × 2 × 2 = 3，而不是 8，因为 8 mod 5 等于 3。

要成为一个群，一个数学集合应具备以下特征，称为*群公理*：

**封闭性** 对于群中的任意两个 *x* 和 *y*，*x* × *y* 也在该群内。在**Z**[5]^*中，2 × 3 = 1（因为 6 = 1 mod 5），2 × 4 = 3，依此类推。

**结合律** 对于群中的任意 *x*、*y*、*z*，有 (*x* × *y*) × *z* = *x* × (*y* × *z*)。在**Z**[5]^*中，(2 × 3) × 4 = 1 × 4 = 2 × (3 × 4) = 2 × 2 = 4。

**单位元存在** 存在一个元素 *e*，使得 *e* × *x* = *x* × *e* = *x*。在任何**Z**[*p*]^*中，单位元是 1。

**逆元素** 对于群中的任何 *x*，存在一个 *y* 使得 *x* × *y* = *y* × *x* = *e*。在 **Z**[5]^* 中，2 的逆元素是 3，3 的逆元素是 2，而 4 是它自己的逆元素，因为 4 × 4 = 16 = 1 mod 5。

此外，如果对于任何群元素 *x* 和 *y*，*x* × *y* = *y* × *x*，则称该群为 *交换群*。这对于任何整数的乘法群 **Z**[*p*]^* 也成立。特别地，**Z**[5]^* 是交换群：3 × 4 = 4 × 3，2 × 3 = 3 × 2，等等。

如果存在至少一个元素 *g*，使得其幂（*g*¹，*g*²，*g*³，等等）模 *p* 可以覆盖所有不同的群元素，则称该群为 *循环群*。此时，元素 *g* 被称为群的 *生成元*。**Z**[5]^* 是一个循环群，具有两个生成元，2 和 3，因为 2¹ = 2，2² = 4，2³ = 3，2⁴ = 1，3¹ = 3，3² = 4，3³ = 2，3⁴ = 1。

请注意，我使用的是乘法作为群运算符，但你也可以使用其他运算符得到群。例如，最简单的群是所有整数的集合，包括正整数和负整数，且加法作为群运算。让我们检查加法是否符合群的公理，按以下顺序：显然，*x* + *y* 是整数，如果 *x* 和 *y* 是整数（封闭性）；(*x* + *y*) + *z* = *x* + (*y* + *z*) 对任何 *x*，*y* 和 *z* 都成立（结合性）；零是单位元；任何数 *x* 在该群中的逆元是 –*x*，因为 *x* + (–*x*) = 0 对任何整数 *x* 都成立。然而，存在一个很大的区别，那就是这个整数群是无限大小的，而在加密中我们只处理 *有限群*，即具有有限个元素的群。通常，我们会使用群 **Z**[*p*]^*，其中 *p* 是 *成千上万* 位长（即包含大约 2^(*p*) 个数字的群）。

#### *困难的事情*

离散对数问题（DLP）是寻找 *y*，使得 *g*^(*y*) = *x*，给定一个群 **Z**[*p*]^* 中的基数 *g*，其中 *p* 是素数，并且给定一个群元素 *x*。离散对数问题之所以称为 *离散*，是因为我们处理的是整数，而不是实数（连续）；它之所以称为 *对数*，是因为我们在寻找 *x* 关于 *g* 的对数。（例如，256 以 2 为底的对数是 8，因为 2⁸ = 256。）

人们常问我，因式分解和离散对数哪个更安全——换句话说，哪个问题更难？我的回答是，它们差不多一样难。实际上，解决离散对数问题的算法与因式分解算法相似，而且使用 *n* 位的难以因式分解的数字，得到的安全性与 *n* 位群中的离散对数相当。与因式分解的原因相同，离散对数问题不是 **NP**-完全问题。（请注意，有些群的离散对数问题更容易解决，但这里我仅指的是由素数模数构成的离散对数群。）

### 问题如何出现

40 多年过去了，我们仍然不知道如何高效地分解大数或解决离散对数问题。业余爱好者可能会辩称，总有一天某个人可能会破解因式分解——我们也没有证明它永远无法被破解——但我们也没有证明**P** ≠ **NP**。同样，你可以推测**P**可能等于**NP**；然而，根据专家们的说法，这种惊讶的可能性不大。所以不必担心。实际上，今天所有公开密钥加密技术都依赖于因式分解（RSA）或离散对数问题（Diffie–Hellman、ElGamal、椭圆曲线加密）。然而，尽管数学可能不会让我们失望，现实世界中的顾虑和人为错误却可能悄然潜入。

#### *当因式分解很容易时*

因式分解大数并不总是很难。例如，考虑这个 1024 位数字*N*，它等于以下形式：

![image](img/f0176-01.jpg)

对于在 RSA 加密或签名方案中使用的 1024 位数字，当*N* = *pq*时，我们预计最好的因式分解算法需要大约 2⁷⁰次操作，正如我们之前所讨论的。但你可以使用 SageMath（一个基于 Python 的数学软件）在几秒钟内分解这个示例数字。我在 2015 款 MacBook 上使用 SageMath 的`factor()`函数，花费不到五秒钟就找到了以下因式分解：

![image](img/f0176-02.jpg)

对的，我作弊了。这个数字并不是*N* = *pq*的形式，因为它不仅有两个大素因子，而是有五个，包括非常小的因子，这使得它容易分解。首先，你会通过从预计算的素数列表中尝试小素数来识别 2⁸⁰⁰ × 641 × 6700417 部分，剩下的则是一个比 1024 位数字容易分解的 192 位数字，它仅有两个大因子。

但是，因式分解不仅在*n*具有小素因子的情况下容易，还在*N*或其因子*p*和*q*具有特定形式时也容易——例如，当*N* = *pq*，其中*p*和*q*都接近某个 2^(*b*)时，当*N* = *pq*且已知*p*或*q*的一些位时，或者当*N*的形式是*N* = *p*^(*r*)*q*^(*s*)且*r*大于 log *p*时。然而，详细解释这些弱点的原因对于本书来说过于技术化。

这里的关键是，RSA 加密和签名算法（在第十章中讨论）需要使用*N* = *pq*的值，其中*p*和*q*是经过仔细选择的，以避免*N*的易分解性，这可能会导致安全灾难。

#### *小的难题并不难*

计算上困难的问题在它们足够小的时候变得容易，即使是指数时间的算法，在问题规模缩小时也变得实际可行。对称加密可能在没有比 2^(*n*)次的暴力破解攻击更快的攻击时仍然安全，但如果密钥长度为*n* = 32，你在几分钟内就能破解该加密。这听起来很显而易见，你可能认为没有人会天真到使用小密钥，但实际上，这种情况有很多可能的原因。以下是两个真实的故事。

假设你是一个对密码学一无所知的开发者，手上有一个 API 可以使用 RSA 加密，并被告知要使用 128 位安全性进行加密。那么，你会选择什么 RSA 密钥大小呢？我见过一些真实的案例，使用 128 位 RSA，或者基于 128 位数字 *N* = *pq* 的 RSA。然而，尽管对一个几千位长的 *N* 进行因式分解几乎不可能，但对一个 128 位数字进行因式分解却很容易。使用 SageMath 软件时，清单 9-2 中显示的命令瞬间完成。

```
sage: p = random_prime(2**64)
sage: q = random_prime(2**64)
sage: factor(p*q)
6822485253121677229 * 17596998848870549923
```

*清单 9-2：通过选择两个随机素数并即时因式分解来生成 RSA 模数*

清单 9-2 显示，作为两个 64 位素数的乘积，随机选取的一个 128 位数可以在一台典型的笔记本电脑上轻松分解。然而，如果我改为选择 1024 位的素数，通过使用 `p = random_prime(2**1024)`，命令 `factor(p*q)` 永远也不会完成，至少在我的一生中是如此。

公平地说，现有工具并不能有效防止不安全的短参数的天真使用。例如，OpenSSL 工具包允许你生成最短 31 位的 RSA 密钥而不发出任何警告；显然，这样短的密钥是完全不安全的，如清单 9-3 所示。

```
$ openssl genrsa 31
Generating RSA private key, 31 bit long modulus
.+++++++++++++++++++++++++++
.+++++++++++++++++++++++++++
e is 65537 (0x10001)
-----BEGIN RSA PRIVATE KEY-----
MCsCAQACBHHqFuUCAwEAAQIEP6zEJQIDANATAgMAjCcCAwCSBwICTGsCAhpp
-----END RSA PRIVATE KEY-----
```

*清单 9-3：使用 OpenSSL 工具包生成不安全的 RSA 私钥*

在回顾密码学时，你不仅应检查所使用算法的类型，还应检查其参数和密钥值的长度。然而，正如你将在以下故事中看到的那样，今天足够安全的东西，明天可能就不安全了。

2015 年，研究人员发现，许多 HTTPS 服务器和邮件服务器仍然支持旧版、不安全的 Diffie–Hellman 密钥交换协议。即，底层的 TLS 实现支持在一个组中使用 Diffie–Hellman，**Z**[*p*]^*，该组由一个仅有 512 位的素数 *p* 定义，而离散对数问题已经不再是一个实际不可计算的问题。

不仅服务器支持一个弱算法，攻击者还可以通过在客户端会话中注入恶意流量，强迫一个无辜的客户端使用这个算法。对攻击者来说更好的是，攻击的最大部分可以一次性执行，并重复用来攻击多个客户端。大约一周的计算用于攻击特定组，**Z**[*p*]^*，仅用了 70 秒就能破解不同用户的独立会话。

如果一个安全协议被削弱的算法所破坏，那么它毫无价值；而如果一个可靠的算法被弱参数所破坏，它也没有任何用处。在密码学中，你总是应该阅读细则。

要了解更多关于这个故事的细节，请查看研究文章《不完美的前向保密性：Diffie–Hellman 在实践中的失败》（*[`weakdh.org/imperfect-forward-secrecy-ccs15.pdf`](https://weakdh.org/imperfect-forward-secrecy-ccs15.pdf)*）。

### 进一步阅读

我鼓励你深入探讨计算的基础方面，特别是在可计算性（哪些函数是可计算的？）和复杂性（以什么代价计算？）的背景下，以及它们与密码学的关系。我大部分谈论的是**P**类和**NP**类问题，但对于密码学家来说，还有许多其他类别和有趣的点。我强烈推荐 Scott Aaronson 的书《量子计算自德谟克里特以来》（剑桥大学出版社，2013 年）。这本书主要讲的是量子计算，但它的前几章精彩地介绍了复杂性理论和密码学。

在密码学研究文献中，你还会发现其他一些计算困难的问题。我将在后续章节中提到它们，但这里有一些例子可以说明密码学家所利用问题的多样性：

+   Diffie–Hellman 问题（给定 *g*^(*x*) 和 *g*^(*y*)，求 *g*^(xy)）是离散对数问题的一种变体，广泛应用于密钥协商协议中。

+   格问题，如最短向量问题（SVP）和带误差学习问题（LWE），是唯一成功应用于密码学的**NP**-困难问题。

+   编码问题依赖于解码纠错码时缺乏足够信息的困难性，自 1970 年代末以来一直是研究的重点。

+   多元问题涉及解非线性方程组，可能是**NP**-困难的，但由于其困难版本过大且过慢，且实践中的版本被发现不安全，未能提供可靠的加密系统。

在第十章中，我们将继续讨论困难问题，特别是因式分解及其主要变体——RSA 问题。
