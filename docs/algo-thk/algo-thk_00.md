## **简介**

![Image](img/common01.jpg)

我假设你已经学会了使用像 C、C++、Java 或 Python 这样的编程语言……并且我希望你已经被它吸引了。很难向非程序员解释为什么通过编程解决问题是如此有意义且有趣的。

我还希望你已经准备好将你的编程技能提升到一个新高度。我有幸帮助你做到这一点。

### 我们将做什么

我本可以从教授你一些炫酷的新技巧开始，告诉你它们为何有用，并将它们与其他炫酷技巧进行比较，但我不会那样做。这些内容会被静置一旁，等待着某个机会来临——如果某个机会真能出现的话。

相反，在这本书中，我所做的就是提出问题：困难的问题。这些是我希望你无法解决的问题，是我希望会让你当前的方法陷入困境的问题。你是程序员，你想解决问题。现在是时候学习那些炫酷的技巧了。本书的全部内容就是提出难题，然后通过将你所知道的与你所需要的知识连接起来，解决这些问题。

这里你不会看到传统的教科书题目。你不会找到一个最优的矩阵链相乘方法，也不会计算斐波那契数列。我保证：你不会解决汉诺塔问题。市面上有很多优秀的教科书可以做这些事情，但我怀疑很多人并不会被这类谜题所吸引。

我的做法是使用你之前未见过的新问题。每年，成千上万的人参加编程竞赛，这些竞赛需要新的问题来衡量参与者能独立解决什么问题，而不是看谁能最快地用谷歌搜索。这些问题很吸引人，它们在经典问题的基础上加入了新的转折和背景，挑战人们找到新的解决方案。这些问题涵盖了似乎无尽的编程和计算知识。我们可以通过选择合适的问题，尽情学习。

让我们从一些基础开始。*数据结构*是组织数据的一种方式，目的是让所需的操作更快。*算法*是解决问题的一系列步骤。有时我们可以在不使用复杂数据结构的情况下制作快速算法；而有时候，正确的数据结构能大大提升速度。我的目标不是将你培养成一名竞赛程序员，虽然我会把那当作一种愉快的副产品。相反，我的目标是通过竞赛编程中的问题来教授你数据结构和算法——并在这个过程中享受乐趣。你可以通过* daniel.zingaro@gmail.com *联系我。如果你学到了东西，给我发邮件。如果你笑了，给我发邮件。

### 第二版新增内容

我非常享受与读者讨论本书第一版的机会。他们的反馈促成了本新版本中的许多变化和改进。

我对全书做了一些小的改进和补充，但以下是一些重要的更新亮点：

**第一章**   我移除了复合词问题，因为这个问题可以通过不需要哈希表的方法来解决。现在我们有了一个关于社交网站密码的问题。此外，我还简化了这一章的代码，以帮助没有 C/C++编程背景的读者，并增加了关于哈希表效率的更多信息。

**第三章**   我增加了更多关于如何发现动态规划中需要的子问题的指导。

**第四章**   这一章是全新的，重点讲解了更高级的记忆化和动态规划的应用。这是读者频繁提出的需求，我很高兴能够将这一部分加入其中。你将学习如何从反向的角度看待动态规划问题（以及为什么要这样做），如何在子问题数组中处理更多维度，并且如何进一步优化动态规划代码，尤其是在它还不够快速的时候。

**第五章，之前是第四章**   我加入了如何在使用动态规划和图之间做选择的指导。

**第八章，之前是第七章**   我进一步讨论了为什么我们将堆实现为数组而不是显式的树。

**第十章**   这一章是全新的，教你如何使用随机化，这个主题在书籍中并不常见。随机化是一种可以帮助你设计简单且快速的算法的技术。你将使用两种类型的随机化算法来解决那些否则会非常困难的问题。你还将学习如何在遇到问题时，判断是否需要使用随机化技术。

### 本书的读者群体

本书适合任何想学习如何解决复杂问题的程序员。你将学习许多数据结构和算法，它们的优点，它们可以帮助你解决的各种问题，以及如何实现它们。读完本书后，你会成为一个更优秀的程序员！

你是否正在参加一门数据结构和算法的课程，却被一堆定理和证明搞得不知所措？情况不一定非得如此。这本书可以作为你的辅导书，帮助你快速理解核心内容，以便你能够编写代码并解决问题。

你是否在为下一次编程面试寻找优势？你需要能够比较和对比不同的解决问题的方法，选择最合适的数据结构或算法，并能解释和实现你的解决方案。在阅读本书的过程中，你将反复练习这些技能。再也不需要害怕哈希表、递归、动态规划、树、图或堆了！

你是一个独立学习者，正在朝着数据结构和算法的专家目标努力吗？如果没有找到合适的资源，从互联网上拼凑学习内容会很累，而且可能会导致知识漏洞。本书将为你提供扎实的基础和一致的展示，帮助你成为专家。

如下节所述，本书中的所有代码都是用 C 编程语言编写的。然而，这不是一本学习 C 的书。如果你之前有 C 或 C++ 的编程经验，那就直接开始吧。如果你之前用过 Java 或 Python 这类语言，我猜你通过阅读会掌握大部分需要的知识，但你可能希望回顾一些 C 的概念，特别是在第一次遇到时。我会使用指针和动态内存分配，所以无论你之前有什么经验，你可能都需要复习这些主题。我推荐的最佳 C 书籍是 K. N. King 的《C 程序设计：现代方法》（第二版）。即使你对 C 没问题，也建议读一读。它非常优秀，任何时候遇到 C 相关的问题，都是极好的伴侣。

### 我们的编程语言

我选择使用 C 作为本书的编程语言，而不是 C++、Java 或 Python 这类高级语言。我会讨论为什么这样做，并且解释我在 C 相关的其他一些决策。

#### *为什么使用 C？*

使用 C 的主要原因是我希望从零开始教你数据结构和算法。当我们需要哈希表时，我们自己构建它。不会依赖字典、哈希映射或其他语言的类似数据结构。当我们不知道字符串的最大长度时，我们会构建一个可扩展的数组：我们不会让语言为我们处理内存分配。我希望你能完全明白发生了什么，绝不藏私。使用 C 帮助我实现这个目标。

在本书中，像我们这样用 C 解决编程问题，是你决定继续学习 C++ 时的有用入门。如果你决定深入竞争性编程，你会高兴地发现，C++ 是最受竞争性编程人员欢迎的语言，因为它有丰富的标准库，并且能够生成优化速度的代码。

#### *静态关键字*

常规的局部变量存储在所谓的 *调用栈* 中。每次调用一个函数时，部分调用栈内存会用来存储局部变量。然后，当函数返回时，这些内存会被释放出来，以供其他局部变量使用。不过，调用栈较小，不适合存储本书中我们会遇到的一些庞大数组。这时，`static` 关键字就派上用场了。将 `static` 用于局部变量时，会将其存储持续时间从自动变为静态，这意味着该变量在函数调用之间保持其值。副作用是，这些变量 *不会* 与常规局部变量存储在同一内存区域，否则它们的值在函数结束时会丢失。相反，它们被存储在自己独立的内存段中，不必与调用栈上的其他内容竞争。

使用 `static` 关键字时需要注意的一点是，这些局部变量只会被初始化一次！快速示例请参见 示例 1。

```
int f(void) {
❶ static int x = 5;
   printf("%d\n", x);
   x++;
}

int main(void) {
  f();
  f();
  f();
  return 0;
}
```

*示例 1：带有 static 关键字的局部变量*

我在局部变量 `x` ❶ 上使用了 `static`。没有它，你应该会看到 `5` 被打印三次。然而，由于使用了 `static`，你应该看到如下输出：

```
5
6
7
```

#### *包含文件*

为了节省空间，我没有包括应该在 C 程序开头添加的 `#include` 行。如果你包含以下内容，就不会出错：

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
```

#### *释放内存*

与 Java 或 Python 不同，C 语言要求程序员释放所有手动分配的内存。模式是使用 `malloc` 分配内存，使用该内存，然后使用 `free` 释放内存。

然而，由于两个原因，我在这里没有释放内存。首先，释放内存会增加杂乱，分散代码的主要教学目的。其次，这些程序的生命周期很短：你的程序将在几个测试用例上运行，完事儿就结束了。操作系统在程序终止时会回收所有未释放的内存，所以即使你多次运行程序，也无需担心。当然，在实践中不释放内存是非常不负责任的：没有人会喜欢一个随着运行而消耗越来越多内存的程序。如果你想练习释放内存，你可以在本书中展示的程序里加入 `free` 调用。

### 主题选择

数据结构和算法的领域太广泛，无法被一本书（或者这位作者）所包容。我使用了三个标准来帮助我决定哪些主题值得纳入其中。

首先，我选择了具有广泛适用性的主题：每个主题不仅可以用来解决书中的相应问题，还能解决许多其他问题。在每一章中，我至少关注两个问题。我通常用第一个问题来介绍数据结构或算法以及它的一个典型应用。其他问题则旨在让你了解数据结构或算法的更多用途。例如，在第六章中，我们研究了 Dijkstra 算法。如果你在 Google 上搜索它，你会发现 Dijkstra 算法用于寻找最短路径。的确，在本章的第一个问题中，我们就是用它来做这个事情。然而，在第二个问题中，我们进一步改进 Dijkstra 算法，不仅找出最短路径，还计算最短路径的数量。我希望随着你深入每一章，你能更多地了解每种技术的应用范围、约束和细节。

其次，我选择了那些实现不会淹没周围讨论的主题。我希望任何问题的解决方案的代码量不超过 150 行。那包括读取输入、解决问题本身和产生输出。如果某个数据结构或算法的实现需要 200 或 300 行代码，那出于实际原因，它就不适合了。

第三，我选择了那些能够支持正确性论证的主题，我希望这些论证既令人信服又直观。教授你特定的数据结构和算法当然是我的目标之一，因为我假设你来这里是为了学习强大的问题解决方法及其实现。同时，我也希望你对*为什么*你所学的内容有效感兴趣，所以我在更为隐秘的目标上也做了一些努力：说服你相信数据结构或算法是正确的。这里不会有正式的证明或类似的内容。不过，如果我在我的隐秘目标上取得了成功，那么你将在学习数据结构或算法的同时，也学到正确性的问题。不要仅仅满足于追踪代码并惊叹它每次都能神奇地运行。没有魔法，能够使代码运行的洞察就在你手边，就像代码本身一样。

如果你想深入了解本书的内容，建议从附录 B 开始。在那里，我加入了一些与第一章、第三章、第五章、第八章、第九章和第十章相关的附加材料。

许多读者通过在阅读本书的同时进行练习或阅读额外的资料将受益。章节末尾的“注释”部分指出了额外的资源，其中一些包含了更多的例子和样例题。还有一些在线资源提供了精选的、分类整理的问题及其解题策略。我找到的最全面的资源是 Steven Halim 和 Felix Halim 的*解题方法*页面；请参见 [*https://cpbook.net/methodstosolve*](https://cpbook.net/methodstosolve)。

### 编程竞赛平台

我选择的每个问题都可以在一个编程竞赛平台上找到。许多这样的竞赛平台存在，每个平台通常包含数百个问题。我尽量保持我们使用的竞赛平台数量较少，但又足够多，以便给我选择最合适问题的灵活性。对于每个竞赛平台，你需要一个用户名和密码；现在就设置好你的账户是值得的，这样在阅读本书时，你就不用中途停下来去设置账户了。以下是我们将使用的竞赛平台：

**Codeforces**   [*https://codeforces.com*](https://codeforces.com)

**DMOJ**   [*https://dmoj.ca*](https://dmoj.ca)

**POJ**   [*http://poj.org*](http://poj.org)

**SPOJ**   [*http://spoj.com*](http://spoj.com)

**UVa**   [*https://uva.onlinejudge.org*](https://uva.onlinejudge.org)

每个问题的描述开始时都会指明该问题可以在某个竞赛平台上找到，并给出你应使用的特定问题代码以访问该问题。

尽管竞赛平台上的一些问题由个人贡献者编写，但其他问题则来自于著名的竞赛。以下是一些本书中问题来源的竞赛：

**国际信息学奥林匹克（IOI）**   这是一个为高中生举办的著名年度比赛。每个参赛国最多派出四名选手，但每名选手单独参赛。比赛持续两天，每天都有多个编程任务。

**加拿大计算机竞赛（CCC）和加拿大信息学奥林匹克（CCO）**   这些是由滑铁卢大学组织的年度高中生竞赛。CCC（即第一阶段）在各个学校举行，表现最好的选手将进入第二阶段（CCO），即在滑铁卢大学举行的竞赛。第二阶段表现最好的选手将代表加拿大参加 IOI。作为一名高中生时，我参加了 CCC，但我从未进入 CCO——我连接近的机会都没有。

**克罗地亚信息学公开赛（COCI）**   这个在线比赛每年举办多次。表现优异的选手将被选入克罗地亚的 IOI 代表队。

**全国中学生信息学奥林匹克（NOIP）** 这是中国的一个年度比赛，类似于加拿大的 CCC。表现最好的选手将被邀请参加中国全国信息学奥林匹克（NOI）。NOI 的优胜者有资格参加进一步的训练，并可能被选拔进入中国 IOI 队。

**南非编程奥林匹克（SAPO）** 这项比赛每年举办三轮。比赛的难度逐渐增加，从第一轮到第二轮，再到最终轮。比赛成绩用于选拔代表南非参加 IOI 的学生。

**美国计算奥林匹克（USACO）** 这项在线比赛每年举办几次，其中最具挑战性的比赛是美国公开赛。在每次比赛中，你将遇到四个难度级别的题目：青铜（最简单）、白银、黄金和铂金（最难）。比赛成绩用于选拔美国 IOI 队伍。

**中北美东部地区编程竞赛（ECNA）** 在这项为大学生举办的年度比赛中，表现最好的选手将被邀请参加年度国际大学生程序设计竞赛（ICPC）世界总决赛。与这里的其他比赛不同，学生们是单独竞争的，而 ECNA 和世界总决赛则是团队比赛。

**DWITE** 这是一个旨在帮助学生为年度比赛做准备的在线编程比赛。不幸的是，DWITE 现在已经不再举行，但那些旧的题目——它们真的很不错！——依然可以使用。

参见附录 C 了解本书中每个问题的来源。

当你提交代码解决问题时，评审会编译你的程序并在测试用例上运行。如果你的程序通过了所有的测试用例，并且在规定时间内完成，那么你的代码会被接受为正确；评审会显示`AC`表示接受的解答。如果你的程序未通过一个或多个测试用例，那么你的程序将不被接受；在这种情况下，评审会显示`WA`（“错误答案”）。一种常见的结果是程序运行过慢，评审会显示`TLE`（“超时”）。请注意，`TLE`并不意味着你的代码其他部分是正确的：如果你的代码超时，评审将不再运行后续的测试用例，所以可能有一些`WA`的 bug 被隐藏在`TLE`背后。

在本书出版时，我为每个问题提供的解决方案均能在规定时间内通过所有测试用例并满足指定的评审要求。在这些基本要求的基础上，我的目标是让代码具有可读性，并且选择清晰性优于速度。这是一本关于教授数据结构与算法的书，而不是让程序在完成任务的前提下追求更高的性能。

### 问题描述的结构

在解决问题之前，我们必须清楚自己被要求做什么。这种精确性不仅仅体现在理解任务本身上，还体现在我们应该如何读取输入并产生输出。因此，每个问题开始时都会有三个组成部分的描述：

**问题**   在这里，我提供了问题的背景和我们需要做的事情。仔细阅读这部分材料很重要，以便你能完全理解我们要解决的问题。有时，误读或误解一些看似微小的词语可能会导致错误的解决方案。例如，第三章中的一个问题要求我们购买“至少”一定数量的苹果：如果你只购买“恰好”那数量的苹果，程序将无法通过某些测试用例。

**输入**   问题的作者提供了测试用例，必须通过所有测试用例，提交才会被认为是正确的。我们的责任是从输入中读取每个测试用例，以便我们可以处理它。我们怎么知道有多少个测试用例呢？每个测试用例的每一行包含什么内容？如果是数字，它们的范围是什么？如果是字符串，它们的长度可以是多少？所有这些信息都在这里提供。

**输出**   如果一个程序能够输出正确的答案，但因为输出格式不正确而未通过测试用例，这会让人非常沮丧。问题描述中的输出部分明确规定了我们应该如何生成输出。例如，它会告诉我们每个测试用例应产生多少行输出，每行应包含什么内容，是否需要在测试用例之间或之后添加空行，等等。此外，我还提供了问题的时间限制：如果程序未能在时间限制内为所有测试用例输出解决方案，那么程序将无法通过。

我已经重写了每个问题的文本，以便在整个文档中保持一致的呈现方式。尽管有这些修改，我的描述传达的信息将与官方描述相同。

本书中大多数问题，我们会从标准输入读取数据并将输出写入标准输出。（只有两个问题不涉及标准输入和输出；它们在第七章中。）这意味着我们应该使用诸如`scanf`、`getchar`、`printf`等 C 语言函数，而不是显式地打开和关闭文件。

### 启动问题：食物排队

让我们通过一个示例问题描述来熟悉一下。我会在过程中提供一些评论（括号内），引导你关注重要的部分。一旦我们理解了问题，我想不出比解决它更好的办法了。与书中的其他问题不同，我们将能够使用我希望你已经掌握的编程结构和思想来解决它。如果你能独立解决这个问题，或者轻松跟随我的解决方案，那我认为你已经为接下来的内容做好准备。如果你遇到严重的困难，可能需要回顾一些编程基础，或者先解决一些其他入门问题再继续。

这是 DMOJ 问题`lkp18c2p1`。（你可能现在就想去 DMOJ 网站搜索这个问题，以便我们完成代码后提交。）

#### *问题描述*

有*n*条排队等候食物的队伍。我们知道每条队伍中已经排队的人数。接着，*m*个新的人将到达，他们会加入到人数最少的队伍（即人数最少的队伍）。我们的任务是确定每个新加入的人会加入哪个队伍以及该队伍中的人数。

（花点时间理解上面的段落。接下来会有一个示例，如果有什么不清楚的，可以通过结合上面的段落和下面的示例来解决。）

这是一个示例。假设有三条队伍，队伍 1 有 3 个人，队伍 2 有 2 个人，队伍 3 有 5 个人。然后，四个新的人到达。（在继续读下去之前，试着计算一下这种情况会发生什么。）第一个人加入队伍 2，队伍 2 现在有 3 个人。第二个人加入队伍 1，队伍 1 现在有 4 个人。第三个人加入队伍 2，队伍 2 现在有 4 个人。第四个也是最后一个人加入队伍 1，队伍 1 现在有 5 个人。

##### 输入

输入包含一个测试用例。输入的第一行包含两个正整数，*n*和*m*，分别表示排队的人数行数和新来的人数。*n*和*m*的最大值为 100。输入的第二行包含*n*个正整数，表示新来的人到达前每条队伍的人数。这些整数的最大值为 100。

以下是上述测试用例的输入：

```
3 4
3 2 5
```

（请注意，这里只有一个测试用例。因此，我们应该期望读取恰好两行输入。）

##### 输出

对于每个新加入的*m*个人，输出一行，包含他们所加入队伍的人数。

上述测试用例的正确输出是：

```
2
3
3
4
```

解决该测试用例的时间限制是三秒。（鉴于我们每个测试用例最多要处理 100 个新加入的人，三秒足够了。我们不需要任何复杂的数据结构或算法。）

#### *解决问题*

对于涉及难以手动构建的数据结构的问题，我可能会先从读取输入开始。否则，我倾向于把这部分代码留到最后。原因是我们通常可以通过传入示例值来测试我们编写的函数；直到我们准备好解决整个问题时，才需要担心解析输入。

我们需要维护的关键数据是每条行中的人数。合适的存储方式是使用数组，每条行一个索引。我们将使用一个名为`lines`的变量来存储这个数组。

每个新到的人都会选择加入一条最短的行，所以我们需要一个辅助函数来告诉我们哪一行是最短的。该辅助函数见清单 2。

```
int shortest_line_index(int lines[], int n) {
  int j;
  int shortest = 0;
  for (j = 1; j < n; j++)
    if (lines[j] < lines[shortest])
      shortest = j;
  return shortest;
}
```

*清单 2：最短行的索引*

现在，给定一个`lines`数组以及`n`和`m`，我们可以解决一个测试用例，相关代码见清单 3：

```
void solve(int lines[], int n, int m) {
  int i, shortest;
  for (i = 0; i < m; i++) {
    shortest = shortest_line_index(lines, n);
    printf("%d\n", lines[shortest]);
 ❶ lines[shortest]++;
  }
}
```

*清单 3：解决问题*

在`for`循环的每次迭代中，我们调用辅助函数来获取最短行的索引。然后我们打印该最短行的长度。接着，这个人加入该行：因此我们必须将该行中的人数加一 ❶。

剩下的就是读取输入并调用`solve`函数；这在清单 4 中完成。

```
#define MAX_LINES 100

int main(void) {
  int lines[MAX_LINES];
  int n, m, i;
  scanf("%d%d", &n, &m);
  for (i = 0; i < n; i++)
    scanf("%d", &lines[i]);
  solve(lines, n, m);
  return 0;
}
```

*清单 4：主函数*

将我们的`shortest_line_index`、`solve`和`main`函数整合起来，并在顶部添加所需的`#include`语句，就能得到一个完整的解决方案，可以提交给评测系统。在提交时，务必选择正确的编程语言：对于本书中的程序，你需要选择 GCC、C99、C11，或评测系统所指定的 C 语言编译器。

如果你想在提交代码之前在本地测试它，有几种方法。由于我们的程序是从标准输入读取的，你可以做的一件事是运行程序并手动输入测试用例。对于小型测试用例，这是一种合理的做法，但重复这样做会很繁琐，特别是对于大型测试用例。（你可能还需要在输入后发出一个文件结束控制代码，例如在 Windows 上按 CTRL-Z，或在其他操作系统上按 CTRL-D。）一个更好的方法是将输入存储在文件中，然后使用*输入重定向*从命令提示符将程序输入重定向到该文件，而不是键盘。例如，如果你将当前问题的测试用例存储在文件*food.txt*中，且编译后的程序名为*food*，那么可以尝试：

```
$ food < food.txt
```

这样就可以轻松地处理多个测试用例：只需更改*food.txt*中的内容，然后再次使用输入重定向运行程序。

恭喜你！你已经解决了第一个问题。而且，你现在了解了我们在本书中处理每个问题的游戏计划，我们将使用我在这里给出的相同通用结构。我们首先会理解问题本身并通过一些例子来演示。接着，我们将开始编写代码来解决问题。不过，我们不一定会一次就写对。也许我们的代码会太慢，或者无法通过某些特定的测试用例。这没关系！我们将学习新的数据结构和算法，然后重新应对问题。最终，我们将解决每一个问题——而每次解决后，我们都会比开始时更了解并成为更好的程序员。

让我们开始吧。

### 在线资源

本书的补充资源，包括可下载的代码和额外的练习题，可以在[*https://nostarch.com/algorithmic-thinking-2nd-edition*](https://nostarch.com/algorithmic-thinking-2nd-edition)找到。

### 注释

《食品线》最初来自 2018 年 LKP 竞赛 2，由 DMOJ 主办。
