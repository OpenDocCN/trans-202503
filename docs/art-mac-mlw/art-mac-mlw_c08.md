# 8

调试

![](img/chapterart.png)

尽管上一章介绍的被动动态分析工具通常可以提供恶意样本的见解，但它们只是间接观察样本的行为，可能无法完全揭示其内部工作原理。在某些情况下，你需要更全面的工具。

最终的动态分析工具是调试器。*调试器*是一个程序，它允许你逐条执行另一个程序的指令。在任何时候，你都可以检查或修改它的寄存器和内存内容，操控控制流等等。在这一章中，我将通过 macOS 的事实标准调试器 LLDB 来介绍各种调试概念。接下来，我们将通过一个案例研究，应用这些概念来揭示在苹果官方应用商店中发现的一款应用程序中的隐秘加密货币挖掘逻辑。

## 为什么你需要调试器

以下示例应该清楚地说明调试器的强大功能。看看这段来自恶意软件 Mami（由我亲自命名）反汇编的代码片段。在这段代码中，我们发现了一大块嵌入的加密数据，它被传递给名为 `setDefaultConfiguration` 的方法（清单 8-1）：

```
[SBConfigManager setDefaultConfiguration:
@"uZmgulcipekSbayTO9ByamTUu_zVtsflazc2Nsuqgq0dXkoOzKMJMNTULoLpd-QV9qQy6VRluzRXqWOGscgheRvikLkPR
zs1pJbey2QdaUSXUZCX-UNERrosul22NsW2vYpS7HQO4VG5l8qic3rSH_fAhxsBXpEe557eHIr245LUYcEIpemnvSPTZ_lN
p2XwyOJjzcJWirKbKwtc3Q61pD..."];
```

清单 8-1：加密数据（Mami）

如果一个恶意样本包含加密数据，那么恶意软件作者通常试图隐瞒某些信息，无论是对检测工具还是对恶意软件分析师。因此，当我们遇到这样的数据时，我们应该有动力将其解密，以揭示其秘密。根据 Mami 方法的名称，我们可以合理地推测，这些嵌入的数据决定了一些初始配置。它可能包含对恶意软件分析师有价值的信息，比如命令与控制服务器的地址、恶意软件的能力洞察等等。

那么我们如何解密它呢？静态分析方法通常效率低下，因为它们要求我们既要理解所使用的加密算法，又要恢复解密密钥。文件或进程监视器在这种情况下也几乎没有用处，因为 Mami 的加密配置数据既没有写入磁盘，也没有传递给其他进程。换句话说，它仅在 Mami 进程的内存空间中以解密状态存在。

使用调试器，我们可以轻松提取这些信息。首先，我们可以指示恶意软件执行，直到它到达 `setDefaultConfiguration:` 方法。然后，通过*单步执行*，即逐条执行每一条指令，我们可以让恶意软件继续执行，控制其进程，在完成配置数据的解密时暂停。由于调试器可以直接检查它正在调试的进程的内存，因此我们可以随后*转储*，或者打印出现在已解密的配置数据（清单 8-2）：

```
{
 "dnsChanger" =  {
   "affiliate" = "";
   "blacklist_dns" = ();
   "encrypt" = true;
   "external_id" = 0;
   "product_name" = dnsChanger;
   "publisher_id" = 0;
    ...
   "setup_dns" =         (
      "82.163.143.135",
 "82.163.142.137"
    );
    "shared_storage" = "/Users/%USER_NAME%/Library/Application Support";
    "storage_timeout" = 120;
   };
 "installer_id" = 1359747970602718687;
 ...
}
```

清单 8-2：解密后的配置数据（Mami）

各种解密的键/值对，例如`"product_name" = dnsChanger`和`setup_dns`数组，提供了对恶意软件目标的洞察：劫持感染系统的 DNS 设置，然后强制将域名解析通过攻击者控制的服务器进行路由。顺便提一下，从解密的配置中我们现在知道，这些服务器位于`82.163.143.135`和`82.163.142.137`。也许这个分析中最值得注意的方面是，我们几乎没有动手，也不需要花时间去理解这些数据是如何被加密的！

这只是调试器强大功能的一个例子。通常，你应该使用调试器来全面理解一个代码样本，并动态修改它，例如绕过反分析逻辑（在第九章中讨论）。当然，一些挑战会影响这些好处。调试器是一个复杂的工具，需要特定的低级知识；因此，完成分析可能需要相当长的时间。然而，一旦你理解了调试器的概念和高效调试的技巧，调试器将成为你最好的恶意软件分析助手。通常，它被证明是分析任何样本时最有效且最全面的方法。

然而，有一点警告值得重申。动态分析样本（包括调试器中的分析）涉及执行（潜在的）恶意代码，因此应始终在隔离的分析系统或虚拟机上进行。后者具有快照的优势，可以让你轻松地在恶意样本的调试会话出现问题时恢复。

## LLDB 调试器

本章我们将重点介绍如何使用*LLDB*，这是调试程序（包括恶意软件）在 macOS 上的事实标准工具。虽然像 Hopper 这样的其他应用程序在其上构建了用户友好的界面，但你可能会发现，直接与 LLDB 的命令行界面交互是最有效的方法。如果你已经安装了 Apple 的 Xcode，你会发现 LLDB 与之一起安装在*/usr/bin/lldb*。如果没有，你可以通过在终端中输入`lldb`并同意安装提示来安装 LLDB 作为独立程序。

在本节中，我们将介绍各种调试概念，例如断点和控制流操作，我将演示如何通过 LLDB 应用这些概念，以促进恶意软件的分析。需要注意的是，LLDB 网站提供了丰富的详细知识，例如深入的教程。^(1) 此外，在调试过程中，你始终可以使用 LLDB 的`help`命令查看有关任何命令的内联信息。

从高层次来看，调试会话通常按照以下方式进行：

1.  你通过将一个项目（例如恶意样本）加载到调试器中来初始化调试会话。

1.  您可以在示例代码的不同位置设置断点，例如在其主入口点或感兴趣的函数调用处。示例被启动并运行，直到遇到断点，此时执行将被暂停。

1.  一旦调试器暂停执行，您就可以自由地四处探索，检查内存和寄存器值，操控控制流，设置其他断点，等等。

1.  您可以继续执行，直到遇到下一个断点，或一次执行一条指令。

请记住，当调试恶意样本时，它被允许执行。因此，始终在虚拟机或独立分析系统中进行调试。这可以确保不会发生持久性损害，并且如果您在虚拟机中进行调试，始终可以将其恢复到先前的状态。在调试会话中，这通常非常有用。例如，您可能会不小心错过一个断点，导致恶意软件完全运行。

### 启动调试器会话

有几种方法可以在 LLDB 中启动调试会话。最简单的方法是从终端执行 LLDB，传入要分析的二进制文件路径，然后是任何其他附加参数（清单 8-3）：

```
% **lldb ~/Downloads/malware** `<arg0 arg1 arg2>`

(lldb) **target create "malware"**
Current executable set to 'malware' (x86_64).
```

清单 8-3：启动调试会话

如您所见，调试器将显示目标创建消息，记录下要调试的可执行文件，并识别其架构。尽管 LLDB 已经创建了调试会话，但尚未执行程序的任何指令。

您还可以将 LLDB 附加到正在运行的进程实例，如下所示：

```
% **lldb -pid**`<target pid>`
```

一旦调试器附加到进程，调试会话就可以开始。然而，我们很少使用这种方法分析恶意软件，因为一旦恶意软件已经运行，其核心逻辑（我们通常希望理解的部分）可能已经执行。此外，这些逻辑可能包含反调试代码，阻止调试器附加。

启动调试会话的第三种方式是通过 LLDB shell 运行 `process attach` 命令，指定进程名称并添加 `--waitfor` 标志，如清单 8-4 所示。这会指示调试器等待与该名称匹配的进程，并在进程启动时附加。

```
% **lldb**
(lldb) **process attach --name malware --waitfor**
```

清单 8-4：等待附加到进程（命名为恶意软件）

附加到进程后，调试器将暂停执行。输出将类似于清单 8-5：

```
Process 14980 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP
...

Executable module set to "~/Downloads/malware".
Architecture set to: x86_64h-apple-macosx-.
```

清单 8-5：进程附加，通过 `--waitfor` 标志触发

`--waitfor` 标志在恶意软件生成其他恶意进程时尤其有用，您可能还希望调试这些进程。

### 控制执行

调试器最强大的功能之一是能够精确控制其正在调试的进程的执行。例如，您可以指示进程执行一条指令，然后暂停。表 8-1 描述了几个与执行控制相关的 LLDB 命令。

表 8-1: 控制执行的 LLDB 命令

| **LLDB 命令** | **描述** |
| --- | --- |
| `run` (`r`) | 运行调试的进程。启动执行，直到命中断点、遇到异常或进程终止，执行才会中止。 |
| `continue` (`c`) | 继续执行调试中的进程。与`run`命令类似，执行会持续，直到遇到断点、异常或进程终止。 |
| `nexti` (`n`) | 执行程序计数器寄存器指向的下一条指令，然后停止。此命令将跳过函数调用和重复的指令。 |
| `stepi` (`s`) | 执行程序计数器寄存器指向的下一条指令，然后停止。与`nexti`命令不同，此命令将进入函数调用，允许分析被调用的函数。 |
| `finish` (`f`) | 执行当前函数（称为*帧*）中的其余指令，返回并停止。 |
| ctrl-c | 暂停执行。如果进程已经运行过（`r`）或继续执行过（`c`），则此操作会使进程在当前执行的位置暂停。 |

请注意，你可以将大多数 LLDB 命令缩写为单个字母或双字母。例如，你可以输入`s`来代替`stepi`命令。还要注意，LLDB 为其命令提供了多个名称，以保持与 GNU 项目调试器（GDB）的向后兼容性，GDB 是 LLDB 的前身之一。^(3) 例如，为了执行单步操作，LLDB 支持`thread step-inst`和`step`，这与 GDB 兼容。为了简便起见，本章描述了与 GDB 兼容的 LLDB 命令名称。

尽管你可以逐步执行二进制文件中的每一条可执行指令，但这样做非常繁琐。另一方面，指示调试器不受限制地运行恶意软件将完全违背调试的目的。解决方法是使用断点。

### 使用断点

*断点*是指令调试器在指定位置暂停执行的命令。通常你会在二进制文件的入口点、方法或函数调用处，或者在感兴趣的指令地址处设置断点。你可能需要先通过静态分析工具（如反汇编器）对二进制文件进行初步分析，以确定断点的具体位置。一旦命中断点并且调试器暂停执行，你将能够检查进程的当前状态，包括内存、CPU 寄存器内容、调用栈等。

你可以使用`breakpoint`命令（简写为`b`）在命名位置设置断点，例如函数或方法名称，或在某个地址上设置断点。在后台，调试器会透明地修改进程内存空间，将指定位置的字节覆盖为断点指令。在 Intel x86_64 系统上，这就是中断 3 指令，值为`0xCC`。一旦设置，当包含断点的内存地址被执行时，中断 3 将导致 CPU 将控制权交还给调试器，从而暂停执行。当然，如果继续执行，调试器会首先执行原始指令（该指令已透明地被覆盖以设置断点），以保持程序的正常功能。

假设我们想调试一个名为*malware*的恶意样本，并在其`main`函数（见列表 8-6）处暂停执行。如果恶意软件的符号没有被剥离（即编译时包含了调试符号），我们可以开始一个调试会话，然后输入以下命令按名称设置断点。

```
(lldb) **b main**
Breakpoint 1: where = malware`main, 
              address = 0x100004bd9
```

列表 8-6：在程序的`main`函数上设置断点

设置了这个断点后，我们可以使用`run`命令指示调试器运行被调试的进程。执行将开始，然后在到达`main`函数起始指令时（见列表 8-7）暂停。

```
(lldb) **run**

(lldb) Process 1953 stopped
stop reason = breakpoint 1.1
->  0x100004bd9 <+0>: pushq  %rbp
```

列表 8-7：断点命中；执行暂停

然而，通常情况下，编译后的二进制文件中没有函数名称，因此我们必须通过指定地址来设置断点。你也可能希望在某个地址上设置断点，比如在感兴趣的函数内。要在地址上设置断点，指定以`0x`为前缀的十六进制地址即可。

在前面的示例中，如果`main`函数（位于`0x100004bd9`）没有命名，我们仍然可以按以下方式在其起始位置设置断点（见列表 8-8）：

```
(lldb) **b 0x100004bd9**
Breakpoint 1: where = malware`__lldb_unnamed_symbol1$$malware, 
              address = 0x100004bd9
```

列表 8-8：通过地址设置断点

幸运的是，大部分 Mac 恶意软件都是用 Objective-C 编写的，这意味着即使是编译后的版本，它也会包含类和方法名称。因此，我们也可以通过将类和完整的方法名称传递给`breakpoint`（`b`）命令，在这些方法名称或它调用的任何 Apple API 上设置断点。

#### 在方法名称上设置断点

回想一下，在第五章中我们使用`class-dump`*工具提取了 Objective-C 的类和方法名称。如果你发现了感兴趣的方法，可以在这些方法上设置断点进行更深入的分析。例如，通过在 FinFisher 恶意软件的安装程序上运行`class-dump`，我们会发现一个名为`installPayload`的方法，它属于一个名为`appAppDelegate`的类。指定类和方法名称后，我们就可以设置断点，以便动态分析恶意软件如何持续地安装自己（见列表 8-9）：*

*```
Target 0: (installer) stopped.
(lldb) b -[appAppDelegate installPayload]

Breakpoint 1: where = installer`-[appAppDelegate installPayload], 
address = 0x000000010000336c
```*

列表 8-9：在`installPayload`方法（FinFisher）上设置断点

请注意，设置 Apple Objective-C 方法的断点可能有些微妙，因为存在各种不透明的编译器优化和抽象。例如，假设在反汇编器中，你注意到一个恶意样本正在调用 Apple 类 `NSTask` 的 launch 方法。你希望在此方法上设置调试器断点，以便当恶意软件尝试启动外部命令或程序时暂停。然而，在运行时，launch 方法的调用实际上并不是由 `NSTask` 类处理，而是由其子类 `NSConcreteTask` 处理。因此，你实际上需要以以下方式设置断点：

```
b -[NSConcreteTask launch]
```

这可能引发以下一个合理的问题：你怎么知道哪个类或子类实际上会处理一个方法？一种方法是跟踪 `objc_msgSend` 函数（及其变体）的调用。由于 Objective-C 调用会在运行时通过此函数路由，因此可以揭示所有类及其调用的方法。稍后我将通过 LLDB 调试器脚本演示如何做到这一点。有关调试 Objective-C 代码的深入讨论，包括设置断点的更多信息，请参见 Ari Grant 的精彩文章《在调试器中跳舞——与 LLDB 共舞》^(4)。

#### 条件触发断点

你经常会希望断点始终触发。其他时候，为了提高效率，可能希望只有在满足特定条件时，断点才会触发并暂停进程。幸运的是，LLDB 支持为断点应用条件。只有当条件评估为真时，断点才会触发并暂停进程。要为断点添加条件，可以使用 `-c` 标志，然后指定条件。例如，假设一个恶意样本正在向远程命令与控制服务器发送加密数据。在调试器中，我们可以在负责加密数据的函数上设置断点，以便在数据传输之前查看其明文内容。不幸的是，如果恶意软件还会定期发送小的“心跳”消息，这将不断触发我们的断点。我们很可能希望忽略这样的消息，因为它们不包含有意义的数据，而且会拖慢我们的分析进度。

解决方案是什么？给断点添加一个条件！具体来说，我们会指示断点仅在加密和泄露的数据大小大于心跳消息时才触发。为了举例说明，假设消息加密函数的第二个参数是消息的大小（可以在 `$rsi` 寄存器中找到），且心跳消息的大小最大为 128 字节。要为断点 1 添加此条件，我们将执行 列表 8-10 中的命令：

```
(lldb) **br modify -c '$rsi > 128' 1**
(lldb) **br list**
Current breakpoints:
1: address = 0x100003d28, locations = 1, resolved = 1, hit count = 0
Condition: $rsi  > 128
```

列表 8-10：设置条件断点

加上这样的条件后，调试器只会在传入加密和泄露函数的数据大小大于 128 字节时才会暂停。完美！

#### 向断点添加命令

通常，我们会设置一个断点，并在触发时执行一个确定性的操作。在前面的示例中，我们可能总是希望打印出未加密的数据，以查看恶意软件即将泄露的内容。虽然我们可以每次断点触发时手动执行此操作，但将一个称为*命令*的内容添加到断点中可能会更高效。这个命令由一个或多个调试器命令组成，并将在每次触发断点时自动执行。要将命令添加到断点中，请使用`breakpoint command add`并通过编号指定断点。然后，指定要执行的命令，再输入`DONE`。沿用之前的示例，假设消息加密函数的第一个参数是消息的明文内容（可以在`RDI`寄存器中找到）。为了添加一个断点操作来打印这个内容，我们将使用`print object`（`po`）命令（将在本章后面讨论）。我们还会告诉调试器继续执行（列表 8-11）：

```
(lldb) **breakpoint command add 1**
Enter your debugger command(s).  Type 'DONE' to end.
> **po $rdi**
> **continue** 
> **DONE**
```

列表 8-11: 添加断点命令

现在，每当触发这个断点时，调试器会打印出传递给函数的明文消息，然后继续执行。我们可以轻松地坐下来观察。

#### 管理断点

LLDB 调试器还支持多种命令来管理断点。可以使用表 8-2 中描述的命令来设置、修改、删除、启用、禁用或列出断点。

表 8-2: 管理断点的 LLDB 命令

| **LLDB 命令** | **描述** |
| --- | --- |
| `breakpoint` (`b`) `<function/method name>` | 在指定的函数或方法名处设置断点。 |
| `breakpoint` (`b`) 0x`<address>` | 在指定的内存地址上的指令处设置一个断点。 |
| `breakpoint list` (`br l`) | 显示所有当前的断点，包括它们的编号。 |
| `breakpoint enable`/`disable` `<number>` (`br e/dis`) | 启用或禁用一个断点（通过编号指定）。 |
| `breakpoint modify` `<modifications>` `<number>` `(br mod)` | 修改断点的选项（通过编号指定）。 |
| `breakpoint delete` `<number>` (`br del`) | 删除一个断点（通过编号指定）。 |

运行带有`breakpoint`参数的`help`命令可以提供与断点相关的命令的完整列表，包括表 8-2 中提到的那些命令。

```
(lldb) **help breakpoint**
Syntax: breakpoint `<subcommand>` [`<command-options>`]
```

如需了解更多有关 LLDB 支持的断点命令的信息，请参见该工具的相关文档。⁵

### 检查所有内容

一旦你暂停了程序的执行，你可以指示调试器显示许多内容，包括 CPU 寄存器的值、进程内存的内容或其他进程状态信息，如当前调用栈。这个强大的功能使你能够检查运行时信息，这些信息通常在静态分析时无法直接获得。例如，在本章开头的案例分析中，我们能够查看恶意软件解密后的内存配置数据。

要转储 CPU 寄存器的内容，请使用`register read`命令（或简化的`reg r`）。要查看特定寄存器的值，请将寄存器名称作为最后一个参数传入：

```
(lldb) **reg read rax**
rax = 0x0000000000000000
```

我们通常也对寄存器指向的内容感兴趣。也就是说，我们想要查看实际内存地址的内容。`memory read`命令或与 GDB 兼容的`x`命令可以用来读取内存内容。请注意，这些指令都要求寄存器名称以`$`作为前缀；例如，`$rax`。

但是，除非我们明确指定数据格式，否则 LLDB 将打印出原始十六进制字节。表 8-3 列出了多种格式说明符，用于指示 LLDB 将内存地址视为字符串、指令或字节。

表 8-3：用于显示内存内容的 LLDB 命令

| **LLDB 命令** | **描述** |
| --- | --- |
| `x/s` `<寄存器或内存地址>` | 将内存显示为以空字符终止的字符串。 |
| `x/i` `<寄存器或内存地址>` | 将内存显示为汇编指令。 |
| `x/b` `<寄存器或内存地址>` | 将内存显示为字节。 |

你还可以通过在`/`后面添加数字值来指定要显示的项目数量。例如，要从当前指令指针（`RIP`）位置开始反汇编 10 条指令，可以输入`x/10i $rip`。

LLDB 调试器还支持`print`命令。当与寄存器或内存地址一起执行时，它将显示指定位置的内容。你还可以指定类型转换，以指示`print`命令格式化数据。例如，如果`RSI`寄存器指向一个以空字符终止的字符串，你可以通过输入`print (char*)$rsi`来显示它。

`print`命令也可以使用`object`说明符来执行。此命令可用于打印任何 Objective-C 对象的内容（或在 Objective-C 术语中称为*描述*）。例如，考虑本章开头展示的示例。在`setDefaultConfiguration`方法中，Mami 恶意软件将其配置数据解密为一个由`RAX`寄存器引用的 Objective-C 对象。因此，使用`print object`命令，我们可以打印出该对象的详细描述，包括其所有键/值对（清单 8-12）：

```
(lldb) **print object $rax**
{
 "dnsChanger" =  {
   "affiliate" = "";
   "blacklist_dns" = ();
   "encrypt" = true;
   "external_id" = 0;
   "product_name" = dnsChanger;
   "publisher_id" = 0;

    ...
   "setup_dns" =         (
      "82.163.143.135",
      "82.163.142.137"
    );
    "shared_storage" = "/Users/%USER_NAME%/Library/Application Support";
    "storage_timeout" = 120;
 };
 "installer_id" = 1359747970602718687;
 ...
}
```

清单 8-12：打印字典对象（Mami）

你可能会想，给定一个任意的值或地址，如何决定使用哪种显示命令。也就是说，如何判断该地址是指向一个 Objective-C 对象、一个字符串，还是一系列指令？如果要显示的值是来自已记录 API 的参数或返回值，它的类型会在文档中注明。例如，苹果的大多数 Objective-C API 或方法返回对象，这些对象应使用 `print object` 命令来显示。然而，如果没有上下文可用，二进制文件的反汇编可能提供一些线索，或者通过试错方法也能解决问题。例如，如果 `print object` 命令没有产生有意义的输出，可以尝试使用 `x/b` 命令将指定数据的内容作为原始十六进制字节输出。

`backtrace`（或 `bt`）调试命令可以打印一系列堆栈帧，这是另一个有用的调试命令，用于检查进程。当触发断点时，我们通常需要确定程序的执行流程，直到那个时刻为止。例如，假设我们在恶意软件的字符串解密函数上设置了断点，这个函数可能在恶意代码的多个地方被调用，用于解密嵌入的字符串。当断点触发时，我们希望知道调用者的位置，即负责调用该函数的代码的地址。这可以通过 `backtrace` 实现。每当一个函数被调用时，调用堆栈中都会创建一个堆栈帧——它包含了进程执行完函数后将返回的地址等信息。由于返回地址是紧接在调用指令之后的地址，我们可以检查它来准确确定调用者的地址。此外，由于 `backtrace` 还包含前面的堆栈帧，因此可以重建整个函数调用层级。如果你有兴趣了解更多关于回溯和调用栈的内容，可以参考苹果的写作《Examining the Call Stack》。^(6)

### 修改进程状态

通常，一旦你设置了断点并暂停了执行，调试会话是相当被动的。然而，你可以通过直接修改进程的状态或甚至控制流来与进程进行交互。这在分析实现了反调试逻辑的恶意样本时尤为有用，相关话题将在下一章讨论。

一旦定位到反调试逻辑，一个选择是通过修改指令指针，指示调试器跳过这段代码。在某些情况下，你也可以通过简单地改变寄存器的值来绕过这种反调试代码。例如，修改 `RAX` 寄存器的值可以破坏一个函数返回的值。

修改二进制状态最常见的方法是更改 CPU 寄存器值或内存内容。`register write` 命令可以用来修改前者的值，而 `memory write` 命令则用于修改后者的内容。

`register write`（或 `reg write`）命令有两个参数：目标寄存器和其新值。我们来看一下如何利用这个命令完全绕过在广泛传播的广告软件安装程序中发现的反分析逻辑。在清单 8-13 中，我们首先使用 `x` 命令配合 `2i` 和程序计数器寄存器（`RIP`）来显示将要执行的下一条指令。位于 `0x100035cbe` 的调用指令会触发反调试逻辑。（这个逻辑的细节在本示例中不重要。）

```
(lldb) **x/2i $rip** 
0x100035cbe: ff d0 callq *%rax
0x100035cc0: 48 83 c4 10 addq $0x10, %rsp

(lldb) **register write $rip 0x100035CC0** 

(lldb) **x/i $rip** 
0x100035cc0: 48 83 c4 10 addq $0x10, %rsp
```

清单 8-13：修改指令指针

为了绕过反调试逻辑的调用，我们使用 LLDB 的 `register write` 命令修改指令指针（`RIP`），使其指向下一条指令（位于 `0x100035cc0`）。重新显示指令指针的值确认它已经成功更新。经过这次修改后，位于 `0x100035cbe` 地址的有问题的调用指令将永远不会被执行，因此，恶意软件的反调试逻辑也永远不会被触发，我们的调试会话可以顺利继续。此外，恶意软件通常不会察觉这一点。

修改 CPU 寄存器值以影响被调试进程的原因还有其他。例如，假设某个恶意软件在自持久化安装之前，尝试连接到一个远程命令与控制服务器。如果该服务器离线，但我们仍希望恶意软件继续执行，以便观察它是如何安装自己的，我们可能需要修改一个寄存器，这个寄存器存储了该连接检查的结果。由于函数调用的返回值保存在 `RAX` 寄存器中，这可能涉及将 `RAX` 的值设置为 `1`（即 `true`），让恶意软件认为连接检查已成功（清单 8-14）：

```
(lldb) **reg write $rax 1**
```

清单 8-14：修改寄存器

简单！

我们可以使用 `memory write` 命令修改任何可写的内存内容。在恶意软件分析过程中，这个命令可以用于修改加密配置文件的默认值，这些配置文件只在内存中解密。这样的配置可能包含一个触发日期，指示恶意软件在遇到该日期之前保持休眠。为了强制恶意软件立即激活，便于观察它的完整行为，你可以直接在内存中修改触发日期为当前时间。

作为另一个示例，`memory write` 命令可以用来修改保存恶意样本远程命令和控制服务器地址的内存。这为分析人员提供了一种简单且不破坏性的方式来指定一个备用服务器，例如一个在其控制下的服务器。能够修改恶意软件的命令和控制服务器的地址或指定一个备用服务器，具有一定的优势。在一篇名为《进攻性恶意软件分析：通过自定义 C&C 服务器解剖 OSX/FruitFly.b》的研究论文中，我展示了如何将恶意软件连接到一个由分析人员控制的备用服务器，并指示它揭示其功能。^(7)

`memory write` 命令的格式由 LLDB 的 `help` 命令描述。利用 `memory write` 最简单的方式是：

+   要修改的内存地址

+   `-s` 标志，并可以选择指定一个数字（如果默认的 1 字节不足以修改，则指定修改的字节数）

+   要写入内存的字节值

例如，要将地址 `0x100100000` 处的内存更改为 `0x41414141`，可以运行以下命令：

```
(lldb) **memory write 0x100100000 -s 4 0x41414141**
```

然后可以使用 `memory read` 命令确认修改：

```
(lldb) **memory read 0x100100000**
0x100100000: 41 41 41 41 00 00 00 00 00 00 00 00 00 00 00 00  AAAA...
```

## LLDB 脚本

LLDB 最强大的功能之一是它对调试脚本的支持，允许你扩展调试器的功能或简单地自动化重复性任务。让我们通过一个示例来演示如何构建一个简单的调试器脚本，以说明重要的概念，并展示这样的脚本如何改善你的动态恶意软件分析。

在本章前面，我提到过，跟踪 `objc_msgSend` 函数的调用可以揭示进程所做的大部分 Objective-C 调用。在分析恶意软件时，这可以为样本的功能提供宝贵的洞察，并推动后续的分析。一种天真的方法是通过在该函数上设置断点来监控对 `objc_msgSend` 函数的调用。是的，这样会暂停进程并允许你检查该函数的参数，其中包括类名和方法名。然而，正如你很快会看到的，这种方法效率非常低，而且对 `objc_msgSend` 函数的频繁调用会变得难以应付。

更高效的方法是创建一个调试器脚本，自动设置一个断点，附加一个命令来打印出 Objective-C 的类名和方法名，然后允许进程继续。LLDB 的调试器脚本使用 Python 编写，并通过调试器命令 `command script import` `<脚本路径>` 导入。这些脚本应该导入 LLDB 模块，以便其余的 Python 代码可以访问 LLDB API。有关此 API 的更多信息，请参阅官方 LLDB 文档： “Python 参考。”^(8)

更常见的是，你可能希望脚本在加载后自动执行某个操作（例如设置断点）。为此，LLDB 提供了 `__lldb_init_module` 这个便利函数，如果在你的调试器脚本中实现了该函数，它将在每次脚本加载时自动被调用。在我们的调试器脚本中，我们将使用这个函数来设置断点和断点回调（列表 8-15）：

```
import lldb

def __lldb_init_module(debugger, internal_dict):
    target = debugger.GetSelectedTarget()
    breakpoint = target.BreakpointCreateByName("objc_msgSend")
    breakpoint.SetScriptCallbackFunction('objc.msgSendCallback')
```

列表 8-15：通过调试器脚本设置断点

首先，我们的代码获取运行在调试器中的进程的引用。通过这个引用，我们可以调用 `BreakpointCreateByName` 函数，在 `objc_msgSend` 函数上设置一个断点。最后，我们通过调用 `SetScriptCallbackFunction` 函数来附加回调函数。请注意，这个函数的参数是你的模块或脚本的名称，后跟一个点和回调函数的名称（例如，`objc.msgSendCallback`）。

现在，每当调用 `objc_msgSend` 函数时，我们的回调函数 `msgSendCallback` 将会被触发。在这个回调函数中，我们只需打印出正在被调用的 Objective-C 类名和方法名，然后让调试的进程继续执行。回顾之前对 `objc_msgSend` 函数的讨论，我们提到它的第一个参数是 Objective-C 类名，第二个参数是方法名。我们还知道，在 Intel x86_64 平台上，前两个参数将分别通过 `RDI` 和 `RSI` 寄存器传递。这意味着我们可以按以下方式实现回调函数（列表 8-16）：

```
def msgSendCallback(frame, bp_loc, dict):
    lldb.debugger.HandleCommand('po [$rdi class]')
    lldb.debugger.HandleCommand('x/s $rsi')

    frame.thread.process.Continue()
```

列表 8-16：通过调试器脚本实现断点操作

为了执行内置的调试器命令，我们可以使用 `HandleCommand` API。首先，我们打印出可以在 `RDI` 寄存器中找到的 Objective-C 类的名称。我们使用 `po`（`print object`）命令，因为我们想显示的类名是一个 Objective-C 字符串对象。接下来，我们打印出存储在 `RSI` 寄存器中的方法名。由于它是一个以 null 结尾的 C 字符串，`x/s` 命令就足够了。然后，我们指示调试器继续执行，这样被调试的进程就能恢复运行。

我们可以将列表 8-15 和 8-16 中的代码保存起来（例如，保存到 *~/objc.py*），然后加载到调试器中，再执行我们感兴趣的恶意样本以便进一步分析（列表 8-17）：

```
(lldb) **command script import ~/objc.py**

(lldb) **NSTask**
0x1d8dcd07c: "alloc"

(lldb) **NSConcreteTask**
0x1d8dccbdd: "init"

(lldb) **NSConcreteTask**
0x1d8e1b67a: "setLaunchPath:"

(lldb) **NSConcreteTask**
0x1d8e1b771: "launch"
```

列表 8-17：我们的调试器脚本正在运行

从我们的脚本输出中，我们看到恶意软件正在利用 `NSTask` 类。在幕后，我们看到一个 `NSConcreteTask` 被初始化，设置了启动路径，然后任务被启动。为了进一步调查，我们现在可以手动在 `NSConcreteTask` 的 `launch` 方法上设置断点，查看恶意软件到底执行了什么。

LLDB 调试器脚本是一种强大的方式，可以扩展调试器并提供无价的能力，尤其在分析更复杂的恶意软件样本时。在这里，我们仅通过一个简单但有用的示例触及了它们的表面。要了解更多内容，可以查阅在线示例，例如 Taha Karim 的脚本，它可以自动转储 Bundlore 恶意软件的有效载荷。^(9) 这些示例展示了更高级的使用案例，同时也提供了对 LLDB 脚本 API 的宝贵洞察。

## 一个示例调试会话：揭示应用商店应用程序中的隐藏加密货币挖矿逻辑

2018 年初，一款名为 Calendar 2 的流行应用程序在苹果官方 Mac App Store 中被发现包含了隐蔽的加密货币挖矿逻辑，能够在用户计算机上悄悄进行加密货币挖矿（图 8-1）。虽然它本身不算恶意软件，但这个应用程序提供了一个很好的案例，展示了调试器如何帮助我们理解一个二进制文件中隐藏或颠覆性的功能。而且，由于恶意加密货币挖矿程序在 macOS 上的泛滥，这个例子尤其具有现实意义。

![Calendar 2 在 Mac App Store 上架。由 Qbix, Inc. 开发，评分为 2/5 星，有 29 个评价，标注为“免费”，但“提供应用内购买”。](img/f08001.png)

图 8-1：苹果官方 Mac App Store 中的隐蔽加密货币挖矿程序

在我进行初步的静态分析筛查时，我发现了多个方法，这些方法的名称与加密货币挖矿相关（示例 8-18）。这一点很奇怪，因为该应用程序声称只是一个日历应用程序。

```
/* @class MinerManager */
-(void)runMining {
    rdx = self->_coreLimit;
    r14 = [self calculateWorkingCores:rdx];
    [Coinstash_XMRSTAK9Coinstash setCPULimit:self->_cpuLimit];
    r15 = [self getPort];
    r12 = [self algorythm];
    [self getSlotMemoryMode];

    [Coinstash_XMRSTAK9Coinstash startMiningWithPort:r15 
                                 password:self->_token 
                                 coreCount:r14
                                 slowMemory:self->_slowMemoryMode
                                 currency:r12];
    ...

    return;
}
```

示例 8-18：应用商店应用中的加密货币挖矿逻辑？

在这个示例中，我们可以看到一个名为 `runMining` 的方法，里面包含调用名为 `Coinstash_XMRSTAK` 框架中方法的代码。由于该框架是用 Swift 编写的，因此方法名称略有混淆，但仍然大部分可以读取。

随后的动态分析目标之一是揭示有关加密货币账户的信息，以便了解任何挖掘的硬币将被发送到哪里。根据方法名称（如 `startMiningWithPort`、`:password:` 等），我推测，在调试会话中，在这些方法中的任意一个上设置断点将揭示这一信息。

启动 LLDB 并加载应用程序后，我们可以通过名称在 `runMining` 方法上设置一个断点，如示例 8-19 所示：

```
% **lldb CalendarFree.app**
(lldb) **target create "CalendarFree.app"**
Current executable set to 'CalendarFree.app' (x86_64).

(lldb) **b -[MinerManager runMining]**
Breakpoint 1: where = CalendarFree`-[MinerManager runMining], 
              address = 0x0000000100077fc0
```

示例 8-19：初始化调试会话并设置初始断点

一旦设置了断点，我们指示调试器运行应用程序。正如预期的那样，它会在我们设置的断点处暂停（示例 8-20）：

```
(lldb) **r**
Process 782 launched: 'CalendarFree.app/Contents/MacOS/CalendarFree' (x86_64)

CalendarFree[782:7349] Miner: Stopped
Process 782 stopped
 stop reason = breakpoint 1.1

CalendarFree`-[MinerManager runMining]:
->  0x100077fc0 <+0>: pushq  %rbp
    0x100077fc1 <+1>: movq   %rsp, %rbp
    0x100077fc4 <+4>: pushq  %r15
    0x100077fc6 <+6>: pushq  %r14
```

示例 8-20：断点命中，执行暂停

让我们逐步执行指令，直到我们到达调用 Coinstash 的`startMiningWithPort:...`方法。顾名思义，它开始了实际的挖矿。由于我们想在到达它之前跳过其他方法调用，我们使用`nexti`（或`n`）命令（见清单 8-21）。这使得方法调用得以执行，但我们无需逐条指令地执行它们。

```
(lldb) **n**

Process 782 stopped
 stop reason = instruction step over

CalendarFree`-[MinerManager runMining] + 35:
->  0x100077fe3 <+35>: movq 0xaa3d6(%rip), %r13   ;0x00007fff58acba00: objc_msgSend
```

清单 8-21：逐步执行指令并跳过方法调用

最终，我们接近了感兴趣方法的调用。回想一下，在汇编中，Objective-C 的调用是通过`objc_msgSend`函数进行路由的。在调试器中，我们首先看到该函数的地址被移动到`R13`寄存器中。虽然我们可以直接在调用`objc_msgSend`函数（地址为`0x100078067`）时设置一个断点，以调用`startMiningWithPort:...`方法，但我们会采取更全面的方法，逐步执行每一条指令，直到达到该调用（见清单 8-22）：

```
(lldb) **n**

Process 782 stopped
 stop reason = instruction step over

CalendarFree`-[MinerManager runMining] + 167:
->  0x100078067 <+167>: callq  *%r13

(lldb) **reg read $r13**
r13 = 0x00007fff58acba00  libobjc.A.dylib`objc_msgSend 
```

清单 8-22：逐步执行指令直到达到感兴趣的调用

请注意，通过`reg read`命令，我们确认`R13`寄存器确实包含了`objc_msgSend`函数。

回顾第六章，当调用`objc_msgSend`函数时，某些寄存器按照约定保存了特定的参数值。例如，函数的第一个参数（保存在`RDI`寄存器中）是调用方法的类或对象。在静态分析筛选过程中，我们识别出这是一个名为`Coinstash_XMRSTAK.Coinstash`的类。通过使用`print object`（`po`）命令，我们可以动态地确认这一点：

```
(lldb) **po $rdi**
Coinstash_XMRSTAK.Coinstash
```

第二个参数（保存在`RSI`寄存器中）将是一个以空字符终止的字符串，表示要调用的方法名。让我们确认一下这是正确的，并且它的值是`startMiningWithPort:...`方法。为了打印出一个以空字符终止的字符串，我们使用`x`命令，并配合`s`格式说明符：

```
(lldb) **x/s $rsi**
0x1000f1576: "startMiningWithPort:password:coreCount:slowMemory:currency:"
```

紧跟着类和方法名的是方法的参数。从方法名中我们可以推测，它接受五个参数，包括端口、密码和货币。我们无法通过静态分析方法（如反汇编器）轻松找到这些参数的值，因为它们并未直接显示出来。通过调试器，这一切变得非常简单。

我们知道，接下来的参数存储在`RDX`、`RCX`、`R8`和`R9`寄存器中，这是按照应用程序二进制接口（ABI）规定的。由于该方法有超过四个参数，最后一个参数会存储在栈上（`RSP`）。让我们来查看一下（见清单 8-23）：

```
(lldb) **po $rdx**
7777

(lldb) **po $rcx**
qbix:greg@qbix.com

(lldb) **reg read $r8**
r8 = 0x0000000000000001

(lldb) **po $r9**
always

(lldb) **x/s $rsp**
0x7ffeefbfe0d0: "graft"
```

清单 8-23：显示`startMiningWithPort:...`方法的参数

请注意，对于对象类型的参数，我们使用`po`命令来显示其内容。对于非对象类型的参数，我们使用其他合适的显示命令，例如`reg read $r8`来查看寄存器的内容，`x/s`来显示以 NULL 结尾的字符串。

通过检查参数，我们揭示了端口（`7777`）、账户密码（`qbix:greg@qbix.com`）、加密货币（`graft`）等信息！而且，如果我们继续调试，还会遇到更多数据，例如，在一个`NSURLRequest`对象中（在本次调试会话中，它位于内存地址 0x1018f04e0）。在调试器中，结合`po`命令，我们可以调用`NSURLRequest`对象的`HTTPBody`方法来显示该网络请求的内容（特别是请求体）。这将揭示详细的账户信息和加密挖矿统计数据（列表 8-24）：

```
1 (lldb) **po [0x1018f04e0 HTTPBody]**
{
  "mining": {
    "statistic": {
      "ZeroCounter": 0,
      "AverageHashRate": 0.92911845445632935,
      "CounterTime": 30,
    },
    "params": {
      "Token": "qbix:greg@qbix.com",
      "Algorithm": "graft",
      "CPULimit": 25,
      "EnableMiningMode": true,
      "CPUBatteryLimit": 10,
      "CoreLimit": 25,
      "Ports": {
        "7777": 1000000,
        "5555": 160,
        "3333": 40
      }
    }
  },
  ...
}
```

列表 8-24：显示包含加密货币挖矿账号信息和统计数据的网络对象

还值得注意的是，由于这些信息通过网络安全地传输（加密），因此通过简单的网络监控工具恢复这些信息会相当复杂。然而，通过调试器，这一过程相对简单。如果你对这个应用程序的完整分析感兴趣，包括使用调试器揭示和理解其加密挖矿逻辑的更多细节，请参见我的文章《Mac 应用商店中的隐秘加密货币挖矿者？》^(10)

## 接下来

在本章中，我介绍了调试器，这是一种最彻底的工具，能够分析甚至是复杂的恶意软件威胁。具体来说，我展示了如何通过断点逐步调试二进制文件，同时检查或修改寄存器和内存内容，跳过不需要执行的函数等等。现在，拥有了这种分析能力，恶意软件根本没有机会。

当然，恶意软件作者并不高兴他们的恶意创作可以如此轻松地被拆解。在下一章中，我们将深入探讨恶意软件作者为阻止（或至少复杂化）静态和动态分析工作而使用的各种反分析逻辑。

## 注释*
