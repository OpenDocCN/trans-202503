

# 前言



![](img/opener.jpg)

欢迎阅读 *The Art of ARM Assembly*。本书将教你如何编写 64 位 ARM CPU 程序，如现代 Apple macOS 机器中使用的 ARM CPU，基于 ARM 的 Linux 系统（包括带有 64 位 Raspberry Pi OS 版本的 Raspberry Pi，以前称为 Raspbian，我简称为 Pi OS），甚至是 iPhone、iPad 以及部分 Android 设备等移动设备。随着 ARM 架构的 Apple macOS 系统的到来，学习和理解 64 位 ARM 汇编语言的需求急剧增加，这也促使我写了这本书。然而，我已尽可能使本书中的源代码和其他信息具有便携性，以便它适用于所有 64 位 ARM 机器。

本书是 *The Art of 64-Bit Assembly* 的姊妹篇，而 *The Art of 64-Bit Assembly* 本身是 *The Art of Assembly Language Programming*（*AoA*）的重写版本。*AoA* 是我在 1989 年开始的一个项目，旨在为加利福尼亚州立理工大学（Pomona）和加利福尼亚大学河滨分校的学生教授 80x86（x86）汇编语言编程。25 多年来，*AoA* 一直是学习 x86 汇编语言编程的指南。在这段时间里，其他处理器有来有去，但 x86 依然是个人计算机和高端工作站的主流，而 x86 汇编语言也始终是学习的事实标准。然而，随着基于 ARM 的 Apple M1 系统（以及后来的 Apple 机器）的出现，ARM 架构的个人计算机逐渐成为主流，因此学习 ARM 汇编语言编程的需求大幅增加。

本书的编写以 *The Art of 64-Bit Assembly* 为模型，涵盖了类似的内容。任何读过我早期书籍的人都会觉得这本书在高层次上非常熟悉。当然，ARM 指令和汇编器——无论是 GNU 汇编器（Gas）还是 Apple 的 Clang 汇编器（与 Gas 大部分兼容）——与 x86 指令和微软宏汇编器（MASM）有很大不同。因此，底层的呈现和编程技巧也有所不同。

## 0.1 ARM CPU 的简史

ARM CPU 拥有悠久而丰富的历史。它最初由 Acorn Computers Ltd. 于 1983 年底开发，作为其 BBC Micro 系统中使用的老旧 8 位 6502 CPU 的替代品。*ARM* 最初代表的是 *Acorn RISC Machine*，但后来改为 *Advanced RISC Machine*（*RISC* 代表 *精简指令集计算机*）。最初的设计在很大程度上是加州大学伯克利分校早期 RISC 设计与 6502 CPU 设计的结合。因此，许多人认为 ARM 起初并不是一个纯粹的 RISC 设计。我们可以将 ARM 看作是 6502 的精神继承者，继承了许多 6502 的特点。

在许多方面，ARM CPU 的设计借鉴了 6502 CPU 对简化指令集计算机的理解。在最初的 RISC 设计中，每条指令的设计都力求做最少的工作，以便减少对硬件的支持需求并提高运行速度。纯 RISC 架构通常不使用条件码位（因为在执行指令后设置条件码需要 CPU 做额外的工作），并且使用固定大小的机器指令编码（通常为 32 位）。而 6502 则试图尽可能减少机器指令的*数量*。

此外，原始的 ARM 支持 16 位和 32 位指令编码。虽然纯 RISC CPU 尝试最大化通用寄存器的数量（通常是 32 个），但原始的 ARM 设计仅支持 16 个寄存器。此外，ARM 使用一个通用寄存器作为程序计数器，这使得可以进行各种编程技巧，但也给纯 RISC 设计带来了问题（如处理异常）。最后，ARM 部分支持硬件堆栈，这是纯 RISC 机器上看不到的功能。尽管如此，不管是“纯粹”还是“非纯粹”，ARM 设计比那个时代的所有其他 RISC CPU 更加长久。

多年来，ARM CPU 变种主要应用于移动和嵌入式领域，绝大多数 ARM CPU 最终应用于手机和平板电脑。然而，有一个显著的应用是在树莓派计算机系统中（截至撰写时，已经销售超过 6100 万台）。除了树莓派，数百万台基于 ARM 的兼容 Arduino 的单板计算机（如 Teensy 系列）也已售出。截至撰写时，树莓派基金会发布了树莓派 Pico，一款基于 ARM 的微控制器板，售价 4 美元（美国），到 2024 年 1 月已售出超过 400 万台此类设备。

## 0.2 为什么要学习 ARM 汇编？

RISC CPU 的设计初衷是使用高级语言（特别是 C/C++）进行编程。很少有著名的程序是用 RISC 汇编语言编写的（尽管原始的 ARM Basic 是一个很好的反例）。在大学和学院中教授汇编语言的主要原因是为了教授*机器组织*（即对机器架构的介绍）。此外，一些应用程序（或者至少是某些应用程序的部分）可以从汇编语言实现中获益。速度和空间是使用汇编语言的两个主要原因，尽管某些算法确实更容易用汇编语言编写（特别是位处理操作）。

最后，学习汇编语言有助于你编写更高质量的高级语言代码。毕竟，像 C/C++这样的语言的编译器将高级源代码翻译成汇编语言。理解底层的机器语言将帮助你编写更好的高级语言（HLL）代码，因为你可以避免低效的 HLL 结构。这种理解在调试或优化 HLL 代码时也非常有用。有时，你必须查看编译器生成的代码，才能理解某个 bug 或效率低下的问题。

那么，为什么特别要写一本关于 ARM 汇编语言的书呢？直到苹果硅 M1 CPU 问世之前，唯一使用 ARM CPU 的常见个人电脑就是树莓派。虽然树莓派很受欢迎，但它通常并未在学校中用于教授计算机组织和汇编语言编程。一些业余爱好者可能会自学 ARM 汇编语言，但大多数树莓派程序员使用的是 Scratch 或 Python，而硬核玩家则使用 C/C++编程。尽管 iPhone、iPad 和安卓手机、平板等移动设备也很受欢迎，但开发者很少会考虑从 Objective-C、Swift 或 Java 切换到汇编语言来为这些设备的应用程序编程。

然而，一旦苹果发布了基于 M1 的 Mac mini、MacBook 和 iMac，情况发生了变化。由于现在 ARM 汇编语言可以在“普通”机器上教授，ARM 低级编程的兴趣激增。自从 A 系列（iPad 和 iPhone）和 M 系列（iPad 和 Mac）系统推出以来，苹果销售的数量超过了树莓派。可以预见的是，到你阅读这本书时，苹果可能已经售出了约十亿台基于 ARM 的个人电脑和移动设备。

鉴于这些发展，越来越多的人将对在 ARM CPU 上进行汇编语言编程感兴趣。如果你希望能够在这批新设备上编写高性能、高效且体积小的代码，那么学习 ARM 汇编语言是开始的好地方。

## 0.3 为什么要学习 64 位 ARM？

尽管最初的 ARM 是 32 位 CPU，但授权 ARM 设计的公司 Arm Holdings 在 2011 年推出了 64 位版本。苹果在几年后推出了其 32 位的 iPhone 5。从那时起，大多数移动设备和个人计算机（包括树莓派 3、4 和 400）都使用了 64 位 CPU，而嵌入式设备则大多坚持使用 32 位 CPU 版本。为 32 位 CPU 编写的代码通常比为 64 位 CPU 编写的代码更节省内存；除非应用程序需要超过 4GB 的内存，否则使用 32 位指令集通常更好。

尽管如此，对于高性能计算，64 位无疑是未来。为什么会这样呢？难道 64 位 ARM 处理器不能运行旧的 32 位代码吗？答案是有条件的“是”。例如，Raspberry Pi 提供了一个 32 位操作系统，即使在 64 位 CPU（如 Pi 3、4 或 400）上运行，它也只运行 32 位代码。然而，64 位 ARM 处理器（ARMv8 或 AARCH64，简称 ARM64）有两种工作模式：32 位模式和 64 位模式。当处于 32 位模式时，它们执行 32 位指令集；而在 64 位模式下，它们执行 64 位指令集。尽管这两种指令集有一些相似之处，但它们并不相同。因此，当操作处于某个模式时，不能执行来自另一个模式的指令。

由于这两种指令集不兼容，本书重点讲解 64 位 ARM 汇编语言。因为你无法在 Apple M1（及之后的版本）上使用 32 位 ARM 汇编语言进行编程，单独教授 32 位汇编语言是不可行的。为什么不同时教授两者呢？虽然学习 32 位汇编语言对想要为 32 位 Pi 操作系统及其他嵌入式单板微控制器编写代码的读者有帮助，但本书的目标是教授基础知识。教授两种不同的指令集会让教育体验变得复杂；与其两者都做得不好，不如专注于做好一件事（64 位汇编）。同时教授 32 位和 64 位汇编语言几乎就像是试图在同一本书中教授 x86-64 和 ARM；一次性学习太多内容是不现实的。此外，32 位操作模式可能会随着时间的推移完全消失。当我写这篇文章时，ARM 已经推出了只支持 64 位代码的变种；我预计未来所有桌面级处理器都会朝这个方向发展。

> 注意

*虽然专注于桌面级和移动设备（如 iPhone）上的 64 位 ARM 汇编语言是合理的，但一些人可能希望学习 32 位 ARM 汇编语言，以便与嵌入式设备一起使用。基于 Arduino 的单板计算机（SBC）、Raspberry Pi Pico SBC 以及许多其他基于 ARM 的嵌入式系统使用 32 位 ARM 变种。此外，如果你在使用 32 位版本的 Pi OS 操作 Raspberry Pi，那么你需要使用 32 位 ARM 汇编语言。因此，*《ARM 汇编语言艺术（第二卷）》*将涵盖这些系统上的 32 位 ARM 汇编语言。*

## 0.4 期望与前提条件

本书假设你已经能够熟练使用高级语言（HLL）进行编程，例如 C/C++（首选）、Python、Swift、Java、Pascal、Ruby、BASIC 或其他面向对象或命令式（过程式）编程语言。尽管许多程序员成功地将汇编语言作为他们的第一种编程语言学习，但我建议你先学习如何*编程*，然后再学习汇编语言编程。本书使用了若干个高级语言（HLL）的例子（通常是 C/C++或 Pascal）。这些例子通常很简单，所以如果你了解其他 HLL 语言，应该能够理解它们。

本书还假设你已经熟悉在程序开发过程中进行编辑/编译/测试/调试的循环。你应该熟悉源代码编辑器和使用标准软件开发工具，因为我不会解释如何编辑源文件。

市面上有各种各样的 64 位 ARM 系统，我的目标是使本书适用于尽可能多的系统。为此，本书中的每个示例程序都已在以下系统上进行测试：

+   基于 Apple M1 的 Mac 系统，如 Mac mini M1 和 Mac mini M2。书中的示例代码已经在 mini M1 上进行测试，但应适用于任何基于 ARM 的 MacBook 或 iMac，以及未来的 M*x* 系统。

+   Raspberry Pi 3、4、400 和 5 系统（以及未来支持 64 位的 Pi 系统），运行 64 位版本的 Pi OS。

+   PINE64 系统，包括 Pinebook、Pinebook Pro 和 ROCKPro 64。

+   几乎任何 64 位 ARM 架构的 Linux 系统。

+   NVIDIA Jetson Nano 系统。

理论上，应该可以将本书中的信息应用到基于 ARM 的 Windows 机器（如 Surface Laptop Copilot+）上。不幸的是，微软的软件开发工具，特别是其汇编器，是基于 Arm（公司）定义的原始 ARM 汇编语法，而不是 Gas。虽然微软的 *armasm64* 在许多方面是更好的工具（因为它使用标准的 ARM 汇编语言语法），但其他人都使用 Gas 语法。两种汇编器之间的机器指令大致相同，但其他语句（被称为 *汇编指令* 或 *伪操作码*）完全不同。因此，用 Gas 编写的示例程序在 *armasm64* 下无法汇编，反之亦然。由于在示例程序中同时展示两种语法形式与同时教授 32 位和 64 位编程一样令人困惑，因此我在示例中坚持使用 Gas 语法。

## 0.5 源代码

本书包含了大量的 ARM 汇编语言（以及一些 C/C++）源代码，通常以三种形式之一呈现：代码片段、单个汇编语言过程或函数（模块）或完整程序。

*代码片段*是程序的片段；它们不是独立的，无法使用 ARM 汇编器（或在 C/C++ 源代码的情况下使用 C++ 编译器）进行编译。它们存在的目的是阐明某个观点或提供某种特定编程技巧的简短示例。以下是一个典型的示例：

```
 .data
i64  .quad   0
      .
      .
      .
     ldr     x1, i64
```

垂直省略号表示可以替代其位置的任意代码。

*模块*是可以编译但无法独立运行的小块代码。模块通常包含一个将被另一个程序调用的函数。以下是一个典型的示例：

```
someFunc:
        add x0, x1, x2
        sub x0, x0, x3
        ret
```

本书中完整的程序被称为 *listings*，我通过列表编号或文件名引用它们。典型的文件名通常采用 *Listing*C*-*N*.S* 的形式，其中 C 是章节编号，N 是该章节中的列表编号。例如，以下 *Listing1-1.S* 是出现在 第一章中的第一个列表：

```
// Listing1-1.S
//
// Comments consist of all text from a //
// sequence to the end of the line.
// The .text directive tells MASM that the
// statements following this directive go in
// the section of memory reserved for machine
// instructions (code).

        .text

// Here is the main function.
// (This example assumes that the
// assembly language program is a
// stand-alone program with its own
// main function.)
//
// Under macOS, the main program
// must have the name _main
// beginning with an underscore.
// Linux systems generally don't
// require the underscore.
//
// The .global _main statement
// makes the _main procedure's name
// visible outside this source file
// (needed by the linker to produce
// an executable).

        .global _main

// The .align 2 statement tells the
// assembler to align the following code
// on a 4-byte boundary (required by the
// ARM CPU). The 2 operand specifies
// 2 raised to this power (2), which
// is 4.

        .align 2

// Here's the actual main program. It
// consists of a single ret (return)
// instruction that simply returns
// control to the operating system.

_main:
        ret
```

尽管大多数列表的格式为 *Listing*C*-*N*.S*，但有些（尤其是来自外部来源的）仅由描述性文件名组成，例如本书大多数示例程序使用的 *aoaa.inc* 头文件。

所有的列表都可以在电子版中找到，网址是 *[`<wbr>artofarm<wbr>.randallhyde<wbr>.com`](https://artofarm.randallhyde.com)*，可以单独下载，也可以作为一个包含本书所有列表的 ZIP 文件下载。该页面还包含本书的支持信息，包括勘误表和供讲师使用的 PowerPoint 演示文稿。

本书中的大多数程序都是通过命令行运行的。这些示例通常使用 bash shell 解释器。因此，每个构建命令和示例输出通常会在您键入的命令前加上 $ 或 % 前缀。在 macOS 下，默认的 shell（命令行）程序是 zsh，它使用百分号（%）而不是美元符号（$）作为提示符。如果您完全不熟悉 Linux 或 macOS 的命令行，请参见 附录 D，以便快速了解命令行解释器。

除非另有说明，本书中出现的所有源代码均受 Creative Commons 4.0 许可协议保护。根据 Creative Commons 许可协议，您可以自由地在自己的项目中使用这些代码。更多详情请参见 *[`<wbr>creativecommons<wbr>.org<wbr>/licenses<wbr>/by<wbr>/4<wbr>.0<wbr>/`](https://creativecommons.org/licenses/by/4.0/)*。

## 0.6 排版和迂腐

计算机书籍有一个习惯，就是滥用英语语言，本书也不例外。每当源代码片段出现在英语句子中间时，编程语言的语法规则与英语语法规则之间往往会产生冲突。本节将描述我在区分英语与编程语言语法规则时所做的选择，以及一些其他约定。

首先，本书使用等宽字体表示程序源文件中的任何文本。这包括变量、过程函数、程序输出以及用户输入。因此，当您看到类似 get 这样的内容时，您知道本书是在描述程序中的标识符，而不是命令您去获取某些东西。

一些逻辑操作有着与英语中常见的含义相同的名称：AND、OR 和 NOT。使用这些术语作为逻辑函数时，本书采用全大写字母来帮助区分可能会引起混淆的英语表述。使用这些术语作为英语单词时，本书使用标准的排版字体。第四个逻辑运算符，异或（XOR），通常不会出现在英语句子中，但本书仍然将其大写。

通常情况下，我总是尽量在第一次使用缩写或简称时进行定义。如果我有一段时间没有使用某个术语，我会在重新使用时再进行一次定义。附录 B 中的术语表也包括了书中大多数出现的缩写。

## 0.7 组织结构

本书分为 4 个部分，共 16 章和 6 个附录。

**第一部分**，机器组织，介绍了 ARM 处理器的数据类型和机器架构：

**第一章：你好，汇编语言的世界**    教授你一些基本的指令，让你可以试验软件开发工具并编写简单的小程序。

**第二章：数据表示与运算**    讨论了整数、字符和布尔值等简单数据类型的内部表示。它还讨论了对这些数据类型可以进行的各种算术和逻辑运算。本章还介绍了一些基本的 ARM 汇编语言操作数格式。

**第三章：内存访问与组织**    讨论了 ARM 如何组织主内存。它解释了内存布局以及如何声明和访问内存变量。它还介绍了 ARM 访问内存和栈（用于存储临时值）的方法。

**第四章：常量、变量和数据类型**    描述了如何在汇编语言中声明命名常量，如何声明和使用指针，以及如何使用复合数据结构，如字符串、数组、结构体（记录）和联合。

**第二部分**，基础汇编语言，提供了编写汇编语言程序所需的基本工具和指令。

**第五章：过程**    介绍了编写你自己的汇编语言函数（过程）所需的指令和语法。本章描述了如何将参数传递给函数并返回函数结果。它还描述了如何声明（并使用）你在栈上分配的局部或自动变量。

**第六章：算术**    解释了 ARM 汇编语言中的基本整数算术和逻辑运算。它还描述了如何将算术表达式从高级语言（HLL）转换为 ARM 汇编语言。最后，本章介绍了使用硬件支持的浮点指令进行浮点算术运算。

**第七章：低级控制结构**    描述了如何在 ARM 汇编语言中实现类似高级语言（HLL）的控制结构，如 if、elseif、else、while、do...while（repeat...until）、for 和 switch。本章还涉及了汇编语言中优化循环和其他代码的方法。

第三部分，高级汇编语言，涵盖了更高级的汇编语言操作。

**第八章：高级算术**    探讨了扩展精度算术、混合模式算术以及其他高级算术运算。

**第九章：数值转换**    提供了一组非常有用的库函数，你可以使用它们将数值转换为字符串格式，或将字符串转换为数值格式。

**第十章：表格查找**    描述如何使用基于内存的查找表（数组）来加速某些计算。

**第十一章：Neon 和 SIMD 编程**    讨论了 ARM 高级 SIMD 指令集，通过同时操作多个数据项来加速某些应用程序。

**第十二章：位操作**    描述了在 ARM 汇编语言中执行位级数据操作的各种操作和函数。

**第十三章：宏和 Gas 编译时语言**    介绍了 Gas 宏功能。宏是强大的构造，允许你设计自己的汇编语言语句，这些语句会扩展为大量单独的 ARM 汇编语言指令。

**第十四章：字符串操作**    解释了在 ARM 汇编语言中使用和创建各种字符字符串库函数。

**第十五章：管理复杂项目**    描述了如何创建汇编语言代码库，并通过使用 makefile 构建这些库（同时讨论 make 语言）。

**第十六章：独立汇编语言程序**    展示了如何编写不使用 C/C++标准库进行 I/O 和其他操作的汇编语言应用程序。本章包括适用于 Linux（Pi OS）和 macOS 的系统调用示例。

第四部分，参考资料，提供了参考信息，包括列出完整 ASCII 字符集的表格、词汇表、安装和使用 Gas 的系统说明、bash shell 解释器简介、你可以在汇编语言程序中调用的有用 C/C++函数，以及每章末尾问题的答案。
