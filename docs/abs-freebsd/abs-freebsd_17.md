## 第十七章：高级软件管理**

![image](img/common01.jpg)

FreeBSD 提供了独特的功能，帮助系统管理员更好地满足用户需求。了解系统的真正工作原理有助于您做出更好的决策。例如，虽然多个处理器、多核处理器和硬件线程都能提高系统性能，但它们并不总是像您想象的那样有效。了解不同类型的多处理如何影响不同类型的工作负载，能告诉您在哪些地方可以提高性能，哪些地方不能。

为了让您的程序在启动时自动启动，并在关机时干净地停止，您必须能够创建和编辑正确的启动和关机脚本。虽然有些程序在操作系统关闭时能够优雅地停止，但其他程序（例如数据库）则要求更温和的关机。干净地启动和停止系统服务是一个很好的习惯，所以我们将进一步了解 FreeBSD 的启动和关机脚本。

在正常情况下，您永远不需要知道 FreeBSD 的链接和共享库支持是如何工作的，但我们还是会讨论这些内容。为什么？因为正常情况在计算机行业中，奇怪地说，是相当罕见的。

最后，FreeBSD 可以通过 Linux 兼容层运行 Linux 软件，也可以运行为其他硬件架构编写的软件。

### 使用多个处理器：SMP

如果您的桌面或服务器是在过去 10 年内构建的，它几乎可以肯定配备了多个处理器。其中一些处理器用于专用目的，例如您显卡中的图形处理器。现代操作系统使用 *对称多处理（SMP）*，即多个相同的通用处理器。现代硬件包括许多不同的专用处理器，例如显卡和服务器远程管理等，但呈现给操作系统的硬件是相同的处理器。

SMP 系统相比单个处理器有许多优势，而且不仅仅是显而易见的“更多的力量！”如果从微观层面考虑，在非常短的时间内，CPU 一次只能做一件事。计算机上的每个进程都在争夺处理器时间。如果 CPU 正在执行数据库查询，它就无法接受以太网卡试图传送的包。每一秒的一小部分时间，内核会指示 CPU 执行 *上下文切换*，并处理另一个请求。这种情况发生得如此频繁和快速，以至于计算机看起来像是在同时做很多事情——就像电视画面看起来在移动，其实它只是在以非常快的速度依次显示单个画面一样。

我的桌面上有 cwm 提供窗口管理，Firefox 打开了成千上万的标签页，LibreOffice 正在接受我的输入。还有一堆终端窗口连接着 SSH 会话。网络中断不断到达；屏幕上显示着文本；MP3 播放器正在播放 Nurse With Wound 的 Stereohenge 专辑。计算机的“无缝多任务处理”看起来对我那脆弱的大脑而言确实很无缝。实际上，计算机只是非常快速地从一个任务切换到另一个任务。一个毫秒，它在将另一个声音片段传输到我的耳机，接下来的一个毫秒，它更新屏幕上的文本。

如果有多个处理器，你的计算机的确*可以*同时执行多个操作。这非常有用——但系统复杂性也急剧上升。

#### *内核假设*

要理解 SMP 以及它相关的问题，我们必须深入研究内核。所有操作系统在支持 SMP 时面临相同的挑战，这里的理论适用于各种平台。接下来是一个粗略的简化。内核设计是一个复杂的话题，几乎不可能有任何描述能够完全阐述它。然而，下面是一个大致的尝试。

FreeBSD 将 CPU 使用率划分为时间片。*时间片*是 CPU 执行一个任务的时间长度。一个进程可以使用 CPU，或者使用整个时间片，或者直到没有更多工作要做为止，此时下一个任务可能会运行。内核使用基于优先级的系统来分配时间片并决定哪些程序可以在哪些时间片中运行。如果一个进程正在运行，但一个更高优先级的进程出现，内核允许第一个进程被中断，或*抢占*。这通常被称为*抢占式多任务处理*。

尽管内核正在运行，但它并不是一个进程。任何进程都有由内核设置的某些数据结构，内核根据需要操作这些数据结构。你可以把内核看作一种特殊类型的进程，它的行为与其他进程大不相同。它无法被其他程序中断——你不能输入 `pkill kernel` 来重启系统。早在以前，内核可能被称为*控制进程*或*监控程序*。

内核面临着系统其他部分没有的特殊问题。假设你有一个程序在通过网络发送数据。内核接受来自程序的数据并将其放入一块内存中，准备交给网络卡。如果计算机一次只能做一件事，那么在内核回到该任务之前，这块内存或网络卡不会发生任何变化。然而，如果你有多个处理器，计算机可以同时执行多个任务。那么，如果两个不同的 CPU，都在处理内核任务，同时指示网络卡执行不同的操作，会发生什么呢？网络卡的表现就像你在一边听老板吼叫，另一边听配偶抱怨；你做的任何事都无法让他们满意。如果一个 CPU 为网络任务分配了内存，而另一个 CPU 为文件系统任务分配了相同的内存，会怎样呢？内核会变得混乱，结果不会让你满意。

为单个处理器设计的类 Unix 内核声明内核是非抢占式的，不能被中断。这简化了内核管理，因为一切都变得完全可预测：当内核的一部分分配内存时，它可以指望在执行下一条指令时该内存不会改变。内核的其他部分不会改变那块内存。当计算机一次只能做一件事时，这是一种安全的假设。然而，一旦开始同时做多件事，这个假设就会崩溃。

#### *SMP：第一次尝试*

FreeBSD 中 SMP 支持的第一次实现非常简单。进程在 CPU 之间分散，达到粗略的负载平衡，并且内核上有一个锁。在一个 CPU 尝试运行内核之前，它会检查锁是否可用。如果锁是空闲的，CPU 会获得锁并运行内核。如果锁不可用，CPU 就知道内核正在其他地方运行，然后继续处理其他任务。这个锁被称为*大锁（BGL）*，或者后来简称为*Giant*。在这种系统下，内核可以确保数据不会被其下方的进程改变。本质上，Giant 保证了内核只会在一个 CPU 上运行，就像它一直以来的工作方式一样。

这种策略对两个 CPU 的情况勉强有效。你可以在一台双 CPU 机器上运行一个中型数据库和一个 Web 服务器，并且有信心 CPU 不会成为瓶颈。如果一个 CPU 忙于提供网页服务，另一个 CPU 就可以空闲来处理数据库查询。但如果你有一台八 CPU 的机器，你就麻烦了；系统会花费大量时间等待 Giant 变得可用！

这种简化的 SMP 技术既不高效也不可扩展。标准的 SMP 教科书很少提到这种方法，因为它非常笨重。然而，其他一些 SMP 处理方法更糟。例如，微软早期的几个服务器操作系统版本将一个处理器专用于用户界面，另一个处理器用于其他所有任务。这种技术也很少出现在教科书中，尽管它确实能使鼠标更加灵敏。

#### *今天的 SMP*

然而，一旦你拥有了内核的锁，你就可以将这个锁分割开。FreeBSD 已经将 Giant 锁分解成许多更小的锁，现在内核的每个部分都使用最小的锁来执行任务。最初，这些锁被实现于内核的核心基础设施中，如调度器（内核中负责分配任务时间片的部分）、网络栈、磁盘 I/O 栈等。这立即提高了性能，因为当一个 CPU 在调度任务时，另一个可以处理网络流量。随后，锁被推向了更低层次的各个内核组件。网络栈的每个部分开发了自己的锁，I/O 子系统的每个部分也都如此——使得内核能够利用多个处理器同时执行多个任务。这些独立的内核子进程被称为*线程*。

每种类型的锁定都有其独特的要求。你将会看到许多不同的锁，例如互斥锁、sx 锁、读写锁、自旋互斥锁、信号量、读多写少锁等等。每种锁都有其优缺点，且每种锁必须在内核中小心使用。

精细化锁定比听起来要*难得多*。锁得太细，内核花费更多时间处理锁，而不是推送数据；锁得太粗，系统浪费时间等待锁可用。适用于 2 处理器系统的锁定会使 32 处理器系统停滞不前，适用于 32 核心主机的锁定对新的 192 核心系统来说完全不够。锁定调整和调优已经花费了数年时间，仍在进行中，并将永远持续下去。

尽管内核的每个部分都使用当前可能的最小锁，但有时那个锁就是 Giant 锁。拔掉 USB 设备意味着在短暂的一瞬间抢占 Giant 锁，内核会说：“暂停一切！我正在重新配置硬件！”一些设备驱动程序仍然使用 Giant 锁，一些虚拟内存栈中的棘手部分、sysctl 处理程序等也使用它。

##### SMP 问题：死锁和锁顺序反转

所有这些内核锁都有复杂的使用规则，它们之间以各种方式相互作用。这些规则是为了防止锁之间发生意外的相互作用。假设内核线程 A 需要资源 Y 和 Z，内核线程 B 也需要 Y 和 Z，但 B 需要 Z 后才需要 Y。如果 A 锁定了 Y，而 B 锁定了 Z，那么 A 就会等待 Z，而 B 则会等待 Y。两个线程都无法继续，直到丢失的资源被释放。这种*死锁*（也叫*致命的拥抱*）会使系统不稳定，可能导致系统崩溃。正确的锁定方式可以避免这个问题，和其他一些问题。

您可能会看到控制台上出现关于*锁定顺序反转*的警告，意味着锁定顺序错误地应用了。虽然这个内核通知并不总是预示着灾难的来临，但关注它仍然很重要。

`WITNESS` 内核选项专门用于监控锁定顺序和锁定顺序违规情况。该选项在 FreeBSD-current 上默认启用（参见第十八章），如果您报告系统出现问题，开发团队可能会要求您启用它。`WITNESS` 选项使内核检查每个操作是否存在锁定顺序违规，这会降低系统性能。不过，运行 `WITNESS`、查看消息并根据消息采取行动，是帮助改进 FreeBSD 的一个极好的方式。

##### 处理锁定顺序反转

当您收到一个锁定顺序反转（LOR）消息时，请完整复制该 LOR 消息。除了显示在控制台上外，这些消息还会记录到 */var/log/messages* 中，方便您查看。一旦获得锁定顺序消息，请在 FreeBSD-current 邮件列表中搜索 LOR 消息的前几行，看看是否有人已经提交了该问题。如果在邮件列表中找到了您的 LOR，请阅读消息并采取推荐的行动。如果开发者最近并特意要求通知进一步的此类 LOR，您才需要在邮件列表中发布“我也遇到这个问题”的消息。

如果您遇到一个新的锁定顺序反转（LOR），恭喜您！发现一个新的 LOR 并不像发现一个新的昆虫物种那样令人满足——首先，您不能给您的 LOR 命名——但它确实有助于 FreeBSD 项目。请将您的报告发送至 FreeBSD-current 邮件列表。提供有关您的系统的详细信息，特别是在 LOR 出现时所执行的工作。您可能会被要求提交一个 bug 报告，正如在第二十四章中讨论的那样。

#### *处理器和 SMP*

您会看到三种不同类型的多处理器系统：多核、多包装和硬件线程。您需要理解它们之间的区别，因为不同的处理器类型会直接影响系统和应用程序的行为。

处理器中的基本单位是*CPU 核心*。每个 CPU 核心由一组资源组成，如执行单元、寄存器、缓存等。曾几何时，一个核心就等同于一个处理器。

CPU *封装*是插入或焊接到主板上的芯片。它就是许多人所称的“CPU”或“处理器”。那个你可能不小心踩碎的昂贵部件？那就是封装。每个封装包含一个或多个核心。在对称多处理（SMP）之前，一个封装只有一个核心。如今，大多数封装至少包含两个核心，且核心数不断增加。同一封装中的 CPU 核心可以相互快速通信。

一些主机有多个封装。多个封装为你提供多个包含多个核心的组，从而提供更多的并行性。封装之间的通信比同一封装内核心之间的通信要慢。此外，每个封装通常都有自己的内存控制器。一个封装中的 CPU 核心从另一个封装获取内存数据会花费更长的时间。是的，这意味着一个 16 核封装比两个 8 核封装的性能更好。然而，实际上，很少有软件会被多线程到足以充分利用这种差异。

最后，某些 CPU 核心通过能够同时运行多个线程来更有效地利用其执行资源。这被称为*硬件线程*、*同时多线程（SMT）*，或（如果你是 Intel 的话）*超线程（HyperThreading）*。这些额外的线程有时被称为虚拟处理器或虚拟核心。然而，虚拟处理器并不是一个完整的 CPU；例如，只有当第一个 CPU 在等待某些操作时，虚拟处理器才会被激活。FreeBSD 的默认调度程序 sched_ule(4)能够区分哪些核心是实际核心，哪些是虚拟核心，并适当地调度任务。

硬件线程引发了多种潜在的安全问题。一个虚拟处理器上运行的任务可以通过各种微妙的时间攻击，从另一个虚拟处理器上运行的任务中捕获数据，例如加密密钥。这不是一个适合脚本小子攻击的手段，但如果你不信任用户，可以通过将启动时可调参数`machdep.hyperthreading_allowed`设置为`0`来禁用硬件线程。

##### 使用 SMP

请记住，多个处理器并不一定让系统更快。一个处理器每秒钟可以处理一定数量的操作。第二个处理器仅意味着计算机每秒钟可以处理两倍的操作量，但这些操作不一定更快。

想象一下 CPU 的数量就像道路上的车道。如果你有一条车道，你只能一次让一辆车经过某个地方。如果你有四条车道，你就可以同时让四辆车经过那个地方。虽然四车道的道路不会让这些车更快到达目的地，但它们会有更多的车同时到达。如果你认为这没有区别，可以想想如果有人把你本地的高速公路换成单车道会发生什么。CPU 的带宽很重要。

虽然一个 CPU 一次只能做一件事，但一个进程一次只能在一个 CPU 上运行。许多程序无法在多个处理器上同时执行工作。线程程序是一个例外，正如我们在本章后面将看到的那样。一些程序通过同时运行多个进程，并让操作系统根据需要将它们分配到不同的处理器来绕过这个限制。流行的 Apache Web 服务器已经这样做了很多年。线程程序是专门设计来与多个处理器一起工作的，而不需要生成多个进程。许多线程程序简单地创建大量线程来处理数据，并将这些线程分散到 CPU 上，这是一种简单的（虽然并非总是有效的）并行处理方式。其他程序根本不处理多个 CPU。

如果你发现其中一个 CPU 100% 忙碌，而其他 CPU 大部分时间处于空闲状态，那说明你正在运行一个无法处理多个 CPU 的程序。第二十一章 将深入探讨性能问题，但对于这种程序，能做的帮助不多。

##### SMP 和 make(1)

用于构建软件的 make(1) 程序可以启动多个进程。如果你的程序写得很干净，你可以使用多个进程来构建它。这对小程序没有帮助，但当你构建一个大程序时，比如 FreeBSD 本身（参见 第十八章）或 LibreOffice，使用多个处理器确实可以加速工作。使用 make(1) 的 `-j` 标志告诉系统同时启动多少个进程。一个好的选择是系统中处理器或核心的数量加一。例如，在一台双处理器系统中，每个处理器有两个核心，我会运行五个进程来构建一个程序。

```
# make -j5 all install clean
```

一些程序员没有正确设计他们的*Makefile*，因此他们的程序无法处理 `-j` 标志。如果构建出现问题，停止使用 `-j` 再试一次——或者，更好的是，找出问题并向作者提交 bug 报告。

### 线程、线程、还有更多线程

你会在各种上下文中听到一个词——*线程*。一些 CPU 支持超线程（HyperThreading）。一些进程有线程。内核的某些部分作为线程运行。我的裤子上有很多很多的线（虽然有些比我妻子认为那些裤子应该在公共场合穿着所需的线少）。这些线程都是什么，它们意味着什么呢？

在大多数情况下，线程是一个轻量级进程。记住，*进程*是系统中的一个任务，一个正在运行的程序。进程有自己在系统中的进程 ID，并可以由用户启动、停止及管理。线程是进程的一部分，但它们由进程管理，不能直接由用户访问。一个进程一次只能做一件事，但个别线程可以独立执行。如果你有一个多处理器系统，一个进程可以在多个处理器上同时运行线程。

任何多线程程序都需要使用一个 *线程库*，该库通过与内核交互，告诉应用程序如何在该操作系统上使用线程。线程库以不同的方式实现线程，因此使用特定的库可能会影响应用程序的性能。

类似地，内核线程是内核中的一个子进程。FreeBSD 有内核线程来处理 I/O、网络等操作。每个线程都有自己的功能、任务和锁定。内核中的线程不使用任何用户空间的库。

硬件线程是虚拟的 CPU 核心，正如在“使用多个处理器：SMP”的 第 396 页中所讨论的那样。虽然你需要了解硬件是什么以及它如何影响你的系统，但硬件线程实际上并不属于线程的一部分。

### 启动和关闭脚本

service(8) 命令是系统启动和关闭脚本的前端。这些脚本被称为 *rc 脚本*，源自 */etc/rc*，即管理多用户启动和关闭过程的脚本。虽然主要的 rc 脚本位于 */etc/rc.d*，但其他位置的脚本用于管理附加软件。Ports 和 packages 安装启动脚本，但如果你安装了自己的软件，你需要创建自己的 rc 脚本。如果你之前没有使用过 shell 脚本，请仔细阅读。Shell 脚本并不难，学习的最好方法是阅读示例并在这些示例的基础上进行变动。此外，修改现有软件包的启动或关闭过程需要理解启动脚本的功能。

在启动和关闭过程中，FreeBSD 会检查 */usr/local/etc/rc.d* 目录，寻找额外的 shell 脚本并将其集成到启动/关闭过程中。（你可以使用 `local_startup` *rc.conf* 变量定义额外的目录，但目前我们假设你只有默认目录。）启动过程会特别查找可执行的 shell 脚本，并假定它找到的任何脚本都是启动脚本。它以 `start` 参数执行该脚本。在关闭过程中，FreeBSD 以 `stop` 参数运行这些相同的命令。预期这些脚本会读取这些参数并采取适当的行动。

#### *rc 脚本排序*

几十年来，类 Unix 操作系统在启动脚本中编码了服务启动顺序。这变得非常烦人，*非常*快。许多（但不是所有）Unix 系统已经摒弃了这种方式。类似地，FreeBSD 的 rc 脚本按照顺序排列。每个 rc 脚本会标识出在启动之前需要哪些资源。rc 系统利用这些信息对脚本进行排序。这个过程在启动和关闭时由 rcorder(8) 执行，但你随时可以手动进行，以查看它是如何工作的。只需将 rcorder(8) 路径传递给你的启动脚本作为参数。

```
# rcorder /etc/rc.d/* /usr/local/etc/rc.d/*
/etc/rc.d/growfs
/etc/rc.d/sysctl
/etc/rc.d/hostid
/etc/rc.d/zvol
/etc/rc.d/dumpon
/etc/rc.d/ddb
/etc/rc.d/geli
/etc/rc.d/gbde
--snip--
```

rcorder(8) 程序将 */etc/rc.d* 和 */usr/local/etc/rc.d* 目录中的所有脚本按系统启动时的顺序排序，使用脚本本身内的标记。如果你的 rc 脚本有任何排序错误，例如死锁脚本，这些错误会出现在 rcorder(8) 输出的开头。

#### *一个典型的 rc 脚本*

rc 脚本系统非常简单——虽然脚本本身可以变得复杂，但复杂性来自于脚本所运行的程序，而不是 rc 系统。启动 NFS 服务器的脚本有一堆依赖关系和需求。而像 timed(8) 这样的简单守护进程的脚本则体现了 rc 系统的简单性。

```
   #!/bin/sh

➊ # PROVIDE: timed
➋ # REQUIRE: DAEMON
➌ # BEFORE:  LOGIN
➍ # KEYWORD: nojail shutdown

➎ . /etc/rc.subr

➏ name="timed"
➐ desc="Time server daemon"
➑ rcvar="timed_enable"
➒ command="/usr/sbin/${name}"

➓ load_rc_config $name
   run_rc_command "$1"
```

`PROVIDE` 标签 ➊ 告诉 rcorder(8) 这个脚本的官方名称。这个脚本叫做 *timed*，以 timed(8) 命名。

`REQUIRE` 标签 ➋ 列出了在此脚本运行之前必须运行的其他脚本。需要在启动前运行 timed 的脚本会在 `REQUIRE` 中列出 timed。此脚本可以在 `DAEMON` 脚本运行后任何时间运行。

`BEFORE` 标签 ➌ 允许你指定该脚本后应运行的其他脚本。此脚本应在 `LOGIN` 脚本之前运行。*/etc/rc.d/LOGIN* 和 */etc/rc.d/timed* 都指定它们必须在 `DAEMON` 之后运行，但 `BEFORE` 标签允许你设置额外的排序要求。

`KEYWORD` 命令 ➍ 让启动系统只选择某些特定的启动脚本。timed(8) 脚本包括 `nojail` 和 `shutdown`。即使启用，监狱环境也不会运行这个脚本。此脚本在系统关闭时运行。

*/etc/rc.subr* 文件 ➎ 包含了 rc 脚本基础结构。每个 rc 脚本都必须包含它。

虽然脚本有一个名字，但脚本运行的程序可能有一个独立的名字 ➏。通常情况下，名为 *timed* 的 rc 脚本会运行名为 *timed* 的程序。

`description` 字段 ➐ 提供了该脚本所提供服务的简要描述，正如你所预期的那样。

`rcvar` 语句 ➑ 列出了切换此脚本的 *rc.conf* 变量。

`command` ➒ 明确指定了该脚本应运行的命令——毕竟，系统中可能有多个相同名称的命令，只是位于不同的目录中。

脚本执行的最后两个操作是从 */etc/rc.conf* 加载该服务的配置 ➓，然后实际运行命令。

虽然这看起来可能有点让人畏惧，但实际上并没有那么难。开始编写你的自定义 rc 脚本时，可以先复制一个现有的脚本。将命令名称设置为你的命令，并适当地更改路径。确定在运行脚本之前必须完成哪些操作：你需要网络正常运行吗？你需要某些守护进程已经启动，还是需要在某些守护进程之前运行你的程序？如果你实在不确定，可以通过使用`REQUIRE`语句并指定系统上最后运行的脚本的名称，将脚本安排在最后运行。通过查看其他提供类似功能的 rc 脚本，你将学会如何在启动脚本中做几乎任何事。

使用这个简单的脚本，你可以通过将信息添加到*/etc/rc.conf*来启用、禁用和配置你的程序。例如，如果你的自定义守护进程名为`tracker`，启动脚本会在*/etc/rc.conf*中查找变量`tracker_enable`和`tracker_flags`，并在每次运行启动脚本时使用它们。

#### *特殊的 rc 脚本提供程序*

你可能注意到我们示例中有名为*DAEMON*的服务，并且可能会想：“这很奇怪，我不知道有什么叫*DAEMON*的系统进程。”其实那并不是一个进程。rc 系统有一些特殊的提供程序，用于定义启动过程中的重要节点。使用这些提供程序可以简化编写 rc 脚本的过程。

FILESYSTEMS 提供程序确保所有本地文件系统都已按*/etc/fstab*中的定义挂载。

网络提供程序在所有网络功能配置完成后出现。这包括在网络接口上设置 IP 地址、PF 配置等。

SERVERS 提供程序表示系统已经具备了支持基本服务器所需的基本功能，如 named(8)和 NFS 支持程序。但此时远程文件系统尚未挂载。

守护进程提供程序确保所有本地和远程文件系统都已挂载，包括 NFS 和 CIFS，并确保更高级的网络功能，如 DNS，已正常运行。

在登录时，所有网络系统服务已启动，FreeBSD 开始启动支持通过控制台、FTP 守护进程、SSH 等进行登录的服务。

通过在自定义 rc 脚本中的`REQUIRE`语句中使用这些提供程序，你可以大致指定何时希望你的自定义程序运行，而无需深入细节。

#### *供应商启动/关机脚本*

也许你正在安装一个复杂的软件包，而供应商并不支持 FreeBSD 的 rc 系统。这不是问题。大多数供应商提供的脚本预计会接收一个参数，如`start`或`stop`。记住，在启动时，FreeBSD 会以`start`作为参数运行每个 rc 脚本，而在系统关机时，它会以`stop`作为参数运行脚本。通过将`PROVIDE`和`REQUIRE`语句作为注释添加到此供应商脚本中，并确认它接受这些参数，你可以确保脚本在启动和关机过程中在正确的时机运行。

在管理脚本中使用 rc 系统功能不是强制性的。在启动过程的最后，FreeBSD 会运行 */etc/rc.local*。你可以在这里添加本地命令。然而，你不能使用 service(8) 来管理 *rc.local* 中的任何内容。

#### *调试自定义 rc 脚本*

本地脚本，例如通过 Ports Collection 安装的脚本，是由 */etc/rc.d/localpkg* 运行的。如果你的自定义脚本引发了问题，你可以尝试通过调试运行 `localpkg` 脚本，查看你的脚本如何与 rc 系统交互。最好的做法是使用调试功能。

```
# /bin/sh -x /etc/rc.d/localpkg start
```

这会尝试重新启动服务器上的每个本地守护进程，这在生产系统中可能并不合适。建议先在测试系统上尝试。另外，记住 `-x` 调试标志不会传递给子脚本；你正在调试的是系统启动脚本 */etc/rc.d/localpkg* 本身，而不是本地脚本。运行脚本时请使用 `-x` 标志进行调试。

### 管理共享库

共享库是提供公共功能给其他已编译代码的已编译代码块。共享库的设计目的是尽可能被多个不同的程序重复使用。例如，许多程序必须为数据生成 *哈希* 或加密校验和。如果每个程序都需要包含自己的哈希代码，程序将更难编写，并且更不容易维护。而且，如果程序实现的哈希略有不同，它们之间将会出现互操作性问题，程序作者也需要学会大量关于哈希的知识才能使用它们。通过使用共享库（在这个例子中是 `libcrypt`），程序可以访问哈希生成函数，而没有兼容性和维护问题。这减小了程序的平均大小，无论是在磁盘上还是在内存中，代价是复杂性增加。

#### *共享库版本和文件*

共享库有一个人类友好的名称、一个版本号和一个相关联的文件。人类友好的名称通常（但不总是）与相关文件相似。例如，版本 1 的共享库 *libjail* 存放在文件 */lib/libjail.so.1* 中。另一方面，主 Kerberos 库的版本 11 存放在文件 */usr/lib/libkrb5.so.11* 中。版本编号从 0 开始。

历史上，当库的更改使其与早期版本的库不兼容时，版本号会递增。例如，libjail.so.0 变成了 libjail.so.1。FreeBSD 团队只有在发布周期开始时才会增加这些版本号（参见 第十八章）。每个库也有一个不带版本号的库名称的符号链接，指向该库的最新版本。例如，你会发现 */usr/lib/libwres.so* 实际上是一个符号链接，指向 */usr/lib/libwres.so.10*。这使得编译软件变得更容易，因为软件只需要查找一般的库文件，而不是该库的特定版本。

FreeBSD 的主要库支持 *符号版本控制*，这使得共享库可以支持多个编程接口。通过符号版本控制，共享库会为每个程序提供该程序所需的库版本。如果你有一个程序需要版本 2 的库，版本 3 也能支持这些功能。

仅仅因为 FreeBSD 支持符号版本控制，并不意味着 Ports Collection 中的所有软件都支持它。你必须留意库版本问题。

#### *将共享库附加到程序中*

那么，程序是如何获取所需的共享库的呢？FreeBSD 使用 ldconfig(8) 和 rtld(1) 根据需要提供共享库，但也提供了一些人性化的工具，供你调整和管理共享库的处理。

rtld(1) 也许是最容易理解的程序，至少从系统管理员的角度来看。每当程序启动时，rtld(8) 会检查程序需要哪些共享库。rtld(8) 程序会搜索库目录，查看这些库是否可用，然后将库与程序链接在一起，确保一切正常工作。你不能直接用 rtld(1) 做太多事情，但它提供了将共享库连接在一起的关键“粘合剂”。

##### 库目录列表：ldconfig(8)

系统不会在每次运行动态链接的程序时都在整个硬盘上搜索任何看起来像共享库的文件，而是通过 ldconfig(8) 维护一个共享库目录列表。(FreeBSD 的旧版本会构建一个系统中实际库的缓存，但现代版本只保持一个检查共享库的目录列表。) 如果程序找不到你知道系统中有的共享库，这意味着 ldconfig(8) 并不知道这些共享库所在的目录。^(1) 若要查看当前 ldconfig(8) 能找到的库，可以运行 `ldconfig -r`。

```
# ldconfig -r
/var/run/ld-elf.so.hints:
        search directories: /lib:/usr/lib:/usr/lib/compat:/usr/local/lib:/usr/
local/lib/perl5/5.24/mach/CORE
        0:-lcxxrt.1 => /lib/libcxxrt.so.1
        1:-lalias.7 => /lib/libalias.so.7
        2:-lrss.1 => /lib/librss.so.1
        3:-lkiconv.4 => /lib/libkiconv.so.4
        4:-lpjdlog.0 => /lib/libpjdlog.so.0
--snip--
```

使用 `-r` 标志，ldconfig(8) 会列出所有共享库目录中的共享库。我们首先看到被搜索的目录列表，然后是这些目录中的各个库。我的主邮件服务器有 170 个共享库；我的主网页服务器有 244 个；我的桌面有 531 个。

如果程序在启动时因找不到共享库而崩溃，那么该库就不会出现在这个列表中。你的问题就是需要将所需的库安装到共享库目录中，或者将库目录添加到被搜索的目录列表中。你可以将每个需要的共享库复制到 */usr/lib* 中，但这会使得系统管理变得非常困难——就像是文件柜中所有东西都归到 *P* 类别下（即 *纸张*）。在中长期内，添加目录到共享库列表中会是更好的选择。

##### 将库目录添加到搜索列表中

如果你添加了一个新的共享库目录，必须将它添加到 ldconfig(8)搜索的列表中。检查*/etc/defaults/rc.conf*中的这些 ldconfig(8)条目：

```
ldconfig_paths="/usr/lib/compat /usr/local/lib /usr/local/lib/compat/pkg"
ldconfig_local_dirs="/usr/local/libdata/ldconfig"
```

`ldconfig_paths`变量列出了常见的库位置。虽然开箱即用的 FreeBSD 没有*/usr/local/lib*目录，但大多数系统在安装后不久会创建一个类似目录。类似地，兼容旧版本 FreeBSD 的库会放入*/usr/lib/compat*。由软件包安装的旧版本库会存放在*/usr/local/lib/compat/pkg*目录。*/lib*和*/usr/lib*目录是默认被搜索的，但这个变量中的路径是共享库的常见位置。

端口和软件包使用`ldconfig_local_dirs`变量，将它们的共享库添加到搜索列表中，而不只是把所有东西都丢进*/usr/local/lib*。软件包可以在这个目录中安装一个文件。这个文件以软件包的名字命名，并包含一个列出软件包安装的库目录的列表。ldconfig 程序会检查这些目录中的文件，读取文件中的路径，并将这些路径视为额外的库路径。例如，Perl 5 软件包将共享库安装在*/usr/local/lib/perl5/5.24/mach/CORE*中。这个端口还会安装一个名为*/usr/local/libdata/ldconfig/perl5*的文件，里面只有一行内容，列出了这个路径。ldconfig 启动脚本会将这些文件中的目录添加到它检查共享库的目录列表中。

**/USR/LOCAL/LIB 与每个端口的库目录**

*/usr/local/lib*不是专门用于由端口和软件包安装的库吗？为什么不把所有共享库都放进那个目录呢？大多数端口正是这么做的，但有时使用单独的目录可以简化维护。例如，我在我的笔记本上安装了 Python 2.7，而*/usr/local/lib/python27*中包含了 647 个文件！如果把所有这些文件都放到*/usr/local/lib*中，就会压倒我非 Python 库的文件，并且让我更难找到由端口安装的只有一两个共享库的文件。

要将你的共享库目录添加到搜索列表中，可以将它添加到*/etc/rc.conf*中的 ldconfig_paths，或者在*/usr/local/libdata/ldconfig*中创建一个列出该目录的文件。两种方法都可以。一旦添加了该目录，该目录中的库将立即可用。

##### ldconfig(8)与奇怪的库

共享库有一些边缘情况你应该理解，还有许多你实际上不必担心的情况。这些情况包括针对不同二进制类型的库和针对其他架构的库。

FreeBSD 支持两种不同格式的二进制文件，a.out 和 ELF。系统管理员不需要了解这些二进制类型的详细信息，但你应该知道，ELF 二进制文件是现代标准，并且在 1998 年的版本 3.0 中成为了 FreeBSD 的标准。早期版本的 FreeBSD 使用的是 a.out。以某种类型编译的程序无法使用另一种类型的共享库。虽然 a.out 二进制文件已经基本消失，但由于支持它们的成本非常低，因此这个支持从未被移除。ldconfig(8) 为 a.out 和 ELF 二进制文件维护了独立的目录列表，正如你从 */etc/rc.d/ldconfig* 的输出中所看到的那样。你会在 *rc.conf* 中找到单独配置 ldconfig(8) 使用 a.out 库的选项。几乎可以说，你不会需要使用 a.out 程序。

另一个特殊情况是当你在 64 位 FreeBSD 安装上运行 32 位二进制文件时。最常见的情况是你在运行 amd64 安装并且希望使用来自旧版本 FreeBSD 的程序时。64 位二进制文件无法使用 32 位库，因此 ldconfig(8) 为它们保持了一个单独的目录列表。你也可以在 *rc.conf* 中找到配置这些目录的选项。不要混合使用 32 位和 64 位库！

一些硬件平台，如 ARM，拥有针对软浮点运算的特殊版本库。你也可以在 *rc.conf* 中找到这些选项，指向一组新的目录。

简而言之，不要将不常用的库与标准库混合使用。这样做会让 FreeBSD 混淆，从而让你感到困扰。

#### *LD_LIBRARY_PATH 和 LD_PRELOAD*

尽管 FreeBSD 内建的共享库配置系统在你是系统管理员时工作得很好，但如果你只是一个没有 root 权限的普通用户，它就无法工作了。^(2) 此外，如果你有自己的个人共享库，你可能不希望它们被全局访问。系统管理员当然也不希望在生产程序中链接随机的用户拥有的库！这时 `LD_LIBRARY_PATH` 就派上用场了。

每次运行 rtld(1) 时，它会检查环境变量 `LD_LIBRARY_PATH`。如果该变量包含目录，它会检查这些目录中的共享库。这些目录中的任何库都会作为程序的选项被包括进去。你可以在 `LD_LIBRARY_PATH` 中指定任意数量的目录。例如，如果我想做一些测试并且在接下来的程序运行中使用 */home/mwlucas/lib* 和 */tmp/testlibs* 里的库，我只需这样设置该变量：

```
# setenv LD_LIBRARY_PATH /home/mwlucas/lib:/tmp/testlibs
```

你可以通过在 *.cshrc* 或 *.login* 中输入正确的命令，在登录时自动设置这个环境变量。

类似地，`LD_PRELOAD` 环境变量允许你先加载特定的库。你可以通过在 `LD_PRELOAD` 中指定完整路径来测试自定义的 libc。当 rtld(1) 运行时，它会从 `LD_PRELOAD` 中获取库，并忽略后续提供相同符号的库。

**LD_ 环境变量与安全性**

使用 `LD_LIBRARY_PATH` 或 `LD_PRELOAD` 并不安全。如果你将此变量指向一个过于开放的目录，你的程序可能会链接到任何人放入该目录的内容。`LD_LIBRARY_PATH` 变量会覆盖共享库目录列表，因此，如果有人能够在你的库目录中放入任意文件，他们就能接管你的程序。出于这个原因，`setuid` 和 `setgid` 程序会忽略这些变量。

#### *程序需要什么*

最后，关于程序正确运行所需的库的问题。通过 `ldd(1)` 获取这些信息。例如，要了解 Emacs 需要哪些库，可以输入以下命令：

```
# ldd /usr/local/bin/emacs
/usr/local/bin/emacs:
        libtiff.so.5 => /usr/local/lib/libtiff.so.5 (0x800a78000)
        libjpeg.so.8 => /usr/local/lib/libjpeg.so.8 (0x800cf1000)
        libpng16.so.16 => /usr/local/lib/libpng16.so.16 (0x800f63000)
        libgif.so.7 => /usr/local/lib/libgif.so.7 (0x80119d000)
        libXpm.so.4 => /usr/local/lib/libXpm.so.4 (0x8013a6000)
        libgtk-3.so.0 => /usr/local/lib/libgtk-3.so.0 (0x801600000)
--snip--
```

这个输出告诉我们 Emacs 所需的共享库的名称以及包含这些库的文件的位置。如果你的程序找不到所需的库，`ldd(1)` 会告诉你。程序本身在你尝试运行时会宣布第一个缺失的共享库的名称，但 `ldd(1)` 会给你完整的列表，这样你可以使用搜索引擎查找所有缺失的库。

在 `ldconfig(8)` 和 `ldd(1)` 之间，你应该充分准备好在你的 FreeBSD 系统上管理共享库。

### 重新映射共享库

偶尔，你会发现有一款软件需要使用特定的共享库，而这些库并不被系统的其他部分使用。例如，FreeBSD 的标准 C 库是 libc。你可以有一个带有特定功能的 libc 副本，只为某个特定程序提供，然后你可以只让那个程序使用这个特殊的 libc，同时其他程序使用标准的 libc。FreeBSD 允许你更改任何应用程序使用的共享库。这听起来有些奇怪，但在各种边缘情况下非常有用。开发者使用这个功能在将代码推送到整个系统之前进行小规模的测试。使用 */etc/libmap.conf* 和 */usr/local/etc/libmap.d/* 中的文件来告诉 `rtld(1)` 对客户端程序撒谎。

虽然 *libmap.conf* 条目对于软件开发非常有用，但你也可以用它们来全局替换库。一些通过包安装的视频卡驱动程序需要你使用它们的驱动程序，而不是某些系统库。少数 Nvidia 驱动程序希望提供 libGL 图形功能。不要覆盖所有程序依赖的 libGL 包：相反，重新映射这个库。你可以为整个系统、特定程序名称或特定完整路径下的程序配置库替换。

一个 libmap 文件（可以是 *libmap.conf* 或 */usr/local/etc/libmap.d/* 中的文件）有两列。第一列是程序请求的共享库的名称；第二列是提供的共享库。所有更改将在下次执行程序时生效；不需要重新启动或重启守护进程。例如，在这里，我们告诉系统，每当任何程序请求 libGL 时，应该提供 Nvidia 版本的库。这些全局覆盖必须首先出现在 *libmap.conf* 中：

```
libGL.so         libGL-NVIDIA.so
libGL.so.1       libGL-NVIDIA.so.1
```

“我可以获得 libGL.so.1 吗？”

“当然，这是 libGL-NVIDIA.so.1。”

全局重新映射库是一个相当大胆的步骤，可能会引起其他系统管理员的讨论，但逐个程序地重新映射库则不那么雄心勃勃，更有可能解决更多问题，而不是制造问题。只需在重新映射语句之前指定所需的程序名并放入方括号。如果你通过完整路径指定程序，映射仅在通过完整路径调用程序时有效。如果你只提供名称，当你运行任何该名称的程序时，映射都会生效。例如，在这里我们重新映射 emacs(1)，使其在通过完整路径调用时使用 Nvidia 的库，而不是系统库：

```
[/usr/local/bin/emacs]
libGL.so         libGL-NVIDIA.so
libGL.so.1       libGL-NVIDIA.so.1
```

如何证明这成功了呢？好吧，检查一下 ldd(1)：

```
# ldd /usr/local/bin/emacs | grep libGL
        libGL.so.1 => /usr/local/lib/libGL-NVIDIA.so.1 (0x80ad60000)
```

你可以看到，当*/usr/local/bin/emacs*请求 libGL.so.1 时，rtld(1)会将其附加到 libGL-NVIDIA.so.1 上。我们指定了 Emacs 二进制文件的完整路径，因此我们需要通过完整路径调用该程序。尝试在没有完整路径调用的情况下对 Emacs 使用 ldd(1)：

```
# cd /usr/local/bin
# ldd emacs | grep libGL
        libGL.so.1 => /usr/local/lib/libGL.so.1 (0x0x8056fa000)
```

通过进入*/usr/local/bin*并直接对 Emacs 运行 ldd(1)，而无需指定完整路径，rtld 无法看到 emacs(1)二进制文件的完整路径。*/etc/libmap.conf*表示只在*/usr/local/bin/emacs*的完整路径下使用 Nvidia 的库。当裸露的`emacs`请求 libGL.so.1 时，它得到了它请求的内容。

如果你希望程序无论是通过完整路径还是基本名称调用，都使用替代库，只需在方括号中给出程序名称，而不是完整名称：

```
[emacs]
libGL.so         libGL-NVIDIA.so
libGL.so.1       libGL-NVIDIA.so.1
```

同样，你也可以通过列出目录名并在后面加上斜杠，选择一个替代库来应用于目录中的所有程序。在这个*/usr/local/etc/libmap.d/oracle*文件中，我们强制目录中的所有程序使用替代库：

```
[/opt/oracle/bin/]
libc.so.7       libc-special.so.2
```

使用*libmap.conf*允许你任意重新映射共享库。开发人员使用此功能来测试代码。端口使用它来为某些程序覆盖库。你也会找到它的用处。

### 在错误的操作系统上运行软件

传统的软件是为特定操作系统编写的，只能在该操作系统上运行。许多人通过改变软件使其能够在另一个系统上运行，从而建立了成功的商业，这一过程称为*移植*。作为管理员，你有几种不同的方式使用为其他平台（非 FreeBSD）编写的软件。最有效的方法是重新编译源代码，使其能够在 FreeBSD 上本地运行。如果这不可行，你可以通过模拟器（如 Wine）运行非本地软件，或者通过重新实现软件本地平台的应用程序二进制接口（ABI）来运行。

#### *重新编译*

许多 FreeBSD 包实际上是其他平台上原本设计的软件的移植版。（这就是为什么它被称为*Ports*集合的原因。）为 Linux、Solaris 或其他类 Unix 操作系统编写的软件，通常可以通过少量或不做修改直接从源代码重新编译并在 FreeBSD 上无缝运行。只需将源代码取出并在 FreeBSD 机器上构建，就可以原生运行外部软件。

重新编译在平台相似时效果最佳。类 Unix 平台应该是相当相似的，不是吗？例如，FreeBSD 和 Linux 提供了许多相似的系统功能；它们都建立在标准 C 函数之上，都使用类似的工具，都使用 GCC 编译器，等等。然而，多年来，各种类 Unix 操作系统已经发生了分歧。每个版本的 Unix 都实现了新特性、新库和新函数，如果某个软件依赖这些特性，它就无法在其他平台上构建。POSIX 标准部分是为了解决这个问题而提出的。POSIX 定义了最基本的类 Unix 操作系统标准。仅使用符合 POSIX 的系统调用和库编写的软件，应该可以立即移植到任何其他符合 POSIX 的操作系统上，而且大多数类 Unix 操作系统厂商都遵循 POSIX。问题在于如何确保开发者遵守 POSIX。许多开源开发者只关心他们的软件是否能在自己偏好的平台上运行。很多特定于 Linux 的软件不仅不符合 POSIX 标准，还包含一堆独特的功能，通常被称为*Linuxisms*。而仅遵循 POSIX 的代码则无法利用操作系统提供的任何特殊功能。

公平地说，FreeBSD 也有一些 FreeBSD 特有的特性，比如超高效的数据读取系统调用 kqueue(2)。其他类 Unix 操作系统则使用 select(2) 和 poll(2)，或者实现自己的系统调用。应用程序开发者会问自己，是否应该使用 kqueue(2)，这样他们的软件在 FreeBSD 上会非常快速，但在其他地方则毫无用处；还是应该使用 select(2) 和 poll(2)，让他们的软件能够在所有地方运行，尽管速度较慢。开发者可以投入更多时间，支持 kqueue(2)、select(2)、poll(2) 和其他操作系统特定的变种，但尽管这样会让用户高兴，从开发者的角度来看却相当糟糕。

FreeBSD 采取了一种折中的方式。如果某个软件可以重新编译以在 FreeBSD 上正常运行，端口团队通常会让它实现。如果该软件需要小的补丁，端口团队会将这些补丁与端口一起包含，并将它们发送给软件开发者。大多数软件开发者都会愉快地接受补丁，从而使他们的软件支持另一个操作系统。即使他们可能没有该操作系统可用于测试，或者他们可能对该操作系统不熟悉，只要补丁来自可靠的来源，并且看起来不错，通常都会被接受。

#### *仿真*

如果软件需要大量重新设计才能在 FreeBSD 上运行，或者如果源代码根本不可用，我们可以尝试仿真。一个 *仿真器* 会将一个操作系统的系统调用和库调用转换为本地操作系统提供的等效调用，从而使在仿真器下运行的程序认为它们正在本地系统上运行。然而，转换所有这些调用会增加额外的系统开销，影响程序的速度和性能。

FreeBSD 支持多种仿真器，其中大多数在 Ports 集合中位于 */usr/ports/emulators* 下。在大多数情况下，仿真器用于教育或娱乐。如果你有一款老旧的 Commodore 64 游戏，想再玩一次，可以安装 */usr/ports/emulators/frodo*。（警告：在现代 FreeBSD 系统上挂载 C64 磁盘会让你比人类本应知道的更多了解磁盘。）在 */usr/ports/emulators/dolphin-emu* 下有一个 Nintendo GameCube 仿真器，在 */usr/ports/emulators/simh* 下有一个 PDP-11 仿真器，等等。

虽然仿真器非常酷，但对于服务器来说并没有太大用处，因此我们不会深入讲解它们。

#### *ABI 重新实现*

除了重新编译和仿真，运行外部程序的最后一种选择是 FreeBSD 最为人熟知的：*应用程序二进制接口（ABI）重新实现*。ABI 是内核提供给程序的服务部分，包括从管理声卡到读取文件、打印到屏幕、启动其他程序的所有操作。就程序而言，ABI 就是操作系统。通过在本地操作系统上完全实现另一个操作系统的 ABI 并提供该操作系统所使用的用户空间库，你可以像在本地平台上一样运行非本地程序。

虽然 ABI 重新实现通常被称为仿真，但它并不是仿真。当实现 ABI 时，FreeBSD 并不是在仿真系统调用，而是为应用程序提供本地实现。没有程序会将系统调用转换为 FreeBSD 等价的调用，也没有努力将用户空间库转换为 FreeBSD 库。同样，称“FreeBSD 实现了 Linux”也是不正确的。创建这个技术时，没有一个词可以完全描述它，直到今天也没有一个特别合适的描述方式。你可以说 FreeBSD 实现了 Linux 系统调用接口，并且支持将二进制文件指向适当的系统调用接口，但这实在是有点冗长。你通常会听到它被称为 *模式*，比如说“Linux 模式”。

ABI 重实现的问题是重叠。许多操作系统都包含具有通用名称的系统调用，例如 read、write 等。FreeBSD 的 read(2) 系统调用与 Microsoft 的 read() 系统调用行为非常不同。当程序使用 read() 调用时，FreeBSD 如何知道它需要哪个版本呢？你可以给你的系统调用不同的名称，但那样会违反 POSIX 并且混淆程序。FreeBSD 通过提供多个 ABI 并通过 *品牌化* 来控制程序使用哪个 ABI，从而解决了这个问题。

#### *二进制品牌化*

操作系统通常具有一个执行程序的系统功能。当内核将程序发送到这个执行引擎时，它会运行该程序。

几十年前，BSD（当时的 Unix）程序执行系统调用被更改为包括对以 `#!/bin/sh` 开头的程序进行特殊检查，并用系统 shell 运行它们，而不是执行引擎。BSD 将这个想法推向了极限：其执行引擎包括一个不同二进制类型的列表。每个程序的二进制类型指向正确的 ABI。因此，FreeBSD 系统可以实现多个 ABI，保持它们的独立性，并支持来自不同操作系统的程序。

这个系统的妙处在于它的开销极小。因为 FreeBSD 无论如何都必须决定如何运行程序，那为什么不让它决定使用哪个 ABI 呢？毕竟，不同操作系统的二进制文件都有略微不同的特征，FreeBSD 可以利用这些特征来识别它们。FreeBSD 只是让这一过程对最终用户透明。二进制文件的识别称为 *品牌化*。FreeBSD 的二进制文件标记为 *FreeBSD*，而其他操作系统的二进制文件则适当品牌化。

#### *支持的 ABI*

由于这种 ABI 重定向，FreeBSD 可以像本地编译一样运行 Linux 二进制文件。旧版本的 FreeBSD 也可以运行 OSF/1、SCO 和 SVR4 二进制文件，但这些平台的需求已经显著减少。^(3) 如果你需要其中的某个，你可以尝试在虚拟机上运行旧版本的 FreeBSD。

Linux 模式，也叫 *Linuxulator*，非常全面，因为 Linux 的源代码是开放的，且其 ABI 有良好的文档。事实上，Linux 模式工作得如此顺利，以至于 Ports Collection 中的许多程序都依赖于它。

#### *安装和配置 Linuxulator*

虽然 ABI 重实现解决了一个主要问题，但程序不仅仅需要 ABI。没有共享库、支持程序和其余的用户空间，大多数程序无法正常运行。无论你使用哪个 ABI，你必须能够访问该平台的用户空间。

如果你想使用 Ports Collection 中可用的 Linux 软件，安装该端口。这将自动安装任何用户空间的依赖项。

如果你想运行某个任意的 Linux 软件，你必须先安装一个 Linux 用户空间。FreeBSD 通常会提供几种不同的 Linux 用户空间作为包。要查看有哪些可用的包，可以在包数据库中搜索 linux_base。

```
# pkg search linux_base
linux_base-c6-6.9_2            Base set of packages needed in Linux mode (Linux CentOS 6.9)
linux_base-c7-7.3.1611_6       Base set of packages needed in Linux mode (Linux CentOS 7.3.1611)
```

这个版本的 FreeBSD 有两个 Linux 用户空间：一个基于 CentOS 6.9，另一个基于 CentOS 7.3。Linux 发行版可能会随着 Linux 方向的变化而发生变化。

检查你的软件运行在哪些版本的 Linux 上。为你的应用安装最合适的用户空间。FreeBSD 将 Linux 用户空间安装在 */usr/compat/linux* 下。

该端口还会加载 Linux 模式内核模块。要在启动时自动加载该模块，可以使用以下 *rc.conf* 条目：

```
linux_enable="YES"
```

就是这样！Linux 模式不是一个正式的服务，因为你无法重启它或获取状态，因此不能用 service(8) 来配置它。运行 `/etc/rc.d/abi start` 可以在不重启的情况下激活 Linux 模式。

在我们深入了解如何运行 Linux 程序之前，先来探索一下用户空间。

##### Linux 用户空间

就像 *linux.ko* 内核模块提供 Linux ABI 一样，Linuxulator 需要一个非常精简的 Linux 用户空间。看看 */usr/compat/linux* 目录，你会看到类似下面的内容：

```
# ls
bin     etc     lib64   proc    selinux sys     var
dev     lib     opt     sbin    srv     usr
```

看起来很像 FreeBSD 的 */* 目录的内容，不是吗？如果你多探查一下，你会发现，通常情况下，*/usr/compat/linux* 中的内容与核心 FreeBSD 安装中的内容相当。你会在两者中找到许多相同的程序。

Linux 爱好者立刻会注意到任何 linux_base 端口的一个特点，那就是它的内容比典型的 Linux 安装要精简。这是因为每个基于 Linux 的包只安装它运行所需的内容。FreeBSD 的 Linux 包将极简的 BSD 哲学强加到 Linux 软件中。

每当可能时，Linux 模式下的程序会尽量保持在 */usr/compat/linux* 目录下，这有点像一个弱监狱（参见 第二十二章）。当你执行一个调用其他程序的 Linux 二进制程序时，Linux ABI 会首先在 */usr/compat/linux* 下查找该程序。如果程序在那里不存在，Linux 模式会在主系统中查找。例如，假设你有一个调用 ping(8) 的 Linux 二进制程序。ABI 首先会在 */usr/compat/linux/* 下查找 ping 程序；截至本文撰写时，它不会找到任何内容。然后，ABI 会检查主 FreeBSD 系统，找到 */sbin/ping*，并使用它。Linuxulator 在很大程度上利用了这种回退机制来减少 Linux 模式用户空间的大小。

另外，假设一个 Linux 二进制程序想调用 sh(1)。Linux ABI 会在 */usr/compat/linux* 下查找，找到 */usr/compat/linux/bin/sh*，并执行该程序，而不是 FreeBSD 原生的 */bin/sh*。

##### linprocfs 和 tmpfs

Linux 使用一个进程文件系统，或*procfs*。FreeBSD 几十年前就将 procfs 作为默认设置移除，因为它存在安全风险，但一些 Linux 程序仍然需要它。使用需要 procfs 的 Linux 软件意味着接受固有的风险。FreeBSD 提供了一个作为 linprocfs(5)的 Linux procfs。

要启用 linprocfs(5)，在安装 Linuxulator 后，将以下内容添加到*/etc/fstab*中：

```
linproc    /compat/linux/proc    linprocfs  rw     0       0
```

FreeBSD 根据需要加载文件系统内核模块，因此请输入`mount` `/compat``/li``nux/proc`来激活 linprocfs(5)而无需重启。

许多 Linux 程序还期望*/dev/shm*用于共享内存。FreeBSD 可以通过 tmpfs(5)模拟这一点。

```
tmpfs    /compat/linux/dev/shm  tmpfs   rw,mode=1777    0       0
```

输入`mount /compat/linux/dev/shm`，共享内存设备就绪。

##### 测试 Linux 模式

现在您对 Linux 模式下安装的内容有了大致了解，测试 Linux 功能变得容易了。运行 Linux shell 并询问它正在运行哪个操作系统：

```
# /usr/compat/linux/bin/sh 
sh-4.1# uname -a
Linux storm 2.6.32 FreeBSD 12.0-CURRENT #0 r322672: Fri Aug 17 16:31:34 EDT
2018 x86_64 x86_64 x86_64 GNU/Linux
sh-4.1#
```

当我们询问这个命令提示符运行的是什么类型的系统时，这个 shell 回答它是一个在 Linux 2.6.32 内核之上运行的 Linux 系统，叫做*FreeBSD*。很酷吧？

但是请记住，Linux 模式并不是一个完整的 Linux 用户空间。在默认的 Linuxulator 安装中，您无法交叉编译软件。您只能执行非常基础的任务。

##### 识别和设置品牌

为软件二进制文件打上品牌要比给牲畜打上品牌容易，但没有那么冒险。大多数现代类 Unix 二进制文件都采用 ELF 格式，其中包括一个注释空间。品牌就存在于这里。FreeBSD 通过该二进制文件上的品牌为每个程序分配一个 ABI。如果二进制文件没有品牌，则假定它是 FreeBSD 二进制文件。

使用 brandelf(1)查看和更改品牌：

```
# brandelf /bin/sh 
File '/bin/sh' is of brand 'FreeBSD' (9).
```

这并不令人惊讶。这是一个 FreeBSD 二进制文件，因此它将在 FreeBSD ABI 下执行。让我们尝试一个 Linux 二进制文件：

```
# brandelf /usr/compat/linux/bin/sh
File '/usr/compat/linux/bin/sh' is of brand 'Linux' (3).
```

使用`-l`标志查看 FreeBSD 支持的品牌。

```
# brandelf -l
known ELF types are: FreeBSD(9) Linux(3) Solaris(6) SVR4(0)
```

如果您有一个无法运行的外部程序，请检查其品牌。如果没有品牌或品牌错误，您可能已经发现了问题所在：FreeBSD 试图在原生 FreeBSD ABI 下运行该程序。通过`brandelf -t`手动设置品牌来解决此问题。例如，要将程序标记为 Linux，可以执行以下操作：

```
# brandelf -t Linux /usr/local/bin/program
```

下次尝试运行该程序时，FreeBSD 将在 Linux ABI 和 Linux 用户空间下运行它，程序应该按预期工作。

您还可以使用 sysctl 设置*回退品牌*。所有 FreeBSD 二进制文件都会被正确地标记，但您复制到主机的随机程序可能不会。未标记品牌的二进制文件将被视为所选回退品牌。sysctl `kern.elf32.fallback_brand`为 32 位主机设置回退品牌，而`kern.elf64.fallback_brand`则为 64 位主机设置回退品牌。此 sysctl 采用品牌的数字标识符，对于 Linux 来说是 3。

```
# sysctl kern.elf64.fallback_brand=3
```

现在，您应该能够运行 Linux 程序，而无需进一步配置。剩下的只是 Linux 模式中的一些小烦恼和瑕疵。可惜的是，正如我们接下来所示的那样，这些问题确实存在。

### 使用 Linux 模式

许多 Linux 程序仅作为端口提供。Ports Collection 足够智能，可以识别出某个软件需要 Linux 模式，并选择合适的 Linux 组件进行安装。一个受欢迎的选择是 Skype。安装这个端口时，会触发正确的 Linux 用户空间安装。

拥有一个最小化的 Linux 用户空间的缺点是，任何端口都会有一堆依赖项。其中一些是 FreeBSD 二进制文件，其他是 Linux 文件。我建议使用端口的 `make missing` 命令来显示缺少的依赖项，甚至像 第十六章 讨论的那样，自动从软件包中安装依赖项。一旦安装了所有所需的软件包，安装了 linprocfs 和 Linux 共享内存设备，并加载了所有内核模块，安装 Skype 就像执行 `make install clean` 一样简单。

#### *调试 Linux 模式*

Linux 模式并不是 Linux，尤其在程序崩溃时，这一点尤为明显。许多程序都有晦涩的错误信息，而 Linux 模式可能会进一步掩盖这些信息。你需要一些工具，能够深入挖掘错误信息，看到真正的问题所在。

##### Linux 模式与 truss(1)

我发现用于调试 Linux 模式的最佳工具是 truss(1)，即 FreeBSD 系统调用追踪器。有些人告诉我，用 truss(1) 来做这件事就像把一台 Mack 卡车的 12 缸发动机装进一辆大众 Beetle 汽车里，但经过深思熟虑，我决定我不在乎。它有效。一旦你了解了 truss(1)，你会想知道你是怎么在没有它的情况下生活的。^(4)

truss(1) 程序可以准确识别程序进行的系统调用以及每个调用的结果。记住，系统调用是程序与内核的接口。当程序试图访问网络、打开文件，甚至分配内存时，它会发出系统调用。这使得 truss(1) 成为查看程序为何失败的一个极好的工具。程序会发出大量的系统调用，这意味着 truss(1) 会生成大量数据，因此用 truss(1) 调试非常适合使用 script(1) 来记录。

所以让我们启动 Skype。

```
$ skype
Segmentation fault (core dumped)
```

好消息是：程序可以运行！坏消息是，它在某个地方卡住了。我最常遇到的错误是缺少库、文件和目录，但具体是哪一个呢？truss(1) 的输出可以告诉我。启动一个 script(1) 会话，在 truss(1) 下运行程序，并结束 script。

你的脚本文件可能会有几百行或几千行；你怎么可能找到问题呢？搜索相关的错误信息或字符串 ERR。在这个例子中，我搜索了字符串 `directory`，并在输出的末尾找到了如下内容：

```
$ truss skype
--snip--
linux_open("/usr/local/Trolltech/Qt-4.4.3-static/lib/tls/i686/sse2/libasound.so.2",0x0,00)
ERR#-2 'No such file or directory'
linux_stat64("/usr/local/Trolltech/Qt-4.4.3-static/lib/tls/i686/sse2",0xffffb248) ERR#-2 'No
such file or directory'
linux_open("/usr/local/Trolltech/Qt-4.4.3-static/lib/tls/i686/libasound.so.2",0x0,00) ERR#-2 'No such file or directory'
--snip--
```

啊哈！Skype 找不到所需的库。软件包维护者可能遗漏了这些库，或者可能是我某个地方搞错了。检查一下你的主机上是否有这些库。如果没有，你需要安装它们。也许有可用的端口，或者我可能需要安装 Linux 软件包。

##### 安装 Linux 软件包

如果你需要的 Linux 库或软件没有端口，你有几种选择。一种是为该软件创建一个端口。端口是参与 FreeBSD 社区的好方法。然而，如果你的目标是让软件运行起来并继续完成你的工作，那么你需要从源 RPM 安装适当的 Linux 软件。不过要注意，一旦你安装了 Ports 集合以外的软件，你就需要手动维护它。

查找你需要的软件的 RPM。确保包的版本与安装在 linux_base 中的版本匹配。如果你的 FreeBSD 主机使用的是 CentOS 7.3.1611，而你找到了适用于 CentOS 8 的缺失库包，那就没用。下载 RPM 文件。

**商业 Linux 软件和 Linux 模式**

请记住，商业软件供应商不会在 FreeBSD 的 Linux 模式下支持其 Linux 软件。如果你身处有服务级别协议的工业环境，并且存在可能需要支付罚款的风险，在使用 Linux 模式之前请三思。商业软件的主要优势是当软件出现故障时，可以找人负责，但 FreeBSD 的 Linux 模式消除了这一优势。

假设我的生活发生了可怕的转折^(5)，我需要在 Linux 模式下运行 Supermin。我找到并下载了包文件，然后使用 tar(1) 安装它。FreeBSD 基于 libarchive 的 tar 可以像处理其他任何文件一样打开 RPM 文件。

```
# cd /compat/linux
# tar -xf /home/mwl/supermin-5.1.16-4.el7.x86_64.rpm
```

现在，我得去找下一个缺失的依赖项。一旦我拥有了完整的依赖项列表，我将写一个端口，以节省其他人这份繁琐的工作。

### 运行来自错误架构或版本的软件

当你运行 FreeBSD 的 amd64 平台时，最终会遇到一些只提供给 i386 平台的软件。如果你的内核启用了 `COMPAT_FREEBSD32` 选项（GENERIC 中已包含），FreeBSD/amd64 可以运行所有 FreeBSD/i386 软件。不过，你不能使用 FreeBSD/amd64 的共享库来运行 FreeBSD/i386 软件。如果你想在 64 位计算机上运行一个复杂的 32 位程序，你必须提供必要库的 32 位版本。这是完全支持的；如果你查看 *rc.conf*，会看到 ldconfig(8) 的选项 `ldconfig32_paths` 和 `ldconfig_local32_dirs`。这些选项专门用于告诉你的 amd64 系统在哪里可以找到 32 位库。FreeBSD 在安装介质中包含了 32 位库。

此外，FreeBSD 可以运行来自旧版本 FreeBSD 的软件。GENERIC 内核包含所有的系统调用，但你仍然需要基础系统库。这些库以包的形式提供，每个主要的 FreeBSD 版本都有一个相应的包。每个包的名称以*compat*开头，后跟版本号，并以*x*结尾。如果你必须运行 FreeBSD 8 的二进制文件，安装 compat8x 包。compat 包包含 64 位和 32 位库。

如果你需要运行非 i386 或 amd64 的二进制文件，你甚至可以使用 binmiscctl(8)在每次运行非 x86 二进制文件时自动启动合适的模拟器。

尽管关于软件管理的知识总是有更多可以学习的内容，但你现在已经足够掌握基本知识来应付了。接下来，让我们继续学习如何升级 FreeBSD。
