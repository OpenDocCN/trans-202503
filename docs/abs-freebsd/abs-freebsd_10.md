## **10

磁盘、分区和几何**

![image](img/common01.jpg)

系统管理员不能过分强调管理磁盘和文件系统的重要性。（去吧，试着过分强调。我会等着的。）你的磁盘存储着你的数据，这使得操作系统对其可靠性和灵活性要求极高。FreeBSD 支持多种文件系统，并有许多不同的方法来处理它们。在本章中，我们将讨论每个系统管理员都会执行的最常见的磁盘任务。

首先，让我们讨论存储设备最重要的一点。

### **磁盘会撒谎**

曾几何时，系统管理员可以根据磁盘提供的信息做出决策。你可以插入硬盘，查询其盘片数、气缸数、扇区数等更多信息。那时候已经是很久很久以前的事了。是的，你现在可以执行相同的查询并得到答案，但这些答案并不反映任何现实。今天，磁盘就像是一个魔法盒子，根据需求吐出数据。这个魔法盒子有的包含旋转的盘片，另一些则没有活动部件。这个魔法盒子提供带编号的扇区来存储比特和字节。那些数字和盒子内容之间的关系？那就是魔法：不可理解且无法知晓。

在之前的书籍中，包括本书的早期版本，我讨论过数据在磁盘上正确放置的重要性，但这些知识如今已经完全过时。如果你仍然保留这些知识，请抛弃它，转而学习更有用的东西，比如所有出演经典*神秘博士*角色的演员的完整传记。

就磁盘设计而言，你需要知道的唯一事情就是*逻辑块寻址（LBA）*。磁盘上的每个扇区都会分配一个编号。文件系统通过编号来调用磁盘扇区。就是这样。LBA 以下的任何内容，都只是你个人的猜测而已。

不幸的是，磁盘现在有了一类新的谎言：扇区大小。

到了 1990 年代，磁盘扇区大小从 128 字节到 2KB 不等。即使是最早的 IBM PC 也能理解软盘上不同的扇区大小。

然而，在 2000 年代初期，制造商决定使用 512 字节的扇区。今天的硬盘容量大得多，文件也同样更大。在过去的几年里，512 字节的扇区大多被 4,096 字节的扇区取代，这种硬盘被称为*4K 硬盘*。这种扇区大小对于我们今天存储的数据类型来说更为合理。

问题是，像 Windows XP 这样的操作系统知道磁盘扇区一直是，而且永远会是，512 字节。这些操作系统无法容忍报告拥有 4KB 扇区的硬盘，因为大家都知道根本没有这种东西。如果你制造了 4K 硬盘，你该怎么办？

就是你一直在做的事。

你教硬盘撒谎。

最重要的是，不同的 4K 驱动方式不同。如果操作系统询问驱动其扇区大小，大多数驱动会声明它们有 512 字节的扇区。那些宣称有 512 字节和 4KB 扇区的驱动可能是 4K 驱动，正在努力说出真相。很少有驱动承认只使用 4KB 扇区。更复杂的是，一些固态硬盘的扇区甚至达到 8KB 或 16KB，或者它们支持多种扇区大小。

FreeBSD 的两个主要文件系统都必须知道底层磁盘的扇区大小以及该扇区的逻辑块地址。如果在磁盘上使用了错误的扇区大小，性能会受到影响。我可以详细讨论这种情况发生的原因，但为了简化，始终将分区对齐到偶数 MB 边界。这可能会浪费一些字节，但与磁盘和文件系统不对齐所带来的严重性能问题相比，这点浪费是微不足道的。

### **设备节点**

我们在第四章中简要讨论过设备节点，但在这里我们将更详细地探讨它们。设备节点是表示硬件设备或操作系统功能的特殊文件。它们作为逻辑接口提供功能给用户程序。通过对设备节点使用命令、发送信息或读取数据，你实际上是在告诉内核执行某个动作。如果设备节点代表物理设备，那你正在对该设备进行操作。这些操作在不同设备间可能大不相同——写数据到磁盘与写数据到声卡是完全不同的操作。虽然你可以在任何地方暴露设备节点，但标准的设备节点存在于*/dev*目录中。

在你可以使用磁盘或磁盘分区之前，你必须知道它的设备名称。FreeBSD 的磁盘设备节点来自该类型硬件的设备驱动程序名称。设备驱动程序名称反过来通常来源于设备的类型，而不是设备的角色或功能。

表 10-1 展示了最常见的磁盘设备节点。

**表 10-1：** 存储设备节点和类型

| **设备节点** | **手册页** | **描述** |
| --- | --- | --- |
| */dev/ada** | ada(4) | ATA 风格直接访问磁盘（SATA, IDE 等） |
| */dev/cd** | cd(4) | 光学媒体驱动（CD，Blu-Ray 等） |
| */dev/da** | da(4) | SCSI 风格直接访问磁盘（USB 存储、SAS 等） |
| */dev/md** | md(4) | 内存磁盘 |
| */dev/mmcsd** | mmcsd(4) | MMC 和 SD 存储卡 |
| */dev/nvd** | nvd(4) | NVM express 驱动 |
| */dev/vtbd** | virtio_blk(4) | 基于 Virtio 的虚拟机磁盘 |
| */dev/xbd** | xen(4) | Xen 虚拟磁盘 |

许多 RAID 控制器将它们的 RAID 容器呈现为 SCSI 设备，因此它们显示为 */dev/da* 设备节点。其他一些则将它们的磁盘呈现为“带有特殊厂商标识的 SCSI”，因此它们会有特别的设备节点名称，如 */dev/raid*（ATA RAID）、*/dev/mfid*（某些 LSI MegaRAID 卡）等。查看你 RAID 控制器的 man 页面，了解它所呈现的设备节点。

### **通用访问方法**

*通用访问方法（CAM）* 是一种标准化的设备驱动架构，最初是为了支持 20 世纪的 SCSI-2 磁盘的复杂命令集而编写的。其理念是，基于这种架构的标准化将简化设备驱动程序的编写。然而，实际上只有 FreeBSD 和 DEC OSF/1 配备了 CAM，并且每个操作系统都以不同的方式填补了规范中的空白。

FreeBSD 9 及之后的版本将支持 CAM 的所有物理磁盘的管理整合到了 CAM 接口中。使用 camcontrol(8) 从磁盘收集信息并向其发出命令。camcontrol(8) 命令有多种子命令，可以向硬盘发出指令。

#### ***你有什么磁盘？***

要识别主机的存储设备，你可以扫描 */var/run/dmesg.boot* 查找磁盘设备节点，或者查看挂载的文件系统并从中倒推。但识别存储设备的最简单方法是让 camcontrol(8) 查询 CAM 系统，看看它识别出了哪些磁盘。让我们看一下我的一台测试系统：

```
# camcontrol devlist
<ATA WDC WD1003FBYZ-0 1V03>        at scbus0 target 0 lun 0 (pass0,da0)
<ATA WDC WD1003FBYZ-0 1V03>        at scbus0 target 1 lun 0 (pass1,da1)
<ATA WDC WD1003FBYZ-0 1V03>        at scbus0 target 2 lun 0 (pass2,da2)
<ATA WDC WD1003FBYZ-0 1V03>        at scbus0 target 3 lun 0 (pass3,da3)
```

该输出分为三个字段。第一个字段给出了设备的名称，由设备本身报告。通常是厂商和厂商的型号。

第二部分给出了 SCSI 连接信息。这些驱动器实际上并不是 SCSI 驱动器——它们是通过 CAM 管理的 SATA 连接。但现在你知道哪些磁盘设备插入了 SATA 控制器的哪个端口。

最后，在括号中，我们有 SCSI 设备和我们可能需要的存储设备节点。这个主机有四个磁盘，分别命名为 da0、da1、da2 和 da3。

#### ***非 CAM 设备***

一般来说，除了专有的 RAID 控制器和虚拟磁盘外，其他都支持 CAM。

RAID 控制器通常已经拥抱并扩展了 CAM 协议，出于制造商当时认为合理的原因。一个在 1990 年代初期编写的协议对于 2010 年的 RAID 控制器来说已经不够用了。这些控制器通常有自己的控制程序。RAID 容器会出现在 `devlist` 和其他 camcontrol(8) 子命令中。

同样，虚拟磁盘不会响应 CAM 命令。那里没有磁盘可供操作——你只是在文件中写入数据块。你可以通过 `camcontrol devlist` 查看磁盘，但就仅此而已。

对于大多数应用，我推荐使用 FreeBSD 的 RAIDZ 或 GEOM RAID，而不是硬件 RAID 控制器。

### **GEOM 存储架构**

FreeBSD 拥有一个极其灵活的存储基础设施系统，称为 *GEOM*（即“磁盘几何”）。GEOM 位于设备驱动程序节点与底层硬件之间，处理它们之间交换的数据。从这个位置，GEOM 可以任意转换输入/输出请求。

**设备控制程序**

一些存储设备具有特殊功能，这些功能在通用 CAM 框架中并未涵盖。RAID 控制器通常具有厂商特定的功能，FreeBSD 包含许多小程序来单独管理这些控制器。你会发现像 mfiutil(8) 和 mptutil(8) 用于较旧的 LSI 控制器，mpsutil(8) 用于较新的 LSI 控制器，等等。如果你有非易失性存储器高速缓存（NVMe）驱动器，可以查看 nvmecontrol(8)。

GEOM 是由内核模块构建的，称为 *GEOM 类*，它们让你执行特定类型的转换或管理。磁盘有一个 GEOM 类，允许内核将数据写入磁盘。但如果你想加密你的磁盘，那也是一个 GEOM 类。基于软件的 RAID？一个 GEOM 类。FreeBSD 将所有存储修改实现为 GEOM 类。

GEOM 类是 *可堆叠* 的。它们使用一个类的输出作为另一个类的输入。如果你想加密硬盘，然后将其镜像到另一个硬盘？当然可以！在硬盘上堆叠一个加密模块，然后再堆叠一个驱动器镜像模块。你想将那个驱动器跨网络镜像？把那个 GEOM 类加到堆栈中。这种灵活的模块化使得 GEOM 成为 FreeBSD 最强大的特性之一。

#### ***GEOM 自动配置***

当 FreeBSD 发现新存储设备时，无论是在启动时还是插入新硬盘时，GEOM 子系统会检查该设备是否包含已知的格式，比如主引导记录、BSD 磁盘标签或其他元数据。GEOM 还会检查物理标识符，如磁盘的序列号。这被称为 *品尝*。

当 GEOM 发现标识信息时，它会根据该元数据的指示配置设备。如果磁盘的元数据说，“我是名为 *garbage* 的镜像的一部分，和另外两块磁盘一起，”GEOM 会寻找其他磁盘并组装镜像。如果 GEOM 能通过格式、标签或其他信息识别存储设备，它会启动该设备，启动一个 GEOM 类实例，创建适当的设备节点，并执行任何它理解的其他配置。

如果 GEOM 无法识别磁盘上的其他元数据，例如在未格式化且未分区的磁盘上，GEOM 会为该存储设备创建设备节点并保持原样。

GEOM 类的实例称为 *geom*。gmirror(8) 类让磁盘彼此镜像，但名为 *garbage* 的特定镜像磁盘对就是一个 geom。该镜像中的每个磁盘也是一个 geom。

#### ***GEOM 与卷管理器***

传统的卷管理器期望你按它们的方式做事，无论这对你的环境和硬件是否合理。如果卷管理器说你通过加密单个驱动器并在其上进行镜像来创建加密的磁盘镜像，那么你就必须这么做。或许在你的环境中，先镜像驱动器然后加密它们更合适，但如果这不是卷管理器的做法，那也没办法。更糟糕的是，一些卷管理器做出糟糕的选择，然后通过旁路方式修复这些选择，以最小化这些决策的后果。

GEOM 与卷管理器的不同之处在于，它假设你知道自己在做什么。它给你灵活性，让你以最适合硬件并能为你的用例带来好处的方式安排存储。GEOM 类让你可以轻松地将新的数据转换功能插入到存储中。而你不能在商业卷管理器中加入加密层之类的功能。

卷管理器涵盖了它们设计时硬件中最常见的情况。然而，随着时间的推移，这些常见的情况变得越来越不常见。人们继续使用卷管理器，即使它们最初为已经过时的硬件设计。GEOM 让你随着硬件、环境和应用程序的变化，演化你的设计。

FreeBSD 包含了两个看起来很像卷管理器的软件套件：gvinum(8) 和 ZFS。Vinum 是 1990 年代的 FreeBSD 卷管理器，尽管 gvinum(8) 重新实现了它作为 GEOM 类，但强烈不建议使用它。ZFS 非常强大，正如我们在第五章中看到的，但它确实有卷管理器的“按我们的方式做事”的理念。

虽然理论上你可以永远堆叠 GEOM 模块，但你必须考虑硬件资源。通过网络镜像一个繁忙的磁盘可能需要专用的网络接口和空闲的交叉连接电缆。加密和解密数据会消耗处理器时间和内存。GEOM 不会阻止你对磁盘进行过度操作；它只是为你提供了进行这些操作的新机会和有趣的可能性。

#### ***提供者、消费者和分割器***

各个 geom 要么是消费者，要么是提供者，或者两者兼具。

一个 *提供者* 为另一个 geom 提供服务。如果你正在镜像两个硬盘，硬盘的 geom 提供磁盘给镜像使用。一个提供者通常具有一个设备节点，比如 */dev/ada1p1*。

一个 *消费者* 使用提供者的服务。磁盘镜像 geom 消耗底层磁盘驱动器。一个 geom 的消费者部分不需要设备节点。

一个 geom 可以既是提供者又是消费者——实际上，堆栈中间的每个 geom 必须既是提供者又是消费者。磁盘镜像 geom 消耗底层的物理存储介质，但它为文件系统提供了一个镜像磁盘。

FreeBSD 对待所有提供者和消费者的方式是相同的。一个物理硬盘只是另一个提供者，就像镜像、加密层或网络导入一样。这一特点使得你可以任意堆叠 GEOM 类。

一个将一个类细分为多个子类的 GEOM 类称为 *切片器*，通常负责管理分区。处理主引导记录（MBR）分区的 GEOM 类是一个切片器，GUID 分区表（GPT）类也是如此。我们在第二章中讨论了这两种分区方法，在本章中我们将进一步探讨这两种方法。切片器必须确保磁盘分区不重叠，并且分区符合分区方案的规则。

#### ***GEOM 控制程序***

许多 GEOM 类都有一个控制程序，让你管理模块或查询设备。一些广泛使用的类使用 geom(8)，而其他类使用如 gmirror(8) 或 geli(8) 之类的程序。*disk* GEOM 类与物理存储介质进行通信，并为上层提供消费者。这是一个非常常用的类。在这里，我查询主机以查看它具有的 *disk* 类型的 geoms，并打印出磁盘提供给操作系统的信息。

```
   $ geom disk list
➊ Geom name: da0
   Providers:
   1\. Name: da0
    ➋ Mediasize: 1000204886016 (932G)
    ➌ Sectorsize: 512
    ➍ Mode: r2w2e3
    ➎ descr: ATA WDC WD1003FBYZ-0
    ➏ lunname: ATA   WDC WD1003FBYZ-010FB0            WD-WCAW36478143
    ➐ lunid: 50014ee25e60dab5
    ➑ ident: WD-WCAW36478143
    ➒ rotationrate: 7200
    ➓ fwsectors: 63
       fwheads: 255
```

该硬盘提供一个名为 da0 ➊ 的磁盘设备。*mediasize* 字段提供其大小（以字节为单位），并将其转换为更便捷的 932GB ➋。

该磁盘声称其 *扇区大小* 为 512 字节 ➌。许多磁盘会虚报其扇区大小。请查看硬盘制造商的文档，以确定实际的扇区大小。驱动器可能会提供 *Stripesize* 值 4,096，表示它们实际上是 4K 驱动器。

一个 GEOM 类的 *mode* 看起来非常像文件权限 ➍，但它实际上是读取（r2）和写入（w2）设备的 GEOM 类的数量，以及请求独占访问设备的设备的数量（e3）。

*descr* 字段 ➎ 提供驱动器的型号。

*lunname* 字段 ➏ 提供型号和序列号。是的，它是 *descr* 和 *ident* 字段的组合。硬盘确实很希望你相信这就是它的名称和标识符。

*lunid* ➐ 提供逻辑单元号（LUN）标识符，描述此驱动器如何连接到此主机。

磁盘的 *ident* ➑ 是驱动器的序列号。

*rotationrate* ➒ 告诉我们该驱动器的旋转速度。它是一个 7,200 RPM 磁盘。非旋转磁盘，如 SSD，其 rotationrate 为 0。

*fwsectors* 和 *fwheads* 字段 ➓ 提供磁盘几何信息。这些是本章开头提到的谎言的例子。即使是 SSD 也会提供这些值。

一些驱动器提供较少的信息。虚拟磁盘几乎不提供任何信息，而且它们提供的任何信息都不可信。（尽管虚拟机系统可能会说该磁盘提供 32,212,254,720 个 512 字节扇区，但谁知道虚拟磁盘下方的实际磁盘是什么样子呢？）

#### ***GEOM 设备节点和堆栈***

许多系统管理员工具期望在磁盘或磁盘分区上运行。类 Unix 系统提供磁盘和分区作为设备节点。GEOM 提供设备节点，以确保这些工具保持兼容性。

大多数活跃的 GEOM 模块在*/dev/*下都有自己的目录。该目录中的设备节点表示该模块当前的提供者。该目录通常（但不总是）以使用该模块的 GEOM 模块命名。例如，gmirror(8)类使用*/dev/mirror*。

目录名称可能会更改，以避免歧义或重叠。*glabel（GEOM 标签）*类使用*/dev/label*。*/dev/gpt*目录包含存储在 GPT 分区上的标签，而*/dev/gptid*目录包含与 GPT 分区相关的数字标识符。

一些类不会创建目录，而是附加到现有设备上。gnop(8)类会在附加的节点旁边创建一个新的节点，但会在设备名称末尾附加*.nop*。

### **硬盘、分区和方案**

虽然我们在第九章中讨论了分区，但请从磁盘驱动器的角度考虑分区。我们第一个 SATA 控制器上的第一个可能的 SATA 磁盘叫做*/dev/ada0*。后续的磁盘分别是*/dev/ada1*、*/dev/ada2*，依此类推。如果你还拥有 SAS 磁盘，它们的编号将从 0 开始。

磁盘被进一步划分为*分区*。即使是运行 Microsoft 操作系统的普通消费级系统，其硬盘上也通常会有多个分区。系统管理员将巨大的磁盘阵列划分为更小、更易于管理的单元，具有特定用途——或者他们也可能采取相反的做法，将多个磁盘合并为一个庞大的分区。

*分区方案*是用于组织磁盘分区的系统。传统的主引导记录（MBR）是一种分区方案。旧的苹果和 SPARC 硬件有它们自己的分区方案。今天，大多数硬件和操作系统使用的方案是*GUID 分区表（GPT）*。每种方案都有其对引导块、硬件架构和分区的要求。本书讨论了 MBR 和 GPT 方案，但你应该意识到其他方案也存在。

每个磁盘分区都会获得自己的设备节点，这些设备节点是通过在底层设备节点名称末尾添加内容来创建的。在这里，我查看了一个默认的 FreeBSD 安装，使用 UFS 格式在虚拟磁盘上进行的设备节点：

```
# ls /dev/vtbd0*
/dev/vtbd0      /dev/vtbd0p1    /dev/vtbd0p2    /dev/vtbd0p3
```

我们有一个磁盘本身的设备节点，然后还有三个其他设备节点，分别以 p1、p2 和 p3 结尾。那些子分区是什么？*p*表示它们是 GPT 分区。在默认安装中，p1 是引导分区，p2 是交换空间，p3 是主文件系统。

每个分区方案都有自己独特的设备节点扩展。我们将在本章后面阅读到这些内容。

### **文件系统表：/etc/fstab**

FreeBSD 像大多数类 Unix 操作系统一样，使用文件系统表*/etc/fstab*将磁盘上的分区映射到文件系统和交换空间。虽然 ZFS 不使用*/etc/fstab*，但其他所有 FreeBSD 文件系统都可以出现在其中。每个使用中的分区都会出现在单独的一行上，并附有挂载和管理指令。

```
/dev/gpt/rootfs  /       ufs     rw  2  1
/dev/gpt/swapfs  none    swap    sw  0  0
proc             /proc   procfs  rw  0  0
```

第一个字段给出了 GEOM 提供者的名称。这可能是一个物理磁盘分区，例如 */dev/ada0p1*，或者可能是一个 GEOM 设备节点的分区。这里的前两行提供了 */dev/gpt* 下的设备节点。这是 GPT 标签，我们将在本章稍后看到。我们的第三项列出了 *proc*，而不是设备节点：它是 procfs(5) 虚拟文件系统，我们将在 第十三章 中详细讨论。

第二个字段给出了文件系统可用的目录，称为 *挂载点*。每个可以读写文件的分区都会附加到一个挂载点，例如 */usr*、*/var* 等等。一些特殊的分区，例如 swap 空间（这里是第二行），其挂载点为 none。因为它们没有连接到目录树，且系统在交换时会覆盖这些文件，所以你不能在 swap 空间上读写文件。

接下来，我们来看文件系统类型。第一行显示的是 *ufs* 类型，或者说是 Unix 文件系统。第二行定义为 *swap* 空间，而第三行是 *procfs* 类型。其他类型包括 *cd9660*（CD 光盘或映像）、*nfs*（网络文件系统挂载）和 *ext4fs*（Linux 文件系统）。文件系统表告诉 FreeBSD 如何挂载这个分区。第十三章讨论了其他文件系统。

第四个字段显示了用于此特定分区的 mount(8) 选项。每个文件系统都有其自己的挂载选项，但这里列出了一些多个文件系统都使用且经常出现在 */etc/fstab* 中的选项：

**ro** 文件系统以只读方式挂载。连 root 用户也不能对其进行写操作。

**rw** 文件系统以读写方式挂载。

**noauto** FreeBSD 不会自动挂载文件系统，无论是在启动时还是在使用 `mount -a` 时。这个选项对于可能在启动时没有介质的可移动媒体驱动器非常有用。

第五个字段用于告诉 dump(8) 需要哪个备份级别来备份这个文件系统。现在，dump 已经基本过时；人们使用 tar(1) 进行文件级备份，或者使用更先进的备份软件，如 Bacula (*[`www.bacula.org/`](http://www.bacula.org/)*) 或 Tarsnap (*[`www.tarsnap.com/`](https://www.tarsnap.com/)*）。

最后一个字段告诉 FreeBSD 启动过程在何时检查文件系统的完整性。所有具有相同编号的分区会与 fsck(8) 一起并行检查。根文件系统标记为 1，意味着它是第一个被检查的。只有根文件系统应该标记为 1，任何其他分区应该标记为 2 或更高，意味着它们稍后会被检查。交换分区、只读介质和逻辑文件系统不需要完整性检查，因此它们会设置为 0。

FreeBSD 在启动时配置所有在 */etc/fstab* 中找到的文件系统。然而，随着系统运行，系统管理员可以挂载其他文件系统，并且她也可以卸载那些列在其中的文件系统。这就引出了我们的下一个问题……

### **现在挂载的是什么？**

如果不是所有的文件系统在启动时都被自动挂载，并且如果系统管理员可以添加和移除挂载的文件系统，如何确定当前已挂载的文件系统呢？使用 mount(8)命令，不带任何选项，可以查看所有挂载的文件系统。

```
# mount
/dev/gpt/rootfs on / (ufs, local, journaled soft-updates)
devfs on /dev (devfs, local, multilabel)
```

这是一个小型的基于 UFS 的主机。它只有一个磁盘分区和一个 devfs(5)实例（参见第十三章）。*local*一词意味着该分区位于连接到此计算机的硬盘上。日志化软更新选项是 UFS 的一个特性，我们将在第十一章中讨论。如果你正在使用 NFS 或 SMB 来挂载分区，它们会出现在这里。

更复杂的主机会产生更大的结果：

```
# mount
base/ROOT/default on / (zfs, local, noatime, nfsv4acls)
base/tmp on /tmp (zfs, local, noatime, nosuid, nfsv4acls)
base/usr/home on /usr/home (zfs, local, noatime, nfsv4acls)
base/usr/ports on /usr/ports (zfs, local, noatime, nosuid, nfsv4acls)
procfs on /proc (procfs, local)
devfs on /dev (devfs, local, multilabel)
--snip--
```

该主机使用多个 ZFS 数据集，每个数据集都有自己的挂载点。mount(8)命令的输出显示了选定的 ZFS 选项，例如 noatime 和 nfsv4acls。

在输出的最后，我们有一个 procfs(5)条目和一个 devfs(5)挂载条目。一个正常工作的 FreeBSD 系统需要在*/dev*挂载 devfs，否则它的运行将不太顺利，或者根本无法长时间工作。

### **磁盘标签**

在最低层次上，操作系统通过硬件与系统的物理连接来识别磁盘。传统上，文件系统表可能会写道：“将连接在 ATA 端口 3 的磁盘用作*/var/log*文件系统。”在硬件灵活性较差时，这种方法工作得很好，但随着硬件技术的发展，这种连接变得更加灵活。如果你根据物理连接来分配磁盘角色，有时这种连接会发生变化。我曾经有过多次主板在不合时宜的时刻爆炸，迫使我进行紧急替换。在这种情况下，追踪哪个电缆连接到哪个接口通常都会失败。在旧版本的 FreeBSD 中，你需要“固定”设备，使得特定的磁盘总是作为特定的设备节点出现。现在不再需要这样做。

今天，系统管理员使用磁盘上的*标签*来通过其他方式引用磁盘，而不是依赖于物理连接。标签标识了一个 geom 实例。与其告诉 FreeBSD*/var/www*在连接到 SATA 端口 2 的磁盘上，不如声明*/var/www*在标签为*website*的磁盘上。前者容易出错，而后者则大多能避免因为硬件技术人员的疏忽。一个磁盘可以同时有多个标签，只要它们是不同类型的标签。FreeBSD 会自动根据磁盘的固有特征推导出许多标签；系统管理员也可以定义其他标签。

大多数标签类型都有一个专门的设备节点目录。每个 GPT 分区都有一个*全局唯一标识符(GUID)*，这些分区的自动创建标签存储在*/dev/gptid*中。磁盘根据其序列号获得唯一的磁盘 ID，这些 ID 会出现在*/dev/diskid*中。手动创建的 GPT 标签出现在*/dev/gpt*中。

像使用其他设备名称一样使用这些标签。如果你将磁盘 ada5 标记为*stuff1*，你可以将磁盘 stuff 分区为*stuff1p1*和*stuff1p2*，并在配置文件中使用这些分区，等等。

不是所有标签都来自 GEOM。ZFS 使用自己内部的标签方法来标识文件系统和池。你还可以向 UFS 文件系统添加标签。

不要让交换的 SATA 电缆毁了你的周末。给所有东西加上标签。

#### ***查看标签***

使用 glabel(8)，即`geom label`的快捷方式来查看标签。以下是来自一个小型虚拟机的标签部分。实际硬件上的标签可能会变得非常复杂。

```
   $ glabel list
➊ Geom name: ada0p1
   Providers:
➋ 1\. Name: gptid/b9c0c7c5-5b66-11e7-8aec-080027739ff6
      Mediasize: 524288 (512K)
      Sectorsize: 512
   --snip--
➌ Consumers:
   1\. Name: ada0p1
      Mediasize: 524288 (512K)
      Sectorsize: 512
      Stripesize: 0
      Stripeoffset: 20480
      Mode: r0w0e0
```

这个主机在磁盘分区*/dev/ada0p1*上有一个单一的 GEOM ➊。它提供了一个基于 GPT 分区 ID ➋的非常长的标签。我们将在底层磁盘上看到一些信息，例如磁盘上的扇区数量、扇区大小以及你可能在`geom` `disk list`输出中看到的其他信息。然而，这些信息来自于分区。物理驱动器信息是从底层磁盘传递上来的。^(1)

这个驱动器有一个单一的消费者 ➌，即实际的底层分区。我们处于这个简单 GEOM 堆栈的最底层，紧贴磁盘，因此它正在自我消费。如果你添加了加密层或软件 RAID，你将看到该 GEOM 消费的其他设备。

#### ***示例标签***

以下是你在大多数 FreeBSD 系统上看到的标签类型的示例。

##### **磁盘 ID 标签**

物理机器提供虚拟机无法获得的标签。

```
Geom name: ada3
Providers:
1\. Name: diskid/DISK-WD-WCAW36477141
--snip--
```

驱动器 ada3 提供了一个名为*diskid/DISK-WD-WCAW36477141*的 GEOM。*diskid* GEOM 以硬盘的序列号命名，基于硬盘提供的信息。你可以将磁盘从这台机器上取下，并将其连接到完全不同的 FreeBSD 主机上，新的主机将生成完全相同的磁盘 ID 标签。在配置中使用 diskid 标签可以确保 FreeBSD 使用你打算使用的确切磁盘。以下是在*/etc/fstab*中列出该磁盘分区 3 的方式：

```
/dev/diskid/DISK-WD-WCAW36477141p3 /usr/local ufs rw 2 2
```

这个磁盘可以作为*/dev/ada3*或*/dev/ada300*连接到主机，FreeBSD 仍然会将该分区挂载为*/usr/local*。

磁盘 ID 标签的问题在于它们难以阅读，也更难输入。我之所以提到它们，是因为它们可能是默认出现的，但我鼓励你选择其他标签。通过在*/boot/loader.conf*中将可调项`kern.geom.label.disk_ident.enable`设置为 0，来从你的主机中移除这些标签。

##### **GPT GUID 标签**

每个 GPT 分区都包括一个 GUID。FreeBSD 可以将 GUID 视为标签。在这里，我们看到了附加为 ada0 的磁盘上分区 1 的 GPT ID 标签：

```
   Geom name: ada0p1
   Providers:
➊ 1\. Name: gptid/075e7b89-30ed-11e7-a386-002590dbd594
   --snip--
```

这个磁盘分区可以方便地表示为*/dev/gptid/075e7b89-30ed-11e7-a386-002590dbd594* ➊。类似于磁盘序列号，GUID 是分区的一部分。你可以将磁盘移动到另一台主机，仍然能够获得相同的 GPT ID。通过在像*/etc/fstab*这样的配置文件中使用 GPT ID 标签，可以确保 FreeBSD 在系统启动时使用这个特定的分区，而不是分区 1，无论哪个设备被分配到 ada0。

使用 GPT ID 标签在你有多个自动配置磁盘时很有意义，例如大型存储阵列。然而，在较小的系统中，128 位的 GUID 过长，令人烦恼。如果你决定不使用这些标签，可以通过将可调参数 `kern.geom.label.gptid.enable` 设置为 0，在 */boot/loader.conf* 中将它们从系统中移除。

对于大多数主机，我建议分配 GPT 标签。

##### **GPT 标签**

GPT 分区允许你在分区表内手动分配标签名称。我强烈建议在可能的情况下这么做。这里是我分配了名称的一个分区：

```
   Geom name: ada2p1
   Providers:
➊ 1\. Name: gpt/swap2
   --snip--
```

我已经为磁盘 ada2 上的分区 1 分配了标签 *swap2* ➊。这个标签物理存储在磁盘分区上。我可以像使用其他设备名称一样在配置中使用这个标签。对于小型系统来说，使用手动分配的标签更加可管理，如这个 */etc/fstab* 所示：

```
/dev/gpt/swap2  none  swap  sw  0  0
```

一个分配的标签比长串的序列号或 GUID 更加人性化。如果可以选择，我建议你为 GPT 分区分配标签。我们在分区时会分配标签。

##### **GEOM 标签**

除了在系统上显示标准标签外，glabel(8) 命令还允许你配置 GEOM 标签。GEOM 标签是特定于 FreeBSD GEOM 基础架构的，并出现在 */dev/label* 中。使用 `glabel label` 命令来管理 GEOM 标签。这里，我将 GEOM 标签 *root* 应用到 GPT 分区 da0p1 上：

```
# glabel label da0p1 root
```

还有一个 `glabel create` 命令，但这些标签在系统重启时会消失。

### **GEOM 枯萎**

一个提供者可以有多个标签。一个分区可能有基于底层存储设备的磁盘 ID（*/dev/diskid/somethinglong*）、GPT ID（*/dev/gptid/somethingevenlonger*）、手动分配的标签（*/dev/gpt/swap0*）以及基于底层设备附件点的设备节点（*/dev/ada0p1*）。虽然多个进程可以同时查看磁盘设备，但许多磁盘操作——例如挂载分区——需要独占的设备控制。

为了防止通过多个名称访问 geoms，当你通过一个标签访问设备时，内核会移除未使用的标签。这被称为 *枯萎*。例如，如果我通过 GPT 标签 */dev/gpt/swap0* 挂载一个交换分区，那么该分区的所有其他标签都会从 */dev* 中消失。任何尝试访问相应 */dev/gptid* 分区的人会发现该设备节点丢失。

一旦设备上的所有独占锁定被移除，内核会恢复其他设备标签的显示。如果我停用了交换空间，GPT ID 和原始设备名称会重新出现。

### **gpart(8) 命令**

像许多操作系统一样，FreeBSD 曾经为每种分区方案提供专门的分区工具。今天，所有的磁盘分区功能，无论是 MBR 还是 GPT，都包括在 gpart(8) 程序中。对于嵌入式设备，可能偶尔需要像 fdisk(8) 和 bsdlabel(8) 这样的旧工具，但 gpart(8) 对服务器和桌面系统完全适用。

这个常用工具意味着无论你使用的是哪种分区方案，都能以相同的方式执行许多操作。例如，无论你使用 MBR 还是 GPT 方案，都需要一种方法来指示特定的分区。两种方案都允许你通过 `-i` 和分区号来指示一个分区。

查看和删除分区是常见功能的很好示例。

#### ***查看分区***

使用 `gpart show` 可以查看 geom 上所有 GPT 和 MBR 分区的简要概览。通过提供 geom 的名称作为参数，可以仅查看该 geom 上的分区。`gpart show` 的输出与 fdisk(8) 和其他传统磁盘管理工具的输出没有太大区别。在这里，我通过传统的设备节点查看存储设备，但我也可以使用 diskid、gptid 或任何其他标签：

```
   $ gpart show ada0
➊ =>        40  1953525088  ada0  GPT  (932G)
➋           40        1024     1  freebsd-boot  (512K)
➌         1064         984        - free -  (492K)
➍         2048     4194304     2  freebsd-swap  (2.0G)
➎      4196352  1949327360     3  freebsd-zfs  (930G)
➏   1953523712        1416        - free -  (708K)
```

第一列给出了分区的第一个块；第二列是分区的大小（以块为单位）。第三列是分区号，第四列是分区类型。（我们将在本章后面讨论分区类型：目前，先按流程进行。）最后，我们给出了磁盘大小。

我们的第一个分区从磁盘的第 40 个扇区开始，填充了将近 20 亿个扇区 ➊。第三个字段显示这不是磁盘上的一个分区，而是整个磁盘的条目。第四个字段给出了使用的分区方案。这是一个 GPT 磁盘。整个磁盘大约为 932GB。

第二个条目也从第 40 扇区开始，填充了 1,024 个扇区 ➋。这是分区 1，类型是 *freebsd-boot*。如果我们想从这个磁盘启动，则需要在此分区上安装引导加载程序。

第三个条目从第 1,064 扇区开始，填充了 984 个扇区 ➌。为什么是 1,064？第一个分区从第 40 扇区开始，填充了 1,024 个扇区，因此前 (1,024 + 40) 1,064 个扇区已被其他分区占用。但这个分区没有分区号，其类型是 `- free -`。这个分区为 4K 扇区的磁盘进行了对齐。

第四个条目是交换空间，根据分区类型 ➍。它从第 2,048 扇区开始，长度为 4,194,304 个扇区，是分区 2。你通常会看到交换空间位于磁盘的前面，这是过去分区放置对性能有影响的遗留物。然而，如果你使用的是虚拟机，将交换空间放在磁盘的前面可以为你在磁盘末尾扩展分区留下空间。

第五个条目是 FreeBSD ZFS 文件系统，从第 4,196,352 扇区开始，占用大约 19 亿个扇区 ➎。这个 freebsd-zfs 分区包含我们的数据。

磁盘的最后部分有 1,416 个空闲扇区 ➏。空间不足以在对齐到 1MB 边界的同时增加分区的空间。

MBR 磁盘看起来与 GPT 磁盘非常相似。

#### ***其他视图***

添加命令行标志来修改 `gpart show` 的输出。

你可以通过底层设备名称和分区编号来组装每个分区的设备节点。如果你想看到设备节点而不是分区编号，可以添加`-p`标志。

要用分区标签替代分区类型，请使用`-l`。

在这里，我展示了这个磁盘的设备节点和标签：

```
$ gpart show -pl ada0
=>        40  1953525088    ada0  GPT  (932G)
          40        1024  ada0p1  gptboot0  (512K)
        1064         984          - free -  (492K)
        2048     4194304  ada0p2  swap0  (2.0G)
     4196352  1949327360  ada0p3  zfs0  (930G)
  1953523712        1416          - free -  (708K)
```

现在，分区编号包含完整的设备名称，比如*ada0p3*。你不再看到 GPT 分区类型，而是看到应用于 GPT 分区的标签，例如*swap0*和*zfs0*。

要查看人类不友好的 GPT 分区类型，而不是 FreeBSD 显示的名称，请使用`-r`。我通常在检查其他操作系统的磁盘时使用它。FreeBSD 可能会将多个分区类型标记为*ntfs*；虽然这对大多数用途来说足够，但如果我在做数字取证，精确的分区方案可能非常重要。

要查看 GPT 分区的更详细描述，请使用`gpart list`。这会产生类似于`glabel list`或其他 GEOM 类命令的输出。

#### ***删除分区***

也许你在创建分区时出错，需要删除其中一个。不是的，你还没有在 MBR 或 GPT 中创建分区，但你遵循的过程无论哪种方式都是一样的。通过编号删除分区。

查看上一节中的分区表。我们有用于启动、交换和 ZFS 的分区。也许你不希望在启动磁盘上有交换空间。使用 gpart delete 命令删除该分区。使用`-i`标志和你想删除的分区编号。gpart show 命令显示交换空间是分区 2。让我们删除它。

```
# gpart delete -i 2 ada0
ada0p2 deleted
```

现在你可以调整 ZFS 分区的大小以使用这些空间。调整分区大小的方式取决于分区方案。

### **设计磁盘**

不，这不是那种故意欺骗你的磁盘。我们谈论的是磁盘的分区方案。在现实世界和存储中，摧毁比创建更容易。在你能够分区磁盘之前，你需要为它分配一个分区方案。

#### ***删除磁盘分区方案***

你可以逐个删除磁盘上的每个分区，然后摧毁分区方案。然而，这样做工作量很大。更简单的方法是直接丢弃整个磁盘分区表。

你不能擦除带有已挂载分区的磁盘。首先卸载这些分区，并从任何 ZFS 池中删除它们。一旦磁盘真正未使用，使用`gpart destroy`擦除任何现有的分区表。

```
# gpart destroy da3
da3 destroyed
```

如果命令立即返回，说明磁盘没有分区。它可能有一个分区方案，但没有分区。如果你遇到“设备繁忙”错误，要么磁盘仍在使用中，要么磁盘有分区。你可以通过`gpart delete`逐个删除所有现有分区，然后销毁分区方案，但通过添加`-F`更容易彻底删除现有方案。

```
# gpart destroy -F da3
```

这会强制擦除所有分区和分区方案。运行 `gpart show da3` 将显示没有分区表。现在可以创建新的磁盘分区。

#### ***分配分区方案***

在创建磁盘分区之前，您需要标记磁盘所使用的分区方案类型。使用 `gpart create` 命令并加上 `-s` 标志和方案类型，如 `gpt` 或 `mbr`。在这里，我将磁盘标记为使用 GPT 方案：

```
# gpart create -s gpt da3
```

使用 `gpart show` 验证磁盘现在是否有 GPT 分区表。现在可以添加 GPT 分区，或重新创建分区表并使用 MBR 添加这些分区。但我们将从深入了解 GPT 开始。

### **GPT 分区方案**

GUID 分区表（GPT）是现代硬盘分区的标准。这是新安装的推荐标准。除非有非常强烈的理由不使用，比如硬件不支持，否则总是使用 GPT 分区方案。

GPT 支持最大 9.4ZB 的磁盘。1 ZB 等于 10 亿 TB。尽管我们的技术最终会超越 9.4ZB，但我预计 GPT 将持续到我职业生涯的最后。

FreeBSD 的 GPT 实现目前支持 128 个分区。每个分区都会分配一个 GUID，它是一个 128 位的数字，以 32 个十六进制字符显示。虽然 GUID 并不保证在整个文明范围内真正唯一，但它们在你的组织内肯定是唯一的。

大多数现代操作系统支持 GPT 及其前身——主引导记录（MBR）。基于 MBR 的系统将分区记录存储在硬盘的第一个扇区。如果主机仅支持 MBR，但磁盘的第一个扇区包含不是 MBR 的内容，系统会感到困惑，可能会拒绝启动。GPT 方案将 *保护性主引导记录（PMBR）* 放置在每个磁盘的第一个扇区。PMBR 表示磁盘包含一个类型为 GPT 的 MBR 分区。第二个扇区包含实际的 GUID 分区表。GPT 还在磁盘的最后一个扇区放置了分区表的备份副本，以便更轻松地恢复损坏的数据。

GPT 需要为引导代码分配一个分区。PMBR 启动代码会搜索磁盘上的 FreeBSD 启动分区。这个启动分区必须大于引导代码，小于 545KB，并且保留给 FreeBSD 启动加载程序。FreeBSD 有两个 GPT 启动加载程序，gptboot(8) 和 gptzfsboot(8)。必须在启动分区上安装其中一个。

使用 gptboot(8) 启动基于 UFS 的系统。在系统启动时，gptboot 会搜索标记为 *bootme* 或 *bootonce* 属性的 FreeBSD 分区。

在运行 ZFS 的系统上使用 gptzfsboot(8)。

使用 gpart(8) 及其众多子命令来查看、创建、编辑和销毁 GPT 分区。

#### ***GPT 设备节点***

每个磁盘分区都有一个设备节点。GPT 分区的设备节点是它们所在 geom 的扩展，由字母 *p* 和分区编号表示。如果你直接在磁盘 ada0 上创建 GPT 分区，第一个分区将是 */dev/ada0p1*，第二个是 */dev/ada0p2*，依此类推。

许多系统将它们的分区放在上层的 geom 上。我有一个系统使用 SATA RAID，并将磁盘呈现为 */dev/raid/r0*。这个磁盘上的分区分别是 */dev/raid/r0p1*、*/dev/raid/r0p2* 等等。你也可能通过 GUID 或磁盘 ID 将分区放到一个设备上，从而获得像 */dev/diskid/DISK-WD-WCAW36477062p1* 这样的分区。

#### ***GPT 分区类型***

当你创建 GPT 分区时，必须为其标记一个 *分区类型*。该类型表示分区的预定用途。FreeBSD 会根据分区类型做出决策，因此要正确分配它们。

严格来说，分区类型是另一个 128 位的 GUID。FreeBSD 使用感叹号标记作为分区类型的 GUID，例如 `!516e7cb5-6ecf-11d6-8ff8-00022d09712b`。这些分区类型在所有操作系统中都很常见，但大多数操作系统会为这些不适合人类阅读的 GUID 提供易于理解的名称。本书使用的是易于理解的名称；如需查看不适合人类的名称，请查阅 gpart(8)。

你在 FreeBSD 系统中最常见的分区类型包括以下几种：

**freebsd-boot** FreeBSD 引导加载程序

**freebsd-ufs** FreeBSD UFS 文件系统

**freebsd-zfs** FreeBSD ZFS 文件系统

**freebsd-swap** FreeBSD 交换分区

**efi** EFI 系统分区，用于从 EFI 启动

你可能还会看到这些 GPT 分区类型。在现代 FreeBSD 中不要使用它们，但知道它们的存在可能有助于你识别出这个奇怪的磁盘是什么，以及如何将其拆解。

**freebsd** 一个被分为 bsdlabel(8) 分区的 GPT 分区

**freebsd-vinum** 一个由 gvinum(8) 控制的分区

**mbr** 一个被细分为 MBR 分区的分区

**ntfs** 一个包含微软 NTFS 文件系统的分区

**fat16, fat32** 包含 FAT 文件系统的分区

要查看完整的已识别分区类型列表，请参见 gpart(8)。

#### ***创建 GPT 分区***

分区磁盘很简单：弄清楚你需要哪些分区，创建它们，然后就可以了。棘手的部分是如何使用你的分区。在创建分区之前，决定你将如何使用这个磁盘。你有多少空间？你希望如何划分？在开始创建分区之前，准确写下你想要实现的目标。

这里，我正在为 UFS FreeBSD 安装手动分区一个 1TB 的磁盘。它将需要一个 512KB 的引导分区（类型 *freebsd-boot*）和 8GB 的交换分区（类型 *freebsd-swap*）。其他分区将是 *freebsd-ufs* 类型：5GB 用于根分区，5GB 用于 */tmp*，100GB 用于 */var*，其余的用于 */usr*。我会为每个分区标明其预定的角色。

使用 gpart(8)创建分区。使用`-t`标志指定分区类型，`-s`指定大小，`-l`为新分区分配 GPT 标签。我将从 boot 分区开始。

```
# gpart add -t freebsd-boot -l boot -s 512K da3
da3p1 added
```

使用`gpart show`检查您的工作。加上`-l`标志查看 GPT 标签。

```
# gpart show -l da3
=>        40  1953525088  da3  GPT  (932G)
          40        1024    1  boot  (512K)
        1064  1953524064       - free -  (932G)
```

这个磁盘有一个分区，大小为 512K，标记为*boot*。命令执行成功。现在添加交换空间。

```
# gpart add -a 1m -t freebsd-swap -s 8g -l swap da3
da3p2 added
```

这个命令与添加 boot 分区的命令非常相似：我们指定分区类型、大小和标签。

等一下——这`-a 1m`是什么？`-a`标志允许您设置分区对齐方式，使您可以设置分区相对于磁盘起始位置的开始和结束位置。还记得在本章开始时我提到过，如果文件系统与 4K 磁盘的物理扇区不对齐可能会导致问题吗？`-a 1m`告诉 gpart 从磁盘的开始位置按 1MB 的偶数倍创建分区。正如我们在本章的第 215 页中“查看分区”部分看到的那样，分区 1 和分区 2 之间会有一些空白空间，但这没问题。这给您留出了空间，必要时可以更改该分区以支持 UEFI（请参阅本章后面部分的“统一可扩展固件接口和 GPT”）。

在创建 5GB 的根分区、*/tmp*分区和 100GB 的*/var*分区时，保持 1MB 对齐。

```
# gpart add -a 1m -t freebsd-ufs -s 5g -l root da3
da3p3 added
# gpart add -a 1m -t freebsd-ufs -s 5g -l tmp da3
da3p4 added
# gpart add -a 1m -t freebsd-ufs -s 100g -l var da3
da3p5 added
```

创建最后一个分区时，不要指定大小。这告诉 gpart 将该分区做得尽可能大。

```
# gpart add -a 1m -t freebsd-ufs -l usr da3
da3p6 added
```

您已分区，并且它已准备好进行安装。

#### ***调整 GPT 分区大小***

再想一想，也许创建一个巨大的*/usr*分区并不明智。一个大约 100GB 的*/usr*分区足以为操作系统文件提供足够的空间，同时为隔离的*/home*分区留出几百 GB 的空间。我信任大多数用户，但有些用户(2)可能会把*/dev/random*扔进文件，直到占满所有可用空间。在这里，我将调整*/usr*的大小，为*/home*创建空间。

使用`gpart resize`来更改分区的大小。您必须知道目标分区的分区编号。运行`gpart show da3`会告诉我们*/usr*是分区 6。使用`-i`标志和分区编号来调整分区大小。

```
# gpart resize -i 6 -s 100g -a 1m da3
da3p6 resized
```

运行`gpart show`以查看新的磁盘大小。

```
# gpart show da3
--snip--
   247465984   209715200    6  freebsd-ufs  (100G)
   457181184  1496343944       - free -  (714G)
```

这个磁盘在末尾有 714GB 的空闲空间。现在我们可以为所有麻烦的用户创建一个宽敞的*/home*分区。

每个分区都会分配特定的扇区。若分区两侧没有空闲空间，您无法增加分区的大小。尽管此示例磁盘在分区 6 之后有大量空闲空间，但您无法利用这些空间来增大分区 1 到分区 5 的大小。您必须删除并重新创建这些分区。

更改分区的大小不会更改该分区上文件系统的大小。缩小带有文件系统的分区会切断部分文件系统。增大分区大小不会扩展文件系统。UFS 和 ZFS 都有处理增大分区大小的工具，但你必须将此作为一个独立的过程来处理。

#### ***更改标签和类型***

你可以使用 `gpart modify` 命令修改 GPT 分区的类型或 GPT 标签。使用 `-i` 给出分区号，使用 `-l` 给出新的标签。在这里，我修改了磁盘 vtbd0 的分区 2 的 GPT 标签：

```
# gpart modify -i 2 -l rootfs vtbd0
```

类似地，使用 `-t` 更改分区的类型：

```
# gpart modify -i 2 -t freebsd-zfs vtbd0
```

磁盘的 GPT 表现在声明分区 2 的标签为 `rootfs`，并且类型为 *freebsd-zfs*。

#### ***在传统硬件上启动***

较旧的硬件期望在磁盘的开始处看到一个主引导记录（MBR），并且不会识别 GPT 分区表。FreeBSD 使用保护性 MBR（PMBR）为传统硬件提供一个可识别的分区表，并帮助该硬件启动 GPT 分区的磁盘。一个格式化为 GPT 的可启动磁盘需要同时拥有保护性 MBR 和 GPT 引导加载程序。

使用 `gpart bootcode` 命令和 `-b` 标志安装一个 PMBR。FreeBSD 提供了一个 PMBR，路径为 */boot/pmbr*。

```
# gpart bootcode -b /boot/pmbr da3
bootcode written to da3
```

这个磁盘将不再干扰那些寻找 MBR 的主机。

你还需要一个引导加载程序。UFS 主机需要 *gptboot* 引导加载程序，而 ZFS 主机需要 *gptzfsboot*。为了方便，FreeBSD 在 */boot* 目录中提供了每个引导加载程序的副本。这些副本不是磁盘上的引导加载程序，而是该版本 FreeBSD 所需的引导加载程序版本。使用 `-p` 标志将选定的引导加载程序安装到 `gpart bootcode`。使用 `-i` 选项告诉 gpart(8) 要将引导加载程序复制到哪个分区。我们在上一节使用的示例磁盘中，分区 1 的类型是 *freebsd-boot*，所以我们将使用该分区。

```
# gpart bootcode -p /boot/gptboot -i 1 da3
partcode written to da3p1
```

你可以将 `-p` 和 `-b` 合并为一个命令。

#### ***统一可扩展固件接口和 GPT***

*统一可扩展固件接口 (UEFI)* 是一种较新的标准，用于在不使用 BIOS 仿真的情况下启动 amd64 硬件。FreeBSD 10 及之后的版本支持早期的 UEFI 启动到 UFS，而 FreeBSD 11 能够从 UEFI 启动 ZFS。

UEFI 使用类型为 *efi* 的分区，该分区必须为 800KB 或更大。使用 `gpart create` 在新磁盘上创建一个 efi 分区。

```
# gpart create -s gpt da0
# gpart add -t efi -s 800K da0
```

FreeBSD 提供了一个 efi 分区，路径为 */boot/boot1.efifat*。使用 dd(1) 将其复制到新的引导分区。

```
# dd if=/boot/boot1.efifat of=/dev/da0p1
```

根据需要分区剩余的磁盘空间。

一个 efi 分区实际上是一个 FAT 文件系统，具有非常特定的目录层次结构。你可以挂载文件 *boot1.efifat* 并进行探索。

#### ***扩展 GPT 磁盘***

我们已经了解了如何扩展分区，但磁盘呢？扩展磁盘通常发生在虚拟主机上。扩展虚拟磁盘时，`gpart(8)`会抱怨磁盘的 GPT 无效。GPT 和 GEOM 在磁盘的第一个和最后一个扇区存储信息。扩展虚拟磁盘意味着添加扇区。新的最后一个扇区将是空的。使用`gpart recover`为最后一个扇区创建新的元数据块。

```
# gpart recover vtbd0
```

你现在可以在扩展后的虚拟磁盘上创建或扩展分区。

既然你已经掌握了 GPT 分区，我们来看看 MBR，看看为什么 GPT 似乎是一个如此重大的改进。

### **MBR 分区方案**

旧硬件或新但小型的硬件可能需要在其磁盘上使用主引导记录分区。Intel 风格的硬件已经使用 MBR 分区数十年，数百万个设备运行着各种操作系统都在使用它。MBR 方案仅适用于 2TB 或更小的磁盘。更大的磁盘必须使用 GPT 分区。

#### ***什么是主引导记录（MBR）？***

*主引导记录（MBR）*是一个文件，占据传统磁盘的前 512 字节，也称为*扇区 0*。MBR 包含分区信息和一个引导加载程序，允许 BIOS 找到操作系统。术语*MBR*可能指代磁盘上的实际第一个扇区或该格式使用的分区方案。

主引导记录描述了四个*主分区*，在 BSD 社区中称为*切片*。每个切片描述包括该分区包含的磁盘扇区和预计在该切片上使用的文件系统类型。如果一个磁盘上只有一个切片，MBR 仍然列出四个切片，但其中三个切片没有分配任何扇区。虽然 MBR 格式支持最多 20 个扩展分区的链表，但由于 BSD 标签的存在，FreeBSD 不需要这些扩展分区。

四个主切片中的一个被认为是活动的。当系统开机时，引导程序代码会查找活动切片并尝试引导它。

MBR 扇区还包含引导程序代码。你不需要专门为引导加载程序分配空间。在 FreeBSD 中，引导程序代码会查找并执行内核。FreeBSD 包括两个不同的引导加载程序，*mbr*和*boot0*。mbr 加载程序用于单操作系统主机。如果你在硬件上安装了多个操作系统，使用 boot0 加载程序——或者，最好是将主机专用于 FreeBSD，并将其他操作系统虚拟化。

切片的主要功能是包含一个 bsdlabel(8)分区。

#### ***BSD 标签***

BSD 出现的时间早于 MBR 或 IBM PC。BSD 使用自己独特的磁盘分区格式，称为 *disklabel*。现在磁盘标签变得更加常见，disklabel 也被称为 *BSD labels* 或 *bsdlabels*。（如果你想激起一场激烈的讨论，可以问一群 FreeBSD 开发者，哪种叫法更正确。）BSD 系统有多个分区，至少包括 */*（根目录），*/usr*，*/var*，*/tmp* 和交换空间，还有独立的分区用于系统执行的实际工作。

当 BSD 移植到 i386 平台时，它们本可以将磁盘改为使用 MBR 分区。通过扩展 MBR 分区，一个磁盘最多可以拥有 24 个分区。然而，disklabel 分区深嵌在内核中，通常位于没人敢碰的棘手地方。移植小组决定将 MBR 切片视为 BSD 磁盘，并使用 BSD disklabel 对每个切片进行分区。系统管理员需要创建 MBR 分区，然后将 disklabel 分区嵌套在这些 MBR 分区内。^(3)

这种方式有效，但也使得 *partition* 这个词变得模糊。*partition* 是指 MBR 分区还是 disklabel 分区呢？FreeBSD 重新使用了 *slices* 这个词来表示 MBR 分区。每个 MBR 切片都会有自己的 disklabel，列出包含在切片中的 BSD 分区。如果你来自 Linux 或 Microsoft Windows 背景，你所熟悉的 MBR 分区在这里被称为 *slices*。

你不能为切片或 disklabel 分区添加标签。这些格式没有空间容纳标签。相反，应为分区上的 ZFS 或 UFS 文件系统添加标签。

也可以跳过切片，直接在硬盘上安装 disklabel。有些硬件拒绝从这样的磁盘启动，因此它们被称为 *dangerously dedicated*（危险专用）。随着 GPT 的出现，危险专用磁盘现在不再被广泛使用。

#### ***MBR 设备节点***

每个磁盘、切片和分区都有一个设备节点。切片设备节点是基础磁盘的扩展，而分区设备节点是设备节点的扩展。以下是在基于 MBR 的系统中，磁盘 ada0 上的设备节点：

```
/dev/ada0       /dev/ada0s1a    /dev/ada0s1d
/dev/ada0s1     /dev/ada0s1b    /dev/ada0s1e
```

磁盘的第一个细分是切片。设备节点使用字母 *s* 和 1 到 4 的数字表示切片。第一个切片是 s1，第二个是 s2，以此类推。未使用的 MBR 分区没有设备节点。在这里，*/dev/ada0s1* 是磁盘上的第 1 个切片。

第二层细分是切片内的 disklabel 分区。每个分区都有一个唯一的设备节点名称，通过在切片的设备节点后添加字母来创建。在这里，我们有四个 disklabel 分区，从 */dev/ada0s1a* 到 */dev/ada0s1e*。传统上，结尾为 *a*（*/dev/ada0s1a*）的节点是根分区，而结尾为 *b*（*/dev/ada0s1b*）的节点是交换空间。

请注意，设备节点列表中没有使用字母 *c*。c 分区表示整个切片。如今，你在切片条目上运行磁盘分区工具，而不是在切片的 disklabel 上。

你可以随意分配 d 到 h 的分区。一个默认的磁盘标签最多可以有七个可用分区。每个磁盘最多可以有四个分区，因此你可以在一个磁盘上拥有最多 28 个分区。一个磁盘标签最多支持 20 个分区，但在第一次创建标签时，必须明确表示要使用额外的分区。

#### ***MBR 和磁盘标签对齐***

分区有各自的磁盘扇区和文件系统块对齐问题。传统上，MBR 分区会在磁道边界结束。虽然在现代硬件上，磁道边界并没有实际意义，但即使是较新的硬盘也会为旧的或能力较弱的硬件提供这样的“舒适的谎言”。如果你创建的 MBR 分区没有在磁道边界结束，并且将该磁盘放入需要遵守磁道边界的机器中，这台机器可能会发生某种“崩溃”。今天你所创建的分区，理论上可能会进入一台较老的系统中。因此，FreeBSD 会安排分区，使它们结束在磁道边界上。磁道边界不仅可以，而且可能与 4K 磁盘扇区大小冲突。至少，MBR 本身就占用了第一个磁道，或者 63 个 512 字节的扇区！

幸运的是，你很少需要写入分区表，并且写入分区表的性能问题也很少。只要你将磁盘标签分区对齐到 1MB 的边界，你会在分区表和磁盘标签分区之间丢失几个扇区，但性能将会是正常的。

所以：对齐磁盘标签分区。不要对齐分区。

#### ***创建分区***

使用 gpart(8)来管理 MBR 分区。要创建一个分区，你需要指定一个分区类型和大小。FreeBSD 的分区使用类型*freebsd*。如果不指定大小，gpart(8)将使用所有可用空间。在一个空的磁盘上，这会将整个磁盘分配给一个单一的分区。

在这里，我删除现有的分区布局，告诉磁盘使用 MBR 方案，并创建一个单一的 FreeBSD 分区：

```
# gpart destroy -F ada3
# gpart create -s mbr ada3
# gpart add -t freebsd ada3
ada3s1 added
```

运行`gpart show`，你会看到该磁盘现在有一个单独的分区。添加`-p`标志以查看分区的设备节点。

```
# gpart show -p ada3
=>        63  1953525105    ada3  MBR  (932G)
          63  1953525105  ada3s1  freebsd  (932G)
```

我们的分区 ada3s1 现在已经准备好用于磁盘标签分区。

要创建多个分区，使用`-s`指定大小。小型嵌入式系统的常见配置是在一个磁盘上放置三个分区。两个较小的分区包含操作系统的不同版本，而第三个则包含任何数据。在这里，我将这个 1TB 的磁盘分为两个 150GB 的分区，并将其余的分配给第三个分区：

```
# gpart add -s 150g -t freebsd ada3
ada3s1 added
# gpart add -s 150g -t freebsd ada3
ada3s2 added
# gpart add -t freebsd ada3
ada3s3 added
```

#### ***删除分区***

使用`gpart delete`来删除不需要的分区。通过`-i`指定分区编号。在这里，我删除了我们上一节中创建的多分区磁盘中的第三个较大分区：

```
# gpart delete -i 3 ada3
ada3s3 deleted
```

#### ***激活分区***

激活的分区是 BIOS 尝试启动的分区。使用`-a`激活标志设置激活分区。使用`-i`指定激活分区的编号。

```
# gpart set -a active -i 1 ada3
```

通过设置不同的激活分区，改变启动的分区。

引导磁盘还需要一个引导加载程序。虽然 MBR 引导加载程序与 GPT 或 UEFI 引导加载程序不同，但它使用相同的 gpart(8) `-b`标志。FreeBSD 提供了一个 MBR 引导加载程序副本，位于*/boot/mbr*。

```
# gpart bootcode -b /boot/mbr ada3
```

磁盘 ada3 上的切片 1 现在是可引导的。现在你已经对磁盘进行了分区，可以在这些切片内部创建 BSD 标签了。

### **BSD 标签**

在切片内部创建 BSD 标签（或磁盘标签）分区，就像创建切片或 GPT 分区一样。你必须告诉存储设备使用的方案，创建并删除分区，直到你满意为止，然后安装引导加载程序。

#### ***创建 BSD 标签***

在 GPT 和 MBR 特定提供分区表空间的情况下，你必须创建一个 BSD 标签并将其写入切片的开头。和任何方案一样，使用`-s`和方案名称。将该方案安装在切片上，而不是磁盘上。

假设你想在切片 ada3s1 上创建一个 BSD 标签。使用 BSD 方案。

```
# gpart create -s bsd ada3s1
ada3s1 created
```

这是一个默认的磁盘标签，最多可以容纳 8 个磁盘标签分区。你可以通过使用`-n`标志增加分区数目，最多可达 20 个。在这里，我在 ada3s3 这个大分区上创建了一堆分区。

```
# gpart create -n 20 -s bsd ada3s3
ada3s3 created
```

这个切片上没有实际的磁盘标签分区；只有一个可以包含磁盘标签分区的标签。标签一旦存在，你就可以创建这些分区了。

#### ***创建 BSD 标签分区***

在盲目输入分区命令之前，先计划好如何对磁盘进行分区。提前在纸上搞清楚比在命令行上解决要容易得多。我打算将磁盘上第一个 150GB 的切片分配给 UFS 文件系统。这个切片将为*/*（根）、交换分区和*/tmp*分配 5GB 的分区。其余的空间将分配给*/usr*。为什么不为*/var*分区？我会把大的切片 ada3s3 分配给*/var*。我不需要添加引导分区，因为 MBR 磁盘不需要引导分区。

要创建磁盘标签分区，你必须使用`-t`指定类型，使用`-s`指定大小——就像你为 GPT 分区做的那样。FreeBSD UFS 文件系统的类型是*freebsd-ufs*。我们从根分区开始。

```
# gpart add -t freebsd-ufs -s 5g -a 1m ada3s1
ada3s1 added
```

要查看这个分区，你必须给`gpart show`提供切片设备，而不是磁盘设备。使用磁盘设备会显示切片。

```
# gpart show ada3s1
=>        0  314572800  ada3s1  BSD  (150G)
          0       1985          - free -  (993K)
       1985   10485760       1  freebsd-ufs  (5.0G)
   10487745  304085055          - free -  (145G)
```

输出的第三行显示了我们的 5GB 分区。

在这个切片的最开始，我们有 1985 个空闲块，约 993KB。我要求分区对齐到 1MB 边界，所以 gpart 浪费了一些空间来满足这个请求。我乐意失去这 993KB，而不是降低系统的性能。

现在创建类型为*freebsd-swap*的交换分区。

```
# gpart add -t freebsd-swap -s 5g -a1m ada3s1
ada3s1b added
```

接下来是 5GB 的*/tmp*。然后，我将剩余的空间分配给一个*/usr*分区，通过省略大小来完成。

```
# gpart add -t freebsd-ufs -s 5g -a1m ada3s1
ada3s1d added
# gpart add -t freebsd-ufs -a1m ada3s1
ada3s1e added
```

一个`gpart show`命令显示我们的磁盘标签分区在磁盘末尾浪费了 63 个块，约 32KB。看我对此毫不在乎。

这些分区现在已经准备好接收文件系统了。我们在第十一章中讨论 UFS。

#### ***分配特定的分区字母***

在传统的 BSD 标签上，*a*分区用于根文件系统，而*b*用于交换。*c*分区表示整个切片。这不是强制性的，但我建议不要将这些字母用于任何其他用途。

为什么这很重要？我曾经在一台服务器上添加了一个硬盘，以便为数据库提供更多空间。我们将数据库软件迁移到了分区*a*，而实际数据则迁移到了分区*b*。^(4) 几个月后，当我去度假时，系统虚拟内存不足。我接到了系统管理员的电话，他找到了并激活了新硬盘上未配置的交换空间——但现在数据库数据丢失了。是的，公司失去了几位客户，并且损失了成千上万美元的收入，这很可悲——但更重要的是，这毁了一天的假期，并且对剩余的假期蒙上了阴影。这是不可接受的。

不要试图反抗这些传统，尤其是在越来越不常见的磁盘格式上。除非是由伯克利的长老们规定，否则不要将字母*a*、*b*或*c*用于其他分区。

gpart 程序设计时是为了处理分区编号，而不是字母。然而，在创建磁盘标签时，`gpart add`会将索引号映射到字母上。分区 1 是*a*，分区 2 是*b*，依此类推。通过在创建分区时指定分区索引，你将字母分配给该分区。

如果你没有指定分区号，`gpart add`会从分区字母*a*开始分配分区字母。你可能将第一个分区编号为 18，但如果没有为下一个分区指定编号，它将默认使用分区*a*。为了避免使用*a*、*b*或*c*，为你创建的每个分区使用数字。你只能使用字母，直到分区有的磁盘标签槽位的数量。标准磁盘标签只能使用字母*a*到*h*，而一个支持 20 个分区的标签可以使用*a*到*t*。

在我的三分区系统中，我想将*/var*放在 ada3s3 上。我想使用一个不同于*a*、*b*或*c*的字母，所以我随机选择了索引 18。它几乎与*/usr*的分区完全相同，只不过我们将它添加到了不同的切片上。

```
# gpart add -t freebsd-ufs -a 1m -i 18 ada3s3
ada3s3r added
```

要查看该磁盘标签分区，你需要运行`gpart show ada3s3`。加上`-p`可以查看设备名称。

```
# gpart show -p ada3s3
=>         0  1324379505   ada3s3  BSD  (632G)
           0        1985           - free -  (993K)
        1985  1324376064  ada3s3r  freebsd-ufs  (632G)
  1324378049        1456           - free -  (728K)
```

你知道吗？我们字母表中的第 18 个字母是*R*。

有了分区，我们可以开始查看文件系统了。
