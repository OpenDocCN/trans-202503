## 23

FREEBSD 的边缘领域

![image](img/common01.jpg)

如果你在 FreeBSD 社区待上一段时间，你会听到各种可以通过了解技术来实现的事情。人们构建嵌入式 FreeBSD 设备，并将它们运送到全球客户手中，而这些客户甚至不知道他们的空调或无线电中继站里有一台类 Unix 服务器。人们还在没有硬盘的机器上运行 FreeBSD，从单台服务器支持数百或数千个无盘工作站。你会发现可以启动的 CD 和 USB 设备，里面包含完整的 FreeBSD 系统，包括你可能需要的所有已安装软件。一旦你掌握了技巧，这些事情并不难做。

在本章中，我们将进入 FreeBSD 的边缘领域——由 FreeBSD 用户完成的真正酷的事情，这些事情并不一定是 FreeBSD 主流项目所支持的。虽然你可以通过常规渠道获得支持和帮助，但你必须做好比平时更多的准备，来调试和排查本章中的所有内容。

### 终端

*终端*是人们可以登录的设备。键盘、显示器和鼠标组成了一个终端，也叫做*控制台*。当你通过 SSH 登录到主机时，它提供的是*虚拟终端*。终端配置通常是自动的，但你可能需要进行一些调整。

文件*/etc/ttys*控制着用户如何以及在哪里登录到你的 FreeBSD 系统。控制台登录是否有效？虚拟终端呢？通过串行线路登录怎么样？FreeBSD 系统提供了四种标准终端：控制台、虚拟终端、拨号终端和伪终端。

*控制台*是单用户模式下唯一可用的设备。在大多数 FreeBSD 系统中，这通常是一个视频控制台，包括显示器和键盘，或者是从另一台系统访问的串行控制台。一旦系统进入多用户模式，控制台通常会连接到一个虚拟终端。控制台设备是*/dev/console*。

*虚拟终端*连接到物理显示器和键盘。你可以在一个物理终端上拥有多个虚拟终端。通过 ALT 和功能键在它们之间切换。下次你坐到键盘前，按下 ALT-F2。你会看到一个新的登录屏幕，主机名后面是`ttyv1`。这就是第二个虚拟终端。按 ALT-F1 则回到主虚拟终端。默认情况下，FreeBSD 有八个虚拟终端，并为 X Windows 保留了第九个。即使在 X 环境下，你也可以使用这八个虚拟文本终端，并且一些 X 桌面提供多个 X 虚拟终端。这些虚拟终端是*/dev/ttyv*设备。

*拨号终端*通过串行线连接。你可以将调制解调器直接连接到你的串口，并让用户拨号连接到你的服务器。虽然现在这种方式不太常见，但相同的功能也支持通过串行控制台登录。拨号终端就是*/dev/ttyu*设备。

最后，*伪终端*完全由软件实现。当你通过 SSH 登录到服务器时，你不需要任何实际的硬件，但软件仍然需要为你的会话创建一个设备节点。伪终端是*/dev/pts/*中的设备节点。你不需要配置伪终端；它们会在你登录时自动协商。

配置对控制台、虚拟终端和拨号终端的访问权限，配置文件为*/etc/ttys*。你可以启用串行访问、要求或禁用密码等设置。

#### */etc/ttys 格式*

*/etc/ttys*中的典型条目如下所示：

```
ttyv0   "/usr/libexec/getty Pc"         xterm  on  secure
```

第一个字段是终端的设备节点。在这种情况下，`ttyv0`是系统中的第一个虚拟终端。

第二个字段是用于处理此终端登录请求的程序。FreeBSD 使用 getty(8)，但如果你有偏好的终端管理程序，可以使用它代替。你可以在软件包中找到几个这样的程序。这个字段接受一个参数，即终端配置。文件*/etc/gettytab*包含了所有的终端配置。

第三个条目是终端类型。文件*/etc/termcap*描述了 FreeBSD 支持的所有终端类型。对于真正的小型系统，FreeBSD 提供了*/etc/termcap.small*，其中仅包含最重要的条目。几乎所有现代终端都可以与`xterm`或`vt100`兼容。

第四个条目决定了终端是否可以接受登录。可以设置为`on`以接受登录，或`off`以禁止登录。`onifconsole`设置允许在内核将端口配置为控制台时在串行端口上进行登录。

最后，我们有一些选项。这个示例设置了`secure`选项，这告诉 getty(8)，root 可以登录该控制台。

提供终端是一个低级的系统任务，直接由 init(8)处理。对*/etc/ttys*的更改不会生效，直到你告诉 init(8)重新读取其配置文件。Init 始终是 PID 1。

```
# kill -1 1
```

#### *不安全的控制台*

当你以单用户模式启动 FreeBSD 时，你会得到一个 root 命令提示符。这对于你的笔记本电脑来说没问题，并且在公司数据中心的服务器上也能很好地工作，但对于不可信的设施中的机器呢？例如，如果你有一台在合租数据中心的服务器，你可能不希望任何人都能够获得 root 级别的访问权限。你可以告诉 FreeBSD 物理控制台不安全，并要求进入单用户模式时需要 root 密码。然后系统会从开机启动到多用户模式而不需要密码，但在你明确选择以单用户模式启动时，会要求输入密码。

在单用户模式下要求密码并不能完全保护你的数据，但它确实大大提高了安全门槛。一个孤单的技术人员在深夜、没人注意时，可以将你的系统启动到单用户模式，并在大约 15 分钟内为自己添加一个账户。而拆卸你的机器，移除硬盘，将它们安装到另一台机器上，进行修改并将服务器重新上线，需要更多时间，侵入性更强，且更有可能被托管管理人员注意到。

在*/etc/ttys*中找到控制台条目：

```
console none        unknown off secure
```

你会发现，控制台终端不像其他终端那样功能丰富；它不运行 getty(8)，并使用通用的`unknown`终端类型。然而，控制台仅限在单用户模式下使用，并且当连接到物理终端时，这样是可以的。

要使控制台在启动到单用户模式时要求 root 登录，请将`secure`更改为`insecure`。

```
console none        unknown off insecure
```

为控制台设置密码保护可以阻止随便的恶作剧行为，但它甚至无法减缓那些拥有物理访问权限的熟练入侵者。

### 管理云端 FreeBSD

数百台或上千台服务器的集群变得越来越常见。像 Ansible 和 Puppet 这样的自动化系统，某种程度上让我们能够保持这些系统的基本秩序。然而，Unix 并不是为了这样操作而设计的。最初的 UNIX 是为了由一个高度熟练的操作员来管理，他能轻松应对各种不同命令输出格式以及更多配置文件样式的怪癖。

FreeBSD 正在通过 libXo 和通用配置语言(UCL)解决云规模管理的问题。

#### *LibXo*

虽然自动化监控是必需的，可以提醒你出现问题，但当涉及到深入的故障排除时，没有什么能替代登录主机、运行命令并解释结果。我已经忘记了写了多少脚本来解析一些晦涩的 ps(1)标志组合的输出，这样我就能将数字传递给监控软件。我也已经忘记了我花了多少小时调试这些脚本，或者解释为什么我写的处理一个 netstat(1)标志的脚本与我们现在感兴趣的标志无关。^(1) 如果将这个问题扩展到数百台或上千台服务器，那么从软件中快速获取信息就变成了一个严重的问题。

FreeBSD 通过 libXo 减少了这个问题的复杂性。

LibXo 是一个库，帮助命令提供不仅是文本形式的输出，还能生成 XML、JSON，甚至 HTML。与其使用 grep(1)和 awk(1)，或者你用过的任何令人不安的 Shell、Perl 或 Python 组合来查找所需的信息，不如让一个解析器从标记格式中提取数据。你还可以将命令输出直接导出到网页上。

不是所有程序都支持 libXo，但越来越多的程序正在添加支持。手册页会声明一个程序是否支持 libXo，如果你懒得阅读，可以尝试使用`--libxo`标志运行命令。所有支持 libXo 的命令都使用该命令行选项。你还必须指定输出格式，文本、XML、JSON 或 HTML。这里，我运行`arp -an`并将 JSON 设置为输出格式。

```
$ arp -an --libxo json
{"__version": "1", "arp": {"arp-cache": {"hostname":"?","ip-address":"
203.0.113.221","mac-address":"08:00:27:31:91:0d","interface":"em0",
"permanent":true,"type":"ethernet"} 
--snip--
```

如何使用这个？我们中的许多人可能不会使用。但如果你正在管理数十台或数百台服务器，你可能拥有足够的专业知识来轻松解析这个。数百种工具可以选择标记数据，而你的应用开发人员可能已经在主机上安装了他们首选的软件。虽然`arp(8)`的输出结果相对一致，但 libXo 也能处理 netstat(1)、vmstat(8)等命令的任何任意标志组合。学会一次性抓取标记数据，你就可以*永远*告别那些可怕的脚本编写。

#### *通用配置语言*

Unix 系统有一种相当标准的配置文件格式。井号（#）是注释。存在变量。也许变量在配置文件中的存在足以激活某个功能，或者你需要将变量设置为某个值。尽管如此，它们都有些不同。有些程序可以从主文件和目录中的文件中提取配置片段，就像 cron(8)从*/etc/crontab*和*/etc/cron.d/*中提取一样。其他程序则不行。有些使用大括号来划分配置块，而有些则使用……无论是 30 年前程序员认为好的主意。结果是，没人看*syslog.conf*会觉得它看起来像*pkg.conf*，尽管它们共享相似的基础概念。

*通用配置语言（UCL）*旨在改变这一现状。如果这些程序的语法类似，为什么不为每个程序使用一个统一的解析库呢？如果你已经有了一个解析库，为什么不让它解析多种格式呢？UCL 允许你提供经典 Unix 风格、JSON 或 YAML 格式的配置文件，非常适合自动化管理。它可以从 shell 代码、UCL、JSON 或 YAML 中提取配置设置。

在我写这篇文章时，FreeBSD 为 pkg(8)使用了 UCL。对其他工具的支持，例如 bhyve(8)，正在慢慢推进。如果你正在管理大量服务器，请查看你的发行版中 UCL 的支持状态。

### 无盘 FreeBSD

尽管 FreeBSD 并不难管理，但数十台或数百台几乎相同的系统可能会变得相当沉重。减少维护负担的一种方法是使用*无盘*系统。无盘系统并不是禁止使用硬盘，而是它们从网络上的 NFS 服务器加载内核和操作系统。

为什么要为你的服务器集群使用无盘系统？多个系统可以从单一的 NFS 服务器启动，集中管理所有的补丁和软件包。这对于终端机集合、计算集群以及其他有大量相同系统的环境非常适用。发布操作系统更新变得非常简单，只需在 NFS 服务器上替换文件。同样，当你发现更新有问题时，恢复它也只是简单地恢复 NFS 服务器上的文件。在这两种情况下，客户端所需做的唯一事情就是重启。由于客户端对服务器只有只读访问权限，未经授权的用户无法对操作系统做出任何更改。如果你只运行少量系统，无盘系统可能会显得过于复杂，但如果系统数量超过几个，无盘系统无疑是一个明确的赢家。

在你运行无盘系统之前，你必须拥有一个 NFS 服务器、一个 DHCP 服务器、一个 TFTP 服务器以及支持无盘启动的硬件。让我们逐一查看并了解如何进行设置。

**测试，测试，测试！**

你的第一次无盘设置将很像你第一次设置防火墙：容易出错、麻烦且令人恼火。我强烈建议你测试准备工作的每一步，这样你可以更容易地发现并解决问题。每个必需服务的测试说明都会提供。

#### *无盘客户端*

运行无盘的机器必须具备足够的智能，通过网络找到它们的引导加载程序和操作系统。实现这一目标的有两种标准方式：BOOTP 和 PXE。*BOOTP*（互联网引导协议）是一个较老的标准，早已被淘汰。*PXE*（英特尔预启动执行环境）已在几乎所有的新机器上得到支持多年，因此我们将专注于此。

启动你的无盘客户端机器并进入 BIOS 设置。在 BIOS 中，你会找到一个选项来设置启动设备顺序。如果机器支持 PXE，其中一个选项将是网络。启用该选项并让机器首先尝试网络启动。

你的无盘客户端已经准备好了。现在让我们准备服务器。

#### *DHCP 服务器设置*

虽然大多数人将 DHCP 看作是为客户端分配 IP 地址的方式，但它能提供的不止这些。你可以配置 DHCP 服务器来提供 TFTP 服务器、NFS 服务器和其他网络资源的位置。无盘系统广泛使用 DHCP，你会发现我们使用了一些你从未尝试过的 DHCP 选项。

OpenBSD 的 DHCP 服务器不支持 FreeBSD 无盘客户端；你必须使用 ISC 的 DHCP 服务器或其他功能更全的版本。一旦你获得了无盘工作站的 MAC 地址，配置 ISC DHCP 服务器来处理无盘系统就非常直接了。

##### MAC 地址

要为 DHCP 客户端分配配置信息，您需要该客户端网卡的 MAC 地址。某些 BIOS 实现提供集成网卡的 MAC 地址，某些服务器级硬件则有打印着 MAC 地址的标签。然而，这些选项过于简单，所以我们将尝试更复杂的方法。

当一台机器尝试从网络启动时，它会发出 DHCP 请求以获取其配置信息。虽然您还没有配置无盘配置，但任何 DHCP 服务器都会记录客户端的 MAC 地址。您可以从租约文件*/var/db/dhcpd.leases*获取客户端信息。

```
  --snip--
➊  lease 198.51.100.10 {
     starts 6 2017/09/16 06:57:23;
     ends 6 2017/09/16 07:07:23;
  --snip--
➋  hardware ethernet 08:00:27:d8:c1:1c;
     uid "\001\010\000'\330\301\034";
     set vendor-class-identifier = "PXEClient:Arch:00000:UNDI:002001";
  }
  --snip--
```

该客户端的 MAC 地址为 08:00:27:d8:c1:1c➋，并已被分配 IP 地址 198.51.100.10➊。根据这些信息，我们可以创建一个 DHCP 配置来为此主机分配静态 IP 地址，并提供其启动信息。

##### DHCP 配置：特定无盘主机

我们在[第二十章中配置了基本的 DHCP 服务。下面是一个适用于无盘客户端的 dhcpd(8)配置示例。这些配置不应该放在子网声明中，而是独立作为顶层声明，即使它与非无盘 DHCP 客户端共享同一子网。

```
➊ group diskless {
        ➋ next-server 198.51.100.1;
        ➌ filename "pxeboot";
        ➍ option root-path "198.51.100.1:/diskless/1/";
        ➎ host compute1.mwl.io {
                ➏ hardware ethernet 08:00:27:d8:c1:1c  ; 
                ➐ fixed-address 198.51.100.101 ;
          }
    }
```

我们定义了一个名为`diskless`的组➊。这个定义将允许我们为该组分配特定的参数，然后只需将主机添加到该组中。组中的每个主机都会得到相同的参数。

`next-server`设置➋告知 DHCP 客户端 TFTP 服务器的 IP 地址，`filename`选项➌告诉客户端从该 TFTP 服务器请求的引导加载程序文件的名称。记得在第四章中提到，引导加载程序是找到并加载内核的软件。最后，`option root-path` ➍告诉引导加载程序在哪里找到该机器的根目录。所有这些选项和设置都会提供给无盘组中的所有客户端。

然后，我们使用`host`语句和此系统的主机名➎将无盘客户端分配到无盘组中。我们的第一个客户端被称为`compute1`。此客户端通过其 MAC 地址➏进行标识，并被分配了一个静态 IP➐。它还接收此组的标准配置。

为网络上的每个无盘主机创建类似的主机条目。

重启 dhcpd(8)使此配置生效。现在重新启动您的无盘客户端。DHCP 日志应该会显示您已为该客户端分配了静态地址。然而，DHCP 客户端在没有引导加载程序的情况下无法继续启动，这意味着您需要一个 TFTP 服务器。

##### DHCP 配置：无盘集群

也许你有大量相同的无盘主机，比如终端机房中的瘦客户端。完全可以理解你不希望为每个瘦客户端都做一个静态的 DHCP 条目。让这些主机从 DHCP 服务器获取它们的引导信息，但不指定主机地址。它们将从 DHCP 池中获取一个地址。许多集群解决方案包括客户端服务，它们会将新主机注册到它们正在使用的“集群管理器”中，因此硬编码的地址就不那么重要了。

你还可以特别识别那些请求 DHCP 信息的 PXE 主机，并将这些主机分配给一个特定的地址组。使用 PXE 引导的主机会将自己标识为 `PXEclient` 类型的客户端，向 DHCP 服务器报告。你可以编写特定的规则来匹配这种类型的客户端，并进行适当配置。有关如何匹配 `vendor-class-identifier` 和 `dhcp-client-identifier`，请查阅 DHCP 手册。

#### *tftpd 和引导加载程序*

我们在第二十章中介绍了如何配置 TFTP 服务器。TFTP 服务器必须为你的无盘客户端提供 *pxeboot* 文件。FreeBSD 将 *pxeboot* 提供在 */boot* 目录下。

```
# cp /boot/pxeboot /tftpboot
# chmod +r /tftpboot/pxeboot
```

尝试通过 TFTP 从你的工作站下载*pxeboot*。如果成功，重启你的无盘客户端并观察它尝试启动。控制台应该会显示类似以下的信息：

```
Building the boot loader arguments
Relocating the loader and the BTX
Starting the BTX loader
```

你之前可能见过这个消息，当一个常规的 FreeBSD 从硬盘启动时。你的无盘客户端将识别 PXE 版本，打印内存，并声明它正在运行引导加载程序。此时，它将无限循环，尝试加载内核。它无法加载内核，因为我们还没有设置 NFS 服务器。

#### *无盘安全性*

无盘系统通过 NFS 运行，并且具有所有 NFS 的安全问题。即使你部署 Kerberos 来加密 NFS 流量，初始网络引导和根文件系统的挂载始终是未加密的。不要在开放的互联网中运行无盘节点。

你可以通过为 NFS 根账户分配一个不同的用户来在某种程度上保护你的 NFS 服务器。运行 `find /diskless/1 -user 0 -exec chown nfsroot {} \;` 会将所有 root 拥有的文件的所有者更改为 nfsroot 用户。然后你可以编辑 *exports* 文件，将 root 映射到 nfsroot 用户。然而，要运行 freebsd-update(8) 时，你需要还原它，并在应用补丁后恢复。但是在你刚开始学习时，不要太复杂。先让基本的用户空间工作起来。

#### *NFS 服务器和无盘客户端用户空间*

许多关于无盘操作的教程建议使用服务器的用户空间和根分区作为无盘客户端。这可能很容易做到，但这根本不安全。你的无盘服务器上可能有你不希望客户端访问的程序，而且它肯定包含了你不希望泄露给一大堆工作站的敏感安全信息。提供一个独立的用户空间是一个更明智的选择。

虽然你可以通过多种方式提供一个独立的用户空间，但我发现最简单的方式是稍微修改第二十二章中的 jail(8)构建过程。首先，为我们的无盘客户端创建一个数据集、UFS 文件系统或目录作为它们的根目录，然后在该目录中安装用户空间和内核。将*base.txz*和*kernel.txz*分发文件提取到该目录中。

```
# tar -xpf base.txz -C /diskless/1/
# tar -xpf kernel.txz -C /diskless/1/
```

如果你构建了一个 FreeBSD 并希望运行它，这也是可以的。在这里，我们将一个本地构建的用户空间安装到*/diskless/1*：

```
# cd /usr/src
# make installworld DESTDIR=/diskless/1
# make installkernel DESTDIR=/diskless/1
# make distribution DESTDIR=/diskless/1
```

现在将这个目录告诉你的 NFS 服务器。我打算在这个网络上安装几台无盘系统，所以我通过 NFS 将这个目录共享给整个子网。客户端不需要对 NFS 根目录有写权限，因此我将其设置为只读。下面的*/etc/exports*行实现了这一点：

```
/diskless/1 -ro -maproot=0 -alldirs -network 198.51.100.0 -mask 255.255.255.0
```

重新启动 mountd(8)以使这个共享可用，并尝试从工作站进行挂载。确认该目录包含一个从客户端可见的基本用户空间，并且客户端无法写入文件系统。

你的无盘主机需要设置一个根密码。使用 chroot(8)和 passwd(1)来设置它。

```
# chroot /diskless/1/ passwd
```

你需要告诉主机它的根文件系统是只读的。创建*/diskless/1/etc/rc.conf*并将`root_rw_mount`设置为 NO。在该目录下，还需要为你的客户端创建一个*resolv.conf*文件。

现在重启你的无盘客户端，看看会发生什么。它应该能够找到内核并启动到一个未配置的多用户模式。根据服务器、客户端和网络速度的不同，这可能需要一些时间来完成。

在这一点上，你可以配置你的用户空间，以特定匹配你的单个无盘客户端。你可以在*/etc*中进行修改，例如创建反映你需求的*/etc/fstab*文件，并将密码文件复制到相应位置。这对一个无盘客户端来说足够了，但 FreeBSD 有专门的基础设施来支持从同一个文件系统启动几十或几百台主机。我们来看看这是如何做到的。

### 无盘工作站农场配置

无盘系统的一个好处是多个机器可以共享同一个文件系统。然而，即使是大多数相同的机器，你也会发现必须让某些配置文件略有不同。FreeBSD 提供了一种机制，通过在 tmpfs(5)临时文件系统上*重新挂载*目录，并将自定义文件复制到这些分区上，从而在统一的用户空间上提供个性化的配置文件。

FreeBSD 的默认无盘设置允许你跨多个网络和子网配置无盘工作站——这是大型网络中的一个宝贵特性。然而，如果你只有少数几台无盘系统，刚开始你可能会觉得它有点繁琐。但是随着时间的推移，你会发现它会越来越有用。无盘系统是解决许多问题的便捷方案。

启动中的 FreeBSD 系统使用 `vfs.nfs.diskless_valid` 来判断它是否在无盘运行。如果 sysctl 等于 `0`，则说明它从硬盘运行；否则，它是在无盘模式下运行。在无盘系统上，FreeBSD 会运行 */etc/rc.initdiskless* 脚本来解析并部署层次化的无盘配置。

#### *配置层次结构*

在无盘主机的 */conf* 目录中配置你的无盘农场。*/conf* 目录中可能包含很多目录。两个关键的目录是 */conf/base* 和 */conf/default*，但你可能也会有单独的子网和/或个别 IP 地址的目录。无盘系统使用这些目录中的内容在挂载的根分区上构建 tmpfs 文件系统，以便每台主机可以拥有独特的设置和读写文件系统。你可以将任何目录都作为 tmpfs 文件系统，并从这个层次结构中填充它，但每台主机都需要一个读写的 */etc* 目录，所以我们将以此为例。

*/conf/base* 目录包含需要在无盘客户端上以读写方式挂载的基础系统文件。创建 */conf/base/etc* 并将一组 */etc* 文件填充其中，无盘主机就可以将它们作为其 tmpfs */etc* 的基础。（如我们稍后所见，它也可以回收无盘根目录的 */etc*）。

*/conf/default* 目录包含你环境的默认设置。也许你环境中的每一台主机都需要一个指向挂载共享数据存储的 */etc/fstab* 文件。你可以创建 */conf/defaults/etc/fstab*，然后无盘系统会将其复制到每台主机，覆盖基础系统中的 */conf/base/etc*。我还会在默认目录中分发你环境的通用 *rc.conf*。

你还可以创建每个子网的目录。将该目录命名为子网的广播地址，即网络中的最高地址。我的无盘农场运行在子网 198.51.100.0/24 上，广播地址是 198.51.100.255。如果我创建了 */conf/198.51.100.255/etc/rc.conf*，该子网中的每台主机都会获得这个 *rc.conf* 文件。如果我为该子网中的无盘主机有一个特殊的 */etc/fstab*，我可以将其放入 */conf/198.51.100.255/etc/fstab*，它将覆盖默认设置。我还会在 */etc/rc.conf.d/* 中添加为仅在该子网上运行的特殊服务的文件。

最后，我可以为每个主机创建独立的目录。如果我创建了 */conf/198.51.100.101/etc/rc.conf.d/apache*，那么主机 198.51.100.101—仅这台主机—会获得这个文件。如果这台主机需要一个真正独特的 */etc/fstab*，我可以将其放入 */conf/198.51.100.101/etc/fstab*，它会覆盖默认的以及子网的 */etc/fstab*。^(2)

这种层次化配置通过一个叫做 *无盘重挂载* 的过程进行部署。

#### *无盘重挂载 /etc*

无磁盘系统检查文件*/conf/base/etc/diskless_remount*，以获取它应该作为内存文件系统挂载的目录列表。如果没有这个文件，就不会创建内存文件系统，并且你的无磁盘主机与所有其他无磁盘主机共享一个只读的用户空间。`diskless_remount`文件包含需要重新挂载的文件系统列表。

```
/etc
```

这告诉 FreeBSD 构建一个 MFS */etc*并将无磁盘根目录现有的*/etc*复制到其中，为我们提供一个基础来工作。

你不一定希望无磁盘根目录中的所有文件都出现在无磁盘主机的*/etc*目录中。这是一个内存文件系统，所以为什么要浪费内存存放你不需要的东西？你也不想让初级系统管理员误以为主机支持它们并不具备的功能。无磁盘系统不应在本地保存日志，因此它们不需要*newsyslog*或*/etc/newsyslog.conf*。你也不需要备份无磁盘客户端，因此*/etc/dumpdates*也是不必要的。浏览*/etc*将揭示出许多与无磁盘主机无关的文件。然而，如果你删除得太多，系统将无法启动，而且所需文件的列表并不直观。例如，如果你删除了*/etc/mtree*，机器将在单用户模式下挂起，因为它无法重新填充 MFS */var*分区。

将你不需要的文件和目录的完整路径放入文件*/conf/base/etc.remove*中。例如，以下条目会删除*/etc/gss*和*/etc/bluetooth*目录，以及之前提到的 syslog 和备份文件。你不需要复制*/etc/resolv.conf*。FreeBSD 的*/etc/rc.d/resolv*启动脚本会从启动主机时的原始 DHCP 响应中创建一个。

```
/etc/gss
/etc/bluetooth
/etc/dumpdates
/etc/resolv.conf
/etc/newsyslog.conf
/etc/syslog.conf
```

这不难，是吗？

现在让我们将一些内容添加回我们的配置中。

### 完成设置

既然你已经有了一个安装好的系统，让我们做一些微调。无磁盘客户端需要第三方软件包和各种配置文件。完成客户端设置最简单和最安全的方法是使用 chroot(8)程序，它将你锁定在文件系统的一个子目录中。通过在 NFS 服务器上使用 chroot(8)，你几乎可以获得对文件系统的读写访问，就像它在无磁盘客户端上存在一样。

```
# chroot /diskless/1
```

是的，*/etc*仍然具有层次化的覆盖，但系统的其他部分存在的方式完全符合无磁盘客户端所看到的样子。你在 chroot 后所做的任何更改都将对客户端保持一致。

#### *安装软件包*

使用 pkg(8)在无磁盘客户端上安装软件。使用`-c`标志来指定无磁盘根目录，并让 pkg(8)切换到该目录。

```
# pkg -c /diskless/1/ install pkg
```

现在你已经在无磁盘客户端上有了软件包工具、数据库和仓库信息。

```
# pkg -c /diskless/1/ install sudo
```

以这种方式安装你需要的软件。

#### *SSH 密钥*

也许关于无盘客户端最令人烦恼的事情就是主机的 SSH 密钥。在正常操作中，每台主机都需要唯一的 SSH 密钥。如果你运行在一个私有网络中，你可能会决定让所有无盘客户端共享相同的 SSH 密钥。你也可能决定让每台主机在启动时自动生成新的 SSH 密钥。由于*/etc*位于 tmpfs 上，这些密钥将在关机时消失，但用户会很快习惯“主机密钥已更改”的消息。然而，你并不希望用户习惯这个。

然而，为每个无盘客户端建立持久的、唯一的主机密钥并不困难。为每台主机创建一个*/conf*目录。

```
# mkdir -p /diskless/1/conf/198.51.100.101/etc/ssh
# cd /diskless/1/conf/198.51.100.101/etc/ssh
```

在此目录中，为你的 SSH 版本使用的每种算法创建 SSH 密钥。虽然 ssh-keygen(1) 包含 `-A` 标志以自动生成缺失的密钥，但它会将这些密钥放在*/etc/ssh*中。这对你的无盘用户环境甚至在 chroot 中都不起作用。你需要通过传统的方式来创建这些密钥。

```
# ssh-keygen -N "" -qt algorithm -f ssh_host_algorithm_key
```

你需要将加密算法的名称替换为小写两次。例如，这里是如何创建一个 DSA SSH 密钥：

```
# ssh-keygen -N "" -qt dsa -f ssh_host_dsa_key
```

今天，OpenSSH 为 RSA、ECDSA 和 ED25519 创建密钥。为每种算法创建密钥。密钥创建非常容易脚本化。查看*/etc/rc.d/sshd*中的示例。

无盘客户端让你轻松地运行成千上万几乎相同的机器。现在我们来看看如何保护其中的一台。

### 存储加密

FreeBSD 支持两种不同的磁盘加密方法，GBDE 和 GELI。两种工具工作方式完全不同，支持不同的加密算法，并针对不同的威胁模型设计。人们常常谈论加密磁盘，但很少有人讨论磁盘加密到底是为了保护磁盘免受什么样的威胁。

*GBDE*（基于几何的磁盘加密）在高安全性环境中具有特定的功能，在这些环境中，保护用户与隐藏数据同样重要。除了用户提供的加密密钥外，GBDE 还使用存储在硬盘特定扇区中的密钥。如果任一密钥不可用，则无法解密分区。为什么这很重要？如果一个安全数据中心（例如在大使馆）遭到攻击，操作员可能会有一两分钟的时间来摧毁硬盘上的密钥并使数据无法恢复。如果坏人把枪指着我的头，告诉我“输入密码，否则怎样”，我希望磁盘系统能说：“密码正确，但密钥已被销毁”。我不想要一个泛泛的错误提示：“无法解密磁盘”。在第一种情况下，我仍然作为一个支离破碎的人质有一定价值；在后一种情况下，我要么死了，要么攻击者会变得非常有创意。^(3)

GELI 更加灵活，但它不像 GBDE 那样能保护我免受身体伤害。如果有人可能因为我笔记本上的机密文件而偷走我的电脑，或者如果一个不受信任的系统用户可能窥探我的交换空间来窃取秘密，GELI 足够用了。GELI 并不试图保护我的人身安全，只保护我的数据。由于我不会从事任何可能增加暴露于枪支的工作（考虑到我住在底特律），这对我来说完全没问题。GELI 还使用 FreeBSD 的加密设备驱动程序，这意味着如果你的服务器有硬件加速器，GELI 会透明地利用它。

我应该提到，人们因为加密配置错误或丢失密钥而损失的数据，远多于因为笔记本被盗。当我听到有人说“我已经加密了整个硬盘！”时，我几乎能预见未来那个同一个人会说：“我丢失了对硬盘上所有内容的访问！”通常我没错。仔细考虑一下你是否真的*需要*磁盘加密。如果你确实需要它，也要备份你的文件。那些政府特工不会破解你笔记本上的加密，他们会等你自己解密——然后他们才会入侵。

如果你想加密你的笔记本，使用 FreeBSD 安装程序来完成这项工作。你仍然应该阅读这一节，以便理解磁盘加密是如何工作的，但如果安装程序愿意为你做这项工作，就让它去做。我们将通过使用 GELI 加密*/dev/da0*上的磁盘分区，并将加密密钥存储在挂载于*/media*的 USB 存储设备上。你可能会觉得使用文件系统中的文件（见第十三章）作为加密分区更为合理。实际上很少有人需要加密整个硬盘，在某些情况下，加密整个硬盘可能会引起怀疑。我已经够麻烦地向机场安检解释我的电脑“看起来如此奇怪”了。在他们看来，一个显示`插入加密密钥并输入加密密码`的启动提示，离`此人是` `一个危险`的疯子，可能需要进行非常彻底的身体检查`只有一步之遥。如果你真的需要加密某些文件，通常它们的总大小只有几兆字节。那正是使用文件系统中的文件或闪存驱动器的完美应用场景。

请注意，你必须在使用 GELI 之前加载*geom_eli.ko*内核模块。

#### *生成和使用加密密钥*

GELI 允许你使用密钥文件和/或密码短语作为加密设备的加密密钥。我们将同时使用这两者。要生成你的加密密钥文件，使用 `dd(1)` 从 */dev/random* 获取适量的数据并写入到文件中。记住，*/media* 是我们的 USB 设备挂载点。如果你真的想保护你的数据，最好直接在 USB 设备上创建密钥，而不是把它保存在你的文件系统中，以防假设的入侵者恢复它。（即使删除文件，依然会留下痕迹，熟练的攻击者有可能提取这些残留数据。）

```
# dd if=/dev/random of=/media/da0p1.key bs=64 count=1
1+0 records in
1+0 records out
64 bytes transferred in 0.000149 secs (429497 bytes/sec)
```

这 64 字节的数据构成了一个 512 位的密钥。如果你愿意，可以增加密钥的大小，但这会在访问加密文件系统时增加额外的处理器负载。别忘了，你的密码短语也会增加密钥的复杂性。

要为密钥分配密码短语，使用 `geli init`。`-s` 标志告诉 geli(8) 加密文件系统所需的扇区大小；通常，4,096 字节或 4KB 是一个合适的扇区大小。`-K` 表示密钥文件。你还必须指定要加密的设备。

```
# geli init -s 4096 -K /media/da0p1.key /dev/da0p1
Enter new passphrase:
Reenter new passphrase:
```

密码短语与密码类似，只不过它可以包含空格并且长度没有限制。如果你真的想保护你的数据，我建议使用一个由多个单词组成、包含非字母数字字符的密码短语，并且不要使用你母语中的常见短语。

现在你已经有了一个密钥，将它附加到要加密的设备上。

```
# geli attach -k /media/da0p1.key /dev/da0p1
Enter passphrase:
```

GELI 现在知道 */dev/da0p1* 是一个加密磁盘，并且文件 */media/da0p1.key* 包含密钥文件。一旦你输入密码短语，你就可以通过新的设备节点 */dev/da0p1.eli* 访问加密磁盘的解密内容。当然，你还需要一个文件系统来存储数据。

#### *加密设备上的文件系统*

在你为加密设备构建文件系统之前，先清除磁盘上任何残留的数据。像 newfs(8) 和 zpool(8) 这样的程序并不会真正覆盖新分区中的大部分数据位；它们仅仅添加了超块，标明 inode 的位置。如果你之前使用过这块磁盘，入侵者将能够看到磁盘上的旧文件残片。更糟的是，他还会看到 GELI 放置在其中的加密数据块。在为磁盘创建文件系统之前，最好覆盖磁盘一层伪装的随机数据，这样可以让入侵者更难识别哪些块包含数据，哪些不包含数据。再次使用 `dd(1)`：

```
# dd if=/dev/random of=/dev/da0p1.eli bs=1m
```

FreeBSD 拥有无限的混乱——或者用技术术语说，*/dev/random* 是非阻塞的。用高质量的随机数覆盖整个磁盘所需的时间取决于你的存储系统。可能需要一天时间。

现在你的磁盘充满了垃圾数据，在它上面创建文件系统并将其附加到系统上。我通常会在这种加密设备上使用 UFS 文件系统。

```
# newfs /dev/da0p1.eli
# mount /dev/da0p1.eli /mnt
```

你的加密磁盘设备现在可以在 */mnt* 中访问。将你的机密文件存储在那里。

加密磁盘有更多的可能性。要么阅读 geli(8)，要么查看我的书籍《FreeBSD 精通：存储基础》（Tilted Windmill Press, 2014）。

这将引导你了解 FreeBSD 中一些较为晦涩的部分。现在让我们看看当事情*真的*出错时该怎么办。。。
