## **13

外部文件系统**

![image](img/common01.jpg)

FreeBSD 支持多种除 ZFS 和 UFS 外的文件系统。你需要通过使用光盘、闪存驱动器等与其他主机互操作。此外，FreeBSD 使用特殊用途的文件系统 devfs(5) 来管理设备节点。Jail 用户可能需要进程文件系统 procfs(5)。对于不需要在重启后存活的超快速存储，你可以将系统内存用作文件系统。你可以通过网络挂载文件系统，使用 Unix 风格的网络文件系统（NFS）或 Microsoft 的常用互联网文件系统（CIFS）。不管你如何努力避免，有时候你还是不得不挂载 ISO 镜像。

使用这些命令需要对挂载文件系统有更深入的理解。

### FreeBSD 挂载命令

我们在讨论 UFS 文件系统时曾提到过 mount(8)，但你也将使用它来将其他文件系统附加到目录树上。mount(8) 命令假设任何本地分区都使用 UFS。如果你尝试挂载一个非 UFS 文件系统，将会遇到错误。

```
# mount /dev/cd0 /media
mount: /dev/cd0: Invalid argument
```

设备节点 */dev/cd0* 代表一个光驱。我为了这个测试将光盘放入驱动器，所以应该能正常工作。然而，尝试挂载时却出现错误。要挂载 UFS 文件系统，你需要设备节点和挂载点。挂载外部文件系统时，必须使用 `-t` 参数指定文件系统类型。光盘使用 ISO 9660 文件系统，FreeBSD 称之为 cd9660。这里，我指定了挂载该光盘的文件系统，并将其挂载到 */cdrom* 目录下：

```
# mount -t cd9660 /dev/cd0 /media
```

现在我可以进入 */media* 目录查看内容。很简单，是吧？

许多文件系统都有其自定义的 mount(8) 命令变体。通过运行 `apropos mount_` 可以获取完整的列表。是的，你需要在命令末尾加下划线；所有的 mount(8) 变体都使用下划线作为分隔符。你会找到 mount_cd9660(8)、mount_msdosfs(8)、mount_nfs(8) 等等。对于没有这种命令的文件系统，始终使用 `mount -t`。

使用 `-o` 标志应用挂载选项。你需要查看每个挂载命令的 man 页面，了解文件系统支持哪些挂载选项。多个挂载选项用逗号分隔。这里，我将一个 FAT32 驱动器挂载到设备节点 */dev/da1*，并以只读方式挂载，同时将所有者和组分配给用户 *bert*：

```
# mount -t msdosfs -o ro,-gbert,-ubert /dev/da1 /media
```

你可以使用 umount(8) 卸载任何已挂载的文件系统：

```
# umount /media
```

umount(8) 命令不关心文件系统类型。它只是尝试将磁盘分区从文件系统中断开。然而，它确实关心是否有进程正在使用该文件系统，如果有进程在使用，umount(8) 会拒绝卸载该文件系统。如果你在文件系统中有一个空闲的终端并且显示 shell 提示符，umount(8) 会拒绝卸载该文件系统。

如果你经常连接和断开文件系统，建议研究一下 autofs(5) 来自动处理这些挂载。

#### *支持的外部文件系统*

下面是一些最常用的外部文件系统，以及每个文件系统的简要描述和适用的挂载命令。

##### FAT (MS-DOS)

FreeBSD 包含了广泛的 FAT 支持，FAT 是 DOS/Windows 9*x* 文件分配表文件系统，通常用于可移动媒体和一些双启动系统。此支持涵盖了 FAT12、FAT16 和 FAT32 类型。不过，你*可以*使用非 FAT 文件系统格式化 U 盘，因此不要盲目认为所有的 U 盘都使用 FAT。由于现在 U 盘最常见的用途是机器之间传输文件，因此大多数 U 盘都是 FAT32 格式。挂载类型为 `msdosfs`（`mount -t msdosfs`）。

如果你处理大量的 FAT32 磁盘，建议调查一下 `mtools` 包，它是一组用于处理 FAT 文件系统的程序，提供比默认的 FreeBSD 工具更高的灵活性。

##### ISO 9660

ISO 9660 是 CD 的标准文件系统，偶尔也用于 DVD。FreeBSD 支持读取和写入 CD，如果你有 CD 刻录机的话。几乎所有遇到的 CD 都使用 ISO 9660 格式。挂载命令是 `mount -t cd9660`。

`cdrtools` 包位于 */usr/ports/sysutils/cdrtools*，包含了许多有用的工具，用于处理 CD 镜像，包括可以从磁盘上的文件生成 ISO 镜像的工具。

##### UDF

UDF（通用磁盘格式）是 ISO 9660 的替代品。你会在一些 DVD 和 Blu-Ray 磁盘上找到 UDF，此外一些大于 FAT32 支持的 32GB 的 U 盘也使用 UDF。随着可移动媒体容量的增加，UDF 文件系统会越来越常见。挂载命令是 `mount -t udf`。

##### EXT

标准的 Linux 文件系统——EXT2、EXT3 和 EXT4——支持许多与 UFS 相同的功能。FreeBSD 可以安全地读取和写入 EXT2 和 EXT3 文件系统，但只能将 EXT4 文件系统挂载为只读模式。

挂载 Linux 文件系统最常用于灾难恢复、双启动系统或系统迁移。尽管名字如此，`mount -t ext2fs` 支持挂载所有版本的 EXT。

Linux 文件系统用户可能会发现 */usr/ports/sysutils/e2fsprogs* 中的工具很有用，它们可以让你 fsck(8) 并检查 Linux 文件系统，除此之外还有其他功能。

#### *权限和外部文件系统*

文件系统的权限取决于文件系统的特性和挂载它的人。FreeBSD 会尝试支持那些与 UFS 或 ZFS 中的特性差异不大的功能。

考虑一下 Linux 文件系统 EXT。EXT 在文件系统中存储权限，并让内核将其映射到 UID。由于 EXT 权限与 UFS 权限非常相似，并且所有必要的权限信息都可以在文件系统内找到，因此 FreeBSD 会尊重这些文件系统上的权限。然而，EXT 不支持 BSD 文件标志，因此你不能在 EXT 上为文件分配这些标志。

FAT 没有权限系统。即使你将 FAT32 U 盘挂载到 FreeBSD 主机上，也无法对文件应用权限。

默认情况下，只有 root 用户可以挂载文件系统，并且 root 拥有所有非 Unix 文件系统。如果这不是你想要的配置，你可以使用`-u`和`-g`标志来设置挂载 FAT32、ISO 9660 或 UDF 文件系统时的用户 ID 和组 ID。例如，如果你要为用户*xistence*挂载一个 FAT32 USB 设备，并希望他能够编辑其内容，可以使用以下命令：

```
# mount -t msdosfs -u xistence -g xistence /dev/da5 /mnt
```

现在，用户*xistence*拥有设备上的文件。

你可能会厌倦为用户挂载介质，尤其是在拥有数十台机器的设施中。要允许用户挂载文件系统，可以将 sysctl `vfs.usermount`设置为`1`。用户就可以在他们有权限访问的任何挂载点上挂载任何设备。虽然*xistence*不能将可移动设备挂载到*/media*，但他可以将其挂载到*/home/xistence/media*。

### 使用可移动介质

你必须能够管理任何可能进入数据中心的可移动介质。在这里，我们将讨论光盘和闪存驱动器。

我建议不要随便把可移动介质插入你的生产服务器——至少出于安全原因，应该避免这样做。谁知道那个供应商的 USB 设备上到底有什么？更糟糕的是，你甚至可以订购“USB 杀手”设备，它们故意损坏硬件。将可疑设备挂载在可丢弃的工作站上，检查其内容，然后将所需的数据复制到 FreeBSD 机器上。这并不能保证安全，因为许多 USB 接口可以在操作系统层下面注入数据，但这是你能做到的最安全方式。然而，某些应用程序仍然觉得可移动介质太方便，当然，当是我的个人 USB 设备时，规则会有所不同。

使用设备需要一个文件系统类型、一个设备节点和一个挂载点。

确定可移动驱动器的文件系统可能需要一些试验和错误。CD 使用 ISO 9660 文件系统，而 DVD 和蓝光光盘则使用 UDF 或 ISO 9660 和 UDF 的组合。若不确定，首先尝试 CD9660。USB 设备和软盘通常使用 FAT32。虽然曾经预计大容量 USB 设备会使用 UDF，但大多数仍然使用 FAT32。运行 fstyp(8)命令来帮助识别设备节点上的文件系统，或者可以在磁盘的设备节点上尝试`gpart show`。

可移动设备每次插入时可能会有不同的设备节点。光驱稍微容易识别，因为大多数主机的光驱数量非常少。如果你有一个光驱，它的设备节点是*/dev/cd0*。USB 设备会显示为*/dev/da*的下一个可用单元。当你插入 USB 设备时，控制台和*/var/log/messages*会显示一个包含设备节点和类型的消息，或者你也可以通过`camcontrol devlist`查看新设备。

FreeBSD 提供了一个*/media*挂载点用于一般的*可移动媒体*挂载。你可以根据需要创建其他挂载点——它们只是目录。对于一些杂项的短期挂载，FreeBSD 提供了*/mnt*。

所以，要将你的 FAT32 USB 设备*/dev/da0*挂载到*/media*，运行：

```
# mount -t msdosfs /dev/da0 /media
```

偶尔，你会发现一个带有分区表的 U 盘。这些设备会要求你挂载*/dev/da0s1*或*/dev/da0p1*，而不是*/dev/da0*。这是设备的格式化方式所决定的，而不是 FreeBSD 的设置。`gpart show`命令可以帮助你弄清楚设备上的分区以及每个分区上的文件系统。

#### *弹出可移动媒体*

要从 FreeBSD 系统中断开可移动媒体，首先卸载文件系统。直到卸载磁盘之前，光驱将无法打开。你可以从端口拔出 USB 闪存驱动器，但在文件系统挂载的情况下拔出可能会损坏设备上的数据。像对待任何其他文件系统一样，使用 umount(8)：

```
# umount /media
```

在许多光驱上，`camcontrol eject`可以打开驱动器托盘。

#### *可移动媒体和/etc/fstab*

你可以通过更新*/etc/fstab*来为可移动媒体添加条目，以便简化系统维护。如果一个可移动文件系统在*/etc/fstab*中有条目，你可以在挂载时省略文件系统和设备名称。这意味着你不必记住精确的设备名称或文件系统来挂载设备。

在*/etc/fstab*中列出可移动媒体时，务必包含`noauto`标志。否则，每当你没有插入可移动媒体时，启动过程会停在单用户模式，因为缺少文件系统。

这是光驱的*/etc/fstab*条目：

```
/dev/cd0   /cdrom   cd9660  ro,noauto       0       0
```

虽然我确信你已经记住了*/etc/fstab*中每一列的含义，但我们仍然提醒你，这个条目的意思是，“将*/dev/cd0*挂载到*/cdrom*，使用 ISO 9660 文件系统。将其设置为只读，并且在启动时不要自动挂载。”

这里是一个类似的 U 盘条目。我使用`large`选项来支持大于 128GB 的文件系统，如 mount_msdosfs(8)中所述。

```
➊/dev/da0    /media    msdosfs  rw,noauto,large     0       0
```

FreeBSD 默认不提供这些设置，但在我经常使用可移动媒体的系统中，拥有这些设置会更加方便。确认你下一个可用的 da 设备是*/dev/da0* ➊，因为尝试挂载一个已经挂载的硬盘是无法成功的。

#### *格式化 FAT32 媒体*

U 盘使用 FAT32 文件系统，但总是已经预格式化。由于 U 盘的读写次数与其价格成反比，切勿轻易重新格式化它们。^(1) 只有在文件系统损坏时才重新格式化 U 盘。使用 newfs_msdos(8)来创建 FAT32 文件系统。

```
# newfs_msdos /dev/da0
```

你会看到几行输出，并且你会有一个新的文件系统。

#### *创建光盘介质*

FreeBSD 允许你将多个文件打包成适合刻录到 CD、DVD 或 Blu-Ray 上的镜像，使用 CD 9660 或 UDF 格式。你可以将任一镜像刻录到磁盘上。FreeBSD 原生支持创建 ISO 文件，但你需要从`cdrtools`包中获取程序来创建 UDF。

无论哪种方式，首先将你想要刻录的所有文件和目录放入一个单一的目录。镜像将包含这些文件和目录，按照你安排的方式保存。记住，光盘镜像是只读的。你不能更新一个镜像；你只能创建一个新的镜像，所以一定要确保所有内容都正确无误。稍后本章你将学到如何使用 mdconfig(8)挂载这些镜像。

在这两个示例中，我们都是从*/home/xistence/cdfiles*中的文件创建一个镜像。

##### 创建 ISO

使用 makefs(8)来创建 ISO。

```
# makefs ➊-t cd9660 ➋-o allow-deep-trees,rockridge ➌image.iso ➍source-files
```

首先使用`-t` ➊指定要创建的文件系统类型——在本例中是 CD 9660。`-o`标志➋允许你指定特定于文件系统的选项。你可以从 makefs(8)的手册页中获得完整的选项列表，但这里显示的选项对于大多数镜像已经足够。接下来，我们需要指定创建的镜像文件名 ➌ 和源目录 ➍，该目录中包含要复制的文件。

要创建一个包含*/home/xistence/cdfiles*中所有文件的镜像，并命名为*bert.iso*，运行：

```
# makefs -t cd9660 -o allow-deep-trees,rockridge bert.iso /home/xistence/cdfiles
```

Bert 现在可以浪费地将 ISO 刻录到物理介质上。

##### 创建 UDF

创建 UDF 需要使用来自`cdrtools`包的 mkisofs(1)命令。使用`-o`指定目标镜像文件。使用`-J`和`-R`分别启用 Joliet 和 Rock Ridge 扩展。（我不会详细说明这些选项的作用，但如果你希望 ISO 像本世纪的光盘一样工作，你需要它们。）添加`-udf`和`-iso-level 3`标志。^(2)

```
# mkisofs -R -J -udf -iso-level 3 -o bert.udf /home/xistence/cdfiles
```

现在你已经有了一个基于*/home/xistence/cdfiles*内容的 UDF 镜像。

无论你创建哪种格式，我建议你在刻录物理光盘之前先挂载它，并仔细检查你的工作。如果你幸运的话，你会记得在镜像中忘记包含的东西。

##### 刻录 ISO 到光学介质

使用来自`cdrtools`包的 cdrecord(1)命令将 ISO 镜像刻录到光盘。将镜像文件作为参数提供。

```
# cdrecord bert.iso
```

根据驱动器速度和映像大小，这可能需要一些时间。

cdrecord(1)程序默认使用*/dev/cd0*。如果你有其他光驱，可以使用`-dev`标志指定另一个设备名称。

```
# cdrecord -dev=cd9 bert.iso
```

现在你有了一张脆弱的塑料光盘，你将在使用两次后把它丢进垃圾填埋场。恭喜！

##### 将 UDF 刻录到光学介质

虽然你*可以*使用 cdrecord(1)将 UDF 镜像刻录到介质上，但通常推荐使用`dvd+rw-tools`包中的 growisofs(1)命令。你需要使用`-dvd-compat`和`-Z`标志。然后，指定设备和镜像文件。

```
# growisofs -dvd-compat -Z /dev/burner=image.udf
```

假设我想将*bert.udf*刻录到*/dev/cd0*的蓝光光盘中。

```
# growisofs -dvd-compat -Z /dev/cd0=bert.udf
```

UDF 文件可能非常大。去泡杯茶吧。最终，你会得到一张刻录好的光盘。

#### *将映像写入闪存驱动器*

USB 闪存驱动器由于其可重复使用性，逐渐取代了光盘。FreeBSD 支持使用 dd(1)命令将磁盘映像写入闪存驱动器。

一定要非常确定哪个设备节点是你的 U 盘，哪个是你的系统硬盘。U 盘显示为 */dev/da* 设备，就像许多硬盘一样。覆盖错误的硬盘是非常尴尬的。^(3)

dd(1) 命令乍一看可能会让人感到困惑。

```
# dd ➊if=inputfile ➋of=outputdevice ➌bs=1M ➍conv=sync
```

`if=` 参数 ➊ 指定你要复制的文件。`of=` 参数 ➋ 指定你要复制到的设备节点。`bs=` 标志 ➌ 指定一次复制的数据量。如果没有这个，dd(1) 会按 512 字节递增进行复制。`conv=` 参数 ➍ 给 dd(1) 提供如何转换输入文件的指令。在这种情况下，*sync* 告诉 dd(1) 同步输入和输出缓冲区的大小。为了将 *bertimage.udf* 刻录到 U 盘 */dev/da9*，我会运行：

```
# dd if=bert.udf of=/dev/da9 bs=1m conv=sync
```

等一下，你就会得到一个镜像的 U 盘。dd(1) 的其他用法可能不需要 `conv=` 标志，但始终使用 `bs`。

现在让我们看看一些你可能会发现有用的其他文件系统。

### 内存文件系统

除了将文件系统放在磁盘或分区上，FreeBSD 还允许你从文件、纯 RAM 或两者的组合中创建分区。这个功能最常见的用途之一是 *内存文件系统* 或 *内存磁盘*。将文件读写到内存中的速度比访问磁盘上的文件要快得多，这使得内存支持的文件系统在某些应用中是一项巨大的优化。然而，和其他所有内存操作一样，你会在系统关闭时丢失内存磁盘中的内容。

FreeBSD 支持两种不同的内存支持磁盘：*tmpfs*（发音为“temp f s”）和*内存磁盘*。虽然它们背后有相似的概念，但底层代码完全不同，而且它们的作用也不同。在长期运行的系统上使用 tmpfs(5) 作为内存支持文件系统。内存磁盘更加灵活，但更适合短期使用或挂载磁盘镜像。

#### *tmpfs*

tmpfs(5) 中的 *tmp* 并不意味着“临时”。它字面上意味着 *tmp*，即 */tmp*。使用 tmpfs 来加速内存支持的 */tmp* 和类似的文件系统。不过，不要在你看到路径中有 *tmp* 时就到处部署 tmpfs。虽然 */tmp* 应该在每次启动时清空，但 */var/tmp* 应该在重启后依然存在。你可能会使用 tmpfs 来处理应用程序锁文件和其他短暂数据，这些数据的速度大幅提升会改善应用程序性能。尽管 tmpfs 曾有过一段困难的历史，但从 FreeBSD 10 开始，它已广泛部署并被认为可以用于生产环境。

通过挂载来创建一个 tmpfs。

```
# mount -t tmpfs tmpfs /tmp
```

如果你的系统将 sysctl `vfs.usermount` 设置为 1，用户就可以创建和挂载 tmpfs 文件系统。

##### tmpfs 选项

默认情况下，tmpfs 的大小为系统可用的 RAM 加上可用的交换空间。反复将文件复制到 */tmp* 可能会耗尽系统内存。这将是非常糟糕的。通过 `size` 选项为你的 tmpfs 设置一个最大大小。

```
# mount -o size=1g -t tmpfs tmpfs /tmp
```

使用 `uid`、`gid` 和 `mode` 选项来控制 tmpfs 的所有权和权限。实际的 */tmp* 目录需要具有世界可写权限，并设置粘滞位，因此请确保使用选项 `mode=1777`。

如果 tmpfs 是为特定用户而设置的，即使是只运行一个应用程序的无特权用户，也应将该用户的所有权分配给 tmpfs。

##### Boot 时的 tmpfs

现在你可以设置最大大小和适当的权限，因此可以使用 */etc/fstab* 来自动在启动时创建 tmpfs。

```
tmpfs  /tmp  tmpfs  rw,mode=1777,size=1G  0  0
```

对于更复杂的内存后备磁盘，可以考虑使用传统的内存磁盘。

#### *内存磁盘*

内存磁盘是一个短暂的存储设备。尽管名称是内存磁盘，内存磁盘并不总是将一块内存当作磁盘来使用。它也可以是这样一个设备，但它可能使用文件、交换空间或其他后备存储。无论如何，内存磁盘在系统关闭时会消失。

##### 内存磁盘类型

内存磁盘有四种类型：malloc-backed、swap-backed、vnode-backed 和 null。

*Malloc-backed* 内存磁盘是纯内存磁盘。即使系统内存不足，FreeBSD 也不会将 malloc-backed 磁盘交换出去。与 tmpfs(5) 类似，使用大容量的 malloc-backed 磁盘是耗尽系统内存的一种好方法。Malloc-backed 磁盘对于没有交换空间的嵌入式设备特别有用。

*Swap-backed* 内存磁盘大多数是内存，但它们也会访问系统的交换分区。如果系统内存不足，它会将最近最少使用的内存部分移动到交换区，正如在第二十一章中讨论的那样。Swap-backed 磁盘通常是速度和性能之间最好的折衷。

*Vnode-backed* 内存磁盘是磁盘上的文件。虽然你可以使用文件作为内存磁盘的后备存储，但这主要用于挂载磁盘映像和测试。

*Null* 内存磁盘会丢弃发送到它的所有内容。所有写入操作都会成功，而所有读取操作都返回零。如果我没有提到 null 内存磁盘，可能有人会写信抱怨，但我不会再给一个保证丢失所有数据的磁盘更多的介绍。

一旦你知道想要做什么，就使用 mdmfs(8) 执行操作。

##### 创建和挂载内存磁盘

mdmfs(8) 工具是多个程序的便捷前端，例如 mdconfig(8) 和 newfs(8)。它处理设备配置和文件系统创建的繁琐工作，使创建内存磁盘尽可能简单。你只需知道你想使用的磁盘大小、内存磁盘类型和挂载点。

Swap-backed 内存磁盘是默认设置。只需告诉 mdmfs(8) 磁盘的大小和挂载点。这里，我们在 */home/mwlucas/test* 上创建了一个 48MB 的 swap-backed 内存磁盘：

```
# mdmfs -t -s 48m md /home/mwlucas/test
```

`-s` 标志指定磁盘大小。如果你运行 mount(8) 而不带任何参数，你会看到你现在已经在该目录上挂载了内存磁盘设备 */dev/md0*。

`-t` 标志启用 TRIM，我们将在接下来的“内存磁盘问题”一节中讨论。

要创建并挂载一个 malloc 支持的磁盘，添加`-M`标志。

要挂载一个 vnode 支持的内存磁盘，使用`-F`标志并指定映像文件的路径。

```
# mdmfs -F diskimage.file md /mnt
```

我们一直使用的`md`条目意味着，“我不在乎我得到什么设备名称，给我下一个空闲的就行。”你也可以指定一个特定的设备名称，如果你愿意的话。在这里，我声明我想要磁盘设备*/dev/md9*：

```
# mdmfs -F diskimage.file md9 /mnt
```

##### 内存磁盘头痛

传统的交换支持的内存磁盘从未将已使用的内存返回给系统。一旦你写入内存磁盘，那块内存就被消耗掉了。如果你需要一个更大的内存磁盘，你必须为其永久分配内存。这是 FreeBSD 包括 tmpfs(5)的原因之一。

然而，如果内存磁盘上的文件系统支持*TRIM*，FreeBSD 现在会将未使用的内存返回给系统。TRIM 不是一个缩写，而是一种告诉磁盘哪些扇区不再使用的协议。UFS，默认的内存磁盘格式，支持 TRIM。在 mdmfs 中通过`-t`标志启用 TRIM。如果你在内存磁盘上使用的是其他文件系统，请确保它是严格临时的。

要释放内存磁盘的内存，关闭内存磁盘。

##### 内存磁盘关闭

要移除内存磁盘，必须卸载分区并销毁磁盘设备。销毁磁盘设备会释放该设备占用的内存，这在系统负载较重时非常有用。要找到磁盘设备，运行 mount(8)并查找你的内存磁盘分区。在输出的某个位置，你会找到类似这样的行：

```
/dev/md41 on /mnt (ufs, local, soft-updates)
```

在这里，我们看到内存磁盘*/dev/md41*挂载在*/mnt*上。让我们卸载并销毁它。

```
# ➊umount /mnt
# mdconfig ➋-d ➌-u 41
```

使用`umount` ➊卸载就像处理其他文件系统一样。mdconfig(8)调用是一个新的命令。使用 mdconfig(8)直接管理内存设备。`-d`标志 ➋表示*销毁*，`-u`标志 ➌提供一个设备号。上述操作销毁了设备*/dev/md41*，即`md`设备号 41。该设备占用的内存现在被释放，可以供其他用途。

##### 内存磁盘与/etc/fstab

如果你在*/etc/fstab*中列出了内存磁盘，FreeBSD 会在启动时自动创建它们。这些条目看起来比其他条目复杂，但如果你理解我们到目前为止使用的 mdmfs(8)命令，其实也不难。

我们可以使用*md*作为设备名称来表示内存磁盘。选择挂载点，就像任何其他设备一样，并使用文件系统类型`mfs`。在`Options`下，列出*rw*（表示可读写）以及用于创建此设备的命令行选项。如果这是一个长期挂载，添加`-t`以启用 TRIM。要创建一个 48MB 的文件系统并将其挂载到*/home/mwlucas/test*，使用以下*/etc/fstab*条目：

```
md      /home/mwlucas/test      mfs      rw,-s48m,-t      0   0
```

看起来很简单，是不是？唯一的问题是，长长的一行会弄乱你漂亮整齐的*/etc/fstab*条目的外观。好吧，它们并不是唯一会让这个文件变丑的东西，正如我们很快将看到的。

#### *挂载磁盘映像*

你可以使用 mdmfs(8)查看 UFS 磁盘镜像，但通常你希望查看 ISO 或 UDF 文件的内容，而不需要将其刻录到磁盘上。（FreeBSD 的 tar(1)可以访问 ISO 的内容，但无法访问 UDF。）只需使用 mdconfig(8)命令的`-a`标志将内存磁盘附加到文件。这里，我将 Bert 的 ISO 附加到一个内存设备：

```
# mdconfig ➊-a -t ➋vnode -f ➌/home/mwlucas/bert.iso
➍md0
```

我们告诉 mdconfig(8)将一个基于 vnode 的内存设备➊附加到指定的文件➌。mdconfig(8)命令响应并告诉我们它附加到的设备➍。现在，我们只需使用适当的挂载命令将该设备挂载到文件系统：

```
# mount -t cd9660 /dev/md0 /mnt
```

我现在可以验证 ISO 中包含了 Bert 的文件，这样他就不会抱怨 ISO 文件坏掉了。

在这一步，常见的错误是没有指定文件系统类型就挂载镜像。你可能会遇到错误，或者可能会成功挂载但没有数据——默认情况下，mount(8)会假设文件系统是 UFS！

完成数据访问后，请确保卸载镜像并销毁内存磁盘设备，就像你对待任何其他内存设备一样。虽然基于 vnode 的内存磁盘不会消耗系统内存，但如果你留下未使用的内存设备，几个月后你可能会困惑为什么它们出现在*/dev*中。如果你不确定系统上有哪些内存设备，可以使用`mdconfig -l`查看所有已配置的 md(5)设备。

```
# mdconfig -l
md0 md1
```

我有两个内存设备？添加`-u`标志和设备编号，看看它是什么类型的内存设备。让我们来看一下内存设备 1（*/dev/md1*）是什么：

```
# mdconfig -l -u 1
md1     vnode     456M  /slice1/usr/home/mwlucas/iso/omsa-51-live.iso
```

我在这个系统上挂载了一个 ISO 镜像？哇。我可能应该在某个月重启一下。算了，太麻烦了，我直接卸载文件系统并销毁内存设备就好了。

#### *文件系统中的文件*

嵌入式系统中使用的一个技巧是将完整的文件系统镜像构建在本地文件中。在前一部分中，我们看到如何使用内存磁盘挂载和访问 CD 磁盘镜像。你可以使用相同的技术来创建、更新和访问 UFS 磁盘镜像。

要在文件中使用文件系统，必须创建一个合适大小的文件，将该文件附加到内存设备上，在设备上放置文件系统，然后挂载该设备。

##### 创建空的文件系统文件

使用 truncate(1)创建一个空的文件系统文件。这些文件是稀疏文件：它们标记为具有某个大小，但在你往里面放东西之前并不会占用任何空间。一个空的稀疏文件只占用一个文件系统块，放入数据后它才会增长。这意味着你可以为任意大小的磁盘创建一个镜像文件，但实际占用的空间只等于你放入镜像中的数据量。

使用`-s`选项和文件大小来创建镜像文件。这里，我创建了一个 1GB 的文件：

```
# truncate -s 1G filesystem.file
```

结果文件显示它的大小相当大。

```
# ls -l filesystem.file
-rw-r--r--  1 mwlucas  mwlucas  1073741824 Aug 11 11:31 filesystem.file
```

但是，如果你检查磁盘使用情况，你会看到不同的结果。

```
# du filesystem.file
1       filesystem.file
```

这个 1GB 的文件在磁盘上使用一个块。

稀疏文件永远不会缩小。它们只能增长。如果你从磁盘镜像中删除了大量文件，镜像文件仍然需要这些空间。

此外，并不是所有文件系统都支持稀疏文件。UFS 和 ZFS 支持。如果你正在尝试在 FAT32 文件系统上创建稀疏文件，那可能是你在解决错误的问题。

##### 在文件上创建文件系统

要在文件上获取文件系统，首先通过 vnode 支持的内存磁盘将文件与设备关联。我们在上一节中做的就是这个操作：

```
# mdconfig -a -t vnode -f filesystem.file
md0
```

现在，让我们在这个设备上创建一个文件系统。这很像在一个闪存盘上使用 newfs(8) 命令创建 UFS 文件系统。软更新日志与文件支持文件系统一样对磁盘支持的文件系统非常有用，因此通过 `-j` 启用它们。

```
# newfs -j /dev/md0 
/dev/md0: 1024.0MB (2097152 sectors) block size 32768, fragment size 4096
        using 4 cylinder groups of 256.03MB, 8193 blks, 32896 inodes.
        with soft updates
super-block backups (for fsck_ffs -b #) at:
 192, 524544, 1048896, 1573248
Using inode 4 in cg 0 for 8388608 byte journal
newfs: soft updates journaling set
```

newfs(8) 程序会输出磁盘的基本信息，例如其大小、块和碎片大小，以及 inode 数量。

现在你已经有了一个文件系统，挂载它：

```
# mount /dev/md0 /mnt
```

恭喜！你现在拥有了一个 1GB 的文件支持文件系统。你可以将文件复制到其中，将其转储到磁带上，或以任何你使用其他文件系统的方式使用它。但除此之外，你还可以像对待其他文件一样移动它。

##### 文件支持文件系统和 /etc/fstab

你可以通过在 */etc/fstab* 中添加正确的条目，自动在启动时挂载文件支持文件系统，就像自动挂载其他内存磁盘一样。你只需使用 `-F` 指定文件名，并使用 `-P` 告诉系统不要在这个文件上创建新文件系统，而是使用已经存在的那个文件系统。在这里，我们将创建的文件支持文件系统自动挂载到 */mnt*，并在启动时挂载。

```
md    /mnt     mfs     rw,-P,-F/home/mwlucas/filesystem.file    0    0
```

我告诉过你，我们会看到比通用内存磁盘更丑的 */etc/fstab* 条目，是吧？

### devfs

devfs(5) 是一个用于管理设备节点的动态文件系统。记住，在类 Unix 操作系统中，*一切*都是文件。这包括物理硬件。几乎所有系统上的设备都有一个 */dev/* 下的设备节点。你已经见过一些磁盘的设备节点，但你也会看到键盘（*/dev/ukbd0* 或 */dev/kbd0*）、控制台（*/dev/console*）、音频混音器（*/dev/mixer0*）等等。你还会找到逻辑设备的设备节点，例如随机数生成器（*/dev/random*）、终端会话（*/dev/ttyv0*）等等。

曾几何时，系统管理员负责创建这些设备节点文件。幸运的系统管理员管理着一个带有用于处理设备节点创建和权限的 shell 脚本的操作系统。如果操作系统的开发者没有提供这样的脚本，或者如果服务器有不包含在脚本中的特殊硬件，那么系统管理员就得通过动物祭祀和 mknod(8) 创建节点。如果出现任何小问题，设备就无法正常工作。另一种选择是将操作系统与每种硬件设备的设备节点一起发布。系统管理员可以放心——嗯，*大致*放心——所需的设备节点在某个地方，埋藏在 */dev* 下的成千上万的文件中。

当然，内核确切知道每个设备节点应该具有什么特性。使用 devfs(5)，FreeBSD 仅询问内核系统应具备哪些设备节点，并提供这些设备节点——没有更多。对于大多数人来说，这样的方式非常有效。不过，你我并非“多数人”。我们对计算机有着不同寻常的需求。或许我们需要使用不同的名称来访问设备节点、改变设备节点的所有权，或者独特地配置硬件。FreeBSD 将设备节点管理的问题分解为三部分：启动时配置设备、全局可用性与权限以及配置启动后通过 devd(8) 动态出现的设备。

#### */dev 启动时*

当设备节点是磁盘上的永久文件时，系统管理员可以创建指向这些节点的符号链接或更改它们的权限，而不必担心这些更改会消失。随着自动化的动态设备文件系统，这种保障消失了。（当然，你也不再需要担心神秘的 mknod(8) 命令了，所以从长远来看，你会受益。）设备节点的更改可能包括例如：

+   使设备节点以不同名称可用

+   更改设备节点的所有权

+   隐藏设备节点不让用户访问

**设备管理与服务器**

在大多数情况下，服务器上的设备节点管理工作无需任何调整或干预。我最常需要调整设备节点的地方是在笔记本电脑和偶尔的工作站上。FreeBSD 的设备节点管理工具非常强大且灵活，支持一些我不曾预料到的使用方式。我们只讨论基础部分。不要认为你必须精通 devfs(5) 才能让你的服务器运行得很好！

在启动时，devfs(8) 根据 */etc/devfs.conf* 中的规则创建设备节点。

##### devfs.conf

*/etc/devfs.conf* 文件允许您为启动时可用的设备创建链接、改变所有权和设置权限。每条规则的格式如下：

```
action      realdevice      desiredvalue
```

有效的操作包括 `link`（创建链接）、`perm`（设置权限）和 `own`（设置所有者）。`realdevice` 条目是一个预存在的设备节点，而最后一个设置是您所需的值。例如，在这里我们为设备节点创建一个新名称：

```
➊link      ➋cd0           ➌cdrom
```

我们希望为设备节点 */dev/cd0* ➋（光驱）创建一个符号链接 ➊，并希望该链接命名为 */dev/cdrom* ➌。只要我们在 */etc/devfs.conf* 文件中添加这条规则并重启，光驱 */dev/cd0* 就会以 */dev/cdrom* 的形式出现，正如许多桌面多媒体程序所期望的那样。

要更改设备节点的权限，请以八进制形式提供所需的权限值：

```
perm        cd0            666
```

在这里，我们设置 */dev/cd0*（我们的 CD 设备）的权限，以便任何系统用户都可以读取或写入该设备。记住，更改 */dev/cdrom* 链接的权限不会更改设备节点的权限，只会更改符号链接的权限。

最后，我们也可以更改设备的所有权。更改设备节点的所有者通常表示你正在以错误的方式解决问题，可能需要停下来思考。FreeBSD 虽然允许你如果坚持的话，随意搞砸系统，但还是能让你做这些操作。在这里，我们让一个特定的用户对磁盘设备*/dev/da20*拥有绝对控制权限：

```
own         da20            xistence:xistence
```

然而，这可能不会产生预期的效果，因为有些程序仍然认为你必须是 root 用户才能执行设备上的操作。我见过不止一个软件如果不是由 root 用户运行，甚至在未尝试访问其设备节点之前就自行关闭。更改设备节点权限不会阻止这些程序在普通用户运行时的抱怨。

使用 devfs.conf(5)进行配置解决了许多问题，但并非所有问题。如果你想让一个设备节点完全不可见且不可访问，你必须使用 devfs 规则。

#### *全局 devfs 规则*

每个 devfs(5)实例的行为都遵循*devfs.rules*中定义的规则。devfs 规则适用于启动时存在的设备和动态出现或消失的设备。规则允许你设置设备节点的所有权和权限，并使设备节点可见或不可见。你不能使用 devfs 规则创建指向设备节点的符号链接。

类似于*/etc/rc.conf*和*/etc/defaults/rc.conf*，FreeBSD 使用*/etc/devfs.rules*和*/etc/defaults/devfs.rules*。为你的自定义规则创建一个*/etc/devfs.rules*，并保持默认文件中的条目不变。

##### devfs 规则集格式

每一组 devfs 规则以一个名称和一个方括号中的规则集编号开始。例如，这是来自默认配置的一个 devfs 规则：

```
[➊devfsrules_hide_all=➋1]
➌add hide
```

*devfs.rules*中的第一条规则被称为`devfs_hide_all` ➊，并且是规则集编号 1 ➋。这个规则集只包含一条规则 ➌。

一旦你有了一组喜欢的 devfs 规则，就可以在启动时在*/etc/rc.conf*中启用它们。这里，我们激活了名为`laptoprules`的 devfs 规则集：

```
devfs_system_rulesets="laptoprules"
```

请记住，devfs 规则适用于启动时系统中的设备，以及启动后动态配置的设备。

##### 规则集内容

所有 devfs 规则（在文件中）都以单词`add`开始，以将规则添加到规则集中。然后，你可以选择使用`path`关键字和设备名称的正则表达式，或者使用`type`关键字和设备类型。在规则的末尾，你有一个*动作*，或者是执行的命令。以下是一个 devfs 规则的示例：

```
add path da* user mwlucas
```

该规则将用户*mwlucas*的所有权分配给所有名称以`da`开头的设备节点。这可能不是一个好主意。

通过路径指定的设备使用标准的 Shell 正则表达式。如果你想匹配多种设备，可以使用星号作为通配符。例如，`path ada1s1`仅匹配设备*/dev/ada1s1*，而`path ada*s*`匹配所有以`ada`开头，后跟一个字符，字母`s`，并且可能有更多字符的设备节点。你可以通过在命令行上使用通配符来精确了解匹配了哪些设备。

```
# ls /dev/ada*s*
```

这将列出你所有 SATA 硬盘上的所有 MBR 切片和分区，但不包括整个硬盘的设备。

`type` 关键字表示你希望规则应用于给定类型的所有设备。有效的关键字包括 `disk`（磁盘设备）、`mem`（内存设备）、`tape`（磁带设备）和 `tty`（终端设备，包括伪终端）。`type` 关键字很少使用，因为它的作用范围太广。

如果你既没有包含 `path` 也没有包含 `type`，devfs 会将规则末尾的动作应用到所有设备节点。在几乎所有情况下，这都是不希望的。

规则集动作可以是 `group`、`user`、`mode`、`hide` 和 `unhide` 中的任何一种。`group` 动作让你设置设备的组所有者，作为附加参数。类似地，`user` 动作分配设备所有者。在这里，我们将 `da` 磁盘的所有权设置为用户名 *desktop* 和组 *usb*：

```
add path da* user desktop
add path da* group usb
```

`mode` 动作允许你以标准的八进制形式分配设备的权限。

```
add path da* mode 664
```

`hide` 关键字可以让你让设备节点消失，`unhide` 让它们重新出现。由于没有程序可以使用不可见的设备节点，这在除了系统使用 jail(8) 时的用途有限。隐藏和重新显示最有意义的场景是包含规则中的规则。

##### 在规则中包含规则

和许多系统管理方面一样，使 devfs 规则模块化以便重用是减少问题的好方法。默认的监狱规则正好展示了 FreeBSD 的 devfs 如何通过 `include` 关键字支持重用。

这是默认配置的开始：

```
➊ [devfsrules_hide_all=1]
➋ add hide

➌ [devfsrules_unhide_basic=2]
➍ add path log unhide
➎ add path null unhide
➏ add path zero unhide
➐ add path crypto unhide
   --snip--
```

规则一，`devfsrules_hide_all` ➊，隐藏所有设备节点 ➋。

规则二，`devfsrules_unhide_basic` ➌，仅包含一系列 `unhide` 声明。此规则只会做一件事：重新显示关键的 Unix 设备节点，如 */dev/log* ➍、*/dev/null* ➎、*/dev/zero* ➏、*/dev/crypto* ➐ 等。大多数进程没有这些设备就无法运行。这些设备节点在标准系统中已经暴露，那么为什么还需要一个规则来重新显示它们呢？类似地，规则集三，`devfsrules_unhide_login`，仅仅是重新显示已登录用户的设备节点。

最后一个规则集利用了所有这些。

```
[devfsrules_jail=4]
add include $devfsrules_hide_all
add include $devfsrules_unhide_basic
add include $devfsrules_unhide_login
add path zfs unhide
```

这个规则集 `devfsrules_jail` 使用 `include` 语句通过引用引入之前的规则集。最后一个语句还重新显示了 */dev/zfs*，使得 ZFS 工具可以在监狱中工作。

如果你希望在所有监狱中都能使用额外的设备节点，你可以将该设备节点添加到监狱的规则集中。或者，你可以定义一个新的规则集，并在所有监狱中使用它。更好的做法是，你可以为仅需要该设备的监狱定义一个规则集，并将该规则集分配给那些监狱。

最后，让我们看一下动态设备。

#### *使用 devd(8) 进行动态设备管理*

热插拔硬件现在已经是常规操作。FreeBSD 的 devfs 在插入硬件时动态创建新的设备节点，并在硬件移除时删除这些节点，这使得使用这些动态设备变得更加简单。devd(8)守护进程更进一步，允许你在硬件出现和消失时运行用户空间程序。

FreeBSD 的默认配置，*/etc/devd.conf*，能够很好地处理大多数现代硬件。如果你需要定制 devd(8)，可以将配置文件放在*/usr/local/etc/devd/*下，以简化升级。你还可以为不同类型的设备添加不同的规则文件，如果你发现 devd(8)配置变得非常复杂。

##### devd 配置

你会发现四种类型的 devd(8)规则：`attach`、`detach`、`nomatch`和`notify`。

`attach`规则在匹配的硬件附加到系统时被触发。当你插入一个网络卡时，`attach`规则会为卡配置一个 IP 地址并启动网络。

`detach`规则在匹配的硬件从系统中移除时被触发。`detach`规则不常见，因为当底层硬件消失时，内核会自动标记资源为不可用，但你可能会在某些情况下用到它们。

`nomatch`规则在新硬件安装但未附加到设备驱动时被触发。这些设备在当前内核中没有设备驱动。

devd(8)在内核向用户空间发送匹配的事件通知时应用`notify`规则。例如，网络接口已启动的控制台消息就是一个`notify`事件。通知通常会出现在控制台或*/var/log/messages*中。

规则也有优先级，0 是最低的。只有最高匹配的规则会被处理，而优先级较低的匹配规则会被跳过。以下是一个 devd(8)规则的示例：

```
➊notify ➋0 {
          match "system"          ➌"IFNET";
          match "subsystem"       ➍"!usbus[0-9]";
          match "type"            ➎"ATTACH";
          action ➏"/etc/pccard_ether $subsystem start";
};
```

这是一个`notify`规则➊，意味着当内核向用户空间发送消息时，它会被触发。作为一个优先级为 0 的规则➋，只有在没有更高优先级的规则匹配我们指定的条件时，这个规则才会被触发。这个规则只有在通知发生在网络系统`IFNET` ➌（网络）且子系统 ➍不匹配表达式`usbus[0-9]`时才会被触发。它排除了 USB 网卡。当通知类型为`ATTACH` ➎时，也就是说，只有在有人插入网络接口时才会匹配。如果这三个条件都满足，devd(8)会运行一个命令来配置网络接口➏。

阅读 devd(8)的手册页，了解你可以在规则中使用的所有选项。如果你想在特定的挂载点上自动挂载某个 USB 闪存盘，可以通过检查每个插入的 USB 设备的序列号来实现。如果你希望对 Intel 网卡和 Atheros 网卡进行不同的配置，可以通过检查供应商来做到这一点。无论你需要编写什么规则，它可能都能在这里找到相关信息。

### 其他文件系统

FreeBSD 支持一些鲜为人知的文件系统。它们大多数只有在特殊情况下才有用，但系统管理中每天都会出现这种特殊情况。

进程文件系统 procfs(5) 包含了大量关于进程的信息。它被视为一个安全风险，并且在现代 FreeBSD 版本中已正式弃用。然而，通过挂载进程文件系统，你可以了解很多关于进程的信息。少数旧应用程序仍然需要挂载在 */proc* 上的进程文件系统；如果一个服务器应用程序需要 procfs，试着找到一个类似的应用程序，它可以完成相同的任务而不需要它。

如果你使用的是 Linux 模式（参见 第十七章），你可能需要 Linux 进程文件系统 linprocfs(5)。许多 Linux 软件都需要进程文件系统，FreeBSD 建议在安装 Linux 模式时，在 */compat/linux/proc* 安装 linprocfs。我建议只有当某个软件提示找不到它时再安装 linprocfs。

文件描述符文件系统 fdesc(5) 提供了每个进程的文件描述符文件系统视图。一些软件，特别是 Java 和流行的 Bash shell，需要 fdescfs(5)。它比 procfs 风险小，但仍然不太理想。当你安装需要它的软件包时，会提供如何挂载 fdescfs(5) 的说明。

现在我们已经讨论了本地文件系统，让我们来看看网络。

### 网络文件系统

网络文件系统允许通过网络访问另一台计算机上的文件。最常用的两种网络文件系统是 Unix 中实现的原始网络文件系统（NFS）和由 Microsoft Windows 推广的 CIFS（也称为 SMB）文件系统。我们会简单提及这两者，但先从老旧的 Unix 标准 NFS 开始。

在 Unix 类系统之间共享目录和分区，或许是你能找到的最简单的网络文件系统。FreeBSD 默认支持 Unix 标准的网络文件系统。配置 NFS 让许多初级系统管理员感到畏惧，但在设置了几个文件共享后，你会发现它并不像想象中那么难。

NFS 并不是作为安全协议设计的。不要在没有包过滤器或防火墙的情况下将 NFS 服务器暴露到互联网上。仅仅在 NFS 层面限制访问是完全不够的——你必须防止随机主机探测主机的远程过程调用（RPC）服务。需要通过 IP 地址和端口号限制对主机的访问。

此外，标准的 NFS 并未加密。任何拥有数据包嗅探器并能够访问你的网络线缆的人都能看到所有文件系统活动。一旦你部署了 Kerberos，你就可以加密 NFS，但 Kerberos 需要单独的书籍来讲解。

每个 NFS 连接使用客户端-服务器模型。一台计算机是服务器；它向其他计算机提供文件系统。这被称为 *NFS 导出*，提供的文件系统称为 *导出*。客户端可以以几乎与挂载本地文件系统相同的方式挂载服务器的导出。

关于 NFS，有一个有趣的特点是它的无状态性。NFS 不会跟踪连接的状态。你可以重启 NFS 服务器，客户端不会崩溃。虽然在服务器停机时客户端无法访问服务器的导出文件，但一旦服务器恢复，客户端会接着之前的状态继续操作。其他网络文件共享系统并不总是如此健壮。当然，无状态性也会引发一些问题；例如，客户端无法知道它当前打开的文件是否被另一个客户端修改过。

**NFS 互操作性**

每个 NFS 实现都有些微差异。你会发现 Solaris、Linux、BSD 和其他类 Unix 系统之间存在一些 NFS 的变种。NFS 应该能在它们之间正常工作，但可能需要偶尔调整。如果你在与其他类 Unix 操作系统进行兼容时遇到问题，可以查看*FreeBSD-net*邮件列表的归档；该问题几乎肯定已经在其中讨论过。

NFS 服务器和客户端都需要内核选项，但各种 NFS 命令会动态加载相应的内核模块。FreeBSD 的 GENERIC 内核支持 NFS，因此对于没有自定义内核的用户来说，这不成问题。

NFS 是一个有完整书籍专门讨论的主题。我们不会深入讨论 NFS 的细节，而是专注于使基本的 NFS 操作能够正常工作。如果你正在部署复杂的 NFS 设置，建议进行进一步的研究。即使是这个基础设置，也能让你完成许多复杂的任务。

#### *NFS 版本*

现代的 NFS 有三个版本：NFSv2、NFSv3 和 NFSv4。FreeBSD 可以透明地自动检测并与版本 2 和 3 进行互操作。

NFSv2 相对简陋，源自于人们当时仅仅满足于能够实现文件共享的时期。

NFSv3 相较于 NFSv2 包含许多增量改进，并且性能大大提升。大多数这些改进甚至无需特别配置。

NFSv4 是一个完全不同且高度复杂的协议，它打破了许多 NFS 的长期规则。它被刻意设计成类似微软的文件共享协议。理解 NFSv4 需要了解文件系统扩展 ACL、跨网络同步用户 ID 等问题。

当人们说“NFS”时，他们几乎总是指 NFSv2 或 NFSv3。有些人将这些协议称为“传统 NFS”。通常如果指 NFSv4，人们会说“NFSv4”。

本书坚持使用常见的 NFSv2 和 NFSv3。我在《*FreeBSD Mastery: Specialty Filesystems*》（Tilted Windmill Press，2016 年）一书中专门花了几章讲解 NFSv4 及相关主题。

#### *配置 NFS 服务器*

使用以下*rc.conf*选项开启 NFS 服务器支持。虽然并非所有选项在所有环境中都是严格必要的，但开启这些选项可以提供最广泛的 NFS 兼容性，并提供良好的开箱即用性能。

```
➊ nfs_server_enable="YES"
➋ rpcbind_enable="YES"
➌ mountd_enable="YES"
➍ rpc_lockd_enable="YES"
➎ rpc_statd_enable="YES"
```

首先，告诉 FreeBSD 加载 *nfsserver.ko* ➊ 内核模块。如果内核不支持 NFS，所有操作都会失败。rpcbind(8) ➋ 守护进程将远程过程调用（RPC）映射到本地网络地址。每个 NFS 客户端都会向服务器的 rpcbind(8) 守护进程询问它可以找到哪个 mountd(8) 守护进程来连接。mountd(8) ➌ 守护进程监听来自客户端的挂载请求，使用高端口号。启用 NFS 服务器还会启动 nfsd(8)，它处理实际的文件请求。NFS 通过 rpc.lockd(8) ➍ 确保文件锁定的顺利进行，rpc.statd(8) ➎ 监控 NFS 客户端，以便在主机消失时释放资源。

虽然你可以在命令行启动所有这些服务，但如果你刚刚学习 NFS，最好在启用 NFS 服务器后重启系统。一旦 NFS 正常运行，sockstat(1) 的输出将显示 `rpc.lockd`、`rpc.statd`、`nfsd`、`mountd` 和 `rpcbind` 在监听。如果你没有看到所有这些守护进程在监听网络，请检查 */var/log/messages* 中的错误信息。

NFS 服务器旨在无缝地与各种 NFS 实现进行互操作。虽然它应该能自动协商连接，但你可能需要调整 NFS 服务器的 nfsd(8) 配置，以最佳适配你的客户端。通过 *rc.conf* 中的选项 `nfs_server_flags` 调整 nfsd(8) 的启动参数。

NFS 可以通过 TCP 或 UDP 运行。UDP 是传统的 NFS 传输协议。TCP 在丢包网络环境下表现更好，且能更好地应对不规则的网络速度。FreeBSD 提供了这两种协议，但默认使用 TCP 挂载。一些客户端在某个协议下表现更好。你可以通过 `-t` 明确启用 TCP，或通过 `-u` 启用 UDP。

NFS 服务器默认会监听机器上的所有 IP 地址。当服务器有多个 IP 地址时，回复 UDP 请求的地址可以是这些地址中的任意一个。这可能会让 NFS 客户端感到困惑。如果你的 NFS 服务器有多个 IP 地址，并且客户端偏好 UDP 协议，可以告诉 NFS 服务器仅使用一个 IP 地址，通过 `-h` 和服务器的 IP 来指定。

虽然 nfsd(8) 工作良好，但负载较高的服务器可能需要额外的 nfsd(8) 进程。虽然 FreeBSD 默认启动四个 nfsd(8) 进程，但你可以通过 `-n` 标志和所需的进程数量启动额外的进程。

这个 *rc.conf* 条目告诉 NFS 仅使用 UDP，绑定到 IP 地址 198.51.100.71，并运行六个 nfsd(8) 实例。

```
nfs_server_flags="-uh 198.51.100.71 -n 6"
```

不过，在你开始调整服务器行为之前，最好先配置一些共享目录。

#### *配置 NFS 导出*

现在，告诉你的服务器它可以共享哪些内容，或者说 *导出*。你可以导出整个服务器上的所有目录和文件系统，但任何称职的安全管理员都会对此感到不满（并且是有正当理由的）。与所有服务器配置一样，在保证服务器履行其职能的同时，应尽量限制访问权限。例如，在大多数环境中，客户端并不需要远程挂载 NFS 服务器的根文件系统。

FreeBSD 让你通过两种不同的路径配置导出。传统方法是通过文件*/etc/exports*。基于 ZFS 的服务器可以通过每个数据集的`sharenfs`属性来配置导出。服务器将根据这些属性创建 ZFS 导出文件*/etc/zfs/exports*。这两种导出文件格式相同。

选择一种管理 NFS 导出的方式。要么编辑*/etc/exports*，要么使用 zfs(8)。同时使用这两种方法可能会让你感到困惑，甚至可能导致所有功能失效。如果使用 ZFS 方法，切勿手动编辑*/etc/zfs/exports*。坚持使用一种方法。

无论选择哪种方法，*/etc/exports*必须存在。如果你通过 zfs(8)管理 NFS，我建议创建一个仅包含注释的单行*/etc/exports*，告诉大家使用 zfs(8)。

##### Exports 条目

那么如何配置一个导出呢？我将从 exports 文件*/etc/exports*开始，但大多数内容也适用于使用 ZFS。我将在第 308 页的“使用 zfs(8)管理 NFS”中讨论这些差异，但理解这些限制需要先理解*/etc/exports*。

每个 exports 条目最多有三部分：

+   要导出的目录或分区（必需）

+   该导出的选项

+   可以连接的客户端

每个客户端和磁盘设备的组合在 exports 文件中只能有一行。这意味着，如果*/usr/ports*和*/usr/home*在同一分区上，并且你想将它们都导出到某个特定客户端，它们必须出现在同一行中。你不能将*/usr/ports*和*/usr/home*导出到一个客户端，且给它们不同的权限。请注意，你不必导出整个磁盘设备；你可以仅导出分区中的一个目录。这个目录不能包含符号链接或点。

NFS 挂载不能跨越分区。如果主机为*/usr*和*/usr/src*配置了独立的 UFS 分区，导出*/usr*并不会自动导出*/usr/src*。

在*/etc/exports*条目的三部分中，只有目录是必需的。exports 行不能包含符号链接或点。为了将我的主目录导出到互联网上的所有主机，我可以使用完全由以下内容组成的*/etc/exports*行：

```
/home/mwlucas
```

这没有任何选项和主机限制。当然，这种导出是愚蠢的，但我还是可以这么做。^(4)

编辑完*exports*文件后，告诉 mountd(8)重新读取该文件：

```
# service mountd reload
```

与 mountd(8)相关的问题会出现在*/var/log/messages*中。日志消息通常比较难以理解：虽然 mountd(8)会告诉你某行有问题，但通常不会说明原因。我遇到的最常见错误涉及符号链接。在目录中使用 pwd(1)可以获取目录的实际路径。

##### NFS 和用户

NFSv2 和 NFSv3 通过 UID 来识别用户。（NFSv4 使用用户名，因为它假设你已在整个网络中同步了用户名。）例如，在我的笔记本上，用户 *mwlucas* 的 UID 是 1001。在 NFS 服务器上，*mwlucas* 也有 UID 1001。这使得我的工作变得简单，因为我不必太担心文件所有权；我在服务器上的权限与在笔记本上的权限相同。

这在大规模网络中可能成为一个问题，尤其是当用户在自己的机器上拥有 root 权限时。解决这个问题的最佳方法是通过 Kerberos 创建一个授权用户的中央存储库。在小型网络或用户数量有限的 NFS 网络中，通常不会遇到这个问题；你可以同步系统上的*/etc/master.passwd*，或者在每个系统上为每个用户分配相同的 UID。

然而，root 用户的处理方式略有不同。NFS 服务器并不信任其他机器上的 root 用户执行服务器上的 root 命令。毕竟，如果入侵者突破了 NFS 客户端，你不希望服务器自动跟着崩溃。NFS 默认将来自客户端 root 账户的请求映射到服务器上的 UID 和 GID 为 –2 的账户。这就是 highly unprivileged *nobody* 账户的由来。

许多其他服务器程序的作者认为 nobody 账户是个好主意，因此他们将 nobody 用于自己的目的。多个安全实体同时以 nobody 身份运行会带来安全问题。FreeBSD 的软件包为所有需要的应用程序创建了无特权用户。我认为 nobody 用户已被污染，建议不要允许使用它。

你可以将 root 的请求映射到其他用户名。例如，你可以指定所有来自客户端 root 的请求将作为服务器上的 *nfsroot* 用户运行。通过小心使用组，你可以允许该 nfsroot 用户拥有有限的文件访问权限。使用 `maproot` 选项将 root 映射到其他用户。这里，我们将客户端上的 UID 0（root）映射到服务器上的 UID 5000：

```
/usr/home/mwlucas -maproot=5000
```

如果你真的希望客户端的 root 拥有服务器上的 root 权限，可以使用 `-maproot` 将 root 映射到 UID 0。这可能适用于你的家庭网络或测试系统。

你不能随意将用户账户映射到彼此。在复杂环境中，确保你同步网络中所有机器上的用户账户和 UID。

NFS 用户最多可以属于 16 个组。一些操作系统能够突破这个限制，但这样做违反了 NFS 协议。如果用户无法通过基于组的访问控制访问文件，请检查他们所属的组数。

编辑 exports 文件后，请记得重新启动 mountd(8)。

##### 导出多个目录

标准的 FreeBSD UFS 安装将所有文件放在一个分区上。你可能希望导出该分区上的多个目录。在 */etc/exports* 文件中，列出同一分区上的所有目录，并将它们与第一个导出的目录放在同一行上，之间用空格隔开。以下是一个具有多个导出的 */etc/exports* 示例：

```
/usr/home/mwlucas /usr/src /var/log /usr/ports/distfiles -maproot=nfsroot
```

客户端可以挂载这些目录中的任何一个，来自 root 的请求会映射到 nfsroot。

行的各个部分之间没有标识符、分隔符或定界符。是的，如果我们能将每个共享目录放在自己的一行上，阅读会更容易，但我们做不到——它们都在同一个分区上。FreeBSD 团队可以重写它，使其结构更清晰，但那样的话，FreeBSD 的*/etc/exports*就与其他 Unix 系统不兼容了。

也许你希望客户端能够挂载分区上的任何目录。可以使用`-alldirs`选项允许此操作。我不会在只有一个分区的主机上这样做。

```
/home -alldirs
```

你只能使用`-alldirs`指定一个分区的挂载点。

##### 长行

与许多其他配置文件一样，你可以使用反斜杠将一行配置分成多行。你可能会发现前面的配置在如下所示的情况下更易于阅读：

```
/usr/home/mwlucas \
    /usr/src \
    /usr/obj \
    /usr/ports/distfiles \
    -maproot = 5000
```

一旦你的导出行变得足够长，这种样式突然比其他方式更具可读性。

##### 限制客户端

要仅允许特定的客户端访问 NFS 导出，请将它们列在*/etc/exports*条目的末尾。在这里，我们将前面的共享限制为一个 IP 地址：

```
/usr/home/mwlucas /usr/src /usr/obj /usr/ports/distfiles \
    -maproot=5000 203.0.113.200
```

你还可以通过使用`-network`和`-mask`限定符，将文件共享限制为某个特定网络上的客户端：

```
/usr/home/mwlucas /usr/src /usr/obj /usr/ports/distfiles \
    -maproot=5000 -network 203.0.113 -mask 255.255.255.0
```

这样，任何 IP 地址以 203.0.113 开头的客户端都可以访问你的 NFS 服务器。我使用类似的设置来快速升级客户端。我在 NFS 服务器上构建一个新的世界和内核，然后让客户端挂载这些分区，并通过 NFS 安装二进制文件。

要将导出到 IPv6 网络，请在地址中包含斜杠。

```
/usr/home/mwlucas -network 2001:db8:bad:c0de::/64
```

你也可以列出主机名而不是 IP 地址，但这会依赖于名称解析。如果丢失了 DNS，你将无法进行文件共享。此外，NFS 服务器在启动 mountd 时会查找每个主机的 IP 地址。如果客户端的 IP 发生变化，你需要重新加载 DNS 和 mountd(8)。如果必须列出主机名，请将它们放在行的末尾。

```
/usr/home/mwlucas www1 www2 www3
```

按每主机分配 NFS 会增加工作量。尽量在不妥协安全性的前提下，广泛地分配 NFS 权限。

##### 客户端和导出组合

*/etc/exports*中的每一行都指定了从一个分区到一个网络、地址或主机集合的导出。不同的主机需要完全不同的导出声明。如果需要，你可以为每个主机更改选项。

```
/usr/home/mwlucas /usr/src /usr/obj /usr/ports/distfiles \
    -maproot=5000 203.0.113.200
/usr -maproot=0 203.0.113.201
```

在这里，我将*/usr*的几个子目录导出给 IP 为 203.0.113.200 的 NFS 客户端。IP 为 203.0.113.201 的 NFS 客户端可以挂载整个*/usr*，甚至可以作为 root 进行挂载。

##### NFS 和防火墙

NFS 因不喜欢防火墙而著名。像 mountd(8)、rpc.lockd(8)和 rpc.statd(8)这样的服务动态端口分配，使得数据包过滤几乎不可能。你可以使用`-p`标志为这些服务分配特定的 TCP 端口。在这里，我使用*rc.conf*条目将 mountd(8)绑定到 4046 端口，将 rpc.lockd(8)绑定到 4045 端口，将 rpc.statd(8)绑定到 4047 端口：

```
mountd_flags="-r -p 4046"
rpc_lockd_flags="-p 4045"
rpc_statd_flags="-p 4047"
```

我可以在我的数据包过滤规则中使用这些端口，为我的 NFS 服务器提供一些保护。

##### 使用 zfs(8)管理 NFS

使用 zfs(8)管理 NFS 有优点也有缺点。你可以按数据集配置 NFS，而且每次更改后不需要手动重启 mountd(8)。命令行配置更容易自动化，很多人发现它也更容易输入。

使用`sharenfs`属性来启用、禁用和配置 NFS 导出。将该属性设置为`on`，可以全局共享一个数据集及其所有后代。这相当于在*/etc/exports*中单独列出该数据集。世界上的任何人都可以挂载这个数据集或它的任何子目录，除非你有其他访问控制，如防火墙。

```
# zfs set sharenfs=on zroot/home
```

类似地，设置为`off`可以取消共享该数据集。

你可能希望在导出上设置一些 NFS 选项。将`sharenfs`设置为所需的选项。这个例子设置了一个 maproot 用户，并将客户端限制在我的本地网络内。将选项放在引号中。

```
# zfs set sharenfs="-network 203.0.113.0/24 -maproot=nfsroot" zroot/home
```

使用 ZFS 管理 NFS 导出的一个问题是，所有允许的主机都会获得相同的选项。也就是说，如果大多数主机需要使用`-maproot=nfsroot`挂载*/home*，但你有一台主机需要以 root 身份挂载该数据集，你就不能使用 ZFS 属性。同样，ZFS 属性只允许定义一个被允许的网络。

#### *启用 NFS 客户端*

配置 NFS 客户端要简单得多。在*/etc/rc.conf*中，添加以下内容：

```
nfs_client_enable="YES"
```

你可以重启或运行`service nfsclient start`。这两种方法都会启动 NFS 客户端功能。

##### 显示可用挂载点

对于 NFS 客户端来说，显而易见的问题是：“我可以从这个服务器挂载什么？”showmount(8)命令列出了客户端可以访问的所有导出。给出`-e`标志和 NFS 服务器的名称。在这里，我询问 storm 服务器提供了哪些导出：

```
# showmount -e storm
Exports list on storm:
/usr/home                          203.0.113.0
```

该客户端被允许根据允许网络 203.0.113.0 的规则挂载*/usr/home*。

运行 showmount(8)不会提供任何服务器端选项，如`-maproot`。这些细节对客户端来说并不容易获取，尽管 touch(1)可以让你轻松测试只读导出。

##### 挂载导出

现在，你可以挂载 NFS 服务器导出的目录或文件系统。与其使用设备名称，不如使用 NFS 服务器的主机名和你想要挂载的目录。例如，要将我的 storm 服务器上的*/home/mwlucas*目录挂载到*/mnt*目录，我会运行：

```
# mount storm:/usr/home/mwlucas /mnt
```

之后，用 df(1)命令测试你的挂载。

```
# df -h
Filesystem            Size    Used   Avail Capacity  Mounted on
--snip--
storm:/usr/home       891G    2.7G    888G     0%    /mnt
```

NFS 挂载的目录显示为一个普通分区，我可以随意读取和写入文件。

##### NFS 挂载选项

FreeBSD 使用保守的 NFS 默认设置，以便与任何其他类 Unix 操作系统互操作。你可以使用挂载选项来调整 FreeBSD 挂载 NFS 导出的方式。你可以在命令行使用`-o`选项，或者将它们添加到*/etc/fstab*条目中。

如果你需要访问一个仅支持 UDP 的 NFS 服务器，可以使用挂载选项`udp`来使用 UDP，而不是默认的 TCP。

程序期望文件系统不会消失，但在使用 NFS 时，可能会发生服务器从网络中消失的情况。这会导致客户端上试图访问 NFS 文件系统的程序永久挂起。通过将 NFS 挂载设置为*可中断*，你将能够通过 CTRL-C 中断挂起的进程。使用 `intr` 设置可中断性。

通过使用软挂载，FreeBSD 会通知程序它们正在处理的文件不再可用。程序如何处理这些信息取决于程序本身，但它们将不再无限期挂起。使用`soft`选项启用软挂载。

如果你想要只读挂载，请使用`ro`挂载选项。

综合来看，我可能会将我的主目录挂载为可中断的软挂载。^(5)

```
# mount -o soft,intr storm:/usr/home/mwlucas /mnt
```

我可以像这样将其添加到*/etc/fstab*文件中：

```
storm:/usr/home/mwlucas  /mnt  nfs  rw,soft,intr  0  0
```

虽然 NFS 对于简单使用来说非常直接，但你可能会花费很多时间进行调整、优化和增强。如果你希望建立一个复杂的 NFS 环境，不要完全依赖这个简短的介绍，而是花时间阅读一本关于这个主题的好书。

现在，让我们来看看读取 Windows 共享。

### 通用互联网文件系统

如果你在一个典型的办公网络中，标准的网络文件共享协议是微软的*通用互联网文件系统（CIFS）*。你可能知道 CIFS 作为服务器消息块（SMB）、"网络邻居"或"为什么我无法挂载那个驱动器？"最初仅由 Microsoft Windows 系统提供，但这个协议已经变成了某种伪标准。

FreeBSD 包含 smbutil(8) 程序，用于查找、挂载和作为 CIFS 客户端使用 CIFS 共享。FreeBSD 在基础系统中不包括 CIFS 服务器，但开源 CIFS 服务器 Samba (*[`www.samba.org/`](https://www.samba.org/)*）在 FreeBSD 上运行良好。

使用 FreeBSD 的 CIFS 支持与现有的 Microsoft 基础设施进行互操作。不要部署 CIFS 来支持类似 Unix 的系统。

#### *先决条件*

在开始使用 Microsoft 文件共享之前，请收集以下有关 Windows 网络的信息：

+   工作组或 Windows 域名

+   有效的 Windows 用户名和密码

+   Windows DNS 服务器的 IP 地址

#### *内核支持*

FreeBSD 使用多个内核模块来支持 CIFS。*smbfs.ko* 模块支持基本的 CIFS 操作。*libmchain.ko* 和 *libiconv.ko* 模块提供支持函数，并在加载 *smbfs.ko* 时自动加载。你可以将这些静态编译到内核中：

```
options    NETSMB
options    LIBMCHAIN
options    LIBICONV
options    SMBFS
```

你可以通过在*boot/loader.conf*文件中添加条目来在启动时自动加载这些设置。

```
smbfs_load=YES
```

你现在可以配置 CIFS。

#### *配置 CIFS*

CIFS 依赖于一个配置文件，通常是*$HOME/.nsmbrc*或*/etc/nsmb.conf*。所有在*/etc/nsmb.conf*中的设置都会覆盖用户主目录中的设置。配置文件通过方括号中的标签分为多个部分。例如，适用于每个 CIFS 连接的设置位于`[default]`部分。创建自己的部分以指定服务器、用户和共享，格式如下：

```
[servername]
[servername:username]
[servername:username:sharename]
```

适用于整个服务器的信息放在以服务器名命名的部分中。适用于特定用户的信息保存在用户名部分中，适用于单个共享的信息保存在包含共享名称的部分中。如果你没有更具体的每用户或每共享信息，可以将所有共享的信息放在一个普通的`[servername]`条目下。

配置条目使用来自 CIFS 系统的值——例如，Bert 的 Windows 用户名是*bertjw*，但他的 FreeBSD 用户名是*xistence*，所以我在*nsmb.conf*中使用*bertjw*。

#### *nsmb.conf 关键字*

在适当的部分下，指定一个带有关键字和值的*nsmb.conf*配置。例如，服务器有 IP 地址而用户没有，所以在服务器部分仅使用 IP 地址分配。使用关键字时，用等号赋值，如*keyword=value*。以下是常用的关键字；有关完整列表，请参见 nsmb.conf(5)。

##### workgroup=string

`workgroup` 关键字指定要访问的 Windows 域或工作组的名称。这通常是所有服务器的默认设置。

```
workgroup=MegaCorp
```

##### addr=a.b.c.d

`addr` 关键字设置 CIFS 服务器的 IP 地址。此关键字只能出现在简单的 `[servername]` 标签下。如果你已经有工作中的 CIFS 名称解析，则不需要此项，但现实中有时并非如此。

##### nbns=a.b.c.d

`nbns` 关键字设置 NetBIOS（WINS）名称服务器的 IP 地址。你可以将此行放在默认部分或特定服务器下。如果你使用 Active Directory（基于 DNS），你可以使用 DNS 主机名。然而，添加一个 WINS 服务器不会影响你的配置，并有助于测试基本的 CIFS 设置。

##### password=string

`password` 关键字为用户或共享设置明文密码。如果必须将密码存储在*/etc/nsmb.conf*中，必须确保只有 root 用户可以读取该文件。在多用户系统中，在*$HOME/.nsmbrc*中存储密码是个坏主意。

你可以使用`smbutil crypt`对 Windows 密码进行加密，生成一个字符串，用于此关键字。加密后的字符串前面有双美元符号（`$$`）。虽然这有助于防止有人意外发现密码，但恶意用户可以轻松地解密它。

```
# smbutil crypt superSecretPassword
$$1624a53302a6d
```

如果服务器需要访问 CIFS 共享以执行其常规任务，请不要使用你的账户。请向 Windows 团队申请为你的服务器提供一个账户，以避免你的账户问题干扰服务器功能。

##### 示例配置

在这里，我创建了一个 *nsmb.conf*，允许 Bert 访问他在公司 CIFS 文件服务器上的文件。

```
[default]
nbns=203.0.113.12
workgroup=BigCorp
[FILESERVER:bertjw]
password=$$1624a53302a6d
```

在这种配置下，Bert 应该能够访问那些专制的 Windows 管理员允许的 CIFS 共享。

#### *CIFS 名称解析*

在 FreeBSD 挂载 CIFS 共享之前，它需要识别共享所在的主机。虽然微软已经使用 DNS 数十年，但典型的 Windows 环境通常支持多种旧版协议。通过 `smbutil lookup` 验证 smbutil(1) 是否能够找到 CIFS 服务器。

```
# smbutil lookup fileserver1
Got response from 203.0.113.12
IP address of ntserv1: 203.0.113.4
```

如果这有效，那么你已经具备了基本的 CIFS 功能。

#### *其他 smbutil(1) 功能*

你可以在命令行查看主机上的共享。首先登录到你的主机。

```
# smbutil login //unix@fileserver1
Password:
```

所以，我们的配置是正确的。让我们使用 smbutil 的 `view` 命令查看此服务器提供了哪些资源。

```
# smbutil view //unix@fileserver1
Password:
Share        Type       Comment
-------------------------------
IPC$         pipe       Remote IPC
ADMIN$       disk       Remote Admin
C$           disk       Default share
unix         disk
4 shares listed from 4 available
```

你将得到一个 CIFS 服务器上每个共享资源的列表。现在，假设你已经完成，退出服务器。

```
# smbutil logout //unix@fileserver
```

#### *挂载共享*

在你完成调查后，使用 mount_smbfs(8) 挂载共享。语法如下：

```
# mount_smbfs //username@servername/share /mount/point
```

我在这台 Windows 机器上有一个叫 *MP3* 的共享，我想从我的 FreeBSD 系统访问它。为了将它挂载到 */home/mwlucas/smbmount*，我会这样做：

```
# mount_smbfs //unix@fileserver1/MP3 /home/mwlucas/smbmount
```

mount(8) 和 df(1) 程序会显示此共享已附加到你的系统，你可以像访问任何其他文件系统一样访问服务器上的文档。使用 umount(8) 来断开与服务器的连接。

#### *其他 mount_smbfs 选项*

mount_smbfs 包括多个选项来调整挂载 CIFS 文件系统的行为。使用 `-f` 选项可以选择不同的文件权限模式，使用 `-d` 选项可以选择不同的目录权限模式。例如，若要设置一个挂载，使得只有我可以访问该目录的内容，我会使用 `mount_smbfs -d 700`。这将使 FreeBSD 权限比 Windows 权限更严格，但我完全没问题。我可以通过 `-u` 选项更改文件的所有者，使用 `-g` 选项更改组。

微软的文件系统对大小写不敏感，但类 Unix 操作系统对大小写敏感。CIFS 默认保持原样，但这可能并不总是理想的。`-c` 标志会让 mount_smbfs(8) 修改文件系统中的大小写：`-c l` 会将所有字母改为小写，而 `-c u` 则会将所有字母改为大写。

#### *nsmb.conf 选项*

下面是不同情况下 *nsmb.conf* 配置项的示例。它们都假设你已经在配置中定义了工作组、NetBIOS 名称服务器，并且拥有访问 CIFS 共享的权限的用户名。

##### 独立系统上的唯一密码

如果你有一台名为 *desktop* 的机器，并且有一个受密码保护的共享，你可以使用类似以下的命令。许多独立的 Windows 系统都有这种密码保护功能。

```
[desktop:shareusername]
password=$$1789324874ea87
```

##### 访问第二个域

在这个例子中，我们访问的是一个名为 *development* 的第二个域。该域的用户名和密码与我们默认域的不同。

```
[development]
workgroup=development
username=support
```

#### *CIFS 文件所有权*

Unix-like 系统和 Windows 系统之间的文件所有权可能会出现问题。首先，你的 FreeBSD 用户名可能无法映射到 Windows 用户名，而且 Unix 的权限机制与 Windows 有很大不同。

由于你使用的是单一的 Windows 用户名来访问共享资源，因此你只能获得该帐户对 Windows 资源的访问权限，但必须为挂载的共享分配正确的 FreeBSD 权限。默认情况下，mount_smbfs(8)将为新的共享分配与挂载点相同的权限。在我们之前的示例中，目录*/home/mwlucas/smbmount*由用户*mwlucas*拥有，并且权限为 755。这些权限表示 mwlucas 可以编辑该目录中的内容，但其他人不能。尽管 FreeBSD 表示该用户可以编辑这些文件，但 Windows 仍可能不允许该特定用户编辑它所共享的文件。

### 提供 CIFS 共享

正如 FreeBSD 可以访问 CIFS 共享一样，它也可以通过 Samba 将共享提供给 CIFS 客户端。你可以在包集合中找到几个版本较新的 Samba。Samba 官网 *[`www.samba.org/`](http://www.samba.org/)* 提供了许多有用的教程。从 FreeBSD 提供 CIFS 共享比访问它们要复杂得多，因此我们将在此结束讨论，以免本书变得更厚。

我们现在已经完成了对 FreeBSD 文件系统的介绍。虽然我已经花了几章来讲解这个主题，但 FreeBSD 还有几个额外的文件系统选项、一个自动挂载工具，甚至支持 Filesystem in Userspace（FUSE），用于访问 NTFS、Linux 的 extfs 等。它还具有特殊的 iSCSI 支持和像 nullfs(5)这样的特殊文件系统，使得在大规模管理监狱（jails）时非常强大。不过，如果我再花更多时间讲解文件系统，你们可能会追踪到我并用钝器表达你们的不满，所以让我们继续讨论 FreeBSD 的一些高级安全特性。
