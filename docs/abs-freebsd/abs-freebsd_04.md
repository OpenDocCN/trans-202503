## 4

开始启动！启动过程**

![image](img/common01.jpg)

虽然 FreeBSD 在开机时可以轻松且自动地启动，但了解每个阶段到底发生了什么，将使你成为一个更好的系统管理员。在启动过程中通常不需要干预，但有一天你会很高兴自己知道如何操作。一旦你熟悉了调整启动过程，你会发现自己能够解决那些之前你只能接受并忍受的问题。

我们将首先讨论系统加载器是如何启动的，并从加载器获取信息。你可以使用加载器来改变早期的启动过程，包括启动替代内核和进入单用户模式。我们还将讨论串行控制台，这是一种标准的系统管理工具。FreeBSD 的多用户启动过程负责启动所有各种使你的计算机有用的服务，我们也会关注这一点。此外，我们还将讨论 FreeBSD 记录的关于启动过程的信息，以及 FreeBSD 如何在不破坏数据的情况下关闭系统。

**递归警告**

本章的一些主题引用了后续章节中的内容。这些后续章节反过来要求你先理解本章内容。学习没有固定的起点。如果你对本章的某部分不完全理解，跳过它继续阅读；随着你继续深入，你会发现这些内容会在你的脑海中逐渐清晰。

启动过程本身可以分为三个主要部分：加载器、单用户模式启动和多用户模式启动。

### 开机

计算机需要足够的智能来找到并加载其操作系统。多年来，这个功能来自基本输入输出系统（BIOS）。较新的系统使用统一可扩展固件接口（UEFI）代替 BIOS。新的安装应该使用 UEFI。其他硬件平台有控制台固件或启动 ROM，执行相同的功能，但我们关注的是常见硬件，因此我们将讨论 UEFI 和 BIOS。

#### *统一可扩展固件接口*

UEFI 是替代三十多年历史的 BIOS 的新技术。任何新系统都将启用 UEFI，并期望使用它。

UEFI 在启动盘上搜索标记为 UEFI 启动分区的分区。尽管这个特殊标记可能暗示一些事情，但该分区仅包含一个 FAT 文件系统，以及特定的目录和文件布局。UEFI 执行文件 */EFI/BOOT/BOOTX64.EFI*。这个文件可能是一个复杂的多操作系统启动加载器，或者直接将你带入操作系统。在 FreeBSD 中，UEFI 启动会启动加载器，*/boot/loader.efi*。

UEFI 相对较新。如果你的新系统在启动 FreeBSD 时遇到问题，你可以尝试启用 BIOS 或“传统”模式。如果系统在 BIOS 模式下能够启动 FreeBSD，但在 UEFI 模式下无法启动，请按照 第二十四章中的讨论提交 bug。^(1)

#### *基本输入输出系统*

最初的 Intel PC 使用了一种基本输入/输出系统（BIOS），它具备足够的能力来在磁盘上查找操作系统。BIOS 会搜索一个被标记为活动的磁盘分区，然后执行该分区的第一部分。对于 FreeBSD 而言，这部分数据被称为*加载器*。每个 FreeBSD 系统都有一个加载器的引用副本，路径为*/boot/loader*。

BIOS 有各种限制。启动加载器必须位于磁盘的一个特定区域。BIOS 无法从大于 2.2TB 的磁盘启动。目标启动加载器必须小于 512KB——按 1980 年的标准来说，这已经很大了，但今天显得微不足道。已安装的加载器是二进制文件，而不是文件系统，因此即使是微小的更改也需要重新编译。UEFI 没有这些限制，并且提供现代功能，如鼠标支持。

然而，最终来说，BIOS 和 UEFI 的目标都是将系统引导到 FreeBSD 加载器。

### 加载器

*加载器*，或称*启动块*，加载 FreeBSD 内核，并在启动内核之前为你呈现一个菜单。加载器(8)程序在左侧提供七个选项。新的 FreeBSD 系统展示了这些选项：

1.  启动多用户模式 [Enter]

1.  启动单用户模式

1.  跳转到加载器提示

1.  重启

1.  内核：default/kernel（1 of 2）

1.  配置启动选项…

1.  选择启动环境…

每个选项都突出显示某些单词或字符，比如“启动单用户模式”中的*S*和“跳转到加载器提示”中的 ESC。选择一个选项可以通过按下高亮字符或数字来实现。

菜单顶部的选项控制 FreeBSD 的启动方式。我们将逐一介绍每个选项。如果你等待 10 秒，加载器将默认自动启动 FreeBSD。

菜单下半部分的选项让你可以微调启动过程。你可以根据需要调整系统的启动方式，稍后我们会讨论这些内容，然后选择前面提到的启动选项之一。

#### *启动多用户模式 [Enter]*

这是正常的启动。按 ENTER 立即启动，跳过 10 秒的延迟。

#### *在单用户模式下启动 FreeBSD*

*单用户模式*是一种最小化启动模式，对于损坏的系统非常有用，尤其是当损坏是人为造成的时。它是 FreeBSD 提供命令提示符的最早时刻，这个模式足够重要，因此本章稍后会有专门的章节讲解。

#### *跳转到加载器提示*

加载器包括一个命令行解释器，你可以在其中输入命令来调整系统启动方式，确保它完全符合你的需求。我们将在“加载器提示”中详细介绍此内容，见第 55 页。

#### *重启*

再来一次，这次要有感觉！

在这些选项中，最重要的是单用户模式和加载器提示。

### 单用户模式

FreeBSD 可以执行一个最小启动，称为 *单用户模式*，它加载内核并查找设备，但不会自动设置文件系统、启动网络、启用安全性或运行任何标准的 Unix 服务。单用户模式是系统可能提供命令提示符的最早阶段。

为什么要使用单用户模式？如果一个配置错误的守护进程挂起了启动，你可以进入单用户模式以防止其启动。如果你忘记了根密码，可以通过单用户模式启动并进行更改。如果你需要调整关键的文件系统，单用户模式也是执行此操作的地方。

当你选择单用户模式启动时，你会看到常规的系统启动信息流过。但在任何程序启动之前，内核会给你一个选择 shell 的机会。你可以进入根分区上的任何 shell；我通常选择默认的 */bin/sh*，但如果你偏好，可以使用 */bin/tcsh*。

#### *单用户模式中的磁盘*

在单用户模式下，根分区是以只读方式挂载的，且没有其他磁盘被挂载。（我们将在第十章讨论挂载文件系统，但现在请暂时跟随进行。）你想使用的许多程序都位于根分区以外的分区，因此你需要将它们全部挂载为可读写并且可用。执行此操作的方式取决于你使用的是 UFS 还是 ZFS。

##### 单用户模式下的 UFS

为了使 */etc/fstab* 文件系统表中列出的所有文件系统可用，请运行以下命令：

```
# fsck -p
# mount -o rw /
# mount -a
```

fsck(8) 程序“清理”文件系统，并确认它们在内部的一致性，以及磁盘认为它拥有的所有文件实际上都存在并已记录。

根文件系统是以只读方式挂载的。无论是什么原因导致我们进入单用户模式，可能需要更改根文件系统。重新挂载根文件系统为可读写模式。

最后，mount(8) 命令的 `-a` 标志会激活 */etc/fstab* 中列出的每一个文件系统（参见第十章）。如果这些文件系统中的某一个正在给你带来问题，你可以通过在命令行中指定它们来单独挂载所需的文件系统（例如，`mount /usr`）。如果你是一个高级用户并且配置了 NFS 文件系统（参见第十三章），你将在此时看到这些文件系统的错误信息，因为网络尚未启动。如果主机在 */etc/fstab* 中有网络文件系统，应该只挂载 UFS 文件系统，如下所示。

如果你在按名称挂载分区时遇到困难，可以尝试使用设备名称。根分区的设备名称可能是 */dev/ad0s1a*。你还需要为此分区指定一个挂载点。例如，要将你的第一个 IDE 磁盘分区挂载为根分区，请输入以下命令：

```
# mount /dev/ad0s1a /
```

如果你的服务器上有网络文件系统，但网络尚未启动，你可以通过指定文件系统类型来挂载所有本地分区。在这里，我们挂载所有类型为 UFS 的本地文件系统，这是 FreeBSD 的默认文件系统类型：

```
# mount -a -t ufs
```

现在你可以访问你的 UFS 文件系统了。

##### 单用户模式下的 ZFS

要使所有的 ZFS 数据集可用，使用`zfs mount`。你可以按名称挂载单独的数据集，也可以使用`-a`挂载所有标记为可挂载的数据集。

```
# zfs mount -a
```

ZFS 将在挂载数据集之前执行常规的完整性检查。

大多数数据集在单用户模式下与多用户模式下一样可访问，但作为根的挂载数据集仍然是只读的。关闭它。我在这里将根数据集设置为可读写，适用于默认的 FreeBSD 安装。

```
# zfs set readonly=off zroot/ROOT/default
```

现在你可以更改文件系统。

#### *单用户模式下可用的程序*

可用的命令取决于哪些分区已挂载。一些基本命令可以在根分区的*/bin*和*/sbin*中找到，即使根分区是只读的，它们也可以使用。其他命令存放在*/usr*中，直到挂载该分区之前无法访问。（看看系统中的*/bin*和*/sbin*，你可以了解在出现问题时可用的命令。）

如果你破坏了共享库系统（参见第十七章），这些程序将无法使用。如果你真的那么不幸运，FreeBSD 在*/rescue*目录中提供了许多核心实用程序的静态链接版本。

#### *单用户模式下的网络*

如果你希望在单用户模式下保持网络连接，使用脚本*/etc/netstart*。该脚本会调用适当的脚本启动网络，给接口分配 IP 地址，并启用数据包过滤和路由。如果你只需要其中的一部分服务，你需要查看该脚本并手动执行适当的命令。

#### *单用户模式的用途*

在单用户模式下，你对系统的访问仅受限于你对 FreeBSD 和 Unix 的了解。

例如，如果你忘记了根密码，你可以从单用户模式重置它：

```
# passwd
Changing local password for root
New Password:
Retype New Password:
#
```

**注意**

*你会注意到系统并没有要求输入旧的根密码。在单用户模式下，你会自动成为 root，而 passwd(8)不会要求 root 输入任何密码。*

或者，如果你发现*/etc/fstab*中有一个错误，导致系统无法启动，你可以通过设备名称挂载根分区，然后编辑*/etc/fstab*来解决问题。

如果你有一个在启动时导致系统崩溃的程序，且你需要阻止该程序再次启动，你可以编辑*/etc/rc.conf*来禁用该程序，或者设置启动脚本的权限，使其无法执行。

```
# chmod a-x /usr/local/etc/rc.d/program.sh
```

我们将在第十五章讨论第三方程序（端口和包）。

你需要理解单用户模式才能成为一个成功的系统管理员，我们将在本书中多次提到它。不过现在，让我们先来看一下加载器提示。

**系统故障与人为错误**

所有这些示例都涉及从人为错误中恢复的原因是有原因的。硬件故障并不常见，FreeBSD 故障则更少。如果不是因为人为错误，我们的计算机几乎永远不会让我们失望。随着您对 FreeBSD 的了解不断深入，您将在单用户模式下变得越来越有能力。

### 加载器提示符

加载器提示符允许您对计算机的启动环境和启动过程中必须配置的变量进行基本更改。它不是类 Unix 环境；它非常简陋，仅支持最小的功能集。当您进入加载器提示符（启动菜单中的第三个选项）时，您将看到如下内容：

```
Type '?' for a list of commands, 'help' for more detailed help.
OK
```

这是加载器提示符。虽然*OK*这个词可能显得友好且令人放心，但它是加载器环境中为数不多的友好特性之一。这不是一个功能齐全的操作系统；它是一个配置系统启动的工具，不适合不了解或胆小的人。您在加载器提示符下所做的任何更改只会影响当前的启动。要撤销更改，请重新启动。（我们将在下一节中看到如何使加载器更改永久生效。）

要查看所有可用的命令，请输入问号。

```
OK ?
Available commands:
  heap             show heap usage
  reboot           reboot the system
  lszfs            list child datasets of a zfs dataset
--snip--
```

许多加载器命令除了开发者外对其他人没有什么用处，因此我们将重点介绍对系统管理员有用的命令。

#### *查看磁盘*

要查看加载器已识别的磁盘，请使用`lsdev`。

```
   OK lsdev
➊ cd devices:
   disk devices:
➋ disk0:    BIOS drive C (33554432 X 512):
      ➌ disk0p1: FreeBSD boot
         disk0p2: FreeBSD swap
       disk0p3: FreeBSD ZFS
➍ zfs devices:
       zfs:zroot
```

加载器检查 CD 驱动器➊，但没有找到任何。 （只有在从 CD 启动时加载器才会找到 CD 驱动器，所以不要因此而惊慌。）它找到了一个硬盘，BIOS 识别为 C 盘➋。然后它描述了该硬盘上的分区。如我们将在第十章中看到的，GPT 分区使用字母*p*和一个数字来标识分区。分区 disk0p1 ➌是一个 FreeBSD 启动分区，用于从 BIOS 启动 FreeBSD。在一个不熟悉的系统上遇到启动问题时，这些知识可能会很有帮助。加载器还可以识别主机上的 ZFS 池 ➍。

#### *加载器变量*

加载器在内核中和配置文件中设置了变量。使用`show`命令查看这些变量及其设置，并使用空格键翻到下一页。

```
OK show
LINES=24
acpi.oem=VBOX
acpi.revision=2
acpi.rsdp=0x000e0000
--snip--
```

这些值包括低级内核调优参数以及从硬件 BIOS 或 UEFI 中获取的信息。我们将在《加载器配置》一章的第 57 页中看到加载器变量的部分列表，书中的相关章节也会提到更多的值。

您可以按名称显示特定的变量。不幸的是，您不能显示一个关键字的所有子变量。像`show acpi.oem`这样的命令可以使用，但`show acpi`或`show acpi.*`则无法使用。

使用`set`命令可以更改单次启动的值。例如，要将`console`设置更改为`comconsole`，可以输入：

```
OK set console=comconsole
```

加载器允许您更改那些本不应该更改的变量。将 acpi.revision 设置为 4 不会突然将您的系统升级到 ACPI 版本 4，您也不能通过软件设置更换硬盘。

#### *重启*

您不是故意进入加载器的吗？重新开始吧。

#### *从加载器引导*

既然您已经调整了系统的低级设置，您可能想要启动系统。使用 boot(8)命令。您可以通过 man 页面中讨论的启动标志进一步调整启动。

一旦您的系统启动到您需要的状态，您可能希望将这些设置永久保存。FreeBSD 允许您通过加载器配置文件实现这一点。

### 加载器配置

通过配置文件*/boot/loader.conf*使加载器设置永久生效。此文件中的设置会在系统启动时直接传递给引导加载器。当然，如果你喜欢每次系统启动时都呆在控制台前，那就不用管这个了！

加载器有一个默认的配置文件，*/boot/defaults/loader.conf*。我们在这里覆盖了许多值。

如果您查看默认的加载器配置，您会看到许多与加载器中列出的变量类似的选项。例如，在这里我们可以设置控制台设备的名称：

```
console="vidconsole"
```

在整个 FreeBSD 文档中，您会看到提到*启动时可调节项*和*加载器设置*。这些设置都在*loader.conf*中配置，其中包括许多 sysctl 值，这些值在系统启动后变为只读。（有关可调节项和 sysctl 的更多信息，请参见第六章）。在这里，我们将内核变量`kern.maxusers`强制设置为`32`。

```
kern.maxusers="32"
```

有些变量在*loader.conf*中没有设置特定值，而是以空引号出现。这意味着加载器通常让内核设置此值，但如果您想覆盖内核的设置，您可以这样做。

```
kern.nbuf=""
```

内核对`kern.nbuf`的值有一定的认知，但如果需要，您可以让加载器指定一个不同的值。

我们将在适当的部分讨论通过引导加载器进行系统调优——例如，内核值将在第六章中讨论，届时它们会变得有点道理——但在这里，有一些常用的加载器值，影响加载器本身的外观和操作以及基本的启动功能。随着 FreeBSD 的成熟，开发人员会引入新的加载器值并修改旧的功能，所以一定要检查您的安装中的*/boot/defaults/loader.conf*，以获取当前的列表。

boot_verbose="NO"

这个值切换你可以通过启动菜单访问的详细启动模式。在标准启动中，内核会打印出一些关于每个设备的基本信息。当你以详细模式启动时，内核会要求每个设备驱动程序打印出它能获取的关于设备的所有信息，并显示各种内核相关的设置细节。详细模式对于调试和开发很有用，但通常不适合日常使用。

autoboot_delay="10"

这个值表示启动菜单显示与自动启动之间的秒数。我经常将其调低到 2 或 3 秒，因为我希望我的机器尽可能快地启动。

beastie_disable="NO"

这个值控制启动菜单的显示方式（最初，BSD “Beastie” 吉祥物的 ASCII 艺术图片装饰了启动菜单）。如果设置为 `YES`，启动菜单将不会显示。

loader_logo="fbsdbw"

这个值允许你选择启动菜单右侧显示的 logo。`fbsdbw` 选项给你默认的 FreeBSD ASCII 艺术 logo。其他选项包括 `beastiebw`（原始 logo）、`beastie`（彩色 logo）和 `none`（无 logo）。

### 启动选项

启动菜单还提供了三个选项：选择内核、设置启动选项和选择启动环境。我们将在适当的章节中讨论这些内容，但这里有一些简要的介绍，帮助你入门。

一台主机可以在其 */boot* 目录下拥有多个内核。选择 *Kernel* 选项会让加载器在可用的选项之间循环切换。要让某个内核作为选项出现，需要在 *loader.conf* 中的 kernels 变量中列出它。

```
KERNELS="kernel kernel.old kernel.GENERIC"
```

菜单只识别以 */boot/kernel* 开头的目录中的内核。如果你有一个内核在 */boot/gerbil* 中，你将需要从加载器提示符加载它。

FreeBSD 支持多种启动选项。选择 *Configure Boot Options* 项目会弹出最常用的选项。

**加载系统默认值**

你调整了设置并希望撤销所有这些操作？选择这个。你至少可以将系统启动到单用户模式，并修复你的 *loader.conf*。

**ACPI 支持**

ACPI 是高级配置和电源接口（Advanced Configuration and Power Interface），是英特尔/东芝/微软的硬件配置标准。它取代并包含了一堆晦涩的标准。ACPI 已经成为标准多年，但如果某个硬件在运行 FreeBSD 时遇到问题，你可以关闭它看看会发生什么。如果你甚至考虑尝试这个选项，务必阅读第二十四章并提交一个 bug 报告。

**安全模式**

FreeBSD 的 *安全模式* 启用了操作系统中几乎所有保守的选项。它关闭了硬盘的 DMA 和写入缓存，限制了速度但提高了可靠性。它还关闭了 ACPI。32 位系统会禁用 SMP。在安全模式下，USB 键盘将不再工作。这个选项对于调试旧硬件非常有用。

**详细模式**

FreeBSD 内核在启动时会探测每一块硬件。大多数发现的信息与日常使用无关，因此引导加载程序不会显示它们。当您以详细模式启动时，FreeBSD 会打印出它能获取的每个系统设置和附加设备的所有细节。这些信息稍后将在*/var/run/dmesg.boot*中可用，正如下一节所讨论的那样。我鼓励您在新机器上尝试详细模式，看看系统的复杂性。

最后，*选择启动环境*选项允许您在 ZFS 启动环境之间进行选择，如第十二章所讨论的。

### 启动消息

启动中的 FreeBSD 系统会显示指示系统附加硬件、操作系统版本以及各种程序和服务启动状态的消息。这些消息在您首次安装系统和进行故障排除时非常重要。启动消息总是以相同的方式开始，首先列出 FreeBSD 项目和加利福尼亚大学董事会的版权声明：

```
Copyright (c) 1992-2018 The FreeBSD Project.
Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994
    The Regents of the University of California. All rights reserved.
FreeBSD is a registered trademark of The FreeBSD Foundation.
FreeBSD 12.0-CURRENT #3 r320502: Fri Jun 30 13:48:50 EDT 2017
    root@storm:/usr/obj/usr/src/sys/GENERIC amd64
FreeBSD clang version 4.0.0 (tags/RELEASE_400/final 297347) (based on LLVM 4.0.0)
```

此外，您还会看到正在启动的 FreeBSD 版本的通知，以及它的编译日期和时间以及使用的编译器。您还可以看到是谁编译了这个内核，在哪台机器上构建的，甚至可以看到这个内核是在文件系统中的哪个位置构建的。如果您经常构建内核，这些信息在确定系统特性时可能非常有价值。

```
WARNING: WITNESS option enabled, expect reduced performance.
```

内核将在整个启动过程中打印诊断消息。前面的消息意味着我在这个特定的内核中启用了调试和故障识别代码，因此我的性能将受到影响。在这种情况下，我不关心性能影响，原因稍后会变得清晰。

```
Timecounter "i8254" frequency 1193182 Hz quality 100
```

此消息标识了特定的硬件。*时间计数器*，或*硬件时钟*，是一种特殊的硬件，虽然您的计算机需要它，但它是如此低级的设备，最终用户实际上无法直接使用它。偶尔，您会看到类似的消息，涉及一些对用户不可见但对系统至关重要的硬件。启动消息在显示过多细节和隐藏可能至关重要的细节之间摇摆。例如，它还会显示系统中 CPU 的所有信息：

```
CPU: Intel(R) Xeon(R) CPU E5-1620 v2 @ ➊3.70GHz (3700.08-MHz K8-class CPU)
  Origin="GenuineIntel"  Id=0x306e4  Family=0x6  Model=0x3e  Stepping=4
              ➋ Features=0xbfebfbff<FPU,VME,DE,PSE,TSC,MSR,PAE,MCE,CX8,APIC,SEP,MTRR,PGE,MCA,
CMOV,PAT,PSE36,CLFLUSH,DTS,ACPI,MMX,FXSR,SSE,SSE2,SS,HTT,TM,PBE>
  Features2=0x7fbee3ff<SSE3,PCLMULQDQ,DTES64,MON,DS_CPL,VMX,SMX,EST,TM2,SSSE3,CX16,
xTPR,PDCM,PCID,DCA,SSE4.1,SSE4.2,x2APIC,POPCNT,TSCDLT,AESNI,XSAVE,OSXSAVE,AVX,F16C,RDRAND>
  AMD Features=0x2c100800<SYSCALL,NX,Page1GB,RDTSCP,LM>
  AMD Features2=0x1<LAHF>
  Structured Extended Features=0x281<FSGSBASE,SMEP,ERMS>
  XSAVE Features=0x1<XSAVEOPT>
  VT-x: PAT,HLT,MTF,PAUSE,EPT,UG,VPID,VID,PostIntr
  TSC: P-state invariant, performance statistics
```

您可能不知道，简单的 CPU 竟然有如此多的细节和特性，对吧？但是当您提交故障报告时，指出某些高级特性无法正常工作，开发人员可能会问您的 CPU 是否具有某个特定的特性。

这是我不担心之前提到的`WITNESS`选项所导致的性能损失的原因：这台机器相当快➊，并且支持许多对现代 CPU 来说至关重要的功能➋。虽然我当然希望能够充分利用我所支付的性能，但我也希望在问题发生时能够及时捕捉到。我希望能够针对这些问题提交有效的 bug 报告，这样开发者才能听到我的问题报告。毕竟，这就是*为什么*我会运行带有 WITNESS 启用的 FreeBSD 开发版本！

```
FreeBSD/SMP: Multiprocessor System Detected: 8 CPUs
```

在这里，内核宣布它已经找到了所有八个 CPU 核心，并准备好管理它们。我有充足的 CPU 和相当多的内存。

```
➊ real memory  = 34359738368 (32768 MB)
➋ avail memory = 33207656448 ➌(31669 MB)
```

*实际*内存➊是计算机中实际安装的 RAM 数量，而*可用*内存➋是内核加载后剩余的内存。我的系统有 31,669MB 的 RAM ➌ 可供实际使用，这足以应对当前系统的负载。

```
➊ioapic0 <Version 2.0> ➋irqs 0-23 on motherboard
➌ioapic1 <Version 2.0> irqs 24-47 on motherboard
```

这是一个相当典型的设备条目。这个设备被称为 ioapic，内核已经发现这个硬件是 2.0 版本，并且有额外的信息与之关联➋。更重要的是，我们发现了两个这种类型的设备，编号为 0 ➊ 和 1 ➌。（所有设备的编号从零开始。）你可以通过阅读设备驱动程序的手册页来了解更多关于这个设备的信息。几乎所有—但并非全部—设备驱动程序都有手册页。

```
usbus0: EHCI version 1.0
usbus0 on ehci0
usbus0: 480Mbps High Speed USB v2.0
```

并非所有设备驱动程序都将它们的所有信息打印在一行上。在这里，我们有一个单一设备，usbus，它用三行来表示仅有的一个设备实例。唯一知道这是单一 USB 总线而非三个独立总线的方法是检查设备的编号。所有这些都属于设备编号零，所以它是一个单一设备。

```
➊ pci0: <simple comms> at device 22.0 (no driver attached)
➋ pcib8: <ACPI PCI-PCI bridge> irq 17 at device 28.0 on ➌pci0
➍ pci8: <ACPI PCI bus> on ➎pcib8
```

启动信息的一个有趣之处是，它们展示了计算机各个组件是如何连接在一起的。在这里，我们有 pci0 ➊，一个直接在主板上的 PCI 接口。然后是 pcib8 ➋，第八号 PCI 桥接器，连接到 pci0 ➌。我们还发现了连接到该 PCI 桥接器的 PCI 总线 pci8 ➍。继续阅读，你会发现连接到该总线的各个设备。现在你可能无法对这些信息做太多事情，但你会发现，当你需要排除故障时，拥有这些信息会非常有价值。

```
➊em0: <Intel(R) PRO/➋1000 Network Connection> port 0xd000-0xd01f mem 
0xfba00000-0xfba1ffff,0xfba20000-0xfba23fff irq 18 at device 0.0 on pci9
```

这个条目显示了 em0，一个 em(4) 类型的网络卡➊，并指出该卡支持千兆以太网➋。我们还看到关于它的内存地址、IRQ 和 PCI 总线连接等各种信息。

你计算机上的每个设备都有一个或多个类似这样的条目。整体来看，它们合理详细地描述了你计算机的硬件。如果你以详细模式启动，你会看到更多的细节—可能比你想要的还要多。

**启动信息文件**

尽管启动信息很有用，但它很可能在你需要时已经从屏幕上消失。为了将来参考，FreeBSD 会将启动消息存储在文件 */var/run/dmesg.boot* 中。这意味着即使系统已经运行了几个月，你仍然可以查看内核的硬件消息。

内核在启动消息中显示的一个关键内容是每个硬件设备的设备名称。这对于管理系统至关重要。每个硬件设备都有一个设备节点名称，要配置它，你需要知道这个名称。例如，之前我们看到了一张名为 em0 的以太网卡。该卡使用 em(4) 驱动程序，第一个由此驱动程序控制的设备编号为零。第二个同类型的设备将是 em1，接着是 em2，以此类推。

大多数可以配置或管理的设备都会在 */dev* 目录下的某个位置有一个设备节点条目。例如，第一个光驱由文件 */dev/cd0* 表示。这些文件被称为 *设备节点*，它们是指向特定硬件的便捷方式。大多数设备节点不能像常规文件那样直接访问；你不能对设备节点使用 cat(1) 命令，也不能将另一个文件复制到它上面。然而，设备节点会作为参数传递给专门的程序。例如，启动时出现的硬盘 ada4 与设备节点 */dev/ada4* 是相同的。当你想挂载这块硬盘时，可以使用设备节点名称，确保你正处理的是那块特定的硬件。

### 多用户启动

超越单用户模式，你将找到多用户模式。这是类似 Unix 的操作系统的标准操作模式。如果你在做实际工作，你的系统处于多用户模式。

当 FreeBSD 完成硬件检测并适当地加载所有设备驱动程序后，它会运行 shell 脚本 */etc/rc*。该脚本挂载所有文件系统，启动网络接口，配置设备节点，识别可用的共享库，并完成其他使系统准备好进行正常工作的任务。大多数系统有不同的启动要求；虽然几乎所有服务器都需要挂载硬盘，但 Web 服务器的操作要求与数据库服务器的操作要求非常不同，即使它们运行在完全相同的硬件上。这意味着 */etc/rc* 必须非常灵活。它通过将所有任务委派给其他负责系统特定方面的 shell 脚本来实现灵活性。

*/etc/rc* 脚本由文件 */etc/defaults/rc.conf* 和 */etc/rc.conf* 控制。

#### */etc/rc.conf、/etc/rc.conf.d 和 /etc/defaults/rc.conf*

与加载器配置文件类似，*/etc/rc* 的配置分为两个文件：默认设置文件 */etc/defaults/rc.conf* 和本地设置文件 */etc/rc.conf*。 */etc/rc.conf* 中的设置会覆盖 */etc/defaults/rc.conf* 中的任何值，正如加载器的配置方式一样。

*/etc/defaults/rc.conf* 文件非常庞大，包含许多变量，通常被称为 *knobs* 或 *tunables*。我们不会讨论所有这些变量，不仅因为 knobs 会不断增加，列出它们会很快过时，还因为很多 knobs 在服务器上并不常用。几乎 FreeBSD 系统中的每个东西都有一个或多个 *rc.conf* knobs，从键盘映射到 TCP/IP 行为。要查看完整且最新的列表，请阅读 rc.conf(5)。要更改 *rc.conf* 设置，可以使用文本编辑器或 sysrc(8)。

##### sysrc(8)

虽然手动编辑 *rc.conf* 完全可行，但在云计算时代，这种方式在大量机器上不可持续。如果必须修改数十台服务器，你需要一种可靠的方法来修改系统，而不是手动编辑每台服务器的配置或依赖 sed/awk 的“黑客”方法。^(2)

FreeBSD 包括 sysrc(8)，这是一个命令行程序，可以一致且安全地从命令行修改 */etc/rc.conf* 及其相关文件。此外，sysrc(8) 还可以显示有关系统非默认设置的信息。

使用 `-a` 来询问 sysrc(8) 你主机的相关信息。

```
# sysrc -a
clear_tmp_enable: YES
defaultrouter: 203.0.113.1
dumpdev: AUTO
keymap: us.dvorak.kbd
--snip--
```

你将获得所有非默认 */etc/rc.conf* 设置的列表。

要让 sysrc(8) 启用某个服务，提供变量名、等号和新值。

```
# sysrc rc_startmsgs=NO
rc_startmsgs: YES -> NO
```

变量 `rc_startmsgs` 现在被设置为 `no`。

请记住，sysrc(8) 是一个用于更改 *rc.conf* 的工具，而不是用来配置 FreeBSD 的工具。它不会进行有效性检查。我一个非常初级的系统管理员不希望 Bert 登录，他根据一些错误的建议进行了设置。

```
# sysrc bert=no
```

虽然这段代码在 */etc/rc.conf* 中设置了 `bert="no"`，但这个变量并没有任何作用。可以通过 `-x` 参数删除它。

```
# sysrc -x bert
```

许多 FreeBSD 配置文件与 *rc.conf* 类似。你可以通过添加 `-f` 参数和文件名，使用 sysrc(8) 来管理它们。

```
# sysrc -af /boot/loader.conf
```

是否应该编辑 *rc.conf* 或使用 sysrc(8)？如果你是在进行手动修改，那么使用你偏好的方式。如果是自动化操作，应该倾向于使用 sysrc(8)。本书中混合了两者的示例。

##### /etc/rc.conf.d/

如果你使用像 Puppet 或 Ansible 这样的服务器配置系统，你可能更信任复制整个文件而不是编辑它们。通过这些工具，使用 */etc/rc.conf.d/* 文件来启用服务。

要在 */etc/rc.conf.d/* 中管理一个服务，创建一个以服务名称命名的文件。也就是说，要管理 bsnmpd(8)，你需要创建 */etc/rc.conf.d/bsnmpd*。在该文件中启用或禁用该服务。

```
bsnmpd_enable=YES
```

我通常使用 Ansible 的服务启用功能，直接修改 */etc/rc.conf* 而不是 */etc/rc.conf.d*，但可以根据个人喜好选择使用。

接下来的几节展示了你可以在 */etc/rc.conf* 中启用和禁用的各种内容。每个设置都会出现在 */etc/defaults/rc.conf* 中，并可以通过 */etc/rc.conf* 条目进行覆盖。每个变量都带有默认设置。

##### 启动选项

以下*rc.conf*选项控制 FreeBSD 如何配置自身并启动其他程序。这些深远的设置会影响所有其他系统程序和服务的运行。

如果您遇到启动脚本本身的问题，您可以在*/etc/rc*及其下属脚本上启用调试功能。这可以提供有关脚本为何未能启动的额外信息。

```
rc_debug="NO"
```

如果您不需要完整的调试输出，但希望获得有关*/etc/rc 过程*的额外信息，可以使用`rc_info`启用信息性消息：

```
rc_info="NO"
```

当启动过程进入多用户启动阶段时，它会打印出每个启动的守护进程的消息。使用`rc_startmsgs`选项可以移除这些消息。

```
rc_startmsgs="NO"
```

##### 文件系统选项

FreeBSD 可以使用内存作为文件系统，正如我们在第十三章中讨论的那样。此功能的一个常见用途是通过使用内存而不是硬盘来加速*/tmp*。在阅读完第十三章后，您可能会考虑实现此功能。*rc.conf*中的变量允许您启用内存支持的*/tmp*并透明、轻松地设置其大小。您还可以选择 FreeBSD 将使用哪些选项来完成文件系统的配置。（那些急切的朋友们可能在想`-S`标志意味着什么。它的意思是*禁用软更新*。如果你不知道这是什么意思，也请等到第十一章再来看。）如果您想使用内存文件系统作为*/tmp*，请将`tmpmfs`设置为`YES`，并将`tmpsize`设置为您希望的*/tmp*大小。

```
tmpmfs="AUTO"
tmpsize="20m"
tmpmfs_flags="-S"
```

另一个流行的 FreeBSD 文件系统功能是其集成的加密分区。FreeBSD 开箱即用支持两种不同的文件系统加密系统：GBDE 和 GELI。*基于 GEOM 的磁盘加密（GBDE）*是 FreeBSD 设计的第一个加密文件系统，旨在用于军事级别的安全。GELI 则更加友好，并且符合与 GBDE 不同的标准。（在启用这些功能之前，您一定要阅读第二十三章！）

```
geli_devices=""
geli_tries=""
geli_default_flags=""
geli_autodetach="YES"
```

默认情况下，FreeBSD 在进入多用户模式后会以可读写的方式挂载根分区。如果您希望改为以只读模式运行，可以将以下变量设置为`NO`。许多人认为这种方式更安全，但只读根分区可能会干扰某些软件的运行，并且肯定会阻止您编辑根分区上的任何文件！

```
root_rw_mount="YES"
```

当启动中的 FreeBSD 尝试挂载其文件系统时，它会检查文件系统的内部一致性。如果内核发现文件系统存在重大问题，它可以尝试使用`fsck -y`自动修复这些问题。虽然在某些情况下这是必要的，但并非完全安全。（在启用此功能之前，请务必仔细阅读第十一章！）

```
fsck_y_enable="NO"
```

内核可能还会发现一些小的文件系统问题，它会在系统以多用户模式运行时，通过使用*后台 fsck* 自动解决这些问题，正如在第十一章中讨论的那样。在某些情况下，使用此功能的安全性存在合理的担忧。你可以控制后台 fsck 的使用，并设置系统在开始后台 fsck 之前等待多长时间。

```
background_fsck="YES"
background_fsck_delay="60"
```

##### 杂项网络守护进程

FreeBSD 包含许多较小的程序或守护进程，它们在后台运行以提供特定的服务。我们将在全书中介绍一些集成服务，但这里有几个对有经验的系统管理员来说特别有用的守护进程。一个流行的守护进程是 syslogd(8)。日志是好东西。日志是如此*非常*好，以至于第二十一章的大部分内容都专门讨论了在 FreeBSD 上如何使用、为、通过和在日志记录。

```
syslogd_enable="YES"
```

一旦决定运行日志守护进程，你可以通过设置命令行标志来精确控制它的运行方式。FreeBSD 在启动守护进程时会使用这些标志。所有可以接受命令行标志的 *rc.conf* 中的程序，都采用以下格式设置标志：

```
syslogd_flags="-s"
```

另一个流行的守护进程是 inetd(8)，它是用于小型网络服务的服务器。（我们在第二十章中介绍 inetd。）

```
inetd_enable="NO"
```

大多数系统使用安全外壳（SSH）守护进程进行远程登录。如果你希望通过网络远程连接到你的系统，几乎可以肯定需要 SSH 服务。

```
sshd_enable="NO"
```

虽然可以通过命令行配置 SSH 守护进程，但通常更好的方法是使用 */etc/ssh/* 中的配置文件。有关详细信息，请参见第二十章。

```
sshd_flags=""
```

FreeBSD 还集成了广泛的时间同步软件，确保系统时钟与外部世界同步。你需要配置这些设置才能使其有效；我们将在第二十章中详细讨论。

```
ntpd_enable="NO"
ntpd_flags="-p /var/run/ntpd.pid -f /var/db/ntpd.drift"
```

此外，FreeBSD 还包括一个小型的 SNMP 守护进程，用于与基于 SNMP 的管理工具配合使用。我们将在第二十一章中讨论如何配置 SNMP。

```
bsnmpd_enable="NO"
```

##### 网络选项

这些控制项决定了 FreeBSD 在启动时如何配置其网络设施。我们将在第七章中讨论网络配置。

互联网上的每台机器都需要一个主机名。主机名是系统的完全合格域名，例如 *www.absolutefreebsd.org*。没有这个主机名，许多程序将无法正常运行。

```
hostname=""
```

FreeBSD 包括一些不同的集成防火墙软件包。我们将在第十九章中简要介绍包过滤器（PF）。在 *rc.conf* 中启用和禁用 PF。

```
pf_enable="NO"
```

你可能对网络上尝试连接到你的系统的失败尝试感兴趣。这有助于检测端口扫描和网络入侵尝试，但也会收集大量垃圾数据。短时间内设置它查看网络上真正发生了什么会很有趣。（不过，知道什么是*真正*发生的往往会引起焦虑。）设置为 `1` 以记录失败的连接尝试。

```
log_in_vain="0"
```

路由器使用 ICMP 重定向来通知客户端计算机特定路由的正确网络网关。虽然这是完全合法的，但在一些网络中，入侵者可以利用这一点来捕获数据。如果你在网络中不需要 ICMP 重定向，可以为此选项设置一个极其小的安全措施。如果你不确定是否正在使用它们，可以询问你的网络管理员。

```
icmp_drop_redirect="NO"
```

如果你是网络管理员，并且不确定你的网络是否使用 ICMP 重定向，有一种简单的方法可以找出——只需将系统接收到的所有重定向记录到 */var/log/messages* 中。^(3) 请注意，如果你的服务器正在遭受攻击，这可能会很快填满你的硬盘。

```
icmp_log_redirect="NO"
```

要连接到网络，你需要为每个接口分配一个 IP 地址。我们将在第八章中详细讨论这一点。你可以使用 ifconfig(8) 命令获取网络接口的列表。每个网络接口列在其自己的行上，配置的网络信息放在引号中。例如，要为你的 em0 网卡分配一个 IP 地址 172.18.11.3 和子网掩码 255.255.254.0，你可以使用：

```
ifconfig_em0="inet 172.18.11.3 netmask 255.255.254.0"
```

如果你的网络使用 DHCP，请使用 `dhcp` 作为 IP 地址。

```
ifconfig_em0="dhcp"
```

类似地，你可以为网络卡分配别名。别名不是卡的实际 IP 地址，但卡会响应该 IP 地址，如第八章中所述。FreeBSD 支持在单个网卡上配置数百个别名，形式如下：*rc.conf* 中的条目：

```
ifconfig_em0_aliasnumber="address netmask 255.255.255.255"
```

别名编号必须是连续的，从 0 开始。如果编号中断，编号中断之后的别名将在启动时不会被安装。（这是一个常见问题，当你遇到此问题时，请检查你的别名列表。）例如，192.168.3.4 的别名将列为：

```
ifconfig_em0_alias0="192.168.3.4 netmask 255.255.255.255"
```

##### 网络路由选项

FreeBSD 的网络栈包括许多用于路由互联网流量的功能。这些从最基础的配置开始，例如为默认网关配置 IP 地址。虽然为网络接口分配有效的 IP 地址让你能够进入本地网络，但默认路由器将使你可以访问局域网以外的一切。

```
defaultrouter=""
```

网络控制设备，如防火墙，必须在不同的接口之间传递流量。虽然 FreeBSD 默认不会执行此操作，但启用它非常简单。只需告诉系统它是一个网关，它就会为你连接多个网络。

```
gateway_enable="NO"
```

##### 控制台选项

控制台选项控制着显示器和键盘的行为。你可以更改键盘的语言、显示器的字体大小，或者几乎任何你想调整的内容。例如，键盘映射默认使用标准的美国键盘，通常称为 *QWERTY*。你可以在目录 */usr/share/syscons/keymaps* 中找到各种键盘映射。我个人偏好 Dvorak 键盘布局，它在该目录下的条目为 *us.dvorak*。将 `keymap` 设置为 *us.dvorak* 后，我的系统将在启动至多用户模式时使用 Dvorak 键盘布局。

```
keymap="NO"
```

FreeBSD 会在键盘长时间空闲后将显示器调暗，空闲时间由 `blanktime` 设置决定。如果将其设置为 `NO`，FreeBSD 将不会调暗屏幕。不过，新硬件也会在一段时间后调暗显示器，以节省电力。如果你已经将 `blanktime` 设置为 `NO`，但屏幕仍然变暗，请检查你的 BIOS 设置和显示器手册。

```
blanktime="300"
```

FreeBSD 还可以在控制台上使用多种字体。虽然默认字体对于服务器来说足够了，但你可能希望在桌面或笔记本电脑上使用不同的字体。我的笔记本电脑有一个 17 英寸的屏幕，适合观看电影，而默认字体在这个尺寸下看起来有些不合适。你可以从目录 */usr/share/syscons/fonts* 中选择新字体，试试不同的字体，看看它们在系统上的效果。字体名称包括字体大小，因此你可以设置相应的变量。例如，字体 *swiss-8x8.fnt* 是瑞士字体，大小为 8 像素 x 8 像素。要使用它，你需要设置 `font8x8` 变量。

```
font8x16="NO"
font8x14="NO"
font8x8="YES"
```

即使没有图形用户界面，你也可以在控制台上使用鼠标。默认情况下，FreeBSD 会尝试自动检测你的鼠标类型。如果你使用的是 PS/2 或 USB 鼠标，启用鼠标守护进程后，它很可能会自动工作，无需特别配置。一些较旧或不常见的鼠标类型需要手动配置，具体内容请参见 moused(8)。

```
moused_enable="NO"
moused_type="AUTO"
```

你还可以根据需要调整显示器上的显示内容。如果你的显示器尺寸不寻常，你可以调整文本的行数和长度，使其适配；还可以更改文本颜色、光标及其行为，进行其他各种小调整。你可以在 man vidcontrol(1) 中查看不同选项的完整列表。

```
allscreens_flags=""
```

同样地，你几乎可以任意调整键盘的行为。从按键重复速度到功能键的效果，都可以根据需要进行配置，具体内容请参见 kbdcontrol(1)。

```
allscreens_kbdflags=""
```

##### 其他选项

这些最终的选项可能在特定环境下有用，也可能没有，但由于它们经常需要使用，因此值得提及。例如，并非所有系统都有打印机可用，但有打印机的系统会希望运行打印守护进程 lpd(8)。我们会在第二十章中提到打印机配置。

```
lpd_enable="NO"
```

sendmail(8) 守护进程管理系统间邮件的发送和接收。虽然几乎所有的系统都需要发送邮件，但大多数 FreeBSD 机器不需要接收邮件。`sendmail_enable` 控制接收邮件，而 `sendmail_outbound_enable` 则允许机器发送邮件。有关更多详细信息，请参见第二十章。

```
sendmail_enable="NO"
sendmail_submit_enable="YES"
```

FreeBSD 的一个更有趣的特点是它能够运行为 Linux 构建的软件。我们在第十七章中讨论了这个功能。运行 Linux 软件并不像打开一个开关那么简单，所以在启用 Linux 兼容模式之前，先阅读那一章！

```
linux_enable="NO"
```

任何类 Unix 操作系统的一个重要组成部分是共享库。你可以控制 FreeBSD 查找共享库的位置。尽管默认设置通常足够用，但如果你发现自己经常为用户设置 `LD_LIBRARY_PATH` 环境变量，应该考虑调整库路径。有关库路径的更多建议，请参见第十七章。

```
ldconfig_paths="/usr/lib /usr/local/lib"
```

FreeBSD 有一个安全配置文件系统，允许管理员控制基本的系统功能。你可以全局禁止挂载硬盘、访问特定的 TCP/IP 端口，甚至更改文件。有关如何使用这些功能的详细信息，请参见第九章。

```
kern_securelevel_enable="NO"
kern_securelevel="-1"
```

现在你已经了解了 FreeBSD 默认支持的一些配置选项，让我们来看一下它们是如何使用的。

### rc.d 启动系统

FreeBSD 通过 shell 脚本 */etc/rc* 弥补了单用户模式和多用户模式之间的空白。这个脚本读取配置文件 */etc/defaults/rc.conf* 和 */etc/rc.conf*，并根据这些文件中找到的内容运行一系列其他脚本。例如，如果你启用了网络时间守护进程，*/etc/rc* 会运行一个专门用来启动该守护进程的脚本。FreeBSD 包含了用于启动服务、挂载磁盘、配置网络和设置安全参数的脚本。

这些脚本位于*/etc/rc.d* 和 */usr/local/etc/rc.d*。我建议你阅读其中的一些脚本，即使只是为了了解 *rc.d* 系统是如何工作的。

使用 service(8) 来控制这些脚本。

#### *service(8) 命令*

所有 *rc.d* 脚本都是可读的，它们如何组合在一起是相当直观的。当你遇到问题时，你可以阅读这些脚本，看看它们是如何工作的，做了什么。不过这有点像工作，大多数系统管理员有更有趣的工作要做。service(8) 命令提供了一个友好的前端来管理 *rc.d* 脚本。你可以使用 service(8) 查看哪些脚本会自动运行；停止、启动和重启服务；检查服务状态；以及更多操作。

##### 列出和识别已启用的服务

使用 `-e` 标志调用 service(8)，可以查看系统启动时将按顺序运行的所有脚本的完整路径。

```
# service -e
/etc/rc.d/hostid
/etc/rc.d/zvol
/etc/rc.d/hostid_save
/etc/rc.d/zfsbe
--snip--
/etc/rc.d/sshd
/etc/rc.d/sendmail
--snip--
```

这个小型主机在启动时运行 23 个脚本。

这里的一个重要细节是脚本名称。你将会在其他命令中使用脚本名称，比如启动、停止和重启服务。

##### 管理服务

虽然完全可以在命令行中重新启动，例如，sshd(8)，但生产主机需要保持所有服务的一致运行。最佳实践是使用 service(8) 来管理进程。你需要像前面展示的那样使用脚本名称，但不包含目录路径。

```
# service name command
```

例如，假设我想重启 sshd(8) 服务。根据之前显示的 `service -e` 输出，有一个脚本 */etc/rc.d/sshd*。我强烈怀疑这个脚本管理着 sshd(8)，但我想确定自己不会不小心重启 Stupidly Similarly named Harassment Daemon。此时就需要用到 `describe` 命令。让我们让 service(8) 来描述 *sshd* 脚本。

```
# service sshd describe
Secure Shell Daemon
```

它是正确的守护进程。让我们重新启动它。

```
   # service sshd restart
➊ Performing sanity check on sshd configuration.
➋ Stopping sshd.
➌ Performing sanity check on sshd configuration.
➍ Starting sshd.
```

重启服务实际上是“停止服务”和“启动服务”的组合。不过这个特定的服务不仅仅做这些。它首先通过验证配置文件 ➊ 然后停止守护进程 ➋，接着重新验证配置 ➌ 并启动守护进程 ➍。为什么？

SSH 处理此主机的远程访问。如果 SSH 服务出现故障，任何人都无法登录主机来修复 SSH 服务。是的，你可以使用远程 KVM 或 IPMI，或者开车去托管中心，但这些都会延长停机时间。最好在关闭之前验证 sshd(8) 是否可以*重新启动*。许多服务脚本包括这种安全检查。如果某个服务抱怨无法停止，仔细查看输出，找出原因。

每个服务支持的命令各不相同。获取特定服务支持的完整命令列表的最简单方法是给服务一个无效参数。像“bert”这样的参数就相当无效。

```
# service sshd bert
/etc/rc.d/sshd: unknown directive 'bert'.
Usage: /etc/rc.d/sshd fast|force|one|quiet
```

你将获得此服务支持的完整命令列表，分为两组。

第一组（用方括号括起来）包含命令的选项。这里是标准选项。将它们作为第二组命令的前缀来使用。

fast 不进行检查（用于启动时）。

force 更加努力地尝试。

one 即使在 *rc.conf* 中未启用，也启动该服务。

quiet 只打印服务名称（用于启动时）。

第二组（用圆括号括起来）包含以下命令：

start 启动服务。

stop 停止服务。

restart 停止并重启服务。

rcvar 打印此服务的*rc.conf*变量。

enabled 如果启用则在 shell 中返回 true（用于脚本）。

describe 打印服务描述。

extracommands 显示服务特定的命令。

`extracommands` 命令非常特定于服务，并且仅列出该服务接受的附加命令。默认情况下，附加命令会出现在默认命令之后。这里是一些常见的附加命令：

configtest 解析服务的配置文件，并在出现错误时停止。

reload 执行软重载（通常通过 SIGHUP），而不是重启。

status 确定服务是否正在运行。

要确定服务的额外命令到底做了什么，你需要阅读服务脚本。

我们将在第十七章中详细讨论 *rc.d*，那时我们会讨论如何定制和编写你自己的 *rc.d* 脚本。

#### *系统关闭*

FreeBSD 使得 *rc.d* 启动系统发挥双重作用；它不仅必须处理系统启动，还必须在关机时关闭所有这些程序。必须有某些操作来卸载所有硬盘，关闭守护进程，并在完成所有工作后进行清理。一些程序不在乎它们是否在系统关闭时被无情地终止——毕竟，系统关闭后，通过 SSH 连接的客户端会被踢掉，任何未完成的网页也会停留在中间。然而，数据库软件非常关心它是如何关闭的，无情地杀死进程会损坏你的数据。许多管理实际数据的其他程序也非常挑剔，如果你不让它们清理自己，你会后悔的。

当你使用 shutdown(8)、halt(8) 或 reboot(8) 命令关闭 FreeBSD 时，系统会调用 shell 脚本 */etc/rc.shutdown*。该脚本依次调用每个 *rc.d* 脚本，并传递 `stop` 选项，顺序与启动时相反，从而允许服务器程序优雅地终止，并在断电前清理磁盘。

### 串行控制台

所有这些控制台的东西都很好，但当你的 FreeBSD 系统位于全国另一端或另一个大洲的共置设施中时，你无法走到键盘前开始输入。许多数据中心没有足够的空间放置键盘或显示器。那么，当机器无法响应网络时，如何远程重启它呢？使用串行控制台将计算机的键盘和视频信号重定向到串行端口，而不是键盘和显示器，可以解决这些问题。

串行控制台可以是物理的，例如计算机背面的串行端口。通过将标准的空接线调制解调器电缆连接到串行端口，并将另一端连接到另一台计算机的串行端口，你可以通过第二台计算机访问第一台系统的启动信息。

它们也可以是虚拟的，例如由 IPMI 的 *Serial-over-LAN (SOL)* 协议提供的虚拟控制台。你需要设置 IPMI 接口并使用特殊软件配置和访问虚拟串行端口，而不是使用空接线调制解调器电缆。

不过，在我们设置端口之前，先来了解一下串行端口协议。

#### *串行协议*

一些最早的计算机控制台是通过串行端口连接到电传打字机的。串行通信已经存在很长时间，并在几十年中不断发展。与现代协议不同，串行线路不会自动协商。你必须将串行连接的两端配置为完全相同的设置。如果配置不匹配，屏幕可能会变成空白，或者显示乱码。

原始的串行线路工作在低速下。许多串行电缆基本保持不变，但我们已经开发出了更好的软件和硬件，能够在每端连接，使我们能够更快地传输数据。旧的串行连接速度为 300 比特每秒（波特率），而一大批现代硬件可以运行在 115,200 波特。尽管如此，在不同的硬件平台之间，常见的标准波特率是 9600 波特，这是 FreeBSD 的默认控制台速度。9600 波特率足以以舒适的速度传输整屏的文本。

对于物理连接，最好坚持使用 9600 波特率，除非无法做到。某些现代硬件不支持 9600 波特率。也有一些硬件宣称支持 9600 波特率，但实际上并不支持。我曾经遇到过硬件被硬编码为 115,200 波特的设备。任何无法或坚决拒绝使用 9600 波特率的设备在设计上就是有问题的，但我们通常无法控制硬件的选择。除非是硬件限制，否则更改串口速度会让你的连接变得更加脆弱，而如果你正在使用控制台，你是没有心情面对脆弱性的。当我提到更改端口速度时，那仅仅是当你必须这样做时才使用的建议。

SOL 连接不是物理线缆，因此你不需要担心线路噪声。你可以安全地在更高的速度下运行它们。

串行协议还包括许多除了速度之外的设置。你可以修改它们，但 8 个数据位、无奇偶校验和 1 个停止位的标准设置是最广泛使用的。你无法在 FreeBSD 中更改这些设置，除非重新编译内核，因此不要乱动这些设置。

记住这些，我们来设置一个控制台。

#### *物理串行控制台设置*

无论你使用的是何种串行控制台，你都需要正确地插入连接才能使其工作。你需要一根空调调制解调器电缆，可以在任何计算机商店或在线供应商处购买。虽然镀金串行电缆不值得花钱，但也不要购买你能找到的最便宜的电缆；如果你遇到紧急情况并需要串行控制台，你可能不会心情去忍受线路噪声！^(4)

将空调调制解调器电缆的一端插入你的 FreeBSD 服务器上的串行控制台端口——默认情况下是第一个串行端口（COM1 或 uart0，具体取决于你习惯使用的操作系统）。你可以通过服务器来更改此设置。

将空调调制解调器电缆的另一端插入另一个系统的空闲串口。我推荐使用另一个 FreeBSD（或其他 Unix 系统）或终端服务器，但如果你只有 Windows 系统，也可以使用。

如果你在远程位置有两台 FreeBSD 机器，确保它们每台都有两个串口。准备两根空中调制解调器电缆，并将每台机器的第一个串口连接到另一台机器的第二个串口。这样，你可以将每台机器作为另一台机器的控制台客户端。如果你有三台机器，可以将它们串联成一个环形。通过将两台和三台机器组合在一起，你可以在任何数量的系统上使用串行控制台。我曾在数据中心工作，那里有 30 或 40 台 FreeBSD 机器，安装显示器根本不现实，我们用串行控制台取得了很好的效果。然而，一旦你有了一两个机架的服务器，投资一个终端服务器是一个非常好的主意。你可以在 eBay 上找到它们，价格便宜。

另一种选择是使用两台 DB9 转 RJ45 转换器，一台标准转换器和一台交叉转换器。这样，你可以通过标准的 CAT5 电缆连接控制台。如果你有一个禁止人类进入的灯塔数据中心，你可以将串行控制台的连接引到你的桌子旁、温暖的房间或任何其他标准以太网式跳线板可达的地方。大多数现代数据设施更适合处理以太网，而不是串行电缆。

#### *IPMI 串行控制台设置*

*智能平台管理接口 (IPMI)* 是一种在硬件层面上管理计算机系统的标准。IPMI 独立于操作系统运行，使用一个叫做*基板管理控制器 (BMC)* 的小型设备。基本上，BMC 就像是你的远程双手和双眼，用来控制服务器。要使用 IPMI 控制台，你需要同时配置 BMC 和主机的 BIOS 或 UEFI。

我会在这里尝试给你一些方向，但配置 BMC 或 UEFI 的最佳资源是你的硬件手册。^(5)

##### BMC 设置

服务器的 BMC 有自己的 IP 地址，通常会获得主板上的专用以太网端口。每个厂商根据自己的偏好设计自己的 BMC。这意味着，配置 BMC 的内容远远超出了本书的范围，但这里有一些提示。

大多数 BMC 配置通过网页界面进行。然而，在你访问网页界面之前，BMC 需要一个 IP 地址。大多数 BMC 的 IP 信息可以在 BIOS 或 UEFI 固件的设置菜单中进行设置。进入管理界面后，配置用户名和密码。记住它们。

一般的 BMC 还包括诸如主系统的电源循环、通过某种下载应用程序（通常是 Java）进行远程控制台访问、虚拟媒体等功能。

永远不要忘记，BMC 是一个运行 Web 服务器的小型嵌入式计算机，它是由某个超负荷工作的公司员工编写的，目的是建立最小可行产品。BMC 并没有经过长时间运行后的性能测试。如果它给你带来任何问题，就重启它。你不需要重启整个计算机；通常在网页界面中会有一个“BMC 重置”或“单元重启”的选项。

如果 BMC 支持基于小程序的控制台，为什么还要使用串口控制台？因为 BMC 控制台是基于小程序的，而 BMC 固件很少更新。我有很多 BMC 控制台，只能使用过时、不安全^(6)的 Java 版本。使用它们需要覆盖安全警告并反复点击“是的，我知道我很傻，还是继续做”框。我不得不专门保留一个虚拟机，用这个不安全的 Java 版本来访问这些控制台。基于小程序的控制台不支持复制粘贴，并且通常延迟很高。

在较慢的连接上，IPMI 比 Java 控制台小程序更好用。我可以复制和粘贴。而且，我可以在任何现代操作系统的命令行中使用 IPMI 控制台。

当你进入 BMC 设置时，找到启动 SOL 的选项。它会启动一个小程序，连接到主机的 SOL 接口，帮助你测试串口控制台配置。

##### UEFI/BIOS 串口控制台配置

一旦 BMC 准备好，你必须配置服务器硬件，将串口指向 BMC。进入硬件的设置菜单，在那里配置 UEFI 或 BIOS。在那个复杂的小选项迷宫中，你会找到类似“串口控制台重定向”这样的选项。

这里的一个重要问题是，你的主机有多少个串口？可能没有，也可能有好几个。你可以选择重定向其中一个串口，或者添加一个额外的虚拟端口。我建议你保持现有的串口不动，添加一个专门用于 SOL 的虚拟端口。它可能被称为“SOL 控制台重定向”。启用它，然后进入该端口的设置。

这里有一些我认为对 FreeBSD 和 SOL 有帮助的设置：

**终端类型** vt100

**数据位** 8

**奇偶校验** 无

**停止位** 1

**流控制** 无

关键部分是波特率、速度或每秒比特数设置。保持默认速度，但记下它。你将需要这个速度来进行连接。

现在你有了串口控制台，设置 FreeBSD。

#### *配置 FreeBSD 的串口控制台*

当 FreeBSD 启动时，加载程序决定在哪里打印控制台消息以及从哪里接受输入。虽然默认是从显示器和键盘，但通过一些调整，你可以将控制台重定向到串口。串口控制台不会提供 BIOS 访问权限，但你几乎可以以任何方式调整 FreeBSD 启动过程。你可以在第一阶段或第二阶段引导加载器中配置串口控制台。

第一级引导加载程序能让你在最早的时候访问控制台，但它要求你使用第一个串口作为控制台。更改端口需要重新编译内核。第一级引导加载程序允许你执行像选择从哪个磁盘加载第二级引导加载程序的任务——本质上是从与 BIOS 或 UEFI 选择的磁盘不同的磁盘引导。这无疑很有用，但很少有用户需要这样做。

第二阶段的引导加载器可以使用任何串口作为控制台，但你首先看到的输出将是《引导提示》中讨论的引导菜单，位于第 55 页。对我们大多数人来说，这完全可以接受。

##### 控制台选项

FreeBSD 的默认配置使用显示器和键盘作为控制台。你可以选择切换到仅串口控制台，或者使用双控制台。通过*/boot/loader.conf*选项`console`来选择其中之一。

仅使用串口的控制台可以防止一些随机的共同工作者对你的设备进行断电重启、插入显示器并修改菜单。是的，他们仍然可以通过第一阶段加载器制造混乱，或者从 USB 启动，但这需要更高的技能。将*console*变量设置为`comconsole`，以仅使用串口作为控制台。

```
console="comconsole"
```

对于大多数部署，我推荐使用双控制台。双控制台会同时在串口和显示器上显示控制台活动。你可以根据需要使用标准控制台或串口控制台。通过列出`comconsole`和`vidconsole`来指定双控制台配置。

```
console="comconsole vidconsole"
```

如果你处在服务器机房环境中，可能会需要在标准控制台和串口控制台之间切换。我通常通过串口控制台管理大量的 FreeBSD 系统，但如果发生问题，我会保留视频控制台以备不时之需。

控制台在重新启动后才会生效。你可以通过查看启动消息来确认 FreeBSD 是否将其控制台放置在串口上。

```
uart0: <16550 or compatible> port 0x3f8-0x3ff irq 4 flags 0x10 on acpi0
uart0: console (9600,n,8,1)
```

第二行显示串口 uart0 被配置为控制台，使用默认设置。我们将在《使用串口控制台》中查看这些设置，位于第 79 页。

##### 高级控制台选项

除了启用控制台外，你还可以调整控制台的端口和速度。

也许我需要使用第二个串口作为控制台。也许第一个串口已经插入了某些设备，或者第二个端口是虚拟 SOL 端口。串口使用 uart(4)设备驱动程序。记住，FreeBSD 设备的编号从零开始，而 COM 端口的编号从 1 开始。COM1 是 uart0，COM2 是 uart1，以此类推。你需要知道端口的基础 I/O 端口，这可以从系统启动消息中获得。

```
# grep uart /var/run/dmesg.boot
uart0: <16550 or compatible> port ➊0x3f8-0x3ff irq 4 flags 0x10 on acpi0
uart1: <16550 or compatible> port ➋0x2f8-0x2ff irq 3 on acpi0
```

单词 port 后面的第一个数字是基础 I/O 端口➊。COM2（或 uart1）的基础地址是 0x2f8。将`comconsole_port`设置为这个值➋。

```
comconsole_port="0x2f8"
```

你的控制台现在位于串口 COM2。

如果我的串行连接无法达到 9600 波特率，我可以通过`comconsole_speed`选项来更改端口速度。

```
comconsole_speed="115200"
```

在物理端口上，不要仅仅因为可以就增加端口速度。

#### *使用串口控制台*

现在你已经完成了物理和软件的设置，接下来配置你的客户端来访问串口控制台。使用串口控制台的关键是记住以下设置：

+   速度（9600 波特，或者你硬件设置的其他值）

+   8 位

+   无奇偶校验

+   1 停止位

访问串行线路的方式取决于它是物理线路还是 IPMI SOL 连接。

##### 物理串行线路

将你的客户端连接到串行线路的另一端。你可以在 Microsoft 平台（PuTTY 是最著名的）、macOS 以及几乎任何其他操作系统上找到终端仿真器。曾几何时，我使用过一台 Palm 掌中宝手持设备，通过串行电缆访问串行控制台。输入正确的设置值到终端仿真器中，串行控制台就会“正常工作”。

FreeBSD 通过 tip(1)访问串行线路，这是一款让你像 telnet 一样连接到远程系统的程序。要运行 tip，作为 root 用户执行以下操作：

```
# tip portname
```

端口名称是指定要在串行端口上使用的串行端口号和速度的简写。文件*/etc/remote*包含了端口名称的列表。该文件中的大多数条目都是 UUCP（Unix-to-Unix 复制协议）曾是主要数据传输协议、串行线路曾是常见连接方式的时代遗留下来的遗物。^(7) 在文件的末尾，你会看到几个类似的条目：

```
# Finger friendly shortcuts
uart0|com1:dv=/dev/cuau0:br#9600:pa=none:
uart1|com2:dv=/dev/cuau1:br#9600:pa=none:
--snip--
```

`uart`条目是标准的 Unix 类型设备名称，而`com`名称是为了方便那些使用过 x86 硬件的人而添加的。

假设你有两台 FreeBSD 机器，背靠背连接，每台机器的串行端口 1 通过 null-modem 电缆连接到串行端口 2。两台机器都配置为使用串行控制台。你将需要连接到本地的串行端口 2，以与另一台系统的串行控制台通信：

```
# tip uart1
connected
```

成功连接！

要断开串行控制台，随时按 ENTER 键，然后输入断开序列“波浪符点”。

```
~.
```

你将被优雅地断开连接。（这也适用于 OpenSSH 客户端。）

tip(1)程序使用波浪符号（`~`）作为控制字符。请阅读 man 页面，查看你可以用它做的所有事情。

##### IPMI SOL 连接

你需要一个 SOL 客户端来连接到你的 IPMI 串行端口。测试你的配置的最快方法可能是使用 BMC 中包含的 SOL 客户端 Applet。尽管该客户端与控制台 Applet 有许多相同的缺点，但它是一个很好的测试场所。如果 BMC 的 SOL 客户端无法工作，请检查你的 SOL 设置和 FreeBSD 配置。验证 SOL 客户端是否设置为使用与你在硬件和 FreeBSD 中设置的相同速度。如果它不起作用，但所有设置看起来匹配，请重启 BMC。一旦它工作，你就可以从另一个主机使用 SOL 了。

标准的 IPMI SOL 客户端是 IPMItool（*[`sourceforge.net/projects/ipmitool/`](https://sourceforge.net/projects/ipmitool/)*），作为 ipmitool 软件包提供。（第十五章讨论了软件包。）IPMItool 可以通过网络与 BMC 交互，提供所有 BMC 功能，无需登录到笨重的 Web 界面。你可以重新启动主机、检查硬件报警和传感器等，所有这些都可以通过命令行完成。但目前，我们将继续使用 SOL 控制台。使用 BMC 的主机名或 IP 地址、用户名和密码登录到 SOL。

```
# ipmitool -H bmc -U username -I lanplus sol activate
```

在这里，我以用户名“bert”登录到我的 Web 服务器的 BMC，主机名为 www-bmc。

```
# ipmitool -H www-kvm -U bert -I lanplus sol activate
```

在提示符下输入密码，SOL 会确认你的登录。

```
[SOL Session operational.  Use ~? for help]
```

我们有控制台。应该有吧。让我们做最后的测试。

#### *在控制台工作*

串行控制台的真正考验在于你是否能够通过它传输数据。一旦你连接了控制台，按下 ENTER 键。

```
FreeBSD/amd64 (www) (ttyu2)

login:
```

FreeBSD 默认允许通过串行控制台登录。登录主机并重启，它会显示通常的控制台信息。

```
Jul 13 11:48:24 Stopping cron.
Stopping sshd.
Stopping devd.
Writing entropy file:.
Writing early boot entropy file:.
Terminated
.
Jul 13 11:48:24 zfs1 syslogd: exiting on signal 15
Waiting (max 60 seconds) for system process `vnlru' to stop... done
Waiting (max 60 seconds) for system process `bufdaemon' to stop... done
Waiting (max 60 seconds) for system process `syncer' to stop...
Syncing disks, vnodes remaining... 0 0 0 done
All buffers synced.
```

系统运行 BIOS 程序并将控制权交给串行控制台时，会有一段较长的暂停。就在你决定机器再也不会启动时，你会看到引导菜单。恭喜！你正在使用串行控制台。按空格键中断启动，就像你在键盘前一样。

系统距离有多远并不重要；你可以更改启动内核，获得详细的启动信息，在单用户模式下启动，或者手动运行 fsck 检查硬盘——都可以。软件串行控制台可能无法显示 BIOS，但很有可能它已经正确设置。使用串行控制台一段时间后，机器是否在地球的另一端还是房间的另一边都不再重要；仅仅是为了访问控制台而离开座椅会显得太麻烦。

如果远程位置的系统完全锁死，你可以连接到串行控制台，并让机房的“远程操作人员”重启系统。这对你的计算机可能不好，但系统被锁死也不好。通过串行控制台，你可以进入单用户模式，并通过查看日志和进行其他故障排除来修复问题。我们将在第二十四章讨论这种问题的故障排除。

现在你已经理解了 FreeBSD 是如何启动和关闭的，让我们来看一些基本工具，确保即使你在实验过程中，系统仍然能继续运行。
