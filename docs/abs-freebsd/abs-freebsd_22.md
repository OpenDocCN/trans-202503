## 第二十二章：**JAILS**

![image](img/common01.jpg)

虚拟化将操作系统实例与底层硬件分离。虚拟化使你可以通过复制文件将操作系统安装从一台硬件迁移到另一台硬件。虚拟化需要在硬件上安装操作系统，但该安装通常非常精简，没有面向公众的服务，并且可以在新硬件上轻松重建。这或许是几十年来系统管理中最大的变化。

虚拟化有点像客户端-服务器环境。硬件及其核心操作系统实例是 *宿主*，而 *客户端* 是所有虚拟化的操作系统实例。客户端依赖宿主提供基本服务，如存储、处理器性能和内存。对宿主的更改可以反映在虚拟化的客户端中，但客户端上的更改不会对宿主产生影响，除了消耗资源之外。

FreeBSD 支持两种类型的虚拟化：jails 和 bhyve。

*Jail* 是一种轻量级虚拟化方法，有时称为 *操作系统级虚拟化*。一个 jail 通常包含一个完整的操作系统用户空间，运行在现有 FreeBSD 系统之上。jail 依赖于宿主系统的文件系统，但只限于目录树的一个子集。它甚至可能在 ZFS 池中有一块专用空间。一个 jail 没有自己的内核，而是在宿主系统的内核限制区域内运行。宿主系统可以在不进入 jail 的情况下管理其中的进程，或者如果需要，也可以在 jail 内运行进程。Jail 不提供图形控制台。使用 jail 来虚拟化相同版本或更早版本的 FreeBSD 安装，或运行简单的虚拟 Linux 系统。

*Bhyve* 是一个更重的虚拟化系统。与使用宿主的内核和文件系统不同，bhyve 模拟硬件。宿主系统为虚拟机提供一块磁盘空间作为存储。一个 bhyve 虚拟机必须携带自己的文件系统、内核和支持基础设施。与 jails 相比，bhyve 虚拟机需要更多的资源，但它们还提供通过虚拟网络计算（VNC）的控制台，并且可以运行真正的外来操作系统，如 Microsoft Windows。由于 bhyve 的快速发展，它正在迅速变化，因此本书没有涵盖它。等到 bhyve 稳定后，我会再写关于它的内容。

在考虑 bhyve 之前，先看看 jail 是否能满足你的需求。

### Jail 基础

Jail 是一种增强版的 chroot，不仅对文件系统适用，还对进程和网络栈进行限制。一个被限制的系统只能访问文件系统的一小部分，无法看到 jail 外的进程。传统上，每个 jail 都分配一个专用的 IP 地址，并且该 jail 只能查看该 IP 的流量。每个 jail 甚至有自己的用户账户。在 jail 中，root 账户完全控制该 jail，但无法访问 jail 之外的任何内容。

对于一个拥有 root 权限的监狱用户来说，监狱看起来像一个几乎完整的 FreeBSD 系统，只缺少一些设备节点。用户可以安装任何她喜欢的软件，而不会干扰主机或其他监狱。监狱中运行的所有进程只能影响监狱的文件和进程。被监禁的用户无法看到监狱之外的任何内容；她被限制在监狱中。如果监狱被黑客入侵，入侵者也会被限制在监狱中。

监狱可以使用基于 vnet(9) 的虚拟网络栈。这是一种高级用法，本文不涉及，但如果你需要为监狱提供自己的路由表，可以按照这种方式操作。

从 FreeBSD 9 开始，多个监狱可以共享一个 IP 地址，但系统管理员需要为每个监狱配置唯一的 TCP/IP 端口来提供每个网络服务。你不能在同一个 IP 的端口 22 上运行多个 SSH 实例！为了简便起见，以下示例为每个监狱使用一个 IP，但请记住，你还有其他选择。

许多人将所有服务都放在监狱中，即使主机是专门用于某个特定目的。监狱数据集的 ZFS 快照，或目录树的 tarball，都是监狱的完整备份。在软件升级失败后恢复变得非常简单，只需要提取 tarball 或回滚到快照。

监狱环境对于软件开发和测试也非常有用。部署一个新服务通常需要安装和测试多个软件包。在选择解决方案并进入生产阶段之前，在监狱环境中进行测试可以防止将不再使用的文件和不需要的软件污染主机。

根据你的硬件和系统负载，单个 FreeBSD 主机可以支持几十个甚至几百个监狱。然而，如果你打算真正运行这么多监狱，确保你的主机有两个独立的网络接口。一个用于监狱，另一个用于管理主机。

一切从配置你的监狱主机开始。

### 监狱主机服务器设置

作为监狱主机的服务器必须在一些令人烦恼的约束条件下运行。在建立第一个监狱之前，请正确配置你的主机。

监狱系统有自己的 sysctl 树，`security.jail`。你只能从主机系统更改这些 sysctl。一些 sysctl 会影响主机上所有运行的监狱。以 `security.jail.param` 开头的 sysctl 可以按监狱逐个设置。我们将在本章中逐步讲解这些内容。

#### *监狱主机存储*

我强烈建议你仅将监狱主机用于运行监狱，并将所有服务都放入监狱中。首先配置主机的存储，将监狱和主机操作系统分开。

许多用于虚拟化的主机在主板上包括用于操作系统的 SATA DOM 闪存驱动器。这些驱动器的大小通常小于 100GB，但 FreeBSD 的基础安装占用的空间远小于一个 GB。如果你有 SATA DOM 或类似设备，可以用它来安装主机操作系统。如果你有多个冗余硬盘集，可以用一对来镜像操作系统，其他的空间则专门用于监狱。

如果你没有这样的硬件，可以将空间分配给主机操作系统。可以使用 UFS 文件系统的分区，或者 ZFS 的数据集预留。无论哪种方式，10GB 的空间应该足够。如果你需要额外的紧急空间，可以从监狱空间借用一些。

虽然 ZFS 对监狱非常有用，但并不是必需的。我曾经在 UFS 上运行监狱多年。使用适合你并符合你环境的方案。

一旦你分区并安装了操作系统，接下来就可以查看网络配置了。

#### *监狱网络配置*

监狱网络配置有两个看似冲突的方面：首先，每个监狱期望完全控制分配给它的任何 IP 地址；其次，监狱可以与其他监狱甚至主机共享 IP 地址。你可以使用主机的任何 IP 地址来启动监狱，但该监狱不能与在该 IP 上运行的其他服务协调任何面向网络的服务。如果你的监狱与主机共享 IP 地址，而主机在端口 22 上运行 SSH，监狱就不能使用端口 22。如果你尝试在监狱中启动 sshd(8)，程序会抱怨不能使用端口 22，并崩溃。监狱之间，或者监狱与主机之间共享 IP 地址，要求系统管理员协调各个端口属于哪个主机，并相应配置所有服务。

配置监狱的最简单方法是为每个监狱分配一个独立的 IP 地址，并为主机分配一个自己的 IP 地址。这样，每个监狱就可以完全控制自己的 IP 地址。一旦熟悉了这种配置，你可以开始在监狱之间共享 IP 地址。这样主机就不能在分配给监狱的 IP 地址上运行守护进程。如果主机的守护进程在监狱的 IP 地址上监听，虽然不会阻止监狱启动，但会阻止监狱在该端口上启动自己的服务。如果用户像 Bert 一样无法 SSH 进入他们的私有监狱，他们会抱怨的！

配置监狱主机的最简洁方法是决定主机仅提供监狱服务。任何在主机上运行的服务必须都在监狱中。如果你需要简单的服务，比如名称服务器或邮件交换机，可以在监狱中配置它们。这不仅比重新配置所有这些服务器并将它们仅附加到选定 IP 地址要容易，而且还为你的其他监狱提供了一层额外的安全性。如果主机被入侵，入侵者会自动获得对所有监狱的访问权限，而入侵单个监狱则会将入侵者限制在该监狱中。

使用 sockstat(1) 来识别网络上监听的程序，正如在 第九章 中讨论的那样。添加 `-46` 标志以仅显示 IPv4 和 IPv6 流量，使用 `-l` 标志以仅显示监听套接字。

```
# sockstat -46l
USER     COMMAND  PID   FD PROTO  LOCAL ADDRESS     FOREIGN ADDRESS
root     ntpd     19776 20 udp6   *:123             *:*
root     ntpd     19776 21 udp4   *:123             *:*
--snip--
root     sshd     2846  3  tcp6   *:22              *:*
root     sshd     2846  4  tcp4   *:22              *:*
```

这个相当默认的 FreeBSD 安装有两个程序在网络上监听：ntpd 和 sshd。两者都在监听所有 IP 地址。我们必须配置这些守护进程，使它们仅监听主机地址。

这里是一些在主机服务器上常见的会引发问题的守护进程。在所有这些例子中，我假设监狱主机的 IP 地址是 198.51.100.50。

##### syslogd

系统日志记录器 syslogd(8) 打开一个 UDP 套接字，以便将消息发送到其他主机。如果你不需要远程日志记录，或者使用其他日志记录解决方案，可以在 *rc.conf* 中使用 `-ss` 标志关闭网络组件。

```
syslogd_flags="-ss"
```

如果你需要发送 syslogd 消息，可以使用 `-b` 标志强制 syslogd 仅附加到一个 IP 地址。

```
syslogd_flags="-b 198.51.100.50"
```

这两种解决方案允许你的监狱管理员单独决定是否跨网络进行日志记录。有关 syslogd 的完整讨论，请参见 第二十一章。

##### inetd

如果你需要 inetd（参见 第二十章），你几乎可以肯定应该在监狱中运行它，而不是在主机上。如果你实在无法避免在主机上运行 inetd，使用 `-a` 标志将它限制为一个 IP 地址，就像以下 *rc.conf* 片段所示。

```
inetd_flags="-a 198.51.100.50 -wW -C 60"
```

如果我只指定了 `-a` 标志和 IP 地址，它会覆盖 inetd 在 */etc/defaults/rc.conf* 中的默认标志。过去几十年的每个 FreeBSD 版本都使用默认标志 `-wW -C 60`；我在这些标志上添加了我的 `-a` 和 IP 地址。

##### sshd

在 */etc/ssh/sshd_config* 中的 `ListenAddress` 选项告诉 sshd(8) 绑定哪些地址。将其限制为仅你的主机 IP 地址。

```
ListenAddress 198.51.100.50
```

如果你的监狱主机提供的唯一服务是 sshd(8)，那么你已经做得很好了。

##### NFS

网络文件系统程序，如 rpcbind(8) 和 nfsd(8)，会绑定主机上的所有 IP 地址，无论你做什么。不要在监狱内运行这些程序，也不要在监狱内运行 NFS。如果你的客户端需要 NFS 挂载，请让主机运行这些程序并提供 NFS 挂载。

##### 网络时间协议

在监狱主机上最具问题的服务是时间同步。所有监狱都从主机获取系统时钟。FreeBSD 内建的时间守护进程 ntpd(8) 会监听主机上的所有 IP 地址，包括监狱内的 IP 地址。作为唯一的特殊例外，我建议你继续在主机上运行 ntpd。

监狱缺乏适当的权限来更改内核的时间。虽然你可以在监狱中运行 ntpd，但它实际上无法*做*任何事情。可以在你的监狱主机上运行 ntpd，别担心它会监听所有 IP 地址。任何试图在 123 端口运行除 ntpd 以外的基于 UDP 的服务的人，可能是想绕过数据包过滤器。让他们更努力地工作吧。

如果你想避免即使是碰撞的可能性，安装 `openntpd` 包。与基础系统中的 ntpd(8) 不同，OpenNTPD 可以配置为只监听一个 IP 地址。

##### IP 地址

每个监狱可以有一个或多个 IP 地址。这些地址必须在启动监狱之前附加到主机。一个没有网络的监狱也可以运行，但无法在主机之外访问。将任何必要的 IP 地址作为别名添加到 */etc/rc.conf* 中。

#### *监狱在启动时*

要让 FreeBSD 在启动时启动你的监狱，设置 `jail_enable` 在 *rc.conf* 中。

```
jail_enable=YES
```

FreeBSD 默认会启动 */etc/jail.conf* 中列出的所有监狱。如果你希望系统只在启动时启动其中一部分监狱，可以使用 `jail_list` *rc.conf* 选项。在这里，我有两个监狱，叫 *mariadb* 和 *httpd*。我希望它们按此顺序启动，以确保我的数据库监狱在调用它的 Web 服务器之前启动。

```
jail_list="mariadb httpd"
```

在系统关闭过程中，FreeBSD 会以启动时的顺序停止监狱。你的应用程序可能不喜欢这种顺序。以我的例子为例，我希望 Web 服务器在数据库后端之前关闭。我宁愿让网站完全无法访问，也不想让用户看到令人讨厌的“数据库服务器已崩溃”错误。

```
jail_reverse_stop=YES
```

如果监狱的启动顺序不重要，你可以同时启动和停止所有监狱。

```
jail_parallel_start="YES"
```

现在你可以配置监狱了。

### 监狱设置

现在我有了一台主机，可以安装一些监狱了。我将从一个叫 *mariadb* 的监狱开始，用来运行……等一下……MariaDB。

每个监狱需要一个专用的根目录。我的所有示例监狱都位于 */jail* 下。我通常会将每个监狱放在一个以监狱名称命名的目录中——在这个例子中是 */jail/mariadb*。

每个监狱需要一个主 IP。它也可以有其他 IP，稍后我们将看到，但我们先从一个开始。监狱 mariadb 获取 203.0.113.51。

每个监狱都需要一个互联网主机名，就像它是一个真实主机一样。这个监狱将成为 *mariadb.mwl.io*。

现在我们可以在监狱中放置用户空间。

#### *监狱用户空间*

虽然你可以在监狱中安装任何用户空间组件，但监狱所需的仅仅是基础系统。获取适用于你所需 FreeBSD 版本的 *base.txz* 发行集，并将其提取到监狱的根目录中。

```
# tar -xpf base.txz -C /jail/mariadb
```

这就是基础操作系统的完整安装。如果你想要额外的发行集，如调试符号，使用相同的方式提取它们。

如果你自己构建了 FreeBSD 基础系统，可以将它安装到监狱中。

```
# cd /usr/src
# make installworld DESTDIR=/jail/mariadb
```

监狱还需要安装过程中创建的支持目录和各种杂项文件，但这些文件不会通过 `make installworld` 创建。`make distribution` 命令会创建这些文件。如果你已经有了这些目录和文件，千万不要重新运行 `make distribution`：它会覆盖任何本地更改。并且不要忘记 DESTDIR 设置，除非你喜欢重置主机的配置！

```
# make distribution DESTDIR=/jail/mariadb
```

你还可以构建一个只包含运行单个程序所需的二进制文件的自定义用户空间，类似于为传统的 chroot 程序构建环境。对于我们大多数人来说，这太麻烦了，但如果你想解锁 ldd(1)并尽情玩耍，我不会阻止你。

一旦你有了监狱的用户空间，就需要在*/etc/jail.conf*中告诉 FreeBSD 关于你的监狱。

#### */etc/jail.conf*

传统上，FreeBSD 在*/etc/rc.conf*中配置监狱。这种方式笨重且不方便。虽然 FreeBSD 仍然支持通过*rc.conf*配置监狱，但我建议使用更加灵活的*/etc/jail.conf*。这个文件不是 UCL 格式，尽管它看起来像是 UCL 可以支持的东西。通过名称定义每个监狱。在监狱名称后面用大括号给出监狱的参数定义。每个参数定义以分号结束。

许多监狱参数都有一个等号，我们为参数赋值。在这里，我将参数`path`设置为值`/jail/mariadb`：

```
path="/jail/mariadb";
```

其他参数仅通过存在与否来启用或禁用某个功能。在这里，我告诉这个监狱开启`mount.devfs`功能：

```
mount.devfs;
```

监狱支持一大堆“挂载”参数，并有不同文件系统的子参数。这个特定参数专门处理挂载 devfs。

通过在特定参数前添加*no*，可以关闭监狱的切换功能。如果我不想启用 devfs，我不会关闭整个挂载参数；我会在*devfs*前加上*no*。

```
mount.nodevfs;
```

这是我定义名为*mariadb*的监狱的方法：

```
mariadb {
 host.hostname="mariadb.mwl.io";
 ip4.addr="203.0.113.51";
 path="/jail/mariadb";
 mount.devfs;
 exec.clean;
 exec.start="sh /etc/rc";
 exec.stop="sh /etc/rc.shutdown";
}
```

参数`host.hostname`提供了监狱的主机名。虽然监狱名称是*mariadb*，但此主机通过互联网主机名*mariadb.mwl.io*来标识自己。

IP 地址位于`ip4.addr`中。我已将地址 203.0.113.51 分配给这个监狱。这个 IP 地址必须先在主机上配置。

监狱的根目录放在`path`变量中。在这里，它被设置为*/jail/mariadb*。

几乎每个监狱都需要访问*/dev*中的特定设备节点，这需要在监狱中挂载 devfs（请参见第十三章）。通过`mount.devfs`设置启用 devfs。监狱默认仅获取少量非常特定的设备节点。由于不受信任的用户有时可能利用设备节点逃离监狱，因此在没有仔细研究的情况下，不要添加额外的设备。您可以使用自定义的 devfs 规则集允许其他设备节点。通过 devfs_ruleset *jail.conf*参数将自定义 devfs 规则集分配给监狱。我强烈建议使用默认的监狱 devfs 规则作为基础，解开该监狱需要的额外设备，而不是试图从头开始构建自定义 devfs 规则集。

一个被监禁的进程可以继承其父进程的部分环境。`exec.clean`选项告诉 jail(8)去除除$TERM 之外的所有环境变量。环境变量$HOME、$USER 和$SHELL 会被设置为目标环境，通常是监狱的根账户环境。你几乎总是需要`exec.clean`。

`exec.start`和`exec.stop`选项告诉 FreeBSD 如何启动和停止监狱。

##### 监狱内启动

监狱可以模拟一个完整运行的 FreeBSD 用户空间，运行单个进程，或者介于两者之间。你必须使用`exec.start` *jail.conf* 参数来告诉 FreeBSD 在监狱中运行哪个进程，或者使用`persist`参数声明即使没有任何进程，监狱仍然存在。在这里，我启动了一个完整的 FreeBSD 用户空间，使用了正常的 FreeBSD 启动脚本：

```
exec.start="/bin/sh /etc/rc"
```

如果你只需要在监狱内运行一个命令，你可以编写自己的启动脚本，并在监狱启动时使用`exec.start`来运行它。你的全新监狱还没有*rc.conf*，因此不会启动任何额外的进程。

你也可以设置`persist`选项来代替`exec.start`。这告诉 FreeBSD，即使监狱内没有任何进程运行，监狱也可以存在。包括`persist`和`exec.start`意味着 FreeBSD 会为监狱启动一个进程，但当进程停止运行时，监狱不会自行关闭。

你可以告诉监狱在启动后使用`exec.poststart`选项运行一个额外的命令。任何通过`exec.poststart`列出的命令或脚本，在正常的*/etc/rc* 启动过程（包括所有启用的包）完成后会在主机中运行。这让你可以编写脚本将监狱连接起来。

类似地，你可以使用`exec.prestop`选项在停止监狱之前在主机上运行一个命令。当系统管理员关闭监狱时，主机会首先运行此命令，然后监狱会执行正常的关闭命令。

`exec.stop`命令告诉 FreeBSD 在监狱中运行哪个命令来关闭监狱。如果你在模拟一个完整的监狱，你可能会像我们在上一节中的示例一样运行`/``bin/sh /etc/rc.shutdown`。

##### 监狱默认设置

你会发现许多监狱共享公共设置。你可以在配置的前面定义这些设置。除非你覆盖它们，否则所有监狱都会使用这些设置。当只使用一个监狱时，这似乎没有太多意义。

```
exec.start="/bin/sh /etc/rc";
exec.stop="/bin/sh /etc/rc.shutdown";
exec.clean;
mount.devfs;

mariadb {
        host.hostname="mariadb.mwl.io";
        ip4.addr="203.0.113.221";
        path="/jail/mariadb";
}
```

然而，考虑到这个配置，添加另一个监狱将需要五行代码，包括大括号。

```
httpd {
        host.hostname="httpd.mwl.io";
        ip4.addr="203.0.113.222";
        path="/jail/httpd";
}
```

在数十个监狱的情况下，这可以节省很多麻烦。

你可以在监狱的定义中覆盖默认设置。如果我不想在监狱中挂载 devfs(5)，我会为该特定监狱设置`mount.nodevfs`。

##### jail.conf 变量

你可以在监狱中使用变量替换。虽然你可以定义一些这些变量，但你也可以从监狱的设置中提取一些变量。变量可以在双引号和未加引号的字符串中展开，但不能在单引号字符串中展开。

在这里，我定义了一个变量来指向包含我所有监狱的目录，并在我的监狱定义中使用它：

```
$j="/jail";
mariadb {
        path="$j/mariadb";
--snip--
}
```

如果我必须将我的监狱迁移到一个新的文件系统或池中，我可以通过更改一个变量来更新*jail.conf*，而不是编辑每个定义。

##### 作为变量的参数

一旦定义了监狱参数，你就可以将其用作变量。每个监狱至少有一个参数，`name`。你可以使用这些参数进一步扩展默认设置。

```
$j="/jail";
path="$j/$name";
host.hostname="$name.mwl.io";

mariadb {
        ip4.addr="203.0.113.221";
}
```

通过将全局默认`path`设置为`$j/$name`，我去除了为每个单独的监狱定义路径的需求。

你可以通过将参数括在大括号中来使用带有句点的多参数。虽然对于像`mount.devfs`这样的参数没有太大意义，但对于每个监狱（jail）参数来说，这是有用的，比如`host.hostname`。

```
path = "/jail/${host.hostname}";
```

我更喜欢将监狱放在以较短名称命名的目录中，而不是以主机名命名，但可以随意根据自己的偏好调整。

将参数和变量与一致的目录布局结合，可以将每个监狱定义压缩成一个配置语句。

#### *测试和配置监狱*

一旦你有了监狱的文件，就将自己锁进监狱。运行 jail(8) 命令在监狱内运行单个命令。你需要四个参数：路径、监狱名称、主 IP 和要运行的命令。

```
# jail <path to jail> <jail name> <jail IP> <command>
```

在这里，我使用位于*/jail/mariadb*中的名为*mariadb*的监狱，IP 地址为 203.0.113.51，来运行命令*/bin/sh*：

```
# jail /jail/mariadb/ mariadb 203.0.113.51 /bin/sh
#
```

运行 ls(1)。你现在在监狱文件系统的根目录中。这个监狱还不是完全的单用户模式，但除了*/bin/sh*之外没有其他程序在这里运行。你可以进行一些基本设置，但连 devfs(5) 都没有挂载。

```
# ps
ps: /dev/null: No such file or directory
```

是的，正常的监狱启动过程会挂载*/dev*，但是监狱没有用户账户，没有根密码，没有守护进程运行，绝对没有任何可选项。在启动之前配置监狱。

##### 从宿主机窃取的东西

一些宿主机的设置信息在监狱内也很有用。你可以将这些信息从宿主机复制到监狱中，但必须从宿主机进行，而不是从监狱内进行。

每个监狱都执行自己的 DNS 解析。你可能可以将宿主机的*/etc/resolv.conf*复制到监狱中。

你的监狱可能与宿主机共享相同的时区。将宿主机的*/etc/localtime*复制到监狱中，或者在监狱内运行 tzsetup(8)来选择一个新的时区。

##### 创建 /etc/fstab

许多程序和脚本，包括*/etc/rc*，期望找到*/etc/fstab*，如果找不到它们会发火。要求*/etc/fstab*在真实服务器中是非常合理的，但监狱中的机器不需要文件系统表。创建一个空的文件系统表。

```
# touch /etc/fstab
```

我不介意不高兴的程序。我只是不想听它们抱怨。

##### 创建 /etc/rc.conf

你可以选择从宿主机管理所有监狱，或者通过 SSH 来管理监狱。你将需要在*/etc/rc.conf*中为 sshd 添加条目。

```
sshd_enable="YES"
```

在创建这个文件时，添加你想要的其他设置。如果你知道某些设置是包所需要的，在它们被需要之前进行设置也不会有坏处。

##### 用户账户和根密码

你只能在监狱内添加用户账户和更改密码。使用 passwd(1)设置 root 密码，并运行 adduser(8)至少添加一个用户，供 SSH 使用。虽然 SSH 不是访问主机的唯一方式，但在大多数情况下，它更为简便。

#### *监狱启动和关闭*

主机将每个监狱视为一个独立的服务，就像 sshd(8)、Web 服务器或任何其他守护进程一样。是的，每个监狱可能会运行一堆需要独立管理的服务，但从主机的角度来看，每个监狱都是一个包含一组进程的单一实体。这是主机和监狱之间分离的一部分。

使用 service(8)命令启动、停止和重启监狱。你需要提供一个额外的参数，即监狱的名称。FreeBSD 会在启动时自动启动监狱，但在系统运行后，你可以单独停止、启动和重启它们。让我们关闭我的数据库监狱并重新启动它。

```
# service jail stop mariadb
# service jail start mariadb
```

我可以使用重启命令，但在页面上显示效果远没有这么震撼。

如果省略监狱名称，service(8)命令将影响 FreeBSD 在启动时启动的所有监狱。

```
# service jail restart
Stopping jails: httpd mariadb.
Starting jails: mariadb httpd
```

这让你能够有条理地重新初始化你的生产监狱基础设施。

FreeBSD 默认启动*/etc/jail.conf*中列出的所有监狱。如在“启动时的监狱”中讨论的那样，第 568 页，你可以在*/etc/rc.conf*中更改此设置。service(8)命令可以控制那些未自动启动的监狱，但必须通过名称指定它们。

#### *监狱依赖关系*

如果你有很多监狱，列出*/etc/rc.conf*中的启动顺序可能会变得繁琐。你通常需要设置启动顺序以保持服务依赖关系。然而，你可以告诉某个监狱它依赖于另一个监狱，使用`depend`选项，而不是在*rc.conf*中定义顺序。

```
httpd {
        ip4.addr="203.0.113.232";
        depend=mariadb;
}
```

监狱 httpd 不会启动，直到监狱 mariadb 运行。`depend`语句会覆盖*rc.conf*中的`jail_list`条目。

### 管理监狱

虚拟化并不会使系统管理任务消失；它只是为执行典型的系统管理员任务提供了更多的选择。以下是一些这些选择。

#### *查看监狱和监狱 ID*

使用 jls(8)命令查看当前系统上运行的所有监狱。

```
# jls
   JID  IP Address      Hostname        Path
    29  203.0.113.221   mariadb.mwl.io  /jail/mariadb
    30  203.0.113.222   httpd.mwl.io    /jail/httpd
    31  203.0.113.223   test.mwl.io     /jail/test
```

每个监狱都有一个唯一的监狱 ID，或 JID。JID 就像进程 ID；每个监狱都有一个，但每次启动监狱时，分配给监狱的确切 JID 会有所不同。我们将使用监狱 ID 或名称来执行各种监狱管理任务。

我们还会获取每个监狱的 IP 地址、主机名以及监狱文件的路径。你不会得到监狱名称，但那些使用基于监狱名称的主机名的人不会有问题弄清楚。

#### *监狱进程*

所有被限制在监狱中的进程都会获得一个进程 ID，就像其他 Unix 进程一样。进程 ID 并不是监狱专有的，它们在主机、监狱和所有其他监狱之间共享。你不会看到重复的进程 ID。

被限制在监狱中的进程会在 ps(1)中显示，使用`-J`标志。

```
# ps -ax
  PID TT  STAT        TIME COMMAND
    0  -  DLs      2:56.24 [kernel]
    1  -  ILs      0:00.07 /sbin/init –
--snip--
35002  -  SsJ      0:00.01 /usr/sbin/syslogd -s
35129  -  IsJ      0:00.00 /usr/sbin/sshd
--snip--
```

进程 ID 35002 和 35129 被限制在监狱中。

使用`-J`标志和监狱名称，通过 ps(1)查看特定监狱的进程。

```
# ps -ax -J test
  PID TT  STAT    TIME COMMAND
35561  -  IsJ  0:00.01 /usr/sbin/syslogd -s
35652  -  IsJ  0:00.00 /usr/sbin/sshd
35661  -  SsJ  0:00.03 sendmail: accepting connections (sendmail)
--snip--
```

使用`-J 0`会排除所有被监禁的进程，让你更容易调试主机。

像 pgrep(1)、pkill(1)和 killall(1)这样的命令都接受一个`-j`参数，让你可以指定一个监狱。如果你喜欢使用 pgrep(1)查看进程信息，可以使用`pgrep -lfj`以及监狱名称或 JID。

```
# pgrep -lf -j mariadb
  PID TT  STAT    TIME COMMAND
35002  -  SsJ  0:00.01 /usr/sbin/syslogd -s
35129  -  IsJ  0:00.00 /usr/sbin/sshd
35158  -  SsJ  0:00.02 sendmail: accepting connections (sendmail)
--snip--
```

为什么 Sendmail 在这个监狱内运行？让我们把它杀掉。

```
# pkill -9 -j mariadb sendmail
```

再次运行 pgrep 显示 Sendmail 已经死掉了。

如果你想获取监狱中运行的进程信息，这个方法效果很好，但有时候你只有进程 ID，必须确定它属于哪个监狱。此时，你需要 ps(1)的`-O`选项。这个选项支持一系列关键字，可以调整 ps(1)的输出方式，这是常规命令行标志无法做到的——具体来说，`-O jail`会增加一个列，显示进程所在的监狱名称。

```
# ps -ax -O jail | grep 39415
39415 mariadb  -  IsJ    0:00.00 /usr/local/libexec/mysqld
```

这个进程正在监狱 mariadb 内运行。

#### *在监狱中运行命令*

jexec(8)命令允许监狱主机管理员在不需要登录到监狱的情况下执行监狱内的命令。这有助于保持监狱所有者的隐私感。^(2) 当监狱所有者 Bert 打电话求助时，我不需要他的 root 密码，甚至不需要在他的系统上有一个账户。使用 jexec 需要知道监狱的名称或 JID。在这里，我使用主机的 root 账户在我的监狱 mariadb 内运行`ps -ax`。

```
# jexec mariadb ps -ax
  PID TT  STAT    TIME COMMAND
35002  -  SsJ  0:00.00 /usr/sbin/syslogd -s
35129  -  IsJ  0:00.00 /usr/sbin/sshd
--snip--
```

这个命令作为 root 在监狱内运行。不过，我可能希望作为另一个被监禁的用户来运行这个命令。使用`-U`标志指定那个用户名。

```
# jexec -U xistence mariadb ps
jexec: xistence: no such user
```

嗯，这可不太好。我期望 Bert 来运行我的数据库。让我们给他创建一个用户账户。

```
# jexec mariadb adduser
Username: xistence
Full name: Bert JW Regeer
Uid (Leave empty for default):
Login group [bert]:
Login group is bert. Invite bert into other groups? []: wheel
--snip--
```

这个监狱现在有一个 Bert 的账户，使用他喜欢的用户名和所有设置。我已经将它添加到监狱内的 wheel 组中。记住，监狱内的 root 访问权限并不等同于主机上的 root 访问权限。这就是监狱的全部意义所在。

我现在可以作为那个用户在那个监狱中运行命令了。

```
# jexec -U xistence mariadb sh
$
```

我被锁在监狱里了！具体来说，是在 Bert 的监狱牢房里。

然而，这个被监禁的进程可能会表现得有点奇怪。一个进程会保留它的环境。在这种情况下，虽然我作为用户 xistence 在运行，但我保留了在非监禁进程中所有的环境设置。这包括$SSH_AUTH_SOCK、我的 IRC 服务器设置等。我不希望这些东西出现在我的监狱环境中。如果我以 Bert 的身份登录，我希望*就是*Bert。

要在进入监狱之前清空你的环境，请使用 jexec 的`-l`标志。这会模拟一个干净的登录。

```
# jexec -lU xistence mariadb sh
```

在监狱中运行命令时，是否总是需要清空环境？不，并不是总是如此。这完全取决于你在做什么。

许多命令支持在主机上运行，但可以指定目标为监狱。请始终检查手册页以了解是否有此类选项。一个好的例子是 sysrc(8)，它允许你通过`-j`指定监狱。在这里，我在监狱 mariadb 上启用 MariaDB。MariaDB 选择继续使用 MySQL 命名惯例，因此通过*rc.conf*选项`mysql_enable`启用它。

```
# sysrc -j mariadb mysql_enable=YES
mysql_enable:  -> YES
```

这个监狱现在已准备好运行 MariaDB。

当然，除了 MariaDB 未安装的那部分。接下来我们来处理这个问题。

#### *安装监狱软件包*

FreeBSD 的包管理工具让你可以从监狱内或从主机上管理软件包。如果主机管理员为你分配了一个监狱来配置，你可能希望从监狱中管理软件包。监狱软件包的工作方式与任何其他 FreeBSD 主机上的软件包完全相同，如第十五章所述。如果你负责整个系统，包括主机和主机上的所有监狱，你可能希望从主机而不是登录到每个监狱来管理每个监狱的软件包。我们来花些时间讲解这个。

pkg(8)命令的`-j`标志允许你指定一个监狱进行管理。你需要一个参数，即监狱的名称或 JID。`-j`标志必须在 pkg(8)子命令之前给出。在这里，我在专用的监狱上安装 MariaDB 服务器：

```
# pkg -j mariadb install mariadb101-server
Updating FreeBSD repository catalogue...
FreeBSD repository is up to date.
All repositories are up to date.
The following 9 package(s) will be affected (of 0 checked):
--snip--
```

请注意，pkg(8)不会提示你正在监狱中安装软件包。它假设如果你使用`-j`，你就知道自己在监狱中工作。

当你从主机管理监狱的软件包时，包管理工具不会在监狱中安装。监狱有自己的软件包数据库，存储在监狱内，但监狱没有直接使用该数据库的方式。

不要在主机和监狱内部之间切换包管理方式。选择一种方法并坚持使用。

#### *更新监狱*

所以你在主机上有无数个监狱，每个监狱都专门执行自己的任务并与其他监狱完全隔离。那很棒，直到你需要为所有监狱应用安全补丁。如果你是从源代码构建 FreeBSD 的，你需要在每个监狱中安装新的世界。但如果你运行的是发行版，freebsd-update(8)（参见第十八章）可以处理监狱。

你不能在监狱内使用 freebsd-update(8)。隔离监狱以防止危及主机系统的同样机制也会禁止 freebsd-update(8)所需的部分功能。相反，你需要从主机更新监狱。

每当你需要更新系统时，先更新主机，再更新监狱。主机必须运行与任何监狱版本相同或更新的 FreeBSD 版本。

首先，将*/etc/freebsd-update.conf*复制到另一个文件中，例如*/etc/jail-freebsd-update.conf*。删除所有在监狱中未安装的组件。监狱没有内核，大多数监狱也没有源代码，所以你可能最终会得到如下条目：

```
Components world
```

当你运行 freebsd-update(8) 时，它会检查你正在运行的 FreeBSD 版本。它通过查询内核来实现。如果你在 FreeBSD 13.0 系统上有 FreeBSD 12.0 的监狱，更新程序就会混淆，卡住并产生神秘错误。你需要 freebsd-update 使用监狱中安装的版本，而不是主机上运行的版本。使用 `--currently-running` 选项告诉 freebsd-update(8) 监狱当前运行的版本。你必须使用监狱的发布版本，包括补丁级别。虽然你可以轻松地从监狱中提取这些信息，但我鼓励你让 freebsd-update 询问监狱当前运行的版本。通过使用 jexec(8) 查询监狱中运行的 FreeBSD 版本来实现。

你还可以使用 `-b` 标志告诉 freebsd-update(8) 监狱所在的目录。

在这里，我更新名为 *test* 的监狱。监狱的文件位于 */jail/test*。我使用反引号中的 jexec(8) 命令检查当前的 FreeBSD 版本。

```
# freebsd-update -f /etc/jail-freebsd-update.conf -b /jail/test/ --currently-running `jexec -l test freebsd-version` fetch install
```

一旦 freebsd-update 运行完成，重新启动你的监狱。它已经升级。

很多人编写了脚本来遍历 */etc/jail.conf* 并升级所有监狱。如果你有多个监狱，最好找到或编写这样的脚本。

### 更多监狱选项

你可以以各种方式自定义监狱。jail(8) 手册页包括了当前的监狱选项列表，但这里是我常用的一些功能。

与其让 jail(8) 分配监狱 ID，你可以使用 `jid` 选项为每个监狱分配一个永久的 ID。

```
jid=101;
```

`securelevel` 选项允许你在监狱中提高安全级别（参见 第九章）。监狱的安全级别永远不能低于主机的安全级别。

你可以通过手动运行 */etc/rc* 和监狱命令来查看监狱的启动信息。不过，这对于日常故障排除来说不太方便。使用 `exec.consolelog` 选项将监狱的控制台消息定向到一个文件。

```
exec.consolelog="$j/logs/$name.log";
```

除了挂载 */dev*，监狱还可以通过 `mount.fdescfs` 和 `mount.procfs` 选项拥有自己的 fdescfs(5) 和 procfs(5)。

### 监狱中的古老 FreeBSD

根据我的经验，*企业网络* 这个词意味着“我们有很多没人敢动的古老设备”。监狱可以帮助你应对这些系统。2014 年，我曾在一家公司工作，运行着一个在 FreeBSD 4.10 上的关键自定义 PHP 和 MySQL 应用程序。我不知道这台服务器是什么时候安装的，但 FreeBSD 4.11 于 2005 年 1 月发布，所以应该是在那之前。这个应用程序使用了过时的 Perl、PHP、OpenSSL 版本等。

更糟糕的是，这个应用程序运行在一台重新利用的桌面机器上，配有一块标准的高质量桌面硬盘。我把一台同年代的备用桌面机器藏在我的桌子下，这样我才有希望将 FreeBSD 4.10 安装到它上面。最合适的解决方案是重写或替换这个应用程序。几个系统管理员曾面对这个任务——并失败了。我决定将其虚拟化。FreeBSD 4.10 在 VMWare 上运行不太好——是的，你可以找到 de(4) 和 fxp(4) 驱动程序，但它们只适用于十多年前版本的这些卡。以下是我如何将这个古老的 FreeBSD 系统放入监狱的方法。

切换到单用户模式。卸载 */proc*——是的，FreeBSD 4 仍然使用 */proc*。那是个好日子。将整个文件系统打包，包括临时目录，如 */usr/obj*、*/usr/ports*、*/var/tmp* 等。按照现代标准，它们占用的空间几乎为零，而且你也无法知道哪些文件以后可能会用到。你或许能在网上找到一个旧的 PHP 5.0.whatever 的 tar 包，但那将需要一些工作。

将 tar 文件复制到你的监狱主机，并在你的监狱目录中解压它。

```
# tar -C /jail/oldserver -xvpf oldserver.tgz
```

一定要使用 `-p` 标志来保留权限。

现在查看 */etc/rc.conf*。监狱主机将处理所有网络功能，所以关闭任何设置 IP 地址或设置路由的语句。移除提供监狱主机所提供服务的守护进程，如时间、数据包过滤器和 SSH。你的监狱主机只需要直接支持应用程序的功能。在这个例子中，我只需要 Apache 和 MySQL。

考虑监狱的 */etc/fstab*。你需要 NFS 文件系统或其他特殊挂载吗？移除所有不需要的内容。如果这个应用程序需要 */proc*，则为它提供监狱选项 `mount.procfs`。

移除旧的 */dev*。你不能在现代的 FreeBSD 上使用 FreeBSD 4 的设备节点。

配置主机以保护监狱。虽然人们可以在 Apache 和 PHP 中编写完全正常的应用程序，但即便是最忠实的 Apache 和 MySQL 粉丝也不会鼓励你将这些 15 年前版本的服务器暴露到互联网上。使用主机的包过滤器来保护监狱。甚至不要考虑使用迁移主机的 OpenSSH 服务器。

你将无法在监狱中使用某些 FreeBSD 4 命令，因为接口已发生了很大的变化。FreeBSD 4 的 ps(1) 无法成功查询现代 FreeBSD 内核。然而，你可以从主机的 */rescue* 目录中复制大多数这些程序的静态链接版本，并将它们复制到监狱中。

这样就简单吗？不，实际上并不简单。源系统越旧，遇到的问题就越多。我在这次迁移中遇到的大多数问题都意味着需要更改一个配置文件，以适应新的底层文件系统。你需要进行通常的系统管理员调试。但这是将现代网络接口应用到没有设备驱动的系统上的一种方法，也是唯一一种在 FreeBSD 4 系统上安装 ZFS 的方式。

### 最后的监狱笔记

人们已经发展出许多使用监狱的方法。要完全覆盖所有这些功能几乎需要一本书，但这里有一些提示。

你可以使用 ZFS 特性将数据集完全委派给监狱管理员，以便监狱所有者可以自己创建快照并创建子数据集。通过 VIMAGE 内核选项，你可以为监狱分配独立的路由表。如果你够大胆，nullfs(5) 允许你回收操作系统安装并最小化磁盘利用率。你还可以使用 RCTL 内核选项为每个监狱设定资源限制。

如果你有很多监狱，可能会更倾向于使用监狱管理程序，如 iocage 或 ezjail。两者都可以在 Ports Collection 中找到。

成功使用监狱要求自动化你的维护工作。每个监狱都需要单独的安全补丁，包括用户空间和已安装的软件包。你能自动化这个过程的程度越高，你就越有可能真正进行这种维护。我推荐使用 Ansible 的监狱模块，或者至少编写你自己的 shell 脚本来应用补丁。

jail(8) 命令可以让你无需命令行即可修改、创建和销毁监狱。如果你进行大量监狱工作，务必阅读手册页。

现在让我们看看一些 FreeBSD 不太为人知的方面。
