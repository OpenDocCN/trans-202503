## 第七章：**网络**

![image](img/common01.jpg)

FreeBSD 以其网络性能著称。TCP/IP 网络协议套件最初是在 BSD 上开发的，而 BSD 则包括了第一个重大实现的 TCP/IP。尽管在 1980 年代，竞争性网络协议被认为更具吸引力，但 BSD TCP/IP 栈的广泛可用性、灵活性以及宽松的许可政策使其成为事实上的标准。这不仅仅是历史的好奇，今天，Facebook 正积极寻找能够让 Linux 的网络性能与 FreeBSD 匹配的工程师。这个项目预计将持续数年。

许多系统管理员今天对网络基础知识有些模糊的了解，但并不真正理解这些知识是如何相互关联的。然而，优秀的系统管理员理解网络。了解 IP 地址的真实含义、子网掩码的工作原理以及端口号与协议号的区别是掌握你职业技能的必要步骤。本章将涵盖其中的一些问题。首先，你必须理解网络层次。

本章提供了关于 TCP/IP 的一个不错概览，但并未涵盖众多细节、陷阱和注意事项。如果你需要深入学习 TCP/IP，建议阅读相关书籍。作为概览，你可以参考我的书《*系统管理员的网络基础*》（Tilted Windmill Press，2015）。最终，你将需要深入了解网络，直接阅读 Charles M. Kozierok 的《*TCP/IP 指南*》（No Starch Press，2005）。

主流的互联网协议是 TCP/IP（基于互联网协议的传输控制协议）。TCP 是传输协议，而 IP 是网络协议，但它们紧密相连，通常被视为一个整体。我们将首先探讨网络如何工作，然后讨论 IP 版本 4 和 6，再继续讲解 TCP 和 UDP。

### 网络层

网络的每一层都处理网络过程中特定的任务，并且只与其上下相邻的层进行交互。学习 TCP/IP 的人常常会笑谈这些层简化了网络过程，但这确实是真的。此时需要记住的重要一点是，每一层仅与直接位于其上方和下方的层进行通信。

经典的开放系统互联（OSI）网络协议栈有七层，完整无缺，几乎涵盖了所有网络协议和应用的各种情况。然而，互联网只是其中的一种情况，而本书并不是关于网络或网络应用的书籍。我们将讨论的内容仅限于 TCP/IP 网络，例如互联网和几乎所有的企业网络，因此我们只需要考虑网络栈的四个层次。

#### *物理层*

在最底层，我们有物理层：网络卡以及从网络卡连接到的电缆、光纤或无线电波。这个层包括物理交换机、集线器或基站、连接这些设备到路由器的电缆以及从你办公室到电话公司的光纤。电话公司交换机是物理层的一部分，横跨大陆的光纤电缆也是如此。如果它能被踩到、掉落或被电锯锯断，那它就是物理层的一部分。从现在开始，我们将把物理层称为*电缆*，尽管这个层可以是任何类型的媒介。

这是最容易理解的层——它就像是硬件完好无损一样简单。如果你的电缆符合物理协议的要求，那就成功了。如果不符合，那就没戏了。没有物理层，其它网络层根本无法工作——就是这么简单。互联网路由器的一个功能是将一种物理层连接到另一种物理层——例如，将本地以太网转换为光纤。物理层没有决策能力，也没有智能；它上面运行的一切都由数据链路层决定。

#### *数据链路层：物理协议*

数据链路层，或称物理协议层，是网络中最有趣的地方。这个层将信息转化为实际的二进制数据（0 和 1），并以适合该物理协议的编码方式通过物理层发送。例如，IP 第四版（IPv4）通过以太网使用媒体访问控制（MAC）地址和地址解析协议（ARP）；而 IP 第六版（IPv6）通过以太网使用邻居发现协议（NDP，有时也简称 ND）。除了流行的以太网数据链路层，FreeBSD 还支持其他协议，包括点对点协议（PPP）和高级数据链路控制协议（HDLC），以及一些组合协议，如某些家庭宽带供应商使用的 PPPoE（以太网上的 PPP）。尽管 FreeBSD 支持所有这些数据链路协议，但它并不支持*所有*曾经使用过的数据链路协议。如果你有特殊的网络需求，可以查阅你所使用的 FreeBSD 版本的文档，看看是否支持该协议。

一些物理协议已经在许多不同的物理层上实现。例如，以太网就曾通过双轴电缆、同轴电缆、CAT3、CAT5、CAT6、CAT7、光纤、HDMI 和无线电波等方式进行传输。通过对设备驱动程序进行些许调整，数据链路层可以适应任何类型的物理层。这就是层次化结构简化网络的一种方式。我们将在本章最后的第 140 页中的“理解以太网”一节详细讨论以太网，因为它是 FreeBSD 系统最常使用的网络类型。通过了解 FreeBSD 上的以太网，你也将能够管理其他协议——当然，前提是你已经理解了这些协议！

除了与物理层交换信息，数据链路层还与网络层进行通信。

#### *网络层*

网络层？难道整个东西不是网络吗？

是的，但网络层更为具体。它映射网络节点之间的连接，回答诸如“其他主机在哪里？”和“你能访问这个特定的主机吗？”这样的问题。这个逻辑协议为在网络上运行的程序提供了一个一致的接口，无论你使用什么样的物理层。互联网上使用的网络层是*互联网协议（IP）*。IP 为每个主机提供一个独一无二的^(1)地址，称为*IP 地址*，以便网络上的任何其他主机都可以找到它。你需要了解 IP 的第 4 版和第 6 版。

网络层是我们真正抽象出底层物理媒介的地方。IP 是通过以太网运行的吗？ATM？信鸽？谁在乎？它有一个 IP 地址，所以我们可以与之通信。继续吧。

网络层与下面的数据链路层和上面的传输层进行通信。

#### *繁重工作：传输层*

传输层处理真实应用程序的实际数据，甚至可能是实际的人类。三种常见的传输层协议是 ICMP、TCP 和 UDP。

*互联网控制消息协议（ICMP）*管理具有 IP 地址的主机之间的基本连接消息。如果 IP 提供了一条道路和地址，那么 ICMP 提供了交通信号灯和高速公路出口标志。大多数时候，ICMP 在后台运行，你无需关注它。

其他著名的传输协议有*用户数据报协议（UDP）*和*传输控制协议（TCP）*。这些有多常见？

好的，互联网协议套件通常称为 TCP/IP。这些协议提供了如通过端口号复用和传输用户数据等服务。UDP 是一种基本的传输协议，提供了传输数据所需的最基本服务。TCP 则提供了更复杂的功能，如拥塞控制和完整性检查。

除了这三种协议，许多其他协议也运行在 IP 之上。文件*/etc/protocols*包含了一个相当全面的传输协议列表，这些协议使用 IP 作为底层机制。你不会在这里找到非 IP 协议，比如 Digital 的 LAT，但它包含了许多你在现实中永远不会见到的协议。例如，下面是 IP 和 ICMP 的条目，它们是互联网上常用的网络层协议：

```
➊ip   ➋0   ➌IP    ➍# Internet protocol, pseudo protocol number
  icmp  1    ICMP    # Internet control message protocol
```

*/etc/protocols*中的每个条目有三个关键字段：一个非正式的名称➊，一个协议编号➋，以及任何别名➌。协议编号在网络请求中用于识别流量。如果你曾经启动过数据包嗅探器或出于某种原因深入研究过网络，你就会看到它。如你所见，IP 是协议 0，ICMP 是协议 1——如果这不是所有其他协议的基础，那么很难想象还有什么能成为基础！TCP 是协议 6，UDP 是协议 17。你还会看到注释➍，提供关于每个协议的更多细节。

传输层与下面的网络层和上面的应用程序层进行通信。

#### *应用程序*

应用程序肯定是网络的一部分。应用程序发起网络连接请求，通过网络发送数据，从网络接收数据，并处理这些数据。网页浏览器、电子邮件客户端、JSP 服务器等都是网络感知应用程序。应用程序只需要与网络协议和用户进行通信。用户层的问题超出了本书的范围。^(2)

### 实践中的网络

所以，你现在明白所有的连接是如何搭建在一起的，并且准备继续前进，对吧？不一定。让我们看看在现实世界中它是如何工作的。部分解释涉及到我们在本章后面会讨论的内容，但如果你正在读这本书，你应该足够了解网络知识，能够跟上。如果你有困难，读完本章的其他部分后可以重新阅读这一节。（可以再买一本这本书，把这几页剪下来，粘贴在本章结尾处。）

假设一个通过你的网络连接到互联网的用户想要查看 Yahoo！用户打开他的浏览器并输入网址。

浏览器应用程序知道如何与网络中的下一层进行通信，即传输层。在将用户的请求处理成合适的格式后，浏览器向传输层请求一个到特定 IP 地址、端口 80 的 TCP 连接。（纯粹主义者会注意到我们跳过了 DNS 请求部分，但这与所描述的过程非常相似，不会对我们的示例产生影响。）

传输层检查浏览器的请求。由于应用程序请求了 TCP 连接，传输层为该类型的连接分配适当的系统资源。请求被分解成易于处理的块，并交给网络层。

网络层不关心实际的请求。它接收到的是一堆需要通过互联网传输的数据。就像邮递员在投递信件时不关心信件内容一样，网络层只是将 TCP 数据与适当的地址信息捆绑在一起。最终的数据块被称为*数据包*。网络层将这些数据包交给数据链路层。

数据链路层不关心数据包的内容。它当然不关心 IP 地址或路由。它收到了一堆零和一，任务就是将这些零和一通过网络传输。它只知道如何执行这个传输。数据链路层可能会根据所使用的物理介质为数据包添加适当的头部和/或尾部信息，从而创建一个*帧*。最后，它将帧交给物理层，在本地电缆、无线或其他介质上进行传输。

**每个都在另一个里面？**

是的，你的原始网页请求已经被 TCP 协议封装。这个请求在传输层又被 IP 协议封装一次，然后又被数据链路协议封装一次。所有这些头部信息都被加在原始请求的前后。你见过那张小鱼被稍大一点的鱼吞掉，而稍大一点的鱼又被更大的鱼吃掉的图片吗？它正是这样。或者，如果你愿意，数据帧就像是最外面的套娃。解开一个协议，你会发现另一个协议。

物理层完全没有智能。数据链路层将一堆零和一传递给物理层，物理层将它们传输到另一个物理设备。它不知道正在使用什么协议，也不知道这些数字是如何通过交换机、集线器或中继器回响的，但这个网络中的某个主机大概是网络的路由器。

当路由器接收到零和一时，它会将它们交给数据链路层。数据链路层去除其封装信息，并将得到的数据包交给路由器中的网络层。路由器的网络层检查数据包并根据其路由表决定如何处理它。然后，它会将数据包交给适当的数据链路层。这可能是另一个以太网接口，或者是一个来自 T1 的 PPP 接口。

在数据传输过程中，你的电缆可能会经历许多物理变化。你的有线互联网连接可能会聚合成光纤 DS3，然后再转化为 OC192 的跨国链路。感谢分层和抽象的奇妙，既你的计算机也你的用户都不需要了解这些内容。

当请求到达目的地时，另一端的计算机接收该帧并将其一路传回协议栈。物理层接收零和一的信号并将它们传送到数据链路层。数据链路层去除以太网头部，并将处理后的数据包交给网络层。网络层去除数据包头部，并将剩余的数据段传递到传输层。传输层将这些数据段重新组装成数据流，然后交给应用程序——在这个例子中是一个 web 服务器。应用程序处理请求并返回答案，然后数据沿协议栈向下传递，必要时穿越各种数据链路层。这一系列的工作是为了让机器完成，只为让你看到那个“404 页面未找到”的错误。

这个例子展示了为什么分层如此重要。每一层仅了解关于上下层必须知道的内容，这使得如果需要，可以轻松地替换层内部的实现。当创建新的数据链路协议时，其他层不必更改；网络协议只需向数据链路层发送格式正确的请求，让该层完成它的工作。当你拥有一个新的网卡时，你只需要一个与数据链路层和物理层接口的驱动程序；你不需要更改网络栈中更高层的任何内容，包括你的应用程序。想象一下，如果设备驱动程序必须安装在你的 web 浏览器、电子邮件客户端和你电脑上所有其他应用程序中，包括自定义构建的应用程序，你会很快放弃计算机，去做一些更理智、更合理的事情，比如与铁砧一起跳伞。

### 获取比特和十六进制

作为一名系统管理员，你会经常遇到像*48 位地址*和*18 位子网掩码*这样的术语。我见过不少系统管理员在听到这些时只是点点头，微笑着，心里想着：“好吧，反正告诉我做工作需要知道什么就行。”不幸的是，数学是这项工作的一部分，你*必须*理解比特。虽然这些数学计算并不直观，但理解它是区分业余者和专业人士的关键之一。如果你想保持业余水平，就不会读这样的书。

或许你在嘀咕，“但我已经知道这些了！”那就跳过吧。但如果你不了解，就不要骗自己。

你可能已经知道，计算机把所有数据都当作 0 和 1 来处理，一个零或一就是一个*比特*。当协议指定了比特数时，它指的是计算机看到的数字。一 个 32 位数字有 32 个数字，每个数字是 0 或 1。你可能在小学时接触过*二进制*数学，或者说*基数 2*，并且记得刚好足够长的时间来通过测试。现在是时候重新拾起那些记忆了。二进制数学实际上只是另一种处理我们每天看到的数字的方式。

我们每天使用*十进制*数学，或者说*基数 10*，来支付披萨费和核对账单。数字从 0 到 9。当你想超过当前最高数字时，你会在左边添加一个数字，并将当前数字设为零。这就是你多年前学到的“进位”规则，现在可能不加思考地自动做出来了。在二进制数学中，数字从 0 到 1，当你想超过当前最高数字时，你会在左边添加一个数字，并将当前数字设为 0。这和十进制数学一模一样，只是少了八根手指。举个例子，表 7-1 展示了将前几个十进制数字转换为二进制的过程。

**表 7-1：** 十进制和二进制数字

| **十进制** | **二进制** |
| --- | --- |
| 0 | 0 |
| 1 | 1 |
| 2 | 10 |
| 3 | 11 |
| 4 | 100 |
| 5 | 101 |
| 6 | 110 |
| 7 | 111 |
| 8 | 1000 |

当你有一个 32 位数字时，例如一个 IP 地址，你会得到一串 32 个 1 和 0。以太网 MAC 地址是 48 位数字，有 48 个 1 和 0。

仅供娱乐，Unix 在某些情况下也使用十六进制数字，例如 MAC 地址和子网掩码。十六进制数字是 4 位长。二进制数 1111，完整的 4 位，等同于 15；这意味着十六进制数学中的数字范围是从 0 到 15。此时，可能有一些人看到应该是单一数字的 2 位数 15，心想我在吸什么烟，以及你们去哪儿能买到同样的东西。十六进制数学使用字母 A 到 F 表示数字 10 到 15。当你数到最后一个数字并想加 1 时，你会将当前数字设为零，并在数字的左边添加一个新数字。例如，想要在十六进制中数到 17，你会说：“1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10, 11。”脱掉一只鞋子，数一数直到你明白为止。

十六进制数字通常会在前面加上*0x*标记。数字 0x12 是十六进制的 18，相当于十进制的 18，而数字 18 则是普通的 18。如果一个十六进制数字没有前导的 0x 标记，那它出现在一个始终以十六进制输出的地方，比如 MAC 地址。字母 A 到 F 也是一种明显的标识，但并不完全可靠；许多十六进制数字根本没有字母，就像许多十进制数字没有奇数位一样。

当你在处理十六进制、十进制和二进制数字时，最简单的做法是拿出科学计算器。如今的中端或更高端计算器都具备在三种系统之间转换的功能，大多数软件计算器也有这种功能。

**比特与字节**

计算机系统通常以字节为单位工作，其中一个 8 位数字由单个字符表示。唯一的例外是网络栈，其中一切都以比特为单位。因此，我们在一台具有 10 兆比特网络连接的机器上有一个 5 兆*字节*的文件。不要把这两者混淆！

### 网络栈

网络栈是让主机通过网络与其他主机通信的软件。主机可以使用仅支持 IPv4 的网络栈、仅支持 IPv6 的网络栈，或者使用双栈配置。FreeBSD 默认启用这两者。

你可能对仅支持 IPv4 的网络栈很熟悉。在过去的 30 年中，大多数主机都使用 IPv4。仅支持 IPv4 的网络栈只能通过 IPv4 进行通信。今天，IPv4-only 的网络栈能够访问大部分互联网，尽管有一些故意的例外。但在几年后，这种情况将不再成立。

同样，只有 IPv6 的网络栈只能与 IPv6 主机通信。大多数大型互联网网站支持 IPv6，但你会发现少数令人烦恼的例外。^(3) 仅使用 IPv6 会使你无法访问一些流行的互联网网站。

当前最常见的服务器配置是双栈设置。客户端主机尝试同时使用 IPv4 和 IPv6，通常会偏向其中一个。微软 Windows 的最近几个版本更倾向于使用 IPv6。

我们首先将讨论更为熟悉的 IPv4，然后以 IPv4 为参考来讨论 IPv6。

### IPv4 地址和子网掩码

IP 地址是分配给网络上特定节点的唯一 32 位数字。有些 IP 地址几乎是永久性的，比如分配给重要服务器的地址。其他地址则会根据网络需求变化，比如拨号客户端使用的地址。共享网络上的单独机器会获取相邻的 IP 地址。

不是将 32 位数字表示为一个单一的数字，而是将 IP 地址分为四个 8 位数字，通常以十进制数字表示。虽然 203.0.113.1 与 11001011.00000000.01110001.00000001 或单一数字 11001011000000000111000100000001 是相同的，但四个十进制数字是我们思维最容易处理的方式。

IP 地址是由互联网服务提供商以块的形式分配的。这些块通常非常小——比如说 16 个或 32 个 IP 地址。如果你的系统位于一个服务器农场中，你可能只会得到一个地址块中的几个 IP 地址。

*网络掩码*，也可以称为 *前缀长度* 或 *斜杠*，是一个标签，表示分配给本地网络的 IP 地址块的大小。你的 IP 块的大小决定了你的网络掩码——或者说，你的网络掩码决定了你有多少个 IP 地址。如果你做过一段时间的网络工作，你一定见过网络掩码 255.255.255.0，并知道它与 256 个 IP 地址的块相关。你甚至可能知道，错误的网络掩码会导致你的系统无法正常工作。然而，在今天，这种简单的网络掩码变得越来越不常见。由 255 和 0 组成的网络掩码虽然易于观察，但会浪费 IP 地址。^(4) 而 IPv4 地址是一种极其稀缺的资源。

当你为服务器获取一块 IP 地址时，它可能看起来像 203.0.113.128/25\。这不是一个二进制数学课程，所以我不会让你画出来并做转换，但可以把 IP 地址看作是一个二进制数的字符串。在你的网络上，你可以改变最右边的位，但不能改变最左边的位。唯一的问题是，“分隔左右的界线在哪里？”这个边界不一定要在那些方便的 8 位线处，这些线把地址的十进制版本分开。前缀长度就是你网络上固定的位数。/25 意味着你有 25 个固定的位。你可以操作 7 个位。通过将固定位设为 1，将网络位设为 0，你可以得到一个十进制的网络掩码，如以下 /25 网络掩码示例：

```
11111111.11111111.11111111.10000000
```

二进制 11111111 是十进制 255，而 1000000 是 128\。你的网络掩码是 255.255.255.128\。如果你从二进制角度思考，这非常简单。你不需要每天都处理这个问题，但如果你不理解底层的二进制概念，十进制转换看起来可能会让人困惑。通过练习，你将学会识别某些十进制数字串作为合法的二进制转换。

所有这些在实践中意味着什么呢？首先，IP 地址块是以 2 的倍数发放的。如果你有 4 位可以操作，你将拥有 16 个 IP 地址（2 × 2 × 2 × 2 = 16）。如果你有 8 位可以操作，你将拥有 256 个地址（2⁸ = 256）。如果有人说你正好有 19 个 IP 地址，那你要么是和别人共享以太网，要么他们错了。

经常会看到主机的 IP 地址后附带其网络掩码——例如，198.51.100.4/26\。这给你提供了将主机接入本地网络所需的所有信息。（寻找默认网关是另一个问题，但根据惯例，它通常是该块中最高或最低的地址。）

#### *十进制计算网络掩码*

你可能不想反复进行十进制和二进制之间的转换。这样不仅不舒服，还增加了出错的机会。这里有一个技巧，可以让你在保持十进制思维的同时计算网络掩码。

你需要找到你网络中有多少个 IP 地址。这个数字几乎肯定是 2 的倍数，并且小于 256。将你拥有的 IP 地址数量从 256 中减去，这就是你的子网掩码的最后一个数字。你还需要识别合法的网络大小。如果你的 IP 地址是 203.0.113.100/26，你需要知道，/26 表示 26 个固定位，或者说 64 个 IP 地址。看一下你 IP 地址的最后一个数字，100。它显然不在 0 到 63 之间，但它在 64 到 127 之间。你 IP 块中的其他主机的 IP 地址范围从 203.0.113.64 到 203.0.113.127，而你的子网掩码是 255.255.255.192（256 – 64 = 192）。

在这一点上，我应该提到，子网掩码经常以十六进制数出现。你可能会觉得这整个事情无望，但为了简化你的生活，表 7-2 展示了子网掩码、IP 信息以及针对/24 及更小网络的相关信息。

**表 7-2：** 子网掩码和 IP 地址转换

| **前缀** | **二进制掩码** | **十进制掩码** | **十六进制掩码** | **可用 IP 地址** |
| --- | --- | --- | --- | --- |
| /24 | 00000000 | 255.255.255.0 | 0xffffff00 | 256 |
| /25 | 10000000 | 255.255.255.128 | 0xffffff80 | 128 |
| /26 | 11000000 | 255.255.255.192 | 0xffffffc0 | 64 |
| /27 | 11100000 | 255.255.255.224 | 0xffffffe0 | 32 |
| /28 | 11110000 | 255.255.255.240 | 0xfffffff0 | 16 |
| /29 | 11111000 | 255.255.255.248 | 0xfffffff8 | 8 |
| /30 | 11111100 | 255.255.255.252 | 0xfffffffc | 4 |
| /31 | 11111110 | 255.255.255.254 | 0xfffffffe | 2 |
| /32 | 11111111 | 255.255.255.255 | 0xffffffff | 1 |

#### *不可用的 IP 地址*

你现在已经理解了斜杠、子网掩码和 IP 地址分配是如何协同工作的，举例来说，/28 有 16 个 IP 地址。不幸的是，你不能使用一个块中的所有 IP 地址。块中的第一个 IP 地址是*网络号*，它用于内部记账。

传统上，任何 IP 地址块中的最后一个数字被称为*广播地址*。根据最初的 IP 规格，网络中的每台机器都应该响应该地址的请求。这使得你可以通过 ping 广播地址，快速确定哪些 IP 地址正在使用。例如，在典型的/24 网络中，广播地址是*x* .*y* .*z* .255。 然而，在 1990 年代末，这一功能被转变为一种攻击技术，并且几乎所有操作系统和大多数网络设备默认禁用了它。^(5) 如果你需要此功能，可以将 sysctl `net.inet.icmp.bmcastecho` 设置为`1`。在大多数环境中，广播地址是一个浪费的 IP 地址。无论如何，你不能将网络中的第一个或最后一个 IP 地址分配给设备，否则会导致网络问题。（是的，这使得/31 网络变得无用。）某些系统优雅地失败；其他系统则失败得不那么优雅。不妨试试看——最好在下班后进行，除非你想有个好故事分享给下一个工作。

#### *分配 IPv4 地址*

你可能认为每台网络上的计算机都有一个 IP 地址，但这并不完全正确。每个网络*接口*都有一个 IP 地址。大多数计算机只有一个网络接口，所以对它们来说，二者没有区别。然而，如果你有多个网络卡，每个卡都有一个单独的 IP 地址。你还可以通过别名配置，在一张卡上拥有多个 IP 地址。另一方面，通过特殊配置，你可以将多张卡合并为一个网络接口，即使有多张卡，计算机仍然只有一个虚拟接口。虽然这些区别很小，但在故障排除时要记住它们。

IP 地址 127.0.0.1 始终附加在每个主机的回环接口上。它只能从本地机器访问。

### IPv6 地址和子网

IPv4 的原始工程师认为 42.9 亿个 IP 地址足够整个世界使用。毕竟，计算机是昂贵的，只有军事和教育系统才会连接到互联网。并不是每个人都能拥有多个联网设备。

哎呀。

未使用的 IPv4 地址已经不再可用。IPv4 地址的价格正在上涨。最终，IPv4 地址的价格将高得大多数人无法承受。全世界不得不迈向 IPv4 的替代者——IP 版本 6。

电信网络和北美以外地区的部分地区已经广泛使用 IPv6。即使你的网络今天没有使用 IPv6，总有一天你会突然发现，上一周你就应该使用它了。

#### *IPv6 基础*

像 IPv4 一样，IPv6 是一种网络层协议。TCP、UDP、ICMP 和其他协议都运行在它之上。回想一下，IPv4 使用 32 位地址，通常表示为四组十进制数字，每组从 0 到 255——例如，203.0.113.13。IPv6 使用 128 位地址，表示为八组四个十六进制字符，每组之间用冒号分隔——例如，2001:db8:5c00:0:90ff:bad:c0de:cafe。

128 位的地址空间是难以想象的巨大，但让我们试着想象一下。数一数每一个曾经活过的人的数量。然后计算他们每个人体内的细胞数量——不仅仅是身体中的细胞，还有身体里的所有细菌细胞。IPv6 足够宽敞，可以为这些细胞中的每一个分配一个比整个 IPv4 地址空间还要大的地址空间。

好消息是，你不需要重新学习网络的基础知识。主机需要一个 IP 地址、一个子网掩码和一个默认网关。你几乎可以——*几乎*——将 IPv6 地址替换为 IPv4 地址，并观察一切正常工作。一个 Web 服务器并不关心它是绑定在 203.0.113.13 的 80 端口，还是绑定在 2001:db8:5c00:0:90ff:bad:c0de:cafe 的 80 端口。服务器接受收到的请求并作出相应的响应。话虽如此，软件的确需要做一些轻微的更改，因为我们的 Web 服务器必须能够记录来自 IPv4 和 IPv6 地址的连接。这些更改有广泛的影响，我们将在几十年内发现新的边缘案例。但总体而言，一旦你理解了 IPv6 的新规则，你所有的网络知识都是适用的。

#### *理解 IPv6 地址*

如前所述，IPv6 地址是 128 位，表示为八组用冒号分隔的每组四个十六进制字符。与十进制的 IP 地址类似，每组中的前导零不需要显示。地址 2001:db8:5c00:0:90ff:bad:c0de:cafe 可以写成 2001:0db8:5c00:0000:90ff:0bad:c0de:cafe，但就像我们不会写 203.000.113.013 一样，我们会去掉 IPv6 地址中的前导零。

IPv6 地址通常包含长串的零，这是由于 IPv6 子网的方式所致。当我写这篇文章时，Sprint 网站的 IPv6 地址是 2600:0:0:0:0:0:0:0。连续的零组会被两个冒号替代。你可以将这个 IP 地址显示为 2600::。但是，你只能在每个地址中做一次双冒号替换。像 2001::a::1 这样的地址将是模棱两可的。2001::a::1 代表 2001:0:0:0:0:a:0:1，2001:0:0:0:a:0:0:1，2001:0:0:a:0:0:0:1，还是 2001:0:a:0:0:0:0:0:1？没有办法确定。

你可能已经见过 IPv4 地址后面加上端口号，例如 203.0.113.13:80。将这种术语与 IPv6 地址结合使用会使它们更加丑陋，并且让所有人感到困惑。像 2001:db8:5c00:0:90ff:bad:c0de:cafe:80 这样的 IP 地址和端口组合并不模糊，但除非你非常仔细阅读，否则你可能会以为它是一个以 80 结尾的 IP 地址。如果你在表示 IP 和端口组合时，应该将地址用方括号括起来，如 [2001:db8:5c00:0:90ff:bad:c0de:cafe]:80。

#### *IPv6 子网*

IPv6 地址每 16 位用冒号分隔，因此划分网络的自然方式通常是/16、/32、/48、/64、/80、/96 和/112。原始的 IPv6 标准建议仅在这些边界进行子网划分（重复了 IPv4 的一个重大错误），但这一做法正被越来越多的人拒绝，转而支持类似 IPv4 风格的任意位置子网划分。IPv6 子网总是用斜线表示，也称为前缀长度，所以你不会看到类似 IPv4 的网掩码 ffff:ffff:ffff:ffff::。

ISP 通常会分配一个/32 或/48 地址块，期望为终端用户网络（例如典型的客户端）分配一个/64 的网络。一个/64 有 2⁶⁴个子网，即 18,446,744,073,709,551,616 个地址。如果你家里或办公室的 IP 地址用完了，你需要停止为每个蓝莓设备单独联网。

当你在 16 位边界进行子网划分时，每个网络会有 65,536 个下一级子网。一个/32 包含 65,536 个/48 网络，一个/48 包含 65,536 个/64 网络。

这是一个冗长的解释，说明了为什么我不提供 IPv6 子网和网络大小的便捷图表。你可以在网上搜索“IPv6 子网计算器”来使用互联网上的计算工具。

#### *链路本地地址*

以*fe8x:*开头的地址（其中*x*是任何十六进制字符）是本地接口的地址。每个接口都有这样的*链路本地*地址，这些地址仅在特定的本地网络上有效。即使一个 IPv6 网络没有路由器，直接附加到本地网络的主机仍然可以使用这些本地地址相互发现并进行通信。链路本地网络始终是/64 子网。你会在其他接口以及完全与本地网络断开的网络上看到相同的 IPv6 子网。这是可以的，这些地址只对链路本地有效。例如，这是一个来自测试机器的链路本地地址。

```
fe80::bad:c0de:cafe%vtnet0
```

这个接口的链路本地地址是`fe80::bad:c0de:cafe`。结尾的`%vtnet0`表示这个地址只在接口`vtnet0`本地有效，无法在机器上的任何其他接口上使用。如果你的机器有一个`vtnet1`接口，而该网络上的主机试图访问地址`fe80::bad:c0de:cafe`，这台机器不会响应。这个地址仅对直接附加到`vtnet0`接口的网络段上的主机有效。

你可能会注意到，这个链路本地地址和该接口的公共 IPv6 地址有一部分是相同的。这是因为自动配置的 IPv6 地址通常是根据接口的物理地址计算出来的；无论该自动配置的地址是公共的还是链路本地的，都没有关系。

#### *分配 IPv6 地址*

在/64 或更大的网络上，IPv6 客户端通常可以通过*路由器发现*自动配置自己的网络。路由器发现类似于简化版的 DHCP 服务。路由器广播网关和子网信息，主机自我配置以使用这些信息。

现代路由器发现版本包括非常基础的 DHCP 风格选项，如 DNS 服务器。然而，并非所有的 IPv6 提供商在其路由器发现配置中都包括这些选项。如果你想为手机或无盘主机提供复杂的自动配置，或者如果你的提供商没有在其配置中提供 DNS 信息，你将需要设置一个 IPv6 DHCP 服务器。

服务器不应使用 IPv6 自动配置。服务器通常需要一个静态 IP，即使是在 IPv6 中也是如此。

网络上小于 /64 的主机必须手动配置。

地址 ::1 始终表示本地主机，并被分配给回环地址。

### TCP/IP 基础

现在你已经对 IP 系统的工作原理有了简单的概述，让我们更深入地考虑一下最常见的网络协议。互联网上占主导地位的传输协议是传输控制协议/因特网协议，简称 TCP/IP。尽管 TCP 是一种传输协议，而 IP 是一种网络协议，但它们紧密交织在一起，通常被视为一个整体。

我们将从最简单的 ICMP 开始，然后讨论 UDP 和 TCP。这些协议都可以在 IPv4 和 IPv6 上运行。虽然每种协议的版本根据底层 IP 协议有所不同，但它们的行为基本相同。

#### *ICMP*

因特网控制消息协议（ICMP）是用于传输路由和可用性消息的标准协议。像 ping(8) 和 traceroute(8) 这样的工具使用 ICMP 来收集它们的结果。IPv4 和 IPv6 有稍微不同版本的 ICMP，有时被称为 *ICMPv4* 和 *ICMPv6*。

尽管有人声称出于安全原因必须阻止 ICMP，但 ICMP 和我们更熟悉的协议 TCP 和 UDP 一样具有多样性。正确的 IPv4 网络性能需要大量的 ICMPv4。如果你觉得必须阻止 ICMP，应该选择性地进行。例如，阻止源抑制消息会破坏路径最大传输单元（pMTU）发现，就像跌进一箱破碎的玻璃和生锈的钉子里。如果你不明白这句话的意思，那么不要阻止 ICMP。

IPv6 在没有 ICMPv6 的情况下无法正常工作，因为 IPv6 不支持数据包分片。如果你使用 IPv6，绝对不要完全阻止 ICMPv6。阻止 ICMPv6 的某些部分而不破坏你的网络需要仔细研究和测试。

#### *UDP*

用户数据报协议（UDP）是最基础的数据传输协议，运行在 IP 之上。它没有错误处理，最小的完整性验证，并且完全没有防止数据丢失的机制。尽管有这些缺点，UDP 仍然是某些类型数据传输的一个不错选择，许多重要的互联网服务依赖于它。

当主机通过 UDP 传输数据时，发送方无法知道数据是否到达了目的地。接收 UDP 数据的程序只是监听网络，并接受到达的任何数据。当程序通过 UDP 接收数据时，它无法验证数据的来源——尽管 UDP 数据包包含源地址，但这个地址很容易被伪造。这就是为什么 UDP 被称为*无连接*或*无状态*的原因。

既然有这么多缺点，为什么还要使用 UDP 呢？使用 UDP 的应用程序通常会有自己的错误校正处理方法，这些方法与 TCP 等协议提供的默认机制不太兼容。例如，简单的客户端 DNS 查询必须在几秒钟内超时，否则用户会打电话到帮助台抱怨。TCP 连接在两分钟后才会超时。由于计算机希望更快地处理失败的 DNS 请求，简单的 DNS 查询使用 UDP。在需要传输大量数据的 DNS 情况下（例如，区域传送），它会智能地切换到 TCP。实时流数据，如视频会议，也使用 UDP。如果在实时视频会议中错过了一些像素，重新传输这些数据只会增加拥堵。毕竟，你无法回到过去来填补那些丢失的图片部分！几乎所有其他使用 UDP 的网络应用程序背后都可以找到类似的理由。

由于 UDP 协议本身在连接到端口时不会返回任何信息，因此没有可靠的方法可以远程测试 UDP 端口是否可达（尽管像 nmap 这样的工具会尝试执行此操作）。

UDP 也是一种*数据报*协议，这意味着每个网络传输都是完整的、自包含的，并作为一个单独的整体单元接收。虽然应用程序可能不会将单个 UDP 数据包视为一个完整的请求，但网络会这样做。TCP 则完全不同。

#### *TCP*

传输控制协议（TCP）包括如错误修正和恢复等巧妙功能。接收方必须确认每个收到的数据包；否则，发送方会重新传输任何未被确认的数据包。使用 TCP 的应用程序可以期待可靠的数据传输。这使得 TCP 成为*连接型*或*有状态*协议，与 UDP 截然不同。

TCP 也是一种*流式*协议，这意味着一个请求可能会被拆分成多个网络数据包。虽然发送方可能会依次传输多个数据块，但接收方可能会收到乱序或分片的数据。接收方必须跟踪这些数据块，并将其正确组装，以完成网络事务。

为了让两台主机交换 TCP 数据，它们必须建立一个通道来传输数据。一台主机请求连接，另一台主机响应请求，然后第一台主机开始传输。这个设置过程被称为*三次握手*。具体细节现在不重要，但你应该知道这个过程的存在。类似地，一旦传输完成，系统必须执行一定的操作来拆除连接。

TCP 常常被应用程序使用，例如邮件程序、FTP 客户端和网页浏览器，因为它有一个相对通用的超时和传输功能集。

#### *协议如何协同工作*

你可以把网络协议栈比作和家人一起坐在节日聚餐桌前。数据链路层（在 IPv4 通过以太网时是 ARP）让你看到桌上的每个人。IP 给每个人分配一个独特的座位，除了那三个用钢琴凳 NAT 的年轻侄子。ICMP 提供基本的路由信息，例如，“到豌豆的最快方式是让克里斯叔叔递给你。”TCP 是你递给别人一道菜，另一个人必须说“谢谢”，你才能放手。最后，UDP 就像是把一个面包滚向贝蒂阿姨；她可能会接住，可能会从额头弹开，或者可能会被在饭桌旁等机会的狗从空中抓住。

#### *传输协议端口*

你有没有注意到计算机有太多的端口？我们要在这道汤中加入 TCP 和 UDP 端口。*传输协议端口*允许一个服务器通过一个传输协议提供许多不同的服务，实现机器之间连接的复用。

当一个网络服务器程序启动时，它会附加或*绑定*到一个或多个逻辑端口。逻辑端口只是一个从 1 到 65535 的任意数字。例如，互联网邮件服务器绑定到 TCP 端口 25。每个到达系统的 TCP 或 UDP 数据包都有一个字段，指示它希望的目标端口。每个传入请求都会标记一个目标端口号。如果传入请求请求端口 25，它会连接到在该端口上监听的邮件服务器。这意味着其他程序可以在不同的端口上运行，客户端可以与这些不同的端口通信，除非是系统管理员，否则没有人会感到困惑。

*/etc/services* 文件包含了一份端口号及其常用服务的列表。几乎可以在任何端口上运行任何服务，但这样做会让其他试图连接到你系统的互联网主机感到困惑。如果有人尝试向你发送电子邮件，他们的邮件程序会自动连接到你系统的端口 25。如果你把邮件服务运行在端口 77，而你在端口 25 上有一个 Web 服务器，你将永远收不到邮件，且你的 Web 服务器将开始收到垃圾邮件。*/etc/services* 文件有一个非常简单的五列格式。

```
➊qotd  ➋17/➌tcp  ➍quote        ➎#Quote of the Day
```

这是`qotd`服务的条目 ➊，它在 TCP 协议中运行在 17 端口 ➋。它也被称为`quote`服务 ➍。最后，我们有一个评论 ➎，提供了更多的细节；显然，*qotd*代表*每日一句*。服务在 TCP 和 UDP 协议中都分配相同的端口号，尽管它们通常只在其中一个协议上运行而不是另一个——例如，qotd 有 17/tcp 和 17/udp 端口。

许多服务器程序会读取*/etc/services*文件，以了解启动时应该绑定到哪个端口，而客户端程序会读取*/etc/services*文件，以了解它们应该尝试连接到哪个端口。如果你在非标准端口上运行服务器，可能需要编辑这个文件来告知服务器应该连接到哪个端口。

正如所有标准一样，常常有充分的理由去打破规则。SSH 守护进程 sshd 通常监听 22/tcp 端口，但我曾出于各种原因将其运行在 23（telnet）、80（HTTP）和 443（HTTPS）端口上。配置这一点取决于你所使用的服务器程序。

##### 保留端口

TCP 和 UDP 协议中低于 1024 的端口被称为*保留端口*。这些端口只分配给核心互联网基础设施和重要服务，如 DNS、SSH、HTTP、LDAP 等——这些服务应该仅由系统或网络管理员合法提供。只有具有根用户权限的程序才能绑定到这些低编号的端口。用户可以在系统策略允许的情况下，在高编号端口上提供比如游戏服务器等服务——但这与设置一个公开可见并声明机器主要用途是游戏服务器的正式网页有些不同！这些核心协议的端口分配通常是固定的。

你可以使用 sysctl 命令`net.inet.ip.portrange.reservedhigh`和`net.inet.ip.portrange.reservedlow`查看和更改保留端口。

有时，某些人认为他们可以禁用这个“仅根用户绑定”功能，从而提高系统的安全性——毕竟，如果你的应用程序可以作为普通用户而非根用户运行，这是否会增加系统的安全性呢？大多数在保留端口上运行的程序实际上是以根用户身份启动，绑定端口后，再将权限降级为一个权限比普通用户更少的特殊限制用户。这些程序设计上就是以根用户启动，并且在以普通用户身份运行时通常会表现得不同。一些程序，如 Apache Web 服务器，编写时已考虑到可以由非根用户安全启动，但其他程序则没有。

### 理解以太网

以太网在企业和家庭网络中极为流行，也是 FreeBSD 系统最常见的连接介质。以太网是一个共享网络；许多不同的机器可以连接到同一个以太网，并可以直接相互通信。这使得以太网相较于其他网络协议具有很大优势，但以太网也有物理距离限制，这使得它仅适用于办公室、共置设施和其他相对较小的网络。^(6)

多种不同的物理介质在过去多年里都支持以太网。曾几何时，大多数以太网电缆都是厚重的同轴电缆。如今，大多数则是相对较薄的 CAT6 电缆，内部有八根非常细的导线。你还可能遇到光纤或无线电上的以太网。为了便于讨论，我们假设你使用的是 CAT6 或更高规格的电缆，这是目前最流行的选择。无论你使用什么物理介质，以太网的理论并不会改变——记住，物理层已经被抽象化。

#### *协议和硬件*

以太网是一种广播协议，这意味着你在网络上发送的每个数据包都可以发送到网络上的每个工作站。（注意，我说的是*可以发送*；一些以太网硬件限制了这些广播的接收者。）你的网卡或其设备驱动程序将目标是你计算机的数据与目标是其他计算机的数据分开。以太网广播特性的一种副作用是，你可以窃听其他计算机的网络流量。虽然这在诊断问题时非常有用，但它也是一个安全隐患。在传统的以太网上捕获明文密码是很简单的。所有主机可以直接与所有其他主机通信而不涉及路由器的以太网部分被称为*广播域*或*段*。

以太网段通过集线器或交换机连接。以太网*集线器*是一个中央硬件设备，用来物理连接多个其他以太网设备。集线器只是简单地将收到的所有以太网帧转发给连接到网络的其他设备。集线器将收到的所有以太网流量广播到每个附加的主机和其他连接的集线器。每个主机负责过滤掉它不需要的流量。集线器是老式的以太网设备，现在很少见了。

*交换机*已经大多取代了集线器。交换机就像集线器，但它会过滤掉发送到每个主机的流量。它识别附加设备的物理地址，并在大多数情况下，仅将帧转发到它们所指向的设备。由于每个以太网主机的带宽是有限的，交换通过减少每个主机必须处理的流量，来减轻单个系统的负担。

##### 交换机故障

交换机会发生故障，尽管思科公司可能不希望你这样认为。一些故障很明显，例如当神秘的黑烟从设备后面泄漏出来时。当交换机失去它的“魔法烟雾”时，它就停止工作了。还有一些故障较为微妙，看起来交换机依然在工作。

每个交换机制造商必须决定如何处理细微的错误。交换机可以选择关闭，直到有人处理，或者尝试向管理员发出警告并继续尽力转发数据包。如果你是供应商，选择显而易见——你尽最大努力让你的客户不认为你的交换机是垃圾。这意味着你的交换机可能会开始像集线器一样工作，而你可能并不知道。坏消息是，如果你依赖交换机来防止机密信息泄漏，你将注定失望。已经有不止一台交换机以这种方式失败过，所以当它发生在你身上时，别太惊讶。

安装一个 syslog 服务器（参见第二十一章）并让你的交换机将日志发送到它，可以降低这个风险。虽然日志记录无法防止交换机故障，但它将简化当交换机开始出现问题时，倾听其抱怨的过程。

##### 以太网速度

以太网最初只支持每秒几兆比特的速度，但现在已经扩展到能够处理数十吉比特的速度。大多数以太网卡的速度是*千兆*，意味着它们每秒可以处理一个千兆比特的数据，但在高速应用中你会找到一些 10Gbs 或 100Gbs 的卡。如果一张卡被标记为*千兆*，并不意味着它实际上能够处理这么大的流量——我见过千兆卡在只有十分之一带宽的情况下就卡住了。当你需要推送带宽时，卡的质量很重要，而当你推送大量带宽时，整个计算机的质量也非常重要。

让交换机和网卡通过*自动协商*自行协商它们的设置。虽然一些经验丰富的人可能记得在旧版以太网卡上禁用自动协商，但千兆及更高速率的以太网要求自动协商才能正常工作。

#### *MAC 地址*

每个以太网卡都有一个唯一的标识符，即媒体访问控制（MAC）地址。这个 48 位的数字有时被称为*以太网地址*或*物理地址*。当一个系统向另一个主机发送数据时，它首先广播一个以太网请求，询问：“哪个 MAC 地址负责这个 IP 地址？”如果主机用它的 MAC 地址作出回应，进一步的数据就会传输到那个 MAC 地址。

IPv4 使用地址解析协议（ARP）将 IP 地址映射到主机。使用 arp(8)命令查看你的 FreeBSD 系统对 ARP 表的了解。最常见的用法是`arp -a`命令，它显示计算机已知的所有 MAC 地址和主机名。

```
# arp -a
gw.blackhelicopters.org (198.51.100.1) at 00:00:93:34:4e:78 on igb0 [ethernet]
sipura.blackhelicopters.org (198.51.100.5) at 00:00:93:c2:0f:8c on igb0 [ethernet]
```

这个完整的 ARP 信息列表被称为*ARP 表*，或*MAC 表*。（术语 MAC 和 ARP 常常可以互换使用，所以不用太担心这个问题。）在这里，我们看到主机*gw.blackhelicopters.org*的 IP 地址是 198.51.100.1，MAC 地址是 00:00:93:34:4e:78，并且你可以通过本地系统的接口`igb0`访问这些主机。

如果 MAC 地址显示为`incomplete`，则表示无法在本地以太网中联系到该主机。在这种情况下，检查你的物理层（电缆）、远程系统以及两者的配置。

IPv6 使用邻居发现协议（NDP）将 IPv6 地址映射到 MAC 地址。这是一个与 ARP 不同的独立协议，用于包括路由器发现。使用 ndp(8)查看主机的 MAC 表和对应的 IPv6 地址。输出故意与 arp(1)类似。

```
# ndp -a
Neighbor                          Linklayer Address  Netif  Expire    S Flags
fe80::fc25:90ff:fee8:1270%vtnet0  fe:25:90:e8:12:70  vtnet0 4s        R R
www.michaelwlucas.com             00:25:90:e8:12:70  vtnet0 permanent R
fe80::225:90ff:fee8:1270%vtnet0   00:25:90:e8:12:70  vtnet0 permanent R
```

输出故意与 arp(8)类似，但略显表格化。`Neighbor`列显示每个邻居的 IPv6 地址、主机名或链路本地地址。`Linklayer Address`列显示邻居的 MAC 地址。`Netif`列显示该主机所连接的网络接口，而`Expire`列显示缓存条目将过期的时间。`S`（状态）列提供有关条目的进一步信息。`R`状态表示主机是可达的，而`I`（incomplete）表示主机不可达。你可能看到的唯一`Flags`条目是`R`，表示该主机正在将自己广告为路由器。有关更多状态和标志，请参见 ndp(8)。

为什么有两个独立的命令？arp(8)和 ndp(8)都用于将 IP 地址映射到 MAC 地址。有些主机可能仅通过其中一个协议或另一个协议可用。仅支持 IPv6 的主机不会出现在你的 ARP 表中，而仅支持 IPv4 的主机则不会出现在 NDP 表中。

对于 arp(8)和 ndp(8)命令，`-n`标志会关闭主机名查找。当你在调试网络问题并且无法获取 DNS 解析时，这个功能非常有用。

现在你了解了网络的工作原理，配置互联网连接就非常简单了。
