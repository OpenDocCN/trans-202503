## **5**

在您打破其他东西之前，请阅读此内容！（备份和恢复）**

![image](img/common01.jpg)

系统故障最常见的原因是那些烦人的人类，但硬件和操作系统也会出现故障。黑客不断学习新方法来破坏网络和渗透应用程序，您不可避免地需要定期升级和修补您的系统。（您是否*会*升级和修补是另一个完全不同的问题。）每次操作系统时，您都有可能犯错、配置错误至关重要的服务，或彻底毁坏系统。想想看，每次修补任何操作系统的计算机后，总会发现某些地方异常！即使是小的系统变动也可能损坏数据。因此，您应该始终假设最坏的情况即将发生。在我们的情况下，这意味着如果硬件或人为因素破坏了硬盘上的数据，您必须能够恢复这些数据。

我们将从使用 tar(1) 进行系统备份和管理磁带驱动器开始，然后回顾如何使用 script(1) 记录系统行为。最后，如果您遭遇部分或几乎完全的灾难，我们将考虑如何通过单用户模式和安装介质恢复和重建系统。

### **系统备份**

只有在您关心数据时，才需要进行系统备份。这并不像听起来那么无意义。真正的问题是，“如果我的数据丢失，替代它的成本是多少？”低端磁带备份系统可能只需几百美元。您的时间值多少钱，恢复系统所需的时间有多久？如果硬盘上最重要的数据是您浏览器的书签文件，那么备份系统可能不值得投资。但如果您的服务器是公司骨干，您就需要非常认真地对待这一投资。

在线备份很容易被破坏或摧毁，就像破坏正在运行的服务器一样。正确的备份应该安全地离线存储。像 rsync(1) 这样的工具，甚至是 ZFS 复制，都不创建实际的备份；它们只是创建方便的在线副本。

完整的备份和恢复操作需要磁带驱动器和介质。您还可以将数据备份到文件、通过网络或到可移动介质（如 CD 或 DVD）。许多人使用通过 USB 3 连接的可移动多 terabyte 硬盘进行备份。尽管我们尽力而为，但磁带仍然是许多环境中的重要媒介。

### **备份磁带**

FreeBSD 支持 SCSI 和 USB 磁带驱动器。SCSI 驱动器是最快且最可靠的。USB 磁带驱动器并不总是符合标准，因此并非总是与 FreeBSD 兼容。务必检查发布说明或 FreeBSD 邮件列表存档，以确认您的磁带驱动器是否与 FreeBSD 兼容。

一旦你物理安装了磁带驱动器，需要确认 FreeBSD 是否识别它。最简单的方法是检查 */var/run/dmesg.boot* 文件中是否有 *sa* 设备（参见 第四章）。例如，以下三行来自 *dmesg.boot*，描述了此机器中的 SCSI 磁带设备：

```
➊sa0 at mps0 bus 0 ➋scbus0 ➌target 3 lun 0
sa0: ➍<QUANTUM ULTRIUM 5 3210> Removable Sequential Access SPC-4 SCSI device
sa0: Serial Number HU1313V6JA
sa0: ➎600.000MB/s transfers
sa0: Command Queueing enabled
```

在所有关于这个磁带驱动器的信息中，最重要的是你的 FreeBSD 系统将这个设备识别为 sa0 ➊。我们还看到它连接到 SCSI 卡 mps0 ➋，SCSI ID 为 3 ➌，并且我们看到驱动器的型号 ➍，以及它能够以每秒 600MB 的速度运行 ➎。

#### ***磁带驱动器设备节点、倒带和弹出***

磁带是一种线性存储介质。每一段磁带存储一部分数据。如果你将多个数据块备份到磁带，避免在每次备份操作后倒带。假设你将一个系统的备份写入磁带，倒带磁带后再备份另一个系统，第二次备份会覆盖第一次备份，因为它使用了相同的磁带段。当你在单个磁带上进行多个备份时，使用合适的设备节点以确保任务之间不会倒带。

与许多有着数十年历史的 Unix 设备一样，访问磁带驱动器的方式决定了它的行为。磁带驱动器有多个不同的设备节点，每个节点让磁带驱动器表现不同。最基本的磁带控制机制是用来访问它的设备节点。普通磁带驱动器有三个节点：*/dev/esa0*、*/dev/nsa0* 和 */dev/sa0*。

磁带是顺序访问设备，要访问磁带上某一特定段的数据，必须倒带磁带以暴露该段。是否倒带是一个重要的问题。

**注意**

*不同磁带设备节点的行为在操作系统之间有所不同。不同版本的 Unix，以及不同的磁带管理软件，会以不同的方式处理磁带。不要对你的备份磁带做假设！*

如果你使用与设备名称匹配的节点名称，当命令完成时，磁带驱动器将自动倒带。我们的示例 SCSI 磁带驱动器的设备名称为 sa0，因此如果你使用 */dev/sa0* 作为设备节点运行命令，命令完成后磁带将倒带。

如果你不希望命令完成时磁带自动倒带，可以使用以 *n* 开头的节点名称来阻止倒带。也许你需要将来自另一台机器的第二个备份附加到磁带上，或者你想在倒带和弹出之前对磁带进行编目。在我们的示例中，使用 */dev/nsa0* 来运行命令而不进行倒带。

要在命令完成时自动弹出磁带，可以使用以 *e* 开头的节点。例如，如果你正在运行完整系统备份，可能希望命令完成时自动弹出磁带，这样操作员就可以将磁带放入盒子中送往外部存储或存放起来。我们的示例使用 */dev/esa0* 设备名称，在命令完成时弹出磁带。一些磁带驱动器可能不支持自动弹出；它们需要你按下物理按钮，操作杠杆将磁带从驱动器中拉出。识别这种驱动器的最简单方法是尝试通过设备节点弹出它，然后看看发生了什么。

#### ***$TAPE 变量***

许多程序假设你的磁带驱动器是 */dev/sa0*，但这并不总是正确的。即使你只有一个磁带驱动器，你也可能希望在命令完成时自动弹出磁带（*/dev/esa0*），或者在完成时不自动倒带（*/dev/nsa0*）。

许多（但不是所有）与备份相关的程序使用环境变量 `$TAPE` 来控制它们默认使用的设备节点。你始终可以在命令行上覆盖 `$TAPE`，但将其设置为你最常用的选项可以节省你以后的一些麻烦。

#### ***使用 mt(1) 检查磁带状态***

现在你知道如何找到你的磁带驱动器后，你可以使用 mt(1) 执行基本操作——如倒带、重张、擦除等等。mt(1) 做的一个基本操作是检查磁带驱动器的状态，具体如下：

```
# mt status
Mode      Density              Blocksize      bpi      Compression
Current: ➊0x25:DDS-3          variable       97000   ➋DCLZ
---------available modes---------
0:        0x25:DDS-3           variable       97000    DCLZ
1:        0x25:DDS-3           variable       97000    DCLZ
2:        0x25:DDS-3           variable       97000    DCLZ
3:        0x25:DDS-3           variable       97000    DCLZ
---------------------------------
             ➌ Current Driver State: at rest.
---------------------------------
File Number: 0  Record Number: 0          Residual Count 0
```

你不必担心这里的大多数信息，但如果你想逐行查看，mt(1) 手册页面包含了所有功能的良好描述。至少，如果命令返回了任何有用的信息，意味着 mt(1) 能找到你的磁带驱动器。

我们首先看到的是驱动器密度 ➊。旧的驱动器可以有不同密度的磁带，用于不同的目的，但现代磁带驱动器尽可能紧密地压缩数据。这个特定的磁带驱动器是 DDS-3 型号；虽然你可以选择使用其他密度，但它提供的所有选择都是 DDS-3。我们还看到这个磁带驱动器提供了 DCLZ 算法的硬件压缩 ➋。在底部附近，我们看到磁带驱动器现在正在做什么 ➌。

`status` 命令可能会给你不同种类的信息。最有问题的就是那个告诉你磁带驱动器未配置的消息：

```
#mt status
mt: /dev/nsa0: Device not configured
```

这意味着你在 `$TAPE` 变量指向的设备节点上实际上没有磁带。你可以通过使用 `-f` 标志来指定设备节点（例如，`mt -f` `/dev/nsa1 status`）来实验设备节点和 mt(1)，尽管你应该从 *dmesg.boot* 获取正确的信息。如果你确定你的设备节点是正确的，也许是因为驱动器中没有插入磁带，或者磁带驱动器需要清洁。

从`mt status`返回的另一个响应是`mt: /dev/nsa0: 设备忙碌`。你请求了磁带的状态，磁带回应：“我现在忙，不能接听。”稍后再试，或者使用`ps -ax`查看哪些命令正在使用磁带驱动器。当你在操作实际的磁带时，只有一个程序实例能够同时访问它。你无法在从磁带提取文件时列出磁带内容。

#### ***其他磁带驱动器命令***

你可以用磁带驱动器做的不仅仅是检查它是否正常工作。我最常用的 mt(1)子命令是`retension`、`erase`、`rewind`和`offline`。

磁带有伸展的倾向，尤其是在第一次使用后。（我非常清楚，现代的磁带供应商都声称他们的磁带经过预拉伸，或者说他们的磁带无法被拉伸，但这个说法和两片面包就能做成一个博洛尼亚三明治。）*重新张紧*磁带只是将磁带完全前后地通过一次，命令是`mt retension`。重新张紧会去掉磁带中的松弛部分，使备份更加可靠。

*擦除*会从磁带上移除所有数据。这不是一个完全可靠的擦除方法，如果你需要隐藏数据以防止数据恢复公司或税务局查看，`mt erase`只是简单地在磁带上滚动并覆盖所有内容一次。这可能需要很长时间。如果你想快速擦除磁带，可以使用`mt erase 0`将磁带标记为空白。

`mt rewind`命令将磁带倒带到起始位置，和通过默认设备节点访问设备一样。

当你*脱机*磁带时，你需要倒带并弹出磁带，这样才能插入新的磁带。奇怪的是，命令是`mt offline`。

现在，让我们获取一些关于这张磁带的数据。

**磁带驱动器的特性**

并非所有的磁带驱动器都支持所有功能。特别是老旧的磁带驱动器非常挑剔，甚至有些脾气不好，要求非常特定的设置才能正常工作。如果你遇到特定驱动器的问题，可以查看*FreeBSD-questions*邮件列表归档，看看是否有其他人遇到过相同的问题。你很可能在那里找到答案。

### **BSD tar(1)**

用于将系统备份到磁带的最流行工具是 tar(1)。*Tar*是“磁带归档程序”的缩写——它是专门为备份而编写的。FreeBSD 也包含了 dump(8)，但它仅适用于不使用软更新日志的 UFS 文件系统。你还会遇到其他备份工具，如 pax 和 cpio，以及基于网络的备份工具，如 Amanda、Bacula 和 Tarsnap。这些工具适合某些特定环境，但不如 tar 那样通用。Tar 是几乎所有操作系统供应商都认可的常见标准；你可以在 Windows、Linux、Unix、BSD、macOS、AS/400、VMS、Atari、Commodore 64、QNX 等几乎所有其他平台上找到 tar。

你可以使用 tar(1)将文件备份到磁带或文件中。包含 tar 文件的备份文件称为*tarball*。从 tarball 中恢复单个文件或一部分文件非常快速且简单。从磁带中恢复备份的一部分也很容易，但速度远不如直接恢复。

FreeBSD 使用的 tar 版本叫做*bsdtar*。bsdtar 可以完全一致地与 GNU tar 配合使用，也可以严格遵循 POSIX tar 的行为。如果你对 GNU tar、POSIX tar 和 bsdtar 之间的差异有任何疑虑，阅读 tar(1)以了解所有详细信息。bsdtar 基于 libarchive(3)构建，这是一个专门用于创建和提取备份归档的库。得益于 libarchive，bsdtar 可以从传统的磁带备份到 ISO 镜像提取文件，所有操作都有相同的界面。如果你需要打开 RPM、zip 文件或几乎任何其他归档文件，bsdtar 都是你的朋友。

像其他任何 tar(1)一样，bsdtar 也可以很“傻”。如果你的文件系统以任何方式损坏，bsdtar 会备份它认为你请求的内容。然后，它会愉快地恢复在原始备份过程中损坏的文件，将正在工作但不正确的文件覆盖为无法正常工作的错误版本。虽然这种问题很少发生，但一旦发生，往往令人难以忘怀。

**文件系统一致性**

无论你使用什么备份软件，在你尝试备份文件时，文件可能会发生变化。日志文件会不断地在末尾添加内容，而数据库可能在文件的任何地方发生变化。文件系统快照始终是一致的，UFS（第十一章）和 ZFS（第十二章）都支持这种功能。绝不要备份正在运行的数据库；应该将数据库转储到归档文件中，然后备份该归档文件。

#### ***tar 模式***

tar 可以执行几种不同的操作，这些操作由命令行标志控制。这些不同的操作被称为*模式*。你需要阅读 man 页面，了解所有 tar 模式的完整描述，但以下列表列出了最常用的几种。

##### **创建归档**

使用*创建模式*（`-c`）来创建一个新的归档。除非另有指定，否则此标志将把所有内容备份到你的磁带驱动器（`$TAPE`，如果没有设置`$TAPE`，则为*/dev/sa0*）。要备份整个系统，你需要告诉 tar 从根目录开始归档所有内容：

```
# tar -c /
```

作为回应，你的磁带驱动器应该亮起，如果你的磁带足够大，最终会呈现出一个完整的系统备份。然而，许多现代硬盘比磁带驱动器能够容纳的容量还要大，因此备份系统中仅重要的部分是更为合理的。例如，如果你电脑上唯一需要的文件都在*/home*和*/var*目录下，你可以在命令行中指定这些目录：

```
# tar -c /home /var
```

##### **列出归档内容**

*列出模式*（`-t`）列出归档中的所有文件。创建归档后，你可以使用此模式列出磁带的内容。

```
# tar -t
.
.snap
dev
tmp
--snip--
```

这个列表包括你备份中的所有文件，运行时可能需要一些时间。注意，文件名中的初始斜杠缺失；例如，*/tmp* 会显示为 *tmp*。这在恢复时变得很重要。

##### **从备份中提取文件**

在*提取*模式下，tar 从归档中恢复文件并将其复制到磁盘上。（这也叫做*解压*。）tar 在你当前的位置提取文件；如果你想用备份中的文件覆盖现有的 */etc* 目录，首先进入根目录。另一方面，如果我要在我的主目录中恢复一个 */etc* 的副本，我会首先进入我的主目录。

```
# cd /home/mwlucas
# tar -x etc
```

记得我说过，缺少的初始斜杠很重要吗？这就是原因。如果备份中包含了那个初始斜杠，tar 将始终相对于根目录提取文件。恢复的 */etc/rc.conf* 将始终写入到 */etc/rc.conf*。没有前导的 */*，你可以将文件恢复到你想要的任何位置；恢复后的 */etc/rc.conf* 可以被恢复为 */home/mwlucas/etc/rc.conf*。如果我正在从一台已退役的机器恢复文件，我不希望它们覆盖当前机器上的文件；我希望它们被放置在其他地方，以免干扰我的系统。

##### **验证备份**

一旦你有了备份，你可能想确认它是否与你的系统匹配。*Diff* 模式（`-d`）将磁带上的文件与磁盘上的文件进行比较。如果磁带上的一切与系统匹配，`tar -d` 将默默运行。然而，磁带和系统之间的完美匹配并*不*是正常的情况。日志文件通常在备份过程中增长，因此磁带上的日志文件不应该与磁盘上的文件匹配。类似地，如果你有一个正在运行的数据库服务器，数据库文件可能不匹配。如果你真的想要一个完美的备份（也叫做*冷备份*），你需要在备份之前将系统切换到单用户模式。你必须决定你可以接受哪些错误，哪些错误需要修正。

#### ***其他 tar 特性***

Tar 还有一些其他功能，可以使它更友好或更有用。这些功能包括详细模式、不同类型的压缩、权限恢复，以及最流行的选项——备用存储。

##### **使用非默认存储**

默认情况下，tar 会将所有内容传输到你的磁带驱动器，但 `-f` 标志允许你指定另一个设备或文件作为目标。在之前的所有示例中，我要么使用默认的磁带驱动器 */dev/sa0*，要么设置了 `$TAPE`。如果我没有这两者中的任何一个，我需要使用 `-f` 来指定磁带驱动器：

```
# tar -c -f /dev/east0 /
```

你还可以将备份保存到文件（或 tar 包）中，而不是使用磁带。通过互联网分发的源代码通常以 tar 包的形式分发。使用相同的 `-f` 标志来指定文件名。例如，为了备份这本书写作时的各个章节，我每隔一段时间运行以下命令来创建 tar 包 *bookbackup.tar*：

```
#tar -cf bookbackup.tar /home/mwlucas/af3e/
```

这个文件可以轻松地在其他地方的机器上进行备份——即使我的房子着火了，书籍也会安全。我可以接通电话和电力线到邻居家，借一台笔记本电脑，找到一个开放的无线接入点，运行 `tar -xf bookbackup.tar`，在焦黑的木材中工作，等待保险公司处理。 (反正那时我也做不了别的事。)

##### **详细模式**

除非遇到错误，否则 tar 通常静默运行。大多数时候这是好的（谁想在每次备份时查看服务器上完整的文件列表？），但有时你会想看到程序执行的过程，获得一种温暖的满足感。添加 `-v` 标志会使 tar 打印它处理的每个文件的名称。你可以使用详细模式标志来创建所有正在备份或恢复的文件的完整列表。在常规的备份或恢复中，这种冗余信息会使错误变得难以察觉。

#### ***压缩***

Bsdtar 继承了 libarchive(3) 所理解的所有压缩算法的支持。我们将介绍一些你可能用来创建归档的压缩算法，按从最理想到最不推荐的顺序排列。Bsdtar 支持更多的压缩算法，但通常情况下你不会使用它们来创建归档。

##### **XZ 压缩**

XZ 压缩算法是当前的新热点。使用`-J`启用它。非 FreeBSD 主机可能需要通过 xz(1) 管道恢复数据以进行读取。使用 XZ 压缩的 Tarball 通常以 *.txz* 结尾。

##### **bzip 压缩**

FreeBSD 的 tar 支持 bzip 压缩，它比 gzip 压缩得更紧凑，使用 `-j` 标志。Bzip 使用的 CPU 时间比 gzip 多，但如今，CPU 时间不像 gzip 出现时那样有限。并不是所有版本的 tar 都支持 bzip 压缩。如果你只会在 FreeBSD 机器上读取文件，或者你愿意在其他平台上安装 bzip，可以使用 `-j` 标志。大多数使用 bzip(1) 压缩的 tarball 以 *.tbz* 结尾。

##### **gzip 压缩**

gzip 标志（`-z`）会在归档的过程中将文件通过 gzip(1) 压缩程序进行处理。压缩后的 tarball 通常以 *.tar.gz*、*.tgz* 或在少数情况下以 *.taz* 结尾。压缩可以大大减小归档的大小；许多备份在压缩后减小了 50% 或更多。虽然所有现代版本的 tar 都支持 gzip，但旧版本不支持，因此，如果你希望每个人都能读取你的备份，最好不要使用 `-z`。

##### **原始 Unix 压缩**

相比之下，所有 Unix 版本的 tar 都可以使用 `-Z` 标志通过 compress(1) 压缩文件。compress 程序的效率不如 gzip，但它确实能够减小文件大小。你可能会遇到的每个 tar 实现都支持 compress(1)。使用 `-Z` 压缩的 tarball 后缀为 *.tar.Z*。

#### ***权限恢复***

`-p`标志会恢复提取文件的原始权限。默认情况下，tar 会将提取文件的所有者设置为提取文件的用户名。对于源代码来说这没问题，但在进行系统恢复时，你真的希望恢复文件的原始权限。（有时间手动恢复这些权限试试看；你会学到不少关于为什么第一次就应该做对的事情。）

**压缩与 FreeBSD TAR**

FreeBSD 的 libarchive 会自动检测备份中使用的压缩类型。在创建档案时，你必须指定所需的压缩方式，但提取时不需要提供压缩算法。让 tar(1)来决定压缩类型，它会自动执行正确的操作，即使档案是使用你从未见过的算法进行压缩的。

#### ***还有更多，更多，更多……***

Tar 有许多更多的功能，以适应备份、文件、文件系统和磁盘几十年来的变化。欲了解完整的功能列表，请阅读 man tar(1)。

### **记录发生的事情**

现在你可以备份整个系统并跟踪单个文件中的变化。剩下的就是跟踪屏幕前发生的事情。一个很少被提及但非常有用的工具是每个系统管理员都应该知道的`script(1)`。它记录你输入的所有内容以及屏幕上显示的所有内容。你可以记录错误和日志输出，供以后分析和剖析。例如，如果你正在运行一个每次都会在同一位置失败的程序，你可以使用`script`来复制你的按键和程序的响应。这在升级系统或从源代码构建软件时特别有用；日志文件的最后 30 行左右是请求帮助时的好材料。

启动`script(1)`只需输入`script`。你将会得到命令提示符，可以继续正常工作。当你想停止记录时，只需输入`exit`或按 CTRL-D。你的活动将会出现在名为*typescript*的文件中。如果你希望文件有特定的名称或位于特定位置，只需将该名称作为参数传递给`script`：

```
# script /home/mwlucas/debug.txt
```

这个工具对于精确记录你输入的内容以及系统如何响应非常有用。每当你需要寻求帮助时，考虑使用`script(1)`。

### **修复损坏的系统**

学习操作系统的最佳方式是与它玩耍，你玩得越深入，学到的越多。如果你玩得足够狠，你肯定会弄坏某些东西，而这恰恰是好事——修复一个严重损坏的系统可以说是学习的最快方式。如果你刚刚让你的系统无法启动，或者计划快速学习到足够的程度以冒险这样做，那么这一节适合你。如果你的系统已经严重损坏，你会学到很多并且会很快掌握。

单用户模式（在第四章中讨论）为你提供了访问许多不同命令和工具的权限。然而，如果你破坏了这些工具怎么办？也许你甚至破坏了*/rescue*中的静态链接程序。这时，安装介质就派上用场了。

FreeBSD 安装镜像提供了一个激活 Live 系统的选项。这个 Live 系统包括了 FreeBSD 默认提供的所有程序。当你从安装介质启动时，你可以选择进入 Live CD，而不是进行安装。

使用 Live CD 你必须对系统管理有所了解。基本上，Live CD 为你提供了一个命令行提示符和各种 Unix 工具。你可以使用启动时的错误信息以及你脑海中的那部分“平衡物”来修复问题。这是你与计算机的较量。在我第一次使用 Live CD 或其前身时，计算机赢了三次。不过之后，我的成功率大大提高了。阅读本书以及其他 Unix 管理手册将提高你的成功几率。

为通用问题情境概括一个逐步的过程几乎是不可能的；你必须遵循的确切步骤取决于你对可怜的、无辜的操作系统造成的具体损害。不过，如果你真的很绝望，Live CD 可以让你在不重新安装的情况下有机会恢复。我曾经不小心破坏了*/etc* 目录，或者损坏了显示登录提示符的 getty(1) 程序。小心使用 Live CD 可以在重新安装所需的时间的一小部分内修复这些问题。如果什么都做不到，也许你可以备份任何幸存的数据，然后重新安装。

始终使用与你当前运行的 FreeBSD 版本大致相当的安装介质。你可能可以使用 12.2 安装 CD 来修复 12.1 系统，但 14-current 安装光盘可能会引发一系列新的问题。

现在你已经可以从几乎所有可能犯的错误中恢复过来了，我们可以深入 FreeBSD 的核心部分：内核。
