## 第二十章：小型系统服务**

![image](img/common01.jpg)

即使是角色定义非常狭窄的服务器，例如专用的 web 服务器，也需要多种小型“辅助”服务来处理基本的管理问题。在本章中，我们将讨论其中一些服务，例如时间同步、发送邮件、DHCP 服务、任务调度等等。我们将从使用 SSH 加固远程连接到 FreeBSD 服务器开始。

### 安全外壳

Unix 的一个伟大优势是它的远程管理的便捷性。无论服务器是在你面前，还是位于一个远程的、被围栏隔离的实验室，或者在一个地下的、最高安全级别的设施中，周围环绕着由一个名叫 Ivan 的自大鼬鼠训练的凶猛守卫犬，只要你能访问网络，就可以控制它。

多年来，telnet(1) 一直是访问远程服务器的标准方式。然而，作为远程管理协议，telnet 有一个致命的缺陷：大多数版本的 telnet 发送的数据是未加密的。任何在你的连接路途中放置数据包嗅探器的人，都可以窃取你的用户名、密码和你在 telnet 会话中查看的任何信息。当你使用 telnet 时，世界上最好的密码选择方案也无法保护你的用户名和密码。入侵者可以将非法的数据包嗅探器放置在任何他们能接触到的地方；我见过它们出现在小型局域网、全球企业网络、处理敏感政府工作的律师事务所、家庭电脑以及互联网骨干网络中。对抗数据包嗅探器的唯一防御手段是以一种嗅探器无法理解的方式处理你的认证凭据和数据。这就是 SSH（安全外壳）的作用所在。

SSH 的行为与 telnet 非常相似，因为它提供了一个高度可配置的终端窗口用于远程主机。但是与 telnet 不同，SSH 会加密你通过网络发送的所有内容。SSH 不仅确保你的密码不会被嗅探，还确保你输入的命令及其输出被加密。虽然 telnet 在某些方面对比 SSH 具有一些小的优势，例如需要更少的 CPU 时间和配置更简单，但 SSH 在安全性上的优势完全压倒了这些小优点。SSH 还具有 telnet 所不具备的许多功能，例如通过加密会话隧道传输任意协议。SSH 可以在所有现代的 Unix 变种上运行，甚至在微软的 Windows 上也能运行。

SSH 通过公钥加密技术加密和认证远程连接。SSH 守护进程提供服务器的公钥给客户端，并将私钥保留给自己。客户端和服务器使用加密密钥协商一个加密安全通道。由于公钥和私钥都在此交易中起作用，因此你的数据是安全的；即使有人捕获了你的 SSH 流量，他们也只能看到加密的垃圾数据。

要使用 SSH，必须在 FreeBSD 机器上运行 SSH 服务器，并在工作站上运行 SSH 客户端。

#### *SSH 服务器：sshd(8)*

sshd(8) 守护进程监听来自网络的 SSH 请求，端口为 TCP 22。要在启动时启用 sshd，请将以下行添加到 */etc/rc.conf*：

```
sshd_enable="YES"
```

设置完成后，你可以使用 */etc/rc.d/sshd* 脚本或 `service sshd` 子命令来启动和停止 SSH。停止 SSH 守护进程不会终止已经在使用的 SSH 会话；它只会阻止守护进程接受新的连接。

与我们查看的未加密协议不同，sshd 很难手动测试。你可以做的一件事是通过使用 nc(1) 连接到 SSH TCP 端口来确认 sshd 是否正在运行。

```
# nc localhost 22
SSH-2.0-OpenSSH_7.2 FreeBSD-20160310
```

我们连接到端口 22，并收到一个 SSH 横幅信息。我们可以看到监听该端口的守护进程将自己称为 SSH 版本 2，基于 OpenSSH 7.2 实现，运行在 FreeBSD 上，版本为 20160310。你可以通过一个简单的 nc(1) 连接获取这些信息，但这也是 sshd 提供的最后一条免费信息。除非你能够手动加密数据包，否则这就是你能做到的极限了。按 CTRL-C 离开 nc(1)，返回命令提示符。

#### *SSH 密钥和指纹*

第一次启动 sshd(8) 时，程序会意识到它没有加密密钥，并自动创建它们。初始化的 sshd 进程会创建三对密钥：一个 RSA 密钥，一个 ECDSA 密钥和一个 ED25519 密钥。

以 *.pub* 结尾的密钥文件包含每种类型的公钥。这些是 sshd 提供给连接客户端的密钥。这使得连接的用户能够验证他连接的服务器是否真的是他认为的那台服务器。（入侵者曾通过诱使用户登录虚假的机器来窃取他们的用户名和密码。）看看其中一个公钥文件；它非常长。即使用户被提供确认服务器提供的密钥是否正确的机会，由于密钥长度过长，即使是最警觉的用户也不会逐一验证每个字符。

幸运的是，SSH 允许你生成一个 *密钥指纹*，这是密钥的一个简短表示。你不能用指纹加密流量或协商连接，但两个不相关的密钥具有相同指纹的机会可以忽略不计。要为公钥生成指纹，输入命令 `ssh-keygen -lf` keyfile.pub。

```
# ssh-keygen -lf /etc/ssh/ssh_host_rsa_key.pub 
2048 SHA256:tEcBfgXctTfaaEF9d5QK3oYUwr5Tb/cuIr3MNxV4wwE root@bert (RSA)
```

第一个数字`2048`表示密钥的位数。2048 是 2018 年 RSA 密钥的标准，但随着计算能力的提高，我预计这个数字会增加。以`tEcB`开头，以`wwE`结尾的字符串是公钥的指纹。虽然它很长，但比实际的密钥短得多，也更易读。将这个密钥指纹从原始服务器复制到你可以从客户端机器访问的地方。如果需要人工验证指纹，可以尝试使用网页或纸质列表。如果你的 SSH 客户端支持 SSHFP 记录，并且你的 DNS 区域支持 DNSSEC，可以改为使用 DNS。在第一次连接时，使用此密钥确认你的服务器身份，或者使用其他密钥分发方法之一。

#### *配置 SSH 守护进程*

尽管 sshd 自带的配置文件已经可以正常使用，但一旦你了解了 sshd(8)提供的所有功能，你可能会想调整设置。配置文件*/etc/ssh/sshd_config*列出了所有默认设置，并用井号（`#`）注释掉。如果你想更改某个设置的值，只需取消注释并修改其值。

我们不会讨论所有可用的 sshd 选项；那样会需要一本相当大的书。此外，OpenSSH 的更新速度非常快，以至于那本书在出版之前就会过时。相反，我们将重点讨论一些人们常做的、更常见的配置更改。

更改 SSH 守护进程的配置后，使用`/etc/rc.d/sshd restart`或`service sshd restart`重启守护进程。

##### VersionAddendum FreeBSD-20170902

`VersionAddendum`会出现在你连接到 sshd 的 TCP 端口时的服务器名称中。有人建议更改它以掩盖操作系统版本。然而，通过使用指纹识别技术分析与主机交换的数据包，识别计算机的操作系统是非常简单的，因此通常不值得花时间做这件事。（另一方面，如果将`VersionAddendum`更改为`DrunkenBadgerSoftware`让你觉得好玩，那就继续吧。）

##### Port 22

sshd(8)默认监听 TCP 端口 22。如果你愿意，可以将其更改为非标准端口。如果你希望 sshd 监听多个端口（例如，除了端口 22 外，还监听端口 443），可以在不同的行上包含多个`Port`条目：

```
Port 22
Port 443
```

更改端口并不作为一种安全措施有用。它可能有助于减少日志的杂音。我坦白承认，我有一个小型 SSH 服务器，监听多个流行的 TCP 端口，专门用来绕过无用的网络安全设备。但这并不会使 SSH 变得更加*安全*。

##### ListenAddress 0.0.0.0

sshd 默认监听机器上的所有 IP 地址的传入请求。如果你需要限制监听的地址范围（例如，在一个监禁服务器上），可以在此处指定：

```
ListenAddress 203.0.113.8
```

如果你希望 sshd 监听多个地址，可以使用多个`ListenAddress`行。

##### SyslogFacility AUTH 和 LogLevel INFO

这两个设置控制 sshd(8) 如何记录连接信息。有关日志记录的更多信息，请参见 第二十一章。

##### LoginGraceTime 2m

该选项控制用户在连接后必须多长时间内完成登录。如果有用户连接但未在此时间窗口内成功登录，sshd 会断开连接。

##### PermitRootLogin no

不要让人们直接以 root 用户身份登录到你的服务器。相反，他们应该以普通用户身份通过 SSH 登录，并通过 su(1) 切换为 root 用户。允许直接的 root 登录会让你失去识别是谁错误配置了你的系统的机会，并且让入侵者更容易掩盖他们的痕迹。

##### MaxAuthTries 6

这是用户在单次连接过程中可以尝试输入密码的次数。超过这个次数后，用户将被断开连接。

##### AllowTcpForwarding yes

SSH 允许用户将任意的 TCP/IP 端口转发到远程系统。如果用户有 shell 访问权限，他们可以安装自己的端口转发器，因此没有理由禁用这个功能。

##### X11Forwarding yes

类 Unix 操作系统使用 X11（或 X）协议来显示图形化程序。在 X 中，显示与物理机器是分开的。你可以在一台机器上运行，比如说一个网页浏览器，并将结果显示在另一台机器上。

由于 X 在安全性方面有过波折，许多管理员下意识地禁用 X 转发。然而，禁用 SSH 的 X 转发并不意味着完全禁用 X 转发。大多数用户如果无法通过 SSH 转发 X，就会使用 X 自带的网络功能或第三方转发工具，在未加密的 TCP/IP 上转发 X，这通常比允许通过 SSH 转发 X 更糟。如果你的 sshd 服务器已安装 X 库和客户端程序，用户可以通过某种方式转发 X；最好让 SSH 来处理转发。如果没有安装 X 软件，那么 `X11Forwarding` 将无效。

##### Banner /some/path

横幅是认证发生前显示的消息。这个选项最常用的场景是显示法律警告。默认情况下不使用横幅。

##### Subsystem sftp /usr/libexec/sftp-server

SSH 允许你通过 scp(1) 安全地将文件从一台系统复制到另一台系统。尽管 scp 工作得很好，但它的用户友好性差。sftp 服务器提供了类似 FTP 的文件传输接口，减少了你在用户教育上的时间，同时仍保持了坚实的安全性。

#### *管理 SSH 用户访问*

默认情况下，任何拥有合法 shell 的用户都可以登录到服务器。通过使用配置变量 `AllowGroups`、`DenyGroups`、`AllowUsers` 和 `DenyUsers`，sshd(8) 允许你定义哪些用户和组可以或不可以访问你的机器。

当你明确列出可以通过 SSH 登录机器的用户时，任何未列出的用户都无法通过 SSH 登录。

例如，`AllowGroups` 选项允许你限制只有在指定组中的用户才能访问 SSH，这些组在 */etc/group* 中定义（见 第九章）。如果设置了此选项，并且用户不属于任何允许的组，他将无法登录。多个组之间用空格分隔：

```
AllowGroups wheel webmaster dnsadmin
```

如果你不想给整个组提供 SSH 访问权限，可以使用 `AllowUsers` 列出单个用户。通过使用 `AllowUsers`，你禁止了除了列出的用户之外的所有人访问 SSH。

`DenyGroups` 列表与 `AllowGroups` 相反。指定的系统组中的用户无法登录。列出的组必须是他们的主组，这意味着它必须列在 */etc/master.passwd* 中，而不仅仅是 */etc/group* 中。这个限制使得 `DenyGroups` 没有看起来那么有用；除非你将它设置为用户的主组，否则无法定义一个叫做 *nossh* 的通用组并将用户添加进去。显式列出允许的组是一个更有用的策略。

最后，`DenyUsers` 变量列出了不允许登录的用户。你可以使用它显式禁止那些虽然属于允许组但被列为禁止的特定用户。

这四个不同的设置使得一个用户可以同时属于多个组。例如，一个用户可能同时属于 `AllowGroups` 列出的组和 `DenyGroups` 列出的组。那么该怎么办呢？SSH 守护进程按以下顺序检查这些值：`DenyUsers`、`AllowUsers`、`DenyGroups` 和 `AllowGroups`。第一个匹配的规则生效。例如，假设 Bert 是 wheel 组的成员。这里是 *sshd_config* 的一部分：

```
DenyUsers: bert
AllowGroups: wheel
```

Bert 无法通过 SSH 登录这台机器，因为 `DenyUsers` 在 `AllowGroups` 之前进行检查。

#### *SSH 客户端*

当然，FreeBSD 自带 SSH 客户端，像大多数类 Unix 操作系统一样。如果可能，使用包含的 SSH 客户端——它是 OpenSSH 的一部分，由 OpenBSD 团队的一个子集开发，不仅是最流行的实现，而且是最好的。如果你被迫使用微软的操作系统，我推荐 PuTTY，它对商业或非商业用途都是免费的，并且有出色的终端仿真。微软正在将 OpenSSH 的一个分支集成到 Windows 中，但在我写这篇文章时，它仍处于测试版。

这是一本 FreeBSD 的书，所以我们将重点介绍 FreeBSD 的 OpenSSH 客户端。你可以通过多种方式配置客户端，但最常见的配置选项仅仅是禁用服务器提供的功能。如果你真的有兴趣调整客户端的行为，阅读 ssh_config(5)。

要连接到另一台主机进行 SSH 登录，输入 `ssh` 主机名。你将看到类似这样的响应：

```
# ssh mwl.io
The authenticity of host 'mwl.io (203.0.113.221)' can't be established.
ECDSA key fingerprint is SHA256:ZxOWglg4oqcZKHOLv5tfqPlAwDW6UGVbiTvjfAjMc4E.
No matching host key fingerprint found in DNS. 
Are you sure you want to continue connecting (yes/no)? yes
```

您的客户端会立即从您连接的主机获取公钥，并检查其内部 SSH 密钥列表中是否存在与该主机匹配的密钥。如果服务器提供的密钥与客户端列表中的密钥匹配，客户端就会认为您连接到了正确的主机。如果客户端在其已知主机列表中没有该主机的密钥，它将呈现密钥指纹供您确认。

SSH 客户端提供的指纹应与您在服务器上生成的指纹完全相同。如果指纹不相同，则说明您连接到了错误的主机，需要立即断开连接。如果指纹匹配，则接受该密钥并继续。一旦您接受了指纹，密钥将保存在您的主目录下的*.ssh/known_hosts*中。

如果您正在为个人使用在本地网络上搭建新服务器，也许您不需要手动比较密钥指纹。不过，您仍然应该复制密钥指纹，因为您最终会希望从远程位置连接，并且需要验证密钥。如果许多人将连接到该服务器，通常可以将指纹放在网页上。您必须决定需要多少安全性。我强烈建议您在安全性上采取谨慎态度。

接受主机密钥，您将被允许登录服务器。虽然使用带有密码短语的私钥比使用密码更好，但在 SSH 中使用密码仍然比使用 telnet 更安全。

##### 通过 SSH 复制文件

SSH 客户端适用于命令行访问，但如果要将文件从一个系统移动到另一个系统呢？SSH 包含两个用于通过网络移动文件的工具：scp(1) 和 sftp(1)。

scp(1) 是“安全复制”，非常适合移动单个文件。scp 需要两个参数：第一个是文件的当前所在位置；第二个是目标位置。目标位置的格式为 *<用户名>@<主机名>:<文件名>*。假设我想将本地系统上的文件 *bookbackup.tgz* 复制到远程服务器 *mwl.io*，并为远程副本指定不同的名称。我会运行：

```
# scp bookbackup.tgz mwlucas@mwl.io:bookbackup-january.tgz
```

如果您想让新复制的文件保持相同的名称，可以省略第二个参数中的文件名：

```
# scp bookbackup.tgz mwlucas@mwl.io:
```

scp(1) 还允许您将文件从远程系统复制到本地系统：

```
# scp mwlucas@mwl.io:bookbackup-january.tgz bookbackup.tgz
```

如果您不想更改本地系统上的文件名，您可以使用一个点作为目标名称：

```
# scp mwlucas@mwl.io:bookbackup.tgz .
```

最后，如果您在远程系统上的用户名与本地用户名相同，您可以删除用户名和 `@` 符号。例如，要备份我的工作，我只需使用：

```
# scp bookbackup.tgz mwl.io:
```

尽管看起来有些复杂，但它对于快速在网络上移动单个文件非常有用。

如果您喜欢交互式系统，或者如果您不确定想从远程服务器抓取的文件的准确名称，那么 sftp(1) 是您的朋友。sftp(1) 需要一个参数，使用 scp 的语法来指定远程服务器的用户名和服务器名：

```
# sftp mwlucas@mwl.io
Connecting to bewilderbeast...
Password:
sftp> ls
```

sftp(1)客户端看起来非常像标准的命令行 FTP 客户端；它支持常见的 FTP 命令，如`ls`（列出）、`cd`（更改目录）、`get`（下载文件）和`put`（上传文件）。一个重要的区别是，sftp(1)不需要在 ASCII 和二进制传输之间做出选择；它只是按原样传输文件。

使用 SSH、scp 和 sftp，你可以完全消除网络中的明文密码。

**OPENSSH 密码和密钥**

要真正保护你的系统，请使用基于密钥的 SSH 认证。创建密钥并不困难，但以最适合你的环境的方式部署它们，比我在这里能讲的要复杂得多。消除 SSH 密码是你可以在网络中做出的最重要的安全改进。

虽然 SSH 是最常见的系统管理员工具，但我们只触及了它的表面。你花时间精通 SSH，将会得到多倍的回报。你可以在网上找到一些很好的教程和几本不错的书籍，包括我自己的*SSH Mastery*（Tilted Windmill Press，2018）。

### 电子邮件

近年来，运行邮件服务器变得异常复杂。应对垃圾邮件、病毒以及随机的无用信息需要专门的技能，并且这些垃圾信息的数量每年都在激增。在你部署邮件服务器之前请仔细考虑。然而，每个主机都需要某种形式的邮件客户端。FreeBSD 包含两个可以用于管理本地邮件并将邮件转发到邮件服务器的软件套件：Sendmail 和 Dragonfly Mail Agent。

*Sendmail* 是邮件程序的鼻祖。它可以是服务器、客户端、过滤器，也可以是任意的邮件处理程序。如果你想与那些隔绝在外、仅通过拨号线路的 UUCP 每天交换一次邮件的网站进行通信，同时也与最新的商业邮件服务器交换邮件，Sendmail 是一个可靠的选择。然而对于大多数人来说，这个被称为电子邮件的瑞士军刀过于复杂。

*Dragonfly Mail Agent (DMA)* 来自 Dragonfly BSD。它是一个非常简洁的邮件客户端，可以在本地主机上发送邮件，或将邮件转发到邮件服务器。它正是你需要的那种工具，用来将每日状态邮件转发给负责读取这些邮件的下属，将你的应用程序的报告发送给应用管理员，并转发所有那些让你 WordPress 安全插件希望你阅读的烦人报告。

我们将花一些时间了解 DMA。然而，在此之前，让我们先谈谈 FreeBSD 如何应对全球各种各样的邮件服务器。

#### *mailwrapper(8)*

几十年来，Sendmail 是类 Unix 系统中唯一可用的邮件服务器。因此，大量软件都期望每个服务器都有 */usr/sbin/sendmail*，并且期望它的行为与 Sendmail 完全相同。更糟糕的是，当通过不同名称调用时，Sendmail 的行为会有所不同。程序 mailq(1) 是 sendmail(8) 的硬链接，但由于它的名称不同，因此行为也不同。newaliases(1)、send-mail(8)、hoststat(8) 和 purgestat(8) 也是如此。^(1)

由于客户端期望找到 Sendmail，任何替代的邮件服务器必须精确模拟 Sendmail，包括这种多重名称行为。使用不同的邮件服务器并不像删除 Sendmail 二进制文件并替换为其他东西那么简单。但人们总是试图这么做。

因此，探索不熟悉的 Unix 系统的系统管理员可能完全不知道 */usr/sbin/sendmail* 真实是什么！如果有人曾经安装过多个不同的邮件服务器，试图找到比 Sendmail 更易用的替代品，那么你就得通过侦探工作和坚持不懈的努力来识别所谓的 sendmail(8)。

FreeBSD 通过使用一个独立的 mailwrapper(8) 程序绕过了所有这些混乱。邮件包装器将对 Sendmail 的请求引导到首选的邮件服务器，邮件服务器安装在其他地方。

在 */etc/mail/mailer.conf* 中配置 mailwrapper(8)。这个文件包含了程序名称的列表，以及实际程序的路径。以下是默认的 *mailer.conf*，它将所有请求指向老旧的 sendmail(8)：

```
sendmail        /usr/libexec/sendmail/sendmail
send-mail       /usr/libexec/sendmail/sendmail
mailq           /usr/libexec/sendmail/sendmail
newaliases      /usr/libexec/sendmail/sendmail
hoststat        /usr/libexec/sendmail/sendmail
purgestat       /usr/libexec/sendmail/sendmail
```

左栏中的这六个“程序”名称是其他程序可能用来指代 Sendmail 的名称。右栏给出了应该调用的程序路径。在这里，我们看到 Sendmail 安装在 */usr/libexec/sendmail/sendmail* 路径下。如果你使用的是替代邮件服务器，必须编辑 *mailer.conf* 来指向正确的邮件程序路径。大多数替代邮件服务器为每个功能使用单独的程序，因为自 Sendmail 出现以来，磁盘空间的成本已经大幅下降。当你从软件包或端口安装替代邮件服务器时，安装后的消息通常会提供如何更新 *mailer.conf* 的具体说明。如果你希望新邮件服务器正常工作，请按照这些说明操作。如果你没有使用软件包而是安装了不同的邮件服务器，你需要自己编辑 *mailer.conf*。

#### *Dragonfly Mail Agent*

Dragonfly Mail Agent (DMA) 可以本地投递邮件并将邮件发送到另一台服务器，但它无法通过网络接收邮件。大多数邮件服务器会绑定到本地主机的 TCP 端口 25，而 dma(8) 则不会。它只为那些可以调用 */usr/sbin/sendmail* 或其对等程序的程序投递邮件。

在启用 DMA 之前，需在 */etc/dma/dma.conf* 中进行配置。这个文件包含了一些变量，你可以取消注释并设置为特定值。虽然 DMA 有多个可配置的设置，但你应该保持大多数设置为默认值。

##### 智能主机

智能主机是实际的邮件服务器，是客户端应该通过其转发邮件的主机。使用主机名或 IP 地址。

```
SMARTHOST=mail.mwl.io
```

##### TCP 端口

如果你的邮件管理员是个疯狂的人，给智能主机的邮件设置了非标准端口，或者你正在尝试绕过 ISP 封锁的 25 端口，可以在此设置 TCP 端口：

```
PORT 2025
```

如果你没有设置智能主机但设置了端口，邮件投递将会中断。

##### 虚假主机名和用户名

你可能希望服务器在发送邮件时自称为另一个主机。也许你的云服务提供商给这个系统分配了一个由随机数字和字母组成的主机名，但你希望它以*www.example.com*发送邮件。使用 MAILNAME 来设置一个假主机名。

```
MAILNAME www.mwl.io
```

如果你为 MAILNAME 提供了文件的完整路径，dma(8)将使用该文件的第一行作为主机名。

一些邮件服务器会非常严格地检查转发的邮件，并拒绝不充分伪造的消息。对于这些主机，你需要使用 MASQUERADE 选项。伪装提供了几种更改邮件的方式。如果你使用完整的电子邮件地址，所有通过 dma(8)发送的邮件都会被重写，使其看起来来自该地址。如果你使用带有@符号的用户名，例如`bert@`，所有邮件看起来都来自该主机上的该用户。仅使用主机名将保留发送者的用户名不变，但会更改主机名。

```
MASQUERADE bert@mwl.io
```

从这个主机发送的任何邮件看起来都是 Bert 发送的，所有的回复也会发给他。一切都按预期进行。

##### 禁用本地投递

一些主机不应该接收邮件。该主机上的任何账户都不应接收邮件，甚至是来自其他本地账户的邮件。通过取消注释 NULLCLIENT 选项完全禁用本地邮件投递。

##### 安全传输

在过去的几十年里，电子邮件协议加入了许多不同的安全措施。你的邮件服务器可能会使用其中的某些或全部措施。请与邮件管理员沟通，了解你的智能主机需要和支持哪些安全措施。

通过取消注释 SECURETRANSFER 选项启用 TLS（如果你的邮件服务器特别糟糕，也可以使用 SSL）。你不需要设置该值，单纯的存在即可启用 TLS。如果你的邮件服务器需要 STARTTLS，也需要取消注释该选项。如果你希望即使 TLS 协商失败也能发送邮件，还需要取消注释 OPPORTUNISTIC_TLS。

这三个选项都需要前面的选项。你可以单独使用 SECURETRANSFER，或者同时使用 STARTTLS 和 SECURETRANSFER，或者全部使用。没有前导选项的 STARTTLS 和 SECURETRANSFER 无法正常工作。

如果你需要本地 TLS 证书，可以通过 CERTFILE 选项进行设置。

```
CERTFILE /etc/ssl/host.crt
```

这些选项应该让你能够连接到几乎任何智能主机。

##### 用户名和密码

一些智能主机要求客户端使用用户名和密码进行身份验证。将身份验证凭据放入文件*/etc/dma/auth.conf*中。每个条目需要以下格式：

```
user|host:password
```

假设我的智能主机是*mail.mwl.io*。用户名是*www1*，密码是*BatteryHorseStapleCorrect*。我的*auth.conf*文件将包含：

```
www1|mail.mwl.io:BatteryHorseStapleCorrect
```

DMA 将使用这个来登录到你的主机。

如果你想通过未加密的连接使用用户名和密码，你必须设置 INSECURE 变量。通过网络发送未加密的身份验证信息是个不好的主意，但许多邮件服务器充满了不好的主意。

##### 启用 DMA

使用 DMA 需要关闭任何现有的 Sendmail 进程，并在 *mailer.conf* 中启用 dma(8)。

即使 Sendmail 仅处理本地投递，它仍作为一个守护进程运行。使用 service(8) 或 */etc/rc.d/sendmail* 脚本关闭 Sendmail。

```
# service sendmail stop
```

确保它永远不会再次启动。

```
# sysrc sendmail_enable=NONE
```

现在，前往 */etc/mail/mailer.conf* 并将每个邮件程序指向 dma(8)。

```
sendmail        /usr/libexec/dma
send-mail       /usr/libexec/dma
mailq           /usr/libexec/dma
newaliases      /usr/libexec/dma
rmail           /usr/libexec/dma
```

DMA 没有持久的守护进程，因此不需要启动脚本。

恭喜，现在你拥有一个小型、简单且有效的客户端邮件代理。

#### *别名文件和 DMA*

*/etc/mail/aliases* 文件包含发送到特定账户或用户名的电子邮件的重定向。即使是像 DMA 这样的邮件客户端和邮件代理也使用别名文件。向别名文件添加条目是本地重定向邮件的好方法。

虽然别名文件具有许多功能，但 DMA 仅能使用其中的一部分。像将邮件重定向到任意文件这样的功能是不可用的。我们将讨论其基本功能。

打开别名文件并查看。每一行都以别名名称或地址开始，后面跟着冒号和一个真实用户列表，用于接收邮件。我们将通过示例来说明别名是如何工作的。

##### 将邮件从一个用户转发到另一个用户

应该总有人读取发送到 root 账户的邮件。与其让某个人登录每一台服务器去读取这些信息，不如将所有 root 的邮件转发到另一个邮件地址。

```
root: bert@mwl.io
```

我已将 Bert 指派为读取所有机器上所有邮件的工作。^(2)

许多电子邮件地址没有与之关联的账户。例如，通常要求的 postmaster 地址并没有账户。你可以使用别名将其转发到一个真实账户。

```
postmaster: root
```

所以，postmaster 转发到 root，然后转发到 Bert。Bert 获取这两个地址的所有邮件。

默认的别名文件包含各种标准地址，用于互联网服务，以及所有默认 FreeBSD 服务账户的别名。默认情况下，它们都指向 root。通过为 root 邮件定义一个真实地址作为目标，你将自动接收到所有系统管理邮件。

##### 别名邮件列表

你可以列出多个用户来创建小型邮件列表。对于动态列表来说，这并不适用，但对于快速和简便的列表来说足够了。

```
escalate: mwlucas@mwl.io, bert@mwl.io, helpdesk@mwl.io
```

一旦你发现自己正在创建一个别名邮件列表，那就是你需要开始考虑要部署哪个邮件列表解决方案的时候。你会比你想象的更早需要它。

### 网络时间

如果一个数据库开始录入比实际时间滞后三小时的日期，或者如果电子邮件的日期显示是明天，你很快就会听到相关反馈。时间是*重要的*。^(3) 你有两个工具来管理系统时间：tzsetup(8) 来控制时区，ntpd(8) 来调整时钟。首先手动设置你的时区，然后使用网络时间协议。

#### *设置时区*

使用 tzsetup(8) 管理时区非常简单，它是一个菜单驱动的程序，可以为每个时区在系统上做出相应的更改。全球性组织可能在他们的系统上使用 UTC（协调世界时，之前称为格林尼治标准时间，当前称为协调世界时，很快将改名为另一种名称），而其他组织则使用他们自己的本地时间。输入 `tzsetup`，按照地理提示操作，选择适合你所在位置的时区。如果你知道你时区的官方名称，可以直接在命令行中设置，而无需经过提示。

```
# tzsetup America/Detroit
```

tzsetup(8) 程序将相关的时区文件从 */usr/share/zoneinfo* 复制到 */etc/localtime*。这是一个二进制文件，你不能使用普通的文本编辑器进行编辑。如果你的时区特性发生变化——例如夏令时开始的日期改变——你必须升级 FreeBSD 来获取新的时区文件，然后重新运行 tzsetup(8) 来正确地重新配置时间。

用户可以使用 `TZ` 环境变量来设置个人时区。

#### *网络时间协议*

*网络时间协议 (NTP)* 是一种在网络中同步时间的方法。你可以让本地计算机的时钟与政府研究实验室的原子钟或主服务器的时间保持一致。提供时间同步的计算机被称为 *时间服务器*，大致分为两组：Tier 1 和 Tier 2。

Tier 1 NTP 服务器直接连接到高精度的时间保持设备。如果你真的需要这种精度，那么你真正需要的是你自己的原子钟。像在廉价 GPS 上找到的 USB 无线电钟看起来可能很不错，但 USB 证明不是传输时间数据的理想介质。去查看一个专用的非 USB GPS 接收器的价格，然后选择一个 Tier 1 NTP 服务器。

Tier 2 NTP 服务器从 Tier 1 NTP 服务器获取时间，提供作为公共服务的时间服务。它们的服务精度达到毫秒级，对于几乎所有非生命支持应用都足够了。进一步的调查甚至会让你找到 Tier 3 时间服务器，它们从 Tier 2 服务器获取时间。

最好的时间服务器来源是 *[`www.pool.ntp.org/`](http://www.pool.ntp.org/)* 上的列表。这个组织将公共 NTP 服务器收集成循环 DNS 池，方便进行 NTP 配置。NTP 服务器首先按全球列表排列，然后按大陆排序，再按国家排列。例如，如果你在加拿大，简单搜索该站点会找到 *0.ca.pool.ntp.org*、*1.ca.pool.ntp.org* 和 *2.ca.pool.ntp.org*。我们在以下示例中将使用这些服务器，但在设置您自己的时间服务时，请查找适合您国家的服务器并使用它们。

##### 配置 ntpd(8)

ntpd(8) 会将系统时钟与一组时间服务器进行对比。它取这些时间服务器提供的时间的合理平均值，舍弃任何与共识相差过远的服务器，并逐渐调整系统时间以匹配平均值。这提供了最精确的系统时间，而不会对任何一个服务器要求过多，并帮助保持错误硬件的检查。NTP 配置文件在 */etc/ntpd.conf* 中。以下是一个使用加拿大时间服务器的示例：

```
server 1.ca.pool.ntp.org
server 2.ca.pool.ntp.org
server 3.ca.pool.ntp.org
```

该系统检查三个时间服务器的更新时间。如果只列出一个服务器，ntpd(8) 会将其时钟与该服务器同步，并共享该服务器遇到的任何时间问题。使用两个时间服务器会导致系统无法正确判断时间；请记住，NTP 会取时间服务器的平均值，但会丢弃任何与其他服务器的时间差异过大的值。当只有两个值时，NTP 如何判断一个服务器是否错误？使用三个时间服务器是最优的；如果其中一个服务器出现问题，ntpd 会发现该服务器提供的时间与另外两个服务器提供的时间不一致。（可以把它看作是“多数人的暴政”；唯一与其他人意见不同的人根本没有发言权。）

##### ntpd(8) 在启动时

要让 ntpd 在启动时执行一次性时钟同步，然后持续调整时钟，请在 */etc/rc.conf* 中设置以下内容：

```
ntpd_enable="YES"
ntpd_sync_on_start="YES"
```

Ntpd 在启动时会立即强制校正时间，然后轻柔地保持时钟同步。

##### 即时时间校正

ntpd(8) 非常擅长长期保持系统时钟的准确性，但它只会逐渐调整本地时钟。如果您的时间差错达到小时或天数（例如安装时或长时间断电后发生的情况），您可能希望在启动任何时间敏感的应用程序之前，先正确设置时钟。ntpd(8) 也包含此功能，可以使用 `ntpd -q` 来实现。

要对时钟执行一次强制校正，请使用`ntpd -q`。这会连接到您的 NTP 服务器，获取正确的时间，设置系统时钟，并退出。

```
# ntpd -q
ntpd: time set -76.976809s
```

系统的时间大约落后了 77 秒，但现在已与 NTP 服务器同步。

不要在生产系统中随意更改时钟。许多数据库驱动的应用程序等时间敏感型软件，如果时间突然向前或向后移动，会遇到问题。

如果你有非常好的硬件并且配备了优质的振荡器，使用`ntpd -q`在启动时可以解决所有时间问题。然而，实际上很少有人拥有这种硬件。我们大多数人都得忍受廉价硬件，后者通常有着极差的时钟。确保时间准确的最佳方式是运行 ntpd(8)，以持续轻微调整时钟。

##### 时间重新分配

虽然 ntpd 不会使用大量网络带宽，但让你网络中的每个服务器查询公共 NTP 服务器是浪费网络资源——既是你自己的资源，也是时间服务器捐赠者的资源。这还可能导致你自己网络中的时间出现非常微小（亚秒级）的波动。

可靠的时间服务器不是虚拟机。Tier 1 NTP 服务器都运行在真实硬件上，专门避免虚拟机可能遇到的时钟抖动问题。

我建议为你的网络设置三个权威的时间服务器。让这些服务器与全球 NTP 池同步它们的时钟。配置你网络中的每个服务器指向这些服务器进行 NTP 更新。这样，你网络中的每个时钟都会完美同步。你无需翻遍 NTP 日志，试图判断全球时间服务器池中的某个特定服务器是否以某种方式破坏了你的系统时钟。最好通过网络边界的防火墙规则强制执行这一策略；只允许你的时间服务器与外部 NTP 服务器通信，这样可以消除一个常见的时间混乱源。

### 名称服务切换

任何类 Unix 系统都会进行无数次对不同名称服务的检查。我们已经讨论过将主机名映射到 IP 地址的域名系统（请参见第七章），但还有密码条目查找服务、TCP/IP 端口号和名称查找服务、IP 协议名称和编号查找服务等。你可以使用*/etc/nsswitch.conf*来配置你的 FreeBSD 系统如何进行这些查询以及它通过 nsswitch（名称服务切换）使用哪些信息来源。

每个名称服务都有一个*nsswitch.conf*条目，包含该服务的类型以及它所使用的信息来源。我们之前在第八章中看到过一个名称服务切换的示例。记得这个主机查找的条目吗？

```
hosts: files dns
```

这意味着，“首先在本地文件中查找 IP 地址，然后查询 DNS。”其他信息来源也类似工作。像大多数其他类 Unix 操作系统一样，FreeBSD 支持表 20-1 中列出的信息来源的名称服务切换。

**表 20-1：** 支持名称服务切换的查找

| **查找** | **功能** |
| --- | --- |
| `groups` | 用户组成员资格检查（*/etc/group*） |
| `hosts` | 主机名和 IP 检查（DNS 和*/etc/hosts*） |
| `networks` | 网络条目（*/etc/networks*） |
| `passwd` | 密码条目（*/etc/passwd*） |
| `shells` | 有效 Shell 的检查（*/etc/shells*） |
| `services` | TCP 和 UDP 服务 (*/etc/services*) |
| `rpc` | 远程过程调用 (*/etc/rpc*) |
| `proto` | TCP/IP 网络协议 (*/etc/protocols*) |

大多数情况下，你不希望去修改这些，除非你喜欢破坏系统功能。例如，如果你有一个 Kerberos 或 NIS 域，你可能希望将你的 FreeBSD 机器连接到它们，以获取用户和组信息——但如果没有，重新配置密码查找会让系统运行得很慢，甚至在最坏的情况下完全无法工作！

对于每个名称服务，你必须指定一个或多个信息来源。许多名称服务非常简单，默认只有一个权威信息来源——一个文件。其他服务，如主机的名称服务，则更为复杂，有多个来源。一些服务非常复杂，仅仅是因为可用的信息种类繁多，并且获取这些信息的方式多种多样。由于本书没有涉及 Kerberos、NIS 或其他企业级用户管理系统，因此我们不会讨论更改密码、组和 shell 信息来源。如果你在这样的环境中，阅读 nsswitch.conf(5) 获取详细信息。

最常见的服务有特定的有效信息来源。*文件*是包含服务信息的标准文本文件。例如，网络协议通常存储在*/etc/protocols*，网络服务存储在*/etc/services*，密码存储在*/etc/passwd*及其相关文件中。*dns*来源意味着信息可通过 DNS 服务器获取，这对于负责将主机名映射到 IP 地址的主机服务来说是典型的。密码服务通常使用*compat*，它与*/etc/passwd*和 NIS 兼容，但也可以使用*files*。你可能会将信息源添加到系统中——例如，启用 LDAP 身份验证会添加*ldap*信息源。

按照你希望它们被尝试的顺序列出每个所需的信息来源。我们的 `hosts` 条目告诉名称服务查找首先尝试本地文件，然后查询 DNS 服务器。

```
hosts: files dns
```

如果你部署了像 LDAP 这样的集中身份验证方案，你需要添加适当的条目，告诉主机从 LDAP 查找密码和组。关键问题是，主机应该先使用本地密码文件，然后再回退到 LDAP，还是从 LDAP 开始，再回退到密码文件？

```
passwd: ldap files
```

在这里，我们首先使用 LDAP，但如果 LDAP 不可用，则回退到密码文件。

### inetd

inetd(8) 守护进程处理不常用网络服务的传入网络连接。大多数系统没有持续不断的 FTP 请求流量，那么为什么要让 FTP 守护进程一直运行呢？相反，inetd 监听网络上的传入 FTP 请求。当 FTP 请求到达时，inetd(8) 启动 FTP 服务器并交接请求。其他依赖 inetd 的常见程序有 telnet、tftp 和 POP3。

Inetd 还处理一些非常小且不常用的功能，这些功能实现起来比通过独立程序更容易。包括 discard（将接收到的任何数据丢弃到黑洞 */dev/null*）、chargen（输出一串字符）以及其他功能。现在，这些服务大多不仅不再需要，反而被认为是有害的。例如，chargen 服务主要用于拒绝服务攻击。

**INETD 安全性**

一些系统管理员将 inetd 看作是一个具有单一安全配置文件的服务，另一些则认为 inetd 有不好的安全历史。两者都不完全正确。inetd 服务器本身是相当安全的，但它要为转发请求到的程序承担一定的责任。一些 inetd 支持的服务，比如 ftp、telnet 等，本身就不安全，而其他一些则有过不良的历史并因此出现问题（例如 popper）。像对待任何其他网络服务器程序一样对待 inetd：除非需要，否则不要运行 inetd，并确认它仅提供受信任且安全的程序！

#### */etc/inetd.conf*

看一下 */etc/inetd.conf*。大多数守护进程有独立的 IPv4 和 IPv6 配置，但如果你没有运行 IPv6，可以忽略 IPv6 条目。我们来看一个条目——FTP 服务器的配置。

```
➊ftp    ➋stream     ➌tcp     ➍nowait     ➎root      ➏/usr/libexec/ftpd     ➐ftpd -l
```

第一个字段是服务名称 ➊，必须与 */etc/services* 中的名称匹配。inetd 会执行服务名称查找，以确定它应该监听哪个 TCP 端口。如果你想改变 FTP 服务器运行的 TCP/IP 端口，可以在 */etc/services* 中更改 FTP 的端口。（你也可以将第一个字段改为匹配所需端口上运行的服务，但我发现这样会让条目稍微有些混乱。）

套接字类型 ➋ 决定了这是什么类型的连接。所有的 TCP 连接都是 `stream` 类型，而 UDP 连接是 `dgram` 类型。虽然你可能会发现其他可能的值，但如果你正在考虑使用它们，要么是你在阅读一个告诉你应该使用什么的文档，要么就是你理解错了。

协议 ➌ 是第 4 层网络协议，可以是 `tcp`（IPv4 TCP）、`udp`（IPv4 UDP）、`tcp6`（IPv6 TCP）或 `udp6`（IPv6 UDP）。如果你的服务器同时接受 IPv4 和 IPv6 连接，可以使用 `tcp46` 或 `udp46`。

下一个字段指示 inetd 是否应该等待服务器程序关闭连接，还是只启动程序然后退出 ➍。一般来说，TCP 守护进程使用`nowait`，而 UDP 守护进程需要`wait`。（虽然有一些例外，但它们很少见。）inetd(8)会为每个传入请求启动一个新的网络守护进程。如果服务使用`nowait`，你可以通过在`nowait`后面直接添加斜杠和数字（例如：`nowait/5`）来控制 inetd 每秒接受的最大连接数。一种入侵者（通常是脚本小子）尝试将服务器从互联网上击倒的方式是为某个服务打开比服务器能够处理的更多的请求。通过限制传入连接的速率，你可以阻止这种情况。另一方面，这意味着你的入侵者可以完全阻止其他人使用该服务。小心选择你的“毒药”！

接下来是服务器守护进程运行的用户 ➎。FTP 服务器 ftpd(8)以 root 身份运行，因为它必须为多个系统用户提供服务，但其他服务器则以专用用户身份运行。

第六个字段是连接请求到达时，inetd 运行的服务器程序的完整路径 ➏。与 inetd(8)集成的服务作为内部服务出现。

最后一个字段给出了启动外部程序的命令，包括任何所需的命令行参数 ➐。

#### *配置 inetd 服务器*

虽然*/etc/inetd.conf*似乎使用了很多信息，但添加一个程序实际上是相当简单的。了解 inetd(8)的最简单方法是实现一个简单的服务。例如，我们来实现一个每日名言（qotd）服务。当你连接到 qotd 端口时，服务器会返回一个随机名言并断开连接。FreeBSD 在其游戏集合中包含了一个随机名言生成器 fortune(1)。这个随机名言生成器就是我们实现基于 inetd 的网络程序所需要的全部内容。我们必须指定端口号、网络协议、用户、路径和命令行。

##### 端口号

*/etc/services*文件将 qotd 列在 17 端口。

##### 网络协议

qotd 服务要求你连接到网络端口并获取回应，因此它需要通过 TCP 运行。记住，UDP 是无连接的——不需要回复。我们必须在 inetd 配置中指定`tcp`，这意味着我们必须在第四个字段中指定`nowait`。

##### 用户

最佳实践建议创建一个没有特权的用户来运行 qotd 服务，如第十九章中讨论的那样。对于这个例子，我们将使用一般的无特权用户 nobody，但如果你在生产环境中实现这一点，你应该创建一个无特权用户 qotd。

##### 路径

在*/usr/bin/fortune*中找到 fortune。

##### 运行命令

fortune(6) 不需要任何命令行参数，但如果你愿意，可以添加它们。^(4) 在 FreeBSD 11 上，信奉墨菲定律的人可以使用 `fortune murphy`，而 *星际迷航* 的粉丝可以通过 `fortune startrek` 获取引用。（后者正确地只包括唯一的 *星际迷航*，而不包括任何跟风的续集。）那些对教育感兴趣的人可以使用 `fortune freebsd-tips`。遗憾的是，FreeBSD 12 删除了许多 fortune 数据库。

##### inetd.conf 配置示例

将这些内容结合起来，qotd 在 */etc/inetd.conf* 中的条目如下所示：

```
qotd    stream    tcp    nowait    nobody    /usr/bin/fortune    fortune
```

你可能觉得这个例子很简单，但通过 inetd(8) 提供其他服务并不更加困难。

#### *启动 inetd(8)*

首先，通过将以下条目添加到 */etc/rc.conf* 中来在启动时启用 inetd(8)：

```
inetd_enable=YES
```

设置完毕后，手动启动 inetd，命令为 `/etc/rc.d/inetd start`。现在 inetd 已经在运行，使用 telnet 连接到 17 端口来测试我们的新服务：

```
   # telnet localhost 17
➊ Trying 127.0.0.1...
   Connected to localhost.
   Escape character is '^]'.
➋ It is difficult to produce a television documentary that is both
   incisive and probing when every twelve minutes one is interrupted by
   twelve dancing rabbits singing about toilet paper.
                   -- Rod Serling
   Connection closed by foreign host.
```

它工作了！我们得到了常见的 TCP/IP 连接信息 ➊ 和我们的随机格言 ➋。（额外的奖励是，你也知道为什么我不为电视写作。）

#### *更改 inetd 的行为*

inetd 根据你设置的标志表现不同。默认标志启用 TCP 包装器，按照 */etc/hosts.allow* 中的配置（见 第十九章）。表 20-2 列出了一些有用的标志。

**表 20-2:** inetd(8) 标志

| **标志** | **描述** |
| --- | --- |
| `-l` | 记录每个成功的连接。 |
| `-c` | 设置每秒钟最多可以连接到任何服务的次数。默认情况下没有限制。注意，“无限制”并不等同于“无限”——你的硬件只处理这么多连接。 |
| `-C` | 设置一个 IP 地址每分钟最多可以连接某个服务的次数。默认情况下，连接速率是无限制的，但使用此选项可以防止有人试图独占你的带宽或资源。 |
| `-R` | 设置任何服务每分钟最大可启动的次数。默认值是 256。如果使用 `-R 0`，则允许对任何服务进行无限次连接。 |
| `-a` | 设置 inetd(8) 绑定的 IP 地址。默认情况下，inetd 会监听系统上所有附加的 IP 地址。 |
| `-w` | 按照 *hosts.allow* 中的配置，使用 TCP 包装器来启动 inetd(8) 启动的程序（见 第十九章）。 |
| `-W` | 按照 *hosts.allow* 中的配置，使用 TCP 包装器为与 inetd(8) 集成的服务提供保护（见 第十九章）。 |

作为一个极端的例子，如果你想使用 TCP 包装器，每秒钟只允许单一主机连接两次，允许每分钟无限次调用服务，并且仅监听 IP 地址 203.0.113.2，那么你需要在 */etc/rc.conf* 中设置如下内容：

```
inetd_flags="-Ww -c 2 -R 0 -a 203.0.113.2"
```

使用 inetd(8)，几乎任何东西都可以是网络服务。

### DHCP

*动态主机配置协议（DHCP）* 是为客户端计算机分配 IP 地址的标准方法。虽然 FreeBSD 默认没有集成 DHCP 服务，但它通常是实现如无盘工作站等服务所必需的。我们将在这里介绍 DHCP 配置的基本内容，帮助你设置自己的网络。

现在，几乎每个防火墙和嵌入式设备都有一个 DHCP 服务器。那么为什么还需要单独的 DHCP 服务器呢？大多数嵌入式 DHCP 服务器缺少运行无盘客户端所需的功能，如网络启动的服务器和 VoIP 电话。当它们支持这些功能时，往往很难管理。这些服务应该运行在真正的服务器上。我们将在此介绍足够的 DHCP 内容，帮助你配置自己的网络客户端，包括无盘主机。

FreeBSD 包含了几种 DHCP 服务器。我比较喜欢 OpenBSD 的 dhcpd 和 ISC 的 DHCP 服务器。*ISC DHCP 服务器* 是行业标准，支持你可能需要的每一个功能。对于小规模部署，我推荐使用 OpenBSD 的 *dhcpd*。OpenBSD 的开发者在 ISC DHCP 的基础上，去掉了所有那些不常用的功能，制作了一个更小、更简单的服务器。配置文件仍然是单向兼容的；你可以在 ISC 的 DHCP 服务器上运行 OpenBSD 的 dhcpd 配置文件，不会有任何问题。（反之亦然，如果你没有使用 OpenBSD 去掉的那些功能。）如果你想运行无盘的 FreeBSD 客户端，或者需要 LDAP 集成，切换到更复杂的 ISC 服务器也是相对简单的。你只能安装这两者中的一个服务器。

这两款服务器的包都包含 dhcpd(8)，配置文件 */usr/local/etc/dhcpd.conf*，以及详尽的 man 页。

**流氓 DHCP 服务器**

每个网络应当只有一组权威的 DHCP 信息。如果你在已经有 DHCP 服务器的网络上设置自己的 DHCP 服务器，比如在公司办公室，可能会导致大量客户端无法正常工作，并引发一堆电话打到网络团队那里。设置一个“流氓”DHCP 服务器是让网络团队从此忽视你所有求助请求的绝佳方式。

#### *DHCP 工作原理*

在一个需要在各个办公室之间转发 DHCP 请求的大型网络中，DHCP 可能会变得非常复杂，但在本地以太网上，它相对简单。每个 DHCP 客户端会向本地以太网广播请求，寻找任何人来提供网络配置信息。如果你的 DHCP 服务器在本地以太网上，它会直接做出响应。如果你的 DHCP 服务器在另一个网络段，那个网络段的路由器需要知道该将 DHCP 请求转发到哪个 IP 地址。DHCP 服务器会将配置文件借给客户端，并追踪哪些客户端被分配了哪些 IP 地址。分配给客户端的配置文件叫做 *租约*。就像你为房屋或汽车支付的租金一样，DHCP 租约会到期，并且需要定期续租。

客户端可以请求某些功能——例如，Microsoft 客户端请求 WINS 服务器的 IP 地址，而无盘系统请求查找内核的位置。你可以根据需要设置这些选项。

每个客户端通过用于连接网络的网卡的 MAC 地址唯一标识。ISC dhcpd 在文件*/var/db/dhcpd.leases*中跟踪 MAC 地址和 IP 地址，以及租约。在这个文件中，你可以识别出哪些主机拥有哪些 IP 地址。如果一个主机暂时离开网络并重新连接，dhcpd(8)会重新分配相同的 IP 地址给该客户端，如果该 IP 地址仍然可用。

#### *配置 dhcpd(8)*

文件*/usr/local/etc/dhcpd.conf*包含了所有关于 dhcpd 的配置。虽然 ISC dhcpd(8)本身就可以写成完整的书籍，我们将在这里重点关注适用于基本小型办公室的功能以及本书后续示例中使用的功能。默认的*dhcpd.conf*文件注释齐全，还包括更多的示例，而 dhcpd.conf(5)则详细到令人痛苦的程度。我们假设你在网络上运行一个单独的 DHCP 服务器，且该服务器应答所有 DHCP 服务请求。（当然，也可以为容错集群化 dhcpd，但这超出了我们的讨论范围。）

##### 全局设置

从一些客户端配置的通用规则开始你的*dhcpd.conf*文件。这些规则适用于所有 DHCP 客户端，除非被明确覆盖。

```
➊ option domain-name "mwl.io";
➋ option domain-name-servers 198.51.100.2, 198.51.100.3;
➌ option subnet-mask 255.255.255.0;
➍ default-lease-time 600;
➎ max-lease-time 7200;
```

每个 DHCP 客户端会向 DHCP 服务器注册其主机名，但客户端必须从服务器学习本地域名。（也可以让 DHCP 服务器设置客户端的主机名。）使用`domain-name`选项 ➊来设置这个。你可以给你的 DHCP 客户端任何你喜欢的域名；它们不需要与服务器的域名相同。如果用空格分隔，你可以包含多个域名，但并非所有操作系统都会识别额外的域名。

每个 TCP/IP 客户端需要一个或多个 DNS 服务器。使用`domain-name-servers`选项 ➋来指定它们。多个 DNS 服务器用逗号分隔。

设置默认子网掩码 ➌是一个好主意。各个网络可以覆盖此设置，但全局默认值非常有用。

租约的正常持续时间由`default-lease-time`选项➍（以秒为单位）给出。租约时间到期后，客户端会向 DHCP 服务器请求新的 DHCP 租约。DHCP 服务器通常默认设置为几分钟，但如果你的网络相对稳定，你可以将其延长至几个小时或几天。如果客户端无法连接到 DHCP 服务器，它将继续使用旧的租约，直到达到租约的最大有效时间，该时间由`max-lease-time` ➎指定。你可以将最大租约时间理解为“如果我的 DHCP 服务器失败了，这是我在电话开始响起之前，必须更换它的时间。”给自己足够的时间来解决问题。^(5)

现在定义子网。

##### 子网设置

网络上的每个子网都需要一个 `subnet` 声明来识别该子网上 DHCP 客户端的配置信息。例如，这是一个单个小型办公室网络的网络声明：

```
➊ subnet 198.51.100.0 netmask 255.255.255.0 {
  ➋ range 198.51.100.50 198.51.100.99;
  ➌ option routers 198.51.100.1;
  }
```

每个子网声明开始时会标识该子网的网络号和子网掩码 ➊。在这里，我们有一个使用 IP 网络号 198.51.100.0 和子网掩码 255.255.255.0 的子网，或 IP 地址 198.51.100.1 到 198.51.100.255。随后的信息都与该子网上的主机有关。

`range` 关键字 ➋ 用于标识 dhcpd(8) 可以分配给客户端的 IP 地址。在这个例子中，我们有 50 个可供客户端使用的 IP 地址。如果在任何租约到期之前有 51 个 DHCP 客户端连接，最后一个主机将无法获得地址。

使用 `routers` 选项 ➌ 定义默认路由。请注意，您不能通过 dhcpd(8) 定义额外的路由；相反，您的本地网络路由器需要有适当的路由来到达目标。如果您的本地网络上有多个网关，您的网关会向 DHCP 客户端发送 ICMP 重定向，告知它更新后的路由。（如果您不知道这是什么意思，没关系。当您需要时，您会突然理解我在说什么，如果您永远不需要它，那么您刚刚浪费了两秒钟的时间去读这句话。）

如果您有多个子网，创建多个子网声明。一些子网可能需要不同于全局默认值的设置，例如子网掩码或 DNS 服务器。如果是这样，请使用相同的关键字为该子网定义这些值。

Dhcpd 允许您设置从子网掩码、启动服务器到甚至为古老 Windows 客户端配置 WINS 服务器的所有内容。我们将在第二十三章中使用这些不太常见的设置来管理无磁盘客户端。有关详细信息，请参阅 dhcpd.conf(5)。

#### *管理 dhcpd(8)*

Dhcpd 默认监听所有网络接口以捕捉 DHCP 请求广播。然而，我曾运行过许多带有多个网络卡的 DHCP 服务器，通常我只希望 dhcpd 监听单个接口。将所需的接口作为命令行参数提供。

```
sysrc dhcpd_flags="em1"
```

现在启用 dhcpd(8) 本身。

```
sysrc dhcpd_enable=YES
```

现在，您可以通过 `service dhcpd start` 启动 dhcpd。

恭喜，您已经准备好了！

### 打印和打印服务器

在类 Unix 操作系统上，打印是一个让新手系统管理员哭泣的主题，而经验丰富的系统管理员则会喋喋不休地谈论过去打印机作为 TTY 设备的时代，以及年轻一代不懂得自己有多幸运。^(6) 最常见的打印情境是通过 USB 端口直接连接到计算机的打印机和连接到网络打印服务器的打印机。

如果你有一台直接连接到 FreeBSD 机器的打印机，比如通过 USB 电缆连接，我建议使用 *Common Unix Printing System (CUPS)*。这套软件管理许多流行的消费级和商用打印机，从普通的喷墨打印机到大规模的激光打印机。我不会详细讲解 CUPS，因为它很复杂，并且根据打印机型号有所不同。你可以在 *[`www.cups.org/`](http://www.cups.org/)* 上了解更多关于 CUPS 的信息。许多品牌的打印机在 CUPS 中有专门的设置程序，比如 HP 的 `hp-setup`。不过，如果你的打印机支持网络连接，建议避免使用 CUPS，而改用网络打印。

通过 *Line Printer Spooler Daemon (LPD)* 访问远程打印服务器或网络打印机相比之下更为简单。LPD 接收 PostScript 文件并生成打印输出。大多数办公打印服务器都运行 LPD。lpd(8) 守护进程管理着 LPD。大多数现代网络打印机也支持 LPD，并且可以作为独立的打印服务器使用。

通过连接到 TCP 端口 515 来测试是否支持 LPD；如果能够连接，说明设备支持 LPD。

```
# nc -v color-printer 515
Connection to color-printer 515 port [tcp/printer] succeeded!
```

该设备支持 LPD。我们可以通过配置 */etc/printcap* 将打印任务发送到它。

#### */etc/printcap*

每个系统已知的打印机都需要在 */etc/printcap* 中有一个条目，即打印机能力数据库。这个文件按照现代标准来看，格式相当晦涩，且对于没有接触过 termcap(5) 的人来说，可能显得非常陌生。幸运的是，要访问打印服务器，你并不需要理解 printcap(5)，你只需要使用以下模板。

要连接到打印服务器上的打印机，你必须知道打印服务器的主机名或 IP 地址，以及你想访问的打印机名称。根据以下模板在 */etc/printcap* 中创建条目。特别注意冒号和反斜杠——它们至关重要。

```
➊ lp|printername:\
       ➋ :sh=:\
       ➌ :rm=printservername:\
       ➍ :sd=/var/spool/output/lpd/printername:\
       ➎ :lf=/var/log/lpd-errs:\
       ➏ :rp=printername:
```

我们的第一行显示了打印机的名称 ➊。如果你从 LibreOffice 或图形化的网页浏览器中打印，这些名称会显示为打印机选项。每台打印机可以有多个名称，用管道符号（`|`）分隔。任何类 Unix 系统上的默认打印机都叫 *lp*，因此将其列为你首选打印机的名称之一。另一个名称应该是打印服务器为你的打印机设置的名称（例如，*3rdFloorPrinter*）。需要注意的是，微软的打印服务器经常将一台打印机共享为多个不同的名称，并且通过不同的名称处理打印任务。如果你在网络上发现这种情况，请确保选择 PostScript 名称。^(7)

默认情况下，lpd(8) 会在每个打印任务前打印一页，列出任务名称、编号、主机及其他信息。除非你处于一个只有一个共享打印机的环境，否则这可能是浪费纸张。`：sh:\` 条目 ➋ 会抑制此页面的打印。

`rm`（远程机器）变量 ➌ 提供打印服务器的主机名。你必须能够通过你在这里指定的名称 ping 到该服务器。如果打印服务器是打印机的一部分，请在此处提供打印机的主机名。

每台打印机都需要一个唯一的打印队列目录 ➍，打印守护进程可以在此目录中存储传输到打印服务器的文档。此目录必须由 *root* 用户和 *daemon* 组拥有。

与必须不同的打印队列目录不同，打印机可以共享一个公共日志文件 ➎。

最后，指定远程打印机名称 ➏，因为打印服务器是通过该名称识别的。如果你直接连接到打印机，而不是连接到中央打印服务器，可以跳过此项—but 你必须删除前一行中的尾部斜杠。

确保你在 */etc/printcap* 文件末尾添加新行；不要在打印机名称后立即终止文件。另外，请注意，和模板中的其他条目不同，最后一行不需要尾部的反斜杠。

打印机有许多选项，从每页的费用到手动设置字符串以进纸新的纸张。大多数这些选项今天已经过时。然而，如果你有一台较老的打印机或有特殊需求，可以查阅 printcap(5) 文档，获取足够的详细信息，甚至让人应接不暇。

#### *启用 LPD*

在 */etc/rc.conf* 中将 `lpd_enable` 设置为 `YES`，以便在启动时启动 lpd(8)。每次编辑 */etc/printcap* 时，必须重启 lpd(8)。使用 lpq(1) 查看打印队列，并在 */var/log/lpd-errs* 中查看是否有任何问题。

### TFTP

让我们结束关于小型网络服务的讨论，也许是仍然使用的最小网络服务——*简单文件传输协议（TFTP）*。TFTP 允许你在机器之间传输文件，而无需任何身份验证。它的灵活性也远不如文件复制协议，如 SCP 或 FTP。然而，TFTP 仍然被嵌入式设备制造商（如思科）用来加载系统配置和操作系统更新。我们在这里提到它，仅仅是因为无盘客户端使用 TFTP 下载操作系统内核并获取初始配置信息。在 TCP 端口 69 上通过 inetd(8) 运行 tftpd(8)。

**TFTP 安全**

TFTP 不适合在公共互联网中使用。任何人都可以在 TFTP 服务器上读取或写入文件！仅应在防火墙后使用 TFTP，或者至少使用 TCP 包裹器（参见 第十九章）保护它。

设置 tftpd(8) 服务器包括四个步骤：为服务器选择根目录、为服务器创建文件、选择文件的所有者，以及运行服务器进程。

#### *根目录*

tftpd(8) 守护进程默认使用目录 */tftpboot*。如果您只有几个很少访问的文件，这可能是合适的选择，但最好将根分区保留给那些不常更改的文件。您不希望通过 TFTP 上传文件导致根分区填满，从而崩溃系统！如果您使用的是 ZFS，可以创建一个 tftp 数据集。在 UFS 中，我通常将 tftpd(8) 的根目录放在 */var/tftpboot*，并添加一个指向 */tftpboot* 的符号链接：

```
# mkdir /var/tftpboot
# ln -s /var/tftpboot /tftpboot
```

现在您可以创建文件并通过 TFTP 进行访问。

#### *tftpd 和文件*

用户可以通过 TFTP 进行文件的读取和写入。如果您希望 tftpd(8) 用户能够读取某个文件，该文件必须是全局可读的：

```
# chmod +r /var/tftproot/filename
```

同样，tftpd(8) 不允许任何人上传文件，除非该文件名已经存在且是全局可写的。请记住，程序和常规文件具有不同的权限。程序必须具备执行权限，除了读取和写入权限，因此您需要为程序和文件设置不同的权限。您可以使用 touch(1) 命令预先创建您希望通过 TFTP 上传的文件。

```
# chmod 666 /var/tftproot/filename
# chmod 777 /var/tftproot/programname
```

是的，这意味着任何知道文件名的人都可以覆盖该文件的内容。请将重要文件设置为只读。^(8) 这也意味着您无需担心有人上传大文件并占满您的硬盘。

#### *文件所有权*

TFTP 服务器中的文件应该由具有最低权限的用户拥有。如果您只偶尔运行 TFTP 服务器，可以使用 nobody 用户。例如，如果您只需要 TFTP 服务器执行偶尔的嵌入式设备升级，可以让 nobody 用户拥有您的文件，并在不需要时关闭 tftpd(8)。然而，如果您运行的是永久性的 TFTP 服务器，最好让专门的 tftp 无权限用户拥有文件。tftp 用户不需要拥有 *tftproot* 目录，实际上，应该有一个完全不同的主目录。他只需要拥有可供用户访问的文件的所有权。

#### *tftpd(8) 配置*

tftpd(8) 完全通过命令行参数进行配置，且参数不多。有关完整列表，请阅读 tftpd(8)，以下是最常用的几个。

如果您仅为运行 tftpd(8) 创建用户，请使用 `-u` 参数指定该用户。如果不指定用户，tftpd(8) 将以 nobody 身份运行。请创建一个无权限用户。

我建议记录所有对 TFTP 守护进程的请求。`-l` 参数会启用日志记录功能。tftpd(8) 使用 `FTP` 功能，您需要在 *syslog.conf* 中启用该功能（请参见 第二十一章）。

tftpd 支持使用 `-s` 标志进行 chroot 限制。这可以让您将 tftpd(8) 限制在您选择的目录中。您可不希望用户通过 TFTP 上传诸如 */etc/passwd* 或 */boot/kernel/kernel* 这样全局可读的文件，这是出于一般原则的考虑！始终对您的 tftpd(8) 安装进行 chroot 限制。

你可以通过 `-c` 参数按 IP 地址为 TFTP 客户端设置 chroot。在这种情况下，你必须为每个允许连接的客户端创建一个目录。例如，假设你只想允许你的路由器通过 IP 地址 192.168.1.1 访问 TFTP。你可以创建一个目录 */var/tftproot/192.168.1.1* 并使用 `-c`。你还必须使用 `-s` 来定义 */var/tftproot* 的基本目录。这是一种不错的折衷方法，当你只想为一两个主机提供 TFTP 服务时，但又不希望让全球用户都能访问你的 TFTP 服务器。

你可以选择允许客户端向 TFTP 服务器写入新文件。这是一个不好的主意，因为它允许远程用户用任意文件填满你的硬盘。如果你确实需要这个功能，请使用 `-w` 标志。

例如，假设你想记录所有对 tftpd 的请求，将根目录改为 */var/tftpboot*，以 tftpd 用户身份运行服务器，并按 IP 地址为客户端设置 chroot。运行 tftpd 的命令可能是这样的：

```
tftpd -l -u tftpd -c -s /var/tftpboot
```

按照本章前面描述的方式，将此内容输入到*inetd.conf*中，重启 inetd(8)，然后就可以开始使用了！

### 调度任务

FreeBSD 的作业调度器 cron(8) 允许管理员定期运行任何命令。结合系统维护调度系统 periodic(8)，你几乎可以调度任何任务。

#### *cron(8)*

如果你需要每天夜间备份数据库，或者一天四次重新加载 DNS 服务器，cron 是你的好帮手。cron(8) 的配置文件称为 *crontabs*，并通过 crontab(1) 进行管理。每个用户都有一个单独的 crontab 文件，存储在 */var/cron/tabs* 中，全局 crontab 文件是 */etc/crontab*。全局 cron 条目也可以放在 */etc/cron.d* 中，并将像 */etc/crontab* 中的一部分那样运行。

##### 用户 Crontab 与 /etc/crontab

*/etc/crontab* 的目的与各个用户的 crontab 不同。使用 */etc/crontab* 时，root 用户可以指定某个命令由哪个用户执行。例如，在 */etc/crontab* 中，系统管理员可以指定，“在每周二晚上 10 点以 root 用户身份运行此任务，在早上 7 点以 *www* 用户身份运行另一个任务。”其他用户只能以自己的身份运行任务。当然，root 用户也可以编辑其他用户的 crontab。

此外，任何系统用户都可以查看 */etc/crontab*。如果你有一个不希望用户知道的定时任务，可以将其放在用户的 crontab 中。例如，如果你为数据库创建了一个非特权用户，可以使用该用户的 crontab 来运行数据库维护任务。

*/etc/crontab* 被认为是一个 FreeBSD 系统文件。在升级时不要覆盖它！简化升级*/etc/crontab*的一种方法是将自定义条目放在文件末尾，并用几行井号（`#`）标记。*/etc/crontab* 文件必须以新行结尾，否则最后一行将不会被解析并执行。如果最后一行是注释，这样没有问题，但如果它是命令，则可能会出现问题。

最后，当你使用文本编辑器编辑*/etc/crontab*时，使用`crontab -e`来编辑用户的 crontab。

##### cron 和环境

Crontab 在一个 shell 中运行，程序可能需要环境变量才能正确运行。你还可以在命令行中为每个从 cron 运行的命令指定环境变量。cron 不会从任何地方继承环境变量；程序需要的任何环境变量必须在 crontab 中指定。例如，以下是 FreeBSD 12 系统中*/etc/crontab*的环境：

```
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin
```

是的，这确实是非常简洁！可以根据需要在用户 crontab 中添加环境变量，但在更改*/etc/crontab*时要谨慎。如果需要自定义环境变量，最好使用用户 crontab 而不是*/etc/crontab*，因为*/etc/crontab*中的许多命令是用于核心系统维护的。

##### Crontab 格式

在环境声明下面，用户的 crontab 分为六列。前五列表示命令应运行的时间，依次是分钟、小时、日期、月份和星期几。如果某列为星号（`*`），表示*每一个*，而数字则表示*在此精确时刻*。分钟、小时和星期几从 0 开始，日期和月份从 1 开始。此外，由于 AT&T 和 BSD 之间的历史分歧，星期天可以用 7 或 0 表示。在时间之后，列出在该时间运行的命令。

*/etc/crontab*文件和*/etc/cron.d*下的文件有一个额外的列：指定以哪个用户身份运行命令。这个用户列位于时间说明和命令之间。如果你愿意，可以查看*/etc/crontab*中的许多示例。

##### 示例 Crontab

假设我们正在编辑一个无权限用户的 crontab，以安排程序的维护。由于*/etc/crontab*文件顶部有列标题，这里我们将展示用户 crontab。（如果要在*/etc/crontab*中使用这些示例，只需在命令前加上用户即可。）在这里，我们希望每小时的第 55 分钟运行程序*/usr/local/bin/maintenance.sh*：

```
55    *    *    *    *    /usr/local/bin/maintenance.sh
```

星号告诉 cron 每小时、每个月的每一天以及每个工作日运行这个作业。`55`告诉 cron 仅在第 55 分钟运行这个作业。

要每天在下午 1:55 运行相同的作业，可以使用以下配置：

```
55    13    *    *    *    /usr/local/bin/maintenance.sh
```

这里，`13`表示 24 小时制下的下午 1:00，`55`表示该小时的第 55 分钟。

使用 cron 时，人们常犯的一个错误是指定了较大的时间单位，却漏掉了较小的单位。例如，假设你想每天上午 8 点运行作业：

```
*    8    *    *    *    /usr/local/bin/maintenance.sh
```

这是错误的。是的，作业将在上午 8:00 运行。它也会在 8:01、8:02、8:03 等时间运行，一直到上午 9:00。如果你的作业运行超过一分钟，你很快就会让系统崩溃。指定仅在上午 8:00 运行的方法是这样的：

```
0    8    *    *    *    /usr/local/bin/maintenance.sh
```

要指定时间范围，例如每小时、每天在上午 8 点到下午 6 点之间的某个时间运行程序，可以使用类似这样的语法：

```
55    8-18    *    *    1-5    /usr/local/bin/maintenance.sh
```

要指定多个精确的时间，使用逗号分隔：

```
55    8,10,12,14,16    *    *    *    /usr/local/bin/maintenance.sh
```

更有趣的是，你可以指定时间的分数或 *步长*。例如，要每隔 5 分钟运行一个程序，请使用：

```
*/5    *    *    *    *    /usr/local/bin/maintenance.sh
```

你可以将范围与步长结合使用。要每隔 5 分钟运行一次程序，但比上一个示例延迟 1 分钟，请使用以下命令：

```
1-56/5    *    *    *    *    /usr/local/bin/maintenance.sh
```

用两个字段控制任务运行的日期：月中的日期和星期几。如果你同时指定这两个条件，任务将在 *任一* 条件满足时运行。例如，告诉 cron 在每个月的 1 号和 15 号，以及每个星期一运行任务，命令如下：

```
55    13    *    1,15    1    /usr/local/bin/maintenance.sh
```

如果你的任务有非标准环境变量，请像在 shell 中一样在命令行上设置环境变量。例如，如果你的程序需要 `LD_LIBRARY_PATH` 环境变量，可以这样设置：

```
55    *    *    *    *    LD_LIBRARY_PATH=/usr/local/mylibs ; /usr/local/bin/maintenance.sh
```

cron 还支持特殊的调度，如 *每年一次* 或 *每天*，通过 `@` 符号。大多数这些术语最好不要使用，因为它们可能会产生歧义。虽然机器确切知道它们的含义，但人类往往会误解！一个有用的 crontab 条目是 *每次系统启动时*，其表示为 `@reboot`。这允许一个非特权用户在系统启动时运行任务。使用 `@reboot` 标签代替时间字段：

```
@reboot    /usr/local/bin/maintenance.sh
```

Crontabs 和 cron(8) 让你以任何你喜欢的方式调度工作，从而将人类从许多常规维护任务中解放出来。

#### *periodic(8)*

一些系统维护任务应该只在特定系统上运行，但它们的运行方式在所有主机上是相同的。这就是 periodic(8) 的作用。

periodic(8) 命令按 cron(8) 确定的计划运行系统功能。Periodic 会检查一个目录中的脚本集合，看看是否需要运行。FreeBSD 包括几个用于定期任务的目录：*/etc/periodic/daily*、*/etc/periodic/weekly*、*/etc/periodic/monthly* 和 */etc/periodic/security*。根据你安装的包，你可能会在 */usr/local/etc/periodic* 中有相应的目录。当 cron 运行 periodic daily 时，periodic(8) 会检查每个 *periodic/daily* 目录中的每个脚本，看看是否应该执行。

当你有空时，我建议你浏览一下 periodic(8) 脚本。你可能会发现禁用的维护脚本对你的环境很有用。

应该运行哪些脚本？默认设置列在 */etc/defaults/periodic.conf* 中，但你可以在 */etc/periodic.conf* 中覆盖它们。

一旦 periodic(8) 运行，它会将脚本的结果通过邮件发送给本地机器上的 root 用户。你可以将 root 的邮件转发给那些会实际阅读它的人。

为什么使用 periodic(8)？它的作用是进行系统维护。*/etc/crontab* 用于配置你自己的系统管理任务。使用单独的脚本可以让系统升级过程中替换任务，并且包可以添加或移除它们。

不过，所有的 periodic(8) 任务都是以 root 用户身份运行的。如果你有需要由权限较低的用户执行的定时任务，请从该用户的 crontab 中运行它们。

现在你已经对 FreeBSD 提供的常见小型服务有了相当的了解，我们接下来讲讲性能。
