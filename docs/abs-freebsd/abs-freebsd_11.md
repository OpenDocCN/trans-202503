## **UNIX 文件系统**

![image](img/common01.jpg)

FreeBSD 的文件系统——Unix 文件系统（UFS）是 BSD 4.4 自带文件系统的直接后代。原 UFS 的作者之一仍然在开发 FreeBSD 的文件系统，并在近年来增加了许多有用的功能。FreeBSD 并不是唯一一个仍在使用 4.4 BSD 文件系统或其后代的操作系统。如果一个 Unix 供应商没有特别宣传其“改进和高级”的文件系统，那么它很可能正在使用 UFS 衍生系统。

UFS 作为最初的文件系统，使其有机会在 FreeBSD 中扩展。许多 UFS 的概念为 FreeBSD 支持其他文件系统提供了基础，从 ZFS 到光盘。即使你不打算使用 UFS，了解 UFS 的基本知识也是理解 FreeBSD 如何管理文件系统的关键。

像 Unix 的其他部分一样，UFS 旨在有效地处理最常见的情况，同时可靠地支持不常见的配置。FreeBSD 自带的 UFS 配置旨在尽可能在现代硬件上广泛使用，但如果需要，你可以选择为数万亿个小文件或几块 1TB 的大文件优化特定的文件系统。

我们今天所称的 UFS 实际上是 UFS 版本 2，或称*UFS2*。原始 UFS 无法处理现代的磁盘容量。

UFS 最适合较小的系统或无法处理 ZFS 开销的应用程序。许多人更喜欢在虚拟机中使用 UFS。我在第二章中讨论了选择文件系统的问题。

### UFS 组件

UFS 由两层构成，一层叫做*Unix 文件系统*，另一层是*快速文件系统（FFS）*。UFS 处理文件名、将文件附加到目录、权限以及用户关心的所有琐碎细节。FFS 则负责将文件写入磁盘并对其进行排列，以便快速访问。这两者协同工作提供数据存储。

#### *快速文件系统*

FFS 由超级块、块、碎片和索引节点组成。

*超级块*记录了文件系统的特征。它包含一个魔术数字，用于识别文件系统为 UFS，以及内核用于优化文件读写的文件系统几何信息。UFS 文件系统会保留多个超级块的备份，以防主块损坏。

*块*是存储数据的磁盘片段。FreeBSD 默认使用 32KB 的块。FFS 将块映射到底层磁盘或 GEOM 提供者的特定扇区。每个存储的文件都会被分割成 32KB 的块，每个块都会存储在自己的块中。

不是所有文件都是 32KB 的整数倍，因此 FFS 将剩余部分存储在*碎片*中。标准为块大小的八分之一，即 4KB。例如，一个 39KB 的文件将填满一个块和两个碎片。一个碎片只有 3KB，因此碎片确实浪费了磁盘空间——但它们浪费的空间比到处使用完整块要少得多。

#### *UFS 如何使用 FFS*

UFS 将某些 FFS 块分配为 *inode*，或 *索引节点*，用来将块和碎片映射到文件。一个 inode 包含每个文件的大小、权限以及包含该文件的块和碎片列表。总的来说，inode 中的数据被称为 *元数据*，即关于数据的数据。

每个文件系统有一定数量的 inode，与文件系统的大小成比例。现代磁盘每个分区可能有数十万个 inode，足以支持数十万个文件。然而，如果你有大量非常小的文件，你可能需要重建文件系统来支持更多的 inode。使用 `df -i` 查看文件系统中剩余的 inode 数量。

理论上，UFS 可以在除 FFS 以外的存储层上运行。这也是许多基于日志或基于区块的文件系统的工作原理。然而，经过数十年的发展，UFS 和 FFS 的特性，如日志和软更新，已经深度交织在一起，以至于分离这两者变得不再现实，甚至连稍微可行的可能性都没有。

#### *Vnodes*

如果你只使用 UFS 文件系统，并且所有硬盘都永久附加，那么 inode 和块的工作是完美的。然而，现如今我们通常会在不同的机器之间甚至不同的操作系统之间交换磁盘。你可能需要在桌面上读取光盘和闪存磁盘，服务器甚至可能需要接受为不同操作系统格式化的硬盘。

FreeBSD 使用存储抽象层——*虚拟节点*，或 *vnode*——在文件系统和内核之间进行调解。你永远不会直接操作 vnode，但 FreeBSD 文档经常提到它们。Vnode 是内核与已挂载文件系统之间的翻译层。如果你是面向对象编程的开发者，可以把 vnode 想象成所有存储类继承的基类。当你写文件到 UFS 文件系统时，内核将数据定向到一个 vnode，这个 vnode 又映射到一个 UFS inode 和 FFS 块。当你写入 FAT32 文件系统时，内核将数据定向到一个 vnode，该 vnode 映射到 FAT32 文件系统的特定部分。只有在处理 UFS 文件系统时才使用 inode，但在处理任何文件系统时都使用 vnode。

### 挂载和卸载文件系统

mount(8) 程序的主要功能是将文件系统附加到主机的文件系统树上。虽然 FreeBSD 在启动时会挂载 */etc/fstab* 中列出的每个文件系统，但你必须理解 mount(8) 的工作原理。如果你之前从未操作过挂载，可以将你的 FreeBSD 测试机启动到单用户模式（参见 第四章）并跟随操作。

在单用户模式下，FreeBSD 会将根分区挂载为只读。在传统的类 Unix 系统中，根分区只包含足够的系统文件来执行基本的设置、启动核心服务并找到其余的文件系统。其他文件系统没有被挂载，因此它们的内容无法访问。当前的 FreeBSD 安装程序将所有内容放在根分区中，因此你可以得到基本的操作系统，但任何特殊的文件系统、网络挂载等都会是空的。你可能需要挂载其他文件系统来进行系统维护。

#### *挂载标准文件系统*

要手动挂载在 */etc/fstab* 中列出的文件系统，例如 */var* 或 */usr*，可以给 mount(8) 命令指定你想要挂载的文件系统名称。

```
# mount /media
```

这会按照 */etc/fstab* 中列出的方式挂载分区，并带有该文件中指定的所有选项。如果你想挂载 */etc/fstab* 中列出的所有分区，除了那些标记为 `noauto` 的分区，可以使用 mount 命令的 `-a` 标志。

```
# mount -a
```

当你挂载所有文件系统时，已经挂载的文件系统不会被重新挂载。

#### *特殊挂载*

你可能需要将文件系统挂载到不寻常的位置或临时挂载某个东西。我通常在安装新磁盘时手动挂载磁盘。使用设备节点和期望的挂载点。如果我的 */var/db* 分区是 */dev/gpt/db*，并且我想将其挂载到 */mnt*，我会运行：

```
# mount /dev/gpt/db /mnt
```

#### *卸载分区*

当你想要从系统中断开文件系统时，可以使用 umount(8) 命令告知系统卸载该分区。（注意命令是 `umount`，而不是 `u`n`mount`。）

```
# umount /usr
```

你不能卸载正在被任何程序使用的文件系统。如果你无法卸载某个分区，可能是你正在以某种方式访问它。即使是命令行提示符在挂载目录中，也会阻止你卸载底层分区。运行 `fstat | grep /usr`（或其他分区）可以显示阻止操作的程序。

#### *UFS 挂载选项*

FreeBSD 支持几种挂载选项来改变文件系统的行为。当你手动挂载分区时，可以使用 `-o` 参数来指定任何挂载选项。

```
# mount -o ro /dev/gpt/home /home
```

你还可以在 `/etc/fstab` 中指定挂载选项（见 第十章）。在这里，我对 */home* 文件系统使用 `ro` 选项，就像在前面的命令行中一样。

```
/dev/gpt/home /home ufs ro 2 2
```

mount(8) 手册页列出了所有 UFS 挂载选项，但这里是最常用的一些。

##### 只读挂载

如果你想查看磁盘的内容，但不允许更改它们，可以将分区挂载为 *只读*。你不能修改磁盘上的数据或写入任何新数据。在大多数情况下，这种方式是最安全但最没有用的挂载方式。

许多系统管理员希望将根分区，甚至 */usr*，挂载为只读，以最小化来自入侵者或恶意软件对系统的潜在损害。这最大化了系统的稳定性，但极大地增加了维护的复杂性。如果你使用自动部署系统，如 Ansible 或 Puppet，并且习惯性地从零开始重新部署服务器，而不是进行升级，那么只读挂载可能适合你。

只读挂载在损坏的计算机上尤其有价值。当 FreeBSD 检测到文件系统损坏或脏文件系统时，它不会允许执行标准的读写挂载，但如果文件系统没有严重损坏，它会执行只读挂载。这为从濒临崩溃的磁盘中恢复数据提供了机会。

要以只读方式挂载文件系统，请使用 `rdonly` 或 `ro` 选项。两者效果相同。

##### 同步挂载

*同步*（或 *sync*）*挂载*是挂载文件系统的老式方式。当你向同步挂载的磁盘写入数据时，内核会等待写入是否实际完成，然后才告知程序。如果写入没有成功完成，程序可以选择相应地采取措施。

同步挂载在崩溃时提供最大的数据信用度，但它也比较慢。诚然，如今“慢”是相对的，因为即使是便宜的磁盘也能超越几年前的高端产品。如果你希望在数据完整性方面表现得极为谨慎，可以考虑使用同步挂载，但在几乎所有情况下，它都是过度的。

要同步挂载分区，请使用 `sync` 选项。

##### 异步挂载

尽管 *异步挂载* 很大程度上被软更新取代（参见软更新章节，第 237 页），你仍然会听到关于它们的讨论。为了更快的数据访问但伴随更高的风险，可以选择异步挂载分区。当磁盘以异步方式挂载时，内核会将数据写入磁盘，并在不等待磁盘确认数据已实际写入的情况下告诉写入程序写入成功。

异步挂载适用于一次性文件系统，如在关机时消失的内存文件系统，但不要用于重要数据。异步挂载和结合软更新的 noasync 之间的性能差异微乎其微。（下一节将讲解 noasync。）

要异步挂载分区，请使用 `async` 选项。

##### 同步和异步结合

FreeBSD 的默认 UFS 挂载选项将同步和异步挂载组合为 *noasync*。使用 noasync 时，影响 inode 的数据会同步写入磁盘，而实际数据则异步处理。结合软更新（本章后面会介绍），noasync 挂载创建了一个非常稳健的文件系统。

由于 noasync 挂载是默认选项，挂载时无需指定它，但当别人使用时，不要让它困扰你。

##### 禁用 Atime

UFS 中的每个文件都包含一个访问时间戳，称为*atime*，记录文件最后一次被访问的时间。如果您有大量文件且不需要这些数据，可以将磁盘挂载为*noatime*，以便 UFS 不更新此时间戳。这对于闪存介质或负载较重的磁盘（如 Usenet 新闻缓冲驱动器）最为有用。不过，某些软件会使用 atime，因此不要盲目禁用它。

##### 禁用执行

您的策略可能要求某些文件系统不应有可执行程序。`noexec`挂载选项防止系统在文件系统上执行任何程序。挂载*/home*为 noexec 可以帮助防止用户运行自己的程序，但为了有效性，还应将*/tmp*、*/var/tmp*以及用户可以写入自己文件的任何地方挂载为 noexec。

noexec 挂载并不会阻止用户运行 shell 脚本或解释型脚本（如 Perl 或 Python 等）。虽然脚本可能位于 noexec 文件系统上，但解释器通常不在该文件系统上。

noexec 挂载的另一个常见用途是，当您有一个包含不同操作系统或硬件架构的二进制文件的文件系统时，您不希望任何人执行它们。

##### 禁用 SUID

Setuid 程序允许用户以另一个用户的身份运行程序。例如，像 login(1)这样的程序必须作为 root 执行某些操作，但必须由普通用户运行。显然，setuid 程序必须小心编写，以防止入侵者利用它们获取未经授权的系统访问权限。许多系统管理员习惯性地禁用所有不必要的 setuid 程序。

`nosuid`选项禁用文件系统中所有程序的 setuid 访问。与 noexec 一样，脚本包装器可以轻松绕过 nosuid 限制。

##### 禁用聚集

FFS 通过聚集优化物理介质上的读写操作。它不是将文件分散到硬盘的各个位置，而是将整个文件以大块的形式写入。同样，读取文件时以较大块的形式读取是有意义的。您可以使用挂载选项`noclusterr`（用于读取聚集）和`noclusterw`（用于写入聚集）来禁用此功能。

##### 禁用符号链接

`nosymfollow`选项禁用符号链接，或文件的别名。*符号链接*主要用于创建指向位于其他分区的文件的别名。要创建指向同一分区上另一个文件的别名，请使用常规链接。有关链接的讨论，请参见 ln(1)。

指向目录的别名始终是符号链接；对于这些，您不能使用硬链接。

### UFS 的弹性

UFS 起源于当时断电意味着数据丢失的时代。经过数十年的使用和调试，UFS 几乎永远不会丢失数据，尤其是与其他开源文件系统相比。UFS 通过仔细的完整性检查来实现这一弹性，特别是在像断电这样的意外关机后。

弹性恢复的重点不是验证磁盘上的数据——UFS 在这方面表现相当好。它的目的是加速在意外关机后完整性验证和文件系统恢复。现代硬盘的容量意味着没有额外的弹性机制，验证可能需要很长时间。对一个 100MB 文件系统的完整性检查要比对一个多 TB 的文件系统进行相同的检查要快得多！增加弹性机制可以提高恢复时间。

UFS 提供了几种方法来提高 UFS 文件系统的可靠性，如软更新和日志记录。在创建文件系统之前，选择一个适合您需求的文件系统。

#### *软更新*

*软更新* 是一种技术，用于组织和安排磁盘写入操作，以确保文件系统的元数据始终保持一致，从而提供几乎与异步挂载相当的性能，并具备同步挂载的可靠性。这并不意味着所有数据都会安全地写入磁盘——在错误时刻发生的电源故障仍然可能导致数据丢失。无论操作系统如何处理，在电源断开的那一刻，正在写入磁盘的文件都无法到达磁盘。但磁盘上的实际内容将是内部一致的。软更新使得 UFS 能够在故障后快速恢复。

你可以在挂载或创建文件系统时启用或禁用软更新。

随着文件系统的增长，软更新会显示出其局限性。多达数 TB 的文件系统在非计划性关机后仍需要相当长的时间来恢复。原始的软更新日志论文 (*[`www.mckusick.com/softdep/suj.pdf`](http://www.mckusick.com/softdep/suj.pdf)*) 提到，一个 92%满的 14 盘阵列，在故意损坏文件系统后，完成完整性检查需要 10 小时。你需要在此之前就拥有日志记录。

#### *软更新日志*

一个日志文件系统记录所有实际文件系统之外的更改。这些更改会迅速写入存储设备，然后以更为从容的速度插入文件系统中。如果系统意外死机，文件系统会自动从日志中恢复任何更改。这大大减少了启动时重建文件系统完整性的需求。当你安装 FreeBSD 时，默认会创建带有软更新日志的 UFS 分区。

软更新日志并不是记录所有事务，而是记录所有元数据更新，以确保文件系统始终能够恢复到一个内部一致的状态。基准测试显示，日志记录对软更新的负载影响极小。然而，它确实增加了 I/O 开销，因为系统必须将所有更改转储到日志中，然后再将它们重新播放到文件系统中。然而，它极大地减少了恢复时间。那个需要 10 小时才能完成完整性检查的 14 盘阵列？使用日志后，它在相同的损坏情况下恢复的时间不到一分钟。

带日志的软更新非常强大。为什么不总是使用日志呢？软更新日志会禁用 UFS 快照。如果你需要 UFS 快照，就不能使用日志。但如果你需要快照，实际上使用 ZFS 可能会更好。FreeBSD 版的 dump(8) 使用 UFS 快照来备份实时文件系统。现在只有我们这些老派 Unix 用户还在使用 dump，主要是因为我们已经熟悉它，但如果你的组织要求使用 dump(8)，你需要另一种容错选项。

#### *GEOM 日志*

FreeBSD 也可以在 GEOM 层级使用 gjournal(8) 进行日志记录。像任何其他文件系统日志一样，gjournal 记录文件系统事务。在启动时，FreeBSD 检查日志文件中是否有尚未写入文件系统的更改，并执行这些更改，以确保文件系统的一致性。Gjournal 在软更新日志之前就已经存在。

虽然软更新日志只记录元数据，但 gjournal 记录所有文件系统事务。在系统故障时，你丢失数据的可能性较小，但一切都会被写入两次，从而影响性能。不过，如果你使用 gjournal，不要使用任何类型的软更新。你还应该以异步方式挂载文件系统。你可以在 gjournaled 文件系统上使用快照。

Gjournal 每个文件系统使用 1GB 的磁盘空间。你不能随便开关它——必须为日志提供空间。你可以为日志使用单独的分区，或者如果留出空间，可以将这个一 GB 包含在分区内。如果决定将 gjournal 添加到现有的分区，你需要找到空间。

你应该使用 gjournal 还是软更新日志？如果可能的话，我建议使用软更新日志。如果这不是一个选项，就使用普通的软更新。如果你需要 UFS 快照，包括在快照上的 dump(8)，那么使用 GEOM 日志。就我个人而言，我已经不再使用 gjournal 了。

### 创建和调优 UFS 文件系统

在上一章中，我们对你的磁盘进行了分区和标签操作。现在让我们在这些分区上创建文件系统。使用 newfs(8) 创建 UFS 文件系统，设备节点作为最后一个参数。在这里，我在设备 */dev/gpt/var* 上创建了一个文件系统：

```
# newfs /dev/gpt/var
/dev/gpt/var: ➊51200.0MB (104857600 sectors) ➋block size 32768, ➌fragment size 4096
        using ➍82 cylinder groups of 626.09MB, 20035 blks, 80256 inodes.
super-block backups (for fsck_ffs -b #) at:
➎192, 1282432, 2564672, 3846912, 5129152, 6411392, 7693632, 8975872,
--snip--
```

第一行重复设备节点并打印分区的大小 ➊，以及块 ➋ 和碎片大小 ➌。你将获得文件系统几何信息 ➍，这是一种遗留信息，源自硬盘几何曾与硬件有某种关系的时代。最后，newfs(8) 打印出超级块备份列表 ➎。你的文件系统越大，备份超级块就越多。

如果你想使用软更新日志，请添加 `-j` 标志。要使用没有日志的软更新，请添加 `-U` 标志。在创建文件系统后，你可以通过 tunefs(8) 启用或禁用软更新日志，或使用普通的软更新。

#### *UFS 标签*

设备节点可以改变，但标签保持不变。最佳实践是为 GPT 分区添加标签，但不能为 MBR 分区添加标签。MBR 上的 UFS 文件系统可以使用 `-L` 标志添加 UFS 标签。

```
# newfs -L var /dev/ada3s1d
```

这些标签会出现在 */dev/ufs* 中。在 */etc/fstab* 和其他配置文件中使用它们，以避免磁盘重命名的混乱。你不能将 UFS 标签应用到非 UFS 文件系统。

如果你在 GPT 分区上使用 UFS，请选择 GPT 或 UFS 标签。由于衰退，你每次只能看到一个标签，这可能会让你感到困惑。

#### *块大小和碎片大小*

UFS 的效率与读取或写入的块和碎片数量成正比。通常，FreeBSD 读取一个 10 块的文件的时间是读取一个 20 块文件的一半。FreeBSD 开发人员选择默认的块和碎片大小是为了适应最广泛种类的文件。

如果你有一个专用文件系统，主要包含大文件或小文件，你可以考虑在创建文件系统时更改块大小。虽然可以更改现有文件系统的块大小，但这是一个糟糕的主意。块大小必须是 2 的幂。碎片是块大小的八分之一这一假设在许多地方是硬编码的，因此让 newfs(8) 根据块大小来计算碎片大小。

假设我有一个专门用于大文件的文件系统，我想增加块大小。默认的块大小是 32KB，那么下一个较大的块大小就是 64KB。使用 `-b` 指定新的块大小。

```
# newfs -b 64K -L home /dev/da0s1d
```

如果你将有很多小文件，可能需要考虑使用更小的块大小。需要注意的一点是，碎片大小不应小于底层磁盘的物理扇区大小。FreeBSD 默认使用 4KB 的碎片。如果你的磁盘有 4KB 的扇区，千万不要使用更小的碎片大小。如果你完全确定你的磁盘有 512 字节的物理扇区，可以考虑创建一个 16KB（甚至 8KB）块大小的文件系统，并使用相应的 2KB 或 1KB 碎片大小。

在我的系统管理员生涯中，我只需要^(1)定制块大小两次。在遇到性能问题之前不要使用定制块大小。

#### *使用 GEOM 日志*

在使用 gjournal(8) 之前，决定将 1GB 日志放在哪里。如果可能，我建议将这一千兆字节包含在文件系统分区中。这意味着如果你想要一个 50GB 的文件系统，就将它放入一个 51GB 的分区。否则，使用一个单独的分区。

在执行任何 gjournal 操作之前，通过 `gjournal load` 或在 */boot/loader.conf* 中加载 geom_journal 内核模块。

要创建一个 gjournal 提供者，同时将分区包含在日志中，请使用 `gjournal label` 命令。

```
# gjournal label da3p5
```

如果你想让一个独立的提供者作为日志，请将该提供者作为第二个参数添加。

```
# gjournal label da3p5 da3p7
```

如果成功，这些命令会静默执行。它们会创建一个新设备节点，名称与您的日志设备相同，只是末尾加上 *.journal*。运行 `gjournal label da3p5` 会创建 */dev/da3p5.journal*。从此以后，所有工作都将在日志设备节点上进行。

在日志设备上创建新的 UFS 文件系统。使用 `-J` 标志告诉 UFS 它是在 gjournal 上运行的。不要启用任何形式的软更新，包括软更新日志功能。这似乎有效一段时间……然后它就不行了。

将 gjournal 文件系统挂载为异步模式。适用于异步挂载的常规警告并不适用于 gjournal。然而，gjournal GEOM 模块会处理通常由文件系统管理的验证和完整性检查。

```
/dev/da3p5.journal /var/log ufs rw,async 2 2
```

文档中说，你可以将现有分区转换为使用 gjournal，只要你为日志设置了一个单独的分区，且现有文件系统的最后一个扇区为空。实际上，我发现现有文件系统的最后一个扇区总是已满，但如果你愿意，试着阅读 gjournal(8) 来获取详细信息。

#### *调整 UFS 设置*

你可以使用 tunefs(8) 查看和更改每个 UFS 文件系统的设置。这可以让你启用和禁用特性；此外，你还可以调整 UFS 如何写入文件、管理空闲空间以及使用文件系统标签。

##### 查看当前设置

使用 `-p` 标志和分区的当前挂载点或底层提供者查看文件系统的当前设置。

```
   # tunefs -p /dev/gpt/var
   tunefs: POSIX.1e ACLs: (-a)                                disabled
➊ tunefs: NFSv4 ACLs: (-N)                                   disabled
➋ tunefs: MAC multilabel: (-l)                               disabled
➌ tunefs: soft updates: (-n)                                 enabled
➍ tunefs: soft update journaling: (-j)                       enabled
➎ tunefs: gjournal: (-J)                                     disabled
   tunefs: trim: (-t)                                         disabled
   tunefs: maximum blocks per file in a cylinder group: (-e)  4096
   tunefs: average file size: (-f)                            16384
   tunefs: average number of files in a directory: (-s)       64
➏ tunefs: minimum percentage of free space: (-m)              8%
   tunefs: space to hold for metadata blocks: (-k)            6408
   tunefs: optimization preference: (-o)                      time
➐ tunefs: volume label: (-L)
```

许多可用的设置与特定的安全功能相关，而这些我们并未涉及。像 MAC 限制 ➋ 和各种 ACL 类型 ➊ 的话题充满了整本书。但我们可以看到，这个文件系统使用了软更新 ➌ 和软更新日志功能 ➍，但并未使用 gjournal ➎。我们获得了最小的空闲空间 ➏。最后，我们有一个不存在的 UFS 标签 ➐。我们得到了关于文件系统几何结构和块大小的一堆信息。

使用 tunefs(8) 在未挂载的文件系统上更改任何这些设置。方便的是，tunefs(8) 会显示每个设置对应的命令行标志。我通常会在更改文件系统设置之前启动单用户模式。

你可能会注意到，你可以调整各种文件系统内部设置，如块排列和文件系统几何结构。但请不要这么做。在超过二十年的 FreeBSD 使用过程中，我从未见过有人通过调整这些设置来改善他们的情况。反而，我见过很多人调整这些设置并最终让自己陷入困境。

但让我们来看看你实际上可能需要启用和禁用的设置。

##### 软更新和日志功能

使用 `-j` 标志启用或禁用文件系统上的软更新日志功能。启用该功能会自动启用软更新。

```
# tunefs -j enable /dev/gpt/var
Using inode 5 in cg 0 for 33554432 byte journal
tunefs: soft updates journaling set
```

若要禁用软更新日志功能，请使用 `disable` 关键字。

```
# tunefs -j disable /dev/gpt/var
Clearing journal flags from inode 5
tunefs: soft updates journaling cleared but soft updates still set.
tunefs: remove .sujournal to reclaim space
```

在一个未启用日志的文件系统上启用软更新日志只会让问题变得更加复杂。挂载该文件系统并删除文件系统根目录中的 *.sujournal* 文件。请注意，关闭日志功能并不会移除软更新功能。使用 `-n enable` 和 `-n disable` 可以开启和关闭软更新（没有日志功能）。

##### 最小空闲空间

UFS 会保留每个分区的 8% 空间，以便它有空间重新排列文件以提高性能。我在 “UFS 空间保留” 章节中进一步讨论了这一点，见 第 249 页。如果你想更改此百分比，可以使用 `-m` 标志。在这里，我告诉文件系统仅保留 5% 的磁盘空间。

```
# tunefs -m 5 /dev/gpt/var
tunefs: minimum percentage of free space changes from 8% to 5%
tunefs: should optimize for space with minfree < 8%
```

你现在应该有更多可用的磁盘空间了。同时，由于 UFS 总是尽可能紧密地打包文件系统，它会运行得更慢。

##### SSD TRIM

固态硬盘使用磨损平衡来延长其使用寿命。磨损平衡在文件系统通知 SSD 每个块不再使用时效果最佳。TRIM 协议负责此通知。通过 `-t` 标志在你的 SSD 支持的文件系统上启用 TRIM。

```
# tunefs -t enable /dev/gpt/var
tunefs: issue TRIM to the disk set
```

为了获得最佳效果，请为固态硬盘上的每个分区启用 TRIM。使用 `newfs -E` 在文件系统创建时启用 TRIM。

##### 为 UFS 文件系统添加标签

你可以通过 `-L` 标志为现有的文件系统添加 UFS 标签。

```
# tunefs -L scratch /dev/ada3s1e
```

不要混合使用 UFS 和 GPT 标签——这样只会让自己更混淆。

#### *扩展 UFS 文件系统*

你的虚拟机磁盘空间不足？扩大磁盘，并扩展最后一个分区来覆盖那个空间，正如在第十章中讨论的那样。那么，那个分区上的文件系统怎么办？这就是 growfs(8) 发挥作用的地方。

growfs(8) 命令将现有的 UFS 文件系统扩展到填充其所在的分区。给 growfs 提供一个参数，即文件系统的设备节点。你也可以使用标签。

```
# growfs /dev/gpt/var
It's strongly recommended to make a backup before growing the file system.
OK to grow filesystem on /dev/gpt/var from 50.0GB to 100GB? [Yes/No] ➊yes
super-block backups (for fsck_ffs -b #) at:
 19233792, 20516032, 21798272, 23080512, 24362752,
--snip--
```

当 growfs(8) 请求确认 ➊ 时，你必须输入完整的 `yes`。任何其他回答，包括许多程序接受的简单 `y`，都会取消操作。确认操作后，growfs(8) 将根据需要添加额外的块、超级块和 inode 来填充分区。

如果你不想让文件系统填满整个分区，你可以使用 `-s` 指定一个大小。在这里，我将这个分区扩展到 80GB。

```
# growfs -s 80g /dev/gpt/var
```

我强烈建议你将文件系统的大小设置为与底层分区相同，除非你想让你的同事打你一巴掌。^(2)

### UFS 快照

你可以在某一时刻对 UFS 文件系统进行快照；这被称为 *快照*。你可以对文件系统进行快照，删除并更改一些文件，然后从快照中复制未更改的文件。像 dump(8) 这样的工具使用快照来确保备份的一致性。UFS 快照不如 ZFS 快照那样强大或灵活，但在其限制范围内，它们是一个稳定、可靠的工具。

UFS 快照需要软更新，但与软更新日志不兼容。每个文件系统最多可以有 20 个快照。

快照让你访问编辑或删除的文件的旧版本。通过将文件作为内存设备挂载，你可以访问快照的内容。我将在第十三章中讨论内存设备。

#### *拍摄和销毁快照*

使用 mksnap_ffs(8) 创建快照。该程序假设你想创建当前工作目录所在文件系统的快照。将快照位置作为参数传入。传统上，快照会存放在文件系统根目录下的 *.snap* 目录中。如果你使用的是自动创建和删除快照的工具，比如 dump(8)，可以在这里找到你的快照文件。不过，如果你不喜欢这个位置，你可以将它们放在任何你想要的位置。这里，我对 */home* 文件系统创建了一个快照：

```
# cd /home
# mksnap_ffs .snap/beforeupgrade
```

快照会占用磁盘空间。你不能对一个已满的文件系统进行快照。

快照其实就是文件。删除文件就意味着删除快照。

#### *查找快照*

快照就是文件，你可以将它们放在文件系统的任何位置。这意味着很容易丢失它们。使用 find(1) 命令和 `-flags snapshot` 选项，可以在文件系统中查找所有快照。

```
# find /usr -flags snapshot
/usr/.snap/beforeupgrade
/usr/.snap/afterupgrade
/usr/local/testsnap
```

这是我的遗留快照！

#### *快照磁盘使用情况*

快照记录了当前文件系统与快照创建时文件系统之间的差异。每次在创建快照之后对文件系统进行的更改都会增加快照的大小。如果你删除了一个文件，快照会保留该文件的副本，以便你以后可以恢复它。

这意味着从包含快照的文件系统中删除数据并不会真正释放空间。如果你有一个 */home* 分区的快照，并删除了一个文件，那么删除的文件会被添加到快照中。

确保使用快照的文件系统始终有足够的空闲空间。如果你尝试创建快照并且 mksnap_ffs(8) 报告因为没有足够空间而无法创建，你可能已经有了 20 个该文件系统的快照。

### UFS 恢复与修复

从硬件故障到系统管理不当^(3)都可能损坏你的文件系统。UFS 的所有弹性技术旨在快速恢复数据完整性，但没有任何技术能完全保证完整性。

让我们来讨论 FreeBSD 如何保持每个 UFS 文件系统的整洁。

#### *系统关机：同步器*

当你关闭 FreeBSD 系统时，内核会将所有数据同步到硬盘，标记磁盘为干净状态，然后关机。这个过程是由一个名为 *syncer* 的内核进程完成的。在系统关机过程中，同步器会报告它在同步硬盘过程中的进度。

在关机过程中，你会看到同步器做出一些奇怪的操作。同步器会遍历需要同步到磁盘的 vnode 列表，使其能够支持所有文件系统，而不仅仅是 UFS。由于软更新的存在，写入一个 vnode 到磁盘可能会生成另一个脏 vnode，需进行更新。你会看到写入磁盘的缓冲区数量迅速从一个较高的值下降到一个较低的值，并且在系统真正同步硬盘时，可能会在零和一个较低的数字之间反复波动一两次。

如果同步器没有机会完成工作，或者由于你的笨拙操作同步器根本没有运行，那么你就会得到一个脏的文件系统。

#### *脏文件系统*

不，磁盘在使用时并不会变脏（尽管盘片上的灰尘会迅速损坏它，水也无济于事）。一个脏的 UFS 分区处于某种“中间状态”；操作系统已经请求写入数据到磁盘，但数据尚未完全写入物理介质。部分数据块可能已经写入，inode 可能已经编辑，但数据没有写入，或者两者的任意组合。实时文件系统几乎总是脏的。

如果主机的文件系统出现问题——例如由于系统崩溃或 Bert 绊倒电源线，系统再次启动时文件系统仍然是脏的。内核会拒绝挂载脏的文件系统。

清理文件系统可以恢复数据完整性，但并不一定意味着你所有的数据都已经写入磁盘。如果文件在系统崩溃时只写了一半，那么这部分文件就丢失了。没有什么可以恢复文件丢失的那一半，而磁盘上剩下的那一半基本上也没有用处。

日志化文件系统应该在 FreeBSD 尝试挂载它时自动恢复。如果文件系统无法恢复，或者你没有日志文件，你将需要使用传奇的 fsck(8)。

#### *文件系统检查：fsck(8)*

fsck(8)程序检查 UFS 文件系统，并尝试验证每个文件是否附加到正确的 inode 并且位于正确的目录。这就像验证数据库的引用完整性。如果文件系统只遭受了轻微损坏，fsck(8)可以自动恢复完整性并将文件系统重新投入使用。

修复一个损坏的文件系统需要时间和内存。一个 fsck(8)操作需要大约 700MB 的内存来分析一个 1TB 的文件系统。大多数计算机系统都有相对比例的内存和存储系统：很少有主机拥有 512MB 内存和 PB 级别的磁盘。但是你应该知道，有可能创建一个 UFS 文件系统大到系统没有足够的内存来修复它。

##### 手动 fsck 操作

有时，这个自动的重启时 fsck 检查会失败。当你检查控制台时，你会看到一个单用户模式提示符，并且系统要求你手动运行 fsck(8)。

先用`fsck -p`来*修整*文件系统。这个命令会自动修复一些较轻微的错误，不会询问你的确认。修整操作通常不会造成数据丢失，虽然偶尔会发生。这通常会成功，但如果不行，系统会要求你运行“完全 fsck”。

如果你在命令行中输入`fsck`，fsck(8)会验证磁盘上的每一个块和 inode。它会找到任何与其 inode 脱节的块，并猜测它们如何拼接以及应该如何附加。然而，fsck(8)可能无法识别这些文件属于哪个目录。

然后，fsck(8)会询问你是否要执行这些重新附加操作。如果你回答`n`，它会删除损坏的文件。如果你回答`y`，它会将丢失的文件添加到分区根目录下的*lost+found*目录中，文件名为一个数字。例如，你的*/usr*分区上的*lost+found*目录是*/usr/lost+found*。如果只有几个文件，你可以手动识别它们；如果有很多文件并且你在寻找特定的文件，像 file(1)和 grep(1)这样的工具可以帮助你按内容识别它们。

如果你回答`n`，那些未知数据将从文件系统中脱离。文件系统会保持脏状态，直到你通过其他方式修复它们。

##### 信任 fsck(8)

如果 fsck(8)无法弄清楚文件该去哪儿……你能吗？如果不能，你别无选择，只能信任 fsck(8)来恢复你的系统或从备份中恢复。

完整的 fsck(8)运行会检查每一个块、inode 和超级块，识别出每一个不一致之处。它会要求你输入`y`或`n`来批准或拒绝每一个修正。任何你拒绝的更改，你必须通过其他方式自行修复。你可能会花上几个小时在控制台上不断输入`y`、`y`、`y`。

所以我再问一遍：如果 fsck(8)无法修复问题，你能吗？

如果你不能，考虑使用`fsck -y`。`-y`标志告诉 fsck(8)尽可能自动重组这些文件，而无需你确认。它假设你会对所有问题回答“是”，即使是那些非常危险的问题。使用`-y`会自动触发`-R`，这告诉 fsck(8)重新尝试清理每个文件系统，直到成功或连续 10 次失败为止。这是治愈还是毁灭。你*有*备份吧？

**危险！**

运行`fsck -y`并不能保证安全。有时，在运行-current 或做其他愚蠢的事情时，我曾让`fsck -y`将整个文件系统的内容迁移到*lost+found*。那时恢复就变得很困难。话虽如此，在运行 FreeBSD-stable 和标准 UFS 文件系统的生产系统中，我从未遇到过问题。

你可以设置系统在启动时自动尝试`fsck -y`。然而，我不推荐这样做，因为如果我的文件系统有一丝机会进入数字涅槃，我希望知道。我要亲自输入这条命令，并感受听到磁盘转动时的忐忑不安。此外，发现你的系统被搞砸了却完全不知道是怎么回事，总是让人不愉快。如果你比我勇敢，可以在*rc.conf*中设置`fsck_y_enable="YES"`。

##### 避免使用 fsck -y

如果你不想使用`fsck -y`，你还有哪些选择？好吧，fsdb(8)和 clri(8)允许你调试文件系统，并将文件重定向到它们的正确位置。你可以将文件恢复到正确的目录和名称。然而，这很困难，^(4)，因此只推荐给秘密忍者文件系统大师使用。

##### 后台 fsck

后台 fsck 为 UFS 提供了一些类似日志文件系统的好处，而无需实际使用日志记录。你必须在没有日志记录的情况下使用软更新才能使用后台 fsck。（有日志记录的软更新远远优于后台 fsck。）当 FreeBSD 看到重启后后台 fsck 正在进行时，它会将脏磁盘挂载为读写模式。当服务器运行时，fsck(8) 会在后台运行，识别文件的松散部分并在幕后整理它们。

后台 fsck 实际上有两个主要阶段。当 FreeBSD 在初始启动过程中发现脏磁盘时，它会对磁盘进行初步的 fsck(8) 评估。fsck(8) 程序会决定是否可以在系统运行时修复损坏，或者是否需要进行完整的单用户模式 fsck 运行。通常情况下，fsck 认为可以继续，并允许系统启动。系统进入单用户模式后，后台 fsck 会以低优先级运行，逐个检查分区。fsck 过程的结果会出现在 */var/log/messages* 中。

你可以预期在后台 fsck 期间，任何需要磁盘活动的应用程序的性能都会很差。fsck(8) 程序占用了磁盘大部分的活动空间。虽然你的系统可能会变慢，但至少它会保持运行。

你 *必须* 在后台 fsck 后检查 */var/log/messages* 以查找错误。初步的 fsck 评估可能会出错，也许确实需要对分区进行完整的单用户模式 fsck。如果你发现这样的消息，请在几小时内安排停机时间来修复问题。尽管不方便，但安排定期停机比由于停电导致的非计划停机以及由此产生的单用户模式 `fsck -y` 要好。

#### *强制读写挂载脏磁盘*

如果你真的想强制 FreeBSD 在不使用后台 fsck 的情况下将脏磁盘挂载为读写模式，你是可以这么做的。你不会喜欢结果的，真的不会。正如在 mount(8) 中所描述的那样，某些读者会认为这是个好主意，除非他们知道为什么。使用 `-w`（读写）和 `-f`（强制）标志来挂载(8)。

挂载一个脏分区进行读写会损坏数据。注意这句话中没有出现像 *可能* 和 *也许* 这样的词。还要注意我没有使用 *可恢复*。挂载脏文件系统可能会让你的计算机崩溃。它可能会摧毁分区上剩余的所有数据，甚至可能彻底破坏底层文件系统。强制挂载脏文件系统进行读写是非常危险的。不要这么做。

#### *后台 fsck，fsck -y，前台 fsck，哎呀！*

所有这些不同的 fsck(8) 问题和情况可能会发生，但 FreeBSD 何时使用每个命令呢？FreeBSD 使用以下条件来决定何时以及如何对文件系统执行 fsck(8)：

+   如果文件系统是干净的，它会在没有 fsck(8) 的情况下挂载。

+   如果一个日志文件系统在启动时是脏的，FreeBSD 会从日志中恢复数据并继续启动。日志文件系统很少需要 fsck(8)。

+   如果一个没有软更新的文件系统在启动时处于脏状态，FreeBSD 会对其运行 fsck(8)。如果文件系统损坏严重，FreeBSD 会停止检查并要求你介入。你可以选择运行 `fsck -y` 或手动批准每个修复。

+   如果一个启用了软更新的文件系统在启动时处于脏状态，FreeBSD 会执行一个非常基础的 fsck(8) 检查。如果损坏较轻，FreeBSD 可以在多用户模式下使用后台 fsck(8)。

+   如果损坏严重，或者你不希望后台运行 fsck(8)，FreeBSD 会中断启动并请求手动运行 fsck(8)。

在配置你的 UFS 文件系统时，考虑恢复路径。

### UFS 空间保留

一个 UFS 文件系统的大小永远不会如你预期的那样大。UFS 会预留 8% 的文件系统空间用于即时优化。只有 root 用户可以写入超过这个限制的空间。这就是为什么一个文件系统似乎使用了超过 100% 可用空间的原因。为什么是 8%？这个数字来源于多年的经验和实际测试。在大多数文件系统上，8% 的预留空间不会造成太大问题，但随着文件系统的增大，这个数值会变得相当可观。在一个 1PB 的磁盘阵列上，UFS 会预留 80TB 空间。

UFS 的表现取决于文件系统的填充程度。在空文件系统上，它优化速度。一旦文件系统达到 92% 的容量（包括 8% 保留空间，占总大小的 85%），它会切换到优化空间利用率。大多数人也会做同样的事——一旦洗衣篮快满了，你还可以再塞些脏衣服进去，不过需要更多的时间和力气。UFS 会将文件碎片化，以更有效地利用空间。碎片会降低磁盘性能。随着空闲空间的减少，UFS 会越来越努力地提高空间利用率。一个满载的 UFS 文件系统运行速度大约是正常速度的三分之一。

你可能想使用 tunefs(8) 来减少 FreeBSD 保留的磁盘空间量。它的效果可能没有你想象的那么大。将保留空间减少到 5% 或更低，告诉 UFS 始终使用空间优化，并尽可能紧密地压缩文件系统。

增加保留空间百分比并不会提高性能。如果你增加保留空间百分比，导致文件系统显示已满，普通用户将无法写入文件。^(5)

保留空间可能会干扰像 NFS 这样的工具。某些可以通过 NFS 挂载 UFS 的操作系统会发现文件系统已满，并告知用户无法写入文件，尽管本地客户端可以写入文件。在故障排除时要记住这一点。

最好的做法是避免你的分区被填满。

### 分区有多满？

要查看每个 UFS 分区剩余的空间，使用 df(1) 命令。它会列出你系统中的分区、每个分区使用的空间以及挂载点。（不要在 ZFS 上使用 df(1)；我们将在下一章讨论原因。）

**$BLOCKSIZE**

关于 FreeBSD 的磁盘工具（包括 df(1)）有一个让人烦恼的地方，那就是它们默认以 512 字节块的形式提供信息。块在使用 512 字节物理块的微小磁盘上是没问题的，但今天它并不是一个有用的度量单位。环境变量 `$BLOCKSIZE` 控制 df(1) 输出的单位。默认的 *.cshrc* 和 *.profile* 文件将 `$BLOCKSIZE` 设置为 1KB，这使得 df(1) 显示千字节而不是块。

`-h` 和 `-H` 标志告诉 df(1) 生成人类可读的输出，而不是使用块。小的 `-h` 使用基 2 来生成 1,024 字节的兆字节，而大的 `-H` 使用基 10 来生成 1,000 字节的兆字节。通常，网络管理员和磁盘制造商使用基 10，而系统管理员使用基 2。只要你知道你选择的是哪一个，任意一种都可以。我是网络管理员，所以你得忍受我在这些示例中的偏见，尽管我的技术编辑不这么认为。

```
   # df -H
➊ Filesystem      Size    Used   Avail Capacity  Mounted on
➋ /dev/gpt/root   1.0G    171M    785M      18%  /
   devfs           1.0k    1.0k      0B     100%  /dev
   /dev/gpt/var    1.0G     64M    892M       7%  /var
   /dev/gpt/tmp    1.0G    8.5M    948M       1%  /tmp
➌ /dev/gpt/usr     14G   13.8G    203M      98%  /usr
```

第一行向我们展示了列标题➊，包括提供者名称、分区大小、已用空间、可用空间、已用空间的百分比以及挂载点。我们可以看到，标记为 */dev/gpt/root* ➋ 的分区只有 1GB 大，但仅使用了 171MB，剩下 785MB 可用。它已满 18%，并挂载在 */* 上。

如果你的系统像我的一样，磁盘使用情况似乎总是在没有明显原因的情况下不断增加。看看这里的 */usr* 分区 ➌。它已满 98%。你可以使用 `ls -l` 来识别单个大文件，但在系统的每个目录中递归地执行这个操作是不可行的。

du(1) 程序在单一目录中显示磁盘使用情况。它的初始输出令人畏惧，可能会吓跑没有经验的用户。在这里，我们使用 du(1) 来找出占用我主目录所有空间的原因：

```
# cd $HOME
# du
1       ./bin/RCS
21459   ./bin/wp/shbin10
53202   ./bin/wp
53336   ./bin
5       ./.kde/share/applnk/staroffice_52
6       ./.kde/share/applnk
--snip--
```

这会一直显示下去，列出每个子目录并给出其以块为单位的大小。每个子目录的总和都会显示——例如，*$HOME/bin* 的内容总共占用了 53,336 块，约为 53MB。我可以坐着让 du(1) 列出每个目录和子目录，但那样我将不得不浏览比我真正需要的更多的信息。而且，块这种单位并不是特别方便，尤其是当它们被左对齐打印时。

让我们整理一下这个输出。首先，du(1) 支持类似于 df 的 `-h` 标志。此外，我不需要查看每个子目录的递归内容。我们可以通过 du 的 `-d` 标志来控制显示的目录数量。这个标志接受一个参数，即你想要明确列出的目录数量。例如，`-d0` 只深入一层目录，并给出该目录中文件的简单小计。

```
# du -h -d0 $HOME
 14G    /home/mwlucas
```

我的主目录里有 14GB 的数据？让我们深入一层，找出最大的子目录。

```
# du -h -d1
 38K    ./bin
 56M    ./mibs
--snip--
 13G    ./startrekgifs
--snip--
```

显然，我必须去别处寻找存储空间，因为我主目录中的数据太重要，不能删除。也许我应该在这个主机下扩展虚拟磁盘。

如果你不太依赖于`-h`标志，可以使用 sort(1)来查找最大目录，命令如下：`du -kxd 1 | sort -n`。

### 添加新的 UFS 存储

无论你做多少规划，最终你的硬盘空间都会填满。你将需要添加新磁盘。在你能使用新硬盘之前，必须对其进行分区、创建文件系统、挂载这些文件系统，并将数据迁移到它们上面。

和初次安装时一样，给你新的磁盘分区和文件系统设计足够的思考。安装时正确分区要比安装后再去重新分区（带有数据的）容易得多。

**备份，备份，再备份！**

在进行任何磁盘操作之前，务必确保你有完整的备份。一个粗心的错误就可能摧毁你的系统！虽然你不常计划重格式化根文件系统，但如果发生这种情况，你希望能够快速恢复。

#### *磁盘分区*

虽然你可以随意分区磁盘，但我建议新磁盘使用与主机其他磁盘相同的分区方案。一个磁盘使用 MBR 而另一个使用 GPT 会很麻烦。这个例子中我将使用 GPT。

决定如何划分磁盘。这是一个 1TB 的磁盘。100GB 将分配给扩展后的*/tmp*。我会为我的新数据库分区分配 500GB。剩余的空间将划分并标记为*emergency*。我不会在这个空间上创建文件系统；它是为了防止需要做完全内存转储或存放某些文件时用的。我将它放在数据库分区旁边，以便需要时可以扩展数据库分区。我可以选择不对紧急空间进行分区，但我希望它有一个 GPT 标签，这样我的同事系统管理员就知道这个空闲空间不是意外的。

从销毁磁盘上的任何分区方案开始，并创建一个 GPT 方案。

```
# gpart destroy -F da3
da3 destroyed
# gpart create -s gpt da3
da3 created
```

现在创建你的 100GB */tmp*和 500GB 数据分区，并将剩余空间放入紧急分区。

```
# gpart add -t freebsd-ufs -l tmp -s 100g da3
da3p1 added
# gpart add -t freebsd-ufs -l postgres -s 500g da3
da3p2 added
# gpart add -t freebsd-ufs -l emergency da3
da3p3 added
```

使用`gpart show`检查你的工作。

```
# gpart show -lp da3
=>        40  1953525088    da3  GPT  (932G)
          40   209715200  da3p1  tmp  (100G)
   209715240  1048576000  da3p2  postgres  (500G)
  1258291240   695233888  da3p3  emergency  (332G)
```

在每个分区上创建文件系统。

```
# newfs -j /dev/gpt/tmp
# newfs -j /dev/gpt/postgres
```

由于*/tmp*在每次启动时都会被清空，我更倾向于不在*/tmp*上使用软更新日志。相反，我会将*/tmp*挂载为异步，并在启动时运行`newfs /dev/gpt/tmp`。很多时候，newfs(8)比 rm(1)更快。

#### *配置/etc/fstab*

现在，告诉*/etc/fstab*关于你的文件系统。我们在第十章中讨论了*/etc/fstab*的格式。

```
/dev/gpt/postgres  /usr/local/etc/postgres ufs  rw  0  2
/dev/gpt/tmp       /tmp                    ufs  rw  0  2
```

FreeBSD 将在启动时识别这些文件系统，或者你可以在命令行上挂载这些新分区。不过，暂时不要重启或挂载分区。首先，你需要将文件迁移到这些文件系统中。

#### *将现有文件安装到新磁盘*

很可能你打算让新的磁盘替换或细分现有分区。你需要将新分区挂载到临时挂载点，将文件移动到新磁盘，然后在所需位置重新挂载分区。虽然*/tmp*没有任何文件，但如果我们正在安装新的数据库文件系统，我们大概有数据库文件需要放在那里。

在移动文件之前，关闭任何正在使用它们的进程。你不能成功地复制正在被更改的文件。如果你要移动数据库文件，请关闭数据库。如果你要移动邮件队列，请关闭所有邮件程序。这也是我推荐在单用户模式下进行所有新磁盘安装的主要原因之一。

现在将你的新分区挂载到一个临时挂载点。这正是*/mnt*的用途所在。

```
# mount /dev/gpt/postgres /mnt
```

现在你必须将文件从当前位置移动到新磁盘，而不更改它们的权限。这用 tar(1)非常简单。你可以将现有数据打包到磁带或文件中，并在新位置解包，但这有点笨重。通过将一个`tar`管道传递给另一个来避免中间步骤。

```
# tar cfC - /old/directory . | tar xpfC - /tempmount
```

如果你在派对上不讲 Unix，这看起来相当惊人。让我们拆解一下。首先，我们进入旧目录并将所有内容打包（tar）。然后，将输出通过管道传输到第二个命令，该命令在新目录中提取备份。当此命令完成时，你的文件将安装到新的磁盘上。例如，要将*/usr/local/etc/postgres*移动到临时挂载在*/mnt*的新分区，你可以执行以下操作：

```
# tar cfC - /usr/local/etc/postgres . | tar xpfC - /mnt
```

检查临时挂载点，确保你的文件确实在那里。一旦你确认文件已正确移动，删除旧目录中的文件，并将磁盘挂载到新位置。例如，在将文件从*/usr/local/etc/postgres*复制后，你将运行：

```
# rm -rf /usr/local/etc/postgres
# umount /mnt
# mount /usr/local/etc/postgres
```

现在你可以恢复正常操作了。我建议重启以验证一切是否按照你的预期恢复。

#### *可堆叠挂载*

也许你不关心你的旧数据；你只想分割现有的文件系统以获得更多空间，并打算从备份中恢复数据。那也没问题。所有 FreeBSD 文件系统都是*可堆叠*的。这是一个高级概念，日常系统管理中并不特别有用，但当你尝试将一个分区分割成两个时，它可能会让你措手不及。

假设，例如，你的数据在*/usr/src*中。查看磁盘上已使用的空间，然后在*/usr/src*上挂载一个新的空分区。如果你之后查看该目录，你会发现它是空的。

问题在于：旧的文件系统仍然保留着原始数据。新的文件系统被挂载在“上方”，因此你只看到新的文件系统。旧的文件系统在你移动数据之前没有更多的可用空间。如果你卸载新的文件系统并再次检查目录，你会惊讶地发现数据奇迹般恢复！新的文件系统遮盖了下层的文件系统。

虽然你看不见数据，但旧文件系统上的数据仍然占用空间。如果你添加了一个文件系统来获取空间，并且将一个新文件系统挂载到旧文件系统的某一部分上，你将无法释放原始文件系统上的空间。这个教训是：即使你正在从备份中恢复数据，也要确保将原始磁盘上的数据移除，以便回收磁盘空间。

既然你已经掌握了 UFS，让我们来探索一下 ZFS。
