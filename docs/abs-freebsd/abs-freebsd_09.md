## 9

**保护您的系统**

![image](img/common01.jpg)

保护您的系统意味着确保计算机的资源仅供授权人员用于授权的目的。即使您的系统上没有重要数据，您仍然拥有宝贵的 CPU 时间、内存和带宽。许多曾认为自己的系统不重要，不会有人去破解的人，最终发现自己成了一个无意中的中继站，成为了攻击的工具，导致某个大型公司瘫痪。你不希望有一天早上醒来，听到执法人员破门而入的声音，因为您的不安全计算机被用来破解了某个银行。

当然，有比某个小屁孩接管您的服务器更糟糕的事情——比如邻里的高利贷者把你的两条腿打断。发现您组织的网页上现在写着“哈哈，你被 r00t 了！”是个相当强劲的竞争者，可能排得上第二。即便是更容易理解的入侵也会带来巨大的麻烦。我曾参与过的多数实际入侵事件（我不是攻击者，而是作为受害者的顾问）都来自那些有政府审查制度的国家，流量分析显示攻击者其实只是想获取不受限制的新闻网站访问权限。虽然我完全同情这些人，但当我依赖服务器的稳定运行来经营我的业务时，他们的入侵是不可接受的。

在过去几年里，接管远程计算机变得容易多了。可以通过搜索引擎找到一些点选即用的程序，用来颠覆计算机。当一个聪明的攻击者编写了一个漏洞时，数千个无聊的青少年可以下载它，并让我们其他人生活得更困难。即使系统上的数据毫无价值，您仍然必须保护系统的资源。

一般来说，操作系统本身并不会被攻破；而是运行在操作系统上的程序会被攻破。即便是世界上最为偏执、默认安全的操作系统，也无法保护写得不好的程序免受其自身问题的影响。偶尔，某个程序可能与操作系统以某种方式交互，从而实际上危及操作系统的安全。其中最著名的就是*缓冲区溢出*，在这种情况下，攻击者的程序会直接被转储到 CPU 的执行空间，操作系统随后执行它。FreeBSD 进行了广泛的审计，消除了缓冲区溢出以及其他众多众所周知的安全问题，但这并不意味着它们已经被彻底根除。新功能和程序不断出现，它们可能以意想不到的方式与旧功能或彼此之间发生交互。

FreeBSD 提供了许多工具来帮助你保护系统免受内外部攻击者的侵害。虽然这些工具中的任何一个单独使用都不足够，但它们都是可取的。将你关于系统安全的所有知识视为工具箱中的工具，而不是解决所有问题的答案。例如，虽然仅仅提高系统的安全级别不会让你的系统变得安全，但结合合理的权限、文件标志、定期修补、密码控制以及所有构成良好安全策略的其他措施时，它会起到作用。我们将在第十九章中介绍更多的高级安全工具，但如果没有在这里讨论的基本保护措施，这些工具无法帮助你保护系统。

### 敌人是谁？

我们将潜在的攻击者随便分为四组：脚本小子、不满的用户、僵尸网络和有技术的攻击者。你会在专门讨论安全的书籍中找到更详细的分类，但这不是你要关注的内容。这些类别容易解释，容易理解，并涵盖了你可能遇到的 99%的攻击者。

#### *脚本小子*

最多的人类攻击者，*脚本小子*，并不是系统管理员。他们没有技能。他们下载基于点击操作的攻击程序，寻找易受攻击的系统。他们相当于抢包的小偷，专门欺负那些手提包稍微松懈的老太太。幸运的是，脚本小子很容易防范：只需保持软件更新，并遵循良好的计算机操作规范。像蝗虫一样，脚本小子容易被打败，但他们实在是*太多*了！

#### *不满的用户*

第二类群体，你的用户，是导致大多数安全问题的根源。你组织的员工最有可能知道安全漏洞的位置，认为规则不适用于他们，并且有时间去破坏你的安全。如果你告诉某个员工公司政策禁止他访问某个计算机资源，而该员工认为他应该有权访问，那么他很可能会寻找绕过限制的方法。任何认为自己特别到规则不适用的人都是安全风险。更糟糕的是，当一个知道所有丑事的员工生气时，坏事可能会发生。你可能已经修补了所有服务器，并安装了极为反人类的防火墙，但如果任何知道密码的人是*Current93*，能够拨打后端调制解调器，你就麻烦了。

阻止这些人的最佳方式就是简单地不要疏忽大意。不要把项目半途而废或文档不全地留着。当有人离开公司时，禁用他的账户，修改所有的管理员密码，通知所有员工该人的离职，并提醒他们不要与该人分享机密信息。制定一套具有实际违规惩罚的计算机安全政策，并由人力资源部门执行。并且，清除那些不安全的调制解调器、运行在奇怪端口上的未记录的 telnet 服务器，或者你当初匆忙设置的、以为没人会发现的黑客后门。

#### *僵尸网络*

僵尸网络的数量超过了上述任何一类，但它们不是人类。它们是被恶意软件感染并从一个中心点控制的机器。僵尸网络可以包括数百万台机器。恶意软件的作者控制着这些僵尸网络，并利用它们做任何事情，从寻找更多易受攻击的主机到发送垃圾邮件或突破安全网站。大多数僵尸网络由 Windows 和 Linux 机器组成，但并不排除 FreeBSD 操作系统也可能被纳入僵尸网络中。

幸运的是，僵尸网络防御和脚本小子防御非常相似；保持软件更新并遵循良好的计算实践会带来很大帮助。

#### *有动机的熟练攻击者*

最危险的群体——熟练攻击者——是那些有能力的系统管理员、安全研究员、渗透专家和犯罪分子，他们想要访问你的特定资源。如今，计算机渗透是一个有利可图的犯罪领域，尤其是当受害者拥有可以用于分布式拒绝服务（DDoS）攻击或大规模垃圾邮件传输的资源时。妥协一个网站农场并将其转化为恶意用途是有利可图的。如果你有有价值的公司机密，可能会成为这些入侵者的目标。如果这些人*真的*想要突破你的网络，他很可能会成功。

尽管如此，能够阻止前三类人群的安全措施会改变熟练攻击者的战术。他将不再通过网络突破你的计算机，而是得以伪装成一名电信维修工，背着一个数据包嗅探器出现在你家门口，或是翻垃圾桶找寻写满密码的旧便签。这大大增加了他的风险，可能会使得入侵变得不值得冒险。如果你能让入侵者的突破计划看起来像一部好莱坞剧本，*不管他对你的网络了解多少*，那么你的安全措施可能已经相当不错了。

**黑客、入侵者及相关渣滓**

你会经常听到“*黑客*”这个词用来描述那些闯入计算机的人。这个词根据说话者的不同有不同的含义。在技术领域，黑客是指那些对技术内部运作感兴趣的人。有些黑客对所有内容都有兴趣，而其他人则专注于某一特定领域。在开源社区中，*黑客*是一个尊重的称呼。FreeBSD 的主要技术邮件列表是* FreeBSD-hackers@FreeBSD.org*。然而，在大众媒体中，黑客通常是指那些闯入计算机系统的人，故事就到此为止。

为了减少混淆，我建议完全避免使用“*黑客*”这个词。在本书中，我称那些闯入计算机的人为*入侵者*。* 技术高手可以被称为各种名字，但他们通常不会反对“哦，伟大而强大的存在”。

* 两个版本之后，我的编辑*仍然*不允许我当面说出我对他们的看法。

### FreeBSD 安全公告

防范任何攻击者的最佳方法是保持系统的最新状态。这意味着你必须知道何时为系统打补丁，打什么补丁，以及如何打。一个过时的系统是脚本小子的最佳伙伴。

FreeBSD 项目包含一些志愿者，他们专门负责审计源代码，并监控基础操作系统及附加软件的安全问题。这些开发人员维护着一个非常低流量的邮件列表，* FreeBSD-security-notifications@FreeBSD.org *，订阅该列表是一个好主意。虽然你可以通过其他邮件列表来获取一般公告，但安全通知列表是获取 FreeBSD 特定信息的唯一来源。要订阅安全通知邮件列表，请参见* [`lists.freebsd.org/`](http://lists.freebsd.org/)*。FreeBSD 安全团队会在该邮件列表中一有新的安全公告就发布。

仔细阅读安全公告，并迅速采取措施应对影响到你的那些问题，因为你可以确定脚本小子正在寻找易受攻击的机器。正如第十八章所讨论的，FreeBSD 使得应用安全补丁变得非常简单。

### 用户安全

记得我说过，你自己的用户是你最大的安全隐患吗？现在你将学习如何管好这些“小家伙”。FreeBSD 提供了多种方式，让用户能够完成工作，而不需要让他们在系统上为所欲为。我们将在这里讨论一些最重要的工具，从添加用户开始。

#### *创建用户账户*

FreeBSD 使用标准的 Unix 用户管理程序，如 passwd(1)、pw(8)和 vipw(8)。FreeBSD 还包含了一个友好的交互式用户添加程序 adduser(8)。当然，只有*root*用户可以添加其他用户。只需在命令行中输入`adduser`即可进入交互式命令行。

当你第一次运行 adduser(8) 时，它会提示你为所有新用户设置适当的默认值。使用以下示例会话来帮助你为系统确定合适的默认值。

```
   # adduser
➊ Username: xistence
➋ Full name: Bert Reger
➌ Uid (Leave empty for default):
```

用户名 ➊ 是账户的名称。我系统上的用户会获得一个由他们的名字首字母、中间名首字母和姓氏组成的用户名。你可以根据自己想出的方案来分配用户名。在这里，我让用户自己选择用户名，这种宽容通常会让我后悔。全名 ➋ 是用户的真实姓名。FreeBSD 接着让你选择一个数字化的用户 ID (UID) ➌。FreeBSD 从 1000 开始编号 UID；虽然你可以更改此设置，但所有低于 1000 的 UID 都保留给系统使用。我建议直接按 ENTER 键选择下一个可用的 UID。

```
➊ Login group [xistence]: 
➋ Login group is xistence. Invite xistence into other groups? []: www
➌ Login class [default]: 
➍ Shell (sh csh tcsh nologin) [sh]: tcsh
➎ Home directory [/home/xistence]: 
➏ Home directory permissions (Leave empty for default):
```

用户的默认组 ➊ 非常重要——记住，Unix 权限是根据所有者和组设置的。FreeBSD 默认将每个用户分配到自己的组，通常是大多数设置中最合理的方式。关于系统管理的大部头书籍提供了几种分组方案——随时使用任何符合你需求的方案。如果适当，你现在可以将该用户添加到其他组 ➋，除了主组之外。

登录类 ➌ 指定了用户可以访问的资源级别。我们稍后会在本节中讨论登录类。

Shell ➍ 是命令行环境。虽然系统默认是 */bin/sh*，我更喜欢 tcsh。^(1) 如果你对其他 shell 深有依赖，随时可以使用它。精通的用户可以更改自己的 shell。

家目录 ➎ 是用户文件在磁盘上的存放位置。该用户及其主组拥有此目录。如果需要，你可以在目录上设置自定义权限 ➏，通常是为了防止其他用户查看该用户的目录。

```
➊ Use password-based authentication? [yes]: 
➋ Use an empty password? (yes/no) [no]: 
➌ Use a random password? (yes/no) [no]: y
➍ Lock out the account after creation? [no]: n
```

密码选项提供了一定程度的灵活性。如果所有用户都熟悉基于密钥的 SSH 身份验证，也许你可以不用密码。与此同时，其余的人都得依赖密码 ➊。

如果你希望用户通过控制台设置自己的密码，可以使用空密码 ➋。第一次连接到该账户的人将设定密码。将空密码作为一种设置，与在氢气飞艇内吸烟一样不太明智。

另一方面，随机密码 ➌ 对于新账户来说是一个好主意。FreeBSD 提供的随机密码生成器足够日常使用。随机密码通常很难记住，这会促使用户尽快更改密码。

当账户被锁定 ➍ 时，没人可以用它登录。这通常是适得其反的。

输入所有信息后，adduser 会将所有内容反馈给您进行审查和确认或拒绝。一旦您确认，adduser 会验证账户设置并为您提供随机生成的密码。然后，它会创建用户的主目录，从*/etc/skel*复制 shell 配置文件，并询问您是否要设置另一个用户。

#### *配置 Adduser: /etc/adduser.conf*

在某些 Unix 系统上创建新用户需要手动编辑*/etc/passwd*，重建密码数据库，编辑*/etc/group*，创建主目录，设置该主目录的权限，安装 dotfiles，等等。这使得处理本地自定义变得例行化——如果您手动设置所有内容，就可以轻松管理本地账户设置。adduser(8)程序提供了一组合理的默认值。对于有不同需求的网站，*/etc/adduser.conf*允许您将这些需求设置为默认值，同时保持高度的自动化。要创建*adduser.conf 文件*，请运行`adduser -C`并回答相关问题。

```
➊ Uid (Leave empty for default):
➋ Login group []: 
➌ Enter additional groups []: staff
➍ Login class [default]: staff
➎ Shell (sh csh tcsh nologin) [sh]: tcsh
➏ Home directory [/home/]: /nfs/u1/home 
➐ Use password-based authentication? [yes]: 
➑ Use an empty password? (yes/no) [no]: 
➒ Use a random password? (yes/no) [no]: yes
➓ Lock out the account after creation? [no]: no
```

您可能希望从 1,000 以外的地方开始编号 UID。如果您想要更高的初始 UID，请在`Uid`字段中输入 ➊。不要从 1,000 以下开始。

登录组 ➋ 是默认的用户组。空的登录组意味着用户账户默认会有一个独立的唯一用户组（FreeBSD 默认设置）。

您可以指定新账户默认属于的任何其他用户组 ➌，以及登录类 ➍。我将这两个设置为`staff`，这样所有新用户都会被添加到该组并分配该类。

为您的用户选择一个默认的 shell ➎。

您的主目录位置 ➏ 可能与独立的 FreeBSD 标准有所不同。在这个例子中，我指定了当多个用户在多台机器上有账户时，常用的 NFS 挂载的主目录样式。

选择新用户的默认密码行为。您可以指定用户是否应该使用密码 ➐，以及初始密码是应该为空 ➑ 还是随机生成 ➒。

最后，决定新账户是否默认锁定 ➓。

您可以在 adduser.conf(5)中找到更多配置设置。虽然您可以在这里设置账户特征，但该文件的格式被认为是 adduser(8)的内部格式。设置名称可能会随着任何 FreeBSD 版本的发布而变化。要更改*adduser.conf*，请重新运行`adduser -C`。

#### *编辑用户*

管理用户不仅仅是创建和删除账户。您需要不时地更改这些账户。虽然 FreeBSD 提供了多个工具用于编辑账户，但最简单的工具是 passwd(1)、chpass(1)、vipw(8)和 pw(8)。这些工具作用于紧密关联的文件*/etc/master.passwd*、*/etc/passwd*、*/etc/spwd.db*和*/etc/pwd.db*。我们将从这些文件开始，然后回顾编辑这些文件的常用工具。

文件 */etc/master.passwd*、*/etc/passwd*、*/etc/spwd.db* 和 */etc/pwd.db* 都包含用户账户信息。每个文件的格式和用途略有不同。文件 */etc/master.passwd* 是权威的用户账户信息来源，并包含加密形式的用户密码。普通用户没有权限查看 */etc/master.passwd* 的内容。然而，普通用户需要访问基本的账户信息；否则，未经授权的系统程序怎么识别用户呢？文件 */etc/passwd* 列出了用户账户，移除了所有特权信息（如加密密码）。任何人都可以查看 */etc/passwd* 的内容以获取基本的账户信息。

许多程序需要账户信息，而解析文本文件非常缓慢。在如今笔记本超级计算机的时代，*缓慢* 这个词不再那么有意义，但在迪斯科风靡一时的年代，这确实是一个非常实际的问题。正因如此，BSD 衍生的系统将 */etc/master.passwd* 和 */etc/passwd* 构建为一个数据库文件。（其他类 Unix 系统在不同的文件中有类似的功能。）文件 */etc/spwd.db* 直接来自 */etc/master.passwd*，并包含敏感的用户信息，但只有 root 可以读取。文件 */etc/pwd.db* 则可以被任何人读取，但它只包含 */etc/passwd* 中的有限信息。

每当任何标准的用户管理程序更改 */etc/master.passwd* 中的账户信息时，FreeBSD 会运行 pwd_mkdb(8) 来更新其他三个文件。例如，三个程序 passwd(1)、chpass(1) 和 vipw(8) 都允许你修改主密码文件，并且这三个程序都会触发 pwd_mkdb 来更新相关文件。

##### 更改密码

使用 passwd(1) 来更改密码。用户可以更改自己的密码，而 root 用户可以更改任何人的密码。要更改自己的密码，只需在命令提示符下输入 `passwd`。

```
# passwd
Changing local password for mwlucas
Old Password:
New Password:
Retype New Password:
```

在更改自己的密码时，passwd(1) 会首先要求输入当前密码。这是为了确保没有其他人可以在你不知情的情况下更改你的密码。虽然走开时注销总是个好习惯，但当你没有注销时，passwd(1) 中的这个简单检查可以防止恶作剧者真正让你烦恼。然后输入两次新密码，操作就完成了。当你是超级用户并且想更改其他用户的密码时，只需在 passwd 后给出用户名作为参数。

```
# passwd mwlucas
Changing local password for mwlucas
New Password:
Retype New Password:
```

请注意，root 用户不需要知道用户的旧密码；root 用户可以以任何方式更改系统中的任何用户账户。

**用户管理与 $EDITOR**

像 chpass 和 vipw 这样的用户管理工具（以及许多其他系统管理工具）会弹出一个文本编辑器窗口，让你进行修改。这些工具通常会检查环境变量`$EDITOR`，以查看你偏好的文本编辑器。`$EDITOR`允许你默认使用 vi、Emacs 或其他已安装的编辑器。我推荐 Vigor，它是 vi(1)的一个克隆，具有动画回形针帮助系统，这可能会让习惯使用老版 Microsoft Office 的用户感到更舒适。

##### 使用 chpass(1)更改账户

账户除了密码外，还有更多关联的信息。chpass(1)工具允许用户编辑他们能接触到的账户信息。例如，如果我以普通用户身份运行 chpass(1)，我会看到一个编辑器，里面包含以下内容：

```
#Changing user information for mwlucas.
Shell: /bin/tcsh
Full Name: Michael W Lucas
Office Location:
Office Phone:
Home Phone:
Other information:
```

我可以编辑账户中的六个信息字段。第一个是我的 shell，可以设置为*/etc/shells*中列出的任何 shell（参见 “Shells 和 */etc/shells*” 第 178 页）。我可以更改我的全名；也许我想列出我的全名中的中间名，或者可能我希望其他系统用户称我为*斯卡比斯先生*。我还可以更新我的办公位置和办公电话，以便同事们能轻松找到我。这是 BSD 在大学校园中发展时非常有用的功能，那时系统用户很少知道彼此的物理位置。现在我们有了广泛的在线目录和更多的计算机，这个功能就不那么有用了。我通常将我的家庭电话号码设置为 911（在英国为 999），并在`其他`字段中填写一些个人信息。

还要注意，作为普通用户，我*无法*更改的内容。系统管理员设置了我的主目录，即使系统有一块新硬盘，空间足够存放我的 MP3 收藏，我也不能更改它。我的 UID 和 GID 号也类似，是由系统或系统管理员分配的。

另一方面，如果我运行`chpass xistence`，其提升的权限给了我一个完全不同的视角。

```
   #Changing user information for xistence.
   Login: xistence
➊ Password: $6$D9b4FFD0kHK2sPSP$bXUFTQqV/QposXw2KTlswzpvoz4HBo8...
   Uid [#]: 1001
   Gid [# or name]: 1001
   Change [month day year]:
   Expire [month day year]:
   Class:
   Home directory: /home/xistence
   Shell: /bin/tcsh
   Full Name: Bert Regeer
   Office Location:
   Office Phone:
   Home Phone:
   Other information:
```

作为 root，你可以对那个可怜的用户做任何你想做的事情。将他的登录名改为*megaloser*只是你能制造的混乱的开始。你甚至可以访问该用户的哈希密码 ➊。除非你擅长计算密码哈希，否则不要修改这个字段。使用 passwd(1)来更安全、更可靠地更改用户的密码。你也可以更改用户的主目录，尽管 chpass(1)不会移动用户的文件；你必须手动复制它们。

你还可以设置密码更改和账户过期的日期。如果你刚刚更改了一个用户的密码，并希望他在第一次登录时更改密码，密码过期功能就非常有用。账户过期功能在某人请求账户时尤其有用，尤其是当他们坚持只需要账户使用有限时间时。你可能会忘记删除该账户，但 FreeBSD 永远不会忘记。这两个字段都采用 *月 日 年* 的日期格式，但只需要输入月份的前三个字母。例如，要让一个用户的密码在 2028 年 6 月 8 日到期，我会在 `Change` 空间输入 `Jun 8 2028`。一旦用户更改了密码，密码过期字段会被清空，但只有系统管理员才能延长账户的过期日期。

##### 大锤：vipw(8)

虽然 chpass(1) 适用于编辑单个账户，但当你必须编辑多个账户时该怎么办？假设你的系统有数百个用户，并且有一个全新的硬盘用于主目录分区。你真想执行 chpass(1) 数百次吗？这时，vipw(8) 就派上用场了。

直接使用 vipw(8) 编辑 */etc/master.passwd*。编辑完成后，vipw(8) 会检查密码文件的语法，确保你没有破坏任何内容。然后，它会保存新的密码文件并运行 pwd_mkdb(8)。尽管 vipw(8) 可以保护你的密码文件免受许多基本错误，但如果你足够聪明，仍然可能会弄糟。你必须了解密码文件的格式，才能正确使用 vipw(8)。

如果 */etc/master.passwd* 中的信息与其他文件中的信息冲突，则以 */etc/master.passwd* 中的信息为准。例如，*/etc/master.passwd* 中显示的主要组是正确的，即使 */etc/group* 中没有将该用户列为成员。这种“*master.passwd* 永远是正确的”逻辑深深植根于用户管理中。

*/etc/master.passwd* 中的每一行都是一个账户记录，包含 10 个由冒号分隔的字段。这些字段如下：

**用户名**

该字段是系统管理员创建的账户名，或者是安装时为提供某些系统服务而创建的用户名。FreeBSD 包括用于系统管理的用户，如 root、daemon、games 等。每个用户拥有基础系统的一部分。FreeBSD 还提供了用于常见服务的账户，如为 web 服务器保留的 *www* 用户。附加软件可能还会添加自己的系统账户。

**加密密码**

第二个字段是加密密码。系统用户没有密码，因此你不能以他们的身份登录。用户账户在此处有一串看起来随机的字符。

**用户 ID**

第三个字段是*用户 ID 数字*，或*UID*。每个用户都有一个唯一的 UID。

**组 ID**

同样，第四个字段是*组 ID 数字*，或*GID*。这是用户的主要组。通常，这与 UID 相同，且该组的名称与用户名相同。

**用户类别**

下一个字段是用户在 */etc/login.conf* 中定义的用户类别（参见 “限制系统使用” 第 188 页(page 188)）。

**密码过期**

这个字段与通过 chpass(1) 设置的密码过期日期相同，不过这里的时间以自纪元以来的秒数存储。使用 `date -j` 和 `+%s` 输出格式可以将真实日期转换为纪元秒数。要将 2018 年 6 月 1 日午夜转换为纪元秒数，可以运行 `date -j 201806010000 '+%s'`。

**账户过期**

这个字段允许你在某一天使账户自动关闭。只需像设置密码过期一样设置账户过期日期。

**个人数据**

这个字段也被称为 *gecos* 字段，原因有些历史上的晦涩。它包含用户的真实姓名、办公室号码、工作电话和家庭电话，所有内容以逗号分隔。不要在此字段中使用冒号；*/etc/master.passwd* 保留冒号作为字段分隔符。

**用户的主目录**

第九个字段是用户的主目录。默认情况下为 */home/<username>*，但你可以将其移动到任何适当的位置。更改此字段时，你还需要移动实际的主目录及其文件。没有主目录的用户默认无法登录，不过可以通过 *login.conf* 中的 `requirehome` 设置进行更改。

**用户的 Shell**

最后的字段是用户的 shell。如果这个字段为空，系统会分配给用户老式的 */bin/sh*。

虽然 chpass(1) 让你可以修改单个用户账户，但 vipw(8) 让你可以操作整个用户库。使用时要小心！

##### 删除用户

rmuser(8) 程序用于删除用户账户。你会被提示输入要删除的用户名，并询问是否删除该用户的主目录。其实你只需要做这些，毕竟销毁比创建要简单得多。

##### 使用 pw(8) 脚本

pw(8) 命令提供了一个强大的命令行界面来管理用户账户。虽然 useradd(8) 会以友好的方式引导你设置账户，但 pw(8) 让你可以在一行命令中指定所有内容。我发现 pw(8) 对日常使用来说有些笨重，但如果你管理很多用户账户，它是无价的。

我确实使用 pw(8) 来锁定账户。虽然被锁定的账户仍然存在，但没人能登录。我曾在客户拖欠账单时有效使用这个方法；当用户无法登录时，他们通常会很快联系，但他们的网站依然在线，邮件也继续积累。

```
# pw lock xistence
```

当 Bert 道歉时，我将解锁他的账户。

```
# pw unlock xistence
```

如果你需要脚本来管理用户，强烈建议阅读 pw(8) 的手册页。

### Shell 和 /etc/shells

*Shell* 是提供用户命令提示符的程序。不同的 shell 行为各异，提供不同的快捷方式和功能。许多人对特定的 shell 非常依赖，如果他们的 shell 在某个系统上不可用，常常会抱怨。软件包集合中包含了许多不同的 shell。

文件 */etc/shells* 包含所有合法用户 shell 的列表。当你从端口或软件包安装一个 shell 时，它会在 */etc/shells* 中添加一个相应的条目。如果你从源代码编译自己的 shell，而没有使用 FreeBSD 端口，你必须在 */etc/shells* 中列出该 shell 的完整路径。

如果用户的 shell 没有列在 */etc/shells* 中，FTP 守护进程将不允许用户通过 FTP 登录。如果你使用 */sbin/nologin* 作为仅限 FTP 使用的用户 shell，你必须将其添加到该文件中，尽管处理此类用户的更好方法是使用登录类，正如本章后面讨论的那样。

### root、用户组与管理

Unix 安全性被认为有些粗糙，因为一个超级用户，*root*，可以做任何事。其他用户只是低级的仆人，忍受着 root 对他们的束缚。问题在于，root 并没有很多不同种类的束缚，且无法很好地个性化这些束缚。虽然这话有一定道理，但一位称职的管理员可以通过组合用户组和权限，安全地解决几乎任何问题。

#### *根密码*

某些操作需要对系统的绝对控制，包括操作核心系统文件，如内核、设备驱动程序和身份验证系统。这些活动是为 root 用户设计的。

要使用根密码，你可以在控制台登录提示符下以 root 身份登录，或者，如果你是 *wheel* 组的成员，可以以自己的身份登录并使用切换用户命令 su(1)。（我们稍后会在本节中讨论用户组。）我建议使用 su；它会记录谁使用了它，并且可以在远程系统上使用。这个命令非常简单：

```
# su
Password:
#
```

接下来，使用 id(1) 命令检查你当前的用户 ID：

```
# id
uid=0(root) gid=0(wheel) groups=0(wheel), 5(operator)
#
```

现在你拥有了系统——我确实是指*拥有*它。考虑每一个按键；粗心大意可能会让你的硬盘恢复到未经格式化的原始状态，变成空旷的废土。而且，根密码要谨慎共享，如果需要分享，尽量少分享，因为任何拥有根密码的人都可以对系统造成无限的损害。

记住，只有在 *wheel* 组中的用户才能通过 su(1) 命令使用根密码成为 root。任何人都可以在系统控制台使用根密码，这也是为什么系统的物理保护至关重要。如果你把根密码交给一个没有物理访问控制台权限的普通用户，他们可以输入 `su` 命令，并多次输入根密码，但仍然无法成功。

这自然引出了一个问题：“谁需要 root 访问权限？”本书中讨论的许多配置都需要使用根密码。一旦系统正常运行，你可以大大减少或停止使用根密码。对于那些绝对需要 root 权限的任务，我推荐使用 sudo 包，可能还需要我的书《Sudo Mastery》（Tilted Windmill Press, 2013）。减少对 root 访问权限需求的最简单方法之一是通过正确使用用户组。

#### *用户组*

类 Unix 操作系统将用户分类为 *组*，每个组由执行相似管理职能的人员组成。系统管理员可以定义一个名为 *webmasters* 的组，将编辑网页的人员账户添加到该组，并设置与网页相关文件的权限，以便该组的成员可以编辑这些文件。她还可以创建一个名为 *email* 的组，将电子邮件管理员添加到该组，并相应地设置邮件相关文件的权限。以这种方式使用组是系统管理中一个强大且常被忽视的工具。

任何用户都可以通过 id(1) 查明自己所属的组。前面的示例显示了用户 root 属于 *wheel* 和 *operator* 组。然而，root 是一个特殊用户，几乎可以做任何事。这是我的账户，更加贴近普通用户的实际情况：

```
# id
uid=1001(mwlucas) gid=1001(mwlucas) groups=1001(mwlucas),0(wheel),68(dialer),1
0001(webmaster)
```

我的 UID 是 1001，用户名是 *mwlucas*。我的 GID，即主组 ID，也是 1001，且我的主组名为 *mwlucas*。这是系统中第一个用户的标准配置，即使是在后续的用户中，唯一变化的是分配给账户和主组的数字。更有趣的是我被分配到的其他组：除了我的主组，我还属于 *wheel*、*dialer* 和 *webmaster* 组。*wheel* 组的成员可以使用 root 密码成为 root，*dialer* 组的成员可以使用 tip(1) 而无需成为 root，*webmaster* 组的成员可以编辑本地系统上的网页文件。这些组在我的系统上具有特殊权限，作为这些组的成员，我继承了这些权限。

组信息在 */etc/group* 中定义。

##### /etc/group

文件 */etc/group* 包含所有组信息，除了用户的主组（该主组在 */etc/master.passwd* 中与用户账户一起定义）。*/etc/group* 中的每一行包含四个由冒号分隔的字段：组名、组密码、组 ID 号码和成员列表。

这是一个示例条目：

```
wheel:*:0:root,mwlucas,xistence
```

组名是一个对人类友好的名称。这个组名为 *wheel*。组名是任意的；如果你愿意，可以把一组用户称为 *lackeys*。选择能够让你了解组别用途的组名；尽管你可能会记得你的 *lackeys* 可能会编辑公司网页，但你的同事能理解这一点吗？

第二个字段，组密码，是一个好主意，但结果变成了安全噩梦。现代类 Unix 系统不再对组密码做任何事情，但该字段仍然保留，因为旧程序期望在这个位置找到内容。星号是一个占位符，用来应付这些程序。

第三个字段给出了组的唯一数字组 ID（GID）。许多程序使用 GID 而不是名称来识别组。*wheel* 组的 GID 为 0，最大 GID 为 65535。

最后是一个由逗号分隔的所有组内用户的列表。用户 *root*、*mwlucas* 和 *xistence* 是 *wheel* 组的成员。

##### 更改组成员资格

如果你想将一个用户添加到某个组，只需要将该用户的用户名添加到该组的行末。例如，wheel 组是允许使用 root 密码的用户列表。这里，我将 *rwatson* 添加到 wheel 组：

```
wheel:*:0:root,mwlucas,xistence,rwatson
```

说实话，我说服 rwatson（领先的安全研究员和前 FreeBSD 基金会主席）承担我任何系统的 sysadmin 职责的可能性几乎为零，但试试看还是值得的。

##### 创建组

创建新组时，只需要一个组名和一个组 ID 号码。从技术上讲，你甚至不需要为该组指定成员；某些程序以组成员身份运行，FreeBSD 使用组权限来控制这些程序，就像控制用户一样。

传统上，GID 是按列表顺序分配的下一个数字。GID 是一个介于 0 和 65535 之间的任意数字。一般来说，低于 1000 的 GID 保留给操作系统使用。需要专用组 ID 的程序通常会使用这个范围内的号码。用户账户从 1001 开始分配 GID，并逐渐递增。一些特殊组可能从 65535 开始编号，并逐渐递减。

#### *使用组来避免 root 权限*

除了安全隐患外，root 密码的分发政策还可能导致组织内部的分歧。许多 sysadmins 拒绝与负责维护系统一部分的人共享 root 密码，但他们又不提供替代方案，从而阻止这些人完成工作。其他 sysadmins 则几乎把 root 密码分发给任何想要的人，然后当系统变得不稳定时抱怨。两种态度从长远来看都是无法维持的。就我个人而言，我不希望你在我的系统上拥有 root 权限。虽然拥有 root 权限很方便，但当系统崩溃时缺乏责任感更方便。

一个常见的情况是，初级 sysadmin 负责系统的某一部分。我曾有很多 DNS 管理员在我下面工作；^(2) 这些人从不安装软件、重新编译内核或执行其他 sysadmin 任务。他们只处理邮件、更新区域文件并重新加载 named 守护进程。新手 sysadmins 通常认为他们需要 root 访问权限来做这些工作。其实不需要，你可以使用组权限。

创建你自己的组，由执行相似管理职能的人组成，可以避免分发 root 密码，同时仍然允许人们完成他们的工作。在本节中，我们将实现基于组的名称服务器文件访问控制。相同的原则也适用于你选择保护的任何文件。邮件和 Web 配置文件是其他常见的组管理对象。

##### 系统账户

FreeBSD 为集成程序保留了一些用户账户名。我们将在第十九章讨论这些无特权账户。例如，nameserver 在用户账户 bind 和组 bind 下运行。如果入侵者攻破了 nameserver，她只能以 bind 用户的权限访问系统。

不要让用户以这些用户身份登录。它们设计上并不是作为交互账户的。而且，不要允许系统账户用户的组拥有为该功能创建的文件。创建一个单独的用户和组来拥有程序文件。这样，我们假设的入侵者甚至无法编辑 DNS 服务器使用的文件，从而进一步减少潜在的损害。如果程序定期更新这些文件（例如，数据库的后端存储），你必须给予程序访问权限，但人类通常不需要编辑这些文件。类似地，数据库也不应该能够编辑其自己的配置文件。

##### 管理员组创建

创建拥有文件的组的最简单方法是使用 adduser(8)创建一个拥有文件的用户，然后将该用户的主组作为文件的组。因为我们已经有了一个叫*bind*的用户，所以我们将创建一个名为*dns*的管理员用户。用户名并不重要，但你应该选择一个大家都能识别的名字。

给你的管理员用户设置一个*nologin*的 shell，这会将 shell 设置为*/sbin/nologin*。这样可以防止任何人实际以管理员用户身份登录。

如果你愿意，可以为这些类型的用户指定特定的 UID 和 GID。我有时会选择类似于其关联服务账户所使用的 UID 和 GID 号码。例如，用户 bind 的 UID 和 GID 都是 53。我可以为用户 dns 指定 UID 为 10053，这样就容易辨识了。其他时候，我会从 65535 开始为我的管理员组编号，然后逐渐向下。这并不重要，只要在一个组织内保持完全一致。

不要将这个管理员用户添加到任何其他组中。在任何情况下，都不要将这个用户添加到特权组中，例如 wheel！

每个用户都需要一个主目录。对于管理员用户，*/nonexistent* 的主目录非常合适。毕竟，这个用户的文件存储在系统的其他地方。

最后，让 adduser(8)禁用该账户。虽然 shell 已经阻止了登录，但额外的防御层总是有益的。

现在你已经有了一个管理员用户和一个组，你可以将文件的所有权分配给该用户。每个文件都有一个用户和一个组。你可以使用`ls -l`查看现有的文件所有权和权限。（如果你忘记了 Unix 权限如何工作，可以阅读 ls(1)和 chmod(1)。）许多系统管理员非常关注文件所有者，对全局权限关注较少，只是匆匆看一下组权限。

```
# ls -l
total 3166
-rw-r-----  1 mwlucas  mwlucas    79552 Nov 11 17:58 rndc.key
-rw-rw-r--  1 mwlucas  mwlucas  3131606 Nov 11 17:58 mwl.io.db
```

在这里，我创建了两个文件。第一个文件，*rndc.key*，可以由用户*mwlucas*读取和写入。任何在*mwlucas*组中的人都可以读取它，但其他人无法操作它。文件*mwl.io.db*可以由用户*mwlucas*或任何在*mwlucas*组中的人读取或写入，但其他人只能读取该文件。如果你在*mwlucas*组中，你可以编辑文件*mwl.io.db*而不需要成为 root 用户。

使用 chown(1)更改文件的所有者和组。你必须知道你想更改所有权的用户和组的名称。在这种情况下，我们要将两个文件的所有权都更改为用户 dns 和组 dns。

```
# chown dns:dns rndc.key
# chown dns:dns mwl.io.db 
# ls -l
total 3166
-rw-r-----  1 dns  dns    79552 Nov 11 17:58 rndc.key
-rw-rw-r--  1 dns  dns  3131606 Nov 11 17:58 mwl.io.db
```

这些文件现在由用户 dns 和组 dns 拥有。任何在 dns 组中的人都可以编辑*mwl.io.db*而不需要使用 root 密码。最后，这个文件可以被运行 nameserver 的用户 bind 读取。将你的 DNS 管理员添加到*/etc/group*中的 dns 组，然后他们就可以执行他们的工作了。

DNS 管理员可能认为他们需要 root 密码来重新启动 nameserver 程序。然而，这可以通过 rndc(8)轻松管理。其他任务可以通过 cron 作业或附加程序 sudo(8)来管理。

如果你只需要一个组而不是一个管理员用户，可以使用 vigr(8)编辑*/etc/group*。

##### 有趣的默认组

FreeBSD 随附了几个默认组。大多数由系统使用，对系统管理员来说并不是特别重要——你应该知道它们的存在，但这与每天与它们打交道是两回事。在表 9-1 中，我为你的娱乐和启发展示了最有用、有趣和令人好奇的默认组。添加你自己的组可以简化系统管理，但这里列出的组在每个 FreeBSD 系统上都可用。

**表 9-1：** FreeBSD 系统组

| **组名** | **用途** |
| --- | --- |
| audit | 可以访问 audit(8)信息的用户 |
| authpf | 可以通过 PF 数据包过滤器进行身份验证的用户 |
| bin | 一般系统程序的组所有者 |
| bind | BIND DNS 服务器软件的组 |
| daemon | 用于各种系统服务，如打印系统 |
| _dhcp | DHCP 客户端操作 |
| dialer | 可以访问串口的用户；对于调制解调器和 tip(1)非常有用 |
| games | 游戏文件的所有者 |
| guest | 系统访客（几乎不使用） |
| hast | 被 hastd(8)使用的文件 |
| kmem | 可以访问内核内存的程序，如 fstat(1)、netstat(1)等 |
| mail | 邮件系统的所有者 |
| mailnull | sendmail(8)或其他邮件服务器的默认组 |
| man | 拥有未压缩 man 页面的用户 |
| network | 拥有像 ppp(8)这样的网络程序的用户 |
| news | 拥有 Usenet 新闻软件的用户（可能未安装） |
| nobody | 为无特权用户 nobody 设置的主组，供 NFS 使用 |
| nogroup | 没有特权的组，供 NFS 使用 |
| operator | 可以访问驱动器的用户，通常用于备份目的 |
| _pflogd | PF 日志记录组 |
| proxy | FTP 代理组，位于 PF 数据包过滤器中 |
| smmsp | Sendmail 提交的组 |
| sshd | SSH 服务器的所有者（参见 第二十章） |
| staff | 系统管理员（来自 BSD 的大学根源，当时用户是职员、教职工或学生） |
| sys | 另一个系统组 |
| tty | 可以写入终端的程序，如 wall(1) |
| unbound | 与 unbound(8) DNS 服务器相关的文件和程序 |
| uucp | 与 Unix 到 Unix 复制协议相关的程序组 |
| video | 可以访问 DRM 和 DRI 视频设备的组 |
| wheel | 可以使用 root 密码的用户 |
| www | 网站服务器程序（不是文件） |
| _ypldap | LDAP 支持的 YP 服务器 ypldap(8) 所需的文件 |

我知道很少有人使用互联网新闻或 UUCP，你可能认为可以将这些组重用于其他目的。然而，实际上创建一个新的组会比以后引起混淆更好。组 ID 号码并不短缺。

### 调整用户安全性

通过设置账户的限制，你可以防止任何单个用户使用过多的内存、处理器时间或其他系统资源。现在即使是小型计算机也有非常快的处理器和大量的内存，这些限制不再那么重要，但在有数十或数百个用户的系统中，这仍然非常有用。你还可以控制用户可以从哪里登录。

#### *限制登录能力*

FreeBSD 每次用户尝试登录时都会检查 */etc/login.access*。如果 *login.access* 中包含禁止该用户登录的规则，登录尝试会立即失败。默认情况下，该文件没有规则，这意味着提供有效用户名和密码的任何人都没有任何限制。

*/etc/login.access* 文件有三个由冒号分隔的字段。第一个字段表示授予（`+`）或拒绝（`-`）登录权限；第二个字段是用户或用户组的列表；第三个字段是连接源的列表。你可以使用 `ALL` 或 `ALL EXCEPT` 语法，这让你可以创建简单但表达力强的规则。规则按先到先得的方式检查。当 login(1) 找到一个用户和连接源匹配的规则时，连接会立即被接受或拒绝，因此规则的顺序非常重要。默认情况下允许登录。

例如，要仅允许 wheel 组的成员从系统控制台登录，你可以尝试以下规则：

```
+:wheel:console
```

然而，这条规则的问题在于它实际上并没有拒绝用户的登录权限。由于默认情况下接受登录，而这条规则只是明确地授予 wheel 组中的用户登录权限，所以没有任何变化。Bert 肯定不在 wheel 组中，但如果他尝试登录，没有规则会拒绝他访问。

你可以尝试两个像这样的规则：

```
+:wheel: console
-:ALL:console
```

这组规则可以实现预期的效果，但比你需要的要长。改用 `ALL EXCEPT` 会更简洁。

```
-:ALL EXCEPT wheel: console
```

这条规则可以最快地拒绝不需要的登录，并且管理员出错的风险较小。作为一种规则，最好通过拒绝登录而不是允许它们来构建 *login.access* 列表。FreeBSD 在遇到此规则时会立即拒绝非 wheel 用户在控制台上的登录。

通过添加最后一条规则，将默认设置从“允许访问”更改为“拒绝访问”。

```
-:ALL:ALL
```

任何不匹配之前允许规则的登录请求都会被拒绝。

*login.access* 中的最后一个字段——连接源，可以使用主机名、主机地址、网络号、域名或特殊值 `LOCAL` 和 `ALL`。让我们来看看它们是如何工作的。

##### 主机名

主机名依赖于 DNS 或 hosts 文件。如果你怀疑你的域名服务器可能遭受入侵或攻击，避免使用主机名；入侵者可以将任何 IP 地址绑定到主机名，从而欺骗你的系统接受连接，且域名服务器故障可能会完全锁定你。尽管如此，仍然可以使用像这样的规则：

```
-:ALL EXCEPT wheel:fileserver.mycompany.com
```

属于 wheel 组的用户可以从文件服务器登录，但其他人不能。

##### 主机地址和网络

主机地址的工作方式与主机名类似，但它们不受 DNS 故障或欺骗的影响。

```
-:ALL EXCEPT wheel:203.0.113.5
```

网络号是一个截断的 IP 地址，像这样：

```
-:ALL EXCEPT wheel:203.0.113.
```

这个网络号允许任何在 wheel 组中的用户从 IP 地址以 203.0.113 开头的机器上登录，并拒绝其他所有来自这些 IP 地址的访问。

##### LOCAL

最复杂的匹配是 `LOCAL`，它匹配任何没有点号的主机名（通常只有本地域的主机）。例如，* [www.mwl.io](http://www.mwl.io) * 认为任何位于 *mwl.io* 域中的机器都匹配 `LOCAL`。DNS 欺骗很容易绕过这个过滤器。尽管我的桌面声称它的主机名是 *storm.mwl.io*，但它的 IP 地址有反向 DNS 记录，声称它位于我的有线调制解调器提供商的网络中。主机 *[www.mwl.io](http://www.mwl.io)* 认为我的桌面不在同一个域，因此不是本地的。因此，我不能使用 `LOCAL` 验证方法。

类似地，任何拥有 IP 地址块的人都可以给他们的地址设置任意所需的反向 DNS。最好避免使用 `LOCAL` 限制。

##### ALL 和 ALL EXCEPT

`ALL` 匹配所有内容，`ALL EXCEPT` 匹配除了你指定的内容以外的所有内容。根据我的观点，这些是最有用的连接源。例如，如果你有一台仅可从几个管理工作站访问的高安全性机器，你可以有这样一条规则：

```
-:ALL EXCEPT wheel:ALL EXCEPT 203.0.113.128 203.0.113.44
```

##### 将一切联系在一起

这些规则的目的是构建一个符合你现实世界策略的登录政策。如果你提供通用服务，但只允许系统管理员远程登录，那么一行 *login.access* 就可以防止其他任何用户登录：

```
-:ALL EXCEPT wheel:ALL
```

如果你能忍受这样严格的限制，这很好。另一方面，我曾在几家使用 FreeBSD 提供客户端服务的互联网服务提供商工作。普通客户如果没有 Shell 账户，就不能登录到服务器。系统管理员可以远程登录，DNS 和 Web 团队成员（属于 dns 和 webmasters 组）也可以。只有系统管理员才能登录到控制台。

```
-:ALL EXCEPT wheel:console
-:ALL EXCEPT wheel dns webmasters:ALL
```

在*login.access*中设置一次，然后让组成员身份控制所有远程登录。

#### *限制系统使用*

你可以通过登录类提供更具体的控制。通过*/etc/login.conf*管理的登录类，定义了为用户提供的资源和信息。每个用户都会被分配一个类，每个类对可用的系统资源有限制。当你更改类的限制时，所有用户在下次登录时都会获得新的限制。在创建用户账户时设置用户的类，或者通过 chpass(1)稍后更改。

##### 类定义

默认的*login.conf*从默认类开始，这是没有其他类的账户所使用的类。这个类基本上给用户提供了对系统资源的无限访问权限，适用于用户数量有限的应用服务器。如果这符合你的需求，则无需调整文件。

每个类定义由一系列变量赋值组成，定义用户的资源限制、计费和环境。类定义中的每个变量赋值以冒号开始和结束。反斜杠字符是一个续行字符，用来表示类在下一行继续，从而使文件更易读。以下是一个类开头的示例：

```
➊default:\
      ➋:passwd_format=➌sha512:\
        :copyright=/etc/COPYRIGHT:\
        :welcome=/etc/motd:\
--snip--
```

这个类被称为`default` ➊。这里展示了这个类中的几个变量中的三个。例如，变量`passwd_format` ➋被设置为`sha512` ➌。通过这些变量赋值和类名，描述了该类，你可以通过将用户分配到另一个类来改变用户在系统上的体验。

*login.conf*中的某些变量没有值，而是通过存在来改变账户行为。例如，`requirehome`变量仅通过在类中出现就生效。如果该值存在，用户必须有一个有效的主目录。

```
       :requirehome:\
```

编辑*login.conf*后，必须更新登录数据库以使更改生效。

```
# cap_mkdb /etc/login.conf
```

这会重建用于快速查找的数据库文件*/etc/login.conf.db*，类似于*/etc/spwd.db*。

默认的*/etc/login.conf*包括几个用户的示例类。如果你想知道在各种情况下应该对用户施加什么样的限制，可以查看这些示例。接下来的部分提供了关于可以在登录类中设置内容的想法。要查看你使用的 FreeBSD 版本中支持的完整设置列表，请阅读 man login.conf(5)。

##### 资源限制

资源限制允许你控制任何一个用户在任何时刻可以独占系统的多少资源。如果你有几百个用户登录到一台机器，而其中一个用户决定编译 LibreOffice，那么这个用户将占用远超过他应得的处理器时间、内存和 I/O 资源。通过限制一个用户可以独占的资源，你可以让系统对所有用户更具响应性。

表 9-2 定义了资源限制的 *login.conf* 变量。

**表 9-2：** 一些 *login.conf* 变量用于限制资源使用

| **变量** | **描述** |
| --- | --- |
| `cputime` | 单个进程可以使用的最大 CPU 时间 |
| `filesize` | 任意一个文件的最大大小 |
| `datasize` | 一个进程可以消耗的最大数据内存大小 |
| `stacksize` | 进程可使用的最大栈内存量 |
| `coredumpsize` | 核心转储的最大大小 |
| `memoryuse` | 一个进程可以锁定的最大内存量 |
| `maxproc` | 用户可以运行的最大进程数 |
| `openfiles` | 每个进程可以打开的最大文件数 |
| `Sbsize` | 用户应用程序可以设置的最大套接字缓冲区大小 |

请注意，资源限制通常是按进程设置的。如果你为每个进程允许 200MB 的内存，并允许每个用户有 40 个进程，那么你实际上给每个用户提供了大约 8GB 的内存。也许你的系统有很多内存，但它真的有这么多吗？

##### 当前和最大资源限制

除了前面列出的限制外，你还可以指定当前和最大资源限制。*当前*限制是建议性的，用户可以根据需要覆盖它们。这在一个合作系统中效果良好，在这个系统中，多个用户自愿共享资源，但你希望通知那些超过标准资源分配的用户。许多用户希望做一个好公民，当被告知他们接近资源限制时，他们会愿意配合。^(3) 用户不能超过*最大*限制。

如果你没有指定资源限制为当前或最大值，FreeBSD 将其视为最大限制。

要指定当前限制，可以在变量名后加上 `-cur`。要设置最大限制，可以加上 `-max`。例如，要设置用户可以拥有的进程数量的当前和最大限制，使用以下输入：

```
        --snip--
        :maxproc-cur: 30:\
        :maxproc-max: 60:\
        --snip--
```

资源限制的一个对应概念是资源核算。如今，核算的重要性已经不如过去，当时今天这种便宜的计算机价格可能高达几百万美元，因此我们在本书中不会讨论它。现在，限制单个用户占用系统资源比为每个 CPU 周期计费更为重要。然而，你应该知道这种功能是存在的。

如果你需要更复杂的资源限制，调查 rctl(8)。

##### 类别环境

你也可以在 */etc/login.conf* 中定义环境设置。与在默认的 *.cshrc* 或 *.profile* 中设置它们相比，这种方法通常更有效，因为 *login.conf* 设置会立即影响所有用户账户，下次登录时生效。某些 shell，如 zsh(1)，不会读取这些配置文件，因此使用类环境可以为这些用户设置正确的环境变量。

所有环境字段都识别两个特殊字符。波浪线（`~`）表示用户的主目录，而美元符号（`$`）表示用户名。以下是一些来自默认类的示例，说明了这一点：

```
        :setenv=MAIL=➊/var/mail/$,BLOCKSIZE=K,FTP_PASSIVE_MODE=YES:\
        :path=/sbin /bin /usr/sbin /usr/bin /usr/games /usr/local/sbin /usr/
local/bin /usr/X11R6/bin ➋~/bin:\
```

通过使用 `$` 字符，环境变量 `MAIL` 被设置为 */var/mail/<username>* ➊。类似地，`PATH` 变量中的最后一个目录是用户主目录中的 *bin* 子目录 ➋。

表 9-3 列出了常见的 *login.conf* 环境设置。

**表 9-3：** 常见的 *login.conf* 环境设置

| **变量** | **描述** |
| --- | --- |
| `hushlogin` | 如果存在，则在登录时不会显示系统信息。 |
| `ignorenologin` | 如果存在，即使 */var/run/nologin* 存在，用户仍然可以登录。 |
| `manpath` | `$MANPATH` 环境变量的目录列表。 |
| `nologin` | 如果存在，用户无法登录。 |
| `path` | `$PATH` 环境变量的目录列表。 |
| `priority` | 用户进程的优先级（nice）（参见第二十一章）。 |
| `requirehome` | 用户必须拥有有效的主目录才能登录。 |
| `setenv` | 用逗号分隔的环境变量及其值列表。 |
| `shell` | 登录时要执行的 shell 的完整路径。此设置会覆盖 */etc/master.passwd* 中的 shell。用户的 `$SHELL` 包含密码文件中的 shell，从而导致环境不一致。对这个设置进行操作是惹恼用户的好方法。 |
| `term` | 默认的终端类型。几乎任何试图设置终端类型的操作都会覆盖此设置。 |
| `timezone` | `$TZ` 环境变量的默认值。 |
| `umask` | 初始的 umask 设置；应该始终以 0 开头，参见 builtin(1)。 |
| `welcome` | 登录欢迎信息的路径，通常是 */etc/motd*。 |

请记住，类的更改会影响该类中的所有用户。如果用户需要不同于类设置的更改，则需要更改其所属的类。

##### 密码和登录控制

与环境设置不同，很多设置可以在登录类以外的地方配置，大多数登录和认证选项只能在登录类中控制。以下是一些常见的认证选项：

passwd_format

此选项设置用于存储密码的加密哈希算法，存储在*/etc/master.passwd*中。默认值是`sha512`，用于 SHA512 哈希。其他允许的选项有`des`（DES）、`blf`（Blowfish）、`md5`和`sha256`（SHA256）。DES 和 Blowfish 在需要在不同的类 Unix 操作系统之间共享密码文件时非常有用，但它们的安全性较弱。SHA256 则是为了与较旧的密码文件兼容，这些文件在 SHA512 成为默认值之前使用。

mixpasswordcase

如果设置了此选项，FreeBSD 会警告用户如果他将密码更改为全小写的单词。尽管名称如此，但全大写的密码也符合此选项的要求。

host.allow, host.deny

这些值允许该类用户使用 rlogin 和 rsh。像你那次被怪异的室友强行喂的模糊绿色肉一样，尽量避免使用它们。

times.allow

此选项允许您安排用户何时可以登录，使用逗号分隔的日期和时间列表。日期使用星期几的前两个字母表示（Su、Mo、Tu、We、Th、Fr 和 Sa）。时间采用标准 24 小时制。例如，如果用户只能在周三的上午 8 点到下午 5 点之间登录，则使用以下条目：

```
        :times.allow=We8-17:\
```

times.deny

此选项允许您指定用户无法登录的时间窗口。请注意，这不会强制已登录的用户退出。格式与`times.allow`相同。如果`times.allow`和`times.deny`时间重叠，则`times.deny`优先。

你无法让那个过度工作的开发者回家，但你可以防止他再打开一个终端窗口。

### 文件标志

所有类 Unix 操作系统都具有相同的文件系统权限，为文件的所有者、其所属组以及所有其他用户分配读取、写入和执行权限。FreeBSD 通过*文件标志*扩展了权限机制，这些标志与权限一起工作，以增强系统的安全性。

许多标志的效果会根据系统的 securelevel 级别不同而有所不同，我们将在下一节中讨论。理解 securelevel 需要对文件标志的了解，而文件标志又依赖于 securelevel。现在，只需在遇到 securelevel 时点点头微笑，接下来的几页将让一切变得清晰。

一些文件标志仅在特殊情况下有用。我们将只讨论最常用的标志。请参阅 chflags(1)获取完整列表。

许多标志有多个名称；虽然在 ls(1)的输出中只会显示一个名称，但你可以在命令行中使用任何名称。出现这些替代名称是因为人们在键入`sapp`e`nd`时，不希望出现错误，而他们本来是想键入`sappnd`。在这里，我首先展示标志的主要名称，然后是更易于理解的别名。

sappnd, sappend

这个系统级的追加-only 标志只能由 root 设置。带有此标志的文件可以被追加，但不能被删除或以其他方式编辑。这个标志对于日志文件尤其有用。如果一个用户的 *.history* 文件设置了 `sappnd`，并且该帐户被入侵，情况会变得很有趣。由于一个常见的入侵者策略是删除 *.history* 文件或将其符号链接到 */dev/null*，以便管理员无法看到发生了什么，`sappnd` 确保了脚本小子无法通过这种方式抹去痕迹。回顾一个尝试删除 `sappnd` 文件的记录几乎是有趣的；你几乎可以看到攻击者的挫败感，随着他尝试各种方法而增加。^(4) 当系统运行在安全级别 1 或更高时，这个标志不能被移除。

schg

只有 root 可以设置系统级不可变标志。带有此标志的文件无法以任何方式更改。它们不能被编辑、移动、替换或覆盖。基本上，文件系统本身会阻止所有更改文件的尝试。当系统运行在安全级别 1 或更高时，这个标志不能被移除。

sunlnk

只有 root 可以在文件上设置系统级不可删除标志。文件可以被编辑或修改，但不能被删除。这不如前两个标志安全，因为如果文件可以编辑，就可以被清空。然而，它在某些情况下还是有用的。我曾在程序崩溃时，程序坚持删除自己的日志文件时使用过这个标志。然而，通常不建议在任何标准系统文件上设置这个标志。当系统运行在安全级别 1 或更高时，这个标志不能被移除。

uappnd

这个用户级的追加-only 标志只能由文件所有者或 root 设置。像系统级的追加-only 标志 `sappnd` 一样，设置了此标志的文件可以被追加，但不能以其他方式编辑或删除。这个标志最适用于个人程序等的日志；它主要是一种防止用户意外删除自己文件的手段。所有者或 root 可以移除此标志。

uchg

这个用户级的不可变标志只能由所有者或 root 设置。像 `schg` 标志一样，这个不可变标志可以防止任何人更改文件。再次强调，root 可以覆盖这个设置，并且用户可以在任何安全级别下禁用它。这个标志有助于防止错误，但并不是一种保护系统的方式。

uunlnk

这个用户级的不可删除标志只能由所有者或 root 设置。设置了此标志的文件无法被所有者删除。Root 可以覆盖这一点，用户也可以随时关闭此标志，这使得这个标志大多没什么用处。

#### *设置和查看文件标志*

使用 chflags(1) 设置标志。例如，为了确保没有人替换服务器的内核，你可以这样做：

```
# chflags schg /boot/kernel/kernel
```

你需要移除此标志才能执行系统更新。

你可以使用 `-R` 标志递归地更改整个目录树的标志。例如，要使 */bin* 目录不可变，可以运行以下命令：

```
# chflags -R schg /bin
```

然后，砰！你的基本系统二进制文件无法更改。

要查看文件上设置了哪些标志，请使用 `ls -lo`。

```
# ls -lo log
-rw-r--r--  1 mwlucas  mwlucas  sappnd 0 Nov 12 12:37 log
```

`sappnd` 条目告诉我们，该日志文件设置了系统的追加-only 标志。做个对比，如果一个文件没有设置标志，它看起来会是这样的：

```
# ls -lo log
-rw-r--r--  1 mwlucas  mwlucas  - 0 Nov 12 12:37 log
```

标志名的短横线告诉我们，该文件没有设置任何标志。

一台全新安装的 FreeBSD 系统，默认情况下没有很多文件被标记为带有标志，但你可以标记任何你想要的文件。在一台我完全预期会被黑客攻击的系统上，我通过在各种系统目录中使用 `chflags -R schg` 来阻止任何人用木马版本替换系统二进制文件。虽然这可能无法阻止攻击者进入，但想象他们的挫败感让我心情好多了。

要移除文件标志，请使用 `chflags` 并在标志名前加上 `no`。例如，要取消设置内核上的 `schg` 标志，输入以下命令：

```
# chflags noschg /boot/kernel/kernel
```

也就是说，你必须运行在 securelevel –1 时才能取消设置许多标志。那么，废话不多说，让我们讨论一下 securelevel 及其对你的意义。

### Securelevels

Securelevel 是内核设置，它通过改变系统的基本行为来禁止某些操作。随着 securelevel 的提高，内核的行为会发生些许不同。例如，在低 securelevel 下，文件标志可以被移除。一个文件可能被标记为不可更改（immutable）——但你可以移除这个标志，编辑文件，然后重新设置该标志。当你提高 securelevel 时，文件标志无法再被移除。系统的其他部分也会发生类似的变化。总体而言，增加 securelevel 所带来的行为变化要么会让入侵者感到沮丧，要么会完全阻止他们。你可以在启动时通过 *rc.conf* 选项 `kern_securelevel_enable="YES"` 启用 securelevel。

Securelevel 通过对你的行为施加限制，增加了系统维护的复杂性。毕竟，许多系统管理任务也是入侵者可能用来掩盖痕迹的行为。例如，在某些 securelevel 下，你无法在系统运行时格式化或挂载新的硬盘。另一方面，securelevel 对入侵者的阻碍要远远大于对你的影响。

#### *Securelevel 定义*

Securelevel 有 5 个等级：–1、0、1、2 和 3，其中 –1 为最低级别，3 为最高级别。启用 securelevels 后，你可以通过 *rc.conf* 选项 `kern_securelevel_enable` 在启动时设置 securelevel。你可以随时提高 securelevel，而不仅仅是在启动时，但你不能在不重启并进入单用户模式的情况下降低 securelevel。毕竟，如果你可以随时降低 securelevel，入侵者也可以！

每个 securelevel 的效果根据你的 FreeBSD 版本而有所不同。要获取最新的信息，请阅读 security(7)。

##### Securelevel –1

默认设置下，内核并没有提供额外的安全保护。如果你正在学习 FreeBSD，并且频繁更改配置，保持在 securelevel –1，并使用内建的文件权限和其他 Unix 安全机制来保护系统。像 `sappnd` 和 `schg` 这样的标志会生效，但 chflags(1) 可以轻松移除这些标志。

##### Securelevel 0

Securelevel 0 仅在启动时使用，除了 securelevel –1 外没有特殊功能。然而，当系统进入多用户模式时，securelevel 会自动提高到 1。将 `kern_securelevel=0` 设置在 */etc/rc.conf* 中，实际上与将 `kern_securelevel=1` 设置是一样的。如果你有启动脚本执行 securelevel 1 禁止的操作，securelevel 0 会非常有用。

##### Securelevel 1

在 securelevel 1，即基本安全模式下，事情变得有趣：

+   系统级文件标志不能被关闭。

+   你不能加载或卸载内核模块（参见 第六章）。

+   程序不能通过 */dev/mem* 或 */dev/kmem* 直接写入系统内存。

+   无法访问 */dev/io*。

+   你不能通过 `debug.kdb.enter` sysctl 进入内核调试器。

+   你不能通过 `debug.kdb.panic` sysctl 让系统崩溃。

+   挂载的磁盘无法直接写入。（你可以将文件写入磁盘；你只是不能直接访问原始磁盘设备。）

对于普通用户来说，securelevel 1 最明显的效果是无法修改 BSD 特定的文件系统标志。如果一个文件被标记为系统级不可变，并且你想替换它，那就太糟糕了。

##### Securelevel 2

Securelevel 2 具有 securelevel 1 的所有行为，并有两个附加功能：

+   磁盘无法进行写入操作，无论是否已挂载。

+   你不能将系统时间改动超过一秒。

这两项看起来对新手系统管理员无关紧要，但它们提供了重要的安全保护。尽管 Unix 提供了方便的工具，如文本编辑器来写文件，但也可以绕过这些工具和实际的文件系统，直接访问硬盘上的底层数据。直接操作硬盘使你可以更改任何文件，而不考虑文件权限。通常这种情况发生在你安装新硬盘并必须在其上创建文件系统时。通常，只有 root 用户可以以这种方式直接写入磁盘。在 securelevel 2 下，即使是 root 也无法使用 newfs(8)、zpool(8) 等命令。

类似地，另一个老黑客技巧是改变系统时间，编辑文件，再将时间改回。这样，当管理员查找可能导致问题的文件时，被篡改的文件看起来似乎已经几个月或几年没有更改，因此看起来不太可能是一个显而易见的关注点。

##### Securelevel 3

Securelevel 3 是 *网络安全模式*。除了 securelevel 1 和 2 的设置外，你无法调整数据包过滤规则。你主机上的防火墙是不可变的。如果你有一个启用了数据包过滤或带宽管理的系统，且这些规则已经经过良好的调优且不太可能改变，那么你可以使用 securelevel 3。

#### *你需要哪种 Securelevel？*

适合你环境的 securelevel 完全取决于你的具体情况。如果你刚刚将 FreeBSD 机器投入生产并且还在微调它，那么保持 securelevel 为 -1。系统调整完毕后，你可以提高 securelevel。大多数生产系统在 securelevel 2 下运行良好。

如果你使用的是 FreeBSD 的数据包过滤或防火墙软件，securelevel 3 可能看起来很诱人。不过，在启用这个选项之前，一定要非常确认你的防火墙规则！securelevel 3 会使你无法更改防火墙，而不影响连接。你百分百确信你的客户永远不会打电话来说：“这是支票，快给我更多服务器！”吗？

#### *安全级别和文件标志无法实现什么？*

考虑一种情况，假设某人侵入了你的网站服务器上的 CGI 脚本，利用它启动一个 shell，再通过 shell 获得 root 权限。

如果你已经相应地设置了 securelevel，也许攻击者会感到沮丧，因为她不仅无法将你的内核替换为她特别编译的版本，还无法加载内核模块。没问题——她仍然可以用木马版本替换各种系统程序，这样下次你登录时，你的新版本的 login(1) 就会将你的密码发送到一个匿名的基于网页的邮箱或互联网新闻组。

所以，为了保护关键文件，你四处执行 `chflags schg -R /bin/*`、`chflags schg -R /usr/lib` 等命令。好吧。如果你忘记了某个文件——比如像 */etc/rc.bsdextended* 这样不常见的文件——入侵者可以编辑该文件，加入 `chflags -R noschg /`。她可以在深夜时重启系统，可能你并没有注意到。你有多频繁坐下来彻底审计你的 */etc/rc* 文件？

你认为系统是安全的，所有文件都得到完全保护。但如何看待 */usr/local/etc/rc.d*，即本地程序启动目录呢？系统启动过程会尝试执行该目录下包含 `#PROVIDE:` 行的任何可执行文件（关于这一点，详见第十七章）。因此，入侵者可以通过将一个简单的 shell 脚本放置在此目录中，造成很大的损害。毕竟，*/etc/rc* 在启动过程的最后会提升 securelevel。假设她创建一个 shell 脚本，在 securelevel 提升之前杀死正在运行的 */etc/rc*，然后又运行自己放在 */var/.hidden/rc.rootkit* 中的脚本继续启动系统，情况会如何？

当然，这些只是几种可能性。还有其他的，唯一的限制是入侵者的创造力。记住，系统安全是一个棘手的问题，没有简单的解决方案。一旦入侵者获得了命令提示符，剩下的就是你和他们的较量。如果他们足够厉害，你甚至在入侵发生时都不会察觉。通过遵循良好的计算机实践并保持系统更新，你可以防止他们第一次入侵就成功。不要让 securelevel 使你变得懒惰！

#### *与安全级别共存*

如果你对 `schg` 标志使用得很宽松，你很快就会发现，自己无法方便地升级或修补系统。事实上，使入侵者生活困难的条件，如果你不知道如何与之合作，也可能使你的生活变得一团糟。

如果你已使用 `schg` 锁定了 */etc/rc.conf*，你必须降低安全级别才能更改系统上运行的程序。当然，安全级别设置就在该文件中，因此为了编辑它，你必须在 */etc/rc* 运行之前控制系统。这意味着你必须启动单用户模式（如 第四章 中讨论的那样），挂载你的文件系统，对相关文件运行 `chflags noschg`，然后继续启动。你甚至可以完全禁用 */etc/rc.conf* 中的安全级别设置，在系统运行时正常工作，或者在 */etc/rc.local* 中添加命令，使其在设置安全级别之前生效。这样你可以更快地恢复服务，但会失去文件标志的保护。

完成维护后，你可以通过将 `kern.securelevel` sysctl 设置为你期望的安全级别来提高（但不能降低）安全级别。

```
# sysctl kern.securelevel=3
```

现在你可以控制文件更改了，让我们考虑控制网络访问到你的系统。

### 网络目标

入侵者通常是通过破坏监听网络的应用程序而非操作系统本身来入侵的。一个操作系统可能会或可能不会帮助防御软件免受网络攻击，但入侵本身通常是从应用程序开始的。减少可以对你的服务器发起的攻击数量的一种方法是，识别所有监听网络的程序，并禁用任何不严格必要的程序。FreeBSD 提供了 sockstat(1) 工具，作为一种简单的方法来识别监听网络的程序。

我们在 第八章 中详细介绍了 sockstat；运行 `sockstat -4` 可以显示所有打开的 IPv4 TCP/IP 端口。每个你打开的网络端口都是一个潜在的弱点和潜在的攻击目标。关闭不必要的网络服务并保护那些必须提供的服务。

定期审查你系统上开放的端口是一个好主意，因为你可能会发现一些令人惊讶的东西。你可能会发现某个你安装的软件有一个你没有意识到的网络组件，而且它一直在安静地监听网络。

一旦你知道了正在运行的程序，如何关闭不需要的程序呢？关闭这些端口的最佳方法是不启动运行它们的程序。网络守护进程通常会在两个地方启动：*/etc/rc.conf* 或 */etc/rc.d* 下的启动脚本。与主 FreeBSD 系统集成的程序，如 sendmail(8)、sshd(8) 和 rpcbind(8)，在 *rc.conf* 中有标志位用来启用或禁用它们，许多附加程序也如此。有关在启动时启用和禁用程序的详细信息，请参见 第四章。

**工作站与服务器安全**

我见过的许多公司都有严格安全的服务器，但很少关注工作站的安全。然而，潜在的入侵者并不关心一个系统是服务器还是工作站。许多服务器和防火墙都有针对系统管理员工作站的特殊规则。入侵者会乐意渗透一个工作站，并试图利用这一点访问服务器。虽然服务器安全至关重要，但不要忽视工作站——尤其是*你*的工作站！

网络探测非常奇怪，因为你真的不知道什么时候有人在试探你的主机。为了了解这种情况有多严重，可以在你的一个公共服务器上的 */etc/rc.conf* 文件中将 `log_in_vain` 设置为 1。这会告诉内核记录所有连接尝试到已关闭的端口。当有人检查你的主机是否存在不存在的 Telnet、Squid 或数据库监听器时，内核会将该尝试记录到 */var/log/messages* 文件中。仅需观看日志，足够让你深刻意识到，整个互联网真的想要攻破你——然后关闭 `log_in_vain`。

### 汇总

一旦你只开放了必要的网络端口，并且知道哪些程序正在使用这些端口，你就知道哪些程序是你最需要关注安全性的。假如 FreeBSD 安全团队发布了一个关于你没有运行的服务的问题公告，你可以安全地推迟修复，直到下一个维护窗口。如果安全团队发布了你正在使用的程序存在漏洞的公告，你就知道必须尽快实施修复。如果他们宣布你正在使用的网络软件存在严重的安全问题，你就知道必须迅速采取行动。能够智能、快速地应对实际风险有助于保护你免受大多数入侵者的攻击。像文件标志和安全级别这样的工具可以最大程度地减少成功入侵者造成的损害。最后，使用组来限制你的系统管理员访问特定的系统部分，可以保护你的计算机免受意外和故意的损害。

现在让我们换个话题，谈谈存储。
