## **19

**高级安全特性**

![image](img/common01.jpg)

FreeBSD 提供了多种工具来保护网络流量和用户。一些工具对系统管理员是不可见的，但它们在后台工作以增加安全性，例如沙箱 API capsicum(4)。数据包过滤使你可以控制谁可以访问你的系统。你还可以使用黑名单来阻止那些不断攻击你主机的网络地址。此外，FreeBSD 还拥有一整套可选的安全特性，你可以在安装过程中或稍后启用。在本章中，我们将研究这些工具和技术，了解如何监控系统的安全性，并讨论如果遭遇入侵该如何应对。

我们从一个核心安全话题开始：非特权用户。

### **非特权用户**

*非特权用户*是为特定任务创建的特定用户。他只有执行该有限任务所需的权限。许多程序作为非特权用户运行，或使用非特权用户执行特定职责。

“只有执行职责所需的权限”听起来像是每个用户账户的要求，不是吗？确实如此，但即便是最低权限的人类用户所使用的账户，仍然比许多程序所需的权限要多。任何拥有 shell 访问权限的用户都有一个家目录。普通用户可以在其家目录中创建文件、运行文本编辑器或处理电子邮件。普通 shell 用户需要这些最小权限，但程序不需要。通过让程序，特别是网络守护进程，以一个非常受限的用户身份运行，你可以控制入侵者对程序或用户造成的损害。

FreeBSD 包括几个非特权用户。查看 */etc/passwd*，你会看到像 *audit*、*bind*、*uucp* 和 *www* 这样的账户。这些都是为特定服务器守护进程使用的非特权账户。看看它们有什么共同点。

非特权用户没有正常的家目录。许多用户的家目录是 */nonexistent*，而其他一些用户，如 *sshd*，则有一个特殊的家目录，如 */var/empty*。拥有一个无法写入或读取文件的家目录虽然使账户的灵活性降低，但对于服务器守护进程来说已经足够。虽然这些用户确实拥有系统上的文件，但通常无法修改这些文件。

同样，任何人都不应该登录这些账户。如果账户*bind*是为 DNS 系统保留的，那么实际上也不应该以该用户身份登录系统！这样的账户必须具有专门拒绝登录的用户 shell，例如 */usr/sbin/nologin*。这一切是如何增强系统安全性的呢？让我们看一个例子。

无论你使用的是哪个 Web 服务器，它通常都会在未授权账户 *www* 下运行。假设入侵者发现了你正在使用的 Web 服务器程序版本中的安全漏洞，并且能够让 Web 服务器执行任意代码。这是最糟糕的安全问题之一，因为入侵者可以让服务器程序做它有能力做的任何事。那么，这个程序的能力究竟是什么呢？

入侵者可能想要在系统上获得一个命令提示符。毕竟，在类 Unix 系统上，命令提示符是进入更多访问权限的门槛。未授权用户拥有一个专门不允许登录的 shell。这会让入侵者非常恼火，迫使他们付出更多努力才能达到命令提示符。

不过，如果她真的足够聪明，nologin shell 并不会阻止入侵者。假设通过巧妙的手段，她让 Web 服务器执行一个简单的 shell，比如 */bin/sh*，并向她提供命令提示符。她进来了，可以造成无法估量的破坏……或者她能做到吗？

她没有主目录，也没有权限创建一个。这意味着她想存储的任何文件都必须放在一个全局可访问的目录中，比如 */tmp* 或 */var/tmp*，这增加了她的可见性。Apache 配置文件由 root 或您的 Web 服务器管理组拥有，而 *www* 用户不属于该组。入侵者可能有途径进入 Web 服务器，但她无法重新配置它。她无法更改网站文件，因为 *www* 用户并不拥有它们。*www* 用户对系统上的任何内容都没有访问权限，除了 Web 服务器本身。一个足够有技能的入侵者可以让 Web 服务器展示不同的页面或重定向到另一个站点，至少在重启之前是这样。突破服务器上运行的应用程序或主机本身，则需要一整套额外的安全漏洞。

不过，未授权用户并不能解决所有的安全问题。我们已经被攻破的 *www* 用户可以查看 Web 应用的源代码文件。如果你的应用编写不当，或者将数据库密码硬编码在隐藏的文件中，你仍然会陷入很大的麻烦。不过，如果你已经保持系统更新并且所有软件包都保持最新，入侵者将很难渗透到 FreeBSD 系统中。

#### ***nobody 账户***

多年来，系统管理员将账户*nobody*作为通用的非特权用户。他们会以*nobody*身份运行网页服务器、代理服务器以及其他程序。这样做比以 root 身份运行这些程序更安全，但还不如为每个守护进程创建独立的用户。如果入侵者成功渗透了这些程序中的一个，他将可以访问所有这些程序。我们的假设性网页服务器入侵者不仅能访问网页服务器，还能访问以相同用户身份运行的其他程序！如果您正在使用 NFS，请记住，NFS 默认将远程 root 账户映射为*nobody*。使用非特权用户的整个目的是最小化成功入侵后可能造成的损害。

虽然您可能会使用*nobody*账户进行测试，但绝不要使用它来部署生产服务。要广泛使用独立的非特权账户。

#### ***一个示例非特权用户***

以下是适用于通用非特权用户的参数：

**用户名** 为用户的功能分配一个相关的用户名。例如，网页服务器的默认用户是*www*。

**主目录** 非特权用户应该故意没有主目录，因此使用*/nonexistent*。也不要创建*/nonexistent*目录；重点是它根本不存在！

**Shell** 非特权用户必须没有可以执行命令的 shell，因此使用*/usr/sbin/nologin*。

**UID/GID** 为非特权用户选择一个特殊范围的用户和组 ID。

**全名** 为用户的功能分配一个描述性的名称。

**密码** 使用 chpass(1)将用户的加密密码设置为一个星号，这将禁用账户密码。（请注意，chpass(1)代表*更改密码文件*，而不是*更改密码*！）

这些设置使得您的非特权用户确实变得非常不特权。您可以使用 adduser(8)轻松设置这些，给账户设置无密码、正确的主目录和适当的 shell。

许多端口和包已经分配了非特权用户和组，列在*/usr/ports/UIDs*和*/usr/ports/GIDs*中。不要害怕添加更多。使用 1000 以上的 UID，以避免与包和 FreeBSD 核心分配的 UID 冲突。

### **网络流量控制**

系统管理员必须具备控制进出其系统的流量的能力。必须阻止不受欢迎的访问者，同时允许合法用户访问。FreeBSD 提供了多种工具，允许您控制外部访问您的系统，包括 TCP 包装器、数据包过滤和黑名单功能。

TCP 包装器，或简称*包装器*，控制网络守护进程的访问权限。虽然程序必须支持 TCP 包装器，但大多数现代软件多年来已经支持包装器。包装器配置相对简单，不需要太多网络知识。然而，作为访问控制手段，包装器的功能是有限的。尽管如此，包装器允许您对连接和提供连接的守护进程执行一些有趣的操作，这就是为什么我们要讨论它的原因。

*数据包过滤* 控制系统允许哪些流量通过，以及哪些流量被拒绝。大多数防火墙实际上是数据包过滤器，只是上面加了一个漂亮的图形用户界面，但你也可以使用 FreeBSD 的数据包过滤和代理软件来构建一个坚固的防火墙。被拒绝的连接请求永远不会到达任何用户空间程序；它会在网络栈中被阻止。数据包过滤可以控制对任何程序、服务或网络端口的访问，但需要更多的网络知识。

*黑名单* 在你希望程序能够决定停止监听远程主机时非常有用。最常见的黑名单工具是 fail2ban (*[`www.fail2ban.org/`](https://www.fail2ban.org/)*)，它非常灵活，但需要大量的特殊配置。FreeBSD 包含 blacklistd，一个更易配置的黑名单工具，但需要与使用它的程序集成。

你应该使用哪种策略？对于基本的 TCP/IP 访问控制，我建议始终使用数据包过滤器。只有在需要 TCP 包装器的特定功能时，才使用它们。我仅将 TCP 包装器的连接阻止与允许作为实现这些高级功能的前提进行讨论。如果你希望服务在多次连接失败后阻止客户端，可以考虑使用 blacklistd。

使用包装器或数据包过滤时，你必须决定是选择默认接受还是默认拒绝的流量控制策略。

### **默认接受与默认拒绝**

在任何安全策略中，一个重要的决策就是选择默认接受还是默认拒绝。*默认接受* 安全策略意味着你允许任何类型的连接，除了你明确禁止的连接。*默认拒绝* 策略意味着你只允许来自特定部分互联网和/或特定服务的连接，拒绝所有其他连接。除非你制定了特定规则，否则默认设置会被使用。一旦选择了默认安全策略，你就可以以某种方式创建例外，以提供或阻止服务。选择的关键实际上是在于你是否愿意向全世界提供服务（默认接受），还是只向少数人提供服务（默认拒绝）。

例如，公司的政策可能要求公司内部网服务器只能从公司内部访问。如果是这样，可以采用默认拒绝策略，并明确列出可以访问该服务器的人员。或者，如果你有一个公共网站，但希望阻止某些互联网部分出于某种原因访问它，则可以采用默认接受策略。

我总是推荐默认拒绝策略。然而，如果你没有做出选择，那么你就选择了默认接受。

选择一个默认策略并不意味着这个默认策略必须毫无例外地执行。我的公共 web 服务器采取默认拒绝安全策略，但我特意允许全球访问这些网站。除非连接请求来自几个指定的 IP 地址之一，否则机器会拒绝连接其他程序的尝试。这是一个完全可以接受的默认拒绝策略。

不同的安全工具以不同的方式实现这些策略。例如，使用 TCP 包装器时，应用的是*第一个*匹配规则。如果你的最后一条规则拒绝所有内容，那么你就建立了一个策略，表示：“除非我在之前的规则中明确允许此流量，否则阻止它。”另一方面，使用 PF 包过滤器时，应用的是*最后一个*匹配规则。如果你的第一条规则说：“阻止所有流量”，那么你就实施了一个策略，表示：“除非我在后面的规则中特别允许此流量，否则阻止它。”

默认接受和默认拒绝都会让系统管理员感到烦恼。如果你采取默认接受策略，你将不断花时间修补漏洞。如果选择默认拒绝策略，你将花时间为别人打开访问权限。你会对任何选择不断道歉。如果选择默认拒绝，你可能会说：“我刚刚为你激活了服务，非常抱歉给你带来不便。”如果选择默认接受，你可能会说：“……这就是入侵者能够访问我们的内部财务数据库并导致我们损失数百万美元的原因。”在后一种情况下，“我为不便向你道歉”*真的是*不够的。

### **TCP 包装器**

记住，在第七章中我们提到过，网络连接会建立到各种监听连接请求的程序上。当一个程序内置 TCP 包装器支持时，程序会根据包装器配置检查传入的请求。如果包装器配置指示拒绝连接，程序会立即丢弃该请求。尽管名称中有 TCP，TCP 包装器也可以与 UDP 连接一起使用。包装器是一个长期存在的 Unix 标准，已经被纳入 FreeBSD。个别程序可能支持包装器，也可能不支持；虽然 FreeBSD 基础系统中的几乎所有程序都支持，某些第三方软件则不支持。

TCP 包装器实现为一个共享库，称为*libwrap*。正如在第十七章中所看到的，共享库是可以在程序之间共享的小块代码。任何与 libwrap 链接的程序都可以使用 TCP 包装器功能。

包装器最常见的保护对象是 inetd(8)，它是一个超级服务器，处理较小程序的网络请求。我们将在第二十章中讨论 inetd。虽然我们的示例涉及 inetd(8)，但你可以用完全相同的方式保护任何其他支持包装器的程序。虽然包装器有助于保护 inetd(8)，但要确保 inetd(8) 不提供任何不必要的服务，正如你对待主系统一样。

#### ***配置包装器***

封装器按顺序检查每个传入连接请求与*/etc/hosts.allow*中的规则进行匹配。第一个匹配的规则会被应用，并且立即停止处理。这使得规则的顺序变得非常重要。每条规则都在单独的一行上，由三部分组成，三部分通过冒号分隔：守护进程名称、客户端列表和选项列表。下面是一个示例规则：

```
ftpd : all : deny
```

守护进程名称是`ftpd`；客户端列表是`all`，意味着所有主机；选项是`deny`，指示封装器拒绝所有连接。除非先前的规则明确授权访问，否则没有人能够连接到该主机上的 FTP 服务器。

在早期的示例中，我只提到两个选项：`accept`和`deny`。它们分别允许和拒绝连接。稍后我们将讨论其他选项。

##### **守护进程名称**

守护进程名称是程序在命令行中出现的名称。例如，inetd(8)在接收到 FTP 请求时启动 ftpd(8)程序。Apache web 服务器启动一个名为*httpd*的程序，所以如果你的 Apache 版本支持封装器，请将守护进程名称指定为`httpd`。（注意，Apache 并不是从 inetd 启动的，但它仍然可以支持封装器。）一个特殊的守护进程名称`ALL`匹配所有支持封装器的守护进程。

如果你的系统有多个 IP 地址，你可以在守护进程名称中指定每个守护进程监听的 IP 地址的不同封装器规则：

```
ftpd@203.0.113.1 : ALL : deny
ftpd@203.0.113.2 : ALL : accept
```

在这个示例中，我们有两个守护进程名称，`ftpd@203.0.113.1`和`ftpd@203.0.113.2`。每个都有一个单独的 TCP 封装器规则。

##### **客户端列表**

客户端列表是一个由特定 IP 地址、网络地址块、主机名、域名和关键字组成的列表，用空格分隔。主机名和 IP 地址很简单：只需要列出它们。

```
ALL : netmanager.absolutefreebsd.com 203.0.113.5 : allow
```

使用此规则放在*/etc/hosts.allow*文件顶部，封装器允许我的网络管理机和任何 IP 地址为 203.0.113.5 的主机连接到该主机上的任何服务。（请注意，我可以通过其他方式阻止此访问。）

在客户端列表中指定网络号时，IP 地址和子网掩码之间用斜杠分隔，如第七章中所述。例如，如果脚本小子从一堆以 192.0.2 开头的地址攻击你的服务器，你可以通过以下方式来阻止它们：

```
ALL : 192.0.2.0/255.255.255.0 : deny
```

你也可以通过在客户端列表中使用域名，并在前面加一个点来实现。通过反向 DNS 实现此功能，这意味着任何控制一个地址块的 DNS 服务器的人都可以绕过此限制。

```
ALL : .mycompany.com : allow
```

如果你有一个长的客户端列表，你甚至可以将它们列在一个文件中，并将文件的完整路径放入*/etc/hosts.allow*文件中的客户端空间。我曾经在一个拥有大量分布广泛主机的网络上工作，比如一个 ISP 或公司网络环境，在全球各地有网络管理工作站。每个工作站共享与其他工作站相同的封装器规则，并在*hosts.allow*中出现多行。通过维护一个包含工作站列表的文件，我可以集中管理所有的变更。

除了专门列出客户端地址和名称外，包装器还提供了几个特殊的客户端关键字，用于将一组客户端添加到你的列表中。表 19-1 显示了这些关键字及其用法。

表 19-1 中列出的多数客户端关键字需要一个正常工作的 DNS 服务器。如果你使用这些关键字，你必须拥有一个非常可靠的 DNS 服务，并且必须记住 DNS 和其他程序之间的重要联系。如果你的 DNS 服务器失败，使用包装器和这些关键字的守护进程将无法识别任何主机。这意味着所有的连接都会匹配 `UNKNOWN` 规则，通常会拒绝连接。此外，客户端端的 DNS 故障可能会拒绝远程用户访问你的服务器，因为你的 DNS 服务器无法从客户端的服务器获取正确的信息。最后，如果你广泛使用基于 DNS 的包装，入侵者只需要过载你的名称服务器或以其他方式干扰你的名称服务器，就能对你的网络发起非常有效的拒绝服务攻击。

**表 19-1：** TCP 包装器关键字

| **关键字** | **用法** |
| --- | --- |
| `ALL` | 该规则匹配所有可能的主机。 |
| `LOCAL` | 该规则匹配每个主机名中不包含点的机器。通常，这意味着局域网内的机器。位于世界另一端、恰好共享你域名的机器也会被视为“本地”主机。 |
| `UNKNOWN` | 该规则匹配无法识别主机名或用户名的机器。一般来说，任何建立 IP 连接的主机都有已知的 IP 地址。然而，追踪主机名需要 DNS，追踪用户名需要 identd(8)。使用此选项时要非常小心，因为临时的 DNS 问题可能导致即使是本地主机名也无法解析，而且大多数主机默认不运行 identd(8)。你不希望因为你的名称服务器配置错误而导致服务无法使用——尤其是当那台机器*就是*你的名称服务器时！ |
| `KNOWN` | 该规则匹配任何具有可确定主机名和 IP 地址的主机。使用此规则时要非常小心，因为 DNS 中断可能会影响服务。 |
| `PARANOID` | 该规则匹配任何主机，其名称与其 IP 地址不匹配。你可能会收到来自 IP 地址为 192.168.84.3 的主机的连接请求，该主机声称自己叫做*mail.michaelwlucas.com*。包装器会反过来检查*mail.michaelwlucas.com*的 IP 地址。如果包装器得到不同的 IP 地址，该主机就符合此规则。没有时间维护 DNS 的系统管理员最有可能拥有未修补的、不安全的系统。 |

TCP 包装器提供了其他一些关键字，但它们没有这些关键字那么有用或安全。例如，可以基于远程机器上的用户名来允许连接。然而，你不应该依赖远程机器上的客户端用户名。例如，如果我设置包装器，只允许用户名为*mwlucas*的人连接到我的本地系统，某人可以轻松地在他们的 FreeBSD 系统中添加一个该名字的帐户，并直接访问。此外，这还依赖于之前提到的罕用的 identd(1)协议。你可以在 hosts_access(5)中找到一些其他类似有用的模糊关键字。

##### **ALL 和 ALL EXCEPT 关键字**

守护进程名称和客户端列表都可以使用`ALL`和`ALL EXCEPT`关键字。`ALL`关键字匹配所有内容。例如，默认的*hosts.allow*文件以一条允许所有连接的规则开始，这条规则允许从任何位置到任何守护进程的连接：

```
ALL : ALL : accept
```

这适用于所有程序和所有客户端。你可以通过为客户端列表或守护进程列表指定特定名称来限制这一点。

```
ALL : 203.0.113.87 : deny
```

在这个例子中，我们拒绝来自主机 203.0.113.87 的所有连接。

完全阻止对所有主机的访问并不是一个好主意，但请记住，TCP 包装器会按顺序执行规则，并在找到第一个匹配规则时停止检查。`ALL`关键字使你可以轻松设置一个默认立场。考虑以下规则集：

```
ALL : 192.168.8.3 192.168.8.4 : accept
ftpd : ALL : accept
ALL : ALL : deny
```

我们的工作站 192.168.8.3 和 192.168.8.4（可能是系统管理员的工作站）可以访问任何他们想访问的内容。世界上的任何人都可以访问 FTP 服务器。最后，我们拒绝所有其他连接。这是一个有用的默认拒绝立场。

使用`ALL EXCEPT`关键字来压缩规则。`ALL EXCEPT`允许你通过排除的方式列出主机；没有列出的主机将匹配。在这里，我们用`ALL EXCEPT`写出相同的规则：

```
ALL : 192.168.8.3 192.168.8.4 : accept
ALL EXCEPT ftpd : ALL : deny
```

当然，这条规则依赖于拥有一个默认的接受策略，该策略允许之后的 FTP 连接。

有些人认为用`ALL`编写规则更清晰，而另一些人则更喜欢`ALL EXCEPT`。需要记住的重要一点是，第一次匹配的规则会结束检查，因此在使用`ALL`时要小心。

允许来自本地主机的任何连接是一个好主意；你可能会发现有些程序在无法与本机通信时会出错。在你的*hosts.allow*文件中尽早放入这样的规则：

```
ALL : localhost : allow
```

##### **选项**

我们已经看到了两种选项：`allow`和`deny`。`allow`允许连接，而`deny`则阻止连接。默认的*hosts.allow*文件中的第一条规则适用于所有守护进程和客户端，它匹配并允许所有可能的连接。如果你想保护你的服务，这条规则不能排在*hosts.allow*中的第一位，但它是默认接受安全立场下的一个好最终规则。类似地，`ALL`:`ALL`:`deny`规则是在默认拒绝安全立场下的一个好最终规则。然而，TCP 包装器除了简单的`allow`和`deny`之外，还支持其他选项，给你提供了很大的灵活性。

**长规则**

如果你使用了很多选项，包装规则可能会变得非常长。为了帮助保持规则的可读性，*hosts.allow* 文件可以使用反斜杠 (`\`) 后跟回车符作为行续字符。

##### **记录**

一旦你决定接受或拒绝连接尝试，你还可以记录该连接。假设你想允许但特别记录来自竞争对手的所有传入请求。同样，你可能想知道因为 DNS 问题而被拒绝的服务器连接数量，当使用 `PARANOID` 客户端关键字时。记录很有用，更多的记录更好。磁盘空间比你的时间便宜。

`severity` 选项将消息发送到系统日志，即 syslogd(8)。你可以配置 syslogd 将这些消息定向到一个任意文件，具体取决于你选择的 syslogd 设施和级别（见 第二十一章）。

```
sshd : ALL : severity local0.info : allow
```

这个示例允许所有 SSH 连接，但也通过 local0 设施记录它们。

##### **扭转**

`twist` 选项允许你在有人尝试连接到包装的 TCP 守护进程时执行任意的 shell 命令和脚本，并将输出返回给远程用户。`twist` 选项仅适用于 TCP 连接。（记住，UDP 是无连接的；没有连接可以返回响应，因此你必须通过非常复杂和麻烦的步骤才能使 `twist` 在 UDP 上工作。此外，许多通过 UDP 传输的协议通常不期望这样的响应，也不具备接收或解释它的能力。在 UDP 上使用 `twist` 并不值得麻烦。）`twist` 选项将 shell 命令作为参数，并充当拒绝加执行此操作的规则。你必须了解基本的 shell 脚本才能使用 `twist`；`twist` 的复杂用法是可能的，但我们将坚持使用简单的用法。

`twist` 选项对于默认拒绝策略中的最后一条规则很有用。使用 `twist` 向尝试连接的人返回如下答案：

```
ALL : ALL : twist /bin/echo "You cannot use this service."
```

如果你只想拒绝某个特定主机的特定服务，可以使用更具体的守护进程和客户端列表与 `twist` 配合使用：

```
sendmail : .spammer.com : twist /bin/echo \
    "You cannot use this service, spam-boy."
```

这对抗垃圾邮件并不有效，但可能会让你感觉更好。不过，遇到粗鲁信息的合法客户可能会引发会议。

如果你感觉友好，可以告诉人们你拒绝他们连接的原因。以下 `twist` 会拒绝所有主机名与其 IP 地址不匹配的连接，并告诉他们原因：

```
ALL : PARANOID : twist /bin/echo \
    "Your DNS is broken. When you fix it, try again."
```

使用 `twist` 会保持网络连接开启，直到 shell 命令完成。如果你的命令执行时间较长，你可能会发现你保持了比预期更多的连接，这可能会影响系统性能。脚本小白可以利用 `twist` 使你的系统过载，进行一个非常简单的拒绝服务攻击。确保 `twist` 简单且能快速完成。

##### **生成**

与 `twist` 类似，`spawn` 选项会拒绝连接并运行指定的 shell 命令。与 `twist` 不同，`spawn` 不会将结果返回给客户端。当您希望 FreeBSD 系统在连接请求时采取某种行动，但又不希望客户端知道时，使用 `spawn`。生成的命令在后台运行。以下示例允许连接，但将客户端的 IP 地址记录到文件中：

```
ALL : PARANOID : spawn (/bin/echo %a >> /var/log/misconfigured ) \
    : allow
```

等一下——`%a` 是从哪里来的？TCP wrapper 支持多个变量，用于 `twist` 和 `spawn` 命令中，因此您可以轻松自定义响应。这个特定的变量 `%a` 代表 *客户端地址*。在命令运行之前，它会展开为客户端的 IP 地址，出现在 shell 命令中。表 19-2 列出了其他变量。

**表 19-2：** `twist` 和 `spawn` 脚本的变量

| **变量** | **描述** |
| --- | --- |
| `%a` | 客户端地址。 |
| `%A` | 服务器的 IP 地址。 |
| `%c` | 所有可用的客户端信息。 |
| `%d` | 连接的守护进程名称。 |
| `%h` | 客户端的主机名，如果没有主机名，则是 IP 地址。 |
| `%H` | 服务器主机名，如果没有主机名，则为 IP 地址。 |
| `%n` | 客户端的主机名，如果找不到主机名，则返回 `UNKNOWN`。如果主机名和 IP 地址不匹配，则返回 `PARANOID`。 |
| `%N` | 服务器的主机名，如果找不到主机名，则返回 `UNKNOWN` 或 `PARANOID`。 |
| `%p` | 守护进程的进程 ID。 |
| `%s` | 所有可用的服务器信息。 |
| `%u` | 客户端的用户名。 |
| `%%` | 单个 `%` 字符。 |

在 shell 脚本中，您可以在任何需要表示它们所代表信息的地方使用这些变量。例如，当有人连接到包装程序时，您可以使用以下命令将所有可用的客户端信息记录到文件中：

```
ALL : ALL : spawn (/bin/echo %c >> /var/log/clients) : allow
```

空格和反斜杠是 shell 命令中的非法字符，可能会导致问题。虽然在正常情况下，主机名中不会出现这两个字符，但互联网几乎可以说是与常规不同的。TCP wrapper 会将任何可能干扰命令 shell 的字符替换为下划线 (`_`)。请检查您的日志中的下划线；它们可能表示潜在的入侵尝试，或者只是某些不懂的人在操作。

#### ***包装封装器总结***

让我们将本节中给出的所有示例结合起来，构建一个完整的 */etc/hosts.allow* 文件来保护一个假设的网络系统。我们首先必须盘点这个系统提供的网络资源、我们网络中的 IP 地址，以及我们希望允许连接的远程系统。

尽管这些要求相当复杂，但它们归结为一个非常简单的规则集：

```
#reject all connections from hosts with invalid DNS and from our competitor
ALL : PARANOID 198.51.100.0/24 : deny
#localhost can talk to itself
ALL : localhost : allow
#our local network may access portmap, but no others
portmap : ALL EXCEPT 203.0.113.0/24 : allow
#allow SSH, pop3, and ftp, deny everything else
sshd, POP3, ftpd : ALL : allow
ALL : ALL : deny
```

您可以在 */etc/hosts.allow* 或 hosts_allow(5) 和 hosts_access(5) 中找到更多注释掉的示例。

### **数据包过滤**

如果你需要控制不支持 TCP 包装器的网络程序的访问，或者当你的需求超出了包装器所能提供的功能时，可以使用 FreeBSD 的内核级包过滤工具。如果你需要包过滤器，最好完全用包过滤替代 TCP 包装器的实现。在同一台机器上同时使用这两种工具只会让你更加困惑。

包过滤器会将每个进入系统的网络包与规则列表进行比较。当某个规则与包匹配时，内核会根据该规则进行操作。规则可以指示系统允许、丢弃或修改包。然而，你不能使用 TCP 包装器提供的那些巧妙选项；连接会在网络层被切断，客户端甚至没有机会到达应用层，就被拒绝了，而不是返回一个相对友好的拒绝信息。

尽管包过滤的概念足够简单，但你第一次实现时将面临一场彻底的噩梦——呃，我是说，一场“宝贵的学习经验”。准备好花几个小时进行实验，并且不要因为失败而灰心丧气。根据我的经验，困扰包过滤的往往是对基本 TCP/IP 知识的无知，而不是包过滤器本身。试图在不了解网络的情况下进行网络流量过滤是令人沮丧且毫无意义的。要真正理解 TCP/IP，唯一的方法是进行实际的工作。再去学习第七章。如果那还不够，就深入阅读那里的推荐书籍。

FreeBSD 面临着大量的包过滤器：IPFW、IP Filter 和 PF。

IPFW 是 FreeBSD 最早的包过滤软件。它与 FreeBSD 紧密集成；事实上，名为 */etc/rc.firewall* 和 */etc/rc.firewall6* 的文件完全是为 IPFW 准备的。虽然非常强大，并且在经验丰富的 FreeBSD 管理员中非常流行，但对于初学者来说，它有点难度。

第二个包过滤器，IP Filter，并不是 FreeBSD 特有的防火墙程序，而是在多个类 Unix 操作系统上都有支持。它主要是由一个人——达伦·里德（Darren Reed）——的巨大努力完成的，他开发了绝大部分代码并将其移植到所有这些操作系统上。如果你希望在多个操作系统之间共享一个防火墙配置，IP Filter 最为有用。

我们将重点讨论富有创意命名的*PF*，即*包过滤器*。PF 起源于 OpenBSD，旨在提供丰富的功能、灵活性并且易于使用。普通的 FreeBSD 管理员可以使用 PF 实现几乎所有使用其他两个包过滤器可以达到的效果。

**注意**

*如果你想深入讨论 PF，可以参考彼得·N·M·汉斯廷（Peter N. M. Hansteen）的《PF 之书》（The Book of PF）（No Starch Press, 2014），或者我自己的书《绝对 OpenBSD》（Absolute OpenBSD）（No Starch Press, 2013），其中有几章专门讲解 PF。你还可以查看在线的 PF FAQ，但那里的俳句要少一些。*

#### ***启用 PF***

PF 包括数据包过滤内核模块 *pf.ko* 和用户空间程序 pfctl(8)。在使用 PF 之前，你必须加载内核模块。最简单的方法是通过 *rc.conf* 启用 PF：

```
pf_enable="YES"
```

PF 默认采用接受所有策略，这意味着仅仅启用防火墙并不会让你把自己锁定在服务器之外。

#### ***默认接受和默认拒绝在数据包过滤中的应用***

安全策略（默认接受和默认拒绝）在数据包过滤中至关重要。如果你使用默认接受策略并希望保护你的系统或网络，你需要许多规则来阻止每一种可能的攻击。如果你使用默认拒绝策略，你必须为你提供的每个小服务显式地开放端口。在几乎所有情况下，默认拒绝是更可取的；虽然它可能更难管理，但它带来的更高安全性完全弥补了这种困难。

使用默认拒绝策略时，很容易将自己锁定在无法远程访问计算机的状态。当你通过 SSH 连接到远程计算机并不小心打破允许 SSH 访问的规则时，你就会遇到麻烦。每个人至少都会发生一次这种情况，所以当它发生在你身上时，不要太尴尬。关键是，最好不要在远程计算机上学习数据包过滤；从你可以控制台访问的计算机开始，这样你可以轻松恢复。我自己多次切断了自己的访问，通常是因为在解决与数据包过滤无关的问题时没有理清思路。如果没有远程控制台或 IPMI，唯一的解决办法就是在我爬上车、开车去远程地点时踢自己一脚，并在修复问题时向我给他人带来不便的人道歉。幸运的是，随着我年龄的增长，这种情况越来越少发生。^(1)

尽管如此，在几乎所有情况下，默认拒绝策略是正确的。作为一个新管理员，你唯一合理的学习数据包过滤的方式是确保你可以方便地访问系统控制台。如果你对自己的配置不完全有信心，除非你有远程控制台和电源访问、一个合格的本地管理员或者一个串行控制台，否则不要在全国范围内设置数据包过滤系统。

#### ***基础数据包过滤与有状态检查***

回想一下第七章，TCP 连接可以处于多种状态，如打开、开启、关闭等。例如，每个连接在客户端发送 SYN 数据包请求连接同步时都会开启。如果服务器在请求的端口上监听，它会回复 SYN-ACK，表示：“我已收到你的请求，这是我们的连接的基本信息。”客户端用 ACK 数据包确认收到信息，表示：“我已确认收到连接信息。”三次握手的每个部分都必须完成，才能建立连接。你的数据包过滤规则集必须允许三次握手的所有部分，以及实际的数据传输。如果你的数据包过滤器规则不允许传输 SYN-ACK，允许服务器接收传入连接请求就毫无意义。

在 1990 年代初，数据包过滤器会单独检查每个数据包。如果数据包匹配规则，它将被允许通过。系统不会记录之前已经通过的内容，也不知道某个数据包是否属于合法的事务。例如，如果一个标记为 SYN-ACK 的数据包到达并且其目标地址在数据包过滤器内，数据包过滤器通常会认为该数据包必须是对之前已批准的数据包的响应。这样的数据包*必须*被批准，以完成三次握手。因此，入侵者伪造 SYN-ACK 数据包并利用它们绕过看似安全的设备。由于数据包过滤器不知道谁曾发送过 SYN 数据包，它无法拒绝不合法的 SYN-ACK 数据包。一旦入侵者将数据包带入网络，他通常可以从一个随机设备触发响应，开始渗透。

现代数据包过滤器使用有状态检查来应对这个问题。*有状态检查*意味着跟踪每个连接及其当前状态。如果一个传入的 SYN-ACK 数据包似乎是正在进行的连接的一部分，但没有人发送相应的 SYN 请求，则该数据包会被拒绝。虽然这使内核变得更加复杂，但编写有状态检查数据包过滤规则比编写传统的规则要容易。数据包过滤器必须跟踪许多可能的状态，因此这比看起来要难编程，尤其是当你考虑到数据包碎片、反欺骗等问题时。

PF 默认执行有状态检查。你无需在规则中指定它。

如果您已经开始想，“嘿，数据包过滤听起来像是防火墙”，您是对的，有一定道理。*防火墙*这个词被应用于各种网络保护设备。 其中一些设备非常复杂；一些设备甚至在智力竞赛中败给了水泥块。如今，*防火墙*这个词不过是一个营销术语，几乎没有实际意义。*防火墙*这个词就像*汽车*这个词：你是指一辆生锈的 1972 年款 Gremlin，配有 6 马力的发动机，排气系统的废气足以突破《京都议定书》，还是一辆闪亮的特斯拉 Roadster，配有 500 马力的发动机、华丽的三色涂装以及“末日音响系统”？两者各有其用途，但显然其中一款是为性能而设计的。虽然“Gremlin”式的防火墙可能也有其用武之地，但最好还是选择您能负担得起的最好的设备。

话虽如此，FreeBSD 可以打造一个坚固的防火墙，完全满足您的需求。数据包过滤只是开始。软件包集合包含各种应用代理，可以让您的 FreeBSD 系统与 Checkpoint 或 PIX 抗衡，并在顶尖表现中脱颖而出——且费用远低于数万美元。

#### ***配置 PF***

配置 PF 在*/etc/pf.conf*文件中。这个文件包含了不同格式的声明和规则，具体格式取决于它们配置的功能。不仅规则的顺序至关重要，功能配置的顺序也同样关键。例如，如果您在重新组装分片数据包之前尝试进行状态检查，连接将无法正常工作。

默认的*/etc/pf.conf*包含了正确顺序的示例规则，但如果您有任何混淆的危险，建议您在各个部分之间加上大号注释标记，必要时使用大写字母。 （使用井号来注释*pf.conf*。）功能必须按此准确顺序输入：

1.  宏

1.  表格

1.  选项

1.  数据包规范化

1.  带宽管理

1.  翻译

1.  重定向

1.  数据包过滤

是的，PF 不仅仅是用来过滤数据包。它是一个通用的 TCP/IP 处理工具。我们不会在这里介绍它的所有功能；去阅读 Peter 的书吧。

##### **宏**

宏允许您定义变量，以便更轻松地编写和阅读规则。例如，下面是定义您的网络接口和 IP 地址的宏：

```
interface="em0"
serveraddr="203.0.113.2"
```

在您的规则中，您可能会将网络接口描述为`$interface`，将服务器的 IP 地址描述为`$serveraddr`。这意味着，如果您重新编号服务器或更换网络卡，只需在*pf.conf*中进行一次更改，您的规则就会完全更新。

有时您希望某个规则引用“当前在此接口上的所有 IP 地址”。您不关心流量到达的是哪个地址，只希望接受或拒绝到该接口的流量。PF 为此提供了简写方式。将接口名称括在括号中，稍后我们将看到。 （您也可以不使用括号直接使用接口名称，但这样 PF 就无法察觉到自上次重新加载或重启以来 IP 的变化。）

##### **表格和选项**

PF 可以通过表格存储大量地址。这比我们将要使用的 PF 更加复杂，但你应该知道这一功能的存在。

类似地，PF 有多种选项来控制网络连接的时间、表格大小和其他内部设置。默认设置通常足够满足正常（以及大多数不正常）使用。

##### **数据包规范化**

TCP/IP 数据包在传输过程中可能被拆分，处理这些数据碎片会增加系统负载，以及服务器必须做的工作量，无论是为了服务请求，还是过滤数据包。系统必须在将数据包交给客户端软件之前重新组装这些碎片，同时决定如何处理任何其他随机的垃圾数据。PF 将这种重新组装称为 *清理*。例如，要重新组装所有通过网络接口进入的碎片，丢弃所有可能不合法的过小碎片，并合理地清理传入的数据流，使用以下规则：

```
scrub in
```

这会影响进入计算机的所有数据包。

虽然清理看起来像是“锦上添花”，但它实际上相当重要，因为 PF 的过滤是基于整个数据包的。碎片要过滤起来要复杂得多，并且需要特殊处理，除非它们被重新组装。没有清理流量会导致连接问题。

##### **带宽、转换和重定向**

PF 包括其他对于防火墙至关重要的功能，并执行通常与网络设备相关的其他功能。通过排队，PF 可以控制主机在每个 IP 或甚至每个端口的基础上传输的流量。PF 包含一大堆功能来支持网络地址转换（NAT）和端口重定向，这两个是防火墙的关键功能。它的支持超出了许多商业产品的范畴。

所有这些内容足以填满另一本书。字面意思。Peter Hansteen 写了 *PF 手册*。去读一下，然后搭建一个防火墙。每个系统管理员至少应该用裸操作系统搭建一次防火墙。即使最终选择使用商业产品、嵌入式设备，或像 pfSense 或 OPNsense 这样的产品，你也会学到很多东西。^(2)

#### ***小型服务器 PF 规则示例***

这里有一组用于保护小型互联网服务器的 PF 规则样本。从这里开始，编辑它以匹配你服务器的需求。

```
➊ ext_if="em1"
➋ set skip on lo0
➌ scrub in

➍ block in
➎ pass out

➏ pass in on $ext_if proto tcp from any to ($ext_if) port {22, 53, 80, 443}
➐ pass in on $ext_if proto udp to ($ext_if) port 53
➑ pass in on $ext_if inet proto icmp to ($ext_if) icmp-type { unreach, redir,
       timex, echoreq }
```

我们首先定义一个宏来指定我们的接口名称 ➊，这样如果更换网络卡时，我们就不需要重写所有规则。

第二行指示 PF 不对 lo0 接口 ➋ 进行过滤。回环接口是本地机器的，只有本地机器能够通过它进行通信。

然后，我们清理传入流量 ➌，将数据包重新组装成一个连贯的整体，并丢弃那些无法重新组装的数据包。

现在我们有了一个合理的传入数据流，我们可以对其进行过滤。此策略首先通过阻止所有传入流量 ➍，设置默认拒绝策略。没有明确允许的任何东西都被禁止。

出站流量有默认允许策略 ➎。

本策略中的最后三条规则处理 TCP、UDP 和 ICMP。它们有类似的格式，我们稍后会详细分析。

首先，我们允许 TCP 流量访问端口 22、53、80 和 443 ➏。

接下来，我们允许 UDP 流量访问端口 53 ➐。如果该主机提供的服务多于 DNS，那么我们会有更长的端口列表。

最后一条规则允许至关重要的 ICMP 流量访问我们的主机，并允许该主机响应 ➑。

让我们更仔细地看看 TCP 规则。

```
➊pass in➋on $ext_if➌proto tcp➍from any➎to ($ext_if)➏port {22, 53, 80, 443}
```

该主机对入站流量有默认拒绝策略，因此通过`pass in`语句 ➊，我们对该策略做出了一个例外。

规则的下一部分指定了该规则适用的接口 ➋。该规则适用于由宏`$ext_if`定义的接口，或者是 em1。

然后，我们指定一个协议 ➌。这个规则适用于 TCP 连接。

你可以编写仅适用于特定源或目标地址的 PF 规则。这个规则适用于来自任何主机的流量 ➍。如果你允许任何源地址，可以省略规则中的这一部分。

然后，我们指定一个目标地址 ➎。目标是括号中的接口名称，这意味着“该接口上的任何 IP 地址”。

最后，定义该规则适用的端口 ➏。大括号允许你将多个实体组合在一起。该过滤器允许连接到端口 22（ssh）、53（DNS）、80（HTTP）和 443（HTTPS）。你也可以通过端口名指定端口（来自*/etc/services*），但我发现数字更可靠。编辑*/etc/services*不应该破坏你的防火墙！在该主机上部署新的 TCP 服务只需要将端口添加到列表中并重新加载防火墙规则。

UDP 规则略有不同。

```
pass in on $ext_if➊proto udp to ($ext_if)➋port 53
```

最明显的变化是定义 UDP 协议而不是 TCP ➊。一个不那么明显的变化是该规则省略了源地址。它适用于来自任何地址的数据包。这个数据包过滤器只允许一个端口，53 ➋。带有单一端口的规则不需要大括号。

ICMP 规则看起来有点复杂，但其实它和其他规则是一样的。

```
pass in on $ext_if inet➊proto icmp to ($ext_if)➋icmp-type➌{ unreach, redir, timex echoreq }
```

指定此规则适用于 ICMP 是直接的 ➊。这个规则也没有列出源地址，因此适用于来自任何地方的流量。

在 TCP 和 UDP 规则中指定目标端口的地方，ICMP 规则列出了`icmp-type` ➋。ICMP 没有端口，但它有不同类型的流量。对于我们的目的，ICMP 类型类似于端口。类型有数字代码，但名称更容易记。

该规则指定了四种不同类型的 ICMP 流量 ➌。

总的来说，这条规则允许通常对互联网正常运行至关重要的 ICMP 流量。你的环境可能需要其他类型的 ICMP。你组织的安全政策可能会指定可以和不能传递哪些 ICMP。但是这四种类型对于面对互联网的服务器来说是一个合理的组合。

这个简单的策略定义了与我们服务器通信的基本规则。虽然它并不完美，但它可以为入侵者设置障碍。那个闯入你的网站服务器并在 10000 端口启动命令提示符的家伙？如果你的防火墙规则不允许该端口的传入连接，那么他们所有的努力都会白费。真是个悲剧。

#### ***管理 PF***

使用 pfctl(8)管理 PF。如果你的规则没有错误，pfctl(8)将静默运行；只有在出现错误时才会输出结果。你需要测试、启用、查看和删除规则。

##### **测试规则**

由于防火墙错误可能会给你带来很大麻烦，最好在启用规则之前先检查它们。虽然规则检查只会解析文件，检查规则本身的语法错误，但如果启用包含语法错误的规则，可能会导致系统无法保护、锁定或两者兼而有之。使用`-n`标志检查文件中的问题，使用`-f`指定 PF 规则文件。

```
# pfctl -nf /etc/pf.conf
```

如果出现错误，请修复它们并重新尝试。

##### **启用规则**

一旦语法检查静默运行，移除`-n`标志以启用新规则。

```
# pfctl -f /etc/pf.conf
```

更改 PF 配置非常迅速。这意味着你可以为不同的时间或情况准备多个 PF 配置。也许你只想在一天中的某些时段允许访问特定服务；你可以安排一个 pfctl(8)运行，在这些时段安装适当的规则。或者，也许你有针对灾难情况的独立规则，并希望在失去互联网连接时安装特殊的规则集。使用 pfctl(8)可以使所有这些配置变得简单。

##### **查看规则**

如果你想查看当前正在防火墙上运行的规则，请使用`pfctl -sr`。

```
# pfctl -sr
scrub in all fragment reassemble
block drop in all
pass in on em1 proto tcp from any to (em1) port = ssh flags S/SA keep state
pass in on em1 proto tcp from any to (em1) port = domain flags S/SA keep state
pass in on em1 proto tcp from any to (em1) port = http flags S/SA keep state
pass in on em1 proto tcp from any to (em1) port = https flags S/SA keep state
pass in on em1 proto udp from any to (em1) port = domain keep state
pass in on em1 inet proto icmp from any to (em1) icmp-type unreach keep state
pass in on em1 inet proto icmp from any to (em1) icmp-type redir keep state
pass in on em1 inet proto icmp from any to (em1) icmp-type timex keep state
pass in on em1 inet proto icmp from any to (em1) icmp-type echoreq keep state
pass out all flags S/SA keep state
```

你可以按照这里展示的格式编写 PF 规则。

注意，虽然我们在配置文件中指定了多个 TCP 端口，但在数据包过滤器中，每个 TCP 和 UDP 端口都有自己的规则。同样，每种 ICMP 类型也有自己的规则。

##### **删除规则**

最后，使用`-Fa`（刷新所有）标志从运行配置中删除所有规则。（你可以使用除`a`以外的其他标志来删除防火墙配置的部分内容，但这样可能会使系统处于不一致的状态。）

```
# pfctl -Fa
```

你会看到 PF 系统地删除所有规则、NAT 配置以及配置中的其他内容。在加载新配置之前，不要手动清除配置；只需加载新规则文件即可删除旧规则。

PF 非常强大，灵活性很高，可以几乎以任何你喜欢的方式（甚至一些你不喜欢的方式）滥用 TCP/IP。我们才刚刚触及表面。查看在第 462 页中提到的“数据包过滤”中的一些资源，以深入探索 PF。

### **Blacklistd(8)**

有时你可能需要比简单的允许或拒绝更深思熟虑的数据包过滤。我经常将 SSH 服务器开放给公网，这样我就可以从任何地方登录。不过，我确实有点不满那些认为我会允许没有密码登录的僵尸网络。这个时候，Blacklistd(8)就派上用场了。

Blacklistd 允许一个守护进程报告：“嘿，这个 IP 地址在骚扰我。”一旦 Blacklistd 收到足够多关于某个地址的投诉，它就会通知防火墙阻止该地址。那些不断攻击你 SSH 服务器的机器人？它们已经历史。

这种黑名单策略对于像 Hail Mary Cloud 这样的分布式僵尸网络只有有限的作用，但即便如此，你仍然可以配置敏感度，屏蔽掉最烦人的客户端。一切取决于每个僵尸网络成员的侵扰程度。

要使用 Blacklistd，你必须设置数据包过滤器以接受来自 Blacklistd 的输入，设置每个服务的容忍级别，并配置服务以使用 Blacklistd。

#### ***PF 与 Blacklistd***

PF 通过锚点处理动态规则。你可以使用 pfctl(8)编辑活动锚点，让你在策略中的特定位置插入规则。在你的`block`和`pass`语句之前添加 Blacklistd 锚点。按照上一节的策略，你的规则将如下所示：

```
--snip--
anchor "blacklistd/*" in on $ext_if
block in
pass out
--snip--
```

你必须在锚点名称周围包含引号，并且必须指定接口。

数据包过滤器现在已经准备好进行动态黑名单处理。

#### ***配置 Blacklistd***

Blacklistd 从*/etc/blacklistd.conf*获取其配置。虽然它的大部分配置都放在这个文件中，但你也可以通过命令行选项修改服务的行为。

从启用*/etc/rc.conf*中的 Blacklistd 开始。

```
# sysrc blacklistd_enable=YES
blacklistd_enable: NO -> YES
```

守护进程不会启动，直到你重新启动或手动启动它，所以你现在可以进行配置。

##### **/etc/blacklistd.conf**

Blacklistd 规则每个只支持单个服务、端口或地址组。将你的规则放入*/etc/blacklistd.conf*，每行一个规则。Blacklistd 规则分为两组，分别是本地和远程。

*本地*的 Blacklistd 规则适用于运行 Blacklistd 的机器上的项目。这里是设置本地 SSH 服务、端口 99 或任何本地内容的地方。本地规则部分以`[local]`开头。

*远程*的 Blacklistd 规则适用于不在本地机器上的项目。这里，你可以定义规则，比如“这个块减少容忍度”或“禁用这些地址较短时间”或“永远不阻止这些地址”。远程规则部分以`[remote]`开头。我们将首先讨论本地规则，然后再讨论远程规则支持的附加内容。

下面是一个*blacklistd.conf*条目的示例：

```
[local]
ssh             stream  *       *               *       3       24h
```

第一行是一个`[local]`语句。此后出现的每个规则都适用于本地机器，直到遇到`[remote]`条目为止。

每个规则有七个字段。前四个字段识别要列入黑名单的流量，而后三个字段定义黑名单行为。星号（`*`）是通配符，表示任何内容都匹配这个字段。

第一个字段是*位置*。对于本地规则，它提供了适用的网络端口。像`ssh`和`ftp`这样的条目可能会让人产生误解。它们并不适用于名为`sshd`和`ftpd`的程序，而是适用于*/etc/services*中列出的网络端口。虽然在本地规则中你可以列出特定的 IP 地址和端口，但 blacklistd 会忽略该地址。只有端口才会生效。示例规则阻止了`ssh`，即端口 22。

第二个字段提供了套接字类型。TCP 套接字使用`stream`类型，而 UDP 套接字需要`dgram`。目前，所有支持 blacklistd 的服务都使用 TCP。你可以放心地在这里使用星号，表示“任何套接字类型”。我们的示例规则使用的是 stream，因此它适用于 TCP 连接。

第三个字段定义了*协议*。支持的选项包括`tcp`、`udp`、`tcp6`、`udp6`或`numeric`，或者你可以使用通配符表示“任何协议”。不使用通配符的唯一原因是，如果你只想匹配某一版本的 IP，例如为 TCP over IPv4 与 TCP over IPv6 使用不同的黑名单设置。

第四个字段给出了抱怨流量的守护进程的*所有者*。这可以是一个通配符、一个用户名或一个 UID。这里通配符是最常见的条目。对于黑名单目的来说，我不关心哪个用户运行在端口 22 上运行的服务器；我关心的是它能被保护不受随机访问。

第五个字段，*数据包过滤规则名称*，是决定如何阻止的第一个条目。Blacklistd 的默认行为是将所有阻止操作放在名为*blacklistd*的锚点下，这个锚点我们在上一节的*pf.conf*中添加过。如果你希望不同的黑名单使用不同的锚点，可以在这个字段中定义锚点名称；否则，使用通配符作为默认值。

如果你在名称前加上一个连字符（`-`），意味着“使用默认名称前缀的锚点”。

```
ssh             stream  *       *               -ssh       3       24h
```

该条目将任何新的黑名单规则添加到名为*blacklistd-ssh*的锚点。

在名称字段中使用斜杠（`/`）和网络掩码的长度告诉 blacklistd 使用前缀表示法来阻止整个子网。

```
22              stream  tcp       *               */24    3       24h
```

当网络中的一台主机行为异常时，我们会阻止邻接的整个/24 子网。/24 在 IPv4 和 IPv6 中有非常不同的含义。务必指定该规则适用的协议！

第六列，*nfail*，设置需要多少次登录失败才能将远程 IP 列入黑名单。这里，通配符表示从不。我们的示例规则设置为 3，这是 OpenSSH 在一次连接中给你的登录尝试次数。

最后一列，*禁用*，表示要将主机列入黑名单多长时间。默认单位是秒，但你也可以使用`m`、`h`和`d`分别表示分钟、小时和天。我们的示例规则设置为 24 小时。

所以，设置了这条规则后，SSH 认证失败三次将导致客户端被封锁 24 小时。

一旦你设置了本地规则，就可以配置远程规则。

##### **blacklistd.conf 远程规则**

使用远程规则来指定 blacklistd 如何根据远程主机改变其行为。远程规则中的每个字段与本地规则相同，但 blacklistd 使用它们的方式会有所不同。这里是一个示例远程规则：

```
[remote]
203.0.113.128/25 *      *       *               =/25    =       48h
```

*地址* 列是一个 IP 地址（IPv4 或 IPv6），一个端口，或者两者。这允许你为特定的远程地址范围设置特殊规则。我们的示例规则适用于地址范围 203.0.113.128/25。

*类型*、*协议*和*所有者*列的解释与本地规则相同。

*名称* 列非常有趣。在远程规则中的等号意味着“使用你匹配的本地规则中的值”。这条规则表示从防火墙规则中获取规则名称条目，并在其后添加网络前缀 /25（一个 255.255.255.128 的子网掩码）。如果来自这个地址范围的连接被列入黑名单，将会影响整个子网。如果你在此处放入一个 PF 锚点名称，blacklistd 会将该地址块的规则添加到命名锚点中。通配符将恢复为默认表。

*nfail* 列让你为这个地址设置自定义的失败次数。也许你想给那个总是输入错误密码的客户提供额外的尝试机会，允许他失败前 30 次。将此列设置为星号将禁用阻止功能。

*禁用* 列允许你为这个地址块设置自定义的封锁时间。使用通配符将禁用封锁功能。

远程规则让你对你不喜欢的人施加更严格的限制，同时告诉 blacklistd(8) 永远不要黑名单你的办公室。

你现在可以启动 blacklistd 了。但它不会做任何事情，因为程序不知道它应该向 blacklistd 报告错误。不过，一旦你配置了它们，它就准备好了。

#### ***配置 Blacklistd 客户端***

FreeBSD 包含了一些支持 blacklistd 的客户端。你最可能使用的两个是 ftpd(8) 和 sshd(8)。

要在你的 SSH 服务器中启用 blacklistd，请将以下行添加到 */etc/ssh/sshd_config* 中。

```
UseBlacklist yes
```

重启 sshd。

在 ftpd(8) 中启用黑名单功能，可以使用 `-B` 命令行选项，配置在 */etc/inetd.conf* 中或独立进程的 */etc/rc.conf* 标志中。

```
ftpd_flags="-B"
```

现在这些程序会在有人登录失败时向 blacklistd(8) 报告。

#### ***管理 Blacklistd***

将那些没有权限访问你服务的烦人客户端加入黑名单，能够减少你需要进行的日志分析量，但你可能会想看到 blacklistd 正在阻止的具体内容。你需要使用 blacklistctl(8)。

blacklistctl(8) 程序只有一个功能：显示 blacklistd 阻止的地址和网络。你总是需要使用 `blacklistctl dump` 命令。

默认情况下，`blacklistctl dump` 显示的是在黑名单候选列表中的主机，但尚未被封锁。添加 `-b` 标志可以查看所有已封锁的主机。

```
# blacklistctl dump -b
        address/ma:port id      nfail   last access
  203.0.113.128/25:22   OK      6/3     2018/08/28 16:30:09
```

在这里，我们看到地址范围 203.0.113.128/25 尝试了 3 次登录，但允许的登录尝试次数为 6 次。它是如何做到的？SSH 允许客户端在一个 TCP/IP 连接上尝试多次登录。黑名单不会阻止一个活动连接。上次有问题的主机尝试访问此服务是在`last access`显示的日期。

你可能会发现剩余时间比最后访问时间更有用。加上`-r`标志。

```
# blacklistctl dump -br
        address/ma:port id      nfail   remaining time
  203.0.113.128/25:22   OK      4/3     36s
```

很快，这个子网将被释放，可以继续骚扰和困扰我的无辜 SSH 服务器。也许我需要增加黑名单的时效。

#### ***去黑名单***

尽管你尽了最大努力，总有一天你需要在地址自然过期之前从黑名单中移除一个地址。blacklistctl(8)程序并不提供这样的功能：你必须手动从 PF 表中删除该地址。这样做需要理解 blacklistd 如何在 PF 中管理地址。

每个被阻止的端口都有一个子锚点，在 blacklistd 锚点内。这个锚点是以端口命名的。阻止端口 22 的子锚点将被命名为*blacklistd/22*。在那个子锚点内，你会找到一个包含被阻止地址的表格。该表格的名称是*port*，后面跟着端口号。无法再连接到端口 22 的主机将出现在一个名为*port22*的表格中。

在这里，我使用包过滤控制程序 pfctl(8)来检查子锚点 blacklistd/22\中的 port22 表的内容。我不会解释所有内容；只需替换你的表和子锚点名称。（阅读 Hansteen 的*《PF 之书》*，让锚点将你拖得更深。非常深，非常深。）

```
# pfctl -a blacklistd/22 -t port22 -T show
--snip--
   203.0.113.128/25
--snip--
```

是的，我们的问题地址就在其中。移除它需要一个相当深奥的 pfctl(8)命令。

```
# pfctl -a blacklistd/22 -t port22 -T delete 203.0.113.128/25
```

然而，黑名单是保存在 PF 之外的一个数据库中，因此被黑名单中的地址仍会出现在 blacklistctl(8)中。该数据库条目最终会无害地过期。如果主机再次不当行为，它将再次被阻止。

### **公钥加密**

许多服务器守护进程依赖公钥加密来确保通信的机密性、完整性和真实性。许多不同的互联网服务也使用公钥加密。你需要对公钥加密有基本的了解，才能运行像安全网站（https）和安全 POP3 邮件（pop3ssl）这样的服务。如果你已经熟悉公钥加密，你大概可以跳过这一部分。如果不熟悉，请为一个高度压缩的入门介绍做好准备。

加密系统使用密钥将消息在可读（明文）和编码（密文）版本之间转换。尽管*明文*和*密文*这两个词包含了*文本*一词，但它们并不限于文本；它们还可以包括图形文件、二进制文件以及你可能想要发送的任何其他数据。

所有加密系统有三个主要目的：完整性、保密性和不可否认性。*完整性*意味着消息没有被篡改。*保密性*意味着只有预定的受众能够读取消息。*不可否认性*意味着作者不能在事后声称自己没有写过这条消息。

早期的密码系统依赖于单一密钥，任何拥有密钥的人都可以加密和解密消息。你可能需要做大量工作来转换消息，比如二战期间让盟军头痛的恩尼格玛机，但密钥使得这种转换成为可能。一个典型的例子就是需要密钥或密码的任何代码。流行于间谍小说中的一次性信息密码本就是最终的单密钥密码系统，除非你拥有那把准确的密钥，否则是无法破解的。

与单密钥密码系统不同，公钥（或非对称）加密系统使用两把密钥：一把私钥和一把公钥。消息使用其中一把密钥加密，使用另一把密钥解密，数字签名确保消息在传输过程中未被篡改。解释这一点的数学确实相当复杂，但它确实有效——只需要接受这样一个事实：非常非常大的数字表现得非常非常奇怪。通常，密钥拥有者会将私钥保密，但将公钥发给全世界供任何人使用。密钥拥有者使用私钥，而其他人则使用公钥。密钥拥有者可以加密任何人都能阅读的消息，而世界上任何人都可以发送只有密钥拥有者能够读取的消息。

公钥加密技术满足了我们对完整性、保密性和不可否认性的需求。如果作者希望任何人都能够读取他的消息，并确保消息未被篡改，他可以用自己的私钥加密消息。任何拥有公钥的人（也就是全世界的人）都可以读取这条消息，但一旦篡改，消息将变得无法辨认。（根据实际用途，他可能选择代替签署数字签名来签署消息。）

以这种方式加密消息还确保了消息的作者拥有私钥。如果某人想发送一条只有特定人员才能读取的消息，他可以用该特定受众的公钥来加密消息。只有拥有匹配私钥的人才能读取这条消息。

只要私钥保持私密，这种方法是有效的。一旦私钥被盗、丢失或公开，安全性就会丧失。一个粗心的人如果丢失了自己的私钥，甚至可能会发现别人代替他签署文件。如果你不想发现有人用你的私钥订购了价值五十万美元的高端图形工作站并将其通过快递送到底特律市中心一个废弃房屋的邮件投递点，就要小心保管好你的密钥。^(3)

所有这些操作的标准工具包是 OpenSSL。

**为什么选择 OpenSSL？**

多年来，OpenSSL 一直是唯一的加密库选择。今天的更新替代方案，尽管可能更加可靠，但并不符合 FreeBSD 的长期支持模型。最明显的替代品，LibreSSL，只对每个版本提供一年的支持。在加密工具包既可靠又能在 FreeBSD 发布周期内持续升级之前，OpenSSL 将不会被替代。

#### ***OpenSSL***

FreeBSD 包含了用于处理公钥加密的 OpenSSL 工具包。OpenSSL 让你能够执行全方位的加密操作。尽管许多程序使用 OpenSSL 的功能，系统管理员通常不需要直接使用 OpenSSL。

虽然 OpenSSL 开箱即用，但我发现设置一些默认值可以让我的工作更轻松。使用文件 */etc/ssl/openssl.cnf* 配置 OpenSSL。该文件中的几乎所有设置默认是正确的，除非你是密码学家，否则不应该更改这些设置。可以更改的少数有用的设置是生成加密签名的默认值。每个默认值都以字符串 `_default` 标记。你最可能关心的是以下设置，我已经根据自己的需求进行了调整：

```
➊ countryName_default            = US
➋ stateOrProvinceName_default    = Michigan
➌ 0.organizationName_default     = Burke and Hare Word Mine, LLC
```

`countryName_default` ➊ 是你所在国家的两字母代码——在我这里是 `US`。`stateOrProvinceName_default` ➋ 是你所在州的名称，可以是任何长度。我会设置为 `Michigan`。`0.organizationName_default` 字段 ➌ 是你的公司名称。如果我要购买签名证书，我会在这里填入希望出现在证书上的内容。如果只是测试程序如何与 SSL 一起工作，并且没有真正的公司名称，我可能会使用我工作的公司名称或我自己编造的名称。

以下值不会出现在 *openssl.cnf* 中，但如果你设置了它们，它们会作为默认值出现在 OpenSSL 命令提示符中。我发现这些很有用，尽管它们比之前的默认值更新得更频繁——它们至少能提醒我正确的答案格式。

```
➊ localityName_default            = Detroit
➋ organizationalUnitName_default  = Pen-Monkey Division
➌ commonName_default              = www.michaelwlucas.com
➍ emailAddress_default            = mwlucas@michaelwlucas.com
```

`localityName_default` ➊ 是你所在城市的名称。`organizationalUnitName_default` ➋ 是你公司中该证书所适用的部门。OpenSSL 中最常被误解的值之一是 `commonName_default` ➌，它是该证书所属机器的主机名，如同反向 DNS 中所显示的那样。记住，反向 DNS 不一定与主机名相同！你的 Web 服务器可能有一个友好的名称，但托管公司可能会在反向 DNS 中为它分配一个完全不同的名称。最后，`emailAddress_default` ➍ 是站点管理员的电子邮件地址。

这些值会作为默认选择出现在 OpenSSL 命令提示符中。将它们设置在配置文件中可以省去后续的麻烦。

#### ***证书***

关于公钥加密，有一个有趣的地方是，作者和受众不必是人类。他们可以是程序。安全外壳（SSH）和安全套接字层（SSL）是程序可以在不担心入侵者窃听的情况下通信的两种不同方式。公钥密码学是*数字证书*的一个重要组成部分，这些数字证书用于安全网站和安全邮件服务。当你打开 Firefox 购买东西时，可能没意识到浏览器正在疯狂地加密和解密网页。这就是为什么你的计算机会抱怨“无效证书”的原因；某人的公钥可能已经过期，或者证书是自签的。今天的协议使用*传输层安全（TLS）*进行加密和解密，并使用*TLS 证书*。

**SSL 与 TLS**

你常常听到关于 SSL 的说法，但它通常是不正确的。今天，传输层安全（TLS）大多取代了 SSL。大多数关于*SSL*的使用是遗留下来的残余。一般来说，面向互联网的网站应该使用 TLS 1.1 或更高版本。TLS 1.0 的保护仅仅是弱保护。任何版本的 SSL 协议所加密的流量都不安全。

许多公司，如 VeriSign，提供公钥签名服务。这些公司被称为*证书颁发机构（CAs）*，因为它们提供*TLS 证书*。其他需要签署证书的公司提供他们的身份验证证明，如公司文件和商业记录，然后这些公钥签名公司用它们的 CA 证书签署申请人的证书。通过签署证书，CA 表示：“我已检查过此人的证件，他/她/它已证明自己的身份，且我对此表示满意。”然而，它们并不保证其他任何事情。TLS 证书的拥有者可以使用证书运行一个销售欺诈或危险产品的网站，或者用它来加密勒索信。签名的 TLS 证书保证的是某些类型的技术安全，而非个人诚信，甚至也不保证单方面的技术安全。证书并不会神奇地为你应用安全补丁。

网络浏览器和其他使用证书的软件包含主要 CA 的证书。当浏览器收到一个由 CA 签署的证书时，它会将该证书视为合法。基本上，网络浏览器会说：“我信任这个证书颁发机构，而证书颁发机构信任这家公司，因此我也会信任这家公司。”只要你信任该 CA，一切都能正常工作。

`ca_root_nss`包包含 Mozilla 项目认可的 CA 证书。如果某个软件在验证证书时失败，请确保你已安装该包。

大多数 CA 都是大型商业公司。不过，无论你的组织规模如何，我建议你调查 Let’s Encrypt（*[`www.letsencrypt.org/`](https://www.letsencrypt.org/)*）。Let’s Encrypt 是一个提供免费、全球有效的 TLS 证书的 CA。

使用未被任何 CA 签名的证书在测试中是完全可以的。它也可能适用于公司内部的应用程序，你可以将证书安装到客户端的网页浏览器中，或者告诉用户信任该证书。我们将讨论这两种方法。

这两种证书使用都需要一个主机密钥。

##### **TLS 主机密钥**

无论是签名证书还是自签名证书，都需要主机的私钥。主机密钥只是一个精心生成的随机数。以下命令创建一个 2,048 位的主机密钥并将其放置在 *host.key* 文件中：

```
# openssl genrsa 2048 > host.key
```

你将看到一条声明，表示 OpenSSL 正在创建主机密钥，并且屏幕上会出现点点移动，表示密钥生成过程正在进行。只需几秒钟，你就会得到一个包含密钥的文件。该文件是一个纯文本文件，包含 `BEGIN RSA PRIVATE KEY` 和一堆随机字符。

保护你的主机密钥！确保它由 root 拥有并且仅 root 可读。一旦将证书投入生产环境，任何拥有该密钥的人都可以用它来窃听你的私人通信。

```
# chown root host.key
# chmod 400 host.key
```

将这个主机密钥放置在与我们为密钥文件本身设置的权限相同的目录中。

##### **创建证书请求**

你需要一个证书请求，无论是签名证书还是自签名证书。我们不常使用 OpenSSL，所以我们不会深入分析这个命令。进入包含主机密钥的目录，并按原样输入以下命令：

```
# openssl req -new -key host.key -out csr.pem
```

在响应中，你将看到一些说明，然后是一系列问题。按下 ENTER 键，你将接受默认答案。如果你已配置 OpenSSL，则默认答案是正确的。

```
➊ Country Name (2 letter code) [US]:
➋ State or Province Name (full name) [Michigan]:
➌ Locality Name (eg, city) [Detroit]:
➍ Organization Name (eg, company) [Burke and Hare Word Mine, LLC]:
➎ Organizational Unit Name (eg, section) [Pen-Monkey Division]:
➏ Common Name (eg, YOUR name) [www.michaelwlucas.com]:
➐ Email Address [mwlucas@michaelwlucas.com]:
```

国家代码 ➊ 是根据 ISO 3166 标准定义的，你可以通过快速的网页搜索找到它。如果你不知道你所在的州 ➋ 和城市 ➌，可以问问偶尔离开服务器房间的人。组织名称 ➍ 很可能是你的公司，并且你也需要列出部门或分部名称 ➎。如果你没有公司，可以列出你的姓氏或其他任何能唯一标识你的方式，对于自签名证书，你可以列出任何你想要的内容。不同的 CA 对非公司实体有不同的标准，所以请检查 CA 的说明。

公共名称 ➏ 经常被误解。它不是你的名字，而是反向 DNS 中显示的服务器名称。你必须在这里填写服务器名称，否则请求将毫无用处。

我建议使用一个通用的电子邮件地址 ➐，而不是个人的电子邮件地址。在这种情况下，我 *是* [michaelwlucas.com](http://michaelwlucas.com)，所以我可以使用我的地址。你不希望你的组织的证书与一个可能因任何原因离开公司的个人挂钩。

```
   Please enter the following 'extra' attributes
   to be sent with your certificate request
➊ A challenge password []:
➋ An optional company name []:
```

挑战密码➊也被称为*密码短语*。再次提醒，保密这个密码短语，因为任何知道它的人都可以使用你的证书。然而，使用证书密码短语是可选的。如果使用密码短语，服务器启动时必须输入它。这意味着，如果你的 Web 服务器崩溃，网站将无法正常工作，直到有人输入密码短语。虽然使用密码短语非常有价值，但这可能是不可接受的。按 ENTER 键以使用空密码短语。

你已经输入了不少公司名称，所以第三个➋可能没有必要了。

一旦你返回命令提示符，你会看到当前目录下有一个名为*csr.pem*的文件。它看起来与您的主机密钥非常相似，不同之处在于顶行显示的是`BEGIN CERTIFICATE REQUEST`，而不是`BEGIN RSA PRIVATE KEY`。

将*csr.pem*提交给你的证书授权中心，证书授权中心将返回实际的证书。我建议将证书保存在一个以主机命名的文件中，比如*www.mwl.io.crt*。这个签名证书适用于任何 TLS 服务，包括网页、pop3ssl 或任何其他支持 TLS 的守护进程。

一些 CA 要求你使用中间证书与您的证书一起使用。虽然大多数守护进程有配置选项来指定中间证书，但如果没有，你可以将签名证书附加到中间证书的末尾。

##### **自行签署证书**

自签名证书在技术上与签名证书相同，但它没有提交给证书授权中心。相反，你自己提供签名。大多数客户不会在生产服务中接受自签名证书，但它非常适合用于测试。要签署你自己的 CSR，请运行以下命令：

```
# openssl x509 -req -days➊365 -in csr.pem -signkey host.key \
-out➋selfsigned.crt
Signature ok
subject=/C=US/ST=Michigan/L=Detroit/O=Burke and Hare Word Mine, LLC/OU=Pen-
Monkey Division/CN=michaelwlucas.com/emailAddress=mwlucas@michaelwlucas.com
Getting Private key
#
```

就这样！你现在拥有一个有效期为 365 天➊的自签名证书，保存在文件*selfsigned.crt*➋中。你可以像使用签名证书一样使用这个密钥，只要你愿意忽略应用程序显示的警告。

如果你自行签署证书，客户端软件会生成“证书签名者未知”的警告。这是正常的——毕竟，除了我的办公室的人，没有人知道 Michael W. Lucas 是谁，或者他为什么要签署网站证书。出于某种原因，人们信任 Symantec 和其他大型公司的 CA。我被认识我的人信任^(4)，但在全球范围内并不被信任。因此，不要在公众能够看到的地方使用自签名证书，因为警告会让他们困惑、恼火，甚至把他们吓跑。

在你花钱购买 CA 证书之前，务必先查看 Let’s Encrypt。它真的会改变你的系统管理实践。

#### ***TLS 技巧：连接到 TLS 保护的端口***

我说过我们不会做太多 OpenSSL 的操作，没错。但这款软件提供了一个太有用的功能，不能错过，一旦你学会了，你每月至少会使用这个技巧一次，并且很高兴你掌握了它。

在本书中，我们通过使用 telnet(1)连接到运行在该端口上的守护进程并发出命令来测试网络服务。这对于 SMTP、POP3 和 HTTP 等明文服务效果很好，但对加密服务如 HTTPS 则不起作用。当你连接到这些服务时，你需要一个程序来为你管理加密。OpenSSL 包含`openssl s_client`命令，专门用于这种类型的客户端调试。虽然你会看到很多加密信息，但你还可以发出明文命令给守护进程，并查看它的响应。使用命令`openssl s_client -connect`，并提供主机名和端口号，中间用冒号隔开。这里，我们连接到安全网页服务器 *[www.absolutefreebsd.com](http://www.absolutefreebsd.com)*：

```
# openssl s_client -connect www.michaelwlucas.com:443
CONNECTED(00000003)
depth=2 O = Digital Signature Trust Co., CN = DST Root CA X3
verify return:1
depth=1 C = US, O = Let's Encrypt, CN = Let's Encrypt Authority X3
--snip--
```

你将看到许多关于信任链和责任限制的内容，以及看起来随机的数字证书。然而，在所有这些之后，你会看到一个空白行，没有命令提示符。你正在直接与服务器守护进程对话。由于这是一个网页服务器，让我们尝试一个 HTTP 命令：

```
GET /
```

系统响应如下：

```
HTTP/1.1 400 Bad Request
```

HTTP 协议自上次我尝试这个以来发生了变化，我猜是这样。但我肯定已经连接到网页服务器了。网络工作正常。

你们中的一些人可能会想，如果与加密服务的通信如此简单，为什么还要加密这个服务呢？加密并不是保护守护进程，而是保护客户端和服务器之间的数据流。TLS 加密可以防止有人在传输过程中窃听你的网络对话——它并不保护服务器或客户端。如果有人闯入了你的桌面，TLS 也无法拯救你。

从此时起，我假设你已经理解了这个 OpenSSL 命令以及我们使用它时发生的事情。

**硬件加密支持**

大多数现代硬件都内置了加密加速功能。不幸的是，FreeBSD 默认配置中没有包含这一功能。硬件加密加速可以减少 CPU 的负载，并且可能加速加密过程。aesni(4)内核模块激活了对 Intel 硬件加密加速器的访问。新的 AMD 加速器驱动正在开发中。内核驱动仅影响内核中发生的加密过程，例如加密磁盘和 IPSec。

### **全局安全设置**

FreeBSD 支持许多可选的安全设置。这些设置改变了基本的 FreeBSD 行为，使其与常见的 Unix 体验不同。然而，一些其他操作系统默认提供这些设置，因此它们并不唯一于 FreeBSD。

你是否应该为了提高安全性而开启所有这些功能？这里没有一个普遍正确的答案。如果限制某部分系统的访问权限到 root 账户意味着你需要给予更多的人 root 权限，也许你不应该强制施加这种限制。不过，其中有几项应该在所有系统上启用。

#### ***安装时选项***

FreeBSD 安装程序提供了一个选项，可以在首次启动时启用这些设置。你可以稍后使用给定的 sysctl 设置启用或禁用它们。

这些功能在用户不多的服务器上特别有用。如果你的应用服务器除了应用程序使用的用户外没有其他非特权用户，那么你应该启用限制非特权用户的功能。不过，如果有非特权用户，请更仔细地考虑这种情况。我的大多数非特权用户^(5)不应该查看服务器进程或其他用户，因此我会对他们进行限制。

**隐藏其他 UID 的进程**

通常，像 `ps -ax` 这样的命令会显示系统上所有正在运行的进程。当你将 sysctl `security.bsd.see_other_uids` 设置为 0 时，用户只能看到自己的进程。无论如何设置，root 用户可以看到所有进程。

**隐藏其他 GID 的进程**

同样，用户通常可以看到其他组拥有的进程。通过将 sysctl `security.bsd.see_other_gids` 设置为 0，可以禁用该功能。同样，root 用户可以看到所有进程，无论该设置如何。

**隐藏监禁进程**

主机上的用户通常可以看到所有在 jail 中运行的进程。通过将 `security.bsd.see_jail_proc` 设置为 0，非特权的非监禁用户将无法看到监禁进程。这个功能出现在 FreeBSD 12 中。

**隐藏消息缓冲区**

非特权用户通常可以看到系统消息缓冲区，该缓冲区可以通过 dmesg(8) 访问。通过将 sysctl `security.bsd.unprivileged_read_msgbuf` 设置为 0，可以禁用该访问。

**禁用进程调试**

调试器可以告诉用户大量有用的信息。将 `security.bsd.unprivileged_proc_debug` 设置为 0，禁止非特权用户使用调试器调试进程。

**随机化进程 ID**

传统的 Unix 系统按顺序创建进程 ID，这让攻击者有机会猜测下一个 PID 会是什么。通过将 sysctl `kern.randompid` 设置为一个随机的大整数，可以随机化进程 ID。如果你将其设置为 1，内核在每次启动时会从 100 到 1,123 之间选择一个新的随机数。

**清理 /tmp**

所有合理的类 Unix 系统在启动时会清理 */tmp* 以清除临时文件。在过去的几年里，FreeBSD 默认关闭了这个行为。你可以使用 tmpfs(5) 来处理 */tmp*，它会在每次关机时销毁。如果你的 */tmp* 存储在磁盘上，那么……作为一个理性和合格的系统管理员，请始终在 */etc/rc.conf* 中将 `clear_tmp_enable` 设置为 `YES`。

**禁用 Syslogd 网络功能**

默认情况下，syslogd(8) 会在 UDP 端口 514 上创建一个半开放的套接字。没有人可以连接到这个套接字；它仅作为占位符使用，以防止其他东西绑定到该端口。一些人认为这个半开放的套接字是一个问题。但我认为这是一个特性；你不希望其他东西绑定到端口 514，声称自己是 syslogd，并向你的日志主机发送令人担忧或虚假安抚的消息。要禁用这个半开放的套接字，请在 */etc/rc.conf* 文件中将 `syslogd_flags` 设置为 `-ss`。

**禁用 Sendmail**

默认的 FreeBSD 安装不会接受来自网络的电子邮件，但它会运行一个 sendmail(8) 守护进程来发送外发邮件。要完全禁用从此主机发送邮件，请在 */etc/rc.conf* 文件中将 `sendmail_enable` 设置为 `NONE`。

禁用外发邮件不会阻止每日、每周和每月的维护任务运行。然而，除非你直接登录到主机，否则它会阻止你接收这些消息的输出。对于有多个主机的人来说，禁用外发邮件是不明智的。如果你使用其他邮件代理，例如 dma(8)（请参见 第二十章），禁用 Sendmail 是合理的。

#### ***安全控制台***

大多数 Unix 系统认为物理控制台是安全的。任何拥有物理机器访问权限的人都可以对主机做任何事情，包括更改 root 密码。通过将所有 */etc/ttys* 文件中标记为 `secure` 的条目更改为 `insecure`，你告诉 FreeBSD 即使在单用户模式下也要求输入 root 密码。^(6) 这不会阻止某人通过物理访问来入侵你的操作系统，但意味着他们需要做更多的工作来破坏你的机器。*非常*稍微多一点的工作。

#### ***不可执行堆栈与堆栈保护***

一种基本的漏洞缓解技术是不可执行堆栈。程序加载到内存后，分配给该程序的每个内存页面应该是可写的或可执行的，但不能两者兼具。

一种常见的漏洞利用技术是欺骗程序将信息写入内存，然后执行该内存。攻击者可能会说服程序写入一块内存，但在不可执行堆栈的情况下，内核不会执行它。

在现代版本的 FreeBSD 中，堆栈默认是不可执行的。禁用此功能的唯一理由是，如果你有一个编写不当的程序，依赖于执行和写入同一块内存。大多数此类有缺陷的软件在过去 15 年中已被正当地清除出开源生态系统。如果你非常不幸且无法避免运行无法处理不可执行堆栈的程序，你可以通过将 `kern.elf32.nxstack`（对于 32 位程序）或 `kern.elf64.nxstack`（对于 64 位程序）设置为 0 来禁用此功能。

与不可执行堆栈相关，堆栈保护页在程序内存分配的各部分之间添加了一个大小随机的额外内存片段。这使得攻击者更难猜测内存地址。FreeBSD 默认分配堆栈保护页，但你可以通过将 sysctl `security.bsd.stack_guard_page` 设置为 0 来关闭它。

#### ***其他安全设置***

FreeBSD 其他大多数内核级安全设置可以在 `security.bsd` sysctl 树中找到。每隔几个月会增加一些新的设置。运行 `sysctl -d security.bsd` 来显示主机可用的选项。我在本节中已经描述了其中的许多内容，但你可能会发现其他一些设置也有用。选项包括禁用 root 账户的特权（`security.bsd.suser_enabled`）、允许非 root 用户设置空闲优先级（`security.bsd.unprivileged_idprio`）以及阻止非特权用户使用 mlock(2)（`security.bsd.unprivileged_mlock`）。看看当前的选项，看看哪些可能有用。

### **使用 mtree(1) 为入侵做准备**

对系统管理员来说，最糟糕的事情之一就是让他觉得系统可能被攻破了。如果你在 */tmp* 中发现神秘文件，或在 */usr/local/sbin* 中发现多余的命令，或者感觉“总有些不对劲”，你就会怀疑是否有人入侵了你的系统。最糟糕的是，这种感觉无法得到证实。一个熟练的攻击者可以用她自己定制的版本替换系统二进制文件，这样她的行为就永远不会被记录，你对她的追踪也会失败。当犯罪分子提供了放大镜并包含了特殊的犯罪遮掩功能时，给你的服务器做检查就像是让福尔摩斯用放大镜来检查你的服务器一样毫无意义！有人甚至劫持了系统编译器，以便新构建的二进制文件包含劫持者的后门。^(7) 更糟糕的是，计算机经常做出奇怪的事情。操作系统极其复杂，应用程序更糟。也许 */tmp* 中那个奇怪的文件是你的文本编辑器在你敲键盘太快时吐出的，或者它是某个粗心入侵者留下的遗物。

恢复被入侵系统的*唯一*方法是从头重新安装系统，从备份中恢复数据，并希望导致入侵的安全漏洞已经被修复。这是一个微弱的希望，怀疑感是如此容易产生，以至于许多系统管理员最终停止在乎，或者欺骗自己，而不是忍受不断的担忧。

大多数入侵者会修改系统上已经存在的文件。FreeBSD 的 mtree(1) 可以记录系统上文件的权限、大小、日期和加密校验和。（虽然 freebsd-update(8) 也包含类似的功能，并且你无需提前收集数据，但它仅涵盖基础系统。）如果你在系统刚安装时记录这些特征，你就有了文件完整无损的记录。当入侵者更改这些文件时，比较将突出显示差异。当你感觉自己可能被黑客攻击时，你可以检查现有文件上的相同信息，看看是否有文件发生变化。

#### ***运行 mtree(1)***

以下命令会在你的根分区上运行 mtree(1)，并存储 SHA512 和 SHA256 加密校验和，将它们放入一个文件中以供后续分析：

```
# mtree➊-x➋-ic➌-K sha512➍-K sha256➎-p /➏-X /home/mwlucas/mtree-exclude >➐/tmp/mtree.out
```

虽然你可以在整个服务器上使用 mtree(1)，大多数人使用 `-x` ➊ 每次对每个分区运行它。你不希望在频繁更改的文件上记录校验和，例如数据库服务器上的数据库分区。在 NFS 挂载点上收集校验和具有双重特性：非常慢并且增加网络拥塞。`-ic` 标志 ➋ 告诉 mtree 将其结果打印到屏幕上，每个后续的文件系统层级都会缩进。这个格式与系统中的 mtree 文件（位于 */etc/mtree*）匹配。`-K` 标志接受几个可选的关键字；在这个例子中，我们希望生成 SHA512 校验和 ➌ 和 SHA256 校验和 ➍。`-p` 标志 ➎ 告诉 mtree 要检查哪个分区。几乎每个分区都有定期更改的文件或目录，因此你不希望为这些文件记录校验和。使用 `-X` ➏ 指定一个 *排除文件*，该文件包含不匹配的路径列表。最后，将此命令的输出重定向到文件 */tmp/mtree.out* ➐。

#### ***mtree(1) 输出：规范文件***

mtree(1) 的输出被称为规范（spec），或 *规范文件*。虽然这个规范最初是为了安装软件时使用，但我们现在用它来验证软件安装。你的规范从注释开始，显示了运行该命令的用户、命令运行的机器、分析的文件系统以及日期。规范中的第一个真实条目设置了该主机的默认值，并以 `/set` 开头。

```
/set type=file uid=0 gid=0 mode=0755 nlink=1 flags=uarch
```

mtree(1) 程序根据对分区中文件的分析选择了这些默认设置。默认的文件系统对象是一个文件，属于 UID 0 和 GID 0，权限为 0755，具有一个硬链接和用户归档标志。之后，系统上的每个文件和目录都有一个单独的条目。以下是根目录的条目：

```
➊.        ➋type=dir➌nlink=19➍time=1504101311.033742000
```

这个文件是点（`.`） ➊，或 *我们现在所在的目录*。它是一个目录 ➋，并且它有 19 个硬链接 ➌。这个目录在 Unix 纪元时间 1,504,101,311.033742000 秒时被修改 ➍。Unix 纪元始于 1970 年 1 月 1 日。

**纪元秒与真实日期**

不想计算自纪元开始以来的秒数吗？要将纪元秒转换为普通日期，可以运行`date -r`秒数。不过，需要去掉 mtree 时间末尾的小数部分；因为 date(1)只接受整数秒。

从某些方面来说，目录的条目相当无聊。毕竟，入侵者无法实际替换目录本身！以下是根目录中一个实际文件的条目：

```
.cshrc      mode=0644 nlink=2➊size=950 time=1499096179.000000000 \
➋ sha256digest=20d2a78c9773c159bac1df5585227c7b64b6aab6b77bccadbe4c65f1be474e8c \
➌ sha512=24d4330e327f75f10101cd7c0d6a5e59163336ade5b9eb04b0d96ea43d221c5eea4c71a89dfe85a...
```

我们可以看到文件名和与根目录相同的模式、链接和时间信息，但还可以看到文件大小➊。此外，还有从文件计算得出的 SHA256➋和 SHA512➌加密哈希值。

虽然理论上入侵者可以制作一个与特定加密哈希值匹配的文件，且尽管密码学家们不断尝试找到实际方法来制作匹配任意 SHA256 和 SHA512 校验和的文件，但入侵者能够制作一个匹配这两个校验和、包含其后门且仍能正常运行的伪造文件的可能性极低。如果真的发生这种情况，我们将会有其他抗此类方法的校验和算法，并会切换到这些算法。

#### ***排除文件***

排除文件（通过`-X`提供）列出了你不希望 mtree(1)分析的文件系统。许多文件系统会在没有恶意干扰的情况下发生变化。日志文件和用户主目录应该会发生变化。像*/tmp*和*/var/db/entropy*这样的目录在功能系统中最好也会发生变化。在排除文件中每一行列出你不想检查的目录，前面加上一个点。

```
./tmp
./var/db/entropy
./var/log
./usr/home
```

等待一天左右，然后再次运行 mtree(1)生成新的规格文件。两个 mtree 文件之间的差异将帮助你改进排除文件。当你怀疑系统被入侵时，你也可以做完全相同的操作。

#### ***保存规格文件***

规格文件包含了在怀疑发生入侵后验证系统完整性所需的信息。如果你将规格文件保存在你想要验证的服务器上，入侵者就可以编辑该文件并掩盖其恶行。你绝对不能将文件保存在系统本身上！时不时会有人建议你对 mtree 规格文件进行校验和，但将其保留在服务器上。这样没有用；如果有人篡改了 mtree 文件和校验和，你怎么知道呢？更糟的是——如果有人篡改了规格文件，而你发现了，你也无法知道更改了什么！请将规格文件复制到一个安全的位置，最好是离线介质，如闪存驱动器或光盘。

#### ***查找系统差异***

当一些事情引起你的怀疑，并开始认为你可能遭遇入侵时，创建一个新的 mtree 规格文件，并与你离线存储的“已知良好”规格文件进行比较。使用 mtree(1)检查规格文件之间的差异。

```
# mtree -f mtree.suspect -f mtree.good > mtree.differences
```

文件中的每一项条目都代表一个已发生更改的内容。我的排除文件经过精细调校，去除了我预期会发生更改的文件。这次运行生成了两行输出。

```
                bin/sh file➊size=161672
➋ sha256digest=a4a85ca3563d8f3bda449711c6b591b37093e668fc136f8829eb188b955f56ab
➌ sha512=011793e3e6cacd99b4261e0a0f3a0b9bd6a6842f3ccd55da1ce2070b568e3c49ae7b0e51d33bb59eff...
                bin/sh file size=➍10489808
➎ sha256digest=45856525d4251b43d68df1429cf1fe0f4adb6640f06d7f995aace5b7ca0c03c2
➏ sha512=a4f0e83e5fb12d615721fd7d57cb6a120068d1aa71fc305b7b86927391f33bec822cf14ce8a8a9db14...
```

文件*/bin/sh* ➊的大小在 mtree 运行之间发生了变化➍。这不好。同时，注意到两个不同的 SHA256 哈希值➋ ➎和两个不同的 SHA512 哈希值➌ ➏。现在不要慌张，但开始向你的同事们提出尖锐、直接的问题。如果你不能得到一个合理的答案，解释为什么这个二进制文件发生了变化，可能需要查看你的安装介质。

或者，也许你需要更新你的排除文件。但如果*/bin/sh*发生了变化，可能就不是了。

### **监控系统安全**

所以，你认为你的服务器是安全的。也许它是……暂时是。

不幸的是，存在一类入侵者，他们无事可做，只能跟进最新的安全漏洞，并尝试在他们认为可能脆弱的系统上进行攻击。即使你虔诚地阅读*FreeBSD-security*并应用每一个补丁，你仍然有可能在某一天被黑客入侵。虽然没有办法绝对确认你没有被黑客入侵，但以下线索将帮助你在发生异常时发现问题：

+   熟悉你的服务器。定期运行`ps -axx`，并了解它们通常运行的进程。如果看到不认识的进程，进行调查。

+   使用`netstat -na`和`sockstat`检查你的开放网络端口。你的服务器应该监听哪些 TCP 和 UDP 端口？如果你不认识某个开放端口，进行调查。也许它是无害的，但它也可能是入侵者的后门。

+   无法解释的系统问题是线索。许多入侵者都是笨手笨脚、缺乏系统管理员技能的傻瓜，他们使用点击和拖拽攻击。他们会让你的系统崩溃，并以为自己是塞缪尔·L·杰克逊的网络化身。

+   真正熟练的入侵者不仅会在事后清理现场，还会确保系统没有任何可能引起你警觉的问题。因此，系统异常稳定的情况下也应当保持警惕。

+   无法解释的重启可能表明有人非法安装了新的内核。它们也可能是硬件故障或配置不当的迹象，因此无论如何都应该进行调查。

+   FreeBSD 每天会通过邮件发送基本的系统状态信息。阅读它们。保存它们。如果发现任何可疑之处，进行调查。查看旧的消息，了解什么时候发生了变化。

我特别推荐使用`lsof`软件包来增加你对系统的熟悉度。`lsof`程序列出系统上所有打开的文件。阅读 lsof(8)的输出本身就是一种教育；你可能从未意识到你的 Web 服务器会打开这么多无用的文件。看到陌生的文件被打开，意味着你可能对你的系统不够熟悉，或者某人在做不当的事情。

### **软件包安全**

FreeBSD 项目提供了一个包含端口和软件包系统安全漏洞的数据库。这个数据库以*漏洞与曝光标记语言（VuXML）*的形式提供。当有人自愿维护一个端口时，他们也自愿关注该端口的安全问题。

一台连接互联网并安装了 pkg(8) 的 FreeBSD 主机会在 periodic(8) 运行时下载最新的 VuXML 文件（参见 第二十一章），并将其存储在 */var/db/pkg/vuln.xml* 中。然后，它会将已安装的软件包与该数据库进行比较。如果你的某个软件包存在漏洞，你将会在每日状态邮件中收到通知。（你有在阅读每日状态邮件吧？）

如果你的软件包不安全，按照 第十五章 的方法升级它们。

如果需要，你可以通过在 *pkg.conf* 中使用 `VULNXML_SITE` 选项来设置一个不同的地址来获取 *vuln.xml* 文件。如果你维护自己的软件包仓库和漏洞数据库，你可能会这么做。

### **如果你被黑了**

在这一切之后，如果你的系统被黑了，你该怎么办？没有简单的答案。关于这个主题已经写了大量书籍。不过，这里有一些常规的建议。

首先也是最重要的：一个被黑客入侵的系统是无法信任的。如果有人获得了你互联网服务器的 root 权限，他可能已经替换了系统上的任何程序。即使你修补了他入侵的漏洞，他也可能已经安装了一个篡改过的 login(8) 程序，每次你登录时都会将你的用户名和密码发送到某个 IRC 频道。不要信任这个系统。升级无法清除它，因为即使是 freebsd-update(8) 和编译器也有可能受到怀疑。

虽然 rootkit 检测软件可能帮助你验证是否存在入侵者，但没有任何工具可以验证入侵者是否“已不在”系统中。你可以随时写信给 *FreeBSD-security@FreeBSD.org* 请求建议。描述你所看到的情况以及你认为自己被黑的原因。不过，准备好面对一个不太愉快的答案：彻底从已知安全的介质重新安装你的计算机，并从备份中恢复数据。你看过 第五章了吗？

良好的安全实践能减少被黑客攻击的几率，就像安全驾驶能减少发生车祸的几率一样。最终你无论如何都会撞坏你的车，然后会想为什么要费这个劲。祝你好运！
