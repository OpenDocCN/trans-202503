## **15

**使你的系统更有用**

![image](img/common01.jpg)

一个基本的 FreeBSD 安装包括*正好*足以让系统运行的内容，再加上一些 Unix 系统传统上包含的额外组件。你可以决定是否安装额外的程序或源代码。尽管 FreeBSD 随着时间的推移不断发展，但一个完整的基本安装大约占用 1GB 的空间——比 Windows 或商业 Linux 安装所需的磁盘空间要少得多。

这种简洁性的优点在于它仅包含必要的系统组件。当你知道没有任何你从未听说过、且永远不会使用的共享库能够导致你的问题时，调试变得简单得多。缺点是你必须决定需要哪些功能，并选择提供这些功能的软件。FreeBSD 通过端口和包简化了附加软件的安装。

### **端口和软件包**

FreeBSD 支持两种安装附加软件的方式。一切都从端口集合开始，但大多数用户会更喜欢预配置的软件包。

FreeBSD 有一个构建附加软件的系统，叫做*端口集合*，或简称*端口*。端口让你从程序供应商提供的原始源代码开始，并按照你需要的方式构建软件，按需启用或禁用功能。对于经验丰富的用户来说，端口既快速又简单，但需要一定的 Unix 专业知识，对于新用户来说可能会感到有些吓人。

*软件包*是通过构建端口而生成的，使用端口维护者认为对最广泛的用户群体最有用的选项，并将它们打包成一个整体，方便安装。FreeBSD 项目有一整套系统，仅用于构建所有端口，打包并供用户下载和安装。软件包让你能够快速安装、卸载和升级附加软件。

**互联网建议永远不会消失**

论坛和邮件列表存档中有许多建议跳过软件包，直接使用端口。这已经不再正确；从技术角度和个人心态上看，软件包更为优选。旧的软件包系统 pkg_tools 有严重的限制。

忽略任何提到像 pkg_add(8)、pkg_delete(8)、pkg_create(8)等工具的推荐意见。它们已经过时了。

FreeBSD 高度灵活的软件包系统叫做*package*，pkg(8)，或简单称为 pkg。软件包信息存储在 SQLite 数据库中，这使得你可以对软件包数据执行任意查询。在开发过程中，pkg 曾被称为*pkgNG*。这个名称已经消失多年，但仍然出现在一些旧文档和第三方软件中。不要让这个名字混淆你。^(1)

我们将首先讨论如何使用 pkg(8)管理系统，然后继续讨论如何通过端口定制软件。

### **软件包**

软件包是来自 Ports Collection 的预编译软件，针对特定版本的 FreeBSD 进行打包。FreeBSD 项目提供了多个软件包集，并在公共仓库中发布，每几天更新一次。软件包是安装附加软件的最简单方式。任何没有法律分发限制的软件可能都可以作为软件包提供。

法律限制？软件可能具有任何许可证条款，包括一些非常奇怪的条款。有些软件的许可证禁止以任何非源代码形式进行分发。FreeBSD 在法律上无法将其打包。其他软件则只能以预编译形式合法分发。FreeBSD 通常会打包这类软件，将其作为预编译的二进制文件和 FreeBSD 特定的打包信息一起分发。

软件包是基于每个主要 FreeBSD 版本的最旧支持版本构建的。所有 FreeBSD 12 版本的软件包都是基于 FreeBSD 12 的最旧支持版本构建的，FreeBSD 13 的软件包是基于 FreeBSD 13 的最旧支持版本构建的，依此类推。这有助于减少、识别和解决 ABI 不兼容问题。

如果你需要建立自己的软件包仓库，查阅 Ports Collection（参见第十六章）以及附加软件包*poudriere*。

#### ***软件包文件***

最终，软件包包含文件。这些文件可能是二进制程序、文档、配置文件或软件可能需要的任何其他内容。这些文件被视为操作系统的一部分。不要手动编辑它们。

一个特殊的情况是，当软件包包含一个示例配置文件时。如果程序需要配置文件，软件包应该包括一个示例。你需要编辑该配置文件以适应你的需求——这就是配置文件的*用途*。

FreeBSD 通过安装带有后缀*.sample*的配置文件来解决这个问题。我们的 Web 服务器配置文件通常会以*httpd.conf.sample*的形式出现。

如果没有生产配置文件，软件包安装时也会将示例文件复制到适当位置。这个文件可以由你来编辑。

如果你升级了一个软件包，pkg(8)会将当前的生产文件与旧的示例文件进行比较。如果示例文件与生产版本相同，升级会替换生产文件。如果文件有任何差异，pkg 只会更新示例文件。合并任何需要的更改到生产配置是你的工作。请注意，软件包升级总是会替换示例配置文件，因此如果旧的示例文件很重要，你需要特别保存它。

#### ***介绍 pkg(8)***

与旧的打包系统不同，pkg(8)是一个单一程序，带有一大堆子命令。你将使用相同的程序来安装、卸载和调查软件包。所有对已安装软件包的更改必须以 root 身份运行。以下是如何安装所有有远见的系统管理员都需要的一个重要程序：

```
# pkg install emacs
```

那些对更优文本处理器抱有不合理偏见的人，可能想要将其删除。

```
# pkg delete emacs
```

所有包操作都使用 pkg(8) 命令。

虽然 pkg(8) 手册页记录了基本的 pkg 功能，但每个子命令都有自己的手册页，命名格式为 *pkg-* 加上子命令名。示例包括 pkg-install(8) 和 pkg-delete(8)。你也可以使用 `pkg help` 命令和子命令的名称获取帮助，例如，`pkg help install`。

FreeBSD 并没有预装 pkg(8)。你需要安装它……作为一个包。等等，别尖叫——它比听起来要*好得多*。

#### ***安装 pkg(8)***

FreeBSD 随附了一个非常简单的包管理器 */usr/sbin/pkg*，即 pkg(7)。它几乎没有足够的智能来找到 FreeBSD 当前的包管理器。它安装那个新的包管理器，并将所有包管理责任交给它。这使得 FreeBSD 在更新包管理器时具有灵活性。

当你第一次尝试安装一个包时，pkg(8) 会提示你安装包管理器。我发现在新服务器上需要安装 dmidecode 包，这样我才能从厂家获得坏电源的 RMA。（不用担心我如何*找到* dmidecode 包——暂时跟着我走就好。）

```
# pkg install dmidecode
```

FreeBSD 运行 pkg(8) 并发现尚未安装包管理。

```
The package management tool is not yet installed on your system.
Do you want to fetch and install it now? [y/N]: y
```

默认的答案以大写字母显示。如果我按 `n` 和回车，pkg 会终止。如果我按 `y` 和回车，FreeBSD 将启动系统。

```
➊ Bootstrapping pkg from pkg+http://pkg.FreeBSD.org/FreeBSD:12:amd64/quarterly, please wait...
➋ Verifying signature with trusted certificate pkg.freebsd.org.2013102301... done
➌ Installing pkg-1.10.0_2...
   Extracting pkg-1.10.0_2: 100%
➍ Updating FreeBSD repository catalogue...
   meta.txz                                 : 100%  944 B     0.9kB/s    00:01
   packagesite.txz                          : 100%    6 MiB   2.0MB/s    00:03
   Processing entries: 100%
   FreeBSD repository update completed. 26059 packages processed.
   All repositories are up to date.
   Updating database digests format: 100%
```

安装开始时会从 FreeBSD 镜像站点下载当前的 pkg 工具 ➊。然后它会检查下载文件的数字签名 ➋。工具被解压并安装 ➌。然后 pkg 下载并安装可用包的目录 ➍。

包管理系统现在已安装。为了顺利运行，FreeBSD 随附的简单 pkg(8) 告诉新安装的包管理系统去安装你真正想要的程序。在这种情况下，我们的新 pkg(8) 为你安装了 dmidecode。

你可以单独安装包管理系统，而不添加其他包，通过运行 pkg bootstrap ——但说实话，没人会在命令行中这么做。当包管理系统已经安装时，运行 pkg bootstrap 不会做任何事情，因此它主要用于安装脚本中。

#### ***常见的 pkg 选项***

虽然每个 pkg 子命令都有独特的功能，但有一些命令选项在几乎所有子命令中都能通用。

在默认配置下，pkg 在执行任何操作之前都会提示你确认。你可以通过 `-y` 标志告诉 pkg 执行操作而不提示你。

另一方面，也许你希望 pkg 显示如果你运行命令会做什么，但不实际执行任何操作。可以使用 `-n` 标志执行演练。例如，使用 `-n` 安装包时，会显示每个将要安装的包的名称，包括依赖包。然而，系统不会安装任何包，演练可以帮助你在维护窗口期间准备好变更。

许多 pkg 操作会生成大量输出。使用 `-q` 可以减少输出量。

`-a` 标志通常将命令应用于所有已安装的软件包。

最后，pkg 通常拒绝做无意义的事情或破坏系统的操作。`-f` 标志强制 pkg 执行你所说的操作。强制执行软件包活动通常是个坏主意，尽管不是总是如此。例如，你可能需要 `-f` 来强制重新安装损坏的软件包。

#### ***配置 pkg(8)***

pkg(8) 程序设计得非常灵活。虽然每个子命令有很多选项，但你可以通过配置文件 */usr/local/etc/pkg.conf* 为大多数程序建立定制但一致的行为。

*pkg.conf* 文件包含了为 pkg(8) 注释掉的默认值。它是一个很好的地方，可以查看系统在你完全没有修改它的情况下是如何运行的。配置采用 UCL 编写（见 第二章）。变量可以设置为整数、字符串（如文件路径）或布尔值，像 `YES` 或 `NO`。`YES`、`ON` 和 `TRUE` 是同义词，`NO`、`OFF` 和 `FALSE` 也是同义词。所有这些都不区分大小写。

```
#PKG_DBDIR = "/var/db/pkg";
#PKG_CACHEDIR = "/var/cache/pkg";
#PORTSDIR = "/usr/ports";
#INDEXDIR = "";
--snip--
```

FreeBSD 在 *pkg.conf* 为空的情况下也能正常运行。默认配置包含许多被注释掉的条目和相当多的别名。你可以考虑在继续时参考这些示例设置。

大多数 pkg 操作提供一个是/否对话框，默认值显示为大写字母。为了保持保守，pkg 通常默认设置为 `NO`。可以通过 `DEFAULT_ALWAYS_YES` 选项将默认值更改为 `YES`。

你可以通过添加 `-y` 标志使 pkg 命令假设你会对所有问题回答“是”。如果你不想每次都输入 `-y`，可以通过将 `ASSUME_ALWAYS_YES` 标志设置为 `YES`，让 pkg 始终假设你会回答“是”。

因为我懒但不鲁莽，所以我更喜欢这些 *pkg.conf* 设置：

```
DEFAULT_ALWAYS_YES = true;
ASSUME_ALWAYS_YES = false;
```

如果安装软件包时出现问题，可能需要调试输出。设置 `DEBUG_LEVEL` 可以开启调试输出。此变量接受从 0（不调试）到 4（完全调试）的整数值。

许多软件包在安装过程中包含脚本。通过将 `DEBUG_SCRIPTS` 设置为 `YES`，可以为每个脚本启用调试。

任何 *pkg.conf* 设置也可以用作环境变量。环境变量会覆盖配置文件中的任何设置。你可以像这样安装带有调试的包：

```
   # env DEBUG_LEVEL=4 pkg upgrade
```

所有选项都可以在 pkg.conf(5) 中找到文档。并不是所有的选项都有注释掉的条目。如果某个选项的示例不存在但你需要它，可以自行添加。我们将在接下来的章节中详细研究其中的许多选项。

#### ***查找软件包***

现在你已经安装了包管理器，可以安装软件包。熟悉各种类 Unix 操作系统的系统管理员知道，不同的操作系统会为同一软件的打包版本赋予不同的名称。在 FreeBSD 上，Apache Web 服务器的软件包名称与 illumos 或其他 Linux 发行版上的 Apache 软件包名称完全不同。在你安装任何东西之前，你需要弄清楚它的名称。

假设客户想在 Apache 上运行 WordPress。你的工作不是质疑客户选择的 Web 服务器；你的工作是构建和支持 Web 服务器。首先，使用 `pkg search` 命令查找 Apache。你需要提供一个文本字符串，供 pkg 执行不区分大小写的搜索。

```
# pkg search apache
apache-ant-1.9.7    Java- and XML-based build tool
apache-forrest-0.9  Tool for rapid development of small sites
apache-mode.el-2.0  Emacs major mode for editing Apache configuration files
--snip--
```

我故意选了一个麻烦的例子；FreeBSD 有大约 50 个与 Apache Web 服务器相关的软件包。幸运的是，每个搜索结果都会列出一行包描述。翻阅这些结果直到找到实际的 Web 服务器是非常简单的。

```
--snip--
apache22-2.2.31_1              Version 2.2.x of Apache web server with prefork MPM
apache22-event-mpm-2.2.31_1    Version 2.2.x of Apache web server with event MPM
apache22-itk-mpm-2.2.31_1      Version 2.2.x of Apache web server with itk MPM
apache22-peruser-mpm-2.2.31_1  Version 2.2.x of Apache web server with peruser MPM
apache22-worker-mpm-2.2.31_1   Version 2.2.x of Apache web server with worker MPM
apache24-2.4.25_1              Version 2.4.x of Apache web server
--snip--
```

六个不同版本的 Apache。首先，看一下软件包名称。当一款软件有多个版本时，主要版本号会被集成到软件包名称中。Apache 2.2 与 Apache 2.4 有很大不同，因此这些软件包被命名为 *apache22* 和 *apache24*。实际的版本号紧随其后。我们第一个 Apache 2.2 软件包实际上是 Apache 2.2.31。后缀 `_1` 是软件包的版本号，这意味着这是一个更新版的软件包。包含的软件没有变化，但软件包本身有所修改。软件包版本号的提升有两个原因。当源代码端口发生变化，且对软件包有实际影响时，版本号会增加。当所需的共享库发生 ABI 更改，需要重新编译软件包时，也会提升版本号。

Apache 2.2 有五个不同的软件包。熟悉 Apache 的人可能记得，Apache 的这个版本可以使用不同的多处理模块（MPM），但必须在编译时选择 MPM。我已经完全忘记了关于 MPM 的所有知识，因此我选择安装 Apache 2.4 包，`apache24`。

##### **软件包搜索选项**

有些搜索会生成数百个结果。试着搜索 Perl，你会得到大约 150 个软件包。Perl 模块的名称都以字符串 `p5-` 开头；FreeBSD 拥有超过 5200 个 Perl 模块的软件包！可以使用命令行选项来修剪或调整搜索结果。虽然 `pkg-search(8)` 列出了许多选项，这里是一些最常用的。

+   使用 `-C` 使搜索区分大小写。

+   如果你确切知道自己需要哪个软件包，并且只想查看它是否适用于你的系统，可以使用 `-e` 标志来搜索精确匹配。你的搜索词必须包含软件包版本号。

+   如果你需要高度自定义你的搜索和搜索结果，请查看 `-L`、`-S` 和 `-Q` 标志，参见 pkg-search(8)。

##### **检查已安装的包**

或许你不确定某个包是否是你真正想要的。你可能会去第三方网站查找该包的详细信息，比如 FreshPorts (*[`www.freshports.org/`](https://www.freshports.org/)*)，但这需要离开你的终端，而我不建议这么做。使用 `-R` 标志来查看包的仓库目录的元数据。这些元数据是每个包中内置的 *包清单* 的一个子集。

```
# pkg search -R apache24
name: "apache24"
origin: "www/apache24"
version: "2.4.25_1"
comment: "Version 2.4.x of Apache web server"
maintainer: "apache@FreeBSD.org"
www: "http://httpd.apache.org/"
--snip--
```

包清单包括包名、构建包的端口、软件版本、包仓库、依赖关系等字段。它很少被使用并且可能会发生变化，所以我们不会详细讨论，但浏览这些信息能提供关于包内软件的更多细节。

这里有一个重要的细节是 *www* 字段，它给出了原始软件来自的网站。这是 Apache Web 服务器，而不是某个使用该名称的分支或其他项目。

这个原始清单的默认格式是 YAML，即 “YAML Ain’t Markup Language”。它是另一种格式化配置文件的语法，但相当易于人类阅读。使用 `--raw-format` 标志选择备用格式。其他支持的格式包括 json 和 json-compact。

```
# pkg search -R --raw-format json-compact apache24
```

如果你想自动解析包信息，这就是获取原始数据的方式。

#### ***安装软件***

使用 pkg 的 `install` 子命令和包名来安装一个包。你不需要给出完整的包名。

```
# pkg install apache24
```

第一件事是 pkg 检查它本地的包数据库是否与包服务器上的数据库一致。你将看到类似“正在更新 FreeBSD 仓库目录”或“FreeBSD 仓库是最新的”这样的消息。

系统会检查你选择的包所需的任何其他包。阅读依赖列表。列表中有你不希望安装的内容吗？这个列表是否给出了 *不* 安装该包的理由？

```
The following 8 package(s) will be affected (of 0 checked):
New packages to be INSTALLED:
        apache24: 2.4.25_1
        libxml2: 2.9.4
--snip--
Number of packages to be installed: 8
```

最后的警告是，pkg 会告诉你安装所需的磁盘空间和带宽。然后你会被提示改变主意。

```
The process will require 139 MiB more space.
33 MiB to be downloaded.

Proceed with this action? [y/N]:
```

输入 y，pkg 会从仓库中获取该包并将其安装到你的系统上。

`install` 子命令假定你要么给出包的完整名称，要么给出没有版本号的包名。你可以请求 apache24 包，pkg 会自动识别当前包为 apache24-2.4.25_1。你也可以使用构建该包的端口名称，例如 `pkg install` `www/apache24`。

在上一节中，我们的软件包搜索显示了五个不同的 Apache 2.2 软件包，每个软件包是稍微不同的变体。如果你要求`pkg install`安装 apache22 软件包，它会安装名为 apache22 的软件包以及一个版本号。如果你想要某个变体，比如 apache22-event-mpm，可以在`install`命令中指定完整的软件包名称。

一些软件包包含安装消息。这些消息可能是有用的说明、警告、注意事项或其他相关内容。如果软件包创建者认为某条信息足够重要，值得花费宝贵的时间编写说明，那你至少应该阅读它。你可以使用 script(1)记录这些信息，或者运行`pkg info --pkg-message`并指定软件包名称再次查看这些信息。

##### **获取软件包**

FreeBSD 通过从互联网上下载软件包进行安装。你可能想在一个位置下载软件包，然后在其他地方或以后安装它们。使用 pkg fetch 命令可以下载但不安装软件包。结合`-d`选项使用`pkg fetch`命令最为合适，这样它会抓取所有依赖包以及指定的软件包。

```
# pkg fetch -d apache24
```

你会看到正常的仓库更新信息，之后会有 pkg 将要下载的内容通知。

```
New packages to be FETCHED:
        apache24-2.4.25_1 (5 MiB: 14.25% of the 33 MiB to download)
        libxml2-2.9.4 (821 KiB: 2.43% of the 33 MiB to download)
--snip--
```

验证 pkg 计划下载的内容是否与预期一致，然后按 y 继续。软件包会下载到软件包文件缓存中。

要安装已下载的软件包，正常运行 pkg install。安装过程会使用缓存的文件，而不是已下载的文件。

阅读 man 页面的用户可能会注意到`-a`标志，它会下载整个软件包仓库。不要使用这个选项。`-a`选项是为公共仓库镜像设计的。普通的系统管理员镜像整个仓库会浪费带宽，且会减慢系统速度。慷慨的人捐赠了 FreeBSD 的软件包服务器带宽，千万不要浪费它。你可能需要下载一大堆软件包，带有依赖关系时，可能需要数百个甚至数千个软件包，但你不需要下载成千上万的软件包。只下载你需要的内容。

##### **下载时机**

任何访问互联网的工具都需要设置最大下载时间。你可以通过两个*pkg.conf*设置来定制 pkg 的下载行为。

如果下载失败，pkg 会重试。`FETCH_RETRY`选项控制 pkg 重试下载的次数。默认情况下是三次，这意味着它会尝试下载一次，并最多重试三次。

在大多数现代互联网连接下，下载过程相当迅速。如果你的上行带宽不是那么现代，你可能需要增加 pkg 在单次下载尝试中花费的时间。`FETCH_TIMEOUT`设置控制 pkg 等待某个文件下载的时间。默认值为 30，限制下载时间为 30 秒。如果你正在通过 33.6 的调制解调器下载 LibreOffice，你可能需要增加这个设置，并考虑通过“马车快递”将文件送到可移动驱动器上。

#### ***包缓存***

下载包并稍后安装的功能意味着 pkg(8)会将这些包存储在磁盘上的某个地方以供以后使用。包缓存目录*/var/cache/pkg*包含从互联网下载的原始包文件。尽管你可以多年管理 FreeBSD 主机而无需处理缓存，但这里有一些你需要知道的事情。

##### **清理缓存**

由于升级、新包、删除的包以及系统管理的随机性，缓存目录可能会填满。我的 Web 服务器只有几个包，但不知怎的已经积累了 1.7GB 的旧包文件。`pkg clean`命令会删除任何已被新版本替换的缓存包，以及任何不再在仓库中的包文件。你将看到所有将被删除的文件列表，并有机会继续或退出。

```
# pkg clean
The following package files will be deleted:
        /var/cache/pkg/php56-mbstring-5.6.26.txz
        /var/cache/pkg/mod_php56-5.6.21-c80f5ce183.txz
--snip--
```

如果你从未清理过长期运行系统上的包缓存，列表可能会非常长。在提示符下，按 y 继续。

如果你想删除所有缓存的包，可以使用`-a`标志。

记住，`pkg clean`会删除那些不再在包仓库中的包文件。如果你依赖于某个已从仓库中删除的包，在清理之前请将该文件备份到缓存之外，否则它会被无意删除。你也可以尝试 pkg-create(8)来从已安装的组件重新构建一个包。

如果你希望在每次安装或升级包后自动清理包缓存，请将*pkg.conf*中的选项`AUTOCLEAN`设置为 true。我觉得自动清理过于激进，因为有时升级后的新包中的错误迫使我恢复到旧版本。我们将在本章末尾讨论包的升级问题。

##### **移动缓存**

你可能希望将包缓存放在文件系统的其他位置。使用*pkg.conf*中的选项`PKG_CACHEDIR`来设置一个新的包缓存目录。

为什么要移动缓存目录？许多服务器集群会在多台机器之间共享一个包缓存。你可以安全地在运行相同 FreeBSD 主版本和硬件架构的主机之间共享包缓存。确保你的 NFS 配置使用了锁定，并设置*pkg.conf*中的选项`NFS_WITH_PROPER_LOCKING`。

#### ***包信息与自动安装***

一段时间后，你会忘记你在系统上安装了哪些包。使用`pkg info`获取已安装软件的完整列表。

```
# pkg info
gettext-runtime-0.19.8.1_1  GNU gettext runtime libraries and programs
indexinfo-0.2.6             Utility to regenerate the GNU info page index
--snip--
```

如果你想了解更多关于已安装包的信息，使用`pkg info`和包名。这样会显示一个易于理解的报告，列出包清单和安装细节。

```
# pkg info apache24
apache24-2.4.25_1
Name           : apache24
Version        : 2.4.25_1
Installed on   : Tue Mar 14 16:56:14 2017 EDT
Origin         : www/apache24
Architecture   : freebsd:12:x86:64
--snip--
```

这个包是什么时候安装的？这个包是在这台机器上从 Ports Tree 构建并启用了某些选项吗？它的许可证是什么？该包中的每个程序需要哪些共享库？使用`pkg info`和包名，你可以回答这些问题以及更多问题。

`pkg info`子命令有许多其他功能。我们将在本章稍后看到其中的一些，例如锁定状态。pkg-info(8)手册页有完整的细节。

##### **自动安装包**

回顾一下示例的`pkg info`输出。我故意在这个系统上安装了几个不同的程序，但我可以肯定我从未故意安装任何关于 GNU 信息页面或 gettext 的内容。

我确实安装了那些程序。我只是没有太关注它们是什么，因为我更关心的是安装那个需要它们的包。它们是依赖项。

FreeBSD 会记录你是请求安装了某个包，还是它作为依赖项被带入。作为依赖项安装的包被称为*自动*包。你请求的包只是包，尽管有时也称它们为*非自动*包。

你可能想知道哪些包是你要求安装的，哪些是作为依赖项被拖入的。到这时，事情就变得复杂了。

##### **查询包数据库**

pkg 工具无法覆盖系统管理员可能遇到的所有情况。获取一些信息的最简单方法是查询已安装的包数据库。虽然你可以使用原始的 SQLite，但那意味着你需要深入了解数据库的内部结构。大多数系统管理员没有那么多时间，特别是当数据库可能随时发生变化时。FreeBSD 通过`pkg query`子命令隔离了这一点。完整的包查询概述会占据一章的篇幅，但这里提供一个快速的概览。

**远程查询**

使用 pkg-query(8)来搜索已安装包的数据库。不过，如果你仓库中可用的包数据库是最新的，你也可以使用 pkg-rquery(8)进行搜索。然而，可用包的数据库并不包含已安装包的所有元数据，因此并非所有模式都可以使用。

任何你可能想从包数据库中提取的信息，都可以通过`pkg query`轻松表示。关键是，任何人可能想从包数据库中提取的所有信息，都在`pkg query`中，正如快速浏览 pkg-query(8)所展示的那样。查询和命令结构是专门为脚本使用设计的，但我们有时会互动式使用它。

通过使用 *模式* 来运行查询。模式是一个有指定含义的变量，用百分号和字母表示。例如，`%n` 包含包名，`%o` 包含构建该包的端口，`%t` 包含表示包安装时间戳的时间戳。

运行 `pkg query` 并给定一个模式，会为每个安装的包输出该值。由于 `%n` 代表包名，以下是你如何获取系统上所有内容的列表：

```
# pkg query %n
apache24
apr
--snip--
```

我们没有得到 `pkg info` 显示的额外信息——但也许这正是你想要的。

你可以在一个查询中请求多个项。`%v` 模式代表包的版本，而 `%c` 代表评论。在这里，我用破折号分隔包名和版本，但在版本和评论之间放置一个制表符。使用 shell 制表符字符 `\t` 意味着我必须为 `pkg query` 参数加上引号。

```
# pkg query "%n-%v\t%c"
apache24-2.4.25_1       Version 2.4.x of Apache web server
apr-1.5.2.1.5.4_2       Apache Portability Library
--snip--
```

你知道，这看起来非常像 `pkg info` 的输出。当 pkg 命令查询或操作包数据库时，它使用的是这些完全相同的模式。你对包装系统的可视化程度与其他工具相同。

如果你想获取特定包的模式，将包名作为最后一个参数。在这里，我获取 apache24 包来源的端口：

```
# pkg query %o apache24
www/apache24
```

当然，我们在查询所有包和查询特定包之间有一个中间选择。

##### **查询中的评估**

这里有一个最后的巧妙包查询功能。许多——但不是所有的——模式都可以作为变量使用。一个命令可以评估这些变量，并根据结果采取行动。使用 `-e` 命令行选项可以评估变量，并使用逻辑运算符。逻辑运算符的完整列表可以在 pkg-query(8) 中找到。

评估可以分解成“如果这个为真，就做那个”。测试放在引号内。这里有一个例子：

```
# pkg query -e '%a = 0' %n
```

这个查询遍历了所有安装的包。`-e` 表示我们正在评估每个包的一个变量。引号内的语句 `%a = 0` 意味着我们在测试该包的 `%a` 值。如果 `%a` 等于 0，查询就会为真，`pkg query` 会打印出 `%n` 的内容。如果 `%a` 等于 0 以外的任何值，语句为假，`pkg query` 会跳过该包并继续处理下一个包。

我们已经知道 `%n` 包含包名。变量 `%a` 包含 pkg 记录的包是否是自动安装的。如果你请求了这个特定的包，它被设置为 0。如果一个包最初是作为依赖安装的，它被设置为 1。所以：如果一个包不是依赖包，就打印出包名。这个查询打印的是非自动安装的包。

```
# pkg query -e '%a = 0' %n
apache24
dmidecode
pkg
youtube_dl
```

这里有几点需要注意。首先，我并没有故意请求 pkg 安装 pkg(8)。我请求了 dmidecode，而 pkg 自我引导安装了。pkg 套件本身始终被视为非自动安装的包。

第二个：谁在这个机器上安装了 youtube_dl？

要找出哪些软件包是作为依赖安装的，请检查`%a`是否设置为 1。

**= 或 ==?**

您将看到使用双等号的示例，就像`pkg query`是编程语言一样。我的示例使用单等号。两者之间肯定有一些细微的差别，以及在特殊条件下应该使用每个符号的情况？

不！

您可以根据自己的肌肉记忆偏好使用单等号或双等号。

但实际上，我不会费心记住如何在所有主机上运行这个查询。我需要一种简单的方式让 pkg(8)为我记住它。

##### **Pkg 命令别名**

您可以在*pkg.conf*中定义 pkg 子命令的别名。这允许您创建别名来显示自动和非自动命令。尽管我也可以在我的 shell 中做类似的事情，但它不会显示为 pkg(8)子命令，而且我很容易困惑。

在*pkg.conf*的底部，您会找到一个名为`ALIAS`的部分。

```
ALIAS              : {
  all-depends: query %dn-%dv,
  annotations: info -A,
--snip--
  }
```

别名是别名名称的单个单词，后跟冒号或等号，然后是要运行的 pkg 命令。如果您运行`pkg all-depends`，pkg(8)会在*pkg.conf*中查找并运行`pkg query %dn-%dv`。每个别名以冒号结尾，表示别名列表将在下一行继续。

默认配置中的许多别名代表了从 pkg_add aeon 遗留下来的东西，这是为我们这些老家伙创建的。尽管如此，现有的别名是查找示例查询和搜索的好地方。而且，通过别名搜索，您会找到以下这个很好的条目：

```
noauto = "query -e '%a == 0' '%n-%v'",
```

这个别名，*noauto*，运行一个`pkg query`命令来评估`%a`，并在其值为 0 时打印软件包的名称和版本号。它会打印那些未自动安装的软件包。我添加了一个非常相似的别名，用于打印自动安装的软件包。

```
auto = "query -e '%a == 1' '%n-%v'",
```

当您发现自己反复运行复杂命令时，可以添加别名。

#### ***卸载软件包***

我们都曾安装软件，最后却因厌恶而将其卸载。唯一的区别是，究竟是什么让我们感到厌恶。使用`pkg delete`子命令卸载软件包。它也可以通过`pkg remove`来实现。那个多余的 youtube_dl 软件包？让我们把它从系统中移除。

```
# pkg delete youtube_dl
Checking integrity... done (0 conflicting)
```

删除过程会确保软件包没有出现严重问题，没有其他软件包需要它，并且它的删除不会导致软件包系统无法预测的严重问题。^(2)

然后，您将看到要删除的软件包列表以及它们释放的空间量。最后会有一个最终的机会让您选择“不”。

```
Proceed with deinstalling packages? [Y/n]: y

[1/1] Deinstalling youtube_dl-2017.02.11...
[1/1] Deleting files for youtube_dl-2017.02.11: 100%
```

该软件包已从您的系统中删除。

##### **移除依赖**

如果您删除一个其他软件包依赖的包，pkg 也会删除依赖的软件包。

```
# pkg delete trousers
--snip--
Installed packages to be REMOVED:
        trousers-0.3.14_1
        gnutls-3.5.9
        emacs-nox11-25.1,3
--snip--
```

gnutls 软件包需要 trousers，而 emacs-nox11 需要 gnutls。删除 trousers 会破坏它们两个，因此 pkg 认为您显然也不想在系统中保留它们。

如果您真的想删除一个其他软件包依赖的包，请添加`-f`标志。

请*非常*小心地阅读`pkg delete`的警告信息！

##### **自动移除**

在主机上保留不必要的软件会增加安全风险并增加系统管理员的工作量。在长期运行的系统上，你并不总是知道该删除哪些软件。删除你选择安装的软件很容易，但这些软件可能带来了你从未关注过的依赖项。或者，某个软件包的新版本可能比旧版本具有更少或不同的依赖项。

我从我的测试系统中删除了 youtube_dl 软件包。这样就只剩下我故意安装的其他软件包及其依赖项。它也保留了 youtube_dl 依赖的但没有其他软件包需要的那些软件包。`pkg autoremove`子命令识别出作为依赖项安装但不再被其他任何软件包需要的软件包，并提供删除这些不再需要的软件包。我强烈建议在删除不需要的依赖项之前执行一次模拟运行，给你脆弱的人类大脑一次检查列表的机会。

```
# pkg autoremove
```

Pkg 运行数据库查询以识别不需要的依赖项，并提议删除它们。

```
Installed packages to be REMOVED:
        python27-2.7.13_1
        readline-6.3.8
        rtmpdump-2.4.20151223
        librtmp-2.4.20151223
--snip--
```

仔细研究这个列表。非软件包软件需要通过其他途径引入的软件包并不罕见。你可能不需要没有 youtube_dl 的 rtmpdump 和 librtmp 视频处理工具，但很多软件都需要 Python 解释器。你*真的*想删除它吗？

如果你真的可以删除这些软件包，回答`y`并继续。如果其中某个依赖项变得至关重要，那么改变你的数据库来告诉它。

#### ***更改软件包数据库***

想要在 pkg(8)之外更改软件包数据库吗？不要。你只会给自己带来麻烦，寻求帮助时要么会遭遇嘲笑，要么会被建议删除所有软件包并重新开始。

有几个情况 pkg(8)支持更改软件包数据库。那时你可以使用`pkg set`。pkg-set(8)子命令允许你在不破坏数据的情况下正确调整数据库中的一些合理值。最常见的情况是当你想让一个自动软件包不再是自动的。

`pkg set`的`-A`标志允许你更改软件包的自动设置。将此标志设置为 1 表示该软件包是自动安装的，作为依赖项，而设置为 0 则表示该软件包是用户专门请求的。

在上一节中，`pkg autoremove`要删除的四个软件包中包括了 Python。我想保留 Python——不仅是这次，而且是今后每次执行 autoremove 时。我保持 Python 的方法很简单，就是把它从自动软件包改为非自动软件包。

```
# pkg set -A 0 python27
Mark python27-2.7.13_1 as not automatically installed? [Y/n]: y
```

现在，Python 是一个非自动软件包。`pkg autoremove`的结果现在看起来不同了。

```
# pkg autoremove -n
--snip--
Installed packages to be REMOVED:
        rtmpdump-2.4.20151223
        librtmp-2.4.20151223
--snip--
```

现在只剩两个软件包，而不是四个？显然 Python 需要 readline。我很高兴 pkg 帮我找出了这一点，因为我实在不想记住这些。

我们会根据需要进一步讲解`pkg set`。

#### ***锁定软件包***

有些软件就像地铁的电气化轨道。触摸它会导致痛苦或死亡。

我最喜欢的例子是远程文件同步程序 rsync(8)。rsync 已经存在几十年了，其内部协议随着时间的推移发生了变化。许多嵌入式和遗留系统使用 rsync，但它从未被升级。我曾花费许多痛苦的小时调试为什么当前的 rsync 无法与 20 世纪的嵌入式电话交换机控制器进行通信。结果发现，某个 rsync 版本的发布去掉了对电话交换机支持的非常旧协议的支持。由于无法升级电话交换机，因此我需要确保主机上的 rsync 软件包永远不会升级。*永远*。

这就是锁定软件包的作用。

当你锁定一个软件包时，pkg 将不会对其进行升级、降级、卸载或重新安装。它将对软件包的依赖项和它所依赖的程序应用相同的规则。负责获取电话交换机文件的主机需要锁定其 rsync 软件包。使用`pkg lock`来锁定软件包。

```
# pkg lock rsync
rsync-3.1.2_6: lock this package? [Y/n]: y
Locking rsync-3.1.2_6
```

这个软件包现在已经固定在原位。

要显示系统上所有被锁定的软件包，请使用`-l`标志。这只会显示你有意锁定的软件包，而不会显示依赖项或依赖关系。

```
# pkg lock -l
Currently locked packages:
rsync-3.1.2_6
```

使用`pkg unlock`命令来移除锁定。

```
# pkg unlock rsync
rsync-3.1.2_6: unlock this package? [Y/n]: y
Unlocking rsync-3.1.2_6
```

要锁定或解锁系统上的所有软件包，请使用`-a`标志。每个软件包都会弹出确认提示，因此，如果你真的想影响所有软件包，请添加`-y`标志。

```
# pkg unlock -a
apache24-2.4.25_1: already unlocked
apr-1.5.2.1.5.4_2: already unlocked
--snip--
rsync-3.1.2_6: unlock this package? [Y/n]: y
Unlocking rsync-3.1.2_6
--snip--
```

软件包锁定并不能阻止具有 root 权限的人修改软件包中包含的文件。

相关的内容，第二十二章讲解了如何使用监狱来限制非常旧的软件。

#### ***软件包文件***

由软件包安装的文件被视为系统文件，你不应该手动编辑它们。在你*可以*编辑这些文件之前，必须知道哪些文件是由软件包带来的。使用`pkg info -l`和软件包名称查看完整的文件列表。（通过*pkg.conf*别名，这个信息也可以通过`pkg list`获得。）

```
# pkg info -l rsync
rsync-3.1.2_6:
        /usr/local/bin/rsync
        /usr/local/etc/rc.d/rsyncd
        /usr/local/etc/rsync/rsyncd.conf.sample
--snip--
```

另一种可能性是你想知道某个文件来自哪个软件包。使用`pkg which`命令。当我发现一个奇怪的库时，我通常会用这个命令来看看它是从哪里来的。

```
# pkg which libp11-kit.so
/usr/local/lib/libp11-kit.so was installed by package p11-kit-0.23.5
```

我的疑问现在是：“什么是 p11-kit？”但这算是进步。

#### ***软件包完整性***

尽管你不应该修改软件包文件，但最终，还是会有人这么做。你可以使用 pkg 来发现这些更改并撤销损害。

pkg-check(8)工具包括用于识别软件包和软件包依赖关系损坏的功能。开发者也可以使用 pkg-check(8)检查从端口构建并分发给最终用户的捆绑软件包，但那是一个完全不同的问题。

##### **文件损坏**

使用`pkg check -s`和软件包名称来验证软件包文件是否未被修改。当我锁定的 rsync 软件包停止从挑剔的远程服务器同步文件时，我会验证其中一个事项就是软件包完整性。

```
# pkg check -s rsync
Checking rsync:   0%
rsync-3.1.2_6: checksum mismatch for /usr/local/bin/rsync
Checking rsync: 100%
```

要么是磁盘出现故障，要么是有人动过我的 rsync(1)二进制文件。由于这个系统使用自修复的 ZFS，所以会有一番“修补”。

你可以卸载并重新安装这个包，但这可能会触发其他依赖该包的包发生变化。另外，正如前面讨论的，这个特定的包很特殊。我不想让 pkg 将这个包升级到最新版本，而是希望强制 pkg 从包缓存中重新安装当前版本。使用`-f`标志执行`pkg install`。虽然它会更新仓库数据库，但会重新安装缓存中的包。如果该包被锁定，你必须先解锁它。

```
# pkg unlock -y rsync
Unlocking rsync-3.1.2_6
# pkg install -fy rsync
--snip--
[1/1] Reinstalling rsync-3.1.2_6...
[1/1] Extracting rsync-3.1.2_6: 100%
# pkg lock -y rsync
```

我珍贵的 rsync 已经恢复了。

通过运行`pkg check -saq`检查所有包的完整性。除非有变动，否则不会产生任何输出，因此你可以通过 cron 定时运行它（见第二十章）。

##### **依赖性问题**

如果有人真的想尝试，他们可以删除其他包依赖的包。使用`pkg check`的`-d`标志来识别并修复缺失的依赖。

```
# pkg check -d emacs-nox11
Checking emacs-nox11: 100%
emacs-nox11 has a missing dependency: gnutls
emacs-nox11 is missing a required shared library: ➊libgnutls.so.30
--snip--
>>> Try to fix the missing dependencies? [Y/n]: y
```

首先要注意的是，当`pkg check`识别到缺失的依赖时，它会尝试修复它。对提示回答 y 以重新安装该依赖。

注意，这个`pkg check`运行显示我们缺少一个库，libgnutls.so.30 ➊。依赖性检查实际上并不会搜索所有包中的所有文件。它之所以知道这个库缺失，是因为包含它的包已经不存在了。如果你手动删除了这个库，依赖性检查是无法找到它的。你需要像之前一样检查包文件的完整性。

如果你想用`pkg check -d`检查所有包的依赖关系，不要提供包名。你可以添加`-a`来显式检查所有包，但这并不是必需的。如果你添加`-q`标志，这个命令只有在发现问题时才会输出结果。添加`-q`还告诉`pkg check`尝试自动解决它发现的任何依赖性问题，而无需用户干预。

这种组合意味着，虽然我可以将这个检查作为定期任务运行，但我对于我的主机重新安装缺失的依赖并不太放心。在自动修复依赖问题之前，考虑一下系统在没有你关注的情况下安装包的情况。

`pkg check`子命令包括一些其他有用的选项，例如`-B`用于重建共享库依赖，`-r`用于手动重新计算已安装包的校验和。详情请参阅 pkg-check(8)。

#### ***包维护***

包管理系统包括一些维护脚本，旨在通过 periodic(8)运行。从*/etc/periodic.conf*启用这些脚本，如第二十章所讨论的那样。每个脚本都会添加到每日、每周或安全状态的电子邮件中。

要进行每日维护检查包的校验和并替换损坏的包，像`pkg check -saq`一样，将`daily_status_security_pkg_checksum_enable`设置为 YES。

为了检测已安装的软件包是否存在 FreeBSD 软件包安全系统中发布的安全漏洞，如 第十九章所讨论的，可以将 `daily_status_security_pkgaudit_enable` 设置为 YES。

如果你希望 FreeBSD 每天备份已安装的软件包和软件包数据库，请将 `daily_backup_pkg_enable` 设置为 YES。

为了接收已安装软件包的变更通知，将 `daily_status_pkg_changes_enable` 设置为 YES。

最后，你可以通过将 `weekly_status_pkg_enable` 设置为 YES，每周检查过时的软件包。

#### ***软件包网络配置和环境***

FreeBSD 的软件包系统是为了适应普通的互联网连接网络而设计的。这有点像一个残酷的笑话，因为没有网络是“正常”的。你可以调整 pkg 的行为以适应你的网络。

最常见的变更是需要使用代理服务器。Pkg 使用 fetch(3) 下载软件包文件，任何特殊的网络配置都可以通过环境变量进行设置。在 *pkg.conf* 文件的 `PKG_ENV` 部分设置环境变量。每个变量需要包括变量名、冒号和对应的值。在这里，我将 `HTTP_PROXY` 环境变量设置为我的网络代理：

```
pkg_env : {
  HTTP_PROXY: "http://proxy.mwl.io/"
}
```

查看 fetch(3) 以获取完整的代理环境设置列表。

有些网络为不同的网络协议栈分配了独立的带宽。我曾经使用过多个网络，其中某些网络在 IPv6 上的连接速度比 IPv4 更好，或者反之。你可以通过在 *pkg.conf* 文件中设置 `IP_VERSION` 来让 pkg 使用某个特定的网络协议。你可以将此设置为 4、6，或者让主机默认自动选择（默认为 0）。

最后，*pkg.conf* 文件中的 `NAMESERVER` 设置允许你覆盖 */etc/resolv.conf* 中的 DNS 服务器。在此处可以输入 IPv4 或 IPv6 地址。你也可以使用主机名，pkg 会通过系统默认的 DNS 服务器来查找该主机名。

### **软件包仓库**

你可能希望使用 FreeBSD 项目提供的以外的软件包。也许你自己构建了软件包，正如 第十六章 所讨论的那样。或者你可能有权访问一个实验性的软件包仓库。又或者你想要切换使用的官方软件包集合。

Pkg 支持软件包 *仓库*，或 *repo*，它们是命名的软件包集合。你可以添加、删除、启用和禁用这些仓库。

正常的仓库配置非常简单，但在少数情况下，它们可能会变得相当复杂。我们不会深入讨论配置自定义仓库的极端情况，但基础知识会让你走得很远。

#### ***仓库配置***

在各自的文件中配置每个仓库。官方的 FreeBSD 仓库应放置在 */etc/pkg* 目录下。仓库配置使用 UCL 格式（参见 第二章）。FreeBSD 默认启用了 FreeBSD 仓库。你可以在 */etc/pkg/FreeBSD.conf* 文件中找到该配置文件。

```
   FreeBSD: {
➊ url: "pkg+http://pkg.FreeBSD.org/${ABI}/quarterly",
➋ mirror_type: "srv",
➌ signature_type: "fingerprints",
➍ fingerprints: "/usr/share/keys/pkg",
➎ enabled: yes
   }
```

这个名为 *FreeBSD* 的仓库支持 FreeBSD 的软件包仓库。当你决定设置自己的仓库时，给它起个有意义的名字。

`mirror_type` 条目 ➋ 告诉 pkg 该仓库是否托管在一个普通的网站上。将 `mirror_type` 设置为 `NONE` 会告诉 pkg 使用 fetch 通过标准网络方法（如 HTTP、FTP，甚至是文件路径）来获取软件包。

数百万台机器运行 FreeBSD 并需要访问软件包仓库。单个 web 服务器无法满足需求。通过将 `mirror_type` 设置为 `srv`，你告诉 pkg 检查 DNS 是否有 SRV 记录。SRV 记录用于引导高可用性服务，如 VoIP 和 Active Directory。

`url` 条目 ➊ 显示了该仓库所在的互联网网站。我相信你之前见过 http URLs，那这个 pkg+http 是怎么回事呢？它将请求与用于引导 pkg 请求的 SRV 记录绑定在一起，正如 `mirror_type` 所设置的那样。

包管理系统可以通过公钥或加密哈希指纹 ➌ 来验证下载的软件包。但你需要告诉 pkg 在哪里找到这些密钥或哈希 ➍。

最后，你必须显式地启用或禁用 ➎ 每个仓库。

#### ***仓库定制***

你可以根据需要添加和移除仓库。由于 */etc/pkg* 保留用于官方 FreeBSD 仓库，你需要另一个目录。传统的位置是 */usr/local/etc/pkg/repos*。如果你想使用不同的目录，你需要在 *pkg.conf* 中通过 `REPO_DIRS` 选项设置一个位置。你将看到注释掉的默认示例。

```
#REPOS_DIR [
#    "/etc/pkg/",
#    "/usr/local/etc/pkg/repos/",
#]
```

本地仓库目录默认不存在，因此你需要创建它。

```
# mkdir -p /usr/local/pkg/repos
```

将你自己的仓库配置放在那个目录里。

FreeBSD 按照目录顺序搜索软件包，检查 `REPOS_DIR` 中给定顺序的目录。显而易见的含义是，默认的 FreeBSD 仓库不能被禁用或覆盖。虽然这不完全正确，但原因有些复杂。

#### ***仓库继承***

你可以将一个仓库的配置分割到多个文件中。后续文件中的条目会覆盖前面文件中的条目。

要查看这如何工作，可以考虑默认的仓库，名为 *FreeBSD*。如果你在 */usr/local/etc/pkg/repos* 中配置了所有自定义仓库，pkg 会首先找到 FreeBSD 仓库。

但现在创建一个 */usr/local/etc/pkg/repos/FreeBSD.conf* 文件。在里面定义 FreeBSD 仓库，但只包括一个配置声明。

```
FreeBSD: { enabled: no }
```

Pkg 在 */etc/pkg/FreeBSD.conf* 中首先找到名为 FreeBSD 的仓库。此配置定义了该仓库的默认设置。它稍后会找到第二个配置。第二个配置只覆盖一个选项，但该选项会禁用仓库。

虽然禁用 FreeBSD 仓库是一个极端的例子，适用于那些不运行自己仓库的人，但对仓库进行小幅修改是有充分理由的，正如我们接下来将看到的。

### **软件包分支**

FreeBSD 的软件包是从 Ports 集合中构建的（参见第十六章）。Ports 集合试图将成千上万种不同的软件套件带到 FreeBSD 上。这些不同的程序都有自己的发布计划，而 Ports 集合也在不断演进，努力跟上它们的步伐。正如你能想象的那样，Ports 集合充满了变化。我们大多数运行服务器的人都更看重稳定性。当大多数系统管理员谈到“稳定性”时，*变化*这个词并不是他们脑海中的第一印象。

我们大多数人并不需要在服务器上安装最新的软件。大多数时候，如果我的数据库服务器只是稍微落后一个或两个小版本，我是没问题的；我只关心它是否能继续正常工作。我当然不会因为 MySQL、nginx 或 PHP 发布了新版本就升级我的服务器。那样做会陷入不断升级的疯狂之中。

我确实希望获得安全性和稳定性的更新。然而，数据库服务器稍微老旧一点我并不在乎。数据库服务器偶尔失去“理智”并将我的所有数据发送到垃圾桶，或者把所有数据提供给底特律的黑客团队，这让我非常不安。

FreeBSD 的软件包系统的*季度分支*试图在世界上不断变化的软件和系统管理员的心理平衡之间找到一个中间点。每年的一月、四月、七月和十月，Ports 团队会将 Ports 集合分叉成一个季度分支。季度分支只会接收安全性和稳定性更新，而主 Ports 集合则继续快速发展。

FreeBSD 项目为每个版本构建了两套软件包。*季度*软件包是从季度 Ports 集合中构建的。*最新*软件包则是从前沿的软件包中构建的。

你们中的一些人虽然不喜欢软件包频繁更新，但还是偏爱使用最新的软件包。没关系，切换很简单。你只需要覆盖 FreeBSD 仓库中的一个条目。像上一节那样创建一个新的仓库文件，*/usr/local/etc/pkg/repos/FreeBSD.conf*。不过，这次我们不会禁用默认仓库，而是要覆盖软件包来源。将 URL 末尾的“quarterly”改为“latest”。

```
FreeBSD: { url: "pkg+http://pkg.FreeBSD.org/${ABI}/latest" }
```

欢迎来到频繁变动的世界！

强烈建议在更改仓库后运行`pkg update -f`，以强制 pkg 下载最新的仓库目录。

切换软件包集合并不意味着你需要重新安装所有内容。如果你旧的软件包能正常工作，就继续使用它们。不过，如果出现奇怪的问题，可以使用类似 `pkg upgrade -fa` 的命令重新安装所有软件包。即使是版本相同的其他软件包，它们可能也会有所不同。

### **升级软件包**

尽管我们可能希望它是另一种情况，但你不能忽视一个新系统的建立。要么会出现稳定性错误，要么某个聪明的家伙发现了一个安全漏洞。(第十九章讨论了包安全的审计。) 有时你必须升级第三方软件。在 FreeBSD 的原始包管理系统 pkg_add 中，包升级存在一定程度的麻烦风险。而使用 pkg(8)时，你仍然会遇到麻烦——但这来自于软件的新版本，而不是包管理系统本身。

在升级包之前，先备份系统。然后，使用`upgrade`子命令让 pkg(8)升级所有包。我建议首先运行干运行，使用`-n`选项。

```
# pkg upgrade -n
--snip--
Checking for upgrades (2 candidates): 100%
Processing candidates (2 candidates): 100%
The following 1 package(s) will be affected (of 0 checked):

Installed packages to be UPGRADED:
        ca_root_nss: 3.29.1 -> 3.29.3

Number of packages to be upgraded: 1

335 KiB to be downloaded.
```

仔细查看待升级的包列表。是否有大的跳跃？是否需要查看任何发行说明？这次升级可能会造成多大影响？升级是否会移除你需要的某些包，比如*X.org*或你的文本编辑器？你是否应该等到周日凌晨 3 点，再让你的下属来处理？^(3) 研究升级内容并考虑每个包升级的风险，可能不会减少你需要做的工作量，但它会减少停机时间和被人责骂的时间。

一旦你对将要发生的变化感到满意，就可以运行升级了。

```
# pkg upgrade -y
```

你将看到关于待升级包的非常相似的信息，然后是下载和安装过程的通知。最后，pkg 会显示每个升级包的安装信息。

即使是世界上最灵活的包管理系统也并不总能满足你的需求。FreeBSD 通过 Ports Collection 使得定制附加软件变得非常容易，我们将进入下一个部分。
