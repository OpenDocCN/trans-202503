## **24

**问题报告和紧急情况**

![image](img/common01.jpg)

FreeBSD 是由人类生产的。人类会犯错。其中一些错误可能微不足道，而另一些则可能导致整个系统崩溃。FreeBSD 明确声明不提供任何保证，但社区对问题非常认真。然而，开发者无法在没有适当的 bug 报告的情况下修复这些问题，而你正是解决问题的关键所在。学习如何提交一个可用的 bug 报告将帮助你与不仅仅是 FreeBSD 项目，还包括所有其他生产软件实体进行互动。

Bug 报告需要展示证明 bug 的程序输出，但如果问题导致整个系统崩溃呢？系统停止的 *panic* 或许是最棘手的问题，但通过适当的准备，你可以像处理任何其他不那么入侵性的 bug 一样处理 panic。FreeBSD 的开发人员确实希望从你的 panic 报告中获得调试输出，并且你可以在问题报告中轻松地提供这些信息。

但首先是有用的 bug 报告。

### **Bug 报告**

*Bug 报告* 是对导致系统表现出意外行为的问题的详细描述。这种描述可能有些模糊，是的。什么算是意外行为？什么算是问题？有效的问题报告范围很广，从“我期望这个东西有一个 man 手册页”到“当我挂载 SMB 文件系统时，操作系统崩溃”。像缺少 man 手册页引用这样的微不足道的问题可能看起来不值得你花时间报告，但每个 man 手册页中的每个引用之所以存在，是因为有人认为它值得包含进去。那么，什么是 bug 报告，什么又不是呢？

Bug 报告不仅仅是说你有问题。Bug 报告是证明 *FreeBSD* 存在问题的地方。是的，我说的是 *证明*。并非 FreeBSD 无罪推定，但要提交 bug 报告，你必须证实你的声明。未附带证据的 bug 报告将会被关闭，并附有简短的回复，比如“不是 bug”或“无用的报告”。寻求帮助的正确途径是首先使用搜索引擎，然后是邮件列表或 FreeBSD 论坛。

任何形式的“我不知道我在做什么”都不应包含在 bug 报告中。这包括“FreeBSD 不按我预期的方式工作”或“我做了一些愚蠢的事情时发生了一些不好的事情”。如果你以一名新手的身份在被评为高难度的悬崖上进行自由攀岩，摔倒并摔断了脖子，医院必须接待你。如果你在运行 newfs(8) 时半途抽掉新硬盘并抱怨文件系统损坏，FreeBSD 的人员会驳回你的 bug 报告。

Bug 可能涉及系统不一致性。每个网络接口、API 和系统调用都有 man 手册页。如果你尝试调用系统调用的 man 手册页却找不到匹配项，那就是一个 bug。如果你在阅读源代码时发现文档与代码不匹配的情况，那也是一个 bug。如果你能够使程序（或整个系统）可复现地崩溃，那就是一个 bug。

你也可以提交 Bug 来向 FreeBSD 项目提交改进。这里的关键词是 *改进*，而不是 *愿望*。一个改进需要附带实际的代码，说明你如何测试这段代码以及任何相关信息，如规范和标准。如果你提交足够多这样的 Bug，你可能会被邀请成为提交者。

Bug 是协作的。通过报告 Bug，你是在表示愿意与 FreeBSD 开发者一起解决你的问题。这可能意味着应用补丁、尝试不同的方法，或者运行调试命令并将输出发送给开发者。报告 Bug 并期待得到类似“已修复！去做这个”的回答是不现实的。在初始的 Bug 报告中包含所有信息可以更快地解决问题。尽量提供过多的数据。

跟我重复一遍：“自由软件。捐赠的支持时间。” 服务器的 RAID 卡让你的硬盘随着康歌的节奏旋转，对你来说可能至关重要，但报告 Bug 的人们正在放弃他们的私人时间来帮助你。记住这一点。

在报告 Bug 时，最好运行的是 FreeBSD 的最新版本。如果你在 FreeBSD 12.0-RELEASE 上报告 Bug，而当前版本是 12.4-p15，别人会要求你更新并重新尝试。没人会查看已经过生命周期的 FreeBSD 版本的 Bug 报告。

#### ***在报告 Bug 之前***

理想情况下，你永远不需要报告 Bug。一个正确的严重 Bug 报告对你来说是很大的工作量，对 FreeBSD 开发者来说也是。FreeBSD 项目有一个内部邮件列表，专门用来评估 Bug 数据库并引导报告到最有可能的开发者那里。虽然向 FreeBSD 邮件列表发送邮件会让成千上万的人知道你的问题，但报告 Bug 会让成千上万的高技能人士知道你的问题，并要求他们为你处理虚拟文书工作。在报告 Bug 之前，确保你和 FreeBSD 项目都需要它。

问题是出现在所有主机上，还是仅在一台主机上？只在一台主机上出现的问题可能是硬件故障导致的。持续的、可重复的行为更可能是一个 Bug。

把你的问题当作一个普遍的问题来处理，先搜索一下 FreeBSD 的常见资源。查看 FAQ 和手册。检查 FreeBSD Bug 数据库，看看是否有现存的 Bug。[`bugs.FreeBSD.org/`](https://bugs.FreeBSD.org/) 上查看。搜索邮件列表归档、论坛以及更广泛的互联网，看看是否有人已经遇到过这个问题。你可以在论坛或 FreeBSD-questions 邮件列表上询问是否有人遇到过这种行为。这是预期的吗，还是应该报告一个 Bug？人们提问的内容将对故障排除和 Bug 报告的创建非常有帮助。

在开始报告 Bug 之前，收集所有可能有帮助的信息。包括：

+   详细启动输出

+   系统版本

+   自定义内核配置（如果有的话）

+   程序调试输出

+   你期望发生什么？

+   实际发生了什么？

你能重现这个问题吗？开发人员在调查 bug 时需要一个可重现的测试用例。如果你的服务器在凌晨三点开始播放歌舞剧曲目，那确实是个问题。如果它只发生一次，且你无法重现，最好的做法是保持沉默，这样别人就不会觉得你疯了。不过，如果它每次在运行特定命令组合时发生，且发生在某些硬件上，那么这个问题就可以得到验证和调查，解决问题后，或者有人给你的服务器提供录音合约。

FreeBSD 使用 Bugzilla 跟踪 bug，网址是 *[`bugs.FreeBSD.org/`](https://bugs.FreeBSD.org/)*。在提交 bug 之前，先搜索现有的 bug 数据库，看看是否有类似或相关的 bug。你的问题是否与现有的某个 bug 相似？如果你的服务器播放迪士尼歌曲，而另一个 bug 显示某人的硬件播放百老汇音乐剧的歌曲，你可能应该在报告中提到这个 bug。那些 bug 是否有一些有启发性的评论？这些评论可能会告诉你如何应对或绕过这个问题，而不必再提交一个相同的 bug。如果你想要更新，可以把自己加入到 bug 的 *cc* 字段。每次 bug 更新时，你都会收到一封电子邮件。

在你搜索 Bugzilla 时，先在那里创建一个账户。即使你现在不需要提交这个 bug，总有一天你会需要…而你可能会因此感到相当烦恼。提前拥有 Bugzilla 账户会让你提交 bug 时稍微轻松一点。

如果你已经走到这一步，仍然遇到问题，那么你可能真的需要提交一个 bug 报告。让我们看看不应该在报告中写什么。

#### ***糟糕的 Bug 报告***

理解一个好的 bug 报告最简单的方法就是阅读一些糟糕的报告，找出它们的不足之处。浏览已关闭的 bug 会揭示出许多糟糕的报告，下面是一个典型的例子：

当我启动 FreeBSD 12.1 ISO 镜像时，无法通过“欢迎使用 FreeBSD”选项屏幕。启动菜单卡住了，每次刷新屏幕时都停留在 10。无论我按什么键，系统都无法启动。如果我按下许多按键，最终会得到内核崩溃。相同的 ISO 镜像在 VirtualBox 中可以启动，并且我能够将其安装到磁盘上。

Bug 报告中包括了一块已损坏的标准 SuperMicro 主板、键盘和鼠标的型号。没有任何硬件是特殊的。报告者建议通过使用类似的硬件来重现这个问题。

首先，报告者显然在安装 FreeBSD 时遇到了问题。甚至可能是 FreeBSD 本身有问题。我毫不怀疑这个系统在启动时会如宣传所说地失败。但没有证据，也没有诊断信息。重现过程也没有什么用；如果每个 12.1 版本的安装镜像在常见硬件上都表现如此，发布工程师早就不会通过这次发布了。

提供硬件的品牌和型号可能没有你想象的那么有用。厂商偶尔会更换芯片组，但不更改型号。详细的启动信息以硬件可以识别的方式标识了机器的硬件，而型号永远无法做到这一点。不过，这个报告者无法提供 12.1 版本的详细启动信息。

如果我遇到这种情况，我首先会尝试使用第二张 CD。也许第一张烧录的磁盘有问题。如果问题仍然存在，我会下载一个稍微旧一点的 FreeBSD 版本，看看问题是否依然存在。如果 12.0 版本失败了，11.0 版本怎么样？我会在我的 bug 报告中加入早期版本的详细启动信息。如果旧版本也失败了，我会在提交 bug 之前向 FreeBSD-questions 邮件列表请求进一步的建议。

正如你可能猜到的那样，没有人会跟进这样的问题。

很多开发者喜欢修复 bug。他们喜欢深入代码，找出微妙的问题。可是他们并不喜欢整理人们那种不稳定的 bug 报告；他们希望自己能够得到报酬来处理那些难缠的人。你的目标是提交一个如此完整且令人信服的 bug 报告，以至于一个正在寻找 bug 的开发者会觉得你是一个容易合作的人——然后，你真的需要*做*一个容易合作的人。

FreeBSD 的 FAQ 中有一个 Dag-Erling Smørgrav 的笑话：“需要多少个-current 用户来换一个灯泡？”答案是 1,169 个，其中包括“有三个用户提交了（bug），其中一个错误归档在文档中，内容仅是‘这里很黑’。”如果你的 bug 报告只是“这里很黑”，那就属于一个糟糕的报告。^(1)

**推测与证据**

每当你向任何人或组织提交 bug 报告时，务必将你的证据与你*认为*发生的事情分开。证据是可以采取行动的；而你的推测则不是。包括推测并不会有什么坏处，但它需要与证据清晰区分开来。你有多少次接到支持电话，用户声称他遇到了某个问题，但一旦你深入调查，发现他告诉你的一切都是假的，实际上是完全无关的事情在发生？是的，别做那种用户。将推测与证据分开。

#### ***修复方案***

任何 bug 报告中最重要的部分就是修复方法。你是如何解决这个问题的？也许你只有一个临时解决方案。“程序在我这样做时崩溃了，但我可以运行它并将输出通过某某处理，效果也还不错。”这个评论对下一个遇到你 bug 的人很有帮助。

当你遇到 bug 时，先看看源代码。修正 man 页或者网站上的错别字并不难。如果你是程序员，浏览源代码几分钟可能就能发现问题。如果没有发现，那么弄清楚系统为什么以这种方式运行，将会让你成为一个更好的程序员和调试者。

也许你无法修复这个 bug。告诉大家这个 bug 的存在仍然很有帮助。但是，通过提供修复方案，你的 bug 报告就不仅仅是一个报告，而是对社区的贡献。

#### ***提交 Bug 报告***

所有的 bug 都会在*[`bugs.FreeBSD.org/`](https://bugs.FreeBSD.org/)*提交和处理。FreeBSD 有三类 bug：端口、基础系统和文档。遇到附加软件的 bug，请使用*端口*类别；遇到随基本 FreeBSD 安装一起安装的 bug，请使用*基础系统*类别；遇到关于 man 页面、FAQ、手册和网站的问题，请使用*文档*类别。每个类别会带出稍微不同的网页表单。文档和端口 bug 所需的字段大部分是基础系统 bug 的子集，因此我们将通过提交一个基础系统 bug 来演示。

网页表单包含几个下拉字段，可以帮助你将 bug 引导到正确的人那里。你的 bug 可能在你提交后被重新分配，但这没关系；最初，你是希望找到一个理解你说的是什么的开发者。你不希望一个文档提交者处理系统调用问题，也不希望一个源代码提交者去搞清楚一个端口包装问题。

`Component`字段让你选择该 bug 影响的系统部分。组件列表会随时间变化，但选择一个组件后会显示其描述。虽然总有一个通用字段，比如`Bin`用于基础系统 bug，但做出正确选择会加速 bug 的处理。

在`Version`字段中，选择这个 bug 所涉及的 FreeBSD 版本。

`Severity`字段有点误导，并且需要你从个人情感中抽离。选项有“仅影响我”、“影响部分人”和“影响多人”。一个糟糕到让你考虑咬掉自己脚趾来逃脱的 bug 可能只影响你。对你来说非常重要，但对 FreeBSD 项目不重要。要抵制宣称“影响所有人”的冲动。同样，网站上的一个拼写错误可能对所有人都可见，但如果到现在为止没人注意到，它可能不值得标为“影响多人”。保留更重要的严重级别给那些对特定设备驱动程序的所有用户或使用某个文件系统的所有人产生负面影响的 bug。如果你因为提交琐碎报告而被认为是关键问题，你会很快发现自己被忽视。FreeBSD 项目依靠的是荣誉系统，声誉比你想的更重要。

在`Hardware`字段中，选择你发现该 bug 的平台。即使看似无关，它也可能是关键的。

`OS`字段是 Bugzilla 的遗留字段，可以忽略。

在这些下拉框下方，Bugzilla 提供了文本框。这些需要更多的思考。

`Summary`字段需要简要描述问题。一个好的总结应该提供独特的信息，使你的 bug 在其他 bug 中脱颖而出。“卸载 SMB 文件系统时出现恐慌”是一个不错的总结。“无法安装”、“系统崩溃”和“问题”则很糟糕。开发者在浏览 bug 数据库时，首先会看到你的总结。一个糟糕的总结会让他跳过这个 bug。

`描述` 区域是你描述问题的地方。不要发泄或抱怨一切有多糟糕。说明发生了什么以及你期望发生什么。如果调试输出足够简短，可以直接附上；否则，将调试输出作为附件上传。包括如何重现问题的建议。如果你有修复方案，请提供。将你关于该问题的任何发现添加进去。有时，最不寻常的细节提供了至关重要的线索。

在描述下方添加 `附件`。这里可以上传你的自定义内核配置、详细启动消息、内核崩溃消息以及冗长的讨论。

使用 **预览** 按钮来确认你包含了所有内容。确认无误后，点击 **提交**。

#### ***提交后***

很快你会收到一封电子邮件，通知你现在是某个 bug 编号的骄傲拥有者。你对该邮件的任何回应都会附加到该 bug 上，只要你不更改主题。

包含正确信息的 bug 报告有很高的几率会迅速关闭。复杂或难以捉摸的 bug 可能需要更长时间，但只要你提供了足够的细节，就会看到更新。

如果你的 bug 报告似乎被遗忘了，可以向相应的邮件列表发送一封邮件，提供 bug 编号、简要说明问题及为什么该问题很重要。FreeBSD 是一个志愿者项目，可能处理你 bug 报告的人发生了什么事情。尽管许多 FreeBSD 开发者是专业程序员，但对他们中的许多人来说，这仍然是一个爱好，必须让位于生病的孩子或紧迫的工作截止日期。如果其他方法都行不通，可以雇佣开发者按合同方式来解决你的特定问题。

如果你提交了一个特别棘手的 bug，FreeBSD 开发者可能会要求你提供更多信息。尽可能快速且全面地提供这些信息。如果你不理解他们的要求，可以花些时间研究后再询问。大多数开发者都很乐意为一个有意愿且基本称职的合作伙伴提供指点，尤其是当你能帮助他们改进代码时。

我已经数不清提交过多少个 FreeBSD 错误报告了。我倾向于提交些微不足道或严重的错误，比如文档错误和内核崩溃，但中间的错误很少。大多数问题已经被解决或提交并关闭。那些奇怪的问题大多是文档上的小错误，位于*/usr/src/contrib*目录下，这个区域是 FreeBSD 项目明确不负责修复小问题的地方。如果像我这样的人能成功关闭超过 90%的错误报告，任何人都可以。值得注意的是，如果你提交了足够多正确的补丁，你会发现与你合作的提交者开始在你背后谈论你。最终，他们会厌倦为你的高质量工作做秘书，并会给你提交权限。如果你拒绝，他们会更坚持地提出。如果你担心的话，不用担心；成为一个提交者并不那么痛苦。关于 FreeBSD 项目的入会仪式有传闻，说是有一群丹麦人拿着斧头在自行车棚后面等着你，但这些完全不是真的。大多数情况下。

不管怎样，还是要继续提交良好的错误报告；这是 FreeBSD 改进的唯一途径！

最难处理的错误类型是完全崩溃的系统。我们来谈谈如何从中获取信息。

### **系统崩溃**

*崩溃*是指操作系统完全停止工作。所有系统，从网络堆栈到磁盘驱动器，都停止工作。当内核面临无法解决的冲突时，系统会选择崩溃，或完全停止工作。如果系统达到了它不知道如何处理的条件，或者它未能通过内部一致性检查，它就会举手表示：“我不知道该怎么办！”崩溃是内核的恶意顺从版本。^(2) FreeBSD 的生产版本越来越难以崩溃，但它仍然可能发生。让系统崩溃的最简单方法是做些愚蠢的事，比如在使用中拔掉一个不可热插拔的硬盘。运行-current 时，崩溃并不罕见；虽然它们不频繁，但也不是非常稀有的情况。

FreeBSD 非常复杂，它的贵族血统和开源开发过程都无法保护它免受所有错误的影响。幸运的是，这种遗产和开发过程确实为你提供了调试问题所需的信息工具。你可能会从一个晦涩的错误代码开始，但你很快会发现，这串乱码字符对某些人来说是有意义的。

发生 panic 的内核可以将关键的信息复制到 *crash dump*（崩溃转储）中。崩溃转储包含了足够的 panic 信息，开发人员希望通过它能够识别并修复底层问题。配置每个系统以捕获崩溃转储，然后再将它们投入生产。FreeBSD 可以通过安装时的设置捕获崩溃转储，但如果你重新配置了服务器或有独特的磁盘分区方式，你需要确认崩溃转储仍然有效。这个预防措施对大多数服务器来说可能没什么用，但当某些事情爆炸时，它将带来巨大的回报。

### **识别 Panic**

当系统发生 panic 时，它会停止运行所有程序、停止写入磁盘并停止监听网络。在除 -current 外的任何版本的 FreeBSD 中，发生 panic 后系统会自动重启。并非所有无解释的重启都是 panic——坏硬件，比如故障的电源或劣质内存，可能会导致重启，而没有任何日志或控制台信息。然而，如果你运行的是 -current，panic 会在控制台中显示类似这样的信息：

```
panic: Assertion cp->co_locker == curthread failed at /usr/src/sys/modules/smbfs/../..
/netsmb/smb_conn.c:363
cpuid = 5
KDB: stack backtrace:
db_trace_self_wrapper() at db_trace_self_wrapper+0x2b/frame 0xfffffe085d0db630
vpanic() at vpanic+0x182/frame 0xfffffe085d0db6b0
kassert_panic() at kassert_panic+0x126/frame 0xfffffe085d0db720
smb_co_unlock() at smb_co_unlock+0x9c/frame 0xfffffe085d0db740
smb_co_put() at smb_co_put+0x68/frame 0xfffffe085d0db770
nsmb_dev_ioctl() at nsmb_dev_ioctl+0x484/frame 0xfffffe085d0db800
devfs_ioctl_f() at devfs_ioctl_f+0x15d/frame 0xfffffe085d0db860
kern_ioctl() at kern_ioctl+0x230/frame 0xfffffe085d0db8c0
sys_ioctl() at sys_ioctl+0x17e/frame 0xfffffe085d0db9a0
amd64_syscall() at amd64_syscall+0x2de/frame 0xfffffe085d0dbab0
Xfast_syscall() at Xfast_syscall+0xfb/frame 0xfffffe085d0dbab0
--- syscall (54, FreeBSD ELF64, sys_ioctl), rip = 0x800b8016a, rsp = 0x7fffffffe4f8, rbp = 0x7fffffffe530 ---
KDB: enter: panic
db>
```

对我来说，这条信息中唯一似乎有些道理的部分是第一行。我卸载了一个 SMB 文件系统，结果得到了这个 panic 信息。第一行提到了 `smbfs`、`netsmb` 和 `smb_conn`，这些看起来都很像 SMB 相关的内容。

底部的 `db>` 是调试器的命令提示符。按下 ENTER 几次，你会看到调试器作出回应；你可以输入命令。调试器指令不是 Unix 命令，但它们有助于你从系统中提取更多信息。

### **响应 Panic**

如果遇到 panic，首先要做的就是获取 panic 信息的副本。由于 FreeBSD 已经不再运行，标准的数据复制方法将无法工作——你不能通过 SSH 连接，也不能使用 `script(1)`。控制台可能完全卡住，不再响应，而不是处于调试器中。不管怎样，你必须获得那个错误信息。

在 1990 年代的糟糕年代里，FreeBSD 在遇到 panic 后并不会自动重启；最初，它只是停在那里显示 panic 信息。我第一次看到 panic 时，慌忙寻找纸和笔。最终，我找到了一只旧信封和一只断了的铅笔，只有在以恰当角度握住时，它才会留下痕迹，然后我趴在服务器架和粗糙的砖墙之间。用一只手平衡住六英寸的黑白显示器，另一只手把信封贴在墙上。显然，在极度紧张的情况下，我长出了第三只手，因为我设法在信封上记录了 panic 信息。最后，身心疲惫，我从机架里滑出来，得意地把所有信息输入到邮件中。相信 FreeBSD 项目的 Panic 应急响应团队一定能够查看这些垃圾信息，告诉我到底发生了什么。

我很快意识到，FreeBSD 并没有一个精英的 PERT 团队随时准备接受我的问题报告。相反，我收到了一封孤单的电子邮件：“你能发送一个回溯信息吗？”当我询问如何操作时，系统将我指引到了一份手册页。（拖自己一路回到 第一章。）幸运的是，panic 很容易重现——要重现这个问题，唯一需要做的事情就是让一个客户登录系统。我花了一天的时间，艰难地掌握了串行控制台和核心转储。

我的信封上的 panic 信息的问题在于，它只提供了故事的一小部分。事实上，它模糊不清，像是把一辆被盗的车描述为“红色，车翼上有一道刮痕”。如果你不提供车的品牌、型号、VIN 号和车牌号，你不可能指望警察能够取得什么进展。同样，如果没有更多来自崩溃内核的信息，FreeBSD 开发人员也无法抓住那段有问题的代码。

好消息是，panic 处理在这些年里有了很大改进。FreeBSD 可以自动记录崩溃转储并捕捉有关 panic 的所有信息。安装程序中甚至有一个开关可以启用它。不过，我强烈建议在将机器投入生产之前先测试 panic 捕获功能。这样，如果发生 panic，你就准备好了，并且能够轻松地提交完整的问题报告。

#### ***准备工作***

配置崩溃转储需要通过 `dumpdev` */etc/rc.conf* 变量告诉 FreeBSD 将转储保存到哪个交换设备上。如果将 `dumpdev` 设置为 `AUTO`，内核会自动将转储保存到第一个交换设备。如果需要，你可以指定一个不同的交换设备，但整个转储必须能放入一个交换设备中。如果常规的交换空间不足以容纳转储，请添加一个磁盘以获得足够的交换空间，并将 `dumpdev` 设置为该分区。

#### ***崩溃转储的实际操作***

当一个配置为捕捉 panic 的系统崩溃时，它会保存内核内存的副本。这个副本被称为 *dump*（转储）。系统无法将 dump 直接保存到文件中。崩溃的内核根本不知道文件系统的事情，其一，文件系统可能已经损坏，或者写入操作可能会破坏它。然而，崩溃的内核理解分区，因此它可以将 dump 写入到一个分区。大多数 FreeBSD 主机都有现成的临时空间——交换分区。FreeBSD 默认将 dump 存储在系统的第一个交换分区中，并将 dump 放置在分区的尽可能后面。完成 dump 后，计算机会重新启动。

在发生 panic 后，主机的文件系统几乎可以肯定会处于脏状态。它们可能是 ZFS 文件系统或使用软更新日志，但系统仍然必须从日志中恢复或回滚到最后一个成功的 ZFS 事务组。使用 fsck(8)清理文件系统可能会占用大量内存，因此 FreeBSD 必须在运行 fsck(8)之前启用交换空间。希望你有足够的内存，使得 fsck(8)不需要交换空间，如果需要交换空间，也希望你有足够的交换空间，以避免覆盖位于交换分区末尾的转储文件。最坏的情况下，你可以进入单用户模式，启用交换到没有转储的分区，清理一个文件系统来保存转储文件，然后手动运行 savecore(8)。

一旦 FreeBSD 有了一个可以保存核心转储的有效文件系统，它会检查交换分区是否有转储文件。如果找到核心转储，FreeBSD 会运行 savecore(8)将转储从交换分区复制到适当的文件系统文件中，运行 crashinfo(8)从转储中收集信息，清除交换分区中的转储数据，然后继续重启。现在，你将拥有一个可用于调试的内核核心文件。

savecore(8)会自动将内核转储放置在*/var/crash*目录中。每个崩溃都有一个名为*vmcore*的文件，后跟一个点和数字。第一次崩溃是*vmcore.0*，第二次是*vmcore.1*，以此类推。FreeBSD 默认保留最近的 10 个崩溃转储。文件*vmcore.last*始终指向最近的崩溃转储。

如果你的*/var*分区不够大以容纳转储，可以在*rc.conf*中通过`dumpdir`变量选择其他目录：

```
dumpdir="/usr/crash"
```

虽然 savecore(8)还支持一些其他选项，如压缩，但在现代系统中通常不需要使用这些选项。

FreeBSD 默认在每个恢复的崩溃转储上运行 crashinfo(8)。crashinfo(8)程序运行一系列调试器脚本，从 panic 中收集信息，并将其存储在一个方便的文本文件*core.txt.0*中。这些信息包括 panic 回溯、进程列表以及大量的虚拟内存统计信息。

**串口控制台与 panic**

虽然串口控制台在 panic 调试中不是严格必要的，但在处理卡住的机器时，它是非常有价值的。虽然提供远程访问的 Java 小程序总比没有好，但能够使用 script(1)捕获所有内容使得串口控制台非常值得使用。如果你真的想为 panic 做好准备，确保你的所有机器都有串口控制台，或者至少有双重控制台。如果可能，记录串口控制台的输出；这样，即使系统未配置崩溃转储，你也能获取到 panic 消息。如果你的笔记本电脑没有串口，可以拍下 panic 消息的照片并附加到故障报告中。

#### ***崩溃转储测试***

你已经设置了`savecore` *rc.conf*选项，所以一切应该正常工作。每当你听到“应该正常工作”这个词时，立即问：“我怎么验证它是否正常工作？”通过将 sysctl `debug.kdb.panic` 设置为大于 0 的任意整数强制 FreeBSD 崩溃。虽然这是重启机器最丑陋的方式，但它确实让主机经历崩溃和核心保存过程。关闭任何可能在中断时损坏数据的活跃进程，例如数据库，并故意触发崩溃。

```
# sysctl debug.kdb.panic=1
```

你将看到控制台上闪现出崩溃信息，随后是主机将核心转储到交换空间的进度。如果你观察重启信息，应该会看到快速提到保存核心文件。当你再次登录到机器时，查看*/var/crash*目录。你会找到三个文件：*info.0*、*vmcore.0*和*core.txt.0*。

*info.0*文本文件描述了转储恢复过程。它包含主机名、架构、崩溃信息等。然而，最重要的细节是最后一行。

```
  Dump Status: good
```

这个转储是可用的。你可以继续调试了。

文件*vmcore.0*包含二进制形式的内存转储。它的大小应该在几百兆字节到几 GB 之间，具体取决于当主机崩溃时它正在做什么。

文件*core.txt.0*包含来自 vmcore.0 的崩溃信息。当你提交问题报告时，请包含你的崩溃的*core.txt*文件。

恭喜——你有了一个核心转储！当主机发生真正的崩溃时，你可以从转储中获取信息。然而，有时崩溃可能会变得更加复杂。

#### ***崩溃转储类型***

FreeBSD 支持三种不同类型的崩溃转储：迷你转储、完整转储和文本转储。所有转储都在发生崩溃时写入交换空间，并在启动时复制到文件。

*迷你转储*，当前默认的转储格式，包含了内核使用的内存。虽然内核本身并不大，但你还会得到 UFS 缓冲区缓存。所需的交换空间应该只占系统内存的一小部分，但也有可能几乎与系统内存一样大，具体取决于系统当时正在执行的任务。转储不包括内核未使用的内存以及 ZFS ARC。

*完整转储*包含系统拥有的所有内存。如果它在 RAM 中，它就会被转储。整个内核内存？没错。你的网页服务器的缓冲区？密码？都在里面。完整转储占用的交换空间与主机的内存大小相同。通过设置 sysctl `debug.minidump` 为 0 来启用完整转储。仅在 FreeBSD 开发人员要求你这样做，以帮助调试特别难以解决的崩溃时才启用完整转储。

*文本转储*是一种高级转储类型，仅包含由 ddb(8)调试器和相关脚本捕获的信息。它仅在内核中启用了 DDB 选项的主机上可用——即，并非任何版本的通用内核。但它包含在-current 通用内核中，因此勇敢的-you souls 使用-current 的用户可以利用文本转储。

#### ***文本转储***

文本转储利用 ddb(8) 调试器在发生 panic 的内核上运行脚本。*/etc/ddb.conf* 中的默认脚本从内核中提取最常用的信息，并将这些信息转储到磁盘中。尽管 crashinfo(8) 是在捕获的内存镜像上运行的，但 ddb(8) 是在发生 panic 的内核上运行的。一位有经验的开发者可以利用这一点。你可能不是一个经验丰富的开发者，但如果你已经读到这本书的这一部分，你应该能够按照指示操作并编辑 */etc/ddb.conf*，这就足够了。

使用 `ddb_enable` *rc.conf* 选项启用文本转储。

```
# sysrc ddb_enable=YES
```

在系统启动时，内核调试器 ddb(8) 会从 */etc/ddb.conf* 读取调试脚本并将其加载到内核中。调试器会在发生 panic 时运行这些脚本。脚本会将内核切换到文本转储模式，调用多个命令收集有用信息，将这些数据写入交换空间，并重启主机。文本转储不像小转储那样有用，但它们占用的空间要小得多。

完整的文本转储将以 tar 文件的形式出现在 */var/crash* 目录下，文件名为 *textdump.tar.0*。每次 panic 后，文本转储的编号会增加，文件 *textdump.tar.last* 始终指向最近的文本转储。textdump(4) 手册页描述了 tar 包内每个文件的内容，但作为用户，你需要知道的是，你应该将整个文件附加到你的 bug 报告中。

#### ***转储与安全***

*vmcore* 文件包含 panic 时你内核内存中的所有内容，其中可能包括敏感的安全信息。有人可能会利用这些信息入侵你的系统。一位 FreeBSD 开发者可能会因为很多合法的原因请求获取 *vmcore* 文件和有问题的内核；这会使调试变得更加容易，并且可以节省大量的邮件来回交流。尽管如此，仍然需要谨慎考虑某人获得这些信息可能带来的后果。如果你不认识请求者，或者不信任他，不要发送该文件，并且*不要*对此感到内疚。花时间研究任何请求你 vmcore 的开发者。即使他们看起来值得信赖和有声望，如果你决定通过邮件来回沟通，而不是直接提供 vmcore，也是完全可以接受的。任何有资格处理你崩溃问题的开发者都明白你为何犹豫是否发送 vmcore，而任何试图让你感到羞愧并迫使你发送它的人，可能根本不应该获得它。

将你的 vmcore 链接发布到公共互联网，相当于将你服务器的核心暴露给全世界。不要这样做。

然而，如果 panic 是可重现的，你可以通过冷启动系统进入单用户模式并立即触发 panic。如果系统没有启动任何包含机密信息的程序，并且没有人向系统输入任何密码，那么转储中就不会包含这些信息。在单用户模式下重现 panic 会生成一个不包含安全信息的、已清理的转储。启动到单用户模式后，运行：

```
# mount -ar
# /etc/rc.d/dumpon start
# command_that_panics_the_system
```

第一个命令将文件系统挂载为只读，这样你就不必在恐慌之后再次运行 fsck(8)了。第二个命令告诉 FreeBSD 将转储保存在哪里。最后，运行触发恐慌的命令。触发恐慌可能需要多个命令，但在大多数情况下，这应该能为你提供一个干净的转储。

如果你的恐慌要求你将机密信息加载到内存中，那么这些信息将出现在转储中。如果你能提交一个有用的错误报告，你就是 FreeBSD 的精英。恭喜！
