## **系统性能与监控**

![image](img/common01.jpg)

即使“它很慢！”不是系统管理员最害怕听到的话，它也排在列表的前面。用户不知道系统为什么慢，可能连问题到底是如何造成的都无法进一步量化或描述。它就是*感觉*慢。通常没有测试用例，也没有一组可重现的步骤，问题似乎也没什么特别的地方。慢速投诉可能导致几个小时的工作时间，因为你需要在系统中挖掘，寻找可能根本不存在的问题。

有一句话更让人恐惧，尤其是在你已经投入了大量工作时间之后：“它仍然很慢。”

一个缺乏经验的系统管理员通过购买更快的硬件来加速慢速系统。这将“速度问题”换成了昂贵的部件和更加昂贵的时间。升级只是让你掩盖问题，而没有真正利用你已经拥有的硬件，有时它们甚至根本无法解决问题。

你可以通过调整导致问题的软件来解决性能问题。你的网站在 WordPress 下很慢？可以考虑在 memcached 或其他 PHP 加速器下运行 PHP。FreeBSD 只是你的应用堆栈中的一层，所以一定要对其他层也给予适当关注。

FreeBSD 包含了许多旨在帮助你检查系统性能并提供必要信息的工具，帮助你找出真正导致系统变慢的原因。它们中的一些，例如 dtrace(1)，非常复杂，要求对系统、软件有深入了解，甚至需要一本专门的书籍。一旦你明白了问题所在，找到问题的解决方案就变得简单多了。你可能确实需要更快的硬件，但有时候调整系统负载或重新配置软件可能会以更低的成本解决问题。在任何情况下，第一步都是理解问题。

### 计算机资源

性能问题通常是由于运行的任务超过了计算机能够处理的能力。这个看起来很显而易见，但请想一想，这到底意味着什么？

一台计算机有四种基本资源：输入/输出、网络带宽、内存和 CPU。如果其中任何一项达到容量限制，其他资源就无法发挥最大效能。例如，你的 CPU 可能在等待磁盘交付数据或等待网络数据包到达。如果你升级 CPU 以提高系统速度，可能会失望。购买一台全新的服务器或许能解决问题，但只是扩大了现有瓶颈。新系统可能比旧系统有更多内存、更快的磁盘、更好的网络卡和更快的处理器，你只是将问题推迟到性能达到新的极限。然而，通过识别系统中的短板并针对特定需求进行优化，你可以大大提升现有硬件的性能。毕竟，为什么要购买一整套新系统，如果几 GB 价格相对便宜的内存就能解决问题呢？（当然，如果你的目标是将这台“慢”系统退役并转做新的桌面，那又是另当别论了。）

输入/输出是一个常见的瓶颈。系统总线有最大吞吐量，虽然你可能没有把磁盘或网络推到极限，但如果不断地同时对它们进行大量操作，你可能会饱和总线。

系统变慢的一个常见原因是同时运行多个大型程序。磁盘 I/O 不仅会被饱和，处理器可能会花费大部分时间等待在 CPU 缓存和内存之间交换数据。例如，我曾经不小心安排了一个庞大的数据库日志轮换任务，同时移动和压缩几 GB 的数据，并且与每日的 periodic(8) 任务重叠。由于这个任务需要关闭主数据库并导致应用程序停机，速度变得至关重要。数据库任务和 periodic(8) 任务都变得无法忍受地慢。重新调度其中一个任务，使得两个任务都能更快速地完成。

FreeBSD 有一些可以提高性能的特性。如果你需要进行大量的加密操作，可以使用 aesni(4) 内核模块。数据库受限于磁盘性能？考虑文件系统的块大小。ZFS 池速度慢？也许你需要一个附加缓存。然而，确定应该更改什么需要对系统进行仔细的检查。

我们将介绍几个 FreeBSD 工具，用于检查系统性能。掌握这些信息后，我们将考虑如何解决性能问题。每个潜在的瓶颈都可以通过合适的工具进行评估。FreeBSD 不断变化，因此较新的系统可能会有新的调优选项和性能特性。请查阅系统中的 tuning(7) 手册，了解当前的性能优化建议。

**什么是正常的？**

本章中你会不断碰到一个词：*异常*。作为系统管理员，你应该了解你的系统的正常状态。它有点像艺术；你可能无法定义*正常*，但你需要在看到*异常*时能够识别它。经常使用这些工具，当系统运行正常时，你就能对系统减速时的异常结果有一个良好的认识。注意你的硬件！

### 检查网络

如果你担心网络性能，测量它。查阅`net``stat` `-m`和`netstat -s`，查看是否有错误或内存或缓冲区不足的地方。这些是瞬时快照，但对于网络，你实际上需要评估几分钟、几小时甚至几天的拥塞和延迟。网络团队可能有像 Cacti、Zabbix 或 Graphite 这样的工具来观察长期性能。^(1)向他们索取信息。将这些工具提供的数据与瞬时快照结合起来。如果你 10 吉比特以太网的每分钟平均吞吐量只有 5 吉比特每秒，但你的瞬时测量显示频繁的峰值达到满载的 10 吉比特，你可能面临非常突发的连接问题。

一些网卡在*轮询模式*下可以更好地处理满负载网络。轮询指示网卡停止将帧发送到操作系统，而是让操作系统定期访问收集这些帧。查阅网卡的手册页，查看它是否支持轮询。使用 ifconfig(8)启用和禁用轮询。

网络负载较重时，可能需要使用不同的拥塞控制算法。FreeBSD 提供了几种 TCP 拥塞控制算法。查找以*cc_*开头的文件，它们位于*/boot/kernel*目录中；这些是拥塞控制模块，每个模块都有一个手册页。

使用 sysctl `net.inet.tcp.cc.available`查看当前加载的拥塞控制算法。

```
# sysctl net.inet.tcp.cc
net.inet.tcp.cc.available: newreno
```

新的 Reno 是传统的拥塞控制算法。该系统上的拥塞控制内核模块包括 CDG、CHD、CUBIC、DCTCP、HD、H-TCP 和 Vegas。H-TCP 算法专为长距离、高带宽应用设计。让我们启用它。

```
# kldload /boot/kernel/cc_htcp.ko
# sysctl net.inet.tcp.cc.available
net.inet.tcp.cc.available: newreno, htcp
```

我们现在在内核中可以使用 H-TCP。通过`net.inet.tcp.cc.algorithm` sysctl 来启用它。

```
# sysctl net.inet.tcp.cc.algorithm=htcp
net.inet.tcp.cc.algorithm: newreno -> htcp
```

最终，你无法将 10 磅带宽放入一个 5 磅的电路中。如果你的饱和以太网正在拖慢应用程序的速度，关闭不必要的网络服务或增加更多带宽。

其他系统条件则要复杂得多。首先通过 vmstat(8)检查问题所在。

### 使用 vmstat(8)进行一般瓶颈分析

FreeBSD 包含多个用于检查系统性能的程序。其中包括 vmstat(8)、iostat(8)和 systat(1)。我们将讨论 vmstat(8)，因为我发现它最有用；iostat(8)与 vmstat(8)相似，而 systat(1)则以 ASCII 图形格式提供相同的信息。

使用 vmstat(8)查看系统当前的虚拟内存统计数据。虽然输出结果需要一些时间来适应，但 vmstat(8)非常适合在小空间内展示大量数据。你可以在命令行输入 vmstat 并跟随进行。

```
# vmstat
procs  memory      page                    disks        faults     cpu
r b w  avm   fre   flt  re  pi  po    fr   sr ad0 ad1   in    sy    cs us sy id
8 0 0 1.3G   26G   157   0   1   0   172    1   0   0   12   212   149  0  0 100
```

vmstat 将显示分为六个部分：进程（`procs`）、`memory`、分页（`page`）、磁盘（`disks`）、故障（`faults`）和 CPU（`cpu`）。我们将快速浏览一下这些部分，然后详细讨论对于调查性能问题最重要的部分。这一行代表系统运行期间的平均值。在接下来的部分，我们会获取更多实时数据。

#### *进程*

vmstat(8)在`procs`标题下有三列。严格来说，vmstat 统计的是线程而不是进程。没有线程的应用程序每个进程有一个线程，但你的多线程应用程序可能会有更多的线程。

r 正在等待 CPU 时间的可运行线程数，包括所有运行中的进程。每个 CPU 一个线程是正常的，这意味着你的硬件得到了充分利用。如果超过这个数量，说明 CPU 成了瓶颈。不过，有些程序会要求主机的处理器全部投入，甚至更多；检查一下是否有这样的“计算黑洞”程序在运行。

b 正在等待系统输入或输出的阻塞线程数——通常是等待磁盘访问的线程。这些线程会在获取到数据后运行。如果这个数字很高，说明磁盘是瓶颈。

w 可运行但完全交换出的线程数。如果你经常有进程被交换出去，说明系统的内存无法满足主机的工作负载。

这台主机自启动以来平均有 8 个可运行线程，但没有等待 I/O 或内存。如果你收到该主机运行缓慢的抱怨，首先需要检查的就是处理器的利用率。是否有某个人在编译 FreeBSD 源代码，以生成书中性能章节的有趣输出，而真实用户却在同一系统上做着工作？

#### *内存*

FreeBSD 将内存分成大小均匀的块，称为*页面*。当程序请求内存时，会分配若干页面。页面的大小依赖于硬件和操作系统，但可以在`hw.pagesize`的 sysctl 中查看。在 FreeBSD 的 i386 和 amd64 平台上，页面大小是 4KB。系统将每个页面视为一个整体——例如，如果 FreeBSD 必须将内存换出，它会按页面逐一进行。管理内存的内核线程被称为*分页守护进程*。`memory`部分有两列。

avm 正在使用的虚拟内存页面的平均数。如果这个值异常高或正在增加，说明系统正在积极消耗交换空间。

fre 可供使用的内存页面数。如果这个值异常低，说明你的系统内存不足。

我们的示例输出使用了 1.3GB 的 RAM，剩余 26GB 可用。内存不是问题。

#### *分页*

`page` 部分显示了虚拟内存系统的工作负载。虚拟内存系统的内部工作原理是一门晦涩的学问，我在这里不会详细描述。^(2)

flt 页面故障的数量，其中需要的信息不在真实内存中，必须从交换空间或磁盘中获取。

re 从缓存中回收或重用的页面数量。

pi 缩写自 *pages in*；表示从真实内存移动到交换区的页面数量。

po 缩写自 *pages out*；表示从交换区移动到真实内存的页面数量。

fr 每秒释放的页面数量。

sr 每秒扫描的页面数量。

将内存移入交换区并不坏，但如果不断地恢复已分页的内存，则表明存在内存不足的情况。高 `fr` 和 `flt` 值可能意味着有大量短命的进程——例如，启动许多其他进程的脚本，或者调度过于频繁的 cron 作业。或者可能是有人在运行 `make -j16 buildworld`。高 `sr` 值可能意味着你的内存不足，因为分页守护进程不断尝试释放内存。分页守护进程通常每分钟运行一次，但高 `sr` 值表示你可能正在尝试做的工作超出了你的 RAM 能承载的范围。

#### *磁盘*

`disks` 部分显示每个磁盘的设备名称。显示的数字是每秒磁盘操作次数，这是判断磁盘负载情况的有价值线索。你应该尽可能将磁盘操作分配到不同的磁盘上，并在可能的情况下将它们安排到不同的总线上。如果某个磁盘显然比其他磁盘忙，并且系统有等待磁盘访问的操作，考虑将一些频繁访问的文件从一个磁盘移动到另一个磁盘。磁盘负载高的一个常见原因是会自我重启的核心转储程序。例如，每当有人点击链接时就会转储核心的故障 CGI 脚本会大大增加磁盘负载。

如果你有很多磁盘，可能会发现它们并不都出现在 vmstat 显示中。由于设计时考虑了 80 列显示，vmstat(8) 无法列出大型系统中的所有磁盘。不过，如果你有更宽的显示器，并且不介意超过 80 列的限制，可以使用 `-n` 标志来设置你希望显示的磁盘数量。

#### *故障*

故障本身并不坏；它们只是系统收到的陷阱和中断。当然，异常大量的故障是坏的——但在解决这个问题之前，你需要了解什么是你系统的正常情况。

vmstat 输出的第一行显示自系统启动以来的平均故障数每秒。

in 接收到的系统中断（IRQ 请求）的数量。

sy 系统调用的数量。

cs 是上秒的上下文切换次数，或者自上次更新以来的每秒平均值。（例如，如果你让 vmstat 每五秒更新一次显示，这一列就会显示过去五秒钟内每秒的上下文切换平均数。）

该主机自启动以来，每秒平均执行 12 次系统调用和 212 次上下文切换。与系统正常工作时看到的数据相比如何？

#### *CPU*

最后，`cpu` 部分显示了系统在执行用户任务（`us`）、系统任务（`sy`）以及空闲时间（`id`）的花费时间。top(1) 以更友好的格式呈现这些相同的信息，但仅显示当前时刻的数据，而 vmstat 允许你查看系统利用率的变化情况。

#### *使用 vmstat*

那么，如何利用这些信息呢？首先检查前三列，看看系统在等待什么。如果你正在等待 CPU 访问（`r` 列），那说明你的 CPU 性能不足。如果你在等待磁盘访问（`b` 列），那说明你的磁盘成为了瓶颈。如果你在交换（`w` 列），说明你的内存不足。使用其他列来更详细地探讨这三种资源短缺情况。

#### *持续 vmstat*

你可能更关心的是随时间变化的系统情况，而不是简短的系统性能快照。使用 `-w` 标志和数字来以持续更新的方式运行它，每隔一定秒数更新一次。FreeBSD 会显示自上次更新以来的平均值，持续更新计数器：

```
# vmstat -w 5
procs  memory       page                    disks     faults         cpu
r b w  avm   fre   flt  re  pi  po    fr   sr ad0 ad1   in    sy    cs us sy id
8 0 0 1.6G   25G   415   0   1   0   432    6   0   0   12   281   157  1  0 99
8 0 0 2.4G   24G 53089   0   7   0 11188  561  11   8   45  8789   994 96  4  0
8 0 0 2.5G   24G 44600   0   3   0 38703  741  10   9   49  8806  1032 96  3  1
8 0 0 2.2G   24G 42841   0  15   0 58044  717  11   9   52 10271  1103 96  4  0
--snip--
```

第一行仍然显示自启动以来的平均值。然而，每五秒钟，系统会在末尾更新一行。你可以坐在那里观看系统性能如何随着计划任务的启动或特定程序的运行而变化。完成后按 CTRL-C 停止。在这个例子中，进程总是在等待 CPU 时间（如 `r` 列中一堆 `8` 所示），并且我们经常会看到等待磁盘访问的情况。

偶尔等待系统资源并不意味着你必须升级硬件；如果性能是可以接受的，就不用担心。但如果不行，必须进一步检查。最常见的原因是存储系统。

### 磁盘 I/O

磁盘速度是常见的性能瓶颈，尤其是旋转磁盘，但即便是基于闪存的存储也可能变慢。必须反复等待磁盘活动完成的程序运行会变得更慢。这通常被称为*磁盘阻塞*，意味着磁盘在阻止程序的活动。解决这个问题的唯一方法是使用更快的磁盘、安装更多的磁盘，或者重新调度负载。

虽然 FreeBSD 提供了多种工具来检查磁盘活动，但我最喜欢的是 gstat(8)，所以我们将使用这个工具。你可以运行 `gstat` 不带任何参数，以显示所有磁盘和分区的状态，更新频率大约每秒一次。如果你的磁盘较多，这可能会显示一大堆零。我总是使用 `-a` 标志，这样 gstat(8) 只会显示有活动的磁盘。`-p` 标志也很有用，可以查看整个磁盘，但我更喜欢按分区查看。

```
# gstat -a
dT: 1.002s  w: 1.000s
 L(q)  ops/s    r/s   kBps ➊ms/r    w/s   kBps ➋ms/w   %busy Name
   0    120      0      0    0.0    118    331    0.1   12.1| ada1
   0    120      0      0    0.0    118    331    0.1   12.1| ada1p1
   0     21      0      0    0.0     19    351    0.4    8.2| da1
   0     20      0      0    0.0     18    331    0.1   12.1| gpt/zfs4
   0     21      0      0    0.0     19    351    0.4    8.2| da1p1
   0     21      0      0    0.0     19    351    0.4    8.2| gpt/zfs7
```

我们为每个磁盘设备、切片和分区获取一行信息，并为每个设备显示各种信息。gstat(8)展示了各种有用的内容，如每秒读取次数（`r/s`）、每秒写入次数（`w/s`）、每秒读取和写入的千字节数，以及一个友好的`%busy`列。

忽略这些大部分内容。有些内容，比如忙碌百分比列，采用了不太准确的测量方法。FreeBSD 开发人员选择了磁盘性能，而不是统计测量的精确度。然而，真正重要的是 ms/r（每次读取的毫秒数）➊ 和 ms/w（每次写入的毫秒数）➋。这些数字是准确的。请测量并监控它们。如果一个磁盘的活动非常高，而另一个处于空闲状态，可以考虑将磁盘上的数据分散到多个磁盘上，或者使用条带化存储。或者，如果是你的笔记本电脑，可能需要接受这就是你存储系统的最大速度。

一旦确定了稀缺的系统资源，你需要找出哪个程序正在消耗这些资源。我们将需要其他工具来帮助诊断。

### CPU、内存和 I/O 使用 top(1)

top(1) 工具提供了一个系统状态的良好概览，显示了有关 CPU、内存和磁盘使用的信息。只需输入 `top`，即可获得系统性能数据的全屏显示。该显示每两秒更新一次，因此你可以获得接近实时的系统视图。即使你将更新间隔设置为一秒，你也可能错过一些短暂的、高资源消耗的进程。

top(1) 的输出分为上下两部分。上半部分提供基本的系统信息，而下半部分提供每个进程的数据。

```
➊last pid: 84111;  ➋load averages:  0.09,  0.21,  0.20               ➌up 7+07:58:00  14:41:09
➍28 processes:  2 running, 26 sleeping
➎CPU:  0.0% user,  0.0% nice,  0.9% system,  0.0% interrupt, 99.1% idle
➏Mem: 80M Active, 642M Inact, 124M Laundry, 222M Wired, 17M Free
➐Swap: 1024M Total, 83M Used, 941M Free, 8% Inuse

  PID USERNAME       THR PRI NICE   SIZE    RES STATE    TIME    WCPU COMMAND
  479 bind             4  20    0 99444K 35956K kqread   6:55   0.00% named
  586 root             1  20    0   154M 33768K select   4:54   0.00% perl
  562 root             1  20    0 22036K 13948K select   1:27   0.00% ntpd
--snip--
```

非常紧凑，对吧？top(1) 工具将尽可能多的数据塞入一个标准的 80 × 25 终端窗口或 X 终端。我们来拆解它，学习如何阅读。我们从上半部分开始，这部分内容在使用 UFS 或 ZFS 时可能会有所不同。

#### *UFS 和 top(1)*

top(1) 的主机信息在 ZFS 和 UFS 主机之间稍有不同，但我们将从 UFS 开始，然后解释它们的差异。

##### PID 值

每个 Unix 系统上的进程都有一个唯一的进程 ID（PID）。每当一个新进程启动时，内核会为它分配一个比前一个进程 PID 大一的值。最后的 PID 值是系统分配的最后一个进程 ID。在前面的示例中，我们的最后一个 PID 是 84,111 ➊。下一个创建的进程将是 84,112，然后是 84,113，依此类推。观察这个数字可以了解系统变化的速度。如果系统以比平常更快的速度分配 PID，可能表示某个进程的分叉失控，或者有某个进程崩溃并重新启动。

##### 负载平均值

*负载平均值* ➋ 是一个相对模糊的数字，它提供了系统 CPU 负载的大致情况。负载平均值是等待 CPU 时间的线程的平均数量。（其他操作系统可能有不同的负载平均值计算方法。）一个可接受的负载平均值取决于你的系统。如果数字异常偏高，您需要调查一下。某些主机在负载平均值为 3 时可能会感到滞后，而某些现代系统即使负载平均值看起来非常高，仍然运行得很流畅。再说一次，*这个*主机的正常负载是多少？

你将看到三个负载平均值。第一个（这里是 0.09）表示过去一分钟的负载平均值，第二个（0.21）表示过去五分钟的负载，最后一个（0.20）表示过去十五分钟的负载。如果你的十五分钟负载平均值很高，但一分钟负载平均值很低，说明你有一次重要的活动峰值，之后已经平息。另一方面，如果十五分钟负载低，但一分钟负载很高，说明在过去的 60 秒内发生了某些事情，可能仍在继续。如果所有负载平均值都很高，说明这种情况已经持续了至少 15 分钟。

##### 运行时间

第一行的最后一项是 *运行时间* ➌，即系统已运行的时间。此系统已运行了 7 天、7 小时和 58 分钟，当前时间是 14:41:09。计算系统启动的时间就留给你了。

##### 进程计数

在第二行，你将看到关于系统当前正在运行的进程的信息 ➍。正在运行的进程实际上在执行任务——它们在响应用户请求、处理邮件，或者执行你的系统所需的其他操作。处于休眠状态的进程则在等待某个来源的输入；它们没问题。你应该预期任何时候都会有相当数量的休眠进程。处于其他状态的进程通常是在等待某个资源的可用，或者以某种方式挂起。大量非休眠、非运行的进程可能表示系统出现了问题。ps(1) 命令可以显示所有进程的状态。

##### 进程类型

`CPU 状态` 行 ➎ 显示了系统在处理不同类型的进程时所花费的 CPU 时间百分比。它显示了五种不同的进程类型：`用户`、`nice`、`系统`、`中断` 和 `空闲`。

`user`进程是普通的日常程序——可能是由 root 运行的守护进程，或者是普通用户运行的命令，等等。如果它出现在`ps -ax`中，它就是一个用户进程。

`nice`进程是优先级被故意调整的用户进程。我们将在《使用 Niceness 重新调整优先级》的第 543 页详细讨论这一点。

`system`值显示 FreeBSD 用于运行内核进程和内核中的用户进程所花费的 CPU 时间百分比。这些包括虚拟内存处理、网络、写入磁盘、使用 INVARIANTS 和 WITNESS 进行调试等。

`interrupt`值显示系统处理中断请求（IRQ）所花费的时间。

最后，`idle`项显示系统处于空闲状态的时间。如果你的 CPU 经常出现非常低的空闲时间，可能需要考虑重新调度任务或更换更快的处理器。

**TOP 和 SMP**

在 SMP 系统中，top(1)显示所有处理器的平均使用情况。你可能有一个处理器完全占用在编译某个东西，但如果另一个处理器处于空闲状态，top(1)显示的 CPU 使用率可能只有 50%。使用`-p`标志查看每个 CPU 的统计信息。

##### 内存

`Mem`行➏表示物理 RAM 的使用情况。FreeBSD 将内存使用分为多个不同的类别。

*活动内存*是用户进程正在使用的内存总量。当一个程序结束时，它所使用的内存会被放入*非活动内存*中。如果系统再次运行这个程序，它可以从内存中检索软件，而不是从磁盘加载。

*空闲内存*完全未被使用。它可能是从未被访问的内存，也可能是某个进程释放的内存。该系统有 17MB 的空闲 RAM。如果你的服务器已经运行了几个月，仍然有空闲内存，你可以考虑将一些 RAM 转移到内存不足的机器上。

*洗衣*中的内存排队等待与其他存储同步，如磁盘。

FreeBSD 11 根据需要在非活动、洗衣和空闲类别之间调度内存，以维持可用内存池。非活动内存最容易转移到空闲池。当缓存内存不足且 FreeBSD 仍然需要更多空闲内存时，它会从非活动池中选择页面，验证是否可以将其用作空闲内存，然后将其移入空闲池。FreeBSD 尽量保持空闲页面的总数高于 sysctl `vm.v_free_target`。

FreeBSD 12 没有缓存，处理低内存情况的方式略有不同。当空闲内存不足时，页面守护进程会从非活动池中选择页面。如果该非活动页面需要同步到磁盘，它会被放入洗衣队列，页面守护进程则会尝试另一个非活动页面。测试主机是否需要更多 RAM 的一种方式是，如果页面守护进程因所有这些测试而积累了 CPU 时间。

在任一 FreeBSD 版本中，空闲内存并不意味着系统内存充足。如果 vmstat(8) 显示你正在进行交换操作，那么说明你使用的物理内存超过了系统的实际内存。你可能有一个定期释放内存的程序。此外，FreeBSD 会将一些从非活动状态的页面移到空闲状态，以保持一定的空闲内存。

FreeBSD 使用 *wired* 内存来存储内核数据结构，以及必须立即获取某块内存的系统调用。wired 内存永远不会被交换或分页。所有 ZFS 使用的内存都是 wired 内存。

##### 交换区

`Swap` 行 ➐ 显示了系统上可用的交换空间总量以及当前使用量。交换区是使用磁盘驱动器作为额外内存。我们将在本章后面更详细地讨论交换区。

#### *ZFS 与 top(1)*

在 ZFS 系统上，top(1) 的输出看起来表面上有所不同，但每个主机对内存的处理有重要的差异。

```
  last pid: 53202;  load averages:  0.26,  0.28,  0.30      up 1+15:41:48
  13:50:54
  120 processes: 1 running, 119 sleeping
  CPU:  0.1% user,  0.0% nice,  0.0% system,  0.0% interrupt, 99.9% idle
➊ Mem: 288M Active, 205M Inact, 3299M Wired, 137M Free
➋ ARC: 2312M Total, 458M MFU, 1626M MRU, 420K Anon, 38M Header, 189M Other
➌      1918M Compressed, 8885M Uncompressed, 4.63:1 Ratio
  Swap: 2048M Total, 126M Used, 1922M Free, 6% Inuse

    PID USERNAME    THR PRI NICE   SIZE    RES STATE   C   TIME    WCPU COMMAND
  53202 mwlucas       1  20    0 20124K  3388K CPU0    0   0:00   0.08% top
    835 mysql        26  23    0   629M   219M select  1  62:42   0.03% mysqld
  53151 www           1  20    0   237M 12924K select  2   0:00   0.03% httpd
    863 nobody        7  20    0 34928K  4960K kqread  0   0:31   0.02% memcached
  53058 www           1  20    0   239M 13296K lockf   0   0:00   0.01% httpd
    852 root          1  20    0   166M 11716K kqread  2   0:05   0.01% php-fpm
  --snip--
```

Mem 部分 ➊ 列出了 `Active`、`Inactive`、`Laundry`、`Wired` 和 `Free` 内存，这些是从 UFS 输出中熟悉的字段。

ARC 行 ➋ 表示 ZFS 的 *高级替换缓存*。`Total` 字段显示整个 ARC 使用的内存量。在缓存使用的 2,312MB 中，458MB 在最常用（`MFU`）缓存中，而 1,626MB 在最近使用（`MRU`）缓存中。你还会看到一些更小的条目，用于表示 ZFS 内部数据结构，如匿名缓冲区（`Anon`）、ZFS 头（`Header`）以及非常有用的 `Other`。

ZFS 压缩了 ARC ➌，通过大量的 CPU 时间来换取稀缺的内存。你可以看到压缩和未压缩缓存数据所使用的空间量。

ZFS 对内存的需求很大，前提是没有其他进程需要它。ZFS 会积极缓存从磁盘读写的数据。该主机有 4,096MB 的内存，而 ZFS 已经占用了其中的 2,312MB。你会看到该主机只剩下 137MB 的空闲内存。如果某个程序请求内存，而系统没有足够的内存可用，ZFS 会将一些缓存释放回系统。如果你看到较高的“Wired”内存水平，记住所有由 ZFS 占用的内存都会进入“wired”类别。

这是一种啰嗦的方式在说：“不要被表面上看起来较高的 ZFS 内存使用量所困扰。” 只有在主机开始分页和交换时才需要担心。

更有趣的是使用这些内存的进程列表。

#### *进程列表*

最后，top(1) 列出了系统上的进程及其基本特征。表格格式旨在尽可能少的空间中展示尽可能多的信息。每个进程占用一行。

**PID** 首先，我们有进程 ID 号，或 PID。每个运行中的进程都有一个唯一的 PID。当你使用 kill(1) 时，通过 PID 来指定进程。（如果你不知道某个进程的 PID，可以使用 pkill(1) 通过进程名称来杀死该进程。）

**用户名** 接下来是运行该进程的用户的用户名。如果多个进程占用了大量 CPU 或内存，并且它们都由同一个用户拥有，那么你就知道该找谁谈话。

**优先级和亲和度** `PRI`（优先级）和 `NICE` 列是相互关联的，表示系统给予每个进程的优先级。我们将在本章稍后讨论优先级和亲和度。

**大小** `SIZE` 显示进程请求的内存量。

**常驻内存** `RES` 列显示程序当前实际在内存中的部分。一个程序可能请求大量的内存，但在任何时候只使用其中的一小部分。内核足够智能，可以根据程序的实际需求分配内存，而不是按请求分配。

**状态** `STATE` 列显示进程当前正在做什么。进程可能处于各种状态——等待输入、处于睡眠状态直到某个事件唤醒它、正在积极运行等等。你可以看到进程正在等待的事件名称，例如 `select`、`pause` 或 `ttyin`。在 SMP 系统上，当进程运行时，你会看到它所运行的 CPU。

**时间** `TIME` 列显示该进程已消耗的总 CPU 时间。

**加权 CPU** 加权 CPU（WCPU）使用量显示该进程使用的 CPU 时间百分比，已根据进程的优先级和亲和度进行了调整。

**命令** 最后，我们有正在运行的程序的名称。

查看 top(1) 的输出可以让你了解系统花费时间的地方。

不是每个主机上的进程都在积极工作。你可能有几十个或上百个空闲的守护进程。按 i 键切换显示空闲进程，或者使用 -i 命令行标志。要显示单独的线程，可以切换 `H` 或添加 `-H` 标志。

默认情况下，top 按加权 CPU 使用量对输出进行排序。你也可以按优先级、大小和常驻内存对输出进行排序。在运行的 top 显示中，按 o 键，然后输入你想排序的列名。这有助于识别那些自命不凡或使用过多内存的程序。

#### *top(1) 和 I/O*

除了标准的 CPU 显示，top(1) 还有一个 I/O 模式，显示哪些进程正在最活跃地使用磁盘。运行 top(1) 时，按 m 进入 I/O 模式。显示的上半部分仍然显示内存、交换区和 CPU 状态，但下半部分会发生显著变化。

```
  PID USERNAME     VCSW  IVCSW   READ  WRITE  FAULT  TOTAL PERCENT COMMAND
 3064 root           89      0     89      0      0     89 100.00% tcsh
  767 root            0      0      0      0      0      0   0.00% nfsd
 1082 mwlucas         2      1      0      0      0      0   0.00% sshd
 1092 root            0      0      0      0      0      0   0.00% tcsh
  904 root            0      0      0      0      0      0   0.00% sendmail
--snip--
```

`PID` 是进程 ID，当然，`USERNAME` 列显示的是谁在运行这个进程。

`VCSW` 代表 *自愿上下文切换*；这是该进程已经将系统交给其他进程的次数。`IVCSW` 代表 *非自愿上下文切换*，显示内核告诉进程“你完成了，现在该让别人运行一会儿”的次数。

类似地，`READ`和`WRITE`显示系统从磁盘读取和写入的次数。`FAULT`列显示该进程需要从磁盘拉取内存页的次数，这也是另一种磁盘读取。这最后三列的汇总显示在`TOTAL`列中。

`PERCENT`列显示该进程使用的磁盘活动的百分比。与 gstat(8)不同，top(1)显示的是每个进程的实际磁盘活动占比，而不是可能的磁盘活动。如果只有一个进程在访问磁盘，top(1)会显示该进程使用了 100%的磁盘活动，即使它仅仅是发送了一点点数据。gstat(8)告诉你磁盘有多忙，而 top(1)则告诉你是什么产生了磁盘活动，并指出责任。这里，我们看到进程 ID 3064 正在产生所有磁盘活动。它是一个 tcsh(1)进程，也叫做“某个用户的 shell”。让我们追踪一下这个罪魁祸首。

**更多顶级功能**

top(1)工具可以以多种方式改变显示方式。你可以查看特定用户的进程，包含或排除内核线程，排除空闲进程等等。有关详细信息，请阅读手册页。

### 后续进程

在任何类 Unix 系统上，每个用户空间进程都有与其他进程的父子关系。当 FreeBSD 启动时，它通过启动 init(8)并将其分配 PID 1 来创建一个单一进程。这个进程会启动其他进程，比如*/etc/rc*启动脚本和处理你登录请求的 getty(8)程序。这些进程是进程 ID 1 的子进程。当你登录时，getty(8)会启动 login(8)，然后启动一个新的 shell，使得你的 shell 成为 login(8)进程的子进程。你运行的命令要么是你 shell 进程的子进程，要么是你 shell 的一部分。你可以使用 ps(1)并通过`-ajx`标志（以及其他标志）查看这些父子关系。

```
# ps -ajx
USER      PID  PPID  PGID  SID JOBC STAT TT         TIME COMMAND
root        0     0     0    0    0 DLs   -      6:26.23 [kernel]
root        1     0     1    1    0 ILs   -      0:00.09 /sbin/init --
root        2     0     0    0    0 DL    -      0:00.00 [crypto]
--snip--
root      845     1   845  845    0 Is    -      0:00.00 /usr/sbin/sshd
root      849     1   849  849    0 Ss    -      0:01.05 /usr/sbin/cron -s
root     8632   845  8632 8632    0 Is    -      0:00.09 sshd: mwlucas [priv] (sshd)
mwlucas  8634  8632  8632 8632    0 S     -      0:00.53 sshd: mwlucas@pts/0,pts/1 (sshd)
mwlucas  8687     1  8687 8687    0 Ss    -      0:25.90 tmux: server (/tmp/tmux-1001/default) (tmux)
--snip--
```

在最左边，我们可以看到进程拥有者的用户名，然后是该进程的`PID`和父进程 PID（`PPID`）。这是我们在这里看到的最有用的信息，但我们将简要介绍其他字段。

`PGID`是进程组 ID 号，通常由其父进程继承。程序可以启动一个新的进程组，该新进程组将拥有与进程 ID 相等的 PGID。进程组用于信号处理和作业控制。会话 ID，或`SID`，是 PGID 的一个分组，通常由单一用户或守护进程启动。进程不能从一个 SID 迁移到另一个 SID。`JOBC`给出作业控制计数，指示进程是否在作业控制下运行（即在后台）。

`STAT`显示进程状态——即你运行 ps(1)时，进程当前正在做什么。进程状态非常有用，它告诉你进程是否处于空闲状态，正在等待什么等等。我强烈建议阅读 ps(1)中关于进程状态的章节。

`TT`列列出进程的控制终端。此列仅显示终端名称的最后部分，例如`v0`表示`ttyv0`，`p0`表示`ttyp0`。没有控制终端的进程显示为`??`。

`TIME`列显示了进程使用的处理器时间，包括用户态和内核态的时间。

最后，我们看到`COMMAND`名称，这是父进程调用的名称。方括号中的进程实际上是内核线程，而非真正的进程。FreeBSD 运行了大量的内核线程。

那么，如何利用这一点来追踪一个可疑进程呢？在我们 top(1)的 I/O 示例中，我们看到进程 3064 几乎产生了我们所有的磁盘活动。运行`ps -ajx`来查找这个进程：

```
   USER      PID  PPID  PGID  SID JOBC STAT TT         TIME COMMAND
   --snip--
   root     3035  3034  3035  2969    1 S+    p0    0:00.03 _su -m (tcsh)
➊ bert     2981  2980  2981  2981    0 Is    p1    0:00.03 -tcsh (tcsh)
➋ root     2989  2981  2989  2981    1 I     p1    0:00.01 su -m
➌ root     2990  2989  2990  2981    1 D     p1    0:00.05 _su -m (tcsh)
➍ root     3064  2990  3064  2981    1 DV+   p1    0:00.15 _su -m (tcsh)
   mwlucas  2996  2995  2996  2996    0 Is    p2    0:00.02 -tcsh (tcsh)
   --snip--
```

我们关注的进程由 root 拥有，是一个 tcsh(1)实例➍，正如 top 的 I/O 模式所显示的那样。然而，命令是以 su(1)身份运行的。检查这个进程的父进程 ID，通过 PPID 列，你会看到进程 3064 是进程 2990 ➌的子进程，进程 2990 又是进程 2989 ➋的子进程，后者由 root 拥有。然而，进程 2989 是由 2981 ➊这个 shell 进程创建的，2981 是由一个真实用户启动的。你可能还会注意到，这些进程都属于会话 2981，显示它们可能都在同一个登录会话中运行。`TT`列显示为`p1`，这意味着用户在该机器的第二个虚拟终端（*/dev/ttyp1*）上登录。调查这个会话 ID 可以揭示 Bert 认为他在做什么。

现在你已经了解了进程的父子操作是如何工作的，你可以进行一些作弊操作。添加`-d`标志，例如`ps -ajxd`，可以以树状结构显示进程及其父进程。你可能需要一个宽的终端。

系统经历短时间的完全占用是正常的。如果没有其他人使用系统，而且没有人抱怨性能问题，为什么不让这个用户运行他的任务呢？然而，如果这个进程影响了其他用户，我们可以选择降低其优先级，使用我们的根权限杀死这个任务，或者拿着棒球棒出现在用户的工位前。

### 分页与交换

使用交换空间本身并不算坏。交换空间比内存慢得多，但它确实能工作，许多程序不需要将所有内容都保存在 RAM 中才能运行。旧的经验法则说，一个典型的程序 80%的时间用于运行 20%的代码，其余的时间则用来启动和关闭、错误处理等。你可以放心地让这些部分从 RAM 中移出，几乎不会影响性能。

交换缓存了它已经处理过的数据。一旦一个进程使用了交换空间，直到该进程退出或从交换空间中调用内存回来之前，这块交换空间将一直在使用。

交换的使用通过*分页*和*交换*实现。分页是没问题的；交换则不太好，但总比崩溃强。

#### *分页*

*分页*发生在 FreeBSD 将正在运行的程序的部分内容移到交换空间时。分页实际上可以提高系统负载很重时的性能，因为未使用的部分可以存储在磁盘上，直到需要时再取出——如果真的需要的话。FreeBSD 可以将实际的内存用来运行真正的代码。系统是否将数据库启动代码移到交换区，一旦数据库启动并运行，真的很重要吗？

#### *交换*

如果计算机没有足够的物理内存来存储在某一微秒内未运行的进程，系统可以将整个进程移动到交换空间。当调度器再次启动该进程时，FreeBSD 会从交换区取回整个进程并运行它，可能还会把其他进程送到交换区。

交换的主要问题是磁盘 I/O 活动暴增，性能急剧下降。由于请求处理时间更长，系统中任何时刻的请求也会增加。登录检查问题只会让情况变得更糟，因为你的登录只是又一个进程。一些系统能够处理一定量的交换，而在其他系统上，情况很快会恶化成死循环。

当 CPU 过载时，系统会变慢。当磁盘成为瓶颈时，系统也会变慢。内存不足实际上可能导致计算机崩溃。如果你在进行交换操作，你*必须*购买更多的内存，否则只能忍受糟糕的性能。如果你被困在这款硬件上无法购买更多内存，可以考虑购买一块非常快速的 SSD 用作交换空间。

vmstat(8) 的输出显示了在任何时刻被交换出去的进程数量。

### 性能调优

FreeBSD 会将最近访问的数据缓存到内存中，因为有很多信息会被反复从磁盘中读取。缓存到物理内存中的信息可以非常快速地访问。如果系统需要更多内存，它会丢弃最旧的缓存数据以腾出空间给新的数据。UFS 和 ZFS 使用不同的方法来决定缓存哪些数据，但这个原则通常适用。

今天早晨启动我的桌面时，我打开了 Firefox 以便查看我的 RSS 订阅。磁盘运行了一两秒钟来加载程序。然后我关闭了浏览器，以便集中精力工作，但 FreeBSD 将 Firefox 保留在缓存中。如果我重新启动 Firefox，FreeBSD 将直接从内存中提取它，而不是再去访问磁盘，从而大大减少了启动时间。如果我启动了一个需要大量内存的进程，FreeBSD 则会将网页浏览器从缓存中清除，以支持新进程。

如果你的系统运行正常，至少应该有几兆字节的空闲内存。sysctl 参数`vm.v_free_target`和`hw.pagesize`告诉你 FreeBSD 认为系统中需要多少空闲内存。如果你总是拥有比这两个 sysctl 参数相乘的值更多的空闲内存，那么你的系统没有得到充分的利用。例如，在我的邮件服务器上，我有：

```
# sysctl vm.v_free_target
vm.v_free_target: 5350
# sysctl hw.pagesize
hw.pagesize: 4096
```

我的系统至少需要拥有 5,350 × 4,096 = 21,913,600 字节，约 22MB 的空闲内存。如果不是因为我对不足的 RAM 有深层次的情感创伤，我完全可以毫不犹豫地从我的桌面丢掉 1GB 的 RAM。^(3)

#### *内存使用*

如果主机的缓存或缓冲区中有大量内存，或者 ARC 已经占用了所有 RAM，那么它并不意味着内存不足。你可能会更好地利用更多的内存，但并不是严格必要的。如果你有较少的空闲内存，但大量活跃且非 ZFS 固定的内存，那么你的系统正在消耗 RAM。增加内存会让你更好地利用缓冲区缓存。

如果页面守护进程持续运行，并且在你的 vmstat 输出中递增 sr 字段，说明内核正在努力提供内存。主机可能确实存在内存不足的情况。然而，一旦主机开始使用交换空间，这种内存不足就不再是假设的情况。虽然这不一定很糟糕，但也不是理论上的问题。

#### *交换空间使用*

交换空间可以帮助暂时弥补 RAM 的不足。例如，如果你在解压一个巨大的文件，可能会轻易消耗掉所有的物理内存，并开始使用虚拟内存。对于这种偶尔的任务，购买更多的 RAM 并不值得，因为交换空间已经足够。如果一台内存不足的服务器运行着一个从未被调用的守护进程，那么这个守护进程最终会被完全或大部分交换掉，以优先考虑执行工作的进程。

只有在系统持续频繁地将数据从交换空间中交换进出时，才需要担心交换空间的使用。

简而言之，交换空间就像酒。偶尔喝一两杯不会伤害你，甚至可能是一个不错的选择。但如果你总是依赖交换空间，那就成问题了。如果你不得不频繁使用交换空间，可以考虑使用一个非常快速且耐用的 SSD。

#### *CPU 使用*

处理器每秒钟能处理的事情是有限的。如果你运行的任务超过了 CPU 的承载能力，请求会开始积压，你将出现处理器积压，系统也会变慢。这就是 CPU 使用的核心概念。如果性能不可接受，并且 top(1)显示你的 CPU 一直处于接近 100%的状态，那么 CPU 利用率可能就是你的问题所在。虽然新硬件确实是一个选择，但你还有其他的选择。例如，检查系统中运行的进程，看看它们是否都必要。是不是某个初级系统管理员安装了 SETI@Home 客户端来用你的空闲 CPU 周期寻找外星人？比特币挖矿程序呢？是否有一些曾经重要的程序现在已经不再需要了？找出并关闭这些不必要的进程，并确保它们在下次系统启动时不会再运行。

如果你有非常具体的需求，比如将某些处理器专门分配给特定任务，考虑使用 cpuset(1)。对于大多数用户来说，这是过度的，但高性能应用可能会很好地利用专用的处理器。

完成这些后，再次评估你的系统性能。如果问题仍然存在，尝试重新调度或调整优先级。

#### *重新调度*

重新调度比重新排序更简单；它是一种相对简单的方法，旨在平衡系统进程，以免它们垄断系统资源。如第二十章所讨论，你和你的用户可以使用 cron(8) 在特定时间安排程序运行。如果你的用户在特定时间运行大量任务，你可以考虑使用 cron(1) 在非高峰时段运行它们。通常像每月账单数据库查询这类任务可以在晚上 6 点到早上 6 点之间运行，没人会介意——财务部门只需要在每月第一天早上 8 点时拿到数据，以便完成上个月的账务结算。类似地，你可以在凌晨 1 点安排你的 `make buildworld && make buildkernel`。

#### *使用友好性重新排序*

如果重新调度不可行，那么你就需要进行重新排序，这可能会稍微复杂一些。在重新排序时，你告诉 FreeBSD 改变给定进程的优先级。例如，你可以让一个程序在繁忙时段运行，但只有在没有其他程序需要运行时才运行。你刚刚告诉那个程序要*友好*，并让出位置给其他程序。

进程越“友好”，它所需的 CPU 时间就越少。默认的友好性是 `0`，但友好性范围从 `20`（非常友好）到 `-20`（一点也不友好）。这看起来可能有些反直觉；你可能会认为较高的数值应该意味着更高的优先级。然而，这会导致语言上的问题；将这个因素称为“自私”或“暴躁”而不是“友好性”当时似乎不是一个好主意。^(4)

top(1) 工具会显示一个 `PRI` 列，表示进程优先级。FreeBSD 会根据多种因素计算进程的优先级，包括友好性，并尽可能先运行高优先级的进程。友好性会影响优先级，但你不能直接编辑优先级。

如果你知道系统的负载接近或达到了容量上限，你可以选择使用 nice(1) 命令运行某个命令并为该进程指定友好性。通过 `nice -n` 和命令前的友好性值来指定友好性。例如，要以 nice 15 启动一个非常自私的 `make buildworld`，你可以运行：

```
# nice -n 15 make buildworld
```

只有 root 用户可以为程序分配负的友好性值，比如 `nice -n -5`。例如，如果你想滥用超级用户权限使编译尽可能快地完成，可以使用负的友好性：

```
# nice -n -20 make
```

**NICE 与 TCSH**

tcsh(1) shell 内置了一个 nice 命令。这个内置的 nice 使用的是 renice(8) 语法，与 nice(1) 不同。我相信这么做除了让 tcsh 用户不高兴之外是有原因的，但现在我想不起来了。要使用 nice(1)，请使用完整路径 */usr/bin/nice*。

通常，你没有足够的时间在启动命令时就让它变得友好，而是必须在发现它占用了系统所有资源时改变其友好性。你可以使用 renice(8) 通过进程 ID 或所有者来重新排序正在运行的进程。要改变进程的友好性，运行 `renice` 并指定新的友好性值和 PID 作为参数。

在我的职业生涯中，我曾运行过几个日志主机。除了常规的 syslog 服务外，它们通常还会运行几个 flow-capture、Nagios 和其他关键的网络感知系统。我通常会使用一个 web 界面来管理所有这些，并允许其他人访问我的日志。如果我发现 web 服务器上的间歇性负载干扰了我的网络监控或 syslogd(8)服务器，我必须采取行动。将 web 服务器的优先级调整低会让客户端运行得更慢，但这比让监控变慢要好。使用 pgrep(1)找到 web 服务器的 PID：

```
# pgrep httpd
993
# renice 10 993
993: old priority 0, new priority 10
```

轰！FreeBSD 现在在其他进程之后处理 web 请求。这大大惹恼了该服务的用户，但既然是我的服务器，我已经很烦了，那也没关系。

要重新调整用户拥有的每个进程的优先级，可以使用`-u`标志。例如，若要使我的进程优先级高于其他任何人的，我可以这样做：

```
# renice -5 -u mwlucas
1001: old priority 0, new priority -5
```

`1001`是我在此系统上的用户 ID。同样，可以推测，我这么做有非常充分的理由，而不仅仅是为了个人的权力需求。^(5) 同样，如果那个吃掉我所有处理器时间的用户坚持要为难我，我可以将他的进程设置为非常、非常低的优先级，这可能会解决其他用户的抱怨。如果你有一个大的后台数据库任务，让运行该任务的用户优先级较低可以让前台工作正常进行。

Niceness 仅影响 CPU 使用率， 对磁盘或网络活动没有影响。

**瓶颈交替**

每个系统都有瓶颈。如果消除了一个瓶颈，性能会提升，直到遇到另一个瓶颈。系统的性能受限于计算机中最慢的组件。例如，web 服务器通常会受到网络限制，因为系统中最慢的部分是互联网连接。如果你将千兆上传带宽升级到 2.4Gb/s 的 OC-48，系统将以其他组件的速度提供站点。管理层经常要求的“消除瓶颈”实际上是“消除干扰你常规工作负载的瓶颈”。

现在你可以查看系统问题了，让我们来学习如何听懂系统试图告诉你的内容。

### 状态邮件

FreeBSD 每天、每周和每月通过 periodic(8)运行维护任务。这些任务进行基本的系统检查，并通知管理员有关变化、需要关注的项目和潜在的安全问题。每个计划任务的输出每天都会发送到本地系统上的 root 账户。了解系统正在做什么的最简单方法是阅读这些邮件；许多像你一样非常忙碌的系统管理员已经合作，使这些信息变得非常有用。虽然你可能会收到很多这些邮件，但通过一点经验，你会学会如何快速浏览报告，只关注关键或异常的变化。

每日、每周和每月报告的配置在*periodic.conf*中进行控制，如第二十章所述。

你可能不想每天都以 root 用户身份登录到所有服务器以读取邮件，因此将每台服务器的 root 邮件转发到一个集中式邮箱。在 */etc/mail/aliases* 中进行此更改，如 第二十章 所讨论。

我建议只在嵌入式系统上禁用这些任务，因为嵌入式系统应该通过其他方式进行管理和监控，例如通过你的网络监控系统。在这样的系统上，禁用 */etc/crontab* 中的 periodic(8) 检查。

虽然这些日常报告很有用，但它们并没有讲述全部情况。日志提供了更为完整的视图。

### 使用 syslogd 进行日志记录

FreeBSD 日志系统非常有用。任何类 Unix 操作系统几乎都可以记录几乎任何内容，并且可以设置详细的记录级别。虽然你会发现默认的系统日志挂钩用于最常见的系统资源，但你可以选择符合需求的日志配置。几乎所有程序都与日志守护进程 syslogd(8) 集成。

syslog 协议通过消息工作。程序发送单个消息，syslog 守护进程 syslogd(8) 捕获并处理这些消息。syslogd(8) 根据消息的设施和优先级处理每个消息，这些都是客户端程序为消息指定的。你必须理解设施和优先级才能管理系统日志。

#### *设施*

*设施* 是表示日志条目来源的标签。这是一个任意的标签，仅是用来区分不同程序的文本字符串。在大多数情况下，每个需要唯一日志的程序都会使用一个独特的设施。许多程序或协议都有专门的设施——例如，FTP 是一种常见协议，以至于 syslogd(8) 为它专门设置了一个设施。syslogd 还支持各种通用设施，你可以将它们分配给任何程序。

以下是标准设施及其用途的信息类型。

auth 关于用户授权的公共信息，例如人们登录或使用 su(1) 时的情况。

authpriv 关于用户授权的私人信息，仅 root 用户可访问。

console 正常打印到系统控制台的消息。

cron 来自系统进程调度器的消息。

daemon 用于所有没有其他明确处理程序的系统守护进程的捕获设施。

ftp 来自 FTP 和 TFTP 服务器的消息。

kern 来自内核的消息。

lpr 打印系统的消息。

mail 邮件系统消息。

mark 该设施每 20 分钟在日志中插入一条记录。与其他日志结合使用时非常有用。

news 来自 Usenet News 守护进程的消息。

ntp 网络时间协议消息。

security 来自安全程序的消息，例如 pfctl(8)。

syslog 来自日志系统本身的消息。注意，不要在日志时再记录日志，这样只会让你头晕。

user 捕获所有消息的设施。如果用户程序没有指定日志设施，则使用此设施。

uucp 来自 Unix 到 Unix 复制协议的消息。这是互联网前时代的 Unix 历史，你可能永远不会遇到。

local0 **到** local7 这些是为系统管理员提供的。许多程序都有设置日志设施的选项；如果可能，选择这些之一。例如，你可能会告诉客户服务系统将日志记录到 `local0`。

尽管大多数程序都有合理的默认设置，但作为系统管理员，你的职责是管理哪些程序记录到哪些设施。

#### *级别*

日志消息的*级别*代表其相对重要性。虽然程序将所有日志数据发送到 syslogd，但大多数系统仅记录 syslogd 接收到的重要内容，丢弃其余的内容。当然，一个人认为无关紧要的事物，可能对另一个人来说是至关重要的，这就是级别的作用所在。

syslog 协议提供了八个级别。使用这些级别来告诉 syslogd 记录什么内容，丢弃什么内容。这些级别按照重要性从高到低的顺序排列：

emerg 系统崩溃。消息会在每个终端上闪烁。计算机基本上已经无法使用。你甚至不需要重启——系统会自动为你重启。

crit 严重错误包括硬盘上的坏块或严重的软件问题。如果你足够勇敢，你可以继续运行，照常使用。

alert 这很糟糕，但不是紧急情况。系统仍然可以继续运行，但这个错误应该立即处理。

err 这些是需要某个时候关注的错误，但不会摧毁系统。

warning 这些是杂项警告，可能不会阻止发出警告的程序照常工作。

notice 包括一般信息，通常不需要你采取行动，比如守护进程的启动和关闭。

info 包括程序信息，如邮件服务器中的个别事务。

debug 该级别通常仅对程序员有用，偶尔也对试图弄清楚程序为何按某种方式运行的系统管理员有用。调试日志可能包含程序员认为调试代码所需的任何信息，其中可能包括违反用户隐私的信息。

none 这意味着，“不要从这个设施记录任何内容。”它最常用于排除通配符条目的信息，稍后我们会看到。

通过将级别与优先级结合使用，你可以非常精确地分类消息，并根据需要处理每条消息。

#### *使用 syslogd(8) 处理消息*

syslogd(8)守护进程从网络中捕获消息，并将它们与*/etc/syslog.conf*或*/etc/syslog.d/*中的条目进行比较。*/etc/syslog.d/*中的文件用于你的自定义条目和附加程序，而*/etc/syslog.conf*用于集成的系统程序。syslogd 只读取以*.conf*结尾的*/etc/syslog.d/*文件。这两个文件格式相同，但为了清晰起见，我将参考*/etc/syslog.conf*。该文件有两列；第一列描述日志消息，可能是通过设施和级别，或者通过程序名称。第二列告诉 syslogd(8)当日志消息与描述匹配时应该做什么。例如，看看这个来自默认*syslog.conf*的条目：

```
mail.info                                       /var/log/maillog
```

这告诉 syslogd(8)，当它接收到来自`mail`设施且级别为`info`或更高的消息时，该消息应该附加到*/var/log/maillog*中。

如果日志文件不存在，logger 将无法记录日志。在重新启动 syslogd(8)之前，请使用 touch(1)创建日志文件。

##### 通配符

你还可以使用通配符作为信息来源。例如，这一行记录来自`mail`设施的每条消息：

```
mail.*                                       /var/log/maillog
```

要记录来自所有地方的所有内容，请取消注释`all.log`条目，并创建文件*/var/log/all.log*：

```
*.*                                         /var/log/all.log
```

这能工作，但我发现它提供的信息过于冗杂，实际使用时并不方便。你会发现自己需要使用复杂的 grep(1)语句将多个命令串联起来才能找到即使是最简单的信息。此外，这还会包含各种私人数据。

##### 排除信息

使用`none`级别可以从日志中排除信息。例如，在这里，我们将`authpriv`信息从我们的全包含日志中排除。分号允许你将多个条目合并到同一行：

```
*.*; authpriv.none        /var/log/most.log
```

##### 比较

你也可以在*syslog.conf*规则中使用比较操作符`<`（小于）、`=`（等于）和`>`（大于）。虽然 syslogd 默认记录指定级别或以上的所有消息，但你可能只想包括一个级别范围。例如，你可以将所有`info`级别及以上的日志记录到主日志文件中，同时将其余的日志记录到调试文件中：

```
mail.info                /var/log/maillog
mail.=debug              /var/log/maillog.debug
```

`mail.info`条目匹配所有发送到`mail`设施且级别为`info`及以上的日志消息。第二行只匹配级别恰好为`debug`的消息。你不能简单地使用`mail.debug`，因为那样调试日志会重复前一个日志的内容。这样，你就不需要为基本的邮件日志筛选调试信息，也不需要为获取调试输出而筛选邮件传输信息。

##### 本地设施

许多程序提供通过 syslog 记录日志的功能。大多数这些程序可以设置为你选择的设施。各种`local`设施是为这些程序保留的。例如，默认情况下，dhcpd(8)（参见第二十章）将日志记录到`local7`设施中。在这里，我们捕获这些消息并将它们发送到自己的文件：

```
local7.*                /var/log/dhcpd
```

如果`local`设施用完了，你可以使用系统未使用的其他设施。例如，我曾在一个没有`uucp`服务的繁忙日志服务器上使用过`uucp`设施。

##### 按程序名称记录日志

如果设施已满，你可以使用程序的名称作为匹配条件。对于一个名称的条目，需要两行：第一行包含带有前导感叹号的程序名称，第二行设置日志记录。例如，FreeBSD 使用此方法记录 ppp(8)的信息：

```
!ppp
*.*                    /var/log/ppp.log
```

第一行指定程序名称，第二行使用通配符告诉 syslogd(8)将所有内容附加到一个文件中。

`!`programname 语法会影响其后的所有行，因此你必须将其放在*syslogd.conf*的最后。你可以放心地在*/etc/syslog.d*文件中使用它，而不必担心影响到其他条目。

##### 记录到用户会话

当你将日志记录到用户时，任何到达的消息都会显示在该用户的屏幕上。要将消息记录到用户会话中，请列出以逗号分隔的用户名作为目标。要将消息写入所有用户的终端，使用星号（`*`）。例如，默认的*syslog.conf*文件包括这一行：

```
*.emerg                *
```

这表示任何紧急级别的消息都会出现在所有用户的终端上。由于这些消息通常会以某种方式说“再见”，因此这是合适的。

##### 将日志消息发送到程序

要将日志消息定向到程序，使用管道符号（|）：

```
mail.*                |/usr/local/bin/mailstats.pl
```

##### 记录到日志主机

我的网络通常有一个单独的日志主机，处理的不仅是 FreeBSD 主机，还有 Cisco 路由器和交换机、其他 Unix 主机以及任何支持 syslog 的设备。这大大减少了系统维护并节省了磁盘空间。每条日志消息都包含主机名，因此你可以轻松地在之后进行分类。

使用*at*符号（`@`）将消息发送到另一台主机。例如，以下这一行将你本地 syslog 接收到的所有内容转发到我网络上的日志主机：

```
*.*                  @loghost.blackhelicopters.org
```

目标主机上的*syslog.conf*文件决定了这些消息的最终目的地。

在日志主机上，你可以通过日志消息的来源主机来分隔日志。使用加号（`+`）符号和主机名来表示接下来的规则适用于此主机：

```
+dhcpserver
local7.*            /var/log/dhcpd
+ns1
local7.*            /var/log/named
```

将你的通用规则放在*syslog.conf*的顶部。每个主机的规则应该放在底部或单独的*syslog.d*文件中。

##### 日志重叠

日志守护进程不是基于首次匹配或最后匹配的方式进行日志记录；相反，它根据每个匹配规则进行记录。这意味着你可以轻松地将一条日志消息记录到多个不同的日志中。考虑以下日志配置片段。

```
*.notice;authpriv.none        /var/log/messages
local7.*                      /var/log/dhcp
```

几乎每条 `notice` 级别或更高的消息都会被记录到 */var/log/messages*。然而，任何具有 `authpriv` 设施的消息都会故意从此日志中排除。我们让我们的 DHCP 服务器记录到 */var/log/dhcp*。这意味着任何 `notice` 级别或更高的 DHCP 消息都会同时记录到 */var/log/messages* 和 */var/log/dhcpd*。我不喜欢这样，我希望我的 DHCP 消息只出现在 */var/log/dhcpd* 中。我可以通过遵循 `authpriv` 示例，使用 `none` 设施故意将 DHCP 消息从 */var/log/messages* 中排除：

```
*.notice;authpriv.none;local7.none        /var/log/messages
```

我的 */var/log/messages* syslog 配置经常随着我逐步排除每个本地设施而变得相当长，但这没关系。

**空格与制表符**

传统的类 Unix 操作系统要求在 *syslog.conf* 中的列之间使用制表符（tabs），但 FreeBSD 允许使用空格。如果你在不同的操作系统之间共享相同的 *syslog.conf*，请确保只使用制表符。

#### *syslogd 自定义*

FreeBSD 默认运行 syslogd，开箱即用，它可以作为日志主机使用。你可以通过使用命令行标志来定制它的工作方式。你可以在命令行或在 *rc.conf* 中指定标志，形式为 `syslogd_flags`。

##### 允许的日志发送者

你可以指定 syslogd(8) 接受来自哪些主机的日志消息。这可以防止你接受来自互联网上随机人的日志。虽然发送大量日志可以用来填满硬盘，作为攻击的前期准备，但更有可能是配置错误的结果。无论如何，你的日志服务器应该通过防火墙进行保护。使用 `-a` 标志来指定可以向你发送日志消息的主机的 IP 地址或网络，以下两个（互斥）示例展示了这一点：

```
syslogd_flags="-a 192.168.1.9"
syslogd_flags="-a 192.168.1.0/24"
```

虽然 syslogd(8) 也接受 DNS 主机名和域名作为这一限制，但 DNS 是一个完全不适合用作访问控制机制的工具。

你可以通过指定 `-s` 标志来完全禁用接受远程主机的消息，这是 FreeBSD 的默认设置。如果你改用 `-ss`，syslogd(8) 还会禁用向远程主机发送日志消息。使用 `-ss` 会将 syslogd(8) 从 sockstat(1) 和 netstat(1) 显示的网络感知进程列表中移除。尽管这个半开放的 UDP 套接字无害，但有些人更喜欢 syslogd(8) 完全不显示在网络上。

##### 绑定到单一地址

syslogd(8) 默认绑定到系统所有 IP 地址上的 UDP 514 端口。你的监狱服务器需要 syslogd，但监狱机器只能运行绑定到单一地址的守护进程。使用 `-b` 标志强制 syslogd(8) 绑定到单一 IP 地址：

```
syslogd_flags="-b 192.168.1.1"
```

##### 附加日志套接字

syslogd(8)可以通过 Unix 域套接字以及通过网络接受日志消息。标准位置是*/var/run/log*。然而，系统上没有任何 chroot 进程可以访问这个位置。如果你希望这些 chroot 进程能够运行，你必须配置它们通过网络进行日志记录，或者为它们提供一个额外的日志套接字。使用`-l`标志来实现这一点，并指定额外日志套接字的完整路径：

```
syslogd_flags="-l /var/named/var/run/log"
```

named(8)和 ntpd(8)程序是 FreeBSD 的一部分，通常会被 chroot。*/etc/rc.d/syslogd*足够智能，可以在你通过*rc.conf*配置这些程序的 chroot 时，自动添加适当的 syslogd 套接字。

##### 详细日志记录

使用详细模式记录日志（`-v`）会打印本地日志中每条消息的数字设施和级别。使用双重详细日志记录会打印设施和级别的名称，而不是数字：

```
syslogd_flags="-vv"
```

这些是我认为最常用的标志。有关完整的选项列表，请参阅 syslogd(8)。

### 日志文件管理

日志文件会增长，你必须决定它们可以增长到什么大小后进行修剪。标准的方法是通过*日志轮换*。当日志被轮换时，最旧的日志会被删除，当前日志文件会关闭并重新命名，并为新的数据创建一个新的日志文件。FreeBSD 包含一个基本的日志文件处理器 newsyslog(8)，它还会压缩文件、重启守护进程，并一般处理所有常规的日志文件操作。cron(1)每小时运行一次 newsyslog(8)。

当 newsyslog(8)运行时，它会读取*/etc/newsyslog.conf*和*/etc/newsyslog.conf.d/*中的文件。*/etc/newsyslog.conf*文件用于核心系统功能，而*/etc/newsyslog.conf.d/*中的文件用于附加软件。newsyslog 程序尝试将*/etc/newsyslog.conf.d/*中的任何文件解析为 newsyslog 配置文件。两者使用相同的格式，因此为了清晰起见，我们将参考*newsyslog.conf*。*newsyslog.conf*中的每一行给出了轮换一个日志文件的条件。如果满足轮换日志的条件，日志会被轮换，并根据需要执行其他操作。*/etc/newsyslog.conf*每个日志文件使用一行；每一行有七个字段，如下所示：

```
/var/log/ppp.log        root:network    640  3     100  *     JC
```

让我们逐个检查每个字段。

#### *日志文件路径*

每行的第一个条目（例如示例中的`/var/log/ppp.log`）是要处理的日志文件的完整路径。

#### *所有者和组*

第二个字段（在我们的示例中为`root:network`）列出了轮换文件的所有者和组，它们由冒号分隔。这个字段是可选的，并且在许多标准条目中并不存在。

newsyslog(8)可以更改旧日志文件的所有者和组。默认情况下，日志文件由 root 用户和 wheel 组拥有。虽然更改所有者并不常见，但在多用户机器上你可能需要此功能。

你还可以选择只更改所有者或仅更改组。在这种情况下，你可以在冒号的两侧只使用一个名称。例如，`:www`将组更改为 www，而`mwlucas:`则将文件的所有权转给我。

#### *权限*

第三个字段（在我们的示例中是`640`）给出了标准 Unix 三位数字表示法中的权限模式。

#### *计数*

该字段指定 newsyslog(8)应保留的最旧旋转日志文件。newsyslog(8)按从最新到最旧的顺序编号存档日志，从最新的日志为日志 0。例如，使用默认的`count`为`5`，对于*/var/log/messages*，你将看到以下日志消息：

```
messages
messages.0.bz
messages.1.bz
messages.2.bz
messages.3.bz
messages.4.bz
messages.5.bz
```

会算数的人会意识到，这样会有六个归档文件，而不是五个，加上当前的日志文件，共有一周的日志。通常来说，日志文件太多总比太少好；但是，如果磁盘空间紧张，删除一个或两个额外的日志文件可能会为你争取一些时间。

#### *大小*

第五个字段（在我们的示例中是`100`）表示文件的大小，以千字节为单位。当 newsyslog(8)运行时，它会将此处列出的大小与文件的实际大小进行比较。如果文件大于此处给定的大小，newsyslog(8)会旋转该文件。如果你不希望文件大小影响文件何时旋转，可以在这里放置一个星号。

#### *时间*

到目前为止，这似乎很简单，对吧？第六个字段，旋转时间，改变了这一点。时间字段有四种不同的合法值类型：星号、数字和两种日期格式。

如果你希望基于日志大小而非年龄进行旋转，请在这里放置一个星号。

如果你在此字段中填写一个普通的数字，newsyslog(8)将在经过该小时数后旋转日志。例如，如果你希望日志每 24 小时旋转一次，但不关心具体的时间，可以在这里填写`24`。

日期格式稍微复杂一些。

##### ISO 8601 时间格式

任何以`@`符号开头的条目都采用限制版 ISO 8601 时间格式。这是 newsyslog(8)在大多数类 Unix 系统上使用的标准格式；它也是 MIT 最初版本的 newsyslog(8)所采用的时间格式。限制版 ISO 8601 稍显晦涩，但每个类 Unix 操作系统都支持它。

限制版 ISO 8601 格式的完整日期是 14 位数字，中间有一个`T`。前四位是年份，接下来的两位是月份，再接下来的两位是日期。`T`作为一种十进制点插入在中间，将整天与部分天数分开。接下来的两位是小时，接下来的两位是分钟，最后两位是秒数。例如，2008 年 3 月 2 日晚上 9:15:08 的日期在限制版 ISO 8601 中表示为`20080302T211508`。

完整的受限 ISO 8601 日期格式比较简单，但当你没有列出完整日期时，容易产生混淆。你可以选择仅指定靠近 `T` 的字段，其他字段留空。空字段是通配符。例如，`1T` 匹配每个月的第 1 天。`4T00` 匹配每个月第 4 天的午夜。`T23` 匹配每天的第 23 小时，即晚上 11 点。使用 *newsyslog.conf* 配置的 `@T23`，日志会在每天晚上 11 点旋转。

与 cron(1) 一样，你必须详细指定时间单位。例如，`@7T`，表示每月第七天，日志每小时旋转一次，持续整天。毕竟，它匹配整天！`@7T01` 会在每月第七天的凌晨 1 点旋转日志，这通常是更理想的设置。然而，你不需要更精确的细节，因为 newsyslog(8) 只每小时运行一次。

##### FreeBSD 特有时间

受限 ISO 8601 时间系统不允许你轻松指定每周任务，也无法指定每月的最后一天。因此，FreeBSD 提供了一种时间格式，让你能够轻松执行这些常见任务。任何以美元符号（`$`）开头的条目，都是采用 FreeBSD 特有的 *月周日* 格式编写的。

该格式使用三个标识符：`M`（月份的日期），`W`（星期几），和 `H`（一天中的小时）。每个标识符后跟一个数字，表示特定的时间。小时数从 0 到 23，星期几从 0（星期天）到 6（星期六）。月份的日期从 1 开始，直到月末，`L` 表示每月的最后一天。例如，要在每个月的第 5 天中午进行日志旋转，我可以使用 `$M5H12`。要在每个月的最后一天晚上 10 点开始月末日志统计，可以使用 `$MLH22`。

**按大小和时间旋转**

你可以在特定时间、达到某个大小时，或两者都满足时旋转日志。如果你同时指定大小和时间，日志将在满足任一条件时旋转。

#### *标志*

`flags` 字段指定日志旋转时要执行的任何特殊操作。这通常告诉 newsyslog(8) 如何压缩日志文件，但你也可以在日志被旋转时通知进程。

##### 日志文件格式和压缩

日志可以是文本文件或二进制文件。

二进制文件只能以非常特定的方式写入。newsyslog(8) 每次创建新的日志时，都会添加“日志文件已翻转”的信息，但将此文本添加到二进制文件会损坏它。`B` 标志告诉 newsyslog(8)，这是一个二进制文件，不需要此头信息。

其他日志文件以普通 ASCII 文本形式写入，newsyslog(8) 可以并且应该在文件顶部添加一个时间戳消息，指示日志何时被旋转。如果你使用 UFS，压缩旧日志文件可以节省大量空间。`-J` 标志告诉 newsyslog(8) 使用 bzip(1) 压缩归档文件；`-Z` 标志指定 gzip 压缩；`-X` 标志表示 xz(1) 压缩；`-Y` 标志表示新兴的 zstd(1) 压缩方式。

然而，如果你使用 ZFS，文本日志文件会在数据集层与其他可压缩文件一起被压缩。你仍然可以按传统方式压缩日志文件，但这样做没有任何优势。此外，在查看文件之前，你需要手动解压它们。让 ZFS 为你处理压缩。

##### 特殊日志文件处理

当它创建并旋转日志文件时，newsyslog(8) 可以执行一些特殊任务。以下是最常见的任务；你可以在 newsyslog.conf(5) 中阅读关于其他任务的内容。

或许你有许多类似的日志文件，想要以相同方式处理。`-G` 标志告诉 newsyslog，行首的日志文件名实际上是一个 shell 通配符，并且所有匹配该表达式的日志文件都应按这种方式旋转。要了解 shell 表达式，请阅读 glob(3)。准备好带上止痛药。

你可能希望 newsyslog 在文件不存在时创建一个文件。为此，请使用 `-C` 标志。syslogd 程序不会记录到不存在的文件。

`-N` 标志明确告诉 newsyslog 在旋转此日志时不要发送信号。

最后，当你不需要使用这些标志时，使用短横线（`-`）作为占位符。它在此处创建一列，以便你可以放置比如 pidfile 路径。

#### *Pidfile*

下一个字段是一个 pidfile 路径（在我们的示例中未显示，但请查看 */etc/newsyslog.conf* 以了解几个示例）。pidfile 记录程序的进程 ID，以便其他程序可以轻松查看它。如果你列出 pidfile 的完整路径，newsyslog(8) 会在旋转日志时向该程序发送 `kill -HUP` 信号。这会通知该进程关闭其日志文件并重新启动自己。并非所有进程都有 pidfile，也并非所有程序在旋转日志时都需要这种特殊处理。

#### *信号*

大多数程序在收到 `SIGHUP` 信号时会执行日志文件旋转，但一些程序在日志旋转时需要特定的信号。你可以在最后一个字段（pidfile 后）列出所需的确切信号。

#### *示例 newsyslog.conf 条目*

让我们将所有这些组合起来，形成一个最糟糕的、你绝对不会相信的示例。一个数据库日志文件需要在每个月的最后一天的晚上 11 点进行旋转。数据库文档说明，在旋转日志时，必须向服务器发送一个中断信号（`SIGINT`，即信号编号 2）。你希望归档日志文件的所有权属于用户 *dbadmin*，且仅该用户可以查看。你需要保留六个月的日志。更重要的是，这些日志是二进制文件。你的 *newsyslog.conf* 条目看起来将是这样的：

```
/var/log/database    dbadmin:   400   6   *   $MLH23   B   /var/run/db.pid   2
```

这是一个故意设计的恶劣示例；在大多数情况下，你只需要输入文件名和轮换条件，就能完成。

### FreeBSD 与 SNMP

通过电子邮件发送的报告很好，但比较笼统，日志也很难分析长期趋势。网络、服务器和服务管理的行业标准是*简单网络管理协议（SNMP）*。许多不同的厂商支持 SNMP 作为一种协议，用于从网络上许多不同的设备收集信息。FreeBSD 包括一个 SNMP 代理 bsnmpd(8)，不仅提供标准的 SNMP 功能，还能展示 FreeBSD 特有的功能。

FreeBSD 的*bsnmpd*（*Begemot SNMPD*的缩写）是一个极简主义的 SNMP 代理，专为可扩展性设计。所有实际功能通过外部模块提供。FreeBSD 包括用于标准网络 SNMP 功能的 bsnmpd 模块以及用于 FreeBSD 特定功能的模块，如 PF 和 netgraph(4)。bsnmpd(8)并不是想做所有事情，而是提供一个基础，使每个人都可以构建只做他们所需的功能的 SNMP 实现，既不多也不少。

#### *SNMP 101*

SNMP 工作在经典的客户端-服务器模型上。SNMP 客户端，通常是某种管理工作站或监控服务器，向 SNMP 服务器发送请求。SNMP 服务器，也称为*代理*，从本地系统收集信息并将其返回给客户端。FreeBSD 的 SNMP 代理是 bsnmpd(8)。

SNMP 代理还可以发送请求以对 SNMP 服务器进行更改。如果系统正确（或不正确，取决于你的观点）配置，你可以通过 SNMP 发出命令。这个“写”配置通常用于路由器、交换机和其他嵌入式网络设备。大多数类 Unix 操作系统有命令行管理系统，通常不接受通过 SNMP 发出的指令。通过 SNMP 写入系统配置或发出命令需要仔细的设置，并会引发各种安全问题；这本身就是一本书的好话题。我认识的没有哪位系统管理员会通过 SNMP 管理他们的系统。考虑到这一点，我们将专注于只读 SNMP。

除了让 SNMP 服务器响应来自 SNMP 客户端的请求外，客户端还可以向网络上其他地方的陷阱接收器发送 SNMP*陷阱*。SNMP 代理会在服务器发生特定事件时生成这些陷阱。SNMP 陷阱很像 syslogd(8)消息，只是它们遵循 SNMP 所要求的非常具体的格式。FreeBSD 目前不包括 SNMP 陷阱接收器；如果需要，可以查看来自 net-snmp 的 snmptrapd(8)（*net-mgmt/net-snmp*）。

##### SNMP MIBs

SNMP 通过管理信息库（MIB）来管理信息，MIB 是一个树状结构，包含以 ASN.1 格式表示的层级信息。我们之前见过一个 MIB 树的例子：在第六章中讨论的 sysctl(8)接口。

每个 SNMP 服务器都有一个它可以从本地计算机中提取信息的列表。服务器将这些信息按层次结构排列成一棵树。每个 SNMP MIB 树都有一些非常通用的主要类别：网络、物理、程序等，每个类别下有更具体的子分类。可以把这棵树想象成一个组织良好的文件柜，其中每个抽屉存放着特定的信息，而抽屉中的文件则存放着具体的事实。类似地，最上层的 MIB 包含了它下属的 MIB 列表。

MIB 可以通过名称或数字来引用。例如，下面是从一个示例系统中提取的 MIB：

```
interfaces.ifTable.ifEntry.ifDescr.1 = STRING: "em0"
```

这个 MIB 中的第一个术语 `interfaces` 告诉我们，我们正在查看这台机器的网络接口。如果这台机器没有接口，第一类甚至不会存在。`ifTable` 是接口表，或者说是系统上所有接口的列表。`ifEntry` 显示某个特定接口，`ifDescr` 表示我们正在查看该接口的描述。这个 MIB 可以总结为：“这台机器上的接口 1 叫做 em0。”

MIB 可以用数字表示，大多数 SNMP 工具本地使用数字 MIB 进行工作。大多数人喜欢使用文字，但你的大脑必须能够处理任意一种方式。MIB 浏览器可以帮助你在数字形式和文字形式的 SNMP MIB 之间进行转换，或者你可以安装 *net-mgmt/net-snmp* 并使用 snmptranslate(1)，但现在，暂时相信我。前面的示例可以转换为：

```
.1.3.6.1.2.1.2.2.1.2.1
```

用文字表示时，这个 MIB 由 5 个以点分隔的术语组成。用数字表示时，这个 MIB 有 11 个部分。如果它们应该是同一个东西，那么这看起来就不太对劲了。怎么回事？

数字表示的 MIB 更长，因为它包含了默认的 `.1.3.6.1.2.1`，它表示 *iso.org.dod.internet.mgmt.mib-2*。这是互联网上使用的标准 MIB 子集。绝大多数 SNMP MIB（但不是全部）都有这个前缀，因此大家通常不再写它。

如果你处于那种难以抑制的情绪中，你甚至可以混合使用文字和数字：

```
.1.org.6.1.mgmt.1.interfaces.ifTable.1.2.1
```

在这一点上，国际条约允许你的同事们用火把和叉子把你赶出大楼。选择一种表示 MIB 的方式并坚持使用它。

##### MIB 定义和 MIB 浏览器

MIB 是根据非常严格的语法定义的，并且记录在 *MIB 文件* 中。每个 SNMP 代理都有自己的 MIB 文件；bsnmpd 的 MIB 文件位于 */usr/share/snmp*。这些文件是非常正式的纯文本格式。尽管你可以仅凭大脑阅读和理解它们，但我强烈建议将它们复制到工作站并安装一个 MIB 浏览器，以便更容易地理解它们。

*MIB 浏览器*解释 MIB 文件，并以完整的树形结构呈现它们，包括每个树的定义和每个 MIB 的描述。一般来说，MIB 浏览器让你输入一个特定的 MIB，并显示该 MIB 的数字和文字定义，同时查询 SNMP 代理以获取该 MIB 的状态。

如果你的工作站上运行 FreeBSD（或其他较小的 Unix 系统），可以使用 mbrowse（*net-mgmt/mbrowse*）进行 MIB 浏览。如果你不想使用图形界面来进行 SNMP 操作，可以查看 net-snmp（*net-mgmt/net-snmp*），它提供了一整套命令行 SNMP 客户端工具。

##### SNMP 安全性

许多安全专家表示，SNMP 实际上代表着“安全：不是我的问题！”这虽然有些刻薄，但确实很真实。SNMP 应该只在受信任的网络上的防火墙后使用。如果你必须在裸露的互联网中使用 SNMP，请使用数据包过滤来防止公众查询你的 SNMP 服务。SNMP 代理运行在 UDP 端口 161 上。

更常见的 SNMP 版本 1 和 2c 不提供加密。这意味着任何拥有数据包嗅探器的人都可以捕获你的 SNMP 社区名，所以一定要确保只在私有网络上使用 SNMP。在不受信任的网络上发起未加密的 SNMP 查询，是让陌生人窥探你系统管理的好方法。SNMP 版本 3 使用加密来保护数据传输。

SNMP 通过*社区*提供基本的安全性。如果你去查找相关内容，你会发现各种解释，说明为什么社区与密码不同，但社区*就是*密码。大多数 SNMP 代理默认有两个社区：public（只读访问）和 private（读写访问）。是的，默认有一个提供读写访问的社区。每当你为任何主机上的任何操作系统配置 SNMP 代理时，首先要做的就是禁用这些默认的社区名称，并用那些几十年来未被广泛记录的名称来替代。

FreeBSD 的 bsnmpd(8)默认使用 SNMPv2c，但也可以使用 SNMPv3。SNMPv3 是一个更复杂的协议，所以我们在这里不讨论它。如果你理解 SNMPv3 协议和配置 FreeBSD 的 bsnmpd 的基础知识，那么启用 SNMPv3 将不会有任何问题。

#### *配置 bsnmpd*

在你可以使用 SNMP 来监控系统之前，必须配置 SNMP 守护进程。配置 bsnmpd(8)文件位于*/etc/snmpd.config*。除了包含公共(public)和私有(private)的默认社区外，默认配置不会启用任何使得 bsnmpd(8)具有吸引力的 FreeBSD 特定功能。

##### bsnmpd 变量

bsnmpd 使用变量为配置语句赋值。大多数高可见性的变量在配置文件的顶部设置，正如你在这里看到的：

```
location := "Room 200"
contact := "sysmeister@example.com"
system := 1     # FreeBSD
traphost := localhost
trapport := 162
```

这些顶部的变量定义了应该在每个 SNMP 代理上设置的 MIB 值。位置描述了机器的物理位置。每个系统都需要一个合法的电子邮件联系方式。bsnmpd(8)也运行在 FreeBSD 以外的操作系统上，因此你可以选择在这里设置特定的操作系统。最后，如果你有陷阱主机，你可以在这里设置服务器名称和端口。

在文件的下方，你可以设置 SNMP 社区名称：

```
# Change this!
read := "public"
# Uncomment begemotSnmpdCommunityString.0.2 below that sets the community
# string to enable write access.
write := "geheim"
trap := "mytrap"
```

`read`字符串定义了该 SNMP 代理的只读社区。默认配置文件建议你更改它。听取这个建议。`write`字符串是读写社区名称，默认在配置文件的下方被禁用。你还可以设置该代理发送的 SNMP 陷阱的社区名称。

仅凭这一配置，bsnmpd(8)将启动、运行并为你的网络管理系统提供基本的 SNMP 数据。只需在*/etc/rc.conf*中设置`bsnmpd``_enable="YES"`，以便在启动时启动 bsnmpd。然而，你不会获得任何特别的 FreeBSD 功能。让我们继续，看看如何管理这个。

##### 详细的 bsnmpd 配置

bsnmpd(8)使用你在配置文件顶部设置的变量，稍后在配置中为不同的 MIB 分配值。例如，在文件的顶部你将变量`read`设置为`public`。稍后在配置文件中，你会看到如下语句：

```
begemotSnmpdCommunityString.0.1 = $(read)
```

这将 MIB `begemotSnmpdCommunityString.0.1`设置为`read`变量的值。

为什么不直接设置这些值呢？bsnmpd(8)被专门设计为可扩展和可配置的。在文件顶部设置几个变量比直接编辑文件下方的规则要容易得多。

让我们回到这里设置的`begemotSnmpdCommunityString` MIB。我们为什么要设置这个？在 MIB 浏览器中搜索这个字符串，你会看到这是定义 SNMP 社区名称的 MIB。你可能已经从`read`变量的赋值中猜到这一点，但确认一下也不错。

同样，你会找到类似这样的条目：

```
begemotSnmpdPortStatus.0.0.0.0.161 = 1
```

检查 MIB 浏览器显示，这决定了 bsnmpd(8)绑定的 IP 地址和 UDP 端口（在本例中，所有可用地址，端口为 161）。所有 MIB 配置都是以这种方式完成的。

##### 加载 bsnmpd 模块

大多数有趣的 bsnmpd(8)功能是通过模块配置的。通过在配置文件中为`begemotSnmpdModulePath` MIB 指定模块处理的类和实现该功能的共享库的完整路径来启用模块。例如，在默认配置中，你会看到 PF bsnmpd(8)模块的注释掉的条目：

```
begemotSnmpdModulePath."pf"    = "/usr/lib/snmp_pf.so"
```

这启用了 PF MIB 的支持。当你启用此选项时，你的网络管理软件将能够直接查看 PF，允许你跟踪从丢失的包到状态表大小的所有信息。

截至本文撰写时，FreeBSD 的 bsnmpd(8) 包含了以下模块，默认禁用。有些模块是 FreeBSD 特有的，而另一些支持行业标准。通过取消注释它们的配置文件条目并重新启动 bsnmpd 来启用这些模块。

lm75 通过 SNMP 提供来自 lm75(4) 温度传感器的数据。

Netgraph 提供了所有基于 Netgraph 的网络功能的可视化，详细信息见 snmp_netgraph(3)。

PF 提供了 PF 包过滤器的可视化。

Hostres 实现了主机资源 SNMP MIB，见 snmp_hostres(3)。

bridge 提供了桥接功能的可视化，详细信息见 snmp_bridge(3)。

wlan 访问有关无线网络的信息。

启用这些模块后，重新启动 bsnmpd(8)。如果程序无法启动，请检查 */var/log/messages* 中的错误信息。

使用 bsnmpd(8)、syslogd(8)、状态邮件和各种性能分析工具，你可以让你的 FreeBSD 系统成为网络中监控最强的设备。现在你已经可以看到系统的所有功能了，让我们拿起手电筒，探索一下 FreeBSD 的一些隐秘角落。
