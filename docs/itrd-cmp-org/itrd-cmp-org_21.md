## **21

异常与中断**

![图片](img/pg495_Image_321.jpg)

到目前为止，我们一直将每个应用程序视为独占使用计算机。但与大多数操作系统一样，Raspberry Pi OS 允许多个应用程序并行运行。它以交替的方式管理硬件，按照需求为每个应用程序及操作系统本身提供所需的硬件资源。

这里有两个问题。首先，操作系统为了执行管理任务，必须保持对应用程序与硬件交互的控制。它通过使用 CPU 中的特权级别系统来实现这一点，从而让操作系统控制其与应用程序之间的网关。

第二，在第二十章中我们看到，大多数 I/O 设备在准备好提供输入或接受输出时，可以中断 CPU 正在进行的活动。CPU 有一个机制来通过这个网关引导 I/O 中断，并调用由操作系统控制的功能，从而允许操作系统保持对 I/O 设备的控制。

在这一章中，我将首先讨论 CPU 如何利用特权级别来强化对硬件的控制。然后，我将讲解什么样的事件会导致特权级别的变化，以及 CPU 如何响应这些事件。最后，我将以一条指令为结束，讨论这条指令如何让应用程序穿越应用软件与系统软件之间的网关，直接调用操作系统中的实用功能。

对这一材料的全面讨论需要详细了解操作系统的内部结构以及如何编程使用特定的硬件，这超出了本书的范围。这里的目标是为你提供一个非常概括的概览。

### **应用软件与系统软件**

软件通常可以分为应用软件和系统软件。我们使用*应用软件*来处理计算机上的大部分任务，而*系统软件*则管理硬件资源的使用，为应用软件提供对硬件的受控访问。

系统软件与应用软件之间的划分是通过*特权级别*系统来维持的。操作系统在*特权*级别上执行，使其能够管理大多数硬件资源。应用程序则在*非特权*级别上执行，以防止它们直接访问大部分硬件。操作系统作为特权程序，充当应用程序对计算机资源使用的监督者。

这种特权分离使操作系统能够管理执行多个应用程序所需的资源。例如，我们可以运行一个媒体应用程序播放音乐，同时使用编辑器应用程序编辑源文件。在等待我们按下另一个键时，操作系统允许媒体应用程序使用 CPU。当我们按下键时，操作系统暂停媒体应用程序足够长的时间来读取按键，然后将控制权交回给媒体应用程序，同时等待非常缓慢（在 CPU 时间内）的我们按下下一个键。

*异常*是指导致当前执行的代码流被暂停，并将 CPU 控制权交给运行在特权级别软件的事件。*中断*是来自连接到 CPU 的设备引发的一种异常事件。在讨论可能导致异常的原因以及异常发生时的处理过程之前，让我们先看看特权级别。

**注意**

*虽然一般概念相同，但术语有所不同，因此在阅读相关手册时需要注意。例如，ARM 使用*异常*作为更通用的术语，其中*中断*是异常的一种类型。另一方面，Intel 使用*中断*作为更通用的术语，而*异常*是中断的一种类型。*

### **特权和异常级别**

操作系统使用*异常级别*来执行当前正在运行的软件的特权级别。任何时候，CPU 都在四个可能的异常级别中的一个级别运行。表 21-1 显示了从最低特权到最高特权的各个级别。

**表 21-1：** AArch64 异常级别

| **级别** | **用途** |
| --- | --- |
| EL0 | 应用程序 |
| EL1 | 操作系统 |
| EL2 | 虚拟机监控程序 |
| EL3 | 固件/安全监视器 |

应用程序在最低的异常级别 EL0 下执行。操作系统在异常级别 EL1 下执行。

*虚拟机监控程序*允许我们在同一计算机上同时运行多个操作系统，通过协调它们与硬件资源的交互。虚拟机监控程序在异常级别 EL2 下执行，赋予它对操作系统的监督控制。

*固件*提供对设备硬件的低级控制。它存储在只读存储器中，并在最高的异常级别 EL3 下执行。当 Raspberry Pi 首次启动时，CPU 从 EL3 开始，以便可以访问所有硬件。

AArch64 架构定义了*安全状态*和*非安全状态*。在安全状态下，可以访问所有硬件，而在非安全状态下，访问受到限制。两个状态之间的切换由*安全监视器*控制，安全监视器是一种只能在异常级别为 EL3 时执行的软件。

在第二十章中，你学习了内存管理单元（MMU）如何使用页表将虚拟内存地址映射到物理内存地址。页表中的每个虚拟内存范围条目包括一个 2 位的*访问权限（AP）*字段，用于该内存范围。表 21-2 展示了每个 CPU 异常级别下的这些权限。

**表 21-2：** AArch64 内存访问权限级别

| **AP** | **EL0（非特权）** | **EL1/2/3（特权）** |
| --- | --- | --- |
| `00` | 无访问 | 读/写 |
| `01` | 读/写 | 读/写 |
| `10` | 无访问 | 只读 |
| `11` | 只读 | 只读 |

应用程序在其指令和只读数据加载到访问权限设置为`11`的虚拟内存中执行。如果它们有任何全局变量，这些变量将被加载到访问权限设置为`01`的虚拟内存中。

操作系统的指令和只读数据被加载到访问权限设置为`10`的虚拟内存中，其全局变量则加载到访问权限设置为`00`的虚拟内存中。

在第二十章的清单 20-2 中，你看到过如何处理这些内存访问权限的例子，当时是在编程 GPIO 设备时。操作系统将一段特权虚拟内存地址空间映射到 GPIO 设备寄存器的硬件地址。我们使用`mmap`系统调用函数，将应用程序中的非特权内存映射到操作系统的 GPIO 地址空间，以便我们的应用程序能够访问它。

除了异常级别外，Armv8-A 处理器还有两种执行状态，AArch32 和 AArch64，如第九章介绍中所述。操作系统在启动时设置执行状态。

异常提供了一种改变执行状态的方法。当一个异常将 CPU 带到更高的异常级别时，我们可以告诉处理器保持当前执行状态或转换到 AArch64。在从异常返回到较低的异常级别时，我们可以告诉处理器保持当前执行状态或转换到 AArch32。这使得我们可以在 64 位的树莓派操作系统下运行 32 位应用程序，但在 32 位版本的树莓派操作系统下无法运行 64 位应用程序。

在接下来的章节中，你将看到异常如何允许使用特权软件。

### **异常事件**

有几种事件可能会导致异常。最常见的原因之一是应用程序（非特权）需要操作系统（特权）提供的服务。

一个例子是当我们调用`write`系统调用函数来在屏幕上显示文本时。如第二章中的图 2-1 所示，`write`函数直接与操作系统通信，操作系统再将字符发送到屏幕。这是通过`svc`指令完成的，它会引发异常。你将在本章后面看到如何使用`svc`。

由`svc`指令引发的异常是*同步异常*，即其时序与 CPU 的时序同步。其他同步异常的原因包括尝试执行在当前异常级别无效的指令，尝试访问超出当前异常级别范围的内存地址，以及调试器在程序中插入断点。

*异步异常*与 CPU 的时序无关。异步异常，也称为*中断*，通常来自 I/O 设备。

异步异常的一个例子是当我们使用`read`系统调用函数从键盘获取字符时。如图 2-1 所示，`read`函数也直接与操作系统通信。然而，当`read`函数请求从键盘获取字符时，操作系统无法预知下一个按键何时会被按下。

操作系统通知键盘设备控制器它正在等待一个字符，并将当前运行的程序置于等待状态。如果有另一个程序准备运行，操作系统将把 CPU 控制权交给该程序。当用户按下键盘上的某个键时，键盘设备控制器向 CPU 发送中断信号，从而引发异常。当 CPU 完成当前指令的执行后，它会处理该中断异常，通常会将等待的程序置于就绪状态。

异常处理是由一段称为*异常处理程序*的代码完成的。CPU 通过执行处理程序代码来响应异常。我们来看一下 CPU 是如何做到这一点的。

### **CPU 对异常的响应**

处理器包含一组*系统寄存器*，用于保存处理器的配置设置。这些寄存器包括保存响应和处理异常所需数据的寄存器。部分用于异常的系统寄存器如表 21-3 所示。

**表 21-3：** 处理异常的部分系统寄存器

| **名称** | **寄存器** | **用途** |
| --- | --- | --- |
| `currentel` | 当前异常级别 | 位 3 和位 2 保存异常级别（`00`表示 EL0，`01`表示 EL1，`10`表示 EL2，`11`表示 EL3） |
| `elr` | 异常链接 | 引发异常的指令地址 |
| `esr` | 异常综合 | 关于异常原因的信息 |
| `far` | 错误地址 | 引发故障的访问地址 |
| `hcr` | 虚拟化配置 | 与 EL2 相关的虚拟化设置 |
| `scr` | 安全配置 | 与 EL3 相关的安全状态设置 |
| `sctlr` | 系统控制 | 关于系统的信息 |
| `spsr` | 保存的程序状态 | 异常发生时该异常级别的 PSTATE |
| `vbar` | 向量基地址 | 异常发生时跳转到该异常级别的基地址 |

这些寄存器只能通过在特权级别运行的软件访问。只有一个 `currentel` 寄存器。`hcr` 寄存器位于 EL2，`scr` 寄存器位于 EL3。此表中的其他系统寄存器在 EL1、EL2 和 EL3 上都有实例。

当前 CPU 的异常级别由 `currentel` 中的第 3 位和第 2 位确定。其他 62 位保留供未来使用。该内容可以通过在特权级别执行 `mrs x`d, `currentel` 指令加载到通用寄存器中：

mrs**—移动系统寄存器**

`mrs x`d, `systemreg` 将系统寄存器 `systemreg` 的内容复制到 `x`d。仅在异常级别 EL1 及以上有效。

还有一个 `msr` 指令，用于将内容存储到某些系统寄存器中，但不能存储到 `currentel` 寄存器中。`currentel` 寄存器中的 2 位异常级别字段的内容只能通过异常来更改。

异常级别只能通过异常事件增加，异常事件可以增加级别或保持不变，但 EL0 的异常事件只能增加级别。减少异常级别的唯一方法是使用 `eret` 指令，它将降低级别或保持不变：

eret**—异常返回**

`eret` 从 `spsr` 寄存器恢复当前异常级别的 PSTATE，并将当前异常级别的 `elr` 寄存器中的地址加载到 `pc`。

PSTATE 是系统寄存器位设置的抽象，定义了当前的处理器状态。例如，`currentel` 寄存器中的第 3 位和第 2 位包含在 PSTATE 中。第九章中 表 9-2 中列出的 `nzcv` 寄存器中的条件标志也包含在 PSTATE 中。

响应异常时，CPU 执行的操作类似于 `bl` 指令，但有一些显著的不同之处。最明显的区别是，我们在程序代码中指定 `bl` 指令跳转的地址，而异常会导致跳转到 *异常向量表* 中的一段代码。

异常向量表有 16 个条目，按 4 个一组排列，如 表 21-4 所示。

**表 21-4：** 异常向量表中的条目

| **偏移** | **类型** | **条件** |
| --- | --- | --- |
| `0x000` | 同步 | 从当前 EL 使用 EL0 的 SP |
| `0x080` | IRQ |  |
| `0x100` | FIQ |  |
| `0x180` | SError |  |
| `0x200` | 同步 | 从当前 EL 使用当前级别的 SP |
| `0x280` | IRQ |  |
| `0x300` | FIQ |  |
| `0x380` | SError |  |
| `0x400` | 同步 | 从较低的 EL，使用 AArch64 跳转到下一个较低的 EL |
| `0x480` | IRQ |  |
| `0x500` | FIQ |  |
| `0x580` | SError |  |
| `0x600` | 同步 | 从较低的 EL，使用 AArch32 跳转到下一个较低的 EL |
| `0x680` | IRQ |  |
| `0x700` | FIQ |  |
| `0x780` | SError |  |

异常级别 EL1、EL2 和 EL3 各自拥有自己的 2KiB 异常向量表。每个 16 个条目包含处理与该条目对应的异常类型和条件的代码。每个条目的长度为 128 字节，可以容纳最多 32 条异常处理指令。如果需要超过 32 条指令来处理异常，则可以从该条目程序代码中调用表外的函数。

每个异常向量表在操作系统首次启动时创建。每个表的地址存储在相应异常级别的向量基地址寄存器`vbar`中。异常会根据异常类型和异常发生时的条件，跳转到这些条目中某一条目的第一条指令。

同步异常来自 CPU，如前一节所述。在三种异步异常中，*IRQ* 是通常来自 I/O 设备控制器的中断请求。在早期版本的 ARM 架构中，*FIQ* 是来自 I/O 设备控制器的快速中断请求，其优先级高于 IRQ。从 Armv8-A 架构开始，FIQ 与 IRQ 具有相同的优先级；它只是提供了另一条中断路径。这两条路径的使用取决于架构的实现。

*SError* 是一种系统错误，用于指示内存系统中发生了意外事件。导致 SError 异常的事件也会根据实现方式有所不同。

每种类型的异常选择的入口取决于异常是否来自相同的异常级别，或者来自较低的级别。如果异常来自当前异常级别，选择将依赖于是否使用 EL0 或当前异常级别的堆栈指针。

如果异常来自较低的异常级别，则选择的入口取决于紧接着的较低级别是使用 AArch32 还是 AArch64 执行。例如，可能有一个 32 位虚拟机与 64 位操作系统并行运行。32 位虚拟机中的应用程序运行在 EL0，而其 32 位操作系统运行在 EL1。当处于 AArch32 模式时发生的异常，若跳转到 EL2 的虚拟机监控器（hypervisor），将进入表 21-4 的第四组中的一个条目。该组中的所有处理程序都来自 32 位虚拟机的操作系统。适当条目的异常处理程序将在 32 位操作系统内执行。

CPU 对异常的响应假设我们希望返回到被异常中断的执行流位置，并以异常发生前的状态继续执行 CPU。

在响应异常时，CPU 执行以下操作：

1.  将 PSTATE 的内容保存在它即将进入的异常级别的`spsr`寄存器中

1.  将最后执行完的指令地址存储到`elr`寄存器中

1.  对于同步和系统错误异常，将原因写入它即将进入的异常级别的`esr`寄存器

1.  对于地址相关的同步异常，将原因写入它即将进入的异常级别的`far`寄存器

1.  更新 PSTATE 为新的异常级别

1.  将适当条目的地址加载到`pc`寄存器中，指向异常向量表

异常处理程序负责保存和恢复它使用的任何通用寄存器。每个异常级别都有一个单独的堆栈指针寄存器，因此可以在每个级别设置单独的堆栈。当在 EL1、EL2 或 EL3 执行时，可以使用当前级别的堆栈指针或 EL0 的堆栈指针。

在异常处理程序恢复所有保存的通用寄存器后，它使用`eret`指令将 PSTATE 恢复到异常发生前的状态，并返回到异常发生的地方。PSTATE 包括在`currentel`寄存器中的 2 位异常级别，因此此操作还会将 CPU 返回到它原先所在的异常级别。

编写异常处理程序是一本书超出范围的高级话题，但在下一节中你将看到如何通过异常调用操作系统的服务。

### **监控调用**

操作系统作为特权实体，负责管理计算机资源。当一个没有特权的应用程序需要使用特权资源时，它通过*监控调用*向操作系统请求服务。

在清单 13-3 中，第十三章里我们使用了`write`系统调用函数，将`Hello, World!`一个字符一个字符地写到屏幕上。`write`函数是对监控调用的 C 语言封装。在清单 21-1 中的程序被称为*独立的*，因为它没有使用任何 C 语言库函数。相反，当我们需要操作系统的服务时，我们直接使用监控调用。

*hello_world.s*

```
   // Write Hello, World! using a system call.
           .arch armv8-a
   // Useful names
           .equ    NUL, 0
           .equ    STDOUT, 1
        ➊ .equ    WRITE, 0x40
           .equ    EXIT, 0x5d
   // Stack frame
           .equ    save19, 16
           .equ    FRAME, 32
   // Constant data
           .section  .rodata message:
           .string "Hello, World!\n"
   // Code
           .text
           .align  2
           .global my_hello
           .type   my_hello, %function
➋ my_hello:
           adr     x1, message       // Address of message
   loop:
           ldrb    w3, [x1]          // Load character
           cmp     w3, NUL           // End of string?
           b.eq    done              // Yes
           mov     x2, 1             // No, one char
           mov     x0, STDOUT        // Write on screen
           mov     x8, WRITE
        ➌ svc     0                 // Tell OS to do it
           add     x1, x1, 1         // Increment pointer
           b       loop              //   and continue
   done:
           mov     w0, wzr           // Return value
        ➍ mov     x8, EXIT          // Terminate this process
           svc     0
```

*清单 21-1：* Hello, World! *独立程序*

`gcc`编译器假设我们使用 C 语言托管环境，并要求第一个函数必须命名为`main`。由于我们没有使用 C 语言库，我们不需要使用 C 语言托管环境，可以随意命名我们的函数 ❷。组装完这个函数后，我们直接进入加载程序，并用`-e`选项告诉它从哪个位置开始执行该函数：

```
$ ld -e my_hello -o hello_world hello_world.o
```

当我们需要操作系统输出一个字符时，我们使用`svc`指令 ❸：

svc**—超级用户调用**

`svc` imm 会导致从异常级别 EL0 跳转到 EL1 的异常。它将 `0x15` 存储在 `esr` 寄存器的第 31 到 26 位，并将 imm（一个 16 位无符号整数）存储在 `esr` 寄存器的第 15 到 0 位。

异常级别 EL1 由操作系统处理。`svc` 处理程序使用 `x8` 寄存器中的整数来确定应采取的操作。写操作的编号是 `0x40` ❶。操作系统中写操作的其他参数与 C 库中的 `write` 函数参数相同。`svc` 指令的参数 imm 在 Linux 中未使用。

我们的 `my_hello` 函数是由操作系统直接启动的一个新进程，而不是从 C 托管环境中调用的。我们通过另一个 supervisor 调用 ❹ 来终止此进程。

请注意，在这个独立的程序中，我们不需要创建栈帧或保存任何寄存器。`svc` 的异常处理程序将在返回时恢复通用寄存器的状态。由于这个程序不会返回到 C 托管环境，我们不需要保存 `sp` 和 `fp` 寄存器。

操作系统操作的编号、操作的参数以及传递这些参数的寄存器可以在 *[`www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/`](https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/)* 上找到。该网站上有四个表格：x86_64（64 位）、arm（32 位）、arm64（64 位）和 x86（32 位）。确保使用与本书配套的 arm64 表格。

表 21-5 列出了常见的 `svc` 代码。

**表 21-5：** `svc` 调用的一些寄存器内容

| **操作** | x8 | x0 | x1 | x2 |
| --- | --- | --- | --- | --- |
| `read` | `0x3f` | 文件描述符 | 字符地址 | 字符数量 |
| `write` | `0x40` | 文件描述符 | 字符地址 | 字符数量 |
| `exit` | `0x5d` | 错误代码 | — | — |

为了完整性，以下是导致异常跳转到虚拟机监控器的指令 `hvc` 和跳转到安全监控器的指令 `smc`：

hvc**—虚拟机监控器调用**

`hvc` imm 会导致从异常级别 EL1 跳转到 EL2 的异常。它将 `0x16` 存储在 `esr` 寄存器的第 31 到 26 位，并将 imm（一个 16 位无符号整数）存储在 `esr` 寄存器的第 15 到 0 位。

smc**—安全监控器调用**

`smc` imm 会导致从异常级别 EL1 或 EL2 跳转到 EL3 的异常。它将 `0x17` 存储在 `esr` 寄存器的第 31 到 26 位，并将 imm（一个 16 位无符号整数）存储在 `esr` 寄存器的第 15 到 0 位。

AArch64 架构中的异常处理机制非常复杂，超出了本书的范围。一个好的下一步是阅读 *Learn the Architecture—AArch64 Exception Model*，该文档可以在 *[`developer.arm.com/documentation/102412/0103`](https://developer.arm.com/documentation/102412/0103)* 上找到。

**轮到你了**

21.1 选择一个你用汇编语言编写的程序。在你知道它将被执行的地方添加指令`mrs x0, currentel`。你的程序仍然可以成功汇编和链接，但当你运行该程序时会发生什么？

21.2 修改“你的练习”中的三个函数`write_char`、`write_str`和`read_str`，练习 14.4 位于第 293 页，使它们使用`svc`指令，而不是调用 C 语言的`write`和`read`函数。

21.3 我们在第二十章中的代码清单 20-2 中使用的`mmap`操作的监控调用号是多少？

### **你所学到的**

**特权级别** 操作系统通过标记内存地址和在较低异常级别的 CPU 上运行应用程序，保持对硬件资源的特权。

**异常级别** CPU 以四个异常级别之一运行软件：从最不特权到最特权，依次为 EL0、EL1、EL2 或 EL3。

**异常** 当前执行的代码流中发生中断，导致 CPU 控制权转交给在特权级别（EL1–EL3）运行的软件。

**中断** 其他硬件设备可以中断 CPU 的常规执行周期，并触发异常。

svc 在 AArch64 中触发异常的指令。

**异常处理程序** 操作系统中的一个函数，当发生异常或中断时，CPU 会调用它。

**异常向量表** 一个异常处理程序的数组。

**独立程序** 一个不使用 C 库函数的程序。

这只是对异常和中断的简要概述。其细节较为复杂，需要对你所使用的 CPU 的具体型号有深入了解。

这就是我对计算机组织的介绍。我希望它为你提供了继续深入探索你感兴趣的任何主题所需的工具。
