# 第六章：使用 SQL 进行基本数学和统计

![](img/chapterart.png)

如果你的数据包含我们在第四章中探讨的任何数值数据类型——整数、小数或浮点数——迟早你的分析将包括一些计算。你可能想知道某一列中所有美元值的平均值，或者将两列中的值相加，计算每行的总和。SQL 可以处理这些计算以及更多的内容，从基础数学到高级统计。

本章我将从基础知识开始，逐步介绍数学函数和初步统计。我还会讨论与百分比和百分比变化相关的计算。对于几个练习，我们将使用你在第五章导入的 2019 年美国人口普查估算数据。

## 理解数学运算符和函数

让我们从你在小学学到的基础数学开始（如果你忘记了一些，没关系）。表 6-1 显示了你在计算中最常使用的九个数学运算符。前四个（加法、减法、乘法和除法）是 ANSI SQL 标准的一部分，并且在所有数据库系统中都有实现。其他的则是 PostgreSQL 特有的运算符，尽管大多数其他数据库管理系统也可能有函数或运算符来执行这些操作。例如，模运算符（`%`）不仅在 PostgreSQL 中有效，在 Microsoft SQL Server 和 MySQL 中也能使用。如果你使用的是其他数据库系统，请查阅其文档。

表 6-1：基本数学运算符

| **运算符** | **描述** |
| --- | --- |
| `+` | 加法 |
| `-` | 减法 |
| `*` | 乘法 |
| `/` | 除法（仅返回商，不返回余数） |
| `%` | 模运算（仅返回余数） |
| `^` | 幂运算 |
| `&#124;/` | 平方根 |
| `&#124;&#124;/` | 立方根 |
| `!` | 阶乘 |

我们将通过在简单数字上执行 SQL 查询来逐步了解这些运算符，而不是在表或其他数据库对象上进行操作。你可以将这些语句分别输入到 pgAdmin 查询工具中并逐一执行，或者如果你从[`www.nostarch.com/practical-sql-2nd-edition/`](https://www.nostarch.com/practical-sql-2nd-edition/)复制了本章的代码，可以高亮每一行并执行它。

### 理解数学和数据类型

在执行示例时，请注意每个结果的数据类型，这些类型会列在 pgAdmin 结果网格中每个列名下方。计算返回的类型会根据操作和输入数字的数据类型有所不同。当使用运算符对两个数字进行运算（加法、减法、乘法或除法）时，返回的数据类型遵循以下模式：

+   两个整数返回一个`integer`（整数）。

+   如果操作符两侧或任一侧为`numeric`类型，则返回`numeric`类型。

+   任何包含浮点数的操作都将返回一个`double precision`（双精度）浮点数。

然而，指数、平方根和阶乘函数有所不同。每个函数只接受一个数字，可能在运算符的前面或后面，并且即使输入是整数，返回的也是数字和浮动类型。

有时结果的数据类型会满足你的需求；但在其他情况下，你可能需要使用 `CAST` 来改变数据类型，如第四章中“使用 CAST 将值从一种类型转换为另一种类型”一节所提到的，例如如果你需要将结果传递给需要特定类型的函数。我们在书中进行讲解时会指出这些情况。

### 加法、减法和乘法

我们先从简单的整数加法、减法和乘法开始。列表 6-1 展示了三个例子，每个例子都以 `SELECT` 关键字后跟数学公式的形式。自第三章以来，我们已经使用 `SELECT` 执行它的主要功能：从表中检索数据。但是，在 PostgreSQL、微软 SQL Server、MySQL 以及其他一些数据库管理系统中，你可以省略表名，执行简单的数学和字符串操作，就像我们这里做的那样。为了可读性，我建议在数学运算符前后使用一个空格；虽然使用空格并不是让代码正常工作的必需条件，但这是一个良好的习惯。

```
1 SELECT 2 + 2;
2 SELECT 9 - 1;
3 SELECT 3 * 4;
```

列表 6-1：使用 SQL 进行基本的加法、减法和乘法

这些语句都不是很复杂，所以你不必感到惊讶，当你在查询工具中运行 `SELECT 2 + 2;` 时得到结果 `4`。同样，减法 2 和乘法 3 的例子也会得到你期望的结果：`8` 和 `12`。输出会像任何查询结果一样显示在一列中。但由于我们没有查询表格并指定列，结果会显示在一个 `?column?` 名称下，表示一个未知的列：

```
?column?
--------
       4
```

没关系。我们没有影响任何表中的数据，只是显示一个结果。如果你想显示列名，可以提供一个别名，例如 `SELECT 3 * 4 AS result;`。

### 执行除法和求余

使用 SQL 进行除法会稍微复杂一些，因为整数运算和小数运算之间的区别。再加上 *取余*，这是一个在除法操作中只返回 *余数* 的运算符，结果可能会让人感到困惑。所以，为了更清楚地展示，列表 6-2 展示了四个例子。

```
1 SELECT 11 / 6;
2 SELECT 11 % 6;
3 SELECT 11.0 / 6;
4 SELECT CAST(11 AS numeric(3,1)) / 6;
```

列表 6-2：使用 SQL 进行整数和小数除法

`/` 运算符 1 将整数 `11` 除以另一个整数 `6`。如果你在脑海中做这个计算，你知道答案是 `1`，余数为 `5`。然而，运行这个查询的结果是 `1`，这是 SQL 处理一个整数除以另一个整数的方式——只报告整数*商*，不显示余数。如果你想获取*余数*作为整数，你必须使用模运算符 `%` 执行相同的计算，如 2 所示。该语句仅返回余数，在此案例中为 `5`。今天没有单一操作可以同时提供商和余数作为整数，尽管有心的开发者将来可能会添加此功能。

模运算不仅仅用于获取余数：你还可以将它作为测试条件。例如，要检查一个数是否为偶数，你可以使用 `% 2` 运算进行测试。如果结果为 `0` 且没有余数，则该数为偶数。

有两种方式可以将两个数字相除并返回 `numeric` 类型的结果。首先，如果其中一个或两个数字是 `numeric`，结果默认会以 `numeric` 表示。这就是当我将 `11.0` 除以 `6` 3 时的情况。执行该查询，结果是 `1.83333`。显示的小数位数可能会根据你的 PostgreSQL 和系统设置有所不同。

其次，如果你正在处理仅以整数形式存储的数据，并且需要强制进行小数除法，你可以使用 `CAST` 将其中一个整数转换为 `numeric` 类型 4。执行该操作后，同样会返回 `1.83333`。

### 使用指数、根和阶乘

除了基础操作外，PostgreSQL 风格的 SQL 还提供了运算符和函数来计算平方、立方，或将基数提升为指数，还可以计算根和阶乘。清单 6-3 展示了这些操作的实际应用。

```
1 SELECT 3 ^ 4;
2 SELECT |/ 10;
SELECT sqrt(10);
3 SELECT ||/ 10;
4 SELECT factorial(4);
SELECT 4 !;
```

清单 6-3：使用 SQL 进行指数、根和阶乘运算

指数运算符 (`^`) 允许你将给定的基数提升到一个指数，如 1 中所示，其中 `3 ^ 4`（口语中我们会称其为三的四次方）返回 `81`。

你可以通过两种方式求一个数的平方根：使用 `|/` 运算符 2 或 `sqrt(``n``)` 函数。对于立方根，使用 `||/` 运算符 3。这两者都是*前缀运算符*，因为它们出现在单一值之前。

要找到一个数字的*阶乘*，你可以使用`factorial(``n``)`函数或`!`运算符。`!`运算符仅在 PostgreSQL 13 及以前的版本中可用，是一个*后缀运算符*，它位于单个值后面。在数学中，你将在许多地方使用阶乘，最常见的应用是确定一组物品有多少种排列方式。比如你有四张照片。你可以将它们在墙上排列成多少种方式呢？为了找到答案，你需要计算阶乘，从物品数量开始，并将其与所有较小的正整数相乘。因此，`factorial(4)`等价于 4 × 3 × 2 × 1\。这就是四张照片的 24 种排列方式。难怪有时候装饰需要这么长时间！

再次提醒，这些运算符是 PostgreSQL 特有的；它们不是 SQL 标准的一部分。如果你使用的是其他数据库应用程序，请查阅其文档，了解如何实现这些运算。

### 注意运算顺序

你可能还记得早期的数学课程中关于数学表达式的运算顺序，或*运算符优先级*。SQL 首先执行哪些计算呢？毫不奇怪，SQL 遵循已建立的数学标准。到目前为止讨论的 PostgreSQL 运算符的优先顺序如下：

1.  指数与根号

1.  乘法、除法、模运算

1.  加法与减法

根据这些规则，如果你想按照不同的顺序计算操作，你需要将操作括在圆括号内。例如，以下两个表达式会产生不同的结果：

```
SELECT 7 + 8 * 9;
SELECT (7 + 8) * 9;
```

第一个表达式返回`79`，因为乘法运算优先执行，先于加法。第二个返回`135`，因为圆括号强制加法先执行。

这是一个使用指数的第二个例子：

```
SELECT 3 ^ 3 - 1;
SELECT 3 ^ (3 - 1);
```

指数运算优先于减法运算，因此在没有圆括号的情况下，整个表达式会从左到右进行求值，找到 3 的 3 次方的运算会最先发生。然后减去 1，得到`26`。在第二个例子中，圆括号强制减法先进行，因此运算结果为`9`，即 3 的 2 次方。

记住运算符优先级，避免稍后需要纠正分析结果！

## 跨人口普查表列进行数学运算

让我们尝试在真实数据上使用最常用的 SQL 数学运算符，通过挖掘你在第五章导入的 2019 年美国人口普查估算表`us_counties_pop_est_2019`。我们不会在查询中使用数字，而是使用包含数字的列名。当我们执行查询时，计算将发生在表中的每一行。

为了刷新你的记忆，运行列表 6-4 中的脚本。它应该返回 3142 行，显示每个美国县的名称和所在州，以及 2019 年人口变化的组成部分：出生、死亡以及国际和国内迁移。

```
SELECT county_name AS1 county,
       state_name AS state,
       pop_est_2019 AS pop,
       births_2019 AS births,
       deaths_2019 AS deaths,
       international_migr_2019 AS int_migr,
       domestic_migr_2019 AS dom_migr,
       residual_2019 AS residual
FROM us_counties_pop_est_2019;
```

清单 6-4：选择带别名的人口普查估计列

这个查询不会返回表中的所有列，而只是与人口估计相关的数据列。此外，我使用`AS`关键字 1 为每个列在结果集中提供了一个较短的*别名*。因为所有数据都来自 2019 年，我去掉了结果列名称中的年份，以减少 pgAdmin 输出中的滚动。这是一个任意的决定，你可以根据需要进行调整。

### 列的加法和减法

现在，让我们尝试使用两列进行简单计算。清单 6-5 将每个县的死亡人数减去出生人数，这是普查中称为自然增加的指标。让我们看看这能展示什么。

```
SELECT county_name AS county,
       state_name AS state,
       births_2019 AS births,
       deaths_2019 AS deaths,
       1 births_2019 - deaths_2019 AS natural_increase
FROM us_counties_pop_est_2019
ORDER BY state_name, county_name;
```

清单 6-5：在*us_counties_pop_est_2019*中减去两列

在`SELECT`语句中提供`births_2019 - deaths_2019` 1 作为其中一列来完成计算。同样，我使用`AS`关键字为该列提供一个可读的别名。如果不提供别名，PostgreSQL 将使用`?column?`标签，这显然不太有用。

运行查询以查看结果。前几行应该类似于以下输出：

```
county           state     births    deaths   natural_increase
--------------   -------   ------    ------   ----------------
Autauga County   Alabama     624       541                 83
Baldwin County   Alabama    2304      2326                -22
Barbour County   Alabama     256       312                -56
Bibb County      Alabama     240       252                -12
```

使用计算器或纸笔快速检查，确认`natural_increase`列等于你减去的两列之间的差值。太棒了！当你浏览输出结果时，请注意一些县的出生人数超过死亡人数，而其他一些县则相反。通常，居民年龄较轻的县出生人数会超过死亡人数；而那些居民年龄较大的地方——比如农村地区和退休热门地区——往往死亡人数会超过出生人数。

现在，让我们在此基础上进行测试，验证我们是否正确导入了列。2019 年的人口估计应等于 2018 年估计加上出生、死亡、迁移和剩余因子相关的列。清单 6-6 中的代码应该显示这一点。

```
SELECT county_name AS county,
       state_name AS state,
       1 pop_est_2019 AS pop,
       2 pop_est_2018 + births_2019 - deaths_2019 +
           international_migr_2019 + domestic_migr_2019 +
           residual_2019 AS components_total,
       3 pop_est_2019 - (pop_est_2018 + births_2019 - deaths_2019 +
           international_migr_2019 + domestic_migr_2019 +
           residual_2019) AS difference
FROM us_counties_pop_est_2019
4 ORDER BY difference DESC;
```

清单 6-6：检查人口普查数据总数

该查询包括 2019 年的人口估计 1，后面是一个计算，将组成部分加到 2018 年的人口估计中作为`component_total` 2。2018 年的估计加上组成部分应该等于 2019 年的估计。为了避免手动检查，我们还添加了一列，将组成部分总和从 2019 年的估计中减去 3。该列名为`difference`，如果所有数据都在正确位置，则每一行应包含零。为了避免查看所有 3,142 行，我们在命名列上添加了`ORDER BY`子句 4。显示差异的任何行应该出现在查询结果的顶部或底部。

执行查询；前几行应该显示以下结果：

```
 county       state    pop    components_total  difference
--------------  -------  ------  ----------------  ----------
Autauga County  Alabama   55869             55869           0
Baldwin County  Alabama  223234            223234           0
Barbour County  Alabama   24686             24686           0
```

通过`difference`列显示零，我们可以确信我们的导入数据是干净的。每当我遇到或导入新的数据集时，我喜欢进行像这样的简单测试。它们帮助我更好地理解数据，并在深入分析之前解决潜在的问题。

### 查找整体百分比

发现数据集中各个项目之间差异的一种方法是计算某个数据点所代表的整个数据集的百分比。然后，你可以通过对比数据集中的所有项目的百分比，获取有意义的洞察——有时甚至是惊喜。

要计算整体的百分比，需将相关数字除以总数。例如，如果你有一个 12 个苹果的篮子，且用了其中 9 个做了一个派，那么就是 9 / 12 或 0.75——通常表示为 75%。

我们将尝试使用示例 6-7 中的代码，对普查人口估计数据进行操作，使用表示每个县地理特征大小的两列数据。`area_land`和`area_water`列显示了一个县的陆地和水域面积（单位为平方米）。使用该代码，我们可以计算出每个县中由水域组成的面积百分比。

```
SELECT county_name AS county,
       state_name AS state,
       1 area_water::numeric / (area_land + area_water) * 100 AS pct_water
FROM us_counties_pop_est_2019
ORDER BY pct_water DESC;
```

示例 6-7：计算一个县的面积中水域的百分比

该查询的关键部分是将`area_water`除以`area_land`和`area_water`的总和，这两者代表了该县的总面积 1。

如果我们使用原始整数类型的数据，我们将无法得到所需的分数结果：每一行将显示 0 的结果，即商。相反，我们通过将其中一个整数强制转换为数字类型来进行十进制除法。这里，为了简洁起见，我们在第一次引用`area_water`时使用了 PostgreSQL 特有的双冒号符号，但你也可以使用 ANSI SQL 标准中的`CAST`函数，具体内容见第四章。最后，我们将结果乘以 100，以将其呈现为百分数——这种方式是大多数人理解百分比的方式。

按照从高到低的百分比排序，输出的结果如下：

```
 county           state            pct_water
------------------  -------------  -----------------------
Keweenaw County     Michigan       90.94723747453215452900
Leelanau County     Michigan       86.28858968116583102500
Nantucket County    Massachusetts  84.79692499185512352300
St. Bernard Parish  Louisiana      82.48371149202893908400
Alger County        Michigan       81.87221940647501072300
```

如果你查看维基百科上关于基维诺县（Keweenaw County）的条目，你会发现为什么该县的总面积中超过 90%是水域：其陆地面积包括了苏必利尔湖中的一个岛屿，而湖水也被包括在普查中报告的总面积内。将这一点加入你的趣闻收藏吧！

### 跟踪百分比变化

数据分析中的另一个关键指标是百分比变化：一个数字比另一个数字大或小多少？百分比变化计算通常用于分析随时间变化的数据，特别适用于比较相似项目之间的变化。

一些示例包括以下内容：

+   每个汽车制造商的年度汽车销售变化

+   每个营销公司所拥有的每个邮件列表的月度订阅变化

+   全国各学校的年注册人数增减

计算百分比变化的公式可以这样表达：

(*新数值* – *旧数值*) / *旧数值*

所以，如果你经营一个柠檬水摊位，今天卖出了 73 杯柠檬水，昨天卖出了 59 杯，你可以这样计算日常百分比变化：

(73 – 59) / 59 = .237 = 23.7%

让我们尝试使用一小组与假设的地方政府部门开支相关的测试数据。清单 6-8 计算了哪些部门的百分比增减最大。

```
1 CREATE TABLE percent_change (
    department text,
    spend_2019 numeric(10,2),
    spend_2022 numeric(10,2)
);

2 INSERT INTO percent_change
VALUES
    ('Assessor', 178556, 179500),
    ('Building', 250000, 289000),
    ('Clerk', 451980, 650000),
    ('Library', 87777, 90001),
    ('Parks', 250000, 223000),
    ('Water', 199000, 195000);

SELECT department,
       spend_2019,
       spend_2022,
     3 round( (spend_2022 - spend_2019) /
                    spend_2019 * 100, 1) AS pct_change
FROM percent_change;
```

清单 6-8：计算百分比变化

我们创建了一个名为`percent_change`的小表，并插入了六行关于 2019 年和 2022 年部门开支的数据。百分比变化公式是：`spend_2022`减去`spend_2019`，然后除以`spend_2019`。我们乘以 100 以将结果表示为百分之一。

为了简化输出，这次我添加了`round()`函数来去掉除一位小数外的所有小数位。该函数需要两个参数：要四舍五入的列或表达式，以及显示的小数位数。由于这两个数字都是`numeric`类型，因此结果也将是`numeric`类型。

该脚本产生了以下结果：

```
department  spend_2019  spend_2022  pct_change
----------  ----------  ----------  ----------
Assessor     178556.00   179500.00         0.5
Building     250000.00   289000.00        15.6
Clerk        451980.00   650000.00        43.8
Library       87777.00    90001.00         2.5
Parks        250000.00   223000.00       -10.8
Water        199000.00   195000.00        -2.0
```

现在，只需找出为什么市政府的书记部门开支超过了其他部门。

## 使用聚合函数计算平均值和总和

到目前为止，我们已经对表格中每行的列进行了数学运算。SQL 还允许你使用*聚合函数*计算同一列中值的结果。你可以在[`www.postgresql.org/docs/current/functions-aggregate.html`](https://www.postgresql.org/docs/current/functions-aggregate.html)查看 PostgreSQL 聚合函数的完整列表，这些函数从多个输入中计算出单一结果。在数据分析中，最常用的两个聚合函数是`avg()`和`sum()`。

返回到`us_counties_pop_est_2019`人口普查表，计算所有县的总人口以及所有县的平均人口是合理的。使用`avg()`和`sum()`函数对`pop_est_2019`列（2019 年人口估算）进行操作，可以轻松完成，如清单 6-9 所示。我们再次使用`round()`函数去掉平均计算中的小数点后的数字。

```
SELECT sum(pop_est_2019) AS county_sum,
       round(avg(pop_est_2019), 0) AS county_average
FROM us_counties_pop_est_2019;
```

清单 6-9：使用`sum()`和`avg()`聚合函数

这个计算产生了以下结果：

```
county_sum  county_average
----------  --------------
 328239523          104468
```

美国所有县的 2019 年估计人口总和大约为 3.282 亿，县人口估算的平均值为 104,468。

## 寻找中位数

一组数字中的*中位数*值是与平均数一样重要的指标，甚至可能更重要。以下是中位数与平均数的区别：

1.  平均值 所有值的总和除以值的个数

1.  中位数 排序后的数值中的“中间”值

中位数在数据分析中很重要，因为它减少了异常值的影响。考虑这个例子：假设六个孩子，年龄分别为 10、11、10、9、13 和 12，去进行一次实地考察。将年龄相加后除以六得到平均年龄很容易：

(10 + 11 + 10 + 9 + 13 + 12) / 6 = 10.8

因为这些年龄值分布在一个较小的范围内，所以 10.8 的平均数很好地代表了这个组。但是当数据值集中在分布的一端，或者组中有异常值时，平均数的帮助就会减少。

例如，假设一位年长的陪同人员加入了实地考察。年龄为 10、11、10、9、13、12 和 46，平均年龄大幅增加：

(10 + 11 + 10 + 9 + 13 + 12 + 46) / 7 = 15.9

现在，平均数并不能很好地代表这个组，因为异常值会让它产生偏差，使得它成为一个不可靠的指标。

在这种情况下，最好找出中位数，它是一个有序数值列表中的中间点——也就是数据中一半的值大于它，另一半的值小于它。以这次实地考察为例，我们将参加者的年龄按从低到高的顺序排列：

9, 10, 10, 11, 12, 13, 46

中位数（median）是 11。对于这个组来说，11 的中位数比 15.9 的平均数更能代表典型年龄。

如果数据集的数值为偶数，则需要取中间两个数值的平均数来找出中位数。我们再加入一位学生（年龄 12）到实地考察中：

9, 10, 10, 11, 12, 12, 13, 46

现在，两个中间值是 11 和 12。为了找出中位数，我们取它们的平均值：11.5。

中位数在财经新闻中经常被报道。关于房价的报告经常使用中位数，因为一个区域中少数几栋奢华别墅的销售可能会使得平均数变得无用。体育运动员的薪水也是一样：一两个超级明星可能会扭曲一个队伍的平均薪资。

一个好的测试是计算一组数值的平均数和中位数。如果它们接近，那么这组数据可能呈正态分布（即熟悉的钟形曲线），此时平均数是有用的。如果它们相差较远，那么这些数值不是正态分布的，中位数则是更好的代表。

### 使用百分位数函数查找中位数

PostgreSQL（与大多数关系型数据库一样）没有内建的`median()`函数，如同你在 Excel 或其他电子表格程序中会找到的那样。它也不包含在 ANSI SQL 标准中。我们可以使用 SQL 中的*百分位数*函数来找出中位数，并使用*分位数*或*切分点*将一组数字划分为相等的大小。百分位数函数是 ANSI SQL 标准的一部分。

在统计学中，百分位数表示在有序数据集中，某个百分比的数据位于该值以下。例如，医生可能会告诉你，你的身高位于你所在年龄组的第 60 百分位。这意味着 60%的人比你矮。

中位数相当于第 50 百分位——同样，一半的数值低于它，另一半高于它。百分位数函数有两个版本——`percentile_cont(``n``)`和`percentile_disc(``n``)`。这两个函数都是 ANSI SQL 标准的一部分，并且在 PostgreSQL、Microsoft SQL Server 和其他数据库中都有实现。

`percentile_cont(``n``)`函数计算百分位数作为*连续*值。也就是说，结果不必是数据集中的一个数字，而可以是介于两个数字之间的一个小数值。这遵循了在偶数个值中计算中位数的方法，即中位数是两个中间值的平均值。`percentile_disc(``n``)`函数则只返回*离散*值，这意味着结果将四舍五入为数据集中的一个数字。

在列表 6-10 中，我们制作了一个包含六个数字的测试表，并计算了百分位数。

```
CREATE TABLE percentile_test (
    numbers integer
);

INSERT INTO percentile_test (numbers) VALUES
    (1), (2), (3), (4), (5), (6);

SELECT
  1 percentile_cont(.5)
    WITHIN GROUP (ORDER BY numbers),
  2 percentile_disc(.5)
    WITHIN GROUP (ORDER BY numbers)
FROM percentile_test;
```

列表 6-10: 测试 SQL 百分位数函数

在连续型 1 和离散型 2 百分位数函数中，我们输入`.5`表示第 50 个百分位数，相当于中位数。运行代码后返回如下结果：

```
percentile_cont     percentile_disc
---------------     ---------------
            3.5                   3
```

`percentile_cont()`函数返回了我们预期的中位数：`3.5`。但由于`percentile_disc()`计算的是离散值，它报告了`3`，即前 50%数据中的最后一个值。因为计算中位数的常用方法是在偶数个数据集中取两个中间值的平均值，因此使用`percentile_cont(.5)`来找到中位数。

### 使用人口普查数据查找中位数和百分位数

我们的人口普查数据可以展示中位数如何与平均数讲述不同的故事。列表 6-11 在`sum()`和`avg()`聚合函数旁边，增加了`percentile_cont()`，用以找出所有县区的总和、平均值和中位数人口。

```
SELECT sum(pop_est_2019) AS county_sum,
       round(avg(pop_est_2019), 0) AS county_average,
       percentile_cont(.5)
       WITHIN GROUP (ORDER BY pop_est_2019) AS county_median
FROM us_counties_pop_est_2019;
```

列表 6-11: 使用`sum()`、`avg()`和`percentile_cont()`聚合函数

你的结果应该等于以下内容：

```
county_sum  county_avg  county_median
----------  ----------  -------------
 328239523      104468          25726
```

中位数和平均值相差很大，这表明平均值可能会误导人们。根据 2019 年的估计，美国一半的县区人口少于 25,726 人，另一半则多于此数。如果你在关于美国人口统计的演讲中告诉观众“美国的平均县区人口是 104,468 人”，他们将会得到一个扭曲的现实图像。2019 年，估计有超过 40 个县区人口超过一百万，洛杉矶县的县区人口超过 1000 万，这将平均值拉高了。

### 使用百分位数函数查找其他分位数

你还可以将数据划分成更小的相等组进行分析。最常见的划分是*四分位数*（四个相等的组）、*五分位数*（五个组）和*十分位数*（10 个组）。要找到任何单独的值，只需将其代入百分位数函数即可。要找到标记第一个四分位数或最低 25%数据的值，你可以使用`.25`：

```
percentile_cont(.25)
```

然而，如果你想生成多个切点，逐个输入值会非常繁琐。你可以通过*数组*，即一个项目列表，将值传递给`percentile_cont()`。

列表 6-12 展示了如何一次性计算四个四分位数。

```
SELECT percentile_cont(1ARRAY[.25,.5,.75])
       WITHIN GROUP (ORDER BY pop_est_2019) AS quartiles
FROM us_counties_pop_est_2019;
```

列表 6-12: 将值数组传递给`percentile_cont()`

在这个例子中，我们通过将值括在*数组构造器* 1 `ARRAY[]` 中来创建分割点。数组构造器是一个表达式，用于从括号内包含的元素构建一个数组。在括号内，我们提供以逗号分隔的值，表示切分的三个点，从而创建四个四分位数。运行查询后，你应该能看到以下输出：

```
quartiles
------------------------
{10902.5,25726,68072.75}
```

因为我们传入了一个数组，PostgreSQL 返回一个数组，结果中用大括号表示。每个四分位数之间用逗号分隔。第一个四分位数是 10,902.5，这意味着 25% 的县份人口等于或低于此值。第二个四分位数与中位数相同：25,726。第三个四分位数是 68,072.75，这意味着最大的 25% 的县份人口至少为此值。（在报告这些数据时，我们当然会四舍五入，因为讨论人口时我们不会用小数。）

数组在 ANSI SQL 标准中有定义，我们在这里的使用只是 PostgreSQL 中处理数组的几种方法之一。例如，你可以将表的某一列定义为特定数据类型的数组。如果你想将多个值存储在单一的数据库列中（例如博客文章的标签集合），而不是将它们存储在一个单独的表中，这样做就很有用。有关声明、查询和修改数组的示例，请参阅 PostgreSQL 文档：[`www.postgresql.org/docs/current/arrays.html`](https://www.postgresql.org/docs/current/arrays.html)。

数组还带有一系列函数（PostgreSQL 的相关函数见：[`www.postgresql.org/docs/current/functions-array.html`](https://www.postgresql.org/docs/current/functions-array.html)），这些函数允许你执行诸如添加或移除值、计数元素等任务。一个用于处理 列表 6-12 返回结果的便捷函数是 `unnest()`，它通过将数组转换为行来使数组更易于阅读。列表 6-13 显示了相关代码。

```
SELECT unnest(
            percentile_cont(ARRAY[.25,.5,.75])
            WITHIN GROUP (ORDER BY pop_est_2019)
            ) AS quartiles
FROM us_counties_pop_est_2019;
```

列表 6-13：使用 `unnest()` 将数组转换为行

现在输出应该以行的形式展示：

```
quartiles
---------
  10902.5
    25726
 68072.75
```

如果我们在计算十分位数，从结果数组中提取并将它们以行的形式展示将特别有帮助。

## 查找众数

我们可以使用 PostgreSQL 的 `mode()` 函数来查找*众数*，即出现次数最多的值。该函数不是标准 SQL 的一部分，其语法类似于百分位数函数。列表 6-14 展示了对 `births_2019`（显示出生人数的列）进行 `mode()` 计算的示例。

```
SELECT mode() WITHIN GROUP (ORDER BY births_2019)
FROM us_counties_pop_est_2019;
```

列表 6-14：使用 `mode()` 查找最频繁的值

结果是 `86`，这是 16 个县份共同拥有的出生人数。

## 总结

处理数字是从数据中获取意义的关键步骤，通过本章中涉及的数学技能，你已经准备好使用 SQL 处理数值分析的基础知识。书中的后续章节将介绍更深层次的统计概念，包括回归分析和相关性，但此时你已经掌握了求和、平均数和分位数的基础知识。你还学会了中位数如何比平均数更公平地评估一组值。仅此一点就能帮助你避免得出不准确的结论。

在下一章中，我将向你介绍将两个或更多表格中的数据结合起来的强大功能，以增加你进行数据分析的选择。我们将使用你已经加载到`analysis`数据库中的 2019 年美国人口普查数据，并探索其他数据集。
