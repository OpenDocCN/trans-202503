# 第七章：宏

![](img/chapterart.png)

宏本质上是一个让编译器为你编写代码的工具。你给编译器提供一个生成代码的公式，并且根据一些输入参数，编译器会将每次调用宏的地方替换为公式运行后的结果。你可以将宏看作是自动代码替换，规则由你定义。

Rust 的宏有许多不同的形态和大小，旨在使实现各种代码生成变得简单。两种主要类型是*声明式*宏和*程序化*宏，我们将在本章中探讨这两种类型。我们还将探讨一些宏如何在日常编码中派上用场，以及更高级使用时可能出现的一些陷阱。

来自 C 语言及其衍生语言的程序员可能已经习惯了 C 和 C++的“邪恶领域”，在这里你可以使用`#define`将每个`true`改成`false`，或者移除所有`else`关键字。如果你有这种经验，你需要将宏与做“坏事”的感觉分开。Rust 中的宏远不是 C 语言宏的“西部荒野”。它们遵循（大部分）良好定义的规则，并且具有相当的抗滥用能力。

## 声明式宏

声明式宏是使用`macro_rules!`语法定义的宏，它允许你方便地定义类似函数的宏，而不需要为此编写专门的 crate（就像你做程序化宏时那样）。一旦定义了声明式宏，你可以通过宏的名称后跟感叹号来调用它。我喜欢把这种宏看作是编译器辅助的搜索和替换：它为许多常规的、结构化良好的转换任务提供了解决方案，并且能够消除重复的模板代码。在你至今为止使用 Rust 的经验中，你认定的大多数宏可能就是声明式宏。需要注意的是，并非所有类似函数的宏都是声明式宏；`macro_rules!`本身就是一个例子，`format_args!`也是。`!`后缀仅仅是告诉编译器宏调用将在编译时被替换成不同的源代码。

为什么声明式宏被称为声明式宏，可能一开始并不显而易见。毕竟，你不是在程序中“声明”所有东西吗？在这里，*声明式*指的是你不需要说明宏的输入如何转换成输出，只是声明当输入是 B 时，你希望输出是 A。你声明它应该是这样的，然后编译器会处理所有需要的解析和重排工作，把你的声明变成现实。这使得声明式宏简洁而富有表现力，尽管它也有使得宏显得相当晦涩的倾向，因为你只有一个有限的语言来表达你的声明。

### 何时使用宏

声明式宏主要在你发现自己反复写相同代码时派上用场，这时你可能希望不再这样做。它们最适合做一些比较机械的替换——如果你打算做一些复杂的代码转换或大量的代码生成，过程宏可能更合适。

我最常使用声明式宏的场景是当我发现自己编写重复且结构相似的代码时，比如在测试和 trait 实现中。对于测试，我通常希望多次运行相同的测试，但使用稍微不同的配置。我可能会有像清单 7-1 中展示的那种代码。

```
fn test_inner<T>(init: T, frobnify: bool) { ... }
#[test]
fn test_1u8_frobnified() {
  test_inner(1u8, true);
}
// ...
#[test]
fn test_1i128_not_frobnified() {
  test_inner(1i128, false);
}
```

清单 7-1：重复的测试代码

虽然这样做是可行的，但它过于冗长、重复，而且容易出错。使用宏，我们可以做得更好，正如在清单 7-2 中展示的那样。

```
macro_rules! test_battery {
  ($($t:ty as $name:ident),*)) => {
    $(
      mod $name {
        #[test]
        fn frobnified() { test_inner::<$t>(1, true) }
        #[test]
        fn unfrobnified() { test_inner::<$t>(1, false) }
      }
    )*
  }
}
test_battery! {
  u8 as u8_tests,
  // ...
  i128 as i128_tests
);
```

清单 7-2：让宏为你重复执行

这个宏将每个以逗号分隔的指令展开为一个单独的模块，每个模块包含两个测试，一个使用`test_inner`并传入`true`，另一个传入`false`。虽然宏的定义并不简单，但它使得添加更多的测试变得更加容易。每个类型都是`test_battery!`调用中的一行，宏将自动生成针对`true`和`false`参数的测试。我们还可以让它为`init`的不同值生成测试。现在，我们大大减少了忘记测试某个特定配置的可能性！

trait 实现的情况类似。如果你定义了自己的 trait，通常你会希望为标准库中的多个类型实现这个 trait，即使这些实现很简单。假设你发明了`Clone` trait，并希望为标准库中所有`Copy`类型实现它。你可以像清单 7-3 中的宏一样，使用宏而不是手动为每个类型编写实现。

```
macro_rules! clone_from_copy {
  ($($t:ty),*) => {
    $(impl Clone for $t {
      fn clone(&self) -> Self { *self }
    })*
  }
}
clone_from_copy![bool, f32, f64, u8, i8, /* ... */];
```

清单 7-3：使用宏一次性为多个相似类型实现一个 trait

在这里，我们为每个提供的类型生成一个`Clone`的实现，其主体仅使用`*`从`&self`中`copy`。你可能会想，为什么我们不为`T: Copy`类型添加一个通用的`Clone`实现呢？我们可以这么做，但一个主要的原因是，这样做会迫使其他 crate 中的类型也使用相同的`Clone`实现，尤其是那些恰好是`Copy`的类型。一个名为*特化*的实验性编译器功能可能提供一个解决方法，但在写这篇文章时，该功能的稳定化还有一段时间。因此，目前来说，我们最好具体列举类型。这个模式不仅适用于简单的转发实现：例如，你可以轻松修改清单 7-3 中的代码，为所有整数类型实现一个`AddOne` trait！

### 它们是如何工作的

每种编程语言都有一个*语法*，它规定了组成源代码的各个字符如何转换成*符号*。符号是语言的最低级构建块，如数字、标点符号、字符串和字符字面量、标识符等；在这一层级，语言关键字和变量名之间没有区别。例如，文本`(value + 4)`在类似 Rust 的语法中会被表示为五个符号序列`(`、`value`、`+`、`4`、`)`。将文本转换成符号的过程还为编译器的其余部分与解析文本的复杂低级细节之间提供了一层抽象。例如，在符号表示中没有空白字符的概念，`/*"foo"*/`和`"/*foo*/"`有不同的表示（前者不是符号，后者是一个字符串字面量符号，内容为`/*foo*/`）。

一旦源代码被转换成符号序列，编译器会遍历该序列并为符号分配语法意义。例如，`()`定界符的符号表示一个分组，`!`符号表示宏调用，依此类推。这就是*解析*过程，它最终生成一个描述源代码结构的抽象语法树（AST）。举个例子，考虑表达式`let x = || 4`，它由符号序列`let`（关键字）、`x`（标识符）、`=`（标点符号）、两个`|`（标点符号）和`4`（字面量）组成。当编译器将其转换成语法树时，它表示为一个*语句*，其中*模式*是*标识符*`x`，其右侧的*表达式*是一个*闭包*，该闭包有一个空的*参数列表*，并且其主体是*整数字面量*`4`的*字面量表达式*。请注意，语法树表示比符号序列更加丰富，因为它为符号组合分配了语法意义，这符合语言的语法规则。

Rust 宏决定了给定符号序列转换成的语法树——当编译器在解析过程中遇到宏调用时，它必须先求值宏，以确定替换的符号，这些符号最终将成为宏调用的语法树。然而，此时编译器仍然在解析符号，可能还没有准备好求值宏，因为它所做的仅仅是解析宏定义的符号。因此，编译器会推迟解析宏调用的定界符中的内容，并记住输入的符号序列。当编译器准备好评估指定的宏时，它会在符号序列上求值宏，解析它生成的符号，并将结果语法树替换到宏调用的位置。

从技术上讲，编译器确实会为宏的输入做一些解析。具体来说，它会解析出基本的内容，如字符串字面量和分隔组，从而生成一系列令牌*树*，而不仅仅是令牌。例如，代码 `x - (a.b + 4)` 会解析成三个令牌树的序列。第一个令牌树是单个令牌，它是标识符 `x`；第二个是单个令牌，它是标点符号 `-`；第三个是一个组（使用圆括号作为分隔符），它本身包含五个令牌树的序列：`a`（标识符）、`.`（标点符号）、`b`（另一个标识符）、`+`（另一个标点符号）、`4`（字面量）。这意味着传递给宏的输入不一定是有效的 Rust，但必须是 Rust 编译器可以解析的代码。例如，你不能在 Rust 中写出 `for <- x`，除非它在宏调用中，但如果宏生成有效语法，则可以这么做。另一方面，你不能将 `for {` 传递给宏，因为它没有闭合的括号。

声明式宏始终生成有效的 Rust 输出。你不能让一个宏生成，比如说，一个函数调用的一半，或者一个没有后续代码块的`if`。声明式宏必须生成一个表达式（基本上是任何你可以赋值给变量的内容），一个语句，如`let x = 1;`，一个项，如 trait 定义或 `impl` 块，一个类型，或一个 `match` 模式。这使得 Rust 宏不容易被滥用：你根本不能写出一个生成无效 Rust 代码的声明式宏，因为宏定义本身无法编译！

这就是声明式宏的高级概述——当编译器遇到宏调用时，它会将调用分隔符中的令牌传递给宏，解析结果令牌流，并用生成的 AST 替换宏调用。

### 如何编写声明式宏

对声明式宏支持的所有语法的详尽解释超出了本书的范围。然而，我们会涵盖一些基础知识，因为有些细节值得指出。

声明式宏由两个主要部分组成：*匹配器* 和 *转录器*。一个宏可以有多个匹配器，每个匹配器都有一个关联的转录器。当编译器遇到宏调用时，它会从第一个到最后一个遍历宏的匹配器，当找到一个匹配调用中令牌的匹配器时，它会通过遍历相应转录器的令牌来替换宏调用。列表 7-4 展示了声明式宏规则的不同部分是如何配合工作的。

```
macro_rules! /* macro name */ {
  (/* 1st matcher */) => { /* 1st transcriber */ };
  (/* 2nd matcher */) => { /* 2nd transcriber */ };
}
```

列表 7-4：声明式宏定义组件

#### 匹配器

你可以将宏匹配器视为一个符号树，编译器尝试以预定义的方式扭曲和弯曲它，以匹配它在调用处给定的输入符号树。举个例子，考虑一个带有匹配器`$a:ident + $b:expr`的宏。这个匹配器会匹配任何标识符（`:ident`）后跟一个加号，再后跟任何 Rust 表达式（`:expr`）。如果宏被调用时传入`x + 3 * 5`，编译器会发现，匹配器会匹配，当它将`$a = x`和`$b = 3 * 5`时，即使`*`没有出现在匹配器中，编译器仍然意识到`3 * 5`是一个有效的表达式，因此可以用`$b:expr`进行匹配，因为`$b:expr`接受任何表达式（`:`expr`部分）。

匹配器可能会变得相当复杂，但它们具有巨大的表达能力，就像正则表达式一样。举个不那么复杂的例子，这个匹配器接受一个或多个（`+`）由逗号分隔（`),`）的键/值对，格式为`key => value`：

```
$($key:expr => $value:expr),+
```

更重要的是，调用带有此匹配器的宏的代码可以为键或值提供任意复杂的表达式——匹配器的魔力将确保键和值表达式被适当地分割。

宏规则支持多种*片段类型*；你已经见过用于标识符的`:ident`和用于表达式的`:expr`，但还有用于类型的`:ty`，甚至还有适用于任何单个符号树的`:tt`！你可以在 Rust 语言参考的第三章中找到完整的片段类型列表（[`doc.rust-lang.org/reference/macros-by-example.html`](https://doc.rust-lang.org/reference/macros-by-example.html)）。这些片段类型，加上用于重复匹配模式的机制（`$()`），使你能够匹配大多数简单的代码模式。不过，如果你发现很难用匹配器表达你想要的模式，可能想尝试使用过程宏，在那里你不需要遵循`macro_rules!`所要求的严格语法。我们将在本章稍后更详细地讨论这些内容。

#### 转录器

一旦编译器匹配了声明性宏匹配器，它会使用匹配器的相关转录器生成代码。宏匹配器定义的变量被称为*元变量*，编译器会在转录器中替换每个元变量的任何出现（如上一节中的`$key`）为匹配该部分匹配器的输入。如果匹配器中有重复（例如，那个示例中的`$(),+`），你可以在转录器中使用相同的语法，它会对输入中的每个匹配重复一次，每次扩展都持有该迭代的适当元变量替换。例如，对于`$key`和`$value`匹配器，我们可以编写以下转录器，为每个匹配到的`$key`/`$value`对生成一次`insert`调用，将其插入到某个映射中：

```
$(map.insert($key, $value);)+
```

请注意，这里我们希望每次重复时都有一个分号，而不仅仅是用来分隔重复，因此我们将分号放在重复的括号内。

#### 卫生

你可能听说过 Rust 宏是*卫生的*，也许你认为卫生性使得它们更安全或更容易使用，但可能并不完全理解这意味着什么。当我们说 Rust 宏是卫生性的，我们的意思是声明式宏（通常）不能影响那些没有显式传递给它的变量。一个简单的例子是，如果你声明一个名为`foo`的变量，然后调用一个也定义了名为`foo`的宏，那么宏的`foo`默认在调用位置（即宏被调用的地方）是不可见的。同样，除非显式传递给宏，否则宏不能访问在调用位置定义的变量（包括`self`）。

大多数时候，你可以将宏标识符看作是存在于与它们扩展到的代码不同的命名空间中。例如，看看示例 7-5 中的代码，它包含一个宏，尝试（并失败）在调用位置遮蔽一个变量。

```
macro_rules! let_foo {
  ($x:expr) => {
    let foo = $x;
  }
}
let foo = 1;
// expands to let foo = 2;
let_foo!(2);
assert_eq!(foo, 1);
```

示例 7-5：宏存在于它们自己的小宇宙中。大多数情况下是这样。

在编译器展开`let_foo!(2)`之后，断言看起来应该会失败。然而，原始代码中的`foo`和宏生成的`foo`存在于不同的宇宙中，它们之间没有任何关系，除了它们恰好共享一个人类可读的名字。事实上，编译器会抱怨宏中的`let foo`是一个未使用的变量。这种卫生性在调试宏时非常有帮助——你不必担心由于恰好选择了相同的变量名而在宏调用者中意外地遮蔽或覆盖变量！

然而，这种卫生性分离仅适用于变量标识符。声明式宏确实共享类型、模块和函数的命名空间与调用位置。这意味着你的宏可以定义新函数，并且这些函数可以在调用作用域中被调用，向其他地方（而非传入的地方）定义的类型添加新实现，引入一个新模块，在宏调用的位置可以访问该模块，等等。这是设计上的考虑——如果宏不能像这样影响更广泛的代码，那么在生成类型、特征实现和函数时使用它们就会更加繁琐，而这些正是宏最为有用的地方。

宏中类型的非卫生性在编写你希望从 crate 中导出的宏时尤其重要。为了使宏真正可重用，你不能假设调用者作用域中会有什么类型。也许调用你宏的代码中定义了 `mod std {}` 或导入了自己的 `Result` 类型。为了安全起见，请确保使用完全指定的类型，比如 `::core::option::Option` 或 `::alloc::boxed::Box`。如果你特别需要引用定义宏的 crate 中的某些内容，使用特殊的元变量 `$crate`。

如果你希望宏影响调用者作用域中的特定变量，你可以选择在宏和调用者之间共享标识符。关键是要记住标识符的来源，因为这就是标识符将绑定到的命名空间。如果你在宏中写 `let foo = 1;`，那么标识符 `foo` 的来源是宏，它将永远不会在调用者的标识符命名空间中可用。另一方面，如果宏接受 `$foo:ident` 作为参数，然后写 `let $foo = 1;`，当调用者用 `!(foo)` 调用宏时，标识符将来源于调用者，因此将引用调用者作用域中的 `foo`。

标识符不必明确传递；在宏外部源代码中出现的任何标识符都会引用调用者作用域中的标识符。在示例 7-6 中，变量标识符出现在 `:expr` 中，但仍然可以访问调用者作用域中的变量。

```
macro_rules! please_set {
  ($i:ident, $x:expr) => {
    $i = $x;
  }
}
let mut x = 1;
please_set!(x, x + 1);
assert_eq!(x, 2);
```

示例 7-6：让宏访问调用站点的标识符

我们本可以在宏中使用 `= $i + 1`，但不能使用 `= x + 1`，因为 `x` 这个名称在宏的定义作用域内是不可用的。

关于声明式宏和作用域的最后一点：与 Rust 中几乎所有其他内容不同，声明式宏在声明之前在源代码中是不存在的。如果你尝试在文件后面使用一个宏定义，这将不起作用！这对你的整个项目都适用；如果你在一个模块中声明了一个宏，并希望在另一个模块中使用它，那么声明宏的模块必须出现在 crate 的前面，而不是后面。如果 `foo` 和 `bar` 是 crate 根目录下的模块，并且 `foo` 声明了一个 `bar` 想要使用的宏，那么 `mod foo` 必须出现在 `mod bar` 之前，在 *lib.rs* 中！

## 过程宏

你可以将过程宏看作是一个解析器和代码生成器的组合，其中你编写连接代码。在高层次上，通过过程宏，编译器收集输入给宏的标记序列，并运行你的程序来确定用什么标记替换它们。

过程宏之所以如此命名，是因为你定义了*如何*根据输入的令牌生成代码，而不是仅仅编写生成的代码。编译器端几乎没有智能——在它看来，过程宏充其量是一个源代码预处理器，可能会任意替换代码。要求你的输入可以被解析为一串 Rust 令牌仍然有效，但仅此而已！

### 过程宏的类型

过程宏有三种不同的类型，每种类型都针对特定的常见用例：

+   类似函数的宏，比如 `macro_rules!` 生成的那些

+   属性宏，比如 `#[test]`

+   派生宏，比如 `#[derive(Serialize)]`

这三种类型都使用相同的底层机制：编译器将一个令牌序列提供给你的宏，并期望你返回一个令牌序列，该序列（可能）与输入树相关。然而，它们在宏的调用方式和输出处理方式上有所不同。我们将简要介绍每一种。

#### 类似函数的宏

类似函数的宏是过程宏中最简单的形式。像声明式宏一样，它只是将宏代码替换为过程宏返回的代码。然而，与声明式宏不同的是，这些宏（像所有过程宏一样）不需要保持卫生性，并且不会保护你避免与调用站点周围代码中的标识符交互。相反，你的宏需要明确指出哪些标识符应该与周围代码重叠（使用 `Span::call_site`），哪些应该视为宏的私有（使用 `Span::mixed_site`，我们稍后会讨论）。

#### 属性宏

属性宏也会整体替换它所附加的项目，但它需要两个输入：出现在属性中的令牌树（去掉属性名称）和整个项的令牌树，包括该项可能包含的其他属性。属性宏使你能够轻松编写一个过程宏，来转换某个项，例如通过向函数定义添加前言或尾声（就像 `#[test]` 所做的那样），或修改结构体的字段。

#### 派生宏

派生宏与另外两个宏有所不同，它不是替换宏的目标，而是向宏的目标添加内容。尽管这种限制看起来可能很严苛，但派生宏是促使创建过程宏的最初动因之一。具体来说，`serde` crate 需要派生宏来实现它现在广为人知的 `#[derive(Serialize, Deserialize)]` 魔法。

派生宏可以说是最简单的程序宏，因为它们有非常严格的格式：你只能在被注解的项后追加项；你不能替换被注解的项，也不能让派生过程接受参数。派生宏确实允许你定义*辅助属性*——这些属性可以放置在被注解的类型内部，以提供给派生宏线索（如`#[serde(skip)]`）——但这些属性主要像标记一样，不能作为独立的宏存在。

### 程序宏的成本

在讨论每种不同类型的程序宏何时适用之前，值得讨论一下为什么在使用程序宏之前你可能需要三思——也就是增加的编译时间。

程序宏可以显著增加编译时间，主要有两个原因。第一个是它们通常带来一些比较重的依赖。例如，`syn` crate，它提供了一个用于 Rust 令牌流的解析器，使得编写程序宏的体验更加轻松，但启用所有特性后，它的编译可能需要几十秒。你可以（并且应该）通过禁用不需要的特性以及在调试模式下编译程序宏，而不是在发布模式下编译，来减轻这一问题。代码在调试模式下通常编译速度是发布模式的几倍，而且对于大多数程序宏来说，你甚至不会注意到执行时间的差异。

程序宏增加编译时间的第二个原因是，它们让你在不自觉的情况下生成大量代码。虽然宏可以让你免去实际输入生成代码的麻烦，但它并不能减轻编译器必须解析、编译和优化这些代码的负担。随着你使用更多程序宏，生成的模板代码会不断累积，这可能会导致编译时间的膨胀。

话虽如此，程序宏的实际执行时间在整体编译时间中很少成为一个重要因素。虽然编译器必须等待程序宏完成其操作后才能继续，但实际上，大多数程序宏不会做任何复杂的计算。尽管如此，如果你的程序宏特别复杂，编译时间可能会在程序宏代码上消耗相当大的执行时间，这一点值得关注！

### 所以你认为你需要一个宏

现在让我们来看看每种程序宏的好用场景。我们先从简单的开始：派生宏。

#### 何时使用派生宏

派生宏仅用于一件事：自动化实现一个可以自动化的特征。并非所有特征都有明显的自动化实现，但很多特征是有的。实际上，只有当特征经常被实现，并且对于任何给定类型的实现非常明显时，才应考虑为该特征添加一个派生宏。第一个条件看起来像常识；如果你的特征只会实现一两次，那么编写和维护一个复杂的派生宏可能并不值得。

第二个条件可能看起来更奇怪：什么是“明显”的实现？考虑一个像`Debug`这样的特征。如果你知道`Debug`的作用，并且看到一个类型，你可能会期望`Debug`的实现输出每个字段的名称，以及字段值的调试表示。这正是`derive(Debug)`所做的。那`Clone`呢？你可能会期望它只克隆每个字段——同样，这正是`derive(Clone)`所做的。对于`derive(serde::Serialize)`，我们期望它序列化每个字段及其值，而它确实做到了。一般来说，你希望特征的派生能匹配开发者对于其可能作用的直觉。如果某个特征没有明显的派生方式，或者更糟的是，如果你的派生方式与明显的实现不匹配，那么你可能最好不要为它提供一个派生宏。

#### 何时使用类似函数的宏

对于类似函数的宏，很难给出一个通用的经验法则。你可能会说，当你想使用类似函数的宏，但无法通过`macro_rules!`来表达时，应该使用类似函数的宏，但这是一个相当主观的指南。毕竟，如果你真心投入，声明式宏可以做很多事情！

有两个特别好的理由可以选择使用类似函数的宏：

+   如果你已经有了一个声明式宏，并且它的定义变得越来越复杂，以至于宏难以维护。

+   如果你有一个纯函数，需要在编译时执行，但无法使用`const fn`来表达。一个例子是`phf` crate，它在编译时接收到一组键，并使用完美哈希函数生成一个哈希映射或集合。另一个例子是`hex-literal`，它接收一个十六进制字符的字符串，并将其替换为相应的字节。一般来说，任何不仅仅在编译时转换输入，而是对输入进行实际计算的内容，都是一个很好的候选者。

我不推荐仅仅为了打破宏的卫生规则而去使用类似函数的宏。类似函数的宏的卫生特性可以避免许多调试上的麻烦，在故意破坏它之前，你应该三思而后行。

#### 何时使用属性宏

这使我们得到了属性宏。尽管这些可以说是过程宏中最通用的，但也是最难知道何时使用的。多年来，我一再看到属性宏增加了四种方式，为代码添加了巨大的价值。

**测试生成**

1.  很常见的情况是希望在多个不同配置下运行相同的测试，或者在相同引导代码下运行许多类似的测试。虽然声明性宏可以帮助您表达这一点，但如果您有类似 `#[foo_test]` 的属性，它在每个注解测试中引入设置序言和后记，或者像 `#[test_case(1)] #[test_case(2)]` 这样的可重复属性，标记给定测试应多次重复执行，那么您的代码通常更易于阅读和维护。

**框架注解**

1.  类似 `rocket` 的库使用属性宏来增强函数和类型，使框架可以在用户无需进行大量手动配置的情况下使用这些信息。能够写 `#[get("/<name>")] fn hello(name: String)` 要比设置一个包含函数指针等内容的配置结构体方便得多。基本上，这些属性构成了一个小型领域特定语言（DSL），隐藏了许多必要的样板代码。类似地，异步 I/O 框架 `tokio` 允许您使用 `#[tokio::main] async fn main()` 自动设置运行时并运行您的异步代码，从而避免在每个异步应用程序的 `main` 函数中编写相同的运行时设置。

**透明中间件**

1.  一些库希望以不显眼的方式注入到您的应用程序中，以提供不改变应用程序功能的增值服务。例如，跟踪和日志记录库如 `tracing` 和度量收集库如 `metered` 允许您通过向函数添加属性来透明地为其加入一些额外的代码，然后该函数的每次调用都将执行库所指定的一些附加代码。

**类型转换器**

1.  有时，你希望不仅仅为某个类型派生特性，而是实际以某种根本的方式更改该类型的定义。在这些情况下，属性宏是解决方案。`pin_project` crate 就是一个很好的例子：它的主要目的是确保所有对给定类型字段的固定访问都按照 Rust 的`Pin`类型和`Unpin`特性所设定的严格规则进行（我们将在第八章详细讨论这些类型）。它通过生成额外的辅助类型、向注解的类型添加方法，并引入静态安全检查，确保用户不会不小心自我陷害。虽然`pin_project`本可以通过过程派生宏来实现，但那种派生的特性实现可能并不明显，这违背了我们使用过程宏的规则之一。

### 它们是如何工作的？

所有过程宏的核心是`TokenStream`类型，它可以被迭代以获取组成该令牌流的单独`TokenTree`项。一个`TokenTree`可以是单个令牌——例如标识符、标点符号或字面量——或者是另一个被定界符如`()`或`{}`括起来的`TokenStream`。通过遍历`TokenStream`，你可以解析出任何你想要的语法，只要这些单独的令牌是有效的 Rust 令牌。如果你想将输入专门解析为 Rust 代码，你可能需要使用`syn` crate，它实现了一个完整的 Rust 解析器，并可以将`TokenStream`转换为一个易于遍历的 Rust AST。

对于大多数过程宏，你不仅想要解析一个`TokenStream`，还需要生成 Rust 代码，将其注入到调用该过程宏的程序中。有两种主要方法可以做到这一点。第一种是手动构造一个`TokenStream`并逐一扩展每个`TokenTree`。第二种是使用`TokenStream`的`FromStr`实现，它允许你解析包含 Rust 代码的字符串，转换成`TokenStream`，方法是`"".parse::<TokenStream>()`。你也可以混合使用这两种方法；如果你想在宏的输入前添加一些代码，只需为前言构造一个`TokenStream`，然后使用`Extend`特性来追加原始输入。

令牌比我目前所描述的要稍微神奇一点，因为每个令牌，实际上每个`TokenTree`，也都有一个*跨度*。跨度是编译器将生成的代码与产生该代码的源代码关联的方式。每个令牌的跨度标记了该令牌的起源。例如，考虑一个（声明式）宏，如列表 7-7 中所示，它为提供的类型生成一个简单的`Debug`实现。

```
macro_rules! name_as_debug {
  ($t:ty) => {
    impl ::core::fmt::Debug for $t {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result
      { ::core::write!(f, ::core::stringify!($t)) }
} }; }
```

列表 7-7：实现`Debug`的一个非常简单的宏

现在假设有人用`name_as_debug!(u31)`调用了这个宏。从技术上讲，编译错误发生在宏内部，特别是在我们写`for $t`的位置（`$t`的另一个用法可以处理无效的类型）。但我们希望编译器能将错误指向用户代码中的`u31`——实际上，这就是跨度所能做到的。

生成的代码中，`$t`的跨度是映射到宏调用中的`$t`的代码。然后，这些信息会被传递到编译器，并与最终的编译错误关联。当编译器最终打印出该错误时，编译器会从宏内部打印错误，提示类型`u31`不存在，但会高亮显示宏调用中的`u31`参数，因为这就是错误所关联的跨度！

跨度非常灵活，它们使得你能够编写过程宏，如果使用`compile_error!`宏，可以生成复杂的错误消息。顾名思义，`compile_error!`会使编译器在其所在位置发出错误，并使用提供的字符串作为错误消息。这看起来可能不太有用，直到你将它与跨度配合使用。通过将你为`compile_error!`调用生成的`TokenTree`的跨度设置为输入某些子集的跨度，你实际上是在告诉编译器发出此编译错误，并将用户指向源代码中的这一部分。结合这两种机制，宏可以生成看似源自相关代码部分的错误，即使实际的编译错误出现在生成代码中，用户甚至从未看到过这些生成的代码！

跨度的强大功能不止于此；跨度也是 Rust 宏清洁性实现的方式。当你构造一个`Ident`标记时，你还需要为该标识符提供跨度，这个跨度决定了该标识符的作用域。如果你将标识符的跨度设置为`Span::call_site()`，则该标识符会在宏调用的地方解析，从而不会与周围的作用域隔离。另一方面，如果你将其设置为`Span::mixed_site()`，则（变量）标识符会在宏定义的地方解析，因此在调用站点中与同名变量完全保持清洁。`Span::mixed_site`之所以这样命名，是因为它遵循`macro_rules!`的标识符清洁规则，正如我们之前所讨论的那样，它在变量使用宏定义站点时与使用调用站点解析类型、模块及其他内容时“混合”了标识符解析。

## 总结

本章我们介绍了声明式宏和过程宏，并探讨了你在自己代码中可能会发现它们各自有用的时机。我们还深入探讨了支撑每种类型宏的机制，以及在编写自己宏时需要注意的一些特性和陷阱。在下一章，我们将开始我们的异步编程之旅，介绍`Future`特性。我保证——它就在下一页。
