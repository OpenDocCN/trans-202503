# 第二章：类型

![](img/chapterart.png)

现在基础知识已经讲完，我们来看看 Rust 的类型系统。我们将跳过《Rust 编程语言》一书中涵盖的基础内容，直接深入探讨不同类型在内存中的布局、特征和特征约束的细节、存在类型以及跨 crate 边界使用类型的规则。

## 内存中的类型

每个 Rust 值都有一个类型。类型在 Rust 中有许多用途，正如我们在本章中将看到的那样，但它们最基本的作用之一是告诉你如何解释内存中的比特。例如，比特序列`0b10111101`（以十六进制表示为`0xBD`）本身并没有意义，直到你给它指定一个类型。当按`u8`类型解释时，这个比特序列是数字 189。当按`i8`类型解释时，它是-67。当你定义自己的类型时，编译器的工作是确定定义类型的每个部分在该类型的内存表示中放置的位置。你的结构体的每个字段会出现在比特序列的哪里？你的枚举的判别值存储在哪里？理解这个过程如何工作非常重要，因为这些细节会影响到你代码的正确性和性能，尤其是在你开始编写更复杂的 Rust 代码时。

### 对齐

在我们讨论一个类型的内存表示是如何确定之前，我们首先需要讨论*对齐*的概念，它决定了一个类型的字节应该存储在哪里。一旦确定了一个类型的表示，你可能认为可以随便选一个内存位置，并将存储在那里的字节解释为该类型。虽然从理论上讲这是正确的，但在实践中，硬件也会限制某个类型可以放置的位置。最明显的例子是指针指向的是*字节*，而不是*比特*。如果你把一个类型为`T`的值放在计算机内存的第 4 位开始，你将无法引用它的位置；你只能创建一个指向字节 0 或字节 1（第 8 位）的指针。因此，所有的值，不论其类型，都必须从字节边界开始。我们说所有的值必须至少是*字节对齐的*——它们必须放置在一个是 8 位倍数的地址上。

有些值的对齐规则比仅仅字节对齐要严格。在 CPU 和内存系统中，内存通常是按比单个字节更大的块访问的。例如，在 64 位 CPU 上，大多数值是按 8 字节（64 位）为一组访问的，每次操作都会从一个 8 字节对齐的地址开始。这被称为 CPU 的*字长*。然后，CPU 会使用一些巧妙的方法来处理读取和写入较小的值，或者跨越这些块边界的值。

在可能的情况下，您需要确保硬件能够以其“本地”对齐方式运行。为了理解为什么这样做很重要，请考虑如果您尝试读取一个从 8 字节块中间开始的`i64`会发生什么（即，它的指针没有 8 字节对齐）。硬件将不得不进行两次读取——第一次从第一个块的后半部分读取以获取`i64`的开始，第二次从第二个块的前半部分读取以获取`i64`的其余部分——然后将结果拼接在一起。这种方式效率不高。由于该操作跨多个访问底层内存进行，如果您读取的内存正在被另一个线程并发写入，您可能会得到奇怪的结果。您可能会在另一个线程写入之前读取前 4 字节，而在写入之后读取后 4 字节，导致值被破坏。

对未对齐数据的操作被称为*未对齐访问*，这可能导致性能低下和不良的并发问题。正因为如此，许多 CPU 操作要求或强烈偏好它们的参数是*自然对齐*的。自然对齐的值是指其对齐方式与其大小相匹配。例如，对于一个 8 字节加载，提供的地址需要是 8 字节对齐的。

由于对齐访问通常更快，并且提供更强的统一性语义，编译器会尽可能利用它们。它通过为每个类型计算一个基于其包含类型的对齐方式来实现这一点。内置值通常按照其大小对齐，因此`u8`按字节对齐，`u16`按 2 字节对齐，`u32`按 4 字节对齐，`u64`按 8 字节对齐。复杂类型——即包含其他类型的类型——通常会分配它们所包含的任何类型中最大的对齐方式。例如，一个包含`u8`、`u16`和`u32`的类型将会按 4 字节对齐，因为它包含`u32`。

### 布局

现在你已经了解了对齐方式，我们可以探讨编译器如何决定类型的内存布局，也就是所谓的*布局*。默认情况下，正如你很快会看到的，Rust 编译器对类型的布局几乎没有什么保证，这使得它成为理解底层原理的一个不太理想的起点。幸运的是，Rust 提供了一个`repr`属性，你可以在类型定义中添加它来请求特定的内存表示。最常见的，假如你看到了这个属性，便是`repr(C)`。顾名思义，它将类型按照与 C 或 C++编译器布局相兼容的方式进行布局。当编写与其他语言通过外部函数接口（FFI）交互的 Rust 代码时，这非常有帮助，我们将在第十一章讨论，因为 Rust 会生成与其他语言编译器预期的布局相匹配的布局。由于 C 的布局是可预测的，并且不会改变，`repr(C)`在不安全上下文中也很有用，尤其是当你在处理指向类型的原始指针时，或者当你需要在两个具有相同字段的不同类型之间进行转换时。它当然也是进入布局算法的完美起点。

所以，让我们看看编译器如何使用`repr(C)`布局某个特定类型：在示例 2-1 中的`Foo`类型。你认为编译器会如何在内存中布局这个类型？

```
#[repr(C)]
struct Foo {
  tiny: bool,
  normal: u32,
  small: u8,
  long: u64,
  short: u16,
}
```

示例 2-1：对齐方式影响布局。

首先，编译器看到字段`tiny`，它的逻辑大小是 1 位（`true`或`false`）。但是由于 CPU 和内存以字节为单位进行操作，`tiny`在内存中的表示占用了 1 字节。接着，`normal`是一个 4 字节类型，因此我们希望它按照 4 字节对齐。但即使`Foo`已经对齐，分配给`tiny`的 1 字节也会使得`normal`错过它的对齐位置。为了解决这个问题，编译器在`tiny`和`normal`之间插入了 3 字节的*填充*——这些字节值不确定，在用户代码中被忽略——以便使内存表示正确对齐。填充字节中没有值，但它确实占用了空间。

对于下一个字段，`small`，对齐很简单：它是一个 1 字节的值，而当前结构的字节偏移量是 1 + 3 + 4 = 8\。这已经是字节对齐的，因此`small`可以紧跟在`normal`后面。不过，`long`又出现了问题。现在我们已经进入`Foo`的 1 + 3 + 4 + 1 = 9 字节。如果`Foo`是对齐的，那么`long`就不是我们希望的 8 字节对齐，因此我们必须插入 7 个字节的填充，使`long`重新对齐。这个操作也方便地确保了最后一个字段`short`需要的 2 字节对齐，总共使得大小为 26 字节。现在我们已经处理完所有字段，还需要确定`Foo`本身的对齐。这里的规则是使用`Foo`所有字段中最大的对齐方式，这将是 8 字节，因为`long`字段的原因。因此，为了确保`Foo`在被放入数组时仍然对齐，编译器会最终添加 6 字节的填充，使`Foo`的大小成为其对齐的倍数，总计 32 字节。

现在我们准备抛弃 C 语言的遗产，考虑一下如果我们不使用`repr(C)`，会发生什么情况，如 Listing 2-1 所示。C 表示的一个主要限制是它要求我们按原始结构定义中出现的顺序放置所有字段。默认的 Rust 表示`repr(Rust)`消除了这个限制，并且去除了其他一些较小的限制，例如对类型字段的确定性排序——即使两个不同的类型共享完全相同的字段，且字段顺序相同，在默认的 Rust 布局下也不能保证它们的布局相同！

由于现在允许重新排序字段，我们可以按照字段大小的递减顺序排列它们。这意味着我们不再需要在`Foo`的字段之间添加填充；字段本身就能实现所需的对齐！`Foo`现在只占用其字段的大小：仅 16 字节。这也是 Rust 默认情况下不会对类型在内存中的布局做出太多保证的原因之一：通过给编译器更多的调整空间，我们可以生成更高效的代码。

事实证明，还有第三种布局类型的方法，那就是告诉编译器我们不希望字段之间有任何填充。在这样做时，我们表示愿意接受使用未对齐访问所带来的性能损失。这种做法最常见的用例是当每增加一个字节的内存都会带来影响时，比如当你有大量的类型实例、内存非常有限，或者你正在通过低带宽的媒介（如网络连接）传输内存中的表示。要启用这种行为，你可以用`#[repr(packed)]`注解你的类型。请记住，这可能会导致代码变得更慢，在极端情况下，如果你尝试执行仅在对齐参数上支持的操作，程序可能会崩溃。

有时，你可能希望给某个特定字段或类型一个比它技术上要求的更大的对齐方式。你可以使用属性`#[repr(align(n))]`来实现。一个常见的用例是确保在内存中连续存储的不同值（例如在数组中）最终会位于 CPU 的不同缓存行中。这样，你可以避免*伪共享*，它会导致并发程序中的性能大幅下降。伪共享发生在两个不同的 CPU 访问恰好共享同一缓存行的不同值时；尽管它们理论上可以并行操作，但最终它们都会争抢更新缓存中的同一个条目。我们将在第十章中更详细地讨论并发。

### 复杂类型

你可能好奇编译器是如何在内存中表示其他 Rust 类型的。这里有一个快速参考：

1.  元组 表示方式类似于结构体，其中字段与元组值的类型相同，且顺序一致。

1.  数组 表示为包含类型的连续序列，元素之间没有填充。

1.  联合体 布局对于每个变体独立选择。对齐方式是所有变体中的最大值。

1.  枚举 与联合体相同，但多了一个隐藏的共享字段，用于存储枚举变体的区分符。区分符是代码用来判断给定值属于哪个枚举变体的值。区分符字段的大小取决于变体的数量。

### 动态大小类型和宽指针

你可能在 Rust 文档的各个奇怪角落和错误消息中遇到过标记特性`Sized`。通常，它会出现是因为编译器希望你提供一个`Sized`的类型，但你（显然）没有提供。Rust 中的大多数类型会自动实现`Sized`，也就是说，它们的大小在编译时是已知的，但有两个常见类型不是：特性对象和切片。例如，如果你有一个`dyn Iterator`或`[u8]`，它们的大小是没有明确规定的。它们的大小依赖于程序运行时才会知道的信息，而不是在编译时已知的，这就是为什么它们被称为*动态大小类型（DSTs）*。没有人能提前知道你的函数接收到的`dyn Iterator`是这个 200 字节的结构体还是那个 8 字节的结构体。这就提出了一个问题：编译器通常必须知道某个事物的大小才能生成有效的代码，比如如何为类型`(i32, dyn Iterator, [u8], i32)`的元组分配空间，或者如果你的代码试图访问第四个字段时应该使用什么偏移量。但如果类型不是`Sized`，那就无法获得这些信息。

编译器几乎在所有地方都要求类型必须是`Sized`。结构体字段、函数参数、返回值、变量类型和数组类型都必须是`Sized`。这种限制非常常见，几乎每次你编写类型约束时，都会包括`T: Sized`，除非你显式地选择不使用它，像是通过`T: ?Sized`（`?`表示“可能不是”）。但是，如果你有一个动态大小类型（DST），并且想对其执行某些操作，比如你真的希望你的函数接受一个特征对象或者切片作为参数，这样的约束就显得不太有用了。

弥合大小类型和非大小类型之间的差距的方法是将非大小类型放在一个*宽指针*（也叫做*胖指针*）后面。宽指针就像普通指针，但它包含一个额外的与字长相同大小的字段，提供指针的额外信息，这些信息是编译器在生成合理的指针操作代码时所需要的。当你获取一个 DST 的引用时，编译器会自动为你构造一个宽指针。对于切片，额外的信息就是切片的长度。对于特征对象——嗯，我们稍后会详细讲解。而关键是，这个宽指针*是*`Sized`的。具体来说，它的大小是`usize`的两倍（`usize`是目标平台上一个字的大小）：一个`usize`用于存储指针，另一个`usize`用于存储完成类型所需的额外信息。

## 特征和特征约束

特征是 Rust 类型系统的关键部分——它们是允许类型之间进行交互的粘合剂，尽管这些类型在定义时彼此并不知情。《*Rust 编程语言*》很好地介绍了如何定义和使用特征，所以我在这里就不再赘述。相反，我们将探讨一些更技术性的特征方面：它们是如何实现的，你需要遵守的限制，以及特征的一些更深奥的使用方式。

### 编译和分派

到现在为止，你可能已经编写了相当多的 Rust 泛型代码。你已经在类型和方法上使用了泛型类型参数，甚至可能还使用了一些特征约束。但是，你是否曾经想过，当你编译这些泛型代码时，实际发生了什么？或者，当你在`dyn Trait`上调用一个特征方法时，发生了什么？

当你编写一个对`T`泛型的类型或函数时，你实际上是在告诉编译器为每个类型`T`创建该类型或函数的副本。当你构造一个`Vec<i32>`或`HashMap<String, bool>`时，编译器本质上是复制粘贴了泛型类型及其所有实现块，并将每个泛型参数的实例替换为你提供的具体类型。它为`Vec`类型做了一个完整的副本，将所有的`T`替换为`i32`，为`HashMap`类型做了一个完整的副本，将所有的`K`替换为`String`，将所有的`V`替换为`bool`。

同样的情况也适用于泛型函数。请看示例 2-2，其中展示了一个泛型方法。

```
impl String {
  pub fn contains(&self, p: impl Pattern) -> bool {
    p.is_contained_in(self)
  }
}
```

示例 2-2：使用静态分派的泛型方法

对于每种不同的模式类型，都需要为其创建一个该方法的副本（回想一下，`impl Trait` 是 `<T: Trait>` 的简写）。我们需要为每个 `impl Pattern` 类型准备一个不同的函数体副本，因为我们需要知道 `is_contained_in` 函数的地址以便调用它。CPU 需要知道跳转到哪里继续执行。对于任何*给定的*模式，编译器知道那个地址就是该模式类型实现该特征方法的地方的地址。但我们无法为*任何*类型使用一个地址，所以我们需要为每个类型准备一个副本，每个副本都有自己的跳转地址。这种方式被称为*静态分派*，因为对于该方法的任何副本，我们“分派到”的地址是静态已知的。

从一个泛型类型转换为多个非泛型类型的过程被称为*泛型化*，这也是泛型 Rust 代码通常与非泛型代码性能相当的原因之一。等到编译器开始优化你的代码时，几乎就好像根本没有泛型存在！每个实例都会单独优化，并且所有类型都已知。因此，代码的效率与直接调用传入模式的 `is_contained_in` 方法（没有任何特征）时的效果是一样的。编译器完全了解所涉及的类型，甚至可以根据需要内联 `is_contained_in` 的实现。

泛型化也有其成本：所有这些类型实例化需要单独编译，如果编译器不能优化掉它们，这会增加编译时间。每个泛型化的函数还会生成自己的机器代码块，这可能会使程序变大。而且，因为不同实例化的泛型类型方法之间的指令不能共享，CPU 的指令缓存也会变得不那么高效，因为它现在需要存储多个几乎相同的指令副本。

静态派发的替代方案是*动态派发*，它使得代码能够在不知晓类型的情况下调用泛型类型的 trait 方法。我之前说过，之所以在 Listing 2-2 中需要多个方法实例，是因为否则你的程序无法知道跳转到哪个地址以调用给定模式上的 trait 方法`is_contained_in`。好了，使用动态派发时，调用者会直接告诉你。如果你将`impl Pattern`替换为`&dyn Pattern`，你就是在告诉调用者，他们必须为此参数提供*两个*信息：模式的地址*和*`is_contained_in`方法的地址。在实践中，调用者给我们提供一个指向内存块的指针，这个内存块称为虚拟方法表（vtable），它保存了给定类型的 trait 方法的所有实现地址，其中之一就是`is_contained_in`。当方法内部代码想要调用提供的模式上的 trait 方法时，它会在 vtable 中查找该模式的`is_contained_in`实现地址，然后调用该地址的函数。这使得我们无论调用者希望使用何种类型，都可以使用相同的函数体。

当我们使用`dyn`关键字选择动态派发时，你会注意到我们必须在前面加上一个`&`。原因是我们在编译时无法知道调用者传入的模式类型的大小，因此我们不知道需要为其预留多少空间。换句话说，`dyn Trait`是`!Sized`，其中`!`表示不是。为了让它变成`Sized`，以便我们可以将其作为参数传入，我们将其放在指针后面（我们知道指针的大小）。由于我们还需要传递方法地址的表格，因此这个指针变成了一个宽指针，其中额外的字保存了指向虚拟方法表（vtable）的指针。你可以使用任何能够持有宽指针的类型来进行动态派发，例如`&mut`、`Box`和`Arc`。Listing 2-3 展示了与 Listing 2-2 相对应的动态派发示例。

```
impl String {
  pub fn contains(&self, p: &dyn Pattern) -> bool {
    p.is_contained_in(&*self)
  }
}
```

Listing 2-3: 使用动态派发的泛型方法

实现了特性的类型与其虚表的组合被称为*特性对象*。大多数特性可以转换为特性对象，但并非所有。例如，`Clone`特性，其`clone`方法返回`Self`，不能转换为特性对象。如果我们接受一个`dyn Clone`特性对象并在其上调用`clone`，编译器将无法知道返回什么类型。再比如，来自标准库的`Extend`特性，它有一个`extend`方法，该方法对于提供的迭代器类型是泛型的（因此可能有多个实例）。如果你调用一个接受`dyn Extend`的方法，则`extend`在特性对象的虚表中无法放入一个唯一的地址；必须为`extend`可能被调用的每个类型插入一个条目。这些都是不能*安全作为对象*的特性，因此无法转换为特性对象。为了安全作为对象，特性中的方法不能是泛型的，也不能使用`Self`类型。此外，特性不能有任何静态方法（即那些第一个参数不是解引用到`Self`的方法），因为无法知道应该调用哪个方法实例。例如，`FromIterator::from_iter(&[0])`应该执行什么代码是不明确的。

当阅读关于特性对象的内容时，可能会看到提到特性约束`Self: Sized`。这样的约束意味着`Self`没有通过特性对象使用（因为它那时会是`!Sized`）。你可以将这个约束放在一个特性上，要求该特性从不使用动态分发，或者将它放在特定方法上，使得该方法在通过特性对象访问时不可用。具有`where Self: Sized`约束的方法在检查特性是否安全作为对象时会被豁免。

动态分发减少了编译时间，因为不再需要编译多个类型和方法的副本，而且它还可以提高 CPU 指令缓存的效率。然而，它也阻止编译器对所使用的具体类型进行优化。在动态分发中，编译器对示例 2-2 中的`find`方法所能做的唯一优化，就是通过虚表插入一个对该函数的调用——它无法执行任何其他优化，因为它不知道函数调用的另一侧将执行什么代码。此外，特性对象上的每个方法调用都需要在虚表中查找，这比直接调用方法多了一点额外开销。

当你在静态分发和动态分发之间做选择时，通常没有明确的正确答案。大体而言，你会希望在库中使用静态分发，而在二进制文件中使用动态分发。在库中，你希望允许用户自行决定哪种分发方式最适合他们，因为你不知道他们的需求。如果你使用动态分发，他们也必须做出同样的决定；而如果你使用静态分发，他们可以选择是否使用动态分发。另一方面，在二进制文件中，你是写最终的代码，所以只有你写的代码的需求需要考虑。动态分发通常允许你编写更简洁的代码，省略泛型参数，且编译速度更快，虽然通常会有微小的性能损失，因此它通常是二进制文件的更好选择。

### 泛型特征

Rust 特征可以通过两种方式实现泛型：使用泛型类型参数，如`trait Foo<T>`，或使用关联类型，如`trait Foo { type Bar; }`。这两者之间的区别不容易立刻看出来，但幸运的是，经验法则非常简单：如果你期望某个特征对于给定类型只有一个实现，就使用关联类型；否则使用泛型类型参数。

这样做的原因是，关联类型通常更容易使用，但不允许多次实现。更简单地说，这条建议的核心就是尽可能使用关联类型。

对于一个泛型特征，用户必须始终指定所有泛型参数并重复这些参数的任何约束条件。这可能很快变得混乱且难以维护。如果你向特征中添加一个泛型参数，那么所有使用该特征的用户也必须更新以反映这一变化。而且，由于对于给定类型可能存在多个特征实现，编译器可能很难决定你想使用哪个特征实例，从而导致像`FromIterator::<u32>::from_iter`这样的糟糕歧义函数调用。但好处是，你可以为同一类型多次实现该特征——例如，你可以为你的类型实现针对多个右侧类型的`PartialEq`，或者你可以同时实现`FromIterator<T>` *和* `FromIterator<&T> where T: Clone`，这正是由于泛型特征所提供的灵活性。

另一方面，使用关联类型时，编译器只需要知道实现了该特征的类型，所有的关联类型都会随之确定（因为只有一个实现）。这意味着所有的约束条件可以全部放在特征本身，而无需在使用时重复。这反过来允许特征添加更多的关联类型，而不会影响其使用者。而且，由于类型决定了特征的所有关联类型，你永远不需要像前一段所示那样使用统一的函数调用语法来消除歧义。然而，你不能对多个`Target`类型实现`Deref`，也不能对多个不同的`Item`类型实现`Iterator`。

### 一致性与孤儿规则

Rust 对你可以在哪些类型上实现特征以及如何实现它们有一些相当严格的规则。这些规则的存在是为了保持*一致性属性：对于任何给定的类型和方法，始终只有一个正确的选择来决定该类型使用哪种方法实现。为了理解这一点，想象一下如果我能为标准库中的`bool`类型编写自己的`Display`特征实现会发生什么。现在，对于任何尝试打印`bool`值并且包含我的 crate 的代码，编译器将不知道是选择我写的实现还是标准库中的实现。没有哪个选择是正确的或比另一个更好，而且编译器显然不能随机选择。如果完全没有标准库的参与，而是我们有两个相互依赖的 crate，它们都为某个共享类型实现了一个特征，也会发生同样的问题。一致性属性确保编译器永远不会陷入这些情况，并且永远不需要做出这些选择：总会有一个明确的选择。*

*维持一致性的一个简单方法是确保只有定义特征的 crate 可以为该特征编写实现；如果没有其他人能实现这个特征，那么就不会有冲突的实现。然而，实践中这太过严格，基本上会让特征变得没用，因为你无法为自己的类型实现像`std::fmt::Debug`和`serde::Serialize`这样的特征，除非你将自己的类型包含进定义特征的 crate 中。相反的极端说法是，只能为自己的类型实现特征，这虽然解决了问题，但又引入了另一个问题：一个定义特征的 crate 现在不能为标准库或其他流行 crate 中的类型提供该特征的实现！理想情况下，我们希望找到一组规则，既能平衡下游 crate 为自己的类型实现上游特征的需求，又能让上游 crate 在不破坏下游代码的情况下添加自己的特征实现。*

在 Rust 中，确立这种平衡的规则是*孤儿规则*。简单来说，孤儿规则规定，只有当 trait *或*类型属于你自己的 crate 时，你才可以为该类型实现 trait。因此，你可以为你自己的类型实现 `Debug`，你也可以为 `bool` 实现 `MyNeatTrait`，但不能为 `bool` 实现 `Debug`。如果你尝试这么做，编译器会告诉你代码无法编译，因为存在冲突的实现。

这使你走得很远；它允许你为第三方类型实现你自己的 trait，并为你自己的类型实现第三方 trait。然而，孤儿规则并不是故事的全部。它还有许多额外的影响、注意事项和例外情况，你应该了解这些内容。

#### 通用实现

孤儿规则允许你通过像 `impl<T> MyTrait for T where T:` 这样的代码对一系列类型实现 trait。这是一种*通用实现*——它不限于某一个特定类型，而是适用于广泛的类型。只有定义 trait 的 crate 才能编写通用实现，并且向现有 trait 添加通用实现会被视为破坏性变更。如果不是这样，某个下游 crate 中的 `impl MyTrait for Foo` 可能会因为你更新定义 `MyTrait` 的 crate 而突然无法编译，原因是冲突的实现。

#### 基本类型

有些类型是如此重要，以至于必须允许任何人都能为它们实现 trait，即使这看起来违反了孤儿规则。这些类型会标记上 `#[fundamental]` 属性，目前包括 `&`、`&mut` 和 `Box`。就孤儿规则而言，基本类型可以说是不存在的——它们在检查孤儿规则之前会被有效地“擦除”，从而允许你例如为 `&MyType` 实现 `IntoIterator`。如果仅有孤儿规则，这种实现是不被允许的，因为它为一个外来类型实现了一个外来 trait——`IntoIterator` 和 `&` 都来自标准库。为基本类型添加通用实现同样会被视为破坏性变更。

#### 覆盖实现

有一些有限的情况，我们希望允许为外来类型实现外来 trait，这是孤儿规则通常不允许的。最简单的例子是当你想写类似 `impl From<MyType> for Vec<i32>` 的代码时。在这里，`From` trait 是外来的，`Vec` 类型也是外来的，但没有违反一致性的风险。这是因为冲突的实现只能通过标准库中的通用实现添加（标准库不能直接命名 `MyType`），而且这本身就是破坏性变更。

为了允许这些类型的实现，孤儿规则包括一个狭义的豁免，允许在非常特定的情况下为外部类型实现外部特征。具体来说，只有当至少有一个 `Ti` 是本地类型，并且在第一个 `Ti` 之前没有任何 `T` 是泛型类型 `P1..=Pn` 时，才允许给定的 `impl<P1..=Pn> ForeignTrait<T1..=Tn> for T0`。只要它们被某个中介类型所“涵盖”，泛型类型参数（`P`）*是*允许出现在 `T0..Ti` 中的。一个 `T` 被认为是被涵盖的，如果它作为某个其他类型的类型参数出现（例如 `Vec<T>`），但如果它单独存在（只是 `T`）或仅出现在基本类型后面（例如 `&T`），则不被视为涵盖。所以，列表 2-4 中的所有实现都是有效的。

```
impl<T> From<T> for MyType
impl<T> From<T> for MyType<T>
impl<T> From<MyType> for Vec<T>
impl<T> ForeignTrait<MyType, T> for Vec<T>
```

列表 2-4：外部类型的外部特征有效实现

然而，列表 2-5 中的实现是无效的。

```
impl<T> ForeignTrait for T
impl<T> From<T> for T
impl<T> From<Vec<T>> for T
impl<T> From<MyType<T>> for T
impl<T> From<T> for Vec<T>
impl<T> ForeignTrait<T, MyType> for Vec<T>
```

列表 2-5：外部类型的外部特征无效实现

这种对孤儿规则的放宽使得在为现有特征添加新实现时，什么构成破坏性变更的规则变得更加复杂。特别是，向现有特征添加新实现只有在它包含至少一个*新的*本地类型，并且该新本地类型满足前面描述的豁免规则时，才算作非破坏性变更。添加任何其他新实现都是破坏性变更。

### 特征边界

标准库充满了特征边界，无论是 `HashMap` 中的键必须实现 `Hash + Eq`，还是传递给 `thread::spawn` 的函数必须是 `FnOnce + Send + 'static`。当你自己编写泛型代码时，几乎肯定会涉及特征边界，否则你的代码无法在泛型类型上做很多事情。随着你编写越来越复杂的泛型实现，你会发现你需要更多的特征边界精度，那么我们来看看如何实现这一点。

首先，trait 边界不必是 `T: Trait` 的形式，其中 `T` 是你实现或类型所泛型化的某种类型。边界可以是任意类型限制，甚至不需要包含泛型参数、参数类型或局部类型。你可以写出像 `where String: Clone` 这样的 trait 边界，即使 `String: Clone` 永远为真且不包含局部类型。你还可以写出 `where io::Error: From<MyError<T>>`；你的泛型类型参数不需要仅出现在左侧。这不仅让你能够表达更复杂的边界，还能避免不必要的重复边界。例如，如果你的方法想要构造一个 `HashMap<K, V, S>`，其中键是某种泛型类型 `T`，值是 `usize`，你可以避免像 `where T: Hash + Eq, S: BuildHasher + Default` 这样写出边界，而是写 `where HashMap<T, usize, S>: FromIterator`。这样可以避免查找你最终使用的方法的确切边界要求，同时更清晰地传达代码的“真正”要求。如你所见，如果你想调用的底层 trait 方法的边界很复杂，这也可以显著减少边界的复杂性。

有时候，你需要对泛型中关联类型设置边界。例如，考虑 `flatten` 迭代器方法，它接收一个产生项目的迭代器，而这些项目本身实现了 `Iterator`，并生成这些内部迭代器项的迭代器。它生成的类型 `Flatten` 是泛型的，泛型参数 `I` 是外部迭代器的类型。如果 `I` 实现了 `Iterator`，*并且* `I` 产生的项本身实现了 `IntoIterator`，那么 `Flatten` 就实现了 `Iterator`。为了使你能够编写类似的边界，Rust 允许你使用 `Type::AssocType` 语法来引用类型的关联类型。例如，我们可以通过 `I::Item` 来引用 `I` 的 `Item` 类型。如果一个类型有多个相同名称的关联类型（例如，提供该关联类型的 trait 本身是泛型的，因此有多个实现），你可以通过 `<Type as Trait>::AssocType` 语法来消除歧义。使用这种方式，你不仅可以为外部迭代器类型编写边界，还可以为该外部迭代器的项类型编写边界。

在广泛使用泛型的代码中，你可能会发现需要写一个与类型的引用相关的约束。通常这没问题，因为你通常会有一个泛型生命周期参数，可以用作这些引用的生命周期。然而，在某些情况下，你希望约束能够说“这个引用在任何生命周期下都实现这个 trait”。这种类型的约束被称为 *高阶 trait 约束*，它在与 `Fn` trait 结合使用时尤其有用。例如，假设你想要对一个函数进行泛型化，该函数接受对 `T` 的引用并返回对该 `T` 内部的引用。如果你写 `F: Fn(&T) -> &U`，你需要为这些引用提供生命周期，但你实际上想说的是“任何生命周期，只要输出和输入相同”。通过使用高阶生命周期，你可以写 `F: for<'a> Fn(&'a T) -> &'a U`，表示对于 *任何* 生命周期 `'a`，约束必须成立。Rust 编译器足够智能，当你像这样使用带有引用的 `Fn` 约束时，它会自动添加 `for`，这涵盖了该特性的绝大多数使用场景。显式的形式如此罕见，以至于在写作时，标准库仅在三个地方使用了它——但它确实存在，所以值得了解。

为了将所有这些内容结合起来，考虑 示例 2-6 中的代码，它可以用于为任何可以迭代且其元素为 `Debug` 的类型实现 `Debug`。

```
impl Debug for AnyIterable
  where for<'a> &'a Self: IntoIterator,
        for<'a> <&'a Self as IntoIterator>::Item: Debug {
    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {
        f.debug_list().entries(self).finish()
}}
```

示例 2-6：适用于任何可迭代集合的过于泛化的 `Debug` 实现

你可以将这个实现复制并粘贴到几乎任何集合类型中，它都会“正常工作”。当然，你可能希望有一个更智能的调试实现，但这很好地展示了 trait 约束的强大功能。

### 标记 Trait

通常，我们使用 trait 来表示多个类型可以支持的功能；`Hash` 类型可以通过调用 `hash` 进行哈希，`Clone` 类型可以通过调用 `clone` 进行克隆，`Debug` 类型可以通过调用 `fmt` 进行调试格式化。但并非所有的 trait 都是以这种方式具有功能性的。有些 trait，称为 *标记 trait*，则表示实现类型的某种属性。标记 trait 没有方法或关联类型，仅仅是告诉你某个特定类型是否可以或不能以某种方式使用。例如，如果一个类型实现了 `Send` 标记 trait，那么它可以安全地跨线程边界发送。如果没有实现这个标记 trait，那么发送它是不安全的。与这种行为没有关联的方法；它只是类型的一个事实。标准库中有许多这样的 trait，位于 `std::marker` 模块中，包括 `Send`、`Sync`、`Copy`、`Sized` 和 `Unpin`。其中大多数（除了 `Copy`）也是 *自动 trait*；编译器会自动为这些类型实现它们，除非类型包含某些未实现标记 trait 的内容。

标记特性在 Rust 中发挥着重要作用：它们允许你编写捕获语义需求的约束，而这些需求并未直接在代码中表达。代码中没有调用 `send` 来要求某个类型是 `Send`。相反，代码 *假设* 给定类型可以安全地在单独的线程中使用，如果没有标记特性，编译器将无法检查这一假设。程序员必须记住这个假设，并仔细阅读代码，而我们都知道，这并不是我们希望依赖的方式。那条道路充满了数据竞争、段错误和其他运行时问题。

类似于标记特性的，还有 *标记类型*。这些是单位类型（例如 `struct MyMarker;`），它们不包含任何数据，也没有方法。标记类型的作用是将类型标记为某种特定的状态。当你想确保用户不能误用某个 API 时，标记类型非常有用。例如，考虑一个类型 `SshConnection`，它可能已经认证过，也可能还没有认证。你可以向 `SshConnection` 添加一个泛型类型参数，然后创建两个标记类型：`Unauthenticated` 和 `Authenticated`。当用户首次连接时，他们会得到 `SshConnection<Unauthenticated>`。在其 `impl` 块中，你只提供一个方法：`connect`。`connect` 方法返回一个 `SshConnection<Authenticated>`，并且只有在那个 `impl` 块中，你才提供运行命令等其他方法。我们将在第三章进一步讨论这个模式。

## 存在类型

在 Rust 中，你很少需要在函数体内声明变量的类型，或者指定你调用的方法的泛型参数的类型。这是因为 *类型推断*，编译器根据代码中出现的类型推断出使用什么类型。编译器通常只会推断变量的类型以及闭包的参数（和返回类型）；顶层定义，如函数、类型、特性和特性实现块，都要求你显式地指定所有类型。这有几个原因，主要原因是当你至少有一些已知的起始点时，类型推断会更容易。然而，完全命名一个类型并不总是容易，甚至可能是不可能的！例如，如果你从函数中返回一个闭包，或者从特性方法中返回一个异步块，它的类型没有一个你可以在代码中直接写出的名称。

为了处理类似的情况，Rust 支持 *存在类型*。你很可能已经见过存在类型的应用。所有标记为 `async fn` 或返回类型为 `impl Trait` 的函数都有一个存在返回类型：该函数签名并没有给出返回值的真实类型，只是给出了一个提示，表明该函数返回 *某种* 类型，该类型实现了调用者可以依赖的某些特性。而且，重要的是，调用者只能依赖返回类型实现这些特性，而不能依赖其他任何东西。

这种行为赋予了存在类型它们的名字：我们在声明中断言某个具体的类型存在，并且将找到该类型的任务交给编译器。编译器通常会通过在函数体内应用类型推导来找出那个类型。

并非所有的 `impl Trait` 实例都使用了存在类型。如果你在函数的参数位置使用 `impl Trait`，它实际上只是一个未命名的泛型参数的简写。例如，`fn foo(s: impl ToString)` 其实只是 `fn foo<S: ToString>(s: S)` 的语法糖。

存在类型在实现包含关联类型的特征时特别有用。例如，假设你正在实现 `IntoIterator` 特征。它有一个关联类型 `IntoIter`，表示该类型可以转换成的迭代器类型。有了存在类型，你就不需要定义一个单独的迭代器类型来作为 `IntoIter`。相反，你可以将关联类型定义为 `impl Iterator<Item = Self::Item>`，然后在 `fn into_iter(self)` 内部写一个表达式，计算出一个 `Iterator`，例如使用一些现有迭代器类型的 `map` 和 `filter` 方法。

存在类型不仅仅提供了便捷功能：它们还允许你进行零成本的类型擦除。你不需要因为某些类型出现在公共签名中而导出辅助类型——迭代器和 `future` 就是常见的例子——你可以使用存在类型来隐藏底层的具体类型。接口的用户只会看到相关类型实现的特征，而具体类型则作为实现细节被隐藏。这样不仅简化了接口，也让你可以随意更改实现，而不会破坏未来的下游代码。

## 摘要

本章提供了对 Rust 类型系统的全面回顾。我们既看了编译器是如何在内存中表示类型的，也看了编译器是如何推理类型的。这些是编写不安全代码、复杂应用接口和后续章节中异步代码的重要背景材料。你还会发现，本章中大部分类型推理的内容将影响你如何设计 Rust 代码接口，我们将在下一章中进行讨论。
