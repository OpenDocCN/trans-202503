# 第十三章：Rust 生态系统

![](img/chapterart.png)

编程如今很少在真空中进行——几乎每一个你构建的 Rust crate 都可能依赖于*某些*不是你编写的代码。无论这种趋势是好是坏，还是两者兼而有之，都是一个备受争议的话题，但无论如何，它已经成为今天开发者体验的一部分。

在这个勇敢的新互相依赖的世界里，比以往任何时候都更重要的是要对可用的库和工具有一个扎实的掌握，并保持对 Rust 社区最新和最好的成果的了解。本章将专门讨论如何利用、跟踪、理解并为 Rust 生态系统做出贡献。由于这是最后一章，在结尾部分，我还将提供一些额外资源的建议，帮助你继续发展你的 Rust 技能。

## 现有的工具

尽管 Rust 相对年轻，但它已经有了一个庞大的生态系统，以至于很难跟踪所有可用的资源。如果你知道自己需要什么，你可能能够通过搜索找到一组合适的 crate，并通过下载统计信息和对每个 crate 仓库的表面检查来确定哪些可能成为合理的依赖项。然而，还有许多工具、crate 和通用的语言特性，可能是你不一定知道要寻找的，但它们有可能为你节省无数小时和复杂的设计决策。

在这一节中，我将介绍一些多年来我发现有帮助的工具、库和 Rust 特性，希望它们在某些时刻对你也能有所帮助！

### 工具

首先，以下是一些我发现自己经常使用的 Rust 工具，你应该将它们添加到你的工具箱中：

**`cargo-deny`**

1.  提供了一种对你的依赖图进行 lint 检查的方法。在写这篇文章时，你可以使用 `cargo-deny` 仅允许某些许可证，禁止某些 crate 或特定版本，检测已知漏洞的依赖项或使用 Git 来源的依赖项，并检测在依赖图中以不同版本多次出现的 crate。在你阅读本文时，可能会有更多有用的 lint 检查。

**`cargo-expand`**

1.  扩展给定 crate 中的宏，并让你检查输出，这使得发现宏转录器或过程宏中深层次的错误变得更加容易。当你编写自己的宏时，`cargo-expand` 是一款不可或缺的工具。

**`cargo-hack`**

1.  帮助你检查你的 crate 是否与启用的任何功能组合兼容。该工具呈现一个类似于 Cargo 本身的界面（如 `cargo check`、`build` 和 `test`），但它提供了运行给定命令与 crate 功能的所有可能组合（*幂集*）的能力。

**`cargo-llvm-lines`**

1.  分析 Rust 代码到中间表示（IR）的映射，这些 IR 会传递给 Rust 编译器中的部分，用于生成机器代码（LLVM），并告诉你哪些 Rust 代码生成了最大的 IR。这非常有用，因为更大的 IR 意味着更长的编译时间，因此找出生成更大 IR 的 Rust 代码（例如，由于单态化）可以帮助发现缩短编译时间的机会。

**`cargo-outdated`**

1.  检查你的任何依赖项（无论是直接的还是传递的）是否有新版本可用。关键是，不像`cargo update`，它甚至会告诉你有关新主版本的信息，因此它是检查你是否错过了由于过时的主版本指定而导致的新版本的重要工具。只需记住，提升依赖项的主版本可能会对你的 crate 产生破坏性影响，特别是如果你在接口中暴露了该依赖项的类型！

**`cargo-udeps`**

1.  识别你在*Cargo.toml*中列出的、实际上从未使用过的任何依赖项。也许你曾经使用过它们，但它们现在已经变得多余，或者它们应该被移动到`dev-dependencies`；无论是哪种情况，这个工具都能帮助你削减依赖闭包中的冗余部分。

虽然它们不是专门用于开发 Rust 的工具，我也强烈推荐`fd`和`ripgrep`——它们是`find`和`grep`的优秀替代品，而且它们本身也是用 Rust 编写的。我每天都在使用这两个工具。

### 库

接下来是一些有用但鲜为人知的 crate，我经常用它们，并且我猜我会在很长一段时间内继续依赖它们：

**`bytes`**

1.  提供了一种高效的机制，用于在不进行复制或处理生命周期的情况下，传递单个连续内存块的子切片。这在低级网络代码中非常有用，因为你可能需要对一块字节进行多个视图，而复制操作是不可取的。

**`criterion`**

1.  一种基于统计学的基准测试库，它利用数学方法消除基准测量中的噪音，并可靠地检测随时间变化的性能变化。如果你在你的 crate 中包含了微基准测试，你几乎可以肯定需要使用它。

**`cxx`**

1.  提供了一个安全且符合人体工程学的机制，用于从 Rust 调用 C++代码，反之亦然。如果你愿意投入一些时间提前更彻底地声明你的接口，以换取更好的跨语言兼容性，那么这个库非常值得关注。

**`flume`**

1.  实现了一个多生产者、多消费者的通道，比 Rust 标准库中包含的更快速、更灵活、更简单。它还支持异步和同步操作，因此它是连接这两个世界的一个很好的桥梁。

**`hdrhistogram`**

1.  一个 Rust 版本的高动态范围（HDR）直方图数据结构，它提供了跨越广泛值范围的直方图的紧凑表示。任何当前跟踪平均值或最小/最大值的地方，你很可能应该改用 HDR 直方图，它能为你提供更好的指标分布洞察。

**`heapless`**

1.  提供不使用堆的数据结构。`heapless`的数据结构都由静态内存支持，这使得它们非常适合嵌入式环境或其他不希望进行内存分配的场景。

**`itertools`**

1.  扩展了标准库中的`Iterator`特性，提供了许多新的便捷方法用于去重、分组和计算幂集。这些扩展方法可以显著减少代码中的样板代码，例如在序列上手动实现某些常见算法时，如同时查找最小值和最大值（`Itertools::minmax`），或使用像检查迭代器是否恰好包含一个项这样的常见模式（`Itertools::exactly_one`）。

**`nix`**

1.  提供类 Unix 系统上的系统调用的惯用绑定，与直接使用像`libc`这样的 C 兼容 FFI 类型相比，能带来更好的体验。

**`pin-project`**

1.  提供了强制执行引脚安全不变量的宏，适用于注解类型，这反过来为这些类型提供了一个安全的引脚接口。这使你可以避免大部分自己实现`Pin`和`Unpin`时的麻烦。另外还有`pin-project-lite`，它避免了（当前）对过程宏机制的相对沉重依赖，但代价是稍微降低了易用性。

**`ring`**

1.  从 C 语言编写的加密库 BoringSSL 中提取出精华，并通过一个快速、简单且难以滥用的接口将其带入 Rust。如果你需要在自己的 crate 中使用加密，这是一个很好的起点。你可能已经在`rustls`库中遇到过它，该库使用`ring`提供现代、安全默认的 TLS 栈。

**`slab`**

1.  实现了一个高效的数据结构，用于替代`HashMap<Token, T>`，其中`Token`是一个仅用于区分映射中的条目的不透明类型。在资源管理中经常使用这种模式，其中当前资源的集合必须集中管理，但单个资源也必须能够以某种方式访问。

**`static_assertions`**

1.  提供静态断言——也就是说，在编译时进行评估的断言，因此可能会在编译时失败。你可以使用它来断言某个类型实现了给定的特性（例如`Send`）或具有给定的大小。我强烈推荐在那些保证可能非常重要的代码中加入这种类型的断言。

**`structopt`**

1.  包装了著名的参数解析库 `clap`，并提供了一种方式，使用 Rust 类型系统（加上宏注解）来描述应用程序的命令行接口。当你解析应用程序的参数时，你会得到你定义的类型的值，从而获得所有类型检查的好处，比如穷尽匹配和 IDE 自动完成。

**`thiserror`**

1.  使得编写自定义枚举错误类型（比如我们在第四章讨论的那种）变得轻松愉快。它会处理实现推荐的特性并遵循既定的惯例，而你只需要定义那些对你的应用程序独特且至关重要的部分。

**`tower`**

1.  实质上，它将函数签名 `async fn(Request) -> Response` 进行封装并在其上实现了一个完整的生态系统。其核心是 `Service` 特性，代表一种类型，可以将请求转换为响应（我怀疑它有一天可能会进入标准库）。这是一个很好的抽象，可以用来构建任何类似服务的东西。

**`tracing`**

1.  提供了高效追踪应用程序执行所需的所有基础设施。至关重要的是，它对你追踪的事件类型以及你想对这些事件做什么保持中立。这个库可以用于日志记录、度量收集、调试、性能分析，当然也包括追踪，所有这些都可以用相同的机制和接口来实现。

### Rust 工具

Rust 工具链有一些你可能不知道的特性，这些特性通常适用于非常具体的使用场景，但如果它们适合你的需求，它们可以成为救命稻草！

#### Rustup

Rustup，Rust 工具链安装器，工作非常高效，以至于它通常会消失在背景中并被遗忘。你偶尔会用它来更新工具链、设置目录覆盖或安装组件，除此之外基本不太使用。然而，Rustup 支持一个非常实用的小技巧，值得了解：工具链覆盖简写。你可以将 `+toolchain` 作为第一个参数传递给任何由 Rustup 管理的二进制文件，二进制文件会按你设置的工具链覆盖运行该命令，并在运行完后重置覆盖为之前的状态。所以，`cargo +nightly miri` 会使用 nightly 工具链运行 Miri，而 `cargo +1.53.0 check` 会检查代码是否能用 Rust 1.53.0 编译。后者在检查你是否破坏了最低支持的 Rust 版本协议时特别有用。

Rustup 还有一个非常方便的子命令 `doc`，它会在浏览器中打开当前 Rust 编译器版本的 Rust 标准库文档本地副本。如果你在没有网络连接的情况下进行开发，这个功能非常有价值！

#### Cargo

Cargo 还提供了一些不太容易发现的实用功能。其中第一个是 `cargo tree`，这是一个内置于 Cargo 自身的子命令，用于检查 crate 的依赖关系图。这个命令的主要功能是将依赖关系图以树状结构打印出来。这个功能本身就很有用，但 `cargo tree` 真正的亮点是 `--invert` 选项：它接受一个 crate 标识符，并生成一个反转的树，显示从当前 crate 开始的所有依赖路径，找到该依赖项。例如，`cargo tree -i rand` 会列出当前 crate 如何依赖任何版本的 `rand`，包括通过传递依赖的方式。如果你想删除某个依赖项，或者某个依赖项的特定版本，并想知道为什么它仍然被拉入依赖，这个功能非常有用。你还可以使用 `-e features` 选项，包含有关为什么启用目标 crate 的每个 Cargo 特性的详细信息。

说到 Cargo 子命令，写自己的子命令其实非常简单，无论是为了与他人分享，还是仅仅为了本地开发。当 Cargo 被调用时，如果遇到一个它无法识别的子命令，它会检查是否存在一个名为 `cargo-$subcommand` 的程序。如果存在，Cargo 会调用该程序并传递任何命令行参数——例如，`cargo foo bar` 会调用 `cargo-foo` 并传递参数 `bar`。Cargo 甚至会将这个命令与 `cargo help` 集成，将 `cargo help foo` 转换为对 `cargo-foo --help` 的调用。

随着你参与更多 Rust 项目，你可能会注意到 Cargo（以及 Rust 更广泛的情况）在磁盘空间方面并不宽容。每个项目都会有自己的目标目录，用于存放其编译结果，随着时间的推移，你会积累多个相同的已编译文件副本，尤其是对于常见的依赖。为每个项目保持独立的编译产物是一个合理的选择，因为它们在不同项目之间不一定兼容（比如，一个项目使用的编译器标志可能和另一个项目不同）。但是在大多数开发环境中，共享构建产物是完全合理的，并且在不同项目之间切换时，可以节省相当多的编译时间。幸运的是，配置 Cargo 以共享构建产物非常简单：只需在你的 *~/.cargo/config.toml* 文件中设置 `[build] target` 为你希望共享的构建产物所在的目录，Cargo 会处理其余的工作。再也不需要目标目录了！只需确保定期清理该目录，并且要知道，`cargo clean` 现在会清除*所有*项目的构建产物。

最后，如果你觉得 Cargo 构建你的 crate 的时间异常长，你可以尝试当前不稳定的 Cargo `-Ztimings`标志。使用该标志运行 Cargo 会输出关于每个 crate 处理所花时间的信息、构建脚本运行时间、哪些 crate 需要等待其他 crate 编译完成的时间，以及大量其他有用的度量信息。这可能会突出一个特别慢的依赖链，你可以着手消除它，或者揭示出一个构建脚本，它从头开始编译一个本地依赖库，你可以改为使用系统库。如果你想深入挖掘，还可以使用`rustc -Ztime-passes`，它会输出关于每个 crate 在编译器内部花费时间的相关信息——不过这些信息可能只有在你打算为编译器本身做贡献时才有用。

#### rustc

Rust 编译器还有一些不太为人所知的功能，对于有创新精神的开发者来说，这些功能可能非常有用。第一个是当前不稳定的`-Zprint-type-sizes`参数，它打印当前 crate 中所有类型的大小。对于除最小的 crate 外，这会产生大量的信息，但当你试图确定调用`memcpy`时意外的时间消耗来源，或者寻找减少内存使用的方法，尤其是当分配大量特定类型的对象时，它非常有价值。`-Zprint-type-sizes`参数还会显示每种类型的计算对齐方式和布局，这可能会引导你发现，比如将一个`usize`类型转换为`u32`可能会对类型在内存中的表示产生重大影响。在调试完某个特定类型的大小、对齐和布局后，我建议你添加静态断言，确保它们不会随着时间的推移而发生回归。你也许会对`variant_size_differences` lint 感兴趣，如果一个 crate 包含大小差异显著的`enum`类型的变体，它会发出警告。

如果你的性能分析样本看起来很奇怪，堆栈帧被重新排序或完全缺失，你也可以尝试`-Cforce-frame-pointers = yes`。帧指针提供了一种更可靠的方式来展开堆栈——在性能分析中，这个操作会被频繁执行——代价是每次函数调用时会使用一个额外的寄存器。即使堆栈展开*应该*在只启用常规调试符号的情况下正常工作（记得在使用发布配置时设置`debug = true`），但这并非总是如此，帧指针可能解决你遇到的任何问题。

### 标准库

Rust 标准库通常被认为比其他编程语言的标准库要小，但它在深度上弥补了广度的不足；你不会在 Rust 的标准库中找到一个 Web 服务器实现或 X.509 证书解析器，但你会找到超过 40 种与 `Option` 类型相关的方法，以及 20 多个特征实现。对于包含的类型，Rust 尽力提供所有相关功能，以显著改善可用性，避免了那些容易出现的冗长模板代码。在本节中，我将介绍一些你可能之前没有遇到过的标准库类型、宏、函数和方法，它们往往能简化或改进（或两者兼而有之）你的代码。

#### 宏和函数

让我们从几个独立的实用工具开始。第一个是 `write!` 宏，它允许你使用格式化字符串写入文件、网络套接字或任何其他实现了 `Write` 的对象。你可能已经熟悉它了——但 `write!` 有一个鲜为人知的特性，那就是它可以同时与 `std::io::Write` 和 `std::fmt::Write` 一起使用，这意味着你可以直接将格式化文本写入 `String` 中。也就是说，你可以写 `use std::fmt::Write; write!(&mut s, "{}+1={}", x, x + 1);` 将格式化的文本附加到 `String s` 中！

`iter::once` 函数接受一个值并生成一个迭代器，该迭代器只会返回该值一次。当调用需要迭代器的函数时，如果你不想分配额外的内存，或者与 `Iterator::chain` 结合使用时，它特别有用，能够将单个元素附加到现有的迭代器上。

我们在第一章简要提到了 `mem::replace`，但值得再提一次，以防你错过了它。这个函数接受对 `T` 的独占引用和一个拥有的 `T`，交换这两者，使得引用对象现在变为拥有的 `T`，并返回先前引用对象的所有权。当你需要在仅有独占引用的情况下获取一个值的所有权时，这个函数非常有用，比如在 `Drop` 的实现中。对于 `T: Default`，还可以参考 `mem::take`。

#### 类型

接下来，让我们来看一些方便的标准库类型。`BufReader` 和 `BufWriter` 类型是进行 I/O 操作时必不可少的，它们会对底层 I/O 资源发出许多小的读写请求。这些类型包装了各自底层的 `Read` 或 `Write`，并实现了 `Read` 和 `Write` 接口，但它们额外对操作进行缓冲，使得许多小的读取操作合并为一次大的读取，许多小的写入操作合并为一次大的写入。这可以显著提高性能，因为你不需要频繁地跨越系统调用边界进入操作系统。

`Cow` 类型，如第三章所述，在你需要对持有的类型或返回的类型有灵活性时非常有用。你很少会将 `Cow` 用作函数参数（回想一下，如果有必要的话，你应该让调用者分配），但作为返回类型时它是无价的，因为它可以精确地表示那些可能会或可能不会分配内存的函数的返回类型。它也非常适合那些既可以作为输入 *也* 可以作为输出的类型，比如类似 RPC 的 API 中的核心类型。假设我们有一个类型 `EntityIdentifier`，如示例 13-1 所示，它用于 RPC 服务接口中。

```
struct EntityIdentifier {
    namespace: String,
    name: String,
}
```

示例 13-1：一个需要分配的组合输入/输出类型的表示

现在假设有两个方法：`get_entity` 以 `EntityIdentifier` 作为参数，`find_by` 根据一些搜索参数返回一个 `EntityIdentifier`。`get_entity` 方法只需要一个引用，因为标识符将（假设）在发送到服务器之前被序列化。但对于 `find_by`，实体将从服务器响应中反序列化，因此必须作为拥有的值来表示。如果我们让 `get_entity` 接受 `&EntityIdentifier`，那就意味着调用者仍然必须分配拥有的 `String` 来调用 `get_entity`，即使接口并不要求这么做，因为它在构造 `EntityIdentifier` 时是必要的！我们可以为 `get_entity` 引入一个单独的类型 `EntityIdenifierRef`，它只持有 `&str` 类型，但那样的话我们就得用两种类型来表示同一件事。`Cow` 来拯救我们！示例 13-2 展示了一个 `EntityIdentifier`，它内部持有 `Cow`。

```
struct EntityIdentifier<'a> {
    namespace: Cow<'a, str>,
    name: Cow<'a str>,
}
```

示例 13-2：一个不需要分配的组合输入/输出类型的表示

使用这种构造，`get_entity` 可以接受任何 `EntityIdentifier<'_>`，这使得调用者仅需使用引用即可调用该方法。而 `find_by` 可以返回 `EntityIdentifier<'static>`，其中所有字段都是 `Cow::Owned`。两个接口共享同一个类型，无需不必要的分配！

`std::sync::Once` 类型是一个同步原语，它允许你在初始化时只运行某段代码一次。这对于 FFI 中的初始化非常有用，尤其是当 FFI 边界另一边的库要求初始化只执行一次时。

`VecDeque`类型是`std::collections`中的一个常被忽视的成员，我发现自己经常用到它——基本上，每当我需要栈或队列时。它的接口类似于`Vec`，而且像`Vec`一样，它在内存中的表示是一个单一的内存块。不同之处在于，`VecDeque`同时跟踪数据的开始和结束位置，这使得从`VecDeque`的*任意*一侧执行推入和弹出操作时能够保持常数时间复杂度，这意味着它可以用作栈、队列，甚至同时作为两者。你需要支付的代价是，值在内存中不再一定是连续的（它们可能已经绕回），这意味着`VecDeque<T>`没有实现`AsRef<[T]>`。

#### 方法

让我们通过快速浏览一些有用的方法来结束这一部分。首先是`Arc::make_mut`，它接受一个`&mut Arc<T>`并返回一个`&mut T`。如果`Arc`是唯一存在的，它会返回`Arc`背后的`T`；否则，它会分配一个新的`Arc<T>`，其中包含`T`的克隆，替换掉当前引用的`Arc`，然后将`&mut`赋给新单例`Arc`中的`T`。

`Clone::clone_from`方法是`.clone()`的另一种形式，它允许你重用要克隆的类型实例，而不是分配一个新的实例。换句话说，如果你已经有了一个`x: T`，你可以执行`x.clone_from(y)`，而不是`x = y.clone()`，这样可能会节省一些内存分配。

`std::fmt::Formatter::debug_*`是实现`Debug`的最简单方法，特别是当`#[derive(Debug)]`无法满足你的需求时，比如如果你只想包括某些字段或暴露一些`Debug`实现未暴露的字段信息。在实现`Debug`的`fmt`方法时，只需在传入的`Formatter`上调用适当的`debug_`方法（例如`debug_struct`或`debug_map`），然后在返回的类型上调用包含的方法来填写类型的详细信息（如使用`field`添加字段，或使用`entries`添加键/值条目），最后调用`finish`。

```` `Instant::elapsed` returns the `Duration` since an `Instant` was created. This is much more concise than the common approach of creating a new `Instant` and subtracting the earlier instance.    `Option::as_deref` takes an `Option<P>` where `P: Deref` and returns `Option<&P::Target>` (there’s also an `as_deref_mut` method). This simple operation can make functional transformation chains that operate on `Option` much cleaner by avoiding the inscrutable `.as_ref().map(|r| &**r)`.    `Ord::clamp` lets you take any type that implements `Ord` and clamp it between two other values of a given range. That is, given a lower limit `min` and an upper limit `max`, `x.clamp(min, max)` returns `min` if `x` is less than `min`, `max` if `x` is greater than `max`, and `x` otherwise.    `Result::transpose` and its counterpart `Option::transpose` invert types that nest `Result` and `Option`. That is, transposing a `Result<Option<T>, E>` gives an `Option<Result<T, E>>`, and vice versa. When combined with `?`, this operation can make for cleaner code when working with `Iterator::next` and similar methods in fallible contexts.    `Vec::swap_remove` is `Vec::remove`’s faster twin. `Vec::remove` preserves the order of the vector, which means that to remove an element in the middle, it must shift all the later elements in the vector down by one. This can be very slow for large vectors. `Vec::swap_remove`, on the other hand, swaps the to-be-removed element with the last element and then truncates the vector’s length by one, which is a constant-time operation. Be aware, though, that it will shuffle your vector around and thus invalidate old indexes!    ## Patterns in the Wild    As you start exploring codebases that aren’t your own, you’ll likely come across a couple of common Rust patterns that we haven’t discussed in the book so far. Knowing about them will make it easier to recognize them, and thus understand their purpose, when you do encounter them. You may even find use for them in your own codebase one day!    ### Index Pointers    Index pointers allow you to store multiple references to data within a data structure without running afoul of the borrow checker. For example, if you want to store a collection of data so that it can be efficiently accessed in more than one way, such as by keeping one `HashMap` keyed by one field and one keyed by a different field, you don’t want to store the underlying data multiple times too. You could use `Arc` or `Rc`, but they use dynamic reference counting that introduces unnecessary overhead, and the extra bookkeeping requires you to store additional bytes per entry. You could use references, but the lifetimes become difficult if not impossible to manage because the data and the references live in the same data structure (it’s a self-referential data structure, as we discussed in Chapter 8). You could use raw pointers combined with `Pin` to ensure the pointers remain valid, but that introduces a lot of complexity as well as unsafety you then need to carefully consider.    Most crates use index pointers—or, as I like to call them, *indeferences*—instead. The idea is simple: store each data entry in some indexable data structure like a `Vec`, and then store just the index in a derived data structure. To then perform an operation, first use the derived data structure to efficiently find the data index, and then use the index to retrieve the referenced data. No lifetimes needed—and you can even have cycles in the derived data representation if you wish!    The `indexmap` crate, which provides a `HashMap` implementation where the iteration order matches the map insertion order, provides a good example of this pattern. The implementation has to store the keys in two places, both in the map of keys to values and in the list of all the keys, but it obviously doesn’t want to keep two copies in case the key type itself is large. So, it uses index pointers. Specifically, it keeps all the key/value pairs in a single `Vec` and then keeps a mapping from key hashes to `Vec` indexes. To iterate over all the elements of the map, it just walks the `Vec`. To look up a given key, it hashes that key, looks that hash up in the mapping, which yields the key’s index in the `Vec` (the index pointer), and then uses that to get the key’s value from the `Vec`.    The `petgraph` crate, which implements graph data structures and algorithms, also uses this pattern. The crate stores one `Vec` of all node values and another of all edge values and then only ever uses the indexes into those `Vec`s to refer to a node or edge. So, for example, the two nodes associated with an edge are stored in that edge simply as two `u32`s, rather than as references or reference-counted values.    The trick lies in how you support deletions. To delete a data entry, you first need to search for its index in all of the derived data structures and remove the corresponding entries, and then you need to remove the data from the root data store. If the root data store is a `Vec`, removing the entry will also change the index of one other data entry (when using `swap_remove`), so you then need to go update all the derived data structures to reflect the new index for the entry that moved.    ### Drop Guards    Drop guards provide a simple but reliable way to ensure that a bit of code runs even in the presence of panics, which is often essential in unsafe code. An example is a function that takes a closure `f: FnOnce` and executes it under mutual exclusion using atomics. Say the function uses `compare_exchange` (discussed in Chapter 10) to set a Boolean from `false` to `true`, calls `f`, and then sets the Boolean back to `false` to end the mutual exclusion. But consider what happens if `f` panics—the function will never get to run its cleanup, and no other call will be able to enter the mutual exclusion section ever again.    It’s possible to work around this using `catch_unwind`, but drop guards provide an alternative that is often more ergonomic. Listing 13-3 shows how, in our current example, we can use a drop guard to ensure the Boolean always gets reset.    ``` fn mutex(lock: &AtomicBool, f: impl FnOnce()) {     // .. while lock.compare_exchange(false, true).is_err() ..     struct DropGuard<'a>(&'a AtomicBool);     impl Drop for DropGuard<'_> {         fn drop(&mut self) {             self.0.store(true, Ordering::Release);         }     }     let _guard = DropGuard(lock);     f(); } ```    Listing 13-3: Using a drop guard to ensure code gets run after an unwinding panic    We introduce the local type `DropGuard` that implements `Drop` and place the cleanup code in its implementation of `Drop::drop`. Any necessary state can be passed in through the fields of `DropGuard`. Then, we construct an instance of the guard type just before we call the function that might panic, which is `f` here. When `f` returns, whether due to a panic or because it returns normally, the guard is dropped, its destructor runs, the lock is released, and all is well.    It’s important that the guard is assigned to a variable that is dropped at the end of the scope, after the user-provided code has been executed. This means that even though we never refer to the guard’s variable again, it needs to be given a name, as `let _ = DropGuard(lock)` would drop the guard immediately—before the user-provided code even runs!    This pattern is frequently used in conjunction with thread locals, when library code may wish to set the thread local state so that it’s valid only for the duration of the execution of the closure, and thus needs to be cleared afterwards. For example, at the time of writing, Tokio uses this pattern to provide information about the executor calling `Future::poll` to leaf resources like `TcpStream` without having to propagate that information through function signatures that are visible to users. It’d be no good if the thread local state continued to indicate that a particular executor thread was active even after `Future::poll` returned due to a panic, so Tokio uses a drop guard to ensure that the thread local state is reset.    ### Extension Traits    Extension traits allow crates to provide additional functionality to types that implement a trait from a different crate. For example, the `itertools` crate provides an extension trait for `Iterator`, which adds a number of convenient shortcuts for common (and not so common) iterator operations. As another example, `tower` provides `ServiceExt`, which adds several more ergonomic operations to wrap the low-level interface in the `Service` trait from `tower-service`.    Extension traits tend to be useful either when you do not control the base trait, as with `Iterator`, or when the base trait lives in a crate of its own so that it rarely sees breaking releases and thus doesn’t cause unnecessary ecosystem splits, as with `Service`.    An extension trait extends the base trait it is an extension of (`trait ServiceExt: Service`) and consists solely of provided methods. It also comes with a blanket implementation for any `T` that implements the base trait (`impl<T> ServiceExt for T where T: Service {}`). Together, these conditions ensure that the extension trait’s methods are available on anything that implements the base trait.    ### Crate Preludes    In Chapter 12, we talked about the standard library prelude that makes a number of types and traits automatically available without you having to write any `use` statements. Along similar lines, crates that export multiple types, traits, or functions that you’ll often use together sometimes define their own prelude in the form of a module called `prelude`, which re-exports some particularly common subset of those types, traits, and functions. There’s nothing magical about that module name, and it doesn’t get used automatically, but it serves as a signal to users that they likely want to add `use` `somecrate``::prelude::*` to files that want to use the crate in question. The `*` is a *glob import* and tells Rust to use all publicly available items from the indicated module. This can save quite a bit of typing when the crate has a lot of items you’ll usually need to name.    Preludes are also great for crates that expose a lot of extension traits, since trait methods can be called only if the trait that defines them is in scope. For example, the `diesel` crate, which provides ergonomic access to relational databases, makes extensive use of extension traits so you can write code like:    ``` posts.filter(published.eq(true)).limit(5).load::<Post>(&connection) ```    This line will work only if all the right traits are in scope, which the prelude takes care of.    In general, you should be careful when adding glob imports to your code, as they can potentially turn additions to the indicated module into backward-incompatible changes. For example, if someone adds a new trait to a module you glob-import from, and that new trait makes a method `foo` available on a type that already had some other `foo` method, code that calls `foo` on that type will no longer compile as the call to `foo` is now ambiguous. Interestingly enough, while the existence of glob imports makes any module addition a technically breaking change, the Rust RFC on API evolution (RFC 1105; see [`rust-lang.github.io/rfcs/1105-api-evolution.html`](https://rust-lang.github.io/rfcs/1105-api-evolution.html)) does *not* require a library to issue a new major version for such a change. The RFC goes into great detail about why, and I recommend you read it, but the gist is that minor releases are allowed to require minimally invasive changes to dependents, like having to add type annotations in edge cases, because otherwise a large fraction of changes would require new major versions despite being very unlikely to actually break any consumers.    Specifically in the case of preludes, using glob imports is usually fine when recommended by the vending crate, since its maintainers know that their users will use glob imports for the prelude module and thus will take that into account when deciding whether a change requires a major version bump.    ## Staying Up to Date    Rust, being such a young language, is evolving rapidly. The language itself, the standard library, the tooling, and the broader ecosystem are all still in their infancy, and new developments happen every day. While staying on top of all the changes would be infeasible, it’s worth your time to keep up with significant developments so that you can take advantage of the latest and greatest features in your projects.    For monitoring improvements to Rust itself, including new language features, standard library additions, and core tooling upgrades, the official Rust blog at [`blog.rust-lang.org/`](https://blog.rust-lang.org/)is a good, low-volume place to start. It mainly features announcements for each new Rust release. I recommend you make a habit of reading these, as they tend to include interesting tidbits that will slowly but surely deepen your knowledge of the language. To dig a little deeper, I highly recommend reading the detailed changelogs for Rust and Cargo as well (links can usually be found near the bottom of each release announcement). The changelogs surface changes that weren’t large enough to warrant a paragraph in the release notes but that may be just what you need two weeks from now. For a less frequently updated news source, check in on *The Edition Guide* at [`doc.rust-lang.org/edition-guide/`](https://doc.rust-lang.org/edition-guide/), which outlines what’s new in each Rust edition. Rust editions tend to be released every three years.    If you’re curious about how Rust itself is developed, you may also want to subscribe to the *Inside Rust* blog at[`blog.rust-lang.org/inside-rust/`](https://blog.rust-lang.org/inside-rust/). It includes updates from the various Rust teams, as well as incident reports, larger change proposals, edition planning information, and the like. To get involved in Rust development yourself—which I highly encourage, as it’s a lot of fun and a great learning experience—you can check out the various Rust working groups at [`www.rust-lang.org/governance/`](https://www.rust-lang.org/governance/), which each focus on improving a specific aspect of Rust. Find one that appeals to you, check in with the group wherever it meets and ask how you may be able to help. You can also join the community discussion about Rust internals over at [`internals.rust-lang.org/`](https://internals.rust-lang.org/); this is another great way to get insight into the thought that goes into every part of Rust’s design and development.    As is the case for most programming languages, much of Rust’s value is derived from its community. Not only do the members of the Rust community constantly develop new work-saving crates and discover new Rust-specific techniques and design patterns, but they also collectively and continuously help one another understand, document, and explain how to take best advantage of the Rust language. Everything I have covered in this book, and much more, has already been discussed by the community in thousands of comment threads, blog posts, and Twitter and Discord conversations. Dipping into these discussions even just once in a while is almost guaranteed to show you new things about a language feature, a technique, or a crate that you didn’t already know.    The Rust community lives in a lot of places, but some good places to start are the Users forum ([`users.rust-lang.org/`](https://users.rust-lang.org/)), the Rust subreddit ([`www.reddit.com/r/rust/`](https://www.reddit.com/r/rust/)), the Rust Community Discord ([`discord.gg/rust-lang-community`](https://discord.gg/rust-lang-community)), and the Rust Twitter account ([`twitter.com/rustlang`](https://twitter.com/rustlang)). You don’t have to engage with all of these, or all of the time—pick one you like the vibe of, and check in occasionally!    A great single location for staying up to date with ongoing developments is the *This Week in Rust* blog ([`this-week-in-rust.org/`](https://this-week-in-rust.org/)), a “weekly summary of [Rust’s] progress and community.” It links to official announcements and changelogs as well as popular community discussions and resources, interesting new crates, opportunities for contributions, upcoming Rust events, and Rust job opportunities. It even lists interesting language RFCs and compiler PRs, so this site truly has it all! Discerning what information is valuable to you and what isn’t may be a little daunting, but even just scrolling through and clicking occasional links that appear interesting is a good way to keep a steady stream of new Rust knowledge trickling into your brain.    ## What Next?    So, you’ve read this book front to back, absorbed all the knowledge it imparts, and are still hungry for more? Great! There are a number of other excellent resources out there for broadening and deepening your knowledge and understanding of Rust, and in this very final section I’ll give you a survey of some of my favorites so that you can keep learning. I’ve divided them into subsections based on how different people prefer to learn so that you can find resources that’ll work for you.    ### Learn by Watching    Watching experienced developers code is essentially a life hack to remedy the slow starting phase of solo learning. It allows you to observe the process of designing and building while utilizing someone else’s experience. Listening to experienced developers articulate their thinking and explain tricky concepts or techniques as they come up can be an excellent alternative to struggling through problems on your own. You’ll also pick up a variety of auxiliary knowledge like debugging techniques, design patterns, and best practices. Eventually you will have to sit down and do things yourself—it’s the only way to check that you actually understand what you’ve observed—but piggybacking on the experience of others will almost certainly make the early stages more pleasant. And if the experience is interactive, that’s even better!    So, with that said, here are some Rust video channels that I recommend:    1.  Perhaps unsurprisingly, my own channel:[`www.youtube.com/c/JonGjengset/`](https://www.youtube.com/c/JonGjengset/). I have a mix of long-form coding videos and short(er) code-based theory/concept explanation videos, as well as occasional videos that dive into interesting Rust coding stories. 2.  The *Awesome Rust Streaming* listing: [`github.com/jamesmunns/awesome-rust-streaming/`](https://github.com/jamesmunns/awesome-rust-streaming/). This resource lists a wide variety of developers who stream Rust coding or other Rust content. 3.  The channel of Tim McNamara, the author of *Rust in Action*: [`www.youtube.com/c/timClicks/`](https://www.youtube.com/c/timClicks/). Tim’s channel, like mine, splits its time between implementation and theory, though Tim has a particular knack for creative visual projects, which makes for fun viewing. 4.  Jonathan Turner’s *Systems with JT* channel: [`www.youtube.com/c/SystemswithJT/`](https://www.youtube.com/c/SystemswithJT/). Jonathan’s videos document their work on Nushell, their take on a “new type of shell,” providing a great sense of what it’s like to work on a nontrivial existing codebase. 5.  Ryan Levick’s channel: [`www.youtube.com/c/RyanLevicksVideos/`](https://www.youtube.com/c/RyanLevicksVideos/). Ryan mainly posts videos that tackle particular Rust concepts and walks through them using concrete code examples, but he also occasionally does implementation videos (like FFI for Microsoft Flight Simulator!) and deep dives into how well-known crates work under the hood.    Given that I make Rust videos, it should come as no surprise that I am a fan of this approach to teaching. But this kind of receptive or interactive learning doesn’t have to come in the form of videos. Another great avenue for learning from experienced developers is pair programming. If you have a colleague or friend with expertise in a particular aspect of Rust you’d like to learn, ask if you can do a pair-programming session with them to solve a problem together!    ### Learn by Doing    Since your ultimate goal is to get better at writing Rust, there’s no substitute for programming experience. No matter what or how many resources you learn from, you need to put that learning into practice. However, finding a good place to start can be tricky, so here I’ll give some suggestions.    Before I dive into the list, I want to provide some general guidance on how to pick projects. First, choose a project that *you* care about, without worrying too much whether others care about it. While there are plenty of popular and established Rust projects out there that would love to have you as a contributor, and it’s fun to be able to say “I contributed to the well-known library X,” your first priority must be your own interest. Without concrete motivation, you’ll quickly lose steam and find contributing to be a chore. The very best targets are projects that you use yourself and have experienced problems with—go fix them! Nothing is more satisfying than getting rid of a long-standing personal nuisance while also contributing back to the community.    Okay, so back to project suggestions. First and foremost, consider contributing to the Rust compiler and its associated tools. It’s a high-quality codebase with good documentation and an endless supply of issues (you probably know of some yourself), and there are several great mentors who can provide outlines for how to approach solving issues. If you look through the issue tracker for issues marked E-easy or E-mentor, you’ll likely find a good candidate quickly. As you gain more experience, you can keep leveling up to contribute to trickier parts.    If that’s not your cup of tea, I recommend finding something you use frequently that’s written in another language and porting it to Rust—not necessarily with the intention of replacing the original library or tool, but just because the experience will allow you to focus on writing Rust without having to spend too much time coming up with all the functionality yourself. If it turns out well, the fact that it already exists suggests that someone else also needed it, so there may be a wider audience for your port too! Data structures and command-line tools often make for great porting subjects, but find a niche that appeals to you.    Should you be more of a “build it from scratch” kind of person, I recommend looking back at your own development experience so far and thinking about similar code you’ve ended up writing in multiple projects (whether in Rust or in other languages). Such repetition tends to be a good signal that something is reusable and could be turned into a library. If nothing comes to mind, David Tolnay maintains a list of smaller utility crates that other Rust developers have requested at [`github.com/dtolnay/request-for-implementation/`](https://github.com/dtolnay/request-for-implementation/) that may provide a source of inspiration. If you’re looking for something more substantial and ambitious, there’s also the Not Yet Awesome list at [`github.com/not-yet-awesome-rust/not-yet-awesome-rust/`](https://github.com/not-yet-awesome-rust/not-yet-awesome-rust/) that lists things that should exist in Rust but don’t (yet).    ### Learn by Reading    Although the state of affairs is constantly improving, finding good Rust reading material beyond the beginner level can still be tricky. Here’s a collection of pointers to some of my favorite resources that continue to teach me new things or serve as good references when I have particularly niche or nuanced questions.    First, I recommend looking through the official virtual Rust books linked from [`www.rust-lang.org/learn/`](https://www.rust-lang.org/learn/). Some, like the Cargo book, are more reference-like while others, like the Embedded book, are more guide-like, but they’re all deep sources of solid technical information about their respective topics. *The Rustonomicon* ([`doc.rust-lang.org/nomicon/`](https://doc.rust-lang.org/nomicon/)), in particular, is a lifesaver when you’re writing unsafe code.    Two more books that are worth checking out are the *Guide to rustc Development* ([`rustc-dev-guide.rust-lang.org/`](https://rustc-dev-guide.rust-lang.org/)) and the *Standard Library Developers Guide* ([`std-dev-guide.rust-lang.org/`](https://std-dev-guide.rust-lang.org/)). These are fantastic resources if you’re curious about how the Rust compiler does what it does or how the standard library is designed, or if you want some pointers before you try your hand at contributing to Rust itself. The official Rust guidelines are also a treasure trove of information; I’ve already mentioned the *Rust API Guidelines* ([`rust-lang.github.io/api-guidelines/`](https://rust-lang.github.io/api-guidelines/)) in the book, but a *Rust Unsafe Code Guidelines Reference* is also available ([`rust-lang.github.io/unsafe-code-guidelines/`](https://rust-lang.github.io/unsafe-code-guidelines/)), and by the time you read this book there may be more.    There are also a number of unofficial virtual Rust books that are enormously valuable collections of experience and knowledge. *The Little Book of Rust Macros* ([`veykril.github.io/tlborm/`](https://veykril.github.io/tlborm/)), for example, is indispensable if you want to write nontrivial declarative macros, and *The Rust Performance Book* ([`nnethercote.github.io/perf-book/`](https://nnethercote.github.io/perf-book/)) is filled with tips and tricks for improving the performance of Rust code both at the micro and the macro level. Other great resources include the *Rust Fuzz Book* ([`rust-fuzz.github.io/book/`](https://rust-fuzz.github.io/book/)), which explores fuzz testing in more detail, and the *Rust Cookbook* ([`rust-lang-nursery.github.io/rust-cookbook/`](https://rust-lang-nursery.github.io/rust-cookbook/)), which suggests idiomatic solutions to common programming tasks. There’s even a resource for finding more books, *The Little Book of Rust Books* ([`lborb.github.io/book/unofficial.html`](https://lborb.github.io/book/unofficial.html))!    If you prefer more hands-on reading, the Tokio project has published *mini-redis* ([`github.com/tokio-rs/mini-redis/`](https://github.com/tokio-rs/mini-redis/)), an incomplete but idiomatic implementation of a Redis client and server that’s extremely well documented and specifically written to serve as a guide to writing asynchronous code. If you’re more of a data structures person, *Learn Rust with Entirely Too Many Linked Lists* ([`rust-unofficial.github.io/too-many-lists/`](https://rust-unofficial.github.io/too-many-lists/)) is an enlightening and fun read that gets into lots of gnarly details about ownership and references. If you’re looking for something closer to the hardware, Philipp Oppermann’s *Writing an OS in Rust* ([`os.phil-opp.com/`](https://os.phil-opp.com/)) goes through the whole operating system stack in great detail while teaching you good Rust patterns in the process. I also highly recommend Amos’s collection of articles ([`fasterthanli.me/tags/rust/`](https://fasterthanli.me/tags/rust/)) if you want a wide sampling of interesting deep dives written in a conversational style.    When you feel more confident in your Rust abilities and need more of a quick reference than a long tutorial, I’ve found the *Rust Language Cheat Sheet* ([`cheats.rs/`](https://cheats.rs/)) great for looking things up quickly. It also provides very nice visual explanations for most topics, so even if you’re looking up something you’re not intimately familiar with already, the explanations are pretty approachable.    And finally, if you want to put all of your Rust understanding to the test, go give David Tolnay’s *Rust Quiz* ([`dtolnay.github.io/rust-quiz/`](https://dtolnay.github.io/rust-quiz/)) a try. There are some real mind-benders in there, but each question comes with a thorough explanation of what’s going on, so even if you get one wrong, you’ll have learned from the experience!    ### Learn by Teaching    My experience has been that the best way to learn something well and thoroughly, by far, is to try to teach it to others. I have learned an enormous amount from writing this book, and I learn new things every time I make a new Rust video or podcast episode. So, I wholeheartedly recommend that you try your hand at teaching others about some of the things you’ve learned from reading this book or that you learn from here on out. It can take whatever form you prefer: in person, writing a blog post, tweeting, making a video or podcast, or giving a talk. The important thing is that you try to convey your newfound knowledge in your own words to someone who doesn’t already understand the topic—in doing so, you also give back to the community so that the next you that comes along has a slightly easier time getting up to speed. Teaching is a humbling and deeply educational experience, and I cannot recommend it highly enough.    ## Summary    In this chapter, we’ve covered Rust beyond what exists in your local workspace. We surveyed useful tools, libraries, and Rust features; looked at how to stay up to date as the ecosystem continues to evolve; and then discussed how you can get your hands dirty and contribute back to the ecosystem yourself. Finally, we discussed where you can go next to continue your Rust journey now that this book has reached its end. And with that, there’s little more to do than to declare:    ``` } ``` ````
