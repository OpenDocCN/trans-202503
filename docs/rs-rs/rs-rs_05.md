# 第五章：项目结构

![](img/chapterart.png)

本章提供了一些关于如何构建 Rust 项目的思路。对于简单的项目，`cargo new` 创建的结构可能是你几乎不需要考虑的。你可能会添加一些模块来拆分代码，添加一些依赖项以获得额外的功能，但大致就是这样。然而，随着项目规模和复杂度的增长，你会发现你需要超越这一点。也许你的 crate 的编译时间失控了，或者你需要条件依赖，或者你需要更好的持续集成策略。在本章中，我们将看看 Rust 语言以及 Cargo 特别提供的一些工具，这些工具使得管理这些问题变得更加容易。

## 特性

*特性*是 Rust 自定义项目的主要工具。从本质上讲，特性只是一个构建标志，crate 可以将其传递给依赖项，以便添加可选功能。特性本身没有语义意义——相反，*你*决定特性对*你的* crate 意味着什么。

通常，我们以三种方式使用特性：启用可选依赖项、根据条件包含 crate 的额外组件以及增强代码的行为。请注意，这些用途都是*增量*的；特性可以增强 crate 的功能，但通常不应做诸如移除模块或替换类型或函数签名之类的事情。这源于这样一个原则：如果开发者对自己的 *Cargo.toml* 做了一个简单的更改，例如添加一个新依赖或启用一个特性，这不应该导致他们的 crate 无法编译。如果一个 crate 具有互斥的特性，这个原则将很快失效——如果 crate A 依赖于 crate C 的某个特性，而 crate B 依赖于 crate C 的另一个互斥特性，那么添加对 crate B 的依赖将会破坏 crate A！因此，我们通常遵循一个原则，即如果 crate A 在 crate C 上编译时启用了某些特性，它也应该在 crate C 启用所有特性时成功编译。

Cargo 在这一原则上非常坚持。例如，如果两个 crate（A 和 B）都依赖于 crate C，但它们分别启用了 C 上的不同特性，Cargo 只会编译一次 crate C，包含 A 或 B 所需的*所有*特性。也就是说，它会合并 A 和 B 中对 C 请求的特性。因此，一般来说，很难向 Rust crate 添加互斥特性；因为有可能两个依赖项会依赖于具有不同特性的 crate，如果这些特性是互斥的，下游 crate 将无法编译。

### 定义和包含特性

特性在 *Cargo.toml* 中定义。示例 5-1 展示了一个名为 `foo` 的 crate 的例子，该 crate 启用了一个简单的特性，用于启用可选依赖项 `syn`。

```
[package]
name = "foo"
...
[features]
derive = ["syn"]

[dependencies]
syn = { version = "1", optional = true }
```

示例 5-1：启用可选依赖项的特性

当 Cargo 编译这个 crate 时，默认情况下不会编译`syn` crate，这样可以减少编译时间（通常是显著减少）。只有当下游 crate 需要使用由`derive`特性启用的 API，并且明确选择启用该特性时，`syn` crate 才会被编译。列表 5-2 展示了如何让下游 crate `bar`启用`derive`特性，从而包含`syn`依赖。

```
[package]
name = "bar"
...
[dependencies]
foo = { version = "1", features = ["derive"] }
```

列表 5-2：启用依赖的特性

有些特性使用得非常频繁，以至于让 crate 选择退出这些特性比选择启用它们更为合理。为了支持这一点，Cargo 允许你为一个 crate 定义一组默认特性。同样，它也允许你选择退出依赖的默认特性。列表 5-3 展示了`foo`如何使其`derive`特性默认启用，同时选择退出`syn`的某些默认特性，仅启用`derive`特性所需的特性。

```
[package]
name = "foo"
...
[features]
derive = ["syn"]
default = ["derive"]

[dependencies.syn]
version = "1"
default-features = false
features = ["derive", "parsing", "printing"]
optional = true
```

列表 5-3：添加并选择退出默认特性，从而管理可选依赖

在这里，如果一个 crate 依赖于`foo`并且没有明确选择退出默认特性，它也会编译`foo`的`syn`依赖。反过来，`syn`将仅使用列出的三个特性进行构建，不会包含其他特性。以这种方式退出默认特性，并仅选择所需的特性，是减少编译时间的好方法！

### 在你的 crate 中使用特性

在使用特性时，你需要确保只有在依赖可用时才使用它。而且，如果你的特性启用了某个特定组件，你需要确保如果该特性没有启用，那么该组件不会被包含。

你可以通过使用*条件编译*来实现这一点，它让你使用注释来指定在特定条件下某段代码是否应该被编译。条件编译主要通过`#[cfg]`属性来表示。同时，还有一个紧密相关的`cfg!`宏，它让你根据类似的条件来改变运行时行为。通过条件编译，你可以做很多有趣的事情，正如我们在本章稍后会看到的，但最基本的形式是`#[cfg(feature = "some-feature")]`，它的作用是仅在启用了`some-feature`特性时，才会编译源代码中的下一项内容。类似地，`if cfg!(feature = "some-feature")`仅在启用了`derive`特性时，相当于`if true`（否则为`if false`）。

`#[cfg]` 属性比 `cfg!` 宏使用得更多，因为宏基于功能修改运行时行为，这可能使得确保功能是可添加的变得困难。您可以将 `#[cfg]` 放置在某些 Rust *项* 前面—例如函数和类型定义、`impl` 块、模块和 `use` 语句，也可以放置在其他一些结构上，如结构体字段、函数参数和语句上。不过，`#[cfg]` 属性不能随便放置；其出现位置受到 Rust 语言团队的严格限制，以避免条件编译导致过于奇怪且难以调试的情况。

请记住，修改 API 的某些公共部分可能会无意中使某个功能变得不可添加，这可能会导致某些用户无法编译您的 crate。您通常可以将向后兼容性更改的规则作为一个经验法则—例如，如果您使一个枚举变体或公共结构体字段依赖于某个功能，那么该类型也必须使用`#[non_exhaustive]`进行注解。否则，如果由于依赖树中的另一个 crate 添加了该功能，那么没有启用该功能的依赖 crate 可能将无法再编译。

## 工作区

Crate 在 Rust 中扮演着多种角色——它们是依赖图中的顶点，是特性一致性的边界，也是编译特性的作用域。因此，每个 crate 都作为一个单独的编译单元进行管理；Rust 编译器将 crate 视为一个大的源文件，将其作为一个整体编译，最终生成一个单一的二进制输出（可以是二进制文件或库）。

虽然这简化了编译器的许多方面，但也意味着大型 crate 的使用可能会变得十分麻烦。如果您更改了应用程序中某个部分的单元测试、注释或类型，编译器必须重新评估整个 crate，以确定是否发生了变化。编译器内部实现了许多加速这一过程的机制，如增量重编译和并行代码生成，但最终 crate 的大小是影响项目编译时间的一个重要因素。

因此，随着项目的增长，您可能希望将其拆分为多个相互依赖的 crate。Cargo 提供了一个非常方便的功能来实现这一点：工作区（workspaces）。一个*工作区*是由多个 crate（通常称为*子 crate*）组成的集合，它们通过一个顶级的*Cargo.toml* 文件相互关联，就像在清单 5-4 中展示的那样。

```
[workspace]
members = [
  "foo",
  "bar/one",
  "bar/two",
]
```

清单 5-4：一个工作区 *Cargo.toml*

`members`数组是一个包含工作区中每个 crate 所在目录的列表。这些 crate 各自有自己子目录中的*Cargo.toml*文件，但它们共享一个*Cargo.lock*文件和一个输出目录。crate 的名称不需要与`members`中的条目匹配。虽然不是强制要求，但工作区中的 crate 通常共享一个名称前缀，通常选择“主”crate 的名称。例如，在`tokio` crate 中，成员分别是`tokio`、`tokio-test`、`tokio-macros`，等等。

也许工作区最重要的功能是，你可以通过在工作区根目录下调用`cargo`与工作区的所有成员交互。想检查它们是否都能编译？`cargo check`会检查它们所有的情况。想运行所有测试？`cargo test`会测试所有的。虽然这不像将所有内容放在一个 crate 中那么方便，所以不要将一切拆分成极小的 crate，但这是一个相当不错的近似。

一旦你拥有一个包含工作区成员数组的工作区级别的*Cargo.toml*，你可以通过路径依赖将你的 crate 彼此依赖，如示例 5-5 所示。

```
# bar/two/Cargo.toml
[dependencies]
one = { path = "../one" }
# bar/one/Cargo.toml
[dependencies]
foo = { path = "../../foo" }
```

示例 5-5：工作区 crate 之间的互依赖

现在，如果你对*bar/two*中的 crate 进行修改，那么只有这个 crate 会重新编译，因为`foo`和*bar/one*没有发生变化。从头开始编译你的项目可能会更快，因为编译器不需要评估整个项目源代码来寻找优化机会。

## 项目配置

运行`cargo new`会为你创建一个最小的*Cargo.toml*，其中包含 crate 的名称、版本号、一些作者信息和一个空的依赖列表。这会让你走得很远，但随着项目的成熟，你可能会想在*Cargo.toml*中添加一些有用的内容。

### 创建元数据

添加到你的*Cargo.toml*文件中最先且最明显的事情是所有 Cargo 支持的元数据指令。除了像`description`和`homepage`这样的明显字段外，包含一些信息也很有用，比如 crate 的*README*路径（`readme`）、与`cargo run`一起运行的默认二进制文件（`default-run`），以及额外的`keywords`和`categories`，这些有助于*crates.io*对你的 crate 进行分类。

对于具有更复杂项目布局的 crate，设置`include`和`exclude`元数据字段也很有用。这些字段决定了哪些文件应该包含在你的包中并发布。默认情况下，Cargo 会包含 crate 目录中的所有文件，除了任何在*.gitignore*文件中列出的文件，但如果你在同一目录中有大型测试夹具、不相关的脚本或其他辅助数据，并且这些数据确实需要版本控制，那么这可能不是你想要的。正如它们的名称所示，`include`和`exclude`分别允许你仅包含特定的文件集或排除符合给定模式的文件。

你可以使用的元数据指令列表不断增长，所以请定期查看 Cargo 文档中的 Manifest 格式页面（[`doc.rust-lang.org/cargo/reference/manifest.html`](https://doc.rust-lang.org/cargo/reference/manifest.html)）。

### 构建配置

*Cargo.toml* 还可以让你控制 Cargo 如何构建你的 crate。最明显的工具是 `build` 参数，它允许你为 crate 编写完全自定义的构建程序（我们将在第十一章中回顾这一点）。然而，Cargo 还提供了两个较小但非常有用的机制，我们将在这里探讨：补丁和配置文件。

#### [patch]

*Cargo.toml* 中的 `[patch]` 部分允许你为依赖项指定一个不同的源，可以临时使用，无论这个补丁依赖项在你的依赖链中出现的位置在哪里。当你需要编译你的 crate 以测试某个修复的 bug、性能提升或即将发布的新小版本时，这一点尤为重要。列表 5-6 展示了如何临时使用一组依赖项的变体。

```
[patch.crates-io]
# use a local (presumably modified) source
regex = { path = "/home/jon/regex" }
# use a modification on a git branch
serde = { git = "https://github.com/serde-rs/serde.git", branch = "faster" }
# patch a git dependency
[patch.'https://github.com/jonhoo/project.git']
project = { path = "/home/jon/project" }
```

列表 5-6：使用 `[patch]` 在 *Cargo.toml* 中覆盖依赖源

即使你对某个依赖项进行了补丁，Cargo 也会仔细检查 crate 版本，以确保你不会不小心补丁错误的主版本。如果出于某种原因，你的 crate 依赖于同一个 crate 的多个主版本，你可以通过为它们分配不同的标识符来为每个版本打补丁，就像在 列表 5-7 中展示的那样。

```
[patch.crates-io]
nom4 = { path = "/home/jon/nom4", package = "nom" }
nom5 = { path = "/home/jon/nom5", package = "nom" }
```

列表 5-7：使用 `[patch]` 在 *Cargo.toml* 中覆盖同一 crate 的多个版本

Cargo 会查看每个路径中的 *Cargo.toml*，识别出 `/nom4` 包含主版本 4，而 `/nom5` 包含主版本 5，并相应地对这两个版本进行补丁。`package` 关键字告诉 Cargo 查找名为 `nom` 的 crate，而不是像默认那样使用依赖标识符（左侧部分）。你也可以在常规依赖项中以这种方式使用 `package` 来重命名依赖项！

请记住，在发布 crate 时上传的包不会考虑补丁。依赖于你 crate 的 crate 将只使用它自己 `[patch]` 部分（可能为空），而不会使用你 crate 的 `[patch]` 部分！

#### [profile]

`[profile]` 部分允许你传递额外的选项给 Rust 编译器，以改变编译 crate 的方式。这些选项主要分为三类：性能选项、调试选项和改变代码行为的用户自定义选项。根据你是以调试模式还是发布模式进行编译（当然还有其他模式），它们有不同的默认设置。

三个主要的性能选项是 `opt-level`、`codegen-units` 和 `lto`。`opt-level` 选项通过告诉编译器如何积极地优化程序来调整运行时性能（`0` 是“完全不优化”，`3` 是“尽可能多地优化”）。设置越高，代码就会被优化得越多，这 *可能* 会使程序运行得更快。不过，额外的优化会带来更高的编译时间，这也是为什么通常只在发布版本中启用优化的原因。

`codegen-units` 选项关系到编译时性能。它告诉编译器允许将单个 crate 的编译拆分成多少个独立的编译任务（*代码生成单元*）。一个大 crate 的编译被拆分成更多的部分，编译速度会更快，因为更多的线程可以帮助并行编译 crate。不幸的是，为了实现这一加速，线程需要尽可能独立工作，这意味着代码优化会受到影响。例如，假设在一个线程中编译的 crate 部分可以通过内联其他部分的代码来受益——但由于这两个部分是独立的，内联无法发生！因此，这个设置是在编译时性能和运行时性能之间的折衷。默认情况下，Rust 在调试模式下使用几乎没有限制的代码生成单元数量（基本上是“尽可能快地编译”），而在发布模式下使用较少的数量（写作时为 16）。

`lto` 设置切换 *链接时优化（LTO）*，它使得编译器（或者更技术性地说是链接器）能够共同优化程序的各个部分，这些部分原本是分别编译的，称为 *编译单元*。LTO 的具体细节超出了本书的范围，但基本思想是，每个编译单元的输出包括了关于该单元所包含代码的信息。当所有单元编译完成后，链接器会再次遍历所有单元，并利用这些额外的信息来优化合并后的编译代码。这一额外的处理步骤会增加编译时间，但能够恢复大部分由于将编译拆分成更小部分而损失的运行时性能。特别是，LTO 可以为性能敏感的程序提供显著的性能提升，这些程序可能从跨 crate 的优化中受益。然而，需要注意的是，跨 crate 的 LTO 可能会显著增加编译时间。

Rust 默认在每个 crate 内的所有 codegen 单元之间执行 LTO，以弥补使用多个 codegen 单元时导致的优化损失。由于 LTO 仅在每个 crate 内执行，而不是跨 crate 执行，因此这个额外的过程并不会太繁重，且增加的编译时间应当低于使用大量 codegen 单元所节省的时间。Rust 还提供了一种名为*薄 LTO*（thin LTO）的方法，该方法允许 LTO 过程大部分并行化，但代价是错过一些“完整” LTO 过程会找到的优化。

`[profile]` 部分还支持有助于调试的标志，如 `debug`、`debug-assertions` 和 `overflow-checks`。`debug` 标志告诉编译器在编译的二进制文件中包含调试符号。这会增加二进制文件的大小，但它意味着在回溯和性能分析中，你将看到函数名等，而不是仅仅是指令地址。`debug-assertions` 标志启用 `debug_assert!` 宏和其他相关的调试代码，这些代码默认情况下不会编译（通过 `cfg(debug_assertions)`）。这些代码可能会使程序运行变慢，但它能帮助你在运行时捕捉到可疑行为。`overflow-checks` 标志，顾名思义，会在整数操作中启用溢出检查。这会使操作变慢（注意到一个趋势了吗？），但可以帮助你早期发现棘手的 bug。默认情况下，这些选项在调试模式下是启用的，在发布模式下是禁用的。

#### [profile.*.panic]

`[profile]` 部分有一个需要单独小节讨论的标志：`panic`。这个选项决定了程序中的代码在调用 `panic!` 时（无论是直接调用还是通过类似 `unwrap` 的间接调用）会发生什么。你可以将 `panic` 设置为 `unwind`（大多数平台的默认值）或 `abort`。我们将在第九章中更详细地讨论 panic 和展开的内容，但这里我会给出一个简要总结。

在 Rust 中，通常当程序发生 panic 时，发生 panic 的线程会开始*展开*其栈。你可以将展开理解为强制从当前函数递归返回，直到回到该线程栈的底部。也就是说，如果 `main` 调用了 `foo`，`foo` 调用了 `bar`，`bar` 调用了 `baz`，那么 `baz` 中发生 panic 时会强制从 `baz` 返回，然后是 `bar`，然后是 `foo`，最后是 `main`，从而导致程序退出。发生展开的线程会正常地丢弃栈上的所有值，这为这些值提供了清理资源、报告错误等的机会。这使得即使在发生 panic 的情况下，运行中的系统也有机会优雅地退出。

当一个线程发生 panic 并展开时，其他线程会继续运行，不受影响。只有当（如果）运行 `main` 的线程退出时，程序才会终止。也就是说，panic 通常仅限于发生 panic 的线程。

这意味着堆栈展开是一把双刃剑；程序在某些组件失败的情况下勉强运行，这可能导致各种奇怪的行为。例如，想象一个线程在更新`Mutex`状态的过程中发生恐慌。任何后续获取该`Mutex`的线程都必须准备好处理状态可能处于部分更新、不一致的情况。因此，一些同步原语（如`Mutex`）会记住上次访问时是否发生了恐慌，并将这一信息传递给任何后续尝试访问该原语的线程。如果线程遇到这种状态，它通常也会发生恐慌，从而导致级联效应，最终终止整个程序。但可以说，这比在损坏的状态下继续运行要好得多！

支持堆栈展开所需的记录并非免费的，它通常需要编译器和目标平台的特别支持。例如，许多嵌入式平台根本无法有效地展开堆栈。因此，Rust 支持一种不同的恐慌模式：`abort`，它确保当发生恐慌时，整个程序会立即退出。在这种模式下，所有线程都不会进行任何清理工作。这可能显得很严厉，确实如此，但它确保了程序永远不会在半工作状态下运行，并且错误能够立即显现出来。

你可能注意到，当一个线程发生恐慌时，它往往会打印出*回溯*信息：导致恐慌发生的函数调用轨迹。这也是一种堆栈展开，尽管它与这里讨论的堆栈展开恐慌行为是不同的。即使使用`panic=abort`，通过传递`-Cforce-unwind-tables`给`rustc`，你仍然可以获取回溯信息，这会使`rustc`包含必要的信息，以便在终止程序的同时回溯堆栈。

## 条件编译

你编写的大多数 Rust 代码是通用的——无论它运行在什么 CPU 或操作系统上，都会以相同的方式工作。但有时你必须做一些特殊的事情，才能让代码在 Windows 上、ARM 芯片上，或者在针对特定平台应用程序二进制接口（ABI）编译时正常工作。或者，可能你希望在某个特定的 CPU 指令可用时，编写某个函数的优化版本，或者在持续集成（CI）环境中禁用一些慢但无关紧要的设置代码。为了应对这些情况，Rust 提供了*条件编译*机制，其中只有在特定的编译环境条件为真时，某个代码片段才会被编译。

我们使用`cfg`关键字来表示条件编译，你在本章的“在你的 crate 中使用功能”部分曾看到过它。它通常以`#[cfg(condition)]`属性的形式出现，表示仅在`condition`为真时编译下一个项目。Rust 还提供了`#[cfg_attr(condition, attribute)]`，当`condition`为真时，它会被编译为`#[attribute]`，否则它不做任何操作。你还可以使用`cfg!(condition)`宏将`cfg`条件作为布尔表达式进行评估。

每个`cfg`构造都接受一个由选项组成的单一条件，比如`feature = "some-feature"`，以及组合器`all`、`any`和`not`，它们的功能大致如你所预期。选项可以是简单的名称，如`unix`，或者是像特性条件中使用的键值对。

有一些有趣的选项可以让编译依赖于特定条件。我们来逐一介绍它们，从最常见的到最不常见的：

**特性选项**

1.  你已经看过这些例子。特性选项以`feature = "name-of-feature"`的形式出现，当指定的特性启用时，它们为真。你可以使用组合器在一个条件中检查多个特性。例如，`any(feature = "f1", feature = "f2")`在`f1`或`f2`中的任意一个特性启用时为真。

**操作系统选项**

1.  这些使用键值语法，键为`target_os`，值如`windows`、`macos`和`linux`。你还可以使用`target_family`指定一个操作系统系列，它的值可以是`windows`或`unix`。这些选项足够常见，因此它们有自己的简短命名形式，你可以直接使用`cfg(windows)`和`cfg(unix)`。例如，如果你希望某段代码仅在 macOS 和 Windows 上编译，可以写成：`#[cfg(any(windows, target_os = "macos"))]`。

**上下文选项**

1.  这些选项让你根据特定的编译上下文来调整代码。最常见的选项是`test`选项，只有在 crate 以测试配置编译时它才为真。请记住，`test`仅针对正在测试的 crate 设置，而不是它的任何依赖项。这也意味着，在运行集成测试时，你的 crate 并不会设置`test`，而是集成测试在测试配置下编译，而你的实际 crate 则正常编译（也就是没有设置`test`）。`doc`和`doctest`选项也同样如此，只有在构建文档或编译文档测试时才会设置。还有`debug_assertions`选项，它默认在调试模式下设置。

**工具选项**

1.  一些工具，如 clippy 和 Miri，设置了自定义选项（稍后会详细介绍），让你在这些工具下运行时自定义编译。通常，这些选项以相关工具的名称命名。例如，如果你不希望某个计算密集型测试在 Miri 下运行，你可以为其设置`#[cfg_attr(miri, ignore)]`属性。

**架构选项**

1.  这些选项让你可以根据编译器目标的 CPU 指令集来编译代码。你可以通过`target_arch`指定特定的架构，`target_arch`接受像`x86`、`mips`、`aarch64`这样的值，或者你可以通过`target_feature`指定特定的平台特性，`target_feature`接受像`avx`或`sse2`这样的值。对于非常底层的代码，你还可能发现`target_endian`和`target_pointer_width`选项非常有用。

**编译器选项**

1.  这些选项让你可以将代码适配到其编译目标平台的 ABI，并且可以通过`target_env`来使用，`target_env`的值包括`gnu`、`msvc`和`musl`。出于历史原因，这个值在 GNU 平台上通常为空。通常，只有在你需要直接与环境 ABI 接口时，才需要这个选项，例如在使用`#[link]`链接到 ABI 特定符号名称时。

虽然`cfg`条件通常用于定制代码，但也有一些可以用于定制依赖项。例如，依赖项`winrt`通常只有在 Windows 系统上才有意义，而`nix` crate 可能只在 Unix-based 平台上有用。列表 5-9 提供了一个如何使用`cfg`条件的示例：

```
[target.'cfg(windows)'.dependencies]
winrt = "0.7"
[target.'cfg(unix)'.dependencies]
nix = "0.17"
```

列表 5-9: 条件依赖

在这里，我们指定只有在`cfg(windows)`条件下（即在 Windows 上），`winrt`版本 0.7 才应该被视为一个依赖项，而`nix`版本 0.17 仅在`cfg(unix)`条件下（即在 Linux、macOS 和其他 Unix-based 平台上）才被视为依赖项。需要记住的一点是，`[dependencies]`部分在构建过程中非常早期就会被评估，此时只有某些`cfg`选项可用。特别地，功能和上下文选项在此时尚不可用，因此你不能使用这种语法来根据功能和上下文拉取依赖项。然而，你可以使用仅依赖于目标规范或架构的任何`cfg`选项，以及任何显式由调用`rustc`的工具设置的选项（如`cfg(miri)`）。

添加你自己的自定义条件编译选项也相当简单。你只需要确保在`rustc`编译你的 crate 时传递`--cfg=myoption`给`rustc`。最简单的做法是将你的`--cfg`添加到`RUSTFLAGS`环境变量中。这在 CI 中很有用，在 CI 中你可能希望根据测试是在 CI 上运行还是在开发机器上运行来定制测试套件：在 CI 设置中将`--cfg=ci`添加到`RUSTFLAGS`中，然后在代码中使用`cfg(ci)`和`cfg(not(ci))`。以这种方式设置的选项也可以在*Cargo.toml*依赖项中使用。

## 版本控制

所有 Rust crate 都有版本，并且预计会遵循 Cargo 的语义化版本控制实现。*语义化版本控制* 规定了哪些类型的变更需要什么类型的版本提升，以及哪些版本是兼容的，兼容的方式是什么。RFC 1105 标准本身值得一读（它并不复杂），但总结起来，它将变更分为三种类型：破坏性变更，需要进行主版本号更新；新增功能，需要进行次版本号更新；修复 bug，仅需进行补丁版本更新。RFC 1105 对什么构成 Rust 中的破坏性变更做了相当好的阐述，我们在本书的其他地方也涉及到了一些相关内容。

我在这里不打算详细说明不同类型变更的确切语义。相反，我想突出一些 Rust 生态系统中版本号出现的更不直观的方式，这些方式在决定如何为自己的 crate 版本时需要特别注意。

### 最小支持的 Rust 版本

第一个 Rust 特性是 *最小支持的 Rust 版本（MSRV）*。关于项目在其 MSRV 和版本管理方面应该遵循什么政策，Rust 社区有很多争议，并没有一个真正完美的答案。问题的核心是，一些 Rust 用户受限于使用较旧版本的 Rust，通常是在企业环境中，他们几乎没有选择。如果我们不断利用新稳定的 API，这些用户将无法编译我们 crate 的最新版本，并会被甩在后头。

有两种技术可以帮助 crate 作者让处于这种情况的用户更轻松。第一种是建立一个 MSRV 政策，承诺 crate 的新版本将始终能够与过去 *X* 个月内的任何稳定版本一起编译。具体的时间长度会有所不同，但 6 个月或 12 个月是常见的。由于 Rust 的六周发布周期，这通常对应于最新的四个或八个稳定版本。任何新引入的代码必须与 MSRV 编译器一起编译（通常由 CI 检查），否则就必须等到 MSRV 政策允许后才能按现状合并。虽然这样可能会有些麻烦，因为这意味着这些 crate 不能利用语言所提供的最新最强功能，但它将让用户的使用体验更轻松。

第二种技术是在 MSRV 更改时确保增加 crate 的次版本号。因此，如果你发布了 2.7.0 版本，并且该版本将 MSRV 从 Rust 1.44 提升到 Rust 1.45，那么一个卡在 1.44 版本的项目，如果依赖于你的 crate，可以使用依赖版本说明符 `version = "2, <2.7"` 来保持项目的正常运行，直到它能够升级到 Rust 1.45。重要的是，你需要增加次版本号，而不仅仅是补丁版本号，这样你就可以在需要时通过发布另一个补丁版本，来为之前的 MSRV 发布版本修复关键的安全问题。

一些项目对 MSRV 的支持非常认真，以至于他们认为 MSRV 的变化是破坏性变化，并且会增加主版本号。这意味着下游项目必须显式地选择接受 MSRV 变化，而不是选择退出——但这也意味着那些没有如此严格 MSRV 要求的用户，如果不更新依赖项，就无法看到未来的 bug 修复，这可能也需要*他们*发布破坏性变化。正如我所说，这些解决方案并非没有缺点。

在 Rust 生态系统中，强制执行 MSRV 是一项挑战。只有一小部分 crate 提供了 MSRV 保证，即使你的依赖项提供了 MSRV 保证，你也需要不断监控它们，知道它们何时提高 MSRV。一旦它们这样做，你需要发布新的 crate 版本，并且提到前面所说的版本约束，以确保你的 MSRV 不会改变。这反过来可能会迫使你放弃依赖项的安全和性能更新，因为你必须继续使用旧版本，直到你的 MSRV 策略允许更新。而这个决定也会影响到你的依赖者。曾有提议将 MSRV 检查内建到 Cargo 中，但截至目前，还没有稳定的可行方案。

### 最小依赖版本

当你首次添加依赖时，并不总是很明确你应该为该依赖指定什么版本说明。程序员通常选择最新版本，或仅选择当前的主版本，但很可能这两种选择都是错误的。这里所说的“错误”，并不是说你的 crate 无法编译，而是说做出这个选择可能会在未来给你的 crate 用户带来麻烦。我们来看一下为什么每一种情况都是有问题的。

首先，考虑你添加了对`hugs = "1.7.3"`（最新发布版本）的依赖的情况。现在假设某个开发者依赖于你的 crate，但他们同时也依赖另一个 crate，`foo`，而 `foo` 又依赖于 `hugs`。进一步假设 `foo` 的作者非常小心他们的 MSRV 策略，因此他们依赖的是 `hugs = "1, <1.6"`。在这种情况下，你将遇到问题。当 Cargo 看到 `hugs = "1.7.3"` 时，它只考虑版本 `>=1.7`。但接着它看到 `foo` 对 `hugs` 的依赖要求是 `<1.6`，于是它放弃了并报告没有一个版本的 `hugs` 能兼容所有要求。

这很遗憾，因为很可能你的 crate 与例如 `hugs 1.5.6` 编译得很好。也许它甚至与 *任何* `1.X` 版本都能编译成功！但通过使用最新版本号，你是在告诉 Cargo 只考虑该次版本号或更高版本的依赖项。那么，解决方案是否是使用 `hugs = "1"` 呢？不，这也不完全正确。可能你的代码确实依赖于仅在 `hugs 1.6` 中新增的内容，所以虽然 `1.6.2` 是可以的，但 `1.5.6` 却不行。如果你只是在一些会自动使用新版本的情况下编译你的 crate，你可能没有意识到这一点，但如果依赖图中的某个 crate 指定了 `hugs = "1, <1.5"`，你的 crate 就无法编译！

正确的策略是列出你 crate 依赖的所有内容的最早版本，并确保随着你向 crate 添加新代码，这一情况仍然保持。但如何在不依赖变更日志或通过反复试验的情况下确认这一点呢？你最好的选择是使用 Cargo 的不稳定 `-Zminimal-versions` 标志，它使你的 crate 使用所有依赖项的最低可接受版本，而不是最高版本。然后，将所有依赖项设置为仅使用最新的主版本号，尝试编译，并为那些无法编译的依赖项添加一个次版本号。如此反复直到所有内容都能顺利编译，这样你就得到了最小版本要求！

值得注意的是，像 MSRV 一样，最小版本检查面临着生态系统采纳的问题。虽然你可能已正确设置了所有版本说明符，但你依赖的项目可能没有。这使得在实践中使用 Cargo 的最小版本标志变得困难（这也是为什么它仍然不稳定的原因）。如果你依赖 `foo`，而 `foo` 又依赖 `bar`，并且 `bar` 的版本说明符是 `bar = "1"`，但实际上它需要的是 `bar = "1.4"`，那么无论你如何列出 `foo`，Cargo 都会报告它编译 `foo` 失败，因为 `-Z` 标志要求它始终优先使用最小版本。你可以通过在 *你的* 依赖项中直接列出 `bar` 并指定适当的版本要求来绕过这个问题，但这些解决方法可能会很麻烦且难以维护。你最终可能需要列出大量通过传递依赖间接引入的依赖项，并且必须随着时间的推移不断保持该列表的更新。

### 变更日志

对于大多数非微不足道的 crate，我强烈建议保留变更日志。没有什么比看到一个依赖项已经发布了重大版本更新后，却不得不翻阅 Git 日志去查找具体更改内容和如何更新代码更让人沮丧了。我建议你不要将 Git 日志直接倒入一个名为 *changelog* 的文件中，而是应该手动维护一个变更日志。这更有可能是有用的。

一个简单但有效的变更日志格式是 Keep a Changelog 格式，详细文档见 [`keepachangelog.com/`](https://keepachangelog.com/)。

### 未发布的版本

Rust 会考虑版本号，即使依赖的来源是目录或 Git 仓库。这意味着即使你尚未发布到 *crates.io*，语义化版本控制仍然很重要；在发布之间，你的 *Cargo.toml* 中列出的版本号也很重要。语义化版本控制标准并没有规定如何处理这种情况，但我会提供一个有效的工作流程，既不繁琐，又能有效地运作。

发布版本后，立即在 *Cargo.toml* 中更新版本号，设置为下一个补丁版本，后缀如 *-alpha.1*。如果你刚发布了 2.0.3，则新版本应该是 2.0.4-alpha.1。如果你刚发布了 alpha 版本，则递增 alpha 版本号。

当你在发布之间对代码进行更改时，注意查看是否有新增功能或破坏性更改。如果发生了其中之一，并且自上次发布以来相应的版本号没有变化，应该递增版本号。例如，如果上次发布的版本是 2.0.3，当前版本是 2.0.4-alpha.2，并且你做了新增更改，那么这个版本号应该是 2.1.0-alpha.1。如果你做了破坏性更改，那么版本号应该变为 3.0.0-alpha.1。如果相应的版本号已经更新，只需递增 alpha 版本号即可。

当你发布一个版本时，移除后缀（除非你想做预发布版本），然后发布，并从头开始。

这个流程之所以有效，是因为它使两个常见的工作流程能够更好地运作。首先，假设一个开发者依赖于你的 crate 的主要版本 2，但他们需要的一个特性目前仅在 Git 上可用。然后你提交了一个破坏性更改。如果你没有同时增加主要版本号，他们的代码将突然以意外的方式失败，可能无法编译，或者会出现奇怪的运行时问题。如果你按照这里的流程操作，Cargo 会通知他们发生了破坏性更改，他们必须解决这个问题或固定一个特定的提交。

接下来，假设一个开发者需要一个他们刚刚贡献的特性，但该特性还没有成为你 crate 发布的版本的一部分。他们已经通过 Git 依赖使用了你的 crate 一段时间，因此项目中的其他开发者已经拥有你仓库的旧版本。如果你没有在 Git 中递增主要版本号，这个开发者无法传达他们的项目现在依赖于刚合并的特性。如果他们推送了他们的更改，他们的同事会发现项目无法再编译，因为 Cargo 会重新使用旧的代码库。另一方面，如果开发者可以递增 Git 依赖的次要版本号，Cargo 会意识到旧的代码库已经过时。

这个工作流程远非完美。它没有提供一种很好的方式来传达多个小或大更改之间的版本变化，而且你仍然需要做一些工作来跟踪版本。然而，它确实解决了 Rust 开发者在使用 Git 依赖项时遇到的两个最常见问题，即使你在版本发布之间做了多个这样的更改，这个工作流程仍然能够捕捉到许多问题。

如果你不太担心版本发布中的小版本号或连续的版本号，你可以通过始终递增版本号的适当部分来改进这个建议的工作流程。不过需要注意的是，取决于你进行此类更改的频率，这可能会使你的版本号变得非常大！

## 总结

在本章中，我们已经探讨了多种配置、组织和发布 crate 的机制，这些机制既有利于你自己，也有利于他人。我们还讨论了在使用 Cargo 中的依赖项和功能时的一些常见陷阱，希望这些陷阱以后不会再让你措手不及。在下一章，我们将转向测试，深入了解如何超越我们熟悉和喜爱的 Rust 简单的 `#[test]` 函数。
