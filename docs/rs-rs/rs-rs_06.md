# 第六章：测试

![](img/chapterart.png)

在本章中，我们将探讨扩展 Rust 测试功能的各种方式，以及可能想要加入的其他类型的测试。Rust 自带了一些内建的测试工具，这些工具在*《Rust 编程语言》*中有详细介绍，主要通过`#[test]`属性和*tests/*目录进行表示。这些工具能够很好地支持各种应用和规模，通常在你刚开始一个项目时，已经足够用了。然而，随着代码库的发展，测试需求变得更加复杂，你可能需要超越简单地在单个函数上标记`#[test]`。

本章分为两个主要部分。第一部分涵盖了 Rust 的测试机制，比如标准的测试框架和条件性测试代码。第二部分则讨论了其他评估 Rust 代码正确性的方法，如基准测试、代码检查和模糊测试。

## Rust 测试机制

要理解 Rust 提供的各种测试机制，首先必须了解 Rust 是如何构建和运行测试的。当你运行`cargo test --lib`时，Cargo 唯一做的特殊事情就是将`--test`标志传递给`rustc`。这个标志告诉`rustc`生成一个测试二进制文件，运行所有单元测试，而不仅仅是编译包的库或二进制文件。在幕后，`--test`有两个主要效果。首先，它启用了`cfg(test)`，这样你可以有条件地包含测试代码（稍后会详细介绍）。其次，它使编译器生成一个*测试框架*：一个精心生成的`main`函数，运行程序中的每个`#[test]`函数。

### 测试框架

编译器通过程序化宏（在第七章中我们将深入讨论）和一些魔法的小技巧，生成测试框架的`main`函数。基本上，框架将每个被`#[test]`注解的函数转换成一个测试*描述符*——这是程序化宏的部分。然后，它将每个描述符的路径暴露给生成的`main`函数——这就是魔法的部分。描述符包含信息，例如测试的名称、设置的任何附加选项（如`#[should_panic]`）等。核心的测试框架会遍历包中的所有测试，运行它们，捕获结果并打印输出。所以，它还包括解析命令行参数的逻辑（例如`--test-threads=1`），捕获测试输出，平行运行列出的测试，并收集测试结果。

在写本文时，Rust 开发者正在致力于使测试工具生成的魔法部分成为公开可用的 API，以便开发者能够构建自己的测试工具。这项工作仍处于实验阶段，但该提案与现有模型非常接近。需要解决的部分魔法是如何确保即使 `#[test]` 函数位于私有子模块中，也能让它们在生成的 `main` 函数中可用。

集成测试（位于 *tests/* 目录中的测试）与单元测试遵循相同的流程，唯一的例外是它们每个都作为独立的 crate 编译，这意味着它们只能访问主 crate 的公共接口，并且是在没有 `#[cfg(test)]` 的情况下针对主 crate 编译运行的。每个 *tests/* 中的文件都会生成一个测试工具。对于 *tests/* 下子目录中的文件，不会生成测试工具，这样你可以为测试共享子模块。

Rust 不要求你使用默认的测试工具。你可以选择退出它，并实现你自己的 `main` 方法，作为测试运行器，通过在 *Cargo.toml* 中为特定的集成测试设置 `harness = false`，如清单 6-1 所示。你定义的 `main` 方法将会被调用来运行测试。

```
[[test]]
name = "custom"
path = "tests/custom.rs"
harness = false
```

清单 6-1：退出标准测试工具

没有测试工具时，`#[test]` 的相关魔法不会发生。相反，你需要编写你自己的 `main` 函数来运行你希望执行的测试代码。实际上，你正在编写一个普通的 Rust 二进制文件，只不过它是由 `cargo test` 运行的。这个二进制文件负责处理默认测试工具通常处理的所有事务（如果你希望支持它们的话），比如命令行标志。`harness` 属性是针对每个集成测试单独设置的，因此你可以拥有一个使用标准测试工具的测试文件，也可以拥有一个不使用它的文件。

没有测试工具的集成测试主要用于基准测试，正如我们稍后将看到的，但它们在你想运行那些不符合标准“一个函数，一个测试”模型的测试时也很有用。例如，你会经常看到没有测试工具的测试与模糊测试器、模型检查器一起使用，或者需要自定义全局设置的测试（如在 WebAssembly 中，或与自定义目标一起使用时）。

### #[cfg(test)]

当 Rust 为测试构建代码时，它会设置编译器配置标志 `test`，你可以利用条件编译来确保代码只有在进行测试时才会被编译。表面上看，这似乎有些奇怪：你不想测试进入生产环境的完全相同的代码吗？当然是的，但只在测试时提供代码，可以让你以几种方式编写更好、更彻底的测试。

#### 仅限测试的 API

首先，只有测试代码可以让你向（单元）测试暴露额外的方法、字段和类型，这样测试不仅可以检查公共 API 是否正常工作，还可以检查内部状态是否正确。例如，考虑`hashbrown`中的`HashMap`类型，它是实现标准库`HashMap`的 crate。`HashMap`类型实际上只是一个围绕`RawTable`类型的包装器，后者实现了大部分哈希表的逻辑。假设在对一个空的哈希表执行`HashMap::insert`后，你想检查哈希表中的一个桶是否非空，如 Listing 6-2 所示。

```
#[test]
fn insert_just_one() {
  let mut m = HashMap::new();
  m.insert(42, ());
  let full = m.table.buckets.iter().filter(Bucket::is_full).count();
  assert_eq!(full, 1);
}
```

Listing 6-2：一个访问不可访问内部状态的测试，因此无法编译

这段代码按原样无法编译，因为尽管测试代码可以访问`HashMap`的私有`table`字段，但它不能访问`RawTable`的私有`buckets`字段，因为`RawTable`位于不同的模块中。我们可以通过将`buckets`字段的可见性设置为`pub(crate)`来解决此问题，但我们并不希望`HashMap`能触及`buckets`，因为这可能会意外地破坏`RawTable`的内部状态。即使将`buckets`设置为只读也可能会带来问题，因为`HashMap`中的新代码可能会开始依赖`RawTable`的内部状态，从而使未来的修改更加困难。

解决方案是使用`#[cfg(test)]`。我们可以向`RawTable`添加一个方法，允许在测试时访问`buckets`，如 Listing 6-3 所示，从而避免为其他代码增加不必要的风险。然后，可以更新 Listing 6-2 中的代码，调用`buckets()`而不是直接访问私有的`buckets`字段。

```
impl RawTable {
  #[cfg(test)]
  pub(crate) fn buckets(&self) -> &[Bucket] {
    &self.buckets
  }
}
```

Listing 6-3：使用`#[cfg(test)]`使内部状态在测试上下文中可访问

#### 测试断言的记账

只有在测试期间存在的代码的第二个好处是，你可以增强程序以执行额外的运行时记账操作，然后由测试进行检查。例如，假设你正在编写自己版本的标准库中的`BufWriter`类型。在测试时，你希望确保`BufWriter`不会不必要地发出系统调用。最直接的方式是让`BufWriter`跟踪它在底层`Write`上调用`write`的次数。然而，在生产环境中，这些信息并不重要，而跟踪这些信息会带来（边际）性能和内存开销。通过`#[cfg(test)]`，你可以确保记账操作仅在测试时发生，如 Listing 6-4 所示。

```
struct BufWriter<T> {
  #[cfg(test)]
  write_through: usize,
  // other fields...
}

impl<T: Write> Write for BufWriter<T> {
  fn write(&mut self, buf: &[u8]) -> Result<usize> {
    // ...
    if self.full() {
      #[cfg(test)]
      self.write_through += 1;
      let n = self.inner.write(&self.buffer[..])?;
    // ...
  }
}
```

Listing 6-4：使用`#[cfg(test)]`将记账限制在测试上下文中

请记住，`test` 仅在作为测试编译的 crate 中设置。对于单元测试，这是正在测试的 crate，正如你所期望的那样。然而，对于集成测试，它是作为测试编译的集成测试二进制文件——你正在测试的 crate 只是作为库编译，因此不会设置 `test`。

### Doctests

文档注释中的 Rust 代码片段会自动作为测试用例运行。这些通常被称为 *doctests*。由于 doctests 出现在你的 crate 的公共文档中，用户很可能会模仿它们，因此它们作为集成测试运行。这意味着 doctests 无法访问私有字段和方法，并且 `test` 在主 crate 的代码中没有设置。每个 doctest 都作为一个独立的 crate 编译，并且在隔离环境中运行，就像用户将 doctest 复制粘贴到自己的程序中一样。

在幕后，编译器对 doctest 进行一些预处理，使其更加简洁。最重要的是，它会自动为你的代码添加一个 `fn main`。这让 doctest 只关注用户可能关心的重要部分，比如实际使用你库中的类型和方法的部分，而不会包含不必要的样板代码。

你可以通过在 doctest 中定义自己的 `fn main` 来选择退出这种自动包装。例如，如果你想使用类似 `#[tokio::main] async fn main` 的异步 `main` 函数，或者你想在 doctest 中添加其他模块，可能需要这么做。

在你的 doctest 中使用 `?` 运算符时，通常不需要使用自定义的 `main` 函数，因为 `rustdoc` 会自动进行一些启发式处理，如果你的代码看起来像是使用了 `?`（例如，代码以 `Ok(())` 结尾），它会将返回类型设置为 `Result<(), impl Debug>`。如果类型推断在函数的错误类型上让你感到困惑，你可以通过显式指定最后一行的类型来消除歧义，例如：`Ok::<(), T>(())`。

Doctest 具有许多额外的功能，这些功能在为更复杂的接口编写文档时非常实用。第一个功能是隐藏单独的行。如果你在 doctest 的一行前加上 `#`，该行会在 doctest 编译并运行时被包含，但不会出现在文档生成的代码片段中。这样你可以轻松隐藏当前示例中不重要的细节，例如为虚拟类型实现特征或生成值。如果你希望展示一系列示例，而不每次都显示相同的前导代码，这也非常有用。列表 6-5 给出了一个包含隐藏行的 doctest 示例。

```
/// Completely frobnifies a number through I/O.
///
/// In this first example we hide the value generation.
/// ```

/// # let unfrobnified_number = 0;

/// # let already_frobnified = 1;

/// assert!(frobnify(unfrobnified_number).is_ok());

/// assert!(frobnify(already_frobnified).is_err());

/// ```
///
/// Here's an example that uses ? on multiple types
/// and thus needs to declare the concrete error type,
/// but we don't want to distract the user with that.
/// We also hide the use that brings the function into scope.
/// ```

/// # use mylib::frobnify;

/// frobnify("0".parse()?)?;

/// # Ok::<(), anyhow::Error>(())

/// ```
///
/// You could even replace an entire block of code completely,
/// though use this _very_ sparingly:
/// ```

/// # /*

/// let i = ...;

/// # */

/// # let i = 42;

/// frobnify(i)?;

/// ```
fn frobnify(i: usize) -> std::io::Result<()> {
```

列表 6-5：使用 `#` 在文档测试中隐藏行

与 `#[test]` 函数类似，文档测试也支持修改文档测试运行方式的属性。这些属性紧跟在用于表示代码块的三重反引号后面，多个属性可以用逗号分隔。

与测试函数类似，您可以指定 `should_panic` 属性来指示特定的文档测试中的代码在运行时应当触发 panic，或者使用 `ignore` 仅在 `cargo test` 以 `--ignored` 标志运行时检查代码段。您还可以使用 `no_run` 属性来指示某个文档测试应编译但不应运行。

属性 `compile_fail` 告诉 `rustdoc` 文档示例中的代码不应该编译。这向用户指示某个特定用法不可行，并作为一个有用的测试提醒您在库的相关部分发生变化时更新文档。您还可以使用此属性来检查某些静态属性是否对您的类型有效。列表 6-6 展示了如何使用 `compile_fail` 来检查某个类型是否没有实现 `Send`，这可能对在不安全代码中维护安全保证至关重要。

```
```compile_fail

# struct MyNonSendType(std::rc::Rc<()>);

fn is_send<T: Send>() {}

is_send::<MyNonSendType>();

```
```

列表 6-6：测试代码是否无法编译，使用 `compile_fail`

`compile_fail` 是一个相对粗略的工具，因为它没有指示 *为什么* 代码不编译。例如，如果代码因为缺少分号而无法编译，`compile_fail` 测试可能看起来已成功。出于这个原因，您通常需要在确保测试确实因为预期错误无法编译后再添加该属性。如果您需要更细粒度的编译错误测试，例如在开发宏时，建议查看 `trybuild` crate。

## 其他测试工具

测试不仅仅是运行测试函数并查看它们是否产生预期的结果。全面的测试技术、方法论和工具的调研超出了本书的范围，但有一些关键的 Rust 特定内容是您在扩展测试工具时应该了解的。

### 静态分析

您可能不会将静态分析工具（linter）的检查视为测试，但在 Rust 中，它们通常可以视为测试。Rust 的 linter *clippy* 将其多个 lint 分类为 *正确性* lint。这些 lint 能捕捉那些能够编译但几乎肯定是 bug 的代码模式。一些示例包括 `a = b; b = a`，这无法交换 `a` 和 `b`；`std::mem::forget(t)`，其中 `t` 是一个引用；以及 `for x in y.next()`，这只会遍历 `y` 中的第一个元素。如果您尚未在 CI 流水线中运行 clippy，您可能应该开始使用它。

Clippy 附带了许多其他的 lint（静态分析检查），虽然这些通常很有帮助，但有时可能比你希望的更具主观性。例如，默认开启的 `type_complexity` lint 会发出警告，提示你使用了一个特别复杂的类型，例如 `Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>`。虽然这个警告鼓励你编写更易读的代码，但你可能会觉得它过于吹毛求疵，难以广泛应用。如果你代码中的某一部分错误地触发了特定的 lint，或者你只是希望允许某一特定实例，你可以使用 `#[allow(clippy::name_of_lint)]` 让该部分代码不受该 lint 的影响。

Rust 编译器也带有一套自己的 lint，形式是警告，尽管这些警告通常更多是针对编写符合惯用法的代码，而不是检查代码的正确性。相反，编译器中的正确性 lint 会被视为错误（可以通过 `rustc -W help` 查看相关列表）。

### 测试生成

编写一个好的测试套件是非常耗费精力的。而且，即使你完成了这项工作，你编写的测试仅仅测试了你在编写它们时考虑的特定行为集。幸运的是，你可以利用一些测试生成技术来开发更好、更全面的测试。这些技术会为你生成输入，用来检查你应用程序的正确性。许多此类工具已经存在，每个工具都有自己的优缺点，因此在这里我只会讲解这些工具的主要策略：模糊测试和属性测试。

#### 模糊测试

关于模糊测试（fuzzing），已经有许多书籍专门讨论了这个话题，但从高层次上看，原理很简单：为你的程序生成随机输入，看看它是否崩溃。如果程序崩溃了，那就是一个 bug。例如，如果你正在编写一个 URL 解析库，你可以通过系统地生成随机字符串并将其传递给解析函数进行模糊测试，直到它发生 panic。若操作不够精细，这个过程可能需要一些时间才能得到结果：如果模糊测试器从 `a` 开始，然后是 `b`，接着是 `c`，依此类推，它需要很长时间才能生成像 `http://[:]` 这样棘手的 URL。在实际应用中，现代的模糊测试工具使用代码覆盖率度量来探索代码中的不同路径，这使得它们能够比真正随机选择输入时更快地达到更高的覆盖度。

模糊测试工具在发现你的代码无法正确处理的奇怪边界情况方面非常出色。它们对你几乎没有设置要求：你只需要将模糊测试工具指向一个接受“可模糊输入”的函数，它就会自动开始工作。例如，Listing 6-7 显示了一个如何进行 URL 解析器模糊测试的例子。

```
libfuzzer_sys::fuzz_target!(|data: &[u8]| {
  if let Ok(s) = std::str::from_utf8(data) {
      let _ = url::Url::parse(s);
  }
});
```

Listing 6-7: 使用 `libfuzzer` 进行 URL 解析器模糊测试

模糊测试工具将会为闭包生成半随机输入，任何能够形成有效 UTF-8 字符串的输入都会被传递给解析器。注意，代码这里并没有检查解析是否成功或失败——而是关注于查找解析器因为违反了内部不变条件而 panic 或崩溃的情况。

模糊测试工具会一直运行，直到你终止它，所以大多数模糊测试工具都内建有机制，在探索了某些测试用例后停止。如果你的输入不是一个可以简单模糊测试的类型——比如哈希表——你通常可以使用像`arbitrary`这样的库，将模糊测试生成的字节字符串转化为更复杂的 Rust 类型。它看起来像魔法，但在幕后，它其实是通过非常直接的方式实现的。这个库定义了一个`Arbitrary`特性，其中有一个方法`arbitrary`，用于从随机字节源构建实现该特性的类型。像`u32`或`bool`这样的原始类型会从输入中读取必要的字节数来构建其有效实例，而像`HashMap`或`BTreeSet`这样的复杂类型会从输入中生成一个数字来决定它们的长度，然后对它们的内部类型调用`Arbitrary`该次数。甚至有一个属性`#[derive(Arbitrary)]`，它通过对每个包含类型调用`arbitrary`来实现`Arbitrary`！如果你想更深入地了解模糊测试，我推荐从`cargo-fuzz`开始。

#### 基于属性的测试

有时候你不仅仅想检查程序是否崩溃，还希望它能够按预期执行。这意味着你的`add`函数没有崩溃是好事，但如果它告诉你`add(1, 4)`的结果是`68`，那可能还是错误的。这就是*基于属性的测试*发挥作用的地方；你描述一些代码应该遵循的属性，然后属性测试框架生成输入并检查这些属性是否确实成立。

使用基于属性的测试的常见方法是，首先编写一个简单但天真的版本的代码，这是你确信正确的版本。然后，对于给定的输入，你将该输入同时提供给你想测试的代码和简化但天真的版本。如果两个实现的结果或输出相同，那么你的代码就是好的——这就是你正在寻找的正确性属性——但如果不相同，你可能已经发现了一个 bug。你还可以使用基于属性的测试来检查与正确性无关的属性，比如某个实现的操作是否比另一个实现的操作耗时更少。普遍的原则是，你希望实际版本和测试版本之间的任何结果差异都是有信息量的并且可操作的，这样每次失败都能让你改进。天真的实现可能是你想替换或增强的标准库中的某个实现（比如`std::collections::VecDeque`），或者它可能是你正在尝试优化的算法的简化版本（比如天真的矩阵乘法与优化后的矩阵乘法）。

如果这种生成输入直到满足某些条件的方式听起来很像模糊测试，那是因为它确实如此——比我更聪明的人曾经说过，模糊测试“只是”基于属性的测试，而你测试的属性就是“它不会崩溃”。

基于属性的测试的一个缺点是它更加依赖于输入的描述。与模糊测试不断尝试所有可能的输入不同，属性测试往往依赖开发者注释的指导，如“0 到 64 之间的数字”或“包含三个逗号的字符串”。这使得属性测试能够更快地覆盖到模糊测试可能需要很长时间才能随机遇到的情况，但它确实需要手动工作，并且可能错过一些重要但冷门的 bug 输入。然而，随着模糊测试和属性测试的不断融合，模糊测试也开始具备这种基于约束的搜索能力。

如果你对基于属性的测试生成感兴趣，我推荐从 `proptest` crate 开始。

### 测试增强

假设你已经设置好了一个非常棒的测试套件，并且你的代码通过了所有的测试。这是如此辉煌。但有一天，通常可靠的测试却莫名其妙地失败了，或者因为分段错误崩溃。有两种常见的原因会导致这种非确定性的测试失败：竞态条件，测试可能仅在两个操作以特定顺序在不同线程上发生时才会失败，以及不安全代码中的未定义行为，例如某些不安全代码从未初始化的内存中读取特定值。

使用常规测试捕捉这些类型的 bug 可能很困难——通常你无法充分控制线程调度、内存布局和内容，或者其他随机系统因素来编写可靠的测试。你可以在循环中多次运行每个测试，但即便如此，如果错误的发生足够罕见或不太可能，它可能仍然不会被捕捉到。幸运的是，有一些工具可以帮助增强你的测试，使捕捉这些类型的 bug 变得更容易。

其中第一个是令人惊叹的工具 *Miri*，它是 Rust 的 *中级中间表示（MIR）* 的解释器。MIR 是 Rust 的一种内部简化表示，帮助编译器在无需考虑 Rust 本身的语法糖的情况下，找到优化并检查属性。通过 Miri 运行测试就像运行 `cargo miri test` 一样简单。Miri *解释* 你的代码，而不是像正常的二进制文件那样编译和运行，这使得测试运行的速度会慢一些。但作为回报，Miri 可以在执行代码的每一行时跟踪整个程序的状态。这使得 Miri 能够检测并报告你的程序是否表现出某些类型的未定义行为，比如未初始化的内存读取、在变量被销毁后使用值，或者越界指针访问。与其让这些操作导致奇怪的程序行为，这些行为可能只在某些情况下才会导致可观察的测试失败（如崩溃），Miri 能够在它们发生时检测到，并立即告诉你。

例如，考虑一下 列表 6-8 中非常不安全的代码，它创建了两个指向同一值的独占引用。

```
let mut x = 42;
let x: *mut i32 = &mut x;
let (x1, x2) = unsafe { (&mut *x, &mut *x) };
println!("{} {}", x1, x2);
```

列表 6-8：Miri 检测到的极其不安全的代码是错误的

在撰写本文时，如果你通过 Miri 运行这段代码，你会遇到一个错误，错误信息会准确指出问题所在：

```
error: Undefined Behavior: trying to reborrow for Unique at alloc1383, but parent tag <2772> does not have an appropriate item in the borrow stack
 --> src/main.rs:4:6
  |
4 | let (x1, x2) = unsafe { (&mut *x, &mut *x) };
  |      ^^ trying to reborrow for Unique at alloc1383, but parent tag <2772> does not have an appropriate item in the borrow stack
```

另一个值得关注的工具是 *Loom*，这是一个巧妙的库，旨在确保你的测试以每种相关的并发操作交替顺序运行。从高层次来看，Loom 跟踪所有线程间同步点，并反复运行你的测试，每次都调整线程从这些同步点开始执行的顺序。因此，如果线程 A 和线程 B 都需要获取相同的 `Mutex`，Loom 会确保测试分别以 A 先获取和 B 先获取的顺序运行。Loom 还跟踪原子操作、内存顺序和对 `UnsafeCell`（我们将在第九章讨论）访问，并检查线程是否不当访问这些内容。如果测试失败，Loom 会提供一个详细的报告，告诉你哪些线程按照什么顺序执行，这样你就可以确定崩溃发生的原因。

### 性能测试

编写性能测试很困难，因为通常很难准确模拟一个能够反映你 crate 的实际使用情况的工作负载。但拥有这样的测试是很重要的；如果你的代码突然变得慢了 100 倍，这应该被视为一个 bug，然而没有性能测试的话，你可能不会发现这种回归。如果你的代码运行得快了 100 倍，这也可能意味着出了问题。这两种情况都是将自动化性能测试纳入 CI 的充分理由——如果性能发生了大幅变化，无论是变快还是变慢，你都应该知道。

与功能测试不同，性能测试没有一个共同的、明确定义的输出。功能测试要么通过，要么失败，而性能测试可能会给出吞吐量、延迟曲线、处理的样本数，或其他与应用程序相关的指标。此外，性能测试可能需要在循环中执行一个函数数十万次，或者可能需要几个小时才能在一个分布式的多核机器网络上运行。由于这个原因，很难在一般意义上讨论如何编写性能测试。因此，在本节中，我们将讨论编写 Rust 性能测试时可能遇到的一些问题，并探讨如何减轻这些问题。三个常被忽视的常见陷阱是性能波动、编译器优化和 I/O 开销。让我们依次探讨这些问题。

#### 性能波动

性能可能由于各种原因而有所不同，许多因素会影响特定机器指令序列的运行速度。有些因素很明显，比如 CPU 和内存的时钟速度，或者机器的负载情况，但很多因素则更为微妙。例如，你的内核版本可能会改变分页性能，用户名的长度可能会改变内存布局，而房间的温度可能会导致 CPU 降频。最终，如果你运行基准测试两次，几乎不可能得到相同的结果。事实上，即使使用相同的硬件，你也可能观察到显著的波动。或者，从另一个角度来看，你的代码可能变得更慢或更快，但由于基准测试环境的差异，这种变化可能是不可见的。

除非你恰好能够在一个高度多样化的机器集群上重复运行基准测试，否则没有完美的方法可以消除性能结果中的所有波动。即便如此，尽力处理这些测量的波动以从基准测试给出的噪音数据中提取信号仍然很重要。在实践中，我们应对波动的好帮手是多次运行每个基准测试，然后查看测量结果的*分布*，而不仅仅是单一的结果。Rust 提供了一些有助于此的工具。例如，像 `hdrhistogram` 这样的 crate 使我们能够查看诸如“95% 的样本运行时间范围是什么？”这样的统计数据，而不仅仅是询问“这个函数的平均运行时间是多少？”为了更加严谨，我们还可以使用像统计学中的零假设检验等技术，来建立一定的信心，确保一个测得的差异确实代表了一个真实的变化，而不仅仅是噪音。

统计假设检验的讲解超出了本书的范围，但幸运的是，这项工作中的大部分已经由其他人完成。例如，`criterion` crate 就可以为你完成所有这些工作，并且更多。你所需要做的就是提供一个函数，供它调用以运行基准测试的一次迭代，然后它会运行适当次数，以确保结果可靠。它随后会生成基准测试报告，其中包括结果摘要、异常值分析，甚至是随时间变化的趋势图表。当然，它不能消除仅在特定硬件配置上测试的影响，但至少它会对在多次执行中可以测量到的噪音进行分类。

#### 编译器优化

现在的编译器非常聪明。它们会消除死代码，在编译时计算复杂表达式，展开循环，并执行其他黑魔法，以挤出代码的每一滴性能。通常这很棒，但当我们试图衡量某段代码的执行速度时，编译器的聪明才智可能会给我们带来无效的结果。例如，考虑在清单 6-9 中基准测试 `Vec::push` 的代码。

```
let mut vs = Vec::with_capacity(4);
let start = std::time::Instant::now();
for i in 0..4 {
  vs.push(i);
}
println!("took {:?}", start.elapsed());
```

列表 6-9：一个可疑的快速性能基准

如果你查看使用类似于优秀的*godbolt.org*或`cargo-asm`在发布模式下编译的代码的汇编输出，你会立即注意到有些问题：`Vec::with_capacity`和`Vec::push`的调用，甚至整个`for`循环，都完全消失了。它们已经被完全优化掉了。编译器意识到代码中实际上没有任何地方需要执行向量操作，因此将它们作为死代码剔除了。当然，编译器完全有权这样做，但对于基准测试来说，这并没有什么帮助。

为了避免这种基准测试优化，标准库提供了`std::hint::black_box`。这个函数曾引发过很多争论和困惑，并且在撰写本文时仍待稳定化，但它非常有用，值得在这里讨论。它的核心实际上是一个恒等函数（即接受`x`并返回`x`），它告诉编译器假设该函数的参数以任意（合法的）方式被使用。它并不会阻止编译器对输入参数应用优化，也不会阻止编译器优化返回值的使用方式。相反，它鼓励编译器实际计算函数的参数（假设该参数会被使用），并将结果存储在某个 CPU 可以访问的地方，以便`black_box`可以用计算出的值调用。编译器可以自由地在编译时计算输入参数，但它仍应将结果注入程序中。

这个函数就是我们在很多基准测试需求中所需要的，尽管并非所有的需求都能用它来解决。例如，我们可以对列表 6-9 进行标注，以便不再让向量访问被优化掉，如列表 6-10 所示。

```
let mut vs = Vec::with_capacity(4);
let start = std::time::Instant::now();
for i in 0..4 {
  black_box(vs.as_ptr());
  vs.push(i);
  black_box(vs.as_ptr());
}
println!("took {:?}", start.elapsed());
```

列表 6-10：列表 6-9 的修正版本

我们已经告诉编译器假设`vs`在每次循环迭代中以任意方式被使用，无论是在调用`push`之前还是之后。这迫使编译器按顺序执行每个`push`，而不合并或以其他方式优化连续的调用，因为它必须假设在每次调用之间，`vs`可能会发生“无法优化掉的任意操作”（这就是`black_box`部分的作用）。

注意，我们使用了`vs.as_ptr()`而不是`&vs`。这是因为编译器应该假设`black_box`可以对其参数执行任何*合法*的操作。通过共享引用修改`Vec`是不合法的，因此如果我们使用`black_box(&vs)`，编译器可能会注意到`vs`在循环的每次迭代之间不会发生变化，从而根据这一观察实施优化！

#### I/O 开销测量

编写基准测试时，容易不小心测量到错误的东西。例如，我们通常希望实时了解基准测试进行到什么阶段。为了做到这一点，我们可能会编写像列表 6-11 那样的代码，旨在衡量`my_function`的运行速度：

```
let start = std::time::Instant::now();
for i in 0..1_000_000 {
  println!("iteration {}", i);
  my_function();
}
println!("took {:?}", start.elapsed());
```

列表 6-11：我们到底在基准测试什么？

这看起来似乎达到了目标，但实际上它并没有真正衡量`my_function`的执行速度。相反，这个循环更有可能告诉我们打印一百万个数字需要多长时间。循环体中的`println!`在幕后做了大量的工作：它将二进制整数转换为十进制数字以便打印，锁定标准输出，使用至少一个系统调用写出一系列 UTF-8 码点，然后释放标准输出锁。不仅如此，如果你的终端打印输入的速度很慢，系统调用可能会被阻塞。这消耗了很多计算周期！而调用`my_function`所需的时间可能与之相比微不足道。

当你的基准测试使用随机数时，会发生类似的情况。如果你在循环中运行`my_function(rand::random())`，你很可能主要在测量生成一百万个随机数的时间。获取当前时间、读取配置文件或启动新线程的情况也是如此——这些事情相对来说都花费很长时间，可能最终会掩盖你实际上想要测量的时间。

幸运的是，一旦你意识到这个问题，通常很容易找到解决方法。确保基准测试循环体内几乎只有你想要测量的代码。所有其他代码应在基准测试开始之前或基准测试的测量部分之外运行。如果你使用`criterion`，可以查看它提供的不同计时循环——它们都旨在适应需要不同测量策略的基准测试案例！

## 总结

在本章中，我们详细探讨了 Rust 所提供的内置测试功能。我们还介绍了许多在测试 Rust 代码时有用的测试工具和技巧。本章是本书中专注于中级 Rust 使用的最后一章。从下一章关于声明式和过程宏开始，我们将更多关注 Rust 代码。下页见！
