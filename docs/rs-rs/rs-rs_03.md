# 第三章：设计接口

![](img/chapterart.png)

每个项目，无论大小，都有 API。实际上，通常有多个 API。其中一些是面向用户的，例如 HTTP 端点或命令行界面，而另一些是面向开发者的，比如库的公共接口。除了这些外，Rust 的 crate 还拥有许多内部接口：每个类型、trait 和模块边界都有自己的小型 API，其他代码也会与之交互。随着代码库的规模和复杂性增加，你会发现投入一些思考和心思来设计内部 API 是值得的，这样可以尽量让代码的使用和维护体验变得更为愉快。

本章将介绍编写 Rust 语言习惯接口时需要考虑的一些重要因素，无论这些接口的用户是你自己的代码，还是其他开发者在使用你的库。这些因素本质上可以归结为四个原则：接口应该是*不令人惊讶*的、*灵活*的、*显而易见*的以及*受限*的。我将依次讨论这四个原则，提供编写可靠且易用接口的指导。

强烈推荐在阅读完本章之后查看 Rust API 指南（[`rust-lang.github.io/api-guidelines/`](https://rust-lang.github.io/api-guidelines/)）。这里有一个非常好的检查清单，详细解释了每项推荐。许多本章中的建议也会通过 `cargo clippy` 工具进行检查，如果你还没有使用该工具，应该尽早在代码中运行它。我还鼓励你阅读 Rust RFC 1105（[`rust-lang.github.io/rfcs/1105-api-evolution.html`](https://rust-lang.github.io/rfcs/1105-api-evolution.html)）以及《Cargo 手册》中关于 SemVer 兼容性的章节（[`doc.rust-lang.org/cargo/reference/semver.html`](https://doc.rust-lang.org/cargo/reference/semver.html)），它们涵盖了在 Rust 中什么是 breaking change，什么不是。

## 不足为奇

**最小惊讶原则**（The Principle of Least Surprise），也称为**最小惊讶法则**（Law of Least Astonishment），在软件工程中经常出现，这一原则同样适用于 Rust 接口。尽可能地，接口应该足够直观，用户如果不得不猜测，通常能够猜对。当然，应用程序的所有内容并不总是能够以这种方式直观易懂，但任何*可以*做到不令人惊讶的部分，都应该做到不令人惊讶。这里的核心思想是，尽量贴近用户可能已经知道的事物，这样他们就不需要以不同于他们习惯的方式重新学习概念。这样，你就可以节省他们的脑力，让他们专注于理解那些实际上是特定于你接口的内容。

你可以通过多种方式使接口具有可预测性。在这里，我们将探讨如何利用命名、共性特征以及人体工程学特征技巧来帮助用户。

### 命名规范

用户首先会通过接口的名称接触到它；他们会立即从遇到的类型、方法、变量、字段和库的名称中推断出一些信息。如果你的接口重用了其他（可能是常见的）接口中的名称——比如方法和类型——用户会知道他们可以对你的方法和类型做出某些假设。一个叫做`iter`的方法可能接受`&self`，并且很可能会给你一个迭代器。一个叫做`into_inner`的方法可能接受`self`，并很可能返回某种包装类型。一个叫做`SomethingError`的类型可能实现了`std::error::Error`并出现在各种`Result`中。通过为相同目的重用常见名称，你可以让用户更容易猜测某些事物的作用，并帮助他们更容易理解你的接口中与众不同的部分。

由此产生的一个推论是，具有相同名称的事物*应该*以相同的方式工作。否则——例如，如果你的`iter`方法接受`self`，或者你的`SomethingError`类型没有实现`Error`——用户可能会根据他们对接口的预期编写错误的代码。他们会感到惊讶和沮丧，并且不得不花时间去弄清楚你的接口与他们的预期有什么不同。当我们能够为用户减少这种摩擦时，我们应该尽量做到。

### 类型的常见特征

Rust 用户通常会做出一个重要的假设，即接口中的所有东西“都能正常工作”。他们期望能够使用`{:?}`打印任何类型，并将任何东西发送到另一个线程，而且他们还期望每个类型都实现了`Clone`。在可能的情况下，我们应避免给用户带来意外，并且积极实现大多数标准特征，即使我们暂时不需要它们。

由于第二章讨论的连贯性规则，编译器将不允许用户在需要这些特征时自行实现它们。用户不能为外部类型（如来自你接口的类型）实现外部特征（例如`Clone`）。他们需要将你的接口类型包装在自己的类型中，即使如此，没有访问类型内部信息的权限，编写一个合理的实现也可能非常困难。

这些标准特征中的首个是`Debug`特征。几乎每种类型都可以且应该实现`Debug`，即使它仅仅是打印类型的名称。使用`#[derive(Debug)]`通常是实现接口中`Debug`特征的最佳方式，但请记住，所有派生特征会自动为任何泛型参数添加相同的限制。你也可以通过利用`fmt::Formatter`上的各种`debug_`辅助方法来编写自己的实现。

紧随其后的是 Rust 自动特性 `Send` 和 `Sync`（以及，较少程度上，`Unpin`）。如果一个类型没有实现其中一个特性，那么它应该有充分的理由。一个非 `Send` 的类型不能放入 `Mutex`，即使在包含线程池的应用中，也不能被传递使用。一个非 `Sync` 的类型不能通过 `Arc` 共享，也不能放入静态变量。用户已经习惯于这些类型在这些上下文中*正常工作*，特别是在异步环境中，几乎所有东西都运行在线程池上。如果你没有确保你的类型实现了这些特性，用户会感到沮丧。如果你的类型无法实现这些特性，确保在文档中清楚地说明这一事实及其原因！

接下来是你应该实现的几乎普遍适用的特性：`Clone` 和 `Default`。这些特性可以很容易地派生或实现，对于大多数类型来说实现它们是有意义的。如果你的类型不能实现这些特性，确保在文档中指出，因为用户通常会期望能够轻松创建更多（以及新的）类型实例。如果不能做到这一点，他们会感到惊讶。

在预期特性的层级中，接下来是比较特性：`PartialEq`、`PartialOrd`、`Hash`、`Eq` 和 `Ord`。`PartialEq` 特性尤其受欢迎，因为用户最终会遇到两个你类型的实例，他们希望用 `==` 或 `assert_eq!` 来比较它们。即使你的类型仅在同一个实例之间才会比较相等，还是值得实现 `PartialEq`，以便让用户能够使用 `assert_eq!`。

`PartialOrd` 和 `Hash` 是更为专业化的特性，可能并不适用于所有情况，但在可能的情况下，你也需要实现它们。尤其是对于用户可能用作映射中的键，或是可能通过任何 `std::collection` 集合类型进行去重的类型，因为这些类型通常需要这些边界。`Eq` 和 `Ord` 在实现类型的比较操作时，除了 `PartialEq` 和 `PartialOrd` 的要求之外，还带有额外的语义要求。这些要求在这些特性的文档中有详细说明，只有在你确定这些语义适用于你的类型时，才应实现它们，*仅限于此*。

最后，对于大多数类型，实现 `serde` crate 的 `Serialize` 和 `Deserialize` 特性是有意义的。这些特性可以轻松派生，`serde_derive` crate 甚至提供了仅重写某个字段或枚举变体的序列化机制。由于 `serde` 是一个第三方 crate，你可能不希望将其作为必需的依赖项。因此，大多数库选择提供一个 `serde` 特性，仅在用户选择时才添加对 `serde` 的支持。

你可能会好奇为什么我没有在这一节中包括可派生特征`Copy`。`Copy`与前面提到的其他特征有两点不同。首先，用户通常不期望类型是`Copy`；相反，他们往往期望如果需要两个副本的话，必须调用`clone`。`Copy`改变了移动给定类型的值的语义，这可能会让用户感到惊讶。第二个观察点是：类型变得不再是`Copy`非常容易，因为`Copy`类型的限制非常严格。一个开始时很简单的类型，最终可能需要持有`String`或其他非`Copy`类型。如果发生这种情况，而你需要移除`Copy`实现，那将是一个不兼容的改变。相比之下，通常你不需要移除`Clone`实现，因此这是一种较为轻松的承诺。

### 人体工学特征实现

Rust 并不会自动为引用类型实现特征。换句话说，你通常不能使用`fn foo<T: Trait>(t: T)`来传入`&Bar`，即使`Bar: Trait`。这是因为`Trait`可能包含一些接受`&mut self`或`self`的方法，而显然这些方法不能在`&Bar`上调用。然而，这种行为对于看到`Trait`只有`&self`方法的用户来说可能会非常令人惊讶！

正因如此，当你定义一个新的特征时，通常希望为`&T where T: Trait`、`&mut T where T: Trait`以及`Box<T> where T: Trait`提供适当的通用实现。根据`Trait`方法的接收者，你可能只能实现其中的一些。标准库中的许多特征都有类似的实现，正是因为这可以减少用户的意外。

迭代器是另一个常见的情况，你通常会想要专门为类型的引用添加特征实现。对于任何可以被迭代的类型，考虑为`&MyType`和`&mut MyType`分别实现`IntoIterator`（如果适用）。这使得`for`循环能够像用户期望的那样，在你的类型的借用实例上直接工作。

### 包装类型

Rust 并没有像传统意义上的对象继承。然而，`Deref`特征及其“亲戚”`AsRef`提供了一些类似继承的功能。这些特征允许你拥有一个类型为`T`的值，并通过直接调用`T`类型的值来调用类型`U`的方法，只要`T: Deref<Target = U>`。这对用户来说像是魔法，通常效果很好。

如果你提供一个相对透明的包装类型（如 `Arc`），你很可能希望实现 `Deref`，以便用户可以仅使用 `.` 运算符调用内部类型的方法。如果访问内部类型不需要任何复杂或可能较慢的逻辑，你还应该考虑实现 `AsRef`，这样用户就可以轻松地将 `&WrapperType` 用作 `&InnerType`。对于大多数包装类型，你还会希望在可能的情况下实现 `From<InnerType>` 和 `Into<InnerType>`，以便用户可以轻松地添加或移除你的包装。

你可能也遇到过 `Borrow` 特征，它看起来与 `Deref` 和 `AsRef` 非常相似，但实际上它是有些不同的。具体来说，`Borrow` 是为一个更窄的用例量身定制的：允许调用者提供多个基本相同的类型变体中的任何一个。它或许本可以被称为 `Equivalent`。例如，对于一个 `HashSet<String>`，`Borrow` 允许调用者提供一个 `&str` *或* `&String`。虽然同样可以通过 `AsRef` 实现这一点，但没有 `Borrow` 的额外要求（目标类型必须实现与实现类型完全相同的 `Hash`、`Eq` 和 `Ord`），这将是不安全的。`Borrow` 还对 `T`、`&T` 和 `&mut T` 实现了 `Borrow<T>` 的广泛实现，这使得它在特征边界中非常方便，可以接受给定类型的所有权 *或* 引用值。一般来说，`Borrow` 仅用于当你的类型与另一种类型本质上等价时，而 `Deref` 和 `AsRef` 更广泛地用于实现任何你的类型可以“充当”的内容。

## 灵活

你编写的每一行代码，隐式或显式地都包含一个合同。这个合同由一组要求和一组承诺组成。要求是对代码如何使用的限制，而承诺是关于代码如何使用的保证。在设计新接口时，你需要仔细考虑这个合同。一个好的经验法则是避免施加不必要的限制，并且只做出你能够兑现的承诺。增加限制或去除承诺通常需要进行重大语义版本的更改，并且可能会破坏其他地方的代码。另一方面，放宽限制或增加承诺通常是向后兼容的。

在 Rust 中，限制通常表现为特征边界和参数类型，而承诺则表现为特征实现和返回类型。例如，比较 Listing 3-1 中的三个函数签名。

```
fn frobnicate1(s: String) -> String
fn frobnicate2(s: &str) -> Cow<'_, str>
fn frobnicate3(s: impl AsRef<str>) -> impl AsRef<str>
```

Listing 3-1: 相似的函数签名，具有不同的合同

这三个函数签名都接受一个字符串并返回一个字符串，但它们的合同却大不相同。

第一个函数要求调用者拥有一个`String`类型的字符串，并且承诺返回一个拥有所有权的`String`。由于契约要求调用者分配内存，并要求我们返回一个拥有所有权的`String`，因此我们不能在不破坏向后兼容性的情况下使这个函数不再需要分配内存。

第二个函数放宽了契约：调用者可以提供任何字符串引用，因此用户不再需要分配内存或放弃`String`的所有权。它还承诺返回一个`std::borrow::Cow`，意味着它可以根据是否需要拥有字符串的所有权，返回字符串引用或拥有所有权的`String`。这里的承诺是函数将始终返回一个`Cow`，这意味着我们不能后来将其改为使用其他优化的字符串表示。调用者还必须特别提供一个`&str`，因此如果他们有一个现成的`String`，必须将其解引用为`&str`才能调用我们的函数。

第三个函数解除这些限制。它仅要求用户传入一个能够生成字符串引用的类型，并且只承诺返回值能够生成字符串引用。

这些函数签名中没有一个比其他的*更好*。如果你需要在函数中拥有一个字符串的所有权，你可以使用第一个参数类型来避免额外的字符串复制。如果你希望允许调用者利用已经分配并返回的拥有所有权的字符串的情况，那么第二个返回类型为`Cow`的函数可能是一个不错的选择。相反，我希望你从中得到的是，你应该仔细考虑接口所绑定的契约，因为事后修改它可能会带来破坏性影响。

在本节的其余部分，我将给出一些接口设计决策的例子，这些决策经常出现，并且它们对你的接口契约的影响。

### 泛型参数

你的接口必须对用户施加的一个明显要求是，他们必须为你的代码提供什么类型。如果你的函数明确地接受一个`Foo`类型，用户必须拥有并提供一个`Foo`。这是无法绕过的。在大多数情况下，使用泛型而不是具体类型是值得的，这样可以允许调用者传递任何符合你函数实际需求的类型，而不仅仅是某个特定类型。将示例 3-1 中的`&str`改为`impl AsRef<str>`就是这种宽松的一个例子。通过这种方式放宽要求的一种方法是，从完全泛型且没有边界的参数开始，然后通过编译器的错误信息来发现你需要添加哪些边界。

然而，如果把这种方法推到极限，它会让每个函数的每个参数都成为它自己的泛型类型，这将既难以阅读也难以理解。并没有硬性规则说明什么时候应该或者不应该将某个参数设为泛型，所以要凭借你的最佳判断来决定。一个好的经验法则是，如果你能想到其他类型，用户合理且频繁地想要使用而不是你最初使用的具体类型，那么就可以将该参数设为泛型。

你可能还记得在第二章中提到过，泛型代码会通过单态化（monomorphization）为每个与泛型代码一起使用的类型组合生成一份副本。考虑到这一点，过度泛化大量参数的想法可能会让你担心会使二进制文件过于庞大。在第二章中，我们还讨论了如何通过动态调度（dynamic dispatch）来缓解这一问题，并且通常不会对性能造成明显影响，这一点在这里同样适用。对于那些你反正会通过引用传递的参数（回想一下，`dyn Trait`不是`Sized`，你需要一个宽指针才能使用它们），你可以轻松地将泛型参数替换为使用动态调度的参数。例如，代替`impl AsRef<str>`，你可以使用`&dyn AsRef<str>`。

不过，在你开始这么做之前，还是有几个问题需要考虑。首先，你是代表你的用户做这个选择的，用户无法选择不使用动态调度。如果你知道你正在应用动态调度的代码永远不会对性能产生敏感影响，那么这样做可能没问题。但如果有用户想在他们的高性能应用中使用你的库，在一个热循环中调用的函数中使用动态调度可能会成为一个障碍。其次，在撰写本文时，使用动态调度仅在你拥有像`T: AsRef<str>`或`impl AsRef<str>`这样简单的特征约束时才有效。对于更复杂的约束，Rust 无法构建动态调度的 vtable，因此你不能使用像`&dyn Hash + Eq`这样的类型。最后，请记住，对于泛型，调用者始终可以通过传递特征对象来选择动态调度。而反过来则不成立：如果你接收一个特征对象，那么调用者必须提供它。

你可能会觉得很有诱惑力，从具体类型开始你的接口，然后随着时间的推移将它们变为泛型。这是可行的，但请记住，这样的变化不一定是向后兼容的。为了说明为什么，假设你将一个函数从`fn foo(v: &Vec<usize>)`改为`fn foo(v: impl AsRef<[usize]>)`。虽然每个`&Vec<usize>`都实现了`AsRef<[usize]>`，但类型推断仍然可能给用户带来问题。想象一下，如果调用者以`foo(&iter.collect())`的方式调用`foo`，会发生什么情况。在原始版本中，编译器能够确定它应该将数据收集到`Vec`中，但现在它只知道需要将数据收集到实现了`AsRef<[usize]>`的某个类型中。而且可能有多个这样的类型，因此经过此更改后，调用者的代码将无法编译！

### 对象安全

当你定义一个新特性时，该特性是否具备对象安全性（请参见第二章“编译与分发”部分的结尾）是特性的契约中一个未明确写明的部分。如果特性是对象安全的，用户可以将实现该特性的不同类型当作一个通用类型来使用`dyn Trait`。如果不是，编译器将不允许为该特性使用`dyn Trait`。即使这样做会稍微影响使用它们的可用性（比如，采用`impl AsRef<str>`而不是`&str`），你也应该倾向于使你的特性具备对象安全性，因为对象安全性能为你的特性提供新的使用方式。如果你的特性必须有一个泛型方法，考虑它的泛型参数是否可以位于特性本身，或者它的泛型参数是否也可以使用动态分发来保持特性的对象安全性。或者，你可以为该方法添加`where Self: Sized`的特性约束，这样就可以仅使用特性实例（而不是通过`dyn Trait`）调用该方法。你可以在`Iterator`和`Read`特性中看到这种模式的例子，这些特性是对象安全的，但在具体实例上提供了一些额外的便利方法。

对于“你应该愿意为保持对象安全做出多少牺牲”这个问题，并没有唯一的答案。我的建议是，你应该考虑你的特性将如何被使用，用户是否有必要将其用作特性对象。如果你认为用户可能会希望将你的特性与许多不同的实例一起使用，那么你应该更加努力地提供对象安全，而不是认为这种用例没有什么意义。例如，动态分发对于`FromIterator`特性没有用处，因为它的唯一方法不接受`self`，因此你根本无法构造一个特性对象。类似地，`std::io::Seek`作为一个特性对象本身几乎没有用，因为你只能在特性对象上进行寻址，而无法进行读写操作。

请记住，对象安全是你公共接口的一部分！如果你以向后兼容的方式修改了特性，比如添加一个具有默认实现的方法，但却导致特性不再具备对象安全性，那么你需要增加你的主语义版本号。

### 借用与拥有

对于你在 Rust 中定义的几乎每个函数、特性和类型，你都必须决定它是应该拥有其数据，还是仅仅持有其数据的引用。无论你做出什么决定，都将对你的接口的可用性和性能产生深远的影响。幸运的是，这些决策通常会自己显现出来。

如果你编写的代码需要拥有数据，例如调用需要`self`的方式或将数据移动到另一个线程，它必须存储拥有的数据。当你的代码必须拥有数据时，通常也应该要求调用者提供拥有的数据，而不是通过引用获取值并克隆它们。这让调用者控制分配过程，并且明确了使用该接口的成本。

另一方面，如果你的代码不需要拥有数据，它应该改为操作引用。一个常见的例外是像`i32`、`bool`或`f64`这样的简单类型，它们直接存储和复制的成本与通过引用存储的成本相当。然而，要小心假设这一规则适用于所有`Copy`类型；`[u8; 8192]`是`Copy`类型，但将它到处存储和复制会非常昂贵。

有时，你并不知道代码是否需要拥有数据，因为这取决于运行时。在这种情况下，`Cow`类型是你的朋友。它允许你通过持有引用或拥有的值来表示可能拥有的数据。如果要求在只有引用时生成一个拥有的值，`Cow`会使用`ToOwned`特性在幕后创建一个，通常是通过克隆。`Cow`通常用于返回类型，表示某些函数可能会分配内存。例如，`String::from_utf8_lossy`只有在输入包含无效 UTF-8 时才会分配内存。`Cow`也可以用于函数的参数，这些函数有时会使用拥有的输入，但在实践中这种情况较少见。

有时，引用生命周期会使接口变得复杂到让它使用起来很麻烦。如果你的用户在使用你的接口时难以让代码编译通过，那通常是一个信号，表明你可能希望（即使不必要）对某些数据拥有所有权。如果你这么做，应该从那些克隆成本较低或不涉及性能敏感的部分数据开始，然后再决定是否为可能是大块字节的数据分配堆内存。

### 可失败和阻塞的析构函数

以 I/O 为中心的类型通常在被丢弃时需要执行清理操作。这可能包括将数据刷新到磁盘、关闭文件或优雅地终止与远程主机的连接。执行这些清理操作的自然位置是在该类型的`Drop`实现中。不幸的是，一旦值被丢弃，我们就没有办法通过其他方式向用户报告错误，除了触发恐慌（panic）。在异步代码中也会出现类似的问题，我们希望在有待完成的工作时完成任务。等到`drop`被调用时，执行器可能已经在关闭中，我们也无法再执行更多的工作。我们可以尝试启动另一个执行器，但这会带来一系列问题，例如在异步代码中阻塞，正如我们在第八章中将看到的那样。

这些问题没有完美的解决方案，无论我们做什么，一些应用程序不可避免地会回落到我们的`Drop`实现。因此，我们需要通过`Drop`提供尽力而为的清理工作。如果清理出错，至少我们尝试过——我们会吞下错误并继续。如果执行器仍然可用，我们可能会启动一个未来任务来进行清理，但如果它永远无法执行，我们也尽力了。

然而，我们应该为那些希望不留下任何悬而未决问题的用户提供更好的替代方案。我们可以通过提供显式析构函数来做到这一点。这通常表现为一个方法，该方法获取`self`的所有权，并暴露销毁过程中固有的任何错误（使用`-> Result<_, _>`）或异步操作（使用`async fn`）。谨慎的用户可以使用该方法优雅地拆除任何相关资源。

和往常一样，这里有一个权衡。一旦你添加了显式析构函数，你将遇到两个问题。首先，由于你的类型实现了`Drop`，你无法在析构函数中从任何该类型的字段中移动出来。这是因为`Drop::drop`会在显式析构函数运行后被调用，它需要`&mut self`，这要求`self`的任何部分都不能被移动。其次，`drop`接受的是`&mut self`，而不是`self`，因此你的`Drop`实现不能简单地调用显式析构函数并忽略其结果（因为它不拥有`self`）。有几种方法可以绕过这些问题，但没有一种是完美的。

第一个方法是将你的顶层类型做成一个围绕`Option`的新类型包装器，`Option`又包含一个内部类型，该类型包含所有字段。然后，你可以在两个析构函数中使用`Option::take`，并且仅在内部类型尚未被取走时，才调用内部类型的显式析构函数。由于内部类型没有实现`Drop`，你可以获得所有字段的所有权。此方法的缺点是，你希望在顶层类型上提供的所有方法现在必须包含代码，绕过`Option`（你知道它总是`Some`，因为`drop`尚未被调用）以访问内部类型的字段。

第二个解决方法是让每个字段都变得*可取走*。你可以通过将`Option`替换为`None`来“取走”它（这就是`Option::take`的作用），但你也可以对许多其他类型进行类似操作。例如，你可以通过将`Vec`或`HashMap`替换为它们便宜的默认构造值来取走它们——`std::mem::take`在这里非常有用。如果你的类型有合理的“空”值，这种方法非常有效，但如果你必须将几乎每个字段都包装在`Option`中，然后在访问这些字段时用匹配的`unwrap`来修改每个访问，就会变得非常繁琐。

第三个选项是将数据保存在`ManuallyDrop`类型中，该类型解引用到内部类型，因此无需进行 unwrap。你也可以在`drop`中使用`ManuallyDrop::take`来在销毁时获取所有权。这个方法的主要缺点是`ManuallyDrop::take`是一个不安全的操作。没有任何安全机制来确保你在调用`take`之后不会尝试使用`ManuallyDrop`中的值，或者确保你不会多次调用`take`。如果你这样做了，程序将悄无声息地表现出未定义的行为，且可能会发生严重问题。

最终，你应该选择最适合你的应用程序的方式。我倾向于选择第二种方式，只有当你发现自己陷入了大量`Option`的困境时，才切换到其他方式。如果代码足够简单，你可以轻松检查代码的安全性，并且你对自己能够做到这一点有信心，那么`ManuallyDrop`的解决方案是非常好的。

## 显而易见

虽然一些用户可能熟悉支撑你接口实现的某些方面，但他们不太可能理解所有的规则和限制。他们可能不知道在调用`bar`之后调用`foo`永远是不可以的，也不知道只有当月亮位于 47 度角并且过去 18 秒内没有人打喷嚏时，调用不安全方法`baz`才是安全的。只有当接口明确表明某些行为很奇怪时，用户才会去查阅文档或仔细阅读类型签名。因此，为用户提供尽可能简便的理解接口的方式，并尽可能使其难以错误使用接口是至关重要的。实现这一点的两大主要技术手段就是文档和类型系统，接下来我们分别来看一下这两者。

### 文档

让你的接口透明的第一步是写好文档。我可以写一本书来专门讨论如何写文档，但在这里我们将专注于 Rust 的特定建议。

首先，清楚地记录下任何可能导致代码产生意外行为的情况，或者代码依赖用户在类型签名之外执行的操作。恐慌是这两种情况的一个好例子：如果你的代码可能发生恐慌，文档中需要记录这一事实，并说明在什么情况下可能发生恐慌。同样，如果代码可能返回错误，也需要记录在哪些情况下会返回错误。对于不安全的函数，记录调用者需要保证什么条件才能确保调用是安全的。

第二，为你的代码提供端到端的使用示例，分别在 crate 和模块层级上。这些示例比针对特定类型或方法的示例更为重要，因为它们可以让用户了解整个系统是如何协同工作的。通过对接口结构的高层次理解，开发者很快就能意识到某些方法和类型的作用以及它们应该如何使用。端到端的示例还为用户提供了定制使用的起点，他们通常会复制并粘贴示例，然后根据自己的需求修改它。这种“做中学”的方法通常比让用户从各个组件拼凑起来要有效得多。

第三，组织好你的文档。将所有的类型、特征和函数放在一个顶级模块中会让用户很难判断从哪里开始。利用模块将语义相关的项组合在一起。然后，使用文档内链接相互关联这些项目。如果类型 A 的文档中提到特征 B，那么就应该直接链接到该特征。如果你让用户更容易探索你的接口，他们就不太可能错过重要的连接或依赖关系。还要考虑使用`#[doc(hidden)]`标记那些由于历史原因而需要存在但不打算公开的接口部分，这样它们就不会干扰文档。

最后，尽可能丰富你的文档。链接到外部资源，解释概念、数据结构、算法或其他接口方面的内容，这些可能在其他地方有很好的解释。RFC、博客文章和白皮书是很好的资源，如果有相关的。使用`#[doc(cfg(..))]`突出显示那些只有在特定配置下才可用的项，让用户快速理解为什么某些文档中列出的方法不可用。使用`#[doc(alias = "...")]`使类型和方法能通过用户可能搜索的其他名称进行发现。在顶级文档中，引导用户查看常用的模块、功能、类型、特征和方法。

### 类型系统指导

类型系统是确保你的接口明显、自动文档化且抗滥用的优秀工具。你有多种技术手段可以使你的接口不容易被滥用，从而更有可能正确地使用它们。

其中第一个是*语义类型*，即你添加类型来表示一个值的*含义*，而不仅仅是它的原始类型。经典的例子是布尔类型：如果你的函数接受三个`bool`类型的参数，通常某个用户会搞错参数顺序，并且只有在某些严重问题发生后才会意识到这一点。而另一方面，如果它接受三个不同的、带有两个变体的枚举类型作为参数，用户就无法搞错顺序，因为编译器会立即报错：如果他们试图将`DryRun::Yes`传给`overwrite`参数，这是行不通的，传`Overwrite::No`给`dry_run`参数也不行。你可以将语义类型应用到布尔类型之外的其他类型。例如，围绕数字类型的新类型可能为包含的值提供一个单位，或者它可以限制原始指针参数，只接受由其他方法返回的指针。

一个密切相关的技术是使用零大小类型来表示类型实例的某些事实。例如，考虑一个名为`Rocket`的类型，它表示一个真实火箭的状态。在`Rocket`上的某些操作（方法）无论火箭处于何种状态都应该可用，但有些操作只有在特定情况下才有意义。例如，如果火箭已经发射，就无法再次发射。同样，如果火箭尚未发射，可能也不应允许拆卸燃料箱。我们可以将这些操作建模为枚举变体，但那样的话，所有方法在每个阶段都会可用，并且我们需要引入可能的恐慌（panic）。

相反，如清单 3-2 所示，我们可以在`Rocket`、`Stage`上引入一个泛型参数，并使用它来限制在何时可以调用哪些方法。

```
1 struct Grounded;
struct Launched;
// and so on
struct Rocket<Stage = Grounded> {
  2 stage: std::marker::PhantomData<Stage>,
}

3 impl Default for Rocket<Grounded> {}
impl Rocket<Grounded> {
  pub fn launch(self) -> Rocket<Launched> { }
}
4 impl Rocket<Launched> {
  pub fn accelerate(&mut self) { }
  pub fn decelerate(&mut self) { }
}

5 impl<Stage> Rocket<Stage> {
  pub fn color(&self) -> Color { }
  pub fn weight(&self) -> Kilograms { }
}
```

清单 3-2：使用标记类型来限制实现

我们引入了单位类型来表示火箭的每个阶段。实际上，我们并不需要存储阶段本身——只需存储它提供的元信息——因此我们通过`PhantomData`存储它，以确保它在编译时被消除。然后，我们仅在`Rocket`持有特定类型参数时，才编写实现块。你只能在地面上构建火箭（暂时如此），并且只能从地面发射它。只有当火箭已被发射时，才能控制其速度。有些事情是你无论火箭处于什么状态时都可以做的，这些操作我们放入了泛型实现块中。你会注意到，以这种方式设计接口时，用户不可能在错误的时机调用方法——我们已经将使用规则编码在类型本身中，并使非法状态*无法表示*。

这个概念也扩展到了许多其他领域；如果你的函数忽略了一个指针参数，除非给定的布尔参数为真，那么最好将这两个参数合并在一起。使用一个枚举类型，其中一个变体表示`false`（且没有指针），另一个变体表示`true`并携带一个指针，这样调用者和实现者都不会误解这两者之间的关系。这是一个强大的思想，我强烈鼓励你加以利用。

另一个小而有用的工具，能够使接口更直观的是`#[must_use]`注解。将其添加到任何类型、特征或函数上，如果用户的代码接收了该类型或特征的元素，或者调用了该函数，却没有显式处理它，编译器将发出警告。你可能已经在`Result`的上下文中见过这种用法：如果一个函数返回一个`Result`，而你没有在某个地方使用其返回值，就会收到编译器的警告。不过，要小心不要过度使用这个注解——只有当用户如果不使用返回值时，很可能会犯错误时，才应该添加它。

## 受限

随着时间的推移，某些用户会依赖你接口的每个属性，无论是 bug 还是功能。这对于那些公开可用的库尤其如此，因为你无法控制用户的使用方式。因此，在做出对用户可见的修改之前，你应该仔细思考。无论是添加一个新的类型、字段、方法或特征实现，还是修改现有的，你都需要确保这些修改不会破坏现有用户的代码，并且你打算在一段时间内保留这个修改。频繁的向后不兼容修改（语义版本管理中的主版本增加）必然会引起用户的不满。

许多向后不兼容的更改是显而易见的，比如重命名公共类型或删除公共方法，但有些更改则更为微妙，并且与 Rust 的工作方式深度结合。在这里，我们将讨论一些更棘手、微妙的更改，以及如何为它们做好规划。你会看到，你需要在这些变化与希望接口灵活性之间找到平衡——有时候，必须做出妥协。

### 类型修改

删除或重命名公共类型几乎肯定会破坏某些用户的代码。为了应对这一点，你需要尽可能利用 Rust 的可见性修饰符，如`pub(crate)`和`pub(in path)`。公共类型越少，你在以后修改代码时，就能越自由地避免破坏现有代码。

然而，用户的代码可以以比仅仅通过名称依赖你的类型更多的方式进行依赖。考虑一下列表 3-3 中的公共类型以及该代码的使用方式。

```
// in your interface
pub struct Unit;
// in user code
let u = lib::Unit;
```

列表 3-3：一个看似无害的公共类型

现在考虑一下，如果你向`Unit`添加一个私有字段会发生什么。即使你添加的字段是私有的，这个改变仍然会破坏用户的代码，因为他们依赖的构造函数已经消失了。类似地，考虑一下列表 3-4 中的代码和用法。

```
// in your interface
pub struct Unit { pub field: bool };
// in user code
fn is_true(u: lib::Unit) -> bool {
    matches!(u, Unit { field: true })
}
```

列表 3-4：用户代码访问单一公共字段

在这里，向 `Unit` 添加一个私有字段会破坏用户代码，这次是因为 Rust 的穷举模式匹配检查逻辑能够看到用户无法看到的接口部分。它会识别出有更多的字段，尽管用户代码无法访问它们，并拒绝用户的模式作为不完整模式。如果我们将元组结构体转换为带有命名字段的常规结构体，也会出现类似的问题：即使字段本身完全相同，任何旧模式也将不再适用于新的类型定义。

Rust 提供了 `#[non_exhaustive]` 属性来帮助缓解这些问题。你可以将它添加到任何类型定义中，编译器将禁止在该类型上使用隐式构造函数（例如 `lib::Unit { field1: true }`）和非穷举模式匹配（即没有尾随 `, ..` 的模式）。如果你怀疑将来可能会修改某个特定类型，那么添加这个属性是非常有用的。然而，它确实会约束用户代码，例如剥夺用户依赖穷举模式匹配的能力，因此，如果你认为某个类型可能保持稳定，最好避免添加这个属性。

### 特征实现

正如你在第二章中回顾到的，Rust 的一致性规则不允许对给定类型的特征进行多重实现。由于我们不知道下游代码可能已经添加了什么实现，添加现有特征的通用实现通常是一个破坏性更改。对现有类型实现外部特征，或对外部类型实现现有特征也是如此——在这两种情况下，外部特征或类型的拥有者可能会同时添加冲突的实现，因此这必须是一个破坏性更改。

移除一个特征实现是一个破坏性更改，但为一个*新*类型实现特征永远不是问题，因为没有 crate 会有与该类型冲突的实现。

或许反直觉的是，你也需要小心为现有类型实现*任何*特征。为了理解原因，考虑列表 3-5 中的代码。

```
// crate1 1.0
pub struct Unit;
put trait Foo1 { fn foo(&self) }
// note that Foo1 is not implemented for Unit

// crate2; depends on crate1 1.0
use crate1::{Unit, Foo1};
trait Foo2 { fn foo(&self) }
impl Foo2 for Unit { .. }
fn main() {
  Unit.foo();
}
```

列表 3-5：为现有类型实现特征可能会导致问题。

如果你为 `crate1` 添加了 `impl Foo1 for Unit`，却没有标记为破坏性更改，下游代码将突然停止编译，因为对 `foo` 的调用现在变得模糊不清。这甚至适用于实现*新*公共特征的情况，如果下游 crate 使用了通配符导入（`use crate1::*`）。如果你提供了一个 `prelude` 模块，并指示用户使用通配符导入，你尤其需要牢记这一点。

对现有特征的大多数更改也是破坏性更改，例如更改方法签名或添加新方法。更改方法签名会破坏所有实现，并可能破坏特征的许多使用情况，而添加新方法“仅仅”会破坏所有实现。然而，添加带有默认实现的新方法是可以的，因为现有的实现将继续适用。

我这里说“通常”和“最”是因为作为接口的作者，我们有一个工具可以让我们绕过一些规则：*封闭特征*。封闭特征是只能由其他 crate 使用，而不能由它们实现的特征。这立即使得一些破坏性更改变得非破坏性。例如，你可以向封闭特征添加一个新方法，因为你知道没有其他实现需要考虑。同样，你可以为新的外部类型实现封闭特征，因为你知道定义该类型的外部 crate 不可能添加与之冲突的实现。

封闭特征最常用于*派生*特征——为实现特定其他特征的类型提供通用实现的特征。只有当你认为外部 crate 不应实现你的特征时，才应该封闭特征；这会严重限制特征的可用性，因为下游 crate 将无法为自己的类型实现该特征。你还可以使用封闭特征来限制哪些类型可以作为类型参数，例如在 列表 3-2 的 `Rocket` 示例中，将 `Stage` 类型限制为仅 `Grounded` 和 `Launched` 类型。

列表 3-6 展示了如何封闭一个特征，并如何在定义 crate 中为其添加实现。

```
pub trait CanUseCannotImplement: sealed::Sealed 1 { .. }
mod sealed {
  pub trait Sealed {}
  2 impl<T> Sealed for T where T: TraitBounds {}
}
impl<T> CanUseCannotImplement for T where T: TraitBounds {}
```

列表 3-6：如何封闭一个特征并为其添加实现

诀窍是将一个私有的、空的特征作为你希望封闭的特征的超特征 1。由于超特征位于私有模块中，其他 crate 无法访问它，因此也无法实现它。封闭特征要求底层类型实现 `Sealed`，因此只有我们明确允许的类型 2 才能最终实现该特征。

### 隐藏的契约

有时，你对代码某一部分所做的更改会以微妙的方式影响接口中其他部分的契约。发生这种情况的两种主要方式是通过重新导出和自动特征。

#### 重新导出

如果你的接口的任何部分暴露了外部类型，那么这些外部类型的任何变化*也*会影响你的接口。例如，考虑如果你迁移到依赖项的新主版本，并将该依赖项中的某个类型作为迭代器类型暴露在你的接口中，会发生什么。依赖于你的接口的用户可能也会直接依赖该依赖项，并期望你的接口提供的类型与该依赖项中相同名称的类型相同。但如果你更改了依赖项的主版本，即使类型的*名称*相同，这种假设也不再成立。列表 3-7 展示了这一点的示例。

```
// your crate: bestiter
pub fn iter<T>() -> itercrate::Empty<T> { .. }
// their crate
struct EmptyIterator { it: itercrate::Empty<()> }
EmptyIterator { it: bestiter::iter() }
```

列表 3-7：重新导出使外部 crate 成为你接口契约的一部分。

如果你的 crate 从 `itercrate 1.0` 迁移到 `itercrate 2.0`，但其他方面没有变化，那么此列表中的代码将无法编译。即使类型没有发生变化，编译器也会（正确地）认为 `itercrate1.0::Empty` 和 `itercrate2.0::Empty` 是*不同*的类型。因此，你不能将后者赋值给前者，这使得这是一个破坏性的接口变更。

为了减轻类似问题，通常最好的做法是使用新类型模式（newtype pattern）来包装外部类型，然后仅暴露你认为有用的外部类型部分。在许多情况下，你可以完全避免使用新类型包装器，通过 `impl Trait` 只提供非常简化的契约给调用者。通过承诺更少，你可以减少破坏性变化。

#### 自动特性

Rust 有一些特性（traits）会根据类型所包含的内容自动实现。对于本次讨论，最相关的是 `Send` 和 `Sync`，尽管 `Unpin`、`Sized` 和 `UnwindSafe` 特性也存在类似的问题。从本质上讲，这些特性为你的接口中的几乎每个类型添加了一个隐藏的承诺。这些特性甚至会通过像 `impl Trait` 这样的类型擦除类型传播。

这些特性的实现（通常）是由编译器自动添加的，但这也意味着，如果它们不再适用，它们*不会*被自动添加。所以，如果你有一个包含私有类型 `B` 的公共类型 `A`，并且你修改 `B` 使其不再是 `Send`，那么 `A` 现在*也*不再是 `Send`。这就是一个破坏性更改！

这些变化可能很难追踪，并且通常直到接口的用户抱怨他们的代码不再工作时才会被发现。为了在问题发生前捕捉到这些情况，良好的做法是在测试套件中包含一些简单的测试，检查你的所有类型是否按照预期实现了这些特性。列表 3-8 给出了一个此类测试的示例。

```
fn is_normal<T: Sized + Send + Sync + Unpin>() {}
#[test]
fn normal_types() {
  is_normal::<MyType>();
}
```

列表 3-8：测试类型是否实现了一组特性

请注意，这个测试不会运行任何代码，而只是测试代码是否能成功编译。如果 `MyType` 不再实现 `Sync`，测试代码将无法编译，你将知道你刚刚做的更改破坏了自动特性实现。

## 总结

在本章中，我们探讨了设计 Rust 接口的多个方面，无论它是面向外部使用，还是仅作为你 crate 内部不同模块之间的抽象边界。我们覆盖了许多具体的陷阱和技巧，但最终，高层的原则应该是引导你思考的方向：你的接口应该是让人毫不意外、灵活、显而易见且有约束的。在下一章中，我们将深入讨论如何在 Rust 代码中表示和处理错误。
