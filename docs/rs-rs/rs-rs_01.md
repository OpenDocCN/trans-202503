# 第一章：基础

![](img/chapterart.png)

当你深入探索 Rust 的更高级内容时，确保你对基础知识有扎实的理解非常重要。像任何编程语言一样，在你开始以更复杂的方式使用 Rust 时，各种关键字和概念的精确定义变得至关重要。在本章中，我们将逐步讲解 Rust 的许多基本概念，并尽可能清晰地定义它们的含义、工作原理以及为什么它们是以这种方式存在的。具体来说，我们将探讨变量和值的区别、它们在内存中的表示方式以及程序所拥有的不同内存区域。接着，我们将讨论一些所有权、借用和生命周期的细微之处，这些都是你在继续阅读本书之前需要掌握的内容。

如果你愿意，你可以从头到尾阅读本章，或者将其作为参考，回顾你不太确定的概念。我建议你在完全理解本章内容之前，不要急于继续，因为对这些基本概念的误解会迅速阻碍你理解更高级的主题，或者导致你错误地使用它们。

## 讨论内存

并非所有内存都是相同的。在大多数编程环境中，你的程序可以访问栈、堆、寄存器、文本段、内存映射寄存器、内存映射文件，甚至可能是非易失性 RAM。你选择在特定情况下使用哪种内存区域，会影响你能在那里存储什么、它能保持可访问的时间以及你如何访问它。不同平台之间这些内存区域的具体细节有所不同，超出了本书的范围，但有些内存区域对于你理解 Rust 代码的方式非常重要，值得在这里进行讨论。

### 内存术语

在我们深入了解内存区域之前，你需要先了解值、变量和指针之间的区别。Rust 中的一个*值*是类型和该类型值域中的元素的组合。一个值可以通过其类型的*表示*转换为字节序列，但单独来看，你可以把值理解为你作为程序员所表示的东西。例如，类型为 `u8` 的数字 `6` 是数学整数 6 的一个实例，其在内存中的表示是字节 `0x06`。类似地，字符串 `str` `"Hello world"` 是所有字符串的一个值，其表示是其 UTF-8 编码。一个值的含义与这些字节存储的位置无关。

一个值被存储在一个*位置*中，这个术语在 Rust 中指的是“可以存储值的位置”。这个位置可以位于栈上、堆上或其他多个地方。存储值最常见的位置是一个*变量*，它是栈上一个命名的值槽。

*指针*是一个值，它保存内存区域的地址，因此指针指向一个位置。指针可以被解引用以访问它所指向的内存位置中存储的值。我们可以将相同的指针存储在多个变量中，从而让多个变量间接引用内存中的同一位置，因此引用相同的底层值。

请参考示例 1-1 中的代码，它展示了这三个元素。

```
let x = 42;
let y = 43;
let var1 = &x;
let mut var2 = &x;
1 var2 = &y;
```

示例 1-1：值、变量和指针

在这里，有四个不同的值：`42`（一个`i32`），`43`（一个`i32`），`x`的地址（一个指针），以及`y`的地址（一个指针）。也有四个变量：`x`、`y`、`var1`和`var2`。后两个变量都保存指针类型的值，因为引用是指针。虽然`var1`和`var2`最初存储相同的值，但它们存储的是该值的独立副本；当我们改变`var2`中存储的值时，`var1`中的值不会改变。特别地，`=`运算符将右侧表达式的值存储在左侧命名的地方。

一个有趣的例子，展示了变量、值和指针之间的区别何时变得重要，出现在如下语句中：

```
let string = "Hello world";
```

即使我们将一个字符串值赋给变量`string`，该变量的*实际*值是指向字符串值`"Hello world"`中第一个字符的指针，而不是字符串值本身。此时你可能会说，“等等，那字符串值到底存储在哪里？指针指向哪里？”如果是这样，你的眼光非常敏锐——我们马上就会讲到这个问题。

### 变量深入解析

我之前给出的变量定义比较宽泛，单独来看可能并不太有用。随着你遇到更复杂的代码，你将需要一个更准确的思维模型，帮助你推理程序到底在做什么。我们可以利用许多这样的模型。详细描述它们会占用几章内容，超出了本书的范围，但广义上来说，它们可以分为两类：高级模型和低级模型。高级模型适用于从生命周期和借用的角度思考代码，而低级模型则适合在你推理不安全代码和原始指针时使用。以下两节中描述的变量模型足以涵盖本书中的大部分内容。

#### 高级模型

在高级模型中，我们不把变量看作存储字节的地方。相反，我们把它们看作是赋值时被赋予名称的值，这些值在程序中被实例化、移动并使用。当你将一个值赋给一个变量时，从此该变量就会“命名”这个值。当后续访问变量时，你可以想象从变量的前次访问到新的访问之间画一条线，这样就建立了两个访问之间的依赖关系。如果变量中的值被移动，则不再能够从其访问绘制任何线条。

在这个模型中，一个变量仅在它持有一个合法的值时存在；你不能从一个未初始化或已被移动的变量绘制线条，所以实际上它就不存在了。使用这个模型，你的整个程序由许多这样的依赖线条组成，这些线条通常被称为*流*，每一条都追踪一个特定值实例的生命周期。流可以在分支处分叉和合并，每个分支追踪该值的不同生命周期。编译器可以检查在程序的任何给定点，所有可能并行存在的流是否兼容。例如，不能有两个并行的流同时对一个值有可变访问；也不能有一个流借用一个值，而没有一个流拥有该值。Listing 1-2 显示了这两种情况的示例。

```
let mut x;
// this access would be illegal, nowhere to draw the flow from:
// assert_eq!(x, 42);
1 x = 42;
// this is okay, can draw a flow from the value assigned above:
2 let y = &x;
// this establishes a second, mutable flow from x:
3 x = 43;
// this continues the flow from y, which in turn draws from x.
// but that flow conflicts with the assignment to x!
4 assert_eq!(*y, 42);
```

Listing 1-2：借用检查器会捕获的非法流

首先，我们不能在`x`初始化之前使用它，因为我们无法从任何地方绘制流。只有在我们为`x`赋值时，才能从它绘制流。这个代码有两个流：一个独占（`&mut`）流从 1 到 3，和一个共享（`&`）流从 1 经过 2 到 4。借用检查器会检查每个流的每个节点，确保没有其他不兼容的流并行存在。在这种情况下，当借用检查器检查 3 处的独占流时，它看到终止于 4 的共享流。由于不能同时对一个值有独占和共享的使用，借用检查器（正确地）拒绝了这段代码。注意，如果 4 不在那里，这段代码会正常编译！共享流将在 2 处终止，而当独占流在 3 处被检查时，不会有冲突的流存在。

如果声明一个新变量，且该变量与先前的变量同名，它们仍然被视为不同的变量。这被称为*遮蔽*——后声明的变量“遮蔽”了前一个变量。两个变量共存，尽管后续代码不再有方法访问前一个变量。这一模型大致匹配编译器的工作方式，特别是借用检查器如何推理程序，并且实际上在编译器内部用于生成高效的代码。

#### 低级模型

变量命名内存位置，这些位置可能包含合法值，也可能不包含。你可以把变量看作是一个“值槽”。当你给它赋值时，这个槽就被填满，原来的值（如果有的话）会被丢弃并被新值替换。当你访问它时，编译器会检查这个槽是否为空，因为如果为空，意味着变量未初始化或者其值已经被移动。指向变量的指针指向该变量的后备内存，可以解引用来获取其值。例如，在语句`let x: usize`中，变量`x`是栈上一个内存区域的名字，该区域足够存储一个`usize`类型的值，但该值没有明确的定义（槽为空）。如果你给这个变量赋值，比如`x = 6`，那块内存区域就会存储表示值`6`的字节。`&x`在你给`x`赋值时不会改变。如果你声明多个同名变量，它们最终会有不同的内存块作为后备存储。这个模型与 C 和 C++以及许多其他低级语言使用的内存模型相匹配，并且在需要明确推理内存时非常有用。

你可能会发现其中某个模型比另一个更符合你之前的理解，但我鼓励你尝试理解这两者。它们都是有效的简化模型，就像任何有用的思维模型必须具备的特点一样。如果你能够从这两种视角考虑一段代码，你会发现解决复杂的代码段变得更加容易，也能更好地理解为什么代码能够或不能按预期编译和运行。

### 内存区域

现在你已经掌握了我们如何引用内存的方式，接下来需要讨论内存到底是什么。内存有许多不同的区域，或许让你惊讶的是，并非所有的内存都存储在计算机的 DRAM 中。你使用的内存部分会对你编写代码的方式产生重大影响。在编写 Rust 代码时，三个最重要的内存区域是栈、堆和静态内存。

#### 栈

*栈*是程序用于函数调用时的临时内存空间。每当调用一个函数时，栈顶会分配一个连续的内存块，称为*帧*。栈底靠近的地方是`main`函数的帧，而随着函数调用其他函数，更多的帧会被压入栈中。一个函数的帧包含该函数内所有变量以及该函数接收的任何参数。当函数返回时，它的栈帧会被回收。

组成函数局部变量值的字节不会立即被清除，但访问它们并不安全，因为它们可能已被后续函数调用覆盖，这些函数的帧可能与被回收的帧重叠。即使它们没有被覆盖，它们也可能包含非法的值，例如在函数返回时被移动的值。

栈帧，特别是它们最终消失这一事实，和 Rust 中的生命周期概念密切相关。存储在栈帧中的任何变量，在该栈帧消失后都不能再访问，因此任何对它的引用必须具有一个生命周期，这个生命周期最多和栈帧的生命周期一样长。

#### 堆

*堆* 是一块内存池，它与程序当前的调用栈无关。堆内存中的值会一直存在，直到它们被显式地释放。当你希望一个值的生命周期超出当前函数的作用域时，堆内存就非常有用。如果这个值是函数的返回值，调用函数可以在其栈上留出一些空间，让被调用的函数在返回之前将这个值写入其中。但如果你希望将这个值发送到一个与当前线程可能没有任何栈帧共享的线程中，你可以将它存储在堆上。

堆允许你显式地分配连续的内存段。当你这样做时，你会得到指向该内存段开始位置的指针。该内存段会被保留，直到你稍后显式释放它；这个过程通常被称为*释放*，这是 C 标准库中相应函数的名称。由于堆内存的分配不会在函数返回时消失，你可以在一个地方分配内存，将指针传递给另一个线程，并让那个线程安全地继续操作该值。换句话说，当你在堆上分配内存时，得到的指针具有不受限制的生命周期——它的生命周期长到程序决定将它保持活跃为止。

在 Rust 中与堆交互的主要机制是 `Box` 类型。当你写 `Box::new(value)` 时，值会被放置到堆上，而你得到的返回值（`Box<T>`）是指向该堆上值的指针。当 `Box` 最终被丢弃时，这块内存会被释放。

如果你忘记释放堆内存，它将永远存在，你的应用程序最终会占满机器上的所有内存。这被称为*内存泄漏*，通常是我们要避免的。然而，也有一些情况你可能故意想要发生内存泄漏。例如，假设你有一个只读的配置，程序中的每个部分都应该能够访问它。你可以将其分配到堆上，并通过 `Box::leak` 显式地泄漏它，从而获得对其的 `'static` 引用。

#### 静态内存

*静态内存* 实际上是一个统称，指的是位于你程序编译文件中的多个密切相关的区域。这些区域在程序执行时会自动加载到你的程序内存中。静态内存中的值会在程序执行期间一直存在。你的程序的静态内存包含了程序的二进制代码，这些代码通常映射为只读。当你的程序执行时，它会逐条指令地遍历二进制代码，并在每次调用函数时跳转。静态内存还保存你使用`static`关键字声明的变量的内存，以及你代码中的某些常量值，如字符串。

特殊生命周期`'static`，其名称来自静态内存区域，标记一个引用有效的时间为“只要静态内存存在”，即直到程序关闭。由于静态变量的内存在程序启动时分配，指向静态内存中变量的引用，按定义就是`'static`，因为它不会被释放直到程序关闭。反之则不然——可能会有指向非静态内存的`'static`引用——但这个名称仍然是合适的：一旦你创建了一个具有静态生命周期的引用，无论它指向什么，其他部分的程序都认为它好像指向了静态内存，因为它可以在程序需要的任何时长内使用。

当你在 Rust 中工作时，你会比遇到真正的静态内存（例如通过`static`关键字）更常遇到`'static`生命周期。这是因为`'static`通常出现在类型参数的 trait 约束中。像`T: 'static`这样的约束表示类型参数`T`能够存在多长时间，我们保留它，直到程序执行结束。实质上，这个约束要求`T`是拥有者且自给自足的，要么它不借用其他（非静态）值，要么它借用的任何东西也是`'static`的，因此会一直存在直到程序结束。一个关于`'static`作为约束的好例子是`std::thread::spawn`函数，它用于创建一个新线程，这要求你传递的闭包是`'static`的。由于新线程可能会比当前线程存活得更久，它不能引用任何存储在旧线程栈上的东西。新线程只能引用那些会在其整个生命周期内存在的值，这些值可能会持续到程序结束。

## 所有权

Rust 的内存模型以所有值都有一个单一的*所有者*为核心——即，恰好有一个位置（通常是作用域）负责最终释放每个值的内存。这通过借用检查器来强制执行。如果值被移动，比如通过将其赋值给一个新变量、将其推送到一个向量中或放到堆上，那么值的所有权从旧位置转移到新位置。此时，你不能再通过原始所有者流出的变量访问该值，即使构成该值的位在技术上仍然存在。相反，你必须通过引用其新位置的变量来访问已移动的值。

有些类型是叛逆者，不遵循这个规则。如果一个值的类型实现了特殊的`Copy`特征，那么即使它被重新分配到新的内存位置，也不会被视为已经移动。相反，值会被*复制*，旧的和新的位置都可以访问。本质上，另一个相同的值实例会在移动的目标位置被构造出来。Rust 中的大多数原始类型，如整数和浮点类型，都是`Copy`类型。为了成为`Copy`，必须能够通过简单地复制它们的位来复制类型的值。这排除了所有*包含*非`Copy`类型的类型，以及任何拥有必须在值被丢弃时释放的资源的类型。

为了理解原因，考虑一下如果像 `Box` 这样的类型是 `Copy` 会发生什么。如果我们执行 `box2 = box1`，那么 `box1` 和 `box2` 都会认为它们拥有为 box 分配的堆内存，当它们超出作用域时，它们都会尝试释放这段内存。两次释放内存可能会导致灾难性的后果。

当一个值的所有者不再需要它时，清理这个值的责任就落在所有者身上，*丢弃*它。在 Rust 中，当持有值的变量不再在作用域内时，丢弃会自动发生。类型通常会递归地丢弃它们包含的值，因此丢弃一个复杂类型的变量可能会导致多个值被丢弃。由于 Rust 的显式所有权要求，我们不能意外地多次丢弃同一个值。一个持有对另一个值引用的变量并不拥有该值，因此当该变量被丢弃时，该值不会被丢弃。

清单 1-3 中的代码简要总结了有关所有权、移动和复制语义以及丢弃的规则。

```
let x1 = 42;
let y1 = Box::new(84);
{ // starts a new scope
  1 let z = (x1, y1);
  // z goes out of scope, and is dropped;
  // it in turn drops the values from x1 and y1
2 }
// x1's value is Copy, so it was not moved into z
3 let x2 = x1;
// y1's value is not Copy, so it was moved into z
4 // let y2 = y1;
```

清单 1-3：移动和复制语义

我们从两个值开始，一个是数字`42`，另一个是包含数字`84`的`Box`（堆分配的值）。前者是`Copy`类型，而后者不是。当我们将`x1`和`y1`放入元组`z`时，`x1`被*复制*到`z`中，而`y1`则被*移动*到`z`中。此时，`x1`仍然可访问并且可以再次使用 3。另一方面，一旦`y1`的值被移动 4，它就变得不可访问，任何尝试访问它的行为都会导致编译错误。当`z`超出作用域 2 时，它包含的元组值会被丢弃，这也会丢弃从`x1`复制的值和从`y1`移动的值。当`y1`的`Box`被丢弃时，它也会释放用于存储`y1`值的堆内存。

## 借用和生命周期

Rust 允许值的所有者将该值通过引用借给其他人，而不放弃所有权。*引用*是指针，它附带了额外的约定，规定了如何使用这些引用，例如该引用是否提供对引用值的独占访问权限，或者该引用的值是否可能同时被其他引用指向。

### 共享引用

共享引用`&T`，顾名思义，是可以共享的指针。可以存在任何数量的其他引用指向相同的值，并且每个共享引用都是`Copy`类型，因此你可以轻松地创建更多的共享引用。共享引用所指向的值不可变；你不能修改或重新赋值共享引用指向的值，也不能将共享引用转换为可变引用。

Rust 编译器允许假设共享引用指向的值在引用存在期间*不会改变*。例如，如果 Rust 编译器发现共享引用指向的值在函数中被多次读取，它可以仅读取一次并重用该值。更具体地说，列表 1-4 中的断言永远不应该失败。

```
fn cache(input: &i32, sum: &mut i32) {
  *sum = *input + *input;
  assert_eq!(*sum, 2 * *input);
}
```

列表 1-4：Rust 假设共享引用是不可变的。

编译器是否选择应用某种优化通常无关紧要。编译器的启发式规则会随着时间变化，因此你通常需要根据编译器允许的行为来编写代码，而不是依据它在某一特定时刻做出的实际行为。

### 可变引用

共享引用的替代方案是可变引用：`&mut T`。对于可变引用，Rust 编译器同样可以完全利用引用所附带的约定：编译器假设没有其他线程通过共享引用或可变引用访问目标值。换句话说，它假设可变引用是*独占的*。这使得某些优化变得可能，而这些优化在其他语言中可能不容易实现。例如，参考列表 1-5 中的代码。

```
fn noalias(input: &i32, output: &mut i32) {
  if *input == 1 {
   1 *output = 2;
  }
2 if *input != 1 {
     *output = 3;
  }
}
```

列表 1-5：Rust 假设可变引用是独占的。

在 Rust 中，编译器可以假设 `input` 和 `output` 不指向相同的内存。因此，在 1 处重新分配 `output` 不会影响 2 处的检查，整个函数可以作为一个单独的 `if-else` 块编译。如果编译器不能依赖于独占的可变性契约，那么该优化将无效，因为 `input` 为 `1` 时可能导致 `output` 为 `3`，例如在 `noalias(&x, &mut x)` 的情况下。

可变引用让你只能修改引用所指向的内存位置。是否可以修改超出直接引用范围的值，取决于该类型之间提供的方法。这可以通过一个示例更容易理解，参考 列表 1-6。

```
let x = 42;
let mut y = &x; // y is of type &i32
let z = &mut y; // z is of type &mut &i32
```

列表 1-6：可变性仅适用于直接引用的内存。

在这个例子中，你可以通过让指针 `y` 引用另一个变量来改变指针的值（即改变指针本身），但你不能改变它所指向的值（即 `x` 的值）。同样，你可以通过 `z` 来改变 `y` 的指针值，但不能改变 `z` 本身，使其持有不同的引用。

拥有一个值和拥有它的可变引用之间的主要区别在于，拥有者负责在不再需要该值时丢弃它。除此之外，你可以通过可变引用做任何你可以通过拥有该值做的事情，有一个例外：如果你将值从可变引用背后移走，那么你必须留下另一个值来替代它。如果你没有这样做，拥有者仍然认为它需要丢弃该值，但没有值可以丢弃！

列表 1-7 给出了你如何移除可变引用背后值的示例。

```
fn replace_with_84(s: &mut Box<i32>) {
  // this is not okay, as *s would be empty:
1 // let was = *s;
  // but this is:
2 let was = std::mem::take(s);
  // so is this:
3 *s = was;
  // we can exchange values behind &mut:
  let mut r = Box::new(84);
4 std::mem::swap(s, &mut r);
  assert_ne!(*r, 84);
}
let mut s = Box::new(42);
replace_with_84(&mut s);
5
```

列表 1-7：通过可变引用的访问必须留下一个值。

我已经添加了注释掉的行，表示非法操作。你不能简单地将值移出 1，因为调用者仍然认为它拥有该值，并会在 5 处再次释放它，从而导致双重释放。如果你只是想留下一个有效的值，`std::mem::take` 2 是一个很好的选择。它等价于 `std::mem::replace(&mut value, Default::default())`；它将 `value` 从可变引用后面移出，但在其位置留下一个新的默认值。默认值是一个独立的、拥有的值，因此调用者可以在作用域结束时安全地丢弃它。

或者，如果你不需要引用背后的旧值，你可以用一个你已经拥有的值 3 来覆盖它，将其留给调用者稍后丢弃该值。当你这么做时，原来在可变引用背后的值会立即被丢弃。

最后，如果你有两个可变引用，你可以交换它们的值而无需拥有它们 4，因为两个引用最终都会得到一个合法的拥有值，供它们的拥有者最终释放。

### 内部可变性

有些类型提供 *内部可变性*，意味着它们允许你通过共享引用来变更一个值。这些类型通常依赖于额外的机制（如原子 CPU 指令）或不变量来提供安全的可变性，而不依赖于独占引用的语义。这些类型通常分为两类：一类是让你通过共享引用获得可变引用，另一类是让你仅凭共享引用就能替换一个值。

第一类类型包括 `Mutex` 和 `RefCell`，它们包含安全机制，确保对于它们给出的可变引用的任何值，在同一时间内只能存在一个可变引用（且没有共享引用）。在底层，这些类型（以及类似的类型）都依赖于一个名为 `UnsafeCell` 的类型，其名称应该让你在使用时有所犹豫。我们将在第九章详细讨论 `UnsafeCell`，但目前你需要知道，它是通过共享引用进行变更的*唯一*正确方式。

提供内部可变性的其他类型是那些不直接给出对内部值的可变引用，而是提供一些方法来在原地操作该值的类型。`std::sync::atomic` 中的原子整数类型和 `std::cell::Cell` 类型属于这一类。你不能直接获取到这些类型背后的 `usize` 或 `i32` 引用，但你可以在某个时刻读取并替换其值。

### 生命周期

如果你正在阅读本书，你可能已经对生命周期的概念有所了解，可能是通过编译器多次提醒生命周期规则的违规。这个层次的理解对于你编写的大部分 Rust 代码来说是足够的，但随着我们深入探索 Rust 的更复杂部分，你将需要一个更严谨的思维模型来进行工作。

新的 Rust 开发者通常被教导将生命周期视为与作用域对应：生命周期在你获取某个变量的引用时开始，在该变量被移动或超出作用域时结束。这通常是正确的，而且通常很有用，但现实情况要复杂一些。*生命周期*实际上是指一些引用必须在其上有效的代码区域。虽然生命周期通常与作用域重合，但它不一定总是如此，正如我们稍后在本节中将看到的那样。

#### 生命周期与借用检查器

Rust 生命周期的核心是*借用检查器*。每当某个生命周期`'a`的引用被使用时，借用检查器检查`'a`是否仍然*有效*。它通过回溯路径到`'a`开始的地方——即引用被获取的地方——并检查沿路径是否没有冲突的使用。这确保了引用仍然指向一个安全访问的值。这类似于我们在本章前面讨论的高级“数据流”思维模型；编译器检查我们正在访问的引用的流动是否与其他平行的流动冲突。

清单 1-8 展示了一个简单的代码示例，带有对`x`引用的生命周期注解。

```
let mut x = Box::new(42);
1 let r = &x;           // 'a
if rand() > 0.5 {
2 *x = 84;
} else {
3 println!("{}", r);  // 'a
}
4
```

清单 1-8：生命周期不需要是连续的。

当我们获取对`x`的引用时，生命周期从 1 开始。在第一个分支 2 时，我们立即尝试通过将`x`的值更改为`84`来修改`x`，这需要一个`&mut x`。借用检查器获取对`x`的可变引用，并立即检查它的使用。它没有发现引用被获取时与使用时之间存在冲突的使用，因此它接受了这段代码。如果你习惯于将生命周期视为作用域，可能会感到惊讶，因为`r`仍然在 2 时有效（它在 4 时失效）。但是，借用检查器足够智能，能意识到如果选择了这个分支，`r`之后不会被使用，因此允许在此处可变地访问`x`。换句话说，从 1 开始的生命周期不会延伸到这个分支：在 2 之后没有来自`r`的流动，因此没有冲突的流动。借用检查器接着找到了在 3 时打印语句中使用`r`的地方。它回溯到 1，并没有发现冲突的使用（2 不在这个路径上），因此它也接受了这个使用。

如果我们在清单 1-8 中添加一个在 4 时对`r`的使用，代码将不再编译。生命周期`'a`将从 1 持续到 4（`r`的最后一次使用），当借用检查器检查我们对`r`的新使用时，它会在 2 时发现一个冲突的使用。

生命周期可能变得相当复杂。在清单 1-9 中，你可以看到一个生命周期的例子，它有*空洞*，在它开始和最终结束之间存在间歇性无效的情况。

```
let mut x = Box::new(42);
1 let mut z = &x;          // 'a
for i in 0..100 {
2 println!("{}", z);     // 'a
3 x = Box::new(i);
4 z = &x;                // 'a
}
println!("{}", z);       // 'a
```

清单 1-9：生命周期可以有空洞。

当我们获取对`x`的引用时，生命周期从 1 开始。然后在 3 时我们离开了`x`，这结束了生命周期`'a`，因为它不再有效。借用检查器通过认为`'a`在 2 时结束，从而接受了这个移动，这样在 3 时`x`没有冲突的流动。接着，我们通过在`z`中更新引用在 4 时重新启动生命周期。不管代码现在是回到 2 还是继续到最终的打印语句，这两种使用方式都有有效的值流动，并且没有冲突的流动，所以借用检查器接受了这段代码！

再次强调，这与我们之前讨论的内存数据流模型完全一致。当`x`被移动时，`z`就停止存在了。当我们稍后重新赋值给`z`时，我们实际上是在创建一个从那时起才存在的新变量。恰好的是，这个新变量也被命名为`z`。考虑到这个模型，这个例子并不奇怪。

#### 泛型生命周期

有时你需要在自己的类型中存储引用。这些引用需要有一个生命周期，以便借用检查器在它们在该类型的各种方法中使用时检查它们的有效性。如果你希望类型上的方法返回一个比对`self`的引用生命周期更长的引用，这一点尤其重要。

Rust 允许你在一个或多个生命周期上定义泛型类型，就像它允许你在类型上定义泛型一样。Steve Klabnik 和 Carol Nichols 的《*Rust 编程语言*》（No Starch Press，2018）对此主题进行了详细讲解，因此我在这里不会重复基础知识。但在你编写此类更复杂的类型时，有两个关于这些类型与生命周期交互的细微之处是你需要注意的。

首先，如果你的类型还实现了`Drop`，那么丢弃你的类型就算作使用了任何类型或生命周期。基本上，当你的类型的一个实例被丢弃时，借用检查器会检查在丢弃之前是否仍然合法使用你的类型的任何泛型生命周期。这是必要的，以防你的丢弃代码*确实*使用了这些引用。如果你的类型没有实现`Drop`，丢弃类型就*不*算作使用，用户可以忽略存储在类型中的任何引用，只要他们不再使用它，就像我们在列表 1-7 中看到的那样。我们将在第九章中进一步讨论这些与丢弃相关的规则。

其次，虽然一个类型可以在多个生命周期上进行泛型化，但这样做往往只会让类型签名变得不必要地复杂。通常，一个类型在单一生命周期上进行泛型化就足够了，编译器会使用插入到类型中的任何引用的较短生命周期作为那个生命周期。如果你有一个包含多个引用的类型，并且它的方法返回的引用应该与这些引用中的*一个*的生命周期绑定在一起时，你才真的需要使用多个泛型生命周期参数。

考虑列表 1-10 中的类型，它提供了一个迭代器，用于遍历由特定字符串分隔的字符串部分。

```
struct StrSplit<'s, 'p> {
  delimiter: &'p str,
  document: &'s str,
}
impl<'s, 'p> Iterator for StrSplit<'s, 'p> {
  type Item = &'s str;
  fn next(&self) -> Option<Self::Item> {
    todo!()
  }
}
fn str_before(s: &str, c: char) -> Option<&str> {
  StrSplit { document: s, delimiter: &c.to_string() }.next()
}
```

列表 1-10：需要在多个生命周期上进行泛型化的类型

当你构建这种类型时，你必须提供`delimiter`和`document`来进行搜索，它们都是字符串值的引用。当你请求下一个字符串时，你会获得一个指向文档的引用。想一想如果你在这个类型中使用单一生命周期会发生什么。迭代器产生的值将与`document`*和*`delimiter`的生命周期绑定在一起。这将使得`str_before`无法编写：返回类型会与一个局部变量的生命周期相关联——由`to_string`生成的`String`——借用检查器将拒绝这段代码。

#### 生命周期方差

方差是一个程序员常常接触到的概念，但很少知道它的名字，因为它大多数时候是不可见的。方差从表面上看描述了哪些类型是其他类型的子类型，以及何时可以用子类型替代父类型（反之亦然）。广义来说，如果类型`A`至少和类型`B`一样有用，那么`A`是`B`的子类型。方差是为什么在 Java 中，如果`Turtle`是`Animal`的子类型，你可以将一个`Turtle`传递给一个接受`Animal`的函数，或者在 Rust 中，你可以将`&'static str`传递给一个接受`&'a str`的函数。

虽然方差通常是隐藏的，但它足够常见，我们需要对它有一定的了解。`Turtle`是`Animal`的子类型，因为`Turtle`比某个不具体指定的`Animal`更“有用”——`Turtle`可以做任何`Animal`能做的事情，而且可能做得更多。同样，`'static`是`'a`的子类型，因为`'static`至少与任何`'a`一样长，因此更有用。或者更普遍地说，如果`'b: 'a`（即`'b`的生命周期比`'a`长），那么`'b`是`'a`的子类型。这显然不是正式的定义，但它已经足够接近实际使用了。

所有类型都有一个方差，它定义了哪些其他相似的类型可以替代该类型。有三种方差：协变、不变和逆变。如果你可以直接用子类型替代该类型，则该类型是*协变的*。例如，如果一个变量的类型是`&'a T`，你可以向其提供一个类型为`&'static T`的值，因为`&'a T`在`'a`上是协变的。`&'a T`在`T`上也是协变的，因此你可以将一个`&Vec<&'static str>`传递给一个接受`&Vec<&'a str>`的函数。

一些类型是*不变的*，这意味着你必须提供完全相同的类型。`&mut T`就是一个例子——如果一个函数接受`&mut Vec<&'a str>`，你不能传递给它一个`&mut Vec<&'static str>`。也就是说，`&mut T`在`T`中是不可变的。如果可以这样做，函数可能会在`Vec`中放入一个生命周期较短的字符串，调用者然后继续使用它，以为它是一个`Vec<&'static str>`，从而认为里面的字符串是`'static`！任何提供可变性的类型通常都是不可变的，原因是相同的——例如，`Cell<T>`在`T`中是不变的。

最后一类，*协变*，出现在函数参数中。如果函数类型允许其参数变得*不那么*有用，那么函数类型会更有用。如果将参数类型的方差与作为函数参数时的方差进行对比，这一点会更加清晰：

```
let x: &'static str; // more useful, lives longer
let x: &'a      str; // less useful, lives shorter

fn take_func1(&'static str) // stricter, so less useful
fn take_func2(&'a str)      // less strict, more useful
```

这种反转的关系表明，`Fn(T)`在`T`上是协变的。

那么，为什么在处理生命周期时需要了解方差呢？方差变得重要是当你考虑泛型生命周期参数如何与借用检查器交互时。考虑像示例 1-11 中所示的类型，它在单个字段中使用了多个生命周期。

```
struct MutStr<'a, 'b> {
  s: &'a mut &'b str
}
let mut s = "hello";
1 *MutStr { s: &mut s }.s = "world";
println!("{}", s);
```

示例 1-11：一个需要多个生命周期的泛型类型

乍一看，在这里使用两个生命周期似乎是不必要的——我们没有需要区分结构体不同部分借用的方法，正如在示例 1-10 中我们对`StrSplit`所做的那样。但如果你将这里的两个生命周期替换为一个`'a`，代码将无法编译！这完全是因为方差的原因。

在 1 处，编译器必须确定生命周期参数应该设置为什么生命周期。如果有两个生命周期，`'a`被设置为`s`借用的待定生命周期，而`'b`被设置为`'static`，因为这是提供的字符串`"hello"`的生命周期。如果只有一个生命周期`'a`，编译器推断该生命周期必须是`'static`。

当我们稍后尝试通过共享引用来访问字符串引用`s`并打印时，编译器试图缩短`MutStr`所使用的`s`的可变借用，以允许`s`的共享借用。

在两个生命周期的情况下，`'a`仅在`println`之前结束，而`'b`保持不变。另一方面，在单一生命周期的情况下，我们遇到了问题。编译器想要缩短`s`的借用，但为此，它还必须缩短`str`的借用。虽然`&'static str`通常可以缩短为任何`&'a str`（`&'a T`在`'a`上是协变的），但这里它处于`&mut T`背后，而`&mut T`在`T`上是不可变的。不变性要求相关类型永远不能被替换为子类型或父类型，因此编译器试图缩短借用失败，并报告`s`仍然被可变借用。哎呀！

由于不变性带来的灵活性降低，你需要确保你的类型在尽可能多的泛型参数上保持协变（或在适当的地方保持逆变）。如果这要求引入额外的生命周期参数，你需要仔细权衡增加另一个参数的认知成本与不变性带来的人体工学成本。

## 总结

本章的目的是建立一个坚实的、共同的基础，以便在接下来的章节中继续构建。到现在为止，我希望你已经牢牢掌握了 Rust 的内存和所有权模型，并且那些你可能从借用检查器那里收到的错误看起来不再那么神秘了。你可能已经了解了我们在这里讲解的一些知识点，但希望本章能给你提供一个更加全面的视角，帮助你理解它们是如何相互联系的。在下一章，我们将做类似的内容，探讨类型。我们将介绍类型如何在内存中表示，看看泛型和特性如何生成可运行的代码，并了解 Rust 提供的一些特殊类型和特性构造，用于更高级的用例。
