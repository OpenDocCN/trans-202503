# 第四章：为什么这么难？

从表面上看，每个遗留系统现代化项目开始时都感觉很容易。毕竟，曾经有一个可用的系统存在。组织不知怎么地设法弄清楚足够的事情，把某个东西投入生产并让它运行了多年。现代化团队所需要做的只是利用更好的技术、后见之明和改进的工具重复这一过程。应该是很容易的。

但是，因为人们看不到他们即将揭示的隐藏技术挑战，他们也假设这项工作会很无聊。重新实现一个已解决的问题几乎没有什么荣耀可言。一个准备开始这样任务的组织渴望新的特性、新的功能和新的好处。现代化项目通常是组织希望尽快完成的任务，因此他们通常在没有做好时间和资源承诺的准备下就匆忙启动这些项目。

我告诉我的工程师，我们必须解决的最大问题不是技术问题，而是人际问题。现代化项目通常需要几个月，甚至几年的时间。让一个工程师团队从头到尾保持专注、激励和动力十足是困难的。让他们的高级领导层准备好一次次投资于本质上已经拥有的东西也是一项巨大的挑战。创造动力并保持动力是大多数现代化项目失败的地方。

到目前为止，最大的动力杀手是那些告诉我们项目一开始应该是容易的假设。它们，按顺序排列如下：

+   我们可以在旧系统的经验教训上建立。

+   我们了解旧系统的边界。

+   我们可以使用工具来加速进程。

让我们花点时间讨论一下，为什么这些显而易见的真理可能并不像看起来那么有用。

## 后见之明的诅咒

在扑克中，人们称之为*结果主义*。这是一种将结果的质量与决策的质量混淆的习惯。在心理学中，人们称之为*自利偏见*。当事情顺利时，我们高估了技能和能力的作用，低估了运气的作用。相反，当事情进展不顺时，一切都是坏运气或外部因素。

遗留系统现代化项目之所以困难的一个主要原因是，人们过高估计了现有系统所提供的后见之明。他们认为现有系统的成功是技术能力的问题，而且他们在最初构建过程中发现了所有潜在的问题并以最佳方式解决了这些问题。他们看到了结果，却没有注意到决策的质量或那些促成这些结果的运气因素。

当然，往往关于原始决策的文档几乎没有，根本没有资料让他们进行研究。尽管如此，忽视运气在任何项目成功中的作用意味着团队认为自己有空间在原始挑战上进行额外的创新。

软件可能存在严重的 bug，但仍然能取得巨大的成功。Lotus 1-2-3 就以把 1900 年误认为是闰年而闻名，但它的受欢迎程度如此之高，以至于至今 Excel 的版本仍然需要编程以保持对这一错误的兼容性。而且由于 Excel 的受欢迎程度最终远远超过了 Lotus 1-2-3，这个 bug 现在成为了 ECMA Office Open XML 规范的一部分。

成功与质量不一定是相关的。遗留系统是成功的系统，但这并不意味着在设计和实施这些系统时所做的每一个决策都是正确的。大多数人认为他们知道这一点，但他们却走入了错误的方向。他们对系统持悲观看法，但尽管如此，他们还是会在路线图上增加新的功能和特性。无论他们看起来多么批评这个系统，他们依然假设基础问题已经得到解决。

我们在现代化遗留系统时遇到困难，是因为我们未能给予遗留系统真正的挑战应有的关注和尊重：背景已经丧失。我们已经忘记了创造最终设计时所做的妥协的复杂网络，也对多年修改带来的复杂性视而不见。我们没有意识到至少有一些设计选择是错误的，系统之所以能够长期良好运作，完全是凭借好运。我们把问题简化了，最终在发现错误之前就承诺了新的挑战。

对遗留系统的轻视并不能保证我们不会陷入依赖已经失去的背景的陷阱。还记得我在第三章中描述的游戏吗？当我们审视系统中哪些部分不应该使用 COBOL 时，这是一个有用的技巧，即使 COBOL 不是因素。通过挑战我的团队，在我们遗留系统的要求下，使用当时遗留系统构建时可用的技术来设计一个系统，我们被迫恢复一些背景。遗留系统中许多“愚蠢”的技术选择看起来非常不同。一旦我们被迫直接审视背景，我们就会意识到这些系统中的一些其实是非常创新的。这让我们稍微有些洞察，哪些决策是技能和远见，哪些是运气。

一个成功的系统可能有一个设计模式，虽然无法在达到某种使用规模后继续生存，但它能够在未越过那个门槛之前就实现其运营目标。这是技能还是运气？如果设计者知道系统无法扩展，但同时也知道系统永远不会达到需要那样扩展的地步，那么我们可以假设这个设计是一个有意识的决定。例如，也许这个系统仅对某些人开放，仅供内部使用。扩展到数百万次请求是没有必要的，因为它最多也只会收到每秒几百个请求。

另一方面，如果系统的设计初衷是其使用会持续增长，并且设计者选择了一个只会在某个临界点之前有效的模式，那么他们的成功就是运气问题。他们只是没有到达那个临界点。Twitter 曾是一个设计良好的系统，直到它变得如此受欢迎，以至于开始崩溃，向用户展示了著名的“故障鲸鱼”卡通而不是他们的内容。一夜之间，构建这个社交媒体平台及其所使用技术的工程师，从被认为是熟练操作员和优越代码的创造者，变成了一群使用过度炒作、简化编程语言的普通业余者。他们既不是天才，也不是傻瓜。

扩展始终涉及一些运气。你可以为一定数量的交易或用户做规划，但你无法真正控制这些因素，尤其是当你构建的是涉及公共互联网的任何内容时。软件系统通常会集成多种技术协同工作来完成某个任务。我不知道有人能预测在每一种可能的规模条件下多种技术的表现，尤其是在它们被结合在一起时。工程团队会尽最大努力减轻潜在问题，但他们永远无法预见所有可能的事件组合。因此，服务在其初始规模上是否能正常运行，并随着其增长持续正常运行，始终是技能与运气的结合。

## 容易也不可能

1988 年，计算机科学家汉斯·莫拉维克观察到，教计算机做一些非常基础的事情非常困难，但编程计算机去做看似复杂的事情却容易得多。那些已经发展了数千年，用来解决像走路、回答问题和识别物体等问题的技能是直觉性的、潜意识的，且极其难以教会计算机。而与此同时，那些数千年来并未成为人类经验的一部分的技能——比如下棋或地理定位——相对来说要简单得多。他将这个悖论与进化联系起来的理论，得到了其他同时期 AI 研究人员的关注，以至于这个悖论最终以他的名字命名。

用莫拉维克自己的话来说，“让计算机在智力测试或玩跳棋时表现出成人水平的能力是比较容易的，而在感知和运动方面，让它们具备一岁婴儿的技能却是困难甚至不可能的。”^(1)

那些希望升级大型复杂系统的人，最好牢记莫拉维克悖论。系统的进化速度远远超过自然，但就像自然界一样，随着系统的进化，它的基础逻辑变得越来越难以理解。当我们习惯于某个东西总是以某种方式运作时，我们往往会忘记它。一旦我们不再思考它，就会忽视它在现代化计划中的重要性。

我们假设成功的系统解决了其核心问题，但我们也假设那些不需要任何思考或努力就能正常工作的东西其实是简单的，而实际上，它们可能承载了多年迭代的复杂性，而这些我们早已忘记。

当系统有多层抽象时，这一点尤其成立，尤其是当这些抽象超出了应用程序的边界时——当它们利用操作系统 API 甚至硬件接口时。你上一次考虑过你的常用软件是否与电脑上的芯片架构兼容是什么时候？你上一次为了让一个新配件与操作系统兼容而需要寻找特定驱动程序是什么时候？如果你是在 1990 年代之后出生的，或许你从未想过这些问题。硬件和软件接口在过去二十年中并没有变得更简单，我们只是抽象掉了许多让 x86 与 x64 的问题，或者下载驱动程序成了与计算机交互时正常部分的那些令人烦恼的差异。

对于非常古老的遗留系统，可能没有抽象层，或者更糟的是，这些抽象层本身可能已经过时。我喜欢称这个问题为*过度生长*，值得详细描述。

## 过度生长：应用程序及其依赖项

*过度生长*是软件与构成其运行平台的抽象层之间的一种特定类型的耦合。依赖管理的危险众所周知，但对于遗留系统，依赖管理不仅仅是包管理器可能安装的内容。系统越老，它运行的平台就越可能本身就是一个依赖项。大多数现代化项目并没有以这种方式思考平台，因此会把这个问题作为一个令人不快的惊喜，等待后续发现。

我们在跨平台兼容性方面取得了巨大的进步，但我们尚未达到应用程序 100% 平台无关的状态，也不太可能完全实现这一目标。

因此，我们在现代化一个系统时，不能忽视底层平台。这个平台有哪些特性是独特的，哪些是其他选项也可以找到的？这个平台有多老，是否已经被一种完全不同的方式所取代？

使得重大迁移如此棘手的是，随着软件的老化，其所定义运行的平台的元素逐渐过时，且在其他平台上对这些元素的支持越来越少。这意味着在我们最老的系统中，通常存在需要从系统中剔除或必须在现代平台上重新构建的逻辑。现有平台变成了围绕被迁移内容的辅助软件。例如，如果你在更换数据库，你不仅仅是在迁移数据。你可能需要用不同的语言或 SQL 的不同实现来重写查询。你可能需要重新思考钩子或存储过程。一个软件语言往往有许多次要语言，专门执行特定功能。有像 bash 或 JCL 这样的命令处理器来触发作业，还有模板语言来构建界面，查询语言来访问数据，等等。商业逻辑在这些层次之间是如何分离的？逻辑是否停留在合理的位置，还是被注入到方便的位置？

大多数 web 开发项目，例如，运行在 Linux 机器上。因此，web 应用程序通常会包含 shell 脚本作为其代码库的一部分——特别是在设置/安装过程中。想象一下，如果 Linux 被其他操作系统取代，迁移这些应用程序在 20 年后的未来会是什么样子。我们可能需要重写所有的 shell 脚本，还需要迁移实际的应用程序。

聪明的工程师会指出，使用容器化和配置管理工具后，这些脚本应该已经是过去式了，但这正是过度增长成为遗留代码问题的原因。曾经，很多任务都是通过 shell 脚本来完成的；这一做法后来被另一种方法取代。如果我们想迁移一个旧应用程序，我们可能会发现这种旧的做法并不被我们想使用的技术所支持。我们必须先迁移辅助软件。

对于现代应用程序而言，过度增长通常不是一个重大障碍。来自同一计算机时代的编程语言通常共享生态系统，因此，替换一种语言为另一种语言时，只需要对周围的辅助软件进行最小的更改就更容易了。记住，过度增长只是另一种形式的耦合。如果这种耦合的价值是存在的，它不一定是坏事。

然而，在旧有的应用程序中，人们似乎很难看到这种类型的耦合。我们往往会忽略辅助软件，就像我们忘记了莫拉维克（Moravec）曾为编程计算机完成简单任务所付出的复杂努力一样。一段程序未升级的时间越长，现代平台和工具支持它的可能性就越小。当辅助软件逐渐失去支持时，现代化实际代码的挑战就变得更加复杂。

在集成点处查找过度生长，即通信层发生变化的地方。有几种不同的过渡点，你可能会在这些地方发现过度生长。

### 垂直迁移：从一个抽象层移动到另一个抽象层

现代软件与机器中电路中流动的物理电压之间存在许多层次。在最基础的层次上，我们可以定义三个层次：软件、硬件和它们之间的操作系统。当在这些层次之间上下迁移时，过度生长通常表现为专有标准，特别是在旧技术中，其中硬件制造商通常也会提供软件。要注意你的应用程序代码是否依赖于特定操作系统的 API，或者更糟的是，是否依赖于运行该应用程序的物理机器的芯片架构。这是旧大型机中常见的问题。软件是用一种特定于构建大型机的公司以及通常是机器型号的汇编语言变体编写的。

### 水平迁移：从一个应用程序移动到另一个应用程序

就像有遗留代码一样，也有遗留协议。当两个应用程序在彼此之间传递数据时，如果它们运行在由公司开发的机器上，或者在使用专有协议的网络设备上进行通信，你可能会在连接周围看到一些过度生长。这在 web 开发中不太成问题，因为互联网的去中心化特性推动了标准协议的普及，如 TCP/IP、FTP 和 SMTP——这些协议都有强大的工具生态系统，并在多个平台上得到了广泛支持。在软件开发的其他领域，专有协议的影响范围更大。这些协议的难易程度取决于相关技术的普及程度。来自大型供应商的专有协议可能会被其他选项支持。例如，Microsoft Exchange Server 协议是专有的，但得到了很好的支持，而依赖于 AppleTalk 的应用程序可能会发现迁移困难。

### 从客户端到服务器的迁移

这种变化可以表现为针对特定工具和集成的特定软件开发工具包（SDK），针对特定数据库连接的驱动程序，或者前端到后端的迁移。虽然这一点可能让一些工程师感到震惊，但有些内部 Web 应用仍然是为在特定的 Web 浏览器上运行而构建的，并且依赖于其他浏览器中不可用的功能或特性。Internet Explorer（IE）是最常见的罪魁祸首。每当你看到 IE 被作为内部应用的首选默认浏览器时，务必再次确认这些应用的前端没有使用 IE 特有的 JavaScript 功能。我们也常常在 Adobe Acrobat 中看到这种情况。早期的数字表单通常是为了利用 Acrobat 特定的 PDF 功能而构建的，可能在不同版本的 Acrobat 之间转换时会遇到困难。一个著名的故事来自我在美国数字服务局的工作经历，当时退伍军人事务部的一个网站只有在你*降级* Acrobat 版本后才能正常工作。^(2)

### 向下转移依赖树

随着编程语言的成熟，它们偶尔会对语法或内部逻辑进行破坏性更改。并非所有依赖都会以相同的速度升级以处理这些变化，这就导致了应用无法升级，直到相关依赖被升级为止。在非常古老的应用中，这些依赖可能已经不再处于积极开发状态。例如，可能维护者从未推出过与最新版本的 Java 或 Node.js 兼容的版本，而要获得该支持，应用必须切换到完全不同的选项。

## 削减过度生长

削减过度生长从技术上来说并不难；它只是令人沮丧和士气低落。过度生长会减缓进度，如果没有准确评估，就会产生意外的惊喜，影响团队的信心。为了最小化其影响，首先需要绘制应用的上下文图。它运行在什么环境中？创建新实例的过程是什么？将其依赖关系映射到两级深度。^(3) 尝试追踪应用中数据的流动过程，直到完成一个请求。这应该能让你更清楚地看到可能存在问题的地方。如果你能把这些问题列入路线图，它们对士气的影响就会小得多。

你可能会觉得现代软件开发正在改善这一情况。跨平台兼容性比以前好多了，这是事实，但商业云的 PaaS（平台即服务）市场的增长也在增加为特定平台功能编程的选项。例如，越多地使用亚马逊的托管服务来构建应用，应用就越会符合亚马逊特有的特征，若该组织后来想要迁移，这种“过度生长”就会带来更多的麻烦。

## 自动化与转换

人们对遗留系统的最后一个假设是，既然计算机能够读取他们试图现代化的代码，那么一定有某种方式来自动化这个过程。他们引入像转译器和静态分析这样的工具，目的是让现代化过程变得更快、更高效。

这些工具很有用，但前提是对它们的预期是现实的。如果你把它们当作指导工具来帮助完善过程，你的现代化团队可以采取战略性方法，避免关键错误，并可能减少一些成本。然而，如果你把它们当作捷径，省略了真正对现代化的投资，它们很可能会让你失望。那些认为工具是解决方案的组织，通常会经历更长、更痛苦和更昂贵的现代化过程。

那么，这些工具究竟做了什么，如何正确使用它们呢？

### 转译代码

*转译*是将用一种编程语言编写的代码自动翻译成另一种编程语言的过程。当被读取的语言与输出将写入的语言之间的差异不大时，使用转译器是有意义的。例如，Python 3 有足够多的破坏性更改，实际上需要工程师迁移他们的代码库，而不仅仅是进行升级。与此同时，Python 3 并没有改变 Python 本身的任何基本哲学，只是一些实现细节。转译工作得如此出色，以至于 Python 3 内置了 Python 2 到 Python 3 和 Python 3 到 Python 2 的转换工具。

转译器的另一个典型用例是，当转译器读取的语言专门设计用于强制执行转译器所编写语言的良好实践时。JavaScript 有许多不同的变种，例如 CoffeeScript 和 TypeScript。

当输入和输出语言之间的差异较大时，转译变得更加复杂，节省时间的预期需要得到适当的管理，以确保成功的结果。这种用例的经典例子是从 COBOL 到 Java 的转译。COBOL 是默认的过程式、命令式和定点数语言，而 Java 则是面向对象的，且默认使用浮点数。将 COBOL 转译为 Java 可能会生成可用的代码，但除非工程师对代码进行检查和微调，否则代码将无法维护。通常这意味着需要重写部分代码。

如果你打算使用转译器进行这种升级，那么至关重要的一点是应用程序必须拥有设计良好且全面的测试套件，最好是自动化测试套件。通过将一种语言自动转换为另一种完全不同的语言所产生的错误可能是微妙的，且难以追踪。例如，当你尝试将一个八位数的数字放入一个定义为七位数的变量时，COBOL 会截断最后一位并继续执行。另一方面，Java 会抛出异常。转译器不会添加代码来处理这些异常。

人们通常投资转译器来帮助升级遗留代码，因为他们认为让计算机程序做第一次转换会节省工程时间，或者他们认为转译器会完全替代原语言专家的帮助。但当两种语言有显著差异时，这种转译器的输出通常不会遵循它所写语言的结构和约定。转译器无法重新思考你如何组织代码。转译后的 COBOL 就是将其当作 COBOL 编写的 Java，因此大多数 Java 程序员无法理解。

这种转译技术的成功案例通常来自那些将转译解决方案作为咨询服务入口的公司。也就是说，首先你购买转译器的许可证，然后你再雇佣人才将转译器的输出重写成可工作的内容。这是一种不错的策略，只要你知道你正在做什么。

### 静态分析

尽管在理论领域之外尚未得到广泛应用，但学术界在利用各种静态分析方法探索并最终改进遗留系统方面做了一些有趣的工作。所谓的软件翻新结合了编译器设计和逆向工程的技术，旨在引导重构过程。软件翻新是半自动的：分析是自动化的，但软件工程师需要实际进行代码重构工作。

一些常见的静态分析类型用于软件翻新，包括以下几种：

1.  依赖图 在这种软件翻新方式中，依赖图会被映射，并使用聚类算法来确定是否存在重叠、冗余、未使用的库或循环依赖^(4)。

1.  语法 这些是特定语言的工具，通过解析抽象语法树进行分析。通常它们会查找重复的代码或被认为是反模式的特定做法（如 goto 语句）。

1.  控制流/数据流图 这些图表是追踪软件执行方式的工具。控制流图映射了代码执行的顺序，而数据流图则映射了变量的赋值和引用。你可以使用这样的分析来发现丢失的业务需求或追踪死代码。

软件翻新方法学尚未完全脱离理论研究，但静态分析工具无论是作为独立产品，还是作为大型集成开发环境或持续集成与部署解决方案的功能，都已可用。这是令人遗憾的，因为方法学是驱动大部分影响的关键。工具本身没有方法学重要，挖掘、理解、记录，最终重写和替换遗留系统的阶段才是关键。工具会来来去去。

## 不让事情变得更难的指南

期望管理非常重要。通常，组织会犯本章所描述的错误，因为他们认为自己正在提高流程效率。他们错误估计了现代化项目所需的时间，错误判断了可以节省多少时间以及如何节省。

当我们用以下准则替代本章开头描述的错误假设时，现代化项目会有更好的成果：

+   保持简单。不要因为旧系统成功就添加新的问题来解决。成功并不意味着旧系统完全解决了它的问题。一些技术决策是错误的，但从未引发任何问题。

+   花些时间尝试恢复上下文。将平台视为一个依赖项，并寻找那些不容易迁移到现代平台的耦合。

+   工具和自动化应该是对人类努力的补充，而不是替代。

个人贡献者通常发现，遵循这一建议的障碍不在于说服自己，而在于说服他人。尤其是当组织庞大时，压力很大，要按照大家都在做的方式来推进项目，即使这样做会牺牲成功，只为了看起来是正确的。在后面的章节中，我们将探讨如何在组织中导航以及推进目标的策略。
