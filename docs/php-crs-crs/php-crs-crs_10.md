

## 第八章：8 高级数组



![](img/opener.jpg)

在本章中，我们将采用更复杂的方法来处理 PHP 数组，并探讨如何手动分配数组的键。这为使用有意义的字符串作为键提供了可能，而不是 PHP 默认的使用顺序整数的行为。我们还将讨论多维数组，其中数组元素的值本身就是另一个数组，并且我们将了解更多用于操作数组的函数和操作符。通过对 PHP 数组的更深入了解，您将开始看到它们如何存储和处理更复杂的数据结构。

### 显式声明数组键

我们已经讨论过 PHP 如何自动为数组元素分配顺序整数键，从 0 开始，在这种情况下，生成的数组将符合*列表*的定义。然而，您也可以在声明数组时使用双箭头操作符（=>）显式地将键映射到每个值，而不是依赖于这种默认行为。这样，您就不必遵循默认的键模式。例如，您可以使用非顺序的整数作为键，或从 0 以外的数字开始计数。无论哪种方式，生成的数组将不再被视为列表，但它仍然是一个有效的数组。为了说明，清单 8-1 显示了一个显式使用非顺序整数键的数组脚本。

```
<?php
$rainfallValues = [
    0 => 10,
    4 => 8,
    3 => 12
];

print "-- Monthly rainfall --\n";
foreach ($rainfallValues as $key => $rainfallValue) {
    print "$key: $rainfallValue\n";
}

var_dump(array_is_list($rainfallValues));
```

清单 8-1：显式声明不按顺序排列的整数数组键

在这里，我们声明了一个 $rainfallValues 数组。在数组的方括号内，我们使用 => 操作符显式地为每个数组元素分配键。例如，0 => 10 会向数组中添加一个值为 10、键为 0 的元素。键/值对通过逗号分隔，就像我们在第七章中没有显式声明键时用逗号分隔数组值一样。在这种情况下，我们还将每个键/值对放在了单独的缩进行中，以提高清晰度。声明数组后，脚本继续通过循环遍历它并打印出键/值对。

请注意，我们声明的数组键不是顺序的。第二个数组元素的键是 4，第三个元素的键是 3。这可能不是分配键的最直观方式，但如果这是我们想要的，PHP 完全可以接受。数组将不再符合列表的定义（因此脚本末尾的 array_is_list() 调用应该返回 false），但数组仍然有效。以下是运行脚本的输出：

```
-- Monthly rainfall --
0: 10
4: 8
3: 12
bool(false)
```

即使数组不是一个完整的列表，foreach 循环仍然有效，它会遍历数组的键/值对并将其打印出来。请注意，键为 4 的元素在键为 3 的元素之前打印出来。关键在于元素是如何*声明*的，而不是键本身的数字顺序。输出末尾的 false 确认了该数组不再符合列表的要求。

一旦你开始显式声明键，就不一定需要为*每一个*数组元素都声明一个键。如果一个元素没有声明键，PHP 将自动查找最近的整数键，递增它，并使用该键作为新的键。如果你希望数组的键按顺序排列，但不从 0 开始，这种方式会非常有用。

例如，假设你有一个学生班级，并希望创建一个数组，将学生的 ID 映射到他们的成绩。每个 ID 是一个七位数的数字，开头是年份，后面跟着三个数字，按顺序递增。例如，在 2025 年，第一位学生的 ID 为 2025001，下一位为 2025002，依此类推。在这种情况下，你可以显式声明第一个数组键，并让 PHP 自动分配其余的键。清单 8-2 展示了具体做法。

```
<?php
$studentGrades = [
    2025001 => 'A',
  ❶ 'B',
    'A',
    'D',
    'F'
];

print "-- Student grades--\n";
foreach ($studentGrades as $studentId => $grade) {
    print "$studentId => $grade\n";
}

var_dump(array_is_list($studentGrades));
```

清单 8-2：显式声明第一个数组键，其余自动分配

在$studentGrades 数组中，我们显式地为第一个元素指定了键 2025001。然后，从第二个元素❶开始，我们只提供值。默认情况下，PHP 会将这些值映射到整数键 2025002、2025003 等。和之前一样，我们通过循环并打印键/值对来完成脚本，并测试该数组是否算作列表。输出如下所示：

```
-- Student grades--
2025001 => A
2025002 => B
2025003 => A
2025004 => D
2025005 => F
bool(false)
```

请注意，PHP 已按顺序分配了其余的键，从显式声明的键 2025001 开始递增。然而，尽管这些键是按顺序排列的，它们并不是从 0 开始的。因此，该数组并不是一个列表，输出末尾的 false 证明了这一点。

### 使用字符串作为键的数组

让我们进一步扩展我们的代码：既然我们已经显式分配了数组键，谁说它们一定得是整数呢？它们同样可以是字符串，在这种情况下，数组中的每个值都可以有一个有意义的名字作为键。例如，回到清单 8-1 中的$rainfallValues 数组，我们可以使用月份名称作为键，而不是使用整数。这种修改将更好地表明数组中的每个值代表一个月的降水总量。清单 8-3 已经相应地修正了脚本。

```
<?php
$rainfallValues = [
    'jan' => 10,
    'feb' => 8,
    'march' => 12
];

print "-- Monthly rainfall --\n";
foreach ($rainfallValues as $key => $rainfallValue) {
 print "$key: $rainfallValue\n";
}

var_dump(array_is_list($rainfallValues));
```

清单 8-3：将字符串用作数组键

这次我们将键'jan'分配给值 10，将键'feb'分配给值 8，将键'march'分配给值 12。我们使用和之前相同的=>运算符来将键与值配对。唯一的不同是，现在键是字符串。以下是脚本的输出：

```
-- Monthly rainfall --
jan: 10
feb: 8
march: 12
bool(false)
```

字符串键清晰地说明了值的实际含义。输出末尾的 false 显示该数组不是一个列表。这并不奇怪，因为这些键甚至不是整数。

使用字符串键从数组中访问单个值的方式和使用整数键访问数组值一样：在数组名后面提供键，并用方括号括起来。例如，以下是如何打印三月降水量的值：

```
print $rainfallValues['march'];
```

同样，你也可以使用方括号表示法，通过字符串键来添加或更新数组元素。在这里，我们为四月添加了新的降水总量：

```
$rainfallValues['april'] = 14;
```

这是一个简单的例子，但希望你可以开始看到 PHP 数组在构建有意义的数据集合方面的潜力。当你不需要面向对象编程（在第五部分中讨论）所提供的全部功能时，使用带有字符串键的数组可以帮助你处理那些值与任务相关联的键（如日期或月份、人名或 ID、或产品名称或代码）数据。

### 多维数组

到目前为止，我们所探索的数组都是*一维的*：它们包含一个元素序列，每个元素都是一个标量（单一）值，映射到一个键。然而，你也可以声明包含数组元素的数组，从而得到一个*多维数组*。例如，假设你想创建一个任务数组，每个任务需要的时间（以分钟为单位）。数组中的每个元素本身可以是一个数组，包含任务名称和其相关的持续时间，如下所示：

```
$tasksAndMinutes = [
    ['shopping', 30],
    ['gym', 60],
    ['nap', 15]
];
```

这里的$tasksAndMinutes 是一个多维数组。它的第一个元素，['shopping', 30]，是一个包含字符串任务名称和整数分钟数的两元素数组。其他数组元素遵循相同的格式。对于这样一个多维数组，我们把整个$tasksAndMinutes 称为*外部*数组，它的元素称为*内部*数组。

处理多维数组的一种方式是使用一组嵌套的 foreach 循环，一个循环遍历外部数组的元素，另一个循环遍历每个内部数组的元素。然而，在$tasksAndMinutes 数组中，所有的内部数组具有相同的结构（这并不总是如此）。因此，在这种情况下，你可以利用对该结构的了解，通过使用单一的 foreach 循环来遍历外部数组，从每个内部数组中提取值。清单 8-4 展示了这一方法。

```
<?php
$tasksAndMinutes = [
    ['shopping', 30],
    ['gym', 60],
    ['nap', 15]
];

foreach ($tasksAndMinutes as $item) {
    $task = $item[0];
    $minutes = $item[1];
    print "allow $minutes minutes today for task: $task\n";
}
```

清单 8-4：处理多维数组

我们像之前一样声明$tasksAndMinutes 数组。接下来，我们声明一个 foreach 循环，遍历$tasksAndMinutes 的元素，使用$item 变量来表示当前元素。如我们所见，每个元素本身是一个包含任务名称和时间（分钟）的数组。因此，我们可以提取$item 的第一个元素（使用整数索引 0）到$task 变量，第二个元素（索引 1）到$minutes 变量。然后，我们使用这两个变量打印关于当前任务的信息，输出如下：

```
allow 30 minutes today for task: shopping
allow 60 minutes today for task: gym
allow 15 minutes today for task: nap
```

在 foreach 循环中，时间和任务名称已经成功地从每个内层数组中提取出来。

在这个例子中，内部数组默认使用整数键，但如你所知，数组也可以使用非数字键。将每个内部数组中的值与有意义的字符串键（如 'task' 和 'minutes'）配对，会让代码更加易读。例如，我们可以通过 $task = $item['task'] 来访问当前元素的任务，而不是 $task = $item[0]。列表 8-5 展示了这一改进。

```
<?php
$tasksAndMinutes = [
    ['task' => 'shopping', 'minutes' => 30],
    ['task' => 'gym', 'minutes' => 60],
    ['task' => 'nap', 'minutes' => 15],
];

foreach ($tasksAndMinutes as $item) {
    $task = $item['task'];
    $minutes = $item['minutes'];
 print "allow $minutes minutes today for task: $task\n";
}
```

列表 8-5：重构列表 8-4，在内部数组中使用字符串键

这次我们显式地将字符串键 'task' 和 'minutes' 分配给 $tasksAndMinutes 中每个数组的值。然后，我们在 foreach 循环中使用这些有意义的键来提取当前正在处理的内部数组中的值。结果和之前完全一样，但代码更容易阅读。在 PHP 支持面向对象编程之前，像这样的具有良好标签的多维数组是许多程序数据相关功能代码的核心部分。 ### 更多数组操作

在第七章中，我们讨论了数组操作，如向简单数组的末尾添加元素和从末尾删除元素。现在我们已经探讨了复杂数组，让我们考虑更多的数组操作。我们将学习如何从数组的任意位置删除元素，如何使用数组运算符如并集（+）和展开（...），以及如何将数组元素提取到单独的变量中。

#### 从数组中删除任何元素

你可以通过将元素的键传递给 unset() 函数来从数组中删除元素。与上一章中介绍的 array_pop() 函数不同，array_pop() 函数专门删除数组中的*最后*一个元素，而 unset() 可以从*任何*位置删除元素。与 array_pop() 不同，unset() 函数不会返回被删除的元素，它只是消失了。

当你开始使用字符串而非整数作为数组键时，使用 unset() 变得更加合适。对于字符串键，数组元素的顺序往往不再重要，因此基于键而非数组中的位置删除元素更有意义。列表 8-6 重新访问了 $rainfallValues 数组作为例子。

```
<?php
$rainfallValues = [
 'jan' => 10,
 'feb' => 8,
 'march' => 12
];

unset($rainfallValues['feb']);

print "-- Monthly rainfall --\n";
foreach ($rainfallValues as $key => $rainfallValue) {
 print "$key: $rainfallValue\n";
}
```

列表 8-6：使用 unset() 从数组中删除元素

我们使用 unset() 从 $rainfallValues 数组中删除键为 'feb' 的元素。然后，我们像之前一样遍历数组，打印剩余元素的详细信息。结果如下：

```
-- Monthly rainfall --
jan: 10
march: 12
```

注意，对于键为 'feb' 的元素没有打印任何数据，因为该元素不再存在于数组中。

> 注意

*调用* unset() *在整个数组上，例如* unset($rainfallValues)*，将删除整个数组，就像在任何其他变量上调用* unset() *将清空该变量一样。*  #### 合并和比较数组

你可以使用一些相同的加法、相等性和身份操作符来组合或比较数组，这些操作符适用于标量（单值）变量。表 8-1 总结了六个可用的数组操作符。

表 8-1：数组操作符

| 名称 | 符号 | 示例 | 描述 |
| --- | --- | --- | --- |
| 联合 | + | $a + $b | 返回一个包含数组 $a 和 $b 元素的数组。 |
| 展开 | ... | [1, ...$a] | 返回一个数组，数组的第一个元素是 1，接着是数组 $a 的元素。 |
| 相等 | == | $a == $b | 如果数组 $a 和 $b 拥有相同的键/值对，则返回 true。 |
| 相同 | === | $a === $b | 如果数组 $a 和 $b 完全相同：它们具有相同的键/值对，元素的顺序和类型也相同，则返回 true。 |
| 不相等 | != 或 <> | $a != $b $a <> $b | 如果数组 $a 和 $b 没有相同的键/值对，则返回 true。 |
| 不相同 | !== | $a !== $b | 如果数组 $a 和数组 $b 不相同，则返回 true。 |

列表 8-7 展示了这些操作符的实际应用。

```
<?php
$cars1 = ['audi' => 'silver', 'bmw' => 'black'];
$cars2 = ['audi' => 'white', 'ferrari' => 'red'];
$names1 = ['matt' => 'smith', 'joelle' => 'murphy'];
$names2 = ['joelle' => 'murphy', 'matt' => 'smith',];

print_r($cars1 + $cars2);
var_dump($names1 == $names2);
var_dump($names1 === $names2);
❶ print_r(['rolls royce' => 'yellow', ...$cars1, ...$names1]);
```

列表 8-7：使用数组操作符

首先，我们声明一些示例数组来进行操作：$cars1 和 $cars2 以汽车品牌为键，汽车颜色为值，而 $names1 和 $names2 以名字为键，姓氏为值。（注意，$names1 和 $names2 拥有相同的元素，但顺序相反。）

然后我们将操作符应用到这些数组，并打印结果。我们使用联合 (+) 操作符来合并 $cars1 和 $cars2，使用相等 (==) 和相同 (===) 操作符来测试 $names1 和 $names2。我们还使用数组展开操作符 (...) 来创建一个新数组，其键为 'rolls royce'，值为 'yellow'，并包含 $cars1 和 $names1 数组的所有元素 ❶。注意，我们使用 print_r() 来显示返回数组的操作结果；该函数比 var_dump() 更简洁地展示数组。运行脚本后，得到如下输出：

```
❶ Array
(
    [audi] => silver
    [bmw] => black
    [ferrari] => red
)
❷ bool(true)
bool(false)
❸ Array
(
    [rolls royce] => yellow
    [audi] => silver
    [bmw] => black
    [matt] => smith
    [joelle] => murphy
)
```

输出的第一部分展示了 $cars1 + $cars2 ❶ 的结果。两个汽车数组都包含一个键为 'audi' 的元素，但数组不能有两个相同的键。因此，联合操作符从 $cars1 中取出 'audi' => 'silver' 元素，但忽略了 $cars2 中的 'audi' => 'white' 元素，结果是一个包含三个元素的数组。接下来，输出中的 true 和 false 结果 ❷ 表明 $names1 和 $names2 数组是 *相等* 的，因为它们有相同的键和值，但不是 *完全相同* 的，因为元素的顺序不同。最后的数组显示了使用展开操作符 (...) ❸ 的结果。新数组包含一个 'rolls royce' 元素，接着是 $cars1 和 $names1 中的元素。

值得强调的是，展开运算符 (...) 在这里的作用：它从一个数组中提取元素，并将它们一个一个地插入到另一个数组中。如果没有展开运算符，整个数组会作为单个元素插入到新数组中，从而创建一个多维数组，而不是将它的各个元素展开到新数组中。举个例子，假设我们在 示例 8-7 中，省略了 $cars1 前面的展开运算符 ❶，如下所示：

```
print_r(['rolls royce' => 'yellow', $cars1, ...$names1]);
```

结果数组将包含一个元素，该元素包含整个 $cars1 数组，如下所示：

```
Array
(
    [rolls royce] => yellow
    [0] => Array
        (
            [audi] => silver
            [bmw] => black
        )

 [matt] => smith
    [joelle] => murphy
)
```

现在数组中的第二个元素，键值为 0，本身是一个数组，包含了完整的 $cars1 内容。这个例子也展示了数组如何将整数键与非整数键混合使用。当整个 $cars1 数组作为元素添加到新数组时，由于没有手动指定键值，它会自动分配第一个可用的整数键 0。同时，新数组中的其他元素都显式地分配了字符串键。像这样混合键的数组是比较少见的；通常这样的数组表示某些东西出了问题，例如这里缺少了展开运算符。

#### 将数组解构为多个变量

有时提取数组中的值并将它们赋值给单独的变量会很有用，这个过程叫做 *解构*。如果你知道数组中的元素数量，你可以通过一条语句解构它，如 示例 8-8 所示。

```
<?php
$rainfallValues = [10, 8, 12];

❶ [$jan, $feb, $march] = $rainfallValues;

print "-- Monthly rainfall --\n";
print "Jan: $jan \n";
print "Feb: $feb \n";
print "Mar: $march \n";
```

示例 8-8：将一个包含三个元素的数组解构为三个单独的变量

我们声明 $rainfallValues 数组包含三个元素。然后，我们将该数组解构到 $jan、$feb 和 $march 变量 ❶ 中。为此，我们在赋值运算符 (=) 的左边列出目标变量，并在右边提供包含整个数组的变量。最后，我们打印出这三个变量中的值，产生如下输出：

```
-- Monthly rainfall --
Jan: 10
Feb: 8
Mar: 12
```

注意，数组中的值已经成功地赋值到单独的 $jan、$feb 和 $march 变量中，并从这些变量中打印出来。 ### 回调函数与数组

*回调函数*，简称 *回调*，是一种不会直接调用的函数，而是作为参数传递给另一个函数。然后，另一个函数会为你调用回调函数。PHP 中有多个函数使用回调与数组结合。

例如，array_walk() 接收一个数组和一个回调函数作为参数，并对数组中的每个元素应用回调函数，从而在这个过程中改变原始数组。类似地，array_map() 接收一个数组和一个回调函数，应用回调函数到每个数组元素，并返回一个包含结果的新数组。array_walk() 和 array_map() 都被称为 *高阶函数*，因为它们将一个函数作为参数。

如果你在一个单独的文件中声明了一个函数（如第五章所讨论的），或者使用了 PHP 的内置函数，你可以通过将包含函数名的字符串传递给高阶函数来使用该函数作为回调。例如，假设我们声明了一个名为 my_function()的函数，并且想要通过使用 array_map()将它应用到$my_array 中的每个元素。下面是具体做法：

```
$my_new_array = array_map('my_function', $my_array);
```

我们将字符串'my_function'（所需回调的名称）和数组作为参数传递给 array_map()，它会对数组中的每个元素调用 my_function()。结果会以新数组的形式返回，我们将其存储在$my_new_array 变量中。

除了单独声明回调函数，另一种常见的做法是在高阶函数的参数列表中直接定义*匿名*（无名）回调函数。在我们在像 array_map()这样的高阶函数中使用匿名函数之前，先让我们单独考虑一下匿名函数，以便更好地理解语法。以下是一个简单的匿名函数，它接收一个数字并返回其值的两倍：

```
function (int $n): int {return $n * 2;}
```

该函数以 function 关键字开始，后面是函数的签名`(int $n): int`，表示该函数接收一个整数参数$n 并返回一个整数值。请注意，函数签名中没有包括名称，因为该函数是匿名的。签名后面是匿名函数的主体，主体被花括号包围。该主体返回提供的$n 参数的两倍值。

另一个选择是将匿名回调函数写成*箭头函数*，使用更简洁的语法，采用双箭头操作符（=>）来分隔函数的签名和主体。这种语法省去了`return`关键字、主体周围的花括号以及结束语句的分号。以下是我们倍增操作的箭头函数版本：

```
fn (int $n): int => $n * 2
```

现在，我们不再使用 function，而是以`fn`开始，这是声明箭头函数的保留关键字。接着是函数的签名，和之前一样。然后是双箭头操作符（=>），后面跟着一个定义函数返回值的表达式（在此例中为$n * 2）。没有了花括号、分号和 return 关键字，箭头函数变得非常简洁。

现在让我们尝试将这个箭头函数用作回调。列表 8-9 展示了如何将箭头函数传递给 array_map()，以便将数组中的每个值都加倍。

```
<?php
$numbers = [10, 20, 30];

$doubleNumbers = array_map(
  ❶ fn (int $n): int => $n * 2,
    $numbers
);

var_dump($doubleNumbers);
```

列表 8-9：将箭头回调函数传递给 array_map()

我们声明了一个包含 10、20 和 30 的$numbers 数组。然后，我们调用 array_map()函数。对于第一个参数，我们使用箭头函数语法声明了我们刚刚讨论过的双倍回调函数❶。注意，箭头函数以逗号结束，因为它是 array_map()函数参数列表的一部分。第二个参数是$numbers 数组。array_map()函数会自动对数组中的每个元素应用箭头函数，并返回一个包含结果的新数组。我们将这个新数组存储在$doubleNumbers 变量中。下面是运行此脚本并打印结果数组的输出：

```
array(3) {
    [0]=>
    int(20)
    [1]=>
    int(40)
    [2]=>
    int(60)
}
```

$doubleNumbers 数组包含值 20、40 和 60。这表示 array_map()函数成功访问了$numbers 数组中的每个值，并对其应用了双倍箭头函数。

### 总结

数组是灵活的数据结构，尤其当我们开始为元素的值分配有意义的字符串键，而不是使用默认的整数键时。在这一章中，你学习了如何使用字符串键的数组。你还看到如何将数组嵌套在其他数组中，创建多维数组，并且如何对数组的每个元素应用回调函数（使用箭头函数语法编写）。像这样的技巧使得数组成为一个复杂数据表示和操作的高级结构。

### 练习

1.   使用字符串键的数组来存储以下姓名和身高（单位：米）对：

```
Fred      1.82
Joelle    1.55
Robin     1.70
```

编写一个 foreach 循环来遍历数组元素并打印它们。

2.   创建一个多维数组来表示以下关于电影的数据：

```
Back to the Future
    duration        116
    leadingActor    Michael J. Fox
The Fifth Element
    duration        126
    leadingActor    Bruce Willis
Alien
    duration        117
    leadingActor    Sigourney Weaver
```

3.   声明一个包含从 1 到 9 的奇数（1、3、5、7、9）的数组，另一个包含偶数（2、4、6、8）的数组。使用数组扩展操作符(...)将两个数组合并，然后使用 PHP 的内置 sort()函数将它们按数字顺序排序。
