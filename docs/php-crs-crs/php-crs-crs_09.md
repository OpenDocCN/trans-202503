

## 第七章：7 简单数组



![](img/opener.jpg)

本章介绍了*数组*，这是一种复合数据类型，用于存储和操作多个数据项，在一个变量名称下。数组允许你将相关数据分组，并高效地对每个数据项应用相同的操作。

从本质上讲，数组是值与键的映射。每个*值*是你想要存储在数组中的数据，而它的*键*是与该值关联的唯一标识符，以便你可以从数组中访问它。在本章中，我们将重点讲解简单数组，它们使用整数作为键。你将学习如何创建和操作简单数组，并通过 foreach 循环遍历数组中的项目。在下一章中，我们将探讨如何通过使用字符串（以及其他数据类型）作为键来创建更复杂的数组，而不是使用整数。

### 创建数组并访问其值

让我们从创建一个简单数组开始，这个数组存储了某个地点的每月降水总量（列表 7-1）。

```
<?php
$rainfall = [10, 8, 12];
```

列表 7-1：声明一个简单数组

我们通过在方括号内使用逗号分隔的值序列来声明一个名为$rainfall 的数组：[10, 8, 12]。这是一个三元素数组，包含值 10、8 和 12。

默认情况下，PHP 会给每个数组值分配一个整数作为键。键是按顺序分配的，从零开始：第一个值（10）的键是 0，第二个值（8）的键是 1，第三个值（12）的键是 2。接受这个默认映射就是使$rainfall 成为一个*简单数组*（与我们将在第八章中探讨的具有自定义键值映射的*复杂数组*相对）。

现在我们有了一个数组，可以使用其键单独访问其值。在列表 7-2 中，我们将$rainfall 数组中的每个值连接成一个字符串消息并打印出来。

```
<?php
$rainfall = [10, 8, 12];

print "Monthly rainfall\n";
print "Jan: " . $rainfall[0] . "\n";
print "Feb: " . $rainfall[1] . "\n";
print "Mar: " . $rainfall[2] . "\n";
```

列表 7-2：通过整数键访问数组元素

我们通过在数组名称后面指定方括号中的键来访问数组中的项目。例如，$rainfall[0]给我们返回$rainfall 数组中的第一个值（10），然后我们将其与字符串"Jan: "连接。同样，我们可以通过$rainfall[1]访问数组中的第二个元素。由于整数键从零开始，具有*n*个元素的数组的最后一个元素的键是*n* - 1。在这个例子中，我们通过$rainfall[2]访问我们这个三元素数组的最后一个元素。以下是运行该脚本的输出：

```
Monthly rainfall
Jan: 10
Feb: 8
Mar: 12
```

值 10、8 和 12 已经成功地从数组中读取并使用它们的整数键 0、1 和 2 打印出来。

如果你尝试使用一个未分配的键访问数组元素，PHP 会给出警告。例如，假设我们在列表 7-2 的末尾添加以下打印语句：

```
print "Apr: " . $rainfall[3] . "\n";
```

这条语句将触发类似于以下的警告：

```
PHP Warning:  Undefined array key 3 in /Users/matt/main.php on line 8
```

我们的数组只有三个元素，键分别为 0、1 和 2，因此没有与$rainfall[3]对应的元素。稍后我们将在本章中讨论如何通过首先确保数组中具有特定键的元素存在来避免类似的警告，然后再尝试访问它。

### 更新数组

通常，在创建数组后，你需要通过添加或删除元素来更新数组。例如，通常会从一个空数组开始，通过将一个空的方括号([])赋值给一个变量来创建它，然后随着脚本的执行，逐渐向其中添加元素。在本节中，我们将讨论一些常见的技术，用于更改数组的内容。

#### 追加元素

如果你正在向一个数组添加新元素，你通常会希望将其添加到数组的末尾，这个操作被称为*追加*。这是一个非常常见的任务，PHP 通过简单的赋值语句使其变得非常容易。在等号左侧，你写数组的名称，后面跟着一个空的方括号；在等号右侧，你写你想要追加到数组中的值。例如，Listing 7-3 展示了一个脚本，它创建了一个空的动物数组，然后将元素追加到它的末尾。

```
<?php
$animals = [];
$animals[] = 'cat';
$animals[] = 'dog';

print "animals[0] = $animals[0] \n";
print "animals[1] = $animals[1] \n";
```

Listing 7-3: 追加元素到数组的末尾

我们通过写一个空的方括号来声明一个名为$animals 的空数组。然后，我们一个一个地将两个元素添加到数组的末尾。例如，$animals[] = 'cat' 将字符串值'cat'添加到数组的末尾。PHP 会自动为新元素分配下一个可用的整数作为键。在这个例子中，由于$animals 在添加'cat'时是空的，所以它的键被赋值为 0。当我们使用相同的符号将'dog'添加到数组时，该元素自动得到键 1。为了确认这一点，我们在脚本末尾打印数组的每个值，输出如下：

```
animals[0] = cat
animals[1] = dog
```

输出结果表明，'cat'成功映射到了数组的键 0，而'dog'映射到了键 1。PHP 引擎能够找到数组中最高的整数键，给它加 1，并将结果作为追加到数组时的下一个唯一整数键。

#### 使用特定键添加元素

虽然更常见的做法是将元素追加到数组，并让 PHP 自动分配下一个可用的整数键，但你也可以在向数组添加元素时手动指定该元素的键。例如，$heights[22] = 101 将值 101 添加到$heights 数组，并为其分配整数键 22。如果该键已经存在值，则该值会被覆盖。因此，这种直接赋值技术通常用于更新数组中已存在的值，而不是添加一个全新的值。Listing 7-4 扩展了我们的$animals 数组脚本，演示了如何进行这种操作。

```
<?php
$animals = [];
$animals[] = 'cat';
$animals[] = 'dog';
$animals[0] = 'hippo';

var_dump($animals);
```

Listing 7-4: 使用指定键直接赋值数组元素

如之前所示，我们将 'cat' 和 'dog' 添加到 `$animals` 数组中。然后，我们通过直接将该字符串赋值给数组的键 0 来替换第一个数组元素的值为 'hippo'。这是运行该脚本后的输出：

```
array(2) {
    [0]=>
    string(3) "hippo"
    [1]=>
    string(3) "dog"
}
```

请注意，'hippo' 现在映射到了键 0，这表示它已经替换了原来的 'cat' 值。

当你用特定的键添加新数组元素时要小心。如果为你提供的键不存在的数组元素进行此操作，可能会破坏整数键的顺序。如果你使用了超出数组当前大小的键，就会发生这种情况。创建一个具有断裂整数键序列的数组是允许的，但如果你在其他地方编写的代码依赖于键的连续序列，这可能会引发问题。我们将在 第八章 中探讨非顺序和非整数键的数组。

#### 添加多个元素

到目前为止，我们只能一次向数组中添加一个元素，但内置的 `array_push()` 函数可以一次将多个元素添加到数组的末尾。该函数接受可变数量的参数。第一个参数是你要更新的数组，后面是要附加的新值，你可以添加任意多个。例如，示例 7-5 重新展示了 示例 7-3 中的脚本，在该脚本中我们首先向 `$animals` 数组添加了元素并打印出来，然后使用 `array_push()` 将另外两个动物添加到数组末尾。

```
<?php
$animals = [];
$animals[] = 'cat';
$animals[] = 'dog';
array_push($animals, 'giraffe', 'elephant');

print "animals[0] = $animals[0] \n";
print "animals[1] = $animals[1] \n";
print "animals[2] = $animals[2] \n";
print "animals[3] = $animals[3] \n";
```

示例 7-5：使用 `array_push()` 将多个值附加到数组末尾

我们调用 `array_push()` 函数，将 `$animals` 数组和我们想要添加的两个字符串值，'giraffe' 和 'elephant'，传入。由于新元素被添加到数组的末尾，它们会自动分配下一个可用的整数键值，分别是 2 和 3。我们通过访问这两个额外的元素并根据它们的键值打印出来，确认了这一点，连同两个原始元素一起输出：

```
animals[0] = cat
animals[1] = dog
animals[2] = giraffe
animals[3] = elephant
```

输出表明，'giraffe' 成功映射到键 2，'elephant' 映射到了键 3。

你可能已经注意到，当我们调用 `array_push()` 函数时，并没有将其作为赋值语句的一部分，函数调用位于等号的右侧，变量名在左侧用于捕获函数的返回值。这是因为 `array_push()` 会直接修改传递给它的数组。从这个意义上讲，`array_push()` 与我们在 第三章 中看到的字符串操作函数非常不同，后者是创建并返回一个新的字符串，而不是直接修改传递给它们的原始字符串。

array_push() 函数可以直接修改提供的数组，因为它的第一个参数是通过按引用传递的方式声明的。正如我们在第五章中讨论的，这意味着该函数会获得传入参数值的直接引用，而不是通过按值传递方式获得该参数值的副本。我们可以通过查看 PHP 文档中的函数签名来确认这一点：

```
array_push(array &$array, mixed ...$values): int
```

第一个参数前的与符号（&）即 &$array，表示这是一个按引用传递的参数。

由于 array_push() 是直接修改数组的，因此无需返回数组的副本，或者我们在调用该函数时使用赋值语句来捕获返回值。实际上，array_push() *确实*有返回值，它返回一个整数，表示数组的新长度。如果你需要在更新数组时跟踪数组的长度，这个返回值就很有用；在列表 7-5 中我们并不需要这个返回值，所以我们只是独立地调用了该函数，而没有将结果赋值给变量。

#### 移除最后一个元素

内置的 array_pop() 函数返回数组中的最后一个元素，并同时从数组中移除该元素。这是另一个按引用传递的函数示例，它会改变提供的数组。在列表 7-6 中，我们使用 array_pop() 来获取并移除 $animals 数组的最后一个元素。

```
<?php
$animals = [];
$animals[] = 'cat';
$animals[] = 'dog';

$lastAnimal = array_pop($animals);
print "lastAnimal = $lastAnimal\n";
var_dump($animals);
```

列表 7-6：使用 array_pop() 函数获取并移除数组中的最后一个元素

我们调用 array_pop()，将 $animals 数组作为参数传递，并将函数的返回值存储在 $lastAnimal 变量中。然后，我们打印出 $lastAnimal 和 $animals 数组，查看哪些元素还剩下。结果如下：

```
lastAnimal = dog
array(1) {
    [0]=>
    string(3) "cat"
}
```

变量 $lastAnimal 中的字符串为 'dog'，因为这是最后一个被添加到数组中的元素。$animals 的 var_dump 显示，调用 array_pop() 后数组只包含 'cat'，这演示了这个通过引用传递的函数如何能够改变传入的数组。

### 检索数组信息

我们已经考虑了修改数组的一些函数，但其他函数可以在不改变数组的情况下返回关于数组的有用信息。例如，count() 返回数组中元素的数量。如果你想检查一个数组是否为空（零个元素可能意味着购物车为空，或者没有从数据库中检索到记录），或者它是否包含比预期更多的项（也许某个客户有多个地址存档），count() 就非常有用。有时，知道数组中有多少项对于控制遍历数组的循环也很有帮助。在列表 7-7 中，我们使用 count() 来打印 $animals 数组中的总项数。

```
<?php
$animals = ['cat', 'dog', 'giraffe', 'elephant'];

print count($animals);
```

列表 7-7：计算数组中元素的数量

我们调用 count()函数，传入我们希望计数的数组名称，并打印结果。由于$animals 数组包含四个元素，因此此脚本应输出整数 4。

> 注意

*sizeof()* *函数是* count() *的别名。如果你看到一个使用* sizeof() *的脚本，知道它的功能与* count() *相同。*

另一个分析性数组函数是 array_is_list()。PHP 区分了列表数组和非列表数组。为了被认为是*列表*，一个长度为*n*的数组必须拥有从 0 到*n* – 1 的连续编号键。array_is_list()函数接收一个数组，并根据该数组是否符合该定义返回 true 或 false。本章讨论的所有数组都符合列表的标准，因为它们依赖于 PHP 的默认行为，即从 0 开始顺序分配键。然而，在下一章，我们将探索具有非整数键的数组，以及 unset()函数，它可以删除一个具有特定键的数组元素，这可能打破连续的数字键链，使数组不再符合列表的定义。因此，array_is_list()函数对于在将数组传递给期望列表结构的代码之前评估数组是否符合要求非常有用。

array_key_last()函数返回给定数组最后一个元素的键。假设数组是一个有效的列表，且键是连续编号的，则 array_key_last()的返回值应该比 count()的返回值少 1。例如，在列表 7-7 的末尾调用 array_key_last($animals)将返回整数 3，因为这是数组中第四个（也是最后一个）元素的键。

之前我提到过，尝试访问一个不存在的数组键会触发警告。为了避免这种情况，在尝试访问数组键之前，使用 isset()函数检查该键是否存在。列表 7-8 展示了该函数的实际应用。

```
<?php
$animals = ['cat', 'dog', 'giraffe', 'elephant'];

❶ if (isset($animals[3])) {
    print "element 3 = $animals[3]\n";
} else {
    print "sorry - there is no element 3 in this array\n";
}

print "(popping last element [3])\n";
❷ array_pop($animals);

if (isset($animals[3])) {
    print "element 3 = $animals[3]\n";
} else {
    print "sorry - there is no element 3 in this array\n";
}
```

列表 7-8：使用 isset()测试数组键的存在

首先，我们创建了一个包含四个元素的$animals 数组。然后，我们使用带有 isset()的 if...else 语句，只有当键为 3 的元素存在时才访问它（此时它应该存在）❶。接着，我们使用 array_pop()删除$animals 数组中的最后一个元素（键为 3 的元素）❷。然后，我们重复相同的 if...else 语句。现在数组中没有键为 3 的元素，但由于我们在尝试访问该元素之前使用 isset()进行测试，因此我们不应该收到警告。看看脚本的输出：

```
element 3 = elephant
(popping last element [3])
sorry - there is no element 3 in this array
```

输出的第一行表示第一次调用 isset()返回了 true，触发了条件语句的 if 分支。最后一行显示第二次调用 isset()返回了 false，触发了 else 分支，避免了尝试访问一个不存在的数组元素。

### 遍历数组

访问数组元素并逐个处理它们是常见的操作。假设数组是一个列表，你可以通过使用一个计数器变量作为当前数组元素的键来使用`for`循环实现这一点。从 0 开始计数器并将其递增直到数组的长度，你可以依次访问每个元素。清单 7-9 使用`for`循环打印我们$animals 数组中的每个元素。

```
<?php
$animals = ['cat', 'dog', 'giraffe', 'elephant'];

$numElements = count($animals);
for ($i = 0; $i < $numElements; $i++) {
  ❶ $animal = $animals[$i];
    print "$animal, ";
}
```

清单 7-9：使用`for`循环遍历数组

我们使用`count()`来查找数组的长度，并将结果存储到$numElements 变量中。然后我们声明一个`for`循环，将计数器$i 从 0 递增到$numElements 的值（但不包括$numElements 本身）。(我们可以将停止条件硬编码为$i < 4，但使用变量可以使代码在数组长度变化时更具灵活性。）在循环语句组内，我们使用$animals[$i]来获取当前循环变量$i 对应的数组元素，并将其存储到$animal ❶。然后我们打印这个$animal 字符串，后面跟着一个逗号和一个空格。当我们在终端运行此脚本时，输出如下：

```
cat, dog, giraffe, elephant,
```

每个数组元素按顺序打印出来。（别担心，我们稍后会修正那个多余的逗号。）

#### 使用`foreach`循环

这种`for`循环方法是可行的，但由于遍历数组元素是一个非常常见的任务，PHP 提供了另一种循环类型——`foreach`循环，来更高效地完成此任务。`foreach`循环的核心语法是`foreach ($array as $value)`；其中$array 是要循环的数组名，而$value 是一个临时变量，每次被赋值为数组中的一个元素。清单 7-10 展示了清单 7-9 的更新版本，使用了`foreach`循环而不是`for`循环。

```
<?php
$animals = ['cat', 'dog', 'giraffe', 'elephant'];

foreach ($animals as $animal) {
 print "$animal, ";
}
```

清单 7-10：使用`foreach`循环优雅地遍历数组

我们通过使用`foreach ($animals as $animal)`来声明这个循环。在这里，$animal 是一个临时变量，依次获取每个数组元素的值，我们然后在循环体内打印它。注意，我们不再需要担心确定数组的长度来设置循环的停止条件，也不需要像在`for`循环版本中那样手动访问每个数组元素（如$animals[$i]）。`foreach`循环会自动访问每个元素。结果与`for`循环版本相同，但`foreach`循环的语法更加优雅简洁。

`foreach`循环还有一个额外的好处，我们无需关心提供的数组是否是真正的列表。在`for`循环版本中，我们依赖于数组键的连续整数编号；如果某个键缺失，尝试访问该键时会出现警告。相比之下，`foreach`循环会简单地访问数组中的每个元素，无论键是什么。

#### 访问键和值

`foreach` 循环的另一种语法允许你访问每个数组元素的键和值，而不仅仅是值。为此，可以按以下格式声明循环：`foreach ($array as $key => $value)`。这里，`$array` 是你想要遍历的数组，`$key` 是一个临时变量，保存当前元素的键，`$value` 是一个临时变量，保存当前元素的值。`=>` 操作符将键与值连接起来。在 第八章 中，当我们处理包含字符串和其他数据类型键的复杂数组时，会更加广泛地使用这种语法。

访问键和值使我们能够消除数组中最后一个元素后的多余逗号。回顾一下，`array_key_last()` 函数返回数组最后一个元素的键。通过将这个函数的返回值与 `foreach` 循环中的当前键进行比较，我们可以决定是否在每个元素后面打印逗号。 清单 7-11 展示了这一方法。

```
<?php
$animals = ['cat', 'dog', 'giraffe', 'elephant'];

foreach ($animals as $key => $animal) {
    print "$animal";
    if ($key != array_key_last($animals)) {
        print ", ";
    }
}
```

清单 7-11：一个修改后的 `foreach` 循环，访问每个数组元素的键和值

我们通过使用 `foreach ($animals as $key => $animal)` 来声明一个 `foreach` 循环。在每次循环中，`$key` 是当前数组元素的键，而 `$animal` 是当前数组元素的值。在循环内，我们首先打印出 `$animal` 中的字符串。然后，我们使用 `if` 语句来判断，如果当前元素的键 *不* 等于数组的最后一个键（可以通过 `array_key_last()` 函数获得），则打印出一个逗号和一个空格。这样应该会产生如下输出：

```
cat, dog, giraffe, elephant
```

我们已经成功地去掉了数组中最后一个元素后的逗号。

#### 将数组转换为字符串

清单 7-11 中的代码本质上是打印一个包含数组元素的字符串，元素之间有一个分隔符（在本例中是逗号和空格）。这是一个常见的任务，因此 PHP 提供了一个内建函数 `implode()` 来自动执行此操作，无需使用任何类型的循环。

该函数接受两个参数：一个作为分隔符的字符串和一个要转换为字符串的数组。分隔符 *位于* 元素之间，而不是 *每个* 元素后面，因此代码不会在数组的最后一个元素后添加额外的分隔符。清单 7-12 展示了一个更新后的脚本，使用 `implode()` 而不是 `foreach` 循环。

```
<?php
$animals = ['cat', 'dog', 'giraffe', 'elephant'];

print implode(', ', $animals);
```

清单 7-12：使用 `implode()` 将数组转换为字符串

在这里，我们打印调用 `implode()` 函数对 `$animals` 数组进行处理后的结果。我们使用字符串 `', '` 作为分隔符，在数组元素之间添加逗号和空格。输出应该与 清单 7-11 完全相同，但 `implode()` 使得代码写起来更高效。

implode()函数可能已经让我们在这种情况下不再需要 foreach 循环，但不要被这个误导。foreach 循环在很多场景下都是正确的工具。一般来说，当你要应用到数组中每个元素的代码比简单地打印出该元素的值更复杂时，使用 foreach 循环通常是合适的。

### 带有可变数量参数的函数

数组的一个重要应用是，你可以用它们来声明接受可变数量参数的函数。当我们在第五章中创建自定义函数时，我们需要准确知道每个函数会接受多少个参数，这样我们才能定义具有相应参数数量的函数。然而，这并不总是可能的。

例如，假设我们想声明一个 sum()函数，它接受一个不确定数量的数字，将它们全部加起来并返回结果。我们不知道用户会传递两个数字、三个数字或更多作为参数，因此无法为每个数字创建一个单独的参数。相反，我们使用一个单一的参数来表示所有数字，并在参数名前写三个点（...）。这种语法告诉 PHP 将该参数视为数组，并将其填充为所有传入的参数，无论有多少个。

列表 7-13 展示了如何通过声明刚才描述的 sum()函数来实现这一方法。记住，函数应该在与调用它们的代码分开的文件中声明，所以创建一个名为*my_functions.php*的文件，包含此列表的内容。

```
<?php
function sum(...$numbers): int
{
    $total = 0;

    foreach ($numbers as $number) {
        $total += $number;
    }

    return $total;
}
```

列表 7-13：一个接受可变数量整数参数并返回它们总和的函数

我们声明了 sum()函数，它返回一个整数。它有一个单一的参数，...$numbers。由于省略号，函数接收到的任何参数都会作为元素分配给一个名为$numbers 的本地数组。注意，使用省略号表示法时，我们没有为参数指定数据类型；我们知道整体的$numbers 变量将是数组类型，尽管数组的单个元素可以是任何类型。在函数体内，我们将$total 初始化为 0。然后我们使用 foreach 循环遍历$numbers 数组的元素，将每个元素的值加到$total 中。当循环结束时，我们返回$total，它保存了所有参数的总和。

> 注意

*我们的* sum() *函数没有包含任何逻辑来确认* $numbers *中的元素实际上是数字。一个真实的函数需要某种形式的数据验证，如果传入的参数不是所有数字，它可能会返回* NULL *或以其他方式指示数据无效。还需要注意的是，PHP 已经有一个内置的* array_sum() *函数，用来计算数组中数字的总和。我们实现了自己的版本用于演示。*

列表 7-14 展示了一个*main.php*脚本，用于读取 sum()函数的声明并通过传递不同数量的参数进行测试。

```
<?php
require_once 'my_functions.php';

print sum(1, 2, 3) . "\n";
print sum(20, 40) . "\n";
print sum(1, 2, 3, 4, 5, 6, 7) . "\n";
```

列表 7-14：一个调用 sum()并传入不同参数个数的主脚本

在使用 require_once 读取并执行*my_functions.php*之后，我们调用了三次 sum()，每次传入不同数量的参数，并打印结果。脚本输出如下：

```
6
60
28
```

打印的三个总和已正确计算。这表明我们的 sum()函数已经成功地将可变数量的参数收集到一个数组中。

### 数组复制与数组引用

假设你有一个包含数组的变量，并将其赋值给第二个变量。在一些语言中，例如 Python 和 JavaScript，第二个变量将被赋值为指向原始数组的*引用*。两个变量将指向计算机内存中的同一个数组，因此一个变量的变化也会影响另一个变量。而在 PHP 中，默认情况下是将第二个变量赋值为数组的*副本*。由于两个变量各自拥有独立的数组，因此一个变量的变化不会影响另一个变量。列表 7-15 回到我们的$animals 数组来说明这一点。

```
<?php
$animals = ['cat', 'dog', 'giraffe', 'elephant'];

$variable2 = $animals;
array_pop($variable2);
var_dump($animals);
```

列表 7-15：复制数组

我们声明了常规的$animals 数组，然后将$animals 赋值给$variable2。这会在$variable2 中创建一个数组的独立副本，因此我们对一个数组的操作不应影响另一个数组。为了证明这一点，我们使用 array_pop()删除$variable2 数组中的最后一个元素，然后打印原始的$animals 数组。结果如下：

```
array(4) {
    [0]=>
    string(3) "cat"
    [1]=>
    string(3) "dog"
    [2]=>
    string(7) "giraffe"
    [3]=>
    string(8) "elephant"
}
```

即使我们从$variable2 数组中删除了最后一个元素（'elephant'），$animals 数组中的四个动物字符串仍然存在，因此这两个变量确实持有独立的数组。

如果你希望将第二个变量赋值为对原始数组的引用，而不是数组的副本，就像其他语言中常见的做法那样，可以在赋值时使用引用操作符（&）。列表 7-16 更新了列表 7-15 中的代码，展示了两者的区别。

```
<?php
$animals = ['cat', 'dog', 'giraffe', 'elephant'];

$variable2 = &$animals;
array_pop($variable2);
var_dump($animals);
```

列表 7-16：在赋值数组时使用引用操作符

这次我们在将$animals 数组赋值给$variable2 时，前缀加上了引用操作符（&）。这意味着一个变量的变化将影响另一个变量，因为两个变量都引用了内存中的同一个数组。更新后的脚本输出结果如下：

```
array(3) {
    [0]=>
    string(3) "cat"
    [1]=>
    string(3) "dog"
    [2]=>
    string(7) "giraffe"
}
```

输出结果显示，从$variable2 数组中弹出元素 3 也同时删除了$animals 数组中的元素 3。这确认了$variable2 和$animals 都引用了内存中的同一个数组。

这些数组赋值的方法没有哪种天生比另一种更好，它们只是不同。有时最好在操作数组之前先复制一份。例如，一个网页可能让用户编辑购物清单，同时提供一个取消按钮来撤销编辑。在这种情况下，你可能希望在确认更改之前处理购物清单数组的副本，因为如果用户点击取消，你可能需要恢复到原始数组。其他时候，最好让多个变量引用内存中同一个数组。也许代码包含选择多个数组中的一个的逻辑，因此需要将某个变量设置为所选数组的引用。

本节的关键点是，除非使用引用操作符（&），否则 PHP 默认会复制数组。如果你在学习 PHP 之前已经学习过其他编程语言，或者将来学习其他语言，那么理解赋值副本与赋值引用之间的区别，并了解语言默认使用的行为是很重要的。

### 将字符串视为字符数组

从某种程度上讲，你可以把字符串看作是一个个独立字符的数组。这在某些情况下很有用，因为你可能希望逐字符“遍历”字符串，执行加密、拼写检查等任务，就像遍历数组的元素一样。

正如你在第三章中看到的，字符串中的字符是从 0 开始编号的，就像简单数组中的元素一样。事实上，你可以使用相同的方括号表示法来访问数组元素，同时也可以访问字符串中的特定字符。例如，如果$name 保存的是字符串'Smith'，那么$name[0]将返回'S'，$name[1]将返回'm'，依此类推。字符串还支持*负*整数键，用于从字符串的末尾反向计数字符：$name[-1]返回'h'（最后一个字符），$name[-2]返回't'，依此类推。

> 注意

*与字符串不同，数组本身并不会将负整数键解释为从数组末尾反向计数。相反，* $animals[-1] *将被解释为* $animals *数组中一个实际键为* -1 *的元素。虽然你*可以*手动将负整数作为键分配给数组元素，但我个人不记得曾经需要这么做。*

列表 7-17 展示了使用数组键语法访问字符串中单个字符的示例。

```
<?php
$name = 'Smith';

$firstChar = $name[0];
$secondToLastChar = $name[-2];

print "first character = '$firstChar'\n";
print "second to last character = '$secondToLastChar'\n";
```

列表 7-17：使用方括号表示法访问字符串字符

我们将字符串 'Smith' 分配给$name 变量。接下来，我们将字符串的第一个字符（$name[0]）复制到$firstChar 变量，将倒数第二个字符（$name[-2]）复制到$secondToLastChar 变量。然后，我们打印出这些变量的值，输出如下信息：

```
first character = 'S'
second to last character = 't'
```

与数组不同，我们不能将字符串传递给 `foreach` 循环以循环遍历其所有字符。然而，我们*可以*使用 PHP 内置的 `str_split()` 函数将字符串转换为实际的字符数组，然后将该数组传递给 `foreach` 循环，如 示例 7-18 所示。

```
<?php
$name = 'Smith';

$characters = str_split($name);
foreach ($characters as $key => $character) {
    print "character with key $key = '$character'\n";
}
```

示例 7-18：使用 `str_split()` 和 `foreach` 循环遍历字符串中的字符

我们将相同的 $name 字符串传递给 `str_split()`。默认情况下，该函数将字符串拆分为单个字符，将它们作为数组的元素，并返回结果，我们将其存储在 $characters 变量中。然后，我们使用 `foreach` 循环访问字符串的数组版本中的每个键和值并打印它们。结果如下：

```
character with key 0 = 'S'
character with key 1 = 'm'
character with key 2 = 'i'
character with key 3 = 't'
character with key 4 = 'h'
```

输出显示，在使用 `str_split()` 将字符串转换为数组后，我们已成功循环遍历原始字符串中的字符。

`str_split()` 函数有一个可选的第二个参数，用于控制结果数组中每个字符串元素的字符数。该参数的默认值为 1，将字符串拆分为单个字符，但如果我们调用 `str_split($name, 2)`，例如，那么结果数组将包含两个字符的字符串：['Sm', 'it', 'h']。

### 其他数组函数

本章已讨论了处理数组的一些内置函数，但 PHP 还有许多其他函数。适用于数组的其他有用函数包括：

sort()   将数组的值按升序排列（对于字符串值按字母顺序，对于数字值按数字顺序）

usort()   根据用户定义的函数将值排序为自定义顺序

array_flip()   交换数组元素的键和值

array_slice()   返回一个包含现有数组子序列的新数组

array_walk()   对数组的每个元素调用用户定义的函数

array_map()   对数组的每个元素调用用户定义的函数，并返回一个包含结果的新数组

array_rand()   返回数组中的随机键

要查看完整的数组函数列表，请参阅 PHP 文档中的 *[`www.php.net/manual/en/ref.array.php`](https://www.php.net/manual/en/ref.array.php)*。

### 总结

在这一章中，我们开始探索数组，这是一种复合数据类型，它在单一的变量名下存储多个值，每个值都有自己的标识键。目前，我们主要关注简单数组，它们的键是整数。本章介绍了多种技术，用于添加、删除和访问数组元素，以及获取数组信息的函数，如 `count()` 和 `isset()`。你还学会了如何通过使用 `foreach` 循环依次处理每个数组元素。在某些情况下，PHP 提供了内置函数来处理常见的数组任务，例如 `implode()` 函数，它将数组中的所有元素连接成一个字符串。这些函数有时可以让你用一个函数调用替代整个循环和条件语句。

### 练习

1.   创建一个 `$colors` 数组，其中包含五种颜色的字符串名称。打印数组中的随机颜色。

提示：你可以通过调用 `array_rand($colors)` 获取一个有效的随机键。

2.   写一个 `foreach` 循环，在新的一行中打印出练习 1 中数组的每个颜色，格式如下：

```
color 0 = blue
color 1 = red
...
```

3.   使用 `array_pop()` 打印练习 1 中颜色数组的最后一个元素。然后使用 `var_dump()` 显示该元素已经从数组中移除。

4.   创建一个包含整数年龄 23、31 和 55 的数组。使用内置函数计算并打印数组中项的数量及其平均值。
