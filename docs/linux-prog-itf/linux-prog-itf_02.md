## 第二章 基本概念

本章介绍了一些与 Linux 系统编程相关的概念，适合那些主要使用其他操作系统，或者仅有有限 Linux 或其他 UNIX 实现经验的读者。

## 核心操作系统：内核

*操作系统*一词通常有两种不同的含义：

+   用来指代整个软件包，它包括管理计算机资源的核心软件及所有附带的标准软件工具，如命令行解释器、图形用户界面、文件工具和编辑器。

+   更狭义地说，是指管理和分配计算机资源（即 CPU、RAM 和设备）的核心软件。

*内核*一词通常作为“操作系统”第二种含义的同义词，我们在本书中关注的正是这一层面的*操作系统*。

尽管没有内核也能在计算机上运行程序，但内核的存在极大地简化了其他程序的编写和使用，并增加了可供程序员使用的力量和灵活性。内核通过提供一个软件层来管理计算机有限的资源，从而实现这一点。

### 注意

Linux 内核的可执行文件通常位于路径 `/boot/vmlinuz`，或类似路径。这个文件名的来源是有历史背景的。在早期的 UNIX 实现中，内核被称为`unix`。后来的 UNIX 实现引入了虚拟内存，便将内核重命名为`vmunix`。在 Linux 中，文件名反映了系统名称，最后的*z*代替了*x*，表示内核是一个压缩的可执行文件。

#### 内核执行的任务

内核执行以下任务：

+   *进程调度*：计算机有一个或多个中央处理单元（CPU），用于执行程序指令。像其他 UNIX 系统一样，Linux 是一个*抢占式多任务*操作系统，*多任务*意味着多个进程（即运行中的程序）可以同时驻留在内存中，每个进程可以使用 CPU。*抢占式*意味着哪些进程能使用 CPU 以及使用多长时间的规则由内核的进程调度器决定（而不是由进程本身决定）。

+   *内存管理*：虽然按十几年前的标准来看，计算机的内存已经非常庞大，但软件的大小也相应地增加了，因此物理内存（RAM）仍然是一个有限的资源，内核必须以公平和高效的方式在进程之间分配。像大多数现代操作系统一样，Linux 采用了虚拟内存管理（虚拟内存管理），这一技术带来了两个主要优势：

    +   进程相互隔离，并与内核隔离，这样一个进程不能读取或修改另一个进程或内核的内存。

    +   只需将进程的部分内容保留在内存中，从而降低了每个进程的内存需求，并允许同时在 RAM 中保存更多进程。这带来了更好的 CPU 利用率，因为它增加了在任何时刻至少有一个进程可以被 CPU 执行的可能性。

+   *提供文件系统*：内核提供磁盘上的文件系统，允许创建、检索、更新、删除文件等操作。

+   *进程的创建与终止*：内核可以将一个新程序加载到内存中，为其提供运行所需的资源（例如，CPU、内存以及对文件的访问）。运行中的程序实例称为*进程*。一旦进程执行完成，内核会确保释放它使用的资源，以便后续的程序可以重新利用这些资源。

+   *访问设备*：连接到计算机的设备（鼠标、显示器、键盘、磁盘和磁带驱动器等）允许计算机与外部世界交换信息，实现输入、输出或两者兼有。内核为程序提供了一个接口，标准化并简化了对设备的访问，同时调度多个进程对每个设备的访问。

+   *网络通信*：内核代表用户进程传输和接收网络消息（数据包）。这项任务包括将网络数据包路由到目标系统。

+   *提供系统调用应用程序编程接口（API）*：进程可以通过内核入口点（称为*系统调用*）请求内核执行各种任务。Linux 系统调用 API 是本书的主要内容。系统调用详细介绍了进程执行系统调用时的步骤。

除了上述功能外，像 Linux 这样的多用户操作系统通常为用户提供*虚拟私人计算机*的抽象；也就是说，每个用户都可以登录系统并在很大程度上独立于其他用户进行操作。例如，每个用户都有自己的磁盘存储空间（主目录）。此外，用户可以运行程序，每个程序都会获得 CPU 的一部分资源并在自己的虚拟地址空间中运行，这些程序可以独立访问设备并通过网络传输信息。内核解决了访问硬件资源时可能出现的冲突，因此用户和进程通常不会察觉到这些冲突。

#### 内核模式与用户模式

现代处理器架构通常允许 CPU 至少在两种不同的模式下操作：*用户模式*和*内核模式*（有时也称为*超级用户模式*）。硬件指令允许从一个模式切换到另一个模式。相应地，虚拟内存的区域可以被标记为属于*用户空间*或*内核空间*。在用户模式下运行时，CPU 只能访问标记为用户空间的内存；尝试访问内核空间的内存会导致硬件异常。在内核模式下运行时，CPU 可以访问用户和内核内存空间。

某些操作只能在处理器处于内核模式时执行。例如，执行停止指令以停止系统，访问内存管理硬件，以及发起设备输入输出操作。通过利用这种硬件设计将操作系统放入内核空间，操作系统实现者可以确保用户进程无法访问内核的指令和数据结构，也无法执行可能会不利于系统操作的操作。

#### 进程与内核视角的对比

在许多日常编程任务中，我们习惯于以面向进程的方式进行编程。然而，在本书后面涉及的各种主题中，从内核的角度考虑问题可能会很有帮助。为了清楚地展示这种对比，我们现在先从进程视角来看看事物的表现，然后再从内核视角来考察。

一个运行中的系统通常有多个进程。对于一个进程，许多事情是异步发生的。一个正在执行的进程并不知道它下次什么时候会超时，哪些其他进程会被调度到 CPU（以及调度的顺序），或者它下次何时会被调度。信号的传递和进程间通信事件的发生是由内核调度的，并且可能在任何时候发生。许多事情对一个进程来说是透明的。一个进程并不知道它在 RAM 中的位置，或者一般来说，它的内存空间中的某一部分是否当前驻留在内存中，还是被保存在交换区（一个用于补充计算机 RAM 的磁盘空间保留区域）。类似地，一个进程也不知道它访问的文件在磁盘驱动器上的位置；它只是通过文件名引用这些文件。一个进程是在隔离中运行的；它不能直接与另一个进程通信。一个进程无法自己创建新进程，也不能结束自身的存在。最后，一个进程不能直接与连接到计算机的输入输出设备进行通信。

相比之下，运行中的系统有一个内核，它知道并控制一切。内核帮助管理系统上所有进程的运行。内核决定哪个进程将获得下一次 CPU 访问权限、何时访问以及访问多长时间。内核维护包含所有运行进程信息的数据结构，并在进程创建、状态变化和终止时更新这些结构。内核维护所有低级数据结构，使程序使用的文件名能够被转换为磁盘上的物理位置。内核还维护将每个进程的虚拟内存映射到计算机的物理内存和磁盘交换区的数据结构。进程间的所有通信都通过内核提供的机制完成。响应进程的请求，内核创建新进程并终止现有进程。最后，内核（特别是设备驱动程序）执行所有与输入输出设备的直接通信，根据需要将信息传输到用户进程或从用户进程传输。

本书稍后会提到类似“一个进程可以创建另一个进程”、“一个进程可以创建一个管道”、“一个进程可以向文件写数据”以及“一个进程可以通过调用 *exit()* 来终止”。但是，请记住，所有这些操作都由内核调解，而这些表述只是“一个进程可以 *请求内核* 创建另一个进程”等的简写形式。

#### 更多信息

现代有关操作系统概念和设计的书籍，特别是参考 UNIX 系统的书籍，包含了 [Tanenbaum, 2007]、[Tanenbaum & Woodhull, 2006] 和 [Vahalia, 1996]，后者包含了关于虚拟内存架构的详细内容。[Goodheart & Cox, 1994] 提供了关于 System V Release 4 的细节。[Maxwell, 1999] 提供了 Linux 2.2.5 内核的部分注释列表。[Lions, 1996] 是对第六版 UNIX 源代码的详细阐述，仍然是 UNIX 操作系统内部结构的有用入门书籍。[Bovet & Cesati, 2005] 详细描述了 Linux 2.6 内核的实现。

## Shell

*Shell* 是一个特殊的程序，用于读取用户输入的命令并根据这些命令执行相应的程序。这样的程序有时被称为 *命令解释器*。

*登录 Shell* 这个术语用于表示在用户首次登录时创建并运行 Shell 的过程。

在某些操作系统中，命令解释器是内核的一个组成部分，而在 UNIX 系统中，Shell 是一个用户进程。存在许多不同的 Shell，且同一台计算机上的不同用户（或者说，同一个用户）可以同时使用不同的 Shell。随着时间的推移，出现了许多重要的 Shell：

+   *Bourne shell* (*sh*)：这是最古老的广泛使用的 shell，由 Steve Bourne 编写。它是第七版 UNIX 的标准 shell。Bourne shell 包含了所有 shell 中常见的许多功能：I/O 重定向、管道、文件名生成（通配符）、变量、环境变量操作、命令替换、后台命令执行以及函数。所有后来的 UNIX 实现都包括 Bourne shell，除了它们可能提供的其他 shell。

+   *C shell* (*csh*)：这个 shell 是由 Bill Joy 在加利福尼亚大学伯克利分校编写的。这个名字来源于该 shell 中许多流程控制构造与 C 编程语言中的相似之处。C shell 提供了许多 Bourne shell 中没有的有用交互功能，包括命令历史、命令行编辑、作业控制和别名。C shell 不兼容 Bourne shell。虽然 BSD 上的标准交互式 shell 是 C shell，但 shell 脚本（稍后会描述）通常是为 Bourne shell 编写的，以确保它们能够跨所有 UNIX 实现移植。

+   *Korn shell* (*ksh*)：这个 shell 是由 AT&T 贝尔实验室的 David Korn 编写的，作为 Bourne shell 的继任者。在保持与 Bourne shell 的向后兼容性的同时，它还结合了类似于 C shell 提供的交互式功能。

+   *Bourne again shell* (*bash*)：这个 shell 是 GNU 项目重新实现的 Bourne shell。它提供了类似于 C shell 和 Korn shell 的交互功能。*bash* 的主要作者是 Brian Fox 和 Chet Ramey。Bash 可能是 Linux 上最广泛使用的 shell。（在 Linux 上，Bourne shell，*sh*，通常由 *bash* 模拟，尽可能接近 *sh* 的实现。）

### 注意

POSIX.2-1992 规定了一个标准的 shell，该标准基于当时版本的 Korn shell。如今，Korn shell 和 *bash* 都符合 POSIX 标准，但它们提供了多个扩展，并且这些扩展在两个 shell 之间有所不同。

这些 shell 不仅仅是为了交互使用，还用于解释 *shell 脚本*，即包含 shell 命令的文本文件。为此，每个 shell 都具备了通常与编程语言相关的功能：变量、循环和条件语句、I/O 命令以及函数。

每个 shell 执行类似的任务，尽管语法有所不同。除非提到特定 shell 的操作，否则我们通常会称之为“shell”，并理解所有 shell 都是以描述的方式运行的。本书中大多数需要 shell 的示例使用 *bash*，但是，除非特别说明，读者可以假设这些示例在其他 Bourne 类型的 shell 中也能以相同的方式工作。

## 用户与组

系统中的每个用户都有唯一标识，且用户可以属于不同的组。

#### 用户

系统中的每个用户都有一个唯一的*登录名*（用户名）和一个对应的数字*用户 ID*（UID）。对于每个用户，这些信息由系统*密码文件*（`/etc/passwd`）中的一行定义，包含以下附加信息：

+   *组 ID*：用户所属的第一个组的数字组 ID。

+   *主目录*：用户登录后进入的初始目录。

+   *登录 shell*：用于解释用户命令的程序名称。

密码记录可能还包括用户的密码，以加密形式存储。然而，出于安全考虑，密码通常存储在单独的*影子密码文件*中，该文件仅对特权用户可读。

#### 组

为了进行管理——特别是为了控制对文件和其他系统资源的访问——将用户组织成*组*是非常有用的。例如，某个团队中参与同一项目的人员，因而共享一套公共文件，可能会被加入同一个组。在早期的 UNIX 实现中，用户只能属于一个组。BSD 系统允许用户同时属于多个组，这一想法被其他 UNIX 实现和 POSIX.1-1990 标准采纳。每个组通过系统的*组文件*（`/etc/group`）中的一行来标识，该行包含以下信息：

+   *组名称*：该组的（唯一）名称。

+   *组 ID*（GID）：与此组关联的数字 ID。

+   *用户列表*：以逗号分隔的登录名列表，列出该组的成员用户（这些用户并未通过密码文件记录中的组 ID 字段被标识为该组的成员）。

#### 超级用户

一个用户，称为*超级用户*，在系统中具有特殊权限。超级用户账户的用户 ID 为 0，通常登录名为*root*。在典型的 UNIX 系统中，超级用户绕过系统中的所有权限检查。因此，例如，超级用户可以访问系统中的任何文件，无论该文件的权限如何，并且可以向系统中的任何用户进程发送信号。系统管理员使用超级用户账户执行各种系统管理任务。

## 单一目录层次结构、目录、链接和文件

内核维护着一个单一的层次化目录结构，用于组织系统中的所有文件。（这与操作系统如 Microsoft Windows 不同，后者每个磁盘设备都有自己的目录层次结构。）该层次结构的根目录是*根目录*，名为 `/`（斜杠）。所有文件和目录都是根目录的子目录或进一步的后代。图 2-1 显示了这种层次化文件结构的示例。

![Linux 单一目录层次结构的子集](img/02-1_CONCEPTS-file-system.png.jpg)图 2-1. Linux 单一目录层次结构的子集

#### 文件类型

在文件系统中，每个文件都有一个*类型*标识，表示它属于哪种文件类型。文件类型之一表示普通数据文件，这些文件通常被称为*常规*或*普通*文件，以区别于其他类型的文件。这些其他文件类型包括设备、管道、套接字、目录和符号链接。

*文件*一词通常用于表示任何类型的文件，而不仅仅是常规文件。

#### 目录与链接

*目录*是一种特殊的文件，其内容形式为文件名的表格，并附有对相应文件的引用。这种文件名加引用的关联叫做*链接*，一个文件可以在同一目录或不同目录中有多个链接，从而有多个名称。

目录可以包含指向文件和其他目录的链接。目录之间的链接建立了图 2-1 所示的目录层次结构。

每个目录至少包含两个条目：`.`（点），这是指向目录本身的链接；以及`..`（点点），这是指向其*父目录*的链接，即层次结构中上一级的目录。每个目录，除了根目录外，都有一个父目录。对于根目录，点点条目是指向根目录本身的链接（因此，`/..`等同于`/`）。

#### 符号链接

像普通链接一样，*符号链接*为文件提供了一个替代名称。但普通链接是目录列表中的文件名加指针条目，而符号链接是一个特别标记的文件，包含另一个文件的名称。（换句话说，符号链接在目录中有一个文件名加指针条目，而指针指向的文件包含一个字符串，表示另一个文件的名称。）这个后者的文件通常称为*符号链接的目标*，常说符号链接“指向”或“引用”目标文件。当在系统调用中指定路径名时，在大多数情况下，内核会自动*解除引用*（或同义地，*跟随*）路径名中的每个符号链接，并将其替换为指向的文件名。如果符号链接的目标本身是符号链接，这个过程可能会递归发生。（内核对解除引用的次数施加限制，以处理符号链接的循环链条问题。）如果符号链接指向一个不存在的文件，则称为*悬空链接*。

*硬链接*和*软链接*常作为普通链接和符号链接的替代术语。为何要有两种不同类型的链接，解释请参见第十八章。

#### 文件名

在大多数 Linux 文件系统中，文件名最多可以有 255 个字符。文件名可以包含除了斜杠（`/`）和空字符（`\0`）之外的任何字符。不过，建议仅使用字母、数字以及.（句点）、_（下划线）和-（连字符）字符。这个 65 个字符的字符集，`[-._a-zA-Z0-9]`，在 SUSv3 中被称为*可移植文件名字符集*。

我们应该避免在文件名中使用不属于可移植文件名字符集的字符，因为这些字符在 Shell、正则表达式或其他上下文中可能有特殊意义。如果包含有特殊意义字符的文件名出现在这些上下文中，则必须对这些字符进行*转义*；也就是说，必须特别标记——通常是在前面加上反斜杠（`\`）——以表明这些字符不应按特殊意义进行解释。在没有转义机制的上下文中，这样的文件名不可用。

我们还应该避免使用以连字符（`-`）开头的文件名，因为在 Shell 命令中指定这样的文件名时，可能会被误认为是选项。

#### 路径名

*路径名*是一个字符串，由可选的初始斜杠（`/`）和一系列由斜杠分隔的文件名组成。除最后一个文件名外，这些组件文件名标识一个目录（或一个解析为目录的符号链接）。路径名的最后一个组件可以标识任何类型的文件，包括目录。路径名前面部分的文件名序列有时称为路径名的*目录*部分，而最后一个斜杠后面的名字有时称为路径名的文件或*基础*部分。

路径名是从左到右读取的；每个文件名位于路径名前面部分指定的目录中。字符串`..`可以在路径名的任何位置使用，表示当前指定位置的父级目录。

路径名描述了文件在单一目录层次结构中的位置，可以是绝对路径名或相对路径名：

+   *绝对路径名*以斜杠（`/`）开始，指定相对于根目录的文件位置。在图 2-1 中的绝对路径名示例有`/home/mtk/.bashrc`、`/usr/include`和`/`（根目录的路径名）。

+   *相对路径名*指定了相对于进程当前工作目录（见下文）的文件位置，并且与绝对路径名的区别在于它没有初始的斜杠。在图 2-1 中，从目录`usr`可以使用相对路径名`include/sys/types.h`引用文件`types.h`，而从目录`avr`则可以使用相对路径名`../mtk/.bashrc`访问文件`.bashrc`。

#### 当前工作目录

每个进程都有一个*当前工作目录*（有时称为进程的*工作目录*或*当前目录*）。这是进程在单一目录层次结构中的“当前位置”，并且从这个目录开始，相对路径名会被进程解释。

进程继承其当前工作目录自父进程。登录 shell 的初始当前工作目录设置为用户密码文件条目中的主目录字段所指定的位置。可以使用*cd*命令更改 shell 的当前工作目录。

#### 文件所有权和权限

每个文件都有一个关联的用户 ID 和组 ID，用来定义文件的所有者和所属的组。文件的所有权用于确定用户对文件的访问权限。

为了访问文件，系统将用户分为三类：文件的*所有者*（有时称为文件的*用户*）、属于与文件组 ID 匹配的组的用户（*组*），以及其他所有人（*其他*）。对于每个用户类别，可以设置三个权限位（总共九个位权限）：*读取*权限允许读取文件内容；*写入*权限允许修改文件内容；*执行*权限允许执行文件，这个文件可以是程序或由某个解释器（通常是 shell，但不总是）处理的脚本。

这些权限也可以设置在目录上，尽管它们的含义略有不同：*读取*权限允许列出目录中的内容（即目录中的文件名）；*写入*权限允许更改目录中的内容（即可以添加、删除和更改文件名）；*执行*（有时称为*搜索*）权限允许访问目录内的文件（取决于文件本身的权限）。

## 文件 I/O 模型

UNIX 系统 I/O 模型的一个显著特点是*I/O 的普遍性*概念。这意味着相同的系统调用（*open()*, *read()*, *write()*, *close()* 等）用于对所有类型的文件进行 I/O 操作，包括设备。（内核将应用程序的 I/O 请求转换为适当的文件系统或设备驱动程序操作，以对目标文件或设备执行 I/O。）因此，使用这些系统调用的程序将适用于任何类型的文件。

内核基本上提供了一种文件类型：字节的顺序流，在磁盘文件、磁盘和磁带设备的情况下，可以使用*lseek()*系统调用进行随机访问。

许多应用程序和库将 *换行* 字符（ASCII 码 10，十进制，有时也称为 *换行符*）解释为终止一行文本并开始另一行。UNIX 系统没有 *文件结束* 字符；文件的结束是通过读取时没有返回数据来检测的。

#### 文件描述符

I/O 系统调用通过*文件描述符*来引用打开的文件，文件描述符是一个（通常较小的）非负整数。文件描述符通常通过调用 *open()* 获取，该函数接受一个指定要进行 I/O 操作的文件路径名参数。

通常，进程在由 shell 启动时会继承三个打开的文件描述符：描述符 0 是*标准输入*，即进程获取输入的文件；描述符 1 是*标准输出*，即进程输出结果的文件；描述符 2 是*标准错误*，即进程输出错误消息和异常或不正常条件通知的文件。在交互式 shell 或程序中，这三个描述符通常连接到终端。在 *stdio* 库中，这些描述符对应于文件流 *stdin*、*stdout* 和 *stderr*。

#### *stdio* 库

为了执行文件 I/O，C 程序通常会使用标准 C 库中的 I/O 函数。这些函数集合称为 *stdio* 库，包含了 *fopen()*、*fclose()*、*scanf()*、*printf()*、*fgets()*、*fputs()* 等等。*stdio* 函数是建立在 I/O 系统调用（如 *open()*、*close()*、*read()*、*write()* 等）的基础上的。

### 注意

我们假设读者已经熟悉 C 标准 I/O (*stdio*) 函数，本书不再涉及这些内容。有关 *stdio* 库的更多信息，可以参考 [Kernighan & Ritchie, 1988]、[Harbison & Steele, 2002]、[Plauger, 1992] 和 [Stevens & Rago, 2005]。

## 程序

*程序*通常有两种形式。第一种形式是*源代码*，它是由一系列使用编程语言（如 C）编写的、易于人类阅读的文本语句。为了执行，源代码必须转换为第二种形式：计算机能够理解的二进制机器语言指令。（这与*脚本*不同，脚本是包含一系列命令的文本文件，命令会直接被程序处理，如 shell 或其他命令解释器。）这两种意义下的*程序*通常被认为是同义的，因为编译和链接的步骤将源代码转换为语义上等价的二进制机器码。

#### 过滤器

*过滤器* 是一个常用的名称，指的是一种从 *stdin* 获取输入、对输入进行某些变换并将变换后的数据写入 *stdout* 的程序。过滤器的例子包括 *cat*、*grep*、*tr*、*sort*、*wc*、*sed* 和 *awk*。

#### 命令行参数

在 C 语言中，程序可以访问*命令行参数*，即程序运行时在命令行上提供的单词。要访问命令行参数，程序的*main()*函数需要按以下方式声明：

```
int main(int argc, char *argv[])
```

*argc*变量包含命令行参数的总数，单独的参数作为由*argv*数组成员指向的字符串提供。第一个字符串*argv[0]*表示程序本身的名称。

## 进程

简单来说，*进程*是一个正在执行的程序的实例。当程序执行时，内核将程序代码加载到虚拟内存中，为程序变量分配空间，并设置内核的书籍数据结构来记录有关进程的各种信息（如进程 ID、终止状态、用户 ID 和组 ID）。

从内核的角度来看，进程是内核必须共享计算机各种资源的实体。对于有限的资源，如内存，内核最初为进程分配一些资源，并根据进程的需求和系统对该资源的总体需求在进程的生命周期中调整这种分配。当进程终止时，所有这些资源都会被释放，以供其他进程重新使用。其他资源，如 CPU 和网络带宽，虽然是可再生的，但必须在所有进程之间公平共享。

#### 进程内存布局

进程逻辑上被分为以下部分，称为*段*：

+   *文本*：程序的说明。

+   *数据*：程序使用的静态变量。

+   *堆*：一个程序可以从中动态分配额外内存的区域。

+   *堆栈*：一块内存，随着函数调用和返回而增长和缩小，用于分配局部变量和函数调用链接信息的存储。

#### 进程创建与程序执行

进程可以通过调用*fork()*系统调用来创建新进程。调用*fork()*的进程被称为*父进程*，新创建的进程被称为*子进程*。内核通过制作父进程的副本来创建子进程。子进程继承父进程的数据、堆栈和堆段的副本，随后可以独立于父进程的副本进行修改。（程序文本位于标记为只读的内存中，两个进程共享该部分内存。）

子进程可以执行与父进程相同代码中的不同功能集，或者通常使用*execve()*系统调用加载并执行一个全新的程序。*execve()*调用会销毁现有的文本、数据、堆栈和堆段，并用基于新程序代码的段替代它们。

几个相关的 C 库函数在*execve()*之上层叠，每个函数提供略有不同的接口来实现相同的功能。所有这些函数的名称都以*exec*字符串开头，且在差异不重要的情况下，我们将使用*exec()*表示这些函数。需要注意的是，实际上并没有名为*exec()*的函数。

通常，我们会使用动词*to exec*来描述执行*execve()*以及其上层库函数执行的操作。

#### 进程 ID 和父进程 ID

每个进程都有一个独特的整数*进程标识符*（PID）。每个进程还具有一个*父进程标识符*（PPID）属性，用于标识请求内核创建该进程的进程。

#### 进程终止与终止状态

进程可以通过两种方式终止：通过使用*_exit()*系统调用（或相关的*exit()*库函数）请求自身终止，或通过信号的发送将其终止。在这两种情况下，进程都会产生一个*终止状态*，这是一个小的非负整数值，父进程可以通过*wait()*系统调用检查该状态。如果调用了 _*exit()*，进程将明确指定其终止状态。如果进程被信号杀死，终止状态将根据导致进程死亡的信号类型进行设置。（有时，我们会将传递给 _*exit()*的参数称为进程的*退出状态*，以区别于终止状态，后者要么是传递给 _*exit()*的值，要么是指示杀死进程的信号。）

按惯例，终止状态为 0 表示进程成功，非零状态表示发生了某种错误。大多数 shell 通过名为*$?*的 shell 变量提供最后执行程序的终止状态。

#### 进程的用户标识符和组标识符（凭证）

每个进程都有多个相关联的用户 ID（UID）和组 ID（GID）。这些包括：

+   *实际用户 ID*和*实际组 ID*：这些 ID 标识了进程所属的用户和组。新进程从其父进程继承这些 ID。登录 shell 从系统密码文件中的相应字段获取实际用户 ID 和实际组 ID。

+   *有效用户 ID*和*有效组 ID*：这两个 ID（结合稍后讨论的附加组 ID）用于确定进程在访问受保护资源（如文件和进程间通信对象）时所具有的权限。通常，进程的有效 ID 与相应的实际 ID 具有相同的值。更改有效 ID 是一种机制，允许进程获取另一个用户或组的权限，稍后会详细描述。

+   *附加组 ID*：这些 ID 标识进程所属的额外组。一个新进程会继承其父进程的附加组 ID。登录 Shell 从系统组文件中获取其附加组 ID。

#### 特权进程

传统上，在 UNIX 系统中，*特权进程*是指其*有效*用户 ID 为 0（超级用户）的进程。这样的进程绕过了内核通常施加的权限限制。相比之下，*非特权进程*（或*无特权进程*）是指由其他用户运行的进程。这些进程有非零有效用户 ID，并且必须遵守内核施加的权限规则。

进程可能是特权的，因为它是由另一个特权进程创建的——例如，由*root*（超级用户）启动的登录 Shell。进程还可以通过设置用户 ID 机制变得具有特权，该机制允许进程获得与其正在执行的程序文件相同的有效用户 ID。

#### 能力

自从 2.2 版本的内核开始，Linux 将传统上属于超级用户的权限划分为一组独立的单元，称为*能力*。每个特权操作都与特定的能力相关联，进程只有在具备相应能力时，才能执行该操作。传统的超级用户进程（有效用户 ID 为 0）对应于一个启用了所有能力的进程。

将一部分能力授予进程可以让它执行一些通常只有超级用户才能执行的操作，同时防止它执行其他操作。

能力在第三十九章中有详细描述。在本书的其余部分，当提到某个特定操作只能由特权进程执行时，我们通常会在括号中标明具体的能力名称。能力名称以前缀`CAP_`开头，例如`CAP_KILL`。

#### *init* 进程

在启动系统时，内核创建了一个特殊的进程，称为*init*，即“所有进程的父进程”，它来源于程序文件`/sbin/init`。系统上的所有进程都是通过*init*或其后代创建的（使用*fork()*）。*init*进程的进程 ID 始终是 1，并且以超级用户权限运行。*init*进程无法被终止（即使是超级用户也不能终止），它仅在系统关闭时终止。*init*的主要任务是创建和监视运行系统所需的一系列进程。（详细信息，请参见*init(8)*手册页。）

#### 守护进程

*守护进程*是一种特殊的进程，由系统创建和管理，方式与其他进程相同，但它具有以下特点：

+   它是长期存在的。守护进程通常在系统启动时启动，并保持存在直到系统关闭。

+   它在后台运行，并且没有控制终端，无法从中读取输入或向其写入输出。

守护进程的例子包括*syslogd*，它记录系统日志中的信息，以及*httpd*，它通过超文本传输协议（HTTP）提供网页服务。

#### 环境列表

每个进程都有一个*环境列表*，它是一个包含*环境变量*的集合，存储在进程的用户空间内存中。该列表的每个元素由一个名称和一个相关的值组成。当通过*fork()*创建新进程时，它会继承父进程的环境副本。因此，环境提供了一种机制，使父进程可以向子进程传递信息。当一个进程使用*exec()*替换其正在运行的程序时，新程序要么继承旧程序使用的环境，要么接收作为*exec()*调用一部分的新的环境。

在大多数 Shell 中，环境变量是通过*export*命令创建的（在 C Shell 中是*setenv*命令），例如如下所示：

```
$ export MYVAR='Hello world'
```

### 注意

每当我们展示一个显示交互式输入和输出的 Shell 会话日志时，输入文本总是以粗体显示。有时，我们在日志中加入注释，使用斜体文本，对输入的命令或输出的结果进行说明。

C 程序可以通过外部变量(*char **environ*)访问环境，并且各种库函数允许进程检索和修改其环境中的值。

环境变量有多种用途。例如，Shell 定义并使用一系列变量，脚本和程序可以通过这些变量访问，这些变量包括`HOME`，它指定用户登录目录的路径名，以及`PATH`，它指定 Shell 在寻找与用户输入的命令对应的程序时应该搜索的目录列表。

#### 资源限制

每个进程都会消耗资源，例如打开的文件、内存和 CPU 时间。通过使用*setrlimit()*系统调用，进程可以为其消耗的各种资源设定上限。每个这样的*资源限制*都有两个相关的值：*软限制*，它限制进程可以消耗的资源量；以及*硬限制*，它是软限制可以调整的最大值。一个没有特权的进程可以将某一特定资源的软限制调整到从零到相应硬限制之间的任何值，但只能降低其硬限制。

当通过*fork()*创建一个新进程时，它会继承父进程的资源限制设置副本。

Shell 的资源限制可以通过*ulimit*命令（在 C Shell 中是*limit*命令）进行调整。这些限制设置会被 Shell 创建的子进程继承，以执行命令。

## 内存映射

*mmap()* 系统调用在调用进程的虚拟地址空间中创建一个新的*内存映射*。

映射分为两类：

+   一个*文件映射*将文件的一个区域映射到调用进程的虚拟内存中。一旦映射，文件的内容可以通过对相应内存区域中的字节进行操作来访问。映射的页会根据需要自动从文件中加载。

+   相反，*匿名映射*没有对应的文件。相反，映射的页被初始化为 0。

一个进程的内存映射可能与其他进程的映射共享。这种情况可能发生在两个进程映射同一区域的文件时，或者因为通过*fork()*创建的子进程继承了父进程的映射。

当两个或多个进程共享相同的页面时，每个进程可能会看到其他进程对页面内容所做的更改，这取决于映射是私有的还是共享的。当映射是*私有的*时，对映射内容的修改对其他进程不可见，并且不会反映到底层文件中。当映射是*共享的*时，对映射内容的修改对共享相同映射的其他进程可见，并且会反映到底层文件中。

内存映射有多种用途，包括从可执行文件的相应段初始化进程的文本段、分配新的（填充零的）内存、文件 I/O（内存映射 I/O）以及进程间通信（通过共享映射）。

## 静态库和共享库

一个*目标库*是一个包含（通常是逻辑上相关的）一组函数的编译目标代码的文件，这些函数可以从应用程序中调用。将一组函数的代码放入一个单一的目标库中可以简化程序创建和维护的任务。现代 UNIX 系统提供了两种类型的目标库：*静态库*和*共享库*。

#### 静态库

静态库（有时也称为*档案*）是早期 UNIX 系统中唯一的库类型。静态库本质上是一个结构化的编译过的目标模块集合。为了使用静态库中的函数，我们在构建程序时的链接命令中指定该库。在将主程序中的各种函数引用解析到静态库中的模块后，链接器会从库中提取所需的目标模块副本，并将这些副本复制到最终的可执行文件中。我们说这样一个程序是*静态链接*的。

每个静态链接的程序都包含其所需的库中目标模块的副本，这会带来一些不利之处。其中一个问题是，不同可执行文件中目标代码的重复会浪费磁盘空间。当多个静态链接程序同时执行并使用相同的库函数时，内存中也会发生相应的浪费；每个程序都需要自己的一份函数副本。此外，如果库函数需要修改，那么在重新编译该函数并将其添加到静态库后，所有需要使用更新函数的应用程序都必须重新链接该库。

#### 共享库

共享库的设计旨在解决静态库的问题。

如果一个程序与共享库链接，那么链接器不会将库中的目标模块复制到可执行文件中，而是将一条记录写入可执行文件，指示在运行时该可执行文件需要使用该共享库。当可执行文件在运行时被加载到内存中时，一个叫做*动态链接器*的程序会确保找到并加载可执行文件所需的共享库，并在运行时进行链接，将可执行文件中的函数调用解析到共享库中的相应定义。在运行时，只有共享库的单一副本需要驻留在内存中，所有正在运行的程序都可以使用这一副本。

共享库包含函数的唯一编译版本，从而节省了磁盘空间。这也大大简化了确保程序使用最新版本函数的工作。只需重新构建包含新函数定义的共享库，现有程序在下次执行时便会自动使用新的定义。

## 进程间通信与同步

一个正在运行的 Linux 系统由众多进程组成，其中许多进程相互独立地运行。然而，一些进程通过合作来实现它们的预定目标，这些进程需要相互之间的通信和同步方法。

进程间通信的一种方式是通过读取和写入磁盘文件中的信息。然而，对于许多应用程序来说，这种方式太慢且不灵活。因此，Linux 像所有现代 UNIX 实现一样，提供了丰富的*进程间通信*（IPC）机制，包括以下几种：

+   *信号*，用于指示某个事件已发生；

+   *管道*（对 shell 用户来说，熟悉的`|`操作符）和*FIFO*，可以用来在进程之间传输数据；

+   *套接字*，可用于将数据从一个进程传输到另一个进程，无论是在同一台主机上还是在通过网络连接的不同主机之间；

+   *文件锁定*，允许进程锁定文件的某些区域，以防止其他进程读取或更新文件内容；

+   *消息队列*，用于在进程之间交换消息（数据包）； 

+   *信号量*，用于同步进程的操作；以及

+   *共享内存*，允许两个或多个进程共享一块内存。当一个进程改变共享内存的内容时，所有其他进程都能立即看到这些变化。

UNIX 系统上多种多样的 IPC 机制，有时功能重叠，部分原因是它们在不同 UNIX 系统变种和各种标准的要求下演化。例如，FIFO 和 UNIX 域套接字本质上执行相同的功能，允许同一系统上的无关进程交换数据。两者都存在于现代 UNIX 系统中，因为 FIFO 来自 System V，而套接字则来自 BSD。

## 信号

尽管我们在前一节中将它们列为进程间通信（IPC）的一种方法，但信号通常在更广泛的其他上下文中使用，因此值得更长时间的讨论。

信号通常被描述为“软件中断”。信号的到达通知进程某个事件或异常条件的发生。信号有多种类型，每种类型表示不同的事件或条件。每种信号类型由不同的整数标识，并用形式为`SIGxxxx`的符号名称定义。

信号由内核、其他进程（具有适当权限）或进程本身发送。例如，当发生以下情况时，内核可能会向进程发送信号：

+   用户在键盘上输入了*中断*字符（通常是*Control-C*）；

+   进程的某个子进程已终止；

+   进程设置的计时器（闹钟）已过期；或者

+   进程尝试访问无效的内存地址。

在 shell 中，*kill*命令可以用于向进程发送信号。*kill()*系统调用在程序中提供相同的功能。

当进程接收到信号时，它根据信号采取以下某种行动：

+   它忽略了信号；

+   它被信号终止；或者

+   它被暂停，直到通过接收一个特殊用途的信号被恢复。

对于大多数信号类型，程序可以选择忽略信号（如果该信号的默认动作不是被忽略，则这种方式很有用），或者建立一个*信号处理程序*。信号处理程序是一个程序员定义的函数，当信号被发送到进程时，该函数会自动调用。该函数执行与生成该信号的条件相关的某些操作。

在生成信号与信号交付之间的这段时间内，信号被称为*挂起*。通常，挂起的信号会在接收进程下次调度运行时传递，或者如果进程已经在运行，则立即传递。然而，也可以通过将信号添加到进程的*信号屏蔽*中来*屏蔽*信号。如果在信号被屏蔽时生成信号，它将保持挂起状态，直到以后被解除屏蔽（即，从信号屏蔽中移除）。

## 线程

在现代 UNIX 实现中，每个进程可以有多个*线程*。一种理解线程的方式是将其看作一组共享相同虚拟内存的进程，以及一系列其他属性。每个线程执行相同的程序代码，并共享相同的数据区和堆。然而，每个线程都有自己的堆栈，包含局部变量和函数调用链信息。

线程可以通过它们共享的全局变量相互通信。线程 API 提供了*条件变量*和*互斥锁*，这些原语使得一个进程的线程能够进行通信并同步它们的行为，特别是在它们使用共享变量时。线程也可以通过进程间通信与同步中描述的 IPC 和同步机制相互通信。

使用线程的主要优点在于，它们使得通过全局变量在协作线程之间共享数据变得容易，并且某些算法比起多进程实现，更自然地转化为多线程实现。此外，多线程应用程序可以透明地利用多处理器硬件上的并行处理能力。

## 进程组和 Shell 作业控制

Shell 执行的每个程序都是在一个新进程中启动的。例如，Shell 创建三个进程来执行以下命令管道（该管道显示当前工作目录中按文件大小排序的文件列表）：

```
$ ls -l | sort -k5n | less
```

除了 Bourne Shell 外，所有主要的 Shell 都提供一个名为*作业控制*的交互功能，允许用户同时执行和操作多个命令或管道。在作业控制的 Shell 中，管道中的所有进程都会被放置在一个新的*进程组*或*作业*中。（在一个简单的 Shell 命令行中，仅包含一个命令时，会创建一个只包含单个进程的新进程组。）进程组中的每个进程都有相同的整数*进程组标识符*，该标识符与组内某个进程的进程 ID 相同，这个进程被称为*进程组领导者*。

内核允许对进程组中的所有成员执行各种操作，特别是信号的传递。作业控制外壳利用这一特性，允许用户暂停或恢复管道中的所有进程，如下节所述。

## 会话、控制终端和控制进程

*会话*是由进程组（作业）组成的集合。会话中的所有进程都具有相同的*会话标识符*。*会话领导者*是创建会话的进程，它的进程 ID 成为会话 ID。

会话主要由作业控制外壳使用。所有由作业控制外壳创建的进程组都属于与外壳相同的会话，该外壳是会话的会话领导者。

会话通常会有一个关联的*控制终端*。控制终端是在会话领导者进程首次打开终端设备时建立的。对于由交互式外壳创建的会话，这就是用户登录时使用的终端。一个终端最多只能是一个会话的控制终端。

由于打开了控制终端，会话领导者成为该终端的*控制进程*。如果发生终端断开连接（例如，如果终端窗口被关闭），控制进程会收到一个`SIGHUP`信号。

在任何时刻，会话中的一个进程组是*前台进程组*（*前台作业*），它可以从终端读取输入并将输出发送到终端。如果用户在控制终端上输入*中断*字符（通常是*Control-C*）或*暂停*字符（通常是*Control-Z*），则终端驱动程序会发送一个信号，终止或暂停（即停止）前台进程组。一个会话可以有任意数量的*后台进程组*（*后台作业*），它们通过在命令后加上符号（`&`）来创建。

作业控制外壳提供了列出所有作业、向作业发送信号，以及将作业在前台和后台之间移动的命令。

## 虚拟终端

*虚拟终端*是一对连接的虚拟设备，分别称为*主设备*和*从设备*。这一设备对提供了一个 IPC 通道，允许数据在两个设备之间双向传输。

伪终端的关键点在于从设备提供了一个行为类似终端的接口，这使得可以将终端导向程序连接到从设备，然后使用连接到主设备的另一个程序来驱动终端导向程序。由驱动程序写入的输出经过终端驱动程序执行通常的输入处理（例如，在默认模式下，回车被映射为换行符），然后作为输入传递给连接到从设备的终端导向程序。终端导向程序写入从设备的任何内容，都将（在执行所有常规终端输出处理后）作为输入传递给驱动程序。换句话说，驱动程序执行的是通常由用户在传统终端上执行的功能。

伪终端被广泛应用于各种场景，最显著的应用是在 X Window 系统登录下提供的终端窗口的实现以及提供网络登录服务的应用程序，如*telnet*和*ssh*。

## 日期和时间

有两种时间对进程非常重要：

+   *实时*是从某个标准时间点（*日历*时间）或某个固定时间点（通常是进程生命周期开始时）来度量的（即*经过*时间或*挂钟时间*）。在 UNIX 系统上，日历时间是从 1970 年 1 月 1 日午夜以来的秒数来度量的，使用协调世界时（通常缩写为 UTC），并且与通过英国格林威治的经线定义的时区基准点进行协调。这个日期，接近 UNIX 系统的诞生，被称为*纪元*。

+   *进程时间*，也称为*CPU 时间*，是一个进程自启动以来所使用的总 CPU 时间。CPU 时间进一步划分为*系统 CPU 时间*，即在*内核模式*下执行代码的时间（例如，执行系统调用并为进程执行其他内核服务），和*用户 CPU 时间*，即在*用户模式*下执行代码的时间（例如，执行普通程序代码）。

*time*命令显示真实时间、系统 CPU 时间以及执行管道中进程所需的用户 CPU 时间。

## 客户端-服务器架构

本书的不同部分，我们讨论了客户端-服务器应用程序的设计和实现。

一个*客户端-服务器应用程序*是一个被分成两个组件进程的应用程序：

+   一个*客户端*，它通过发送请求消息请求服务器执行某些*服务*；

+   一个*服务器*，它检查客户端的请求，执行适当的操作，然后将响应消息发送回客户端。

有时，客户端和服务器可能会进行一系列扩展的请求和响应对话。

通常，客户端应用程序与用户互动，而服务器应用程序提供对某些共享资源的访问。通常，多个客户端进程实例与一个或几个服务器进程实例进行通信。

客户端和服务器可能驻留在同一主机上，也可能位于通过网络连接的不同主机上。为了相互通信，客户端和服务器使用在进程间通信与同步中讨论的 IPC 机制。

服务器可能实现多种服务，例如：

+   提供对数据库或其他共享信息资源的访问；

+   提供通过网络访问远程文件；

+   封装一些业务逻辑；

+   提供对共享硬件资源（例如打印机）的访问；或者

+   提供网页服务。

将服务封装在单一服务器中有很多好处，举例如下：

+   *效率*：由服务器管理的单个资源实例（例如打印机）可能比在每台计算机上本地提供相同资源更为经济。

+   *控制、协调与安全性*：通过将资源（特别是信息资源）集中在一个位置，服务器可以协调对该资源的访问（例如，防止两个客户端同时更新相同的信息），或将其安全地保护，只允许特定的客户端访问。

+   *在异构环境中的操作*：在网络中，各种客户端和服务器可以运行在不同的硬件和操作系统平台上。

## 实时

*实时应用程序*是那些需要及时响应输入的应用程序。通常，这种输入来自外部传感器或专用输入设备，输出则表现为控制一些外部硬件。具有实时响应要求的应用程序示例包括自动化生产线、银行 ATM 机和飞机导航系统。

尽管许多实时应用程序要求对输入做出快速响应，但决定性因素是确保在触发事件后的某个截止时间内传递响应。

提供实时响应性，特别是在要求短响应时间的情况下，需要底层操作系统的支持。大多数操作系统原生不提供这种支持，因为实时响应性要求可能与多用户时间共享操作系统的要求相冲突。传统的 UNIX 实现并不是实时操作系统，尽管已经开发出了实时变种。Linux 的实时变种也已创建，最近的 Linux 内核正在朝着完全原生支持实时应用程序的方向发展。

POSIX.1b 为支持实时应用程序定义了 POSIX.1 的多个扩展。这些扩展包括异步 I/O、共享内存、内存映射文件、内存锁定、实时时钟和定时器、替代调度策略、实时信号、消息队列和信号量。尽管它们严格来说不算是实时的，但大多数 UNIX 实现现在支持其中的一部分或全部扩展。（在本书中，我们将描述 POSIX.1b 的特性，Linux 支持其中的哪些功能。）

### 注意

在本书中，我们使用术语 *real time* 来指代日历或经过的时间的概念，而使用术语 *realtime* 来表示操作系统或应用程序提供的本节所描述的响应性。

## `/proc` 文件系统

与其他一些 UNIX 实现一样，Linux 提供了一个 `/proc` 文件系统，该系统由一组目录和文件组成，挂载在 `/proc` 目录下。

`/proc` 文件系统是一个虚拟文件系统，它以看起来像文件和目录的形式提供了一个访问内核数据结构的接口。这提供了一种便捷的机制来查看和更改各种系统属性。此外，一组以 `/proc/`*PID* 形式命名的目录，其中 *PID* 是进程 ID，使我们可以查看系统上每个正在运行的进程的相关信息。

`/proc` 文件的内容通常是人类可读的文本形式，并且可以被 shell 脚本解析。程序可以简单地打开并从中读取，或写入所需的文件。在大多数情况下，进程必须具有特权才能修改 `/proc` 目录中文件的内容。

当我们描述 Linux 编程接口的各个部分时，我们也会描述相关的 `/proc` 文件。`/proc` 文件系统 提供了有关该文件系统的更多一般信息。`/proc` 文件系统没有由任何标准指定，本文描述的细节是 Linux 特有的。

## 总结

在本章中，我们回顾了一些与 Linux 系统编程相关的基本概念。理解这些概念应该能为读者提供足够的背景，使那些对 Linux 或 UNIX 经验有限的读者能够开始学习系统编程。
