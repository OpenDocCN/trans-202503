## 第五十一章：POSIX IPC 简介

POSIX.1b 实时扩展定义了一组类似于 System V IPC 机制的 IPC 机制，这些机制在第四十五章到第四十八章中描述。（POSIX.1b 的开发者之一的目标是设计一组不具备 System V IPC 设施缺陷的 IPC 机制。）这些 IPC 机制统称为 POSIX IPC。三种 POSIX IPC 机制如下：

+   *消息队列*可用于在进程之间传递消息。与 System V 消息队列一样，消息边界会被保留，从而读写操作是按消息单元进行通信的（与管道提供的没有边界的字节流不同）。POSIX 消息队列允许为每条消息分配优先级，这使得高优先级消息可以排在低优先级消息之前。这样提供了与 System V 消息中的类型字段相同的一些功能。

+   *信号量*允许多个进程同步它们的操作。与 System V 信号量类似，POSIX 信号量是一个由内核维护的整数，其值永远不允许低于 0。POSIX 信号量比 System V 信号量更易于使用：它们是单独分配的（与 System V 信号量*集合*不同），并且使用两个操作单独操作，每次操作都将信号量的值增加或减少 1（与*semop()*系统调用可以原子性地从 System V 信号量集合中的多个信号量添加或减少任意值不同）。

+   *共享内存*使多个进程能够共享同一内存区域。与 System V 共享内存类似，POSIX 共享内存提供了快速的 IPC。一旦一个进程更新了共享内存，其他共享相同内存区域的进程可以立即看到变化。

本章概述了 POSIX IPC 设施，重点介绍它们的共同特征。

## API 概述

这三种 POSIX IPC 机制具有许多共同特征。表 51-1 总结了它们的 API，我们将在接下来的几页中详细介绍它们的共同特征。

### 注意

除了在表 51-1 中提到之外，在本章的其余部分，我们将忽略 POSIX 信号量有两种类型的事实：命名信号量和未命名信号量。命名信号量就像本章中描述的其他 POSIX IPC 机制：它们通过名称来标识，并且任何拥有适当权限的进程都可以访问该对象。未命名信号量没有相关的标识符；相反，它被放置在一个由一组进程或单一进程的线程共享的内存区域中。我们将在第五十三章中详细介绍这两种类型的信号量。

表 51-1。POSIX IPC 对象的编程接口汇总

| 接口 | 消息队列 | 信号量 | 共享内存 |
| --- | --- | --- | --- |
| 头文件 | `<mqueue.h>` | `<semaphore.h>` | `<sys/mman.h>` |
| 对象句柄 | *mqd_t* | *sem_t** | *int*（文件描述符） |
| 创建/打开 | *mq_open()* | *sem_open()* | *shm_open()* + *mmap()* |
| 关闭 | *mq_close()* | *sem_close()* | *munmap()* |
| 删除 | *mq_unlink()* | *sem_unlink()* | *shm_unlink()* |
| 执行 IPC | *mq_send()*, *mq_receive()* | *sem_post(), sem_wait()*, *sem_getvalue()* | 在共享区域的位置上操作 |
| 其他操作 | *mq_setattr()*—设置属性 *mq_getattr()*—获取属性 *mq_notify()*—请求通知 | *sem_init()*—初始化未命名信号量 *sem_destroy()*—销毁未命名信号量 | （无） |

#### IPC 对象名称

要访问一个 POSIX IPC 对象，我们必须有某种方式来标识它。SUSv3 指定的唯一可移植方法是通过名称来标识 POSIX IPC 对象，该名称由一个初始的斜杠（/）组成，后跟一个或多个非斜杠字符；例如，`/myobject`。Linux 和其他一些实现（例如 Solaris）允许这种可移植的 IPC 对象命名方式。

在 Linux 上，POSIX 共享内存和消息队列对象的名称限制为`NAME_MAX`（255）个字符。对于信号量，限制少了 4 个字符，因为实现会在信号量名称前加上*sem*字符串。

SUSv3 并不禁止使用 `/myobject` 以外的形式的名称，但它指出这种名称的语义是实现定义的。在某些系统上，创建 IPC 对象名称的规则有所不同。例如，在 Tru64 5.1 上，IPC 对象名称作为标准文件系统中的名称创建，且名称被解释为绝对路径或相对路径。如果调用者没有权限在该目录中创建文件，则 IPC *open* 调用失败。这意味着在 Tru64 上，未经授权的程序无法创建 `/myobject` 形式的名称，因为未经授权的用户通常无法在根目录（`/`）中创建文件。其他一些实现也有类似的实现特定规则来构造给定 IPC *open* 调用的名称。因此，在可移植的应用程序中，我们应该将 IPC 对象名称的生成隔离到一个单独的函数或头文件中，以便根据目标实现进行定制。

#### 创建或打开 IPC 对象

每个 IPC 机制都有一个关联的 *open* 调用（*mq_open()*、*sem_open()* 或 *shm_open()*），它类似于用于文件的传统 UNIX *open()* 系统调用。给定一个 IPC 对象名称，IPC *open* 调用要么：

+   创建一个具有指定名称的新对象，打开该对象，并返回一个句柄；或者

+   打开现有对象并返回该对象的句柄。

IPC *open* 调用返回的句柄类似于传统 *open()* 系统调用返回的文件描述符——它在后续调用中用于引用该对象。

IPC *open* 调用返回的句柄类型取决于对象的类型。对于消息队列，它是一个消息队列描述符，类型为 *mqd_t*。对于信号量，它是类型为 *sem_t ** 的指针。对于共享内存，它是一个文件描述符。

所有 IPC *open* 调用至少允许三个参数——*name*、*oflag* 和 *mode*——如下所示的 *shm_open()* 调用为例：

```
fd = shm_open("/mymem", O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
```

这些参数类似于传统 UNIX *open()* 系统调用的参数。*name* 参数标识要创建或打开的对象。*oflag* 参数是一个位掩码，至少可以包含以下标志：

`O_CREAT`

如果对象尚不存在，则创建该对象。如果未指定此标志且对象不存在，则会导致错误（`ENOENT`）。

`O_EXCL`

如果同时指定了 `O_CREAT` 且对象已存在，则会导致错误（`EEXIST`）。这两步——检查是否存在和创建——是原子性的（原子性与竞争条件）。如果未指定 `O_CREAT`，此标志将不起作用。

根据对象的类型，*oflag* 可能还包括 `O_RDONLY`、`O_WRONLY` 或 `O_RDWR` 之一，其含义类似于 *open()*。某些 IPC 机制还允许额外的标志。

剩余的参数，*mode*，是一个位掩码，指定在调用创建新对象时要赋予该对象的权限（即，指定了`O_CREAT`且该对象尚不存在）。*mode*可以指定的值与文件相同（表 15-4，见常规文件的权限）。与*open()*系统调用一样，*mode*中的权限掩码会与进程的 umask 进行掩码运算（进程文件模式创建掩码：*umask()*")）。新 IPC 对象的所有权和组所有权取决于执行 IPC *open*调用的进程的有效用户和组 ID。（严格来说，在 Linux 上，新 POSIX IPC 对象的所有权是由进程的文件系统 ID 决定的，这通常与相应的有效 ID 相同。请参见第 9.5 节。）

### 注意

在 IPC 对象出现在标准文件系统中的系统上，SUSv3 允许实现将新 IPC 对象的组 ID 设置为父目录的组 ID。

#### 关闭 IPC 对象

对于 POSIX 消息队列和信号量，有一个 IPC *close*调用，表示调用进程已完成使用该对象，系统可以释放与该对象相关的任何资源。POSIX 共享内存对象通过使用*munmap()*取消映射来关闭。

如果进程终止或执行*exec()*，IPC 对象会自动关闭。

#### IPC 对象权限

IPC 对象具有与文件相同的权限掩码。访问 IPC 对象的权限与访问文件的权限类似（权限检查算法），不同之处在于执行权限对于 POSIX IPC 对象没有意义。

从内核版本 2.6.19 起，Linux 支持使用访问控制列表（ACL）来设置 POSIX 共享内存对象和命名信号量的权限。目前，POSIX 消息队列不支持 ACL。

#### IPC 对象删除和对象持久化

与打开的文件类似，POSIX IPC 对象是*引用计数*的——内核维护着对该对象的打开引用计数。与 System V IPC 对象相比，这使得应用程序更容易判断何时可以安全地删除该对象。

每个 IPC 对象都有一个相应的 *unlink* 调用，其操作类似于传统的 *unlink()* 系统调用，用于删除文件。*unlink* 调用立即删除对象的名称，然后在所有进程停止使用该对象后销毁该对象（即当引用计数降为零时）。对于消息队列和信号量，这意味着在所有进程关闭对象后，才销毁该对象；对于共享内存，销毁发生在所有进程使用 *munmap()* 取消映射该对象之后。

在对象被解除链接后，指定相同对象名称的 IPC *open* 调用将引用一个新对象（如果没有指定 `O_CREAT`，则调用会失败）。

与 System V IPC 一样，POSIX IPC 对象具有内核持久性。一旦创建，对象将一直存在，直到它被解除链接或系统关闭。这允许一个进程创建一个对象，修改其状态，然后退出，留下该对象供稍后启动的进程访问。

#### 通过命令行列出和删除 POSIX IPC 对象

System V IPC 提供了两个命令，*ipcs* 和 *ipcrm*，用于列出和删除 IPC 对象。没有标准命令用于执行类似的任务来操作 POSIX IPC 对象。然而，在许多系统上，包括 Linux，IPC 对象是通过真实或虚拟文件系统实现的，通常挂载在根目录 (`/`) 下的某个位置，并且可以使用标准的 *ls* 和 *rm* 命令来列出和删除 IPC 对象。（SUSv3 并未指定使用 *ls* 和 *rm* 来执行这些任务。）使用这些命令的主要问题是 POSIX IPC 对象名称的非标准性质以及它们在文件系统中的位置。

在 Linux 上，POSIX IPC 对象包含在虚拟文件系统中，这些文件系统挂载在设置了粘滞位的目录下。粘滞位是限制删除标志（Set-User-ID, Set-Group-ID 和 Sticky 位）；设置此标志意味着一个没有特权的进程只能解除链接它拥有的 POSIX IPC 对象。

#### 在 Linux 上编译使用 POSIX IPC 的程序

在 Linux 上，使用 POSIX IPC 机制的程序必须链接 *realtime* 库 *librt*，通过在 *cc* 命令中指定 *-lrt* 选项。

## System V IPC 和 POSIX IPC 的比较

在接下来的章节中，我们将查看 POSIX IPC 机制，并将每个机制与其 System V 对应机制进行比较。在这里，我们考虑这两种 IPC 类型的一些一般比较。

与 System V IPC 相比，POSIX IPC 具有以下一般优势：

+   POSIX IPC 接口比 System V IPC 接口更简单。

+   POSIX IPC 模型——使用名称而不是键，以及 *open*、*close* 和 *unlink* 函数——与传统的 UNIX 文件模型更加一致。

+   POSIX IPC 对象是通过引用计数进行管理的。这简化了对象的删除过程，因为我们可以解除链接 POSIX IPC 对象，并知道它仅在所有进程都关闭它之后才会被销毁。

然而，System V IPC 有一个显著的优势：可移植性。与 System V IPC 相比，POSIX IPC 在以下几个方面的可移植性较差：

+   System V IPC 在 SUSv3 中有明确规定，并在几乎所有 UNIX 实现中得到支持。相比之下，POSIX IPC 机制在 SUSv3 中是一个可选组件。一些 UNIX 实现不支持（所有）POSIX IPC 机制。这种情况在 Linux 上得到了缩影：POSIX 共享内存在内核 2.4 版本才开始支持；POSIX 信号量的完整实现从内核 2.6 版本开始才可用；POSIX 消息队列则从内核 2.6.6 版本开始支持。

+   尽管 SUSv3 规定了 POSIX IPC 对象名称，但各个实现对于命名 IPC 对象遵循不同的约定。这些差异要求我们做一些额外的工作，以编写可移植的应用程序。

+   POSIX IPC 的各个细节在 SUSv3 中并未具体规定。特别是，未规定用于显示和删除系统中存在的 IPC 对象的命令。（在许多实现中，使用标准的文件系统命令，但用于标识 IPC 对象的路径名细节有所不同。）

## 总结

POSIX IPC 是 POSIX.1b 提出的三种 IPC 机制——消息队列、信号量和共享内存——的总称，作为 System V IPC 机制的替代方案。

POSIX IPC 接口与传统 UNIX 文件模型更加一致。IPC 对象通过名称进行标识，并通过类似于与文件相关的系统调用的 *open*、*close* 和 *unlink* 调用进行管理。

POSIX IPC 提供了一个在许多方面优于 System V IPC 接口的接口。然而，POSIX IPC 在某些方面的可移植性稍逊于 System V IPC。
