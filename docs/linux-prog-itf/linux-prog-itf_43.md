## 第四十三章。进程间通信概述

本章简要介绍了进程和线程可以用来相互通信和同步其动作的设施。后续章节将提供关于这些设施的更多细节。

## IPC 设施的分类

图 43-1 总结了 UNIX 通信和同步设施的丰富多样性，将它们分为三个广泛的功能类别：

+   *通信*：这些设施用于进程间的数据交换。

+   *同步*：这些设施用于同步进程或线程的动作。

+   *信号*：尽管信号主要用于其他目的，但在某些情况下，它们可以作为同步技术使用。更少见的是，信号可以作为通信技术使用：信号编号本身就是一种信息形式，实时信号可以附带相关数据（整数或指针）。信号的详细描述见第二十章至第二十二章。

尽管其中一些设施涉及同步，但通常使用通用术语*进程间通信*（IPC）来描述所有这些设施。

![UNIX IPC 设施的分类](img/43-1_IPC-taxonomy.png.jpg)图 43-1. UNIX IPC 设施的分类

如图 43-1 所示，通常多个设施提供类似的 IPC 功能。出现这种情况有几个原因：

+   相似的设施在不同的 UNIX 变种中发展起来，并随后被移植到其他 UNIX 系统中。例如，FIFO 最早在 System V 上开发，而（流）套接字则是在 BSD 上开发的。

+   为了解决早期相似设施的设计缺陷，开发了新的设施。例如，POSIX IPC 设施（消息队列、信号量和共享内存）作为对较老的 System V IPC 设施的改进而设计。

在某些情况下，图 43-1 中归为一类的设施实际上提供了显著不同的功能。例如，流套接字可以用于通过网络进行通信，而 FIFO 仅用于在同一台机器上的进程之间进行通信。

## 通信设施

如图 43-1 所示，各种通信设施允许进程之间交换数据。（这些设施也可以用于单个进程的线程之间交换数据，但通常不需要，因为线程可以通过共享全局变量交换信息。）

我们可以将通信设施分为两类：

+   *数据传输设施*：区分这些设施的关键因素是写入和读取的概念。为了进行通信，一个进程将数据写入 IPC 设施，另一个进程读取该数据。这些设施需要在用户内存和内核内存之间进行两次数据传输：一次是写入时从用户内存到内核内存的传输，另一次是读取时从内核内存到用户内存的传输。（图 43-2 展示了管道的这种情况。）

+   *共享内存*：共享内存允许进程通过将数据放置在进程间共享的内存区域来交换信息。（内核通过使每个进程的页面表条目指向相同的 RAM 页面来实现这一点，如图 49-2 所示，参见内存映射 I/O）。进程可以通过将数据放入共享内存区域，使数据对其他进程可用。由于通信不需要系统调用或在用户内存和内核内存之间传输数据，因此共享内存可以提供非常快速的通信。

![使用管道在两个进程之间交换数据](img/43-2_IPC-pipe-scale90.png.jpg)图 43-2. 使用管道在两个进程之间交换数据

#### 数据传输

我们可以进一步将数据传输设施分为以下子类别：

+   *字节流*：通过管道、FIFO 和数据报套接字交换的数据是一个未定界的字节流。每次读取操作可以从 IPC 设施读取任意数量的字节，而不管写入进程写入的块大小。这种模型反映了传统 UNIX 中“文件作为字节序列”的模型。

+   *消息*：通过 System V 消息队列、POSIX 消息队列和数据报套接字交换的数据以定界消息的形式存在。每个读取操作读取一个完整的消息，正如写入进程所写。无法读取消息的一部分并将剩余部分留在 IPC 设施中；也不能在一次读取操作中读取多个消息。

+   *伪终端*：伪终端是一种通信设施，主要用于特殊情况。我们在第六十四章中提供了详细信息。

几个通用特性将数据传输设施与共享内存区分开：

+   尽管数据传输设施可能有多个读取器，但读取是破坏性的。读取操作会消耗数据，而该数据不再对其他进程可用。

    ### 注意

    `MSG_PEEK`标志可用于执行非破坏性读取操作（特定于套接字的 I/O 系统调用：*recv()*和*send()*和 send()")）。UDP（互联网域数据报）套接字允许将单个消息广播或多播到多个接收方（TCP 与 UDP）。

+   读者和写者进程之间的同步是自动进行的。如果读者试图从当前没有数据的数据传输设施中读取数据，则（默认情况下）读取操作会阻塞，直到某个进程向该设施写入数据。

#### 共享内存

大多数现代 UNIX 系统提供三种共享内存形式：System V 共享内存、POSIX 共享内存和内存映射。在后续章节中，我们会在描述这些设施时考虑它们之间的差异（特别请参见共享内存 API 的比较）。

请注意关于共享内存的以下几点：

+   尽管共享内存提供了快速通信，但这种速度优势受到同步共享内存操作需求的制约。例如，当一个进程正在更新共享内存中的数据结构时，另一个进程不应尝试访问它。信号量是与共享内存一起使用的常见同步方法。

+   放置在共享内存中的数据对所有共享该内存的进程可见。（这与上文所述的数据传输设施中的破坏性读取语义相对。）

## 同步设施

在图 43-1 中所示的同步设施允许进程协调它们的操作。同步使得进程能够避免同时更新共享内存区域或文件的相同部分。如果没有同步，这种同时更新可能会导致应用程序产生错误的结果。

UNIX 系统提供以下同步设施：

+   *信号量*：信号量是由内核维护的整数，其值永远不能低于 0。进程可以减少或增加信号量的值。如果尝试将信号量的值减少到 0 以下，内核会阻塞该操作，直到信号量的值增加到允许操作执行的水平。（或者，进程可以请求一个非阻塞操作；此时，内核会立即返回错误，表示该操作无法立即执行。）信号量的含义由应用程序决定。进程通过递减信号量（比如从 1 变为 0）来预定对某个共享资源的独占访问，完成对资源的操作后，再增加信号量，以便释放该共享资源供其他进程使用。二进制信号量——其值限制为 0 或 1——的使用非常普遍。然而，处理多个实例的共享资源的应用程序会使用一个最大值等于共享资源数量的信号量。Linux 提供了 System V 信号量和 POSIX 信号量，它们在功能上基本相同。

+   *文件锁*：文件锁是一种专门设计用来协调多个进程在同一文件上操作的同步方法。它们也可以用于协调对其他共享资源的访问。文件锁有两种类型：读锁（共享锁）和写锁（独占锁）。任何数量的进程都可以对同一文件（或文件的某一部分）持有读锁。然而，当一个进程持有文件（或文件区域）的写锁时，其他进程将无法在该文件（或文件区域）上持有任何读锁或写锁。Linux 通过 *flock()* 和 *fcntl()* 系统调用提供文件锁定功能。*flock()* 系统调用提供了一种简单的锁机制，允许进程对整个文件进行共享或独占锁定。由于其功能有限，*flock()* 锁定机制如今很少使用。*fcntl()* 系统调用提供了记录锁定，允许进程在同一文件的不同区域上放置多个读锁和写锁。

+   *互斥量和条件变量*：这些同步设施通常与 POSIX 线程一起使用，如第三十章中所述。

### 注意

一些 UNIX 实现，包括提供 NPTL 线程实现的 Linux 系统，允许互斥量和条件变量在进程之间共享。SUSv3 允许但不强制要求实现支持进程共享的互斥量和条件变量。它们并非在所有 UNIX 系统上都可用，因此不常用于进程同步。

在进行进程间同步时，我们通常根据功能需求来选择设施。在协调对文件的访问时，文件记录锁定通常是最佳选择。而对于协调访问其他类型共享资源，信号量通常是更好的选择。

通信设施也可以用于同步。例如，在管道作为进程同步方法中，我们展示了如何使用管道同步父进程与其子进程的操作。更一般而言，任何数据传输设施都可以用于同步，同步操作以通过该设施交换消息的形式进行。

### 注

自 Linux 内核 2.6.22 版本起，Linux 提供了一种额外的、非标准的同步机制，通过 *eventfd()* 系统调用实现。该系统调用创建了一个 *eventfd* 对象，内核维护着一个与之关联的 8 字节无符号整数。系统调用返回一个文件描述符，指向该对象。向该文件描述符写入整数会将该整数添加到对象的值中。若对文件描述符进行 *read()* 操作且对象的值为 0，则该操作会阻塞。如果对象的值非零，*read()* 操作会返回该值并将其重置为 0。此外，可以使用 *poll()*、*select()* 或 *epoll* 来测试对象是否有非零值；如果有，文件描述符将被标记为可读。希望使用 *eventfd* 对象进行同步的应用程序，必须首先使用 *eventfd()* 创建该对象，然后调用 *fork()* 来创建相关的进程，这些进程会继承指向该对象的文件描述符。有关更多详细信息，请参见 *eventfd(2)* 手册页。

## 比较 IPC 设施

当谈到 IPC 时，我们会面临一系列的选择，初看起来可能让人感到困惑。在后续章节中，我们将描述每种 IPC 设施，并对每种设施与其他类似设施进行比较。在接下来的页面中，我们会考虑一些可能决定选择哪种 IPC 设施的通用因素。

#### IPC 对象标识符与打开对象的句柄

为了访问 IPC 对象，进程必须具备某种标识对象的方式，并且一旦对象被“打开”，进程必须使用某种类型的句柄来引用已打开的对象。表 43-1 总结了不同类型 IPC 设施的这些属性。

表 43-1. 各种类型 IPC 设施的标识符和句柄

| 设施类型 | 用于标识对象的名称 | 用于在程序中引用对象的句柄 |
| --- | --- | --- |
| 管道 | 无名称 | 文件描述符 |
| FIFO | 路径名 | 文件描述符 |
| UNIX 域套接字 | 路径名 | 文件描述符 |
| 网络域套接字 | IP 地址 + 端口号 | 文件描述符 |
| System V 消息队列 | System V IPC 键值 | System V IPC 标识符 |
| System V 信号量 | System V IPC 键值 | System V IPC 标识符 |
| System V 共享内存 | System V IPC 键值 | System V IPC 标识符 |
| POSIX 消息队列 | POSIX IPC 文件路径名 | *mqd_t*（消息队列描述符） |
| POSIX 命名信号量 | POSIX IPC 文件路径名 | *sem_t **（信号量指针） |
| POSIX 无名信号量 | 无名称 | *sem_t **（信号量指针） |
| POSIX 共享内存 | POSIX IPC 文件路径名 | 文件描述符 |
| 匿名映射 | 无名称 | 无 |
| 内存映射文件 | 文件路径名 | 文件描述符 |
| *flock()* 锁 | 文件路径名 | 文件描述符 |
| *fcntl()* 锁 | 文件路径名 | 文件描述符 |

#### 功能性

各种 IPC 设施之间存在功能差异，这些差异在决定使用哪个设施时可能是相关的。我们首先总结一下数据传输设施和共享内存之间的区别：

+   数据传输设施涉及读写操作，传输的数据只能被一个读取进程消费。写入进程与读取进程之间的流控制，以及同步操作（确保在数据设施为空时，读取进程会被阻塞），由内核自动处理。该模型非常适合许多应用程序设计。

+   其他应用程序设计更自然地适应共享内存模型。共享内存允许一个进程将数据对任何共享同一内存区域的其他进程可见。通信“操作”非常简单——进程可以像访问其虚拟地址空间中的任何其他内存一样访问共享内存中的数据。另一方面，处理同步（以及可能的流控制）可能会增加共享内存设计的复杂性。该模型非常适合需要维持共享状态的应用程序设计（例如，共享数据结构）。

关于各种数据传输设施，以下几点值得注意：

+   一些数据传输设施将数据作为字节流传输（管道、FIFO 和流套接字）；而其他设施则是面向消息的（消息队列和数据报套接字）。哪种方法更可取取决于具体应用。（应用程序还可以通过使用分隔符字符、固定长度的消息或编码了消息总长度的消息头，将字节流设施转换为面向消息的模型；详见第 44.8 节。）

+   与其他数据传输设施相比，System V 和 POSIX 消息队列的一个显著特点是能够为消息分配一个数值类型或优先级，使得消息可以按照与发送顺序不同的顺序进行传递。

+   管道、FIFO 和套接字是通过文件描述符实现的。这些 IPC 设施都支持一系列替代 I/O 模型，我们在第六十三章中描述了这些模型：I/O 多路复用（*select()* 和 *poll()* 系统调用）、信号驱动 I/O，以及 Linux 特有的 *epoll* API。这些技术的主要优点是，它们允许应用程序同时监控多个文件描述符，以查看是否可以在任何一个上进行 I/O 操作。相比之下，System V 消息队列不使用文件描述符，也不支持这些技术。

### 注意

在 Linux 上，POSIX 消息队列也是通过文件描述符实现的，并支持上述的替代 I/O 技术。然而，这种行为在 SUSv3 中并未指定，并且在大多数其他实现中不受支持。

+   POSIX 消息队列提供了一种通知功能，当一个消息到达一个先前为空的队列时，可以向进程发送信号或实例化一个新的线程。

+   UNIX 域套接字提供了一种功能，允许将文件描述符从一个进程传递到另一个进程。这允许一个进程打开一个文件，并将其提供给另一个可能无法访问该文件的进程。我们在传递文件描述符中简要描述了这个功能。

+   UDP（互联网域数据报）套接字允许发送方将消息广播或多播到多个接收者。我们在 TCP 与 UDP 中简要描述了这个功能。

关于进程同步设施，以下几点值得注意：

+   使用 *fcntl()* 设置的记录锁被认为是由设置锁的进程拥有的。内核利用这一所有权属性来检测死锁（即两个或多个进程持有相互阻塞的锁，导致无法继续请求锁的情况）。如果发生死锁，内核会拒绝其中一个进程的锁请求，并从 *fcntl()* 调用返回错误，表明发生了死锁。System V 和 POSIX 信号量没有所有权属性，因此不会对信号量进行死锁检测。

+   使用 *fcntl()* 设置的记录锁在拥有锁的进程终止时会自动释放。System V 信号量提供了类似的功能，即“撤销”功能，但在某些情况下此功能并不可靠（信号量撤销值）。POSIX 信号量没有类似的功能。

#### 网络通信

在图 43-1 中显示的所有 IPC 方法中，只有套接字允许进程通过网络进行通信。套接字通常用于两个领域之一：UNIX 域，它允许同一系统中的进程之间进行通信；和*Internet* 域，它允许通过 TCP/IP 网络连接的不同主机上的进程之间进行通信。通常，只需要进行少量修改，就可以将使用 UNIX 域套接字的程序转换为使用 Internet 域套接字的程序，因此，使用 UNIX 域套接字构建的应用程序可以相对轻松地变为支持网络的应用程序。

#### 可移植性

现代 UNIX 实现支持图 43-1 中显示的大多数 IPC 设施。然而，POSIX IPC 设施（消息队列、信号量和共享内存）并不像 System V IPC 设施那样广泛可用，特别是在较旧的 UNIX 系统上。（POSIX 消息队列的实现和对 POSIX 信号量的完全支持仅在 Linux 2.6.*x* 内核系列中出现。）因此，从可移植性的角度来看，System V IPC 可能比 POSIX IPC 更可取。

#### System V IPC 设计问题

System V IPC 设施是在传统 UNIX I/O 模型之外独立设计的，因此存在一些特性，使得其编程接口使用起来更加复杂。相应的 POSIX IPC 设施旨在解决这些问题。以下几点尤其值得注意：

+   System V IPC 设施是无连接的。这些设施没有类似于文件描述符的句柄（如文件描述符）来引用一个打开的 IPC 对象。在后面的章节中，我们有时会提到“打开”一个 System V IPC 对象，但这实际上只是描述获取一个句柄来引用该对象的简写。内核并不会记录进程“打开”了该对象（与其他类型的 IPC 对象不同）。这意味着内核无法维护当前正在使用该对象的进程数的引用计数。因此，应用程序可能需要额外的编程工作，才能知道何时可以安全地删除该对象。

+   System V IPC 设施的编程接口与传统的 UNIX I/O 模型不一致（它们使用整数键值和 IPC 标识符，而不是路径名和文件描述符）。这些编程接口也过于复杂。最后一点特别适用于 System V 信号量（参考 System V 信号量的缺点和与其他同步技术的比较）。

相比之下，内核会计算 POSIX IPC 对象的打开引用计数。这简化了何时可以删除对象的决策。此外，POSIX IPC 设施提供的接口更简单，并且与传统的 UNIX 模型更加一致。

#### 可访问性

表 43-2 的第二列总结了每种类型的 IPC 对象的一个重要特性：权限方案，规定了哪些进程可以访问该对象。以下列表增加了关于各种方案的细节：

+   对于一些 IPC 设施（例如 FIFO 和套接字），对象名称存储在文件系统中，且可访问性由关联的文件权限掩码决定，该掩码指定所有者、组和其他的权限（文件权限）。尽管 System V IPC 对象不驻留在文件系统中，但每个对象都有一个相关的权限掩码，其语义与文件的权限掩码类似。

+   一些 IPC 设施（管道、匿名内存映射）被标记为仅由相关进程访问。这里的 *相关* 指通过 *fork()* 相关。为了让两个进程访问该对象，其中一个必须创建该对象并调用 *fork()*。作为 *fork()* 的结果，子进程会继承一个引用该对象的句柄，从而使两个进程可以共享该对象。

+   POSIX 无名信号量的可访问性由包含信号量的共享内存区域的可访问性决定。

+   为了对文件加锁，进程必须拥有指向该文件的文件描述符（即实际上，它必须具有打开文件的权限）。

+   访问（即连接或发送数据报到）网络域套接字没有任何限制。如有必要，访问控制必须在应用程序内部实现。

表 43-2. 各种类型的 IPC 设施的可访问性和持久性

| 设施类型 | 可访问性 | 持久性 |
| --- | --- | --- |
| 管道 | 仅由相关进程访问 | 进程 |
| FIFO | 权限掩码 | 进程 |
| UNIX 域套接字 | 权限掩码 | 进程 |
| 网络域套接字 | 由任何进程访问 | 进程 |
| System V 消息队列 | 权限掩码 | 内核 |
| System V 信号量 | 权限掩码 | 内核 |
| System V 共享内存 | 权限掩码 | 内核 |
| POSIX 消息队列 | 权限掩码 | 内核 |
| POSIX 命名信号量 | 权限掩码 | 内核 |
| POSIX 无名信号量 | 底层内存的权限 | 视情况而定 |
| POSIX 共享内存 | 权限掩码 | 内核 |
| 匿名映射 | 仅由相关进程访问 | 进程 |
| 内存映射文件 | 权限掩码 | 文件系统 |
| *flock()* 文件锁 | *open()* 打开文件 | 进程 |
| *fcntl()* 文件锁 | *open()* 打开文件 | 进程 |

#### 持久性

*持久性*一词指的是 IPC 对象的生命周期。（请参见表 43-2 的第三列。）我们可以区分三种持久性：

+   *进程持久性*：进程持久的 IPC 对象仅在至少一个进程保持它打开时存在。如果所有进程都关闭该对象，那么与该对象相关的所有内核资源都会被释放，任何未读的数据也会被销毁。管道、FIFO 和套接字是具有进程持久性的 IPC 设施的例子。

    ### 注意

    FIFO 的数据持久性与其名称的持久性不同。FIFO 在文件系统中有一个名称，即使所有引用该 FIFO 的文件描述符都被关闭后，名称仍然会存在。

+   *内核持久性*：内核持久的 IPC 对象会一直存在，直到它被显式删除或系统关闭。该对象的生命周期与是否有进程保持该对象打开无关。这意味着，例如，一个进程可以创建一个对象，将数据写入其中，然后关闭它（或终止）。稍后，另一个进程可以打开该对象并读取数据。具有内核持久性的设施示例有 System V IPC 和 POSIX IPC。我们在后面的章节中描述这些设施时，会利用这一特性，展示示例程序：对于每个设施，我们会实现单独的程序来创建对象、删除对象并执行通信或同步。

+   *文件系统持久性*：具有文件系统持久性的 IPC 对象即使在系统重启后也能保留其信息。该对象会一直存在，直到它被显式删除。唯一展示文件系统持久性的 IPC 对象是基于内存映射文件的共享内存。

#### 性能

在某些情况下，不同的 IPC 设施可能会表现出显著的性能差异。然而，在后面的章节中，我们通常避免进行性能比较，原因如下：

+   IPC 设施的性能可能在整个应用程序的性能中并不是一个显著因素，也可能不是决定选择 IPC 设施的唯一因素。

+   各种 IPC 设施的相对性能可能在不同的 UNIX 实现中，或者在不同版本的 Linux 内核中有所不同。

+   最重要的是，IPC 设施的性能会根据其使用的具体方式和环境而有所不同。相关因素包括每次 IPC 操作中交换的数据单元的大小、可能存在的未读数据量、是否需要为每个交换的数据单元进行进程上下文切换，以及系统的其他负载。

如果 IPC 性能至关重要，那么没有什么能够替代在与目标系统匹配的环境中运行的特定应用基准测试。为此，可能值得编写一个抽象的软件层，将 IPC 设施的细节从应用程序中隐藏起来，然后在抽象层下替换不同的 IPC 设施并测试性能。

## 总结

本章概述了进程（和线程）可以用来相互通信和同步其操作的各种设施。

Linux 提供的通信设施包括管道（pipes）、命名管道（FIFOs）、套接字（sockets）、消息队列（message queues）和共享内存（shared memory）。Linux 提供的同步设施包括信号量（semaphores）和文件锁（file locks）。

在许多情况下，在执行特定任务时，我们可以选择几种可能的通信和同步技术。在本章中，我们以不同方式比较了这些技术，目的是突出一些可能影响选择某一技术而非其他技术的差异。

在接下来的章节中，我们将更详细地讨论每个通信和同步设施。

## 练习

1.  编写一个程序，测量管道提供的带宽。作为命令行参数，程序应接受要发送的数据块数量和每个数据块的大小。在创建管道后，程序会分为两个进程：一个子进程以尽可能快的速度将数据块写入管道，父进程则读取数据块。在所有数据读取完毕后，父进程应打印所需的时间和带宽（每秒传输的字节数）。测试不同数据块大小的带宽。

1.  对 System V 消息队列、POSIX 消息队列、UNIX 域流套接字（UNIX domain stream sockets）和 UNIX 域数据报套接字（UNIX domain datagram sockets）重复前面的练习。使用这些程序比较 Linux 上各种 IPC 设施的相对性能。如果你可以访问其他 UNIX 实现，尝试在这些系统上做相同的比较。
