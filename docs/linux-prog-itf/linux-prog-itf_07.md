## 第七章. 内存分配

许多系统程序需要能够为动态数据结构（例如，链表和二叉树）分配额外的内存，这些数据结构的大小取决于仅在运行时才能获得的信息。本章描述了用于在堆或栈上分配内存的函数。

## 堆上分配内存

进程可以通过增加堆的大小来分配内存，堆是一个变动大小的连续虚拟内存段，开始于进程的未初始化数据段之后，并随着内存的分配和释放而增大或缩小（请参见图 6-1，以及虚拟内存管理）。堆的当前限制被称为 *程序断点*。

在 C 程序中，通常使用 *malloc* 系列函数来分配内存，我们将在稍后描述这些函数。然而，我们首先介绍 *brk()* 和 *sbrk()* 函数，它们是 *malloc* 函数的基础。

### 调整程序断点：*brk()* 和 *sbrk()*

调整堆的大小（即分配或释放内存）实际上就像告诉内核调整它对进程程序断点位置的理解一样简单。最初，程序断点位于未初始化数据段的末尾之后（即与 *&end* 相同的位置，如图 6-1 所示）。

在程序断点增加后，程序可以访问新分配区域中的任何地址，但此时尚未分配任何物理内存页。当进程首次访问这些页中的地址时，内核会自动分配新的物理内存页。

传统上，UNIX 系统提供了两个用于操作程序断点的系统调用，这两个系统调用在 Linux 上都可用：*brk()* 和 *sbrk()*。尽管这些系统调用在程序中很少直接使用，但理解它们有助于澄清内存分配的工作原理。

```
#define _BSD_SOURCE             /* Or: #define _SVID_SOURCE */
#include <unistd.h>

int `brk`(void **end_data_segment*);
```

### 注意

成功时返回 0，出错时返回 -1

```
void *`sbrk`(intptr_t *`increment`*);
```

### 注意

成功时返回先前的程序断点，出错时返回 *(void *)* -1

*brk()* 系统调用将程序断点设置为 *end_data_segment* 指定的位置。由于虚拟内存是按页分配的，*end_data_segment* 会有效地向上舍入到下一个页边界。

尝试将程序断点设置到其初始值以下（即低于*&end*）可能会导致意外行为，例如当尝试访问现已不存在的初始化或未初始化的数据段时发生段错误（`SIGSEGV`信号，参见信号类型和默认行为）。程序断点可以设置的精确上限取决于多个因素，包括：数据段大小的进程资源限制（`RLIMIT_DATA`，参见特定资源限制的详细信息）；以及内存映射、共享内存段和共享库的位置。

调用*sbrk()*通过将*increment*加到程序断点上来调整程序断点。（在 Linux 中，*sbrk()*是建立在*brk()*基础上的库函数。）用于声明*increment*的*intptr_t*类型是一种整数数据类型。成功时，*sbrk()*返回程序断点的先前地址。换句话说，如果我们增加了程序断点，返回值指向新分配内存块的起始位置。

调用*sbrk(0)*返回当前程序断点的设置，而不会改变它。如果我们想跟踪堆的大小，可能会用到这个功能，譬如为了监控内存分配包的行为。

### 注意

SUSv2 规定了*brk()*和*sbrk()*（并将它们标记为遗留功能）。SUSv3 取消了它们的规范。

### 在堆上分配内存：*malloc()*和*free()*

通常，C 程序使用*malloc*系列函数在堆上分配和释放内存。这些函数相对于*brk()*和*sbrk()*具有几个优势，特别是：

+   作为 C 语言的一部分进行了标准化；

+   在多线程程序中使用更加简便；

+   提供了一个简单的接口，允许以小单位分配内存；

+   允许我们任意地释放内存块，这些内存块会被保存在空闲列表中，并在未来的内存分配调用中被回收。

*malloc()*函数从堆中分配*size*字节，并返回指向新分配内存块起始位置的指针。分配的内存未初始化。

```
#include <stdlib.h>

void *`malloc`(size_t *size*);
```

### 注意

成功时返回指向分配内存的指针，出错时返回`NULL`

由于*malloc()*返回*void **，我们可以将其赋值给任何类型的 C 指针。*malloc()*返回的内存块总是按照适合任何 C 数据结构的字节对齐方式进行分配。实际上，这意味着它在大多数架构上会以 8 字节或 16 字节对齐进行分配。

### 注意

SUSv3 规定，调用*malloc(0)*可能返回`NULL`或指向一小块内存的指针，该内存可以（并且应该）通过*free()*释放。在 Linux 中，*malloc(0)*遵循后者的行为。

如果内存无法分配（可能是因为我们达到了程序 break 可以提升的限制），那么 *malloc()* 会返回 `NULL` 并将 *errno* 设置为指示错误的值。尽管分配内存失败的可能性较小，但所有对 *malloc()* 的调用，以及我们稍后描述的相关函数，都应该检查此错误返回。

*free()* 函数会释放其 *ptr* 参数所指向的内存块，*ptr* 应该是先前由 *malloc()* 或我们稍后在本章中描述的其他堆内存分配函数返回的地址。

```
#include <stdlib.h>

void `free`(void **ptr*);
```

通常情况下，*free()* 并不会降低程序 break，而是将内存块添加到一个空闲块列表中，这些空闲块会被后续调用 *malloc()* 时回收。这样做有几个原因：

+   被释放的内存块通常位于堆的中间位置，而不是堆的末端，因此无法降低程序 break。

+   它最小化了程序必须执行的 *sbrk()* 调用次数。（如 系统调用 中所述，系统调用有一个小但重要的开销。）

+   在许多情况下，降低 break 并不会帮助那些分配大量内存的程序，因为这些程序通常倾向于保持已分配的内存，或者反复释放和重新分配内存，而不是释放所有内存后继续长时间运行。

如果传递给 *free()* 的参数是 `NULL` 指针，则该调用什么也不做。（换句话说，传递 `NULL` 指针给 *free()* 并不是错误。）

在调用 *free()* 后再使用 *ptr*——例如，第二次将其传递给 *free()*——是一个错误，可能导致不可预测的结果。

#### 示例程序

示例 7-1 中的程序可用于说明 *free()* 对程序 break 的影响。该程序分配多个内存块，然后根据其（可选的）命令行参数，释放其中一些或全部内存块。

前两个命令行参数指定了要分配的块的数量和大小。第三个命令行参数指定了在释放内存块时使用的循环步长单位。如果我们在此处指定 1（如果省略此参数，则默认为 1），则程序会释放每一个内存块；如果指定 2，则释放每第二个分配的块，以此类推。第四个和第五个命令行参数指定了我们希望释放的块的范围。如果这些参数被省略，则释放所有已分配的块（按第三个命令行参数给定的步长释放）。

示例 7-1. 演示释放内存时程序 break 会发生什么

```
`memalloc/free_and_sbrk.c`

#include "tlpi_hdr.h"
#define MAX_ALLOCS 1000000

int
main(int argc, char *argv[])
{
    char *ptr[MAX_ALLOCS];
    int freeStep, freeMin, freeMax, blockSize, numAllocs, j;

    printf("\n");

    if (argc < 3 || strcmp(argv[1], "--help") == 0)
        usageErr("%s num-allocs block-size [step [min [max]]]\n", argv[0]);

    numAllocs = getInt(argv[1], GN_GT_0, "num-allocs");
    if (numAllocs > MAX_ALLOCS)
        cmdLineErr("num-allocs > %d\n", MAX_ALLOCS);

    blockSize = getInt(argv[2], GN_GT_0 | GN_ANY_BASE, "block-size");

    freeStep = (argc > 3) ? getInt(argv[3], GN_GT_0, "step") : 1;
    freeMin =  (argc > 4) ? getInt(argv[4], GN_GT_0, "min") : 1;
    freeMax =  (argc > 5) ? getInt(argv[5], GN_GT_0, "max") : numAllocs;

    if (freeMax > numAllocs)
        cmdLineErr("free-max > num-allocs\n");

    printf("Initial program break:          %10p\n", sbrk(0));

    printf("Allocating %d*%d bytes\n", numAllocs, blockSize);
    for (j = 0; j < numAllocs; j++) {
        ptr[j] = malloc(blockSize);

        if (ptr[j] == NULL)
            errExit("malloc");
    }

    printf("Program break is now:           %10p\n", sbrk(0));

    printf("Freeing blocks from %d to %d in steps of %d\n",
                freeMin, freeMax, freeStep);
    for (j = freeMin - 1; j < freeMax; j += freeStep)
        free(ptr[j]);

    printf("After free(), program break is: %10p\n", sbrk(0));

    exit(EXIT_SUCCESS);
}
     `memalloc/free_and_sbrk.c`
```

使用 示例 7-1 运行程序，并使用以下命令行使程序分配 1000 个内存块，然后释放每隔一个块：

```
$ `./free_and_sbrk 1000 10240 2`
```

输出显示，在这些块被释放之后，程序断点保持不变，仍然停留在所有内存块分配时达到的水平：

```
Initial program break:           0x804a6bc
Allocating 1000*10240 bytes
Program break is now:            0x8a13000
Freeing blocks from 1 to 1000 in steps of 2
After free(), program break is:  0x8a13000
```

以下命令行指定除了最后一个分配的块之外，其他所有块都应被释放。再次强调，程序中断点保持在其“最高水位”处。

```
$ `./free_and_sbrk 1000 10240 1 1 999`

Initial program break:           0x804a6bc
Allocating 1000*10240 bytes
Program break is now:            0x8a13000
Freeing blocks from 1 to 999 in steps of 1
After free(), program break is:  0x8a13000
```

然而，如果我们释放堆顶的完整内存块集，我们会看到程序断点从其峰值下降，这表明 *free()* 已使用 *sbrk()* 来降低程序断点。在这里，我们释放最后 500 个分配的内存块：

```
$ `./free_and_sbrk 1000 10240 1 500 1000`

Initial program break:           0x804a6bc
Allocating 1000*10240 bytes
Program break is now:            0x8a13000
Freeing blocks from 500 to 1000 in steps of 1
After free(), program break is:  0x852b000
```

在这种情况下，(*glibc*) *free()* 函数能够识别堆顶整个区域是空闲的，因为在释放块时，它会将相邻的空闲块合并成一个更大的块。（这样做是为了避免在空闲列表中出现大量过小的碎片，而这些碎片可能太小以至于无法满足后续的 *malloc()* 请求。）

### 注意

*glibc free()* 函数只有在堆顶的空闲块“足够”大时，才会调用 *sbrk()* 来降低程序断点，其中“足够”是由控制 *malloc* 包操作的参数决定的（128 kB 是一个典型值）。这减少了必须执行的 *sbrk()* 调用次数（即 *brk()* 系统调用的次数）。

#### 是否应该调用 *free()*？

当一个进程终止时，所有内存都会返回给系统，包括由 *malloc* 包中的函数分配的堆内存。在那些分配内存并在程序终止之前持续使用它的程序中，通常会省略对 *free()* 的调用，依赖这一行为来自动释放内存。这在分配了大量内存块的程序中尤其有用，因为添加多次调用 *free()* 可能会消耗大量 CPU 时间，并且可能会使代码变得复杂。

虽然依赖进程终止来自动释放内存对于许多程序来说是可接受的，但有几个原因表明显式释放所有分配的内存是更理想的做法：

+   显式调用 *free()* 可能使程序在面对未来修改时更具可读性和可维护性。

+   如果我们使用 *malloc* 调试库（如下所述）来查找程序中的内存泄漏，那么任何没有显式释放的内存都会被报告为内存泄漏。这可能会使查找真正的内存泄漏变得更加复杂。

### *malloc()* 和 *free()* 的实现

尽管*malloc()*和*free()*提供的内存分配接口比*brk()*和*sbrk()*更容易使用，但在使用它们时仍然可能会犯各种编程错误。了解*malloc()*和*free()*的实现方式，能够帮助我们理解这些错误的原因，以及如何避免它们。

*malloc()*的实现很简单。它首先扫描之前通过*free()*释放的内存块列表，以找到一个大小大于或等于需求的内存块。（根据实现的不同，扫描时可能采用不同的策略，例如*first-fit*或*best-fit*。）如果该块的大小正好合适，它就会返回给调用者。如果它更大，则会将其拆分，返回一个正确大小的内存块给调用者，并将一个较小的空闲块留在空闲列表上。

如果空闲列表中的所有块都不够大，*malloc()*会调用*sbrk()*来分配更多的内存。为了减少调用*sbrk()*的次数，*malloc()*会以更大的单位增加程序断点（是虚拟内存页面大小的某个倍数），并将多余的内存放入空闲列表中。

看看*free()*的实现，事情变得更有趣了。当*free()*将一个内存块放入空闲列表时，它是如何知道该块的大小的？这是通过一个技巧实现的。当*malloc()*分配内存块时，它会额外分配一些字节来存放一个整数，表示该块的大小。这个整数位于内存块的开头；实际上返回给调用者的地址指向该长度值之后的位置，如图 7-1 返回的内存块")所示。

![malloc()返回的内存块](img/07-1_MEMALLOC-malloc.png.jpg)图 7-1. malloc()返回的内存块

当一个块被放入（双向链表）空闲列表时，*free()*使用该块本身的字节将其添加到列表中，如图 7-2 所示。

![空闲列表中的一个块](img/07-2_MEMALLOC-free-block.png.jpg)图 7-2. 空闲列表中的一个块

随着内存块的不断释放和重新分配，空闲列表中的块会与已分配的、正在使用的内存块混杂在一起，如图 7-3 所示。

![包含已分配块和空闲列表的堆](img/07-3_MEMALLOC-free-list.png.jpg)图 7-3. 包含已分配块和空闲列表的堆

现在考虑到 C 语言允许我们创建指向堆中任意位置的指针，并修改它们指向的位置，包括由*free()*和*malloc()*维护的*长度*、*上一个空闲块*和*下一个空闲块*指针。将这一点加入到之前的描述中，我们就得到了一个相当易燃的组合，容易导致难以察觉的编程错误。例如，如果通过一个错误的指针，我们不小心增加了一个已分配内存块前面的某个长度值，并随后释放该块内存，那么*free()*将会在空闲列表中记录一个错误大小的内存块。接着，*malloc()*可能会重新分配这个内存块，导致程序拥有指向两个已分配内存块的指针，这两个块看似独立，但实际上它们是重叠的。可以绘制出许多其他可能出错的情景。

为了避免这些类型的错误，我们应该遵守以下规则：

+   在分配了一块内存后，我们应该小心不要触碰该块内存范围之外的任何字节。例如，这可能是由于指针运算错误或循环中更新块内容时的越界错误造成的。

+   多次释放同一块已分配的内存是错误的。在 Linux 上使用*glibc*时，我们通常会遇到段错误（`SIGSEGV`信号）。这是好事，因为它提醒我们犯了编程错误。然而，更一般来说，释放同一块内存两次会导致不可预测的行为。

+   我们不应该使用没有通过*malloc*包中的某个函数获得的指针值来调用*free()*。

+   如果我们正在编写一个长时间运行的程序（例如，一个 shell 或一个网络守护进程），该程序会反复为各种用途分配内存，那么我们应该确保在使用完内存后及时释放它。否则，堆将持续增长，直到达到虚拟内存的上限，此时进一步的内存分配将失败。这种情况被称为*内存泄漏*。

#### *malloc*调试工具和库

没有遵循上述规则可能会导致创建出一些晦涩且难以复现的错误。使用*glibc*提供的*malloc*调试工具或专门为此目的设计的多个*malloc*调试库，可以大大简化查找这些错误的任务。

*glibc* 提供的*malloc*调试工具包括以下内容：

+   *mtrace()*和*muntrace()*函数允许程序开启和关闭内存分配调用的追踪。这些函数与`MALLOC_TRACE`环境变量配合使用，该变量应定义为包含追踪信息应写入的文件名。当调用*mtrace()*时，它会检查该文件是否已定义并且能够打开以进行写入；如果可以，那么所有对*malloc*包中函数的调用都会被追踪并记录在该文件中。由于生成的文件不容易被人类阅读，提供了一个脚本——也叫*mtrace*——来分析该文件并生成可读的摘要。出于安全原因，set-user-ID 和 set-group-ID 程序会忽略对*mtrace()*的调用。

+   *mcheck()*和*mprobe()*函数允许程序对分配的内存块执行一致性检查；例如，捕获诸如尝试写入分配的内存块末尾之后位置的错误。这些函数提供的功能在某种程度上与下面描述的*malloc*调试库重叠。使用这些函数的程序必须使用*cc -lmcheck*选项与*mcheck*库链接。

+   `MALLOC_CHECK_`环境变量（注意末尾的下划线）与*mcheck()*和*mprobe()*的作用类似。（这两种技术之间的一个显著区别是，使用`MALLOC_CHECK_`不需要修改和重新编译程序。）通过将此变量设置为不同的整数值，我们可以控制程序如何响应内存分配错误。可能的设置值为：0，表示忽略错误；1，表示在*stderr*上打印诊断错误；2，表示调用*abort()*终止程序。并非所有的内存分配和释放错误都会通过使用`MALLOC_CHECK_`来检测到；它只会发现常见的错误。然而，与使用*malloc*调试库相比，这种技术运行速度快、易于使用，并且具有较低的运行时开销。出于安全原因，set-user-ID 和 set-group-ID 程序会忽略`MALLOC_CHECK_`的设置。

有关上述所有功能的更多信息，请参见*glibc*手册。

一个 *malloc* 调试库提供与标准 *malloc* 包相同的 API，但额外执行一些工作以捕捉内存分配错误。为了使用此类库，我们将应用程序链接到该库，而不是标准 C 库中的 *malloc* 包。由于这些库通常会牺牲较慢的运行时操作、增加的内存消耗或两者，因此我们应仅在调试时使用它们，并且在应用程序的生产版本中返回使用标准 *malloc* 包进行链接。这类库包括 *Electric Fence* ([`www.perens.com/FreeSoftware/`](http://www.perens.com/FreeSoftware/))，*dmalloc* ([`dmalloc.com/`](http://dmalloc.com/))，*Valgrind* ([`valgrind.org/`](http://valgrind.org/))，和 *Insure++* ([`www.parasoft.com/`](http://www.parasoft.com/))。

### 注意

*Valgrind* 和 *Insure++* 都能够检测到除堆内存分配相关的错误之外的许多其他类型的错误。有关详细信息，请查看它们各自的网站。

#### 控制和监控 *malloc* 包

*glibc* 手册描述了一些非标准函数，这些函数可以用于监控和控制 *malloc* 包中函数的内存分配，包括以下内容：

+   *mallopt()* 函数修改控制 *malloc()* 使用的算法的各种参数。例如，某个参数指定了在使用 *sbrk()* 来缩小堆之前，空闲链表的末尾必须存在的最小可释放空间。另一个参数指定了堆上分配的块的大小上限；超过该大小的块将使用 *mmap()* 系统调用进行分配（请参见 匿名映射）。

+   *mallinfo()* 函数返回一个结构体，包含关于 *malloc()* 分配的内存的各种统计信息。

许多 UNIX 实现提供了 *mallopt()* 和 *mallinfo()* 的版本。然而，这些函数提供的接口在不同实现之间有所不同，因此它们不可移植。

### 堆上分配内存的其他方法

除了 *malloc()*，C 标准库还提供了一系列其他函数，用于在堆上分配内存，本文将介绍这些函数。

#### 使用 *calloc()* 和 *realloc()* 分配内存

*calloc()* 函数为一组相同的元素分配内存。

```
#include <stdlib.h>

void *`calloc`(size_t *numitems*, size_t *size*);
```

### 注意

成功时返回指向分配内存的指针，失败时返回 `NULL`

*numitems* 参数指定要分配的项数，*size* 参数指定这些项的大小。在分配适当大小的内存块后，*calloc()* 返回指向块起始位置的指针（如果内存无法分配，则返回 `NULL`）。与 *malloc()* 不同，*calloc()* 会将分配的内存初始化为 0。

以下是使用 *calloc()* 的示例：

```
struct { /* Some field definitions */ } myStruct;
struct myStruct *p;

p = calloc(1000, sizeof(struct myStruct));
if (p == NULL)
    errExit("calloc");
```

*realloc()*函数用于调整（通常是增大）由*malloc*包中的某个函数之前分配的内存块的大小。

```
#include <stdlib.h>

void *`realloc`(void **ptr*, size_t *size*);
```

### 注意

成功时返回指向分配内存的指针，出错时返回`NULL`。

*ptr*参数是指向要调整大小的内存块的指针。*size*参数指定内存块的新大小。

成功时，*realloc()*返回指向调整大小后的内存块位置的指针。这个位置可能与调用前的位置不同。出错时，*realloc()*返回`NULL`，并保持*ptr*指向的内存块不变（SUSv3 要求如此）。

当*realloc()*增大已分配内存块的大小时，它不会初始化新增的字节。

使用*calloc()*或*realloc()*分配的内存应使用*free()*释放。

### 注意

调用*realloc(ptr, 0)*等同于先调用*free(ptr)*，然后再调用*malloc(0)*。如果*ptr*指定为`NULL`，则*realloc()*等同于调用*malloc(size)*。

对于通常的情况，即我们增加内存块的大小，*realloc()*尝试将该块与空闲列表中紧接其后的内存块合并（如果存在并且足够大）。如果该块位于堆的末尾，*realloc()*会扩展堆。如果内存块位于堆的中间，并且其后没有足够的空闲空间，*realloc()*会分配一个新的内存块，并将旧块中的所有数据复制到新块中。这种情况很常见，并且对 CPU 的要求较高。一般建议尽量减少使用*realloc()*。

由于*realloc()*可能会重新定位内存块，我们必须使用*realloc()*返回的指针来作为未来引用该内存块的依据。我们可以如下使用*realloc()*重新分配由变量*ptr*指向的内存块：

```
nptr = realloc(ptr, newsize);
if (nptr == NULL) {
    /* Handle error */
} else {                /* realloc() succeeded */
    ptr = nptr;
}
```

在此示例中，我们没有将*realloc()*的返回值直接赋给*ptr*，因为如果*realloc()*失败，则*ptr*将被设置为`NULL`，从而使现有的内存块不可访问。

因为*realloc()*可能会移动内存块，任何在*realloc()*调用前指向该内存块内位置的指针，在调用后可能不再有效。唯一保证仍然有效的对块内位置的引用类型是通过向指向块起始位置的指针添加偏移量来形成的。我们将在第 48.6 节中详细讨论这一点。

#### 分配对齐内存：*memalign()*和*posix_memalign()*。

*memalign()* 和 *posix_memalign()* 函数的设计目的是分配从指定的 2 的幂对齐的地址开始的内存，这对于某些应用程序非常有用（例如，参见 示例 13-1, 在 直接 I/O 的对齐限制 中）。

```
#include <malloc.h>

void *`memalign`(size_t *boundary*, size_t *size*);
```

### 注意

成功时返回指向已分配内存的指针，出错时返回 `NULL`

*memalign()* 函数从对齐到 *boundary* 的倍数的地址开始分配 *size* 字节的内存，*boundary* 必须是 2 的幂。已分配内存的地址作为函数结果返回。

*memalign()* 函数并非所有 UNIX 实现中都有。大多数其他提供 *memalign()* 的 UNIX 实现需要包含 `<stdlib.h>` 而不是 `<malloc.h>`，以获得该函数声明。

SUSv3 并没有指定 *memalign()*，而是指定了一个类似的函数，名为 *posix_memalign()*。该函数是标准委员会最近创建的，只出现在少数几个 UNIX 实现中。

```
#include <stdlib.h>

int `posix_memalign`(void ***memptr*, size_t *alignment*, size_t *size*);
```

### 注意

成功时返回 0，出错时返回正的错误号

*posix_memalign()* 函数与 *memalign()* 函数在两个方面有所不同：

+   已分配内存的地址将通过 *memptr* 返回。

+   内存将按 *alignment* 的倍数进行对齐，*alignment* 必须是 *sizeof(void *)*（大多数硬件架构上为 4 或 8 字节）的 2 的幂倍数。

还需要注意该函数的返回值不同寻常——它不会在出错时返回 -1，而是返回一个错误号（即，通常在 *errno* 中返回的正整数）。

如果 *sizeof(void *)* 为 4，则可以使用 *posix_memalign()* 按照如下方式分配 65,536 字节的内存，并确保其对齐到 4096 字节边界：

```
int s;
void *memptr;

s = posix_memalign(&memptr, 1024 * sizeof(void *), 65536);
if (s != 0)
    /* Handle error */
```

使用 *memalign()* 或 *posix_memalign()* 分配的内存块应该使用 *free()* 进行释放。

### 注意

在某些 UNIX 实现中，无法对通过 *memalign()* 分配的内存块调用 *free()*，因为 *memalign()* 实现使用 *malloc()* 分配一块内存块，然后返回指向该内存块中适当对齐地址的指针。*glibc* 实现的 *memalign()* 不会遇到此限制。

## 堆栈上分配内存：*alloca()*

与 *malloc* 包中的函数类似，*alloca()* 也会动态分配内存。然而，*alloca()* 并非从堆中获取内存，而是通过增大栈帧的大小从栈中获取内存。这是可能的，因为调用函数的栈帧在栈顶，因此栈帧上方有空间可供扩展，这可以通过简单地修改栈指针的值来完成。

```
#include <alloca.h>

void *`alloca`(size_t *size*);
```

### 注意

返回指向分配的内存块的指针

*size* 参数指定在栈上分配的字节数。*alloca()* 函数返回一个指向分配内存的指针，作为其函数结果。

我们不需要——实际上，也绝不能——调用 *free()* 来释放使用 *alloca()* 分配的内存。同样，无法使用 *realloc()* 来调整由 *alloca()* 分配的内存块的大小。

尽管 *alloca()* 不是 SUSv3 的一部分，但它在大多数 UNIX 实现中都有提供，因此具有合理的可移植性。

### 注意

较旧版本的 *glibc* 和一些其他 UNIX 实现（主要是 BSD 衍生版本）要求包含 `<stdlib.h>` 而不是 `<alloca.h>` 来获取 *alloca()* 的声明。

如果由于调用 *alloca()* 导致栈溢出，那么程序的行为将不可预测。特别地，我们不会得到 `NULL` 返回值来通知我们发生了错误。（实际上，在这种情况下，我们可能会收到 `SIGSEGV` 信号。有关更多细节，请参见 在备用栈上处理信号：*sigaltstack()*")。）

请注意，我们不能在函数参数列表中使用 *alloca()*，如下面的例子所示：

```
func(x, alloca(size), z);           /* WRONG! */
```

这是因为 *alloca()* 分配的栈空间会出现在函数参数空间的中间（这些参数在栈帧内具有固定位置）。因此，我们必须使用类似下面的代码：

```
void *y;

y = alloca(size);
func(x, y, z);
```

使用 *alloca()* 分配内存相比 *malloc()* 有一些优势。其一是，使用 *alloca()* 分配内存块比使用 *malloc()* 更快，因为 *alloca()* 由编译器实现为内联代码，直接调整栈指针。此外，*alloca()* 不需要维护空闲块的列表。

*alloca()* 的另一个优势是，它分配的内存会在栈帧被移除时自动释放；也就是说，当调用 *alloca()* 的函数返回时。这是因为函数返回时执行的代码会将栈指针寄存器的值重置为前一个栈帧的结束位置（即，假设栈向下增长，为当前栈帧起始位置上方的地址）。由于我们不需要确保在函数的所有返回路径上释放分配的内存，因此某些函数的编码变得更加简单。

使用*alloca()*特别有用，如果我们使用*longjmp()*（执行非局部跳转：*setjmp()*和*long jmp()*和 long jmp()")）或*siglongjmp()*（从信号处理程序执行非局部跳转）来执行来自信号处理程序的非局部跳转。在这种情况下，如果我们在跳过的函数中使用*malloc()*分配内存，避免内存泄漏是困难甚至不可能的。相反，*alloca()*完全避免了这个问题，因为随着这些调用展开栈，分配的内存会被自动释放。

## 总结

使用*malloc*系列函数，进程可以动态地在堆上分配和释放内存。在考虑这些函数的实现时，我们看到程序在错误处理分配的内存块时可能会出现各种问题，并且注意到有许多调试工具可用于帮助定位这些错误的源头。

*alloca()*函数在栈上分配内存。当调用*alloca()*的函数返回时，这块内存会自动被释放。

## 练习

1.  修改示例 7-1（`free_and_sbrk.c`）中的程序，在每次执行*malloc()*后打印当前的程序断点值。运行该程序并指定一个小的分配块大小。这将演示*malloc()*并不会在每次调用时使用*sbrk()*来调整程序断点，而是定期从中分配更大的内存块，并从中将小块内存分配给调用者。

1.  （高级）实现*malloc()*和*free()*。
