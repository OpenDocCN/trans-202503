## 附录 C. 转换`NULL`指针

请考虑以下对可变参数函数*execl()*的调用：

```
execl("ls", "ls", "-l", (char *) NULL);
```

### 注意

*可变参数函数*是指接受可变数量或类型不定的参数的函数。

是否需要在`NULL`前进行类型转换，是一些混淆的根源。虽然我们在很多情况下可以不使用类型转换，但 C 标准要求必须使用类型转换；如果不包含转换，可能会导致应用程序在某些系统上崩溃。

`NULL`通常被定义为 0 或*(void *) 0*。（C 标准允许其他定义，但它们本质上等价于这两种可能性之一。）需要类型转换的主要原因是，`NULL`允许定义为 0，因此我们首先讨论这种情况。

C 预处理器在源代码传递给编译器之前，会将`NULL`转换为 0。C 标准规定，整数常量 0 可以在任何可能使用指针的上下文中使用，编译器将确保该值被视为空指针。在大多数情况下，一切正常，我们无需担心类型转换。例如，我们可以写出如下代码：

```
int *p;

p = 0;                                  /* Assign null pointer to 'p' */
p = NULL;                               /* Same as 'p = 0' */
```

上述赋值之所以有效，是因为编译器可以确定赋值右侧需要一个指针值，并会将值 0 转换为空指针。

类似地，对于具有固定参数列表的函数，我们可以为指针参数指定 0 或`NULL`，以表示应传递一个空指针给函数：

```
sigaction(SIGINT, &sa, 0);
sigaction(SIGINT, &sa, NULL);           /* Equivalent to the preceding */
```

### 注意

如果我们要传递一个空指针给一个旧式的、没有原型的 C 函数，那么关于需要适当地转换 0 或`NULL`的所有论点仍然适用，无论该参数是否是可变参数列表的一部分。

因为在上述示例中不需要类型转换，有人可能会得出结论认为类型转换永远不需要。但这是错误的。当在调用像*execl()*这样的可变参数函数时，如果指定了空指针作为其中一个可变参数，类型转换是必须的。为了理解为何需要这样做，我们需要知道以下几点：

+   编译器无法确定可变参数函数中各个参数的预期类型。

+   C 标准并不要求空指针必须以与整数常量 0 相同的方式表示。（理论上，空指针可以通过任何与有效指针不同的位模式表示。）标准也并未要求空指针的大小与整数常量 0 相同。标准只要求，在期望指针的上下文中出现整数常量 0 时，0 应被解释为空指针。

因此，写出以下任意一种情况都是错误的：

```
execl(prog, arg, 0);
execl(prog, arg, NULL);
```

这是一个错误，因为编译器会将整数常量 0 传递给*execl()*，但无法保证这与空指针等价。

实际上，我们通常可以不使用强制类型转换，因为在许多 C 实现中（例如 Linux/x86-32），整数（*int*）常量 0 和空指针的表示是相同的。然而，也有一些实现是不同的——例如，在某些实现中，空指针的大小大于整数常量 0 的大小——因此，在上述示例中，*execl()* 很可能会接收到一些与整数 0 相邻的随机位，这些位会被解释为一个随机（非空）指针。省略强制类型转换会导致程序在移植到这些实现时出现问题。（在一些上述实现中，`NULL` 被定义为 *long* 整数常量 *0L*，并且 *long* 和 *void ** 有相同的大小，这可能会拯救那些错误构造的程序，尤其是使用上面第二个 *execl()* 调用的程序。）因此，我们应当以以下方式重写上述 *execl()* 调用：

```
execl(prog, arg, (char *) 0);
execl(prog, arg, (char *) NULL);
```

即使在 `NULL` 被定义为 *(void *) 0* 的实现中，通常也需要按照上面最后一个调用的方式进行强制类型转换。这是因为，尽管 C 标准要求不同类型的空指针在进行相等比较时应返回真值，但它并不要求不同类型的指针具有相同的内部表示（尽管在大多数实现中它们具有相同的表示）。而且，正如之前所述，在变参函数中，编译器无法将 *(void *) 0* 强制转换为适当类型的空指针。

### 注意

C 标准对不同类型的指针不需要具有相同表示的规则作出一个例外：*char ** 和 *void ** 类型的指针必须具有相同的内部表示。这意味着在 *execl()* 的示例中，传递 *(void *) 0* 而不是 *(char *) 0* 不会有问题，但在一般情况下，仍然需要强制类型转换。
