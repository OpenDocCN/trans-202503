## 第二十五章。进程终止

本章描述了进程终止时发生的情况。我们首先介绍如何使用*exit()*和*_exit()*来终止进程。然后，我们讨论如何使用退出处理程序在进程调用*exit()*时自动执行清理操作。最后，我们考虑*fork()*、*stdio*缓冲区和*exit()*之间的一些交互。

## 终止进程：*_exit()*和*exit()*

进程可以通过两种方式终止。其中一种是*非正常*终止，由默认动作为终止进程的信号传递引起（有或没有核心转储），如第 20.1 节所述。另一种方式是通过使用*_exit()*系统调用*正常*终止进程。

```
#include <unistd.h>

void _`exit`(int *status*);
```

提供给*_exit()*的*status*参数定义了进程的*终止状态*，该状态在父进程调用*wait()*时可用。虽然定义为*int*类型，但实际上只有*status*的最低 8 位会传递给父进程。根据约定，终止状态为 0 表示进程成功完成，而非零状态值表示进程未能成功终止。关于如何解释非零状态值没有固定规则；不同的应用程序遵循各自的约定，这些约定应在它们的文档中进行说明。SUSv3 规范了两个常量，`EXIT_SUCCESS`（0）和`EXIT_FAILURE`（1），它们在本书中的大多数程序中被使用。

进程总是通过*_exit()*成功终止（即，*_exit()*永不返回）。

### 注意

尽管可以通过*status*参数将 0 到 255 范围内的任何值传递给父进程，但指定大于 128 的值可能会在 shell 脚本中引起混淆。原因是，当命令通过信号终止时，shell 会通过将变量*$?*的值设置为 128 加上信号编号来表示这一事实，而这个值与进程调用*_exit()*时传递相同*status*值的结果无法区分。

程序通常不会直接调用*_exit()*，而是调用*exit()*库函数，该函数在调用*_exit()*之前执行各种操作。

```
#include <stdlib.h>

void `exit`(int *status*);
```

*exit()*执行以下操作：

+   退出处理程序（通过*atexit()*和*on_exit()*注册的函数）按其注册的逆序被调用（退出处理程序）。

+   *stdio*流缓冲区被刷新。

+   调用*_exit()*系统调用时，使用在*status*中提供的值。

### 注意

与特定于 UNIX 的*_exit()*不同，*exit()*作为标准 C 库的一部分被定义；也就是说，每个 C 实现都可以使用它。

另一种进程终止的方式是从 *main()* 返回，或者通过隐式的方式（即在 *main()* 函数的末尾退出）。显式执行 *return n* 通常等同于调用 *exit(n)*，因为调用 *main()* 的运行时函数会使用 *main()* 的返回值来调用 *exit()*。

### 注意

有一种情况下，调用 *exit()* 和从 *main()* 返回并不等同。如果退出处理过程中访问了 *main()* 中的局部变量，那么从 *main()* 返回会导致未定义行为。例如，如果在调用 *setvbuf()* 或 *setbuf()*（stdio 库中的缓冲区）时指定了 *main()* 中的局部变量，就可能会发生这种情况。

如果执行返回时没有指定返回值，或者在 *main()* 函数的末尾退出，也会导致 *main()* 的调用者调用 *exit()*，但结果会根据所支持的 C 标准版本和使用的编译选项有所不同：

+   在 C89 标准中，这种情况下的行为是未定义的；程序可能会以任意的 *status* 值终止。这就是在 Linux 上使用 *gcc* 编译时的默认行为，程序的退出状态会取自栈上的某个随机值或某个特定的 CPU 寄存器。应避免以这种方式终止程序。

+   C99 标准要求，在程序主函数的末尾退出应当等同于调用 *exit(0)*。这是我们在 Linux 上使用 *gcc -std=c99* 编译程序时获得的行为。

## 进程终止的详细信息

在进程的正常和异常终止过程中，都会发生以下操作：

+   打开的文件描述符、目录流（读取目录：*opendir()* 和 *readdir()* 和 readdir()")）、消息目录描述符（参见 *catopen(3)* 和 *catgets(3)* 手册页）以及转换描述符（参见 *iconv_open(3)* 手册页）都会被关闭。

+   由于关闭文件描述符，任何由该进程持有的文件锁（第五十五章）都会被释放。

+   所有附加的 System V 共享内存段都会被分离，且每个内存段对应的 *shm_nattch* 计数器会减一。（参见第 48.8 节。）

+   对于每个由进程设置了 *semadj* 值的 System V 信号量，该 *semadj* 值会被加到信号量值上。（参见第 47.8 节。）

+   如果这是控制终端的控制进程，那么会向控制终端的前台进程组中的每个进程发送 `SIGHUP` 信号，且终端会与会话解除关联。我们将在第 34.6 节进一步讨论这一点。

+   任何在调用进程中打开的 POSIX 命名信号量都会被关闭，就像调用了 *sem_close()* 一样。

+   调用进程中打开的任何 POSIX 消息队列都会被关闭，仿佛调用了*mq_close()*。

+   如果由于该进程退出而导致进程组变为孤儿，并且该组中有任何停止的进程，则该组中的所有进程将收到`SIGHUP`信号，随后是`SIGCONT`信号。我们将在孤儿进程组（以及`SIGHUP`回顾）中进一步讨论这一点。

+   该进程使用*mlock()*或*mlockall()*（内存锁定：*mlock()*和*mlockall()*和 mlockall()")）建立的任何内存锁会被移除。

+   该进程使用*mmap()*建立的任何内存映射都将被解除映射。

## 退出处理程序

有时，一个应用程序需要在进程终止时自动执行一些操作。考虑一个应用程序库的例子，如果在进程生命周期内使用该库，则需要在进程退出时自动执行一些清理操作。由于该库无法控制进程退出的时机和方式，也无法强制主程序在退出前调用库特定的清理函数，因此无法保证清理操作会执行。在这种情况下，一种方法是使用*退出处理程序*（旧版 System V 手册中使用术语*程序终止例程*）。

退出处理程序是一个由程序员提供的函数，它在进程生命周期的某个时刻注册，并在*正常*进程终止时通过*exit()*自动调用。如果程序直接调用*_exit()*，或进程被信号异常终止，则不会调用退出处理程序。

### 注意

在一定程度上，退出处理程序在进程因信号终止时未被调用，限制了其效用。我们能做的最好方法是为可能发送到进程的信号建立处理程序，并让这些处理程序设置一个标志，促使主程序调用*exit()*。（因为*exit()*不是在表 21-1 中列出的异步信号安全函数之一，在信号处理程序中的*errno*使用中提到，我们通常不能从信号处理程序中调用它。）即便如此，这也不能处理`SIGKILL`的情况，因为`SIGKILL`的默认操作无法更改。这是我们应该避免使用`SIGKILL`来终止进程的另一个原因（如在信号类型和默认操作中所述），而应该使用`SIGTERM`，它是*kill*命令发送的默认信号。

#### 注册退出处理程序

GNU C 库提供了两种注册退出处理程序的方法。第一种方法是在 SUSv3 中指定的，使用 *atexit()* 函数。

```
#include <stdlib.h>

int `atexit`(void (**func*)(void));
```

### 注意

成功时返回 0，出错时返回非零值

*atexit()* 函数将 *func* 添加到一个在进程终止时调用的函数列表中。函数 *func* 应该定义为不带参数且不返回值，因此具有以下通用形式：

```
void
func(void)
{
    /* Perform some actions */
}
```

注意，*atexit()* 在发生错误时返回一个非零值（不一定是 -1）。

可以注册多个退出处理程序（甚至是同一个退出处理程序多次）。当程序调用 *exit()* 时，这些函数会按注册的 *逆序* 被调用。这种顺序是合理的，因为通常，较早注册的函数是执行更基础清理操作的函数，这些操作可能需要在后注册的函数执行后进行。

本质上，任何想要的操作都可以在退出处理程序中执行，包括注册额外的退出处理程序，这些处理程序会被放置在待调用的退出处理程序列表的头部。然而，如果某个退出处理程序未能返回——无论是因为它调用了 *_exit()*，还是因为进程被信号终止（例如，退出处理程序调用了 *raise()*）——则剩余的退出处理程序不会被调用。此外，通常由 *exit()* 执行的剩余操作（例如，刷新 *stdio* 缓冲区）也不会被执行。

### 注意

SUSv3 声明，如果一个退出处理程序本身调用 *exit()*，结果是未定义的。在 Linux 上，剩余的退出处理程序会正常调用。然而，在某些系统上，这会导致所有退出处理程序再次被调用，这可能导致无限递归（直到栈溢出导致进程终止）。可移植的应用程序应该避免在退出处理程序中调用 *exit()*。

SUSv3 要求实现必须允许进程至少注册 32 个退出处理程序。通过调用 *sysconf(_SC_ATEXIT_MAX)*，程序可以确定实现定义的最大可注册退出处理程序数量。（然而，没有办法知道已经注册了多少个退出处理程序。）通过将注册的退出处理程序链接在一个动态分配的链表中，*glibc* 允许几乎无限数量的退出处理程序注册。在 Linux 上，*sysconf(_SC_ATEXIT_MAX)* 返回 2,147,482,647（即最大有符号 32 位整数）。换句话说，在我们达到可注册函数数量的限制之前，其他问题（例如内存不足）会导致程序出错。

通过 *fork()* 创建的子进程会继承父进程的退出处理程序注册副本。当一个进程执行 *exec()* 时，所有退出处理程序的注册都会被移除。（这是必然的，因为 *exec()* 会替换退出处理程序的代码以及其余的程序代码。）

### 注意

我们无法注销已经通过*atexit()*（或下面描述的*on_exit()*）注册的退出处理程序。然而，我们可以让退出处理程序在执行操作之前检查某个全局标志是否已设置，并通过清除该标志来禁用退出处理程序。

使用*atexit()*注册的退出处理程序存在一些限制。第一个限制是，当被调用时，退出处理程序无法知道传递给*exit()*的状态。有时，了解状态可能会有用；例如，我们可能希望根据进程是成功退出还是失败退出来执行不同的操作。第二个限制是，当调用退出处理程序时，我们无法为其指定参数。这样的功能对于定义一个根据其参数执行不同操作的退出处理程序，或者多次注册一个函数，每次使用不同的参数，可能会非常有用。

为了解决这些限制，*glibc*提供了一种（非标准的）替代方法来注册退出处理程序：*on_exit()*。

```
#define _BSD_SOURCE           /* Or: #define _SVID_SOURCE */
#include <stdlib.h>

int `on_exit`(void (**func*)(int, void *), void **arg*);
```

### 注意

成功时返回 0，出错时返回非零值

*on_exit()*的*func*参数是指向以下类型函数的指针：

```
void
func(int status, void *arg)
{
    /* Perform cleanup actions */
}
```

当被调用时，*func()*会传递两个参数：传递给*exit()*的*status*参数，以及在注册时传递给*on_exit()*的*arg*参数的副本。尽管被定义为指针类型，*arg*对程序员来说可以有多种解释。它可以用作指向某个结构体的指针；同样，通过适当的类型转换，它也可以被当作整数或其他标量类型处理。

与*atexit()*一样，*on_exit()*在出错时返回一个非零值（不一定是-1）。

与*atexit()*一样，可以使用*on_exit()*注册多个退出处理程序。通过*atexit()*和*on_exit()*注册的函数被放置在同一个列表中。如果在同一个程序中同时使用这两种方法，那么退出处理程序会按照注册顺序的逆序调用。

尽管比*atexit()*更灵活，*on_exit()*应该避免在旨在具有可移植性的程序中使用，因为它不受任何标准的约束，并且仅在少数其他 UNIX 实现中可用。

#### 示例程序

示例 25-1 演示了如何使用*atexit()*和*on_exit()*注册退出处理程序。当我们运行这个程序时，我们会看到如下输出：

```
$ `./exit_handlers`
on_exit function called: status=2, arg=20
atexit function 2 called
atexit function 1 called
on_exit function called: status=2, arg=10
```

示例 25-1. 使用退出处理程序

```
`procexec/exit_handlers.c`
#define _BSD_SOURCE     /* Get on_exit() declaration from <stdlib.h> */
#include <stdlib.h>
#include "tlpi_hdr.h"

static void
atexitFunc1(void)
{
    printf("atexit function 1 called\n");
}

static void
atexitFunc2(void)
{
    printf("atexit function 2 called\n");
}

static void
onexitFunc(int exitStatus, void *arg)
{
    printf("on_exit function called: status=%d, arg=%ld\n",
                exitStatus, (long) arg);
}

int
main(int argc, char *argv[])
{
    if (on_exit(onexitFunc, (void *) 10) != 0)
        fatal("on_exit 1");
    if (atexit(atexitFunc1) != 0)
        fatal("atexit 1");
    if (atexit(atexitFunc2) != 0)
        fatal("atexit 2");
    if (on_exit(onexitFunc, (void *) 20) != 0)
        fatal("on_exit 2");

    exit(2);
}
      `procexec/exit_handlers.c`
```

## *fork()*、*stdio*缓冲区和*_exit()*之间的交互

示例 25-2 和 stdio 缓冲区的交互")中程序输出展示了一种初看令人困惑的现象。当我们将标准输出定向到终端时，看到预期的结果：

```
$ `./fork_stdio_buf`
Hello world
Ciao
```

然而，当我们将标准输出重定向到文件时，看到如下结果：

```
$ `./fork_stdio_buf > a`
$ `cat a`
Ciao
Hello world
Hello world
```

在上述输出中，我们看到两个奇怪的现象：由*printf()*写入的行出现了两次，*write()*的输出出现在*printf()*之前。

示例 25-2. *fork()*和*stdio*缓冲的交互

```
`procexec/fork_stdio_buf.c`
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    printf("Hello world\n");
    write(STDOUT_FILENO, "Ciao\n", 5);

    if (fork() == -1)
        errExit("fork");

    /* Both child and parent continue execution here */

    exit(EXIT_SUCCESS);
}
     `procexec/fork_stdio_buf.c`
```

要理解为什么使用*printf()*写入的消息会出现两次，回想一下*stdio*缓冲区是保存在进程的用户空间内存中的（请参见 stdio 库中的缓冲）。因此，这些缓冲区会在*fork()*时被复制到子进程中。当标准输出定向到终端时，默认是行缓冲，因此由*printf()*写入的以换行符结束的字符串会立即显示。然而，当标准输出定向到文件时，默认是块缓冲。因此，在我们的示例中，*printf()*写入的字符串在*fork()*时仍然存在于父进程的*stdio*缓冲区中，这个字符串会在子进程中被复制。当父进程和子进程稍后调用*exit()*时，它们都会刷新自己的*stdio*缓冲区，导致重复输出。

我们可以通过以下几种方式来防止这种重复输出的发生：

+   作为解决*stdio*缓冲问题的具体方法，我们可以使用*fflush()*在调用*fork()*之前刷新*stdio*缓冲区。或者，我们可以使用*setvbuf()*或*setbuf()*来禁用*stdio*流的缓冲。

+   子进程可以调用*_exit()*代替调用*exit()*，这样它就不会刷新*stdio*缓冲区。这个技巧体现了一个更一般的原则：在一个创建子进程且子进程不执行新程序的应用程序中，通常只有一个进程（通常是父进程）应该通过*exit()*终止，而其他进程应该通过*_exit()*终止。这可以确保只有一个进程调用退出处理程序并刷新*stdio*缓冲区，这通常是期望的行为。

### 注意

其他允许父进程和子进程都调用*exit()*的方法也是可能的（有时也是必要的）。例如，可以设计退出处理程序，使其即使在多个进程中被调用时也能正确工作，或者在调用*fork()*之后才为应用程序安装退出处理程序。此外，有时我们可能确实希望所有进程在*fork()*之后刷新它们的*stdio*缓冲区。在这种情况下，我们可以选择使用*exit()*终止进程，或根据需要在每个进程中显式调用*fflush()*。

程序中示例 25-2*和*stdio*缓冲的交互")中的*write()*输出没有出现两次，因为*write()*直接将数据传输到内核缓冲区，而该缓冲区在*fork()*时不会被复制。

到目前为止，程序输出被重定向到文件时的第二个奇怪现象的原因应该已经清楚了。*write()* 的输出先于 *printf()* 的输出出现，因为 *write()* 的输出会立即传输到内核缓冲区，而 *printf()* 的输出只有在通过调用 *exit()* 刷新 *stdio* 缓冲区后才会传输。（通常，在同一个文件上混合使用 *stdio* 函数和系统调用来执行 I/O 时需要小心，详见第 13.7 节。）

## 总结

一个进程可以以异常或正常方式终止。异常终止发生在接收到某些信号时，其中一些信号还会导致进程生成核心转储文件。

正常终止是通过调用 *_exit()* 或更常见的 *exit()* 完成的，后者是基于 *_exit()* 之上的。*exit()* 和 *_exit()* 都接受一个整数参数，其最低有效的 8 位定义了进程的终止状态。按照惯例，状态 0 表示成功终止，非零状态表示终止失败。

在正常和异常的进程终止过程中，内核会执行各种清理步骤。通过调用 *exit()* 正常终止进程时，还会调用使用 *atexit()* 和 *on_exit()* 注册的退出处理程序（按照注册的反向顺序），并导致 *stdio* 缓冲区被刷新。

#### 进一步信息

请参考第 24.6 节中列出的进一步信息来源。

## 练习

1.  如果一个子进程调用 exit(-1)，父进程将看到什么退出状态（由 `WEXITSTATUS()` 返回）？
