## 第六章 进程

在本章中，我们将研究进程的结构，特别关注进程虚拟内存的布局和内容。我们还将检查进程的一些属性。在后续章节中，我们将进一步探讨进程属性（例如，第九章中的进程凭据 Chapter 9，以及第三十五章中的进程优先级和调度 Chapter 35）。在第二十四章到第二十七章中，我们将讨论进程是如何创建的、如何终止的，以及如何使其执行新程序。

## 进程与程序

*进程*是一个执行中的程序实例。在本节中，我们将详细阐述这个定义，并澄清程序与进程之间的区别。

*程序*是一个包含各种信息的文件，这些信息描述了如何在运行时构建一个进程。这些信息包括以下内容：

+   *二进制格式标识*：每个程序文件都包含描述可执行文件格式的元信息。这使得内核能够解释文件中的其他信息。从历史上看，UNIX 可执行文件的两种广泛使用的格式是最初的*a.out*（“汇编输出”）格式和后来的、更复杂的*COFF*（公共对象文件格式）。如今，大多数 UNIX 实现（包括 Linux）采用可执行与链接格式（ELF），相比旧格式，ELF 提供了多种优势。

+   *机器语言指令*：这些指令编码了程序的算法。

+   *程序入口点地址*：这是标识程序执行应从哪条指令开始的地址。

+   *数据*：程序文件包含用于初始化变量的值，以及程序使用的字面常量（例如字符串）。

+   *符号和重定位表*：这些表描述了程序中函数和变量的位置和名称。这些表用于多种目的，包括调试和运行时符号解析（动态链接）。

+   *共享库和动态链接信息*：程序文件包括列出程序在运行时需要使用的共享库的字段，以及应该用于加载这些库的动态链接器的路径名。

+   *其他信息*：程序文件包含了描述如何构建进程的各种其他信息。

一个程序可以用来构建多个进程，或者反过来，多个进程可以运行同一个程序。

我们可以将本节开始时给出的进程定义重新表述如下：进程是一个抽象实体，由内核定义，系统资源被分配给它以执行程序。

从内核的角度来看，一个进程由用户空间的内存组成，其中包含程序代码和该代码使用的变量，以及一系列内核数据结构，这些数据结构维护有关进程状态的信息。记录在内核数据结构中的信息包括与进程相关的各种标识符号码（ID），虚拟内存表，打开的文件描述符表，信号传递和处理的信息，进程资源的使用情况和限制，当前工作目录，以及其他一系列信息。

## 进程 ID 和父进程 ID

每个进程都有一个进程 ID（PID），它是一个正整数，用来唯一标识系统上的进程。进程 ID 被各种系统调用使用并返回。例如，*kill()*系统调用（发送信号：*kill()*")）允许调用者向具有特定进程 ID 的进程发送信号。进程 ID 在我们需要构建一个唯一标识进程的标识符时也很有用。一个常见的例子是将进程 ID 作为进程唯一文件名的一部分。

*getpid()*系统调用返回调用进程的进程 ID。

```
#include <unistd.h>

pid_t `getpid`(void);
```

### 注意

始终成功返回调用者的进程 ID。

用于*getpid()*返回值的*pid_t*数据类型是一个由 SUSv3 指定的整数类型，用于存储进程 ID。

除了一些系统进程，比如*init*（进程 ID 为 1），程序和为运行该程序创建的进程 ID 之间没有固定的关系。

Linux 内核将进程 ID 限制为小于或等于 32,767。当创建一个新进程时，它将分配下一个顺序可用的进程 ID。每次达到 32,767 的限制时，内核会重置其进程 ID 计数器，从而重新分配低整数值作为进程 ID。

### 注意

一旦达到 32,767，进程 ID 计数器将重置为 300，而不是 1。这是因为许多低编号的进程 ID 已被系统进程和守护进程永久使用，因此在这个范围内查找未使用的进程 ID 将浪费时间。

在 Linux 2.4 及以前版本中，进程 ID 的上限 32,767 由内核常量`PID_MAX`定义。随着 Linux 2.6 的发布，情况发生了变化。虽然进程 ID 的默认上限仍然是 32,767，但此限制可以通过 Linux 特有的`/proc/sys/kernel/pid_max`文件中的值进行调整（该值比最大进程 ID 大 1）。在 32 位平台上，该文件的最大值为 32,768，但在 64 位平台上，它可以调整到任何最大值，最高可达 222（大约 400 万），使得能够容纳非常大的进程数。

每个进程都有一个父进程——即创建它的进程。进程可以通过*getppid()*系统调用来获取父进程的进程 ID。

```
#include <unistd.h>

pid_t `getppid`(void);
```

### 注意

始终成功返回调用者父进程的进程 ID

实际上，每个进程的父进程 ID 属性代表了系统上所有进程的树状关系。每个进程的父进程也有自己的父进程，以此类推，直到回溯到进程 1，*init*，它是所有进程的祖先。（这个“家谱”可以通过 *pstree(1)* 命令查看。）

如果一个子进程因其“出生”父进程终止而变成孤儿进程，则该子进程会被 *init* 进程收养，之后在子进程中调用 *getppid()* 时会返回 1（见 孤儿进程与僵尸进程）。

可以通过查看 Linux 特有的 `/proc/`*`PID`*`/status` 文件中的 `PPid` 字段来找到任何进程的父进程。

## 进程的内存布局

分配给每个进程的内存由多个部分组成，通常称为 *段*。这些段如下：

+   *文本段*包含程序运行时的机器语言指令。文本段被设为只读，以防止进程通过错误的指针值意外修改自己的指令。由于多个进程可能在运行相同的程序，文本段被设为可共享，从而使得程序代码的单一副本可以映射到所有进程的虚拟地址空间中。

+   *初始化数据段*包含显式初始化的全局变量和静态变量。这些变量的值在程序加载到内存时从可执行文件中读取。

+   *未初始化数据段*包含未显式初始化的全局变量和静态变量。在程序启动之前，系统会将该段的所有内存初始化为 0。出于历史原因，这个段通常被称为 *bss* 段，这是一个源自旧汇编助记符“由符号开始的块”（block started by symbol）的名称。将已初始化的全局和静态变量与未初始化的变量放在不同的段中的主要原因是，当程序存储在磁盘上时，无需为未初始化的数据分配空间。相反，可执行文件仅需要记录未初始化数据段所需的位置和大小，在运行时由程序加载器分配该空间。

+   *栈*是一个动态增长和缩小的段，包含栈帧。每调用一个函数，都会为其分配一个栈帧。栈帧存储函数的局部变量（即自动变量）、参数和返回值。栈帧将在第 6.5 节中进一步讨论。

+   *堆*是一个可以在运行时动态分配内存（用于变量）的区域。堆的顶部被称为 *程序断点*。

较少使用，但更具描述性的标签用于初始化和未初始化数据段，分别是 *用户初始化数据段* 和 *零初始化数据段*。

*size(1)* 命令显示二进制可执行文件中文本段、已初始化数据段和未初始化数据（*bss*）段的大小。

### 注

文中使用的术语*段*不应与某些硬件架构（如 x86-32）上使用的硬件分段混淆。实际上，段是 UNIX 系统中进程虚拟内存的逻辑划分。有时，术语*区段*会替代*段*使用，因为*区段*与现在广泛使用的 ELF 可执行文件格式规范中的术语更加一致。

本书中的许多地方都提到，库函数返回指向静态分配内存的指针。这里的意思是，该内存是在已初始化或未初始化的数据段中分配的。（在某些情况下，库函数可能会在堆上进行一次动态内存分配；然而，这一实现细节与我们在这里描述的语义点无关。）需要注意的是，库函数返回的信息通过静态分配的内存传递，因为该内存的存在是独立于函数调用的，并且该内存可能会被后续对同一函数的调用（或在某些情况下，对相关函数的调用）覆盖。使用静态分配内存的效果是使函数变为不可重入。关于重入性，我们在可重入和异步信号安全函数以及线程安全（和重入性再探）中有更详细的讨论。

示例 6-1 展示了各种类型的 C 变量，并附有注释指明每个变量所在的段。这些注释假设使用的是非优化编译器，并且应用程序二进制接口中所有参数都通过栈传递。在实践中，优化编译器可能会将频繁使用的变量分配到寄存器中，或完全优化掉某些变量。此外，一些 ABI 规定函数参数和函数结果应通过寄存器而非栈传递。尽管如此，此示例仍能展示 C 变量与进程段之间的映射关系。

示例 6-1. 程序变量在进程内存段中的位置

```
`proc/mem_segments.c`
#include <stdio.h>
#include <stdlib.h>

char globBuf[65536];            /* Uninitialized data segment */
int primes[] = { 2, 3, 5, 7 };  /* Initialized data segment */

static int
square(int x)                   /* Allocated in frame for square() */
{
    int result;                 /* Allocated in frame for square() */

    result = x * x;
    return result;              /* Return value passed via register */
}

static void
doCalc(int val)                 /* Allocated in frame for doCalc() */
{
    printf("The square of %d is %d\n", val, square(val));

    if (val < 1000) {
        int t;                  /* Allocated in frame for doCalc() */

        t = val * val * val;
        printf("The cube of %d is %d\n", val, t);
    }
}

int
main(int argc, char *argv[])    /* Allocated in frame for main() */
{
    static int key = 9973;      /* Initialized data segment */
    static char mbuf[10240000]; /* Uninitialized data segment */
    char *p;                    /* Allocated in frame for main() */

    p = malloc(1024);           /* Points to memory in heap segment */

    doCalc(key);

    exit(EXIT_SUCCESS);
}
      `proc/mem_segments.c`
```

### 注

*应用二进制接口*（ABI）是一组规则，规定了二进制可执行文件在运行时如何与某些服务（例如内核或库）交换信息。ABI 规定了交换这些信息时使用哪些寄存器和栈位置，以及交换值的含义。编译为特定 ABI 的二进制可执行文件应该能够在任何呈现相同 ABI 的系统上运行。这与标准化的 API（如 SUSv3）不同，后者只保证从源代码编译的应用程序的可移植性。

尽管在 SUSv3 中没有规定，但在大多数 UNIX 实现（包括 Linux）中的 C 程序环境提供了三个全局符号：*etext*、*edata*和*end*。这些符号可以在程序中使用，以分别获取程序文本结束、已初始化数据段结束和未初始化数据段结束之后的下一个字节的地址。为了使用这些符号，我们必须显式声明它们，如下所示：

```
extern char etext, edata, end;
        /* For example, &etext gives the address of the end
           of the program text / start of initialized data */
```

图 6-1 显示了 x86-32 架构上各种内存段的排列。图中顶部标记为*argv, environ*的区域包含程序的命令行参数（可以通过*C 语言中的*main()*函数的*argv*参数访问）和进程环境列表（我们稍后讨论）。图中显示的十六进制地址可能会有所不同，具体取决于内核配置和程序链接选项。灰色区域表示进程虚拟地址空间中无效的范围；即，尚未创建页表的区域（参见下面关于虚拟内存管理的讨论）。

我们在虚拟内存中共享内存的位置中更详细地回顾了进程内存布局的话题，讨论了共享内存和共享库在进程虚拟内存中的位置。

## 虚拟内存管理

前面讨论的进程内存布局忽略了我们实际上在讨论*虚拟内存*中的布局。由于理解虚拟内存在后续讨论诸如*fork()*系统调用、共享内存和映射文件等话题时非常有用，我们现在来考虑一些细节。

像大多数现代内核一样，Linux 采用了一种称为*虚拟内存管理*的技术。该技术的目的是通过利用大多数程序的典型属性——*局部性*，来高效利用 CPU 和 RAM（物理内存）。大多数程序展示了两种局部性：

+   *空间局部性*是程序倾向于引用与最近访问过的内存地址接近的地址的特性（由于指令的顺序处理，有时也包括数据结构的顺序处理）。

+   *时间局部性*是程序倾向于在不久的将来访问它最近访问过的相同内存地址的特性（因为存在循环）。

![Linux/x86-32 上的进程典型内存布局](img/06-1_PROCESS-memory-layout.png.jpg)图 6-1。Linux/x86-32 上的进程典型内存布局

局部性引用的结果是，程序在执行时只需要将其地址空间的一部分保留在 RAM 中。

一种虚拟内存方案将每个程序使用的内存分割成小的固定大小单元，称为*页面*。相应地，RAM 被划分为一系列相同大小的*页框*。在任何时候，程序的某些页面只需要驻留在物理内存页框中；这些页面形成所谓的*常驻集*。程序未使用的页面的副本保存在*交换区*——一个用于补充计算机 RAM 的磁盘空间保留区域——并且仅在需要时加载到物理内存中。当进程引用一个当前不在物理内存中的页面时，会发生*页面错误*，此时内核暂停进程的执行，直到该页面从磁盘加载到内存中。

### 注意

在 x86-32 上，页面大小为 4096 字节。其他一些 Linux 实现使用更大的页面大小。例如，Alpha 使用 8192 字节的页面大小，而 IA-64 具有可变的页面大小，通常的默认值是 16,384 字节。程序可以使用调用*sysconf(_SC_PAGESIZE)*来确定系统的虚拟内存页面大小，如第 11.2 节所述。

![虚拟内存概述](img/06-2_PROCESS-virtual-memory.png.jpg)图 6-2。虚拟内存概述

为了支持这种组织方式，内核为每个进程维护一个*页表*（图 6-2）。页表描述了进程*虚拟地址空间*（进程可用的所有虚拟内存页面的集合）中每一页的位置。页表中的每个项要么指示一个虚拟页在 RAM 中的位置，要么指示该页当前驻留在磁盘上。

并非进程虚拟地址空间中的所有地址范围都需要页表项。通常，虚拟地址空间中的大范围是未使用的，因此无需维护相应的页表项。如果进程尝试访问一个没有对应页表项的地址，它会收到一个`SIGSEGV`信号。

一个进程的有效虚拟地址范围可能会随着其生命周期的变化而变化，因为内核会为进程分配和释放页面（以及页表项）。这种情况可能在以下几种情况下发生：

+   当堆栈向下增长超出之前的限制时；

+   当通过*brk()*、*sbrk()*或*malloc*系列函数在堆上分配或释放内存时（第七章）；

+   当使用*shmat()*附加 System V 共享内存区域并使用*shmdt()*分离时（第四十八章）；以及

+   当使用*mmap()*创建内存映射并使用*munmap()*取消映射时（第四十九章）。

### 注意

虚拟内存的实现需要硬件支持，表现为*分页内存管理单元*（PMMU）。PMMU 将每个虚拟内存地址引用转换为相应的物理内存地址，并在特定的虚拟内存地址对应的页面不在 RAM 中时，通知内核发生页面错误。

虚拟内存管理将进程的虚拟地址空间与物理内存地址空间分开。这带来了许多优点：

+   进程之间以及进程与内核之间是相互隔离的，因此一个进程无法读取或修改另一个进程或内核的内存。这是通过为每个进程的页表条目指向 RAM 中不同的物理页面（或交换区）来实现的。

+   在适当的情况下，两个或多个进程可以共享内存。内核通过使不同进程中的页表条目引用相同的 RAM 页面来实现这一点。内存共享通常发生在两种常见情况下：

    +   执行相同程序的多个进程可以共享程序代码的单个（只读）副本。当多个程序执行相同的程序文件（或加载相同的共享库）时，便会隐式地执行这种共享。

    +   进程可以使用*shmget()*和*mmap()*系统调用显式请求与其他进程共享内存区域。这是为了进程间通信的目的。

+   便于实现内存保护方案；也就是说，页表条目可以标记，以指示相应页面的内容是否可读、可写、可执行，或者是这些保护的某种组合。当多个进程共享内存中的页面时，可以指定每个进程对内存的不同保护；例如，一个进程可能对某一页面具有只读访问权限，而另一个进程则具有读写访问权限。

+   程序员以及编译器和链接器等工具无需关心程序在 RAM 中的物理布局。

+   由于程序的部分内容不需要驻留在内存中，因此程序加载和运行更快。此外，进程的内存占用（即虚拟大小）可以超出 RAM 的容量。

虚拟内存管理的一个最终优势是，由于每个进程使用的 RAM 更少，可以同时在 RAM 中保持更多的进程。这通常会导致更好的 CPU 利用率，因为它增加了在任何时刻至少有一个进程可以被 CPU 执行的可能性。

## 栈和栈帧

栈在函数被调用和返回时线性地增长和缩小。对于 Linux 上的 x86-32 架构（以及大多数其他 Linux 和 UNIX 实现），栈位于内存的高端，并向下增长（朝向堆）。一个专用寄存器——*栈指针*，用于跟踪栈的当前顶部。每次调用一个函数时，栈上都会分配一个额外的栈帧，而这个栈帧会在函数返回时被移除。

### 注意

即使栈是向下增长的，我们仍然称栈的增长端为*顶部*，因为从抽象的角度来看，它就是这样的。栈增长的实际方向是一个（硬件）实现细节。一种 Linux 实现——HP PA-RISC 确实使用了一个向上增长的栈。

从虚拟内存的角度来看，栈段在分配栈帧时会增加大小，但在大多数实现中，栈帧被释放后它的大小不会减少（内存会在分配新栈帧时被重新使用）。当我们谈论栈段增长和缩小时，我们是从栈帧被添加到和从栈中移除的逻辑角度来考虑的。

有时，术语*用户栈*被用来区分我们在这里描述的栈和*内核栈*。内核栈是一个每个进程的内存区域，保存在内核内存中，用作在执行系统调用时内部调用的函数的栈。（内核不能使用用户栈来执行此目的，因为它位于未受保护的用户内存中。）

每个（用户）栈帧包含以下信息：

+   *函数参数和局部变量*：在 C 语言中，这些被称为*自动*变量，因为它们在函数调用时会自动创建。当函数返回时，这些变量也会自动消失（因为栈帧消失），这就是自动变量与`静态`（和全局）变量的主要语义区别：后者具有独立于函数执行的永久存在性。

+   *调用链接信息*：每个函数使用某些 CPU 寄存器，例如程序计数器，它指向下一个要执行的机器语言指令。每次一个函数调用另一个函数时，这些寄存器的副本会被保存在被调用函数的栈帧中，以便当函数返回时，可以恢复调用函数的相应寄存器值。

由于函数可以相互调用，因此栈上可能会有多个栈帧。（如果一个函数递归调用自身，那么栈上会有多个该函数的栈帧。）参见示例 6-1，在执行函数*square()*时，栈上会包含如图 6-3 所示的栈帧。

![进程栈示例](img/06-3_PROCESS-stack-frames-scale90.png.jpg)图 6-3. 进程栈示例

## 命令行参数 (*argc, argv*)

每个 C 程序必须有一个名为*main()*的函数，这是程序执行的起始点。当程序执行时，命令行参数（由 shell 解析的独立单词）通过两个参数传递给函数*main()*。第一个参数，*int argc*，表示命令行参数的数量。第二个参数，*char *argv[]*，是一个指向命令行参数的指针数组，每个参数都是一个以 null 终止的字符字符串。第一个字符串，即*argv[0]*，通常是程序本身的名称。*argv*中的指针列表以`NULL`指针结束（即*argv[argc]*为`NULL`）。

*argv[0]*包含用于调用程序的名称这一事实，可以用来执行一个有用的技巧。我们可以创建多个指向同一个程序的链接（即程序的不同名称），然后让程序查看*argv[0]*，根据调用它时使用的名称执行不同的操作。这个技术的一个示例是*gzip(1)*、*gunzip(1)*和*zcat(1)*命令，它们都是指向同一个可执行文件的链接。（如果我们采用这种技术，就必须小心处理用户可能通过一个名称不同于我们预期的链接来调用程序的情况。）

图 6-4 展示了与*argc*和*argv*相关的数据结构示例，当执行示例 6-2 中的程序时。在此图中，我们使用 C 语言表示法`\0`来表示每个字符串末尾的终止空字节。

![命令 necho hello world 的 argc 和 argv 值](img/06-4_PROCESS-cmd-line-args-scale90.png)图 6-4. 命令*necho hello world*的*argc*和*argv*值

示例 6-2 中的程序会回显其命令行参数，每行输出一个参数，前面会显示正在显示的*argv*元素。

示例 6-2. 回显命令行参数

```
`proc/necho.c`
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    int j;

    for (j = 0; j < argc; j++)
        printf("argv[%d] = %s\n", j, argv[j]);

    exit(EXIT_SUCCESS);
}
      `proc/necho.c`
```

由于 *argv* 列表由 `NULL` 值终止，我们可以按照 示例 6-2 的方式编写程序体，以便逐行输出命令行参数：

```
char **p;

for (p = argv; *p != NULL; p++)
    puts(*p);
```

*argc*/*argv* 机制的一个限制是，这些变量仅在 *main()* 函数的参数中可用。为了在其他函数中便捷地访问命令行参数，我们必须将 *argv* 作为参数传递给那些函数，或者设置一个全局变量指向 *argv*。

有几种非便携式的方法可以从程序中的任何位置访问部分或全部这些信息：

+   任何进程的命令行参数可以通过 Linux 特有的 `/proc/`*`PID`*`/cmdline` 文件读取，每个参数由一个空字节终止。（程序可以通过 `/proc/self/cmdline` 访问其自身的命令行参数。）

+   GNU C 库提供了两个全局变量，可以在程序的任何地方使用，以获取用于调用程序的名称（即第一个命令行参数）。第一个变量，*program_invocation_name*，提供了调用程序时使用的完整路径名。第二个变量，*program_invocation_short_name*，提供了去除任何目录前缀后的名称版本（即路径名的文件名部分）。这两个变量的声明可以通过在 `<errno.h>` 中定义宏 `_GNU_SOURCE` 来获得。

如 图 6-1 所示，*argv* 和 *environ* 数组，以及它们最初指向的字符串，位于进程栈上方的一个连续内存区域中。（我们将在下一节中描述 *environ*，它保存了程序的环境列表。）这个区域存储的字节总数有上限。SUSv3 规定使用 `ARG_MAX` 常量（在 `<limits.h>` 中定义）或调用 *sysconf(_SC_ARG_MAX)* 来确定此限制。（我们将在第 11.2 节中描述 *sysconf()*。）SUSv3 要求 `ARG_MAX` 至少为 `_POSIX_ARG_MAX`（4096）字节。大多数 UNIX 实现允许的限制远高于此值。SUSv3 没有规定实现是否将开销字节（用于终止空字节、对齐字节以及 *argv* 和 *environ* 指针数组）计入 `ARG_MAX` 限制中。

### 注意

在 Linux 上，`ARG_MAX` 历史上固定为 32 页（即在 Linux/x86-32 上为 131,072 字节），并包括了用于开销字节的空间。从内核版本 2.6.23 开始，可以通过 `RLIMIT_STACK` 资源限制来控制 *argv* 和 *environ* 使用的总空间限制，并且为 *argv* 和 *environ* 允许更大的限制。该限制的计算方法是 *execve()* 调用时生效的软 `RLIMIT_STACK` 资源限制的四分之一。更多详细信息，请参见 *execve(2)* 手册页。

许多程序（包括本书中的几个示例）使用 *getopt()* 库函数解析命令行选项（即以连字符开头的参数）。我们在 附录 B 中描述了 *getopt()*。

## 环境列表

每个进程都有一个相关的字符串数组，称为 *环境列表*，或简称 *环境*。这些字符串的每一个都以 *name=value* 形式进行定义。因此，环境表示一组可以存储任意信息的名称-值对。列表中的名称被称为 *环境变量*。

当一个新进程被创建时，它会继承父进程的环境副本。这是一种原始但常用的进程间通信方式——环境提供了一种从父进程向其子进程传递信息的方式。由于子进程在创建时获得父进程环境的副本，因此这种信息传递是单向的且只能进行一次。在子进程创建后，任一进程都可以改变自己的环境，而这些变化不会被另一个进程看到。

环境变量的一个常见用途是在 shell 中。通过将值放入自己的环境，shell 可以确保这些值被传递给它创建的执行用户命令的进程。例如，环境变量 `SHELL` 被设置为 shell 程序本身的路径名。许多程序将这个变量解释为在需要执行 shell 时应该执行的 shell 名称。

一些库函数允许通过设置环境变量来修改它们的行为。这使得用户能够控制应用程序的行为，而无需改变应用程序的代码或重新链接到相应的库。这个技术的一个例子由 *getopt()* 函数提供（见 附录 B），其行为可以通过设置 `POSIXLY_CORRECT` 环境变量来修改。

在大多数 shell 中，可以使用 *export* 命令向环境中添加值：

```
$ `SHELL=/bin/bash`
               *Create a shell variable*

$ `export SHELL`
                  *Put variable into shell process's environment*
```

在 *bash* 和 Korn shell 中，这可以简写为：

```
$ `export SHELL=/bin/bash`
```

在 C shell 中，使用 *setenv* 命令来代替：

```
% `setenv SHELL /bin/bash`
```

上述命令会永久地将值添加到 shell 的环境中，随后所有 shell 创建的子进程都将继承该环境。在任何时候，都可以使用 *unset* 命令（C shell 中为 *unsetenv*）删除环境变量。

在 Bourne shell 及其后代（例如 *bash* 和 Korn shell）中，可以使用以下语法将值添加到用于执行单个程序的环境中，而不影响父 shell（以及后续命令）：

```
$ ``*`NAME=value`*`` ``*`program`*``
```

这会将定义添加到仅执行命名程序的子进程的环境中。如果需要，可以在程序名称前添加多个赋值（由空格分隔）。

### 注意

*env* 命令使用修改过的 shell 环境列表运行程序。可以修改环境列表，以便从 shell 复制的列表中添加或删除定义。有关详细信息，请参阅 *env(1)* 手册页。

*printenv* 命令显示当前的环境列表。以下是它的输出示例：

```
$ `printenv`
LOGNAME=mtk
SHELL=/bin/bash
HOME=/home/mtk
PATH=/usr/local/bin:/usr/bin:/bin:.
TERM=xterm
```

我们将在后续章节中的适当位置描述大多数上述环境变量的用途（另见 *environ(7)* 手册页）。

从上述输出中可以看出，环境列表并未排序；列表中字符串的顺序只是最方便实现的排列方式。通常这不是问题，因为我们通常希望访问环境中的单个变量，而不是它们的有序序列。

任何进程的环境列表可以通过 Linux 特有的 /`proc/`*`PID`*`/environ` 文件进行查看，其中每个 *NAME=value* 对通过空字节结束。

### 从程序访问环境

在 C 程序中，可以使用全局变量 *char **environ* 访问环境列表。（C 运行时启动代码定义了这个变量，并将环境列表的位置分配给它。）像 *argv* 一样，*environ* 指向一个以 `NULL` 结尾的指针列表，指向以空字符结尾的字符串。图 6-5 显示了 *printenv* 命令上面显示的环境数据结构。

![进程环境列表数据结构示例](img/06-5_PROCESS-environ.png)图 6-5. 进程环境列表数据结构示例

示例 6-3 中的程序通过访问*environ*列出进程环境中的所有值。该程序产生与*printenv*命令相同的输出。该程序中的循环依赖于使用指针来遍历*environ*。虽然可以将*environ*视为数组（如我们在示例 6-2 中使用*argv*一样），但这不太自然，因为环境变量列表中的项目没有特定的顺序，并且没有与*argc*相对应的变量来指定环境列表的大小。（出于类似的原因，我们在图 6-5 中没有对*environ*数组的元素进行编号。）

示例 6-3. 显示进程环境

```
`proc/display_env.c`
#include "tlpi_hdr.h"

extern char **environ;

int
main(int argc, char *argv[])
{
    char **ep;

    for (ep = environ; *ep != NULL; ep++)
        puts(*ep);

    exit(EXIT_SUCCESS);
}
      `proc/display_env.c`
```

访问环境变量列表的另一种方法是为*main()*函数声明一个第三个参数：

```
int main(int argc, char *argv[], char *envp[])
```

该参数可以像处理*environ*一样处理，区别在于其作用范围局限于*main()*。虽然这个特性在 UNIX 系统上得到了广泛实现，但由于作用范围的限制，它的使用应该避免，因为在 SUSv3 中并未指定此特性。

*getenv()*函数从进程环境中检索单个值。

```
#include <stdlib.h>

char *`getenv`(const char **name*);
```

### 注意

返回指向（值）字符串的指针，如果没有该变量，则返回`NULL`。

给定一个环境变量的名称，*getenv()*会返回指向相应值字符串的指针。因此，在我们之前展示的示例环境中，如果指定`SHELL`作为*name*参数，则会返回*/bin/bash*。如果没有与指定名称匹配的环境变量，*getenv()*将返回`NULL`。

使用*getenv()*时，请注意以下可移植性考虑事项：

+   SUSv3 规定应用程序不应修改*getenv()*返回的字符串。这是因为（在大多数实现中）该字符串实际上是环境的一部分（即*name=value*字符串中的*value*部分）。如果需要更改环境变量的值，则可以使用*setenv()*或*putenv()*函数（下文将描述）。

+   SUSv3 允许*getenv()*的实现使用一个静态分配的缓冲区返回结果，该缓冲区可能会被后续的*getenv()*、*setenv()*、*putenv()*或*unsetenv()*调用覆盖。尽管*glibc*的*getenv()*实现没有以这种方式使用静态缓冲区，但需要保持由*getenv()*调用返回的字符串的便携程序，应在再次调用这些函数之前，将字符串复制到另一个位置。

#### 修改环境变量

有时候，进程修改其环境是有用的。一种原因是为了做出更改，并使得该进程随后创建的所有子进程都能看到这种变化。另一个可能性是，我们希望设置一个变量，使其对要加载到该进程内存中的新程序可见（“execed”）。从这个角度看，环境不仅是进程间通信的一种形式，也是程序间通信的一种方式。（这一点将在第二十七章中进一步解释，我们会讲解 *exec()* 函数如何允许程序在同一进程中用新程序替换自身。）

*putenv()* 函数将一个新变量添加到调用进程的环境中，或者修改现有变量的值。

```
#include <stdlib.h>

int `putenv`(char **string*);
```

### 注意

成功时返回 0，错误时返回非零值。

*string* 参数是一个指向 *name=value* 形式字符串的指针。在 *putenv()* 调用之后，这个字符串将成为环境的一部分。换句话说，*string* 所指向的字符串不会被复制，而是 *environ* 中的一个元素将指向与 *string* 相同的位置。因此，如果我们随后修改 *string* 所指向的字节，这一变化将影响进程的环境。出于这个原因，*string* 不应是自动变量（即，在栈上分配的字符数组），因为一旦定义该变量的函数返回，这块内存区域可能会被覆盖。

注意，*putenv()* 在出错时返回非零值，而不是 -1。

*glibc* 实现的 *putenv()* 提供了一个非标准扩展。如果 *string* 不包含等号 (`=`)，那么由 *string* 标识的环境变量将从环境列表中移除。

*setenv()* 函数是添加变量到环境中的一种替代方式，替代 *putenv()*。

```
#include <stdlib.h>
int `setenv`(const char **name*, const char **value*, int *overwrite*);
```

### 注意

成功时返回 0，错误时返回 -1。

*setenv()* 函数通过为 *name=value* 形式的字符串分配一个内存缓冲区，并将 *name* 和 *value* 所指向的字符串复制到该缓冲区中，从而创建一个新的环境变量。请注意，我们不需要（实际上，不能）在 *name* 的末尾或 *value* 的开头提供等号，因为 *setenv()* 在将新定义添加到环境中时会自动添加该字符。

*setenv()* 函数在变量由 *name* 标识且 *overwrite* 的值为 0 时，不会改变环境。如果 *overwrite* 非零，则环境始终会被改变。

*setenv()* 函数复制其参数，这意味着，与 *putenv()* 不同，我们可以在随后修改 *name* 和 *value* 所指向的字符串内容，而不会影响环境。它还意味着，将自动变量作为 *setenv()* 的参数不会引发任何问题。

*unsetenv()* 函数将从环境中移除由 *name* 标识的变量。

```
#include <stdlib.h>

int `unsetenv`(const char **name*);
```

### 注意

成功时返回 0，错误时返回 -1。

与*setenv()*一样，*name*不应包含等号。

*setenv()*和*unsetenv()*都源自 BSD，并且比*putenv()*的使用范围小。虽然它们没有在原始的 POSIX.1 标准或 SUSv2 中定义，但它们被包含在 SUSv3 中。

### 注意

在*glibc* 2.2.2 之前的版本中，*unsetenv()*的原型是返回*void*。这是原始 BSD 实现中*unsetenv()*的原型，一些 UNIX 实现仍然遵循 BSD 原型。

有时，清空整个环境并用选定的值重新构建它是有用的。例如，我们可能会为了以安全的方式执行设置用户 ID 的程序而这么做（不要信任输入或环境）。我们可以通过将`NULL`赋值给*environ*来清除环境：

```
environ = NULL;
```

这正是*clearenv()*库函数所执行的步骤。

```
#define _BSD_SOURCE           /* Or: #define _SVID_SOURCE */
#include <stdlib.h>

int `clearenv`(void)
```

### 注意

成功时返回 0，错误时返回非零值

在某些情况下，使用*setenv()*和*clearenv()*可能会导致程序内存泄漏。我们在上面提到过，*setenv()*会分配一个内存缓冲区，并将其作为环境的一部分。当我们调用*clearenv()*时，它并不会释放这个缓冲区（它不能释放，因为它并不知道缓冲区的存在）。如果一个程序反复使用这两个函数，就会不断泄漏内存。实际上，这通常不会成为问题，因为一个程序通常只会在启动时调用*clearenv()*一次，用以移除从前一个程序（即调用*exec()*启动当前程序的程序）继承的所有环境条目。

### 注意

许多 UNIX 实现提供了*clearenv()*，但它并未在 SUSv3 中规定。SUSv3 规定，如果一个应用程序直接修改了*environ*（如同*clearenv()*所做的那样），则*setenv()*、*unsetenv()*和*getenv()*的行为是未定义的。（这样做的理由是，防止符合标准的应用程序直接修改环境变量，允许实现方完全控制它用来实现环境变量的数据结构。）SUSv3 允许应用程序清除其环境的唯一方式是获取所有环境变量的列表（通过从*environ*获取名称），然后使用*unsetenv()*逐一移除这些名称。

#### 示例程序

示例 6-4 展示了本节中讨论的所有函数的使用。该程序首先清除环境，然后添加任何作为命令行参数提供的环境定义。接着，它会：为一个名为`GREET`的变量添加定义（如果环境中尚未存在）；移除任何名为`BYE`的变量的定义；最后，打印当前的环境列表。下面是程序运行时生成的输出示例：

```
$ `./modify_env "GREET=Guten Tag" SHELL=/bin/bash BYE=Ciao`

GREET=Guten Tag
SHELL=/bin/bash
$ `./modify_env SHELL=/bin/sh BYE=byebye`

SHELL=/bin/sh
GREET=Hello world
```

如果我们将 `NULL` 赋值给 *environ*（如在 示例 6-4 中通过调用 *clearenv()* 所做的那样），那么我们会预期以下形式的循环（在程序中使用的那样）会失败，因为 **environ** 是无效的：

```
for (ep = environ; *ep != NULL; ep++)
    puts(*ep);
```

然而，如果 *setenv()* 和 *putenv()* 发现 *environ* 为 `NULL`，它们会创建一个新的环境列表并将 *environ* 设置为指向该列表，结果使得上述循环能够正确运行。

示例 6-4. 修改进程环境

```
     `proc/modify_env.c`
#define _GNU_SOURCE     /* To get various declarations from <stdlib.h> */
#include <stdlib.h>
#include "tlpi_hdr.h"

extern char **environ;

int
main(int argc, char *argv[])
{
    int j;
    char **ep;

    clearenv();         /* Erase entire environment */

    for (j = 1; j < argc; j++)
        if (putenv(argv[j]) != 0)
            errExit("putenv: %s", argv[j]);

    if (setenv("GREET", "Hello world", 0) == -1)
        errExit("setenv");

    unsetenv("BYE");

    for (ep = environ; *ep != NULL; ep++)
        puts(*ep);

    exit(EXIT_SUCCESS);
}
     `proc/modify_env.c`
```

## 执行非局部跳转：*setjmp()* 和 *longjmp()*

*setjmp()* 和 *longjmp()* 库函数用于执行 *非局部跳转*。术语 *非局部* 指的是跳转的目标位置位于当前执行的函数之外。

和许多编程语言一样，C 语言包含 `goto` 语句，虽然它可能会被滥用，使程序变得难以阅读和维护，但在某些情况下，它确实有助于使程序更简单、更快速，甚至两者兼备。

C 语言的 `goto` 有一个限制，即无法从当前函数跳转到另一个函数。然而，这种功能在某些情况下可能会非常有用。考虑一下错误处理中的常见场景：在一个深度嵌套的函数调用中，我们遇到了一个错误，需要通过放弃当前任务，回溯多个函数调用，然后在某个更高层的函数中继续执行（甚至可能是 *main()*）。为了实现这一点，我们可以让每个函数返回一个状态值，调用者检查并适当处理这个状态值。这是完全有效的，而且在许多情况下，这种方式是处理此类场景的理想方法。然而，在某些情况下，如果我们能够从嵌套函数调用的中间位置跳回到调用它的某个函数（立即调用者，或者调用者的调用者，依此类推），编程会更加简便。这正是 *setjmp()* 和 *longjmp()* 提供的功能。

### 注意

在 C 语言中，`goto` 不能用于在函数之间跳转的限制存在，是因为所有 C 函数都位于相同的作用域级别（即，标准 C 中没有函数声明的嵌套，虽然 *gcc* 允许作为扩展）。因此，给定两个函数 X 和 Y，编译器无法知道函数 X 的栈帧是否会在调用 Y 时存在于栈上，因此无法确定从函数 Y 到函数 X 的 `goto` 是否可能。在像 Pascal 这样的语言中，函数声明可以嵌套，并且允许从嵌套函数跳转到包含它的函数，函数的静态作用域使得编译器能够确定函数的动态作用域的某些信息。因此，如果函数 Y 在语法上嵌套在函数 X 中，编译器就知道，在调用 Y 时，函数 X 的栈帧已经在栈上，可以为从函数 Y 跳转到函数 X 中的某个位置生成代码。

```
#include <setjmp.h>

int `setjmp`(jmp_buf *env*);
```

### 注意

初始调用时返回 0，通过 *longjmp()* 返回时返回非零值。

```
void `longjmp`(jmp_buf *env*, int *val*);
```

调用 *setjmp()* 会为后续由 *longjmp()* 执行的跳转建立目标。这个目标正是 *setjmp()* 调用发生的程序位置。从编程角度来看，*longjmp()* 之后，它看起来就像是我们第二次从 *setjmp()* 调用中返回。我们通过 *setjmp()* 返回的整数值来区分第二次“返回”和第一次返回。初始的 *setjmp()* 返回 0，而后来的“伪”返回会提供 *longjmp()* 调用中 *val* 参数指定的值。通过为 *val* 参数使用不同的值，我们可以区分从程序中的不同位置跳转到相同目标。

如果没有检查，指定 *val* 参数为 0，会导致伪返回看起来像是初始的返回。因此，如果 *val* 被指定为 0，*longjmp()* 实际上会使用值 1。

两个函数都使用的 *env* 参数提供了使跳转得以实现的连接。*setjmp()* 调用将当前进程环境的各种信息保存到 *env* 中。这使得 *longjmp()* 调用可以执行伪返回，因为 *longjmp()* 必须指定相同的 *env* 变量。由于 *setjmp()* 和 *longjmp()* 调用位于不同的函数中（否则，我们可以使用简单的 `goto`），*env* 被声明为全局变量，或者在较少情况下，作为函数参数传递。

除了其他信息外，*env* 还存储了调用 *setjmp()* 时 *程序计数器* 寄存器（指向当前执行的机器语言指令）和 *栈指针* 寄存器（标记栈的顶部）的副本。这些信息使得随后的 *longjmp()* 调用能够完成两个关键步骤：

+   去除所有函数调用之间的堆栈帧，这些函数调用位于调用 *longjmp()* 的函数与之前调用 *setjmp()* 的函数之间。这一过程有时被称为“堆栈展开”，通过将堆栈指针寄存器重置为保存在 *env* 参数中的值来实现。

+   重置程序计数器寄存器，使程序从初始的 *setjmp()* 调用位置继续执行。再次，这通过使用保存在 *env* 中的值来实现。

#### 示例程序

示例 6-5 和 longjmp() 的使用") 演示了如何使用 *setjmp()* 和 *longjmp()*。该程序通过初始调用 *setjmp()* 设置了一个跳转目标。随后通过 `switch`（根据 *setjmp()* 返回的值）来判断我们是刚刚完成了从 *setjmp()* 的初次返回，还是在经历了 *longjmp()* 后回到了此处。如果返回值为 0——意味着我们刚刚完成了初次的 *setjmp()*——我们调用 *f1()*，而 *f1()* 会根据 *argc*（即命令行参数的数量）的值，选择是立刻调用 *longjmp()*，还是继续调用 *f2()*。如果达到了 *f2()*，它会立即执行 *longjmp()*。无论哪种情况，*longjmp()* 都会将程序带回 *setjmp()* 调用点。我们在两次 *longjmp()* 调用中使用不同的 *val* 参数，因此在 *main()* 中的 `switch` 语句可以判断跳转发生的函数，并打印出相应的信息。

当我们在没有任何命令行参数的情况下运行 示例 6-5 和 longjmp() 的使用") 时，我们看到的是：

```
$ `./longjmp`

Calling f1() after initial setjmp()
We jumped back from f1()
```

指定命令行参数会导致从 *f2()* 发生跳转：

```
$ `./longjmp x`

Calling f1() after initial setjmp()
We jumped back from f2()
```

示例 6-5. 演示 *setjmp()* 和 *longjmp()* 的使用

```
`proc/longjmp.c`
#include <setjmp.h>
#include "tlpi_hdr.h"

static jmp_buf env;

static void
f2(void)
{
    longjmp(env, 2);
}

static void
f1(int argc)
{
    if (argc == 1)
        longjmp(env, 1);
    f2();
}

int
main(int argc, char *argv[])
{
    switch (setjmp(env)) {
    case 0:     /* This is the return after the initial setjmp() */
        printf("Calling f1() after initial setjmp()\n");
        f1(argc);               /* Never returns... */
        break;                  /* ... but this is good form */

    case 1:
        printf("We jumped back from f1()\n");
        break;

    case 2:
        printf("We jumped back from f2()\n");
        break;
    }

    exit(EXIT_SUCCESS);
}
     `proc/longjmp.c`
```

#### 使用 *setjmp()* 的限制

SUSv3 和 C99 指定，*setjmp()* 的调用只能出现在以下上下文中：

+   作为选择或迭代语句的整个控制表达式（`if`、`switch`、`while` 等）；

+   作为一元 `!`（*not*）操作符的操作数，其中结果表达式是选择或迭代语句的整个控制表达式；

+   作为比较操作（`==`、`!=`、`<` 等）的一部分，其中另一个操作数是一个整数常量表达式，且结果表达式是选择或迭代语句的整个控制表达式；或者

+   作为一个独立的函数调用，而不是嵌入在某个更大的表达式中。

请注意，C 语言中的赋值语句不在上述列表中。以下形式的语句不符合标准：

```
s = setjmp(env);                    /* WRONG! */
```

这些限制是因为作为常规函数实现的*setjmp()*不能保证有足够的信息来保存所有寄存器和临时堆栈位置的值，以便在执行*longjmp()*之后能够正确恢复它们。因此，允许仅在不需要临时存储的简单表达式中调用*setjmp()*。

#### 滥用*longjmp()*

如果*env*缓冲区被声明为全局变量（这在实践中是典型的），那么可能会执行以下步骤：

1.  调用一个使用*setjmp()*来在全局变量*env*中建立跳转目标的函数*x()*。

1.  从函数*x()*中返回。

1.  调用一个做*longjmp()*并使用*env*的函数*y()*。

这是一个严重的错误。我们不能在一个已经返回的函数中进行*longjmp()*。考虑到*longjmp()*试图对堆栈做的事情——它试图将堆栈展开回一个已经不存在的帧——我们就会意识到这会导致混乱。如果幸运的话，我们的程序会直接崩溃。然而，依据堆栈的状态，其他可能性包括无限的调用-返回循环，或者程序表现得就像它真的从一个当前没有执行的函数中返回一样。（在多线程程序中，类似的滥用是从与*setjmp()*被调用的线程不同的线程中调用*longjmp()*。）

### 注意

SUSv3 规定，如果*longjmp()*在嵌套的信号处理程序内部被调用（即，在处理另一个信号的处理程序执行时被调用），那么程序行为是未定义的。

#### 优化编译器的问题

优化编译器可能会重新排列程序中指令的顺序，并将某些变量存储在 CPU 寄存器中，而不是 RAM 中。这类优化通常依赖于运行时控制流反映程序的词法结构。由于通过*setjmp()*和*longjmp()*执行的跳转操作是在运行时建立和执行的，并且不反映程序的词法结构，因此编译器优化器在执行任务时无法考虑这些跳转操作。此外，一些 ABI 实现的语义要求*longjmp()*恢复由早期的*setjmp()*调用保存的 CPU 寄存器的副本。这意味着经过优化的变量可能会因*longjmp()*操作而出现不正确的值。我们可以通过检查示例 6-6 交互的演示")中程序的行为来看到这一点。

示例 6-6。编译器优化与*longjmp()*交互的演示

```
`proc/setjmp_vars.c`
#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>

static jmp_buf env;

static void
doJump(int nvar, int rvar, int vvar)
{
    printf("Inside doJump(): nvar=%d rvar=%d vvar=%d\n", nvar, rvar, vvar);
    longjmp(env, 1);
}

int
main(int argc, char *argv[])
{
    int nvar;
    register int rvar;          /* Allocated in register if possible */
    volatile int vvar;          /* See text */

    nvar = 111;
    rvar = 222;
    vvar = 333;

    if (setjmp(env) == 0) {     /* Code executed after setjmp() */
        nvar = 777;
        rvar = 888;
        vvar = 999;
        doJump(nvar, rvar, vvar);

    } else {                    /* Code executed after longjmp() */

        printf("After longjmp(): nvar=%d rvar=%d vvar=%d\n", nvar, rvar, vvar);
    }

    exit(EXIT_SUCCESS);
}

      `proc/setjmp_vars.c`
```

当我们正常编译示例 6-6 交互的演示")中的程序时，我们会看到预期的输出：

```
$ `cc -o setjmp_vars setjmp_vars.c`

$ `./setjmp_vars`

Inside doJump(): nvar=777 rvar=888 vvar=999
After longjmp(): nvar=777 rvar=888 vvar=999
```

然而，当我们使用优化编译时，得到以下意外结果：

```
$ `cc -O -o setjmp_vars setjmp_vars.c`

$ `./setjmp_vars`

Inside doJump(): nvar=777 rvar=888 vvar=999
After longjmp(): nvar=111 rvar=222 vvar=999
```

在这里，我们看到在 *longjmp()* 之后，*nvar* 和 *rvar* 被重置为 *setjmp()* 调用时的值。这是因为优化器执行的代码重组在 *longjmp()* 的影响下被误解了。任何可能进行优化的局部变量都可能遭遇这种问题；这通常意味着指针变量以及任何简单类型的变量，如 *char*、*int*、*float* 和 *long*。

我们可以通过将变量声明为 `volatile` 来防止代码重组，这会告诉优化器不要对这些变量进行优化。在前面的程序输出中，我们看到变量 *vvar* 被声明为 `volatile`，即使在启用优化编译的情况下，它也被正确处理。

由于不同的编译器进行不同类型的优化，因此可移植的程序应该在调用 *setjmp()* 的函数中的所有上述类型的局部变量上使用 `volatile` 关键字。

如果我们为 GNU C 编译器指定 *-Wextra*（*额外警告*）选项，它会为 `setjmp_vars.c` 程序生成以下有用的警告：

```
$ `cc -Wall -Wextra -O -o setjmp_vars setjmp_vars.c`

setjmp_vars.c: In function `main':
setjmp_vars.c:17: warning: variable `nvar' might be clobbered by `longjmp' or `vfork'
setjmp_vars.c:18: warning: variable `rvar' might be clobbered by `longjmp' or `vfork'
```

### 注意

观察编译 `setjmp_vars.c` 程序时在启用和未启用优化情况下产生的汇编输出是很有指导意义的。*cc -S* 命令会生成一个扩展名为 *.s* 的文件，包含程序生成的汇编代码。

#### 尽量避免使用 *setjmp()* 和 *longjmp()*

如果 `goto` 语句可能使程序难以阅读，那么非局部的 `goto` 语句会使问题更加严重，因为它们可以在程序中的任何两个函数之间转移控制。出于这个原因，*setjmp()* 和 *longjmp()* 应该谨慎使用。在设计和编码时，通常值得花费额外的工作来设计一个避免使用这些函数的程序，因为这样的程序更易读，并且可能更具可移植性。话虽如此，我们在讨论信号时会重新审视这些函数的变体（*sigsetjmp()* 和 *siglongjmp()*，在从信号处理程序执行非局部跳转中描述），因为它们在编写信号处理程序时偶尔会很有用。

## 概述

每个进程都有一个独特的进程 ID，并记录其父进程的进程 ID。

进程的虚拟内存在逻辑上分为多个段：文本段、（已初始化和未初始化的）数据段、栈段和堆段。

栈由一系列帧组成，每当函数被调用时，都会添加一个新帧，函数返回时会移除相应的帧。每个帧包含单次函数调用的局部变量、函数参数以及调用链接信息。

程序启动时提供的命令行参数通过*argc*和*argv*参数传递给*main()*函数。按照惯例，*argv[0]*包含用于启动程序的名称。

每个进程都会收到其父进程环境列表的副本，这是一组名称-值对。全局变量*environ*和各种库函数允许进程访问和修改其环境列表中的变量。

*setjmp()*和*longjmp()*函数提供了一种从一个函数跳转到另一个函数的非局部 goto 方式（展开栈）。为了避免编译器优化带来的问题，在使用这些函数时，我们可能需要声明带有`volatile`修饰符的变量。非局部 goto 会使程序难以阅读和维护，应尽可能避免使用。

#### 进一步的信息

[Tanenbaum, 2007]和[Vahalia, 1996]详细描述了虚拟内存管理。Linux 内核的内存管理算法和代码在[Gorman, 2004]中有详细描述。

## 练习

1.  编译示例 6-1 (`mem_segments.c`)中的程序，并使用*ls -l*列出其大小。尽管程序包含一个大约 10MB 大小的数组（*mbuf*），但可执行文件的大小远小于这个。为什么会这样？

1.  编写一个程序，看看如果我们尝试*longjmp()*跳转到一个已经返回的函数会发生什么。

1.  使用*getenv()*、*putenv()*以及在必要时直接修改*environ*的代码，来实现*setenv()*和*unsetenv()*。你的*unsetenv()*版本应该检查是否存在多个环境变量的定义，并删除它们所有（这也是*glibc*版本的*unsetenv()*所做的）。
