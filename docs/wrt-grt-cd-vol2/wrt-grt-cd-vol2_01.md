# 第一章：**低级思维，高级编程**

*如果你想编写最好的高级语言代码，学习汇编语言吧。*

*—常见的编程建议*

![image](img/common01.jpg)

本书并没有教授任何革命性的东西。而是描述了一种经过时间考验、验证过的方法来编写优秀的代码——理解你编写的代码如何在真实机器上执行。通向这一理解的旅程始于这一章。在这一章中，我们将探讨以下主题：

+   程序员对典型编译器生成的代码质量的误解

+   为什么学习汇编语言仍然是一个好主意

+   在编写高级语言代码时如何保持低级思维

那么，事不宜迟，让我们开始吧！

### 1.1 关于编译器质量的误解

在个人计算机革命的初期，高性能软件是用汇编语言编写的。随着时间的推移，优化编译器不断改进，编译器的作者们开始声称，编译器生成的代码的性能与手工优化的汇编代码相差 10%到 50%。这样的声明推动了高级语言在 PC 应用程序开发中的兴起，并敲响了汇编语言的丧钟。许多程序员开始引用诸如“我的编译器达到了汇编语言速度的 90%，所以用汇编语言简直是疯狂”的统计数据。问题是，他们从未费心去编写手工优化的汇编版本应用程序来验证他们的说法。通常，他们对编译器性能的假设是错误的。更糟糕的是，当像 C 和 C++这样的语言的编译器成熟到能够生成非常好的输出代码时，程序员们开始偏好那些高级语言，如 Java、Python 和 Swift，这些语言要么是解释型（或半解释型）的，要么是拥有非常不成熟的代码生成器，生成糟糕的输出代码。

优化编译器的作者们并没有说谎。在合适的条件下，优化编译器*可以*生成几乎与手工优化的汇编语言代码一样优秀的代码。然而，高级语言（HLL）代码必须以合适的方式编写，才能达到这些性能水平。以这种方式编写高级语言代码需要对计算机如何操作和执行软件有深刻的理解。

### 1.2 为什么学习汇编语言仍然是一个好主意

当程序员们首次放弃汇编语言，转而使用高级语言时，他们通常理解所使用的高级语言的低级影响，并能够适当地选择高级语言语句。不幸的是，随后的程序员一代并没有掌握汇编语言的优势。因此，他们并没有能力明智地选择那些能够高效转化为机器代码的语句和数据结构。如果将他们的应用程序与相应的手工优化汇编语言程序的性能进行比较，结果无疑会证明其性能更差。

资深程序员意识到这个问题后，向新程序员提供了明智的建议：“如果你想学会写出优秀的高级语言代码，你需要学习汇编语言。”通过学习汇编语言，程序员可以理解他们代码的低级含义，并做出关于如何在高级语言中编写应用程序的明智决策。^(1) 第二章将进一步讨论汇编语言。

### 1.3 为什么学习汇编语言并非绝对必要

尽管任何全面的程序员学习编程汇编语言是个好主意，但这并不是写出优秀、高效代码的必要条件。最重要的是理解高级语言如何将语句翻译成机器代码，以便你可以选择合适的高级语言语句。虽然成为汇编语言的专家是一种方法，但这种方法需要相当多的时间和精力。

那么，问题是：“程序员是否可以仅研究机器的低级性质，改善他们编写的高级语言代码，而不必成为汇编语言专家？”根据前述观点，答案是有条件的肯定。这本书的目的就是教你写出优秀代码所需的知识，而不必成为汇编语言专家。

### 1.4 从低级角度思考

当 Java 在 1990 年代末期开始流行时，这门语言收到了以下类似的抱怨：

Java 的解释性代码让我在编写软件时需要更加小心；我不能像在 C/C++中那样使用线性查找。我必须使用像二分查找这样良好（且实现更困难）的算法。

这些语句展示了使用优化编译器的主要问题：它们使程序员变得懒惰。尽管优化编译器在过去几十年取得了巨大进展，但没有任何一个编译器能够弥补编写不良高级语言源代码的问题。

当然，许多初学者高级语言（HLL）程序员读过关于现代编译器优化算法多么神奇的文章，并假设编译器无论输入什么都会生成高效的代码。然而，事实并非如此：尽管编译器在将编写良好的高级语言代码转换为高效机器代码方面做得很好，但编写不良的源代码会妨碍编译器的优化算法。事实上，常常能听到 C/C++程序员称赞他们的编译器，却从未意识到由于他们编写的代码方式，编译器实际上做得很差。问题在于，他们从未真正查看过编译器从高级语言源代码生成的机器代码。他们假设编译器做得很好，因为他们被告知编译器生成的代码几乎与专家的汇编语言程序员所能生成的代码一样好。

#### 1.4.1 编译器的好坏取决于你提供的源代码

不用说，编译器不会改变你的算法来提高软件的性能。例如，如果你使用线性搜索而不是二分搜索，你不能指望编译器为你使用更好的算法。当然，优化器可能会通过一个常数因子（比如让你的代码速度加倍或三倍）来提高线性搜索的速度，但这种提高可能和使用更好的算法相比微不足道。实际上，很容易证明，在数据库足够大的情况下，通过没有优化的解释器执行二分搜索会比通过最佳编译器执行线性搜索更快。

#### 1.4.2 如何帮助编译器生成更好的机器代码

假设你已经为你的应用程序选择了最好的算法，并且你花费额外的费用购买了最好的编译器。有没有办法让你写的高级语言代码比你平常编写的更高效？一般来说，答案是肯定的。

编译器世界中一个最被保密的秘密就是，大多数编译器基准测试都是被操控的。大多数真实世界中的编译器基准测试都会指定一个算法，但具体的算法实现由编译器厂商来完成，并且这些厂商通常知道他们的编译器在处理特定代码序列时的表现，因此他们会编写出能生成最佳可执行文件的代码序列。

有些人可能觉得这是一种作弊行为，但其实并不是。如果编译器能够在正常情况下生成相同的代码序列（也就是说，这种代码生成技巧并不是专门为基准测试开发的），那么展示其性能是完全没有问题的。而且，如果编译器厂商能够使用类似的小技巧，那么你也完全可以。通过精心选择你在高级语言源代码中使用的语句，你可以“手动优化”编译器生成的机器代码。

手动优化有多个层级。在最抽象的层面上，你可以通过为软件选择更好的算法来优化程序。这种技术与编译器和语言无关。

降低抽象级别，下一步就是根据你使用的高级语言来手动优化代码，同时保持优化与该语言的具体实现无关。虽然这种优化可能不适用于其他语言，但它应该适用于同一种语言的不同编译器。

降低到另一个层次，你可以开始考虑如何构造代码，使得优化仅适用于某个特定的编译器厂商，或者仅适用于某个特定版本的编译器。

最后，在可能的最低层次，你可以考虑编译器发出的机器代码，并调整在 HLL 中编写语句的方式，以迫使编译器生成某些机器指令序列。Linux 内核就是这种方法的一个例子。传说中，内核开发者不断调整他们在 Linux 内核中编写的 C 代码，以控制 GNU C 编译器（GCC）所生成的 80x86 机器代码。

虽然这个开发过程可能有些被夸大，但有一点是肯定的：采用这种方法的程序员将能够从编译器中生成最优的机器代码。这种代码与合格的汇编语言程序员所写的代码相当，也是高级语言（HLL）程序员在辩论时提到的，认为编译器生成的代码可以与手写汇编语言相媲美的那种编译器输出。大多数人并不会为了编写 HLL 代码而走到这些极端，这点从未被提出作为论点。然而，事实仍然是，精心编写的 HLL 代码可以接近于高效的汇编代码。

编译器是否会生成和专家级汇编语言程序员所写的代码一样好，甚至更好？正确答案是否定的；毕竟，专家级汇编语言程序员总能查看编译器的输出并加以改进。然而，精心编写代码的程序员，如果使用像 C/C++ 这样的 HLL，仍然可以接近这一目标，只要他们编写的程序能够让编译器轻松地将其转换为高效的机器代码。因此，真正的问题是：“我该如何编写 HLL 代码，使编译器能够最有效地转换它？”嗯，回答这个问题正是本书的主题。但简短的答案是：“用汇编语言思考；用高级语言编写。”我们来快速看看如何做到这一点。

#### 1.4.3 在编写 HLL 代码时如何思考汇编语言

HLL 编译器将该语言中的语句翻译为一个或多个机器语言（或汇编语言）指令的序列。应用程序在内存中占用的空间大小，以及应用程序执行时所花费的时间，直接与编译器发出的机器指令的数量和类型相关。

然而，你可以通过两种不同的代码序列在 HLL 中实现相同的结果，这并不意味着编译器为每种方法生成相同的机器指令序列。HLL 中的 `if` 和 `switch/case` 语句就是经典的例子。大多数入门编程教材都建议将一连串的 `if-elseif-else` 语句等同于 `switch/case` 语句。考虑以下简单的 C 语言示例：

```

			switch( x )
    {
        case 1:
            printf( "X=1\n" );
            break;

        case 2:
            printf( "X=2\n" );
            break;

        case 3:
            printf( "X=3\n" );
            break;

        case 4:
            printf( "X=4\n" );
            break;

        default:
            printf( "X does not equal 1, 2, 3, or 4\n" );
    }

/* equivalent if statement */

    if( x == 1 )
        printf( "X=1\n" );
    else if( x== 2 )
        printf( "X=2\n" );
    else if( x==3 )
        printf( "X=3\n" );
    else if( x==4 )
        printf( "X=4\n" );
    else
        printf( "X does not equal 1, 2, 3, or 4\n" );
```

尽管这两个代码序列在语义上可能是等效的（也就是说，它们计算相同的结果），但不能保证编译器会为两者生成相同的机器指令序列。

哪一个会更好呢？除非你了解编译器如何将这些语句转换为机器代码，并且对不同机器之间的效率差异有基本的了解，否则你可能无法回答这个问题。完全理解编译器如何转换这两个序列的程序员可以对它们进行评估，然后根据预期输出代码的质量明智地选择其中一个。

通过在编写 HLL 代码时使用低级术语，程序员可以帮助优化编译器接近手工优化的汇编语言代码所达到的代码质量水平。遗憾的是，通常情况相反：如果程序员没有考虑 HLL 代码的低级影响，编译器很少会生成最优的机器代码。

### 1.5 编写高级语言代码

在编写高级语言代码时，如果用低级术语思考，其中一个问题是，按这种方式编写 HLL 代码几乎和编写汇编代码一样费劲。这消除了编写 HLL 程序时许多熟悉的好处，比如更快的开发时间、更好的可读性和更容易的维护。如果你正在牺牲使用 HLL 编写应用程序的好处，为什么不干脆从一开始就用汇编语言编写呢？

事实证明，使用低级术语思考并不会像你预期的那样大幅延长整体项目的进度。虽然它确实会减缓初期的编码过程，但最终生成的高级语言（HLL）代码仍然是可读的、可移植的，并且能够保持良好代码的其他特性。但更重要的是，它还会获得一些本来没有的效率。一旦代码编写完成，在软件开发生命周期（SDLC）的维护和增强阶段，你就不必再用低级术语去思考它了。简而言之，在初期软件开发阶段使用低级术语思考，既保留了低级和高级编码的优势（效率加上易于维护），又避免了相应的缺点。

### 1.6 跨语言的方法

虽然本书假设你至少熟悉一种命令式语言，但它并不是完全针对某一种语言的；其概念跨越了你使用的任何编程语言。为了帮助使示例更易理解，我们将使用多种语言的编程示例，诸如 C/C++、Pascal、BASIC、Java、Swift 和汇编语言。在展示示例时，我会详细解释代码的运行方式，这样即使你不熟悉特定的编程语言，也能通过阅读附带的描述理解其运作方式。

本书在各种示例中使用了以下语言和编译器：

+   **C/C++：** GCC 和微软的 Visual C++

+   **Pascal：** Borland 的 Delphi 和 Free Pascal

+   **汇编语言：** 微软的 MASM、HLA（高级汇编语言）和 Gas（GNU 汇编器）

+   **Basic：** 微软的 Visual Basic

如果你不习惯使用汇编语言，不用担心：80x86 汇编语言的入门教程和在线参考 (*[`www.writegreatcode.com/`](http://www.writegreatcode.com/)* )将帮助你读取编译器输出。如果你想扩展你对汇编语言的了解，可以查看本章末尾列出的资源。

### 1.7 额外提示

没有一本书能完全涵盖写出优秀代码所需的所有知识。因此，这本书专注于编写优秀软件最相关的领域，为那些有兴趣编写最佳代码的人提供 90%的解决方案。要获得剩下的 10%，您需要额外的帮助。以下是一些建议：

**成为一名精通汇编语言的程序员。** 至少精通一种汇编语言，将填补许多从这本书中无法获得的细节。如前所述，本书的目的是教你如何编写最佳代码，*而不是*成为一名汇编语言程序员。然而，额外的努力将提高你以低级语言思考的能力。

**学习编译器构造理论。** 虽然这是计算机科学中的一个高级话题，但没有比研究编译器背后的理论更好的方式来理解编译器如何生成代码。尽管有许多关于这个主题的教材，其中一些需要相当的先备知识。在购买任何书籍之前，请仔细审查，确定它是否以适合您技能水平的方式编写。您还可以在线搜索一些优秀的网络教程。

**学习高级计算机架构。** 机器组织和汇编语言编程是计算机架构学习的一个子集。虽然你可能不需要知道如何设计自己的 CPU，但学习计算机架构可能帮助你发现改进你编写的高级语言（HLL）代码的其他方法。

### 1.8 获取更多信息

Duntemann, Jeff. *《汇编语言逐步教程》*（第 3 版）。印第安纳波利斯：Wiley，2009 年。

Hennessy, John L.，David A. Patterson. *《计算机架构：定量方法》*（第 5 版）。沃尔瑟姆，马萨诸塞州：Morgan Kaufmann，2012 年。

Hyde, Randall. *《汇编语言的艺术》*（第 2 版）。旧金山：No Starch Press，2010 年。
