# 第二章：**你不应该学习汇编语言吗？**

![image](img/common01.jpg)

尽管本书将教你如何在不精通汇编语言的情况下编写更好的代码，但真正出色的高级语言程序员都知道汇编语言，而这种知识正是他们编写优秀代码的原因之一。如第一章所提到的，尽管本书能为你提供一个 90%的解决方案，帮助你编写优秀的高级语言代码，但要填补最后的 10%，你需要学习汇编语言。虽然教授汇编语言超出了本书的范围，但它仍然是一个重要的主题，值得讨论。因此，本章将探讨以下内容：

+   学习汇编语言的难点

+   高级汇编器及其如何使学习汇编语言变得更容易

+   如何使用现实世界的工具，如 Microsoft Macro Assembler (MASM)、Gas（Gnu Assembler）和 HLA（高级汇编语言），轻松学习汇编语言编程

+   汇编语言程序员如何*思考*（即汇编语言编程范式）

+   可用的资源，帮助你学习汇编语言编程

### 2.1 学习汇编语言的好处与障碍

学习汇编语言——*真正*学习汇编语言——有两个好处。首先，你将完全理解编译器能够生成的机器代码。通过掌握汇编语言，你将实现前面所述的 100%解决方案，并能够编写更好的高级语言代码。其次，当你的高级语言编译器即使在你的帮助下也无法生成最佳代码时，你将能够用汇编语言编写应用程序的关键部分。掌握本书接下来的章节，磨练你的高级语言技巧后，继续学习汇编语言是一个非常好的选择。

然而，学习汇编语言有一个难点。在过去，学习汇编语言是一个漫长、困难且令人沮丧的过程。汇编语言编程范式与高级语言编程有足够的差异，导致大多数人在学习汇编语言时会觉得自己像是从头开始。这非常令人沮丧，因为你已经能在 C/C++、Java、Swift、Pascal 或 Visual Basic 等编程语言中做到某些事情，但在汇编语言中却无法找到解决方案。

大多数程序员喜欢在学习新知识时能够应用以往的经验。不幸的是，传统的汇编语言学习方法往往迫使高级语言（HLL）程序员忘记他们过去所学的内容。与此相反，本书提供了一种方法，帮助你在学习汇编语言时高效利用现有的知识。

### 2.2 本书如何提供帮助

一旦你读完本书，你会发现有三个理由让学习汇编语言变得更加容易：

+   你会更有动力去学习它，因为你会理解这样做能帮助你编写更好的代码。

+   你将已经学习过五个简要的汇编语言入门（80x86、PowerPC、ARM、Java 字节码和微软 IL），所以即使你之前从未接触过，等你读完这本书时，你也会掌握一些汇编语言的知识。

+   你已经看到过编译器如何为所有常见的控制和数据结构生成机器代码，因此你已经学会了作为初学汇编语言程序员最困难的课题之一——如何用汇编语言实现那些在高级语言（HLL）中已经知道怎么做的事情。

尽管这本书不会教你如何成为一名专家级的汇编语言程序员，但大量的示例程序展示了编译器如何将高级语言翻译成机器代码，这些将让你了解许多汇编语言编程技巧。如果你决定在阅读完这本书后学习汇编语言，你会发现这些技巧很有用。

当然，如果你已经掌握了汇编语言，这本书会更容易阅读。然而，一旦你读完这本书，你也会发现汇编语言更容易掌握。由于学习汇编语言可能比读这本书更耗时，因此更有效的方式是先从这本书开始。

### 2.3 高级汇编器的拯救

早在 1995 年，我与加利福尼亚大学河滨分校计算机科学系主任进行了一次讨论。我感叹学生们在学习汇编课程时不得不重新开始，浪费宝贵的时间重新学习许多内容。随着讨论的深入，问题显然并不在于汇编语言本身，而是在于现有汇编器的语法（比如微软宏汇编器，或 MASM）。学习汇编语言不仅仅是学习几条机器指令。首先，你需要学习一种新的编程风格。掌握汇编语言不仅仅是理解几条机器指令的语义，更是要学会如何将这些指令组合起来解决现实世界中的问题。*这*才是最难的部分。

其次，*纯*汇编语言并不是你可以高效地一次学习几条指令的东西。即使是写最简单的程序，也需要相当的知识和一些几十条甚至更多的机器指令。当你将这些指令与学生在典型汇编课程中必须学习的所有其他机器组织知识结合时，往往需要几周的时间，才能准备好写出除了“填鸭式”简单应用程序以外的任何东西。

1995 年 MASM 的一个重要特点是支持类似于高阶语言的控制语句，如 `.if` 和 `.while`。虽然这些语句并非真正的机器指令，但它们确实允许学生在课程初期使用熟悉的编程结构，直到他们有足够的时间学习足够的低级机器指令，以便在他们的应用中使用。通过在学期初期使用这些高级结构，学生可以集中精力学习汇编语言编程的其他方面，而不必一次性吸收所有内容。这使得他们可以在课程中更早地开始编写代码，因此到学期结束时，他们能够覆盖更多的学习内容。

像 MASM（32 位 v6.0 及更高版本）这样的汇编器提供了类似于高阶语言中控制语句的功能——除了执行相同操作的传统低级机器指令外——这种汇编器被称为*高级汇编器*。理论上，借助一本使用这些高级汇编器教授汇编语言编程的合适教材，学生可以在课程的第一周就开始编写简单的程序。

像 MASM 这样的高级汇编器唯一的问题是，它们只提供了少数几个类似高阶语言的控制语句和数据类型。几乎所有其他内容对于熟悉高阶语言编程的人来说都是陌生的。例如，MASM 中的数据声明与大多数高阶语言中的数据声明完全不同。尽管存在类似高阶语言的控制语句，初学汇编的程序员仍然需要重新学习大量的信息。

### 2.4 高级汇编语言

在与我的系主任讨论之后，我意识到没有理由让汇编器不能采用更高层次的语法，而不改变汇编语言的语义。例如，考虑以下 C/C++ 和 Pascal 中声明整数数组变量的语句：

```

			int intVar[8]; // C/C++

var intVar: array[0..7] of integer; (* Pascal *)
```

现在考虑一下 MASM 对同一对象的声明：

```
intVar sdword 8 dup (?) ;MASM
```

尽管 C/C++ 和 Pascal 的声明各不相同，但汇编语言版本与两者的差异更加显著。一名 C/C++ 程序员即使从未见过 Pascal 代码，也能大致理解 Pascal 的声明，反之亦然。然而，Pascal 和 C/C++ 程序员可能完全无法理解汇编语言的声明。这只是高阶语言（HLL）程序员在学习汇编语言时面临的一个问题。

令人遗憾的是，汇编语言中的变量声明没有理由与高级语言中的声明如此截然不同。在最终的可执行文件中，汇编器使用何种语法来声明变量并不会造成任何差别。既然如此，为什么汇编器不使用更类似高级语言的语法，这样从高级语言转过来的程序员就能更容易学习汇编语言呢？思考这个问题让我开发了一种新的汇编语言，专门为那些已经掌握高级语言的学生设计，用于教学汇编语言编程，这种语言叫做*高级汇编语言（HLA）*。在 HLA 中，上述的数组声明看起来是这样的：

```
var intVar:int32[8]; // HLA
```

虽然语法与 C/C++和 Pascal 略有不同（实际上，它是两者的结合），但大多数高级语言（HLL）程序员大概能理解这个声明的含义。

HLA 设计的整体目的是提供一个尽可能类似传统（命令式）高级编程语言的汇编语言编程环境，同时不牺牲编写*真实*汇编语言程序的能力。语言中与机器指令无关的部分使用熟悉的高级语言语法，而机器指令仍然与底层的 80x86 机器指令一一对应。

使 HLA 尽可能类似于各种高级语言意味着，学习汇编语言编程的学生不需要花太多时间去适应一个截然不同的语法。相反，他们可以运用已有的高级语言知识，这使得学习汇编语言的过程更轻松、更快捷。

然而，单单一个舒适的声明语法和一些类似高级语言的控制语句并不足以让学习汇编语言变得尽可能高效。一个关于学习汇编语言的常见抱怨是，它对程序员几乎没有任何支持，程序员必须在编写汇编代码时不断重新发明轮子。例如，当使用 MASM 学习汇编语言时，你会很快发现，汇编语言并没有提供有用的输入输出功能，比如将整数值作为字符串打印到用户的控制台。汇编程序员必须自己编写这样的代码。不幸的是，编写一套体面的 I/O 例程需要相当复杂的汇编语言编程知识。获得这些知识的唯一途径是首先编写大量的代码，但在没有 I/O 例程的情况下这么做是非常困难的。因此，一个好的汇编语言教育工具也需要提供一套 I/O 例程，允许初学的汇编程序员在自己具备编写这些例程的编程能力之前，能够完成一些简单的 I/O 任务，比如读取和写入整数值。HLA 通过*HLA 标准库*实现了这一点，HLA 标准库是一个子程序和宏的集合，使得编写复杂应用程序变得非常容易。

由于 HLA 的流行以及它是一个免费、开源并且面向公共领域的产品，支持 Windows 和 Linux，因此本书在涉及汇编语言的编译器无关示例时，使用了 HLA 语法。尽管它已经有超过 20 年的历史，且仅支持 32 位的 Intel 指令集，但 HLA 仍然是学习汇编语言编程的极好方式。虽然最新的 Intel CPU 直接支持 64 位寄存器和操作，但学习 32 位汇编语言对 HLL 程序员而言，依然与学习 64 位汇编语言同样相关。

### 2.5 高级思维，低级编程

HLA 的目标是让初学者在编写低级代码时能够用高级语言的术语进行思考（换句话说，正好与本书试图教授的内容相反）。对于第一次接触汇编语言的学生来说，能够以高级语言的思维方式进行思考是一个天赐之物——他们可以在面对特定的汇编编程问题时，应用已经在其他语言中学到的技巧。以这种方式控制学生学习新概念的速度，可以使教育过程更高效。

最终，目标当然是学习低级编程范式。这意味着逐渐放弃类似高级语言（HLL）的控制结构，编写纯粹的低级代码（也就是“低级思维，低级编程”）。尽管如此，从“高层思维，低级编程”开始，是学习汇编语言编程的一个极好的渐进方式。

### 2.6 汇编编程范式（低级思维）

现在应该很清楚，汇编语言编程与常见的高级语言编程有很大的不同。幸运的是，在本书中，你不需要从头开始编写汇编语言程序。然而，如果你了解汇编程序是如何编写的，你将能够理解编译器为何生成特定的代码序列。为此，我将在这里花些时间描述汇编语言程序员（和编译器）如何“思考”。

汇编语言编程范式的最基本方面——也就是汇编编程如何实现的模型——是将大项目分解为机器可以处理的小任务。从根本上讲，CPU 每次只能执行一个小任务；即使对于复杂指令集计算机（CISC）也是如此。因此，像高级语言中那样的复杂操作必须被分解成机器可以直接执行的较小组件。举个例子，考虑以下 Visual Basic (VB) 赋值语句：

```
profits = sales - costOfGoods - overhead - commissions
```

没有任何实用的 CPU 会允许你将整个 VB 语句作为单个机器指令执行。相反，你必须将该赋值语句分解为一系列机器指令，计算其中的各个组成部分。例如，许多 CPU 提供了一个*减法*指令，可以让你从机器寄存器中减去一个值。由于该示例中的赋值语句包含三个减法操作，你将需要将赋值操作分解为至少三个不同的减法指令。

80x86 CPU 系列提供了一个相当灵活的减法指令：`sub()`。该指令允许以下几种形式（在 HLA 语法中）：

```

			sub( constant, reg );       // reg = reg - constant
sub( constant, memory );    // memory = memory - constant
sub( reg1, reg2 );          // reg2 = reg2 - reg1
sub( memory, reg );         // reg = reg - memory
sub( reg, memory );         // memory = memory - reg
```

假设原始 VB 代码中的所有标识符都代表变量，我们可以使用 80x86 `sub()` 和 `mov()` 指令来实现相同的操作，HLA 代码序列如下：

```

			// Get sales value into EAX register:

mov( sales, eax );

// Compute sales-costOfGoods (EAX := EAX - costOfGoods)

sub( costOfGoods, eax );

// Compute (sales-costOfGoods) - overhead
// (note: EAX contains sales-costOfGoods)

sub( overhead, eax );

// Compute (sales-costOfGoods-overhead)-commissions
// (note: EAX contains sales-costOfGoods-overhead)

sub( commissions, eax );

// Store result (in EAX) into profits:

mov( eax, profits );
```

这段代码将单一的 VB 语句分解为五个不同的 HLA 语句，每个语句都执行总计算的一部分。汇编语言编程范式背后的秘密是知道如何将像这样的复杂操作分解为一串简单的机器指令。我们将在第十三章中再次探讨这个过程。

高级语言（HLL）控制结构是另一个将复杂操作分解为简单语句序列的重要领域。例如，考虑以下 Pascal `if()` 语句：

```

			if( i = j ) then begin

    writeln( "i is equal to j" );

end;
```

CPU 不支持`if`机器指令。相反，您比较两个值，设置*条件码标志*，然后通过使用*条件跳转*指令测试这些条件码的结果。将高级语言`if`语句转换为汇编语言的常见方法是测试相反的条件（`i <> j`），然后跳过如果原始条件（`i = j`）评估为`true`时要执行的语句。例如，下面是将之前的 Pascal `if`语句转换为 HLA（使用纯汇编语言，即不使用高级语言样式的构造）的一个示例：

```

			    mov( i, eax );      // Get i's value into eax register
    cmp( eax, j );      // Compare eax to j's value
    jne skipIfBody;     // Skip body of if statement if i <> j

    << code to print string >>

skipIfBody:
```

随着高级语言控制结构中的布尔表达式变得越来越复杂，对应的机器指令数量也会增加。但这个过程保持不变。稍后，我们将看看编译器是如何将高级语言控制结构转换为汇编语言的（请参见第十三章和第十四章）。

将参数传递给过程或函数、访问这些参数，然后访问该过程或函数本地的其他数据，是汇编语言相较于典型的高级语言更为复杂的另一个领域。这是一个重要话题，但超出了本章的范围，因此我们将在第十五章中再次讨论。

最终，问题的关键是，当将算法从高级语言转换时，必须将问题分解成更小的部分，以便能够在汇编语言中进行编码。如前所述，好消息是，当您只是在阅读汇编代码时，您无需自己决定使用哪些机器指令——编译器（或汇编程序员）在最初创建代码时已经为您完成了这项工作。您所需要做的只是建立高级语言代码与汇编代码之间的对应关系。如何完成这一点是本书余下部分的主要内容。

### 2.7 获取更多信息

Bartlett, Jonathan. *《从零开始编程》*. 编辑：Dominick Bruno, Jr. 自费出版，2004 年。此书的较旧、免费的版本，使用 Gas 教授汇编语言编程，可以在网上找到：*[`www.plantation-productions.com/AssemblyLanguage/ProgrammingGroundUp-1-0-booksize.pdf`](http://www.plantation-productions.com/AssemblyLanguage/ProgrammingGroundUp-1-0-booksize.pdf)*。

Blum, Richard. *《专业汇编语言》*. 印第安纳波利斯：Wiley，2005 年。

Carter, Paul. *《PC 汇编语言》*. 自费出版，2019 年。*[`pacman128.github.io/static/pcasm-book.pdf`](https://pacman128.github.io/static/pcasm-book.pdf)*。

Duntemann, Jeff. *《汇编语言一步步》*. 第 3 版. 印第安纳波利斯：Wiley，2009 年。

Hyde, Randall. *《汇编语言的艺术》*. 第 2 版. 旧金山：No Starch Press，2010 年。

———. “Webster：在互联网上学习汇编语言的地方。”*[`plantation-productions.com/Webster/index.html`](http://plantation-productions.com/Webster/index.html)*。
