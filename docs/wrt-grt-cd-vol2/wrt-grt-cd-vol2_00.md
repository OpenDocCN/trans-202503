# 前言

![image](img/common01.jpg)

我们所说的*优秀代码*是什么意思？不同的程序员会有不同的看法。因此，提供一个能让每个人都满意的包罗万象的定义是不可能的。以下是本书将使用的定义：

优秀的代码是使用一致且优先考虑良好的软件特性编写的软件。特别是，优秀的代码遵循一套规则，这些规则指导程序员在将算法实现为源代码时所做的决策。

然而，正如我在*《编写优秀代码，第一卷：理解机器》*（以下简称*WGC1*）中提到的，几乎每个人都能达成共识的是，优秀代码具有一些共性特征。具体来说，优秀的代码：

+   高效使用 CPU（即，它很快）

+   高效使用内存（即，它很小）

+   高效使用系统资源

+   易于阅读和维护

+   遵循一致的风格指南

+   使用明确的设计，遵循已建立的软件工程规范

+   容易扩展

+   经过充分测试且稳健（即，它能够正常工作）

+   具有良好的文档

我们可以轻松地在这个列表中添加数十个条目。例如，一些程序员可能认为，优秀的代码必须具备可移植性，必须遵循一套特定的编程风格指南，或者必须用某种语言编写（或者*不能*用某种语言编写）。有些人可能认为优秀的代码必须尽可能简洁，而另一些人则认为它必须快速编写。还有一些人可能认为优秀的代码是在规定时间内按预算完成的。

鉴于优秀代码涉及的方面有很多——太多了，无法在一本书中完全描述——《编写优秀代码》系列的第二卷主要集中在其中一个方面：高效的性能。尽管效率可能并非软件开发努力的首要目标——也并非代码要成为优秀代码的必要条件——人们普遍认为低效的代码*不是*优秀代码。而低效正是现代应用程序的主要问题之一，因此这是一个需要强调的重要话题。

### 优秀代码的性能特征

随着计算机系统性能从兆赫兹提升到数百兆赫兹，再到千兆赫兹，计算机软件性能逐渐被其他问题所取代。如今，软件工程师常常会大声疾呼：“你永远不应该优化你的代码！”有趣的是，你很少听到软件*用户*说出这样的话。

尽管这本书描述了如何编写高效代码，但它并不是一本关于优化的书。*优化*是软件开发生命周期（SDLC）中的一个阶段，在这个阶段，软件工程师确定为什么他们的代码未能满足性能规范，并相应地进行优化。但不幸的是，如果他们直到优化阶段才考虑应用程序的性能，那么优化可能就不会实现实际效果。确保应用程序符合合理的性能基准的时间点是在 SDLC 的*开始*阶段，即设计和实现阶段。优化可以微调系统的性能，但它很少能带来奇迹。

虽然这句名言常常被归因于唐纳德·克努斯（Donald Knuth），是他使其广为人知，但最初是托尼·霍尔（Tony Hoare）说的：“过早优化是万恶之源。”这句话长期以来一直是那些忽视应用性能，直到 SDLC 的最后阶段才开始关注的工程师们的口号——在这个阶段，优化通常会因为经济或市场时间的原因而被忽视。然而，霍尔并没有说，“在应用程序开发的早期阶段关心性能是万恶之源。”他特别说的是*过早优化*，而那时的过早优化意味着在汇编语言代码中计算周期和指令——这并不是你在程序设计初期，代码库仍在不断变化时应该做的事情。因此，霍尔的评论是非常准确的。

以下是查尔斯·库克（Charles Cook）的一篇短文摘录（* [`bit.ly/38NhZkT`](https://bit.ly/38NhZkT) *），进一步描述了过度解读霍尔言论的问题：

我一直认为，这句名言常常导致软件设计师犯下严重错误，因为它被应用到了一个不同的问题领域，偏离了最初的意图。

这段话的完整版本是：“我们应该忘记小的效率问题，大约 97%的时间都不必考虑：过早优化是万恶之源。”我同意这一观点。在性能瓶颈明显之前，通常不值得花费大量时间在代码的微优化上。但是，相反地，在系统级别设计软件时，性能问题应该从一开始就被考虑进去。一个好的软件开发者会自动做到这一点，因为他们已经对性能问题可能导致的问题有了直觉。而一个经验不足的开发者则不会在意，错误地认为稍后在优化阶段做一些微调就能解决问题。

事实上，霍尔（Hoare）是在说，软件工程师应该先关心其他问题，比如良好的算法设计和实现，再去关注传统的优化问题，比如某条语句执行所需的 CPU 周期数。

尽管您肯定可以在优化阶段应用本书的许多概念，但这里大部分技术实际上需要在初始编码阶段应用。有经验的软件工程师可能会争辩说，这样做只会产生性能上的轻微改进。在某些情况下，这是正确的——但请记住，这些轻微的效果是累积的。如果您推迟到达“代码完成”时才实施这些想法，它们很可能永远不会出现在您的软件中。在已经工作的代码上实施这些变更是太麻烦了，也太冒险了。

### 本书的目标

本书（以及*WGC1*）试图填补当前一代程序员教育中的空白，以便他们能够编写高质量的代码。特别是，它涵盖了以下概念：

+   为什么考虑您的高级程序的低级执行方式是重要的

+   编译器如何从高级语言（HLL）语句生成机器码

+   编译器如何使用低级别、原始数据类型来表示各种数据类型

+   如何编写您的高级语言代码，以帮助编译器生成更好的机器码

+   如何利用编译器的优化功能

+   如何在编写高级语言代码时“思考”汇编语言（低级术语）

本书将教会您如何选择适当的高级语言语句，以便与现代优化编译器生成高效的机器码。在大多数情况下，不同的高级语言语句提供了许多实现给定结果的方法，其中一些在机器级别上自然比其他方法更有效。虽然有选择比较低效的语句序列背后可能存在非常好的理由（例如可读性），但事实上，大多数软件工程师并不了解高级语言语句的运行时成本，因此无法做出明智的选择。本书的目标就是改变这种现状。

再次强调，本书并非只讨论无论如何选择最高效的语句序列。而是要了解各种高级语言结构的成本，这样当面对多个选择时，您就可以明智地决定使用哪个序列最为合适。

### 章节组织

尽管您不需要成为汇编语言专家才能编写高效的代码，但您至少需要基本的汇编语言知识才能理解本书中的编译器输出。第一章和第二章讨论了学习汇编语言的几个方面，涵盖了常见误解、关于编译器的考虑以及可用的资源。第三章为 80x86 汇编语言提供了一个快速入门。在线附录（*[`www.randallhyde.com/`](http://www.randallhyde.com/)*）为 PowerPC、ARM、Java 字节码和公共中间语言（CIL）汇编语言提供了入门指南。

在第四章和第五章中，你将通过检查编译器输出，学习如何确定你的高级语言（HLL）语句的质量。这些章节描述了反汇编器、目标代码转储工具、调试器、各种 HLL 编译器选项用于显示汇编语言代码的功能以及其他有用的软件工具。

本书的其余部分，第六章至第十五章，描述了编译器如何为不同的 HLL 语句和数据类型生成机器码。掌握这些知识后，你将能够选择最合适的数据类型、常量、变量和控制结构，从而生成高效的应用程序。

### 假设和前提条件

本书的编写假设了你具备某些先前的知识。如果你的个人技能集符合以下要求，你将从本书中获得最大的收益：

+   你应该至少精通一种命令式（过程式）或面向对象的编程语言。这包括 C 和 C++、Pascal、Java、Swift、BASIC、Python 以及汇编语言，还包括 Ada、Modula-2 和 FORTRAN 等语言。

+   你应该能够根据一个小问题描述，设计并实现一个软件解决方案。大学或高等院校的一个学期或季度课程（或几个月的自学经验）应该足以做为准备。

+   你应该对计算机组织和数据表示有基本的理解。你应该了解十六进制和二进制数字系统。你应该理解计算机如何在内存中表示各种高级数据类型，如有符号整数、字符和字符串。尽管接下来的几章会提供机器语言的入门知识，但如果你已经掌握了这些信息，将会大有帮助。如果你觉得这一方面的知识有些薄弱，*WGC1*全面涵盖了计算机组织的相关内容。

### 本书的环境

虽然本书提供的是通用信息，但讨论的某些部分必然与系统相关。由于 Intel 架构的 PC 是目前使用最广泛的，因此当讨论特定的系统相关概念时，我将以此平台为例。然而，这些概念同样适用于其他系统和 CPU——比如旧款 Power Macintosh 系统中的 PowerPC CPU，手机、平板和单板计算机（SBC，例如 Raspberry Pi 或更高端的 Arduino 板）中的 ARM CPU，以及 Unix 系统中的其他 RISC CPU——尽管你可能需要针对你特定平台的示例进行一些额外的研究。

本书中的大多数示例可以在 macOS、Windows 和 Linux 下运行。在创建示例时，我尽量遵循标准库接口与操作系统的交互，只有在无法避免时才使用操作系统特定的调用。

本文中的大多数具体示例将在现代 Intel 架构（包括 AMD）CPU 上运行，支持 Windows、macOS 和 Linux 操作系统，配备适量的 RAM 和现代 PC 上常见的其他系统外设。即使是软件本身无法直接适用，这些概念也可以应用于 Mac、Unix 系统、单板计算机（SBC）、嵌入式系统甚至大型主机。

### 更多信息

Mariani, Rico. “性能设计。” 2003 年 12 月 11 日。*[`docs.microsoft.com/en-us/archive/blogs/ricom/designing-for-performance/`](https://docs.microsoft.com/en-us/archive/blogs/ricom/designing-for-performance/)*。

Wikipedia. “程序优化。” *[`en.wikipedia.org/wiki/Program_optimization/`](https://en.wikipedia.org/wiki/Program_optimization/)*。
