## **类型**

*哈丁曾说过：“成功仅靠计划是不够的，还必须即兴发挥。”我会即兴发挥。

—艾萨克·阿西莫夫，《基地》

![图片](img/common.jpg)

如第一章所述，类型声明了编译器如何解释和使用一个对象。在 C++程序中，每个对象都有一个类型。本章首先对基本类型进行详细讨论，然后介绍用户自定义类型。在这个过程中，你将学习到几种控制流结构。

### 基本类型

*基本类型*是最基本的对象类型，包括整数、浮点数、字符、布尔值、`byte`、`size_t`和`void`。有些人称这些基本类型为*原始*类型或*内建*类型，因为它们是核心语言的一部分，几乎总是可以使用。这些类型可以在任何平台上使用，但它们的特性，如大小和内存布局，取决于实现。

基本类型在两者之间取得了平衡。一方面，它们尝试映射 C++构造与计算机硬件之间的直接关系；另一方面，它们通过允许程序员编写一次代码并在多个平台上运行，从而简化了跨平台编程。接下来的部分将进一步介绍这些基本类型的细节。

#### *整型类型*

整型类型存储整数：即那些没有小数部分的数字。整型的四种大小是*short int*、*int*、*long int*和*long long int*。每种类型可以是有符号或无符号的。*有符号*变量可以是正数、负数或零，而*无符号*变量必须是非负数。

整型类型默认是有符号的`int`，这意味着你可以在程序中使用以下简写：`short`、`long`和`long long`，而不是`short int`、`long int`和`long long int`。表 2-1 列出了所有可用的 C++整型类型，指出每种类型是有符号还是无符号，跨平台时每种类型的大小（以字节为单位），以及每种类型的格式说明符。

**表 2-1：** 整型类型、大小和格式说明符

| **类型** | **有符号** | **字节大小** | **printf 格式说明符** |
| --- | --- | --- | --- |
| **32 位操作系统** | **64 位操作系统** |
| **Windows** | **Linux/Mac** | **Windows** | **Linux/Mac** |
| `Short` | 是 | 2 | 2 | 2 | 2 | `%hd` |
| `unsigned short` | 否 | 2 | 2 | 2 | 2 | `%hu` |
| `int` | 是 | 4 | 4 | 4 | 4 | `%d` |
| `unsigned int` | 否 | 4 | 4 | 4 | 4 | `%u` |
| `long` | 是 | 4 | 4 | 4 | 8 | `%ld` |
| `unsigned long` | 否 | 4 | 4 | 4 | 8 | `%lu` |
| `long long` | 是 | 8 | 8 | 8 | 8 | `%lld` |
| `unsigned long long` | 否 | 8 | 8 | 8 | 8 | `%llu` |

注意，整型类型的大小在不同平台上有所不同：64 位的 Windows 和 Linux/Mac 对于`long`整数的大小不同（分别是 4 和 8）。

通常，编译器会警告格式说明符和整数类型之间的不匹配。但在使用 `printf` 语句时，你必须确保格式说明符是正确的。这里列出格式说明符，以便在后续的示例中可以将整数打印到控制台。

**注意**

*如果你想强制使用保证的整数大小，可以使用 `<cstdint>` 库中的整数类型。例如，如果你需要一个恰好为 8、16、32 或 64 位的有符号整数，你可以使用 `int8_t`、`int16_t`、`int32_t` 或 `int64_t`。你可以找到符合要求的最快、最小、最大、有符号和无符号整数类型。但由于并非每个平台都可以使用这个头文件，所以你应仅在没有其他替代方案时使用 `cstdint` 类型。*

*字面量* 是程序中的硬编码值。你可以使用四种硬编码的 *整数* *字面量* 表示法：

**`二进制`** 使用前缀 `0b`

**`八进制`** 使用前缀 `0`

**`十进制`** 这是默认值

**`十六进制`** 使用前缀 `0x`

这四种不同的表示法都用于表示相同的整数集合。例如，列表 2-1 展示了如何使用每种非十进制表示法为多个整数变量赋值，并使用整数字面量。

```
#include <cstdio>

int main() {
  unsigned short a = 0b10101010; ➊
  printf("%hu\n", a);
  int b = 0123; ➋
  printf("%d\n", b);
  unsigned long long d = 0xFFFFFFFFFFFFFFFF; ➌
  printf("%llu\n", d);
}
--------------------------------------------------------------------------
170 ➊
83 ➋
18446744073709551615 ➌
```

*列表 2-1：一个分配多个整数变量并用适当格式说明符打印它们的程序*

该程序使用每种非十进制整数表示法（如二进制 ➊、八进制 ➋ 和十六进制 ➌），并通过 `printf` 打印每个值，使用适当的格式说明符，具体见表 2-1。每个 `printf` 的输出会作为以下注释出现。

**注意**

*整数字面量可以包含任意数量的单引号（'），以提高可读性。这些单引号会被编译器完全忽略。例如，`1000000` 和 `1'000'000` 都是等于一百万的整数字面量。*

有时，打印无符号整数的十六进制表示法或（很少）八进制表示法是有用的。你可以分别使用 `printf` 格式说明符 `%x` 和 `%o`，如列表 2-2 所示。

```
#include <cstdio>

int main() {
  unsigned int a = 3669732608;
  printf("Yabba %x➊!\n", a);
  unsigned int b = 69;
  printf("There are %u➋,%o➌ leaves here.\n", b➍, b➎);
}
--------------------------------------------------------------------------
Yabba dabbad00➊!
There are 69➋,105➌ leaves here.
```

*列表 2-2：一个使用无符号整数的八进制和十六进制表示法的程序*

十进制 `3669732608` 的十六进制表示为 `dabbad00`，它出现在输出的第一行，作为十六进制格式说明符 `%x` ➊ 的结果。十进制的 69 在八进制中是 105。无符号整数格式说明符 `%u` ➋ 和八进制整数格式说明符 `%o` ➌ 分别对应于 ➍ 和 ➎ 的参数。`printf` 语句将这些数值 ➋➌ 替换到格式字符串中，输出信息为 `这里有 69,105 片叶子`。

**警告**

*八进制前缀源自 B 语言，当时 PDP-8 计算机和八进制字面量非常普遍。C 语言及其扩展 C++延续了这个可疑的传统。你必须小心，例如在硬编码邮政编码时：*

```
int mit_zip_code = 02139; // Won't compile
```

*去掉十进制字面量中的前导零，否则它们将不再是十进制数。这行代码无法编译，因为 9 不是八进制数字。*

默认情况下，整数字面量的类型是以下之一：`int`、`long` 或 `long long`。整数字面量的类型是这三种类型中最小的那一个。（这是由语言定义的，并会由编译器强制执行。）

如果你想要更多控制，可以为整数字面量提供*后缀*来指定其类型（后缀不区分大小写，因此你可以选择自己喜欢的样式）：

+   `unsigned` 后缀 `u` 或 `U`

+   `long` 后缀 `l` 或 `L`

+   `long long` 后缀 `ll` 或 `LL`

你可以将 `unsigned` 后缀与 `long` 或 `long long` 后缀结合使用，以指定符号性和大小。表 2-2 显示了后缀组合可能的类型。允许的类型用勾号（✓）表示。对于二进制、八进制和十六进制字面量，你可以省略 `u` 或 `U` 后缀。这些用星号（*）表示。

**表 2-2：** 整数后缀

| **类型** | **(无)** | **l/L** | **ll/LL** | **u/U** | **ul/UL** | **ull/ULL** |
| --- | --- | --- | --- | --- | --- | --- |
| `int` | ✓ |  |  |  |  |  |
| `long` | ✓ | ✓ |  |  |  |  |
| `long long` | ✓ | ✓ | ✓ |  |  |  |
| `unsigned int` | * |  |  | ✓ |  |  |
| `unsigned long` | * | * |  | ✓ | ✓ |  |
| `unsigned long long` | * | * | * | ✓ | ✓ | ✓ |

最小允许的类型仍然适应整数字面量的类型即为结果类型。这意味着，在所有允许的类型中，最小的类型将适用。例如，整数字面量 `112114` 可以是 `int`、`long` 或 `long long`。由于 `int` 可以存储 112114，因此结果类型是 `int`。如果你真的希望使用 `long`，你可以指定 `112114L`（或 `112114l`）。

#### *浮点类型*

浮点类型存储的是实数的近似值（在我们的定义中，实数可以是任何有小数点和分数部分的数字，例如 0.33333 或 98.6）。虽然无法在计算机内存中精确表示任意实数，但可以存储一个近似值。如果这让你难以相信，只需想一想像 π 这样的数字，它有无限多的位数。考虑到计算机内存是有限的，你怎么可能表示无限多的位数呢？

与所有类型一样，浮点类型占用有限的内存，这被称为类型的*精度*。浮点类型的精度越高，近似实数时就越准确。C++ 提供了三种精度级别的近似：

`**float**` 单精度

`**double**` 双精度

`**long double**` 扩展精度

与整数类型一样，每种浮点数表示方式都依赖于实现。此部分不会详细讨论浮点类型，但请注意，这些实现中有许多细微差别。

在主要的桌面操作系统中，`float`类型通常有 4 字节的精度。`double`和`long double`类型通常有 8 字节的精度（*双精度*）。

大多数不涉及科学计算应用的用户可以放心忽略浮点表示的细节。在这种情况下，一个好的通用规则是使用`double`。

**注意**

*对于那些无法忽略细节的用户，请查看与你的硬件平台相关的浮点规格。浮点存储和算术的主要实现概述在* IEEE 浮点运算标准 IEEE 754 中。

##### 浮点字面量

浮点字面量默认是双精度。如果需要单精度，使用`f`或`F`后缀；要使用扩展精度，使用`l`或`L`后缀，如下所示：

```
float a = 0.1F;
double b = 0.2;
long double c = 0.3L;
```

你还可以在字面量中使用科学计数法：

```
double plancks_constant = 6.62607004➊e-34➋;
```

不允许在*有效数字*（基数➊）和*后缀*（指数部分➋）之间有空格。

##### 浮点格式说明符

格式说明符`%f`显示带有小数位的`float`，而`%e`则以科学计数法显示相同的数字。你可以让`printf`决定使用这两者中的哪一个，使用`%g`格式说明符，它选择`%e`或`%f`中更紧凑的一个。

对于`double`，只需在所需的说明符前添加`l`（小写*L*）；对于`long double`，则添加`L`。例如，如果你想要一个带有小数位的`double`，你可以指定`%lf`、`%le`或`%lg`；对于`long double`，则指定`%Lf`、`%Le`或`%Lg`。

请参见列出 2-3，该示例探讨了打印浮点数的不同选项。

```
#include <cstdio>

int main() {
  double an = 6.0221409e23; ➊
  printf("Avogadro's Number:  %le➋ %lf➌ %lg➍\n", an, an, an);
  float hp = 9.75; ➎
  printf("Hogwarts' Platform: %e %f %g\n", hp, hp, hp);
}
--------------------------------------------------------------------------
Avogadro's Number:  6.022141e+23➋ 602214090000000006225920.000000➌
6.02214e+23➍
Hogwarts' Platform: 9.750000e+00 9.750000 9.75
```

*列出 2-3：一个打印多个浮点数的程序*

本程序声明了一个名为`an`的`double` ➊。格式说明符`%le` ➋ 给出科学计数法`6.022141e-23`，而`%lf` ➌ 给出了十进制表示`602214090000000006225920.000000`。`%lg` ➍ 说明符选择了科学计数法`6.02214e-23`。名为`hp`的`float` ➎ 使用`%e`和`%f`说明符产生类似的`printf`输出。但格式说明符`%g`决定提供十进制表示 9.75，而不是科学计数法。

一般来说，使用`%g`来打印浮点类型。

**注意**

*实际上，你可以省略`double`格式说明符前的`l`前缀，因为`printf`会将`float`类型的参数提升为`double`精度。*

#### *字符类型*

字符类型用于存储人类语言数据。六种字符类型包括：

`**char**` 默认类型，始终为 1 字节。可能是有符号也可能是无符号。（示例：ASCII。）

`**char16_t**` 用于 2 字节字符集。（示例：UTF-16。）

`**char32_t**` 用于 4 字节字符集。（示例：UTF-32。）

`**signed char**` 与`char`相同，但保证为有符号。

`**unsigned char**` 与`char`相同，但保证为无符号。

`**wchar_t**` 大到足以容纳实现区域中最大字符。（示例：Unicode。）

`char`、`signed char` 和 `unsigned char` 被称为*窄字符*，而 `char16_t`、`char32_t` 和 `wchar_t` 被称为*宽字符*，这是由于它们相对的存储需求。

##### 字符常量

*字符常量* 是单个常量字符。所有字符都被单引号（`' '`）括起来。如果字符不是 `char` 类型，你还必须提供一个前缀：`L` 表示 `wchar_t`，`u` 表示 `char16_t`，`U` 表示 `char32_t`。例如，`'J'` 声明了一个 `char` 常量，而 `L'J'` 声明了一个 `wchar_t` 常量。

##### 转义序列

有些字符不会在屏幕上显示。相反，它们会强制显示执行一些操作，比如将光标移动到屏幕左侧（回车符）或将光标向下移动一行（换行符）。其他字符虽然会显示在屏幕上，但它们是 C++ 语言语法的一部分，如单引号或双引号，因此你必须非常小心地使用它们。为了将这些字符放入 `char` 中，你可以使用 *转义序列*，如 表 2-3 中所列。

**表 2-3：** 保留字符及其转义序列

| **值** | **转义序列** |
| --- | --- |
| 换行符 | `\n` |
| 水平制表符 | `\t` |
| 垂直制表符 | `\v` |
| 退格符 | `\b` |
| 回车符 | `\r` |
| 换页符 | `\f` |
| 响铃符 | `\a` |
| 反斜杠 | `\\` |
| 问号 | `?` 或 `\?` |
| 单引号 | `\'` |
| 双引号 | `\"` |
| 空字符 | `\0` |

##### Unicode 转义字符

你可以使用 *通用字符名称* 来指定 Unicode 字符常量，并且你可以通过两种方式来形成通用字符名称：前缀 `\u` 后跟 4 位十六进制 Unicode 码点，或者前缀 `\U` 后跟 8 位十六进制 Unicode 码点。例如，你可以将字符 `A` 表示为 `'\u0041'`，将啤酒杯字符 ![Image](img/fig38_1.jpg) 表示为 `U'\U0001F37A'`。

##### 格式说明符

`char` 的 `printf` 格式说明符是 `%c`。`wchar_t` 的格式说明符是 `%lc`。

列表 2-4 初始化了两个字符常量 `x` 和 `y`。你可以使用这些变量来构建 `printf` 调用。

```
#include <cstdio>

int main() {
  char x = 'M';
  wchar_t y = L'Z';
  printf("Windows binaries start with %c%lc.\n", x, y);
}
--------------------------------------------------------------------------
Windows binaries start with MZ.
```

*列表 2-4：一个程序，赋值给多个字符类型的变量并打印它们*

该程序输出 *Windows 二进制文件以 MZ 开头*。尽管 *M* 是窄字符 `char`，而 *Z* 是宽字符，但 `printf` 可以正常工作，因为程序使用了正确的格式说明符。

**注意**

*所有 Windows 二进制文件的前两个字节是字符 M 和 Z，这是对 MS-DOS 可执行文件格式设计者 Mark Zbikowski 的致敬*。

#### *布尔类型*

布尔类型有两种状态：真（true）和假（false）。唯一的布尔类型是 `bool`。整数类型和 `bool` 类型可以方便地进行转换：`true` 状态转换为 1，`false` 转换为 0。任何非零整数都转换为 true，0 转换为 `false`。

##### 布尔常量

要初始化布尔类型，你可以使用两个布尔常量：`true` 和 `false`。

##### 格式说明符

`bool` 类型没有格式说明符，但你可以在 `printf` 中使用 `int` 格式说明符 `%d` 来输出 `true` 为 `1`，`false` 为 `0`。原因是 `printf` 会将任何小于 `int` 的整型值提升为 `int`。列表 2-5 展示了如何声明一个布尔变量并检查其值。

```
#include <cstdio>

int main() {
  bool b1 = true;  ➊ // b1 is true
  bool b2 = false; ➋ // b2 is false
  printf("%d %d\n", b1, b2); ➌
}
--------------------------------------------------------------------------
1 0 ➌
```

*列表 2-5：使用 `printf` 语句打印 `bool` 变量*

你将 `b1` 初始化为 `true` ➊，将 `b2` 初始化为 `false` ➋。通过将 `b1` 和 `b2` 作为整数打印（使用 `%d` 格式说明符），你会得到 `b1` 为 1，`b2` 为 0 ➌。

##### 比较运算符

*运算符* 是对 *操作数* 执行计算的函数。操作数只是对象。（关于运算符的详细内容请参考 第 182 页的“逻辑运算符”部分。）为了能够使用 `bool` 类型给出有意义的示例，你将在本节快速了解比较运算符，在下一节了解逻辑运算符。

你可以使用多个运算符来构建布尔表达式。回忆一下，比较运算符接受两个参数并返回一个 `bool`。可用的运算符有相等（`==`）、不等（`!=`）、大于（`>`）、小于（`<`）、大于或等于（`>=`）以及小于或等于（`<=`）。

列表 2-6 展示了如何使用这些运算符来产生布尔值。

```
#include <cstdio>

int main() {
  printf(" 7 ==  7: %d➊\n", 7  ==  7➋);
  printf(" 7 !=  7: %d\n", 7  !=  7);
  printf("10 > 20: %d\n", 10 >  20);
  printf("10 >= 20: %d\n", 10 >= 20);
  printf("10 < 20: %d\n", 10 <  20);
  printf("20 <= 20: %d\n", 20 <= 20);
}
--------------------------------------------------------------------------
 7 ==  7: 1 ➊
 7 !=  7: 0
10 >  20: 0
10 >= 20: 0
10 <  20: 1
20 <= 20: 1
```

*列表 2-6：使用比较运算符*

每个比较产生一个布尔结果 ➋，并且 `printf` 语句将布尔值打印为 `int` ➊。

##### 逻辑运算符

*逻辑运算符* 对 `bool` 类型的布尔逻辑进行求值。你可以通过它们需要的操作数个数来分类运算符。*一元运算符* 需要一个操作数，*二元运算符* 需要两个，*三元运算符* 需要三个，以此类推。你还可以通过描述它们操作数的类型进一步对运算符进行分类。

一元 *取反* 运算符（`!`）接受一个操作数并返回其相反值。换句话说，`!true` 得到 `false`，而 `!false` 得到 `true`。

逻辑运算符与（`&&`）和或（`||`）是二元运算符。逻辑与仅在两个操作数都为 `true` 时返回 `true`。逻辑或只要任一操作数为 `true` 就返回 `true`。

**注意**

*当你读取布尔表达式时，`!` 读作“非”，例如“a 且 非 b”表示表达式 `a && !b`*。

逻辑运算符刚开始可能看起来让人困惑，但它们很快就变得直观。列表 2-7 展示了逻辑运算符的用法。

```
#include <cstdio>

int main() {
  bool t = true;
  bool f = false;
  printf("!true: %d\n", !t); ➊
  printf("true  &&  false: %d\n", t &&  f); ➋
  printf("true  && !false: %d\n", t && !f); ➌
  printf("true  ||  false: %d\n", t ||  f); ➍
  printf("false ||  false: %d\n", f ||  f); ➎
}
--------------------------------------------------------------------------
!true: 0 ➊
true  &&  false: 0 ➋
true  && !false: 1 ➌
true  ||  false: 1 ➍
false ||  false: 0 ➎
```

*列表 2-7：展示使用逻辑运算符的程序*

在这里，你可以看到取反运算符 ➊、逻辑与运算符 ➋➌ 和逻辑或运算符 ➍➎。

#### *std::byte 类型*

系统程序员有时需要直接处理*原始内存*，它是没有类型的位的集合。在这种情况下，使用`std::byte`类型，该类型可以在`<cstddef>`头文件中找到。`std::byte`类型允许进行按位逻辑运算（你将在第七章中遇到这些），除此之外几乎没有其他功能。将此类型用于原始数据而不是整型可以帮助避免常见的难以调试的编程错误。

请注意，与`<cstddef>`中的大多数其他基本类型不同，`std::byte`在 C 语言中没有完全对应的类型（即“C 类型”）。像 C++一样，C 语言有`char`和`unsigned char`。这些类型使用起来不那么安全，因为它们支持许多`std::byte`不支持的操作。例如，你可以对`char`执行算术运算（如加法`+`），但不能对`std::byte`执行类似的操作。奇怪的`std::`前缀称为*命名空间*，你将在“命名空间”一节中了解更多内容（见第 216 页）（现在，暂时将命名空间`std::`视为类型名称的一部分）。

**注意**

*关于如何发音*std*有两种观点。一种是将其视为首字母缩略词，发音为“ess-tee-dee”；另一种是将其视为首字母缩写，发音为“stood”。当提到`std`命名空间中的类时，通常会隐含命名空间运算符`::`。所以你可以将`std::byte`发音为“stood byte”，或者，如果你不喜欢简洁的表达方式，可以发音为“ess-tee-dee colon colon byte”。*

#### *size_t 类型*

你使用`size_t`类型，该类型也可以在`<cstddef>`头文件中找到，用来编码对象的大小。`size_t`对象保证它们的最大值足以表示所有对象的最大字节数。从技术上讲，这意味着`size_t`可能占用 2 个字节或 200 个字节，具体取决于实现。在实践中，它通常与 64 位架构上的`unsigned long long`相同。

**注意**

*`size_t`类型是 C 库头文件中的 C 类型，但它与 C++版本相同，后者位于`std`命名空间中。有时，你会看到（技术上正确的）构造`std::size_t`。*

##### sizeof

一元运算符`sizeof`接受一个类型操作数，并返回该类型的大小（以字节为单位）。`sizeof`运算符始终返回一个`size_t`。例如，`sizeof(float)`返回`float`类型所占的字节数。

##### 格式说明符

`size_t`的常用格式说明符是`%zu`（用于十进制表示）或`%zx`（用于十六进制表示）。列表 2-8 展示了你如何检查系统上多个整数类型的大小。

```
#include <cstddef>
#include <cstdio>

int main() {
  size_t size_c = sizeof(char); ➊
  printf("char: %zu\n", size_c);
  size_t size_s = sizeof(short); ➋
  printf("short: %zu\n", size_s);
  size_t size_i = sizeof(int); ➌
  printf("int: %zu\n", size_i);
  size_t size_l = sizeof(long); ➍
  printf("long: %zu\n", size_l);
 size_t size_ll = sizeof(long long); ➎
  printf("long long: %zu\n", size_ll);
}
--------------------------------------------------------------------------
char: 1 ➊
short: 2 ➋
int: 4 ➌
long: 4 ➍
long long: 8 ➎
```

*列表 2-8：一个打印多个整数类型字节大小的程序。（输出来自 Windows 10 x64 机器。）*

清单 2-8 评估`char` ➊、`short` ➋、`int` ➌、`long` ➍和`long long` ➎的`sizeof`，并使用`%zu`格式说明符打印它们的大小。结果将根据操作系统有所不同。回想一下表 2-1，每个环境定义了其自身的整数类型大小。特别注意清单 2-8 中`long`类型的返回值；Linux 和 macOS 定义了 8 字节的`long`类型。

#### *void*

`void`类型没有值的集合。因为`void`对象不能保存任何值，所以 C++不允许使用`void`对象。你在特殊情况下使用`void`，例如用于没有返回值的函数的返回类型。例如，`taunt`函数不返回任何值，因此它的返回类型声明为`void`：

```
#include <cstdio>

void taunt() {
  printf("Hey, laser lips, your mama was a snow blower.");
}
```

在第三章中，你将学习其他`void`类型的特殊用途。

### 数组

数组是具有相同类型变量的序列。*数组类型*包括元素类型和包含的元素数量。你可以将这些信息结合在一起，通过声明语法来表示：元素类型位于方括号前，方括号内包含数组的大小。

例如，下面一行声明了一个包含 100 个`int`对象的数组：

```
int my_array[100];
```

#### *数组初始化*

有一个简便的方法可以用花括号初始化数组的值：

```
int array[] = { 1, 2, 3, 4 };
```

你可以省略数组的长度，因为它可以根据花括号内的元素数量在编译时推断出来。

#### *访问数组元素*

你可以通过使用方括号来访问数组元素，方括号中包含所需的索引。在 C++中，数组索引是从 0 开始的，因此第一个元素位于索引`0`，第十个元素位于索引`9`，依此类推。清单 2-9 演示了如何读取和写入数组元素。

```
#include <cstdio>

int main() {
  int arr[] = { 1, 2, 3, 4 }; ➊
  printf("The third element is %d.\n", arr[2]➋);
  arr[2] = 100; ➌
  printf("The third element is %d.\n", arr[2]➍);
}
--------------------------------------------------------------------------
The third element is 3\. ➋
The third element is 100\. ➍
```

*清单 2-9：一个索引数组的程序*

这段代码声明了一个名为`arr`的四元素数组，包含元素`1`、`2`、`3`和`4` ➊。在下一行 ➋，它打印第三个元素。然后，它将第三个元素赋值为 100 ➌，所以当它重新打印第三个元素 ➍时，值为`100`。

#### *for 循环概览*

`for`循环让你重复（或迭代）执行语句指定次数。你可以规定一个起始点和其他条件。*初始化语句*在第一次迭代之前执行，因此你可以在`for`循环中初始化使用的变量。*条件表达式*是在每次迭代之前评估的表达式。如果它的结果为`true`，则继续迭代。如果为`false`，则`for`循环终止。*迭代语句*在每次迭代后执行，当你需要增加变量以覆盖一系列值时，这很有用。`for`循环的语法如下：

```
for(init-statement; conditional; iteration-statement) {
  --snip--
}
```

例如，清单 2-10 展示了如何使用`for`循环查找数组中的最大值。

```
#include <cstddef>
#include <cstdio>

int main() {
  unsigned long maximum = 0; ➊
 unsigned long values[] = { 10, 50, 20, 40, 0 }; ➋
  for(size_t i=0; i < 5; i++) { ➌
    if (values[i] > maximum➍) maximum = values[i]; ➎
  }
  printf("The maximum value is %lu", maximum); ➏
}
--------------------------------------------------------------------------
The maximum value is 50 ➏
```

*清单 2-10：查找数组中包含的最大值*

你将`maximum` ➊初始化为可能的最小值；这里是 0，因为它是无符号的。接下来，你初始化数组`values` ➋，并使用`for`循环 ➌对其进行迭代。迭代器变量`i`的范围从 0 到 4（包括 4）。在`for`循环内，你访问`values`中的每个元素，并检查该元素是否大于当前的`maximum` ➍。如果是，你将`maximum`设置为该新值 ➎。当循环完成时，`maximum`将等于数组中的最大值，接着打印`maximum`的值 ➏。

**注意**

*如果你之前编写过 C 或 C++代码，你可能会想知道为什么列表 2-10 使用`size_t`而不是`int`作为`i`的类型。考虑到`values`理论上可能占用最大允许的存储空间，虽然`size_t`保证能够索引其中的任何值，而`int`不能。在实际中，这没有太大区别，但从技术上讲，`size_t`是正确的。*

##### 基于范围的 for 循环

在列表 2-10 中，你已经看到如何使用`for`循环 ➌来迭代数组的元素。通过使用*基于范围的 for 循环*，你可以省略迭代器变量`i`。对于某些对象，如数组，`for`理解如何迭代对象内的值范围。以下是基于范围的 for 循环的语法：

```
for(element-type➊ element-name➋ : array-name➌) {
  --snip--
}
```

你声明一个迭代器变量`element-name` ➋，其类型为`element-type` ➊。`element-type`必须与正在迭代的数组中的元素类型匹配。这个数组称为`array-name` ➌。

列表 2-11 用基于范围的`for`循环重构了列表 2-10。

```
#include <cstdio>

int main() {
  unsigned long maximum = 0;
  unsigned long values[] = { 10, 50, 20, 40, 0 };
  for(unsigned long value : values➊) {
    if (value➋ > maximum) maximum = value➌;
  }
 printf("The maximum value is %lu.", maximum);
}
--------------------------------------------------------------------------
The maximum value is 50.
```

*列表 2-11：用基于范围的 for 循环重构列表 2-10*

**注意**

*你将在第七章学习关于表达式的内容。现在，先把表达式想象成一些代码片段，它们对你的程序产生影响。*

列表 2-11 大大改进了列表 2-10。一眼看去，你就知道`for`循环在迭代`values` ➊。由于你已经丢弃了迭代器变量`i`，`for`循环的主体简化了；因此，你可以直接使用`values`中的每个元素 ➋➌。

慷慨使用基于范围的`for`循环。

##### 数组中的元素数量

使用`sizeof`运算符来获取数组的总字节大小。你可以使用一个简单的技巧来确定数组中的元素数量：将数组的大小除以单个元素的大小：

```
short array[] = { 104, 105, 32, 98, 105, 108, 108, 0 };
size_t n_elements = sizeof(array)➊ / sizeof(short)➋;
```

在大多数系统上，`sizeof(array)` ➊将计算为 16 字节，而`sizeof(short)` ➋将计算为 2 字节。无论`short`的大小如何，`n_elements`将始终初始化为 8，因为该因子会相互抵消。此计算发生在编译时，因此以这种方式计算数组的长度不会产生运行时成本。

`sizeof(x)/sizeof(y)`这种写法有点像黑客技术，但它在旧代码中广泛使用。在第二部分中，你将学习其他存储数据的选项，这些选项不需要外部计算它们的长度。如果你真的必须使用数组，你可以安全地通过`std::size`函数来获取元素的数量，该函数在`<iterator>`头文件中可用。

**注意**

*作为附加好处，`std::size`可以与任何公开`size`方法的容器一起使用。这包括第十三章中的所有容器。这在编写泛型代码时尤其有用，这是你将在第六章中探讨的主题。此外，如果你意外地传递了不支持的类型，如指针，它会拒绝编译。*

#### *C 风格字符串*

*字符串*是连续的字符块。*C 风格字符串*或*空字符终止字符串*在其末尾附加一个零字节（一个空字符）以表示字符串的结束。由于数组元素是连续的，你可以将字符串存储在字符类型的数组中。

##### 字符串字面量

通过将文本括在引号（`""`）中来声明字符串字面量。像字符字面量一样，字符串字面量支持 Unicode：只需在字面量前添加适当的前缀，如`L`。以下示例将字符串字面量分配给数组`english`和`chinese`：

```
char english[] = "A book holds a house of gold.";
char16_t chinese[] = u"\u4e66\u4e2d\u81ea\u6709\u9ec4\u91d1\u5c4b";
```

**注意**

*惊讶！你一直在使用字符串字面量：你的`printf`语句的格式化字符串就是字符串字面量。*

这段代码生成了两个变量：`english`，其内容是`A book holds a house of gold.`，以及`chinese`，其内容是书中自有黄金屋的 Unicode 字符。

##### 格式说明符

窄字符字符串（`char*`）的格式说明符是`%s`。例如，你可以将字符串包含到格式化字符串中，如下所示：

```
#include <cstdio>

int main() {
  char house[] = "a house of gold.";
  printf("A book holds %s\n ", house);
}
--------------------------------------------------------------------------
A book holds a house of gold.
```

**注意**

*将 Unicode 打印到控制台是出奇的复杂。通常，你需要确保选择了正确的代码页，而这个话题远远超出了本书的范围。如果你需要将 Unicode 字符嵌入到字符串字面量中，请查看`wprintf`，它位于`<cwchar>`头文件中。*

连续的字符串字面量会被连接在一起，任何中间的空格或换行都会被忽略。因此，你可以在源代码中将字符串字面量分布在多行，编译器会将它们当作一个整体来处理。例如，你可以将这个例子重构如下：

```
#include <cstdio>

int main() {
  char house[] = "a "
      "house "
      "of "  "gold.";
  printf("A book holds %s\n ", house);
}
--------------------------------------------------------------------------
A book holds a house of gold.
```

通常，当你的源代码中有一个长字符串字面量，会跨越多行时，这种结构只在提高可读性时有用。生成的程序是相同的。

##### ASCII

*美国标准信息交换码（ASCII）*表将整数分配给字符。表 2-4 显示了 ASCII 表。对于每个十进制（0d）和十六进制（0x）的整数值，都会显示相应的控制代码或可打印字符。

**表 2-4：** ASCII 表

| **控制代码** | **可打印字符** |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- |
| **0d** | **0x** | **Code** | **0d** | **0x** | **Char** | **0d** | **0x** | **Char** | **0d** | **0x** | **Char** |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | 0 | `NULL` | 32 | 20 | `SPACE` | 64 | 40 | `@` | 96 | 60 | `` ` `` |
| 1 | 1 | `SOH` | 33 | 21 | `!` | 65 | 41 | `A` | 97 | 61 | `a` |
| 2 | 2 | `STX` | 34 | 22 | `"` | 66 | 42 | `B` | 98 | 62 | `b` |
| 3 | 3 | `ETX` | 35 | 23 | `#` | 67 | 43 | `C` | 99 | 63 | `c` |
| 4 | 4 | `EOT` | 36 | 24 | `$` | 68 | 44 | `D` | 100 | 64 | `d` |
| 5 | 5 | `ENQ` | 37 | 25 | `%` | 69 | 45 | `E` | 101 | 65 | `e` |
| 6 | 6 | `ACK` | 38 | 26 | `&` | 70 | 46 | `F` | 102 | 66 | `f` |
| 7 | 7 | `BELL` | 39 | 27 | `'` | 71 | 47 | `G` | 103 | 67 | `g` |
| 8 | 8 | `BS` | 40 | 28 | `(` | 72 | 48 | `H` | 104 | 68 | `h` |
| 9 | 9 | `HT` | 41 | 29 | `)` | 73 | 49 | `I` | 105 | 69 | `i` |
| 10 | 0a | `LF` | 42 | 2a | `*` | 74 | 4a | `J` | 106 | 6a | `j` |
| 11 | 0b | `VT` | 43 | 2b | `+` | 75 | 4b | `K` | 107 | 6b | `k` |
| 12 | 0c | `FF` | 44 | 2c | `,` | 76 | 4c | `L` | 108 | 6c | `l` |
| 13 | 0d | `CR` | 45 | 2d | `-` | 77 | 4d | `M` | 109 | 6d | `m` |
| 14 | 0e | `SO` | 46 | 2e | `.` | 78 | 4e | `N` | 110 | 6e | `n` |
| 15 | 0f | `SI` | 47 | 2f | `/` | 79 | 4f | `O` | 111 | 6f | `o` |
| 16 | 10 | `DLE` | 48 | 30 | `0` | 80 | 50 | `P` | 112 | 70 | `p` |
| 17 | 11 | `DC1` | 49 | 31 | `1` | 81 | 51 | `Q` | 113 | 71 | `q` |
| 18 | 12 | `DC2` | 50 | 32 | `2` | 82 | 52 | `R` | 114 | 72 | `r` |
| 19 | 13 | `DC3` | 51 | 33 | `3` | 83 | 53 | `S` | 115 | 73 | `s` |
| 20 | 14 | `DC4` | 52 | 34 | `4` | 84 | 54 | `T` | 116 | 74 | `t` |
| 21 | 15 | `NAK` | 53 | 35 | `5` | 85 | 55 | `U` | 117 | 75 | `u` |
| 22 | 16 | `SYN` | 54 | 36 | `6` | 86 | 56 | `V` | 118 | 76 | `v` |
| 23 | 17 | `ETB` | 55 | 37 | `7` | 87 | 57 | `W` | 119 | 77 | `w` |
| 24 | 18 | `CAN` | 56 | 38 | `8` | 88 | 58 | `X` | 120 | 78 | `x` |
|  25  | 19 | `EM` | 57 | 39 | `9` | 89 | 59 | `Y` | 121 | 79 | `y` |
| 26 | 1a | `SUB` | 58 | 3a | `:` | 90 | 5a | `Z` | 122 | 7a | `z` |
| 27 | 1b | `ESC` | 59 | 3b | `;` | 91 | 5b | `[` | 123 | 7b | `{` |
| 28 | 1c | `FS` | 60 | 3c | `<` | 92 | 5c | `\` | 124 | 7c | `&#124;` |
| 29 | 1d | `GS` | 61 | 3d | `=` | 93 | 5d | `]` | 125 | 7d | `}` |
| 30 | 1e | `RS` | 62 | 3e | `>` | 94 | 5e | `^` | 126 | 7e | `~` |
| 31 | 1f | `US` | 63 | 3f | `?` | 95 | 5f | `_` | 127 | 7f | `DEL` |

ASCII 码 0 到 31 是 *控制字符*，用于控制设备。这些字符大多已经过时。当美国标准协会在 1960 年代正式化 ASCII 时，现代设备包括打字机、磁带读卡器和点阵打印机。一些仍在常用的控制代码如下：

+   0 (NULL) 被编程语言用作字符串终止符。

+   4 (EOT)，传输结束符，终止 shell 会话和 PostScript 打印机通信。

+   7 (BELL) 使设备发出声音。

+   8 (BS)，退格键，使设备擦除最后一个字符。

+   9（HT），水平制表符，将光标移动若干个空格到右侧。

+   10（LF），换行符，在大多数操作系统中用作行结束符。

+   13（CR），回车符，和 LF 结合使用，在 Windows 系统上作为行结束符。

+   26（SUB），替代字符/文件结束符/`ctrl`-Z，暂停当前正在执行的交互式进程，在大多数操作系统上均适用。

ASCII 表的其余部分，即从 32 到 127 的编码，是可打印字符。这些字符表示英文字母、数字和标点符号。

在大多数系统中，`char` 类型的表示为 ASCII。虽然这种关系并非严格保证，但它已成为事实上的标准。

现在是时候将你对 `char` 类型、数组、`for` 循环和 ASCII 表的知识结合起来了。示例 2-12 展示了如何创建一个包含字母的数组，打印结果，然后将该数组转换为大写字母并再次打印。

```
#include <cstdio>

int main() {
  char alphabet[27];➊
  for (int i = 0; i<26; i++) {
 alphabet[i] = i + 97; ➋
  }
  alphabet[26] = 0; ➌
  printf("%s\n", alphabet); ➍
  for (int i = 0; i<26; i++) {
    alphabet[i] = i + 65; ➎
  }
  printf("%s", alphabet); ➏
}
--------------------------------------------------------------------------
abcdefghijklmnopqrstuvwxyz➍
ABCDEFGHIJKLMNOPQRSTUVWXYZ➏
```

*示例 2-12：使用 ASCII 打印小写和大写字母*

首先，你声明一个长度为 27 的 `char` 数组来保存 26 个英文字母以及一个空终止符 ➊。接下来，使用 `for` 循环从 0 到 25 进行迭代，迭代器为 `i`。字母 *a* 在 ASCII 中的值为 97。通过将 97 加到迭代器 `i`，你可以生成 `alphabet` 中的所有小写字母 ➋。为了使 `alphabet` 成为一个空终止字符串，你将 `alphabet[26]` 设置为 0 ➌。然后，你打印结果 ➍。

接下来，你打印大写字母。字母 *A* 在 ASCII 中的值为 65，因此你需要相应地重置字母表中的每个元素 ➎ 并再次调用 `printf` ➏。

### 用户定义类型

*用户定义类型* 是用户可以定义的类型。用户定义类型的三大类如下：

**枚举类型** 是用户定义类型中最简单的一种。枚举类型可以取的值被限制为一组可能的值。枚举非常适合用来建模类别概念。

**类** 是功能更全面的类型，它使你能够灵活地将数据和函数配对。仅包含数据的类称为普通数据类；你将在本节中学习它们。

**联合类型** 是一种特别的用户定义类型。所有成员共享同一内存位置。联合类型很危险，容易被误用。

#### *枚举类型*

使用关键字 `enum class` 来声明枚举类型，后跟类型名称和它可以取的值的列表。这些值是任意的字母数字字符串，代表你想表示的任何类别。在底层，这些值只是整数，但它们使得你能够通过使用程序员定义的类型，而不是任意整数，从而编写更安全、更具表现力的代码。例如，示例 2-13 声明了一个名为 `Race` 的 `enum class`，它可以取七个值之一。

```
enum class Race {
  Dinan,
 Teklan,
  Ivyn,
  Moiran,
  Camite,
  Julian,
  Aidan
};
```

*示例 2-13：一个包含 Neal Stephenson 的《Seveneves》中的所有种族的枚举类*

要将枚举变量初始化为某个值，使用类型名称后跟两个冒号`::`和所需的值。例如，以下是如何声明变量`langobard_race`并将其值初始化为`Aidan`：

```
Race langobard_race = Race::Aidan;
```

**注意**

*从技术上讲，`enum class`是两种枚举类型之一：它被称为作用域枚举。为了与 C 语言兼容，C++还支持一种非作用域枚举，它使用`enum`而不是`enum class`声明。主要的区别在于作用域枚举要求在值之前使用枚举类型后跟`::`，而非作用域枚举则不需要。非作用域`enum`类比作用域枚举更不安全，因此除非绝对必要，最好避免使用它们。它们在 C++中主要是出于历史原因，特别是为了与 C 代码的互操作性。有关详细信息，请参阅 Scott Meyers 的《Effective Modern C++》，第 10 项。*

##### switch 语句

*switch 语句*根据*条件*的值将控制权转移到多个语句之一，该条件可以是整数类型或枚举类型。`switch`关键字表示一个 switch 语句。

switch 语句提供了条件分支。当执行 switch 语句时，控制权转移到符合条件的*case*，或者如果没有任何 case 匹配条件表达式，则转移到*default condition*。`case`关键字表示一个 case，而`default`关键字表示默认条件。

有点令人困惑的是，执行会继续直到 switch 语句的末尾或遇到`break`关键字。你几乎总是会在每个条件的末尾找到一个`break`。

switch 语句有很多组件。列表 2-14 展示了它们是如何组合的。

```
switch➊(condition➋) {
  case➌ (case-a➍): {
    // Handle case a here
    --snip--
  }➎ break➏;
  case (case-b): {
    // Handle case b here
    --snip--
  } break;
 // Handle other conditions as desired
    --snip--
  default➐: {
    // Handle the default case here
    --snip--
  }
}
```

*列表 2-14：展示 switch 语句如何组合在一起的草图*

所有的 switch 语句都以`switch`关键字 ➊开始，后面跟着括号中的`condition` ➋。每个 case 以`case`关键字 ➌开始，后面跟着该 case 的枚举或整数值 ➍。例如，如果`condition` ➋等于`case-a` ➍，则包含`Handle case a here`的代码块将执行。在每个 case 语句后 ➎，你需要放一个`break`关键字 ➏。如果`condition`与任何 case 都不匹配，则执行`default` case ➐。

**注意**

*每个 case 的括号是可选的，但强烈建议使用它们。如果不使用括号，有时会出现意外的行为。*

##### 使用枚举类的 switch 语句

列表 2-15 使用 switch 语句对`Race`枚举类进行操作，生成定制的问候语。

```
#include <cstdio>

enum class Race { ➊
  Dinan,
  Teklan,
  Ivyn,
  Moiran,
  Camite,
  Julian,
  Aidan
};

int main() {
  Race race = Race::Dinan; ➋

  switch(race) { ➌
  case Race::Dinan: { ➍
      printf("You work hard.");
    } break;➎
  case Race::Teklan: {
      printf("You are very strong.");
    } break;
  case Race::Ivyn: {
      printf("You are a great leader.");
    } break;
  case Race::Moiran: {
      printf("My, how versatile you are!");
    } break;
 case Race::Camite: {
      printf("You're incredibly helpful.");
    } break;
  case Race::Julian: {
      printf("Anything you want!");
    } break;
  case Race::Aidan: {
      printf("What an enigma.");
    } break;
  default: {
      printf("Error: unknown race!"); ➏
    }
  }
}
--------------------------------------------------------------------------
You work hard.
```

*列表 2-15：根据选择的`Race`打印不同问候语的程序*

`enum class` ➊声明了枚举类型`Race`，你用它将`race`初始化为`Dinan` ➋。switch 语句 ➌评估条件`race`以确定应该将控制权转交给哪个条件。由于你在代码的前面已经将其硬编码为`Dinan`，所以执行将转到 ➍，并打印`You work hard.` 在 ➎的`break`终止了 switch 语句。

在 ➏ 的 `default` 条件是一个安全功能。如果有人向枚举类中添加了新的 `Race` 值，程序将在运行时检测到该未知的种族并打印错误信息。

尝试将 `race` ➋ 设置为不同的值。输出结果是如何变化的？

#### *普通数据类（POD）*

*类*是用户定义的包含数据和函数的类型，它们是 C++ 的核心和灵魂。最简单的类是 *普通数据类（POD）*。POD 是简单的容器。你可以把它们看作是包含潜在 *不同* 类型元素的异构数组。类中的每个元素称为 *成员*。

每个 POD 都以关键字 `struct` 开头，后面跟着 POD 的名称。接下来，你列出成员的类型和名称。考虑以下声明具有四个成员的 `Book` 类：

```
struct Book {
  char name[256]; ➊
  int year; ➋
  int pages; ➌
  bool hardcover; ➍
};
```

一个 `Book` 包含一个 `char` 数组 `name` ➊、一个 `int year` ➋、一个 `int pages` ➌ 和一个 `bool hardcover` ➍。

你像声明其他变量一样声明 POD 变量：通过类型和名称。然后，你可以使用点运算符（`.`）访问变量的成员。

列表 2-16 使用了 `Book` 类型。

```
#include <cstdio>

struct Book {
  char name[256];
  int year;
  int pages;
  bool hardcover;
};

int main() {
  Book neuromancer; ➊
  neuromancer.pages = 271; ➋
  printf("Neuromancer has %d pages.", neuromancer.pages); ➌
}
--------------------------------------------------------------------------
Neuromancer has 271 pages. ➌
```

*列表 2-16：使用 POD 类型 `Book` 来读取和写入成员的示例*

首先，你声明一个 `Book` 类型的变量 `neuromancer` ➊。接着，使用点运算符（`.`）将 `neuromancer` 的页数设置为 271 ➋。最后，你打印一条消息并提取 `neuromancer` 的页数，再次使用点运算符 ➌。

**注意**

*POD 类型具有一些有用的低级特性：它们与 C 兼容，可以使用高效的机器指令来复制或移动它们，并且可以高效地表示在内存中。*

*C++ 保证成员在内存中是按顺序排列的，尽管某些实现要求成员沿着字边界对齐，这取决于 CPU 寄存器的长度。通常的做法是，在 POD 定义中按照从大到小的顺序排列成员。*

#### *联合体*

联合体是 POD 类型的“表亲”，它将所有成员放在同一位置。你可以把联合体看作是对一块内存的不同视图或解释。它们在某些低级场景中非常有用，比如在跨架构一致的结构体序列化中、处理与 C/C++ 互操作相关的类型检查问题，甚至在打包位域时。

列表 2-17 演示了如何声明一个联合体：只需使用 `union` 关键字代替 `struct`。

```
union Variant {
  char string[10];
  int integer;
  double floating_point;
};
```

*列表 2-17：一个示例联合体*

联合体 `Variant` 可以被解释为一个 `char[10]`、一个 `int` 或一个 `double`。它仅占用与其最大成员（在此情况下可能是 `string`）相同的内存空间。

你使用点运算符（`.`）来指定联合体的解释。从语法上看，这与访问 POD 成员类似，但在底层完全不同。

由于联合体的所有成员都在同一位置，你很容易导致数据损坏。清单 2-18 展示了这一危险。

```
#include <cstdio>

union Variant {
  char string[10];
  int integer;
  double floating_point;
};

int main() {
  Variant v; ➊
  v.integer = 42; ➋
  printf("The ultimate answer: %d\n", v.integer); ➌
  v.floating_point = 2.7182818284; ➍
  printf("Euler's number e:    %f\n", v.floating_point); ➎
  printf("A dumpster fire:     %d\n", v.integer); ➏
}
--------------------------------------------------------------------------
The ultimate answer: 42 ➌
Euler's number e:    2.718282 ➎
A dumpster fire:     -1961734133➏
```

*清单 2-18：使用联合体`Variant`的程序，参见清单 2-17*

你在➊声明了一个`Variant v`。接下来，你将`v`解释为整数，设置它的值为 42 ➋，并打印它 ➌。然后，你将`v`重新解释为`float`并重新赋值 ➍。你将它打印到控制台，所有看起来都很好 ➎。到目前为止一切正常。

灾难发生在你再次试图将`v`解释为整数时 ➏。你在将欧拉数 ➍ 赋值时覆盖了`v`的原始值（42） ➋。

这就是联合体的主要问题：你需要自己跟踪哪种解释是合适的。编译器不会帮助你。

你应该避免在除非极少数情况外使用联合体，在本书中你不会看到它们。第 379 页的“variant”讨论了当你需要多类型功能时，一些更安全的选项。

### 功能全面的 C++类

POD 类只包含数据成员，有时这就是你从类中需要的全部。然而，仅使用 POD 设计程序可能会带来很多复杂性。你可以通过*封装*来应对这种复杂性，封装是一种将数据与操作它的函数绑定的设计模式。将相关的函数和数据放在一起有助于简化代码，至少有两种方式。首先，你可以把相关代码放在一个地方，这有助于你推理程序的行为。你可以理解代码片段是如何工作的，因为它在一个地方描述了程序的状态以及代码如何修改该状态。其次，你可以使用称为*信息隐藏*的做法，将类的一些代码和数据隐藏起来，避免它们被程序的其他部分访问。

在 C++中，你通过在类定义中添加方法和访问控制来实现封装。

#### *方法*

*方法*是成员函数。它们在类、数据成员和某些代码之间创建了一个明确的连接。定义一个方法就像在类定义中添加一个函数一样简单。方法可以访问类的所有成员。

考虑一个示例类`ClockOfTheLongNow`，它跟踪年份。你定义一个`int year`成员和一个递增它的`add_year`方法：

```
struct ClockOfTheLongNow {
  void add_year() { ➊
    year++; ➋
  }
  int year; ➌
};
```

`add_year`方法的声明➊看起来像是任何一个不带参数且不返回值的函数。在方法内部，你会递增➋成员变量`year` ➌。清单 2-19 展示了如何使用该类来跟踪年份。

```
#include <cstdio>

struct ClockOfTheLongNow {
  --snip--
};

int main() {
  ClockOfTheLongNow clock; ➊
  clock.year = 2017; ➋
  clock.add_year(); ➌
  printf("year: %d\n", clock.year); ➍
  clock.add_year(); ➎
  printf("year: %d\n", clock.year); ➏
}
--------------------------------------------------------------------------
year: 2018 ➍
year: 2019 ➏
```

*清单 2-19：使用`ClockOfTheLongNow`结构的程序*

你声明了`ClockOfTheLongNow`实例`clock` ➊，然后将`clock`的`year`设置为`2017` ➋。接下来，你在`clock`上调用`add_year`方法 ➌，然后打印`clock.year`的值 ➍。你通过递增 ➎并再次打印 ➏来完成程序。

#### *访问控制*

*访问控制* 限制类成员的访问。*公共* 和 *私有* 是两种主要的访问控制。任何人都可以访问公共成员，但只有类本身可以访问其私有成员。所有 `struct` 成员默认都是公共的。

私有成员在封装中扮演着重要角色。再考虑一下 `ClockOfTheLongNow` 类。目前，`year` 成员可以从任何地方访问——无论是读取还是写入。假设你想防止 `year` 的值小于 2019。你可以通过两步来实现这一点：你将 `year` 设为私有，并要求所有使用该类的用户（消费者）只能通过类的方法与 `year` 进行交互。清单 2-20 说明了这种方法。

```
struct ClockOfTheLongNow {
  void add_year() {
    year++;
  }
  bool set_year(int new_year) { ➊
    if (new_year < 2019) return false; ➋
    year = new_year;
    return true;
  }
  int get_year() { ➌
    return year;
  }
private: ➍
  int year;
};
```

*清单 2-20：一个更新版的 `ClockOfTheLongNow`，来自 清单 2-19，封装了 `year`*

你已为 `ClockOfTheLongNow` 添加了两个方法：一个 *setter* ➊ 和一个 *getter* ➌，用于 `year`。你不允许 `ClockOfTheLongNow` 的用户直接修改 `year`，而是通过 `set_year` 设置 `year`。这种输入验证确保了 `new_year` 永远不会小于 2019 ➋。如果小于 2019，代码返回 `false` 并且 `year` 保持不变。否则，`year` 会被更新并返回 `true`。要获取 `year` 的值，用户需要调用 `get_year`。

你已经使用访问控制标签 `private` ➊ 禁止消费者访问 `year`。现在，用户只能在 `ClockOfTheLongNow` 内部访问 `year`。

##### class 关键字

你可以将 `struct` 关键字替换为 `class` 关键字，后者默认声明成员为 `private`。除了默认的访问控制外，使用 `struct` 和 `class` 关键字声明的类是一样的。例如，你可以通过以下方式声明 `ClockOfTheLongNow`：

```
class ClockOfTheLongNow {
  int year;
public:
  void add_year() {
    --snip--
  }
  bool set_year(int new_year) {
    --snip--
  }
  int get_year() {
    --snip--
  }
};
```

声明类的方式是个人风格问题。除了默认的访问控制外，`struct` 和 `class` 没有任何区别。我偏爱使用 `struct` 关键字，因为我喜欢先列出公共成员。但你会看到各种各样的约定，外面的人使用的风格不同。培养一种风格并坚持下去。

##### 初始化成员

既然已经封装了 `year`，你现在必须使用方法来与 `ClockOfTheLongNow` 交互。清单 2-21 展示了如何将这些方法组合成一个程序，尝试将年份设置为 2018。操作失败后，程序将年份设置为 2019，增加年份，然后打印最终的值。

```
#include <cstdio>

struct ClockOfTheLongNow {
  --snip--
};

int main() {
  ClockOfTheLongNow clock; ➊
  if(!clock.set_year(2018)) { ➋ // will fail; 2018 < 2019
   clock.set_year(2019); ➌
  }
  clock.add_year(); ➍
  printf(“year: %d”, clock.get_year());
}
--------------------------------------------------------------------------
year: 2020 ➎
```

*清单 2-21：使用 `ClockOfTheLongNow` 的程序，演示如何使用方法*

你声明了一个时钟 ➊ 并尝试将其年份设置为 2018 ➋。这失败了，因为 2018 小于 2019，程序随后将年份设置为 2019 ➌。你将年份增加了一次 ➍ 然后打印其值。

在第一章中，你看到未初始化的变量可能会包含随机数据，在调试时你可以观察到这一点。`ClockOfTheLongNow` 结构体也有同样的问题：当 `clock` 被声明 ➊ 时，`year` 是未初始化的。你希望保证 `year` 在*任何情况下*都不小于 2019。这种要求被称为*类不变性*：类的一个特性，它始终为真（即永远不会改变）。

在这个程序中，`clock` 最终达到了一个良好的状态 ➌，但你可以通过使用*构造函数*来做得更好。构造函数从对象生命周期的开始就初始化对象，并强制执行类的不变性。

#### *构造函数*

构造函数是具有特殊声明的特殊方法。构造函数的声明不指定返回类型，且它们的名称与类名相同。例如，清单 2-22 中的构造函数没有参数，并将 `year` 设置为 2019，这使得 `year` 默认为 2019。

```
#include <cstdio>

struct ClockOfTheLongNow {
  ClockOfTheLongNow() { ➊
    year = 2019; ➋
  }
  --snip--
};

int main() {
  ClockOfTheLongNow clock; ➌
  printf("Default year: %d", clock.get_year()); ➍
}
--------------------------------------------------------------------------
Default year: 2019 ➍
```

*清单 2-22：通过无参构造函数改进 清单 2-21*

该构造函数不接受任何参数 ➊，并将 `year` 设置为 2019 ➋。当你声明一个新的 `ClockOfTheLongNow` ➌ 时，`year` 默认为 2019。你通过 `get_year` 访问 `year` 并将其打印到控制台 ➍。

如果你想用自定义的年份初始化一个 `ClockOfTheLongNow` 呢？构造函数可以接受任意数量的参数。你可以实现任意多个构造函数，只要它们的参数类型不同。

考虑清单 2-23 中的例子，在其中你添加了一个接受 `int` 的构造函数。构造函数将 `year` 初始化为该参数的值。

```
#include <cstdio>

struct ClockOfTheLongNow {
  ClockOfTheLongNow(int year_in) { ➊
    if(!set_year(year_in)) { ➋
      year = 2019; ➌
    }
  }
 --snip--
};

int main() {
  ClockOfTheLongNow clock{ 2020 }; ➍
  printf("Year: %d", clock.get_year()); ➎
}
--------------------------------------------------------------------------
Year: 2020 ➎
```

*清单 2-23：通过另一个构造函数扩展 清单 2-22*

新的构造函数 ➊ 接受一个类型为 `int` 的 `year_in` 参数。你调用 `set_year` 并传入 `year_in` ➋。如果 `set_year` 返回 false，说明调用者提供了无效输入，你会用默认值 2019 覆盖 `year_in` ➌。在 `main` 中，你使用新构造函数 ➍ 创建一个时钟对象，然后打印结果 ➎。

`ClockOfTheLongNow clock{ 2020 };` 的调用被称为初始化。

**注意**

*你可能不喜欢无声地将无效的 `year_in` 实例修正为 2019 ➌。我也不喜欢这样。异常可以解决这个问题；你将在“异常”一节中学习它们，详见 第 98 页。*

#### *初始化*

*对象初始化*，或者简单地说，*初始化*，是将对象“唤醒”的过程。不幸的是，对象初始化的语法较为复杂。幸运的是，初始化过程是直接的。本节将 C++对象初始化的复杂过程提炼成易于理解的叙述。

##### 将基础类型初始化为零

让我们从初始化一个基础类型的对象为零开始。可以通过四种方式实现这一点：

```
int a = 0;    ➊// Initialized to 0
int b{};      ➋// Initialized to 0
int c = {};   ➌// Initialized to 0
int d;        ➍// Initialized to 0 (maybe)
```

其中三种方法是可靠的：使用文字值显式设置值 ➊，使用花括号`{}` ➋，或使用等号加花括号`= {}` ➌。没有额外标记声明对象 ➍ 是不可靠的；它只在某些特定情况下有效。即使你知道这些情况，也不应依赖这种行为，因为它会引起混淆。

使用花括号`{}`来初始化变量，不出所料，称为*花括号初始化*。C++初始化语法混乱的部分原因在于，语言最初从 C 语言发展而来，而 C 语言中的对象生命周期是原始的，后来发展为具有强大和丰富功能的对象生命周期。语言设计者将花括号初始化引入现代 C++，以帮助平滑过渡因初始化语法产生的尖锐问题。简而言之，无论对象的作用域或类型如何，*花括号初始化始终适用*，而其他表示法则不然。在本章后续部分，你将学习一条通用规则，鼓励广泛使用花括号初始化。

##### 将基本类型初始化为任意值

初始化为任意值类似于将基本类型初始化为零：

```
int e = 42;    ➊ // Initialized to 42
int f{ 42 };   ➋ // Initialized to 42
int g = { 42 };➌ // Initialized to 42
int h(42);     ➍ // Initialized to 42
```

有四种方法：等号 ➊、花括号初始化 ➋、等号加花括号初始化 ➌ 和圆括号 ➍。所有这些都会产生相同的代码。

##### 初始化 POD 类型

初始化 POD 的标记通常遵循基本类型的规则。示例 2-24 通过声明一个包含三个成员的 POD 类型，并使用不同的值初始化其实例，展示了它们的相似性。

```
#include <cstdint>

struct PodStruct {
  uint64_t a;
  char b[256];
  bool c;
};

int main() {
  PodStruct initialized_pod1{};    ➊   // All fields zeroed
  PodStruct initialized_pod2 = {}; ➋   // All fields zeroed

  PodStruct initialized_pod3{ 42, "Hello" }; ➌   // Fields a & b set; c = 0
  PodStruct initialized_pod4{ 42, "Hello", true }; ➍ // All fields set
}
```

*示例 2-24：一个展示多种方式初始化 POD 的程序*

将 POD 对象初始化为零类似于将基本类型的对象初始化为零。花括号 ➊ 和等号加花括号 ➋ 方法产生相同的代码：字段初始化为零。

**警告**

*你不能使用等号零方法来初始化 POD 类型。以下代码无法编译，因为在语言规则中明确禁止使用：*

```
PodStruct initialized_pod = 0;
```

##### 将 POD 初始化为任意值

你可以使用花括号初始化器将字段初始化为任意值。花括号初始化器中的参数必须与 POD 成员的类型匹配。参数从左到右的顺序与成员从上到下的顺序匹配。任何省略的成员都会被置为零。成员`a`和`b`在初始化`initialized_pod3` ➌ 后分别初始化为`42`和`Hello`，而`c`则被置为零（设置为 false），因为你在花括号初始化中省略了它。`initialized_pod4` ➍ 的初始化包括了`c`的参数（`true`），因此其值在初始化后被设置为 true。

等号加花括号初始化的工作方式完全相同。例如，你可以将 ➍ 替换为：

```
PodStruct initialized_pod4 = { 42, "Hello", true };
```

你只能从右到左省略字段，因此以下代码无法编译：

```
PodStruct initialized_pod4 = { 42, true };
```

**警告**

*你不能使用圆括号来初始化 POD 类型。以下代码无法编译：*

```
PodStruct initialized_pod(42, "Hello", true);
```

##### 初始化数组

你像初始化 POD 类型一样初始化数组。数组和 POD 声明的主要区别在于数组指定了长度。回想一下，这个参数写在方括号`[]`中。

当你使用花括号初始化器来初始化数组时，长度参数变得可选；编译器可以根据花括号初始化器中的参数数量推断出大小参数。

清单 2-25 展示了初始化数组的一些方法。

```
int main() {
  int array_1[]{ 1, 2, 3 };  ➊ // Array of length 3; 1, 2, 3
  int array_2[5]{};          ➋ // Array of length 5; 0, 0, 0, 0, 0
  int array_3[5]{ 1, 2, 3 }; ➌ // Array of length 5; 1, 2, 3, 0, 0
  int array_4[5];            ➍ // Array of length 5; uninitialized values
}
```

*清单 2-25：一个程序列出初始化数组的各种方式*

数组`array_1`的长度为三，元素值为 1、2 和 3 ➊。数组`array_2`的长度为五，因为你指定了长度参数 ➋。花括号初始化器为空，因此所有五个元素初始化为零。数组`array_3`的长度也是五，但花括号初始化器不为空。它包含三个元素，因此剩余的两个元素初始化为零 ➌。数组`array_4`没有花括号初始化器，因此它包含未初始化的对象 ➍。

**警告**

*`array_4`是否初始化实际上取决于与初始化基本类型相同的规则。对象的存储持续时间，你将在《对象的存储持续时间》章节中学习，位于第 89 页，决定了这些规则。如果你明确初始化，这些规则无需记忆*。

##### 完全特性的类

与基本类型和 POD 类型不同，完全特性的类*总是被初始化*。换句话说，完全特性类的构造函数在初始化过程中总是会被调用。调用哪个构造函数取决于在初始化时提供的参数。

清单 2-26 中的类有助于澄清如何使用完全特性的类。

```
#include <cstdio>

struct Taxonomist {
  Taxonomist() { ➊
    printf("(no argument)\n");
  }
  Taxonomist(char x) { ➋
    printf("char: %c\n", x);
  }
  Taxonomist(int x) { ➌
    printf("int: %d\n", x);
  }
  Taxonomist(float x) { ➍
    printf("float: %f\n", x);
  }
};
```

*清单 2-26：一个类在初始化时宣布其调用的构造函数*

`Taxonomist`类有四个构造函数。如果不提供参数，将调用无参数构造函数➊。如果在初始化时提供了`char`、`int`或`float`，则分别调用相应的构造函数：➋、➌或➍。在每种情况下，构造函数会通过`printf`语句提醒你。

清单 2-27 使用不同的语法和参数初始化了几个`Taxonomists`。

```
#include <cstdio>

struct Taxonomist {
  --snip--
};

int main() {
  Taxonomist t1; ➊
  Taxonomist t2{ 'c' }; ➋
  Taxonomist t3{ 65537 }; ➌
  Taxonomist t4{ 6.02e23f }; ➍
  Taxonomist t5('g'); ➎
 Taxonomist t6 = { 'l' }; ➏
  Taxonomist t7{}; ➐
  Taxonomist t8(); ➑
}
--------------------------------------------------------------------------
(no argument) ➊
char: c ➋
int: 65537 ➌
float: 602000017271895229464576.000000 ➍
char: g ➎
char: l ➏
(no argument) ➐
```

*清单 2-27：一个程序使用`Taxonomist`类的各种初始化语法*

如果没有任何花括号或圆括号，将调用无参数构造函数➊。与 POD 和基本类型不同，你可以依赖这种初始化，无论你在哪里声明该对象。使用花括号初始化器时，`char` ➋，`int` ➌和`float` ➍构造函数按预期调用。你还可以使用圆括号➎和等号加花括号语法➏；这些都会调用预期的构造函数。

尽管功能完整的类总是会被初始化，但有些程序员喜欢对所有对象使用相同的初始化语法以保持统一性。使用大括号初始化器时，这没有问题；默认构造函数会按预期被调用 ➐。

不幸的是，使用圆括号 ➑ 会导致一些令人惊讶的行为。你不会得到任何输出。

如果你稍微眯一下眼睛，这个初始化 ➑ 看起来像一个函数声明，事实上它就是一个。由于一些晦涩的语言解析规则，你所声明给编译器的是一个尚未定义的函数`t8`，它不接受任何参数，并返回一个`Taxonomist`类型的对象。哎呀。

**注意**

在第 244 页的*函数声明*部分详细讲解了函数声明。但目前，你只需知道你可以提供一个函数声明，定义函数的修饰符、名称、参数和返回类型，然后在稍后的定义中提供函数体*。

这个广为人知的问题被称为*最烦人的解析*，也是 C++社区将大括号初始化语法引入语言的主要原因之一。*窄化转换*是另一个问题。

##### 窄化转换

每当遇到隐式窄化转换时，大括号初始化会生成警告。这是一个很好的功能，可以帮助你避免一些严重的错误。考虑以下示例：

```
float a{ 1 };
float b{ 2 };
int narrowed_result(a/b); ➊ // Potentially nasty narrowing conversion
int result{ a/b };        ➋ // Compiler generates warning
```

将两个`float`字面量相除会得到一个 float 类型的结果。在初始化`narrowed_result` ➊时，编译器会默默地将`a/b`（0.5）的结果窄化为 0，因为你使用了圆括号`( )`来初始化。当你使用大括号初始化器时，编译器会生成警告 ➋。

##### 初始化类成员

你可以使用大括号初始化器来初始化类的成员，如此处所示：

```
struct JohanVanDerSmut {
  bool gold = true; ➊
  int year_of_smelting_accident{ 1970 }; ➋
  char key_location[8] = { "x-rated" }; ➌
};
```

`gold`成员使用等号初始化 ➊，`year_of_smelting_accident`使用大括号初始化 ➋，而`key_location`使用大括号加等号初始化 ➌。不能使用圆括号来初始化成员变量。

##### 准备好大括号

初始化对象的选项甚至让经验丰富的 C++程序员感到困惑。这里有一个通用的规则，可以简化初始化过程：*在所有地方都使用大括号初始化器*。大括号初始化器几乎在所有情况下都能按预期工作，并且能带来最少的意外。因此，大括号初始化也被称为*统一初始化*。本书的其余部分都会遵循这一指导原则。

**警告**

*在某些 C++标准库类中，你将打破使用大括号初始化器的规则。第二部分会清楚地阐明这些规则的例外情况。*

#### *析构函数*

一个对象的*析构函数*是它的清理函数。析构函数在对象销毁之前被调用。析构函数几乎从不被显式调用：编译器会确保每个对象的析构函数在适当的时候被调用。你通过使用波浪符`~`后跟类的名称来声明一个类的析构函数。

以下`Earth`类具有一个析构函数，打印`Making way for hyperspace bypass`：

```
#include <cstdio>
struct Earth {
  ~Earth() { // Earth's destructor
       printf("Making way for hyperspace bypass");
  }
}
```

定义析构函数是可选的。如果决定实现析构函数，则它不能接受任何参数。你可能希望在析构函数中执行的操作包括释放文件句柄、刷新网络套接字和释放动态对象。

如果没有定义析构函数，系统会自动生成一个默认析构函数。默认析构函数的行为是不会执行任何操作。

你将在“追踪对象生命周期”章节中学习更多关于析构函数的内容，详见第 96 页。

### 总结

本章介绍了 C++的基础知识，即其类型系统。你首先学习了基本类型，它们是所有其他类型的构建块。接着，你学习了用户定义的类型，包括`enum class`、POD 类和完全特性的 C++类。最后，你通过讨论构造函数、初始化语法和析构函数结束了对类的学习。

**命令行符号**

**2-1.** 创建一个`enum class Operation`，其值为`Add`、`Subtract`、`Multiply`和`Divide`。

**2-2.** 创建一个`struct Calculator`。它应该有一个构造函数，接受一个`Operation`。

**2-3.** 在`Calculator`上创建一个名为`int calculate(int a, int b)`的方法。调用时，该方法应根据构造函数的参数执行加法、减法、乘法或除法，并返回结果。

**2-4.** 尝试不同的方式初始化`Calculator`实例。

**进一步阅读**

+   *ISO 国际标准 ISO/IEC（2017 年）— C++编程语言*（国际标准化组织；瑞士日内瓦；* [`isocpp.org/std/the-standard/`](https://isocpp.org/std/the-standard/)）

+   *《C++程序设计语言》*，第 4 版，作者：Bjarne Stroustrup（Pearson Education，2013 年）

+   *《有效的现代 C++》*，作者：Scott Meyers（O’Reilly Media，2014 年）

+   *《C++简化：普通数据类型》*，作者：Andrew Koenig 和 Barbara E. Moo（Dr. Dobb’s，2002 年；[`www.drdobbs.com/c-made-easier-plain-old-data/184401508/`](http://www.drdobbs.com/c-made-easier-plain-old-data/184401508/)）
