# 第三章：使用 Ansible 配置 SSH

![](img/chapterart.png)

*SSH* 是一种协议和工具，提供从你自己的机器到远程主机的命令行访问。如果你正在管理一台或多台远程主机，最常见的访问方式是通过 SSH。大多数服务器可能是无头的，因此最简单的访问方式就是通过终端。由于 SSH 开放了主机访问权限，错误配置或默认安装可能导致未经授权的访问。与很多 Linux 服务一样，默认的安全设置对于大多数情况是足够的，但你还是应该知道如何提高安全性并进行自动化。作为一名工程师，你应该理解如何在主机或多个主机上锁定 SSH 的步骤。

在本章中，你将学习如何使用 Ansible 来确保你虚拟机的 SSH 访问安全。你将通过禁用 SSH 密码访问，要求通过 SSH 使用公钥认证，并为你的用户 *bender* 启用两因素认证 (2FA)。你将使用一些熟悉的 Ansible 模块的组合，并将接触到一些新的模块。到本章结束时，你将更好地理解如何强制执行严格的 SSH 访问控制，以及实现这一目标所需的自动化步骤。

## 理解并激活公钥认证

大多数 Linux 发行版默认使用密码进行 SSH 身份验证。虽然这种方式在许多设置中是可以接受的，但你应该通过增加另一种选项来加强安全性：*公钥认证*。这种方法使用一对密钥，包括公钥文件和私钥文件来确认你的身份。公钥认证被认为是 SSH 身份验证的最佳实践，因为潜在的攻击者若想劫持用户身份，需要同时拥有用户的私钥副本和解锁该私钥的密码短语。

当你用密钥创建 SSH 会话时，远程主机会用你的公钥加密一个 *挑战* 并将其发送回你。因为你持有私钥，所以你可以解码消息，并将回应发送回远程服务器。如果服务器能够验证回应，它会知道你持有私钥，从而确认你的身份。要了解更多关于密钥交换和 SSH 的内容，请访问 [`www.ssh.com/academy/ssh/`](https://www.ssh.com/academy/ssh/)。

### 生成公钥对

要生成密钥对，你需要使用`ssh-keygen`命令行工具。这个工具通常作为`ssh`包的一部分默认安装在 Unix 主机上，用于生成和管理 SSH 的身份验证密钥对。你很可能已经在本地主机上拥有一个公钥对，但为了本书的目的，我们将创建一个新的密钥对，这样就不会干扰到现有的密钥对。你还会为私钥设置一个密码短语。*密码短语*类似于密码，但通常更长（像是由不相关的词组成，而不是一串复杂的字符）。你添加它是为了防止万一私钥落入错误的人手中，坏人需要知道你的密码短语才能解锁它并冒充你的身份。

在本地主机的终端中，输入以下命令生成一个新的密钥对：

```
$ **ssh-keygen -t rsa -f ~/.ssh/dftd -C dftd**
Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase): `<passphrase>`
Enter same passphrase again: `<passphrase>`
Your identification has been saved in /Users/bradleyd/.ssh/dftd.
Your public key has been saved in /Users/bradleyd/.ssh/dftd.pub.
```

你首先指示`ssh-keygen`创建一个名为`dftd`（DevOps for the Desperate）的`rsa`密钥对。如果你没有指定名称，它会默认使用*id_rsa*，这可能会覆盖你现有的本地密钥。`-C`标志会在密钥末尾添加一个可读的注释，以帮助识别该密钥的用途。这里，它的注释也设置为`dftd`。在执行过程中，命令会提示你通过添加密码短语来保护你的密钥。输入一个强密码短语来保护密钥。同时，记得始终保持密码短语的安全，因为如果你丢失了它，密钥将永远被锁定，你将无法再使用它进行身份验证。

在确认密码短语后，私钥和公钥文件将被创建在你本地的*~./ssh/*目录下。

### 使用 Ansible 将公钥传送到虚拟机

每个用户在虚拟机上的主文件夹中都有一个名为*authorized_keys*的文件。该文件包含一份公钥列表，SSH 服务器可以用来验证该用户的身份。你将使用这个文件在通过 SSH 访问虚拟机时验证*bender*的身份。为此，你需要将你在上一节中创建的本地公钥（在我的案例中是*/Users/bradleyd/.ssh/dftd.pub*）复制到虚拟机上的*/home/bender/.ssh/authorized_keys*文件中。

要复制文件的内容，你将使用提供的 Ansible 任务。这个任务以及本章所有相关任务位于克隆的仓库中的*ansible/chapter3/*目录下。

打开你喜欢的编辑器中的*authorized_keys.yml*文件，查看 Ansible 任务。你首先会注意到，这个文件只有一个任务。它应该看起来像这样：

```
- name: Set authorized key file from local user
  authorized_key:
    user: bender
    state: present
    key: "{{ lookup('file', lookup('env','HOME') + '/.ssh/dftd.pub') }}"
```

首先，设置任务的`name`来标识其意图。使用 Ansible 的`authorized_key`模块将你的公钥从本地主机复制到虚拟机上的*bender*用户。`authorized_key`模块非常简单，要求你只设置`user`和`key`两个参数。在这个例子中，它将你之前创建的本地公钥复制到`bender`的*/home/bender/.ssh/authorized_keys*文件中。将`state`设置为`present`，因为你想添加密钥而不是删除它。

要获取本地公钥的内容，你需要使用 Ansible 的评估扩展操作符（`{{` `}}`）和一个内置的 Ansible 函数 `lookup`*。* `lookup` 函数根据作为其第一个参数指定的插件，从外部资源中检索信息。在这个示例中，`lookup` 使用 `file` 插件读取 *~/.ssh/dftd.pub* 公钥文件的内容。这个公钥文件的完整路径是通过 ``lookup `env` 插件和用 *+* 符号表示的字符串连接构建的。如果你使用的是 Mac，最终结果应该类似于：*/Users/bradleyd/.ssh/dftd.pub*。如果你使用的是 Linux，结果应该类似于：*/home/bradleyd/.ssh/dftd.pub*。文件路径将根据你的操作系统和用户名有所不同。``

````## Adding Two-Factor Authentication    Security is built in layers. The more layers you have, the harder it is for an intruder to gain access. The next layer of security to add is *two-factor authentication (2FA**)*, which validates a user’s identity by using credentials and something that the user has, like a phone or device. The main goal of 2FA is to make it harder for someone to spoof your identity if your password or key is compromised.    Two-factor authentication relies on your providing two out of these three things: *something you know*, *something you have*, and *something you are*. Here are some examples of each:    1.  Something you know: password or pin 2.  Something you have: phone or hardware authentication device, such as a YubiKey 3.  Something you are: fingerprint or voice    For this example, you’ll use a *time-based one-time password (TOTP)* to satisfy the “something you have” portion, along with your public key for access. You’ll use the `Google Authenticator` package to configure your VM to use TOTP tokens for logging in. These TOTP tokens are usually generated from an application like `oathtool` ([`www.nongnu.org/oath-toolkit/`](https://www.nongnu.org/oath-toolkit/)) and are valid for only a short period of time. I have taken the liberty of creating 10 TOTP tokens that Ansible will use for you, but I will also show you how to use `oathtool` (more on this later).    To enforce 2FA on your VM, you’ll use some provided Ansible tasks to install another PAM module, configure the SSH server, and enable 2FA. To review the provided tasks, first open the *two_factor.yml* file in your editor. (All the Ansible files for this chapter are located in the *ansible/chapter3/* directory.) This file has seven tasks, and each task has a specific job to enable 2FA. The tasks are named as follows:    1.  Install the `libpam-google-authenticator` package. 2.  Copy over preconfigured `GoogleAuthenticator` config. 3.  Disable password authentication for SSH. 4.  Configure PAM to use `GoogleAuthenticator` for SSH logins. 5.  Set `ChallengeResponseAuthentication` to `Yes`. 6.  Set Authentication Methods for *bender*, *vagrant*, and *ubuntu*. 7.  Insert an additional line here that reads: Restart SSH Server.    We’ll look at each of these tasks in the following sections.    ### Installing Google Authenticator    `Google Authenticator` is a PAM module that allows you to enforce 2FA over SSH. This module is located in the Ubuntu software repository under the name `libpam-google-authenticator`. The package contains all the necessary files to enable `Google Authenticator`. With the *two_factor.yml* file still open, find the first task at the top. It should look like this:    ``` - name: Install the libpam-google-authenticator package   apt:     name: "libpam-google-authenticator"     update_cache: yes     state: present ```    The `name` on the first line identifies the task’s intent (installing a package). You’ll use Ansible’s `apt` module to install the OS package. The `apt` module also requires the following `name` parameter to be set, and in this example, it is set to the package name `libpam-google-authenticator`.    Finally, as before, set the `state` to `present` since you want to install the package and not remove it. Most Ansible modules have the `state` set to `present` as a default, but you are most likely not the only person using these tasks. Letting the other engineers know your intent leaves little room for doubt or error, so even though you could omit this step, it’s always better to be explicit.    ### Configuring Google Authenticator    To configure `Google Authenticator` for a user, you typically would run the `google-authenticator` command that was installed from the `libpam-google-authenticator` package. This application creates a configuration file named *.google_authenticator* in the user’s *home/* directory by default. The configuration file consists of a Base32 key (secret); configuration options, such as token reuse and time to live; and 10 emergency recovery tokens. To keep the focus on provisioning, I’ve created the *google_authenticator* configuration file for you in the *chapter3/* directory.    Since the goal is to automate, you’ll use an Ansible task to copy this configuration file over to the VM. If you’re tempted to think, “It would be easier just to run the command by hand,” remember that in most cases you’ll be managing many hosts. Doing that by hand would be tedious and make you error prone.    With the *two_factor.yml* file still open, locate the task on line 7 of the file that looks like this:    ``` - name: Copy over preconfigured GoogleAuthenticator config   copy:     src: ../ansible/chapter3/google_authenticator     dest: /home/bender/.google_authenticator     owner: bender     group: bender     mode: 0600 ```    As always, the `name` of the task describes its intent (copy a file). The Ansible `copy` module copies the configuration file from your local host to the VM. Use the `copy` module when you need to copy a file from a source to a destination. (The source can be either local or remote.) The `copy` module requires you to set the `src` and `dest` parameters. In this case, the `src` field is set to the local *google_authenticator* file in the cloned repository ([`github.com/bradleyd/devops_for_the_desperate/`](https://github.com/bradleyd/devops_for_the_desperate/)). Notice the two dots (`..`) in the beginning of the source (*src*) file. These dots indicate that the file is located one directory up from the current *vagrant/* directory, where the `ansible` command is run. Without these dots, the `ansible-playbook` command would not be able to find the *ansible/* directory where the file is located. The `dest` parameter is set to the file named */home/bender/.google_authenticator* on the VM. The file permission, or `mode`, is set to read and write (`0600`), so only the owner of the file, *bender*, can read and write to it.    To learn more about `Google Authenticator`, visit [`github.com/google/google-authenticator/wiki/`](https://github.com/google/google-authenticator/wiki/)*.*    ### Configuring PAM for Google Authenticator    As mentioned in Chapter 2, PAM controls a lot of authorization and authentication methods in Linux. To be able to use `Google Authenticator` over SSH, you need to modify the SSH PAM configuration file, which is very similar to what you did in Chapter 2. To add `Google Authenticator` to PAM, you’ll need to make changes to the module file located at */etc/pam.d/sshd*. This file controls how PAM interacts with the SSH server (more on that later).    You’ll use two provided Ansible tasks that disable password prompts over SSH and tell PAM where it can find the `Google Authenticator` file (*pam_google_authenticator.so*). Remember, you want to force users to use public key authentication in lieu of passwords. This change will also make it harder for attackers to brute-force SSH with a password since you will not allow it.    With the *two_factor.yml* file still open, locate the first of the two tasks that configure PAM (on line 15). It should look like this:    ``` - name: Disable password authentication for SSH   lineinfile:     dest: "/etc/pam.d/sshd"     regex: "@include common-auth"     line: "#@include common-auth" ```    This task disables `password` prompts for SSH via the PAM module. To edit the PAM *sshd* file, this task uses the familiar Ansible `lineinfile` module, which locates the `common-auth` line with a regular expression (`regex`) and comments it out with a *#* sign. In this case, the regular expression searches for the full `common-auth` line. By commenting out that line, SSH `password` prompts for users are disabled when logging in over SSH.    The second task that will configure PAM, located on line 21, should look like this:    ``` - name: Configure PAM to use GoogleAuthenticator for SSH logins   lineinfile:     dest: "/etc/pam.d/sshd"     line: "auth required pam_google_authenticator.so nullok" ```    This task tells PAM about the `Google Authenticator` module. It uses the Ansible `lineinfile` module again to edit the PAM *sshd* file. This time, you just want to add the `auth` line to the bottom of the PAM file, which lets PAM know it should use `Google Authenticator` as an authentication mechanism. The `nullok` option at the end of the line tells PAM that this authentication method is optional, which allows you to avoid locking out users until they have successfully configured 2FA. In a production environment, you should remove the `nullok` option once all users have enabled 2FA.    ### Configuring the SSH Server    The SSH server manages all the SSH connections from the clients and enforces specific rules governing those connections. The SSH server will require some changes to expect a 2FA response, since that’s not a default configuration.    First, you’ll want to use Ansible to enable a keyboard response prompt when authenticating over SSH. The option to set is called `ChallengeResponseAuthentication`, and it’s needed so users can enter the two-factor verification code when logging in.    The second change Ansible will make is to set the SSH users’ `AuthenticationMethods`, which enable the SSH server to enforce specific ways for users to authenticate themselves. For this example, you’ll set the `AuthenticationMethods` for *bender* to be `publickey` and `keyboard-interactive`. This will force *bender* to need a public key and a TOTP token to log in. You’ll also set the *vagrant* and *ubuntu* users’ `AuthenticationMethods` only to `publickey` to log in, so you’ll still have users that can access the VM if anything goes wrong with 2FA.    With the *two_factor.yml* file still open, let’s review the two tasks that modify the VM’s SSH server. The first of these tasks, on line 26, should look like this:    ``` - name: Set ChallengeResponseAuthentication to Yes   lineinfile:     dest: "/etc/ssh/sshd_config"     regexp: "^ChallengeResponseAuthentication (yes|no)"     line: "ChallengeResponseAuthentication yes"     state: present ```    The task sets the `ChallengeResponseAuthentication` to `yes`. It uses the `lineinfile` module again to change a line in the VM’s SSH server config file. It locates the line using a regular expression that searches for the `ChallengeResponseAuthentication` option at the beginning of a line that is set to `yes` or `no`. Once it finds the line, it sets the line to `ChallengeResponseAuthentication` `yes` to enable keyboard interactivity for 2FA.    The last task in the file that configures the SSH server should look like this:    ``` - name: Set Authentication Methods for bender, vagrant, and ubuntu   blockinfile:     path: "/etc/ssh/sshd_config"     block: |       Match User "ubuntu,vagrant"           AuthenticationMethods publickey       Match User "bender,!vagrant,!ubuntu"           AuthenticationMethods publickey,keyboard-interactive     state: present   notify: "Restart SSH Server" ```    This task sets the authentication methods for users using the `blockinfile` module. Similar to `lineinfile`, `blockinfile` can manipulate a block of text. This is useful when you need to change multiple lines at once and preserve indentation inside a file. The `blockinfile` module requires that the `path` parameter be set. In this case, the `path` of the file to edit is */etc/ssh/sshd_config*. The pipe character (`|`) is YAML notation for introducing a multiline string: the block of text, where the task uses an SSH server configuration option called `Match` that allows you to apply certain criteria to specific users. In this example, you want to allow the *ubuntu* and *vagrant* users to use `publickey` authentication only when logging in over SSH. Then you want to set the authentication methods for *bender* to be `publickey` and `keyboard-interactive`, to enforce 2FA. Finally, this example sets a `notify` action to `"Restart SSH Server"` on this task. (I’ll discuss the `notify` option next.)    ### Restarting the SSH Server with a Handler    Editing the configuration file is not enough; the SSH server requires a restart for all the changes to take effect. To make that happen, you’ll use the `notify` Ansible option that triggers a `handler` to perform a single task. A `handler` is just like any other task, but it’s executed only once and has a globally unique name across the whole playbook.    The last Ansible task in *two_factor.yml* activates a `handler` that restarts the SSH server for you. Open the *handlers/restart_ssh.yml* file found in the *ansible/* directory. It should look like this:    ``` - name: Restart SSH Server   service:     name: sshd     state: restarted ```    This `handler`’s `name` is set to `Restart SSH Server`. This `name` matches the `notify` value from the previous task (`Set Authentication Methods for bender`, `vagrant, and ubuntu`). This is not an accident. The values must match exactly to be triggered. The `service` module restarts the SSH server. This module requires the `name` parameter, which is `sshd` in this case, to be set. Finally, this task sets the `state` to `restarted`. If, for some reason, the SSH server does not restart, the task will fail.    You’re now finished with the Ansible tasks, so it’s safe to close all the open files.    ## Provisioning the VM    To provision the VM with all the tasks described thus far, you’ll need to uncomment them in the playbook. You’ll follow essentially the same process that you followed in Chapter 2, but this time around, you’ll need to uncomment two tasks and a `handler`. Open the *site.yml* file in your editor and locate the task for authorized keys, which should look like this:    ``` **#-** **import_tasks****: chapter3/****authorized_keys.yml** ```    Remove the `#` symbol to uncomment it.    Next, find the task for 2FA:    ``` **#-** **import_tasks****: chapter3/****two_factor.yml** ```    Remove the `#` symbol to uncomment that line as well.    Next, find the `handler` section that’s located below all the tasks. The `handler` to restart the SSH server should look like this:    ``` **#-** **import_tasks****: handlers/****restart_ssh.yml** ```    Remove the `#` symbol at the beginning of the line to uncomment it.    The playbook should now look like this:    ``` - name: Provision VM   hosts: all   become: yes   become_method: sudo   remote_user: ubuntu   tasks:     - import_tasks: chapter2/pam_pwquality.yml  - import_tasks: chapter2/user_and_group.yml     **- import_tasks: chapter3/authorized_keys.yml**  **- import_tasks: chapter3/two_factor.yml**   `--snip--`   handlers:  **- import_tasks: handlers/restart_ssh.yml** ```    Here, the changes to the playbook for Chapter 3 are added on to the changes from Chapter 2. As mentioned previously, the playbook is a collection of tasks that will perform specific actions on a host or group of hosts to enforce a specified state.    Now, you’ll automate the configuration of the VM using Vagrant. Navigate to the *vagrant/* directory, and once there, enter the following command:    ``` $ **vagrant** **provision** `--snip--` PLAY RECAP ********************************************************************* default    : ok=16   changed=9   unreachable=0   failed=0   skipped=0   rescued=0   ignored=0 ```    Notice that the total task count has increased to `16` since the last provision. You have also changed a total of `9` things on the VM. Here’s a summary of the things that changed:    *   Seven new tasks from Chapter 3 *   One task that updates the empty file from the previous chapter *   One `handler`    Once again, make sure no actions failed before you continue. The values from the provision output will vary, depending on how many times you run the `provision` command in this chapter. This is because Ansible is working hard to make sure your environment is consistent, and it doesn’t do extra work that is not needed. As mentioned earlier, Ansible is idempotent, meaning it can be executed several times and each execution completes with the same end state you would expect from the initial execution.    ## Testing SSH Access    With the VM successfully provisioned, you should test *bender*’s access over SSH. To test public key and 2FA over SSH, you’ll need the private key you created earlier and one of the emergency tokens from the *google_authenticator* file in the repository. The private key should be located in your local SSH directory. On my Mac, it’s in */Users/bradleyd/.ssh/dftd*. The emergency tokens are the 10 eight-digit numbers located at the bottom of the *ansible/chapter3/google_authenticator*file. Choose the first one.    To `ssh` in to the VM as *bender*, open a terminal on your local host and enter the following command:    ``` $ **ssh** 1**-i ~/.ssh/dftd** **-p 2222** 2**bender@localhost** Enter passphrase for key /Users/bradleyd/.ssh/dftd: `<passphrase>` Verification code: `<76338876>` `--snip--` bender@dftd:~$ ```    In the `ssh` command, you set the identity file to your private key 1 for authentication and set the remote SSH port to `2222`. The default SSH port is 22, but Vagrant listens on a different SSH port to avoid conflicts on your local host. You also set the login user to *bender* and the SSH host to `localhost` 2.    The output indicates you should have been prompted twice during this login session: once to enter the passphrase to unlock your private key, and a second time to enter a 2FA verification code. After satisfying both prompts, you should be successfully logged in to the VM as *bender*.    If, for some reason, you weren’t prompted for a TOTP token or for the private key passphrase, stop and check for errors. You can log in to the VM as the *vagrant* user and inspect the logs. A good place to start looking for errors is in either */var/log/auth.log* or */var/log/syslog*on the VM. Common errors include the SSH server not restarting cleanly and one of the configuration files having a syntax issue.    Each of the 10 tokens provided is for one-time use. Every time you successfully use one, it’s removed from the */home/bender/.google_authenticator* file. If, for some reason, you burn through all the tokens, run the `vagrant provision` command again to replace the file and replenish the tokens. Another option is to use a TOTP application like `oathtool` and generate a time-based one-time token by using the Base32 secret at the top of the */home/bender/.google_authenticator* file. You can install `oathtool` with Ubuntu’s package manager by using the `apt install oathtool` command. Every time you need a token, you can use the following command:    ``` $ **oathtool --totp --base32 "QLIUWM4UVD7E5SI6PPVZ2EGRFU"** 097903 ```    Here, you pass `oathtool` your Base32 secret in the double quotes and set the flags `--totp` and `--base32` to generate the token. In this result, the token `097903` is generated and can be used when prompted for a verification code. Feel free to use this method or the provided tokens when logging in.    ## Summary    In this chapter, you secured the VM by disabling password logins, requiring public key authentication, and enforcing 2FA for *bender*. Automating these simple steps improves your host’s security, whether it’s local or on someone else’s computer in the cloud. As with the previous chapters, these automation tasks are a part of a foundational base that you can employ with all your hosts. In the next chapter, you’ll use more Ansible tasks to control user access by enabling security policies.````
