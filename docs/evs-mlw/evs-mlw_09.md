

## 第八章：7 运行时环境与虚拟处理器异常



![](img/opener.jpg)

在前面的三章中，您已经看到恶意软件如何查询和枚举操作系统的工件和配置，以了解其环境并检测到自己正被分析。本章将重点介绍恶意软件如何通过检查恶意软件分析工具引入的异常、监控虚拟处理器的性能和时序，以及滥用虚拟处理器指令，来主动识别分析沙箱和虚拟机环境。

### 检测分析和运行时异常

当恶意软件在沙箱或恶意软件分析环境中执行时，沙箱或分析工具可能通过多种方式泄露它们的存在。例如，沙箱有时会将恶意软件文件重命名为一个通用的文件名。沙箱和分析工具还可能向恶意软件样本中注入代码或修改其中的代码，以便更好地拦截和分析恶意软件的行为。一些恶意软件变种能够检测到它们运行时环境中的这些异常。我们来更详细地了解这些技术。

#### 运行路径、文件名与参数

当恶意软件被发送到自动化沙箱进行引爆和分析时，它通常会被命名为一些通用的名称，如 *sample.exe* 或 *malware.exe*，或者分配一个哈希值，例如 *b3126a1de5401048f5a6ea5a9192126fc7482ff0*。它可能还会从一个通用目录中运行，例如 *C:\Users\<user>\Downloads* 或 *C:\Users\<user>\Desktop*，而不是恶意软件作者所意图的目录，如临时目录。有些恶意软件可以识别这些异常。例如，某个恶意软件样本可能会调用 GetModuleFileName 函数来返回它自己的名称，或者调用 PathFindFileName 函数来返回其执行的完整路径。以下样本调用了 GetModuleFileName 来测试它的文件名是否在黑名单中：

```
push  offset size   ; nSize
push  offset fileNameBuffer  ; lpFilename
push  esi; hModule (null)
1 call  GetModuleFileNameA
`--snip--`
loc_21D10:
push offset blocklist1 ; "malware.exe"
push fileNameBuffer
2 call wcsstr
test eax, eax
jz   short loc_21E12:
`--snip--`
3 loc_21E12:
push offset blocklist2 ; "sample.exe"
push fileNameBuffer
call wcsstr
test eax, eax
jz   short loc_21F10:
```

该恶意软件样本调用了 GetModuleFileNameA 函数 ❶，并传递了三个参数：一个缓冲区（fileNameBuffer），用于存储返回的恶意软件文件名，一个缓冲区的大小（size），以及一个目标模块（esi）。当目标模块被设置为 null 时，表示当前运行的进程。

接下来，代码调用了wcsstr函数❷，该函数有两个参数：一个被列入黑名单的文件名（blocklist1）和一个指向缓冲区的指针，该缓冲区存储了从GetModuleFileName返回的恶意软件文件名。恶意软件样本随后将其自身的文件名与黑名单中的值进行比较。如果结果为0，即返回的文件名与黑名单中的文件名不匹配，恶意软件将跳到下一个比较。它将继续遍历黑名单中的文件名列表❸。如果找到匹配项，它就会假设自己正在被分析。

恶意软件沙箱和分析人员有时会将恶意软件文件重命名为其哈希值，而不是使用通用的文件名—通常为 MD5、SHA-1 或 SHA256 格式。当你从像 VirusTotal 这样的恶意软件库下载恶意软件时，它的文件名通常是哈希值的形式，如*b3126a1de5401048f5a6ea5a9192126fc7482ff0*。恶意软件分析人员或沙箱可能会在运行文件之前，简单地将文件扩展名附加到这个文件名上：*b3126a1de5401048f5a6ea5a9192126fc7482ff0.exe*。哈希值有固定的字符数，比如 MD5 哈希值有 32 个字符，SHA-1 哈希值有 40 个字符。恶意软件可以计算文件名中的字符数，如果文件名恰好是 32 个或 40 个字符（再加上文件扩展名字符），恶意软件可能会假设它正在分析环境中运行。

此外，恶意软件可以检查其运行路径和文件名，并将其与恶意软件作者原本意图的运行路径和文件名进行比较。例如，一个恶意的 Microsoft Word 文档可能试图从互联网下载一个可执行文件，并将其保存在*C:\Users\<user>\AppData\Roaming*目录下，文件名为*abc.exe*。如果恶意软件分析人员获取到这个可执行文件，而没有原始的 Word 文档，并且从*C:\Users\<user>\Downloads*目录中以*evil.exe*的文件名运行它，恶意软件样本可能会注意到它从一个异常的位置运行，且文件名未知，从而采取规避措施。

最后，恶意软件可能会检查其命令行参数。一些沙箱会在恶意软件进程中添加自己的参数，例如-force、-analysis，或-samp class="SANS_TheSansMonoCd_W5Regular_11">debug。通过检查这些参数是否存在，恶意软件可以检测它是否在沙箱环境中运行，并相应地改变其行为。此技术的变种是恶意软件仅在特定命令行参数下执行。如果没有这些参数执行恶意软件（例如在自动化沙箱环境中引爆时），它可能无法完全执行或表现出不同的功能。例如，恶意软件样本*evil.exe*可能需要命令行参数do_stuff：

```
C:\> evil.exe do_stuff
```

如果没有do_stuff参数，恶意软件可能在分析环境中无法正常运行。此技术通常涉及一个初步的恶意软件可执行文件或脚本，它使用正确的参数执行主要的恶意软件可执行文件。在这种情况下，你可能需要进行一些手动分析和逆向工程，以确定恶意软件期望的命令行参数。

为了绕过恶意软件可能使用的许多文件名和运行路径规避检查，你可以简单地将文件重命名为一个随机单词或短语，并从一个恶意软件常常执行的目录运行该文件，例如临时目录（例如，*C:\Users\<username>\AppData\Roaming\*）。理解整个攻击链也非常重要：恶意软件可能在寻找特定的文件路径或参数，获取这些路径的快速方法是调查攻击的所有痕迹。

#### 加载模块

某些沙箱和恶意软件分析工具将模块加载到正在运行的恶意软件进程的内存地址空间中，以修改恶意软件的行为或拦截其代码。在这种情况下，*模块*通常是一个 DLL 文件，它被加载（或*注入*）到目标进程中以实现各种目的。为了确定哪些模块已加载到其内存空间中，恶意软件可以使用 Windows API 函数，如 Module32First、Module32Next 和 GetModuleHandle 来枚举已加载的模块并识别任何异常。Module32First 和 Module32Next 用于迭代调用进程中所有已加载的模块，就像 Process32First 和 Process32Next 用于枚举进程一样。另一方面，GetModuleHandle 仅接受一个模块名作为参数，并在该模块已加载时返回模块的句柄。恶意软件可以利用这一点检查一个硬编码的模块名称列表，如下所示：

```
loc_1:
push offset toolSandboxie; "sbiedll.dll"
call GetModuleHandleA
test eax, eax
jz  loc_2:
`--snip--`
loc_2:
push offset toolVirtualpc; "vmcheck.dll"
call GetModuleHandleA
test eax, eax
```

该恶意软件样本首先将字符串 "sbiedll.dll" 的地址推送到栈中，然后调用 GetModuleHandleA。如果返回值是 0，意味着该模块未加载到恶意软件的内存空间中，代码将跳转到 loc_2，并使用相同的指令检查 "vmcheck.dll" 模块。此样本查找的两个模块分别是 Sandboxie（*sbiedll.dll*），一个流行的沙箱应用程序，以及 *vmcheck.dll*，这是一个通常会加载到虚拟 PC 客户端中的模块。

> 注意

*此技术还可以用于其他目的，比如寻找反恶意软件、终端检测与响应（EDR）以及其他防御工具；我们将在第 IV 部分中讨论这一点。*

#### 内存中的异常字符串

在钩取或监控恶意软件时，分析沙箱和工具有时会在恶意软件的进程内存空间中留下痕迹。恶意软件可以枚举内存中的这些字符串，搜索特定的分析工具和其他可疑行为，如以下伪代码所示：

```
hashedString = "9253221daaf309200fdcec682a987a51c5a5a598";
ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);
hashedBuffer = sha1sum(lpbuffer);
if (memcmp(hashedString, hashedBuffer, sizeof(hashedString)) == 0)
{
  TerminateProcess();
}
```

首先，这个恶意软件样本定义了变量hashedString。这个字符串仅仅是字符串HookLibraryx86.dll的 SHA-1 哈希值，我稍后会更详细地讨论这一点。接下来，样本将调用函数ReadProcessMemory，并传入多个参数，其中最重要的参数包括进程的句柄（hProcess），从进程内开始读取内存的基地址（lpBaseAddresss），接收读取内存数据的缓冲区（lpBuffer），以及要从内存中读取的字节数（nSize）。在这种情况下，被读取的进程是恶意软件本身的进程。一旦从内存中读取了数据并将其存储到缓冲区中，样本将使用 SHA-1 算法对该数据进行哈希计算。最后，样本调用memcmp函数将哈希后的缓冲区数据与原始哈希字符串进行比较。

恶意软件可以搜索其整个内存地址空间中的异常，也可以针对特定的内存区域。lpBaseAddress值可以是恶意软件进程地址空间内的任何基地址。

该恶意软件样本使用哈希技术使得分析变得更加困难，因为在没有反向哈希的情况下，我们无法确切知道它在内存中搜索的内容。*HookLibraryx86.dll*是一个常在使用 ScyllaHide 工具分析恶意软件时加载到内存中的模块。我将在第十章中更详细地讨论 ScyllaHide，但目前请记住，恶意软件可以扫描自身内存中的异常字符串，并将其搜索内容混淆，以增加分析的难度。

#### 钩子函数和加速检查

自动化恶意软件沙箱和一些分析工具在运行恶意软件时，可能会钩取并修改特定函数，以绕过某些规避检测的尝试。一个常见的钩取函数是 Sleep，恶意软件利用它保持休眠状态，防止自动化沙箱成功分析（因为沙箱通常只运行几分钟）。例如，沙箱可能会修改 Sleep 函数的参数，将休眠时间从 5 分钟改为 30 秒。恶意软件可以通过将 Sleep 函数“夹在”两个基于计时的函数之间，来检查 Sleep 函数是否被篡改，例如 GetTickCount（这种技术称为 *加速检查*）：

```
call GetTickCount
mov edi, eax
push 7530h ; 30,000 ms
call Sleep
call GetTickCount
sub eax, edi
mov ecx, 7148h ; 29,000
cmp ecx, eax
```

这个恶意软件样本调用了 GetTickCount，然后调用 Sleep 休眠 30,000 毫秒（30 秒）。接着，它第二次调用 GetTickCount，然后将第一次的 GetTickCount 结果减去第二次的值，并将差值存储在 eax 中（sub eax, edi）。最后，恶意软件将 eax 中的值与 29,000 毫秒进行比较，这是恶意软件预期经过的最短时间。如果自动化沙箱或工具篡改了 Sleep 函数，那么 GetTickCount 的值将与预期的时间长度不成比例，从而使恶意软件察觉到有问题。

### 使用性能和计时指示器

实际的非虚拟化处理器与虚拟化处理器之间可能存在显著的时间和性能偏差。非虚拟化处理器通常比虚拟化处理器使用相同硬件规格时执行指令更快、更高效。大多数情况下，普通用户在与这些系统交互时并不会察觉到这种差异。然而，恶意软件可以利用这些微小的差异来揭示底层的虚拟机。

#### rdtsc 指令

*读取时间戳计数器*，或 `rdtsc`，是一条具有多种用途的特殊汇编指令，包括性能监控和度量收集。当 `rdtsc` 指令在 CPU 上执行时，当前的 CPU 时钟周期数会被存储，可以引用并与后续的 `rdtsc` 指令进行比较。这两个值之间的差异就是自第一次执行 `rdtsc` 指令以来的时钟周期数。

虚拟机存在与 `rdtsc` 指令相关的问题。当程序在虚拟处理器上运行并执行 `rdtsc` 时，虚拟处理器必须将此指令传递给“真实”处理器：运行宿主操作系统的硬件 CPU。将 `rdtsc` 指令传递给真实 CPU 并返回的过程会引起一些延迟，从而增加时钟周期数。当恶意软件发现返回的时钟周期数高于非虚拟化系统时，它可能会推断出自己正在虚拟机环境中运行。

为了更好地理解恶意软件如何使用这种技术，我们来看看从反汇编的恶意软件代码中提取的一段汇编代码：

```
rdtsc
mov [ebp+rdtsc_1], eax
xor eax, eax
rdtsc
sub eax, [ebp+rdtsc_1]
```

该恶意软件样本使用了 `rdtsc` 指令来获取当前的时钟周期数，并将该值存储在一个缓冲区（`rdtsc_1`）中。然后，它执行另一个 `rdtsc` 指令，并将结果从原始值中减去（`sub eax, [ebp+ rdtsc_1]`）。它可以使用结果值来判断执行时间是否在非虚拟化处理器的阈值范围内。

有时，恶意软件比仅仅使用两条简单的 `rdtsc` 指令更为狡猾，一些恶意软件家族执行多次 `rdtsc` 指令以获得更准确的值。在下一部分，我们将介绍 `rdtsc` 的更多使用案例。

#### `函数执行时序`

考虑到非虚拟化和虚拟化处理器之间的时序差异，一些恶意软件会运行某个函数或指令，并将其执行时间与代表真实非虚拟化处理器的基准时间进行比较。如果指令执行速度比基准时间慢，恶意软件可能会判断它正在虚拟机中运行。

一种技术是恶意软件将一个 Windows API 函数调用或指令夹在两个 GetTickCount 函数之间，并比较结果。两个 GetTickCount 函数之间的长时间延迟可能会向恶意软件表明它正在被执行和分析。

这种技术有许多变种，包括使用指令如 rdtsc 和 cpuid，而不是像 GetTickCount 这样的 Windows API 函数。这里的要点是，每当你发现恶意软件使用基于时间的函数或指令，并随后进行比较操作时，你应该更详细地调查它。

#### 性能计数器

CPU 保持 *性能计数器* 以表示自某个时间点以来执行的指令数。它们可以合法地用于收集性能指标，但恶意软件可以利用它们来检测虚拟机环境。QueryPerformanceCounter 函数查询处理器的性能计数器并返回当前值。QueryPerformanceFrequency 返回性能计数器的 *频率*，这是一个固定值，表示处理器的整体性能。当这些指令在虚拟机中执行时，这些函数返回的值可能比非虚拟化系统略低，从而显示虚拟化处理器的性能影响。

如果你发现恶意软件使用这些函数，检查是否有随后的比较操作。这可能是恶意软件试图识别你的分析环境。

### 滥用虚拟处理器

虚拟机中的虚拟处理器可能会以某种方式解释和执行特定的汇编指令，从而向恶意软件揭示虚拟机的存在。在本节中，我们将深入探讨恶意软件如何通过滥用这些虚拟处理器，错误使用指令或利用它们的设计缺陷来进行攻击。

#### 红丸与无丸技术

红丸和无丸技术是恶意软件用来检测虚拟环境的两种著名方法。这两种技术检查处理器数据结构中的虚拟机特定值。这些技术在现代分析环境中通常无效，因此现代恶意软件中很少使用它们，但了解它们仍然是有益的。

对于 Red Pill 技术，恶意软件执行*存储中断描述符表*（Store Interrupt Descriptor Table），或sidt汇编指令，将中断描述符表寄存器的值写入内存中，然后进行检查。*中断描述符表（IDT）*是处理器用来确定对异常和中断作出正确响应的数据结构。(*异常*指示处理器某个指令出错，而*中断*允许处理器在需要时响应更高优先级的事件。）如果恶意软件在虚拟机中运行，IDT 寄存器的第五个字节将包含一个特定的值，表明这一点。

Red Pill 技术的实现很简单：

```
lea  eax, [ebp+buffer]
sidt [eax]
mov  al, [eax+5]
cmp  al, 0FFh
```

sidt [eax]指令将 IDT 寄存器的内容（长度为 6 字节）存储到缓冲区。该代码读取此值并执行与缓冲区中第五个字节的比较操作，即[eax+5]。如果正在虚拟机中运行，IDT 寄存器的第五个字节将等于FF（十六进制）。

No Pill 技术使用*存储本地描述符表*（Store Local Descriptor Table），或sldt指令将*本地描述符表*（*LDT*）寄存器存储到内存中。由于正常的 Windows 应用程序不使用 LDT，因此该 LDT 寄存器的值应为0。然而，在某些虚拟化管理程序中，该 LDT 寄存器的值会包含一个非零值，这可能会提示恶意软件它正在虚拟机中运行。与 Red Pill 技术类似，No Pill 技术在现代沙盒和虚拟化管理程序中已无法正常工作。

#### IO 端口

*输入/输出端口 (IO 端口)* 是机器物理硬件与运行其上的软件之间的通信方式。某些虚拟化管理程序（hypervisor）使用 IO 端口进行主机与客户操作系统的通信。例如，VMware 使用 VMX IO 端口。思科 Talos 的研究表明，恶意软件可以识别 VMX 端口，从而检测其是否运行在 VMware 环境中。以下汇编代码展示了这一过程可能的实现方式：

```
mov   eax, 'VMXh'
mov   ebx, 2EF36D4Ch
mov   ecx, 0Ah
mov   dx, 'VX'
in    eax, dx
cmp   ebx, 2EF36D4Ch
```

这个恶意软件样本将VMXh的值加载到eax寄存器中，然后将魔法值2EF36D4Ch加载到ebx寄存器中。这个魔法值可以是任何十六进制值，在这里并不重要。接下来，代码将dx寄存器段加载为VX的值，或十六进制的5658，这是 VMX 端口号。最后，恶意软件执行in eax, dx，使用in汇编指令尝试访问 IO 端口。如果该主机正在运行 VMware Workstation 虚拟机监控程序，这条指令将返回魔法数字，可能会导致恶意软件样本自我终止或采取其他回避措施。在非虚拟化主机上，返回的值将是0。

和红药丸（Red Pill）和无药丸（No Pill）技术一样，这种特定的技术已经相当古老，并且在现代版本的 VMware 中已经被修补。然而，理解这一技术以及类似的技术仍然很重要，尤其是在分析使用它或其变种的恶意软件时。

#### cpuid 指令

cpuid汇编指令返回有关主机处理器的信息，例如处理器的特性和制造商。在虚拟机外部，执行cpuid并将 EAX 设置为0时，将返回类似Genuineintel（对于 Intel 处理器）或AuthenticAMD（对于 AMD 处理器）的信息。当cpuid在虚拟机内部执行时，它通常返回虚拟机监控程序的名称。以 VMware 为例，这个字符串是VMwareVMware。对于 VirtualBox，返回的字符串是VBoxVBoxVBox。

在执行 `cpuid` 前将 EAX 设置为 `1` 可以返回更多的信息，存储在 ECX 和 EDX 寄存器的一个 31 位区块中。如果系统的 CPU 是物理 CPU，则 ECX 寄存器的第 31 位为 `0`，如果系统使用虚拟 CPU，则该位为 `1`，这表明处于虚拟机环境中。以下是一个恶意软件样本使用此技巧的汇编代码片段：

```
inc eax
cpuid
bt ecx, 0x1f
jc terminate_process
```

在这里，恶意软件将 `eax` 设置为 `1`（`inc eax`），该值将作为 `cpuid` 指令的参数。执行完 `cpuid` 后，恶意软件会执行 `bt` (*位测试*) 指令，将 ECX 寄存器的第 31 位移动到 *进位标志* 寄存器中，该寄存器是一个特殊的 CPU 寄存器，能够存储 `0` 或 `1` 的值，通常在加减法操作中使用。最后，样本检查进位标志寄存器（`jc`），如果其值为 `1`，恶意软件将得出结论认为它正在虚拟机中运行并自行终止。

> 注意

*维基百科是有关从 `cpuid` 返回的处理器信息和功能位的一个极好参考资料。请参阅* [`<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/CPUID<wbr>.`](https://en.wikipedia.org/wiki/CPUID)

#### 不支持的指令集

恶意软件可能使用 `cpuid` 来检测处理器是否支持特定的指令集。例如，EDX 寄存器中的第 23 位指定处理器是否支持 *SSE 指令集*，这是一组不常见的汇编指令，通常用于图形处理和科学计算。一些现代的虚拟机监控器（hypervisor）支持像 SSE 这样的指令集，但并不是所有的都支持！这可能成为恶意软件检测自己是否运行在虚拟机或沙盒中的一种明显迹象。

一些恶意软件不会像系统地查看 `cpuid` 的输出那样，而是直接尝试执行这些指令，如下所示：

```
movdqa xmm0, xmmword ptr [eax]
movdqa xmm1, xmmword ptr [eax]
movdqa xmmword ptr [eax], xmm0
movdqa xmmword ptr [eax], xmm1
```

movdqa（移动对齐的双四字数据）指令用于将数据移入和移出 *XMM 寄存器*，这些寄存器用于 SSE 指令集。在这段代码中，movdqa 指令将由 eax 引用的数据移动到 xmm0 寄存器，再移动到 xmm1 寄存器。然后，它将这些数据从 xmm 寄存器移回到 eax。如果此代码产生错误（或者恶意软件崩溃！），恶意软件样本可能会假设它正在虚拟化环境中运行。

这里举的 SSE 指令集只是一个例子，大多数现代管理程序都支持它。需要记住的重要一点是，任何外部或不常见的汇编指令，如果管理程序不支持它们，都可能被恶意软件滥用来进行虚拟机和沙箱检测。

另一个外部指令的例子是 vpcext，如果在 Windows 虚拟 PC 管理程序之外执行，将会产生错误。然而，如果在虚拟 PC 内执行，该指令将成功，并将 EBX 寄存器设置为 0。以下代码执行 vpcext 指令，接着执行 test 指令以检查 ebx 是否等于 0：

```
vpcext 7, 0bh
test ebx, ebx
```

#### 捕获标志与其他技术

捕获标志是 Intel x86 指令集中的 EFLAGS 寄存器的第八位。如果在调用其他指令之前启用该位，将触发异常。在虚拟机环境中，管理程序模拟捕获标志的行为。根据所使用的管理程序，此模拟可能不正确或不完整，这会导致捕获标志被忽略，并通知恶意软件它正在虚拟机中运行。这项技术首次于 2021 年由 Palo Alto 的 Unit 42 研究人员在实际环境中发现。

看起来像这样的虚拟机检测方法，如捕获标志技术，每隔几年就会有新的被发现。它们大多数有一个共同点：它们滥用 CPU 及其架构设计的工作方式，导致管理程序以意外或以前未知的方式表现，从而最终暴露出底层的虚拟机。恶意软件分析师必须及时了解这些技术，以便识别恶意软件何时使用它们。

### 使用检测技术的风险

正如你在这一章以及前几章中看到的，对于恶意软件作者而言，实施虚拟机和分析工具检测功能有很多好处。那么，为什么恶意软件作者*不*包括这些功能呢？其中一个原因是，这些技术实际上可能增加恶意软件被反恶意软件或分析员发现的概率。恶意软件执行的 Windows API 函数或指令越可疑，越有可能被注意到这些行为异常。

另一个风险则不那么明显，我认为有点滑稽。如果恶意软件检测到自己运行在虚拟机中并选择不感染宿主，这在某些情况下可能是自我挫败的。许多组织正在转向云和按需基础设施，实际上许多系统都是虚拟机。能够检测虚拟机以逃避恶意软件分析员和沙盒的恶意软件，往往也在同时逃避它本应感染的企业系统。

一个现实世界的例子是广为人知的网络犯罪恶意软件 Emotet，它采用了多种反分析技术，其中之一就是虚拟机（VM）和沙盒检测。如果它认为宿主是虚拟机或沙盒，Emotet 会自行终止，从而防止感染，或者它会与在真实物理系统上运行时的行为不同。这导致了 Emotet 的感染率比正常情况下要低，并可能帮助一些运行虚拟化基础设施的组织避免了重大损害。

### 总结

在这一章中，你了解了恶意软件可以用来建立上下文并检测恶意软件分析工具、虚拟机和沙盒的几种技术。接下来，我们将在本章和前三章讨论的基础上继续展开。具体来说，我们将探讨恶意软件在发现自己运行在虚拟化环境或实验室中时，为了规避和干扰分析工作所采取的措施。
