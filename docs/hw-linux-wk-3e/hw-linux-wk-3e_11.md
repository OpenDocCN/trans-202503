# Shell 脚本简介

![](img/chapterart.png)

如果你能够在 shell 中输入命令，你就能编写 shell 脚本。*Shell 脚本*（也称为 *Bourne shell 脚本*）是一系列写入文件中的命令；shell 会从文件中读取这些命令，就像你在终端中输入一样。

## 11.1 Shell 脚本基础

Bourne shell 脚本通常以以下行开始，指示 `/bin/sh` 程序应执行脚本文件中的命令。（确保脚本文件开头没有空白字符。）

```
#!/bin/sh
```

`#!` 部分被称为 *shebang*；你将在本书的其他脚本中看到它。你可以在`#!/bin/sh`行后列出任何你希望 shell 执行的命令。例如：

```
#!/bin/sh
#
# Print something, then run ls

echo About to run the ls command.
ls
```

和 Unix 系统上的任何程序一样，你需要为 shell 脚本文件设置可执行位，但你还必须设置读取位，以便 shell 能够读取该文件。做到这一点的最简单方法如下：

```
$ **chmod +rx** `script`
```

这个`chmod`命令允许其他用户读取并执行`script`。如果你不希望这样，可以使用绝对模式`700`来代替（更多权限内容请参见第 2.17 节）。

创建 shell 脚本并设置读取和执行权限后，你可以将脚本文件放置在命令路径中的一个目录里，然后在命令行上运行脚本名称来执行它。如果脚本位于当前工作目录中，你也可以运行`./``script`，或者使用完整路径名来运行。

使用 shebang 运行脚本几乎（但不完全）等同于在你的 shell 中运行一个命令；例如，运行一个名为`myscript`的脚本会导致内核运行`/bin/sh myscript`。

基本内容讲解完毕后，让我们来看一看 shell 脚本的一些限制。

### 11.1.1 Shell 脚本的限制

Bourne shell 轻松地操作命令和文件。在第 2.14 节中，你已经看到 shell 如何重定向输出，这是 shell 脚本编程的一个重要元素。然而，shell 脚本只是 Unix 编程的一个工具，尽管脚本拥有相当强大的功能，但它们也有局限性。

Shell 脚本的一个主要优点是，它们可以简化和自动化你在 shell 提示符下执行的任务，例如批量操作文件。但如果你想分解字符串、进行重复的算术计算、访问复杂的数据库，或者需要函数和复杂的控制结构，那么最好使用像 Python、Perl 或 `awk` 这样的脚本语言，或者甚至是像 C 这样的编译语言。（这是很重要的，所以你会在整章中看到它。）

最后，请注意你的 shell 脚本大小。保持脚本简短。Bourne shell 脚本并不适合做成很大，尽管你可能会遇到一些庞然大物。

## 11.2 引号和字面量

在与 Shell 和脚本打交道时，最令人困惑的元素之一就是知道什么时候以及为什么使用引号（引用符）和其他标点符号。假设你想打印字符串 `$100`，并且你这样做了：

```
$ **echo $100**
00
```

为什么它打印了 `00`？因为 `$1` 具有 `$` 前缀，Shell 将其解释为一个 Shell 变量（我们稍后会讲解这些）。你想，也许如果用双引号将它括起来，Shell 就不会动 `$1` 了：

```
$ **echo "$100"**
00
```

这仍然没有成功。你问朋友，朋友说你应该改用单引号：

```
$ **echo '$100'**
$100
```

为什么这个特定的命令能成功？

### 11.2.1 字面量

当你使用引号时，你通常是试图创建一个*字面量*，这是一个 Shell 在传递给命令行之前不应分析（或试图改变）的字符串。除了你刚才看到的示例中的 `$`，当你想要将 `*` 字符传递给像 `grep` 这样的命令，而不是让 Shell 展开它时，或者当你需要在命令中使用分号（`;`）时，这种情况经常会出现。

在编写脚本和使用命令行时，记住当 Shell 运行命令时会发生什么：

1.  在运行命令之前，Shell 会查找变量、通配符和其他替换，并在它们出现时执行替换。

1.  Shell 将替换结果传递给命令。

涉及字面量的问题可能会比较微妙。假设你正在查找 */etc/passwd* 中所有匹配正则表达式 `r.*t` 的条目（也就是说，包含 `r` 并且稍后在行中有 `t` 的行，这样你就能搜索到像 `root`、`ruth` 和 `robot` 这样的用户名）。你可以运行以下命令：

```
$ **grep r.*t /etc/passwd**
```

它大多数时候是有效的，但有时神秘地失败了。为什么？答案可能在你当前的目录中。如果该目录包含名为 *r.input* 和 *r.output* 的文件，那么 Shell 会将 `r.*t` 展开为 `r.input r.output` 并创建以下命令：

```
$ **grep r.input r.output /etc/passwd**
```

避免此类问题的关键是首先识别可能导致问题的字符，然后应用正确类型的引号来保护这些字符。

### 11.2.2 单引号

创建字面量并让 Shell 保持字符串不变的最简单方法是将整个字符串用单引号（`'`）括起来，如这个示例中使用 `grep` 和 `*` 字符：

```
$ **grep 'r.*t' /etc/passwd**
```

就 Shell 而言，两个单引号之间的所有字符，包括空格，构成一个单一的参数。因此，以下命令*不*有效，因为它要求 `grep` 命令在标准输入中查找字符串 `r.*t /etc/passwd`（因为 `grep` 只有一个参数）：

```
$ **grep 'r.*t /etc/passwd'**
```

当你需要使用字面量时，你应该首先使用单引号，因为这样可以确保 Shell 不会尝试进行*任何*替换。因此，这是一种相对简洁的语法。然而，有时你需要更多的灵活性，这时你可以转而使用双引号。

### 11.2.3 双引号

双引号（`"）`的功能与单引号相同，只是 Shell 会展开双引号内的任何变量。你可以通过运行以下命令并将双引号替换为单引号，再次运行来看出区别。

```
$ **echo "There is no * in my path: $PATH"**
```

当你运行命令时，注意到 Shell 会替换 `$PATH`，但不会替换 `*`。

### 11.2.4 文字单引号

当你传递一个文字单引号给命令时，使用 Bourne shell 可能会很棘手。实现这一点的一种方法是，在单引号字符前加上反斜杠：

```
$ **echo I don\'t like contractions inside shell scripts.**
```

反斜杠和引号 *必须* 出现在任何一对单引号外。像 `'don\'t` 这样的字符串会导致语法错误。奇怪的是，你可以将单引号放入双引号中，如以下示例所示（输出与前面的命令相同）：

```
$ **echo "I don't like contractions inside shell scripts."**
```

如果你陷入困境并且需要一个通用规则来引用整个字符串而不进行替换，请按照此过程操作：

1.  将所有出现的 `'`（单引号）替换为 `'\''`（单引号、反斜杠、单引号、单引号）。

1.  将整个字符串放入单引号中。

因此，你可以像下面这样引用一个尴尬的字符串 `this isn't a forward slash: \`：

```
$ **echo 'this isn'\''t a forward slash: \'**
```

## 11.3 特殊变量

大多数 Shell 脚本理解命令行参数，并与它们运行的命令进行交互。为了让你的脚本不仅仅是简单的命令列表，而成为更灵活的 Shell 脚本程序，你需要了解如何使用特殊的 Bourne shell 变量。这些特殊变量与第 2.8 节中描述的其他 Shell 变量类似，不同之处在于你不能更改某些变量的值。

### 11.3.1 单个参数：$1，$2，等等

`$1`、`$2` 和所有命名为正整数的变量包含脚本参数或*参数*的值。例如，假设以下脚本的名称是 *pshow*：

```
#!/bin/sh
echo First argument: $1
echo Third argument: $3
```

尝试按照以下方式运行脚本，看看它是如何打印参数的：

```
$ **./pshow one two three**
First argument: one
Third argument: three
```

内置的 Shell 命令 `shift` 可以与参数变量一起使用，移除第一个参数（`$1`）并使其余参数前移，使得 `$2` 成为 `$1`，`$3` 成为 `$2`，依此类推。例如，假设以下脚本的名称是 *shiftex*：

```
#!/bin/sh
echo Argument: $1 
shift
echo Argument: $1
shift
echo Argument: $1
```

按照下面的方式运行它来查看它如何工作：

```
$ **./shiftex one two three** 
Argument: one
Argument: two
Argument: three
```

如你所见，`shiftex` 通过打印第一个参数、移动剩余参数并重复该过程，来打印所有三个参数。

### 11.3.2 参数个数：$#

`$#` 变量保存传递给脚本的参数数量，在你运行 `shift` 循环以逐个处理参数时特别重要。当 `$#` 为 `0` 时，表示没有参数剩余，因此 `$1` 为空。（有关循环的描述，请参见第 11.6 节。）

### 11.3.3 所有参数：$@

`$@` 变量表示脚本的所有参数，对于将它们传递给脚本内的命令非常有用。例如，Ghostscript 命令（`gs`）通常很长且复杂。假设你想要为以 150 dpi 的分辨率光栅化 PostScript 文件并使用标准输出流，同时又希望能够传递其他选项给 `gs`。你可以编写这样的脚本来允许添加更多命令行选项：

```
#!/bin/sh
gs -q -dBATCH -dNOPAUSE -dSAFER -sOutputFile=- -sDEVICE=pnmraw $@
```

```
#!/bin/sh
gs -q -dBATCH -dNOPAUSE -dSAFER **\**
   -sOutputFile=- -sDEVICE=pnmraw $@
```

### 11.3.4 脚本名称：$0

`$0` 变量保存脚本的名称，并且在生成诊断信息时非常有用。例如，假设你的脚本需要报告一个存储在 `$BADPARM` 变量中的无效参数。你可以使用以下代码打印诊断信息，以便错误消息中出现脚本名称：

```
echo $0: bad option $BADPARM
```

所有的诊断错误信息应该输出到标准错误流。如在第 2.14.1 节中所解释，`2>&1` 将标准错误重定向到标准输出。若要写入标准错误流，可以通过 `1>&2` 反转这一过程。要为上述示例实现此操作，请使用：

```
echo $0: bad option $BADPARM 1>&2
```

### 11.3.5 进程 ID：$$

`$$` 变量保存了 shell 的进程 ID。

### 11.3.6 退出代码：$?

`$?` 变量保存了 shell 执行的最后一条命令的退出代码。退出代码是掌握 shell 脚本的关键，接下来将讨论这一点。

## 11.4 退出代码

当一个 Unix 程序完成时，它会留下一个*退出代码*，这是一个数值，也称为*错误代码*或*退出值*，供启动该程序的父进程使用。当退出代码为零（`0`）时，通常表示程序没有问题地运行。然而，如果程序出现错误，它通常会以非零数字退出（但并不总是如此，正如你接下来会看到的那样）。

shell 会将最后一条命令的退出代码保存在 `$?` 特殊变量中，因此你可以在 shell 提示符下查看它：

```
$ **ls / > /dev/null**
$ **echo $?**
0
$ **ls /asdfasdf > /dev/null**
ls: /asdfasdf: No such file or directory
$ **echo $?**
1
```

你可以看到成功的命令返回了 `0`，而失败的命令返回了 `1`（当然，前提是你的系统中没有名为 */asdfasdf* 的目录）。

如果你打算使用一个命令的退出代码，你*必须*在运行命令后立即使用或存储该代码（因为下一个运行的命令会覆盖前一个代码）。例如，如果你连续运行两次 `echo $?`，第二条命令的输出总是 `0`，因为第一次 `echo` 命令执行成功。

在编写 shell 代码时，你可能会遇到需要因为错误（例如错误的文件名）而使脚本停止的情况。可以在脚本中使用 `exit 1` 来终止并将退出代码 `1` 返回给执行脚本的父进程。（如果你的脚本有不同的异常退出条件，你可以使用不同的非零数字。）

请注意，某些程序（如`diff`和`grep`）使用非零的退出代码来表示正常情况。例如，如果`grep`找到匹配的模式，它会返回`0`，如果没有找到则返回`1`。对于这些程序，退出代码`1`并不是错误，因此`grep`和`diff`在遇到实际问题时会返回退出代码`2`。如果你认为某个程序可能使用非零退出代码来表示成功，可以阅读该程序的手册页面。退出代码通常会在 EXIT VALUE 或 DIAGNOSTICS 部分进行说明。

## 11.5 条件语句

Bourne Shell 有专门用于条件判断的结构，包括`if`/`then`/`else`和`case`语句。例如，这个包含`if`条件的简单脚本会检查脚本的第一个参数是否为`hi`：

```
#!/bin/sh
if [ $1 = hi ]; then
   echo 'The first argument was "hi"'
else
   echo -n 'The first argument was not "hi" -- '
   echo It was '"'$1'"'
fi
```

前述脚本中的`if`、`then`、`else`和`fi`是 Shell 关键字；其他的则是命令。这一点非常重要，因为很容易将条件表达式`[ $1 = "hi" ]`误认为是特殊的 Shell 语法。实际上，`[`字符是 Unix 系统中的一个实际程序。所有 Unix 系统都有一个名为`[`的命令，它用于执行 Shell 脚本中的条件测试。这个程序也被称为`test`；`test`和`[`的手册页面是一样的。（你很快会学到，Shell 并不总是运行`[`，但现在你可以把它当作一个独立的命令来理解。）

在这里，理解退出代码的重要性正如第 11.4 节所解释的那样。让我们看看前一个脚本实际是如何工作的：

1.  Shell 会运行`if`关键字后面的命令，并收集该命令的退出代码。

1.  如果退出代码是`0`，Shell 会执行紧跟在`then`关键字后的命令，直到遇到`else`或`fi`关键字为止。

1.  如果退出代码不是`0`并且有`else`语句块，Shell 会运行`else`关键字后面的命令。

1.  条件表达式在`fi`处结束。

我们已经确定了`if`后面的测试是一个命令，那么让我们来看一下分号（`;`）。它只是 Shell 中用于表示命令结束的常规标记，之所以出现，是因为我们将`then`关键字放在了同一行。如果没有分号，Shell 会将`then`作为参数传递给`[`命令，这通常会导致难以追踪的错误。你可以通过将`then`关键字放在单独的行上来避免使用分号，如下所示：

```
if [ $1 = hi ]
then
   echo 'The first argument was "hi"'
fi
```

### 11.5.1 空参数列表的解决方法

在前面的示例中，条件语句可能存在一个潜在问题，这是一个常被忽视的情景：`$1`可能为空，因为用户可能没有传递任何参数来运行脚本。如果`$1`为空，测试就变成了`[ = hi ]`，此时`[`命令会因错误而中止。你可以通过以下两种常见方式之一，将参数用引号括起来来修复这个问题：

```
if [ "$1" = hi ]; then
if [ x"$1" = x"hi" ]; then
```

### 11.5.2 其他测试命令

除了`[`，还有许多其他命令可以用于条件测试。这里有一个使用`grep`的示例：

```
#!/bin/sh
if grep -q daemon /etc/passwd; then
    echo The daemon user is in the passwd file.
else
    echo There is a big problem. daemon is not in the passwd file.
fi
```

### 11.5.3 elif

还有一个`elif`关键字，它可以将多个`if`条件语句连接起来，如下所示：

```
#!/bin/sh
if [ "$1" = "hi" ]; then
   echo 'The first argument was "hi"'
elif [ "$2" = "bye" ]; then
   echo 'The second argument was "bye"'
else
   echo -n 'The first argument was not "hi" and the second was not "bye"-- '
   echo They were '"'$1'"' and '"'$2'"'
fi
```

请记住，控制流只会通过第一个成功的条件，因此，如果你使用`hi bye`作为参数运行此脚本，你将只得到`hi`参数的确认。

### 11.5.4 逻辑构造

有两种快速的一行条件构造，你可能时不时会看到，使用`&&`（"与"）和`||`（"或"）语法。`&&`构造如下工作：

```
`command1` `&&` `command2`
```

在这里，shell 运行`command1`，如果退出代码为`0`，shell 还会运行`command2`。

`||`构造类似；如果`||`前的命令返回非零退出代码，shell 将运行第二个命令。

`&&`和`||`构造通常用于`if`测试，在这两种情况下，最后运行的命令的退出代码决定了 shell 如何处理条件。在`&&`构造的情况下，如果第一个命令失败，shell 将使用它的退出代码作为`if`语句，但如果第一个命令成功，shell 将使用第二个命令的退出代码作为条件。在`||`构造的情况下，如果第一个命令成功，shell 使用第一个命令的退出代码，否则如果第一个命令失败，则使用第二个命令的退出代码。

例如：

```
#!/bin/sh
if [ "$1" = hi ] || [ "$1" = bye ]; then
    echo 'The first argument was "'$1'"'
fi
```

如果你的条件语句中包含测试命令（`[`），如这里所示，你可以使用`-a`和`-o`来代替`&&`和`||`，例如：

```
#!/bin/sh
if [ "$1" = hi  -o "$1" = bye ]; then
   echo 'The first argument was "'$1'"'
fi
```

你可以通过在测试前放置`!`运算符来反转测试（即逻辑非）。例如：

```
#!/bin/sh
if [ ! "$1" = hi  ]; then
   echo 'The first argument was not hi'
fi
```

在这种特定的比较情况下，你可能会看到`!=`作为一种替代方法，但`!`可以与接下来章节中描述的任何条件测试一起使用。

### 11.5.5 条件测试

你已经了解了`[`的工作原理：如果测试为真，退出代码为`0`，如果测试失败，则退出代码为非零。你也知道如何使用`[` `str1` `=` `str2` `]`来测试字符串相等性。然而，请记住，shell 脚本非常适合对整个文件进行操作，因为许多有用的`[`测试涉及文件属性。例如，以下行检查`file`是否为常规文件（不是目录或特殊文件）：

```
[ -f `file` ]
```

在脚本中，你可能会看到`-f`测试出现在类似于此的循环中，它测试当前工作目录中的所有项目（你将在 11.6 节中学到更多关于循环的内容）：

```
for filename in *; do
    if [ -f $filename ]; then
        ls -l $filename
        file $filename
    else
        echo $filename is not a regular file.
    fi
done 
```

有数十种测试操作，所有操作都可归为三大类：文件测试、字符串测试和算术测试。info 手册包含完整的在线文档，但 test(1)手册页是快速参考。以下部分概述了主要的测试。（我省略了一些不太常见的测试。）

#### 文件测试

大多数文件测试，如`-f`，被称为*一元*操作，因为它们只需要一个参数：要测试的文件。例如，以下是两个重要的文件测试：

1.  `-e` 如果文件存在，则返回 true

1.  `-s` 如果文件不为空，则返回 true

一些操作符检查文件类型，这意味着它们可以确定某个文件是否为常规文件、目录或某种特殊设备，如 表 11-1 所列。此外，还有一些单目操作符检查文件的权限，如 表 11-2 所列。（有关权限的概述，请参见第 2.17 节。）

表 11-1：文件类型操作符

| **操作符** | **测试条件** |
| --- | --- |
| `-f` | 常规文件 |
| `-d` | 目录 |
| `-h` | 符号链接 |
| `-b` | 块设备 |
| `-c` | 字符设备 |
| `-p` | 命名管道 |
| `-S` | 套接字 |

表 11-2：文件权限操作符

| **操作符** | **权限** |
| --- | --- |
| `-r` | 可读 |
| `-w` | 可写 |
| `-x` | 可执行 |
| `-u` | 设置 UID |
| `-g` | 设置 GID |
| `-k` | “粘滞” |

最后，三个*二进制*操作符（需要两个文件作为参数的测试）用于文件测试，但它们并不常见。考虑以下命令，它包括 `-nt`（“比...新”）：

```
[ `file1` -nt `file2` ]
```

如果 `file1` 的修改日期比 `file2` 新，则此命令返回 true。`-ot`（“比...旧”）操作符则执行相反的操作。如果你需要检测相同的硬链接，`-ef` 会比较两个文件，如果它们共享 inode 编号和设备，则返回 true。

#### 字符串测试

你已经见过二进制字符串操作符 `=`，它在操作数相等时返回 true，和 `!=` 操作符，它在操作数不相等时返回 true。还有两个额外的单目字符串操作：

1.  `-z` 如果参数为空则返回 true（`[ -z "" ]` 返回 `0`）

1.  `-n` 如果参数不为空则返回 true（`[ -n "" ]` 返回 `1`）

#### 算术测试

请注意，等号（`=`）用于检查*字符串*相等，而非*数值*相等。因此，`[ 1 = 1 ]` 返回 `0`（真），但 `[ 01 = 1 ]` 返回 false。处理数字时，使用 `-eq` 而非等号：`[ 01 -eq 1 ]` 返回 true。表 11-3 提供了完整的数值比较操作符列表。

表 11-3：算术比较操作符

| **操作符** | **当第一个参数是 ___________ 第二个时返回 true** |
| --- | --- |
| `-eq` | 等于 |
| `-ne` | 不等于 |
| `-lt` | 小于 |
| `-gt` | 大于 |
| `-le` | 小于或等于 |
| `-ge` | 大于或等于 |

### 11.5.6 case

`case` 关键字形成另一种条件构造，非常适用于匹配字符串。它不会执行任何测试命令，因此不会评估退出码。然而，它可以进行模式匹配。这个示例讲述了大部分内容：

```
#!/bin/sh
case $1 in
    bye)
        echo Fine, bye.
        ;;
    hi|hello)
        echo Nice to see you.
        ;;
    what*)
        echo Whatever.
        ;;
    *)
        echo 'Huh?'
        ;;
esac
```

Shell 执行如下：

1.  脚本将 `$1` 与每个用 `)` 字符标记的 case 值进行匹配。

1.  如果 case 的值匹配 `$1`，shell 会执行 case 下面的命令，直到遇到 `;;`，此时它会跳到 `esac` 关键字。

1.  条件语句以 `esac` 结束。

对于每个情况值，你可以匹配单个字符串（比如前面的示例中的 `bye`）或使用 `|` 匹配多个字符串（`hi|hello` 当 `$1` 等于 `hi` 或 `hello` 时返回真），或者你可以使用 `*` 或 `?` 模式（`what*`）。要创建一个默认情况来匹配除指定的情况值之外的所有值，可以使用一个单独的 `*`，如前面示例中的最后一个情况所示。

## 11.6 循环

Bourne shell 中有两种循环：`for` 循环和 `while` 循环。

### 11.6.1 for 循环

`for` 循环（也叫做“for each”循环）是最常见的。以下是一个示例：

```
#!/bin/sh
for str in one two three four; do
    echo $str
done
```

在这个列表中，`for`、`in`、`do` 和 `done` 都是 shell 关键字。Shell 执行以下操作：

1.  将变量 `str` 设置为 `in` 关键字后面四个以空格分隔的值中的第一个值（`one`）。

1.  在 `do` 和 `done` 之间运行 `echo` 命令。

1.  返回到 `for` 行，将 `str` 设置为下一个值（`two`），执行 `do` 和 `done` 之间的命令，并重复这个过程，直到它完成 `in` 关键字后面的所有值。

这个脚本的输出如下所示：

```
one
two
three
four
```

### 11.6.2 while 循环

Bourne shell 的 `while` 循环使用退出码，就像 `if` 条件语句一样。例如，以下脚本执行 10 次迭代：

```
#!/bin/sh
FILE=/tmp/whiletest.$$;
echo firstline > $FILE

while tail -10 $FILE | grep -q firstline; do
    # add lines to $FILE until tail -10 $FILE no longer prints "firstline"
    echo -n Number of lines in $FILE:' '
    wc -l $FILE | awk '{print $1}'
    echo newline >> $FILE
done

rm -f $FILE
```

在这里，`grep -q firstline` 的退出码就是测试条件。只要退出码为非零（在本例中，当字符串 `firstline` 不再出现在 `$FILE` 的最后 10 行中时），循环就会退出。

你可以使用 `break` 语句跳出 `while` 循环。Bourne shell 还有一个 `until` 循环，作用与 `while` 类似，不同之处在于，当遇到退出码为零时，它会终止循环，而不是遇到非零退出码。也就是说，你不需要经常使用 `while` 和 `until` 循环。事实上，如果你发现需要使用 `while`，你可能应该使用一个更适合你任务的语言，如 Python 或 `awk`。

## 11.7 命令替换

Bourne shell 可以将命令的标准输出重定向回 shell 自身的命令行。也就是说，你可以将命令的输出作为另一个命令的参数，或者通过将命令包裹在 `$()` 中，将命令输出存储在 shell 变量中。

这个示例将命令的输出存储在 `FLAGS` 变量中。第二行中的粗体代码展示了命令替换。

```
#!/bin/sh
FLAGS=**$(grep ^flags /proc/cpuinfo | sed 's/.*://' | head -1)**
echo Your processor supports:
for f in $FLAGS; do
    case $f in
        fpu)    MSG="floating point unit"
                ;;
        3dnow)  MSG="3DNOW graphics extensions"
                ;;
        mtrr)   MSG="memory type range register"
                ;;
        *)      MSG="unknown"
                ;;
    esac
    echo $f: $MSG
done
```

这个示例有些复杂，因为它展示了你可以在命令替换中使用单引号和管道符。`grep` 命令的结果被传递给 `sed` 命令（关于 `sed` 的更多内容请参见第 11.10.3 节），`sed` 去除所有与表达式 `.*:` 匹配的内容，`sed` 的结果再传递给 `head`。

使用命令替换时很容易过度使用。例如，不要在脚本中使用`$(ls)`，因为使用 shell 来扩展 `*` 更快。此外，如果你想对多个通过 `find` 命令获得的文件名执行命令，考虑使用管道将其传递给 `xargs`，而不是命令替换，或者使用 `-exec` 选项（这两种方法都将在 11.10.4 节中讨论）。

## 11.8 临时文件管理

有时需要创建一个临时文件来收集输出，以便后续命令使用。创建这样的文件时，确保文件名足够独特，以免其他程序意外地写入此文件。有时，使用简单的 shell PID（`$$`）作为文件名就能实现，但当你需要确保没有冲突时，像 `mktemp` 这样的工具通常是更好的选择。

这是使用 `mktemp` 命令创建临时文件名的方法。这个脚本显示了过去两秒内发生的设备中断：

```
#!/bin/sh
TMPFILE1=$(mktemp /tmp/im1.XXXXXX)
TMPFILE2=$(mktemp /tmp/im2.XXXXXX)

cat /proc/interrupts > $TMPFILE1
sleep 2
cat /proc/interrupts > $TMPFILE2
diff $TMPFILE1 $TMPFILE2
rm -f $TMPFILE1 $TMPFILE2
```

`mktemp` 的参数是一个模板。`mktemp` 命令将 `XXXXXX` 转换为一组唯一的字符，并使用该名称创建一个空文件。请注意，这个脚本使用变量名来存储文件名，这样如果你想更改文件名，只需更改一行即可。

使用临时文件的脚本中常见的问题是，如果脚本被中止，临时文件可能会被遗留。在前面的例子中，在第二个 `cat` 命令之前按下 ctrl-C 会将临时文件留在 */tmp* 中。尽可能避免这种情况。相反，使用 `trap` 命令创建一个信号处理器，捕获 ctrl-C 生成的信号并删除临时文件，如以下处理器所示：

```
#!/bin/sh
TMPFILE1=$(mktemp /tmp/im1.XXXXXX)
TMPFILE2=$(mktemp /tmp/im2.XXXXXX)
trap "rm -f $TMPFILE1 $TMPFILE2; exit 1" INT
 --`snip`--
```

必须在处理器中使用 `exit` 来显式结束脚本执行，否则 shell 在运行信号处理器后会继续照常运行。

## 11.9 Here Documents

假设你想打印一大段文本或将大量文本传递给另一个命令。与其使用多个`echo`命令，你可以使用 shell 的 *here document* 特性，如以下脚本所示：

```
#!/bin/sh
DATE=$(date)
cat **<<EOF**
Date: $DATE

The output above is from the Unix date command.
It's not a very interesting command.
**EOF**
```

粗体部分控制着 here document。`<<EOF` 告诉 shell 将随后的所有行重定向到 `<<EOF` 前面的命令的标准输入中，在这个例子中是 `cat`。重定向会在 `EOF` 标记单独出现在一行时停止。该标记实际上可以是任何字符串，但请记住，在 here document 的开始和结束使用相同的标记。另外，惯例是标记应使用全大写字母。

注意 here document 中的 shell 变量 `$DATE`。shell 会在 here document 中扩展 shell 变量，这在你打印包含多个变量的报告时尤其有用。

## 11.10 重要的 Shell 脚本工具

在 Shell 脚本中，有几个程序特别有用。某些工具，如`basename`，只有与其他程序一起使用时才实际有效，因此不常在 Shell 脚本外找到应用。然而，像`awk`这样的程序也可以在命令行上非常有用。

### 11.10.1  basename

如果你需要去除文件名的扩展名或去掉完整路径名中的目录部分，请使用`basename`命令。尝试在命令行中运行这些示例，看看命令是如何工作的：

```
$ **basename example.html .html**
$ **basename /usr/local/bin/example**
```

在这两种情况下，`basename`都会返回`example`。第一个命令去除了*example.html*的*.html*后缀，第二个命令则从完整路径名中去除了目录部分。

这个示例展示了如何在脚本中使用`basename`将 GIF 图像文件转换为 PNG 格式：

```
#!/bin/sh
for file in *.gif; do
    # exit if there are no files
 if [ ! -f $file ]; then
        exit
    fi
    b=$(basename $file .gif)
    echo Converting $b.gif to $b.png...
    giftopnm $b.gif | pnmtopng > $b.png
done
```

### 11.10.2  awk

`awk`命令不是一个简单的单用途命令；它实际上是一种强大的编程语言。不幸的是，`awk`的使用如今已经成为一种失传的技艺，被像 Python 这样的大型语言所取代。

关于`awk`的书籍有很多，包括阿尔弗雷德·V·阿霍（Alfred V. Aho）、布赖恩·W·科尼根（Brian W. Kernighan）和彼得·J·温伯格（Peter J. Weinberger）所著的*The AWK Programming Language*（1988 年，Addison-Wesley）。不过，很多人仅仅用`awk`来做一件事——从输入流中提取单个字段，像这样：

```
$ **ls -l | awk '{print $5}'**
```

该命令打印`ls`输出中的第五个字段（文件大小）。结果是一个文件大小的列表。

### 11.10.3  sed

`sed`（“流编辑器”）程序是一个自动文本编辑器，它接受一个输入流（一个文件或标准输入），根据某些表达式对其进行修改，并将结果输出到标准输出。在很多方面，`sed`像是原始的 Unix 文本编辑器`ed`。它有数十种操作、匹配工具和寻址功能。与`awk`类似，关于`sed`的书籍也有很多，包括一本快速参考书，*sed & awk Pocket Reference*（第二版，Arnold Robbins，O’Reilly，2002 年）。

尽管`sed`是一个大型程序，且深入分析超出了本书的范围，但我们很容易看出它是如何工作的。一般来说，`sed`接受一个地址和一个操作作为参数。地址是一组行，命令则决定如何处理这些行。

`sed`的一个非常常见的任务是用正则表达式替换某些文本（参见第 2.5.1 节），像这样：

```
$ **sed 's/**`exp`**/**`text`**/'**
```

如果你想将每行中的第一个冒号替换为`%`并将结果发送到标准输出，你可以这样做：

```
$ **sed 's/:/%/' /etc/passwd**
```

要替换*/etc/passwd*中的*所有*冒号，可以在操作末尾添加`g`（全局）修饰符，像这样：

```
$ **sed 's**`/:/`**%/g' /etc/passwd**
```

这是一个按行操作的命令；它读取*/etc/passwd*，删除第三行到第六行，并将结果输出到标准输出：

```
$ **sed** **3,6d /etc/passwd**
```

在这个例子中，`3,6` 是地址（行号范围），而 `d` 是操作（删除）。如果省略地址，`sed` 将作用于其输入流中的所有行。最常用的两个 `sed` 操作可能是 `s`（搜索和替换）和 `d`。

你还可以使用正则表达式作为地址。此命令删除与正则表达式 `exp` 匹配的任何行：

```
$ **sed '/**`exp`**/d'**
```

在所有这些示例中，`sed` 写入标准输出，这是最常见的用法。如果没有文件参数，`sed` 会从标准输入读取，这种模式你在 Shell 管道中经常会遇到。

### 11.10.4  xargs

当你必须对大量文件执行一个命令时，命令或 Shell 可能会提示无法将所有参数放入其缓冲区。使用 `xargs` 可以解决这个问题，它通过对标准输入流中的每个文件名执行命令来绕过这个限制。

许多人将 `xargs` 与 `find` 命令一起使用。例如，以下脚本可以帮助你验证当前目录树中每个以 *.gif* 结尾的文件是否确实是 GIF 图像：

```
$ **find . -name '*.gif' -print | xargs file**
```

在这里，`xargs` 运行 `file` 命令。然而，这种调用可能会导致错误或使系统面临安全问题，因为文件名中可能包含空格和换行符。编写脚本时，请使用以下形式，该形式将 `find` 输出的分隔符和 `xargs` 参数分隔符从换行符改为 NULL 字符：

```
$ **find . -name '*.gif' -print0 | xargs -0 file**
```

`xargs` 启动了*大量*进程，因此，如果你有一个很大的文件列表，别指望能得到很好的性能。

如果目标文件名可能以单个短横线（`-`）开头，你可能需要在 `xargs` 命令的末尾添加两个短横线（`--`）。双短横线（`--`）告诉程序，后续的任何参数都是文件名，而不是选项。然而，请记住，并非所有程序都支持双短横线。

当你使用 `find` 时，有一个替代方案是 `xargs`：`-exec` 选项。然而，语法有些复杂，因为你需要提供大括号 `{}` 来替代文件名，并且使用字面量的 `;` 来表示命令的结束。以下是仅使用 `find` 完成前述任务的方法：

```
$ **find . -name '*.gif' -exec file {} \;**
```

### 11.10.5  expr

如果你需要在 Shell 脚本中使用算术运算，`expr` 命令可以提供帮助（甚至能做一些字符串操作）。例如，命令 `expr 1 + 2` 会输出 `3`。（运行 `expr --help` 获取完整的操作列表。）

`expr` 命令是一个笨拙且缓慢的数学运算方法。如果你发现自己经常使用它，可能应该使用像 Python 这样的语言，而不是 Shell 脚本。

### 11.10.6  exec

`exec` 命令是一个内建的 Shell 功能，它将当前的 Shell 进程替换为你在 `exec` 后指定的程序。它执行了第一章中描述的 `exec()` 系统调用。这个功能是为了节省系统资源，但请记住，执行 `exec` 后没有返回；当你在脚本中运行 `exec` 时，脚本和运行脚本的 Shell 都会被新的命令替代。

要在 Shell 窗口中测试这个，试着运行`exec cat`。当你按 ctrl-D 或 ctrl-C 终止`cat`程序后，窗口应该会消失，因为它的子进程已经不存在了。

## 11.11 子 Shell

假设你需要稍微改变 Shell 中的环境，但不希望进行永久更改。你可以使用 Shell 变量改变并恢复环境的一部分（例如路径或工作目录），但这是一种笨重的方法。更简单的选择是使用*子 Shell*，一个全新的 Shell 进程，你可以创建它来运行一两个命令。新 Shell 有一个原 Shell 环境的副本，当新 Shell 退出时，你对其环境所做的任何更改都会消失，初始的 Shell 将正常运行。

使用子 Shell 时，将要由子 Shell 执行的命令放在括号中。例如，以下这一行将在*uglydir*中执行`uglyprogram`命令，同时保持原 Shell 不变：

```
$ **(cd uglydir; uglyprogram)**
```

这个例子展示了如何将一个组件添加到路径中，这可能作为永久更改引发问题：

```
$ **(PATH=/usr/confusing:$PATH; uglyprogram)**
```

使用子 Shell 对环境变量进行一次性更改是非常常见的任务，甚至有一个内置语法可以避免使用子 Shell：

```
$ **PATH=/usr/confusing:$PATH uglyprogram**
```

管道和后台进程也可以与子 Shell 一起工作。以下示例使用`tar`来归档*orig*中的整个目录树，然后将归档文件解压到新目录*target*中，从而有效地复制*orig*中的文件和文件夹（这很有用，因为它保留了所有权和权限，并且通常比使用如`cp -r`等命令更快）：

```
$ **tar cf -** `orig` **| (cd** `target`**; tar xvf -)**
```

## 11.12 包含其他文件到脚本中

如果你需要在 Shell 脚本中包含来自另一个文件的代码，使用点（`.`）操作符。例如，这会执行*config.sh*文件中的命令：

```
. config.sh
```

这种包含方法也称为*源文件*，它在读取变量（例如，在共享配置文件中）和其他类型的定义时非常有用。这不同于执行另一个脚本；当你运行一个脚本（作为命令）时，它会在一个新的 Shell 中启动，除了输出和退出代码，你无法获取其他任何东西。

## 11.13 读取用户输入

`read`命令从标准输入中读取一行文本，并将文本存储在一个变量中。例如，以下命令将输入存储在`$var`中：

```
$ **read** `var`
```

这个内置的 Shell 命令与书中未提到的其他 Shell 特性一起使用时非常有用。通过`read`，你可以创建简单的交互，例如提示用户输入，而不是要求他们在命令行中列出所有内容，并构建“你确定吗？”的确认操作，作为危险操作的前置步骤。

## 11.14 何时（不）使用 Shell 脚本

Shell 功能如此丰富，以至于很难将其重要元素浓缩到单一章节。如果你对 shell 还能做什么感兴趣，可以看看一些关于 shell 编程的书籍，比如 Stephen G. Kochan 和 Patrick Wood 合著的《*Unix Shell* 编程》第三版（SAMS 出版社，2003 年），或 Brian W. Kernighan 和 Rob Pike 合著的《*UNIX 编程环境*》（Prentice Hall，1984 年）中的 shell 脚本讨论。

然而，在某个时刻（特别是当你开始过度使用`read`内置命令时），你必须问问自己，是否仍然使用适合该任务的工具。记住，shell 脚本最擅长的事情是：操作简单的文件和命令。正如前面所说，如果你发现自己写的东西看起来复杂，尤其是涉及到复杂的字符串或算术操作时，不要害怕转向像 Python、Perl 或 `awk` 这样的脚本语言。
