# 第十四章：Linux 桌面与打印的简要概述

![](img/chapterart.png)

本章简要介绍了典型 Linux 桌面系统中的组件。在所有 Linux 系统上的不同类型的软件中，桌面领域是最为多样和丰富多彩的，因为有这么多环境和应用程序可以选择，而且大多数发行版都使你可以相对容易地尝试它们。

与 Linux 系统的其他部分（如存储和网络）不同，创建桌面结构并不涉及一个复杂的层次结构。相反，每个组件执行特定的任务，并根据需要与其他组件进行通信。有些组件确实共享一些共同的构建块（特别是图形工具包的库），你可以将它们视为简单的抽象层，但这也就是它的深度了。

本章提供了对桌面组件的一般讨论，但我们将更详细地探讨其中的两个部分：大多数桌面背后的核心基础设施，以及*D-Bus*，一个在系统许多部分使用的进程间通信服务。我们将把实践讨论和示例限制在一些诊断工具上，尽管这些工具在日常使用中并不特别有用（大多数图形用户界面不需要你输入命令行指令来与之交互），但它们将帮助你理解系统的底层机制，并可能在过程中带来一些娱乐。我们还将简要介绍打印功能，因为桌面工作站通常共享一台公共打印机。

## 14.1 桌面组件

Linux 桌面配置提供了极大的灵活性。Linux 用户所体验的大部分内容（桌面的“外观和感觉”）来自于应用程序或应用程序的构建块。如果你不喜欢某个特定的应用程序，通常可以找到替代品。如果你想要的东西不存在，你可以自己编写。Linux 开发者对桌面应如何表现有各种各样的偏好，这也带来了大量的选择。

为了使得应用程序能够协同工作，所有应用程序需要有一些共同点。在本文写作时，Linux 桌面的核心正处于过渡状态。从一开始到最近，Linux 桌面使用的是 X（*X Window System*，也称为*Xorg*，源于其维护组织）。然而，这种情况现在正在发生变化；许多发行版已过渡到基于*Wayland*协议的软件集来构建窗口系统。

为了理解是什么驱动了基础技术的变化，让我们退后一步，回顾一下图形学的一些基础。

### 14.1.1  帧缓冲

所有图形显示机制的底层是*帧缓存*，这是一个内存块，图形硬件读取并传输到屏幕上进行显示。帧缓存中的几个字节代表显示器的每个像素，因此，如果你想改变某个事物的显示效果，就需要将新值写入帧缓存内存。

窗口系统必须解决的一个问题是如何管理对帧缓存的写入。在任何现代系统中，窗口（或窗口集）属于各自的进程，并独立进行所有图形更新。因此，如果用户被允许移动窗口并让它们部分重叠，应用程序如何知道在哪里绘制图形，如何确保一个应用程序不会覆盖其他窗口的图形？

### 14.1.2  X 窗口系统

X 窗口系统采用的方法是拥有一个服务器（称为*X 服务器*），它充当桌面的“内核”，管理从渲染窗口到配置显示屏、处理来自设备（如键盘和鼠标）的输入等所有事务。X 服务器并不规定任何事物应该如何操作或显示。相反，X *客户端*程序负责处理用户界面。基本的 X 客户端应用程序，如终端窗口和网页浏览器，会与 X 服务器建立连接，并请求绘制窗口。作为回应，X 服务器确定窗口放置的位置以及在哪里渲染客户端图形，并承担一定的责任来渲染图形到帧缓存。X 服务器还会在适当的时候将输入传递给客户端。

由于 X 服务器充当所有事务的中介，它可能成为一个重要的瓶颈。此外，它包含许多已经不再使用的功能，而且它的历史相当悠久，最早可追溯到 1980 年代。尽管如此，它的灵活性足以容纳许多扩展功能，延长了它的生命周期。我们将在本章稍后介绍如何与 X 窗口系统交互的基本方法。

### 14.1.3  Wayland

与 X 不同，Wayland 在设计上显著去中心化。没有一个大型显示服务器为多个图形客户端管理帧缓存，也没有集中式的图形渲染权威。相反，每个客户端都有自己的内存缓冲区（可以将其视为一种子帧缓存）用于自己的窗口，并且有一款名为*合成器*的软件，将所有客户端的缓冲区合并成必要的形式，再将其复制到屏幕的帧缓存中。由于通常有硬件支持这个任务，合成器的效率可以相当高。

在某些方面，Wayland 中的图形模型与大多数 X 客户端多年来一直执行的实践并没有太大不同。大多数客户端并没有从 X 服务器获得任何帮助，而是将它们自己的数据作为位图进行渲染，然后将该位图发送到 X 服务器。为了承认这一点，X 拥有一个合成扩展，该扩展已经使用了好几年。

在将输入通道传递到正确的应用程序任务中，大多数 Wayland 设置和许多 X 服务器使用一个名为*libinput*的库来将事件标准化到客户端。这个库并不是 Wayland 协议所要求的，但在桌面系统上，它几乎是通用的。我们将在 14.3.2 节中讨论 libinput。

### 14.1.4  窗口管理器

X 和 Wayland 系统之间的一个主要区别在于*窗口管理器*，即决定如何安排屏幕上窗口的那部分软件，它对用户体验至关重要。在 X 中，窗口管理器是一个客户端，作为服务器的辅助程序；它绘制窗口的装饰（如标题栏和关闭按钮），处理输入事件并告诉服务器移动窗口的位置。

然而，在 Wayland 中，窗口管理器*实际上*就是服务器。它负责将所有客户端窗口缓冲区合成到显示帧缓冲区中，并处理输入设备事件的传递。因此，它需要做的工作比 X 中的窗口管理器要多，但其中许多代码在不同窗口管理器实现之间是可以共享的。

两个系统中都有许多窗口管理器实现，但 X 由于其长久的存在，拥有更多窗口管理器。然而，许多流行的窗口管理器，如 Mutter（在 GNOME 中）和 Kwin（来自 KDE）也已扩展以支持 Wayland 合成。不管底层技术如何，似乎永远不会有一个标准的 Linux 窗口管理器；因为用户的口味和需求多种多样且不断变化，新窗口管理器不断涌现。

### 14.1.5  工具包

桌面应用程序包括某些常见元素，如按钮和菜单，称为*小部件*。为了加速开发并提供统一的外观，程序员使用图形*工具包*来提供这些元素。在 Windows 或 macOS 等操作系统中，供应商提供了一个通用的工具包，大多数程序员都会使用它。在 Linux 上，GTK+工具包是最常见的之一，但你也会经常看到基于 Qt 框架和其他工具包构建的小部件。

工具包通常由共享库和支持文件组成，如图像和主题信息。

### 14.1.6  桌面环境

尽管工具包为用户提供了统一的外观，但桌面的一些细节仍需要不同应用之间的协作。例如，一个应用可能希望与另一个应用共享数据，或者更新桌面上的公共通知栏。为了满足这些需求，工具包和其他库被打包成更大的软件包，称为*桌面环境*。GNOME、KDE 和 Xfce 是一些常见的 Linux 桌面环境。

工具包是大多数桌面环境的核心，但要创建一个统一的桌面，环境还必须包括许多支持文件，例如图标和配置文件，这些文件构成了主题。所有这些都通过描述设计规范的文档结合在一起，比如应用程序菜单和标题应如何显示，以及应用程序应如何响应某些系统事件。

### 14.1.7 应用程序

桌面顶部是一些应用程序，例如网页浏览器和终端窗口。X 应用程序的范围可以从简单的（例如古老的`xclock`程序）到复杂的（例如 Chrome 浏览器和 LibreOffice 套件）。这些应用通常是独立运行的，但它们通常会使用进程间通信来察觉相关事件。例如，当你插入一个新的存储设备或收到新的电子邮件或即时消息时，应用程序可以表达兴趣。这种通信通常通过 D-Bus 进行，具体描述见第 14.5 节。

## 14.2 你正在运行 Wayland 还是 X？

在开始我们的实践讨论之前，你需要确定你拥有的是哪种图形系统。只需打开一个 shell 并检查`$WAYLAND_DISPLAY`环境变量的值。如果值是类似`wayland-0`的东西，那说明你正在运行 Wayland。如果该变量没有设置，那你可能在运行 X（大概率是这样；虽然也有例外，但通过这个测试你不太可能遇到）。

这两个系统并不是互相排斥的。如果你的系统使用 Wayland，它也很可能在运行一个 X 兼容服务器。也可以在 X 内启动 Wayland 合成器，但那可能会有点奇怪（稍后会详细介绍）。

## 14.3 更深入了解 Wayland

我们将从 Wayland 开始，因为它是新兴标准，目前在许多发行版中默认使用。不幸的是，由于其设计和年轻的历史，关于 Wayland 的工具不像 X 那样丰富。我们会尽力而为。

但首先，让我们来谈谈 Wayland*是什么*以及*不是*。*Wayland*这个名称指的是合成窗口管理器与图形客户端程序之间的通信协议。如果你去寻找一个大的 Wayland 核心包，你是找不到的，但你会找到大多数客户端用来与该协议进行通信的 Wayland 库（至少目前是这样）。

还有一个参考性的合成窗口管理器，叫做 Weston，以及一些相关的客户端和工具。这里的 *参考* 意思是 Weston 包含了合成器所需的基本功能，但它不适合普通用户使用，因为它的界面非常简陋。这个设计的目的是让合成窗口管理器的开发者可以查看 Weston 的源代码，了解如何正确实现关键功能。

### 14.3.1  合成窗口管理器

虽然听起来有些奇怪，但你可能并不知道自己实际运行的是哪个 Wayland 合成窗口管理器。你也许能通过界面中的信息选项找到它的名称，但没有固定的位置可以查看。然而，你几乎总是可以通过追踪它与客户端通信所使用的 Unix 域套接字来找到正在运行的合成器进程。这个套接字就是 `WAYLAND_DISPLAY` 环境变量中的显示名称，通常是 `wayland-0`，并且通常可以在 */run/user/<uid>* 路径下找到，其中 *<uid>* 是你的用户 ID（如果没有，检查 `$XDG_RUNTIME_DIR` 环境变量）。以 root 用户身份运行时，你可以通过 `ss` 命令找到监听此套接字的进程，但输出可能看起来有些混乱：

```
# ss -xlp | grep wayland-
u_str             LISTEN              0                    128                                                                         /run/user/1000/wayland-0 755881                                                * 0             users:(("gnome-shell",pid=1522,fd=30),("gnome-shell",pid=1522,fd=28))
```

然而，你只需要筛选一下；你可以看到，这里合成器进程是`gnome-shell`，PID 1522。遗憾的是，这里又有一层间接性；GNOME shell 是 Mutter 的插件，而 Mutter 是 GNOME 桌面环境中使用的合成窗口管理器。（在这里，称 GNOME shell 为插件只是意味着它将 Mutter 作为库来调用。）

在 Wayland 合成器的上下文中，你可以将 *显示* 理解为可视区域，由帧缓冲区表示。一个显示可以跨多个显示器，如果计算机连接了多个显示器的话。

虽然比较罕见，但你可以同时运行多个合成器。实现这一点的一种方式是将合成器分别运行在不同的虚拟终端上。在这种情况下，第一个合成器通常会将显示名称设置为 `wayland-0`，第二个为 `wayland-1`，依此类推。

你可以通过 `weston-info` 命令来获得一些关于合成器的见解，该命令显示合成器可用的接口的一些特性。不过，你不应期望看到太多，除了显示和一些输入设备的信息。

### 14.3.2  libinput

为了将来自设备（如键盘）的输入从内核传递到客户端，Wayland 合成器需要收集这些输入并以标准化的形式将其传递给适当的客户端。libinput 库提供了必要的支持，能够从各种 */dev/input* 内核设备中收集输入并进行处理。在 Wayland 中，合成器通常不会直接将输入事件原样传递；它会将事件翻译成 Wayland 协议后再发送给客户端。

通常，像 libinput 这样的工具不会特别引人注目，但它带有一个小工具，也叫 `libinput`，允许你检查由内核呈现的输入设备和事件。

尝试以下方法查看可用的输入设备（你可能会得到很多输出，因此要准备好翻页查看）：

```
# libinput list-devices
`--snip--`
Device:           Cypress USB Keyboard
Kernel:           /dev/input/event3
Group:            6
Seat:             seat0, default
Capabilities:     keyboard 
Tap-to-click:     n/a
Tap-and-drag:     n/a
Tap drag lock:    n/a
Left-handed:      n/a
`--snip--`
```

在这个局部视图中，你可以看到设备的类型（键盘）以及内核 `evdev` 设备的位置（*/dev/input/event3*）。当你监听这些事件时，该设备会出现：

```
# libinput debug-events --show-keycodes
-event2   DEVICE_ADDED     Power Button                      seat0 default group1  cap:k
`--snip--`
-event5   DEVICE_ADDED     Logitech T400                     seat0 default group5  cap:kp left scroll-nat scroll-button
-event3   DEVICE_ADDED     Cypress USB Keyboard              seat0 default group6  cap:k
`--snip--`
 event3   KEYBOARD_KEY      +1.04s      KEY_H (35) pressed
 event3   KEYBOARD_KEY      +1.10s      KEY_H (35) released
 event3   KEYBOARD_KEY      +3.06s      KEY_I (23) pressed
 event3   KEYBOARD_KEY      +3.16s      KEY_I (23) released
```

当你运行此命令时，移动鼠标指针并按下某些键。你将获得一些描述这些事件的输出。

记住，libinput 库只是一个用于捕捉内核事件的系统。因此，它不仅在 Wayland 下使用，也在 X 窗口系统下使用。

### 14.3.3  Wayland 中的 X 兼容性

在讨论 X 窗口系统之前，让我们先探索它与 Wayland 的兼容性。X 有无数的应用程序，任何从 X 迁移到 Wayland 的尝试都将因缺乏 X 支持而受到极大的阻碍。有两种同步的方法可以弥合这个差距。

第一个方法是为应用程序添加 Wayland 支持，从而创建一个原生的 Wayland 应用程序。大多数在 X 上运行的图形应用程序已经使用了像 GNOME 和 KDE 中的工具包。由于为这些工具包添加 Wayland 支持的工作已经完成，所以将一个 X 应用程序转变为原生的 Wayland 应用程序并不困难。除了关注窗口装饰和输入设备配置的支持外，开发者只需要处理应用程序中那些稀有的 X 库依赖。对于许多主要的应用程序，这项工作已经完成。

另一种方法是通过 Wayland 中的兼容层运行 X 应用程序。这是通过作为 Wayland 客户端运行整个 X 服务器来实现的。这个服务器叫做 `Xwayland`，其实只是另一个被嵌入在 X 客户端下的层，默认情况下由大多数合成器启动序列运行。`Xwayland` 服务器需要翻译输入事件，并单独维护其窗口缓冲区。引入像这样的中间人总会稍微减慢速度，但大多数情况下，这并没有什么实质性影响。

反向操作则不太奏效。你不能像在 X 上运行 Wayland 客户端那样运行它（理论上，写出这样的系统是可能的，但没有太大意义）。然而，你可以在 X 窗口内运行一个合成器。例如，如果你正在运行 X，可以在命令行中运行 `weston` 来启动一个合成器。你可以在合成器内打开终端窗口和任何其他 Wayland 应用程序，甚至可以在正确启动了 `Xwayland` 后，在合成器内运行 X 客户端。

然而，如果你保持这个合成器运行并返回到你的常规 X 会话，你可能会发现某些工具无法按预期工作，甚至可能会出现在合成器窗口中，而你预期它们应该出现在 X 窗口中。原因是许多 GNOME 和 KDE 等系统上的应用程序现在都同时支持 X 和 Wayland。它们首先会寻找一个 Wayland 合成器，如果`WAYLAND_DISPLAY`环境变量没有设置，`libwayland`中的代码默认会查找`wayland-0`。找到一个可用的合成器时，应用程序会使用它。

避免这种情况的最好方法是简单地不要在 X 内部或与 X 服务器同时运行合成器。

## 14.4 更深入了解 X 窗口系统

与基于 Wayland 的系统相比，X 窗口系统（[`www.x.org/`](http://www.x.org/)）历来非常庞大，基本发行版包括 X 服务器、客户端支持库和客户端。由于 GNOME 和 KDE 等桌面环境的出现，X 的角色随着时间的推移发生了变化，现在的重点更多放在管理渲染和输入设备的核心服务器上，并简化了客户端库。

X 服务器在你的系统上很容易识别。它被称为`X`或`Xorg`。查看进程列表，你通常会看到它运行时带有一些选项，像这样：

```
Xorg -core :0 -seat seat0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch
```

这里显示的`:0`称为*X 显示器*，是一个标识符，代表你通过共同的键盘和/或鼠标访问的一个或多个显示器。通常，显示器对应于连接到计算机的单个显示器，但你也可以将多个显示器放置在同一个显示器下。对于在 X 会话下运行的进程，`DISPLAY`环境变量会设置为显示器标识符。

在 Linux 上，X 服务器运行在虚拟终端上。在这个例子中，`vt7`参数表明它被指示在*/dev/tty7*上运行（通常，服务器会在第一个可用的虚拟终端上启动）。你可以通过在不同的虚拟终端上运行多个 X 服务器来同时运行多个 X 服务器，每个服务器都有一个唯一的显示标识符。你可以通过按 ctrl-alt-fn 键或使用`chvt`命令在服务器之间切换。

### 14.4.1  显示管理器

通常你不会在命令行上启动 X 服务器，因为启动服务器并不会定义任何应该在其上运行的客户端。如果你单独启动服务器，你只会看到一个空白屏幕。相反，启动 X 服务器最常见的方法是使用*显示管理器*，这是一种启动服务器并在屏幕上显示登录框的程序。当你登录时，显示管理器会启动一组客户端程序，比如窗口管理器和文件管理器，这样你就可以开始使用机器了。

有许多不同的显示管理器可用，如`gdm`（用于 GNOME）和`kdm`（用于 KDE）。在前述 X 服务器调用的参数列表中的`lightdm`是一个跨平台的显示管理器，旨在能够启动 GNOME 或 KDE 会话。

如果你坚持从虚拟控制台启动 X 会话，而不是使用显示管理器，可以运行`startx`或`xinit`命令。然而，得到的会话可能非常简单，看起来完全不像显示管理器的界面，因为其机制和启动文件不同。

### 14.4.2  网络透明性

X 的一个特点是网络透明性。由于客户端通过协议与服务器通信，可以在网络上跨不同机器直接运行客户端，X 服务器监听 TCP 端口 6000 上的连接。连接到该端口的客户端可以进行身份验证，并将窗口发送到服务器。

不幸的是，这种方法通常不提供加密，因此存在安全隐患。为了弥补这一漏洞，大多数发行版现在会禁用 X 服务器的网络监听（通过向服务器添加`-nolisten tcp`选项）。然而，你仍然可以通过 SSH 隧道从远程机器运行 X 客户端，正如第十章所描述的那样，将 X 服务器的 Unix 域套接字连接到远程机器上的套接字。

### 14.4.3 探索 X 客户端的方式

尽管通常不会想到从命令行操作图形用户界面，但有几个工具可以让你探索 X 窗口系统的各个部分。特别是，你可以检查正在运行的客户端。

最简单的工具之一是`xwininfo`。当没有任何参数运行时，它会提示你点击一个窗口：

```
$ **xwininfo** 
xwininfo: Please select the window about which you
          would like information by clicking the
          mouse in that window.
```

点击后，它会打印有关窗口的信息列表，如其位置和大小：

```
xwininfo: Window id: 0x5400024 "xterm"

  Absolute upper-left X:  1075
  Absolute upper-left Y:  594
--`snip`--
```

注意这里的窗口 ID。X 服务器和窗口管理器使用这个标识符来跟踪窗口。要获取所有窗口 ID 和客户端的列表，可以使用`xlsclients -l`命令。

### 14.4.4  X 事件

X 客户端通过事件系统获取输入和服务器状态的其他信息。X 事件像其他异步进程间通信事件一样工作，例如 udev 事件和 D-Bus 事件。X 服务器接收来自输入设备等来源的信息，然后将这些输入作为事件重新分发给任何感兴趣的 X 客户端。

你可以通过`xev`命令来实验事件。运行它会打开一个新窗口，你可以将鼠标移动到窗口中，点击并输入。当你这么做时，`xev`会生成描述它从服务器接收到的 X 事件的输出。例如，下面是鼠标移动的示例输出：

```
$ **xev**
`--snip--`
MotionNotify event, serial 36, synthetic NO, window 0x6800001,
    root 0xbb, subw 0x0, time 43937883, (47,174), root:(1692,486),
    state 0x0, is_hint 0, same_screen YES

MotionNotify event, serial 36, synthetic NO, window 0x6800001,
    root 0xbb, subw 0x0, time 43937891, (43,177), root:(1688,489),
    state 0x0, is_hint 0, same_screen YES
```

注意括号中的坐标。第一对坐标表示鼠标指针在窗口中的 x 和 y 坐标，第二对（`root:`）表示指针在整个显示器上的位置。

其他低级事件包括按键和按钮点击，但更高级的事件则表示鼠标是否进入或退出窗口，或者窗口是否获得或失去来自窗口管理器的焦点。例如，下面是相应的退出和失去焦点事件。

```
LeaveNotify event, serial 36, synthetic NO, window 0x6800001,
    root 0xbb, subw 0x0, time 44348653, (55,185), root:(1679,420),
    mode NotifyNormal, detail NotifyNonlinear, same_screen YES,
    focus YES, state 0

FocusOut event, serial 36, synthetic NO, window 0x6800001,
    mode NotifyNormal, detail NotifyNonlinear
```

`xev` 的一个常见用途是提取不同键盘的键码和按键符号，特别是在重新映射键盘时。以下是按下 L 键时的输出；这里的键码是 46：

```
KeyPress event, serial 32, synthetic NO, window 0x4c00001,
    root 0xbb, subw 0x0, time 2084270084, (131,120), root:(197,172),
    state 0x0, keycode 46 (keysym 0x6c, l), same_screen YES,
    XLookupString gives 1 bytes: (6c) "l"
    XmbLookupString gives 1 bytes: (6c) "l"
    XFilterEvent returns: False
```

你还可以将 `xev` 附加到现有的窗口 ID 上，使用 `-id` `id` 选项。用从 `xwininfo` 获取的 ID 替换 `id`（它将是一个以 `0x` 开头的十六进制数字）。

### 14.4.5  X 输入和首选项设置

X 的一个潜在困惑特性是，设置首选项通常有多种方式，而且某些方法可能无法生效。例如，Linux 系统上一种常见的键盘设置是将 Caps Lock 键重新映射为 Ctrl 键。实现此操作有多种方法，从使用旧的`xmodmap`命令进行小幅调整，到通过`setxkbmap`工具提供一个全新的键盘映射。你如何知道该使用哪一种（如果有的话）呢？这取决于了解系统中哪些部分负责处理，但要确定这一点可能会很困难。请记住，桌面环境可能会提供自己的设置并进行覆盖。话虽如此，以下是一些关于底层基础设施的提示。

#### 输入设备（一般）

X 服务器使用 *X 输入扩展* 来管理来自多个设备的输入。有两种基本类型的输入设备——键盘和指针（鼠标）——你可以连接任意多的设备。为了同时处理多个相同类型的设备，X 输入扩展创建了一个 *虚拟核心* 设备，将设备输入引导到 X 服务器。

要查看你机器上的设备配置，可以运行 `xinput --list` 命令：

```
$ **xinput --list**
∣ Virtual core pointer                           id=2    [master pointer  (3)]
∣   ↳Virtual core XTEST pointer                 id=4    [slave  pointer  (2)]
∣   ↳ Logitech Unifying Device                  id=8    [slave  pointer  (2)]
⌊ Virtual core keyboard                          id=3    [master keyboard (2)]
    ↳ Virtual core XTEST keyboard               id=5    [slave  keyboard (3)]
    ↳ Power Button                              id=6    [slave  keyboard (3)]
    ↳ Power Button                              id=7    [slave  keyboard (3)]
    ↳ Cypress USB Keyboard                      id=9    [slave  keyboard (3)]
```

每个设备都有一个关联的 ID，你可以在 `xinput` 和其他命令中使用该 ID。在此输出中，ID 2 和 3 是核心设备，ID 8 和 9 是实际设备。注意，机器上的电源按钮也被视为 X 输入设备。

大多数 X 客户端监听来自核心设备的输入，因为它们无需关心是哪个特定设备触发了事件。事实上，大多数客户端对 X 输入扩展一无所知。然而，客户端可以使用该扩展来单独指定某个设备。

每个设备都有一组相关的 *属性*。要查看这些属性，可以使用带设备编号的 `xinput`：

```
$ **xinput --list-props 8**
Device 'Logitech Unifying Device. Wireless PID:4026':
        Device Enabled (126):   1
        Coordinate Transformation Matrix (128): 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000
        Device Accel Profile (256):     0
        Device Accel Constant Deceleration (257):       1.000000
        Device Accel Adaptive Deceleration (258):       1.000000
        Device Accel Velocity Scaling (259):    10.000000
`--snip--`
```

你可以使用 `--set-prop` 选项更改多个属性。有关更多信息，请参阅 xinput(1) 手册页。

#### 鼠标

你可以使用`xinput`命令操作与设备相关的设置，许多最有用的选项与鼠标（指针）相关。你可以直接将许多设置作为属性进行更改，但通常使用专门的`--set-ptr-feedback`和`--set-button-map`选项来操作`xinput`会更容易。例如，如果你有一个三按钮鼠标，位于`dev`上，并且你想要反转按钮的顺序（这对左撇子用户很有用），可以尝试这样做：

```
$ **xinput --set-button-map** `dev` **3 2 1**
```

#### 键盘

不同国家/地区提供的多种键盘布局在集成到任何窗口系统时会带来特别的困难。X 一直在其核心协议中提供一个内部的键盘映射功能，你可以使用`xmodmap`命令进行操作，但任何较新的系统都会使用 XKB（X 键盘扩展）来获得更精细的控制。

XKB 很复杂，以至于许多人在需要快速更改时仍然使用`xmodmap`。XKB 的基本概念是，你可以定义一个键盘映射，用`xkbcomp`命令编译它，然后使用`setxkbmap`命令将该映射加载并激活到 X 服务器中。这个系统有两个特别有趣的特点：

+   你可以定义部分映射来补充现有的映射。这对于一些任务非常有用，例如将 Caps Lock 键改为 Ctrl 键，许多桌面环境中的图形键盘偏好设置工具都会用到它。

+   你可以为每个附加的键盘定义单独的映射。

#### 桌面背景

你的 X 服务器的*根窗口*是显示器的背景。旧的 X 命令`xsetroot`允许你设置根窗口的背景颜色和其他特性，但由于根窗口通常不可见，它在大多数机器上没有效果。相反，大多数桌面环境将一个大的窗口放置在所有其他窗口的后面，以启用诸如“动态壁纸”和桌面文件浏览等功能。有一些方法可以通过命令行更改背景（例如，在一些 GNOME 安装中使用`gsettings`命令），但如果你真的*想*这样做，你可能是有点闲暇时间。

#### xset

可能最古老的偏好命令是`xset`。虽然它现在用得不多，但你可以快速运行`xset q`来查看一些功能的状态。最有用的功能可能是屏幕保护程序和*显示电源管理信号（DPMS）*设置。

## 14.5 D-Bus

从 Linux 桌面中涌现出的最重要的进展之一是*桌面总线（D-Bus）*，一个消息传递系统。D-Bus 之所以重要，是因为它作为一个进程间通信机制，允许桌面应用程序相互通信，并且因为大多数 Linux 系统都使用它来通知进程系统事件，比如插入 USB 驱动器。

D-Bus 本身由一个库组成，该库通过协议标准化了进程间通信，并提供支持功能，使任何两个进程能够互相通信。单独来看，这个库不过是普通 IPC（进程间通信）设施的一个高级版本，例如 Unix 域套接字。D-Bus 的真正价值在于一个名为 `dbus-daemon` 的中心“枢纽”。需要响应事件的进程可以连接到 `dbus-daemon` 并注册接收某些类型的事件。连接的进程也会生成这些事件。例如，进程 `udisks-daemon` 监控 udev 中的磁盘事件，并将它们发送给 `dbus-daemon`，然后后者会将事件转发给对磁盘事件感兴趣的应用程序。

### 14.5.1  系统与会话实例

D-Bus 已成为 Linux 系统的核心部分，并且现在已超越桌面应用。例如，systemd 和 Upstart 都有 D-Bus 通信渠道。然而，将桌面工具的依赖添加到核心系统中违背了 Linux 的设计原则。

为了解决这个问题，实际上有两种 `dbus-daemon` 实例（进程）可以运行。第一种是 *系统实例*，它由 init 在启动时通过 `--system` 选项启动。系统实例通常以 D-Bus 用户身份运行，其配置文件是 */etc/dbus-1/system.conf*（不过你可能不应该修改该配置）。进程可以通过 */var/run/dbus/system_bus_socket* Unix 域套接字连接到系统实例。

独立于系统 D-Bus 实例，还有一个可选的 *会话实例*，它只在你启动桌面会话时运行。你运行的桌面应用程序会连接到这个实例。

### 14.5.2  D-Bus 消息监控

查看系统和会话 `dbus-daemon` 实例之间差异的最好方法之一是监控总线上的事件。尝试在系统模式下使用 `dbus-monitor` 工具，如下所示：

```
# dbus-monitor --system
signal sender=org.freedesktop.DBus -> dest=:1.952 serial=2 path=/org/freedesktop/DBus; interface=org.freedesktop.DBus; member=NameAcquired
   string ":1.952"
```

启动消息表明监视器已经连接并获得了一个名称。当你这样运行时，通常不会看到太多活动，因为系统实例通常不会很忙。为了看到一些活动，尝试插入一个 USB 存储设备。

相比之下，会话实例的工作要复杂得多。假设你已经登录到桌面会话，尝试以下操作：

```
$ **dbus-monitor --session**
```

现在尝试使用桌面应用程序，例如文件管理器；如果你的桌面环境支持 D-Bus，你应该会看到一系列指示各种变化的消息。请记住，并非所有应用程序都会生成消息。

## 14.6 打印

在 Linux 上打印文档是一个多阶段过程：

1.  执行打印的程序通常会将文档转换为 PostScript 格式。这一步是可选的。

1.  程序将文档发送给打印服务器。

1.  打印服务器接收文档并将其放入打印队列。

1.  当文档在队列中的顺序到来时，打印服务器将文档发送给打印过滤器。

1.  如果文档不是 PostScript 格式，打印过滤器可能会进行转换。

1.  如果目标打印机不理解 PostScript，打印机驱动程序会将文档转换为与打印机兼容的格式。

1.  打印机驱动程序会向文档添加可选指令，例如纸盘和双面打印选项。

1.  打印服务器使用后端将文档发送到打印机。

这个过程最令人困惑的部分是为什么如此多的内容都围绕着 PostScript 展开。PostScript 实际上是一种编程语言，因此当你使用它打印文件时，你实际上是在将一个程序发送到打印机。PostScript 作为 Unix-like 系统中打印的标准，就像*.tar*格式作为归档标准一样。（现在一些应用程序使用 PDF 输出，但这相对容易转换。）

我们稍后会详细讨论打印格式，但首先让我们来看一下排队系统。

### 14.6.1  CUPS

Linux 中的标准打印系统是*CUPS*（[`www.cups.org/`](http://www.cups.org/)），它与 macOS 上使用的系统相同。CUPS 服务器守护进程称为`cupsd`，你可以使用`lpr`命令作为简单客户端将文件发送到守护进程。

CUPS 的一个显著特点是它实现了*互联网打印协议（IPP）*，这是一种允许客户端和服务器在 TCP 端口 631 上进行类似 HTTP 的事务的系统。事实上，如果你的系统上运行着 CUPS，你可能可以连接到*http://localhost:631/*来查看当前配置并检查打印任务。大多数网络打印机和打印服务器都支持 IPP，Windows 也是如此，这使得设置远程打印机成为一项相对简单的任务。

你可能无法通过网页界面管理系统，因为默认设置并不非常安全。相反，你的发行版很可能有一个图形设置界面来添加和修改打印机。这些工具会操作配置文件，通常位于*/etc/cups*目录下。通常最好让这些工具为你工作，因为配置可能会很复杂。即使你确实遇到问题并需要手动配置，通常最好通过图形工具创建一个打印机，这样你就有了一个起点。

### 14.6.2  格式转换与打印过滤器

许多打印机，包括几乎所有低端型号，都不理解 PostScript 或 PDF。为了支持这些打印机，Linux 打印系统必须将文档转换为特定打印机的格式。CUPS 将文档发送到*光栅图像处理器（RIP）*来生成位图。RIP 几乎总是使用 Ghostscript（`gs`）程序来完成大部分实际工作，但这有点复杂，因为位图必须适应打印机的格式。因此，CUPS 使用的打印机驱动程序会查阅特定打印机的*PostScript 打印机定义（PPD）*文件，以确定分辨率和纸张大小等设置。

## 14.7 其他桌面主题

Linux 桌面环境的一个有趣特点是，你通常可以选择自己想使用的部分，并且停止使用那些你不喜欢的部分。对于各种桌面项目的调查，可以查看 *https://www.freedesktop.org/* 上的邮件列表和项目链接。

Linux 桌面领域的另一个重要进展是 Chromium OS 开源项目及其在 Chromebook PC 上的 Google Chrome OS 对应系统。这是一个 Linux 系统，使用了本章中描述的许多桌面技术，但其核心是 Chromium/Chrome 网络浏览器。许多传统桌面系统中的功能在 Chrome OS 中被去除。

尽管桌面环境在视觉上可能很有趣且值得尝试，但我们需要在这里结束讨论。然而，如果这一章引发了你的兴趣，并且你认为自己可能想要在这些方面工作，那么你就需要了解开发者工具的工作原理，而这正是我们接下来要探讨的内容。
