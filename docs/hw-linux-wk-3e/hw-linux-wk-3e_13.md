# 第十三章：用户环境

![](img/chapterart.png)

本书的主要内容聚焦于 Linux 系统中通常支持服务器进程和交互式用户会话的部分。但最终，系统和用户必须在某个地方相遇。启动文件在这一点上起着重要作用，因为它们为 shell 和其他交互式程序设置默认值。它们决定了用户登录时系统的行为。

大多数用户并不会密切关注自己的启动文件，只有在想要添加一些方便的内容（例如别名）时才会修改它们。随着时间的推移，这些文件会被不必要的环境变量和测试混杂，可能会导致令人烦恼（甚至相当严重）的错误。

如果你已经使用 Linux 一段时间，你可能注意到，随着时间的推移，你的主目录会累积一堆令人困惑的启动文件。这些文件有时被称为 *dot 文件*，因为它们几乎总是以一个点（*.*）开头，这使得它们不会出现在 `ls` 和大多数文件管理器的默认显示中。这些文件中的许多在你第一次运行程序时会自动创建，你也永远不需要修改它们。本章主要讨论的是 shell 启动文件，这些文件是你最可能修改或从头编写的。首先，让我们看看在处理这些文件时你需要多么小心。

## 13.1 创建启动文件的指南

在设计启动文件时，要考虑到用户。如果你是机器上唯一的用户，你无需太多担心，因为任何错误只会影响你，而且修复起来相对简单。然而，如果你正在创建启动文件，目的是作为所有新用户在一台机器或网络上的默认文件，或者如果你认为有人可能会将你的文件复制到其他机器使用，那么这个过程就变得非常重要。如果你在启动文件中犯了一个错误，并将其分发给了 10 个用户，那么你可能需要修复 10 次这个错误。

在为其他用户创建启动文件时，记住两个基本目标：

1.  简洁性：保持启动文件数量尽可能少，且尽量使文件简短而简单，这样它们便于修改，同时不容易出错。每个启动文件中的项目都可能成为导致问题的因素。

1.  可读性：在文件中使用大量注释，让用户清楚地了解文件中每一部分的作用。

## 13.2 何时修改启动文件

在修改启动文件之前，问问自己是否真的应该这么做。以下是更改启动文件的一些合理理由：

+   你想要更改默认提示符。

+   你需要适应一些关键的本地安装软件。（不过，可以先考虑使用包装脚本。）

+   你的现有启动文件已损坏。

如果你的 Linux 发行版一切正常，要小心。有时，默认的启动文件与 */etc* 中的其他文件会相互作用。

话虽如此，如果你不想改变默认设置，你可能不会阅读这一章，因此让我们来看看重要的内容。

## 13.3 Shell 启动文件元素

启动文件中应该包含什么？一些内容看起来可能显而易见，例如命令路径和提示符设置。但到底*应该*在路径中包含什么？合理的提示符应该是什么样的？启动文件中放入多少内容算是过多？

本节讨论了 shell 启动文件的基本内容——从命令路径、提示符、别名到权限掩码。

### 13.3.1  命令路径

任何 shell 启动文件中最重要的部分是命令路径。路径应该涵盖包含每个普通用户感兴趣的应用程序的目录。至少，路径应该按顺序包含以下组件：

```
/usr/local/bin
/usr/bin
/bin
```

这个顺序确保你可以使用位于*/usr/local*中的特定站点变体来覆盖标准的默认程序。

大多数 Linux 发行版将几乎所有打包的用户软件的可执行文件安装在*/usr/bin*中。随着时间的推移，也有一些偶尔的差异，例如将游戏放在*/usr/games*，将图形应用程序放在单独的位置，因此首先检查系统的默认设置。并确保系统上每个通用程序都可以通过刚才列出的某个目录访问。如果不能，那么你的系统可能已经失控。不要为了适应每个新的软件安装目录而改变用户环境中的默认路径。一个廉价的解决方案是使用符号链接将其指向*/usr/local/bin*。

许多用户会创建自己的 *bin* 目录来存储 shell 脚本和程序，因此你可能想将其添加到路径的最前面：

```
$HOME/bin
```

如果你对系统工具（如`sysctl`、`fdisk`和`lsmod`）感兴趣，可以将 *sbin* 目录添加到你的路径中：

```
/usr/local/sbin
/usr/sbin
/sbin
```

### 13.3.2  手册页路径

传统的手册页路径是由`MANPATH`环境变量决定的，但你不应该设置它，因为这样会覆盖系统默认的*/etc/manpath.config*。

### 13.3.3  提示符

经验丰富的用户倾向于避免冗长、复杂且无用的提示符。相比之下，许多管理员和发行版将所有内容都拖入默认提示符中。即使是许多 shell 默认提示符也杂乱无章或大多数情况下毫无用处。例如，默认的`bash`提示符包含了 shell 的名称和版本号。你的选择应反映用户的需求；如果对用户有帮助，可以在提示符中放置当前工作目录、主机名和用户名。

最重要的是，避免使用对 shell 来说具有特殊意义的字符，例如以下这些：

```
{ } = & < >
```

这个简单的`bash`提示符设置以传统的 `$` 结束（传统的 `csh` 提示符以 `%` 结束）：

```
PS1='\u\$ '
```

`\u` 是 shell 会评估为当前用户名的表达式（请参阅 bash(1) 手册页中的 PROMPTING 部分）。其他常用的表达式包括：

1.  `\h` 主机名（简短形式，不带域名）。

1.  `\!` 历史编号。

1.  `\w` 当前目录。由于这可能变得很长，你可以通过使用`\W`来限制显示只显示最后一个组件。

1.  `\$` 如果作为用户账户运行，则为`$`；如果为 root 用户，则为`#`。

### 13.3.4  别名

当代用户环境中的一些棘手问题之一是*别名*的角色，这是一个在执行命令之前将一个字符串替换为另一个字符串的 shell 功能。别名可以是节省打字的有效快捷方式。然而，它们也有几个缺点：

+   操作参数可能会很棘手。

+   它们容易让人困惑；shell 的内置`which`命令可以告诉你某个东西是否是别名，但它不会告诉你它是在哪里定义的。

+   在子 shell 和非交互式 shell 中，它们不受欢迎；它们不会传递给子 shell。

定义别名时一个经典的错误是为现有命令添加额外的参数——例如，将`ls`别名为`ls -F`。充其量，这会使你在不需要时很难移除`-F`参数。最糟糕的是，它可能会对不理解自己没有使用默认参数的用户造成严重后果。

鉴于这些缺点，你应该尽可能避免使用别名；编写一个 shell 函数或一个全新的 shell 脚本要更容易。计算机可以非常快速地启动并执行 shell，因此别名和全新命令之间的差异应该是不可察觉的。

也就是说，当你希望更改 shell 环境的一部分时，别名确实会派上用场。你不能通过 shell 脚本来更改环境变量，因为脚本作为子 shell 运行。（但是，你可以定义 shell 函数来执行这个任务。）

### 13.3.5  权限掩码

如第二章所述，shell 的内置`umask`（权限掩码）功能设置了你的默认权限。在你的启动文件中包含`umask`命令，以确保你运行的任何程序创建的文件具有你期望的权限。有两种合理的选择：

1.  `077` 这个掩码是最严格的权限掩码；它不允许其他用户访问新创建的文件和目录。这通常适用于多用户系统，在这种系统中，你不希望其他用户查看你的任何文件。然而，作为默认设置时，当你的用户希望共享文件但不理解如何正确设置权限时，这个掩码有时会导致问题。（缺乏经验的用户往往会将文件设置为世界可写模式。）

1.  `022` 这个掩码允许其他用户读取新创建的文件和目录。在单用户系统上，这可能是一个不错的选择，因为许多以伪用户身份运行的守护进程将无法看到使用更严格的`077` umask 创建的文件和目录。

## 13.4 启动文件顺序和示例

现在你已经知道了应该把什么内容放入 shell 启动文件中，接下来是一些具体的示例。令人惊讶的是，创建启动文件时最困难和最令人困惑的部分之一是确定使用多个可能的启动文件中的哪一个。本节将介绍两种最流行的 Unix shell：`bash` 和 `tcsh`。

### 13.4.1  bash Shell

在 `bash` 中，你可以选择启动文件名 *.bash_profile*、*.profile*、*.bash_login* 和 *.bashrc*。哪个文件适合你的命令路径、手册页路径、提示符、别名和权限掩码呢？答案是，你应该有一个 *.bashrc* 文件，并附带一个指向 *.bashrc* 的 *.bash_profile* 符号链接，因为 `bash` shell 实例类型有几种不同的选择。

两种主要的 shell 实例类型是交互式和非交互式，但我们只关心交互式 shell，因为非交互式 shell（例如运行 shell 脚本时）通常不会读取任何启动文件。交互式 shell 是你用来从终端运行命令的 shell，就像本书中提到的那些，它们可以分为 *登录* 或 *非登录*。

#### 登录 shell

传统上，登录 shell 是你通过终端登录系统时获得的 shell，通常使用如 */bin/login* 的程序。通过 SSH 远程登录也会提供登录 shell。基本思想是登录 shell 是一个初始 shell。你可以通过运行 `echo $0` 来判断一个 shell 是否是登录 shell；如果第一个字符是 `-`，则该 shell 是登录 shell。

当 `bash` 作为登录 shell 运行时，它会运行 */etc/profile*。然后，它会查找用户的 *.bash_profile*、*.bash_login* 和 *.profile* 文件，并只运行它看到的第一个文件。

听起来很奇怪，但实际上你可以通过将非交互式 shell 作为登录 shell 来强制其运行启动文件。为此，可以使用 `-l` 或 `--login` 选项启动 shell。

#### 非登录 shell

非登录 shell 是你登录后运行的附加 shell。它只是任何非登录 shell 的交互式 shell。窗口系统终端程序（如 `xterm`、GNOME Terminal 等）通常会启动非登录 shell，除非你特别要求使用登录 shell。

当 `bash` 启动为非登录 shell 时，它会运行 */etc/bash.bashrc*，然后运行用户的 *.bashrc* 文件。

#### 两种 shell 的后果

两种不同启动文件背后的原因是，在早期，用户通过传统终端登录系统时会使用登录 shell，然后使用窗口系统或 `screen` 程序启动非登录子 shell。对于非登录子 shell，反复设置用户环境和运行已经运行过的一堆程序被认为是一种浪费。对于登录 shell，你可以在如 *.bash_profile* 这样的文件中运行一些复杂的启动命令，仅将别名和其他“轻量级”内容留给 *.bashrc*。

目前，大多数桌面用户通过图形显示管理器登录（你将在下一章了解更多关于这些的信息）。其中大多数以一个非交互式登录 Shell 启动，以保持登录与非登录模型的区分。如果它们没有这样做，你需要在你的 *.bashrc* 中设置整个环境（路径、手册路径等），否则你将无法在终端窗口的 Shell 中看到任何环境变量。然而，如果你希望通过控制台或远程登录，你*还需要*一个 *.bash_profile*，因为那些登录 Shell 根本不会处理 *.bashrc*。

#### 示例 .bashrc

为了同时满足非登录和登录 Shell，如何创建一个 *.bashrc* 也可以作为你的 *.bash_profile* 使用？这里有一个非常基础（但完全足够）的示例：

```
# Command path.
PATH=/usr/local/bin:/usr/bin:/bin:/usr/games
PATH=$HOME/bin:$PATH

# PS1 is the regular prompt. 
# Substitutions include:
# \u username \h hostname \w current directory
# \! history number \s shell name \$ $ if regular user
PS1='\u\$ '

# EDITOR and VISUAL determine the editor that programs such as less
# and mail clients invoke when asked to edit a file.
EDITOR=vi
VISUAL=vi

# PAGER is the default text file viewer for programs such as man.
PAGER=less

# These are some handy options for less.
# A different style is LESS=FRX
# (F=quit at end, R=show raw characters, X=don't use alt screen)
LESS=meiX

# You must export environment variables.
export PATH EDITOR VISUAL PAGER LESS

# By default, give other users read-only access to most new files.
umask 022
```

在这个启动文件中，路径将 `$HOME/bin` 放在最前面，以便那里可执行的文件优先于系统版本。如果你需要使用系统可执行文件，可以添加 `/sbin` 和 `/usr/sbin`。

如前所述，你可以通过符号链接将这个 *.bashrc* 文件与 *.bash_profile* 共享，或者你可以通过创建如下的一行命令，使得它们的关系更加清晰：

```
. $HOME/.bashrc
```

#### 检查登录和交互式 Shell

使用与你的 *.bash_profile* 匹配的 *.bashrc* 时，通常不需要为登录 Shell 运行额外的命令。然而，如果你想为登录和非登录 Shell 定义不同的操作，你可以在 *.bashrc* 中添加以下测试，它会检查 Shell 的 `$-` 变量中是否包含 `i` 字符：

```
case $- in
 *i*) # interactive commands go here
 `command`
 `--snip--`
    ;;
 *)   # non-interactive commands go here
    `command`
    --`snip`--
    ;;
esac
```

### 13.4.2  tcsh Shell

几乎所有 Linux 系统上的标准 `csh` 都是 `tcsh`，这是一种增强版的 C shell，流行的特性包括命令行编辑和多模式的文件名和命令补全。即使你不使用 `tcsh` 作为默认的新用户 Shell（`bash` 应该是默认的），你仍然应该提供 `tcsh` 启动文件，以防用户遇到 `tcsh`。

在 `tcsh` 中，你不必担心登录 Shell 和非登录 Shell 之间的区别。启动时，`tcsh` 会查找一个 *.tcshrc* 文件。如果没有找到，它会查找 `csh` shell 的 *.cshrc* 启动文件。这样做的顺序是因为你可以使用 *.tcshrc* 文件来扩展 `tcsh`，而这些扩展在 `csh` 中不可用。你应该坚持使用传统的 *.cshrc* 文件，而不是 *.tcshrc*；几乎不可能有人会在 `csh` 中使用你的启动文件。如果某个用户在其他系统上遇到 `csh`，你的 *.cshrc* 将可以正常工作。

#### 示例 .cshrc

这是一个示例 *.cshrc* 文件：

```
# Command path.
setenv PATH $HOME/bin:/usr/local/bin:/usr/bin:/bin

# EDITOR and VISUAL determine the editor that programs such as less
# and mail clients invoke when asked to edit a file.
setenv EDITOR vi
setenv VISUAL vi

# PAGER is the default text file viewer for programs such as man.
setenv PAGER less

# These are some handy options for less.
setenv LESS meiX

# By default, give other users read-only access to most new files.
umask 022

# Customize the prompt.
# Substitutions include:
# %n username %m hostname %/ current directory
# %h history number %l current terminal %% %
set prompt="%m%% "
```

## 13.5 默认用户设置

编写启动文件并为新用户选择默认设置的最佳方法是在系统上实验一个新的测试用户。创建测试用户时，使用一个空的家目录，并避免将自己的启动文件复制到测试用户的目录中。重新编写新的启动文件。

当你认为配置已经正常时，尝试以所有可能的方式登录新测试用户（在控制台上、远程登录等）。确保测试尽可能多的功能，包括窗口系统操作和手册页。当你对测试用户满意后，创建第二个测试用户，将第一个测试用户的启动文件复制过去。如果一切正常，你现在拥有了一组可以分发给新用户的启动文件。

本节概述了新用户的合理默认设置。

### 13.5.1  Shell 默认设置

对于 Linux 系统上的新用户，默认的 shell 应该是 `bash`，因为：

+   用户与他们用于编写 shell 脚本的相同 shell 进行交互。（由于种种原因，我在这里不展开讨论，`csh` 是一个臭名昭著的糟糕脚本工具——甚至不要考虑它。）

+   `bash` 是 Linux 发行版的默认 shell。

+   `bash` 使用 GNU readline 库来接收输入，因此它的界面与许多其他工具的界面相同。

+   `bash` 为你提供了精细、易于理解的 I/O 重定向和文件句柄控制。

然而，许多经验丰富的 Unix 专家使用 `csh` 或 `tcsh` 等 shell，仅仅是因为他们最熟悉这种 shell，无法忍受切换。当然，你可以选择任何你喜欢的 shell，但如果没有特别偏好，建议选择 `bash`，并将其设置为新用户的默认 shell。（用户可以通过 `chsh` 命令更改其 shell 以适应个人喜好。）

### 13.5.2  编辑器

在传统系统中，默认编辑器是 `vi` 或 `emacs`。这些编辑器几乎可以保证在几乎所有 Unix 系统上都能找到（或者至少可用），这意味着它们对于新用户来说会在长期内造成最少的麻烦。然而，Linux 发行版通常将 `nano` 配置为默认编辑器，因为它对初学者更友好。

与 shell 启动文件一样，避免使用过大的默认编辑器启动文件。在 *.exrc* 启动文件中加入少量的 `set` `showmatch`（让 `vi` 显示匹配的括号）不会对任何人造成困扰，但避免任何显著改变编辑器行为或外观的设置，如 `showmode` 特性、自动缩进和换行边距等。

### 13.5.3  分页程序

分页程序是一个程序，比如 `less`，它一次显示一页文本。将默认的 `PAGER` 环境变量设置为 `less` 是完全合理的。

## 13.6 启动文件的陷阱

避免在启动文件中出现以下陷阱：

+   不要在 shell 启动文件中放入任何图形化命令。并不是所有的 shell 都在图形环境中运行。

+   不要在 shell 启动文件中设置 `DISPLAY` 环境变量。我们还没有涉及图形环境，但这可能会导致你的图形会话出现问题。

+   不要在 shell 启动文件中设置终端类型。

+   不要在默认的启动文件中省略描述性的注释。

+   不要在启动文件中运行会输出到标准输出的命令。

+   永远不要在 shell 启动文件中设置`LD_LIBRARY_PATH`（参见第 15.1.3 节）。

## 13.7 进一步的启动话题

因为本书仅涉及基础的 Linux 系统，我们不会讨论窗口环境的启动文件。这确实是一个大问题，因为现代 Linux 系统的显示管理器有自己的一套启动文件，比如*.xsession*、*.xinitrc*，以及与 GNOME 和 KDE 相关的无尽组合。

窗口环境的选择可能让人感到困惑，并且在 Linux 中没有统一的方式来启动窗口环境。下一章将描述一些可能的选择。然而，当你了解了系统的工作方式后，你可能会对与图形环境相关的文件过于着迷。没问题，但不要将其强加给新用户。在 shell 启动文件中保持简单的原则同样适用于 GUI 启动文件。实际上，你可能根本不需要更改你的 GUI 启动文件。
