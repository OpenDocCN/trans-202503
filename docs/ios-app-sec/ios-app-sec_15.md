## **12**

**注入攻击**

在本章中，我将讨论各种注入攻击，其中许多攻击同时适用于 iOS 客户端应用程序及其远程端点或 API。虽然对所有潜在的服务器端缺陷进行彻底检查超出了本书的范围，但本章将为你提供一个思路，了解 iOS 应用程序及其配套的端点或 Web 应用程序如何协作来防止安全漏洞。

注入攻击是 Web 应用程序的常见问题，但客户端注入攻击则较为罕见，开发人员和安全工程师往往未予以注意。客户端注入攻击发生在远程提供的数据被设备上运行的程序解析时。最著名的例子包括跨站脚本攻击、SQL 注入、谓词注入和 XML 注入。

### **客户端跨站脚本攻击**

*跨站脚本攻击（XSS）* 是一种通常出现在 web 应用程序中的问题，但 JavaScript 也可以被注入到 iOS 应用程序使用的内容中。一款著名的存在 XSS 漏洞的应用是 Skype 移动应用程序。正如安全研究员 Phil Purviance 在他的 Superevr 博客中所描述的，当时该应用使用了 `UIWebView` 来渲染内容。^(1) 在显示远程用户的全名时没有进行消毒，这使得攻击者能够通过将恶意脚本嵌入到用户名中，进而将脚本注入到远程用户的应用程序中。在这种情况下，攻击者可以窃取设备上的敏感数据（如通讯录内容）。这种攻击还可以用来插入一个虚假的登录页面，将凭据提交给攻击者控制的域名。

如果你的应用使用了 `UIWebView`，为了避免 XSS 漏洞，特别需要注意不要从服务器或其他外部源获取未经消毒的用户提供的数据，并将其集成到用户界面中。你可以通过两部分的方法来最有效地做到这一点，既使用 *输入消毒*，又使用 *输出编码*。

#### ***输入消毒***

输入消毒涉及从外部输入中去除潜在的有害字符，可以采用 *黑名单* 或 *白名单* 方法。

##### **黑名单恶意输入**

在黑名单中，你会尝试列出所有可能导致安全问题的字符，并将这个列表交给你的应用程序。然后，你编写应用程序，要么删除不接受的字符，要么当这些字符出现时抛出错误。

黑名单是一种脆弱的方法，且很少有效。你需要知道每一种可能导致问题的数据形式，包括每种字符编码、每个 JavaScript 事件处理程序或 SQL 特殊字符等等。例如，你可能仅仅将 `<` 和 `>` 添加到黑名单中，指望通过 `<script>` 标签来防止 XSS 攻击，但你忽略了可以仅通过双引号、括号和等号等字符来完成的攻击。

一般来说，如果您的应用程序或您正在测试的应用程序依赖于黑名单字符，请调查该黑名单是否掩盖了潜在的缺陷。这类过滤器很容易被绕过，而依赖这种技术的应用程序可能也缺乏有效的输出编码，这点我将在 “输出编码” 中于第 201 页讨论。

##### **允许输入的白名单**

在白名单方法中，您需要明确地定义哪些字符对特定用户输入是可接受的。白名单优于黑名单，因为全面指定应该允许哪些字符比推测哪些字符可能是坏的要容易得多。在白名单方法中，您可能会定义电话号码字段应允许的字符：0 到 9，以及可能的破折号和括号。这不仅能排除几乎所有恶意输入，还能保持数据库中的数据清洁。

##### **找到平衡**

在黑名单或白名单的输入清理中，可能会出现过度热衷的情况。一些程序和网站实际上不允许某些输入中的合法字符（最显著的是用户密码）。您可能遇到过拒绝接受包含特殊字符的密码的应用程序或网站（例如`!`、`<`、`>`、`'` 或 `;`）。这通常是程序员在后端处理数据时表现出极端不胜任的迹象。

例如，如果一个应用程序去除撇号或分号，开发者可能没有使用参数化的 SQL 语句，而是依赖于去除“坏”的特殊字符来防止 SQL 注入。但这种针对可疑坏字符的黑名单仅仅是降低了用户密码的复杂性，并且不太可能以任何全面的方式解决 SQL 注入问题。

为了确保输入清理正确工作，它还需要尽可能接近数据处理或存储之前的那一刻。例如，当一个 iOS 应用程序与远程 API 通信时，应用程序当然可以尝试去除有害字符或将输入限制在某个字符范围内。这是可以的，但它*仅仅*会提高用户的可用性。用户可以立即看到他们的输入不会被接受，而不需要等到填写完所有表单数据并尝试提交时才发现问题。

您的典型用户可能会欣赏这种副作用，但这里有一个问题：用户控制设备，并最终控制程序的行为。如果您的用户界面不允许某些值作为输入，攻击者所需要做的就是通过代理路由设备的流量，正如我在 “网络和代理设置” 中于第 43 页描述的那样。用户可以在数据离开应用程序但尚未到达服务器时修改数据，并将有害字符重新添加回去。

为了应对这种可能性，永远不要信任移动应用提供正确的数据。在客户端-服务器应用程序中，始终确保消毒工作在服务器端完成。

在输入消毒得当的情况下，你应该继续进行输出编码。

#### ***输出编码***

输出编码，有时也称为 HTML 实体编码，是将用户输入中的字符替换为其 HTML 表示的过程。对于任何可能未被信任的数据，这个过程是必要的，这些数据可能最终会在 WebView 中呈现。例如，字符 `<` 和 `>` 会分别转换为 `&lt;` 和 `&gt;`。当数据显示给用户时，这些字符应该在 UI 中显示为 `<` 和 `>`，但由于它们已被编码，HTML 引擎不会将它们处理为元字符，后者可能在 `<script>` 标签中使用。

输出编码是交付包含第三方输入的 HTML 给客户端之前的最后一道且最强有力的防线。即使你在输入消毒过程中完全忽略了潜在的有害元字符，只要你对输出进行编码，就不必担心你发送的数据是否会被浏览器执行，而只是显示出来。

##### **显示不可信的数据**

与输入消毒一样，输出编码通常应该在服务器端执行，而不是在客户端。但如果你必须展示来自你无法控制的域的数据，并且这些数据不可信，那么你需要在显示内容给用户之前进行 HTML 实体编码。

Google Toolbox for Mac 包含两个 `NSString` 类的类别方法，你可以用来在客户端编码 HTML 实体：`gtm_string-ByEscapingForHTML` 和 `gtm_stringByEscapingForAsciiHTML`。^(2) 在你的项目中包括 Google 的 `NSString` 类别，使得你可以简单地调用任何 `NSString` 对象的方法，返回一个编码后的表示：

```
NSString *escaped;
escaped = [@"Meet & greet" gtm_stringByEscapingForHTML];
```

在进行转义之后，`escaped` 应该包含 `NSString Meet &amp; greet`，它应该可以安全地在 HTML 中渲染。

##### **不要过度编码**

与输入消毒一样，输出编码也需要小心，避免过度处理。一些应用程序在将接收到的字符发送到服务器或存储到数据库之前，会先进行实体编码，然后又重新编码已经编码的数据。你可能在移动应用程序或 Web 应用程序中看到过这种情况。

例如，我曾经看到一个应用程序显示一个横幅，邀请我参加“Meet &amp; greet”。在底层的 HTML 源代码中，这些数据将如下所示：

```
Meet &amp;amp; greet
```

原始输入已经被编码（为 `&amp;`），在浏览器中会正确显示为 `&`。如果再次进行编码，它就会显示为 `&amp;`。这样并不会引发安全问题，但可能导致数据变得混乱，难以处理。只需记住，这项技术被称为 *输出编码*，原因在于它需要在输出之前进行。

### **SQL 注入**

客户端 SQL 注入是由于解析外部提供的数据，将有效的 SQL 注入到格式错误的 SQL 语句中。动态构建的语句，如果使用了未经清理的外部输入，就容易受到 SQL 注入攻击。恶意输入会包含 SQL 元字符和语句，破坏原始查询的意图。

例如，假设一个用户将简单的状态信息发布到网站上。然后该信息被下载并添加到本地数据存储中。如果发布原始内容的用户具有基本的安全知识和恶意意图，用户可能会将 SQL 嵌入到信息中，当 SQL 引擎解析时就会执行这些恶意 SQL。此类恶意 SQL 可能会破坏或修改数据存储中的现有数据。

在 iOS 上，最常用的 SQL API 是 SQLite。清单 12-1 显示了一个格式错误的、动态构建的 SQLite SQL 语句示例。

```
NSString *uid = [myHTTPConnection getUID];
NSString *statement = [NSString StringWithFormat:@"SELECT username FROM users where
     uid = '%@'",uid];
const char *sql = [statement UTF8String];
```

*清单 12-1：一个易受 SQL 注入攻击的未参数化 SQL 语句*

这里的问题是 `uid` 的值来自用户提供的输入，并且直接插入到 SQL 语句中，采用了格式化字符串的方式。任何用户提供的 SQL 都会在最终执行时成为该语句的一部分。

为了防止 SQL 注入，只需使用参数化语句来避免首先动态构建 SQL 语句。与其动态构建语句并将其传递给 SQL 解析器，不如使用参数化语句，这样 SQL 语句就会独立于参数进行评估和编译。在执行时，参数会被传递给已编译的语句。

使用参数化语句，正确的查询构造方式是将 `?` 作为占位符，用于表示提供的参数，如 清单 12-2 所示，而不是像 清单 12-1 那样动态构建 SQL。

```
   static sqlite3_stmt *selectUid = nil;
➊ const char *sql = "SELECT username FROM users where uid = ?";
➋ sqlite3_prepare_v2(db, sql, -1, &selectUid, NULL);
➌ sqlite3_bind_int(selectUid, 1, uid);
   int status = sqlite3_step(selectUid);
```

*清单 12-2：一个正确参数化的 SQL 语句*

SQL 语句在 ➊ 处使用 `?` 占位符构建。然后，代码使用 `sqlite3_prepare_v2` 在 ➋ 处编译 SQL 语句，最后通过 `sqlite3_bind_int` 在 ➌ 处绑定用户提供的 `uid`。由于 SQL 语句已经构建完成，`uid` 参数中提供的任何额外 SQL 都不会被添加到 SQL 中，它仅通过值传递。

除了防止 SQL 注入，使用参数化的预处理语句在大多数情况下还会提高应用程序的性能。即使某个语句没有接受来自不信任源的输入，您也应当为所有 SQL 语句使用它们。

### **谓词注入**

*谓词* 让你使用类似 SQL 的基本查询语言，在数据之间执行逻辑比较。在基本的 `NSPredicate` 中，值是通过格式化字符串进行比较或过滤的。

```
➊ NSMutableArray *fruit = [NSMutableArray arrayWithObjects:@"Grape", @"Peach",
        @"orange", @"grapefruit", nil];
➋ NSPredicate *pred = [NSPredicate predicateWithFormat:@"SELF CONTAINS[c] 'Grape'"];
➌ NSArray *grapethings = [fruit filteredArrayUsingPredicate:pred];
   NSLog(@"%@", grapethings);
```

在➊，创建了一个包含各种水果类型的数组；这个数组将作为数据源，用来与表达式进行比较。在➋创建谓词时，生成了一个查询，检查字符串`"Grape"`是否包含在谓词正在比较的项中。（`[c]`使得这个比较不区分大小写。）当在➌实例化一个新数组以包含这个比较的结果时，`fruit`数组的`filteredArrayUsingPredicate`方法被用来传入谓词。结果，`grapethings`数组现在应该包含`"Grape"`和`"grapefruit"`。

到目前为止，一切顺利！但是在使用外部提供的数据构建谓词查询时，可能会出现一些问题。首先，考虑使用 SQL 的`LIKE`操作符构建谓词的情况，如下所示。

```
NSPredicate *pred;
pred = [NSPredicate predicateWithFormat:@"pin LIKE %@", [self.pin text]];
```

这个示例评估一个 PIN 码，可能是我应用程序的二级身份验证方式。但`LIKE`操作符执行了这个评估，这意味着用户输入简单的通配符字符（[*]）会导致谓词评估为真，从而有效地绕过了 PIN 保护。

对于熟悉 SQL 注入的人来说，这个结果可能是显而易见的（因为 SQL 也有`LIKE`操作符），但请考虑更微妙的情况，比如你正在检查使用谓词`MATCHES`操作符的代码，如下所示：

```
NSPredicate *pred;
pred = [NSPredicate predicateWithFormat:@"pin MATCHES %@", [self.pin text]];
```

这段代码与`LIKE`示例存在相同的问题，但与仅接受通配符不同，`MATCHES`期望一个正则表达式。因此，使用`.*`作为你的 PIN 码就足以绕过验证。

为了防止谓词注入攻击，检查你代码中所有`NSPredicate`的使用，确保所用的操作符对应用程序而言是合理的。还应该限制用户提供的数据中可以传递给谓词的字符，以确保像通配符这样的字符不会被插入。或者，干脆不要在安全敏感操作中使用谓词。

### **XML 注入**

XML 注入发生在恶意 XML 被 XML 解析器实例解析时。通常，这种类型的攻击被用来迫使应用程序通过网络加载外部资源或消耗系统资源。在 iOS 环境中，最常用的 XML 解析器是 Foundation 的`NSXMLParser`类。

#### ***通过 XML 外部实体注入***

XML 解析器的一个基本功能是处理 XML 实体。你可以把这些当作快捷方式或委婉说法。例如，假设你有这样一个简单的字符串：

```
<!ENTITY myEntity "This is some text that I don't want to have to spell out
     repeatedly">
```

然后，你可以在 XML 文档的其他部分引用这个实体，解析器会在该占位符处插入实体的内容。要引用你定义的实体，只需使用以下语法：

```
<explanation>&myEntity;</explanation>
```

`NSXMLParser`实例有多个可配置的参数，这些参数可以在实例化后进行设置。如果`shouldResolveExternalEntities`在`NSXMLParser`实例上设置为`YES`，则解析器将遵循*文档类型定义（DTD）*，该定义可以从外部 URL 获取实体。（这就是这些被称为*外部*实体的原因。）当解析的 XML 中遇到已定义的实体时，URL 将被请求，并且查询结果将用于填充 XML，如下例所示：

```
NSURL *testURL = [NSURL URLWithString:@"http://api.nostarch.com"];
NSXMLParser *testParser = [[NSXMLParser alloc] initWithContentsOfURL:testURL];
[testParser setShouldResolveExternalEntities:YES];
```

在这里，实例化了一个 XML 解析器，它从传递给`initWithContentsOfURL`参数的`NSURL`读取数据。但如果远程服务器决定返回大量数据，或只是简单地挂起，客户端应用程序可能会崩溃或响应挂起。

然而，请记住，外部实体也可以引用本地文件，这意味着文件的内容可能会被包含在解析的 XML 中。如果该 XML 被存储并在以后发送到服务器或其他第三方，则该文件的内容将与其余的 XML 一起披露。为了避免这种情况，确保任何传递给 XML 解析器的 URL 或文件名都经过彻底清理，理想的做法是使用白名单方法，就像我在"允许输入的白名单"中讨论的跨站脚本一样，详见第 12 页。

请注意，在 iOS 7.0 和 7.1 中，XML 解析器的默认行为是解析外部实体（与解析器的预期行为相反），并且使用`setShouldResolveExternalEntities:NO`实际上不起作用。^(3) 不幸的是，除了使用替代的 XML 解析器外，没有办法修复 iOS 旧版本中的 XML 解析器安全问题。该问题在 iOS 8 中已得到解决。

**注意**

*与某些人所声称的相反，* `*NSXMLParser*` *并不* *易受递归实体攻击的影响，递归实体攻击是一种拒绝服务攻击，通常被称为*十亿笑声*攻击。易受攻击的解析器会解析递归实体（引用其他实体的实体），并消耗大量系统资源。然而，如果递归实体声明传递给* `*NSXMLParser*`*，会抛出一个* `*NSXMLParserEntityRefLoopError*`* 错误。

然而，滥用官方外部实体并不是 iOS 代码中 XML 注入的唯一需要注意的因素。一些应用程序会集成第三方 XML 库，这些库带来了自己的一系列问题。

#### ***关于替代 XML 库的问题***

你可能会在各种 iOS 项目中遇到替代的 XML 库，这些库通常因其比 `NSXMLParser` 更好的性能特性以及对 XPath 等功能的支持而被选用。（Ray Wenderlich 在他的博客上提供了一篇关于选择 XML 解析器的好教程。^(4)) 在查看使用替代 XML 库的代码时，首先确保通过该库的标准方法禁用外部实体扩展。然后，确认任何集成外部输入的 XPath 查询首先对输入进行清理，就像防止跨站脚本攻击时一样。XPath 查询还应该以类似 SQL 查询的方式进行参数化（见 第 203 页的“SQL 注入”部分），但具体方法可能会根据涉及的第三方库有所不同。

### **结束思考**

最终，本章大多数攻击的处理方法都归结为将所有外部输入视为敌对：去除潜在的恶意内容，并尽可能地对其进行编码或处理，以防止代码执行。明确允许的每个参数的内容是个好主意，尤其是从 UI 或远程用户操作的来源获取的内容，并在程序中强制执行这一点。

现在，我将不再讨论防范恶意数据攻击，而是转向使用适当的加密技术保护良好数据。
