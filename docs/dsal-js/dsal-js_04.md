<hgroup>

## 3 抽象数据类型

</hgroup>

![](img/opener.jpg)

*抽象数据类型（ADT）*由它支持的*操作*和提供的*行为*来定义。在本书中，我们将研究数据结构，前提是它们能够实现特定的 ADT；从实际角度来看，你可以说 ADT 通常指定了需求和要求。本书不会单纯研究数据结构；我们总是将它们置于 ADT 的上下文中，考虑数据结构（和相关算法）需要支持的操作。在这一章中，你将学习更多关于 ADT 的知识，以及如何在 JavaScript 中实现它们。

一个 ADT 可以通过多种方式实现，可能有不同的性能（这是我们将在下一章讨论的话题），使用不同的数据结构和算法。例如，你可以用数组、列表或树来实现集合，但在不同情况下，性能可能不同。一个实际的实现（意味着某个数据结构和与之配套的算法）可能被称为*具体数据类型（CDT）*，但在这里你不会看到这个术语。

数据类型的实现不是抽象的；它是一个具体的方面，影响着开发者。数据类型的定义不需要编码，但其实现肯定需要编码。首先，让我们回顾一些关于数据类型、抽象和操作的基本概念，然后再详细定义抽象数据类型（ADT）。

### 理论

什么是数据类型，我们如何使用它们？它们可以抽象地定义吗，还是我们必须始终依赖实际的实现？我们能对数据类型做些什么，它们提供了哪些操作，它们有何影响？在开始学习 ADT 之前，让我们更仔细地看看激发本章重点的基本软件概念。

#### 数据类型

编程语言最初只包括少数几种内建数据类型，例如字符、字符串、布尔值和数字（整数或浮点数），开发者无法添加新的数据类型；给定的选项就是他们能使用的所有内容。随着像*类*这样的概念加入编程语言，开发者可以添加新的、更复杂的数据类型。一个数据类型（无论是语言提供的还是你自己创建的）由它可能表示的值集合以及可以对其执行的操作来定义；例如，可以将两个字符串连接起来，执行布尔值的逻辑运算，进行整数的算术运算，或者比较浮点数。

在使用数据类型时，通常不需要关心其内部表示的细节——只需要关心你能做什么以及如何利用它来获得结果。输入和输出才是最重要的。ADT 的基本理念是指定可以执行的操作，忽略内部方面。（如果语言提供位操作或某些低级特性，可能需要了解内部表示的细节，但对于大多数编程任务来说，你不需要这样做。）

现代语言，包括 JavaScript，允许用户定义自己的数据类型。一开始，开发者只能使用简单的记录类型（比如用三个数字字段表示日期：日、月、年），但现在你可以进一步使用类来隐藏实现细节，这样用户只需要关心如何使用新定义的数据类型，而不需要关注其他内容。

> 注意

*ADT 也可以代表代数数据类型，这是一个不同的概念，表示通过组合其他类型形成的类型。*

#### 抽象

我们已经在谈论抽象的概念，现在让我们更具体地思考这个术语的含义。基本上，*抽象*意味着隐藏或省略细节，转而寻求一个更高层次的总体概念。当我们谈论抽象时，我们有意识地忽略实现方面的内容，至少在此时，我们专注于我们的需求，无论我们以后如何通过代码解决它们。例如，你需要存储和检索字符串吗？字典抽象数据类型（ADT）就是你的解决方案；你稍后会看到如何实现它，但无论你怎么做，这就是你需要的数据类型。

软件工程有三个相似且相关的概念：

**封装** 将模块设计为好像它们周围有一个“外壳”或“胶囊”，只有该模块负责处理其数据。其理念是将数据和处理这些数据的方法包装在一起，放在同一个地方，以实现更为一致和紧密的设计。

**数据隐藏** 将模块实现的内部细节隐藏起来，确保它们的更改不会影响系统的其他部分。这种机制确保外部无法访问内部细节。换句话说，封装将一切聚合在一起，而数据隐藏确保没人能从“外部”干扰内部内容。

**模块化** 将系统划分为可以独立设计和开发的单独模块。正确使用模块可以提供封装和数据隐藏。

ADT 只定义它能执行哪些操作；它不会详细说明这些操作如何实现。换句话说，通过 ADT，你描述的是“抽象”的操作，而不是具体的实现细节。让我们来考虑一些可以对 ADT 执行的不同类型的操作。

#### 操作与变更

一种常见的数据类型分类方法是通过 *可变* 和 *不可变* 值来区分。例如，在 JavaScript 中，对象和数组是可变的。创建对象或数组后，你可以修改其值，而无需创建新的对象或数组。另一方面，数字和字符串是不可变的；如果对这些数据类型应用操作，将会生成一个新的、不同的、独立的值。

当设计一个新的日期类型（例如，一个包含三个独立整数值的对象，如本章早些时候提到的日期示例）时，你可以选择提供设置日期、月份或年份的操作，这样日期对象就是可变的。另一方面，如果这些操作返回一个新的日期对象，而不是修改现有对象，则日期对象是不可变的。

> 注意

*React Redux 开发者深知不可变性及其要求。如果你想修改使用 Redux 的 React 应用程序的状态，不能直接修改它；你必须生成一个包含所需更改的新状态。Redux 假设你以不可变的方式管理状态数据。（我们将在第十八章进一步讨论不可变性。）*

以下列表展示了适用于 ADT 的操作类别：

**创建者** 函数生成一个给定类型的新对象，可能需要一些值作为参数。以日期 ADT 示例为例，一个创建者可以根据日期、月份和年份值生成一个新的日期。

**观察者** 函数接收给定类型的对象并生成不同类型的值。例如，对于日期抽象数据类型（ADT），getMonth() 操作可能返回月份的整数，或者 isSunday() 谓词可以判断给定日期是否是周日。

**生产者** 函数接收一个给定类型的对象，可能还会接受一些额外的参数，并生成一个新的给定类型的对象。对于日期 ADT，你可以有一个函数将一个整数天数加到日期上，生成一个新的日期。

**修改器** 函数直接修改给定类型的对象。例如，setMonth() 方法可以修改一个对象（更改其月份），而不是生成一个新的对象。

对于不可变数据类型，仅适用前三种操作；而对于可变数据类型，还适用修改操作。

### 实现一个 ADT

考虑一个情况，你想实现一个 *集合* 或 *多重集合*，它是类似集合的容器，但允许重复元素。（集合定义上不能包含重复元素。）我们还将增加一个额外的操作（“greatest”），让它更有趣。表 3-1 提供了本书中如何描述 ADT 的示例。

表 3-1：集合的操作

| 操作 | 签名 | 描述 |
| --- | --- | --- |
| 创建 | → bag | 创建一个新的集合。 |
| 空吗？ | bag → boolean | 给定一个集合，确定它是否为空。 |
| 添加 | bag × value → bag | 给定一个新值，将其添加到集合中。 |
| 移除 | bag × value → bag | 给定一个值，将其从袋子中移除。 |
| 查找 | bag × value → boolean | 给定一个值，检查它是否存在于袋子中。 |
| 最大值 | bag → value &#124; undefined | 给定一个袋子，找到其中的最大值。 |

现在暂时忽略中间一列，专注于另外两列。操作列列出了每个提供的操作，而描述列则提供了该操作预期实现的简单解释。你需要能够创建一个新的（空的）袋子，并测试该袋子是否为空。你还需要能够向袋子中添加新值，并从中移除先前添加的值，这两个操作都会改变袋子的内容。最后，你希望能够找到袋子中是否包含给定的值，并且确定袋子中的最大值。

你也可以有一列指定操作的类型——创建者、观察者、生产者等等——但通常这是通过操作的描述来理解的，而不会明确地包括在内。

操作的签名是什么？这是表 3-1 中间一列的内容。除非使用 TypeScript 或 Flow（如第一章中提到的），否则 JavaScript 不允许开发者为函数和变量指定类型，但添加这些信息（即使只是以注释或类似这种表格的形式）有助于用户更好地理解函数的期望和返回结果。

指定一个函数的参数和返回结果被称为*签名*，它基于一种叫做*Hindley-Milner*的*类型系统*。你从函数参数的类型开始，按顺序排列，用×分隔，接着是一个箭头，然后是函数返回结果的类型。

让我们考虑一些示例。表 3-1 显示，create()函数不接受任何参数，返回一个 bag 类型的结果。同样，add()接受两个参数，一个是袋子，一个是值，它返回一个袋子作为结果。最后，greatest()函数接受一个袋子参数，并返回一个值或 undefined。

完整的 Hindley-Milner 系统包含更多的细节，比如类型约束、泛型类型、未确定数量的参数、类方法等等，但对于我们的需求，表 3-1 中展示的定义已经足够。

#### 使用类实现 ADT

让我们用一个类来开始实现袋子 ADT。对象将有两个属性：count，它计算袋子中有多少个元素，和 data，它是一个对象，每个元素都有一个键，并且该键的值表示它在袋子中出现的次数。请记住，我们并不寻找一种特别高效的方式来实现袋子（我们将在第十一章中讨论这个问题）。现在，我们只是看一个使用类的示例。

例如，如果你将字符串 HOME、SWEET 和 HOME 添加到袋子中，该对象将如下所示：

```
{
  count: 3,
  data: {
    **HOME**: 2,
    **SWEET**: 1,
  },
};
```

计数属性的值为 3，表示有三个字符串已添加到包中。数据部分包括一个 HOME 属性，其值为 2（因为 HOME 被添加了两次），以及一个 SWEET 属性，其值为 1。

清单 3-1 显示了完整的 Bag 类。

```
class Bag {
❶ count = 0;
  data = {};

❷ isEmpty() {
    return this.count === 0;
  }

❸ find(value) {
    return value in this.data;
  }

❹ greatest() {
    return this.isEmpty() ? undefined : Object.keys(this.data).sort().pop();
  }

  add(value) {
  ❺ this.count++;
  ❻ if (this.find(value)) {
      this.data[value]++;
    } else {
      this.data[value] = 1;
    }
  }

  remove(value) {
  ❼ if (this.find(value)) {
    ❽ this.count--;
    ❾ if (this.data[value] > 1) {
        this.data[value]--;
      } else {
        delete this.data[value];
      }
    }
  }
}
```

清单 3-1：包 ADT 的一种可能实现

新对象以零计数和空的数据集初始化 ❶。你可以通过检查计数是否为零来判断该对象是否为空 ❷。要查看包中是否包含给定的键 ❸，可以使用 in 操作符检查它是否出现在数据对象中。由于 JavaScript 的功能，找到最大键 ❹ 也并不困难。你首先获取一个包含所有键的数组（所有添加到包中的值），然后对其进行排序，最后使用 pop() 获取数组的最后一个元素，这将是包中最大的键。

要向包中添加一个键，首先将计数加 1 ❺，然后检查该键是否已经在包中 ❻；如果在，递增其计数；如果不在，则以计数 1 将其添加进去。

要从包中移除一个键，首先验证该键是否确实在包中 ❼。如果不在，就不做任何操作。如果找到该键，递减其计数 ❽，然后检查该键在包中出现的次数 ❾。如果其计数大于 1，则将其减 1。如果计数恰好为 1，则从数据对象中移除该键。

如何使用这个对象？以歌曲《Home, Sweet Home》中的几个词为例（原版歌曲来自 1823 年，而非 Mötley Crüe 演唱的新版），你可以做类似于清单 3-2 中展示的代码，将部分歌词添加到包中。

```
const b = new Bag();
❶ console.log(b.isEmpty());   // true

❷ b.add("HOME");
b.add("HOME");
b.add("SWEET");
b.add("SWEET");
b.add("HOME");

b.add("THERE'S");
b.add("NO");
b.add("PLACE");
b.add("LIKE");
b.add("HOME");

❸ console.log(b.isEmpty());   // false

❹ console.log(b.find("YES")); // false
console.log(b.find("NO"));  // true

❺ console.log(b.greatest());  // THERE'S
❻ b.remove("THERE'S");
console.log(b.greatest());  // SWEET
```

清单 3-2：包实现的测试

新创建的包是空的 ❶，正如预期的那样。你可以向其中添加几个键 ❷，显然包就不再为空了 ❸。（关于更简洁的方式来链式调用类似操作，请参见问题 3.1。）查找操作 ❹ 如预期般工作；"YES" 不在包中，但 "NO" 在。最后，包中最大的键是 "THERE'S" ❺，但在移除它 ❻ 后，"SWEET" 成为了新的最大值。

#### 使用函数实现 ADT（可变版本）

现在你已经创建了 ADT 的具体实现，如果你使用函数而不是类，情况会如何变化？清单 3-3 使用了相同的表示法，基于一个具有计数和数据属性的对象。不同之处主要是语法上的，比如将包对象作为参数传递给函数，而不是在方法中通过 this 引用它。

```
 const newBag = () => ({count: 0, data: {}});

  const isEmpty = (bag) => bag.count === 0;

  const find = (bag, value) => value in bag.data;

  const greatest = (bag) =>
  isEmpty(bag)
    ? undefined
    : Object.keys(bag.data).sort().pop();

  const add = (bag, value) => {
  bag.count++;
  if (find(bag, value)) {
    bag.data[value]++;
  } else {
    bag.data[value] = 1;
  }
  return bag;
};

  const remove = (bag, value) => {
  if (find(bag, value)) {
    bag.count--;
    if (bag.data[value] > 1) {
      bag.data[value]--;
    } else {
      delete bag.data[value];
    }
  }
  return bag;
};
```

清单 3-3：包 ADT 的一种替代（可变）实现

清单 3-3 中的代码与清单 3-1 中的使用类的代码类似。newBag()函数返回一个具有 count 和 data 字段的对象，就像 Bag 类中的构造函数一样。对于其他五个函数（isEmpty, find, greatest, add 和 remove），与基于类的代码相比，有两个不同之处：你使用 bag 参数来访问对象，而不是使用 this，并且你在 add()和 remove()变异方法的末尾显式返回 bag。然而，在这种情况下，你其实不需要这样做，因为你实际上是在修改通过引用传递给函数的 bag 参数。（这是 JavaScript 传递对象作为参数的标准方式。）但是，如果你以不使用对象的其他方式实现这个 ADT，那么返回新的具体数据类型将是强制性的。由于你不想让外部依赖于实现的内部细节，最简单（也是最安全）的方法是始终返回新的更新对象，无论它的类型如何。

使用这种 ADT 实现的代码，如清单 3-4 所示，与清单 3-2 中的基于类的版本非常相似。

```
❶ let b = newBag();
❷ console.log(isEmpty(b));     // true

❸ b = add(b, "HOME");
b = add(b, "HOME");
b = add(b, "SWEET");
b = add(b, "SWEET");
b = add(b, "HOME");

b = add(b, "THERE'S");
b = add(b, "NO");
b = add(b, "PLACE");
b = add(b, "LIKE");
b = add(b, "HOME");

console.log(isEmpty(b));     // false

❹ console.log(greatest(b));    // THERE'S
❺ console.log(find(b, "YES")); // false
console.log(find(b, "NO"));  // true

❻ b = remove(b, "THERE'S");
console.log(greatest(b));    // SWEET
```

清单 3-4：可变实现的袋子测试

简单的区别在于对象创建❶，测试袋子是否为空❷，添加❸和移除❻元素，获取最大值❹，以及检查某个值是否在袋子中❺。你不再写 b.something(...)，而是写 something(b, . . .)。

#### 使用函数实现 ADT（不可变版本）

最后，让我们考虑一下我们 ADT 的不可变实现。（在第十八章中，我们将更详细地了解不可变数据结构，并介绍更多的案例。）这里没有特别的理由要求不可变性，除了希望以更函数式的方式工作，避免副作用，正如在第二章中所描述的那样。

在这种情况下，由于你希望开发一个不可变的袋子，你可能不能直接修改袋子对象，因此你需要改变变异方法的实现；其余部分保持不变。解决方案只是要求在袋子需要更改时创建并返回一个新对象。要添加一个新值，可以使用以下代码：

```
const add = (bag, value) => {
❶ bag = {count: bag.count - 1, data: {...bag.data}};
  if (find(bag, value)) {
    bag.data[value]++;
  } else {
 bag.data[value] = 1;
  }
  return bag;
};
```

由于向袋子中添加新值永远不会失败，你总是需要生成一个新对象，所以你实际上会执行❶。

要从袋子中移除一个值，首先要检查要移除的值是否在其中，然后再进行移除：

```
const remove = (bag, value) => {
❶ if (find(bag, value)) {
  ❷ bag = {count: bag.count - 1, data: {...bag.data}};
    if (bag.data[value] > 1) {
      bag.data[value]--;
    } else {
      delete bag.data[value];
    }
  }
  return bag;
};
```

和之前一样，首先检查该值是否在袋子中❶；如果它存在❷，则创建一个新对象，并返回它。

在这种情况下，代码修改很少，但对于更复杂的数据结构（如本书后续将介绍的内容），创建现有结构的副本可能就不那么容易或快速，你需要做额外的处理或结构化。

### 总结

在这一章中，我们介绍了抽象数据类型（ADT）的概念，你将在本书的其余部分看到它，特别是在分析竞争的数据结构和算法的优缺点时。定义一个 ADT 是决定应该使用什么结构以及如何实现算法的第一步。理解 ADT 的概念将帮助你为代码获取最佳性能。

在下一章，我们将研究一个互补的概念：我们如何比较抽象数据类型（ADT）的具体实现，换句话说，我们如何判断一个算法是否比另一个算法更好或更差？我们还将介绍算法分析和与性能类别相关的概念。

### 问题

**3.1  链式调用**

修改背包方法，以便你可以像下面这样进行链式添加：

```
const b = new Bag();
b.add("HOME").add("HOME");
b.add("SWEET").add("SWEET").add("HOME");
```

你还应该能够将移除操作和其他操作进行链式调用，例如以下操作，它将移除两个值，并测试背包是否变为空：

```
b.remove("NO").remove("HOME").isEmpty();
```

**3.2  数组，而不是对象**

你能否使用数组而不是对象来实现背包 ADT？你可以用有序数组表示背包，从而使 `greatest()` 函数的实现变得非常迅速。当然，`add()` 方法应该负责保持数组的顺序。

**3.3  额外操作**

本章只描述了背包的一些额外操作，但对于某些应用，你可能需要增加或更改操作；你能想到哪些吗？

**3.4  错误操作**

在定义一个 ADT 时，你如何指定错误结果，比如可能抛出异常或返回某种特殊值？

**3.5  准备，集合……**

在本章中，我们讨论了背包，但在后面的章节中，我们将讨论集合，它不允许重复的值。你能提前思考并设计一个合适的 ADT 吗？
