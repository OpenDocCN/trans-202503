

## 2 在 JavaScript 中使用函数式编程



![](img/opener.jpg)

*函数式编程（FP）*是一种基于函数的编程范式，函数是你代码的唯一构建块。使用 FP 可以提高代码的模块化，帮助你编写更易理解、可测试和易于维护的代码，同时避免出现 bug；这是一个全方位的胜利。

有些人声称，FP 是一种开明的编程方法，它让*面向对象编程（OOP）*和其他范式远远落后。也有些人认为，它只是理论上的概念，不适用于“现实世界”，并且带来了比解决的问题更多的麻烦。像大多数领域一样，差异并非非黑即白，而是介于灰色之间。这不仅仅是使用 FP 还是不使用 FP 的问题。在本书中，我们会使用 FP，但不是教条式的，并且在本章中，你将看到 JavaScript 如何让你进行函数式编程，何时使用 FP 以及何时*不*使用它。无论何时 FP 适用并且更为合适，我们会使用它，但如果 OOP 更为适用，我们也会改用 OOP。

> 注

*FP 不是一种现代的时尚。第二古老的编程语言（仅次于 1957 年出现的 FORTRAN）是 LISP（于一年后出现），它完全基于 FP。自那时以来，许多其他 FP 语言相继出现，甚至像 JavaScript 这样的非函数式语言也提供了相同类型的功能。*

### 为什么使用函数式编程？

在编程时，考虑哪些特性对你最重要，然后问自己，FP 是否能够提供这些特性。大多数程序员通常希望自己编写的代码是：

**易懂 **代码只需要编写一次，但会被阅读多次，用户应该能够轻松理解你的函数及其关系，而无需过多的努力。函数式编程通常生成更短、更简洁的代码，这使得理解起来更加容易。

**可维护 **你的代码很可能在未来需要维护，并且应该便于进行修改。使 FP 代码更易理解的特性也使得维护变得更为简便。你还无需担心在修改某个函数时会破坏其他部分。

**可测试 **单元测试是开发工作中的常见部分，它允许你验证代码每个组件的行为。单元测试还作为一种文档，为阅读你代码的人提供如何使用某个函数的示例。如果你的编程风格不支持编写易于测试的代码，你将遇到问题。FP 始终生成可以独立测试的函数。

**模块化** 你应该将代码的功能划分为独立的模块，每个模块涉及程序的一个特定方面，这样如果你在一个模块中做出更改，它就不会影响到其他代码。FP 的目标是编写独立的函数，这些函数可以重构或修改，而不影响其他函数。编写独立的函数有助于实现*关注点分离*（程序的不同部分重叠较少）。此外，模块往往是*高度内聚*的，这意味着它们包含的函数确实是属于一起的，并且它们是*松散耦合*的，因此函数中的更改不太可能需要修改其他函数。

**可重用** 重用代码可以节省时间和金钱。由于在 FP 中函数独立存在，因此你可以在任何地方使用编写良好的函数集合。

当然，面向对象的代码也能做到这些。没有人会说 FP 是解决所有软件开发问题的银弹。我总是建议采取中庸之道；经过深思熟虑、平衡的混合通常是最佳解决方案。

### JavaScript 作为函数式语言

*JavaScript 是函数式的吗？* 当人们讨论函数式语言时，他们通常提到 Haskell、Erlang、Scala 等；通常不会提到 JavaScript。这可能是因为目前没有确切的定义来说明什么构成了函数式语言、函数式语言应该提供哪些特性，或者它应该如何工作。本书中，我们将认为只有当一种语言支持常见的 FP 特性时，它才算是函数式语言；你将看到 JavaScript 如何与之比较。我们将利用诸如将函数视为一等公民、数组函数、纯函数、高阶函数和递归等特性，同时避免副作用（或者说 FP 术语中的*不纯*），避免使用（局部或全局）状态、变更对象或参数等。

#### 函数作为一等公民

在 JavaScript 中，函数是*一等公民*，意味着你可以对它们执行任何你可以对其他对象执行的操作。你可以将函数存储在变量中，将函数作为参数传递，或将一个函数作为结果从其他函数返回。

考虑一个应用程序接口（API）调用的例子。如果你使用像 Axios（或者 SuperAgent，或者其他类似的库，它们简化了对远程服务器的异步调用过程），你可能见过这样的代码：

```
axios.get("your/url/api").then(**(response) => {**
 **// ...do something with the response**
**}**)
```

.then()方法的参数是一个函数，它的传递方式和你传递数字或数组一样。

在第十二章，我们也会这样做，我们还将能够为函数参数赋予默认值，以改变函数的执行方式：

```
const preOrder = (tree, **visit = (x) => console.log(x)**) => {
  if (tree !== null) {
    visit(tree.key);
    preOrder(tree.left, visit);
    preOrder(tree.right, visit);
  }
};
```

preOrder()函数接受两个参数：一棵树（你将在后面学习树）和一个访问函数；如果你没有提供访问函数，默认值将是一个简单的函数，它只会记录你传递给它的内容。

将一个或多个函数作为参数使得该函数成为*高阶函数*；这种函数的另一个特征是返回一个函数作为结果。普通函数（那些不接收或返回函数的）被称为*一阶函数*。

在相同的例子中，你还可以编写如下代码：

```
❶ const myVisit = (x) => {
  // ...do some interesting things with x
}

let myTree = newTree();
// ...set up myTree, add to it, etc.

❷ preOrder(myTree, **myVisit**);
```

该函数存储在变量❶中，因为函数只是另一种可以存放在变量中的值类型，然后变量的内容以与传递 myTree（另一个类型不同的变量）相同的方式传递给函数❷。

在本章中你会看到更多的例子，包括返回函数作为结果的函数。

#### 声明式编程

函数式编程（FP）采用更高层次的*声明式*风格，而不是在过程式“常规”编程中使用的命令式风格。在声明式编程中，你只需要指定你想要什么，而不是逐个详细地列出完成它所需的步骤，这在过程式编码中是必须的。声明式编码的最佳示例是数组操作。操作数组通常涉及循环，你可以“手动”实现（比如使用 while 循环），或者使用更常见的 for 语句，但 JavaScript 让你可以使用一些特定的数组函数进行声明式操作。事实上，我们将在接下来讨论一些*方法*，但概念是一样的；方法归根结底也是函数。

以下列表详细介绍了一些可用的数组函数，帮助你在数组中查找或选择元素：

**.filter() **从数组中挑选出满足某些条件的元素

**.find() 和 .findIndex() **在数组中查找满足某些条件的元素

**.some() **检查数组中是否至少有一个元素满足某个条件

**.every() **测试数组中的所有元素是否满足某个条件

其他函数将数组转换成一个新的数组或单个结果：

**.map() **通过对数组的元素应用给定的函数，将一个数组转换为另一个数组

**.reduce() **对整个数组应用给定的操作，从左到右，将其简化为一个单一结果

**.reduceRight() **与 .reduce() 类似，但从右到左进行操作

这个列表并不是完整的：还有更多转换数组的函数，如 .flat() 或 .flatMap()，但你在这里看不到它们。

> 注意

*有些人说这些函数比对应的手写循环更慢，使用它们会带来一些性能损失。即使这些说法是真的，它们也不重要。除非你遇到了真正的性能问题，并且在分析代码后得出结论认为是数组函数导致的，编写更长、更多错误的代码实际上没有什么意义。*

##### 过滤数组

让我们看一个常见的任务：遍历数组，选择满足某些条件的元素，并丢弃其余元素。 .filter() 方法正是实现了这一点：你提供一个*谓词*（一个根据参数生成布尔结果的函数），然后返回一个新数组，只包含原始数组中满足谓词条件的元素。

例如，要选择所有小于 21 的值，以下谓词将非常有用：

```
const under21 = (value) => value < 21;
```

under21()函数获取一个值，如果该值小于 21，则返回 true。现在你可以像下面这样编写代码：

```
let myArray = [22, 9, 60, 12, 4, 56];
let newArray = **myArray.filter(under21)**;
console.log(newArray); // [9, 12, 4]
```

这指定了你想要应用“小于 21”检查来过滤原始数组，结果是一个新数组，只包含满足给定测试的值。你不需要编写任何代码来控制循环，初始化输出数组或其他任何东西。代码更简洁且真正声明性；它只指定了*你想要什么*，而不是*如何得到它*。

##### 搜索数组

其他方法让你可以搜索数组中某个满足谓词的元素，返回该元素或它在数组中的位置：

**find()** 从头到尾遍历数组，测试给定的谓词；如果数组中的某个元素满足谓词，该元素将被返回；如果没有元素满足谓词，则返回 undefined。最近的新方法 findLast()做了相同的事情，但它是从尾部向头部搜索。

**findIndex()** 类似于 find()，但它返回第一个满足谓词的元素的位置，如果没有元素满足谓词，则返回-1。新方法 findLastIndex()返回最后一个满足谓词的元素位置。

这些方法非常实用，因为它们在一行代码中提供了所有需要的搜索代码。搜索谓词的复杂性没有限制。例如，你不仅限于寻找一个值，还可以测试任何条件，就像你之前使用 under21()一样。

这里有一些同时使用这两种搜索方法的示例，因为它们是相关且相似的：

```
let myArray = [22, 9, 60, 12, 4, 56];
const under21 = (value) => value < 21;
❶ console.log(myArray.find(under21));      **// 9**
❷ console.log(myArray.findIndex(under21)); **// 1**

const equal21 = (value) => value === 21;
❸ console.log(myArray.find(equal21));      **// undefined**
❹ console.log(myArray.findIndex(equal21)); **// -1**
```

满足 under21 谓词的 myArray 的第一个元素是 9 ❶，它位于数组的第 1 个位置 ❷。如果你使用一个 equal21 谓词重新调用，该谓词检查值是否为 21，你将得到 undefined ❸和-1 ❹，因为数组中找不到这样的元素。

> 注意

*如果你正在搜索一个特定的值，* .includes()，.index() 和 * .lastIndexOf() *会非常有用，尽管它们的灵活性不如前面描述的函数式编程（FP）方法，因为它们只是让你搜索一个值，而不能测试任何可能的条件。*

##### 测试数组

与搜索相关的方法有 .some() 和 .every()。第一个检查数组中是否*任何*元素满足某个谓词，第二个检查是否*所有*元素都满足该谓词：

```
let myArray = [22, 9, 60, 12, 4, 56];
const under21 = (value) => value < 21;
console.log(myArray.some(under21));  **// true**
console.log(myArray.every(under21)); **// false**

const equal21 = (value) => value === 21;
console.log(myArray.some(equal21));  **// false**
console.log(myArray.every(equal21)); **// false**
```

如果你测试数组中是否有元素小于 21，答案是“真”，但并非所有元素都为真。如果你重复进行这些等于 21 的测试，两个答案都为假。

如果你已经有了上一节中的方法，你可以省略这些函数（请参见本章末尾的第 2.7 问题）。

##### 转换一个数组

算法通常需要遍历一组元素（如数组），对每个元素应用某些操作，进而创建一个新的集合。例如，在一个 Web 应用程序中，你可能有一个字符串列表，这些字符串可能表示数字，你可能想将这个列表转换为对应的数字值列表。为数组的所有元素设置一个循环，系统地处理每个元素，并生成一个新的数组，是一个常见的过程，通常会在开发者学习初期教授。这种转换在函数式编程（FP）中也非常关键，JavaScript 通过 .map() 函数来实现。

考虑一个简单的例子，它只生成一个新的数组，并将所有值乘以 10：

```
let myArray = [22, 9, 60, 12, 4, 56];
console.log(**myArray.map((x) => 10*x)**);
// [220, 90, 600, 120, 40, 560]
```

从你一直在使用的数组开始。如果你用一个将参数乘以 10 的函数来映射它，你将得到一个新的数组，其值是原数组值的 10 倍。

使用 .map() 而不是常规的循环意味着代码更加清晰，而且映射是函数式编程中的一个著名模式。代码也更简短，这意味着出错的机会更少。最后，代码生成一个新的数组，而不是修改原始数组，因此该函数是 *纯粹的*（你将在本章后面学习这是什么意思）。只要可能，使用 .map()，但要注意它的一些特性可能会让你吃亏；请参考本章末尾的第 2.4 问题获取示例。

##### 将数组简化为单一值

这里是另一个常见任务：编写遍历整个数组的循环，执行某种操作，最后得到一个计算结果。（一个典型的例子是一个包含数字的数组，将它们加起来。）你可以使用 .reduce() 或较少使用的 .reduceRight() 函数以函数式的方式实现这种任务。以下代码对整个数组进行求和：

```
const myArray = [22, 9, 60, 12, 4, 56];
const mySum = myArray.**reduce((a, v) => a + v, 0)**; **// 163**
```

这个逻辑完成了应用一个接收两个值并返回它们和的函数到整个数组的所有操作，从 0 开始。换句话说，它将数组中的所有元素相加。a 参数代表 *累加器*（初始值为 0），v 代表 *值*（数组中的每个元素）。你不需要为 .reduce() 提供初始值，但提供初始值更安全。如果你试图在没有初始值的情况下对一个空数组进行归约操作，你将遇到运行时错误。

为了展示 .reduce() 的强大功能，来看另一个案例，在这个案例中，你需要计算多个结果：计算数组值的平均值。为此，你不仅需要它们的总和（你已经知道如何获取），还需要它们的数量（不要忘记你可以使用 myArray.length 来获取后者；这只是一个例子）：

```
const myArray = [22, 9, 60, 12, 4, 56];
myArray.**reduce((a, v) => ({s: a.s + v, c: a.c + 1}), {s: 0, c: 0})**;
// {s: 163, c: 6}
```

该对象有两个字段（s 代表总和，c 代表计数），并且归约函数在每一步都重新计算这些值；最终结果与前面的示例相符。

如果你需要从右到左处理数组，`.reduceRight()` 的工作方式与 `.reduce()` 相同，但它从数组的末尾开始，返回到第一个元素。当然，你也可以通过先使用 `.reverse()` 然后再使用 `.reduce()` 来反转原始数组，但那会产生副作用。数组会就地被反转（关于此，请参见第 33 页的“变异参数”）。

##### 遍历数组

`.forEach()` 数组函数负责遍历数组，为每个元素调用回调，因此你只需要声明你想要做什么工作，其他的都不需要。你可以使用这个函数重新实现数组求和逻辑：

```
const myArray = [22, 9, 60, 12, 4, 56];
❶ let sum = 0;
❷ myArray.forEach((v) => {
  sum += v;
});
❸ console.log(sum); // 163, as earlier
```

首先将 `sum` 变量设置为 0；该变量将获得数组中所有元素的总和❶。然后遍历数组❷并指定你希望对每个元素 `v` 做的操作。在这种情况下，将其加到 `sum` 中，最终结果❸与之前完全相同。

#### 高阶函数

如前所述，接收其他函数作为参数或返回函数作为结果的函数被称为 *高阶函数*。这意味着所有与回调函数一起工作的函数都是高阶函数，刚才讨论的所有数组方法也是如此。这些函数中的一些允许你以更声明式的方式工作（就像你之前看到的），而另一些则允许你扩展函数并修改它的行为——例如，添加日志记录以帮助调试或使用记忆化以提高性能。

考虑一下高阶函数的用途之一：返回一个新函数，包含一个包装的行为示例。包装产生一个新函数，它保留了原始功能，但添加了一些额外的行为。假设你想为一个函数添加日志记录功能，用于调试目的。你当然可以修改这个函数，但这样做是有风险的，因为你可能会不小心修改不该触碰的部分。你也可以使用调试器，但包装函数提供了更多的灵活性。

原始函数可能是这样的：

```
const myFunction = (arg1, arg2) => {
  // Do something with arg1 and arg2
  // and eventually return something.
}
```

然后你可以修改它来添加日志记录：

```
const myFunction = (arg1, arg2) => {
 **console.log("Entering myFunction with ", arg1, arg2);**
  // Do something with arg1 and arg2
  // and calculate something to return.
 **const toReturn = something;**
 **console.log("Exiting myFunction, returning ", toReturn);**
 **return toReturn;**
}
```

然而，如果函数有多个返回语句，你需要修改它们所有的返回部分。

使用高阶日志记录函数更好：

```
const addLogging = (fn) => (...args) => {
❶ console.log("Entering ", fn.name, " with ", . . .args);
❷ const toReturn = fn(...args);
❸ console.log("Exiting ", fn.name, " returning ", toReturn);
❹ return toReturn;
}
```

`addLogging()` 函数接收一个函数作为参数，并返回一个新函数❹。首先，这个新函数记录原始函数的名称❶和它接收到的参数。然后，它实际上调用原始函数来计算函数所需的内容❷。之后，新函数记录结果❸，并最终返回该值。

这是一个简单的示例：

```
❶ const sum2 = (a, b) => {
  console.log("Calculating...");
  return a+b;
}

❷ addLogging(sum2)(22, 9);
**// Entering sum2 with 22 9**
**// Calculating...**
**// Exiting sum2 returning 31**
```

`sum2()` 函数记录某些内容，并返回它的参数之和❶。当你将 `sum2` 作为参数传递给 `addLogging` 并调用返回的函数❷时，你可以获得额外的日志记录，而不需要触及原始函数。

#### 副作用

当一个函数仅依赖它所接收的参数，并且不产生任何副作用时，它被称为*纯函数*。纯函数的概念与数学函数密切相关：给定一个*f*(*x*)函数，当给定一个*x*的值时，它所做的只是计算一个新的值。

使用纯函数的一个优点是它们不会产生任何副作用，例如改变程序状态、修改变量、改变对象等。这意味着当你调用一个纯函数时，你不需要担心代码中的任何可能的变化或其他部分可能会被破坏；你可以专注于传递给函数的参数，知道不会发生任何“意外”。当传入相同的参数时，函数总是会返回相同的结果。这个结果不会依赖于任何“外部”变量或状态，这些变量或状态可能会改变并导致函数产生不同的结果。另一方面，纯函数不能依赖于随机数、一天中的时间、输入/输出（I/O）函数的结果等；它只依赖于它的输入。

##### 使用全局状态

副作用的最常见原因是使用与代码其他部分共享的非局部变量。由于纯函数在给定相同输入时总是产生相同的输出，如果一个函数依赖于它之外的某些变量，它就自动变成了不纯函数。

问题更为复杂；调试一个依赖于全局状态的函数更加困难，因为为了理解为什么一个函数返回了某个特定的值，你必须还要理解程序状态是如何达到的，而这本身就需要理解运行代码的所有历史。即使你没有特别遵循函数式编程（FP）的原则，避免使用全局变量的建议也是非常有价值的。

##### 保持内部状态

你可以将不使用外部变量的做法扩展到避免使用内部变量，这些变量在函数调用之间保持状态。即使没有全局变量的存在，内部变量也可能导致未来对函数的调用返回不同的输出，即使传入相同的输入参数。

使用内部状态是为什么函数式编程者不喜欢使用对象的原因。面向对象编程（OOP）要求数据存储在对象中以供计算，这自动开启了不纯代码的可能性，因为某些方法可能不仅依赖于它们的参数，还依赖于对象的内部属性。

##### 变更参数

我们已经考虑了操作（并可能修改）外部或内部变量，但还有一种“罪行”你可能会犯：修改函数的实际参数。在 JavaScript 中，参数是按值传递的，除非它们是对象或数组，这些是按引用传递的。后者意味着，如果函数修改了参数，它实际上是在修改原始对象或数组，这无疑是一种副作用。你在本章之前看到的一个可能的例子是通过首先应用 .reverse() 来反转数组，从而模拟 .reduceRight() ——这是一个意外的副作用（参见第 29 页的“将数组缩减为单个值”部分）。

检测这种错误可能比较困难，因为 JavaScript 本身提供了几个会根据定义修改其输入的函数和方法。例如，如果你决定对输入数组进行排序，执行 `myArray.sort()` 实际上会修改原始数组，而这可能是调用你函数的用户未曾注意到的。其他数组方法，如 pop() 或 splice()，也会影响相关数组；类似的*变异*方法还有很多。（然而需要注意的是，ECMAScript 最近增加了 toSorted()、toReversed() 和 toSpliced() 方法，它们不会影响原始数组。）

##### 返回不纯函数

有些函数本质上是不纯的。例如，如果你调用一个 API 来获取每日新闻，你期望每次返回不同的结果。如果你正在编写一个游戏，并且需要使用 Math.random() 来生成随机数，你会希望每次结果不同；如果它总是返回相同的数字，那就没有用了。类似地，任何与当前日期或时间相关的函数都会是不纯的，因为其结果取决于外部条件（即时间），这可以看作是全球状态的一部分。

对于与 I/O 相关的函数，返回结果可能因其他原因发生变化。I/O 错误可能会意外发生；例如，外部服务可能崩溃，或者某些文件系统的访问权限可能发生变化。这意味着函数在任何时候都可能抛出异常，而不是返回数据。即使是看似安全的函数，如 console.log()，它不产生内部变化，但也是不纯的，因为用户会看到控制台输出的变化。

#### 不纯函数

摆脱所有不纯的情况可能不现实，因此下一个选项是考虑如何减少问题的规模。一个解决方案是避免使用状态，另一个解决方案是使用*注入*模式来控制不纯性。

##### 避免状态

关于设置全局状态，幸运的是，有一个广为人知的解决方案。如果一个函数需要*获取*全局状态，只需将所需的状态元素作为参数提供给该函数。这种方法解决了这个问题，因为函数就不需要直接访问全局状态了。另一方面，如果一个函数需要*设置*全局状态，它不应该直接这么做。该函数应该生成一个更新后的状态并返回，调用者应负责更新全局状态。如果确实需要更新状态，至少会在更高的层次上进行；提供状态数据给函数的同时，也会更新状态。

这两条规则也简化了测试。你不需要设置某些全局状态，只需将初始状态提供给函数，然后检查返回的新状态是否正确。

##### 使用依赖注入

所以，处理状态的问题已经解决了，但如果你真的需要一些不纯粹的函数——例如用于 I/O 或随机数时怎么办呢？这里展示的技术提供了更灵活的代码，简化了单元测试，并便于后期维护。

假设一个函数需要调用 API，并且像本章之前展示的那样直接通过 Axios 实现（参见第 25 页的“函数作为一等公民”部分）：

```
doSomething(a, b, c);
...
function doSomething(x, y, z) {
  // ...
  **axios.get("/some/url");**
  // ...
}
```

不直接调用 API，而是提供（或注入）一个函数来执行它：

```
❶ const getData = (url) => axios.get(url);

❷ doSomething(a, b, c, **getData**);

function doSomething(x, y, z, getter) {
  // ...
  **getter("/some/url");**
  // ...
}
```

你定义了一个新的 getData() 函数，实际调用了 API ❶ 并将其作为新的额外参数 ❷ 传递给（修改后的）doSomething() 函数。你实际上并没有避免使用不纯函数（例如进行 I/O 操作），但现在调用者通过注入相关函数来控制这一过程。

这个解决方案与避免使用全局状态时的做法是一样的，因为直接使用 axios.get() 实际上是在使用全局对象的方法，而你避免这种情况的做法是为函数提供一个额外的参数，这样它就不需要直接访问任何全局对象了。整个代码仍然会按需进行 I/O 操作，但现在更低层次的 doSomething() 函数是纯粹的，并且为了测试目的，你可以提供一个模拟函数。### 总结

本章中，我们描述了函数式编程（FP）的特点，JavaScript 如何支持它，并给出了几个使用示例。以 FP 为导向的编程方式能够使代码更清晰、更易于维护，且我们将在本书中根据实际情况始终使用这种风格。在后续章节中，我们将致力于应用 FP，并使用函数来处理算法和数据结构。第十八章完全采用函数式编程路线，探讨了 FP 概念如何扩展到函数式数据结构。

### 问题

**2.1 纯粹还是不纯粹？**

考虑以下一个计算圆周长的函数，它通过访问全局变量来计算，但它是纯粹还是不纯粹的？

```
const PI = 3.14159265358979;
const circumference = (r) => 2 * PI * r;
```

**2.2 为失败做好准备**

`addLogging()` 函数没有考虑到原始函数抛出异常的情况。你能修改它以便在这种情况下也能正确返回结果吗？

**2.3 你有时间吗？**

编写一个 `addTiming()` 高阶函数，它接受一个函数作为参数并生成一个等效的新函数，但会在控制台记录时间数据。你想要的解决方案类似于本章提到的 `addLogging()` 函数；也要注意异常的处理。

**2.4 解析问题**

如果你尝试对 `["1", "2", "4", "8", "16", "32"]` 使用 `.map(parseInt)`，会得到一个奇怪的结果 `[1, NaN, NaN, NaN, 1, 17]`；你能解释一下为什么吗？提示：检查 `.map()` 向你的函数传递了哪些参数。

**2.5 否定一切**

编写一个 `negate()` 高阶函数，给定一个谓词，它将生成一个互补谓词，返回相反的结果。例如，如果你有一个 `isAdult()` 函数检查某个参数是否大于或等于 21，`negate(isAdult)` 将检查该参数是否*不*大于或等于 21。（提示：你可能会发现这个函数在接下来的两个问题中很有用。）

**2.6 每个、一些 ... 没有？**

创建一个 `.none()` 方法，用于检查数组中是否没有元素满足给定的谓词条件。

**2.7 没有一些，没有每个**

根据 `.find()` 或 `.findIndex()` 编写 `.some()` 和 `.every()` 的等效函数。

**2.8 它做了什么？**

解释以下代码的输出及其原因：

```
["James Bond", 0, 0, 7].map(Boolean)
```
