

# 前言



![](img/opener.jpg)

本书涉及计算机科学中的两个基本概念：数据结构和算法。它的结构与大学课程类似，并添加了来自编码挑战和面试题目的示例，利用这些示例讨论特定算法和数据结构的相对优缺点。

所有示例都用 JavaScript 编写，特别注意现代语言特性，以简化编程。性能也被考虑到，包括从理论角度（算法的时间复杂度）和实际角度（架构设计、性能测试）。每章结束时都会有一系列问题，帮助加深本章所涉及的概念，并为读者提供进一步的示例来应用。问题的答案会在书末给出。

## 谁应该阅读本书？

本书面向三类读者。第一类也是主要的读者是 JavaScript 前端（Web）和后端（Node.js）开发者，因为本书探讨了如何运用数据结构和算法来解决和优化复杂问题。

第二类读者是计算机科学（CS）专业的学生，因为本书涵盖了大多数计算机科学课程中的主题。这些学生应该熟悉几种编程语言，因此，专注于 JavaScript 并不会成为障碍。这些算法并不依赖于语言的特性，可以轻松地转换为其他语言。

最后，第三类读者是正在准备编码面试或对竞技编程感兴趣的程序员。这些读者将从实际的算法和数据结构实现中获益，并通过看到他们将遇到的各种问题的示例，来提升自己的能力。

## 本书的写作方法是什么？

本书始终采用实际的方式来探讨真实世界中的使用案例。它考虑了常见的问题，并讨论了适当的算法和数据结构。我们将探讨多个版本和优化，并开发几个实现变体，以便更深入地理解可能的替代解决方案。

所有的示例都使用 JavaScript 编写，因为它是一种广泛可用的语言，既可应用于前端也可用于后端开发。JavaScript 也非常知名且被广泛使用，应该能够应用于各种问题。

## 本书内容是什么？

这本书分为三部分。第一部分涵盖了基础内容，并突出了整个书中使用的 JavaScript 重要特性。我们将探索函数式编程，以理解后续章节中应用的一些设计考虑因素。我们还将考虑抽象数据类型（ADTs），这是一个涉及数据结构和算法的概念。最后，我们将研究与算法相关的性能问题，这将在本书的后续章节中多次应用。以下章节位于第一部分：

**第一章：使用 JavaScript **在这一章，我们将介绍本书其余部分中使用的 JavaScript 重要特性，但我们只会考虑重点内容，因为假设你已经熟悉该语言。主题包括当前的 JavaScript 版本、转译、类型、箭头函数、扩展运算符、解构、模块等。我还将介绍一些可帮助你开发 JavaScript 代码的工具。

**第二章：JavaScript 中的函数式编程 **在这一章，我们将探讨函数式编程，突出在本书其余部分中使用的一些设计特性。主题包括函数式编程是什么，为什么你应该使用它，JavaScript 是否是一种函数式编程语言，声明式编程风格、副作用和高阶函数等。

**第三章：抽象数据类型 **在这一章，我将介绍抽象数据类型的概念，作为考虑数据结构及其相关操作的基础。在后续章节中，所有的数据结构将被视为 ADTs，以突出它们的优缺点以及性能。关键主题将包括什么是 ADTs，以及如何在 JavaScript 中实现它们。

**第四章：算法分析 **在这一章，我们将考虑算法在空间和速度方面的性能。我们将讨论复杂度类的概念，以及它如何（和何时）应用于算法和数据结构的设计。我们将探讨的主题包括什么是算法的性能；大*O*符号；复杂度类；最优、平均、最差和摊销情况之间的差异；如何衡量性能；以及时间与空间的权衡。

第二部分的内容集中在算法上，讨论算法设计的策略。特别地，我们将考虑搜索、排序、洗牌和抽样——这些都有着著名的算法。本部分的章节如下：

**第五章：算法设计** 本章将探讨算法设计的策略，并展示每种情况的示例。我们将讨论一般实践、递归、暴力搜索、贪心算法、分治算法、回溯法、动态规划、分支限界法、变换与征服法和问题简化。

**第六章：排序** 本章将讨论几种常见且重要的排序算法，旨在将无序的数据序列转变为有序序列。有些算法（如堆排序）只会简要提及，因为它们将在后续章节中进一步分析，届时会详细描述相应的数据结构。本章内容包括排序问题的描述、内部排序与外部排序、JavaScript 自带的排序函数、基于比较的算法（如冒泡排序、选择排序、插入排序、快速排序、归并排序等），以及无比较的排序算法（如位图排序、计数排序和基数排序）。

**第七章：选择** 本章将展示只找出列表或数组中第*k*小值的算法，而不是排序算法，排序是为了将完整集合排序。我们将讨论选择问题的一般情况，使用 JavaScript 的最小值和最大值函数；通过排序（或部分排序）进行选择；以及其他几种算法，如快速选择、Floyd-Rivest 算法、中位数的中位数和选择排序。

**第八章：洗牌与采样** 本章可以视为第六章的补充。在这里，我们希望生成一个随机无序的数据序列，而不是完全有序的序列，这在计算机扑克牌游戏或统计抽样中可能是需要的。我们将讨论洗牌问题，如何进行随机排序，Fisher-Yates 算法，随机键排序和随机采样算法。

**第九章：查找** 本章将考虑几种常见的查找算法，目的是快速判断某个特定值是否包含在某个数据集内。有些算法将在本章介绍，但我们将在后续章节中对它们进行更深入的探讨，届时会描述并分析相应的数据结构。本章的内容包括查找问题的描述、JavaScript 自带的查找函数、线性查找（有无哨兵）、跳跃查找、二分查找和插值查找。

本书的第三部分专注于数据结构，考虑了几种数据结构类型，从简单的线性结构到更复杂的非线性结构。本部分包括以下章节：

**第十章：列表** 本章讨论最简单的结构——链表，还包括几种变种。我们将详细探讨链表（它是什么，几种类型，它的抽象数据类型；单向、双向和循环链表）、栈（它是什么以及几种实现方式）、队列（队列是什么，它的应用，抽象数据类型及多种实现方式），以及双端队列（它的目标、抽象数据类型和实现）。

**第十一章：袋、集合与映射** 本章将讨论可以表示集合（没有重复元素）和袋（允许重复元素）的结构，并将映射（键/值对）作为一个特殊的重要案例。我们将了解袋和集合是什么以及它们的实现（包括 JavaScript 自身的版本以及基于数组和链表的版本），最后讨论哈希和位图。

**第十二章：二叉树** 本章讨论二叉树，特别是二叉搜索树（BST），它是许多算法的基础。我们将讨论树是什么，树的遍历（前序、中序和后序算法），以及使用二叉搜索树进行查找（包括伸展树、平衡搜索树如 AVL 树和红黑树，以及随机化的二叉搜索树）。

**第十三章：树与森林** 在本章中，我们将研究更一般的树的变种，包括森林（一组树）。主题包括树和森林的定义，它们的几种表示方式，遍历算法（广度优先和深度优先算法），B 树及其用于查找的变种，以及作为二叉搜索树变种的红黑树。

**第十四章：堆** 在本章中，我们将讨论堆，一种二叉树的变种，它无需动态内存即可存储，并且可以轻松实现优先队列和排序。我们将讨论堆是什么，二叉堆及其变种（如三叉堆或 d 叉堆）、堆排序（一种基于堆的排序算法）、基于堆的采样算法以及堆相关的二叉搜索树（treap）。

**第十五章：扩展堆** 本章扩展了堆的概念，考虑了允许额外操作的变种，例如改变（更改键的值）和合并（将两个或多个堆合并为一个）。我们将讨论二项堆、懒惰二项堆、斐波那契堆以及配对堆。

**第十六章：数字查找树** 在本章中，我们将讨论专门设计用来查找字符串的树结构，比如常见的“字典”，我们可以在其中查找单词。我们将介绍字典树（trie）、基数字典树（radix trie）、三叉字典树（ternary trie）以及这些结构的其他变种。

**第十七章：图** 本章将讨论图结构，目前在许多应用中都有使用，比如谷歌地图或在软件项目中计算依赖关系。内容包括图是什么、不同的表示方式（如邻接表或邻接矩阵）、图的遍历和路径寻找（包括最短路径算法）、以及拓扑排序。

**第十八章：不变性与函数式数据结构** 本章将讨论不变性方面的内容，并探索如何通过修改算法来避免改变输入结构，从而产生一个新的结构。我们将了解什么是函数式数据结构，什么是不变性，如何冻结对象，避免修改数据结构所需的算法，以及一些具体的函数式数据结构示例，如列表、队列和树。

本书最后提供了每章末尾问题的答案；有时答案会给出完整解答，而有时则提供提示或解决方案的链接。

> 注意

*本书的所有源代码都可以在* [`github.com/fkereki/data-structures-and-algorithms-book`](https://github.com/fkereki/data-structures-and-algorithms-book) 获得。
