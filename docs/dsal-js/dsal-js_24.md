

# 第二十一章：索引



+   数字

+   2-3 树，304，311–312。*另见* B 树

+   A

+   抽象数据类型（ADT），37–47

+   抽象，39

+   创建者，40

+   实现，40–46

+   使用类，41

+   使用函数，43，45

+   变异，39–40

+   修改器，40，44–45

+   观察者，40

+   操作，39–40

+   生产者，40

+   抽象，38，39

+   自适应排序，92

+   可寻址堆，346

+   阿德尔森-维尔斯基，格奥尔基，249

+   抽象数据类型（ADT），37–47

+   算法

+   分析，47，50，52，55

+   回溯，69–71，89

+   暴力破解，82

+   复杂度，50，52

+   设计，63

+   分治法，65–68，72

+   性能，50–58

+   摊销时间性能，54

+   弓箭谜题，89

+   确保平衡的二叉搜索树，249

+   渐进符号，51

+   算法的平均情况性能，54

+   AVL 树，235，249–254，261

+   添加到其中，251

+   创建，250

+   节点数，280

+   性能，255

+   从中移除，251

+   旋转，252

+   B

+   巴别塔，13，19

+   回溯，69，70，71，89

+   胶囊，40–47，203–205，219–220，232–233

+   使用二叉搜索树实现，239

+   使用列表实现，207

+   对其的操作，204

+   拜尔，鲁道夫，291

+   BB[α] 树。*参见* 权重平衡有界树

+   贝尔曼-福特最短路径算法，466

+   算法的最佳情况性能，54

+   双向冒泡排序，99

+   拜尔斯，安布罗斯，218

+   大 Omega 符号，51

+   大 *O* 符号，51–59

+   大 Θ 表示法，51

+   二叉堆，318，340，341

+   二叉搜索，56–57，59，166–168，172

+   二叉搜索树，239–282，485

+   向其中添加值，241–242

+   保证平衡，249–261

+   AVL 树，249–254，261

+   背包，实施，239

+   平衡，249–250

+   从中删除，485

+   寻找最大值，244–245

+   中序遍历，246–248，280

+   集合上的操作，239

+   性能，248–249

+   后序遍历，246，280

+   先序遍历，246，279–280

+   概率平衡，249，261–278，281–282

+   随机化二叉搜索树，262–270，281

+   重新平衡，282

+   红黑树，304–314

+   从中移除值，242–244

+   搜索，239–241

+   自调整树，249，261–278，281–282

+   集合，实施，239

+   伸展树，270–278，281–282

+   遍历，246–248，280

+   权重约束平衡树，255–261，281

+   二叉树，237–282，287，288，304

+   2-3 树，304，311–312

+   完全，238，244，247，279

+   复制，279

+   满，237–238，279，280

+   堆有序，347

+   高度，237，238，249–257，279，280

+   完美，238，248，256，279，282

+   大小，279

+   二项堆，351–367，385

+   向其中添加值，354–356

+   更改值, 360–362

+   实现, 353–354

+   合并, 356–358

+   性能, 362–363

+   从中移除值, 358–360

+   二项树, 351–352

+   位图, 206

+   位图选择, 122–123

+   位图排序, 112–113

+   博戈排序, 117

+   穷举算法, 82–86, 87

+   B 树, 291–303, 315。*另见* 红黑树

+   向其中添加键, 295–298

+   实现, 292–293

+   中序遍历, 294–295

+   优化, 315

+   性能, 303

+   从中移除键, 298–303

+   在其中搜索, 293–294

+   遍历, 294–295

+   冒泡排序, 97–98, 100, 103–104, 118

+   Burton, F. Warren, 470

+   C

+   链接, 使用哈希的, 219–221

+   制定变更, 87

+   循环列表, 195–200

+   向其中添加元素, 197

+   实现, 198–199

+   连接, 200

+   在其上的操作, 196

+   性能, 199–200

+   从中移除元素, 197–199

+   鸡尾酒摇晃排序（穿梭排序）, 99–100

+   投币洗牌, 140–141

+   梳理排序, 103–104

+   算法复杂度, 50–58

+   连通性检测, 428, 453–458

+   基于搜索的算法, 456–458

+   基于集合的算法, 454–456

+   计数选择, 123–124

+   计数排序, 114–115

+   密码算术谜题（密码算式）, 83–86, 90

+   循环检测, 427, 452–453

+   Tarjan 算法, 448, 452–453

+   D

+   d-叉堆, 340–341

+   数据结构

+   二叉搜索树, 239–282, 485

+   双端队列, 191–195, 201

+   哈希表。*见* 哈希

+   堆。*见* 堆

+   列表, 177–184, 195–200, 201

+   队列，188–191，201，326–327，342，346–347，531

+   栈，184–188，200，201

+   treap，332–340，343

+   树。*见* 树

+   前缀树。*见* tries

+   声明式编程，26–30

+   双端队列，191–195，201

+   向中添加元素，192–194

+   实现，194–195

+   操作，192

+   性能，195

+   从中删除元素，193

+   Dijkstra 算法，438

+   简化，466

+   分治，65–68，72

+   双重哈希，226–229

+   使用素数长度的双重哈希，229–232

+   倍增查找。*见* 指数查找

+   双向链表。*见* 循环链表

+   荷兰国旗问题，119

+   动态规划 (DP)，63，72–82，89–90

+   自底向上，72，79–82

+   计算斐波那契数列，72–74，79–80

+   换行，74–79，89

+   记忆化，72–74，78–81

+   求和范围，80–82，90

+   查找表，72

+   自顶向下，72–79

+   E

+   ECMAScript，6，8，10–11，13

+   ESLint，18，19

+   指数查找，168–169，173

+   扩展堆

+   二项堆，351–363，385

+   斐波那契堆，367–376，386

+   懒汉式二项堆，363–367

+   配对堆，376–384

+   偏斜堆，347–351，385

+   外部排序，92

+   F

+   阶乘，52，53，65–66，82，88

+   斐波那契堆，367–376，386

+   向中添加值，371

+   改变其中的值，372–375

+   实现，368–369

+   合并，370–371

+   性能, 375–376

+   从中移除值, 371–372

+   斐波那契数列, 66–67, 72–74, 79–80, 89

+   使用自底向上的动态规划计算, 79–80

+   使用自顶向下的动态规划计算, 72–74

+   Fira Code 字体, 15–16

+   菲舍尔-耶茨抽样, 151–152

+   菲舍尔-耶茨洗牌, 145–146, 151–152, 156

+   流类型检查器, 18

+   弗洛伊德, 罗伯特, 142, 329

+   弗洛伊德的抽样, 148–150

+   弗洛伊德的洗牌, 142–143

+   弗洛伊德-沃肖尔算法, 430–434

+   森林, 实现, 288

+   FORTH, 185

+   FORTRAN, 24

+   函数式数据结构, 470–484

+   数组, 470

+   二叉搜索树, 478–481

+   常见列表, 470–473

+   斐波那契堆, 481

+   哈希表, 470

+   队列, 474–478

+   栈, 473–474

+   函数式编程 (FP)

+   声明式风格, 26–30

+   高阶函数, 30–32

+   非纯函数, 33–34

+   使用原因, 24

+   副作用, 32–33

+   G

+   跑步搜索。*参见* 指数搜索

+   一般树, 237

+   图

+   邻接表表示法, 429–430

+   邻接矩阵表示法, 428–429

+   邻接集表示法, 430

+   弧, 425

+   箭头, 425

+   贝尔曼-福特算法, 434–438

+   连通性检测, 428, 453–458

+   循环检测, 427, 452–453

+   定义, 425–427

+   的度, 425

+   戴克斯特拉算法, 438–444

+   边, 425

+   弗洛伊德-沃肖尔算法, 430–434

+   哈密顿回路, 88

+   卡恩算法, 445–448

+   克鲁斯卡尔算法, 88, 462–465

+   链接, 425

+   最小生成树, 88, 427, 458–465

+   邻居, 425

+   节点, 425

+   点, 425

+   普里姆算法, 459–462

+   表示，428–430

+   最短路径问题，427，430–443，466

+   排序，444–452

+   Tarjan 算法，448，452–453

+   拓扑排序，427，445–448，451–452，466

+   顶点，425

+   贪心算法，63，87–88

+   H

+   哈希，218–232，233

+   向中添加值，220，224，228，231

+   链接法，见，219–221

+   碰撞，219，222

+   创建，220，223–224，227，230–231

+   双重哈希，226–229

+   带质数长度的双重哈希，229–232

+   哈希余数函数，218

+   负载因子，222，223，225，226，228

+   开放定址法，见，221–226

+   性能，221，225

+   从中删除值，221，225，229，232

+   调整大小，233

+   在中搜索，220，224，228，231

+   堆

+   添加到，321–323

+   可寻址堆，346–347

+   二叉堆，318–325

+   二项堆，351–363，385

+   d-叉堆，340–341

+   斐波那契堆，367–376，386

+   弗雷德曼，迈克尔，368

+   堆排序的二叉树。*见* 斜堆

+   堆属性，318，319–320，330，332–337

+   实现，320–325

+   惰性二项堆，363–367

+   左式堆，347

+   最大堆，319

+   最小堆，319

+   操作，320

+   配对堆，376–384

+   性能，325

+   优先队列，326–327，342

+   四元堆，340

+   从中移除, 323–325, 342

+   搜索, 342, 386

+   偏斜堆, 347–350, 385

+   结构属性, 318–319, 332

+   Treap, 332–340, 343

+   三叉堆, 340

+   堆排序, 320, 327–331, 342, 343

+   分析, 329

+   Floyd 的堆构建优化, 329

+   Williams 原始堆排序, 327

+   高阶函数, 30–32

+   Hindley-Milner 类型系统, 41

+   I

+   不可变性。*请参见* 函数式数据结构

+   非纯函数

+   避免状态, 33–34

+   使用注入, 34

+   低效排序, 116–117

+   无限循环。*请参见* 无限循环

+   二叉搜索树的中序遍历, 246–248, 280

+   原地排序, 93

+   插入排序, 101–103, 104, 105, 108, 111, 118

+   内部排序, 92

+   插值搜索, 169–171

+   J

+   JavaScript, 3–21, 25–34。*另请参见* 函数式编程 (FP)

+   箭头函数, 4–5

+   类, 5–6

+   闭包, 11–13

+   CommonJS 模块, 9

+   解构赋值, 7–8, 9–10

+   开发工具, 13–20

+   ECMAScript 模块, 10–11

+   数组筛选, 27

+   作为函数式语言, 25–34

+   .indexOf 方法, 160

+   遍历数组, 30

+   模块, 8–11, 13

+   .pop 方法, 185, 200

+   .push 方法, 185, 200

+   .random 方法, 138

+   将数组简化为一个值, 29–30

+   数组搜索, 27–28

+   睡眠排序, 117

+   .sort 方法, 95–96

+   扩展运算符, 6–7

+   测试数组, 28, 36

+   转换数组, 28–29, 35

+   JSDoc, 16–18

+   跳跃搜索, 163–166, 172

+   K

+   卡恩算法，445–448

+   克努斯，唐纳德，52，152，157

+   克努斯的抽样，152

+   克鲁斯卡尔算法，462–465

+   L

+   兰迪斯，叶夫根尼，249

+   懒惰二项堆，363–367

+   向中添加值，364–365

+   变更值，366–367

+   实现，363–364

+   性能，367

+   从中移除值，365–366

+   懒惰选择，132–134

+   左倾堆，347

+   莱默代码，144

+   线性查找，160–162

+   LISP，24，177

+   列表

+   向中添加值，182

+   附加到，200

+   循环列表，195–200

+   创建，182

+   双端队列，191–195，201

+   获取指定位置的值，183

+   使用数组实现，179–180

+   使用动态内存实现，180–183

+   操作，178

+   有序列表，207–210

+   性能，184

+   队列，188–191，201

+   从中移除值，182–183

+   在中查找，183–184

+   自组织，215–218，232

+   跳表，210–215，232

+   栈，184–188，200，201

+   彩票抽样，150–151

+   洛伊德，萨姆，70，89

+   卢卡斯，埃德华，67

+   M

+   地图，203，205，220，221

+   已定义，203

+   操作，205

+   最大堆，319

+   迷宫，求解，69–70

+   麦克克雷特，爱德华，291

+   中位数选择算法，127–130

+   可合并优先队列（MPQs），346–347

+   操作，347

+   归并排序，93，110–112，119，133

+   最小堆，319

+   最小生成树，88，427，458–465

+   克鲁斯卡尔算法，462–465

+   普里姆算法，459–462

+   Mozilla 开发者网络（MDN），13

+   多重集，40–47

+   互递归。*参见* 互递归

+   O

+   基于对象的字典树，401–405

+   向中添加键，404–405

+   实现，402

+   性能，406

+   从中移除键，405–406

+   搜索，402–404

+   面向对象编程（OOP），23，32

+   离线排序，93

+   O’Neill，梅丽莎，470

+   在线排序，93

+   仅一个值抽样，146–147

+   开放寻址，哈希表，221–226

+   果园，284

+   有序列表，207–210

+   向中添加值，208–209

+   性能，210

+   从中移除值，209–210

+   在中搜索，207–208

+   哨兵和，211，212，232

+   不同位置排序，93

+   P

+   配对堆，376–384

+   向中添加值，378

+   改变值，382–384

+   实现，377

+   合并，377–378

+   性能，384

+   从中移除值，378–381

+   Pandita，纳拉扬，84

+   分区交换排序。*参见* 快速排序

+   帕斯卡三角形，352

+   性能，算法，50–59

+   平摊时间，54

+   平均情况，54

+   最佳情况，52，54，59

+   大Ω符号，51–52

+   大*O*符号，51–52，57，59

+   大Θ符号，51，59

+   类，复杂度，52–54

+   常数阶，52，53，54

+   指数阶，52，53

+   阶乘阶，52，53

+   线性阶，52，53，55

+   对数阶，52，53

+   对数线性阶，52

+   测量，54–55

+   二次阶，52，53

+   小ω符号，51，52，57

+   小*o*表示法，51，52，59

+   权衡，57–58

+   最坏情况，52，54，55，57，59

+   算法的性能测量，54–55

+   性能权衡，57–58

+   生成下一个排列，84–86

+   排列排序，117

+   持久化数据结构。*参见* 函数式数据结构

+   PostScript，185

+   Prettier 格式化，16

+   普里姆算法，459–462

+   优先级队列，326–327，342，346–347，531

+   可寻址，346–347

+   可寻址堆，346

+   左式堆，347

+   可合并，346–347

+   操作，326，347

+   概率平衡二叉搜索树，249，261–278，281–282

+   Q

+   四元堆，340

+   队列，188–191，201，326–327，342，346–347，531

+   向队列中添加元素（入队），189

+   实现，189–191

+   操作，188

+   性能，191

+   优先级，326–327，342，346–347，531

+   从队列中移除元素（出队），189–190

+   快速选择，125–132，135

+   快速排序，105–110，119，125–126，127，247，264

+   双枢轴选择，108–110

+   混合方法，107–108

+   “三数中值”枢轴选择，107

+   枢轴选择技巧，106–107

+   标准版本，105–106

+   R

+   基数排序，112，115–116，119

+   基数树，406–413

+   向其中添加键，410–411，424

+   创建，407

+   性能，414

+   从中移除键，412–414

+   搜索，407–409

+   随机化二叉搜索树，262–270，281

+   添加键到，263–264

+   创建，262–263

+   合并，268–269

+   性能，269–270

+   从中移除键，267–268

+   分割，264–267

+   随机数生成，138

+   React Redux，40

+   递归，64–72，82，89，208

+   分治法，65–68，72

+   备忘录化，73–74，78–81

+   互相. *见* 互递归

+   红黑树，304–314

+   添加键到，306–307

+   实现，305–306

+   性能，313–314

+   从中移除键，309–313

+   恢复结构，307–309

+   重复步骤枢轴选择，130–132

+   水库抽样，153–154

+   逆波兰表示法（RPN），185

+   Robson, J. M., 143

+   Robson 算法，143–145，156

+   S

+   抽样，146–153，156，157

+   Fisher-Yates 算法，151–152

+   Floyd 算法，148–150

+   Knuth 算法，152–153

+   抽奖，150–151

+   只有一个值，146–147

+   带重复，146–147，156

+   不带重复，147–154

+   水库抽样，153–154

+   多个值，147

+   通过排序或洗牌，148

+   搜索

+   二分搜索，56–57，59，166–168，172

+   定义，159–160

+   指数搜索，168–169，173

+   插值搜索，169–171

+   跳跃搜索，163–166，172

+   线性搜索，160–161

+   带哨兵的线性搜索，162–163

+   有序数组，163–171

+   未排序数组，160–162

+   Sedgewick, Robert，304，312

+   选择

+   位图选择，122–123

+   计数选择，123–124

+   惰性选择，132–134

+   中位数的中位数枢轴选择，127–130

+   归并排序，133

+   快速选择，125–132，135

+   快速排序，105–110，119，125–126，127，247，264

+   重复步骤枢轴选择，130，131，135

+   使用比较选择，124–125，130

+   无比较选择，122–124

+   选择排序，100–101，124–125，135

+   自调整树，249，261–278，281–282

+   自组织列表，215–218，232

+   向其中添加值，217

+   计数排序策略，218

+   移动到前端（MTF）策略，218

+   性能，217–218

+   从中移除值，217

+   在中搜索，215–217

+   与前一个交换策略，218

+   变种，217–218

+   集合

+   二叉搜索树，实现方式，239–282

+   位图，实现方式，206

+   哈希，233

+   JavaScript 对象，与之结合，205–206

+   列表，实现方式，207–218

+   操作，204

+   外壳排序，104–105

+   最短路径问题，427，430–443，466

+   贝尔曼-福特算法，434–438

+   戴克斯特拉算法，438–444

+   弗洛伊德-沃尔沙尔算法，430–434

+   洗牌，139–146，148，151，155–157

+   通过投币，140–141

+   菲舍尔-耶茨算法，145–146，151–152，156

+   弗洛伊德算法，142–143

+   线性时间，142–146

+   排列，139，142–146，155

+   罗布森算法，143–145，156

+   通过排序，139–140

+   穿梭排序，99–100

+   副作用

+   保持内部状态，32

+   变更参数，33

+   返回非纯函数，33

+   使用全局状态，32

+   沉降排序，99，118

+   偏斜堆，347–350，385

+   向其中添加键，350

+   实现，348

+   合并，348–350

+   性能，350–351

+   从中删除键，350

+   跳表，210–215，232

+   向其中添加值，213–214

+   创建，211–212

+   性能，215

+   从中删除值，214–215

+   重构，232

+   在其中查找，212

+   睡眠排序，117

+   慢排序，116

+   小欧米伽符号，51，52，57

+   小 *o* 符号，51，52，59

+   排序

+   自适应，92–93

+   双向冒泡排序，99

+   位图排序，112–113，115

+   博戈排序，117

+   冒泡排序，97–98，100，103–104，118

+   鸡尾酒摇摆排序，99

+   梳排序，103–104

+   计数排序，114–115

+   荷兰国旗问题，119

+   外部，92

+   堆排序，320，327–331，342，343

+   低效，116–117

+   原地，93

+   插入，108

+   插入排序，101–103，104，105，108，111，118

+   内部，92

+   归并排序，93，110–112，119，133

+   离线，93

+   在线，93，105

+   非原地，93

+   分区交换排序，105

+   性能，93，96–98，101，105–108，110–112，117–119

+   排列排序，117

+   二叉查找树的先序遍历，280

+   快速排序，105–110，119，125–126，127，247，264

+   基数排序，112，115–116，119

+   选择排序，100–101，124–125，135

+   Shell 排序，104–105

+   shuttle 排序，99

+   沉降排序，99，118

+   睡眠排序，117

+   慢排序，116

+   .sort 方法，95–96

+   稳定性，93–94，96，111，116，118

+   stooge 排序，116

+   Tim 排序，111

+   展开树，270–278，281–282

+   向中添加键，274–275

+   性能，278

+   从中移除键，275–278

+   在中搜索，274

+   展开树，271–274

+   海滩上的方格游戏，70，89

+   栈，184–188，200，201

+   添加到（推入），185–187

+   使用数组实现，185

+   操作，185

+   性能，188

+   弹出（从中移除），185–187

+   斯特林近似，97

+   stooge 排序，116

+   T

+   Tarjan，罗伯特，368，448，452–453

+   Tarjan 算法，448，452–453

+   同义命题，检测，82–83

+   三元堆，340–341

+   三元搜索尝试，414–424

+   向中添加键，417–419

+   创建，415–416

+   性能，423

+   从中移除键，419–423

+   在中搜索，416–417

+   在中存储额外数据，416

+   Tim 排序，111

+   拓扑排序，427，445–448，451–452，466

+   Kahn 算法，445

+   Tarjan 算法，448，452–453

+   汉诺塔，67，89

+   旅行商问题，84，87–88

+   treap，332–340，343

+   向中添加键，333–336

+   创建，332–333

+   合并，343

+   性能，339–340，344

+   从中移除键，336–339，343

+   搜索，332–333

+   分割，343

+   树

+   2-3 树，304，312

+   向中添加节点，286

+   祖先，定义，237

+   AVL 树，235，249–254，261

+   二叉搜索树，239–282，485

+   二叉树，237–282，287，288，304

+   二项树，351–352

+   广度优先（层次遍历）遍历，290–291

+   B 树，291–303，315

+   子节点，定义，237

+   定义，283–290

+   度，237，284

+   深度优先遍历，289–290

+   后代，定义，237

+   等价，314–315

+   森林，284，288

+   一般树，237

+   树丛，定义，284

+   高度，237，272

+   使用数组实现，284–287

+   使用二叉树实现，287

+   中序遍历，289，294

+   层次，定义，237

+   最小生成树，88，427，458–465

+   多叉（多路），定义，284

+   果园，定义，284

+   有序森林，284

+   组织图（组织结构图），236

+   父节点，定义，237

+   后序遍历，289，314

+   先序遍历，289，314

+   概率平衡二叉搜索树，249，261–278，281–282

+   基数树，406–413

+   红黑树，304–314

+   从中移除节点，286–287

+   表示，237，287–291

+   根节点，定义，237

+   大小，定义，237

+   擦拭树，270–278，281–282

+   遍历，288–291

+   权重约束平衡树，255–261，281

+   试验树

+   添加键到，394–397，404–405，410–411，417–419

+   经典，388–401，424

+   实现，388–390，402，407，415–416

+   基于对象的，401–406

+   性能，401，406，414，423

+   基数树，406–413

+   从中移除键，397–401，405–406，412–413，419–423

+   在中搜索，390，402–403，407–409，416–417

+   存储额外数据，390–406

+   三元搜索尝试，414–423

+   三元堆，340

+   TypeScript，18–19

+   V

+   Visual Studio Code (VSC)，4，13–15，18

+   W

+   Waterman, Alan, 153

+   WebAssembly (WASM)，185

+   权重有界平衡（BB[α])树，255–261，281

+   向中添加键，257

+   创建，256–257

+   按排名查找，260–261

+   修复平衡，257–259

+   性能，261

+   从中移除键，257

+   Williams, John W. J., 327–329

+   算法的最坏情况性能，54
