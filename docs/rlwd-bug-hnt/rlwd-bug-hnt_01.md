## 第一章：**漏洞悬赏基础**

![Image](img/common.jpg)

如果你是黑客新手，了解互联网如何工作以及当你在浏览器地址栏中输入 URL 时背后发生的事情会有所帮助。尽管访问一个网站看起来很简单，但它涉及许多隐藏的过程，比如准备 HTTP 请求、识别发送请求的域名、将域名转换为 IP 地址、发送请求、呈现响应等等。

在本章中，你将学习基本概念和术语，如漏洞、漏洞悬赏、客户端、服务器、IP 地址和 HTTP。你将对执行意外操作、提供意外输入或访问私人信息如何导致漏洞有一个大致了解。然后，我们将了解当你在浏览器的地址栏中输入 URL 时会发生什么，包括 HTTP 请求和响应的样式以及各种 HTTP 动作动词。我们将以理解 HTTP 无状态的含义来结束本章。

### 漏洞和漏洞悬赏

*漏洞*是应用程序中的弱点，允许恶意人士执行一些未被授权的操作或访问他们本不应有权访问的信息。

在学习和测试应用程序时，请记住，漏洞可能来源于攻击者执行预期和非预期的操作。例如，更改记录标识符的 ID 来访问你本不应访问的信息，就是一种非预期的操作。

假设一个网站允许你创建一个包含姓名、电子邮件、生日和地址的个人资料。它会保持你的信息私密，并且只与你的朋友分享。但如果该网站允许任何人在没有你许可的情况下添加你为朋友，这就会成为一个漏洞。尽管该网站对非朋友保持你的信息私密，但通过允许任何人添加你为朋友，任何人都可以访问你的信息。在测试网站时，始终考虑别人如何滥用现有功能。

*漏洞悬赏*是网站或公司给予任何道德地发现漏洞并报告给该网站或公司的人的奖励。奖励通常是金钱，范围从几十美元到几万美元不等。其他形式的奖励还包括加密货币、航空里程、奖励积分、服务积分等。

当公司提供漏洞悬赏时，它会创建一个*程序*，这个术语我们将在本书中用来表示公司为希望测试其漏洞的人制定的规则和框架。需要注意的是，这不同于那些运行*漏洞披露程序（VDP）*的公司。漏洞悬赏提供一定的现金奖励，而 VDP 则不提供报酬（尽管公司可能会奖励一些纪念品）。VDP 只是道德黑客向公司报告漏洞的一种方式，目的是让公司修复这些漏洞。虽然本书中的并非所有报告都得到了奖励，但它们都是参与漏洞悬赏计划的黑客的示例。

### 客户端与服务器

你的浏览器依赖于互联网，互联网是一个计算机网络，这些计算机相互发送消息。我们将这些消息称为*数据包*。数据包包含你发送的数据以及关于这些数据的来源和去向的信息。互联网上的每台计算机都有一个地址，用于接收发送到它的包。然而，一些计算机只接受某些类型的数据包，其他计算机则只允许来自受限计算机列表的数据包。接收计算机的任务是决定如何处理这些数据包以及如何做出响应。本书的目的，我们将仅关注数据包中包含的数据（即 HTTP 消息），而非数据包本身。

我会将这些计算机称为客户端或服务器。发起请求的计算机通常被称为*客户端*，无论请求是由浏览器、命令行等发起的。*服务器*则指的是接收请求的网站和 Web 应用。如果该概念适用于客户端或服务器，我就指代一般的计算机。

由于互联网可能包含任意数量的计算机相互通信，我们需要一些规范来指导计算机如何在互联网上进行通信。这些规范以*请求评论（RFC）*文档的形式存在，定义了计算机应如何行为。例如，*超文本传输协议（HTTP）*定义了你的互联网浏览器如何使用*互联网协议（IP）*与远程服务器通信。在这种情况下，客户端和服务器都必须同意实现相同的标准，以便理解彼此发送和接收的数据包。

### 访问网站时会发生什么

由于本书将重点讨论 HTTP 消息，本节将为你提供当你在浏览器地址栏中输入 URL 时，发生过程的高层次概述。

#### *步骤 1：提取域名*

一旦你进入 *[`www.google.com/`](http://www.google.com/)*，你的浏览器会根据网址确定域名。*域名*标识了你想访问的网站，并且必须遵守由 RFC 定义的特定规则。例如，域名只能包含字母数字字符和下划线。一个例外是国际化域名，它超出了本书的讨论范围。要了解更多信息，请参阅 RFC 3490，该文档定义了它们的使用。在此示例中，域名是 *[www.google.com](http://www.google.com)*。域名是找到服务器地址的一种方式。

#### *步骤 2：解析 IP 地址*

确定域名后，你的浏览器使用 IP 来查找与该域名关联的*IP 地址*。这个过程称为解析 IP 地址，互联网上的每个域名都必须解析到一个 IP 地址才能正常工作。

存在两种类型的 IP 地址：互联网协议版本 4（IPv4）和互联网协议版本 6（IPv6）。IPv4 地址由四个数字组成，数字之间用点连接，每个数字的范围是 0 到 255。IPv6 是最新版本的互联网协议，它的设计旨在解决 IPv4 地址即将耗尽的问题。IPv6 地址由八组四个十六进制数字组成，数字之间用冒号分隔，但也有方法可以缩短 IPv6 地址。例如，8.8.8.8 是一个 IPv4 地址，而 2001:4860:4860::8888 是一个缩短后的 IPv6 地址。

为了仅使用域名查找 IP 地址，你的计算机会向*域名系统（DNS）*服务器发送请求，这些服务器是互联网上的专门服务器，拥有所有域名及其匹配 IP 地址的注册信息。上述的 IPv4 和 IPv6 地址就是 Google 的 DNS 服务器。

在这个例子中，你连接的 DNS 服务器会将 *[www.google.com](http://www.google.com)* 与 IPv4 地址 216.58.201.228 匹配，并将该地址返回给你的计算机。要了解更多关于网站 IP 地址的信息，你可以在终端使用命令`dig A` site.com，并将 site.com 替换为你要查询的网站。

#### *步骤 3：建立 TCP 连接*

接下来，计算机会尝试通过端口 80 与该 IP 地址建立*传输控制协议（TCP）*连接，因为你使用的是 *http://* 访问网站。TCP 的细节不重要，除了要注意它是另一种定义计算机如何相互通信的协议。TCP 提供双向通信，使得消息接收方能够验证他们收到的信息，确保在传输过程中没有数据丢失。

你发送请求的服务器可能正在运行多个服务（可以将服务看作是计算机程序），因此它使用*端口*来标识特定的进程，以接收请求。你可以把端口看作是服务器通向互联网的“门”。如果没有端口，服务就必须竞争发送到同一位置的信息。这意味着我们需要另一种标准来定义服务之间如何协作，并确保一个服务的数据不会被另一个服务窃取。例如，端口 80 是发送和接收未加密的 HTTP 请求的标准端口。另一个常用的端口是 443，用于加密的 HTTPS 请求。虽然端口 80 是 HTTP 的标准端口，端口 443 是 HTTPS 的标准端口，但 TCP 通信可以发生在任何端口，具体取决于管理员如何配置应用程序。

你可以通过打开终端并运行 `nc` <IP 地址> `80` 来在端口 80 上建立与网站的 TCP 连接。这一行使用了 Netcat 工具 `nc` 命令来创建一个用于读写消息的网络连接。

#### *步骤 4：发送 HTTP 请求*

继续以 *[`www.google.com/`](http://www.google.com/)* 为例，如果第 3 步中的连接成功，浏览器应该准备并发送 HTTP 请求，如 示例 1-1 所示：

```
➊ GET / HTTP/1.1

➋ Host: www.google.com

➌ Connection: keep-alive

➍ Accept: application/html, */*

➎ User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36

   (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36
```

*示例 1-1：发送 HTTP 请求*

浏览器向 `/` 路径 ➊ 发送一个 `GET` 请求，这是网站的根路径。网站的内容按照路径组织，就像你计算机上的文件夹和文件一样。当你深入每个文件夹时，你通过记录每个文件夹的名称并跟随一个 `/` 来表示所走的路径。当你访问一个网站的首页时，你访问的是根路径，它只是一个 `/`。浏览器还会指明它正在使用 HTTP 1.1 协议。`GET` 请求只是用于检索信息，我们稍后会进一步了解它。

*Host 头部* ➋ 包含作为请求一部分发送的额外信息。HTTP 1.1 需要它来识别给定 IP 地址的服务器应该将请求发送到哪里，因为一个 IP 地址可以承载多个域名。*Connection 头部* ➌ 表示请求保持与服务器的连接，以避免不断开关连接所带来的开销。

你可以在 ➍ 看到预期的响应格式。在这种情况下，我们期望 `application/html` 格式，但会接受任何格式，如通配符（`*/*`）所示。虽然有数百种可能的内容类型，但在我们的应用中，你最常见的将是 `application/html`、`application/json`、`application/octet-stream` 和 `text/plain`。最后，User-Agent ➎ 表示负责发送请求的软件。

#### *步骤 5：服务器响应*

作为对我们请求的回应，服务器应该返回类似于示例 1-2 的内容：

```
➊ HTTP/1.1 200 OK

➋ Content-Type: text/html

   <html>

     <head>

       <title>Google.com</title>

     </head>

     <body>

    ➌ --snip--

     </body>

   </html>
```

*示例 1-2：服务器响应*

在这里，我们收到了一个 HTTP 响应，状态码为 200 ➊，遵循 HTTP/1.1 协议。状态码很重要，因为它指示了服务器的响应情况。根据 RFC 的定义，这些代码通常是三位数字，开头为 2、3、4 或 5。虽然没有严格要求服务器使用特定的代码，但以 2 开头的*xx*代码通常表示请求成功。

由于没有严格要求服务器如何实现 HTTP 代码的使用，你可能会看到某些应用程序即使在 HTTP 消息体中解释存在应用程序错误，也会回应 200。*HTTP 消息体*是与请求或响应相关联的文本 ➌。在这种情况下，我们已移除内容，并用--snip--替代，因为 Google 的响应体太大。响应中的这段文本通常是网页的 HTML，但也可能是应用程序接口的 JSON，文件下载的文件内容等。

Content-Type 头部 ➋ 告诉浏览器消息体的媒体类型。媒体类型决定了浏览器如何渲染消息体的内容。但浏览器并不总是使用应用程序返回的值；相反，浏览器会执行*MIME 嗅探*，读取消息体内容的第一部分来确定媒体类型。应用程序可以通过包含*X-Content-Type-Options: nosniff*头部来禁用这种浏览器行为，但在前面的示例中没有包含该头部。

以 3 开头的其他响应代码表示重定向，指示浏览器需要发出额外的请求。例如，如果 Google 理论上需要将你从一个 URL 永久重定向到另一个，它可以使用 301 响应。相比之下，302 是临时重定向。

当收到 3*xx*响应时，浏览器应该向`Location`头部定义的 URL 发起新的 HTTP 请求，如下所示：

```
HTTP/1.1 301 Found

Location: https://www.google.com/
```

以 4 开头的响应通常表示用户错误，例如当请求没有提供适当的身份验证信息以授权访问内容时，尽管已提供有效的 HTTP 请求，仍会返回 403 响应。以 5 开头的响应表示某种服务器错误，例如 503，表示服务器无法处理发送的请求。

#### *步骤 6：渲染响应*

因为服务器返回了一个 200 响应，且内容类型为 text/html，我们的浏览器将开始渲染它所接收到的内容。响应体告诉浏览器应该向用户展示什么。

对于我们的示例，这将包括页面结构的 HTML；样式和布局的层叠样式表（CSS）；以及用于添加额外动态功能和媒体（如图像或视频）的 JavaScript。服务器也可以返回其他内容，例如 XML，但我们将在此示例中保持基础内容。第十一章将更详细地讨论 XML。

由于网页可能引用外部文件，如 CSS、JavaScript 和媒体文件，浏览器可能会为网页所需的所有文件发起额外的 HTTP 请求。在浏览器请求这些附加文件的同时，它继续解析响应并将页面主体展示给你。在这种情况下，它将渲染 Google 的首页，*([www.google.com](http://www.google.com))*。

请注意，JavaScript 是一种由所有主流浏览器支持的脚本语言。JavaScript 使网页具有动态功能，包括在不重新加载页面的情况下更新网页内容、检查密码是否足够强（在一些网站上）等。像其他编程语言一样，JavaScript 拥有内置函数，可以将值存储在变量中，并响应网页上的事件运行代码。它还可以访问各种浏览器应用程序编程接口（API）。这些 API 使得 JavaScript 能够与其他系统交互，其中最重要的可能是文档对象模型（DOM）。

DOM 允许 JavaScript 访问和操作网页的 HTML 和 CSS。这一点非常重要，因为如果攻击者能够在某个网站上执行自己的 JavaScript 代码，他们将能够访问 DOM，并代表目标用户在该网站上执行操作。第七章将进一步探讨这个概念。

### HTTP 请求

客户端和服务器之间关于如何处理 HTTP 消息的协议包括定义请求方法。*请求方法* 指示客户端请求的目的，以及客户端期望的成功结果。例如，在清单 1-1 中，我们发送了一个 `GET` 请求到 *[`www.google.com/`](http://www.google.com/)*，这意味着我们只期望返回 *[`www.google.com/`](http://www.google.com/)* 的内容，而不执行其他操作。因为互联网被设计为远程计算机之间的接口，请求方法的开发和实施就是为了区分所调用的动作。

HTTP 标准定义了以下请求方法：`GET`、`HEAD`、`POST`、`PUT`、`DELETE`、`TRACE`、`CONNECT` 和 `OPTIONS`（`PATCH` 也有提议，但在 HTTP RFC 中没有广泛实现）。在写作本文时，浏览器仅通过 HTML 发送 `GET` 和 `POST` 请求。任何 `PUT`、`PATCH` 或 `DELETE` 请求都是 JavaScript 调用 HTTP 请求的结果。当我们考虑应用程序中期望这些方法类型的漏洞示例时，这将在本书后面有所体现。

下一节简要概述了本书中你将遇到的请求方法。

#### *请求方法*

`GET`方法检索请求中标识的任何信息 *统一资源标识符（URI）*。术语 URI 通常与统一资源定位符（URL）同义。技术上，*URL*是 URI 的一种类型，它定义了一个资源，并通过网络位置提供了一种定位该资源的方式。例如，*http://www.google.com/<example>/file.txt*和*/<example>/file.txt*都是有效的 URI。但只有*http://www.google.com/<example>/file.txt*是有效的 URL，因为它通过域名* [`www.google.com`](http://www.google.com) *标识了如何定位该资源。尽管存在细微差别，我们在本书中提到任何资源标识符时都将使用*URL*。

尽管无法强制执行这一要求，`GET`请求不应更改数据；它们应该仅从服务器检索数据，并将其返回到 HTTP 消息体中。例如，在社交媒体网站上，`GET`请求应该返回你的个人资料名称，而不是更新你的个人资料。这种行为对于第四章中讨论的跨站请求伪造（CSRF）漏洞至关重要。访问任何 URL 或网站链接（除非由 JavaScript 调用）会导致浏览器向目标服务器发送`GET`请求。这种行为对于第二章中讨论的开放重定向漏洞至关重要。

`HEAD`方法与`GET`方法相同，不同之处在于服务器必须在响应中不返回消息体。

`POST`方法调用接收服务器上由服务器确定的某个功能。换句话说，通常会执行某种类型的后端操作，例如创建评论、注册用户、删除账户等。服务器对`POST`请求的响应操作可能会有所不同。有时，服务器可能根本不会采取任何行动。例如，`POST`请求可能会导致在处理请求时发生错误，从而导致记录未被保存到服务器。

`PUT`方法调用与远程网站或应用程序上已存在记录相关的某个功能。例如，它可能在更新已存在的账户、博客文章等时使用。同样，执行的操作可能会有所不同，可能导致服务器根本不执行任何操作。

`DELETE`方法请求远程服务器删除由 URI 标识的远程资源。

`TRACE`方法是另一种不常见的方法，它用于将请求消息反射回请求方。它允许请求方查看服务器接收到的内容，并利用这些信息进行测试和收集诊断信息。

`CONNECT`方法保留用于与*代理*配合使用，代理是将请求转发到其他服务器的服务器。此方法启动与请求资源的双向通信。例如，`CONNECT`方法可以通过代理访问使用 HTTPS 的网站。

`OPTIONS` 方法向服务器请求关于可用通信选项的信息。例如，通过调用 `OPTIONS`，你可以了解服务器是否接受 `GET`、`POST`、`PUT`、`DELETE` 和 `OPTIONS` 请求。此方法不会指示服务器是否接受 `HEAD` 或 `TRACE` 请求。浏览器会自动发送此类请求，针对特定的内容类型，例如 `application/json`。这种方法被称为 *预检* OPTIONS *请求*，在第四章中会更深入地讨论，因为它作为 CSRF 漏洞的保护机制。

#### *HTTP 是无状态的*

HTTP 请求是*无状态的*，这意味着每个发送到服务器的请求都会被当作一个全新的请求来处理。当服务器接收到请求时，它并不了解与浏览器之间之前的任何通信。这对大多数网站来说是个问题，因为网站希望记住你是谁。否则，你每次发送 HTTP 请求时都必须重新输入用户名和密码。这也意味着，处理 HTTP 请求所需的所有数据必须随着每个客户端发送给服务器的请求一同重新加载。

为了澄清这个困惑的概念，考虑以下示例：如果你我之间进行的是无状态的对话，那么在每句句子之前，我都得先说“我是 Peter Yaworski，我们刚刚在讨论黑客行为。”然后你得*重新加载*我们讨论的所有关于黑客的内容。想想 Adam Sandler 在 *50 次初恋* 中每天早晨为 Drew Barrymore 所做的事情（如果你还没看过这部电影，应该去看看）。

为了避免每次 HTTP 请求都重新发送用户名和密码，网站使用了 cookies 或基本认证，我们将在第四章中详细讨论。

**注意**

*使用 base64 编码内容的具体方式超出了本书的范围，但你在进行黑客攻击时很可能会遇到 base64 编码的内容。如果遇到此类情况，你应该始终解码该内容。通过 Google 搜索“base64 decode”应该能找到很多工具和方法来完成这个过程。*

### 总结

现在，你应该对互联网是如何工作的有了基本的了解。具体来说，你学到了当你在浏览器地址栏中输入一个网站时会发生什么：浏览器如何将其转化为域名，域名如何映射到 IP 地址，HTTP 请求如何被发送到服务器。

你还学到了浏览器是如何构建请求和渲染响应的，以及 HTTP 请求方法如何允许客户端与服务器进行通信。此外，你了解了漏洞是如何通过某人执行非预期的操作或获取原本无法访问的信息而产生的，并且漏洞赏金是对道德地发现并报告网站漏洞的奖励。
