# 第四章：编写可操作的代码

当代码暴露于“真实世界”时，会发生一些奇怪的事情。用户是不可预测的，网络是不可靠的，事情会出错。生产软件必须保持运行。编写可操作的代码可以帮助你应对不可预见的问题。可操作的代码具有内置的保护、诊断和控制功能。通过使用安全且具有韧性的编码实践进行防御性编程来保护你的系统。安全代码可以防止许多失败，而韧性代码在失败发生时能恢复。你还需要能够查看系统状态，以便诊断故障。暴露日志、指标和调用跟踪信息，便于诊断。最后，你需要在不重写代码的情况下控制系统。一个可操作的系统应该有配置参数和系统工具。

本章描述了一些最佳实践，这些实践将使你的代码更容易在生产环境中运行。内容涵盖广泛，因此我们保持内容的密度。到本章结束时，你将熟悉让软件可操作的关键概念和工具。此外，可操作性注释在代码审查中很常见；这些信息将帮助你更好地提供和接收反馈。

## 防御性编程

防御性代码是对任何运行你代码的人（包括你自己！）的一种关怀。防御性代码出错的几率较低，且当出现错误时，更有可能恢复。让你的代码安全且具有韧性。*安全代码*利用编译时验证来避免运行时失败。使用不可变变量、访问修饰符来限制作用域，以及静态类型检查器来防止错误。在运行时，通过验证输入来避免意外情况的发生。*韧性代码*采用异常处理最佳实践，并优雅地处理失败。

### 避免空值

在许多编程语言中，未赋值的变量默认值为`null`（或`nil`、`None`，或其他类似的变体）。空指针异常是常见的错误。堆栈跟踪常常让人困惑，并引发“这个变量怎么可能没有被设置？”的调查。通过检查变量是否为 null、使用空对象模式以及使用选项类型来避免空指针异常。

在方法开始时执行 null 检查。使用`NotNull`注解以及类似的语言特性（如果可用）。事先验证变量是否为 null，意味着后续代码可以安全地假定正在处理的是实际值，这将使你的代码更加简洁和易读。

*空对象模式*使用对象代替空值。这个模式的一个例子是，当没有找到对象时，搜索方法返回一个空列表，而不是`null`。返回空列表允许调用者安全地遍历结果，而无需编写特殊的代码来处理空结果集。

一些语言内置了*选项类型*——`Optional`或`Maybe`——迫使开发者思考如何处理空响应。如果这些选项类型可用，利用它们。

### 使变量不可变

一旦设置了不可变变量，就不能更改它们。如果您的语言有明确声明变量为不可变的方式（例如 Java 中的`final`，Scala 中的`val`而不是`var`，Rust 中的`let`而不是`let mut`），请尽可能使用。不可变变量防止了意外修改。比您想象的更多的变量可以变得不可变。作为奖励，使用不可变变量使并行编程更简单，编译器或运行时知道一个变量不会改变时，可以更高效。

### 使用类型提示和静态类型检查

限制变量可以取的值。例如，只有少数有效字符串值的变量应该是`Enum`类型，而不是`String`类型。限制变量将确保意外值会立即失败（或者可能根本无法编译），而不是引发错误。在定义变量时，使用尽可能具体的类型。

像 Python（从 Python 3.5 开始）、Ruby 通过 Sorbet（计划作为 Ruby 3 的一部分）以及 JavaScript（通过 TypeScript）等动态语言现在都支持越来越强大的*类型提示*和*静态类型检查器*。类型提示允许您在通常是动态类型的语言中指定变量的类型。例如，下面的 Python 3.5 方法使用类型提示来接收和返回一个字符串：

```
def say(something: str) -> str: return "You said: " + something
```

最好的是，类型提示可以逐步添加到现有代码库中。当与静态类型检查器结合使用时，静态类型检查器使用类型提示在代码执行之前查找错误，您可以防止运行时失败。

### 验证输入

永远不要相信代码接收到的输入。开发人员、故障硬件和人为错误可能会损坏输入数据。通过验证输入数据是否格式正确来保护代码。使用前置条件、校验和验证数据，使用安全最佳实践，并使用工具来查找常见错误。尽早拒绝不良输入。

使用前置条件和后置条件验证方法输入变量。当您使用的类型无法完全捕获有效的变量值时，请使用库和框架来验证前置条件。大多数语言都有像`checkNotNull`这样的库方法或像`@Size(min=0, max=100)`这样的注解。尽量做到尽可能的限制。检查输入字符串是否符合预期格式，并记得处理前导或尾随空格。验证所有数字是否在适当的范围内：如果参数应该大于零，确保它大于零；如果参数是 IP 地址，检查它是否是有效的 IP。

计算机硬件并不总是可靠的。网络和磁盘可能会损坏数据。如果需要强大的持久性保证，请使用校验和来验证数据是否没有意外变化。

也不要忽视安全性。外部输入是危险的。恶意用户可能会尝试向输入中注入代码或 SQL，或者溢出缓冲区以控制你的应用程序。使用成熟的库和框架来防止跨站脚本攻击。始终转义输入以防止 SQL 注入攻击。在使用 `strcpy` 这类命令操作内存时，明确设置大小参数（特别是使用 `strncpy`）以防止缓冲区溢出。使用广泛采用的安全和加密库或协议，而不是自己编写。熟悉 Open Web Application Security Project (OWASP) Top 10 安全报告（[`owasp.org/www-project-top-ten/`](https://owasp.org/www-project-top-ten/)）以快速入门安全知识。

### 使用异常

不要使用特殊的返回值（`null`、`0`、`–1` 等）来表示错误。所有现代语言都支持异常，或者有一个标准的异常处理模式（比如 Go 的 `error` 类型）。特殊值在方法签名中并不明显，开发者不会知道返回了错误状态，也就无法处理它们。而且，很难记住哪个返回值对应哪个失败状态。异常比 `null` 或 `–1` 带有更多的信息；它们是命名的，并且有堆栈追踪、行号和消息。

例如，在 Python 中，`ZeroDivisionError` 比 `None` 返回值提供更多的信息：

```
Traceback (most recent call last): File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero
```

在许多语言中，检查异常可以从方法签名中看到：

```
// Go’s Open method clearly has an error return
func Open(name string) (file *File, err error)
// Java’s open() method clearly throws an IOException
public void open (File file) throws IOException
```

Go 中的错误声明和 Java 中的异常声明清楚地表明，打开的方法可能会抛出需要处理的错误。

### 精确处理异常

精确的异常使代码更易使用。尽可能使用内建异常，避免创建通用异常。使用异常来处理失败，而不是控制应用程序逻辑。

大多数语言都有内建的异常类型（`FileNotFoundException`、`AssertionError`、`NullPointerException` 等）。如果内建类型可以描述问题，就不要创建自定义异常。开发者对现有的异常类型有经验，知道它们的含义。

在创建自定义异常时，不要让它们太通用。通用异常很难处理，因为开发者不知道他们正在处理什么样的问题。如果开发者没有得到一个明确的错误信号，他们将被迫让应用程序失败——这是一个重要的操作。尽可能具体地定义你抛出的异常类型，以便开发者能适当地处理失败。

也不要把异常用作应用程序逻辑的一部分。你希望你的代码是可预测的，而不是聪明的。用异常跳出方法会让代码变得混乱，且难以调试。

这个 Python 示例使用了 `FoundNodeException`，而不是直接返回找到的节点：

```
def find_node(start_node, search_name): for node in start_node.neighbors: if search_name in node.name: raise FoundNodeException(node) find_node(node, search_name)
```

不要这样做。只需返回节点。

### 提前抛出异常，延后捕获异常

遵循“早抛出，晚捕获”原则。*早抛出*意味着尽可能靠近错误的位置抛出异常，以便开发人员能够快速找到相关代码。等待抛出异常会让你更难找到失败实际发生的位置。当发生错误时，如果其他代码在异常被抛出之前执行，你就有可能触发第二个错误。如果第二个错误抛出了异常，你就无法知道第一个错误发生过。追踪这种错误非常令人抓狂。你修复了一个错误，却发现真正的问题在上游。

*捕获异常延迟*意味着将异常向上传播直到程序能够处理异常的级别。考虑一个尝试写入满磁盘的应用程序。有很多可能的后续步骤：阻塞并重试、异步重试、写入另一个磁盘、提醒用户，甚至崩溃。适当的反应取决于应用程序的具体情况。数据库写前日志必须写入，而文字处理器的后台保存可以延迟。能够做出此决策的代码很可能离遇到满磁盘的低级库有好几层。所有中间层都需要将异常向上传播，而不是尝试过早修复。过早修复的最糟糕情况是“吞掉”你无法处理的异常，通常是在`catch`块中忽略它：

```
try { // ...
} catch (Exception e) { // ignoring since there’s nothing I can do about it
}
```

这个异常既不会被记录，也不会被重新抛出，也不会采取任何其他行动；它被完全忽略。失败被隐藏，可能带来灾难性后果。调用可能抛出异常的代码时，要么完全处理异常，要么将其传播到栈上。

### 智能重试

对错误的适当反应通常是简单地重试。在调用远程系统时，计划偶尔需要多次尝试。重试操作看起来很简单：捕获异常并重试操作。实际上，何时以及多频繁地重试需要一定的技巧。

最天真的重试方法是简单地捕获异常并立即重试操作。但如果操作再次失败怎么办？如果磁盘空间用尽，它很可能在 10 毫秒后仍然没有空间，10 毫秒后也一样。不断地敲击会使事情变得更慢，并且让系统更难恢复。

使用一种叫做*退避*的策略是明智的。退避通过非线性增加睡眠时间（通常使用指数退避，例如`(重试次数)²`）。如果你使用这种方法，请确保设置一个最大值来限制退避时间，避免过大。然而，如果一个网络服务器出现了闪断，并且所有客户端同时经历了这个闪断，那么如果都使用相同的退避算法进行退避，它们会同时重新发起请求。这叫做*雷霆洪流*；许多客户端同时发起重试请求可能会让正在恢复的服务再次崩溃。为了解决这个问题，可以在退避策略中加入*抖动*。使用抖动时，客户端会在退避时间上加上一个随机的、有界的时间。引入随机性可以将请求分散开，减少踩踏的可能性。

不要盲目地重试所有失败的请求，尤其是那些写入数据或导致某些业务流程执行的请求。当应用遇到它未设计来处理的错误时，最好让应用崩溃；这叫做*快速失败*。如果你快速失败，后续不会造成进一步的损害，人类可以找出正确的处理方式。确保不仅要快速失败，而且要大声失败。相关信息应该是可见的，这样调试才容易。

### 编写幂等系统

系统在失败后所处的状态并不总是显而易见的。如果在远程写入请求过程中网络失败，请求是否在失败之前成功了呢？这让你陷入困境：你是重试并冒着双重写入请求的风险，还是放弃并冒着丢失数据的风险？在计费系统中，重试可能导致客户被重复收费，而不重试则可能意味着完全不收费。有时候你可以读取远程系统来检查，但并非总能如此。本地状态变更也可能面临类似的问题。非事务性的内存数据结构变更可能让你的系统处于不一致的状态。

处理重试的最佳方法是构建幂等系统。*幂等*操作是可以多次应用并且依然得到相同结果的操作。向集合中添加一个值是幂等的。无论这个值被添加多少次，它在集合中只存在一次。通过允许客户端为每个请求提供一个唯一的 ID，远程 API 可以变得幂等。当客户端重试时，它会提供与其失败尝试相同的唯一 ID；服务器可以在请求已经处理过的情况下去重请求。使所有操作都幂等可以大大简化系统交互并消除大量可能的错误。

### 清理资源

确保在发生失败时清理所有资源。释放不再需要的内存、数据结构、网络套接字和文件句柄。操作系统对文件句柄和网络套接字的数量有固定的限制；一旦超过限制，所有新的句柄和套接字都无法打开。泄漏的网络套接字——未能在使用后关闭它们——将使无用的连接持续存在，这会填满连接池。以下代码是危险的：

```
f = open('foo.txt', 'w')
# ...
f.close()
```

在 `f.close()` 之前发生的任何失败都会阻止文件指针被关闭。如果你的语言不支持自动关闭功能，应该将代码包裹在 `try`/`finally` 块中，即使发生异常也能安全地关闭文件句柄。

许多现代语言具有自动关闭资源的功能。Rust 会在对象离开作用域时自动通过调用析构方法来关闭资源。Python 的 `with` 语句会在调用路径离开代码块时自动关闭句柄：

```
with open('foo.txt') as f: # ...
```

## 日志记录

当你第一次向终端写入“Hello, world!”时，你就已经在进行日志记录了。打印日志消息对于理解代码或调试小程序非常简单方便。对于复杂的应用程序，语言提供了复杂的日志库，使操作员可以更好地控制日志的记录及其时机。操作员可以通过日志级别调节日志量，并控制日志格式。框架还会注入上下文信息——线程名称、主机名、ID——这些信息在调试时非常有用。日志框架与日志管理系统配合良好，后者将日志消息聚合，供操作员过滤和搜索。

使用日志框架可以让你的代码更易于操作和调试。设置日志级别，让操作员能够控制应用程序的日志量。保持日志原子性、快速性和安全性。

### 使用日志级别

日志框架有*日志级别*，允许操作员根据重要性筛选消息。当操作员设置了一个日志级别时，所有等于或高于该级别的日志都会被输出，而低于该级别的消息将被静默处理。日志级别通常通过全局设置和包或类级别的覆盖来控制。日志级别允许操作员根据具体情况调整日志量，从极为详细的调试日志到正常操作的稳定背景噪音。

例如，以下是一个 Java `log4j.properties` 片段，它定义了一个 ERROR 级别的根日志详细度，并为来自 `com.foo.bar` 包空间的日志设置了特定包的 INFO 级别日志详细度：

```
# set root logger to ERROR level for fout FileAppender
log4j.rootLogger=ERROR,fout
# set com.foo.bar to INFO level 
log4j.logger.com.foo.bar=INFO
```

你必须为每条日志消息使用适当的严重性级别，这样日志级别才有意义。虽然日志级别并不完全标准化，但以下级别是常见的：

1.  TRACE 这是一个极其细致的日志级别，仅针对特定的包或类启用。这个级别在开发之外很少使用。如果你需要逐行日志或数据结构的转储，这个级别适合你。如果你发现自己频繁使用 TRACE，你应该考虑使用调试器逐步执行代码。

1.  DEBUG 当消息在生产问题期间有用，但在正常操作期间没有用时，使用此级别的日志。不要使用过多的 debug 级别日志，以至于在调试时输出变得无法使用；将这些内容保留给 TRACE。

1.  INFO 这是关于应用程序状态的可选信息，但并不表示任何问题。像“服务已启动”和“监听端口 5050”这样的应用程序状态消息会记录在此。INFO 是默认的日志级别。不要在 INFO 中记录无意义的日志——“以防万一”的日志应该记录在 TRACE 或 DEBUG 级别。INFO 日志应该在正常操作期间提供有用的信息。

1.  WARN 这些是关于潜在问题情况的消息。接近容量的资源值得警告。每当你记录警告时，应该有一个明确的行动要求，希望看到该消息的人采取。如果警告没有可操作性，则记录为 INFO。

1.  ERROR 这些消息表明发生了需要关注的错误。无法写入的数据库通常会产生 ERROR 日志。ERROR 日志应该足够详细，以便诊断问题。记录明确的细节，包括相关的堆栈跟踪和软件正在执行的操作。

1.  FATAL 这些是“最后的求生”日志消息。如果程序遇到严重条件，必须立即退出，可以在 FATAL 级别记录有关问题原因的消息。应包括程序状态的相关上下文；应该记录恢复或诊断相关数据的位置。

这是在 Rust 中发出的 INFO 级别日志：

```
info!("Failed request: {}, retrying", e);
```

日志行包括导致请求失败的错误。使用 INFO 级别是因为应用程序正在自动重试；无需操作员采取任何措施。

### 保持日志原子性

如果某条信息仅在与其他数据配合时才有用，请将其在一条消息中*原子性*地记录下来。原子性日志将所有相关信息记录在一行中，更适合与日志聚合工具配合使用。不要假设日志会按照特定的顺序出现；许多操作工具会重新排序甚至丢弃消息。不要依赖系统时钟时间戳来进行排序：系统时钟可能会重置或在不同主机间漂移。避免在日志消息中使用换行符；许多日志聚合工具将每个新行视为单独的消息。特别确保堆栈跟踪以单条消息记录，因为它们通常在打印时包含换行符。

下面是一个非原子性日志消息的示例：

```
2022-03-19 12:18:32,320 – appLog – WARNING – Request failed with:
2022-03-19 12:18:32,348 – appLog – INFO – User login: 986
Unable to read from pipe.
2022-03-19 12:18:32,485 – appLog – INFO – User logout: 986
```

WARNING 日志消息中包含换行符，这使得它很难阅读。WARNING 的后续行没有时间戳，并且与来自另一个线程的其他 INFO 消息交织在一起。WARNING 应该原子性地作为一行记录。

如果日志消息不能原子性地输出，请在消息中包含唯一标识符，以便稍后将它们拼接起来。

### 保持日志快速

过度的日志记录会影响性能。日志必须写入某个地方——到磁盘、到控制台或到远程系统。字符串在写入之前必须进行拼接和格式化。使用参数化日志记录和异步附加器可以保持日志记录的快速性。

你会发现字符串拼接非常慢，在性能敏感的循环中可能会造成灾难性的后果。当一个拼接的字符串传递到日志方法中时，无论日志的详细级别如何，拼接都会发生，因为参数在传递给方法之前就已经被计算。日志框架提供了机制，推迟字符串拼接，直到实际需要时才执行。有些框架将日志消息强制进入闭包，只有在调用日志行时才会执行，而其他框架则支持参数化消息。

例如，Java 在日志调用中有三种拼接字符串的方式，其中两种在调用`trace`方法之前会拼接字符串参数：

```
while(messages.size() > 0) { Message m = message.poll(); // This string is concatenated even when trace is disabled! log.trace("got message: " + m); // This string is also concatenated when trace is disabled. log.trace("got message: {}".format(m)); // This string is only concatenated when trace is enabled. It’s faster. log.trace("got message: {}", m);
}
```

最终的调用使用了一个参数化的字符串，只有在实际写入日志行时才会被评估。

你还可以使用*附加器*来管理性能影响。附加器将日志路由到不同的位置：控制台、文件或远程日志聚合器。默认的日志附加器通常在调用者的线程中操作，就像调用`print`一样。*异步*附加器在不阻塞执行线程的情况下写入日志消息。这提高了性能，因为应用程序代码不需要等待日志写入。*批处理*附加器在写入磁盘之前将日志消息缓存在内存中，从而提高了写入吞吐量。操作系统的页面缓存也通过充当缓冲区来帮助日志吞吐量。虽然异步和批量写入提高了性能，但如果应用程序崩溃，可能会导致日志消息丢失，因为并不是所有日志都能保证写入磁盘。

请注意，改变日志的详细程度和配置可以消除竞争条件和漏洞，因为这会减慢应用程序的速度。如果你启用了详细日志记录来调试一个问题，并发现一个漏洞消失了，日志更改本身可能就是原因。

### 不要记录敏感数据

在处理敏感数据时要小心。日志消息不应包含私密数据，如密码、安全令牌、信用卡号码或电子邮件。这可能看起来很显而易见，但很容易出错——仅仅记录一个 URL 或 HTTP 响应可能会暴露日志聚合器未能保护的信息。大多数框架支持基于规则的字符串替换和删除；配置它们，但不要将它们作为唯一的防护措施。要保持警觉；记录敏感数据可能带来安全风险，并违反隐私法规。

## 度量

通过度量工具仪表化您的应用程序，以了解其行为。度量是日志的数字等效物；它们测量应用程序行为。查询花费了多长时间？队列中有多少元素？写入磁盘的数据量？测量应用程序行为有助于检测问题，并对调试有用。

有三种常见的度量类型：计数器、测量器和直方图。这些名称在不同的监控系统中可能相似，但不一致。*计数器*用于测量事件发生的次数。使用缓存命中计数器和请求计数器，您可以计算缓存命中率。计数器的值仅在进程重新启动时增加或重置为 0（它们是*单调递增*的）。*测量器*是时间点测量，可以上下波动；可以将其视为汽车速度表或汽车中的油量指示器。测量器公开统计数据，如队列、堆栈或映射的大小。*直方图*根据事件的大小将事件分成范围。每个范围都有一个计数器，在事件值落入其范围时递增。直方图通常测量请求花费的时间或数据有效负载大小。

系统性能通常以阈值百分位数的度量值来衡量，例如第 99 百分位数，简称为*P99*。具有 2 毫秒 P99 延迟的系统在收到的请求中，99%的情况下响应时间为 2 毫秒或更少。百分位数来自直方图。为了减少需要跟踪的数据量，一些系统要求您配置关注的百分位数；如果系统默认跟踪 P95，但您有 P99 服务水平目标（SLO*），请确保相应更改设置。

应用程序度量被聚合到像 Datadog、LogicMonitor 或 Prometheus 这样的集中式*可观测性* *系统*中。可观测性是控制理论中的一个概念，定义通过观察其输出来确定系统状态的便捷程度。可观测性系统试图通过提供仪表板和监控工具来更轻松地确定运行中应用程序的状态。仪表板向运营商展示系统中的运行情况，并基于度量值触发警报的监控工具。

指标也用于自动缩放系统。*自动缩放*在提供动态资源分配的环境中很常见。例如，云主机可以通过监视负载指标自动调整运行实例的数量。自动缩放在需要时增加服务器容量，在以后节省费用时减少服务器容量。

要跟踪 SLO，使用可观测性系统，并利用自动缩放功能，必须测量所有内容。度量使用标准度量库进行跟踪；大多数应用程序框架都提供这些功能。作为开发者，您的工作是确保重要的度量指标暴露给可观测性系统。

### 使用标准度量库

虽然计数器、仪表和直方图的计算相对简单，但不要自行编写度量库。非标准库是维护的噩梦。标准库可以开箱即用并与所有内容集成。你的公司可能有他们偏好的度量库。如果有，使用它。如果没有，开始讨论采用一个。

大多数可观察性系统提供多种语言的度量客户端库。我们将在一个简单的 Python Web 应用程序中使用 StatsD 客户端来展示度量的样子。度量库的结构通常很相似，所以我们的示例几乎可以无缝地迁移到你使用的任何库中。

在示例 4-1 中的 Python Web 应用程序有四个方法：`set`、`get`、`unset` 和 `dump`。`set` 和 `get` 方法简单地在服务中存储的映射中设置和检索值。`unset` 方法从映射中删除键值对，`dump` 将映射进行 JSON 编码并返回。

```
import json
from flask import Flask, jsonify
from statsd import StatsClient
app = Flask(__name__)
statsd = StatsClient()
map = {}
@app.route('/set/<k>/<v>')
def set(k, v): """ Sets a key's value. Overwrites if key already exists. """ map[k] = v statsd.gauge('map_size', len(map))
@app.route('/get/<k>')
def get(k): """ Returns key's value if it exists. Else, None is returned. """ try: v = map[k] statsd.incr('key_hit') return v except KeyError as e: statsd.incr('key_miss') return None
@app.route('/unset/<k>')
def unset(k): """ Deletes key from map if it exists. Else, no-op. """ map.pop(k, None) statsd.gauge('map_size', len(map))
@app.route('/dump')
def dump(): """ Encodes map as a JSON string and returns it. """ with statsd.timer('map_json_encode_time'): return jsonify(map)
```

示例 4-1：一个使用 StatsD 客户端度量库的 Python Flask 应用程序示例

这个示例使用计数器 `key_hit` 和 `key_miss` 来追踪 `get` 操作中的命中和未命中，使用 `statsd.incr`。定时器（`statsd.timer`）用来测量将映射编码为 JSON 所需的时间，结果将被添加到定时直方图中。序列化是一个昂贵的 CPU 密集型操作，因此应该进行度量。仪表（`statsd.gauge`）用来测量映射的当前大小。我们本可以使用计数器的增量和减量方法来追踪映射大小，但使用仪表更不容易出错。

像 Flask 这样的 Web 应用框架通常会为你做很多度量计算。大多数框架会统计每次方法调用的所有 HTTP 状态码，并对所有 HTTP 请求进行计时。框架度量是获取大量度量的绝佳方式，只需配置框架将结果输出到你的可观察性系统中。而且，你的代码会更简洁，因为度量是在框架底层进行的。

### 测量一切

测量是廉价的；你应该广泛使用它们。测量以下所有数据结构、操作和行为：

+   资源池

+   缓存

+   数据结构

+   CPU 密集型操作

+   I/O 密集型操作

+   数据大小

+   异常和错误

+   远程请求和响应

使用仪表来测量资源池的大小。特别注意线程池和连接池。大型池通常表示系统卡住或无法跟上。

统计缓存命中和未命中。命中与未命中比率的变化会影响应用性能。

使用仪表测量关键数据结构的大小。异常的数据结构大小表明可能有不正常的情况发生。

对 CPU 密集型操作进行计时。特别注意数据序列化操作，这些操作出奇地昂贵。简单的 JSON 编码数据结构通常是代码中最昂贵的操作。

磁盘和网络 I/O 操作既慢又不可预测。使用计时器来衡量它们所需的时间。测量你的代码处理的数据大小。跟踪*远程过程调用*（*RPC*）有效载荷的大小。使用直方图（类似于计时器）跟踪用于 I/O 的生成数据的大小，这样你可以看到 99 百分位的数据大小。大数据对内存占用、I/O 速度和磁盘使用有影响。

计算每个异常、错误响应代码和错误输入。测量错误使得在出现问题时容易触发警报。

测量对应用程序的任何请求。异常高或低的请求数是系统出现问题的信号。用户希望你的系统响应迅速，因此你需要测量延迟。记录所有响应时间，以便知道何时系统变慢。

花时间了解你的度量库是如何工作的。库如何计算度量并不总是显而易见；许多库会进行采样测量。采样可以保持性能快速并减少磁盘和内存使用，但它也使得测量结果不那么精确。

## 跟踪

开发人员都知道堆栈跟踪，但还有一种较不常见的跟踪方式：*分布式调用跟踪*。一次对前端 API 的调用可能会导致数百个下游 RPC 调用到不同的服务。分布式调用跟踪将所有这些下游调用串联成一个图。分布式追踪对于调试错误、衡量性能、理解依赖关系和分析系统成本（哪些 API 最昂贵，哪些客户最花费等）都非常有用。

RPC 客户端使用追踪库将调用追踪 ID 附加到请求中。后续的 RPC 调用由下游服务附加相同的调用追踪 ID。服务随后报告它们接收到的调用，以及调用追踪 ID 和其他数据，如元数据标签和处理时间。一个专门的系统记录所有这些报告，并通过调用追踪 ID 将调用追踪重新拼接在一起。凭借这些信息，追踪系统可以呈现完整的分布式调用图。

调用追踪 ID 通常会通过 RPC 客户端包装器和服务网格自动传播。确保在调用其他服务时传播任何必需的状态。

## 配置

应用程序和服务应该暴露设置，允许开发人员或站点可靠性工程师（SREs）配置运行时行为。应用配置最佳实践将使你的代码更易于运行。不要过于创新；使用标准配置格式，提供合理的默认值，验证配置输入，并尽可能避免动态配置。

配置可以通过多种方式表达：

+   纯文本、可读性格式的文件，如 INI、JSON 或 YAML

+   环境变量

+   命令行标志

+   一个自定义的*领域特定语言*（*DSL*）

+   应用程序编写的语言

人类可读的配置文件、环境变量和命令行标志是最常见的配置方式。当需要设置多个值或希望对配置进行版本控制时，通常使用文件。环境变量易于在脚本中设置，并且可以轻松检查和记录。命令行标志易于设置，并且在进程列表中可见，比如`ps`命令。

当配置需要可编程逻辑（如`for`循环或`if`语句）时，DSL（领域特定语言）非常有帮助。基于 DSL 的配置通常在应用程序使用 DSL 友好的语言（如 Scala）时使用。使用 DSL 而非完整的编程语言，作者可以为复杂操作提供快捷方式，并限制配置为安全的值和类型——这是考虑安全性和启动性能时的重要因素。但 DSL 使用标准工具进行解析时比较困难，这使得与其他工具的互操作性变得更加困难。

在应用程序的语言中表达配置通常发生在应用程序使用像 Python 这样的脚本语言编写时。使用代码生成配置非常强大，但也很危险。可定制的逻辑会模糊应用程序看到的配置。

### 不要在配置上过于创新

配置系统应该是简单的。当操作员在凌晨 3 点被叫醒时，他不应该需要记住 Tcl 语法来更改超时值。

对配置系统进行创新很有诱惑力。配置是每个人都熟悉的，而简单的配置系统似乎缺少有用的功能——如变量替换、`if`语句等。许多富有创意且心地善良的人花费了大量时间来制作精美的配置系统。可悲的是，你的配置方案越聪明，你遇到的错误就会越离奇。不要在配置上过于创新——使用最简单且有效的方法。一个标准格式的静态配置文件是理想的选择。

大多数应用程序通过静态配置文件进行配置。应用程序运行时更改该文件不会影响应用程序；要应用更改，必须重新启动应用程序。动态配置系统用于在不重新启动应用程序的情况下重新配置应用程序。动态配置通常存储在专用的配置服务中，当值发生变化时，应用程序会轮询或推送更新。或者，动态配置通过定期检查本地配置文件的更新来刷新。

动态配置通常不值得引入的复杂性。你需要仔细考虑各种配置在运行过程中改变的所有影响。它还使得追踪配置何时被更改、谁更改了它以及原始值是什么变得更加困难——这些信息在调试操作问题时可能至关重要。它还可能依赖于其他分布式系统。虽然听起来很基础，但重新启动进程以采纳新配置在操作和架构上通常更具优势。

然而，确实有一些常见的用例需要动态配置。日志详细级别通常是一个动态设置。当出现异常情况时，运维人员可以将日志级别更改为更高的详细级别，如 DEBUG。重新启动进程可能会改变你正在观察的异常行为。通过调整正在运行的进程的日志级别，可以在不重启的情况下窥视其行为。

### 记录和验证所有配置

在启动时立即记录所有（非机密）配置，以显示应用程序正在看到的内容。开发人员和运维人员偶尔会误解配置文件应该放置的位置，或者多个配置文件是如何合并的。记录配置值可以向用户展示应用程序是否看到预期的配置。

在加载配置时始终验证配置值。验证只需进行一次，并尽可能早（在配置加载后立即）。确保值被设置为正确的类型，比如端口号应为整数，并检查值是否符合逻辑：检查边界、字符串长度、有效的枚举值等。`–200`是一个整数，但不是有效的端口。利用具有强大类型系统的配置系统来表达可接受的配置值。

### 提供默认值

如果用户必须设置大量配置参数，那么你的系统将变得难以运行。设置良好的默认值，使你的应用程序在大多数用户的机器上能够即插即用。如果没有配置端口，则默认为大于 1024 的网络端口（较低的端口被限制）。如果未指定目录路径，则使用系统的临时目录或用户的主目录。

### 将相关配置分组

应用程序配置很容易变得难以管理，尤其是那些不支持嵌套配置的键值格式。使用像 YAML 这样的标准格式，它允许嵌套。将相关属性分组，使配置更易于组织和维护。

将紧密耦合的参数（如超时时间和单位）组合到一个结构中，以便清晰地表示它们之间的关系，并强制运维人员原子地声明这些值。与其定义`timeout_duration=10`和`timeout_units=second`，不如使用`timeout=10s`或`timeout: { duration: 10, units = second }`。

### 将配置视为代码

*配置即代码（CAC）*理念认为，配置应该像代码一样受到严格管理。配置错误可能是灾难性的。一个错误的整数或缺少的参数都可能使应用程序崩溃。

为了确保配置更改的安全性，配置应进行版本控制、审查、测试、构建和发布。将配置保存在像 Git 这样的版本控制系统中，这样你可以追踪更改历史。像代码审查一样审查配置更改。验证配置是否格式正确，并符合预期的类型和值范围。构建并发布配置包。我们将在第八章详细讲解配置交付。

### 保持配置文件干净

干净的配置更容易被他人理解和更改。删除未使用的配置，使用标准的格式和间距，不要盲目复制其他文件中的配置（*cargo culting*的例子：复制东西却没有真正理解它们的功能或如何工作）。整洁的配置在快速迭代时难以维护，但配置错误会导致生产环境中断。

### 不要编辑已部署的配置

避免在特定机器上手动编辑配置。一旦配置发生变动，后续的部署会覆盖这些更改，且很难追踪谁做了更改，具有相似配置的机器最终会出现分歧。

与保持配置文件干净一样，抵制在生产环境中手动编辑配置文件的诱惑是困难的，有时是不可避免的。如果在生产事件中手动编辑了配置，请确保稍后将更改提交到“真相源”（版本控制系统）。

## 工具

可操作的系统配备了帮助操作员运行应用程序的工具。操作员可能需要批量加载数据、执行恢复、重置数据库状态、触发领导选举或将分区分配从一台机器转移到另一台机器。系统应配备帮助操作员处理常见操作的工具。

工具编写是一个协作过程。在某些情况下，您将被要求编写并提供操作工具。拥有强大 SRE 团队的组织也可能为您的系统编写工具。不论如何，请与您的运维团队合作，了解他们的需求。

SRE 通常更喜欢基于 CLI 的工具和自描述的 API，因为它们易于脚本化。可脚本化的工具易于自动化。如果你计划构建基于 UI 的工具，请将逻辑抽象为共享的库或服务，CLI 工具也可以使用这些逻辑。并且像对待代码一样对待系统的工具：遵循清晰的编码标准并严格测试。

你的公司可能已经有现成的工具集；例如，通常会有一个标准的内部 Web 工具框架。将你的工具与现有的标准框架集成。寻找*单一管理控制台*（统一管理控制台）。拥有统一管理控制台的公司将期望所有工具都能与其集成。如果你的公司已有基于 CLI 的工具，可以询问是否有必要将你的工具与它们集成。每个人都习惯了现有的工具界面；与它们集成将使你的工具更容易使用。

## 做与不做

| **做** | **不做** |
| --- | --- |
| **做** 优先处理编译错误而非运行时错误。 | **不做** 使用异常处理应用逻辑。 |
| **做** 尽可能让事物保持不可变。 | **不做** 使用返回代码进行异常处理。 |
| **做** 验证输入和输出。 | **不做** 捕获无法处理的异常。 |
| **做** 学习 OWASP 十大风险。 | **不做** 编写多行日志。 |
| **做** 使用错误检查工具和类型或类型提示。 | **不做** 将秘密或敏感数据写入日志。 |
| **做** 在异常后清理资源（特别是套接字、文件指针和内存）。 | **不做** 手动编辑机器上的配置。 |
| **做** 在代码中加入度量指标。 | **不做** 在配置文件中存储密码或秘密信息。 |
| **做** 使你的应用程序可配置。 | **不做** 编写自定义配置格式。 |
| **做** 验证并记录所有配置。 | **不做** 如果可以避免，使用动态配置。 |

## 提升技能

很少有书籍专门讲解编写可操作的代码。相反，这些主题出现在许多软件工程书籍的各个章节中。例如，Steve McConnell 的《代码大全》（微软出版社，2004 年）第八章讲述了防御性编程。Robert C. Martin 的《代码整洁之道》（Pearson，2008 年）第 7 和第八章讨论了错误处理和边界。它们是不错的起点。

网络上也有很多关于防御性编程、异常处理、日志记录、配置和工具的文章。*亚马逊构建者图书馆*（[`aws.amazon.com/builders-library/`](https://aws.amazon.com/builders-library/)）是一个特别有用的资源。

Google SRE 团队的《构建安全可靠的系统》（O’Reilly Media，2020 年）是一本宝贵的建议书，尤其是从安全角度看。Google 的《站点可靠性工程》（O’Reilly Media，2016 年）是关于站点可靠性相关事宜的经典书籍。虽然它更侧重于*写* 可操作的代码，但它仍然是一本必读书籍。它将让你对运行生产软件的复杂世界有所了解。这两本书都可以在网上免费获得，也可以印刷版购买。
