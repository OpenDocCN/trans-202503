# 第三章：与代码打交道

在法国阿尔勒有一座古老的罗马圆形剧场。它曾经为多达 20,000 人提供娱乐——战车比赛和角斗士竞技。罗马灭亡后，一个小镇就在圆形剧场的场地内建立起来。这是有道理的，因为那里有墙壁和排水系统。后来的人们可能会觉得这个设置奇怪且不方便。他们可能会批评剧场的建筑师在设计上做出的选择，导致很难将其改造成一个城镇。

代码库就像法国阿尔勒的圆形剧场。各代人编写了不同的层次并进行了修改。许多人都接触过这段代码。测试缺失或强加了过去时代的假设。需求的变化使得代码的使用方式发生了扭曲。与代码打交道很困难，这也是你必须首先面对的事情之一。

本章将向你展示如何与现有代码合作。我们将介绍导致混乱的概念—软件熵和技术债务—以便让你有一个更广泛的视角。接着，我们将提供有关如何安全更改代码的实际指导，并以避免无意中增加代码杂乱的技巧作为总结。

## 软件熵

当你浏览代码时，你会注意到它的不足。杂乱的代码是变化的自然副作用；不要因为代码不整洁就责怪开发人员。这种走向混乱的倾向被称为*软件熵*。

许多因素导致软件熵。开发人员之间误解彼此的代码或风格不同。技术栈和产品需求的变化导致了混乱（参见第十一章）。错误修复和性能优化引入了复杂性。

幸运的是，软件熵是可以管理的。代码风格和错误检测工具帮助保持代码清洁（第六章）。代码审查帮助传播知识并减少不一致性（第七章）。持续重构减少熵（参见本章后面的“代码变更”）。

## 技术债务

*技术债务*是软件熵的一个主要原因。技术债务是为了修复现有代码的不足而需要在未来做的工作。就像财务债务一样，技术债务有本金和利息。本金是需要修复的原始不足。利息则是在代码演化过程中未解决根本问题时产生的—逐渐实施越来越复杂的变通方法。随着这些变通方法的复制和加固，利息也在累积。复杂性蔓延，导致缺陷。未偿还的技术债务是常见的，遗留代码中有很多这样的债务。

你不同意的技术决策不是技术债务。你不喜欢的代码也不是。要构成债务，问题必须要求团队“支付利息”，或者代码必须有可能引发一个关键问题—一个需要紧急偿还的问题。不要滥用这个词语。频繁使用“技术债务”会削弱这一说法，使得处理重要债务变得更加困难。

我们知道债务令人沮丧，但并不全是坏事。Martin Fowler 将技术债务分为一个二维矩阵（表 3-1）。

表 3-1：技术债务矩阵

|  | **草率** | **谨慎** |
| --- | --- | --- |
| **故意的** | “我们没有时间进行设计。” | “我们现在就发布，稍后再处理后果。” |
| **无意的** | “什么是分层？” | “现在我们知道应该如何做了。” |
| 来源：[`martinfowler.com/bliki/TechnicalDebtQuadrant.html`](https://martinfowler.com/bliki/TechnicalDebtQuadrant.html) |

谨慎、故意的债务是技术债务的经典形式：在代码中已知的缺陷与交付速度之间的务实权衡。只要团队在后期有纪律地解决它，这就是一种良性的债务。

草率、故意的债务是在团队承受交付压力时产生的。“只”是一个提示，表明正在讨论草率的债务：“我们可以稍后*只*添加结构化日志记录，”或者，“*只*增加超时。”

草率、无意的债务来自于*未知的未知*。你可以通过预先记录并获取实施计划的反馈，以及进行代码审查，来减轻草率无意债务的风险。持续学习也能最大程度地减少无意的草率行为。

谨慎、无意的债务是经验增长的自然结果。有些教训只有在事后才能学到：“我们本应为没有完成注册流程的用户创建账户。市场部需要捕捉失败的注册，而现在我们不得不增加额外的代码，如果它是核心数据模型的一部分，本可以避免。”与谨慎和故意债务不同，团队并不会意识到自己正在承担债务。与无意的草率债务不同，这种类型的债务更像是学习问题领域或作为软件架构师成长的自然结果，而不是单纯因为没有做功课的结果。健康的团队使用项目回顾等实践来发现无意的债务，并讨论何时以及是否偿还。

这个矩阵中的一个重要启示是，一些债务是不可避免的，因为你无法防止无意的错误。债务甚至可能是成功的标志：项目存活了足够长的时间，变得有些杂乱无章。

### 解决技术债务

不要等到世界停止运转才修复问题一个月。相反，应该在进行过程中清理并进行小规模的重构。以小的、独立的提交和拉取请求来进行修改。

你可能会发现渐进式重构不足以解决问题——需要进行更大的改动。大型重构是一个严肃的承诺。在短期内，偿还债务会减缓功能交付，而承担更多债务会加速交付。从长远来看，情况正好相反：偿还债务加快交付，而承担更多债务会减慢交付。产品经理的激励是推动更多功能（因此也会带来更多债务）。正确的平衡高度依赖于具体的情境。如果你有大型重构或重写的建议，首先向团队阐明你的理由。以下是讨论技术债务的一个良好框架：

1.  客观地陈述情况。

1.  描述债务的风险和成本。

1.  提出一个解决方案。

1.  讨论备选方案（包括不采取行动）。

1.  权衡利弊。

以书面形式提出你的提案。不要基于价值判断来提出上诉（“这段代码又旧又丑”）。应关注债务的成本和修复它的好处。要具体，不要惊讶于如果在工作完成后你被要求展示修复的好处。

> 大家好，
> 
> 我认为是时候将登录服务拆分为两个服务了：一个负责身份验证，另一个负责授权。
> 
> 登录服务的不稳定性占我们值班问题的 30%以上。这种不稳定性似乎主要来源于身份验证和授权逻辑的交织。当前的设计使得我们很难测试所有需要提供的安全功能。我们保证客户数据的安全，而现有的登录服务使得这一承诺越来越难以实现。我还没有和合规团队沟通过，但我担心在下一次审计时他们会提出问题。
> 
> 我认为访问控制逻辑之所以被放入服务中，主要是出于方便，考虑到当时的各种时间和资源限制。这并不是基于某种总体架构原则的决定。然而，现在处理这个问题意味着需要重构登录服务，并将授权代码移出——这是一个大项目。不过，我认为解决稳定性和正确性问题是值得的。
> 
> 减少工作量的一种方式是依赖后台团队的授权服务，而不是创建我们自己的服务。我认为这不是正确的方法，因为他们解决的是不同的用例。我们处理的是面向用户的授权，而他们处理的是系统间授权。但也许有一种优雅的方式可以同时处理这两者。
> 
> 你怎么看？
> 
> 谢谢！
> 
> Johanna

## 更改代码

更改代码不像在一个全新的代码库中编写代码。你必须在不破坏现有行为的情况下进行更改。你必须理解其他开发人员的思路，遵循现有的风格和模式。并且在进行更改时，必须逐步改善代码库。

代码更改技巧大致相同，无论是添加新功能、重构、删除代码还是修复 bug。事实上，不同类型的更改通常是结合进行的。在添加新功能时，重构——改善内部代码结构而不改变功能——常常是必要的，因为它使得添加功能变得更容易。在修复 bug 时，代码也会被删除。

修改大型现有代码库是一项多年来——甚至是几十年——磨炼出来的技能。以下是一些入门技巧。

### 使用遗留代码更改算法

在他的书《*与遗留代码有效工作*》（Pearson，2004）中，Michael C. Feathers 提出了以下安全修改现有代码库的步骤：

1.  确定更改点。

1.  找到测试点。

1.  打破依赖关系。

1.  编写测试。

1.  进行更改并重构。

将前四个步骤视为在第五步之前清理空间并在田地周围建立围栏。在围栏建立之前，野生动物可能会进入并破坏你的植物。找到需要修改的代码，并弄清楚如何对其进行测试。如有需要，重构代码以便进行测试。添加验证现有行为的测试。一旦围栏建立，且你更改点周围的区域得到了很好的保护，就可以在内部进行更改。

首先，使用第二章中的策略定位需要修改的代码（*变更点*）：阅读代码、实验并提出问题。在我们的园艺比喻中，变更点就是你将种下种子的地方。

一旦找到代码，找到它的测试点。*测试点*是你想要修改的代码的入口点——测试调用并注入的区域。测试点展示了你在做任何更改之前的代码行为，你需要使用这些点来测试你自己的更改。

如果幸运的话，测试点可能很容易访问；如果不幸，你需要打破依赖才能访问它们。在这个背景下，依赖不是指库或服务依赖；而是测试你的代码所需的对象或方法。*打破依赖*意味着改变代码结构，使其更容易进行测试。你需要修改代码，以便将测试挂接上并提供合成输入。这些更改*不能*改变行为。

重构以打破依赖是工作中最具风险的部分。它甚至可能涉及修改已有的测试，这会让检测行为是否发生变化变得更加困难。采取小步伐，在这一阶段不要引入任何新功能。确保你能够快速运行测试，这样你就能频繁运行测试。

有多种技术可以用来打破依赖，包括以下几种：

+   将一个大型复杂方法拆分成多个较小的方法，这样就可以独立地测试各个功能模块。

+   引入接口（或其他间接方式）为测试提供一种简单的实现复杂对象的方法——虽然不完整，但足以进行测试。

+   注入显式控制点，允许你模拟那些难以控制的执行方面，例如时间的流逝。

不要为了让测试更容易而改变访问修饰符。将私有方法和变量设置为公共可以让测试访问代码，但这也破坏了封装——一种糟糕的解决办法。破坏封装会增加你需要在项目生命周期内保证的行为范围。我们将在第十一章中进一步讨论这个问题。

在重构和打破依赖的同时，增加新的测试来验证旧的行为。在迭代过程中频繁运行测试套件，包括新的和旧的测试。考虑使用自动化测试工具生成能够捕捉现有行为的测试。有关测试编写的更多内容，请参见第六章。

一旦断开了依赖并且有了好的测试，就该进行“真正”的更改了。添加验证更改的测试，然后重构代码以进一步改进其设计。你可以大胆地进行更改，因为你已经确保了代码的安全边界。

### 让代码比你找到时更干净

网络上的编码箴言经常引用童子军原则：“永远让营地比你找到时更干净。” 就像营地一样，代码库是共享的，继承一个干净的代码库是件好事。将同样的理念应用到代码上——让代码比你找到时更干净——将有助于让你的代码随着时间的推移变得更好。不需要做一个“停止全世界”的重构项目。重构的成本将通过许多更改来摊销。

在修复漏洞或添加功能时，清理相邻的代码。不要特意去寻找脏代码，要顺便清理。尽量保持代码清理的提交与更改行为的提交分开。分开提交可以让你在回滚代码时，不会丢失清理代码的提交。小的提交也使得更容易进行代码审查。

重构并不是清理代码的唯一方法。有些代码就是臭。逐步清理有异味的代码。*代码异味*是指那些不一定有错误，但使用已知会引发问题的模式的代码；它“闻起来怪怪的”。考虑以下 Java 代码片段：

```
if (a < b) a += 1;
```

这个代码片段完全正确。在 Java 中，单个语句可以跟随一个条件，而无需将其包含在大括号中。然而，这段代码“有异味”，因为它使得接下来很容易犯下以下错误：

```
if (a < b) a += 1; a = a * 2;
```

与 Python 不同，Java 忽略缩进，依赖大括号来分组语句。因此，无论`if`条件如何，`a`都会被加倍。如果在原始代码编写时使用了包围`a += 1;`的可选大括号，这个错误会更难以发生。缺少大括号是一种代码异味。

许多代码检查工具和代码质量工具会检测到这个问题，以及其他代码异味，如非常长的方法或类、重复的代码、过多的分支或循环，或者参数过多。更微妙的反模式则更难识别和修正，需要工具和经验的帮助。

### 做增量更改

重构通常有两种形式。第一种是一个改变世界的大规模代码审查，一次更改数十个文件。第二种是一个混乱的拉取请求，同时包含了重构和新功能。这两种更改都很难审查。合并提交会使得在不影响你希望保留的重构的情况下回滚功能更改变得困难。相反，保持你的重构更改小巧。为代码更改算法中的每一个步骤单独发起拉取请求（参见前面的“使用遗留代码更改算法”）。如果更改很难跟踪，请使用较小的提交。最后，在你进行重构狂潮之前，先获得团队的支持。你正在更改团队的代码，他们也有发言权。

### 关于重构要务实

并不总是明智的选择进行重构。存在截止日期和相互竞争的优先级。重构需要时间。你的团队可能决定忽略重构机会以发布新特性。这些决策会增加团队的技术债务，但可能是正确的决定。重构的成本也可能超过它的价值。正在被替换的旧的、已弃用的代码不需要重构，低风险或很少修改的代码也不需要重构。关于何时进行重构，要务实。

### 使用 IDE

*集成开发环境（IDEs）*在高级程序员中有一种偏见；他们认为依赖编辑器的“帮助”是一种弱点，并迷恋 Vim 或 Emacs——“更文明时代的优雅武器。”这完全是胡说八道。利用现有的工具。如果你的编程语言有好的 IDE，就使用它。

IDE 在重构时特别有帮助。它们具有重命名和移动代码、提取方法和字段、更新方法签名等工具，执行其他常见操作。在大型代码库中，简单的代码操作既繁琐又容易出错。IDE 会自动遍历代码并更新它，以反映新的更改。（为了避免收到讨厌的邮件：我们知道也可以通过 Vim 和 Emacs 实现这些功能。）

只是不要过于沉迷其中。集成开发环境（IDEs）使得重构变得如此简单，以至于一些简单的调整就能引发大量的代码审查。人类仍然需要审查你自动化的 IDE 更改。自动重构也有其局限性。如果通过反射或元编程调用已重命名的方法，可能不会调整到该方法的引用。

### 使用版本控制系统最佳实践。

更改应提交到*版本控制系统（VCS）*，例如 Git。版本控制系统跟踪代码库的历史记录：谁做了每个更改（*提交*）以及何时进行的更改。每个提交也会附带*提交信息*。

在开发过程中要尽早且频繁地提交更改。频繁提交能展示代码如何随着时间变化，让你撤销更改，并充当远程备份。然而，频繁提交常常导致像“哎呀”或“修复坏的测试”这样的无意义信息。在快速编写代码时，使用简短的提交信息并没有错，但对其他人来说毫无价值。在提交更改进行审查之前，重基你的分支，压缩你的提交，并写一个清晰的提交信息。

你的压缩提交信息应遵循团队的约定。为提交信息添加问题 ID 是常见做法：“[MYPROJ-123] 使后端与 Postgres 兼容。”将提交与问题关联起来可以帮助开发人员找到更多的上下文信息，并便于脚本编写和工具使用。如果没有建立规则，请遵循 Chris Beams 的建议（[`chris.beams.io/posts/git-commit`](https://chris.beams.io/posts/git-commit)）。

+   用空行将主题与正文分开。

+   将主题行限制为 50 个字符。

+   将主题行的首字母大写。

+   不要在主题行末尾加句号。

+   在主题行中使用命令式语气。

+   将正文限制在 72 个字符以内。

+   使用正文解释是什么和为什么，而不是如何。

Chris 的帖子值得一读；它描述了良好的习惯。

## 避免陷阱

现有的代码带有负担。库、框架和模式已经到位。一些标准可能会让你烦恼。虽然想要使用干净的代码和现代的技术栈是很自然的，但重写代码或忽视标准是危险的。重写代码如果做得不好可能会使代码库不稳定，而重写的代价是牺牲新功能。编码标准保持代码的可读性；偏离这些标准会让开发者很难工作。

在他的书《*困难的事情就是困难的事情*》（Harper Business，2014）中，Ben Horowitz 说道：

> 任何技术创业公司必须做的首要事情，是构建一个在做某事上至少比当前主流方式好十倍的产品。提升两三倍的效果是不够的，无法让人们快速且大规模地切换到新事物。

Ben 说的是创业产品，但同样的观点也适用于现有代码。如果你想重写代码或偏离标准，你的改进必须比原来好一个数量级。小的改进不够——代价太高。大多数工程师低估了约定的价值，而高估了忽视它的价值。

小心重写代码、违背约定或添加新技术到技术栈中。将重写留到高价值的场景中。尽可能使用无聊的技术。即使你不同意某个约定，也不要忽视它，避免分叉代码。

### 使用无聊的技术

软件是一个快速发展的领域。新的工具、语言和框架层出不穷。与在线上的新技术相比，现有的代码显得过时。然而，成功的公司之所以使用较旧的库和模式，是有原因的：成功需要时间，而在技术上不断更迭只会让人分心。

新技术的问题在于它不够成熟。在他的演讲《选择无聊技术》中，Dan McKinley 指出：“无聊技术的失败模式是人们熟知的” ([`boringtechnology.club/`](http://boringtechnology.club/))。所有技术都会失败，但旧的东西以可预测的方式失败。新的东西则以意想不到的方式失败。缺乏成熟意味着更小的社区、更少的稳定性、更少的文档和更少的兼容性。新技术在 Stack Overflow 上的答案也更少。

有时，新技术能解决你公司面临的问题，但有时它也无法解决。需要纪律性和经验来辨别何时使用新技术。收益必须超过成本。每一次使用新技术的决策都花费一个“创新代币”，这是 Dan 提出的概念，表示在新技术上的投入可以用来开发创新的新功能。公司拥有的这种代币数量是有限的。

为了平衡成本和收益，将你的创新代币花费在那些服务于公司高价值领域（核心竞争力）的技术上，解决广泛的使用案例，并且能够被多个团队采纳。如果你的公司专注于抵押贷款的预测分析，并且拥有一支数据科学博士团队，那么采用最前沿的机器学习算法是有意义的；如果你的公司只有 10 名工程师并且正在开发 iOS 游戏，那么使用现成的技术就足够了。新技术的好处更大，如果它能让你的公司更具竞争力。如果它能够被广泛采纳，更多的团队将受益，你的公司总体上需要维护的代码也会减少。

为一个项目选择新的编程语言有着特别深远的后果。使用一种新的语言会将整个技术栈引入到你公司的生态系统中。新的构建系统、测试框架、IDE 和库都需要得到支持。一种语言可能有巨大的优势：某种特定的编程范式、实验的便利性，或者消除某些类型的错误。语言的优势必须与其权衡相平衡。如果使用一个新的框架或数据库需要一个创新代币，那么使用一种新的语言则需要三个。

新语言周围的生态系统的成熟度特别关键。构建和打包系统是否经过深思熟虑？IDE 支持如何？重要的库是否由有经验的开发者维护？是否有测试框架可用？如果需要，你能支付支持费用吗？你能雇佣到具有相关技能的工程师吗？这门语言容易上手吗？这门语言的性能如何？语言的生态系统能与公司现有工具集成吗？这些问题的答案和语言本身的特性一样重要。数十亿美元的公司都是在平凡的语言上建立起来的。伟大的软件是在 C、Java、PHP、Ruby 和 .NET 等语言中编写的。除非这门语言已经过时，否则它的年龄和缺乏热度几乎不能作为反对的理由。

### 不要走“叛逆”路线

不要因为不喜欢公司的（或行业的）标准而忽视它们。编写不符合标准的代码意味着它无法与公司的环境兼容。持续集成检查、IDE 插件、单元测试、代码规范检查、日志聚合工具、度量仪表盘和数据管道等都已经集成在内。你定制的方法将会成本高昂。

你的偏好可能真的更好。然而，仍然不建议选择“叛逆”路线。在短期内，还是按照大家的做法去做。试着理解标准方法背后的原因。它可能是在解决一个不明显的问题。如果你无法找出一个合理的原因，可以询问周围的人。如果还是找不到答案，和你的经理以及拥有该技术的团队展开对话。

在改变标准时，需要考虑许多方面：优先级、所有权、成本和实施细节。说服一个团队放弃他们拥有的东西并不容易。会有很多不同的意见。你需要保持务实。

与重写类似，改变一个广泛采用的东西是缓慢的。这并不意味着这件事不值得做。如果你通过正确的渠道处理，好事会降临到你身上。你将接触到组织的其他部门，这对建立人脉和晋升非常有益。你还将成为新解决方案的早期采用者——你将是第一个使用新事物的人。通过提供反馈，你会得到你想要的。但不要从日常工作中分心，并确保你的经理知道你在花时间做这些项目。

### 不要在没有提交上游的情况下进行 Fork

*Fork*是另一个源代码库的完整独立副本。它有自己的主干、分支和标签。在像 GitHub 这样的代码共享平台上，fork 是在提交拉取请求到上游仓库之前使用的。Fork 让没有写入权限的用户也能为项目做出贡献——这是一种正常且健康的做法。

没有意图将更改贡献回去的 fork 行为是不太健康的。当项目的方向出现分歧、原项目被放弃，或者难以将更改合并到主代码库时，就会发生这种情况。

维护公司内部的 fork 尤其具有隐蔽性。开发人员会相互告知，他们会“稍后”贡献更改回去。这种情况很少发生。没有贡献到上游的小调整随着时间的推移积累，最终你会运行完全不同的软件。功能和 bug 修复越来越难以合并到上游。团队发现他们实际上已经隐性地承担了维护整个项目的责任。一些公司甚至 fork 他们自己的开源项目，因为他们没有将内部更改贡献回去！

### 抵制重写的诱惑

重构工作常常演变成彻底的重写。重构现有代码是令人畏惧的；那为什么不直接丢掉旧系统，重新从头开始重写一遍呢？把重写当作最后的手段。这是多年经验所获得的宝贵建议。

一些重写是值得做的，但许多重写是不值得的。要诚实地对待你对重写的渴望。因为不喜欢某种语言或框架而重写并不是一个好的理由。重写应该只有在收益超过成本的情况下进行；它们是有风险的，而且成本很高。工程师们总是低估了重写所需的时间。尤其是迁移是糟糕的。数据需要迁移，上游和下游系统需要更新。这可能需要数年，甚至几十年。

重写并不总是更好。在他著名的《*人月神话*》一书（Addison-Wesley Professional，1995 年）中，Fred Brooks 创造了“第二系统综合症”这一术语，描述了简单系统如何被复杂系统取代的现象。第一个系统的范围是有限的，因为其创作者并不了解问题领域。这个系统完成了工作，但它笨拙且有限。开发者现在已经积累了经验，他们清楚地看到自己当初的错误。于是他们着手开发第二个系统，想要把所有聪明的点子都融入其中。新的系统设计得很灵活——一切都是可配置和可注入的。不幸的是，第二个系统通常会变成臃肿的杂乱无章。如果你打算重写一个系统，要非常小心避免过度扩展。

## 做的事与不做的事

| **做的事** | **不做的事** |
| --- | --- |
| **做** 逐步进行重构。  | **不做** 过度使用“技术债务”这个术语。  |
| **做** 将重构提交与功能提交分开。  | **不做** 为了测试目的将方法或变量设为公共的。  |
| **做** 保持修改尽量小范围。  | **不做** 做个语言上的挑剔者。  |
| **做** 留下比原本更干净的代码。  | **不做** 忽视公司标准和工具。  |
| **做** 使用简单的技术。  | **不做** 在没有将代码提交上游的情况下分叉代码库。  |

## 升级

我们广泛使用 Michael C. Feathers 的《*与遗留代码高效工作*》（Pearson，2004 年）一书。这本书的细节远远超过我们在几页纸上能表达的。如果你发现自己在处理庞大且凌乱的代码库时，我们推荐你阅读 Michael 的这本书。你或许也会发现 Jonathan Boccara 的书有帮助：《*遗留代码程序员工具箱*》（LeanPub，2019 年）。

Martin Fowler 写了大量关于重构的文章。如果你想快速阅读，他的博客是获取内容的好地方。如果你对重构的经典书籍感兴趣，他写的《*重构：改善既有代码的设计*》（Addison-Wesley Professional，1999 年）是一本必读之作。

最后，我们必须提到 Fred Brooks 的《*人月神话*》（Addison-Wesley Professional，1995 年）。这是每个软件工程师都应该读的经典书籍。它讨论了软件项目在实际操作中如何运作。你会惊讶地发现，这本书与你在工作中的日常经历有着如此紧密的联系。
