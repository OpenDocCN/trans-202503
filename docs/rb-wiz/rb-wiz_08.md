# 第九章 继承红宝石的魔法

# 她陛下的珍奇动物园

国王、鲁本和斯嘉丽沿着地下通道向城堡的方向快速奔跑。

“还要多远？”鲁本气喘吁吁地问。

“我不确定，”国王说道，“但 Wherefore 告诉我们尽可能走远，然后我们就能到达神秘的管道。”他思索了一下。“不过应该不会太远，”他最终说道，“这是安布罗斯洞窟，虽然它们延伸至整个王国的地下，但我知道哈尔多可以在几分钟内穿越城堡和比松树林更远的地方。”

“没错！哈尔多熟悉这些隧道，”斯嘉丽说道。她沉默地跑了几分钟。“如果……会怎样……”她开口说道。

“什么如果？”鲁本问道。

“那么，如果引发这一切麻烦的人是哈尔多让进来的呢？或者如果哈尔多是*他们中的一员*呢？”

“闭嘴！”国王说道，“哈尔多从小时候就跟着我，他绝不会做任何伤害我们或这个王国的事！”

“我们应该考虑所有可能性，”斯嘉丽说道。

“即便如此，”国王说道，“所有嫌疑人都是无辜的，直到我们证明他们有罪。如果我们运气好，等我们到达城堡时，能当场抓到这些恶棍！”

“随时都会的，”鲁本说道。“看！”

前方，狭窄的隧道展开成一个宽阔的洞窟。国王、斯嘉丽和鲁本跑进开阔的空间，然后停下片刻，喘着气。

“就是这里，”国王说道，“城堡下方的地下室下面！现在我们只需要找到神秘的管道，然后爬回到我的皇家书房。”

“就是这里！”斯嘉丽说道。在黑暗中，他们勉强看见远角落里神秘管道的轮廓。

三人走到管道底部，管道正在轻轻地咕噜作响。

“现在怎么样？”鲁本问道。“神秘的管道里满是水！我们怎么爬上去？”

“我们之前打开了那个 Flowmatic 什么的，”斯嘉丽说道，“我们可以把它关掉！”她在管道底部摸索，直到找到那个熟悉的计算装置的方形形状，然后打开了它的盖子。IRB 提示的光芒照亮了他们的脸。

“对了！”国王说道，“我们之前改了什么变量？”

“`flowmatic_on`！”鲁本回答道。

斯嘉丽迅速在计算装置上输入：

```

>> **flowmatic_on = false**
=> false

```

随着一声缓慢的*booooop*和*咕噜咕噜*的声音，神秘的管道关闭并排空了。

“做得好，斯嘉丽！”国王说道，他走到管道的另一侧。他抓住一个突出的金属轮子，转动了几下。轮子转了好几圈，随着一声空洞的*砰*，它连接的门慢慢打开了。

“进入神秘的管道！”国王喊道，三人都爬了进去。

鲁本直视着管道顶部，眯着眼睛。“我连上面的光都看不见！”他说道，“这个管道太大了！哈喽！”他喊道，神秘管道回响着：*哈喽！ 喽！ 哦！*

“爬上去得费时费力，如果我们能做到的话！”斯嘉丽说道。她想了想。“我或许有个主意。”她转向鲁本和国王。“你们信任我吗？”她问道。

“凭我的生命！”国王说道。

“到终点！”鲁本说道。

“好吧，”斯嘉丽说道。“屏住呼吸！”她伸手到神秘管道旁边的计算机设备上，开始输入：

```

>> **flowmatic_on = true**

```

她猛地把金属门关上，瞬间，管道里充满了水。

几秒钟，三人漂浮在神秘管道底部，屏住呼吸。接着，整个管道微微颤动，随着一声深沉的*嗖*，水流的冲击力将国王、斯嘉丽和鲁本直接推了上去！

![没有说明的图片](img/httpatomoreillycomsourcenostarchimages2160039.png.jpg)

几秒钟后，他们三人开始放慢速度，发现自己漂浮在神秘管道狭窄顶部仅几英寸的地方。国王伸手按下管道门的门闩，随着一阵水流，三人跌跌撞撞地从门口掉进了国王的皇家书房。

“天才！绝对是天才！”国王急促地说道。

“谢谢你，”斯嘉丽说着，微微鞠了一躬。“但是我们得赶紧去找皇后！你知道她在哪儿吗？”

“她应该刚从皇家陛下的 Ruby 黑客大会回来，”国王说道，“所以我想她现在应该在她的皇家办公室里。走吧！”说完，他冲出了房间。

Ruby 和斯嘉丽紧随其后。“皇后参加了 Ruby 大会？”斯嘉丽一边跑上楼梯一边问。

“的确如此！”国王说道。“你可能会惊讶地发现，虽然我对这些 Ruby 的事情还很新，但我的妻子可是个不折不扣的黑客。”

“太棒了！”鲁本说道。“也许她能帮我们修好这些 Ruby 故障，抓住那些搞破坏的坏人。”

“我希望如此。啊！我们到了，”国王说道，急停在一扇带有金色把手的巨大木门前。

他同时拉下两个把手，猛地推开门，急匆匆地冲了进去。

皇后正坐在一把高背椅上，专心致志地敲打着计算机设备。

“他们试图闯入我的计算机设备！”皇后说道。“这简直不可理喻！”

“他们是谁？”斯嘉丽和鲁本齐声问道，跟着国王进入皇后的皇家办公室。

“我不知道！”皇后一边打字一边说道。“他们有四个人，我抓到他们在我的计算机设备前，试图破解我的密码。幸运的是，我对安全性要求非常严格。”

“她确实是，”国王说道，一边拧干他那蓬松的白胡子。“她甚至不让我在网上买橡皮糖！”

“有充分的理由，”皇后说道，停下了打字。“上次我让你做这事时，你竟然把一大笔钱给了一个自称是橡皮糖国王的人！”她停顿了一下，看了看斯嘉丽和鲁本。“我相信我们还没见过面，”她说道。“你们是？”她上下打量了他们三人。“你们为什么都这么湿？”

“我是鲁本，”鲁本说道，“这是斯卡雷特。我们在帮助国王找出是谁让 Ruby 出现故障的，我们从深红松树林一路跑来，游过神秘管道来帮助处理这件事！”

“好吧，你来对地方了！”女王说道。“如果这事我不做到底，那就没天理了。”她又开始打字。

![没有说明文字的图片](img/httpatomoreillycomsourcenostarchimages2160041.png.jpg)

“你有好好观察过他们吗？”斯卡雷特问道。“有没有什么线索？你看到或听到什么能帮助我们抓住他们的吗？”

“我没看到他们的脸，”女王说道，“但是我听到他们试图破解我的计算设备密码。他们有四个人——听起来是两个男孩和两个女孩。我从 Hacktastic Ruby 大会早早回来，想着试试我学到的一些 Ruby 技巧，当我走进办公室时，正好抓到他们作案！我大声喊叫他们投降，他们就跑了，我立刻派卫兵去追他们。与此同时，我一直在努力增加计算设备的安全性，确保它能完全防御攻击。”

“他们从你的计算设备上得到了什么吗？”斯卡雷特问道。

“谢天谢地，不是，”女王说道。“他们没拿到我的密码，但如果他们拿到，我们就麻烦大了。凭那个，他们可以不受任何限制地访问王国里的任何系统！”

“这些坏蛋越来越猖狂了！”国王在女王的办公室里来回踱步。“我们得尽快抓住他们，不能让他们再作恶。下次我们可能就不这么幸运了。”

女王点了点头。“我已经指示卫兵将任何他们抓到的嫌疑人直接带来我们这里审问，”她说道。“与此同时，我已经升级了我的计算设备的所有安全措施。剩下的就是更新我的一些 Ruby 程序，使它们也更安全！”

“Ruby！”鲁本说道。“那正好是我们的专长。我们能帮忙吗？”他问道。

女王微笑着说道。“那真是太好了，”她说道。“虽然我在不少编程语言上都有些造诣，但在 Ruby 上我还是个新手。”她在椅子上挪了挪，鲁本和斯卡雷特爬到她旁边坐下。

“首先，首先，”女王说道，“你们知道怎么创建 Ruby 类吗？”

# 复习一下类

“我想是的，”鲁本说道。“我可以创建任何我想要的类吗？”女王点了点头，鲁本在她的计算设备上输入了代码：

```

>> **class Animal**
>>   **attr_accessor :name**
>>
>>   **def initialize(name, legs=4)**
>>     **@name = name**
>>     **@legs = legs**
>>   **end**
>> **end**
=> nil

```

“明白了！”女王说道。“你定义了一个 `Animal` 类。你使用了 `attr_accessor` 来自动生成一个方法，用来访问动物的 `name`，而 `initialize` 方法则在每次创建新动物时，设置动物的 `@name` 和 `@leg` 数量。”

“没错！”鲁本说道。“如果我们用 `Animal.new` 创建一个动物，但没有指定它的腿数，它默认会是 `4` 条腿。”

女王点了点头。“这对我来说很有道理。你们可以开始创建几个动物试试。”

鲁本继续打字：

```

➊ >> **monkey = Animal.new('George', 2)**
  => #<Animal:0x00000104953940 @name="George", @legs=2>

➋ >> **monkey.name = 'Kong'**
  => "Kong"

➌ >> **dog = Animal.new('Bigelow')**
  => #<Animal:0x00000104950178 @name="Bigelow", ➍@legs=4>

```

“太棒了！在 ➊，我们创建了 `monkey`，一个 `Animal` 类的实例，并将它的名字设为 `'George'`，腿数为 `2`。接下来，在 ➋，我们将 `monkey` 的名字改为 `'Kong'`，展示了我们的 `attr_accessor` 让我们不仅能读取*还*能更改名字。

“最后，在 ➌，我们创建了 `Animal` 类的第二个实例 `dog`，名字为 `'Bigelow'`。由于我们没有为 `dog` 指定腿数，它默认会有四条腿，就像在 ➍ 所显示的返回值那样。”

## 一些类

女王思考了一下。“是的，这样挺好。那么，”她接着说，“想象一下，如果我们不仅仅把 `monkey` 和 `dog` 当作 `Animal` 类的实例，而是想要将 `Monkey` 和 `Dog` 作为单独的类来处理。我们该怎么做呢？”

“嗯，我们可以这样做，”Ruben 说道，他开始输入：

```

>> **class Monkey**
>>   **attr_accessor :name**
>>
>>   **def initialize(name)**
>>     **@name = name**
>>     **@legs = 2**
>>   **end**
>> **end**
=> nil

```

“正是如此，”女王说道。“这定义了一个 `Monkey` 类，猴子类创建的猴子会有 `@name` 和两个 `@leg`。`attr_accessor` 还会自动为每只猴子创建一个 `name` 方法，让我们可以获取它的名字。为了从类中创建一只新的猴子，我们使用 `Monkey.new` 并传入它的名字作为字符串值。像这样！”她在计算机装置上输入：

```

>> **monkey = Monkey.new('George')**
=> #<Monkey:0x00000104bdf3a8 @name="George", @legs=2>

>> **monkey.name**
=> "George"

```

“我们也可以对 `Dog` 类做同样的事情，”Ruben 继续说道。“我们知道几乎每只狗都有四条腿，所以它的结构会和 `Monkey` 类一样，只是类名不同，`@leg` 的数量会是 `4`。”他说着在计算机装置上输入：

```

>> **class Dog**
>>   **attr_accessor :name**
>>
>>   **def initialize(name)**
>>     **@name = name**
>>     **@legs = 4**
>>   **end**
>> **end**
=> nil

```

“就像我们可以通过 `Monkey.new` 创建新的猴子，并传入一个字符串作为猴子的名字一样，我们也可以通过 `Dog.new` 创建新的狗狗，并传入一个字符串作为狗的名字！”Ruben 说道。

```

>> **dog = Dog.new('Bigelow')**
=> #<Dog:0x00000104be3d18 @name="Bigelow", @legs=4>

>> **dog.name**
=> "Bigelow"

```

“这肯定是创建一对类的方式之一，”女王说道，“但看起来你为 `Monkey` 和 `Dog` 类写了很多重复的代码。”

“没错，”Ruben 说道。“这样可以吗？”

## 继承与 DRY 代码

“嗯，”女王说道，“每当你发现自己写了重复的代码时，你应该问问自己是否*非得*这样做。好的代码——不像我丈夫这样，”她忍住笑意说道，国王正在从他华丽的王袍袖子里倒出水，“——应该是 *DRY* 的。”

“我知道那个！”国王说道，一边将水滴从他的弦上抖掉并放回口袋。“它代表 *不要* *重复* *自己*。”

“他知道这个，因为他总是重复自己，”女王低声对 Scarlet 和 Ruben 说道。“但是，是的，”她接着说，“如果你避免在代码中重复自己，就能节省大量时间！而且，如果你需要修改某个部分，你只需要修改 *一个* 地方，而不是多个地方。”

“我喜欢这个！”Ruben 说道，“但我们怎么才能让我们的类代码更 *DRY* 呢？”

“通过 *继承*，”女王说道。

“继承！”Scarlet 说道。“我好像以前听说过这个，但不太清楚它是什么意思。”

“我来给你们展示，”女王一边解释一边在计算装置上敲打着。“我们已经创建了一个名为`Animal`的类。假设我们可以使用这个类作为创建`Monkey` *和*`Dog`类的方式呢？”

```

>> **class Dog < Animal**
>>   **def bark**
>>     **puts 'Arf!'**
>>   **end**
>> **end**
=> nil

```

“`class Dog < Animal` 这一部分的意思是`Dog`类*继承自*`Animal`类。它对 Ruby 说：‘创建一个新的名为`Dog`的类，它知道如何做`Animal`类做的一切，’”女王说道。“然后我们只需要像平常一样添加一个方法。在这里，我为`Dog`类添加了一个`bark`方法，因为狗会叫。”她卷起了袖子。

“这里有一个惊人的地方：因为`Dog`继承自`Animal`，新的狗类可以做任何动物能做的事，*并且*还能够做狗能做的事。它们会有一个`name`方法和默认的四条腿，并且知道如何`bark`！”

```

>> **dog = Dog.new('Bigelow')**
=> #<Dog:0x00000104c89218 @name="Bigelow", @legs=4>

>> **dog.name**
=> "Bigelow"

>> **dog.bark**
Arf!
=> nil

```

“令人震惊！”国王说道。

“不是吗？”女王说道。“这也意味着，我们可以通过再次从`Animal`类继承，而不必重新输入所有关于`Monkey`类的定义。因为我们从`Animal`继承，我们得到了`name`方法和默认的`@legs`值为`4`，*而且*我们还会得到我专为猴子添加的这个新的`make_sounds`方法。”

```

>> **class Monkey < Animal**
>>   **def make_sounds**
>>     **puts 'Eeh ooh ooh!'**
>>   **end**
>> **end**
=> nil

```

“现在我们可以创建一个有名字和两条腿的新猴子了。不仅可以通过我们从`Animal`继承来的`name=`方法改变它的名字，还可以`make_sounds`！”

“我们可以获取名字并更改它吗？”Ruben 问道。

女王点了点头。“记住，我们是从`Animal`继承的，而`Animal`有`attr_accessor :name`。这会自动创建一个`name`方法，用于获取名字，还有一个`name=`方法，用于设置名字。明白了吗？”

```

>> **monkey = Monkey.new('George', 2)**
=> #<Monkey:0x00000102deaed8 @name="George", @legs=2>

>> **monkey.name = 'Oxnard'**
=> "Oxnard"

>> **monkey.make_sounds**
Eeh ooh ooh!
=> nil

```

“哇！”Scarlet 说道，“这太神奇了——`monkey`和`dog`都有各自的方法，但它们也可以做任何`Animal`能做的事！”

![没有标题的图片](img/httpatomoreillycomsourcenostarchimages2160043.png.jpg)

“这就是继承如此美妙的原因！”女王说道。“考虑到我们之前的`Animal`类，它有`attr_accessor`用于`:name`，并且有一个`initialize`方法来设置`@name`和`@legs`实例变量，我们可以创建两个新的类，这些类继承了这些信息，并添加一些新内容——比如为`Dog`实例添加一个`bark`方法，为`Monkey`实例添加一个`make_sounds`方法。”

“Ruby 中的继承就像现实生活中的继承一样，”女王继续说道。“就像你可能继承了你父亲的眼睛颜色或你母亲的数学才能，Ruby 中的对象也可以继承其他对象的信息和方法。”

“哦！”Ruben 说道。“所以我们不仅可以使用类来创建许多相似的对象，避免编写额外的代码，我们还可以编写从其他类借用代码的类？”

“说得对，”女王说道。“如果两个类之间有我喜欢称之为‘is-a’关系，比如‘猴子*是*一种动物’或者‘狗*是*一种动物’，我们可能会在代码中使用继承。”

“但是`Dog`类永远不会继承自`Monkey`类，”Scarlet 说，“因为狗*不是*猴子的一种。”

“没错，”女王答道。

“你能再展示一下语法吗？”Scarlet 说。“这是个好技巧，我想记住它。”

# 子类和父类

“当然可以，”女王回答。“当你有一个类继承自另一个类时，你使用`class`关键字，就像往常一样。然后你写下要继承的类的名称，我们称之为*子类*或*子类*，然后是`<`。你可以把那个小小的`<`看作是箭头的尖端，意思是‘把右边类的所有能力和特性带入左边的类！’最后，你在`<`的右边写下你要继承的类的名称，这就是我们所说的*父类*或*父类*。最后，你可以像平常一样定义任何新的方法。它看起来像这样，”她说着并敲击键盘：

super_and_subclass.rb

```

➊ class MySuperclass
    def say_hello
      puts 'Hello!'
    end
  end

➋ class MySubclass < MySuperclass
    def say_goodbye
      puts 'Goodbye!'
    end
  end

```

“这里我们有两个类，`MySuperclass`和`MySubclass`，”女王解释道。“`MySubclass`在第➋行继承自`MySuperclass`，因此`MySubclass`的实例不仅拥有在`MySubclass`类中定义的`say_goodbye`方法，而且还可以使用它从`MySuperclass`继承的`say_hello`方法！让我们看看当我们创建一个新的`MySubclass`实例时会发生什么。”

```

>> **load 'super_and_subclass.rb'**
=> true

>> **subby = MySubclass.new**
=> #<MySubclass:0x00000104a4c478>

>> **subby.say_hello**
Hello!
=> nil

>> **subby.say_goodbye**
Goodbye!
=> nil

```

“我通过`MySubclass.new`创建了一个名为`subby`的`MySubclass`实例，”女王说道。“正如我承诺的那样，`subby`可以使用在`MySubclass`中定义的`say_goodbye`方法，也可以使用在`MySuperclass`中定义的`say_hello`方法，因为`MySubclass`继承自`MySuperclass`，因此它可以做任何`MySuperclass`能做的事。”

“谢谢！”Scarlet 说，“我现在明白了。”她看着屏幕几秒钟。“一个类可以继承多个其他类吗？”她问道。

“唉，不行，”女王说。“你只能在`<`的左边放一个类名，在右边放一个类名。然而！”她继续说道，“*确实*有一个 Ruby 技巧，可以让你将多个类的行为混合到一个类中，我们稍后会讲到。”

“好的，”Ruben 说，“但是如果你想让你的子类有一个与父类不同版本的方法呢？”

## 覆盖方法：海盗也是人

“现在*这个*，我们可以做到了，”女王说。“任何子类都可以在任何时候覆盖它从父类继承的方法。让我们来看看。我们会创建一个名为`Person`的父类和一个名为`Pirate`的子类，每个类都有一个`speak`方法。当然，海盗和普通人的说话方式可不太一样，对吧？”Scarlet 和 Ruben 点点头。“所以，”女王继续说道，“这两个`speak`方法会不同。”她在计算设备上敲入了代码：

pirates_and_people.rb

```

➊ class Person
    attr_reader :name

    def initialize(name)
      @name = name
    end

    def speak
      puts 'Hello!'
    end
  end

➋ class Pirate < Person
    def speak
      puts 'Arr!'
    end
  end

```

“从 ➊ 开始，我定义了`Person`类并添加了`attr_reader :name`，这样我们就能够获取和修改任何`Person`实例的名字，”女王说道。“`initialize`方法将`name`设置为我们在调用`Person.new`时传入的字符串，而`speak`方法只会打印`'Hello!'`。”

“到目前为止我跟上了！”国王说道。

“接下来，在 ➋ 处，我定义了`Pirate`类继承自`Person`类，因此`Pirate`实例将能够执行`Person`实例能够执行的任何操作，”女王说道。“但是！我为`Pirate`类定义了自己的`speak`方法，打印出`'Arr!'`。我们稍后会看看它是如何工作的。首先，让我们创建每个类的一个实例，确保我们能够顺利创建它并获取它的名字。”

```

>> **load 'pirates_and_people.rb'**
=> true

>> **esmeralda = Person.new('Esmeralda')**
=> #<Person:0x00000104bfaa90 @name="Esmeralda">

>> **rubybeard = Pirate.new('RubyBeard')**
=> #<Pirate:0x00000104bfedc0 @name="RubyBeard">

>> **esmeralda.name**
=> "Esmeralda"

>> **rubybeard.name**
=> "RubyBeard"

```

“现在，让我们测试一下我们的`speak`方法，”女王说道。“因为`Pirate`创建了自己的`speak`方法，所以`Pirate`的实例将使用那个方法，而不是继承自`Person`的那个方法，”她解释道。“但是由于我们没有修改`Pirate`通过`attr_reader :name`继承来的`name`和`name=`方法，我们仍然可以像处理普通人一样处理海盗的名字——获取和修改名字。”

```

>> **esmeralda.speak**
Hello!
=> nil

>> **rubybeard.speak**
Arr!
=> nil

```

“那真是太酷了，”鲁本说道，“但是我们什么时候决定重写一个方法呢？”

“每当一个类继承自另一个类，而且你想要*大部分*相同的行为，但不是完全一样的时候，”女王说道。“在这个例子中，我们希望`Pirate`是`Person`，并且像`Person`一样创建它，但我们希望确保我们的`Pirate`听起来像海盗。所以我们只需要重写我们希望在普通人和海盗之间有所不同的方法！”

“那说得通，”Scarlet 说道，“但是如果我们想要两者的结合呢？也就是说，如果我们想要*修改*一个继承来的方法，但又不完全*替换*它呢？”

## 使用 super

“我很高兴你问了这个问题，”女王说道。“这正是 Ruby 允许我们做的——我们只需要`super`关键字。使用我们之前创建的`Animal`类，我们将创建一个已经存在的方法的新版本，就像我们之前对`speak`方法所做的那样，并添加我们的新代码。然后，我们会使用`super`来告诉 Ruby：‘好吧，我已经完成了对这个方法的修改！现在让它执行父类版本方法中所有的操作。’它是这样工作的，”她说着，输入了：

super_dog.rb

```

class Dog < Animal
  def initialize(name)
    puts 'Just made a new dog!'
    super
  end
end

```

“现在我们可以像之前一样创建一个继承自`Animal`的`Dog`类，”女王说道。

```

>> **load 'super_dog.rb’**
=> true

>> **dog = Dog.new('Bigelow')**
Just made a new dog!
=> #<Dog:0x00000104c6f020 @name="Bigelow", @legs=4>

```

“不过在这里，我们为`Dog`类定义了自己的`initialize`方法，`Dog`的实例将使用这个方法，而不是继承自`Animal`的那个方法，”女王继续说道。

“就像海盗使用自己的`speak`方法，而不是`Person`类的那个方法一样，”鲁本说道。

“正是！”王后说。“我们在`Dog initialize`方法中添加了自己的`puts`语句来打印出一条信息，但之后我们使用了`super`来告诉 Ruby：‘好的！现在，使用`Animal`的`initialize`方法。’`super`所做的就是调用父类方法的版本！由于`Animal`的`initialize`方法为我们设置了`@name`和`@legs`实例变量，因此你会看到不仅有`@name="Bigelow"`，还有`@legs=4`！”

“哎呀，太惊人了，”国王说，他终于把自己弄干了。“Ruby 到底有什么是*做不到*的？”

“这不算什么，”王后说。“真正有趣的部分来了。我们将通过继承、方法重写和`super`来创造一些可靠的伙伴，帮助我们防御入侵我们王国的敌人！”

# 用守卫狗和飞猴保护王国

“但在我们继续之前，”王后说，“我们还是回到我们的`Dog`和`Monkey`类吧。首先，我会重新定义一个`Dog`类，因为已经有一段时间没看它了。”她在她的计算机装置上打字：

guard_dog.rb

```

class Dog < Animal
  attr_accessor :name

  def initialize(name)
    @name = name
  end

  def bark
    puts 'Arf!'
  end
end

```

“我们的`Dog`类继承自`Animal`，并将以`name`进行初始化，它还会有一个`bark`方法，随时可以让它叫个不停，”王后说。“接下来，我将创建一个全新的类，继承自`Dog`。让我们继续修改*guard_dog.rb*吧！”她在计算机装置上打字：

guard_dog.rb

```

  class GuardDog < Dog

➊   attr_accessor :strength

➋   def initialize(name, strength)
      @strength = strength
      super(name)
    end

➌   def bark
      puts 'Stop, in the name of the law!'
    end

➍   def attack
      puts "Did #{rand(strength)} damage!"
    end
  end

```

“在这里，我创建了一个继承自`Dog`的`GuardDog`类。在 ➊，我为`:strength`添加了一个`attr_accessor`，这样我们就可以设置和获取新守卫狗的力量。接下来，在 ➋，我添加了一个`initialize`方法，它部分重写了`Dog`中的`initialize`方法：它设置了`GuardDog`的`@strength`，然后仅传递`name`调用`super`，以使用`Dog`的`initialize`方法，进而设置`@name`。在 ➌，我完全重写了`Dog`中的`bark`方法，并为`GuardDog`设置了一个独有的叫声。

最后在 ➍，我添加了一个全新的`attack`方法，用于打印出一条字符串，说明狗造成了多少伤害。该方法使用了 Ruby 内置的`rand`方法来选择一个介于零和`GuardDog`的力量之间的随机数。

“哇！”鲁本说。“太棒了！我没想到你还能用参数来调用`super`。”

“哦，是的，”王后说。“如果单独调用`super`，它会用子类`initialize`方法获得的所有参数来调用父类的`initialize`方法。`GuardDog`比`Dog`多接受一个参数——它还需要`strength`，而`Dog`仅用`name`来创建。如果我们尝试同时给`Dog`传递这两个参数，就会导致错误。所以我们只用`name`来调用`super`，确保`Dog`的`initialize`方法能接收到它期望的参数数量。”

## 每一只守卫狗都有它的日子

“那么，”王后继续说，“让我们创建一个新的`GuardDog`并进行测试吧！”

```

>> **load('guard_dog.rb')**
=> true
>> **rex = GuardDog.new('Rex', 7)**
=> #<GuardDog:0x0000010334e168 @strength=7, @name="Rex">
>> **rex.strength**
=> 7
>> **rex.bark**
Stop, in the name of the law!
=> nil
>> **rex.attack**
Did 1 damage!
=> nil
>> **rex.attack**
Did 4 damage!
=> nil

```

“现在我们有了一种特殊的狗——`GuardDog`——它有自己的一套方法！”皇后说。“我们部分重写了它的`initialize`方法，因为我们希望它有`strength`，但之后我们使用`super`像创建普通狗那样完成了它的创建。我们重写了`bark`方法，因为我们希望`GuardDog`有`bark`方法，然后通过添加一个完全新的`attack`方法结束，`GuardDog`有这个方法，而普通的`Dog`没有。”

“我现在开始明白了，”鲁本说。“我们通过继承来减少需要重新输入的代码量，当我们想做出例外并赋予子类特殊行为时，我们重写方法！”皇后点点头。

“别忘了`super`，”斯嘉丽说。“当我们想要部分修改子类中方法的行为，但不完全替代它时，我们会用这个。”

国王皱起了眉头。“这很有道理，但我们能再看一些吗？”他问。“一下子记住这些有点多。”

## 再来一次，带点情感！

鲁本点点头。“能再来一个例子，确保我们理解吗？”他问。

“当然，”皇后说。“这是另一个继承、方法重写和`super`的例子，这次我们使用我们可靠的`Monkey`类。让我们让`Monkey`看起来像这样，”她说着，打了几行代码：

flying_monkey.rb

```

class Monkey < Animal
  attr_reader :name, :arms

  def initialize(name, arms = 2)
    @name = name
    @arms = arms
  end

  def make_sounds
    puts 'Eeh ooh ooh!'
  end
end

```

“在这里，我们有一个`Monkey`类。通过使用`attr_reader`，我们可以获取（但不能修改）猴子的`name`和`arms`数量，默认为`2`。我们还有一个`make_sounds`方法，它会打印出一个字符串。”

“看起来很标准，”国王说。

“接下来，”皇后继续说，“我们将创建一个继承自`Monkey`的`FlyingMonkey`类。我们将继续在*flying_monkey.rb*中添加内容！”她在她的计算机装置中输入了代码：

flying_monkey.rb

```

➊ class FlyingMonkey < Monkey
➋   attr_reader :wings

➌   def initialize(name, wings, arms = 2)
      @wings = wings
      super(name, arms)
    end

➍   def throw_coconuts
      coconuts = rand(arms)
      damage = coconuts * wings
      puts "Threw #{coconuts} coconuts! It did #{damage} damage."
    end
  end

```

“对于我们的`FlyingMonkey`类，”皇后说，“首先我们继承自`Monkey` ➊。接下来，我们为`:wings`添加一个`attr_reader`，这样我们就知道我们的`FlyingMonkey`有多少翅膀 ➋。我们用一个特定数量的`@wings`来初始化飞行猴子，但接着调用`super`让`Monkey`类来设置`@name`和`@arms`的数量 ➌。然后我们定义一个全新的`throw_coconuts`方法 ➍，这个方法使用 Ruby 内置的`rand`方法来计算飞行猴子投掷椰子的伤害值。椰子的数量是一个从零到飞行猴子手臂数量之间的随机数，伤害值则是这个数字乘以猴子翅膀的数量，因为有更多翅膀的猴子可以飞得更高。”

“好的！”皇后说。“让我们创建一个飞行猴子并测试它的方法。”

```

>> **load 'flying_monkey.rb'**
=> true

>> **oswald = FlyingMonkey.new('Oswald', 6, 4)**
=> #<FlyingMonkey:0x000001013d1718 @wings=6, @name="Oswald", @arms=4>
>> **oswald.make_sounds**
Eeh ooh ooh!
=> nil

>> **oswald.throw_coconuts**
Threw 3 coconuts! It did 18 damage.
=> nil

```

“太棒了！”斯嘉丽说。“我们通过使用`FlyingMonkey`自己的`initialize`方法来添加翅膀，然后让`Monkey`类来完成设置名字和手臂数量的工作。而且因为`FlyingMonkey`继承了`Monkey`，所以飞行猴子不仅可以`throw_coconuts`，还可以使用`Monkey`的`make_sounds`方法！”

“好极了！”国王说。“我敢打赌那只猴子在扔椰子方面也非常出色。想来，飞行猴子自然是应该具备这种本事。”

“我敢打赌它能发出非常逼真的猴子叫声，”鲁本补充道。

“我想这有道理，”斯嘉丽说，“但有件事困扰着我：为什么我们的 `GuardDog` 会知道怎么*说话*？”

“他是一只非常聪明的狗，”皇后说。

“非常聪明，”国王说。

“说到这个，”皇后说，“我觉得该是时候让我们的守卫狗和飞行猴子开始工作了！”她按下椅子扶手上的一个按钮，她的计算设备开始嗡嗡作响。几秒钟内，办公室四周的门打开了，几十只守卫狗和飞行猴子涌了出来！

![没有标题的图片](img/httpatomoreillycomsourcenostarchimages2160045.png.jpg)

“塔可星期二！”国王说。“我原本以为所有这些小工具和黑客会议都是浪费时间和金钱。”

“恰恰相反，”皇后说，“我觉得它们可能会拯救这个王国！”

国王张开嘴准备说话，但就在此时，皇后桌上的一部鲜红的电话开始疯狂地响了起来。她接起电话。“喂？”她说。她等了一会儿，眼睛睁得大大的。“保持原地不动！我们马上就到！”她挂断电话，跳下椅子。“卫兵有消息！”她说。“他们在皇家马厩。快点，我们走！”

![没有标题的图片](img/httpatomoreillycomsourcenostarchimages2160047.png.jpg)

说完，他们四人迅速从皇后的办公室冲出去，朝着后面的马厩跑去，守卫狗们迅速前冲，飞行猴子紧随其后。

# 皇后的机器

这真是越来越激动人心了！在国王、皇后、鲁本和斯嘉丽去捉拿坏人时，让我们跳进去帮助皇后创建一个 Ruby 类，来帮助保持她所有的皇家事务机密；毕竟，`GuardDog` 和 `FlyingMonkey` 也只能做这么多！我想为她的计算设备创建一个更加安全的登录账户，可能正是我们所需要的；我们可不希望有人再次轻易闯入。所以，我们将设置一个 `Account` 类，里面有一个 `password`，让皇后用来登录她的计算机。

让我们从创建一个名为 secrecy.rb 的新文件开始，并键入以下代码。

secrecy.rb

```

➊ class Account
    attr_accessor :username, :password
➋   def initialize(username, password)
      @username = username
      @password = password
    end
  end

➌ class SuperSecretAccount < Account
➍   def initialize(username, password)
      @reset_attempts = 0
      super(username, password)
    end

➎   def password=(new_password)
      while @reset_attempts < 3
        print 'Current password?: '
        current_password = gets.chomp
        if @password == current_password
          @password = new_password
          puts "Password changed to: #{new_password}"
          break
        else
          @reset_attempts += 1
          puts "That's not the right password."
          puts "Attempt #{@reset_attempts} of 3 used up!"
        end
      end
    end

➏   def password
      'The password is secret!'
    end
  end

➐ regular = Account.new('Your name', 'your password')
  super_safe = SuperSecretAccount.new('Your name', 'your password')

➑ regular = Account.new('Your name', 'your password')
  super_safe = SuperSecretAccount.new('Your name', 'your password')

  puts "Your regular account password is: #{regular.password}"
  regular.password = 'Something else!'
  puts "Your regular account password is now: #{regular.password}"

  puts "If we try to see the secret account password, we get: #{super_
  safe.password}"

  changed_password = 'Something else!'

  puts "Trying to change your secret account password to: #{changed_
  password}..."
  super_safe.password = changed_password

```

这段代码比较长，我们一步一步地来看。

首先，我们在 ➊ 创建一个基本的 `Account` 类，设置一些实例变量（在 ➋ 的 `initialize` 方法中查看它们）。`Account` 类的实例可以通过 `attr_accessor` 让 Ruby 代码随意读取和修改 `@username` 和 `@password` 的值，提供了对这两个属性的访问权限。

我们已经有了一个相当不错的开始！这段代码让我们能够为某人创建账户，并允许该人设置密码，就像你为一个网站或电子邮件设置密码一样。然而，问题是，这段代码允许*任何* Ruby 代码修改用户密码，这显然是我们不希望看到的。

为了解决这个问题，我们在 ➌ 创建了 `SuperSecretAccount` 类，它继承自 `Account`，接下来是事情变得有趣的地方。首先，`SuperSecretAccount` 的 `initialize` 方法同样接受一个用户名和密码，并将这些传递给 `super`，让 `Account` 负责设置这些实例变量 ➍。`SuperSecretAccount` 还创建了一个新的实例变量 `@reset_attempts`，用来跟踪用户尝试登录的次数。

接下来，`SuperSecretAccount` 类重写了 `password=` 方法 ➎（由 `Account` 的 `attr_accessor :password` 创建的两个方法之一），因此它要求用户输入旧密码才能更改密码。如果她输入了正确的密码，程序会更新密码并立即 `break` 跳出 `while` 循环；如果她三次尝试失败，程序将在不更改密码的情况下退出。

之后，`SuperSecretAccount` 类重写了 `password` 方法 ➏（由 `Account` 的 `attr_accessor :password` 创建的另一个方法），并让它打印出字符串 `The password is secret!`，而不是像通常那样直接显示密码。最后，我们创建了几个账户 ➐，并尝试获取和设置密码 ➑。

你可以通过在命令行中输入 **`ruby secrecy.rb`** 来运行文件中的代码。确保你在与 *secrecy.rb* 文件相同的文件夹中，然后输入：

```

$ **ruby secrecy.rb**

```

这是我得到的输出（你的可能会稍有不同，取决于你在运行脚本时输入的内容）：

```

➊ Your regular account password is: your password
  Your regular account password is now: Something else!
➋ If we try to see the secret account password, we get: The password
  is secret!
➌ Trying to change your secret account password to Something else!...
  Current password?: **lasers**
  That's not the right password.
  Attempt 1 of 3 used up!
  Current password?: **ninjas**
  That's not the right password.
  Attempt 2 of 3 used up!
  Current password?: **your password**
  Password changed to: Something else!

```

首先，我们看到程序打印出我们常规账户的密码，然后是我们更改密码后的新密码 ➊。那太简单了！

接下来，在 ➋，我们看到我们的秘密账户正确地隐藏了密码，若我们尝试查看密码，它只会打印出 `The password is secret!`。

最后，我们尝试在 ➌ 更改我们的秘密账户密码。我们先输入两个错误的密码（`lasers` 和 `ninja`），然后输入正确的密码 `your password`，我们的 Ruby 程序打印出我们成功地将密码更新为 `Something else!`。

随意玩玩这段代码。当你尝试获取和设置 *secrecy.rb* 中 `regular` 账户的密码时会发生什么？当你尝试更改 `super_safe` 账户时又会怎么样？

如果我们尝试在 `super_safe` 账户上设置密码，并且传入正确的当前密码，会发生什么？如果是错误的呢？尝试多次输入错误密码会怎么样？

一旦你完成了对代码的探索，你可以尝试思考我们可以做些什么来让它变得更好。例如，我们可以为`Account`或`SuperSecretAccount`添加哪些方法，使它们更有用？（也许添加一个`reset_password`方法，以防你完全忘记了密码？）`SuperSecretAccount`可能会从`Account`重写哪些方法？有没有哪些方法可能使用`Account`的一部分功能，但不是全部？我们该如何做到这一点？（提示：`super`将会参与其中。）

最后，Ruby 确实有一些内置方法可以帮助你提高代码的安全性（或至少控制哪些方法可以被调用）。如果你愿意，可以在 Ruby 文档中详细阅读：*[`ruby-doc.org/core-2.0.0/Module.html#method-i-private`](http://ruby-doc.org/core-2.0.0/Module.html#method-i-private)*。

# 你已经知道这些了！

你在这一章学了一些复杂的内容，但我相信你已经掌握得很好了。为了确保这一点，我们再过一遍所有内容。

首先，我们回顾了如何使用`class`关键字创建 Ruby 类。

```

class Greeting
  def say_hello
    puts 'Hello!'
  end
end

```

接下来，你发现 Ruby 类可以通过*继承*相互共享信息和方法：就像一个人可以继承父母的特征一样，一个 Ruby 类可以从另一个类继承信息和行为。进行继承的类称为*子类*，而被继承的类称为*父类*。

继承的语法如下：

```

class Dog < Animal
  def bark
    puts 'Arf!'
  end
end

```

在这个例子中，由于`Dog`继承自`Animal`，所以`Dog`类的实例（通过`Dog.new`创建）可以使用`Animal`类中定义的任何方法。

我们还学习了*方法重写*和`super`关键字。方法重写就是在子类中编写一个与父类方法同名的方法；当我们创建子类的实例时，它会使用子类版本的方法，而不是父类的版本。每当你想要在子类中实现不同或更具体的行为时，你就需要重写父类的方法。例如，假设你正在编写一个游戏，其中巫师是英雄（`class Wizard < Hero`），巫师在他们的`attack`方法中使用魔法，而不是游戏默认的`剑`。

你可以像这样重写一个方法：

```

class Hero
  def initialize(name)
    @name = name
  end

  def attack
    puts "Swung sword for #{rand(5)} damage!"
  end
end

class Wizard < Hero
  def attack
    puts "Cast spell for #{rand(20)} damage!"
  end
end

```

我们可以从以下例子中看到这一点：这个英雄很擅长剑术，但巫师知道如何施放魔法！

```

>> **aragorn = Hero.new('Aragorn')**
=> #<Hero:0x0000010334e398 @name="Aragorn">

>> **aragorn.attack**
Swung sword for 4 damage!
=> nil

>> **gandalf = Wizard.new('Gandalf')**
=> #<Wizard:0x000001033627f8 @name="Gandalf">

>> **gandalf.attack**
Cast spell for 17 damage!
=> nil

```

如果我们只想修改方法的*部分*内容，可以使用`super`；我们添加所需的额外功能，然后调用`super`来调用父类的版本，如下所示：

```

class Wizard < Hero
  def attack
    super # This calls Hero's attack method
    puts 'But I also know magic! You shall not pass!'
  end
end

```

`attack`方法做了两件事。首先，它通过`super`调用父类的`attack`版本（也就是`Hero`类中定义的`attack`方法，它只打印`Swung sword`的消息）。然后，它打印额外的信息（`But I also know magic! You shall not pass!`）。当你想修改父类方法的行为，但又不完全替换它时，就可以这么做。

```

>> **gandalf = Wizard.new('Gandalf')**
=> #<Wizard:0x000001032d4278 @name="Gandalf">

>> **gandalf.attack**
Swung sword for 2 damage!
But I also know magic! You shall not pass!
=> nil

```

最后但同样重要的是，你看到可以通过带有参数的`super`来将正确的参数传递给父类的方法：

```

class Dog
  attr_accessor :name

  def initialize(name)
    @name = name
  end
end

  class GuardDog < Dog
  attr_reader :strength

  def initialize(name, strength)
    @strength = strength
    super(name)
  end
end

```

现在，当我们创建一个`GuardDog`时，它会添加自己的`@strength`，并让`Dog`来负责添加`@name`：

```

>> **mook = GuardDog.new('Mook', 2)**
=> #<GuardDog:0x00000102fcfca8 @strength=2, @name="Mook">
>> **mook.name**
=> "Mook"
>> **mook.strength**
=> 2

```

好了！到此为止，你已经是一个类的高手了。嗯，*差不多*——正如你有方法更新和更改你的方法一样，也有方法更新和更改你的类；你甚至可以将来自不同类的行为混合到你创建的 Ruby 类中！Ruby 类的最后一块拼图就是*模块*，如果我们加快速度，就能准时赶到皇家马厩，了解它们的所有内容。
