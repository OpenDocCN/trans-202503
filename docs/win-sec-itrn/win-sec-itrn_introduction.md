

# 前言



![](img/chapter.jpg)

数以亿计的设备使用微软 Windows 平台。许多全球最大的公司依赖其安全性来保护数据和通信，任何在 Azure 云中托管代码的人也如此。但由于 Windows 对现代互联网安全至关重要，它也成为了攻击的热门目标。

Windows NT 操作系统从 1993 年开始就将安全性纳入设计，首次引入了用户账户、资源控制和网络远程访问。自那时以来的 20 多年里，Windows 安全性发生了巨大变化。微软已经用现代技术替代了原始的认证过程，赋予访问控制机制更多功能，并显著增强了平台的攻击防护能力。

今天，Windows 平台的安全性异常复杂，许多攻击依赖于滥用这种复杂性。不幸的是，微软在这一领域的文档可能存在不足。由于 Windows 并非开源，有时理解其安全性的唯一途径是通过深入的研究和分析。

这正是我的专长所在。我在 Windows 平台上作为开发者和安全研究员已经有超过 20 年的经验，积累了对操作系统中未公开部分的理解。在本书中，我将以易于理解的方式分享我广泛的专业知识。通过掌握 Windows 安全的原理，你将能够启动自己的研究项目或改进你的软件产品。

## 本书适合谁阅读？

我写这本书是为那些从事 Windows 安全工作的人准备的。也许你是 Windows 软件的开发者，想确保你的产品是安全的。或者你是负责在企业中保护 Windows 安全的系统管理员，但对各种安全功能如何结合保护平台理解不深。又或者你可能是研究人员，想通过漏洞挖掘操作系统中的安全漏洞。

本书假定读者对 Windows 用户界面及其基本操作有一定的了解，比如文件操作。也就是说，你不需要成为低级 Windows 专家：对于那些需要更多基础知识的读者，第二章和第三章提供了操作系统概述以及其组成部分。

我在很大程度上依赖 PowerShell 脚本，因此你会发现如果你对该语言有所了解，以及对其基于的.NET 框架有所掌握，将会对你有所帮助。为了帮助你快速入门，第一章提供了 PowerShell 一些特性的简要概述。在其他地方，我将尽力避免使用该语言的深奥特性，以便让具备其他脚本语言或 Shell 环境（如 bash）知识的读者也能理解代码。

## 本书内容概览

在每一章中，我们都会介绍现代版本的 Windows 中实现的核心安全特性。我们还将通过一些用 PowerShell 编写的实例来进行讲解，这些实例将帮助你更好地理解本章介绍的命令。以下是每章内容的简要总结。

第一部分从编程角度介绍了 Windows 操作系统。它应该为你提供理解本书其余部分所需的基础。

**第一章：设置 PowerShell 测试环境**在本章中，你将设置 PowerShell 以运行后续章节中的示例。这包括安装我编写的 PowerShell 模块，用于与 Windows 及其安全功能进行交互。本章还概述了 PowerShell 脚本语言。

**第二章：Windows 内核**本章介绍了 Windows 内核及其系统调用接口的基础知识，这是开发深入理解 Windows 安全的关键内容。我还描述了对象管理器，用于管理资源。

**第三章：用户模式应用程序**大多数应用程序并不直接使用内核的系统调用接口，而是使用一套更高层的编程接口。本章介绍了 Windows 的功能，例如文件处理和注册表。

第二部分涵盖了 Windows 内核中最重要的安全组件——安全参考监视器。我们将探讨访问控制的各个方面，从构建用户身份到保护单个资源（如文件）。

**第四章：安全访问令牌**Windows 为每个运行中的进程分配一个访问令牌，该令牌代表用户在系统中的身份。本章描述了存储在令牌中的各种组件，这些组件用于检查访问权限。

**第五章：安全描述符**每个可安全访问的资源都需要描述谁可以访问它以及授予何种访问权限。这正是安全描述符的作用。在本章中，我们将讨论它们的内部结构，以及如何创建和操作这些描述符。

**第六章：读取和分配安全描述符**为了检查系统的安全性，你需要能够查询资源的安全描述符。本章解释了不同类型资源如何进行安全描述符查询。它还涵盖了 Windows 为资源分配安全描述符的多种复杂方式。

**第七章：访问检查过程    **Windows 使用访问检查来确定应授予用户对资源的访问权限。此操作会使用令牌和安全描述符，并根据算法确定授予的访问权限。本章通过 PowerShell 实现此算法，深入探讨其设计。

**第八章：其他访问检查应用场景    **虽然 Windows 主要使用访问检查来授予资源访问权限，但有时也用它来确定其他安全属性，例如资源的可见性以及进程是否以较低权限运行。本章介绍了访问检查的这些替代应用场景。

**第九章：安全审计    **访问检查过程还可以生成用户访问过的资源的日志，并记录访问级别。本章介绍了这些系统审计策略。

第三部分包含了 Windows 认证的详细信息，以及为实现访问控制而验证用户身份的机制。

**第十章：Windows 认证    **由于认证这一话题相当复杂，本章总结了认证结构和服务，其他认证机制依赖于此结构和服务。

**第十一章：Active Directory    **Windows 2000 为企业中的 Windows 系统提供了一个新的网络模型，所有认证信息都存储在一个网络目录中，用户和管理员可以查询和修改。本章讲解了 Active Directory 如何存储信息，并保护其免受恶意修改。

**第十二章：交互式认证    **Windows 中最常见的认证场景是用户输入用户名和密码以访问计算机桌面。本章讲解了操作系统如何实现这一认证过程。

**第十三章：网络认证    **当用户想要访问 Windows 企业网络中的网络服务时，他们通常需要进行认证。Windows 提供了特殊的网络协议来实现这一认证，而无需将用户的凭证暴露给可能存在的恶意网络。本章讲解了网络认证过程，重点介绍了新技术局域网管理器（NTLM）认证协议。

**第十四章：Kerberos 认证    **与 Active Directory 一起，Windows 2000 还引入了开源的 Kerberos 认证协议，用于企业网络认证。本章讲解了 Kerberos 在 Windows 中如何进行交互式认证和网络认证。

**第十五章：协商身份验证和其他安全包**    多年来，Windows 增加了其他类型的网络身份验证协议。本章涵盖了这些新类型，包括 Negotiate，以补充第十三章和第十四章中讨论的内容。

最后，两个附录提供了配置细节和更多资源。

**附录 A：为测试构建 Windows 域网络**    为了运行书中的一些示例，您需要一个 Windows 域网络。本附录提供了使用 PowerShell 配置测试网络的一些步骤。

**附录 B：SDDL SID 别名映射**    本附录提供了第五章中引用的常量表。

## 本书中使用的 PowerShell 约定

PowerShell 脚本语言是所有版本 Windows 中都包含的一项功能，是灵活地实验操作系统内部结构的最佳方式之一，而无需安装太多额外的软件。由于 PowerShell 基于 .NET 运行时，本书将使用我为与 Windows 交互而编写的 .NET 库，使得开发复杂脚本变得更加容易。本书中的所有示例脚本都可以从 *[`<wbr>github<wbr>.com<wbr>/tyranid<wbr>/windows<wbr>-security<wbr>-internals`](https://github.com/tyranid/windows-security-internals)* 下载。

每章中的 PowerShell 示例遵循一套常见的风格约定，旨在帮助您理解如何使用它们。每个示例都以列表的形式提供，其中有两种类型：交互式和非交互式。交互式 PowerShell 列表是您应在命令行输入的，以观察结果。以下是一个交互式列表示例：

```
❶ PS> **ls C:\**
❷ Directory: C:\
Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-r---               4/17  11:45 AM        Program Files
❸ `--snip--` 
```

交互式列表在每个命令前面都会有一个 PowerShell 风格的提示符 (PS>)，并以粗体显示命令 ❶。您将在命令下方看到相应的输出 ❷。有时输出可能非常长，因此为了节省空间，我使用 --snip-- 来表示输出已被截断 ❸。还请注意，在某些示例中，输出是示意性的，可能会根据您的操作系统或网络配置略有不同。

大多数交互式列表设计为从普通用户账户执行。然而，某些列表必须以管理员账户运行才能访问某些受保护的功能。如果不以管理员身份运行命令，结果将不正确。每个列表前面的文本将说明是否需要以管理员身份运行命令。

非交互式列表包含 PowerShell 代码，您可以将其复制到脚本文件中以供重用，示例如下：

```
function Get-Hello {
    "Hello"
} 
```

非交互式列表不包含 PowerShell 提示符，并且不会使用粗体。

如果你曾经在 PowerShell 中编写过脚本，你会知道该语言以冗长的命令和参数名称著称。这使得某些命令在书中难以适应单行显示。以下是一个长 PowerShell 命令的示例，以及书中可能将其拆分以适应页面的一些方式：

```
PS> **Get-ChildItem -LiteralPath "C:\" -Filter "*.exe" -Recurse -Hidden**
❶ **-System** **-Depth 5 | Where-Object {**
  ❷ **$_.Name -eq "Hello"**
**}** 
```

第一行，使用 Get-ChildItem 命令，过长以至于无法显示在同一行，因此它换行到了下一行 ❶。你不能在命令的中间随意添加换行符，所以当你在终端或文件中输入时，应该把它当作一行来处理。表明该行继续的关键标志是第一列有一个粗体字符，而不是输出的一部分。

PowerShell 可以在某些字符上断行，例如管道符号 (|)、逗号 (,) 或大括号 ({})。在这个示例中，我在开括号 ({) 后添加了换行符，并将后续的命令放在大括号内，缩进了一个层级 ❷。在这种情况下，Shell 会处理新行的引入。注意，闭括号 (}) 位于第一列，因此你可能认为它应该放在前一行上。尽管将大括号移动到前一行在这个特定情况下仍然有效，但这是不必要的。

请注意，Windows 操作系统仍在积极开发中。虽然所有 PowerShell 示例都已经在撰写时可用的最新版本的 Windows 上进行了测试，但到你阅读这本书时，可能会引入新的安全功能，或者一些旧功能会被弃用。以下是测试示例的版本列表以及主要的操作系统版本号：

+   Windows 11（操作系统版本 22631）

+   Windows 10（操作系统版本 19045）

+   Windows Server 2022（操作系统版本 20384）

+   Windows Server 2019（操作系统版本 17763）

文本中提到的“最新版本”指的是以下这些版本。

## 联系方式

我一直很乐意收到关于我工作中的反馈，无论是积极的还是消极的，这本书也不例外。你可以通过电子邮件联系我，地址是 *winsecinternals.book@gmail.com*。你还可以订阅我的博客 *[`<wbr>www<wbr>.tiraniddo<wbr>.dev`](https://www.tiraniddo.dev)*，我会在那儿发布一些我最新的高级安全研究。
