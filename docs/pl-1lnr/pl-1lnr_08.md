## 附录 A. Perl 的特殊变量

在本附录中，我总结了 Perl 最常用的特殊（预定义）变量，如 `$_`、`$.`、`$/`、`$\`、`$1`、`$2`、`$3`（等等）、`$`、`@F` 和 `@ARGV` 等。

## A.1 变量 $_

`$_` 变量，被称为 *默认变量*，是 Perl 中最常用的变量。通常这个变量被读作“it”（如果不读作“dollar-underscore”）；当你继续阅读时，你会明白原因。

当使用 `-n` 和 `-p` 命令行参数时，输入被存储在哪里呢？而且，许多操作符和函数会隐式地作用于它。这里有一个例子：

```
perl -le '$_ = "foo"; print'
```

在这里，我将字符串 `"foo"` 放入 `$_` 变量中，然后调用 `print`。当没有参数时，`print` 会打印 `$_` 变量的内容，即 `"foo"`。

类似地，当 `s/regex/replace/` 和 `/regex/` 操作符没有使用 `=~` 操作符时，`$_` 会被使用。考虑这个例子：

```
perl -ne '/foo/ && print'
```

这个一行命令仅打印匹配`/foo/`的行。`/foo/` 操作符隐式地作用于包含当前行的 `$_` 变量。你也可以将其重写为以下内容，但那样会需要输入过多：

```
perl -ne 'if ($_ =~ /foo/) { print $_ }'
```

“如果匹配 `/foo/`，则打印出来”——你大概明白了。你也可以通过调用 `s/foo/bar/` 来简单地替换所有行中的文本：

```
perl -pe 's/foo/bar/'
```

有趣的是，Perl 借用了 `$_` 变量来自 sed。记得 sed 有一个模式空间吗？`$_` 变量也可以称为 Perl 的模式空间。如果你在 sed 中编写前面的单行命令 (`perl -pe 's/foo/bar/'`)，它会变成 `sed 's/foo/bar/'`，因为 sed 会将每一行放入模式空间中，并且 `s` 命令会隐式地作用于它。Perl 从 sed 借用了许多概念和命令。

### 使用 `$_` 和 `-n` 参数

当使用 `-n` 参数时，Perl 会在你的程序周围加上以下循环：

```
while (<>) {
    # your program goes here (specified by -e)
}
```

`while (<>)` 循环从标准输入或命令行上指定的文件中读取行，并将每一行放入 `$_` 变量中。你可以修改这些行并打印它们。例如，你可以反转这些行：

```
perl -lne 'print scalar reverse'
```

因为我在这里使用了 `-n` 参数，所以这个程序变成了：

```
while (<>) {
    print scalar reverse
}
```

这等同于

```
while (<>) {
    print scalar reverse $_
}
```

这两个程序是等价的，因为许多 Perl 函数会隐式地作用于 `$_`，这使得写 `reverse` 和 `reverse $_` 在功能上是一样的。你需要使用 `scalar` 来将 `reverse` 函数放入标量上下文中。否则，它会在列表上下文中（`print` 强制列表上下文），并且不会反转字符串。（我在第 12 页的单行命令 2.6 中详细解释了 `-n` 标志，在第 67 页的单行命令 6.22 中讲解了行反转。）

### 使用 `$_` 和 `-p` 参数

当你使用 `-p` 参数时，Perl 会在你的程序周围加上以下循环：

```
while (<>) {
    # your program goes here (specified by -e)
} continue {
    print or die "-p failed: $!\n";
}
```

结果几乎与使用 `-n` 参数时相同，只是每次迭代后，`$_` 的内容会被打印出来（通过 `continue` 块中的 `print`）。

为了像使用 `-n` 时那样反转行，我可以这样做：

```
perl -pe '$_ = reverse $_'
```

现在程序变成了：

```
while (<>) {
    $_ = reverse $_;
} continue {
    print or die "-p failed: $!\n";
}
```

我已将 `$_` 变量修改为 `reverse $_`，这会反转行。`continue` 块确保它会被打印。（书中第 7 页的单行代码 2.1 更详细地解释了 `-p` 参数。）

### 明确使用 `$_`

`$_` 变量也常常被显式使用。以下是一些显式使用 `$_` 变量的例子：

```
perl -le '@vals = map { $_ * 2 } 1..10; print "@vals"'
```

这行代码的输出是 `2 4 6 8 10 12 14 16 18 20`。在这里，我使用 `map` 函数对给定列表中的每个元素应用表达式，并返回一个新的列表，其中每个元素都是该表达式的结果。在这个例子中，列表是 `1..10`（`1 2 3 4 5 6 7 8 9 10`），表达式是 `$_ * 2`，意味着将每个元素（“它”）乘以 `2`。如你所见，我明确地使用了 `$_`。当 `map` 函数遍历列表时，每个元素会被放入 `$_`，方便我使用。

现在让我们在一个方便的单行代码中使用 `map`。怎么样，试试一个将每行的每个元素乘以 2 的例子？

```
perl -alne 'print "@{[map { $_ * 2 } @F]}"'
```

这行代码将表达式 `$_ * 2` 应用到 `@F` 中的每个元素。看起来很复杂的 `"@{[...]}"` 只是执行代码的一种方式，放在引号内部。（书中第 30 页的单行代码 4.2 解释了 `@F`，第 32 页的单行代码 4.4 解释了 `"@{[...]}"`。）

另一个显式使用 `$_` 的函数是 `grep`，它允许你从列表中过滤元素。这里是一个例子：

```
perl -le '@vals = grep { $_ > 5 } 1..10; print "@vals"'
```

这行代码的输出是 `6 7 8 9 10`。如你所见，`grep` 从列表中过滤掉了大于 5 的元素。条件 `$_ > 5` 问的是：“当前元素是否大于 5？”——更简洁地说，“它是否大于 5？”

让我们在一行代码中使用 `grep`。如何用一个查找并打印当前行上所有回文的例子呢？

```
perl -alne 'print "@{[grep { $_ eq reverse $_ } @F]}"'
```

这里传给 `grep` 函数的条件是 `$_ eq reverse $_`，它问的是：“当前元素是否与其反向相同？”这个条件只对回文有效。例如，给定以下输入：

```
civic foo mom dad
bar baz 1234321 x
```

这行代码输出的是：

```
civic mom dad
1234321 x
```

如你所见，所有这些元素都是回文。

你可以通过在命令行中输入 `perldoc perlvar` 来进一步了解 `$_` 变量。*perlvar* 文档解释了 Perl 中所有的预定义变量。

## A.2 变量 $.

在读取文件时，`$.` 变量总是包含当前正在读取的行号。例如，这行代码为 `file` 中的每一行编号：

```
perl -lne 'print "$. $_"' *file*
```

你可以使用这行代码来做同样的事情，它将当前行替换为行号，后面跟着相同的行：

```
perl -pe '$_ = "$. $_"' *file*
```

`$.` 变量在多个文件之间不会重置，所以要同时为多个文件编号，你可以写：

```
perl -pe '$_ = "$. $_"' *file1 file2*
```

这行代码继续为 `file2` 中的行编号，接着 `file1` 停下的位置。（如果 `file1` 有 10 行，`file2` 的第一行将被编号为 11。）

要重置 `$.` 变量，你可以显式地对当前文件句柄 `ARGV` 执行 `close`：

```
perl -pe '$_ = "$. $_"; close ARGV if eof' *file1 file2*
```

`ARGV` 是一个特殊的文件句柄，包含当前打开的文件。通过调用 `eof`，我在检查当前文件是否已到达结尾。如果是，`close` 会关闭它，从而重置 `$.` 变量。

你可以通过修改 `$/` 变量来改变 Perl 认为的一行是什么。接下来的部分将讨论这个变量。

## A.3 变量 $/

`$/` 变量是输入记录分隔符，默认值是换行符。这个变量告诉 Perl 什么算作一行。假设你有一个简单的程序，给每一行编号：

```
perl -lne 'print "$. $_"' *file*
```

因为默认情况下 `$/` 是换行符，Perl 会读取直到第一个换行符的所有内容，放入 `$_` 变量中，并递增 `$.` 变量。接下来，它调用 `print "$. $_"`，打印当前的行号和该行内容。但如果你将 `$/` 的值更改为两个换行符，比如 `$/ = "\n\n"`，Perl 将读取直到第一个两个换行符的所有内容；也就是说，它按段落而不是按行来读取文本。

这是另一个示例。如果你有一个如下的文件，可以将 `$/` 设置为 `:`，然后 Perl 将逐个读取文件中的字符。

```
3:9:0:7:1:2:4:3:8:4:1:0:0:1:... (goes on and on)
```

或者如果你将 `$/` 设置为 `undef`，Perl 将在一次读取中读取整个文件（称为 *slurping*）：

```
perl -le '$/ = undef; open $f, "<", "*file*"; $contents = <$f>"
```

这一行代码将整个文件 `file` 读取到变量 `$contents` 中。

你也可以将 `$/` 设置为引用一个整数：

```
$/ = \1024
```

在这种情况下，Perl 每次读取 1024 字节。（这也叫做 *逐条记录读取*。）

你也可以使用 `-0` 命令行开关为这个变量提供一个值，但请注意，像这样不能进行逐条记录的版本。例如，要将 `$/` 设置为 `:`，请指定 `-0072`，因为 `072` 是字符 `:` 的八进制值。

为了记住这个变量的作用，回想一下，当引用诗歌时，行与行之间是用 `/` 分隔的。

## A.4 变量 $\ 

每次 `print` 操作后都会附加美元反斜杠变量。例如，你可以在每个 `print` 后附加一个点和一个空格 `". "`：

```
perl -e '$\ = ". "; print "hello"; print "world"'
```

这一行代码将输出以下内容：

```
hello. world.
```

修改这个变量特别有帮助，当你想通过双重换行符分隔输出时。

要记住这个变量，只需回想你可能希望在每一行后打印 `\n`。请注意，对于 Perl 5.10 及之后的版本，`say` 函数是可用的，它类似于 `print`，只是它总是在末尾添加一个换行符，并且不使用 `$\` 变量。

## A.5 变量 $1、$2、$3 等

变量 `$1`、`$2`、`$3` 等包含来自最后一次模式匹配中相应捕获括号对的匹配内容。以下是一个示例：

```
perl -nle 'if (/She said: (.*)/) { print $1 }'
```

这一行代码匹配包含字符串 `She said:` 的行，然后捕获该字符串后的所有内容到变量 `$1` 中并打印出来。

当你使用另一个括号对时，文本将被捕获到变量 `$2` 中，依此类推：

```
perl -nle 'if (/(She|He) said: (.*)/) { print "$1: $2" }'
```

在这一行代码中，首先 `"She"` 或 `"He"` 被捕获到变量 `$1` 中，然后她或他说的任何话被捕获到变量 `$2` 中，并作为 `"$1: $2"` 打印出来。你将得到与括号对数相同数量的捕获变量。

为了避免将文本捕获到变量中，可以在括号开头使用 `?:` 符号。例如，将 `(She|He)` 更改为 `(?:She|He)`：

```
perl -nle 'if (/(?:She|He) said: (.*)/) { print "Someone said: $1" }'
```

不会将 `"She"` 或 `"He"` 捕获到变量 `$1` 中。相反，第二对括号会将她或他说的话捕获到变量 `$1` 中。

从 Perl 5.10 开始，你可以使用命名捕获组，例如 `(?<name>...)`。这样做时，您可以使用 `$+{name}` 来引用组，而不是使用变量 `$1`、`$2` 等。例如，这将 `"She"` 或 `"He"` 捕获到名为 `gender` 的组中，并将她或他说的话捕获到名为 `text` 的组中：

```
perl -nle 'if (/(?<gender>She|He) said: (?<text>.*)/) {
  print "$+{gender}: $+{text}"
}'
```

## A.6 变量 $,

`$` 变量是 `print` 打印多个值时的输出字段分隔符。默认情况下它未定义，这意味着所有打印的项都会连接在一起。实际上，如果你这样做：

```
perl -le 'print 1, 2, 3'
```

你将打印出 `123`。然而，如果你将 `$` 设置为冒号，则会：

```
perl -le '$,=":"; print 1, 2, 3'
```

你将得到 `1:2:3`。

现在，假设你想打印一组值。如果你这样做：

```
perl -le '@data=(1,2,3); print @data'
```

输出是 `123`。但如果你将变量加上引号，值将以空格分隔：

```
perl -le '@data=(1,2,3); print "@data"'
```

所以输出是 `1 2 3`，因为数组在双引号字符串中被插值。

## A.7 变量 $”

这就引出了 `$"` 变量：它是一个单一的空格（默认情况下），会在每个数组值之间插入。当你写类似 `print "@data"` 的代码时，`@data` 数组会被插入，且 `$"` 的值会在每个数组元素之间插入。例如，以下代码会打印 `1 2 3`：

```
perl -le '@data=(1,2,3); print "@data"'
```

但如果你将 `$"` 改为，例如，破折号 `-`，输出将变为 `1-2-3`：

```
perl -le '@data=(1,2,3); $" = "-"; print "@data"'
```

回想一下这里的 `@{[...]}` 技巧。如果你 `print "@{[...]}"`，你可以执行放在方括号中的代码。更多示例和细节，请参见 A.1 变量 $_ 一节讨论的 `$_` 变量，见第 95 页及第 32 页的一行代码 4.4。

## A.8 变量 @F

`@F` 变量是在你的 Perl 程序中使用 `-a` 参数时创建的，`-a` 代表自动分割字段。当你使用 `-a` 时，输入会按空格字符分割，生成的字段会放入 `@F` 中。例如，如果输入行是 `foo bar baz`，那么 `@F` 是一个数组 `("foo", "bar", "baz")`。

这种技术允许你操作单独的字段。例如，你可以访问 `$F[2]` 来打印第三个字段，如下所示（记住数组是从索引 0 开始的）：

```
perl -ane 'print $F[2]'
```

你还可以进行各种计算，比如将第五个字段乘以 2：

```
perl -ane '$F[4] *= 2; print "@F"'
```

在这里，第五个字段 `$F[4]` 被乘以 2，而 `print "@F"` 会打印所有字段，字段之间用空格分隔。

你也可以将 `-a` 参数与 `-F` 参数一起使用，`-F` 参数指定分隔字符。例如，要处理 */etc/passwd* 中以冒号分隔的条目，你可以写：

```
perl -a -F: -ne 'print $F[0]' /etc/passwd
```

它会打印来自 */etc/passwd* 的用户名。

## A.9 变量 @ARGV

`@ARGV` 变量包含传递给 Perl 程序的参数。例如，以下代码会打印 `foo bar baz`：

```
perl -le 'print "@ARGV"' foo bar baz
```

当你使用 `-n` 或 `-p` 标志时，传递给 Perl 程序的参数会一个一个地作为文件打开，并从 `@ARGV` 中移除。要访问传递给程序的文件名，可以在 `BEGIN` 块中将它们保存在一个新变量中：

```
perl -nle 'BEGIN { @A = @ARGV }; ...' *file1 file2*
```

现在你可以在程序中使用 `@A`，它包含 `("file1", "file2")`。如果你没有这么做，而是直接使用 `@ARGV`，一开始它将包含 `("file2")`，但当 `file1` 被处理时，它将变为空 `()`。这里要小心！

一个外观相似的变量 `$ARGV` 包含当前正在读取的文件名，如果程序当前从标准输入读取，则为 `"-"`。

## A.10 变量 %ENV

`%ENV` 哈希表包含来自你的 shell 的环境变量。当你希望在脚本中预定义一些值并在 Perl 程序或单行命令中使用这些值时，这个变量非常有用。

假设你想使用 `system` 函数执行一个不在路径中的程序。你可以修改 `$ENV{PATH}` 变量并附加所需的路径：

```
perl -nle '
  BEGIN { $ENV{PATH} .= ":/usr/local/yourprog/bin" }
  ...
  system("yourprog ...");
'
```

这个单行命令打印所有来自 Perl 的环境变量：

```
perl -le 'print "$_: $ENV{$_}" for keys %ENV'
```

它遍历 `%ENV` 哈希表的键（环境变量名），将每个键放入 `$_` 变量中，然后打印该名称后跟 `$ENV{$_}`，即环境变量的值。
