## 第二章 空格

在本章中，我们将探讨各种改变行和词间距的一行命令，执行诸如在文件中双倍或三倍行距、删除空行以及双倍行距词汇等任务。你还将了解各种命令行参数，如`-p`、`-e`、`-n`，以及特殊变量，如`$_`和`$\`。

## 2.1 双倍行距文件

```
perl -pe '$\ = "\n"' *file*
```

这个一行命令实现了文件的双倍行距。这里需要解释三件事：`-p`和`-e`命令行选项以及简短的`$\ = "\n"` Perl 程序。

使用`-e`选项可以直接在命令行输入 Perl 程序。通常你不会为每个小程序创建源文件；使用`-e`你可以很容易地将程序直接写入命令行，作为一行命令。在这种情况下，整个 Perl 程序包含在这一行命令中，即`$\ = "\n"`。务必使用单引号（`'`）包裹程序，否则你的 shell 会将`$\`等内容解释为 shell 变量，而这些变量没有值，实际上会将它们删除！

现在让我们看看`-p`选项。指定`-p`告诉 Perl 假定在你的程序周围有一个循环：

```
while (<>) {
    # your program goes here (specified by -e)
} continue {
    print or die "-p failed: $!\n";
}
```

从广义上讲，这个构造会遍历所有输入，执行你的代码，并打印`$_`的值（`print`语句打印`$_`的值），这使你能够快速修改输入的全部或部分行。`$_`变量是一个特殊的变量，它会被当前的文本行替换。它也可以替换为其他内容。你将在本书中学到关于`$_`的所有知识。（有关它的使用案例，请参见附录 A。）

但更详细地理解这个循环的工作原理是很重要的。首先，`while (<>)`循环从标准输入中读取每一行并将其放入`$_`变量中。接着，执行由`-e`指定的代码，然后是`print or die`部分。

`continue`语句在每一行之后执行`print or die`语句，尝试打印`$_`变量的内容。如果尝试失败（例如，终端不可写，或者标准输出被重定向到无法写入的地方），`die`会使 Perl 退出并显示错误信息。

在这行命令中，`-e`指定的代码是`$\ = "\n"`，因此 Perl 执行的程序看起来像这样：

```
while (<>) {
    $\ = "\n";
} continue {
    print or die "-p failed: $!\n";
}
```

这个 Perl 程序将每一行读入`$_`变量，然后设置`$\`为换行符并调用`print`。另一个特殊的变量是`$\`。它类似于 Awk 中的`ORS`（输出记录分隔符）变量，它会在每次`print`操作之后附加。没有参数的`print`语句打印`$_`的内容，并在输出的末尾附加`$\`。结果是，每一行被原样打印，并在末尾附加`$\`，其值为换行符。现在，输入变为双倍行距。

实际上，你并不需要为每一行都设置`$\`为换行符；你可以只在程序的开始处设置一次：

```
perl -pe 'BEGIN { $\ = "\n" }' *file*
```

这个一行代码在 Perl 执行任何操作之前，只会将`\`设置为换行符一次，位于`BEGIN`代码块中。`BEGIN`代码块是一个特殊的代码块，在 Perl 程序中执行的所有其他操作之前首先被执行。以下是展开后的 Perl 程序，它的运行方式与前一个一行代码完全相同：

```
BEGIN { $\ = "\n" }
while (<>) {
} continue {
    print or die "-p failed: $!\n";
}
```

这是另一种对文件进行双倍行距的方式。这个一行代码在每行的末尾添加一个换行符，然后`print`该行：

```
perl -pe '$_ .= "\n"' *file*
```

这个一行代码等同于

```
while (<>) {
    $_ = $_ . "\n"
} continue {
    print or die "-p failed: $!\n";
}
```

写`$_ = $_ . "\n"`与写`$_ .= "\n"`是等效的。这个表达式只是将`$_`与`"\n"`连接起来。（句点（`.`）是字符串连接操作符。）

但可能最简洁的双倍行距方式是使用替换操作符`s`：

```
perl -pe 's/$/\n/' *file*
```

这个一行代码将正则表达式`$`（匹配行尾的字符）替换为换行符，有效地在行尾添加了一个换行符。

如果你使用的是 Perl 5.10 或更高版本，你可以使用`say`操作符。`say`操作符的作用类似于`print`，但它总是在行尾添加一个换行符。在 Perl 5.10 中，这个一行代码可以这样写：

```
perl -nE 'say' *file*
```

`-E`命令行参数的作用与`-e`命令行参数完全相同，但它还启用了 Perl 5.10 的功能，包括`say`操作符。`-n`参数与`-p`类似，但你必须自己打印每一行。（我在一行代码 2.6 中更详细地解释了`-n`参数。）这个一行代码打印该行，接着由`say`操作符追加另一个换行符。

例如，如果文件包含四行：

```
line1
line2
line3
line4
```

运行这些一行代码中的任何一行都会输出以下内容：

```
line1

line2

line3

line4
```

在这些最初的几个示例中，我将文件名作为最后一个参数传递给一行代码。当我这么做时，一行代码会在该文件的内容上进行操作。如果我没有给一行代码传递文件名，它们将操作来自标准输入的数据。从现在开始，我不会在一行代码的末尾指定文件，但如果你想在文件上运行一行代码，你始终可以将文件名加回来。在编写一行代码时，最好通过直接在标准输入中键入一些内容来快速测试它们是否正确。然后，当你确信这行代码有效时，你可以在末尾传递一个或多个文件名。

再次提醒，不要忘记 Perl 的便捷文档系统*perldoc*。只需在命令行输入`perldoc perlrun`，就能显示如何运行 Perl 及所有命令行参数的相关信息。

## 2.2 对文件进行双倍行距操作，排除空行

```
perl -pe '$_ .= "\n" unless /^$/'
```

这个一行代码通过在每个非空行的末尾添加一个换行符来双倍行距所有非空行。`unless`表示“如果不是”，`unless /^$/`表示“如果不是‘行首到行尾’”。条件“行首到行尾”仅对空行成立。

以下是展开后的这个一行代码的样子：

```
while (<>) {
    unless (/^$/) {
        $_ .= "\n"
    }
} continue {
    print or die "-p failed: $!\n";
}
```

这是一个更好的测试，它考虑到了行中的空格和制表符：

```
perl -pe '$_ .= "\n" if /\S/'
```

这里，行与`\S`进行匹配——这是一个正则表达式序列，是`\s`的反向，`\s`匹配任何空白字符（包括制表符、垂直制表符、空格、换行符和回车符）。`\s`的反向是任何非空白字符。结果是，所有包含至少一个非空白字符的行都被双倍行距。

## 2.3 将文件设置为三倍行距

你也可以通过在每行末尾输出更多的换行符，轻松地将文件设置为三倍行距：

```
perl -pe '$\ = "\n\n"'
```

或者

```
perl -pe '$_ .= "\n\n"'
```

或者

```
perl -pe 's/$/\n\n/'
```

这些命令与本章中的第一个命令类似，不同之处在于每行末尾添加了两个换行符。

## 2.4 将文件设置为 N 行间距

```
perl -pe '$_ .= "\n"x7'
```

这行命令在每行后插入七个换行符。注意，我使用了`"\n" x 7`来将换行符重复七次。`x`运算符将左侧的值重复*N*次。

例如，这一行

```
perl -e 'print "foo"x5'
```

打印`foofoofoofoofoo`。

顺便提一下，有时候当你需要生成一定量的数据时，`x`运算符非常有用。例如，要生成 1KB 的数据，你可以这样做：

```
perl -e 'print "a"x1024'
```

这行命令打印字符* a * 1024 次。

## 2.5 在每行前添加一个空行

```
perl -pe 's/^/\n/'
```

这行命令使用了`s/regex/replace/`运算符。它用替代值替换给定的正则表达式。在这行命令中，运算符是`s/^/\n/`，正则表达式是`^`，替代值是`\n`。`^`模式匹配文本的开始位置，而`s`运算符将其替换为`\n`，即换行符。因此，换行符被插入到这一行之前。要插入其他内容，只需将`\n`替换为你要插入的部分。

## 2.6 删除所有空行

```
perl -ne 'print unless /^$/'
```

这行命令使用了`-n`标志，告诉 Perl 在程序周围假定一个与`-p`不同的循环：

```
while (<>) {
    # your program goes here
}
```

将这个循环与当你指定`-p`时 Perl 假定的循环进行比较，你会看到这个循环没有`continue { print or die }`部分。在这个循环中，每一行都由钻石运算符`<>`读取并存储在特殊变量`$_`中，但它不会被打印！你必须自己打印这一行——如果你想选择性地打印、修改或删除行，这是一个非常有用的功能。

在这行命令中，代码是`print unless /^$/`，所以整个 Perl 程序变成了：

```
while (<>) {
    print unless /^$/
}
```

进一步解析，你得到这个：

```
while (<>) {
    print $_ unless $_ =~ /^$/
}
```

这行命令打印所有非空行。（你在第 11 页的一行命令 2.2 中看到了`/^$/`正则表达式。）

这行命令还删除了所有空行：

```
perl -lne 'print if length'
```

这个单行命令使用了`-l`命令行参数，它会自动去掉输入行末尾的换行符（基本上就是去掉末尾的换行），然后在打印时再将其加回到行尾。指定给`-e`参数的代码是`'print if length'`，意思是“如果行有内容，就打印”。空行的长度为 0，因此不会被打印（在 Perl 中，0 是一个假值，因此`if length`条件会返回假）。所有其他非空行都有长度，并且会被打印。如果没有`-l`，字符串的末尾仍然会有换行符，因此长度会是 1 或 2 个字符！^([1])

这是另一个去除所有空白行的单行命令：

```
perl -ne 'print if /\S/'
```

这个单行命令与前两个稍有不同。`print unless /^$/`和`print if length`都会打印出仅由空格和/或制表符组成的行。这样的行看起来像是空的，可能需要过滤掉。这个单行命令使用了`\S`（在 2.2 的单行命令中解释过），这是一个匹配非空字符的正则表达式序列。仅包含空格和/或制表符的行不匹配`\S`，因此不会被打印。

正如你所看到的，你可以用很多不同的方式写同样的程序。事实上，Perl 的座右铭是*有不止一种方法可以做这件事*，简称*TIMTOWTDI*，发音为“Tim Toady”。（有趣的冷知识：Perl 的发明者 Larry Wall 在 Twitter 和 IRC 上使用@TimToady 作为昵称。）

## 2.7 删除所有连续的空白行，只留下一个

```
perl -00 -pe ''
```

这个单行命令真的很难理解，不是吗？首先，它没有任何代码！`-e`是空的。接下来，它有一个愚蠢的`-00`命令行选项，它启用了*段落吸入模式*，这意味着 Perl 按段落而不是按行读取文本。（段落是由两个或更多换行符分隔的文本。）段落被放入`$_`中，并且`-p`选项会打印它。

你甚至可以用更简洁的方式写这个：

```
perl -00pe0
```

这里，指定给`-e`的代码是`0`，它什么也不做。

这是我最喜欢的单行命令之一，因为如果你之前没有见过它，可能很难理解，而我喜欢思考难题。（`-e`没有指定代码！它怎么可能有用？）

## 2.8 将所有空白行压缩/扩展为连续的 N 行

假设你有一个文件，每个段落后都有两个空白行，而你希望将段落之间的行距扩展为三行。你可以像这样将 2.4 和 2.7 的单行命令结合起来：

```
perl -00 -pe '$_ .= "\n"x2'
```

这个单行命令通过`-00`选项按段落读取行，然后在每个段落后加上三个换行符。代码`"\n"x2`打印两个换行符，这两个换行符会加到段落末尾已经存在的空白行后面。

以类似的方式，你也可以减少段落之间的行距。假设你有一个文件，出于某种奇怪的原因，段落之间有十个空白行，而你希望将这些空白行压缩为三行。你可以再次使用相同的单行命令！

## 2.9 在所有单词之间加倍行距

```
perl -pe 's/ /  /g'
```

在这里，你使用替代操作符` s`将一个空格“ ”替换为两个空格“ ”，并且每一行都全局替换（`/g`标志使替换全局进行），就这么简单！

这是一个示例。假设你有这样一行文本：

```
this line doesn't have enough whitespace!
```

运行这个单行命令会增加单词之间的间距：

```
this  line  doesn't  have  enough  whitespace!
```

## 2.10 删除单词之间的所有空格

```
perl -pe 's/ +//g'
```

这个单行命令使用“`+`”正则表达式来匹配一个或多个空格。当它找到匹配项时，会将其替换为空字符串，并全局删除所有单词之间的空格。

如果你还想去除可能添加间距的制表符和其他特殊字符，可以使用`\s+`正则表达式，它表示“匹配空格、制表符、垂直制表符、换行符或回车符”：

```
perl -pe 's/\s+//g'
```

这是一个示例。假设你有这样一行文本：

```
this line has too much whitespace said cowboy neal
```

运行这个单行命令会移除所有空格：

```
thislinehastoomuchwhitespacesaidcowboyneal
```

## 2.11 将所有单词之间的空格更改为一个空格

```
perl -pe 's/ +/ /g'
```

这个单行命令与前一个类似，只是它将一个或多个空格替换为一个空格。

例如，如果你有这样一行：

```
this   line has really           messed-up                    spacing
```

运行这个单行命令将单词之间的间距标准化为一个空格：

```
this line has really messed-up spacing
```

## 2.12 在所有字符之间插入空格

```
perl -lpe 's// /g'
```

在这里，你匹配看似没有任何东西的地方，并将其替换为一个空格。这个“什么也没有”实际上意味着“字符之间的匹配”，因此你会在所有字符之间插入一个空格。（匹配包括文本的开始和结束。）

例如，给定这一行：

```
today was a great day
```

运行这个单行命令会产生以下结果：

```
t o d a y   w a s   a   g r e a t   d a y
```

可能很难看到所有空格被添加到哪里，所以我们通过修改这个单行命令来在所有字符之间插入一个冒号来说明这一点：

```
perl -lpe 's//:/g'
```

这将输出：

```
:t:o:d:a:y: :w:a:s: :a: :g:r:e:a:t: :d:a:y:
```

如你所见，空格（或冒号）也会插入到文本的开头和结尾。还要注意，现有的空格也算作字符，因此它们是三倍的间距。

* * *

^([1]) Windows 使用两个字符表示换行符。
