## 第七章 选择性地打印和删除行

在本章中，我们将研究各种打印和删除特定行的单行代码。这些单行代码将例如打印重复的行、打印文件中最短的行，以及打印匹配某些模式的行。

但是，每个打印特定行的单行代码也可以被视为删除那些未打印的行。例如，一个打印所有唯一行的单行代码会删除所有重复的行。我只讨论打印内容的单行代码，而不是删除内容的单行代码，因为一个总是另一个的反操作。

## 7.1 打印文件的第一行（模拟`head -1`）

```
perl -ne 'print; exit' *file*
```

这个单行代码非常简单。由于`-n`选项，Perl 将第一行读取到`$_`变量中，然后调用`print`打印`$_`变量的内容。然后它就退出了。就这样。第一行被打印，这正是你想要的。

你也可以说这个单行代码删除了除了第一行之外的所有行。但不用担心。这个特定的单行代码不会删除文件内容，除非你还指定了`-i`命令行参数，像这样：

```
perl -i -ne 'print; exit' *file*
```

正如我在第一章和第 59 页的单行代码 6.1 中所解释的，`-i`参数会就地编辑文件。在这种情况下，文件中的所有行都会被删除，除了第一行。使用`-i`时，务必指定一个备份扩展名，像这样：

```
perl -i.bak -ne 'print; exit' *file*
```

这将在内容被覆盖之前创建一个备份文件*file.bak*。

你可以向任何单行代码添加`-i`命令行参数来更改文件内容。如果不使用`-i`参数，单行代码只会将文件的新内容打印到屏幕上，而不会修改文件。

## 7.2 打印文件的前 10 行（模拟`head -10`）

```
perl -ne 'print if $. <= 10' *file*
```

这个单行代码使用了`$.`特殊变量，它表示“当前行号”。每当 Perl 读取一行时，它会将`$.`增加 1，因此很明显，这个单行代码只是打印前 10 行。

这个单行代码也可以不使用`if`语句来编写：

```
perl -ne '$. <= 10 && print' *file*
```

在这里，只有当布尔表达式`$. <= 10`为真时才会调用`print`，这个表达式只有在当前行号小于或等于 10 时才为真。

另一种稍微复杂一些的方法是使用标量上下文中的范围操作符（`..`）：

```
perl -ne 'print if 1..10' *file*
```

标量上下文中的范围操作符返回一个布尔值。这个操作符是*双稳态*的，像一个触发器，模拟了 sed、awk 以及各种文本编辑器中的*行范围*（逗号）操作符。只要左操作数为假，操作符的值就是假。一旦左操作数为真，范围操作符为真，直到右操作数为真，此时范围操作符又变为假。因此，这个双稳态操作符在第一行时变为真，保持真直到第十行，然后变为假并保持为假。

第四种选择是遵循本章中的第一个示例：

```
perl -ne 'print; exit if $. == 10' *file*
```

这里，我对`exit`加了一个条件，即当前行（我刚刚打印的行）是第 10 行。

## 7.3 打印文件的最后一行（模拟`tail -1`）

```
perl -ne '$last = $_; END { print $last }' *file*
```

打印文件的最后一行比打印第一行要复杂，因为你永远无法知道哪一行是最后一行。因此，你总是需要将刚刚读取的行保存在内存中。在这个单行代码中，你会将当前行`$_`保存到`$last`变量中。当 Perl 程序结束时，它会执行`END`块中的代码，打印最后一行读取的内容。

这里有另一种做法：

```
perl -ne 'print if eof' *file*
```

这个单行代码使用了`eof`（或文件结束）函数，它会返回 1，如果下一个读取操作返回文件结尾。因为在文件的最后一行之后，下一次读取将返回文件结尾，所以这个单行代码可以完成任务。下一次读取意味着 Perl 会尝试从当前文件中读取一个字符，如果读取失败，它会发出到达文件结尾的信号，表示整个文件已被读取。如果读取成功，Perl 会悄悄地将该字符放回输入流，就好像什么都没有发生一样。

## 7.4 打印文件的最后 10 行（模拟`tail -10`）

```
perl -ne 'push @a, $_; @a = @a[@a-10..$#a] if @a>10; END { print @a }' *file*
```

这个单行代码有点复杂。在这里，你将每一行推入`@a`数组，然后如果数组中包含超过 10 个元素，就用其最后 10 个元素替换`@a`。表达式`@a = @a[@a-10..$#a]`的意思是“用`@a`的最后 10 个元素替换`@a`”。`@a-10`会使`@a`在标量上下文中进行求值，因此返回数组元素的数量减去 10。表达式`$#a`是`@a`数组的最后一个索引。最后，`@a[@a-10..$#a]`进行切片（返回）数组的最后 10 个元素，并用它来覆盖`@a`，使其始终只包含最后 10 个元素。

例如，假设`@a`包含`(line1, line2, line3, line4)`，你想打印文件的最后四行。当你读取到第五行时，数组变成了`(line1, line2, line3, line4, line5)`，而`@a-4`的值是 1，因为`@a`在标量上下文中是 5。但`$#a`的值是 4，因为它是数组的最后一个索引。因此，当你取切片`@a[@a-4..$#a]`时，它变成了`@a[1..4]`，这会丢弃数组的第一个元素，`@a`数组变成了`(line2, line3, line4, line5)`。

一个更简单的写法是使用`shift`：

```
perl -ne 'push @a, $_; shift @a if @a>10; END { print @a }' *file*
```

这个单行代码不需要对`@a`进行切片，因为你可以保证，如果`@a > 10`，那么`@a == 11`。`shift`是一个操作符，用于移除数组的第一个元素。所以在这个循环中，当你有超过 10 行时，你可以简单地移除存储的第一行。

## 7.5 打印匹配正则表达式的行

```
perl -ne '/*regex*/ && print'
```

这个单行代码测试当前行是否匹配`/regex/`。如果匹配成功，`/regex/`的匹配就会成功，并且调用`print`。

你可以用`if`来替代`&&`，反转`/regex/`和`print`语句：

```
perl -ne 'print if /*regex*/'
```

## 7.6 打印不匹配正则表达式的行

```
perl -ne '!/*regex*/ && print'
```

这段单行代码是对前面那段单行代码的反转。这里，我通过`!`操作符反转匹配，测试该行是否不匹配`/regex/`。如果不匹配，我调用`print`来打印该行。

你也可以反过来写：

```
perl -ne 'print if !/*regex*/'
```

你也可以使用`unless`代替`if !`：

```
perl -ne 'print unless /*regex*/'
```

另一种写法是将德摩根定律应用到`!/regex/ && print`：

```
perl -ne '/*regex*/ || print'
```

## 7.7 打印每一行，前面有匹配正则表达式的行

```
perl -ne '/*regex*/ && $last && print $last; $last = $_'
```

这段单行代码会在匹配`/regex/`的行上面打印一行。我们从最后一个语句`$last = $_`开始，它将每一行保存到`$last`变量中。假设下一行被读取并且匹配了`/regex/`。由于上一行已保存在`$last`中，这段单行代码会直接打印出来。`&&`系列操作符的意思是，首先正则表达式必须匹配，其次`$last`必须为真值。（空行仍然会被打印，因为它们包含换行符。）

假设你有一个包含四行的文件：

```
hello world
magic line
bye world
magic line
```

如果你想打印所有匹配`magic`的行上方的行，可以这样做：

```
perl -ne '/magic/ && $last && print $last; $last = $_'
```

该单行代码将打印：

```
hello world
bye world
```

## 7.8 打印每一行，前面紧跟着匹配正则表达式的行

```
perl -ne 'if ($p) { print; $p = 0 } $p++ if /*regex*/'
```

在这里，我将变量`$p`设置为 1，如果当前行匹配正则表达式。变量`$p`为 1 表示下一行应该被打印。现在，当下一行被读取并且`$p`被设置时，当前行会被打印，`$p`会被重置为 0。非常简单。

假设你有这样一个四行的文件：

```
science
physics
science
math
```

如果你想打印所有匹配`science`的行下方的行，可以这样做：

```
perl -ne 'if ($p) { print; $p = 0 } $p++ if /science/'
```

该单行代码将打印：

```
physics
math
```

如果你想使用`&&`来编写这段代码并避免使用`if`和大括号，可以这样做：

```
perl -ne '$p && print && ($p = 0); $p++ if /science/'
```

你也可以聪明地简化这段单行代码，变成以下内容：

```
perl -ne '$p && print; $p = /science/'
```

如果当前行匹配`science`，则变量`$p`被设置为真值，下一行将被打印。如果当前行不匹配`science`，则`$p`变为未定义，下一行不被打印。

## 7.9 打印以任意顺序匹配正则表达式 AAA 和 BBB 的行

```
perl -ne '/*AAA*/ && /*BBB*/ && print'
```

这段单行代码测试一行是否同时匹配两个正则表达式。如果一行同时匹配`/AAA/`和`/BBB/`，它就会被打印。具体来说，这段单行代码会打印包含`*AAA*`和`*BBB*`的行，例如`foo AAA bar BBB baz`，但不会打印`foo AAA bar AAA`，因为它不包含`*BBB*`。

## 7.10 打印不匹配正则表达式 AAA 和 BBB 的行

```
perl -ne '!/*AAA*/ && !/*BBB*/ && print'
```

这段单行代码几乎与之前的一模一样。这里，我测试一行是否不匹配两个正则表达式。如果它既不匹配`/AAA/`也不匹配`/BBB/`，它就会被打印。

## 7.11 打印匹配正则表达式 AAA 后接 BBB 再接 CCC 的行

```
perl -ne '/*AAA*.**BBB*.**CCC*/ && print'
```

在这里，我将正则表达式 `AAA`、`BBB` 和 `CCC` 用 `.*` 连接在一起，`.*` 的意思是“匹配任何东西或什么都不匹配”。如果 `AAA` 后跟 `BBB`，再后跟 `CCC`，该行就会打印。例如，这个单行代码会匹配并打印类似 *123**AAA**880**BBB**222**CCC**、x**AAA**y**BBB**z**CCC*** 和 ***AAABBBCCC*** 这样的字符串。

## 7.12 打印至少 80 个字符的行

```
perl -ne 'print if length >= 80'
```

这个单行代码打印所有至少包含 80 个字符的行。在 Perl 中，有时可以省略函数调用的括号 `()`，所以这里我省略了 `length` 函数的括号。事实上，调用 `length`、`length()` 和 `length($_)` 对于 Perl 来说是等效的。

如果你不想计算行尾，可以通过 `-l` 打开行尾的自动处理：

```
perl -lne 'print if length >= 80'
```

这个开关确保空白行的长度为零，而空白行通常有长度 1 或 2，具体取决于文件格式。（UNIX 换行符的长度为 1；Windows 换行符的长度为 2。）

## 7.13 打印少于 80 个字符的行

```
perl -ne 'print if length() < 80'
```

这个单行代码是前一个的反转。它检查一行的长度是否少于 80 个字符。同样，如果你不想计算行尾，使用 `-l`。

## 7.14 只打印第 13 行

```
perl -ne '$. == 13 && print && exit'
```

正如我在第 70 页的单行代码 7.2 中解释的那样，`$.` 特殊变量表示“当前行号”。因此，如果 `$.` 的值是 13，这个单行代码会打印该行并退出。

## 7.15 打印除第 27 行外的所有行

```
perl -ne '$. != 27 && print'
```

与前一个单行代码类似，这个代码检查当前行的行号是否为 27。如果行号不是 27，它会打印；如果是，它就不打印。

你也可以通过交换 `print` 和 `$. != 27` 并使用 `if` 语句修饰符来实现相同的效果—就像这样：

```
perl -ne 'print if $. != 27'
```

或者你可以使用 `unless`：

```
perl -ne 'print unless $. == 27'
```

## 7.16 只打印第 13、19 和 67 行

```
perl -ne 'print if $. == 13 || $. == 19 || $. == 67'
```

这个单行代码只会打印第 13、19 和 67 行。它不会打印其他行。其工作原理是：如果当前行号（存储在 `$.` 变量中）是 13、19 或 67，它会调用 `print`。你可以使用任何行号来打印特定的行。例如，要打印第 13、19、88、290 和 999 行，你可以这样做：

```
perl -ne 'print if $. == 13 || $. == 19 || $. == 88 || $. == 290 || $. == 999'
```

如果你想打印更多的行，可以将它们放入一个单独的数组中，然后测试 `$.` 是否在这个数组中：

```
perl -ne '
  @lines = (13, 19, 88, 290, 999, 1400, 2000);
  print if grep { $_ == $. } @lines
'
```

这个单行代码使用 `grep` 测试当前行 `$.` 是否在 `@lines` 数组中。如果当前行号在 `@lines` 数组中找到，`grep` 函数会返回一个包含当前行号的元素列表，并且这个列表的值为真。如果当前行号不在 `@lines` 数组中，`grep` 函数会返回一个空列表，值为假。

## 7.17 打印第 17 到 30 行的所有行

```
perl -ne 'print if $. >= 17 && $. <= 30'
```

在这个单行代码中，`$.` 变量代表当前行号。因此，单行代码检查当前行号是否大于等于 17 且小于等于 30。

你也可以使用翻转操作符执行相同的操作，翻转操作符在第 7.2 节的第 70 页中有说明。当与整数一起使用时，翻转操作符作用于`$.`：

```
perl -ne 'print if 17..30'
```

## 7.18 打印两个正则表达式之间的所有行（包括匹配的行）

```
perl -ne 'print if /*regex1*/../*regex2*/'
```

这一行代码使用了翻转操作符（在第 7.2 节的第 70 页中有说明）。当与整数一起使用时，操作数会与`$.`变量进行比较。当与正则表达式一起使用时，操作数会与当前行进行比较，当前行存储在`$_`变量中。操作符最初返回`false`。当一行与`regex1`匹配时，操作符翻转并开始返回`true`，直到另一行与`regex2`匹配。此时，操作符最后一次返回`true`，然后翻转回`false`状态。从此以后，操作符将一直返回`false`。因此，这一行代码打印所有在`regex1`和`regex2`匹配的行之间（包括匹配的行）。

## 7.19 打印最长的行

```
perl -ne '
  $l = $_ if length($_) > length($l);
  END { print $l }
'
```

这一行代码将迄今为止看到的最长行保存在`$l`变量中。如果当前行`$_`的长度超过了最长行的长度，则将`$l`中的值替换为当前行的值。在程序结束前，`END`块会被执行，并打印保存在`$l`中的最长行值。

如果你想防止换行符计入行长，请记得使用`-l`选项。

## 7.20 打印最短的行

```
perl -ne '
  $s = $_ if $. == 1;
  $s = $_ if length($_) < length($s);
  END { print $s }
'
```

这一行代码是上一行的相反操作。因为它查找的是最短的行，并且对于第一行，`$s`尚未定义，你需要显式地通过`$s = $_ if $. == 1`将其值设置为第一行。然后它就简单地执行与上一行代码相反的操作。也就是说，它检查当前行是否是迄今为止最短的行，如果是，就将其赋值给`$s`。

## 7.21 打印所有包含数字的行

```
perl -ne 'print if /\d/'
```

这行代码使用正则表达式`\d`（表示“一个数字”）来检查一行是否包含数字。如果包含，检查成功，行就会被打印。例如，这一行会被打印，因为它包含数字：

```
coding is as easy as 123
```

然而，这一行不会被打印，因为它不包含数字：

```
coding is as easy as pie
```

## 7.22 打印所有只包含数字的行

```
perl -ne 'print if /^\d+$/'
```

在这一行代码中，正则表达式`^\d+$`表示“如果一行从头到尾只包含数字，则匹配该行”。例如，这一行会被打印，因为它只包含数字：

```
3883737189170238912377
```

然而，这一行不会被打印，因为它还包含一些字符：

```
8388338 foo bar random data 999
```

你也可以反转`^\d$`的正则表达式，改用`\D`：

```
perl -lne 'print unless /\D/'
```

这个单行代码非常适合培养你的逻辑推理能力，因为它使用了两次逻辑否定。在这里，只有当一行*不*包含非数字字符时，行才会被打印。换句话说，只有当所有字符都是数字时，它才会打印。（注意，我在这个单行代码中使用了`-l`命令行参数，因为行末有换行符。如果我不使用`-l`，那么这一行就会包含换行符—一个非数字字符—因此不会被打印。）

## 7.23 打印所有只包含字母字符的行

```
perl -ne 'print if /^[[:alpha:]]+$/
```

这个单行代码检查一行是否只包含字母字符。如果是，它会打印该行。`[[:alpha:]]`表示“任何字母字符”。而`[[:alpha:]]+`表示“所有字母字符”。

## 7.24 打印每隔一行

```
perl -ne 'print if $. % 2'
```

这个单行代码打印第一、第三、第五、第七行（依此类推）。它之所以这样做，是因为`$. % 2`在当前行号为奇数时为真，在当前行号为偶数时为假。

## 7.25 从第二行开始打印每隔一行

```
perl -ne 'print if $. % 2 == 0'
```

这个单行代码类似于前一个，只是它打印第二、第四、第六、第八行（依此类推），因为`$. % 2 == 0`在当前行号为偶数时为真。

或者，你可以简单地反转前一个例子中的测试条件：

```
perl -ne 'print unless $. % 2'
```

## 7.26 只打印所有重复的行一次

```
perl -ne 'print if ++$a{$_} == 2'
```

这个单行代码跟踪它已经看到的行，并计算每行出现的次数。如果它第二次看到一行，它会打印该行，因为`++$a{$_} == 2`为真。如果它看到一行超过两次，它就什么也不做，因为该行的计数大于 2。

## 7.27 打印所有唯一的行

```
perl -ne 'print unless $a{$_}++'
```

这个单行代码只有在该行的哈希值`$a{$_}`为假时才打印该行。每次 Perl 读取一行时，它会增加`$a{$_}`的值，从而确保这个单行代码只打印从未出现过的行。
