## 第四章 计算

本章将介绍各种用于计算的一行代码，如查找最小值和最大值、计数、打乱和排列单词，以及计算日期和数字。你还将了解`-a`、`-M`和`-F`命令行参数、`$`特殊变量，以及`@{[ ... ]}`构造，它允许你在双引号内运行代码。

## 4.1 检查一个数字是否是质数

```
perl -lne '(1x$_) !~ /¹?$|^(11+?)\1+$/ && print "$_ is prime"'
```

这行代码使用了 Abigail 巧妙的正则表达式来检测给定的数字是否是质数。（不要把这个正则表达式当真；我把它放在这里是为了其艺术价值。如果是严肃的用途，请使用 CPAN 的`Math::Primality`模块来判断一个数字是否是质数。）

这是这个巧妙的一行代码的工作原理：首先，数字通过`(1x$_)`转换成其一元表示法。例如，`5`被转换为`1x5`，即`11111`（`1`重复`5`次）。接下来，一元数字会被测试是否与正则表达式匹配。如果不匹配，则该数字是质数；否则，它是合成数。`!~`运算符是`=~`运算符的反义，如果正则表达式不匹配，则返回 true。

正则表达式由两部分组成：第一部分`¹?$`匹配`1`和空字符串。显然，空字符串和 1 都不是质数，因此这一部分的正则表达式会将它们排除。

第二部分`^(11+?)\1+$`决定了两个或更多的`1`是否重复构成整个数字。如果是，正则表达式匹配，意味着该数字是合成数。如果不是，它是质数。

现在考虑正则表达式的第二部分如何作用于数字 5。数字 5 的一元表示法是 11111，因此`(11+?)`匹配前两个`1`，回溯引用`\1`变成 11，整个正则表达式变为`¹¹(11)+$`。由于它无法匹配五个`1`，所以失败。接下来，它尝试匹配前三个`1`。回溯引用变为 111，整个正则表达式变为`¹¹¹(111)+$`，仍然不匹配。该过程对 1111 和 11111 也重复，最终整个正则表达式没有匹配，说明该数字是质数。

那么数字 4 呢？数字 4 在一元表示法中是 1111。`(11+?)`匹配前两个`1`。回溯引用`\1`变成 11，整个正则表达式变为`¹¹(11)+$`，匹配原始字符串并确认该数字不是质数。

## 4.2 打印每行所有字段的总和

```
perl -MList::Util=sum -alne 'print sum @F'
```

这个单行命令通过`-a`命令行选项打开字段*自动分割*，并通过`-Mlist::Util=sum`导入`List::Util`模块的`sum`函数。 (`List::Util`是 Perl 的核心模块之一，所以你不需要安装它。）自动分割默认发生在空白字符上，结果字段会被放入`@F`变量中。例如，行`1 4 8`会按空格分割，使得`@F`变成`(1, 4, 8)`。`sum @F`语句将求和`@F`数组中的元素，得到`13`。

`-Mmodule=arg`选项从`module`导入`arg`。它等同于写成

```
use module qw(arg);
```

这个单行命令相当于

```
use List::Util qw(sum);
while (<>) {
    @F = split(' ');
    print sum @F, "\n";
}
```

你可以通过为`-F`命令行开关指定一个参数来改变自动分割的默认行为。假设你有以下一行：

```
1:2:3:4:5:6:7:8:9:10
```

如果你希望找到所有这些数字的总和，可以简单地将`:`指定为`-F`开关的参数，像这样：

```
perl -MList::Util=sum -F: -alne 'print sum @F'
```

这将按冒号字符分割行并求和所有的数字。输出是`55`，因为这是从 1 到 10 的数字之和。

## 4.3 打印所有行中所有字段的总和

```
perl -MList::Util=sum -alne 'push @S,@F; END { print sum @S }'
```

这个单行命令不断将分割后的字段推送到`@S`数组中。当输入结束且 Perl 准备退出时，`END { }`代码块会被执行，并输出`@S`中所有项目的总和。这样会对所有行中的所有字段求和。

请注意，如何将`@F`数组推送到`@S`数组实际上是将元素附加到它。与许多其他编程语言不同，推送数组 1 到数组 2 会将数组 1 放入数组 2 中，而不是将数组 1 的元素附加到数组 2 中。Perl 默认执行列表展平。

不幸的是，使用这个方法对所有行的所有字段求和会创建一个庞大的`@S`数组。一个更好的解决方法是只保留运行时的和，像这样：

```
perl -MList::Util=sum -alne '$s += sum @F; END { print $s }'
```

在这里，每一行被分割成`@F`，然后将值求和并存储在运行时的和变量`$s`中。一旦所有输入被处理完，单行命令会打印出`$s`的值。

## 4.4 将每一行的所有字段洗牌

```
perl -MList::Util=shuffle -alne 'print "@{[shuffle @F]}"'
```

这个单行命令最棘手的部分是`@{[shuffle @F]}`构造。这个构造允许你执行引号内的代码。通常，文本和变量会放入引号中，但使用`@{[ ... ]}`构造，你也可以运行代码。

在这个单行命令中，执行的代码是`shuffle @F`，它对字段进行洗牌并返回洗牌后的列表。`[shuffle @F]`创建了一个包含洗牌字段的数组引用，`@{ ... }`则是解除引用。你只需创建一个引用并立即解除引用。这使得你能够执行引号内的代码。

让我们看几个例子，理解为什么我选择在引号内执行代码。如果我写了`print shuffle @F`，那么行中的字段会被连接起来。对比一下这个单行命令的输出：

```
$ echo a b c d | perl -MList::Util=shuffle -alne 'print "@{[shuffle @F]}"'
b c d a
```

转换成：

```
$ echo a b c d | perl -MList::Util=shuffle -alne 'print shuffle @F'
bcda
```

在第一个例子中，打乱顺序的字段数组（双引号内）会被插值，并且数组元素用空格分隔，因此输出为`b c d a`。在第二个例子中，插值没有发生，Perl 会逐个输出元素，而不进行分隔，输出为`bcda`。

你可以使用`$`这个特殊变量来改变打印时数组元素之间的分隔符。例如，当我将分隔符更改为冒号时，会发生以下情况：

```
$ echo a b c d | perl -MList::Util=shuffle -alne '$,=":"; print shuffle @F'
b:c:d:a
```

你还可以使用`join`函数通过空格连接`@F`中的元素：

```
perl -MList::Util=shuffle -alne 'print join " ", shuffle @F'
```

在这里，`join`函数使用给定的分隔符连接数组的元素，而`@{[ ... ]}`结构是实现这一操作最简洁的方式。

## 4.5 找出每行中数值最小的元素（最小元素）

```
perl -MList::Util=min -alne 'print min @F'
```

这个一行代码与前面的例子有些相似。它使用了`List::Util`中的`min`函数。一旦通过`-a`自动拆分行并将元素存入`@F`数组，`min`函数就能找到数值最小的元素并打印出来。

例如，如果你有一个文件包含以下行：

```
-8  9  10 5
7   0  9  3
5  -25 9  999
```

运行这行代码会产生以下输出：

```
-8
0
-25
```

第一行的最小数字是`-8`；第二行的最小数字是`0`；第三行的最小数字是`-25`。

## 4.6 找出所有行中数值最小的元素（最小元素）

```
perl -MList::Util=min -alne '@M = (@M, @F); END { print min @M }'
```

这行代码结合了 4.3 和 4.5 的代码。`@M = (@M, @F)`结构等同于`push @M, @F`。它将`@F`的内容附加到`@M`数组中。

这个一行代码将所有数据存储在内存中，如果你在一个非常大的文件上运行它，Perl 可能会耗尽内存。最好的方法是找出每一行的最小元素，并将该元素与前一行的最小元素进行比较。如果当前行的元素小于前一行的元素，那么它就是目前为止最小的元素。处理完所有行后，你可以通过`END`块打印出找到的最小元素：

```
perl -MList::Util=min -alne '
  $min = min @F;
  $rmin = $min unless defined $rmin && $min > $rmin;
  END { print $rmin }
'
```

在这里，你首先找到当前行的最小元素并将其存储在`$min`中。然后检查当前行的最小元素是否是迄今为止最小的元素。如果是，就将它赋值给`$rmin`。当你遍历完所有行后，`END`块会执行并打印出`$rmin`。

假设你的文件包含以下行：

```
-8  9  10 5
7   0  9  3
5  -25 9  999
```

运行这行代码会输出`-25`，因为这是文件中最小的数字。

如果你使用的是 Perl 5.10 或更高版本，你可以通过以下一行代码实现相同的功能：

```
perl -MList::Util=min -alne '$min = min($min // (), @F); END { print $min }'
```

这个单行代码使用了 `//` 运算符，这是 Perl 5.10 新增的运算符。这个运算符类似于逻辑 OR 运算符 (`||`)，不同之处在于它测试的是左边的定义性而非真假值。这意味着它测试左边是否已定义，而不是是否为真或假。在这个单行代码中，表达式 `$min // ()` 如果 `$min` 已定义，则返回 `$min`，否则返回一个空列表 `()`。`//` 运算符避免了你使用 `defined` 来测试定义性。

考虑当这个单行代码在前面的文件上运行时会发生什么。首先，Perl 读取行 `-8 9 10 5`，将其拆分并将数字放入 `@F` 数组中。此时，`@F` 数组变为 `(-8, 9, 10, 5)`。接着，它执行 `$min = min ($min // (), @F)`。由于 `$min` 尚未定义，`$min // ()` 解析为 `()`，所以整个表达式变为 `$min = min ((), (-8, 9, 10, 5))`。

Perl 设计上就支持列表扁平化，因此在将参数传递给 `min` 函数时，表达式变成了 `$min = min(-8, 9, 10, 5)`。这定义了 `$min`，并将其设置为 `-8`。Perl 继续执行下一行，在这一行中，它将 `@F` 设置为 `(7, 0, 9, 3)`，然后再次求值 `$min = min($min // (), @F)`。因为 `$min` 已经定义，所以 `$min // ()` 会被解析为 `$min`，表达式变成 `$min = min(-8, 7, 0, 9, 3)`。此时，`-8` 仍然是最小的元素，所以 `$min` 保持为 `-8`。最后，Perl 读取最后一行，执行 `$min = min(-8, 5, -25, 9, 999)`，发现 `-25` 是文件中的最小元素。

## 4.7 找到每行的数值最大元素（最大元素）

```
perl -MList::Util=max -alne 'print max @F'
```

这与单行代码 4.5 的作用相同，唯一不同的是将 `min` 替换为 `max`。

## 4.8 找到所有行的数值最大元素（最大元素）

```
perl -MList::Util=max -alne '@M = (@M, @F); END { print max @M }'
```

这个单行代码与单行代码 4.6 和 4.7 类似。在这个单行代码中，每一行都会自动拆分并放入 `@F` 数组中，然后该数组会与 `@M` 数组合并。当输入处理完毕后，`END` 块执行，并打印出最大元素。

这是另一种找到最大元素的方法，它只保留当前的最大元素，而不是将所有元素保存在内存中：

```
perl -MList::Util=max -alne '
  $max = max @F;
  $rmax = $max unless defined $rmax && $max < $rmax;
  END { print $rmax }
'
```

如果你使用的是 Perl 5.10 或更高版本，可以使用 `//` 运算符来简化这个单行代码：

```
perl -MList::Util=max -alne '$max = max($max // (), @F); END { print $max }'
```

这与单行代码 4.6 相同，唯一不同的是将 `min` 替换为 `max`。

## 4.9 将每个字段替换为其绝对值

```
perl -alne 'print "@{[map { abs } @F]}"'
```

这个单行代码首先使用 `-a` 选项自动拆分该行。拆分后的字段会存储在 `@F` 变量中。接着，它使用 `map` 函数对每个字段调用绝对值函数 `abs`。本质上，`map` 函数会将给定的函数应用到列表的每个元素，并返回一个包含应用该函数结果的新列表。例如，如果列表 `@F` 是 `(-4, 2, 0)`，对其进行 `abs` 映射后会得到列表 `(4, 2, 0)`。最后，这个单行代码会打印出新列表中的正值。

`@{[ ... ]}` 结构，介绍于一行代码 4.4，允许你执行引号内的代码。

## 4.10 打印每行的字段总数

```
perl -alne 'print scalar @F'
```

这个一行代码强制在标量上下文中求值 `@F`，在 Perl 中这意味着“`@F` 中的元素数量”。因此，它打印每行中的元素数量。

例如，如果你的文件包含以下几行：

```
foo bar baz
foo bar
baz
```

运行这个一行代码将产生以下输出：

```
3
2
1
```

第一行有三个字段，第二行有两个字段，最后一行有一个字段。

## 4.11 打印每行的字段总数，后跟该行内容

```
perl -alne 'print scalar @F, " $_"'
```

这个一行代码和一行代码 4.10 相同，只是在末尾添加了 `$_`，它打印整行内容。（记住，`-n` 会将每一行放入 `$_` 变量中。）

让我们在和一行代码 4.10 相同的示例文件上运行这个一行代码：

```
foo bar baz
foo bar
baz
```

运行这个一行代码将产生以下输出：

```
3 foo bar baz
2 foo bar
1 baz
```

## 4.12 打印所有行的字段总数

```
perl -alne '$t += @F; END { print $t }'
```

在这里，这行代码将每行的字段数累加到变量 `$t` 中，直到所有行都被处理完。接下来，它打印结果，结果包含所有行的单词数量。注意，你将 `@F` 数组添加到标量变量 `$t` 中。由于 `$t` 是标量，`@F` 数组在标量上下文中求值并返回它所包含的元素数量。

在以下文件上运行这个一行代码：

```
foo bar baz
foo bar
baz
```

输出数字 `6`，因为该文件总共包含六个单词。

## 4.13 打印匹配模式的字段总数

```
perl -alne 'map { /*regex*/ && $t++ } @F; END { print $t || 0 }'
```

这个一行代码使用 `map` 对 `@F` 数组中的每个元素应用操作。在这个示例中，操作检查每个元素是否匹配 `/regex/`，如果匹配，则增加 `$t` 变量。然后它打印 `$t` 变量，其中包含匹配 `/regex/` 模式的字段数量。`$t || 0` 结构是必要的，因为如果没有字段匹配，`$t` 将不存在，所以必须提供一个默认值。你可以提供任何其他默认值，甚至是字符串，而不是 `0`！

循环会是一个更好的方法：

```
perl -alne '$t += /*regex*/ for @F; END { print $t }'
```

在这里，`@F` 中的每个元素都与 `/regex/` 进行测试。如果匹配，`/regex/` 返回真；否则返回假。当按数值使用时，真转化为 `1`，假转化为 `0`，因此 `$t += /regex/` 会将 `1` 或 `0` 加到 `$t` 变量中。结果是，匹配的数量被计入 `$t`。在 `END` 块中打印结果时不需要默认值，因为无论字段是否匹配，`+=` 操作符都会执行。你总会得到一个值，有时这个值会是 `0`。

另一种做法是使用在标量上下文中的 `grep`：

```
perl -alne '$t += grep /*regex*/, @F; END { print $t }'
```

在这里，`grep` 返回匹配的数量，因为它在标量上下文中被求值。在列表上下文中，`grep` 返回所有匹配的元素，但在标量上下文中，它返回匹配元素的数量。这个数字会累计到 `$t` 中，并在 `END` 块中打印。在这种情况下，你不需要为 `$t` 提供默认值，因为 `grep` 在这些情况下会返回 `0`。

## 4.14 打印匹配模式的行数

```
perl -lne '/*regex*/ && $t++; END { print $t || 0 }'
```

在这里，`/regex/` 如果当前输入行匹配这个正则表达式，则评估为真。写 `/regex/ && $t++` 就等同于写 `if ($_ =~ /regex/) { $t++ }`，它会在行匹配指定模式时递增 `$t` 变量。在 `END` 块中，`$t` 变量包含模式匹配的总次数并被打印；但是如果没有匹配的行，`$t` 会再次未定义，因此你必须打印一个默认值。

## 4.15 打印数字 π

```
perl -Mbignum=bpi -le 'print bpi(21)'
```

`bignum` 包导出了 `bpi` 函数，用于按所需精度计算 π 常数。这个一行代码将 π 打印到 20 位小数。（注意，你需要指定 `n+1` 才能将其精确到 `n` 位。）

`bignum` 库还导出了常数 π，已预计算到 39 位小数：

```
perl -Mbignum=PI -le 'print PI'
```

## 4.16 打印数字 *e*

```
perl -Mbignum=bexp -le 'print bexp(1,21)'
```

`bignum` 库导出了 `bexp` 函数，它接受两个参数：要将 *e* 提高的幂数和所需的精度。这个一行代码将常数 *e* 打印到 20 位小数。

例如，你可以打印 *e*² 的值，精确到 30 位小数：

```
perl -Mbignum=bexp -le 'print bexp(2,31)'
```

与 π 相似，`bignum` 也导出了常数 *e*，并已预计算到 39 位小数：

```
perl -Mbignum=e -le 'print e'
```

## 4.17 打印 UNIX 时间（自 1970 年 1 月 1 日 00:00:00 UTC 起的秒数）

```
perl -le 'print time'
```

内置的 `time` 函数返回自纪元以来的秒数。这个一行代码仅打印当前时间。

## 4.18 打印格林威治标准时间和本地计算机时间

```
perl -le 'print scalar gmtime'
```

`gmtime` 函数是一个内置的 Perl 函数。当在标量上下文中使用时，它返回本地化为格林威治标准时间（GMT）的时间。

内置的 `localtime` 函数与 `gmtime` 类似，不同之处在于，当在标量上下文中使用时，它返回计算机的本地时间：

```
perl -le 'print scalar localtime'
```

在列表上下文中，`gmtime` 和 `localtime` 都返回一个包含九个元素的列表（UNIX 程序员称之为 `struct tm`），其中包含以下元素：

```
($second,             [0]
$minute,              [1]
$hour,                [2]
$month_day,           [3]
$month,               [4]
$year,                [5]
$week_day,            [6]
$year_day,            [7]
$is_daylight_saving   [8]
)
```

你可以 *切片* 这个列表（即从中提取元素），或者如果只需要其中的一部分信息，可以打印单个元素。例如，要打印 `H:M:S`，可以从 `localtime` 中切片元素 `2`、`1` 和 `0`，如下所示：

```
perl -le 'print join ":", (localtime)[2,1,0]'
```

要单独切片元素，可以指定一个要提取的元素列表，例如 `[2,1,0]`。或者按范围切片：

```
perl -le 'print join ":", (localtime)[2..6]'
```

这行代码打印小时、日期、月份、年份和星期几。

你也可以使用负索引从列表的另一端选择元素：

```
perl -le 'print join ":", (localtime)[-2, -3]'
```

这个一行代码打印元素 `7` 和 `6`，它们分别是年份中的第几天（例如，第 200 天）和星期几（例如，第 4 天）。

## 4.19 打印昨天的日期

```
perl -MPOSIX -le '
  @now = localtime;
  $now[3] -= 1;
  print scalar localtime mktime @now
'
```

记住，`localtime`返回一个包含九个元素的列表（参见一行代码 4.18），这些元素是各种日期信息。列表中的第四个元素是当前月的日期。如果从这个元素中减去 1，你将得到昨天的日期。

`mktime`函数根据这个修改过的九元素列表构建 UNIX 纪元时间，而`scalar localtime`结构打印出新的日期，即昨天。这行代码在一些极端情况下也能正常工作，比如当前日期是月初时。你需要`POSIX`包，因为它导出了`mktime`函数。

例如，如果现在是*Mon May 20 05:49:55*，运行这行代码将打印出*Sun May 19 05:49:55*。

## 4.20 打印出 14 个月、9 天和 7 秒前的日期

```
perl -MPOSIX -le '
  @now = localtime;
  $now[0] -= 7;
  $now[3] -= 9;
  $now[4] -= 14;
  print scalar localtime mktime @now
'
```

这行代码修改了`@now`列表中的第一个、第四个和第五个元素。第一个元素是秒，第四个是天，第五个是月。`mktime`命令根据这个新的结构生成 UNIX 时间，而在标量上下文中计算的`localtime`则打印出 14 个月、9 天和 7 秒前的日期。

## 4.21 计算阶乘

```
perl -MMath::BigInt -le 'print Math::BigInt->new(5)->bfac()'
```

这行代码使用了`Math::BigInt`模块中的`bfac()`函数（即 Perl 核心自带，无需安装）。`Math::BigInt->new(5)`构造创建了一个值为`5`的`Math::BigInt`对象，接着调用该对象的`bfac()`方法来计算`5`的阶乘。将`5`改为任何你想要的数字来找到它的阶乘。

计算阶乘的另一种方法是将 1 到*n*的数字相乘：

```
perl -le '$f = 1; $f *= $_ for 1..5; print $f'
```

在这里，我将`$f`设置为`1`，然后从`1`循环到`5`，并将`$f`乘以每个值。结果是`120`（`1*2*3*4*5`），即 5 的阶乘。

## 4.22 计算最大公约数

```
perl -MMath::BigInt=bgcd -le 'print bgcd(@list_of_numbers)'
```

`Math::BigInt`有几个其他有用的数学函数，包括`bgcd`，它计算一组数字的*最大公约数（gcd）*。例如，要找到`(20, 60, 30)`的最大公约数，可以像这样执行这行代码：

```
perl -MMath::BigInt=bgcd -le 'print bgcd(20,60,30)'
```

要从文件或用户输入中计算最大公约数，可以使用`-a`命令行参数，并将`@F`数组传递给`bgcd`函数：

```
perl -MMath::BigInt=bgcd -anle 'print bgcd(@F)'
```

（我在一行代码 4.2 中解释了`-a`参数和`@F`数组，见第 30 页。）

你也可以使用欧几里得算法来找到`$n`和`$m`的最大公约数。这行代码正是做了这件事，并将结果存储在`$m`中：

```
perl -le '
  $n = 20; $m = 35;
  ($m,$n) = ($n,$m%$n) while $n;
  print $m
'
```

欧几里得算法是最古老的求最大公约数算法之一。

## 4.23 计算最小公倍数

*最小公倍数（lcm）*函数`blcm`包含在`Math::BigInt`中。使用这行代码来找到`(35, 20, 8)`的最小公倍数：

```
perl -MMath::BigInt=blcm -le 'print blcm(35,20,8)'
```

要从包含数字的文件中找到最小公倍数，可以使用`-a`命令行开关和`@F`数组：

```
perl -MMath::BigInt=blcm -anle 'print blcm(@F)'
```

如果你知道一些数论知识，可能会记得最大公约数和最小公倍数之间是有关系的。给定两个数字`$n`和`$m`，你知道它们的最小公倍数是`$n*$m/gcd($n,$m)`。因此，这行代码如下所示：

```
perl -le '
  $a = $n = 20;
  $b = $m = 35;
  ($m,$n) = ($n,$m%$n) while $n;
  print $a*$b/$m
'
```

## 4.24 生成 5 到 15 之间（不包括 15）的 10 个随机数

```
perl -le 'print join ",", map { int(rand(15-5))+5 } 1..10'
```

这行代码打印了 10 个介于 5 和 15 之间的随机数。看起来可能很复杂，但其实很简单。`int(rand(15-5))`其实就是`int(rand(10))`，它返回一个从 0 到 9 之间的随机整数。加上`5`后，它返回一个从 5 到 14 之间的随机整数。范围`1..10`使得它生成 10 个随机整数。

你也可以将这个一行代码写得更详细一些：

```
perl -le '
  $n=10;
  $min=5;
  $max=15;
  $, = " ";
  print map { int(rand($max-$min))+$min } 1..$n;
'
```

在这里，所有的变量都更为明确。要修改这个一行代码，可以更改变量`$n`、`$min`和`$max`。`$n`变量表示要生成多少个随机数，而`$min-$max`是生成随机数时的范围。

`$`变量被设置为空格，因为它是`print`的输出字段分隔符，默认值是`undef`。如果你没有将`$`设置为空格，数字就会被连接在一起打印。（参见第 32 页的一行代码 4.4，讨论了`$`的用法。）

## 4.25 生成列表的所有排列

```
perl -MAlgorithm::Permute -le '
  $l = [1,2,3,4,5];
  $p = Algorithm::Permute->new($l);
  print "@r" while @r = $p->next
'
```

这行代码使用了`Algorithm::Permute`模块的面向对象接口来找到列表的所有排列，也就是所有重新排列项的方式。`Algorithm::Permute`的构造函数接收一个元素数组的引用，用于排列。在这个特定的一行代码中，元素是数字`1, 2, 3, 4, 5`。

`next`方法返回下一个排列。反复调用它可以遍历所有排列，每个排列都会被放入`@r`数组中并打印出来。（注意：输出的排列列表会迅速变大。对于一个包含`n`个元素的列表，有`n!`（*n*的阶乘）个排列。）

打印所有排列的另一种方式是使用`permute`子例程：

```
perl -MAlgorithm::Permute -le '
  @l = (1,2,3,4,5);
  Algorithm::Permute::permute { print "@l" } @l
'
```

如果你将`@l`更改为仅包含三个元素`(1, 2, 3)`并运行它，得到的结果如下：

```
1 2 3
1 3 2
3 1 2
2 1 3
2 3 1
3 2 1
```

## 4.26 生成幂集

```
perl -MList::PowerSet=powerset -le '
  @l = (1,2,3,4,5);
  print "@$_" for @{powerset(@l)}
'
```

这行代码使用了来自 CPAN 的`List::PowerSet`模块。该模块导出了`powerset`函数，它接收一个元素列表并返回一个数组引用，该数组包含指向子集数组的引用。你可以通过在命令行运行`cpan List::PowerSet`来安装此模块。

在`for`循环中，你调用`powerset`函数并将`@l`的元素列表传递给它。接下来，你取消引用`powerset`的返回值，它是一个包含子集的数组引用，然后再取消引用每个子集`@$_`并打印出来。

*幂集*是所有子集的集合。对于一个包含*n*个元素的集合，幂集中恰好有 2^(*n*)个子集。这里是`(1, 2, 3)`的幂集示例：

```
1 2 3
2 3
1 3
3
1 2
2
1
```

## 4.27 将 IP 地址转换为无符号整数

```
perl -le '
  $i=3;
  $u += ($_<<8*$i--) for "127.0.0.1" =~ /(\d+)/g;
  print $u
'
```

这行代码将 IP 地址`127.0.0.1`转换为一个无符号整数，方法是首先对 IP 地址进行全局匹配`(\d+)`。执行`for`循环遍历全局匹配时，会迭代所有的匹配项，这些匹配项就是 IP 地址的四个部分：`127`、`0`、`0`、`1`。

接下来，匹配结果被加总到`$u`变量中。第一个位移 8 × 3 = 24 位，第二个位移 8 × 2 = 16 位，第三个位移 8 位。最后一个直接加到`$u`中。得到的整数恰好是`2130706433`（一个非常极客的数字）。

这里有更多的单行代码：

```
perl -le '
  $ip="127.0.0.1";
  $ip =~ s/(\d+)\.?/sprintf("%02x", $1)/ge;
  print hex($ip)
'
```

这行代码利用了`127.0.0.1`可以很容易转换为十六进制的事实。在这里，`$ip`与`(\d+)`匹配，每个 IP 部分都通过`sprintf("%02x", $1)`在`s`操作符内转换为十六进制数字。`s`操作符的`/e`标志使得替换部分作为 Perl 表达式进行求值。结果，`127.0.0.1`被转换为`7f000001`，然后通过 Perl 的`hex`操作符将其解释为十六进制数，并转换为十进制数。

你还可以使用`unpack`：

```
perl -le 'print unpack("N", 127.0.0.1)'
```

这行代码可能是尽可能简短的了。它使用了*vstring 字面量*（版本字符串）来表示 IP 地址。vstring 是由指定的序号值组成的字符串字面量。新形成的字符串字面量被解包为网络字节顺序（大端顺序）的数字，并被打印出来。

如果你有一个包含 IP 的字符串（而不是 vstring），你首先需要使用`inet_aton`函数将其转换为字节形式：

```
perl -MSocket -le 'print unpack("N", inet_aton("127.0.0.1"))'
```

在这里，`inet_aton`将字符串`127.0.0.1`转换为字节形式（等同于纯粹的 vstring `127.0.0.1`），然后`unpack`将其解包，就像前面的单行代码那样。

## 4.28 将无符号整数转换为 IP 地址

```
perl -MSocket -le 'print inet_ntoa(pack("N", 2130706433))'
```

在这里，整数`2130706433`被打包成大端字节顺序的数字，然后传递给`inet_ntoa`函数，该函数将数字转换回 IP 地址。（注意，`inet_ntoa`是`inet_aton`的反向操作。）

你也可以这样做：

```
perl -le '
  $ip = 2130706433;
  print join ".", map { (($ip>>8*($_))&0xFF) } reverse 0..3
'
```

在这里，`$ip`首先向右移动 24 位，然后与`0xFF`进行按位与运算，生成 IP 的第一部分，即`127`。接着，向右移动 16 位并与`0xFF`按位与，得到`0`，然后再向右移动 8 位并与`0xFF`按位与，得到另一个`0`。最后，整个数字与`0xFF`按位与，得到`1`。

`map { ... }`的结果是一个列表`(127, 0, 0, 1)`。这个列表现在通过点号`"."`连接，生成 IP 地址`127.0.0.1`。

你可以用特殊变量`$`替代`join`，它在`print`语句中充当值分隔符：

```
perl -le '
  $ip = 2130706433;
  $, = ".";
  print map { (($ip>>8*($_))&0xFF) } reverse 0..3
'
```

因为`reverse 0..3`与`3,2,1,0`相同，所以你也可以写成：

```
perl -le '
  $ip = 2130706433;
  $, = ".";
  print map { (($ip>>8*($_))&0xFF) } 3,2,1,0
'
```
