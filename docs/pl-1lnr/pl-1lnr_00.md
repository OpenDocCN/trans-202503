## 第一章：Perl 单行命令入门

Perl 单行命令是小巧而强大的 Perl 程序，能够在一行代码中完成一个任务。它们可以做得非常好——比如更改行间距、给行编号、执行计算、转换和替换文本、删除和打印特定行、解析日志、就地编辑文件、计算统计数据、执行系统管理任务或一次更新多个文件。Perl 单行命令将使你成为一个 Shell 战士：曾经需要几分钟（甚至几小时）才能解决的问题，现在只需几秒钟！

在本章节中，我将向你展示单行命令的样子，并让你尝尝本书其余部分的内容。本书需要一定的 Perl 知识，但大多数单行命令都可以在不深入了解语言的情况下进行调整和修改。

我们来看一些例子。这里是一个例子：

```
perl -pi -e 's/*you*/*me*/g' *file*
```

这个单行命令会将文件`file`中所有的`you`替换为`me`。如果你问我，这非常有用。想象一下，你在一台远程服务器上，需要替换文件中的文本。你可以打开文本编辑器执行查找替换，或者直接通过命令行进行替换，一下子就完成了。

这个单行命令和本书中的其他命令在 UNIX 系统上运行良好。我使用的是 Perl 5.8 来运行它们，但它们也适用于更新版的 Perl，例如 Perl 5.10 及更高版本。如果你在 Windows 计算机上，你需要稍微修改它们。为了让这个单行命令在 Windows 上工作，可以将单引号换成双引号。有关在 Windows 上使用 Perl 单行命令的更多信息，请参见附录 B。

在本书中，我将使用 Perl 的`-e`命令行参数。它允许你使用命令行来指定要执行的 Perl 代码。在前面的单行命令中，代码的意思是“执行替换（`s/you/me/g`命令）并将`you`替换为`me`，全局替换（`/g`标志）。”`-p`参数确保代码在每一行输入上都执行，并且执行后打印该行。`-i`参数确保`file`文件就地编辑。就地编辑（*in-place*）意味着 Perl 会直接在文件中进行所有替换，覆盖你想要替换的内容。我建议你通过在`-i`参数中指定备份扩展名来始终备份你正在编辑的文件，例如：

```
perl -pi.bak -e 's/*you*/*me*/g' *file*
```

现在，Perl 首先创建一个`file.bak`备份文件，然后才修改`file`的内容。

那么，如何在多个文件中进行相同的替换呢？只需在命令行中指定文件：

```
perl -pi -e 's/*you*/*me*/g' *file1 file2 file3*
```

这里，Perl 首先在`file1`中将`you`替换为`me`，然后在`file2`和`file3`中执行相同的操作。

你也可以像这样，只对匹配`we`的行进行相同的替换：

```
perl -pi -e 's/*you*/*me*/g if /*we*/' *file*
```

在这里，你使用条件`if /we/`来确保` s/you/me/g`只在匹配正则表达式`/we/`的行上执行。

正则表达式可以是任何内容。比如你想只对包含数字的行执行替换。你可以使用`/\d/`正则表达式来匹配数字：

```
perl -pi -e 's/*you*/*me*/g if /\d/' *file*
```

如何查找文件中出现超过一次的所有行？

```
perl -ne 'print if $a{$_}++' *file*
```

这个单行命令记录你迄今为止遇到的行，并在`%a`哈希中计数它看到这些行的次数。如果已经见过该行，条件`$a{$_}++`为真，因此它会打印该行。否则，它会“自动”在`%a`哈希中创建一个包含当前行的元素并增加其值。`$_`特殊变量包含当前行。这个单行命令还使用了`-n`命令行参数来遍历输入，但与`-p`不同，它不会自动打印行。 （现在不要担心所有的命令行参数；你会随着本书的学习逐步了解它们！）

如何给行编号？超级简单！Perl 的`$.`特殊变量保持当前行号。只需将其与行一起打印出来：

```
perl -ne 'print "$. $_"' *file*
```

你也可以通过使用`-p`参数并修改`$_`变量来实现同样的功能：

```
perl -pe '$_ = "$. $_"' *file*
```

在这里，每一行都被替换为字符串`"$. $_"`，这等于当前行号后跟该行的内容。（请参阅第 17 页的单行命令 3.1 以获取完整解释。）

如果你省略了单行命令末尾的文件名，Perl 将从标准输入读取数据。从现在开始，我将假设数据来自标准输入，并省略文件名。如果你想在整个文件上运行单行命令，随时可以加回文件名。

你还可以将前面两个单行命令结合起来，创建一个只对重复行编号的命令：

```
perl -ne 'print "$. $_" if $a{$_}++'
```

你还可以使用`List::Util` CPAN 模块中的`sum`函数对每一行的数字进行求和。CPAN（Comprehensive Perl Archive Network；* [`www.cpan.org/`](http://www.cpan.org/) *）是一个包含超过 100,000 个可重用 Perl 模块的档案。`List::Util`是 CPAN 上的一个模块，包含各种列表工具函数。你不需要安装这个模块，因为它已经随 Perl 一起提供（它是 Perl 核心的一部分）。

```
perl -MList::Util=sum -alne 'print sum @F'
```

`-MList::Util`命令行参数导入了`List::Util`模块。这个单行命令中的`=sum`部分导入了`List::Util`模块中的`sum`函数，使得程序能够使用这个函数。接下来，`-a`启用了当前行自动分割成`@F`数组的字段。默认情况下，分割是在空白字符上进行的。`-l`参数确保`print`在每行结束时输出一个换行符。最后，`sum @F`计算`@F`列表中所有元素的总和，`print`打印结果并跟随一个换行符（这是我用`-l`参数添加的）。(请参阅第 30 页的单行命令 4.2 了解更详细的解释。)

如何查找 1299 天前的日期？试试这个：

```
perl -MPOSIX -le
  '@t = localtime; $t[3] -= 1299; print scalar localtime mktime @t'
```

我在一行代码 4.19（第 41 页）中详细解释了这个例子，但基本上，你修改了 `localtime` 返回的结构的第四个元素，这正好是天数。你只需从当前日期减去 1299 天，然后通过 `localtime mktime @t` 重新组合结果成新的时间，并以标量上下文打印结果，显示人类可读的时间。

那么如何生成一个八个字母的密码呢？给你一个：

```
perl -le 'print map { ("a".."z")[rand 26] } 1..8'
```

`"a".."z"` 生成从 *a* 到 *z* 的字母列表（总共 26 个字母）。然后你随机选择一个字母八次！（这个例子在第 51 页的一行代码 5.4 中有详细解释。）

或者，假设你想找到与某个 IP 地址对应的十进制数。你可以使用 `unpack` 很快地找到它：

```
perl -le 'print unpack("N", 127.0.0.1)'
```

这个一行代码使用了 *v-字符串*，即版本字面量。V-字符串提供了一种方法，通过指定的序号来组合字符串。IP 地址 `127.0.0.1` 被视为 v-字符串，这意味着数字 `127`、`0`、`0`、`1` 被连接成一个由四个字符组成的字符串，其中第一个字符的序号值为 127，第二和第三个字符的序号值为 0，最后一个字符的序号值为 1。接下来，`unpack` 将它们解包成一个单一的十进制数字，按照“网络”（大端）顺序进行排列。（更多内容请参见第 45 页的一行代码 4.27）

那么计算呢？让我们找出表格中第一列数字的总和：

```
perl -lane '$sum += $F[0]; END { print $sum }'
```

行会使用 `-a` 参数自动分割成字段，可以通过 `@F` 数组访问。数组的第一个元素 `$F[0]` 就是第一列，所以你只需用 `$sum += $F[0]` 将所有列的值相加。当 Perl 程序完成时，它会执行 `END` 块中的任何代码，在这个例子中就是打印出总和。简单！

现在，让我们找出有多少数据包通过了 `iptables` 规则：

```
iptables -L -nvx | perl -lane '$pkts += $F[0]; END { print $pkts }'
```

`iptables` 程序在第一列输出数据包。你只需要将第一列中的数字相加，就能知道通过防火墙规则的包的数量。虽然 `iptables` 也会输出表头，但你可以安全地忽略这些，因为 Perl 会将它们转换为零，以便进行 `+=` 操作。

如何获取系统中所有用户的列表？

```
perl -a -F: -lne 'print $F[4]' /etc/passwd
```

将 `-a` 和 `-F` 参数结合使用，让你可以指定分割行的字符，默认情况下是空格。在这里，你可以使用冒号字符作为分隔符，正好是 `/etc/passwd` 的记录分隔符。接下来，你打印第五个字段 `$F[4]`，它包含用户的真实姓名。

如果你在命令行参数上迷路了，记住 Perl 配备了一个很棒的文档系统，叫做 *perldoc*。在命令行输入 `perldoc perlrun`，这将显示如何运行 Perl 以及所有命令行参数的文档。当你突然忘记哪个命令行参数做什么，需要快速查找时，这个非常有用。你也可以阅读 *perldoc perlvar*，它解释了变量；*perldoc perlop*，它解释了操作符；以及 *perldoc perlfunc*，它解释了函数。

Perl 一行命令让你能够快速完成许多任务。你将在本书中找到超过 130 个一行命令。阅读它们，尝试它们，没多久你就会成为本地的 Shell 大师。（只是不要告诉你的朋友——除非你想要竞争。）

享受吧！
