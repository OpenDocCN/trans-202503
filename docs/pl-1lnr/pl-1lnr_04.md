## 第五章：处理数组和字符串

在本章中，我们将看一些用于创建字符串和数组的单行命令，用于做一些事情，比如生成密码、创建特定长度的字符串、查找字符的数值以及创建数字数组。你还将学习范围操作符`..`、`x`操作符、`$`特殊变量以及`@ARGV`数组。

## 5.1 生成并打印字母表

```
perl -le 'print a..z'
```

这个单行命令打印了从`a`到`z`的所有字母，结果为`abcdefghijklmnopqrstuvwxyz`。字母是通过范围操作符`..`生成的，当它在列表上下文中用于字符串时（这里由`print`提供），它应用了神奇的自动增量算法，将字符串推进到下一个字符。因此，在这个单行命令中，范围`a..z`的自动增量算法产生了从`a`到`z`的所有字母。

我确实把这个单行命令做得很简洁。如果我使用了`strict`，它就无法工作，因为裸词`a`和`z`。这个版本在语义上更正确：

```
perl -le 'print ("a".."z")'
```

记住，范围操作符`..`会生成一个值的列表。如果你愿意，你可以通过设置`$`特殊变量来打印这些值，并用逗号分隔：

```
perl -le '$, = ","; print ("a".."z")'
```

`$`是字段分隔符。它在每个字段之间由`print`输出。然而，从语义上讲，使用`join`将字母列表用逗号分隔会更具吸引力，因为即使不直接使用`print`，它也能正常工作：

```
perl -le '$alphabet = join ",", ("a".."z"); print $alphabet'
```

这里，`a..z`的列表在打印之前用逗号连接，输出为：

```
a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
```

## 5.2 生成并打印从“a”到“zz”的所有字符串

```
perl -le 'print join ",", ("a".."zz")'
```

这个单行命令再次使用了范围操作符`..`，但这一次，它不像之前的单行命令那样停在`z`。相反，它将`z`前进一个字符，产生`aa`。然后继续进行，产生`ab`、`ac`，依此类推，直到到达`az`。此时，它将字符串推进到`ba`，继续生成`bb`、`bc`，依此类推，直到最终达到`zz`。

你还可以通过这样做来生成所有从`aa`到`zz`的字符串：

```
perl -le 'print join ",", "aa".."zz"'
```

这个单行命令的输出是：

```
aa, ab, ..., az, ba, bb, ..., bz, ca, ..., zz
```

## 5.3 创建十六进制查找表

```
@hex = (0..9, "a".."f")
```

在这个单行命令中，`@hex`数组包含了数字 0、1、2、3、4、5、6、7、8、9 以及字母 a、b、c、d、e、f。你可以使用这个数组将一个数字（在变量`$num`中）从十进制转换为十六进制，使用以下的进制转换公式。（这不是一个单行命令，我加入它是为了说明如何使用`@hex`查找数组。）

```
perl -le '
  $num = 255;
  @hex = (0..9, "a".."f");
  while ($num) {
    $s = $hex[($num % 16)].$s;
    $num = int $num/16;
  }
  print $s
'
```

但是，当然，如果我使用`printf`（或`sprintf`）并使用`%x`格式说明符，转换数字为十六进制会更容易。

```
perl -le 'printf("%x", 255)'
```

要将数字从十六进制转换回十进制，使用`hex`操作符：

```
perl -le '$num = "ff"; print hex $num'
```

`hex`操作符接受一个十六进制字符串（可以以`0x`开头或不以`0x`开头），并将其转换为十进制。

## 5.4 生成一个随机的八字符密码

```
perl -le 'print map { ("a".."z")[rand 26] } 1..8'
```

在这里，`map` 操作符执行代码 `("a".."z")[rand 26]` 八次，因为它会遍历范围 `1..8`。在每次迭代中，代码会从字母表中随机选择一个字母。当 `map` 完成迭代后，它会返回生成的字符列表，`print` 会打印它，从而将所有字符连接起来。

若要在密码中包含数字，可以将 `0..9` 添加到字符列表中，并将 `26` 改为 `36`，因为现在有 `36` 种可能的字符：

```
perl -le 'print map { ("a".."z", 0..9)[rand 36] } 1..8'
```

如果你需要更长的密码，可以将 `1..8` 改为 `1..20`，生成一个 20 个字符长的密码。

## 5.5 创建特定长度的字符串

```
perl -le 'print "a"x50'
```

这个单行代码创建了一个由 50 个字母 `a` 组成的字符串并打印出来。操作符 `x` 是重复操作符。在这里，字母 `a` 被 `x50` 重复 50 次。这个单行代码在你需要为调试或其他任务生成特定数据时非常有用。例如，如果你需要 1KB 的数据，只需执行以下操作：

```
perl -e 'print "a"x1024'
```

我去掉了 `-l` 参数，因为它会输出一个额外的换行符，导致数据量为 1025 字节。

当你在列表上下文中使用重复操作符，并且将一个列表作为第一个操作数时，你会创建一个包含给定元素重复的列表，像这样：

```
perl -le '@list = (1,2)x20; print "@list"'
```

这个单行代码创建了一个包含 20 次 `(1, 2)` 重复的列表，形如 `(1, 2, 1, 2, 1, 2, ...)`。（`x` 左侧的括号表示一个列表。）

## 5.6 从字符串创建数组

```
@months = split ' ', "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec"
```

这里，`@months` 被填充了包含月份名称的字符串中的值。由于所有月份名称由空格分隔，`split` 操作符将它们分割并放入 `@months` 中。因此，`$months[0]` 包含 `Jan`，`$months[1]` 包含 `Feb`，……，`$months[11]` 包含 `Dec`。

你也可以使用 `qw/.../` 操作符做同样的事情：

```
@months = qw/Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec/
```

`qw/.../` 操作符接受一个由空格分隔的字符串，并创建一个数组，其中每个单词都是数组的一个元素。

虽然这本身不是一个单行代码，但这是一个有用的、符合习惯的方式来创建数组，写单行代码时会很有帮助。

## 5.7 从命令行参数创建字符串

```
perl -le 'print "(", (join ",", @ARGV), ")"' *val1 val2 val3*
```

这个单行代码使用了 `@ARGV` 数组，包含了所有传递给 Perl 的参数。在这个单行代码中，传递给 Perl 的值是 `val1`、`val2` 和 `val3`，所以 `@ARGV` 包含了字符串 `val1`、`val2` 和 `val3`。这个单行代码打印出字符串 `(val1,val2,val3)`，例如，可以用来生成 SQL 查询。

如果你熟悉 SQL 中的 INSERT 查询，你会知道其最基本的形式是 `INSERT INTO table VALUES (val1, val2, val3, ...)`。如你所见，这个单行代码生成了 SQL 查询中的 `VALUES` 部分。

你可以轻松修改这个单行代码来打印整个 INSERT 查询：

```
perl -le '
  print "INSERT INTO table VALUES (", (join ",", @ARGV), ")"
' val1 val2 val3
```

下面是这个单行代码的输出：

```
INSERT INTO *table* VALUES (*val1,val2,val3*)
```

## 5.8 查找字符串中字符的数值

```
perl -le 'print join ", ", map { ord } split //, "hello world"'
```

这个单行命令将字符串 `"hello world"` 拆分成一个字符列表，使用 `split //, "hello world"`。然后它将 `ord` 操作符映射到每个字符上，返回每个字符的数字值。最后，所有的数字值通过逗号连接并打印出来。输出如下：

```
104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100
```

你也可以使用 `unpack` 操作符，通过指定 `C*` 作为解包模板来实现：

```
perl -le 'print join ", ", unpack("C*", "hello world")'
```

模板中的 `C` 代表“无符号字符”，而 `*` 代表“所有字符”。

要查找字符的十六进制值，你可以这样做：

```
perl -le '
  print join ", ", map { sprintf "0x%x", ord $_ } split //, "hello world"
'
```

在这里，`map` 操作符对每个字符执行 `sprintf "0x%x", ord $_`，返回字符的十六进制值，并加上前缀 `'0x'`。输出如下：

```
0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64
```

同样，要获取字符的八进制值，你可以这样做：

```
perl -le '
  print join ", ", map { sprintf "%o", ord $_ } split //, "hello world"
'
```

输出如下：

```
150, 145, 154, 154, 157, 40, 167, 157, 162, 154, 144
```

最后，为了生成以 `0` 开头的正确八进制值，你可以在 `sprintf` 函数中指定 `%#o` 格式：

```
perl -le '
  print join ", ", map { sprintf "%#o", ord $_ } split //, "hello world"
'
```

下面是输出结果：

```
0150, 0145, 0154, 0154, 0157, 040, 0167, 0157, 0162, 0154, 0144
```

## 5.9 将一系列数字 ASCII 值转换为字符串

```
perl -le '
  @ascii = (99, 111, 100, 105, 110, 103);
  print pack("C*", @ascii)
'
```

就像我在前面的单行命令中使用 `C*` 模板将字符串解包成一个值的列表一样，我也可以使用相同的模板将它们打包成一个字符串。单行命令的输出如下：

```
coding
```

将一系列数字 ASCII 值转换为字符串的另一种方法是使用 `chr` 操作符，它接受代码点值并返回对应的字符：

```
perl -le '
  @ascii = (99, 111, 100, 105, 110, 103);
  $str = join "", map chr, @ascii;
  print $str
'
```

在这里，你只需将 `chr` 操作符映射到 `@ascii` 数组中的每个数字值上，这样就会生成一个与这些数字值对应的字符列表。接下来，你将字符连接在一起生成 `$str`，然后打印出来。

你还可以对这个单行命令进行简化，得到以下代码：

```
perl -le 'print map chr, 99, 111, 100, 105, 110, 103'
```

你还可以使用 `@ARGV` 数组，将 ASCII 值作为参数传递给单行命令：

```
perl -le 'print map chr, @ARGV' 99 111 100 105 110 103
```

## 5.10 生成一个包含 1 到 100 之间的奇数的数组

```
perl -le '@odd = grep {$_ % 2 == 1} 1..100; print "@odd"'
```

这个单行命令生成了一个从 1 到 99 的奇数数组（即 1, 3, 5, 7, 9, 11, … , 99）。它使用 `grep` 对列表 `1..100` 中的每个元素进行代码 `$_ % 2 == 1` 的评估，仅返回那些评估结果为真的元素。在这个例子中，代码检查除以 2 的余数是否为 1。如果是，那么该数字是奇数，并被放入 `@odd` 数组。

你也可以通过利用奇数的最低有效位被设置的特点，并测试最低有效位来编写这段代码：

```
perl -le '@odd = grep { $_ & 1 } 1..100; print "@odd"'
```

表达式 `$_ & 1` 用于隔离最低有效位，`grep` 仅选择那些最低有效位被设置的数字——也就是所有奇数。

## 5.11 生成一个包含 1 到 100 之间偶数的数组

```
perl -le '@even = grep {$_ % 2 == 0} 1..100; print "@even"'
```

这个单行命令几乎与 5.10 中的命令相同，唯一的区别是 `grep` 测试条件是“这个数字是否为偶数（除以 2 后余数为 0）？”

## 5.12 查找字符串的长度

```
perl -le 'print length "one-liners are great"'
```

`length` 子例程用于查找字符串的长度。

## 5.13 查找数组中的元素个数

```
perl -le '@array = ("a".."z"); print scalar @array'
```

在标量上下文中评估数组会返回数组的元素个数。

你也可以通过在数组的最后一个索引上加`1`来做到这一点：

```
perl -le '@array = ("a".."z"); print $#array + 1'
```

这里，`$#array`返回`@array`中的最后一个索引。因为这个数字比数组中元素的数量少 1，所以你可以在结果上加上`1`来找到数组中的元素总数。

例如，假设你想找出当前目录中有多少个文本文件。你可以使用`@ARGV`并将`*.txt`通配符传递给 Perl。Shell 将`*.txt`通配符扩展为匹配`*.txt`的文件名列表，然后 Perl 将它们放入`@ARGV`数组，并在标量上下文中打印该数组。输出将是当前目录中文本文件的数量：

```
perl -le 'print scalar @ARGV' *.txt
```

如果你的 Shell 不支持文件名扩展（也称为*通配符匹配*），或者你使用的是 Windows，你可以使用钻石操作符与`*.txt`参数：

```
perl -le 'print scalar (@ARGV=<*.txt>)'
```

在这种情况下，钻石操作符会进行通配符匹配，并返回一个匹配`*.txt`的文件名列表。在标量上下文中评估这个列表会返回匹配的文件数量。
