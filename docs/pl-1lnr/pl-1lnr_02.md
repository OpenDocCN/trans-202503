## 第三章 编号

在本章中，我们将介绍各种用于为行和单词编号的单行命令，你还将了解`$.`这个特殊变量。你还会学习到 Perl 高尔夫，一种“运动”，它要求编写最短的 Perl 程序来完成任务。

## 3.1 在文件中为所有行编号

```
perl -pe '$_ = "$. $_"'
```

正如我在单行命令 2.1（第 7 页）中解释的那样，`-p`告诉 Perl 假设程序（由`-e`指定）周围有一个循环，它读取输入的每一行到`$_`变量中，执行程序，然后打印`$_`变量的内容。

这个单行命令仅通过将`$.`变量附加到`$_`上来修改`$_`。特殊变量`$.`包含输入的当前行号。结果是，每一行的行号都会被添加到行首。

同样，你也可以使用`-n`参数并打印字符串`"$. $_"`，即当前行号后跟该行内容：

```
perl -ne 'print "$. $_"'
```

假设一个文件包含三行：

```
foo
bar
baz
```

运行这个单行命令会为它们编号：

```
1 foo
2 bar
3 baz
```

## 3.2 在文件中仅为非空行编号

```
perl -pe '$_ = ++$x." $_" if /./'
```

在这里，你使用了“条件成立时执行操作”语句，该语句只有在条件为真时才会执行操作。在这种情况下，条件是正则表达式`/./`，它匹配所有非换行符的字符（即，匹配非空行）。操作`$_ = ++$x." $_"`将变量`$x`（递增后）附加到当前行的前面。由于没有使用`strict` pragma，变量`$x`在第一次递增时会自动创建。

结果是，在每个非空行上，变量`$x`会递增，并被添加到该行的前面。空行不会被修改，且原样打印。

单行命令 2.2（第 11 页）展示了通过正则表达式`\S`匹配非空行的另一种方法：

```
perl -pe '$_ = ++$x." $_" if /\S/'
```

假设一个文件包含四行，其中两行是空的：

```
line1

line4
```

运行这个单行命令只为第一行和第四行编号：

```
1 line1

2 line4
```

## 3.3 在文件中为非空行编号并打印（删除空行）

```
perl -ne 'print ++$x." $_" if /./'
```

这个单行命令使用了`-n`程序参数，它将行放入`$_`变量中，然后执行由`-e`指定的程序。与`-p`不同，`-n`在执行完`-e`中的代码后不会自动打印行，因此你需要显式调用`print`来打印`$_`变量的内容。

这个单行命令只在含有至少一个字符的行上调用`print`，与前一个单行命令一样，它会为每个非空行将行号保存在变量`$x`中并递增。空行会被忽略，不会被打印。

假设一个文件包含和单行命令 3.2 相同的四行：

```
line1

line4
```

运行这个单行命令会删除空行，并为第一行和第四行编号：

```
1 line1
2 line4
```

## 3.4 为所有行编号，但仅为非空行打印行号

```
perl -pe '$_ = "$. $_" if /./'
```

这个单行命令与单行命令 3.2 类似。在这里，只有当行中至少包含一个字符时，才会修改保存整行的`$_`变量。所有其他空行会原样打印，不带行号。

假设一个文件包含四行：

```
line1

line4
```

运行这个单行命令会为所有行编号，但只打印第一行和第四行的行号：

```
1 line1

4 line4
```

## 3.5 仅编号匹配模式的行；打印其余行原样

```
perl -pe '$_ = ++$x." $_" if /*regex*/'
```

在这里，依然使用了“条件下的动作”语句，条件仍然是一个模式（正则表达式）：`/regex/`。动作与单行命令 3.2 中的相同。

假设一个文件包含以下行：

```
record foo
bar baz
record qux
```

如果你想为包含*record*一词的行编号，可以将单行命令中的`/regex/`替换为`/record/`：

```
perl -pe '$_ = ++$x." $_" if /record/'
```

当你运行这个单行命令时，它会给你以下输出：

```
1 record foo
bar baz
2 record qux
```

## 3.6 只编号并打印匹配模式的行

```
perl -ne 'print ++$x." $_" if /*regex*/'
```

这个单行命令几乎与单行命令 3.3 完全相同，只是它仅编号并打印匹配`/regex/`的行。它不会打印不匹配的行。

例如，一个文件包含与单行命令 3.5 中相同的行：

```
record foo
bar baz
record qux
```

假设你只想编号并打印包含*record*一词的行。在这种情况下，改变`/regex/`为`/record/`并运行单行命令将得到如下结果：

```
1 record foo
2 record qux
```

## 3.7 为所有行编号，但只对匹配特定模式的行打印行号

```
perl -pe '$_ = "$. $_" if /*regex*/'
```

这个单行命令类似于单行命令 3.4 和 3.6。在这里，如果某一行匹配`/regex/`，则在该行前面加上行号；否则，该行将不带行号直接打印。

将`/regex/`替换为`/record/`并在与单行命令 3.6 相同的示例文件上运行此单行命令将给出如下输出：

```
1 record foo
bar baz
3 record qux
```

## 3.8 使用自定义格式为文件中的所有行编号

```
perl -ne 'printf "%-5d %s", $., $_'
```

这个单行命令使用`printf`打印行号和行内容。`printf`进行格式化输出。你指定格式并将数据传递给它，然后它会根据格式打印数据。这里，行号的格式是`%-5d`，它将行号左对齐，占据五个字符的位置。

这是一个示例。假设这个单行命令的输入是

```
hello world
bye world
```

然后输出如下：

```
1     hello world
2     bye world
```

其他格式字符串包括`%5d`，它将行号右对齐，位置宽度为五个字符，以及`%05d`，它用零填充并右对齐行号。以下是使用`%5d`格式字符串打印行号的输出：

```
    1 hello world
    2 bye world
```

这是使用`%05d`格式字符串得到的输出：

```
00001 hello world
00002 bye world
```

要了解更多关于可用的各种格式，请在命令行运行`perldoc -f sprintf`。

## 3.9 打印文件的总行数（模拟`wc -l`）

```
perl -lne 'END { print $. }'
```

这个单行命令使用了 Perl 从 Awk 语言中借来的`END`块。`END`块在 Perl 程序执行完毕后执行。在这里，Perl 程序是由`-n`参数创建的对输入的隐式循环。一旦它遍历完输入，特殊变量`$.`就包含了输入中的行数，`END`块将打印这个变量。`-l`参数设置了`print`的输出记录分隔符为换行符，因此你无需手动打印换行符，像这样：`print "$.\n"`。

你也可以用这个单行命令做相同的事情：

```
perl -le 'print $n = () = <>'
```

如果您对 Perl 上下文理解得很透彻，这个单行代码很容易理解。`() = <>` 这一部分告诉 Perl 在列表上下文中评估 `<>` 操作符（即*钻石操作符*），这使得钻石操作符将整个文件作为行的列表读取。接下来，您将这个列表赋值给 `$n`。因为 `$n` 是标量，所以这个列表赋值是在标量上下文中评估的。

这里真正发生的事情是 `=` 操作符是右结合的，这意味着右边的 `=` 会先执行，左边的 `=` 会后执行：

```
perl -le 'print $n = (() = <>)'
```

在标量上下文中评估列表赋值会返回列表中的元素个数；因此，`$n = () = <>` 构造等同于输入中的行数，也就是文件中的行数。`print` 语句会打印这个数字。`-l` 参数确保在打印数字后添加一个换行符。

您还可以从这个单行代码中省略变量 `$n`，并通过 `scalar` 操作符强制标量上下文：

```
perl -le 'print scalar(() = <>)'
```

在这里，您不需要通过再次将其赋值给另一个标量来在标量上下文中评估列表赋值，您只需要使用 `scalar` 操作符在标量上下文中评估列表赋值。

现在来看一个更明显的版本：

```
perl -le 'print scalar(@foo = <>)'
```

在这里，您不使用空列表 `()` 来强制 `<>` 处于列表上下文中，而是使用变量 `@foo` 来实现相同的效果。

这里有另一种方法：

```
perl -ne '}{print $.'
```

这个单行代码使用了所谓的*Eskimo 操作符* `}{`（实际上是一个巧妙的构造）与 `-n` 命令行参数配合使用。正如我之前解释的，`-n` 参数强制 Perl 在程序周围假设一个 `while(<>) { }` 循环。Eskimo 操作符强制 Perl 跳出这个循环，这样单行代码就扩展成了：

```
while (<>) {
}{               # eskimo operator here
    print $.;
}
```

如您所见，这个程序只是循环遍历所有输入，并在完成后打印 `$.`，即输入中的行数。如果您稍微调整一下格式，这一点就会更加明显：

```
while (<>) {}
{
    print $.;
}
```

如您所见，这只是一段空循环，它循环遍历所有输入，然后是一个用大括号包裹的 `print` 语句。

## 3.10 打印文件中非空行的数量

```
perl -le 'print scalar(grep { /./ } <>)'
```

这个单行代码使用了 Perl 的 `grep` 函数，它类似于 UNIX 的 `grep` 命令。给定一个值列表，`grep { condition } list` 只返回那些使得 `condition` 为真的值。在这个例子中，条件是一个正则表达式，用来匹配至少一个字符，因此输入会被过滤，`grep{ /./ }` 返回所有非空行。为了得到行数，您需要在标量上下文中评估 `grep` 并打印结果。

一些 Perl 程序员喜欢创建最短的 Perl 程序来完成某个特定的任务——这项练习叫做*Perl 高尔夫*。这个单行代码的高尔夫版将 `scalar()` 替换为 `~~`（双重按位取反）并去掉空格，将其缩短成这样：

```
perl -le 'print ~~grep{/./}<>'
```

这个双重按位取反技巧实际上是`scalar`的同义词，因为按位取反作用于标量值，因此`grep`在标量上下文中执行。

你可以通过去掉`print`后的空格并去除大括号，使这段代码更简洁：

```
perl -le 'print~~grep/./,<>'
```

如果你使用的是 Perl 5.10 或更高版本，你还可以使用`-E`命令行开关和`say`操作符：

```
perl -lE 'say~~grep/./,<>'
```

真正的高尔夫大师之作！

## 3.11 打印文件中空行的数量

```
perl -lne '$x++ if /^$/; END { print $x+0 }'
```

在这里，你使用变量`$x`来计数遇到的空行数量。一旦遍历完所有行，你在`END`块中打印`$x`的值。你使用`$x+0`的构造来确保如果没有空行，输出`0`。（否则`$x`将没有被创建并且是未定义的，给未定义的值加上`+0`会输出`0`。）`$x+0`的替代方法是`int`运算符：

```
perl -lne '$x++ if /^$/; END { print int $x }'
```

你还可以通过以下方式修改之前的一行代码：

```
perl -le 'print scalar(grep { /^$/ } <>)'
```

或者用`~~`来写：

```
perl -le 'print ~~grep{ /^$/ } <>'
```

`~~`进行了两次按位取反操作，这使得`grep`在标量上下文中执行，并返回空行的数量。

这最后两个版本不如带有`END`块的一行代码高效，因为它们将整个文件读入内存，而带有`END`块的一行代码是逐行处理的，因此只在内存中保留一行输入。

## 3.12 打印文件中匹配模式的行数（模拟`grep -c`）

```
perl -lne '$x++ if /*regex*/; END { print $x+0 }'
```

这段一行代码基本上与 3.11 相同，只是当某行匹配正则表达式`/regex/`时，它会将行计数器`$x`递增 1。`$x+0`的技巧确保在没有行匹配`/regex/`时，输出`0`。（详见 3.11 中的`$x+0`技巧的详细解释。）

## 3.13 为所有行中的单词编号

```
perl -pe 's/(\w+)/++$i.".$1"/ge'
```

这个一行代码使用了`/e`标志，使得 Perl 将`replace`部分的`s/regex/replace/`表达式作为代码来执行！

这里的代码是`++$i.".$1"`，意思是“将变量`$i`递增 1，然后将其加到字符串`".$1"`前面（即一个点和匹配组`$1`的内容）。”这里的匹配组是每个单词：`(\w+)`。

一句话来说，这段一行代码匹配一个单词`(\w+)`，将其放入`$1`，然后执行`++$i.".$1"`代码，为单词全球编号（`/g`标志）。完成了—所有单词都被编号。

例如，如果你有一个文件，包含以下三行：

```
just another
perl hacker
hacking perl code
```

运行这段一行代码会为文件中的每个单词编号，并生成以下输出：

```
1.just 2.another
3.perl 4.hacker
5.hacking 6.perl 7.code
```

## 3.14 为每一行中的单词编号

```
perl -pe '$i=0; s/(\w+)/++$i.".$1"/ge'
```

这类似于一行代码 3.13，只是你在每行开始时将变量`$i`重置为`0`。以下是运行这段一行代码在 3.13 中的例子时的结果：

```
1.just 2.another
1.perl 2.hacker
1.hacking 2.perl 3.code
```

如你所见，每一行中的单词编号是独立于其他行的。

## 3.15 用数字位置替换所有单词

```
perl -pe 's/(\w+)/++$i/ge'
```

这个单行命令几乎与单行命令 3.13 相同。在这里，你只需用每个单词的数字位置来替换它，而这个数字位置保存在变量`$i`中。例如，如果你在单行命令 3.13 和 3.14 中的文件上运行这个单行命令，它会将文件中的单词替换为它们的数字位置，输出如下：

```
1 2
3 4
5 6 7
```

好玩！
