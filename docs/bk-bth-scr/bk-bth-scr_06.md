<hgroup>

## 5 字符串和布尔数据类型

</hgroup>

![](img/chapter.jpg)

在学习 Batch 数据类型赋值的第一件事就是，Batch 不允许赋予数据类型。这里并没有什么平等主义的底层思想，但所有 Batch 变量都是平等的。从本质上讲，保存数字、文本甚至布尔值的变量没有任何区别。然而，设置为数字的变量可以被视为数值类型，接下来我将集中讲解这些数据类型。

在本章中，在概述所有 Batch 数据类型之后，你将学习字符串和字符变量。你还将进一步探索字符串，了解如何进行子字符串提取和文本替换。布尔值并非 Batch 的创建者设计的，但我将教你如何构建和使用这个有用的数据类型。

### 常见数据类型

许多（如果不是大多数的话）编程语言不仅允许，而且要求在赋值或以任何方式使用变量之前，必须先声明其数据类型。不同语言之间有所不同，但这里有一个一般的数据类型列表：

**字符**    单个字母数字字符

**字符串**    零个或多个字母数字字符

**整数**    正数和负整数

**浮点数**    具有小数点的数字

**布尔值**    真或假

无论好坏，Batch 变量并没有显式声明。变量名第一次被解释器发现时，它就会凭空产生。这种做法确实提供了很大的灵活性，但也可能很棘手且危险。解释器会认为变量名拼写错误的实例是一个完全不同的变量，且编译器并不会捕捉到这个错误。相反，它会被当作一个新的变量，这个变量可能最终什么也没有。

变量可以被赋予一个整数，并且可以对其进行算术运算。这个变量之后可以被赋值为文本，并像字符串一样处理。这也意味着，包含字符串的变量可能不小心进行算术运算，但从好的一面看，数字可以轻松地当作字符串处理，在控制台或报告中无需任何转换。这是纯粹的数字混乱，是为虚无主义者设计的编程语言，不知为何它居然能工作。

即使你不能直接赋予数据类型，你仍然可以创建变量，并将其当作某种类型来使用，但——我必须强调这一点——每个 Batch 变量的底层结构实际上只是几字节的内存，没有明确的类型区分。

### 字符

字符仅仅是单个字节的文本；在 Batch 世界中，可以把它看作是一个非常短的字符串，因为它和任何其他单字符字符串的处理方式完全相同。我将简短讲解这一部分，并继续介绍字符串。

### 字符串

字符串是任意长度的文本，包含字母字符、数字和/或特殊字符。以下命令将 aString 变量设置为一个包含五个单词的字符串：

```
set aString=Awesome Batch Code Dares Excellence
```

包括嵌入的空格，其长度总计为 35 个字符，或者用程序员的话来说，是 35 个字节。

许多特殊字符，如美元符号和英镑符号，可以明确地包含在字符串中，但其他字符，如百分号符号，则不行，因为它们在 Batch 中有特定的用途。在第十四章中，我将讲解如何通过转义实现将所有字符包含在字符串中的方法，但现在要理解的是，当解释器在字符串中遇到感叹号时，它不会中止执行，但你可能不会看到预期的结果。例如，赋值给这个变量的值中的最后一个字符是一个感叹号：

```
set aString=Awesome Batch Code Dares Excellence!
> con echo A String is "%aString%" 
```

这是 `echo` 命令的结果：

```
A String is "Awesome Batch Code Dares Excellence"
```

标点符号没有写入控制台，因为它没有包含在字符串变量中。

> 注意

*如第三章中所述，我假设本书中启用了延迟扩展。这个例子很好地说明了这一点，因为如果延迟扩展被禁用，感叹号将仅仅是另一个字符，而不是用来解析变量的分隔符。这个字符会作为值的一部分被包含在内，并与其余文本一起写入控制台。能够将感叹号视为普通文本，可能是禁用延迟扩展的唯一优势。这个微不足道的优势与延迟扩展所提供的功能相比显得微不足道，这也是我推荐全书都使用它的原因。*

在后续章节中，我会讨论如何将字符串和其他数据类型写入文件，但在这里我将解释如何构建、连接、提取子串和操作字符串。

#### 构建和连接

上一个例子使用单个 `set` 命令将值 `Awesome Batch Code Dares Excellence` 赋给一个变量。以下六行执行相同的任务：

```
set a=Awesome
set b=Batch &
set c=Code
set d=Dares
set e= Excellence
set aString=%a% %b%%c% %d%%e% 
```

实际上，这种方法在构建字符串时效率极低，但它很好地展示了连接的原理。

由字母表前五个字母定义的变量每个都被设置为一个单词。然后在最后一行，所有五个变量都被解析并连接起来创建一个 `aString`。注意结果中嵌入的四个空格：一个是来自 `Batch` 后面的空格，另一个是来自 `Excellence` 前面的空格，其他两个则是嵌入在最后的 `set` 命令中。

上一个例子展示了如何通过连接其他字符串来创建一个字符串，但你也可以通过附加或预置其他文本来扩展现有字符串：

```
set longText=This field contains a brutal run-on sentence and if its prose 
set longText=%longText% were to be typed into a single line the reader would
set longText=%longText% be forced to scroll way over to the right to read what
set longText=%longText% you are reading now and then scroll way back to the
set longText=%longText% left after mercifully getting to this period. 
```

这里一个字符串被四次附加额外文本，从而创建了一个非常长的字符串。

这种方法是我创建长字符串变量的偏好方式，但你也可以使用“续行符”或插入符号（^）完成相同的任务。当解释器遇到行尾的插入符号时，它会将下一行附加到该行：

```
 set longText=This field contains a brutal run-on sentence and if its prose ^
were to be typed into a single line the reader would be forced to scroll way^
 over to the right to read what you are reading now and then scroll way back ^
to the left after mercifully getting to this period. 
```

在这个例子中，使用了三个插入符号来制作一个四行的 set 命令。第一行和第三行前面有一个空格，而它们的后续行从第一字节开始，这导致了单词之间的空格。为了展示一种不同的实现方式，第二个插入符号紧跟在单词 way 后面，接下来的行在下一个单词 over 前有一个空格。最终结果是一个由空格分隔的长字符串。

我不太喜欢这种技术，原因很简单，它会破坏我的缩进规则。我通常将大部分命令缩进两个或更多空格，正如 set 命令的第一行所示，但任何后续行开头的空格都被视为附加文本的一部分。这实际上意味着这些行必须左对齐。我会在第九章中深入讨论缩进规则。现在只需理解它是有效的——但不美观。

> 注意

*我把“续行符”加上引号是因为这是一个过度简化。插入符号实际上是一个转义字符。在第十四章中，我会解释为什么这很重要，但许多批处理程序员通常称其为*续行符*。*

#### 子字符串

任何值得一提的语言都会支持一种子字符串函数，能够提取字符串的一部分，而 Batch 也不例外。在接下来的几个例子中，我们假设 aString 变量已经像之前那样设置好了：

```
set aString=Awesome Batch Code Dares Excellence
```

一个*子字符串函数*需要两个数字，即偏移量或起始位置和所需文本的长度。令人惊讶的是，Batch 使用的是更现代语言中常见的零偏移量，而不是 20 世纪语言中更常见的 1 偏移量。这意味着第一个字节的位置是 0（而不是 1），第二个字节的位置是 1，第 100 个字节的位置是 99，以此类推。

子字符串的语法有点笨重。变量使用百分号进行解析，这是常见的做法，但闭合的百分号前面会加上冒号、波浪号、偏移量、逗号，最终是长度。因此，下面的语法会返回 aString 变量的前三个字符：

```
set subString=%aString:~0,3%
```

偏移量为 0 告诉解释器从第一个字节开始，长度定义为 3，最终将文本 Awe 赋值给 subString。

以下代码从同一字符串的第一个单词中提取文本 some：

```
set subString=%aString:~3,4%
```

我们需要从第 4 个字节开始，这就是零偏移量 3。如果你觉得零偏移量有些混乱，可以将偏移量理解为子字符串*之前*的字节数。更明显的是，长度是 4。

这里有两个子字符串与硬编码的 "to" 和几个空格一起拼接：

```
set phrase=%aString:~15,3% to %aString:~8,5%
```

第 15 个字节是 Code 中的字母 C，因此第一个子字符串是该单词的剩余三个字节。第 8 个字节是 Batch 前的空格，因此接下来的五个字节包含整个单词。结果是一个恰当的，虽然不那么高深的，重新诠释原始字符串：ode to Batch。

如果没有定义长度，解释器将返回字符串的其余部分。为了演示，以下子字符串没有长度，也没有前导逗号。偏移量对应于 35 字节变量中倒数第一个单词前面的 25 个字节：

```
set subString=%aString:~25%
```

结果是，subString 被赋值为字符串“Excellence”，即原始字符串的最后 10 个字节。

##### 负偏移量

注意以下示例中的负偏移量。有趣的是，这也将“Excellence”赋值给变量：

```
set subString=%aString:~-10%
```

一个*负偏移量*表示起始位置相对于字符串的结尾，而不是开头，这意味着-10 告诉解释器子字符串应从字符串末尾起 10 个字节的位置开始。由于没有给定长度，它将返回文本的其余部分。只要变量已填充，%aString:~-1%是检查其最后一个字节的简便方法。

这两个命令都会返回相同的子字符串：

```
set subString=%aString:~15,3%
set subString=%aString:~-20,3% 
```

第一个命令的偏移量是原始字符串起始位置的 15 个字节，而第二个命令通过从 35 字节的变量末尾起始的 20 个字节来找到相同的位置。

##### 负长度

负长度的工作方式类似。不要把它看作是一个*长度*；把它看作是字符串末尾*不*包含在子字符串中的字节数。例如，以下命令返回一个去掉首尾字节的字符串：

```
set subString=%aString:~1,-1%
```

你甚至可以将负偏移量与负长度一起使用。以下命令提取字符串的倒数第二个字节：

```
set subString=%aString:~-2,-1%
```

偏移量-2 告诉解释器从倒数第二个字节开始，长度-1 表示删除最后一个字节。

##### 实际中的子字符串

批处理中的一个不错的特性是，如果请求的子字符串超出了字符串的长度，解释器会返回 null，而不会崩溃。因此，当遇到 35 字节字符串的命令%aString:~99,1%时，解释器不会崩溃，也不会返回空格。它只会返回一个空字符串。这是确定字符串长度的一种方便方法，避免了编译代码中常见的 null 指针异常。如果第 36 个字节为空（即"%aString:~35,1%"为""），但第 35 个字节已填充，则字符串的长度正好为 35 个字节。

然而，这种语法仅在截取已填充的字符串时有效。正如我刚才提到的，当字符串长度在 1 到 35 字节之间时，%aString:~35,1%的解析结果为 null；当然，如果字符串长度为 36 字节或更长，它会解析为第 36 个字节。但如果字符串为空或设置为 null，%aString:~35,1%会解析为~35,1，或冒号和后续定界符之间的所有内容。同样，由于这个警告，当尝试检查空字符串的最后一个字节时，%aString:~-1%会解析为~-1，而不是你可能期望的 null。

现在你已经知道如何从另一个字符串中提取字符串的任何部分，但之前的例子中，所有的偏移量和长度都是硬编码的。通常情况下，甚至大多数情况下，这两个数字会是变量。在以下示例中，偏移量和长度被定义为显而易见的命名变量，并在第三个命令中使用：

```
set offset=15
set length=3
set subString=!aString:~%offset%,%length%! 
```

包围偏移量和长度的百分号首先会解析这些变量的数值。然后，感叹号发挥作用，使得 !aString:~15,3! 解析为我们熟悉的 ode，这是启用延迟扩展的又一次胜利。

完成下一章后，我将在其中讨论算术运算，你将能够计算持有整数值的变量，用作偏移量和长度来查找子字符串。

#### 文本替换

Batch 还有一个便捷的机制，可以将字符串的全部或部分替换为其他文本。例如，假设以下变量包含这个不太合适的文件名：

```
set filNm=File_Name_With_Underscores.docx
```

如果你不喜欢这个文件名，你可以将下划线替换为短横线。在第七章中，我将介绍用于重命名文件的理想命令，但在这里我将讨论如何构建包含新文件名的变量。

文本替换语法类似于用于子字符串提取时的语法。变量和冒号仍然被百分号包围，但现在没有波浪号。冒号后面是要查找并更改的文本，接着是等号分隔符，最后是替换文本：

```
set newFilNm=%filNm:_=-%
```

每一个下划线字符（_），而不仅仅是遇到的第一个下划线，都会被替换为短横线（-），从而得到 File-Name-With-Underscores.docx。小心不要更改超过预期的文本。

看着这个文件名，也可以考虑将 Underscores 替换为 Dashes。幸运的是，Batch 不要求目标文本和替换文本的长度相同，因此这个附加命令进一步将变量的值更新为 File-Name-With-Dashes.docx：

```
set newFilNm=%newFilNm:underscor=Dash%
```

由于这两个单词都以 es 结尾，我使用单数形式的 Dash 作为替换文本，而目标文本是 underscor，后者甚至不是一个真实的单词。此外，注意到在变量的值中 Underscores 是大写的，而在替换语法中，underscor 是小写的。非常重要的一点是，Batch 执行的是不区分大小写的替换。目标文本的大小写可以是任意的，甚至是混合大小写，这对结果没有影响，但替换文本会按原样使用。因此，%newFilNm:UNDERscor=Dash% 与之前命令中的变量解析功能完全相同，但 %newFilNm:underscor=DASH% 将会导致文件名变为 File-Name-With-DASHes.docx。

这很微妙，但前两个命令展示了两种不同的赋值方法。第一个命令将修改后的 `filNm` 值赋给 `newFilNm`，而不改变 `filNm`。第二个命令将 `newFilNm` 重新赋值给它自己，以便其最终值反映两个文本替换。这两种方法为你提供了灵活性，可以选择直接在变量内修改值，或者保持两个变量，一个保存旧文本，一个保存新文本。

你还可以使用延迟扩展将目标文本 `targ` 和替换文本 `repl` 转换为变量。这里有一个例子：

```
set targ=Love
set repl=Hate
set aString=I Love Broccoli
set aString=!aString:%targ%=%repl%! 
```

结果是更诚实的字符串 "I Hate Broccoli"。

文本搜索是文本替换语法的一个绝妙应用。在第二十四章中，我将对比两种判断一个字符串是否为另一个字符串一部分的方法。`findstr` 命令效果不错，但基于前述语法的方法执行速度要快得多。剧透：文本搜索逻辑会将搜索到的文本替换为空，然后将结果与原始文本进行比较。如果它们不同，说明文本被找到了。

### 布尔值

布尔值在编译语言中无处不在，它们只有两个状态：true 或 false。一旦设置，你可以单独使用它们作为 if 命令中的条件语句，评估为真或假，从而决定是否执行一段代码。Batch 并不明确支持布尔值，但通过一点巧妙的设计，你可以创建布尔值。

许多篇幅已被用来探讨“上帝是否存在？”这个问题。这不是那类书籍，但我们可以回答一个更简单的问题：“*God.txt* 是否存在？”在第四章中，我展示了如何使用 if 命令来判断一个文本文件是否存在：

```
if exist C:\Batch\God.txt (
   set god=Found
) else (
   set god=NotFound
) 
```

一个变量根据某一时刻文件的状态被设置为 `Found` 或 `NotFound`。然后，可以在未来询问 `god` 变量，以确定 *God.txt* 是否在那个较早的时刻存在。它能工作，但有点笨重；布尔值将提供更优雅的解决方案。然后，你可以根据需要在代码中多次引用这个布尔值，甚至可能重置它。

#### 设置和评估布尔值

在 Batch 中，布尔值像所有变量一样，本质上只是一些文本，但这些文本可以被评估为真或假。按照惯例，我总是将布尔变量名以小写字母 b 开头，后跟大写字母，以便使其作为布尔值脱颖而出。（一个更冗长且描述性的选项是以 `bool` 文字开头。）让我们复制之前示例中的逻辑，唯一的区别是将笨重的变量 `god` 替换为布尔值 `bGod`，如果找到 *God.txt* 则将其设置为 true，否则为 false：

```
if exist C:\Batch\God.txt (
   set bGod=true==true
) else (
   set bGod=false==x
) 
```

在其他编程语言中，布尔值通常显式设置为 true 或 false。例如，一个有效的 Java 命令是 bGod = true;。但是，Batch 布尔值的前述设置命令看起来有点不同；特别是每个命令都有三个等号。第一个等号仅用于赋值；另外两个则是赋值的一部分。当 if 命令的条件语句为真时，我们将 bGod 设置为 true==true；如果不是，则值为 false==x。这看起来确实有些奇怪，但现在该变量虽然技术上仍然只是文本，但可以像这样被评估为另一个 if 命令的条件语句：

```
if %bGod%  > con echo Let us pray.
```

那么怎么做呢？如果 bGod 被设置为我们认为的 true，解释器将 %bGod% 解析为 if true == true。该变量包含一个等号操作符，两个相等的等号，并且两边的值是相同的。（别问操作符周围的空格，这就是解释器看到的。）将所有这些放在 if 命令后面，它将被评估为真。

然而，如果该变量被设置为我们认为的 false，那么命令将被解析为 if false == x，它比较两个明显不同的值，导致 if 命令后面的代码不被执行。

带有布尔值的 if 命令还可以与 not 子句一起使用：

```
if not %bGod%  > con echo Live every day to the fullest.
```

如果文本 if not %bGod% 被解析为 if not true == true，那么评估结果是 *not true* 或 false。但当文本解析为双重否定 if not false == x 时，它将评估为 *not false* 或 true，并且文本将被写入控制台。

#### 布尔值转换为字符串

我选择 true==true 作为 true 的值，但 x==x 或 0 == 0 也能工作，并且需要更少的击键。即使是 false==false 也会评估为 true，但我们不必这样做。同样，false==x 本来可以包含任何两个不同的字符串，但我选择了这些值，使得布尔值的文本 true 或 false 始终处于前沿。布尔变量的结构使你能够模仿编译代码中的另一个布尔特性——将布尔值转换为字符串。

如前所述，你可以通过简单地去掉等号后面的所有内容，将 Batch 布尔值转换为字符串 true 或 false。当我们在 第十九章中讲到 for 命令时，我将展示具体是如何实现的，但现在，下面的代码行可以截断多余的文本：

```
for /F "delims==" %%b in ("%bGod%") do  set bStrGod=%%b
```

在此执行之后，针对有效的布尔值，名为 bStrGod 的 *布尔字符串* 变量将包含 true 或 false。

（如果布尔变量以 b 开头，那么将布尔字符串变量以 bs 开头可能是有意义的，但我选择的惯例避免了人们对我的代码充满 BS 的指责。）

### 总结

字符串在 Batch 中无处不在，在本章中，我详细讲解了如何构建和连接字符串。子字符串提取和文本替换是两个强大而有用的工具，尽管它们的语法较为深奥，但所有 Batch 编程人员都应该掌握。布尔值虽然不那么常见，但我希望我已经展示了这一不常用数据类型的实用性。

在下一章，我将继续讨论数据类型，深入探讨数字数据类型。我将详细介绍三种不同进制的整数和浮点数，为探索 Batch 中如何处理算术运算提供一个很好的机会。
