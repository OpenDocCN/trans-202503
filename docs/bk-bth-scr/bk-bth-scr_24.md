<hgroup>

## 21 伪环境变量

</hgroup>

![](img/chapter.jpg)

我在第二章中介绍了环境变量及其 set 命令，它们从那时起出现在了几乎每一页中。你可以定义和解析一个简单的变量，然后可能会重置并以不同方式再次使用它。*伪环境变量*与其类似，但也有显著不同。你可以像常规环境变量一样解析它们，但它们的来源或设置方式有本质的不同。

我们已经讨论了一些伪环境变量，包括 path、pathext、cd 和 errorlevel。所有伪环境变量都有一些共同特点，但许多都有独特的属性。许多伪环境变量有不同的设置方式，有些你根本不应设置。某些变量在运行 bat 文件之前就已激活，而解释器会在执行过程中反复更新其他变量。

每个伪环境变量在批处理世界中都有一个固有的特性，在正确使用之前你必须理解这一点。在本章中，我将解释一些已经提到的伪环境变量的复杂性，并探索一些我们将在未来章节中使用的有用的伪环境变量。我还将提供一直承诺的关于从编码者角度看，bat 文件和 cmd 文件的主要区别的解释。

### 日期和时间

你可以轻松地通过分别使用恰如其分命名的日期和时间伪环境变量来获取当前的日期和时间：

```
> con echo Date = "%date%";  Time = "%time%"
```

如果在波士顿红袜队结束了 86 年的冠军荒之后不久执行该命令，它将产生如下输出：

```
Date = "Wed 10/27/2004";  Time = "23:39:12.34"
```

日期变量包含当前日期，格式为星期几、月份、日期和年份。星期几总是以三个字符的大写和小写混合形式呈现，后跟一个空格、一个两字节的月份、一个斜杠、一个两字节的日期、另一个斜杠和一个四字节的年份。例如，Sun 06/08/1986 是批处理时代早期的一个例子。

时间变量包含当前时间，格式为小时、分钟、秒和百分之一秒。它使用 24 小时制，因此晚上 11:39 转为 23:39:00.00。如果小时数是单个数字，批处理会在其前面加上一个空格，而不是前导零；例如，在上午 10:00 临近时，时间将解析为一个空格，后跟 9:59:59.99，而午夜则显示为空格加上 0:00:00.00。

这确实有些奇怪，但请记住，时间在前面有一个空格代替零，而日期对于所有单数字的月份和日期则有一个前导零。

由于日期和时间格式良好，你可以轻松地将它们用来增强报告和日志文件，而且因为日期格式一致，所以可以轻松地提取一个日期戳，格式为 CCYYMMDD，如 Listing 21-1 所示。

```
set #=%date%
set datestamp=%#:~10,4%%#:~4,2%%#:~7,2% 
```

Listing 21-1: 在 Datestamp.bat 文件中使用的两个命令来构建日期戳

（为了节省按键次数，我喜欢使用井号作为一个非常简短的变量名，但仅限于非常简洁和有限的使用。在 bat 文件中稍后使用这个变量会造成困扰，但在接下来的一两行中立即使用它则是一个很好的方式来简化代码。虽然我必须承认，%#:~7,2%是深奥的，并非每个人都喜欢。）

使用不同的技术，以下是构建按 HHMMSSss 格式的时间戳的代码：

```
set timestamp=%time: =0%
set timestamp=%timestamp::=%
set timestamp=%timestamp:.=% 
```

第一个命令将替换前导空格（如果存在的话），用 0 代替。接下来的两个命令将移除两个冒号和小数点。

除非在上午 10 点之前进行编码和测试，否则很容易忘记前导空格，但它是至关重要的。如果在下午测试时忘记了它，变量将会在午夜时刻突然包含一个空格，而根据你计划如何使用它，可能会在非常不合时宜的时刻发生失败。这可以看作是另一个警告。

日期戳和时间戳有许多用途。你可以在文件名中使用它们来表示创建日期和时间。在 if 命令中，你可以将它们与其他日期戳或时间戳进行比较，在特定日期和时间启用逻辑。你甚至可以在某些过程之前和之后捕获它们来衡量经过的时间。

### Prompt

提示符伪环境变量同时也作为命令使用。就像 path 是用来更改路径变量的命令一样，prompt 是用来更改提示符变量的命令。

在第十二章中，当讨论解释器生成的输出（stdout）时，我提到了解释器会在每个命令的输出前加上提示符，无论输出最终是显示在控制台上，还是重定向到跟踪文件中。默认情况下，提示符是当前目录后跟一个大于符号。例如，如果从* C:\Batch\* 目录运行清单 21-1 中生成日期戳的两行代码，它可能会生成以下输出到跟踪文件：

```
C:\Batch>set #=Wed 10/27/2004
C:\Batch>set datestamp=20041027 
```

但默认设置是可以更改的。提示符变量包含硬编码文本和/或特殊代码，定义了在 stdout 中看到的提示符内容，而提示符命令是更新提示符变量的工具。该命令的唯一参数是新的提示符变量，它将改变我们在 stdout 中看到的内容。

为了演示，如果我特别自恋并希望每行执行的代码上都带有我的签名，这个简单的命令可以满足我的虚荣心：

```
prompt Jack's$SCode$G
```

参数中有两段硬编码文本，分别是 Jack's 和 Code。此外，还有两个特殊代码，在单词之间插入一个空格（$S），在末尾插入一个大于符号（$G）。运行相同的两行代码，在同一天现在会生成如下输出：

```
Jack's Code>set #=Wed 10/27/2004
Jack's Code>set datestamp=20041027 
```

但是这个命令和变量并不是为了虚荣而创建的；它们是为了在提示符中填充自定义信息而创建的。考虑这个更为复杂和深奥的示例：

```
prompt %~NX0$A$N:$$$C$D$B$T$F$G
```

这个提示符命令并不容易阅读，但这里我将其分解如下：

%~NX0    Bat 文件名和扩展名；可能解析为 Datestamp.bat

$A    和符号；解析为 &

$N    驱动器字母；可能解析为 C

:    硬编码文本；显示为 :

$$    美元符号；解析为 $

$C    左括号；解析为 (

$D    日期；可能解析为 Wed 10/27/2004

$B    管道符号；解析为 |

$T    时间；可能解析为 23:39:12.34

$F    右括号；解析为）

$G    大于号；解析为 >

在你分配这个提示变量之后，执行相同的两行可能会得到如下输出：

```
Datestamp.bat&C:$(Wed 10/27/2004|23:39:12.34)>set #=Wed 10/27/2004
Datestamp.bat&C:$(Wed 10/27/2004|23:39:12.35)>set datestamp=20041027 
```

在这个提示变量中的这些实体，除了少数几个，都是特定于提示命令的特殊代码。一个字节，冒号，是硬编码的，第一个项目，%~NX0，只是一个解析后的变量。它恰好是正在执行的 bat 文件的名称和扩展名，但几乎任何变量都可以在这里使用。

时间的特殊代码 ($T) 允许你精确看到每个命令执行的时间。如果一个 bat 文件执行时间似乎比预期长，这是一个简单的方式来确定瓶颈。在前面的例子中，第二个命令执行的时间比第一个多了百分之一秒，这个信息会在提示符中显示出来，而其他部分保持不变。

另外，请注意，大于号 ($G) 是提示符中的最后一个字符。如果没有它，提示符会与后面的命令混在一起，产生相当难以读取的标准输出。它不是必须的，但最好在提示符末尾加上大于号或某种特殊字符。

你甚至可以在大于号后加上一个或两个空格，以进一步区分提示符和输出。无论当前提示变量是什么，这个命令都会在提示符后加上两个空格：

```
prompt %prompt%$S$S
```

这个命令清楚地展示了提示符的两种用法。假设默认的提示符是活动的，提示符变量解析为 $P$G（当前目录和大于号）。然后命令将此与 $S$S 连接，并将其作为提示命令的参数：

```
C:\Batch>prompt $P$G$S$S
```

这个命令激活带有尾随空格的新提示符，以执行任何后续命令：

```
C:\Batch>  set #=Wed 10/27/2004
C:\Batch>  set datestamp=20041027 
```

通过硬编码的文本和所有特殊代码可用的字符，你可以轻松地定制提示符，几乎可以实现任何你想得到的文本，以满足任何需求。我之前展示了一些特殊代码，但帮助命令提供了完整的列表。

### 随机数字

随机伪环境变量解析为一个介于 0 和 32,767 之间的随机数，包括两者。你可以用它来模拟抛硬币；偶数为正面，奇数为反面。如果你想随机启动一个过程在任意数量的服务器上，这个伪环境变量可以为你提供这种能力。

为了演示随机的一个用法，在第十五章中，我展示了交互式批处理，其中有一个 bat 文件提供笑话、双关语或谜语——但每次只提供其中一个。不幸的是，这些内容很快就用完了。现在，想象一个包含 100 个 bat 笑话、100 个 bat 双关语和 100 个 bat 谜语的库。不幸的是（或幸运的是），我不会在这里列出它们。再想象一下，当用户请求一个双关语时，我们从这个库中随机选择一个双关语。

为了实现这一点，我们需要做几件事。首先，我们需要将 100 个双关语放入数组中，以便单独选择它们。（这一点将在第二十九章中讨论。）更重要的是，我们需要一种生成 100 个可能数字中的一个随机数字的方法。以下的 set /A 命令使用随机伪环境变量和模运算符生成一个介于 0 和 99 之间的 *随机* 数字（可以说）：

```
set /A punNbr = %random% %% 100
```

如果将这些双关语标记为 0 到 99，我们可以简单地根据 punNbr 的值选择双关语。如果将双关语标记为 1 到 100，我们只需在结果中加 1：

```
set /A punNbr = %random% %% 100 + 1
```

我提到这“有点”有效的原因有两个。首先，像大多数计算机生成的随机数一样，这实际上是一个伪随机数，而不是真正的随机数。（是的，这就是伪随机的伪环境变量。）当 bat 文件第一次启动时，解释器会用当前时间为随机函数提供种子，这个时间会被用于生成后续请求的所有随机数的算法。这意味着，在同一时刻启动的两个 bat 文件会看到相同的伪随机数生成集——甚至是相隔几秒钟启动的两个 bat 文件，至少在最初的几次调用中，也会看到非常相似的 *随机* 数字。虽然伪随机数对于大多数应用程序来说是完全可以接受的，但还是要注意这一点。

punNbr 不是完全随机的第二个原因是 32,768 这个随机数的总数不能被 100 整除。如果你在这一节中执行第一次 set 命令 32,768 次（每次执行一次，数字从 0 到 32,767），结果为 0 的次数是 328 次。同样，1 到 67 的结果各出现 328 次。然而，68 作为结果的次数仅为 327 次，其余数字直到 99 也都是如此。结果是，有些数字会被 *随机* 选择的频率稍微高于其他数字。

本节的其余内容是一个略微有强迫症的数学家成为程序员，最终处理随机数的不可避免结果。大多数时候，伪随机数和模运算能完全完成任务，但如果你想知道如何尽可能接近真正的随机数，请继续阅读。

### cmdcmdline 变量

另一个有趣的伪环境变量是 cmdcmdline，或者*命令行命令*。它看起来很冗余，但它实际上是最初启动当前执行的命令行命令。在 Windows 计算机上，*.bat*扩展名默认与 Windows 的*cmd.exe*程序关联，当你打开一个 bat 文件时，这个程序会执行它。为了演示，假设*DateTime.bat*文件包含以下命令：

```
> con echo %cmdcmdline%
```

执行 bat 文件时可能会将这些内容写入控制台：

```
C:\WINDOWS\system32\cmd.exe /C ""C:\Batch\DateTime.bat" "
```

当你打开或双击一个 bat 文件时，Windows 在后台会调用*cmd.exe*程序，并传入/C 选项和 bat 文件作为其参数。如果这个 bat 文件调用了另一个 bat 文件，cmdcmdline 的值不会改变。它始终是启动高级进程的命令。

你可以解析这个变量来获取一些有用的信息。即使从被调用的 bat 文件中，你也可以检索到原始的参数列表。如果你已经将 stdout 重定向到跟踪文件，跟踪文件的路径和名称就位于变量值的末尾，准备好被提取。一个 bat 文件可能被设计成可以在两种不同模式下运行，独立运行或被另一个 bat 文件调用，每种模式下需要略有不同的逻辑。为了智能地确定模式，可以将这个变量的内容与%0 隐藏参数进行比较。如果你发现这两个字段中都包含同一个 bat 文件的名称，那么它就是高级 bat 文件，因此是独立的。如果没有，那么它一定是被调用的 bat 文件。

### 系统变量

另一类伪环境变量告诉你 bat 文件执行所在的机器信息。它们被称为*系统变量*。

这些系统变量的一个示例包括 USERNAME、USERPROFILE、PROCESS_ARCHITECTURE、NUMBER_OF_PROCESSORS 等，这些对任何熟悉 Windows 计算机工作原理的人来说都有意义。变量 ProgramFiles 解析为 Microsoft 安装其 64 位程序文件的根目录，而 ProgramFiles(x86)则对其 32 位版本做同样的事。

在这些冗长命名的变量之后，可能会显得有些奇怪，但 OS 是*操作系统*的一个简化缩写。用于存储*临时*文件的目录足够特殊，值得拥有两个系统变量 TEMP 和 TMP，而你可以通过 windir 引用根*Windows 目录*。

USERDOMAIN 变量在你的 bat 文件可以在不同域中运行时非常有用，甚至可能在不同的物理位置。每个域可能有不同的基础设施，例如某些资源的路径，而这个变量是使代码足够智能以便在多个位置运行的关键。我常用的另一个系统变量是 COMPUTERNAME。如果一个进程可以在几十台服务器中的任何一台上启动，你可以使用这个变量轻松确定 bat 文件在哪里被执行。

> 注意

*尽管看起来可能不一致，但我在本节中对系统变量名称的大小写并不是随意的。你可能知道所有批处理变量都是不区分大小写的，而我通常使用驼峰式命名，但我展示每个伪环境变量的方式是按照微软的呈现方式——即，通过在命令提示符下运行没有参数的 set 命令时所显示的内容，以避免任何混淆。有些完全大写，有些完全小写，有些是驼峰式命名，有些甚至是蛇形命名（用下划线分隔的单词），还有一些甚至在变量名中包含括号。这对于任何渴望一致性的人来说，简直是噩梦。*

进一步探索。打开命令提示符并输入三字节命令 set，查看你计算机上设置的所有变量。所有这些变量在该计算机上运行任何 bat 文件时都会可用。

### Bat 文件与 cmd 文件

在第一章中，我介绍了 bat 文件和 cmd 文件。当时，我提到从编码者的角度来看，唯一显著的区别在于解释器设置返回码的方式和时机。这里我将详细说明这些区别。

我们已经讨论过三个命令，当命令执行失败时，会将 errorlevel 设置为非零值：set、path 和 prompt。实际上，大多数命令都会这样做，但它们的不同之处在于，当命令执行成功时，它们不会将 errorlevel 设置为 0。最终的结果是，执行这些命令后，你不能信任 errorlevel 的值。

然而，在 cmd 文件中，成功执行这些命令时，errorlevel 总是设置为 0，而当命令执行失败时，errorlevel 总是设置为非零值。（我说这是*最大的*区别。我并没有说这是*很大的*区别。）

大多数编码者，包括我自己，很少检查这些命令的返回码。即使你将一个不存在的目录传给 path 命令，它也不会失败；只有在某些原因导致它无法用有效路径重置变量时才会失败，而我从未见过这种情况。同样，prompt 命令几乎接受任何东西作为提示变量，我也从未见过它失败。使用 set 命令设置简单变量也很难出错。唯一可能的例外是使用 set /A 做一些算术运算时。例如，缺少操作数或除以零会生成非零的 errorlevel 值。

话虽如此，如果你想在执行这些命令后检查 errorlevel，有两种解决方法。首先，在使用 bat 文件时，无论以何种方式，你都需要在执行 set、path 或 prompt 命令之前，将 errorlevel 重置为零。如果命令失败，解释器会将 errorlevel 重置为非零值；如果命令成功，errorlevel 仍然是零。另一种选择是使用 cmd 文件。

在 bat 文件中将返回码设置为零有一个障碍。一般来说，问题在于如何设置伪环境变量。更具体地说，errorlevel 永远不应通过 set 命令设置，但总有解决办法。

### 设置伪环境变量

你有能力设置和重置一些伪环境变量。你已经了解到，path、cd 和 prompt 既可以作为命令，也可以作为变量，命令会重置同名的变量。它们在 bat 文件启动时会设置为默认值，但你可以更改这些值。

其他伪环境变量，如 windir，在 bat 文件启动时已经设置，重置它们是愚蠢的行为。解释器在 bat 文件执行过程中会设置并重置其他这样的变量，可能多次。例如，大多数命令会重置 errorlevel；time 变量每 1/100 秒就会获得一个新值，如果 bat 文件在午夜运行，date 也会发生变化。你绝不应该设置这些变量。请注意，我没有写出你*不能*设置这些变量。没有什么能阻止你执行这个命令：

```
set errorlevel=0& rem Never Never Never Do This... Ever
```

没有编译器来阻止这种傲慢行为。解释器不会中止并崩溃执行，它本质上说：“你现在想设置 errorlevel 吗？这是我的变量，但如果你想要它，没问题，它现在是你的了。不过，我再也不管它了。”我可能把解释器拟人化得太过了，但它有时真的显得非常消极攻击性。

这个简单但不明智的 set 命令将变量转换为一个简单的用户变量，并将其从伪环境变量的范畴中移除。随后执行的命令将会成功或失败，这些命令通常会生成返回码，但由于 errorlevel 不再是伪环境变量，它将保持原样，不会从其错误分配的值中改变，直到运行流结束或另一个不明智的 set 命令再次错误地重置它。

一些永远不应通过 set 命令设置的伪环境变量包括 errorlevel、date、time、cmdcmdline 和 random。如果有疑问，最好假设任何伪环境变量都不应该被重置。重置这些变量大多数时候没有意义，但有一个你可能希望重置：errorlevel。在上一节中，我详细描述了这种场景。

以下命令在没有提及 errorlevel 的情况下将 errorlevel 重置为 0：

```
cmd /C exit 0
```

cmd 命令打开一个新的命令行窗口，/C 选项告诉解释器执行其后的命令，并在执行完毕后终止新命令行窗口。在这个示例中，它执行一个简单的退出命令，返回 0。结果是，它将 errorlevel 设置为 0——无需使用 set 命令。

如果这看起来有点熟悉，那是因为我在本章前面提到过 *cmd.exe* 程序。你可以使用 cmd 命令调用这个程序，它也是解释器，从而执行 bat 文件或其他命令。

### 总结

真正理解伪环境变量将为你提供更多工具，让你完成更多任务。我没有提供一个详尽的列表，但我提到了重要的几个。你已经学会了如何操作提示符，如何生成随机数，以及错误设置某些伪环境变量的危险。我还在两种情况下讨论了 errorlevel 伪环境变量。你可以将它重置为任何数字，但并不是你可能想象的那样，并且它在 bat 文件中和 cmd 文件中的表现有所不同。

在下一章中，你将学习如何使用日期和时间伪环境变量在批处理文件中创建和格式化报告。
