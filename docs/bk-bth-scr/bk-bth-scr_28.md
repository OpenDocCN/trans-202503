

## 第二十五章：25 批处理文件构建批处理文件



![](img/chapter.jpg)

在我们的后工业时代，制造商可以相对轻松地制造一个烤面包机，但没有人能制造出一个能够制造另一个烤面包机的烤面包机，我敢说，任何制造商都不可能做到这一点。至少部分上，机器人可以制造机器人，但汽车不能制造汽车，智能手机也不够聪明，无法制造任何具有智能的手机。然而，在软件领域，代码创造代码，程序传播程序，而批处理文件则创造批处理文件。

本章不是讨论飞行哺乳动物的繁殖，而是讨论一个批处理文件如何创建另一个批处理文件的技术。几种编程语言提供了自动化代码生成器，但这些通常只创建一个模板或一个良好的起点，供你进行有趣的编码工作。而这里我指的是，一个批处理文件可以创建另一个完全功能且准备好执行的批处理文件。

如果这听起来像是一个魔术把戏，那可不是。你可能需要从一个批处理过程中获取信息，才能编写后续过程的代码。与其为第二个过程编写批处理文件，不如让第一个批处理文件足够智能，能够写出第二个文件，并且包含所有需要的信息。这还可以让一个批处理文件根据输入的大小，动态地拆分大型过程，创建任意数量的过程。

我将首先直接展示一个完整的逐步示例，讲解一个批处理文件如何构建另一个批处理文件，从父级批处理文件到创建的子级批处理文件，最终到子级文件的输出。我还将详细说明如何用静态数据、已解析变量和未解析变量填充一个动态创建的批处理文件。我会将这一切与一个现实世界的应用结合起来，展示多代批处理文件，并且最重要的是，讨论这种技术的有用应用。

### 动态创建批处理文件

解释批处理文件构建批处理文件如何工作的最佳方式是通过一个简单但（希望）有趣的示例，因此我将从 *Mother.bat* 的演示开始。当它执行时，它会在控制台显示它的名字，这并不新鲜，然后继续做一件曾经听起来像是炼金术的事情：构建一个恰如其名的 *Daughter.bat* 文件，这是一个将在执行时把自己的名字以及赋予它生命的批处理文件的名字显示到控制台上的批处理文件。

清单 25-1 不是一个代码片段；它展示了完整的 *Mother.bat* 文件内容，这是父级批处理文件。

```
@setlocal EnableExtensions EnableDelayedExpansion
@echo off
❶ > con echo ***** This bat file is "%~NX0".
> con echo.

set batDtr=C:\Batch\Daughter.bat
❷ >  %batDtr% echo   @setlocal EnableExtensions EnableDelayedExpansion
>> %batDtr% echo   @echo off
❸ >> %batDtr% echo   ^> con echo ***** This bat file is "%%~NX0".
❹ >> %batDtr% echo   ^> con echo ***** It was created by "%~NX0".
❺ >> %batDtr% echo   ^> con echo.
❻ >> %batDtr% echo   pause
❼  pause 
```

清单 25-1: 父级批处理文件，Mother.bat

bat 文件以 setlocal 命令开始（就像我写的所有 bat 文件一样）。它将 echo 设置为关闭，从而保持控制台显示干净。代码的第一部分以两个 echo 命令结束，分别将 bat 文件的名称写入控制台，并随后加上一个空行 ❶。由于我们没有进入常规过程，%~0 解析为正在执行的 bat 文件的路径和名称的隐藏参数（第十一章）。通过使用两个修饰符，%~NX0 只提取隐藏参数中的文件名和扩展名（第十七章）。

bat 文件的最后一部分才是最有趣的地方。六个 echo 命令分别写一行来构建子 bat 文件。第一个 echo 命令 ❷ 使用一个重定向字符创建子 bat 文件，并将 setlocal 命令写入其中。（我提到过，我写的每个 bat 文件都以这个命令开始，这对于通过其他 bat 文件间接写入的 bat 文件同样适用。）

这里没有执行 setlocal 命令；这段代码将其视为简单文本，将其重定向或写入 *Daughter.bat*。不要把它当作 setlocal 命令，而应当视作 *proto* setlocal 命令。echo 命令后跟三个空格；第一个空格将命令本身与它写入的文本分开，接下来的两个空格是它写入文件的文本的一部分。从功能上讲，这两个额外的空格不是必需的，但出于美学考虑，我总是进行缩进，即使是在动态创建的 bat 文件中也是如此。

执行重定向的多个命令似乎每个都有两个 echo 命令。从这些命令中的最后一个 ❺ 开始，第一个 echo 将一行写入子 bat 文件，这一行完全由 `> con echo.` 文本组成。插入符号转义字符在这里至关重要。如果没有它，解释器会把它后面的大于号当作第二个重定向操作符，这显然是不好的。有了插入符号，大于号只是作为另一个字符写入子 bat 文件。

之前的两个命令看起来非常相似。它们都是将记录写入 *Daughter.bat*；这两条记录都是 echo 命令，将某些内容写入控制台，并且都使用插入符号作为其重定向字符的转义字符。然而，它们之间有一个关键的区别。

每个命令在星号后写出不同的文本，但这无关紧要。第一个命令❸在文件名解析中看似有第二个百分号符号。别被这微妙之处欺骗；它是本章的关键。第二个命令❹中的文本实际上解析为父 bat 文件的名称。但是在第一个命令❸中，第一个百分号符号是第二个百分号符号的转义字符，这意味着解释器将这两个字符解析为一个百分号符号，并将其作为普通文本字符写入文件。因此，后面的波浪号和其他字符在这个上下文中对 Batch 没有特殊含义，解释器也将它们按原样作为文本写入子 bat 文件。

这话不必说得太尖锐，但以下是解释解释器如何在写入子 bat 文件时处理这些相似文本字符串的方式：

+   “%%~NX0”文本❸变成了“%~NX0”。

+   “%~NX0”文本❹变成了“Mother.bat”。

父 bat 文件写入最后一行，这将成为子 bat 文件中的暂停命令❻。最后，一个真正的暂停命令❼将*Mother.bat*补充完整。

现在我们可以执行*Mother.bat*，这是 Listing 25-1 中展示的 bat 文件构建 bat 文件。它的第一部分代码中的“%~NX0”❶解析为“Mother.bat”，然后在控制台上显示以下内容：

```
***** This bat files is "Mother.bat".

Press any key to continue ... 
```

*Mother.bat* 结尾的那个暂停命令保持控制台打开，以便我们可以阅读这个信息。

更有趣的是，*Mother.bat* 创建了 *Daughter.bat*，一个完全功能的 bat 文件。这个观点不能过分强调；Listing 25-2 中展示的 bat 文件*并非*由人直接创建。

```
@setlocal EnableExtensions EnableDelayedExpansion
@echo off
> con echo ***** This bat file is "%~NX0".
> con echo ***** It was created by "Mother.bat".
> con echo.
pause 
```

Listing 25-2: 子 bat 文件，Daughter.bat

子 bat 文件有六条记录，其中中间的两条最为有趣。正如预期的那样，解释器将*Mother.bat* (Listing 25-1)中的“%%~NX0”解析为*Daughter.bat*中的第一个 echo 命令中的“%~NX0”。当*Daughter.bat*本身（她？）执行时，这一点很重要。同样，子 bat 文件中的下一个 echo 命令包含了“Mother.bat”文本，这是解释器从父 bat 文件中的“%~NX0”解析出来的。

这最终导致执行子 bat 文件 *Daughter.bat*。像运行任何其他 bat 文件一样运行它，它会将以下内容写入控制台：

```
***** This bat file is "Daughter.bat".
***** It was created by "Mother.bat".

Press any key to continue ... 
```

当子 bat 文件执行时，解释器将第一个重定向的 echo 命令中的“%~NX0”解析为“Daughter.bat”。下一行输出来自包含已解析的“Mother.bat”的 echo 命令。

总结一下，我们来看看从父文件到子文件再到子文件输出的流程。当父 bat 文件执行时，“%%~NX0”在子 bat 文件中变成了“%~NX0”——再次，由于转义，两个百分号符号会解析为一个。然后当子 bat 文件执行时，“%~NX0”在最终输出中解析为“Daughter.bat”。

与此对比，父级 bat 文件中的 `"%~NX0"` 会变成子级 bat 文件中的 "Mother .bat"。从子级的角度来看，那时它是硬编码文本，并且当子级 bat 文件执行时，它会将 "Mother.bat" 写入控制台。

这个例子展示了两个重要的观点。首先，完全可能通过 bat 文件创建另一个功能齐全的 bat 文件。其次，一些包含转义字符的文本可以成为子级中一个 *可解析* 的变量，而不是已经解析的变量。换句话说，父级可以将一些文本写入子级，而当子级执行时，这些文本会解析为变量的值。但这个例子只是触及了其中的可能性。

没有人会将这个过程与未来某天可能会消灭或奴役全人类的人工智能混淆，但我不会称 *Mother.bat* 为一个愚蠢的 bat 文件。

### 变量解析

现在你可以在父级或子级 bat 文件中解析隐藏参数，但解析普通变量在任一 bat 文件中同样重要，甚至更为关键。

用百分号和感叹号定界的变量行为有所不同。为了演示这一点，下面的代码列出了两个在所有 Windows 计算机上设置的系统变量：`computername` 是计算机的名称，`os` 是计算机的操作系统（第二十一章）。此代码创建一个名为 *Dynamic.bat* 的小型 bat 文件：

```
set batDyn=C:\Batch\Dynamic.bat 
>  %batDyn% echo   @setlocal EnableExtensions EnableDelayedExpansion
>> %batDyn% echo   @echo off 
❶ >> %batDyn% echo   ^> con echo This bat was built on %computername%,
>> %batDyn% echo   ^> con echo       using the operating system !os!.
❷ >> %batDyn% echo   ^> con echo This bat is running on %%computername%%,
>> %batDyn% echo   ^> con echo       using the operating system ^^!os^^!.
>> %batDyn% echo   pause 
```

我已经将第一次引用到的 `computername` 用一对百分号符号 ❶ 括起来，在接下来的命令中，我将第一次引用的 `os` 用一对感叹号括起来。（这两种定界符都适用于这两个变量；我只是对比并比较它们而已。）这两个变量在这两条 echo 命令执行时会解析为各自的值，可能会将以下内容写入动态 bat 文件：

```
> con echo This bat was built on JACKLAPTOP,
> con echo       using the operating system Windows_NT. 
```

然而，接下来的两条 echo 命令 ❷ 会写出以下两行：

```
> con echo This bat is running on %computername%,
> con echo       using the operating system !os!. 
```

当解释器遇到 `%%computername%%` 时，它并不会将其识别为变量。由于百分号本身是转义字符，每对百分号都会解析为一个单独的百分号符号，且它们之间的文本并不是一个变量名；至少目前来看，它只是随便附带的。正如在 第十四章 中详细说明的那样，转义感叹号稍微复杂一点，但 `^^!os^^!` 同样会解析为 `!os!`。

在任何计算机上执行子级 bat 文件 *Dynamic.bat* 时，前两条 echo 命令会将现在的硬编码文本写入控制台——也就是说，它们写入的是第一个 bat 文件运行的计算机上的信息。然而，接下来的两条 echo 命令包含两个变量，这两个变量会在 *Dynamic.bat* 执行时解析，它们的值会反映出运行此子级 bat 文件的计算机的计算机名称和操作系统。

让我们看一个实际应用来演示何时将变量解析并写入子级 bat 文件是有意义的，何时将其解析并执行时再进行处理才更合适。

### 一个实际应用

之前的示例展示了如何在动态创建的批处理文件中解析变量和参数，但这些示例本质上是教学用的。仅仅用来宣布其来源和当前状态的批处理文件并没有实际用途。一个真实的批处理文件构建批处理文件将会做更多的事情，并且更加有用。

例如，它可能会将变量从父级传递到子级。每当批处理文件执行时，它会累积和修改变量，但没有什么是自动将这些变量赋值到动态创建的批处理文件中的。确保变量在其后代文件中保留的简单方法是写入一个`set`命令，将该变量传递给子文件。当该批处理文件运行时，`set`命令执行，变量将可用，直到它被重置或文件执行结束。

我已经展示了如何用`echo`命令写入一行代码，但你也可以使用`type`命令将整个文件的内容写入动态创建的批处理文件中（第十二章）。通常，我会用前言静态文件开始一个子批处理文件，并用尾声静态文件结束它。

前言静态文件可能以`setlocal`命令开始（因为大多数批处理文件应该这样做），并且很可能设置了一些变量，但其后内容可以是任何内容。重要的是，这个文件包含硬编码的批处理代码，启动每个动态创建的批处理文件的过程。同样，尾声静态文件包含完成所有子批处理文件所需的公共代码。至少，它通常包含一些可调用的例程和错误处理。

静态批处理文件不必仅仅出现在动态创建的批处理文件的开始和结束。你可以插入其他命令，并且将多个`type`命令与`echo`命令交替使用。你甚至可以将少量代码存储在一个静态文件中，以避免使用转义字符。

以下列表包含一个实际批处理文件构建的模板：

```
set batDyn=C:\Batch\Dynamic.bat
❶ >  %batDyn% type C:\Batch\StaticPrologue.bat
❷ >> %batDyn% echo.
❸ >> %batDyn% echo   set someVar=%someVar%
>> %batDyn% echo   set someOtherVar=%someOtherVar%
❹ >> %batDyn% echo   set parentPath=%path%
>> %batDyn% echo.
❺ >> %batDyn% echo   %someExe%
❻ >> %batDyn% echo   if %%errorlevel%% neq 0 ^(
❼ >> %batDyn% echo      ^> con echo Some EXE FAILED
>> %batDyn% echo      pause
>> %batDyn% echo      goto :Abort
❽ >> %batDyn% echo   ^)
❾ >> %batDyn% type C:\Batch\StaticEpilogue.bat 
```

初看起来，开始创建*Dynamic.bat*的重定向❶可能像是众多`echo`命令中的第一个，但实际上它是列表中第二个`type`命令的第一个。这个命令将*StaticPrologue.bat*文件的全部内容写入动态创建的批处理文件中。

两个`echo`命令❸演示了如何在子批处理文件中保持父级变量。每个逐渐展开的`set`命令的参数都包含变量名，等号左侧是变量名，右侧是解析后的值。看起来有些冗余，但这会变成一个硬编码的`set`命令，将值赋给子批处理文件中的变量。

接下来的 echo 命令 ❹ 展示了这一技术的一个变体；新的变量获得了一个新的名称。子 bat 文件可能需要知道父 bat 文件使用的路径变量，但我们不想影响子文件自身的路径变量。此命令写入一个 set 命令，最终会将父文件路径变量的完整内容赋值给一个名为 parentPath 的变量，当 *Dynamic.bat* 执行时。

使用转义技术来创建动态 bat 文件有两个原因。首先，用于解析变量的百分号和感叹号有时需要转义——这取决于我们何时应该解析变量。

*Dynamic.bat* 将调用某个可执行文件，然后检查返回码。在这个示例中，假设我们在创建动态 bat 文件时就已经知道了可执行文件。因此，我只是将变量解析为 %someExe% ❺ 并将其直接写入动态 bat 文件中，成为硬编码的文本。

返回码 ❻ 是一个完全不同的故事；显然，我们*不应该*在命令执行之前解析它，因为动态 bat 文件在运行时会执行此命令，所以我使用了转义字符来处理分隔符。解释器看到 %%errorlevel%% 并将 %errorlevel% 写入文件。如果没有转义字符，变量会在写入时直接解析为它当时的状态，可能是 0，导致一个永远为假的条件语句：if 0 neq 0。转义字符将其保留为尚未解析的变量。

使用转义字符的第二个原因是在字符在 Batch 中有其他特殊意义时。例如，当管道符和与符号要作为动态代码的一部分时，必须始终对它们进行转义。在这个例子中，我们需要转义代码块周围的开括号 ❻ 和闭括号 ❽，以及代码块内部的重定向符号或大于号 ❼。

假设 someExe 被设置为某个特定值，解释器可能会将 ❺ 和 ❽ 之间的代码段写入动态 bat 文件，如下所示：

```
C:\Batch\SomeExecutable.exe
if %errorlevel% neq 0 (
   > con echo Some EXE FAILED
   pause
   goto :Abort
) 
```

第二个 type 命令 ❾ 补充了这个列表，并将整个 *StaticEpilogue.bat* 写入动态文件。它可能使用了之前代码中明确写入动态 bat 文件的三个变量。考虑到代码块内的 goto 命令，我也很有信心这个文件中某处会有一个 :Abort 标签。不管它的内容是什么，它们都会完成动态 bat 文件的编写。

但是，将静态文件写入子 bat 文件时有一个微妙的警告。我忽略了代码中一个非常关键的命令，这么关键，以至于我把它留到了最后。在第一个 type 命令将静态序言数据写入动态创建的 bat 文件之后，一个简单的 echo 命令 ❷ 会向 *Dynamic.bat* 添加一个空行。

您可能会认为我这样做只是为了简单地分隔新批处理文件中的静态代码和即将到来的设置命令，这本身就是一个很好的理由。毕竟，在设置命令之后的空白行❹也仅为此目的创建了一些空白空间，但是第一个空白行的作用远不止美观。

为了解释这个空白行修复的问题，我曾经与一个同事分享过这个批处理构建技术，他在其*StaticPrologue.bat*的等效末尾设置了一个关键变量：

```
set criticalVar=criticalValue
```

这些数据是文件的最后；甚至没有尾随的空白行。这很快就会变得至关重要。

在他的主批处理文件中的 type 命令之后，他没有写一个空白行。相反，他设置了一个变量：

```
>> %batDyn% echo   set someVar=%someVar%
```

最终结果是他动态批处理文件中间的这行代码：

```
set criticalVar=criticalValue  set someVar=Whatever
```

看起来像是第二个设置命令实际上并不是命令；它只是更多文本的附加，包括空格，附加到*实际*设置命令的预期值上。结果是动态代码未将 criticalVar 设置为预期值，并且根本没有设置 someVar。显然，结果是垃圾，但是是什么导致了这种情况？

当解释器执行重定向到文件的 echo 命令时，它将文本追加到目标文件的末尾。然后解释器立即追加两个字符以换行回车，或者更不正式地说，添加一个 CRLF。（我在第十四章详细描述了 CRLF。）最终结果是，在编辑器中查看时，在文件底部会有一个空行。当您连续重定向多个 echo 命令时，每个命令都会追加一行文本和一个 CRLF，以便下一个命令将其文本追加为新记录。

当你仅通过 echo 命令动态生成代码创建文件时，这很有效，但是 type 命令会将整个文件原样写入目标而不添加 CRLF。如果静态批处理文件的创建者没有在文件的最后一个记录上附加 CRLF，则可能会引发问题。（也就是说，他们没有将光标定位在最后一个记录的末尾，按 ENTER 键并保存文件。）当解释器将缺少该 CRLF 的静态文件写入动态批处理文件，然后尝试通过 echo 命令追加记录时，实际上会将该记录追加到复制的静态数据的最后一个记录上，导致我们在这里看到的一团糟。（这也导致了一位沮丧的同事试图弄清楚为什么一些变量没有按预期解析。）

`echo.`命令❷会写入一个空白记录（甚至没有任何空格），更重要的是，会写入一个 CRLF（回车换行符）。在这里加入它是为了确保，如果静态文件的最后一条记录缺少 CRLF，代码会在动态生成的 bat 文件中插入另一个 CRLF；如果 CRLF 并不缺失，它会写入一个空记录，这样能很好地分隔代码部分。如果你真的依赖那个空白行，可以写两行空白。

看似是一个永无止境的战斗，要让代码万无一失，并预见到所有可能导致它崩溃的条件，但有两种主要方法可以避免这个问题：确保你使用的每个静态文件都以 CRLF 结尾，或者在每个未完成子 bat 文件的`type`命令后写入一个空白行。我发现用后者方法在代码中控制这一点更容易，但总是做两者也是个不错的主意。

### 多代 bat 文件

这句话“给我一个足够长的杠杆和一个支点，我将撬动地球”通常归于阿基米德。我想，如果古希腊人有 Batch，伟大的思想家一定会说，“给我足够的转义字符和磁盘空间，我将创建一个无限生成 bat 文件的 bat 文件。”毫无疑问，这句话与原文相比显得苍白无力，但转义字符是可以被转义的，而 bat 文件也不限于单一的后代生成。

去掉所有多余的部分，这个简化版的*Mother.bat*会创建一个子 bat 文件，这个子 bat 文件将会创建它自己的后代：

```
set batDtr=C:\Batch\Daughter.bat
>  %batDtr% echo   set batGDtr=C:\Batch\GrandDaughter.bat
>> %batDtr% echo   ^>   %%batGDtr%% echo   @echo off
>> %batDtr% echo   ^>^> %%batGDtr%% echo   ^^^> con echo I am "%%%%~NX0"
>> %batDtr% echo   ^>^> %%batGDtr%% echo   ^^^> con echo Begat by "%%~NX0"
>> %batDtr% echo   ^>^> %%batGDtr%% echo   ^^^> con echo Begat by "%~NX0"
>> %batDtr% echo   ^>^> %%batGDtr%% echo   pause 
```

执行*Mother.bat*会产生*Daughter.bat*：

```
set batGDtr=C:\Batch\GrandDaughter.bat
>  %batGDtr% echo   @echo off
>> %batGDtr% echo   ^> con echo I am "%%~NX0"
>> %batGDtr% echo   ^> con echo Begat by "%~NX0"
>> %batGDtr% echo   ^> con echo Begat by "Mother.bat"
>> %batGDtr% echo   pause 
```

注意到`^>`会转义成`>`，而`%%`会转义成`%`，但是通过转义转义字符，`^^^>`会变成`^>`，`%%%%`会变成`%%`。

执行*Daughter.bat*会产生*GrandDaughter.bat*：

```
@echo off
> con echo I am "%~NX0"
> con echo Begat by "Daughter.bat"
> con echo Begat by "Mother.bat"
pause 
```

运行*GrandDaughter.bat*会在控制台输出如下内容，其中`%~NX0`最后一次解析为"GrandDaughter.bat"：

```
I am "GrandDaughter.bat"
Begat by "Daughter.bat"
Begat by "Mother.bat"
Press any key to continue ... 
```

我有个承认的地方。这个最后的例子不过是作者无耻炫耀的一个明显实例——就像是程序员版的触地舞或扣篮后的垃圾话。我已经编写批处理脚本很多年了，这是我第一次甚至想到编写一个 bat 文件来构建另一个 bat 文件，进而构建一个新的 bat 文件。我这么做只是为了展示可能性，实际上很难想到它的现实应用场景，但创建一个生成第二个 bat 文件的 bat 文件，确实有很多用途。

### 推荐

你可以使用前面讨论过的实际应用作为更复杂的动态 bat 文件的模板。它包含了你需要的所有部分：它分配变量，使用现有和新创建的名称；它使用转义来允许后续解析变量；它转义其他特殊字符，以便在子 bat 文件中使用；它还使用部分静态 bat 文件与动态生成的代码配合使用。

当一个过程增长到需要将其拆解为更小的部分并独立执行时，这种技术非常有效。也许你会根据输入的大小来进行拆分，从而编写一个 bat 文件，首先检查输入后动态生成一个或多个 bat 文件。换句话说，你可以动态创建一个动态数量的子进程。

不同的子过程可能最终在不同的服务器上运行，以平衡负载。你可能能够使用静态的 bat 文件处理这些子过程，但当你动态生成其他 bat 文件时，可以在执行原始 bat 文件的过程中收集信息，并将其注入到新生成的 bat 文件中。

有人可能会反对，认为你可以将动态信息作为参数传递给第二个 bat 文件，但这只有在第一个 bat 文件确实调用第二个时才有效。可能有其他完全不同的进程会执行你动态创建的 bat 文件。那个进程不需要传递任何参数，甚至不需要理解 bat 文件的内容或功能。你甚至可以创建一个 bat 文件，暂时保留它，并在稍后的时间执行它。

### 总结

在本章中，我展示了一个 bat 文件如何构建另一个 bat 文件。在详细演示之后，我讨论了如何将已解析的变量和可解析的变量写入动态 bat 文件。我还分享了我用于在动态 bat 文件中创建变量以及构建包含动态和静态代码的 bat 文件的一些技术。你学到了动态生成的 bat 文件最有用和最适用的情况。

在下一章中，我将演示一个有趣的 bat 文件构建应用。在讨论了一个非常有用的技术——自动重启间歇性失败之后，我将应用本章中的经验，执行一个更为复杂的任务：终止并重启挂起的执行。我们将动态创建第二个 bat 文件来调用易于挂起的进程，并从第一个 bat 文件中监控它。随着工具箱的不断扩展，问题开始在工具中找到解决方案，真是令人惊叹。
