

## 第二十二章：22 撰写报告



![](img/chapter.jpg)

即使用力眯眼到差点得脑动脉瘤，也没有人会把批处理程序误认为是 Power BI 或其他类似的报告生成工具，但当你需要一个简单的格式化文本报告时，批处理程序是一个可以胜任的工具。

在本章中，我们将构建一个基于管道分隔输入文件的报告。通过上一章的两个伪环境变量，你将学习如何构建一个包含当前日期和时间的标题，以及格式化的列标题。你还将通过读取输入文件并使用在第二部分中学到的某个命令来创建详细记录。我将分享一些技术，用于将字符串、整数和浮动点数据右对齐或左对齐，并在固定宽度或等宽字体中整齐排列列。最后，你将学习如何对数据进行汇总，创建带有总量和平均量的尾部记录。

如果你想生成饼图、直方图或散点图……还有其他工具可以选择。

### 数据和报告

本次练习中，我们将从一个简单的管道分隔文件开始，文件包含了 2019 年少数精选富裕国家的三项重要健康指标。每条记录的第一个标记是国家名称，后面跟着该国用于医疗保健的国内生产总值百分比。这是衡量一个国家在其总体财富中用于医疗保健开支的一个很好的指标。第三个标记是预期寿命，最后一个是每 10 万人中的可避免死亡人数。可避免死亡是指由于缺乏有效且高质量医疗保健而导致的死亡，例如糖尿病、高血压和某些癌症等疾病。这两个指标是衡量医疗系统效果的非常好的标志。*HealthStats.dat* 文件可以包含任意数量的记录，但为了简便起见，我这里只包含了七个国家及其统计数据，如清单 22-1 所示。

```
Australia|9.3|82.6|62
Canada|10.7|82|72
France|11.2|82.6|60
Germany|11.2|81.1|86
Sweden|11|82.5|65
UK|9.8|81.3|84
US|16.9|78.6|112 
```

清单 22-1：包含健康统计数据的管道分隔 HealthStats.dat 文件

注意前两个数字标记是浮动点值，但有人（是我）没有为某些条目的值包含.0。我们需要在代码中考虑到这一点。（该文件中的数据来自“英联邦基金会”，并经许可使用，网址是* [`www.commonwealthfund.org/publications/issue-briefs/2020/jan/us-health-care-global-perspective-2019`](https://www.commonwealthfund.org/publications/issue-briefs/2020/jan/us-health-care-global-perspective-2019) *。）

这是很棒的数据，但管道分隔文件的可读性并不出名。我们的任务是将清单 22-1 中的数据转换成清单 22-2 中更具可读性和描述性的报告。

```
 A Comparison of National Health
            Expenditures and Outcomes, 2019
             Date: 03/23/2020  Time: 14:30

                 % of           Life          Avoidable
Country          GDP         Expectancy      Deaths/100K
-------          ----        ----------      ----------- 
Australia         9.3           82.6              62
Canada           10.7           82.0              72
France           11.2           82.6              60
Germany          11.2           81.1              86
Sweden           11.0           82.5              65
UK                9.8           81.3              84
US               16.9           78.6             112
-------          ----        ----------      -----------
Averages         11.4           81.5              77 
```

清单 22-2：由 HealthRpt.txt 批处理文件生成的报告

最多你也只能称这个报告为功能性报告。它没有你在浏览器中查看的 HTML 报告那样的不同字体大小、框架、突出显示、自动居中或其他特性，但它是有用的、信息丰富且格式良好的。

这样一份报告有三个不同的部分：介绍、正文和总结，分别由头记录、详细记录和尾记录组成。我会分享完整的批处理文件来构建这个报告，但我会将其分解成这三部分。在本章结束时，你将能够构建自己的数据文件并生成自己的报告。

### 头记录

开始的明显位置是介绍部分，包括标题和列头。以下是创建报告的批处理文件的第一部分：

```
setlocal EnableExtensions EnableDelayedExpansion
❶ set rpt=C:\Batch\HealthRpt.txt
❷ set cnt=0
set totPerGDP=0
set totLifeExp=0
set totDeaths=0

❸ >  %rpt% echo              A Comparison of National Health
>> %rpt% echo             Expenditures and Outcomes, 2019
>> %rpt% echo              Date: %date:~4%  Time: %time:~0,5%
>> %rpt% echo.
❹ >> %rpt% echo                  %% of          Life          Avoidable
>> %rpt% echo Country          GDP          Expectancy      Deaths/100K
>> %rpt% echo -------          ----        ----------      ----------- 
```

在打开的`setlocal`命令后，我们定义了 rpt 变量 ❶，其包含报告文件的路径和名称。我保持变量名简洁，因为我们每次写入报告记录时都会使用它，这将是非常频繁的。接下来，我们将四个变量 ❷ 初始化为 0。cnt 变量用于记录详细记录的数量，其他变量则是报告中三个数量的总和，我们将在批处理文件的后两部分使用它们。

介绍部分实际上由两部分组成：标题 ❸ 和列头 ❹。在这个特定报告中，它们总共占用了七个头记录，我们将通过七个`echo`命令将它们重定向到报告文件中。

我们通过将标题的开头重定向到由 rpt 变量定义的文件 ❸ 来启动报告；仅对这条命令使用了一个重定向符号，所以如果文件已存在，将会覆盖它。接着，我们将标题的其余部分附加到文件中，后面跟上日期和时间，并通过`echo`命令输出一个空行。

我们在第三个记录中填充日期和时间，分别使用恰如其名的日期和时间变量。这些伪环境变量在第二十一章中介绍，它们提供了一种简单的方法来记录报告生成的时间。注意，我从每个值中提取部分信息，以去除日期中的星期几和时间中的秒数。有时候数据过多也是一种负担。

最后三个`echo`命令用于输出列头 ❹。大部分数据是硬编码的，但注意我用另一个百分号转义了百分号符号，以防解释器认为它是一个非常尴尬的变量名的开始（参见第十四章）。

标题和列头中的一些数据似乎没有对齐，但这只是由于变量解析和转义的结果。将所有内容对齐的最佳方法是使用固定宽度字体将标题、列头和一行示例数据输入到文本文件中，并按所需对齐所有内容——也就是，输入清单 22-2 中的报告示例。当对对齐结果满意后，将生成的标题复制到 bat 文件中，并在每个标题前加上重定向和 echo 命令。然后添加任何转义字符，并将任何临时文本（如示例日期和时间）替换为将要取代它们的变量。

在这最后一步中，允许数据发生偏移；所有内容将在最终输出中重新对齐。例如，日期和时间记录❸似乎被向右偏移，但那只是因为带有子字符串语法和包围百分号的变量名比最终显示的时间要长。同样，额外的百分号❹会使第一列头部记录中的其余数据出现偏差。Life 和 Avoidable 似乎没有与接下来的两行对齐，但当解释器将两个百分号合并为一个时，所有内容将再次对齐。

### 详细记录

这里有很多内容需要解释，但以下代码会为输入文件中的每一条记录写入一个格式化的详细记录，并跟踪记录数以及三个字段的累计总和：

```
❶ for /F "usebackq tokens=1-4 delims=|" %%a in ("C:\Batch\HealthStats.dat") do (
❷ set ctry=%%a                eol
❸ for /F "tokens=1-2 delims=." %%m in ("%%b") do (
      set dcml=%%n0
      set perGDP=      %%m.!dcml:~0,1!
   )
❹ for /F "tokens=1-2 delims=." %%m in ("%%c") do (
      set dcml=%%n0
      set lifeExp=              %%m.!dcml:~0,1!
   )
❺ set deaths=                %%d
❻ >> %rpt% echo !ctry:~0,15! !perGDP:~-5! !lifeExp:~-14! !deaths:~-15!
❼ set /A cnt += 1
   set /A totPerGDP += !perGDP:.=!
   set /A totLifeExp += !lifeExp:.=!
   set /A totDeaths += deaths
) 
```

在第十九章中介绍的 for /F 命令❶是提取管道分隔数据文件（delims=|）中每条记录的四个标记（tokens=1-4）的明显解决方案。这个逻辑将数据文件中的国家分配给 for 变量%%a，这意味着 GDP 百分比是%%b，预期寿命是%%c，避免死亡人数是%%d。

#### 使用对齐数据的方式对齐列

我正在填充 ctry 变量❷，它包含字符串数据，填充一些空格，并最终加上不会出现在报告中的文本 eol。为了让列对齐，我将使这个字段左对齐，并最终截取它的前 15 个字节，但为了让这个方法奏效，字段的长度必须至少是 15 个字节——因此，使用了空格填充。

结尾的 eol 标签仅仅是为了向读者展示该字段有尾随空格。在写入记录之前我会去掉它，因此任何文本都可以，但它代表了*行尾*。（如果你对报告特别自豪，可以通过输入你的名字来标记你的作品。）如果没有某种标记，未来的开发者可能会删除尾随空格，尤其是在他们更熟悉忽略尾随空格的编程语言时，而几乎所有语言都不包括 Batch 语言。

警告

*在第二章中，我提到过，你可以在后导空格后放置一个和符号（&）或命令分隔符，但由于一个令人沮丧的限制，这在代码块中不起作用，或者至少不像在其他地方那样工作。当你在代码块中使用和符号而没有后续命令时，解释器会停止工作，这意味着你可以用&rem 替代 eol。在更奇怪的情况下，如果进行了转义，和符号可以在没有第二个命令的代码块中工作，所以你也可以用^&替代 eol。*

将国家变量与对应于最后一列的变量进行对比，后者详细描述了每 10 万人中可避免的死亡人数。与其使用后导空格，我在死亡人数 ❺ 后添加了 15 个*前导*空格。这个值是整数，并且与我们应该按第一个字符对齐的字符串数据项不同，我们应该按可避免死亡人数的最后一个字符或个位数对齐。

为了右对齐一个数字，我做的是与处理字符串时相反的操作。我*在前面加上*一些空格，以便后来能从字段的末尾提取所需的文本。为了保持报告所需的空格数量，我将从这个字段提取 15 个字节，所以如果这个字段的长度不足 15 个字节，生成的数据将会偏斜。

#### 处理浮点数据

十进制或浮点值代表中间的两列，因为我们将以相同的方式处理它们，所以我只关注其中一列。输入文件中的数据表示预期寿命 ❹ 以十进制形式，所有值都包含十分位，除了加拿大，它恰好是一个整数，但我们希望报告中的每个值都有小数位，并且我们希望这些数字的小数点对齐。

我正在从外层`for`命令的第三个标记%%c ❶ 中解析预期寿命，并将其作为输入字符串传递给一个内层`for`命令 ❹。通过点号分隔后，值被分为小数点前的整数部分和小数点后的十进制部分。我将后者赋值给 dcml 或十进制变量，同时附加 0。批处理语法可以非常深奥，容易忽视，但在四个字节%%n0 中，前三个是内层`for`循环的第二个标记，最后一个是硬编码的数字。

在内层`for`命令的代码块中的第二个也是最后一个命令里，我提取了十进制的第一个字节：!dcml:~0,1!。对于大多数国家，我们将 0 附加到十进制值后面，然后立即将其去掉。这似乎毫无意义，直到考虑到加拿大。由于加拿大的预期寿命为 82 且没有十进制值，所以附加到末尾的 0 成为唯一的十进制字节。最后，我将整个数字%%m、一个点和十进制值的第一个数字拼接在一起。为了避免遗忘，所有这些都必须跟随一些前导空格以进行右对齐。如果我们想格式化带有两位小数的数字，比如美元金额，我们本可以附加两个零并提取前两个字节。

（在这个示例中，%%n0 代表一个变量后跟硬编码的 0，但只改变一个字节会产生完全不同的结果：%~n0。此时，n 变成了隐藏参数%~0 的修饰符。因此，%~n0 解析为 bat 文件的无扩展名的名称。哦，批处理的奇妙之处。）

每个国家 GDP 中用于医疗保健的百分比的逻辑❸几乎与预期寿命的逻辑相同。由于列的对齐方式，唯一的区别是我们为每个值附加的前导空格数量。

#### 编写详细记录

这四个变量最终会在实际将格式化文本字符串写入报告文件的那一行中合并❻。这是类似于我们在本章前面看到的回显命令重定向，通过解析这四个变量并通过子字符串提取每个部分，每个部分之间用空格分隔。

为了左对齐 ctry 变量，我使用了偏移量 0 和长度 15，从而提取前 15 个字节并丢弃其他所有内容（包括行尾标记）。接下来的三个值，perGDP、lifeExp 和 deaths，是右对齐的数字，因此我使用负偏移量来获取最后的 5、14 和 15 个字节。

各种长度依赖于布局。格式化详细记录并确定合适布局的最佳方法是输入我为头部记录建议的相同类型的示例行。找出每个对齐字段的长度，进行实验，并预期可能需要一些调整。只需小心确保如果你打算提取*n*字节，那么字符串中至少有*n*字节。更直白地说，国家字段是 15 个字节，因此确保添加 15 个空格以确保完美对齐。

#### 使用计数器和总和

代码块的最后四行❼都使用第六章中的增量赋值运算符进行一些算术运算。第一个是简单的计数器 cnt，用来追踪条目的数量。最后三个，totPerGDP、totLifeExp 和 totDeaths，是报告中三个量的累计总和。我为这些变量命名时使用了 tot，代表*总计*，并在常见的变量名之前加上了这一前缀。

逻辑是通过每条记录中的死亡人数来递增死亡总数的变量。其他两个是小数，如你在第六章中学到的，浮点数运算需要一些技巧。文本替换语法会在将每个值加到总数之前去掉小数点——例如，!perGDP:.=!。这实际上是将总数乘以 10，因此我们在计算平均值并写出尾部记录时需要解决这个不一致性。

我在这个报告中没有做，但是你可能想在一定数量的详细记录后插入分页符。通常，你可能希望在底部显示页码，然后是几行空白，之后再复制表头，接着显示另一页的详细记录。要在每 25 行详细记录后进行分页检查，可以在循环结束时检查 cnt %% 25。如果等于 0，表示记录数是 25 的倍数，那么你就可以插入分页符。你还可以创建另一个计数器用于页码，并将其作为页面尾部信息的一部分进行写入，同时将表头逻辑移到一个可调用的程序中，这样你就可以多次调用它。

### 结束记录

bat 文件的第三个也是最后一部分查找并格式化平均值，然后将其写入报告：

```
❶ set /A avePerGDP = (totPerGDP * 10 / cnt + 5) / 10
set /A aveLifeExp = (totLifeExp * 10 / cnt + 5) / 10
set /A avgDeaths = (totDeaths * 10 / cnt + 5) / 10
❷ set avePerGDP=     %avePerGDP%
set aveLifeExp=            %aveLifeExp%
set avgDeaths=              %avgDeaths%

❸ >> %rpt% echo -------          ----        ----------      -----------
>> %rpt% echo Averages      !avePerGDP:~-5,-1!.!avePerGDP:~-1!^
 !aveLifeExp:~-13,-1!.!aveLifeExp:~-1! !avgDeaths:~-15!
goto :eof 
```

为了计算平均值，我们可以简单地将总计除以详细记录的数量，但由于 Batch 会截断解决方案的小数部分，实际上所有的值都会被向下舍入。为了弥补这一点，每个 set /A 命令❶首先将值乘以 10 再除以 cnt。将 5 加到这个数值上可以修正舍入，使得除以 10 时可以得到正确的平均值。例如，77.4 的死亡人数应该向下舍入：77.4 + 0.5 = 77.9，在截断小数后变为 77。而 77.6 应该向上舍入：77.6 + 0.5 = 78.1，最终变为 78。因为我们不能直接加上小数 0.5，所以我们通过先乘以 10，加 5，再除以 10 来实现。

代码的下一个部分❷为每个平均值添加前导空格，为数据对齐的子字符串做准备。代码的最后一部分❸通过两个 echo 命令将尾部记录写入报告。第一个命令写入与表头记录相同的硬编码破折号。第二个命令将国家名称替换为硬编码的文本“Averages”，其余命令显示三个平均值，经过如此密集的子字符串处理，以至于我不得不在下一行继续命令。

我正在从 avgDeaths 变量中提取最后 15 个字节，但由于其他两个总计值实际上是其实际值的 10 倍，因此它们对应的平均值 avePerGDP 和 aveLifeExp 也增加了 10 倍。我们不能通过除以 10 来纠正这个问题，因为那样会丢失小数部分。然而，通过在写入数字时插入一个小数点，我们能够正确显示数字，实际上是通过除以 10 同时保留小数部分，这样两全其美。注意，!avePerGDP:~-5,-1!.!avePerGDP:~-1!解析为倒数第二个字节之前的四个字节，一个硬编码的小数点和最后一个字节。

其他数据集可能适合仅显示总计而非平均值，这意味着浮动点算术运算将减少或消失。即使在这个例子中使用了平均值，我们也能够创建一个相当令人印象深刻的报告，而不需要大量的代码。

### 总结

在本章中，我介绍了使用 Batch 格式化的典型文本报告的三个部分。如果你期待一个能轻松自动对齐列的巧妙程序，我敢肯定我让你失望了，但只要稍微注意细节，你就能创建出高质量的报告。你学会了如何构建标题、头部、任意数量的详细记录，以及包含总数和平均值的尾部记录。在此过程中，我展示了如何对齐列并处理数据项对齐的技巧，还分享了处理浮动小数点数据的建议。这并不是一个重型工具，我相信没有人仅仅靠制作 Batch 报告谋生，但当需要一个简单的文本报告时，编译程序就显得不必要了。

下一章将转变话题，深入探讨一个对我来说非常重要的主题：递归。你将学习如何编写调用自身的 Batch 代码，并探索一些有趣的应用。
