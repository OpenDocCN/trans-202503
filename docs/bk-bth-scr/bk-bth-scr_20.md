<hgroup>

## 18 目录、递归和迭代循环

</hgroup>

![](img/chapter.jpg)

许多批处理命令都有选项，但大多数提供的只是命令的稍微不同的变种或调整。for 命令的选项则是一个完全不同的故事。四个可用的选项以四种不同的方式影响 for 命令。在本章中，我将详细介绍其中的三个，第四个将在下一章中讲解，并且需要专门的一章来描述。

一个选项将命令的焦点从文件转向目录，另一个则使用递归遍历子目录以查找文件。你还将学到，如何将这两个选项结合使用来遍历一个目录树，查找子目录。

本章中的最后一个选项将 for 命令变成了一个我尚未讨论过的全新东西。它的功能与没有选项的 for 命令或带有其他选项的命令有很大的不同。它创建了一个迭代循环，在从一个数字到另一个数字的过程中，按照固定的增量或减量执行逻辑。这项工具对于任何程序员来说都是绝对必要的。

### 目录选项

不是所有选项字母都能准确描述它们的功能，但 /D 选项代表 *directory*（目录）。虽然没有选项的 for 命令会枚举文件名列表，但 /D 选项使得命令可以枚举目录或文件夹的列表。通用语法显示，除了插入该选项外，语法与没有选项的 for 命令完全相同：

```
for /D %%`variable` in (`input`) do `command`
```

在使用该选项之前，这里有一个类似于上一章的示例，一个没有选项的 for 命令，在路径后使用了一个唯一的通配符字符作为文件名：

```
for %%f in (C:\Budget\*) do (
   > con echo Filename is %%f
) 
```

结果输出包括文件夹中每个文件的路径和文件名，并写入控制台。

在下面的示例中，我对没有选项的 for 循环做了两个修改：一个是重要的，另一个是外观上的修改。重要的修改是将 /D 选项插入到 for 变量之前。注意，for 命令的其余部分保持完全不变。外观上的修改是我将 echo 命令中的“File”替换成了“Directory”：

```
for /D %%f in (C:\Budget\*) do (
   > con echo Directory Name is %%f
) 
```

对这段代码的另一个可能修改是将 %%f 替换为 %%d 来代表 *directory*（目录）（但我不打算使这个示例过于复杂）。

在没有 /D 选项的情况下，这个文件夹中的文件不再是输出的一部分。现在，解释器将立即将每个位于 *C:\Budget\* 下的目录写入控制台，可能是：

```
Directory Name is C:\Budget\BankStatements
Directory Name is C:\Budget\CreditCardStatements 
```

该输出假定这是唯一的两个子目录，但那些子目录的子目录并未出现在输出中。

### 递归选项

另一个有用的选项是`/R`，它方便地代表*递归*。这个选项使得`for`命令能够递归地在一个目录及其所有子目录（以及它们的子目录，依此类推）中搜索符合某个模式的文件。与没有选项的命令语法相比，它的通用语法与仅有选项的命令语法有所不同：

```
for /R [[`drive`:]`path`] %%`variable` in (`input`) do `command`
```

最显著的区别在于要搜索的路径现在出现在`for`变量之前。如果省略尾部斜杠，解释器不会受到影响，但最好加上斜杠，以明确表示它是一个路径。路径可以仅是驱动器字母后跟冒号，并且对于包含空格的路径，你需要用双引号括起来。在括号内，输入将是一个或多个没有路径的文件名，文件名之间用空格或逗号分隔。例如，以下命令会在*C:\Budget\*目录及其所有子目录中搜索 Word 文档，并将找到的文件写入控制台：

```
for /R C:\Budget\ %%w in (*.docx) do (
   > con echo Word Document Name is %%w
) 
```

以下`for`命令会找到你在意大利旅行中错放的照片，或者至少是任何扩展名为`*.jpg*`或`*.bmp*`的文件，且文件名以*Italy*开头。由于使用了`/R`选项，命令不仅会在根目录*C:\*文件夹中查找，还会在你整个*C:\*驱动器中查找：

```
for /R C:\ %%p in (Italy*.jpg, Italy*.bmp) do (
   > con echo Photo from the Italy Trip is %%p
) 
```

（多个文件模式在所有`for`命令中都可以使用，无论是否有选项。）

`for /R` 命令有其他几种变体。在一般语法中，围绕驱动器和路径的方括号意味着它们是可选的，如果省略，则假定当前目录。因此，前面的命令在功能上等同于以下命令，因为*C:\*是当前目录：

```
cd C:\
for /R %%p in (Italy*.jpg, Italy*.bmp) do (
   > con echo Photo from the Italy Trip is %%p
) 
```

在这两个例子中，`%%p`将解析为每个找到的照片的完整路径和文件名。

在一个微妙的警告中，所有传递给`for /R`命令的输入必须至少包含一个通配符字符。如果你在之前的命令中使用了显式的文件名（或没有星号或问号的任何文本）作为输入，它会返回*C:\*及其所有子目录，并附带你的文件名，即使文件在目录中不存在。要找到显式的文件名，你必须在文件名输入中添加一个通配符字符。我建议使用尾部星号，因为它通常最不容易意外捕获其他文件。

> 注意

*无论好坏，解释器自行处理递归，即进入每个子文件夹，隐藏它给你。在第二十三章中，我将重新讲解递归并解释如何定义实际的递归调用，从而开启更多可能性。*

### 目录递归

如果`/D`选项允许目录搜索，而`/R`选项允许递归文件搜索，你可能会认为它们可以一起用于递归目录搜索，确实如此。格式遵循`/R`命令的通用语法，`/D`在`/R`之前，并且括号中的输入仅为一个星号：

```
for /D /R C:\Budget\ %%d in (*) do (
   > con echo Directory is %%d
) 
```

运行此代码会显示 *C:\Budget\* 所有子目录及其所有子目录，依此类推。例如，假设存在两个特定的子目录和一个子子目录，输出会是：

```
Directory is C:\Budget\SubDir
Directory is C:\Budget\Taxes
Directory is C:\Budget\SubDir\SubSubDir 
```

在一个有趣的怪异情况下，单独使用 for /R 命令也可以执行相同的功能，而不需要 /D 选项，或者至少执行的是类似的功能。为了演示这一点，我对之前的 for 命令做了两个小调整。我去掉了 /D 选项，并将输入从星号改为点：

```
for /R C:\Budget\ %%d in (.) do (
   > con echo Directory is %%d
) 
```

这并不直观，但括号中的点会指示 for /R 命令列举目录而不是文件。（目录和点都以 D 开头，如果这有帮助的话。）这也会产生子目录的列表，但请注意三点不同：

```
Directory is C:\Budget\.
Directory is C:\Budget\SubDir\.
Directory is C:\Budget\SubDir\SubSubDir\.
Directory is C:\Budget\Taxes\. 
```

当你使用 /R 选项并将输入改为点时，第一个不同之处是解释器现在会列举根目录，在这个例子中是 *C:\Budget\*，以及所有子目录。第二，输出的每个目录后面会跟着一个反斜杠和一个点，第三，输出排序方式也不同，解释器会先处理一个目录的子目录，再处理其兄弟目录。请注意，当同时使用 /D 和 /R 选项，并且输入为星号时，解释器会先处理 *C:\Budget\Taxes\*，再处理 *C:\Budget\SubDir\SubSubDir\*，这与使用 /R 选项和点时的结果正好相反。

警告

*我所详细说明的关于点作为输入传递给* for /R *命令的内容，正是帮助文档所说的那样，但这并不完全正确。每行输出末尾的点只是输入的再现。这是前一节中提到的 batveat 的另一种表现形式。任何没有通配符的输入都会告诉命令逐步遍历所有子目录，并将每个子目录附加上该输入。点在上面的例子中很好地结束了每个目录，但如果你改为使用波浪号作为输入，输出中的目录都会以波浪号结尾，而不是点。*

输出中的差异很细微，根据你的应用程序的不同，这些差异可能并不重要，但无论如何，它们依然存在。

### 迭代循环选项

/L 选项将 for 命令转变为一个迭代循环，这是任何编码者工具箱中的必备项目，并且可能是最常用的命令变体。我至今讨论的循环都在遍历一系列文件、目录或某种文本。然而，这个选项将 for 命令变成一个通过某个数值或步长从一个数字递增或递减到另一个数字，并且有一个固定结束值的循环。大多数编程语言都会以某种方式实现迭代循环。事实上，许多语言也有一个专门用于此目的的 for 命令。批处理脚本的独特之处在于，for 命令做了这么多其他事情。

将命令转变为迭代循环的一般语法是：

```
for /L %%`variable` in (`start`, `step`, `end`) do `command`
```

除了添加 `/L` 选项外，这与没有选项的 `for` 命令之间唯一的区别是括号内的数据，在这里三个用逗号分隔的数字组成了输入。第一个是起始值或起始索引；第二个是步长，即每次循环迭代中索引递增的量；最后一个是结束值，即索引可以达到的最后一个值。

例如，这个 `/L` 循环从值 1 开始，每次迭代步进 2，直到 3 结束：

```
for /L %%i in (1, 2, 3) do  > con echo Index is %%i
```

这个命令在循环的第一次迭代中将 `for` 变量 %%i 设置为 1；然后，它以步长 2 递增，使得 %%i 第二次通过时变为 3。这与结束值匹配，因此循环不再执行。以下是输出到控制台的内容：

```
Index is 1
Index is 3 
```

以下 `for` 命令从变量设置为 10 开始，然后每次递增 1，直到达到 12：

```
for /L %%i in (10, 1, 12) do  > con echo Index is %%i
```

这会遍历索引 10、11 和 12。

要递减索引，请将步长赋值为负数：

```
for /L %%i in (2, -1, 0) do  > con echo Index is %%i
```

这会导致索引从 2 降到 0：

```
Index is 2
Index is 1
Index is 0 
```

所有三个数值输入都可以是负数：

```
for /L %%i in (-1, -3, -7) do  > con echo Index is %%i
```

这个 `for` 循环会对这三个索引执行：

```
Index is -1
Index is -4
Index is -7 
```

给定以下的起始值和步长，显然这个 `for` 命令生成了一个从 10 开始的递增的正数 10 的倍数序列：

```
for /L %%i in (10,10,35) do  > con echo Index is %%i
```

更不清楚的是序列到底在哪里结束。35 的结束值不是 10 的倍数，因此不在序列中，但一旦索引大于 35，循环就会结束，所以 30 是序列中的最后一个数字。如果结束值是 30、39 或任何介于它们之间的整数，命令在功能上是等效的，但为了清晰起见，30 会是最好的选择。此外，请注意，我在输入中省略了逗号后的空格。通常，我会为了可读性添加空格，但这个例子展示了它们并不是必需的（并且很容易被忽略）。

#### 幂函数例程

不幸的是，Batch 不支持幂函数。在第六章中，我提到我们可以为此任务编写一个简短的例程，这里是承诺中的例程，它使用了一个迭代循环。它接受三个参数：指数的基数、指数值以及包含结果的返回变量的名称：

```
:Pow
 set %3=1 
 for /L %%i in (1, 1, %2) do  set /A %3 *= %1
 goto :eof 
```

（如果返回参数让你困惑，可以回到第十一章。）

我将返回参数初始化为 1。然后，循环从 1 开始，每次递增 1，直到达到指数或第二个参数的值。因此，如果指数是 *n*，循环执行 *n* 次。循环内的命令将返回参数乘以指数的基数或第一个参数。因此，如果基数是 *b*，这个 `for` 循环将 *n* 个 *b* 相乘。当循环完成时，返回参数包含 *b**^n*，例程结束。

要找到 53，请调用例程并传递这三个参数：

```
call :Pow 5 3 pow
> con echo Five cubed = %pow% 
```

代码将 3 个 5 相乘，并将结果 Five cubed = 125 输出到控制台。

#### 案例研究

作为 18 世纪末的七岁数学神童，伟大的数学家卡尔·弗里德里希·高斯和全班其他同学一起，从老师那里接到了一项繁重的任务。学生们需要将 1 到 100 的所有数字加起来。过了一会儿，老师抬起头，看到所有的孩子都在忙着用粉笔和石板做加法，只有一个人没有。他走近年轻的高斯，准备严厉训斥，结果发现高斯的石板上写着正确答案 5050。

高斯意识到有 50 对数字加起来是 101（100 + 1，99 + 2，...，51 + 50）。他迅速将 50 乘以 101，写下答案，然后坐回去等待同学们完成，可能在想他们怎么还没做完。

这个故事有其他不同的版本，虽然它可能是传说，但如果那些其他的学生能够使用一台 Windows 电脑，他们也许能在年轻天才之前就完成任务——前提是他们能够快速键入以下内容：

```
set sum=0
for /L %%i in (1, 1, 100) do (
   set /A sum += %%i
)
> con echo The sum is %sum%. 
```

这个循环从 1 到 100 迭代%%i 索引，其中 set /A 命令会累加所有索引的值。在循环之前，set 命令明确地将 sum 初始化为 0，从而保证最终结果是所需的值。高斯的技术娴熟的同学们或许能在与高斯本人相当的时间内，把输出“总和是 5050”写到他们的石板上。

### 总结

在本章中，你学习了 for 命令的三个选项。/D 选项允许命令枚举目录而不是文件，/R 选项则使用递归来遍历子目录。我甚至演示了递归枚举目录的两种方法。

你还学习了如何使用/L 选项创建一个迭代循环，并掌握了它的所有方面。我使用了带此选项的 for 命令来创建一个将一个数字提升为另一个数字的例程，甚至还顺便讲了一下快速的数学历史课程以及一点批处理算术。

现在只剩下一个选项了，你将在下一章学习它。它允许读取文件以及更多操作。
