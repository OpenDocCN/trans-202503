

## 第二十七章：27 与/或 运算符



![](img/chapter.jpg)

在这一章中，我将讨论可能是 Batch 中最明显的缺陷。它不支持与运算符，也没有或运算符。简要介绍问题后，我将详细描述一些模拟或模仿这两个运算符的技巧，处理真值和假值的情况。与运算符相对简单，但或运算符则需要更多的创造力。

和 Batch 的情况一样，你可以对这个缺陷感到沮丧，也可以将其视为创造力的灵感。这些技巧是每个 Batch 程序员必备的，因为没有它们，你就无法编写出即使是稍微有趣的 if 命令。

### 问题陈述

有一个特定的对话，是每个学习 Batch 的人必经的洗礼：

*Bobby*：我有个语法问题。我正在尝试用与运算符编写 if 命令——你知道的，如果 variable1 等于 A 且 variable2 等于 B——这不复杂。我本以为语法就是简单的*and*这个词。结果不行，所以我尝试了一个和符号，再加上两个和符号。我知道 Batch 可能不太直观，所以一定有某种奇怪的与运算符语法，可能是一个带有波浪符号的@符号，或者类似的胡说八道。那么，我该怎么写？

*Jack*：抱歉，Batch 没有与运算符。

*Bobby*：认真的吗？这没有任何意义。

*Jack*：真的，没有。

*Bobby*：你是在逗我吧？每种有 if 命令的编程语言都有与运算符。我觉得这应该是有规定的。

*Jack*：不， 不是所有语言都有。我现在想不起来其他语言，但 Batch 在这一点上并没有随大流。

*Bobby*：这就像卖一辆不能左转的车。那该怎么办？

*Jack*：走三次右转。哦...顺便说一下，或运算符...也不是回事。

*Bobby*：我还是不确定你是不是在耍我。离愚人节还远着呢，我真的需要让这个东西工作。有什么建议吗？

*Jack*：我同意，Batch 应该有这些运算符，但这也是创造力派上用场的地方。任何人都可以在 Java 或 Perl 中编写与运算符，但在 Batch 中做到这一点，会让你有一种巨大的自豪感和成就感。至于或运算符，它更有趣——或者说，从你的角度看，可能更成问题。

我还记得在这段对话中扮演新手的角色，之后我在对立的角色中无数次体验过似曾相识的感觉。我担心有些人会觉得我夸大了这个问题，但它确实让很多人困惑。这个与运算符如果两个比较都为真时，**确实**不会返回真：

```
if "%var1%" equ "A" and "%var2%" equ "B" (
   > con echo This is junk code.
) 
```

这并不意味着代码块中的命令永远不会执行；实际上，解释器通常会在丢弃无效的 if 命令后执行它。更复杂的是，无效的命令可能会将错误信息输出到 stderr，也可能不会，错误级别(errorlevel)可能是非零值，也可能不是。

这个*无效*的或运算符也是如此：

```
if "%var1%" equ "A" or "%var2%" equ "B" (
   > con echo This is more junk code.
) 
```

如果其中一个或两个比较为真，它不会返回真。

但够了，先不谈那些不可行的方法。针对这些操作符，还有一些优雅或实用的解决方案。

### 复制`and`操作符

编写绕过缺少`and`操作符的第一个且最明显的技巧是使用嵌套的`if`命令：

```
if "%var1%" equ "A" (
    if "%var2%" equ "B" (
      > con echo Nesting works but is oh so uninspired.
)  ) 
```

如果条件语句中的任何一个使用了`exist`关键字来判断资源是否存在，或使用`defined`关键字来判断变量是否已定义，那么这是唯一可能的解决方案。但如果你要检查多个变量是否与常量或其他变量相等，我将分享一个更加优雅的解决方案。以下的`if`命令，将两个解析后的变量放在等号操作符的一侧，两个值放在另一侧，其功能上与前面示例中的嵌套命令是等效的：

```
if "%var1%-%var2%" equ "A-B" (
   > con echo This if command has an AND operator even if the AND is implied.
) 
```

等式的左侧，%var1%-%var2%，包含了三个部分：第一个变量的解析结果、一个破折号以及第二个变量的解析结果。如果两个变量分别设置为 A 和 B，那么"%var1%-%var2%"会解析为"A-B"，并且相等。如果任一变量（或两者）设置为其他任何值，则条件判断为假。

破折号分隔符有两个重要的作用。如果没有分隔符，当其中一个变量解析为 AB 而另一个变量解析为空时，我们会错误地认为它们相等。而且，使用分隔符使得代码更易读，特别是当比较变得更复杂时。例如，以下两个`if`命令——每个包含三个比较——非常相似，但你更愿意阅读哪一个？

```
if /i "%writer%%coworker%%admin%" equ "jackbobbysteve" (
   > con echo These variables and values are smushed together.
)

if /i "%writer%-%coworker%-%admin%" equ "jack-bobby-steve" (
   > con echo We can all agree this is far more readable.
) 
```

我使用了破折号作为分隔符，但几乎任何简洁的字符都可以使用。点（`.`）也是一个不错的选择，但最重要的是，你选择的分隔符应该是一个你不希望出现在数据中的字符。（虽然我不太愿意触及这个话题，但条件语句`"%A%-%B%" equ "%X%-%Y%"`在 A 和 Y 被设置为破折号且 B 和 X 为空的情况下会错误地判断为真。虽然从理论上讲这是一个问题，但如果你了解你的数据并明智地选择分隔符，在实际应用中这不会成为问题。）

还要注意，前面列表中的两个比较是不区分大小写的。你可以通过添加`/i`选项对任何多重比较进行类似的操作，但它是全局生效的——也就是说，它会应用到示例中的所有三个比较。如果你需要进行大小写敏感与不敏感混合的比较，嵌套结构是你最好的选择。

在大多数其他语言中，上述逻辑需要两个`and`操作符。而在 Batch 中，你可能会通过三个嵌套的`if`命令来实现，但将操作数通过破折号连接的技巧，比即便是使用真实的`and`操作符要简洁且易读。

### 复制`or`操作符

`or`操作符的复杂性与`and`操作符的简单性截然不同。我将展示最适合不同情况的技巧。

#### 将一个变量与多个值进行比较

或运算符的一个常见应用是确定一个变量的内容是否等于两个或更多值中的一个。例如，你可以从一个州的邮政编码中获得很多信息。如果它等于 WA、OR 或 CA，那么该州位于美国本土的太平洋海岸；而任何一个包含在 10 个值中的邮政编码则表示该州位于密西西比河上。

为了构建一个或运算符来查找分配给单个变量的多个值中的一个，我将再次使用非常有用的 for 命令：

```
for %%p in (ND SD) do (
   if "%postalCode%" equ "%%p" (
      > con echo This is an OR operator of a variable and multiple values.
)  ) 
```

echo 命令只有在变量表示一个达科他州的邮政编码时才会执行。

for 命令会执行其代码块两次，分别传递 ND 和 SD 作为 %%p 变量。代码块仅包含一个 if 命令，它将 postalCode 的内容与作为 for 变量传递的内容进行比较。因此，if 命令的第一次执行会检查变量是否解析为 ND，第二次执行会将 postalCode 的值与 SD 进行比较。如果变量等于 ND 或 SD，if 命令会评估为 true，从而触发其代码块的执行。从本质上讲，这就是一个 Batch 或运算符。

上一个例子是针对两个可能的值，但由于 for 命令接收一个由空格分隔的列表，你可以传递任意数量的值。以下是一个 Batch 或运算符匹配六个名称中的任何一个的例子：

```
for %%p in (Cleese Gilliam Jones Chapman Idle Palin) do (
   if /i "%name%" equ "%%p" (
      > con echo %name% is a Python
)  ) 
```

一个单一的变量，如 postalCode 或 name，不能同时具有两个当前值，这意味着使用这种技术时，if 命令中的条件子句最多只能评估为一次 true。这对其他变种的或运算符并不适用，因此其他考虑因素和修改会发挥作用。

#### 将多个变量与一个值进行比较

让我们反转上面的例子，将多个变量与一个硬编码的值进行比较。假设某个特定的程序有两个函数，如果其中一个变量设置为某个共同值，我们希望执行该函数。

在这个例子中，for 命令使用两个变量的解析值作为输入，并将它们传递给 if 命令，然后将它们与 A 进行比较：

```
 for %%i in (%var1% %var2%) do (
    if "A" equ "%%i" (
       > con echo This OR operator compares a value to multiple variables.
       goto :OrDone
)  )
:OrDone 
```

在这种情况下，两个变量都有可能等于 A。如果两个变量都为 true，正确的或运算符将不会在 if 命令的代码块中执行两次代码。为了模拟这种行为，我们必须在第一个 true 条件满足并执行代码块后跳出逻辑，这可以通过 goto 命令将控制转到 for 循环之后的标签来实现。

很多时候，执行代码块多次是完全可以接受的。例如，如果你在条件为真的时候设置一些变量，重新设置它们为相同的值也不会有什么问题，在这种情况下，你可以通过移除 goto 和标签来简化代码。不过，即便如此，这段代码在所有情况下也并非万无一失。

上一个示例中的技术假设变量不包含任何嵌入的空格。由于 for 命令接受一个以空格分隔的列表，解释器将把一个包含空格的单一值当作两个不同的值来处理。下面的清单考虑到了这一限制：

```
 for %%i in ("%var1%" "%var2%") do (
    if "A" equ "%%~i" (
       > con echo This OR operator compares a value to multiple variables.
       goto :OrDone
 )  )
:OrDone 
```

我已经把每个解决的输入变量用双引号括起来，确保我们将每个变量整体传递到代码块中。为了处理我刚刚添加的部分，我还在 for 变量的解析中加上了波浪线，以便在比较时去掉这些双引号：%%~i。

仅仅是这些变量中的一个内容中有双引号就可能会破坏这段代码。了解你的数据。

#### 比较多个变量和值

之前的示例展示了常见但相对狭窄的情况。它们不适用于包含或运算符的更复杂条件子句，这些子句需要比较多个变量与不同的硬编码值，或是比较不同的变量之间的关系。

作为一个具体的例子，某个期望的条件子句可能会在一个变量等于特定值或第二个变量等于第三个变量时返回 true。也就是说，我们可能会尝试执行如下操作，但同样，这在批处理（Batch）中*不*会生效：

```
if "%var1%" equ "A" or "%var2%" equ "%var3%" (
   > con echo This is one last example of junk code.
) 
```

有两种方法可以模仿这种或运算符的变体：

**"else if" 解决方案**

通过一些蛮力，你可以先评估第一个条件，然后使用 第四章中的 else if 结构来评估后续条件：

```
if "%var1%" equ "A" (
   > con echo This executes for only one of multiple conditions.
) else if "%var2%" equ "%var3%" (
   > con echo This really needs to be the same code as what's above.
) 
```

这段代码可以工作，但有一个我在代码中已经暗示的重大缺点。如果 if 命令中的条件子句为真，你必须重复执行要执行的代码块。如果这段代码只有一条语句，那也许还可以接受，但如果逻辑更加复杂，甚至是两三行代码，代码就会变得非常混乱。在这种情况下，最好将那段代码块放到一个带标签的方法中，并从多个位置调用它：

```
if "%var1%" equ "A" (
   call :CommonLogic
) else if "%var2%" equ "%var3%" (
   call :CommonLogic
) 
```

:CommonLogic 例程可能包含一些复杂的逻辑并位于 bat 文件的其他地方，但如果它仅仅是少量的命令，我建议将它直接放置在 else if 结构之后，放入一个始终为假的 if 命令中。（有关这种技术的更多信息，请参见 第二十章。提示：if 0 equ 1。）然而，如果代码块真的不值得拥有自己的方法（或者即使它值得），还有另一种值得探索的技术。

**嵌套的 **for** 命令解决方案**

实现或操作符的最后一种技巧并不简单，但它很优雅，我已经多次使用过。它模拟了两个项目的多次比较，只要有一个匹配就满足条件，但这两个项目可以是任何组合的已解析变量和硬编码值。它甚至可以处理任何值中的嵌入空格。

在这个解决方案中，我将 if 命令包裹在两个嵌套的 for 命令中：

```
 for %%i in ("%var1%:A" "%var2%:%var3%") do (
    for /F "tokens=1-2 delims=:" %%j in ("%%~i") do (
       if "%%j" equ "%%k" (
          > con echo A complex OR conditional clause has evaluated to true^^!
          goto :IfOrDone
 )  )  )
:IfOrDone 
```

外部 for 命令的输入是一个以空格分隔的由冒号分隔的值对集合，其中每一对值都被双引号括起来。这意味着外部代码块的每次执行都会将由冒号分隔的一对值解析为%%~i。值对可以是已解析变量和硬编码值的组合，比如第一个值对：%var1%:A。相比之下，第二个值对展示了另一种可能性，即两个已解析的变量：%var2%:%var3%。

内部 for /F 命令依次接受每一对由 %%~i 解析的值，并将其视为字符串输入，因为它们被双引号括起来。（请注意，“%%~i”会去掉双引号再加回。虽然我本可以使用%%i，但显式的双引号使得输入给 for /F 命令的是一个字符串这一点更加明确。）

tokens 和 delims 子句通过冒号分隔符将值对分割成 %%j 和 %%k 令牌（第十九章）。最后，if 命令比较它们是否相等，如果为真，则执行代码块。

我正在使用之前采用的相同技术来跳出逻辑，以免它多次执行。再次说明，如果没有问题让代码块执行多次，你可以省略 goto 命令和标签。如果比较的值中可能包含冒号，你可以选择不同的分隔符。同样，如果某个值中可能包含双引号，你可以去掉输入列表中每对值周围的双引号，但这样会暴露数据中的空格和特殊字符。

当你掌握了它的工作原理后，再用全新的视角重新审视并问自己，这看起来像是一个带有或操作符的 if 命令吗？有些人可能会觉得它很晦涩，明确来说，确实需要一个解释性备注，但我在这里展示的代表了你可能遇到的最全面、复杂的 Batch 或操作符。

### else 关键字

还有一个与任何 if 命令相关的最后一个重要话题我们不能忘记：else 关键字。我已经讨论过当多个条件都为真或至少一个条件为真时执行一个代码块，但通常你会希望在最终的与或或条件为假时执行另一个代码块。传统上，这就是紧随 else 关键字之后的代码块。

使用多个已解析变量和硬编码值串联在一起的模拟与操作符，适合使用 else 代码块：

```
if "%var1%-%var2%" equ "A-B" (
   > con echo Both are true.
) else (
   > con echo One of these variables doesn't match the value, or both don't.
) 
```

这也适用于 else if 结构，可以模拟“或”运算符。但你只能在其他情况中模拟 else 关键字，我将在这里分享两种非常有用的方法：

**抢占性行动法**

执行 else 逻辑的最简单方法是先抢占性地执行它：

```
set result=NoMatchFound
for %%p in (ND SD) do (
   if "%postalCode%" equ "%%p" (
      set result=Match
)  ) 
```

显然，只有在找到匹配项后，能够轻松撤销抢占性逻辑时，这才有效。如果 else 逻辑是复制或删除文件，这个技巧就没什么价值，但如果逻辑仅仅是将变量设置为两个值之一，你可以先执行 else 逻辑，如果 if 命令返回 true，则撤销它。本质上，这就是 if...else 结构。

**分支跳过法**

另一种方法是利用标签前的那一小段空间，在第一次匹配时跳出代码块：

```
 for %%p in (ND SD) do (
    if "%postalCode%" equ "%%p" (
       set result=Match
       goto :OrDone
 )  )
 set result=NoMatchFound
:OrDone 
```

goto 命令已经确保它上方的逻辑只会执行一次，但现在它也会在 for 命令完成后跳过紧接其后的逻辑。如果该逻辑找到一个匹配项，它会将变量设置为 Match，但如果 if 命令在输入列表耗尽后没有找到匹配项，控制流才会转到 set 命令，将变量设置为 NoMatchFound。

这种方法提供了更大的灵活性。你可以在找到匹配项时调用一个程序，如果没有找到，则删除一个目录。代码并不做任何抢占性操作，因此不需要撤销任何东西。因此，分支跳过法是更接近 if...else 结构的真正形式。由于 else 逻辑位于最后，它看起来更像传统结构。看到足够多的这种写法后，你会开始把那两个闭括号视为一种 else 关键字。

### 总结

在本章中，我详细介绍了几种模拟条件语句中的“和”运算符的方法，你也学习了多种模拟“或”运算符的技巧，以满足多种不同的情况。我还演示了模拟 else 关键字的方法，用于执行传统上在条件语句为假时执行的逻辑。

确实如此，本章讨论的技巧在大多数编程语言中完全不必要，但对于任何想编写复杂逻辑的 Batch 编码者来说，它们是必需的。它们也尽可能优雅地填补了 Batch 世界中最显著的空白。

Bobby 不应因尝试使用&&作为“和”运算符而受到责备；如果他尝试使用||作为“或”运算符，也不应受到责备。在其他编程语言中，&&和||常被用于这些目的。我还没有提到过，但&&和||运算符确实在 Batch 中有其用武之地，只不过与完全不同的话题——条件执行相关。在第四章中，我详细介绍了最常用的条件执行技巧（if 命令），而在下一章中，我会回到这个话题，分享一些鲜为人知的替代技巧。
