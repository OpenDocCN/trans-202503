<hgroup>

## 30 杂项内容

</hgroup>

![](img/chapter.jpg)

在本书中，我努力编写简短、简洁的章节，针对具体话题进行讨论，同时在过程中介绍一些相关的命令。在本章中，我将讨论一些无法归类到其他章节的有趣话题，这些话题太短，无法单独成章，但它们的重要性和实用性丝毫不逊色于其他内容。

在这些杂项内容中，你将学习如何排序文件并查询注册表中的有用信息。你还将学习如何检索和设置文件和目录的属性，我还将讨论位操作，以完善本书对批处理运算的覆盖。

### 排序文件

排序命令完全符合你的预期；它将输入文件排序为输出文件。为了演示，假设有一个小文件，其中包含未来八位星际舰队*企业号*船长的名字，按他们担任船长的顺序列出。前 15 个字节包含一个名字，后面跟着一个字节作为中间名首字母（如果有的话，只有一位船长使用了中间名）。姓氏从字节 17 开始，后面可能跟着一些空格：

```
Jonathan        Archer
Robert          April
Christopher     Pike
James          TKirk
Willard         Decker
John            Harriman
Rachel          Garrett
Jean-Luc        Picard 
```

(*星际迷航*以其平行宇宙和时间线著称，但这是*我们*宇宙中的船长名单，且有一项重要遗漏。斯波克，或者说斯波克先生，未列入名单有两个原因。首先，最主要的是他只有一个名字，这个名字既不是名字也不是姓氏，而有时被当作名字或姓氏，这使得数据文件的格式变得复杂。其次，他作为船长的时间在*星际迷航 II：可汗的愤怒*的开头只有大约三分钟。尽管我非常注重每个批处理事实的准确性，但我也力求忠于*星际迷航*的正史。)

以下命令将文件作为第一个参数接受，/O 选项紧接着并定义了其后的*输出*文件：

```
sort C:\Batch\Captains.txt /O C:\Batch\SortedByName.txt
```

该命令可以非常轻松地将小型输入文件排序到大小相同的输出文件中。以下是执行前述命令后，*SortedByName.txt* 文件的完整内容：

```
Christopher    Pike
James        TKirk
Jean-Luc        Picard
John            Harriman
Jonathan        Archer
Rachel          Garrett
Robert          April
Willard         Decker 
```

这些船长按名字排序，因为排序命令默认从记录的第一个字节开始排序。如果有两个船长的名字相同，他们将按中间名首字母排序，最后按姓氏排序，但我们可以通过 /+ 选项轻松改变排序的起始字符。以下命令从字节 17 开始排序，这是姓氏的起始位置：

```
sort C:\Batch\Captains.txt /O C:\Batch\SortedByLastName.txt /+17
```

*SortedByLastName.txt* 文件按姓氏排序，正如其名称所示：

```
Robert          April
Jonathan        Archer
Willard         Decker
Rachel          Garrett
John            Harriman
James          TKirk
Jean-Luc        Picard
Christopher     Pike 
```

该命令还有一些其他有用的选项，用于自定义排序。/R 选项会*反转*排序顺序，因此如果你在上一个命令中添加了 /R，Pike 会排在第一，April 会排在最后。/UNIQ 选项仅输出*唯一*的行，换句话说，它会删除重复的记录。如果输入文件中的某些记录可能超过默认的最大长度 4,096 字节，可以使用 /REC 来定义不同的最大*记录*长度，最大为 65,535 字节。

> 注意

*我必须声明我对任何由单个字母 O 表示的选项、参数或设置的反感；用户总是会因错误而输入零。在我年轻时的编码失误之后，我避免使用这种以及其他含糊不清的字符（如 I 和 l），但不幸的是，sort 命令就是这样。*

在处理大文件时，sort 命令的性能远不如商业工具，而且不能定义多个排序字段，但该命令提供了一个简便的方法，可以对小型到中型文件进行简单排序。

商用的排序工具比 sort 命令要快得多，并且提供更多的功能。通过一点努力，你可以设置一个批处理文件，根据工具是否在机器上注册来执行不同的命令。例如，如果存在商业排序工具（如 Syncsort），批处理文件可以执行它；如果不存在，则会执行较慢但仍然有效的 sort 命令。通过这种方式，你可以在已注册工具的机器上受益于更快的排序工具，但这个计划的主要挑战在于确定工具是否已安装并注册在特定的机器上。方便的是，这直接引出了我们的下一个话题。

### Windows 注册表

Windows 注册表是一个层次结构的数据库，存储操作系统和所有已安装应用程序的配置设置和选项。它的结构类似于 Windows 本身，看起来像是一个文件夹结构，但每个看似文件夹的地方实际上是一个注册表键，位于根键或树干下的一个或多个级别。

如果某个应用程序已安装在特定的计算机上，你可以在注册表中找到有关该应用程序的信息。其他机器是否存在该信息，就能判断该应用程序是否安装在该计算机上，我们可以通过几行批处理代码来确定这一点。

例如，如果 Syncsort 已安装在 Windows 计算机上，它在注册表中有一个注册表键，最终我们将通过一些批处理代码查询与该应用程序相关的注册表键。如果找到该键，则说明 Syncsort 已安装；如果未找到，则说明未安装。但在使用这一逻辑之前，我们需要知道与该应用程序相关的注册表键。找到该键的最佳方法是查找已安装该软件（在此示例中为 Syncsort）计算机的注册表。

#### 探索注册表

regedit 命令，代表 *注册表编辑器*，提供了一个类似于 Windows 资源管理器的入口，允许你浏览注册表。在命令提示符下，输入以下命令并按回车键：

```
**regedit**
```

注册表编辑器应该会打开。

警告

*再想一想，稍等一下。当我第一次使用这个编辑器时，感觉就像是闯进了一座老宅子里的一个秘密房间，通过一个陷阱门进入，但这里确实有做出一些破坏的潜力。无需因此而感到害怕，但除非你对注册表有深刻的理解，否则不要在注册表编辑器中删除或修改任何内容。谨慎是必须的，但即使许多数据是晦涩难懂的，调查注册表也能带来启示。*

计算机上加载的所有软件都位于 *HKEY_LOCAL_MACHINE\SOFTWARE* 下，因此这是查找应用程序的第一个地方。如果 *SOFTWARE* 键下的许多键中没有一个显然是该产品的，你还可以右键点击 *HKEY_LOCAL_MACHINE* 根键或根 hive，选择 **查找**，输入应用程序名称或其他搜索字符串，然后按回车键。第一个匹配该字符串的键将出现，按 F3 可以跳转到下一个匹配的键。

为了演示，我们假设找到了下列应用程序的注册表键：

```
HKEY_LOCAL_MACHINE\SOFTWARE\Syncsort
```

regedit 命令是本书中为数不多的几乎专门在命令提示符下使用的命令之一，在 bat 文件中几乎没有用处。如果你在 bat 文件中使用它，它将仅仅打开注册表编辑器，并暂停 bat 文件的执行，直到用户关闭编辑器。但是，通过这个命令和一点努力，我们现在已经得到了注册表键。接下来我们需要一些 Batch 代码，用来判断这个键是否存在于其他计算机的注册表中。

#### 查询注册表

解决此挑战的方法是 reg 命令，reg 简单代表 *注册表*。从 bat 文件中，reg 命令本身就可以在注册表中做出相当大的修改。如果你查看此命令的帮助信息，你会发现它拥有多个操作，可以操作注册表，包括添加、删除、复制和导入，某些心怀不轨的人可能会轻易利用这些操作来构建 bat 病毒。了解这些命令的存在非常重要，但只有在你完全理解注册表及其可能影响的情况下，才应使用它们。我将严格聚焦于从注册表中读取或查询操作，也就是说，执行 reg 命令的查询操作。

最基本的 reg query 命令接受一个可能的注册表键作为参数。方便的是，Batch 允许我们将 HKEY_LOCAL_MACHINE 根键缩写为 HKLM。此命令正在注册表中查找 Syncsort：

```
reg query "HKLM\SOFTWARE\Syncsort"
```

此命令返回参数的注册表键值和其他直接从属的注册表键的列表。对于我们的目的来说更重要的是，如果此命令在注册表中找到该参数键，它将设置 errorlevel 为 0；如果找不到，则返回值为 1。考虑到这一点，请看使用相同命令的代码，并通过条件执行设置布尔值：

```
reg query "HKLM\SOFTWARE\Syncsort" && (
   set bSyncsort=true==true
) || (
   set bSyncsort=false==x
) 
```

执行此操作后，您可以在流程的其他地方引用该布尔值，以确定特定的应用程序是否已安装并可用。

我们还可以查询注册表中的其他类型信息。例如，以下命令使用 /V 选项查找当前 Windows 版本的特定注册表键 *值*，ProductName：

```
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /V ProductName
```

如果没有 /V 选项，命令可能会将许多键值和从属键写入标准输出，但如果使用此选项，它将仅在找到键值时写入两行输出。一个例子可能是：

```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion
    ProductName    REG_SZ    Windows 10 Home 
```

参数中的注册表键是输出的第一行，关于 ProductName 的所需信息包含在第二行。

以下的 for /F 命令能够很好地解析出 Windows 版本并将其分配给一个变量：

```
set key=HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion
for /F "usebackq tokens=1,2*" %%i in (`reg query "%key%" /V ProductName`) do (
   if /i "%%i" equ "ProductName" (
      set winVersion=%%k
)  ) 
```

由于 for /F 命令处理两行文本，而我们只关心第二行，因此 if 命令将仅提取包含 ProductName 的那一行作为第一个令牌。（我们也可以通过 第十九章 中的 skip=1 子句忽略第一行。）

由于 tokens 子句中的星号，第三个令牌 %%k 包含从未使用和丢弃的第二个令牌之后的所有内容，包括嵌入的空格。因此，winVersion 的值变为 Windows 10 Home。如果在另一台机器上运行此代码，它可能将 Windows 7 Enterprise 分配给该变量。

关于注册表，可以写下更多的内容。我在这里仅从 Batch 的角度简单介绍了一下，展示了如何安全地查询一些非常有用的信息。reg 命令的帮助文档为好奇者提供了更多的信息。

### 文件属性

就像你可以用 reg 命令做坏事一样，你也可以用另一个有趣的命令，attrib 命令，做同样的事情。它的名字是 *attribute*（属性）的缩写，既能检索也能分配文件和目录属性。坏人可以利用此命令在计算机上创建和隐藏恶意文件，以实现各种恶意目的，尽管这种行为违反了批处理编码者的誓言，誓言只将其力量用于正当用途。

#### 检索属性

如果命令的唯一参数是文件，它将返回文件的属性。请考虑以下内容：

```
attrib C:\Batch\SomeFile.txt
```

如果文件从左到右处于准备归档（A，字节 1）、系统文件（S，字节 4）、隐藏（H，字节 5）和只读（R，字节 6）状态，则此命令将以下结果写入标准输出：

```
A  SHR                C:\Batch\SomeFile.txt
```

第二和第三字节始终为空。

字符串中的每个位置代表一个预定义的属性。例如，第五个字节中 H 的值表示文件是隐藏的，或者至少在 Windows 资源管理器中默认情况下无法看到它。相反，那个位置上的空格意味着文件不是隐藏的。

要确定特定文件是否为只读，以下 for /F 命令使用 attrib 命令作为输入：

```
for /F "usebackq tokens=*" %%a in (`attrib C:\Batch\SomeFile.txt`) do (
   set attrs=%%a
   if "!attrs:~5,1!" equ "R" (
      set bReadOnly=true==true
   ) else (
      set bReadOnly=false==x
)  ) 
```

代码块中的逻辑根据与第六个字节相关联的文件属性的存在与否，将 bReadOnly 布尔值设置为 true 或 false。

带有通配符的文件掩码可以返回多个文件的结果。/S 选项在目录及其所有子目录中的所有文件上匹配文件名或掩码，并返回每个文件的结果。此外，/D 选项处理目录属性，而不是文件的属性。

#### 设置属性

该命令的真正强大之处在于它能够重置属性。在属性字符前加上负号会关闭该属性，加上正号则会开启该属性。例如，以下命令确保文件不是系统文件（-S）且不是隐藏文件（-H），同时是只读的（+R）：

```
attrib -S -H +R C:\Batch\SomeFile.txt
```

这非常有用。如果你创建了一个批处理程序，用于创建或修改一个用户可能会访问的文件，并且这些用户不应信任该文件，你可以使用 attrib 命令在不使用文件时保护并隐藏它。为了让文件可访问，在更新文件之前运行带有-H -R 参数的命令，更新后再运行另一个带有+H +R 参数的命令，从而将文件保持隐藏并只读，直到代码再次需要它。这相当于数字化的“解锁工具棚，取出并使用割草机，用完后再放回，并重新上锁，直到草又长起来”。

有趣的是，当文件是系统文件或隐藏文件时，attrib 命令无法设置属性——除了系统和隐藏文件属性本身。因此，如果文件是隐藏的，并且你仅在参数字符串中使用+R，attrib 命令将无法将文件设置为只读。然而，之前的命令（-S -H +R 参数字符串）确保这些文件属性没有被设置，从而使得可以使用最后的属性。如果需要，你可以执行第二个 attrib 命令来重置系统和/或隐藏属性：+S +H。你可以通过 help 命令查看你可以设置和取消设置的完整属性列表。

为了演示最终用途，del 命令（第七章）非常擅长删除特定文件，但不能删除所有文件*除了*特定文件。假设你的工作目录没有任何隐藏文件，这三行代码会删除除了那个文件之外的所有内容：

```
attrib +H C:\Work\Noah.txt
del C:\Work\* /Q /A-H
attrib -H C:\Work\Noah.txt 
```

第一个 attrib 命令将*Noah.txt*文件改为隐藏；接着 del 命令通过/A-H 选项删除目录中所有未隐藏的文件。最后，第二个 attrib 命令将文件恢复到原先的状态，没有任何损伤，也没有删除目录中的其他文件。

一旦掌握了操作文件属性的技巧，你就可以开始操作位了。

### 位操作

在第六章中，我承诺会回到 Batch 支持的最后几个算术操作符：三个按位操作符和两个逻辑位移操作符。这些操作符作用于位级别，因此你需要在理解它们的行为时转向二进制世界。*半字节*，即一个字节的一半，包含四个位，每个位代表一个递减的二次方。将位的值设置为 1 表示打开该位，将其值设置为 0 则表示关闭该位。

当你开启四个位中最左边的第一个位时，它表示十进制 8——第二个位是 4，第三个位是 2，最后一个位是 1。因此，二进制 0001 等于十进制 1，而二进制 1000 等于十进制 8。

你可以通过开启一组位来得到其他数字。二进制 1111 等于十进制 15——即 8 + 4 + 2 + 1。由两个半字节组成的完整字节有 256 个独特的值，但在本讨论中，我将坚持使用更加易于管理的半字节及其 16 个独特值来做大多数即将出现的例子。

#### 按位操作

*按位与* 操作接受两个操作数，并返回在每个位位置上，如果两个操作数的对应位都设置为 1，则该位置为 1。在这个例子中，考虑十进制数字 3 和 6。十进制数字 3 等于二进制 0011，打开了 2 和 1 的位，十进制数字 6 等于二进制 0110，打开了 4 和 2 的位。唯一共同的设置为 1 的位是第三位，其值为 2，所以 3 和 6 的按位与操作结果是二进制 0010 或十进制 2。

*按位或* 运算符会查找在*任一*操作数中被设置为 1 的位。在 3 和 6 之间有三个这样的位，结果是二进制 0111 或十进制 7。*按位异或* 会开启两个操作数中*不同*的位。使用相同的数字，只有第二位和第四位不同，所以结果是二进制 0101 或十进制 5（即 4 + 1）。

这种操作在表格形式中更容易理解。表格 30-1 还介绍了每个按位算术操作的 Batch 操作符。

表格 30-1：按位算术和操作符

|  | 操作符 | 示例 |
| --- | --- | --- |
| 按位与 | & | 3 & 6 = 0011 & 0110 = 0010 = 2 |
| 按位或 | &#124; | 3 &#124; 6 = 0011 &#124; 0110 = 0111 = 7 |
| 按位异或 | ^ | 3 ^ 6 = 0011 ^ 0110 = 0101 = 5 |

在掌握按位逻辑运算的工作原理后，你可能会对操作符的选择感到疑惑。一个与号（&）通常用于终止命令，插入符号（^）是一个转义字符，而按位或操作符（|）通常用于将数据从一个命令传输到另一个命令（更别提条件执行了）。难道你不能在算术运算中使用这些字符吗？

你是可以的，但你需要采取一些措施，确保这些字符不会触发它们的其他用途。实际上有三种不同的方法，我在这三个功能等价的按位和算术运算示例中展示了它们：

```
set /A bitAnd = "3 & 6"
set /A "bitAnd = 3 & 6"
set /A bitAnd = 3 ^& 6 
```

我的偏好是将算术运算用双引号括起来，就像第一个示例所示。你也可以用双引号将变量名、等号操作符和算术运算括起来，正如第二个示例所示。最后，你可以用插入符号（caret）转义操作符。

以下展示了使用我偏好的方法进行的三种按位运算：

```
set /A bitAnd = "3 & 6"
set /A bitOr = "3 | 6"
set /A bitXOr = "3 ^ 6" 
```

执行这些命令后，bitAnd、bitOr 和 bitXOr 分别包含值 2、7 和 5，这与之前计算的结果相同。

这里我通常会详细说明刚才讨论的内容的多种用途，但我不能说我每天都在操作位。实际上，我从未在批处理脚本中使用过任何按位运算符。在早期的计算机编程中，程序员通常会在位级上连接一组标志，生成一个压缩的字段。然后，他们可以通过位操作来设置和获取表示单独标志的位。

便宜且丰富的内存让这种技术成为过去的记忆，但我仍然可以分享一个用例。以下代码判断一个数字是否是 2 的幂次方：

```
set /A bitAnd = "nbr & (nbr - 1)"
if %bitAnd% equ 0  > con echo %nbr% is a power of 2. 
```

只有当 nbr 等于 0、1、2、4、8、16 等时，echo 命令才会输出消息。

任何一个 2 的幂次方的数字都有且只有一位是开启的，而比它小 1 的数字则将这位关闭，同时右边的所有位都变为开启。例如，十进制 8 = 二进制 1000，而 7 = 0111。对这两个操作数进行按位与运算的结果为 0，因为它们没有共同开启的位。如果数字不是 2 的幂次方，至少有一个对应的位在它和小于它的数字中都被开启。例如，6 = 0110，而 5 = 0101；第二位在两个数字中都被开启，因此按位与运算的结果非零：4 = 0100。

#### 逻辑移位运算

批处理还提供了两种操作位的工具。*逻辑左移*运算符将第一个操作数中的所有位向左移，移位的位数由第二个操作数决定，并且右边的位用零替代。*逻辑右移*运算符类似，但它将位向右移，将左侧空缺的位用零填充，同时丢弃右侧相同数量的位。

这里是逻辑移位运算符，并附有示例：

|  | 运算符 | 示例 |
| --- | --- | --- |
| 逻辑左移 | << | 3 << 2 = 0011 → 1100 = 12 |
| 逻辑右移 | >> | 9 >> 1 = 1001 → 0100 = 4 |

逻辑移位插入到结果中的位用粗体显示。第一个命令在将位向左移两位后附加了两个零。第二个命令在将位向右移一位后前置一个零，同时在过程中去掉了最右边的 1。

以下两个命令在 Batch 中实现了这两个示例：

```
set /A logicLeftShift = "3 << 2"
set /A logicRightShift = "9 >> 1" 
```

（为了处理小于号和大于号，我们需要转义字符或前文提到的两种双引号技巧之一。）

我同样感到困惑，试图找到逻辑移位的应用，因为我在实际工作中从未使用过这些运算符。然而，由于 Batch 不支持指数运算，我们可以使用逻辑左移将一个数字提升到某个幂次……前提是这个基数是二。可以把它看作一个非常狭义的幂函数。考虑这些计算 2³ 和 2⁹ 的示例：

```
set /A TwoCubed = "1 << 3"
set /A TwoToTheNinth = "1 << 9"
> con set Two 
```

每个字节中的每一位（以及字节本身）都代表 2 的幂，因此，第一个命令将 0001 向左移 3 位，得到 1000，即十进制数 8，正好是 2 的三次方。后续的 set 命令将以下内容写入控制台：

```
TwoCubed=8
TwoToTheNinth=512 
```

第二个命令在计算中使用了多个字节。注意，二进制的 1 后跟 9 个零等于 512，即 2 的 9 次方。

如果你在实际应用中使用过这些运算符，给我留言，我会考虑将你的应用案例添加到本书的下一个版本中。

### 总结

在这一章中，我讨论了一些话题，尽管它们太简短，无法单独成章，但我还是觉得必须分享。你学习了如何排序中小型数据文件，以及如何定制排序。我简要介绍了 Windows 注册表，并展示了如何使用几个有趣的命令进行查询。你还学会了如何设置和获取文件属性，以及如何使用位运算符和逻辑移位运算符操作位。

下一章可能是本书中最重要的一章，最终也会是被引用最多的一章。故障排除技巧和测试技术在任何编程语言中都很重要，特别是在没有编译器的脚本语言中——而且没有动画器或调试器。
