<hgroup>

## 11 参数和参数传递

</hgroup>

![](img/chapter.jpg)

在前一章中，我演示了如何通过 bat 文件调用内部例程和其他 bat 文件，但我没有讨论如何在调用逻辑和被调用逻辑之间传递数据。默认情况下，所有在调用代码中设置的变量都对被调用代码可见，反之亦然。如果代码紧密耦合，从技术上讲，不需要传递参数和接受参数，但要使其生效，两个代码集必须达成一致并使用相同的变量集。

如果您只是创建一个第二个 bat 文件来拆分一个大型项目，并且被调用的 bat 文件永远不会从其他地方调用，那么这样做是可以接受的。但为了创建更通用的代码，使得其他过程和程序员可以重复使用，参数化传递给 bat 文件和例程的数据是至关重要的。

在本章中，我将详细介绍您需要了解的所有关于参数和参数传递的知识，包括 Batch 独有的晦涩语法。您将学习如何将参数传递给 bat 文件或例程，以及如何接受返回的参数。您甚至会了解隐藏参数、如何以及为什么要调整参数，以及如何通过几次鼠标点击将参数传递给 bat 文件。

### 传递参数

为了演示如何传递参数和接受参数，我将编写一个简短的 bat 文件，构建一个简单的 Mad Libs 示例，这是一个在便携式电子设备普及之前，让孩子们在长时间车程中保持耐心的游戏。这个 bat 文件接受三个顺序参数（一个形容词，一个动词和一个名词），并将它们插入以下文本中，然后显示结果给用户：

蝙蝠是 _______（形容词）哺乳动物。它们在洞穴中 _______（动词）飞来飞去，但如果你站在它们下方，你可能会被 _______（名词）砸中。

我还不打算与您分享这个调用的 bat 文件，因为我首先会集中讲解如何在传递这三个参数时调用*MadLibs.bat*。毕竟，调用的 bat 文件并不关心香肠是如何做出来的；它只需要一个绞肉机。调用的 bat 文件只需要知道要传递的参数和预期的结果，仅此而已。（在下一部分，我将从被调用的 bat 文件 *MadLibs.bat* 的角度来分析这个问题。）

在第十章中，我演示了如何使用 call 命令调用另一个 bat 文件。接下来的命令正是如此操作的，不过现在，bat 文件名后面跟着三个参数，分别是形容词、动词和名词，按照这个顺序，且每个参数之间用空格分隔：

```
call C:\Batch\MadLibs.bat adorable fly guano
```

显然有人在作弊，因为写入控制台的结果对这个游戏来说太合理了：

```
Bats are adorable mammals. They fly around in caves,
but if you stand under them, you might get hit with guano. 
```

更典型的情况是，如果一个 11 岁的男孩玩这个游戏，他可能会想到以下一组代表形容词、动词和名词的词：

```
call C:\Batch\MadLibs.bat stinky fart poop
```

结果是

```
Bats are stinky mammals. They fart around in caves,
but if you stand under them, you might get hit with poop. 
```

这种方式不知为何仍然有效——至少对于一个青少年男孩来说是这样。

#### 参数分隔符

在前面的示例中，传递的参数通过空格彼此分隔，并且与被调用的批处理文件名分开。空格无疑是最常见的分隔符，逗号是第二常用的分隔符，但分号、等号和制表符也可以作为分隔符。考虑以下两个调用命令：

```
call C:\Batch\MadLibs.bat adorable fly guano
call C:\Batch\MadLibs.bat,adorable;fly=guano 
```

两个命令在功能上是等效的，但第二个命令看起来像是故意混淆其意图的练习。

逗号分隔的数据是相当常见的（例如*.csv*文件的内容）。因为逗号是批处理参数分隔符的一部分，你可以将逗号分隔的数据存储在一个变量中，然后将该变量作为命令的一部分传递，像这样：

```
set myArgs=adorable,fly,guano 
call C:\Batch\MadLibs.bat %myArgs% 
```

解释器将每一段由逗号分隔的文本视为一个独立的参数（假设数据中没有其他分隔符）。这看起来可能像是一个参数，但实际上命令传递了三个参数。

#### 参数封装

查看允许的参数分隔符列表会引发一个有趣的问题：是否可以将空格和其他分隔符作为实际的参数数据传递？是的，这完全可能，但首先要考虑以下这些（三个？）参数所带来的问题：

```
call C:\Batch\MadLibs.bat ad hominem took off ice cream
```

显然有人在故意制造麻烦，使用三个参数的双词版本。（而任何把“ad hominem”作为《疯狂填字游戏》形容词使用的人，其实比制造麻烦还更为做作。他可能是办公室里那个纠正每个人使用“参数”和“论点”错误的人。）结果是，解释器需要处理六个参数，而不是三个。

由于空格是分隔参数的字符之一，解释器将“ad”视为形容词参数，而动词参数是“hominem”，名词参数是“took”。这导致了一个毫无意义的词组，即便是按照《疯狂填字游戏》的标准来看也显得荒谬。命令的其余部分“off ice cream”变成了一个接收最多三个参数的批处理文件的第四、第五和第六个参数；它们被适当忽略，不会造成进一步的影响。

解决这个问题的方法是将每个参数用双引号括起来，这样做还有一个额外的好处，就是可读性大大提高：

```
call C:\Batch\MadLibs.bat "ad hominem" "took off" "ice cream"
```

被调用的批处理文件需要处理可能被双引号包裹的参数，稍后我会详细讲解。

通过这些设置，输出至少在语法上是有意义的，大致正确：

```
Bats are ad hominem mammals. They took off around in caves,
but if you stand under them, you might get hit with ice cream. 
```

包裹的双引号提供了另一个巨大优势；它们能够占据任何缺失参数或设置为空格的参数的位置。例如，作为一种反向思维，某人可能拒绝提供第一个参数。（毕竟，省略形容词仍然能保持语法正确，但省略名词或动词必定会破坏句子结构。）如果没有双引号，在以下示例中，第二个参数会偏移成为第一个，第三个则变成第二个。相反，即使第一个参数为空，依然传递了三个参数：

```
call C:\Batch\MadLibs.bat "" "hop" "fudge"
```

hop 和 fudge 参数正确映射到 verb 和 noun，而没有 adjective，因此输出如下：

```
Bats are  mammals. They hop around in caves,
but if you stand under them, you might get hit with fudge. 
```

双引号的包围还允许你将逗号、分号、等号甚至制表符作为参数或参数的一部分使用。

#### 参数变量

到目前为止，我只展示了硬编码的参数，但实际上，参数通常是变量。如果你不能百分百确定没有（并且永远不会有）嵌入的空格，建议你在解析后的变量周围加上双引号：

```
call C:\Batch\MadLibs.bat "%arg0%" "%arg1%" "%arg2%"
```

当调用命令执行时，三个参数变量会被解析并传递给被调用的 bat 文件，每个参数都被双引号包围。

> 注意

*“参数与论据”的争论：关于这两个术语之间的区别有一些争议。我见过不同的定义，但我在写作时使用的是这样一个区分：* 论据 *是从* 调用 *代码传递的，* 参数 *是被* 被调用 *代码接受的。但也有灰色地带，程序员常常谈论“传递参数”和“接收论据”。我们都知道什么意思。我不想成为那个在办公室里纠正每个人的刻板讨厌家伙，但我会尽量保持这些词的一致使用。*

### 接受参数

让我们通过 180 度转变视角，来看一下示例 11-1，在这个示例中，被调用的 bat 文件接受三个参数，这意味着最终共享 *MadLibs.bat* 文件，该文件在前面的示例中生成了多轮输出。

```
set adjective=%~1
set verb=%~2
set noun=%~3

> con echo.
> con echo Bats are %adjective% mammals. They %verb% around in caves, 
> con echo but if you stand under them, you might get hit with %noun%.
goto :eof 
```

示例 11-1：MadLibs.bat 文件接受三个参数并显示一个 Mad Lib。

任何接受参数的 bat 文件应该以两种方式之一开始。它应该包含说明 bat 文件接受哪些参数的注释，或者它应该在文件顶部使用 set 命令定义这些参数，并使用明确命名的变量。对于这个 bat 文件，我选择了后一种方式。

第一个参数被描述性地命名为 adjective，而 %~1 是解析传递给 bat 文件的第一个参数的最佳语法。递增该整数可以得到第二个参数的值 %~2，并将其赋值给 verb。最后，另一个明确命名的变量 noun 被赋值为第三个参数 %~3。

#### 解析带波浪号的参数

下一个要点既重要又微妙；如果你从 bat 文件的第一行中去掉波浪号，%1 会解析为接收到的第一个参数，无论是否有双引号。然而，%~1 会解析为去掉双引号的第一个参数——如果没有双引号需要去掉，解析后的参数保持不变，因此波浪号不会带来任何问题。其他参数也一样：%~2 解析为去掉双引号的第二个参数，%2 则解析为传递的原始参数。

波浪号的使用正是我在前一节中提到的内容，指的是被调用的批处理文件需要做些什么，以便处理可能被或可能不被双引号括起来的参数。*MadLibs.bat*文件显然使用了波浪号的语法，使它能够同时兼容两种情况，从而给调用批处理文件的开发者提供了便利。

我*唯一*不会使用波浪号来解析参数的情况是当我明确希望保留双引号时，而这种情况极为罕见。使用波浪号可以让调用的批处理文件灵活地选择是否使用双引号。请考虑以下这两个功能上等价的命令：

```
call C:\Batch\MadLibs.bat ugly running "cell phone"
call C:\Batch\MadLibs.bat "ugly" "running" "cell phone" 
```

调用的批处理文件必须使用双引号来处理任何包含空格的参数，例如上面提到的第三个参数；否则，双引号不是必需的，但使用它们不会有害。我提到这两个命令在功能上是等价的，但如果*MadLibs.bat*没有在前面三个命令中使用波浪号，那就不成立了。

如果你觉得解析参数的语法看起来很奇怪，那你并不孤单。变量通常通过两个百分号来解析，但在这里，单个百分号后面跟着一个一位数（或波浪号和数字），别无他物。以数字开头的变量不能通过百分号解析，因此当解释器看到百分号后跟着一个数字（可能中间有一个波浪号）时，就会认为这是一个参数。一旦理解了，它确实提供了一个非常简洁的语法来解析参数。

#### 解析整个参数列表

你可以通过在参数列表前加上百分号和星号，轻松解析整个参数列表，无论值的数量如何，这在被调用的批处理文件需要调用另一个批处理文件或例程并传递相同的参数列表时非常方便。考虑以下命令，特别是末尾的%*字符：

```
call C:\Batch\SecondCalledBat.bat "%arg0%" %*
```

该命令传递了一个由简单变量组成的参数列表，后面跟着传递到批处理文件或例程的参数列表。我已将第一个参数，即 arg0 变量，用双引号括起来，以防它包含任何嵌入的分隔符字符，如空格；这确保了解释器将该变量视为单一参数，而不是多个参数。其余的参数是传递到被调用的批处理文件的完整参数集，无论数量如何。最终，传递到批处理文件的第一个参数是调用中的第二个参数，以此类推。（剧透：当我们在第三十二章讲解面向对象设计时，我们将广泛使用这项技术。）

### 内部例程参数

到目前为止，我只讨论了与调用另一个 bat 文件相关的参数。幸运的是，在调用 bat 文件内部的例程时，实际上并没有什么不同。我们可以轻松地将列表 11-1 中的完整 bat 文件重写为一个内部例程。请注意，在列表 11-2 中，唯一的区别是添加了标签。

```
:MadLibs
 set adjective=%~1
 set verb=%~2
 set noun=%~3

 > con echo.
 > con echo Bats are %adjective% mammals. They %verb% around in caves, 
 > con echo but if you stand under them, you might get hit with %noun%.
 goto :eof 
```

列表 11-2：`:MadLibs` 例程接受三个参数并显示一个 Mad Lib。

调用例程的 call 命令具有相同的参数，并且双引号的处理方式也相同：

```
call :MadLibs "ad hominem" "took off" "ice cream"
```

唯一的区别是调用了一个标签，而不是另一个 bat 文件。其他一切都完全一样。

### 隐藏参数

许多现代语言将传入的参数列表视为一个数组，特别是一个零偏移的数组。再加上批处理文件意外地使用零偏移来进行子字符串提取，许多程序员曾经尝试在 %~0 中寻找一个参数（包括我自己）。结果可能让人困惑，正如在列表 11-2 中展示的，添加以下 echo 命令来说明这一点：

```
:MadLibs
 > con echo Parm 0 is %~0
 set adjective=%~1 
```

写入控制台的文本包含正在执行的例程的名称：

```
Parm 0 is :MadLibs
```

在我解释到底发生了什么之前，章节前面提到过，Mad Libs 的逻辑在一个外部文件中，并像这样被调用：

```
call C:\Batch\MadLibs.bat "adorable" "fly" "guano"
```

将之前添加到 :MadLibs 例程中的相同 echo 命令，添加到列表 11-1 中的被调用 bat 文件中，结果如下：

```
Parm 0 is C:\Batch\MadLibs.bat
```

我不太愿意称 %0 为第一个参数。它更像是一个隐藏参数，位于第一个参数之前。从这个例子来看，很明显隐藏的参数是正在执行的例程或 bat 文件的名称，但它来自哪里呢？

一个 bat 文件通常是 call 命令的第一个参数，并且这个参数会作为 %0 传递给被调用的 bat 文件本身。事实上，%0 匹配的是 call 命令中路径和文件名（或标签名）的大小写，而不是实际路径和文件名的大小写。如果路径不是参数的一部分，那么它就不是 %0 的一部分。此外，如果 call 命令中路径和文件名被双引号括起来，那么 %0 也会被双引号括起来。因此，通常最好像处理其他参数一样使用波浪符号来解析它，即 %~0。

隐藏的参数在所有 bat 文件中都无处不在，不仅仅是被调用的 bat 文件或例程。即使是一个高层次的 bat 文件，那个你可能通过双击打开的文件，其路径和文件名也包含在隐藏的参数中。我们通常不会考虑打开 bat 文件时发生了什么，但这并不是魔法。Windows 执行一个 call 命令，并将 bat 文件作为唯一参数传递给你。结果是 %0 被解析为 bat 文件的路径和名称，并被双引号括起来。

这个隐藏参数有很多用途。对于错误处理，它提供了一种简单的方式来记录错误发生的例程。如果 bat 文件被移动到不同的目录、计算机或域中，隐藏参数可以帮助 bat 文件知道它的位置。当我们介绍到 for 命令时，有一种相对简单的方法可以从一个包含路径和文件名的变量中仅获取路径。然后，你可以以多种方式使用它。例如，你可以将输出文件放入 bat 文件所在目录下的子文件夹，或者 bat 文件可以根据它所处的位置执行不同的操作。它是 Batch 中一个非常有用且隐藏的特性。

### 移动参数

如果第一个参数通过%~1 解析，第九个参数通过%~9 解析，那么第 10 个参数通过%~10 解析似乎是合理的。但实际上不行，解释器只识别参数 0 到 9，或者单个数字的序数。要是编译器能够温和地提醒你%~10 不是有效参数那该多好，但同样的，这就是 Batch。为了演示在解析这个参数时可能出现的问题，可以参考示例 11-3 中的一个双数字参数列表。例程传递给它的是字母表的前一半，目的是将五个选定的字母写入控制台。

```
 call :Alphabet A B C D E F G H I J K L M
 goto :eof

:Alphabet
 > con echo Parm 1 is "%~1"
 > con echo Parm 2 is "%~2"
 > con echo Parm 9 is "%~9"
 > con echo Parm 10 is "%~10"
 > con echo Parm 13 is "%~13"
 goto :eof 
```

示例 11-3：第一次尝试编写例程:Alphabet，以显示五个参数

前三个看起来没问题，但第 10 和第 13 个参数似乎是无效的：

```
Parm 1 is "A"
Parm 2 is "B"
Parm 9 is "I"
Parm 10 is "A0"
Parm 13 is "A3" 
```

当我们人类看到%~13 时，我们看到的是数字 13，可能会期待第 13 个参数 M 被解析出来。但解释器从来没有被误认为是人工智能，更不可能是人类智慧。当它遇到%~13 时，它看到的是第一个参数%~1，解析为 A，后面跟着硬编码的值 3，结果是 A3。类似地，%~10 会解析为第一个参数，但会附加一个零，结果是 A0。

然而，Batch 并不限于只有九个参数。事实上，我曾见过传递了几十个参数，因为没有实际的限制（除了任何命令中最大字符数为 8,191 的限制）。要访问第 10 个及以后的参数，你需要使用 shift 命令。为了演示，让我们修正示例 11-3 中的:Alphabet 例程：

```
:Alphabet
 > con echo Parm 1 is "%~1"
 > con echo Parm 2 is "%~2"
 > con echo Parm 9 is "%~9"
 shift
 > con echo Parm 10 is "%~9"
 shift & shift & shift
 > con echo Parm 13 is "%~9"
 goto :eof 
```

在 shift 命令执行之前，第 1、2 和 9 号参数的解析结果没有变化，shift 命令会将每个参数向左移动一个位置。第二个参数变成第一个，第三个变成第二个，第 10 个参数变成第九个。虽然这可能直觉上让人不太明白，但在 shift 命令之后，%~9 会解析为第 10 个参数。再经过三次 shift 命令，%~9 会解析为 M，第 13 个参数，从而产生期望的输出：

```
Parm 1 is "A"
Parm 2 is "B"
Parm 9 is "I"
Parm 10 is "J"
Parm 13 is "M" 
```

在第二章中介绍命令分隔符(&)时，我提到过应该谨慎使用它。在其他情况下，它可能会弄乱代码，但 shift 是一个非常简单和简洁的命令，将三个命令写在一行实际上可以清理代码。

请注意，shift 命令不会影响%*的解析。这种奇怪的语法无论执行了多少个 shift 命令，仍然会解析为完整且原始的参数列表。

移动参数引发了一个有趣的问题。在执行 shift 命令后，使用%0 解析的路径和文件名会发生什么？简短的回答是，它会被清除并替换为第一个参数，至少在默认情况下是这样。但是 shift 命令有一个独立的选项，这个选项定义了在 shift 时哪个参数会被丢弃；所有在该参数之前的参数都会被保留。它的格式与我们之前描述的选项有所不同。/n 选项丢弃第*n*个参数，因此以下命令丢弃第一个参数并保留%0：

```
shift /1
```

参数 0，或者说隐藏参数，保持不变。参数 1 被丢弃，而参数 2 向前滑动成为参数 1，第三个参数变成第二个，以此类推。通过一个小改动，以下命令保留了前四个参数（以及隐藏参数），同时丢弃了第五个参数：

```
shift /5
```

参数 6 被移动到参数 5，其他参数也相应地移动。

这个选项接受参数 0 到 8——尽管没有必要使用/0，因为这是默认行为。由于某些未知原因，/9 是无效的。别问。

### 返回参数

你现在知道如何将参数传递给例程和其他批处理文件，并将接收到的参数写入控制台，但在真实的编码世界中，许多例程接受一些参数并将其他参数传回调用者。由于在被调用进程中的批处理变量是全局可用的，一些程序员干脆在例程中设置一个硬编码的变量名，并在其他地方使用它。真是些**庸俗**的人！一种更优雅、灵活的解决方案是允许调用者定义返回变量的名称。

> 注意

*我使用*庸俗*一词作为贬义词，但并非没有犹豫。今天，这个词是指对美学和艺术无感的粗暴个体，而我正是以此含义使用它。但是，如果他们有现代代表性，我们不会诋毁整个民族。甚至连“吉普赛蛾”也正在被重新命名，正确地说是为了不冒犯某一群体，尽管这只蛾仍然可以被肆意诽谤。我相信当时有好有坏的庸俗人，但由于他们在两千五百多年前被完全消灭，并且在三大世界宗教的经文中被视为不祥之物，他们的名字被轻蔑地使用，而几乎没有任何悔意。近几十年来，甚至我们的远亲——尼安德特人，形象的恢复比庸俗人更加正面。*

以下示例包含三个参数；前两个是要相加的数字，第三个是加法的结果。这个例程可能很短，但由于其复杂性，确实需要注释：

```
rem - Parm 3 is the sum of Parms 1 and 2
 :Add
  set /A %~3 = %~1 + %~2
  goto :eof 
```

在 set /A 命令的等号右侧，前两个参数被解析并相加。等号左侧——即被设置的部分——是神秘的文本%~3。这里本应是一个变量名，但实际上解析的是第三个参数。set /A 命令实际上是将一个命名变量设置为两个数字的和。最重要的是，这个变量名就是传入此例程的第三个参数。这种技术不难理解，但却不直观，并且在其他语言中并不常见。我见过很多程序员被这个弄得一头雾水。

一个对该例程的调用示例可以澄清发生了什么。以下调用命令传递了两个数字和一个变量名，其中双引号是可选的：

```
call :Add "7" "8" "sum"
```

在此调用之后，sum 变量的值为 15。我不能过分强调的是，在这种技术中，调用代码定义了要返回的变量名。为了进一步说明这一点，本例中的三个调用都是对同一个:Add 例程的调用：

```
call :Add "5" "8" "sum1"
call :Add "9" "11" "sum2"
call :Add "%sum1%" "%sum2%" "sum4Nbrs"
> con echo The sum of all four numbers is %sum4Nbrs%. 
```

前两个调用使用了硬编码的数字，分别返回 sum1 和 sum2 变量。这两个变量都被解析并作为参数传递到第三个调用中，返回 sum4Nbrs。

请注意，在前两个调用中，sum1 和 sum2 没有带有分隔符的百分号，因为变量名被传递。但是在第三个调用中，我正在解析它们，因为它们的值被传递了——这些值是在前两个调用中赋值的。最后，echo 命令将这些内容写入控制台：

```
The sum of all four numbers is 33.
```

一个调用中的输出使用的同一个变量，在另一个调用中作为输入，但这个变量是否可以在单个调用中同时用于这两种用途呢？

### 一个变量作为输入和输出

一个单独的变量可以同时作为例程或批处理文件的输入和输出。为了设置这个，想象一个求整数平方的例程。第一个参数是输入，第二个参数是输出——简单来说，就是输入乘以它本身：

```
:Square
 set /A %~2 = %~1 * %~1
 goto :eof 
```

该例程没有展示我们尚未讨论的内容，尽管%~1 的输入被使用了两次。调用代码定义了输出变量，并在例程中将其解析为%~2。

调用代码可以使用两个不同的变量来作为输入和输出。但是假设你想用一个变量的平方来替换它的值。为了实现这一点，你可以将它的值作为第一个参数传递——请注意，值两侧有百分号——并将变量名作为第二个参数传递，而不加百分号：

```
call :Square %nbr% nbr
```

如果在调用之前，nbr 被设置为 5，那么调用之后它会被设置为 25。:Square 例程提供了一些真正的灵活性，可以与两个不同的变量或相同的变量一起使用。

让我们再对这段代码做一次小改动，写一个只有一个参数的例程，该参数既是输入也是输出。该参数是一个包含数字值的变量，例程将该值替换为其平方，这使得调用例程变得更加简便：

```
 call :SquareMe nbr
 > con echo The squared number is %nbr%.
 goto :eof

:SquareMe
 set /A %~1 = !%~1! * !%~1!
 goto :eof 
```

首先，注意到新例程（或标签）的名称。更重要的是，注意到该例程接受一个单一的参数，即整数的未解析变量名——而不是整数值。

将:SquareMe 与:Square 例程进行比较，set /A 命令有两个关键更新。首先，不再将%~1 自乘，而是将!%~1!作为每个操作数。在之前的例子中，接受的是一个值，而现在输入的是一个变量名，因此%~1 解析为变量名，并且通过延迟扩展，感叹号将该名称解析为整数值。（我是否提到过延迟扩展的真正强大之处？它的应用仅受限于你的想象力。）

第二个变化是积被分配给第一个参数%~1，而不是第二个参数%~2。记住，在:SquareMe 中，唯一的参数现在是变量名。结果是，调用此例程会更改变量的值，即使该变量在例程中没有明确提到。

> 注意

*我已经通过例程演示了返回参数，但从被调用的 bat 文件返回参数的方式几乎是一样的。实际上，如果被调用的 bat 文件*没有*通过 setlocal 和 endlocal 命令限制作用域，那么它的工作方式完全相同。如果它限制了作用域，那么有一种特殊技巧可以让一个或多个变量在 endlocal 之后存活，我将在第十六章中详细说明。*

### 输入参数列表的长度变化

让我们构建一个更接近实际的例程，使用我们目前为止在本章中学到的内容。以下例程接受一系列一对多的数字（没有合理的限制），并返回两个变量，一个填充为输入数字的和，另一个填充为输入数字的积：

```
rem - Parm 1 = Sum of multiple numbers, returned parm
rem - Parm 2 = Product of multiple numbers, returned parm
rem - Parms 3+ = Set of numbers to add and multiply
 :Arithmetic
  set %~1=0
  set %~2=1
 :NextParm
  set /A %~1 += %~3
  set /A %~2 *= %~3
  shift /3
  if "%~3" neq ""  goto :NextParm
  goto :eof 
```

由于我们不知道在给定调用中会有多少输入参数，因此将这些参数放在参数列表的末尾，输出参数占据前两个位置。（没人说输入必须在输出之前。）由于其复杂性，:Arithmetic 例程包含了许多必要的注释，用于定义参数列表。

和，表示为%~1，因为它还没有实际的变量名，初始化为 0。同样，积，%~2，初始化为 1。（对于我的数学迷朋友们来说，这分别被称为加法和乘法的单位。）暂时忽略第二个标签:NextParm，集中注意力在接下来的两个 set /A 命令上。第一个命令将第一个参数，即和，设置为它本身加上列表中的第一个输入数字%~3，它是第三个参数。类似地，接下来的命令将第二个参数，即积，设置为它本身乘以列表中的第一个数字，同样是%~3。

接下来的 shift 命令非常关键。输入参数的数量是未知的，所以我们希望丢弃刚刚使用过的第三个参数，并将其后面的参数向左移动，而不干扰前两个参数，这两个参数在本例中也是返回参数。/3 选项能够无缝地实现这一点。接下来，我们查看新生成的第三个参数，看看它是否已被填充。请记住，这个参数在原始列表中是第二个输入数字，或者说在 shift 之前是第四个总体参数。如果它已经被填充，我们将返回之前忽略过的 :NextParm 标签。现在，这两个 set /A 命令分别将第二个输入参数加到和中，并乘到积中。

这个过程会一直重复，直到数字列表（无论其长度如何）用完为止，此时 if 命令的条件语句为假，控制权将转移到后续的 goto :eof 命令，例程将返回前两个参数。

以下代码测试了这个新例程：

```
call :Arithmetic sum product 5 8 9 11
> con echo The sum is %sum%.
> con echo The product is %product%. 
```

结果文本将写入控制台：

```
The sum is 33.
The product is 3960. 
```

顺便说一下，如果这个结构看起来很熟悉，那是因为它是来自第九章的 Batch do...while 命令的示例。至少假设有一个输入参数，并且只要存在更多的参数，例程就会执行算术运算，或者说是 *只要*。

### 拖放参数

通过几个鼠标点击，你可以将任何文件的路径和名称，或者多个文件，传递给 bat 文件。这是当我学习 Batch 时让我和其他许多人都感到惊讶的事情。只需右键单击任何文件并选择 **复制**；然后右键单击 bat 文件进行执行并选择 **粘贴**。bat 文件执行时，唯一的参数是复制文件的路径和文件名（如果路径或文件名包含空格，则会用双引号括起来）。另外，你还可以选择文件，拖动并将其放到 bat 文件上，结果是一样的。

这种技术适用于任何数量的文件。如果你将 *n* 个文件复制到 bat 文件上，*n* 个以空格分隔的参数将被传递——每个参数都是一个路径和文件名。如果你将 *n* 个文件拖放到 bat 文件上，情况也是一样，甚至适用于目录。

起初，将文件拖放到 bat 文件上可能看起来像是一个简单的 Batch 小把戏，但它的用途非常广泛。你可以设计一个包装的 bat 文件来处理单个文件。也许一个程序正在执行，并以一个文件作为输入；该程序可能会将文件转换为不同的格式或添加尾部记录。也许 Batch 代码只是简单地重命名文件或给现有的文件名添加扩展名。重要的是，bat 文件正在对输入文件执行某些操作。

一种可能的操作是简单地将输入文件复制到另一个目录。考虑以下两个命令，它们构成了 *BackUpOneFile.bat* 的全部内容：

```
xcopy %1 D:\Some\Deep\Hard\To\Reach\Folder\ /F /Y
pause 
```

xcopy 命令的第一个参数 %1 解析为 bat 文件的第一个参数，该参数将是任何拖放到 *BackUpOneFile.bat* 上的文件的路径和文件名。该命令将输入文件复制到目标路径，即 *D:\* 驱动器中的一个深层、难以触及的文件夹。（我故意保留了 %1 语法中的双引号，而不是 %~1，因为如果路径或文件名包含空格，xcopy 命令需要双引号。）最后，pause 命令仅仅是让窗口保持打开状态，以便用户查看复制结果。

最终，如果你将 *BackUpOneFile.bat* 放在 Windows 桌面上，你可以快速将任何一个文件拖放到它上面，bat 文件将把输入文件复制到所需的目录，而无需你导航到该目录。

为了在没有这种拖放技术的情况下将参数传递给 bat 文件，你必须输入一个调用命令（到另一个 bat 文件或命令提示符中），并将输入文件作为参数键入。但通过这种技术，任何用户，甚至是非程序员，都可以轻松地运行 bat 文件，而无需键盘输入。你可以为位于网络上任何位置的 bat 文件创建一个 Windows 快捷方式，从而隐藏源 Batch 代码，使用户更难意外删除或修改它。

当路径和文件名作为参数传递给 bat 文件时，Batch 提供了一种简便的方法来获取关于文件的各种信息，例如最后修改日期和时间、大小、属性、路径、扩展名、文件名等。我将在探索 第十七章 中的 for 命令后详细讨论这一点。for 命令还将解锁循环功能，这样如果我们将 *n* 个文件拖放到 bat 文件中，系统就可以依次处理每个文件。

### 总结

本章以及 第八章 到 第十章 希望能够让你对 Batch 的理解超越单一的无规律顺序执行的 bat 文件。在不久的过去，你的 bat 文件无法调用可执行文件或其他 bat 文件，解释器只会按顺序执行每个命令，直到遇到 bat 文件的结尾。但是现在，你有了开始构建有趣且复杂的 bat 文件的工具。

在本章中，你学习了如何将参数传递给 bat 文件和程序，并在调用的 bat 文件中接收它们作为参数。我详细介绍了如何分隔参数，甚至如何将分隔符本身作为参数传递。你还初步了解了隐藏参数——Batch 世界中的“雪人”。我展示了如何传递回调用者定义的变量，其中包含返回值。你甚至可能学会了如何玩疯狂填字游戏。

在下一章，我将通过介绍各种由解释器和你自己创建的输出，进一步拓展这一领域。我将向你展示如何捕获 Batch 命令的输出，以及如何创建自己的文件。
