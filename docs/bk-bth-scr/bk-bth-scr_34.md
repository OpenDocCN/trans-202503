

## 第三十一章：31 个故障排除技巧和测试技术



![](img/chapter.jpg)

当我最初开始与少数朋友和同事分享我正在写这本书的事实时，他们最想在书中看到的是关于测试和故障排除的一章，因为批处理带来了独特的开发挑战。

我经常提到没有批处理编译器，也许这不言而喻，但其实也没有动画器或调试器。逐步执行一些批处理命令，跳过其他命令，设置断点，检查或修改变量，这些都纯粹是幻想，或者说是一本很糟糕的小说（或者可能是我的下一个项目）。批处理代码的生命周期有两个步骤：编写和执行。就是这么简单；没有编译，也没有动画。但这并不意味着你不能测试批处理文件。实际上，这让测试变得更加重要。

在本章中，我将逐步介绍一些技巧，讨论我多年来在编码批处理应用程序过程中学到和开发的各种技术，无论是小型应用程序还是大型应用程序。

（如果这个押头韵的标题让你不太喜欢，那就感谢我将它从“令人垂涎的整洁故障排除技巧和永恒的测试技术”删减掉——这简直是 Ts 的海啸。）

### 捕获 stdout 和 stderr

毋庸置疑，测试和故障排除任何批处理文件的第一步是将 stdout 和 stderr 捕获到追踪文件中。虽然其他编程语言提供了动画功能，但批处理提供了次优选择——详细记录每个命令执行的结果。在某些有限的情况下，追踪信息甚至可能比动画更好。确实，你不能在批处理文件执行时逐步调试代码并操作变量，但你可以看到变量的值，并通过简单的向上滚动轻松返回。

然而，追踪信息可能让人感到望而生畏。如果一个循环执行了 1,000 次，所有 1,000 次执行都会出现在追踪文件中，可能会跨越成千上万行。因此，本章的大部分技巧将围绕如何解读追踪信息展开。追踪中的信息非常宝贵，如果你不记得如何捕获 stdout 和 stderr，请返回到第十二章，重新熟悉一下捕获过程再继续阅读。

现在你可以捕获追踪信息，能否读取这些信息至关重要。

### 如何导航追踪信息

始终在查看追踪信息时参考生成它的批处理文件。这是因为追踪文件的内容可能会让人迷失其中，原始的批处理代码就像是森林的地图。这个建议可能看起来很显而易见，但有时追踪信息可能与批处理代码差异很大。例如，在追踪信息中，你可能会看到像这样设置 myVar：

```
C:\Batch>set myVar=finalValue
```

但这并不能告诉你 `finalValue` 是硬编码的，还是通过其他方式设置的，比如从一个中间变量解析出来的。不过，原始的 bat 文件会告诉你：

```
set myVar=%intermediate%
```

此外，追踪信息可能变得非常长且密集，只有通过搜索才能找到所需的输出部分，但这样做可能比你想象的要复杂。考虑以下代码：

```
rem Execute the Database Purge Program
  %_pgmPurgeDB%
  if %errorlevel% neq 0 (
     set errorMsg=The Database Purge Program Failed
     goto :Abort
  ) 
```

生成的追踪信息可能如下所示：

```
C:\Batch>rem Execute the Database Purge Program 

C:\Batch>DatabasePurge.exe

C:\Batch>if 0 NEQ 0 (
set errorMsg=The Database Purge Program Failed 
 goto :Abort 
) 
```

解释器显示变量已解析，因此你无法通过从 bat 文件中搜索 `_pgmPurgeDB` 变量名来找到追踪信息中的这一部分。代码的多个部分通常看起来相似。例如，多个程序可能会执行，并且后面跟着类似的错误处理。

这个 Batch 代码中最容易识别的两个部分是注释和错误信息。我们可以利用这些硬编码的文本来解决问题。为了解决这个问题，确保每个程序前都有一个独特的注释，或者每个程序后在错误处理代码块中有一个独特的错误信息。现在，为了在追踪信息中找到这一段代码，只需从 bat 文件中复制注释或错误信息，并在追踪信息中进行搜索。这样，你也在记录代码——这简直是双赢的局面。

成功的执行过程通常相似且乏味，但失败往往独特且有趣。让我们再次执行相同的代码，但这次假设一个用户要求我们调查为什么数据库没有被清除，尽管 bat 文件看似成功执行了。线索就在追踪信息中：

```
C:\Batch>rem Execute the Database Purge Program 

C:\Batch>if 0 NEQ 0 (
set errorMsg=The Database Purge Program Failed 
 goto :Abort 
) 
```

首先是注释。然后，`errorlevel` 变量在 if 命令的条件语句中解析为 0，因此程序应该是成功执行了，对吧？不，这仅仅意味着最后设置该变量的过程将其设置为 0。最后设置该变量的过程是可执行文件吗？等一下……可执行文件在哪里？它没有在注释后出现在追踪信息中。这是一个线索。

这证明了在读取追踪信息时，逐行参考原始 Batch 代码是多么重要。逐行分析可以清楚地暴露缺失的内容，在这种情况下，就是程序调用。如果没有原始的 bat 文件，就很难发现有东西缺失。

回到我们特定的问题，其近因可能是程序的变量解析为 null 或一个或多个空格，但根本原因是什么？也许这个变量在代码中拼写错误；也许在早期定义它时有人拼错了它；也许它根本没有被定义过；也许是其他进程将其清空了。（但也许是有人在 `_pgmPurgeDB` 的内容前加了 `@`，从而抑制了可执行文件名在追踪信息中的显示，即使它确实执行了，或者也许是我想得太复杂了。）你可以确定的是，程序的执行没有出现在追踪信息中，稍微再深挖一点，你就能找到实际的根本原因。

记住，这是未编译的代码；使用未定义的变量是编译器会抓到的问题，但批处理程序员没有这个奢侈的待遇。

### 不要被幽灵跟踪所迷惑

我曾见过不止一个新手批处理程序员，盯着类似以下的跟踪记录部分，坚信程序失败了：

```
C:\Batch>if 0 NEQ 0 (
set errorMsg=The Database Purge Program Failed 
 goto :Abort 
) 
```

毕竟，跟踪记录清楚地显示了一个将 errorMsg 变量设置为一个明确表示程序失败的字符串的行，但这只是“幽灵跟踪”。该消息上方的行包含 if 命令和触发逻辑的条件子句：if 0 NEQ 0。这个条件是假的，因此代码块没有执行，任何看似执行的情况都只是幻象。如果存在 else 关键字和代码块，那个代码块中的代码本应会执行，但在这个例子中，解释器评估了 if 命令后，控制跳过了代码块后面的内容。

无论好坏，解释器不会抑制这种未执行的代码块。跟踪记录中并非每一部分都执行了。如果代码块中的命令生成了输出到标准输出（stdout），则该输出在跟踪记录中是否存在，可以验证它是否执行了。然而，很多时候代码块中的内容并不会生成输出，因此你必须像解释器一样，尝试评估条件子句。

令人沮丧的是，甚至这个方法也有局限性。你并不总是能够从跟踪记录中评估某些条件子句的结果。例如，if exist 命令用于判断文件是否存在，但仅凭跟踪记录中的条件子句，无法评估出文件是否存在。你几乎无法得知在代码执行时，文件是否存在，或者文件的连接是否暂时丢失。

如果代码分支显著，你可以从跟踪记录中接下来的情况推断出 if 命令的结果。例如，如果错误消息已经被设置，控制会立即跳转到：Abort 标签，因为有 goto 命令。问问自己，跟踪记录中的接下来的几行是否像该标签下的代码，还是像代码块后的代码。（这也是我之前提到的描述性注释的另一个原因。）然而，如果代码块中的代码只是设置了一个或两个变量，你很难仅凭跟踪记录判断它是否真正执行了（尽管下一个提示可能会有所帮助）。

如果没有其他办法，你可以在条件子句为真的时候，开始执行的代码块中加入一个 echo true 命令。我不太愿意建议这样不优雅的代码杂乱无章，但它会在 if 命令执行后立即将“true”文本，或者你希望的任何文本，写入到跟踪记录中，但只有当代码块执行时，才能明确显示 if 命令的结果。例如：

```
C:\Batch>if exist C:\Batch\MysteryFile.txt (
echo true 
 set errorMsg=The Database Purge Program Failed 
 goto :Abort 
) 
true 
```

代码块中的 echo true 命令总会出现在追踪中。毕竟，这个提示的重点在于，幽灵追踪包含了未执行的命令。但紧接在右括号之后的 true 文本显示了代码块已执行，并且当 if 命令查找该文件时，神秘文件确实存在。

### 创建变量的审计追踪

在批处理文件执行过程中，所有已设置、重置或未设置的变量的审计追踪可以极大地帮助你排除故障。如前面的提示所述，这可能是唯一能知道某个代码块是否执行的方式。为此，在一个长时间运行的批处理文件的开始部分，我通常会添加以下两行：

```
rem - All Variables in Effect Before Execution:
  set 
```

这个简单的命令，set 命令不带参数，会将所有现有的变量写入捕获的追踪。在同一过程的末尾，你可以执行相同的命令，但备注中引用执行后的状态。

这些备注使得所有已填充的变量列表易于查找。初始命令列出在执行开始时机器上设置的所有变量，后者则显示在执行过程中发生了什么变化。你只有在调试或作为每次执行的审计追踪时，才能执行此操作。

我在第二十九章中曾提到过这一技术，涉及数组和哈希表。你可能通过各种方式填充这些数据结构，而数据结构的构建即使条目不多，也可能使追踪变得杂乱。在那一章中，我建议使用更具针对性的 set 命令将数组或哈希表的内容转储到追踪中。例如，我们构建了一个名为 people 的哈希表。由于数据结构中的每个条目都以 people{开头，以下命令将在加载后或任何其他流程节点显示哈希表的全部内容：

```
rem - The Contents of people{key}:
  set people{ 
```

类似地，如果你的约定是将所有包含可执行程序的变量前缀设置为 _prog 文本，那么以下命令将显示所有这些变量的完整列表：

```
rem - All Program Variables:
  set _prog 
```

不带参数的命令在长时间的过程开始和结束时效果最佳，因为它提供了全局变量集，而带有目标的命令则适用于在批处理文件中战略位置的较短变量列表，可能是在某些复杂代码之后。

### 理解 for 命令的标准输出

由 for 命令生成的追踪复杂性与 for 命令本身的复杂性成正比，但即使是一个简单的例子也能展示一个常见的误解。以下代码来自第十八章，但它的作用不是求 1 到 100 的整数和，而是求 1 到由 count 变量定义的数字范围的整数和：

```
for /L %%i in (1,1,%count%) do (
  set /A sum += %%i
) 
```

为了减少追踪的长度，假设计数设置为 3，这意味着它会执行三次，尽管以下追踪显示了四个设置命令：

```
C:\Batch>for /L %i in (1 1 3) do (set /A sum += %i) 

C:\Batch>(set /A sum += 1) 

C:\Batch>(set /A sum += 2)

C:\Batch>(set /A sum += 3) 
```

第一行是整个 for /L 命令——但*不是*它的执行。请注意，count 以及括起来的百分号在输入中解析为 3，而两个%%i 的引用都变成了%i。这实际上是你在命令提示符中输入 for 命令时的变量形式，出于某种原因，它就是这样显示在 stdout 中的。接下来的三行展示了代码块的三次实际执行，for 变量分别解析为 1、2 和 3。

因为像 count 这样的变量在第一行中被解析，所以它可能看起来像是实际执行。这一点在使用复杂代码块或更多循环执行的更复杂示例中尤为明显。但请理解，这只是对即将到来的执行的一个信息性设置。可以把它看作是一本书的无言介绍，后面还有章节，每一章对应一次循环执行。

下一个提示展示了另一个关于 for 命令追踪的混淆来源。

### 如何解释未解析的变量

这非常让人沮丧，但解释器在追踪中解析了一些变量，而其他变量没有解析。在上一条提示中我提到，for 命令的追踪可以变得相当复杂，且不需要太多的东西。为了演示这一点，这里是一个不同的文件版本，我曾经在讨论第十九章中的 for /F 命令时频繁使用。我的做法只是将文件的整个记录放入一个变量，并将该记录同时写入 stdout 和控制台：

```
for /F "tokens=*" %%r in (C:\Batch\FourBrits.txt) do (
   set inRec=%%r
   echo Writing to Stdout: !inRec!
   > con echo Writing to the Console: !inRec!
) 
```

（如果你问我为什么不直接写%%r 标记，而是将多余的 inRec 变量包含进来，我正在展示一个在 for 命令的代码块内设置和使用变量的追踪结果，并尽可能减少其他内容的干扰。这种情况在逻辑稍微复杂一点的情况下自然而然地会发生。）

与上一条提示类似，追踪首先显示 for 命令，虽然大体上没有改变，但与实际代码相比还是有所不同。相反，解释器将这个更复杂的命令及其关联的代码块分成多行显示，便于阅读：

```
C:\Batch>for /F "tokens=*" %r in (C:\Batch\FourBrits.txt) do (
set inRec=%r
 echo Writing to Stdout: !inRec! 
 echo Writing to the Console: !inRec! 1>con
) 
```

接下来，文件中的第一条记录在追踪中生成以下内容。括号内的是正在执行的代码，而最后一行是第一个 echo 命令的结果：

```
C:\Batch>(
set inRec=English   John      Paul      George    Richard 
 echo Writing to Stdout: !inRec! 
 echo Writing to the Console: !inRec! 1>con 
) 
Writing to Stdout: English   John      Paul      George    Richard 
```

顺便提一下，文件中的每一条记录都会生成类似这样的内容，因此你可以看到追踪很容易迅速变得非常庞大；100 条记录将会生成 600 行文本。

前面的追踪信息清晰地显示了从%%r 解析出的输入记录及其赋值给 inRec 变量的过程，但是——这点很重要——接下来的两行追踪完全没有显示!inRec!的解析。它是否被正确设置并解析了呢？在这个实例中，我在第一个 echo 命令中使用它，清楚地展示了变量的内容在输出的尾部行中，但你在追踪信息中看不到该变量的其他使用情况。例如，第二个 echo 命令正在向控制台写入相同的文本，但它没有出现在追踪中。（可以将这看作是与幽灵追踪相反的情况。）

简单来说，任何在代码块内部赋值并通过感叹号解决的变量（也在代码块内），会以感叹号包围的变量名形式呈现，也就是说，未解决的。当执行时，它按预期解决，但追踪信息不会给出任何相关提示。

这是一个极其令人不安的警告（batveat）。有几乎无数的理由在 for 命令的代码块内设置并使用变量——而且通常最有趣的代码就藏在这里——但是发生的事情却消失在虚无之中。延迟扩展（在代码块内部和外部执行）是这一问题的另一个受害者。

处理这个问题有几种方法。第一种方法是完全不做任何处理；一旦理解了这种行为，一个好的程序员可以通过了解需要进行一定的推断来读取追踪信息，从而应对这些特性。

第二种方法是巧妙地放置 echo 命令来显示几行逻辑的结果。你可以将文本写入控制台以进行故障排除（稍后会详细介绍），或者简单地写入追踪文件。这实际上是我在前一个列表中用第一个 echo 命令所做的。

第三种方法是，如果需要逐行显示每个命令的结果，你可以将有趣的代码块移到一个调用例程中，并通过 call 命令调用它，传递所需的令牌作为参数。该例程可以将令牌当作参数处理，最终结果是功能上等效的代码，且现在在追踪信息中完全解析。

我对这个问题有一些职业经历。在实现一个非常复杂的嵌套 for 结构，最终导致重命名文件后，一直有人提出是否真的发生了重命名的问题。为了最终解决这个争论，我使用调用例程重写了代码。不幸的是，我们有时不得不为了功能性而妥协优雅性。

顺便提一下，这个追踪信息包含了一些怪异现象。代码块内部的第一行没有缩进，其他行缩进了一个空格，无论 bat 文件中的缩进如何。重定向语法`> con`出现在 bat 文件中的 echo 命令之前，但在追踪信息中，它被移到了末尾。我无法解释这些不一致之处，但我知道它们存在，我们必须接受追踪信息中的内容是对实际代码的扭曲呈现。

### 识别不一致的命令输出

由于批处理命令的多变性，命令间产生的消息会有所不同，从而加重了前面提到的麻烦。例如，如果一个 xcopy 命令在代码块内执行，并使用在代码块中设置并解析的变量，那么跟踪信息不会显示解析后的文件名或文件名。然而，如果使用/F 选项，该命令会将一条清晰的消息写入跟踪信息，详细列出命令的结果，列出复制的文件或文件。

相比之下，一个类似的 ren 命令在成功重命名时不会产生任何消息，意味着你可以重命名一个文件，但在跟踪信息中除了一个未解析的文件名的 ren 命令外没有任何提及。一个失败的 ren 命令会将一个通用的错误消息写入 stderr，但不同于 xcopy 命令，它不包含文件名。最终结果是，如果一个失败的 ren 命令在 for 循环中使用了感叹号，或者使用了延迟扩展，那么错误消息会说明重命名失败，但没有提及文件名或提供任何其他信息。

随着经验的积累，你会学会预期何时从常用命令中获得什么输出。对于其他命令，你则要预期一些出乎意料的情况。

### 将变量写入控制台

除非你直接跳到这一章和这个提示，否则你一定非常熟悉回显命令通过> con 语法将输出重定向到控制台。我多次使用过这种技巧来展示代码列表的结果，尤其在故障排除时，它非常方便，特别是在处理复杂的 for 循环时。

跟踪信息可能既隐晦又庞大，这对于可读性来说不是一个好组合。为了提取出重要数据，我经常在循环中放置一个临时重定向的回显命令，以便在每次循环时查看一个或多个变量的状态。

例如，“理解 for 命令的标准输出”第 380 页中的逻辑，计算一系列整数的和，这很难进行测试，因为虽然我们能看到 sum 变量被设置，但我们从未在任何一次循环迭代中看到它在跟踪信息中被解析。直到在循环后使用 sum 时，你才会看到它的值，但如果你没有得到预期的结果，你很可能会想查看那些丢失的中间值。你可以在求和代码中添加一行，以便获得事件的求和。看看你能否发现它：

```
 for /L %%i in (1,1,%count%) do (
      set /A sum += %%i
> con echo ---- index = %%i ---- sum = !sum! -----
  ) 
```

假设在执行之前，count 的值被设置为 4；最终的和应该是 10，但我们得到了 35。

如果你需要更多的细节，跟踪信息仍然没有改变，但额外的命令将以下简洁明了的文本写入控制台。变量被清楚地标注，破折号使它们更突出、更易于阅读：

```
---- index = 1 ---- sum = 26 -----
---- index = 2 ---- sum = 28 ----- 
---- index = 3 ---- sum = 31 ----- 
---- index = 4 ---- sum = 35 ----- 
```

索引变量应该递增（这没什么意外的），但对每个条目的 sum 变量进行仔细检查后，问题显现出来。代码从未初始化 sum，只有当它在进入循环时为 25 时，第一行中的 sum 才能为 26。之前的某个过程必须使用了这个同名的变量。添加一个快速的 set 命令将该变量初始化为 0 后，代码显示如下：

```
---- index = 1 ---- sum = 1 -----
---- index = 2 ---- sum = 3 ----- 
---- index = 3 ---- sum = 6 ----- 
---- index = 4 ---- sum = 10 ----- 
```

再次仔细检查 sum 变量，现在可以发现一切按预期工作；也就是说，之前的 sum 加上当前的索引，确实等于每个条目中的当前 sum，从第一个条目开始，它仅为 1。一旦测试和故障排除完成，你可以并且应该删除 echo 命令，然后继续往下。

我已经在最简单的 for 命令之一上演示了这种技巧，但 for 命令很快就变得晦涩难懂。一两个简单的重定向 echo 命令可以迅速且轻松地生成一些复杂且重复的逻辑摘要，从而大大帮助你的故障排除。

在第九章中，我曾对缩进表达过一些非常明确的看法，而我似乎在这个 echo 命令中违背了这些规则。简单回顾一下，注释没有缩进，标签缩进一个字节，其他所有内容缩进两个字节或更多。在我看来，这对于最终产品是必须遵守的，但这个 echo 命令是临时的，最好让这一点显而易见。否则，很有可能你会不小心将其遗留在代码中。这个花哨且未缩进的命令几乎在乞求被删除。

### 解读不同类型的语法错误

解释器将两种通用的错误信息写入 stderr：由命令生成的错误和语法错误。失败的 xcopy 或 del 命令会在跟随清晰错误信息的跟踪中显示命令本身，说明为何无法复制或删除文件。

不幸的是，语法错误并不总是以一致的方式呈现。语法错误的一个例子是在条件子句中使用不存在的 and 运算符。如第二十七章中提到的，解释器可能会直接忽略它，继续执行代码块中的内容，甚至不会写入 stderr。一个稍微不同的条件子句使用相同的错误运算符，可能会将 if 命令写入跟踪，然后是错误信息：

```
C:\Batch>if "" NEQ "A" and "" equ "B" (
'and' is not recognized as an internal or external command,
operable program or batch file. 
```

但这仍然继续执行代码块及之后的内容。顺便提一下，这条错误信息的意思是解释器错误地尝试将命令中的某些内容当作程序来执行，但通常这实际上是语法错误。

语法错误至少还有一种表现形式。为了演示这一点，让我们考虑一下本章早些时候讨论的稍作修改的代码版本，该代码除了执行一个程序并检查返回码外，几乎没有做其他任何事情：

```
%_pgmPurgeDB%
if %errorlevel% neq 0
   set errorMsg=The Database Purge Program Failed
   goto :Abort
) 
```

尽管这段代码看起来很简单，但执行时却崩溃了，命令窗口关闭，追踪底部留下了以下文字：

```
C:\Batch>DatabasePurge.exe
The syntax of the command is incorrect.

C:\Batch>  if 0 neq 0 
```

悲观主义者可能会指出，通用错误信息完全缺乏细节。乐观主义者可能会指出，解释器明确地告诉你语法错误，但当你开始分析这个信息时，你会意识到它的数字化作者无意间显得有些阴险。

错误信息指出语法不正确，紧随程序执行之后；它们之间甚至没有空行。这显然暗示着前一行有语法错误。但实际上，解释器更像是个占卜师。它声明接下来的那一行——被空行隔开的那一行——是错误的源头，尽管它看起来像是一个无争议的 if 命令。

总结一下，语法错误有时会在追踪中写出错误信息，有时则不会。有时解释器会忽略语法错误，继续执行接下来的命令，有时则不会。错误信息有时会在出错的命令之后出现，有时会出现在之前。我的最佳建议是，找出错误的大致位置。查看错误信息前后的代码，避免出现“隧道视野”。

在继续之前，那个 if 命令的语法到底有什么问题呢？这正是编译器提供简洁明了的错误信息时，简直是天降甘霖，但我们仅有的武器不过是我们的聪明才智和一个耸耸二进制肩膀的解释器，它说：“出错了，自己找原因。”紧盯着它后面的代码行进行仔细检查，命令名称几乎不可能拼错，if；有效的运算符，neq；以及两个要比较的数字。哎呀！缺少了一个左括号。

### 尽可能模块化

创建执行特定任务的小 bat 文件有很多好处，其中最重要的一项是测试。你可以轻松设置另一个 bat 文件来多次调用新 bat 文件，使用不同的输入参数，每次都验证所有输出结果，这些输出可以是返回的参数、写入控制台的数据，或是某些操作，比如复制文件。

要查看这个例子的实例，只需翻到第十一章。在构建了*MadLib.bat*文件后，我多次使用不同的输入参数调用它。转到第二十九章，如果你在一个已经很大的过程中的某一部分代码里创建一个数组或哈希表，一种选择是将其编码到现有的 bat 文件中。但大多数情况下，更好的选择是创建一个新的 bat 文件，包含所有有趣的逻辑。然后你可以通过从另一个 bat 文件使用 call 命令来快速并反复测试新 bat 文件，以排除任何漏洞。最后，你只需要在包含更大过程的现有 bat 文件中添加一两个 call 命令即可。

你很快就会看到更多这样的例子。在第三十二章中，在创建一个面向对象的 bat 文件后，我将通过另一个 bat 文件使用多个 call 命令来调用它。然后在第三十三章中，我将创建一个单独的 bat 文件来处理栈。随后对它的调用将推送项目到栈上并从栈中取出项目。尽可能进行模块化。

### 测试 Bat 文件中的代码片段

不幸的是，有时候模块化并不可行。一个大型应用程序可能需要调整现有的 for 命令。如果它在一个大型的 bat 文件中，且这个文件是一个更大流程的一部分，将更改集成到新模块中可能不切实际。更复杂的是，由于缺乏编译器，当你做出即使是最微小的更改时，出错的几率大大增加。如果这是一个长时间运行的过程，你可能需要一小时甚至更长时间才能发现自己遗漏了一个括号，而更复杂的更改通常需要多轮的编码-测试-调整。最好只测试待测试的代码，能够快速反复运行它。

我们需要的是一种方法，在简单和受控的环境中模拟新逻辑或更新逻辑的实际环境。为了实现这一目标，我在每台工作计算机上都有一个*C:\Batch\*文件夹，其中包含一个名为*Test.bat*的 bat 文件，至少一开始其内容是完整的：

```
 @setlocal EnableExtensions EnableDelayedExpansion
  @call :GetTrace > C:\Batch\Trace.txt 2>&1
  @pause
  goto :eof

 :GetTrace
rem --- Variables Set Prior to Code Snippet
rem --- Code Snippet Goes Here
rem --- Variables Set After to Code Snippet
  goto :eof 
```

目前，这个 bat 文件将执行一个非常无聊的例程，包含三个 rem 命令，捕获 stdout 和 stderr 到追踪文件，并通过 pause 命令保持控制台打开。但这个 bat 文件仅仅是一个外壳。要测试来自更大 bat 文件的代码片段，可以将其粘贴到第二个 rem 命令之后。示例可能包括一个复杂的 for 命令，或者一个更长的片段，它在构建和使用数组的同时，还读取和写入多个文件。

如果代码期望在代码片段执行之前设置某些变量，你可以在第一个 rem 命令之后将它们作为硬编码值输入。如果需要读取某个文件，可以在此部分创建一个模拟文件，并添加其文件连接器。

类似地，如果被测试的过程是为了在环境中设置某些变量以供后续使用，你可以在第三个 rem 命令之后，通过将 echo 命令重定向到控制台来查询它们。你不仅能在控制台上看到这些解析后的变量，还能在详细的追踪信息中看到它们（除非未解析的变量问题再次出现）。

为了演示，如果你使用这种技术来测试本章前面详细介绍的求和逻辑，你可以像这样更新 shell bat 文件中的内部例程：

```
 :GetTrace
rem --- Variables Set Prior to Code Snippet
  set count=100

rem --- Code Snippet Goes Here
  for /L %%i in (1,1,%count%) do (
      set /A sum += %%i
  )

rem --- Variables Set After to Code Snippet
  > con echo sum = %sum%
  goto :eof 
```

待测试的代码放在中间部分，但这只是起点。你需要在核心逻辑执行之前定义计数变量，并且由于这段代码的最终结果是一个变量的值，你将需要在程序的第三部分解析并显示 sum 到控制台。

现在你可以快速、高效、频繁地进行测试、调整、重新测试和再次调整。这不是最终测试，但一旦测试满意，你可以将清单复制并粘贴到主流程中。现在你可以以较高的信心执行完整的端到端测试。

我也使用同一个批处理文件来测试我在之前的技巧中介绍的模块化代码。你可以轻松地在中间部分添加一个或多个其他批处理文件的调用命令，同时仍然使用第一部分进行设置，第三部分进行验证。剪切和粘贴从来不优雅，但毫无疑问，在测试批处理文件中的代码片段是非常有效的。

### 总结

我无法过分强调掌握测试和故障排除批处理代码技术的重要性。在这一章中，我插入了*《尖峰时刻》*中的放大器，并把音量调到 11。通过这 11 个技巧，我展示了我如何开发和维护批处理文件。用一句话总结：捕获并能够读取跟踪，写入控制台输出，尽可能进行模块化，并在适当时使用*Test.bat*。

我相信其他人会有有用的补充内容，我鼓励你去寻找它们。对批处理的测试，唯一的替代方案就是最终放弃并编写一些已编译的代码来执行本可以并且应该通过几行批处理代码完成的任务。

下一章将讨论一种令人兴奋且有趣的编码方法：面向对象设计，这个话题你可能现在还不会与批处理（Batch）联系在一起，但很快你会发现它的关联。
