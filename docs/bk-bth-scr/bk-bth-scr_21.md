

## 19 读取文件和其他输入



![](img/chapter.jpg)

到目前为止，功能强大的 for 命令的最复杂语法和最强大的功能是通过 /F 选项实现的，它允许进行*文件读取*。没有选项的 for 命令已经能够处理文件，比如获取文件的名称、路径、驱动器、大小和属性，几乎涵盖了与文件相关的所有内容，除了文件的实际内容。接下来就是 /F 选项。

在介绍语法后，我将演示如何逐条记录地读取文件。你将学习如何操作输入数据，将记录的全部内容放入变量中，或将其拆分为批处理所称的 tokens。通过对数据进行标记化处理，你将能够提取你需要的特定数据部分。

尽管 for /F 命令表面上是用于读取文件的，但输入也可以采用其他形式。这个命令可以将字符串视为单个记录文件，甚至可以将另一个批处理命令的输出作为其输入。所有这些将允许你以多种不同的方式处理和操作不同形式的信息。

### 含 /F 选项的 for 命令

/F 选项将 for 命令转变为一个多功能的文件读取工具。带有此选项的命令有多种形式，但我将首先考虑其中一种。以下是读取文件或文件集的 for /F 命令的通用语法：

```
for /F ["`suboptions`"] %%`variable` in (`file-set`) do `command`
```

与没有选项的 for 命令相比，这种语法有很大不同。最明显的是，/F 选项已经到位。我还将括号内的通用输入占位符更改为更具体的术语 file-set，但这仅仅是命名上的不同。与没有选项的命令版本相比，这个变体只接受一个文件、文件掩码或多个文件或文件掩码。

最显著的区别是增加了["suboptions"]子句。方括号表示这些子选项本身是可选的，但如果包含它们，必须用双引号括起来。每个可能的子选项都有自己的特定关键字。我将在本章稍后讨论其中一个子选项 usebackq，但其他子选项会直接影响你如何读取和操作数据。

### 读取文件内容

关键字 tokens、delims、skip 和 eol 可能不容易说出口，但它们是子选项子句的关键元素，控制着文件的读取。了解它们的最佳方法是探索没有选项的 for /F 命令的行为，然后逐一添加与这四个关键字相关的子句，以展示它们的用途。

让我们回到第十七章中 for 命令的介绍部分，在那里我简要处理了一个名为*FourBrits.txt*的文件，但没有提及其内容。对于这个演示，假设这是一个包含四条记录的小文件。每条记录有五个元素，第一个是语言，其余四个是该语言中写出的四个特定男性名字。元素之间由空格或制表符分隔，下面是文件的完整内容：

```
English   John      Paul      George    Richard
Spanish   Juan      Pablo     Jorge     Ricardo
French    Jean      Pol       Georges   Richard
Italian   Giovanni  Paolo     Giorgio   Riccardo 
```

考虑这个 for 命令：

```
for %%a in (C:\Batch\FourBrits.txt) do (
   > con echo %%a
) 
```

输出正是你现在期望的：一行数据，显示输入文件的路径和文件名：

```
C:\Batch\FourBrits.txt
```

为了演示新选项，我将在逻辑中添加/F：

```
for /F %%a in (C:\Batch\FourBrits.txt) do (
   > con echo %%a
) 
```

现在是输出：

```
English
Spanish
French
Italian 
```

这样一个小小的变化导致了截然不同的结果。现在，代码不是以文件名的形式向控制台写入单条信息，而是输出文件中每条记录的第一个单词。由于/F 选项，命令正在打开并读取文件的内容。还有很多工作要做，但命令实际上是在读取文件中的每一条记录，并将%%a 设置为记录中的第一个单词。如果文件包含 64 条记录，那么之前的逻辑将在控制台上写入 64 个单词，每个单词占一行。

这个输出引发了更多问题，而不是解答了它们。为什么这不是写入整个记录？我们可以只解析记录的一部分吗？我们必须读取每条记录吗？这就是通用语法中的 suboptions 子句的关键字发挥作用的地方。

#### 标记化数据

在 Batch 中，一个*标记*是记录的一个元素，默认情况下，每个标记由空格或制表符分隔。检查文件中的第一条记录，它正好包含五个标记：

```
English   John      Paul      George    Richard
```

默认情况下，Batch 将标记数量设置为 1。这解释了为什么在之前的示例中，解释器将%%a 解析为每条记录中的第一个单词（或标记），并丢弃了记录中的其余部分。

要更改这个默认值，你可以使用 tokens 子句；它是 tokens 关键字，后面跟着一个等号和设置，在这种情况下是 2：

```
for /F "tokens=2" %%a in (C:\Batch\FourBrits.txt) do (
   > con echo %%a
) 
```

tokens 子句告诉解释器将哪个标记或哪些标记作为 for 变量传递到循环中。执行此代码会产生以下输出，写入控制台：

```
John
Juan
Jean
Giovanni 
```

由于 tokens 子句，解释器现在将第二个单词或标记传递到循环中，将 John 及其翻译写入控制台。将其设置为 5 将检索到 Richard 的名字。通过这个子句，你可以相对轻松地提取单个标记。

##### 提取多个标记

能够提取单个标记很不错，但能够提取多个并选择标记会更有用。要提取所有五个标记，将文本 1-5 分配给 tokens 关键字。但这引出了一个有趣的问题。如何仅通过定义单个变量%%a 来解析这五个标记呢？

额外的变量以简单的字母顺序优雅地表示。如果%%a 是 for /F 命令中定义的变量，它解析为标记子句中定义的第一个标记，接着%%b 解析为第二个，%%c 解析为第三个，%%d 解析为第四个，最后%%e 解析为第五个。考虑以下内容：

```
for /F "tokens=1-5" %%a in (C:\Batch\FourBrits.txt) do (
   > con echo %%a:  %%b, %%c, %%d, and %%e
) 
```

这段代码将记录格式化，使语言后跟冒号和两个空格。然后，在输出中，名称之间用逗号和空格分隔，最后一个名字前有一个连接词：

```
English:  John, Paul, George, and Richard 
Spanish:  Juan, Pablo, Jorge, and Ricardo 
French:  Jean, Pol, Georges, and Richard 
Italian:  Giovanni, Paolo, Giorgio, and Riccardo 
```

你也可以选择提取特定的标记，而不是一个范围。在标记子句中，用逗号分隔所需的标记。此代码仅将第二个和第四个标记传入循环：

```
for /F "tokens=2,4" %%a in (C:\Batch\FourBrits.txt) do (
   > con echo %%a and %%b played guitar.
) 
```

结果将写入控制台：

```
John and George played guitar. 
Juan and Jorge played guitar. 
Jean and Georges played guitar. 
Giovanni and Giorgio played guitar. 
```

现在，数据记录中的第二个标记是标记子句定义的第一个标记，因此 Batch 将其分配给%%a，而不是%%b。同样，%%b 现在解析为记录中的第四个标记，也就是第二个选中的标记。简而言之，变量字母模仿的是标记子句中定义的标记位置，而不是它在记录中的位置。

到目前为止，我使用了%%a 作为 for 变量。无论你选择哪个字母作为变量，解释器都会将后续标记分配给字母表中的相应字母。之前的代码在功能上等价于以下代码：

```
for /F "tokens=2,4" %%x in (C:\Batch\FourBrits.txt) do (
   > con echo %%x and %%y played guitar.
) 
```

唯一的区别是我将%%a 改为了%%x，这意味着%%y 现在解析为第二个标记，而不是%%b。

需要注意的是，选择%%x 作为 for 变量限制了你只能处理三个可能的标记，因为在%%z 之后没有更多的标记可以分配（尽管《超越斑马》（*On Beyond Zebra!*）中的 Dr. Seuss 努力过）。你不会经常看到这种情况，但数字也有效。例如，如果你提取三个标记并将 for 变量定义为%%7，解释器将使用%%8 和%%9 作为隐式标记。

该关键字还接受数字、逗号和短横线的组合。例如，tokens=1,3-5 子句处理除 John（第二个标记）之外的所有标记。

##### 提取记录的其余部分

关于标记关键字，还有另一个变化。星号表示输入记录的其余部分，包括嵌入的空格。考虑这段使用 2* 的代码在标记子句中的情况：

```
for /F "tokens=2*" %%a in (C:\Batch\FourBrits.txt) do (
   > con echo %%a, Rest of the Band: "%%b"
) 
```

这个命令将第二个标记分配给%%a，因为子句中的 2；然后解释器将记录的其余部分，即第三、第四和第五个标记，包括任何嵌入的空格和制表符，分配给%%b，因为星号(*)。语言，即每个记录中的第一个标记，在输出中找不到：

```
John, Rest of the Band: "Paul      George    Richard" 
Juan, Rest of the Band: "Pablo     Jorge     Ricardo" 
Jean, Rest of the Band: "Pol       Georges   Richard" 
Giovanni, Rest of the Band: "Paolo     Giorgio   Riccardo" 
```

为了让这个讨论圆满结束，当我们在本章开始时仅仅为 for 命令添加了 /F 选项时，默认的标记子句只将第一个标记传递到代码块。在许多情况下，你会希望将整个记录完整地提取出来，正如它在输入文件中所呈现的那样作为一个整体。由于星号代表输入记录的其余部分，单独将它分配给标记就会选择整个记录：

```
for /F "tokens=*" %%r in (C:\Batch\FourBrits.txt) do (
   > con echo Entire Record: "%%r"
) 
```

同时请注意，我将变量改为 %%r。这里是输出结果：

```
Entire Record: "English   John      Paul      George    Richard" 
Entire Record: "Spanish   Juan      Pablo     Jorge     Ricardo" 
Entire Record: "French    Jean      Pol       Georges   Richard" 
Entire Record: "Italian   Giovanni  Paolo     Giorgio   Riccardo" 
```

之前使用 %%a 完全可以正常工作，但我在这里做了修改，原因有两个：首先，r 代表*记录*，其次，作为一个简单的提醒，任何字母字符都可以使用。

> 注意

*如第十七章中所提到，for 变量实际上是区分大小写的，并且允许一些非字母数字字符。这意味着 %%a 和 %%b 仅能解析为定义为 %%a 的变量的前两个标记；%%A 和 %%B 不会生效，除非你将 for 变量改为 %%A。我可能不需要再提，但那些奇怪的字符（比如 %%#）根本不适合用来提取多个标记。*

#### 定义数据分隔符集

能够将输入记录分解为由空格和制表符等分隔符定义的标记确实非常强大，但在许多情况下，你无法控制正在读取的文件中的数据，而不同的分隔符，甚至是多个分隔符，会更加适用。delims 关键字定义了用于标记数据的一种或多种*分隔符*。

##### 解析逗号分隔数据

逗号分隔格式是一种流行且简便的存储数据方式。例如，*.csv* 文件包含任意数量的逗号分隔记录，你可以使用 Excel 打开并查看数据。每个标记由逗号分隔，每个标记可以包含空格。在展示 Batch 如何读取 CSV 数据之前，我需要做一些设置。

*FourBrits.txt* 文件可能包含带有嵌入空格的名字，比如 Richard aka Ringo。在之前讨论的空格分隔示例中，这段文本包含三个不同的标记。我现在将重新格式化数据，并以逗号分隔的文件 *FourBrits.csv* 提供。该文件的内容将与其同名的 *.txt* 文件相同，只是分隔符和 Richard 的别名有所不同：

```
English,John,Paul,George,Richard aka Ringo
Spanish,Juan,Pablo,Jorge,Ricardo aka Ringo
French,Jean,Pol,Georges,Richard aka Ringo
Italian,Giovanni,Paolo,Giorgio,Riccardo aka Ringo 
```

下一步任务是修改 for /F 命令，使其将逗号作为分隔符而不是空格，我将通过 delims 关键字实现这一点。当关键字不存在时，解释器会默认为只包含空格和制表符字符的分隔符集。在以下示例中，delims=, 将分隔符集定义为单个字符，即逗号：

```
for /F "tokens=1-5 delims=," %%a in (C:\Batch\FourBrits.csv) do (
    > con echo %%a:  %%b, %%c, %%d, and %%e
) 
```

当解释器遇到第五个也是最后一个标记——一个名字后跟别名 Ringo 时——它会将文本写入控制台，保留其中的空格：

```
English:  John, Paul, George, and Richard aka Ringo
Spanish:  Juan, Pablo, Jorge, and Ricardo aka Ringo
French:  Jean, Pol, Georges, and Richard aka Ringo
Italian:  Giovanni, Paolo, Giorgio, and Riccardo aka Ringo 
```

Ringo 是不可翻译的。

使用管道分隔的数据文件也很流行；delims=|子句解析输入数据中的管道，这样内嵌的空格和逗号就不会创建额外的标记。等号甚至可以作为分隔符，使用 delims==子句。（你很快会看到相关示例。）

##### 定义多个分隔符

你甚至可以通过一个 delims 子句定义多个分隔符。以下代码将分隔符集合定义为逗号和空格。虽然很微妙，但与之前的示例相比，唯一的变化是我在 delims=和后续的双引号之间添加了一个空格：

```
for /F "tokens=1-5 delims=, " %%a in (C:\Batch\FourBrits.csv) do (
   > con echo %%a:  %%b, %%c, %%d, and %%e
) 
```

现在，解释器每次遇到空格或逗号时，都会看到一个新的标记。第五个标记将仅包含名字 Richard，而 aka 和 Ringo 分别被分配到未分配的第六个和第七个标记。

为了展示更大范围的分隔符，我将使用一个名为*Alphabets.txt*的单记录文件，其中包含大写和小写的拉丁字母，中间用一个空格隔开：

```
ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz
```

完全省略 delims 子句将调用默认的分隔符集合，并仅生成两个标记：大写字符集和小写字符集，除此之外没有更多内容。相反，在以下代码中，我将 delims 关键字设置为 Delims 文本和一个尾随空格：

```
for /F "tokens=1-8 delims=Delims " %%a in (C:\Batch\Alphabets.txt) do (
   > con echo Token 1 = %%a
   > con echo Token 2 = %%b
   > con echo Token 3 = %%c
   > con echo Token 4 = %%d
   > con echo Token 5 = %%e
   > con echo Token 6 = %%f
   > con echo Token 7 = %%g
   > con echo Token 8 = %%h
) 
```

如果数据中每个分隔符仅出现一次，似乎逻辑上会产生八个标记。虽然这不一定是正确的，但我已经通过 tokens=1-8 子句定义了这么多个标记，并添加了相同数量的 echo 命令。让我们关注一下生成的标记数量。以下是结果输出：

```
Token 1 = ABC
Token 2 = EFGHIJKLMNOPQRSTUVWXYZ
Token 3 = abcd
Token 4 = fgh
Token 5 = jk
Token 6 = nopqr
Token 7 = tuvwxyz
Token 8 = 
```

这里有许多需要注意的点，包括分隔符集合是区分大小写的事实。大写字母 D 是一个分隔符，但小写字母 d 不是。小写字母 e、l、i、m 和 s，以及空格，组成了完整的分隔符集合。当查看原始数据，并将除了空格以外的分隔符加粗时，更容易理解这七个标记的来源：

```
ABC**D**EFGHIJKLMNOPQRSTUVWXYZ abcd**e**fgh**i**jk**lm**nopqr**s**tuvwxyz
```

注意，这些数据中列出了两个分隔符（l 和 m）按顺序排列，并且由于它们之间没有任何内容，你可能会预期解释器将为第六个标记分配空值或空白，并将其后面的文本 nopqr 移到第七个标记。然而，Batch 将连续的分隔符（lm）视为一个单一的分隔符，因此第六个标记是文本 nopqr。因此，tuvwxyz 是第七个标记，且由于它后面没有内容，第八个标记的值为空。

注意只使用你已定义的标记。如果子句是 tokens=1-7，最终的 echo 命令将导致 Token 8 = %h，因为%%h 不会是第八个标记；它将是一个百分号转义另一个百分号，后面跟着一个硬编码的字符。

在解析逗号分隔（或管道分隔）数据时，许多编译语言将连续的分隔符视为两个分隔符，并尊重它们之间的空值，这完全是合理的。然而，Batch 通常以空格作为分隔符，只需看看原始的*FourBrits.txt* 数据，其中每个单词之间的空格数量不一，就可以清楚地看到，视多个空格为单一分隔符也是非常合乎逻辑的。

不幸的是，这确实会带来一些挫败感，尤其是当数据不是以空格，而是逗号分隔时，但在第二十章中，我会向你展示如何让 for 循环尊重连续分隔符之间的空值。然而，如果我能够控制仅以逗号分隔的输入数据，我会总是在两个逗号之间写入一个空元素作为空格。

我将空格放在分隔符集合中的最后，因为它必须排在最后。我不想再次贬低解释器，但如果空格出现在其他位置，它会感到困惑。因此，在将空格包含在分隔符集合中时，delims 子句必须放在子选项的最后，紧接在结尾的双引号之前。

#### 跳过头部记录

如你刚刚看到的，tokens 和 delims 关键字有很多微妙之处。接下来的几个关键字则简单得多，特别是 skip 关键字，它可以让你在读取文件时跳过任意数量的头部记录。

让我们回到原始的*FourBrits.txt* 文件，在接下来的四条记录之前添加一个头部记录：

```
Four Liverpudlians in Four Languages:
English   John      Paul      George    Richard
Spanish   Juan      Pablo     Jorge     Ricardo
French    Jean      Pol       Georges   Richard
Italian   Giovanni  Paolo     Giorgio   Riccardo 
```

让我们运行来自 tokens 关键字讨论的相同的 for /F 循环：

```
for /F "tokens=1-5" %%a in (C:\Batch\FourBrits.txt) do (
   > con echo %%a:  %%b, %%c, %%d, and %%e
) 
```

它将头部行作为其他行一样处理，输出以下垃圾数据，后面跟着四行有效输出（我只展示其中一行）：

```
Four:  Liverpudlians, in, Four, and Languages:
English:  John, Paul, George, and Richard 
```

幸运的是，skip 关键字定义了在文件开头要跳过的记录数。这样就会跳过第一条记录，并完美处理数据记录：

```
for /F "tokens=1-5 skip=1" %%a in (C:\Batch\FourBrits.txt) do (
   > con echo %%a:  %%b, %%c, %%d, and %%e
) 
```

如果有三条头部记录，skip=3 子句会使 for 命令从第四条记录开始。

#### 抑制注释记录

虽然 skip 关键字仅跳过文件开头的记录，但 eol 关键字（表示*行尾*注释字符）跳过文件中所有以定义字符开头的记录。如果我要宽容一点的话，我会说，当解释器在记录的第一个字节中看到定义的*字符*时，它会将该字符视为*行尾*，并将剩余部分视为*注释*。

为了演示，我们再次编辑输入文件。这一次，我添加了第二条注释记录，更重要的是，每条注释记录现在都以句点开头：

```
.Four Liverpudlian in Four Languages:
English   John      Paul      George    Richard
Spanish   Juan      Pablo     Jorge     Ricardo
French    Jean      Pol       Georges   Richard
.This is a random and annoying mid-file comment with no discernable purpose.
Italian   Giovanni  Paolo     Giorgio   Riccardo 
```

向相同的 for 命令中添加 eol=. 子句指示解释器跳过所有注释行，无论它们在数据中出现的位置如何，并只处理其余的记录：

```
for /F "tokens=1-5 eol=." %%a in (C:\Batch\FourBrits.txt) do (
   > con echo %%a:  %%b, %%c, %%d, and %%e
) 
```

不幸的是，这个简单明了的关键字也有它自己的限制。鉴于 `delims` 子句接受一组分隔符，你可能期望 `eol` 子句接受一个或多个字符。但实际上，它只接受一个字符。

术语 `tokens`、`delims`、`skip` 和 `eol` 可能不像 John、Paul、George 和 Ringo 那样朗朗上口，但这四个精彩的关键字提供了极大的灵活性，本章及其他章节中还会有更多与这些关键字相关的子句示例。

### 定义输入

你现在知道如何使用 `for /F` 命令读取一个文件，但你可能还不知道如何读取一个*文件*——这之间是有区别的。传统的文件是由存储在驱动器上的一个可引用位置中的记录组成的字节集合，这些记录通过目录和文件名进行定义。而*文件*是某种可以被 `for /F` 命令读取的输入；它可以采取不同的形式，并不一定是编辑器能够打开的东西。

除了传统的文件，这个命令还可以接受字符串作为输入，也可以接受另一个批处理命令的输出。正如你将很快看到的那样，语法中的微小差别决定了输入的类型。

#### 文件输入

文件集输入是传统的文件或一组文件。我在本章中已经展示了几次这种形式的示例。每个示例中括号内都包含一个文件，现在我们知道这些输入是文件，因为没有任何围绕的引号，无论是单引号还是双引号。你还没有看到的是一组文件。以下命令按文件集中的列出顺序读取两个文件的内容，文件之间由逗号、空格或两者的组合作为分隔符，方便阅读：

```
for /F "tokens=1-5" %%a in (FourBrits.txt, MoreBrits.txt) do (
   > con echo %%a:  %%b, %%c, %%d, and %%e
) 
```

假设第一个文件 *FourBrits.txt* 有四条记录，`for /F` 命令按顺序处理每一条记录，向控制台写入四行。解释器接着关闭该文件并打开 *MoreBrits.txt*。此文件中的每一条记录都会触发一次代码块内逻辑的执行，并向控制台再写入一行。我还删除了文件路径，因此解释器将在当前目录以及路径变量中定义的目录中查找这些文件。

#### 字符串输入

以下是使用字符串作为输入的 `for /F` 命令的一般语法。请注意括号内的输入：

```
for /F ["`suboptions`"] %%`variable` in ("`string`") do `command`
```

这种形式将输入文本替换为“字符串”。双引号告诉解释器它们包围的是某种文本，而完全没有引号则告诉解释器考虑输入为文件或一组文件。其他部分的工作方式完全相同。

以下 `for /F` 命令与本章前面使用的其他示例类似，唯一不同的是输入：

```
for /F "tokens=1-5" %%a in ("Italian Giovanni Paolo Giorgio Riccardo") do (
   > con echo %%a:  %%b, %%c, %%d, and %%e
) 
```

唯一的区别是，我已将 *FourBrits.txt* 的最后一行文本移除了一些额外的空格以提高可读性，并将其作为被双引号包围的字符串输入。

代码块中的 `echo` 命令并不知道这五个标记的来源，是否来自硬编码的字符串或从文件读取的记录。这里是我们熟悉的结果：

```
Italian:  Giovanni, Paolo, Giorgio, and Riccardo
```

在这个例子中，括号内的文本是硬编码的，但你也可以使用包含文本的变量，只要它被双引号括起来。你可以使用任何字符串作为输入，解释器会将其视为一个单一记录文件。

这个特性使得复杂的字符串解析成为可能。实际上，我在 第五章 中使用了这个功能，却完全没有解释它是如何工作的，承诺稍后会解释。`for /F` 命令将布尔值转换为布尔字符串，其中 `bGod` 布尔值包含两个值中的一个，`true==true` 或 `false==x`。当时我提到，尽管将其归结为不过是个魔术技巧，这个命令会去掉两个等号及其后的所有内容，从而将 `bStrGod` 的值设为 `true` 或 `false`：

```
for /F "delims==" %%b in ("%bGod%") do  set bStrGod=%%b
```

通过本章所学，你现在可以弄清楚它是如何工作的。

`for /F` 命令将括号内双引号中的解析布尔值视为字符串或文本输入。`delims` 子句将等号定义为唯一的分隔符，并且由于我没有定义 `tokens` 关键字，所以隐式地采用了默认子句 `tokens=1`。结果是，等号前的词是第一个标记，解释器将其解析为 `%%b`（当然是为 *boolean*），同时丢弃等号后面的第二个标记。`set` 命令然后在第一次也是唯一一次执行时将第一个标记赋值给布尔字符串。

所以，这根本不是什么魔术，而仅仅是一种简洁的方法，通过一行代码从更大的字符串中提取一个单一的分隔值。请看 `for /F` 命令及其多个输入的强大功能。

#### 命令输入

括号内的内容决定了任何 `for /F` 命令的输入。你知道没有引号表示一个文件，双引号表示一个字符串。单引号表示另一个 Batch 命令是输入，下面是它的一般语法：

```
for /F ["`suboptions`"] %%`variable` in ('`command`') do `command`
```

在单引号之间输入的任何 Batch 命令会先执行，其结果的标准输出（stdout）将作为 `for /F` 命令的输入。解释器随后会逐行处理它认为是输入的内容，如果有多行，就像处理一个文件一样。

为了展示命令作为输入的有用性，考虑在 第十三章 中介绍的 `dir` 命令。以下命令列出给定目录中的所有文本文件：

```
dir C:\Batch\*.txt /B
```

`/B` 选项只会生成文件名和扩展名的列表——没有文件日期和大小，也没有头部和尾部行。命令只会将这些信息写入标准输出供你查看，仅此而已。很多时候，你会想将这个文件列表拿来对每个文件执行某些逻辑。例如，让我们编写一些代码，将目录中所有 `*.txt` 文件的扩展名改为 `*.bak`，以表示它们是备份文件。

单引号告诉 for /F 命令输入的是一个命令。dir 命令生成一个文件名列表，每个文件名都带有扩展名但没有路径：

```
for /F "tokens=*" %%f in ('dir C:\Batch\*.txt /B') do (
   ren "C:\Batch\%%f" "%%~Nf.bak"
) 
```

tokens=* 子句确保 %%f 在遍历文件列表时将整个字符串作为其值。默认子句会丢弃名称中第一个嵌入空格后的所有内容。ren 命令重命名文件，使用文件名的修改符（N），并附加上硬编码的扩展名。

我希望你能理解这一点有多么令人印象深刻。三个命令被绑定在一起，只需几行代码就可以完成相当多的操作。对于经常使用它的人来说，这可能变得司空见惯，而对于其他人来说，可能会觉得有些压倒性，但在许多语言中，类似的操作没有中间文件是做不到的。使用这种技术，dir 命令不仅仅是将信息输出到控制台或文件中（虽然这也很有用）。输出的原始格式显然是为此目的设计的。你可以对任意数量的文件执行许多处理，无论是简单的还是复杂的。我会在深入一些实际应用时进一步展开。

### 输入类型的替代语法

对于某些输入，刚才讨论的语法根本不起作用。有时文件名包含空格，但将其用双引号括起来会使其变成字符串输入。如果字符串中包含双引号，你就无法将其用一对双引号括起来。同样，命令有时会包含单引号。这些情况就需要不同的语法，而 usebackq 关键字，作为 for /F 命令的最后一个子选项，是解决方案。

在深入之前，有些批处理缩写是显而易见的；我大概不需要告诉你 delims 是 *delimiters* 的缩写，tokens 是 *tokens* 的缩写。但你可能会对这个加密的文本 usebackq 感到困惑。这个关键字代表 *use back quote*，虽然这可能没什么帮助，但至少现在你知道看到它时该怎么发音了。

#### 文件输入

展示 usebackq 关键字有用性的最佳方法是重新创建一种无疑促使其诞生的情境。到目前为止，本章中的许多示例都读取了一个名为 *FourBrits.txt* 的文件。我很少在文件名中嵌入空格，但别人可能会将这个文件命名为 *Four Brits.txt*。

为了展示空格可能带来的问题，我从之前的内容中直接复制了以下 for /F 命令，只是文件名现在包含了一个嵌入的空格：

```
for /F "tokens=1-5" %%a in (C:\Batch\Four Brits.txt) do (
   > con echo %%a:  %%b, %%c, %%d, and %%e
) 
```

批处理将此视为两个文件（而不是一个），可能会失败，因为找不到名为 *Four* 且没有扩展名的文件。显而易见的解决方案是将路径和文件名用双引号括起来，但 for /F 命令会将其视为文本字符串而不是文件名，因此这种方法行不通。

解决方案是使用 usebackq 关键字 *并* 在输入周围加上双引号：

```
for /F "usebackq tokens=1-5" %%a in ("C:\Batch\Four Brits.txt") do (
   > con echo %%a:  %%b, %%c, %%d, and %%e
) 
```

这个关键字还使处理包含特殊字符（如括号）的路径和文件名变得更容易。

`for /F` 命令成功地读取文件并产生与之前相同的输出。你甚至可以读取多个文件，每个文件的名字中都有空格：

```
for /F "usebackq tokens=1-5" %%a in ("Four Brits.txt", "More Brits.txt") do (
   > con echo %%a:  %%b, %%c, %%d, and %%e
) 
```

注意，文件名由逗号分隔，并且每个文件名都被一对双引号括起来。

这是使用文件集作为输入并带有 `usebackq` 关键字的命令的一般语法：

```
for /F "usebackq [`suboptions`]" %%`variable` in ("`file-set`") do `command`
```

这个关键字改变了规则。双引号可以包围每个文件名，尽管它在没有双引号的情况下仍然与关键字一起工作，前提是文件名中没有嵌入空格。

#### 字符串输入

`usebackq` 关键字解决了一个问题，但又创造了另一个问题。它允许在文件名周围使用双引号，但这似乎禁止了处理字符串的能力。解决方案是将文本用不同的字符括起来，这个字符就是单引号。以下是一般语法：

```
for /F "usebackq [`suboptions`]" %%`variable` in ('`string`') do `command`
```

因此，以下两个 `for` 命令在功能上是等价的：

```
for /F "tokens=1-4" %%a in ("Larry Moe Curly Iggy") do break
for /F "usebackq tokens=1-4" %%a in ('Larry Moe Curly Iggy') do break 
```

如果没有 `usebackq`，我将 Stooges 的简短列表括在双引号中，而当关键字存在时，单引号会将相同的文本括起来。（我还使用了 `break` 或 *无操作* 命令，使这些命令在关注关键字和引号类型的同时有效，但这些命令不会产生任何输出。）

为什么 Batch 提供两种执行相同任务的方法？为了回答这个问题，我将使用一串芝加哥机场的名称，每个机场名出于某种未知原因都被括在括号中，作为输入。以下两个命令在功能上是等价的：

```
for /F "tokens=1-2" %%a in ("(O'Hare) (Midway)") do break
for /F "usebackq tokens=1-2" %%a in ('^(O'Hare^) ^(Midway^)') do break 
```

第一个示例，没有使用 `usebackq`，要更加易于操作。你必须转义特殊字符，如括号，因为缺少双引号。但如果没有关键字，这些字符只是出现在双引号中的一部分。

但是，在双引号字符串中，唯一永远不起作用的字符就是孤立的双引号本身——即使它被转义。回到 Stooges，虽然 Iggy Pop 是 *The Stooges* 的主唱，但他显然不是 *The Three Stooges* 的成员，所以我可能想用引号或者双引号把他的名字括起来，以表示讽刺：

```
for /F "usebackq tokens=1-4" %%a in ('Larry Moe Curly "Iggy"') do (
   > con echo The Four Stooges are %%a, %%b, %%c, and %%d.
) 
```

（解释器足够智能，可以处理双引号字符串中的双引号个数是偶数的情况，但为了清晰起见，当字符串中包含任何双引号时，我总是使用关键字并将整个输入用单引号括起来。）

这个 `for /F` 命令将以下内容写入控制台：

```
The Four Stooges are Larry, Moe, Curly, and "Iggy".
```

（可怜的 Shemp，大家都忘了 Shemp。）

#### 命令输入

你刚刚学会了在使用 `usebackq` 和字符串输入时使用单引号，因此你不能再用它们来括起命令。但是，这种通用语法允许你将关键字与命令作为输入一起使用：

```
for /F "usebackq [`suboptions`]" %%`variable` in (``command``) do `command`
```

在某些字体中，括住命令输入的两个字符可能看起来像单引号，但它们是全新的字符。

这让我们回到那个悬而未决的问题，关于文本 usebackq 或 *use back quote* 的含义。这个名称源于那些弯曲的单引号，它们把命令括起来，实际上这些单引号更准确地说是反引号（或称为反撇号）。反引号的键在大多数键盘上位于 TAB 键的上方和数字 1 键的左侧。这个键有双重功能，按住 Shift 键可以输入波浪号。它被 relegated 到键盘的底层区域，因为大多数人几乎从不使用它，但它是 Batch 编程者的一个重要键。

以下 for /F 命令是功能等效的；第一个模仿了前一节的一个命令，第二个使用了关键字和反引号：

```
for /F "tokens=*" %%f in ('dir C:\Batch\*.txt /B') do break
for /F "usebackq tokens=*" %%f in (`dir C:\Batch\*.txt /B`) do break 
```

第一行支持命令中可能包含反引号的情况，而你会使用第二行—带有 usebackq 关键字的语法—当命令可能包含单引号时。

#### 何时使用 usebackq

你可以在有或没有 usebackq 的情况下实现每种类型的输入，那么应该什么时候使用这个关键字呢？简单来说：无论何时可能，我都会对文件集和命令输入使用 usebackq，对于字符串输入则不使用。

用双引号括起输入能够提供最大的灵活性，并且应该在可能的情况下使用。它支持输入中嵌入空格和许多可能需要转义的字符。因此，在处理文件集时，我使用双引号和 usebackq，而在处理字符串时，我使用双引号并省略该关键字。

当输入是一个命令时，双引号不会参与计算。有些人可能会跳过关键词来节省一些按键，但我使用 usebackq 关键字和反引号将输入括起来，原因有两个。首先，虽然单引号和反引号在命令中都不太常见，但反引号更不常见。更重要的是，当你看到单引号时，你会立刻问自己输入是字符串还是命令；而反引号消除了所有的歧义，它就是一个命令。

如果你实施我的建议，最终结果是任何查看你 for /F 命令的人都能够从输入中推断出很多信息。如果它被反引号括起来，那就是一个命令；如果它被双引号括起来，焦点就转移到了 usebackq 上。如果存在，那输入就是一个文件集；如果没有，那它就是一个字符串。还有三种形式在“蓝月亮”时可用，但你会比看到两次满月还要少见到包含双引号的输入字符串或包含反引号的输入命令。

关于 usebackq 的最后一个提示，如果你觉得这个关键字还不够难懂，q 是可选的。你可以用它的同义词 useback 替换本章代码示例中出现的每一个 usebackq 实例。我通常支持减少按键次数，但这样做会在已经对许多人来说难以理解的东西上加上一层面纱。

### 实际应用

读取文件的能力，以及将字符串和命令输出当作文件来处理的能力，具有许多应用。真正理解 for /F 命令可以接受的不同类型的输入，将使你能够提出富有创意的解决方案，解决一些曾经看似难以克服的问题。

#### 仅处理文件夹中的大文件

在第十七章中，我探讨了一个应用程序，该程序将多个文件传递到一个 bat 文件中逐个处理。在这个例子中，我们仍然会逐个处理文件，但我们不再使用参数列表，而是处理某个特定文件夹中的所有*.txt*文件。为了让它更有趣一点，我们只处理大文件，定义为至少 100KB 大小的文件。

你可以将 dir 命令作为输入传递给 for /F 命令，前提是使用 usebackq 关键字并将命令放入反引号中。裸格式选项/B 会生成一个没有头部的干净文件列表，非常适合这个目的，但使用这个选项时会丢失文件大小，因此我们暂时放弃这个想法。

然而，不使用/B 选项会带来其他挑战。文件的日期和时间会被列出，并且还会有头部和尾部记录。你需要使用每个文件的大小来评估它是否足够大以进行处理，但显示的文件大小中的恼人逗号会成为一个麻烦。

在第十三章中，我提到过 dir 命令的/-C 选项会抑制逗号，但要弄清楚如何解析其输出中的内容，你需要查看一个示例。除非你拥有比我更为详细的记忆，否则构建任何复杂的 for /F 命令时，内嵌命令的执行是一个必不可少的步骤，该内嵌命令位于反引号中，你需要执行它并检查其输出。以下是命令，其中 workDir 是相关文件夹：

```
dir %workDir%\*.txt /-C
```

它可能生成如下内容：

```
 Volume in drive C is OS
 Volume Serial Number is 2E6D-DBF0

 Directory of C:\Batch

12/25/2011  12:42 PM            538346 Big.txt
11/24/2011  05:22 PM             17234 Little.txt
09/05/2011  10:43 AM                10 Wee Tiny.txt
07/04/2011  07:22 PM           1864408 Wicked Big.txt
               4 File(s)        2419998 bytes
               0 Dir(s)    146181152768 bytes free 
```

这里有很多内容需要解析，但通过这些数据，你可以构建剩余的 for /F 命令。你关注的是四个详细记录，但包括空记录在内的五个头部记录，你需要通过 skip=5 子句跳过它们。

接下来，你需要找出找到与文件大小和名称对应的标记的最佳方法。空格是默认的分隔符之一，在这里效果很好，但请注意，如果你想从数据中提取月份、日期、年份、小时或分钟，你会使用一个定义了正斜杠、冒号和空格的分隔符集的 delims 子句。由于空格是分隔符，你必须戴上解释器的帽子，寻找以空格为分隔符的标记。日期是第一个标记，时间由接下来的两个标记组成；由于内嵌的空格，上午/下午（AM/PM）成为第三个标记。因此，第四个标记是文件大小，其余数据是文件名。

为了表示大小，你将使用 `%%s` 作为 `for` 变量，这意味着 `%%t` 将是文件名及扩展名。（如果你使用 `%%e` 作为大小，那么 `%%f` 就变成了文件。）

可能会有诱惑认为文件名是第五个令牌，但文件名中可能包含空格，任何空格都会将其分隔成另一个令牌。幸运的是，文件名出现在数据的末尾，这意味着 `tokens=4*` 子句会将其分配为两个令牌。第四个令牌是文件大小，由于有星号，其余数据即文件名则成为第五个令牌。

你还没有完成，但可以将 `for /F` 命令的主要结构组合起来。这里讨论的所有内容都在这里，尤其是反引号中的 `dir` 命令：

```
for /F "usebackq tokens=4* skip=5" %%s in (`dir %workDir%\*.txt /-C`) do (
```

在调用处理大文件的逻辑之前，你需要处理两个 `if` 命令。第一个简单地验证文件大小 `%%s` 是否大于或等于 100000。`for /F` 命令允许你跳过头部记录，但尾部记录仍然会影响结果，因此你必须灵活处理。在 `dir` 命令的输出中，注意到两个尾部记录的第四个令牌是字节数，这肯定不适用于你感兴趣的详细记录。因此，你需要一个第二个 `if` 命令，通过检查同一个 `%%s` 变量来过滤掉这两条不需要的记录。

现在你可以将它们组合起来了：

```
for /F "usebackq tokens=4* skip=5" %%s in (`dir %workDir%\*.txt /-C`) do (
   if %%s geq 100000 (
      if /i "%%s" neq "bytes" (
         call :ProcessBigTxtFile "%workDir%\%%t"
)  )  ) 
```

如果 `workDir` 变量已填充为文本文件的工作目录，那么此代码就可以处理由 `%%t` 表示的大型文本文件了。此外，可能会觉得很奇怪，`%%s` 被用于数值和字母比较。在第四章中，我提到过，数值和字母值是有顺序的；字母被认为大于数字，因此字节数大于等于 100000 的条件子句总是为真。如果它一直为假，那么你本可以省略第二个 `if` 命令。

总是存在多个解决方案，看到以不同方式思考问题是一件很棒的事情。我打算再次尝试 `dir` 命令的 `/B` 选项。我知道它不会提供文件大小，但也许有其他方法可以获取它。我在第十七章中展示了如何使用修饰符来获取文件大小，使用不带选项的 `for` 命令。也许两个 `for` 命令会比一个更好。

我将从这个解决方案开始，它实现了嵌套的 `for` 命令：

```
for /F "usebackq tokens=*" %%f in (`dir %workDir%\*.txt /B`) do (
   for %%g in ("%workDir%\%%f") do (
      if %%~Zg geq 100000 (
         call :ProcessBigTxtFile %%g
)  )  ) 
```

外部 `for` 命令具有 `/F` 选项，并使用 `usebackq` 关键字，同时它将 `%%f` 用作变量。它的输入是一个带有 `/B` 选项的 `dir` 命令，并用反引号包裹。`tokens=*` 子句确保无论文件名中是否有空格，代码都会将每个文件名传入代码块，在这里我会立即为其添加路径，用双引号括起来，并将其作为输入传递给内部 `for` 命令。

这个内部命令没有使用 /F 选项，它使用%%g 作为变量，但除了%%f 之外，任何其他变量名都可以是良好的格式。我通过使用修饰符%%~Zg 来推导文件大小；如果文件足够大，call 命令会调用处理大文件的例程。

嵌套的 for 命令与非嵌套命令的行为差别不大，但一个重要的点是每个命令所选的 for 变量的字母字符。我本可以为两个命令都使用%%f，但我总是使用唯一的值，因为这样更清晰、更易读。此外，外部变量在内部命令中仍然可用，但前提是它没有被内部变量覆盖。

为了防止 for 变量冲突，它们不仅要不同，而且我还建议错开它们，以确保任何隐含的变量不会发生冲突。例如，如果外部命令从输入数据中提取三个标记并使用%%f 作为其 for 变量，那么%%g 和%%h 也应当避免在内部命令中使用。

你已经看到了两个解决同一问题的方法。一个使用了更复杂的命令来解析数据，另一个则使用了嵌套命令。哪种方式更好是有争议的，但无可争议的是，和其他语言一样，所有问题都有多种可能的解决方案。永远不要满足于一个解决方案。

#### 全局文本替换

想象一下，你维护一个旧系统，运行着许多可执行文件，其中许多文件存放在一台旧服务器上。团队正在退役这台服务器*\\OldServer*，并用恰如其分地命名为*\\NewServer*的新服务器替换它。计划是将旧服务器上的每个文件迁移到新服务器，并保持相同的目录结构。

幸运的是，你的团队明智地实施并遵循了一致的命名规范，定义每个程序的变量都以 _pgm 开头。你控制其中一些变量的创建，但不是所有变量。你永远无法追踪到所有变量，但为了顺利切换到新服务器，你需要实时调整所有这些变量——也就是说，你需要将旧服务器的文本更改为新服务器的文本，而且你甚至无法获取所有变量名的列表。

第一个需要解决的问题是检索给定执行中的变量名列表。在第二章中，你学习了以下命令会生成所有当前活动的变量列表，这些变量名以 _pgm 开头：

```
set _pgm
```

如果仅设置了四个这样的变量，以下可能是命令的结果：

```
_pgmDBMrge=\\OldServer\Executables\DatabaseMerge.exe
_pgmSTElse=\\NewServer\Executables\SomethingElse.exe
_pgmTtlDiff=\\ThirdServer\Progs\TotallyDifferent.exe
_pgmVldtn=\\OldServer\Executables\Validation.exe 
```

这些中的第一项和最后一项需要调整，第二项已经使用了新文本更新，第三项有一个完全不同的目录结构。你需要更新其中两个，而不改变另外两个。解决方案包括将前一个 set 命令作为 for /F 命令的输入。代码块将接受变量名和对应的值，并用更新后的文本重置该变量。

以下 for /F 命令是其中一种解决方案：

```
for /F "usebackq tokens=1,2 delims==" %%p in (`set _pgm`) do (
   set tempPgm=%%q
   set %%p=!tempPgm:\\OldServer\=\\NewServer\!
) 
```

你将命令 set _pgm 放在反引号之间，并在 for /F 命令中使用了 usebackq 关键字。使用 dir 命令作为输入时，我强调了理解其输出的重要性，同样的道理也适用于 set 命令。查看四行示例输出，它们的共同点是变量名后面跟着一个值，两者之间用等号隔开。因此，你通过 delims==子句按等号进行分隔，并使用 tokens=1,2 子句提取两个令牌。for 变量%%p 是变量名，意味着%%q 是它的值。

这段代码仅用两个命令就能重置代码块中的变量。你将输入变量%%q 的原始值赋给临时变量 tempPgm。第二个命令将变量名%%p 重置为该值，并将*\\OldServer*替换为*\\NewServer*。注意，由于 tempPgm 在代码块中被设置并使用，因此必须使用感叹号来解析该变量的当前值。

这个逻辑会更新所有具有特定前缀的变量，同时忽略没有该前缀的变量。基于这一原则还有很多其他应用。你可以通过用一个命令 set %%p=替换代码块中的代码，并使用默认的 tokens 子句，来将所有类似名称的变量重置为 null。

### 文档说明

我对不同形式的 for /F 命令的语法做了一些调整，所以我将把你在这里看到的与帮助文档中的内容进行比较，并解释我的理由。首先，这是你通过运行 for /?命令可以看到的内容：

```
FOR /F ["`options`"] %`variable` IN (`file-set`) DO `command` [`command-parameters`]
FOR /F ["`options`"] %`variable` IN ("`string`") DO `command` [`command-parameters`]
FOR /F ["`options`"] %`variable` IN ('`command`') DO `command` [`command-parameters`]

    or, if usebackq option present:

FOR /F ["`options`"] %`variable` IN (`file-set`) DO `command` [`command-parameters`]
FOR /F ["`options`"] %`variable` IN ('`string`') DO `command` [`command-parameters`]
FOR /F ["`options`"] %`variable` IN (``command``) DO `command` [`command-parameters`] 
```

我列出了我几乎专门使用的三种形式，然后是我不常使用的几种：

```
for /F "usebackq [`suboptions`]" %%`variable` in ("`file-set`") do `command`
for /F ["`suboptions`"] %%`variable` in ("`string`") do `command`
for /F "usebackq [`suboptions`]" %%`variable` in (``command``) do `command`

for /F ["`suboptions`"] %%`variable` in (`file-set`) do `command`
for /F "usebackq [`suboptions`]" %%`variable` in ('`string`') do `command`
for /F ["`suboptions`"] %%`variable` in ('`command`') do `command` 
```

首先，我比大多数程序员更喜欢小写字母。而且，我将["options"]子句替换为["suboptions"]。这个 for 命令已经有一个选项/F，我认为没有必要再引入另一种类型的选项，所以我选择了*suboptions*这个术语，但这两个调整都是表面上的。

我去掉了每行末尾的[command-parameters]，因为这只是说明命令可能有参数，但这显而易见，不值得浪费额外的篇幅。为了真正正确地展示，我本可以显示额外的可选命令以及定义可能代码块的可选括号。为了让文档更具可读性，它必须保持一定的模糊性，因此我决定让它简洁明了。

另一个区别是，我对 for 变量%%variable 使用了两个百分号，而不是一个。帮助文档显示了如何从命令提示符执行命令，唯一的区别是它调用的是单个百分号。这是一本关于 bat 文件的书，而不是命令提示符，而且命令通常过于复杂，不适合在提示符下输入。

我明确地在使用 usebackq 关键字的形式中展示它，而帮助文档将其放在一个奇怪的标题后面。为了适应这一变化，我还将其他子选项放入方括号中，因为它们仍然是可选的。

最后的区别在于第一个形式，这也是最关键的一点。在研究这本书时，我感到非常震惊，发现两个使用文件集作为输入的形式在帮助文档中是相同的。添加 usebackq 关键字意味着现在双引号可以包含输入内容。从技术上讲，它们并不一定需要存在，但这不正是使用 usebackq 的意义所在吗？我很难想出在使用该关键字时我不想使用双引号的情况，因此我在文档中包含了它们，但请理解它们是可选的。

使用对你有意义的形式。更好的是，选择其中一个形式开始（我希望是我的形式），然后在你自己的 for 命令文档中进行构建。

### 拆解任何 for 命令

for 命令，尤其是跟随/F 选项时，可能会让人感到压倒性。你可以在仅几行代码中加入相当多的逻辑。当你遇到这样的构造时，可能很难准确知道从哪里开始分析。我多年来已经拆解了许多这样的命令（其中不少是我自己写的），每当我看到一个以 for 开头的命令时，我都会使用这些问题和步骤来弄清楚代码在做什么：

1.  什么是选项？是没有选项、/D、/R、/L 还是/F？

2.  根据选项，它使用的是什么类型的输入？如果没有选项，那么输入是文件、文件集还是值的列表？如果是/D 选项，期望输入为一个目录。如果是/R 选项，期望对一个或多个文件进行递归处理。如果是/L 选项，查看定义迭代循环的三个数字。在这四种情况下，按照输入的逻辑步骤通过代码块。

但是，如果选项是/F，那么你才刚刚开始拆解。命令使用的是什么类型的输入？如果没有引号，输入是文件集；如果是反引号，则是一个命令。如果是双引号，usebackq 将其转换为文件集；否则是一个字符串。如果是单引号，usebackq 将其转换为字符串；否则是一个命令。

3.  确定输入贡献了什么。文件集是否包含通配符？大概处理了多少个文件？文件或文件中的数据是什么类型？该字符串是硬编码的还是变量？命令做了什么，输出是什么？大致创建了多少行输出？数据的稳定性如何——也就是说，会有头部或尾部数据吗？

4.  检查子选项，并确定输入是如何被处理的。根据 tokens 和 delims 子句（或它们的默认值），会创建多少个标记，它们将如何从输入中填充？是否有记录通过 skip 或 eol 子句被丢弃？

5.  识别 for 变量，可能是 %%i，并确定与之相关的输入数据及其后续变量，可能是 %%j 和 %%k。

6.  检查代码块。确定 for 变量以及任何隐含变量的引用方式。是否有文件被复制、重命名、删除或以其他方式处理？

也许这些问题和步骤看起来令人难以应对，但为了展示它们的简单性，让我们拆解一些代码。某个刚认识的在线用户给了你这个命令，告诉你它会备份一些文件。只需要运行它：

```
for /F "usebackq tokens=1,3" %%x in (`xcopy * %userprofile%\%random%\`) do (
   if "%%y" neq "copied" > %%x echo This file has been randomly moved.
) 
```

但在执行之前，你应该先拆解它。使用之前的六个步骤：

1.  选项是/F。

2.  反引号包裹输入，所以它是一个命令。

3.  xcopy 的源参数是星号，这意味着该命令将当前目录中的所有文件复制到一个奇怪命名的文件夹中，使用了两个伪环境变量，我还没有讨论（但会在第二十一章中讨论）。如果此命令成功复制五个文件，输出将是五个源文件的列表，后面跟着一条记录，写着：5 个文件已复制。

4.  基于 tokens 子句和缺少 delims 子句，该代码提取了从空格分隔输入中提取的第一个和第三个标记。对于大部分输出，第一个标记是源文件的完整路径和名称，假设文件名中没有嵌入空格，第三个标记为空。对于输入的最后一行，或者说记录的结尾，第一个标记解析为已复制的文件数量，而第三个标记是“copied”这个词。

5.  %%x 是路径和文件名，直到输出的最后一行，当它变成已复制的文件数量时。%%y 完全为空（假设没有嵌入的空格），在处理输出的最后一行时解析为“copied”。到目前为止，一切正常。

6.  切换到代码块，if 命令过滤掉最后一条记录，其中 %%y 解析为特定文本，这意味着每个被复制的文件，echo 命令都会将其整个内容替换成看似模糊的威胁。

这看起来有点可疑。代码将当前目录中的所有文件隐藏起来，包括假设它在当前目录中的 bat 文件本身，放进一个随机命名的文件夹中。然后它擦除并替换每个源文件的内容，替换成一些文本。即使带有嵌入空格的文件名可能会被保留下来也无济于事。

因为你现在知道如何拆解一个 for 命令，所以你没有被这个 bat 文件欺骗。你没有执行代码，但已经推断出它是恶意代码——一个 bat 病毒。

### 概要

在这一章中，你了解了 for 命令的文件读取选项，并且学到了它不仅仅是读取文件。输入可以是文件、字符串，或者是命令的输出，每种都有不同的语法。我详细介绍了如何操作输入数据、创建标记，并在命令的代码块中使用这些标记的语法。我还通过一些现实世界的问题展示了这些功能，最后讨论了如何拆解这个重要的命令。

在下一章中，我将通过考察一些高级技巧来结束第二部分，这些技巧要么解决与使用 for 命令相关的问题，要么解决 for 命令使用中的问题。
