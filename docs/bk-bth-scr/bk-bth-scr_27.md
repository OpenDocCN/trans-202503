<hgroup>

## 24 文本字符串搜索

</hgroup>

![](img/chapter.jpg)

在前面的章节中，你已经看到了多种搜索方法，例如查找文件、目录，甚至是丢失的磁盘空间。在本章中，我将讨论多种文本字符串搜索方式以及这些搜索的应用场景。你将看到单个单词的搜索、从多个可能单词中选择一个的搜索、以及包含多个单词的文字字符串搜索。另一种搜索方式将查找一个单词列表，并且只有当每个单词都被找到时，搜索才算成功。我将演示如何对文件、多个文件以及其他字符串执行这些搜索。

为了执行这些搜索，我将比较并对比两种非常不同的技术。一种更加灵活，另一种执行速度更快，因此它们各自都有极高的实用价值。我还将讨论正则表达式，并展示如何利用它们构建一些非常强大的 Batch 搜索。

### 在文件中搜索

为了演示如何在文件中搜索字符串，第一个要求是有一个文件可供搜索。在实际应用中，你可能会有一个包含成千上万条记录的日志文件，其中夹杂着许多客户端信息；搜索客户端名称可以提取出所有相关条目，从而生成一个更有针对性的报告。每日报告文件的结尾可能每个都有总计；在这些报告文件中搜索 Totals 文本可以提取出每个报告文件中的所有尾部记录。更好的是，你还可以搜索满足文件掩码的所有文件，也许是针对上个月或去年的文件。

在本次演示中，我将使用一个更小的（也希望更有趣的）输入文件，一个名为 *12Movies.txt* 的文件，里面包含了一份跨越三十年的电影名单，按照上映日期排列。仔细观察这些标题，看是否能发现任何共同点。以下是该文件的完整内容：

```
Here Come the Littles
Little Shop of Horrors
Big Trouble in Little China
Big
The Little Mermaid
The Big Lebowski
Stuart Little
Big Momma's House
My Big Fat Greek Wedding
Little Miss Sunshine
Big Hero 6
The Big Short 
```

其中一些是很棒的电影，有些则一般，还有一些我从未看过，但我们将在本章的多个示例中使用这个文件。

#### 一个简单的字符串

`findstr` 命令是 Batch 中查找一个或多个文件内文本字符串的主要工具。尽管命令名较为简短，但程序员通常称其为 *find string* 命令。你将很快看到这个命令的多功能性，但我将从一个没有选项的简单命令开始，该命令搜索输入文件中的 Little 一词。第一个参数是搜索字符串，第二个参数是要搜索的文件：

```
findstr Little C:\Batch\12Movies.txt
```

该命令会将包含六个连续字母的每一条记录从文件中写入 stdout：

```
Here Come the Littles
Little Shop of Horrors
Big Trouble in Little China
The Little Mermaid
Stuart Little
Little Miss Sunshine 
```

注意，尽管返回的第一个标题包含了搜索词后缀的字母 "s"，但解释器仍然返回了该标题；这个命令并不是在搜索完整的单词。此外，这个特定的命令会将伪环境变量 errorlevel 设置为 0，表示它找到了至少一个匹配的搜索字符串。如果没有找到任何匹配项，errorlevel 的值会变成 1。

通常，编码人员会以三种方式处理此命令的输出。如果你仅仅想知道是否存在一个或多个记录，你只需要检查 errorlevel 并继续。其他情况下，你可以将写入标准输出的返回记录列表重定向到控制台或输出文件，以供后续使用或查看。最后一种用法是通过程序化方式处理每一个返回的记录，你可以通过将 findstr 命令作为输入传递给 for /F 命令来实现。在接下来的大部分示例中，我会描述写入标准输出的内容，但请理解，这些输出有许多不同的用途。

现在，让我们对之前的命令做一个微小的修改，将搜索字符串全部改为小写：

```
findstr little C:\Batch\12Movies.txt
```

这个命令没有返回任何结果，因为 findstr 命令默认是区分大小写的，而且文件中每个单词的实例都以大写字母 L 开头。另一个有趣的结果是，由于命令没有返回任何内容，errorlevel 的值为 1。通常，区分大小写的搜索正是你想要的；但很多时候，正是你不想要的。

#### 自定义选项

幸运的是，这个命令有许多选项可以自定义每次搜索。我将在本章中讨论其中的许多选项，从一些改变 findstr 命令行为的简单但强大的选项开始。

就像 /i 选项启用 if 命令的不区分大小写功能一样，同样的选项也适用于 findstr 命令。（如第四章中所提到的，我使用小写字母表示此选项，但 /I 也有效。）注意该选项和奇怪的大写方式 tHE：

```
findstr /i tHE C:\Batch\12Movies.txt
```

我并不是推荐这种大写规则，但我这样做是为了清楚地展示解释器返回的四个标题，包含这三个字母，并按此顺序出现，不论大小写，正如你在输出中看到的：

```
Here Come the Littles
The Little Mermaid
The Big Lebowski
The Big Short 
```

另一个有用的选项是 /E。使用它时，命令只返回搜索字符串位于记录*末尾*的记录。考虑这个命令：

```
findstr /i /E little C:\Batch\12Movies.txt
```

唯一返回的标题是*Stuart Little*。另外，请注意此命令使用了多个选项进行进一步的自定义；通过 /i 和 /E 选项，它进行不区分大小写的搜索，查找以搜索字符串结尾的记录。

类似地，/B 选项仅返回搜索字符串位于记录*开头*的记录。你还可以将此选项与 /i 以及 /N 选项组合使用，/N 选项会将*行号*添加到返回的记录前，行号与记录之间用冒号分隔：

```
findstr /i /B /N big C:\Batch\12Movies.txt
```

这个 findstr 命令返回以下四个标题，所有标题都以大写字母开头，不区分大小写，并在前面加上相应的行号：

```
3:Big Trouble in Little China
4:Big
8:Big Momma's House
11:Big Hero 6 
```

另一个有用的选项是 /V，它会否定搜索逻辑。以下命令与之前的命令相同，除了包含了 /V 选项：

```
findstr /i /B /N /V big C:\Batch\12Movies.txt
```

之前返回的四条记录现在已从输出中消失，取而代之的是不符合搜索标准的另外八条记录。行号仍然显示在每条记录的前面，因为使用了/N 选项，但/V 选项改变了逻辑，使得输出仅包含所有*不*以“big”开头的记录，大小写不敏感：

```
1:Here Come the Littles
2:Little Shop of Horrors
5:The Little Mermaid
6:The Big Lebowski
7:Stuart Little
9:My Big Fat Greek Wedding
10:Little Miss Sunshine
12:The Big Short 
```

这些选项中的最后一个是/X，它只查找完全匹配搜索字符串的记录：

```
findstr /i /X big C:\Batch\12Movies.txt
```

这个命令返回一个标题，即汤姆·汉克斯的电影*Big*。

/i、/B、/E 和/N 选项中的单字符代码代表它们的功能，但/V、/X 等选项的功能则不那么明显。在使用 findstr 命令时，计划充分利用帮助功能。

#### 多个词

两个词的搜索有多种变体（当搜索字符串包含嵌入的空格时）。我们可以搜索包含任意一个词、两个词都包含，或者这两个词按空格（或空格）分隔的字面字符串的所有记录。findstr 命令可以处理所有这些变体，尽管搜索两个词都存在的变体需要做一些额外的工作。我们可以将这些解决方案推展到搜索多个词的情况。

##### 列表中的任何词

与单词搜索字符串不同，以下的 findstr 命令将两个词放在双引号中。如果你以前没见过这种情况，你可能期待它返回所有包含“the”后跟“big”的标题，但事实并非如此：

```
findstr /i "the big" C:\Batch\12Movies.txt
```

实际上，双引号将一组以空格分隔的搜索字符串括起来。解释器会在文件中的每条记录中搜索该搜索字符串集合中的每个词，返回至少匹配一个的所有记录。此命令返回九个标题；该列表中的所有电影除三部外，包含了单词“the”或“big”，或者两者都有。

向搜索字符串集合中添加三个特定的词将返回所有 12 个标题：

```
findstr /i "the big art hop sun" C:\Batch\12Movies.txt
```

搜索字符串集合中的另外三个词分别是*Stuart*、*Shop*和*Sunshine*，而每个词都出现在之前缺失的标题中。尽管如此，如果你还没有注意到，双词搜索字符串集“big little”能更高效地返回文件中的每条记录。

##### 一个字面值字符串

通过简单修改，你可以将搜索命令从查找两个词之一，改为查找单一字符串：the，后跟一个空格和 big。/C 选项定义了一个字面值搜索字符串，当搜索字符串包含至少一个空格时，必须使用此选项。

你之前已经看到过对*12Movies.txt*的大小写不敏感的搜索。在这个例子中，我在现在被双引号括起来的字面搜索字符串前插入了/C:选项：

```
findstr /i /C:"the big" C:\Batch\12Movies.txt
```

该 findstr 命令仅返回这两个标题：

```
The Big Lebowski
The Big Short 
```

这两个标题恰好以该文本开头，但如果该字面字符串出现在标题后面，记录也会出现在输出中。

字面搜索字符串不必包含完整的单词。以下命令

```
findstr /i /C:"y big fat greek wed" C:\Batch\12Movies.txt
```

返回的标题是*My Big Fat Greek Wedding*。

##### 列表中的所有单词

在*12Movies.txt*文件中，只有一个电影标题包含了两个特定的词，Big 和 Little。不幸的是，findstr 命令无法通过单次搜索同时找到包含这两个词的所有记录，但凭借一些巧妙的技巧，你可以将两个 findstr 命令结合起来完成任务：

```
findstr /i big C:\Batch\12Movies.txt | findstr /i little
```

这通过管道字符将一个 findstr 命令的输出传递给另一个 findstr 命令（这是在第十二章中介绍的管道技术的另一个应用）。第一个 findstr 命令使用*12Movies.txt*文件作为输入，执行不区分大小写的“big”字搜索。正如你现在已经看到的，这个命令本身会将七个标题写入标准输出。

但这并不是一个简单的命令。解释器将输出（那七条记录）写入一个无名的临时文件，并将其通过管道传递到第二个 findstr 命令，该命令执行不区分大小写的“小”字搜索。请注意，在第二个命令中我没有定义输入文件。它不需要，因为它的输入是第一个 findstr 命令的输出。如下所示的输出表明，在包含“big”这个词的七个标题中，只有一个也包含了“little”这个词：

```
Big Trouble in Little China
```

最终结果是一个只返回包含两个字符串的记录的搜索。

中间文件丢失了，但如果你希望保留事件的审计轨迹，可以将输出重定向到一个文件中。然后你可以将该文件的类型命令通过管道传递到第二个 findstr 命令：

```
findstr /i big C:\Batch\12Movies.txt > C:\Batch\BigMovies.txt
type C:\Batch\BigMovies.txt | findstr /i little 
```

这两个命令找到了相同的标题，但现在*BigMovies.txt*包含了第一次搜索字符串找到的七条记录。

你可以使用这种技术与任意数量的搜索字符串。以下命令再次找到唯一的标题，因为它包含了所有四个搜索字符串，即使第三个词只是标题中一个单词的一部分：

```
findstr /i big C:\Batch\12Movies.txt | findstr /i little ^
                                     | findstr /i chi ^
                                     | findstr /i trouble 
```

这种技术最难的部分是使其可读。在这个例子中，我将除了第一个之外的所有搜索字符串通过在多行上继续命令并使用尾部的插入符号来排列。

### 搜索多个文件

到目前为止，我已经使用单一的输入文件执行了 findstr 命令，但你可以通过一次调用搜索多个文件。该命令接受多个文件作为额外的参数，并且也支持文件掩码。以下命令将在我们一直使用的文件中以及满足两个文件掩码之一的任何文件中查找不区分大小写的 miss 文本：

```
findstr /i miss C:\Batch\12Movies.txt C:\Flicks\*Movies.txt C:\Movies\*
```

这个例子引发了一个关于输出的问题，因为之前的调用只是将每个找到的记录写入标准输出。当搜索单一文件时，这种方法很好用，但当搜索多个文件时，这样的输出会让你无法知道每条输出记录的来源文件。解释器聪明地检测到这种差异，并在找到的记录中输出路径和文件名：

```
C:\Batch\12Movies.txt:Little Miss Sunshine
C:\Movies\Some Other File.dat:  Will findstr miss this record?
C:\Movies\Some Other File.dat:  Sorry, that was misserable. Sorry again. 
```

命令如预期一样在 *12Movies.txt* 文件中找到了 *Little Miss Sunshine*，它还在两个符合尾部文件掩码的文件的记录中找到了该文本，从而得到了输出的最后两行。格式化效果不尽如人意。尽管有冒号分隔符，但很难看清文件名的结尾和记录的开始。当将输出写入控制台时，/A 选项会以你选择的颜色方案突出显示路径和文件名，但当你将输出重定向到文件或管道到另一个命令时，这显然不会有任何作用。

冒号作为分隔符是一个不太理想的选择，因为它通常是驱动器字母后路径的一部分，就像在这个实例中一样。如果你想解析这些数据，可以将 findstr 命令的输出作为输入传递给 for /F 命令，并以冒号为分隔符。但鉴于此输出，路径和文件名会跨越前两个标记，实际记录位于第三个标记。一个不能出现在路径或文件名中的分隔符，例如管道符，会是一个更好的选择，但你仍然可以通过稍作额外工作来解析这些数据。

/S 选项将搜索范围扩展到包括子目录。我经常与通配符一起使用它来搜索目录树中的所有文件或目录树中某种扩展名的所有文件，但在下面的示例中，我使用了一个显式的文件名：

```
findstr /i /S /N miss C:\Batch\12Movies.txt
```

解释器在 *C:\Batch\* 及其所有子文件夹中搜索名为 *12Movies.txt* 的文件。然后，它会在每个找到的文件中搜索包含搜索字符串的记录。

此外，请注意，我重新引入了之前提到的 /N 选项。现在输出包含路径和文件名、行号（两侧用冒号分隔），以及包含搜索字符串的完整记录：

```
C:\Batch\12Movies.txt:10:Little Miss Sunshine
C:\Batch\Subfolder\12Movies.txt:2:The misspelling of miserable was painful.
C:\Batch\Subfolder\12Movies.txt:3:It should be a missdemeanor. 
```

两个目录中的两个文件有相同的名称，但该命令的结果表明它们的内容截然不同。

警告

*当 findstr 命令未找到符合文件掩码的文件时，它会向 stderr 输出错误信息，说明无法打开特定掩码。如果你已将 stdout 和 stderr 都重定向到跟踪文件中，命令会将错误信息与期望的输出混合。如果掩码可能无效，使用 2> nul 语法抑制 stderr 预期了 batveat 的可能性，并清理了输出：*

```
findstr /i miss C:\Batch\12Movies.txt C:\NotADir\* 2> nul 
```

> *解释器返回它在有效文件中找到的所有记录，但它会将关于不存在目录的错误信息发送到 nul 文件中。此技巧甚至适用于已将 stderr 重定向的例程或 bat 文件中。*

### 辅助搜索文件

当你的搜索变得更加复杂时，可以通过两个辅助文件更容易地管理它们，一个包含搜索字符串列表，另一个包含要搜索的文件列表。

#### 搜索字符串文件

我之前提到过，你可以通过将多个以空格分隔的搜索字符串括在双引号中来搜索列表中的任何字符串。这对于少数几个字符串非常有效，但当列表足够长，导致命令变得杂乱时，你可以使用 findstr 命令并通过一个包含搜索字符串列表的文件来执行。你可以通过在/G 选项后输入文件名来定义此文件，文件名与选项之间用冒号分隔。以下示例执行区分大小写的搜索，查找“小”和它的四个同义词，你可以很容易地添加更多：

```
>  SearchStr.temp echo Little
>> SearchStr.temp echo Small
>> SearchStr.temp echo Short
>> SearchStr.temp echo Minuscule
>> SearchStr.temp echo Tiny
findstr /G:SearchStr.temp C:\Batch\12Movies.txt
del SearchStr.temp 
```

我正在构建一个包含硬编码字符串的临时文件，但它们可以很容易地是变量，甚至可以来自用户输入，而且因为这是一个临时文件，我在完成后会将其删除。输出结果包含所有至少包含其中一个这五个字符串的记录，在这个例子中包括六个包含“小”的标题，再加上*《大空头》*，而其他三个搜索字符串没有找到任何内容。

这种技术在搜索标准每次执行时都可能变化时特别有用。你可以在代码中动态生成一个文件，甚至手动更新它，然后可以运行相同的代码并得到不同的结果。

#### 待搜索的文件列表

更进一步，我将使用刚刚创建的文件，里面包含搜索字符串的列表，并与另一个包含待搜索文件列表的文件一起使用。这个*文件列表（FOF）*是通过 findstr 命令和/F 选项来定义的。类似于/G 选项，文件在选项之后，使用冒号分隔：

```
findstr /i /G:C:\Batch\SearchStrings.txt /F:C:\Batch\SearchFiles.txt
```

奇怪的是，只有在使用/G 选项时，才能使用/F 选项。

如果要搜索的文件列表只有在执行时才知道，你可以在运行时动态构建这个 FOF 文件。当你无法轻松定义一个文件掩码时，这种技术也非常有用。例如，如果你计划搜索多个文件集（可能是生产文件集或测试文件集，其中部分文件名带有日期戳），这些选项是理想的选择。你还可以使用用户输入的数据来创建搜索字符串文件，可能是一个客户名称的列表。然而，如果待搜索的文件列表比较固定，你也可以使用一个静态文件。

### 搜索字符串

大多数编译语言都包含一种方法，返回一个布尔值，指示一个字符串是否在另一个字符串中部分或完全包含，因为这种需求在各种不同的情况下经常出现。在批处理文件中，你可以搜索包含路径的变量，以查找特定的节点或服务器名称，或者检查路径变量，看看它是否包含某个特定的目录。你甚至可以使用这种技术来验证用户输入，确认响应中至少包含列表中的一个单词。

查找一个字符串是否包含另一个字符串有两种非常不同的方法。Batch 的开发者设计了 findstr 命令用于搜索文件，但第一种方法将其调整为搜索字符串。第二种方法基于第五章中的文本替换语法，每种方法都有其显著的优势。

**findstr 方法**

寻找爱情可能很困难，但使用 findstr 命令，寻找“love”字符串只需要几行代码。在这个练习中，我将 aString 变量设置为两个相似的文本字符串之一，这些字符串是给计划前往亚得里亚海两个邻国的冬季旅行者的建议：

```
set aString=Bring mittens and a sweater to Croatia.
set aString=Bring gloves and a pullover to Slovenia. 
```

我将通过接下来的几个代码示例进行两次演示，变量分别设置为这些字符串，以展示完全不同的行为。

你能在这两个字符串中找到“love”吗？findstr 命令可以：

```
echo "%aString%" | findstr love
if %errorlevel% equ 0 (
   set bLove=true==true
) else (
   set bLove=false==x
) 
```

要在 aString 中搜索“love”文本，我使用了之前介绍的管道技术，唯一的区别是，我不是通过 type 命令将一个多记录的文件管道传输到 findstr 命令，而是通过 echo 命令将一个变量传输。实际上，我将变量的内容当作一个单记录的输入文件传递给 findstr 命令。最终的结果是，命令在字符串中搜索文本。

请记住，当 findstr 命令找到搜索字符串时，会将 errorlevel 设置为 0；否则，值为 1。如果是 0，代码将 bLove 布尔值设置为 true；如果不是，结果为 false。

首先，设想这个逻辑：aString 设置为克罗地亚的字符串。该字符串中没有“love”文本，所以命令返回 1，我们将布尔值设置为 false。现在，使用斯洛文尼亚的字符串进行相同的操作。该字符串中的“love”文本嵌入在三个不同的单词中——Bring g**love**s 和 a pul**love**r 到 S**love**nia。一个或多个匹配项将 errorlevel 设置为 0，因此我们将布尔值设置为 true。

还请注意，我们如何轻松地将其转换为不区分大小写的搜索：

```
echo "%aString%" | findstr /i love 
```

在搜索文件时所具有的灵活性，在搜索字符串时仍然适用。可以针对字符串的开头或结尾、否定逻辑等进行操作，这些选项在这种情况下都能完美工作。

**文本替换方法**

文本替换方法背后的思想与其执行方式一样直接。该技术将已解析的变量与去除搜索字符串后的变量进行比较。如果它们不同，则找到了搜索字符串；如果它们相同，则没有找到文本。以下代码使用此方法来确定一个字符串是否包含另一个字符串，在这个例子中是“love”，并将前一个示例中的布尔值设置为 true 或 false：

```
if "%aString%" neq "%aString:love=%" (
   set bLove=true==true
) else (
   set bLove=false==x
) 
```

不等式的左侧现在已经很基础了，已经是一个用双引号括起来的解析过的变量。if 命令将其与 "%aString:love=%" 进行比较，这是同样解析过的变量，但其中所有的 love 字符串都被替换为空值；注意，在等号和终止的百分号之间没有任何内容。结果是，如果 aString 包含至少一个 love 字符串的实例，这两个值就会不同，我们将 bLove 布尔值设置为 true；如果搜索字符串不在我们要搜索的字符串内，那么这两个值是相同的，我们将 bLove 设置为 false。

让我们用 aString 的两种可能值来执行这段代码。假设它包含克罗地亚文本，那么这两个值是相同的，因为没有找到 love 字符串，我们将 bLove 设置为 false。然而，文本替换语法通过删除 love 字符串的三个实例来改变斯洛文尼亚文本，结果是这样的混乱： "Bring gs and a pulr to Snia." 显然，这不等于原始文本，因此我们将 bLove 设置为 true。

延迟扩展使得这一技术更具通用性，允许你使用变量来表示搜索字符串和待搜索的字符串：

```
if "%stringToSearch%" neq "!stringToSearch:%searchString%=!" (
    set bLove=true==true
) else (
   set bLove=false==x
) 
```

现在，搜索字符串和待搜索字符串是变量，这使你可以在执行搜索之前，在批处理代码中确定这两个值。

在搜索字符串时，这两种方法在批处理的应用中各有其明确的作用。findstr 方法的最大优势是其灵活性，主要体现在它能够执行区分大小写的搜索，并且你可以使用前面讨论过的选项来轻松定制任何搜索。相比之下，文本替换方法本质上是大小写不敏感的，因为你无法轻易改变解释器忽略被更改文本的大小写这一事实。

文本替换方法也有它自身的优势。首先，我认为它稍微简单一些。两种方法都不复杂，但即使是带有延迟扩展的 if 命令也比通过 echo 管道传递给 findstr 更加直接。不过，它最大的优势是性能。

当你调用 findstr 命令时，实际上是在调用一个程序，*findstr.exe*，而任何程序调用都会比简单的两个变量比较涉及更多的开销。它们都会在瞬间完成，但文本替换方法发生的时间要小得多。你可能在进行少量搜索时无法察觉到这一点，但我对两种方法进行了广泛的测试，发现文本替换方法比 findstr 方法快了超过 200 倍。测试性能时需要考虑许多变量，我的测试结果也远非最终结论，但可以肯定地说，文本替换方法的一个主要优势就是速度更快。

最终分析来看，如果你的代码需要重复执行搜索，例如在一个可能包含数百甚至数千次调用的循环中，替换文本方法是更好的选择。然而，如果效率不是一个大问题，或者你需要更复杂的搜索，即便是区分大小写的搜索，findstr 方法则是更好的选择。

### 正则表达式

在本书中，我已经多次暗示，批处理语法可能是深奥且反直觉的，即使是对于那些已经编写多年代码的人来说。但在某个地方，某个持不同意见的人可能会说，“其实没那么糟”或者“我们中谁没有记住 findstr 命令的所有选项？”对这个人，我只有两个词：“*正则表达式*”或“*regex*”。

正则表达式不仅限于批处理（Batch）。许多编程语言和编辑器都将它们作为一个强大的搜索工具。通过正则表达式，你可以搜索数字值、非数字值以及非常复杂的字符模式和范围。findstr 命令的 /B 和 /E 选项允许你搜索记录的开头或结尾的文本，但正则表达式让你在一个命令中同时完成这两项工作——即，搜索一个字符串位于记录开头，另一个字符串位于记录结尾。让我们通过一些例子来看看正则表达式的实际应用。

#### 搜索任何数字

以下使用正则表达式选项的 findstr 命令（通过 /R 标记）搜索 *12Movies.txt* 文件，查找标题中至少有一个数字的所有电影：

```
findstr /R "[0-9]" C:\Batch\12Movies.txt
```

正则表达式 [0-9] 表示所有从 0 到 9 的字符，包括两端。根据我们在本章中使用的输入文件，命令返回一个标题：

```
Big Hero 6
```

如果我们处理的是一个更完整的电影列表，返回的标题可能包括 *2001: 太空漫游*、*十二怒汉*、*第 12 人* 和 *海洋的十一*，但不会包括重拍版的 *海洋的十一*。

正则表达式在搜索字符串而非文件时也非常有效。考虑以下示例，该示例使用否定逻辑（/V）与正则表达式（/R）进行搜索：

```
:TryAgain
 > con set /P reply=Enter a movie title that does NOT include a number:
 echo %reply% | findstr /R /V "[0-9]"
 if errorlevel 1 (
    > con echo Invalid response. Please try again. 
    goto :TryAgain
) 
```

该代码提示用户输入一个标题中没有数字的电影标题。如果他们输入一个典型的续集电影标题或像 *28 天后* 这样的标题，程序会提示他们输入不同的标题，直到他们最终按照指示操作。

#### 使用复杂条件进行搜索

对于没有正则表达式的话，搜索会变得更加困难，可以考虑以下内容：

```
findstr /R "^The...........*Man$" C:\Batch\12Movies.txt
```

在这个上下文中，前导插入符号（caret）不是转义字符，而是双引号包围的字符串的一部分。插入符号是一个正则表达式指示符，表示它后面的文本被固定在字符串的开头，而结尾的美元符号则表示它前面的文本被固定在字符串的结尾。11 个点是通配符，星号表示它前面的通配符可以是任意长度，包括零。

将这些内容整合在一个非正则表达式程序员能理解的语言中，搜索的目的是查找所有以“The”开头并以“Man”结尾的记录，区分大小写，且两者之间至少有 10 个字符（包括空格）。

如果你执行这个命令，使用一个包含更完整电影列表的文件，它可能会返回标题为*隐形人*和*神奇蜘蛛侠*的记录。然而，*神奇蜘蛛侠 2*、*音乐之人*和前述的*第 12 个人*却不会出现在结果中。（第一个标题附加了数字，而其他两个标题太短。）

如果不使用正则表达式，你可以将一个 findstr 命令（使用/B 选项）通过管道传递给另一个 findstr 命令（使用/E 选项），但你仍然需要过滤掉所有标题中两个词之间少于 10 个字符的记录；这虽然可行，但非常混乱。许多其他复杂到几乎不可能的搜索，使用正则表达式会变得更加容易。

正则表达式的主题足以写一本书。我展示了几个在 Batch 中有用的示例，但下次当你的搜索变得过于复杂时，查阅书籍或在网上查找你问题的正则表达式语法，尝试使用 findstr 命令和/R 选项。即使是经验丰富的程序员，有时也会因正则表达式的复杂性而避开它，但在这些相对简单的示例中所展示的强大功能，实际上为其他应用打开了一扇窗。

为了让事情更加有趣，Batch 只支持常见正则表达式功能的子集，因此一些在其他地方有效的正则表达式在 Batch 中不起作用。显而易见，进行严格测试是必须的，既要考虑正向案例，也要考虑负向案例。

### 查找文件的记录数

收集或许是一种恶习，但在 Batch 中，什么都不会真正被丢弃。虽然 xcopy 和 robocopy 命令早已取代了 copy 命令处理所有与复制相关的功能，但 copy 命令仍然有用，可以用来创建一个空文件。同样，find 命令与 findstr 命令相比几乎没有用处，因此我将跳过关于如何使用它进行搜索的讨论。然而，它确实有一个有用的功能：获取文件的记录数。请看以下内容：

```
find "" /V /C C:\Batch\12Movies.txt
```

这个命令在双引号之间执行对空字符串的搜索，以*12Movies.txt*作为输入文件。/V 选项与 findstr 命令一样，否定了搜索逻辑。它返回所有不包含空字符串的记录，这实际上返回了文件中的每一条记录。/C 选项提供了返回的记录的*数量*，即文件中所有记录的数量，因为每一条记录都会返回，但它写入标准输出的内容比我们需要的要详细一些：

```
---------- C:\BATCH\12MOVIES.TXT: 12
```

方便且奇怪的是，当我们通过 type 命令将输入文件传递给 find 命令时，它的行为有所不同：

```
type C:\Batch\12Movies.txt | find "" /V /C
```

这个命令简洁地将记录数（本例中为 12）写入标准输出。

为了将该值捕获到变量中，我们可以执行两个通过管道传递的命令作为 `for /F` 命令的输入，但在 `find` 命令之前，我们必须转义管道符：

```
for /F usebackq %%c in (`type C:\Batch\12Movies.txt ^| find "" /V /C`) do (
   set recCount=%%c
) 
```

（注意使用 `usebackq` 关键字和反引号将 `for /F` 命令的输入组件包围，这种组合清晰地展示了命令输入。）

这看起来可能是获取记录数的漫长过程。是的，通过使用转义，我们将一个命令（`type`）的输出通过管道传递到第二个命令（`find`），并将其输出作为输入传递给第三个命令（`for`），这个命令包含一个包含第四个命令（`set`）的代码块，第四个命令实际上设置了变量。呼。尽管如此，它仍然有效，而且以其独特的方式非常优雅。

### 总结

在这一章中，我讨论了批处理文本搜索的多个方面。你学会了如何执行多种类型的字符串搜索，如何搜索文件中的每一条记录，以及如何在一个字符串中查找另一个字符串。

我还比较和对比了两种不同的文本搜索技术。`findstr` 方法功能强大且灵活，而文本替换方法简单、高效且速度极快。你现在知道在何时使用每种方法。我介绍了正则表达式，并演示了它们在复杂搜索中的巨大实用性。你甚至学会了如何确定文件中有多少条记录。

在下一章中，我将介绍另一个迷人且实用的话题——生成代码的代码，特别是创建其他 bat 文件的 bat 文件。
