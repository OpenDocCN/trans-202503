

## 第八章：8 执行编译程序



![](img/chapter.jpg)

本章名义上是关于一个 bat 文件执行或调用用其他语言编写并编译的程序。实际上，执行这些操作的语法非常简单。本章最有趣的部分是，有时候被执行的程序在 bat 文件中并没有定义路径。那么，bat 文件是如何找到可执行文件的呢？

本章的主要内容将集中在寻找此类程序的两个重要机制上：*当前目录* 和路径变量。这个话题不仅仅局限于执行程序。当你调用其他 bat 文件时，也会用到这些机制，而且它影响到很多其他资源未在 bat 文件中定义路径时的情况。例如，在第七章中，我讨论了许多用于复制、移动、删除和重命名文件的命令。当这些命令中的文件或文件未在 bat 文件中定义路径时，它们仍然能在你的 bat 文件中完美运行，只要你理解这些概念。当然，你还将学习不同的方式来调用程序并传递参数。

### 调用可执行文件

bat 文件通常仅仅是调用编译程序的载体或包装器，也就是所谓的 *可执行文件*。bat 文件会设置一些程序所需的变量，调用可执行文件，并在后台执行一些错误处理。更复杂的 bat 文件可能会调用数十个不同的程序，甚至在某些调用上使用条件逻辑。无论简单还是复杂，Batch 的一个特点是能够调用用其他语言编写的可执行文件。

call 命令接受可执行文件作为它的第一个参数，可能也是唯一的参数。以下命令调用或执行位于 *C:\Executables\* 目录下的程序 *MyProg.exe*：

```
call C:\Executables\MyProg.exe
```

call 命令用于调用程序；这应该不会让人感到惊讶，但接下来要说的会有些奇怪。这是 Batch 中唯一一个，在命令名本身被省略时仍然能正常工作的命令，可能其他语言中也没有类似的情况。以下命令虽然在技术上不是 call 命令，但它执行的功能与前面的例子中的 call 命令相同：

```
C:\Executables\MyProg.exe
```

想一想这个问题。命令 set x=1 设置了一个变量，但语句 x=1 只是让解释器感到困惑。如果 robocopy 命令前面没有 robocopy 这个文本，没有理智的人会期望剩下的文本能复制一个文件。（如果这还不够奇怪，调用其他 bat 文件时，call 命令的有无会变得更加怪异，在第十章中有所讨论。）

这几乎看起来像魔法，但从解释器的角度来看。当它解释一行新代码时，通常期望第一项是一个命令。当它找到 set 时，它会预期一个变量、一个等号和一个值；当它找到 robocopy 时，它接下来会寻找不同的参数。当它遇到完全出乎意料的东西时，解释器不会退缩；它会给你，程序员，一个怀疑的好处，假设无论它是什么，都可以执行，并执行它——就像 call 命令那样。

一些批处理程序员使用 call 命令来执行可执行文件；有些则不使用。我属于后者，更喜欢程序仅由可执行文件本身或只是一个解决的变量在单行代码中呈现的干净样式，但对于那些明确拼写出命令的人，我没有异议。更重要的是，一致性是关键；坚持你选择的约定。

我还更倾向于将程序名保存在一个带有完整路径的变量中，只有在它尚未定义时才进行设置。这确保了所需的程序默认存储在变量中，同时也允许其他人将其设置为备用程序，以增加灵活性：

```
if not defined pgmMyProg  set pgmMyProg=C:\Executables\MyProg.exe
```

然后，当执行程序时，这个简单的命令，如果我可以称它为命令，将会*调用*期望的程序：

```
%pgmMyProg%
```

这个变量包含可执行文件的路径，但让我们回到一个仅由硬编码路径和文件名组成的代码行的概念。

你可以通过移除路径，保留程序名和可能的扩展名来简化它：

```
myProg.exe
```

这看起来更简单，但当你停下来思考解释器该如何在机器或网络的某个位置找到程序时，复杂性就增加了。在深入这些细节之前，我需要稍微插开话题，讲讲两个命令/变量。

### cd 命令和变量

cd 命令也是一个变量，是少数几个批处理伪环境变量之一。在第二十一章中，我将有更多内容讨论这些变量。目前，只需将它们视为解释器最初设置的变量，具有一些独特的特性。

这个变量代表*当前目录*。该命令稍微有些模糊，因为它也可以表示*更改目录*，因为它被用来……嗯，改变当前目录。

当你双击或打开一个 bat 文件时，当前目录就是 bat 文件所在的目录或文件夹。如果从另一个进程调用相同的 bat 文件，当前目录将从该进程继承。仅仅在不同目录中调用一个 bat 文件或可执行文件并不会改变当前目录，但 cd 命令会。

接下来的第一行和最后一行使用 cd 变量来显示当前目录。中间部分是 cd 命令，巧妙地将当前目录更改为其参数，假设该目录存在：

```
> con echo Current Directory is: %cd%
cd C:\NewDir\
> con echo Current Directory is: %cd% 
```

如果一个包含这三行代码的 bat 文件位于 *C:\Batch\* 目录下，执行它会在控制台上显示原始当前目录和新分配的当前目录：

```
Current Directory is: C:\Batch
Current Directory is: C:\NewDir 
```

你还可以相对现有的当前目录设置当前目录。一个点表示现有的值，因此这将把 cd 变量分配到一个子目录：

```
cd .\Child\
```

两个点表示当前目录的父目录，因此以下命令会将当前目录上移一个级别：

```
cd ..
```

（..\.. 参数查找祖父目录。）

你甚至可以通过先使用两个点“..”上移一个级别，再重新分配 cd 变量到同级目录：

```
cd ..\Sibling\
```

我甚至不愿提及这一点，但 chdir 是 cd 命令的批处理同义词。也就是说，前一个示例中的命令在功能上等同于 chdir ..\Sibling\。然而，cd 变量没有同义词，所以你可以使用 chdir 或 cd 来更改当前目录，但在解析当前目录时，你需要使用 cd。我发现最简单的做法是始终使用 cd 来完成这两个目的。

在讲解当前目录的用途之前，我需要介绍另一个命令，它也是一个变量。

### path 命令和变量

类似于 cd，path 也是一个命令和伪环境变量。该变量在 Windows 机器上预定义，包含一个以分号分隔的目录列表，这些目录对计算机是必需的，例如 Java 和 Windows 可执行文件的路径。（要查看当前在 Windows 机器上设置的 path 变量，可以打开命令提示符，使用我们在第二章中学到的知识，输入命令 set path。）

就像 cd 命令设置当前目录一样，path 命令设置 path 变量。在以下代码行中，现有的值被两个其他目录添加到前后；请注意，在每个附加目录的末尾插入了分号作为分隔符：

```
path C:\PrependDir\;%path%C:\AppendDir\;
```

你可以完全重新分配 path 变量——甚至可以完全清除它，如果参数仅是一个分号的话。此变量中的各个目录是有目的的，可能是为了允许某些必要的进程运行。对于在机器上持久更改该变量（例如使用 setx 命令）要非常小心，但前面显示的 path 命令只会更改 bat 文件执行时的路径。最坏的情况是你可能会破坏 bat 文件，但不会破坏计算机上的其他任何内容。在下一节中，我将解释为什么你可能想要更改 path 变量。

警告

*set 命令提供了重置 cd 和 path 变量的另一种方法，但出于一致性考虑，我抵制这种方法，因为一些其他伪环境变量不能或不应该使用此命令重置——而且它需要更多的按键操作。*

### 查找可执行文件

让我们回到通过仅调用程序的名称和扩展名来执行程序，如下所示：

```
myProg.exe
```

解释器在哪里找到可执行文件？它首先会在当前目录查找。如果在那里找到了，它会执行那个文件。否则，解释器会按顺序在路径变量中定义的每个目录中查找，并执行第一个找到的可执行文件。如果在这些目录中找不到该文件，解释器只会将错误级别设置为 9009 的值。（奇怪的是，如果`call`命令出现在可执行文件名之前，错误代码是 1。）

假设*myProg.exe*位于*C:\Executables\*，我们执行相同的代码行。如果该目录是当前目录，程序将被找到并执行。否则，如果该目录在路径变量中，程序可能会被找到并执行。这假设程序没有被当前目录中或路径变量更高位置中的同名、同扩展名的其他程序所覆盖。

如果以上都不成立，程序将无法找到，但有多种方法可以确保解释器找到可执行文件。首先，我们可以使用`cd`命令在执行程序之前更改当前目录：

```
cd C:\Executables\
```

或者，我们可以通过两种方式来修改路径变量，使其包含目录。这里我是在路径前添加目录：

```
path C:\Executables\;%path%
```

这里我是在路径后追加目录：

```
path %path%C:\Executables\;
```

如果目录被追加，并且路径变量中较早定义的目录中存在另一个名为*myProg.exe*的文件，那么将会执行那个程序。将目录添加到前面确保了我的可执行文件在任何其他文件之前被选中，但这也有一定的风险。它可能会将某些内容引入到路径变量中，覆盖其他进程使用的资源。

这绝不是一种不好的技巧；事实上，当合理管理时，它非常有用。使用当前目录或路径变量来查找可执行文件的一个很好的应用是使代码具有可移植性。你可以将一个批处理文件保存在单个文件夹中，或者一个更复杂的文件夹结构中，里面包含其他批处理文件、可执行文件、配置文件和其他资源。然后，你可以将这个文件夹复制到具有不同根目录结构的其他计算机和网络中。由于当前目录本质上跟随高层批处理文件，它会在这些不同的位置工作，只要使用当前目录来查找它的其他组件。

你可以将默认可执行文件与批处理文件放在同一个文件夹中。如果单独运行，它将使用这个可执行文件。如果从另一个批处理文件调用，且当前目录不同，它可能会找到一个不同的程序，从而允许其他人使用你的批处理文件来调用他们自己的可执行文件。简而言之，你可以创建一组同名的程序，在不同的实例中执行不同的程序。

进一步说，我之前提到过，实际上甚至不需要扩展名就可以调用一个程序。也就是说，如果 *myProg.exe* 存在于当前目录，它*很可能*会通过以下代码行被调用：

```
myProg
```

解释器通过另一个伪环境变量 `pathext` 来找到没有扩展名的可执行文件，`pathext` 包含一个由分号分隔的扩展名列表，类似于 `path` 变量包含的目录层级。解释器仍然会在当前目录中查找可执行文件，然后是 `path` 变量中的各个目录，但在每个文件夹中，它现在会查找第一个可以找到的，文件名为 *myProg* 且扩展名位于给定层级中的可执行文件。

如果 `pathext` 变量没有被其他人或其他程序修改，它通常包含大约十几种文件扩展名，按顺序包括：*.com*、*.exe*、*.bat* 和 *.cmd*。因此，唯一会阻止先前的命令在当前目录执行 *myProg.exe* 的实体，就是当前目录中的 *myProg.com*。 （如果你需要重置这个变量，可以使用 `set` 命令。`pathext` 变量只是一个变量，而不是一个命令。）

### 推送和弹出当前目录

`cd` 命令非常有效地更改当前目录，但先前的当前目录会消失在空中，再也无法找回。通常这完全没有问题，但在某些情况下，你可能希望在更改当前目录后暂时恢复原来的状态。也许有一个实用的批处理文件（bat 文件）是为了被其他许多批处理文件调用而编写的。稍后我将详细讨论如何从另一个批处理文件调用一个批处理文件，但现在，我们只需要理解被调用的批处理文件的角度。

被调用的批处理文件可能会在某个文件夹中创建或使用资源，因此在批处理文件开始时更改当前目录是有意义的。然而，当被调用的批处理文件完成并将控制权交还给调用它的批处理文件时，应该恢复先前的当前目录。这是基本的礼貌，因为调用的批处理文件可能正在不同的目录中工作，改变它的当前目录可能会给它带来问题。一个更自私的动机是，被调用的批处理文件可能希望保持它自己的目录。如果被调用的批处理文件不恢复当前目录，调用的批处理文件可能会在现在的当前目录中丢下不必要的文件。被调用的批处理文件可以在不让外部干扰的情况下保护它的目录，同时也表现得非常有礼貌。

为了解决这个问题，你可以在执行 `cd` 命令之前将先前的当前目录存储在一个变量中，然后在批处理文件的末尾执行另一个 `cd` 命令来恢复它。但批处理提供了两个命令，结合使用可以更优雅地完成这个任务，它们就是 `pushd` 和 `popd` 命令。

pushd 命令像 cd 命令一样改变当前目录，但它还会将先前的当前目录 *推送* 到堆栈中，供以后使用。有时它被称为 *推送目录* 命令，尽管为了简便，通常按字面发音，即“push-d”命令。在 bat 文件的开头附近，此命令将简洁地执行这两个任务：

```
pushd C:\NewDir\
```

在 bat 文件的末尾或接近末尾的位置，以下简短的命令将删除 *C:\NewDir\* 作为当前目录，并从堆栈中获取或 *弹出* 之前的当前目录，用它来恢复当前目录：

```
popd
```

这有时被称为 *弹出目录* 命令，但更常见的是“pop-d”命令。

注意，没有参数；popd 是一个极少接受任何参数的命令。当多个 pushd 命令执行时，每个命令都会将另一个先前的当前目录推送到堆栈中，而每个随后的 popd 命令都会恢复最近添加的目录。

另需注意的是，如果传递给 pushd 命令的参数是网络路径，则该路径会分配给最高的未使用驱动器字母，popd 命令将取消该分配。最后，未带参数的 pushd 命令会显示堆栈中目录的完整列表，从最近添加的目录开始。

警告

*pushd 和 popd 命令必须平衡使用。 如果一个 pushd 分配了网络路径，则应始终执行相应的 popd，即使有错误被处理。如果没有，任何映射的驱动器字母将保持映射，即使 bat 文件已经完成。如果这种情况发生得足够频繁，计算机会用完可用的驱动器字母。*

### 使用当前目录查找其他资源

当前目录用于的不仅仅是查找可执行程序。对于任何资源，例如文件，如果路径没有被定义，当前目录将被假定为其路径。例如，在第七章中，以下命令删除了一个显式文件和所有以特定扩展名结尾的文件：

```
del /Q C:\Source\Junk.txt C:\Source\*.OLD
```

以下命令在按下的键数更少的情况下完成相同的任务 *如果*——*if* 是一个关键限定词——当前目录是 *C:\Source\*，即前一个命令的路径移除两次：

```
del /Q Junk.txt *.OLD
```

xcopy 命令的源参数和任何其他接受路径和文件名作为参数的命令相同。我通常更倾向于使用显式路径，以避免任何歧义，但这种技巧赋予了本章中描述的同类型的灵活性，适用于大量命令。再翻阅一遍第七章，想象所有用于复制、移动和重命名文件的命令都没有显式路径。如果解释器能够在当时的当前目录中找到特定的文件或文件，它们都会是有效的命令。

### 向可执行文件传递参数

在本章开始时，我演示了如何调用一个已编译的程序。在继续之前，我有一个关于这个语法的最后观察要分享。

可执行文件通常在执行时接受一个或多个参数。这些参数通过简单地将它们列在程序后面作为参数传递给程序。为了便于阅读，我将这三个参数放入了变量中：

```
set inFile=C:\Batch\Input.dat
set outFile=C:\Batch\Output.dat
set logFile=C:\Batch\Log.dat

%pgmMyProg% %inFile% %outFile% %logFile% 
```

输入文件是传递给程序的第一个参数；在许多语言中，这通常被视为程序中的 args[0]。同样，输出文件是第二个参数 args[1]，日志是第三个参数 args[2]。你也可以使用硬编码的值，参数可以是任何你想要的，它们不一定是文件。

### 摘要

执行已编译的程序一开始看起来非常基础。毕竟，你甚至不需要一个命令。但如果不了解当前目录和我在这里详细介绍的路径变量，你就无法真正理解它是如何工作的。你已经学会了解释器如何使用它们来查找可执行文件、文件和其他资源，以及管理这些重要变量内容的多种方法。

执行另一个 bat 文件类似于但不完全相同于执行已编译的程序，你将在第十章中了解这些区别。但在我深入讨论之前，你将学习标签及其在下一章中的多种重要用途，主要是它们对命令执行时间和频率的影响。
