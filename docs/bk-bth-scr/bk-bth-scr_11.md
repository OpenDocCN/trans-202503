<hgroup>

## 10 调用例程和批处理文件

</hgroup>

![](img/chapter.jpg)

在上一章中，我介绍了标签和非顺序执行，它们在本章中也发挥了重要作用。我将很快介绍一种已经讨论过的命令的新变化，使你能够创建并调用由标签定义的例程。控制权不会仅仅交给标签后面的代码，而是在例程执行后返回到调用它的地方。当你编写更复杂、更有趣的批处理文件时，你将希望充分理解例程。

在第八章中，我介绍了调用用其他语言编译的可执行文件的概念。这里我将扩展这一讨论，描述一个批处理文件调用另一个批处理文件的不同技巧。显然，你将了解最典型的调用方式，即将控制权返回给调用批处理文件的方式。但你也会学到将控制权交给被调用批处理文件的技巧，以及如何生成一个并行的第二个批处理进程。此外，你还将探索不同的退出例程或批处理文件的方式，无论是否带有返回代码。

### 调用命令，再探讨

在你创建可调用的内部例程之前，你必须了解两个与标签相关的命令的相似性和差异性。一个是第八章中首次介绍的 call 命令，我们用它来调用用其他语言编译的程序。另一个是第九章中介绍的 goto 命令，用于改变批处理文件的执行流程。

为了对比这两个命令，回顾第九章中的这段代码：

```
 > con echo Before GOTO
 goto :MyLabel
 > con echo After GOTO
:MyLabel
 > con echo After LABEL 
```

goto 命令跳过了中间的 echo 命令，导致输出结果如下：

```
Before GOTO
After LABEL 
```

为了演示两者的对比，清单 10-1 将代码中的每个 goto 实例替换为 call，包括 goto 命令和 echo 命令中的文本，同时保持此非常简洁的批处理文件中的其他内容不变。

```
 > con echo Before CALL
 call :MyLabel
 > con echo After CALL
:MyLabel
 > con echo After LABEL 
```

清单 10-1：演示 call 命令的简短批处理文件

执行清单 10-1 中的批处理文件，你会在控制台上看到清单 10-2 中显示的四行内容，而不是某些人预期的三行。

```
Before CALL
After LABEL
After CALL
After LABEL 
```

清单 10-2：执行清单 10-1 时写入控制台的结果

“Before CALL”的显示显然会立即执行（双关含义）。call 命令暂时将控制权交给标签后面的代码，导致显示“After LABEL”。当时如果是 goto 命令，那就结束了；批处理文件在那次显示之后就终止了。但是使用 call 命令时，在执行完：MyLabel 和批处理文件结尾之间的所有内容后，控制权会返回到 call 命令后面紧接的命令。因此，显示“After CALL”。

有些人可能会认为执行到此为止，但解释器接下来再次遇到 :MyLabel。我们没有调用它，也没有跳转到它；它只是代码的下一行。请注意，我没有称它为命令或语句。它只是代码的一行，占位符，在这个上下文中，除了是通向下一个命令的微妙“减速带”外，几乎没有其他意义。解释器继续执行 bat 文件中的最后一行，并且 After LABEL 文本第二次显示。解释器没有找到其他命令需要解释，bat 文件执行完毕。

虽然 goto 命令放弃了控制权，但 call 命令会记住它来自何处，并在完成任务后返回到该位置。现在我们已经具备了可调用的内部例程，我们将通过 call 命令调用该例程。

### 调用内部例程

当你的 Batch 代码变得更加复杂时，你可能会想从 bat 文件中的不同位置多次执行某段代码。例如，你可能想多次调用一个可执行文件，或者定期检查某个目录中是否有需要复制的文件。当我们进入交互式 Batch 时，你可能会想多次询问用户问题并获取响应。

面对需要多次调用某段代码的需求，一位新手程序员可能会 resort to cut and paste——在我极为评判（但准确）的看法中，这是一种令人厌恶的选择。一个更好的解决方案是创建一个内部例程，并从多个位置调用它。你甚至可以将一些只调用一次的代码放入一个例程中，便于更好地组织你的 bat 文件。有时直接通过标签运行是完全可以的，但更多时候，你可能希望创建一个只能通过调用才会执行的例程。

对于接下来的练习，我将以清单 10-1 为例，重新配置它，使得标签定义了一个可调用的例程。也就是说，执行流程会调用该例程，执行完毕后返回，再退出 bat 文件，避免再次执行该例程。为此，我需要一种方法来终止例程和 bat 文件。在清单 10-2 中，After LABEL 显示的内容将不再出现。相反，我们将期待以下三行输出：

```
Before CALL
After LABEL
After CALL 
```

以下代码，尽管看起来与之前的不同，但正是做了这件事：

```
 > con echo Before CALL
❶ call :MyLabel
 > con echo After CALL
❷ goto :eof & rem End of TestCall.bat

❸ :MyLabel
 > con echo After LABEL
❹ goto :eof & rem End of :MyLabel

❺ :AnotherLabel
 > con echo This is Never Executed
 ❻ goto :eof & rem End of :AnotherLabel 
```

在逐步执行代码之前，请注意这三条 goto :eof 命令。正如你所预料的，第一个 ❷ 跳转到*文件末尾*，终止 bat 文件。其他两条 ❹ ❻ 则是完全不同的——是一些新的内容。

在初始的 `echo` 命令之后，`call` 命令 ❶ 调用了 :MyLabel ❸ 定义的例程，该例程仅包含两条命令。第一条是熟悉的将 “After LABEL” 打印到控制台，第二条是一个 `goto :eof` 命令 ❹。因为该命令在标签调用后执行，所以它结束的不是文件而是例程，控制会返回到 `call` 命令 ❶ 之后的命令，打印 “After CALL” 到控制台。最后，主 `goto :eof` 命令 ❷ 退出了 bat 文件，因为解释器知道它不在例程中。

当在 :MyLabel ❸ 例程内部时，跳转到 :eof（或 *文件结束*）是一个误称；它实际上更像是 *例程结束*，但我们不必在语义上纠缠。如果去掉这个 `goto :eof` 命令 ❹，控制会继续执行到 :AnotherLabel ❺ 下的代码，然后再返回主线逻辑。但有了这个命令 ❹，则 :AnotherLabel 下的代码永远不会执行。

由于 `goto :eof` 命令有两种不同的用途，我通常会在此类命令后添加注释，明确指出它正在终止的内容，可能是例程的名称或是 bat 文件本身。我只是将 `rem` 命令放在一个 & 符号后面，& 符号将两条命令分开，写在同一行代码中。从程序角度看，这并不是必须的，但这种做法确实大大提高了代码的可读性，尤其是在例程变得比之前的示例更长、更复杂时。

### 调用 Bat 文件

短小或重复的代码片段非常适合放入内部例程中；你可以在 bat 文件的末尾添加一个或多个例程，创建一个结构良好的模块，你可以为此感到自豪。但有时这些短小的代码片段并不那么简短，或者它们非常有用，以至于你希望将它们提供给其他由你编写的，甚至是其他人编写的 bat 文件。在这种情况下，应该用一个 bat 文件调用另一个 bat 文件，而不是创建一个例程。例如，你可以创建一个单独的 bat 文件来处理日志记录，并从多个其他 bat 文件中调用它。

从另一个 bat 文件执行一个 bat 文件的方式与执行内部例程有些不同。但首先，让我们回到 第八章 中如何执行编译程序。当解释器遇到一行仅包含可执行文件名的代码时，它会调用该可执行文件。因此，这条“命令”执行了程序：

```
C:\Executables\CompiledProg.exe
```

程序完成任务后，控制会返回到 bat 文件。你可能期望调用一个 bat 文件的方式与此相同，但实际上并非如此。然而，以下这一行代码确实执行了被调用的 bat 文件，但存在一个巨大的警告：

```
C:\Batch\CalledBat.bat
```

那个 bat 文件的特点很简单：控制永远不会返回到调用它的 bat 文件。整个过程在被调用的 bat 文件结束时就结束了。绝大多数情况下，你都希望控制能够返回；否则，在调用 bat 文件后继续编码就没有什么意义了。为了看到控制返回，你可以在被调用的 bat 文件之前插入 call 命令：

```
call C:\Batch\CalledBat.bat
```

总结一下，无论是调用 bat 文件还是调用其他语言编译的可执行文件，你都可以使用 call 命令或者省略它，但它们是有区别的。调用可执行文件时，这两种方法几乎是相同的。而调用另一个 bat 文件时，call 命令确保控制能够返回给调用者。如果没有这个命令，控制将永远不会返回。

由于我从未找到过不返回的 bat 文件调用的用途，我的偏好一直是对于可执行文件省略 call 命令，对于 bat 文件使用它。一个优点是，一眼就能看出被调用的是哪种类型的文件。

在我的职业生涯初期，我通过一次艰难的经历学到了调用命令（call command）在 bat 文件中的必要性，那时我无法理解为什么我的 bat 文件停止执行。没有挂起或中止的消息，它就是停止了。更复杂的是，我的故障排除自然集中在被调用的 bat 文件上。过了很久，我才注意到缺少了 call 命令，更重要的是，才理解了它的重要性。但这并不是关于 call 命令的唯一特性。

### 关于调用标签的备注

在上一章中，我提到过，在 goto 命令的参数中，标签名称后面的冒号是可以省略的，尽管强烈建议包含它。而在 call 命令中，调用定义内部例程的标签时，冒号是始终需要的。

这个明显的不一致可能无法理解，直到你考虑到 goto 命令只关心跳转到它自己 bat 文件中的标签，而 call 命令则能调用它自己 bat 文件内外的实体。结果就是，当没有冒号的情况下尝试调用 :MyLabel 时，会发生一些非常意外的事情：

```
call MyLabel
```

冒号本应告诉解释器调用一个内部例程，但解释器却试图调用一个外部文件。首先，它会在当前目录中查找一个可执行文件，例如 *MyLabel.com* 或 *MyLabel.exe*。接着它会查找 *MyLabel.bat* 以及一些其他类型的可执行文件，仍然在当前目录中。然后它会在路径变量中的所有目录中查找任何名为 MyLabel 的可执行文件。如果没有找到这样的文件，解释器就不会再查找该名称的标签，即使 :MyLabel 是 bat 文件中的有效标签；相反，它会产生一个错误。

在使用 goto 或 call 命令跳转到标签时，始终使用冒号，至少为了保持一致性。

> 注意

*在第九章中，我提到过，当找不到标签时，goto 命令会中止进程。call 命令则宽容一些。当其参数是无效标签时，二者都会输出错误信息，但 call 命令还会将 errorlevel 设置为 1。如果你选择不检查返回码，进程会继续执行，就像什么都没发生一样。（有关如何处理失败的 call 命令的更多细节，请参见第二十八章。）*

### 启动 Bat 文件

有时你可能希望将 bat 文件作为新进程启动或生成。也就是说，你可能希望启动另一个 bat 文件，但不希望解释器在继续之前等待它完成。例如，你可以并行执行多个进程，从而加速整体处理时间。你还可以启动一个非关键但耗时的任务，可能是一个日志记录过程，让它自行执行。在第二十六章中，我将讨论如何自动终止和重启一个挂起的进程。为了实现这一点，我将把容易挂起的进程生成一个独立的 bat 文件，并从主 bat 文件中监控它。

要启动或生成 bat 文件，只需使用 start 命令替代 call 命令：

```
start C:\Batch\LaunchedBat.bat
```

该命令创建了第二个命令或 DOS 窗口，*LaunchedBat.bat*文件与启动它的 bat 文件同时执行。

### exit 命令

如你所料，exit 命令会退出例程、bat 文件或整个执行过程，甚至可以设置返回码。它的功能与 goto :eof 命令重叠，但我很快会展示出一个显著的区别。

不带参数的 exit 命令会突然结束整个进程。遗憾的是，第二个 echo 命令将不会被执行：

```
> con echo The Meaning of Life is...
exit
> con echo ... %meaningOfLife% 
```

第一个 echo 命令将消息输出到控制台，但 exit 命令会在你阅读之前关闭窗口。无论 exit 命令在哪里调用——无论是在高层 bat 文件中、在调用的 bat 文件中，还是在任何类型的 bat 文件中的例程——都会发生这种情况。此命令的变体类似于使用大锤。

然而，/B 选项将 exit 命令变成了更像一只珠宝锤。文档中没有明确说明 B 代表什么，但对我来说，它代表*break*，即后续命令仅中断被调用的代码，无论是调用的 bat 文件，还是 bat 文件内部的例程：

```
exit /B
```

该命令仅在高层 bat 文件的主逻辑中调用时才会退出整个进程。它不会更改 errorlevel，逻辑上等同于 goto :eof。两个命令都是有效的，使用哪个通常取决于个人偏好。我的偏好是 goto :eof 命令，但仅在不需要返回码的情况下。

在第九章的开头，我提到了清单 10-3 中复现的基本中止逻辑，但将解释留到后面，现在就是解释的时机。

```
:Abort
 echo The Process is aborting
 exit /B 1 
```

清单 10-3：一个标记为:Abort 的中止例程

这个`exit`命令的行为与`exit /B`非常相似，唯一的例外是，当控制权返回到代码被调用的位置时，跟随选项的命令数字参数将成为`errorlevel`中的新值。简而言之，这个命令会中断批处理文件或例程，并返回退出或返回代码。在之前的示例中，返回代码是 1。如果没有检测到错误，批处理文件的主逻辑可能通过将返回代码设置为 0 来结束：

```
exit /B 0
```

如果检测到致命错误，主逻辑中的`goto :Abort`命令将引导解释器进入清单 10-3 中显示的终止逻辑。必须使用`goto`命令，因为`call`命令会将终止逻辑当作被调用的例程；错误级别会被设置，但控制权会返回到致命错误发生的地方。而当通过`goto`命令导航到标签时，并不会调用例程；它仍然被认为是在主逻辑中，`exit`命令会结束批处理文件，而不是调用一个例程。

为了增加灵活性，你可以为退出代码创建一个变量，并为不同的失败设置不同的值：

```
:Abort
 echo The Process is Aborting
 exit /B %exitCode% 
```

然后，这段逻辑可以通过多个`goto`命令在批处理文件中进行访问。

（一个真实的终止例程会比这个简单的回显命令更有趣。错误信息可能包含多行内容并包含变量，还会被写入日志文件和控制台，但为了保持对退出命令的关注，我在这里进行了简化。）

### 总结

在本章中，我详细介绍了调用内部例程和其他批处理文件的不同方法。你已经学会了如何带或不带返回代码从这些调用中返回，或者如何从任何地方直接中止整个过程。你还学会了如何启动或生成另一个与第一个批处理文件完全独立的批处理文件。最重要的是，你现在理解了`goto`和`call`命令之间重要而微妙的差异。简而言之，`call`会返回控制权并可以访问其外部，而`goto`则没有这种能力。

这个谜题中仍然有一个大块未解。一个调用的批处理文件可以将多个参数传递给被调用的批处理文件，而且被调用的批处理文件甚至可以设置并返回参数。这个过程比人们预期的要复杂，我将在接下来的章节中详细讲解所有的细节。
