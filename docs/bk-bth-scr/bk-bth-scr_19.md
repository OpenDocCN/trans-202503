

## 17 `for`命令的基础



![](img/chapter.jpg)

在本章中，我将介绍`for`命令，特别是没有任何选项的`for`命令，它仅仅展示了该命令的整体功能。这个没有选项的命令创建了循环，其中输入可以是零个到多个值，既可以是简单的文本值，也可以是文件名。有些人称之为*基本*的`for`命令，但我不太喜欢这个修饰词，因为即使没有选项（我将在后续章节中讨论），`for`命令也并不“基本”。

说到修饰符，在完全不同的上下文中，这个命令的语法允许使用多个*修饰符*，你将学习如何使用这些修饰符提取关于任何文件的丰富信息，比如它的大小、最后修改的日期和时间、属性、以及路径和文件名的部分内容。你还会看到几个没有选项的`for`命令在实际中的应用示例，作为它强大功能的一个小展示，我将从如何构建有关这个重要命令的个性化文档开始。

### 创建个性化文档

在正式开始之前，我强烈建议将`for`命令的帮助文档导出到一个文本文件中以备将来参考。正如你在第十二章中学到的，你可以将任何命令的输出重定向到文件，这对于`help`命令也是适用的：

```
for /? > %userprofile%\OneDrive\Desktop\ForCommand.txt
```

使用这个路径，命令会在我的 Windows 桌面上创建*ForCommand.txt*文件。你可以尝试删除*OneDrive\*节点，或者将其写入你选择的文件夹，但桌面是一个很方便存放这个文件的地方。（你将在第二十一章中了解 userprofile 伪环境变量。）

我没有建议你对任何其他命令这样做，而且你总是可以在命令提示符下找到帮助信息，所以你可能会好奇为什么我在这里建议这样做。随着你探索和实验`for`命令，这最终将变得更多是*自我*文档（就像一个数字笔记本）而不是*帮助*文档。部分文档并不十分清晰，正如你很快会看到的，确实需要一些注解。通过这个文件，你可以添加自己的评论并修改语法，使其更符合你的理解。你还可以添加命令可以采用的不同形式的示例，并包括你以后可以提取和使用的模板。

`for` 命令的语法细微变化会极大影响其功能，甚至可能导致其无法工作。因此，程序员常常会尝试编写 `for` 命令。如果第一次不行，他们会继续尝试，可能会添加某些关键字，给输入加上双引号，或者尝试单引号。最终，他们会找到某个有效的或者看似有效的方案。更好的方法是理解这个命令多种形式的复杂性。创建个性化文档，你将能将关于这个命令的所有信息集中在一个地方（当然除了这本书）。

### 无选项 `for` 命令

让我们从没有选项的 `for` 命令开始。`for` 命令可以与（恰如其分地）四个选项一起使用，我将在接下来的两章中详细讲解这些选项，但即便不带选项，它依然是个强力工具。以下不是一个实际的命令，而是用于执行循环零次或多次的通用语法， loosely 基于帮助文档中找到的内容：

```
for `%%variable` in (`input`) do `command`
```

关键词 `for`、`in` 和 `do` 是保留字，在你的 `for` 命令中将按此方式出现。括号也会如示例所示出现，但括号中的内容是无选项 `for` 命令的三个主要组成部分之一。这些组成部分分别是 `for` 变量（%%variable）、你传递给命令的输入（input），以及在循环中执行的核心逻辑（command）。

**`for` 变量**

`for` 变量是这个命令的核心。如果循环执行多次，它的值会在每次迭代时发生变化。你通过两个百分号符号加上一个字符来定义 `for` 变量。数字和许多特殊字符都是有效的，但大多数程序员普遍使用字母。通常，`%%i` 是最常用的变量，其中 `i` 代表 *索引*。

有些程序员专门使用 `%%i`，好像它是唯一允许的 `for` 变量，但不要局限于此。一个单字符的变量名没有太多的描述潜力，但可以利用手头的工具。我常用 `%%f` 表示 *文件*，`%%c` 表示 *计数*，`%%n` 表示 *名称* 或 *数字*，虽然 `%%#` 也可以表示 *数字*。与其他变量名一样，很多程序员使用大写字母，但我使用小写字母。做你认为合理的，并且保持一致。

**输入**

`for` 命令的第二个组成部分是括号内的输入，或者说你传递给命令的输入。它可以是一组文件名、单个文件名、文件掩码、多个文件掩码、硬编码文本或已解析的变量。要等一段时间才能给你展示所有这些，因此目前先将其视为输入，从单个文件开始。（帮助文档使用 set 代替输入，像是文件的 *集合*，但这个术语不完整，且容易与同名的命令混淆。）

**命令**

最后，命令是每次循环执行的核心逻辑，可以执行零次或多次。它可以是单个命令，也可以是跨越多行代码的多个命令，在该逻辑中的任何地方，你都可以将 `for` 变量解析为它的当前值，但这个变量与之前见过的变量完全不同。通常，你使用百分号符号（前后都有）来解析变量，但你按照定义的方式解析 `for` 变量：前缀是两个百分号符号。更简单地说，如果你将 `for` 变量定义为 `%%n`，你可以在命令中将其解析为 `%%n`。

类似于批处理接受参数的方式， strategically 放置的波浪号（tilde）可以移除围绕变量的双引号。对于 `for` 变量，波浪号出现在第二个百分号符号之后和变量名之前——例如，`%%~n`。与参数类似，如果没有双引号，波浪号对解析没有任何影响。

在一个非常令人惊讶的转折中，`for` 变量是区分大小写的，这是批处理世界中的一个显著异常。因此，`%%i` 和 `%%I` 不是同一个实体。在另一个转折中，在第十四章你学会了如何用另一个百分号转义百分号符号。这个变量也带有双百分号符号，但解释器足够聪明，能够区分它们。例如，如果 `%%i` 结果是一个 `for` 变量，解释器会将其解析为其值；如果不是，解释器会将第一个字符视为转义字符，并将其解析为文本 `%i`。让我们将这些内容组合成一些实际可执行的示例。

以下 `for` 命令将路径和文件名写入控制台：

```
for %%f in (C:\Batch\MyInputFile.txt) do  > con echo Filename is %%f
```

对于其三个组件，我选择 `%%f` 作为 `for` 变量的简写，表示*文件*，因为输入是一个文件，*C:\Batch\MyInputFile.txt*。命令组件是一个简单的 `echo` 命令，用于将文本输出到控制台。

不久你就会看到 `for` 命令如何创建一个执行多次的循环，但这个例子只执行一次，变量被设置为括号内的路径和文件名。接下来是 `do` 保留字后的命令，`echo` 命令中的 `%%f` 会解析为输入文本，并将以下内容写入控制台：

```
Filename is C:\Batch\MyInputFile.txt
```

注意代码行中两个 `%%f` 实例，一个在行首附近，另一个在行末。第一个定义了 `for` 变量，第二个实例使用了该变量；也就是说，命令组件解析它并使用其值。

如果你在 `echo` 命令周围加上括号，会稍微更容易理解，这也是合法的语法：

```
for %%f in (C:\Batch\MyInputFile.txt) do  (> con echo Filename is %%f)
```

如果命令组件包含的逻辑稍微复杂一点，最好将其重写为多行代码，以便于阅读。

以下示例在功能上等同于前两个示例，但 `echo` 命令现在独立成一行。使用多行语法时，括号是必需的：

```
for %%f in (C:\Batch\MyInputFile.txt) do (
    > con echo Filename is %%f
) 
```

开括号必须紧跟在 `do` 保留字后面，且与其位于同一行。这是一个重要的规定，因为其他语言允许，甚至鼓励，开括号单独位于新的一行，并与闭括号对齐。

下一个例子展示了关于无选项 `for` 命令的三个额外要点：

```
for %%F in ("C:\Program Files (x86)\Notepad++\notepad++.exe") do (
   > con echo Filename is %%F
   > con echo Filename is %%~F
) 
```

首先，注意到 `for` 命令的代码块中可以包含多个命令。其次，我将 `for` 变量改为 `%%F`，只是为了展示我可以将它设为任何我想要的字符，只要在代码块中一致使用 `%%F` 或 `%%~F`（尽管你不会再看到我用大写字母来表示这种变量）。第三，我将输入路径和文件名括在双引号中。即使路径和文件名中包含空格、括号，甚至加号，解释器也不会受到影响，因为使用了双引号。

为了演示波浪号与参数的作用，注意到在第一次使用 `%%F` 的 `echo` 命令输出中有双引号，而在第二次使用 `%%~F` 时没有双引号：

```
Filename is "C:\Program Files (x86)\Notepad++\notepad++.exe"
Filename is C:\Program Files (x86)\Notepad++\notepad++.exe 
```

对于单个文件名作为输入，这个 `for` 命令看起来可能有些过度，因为它的确是过度的。你完全可以用两个 `echo` 命令更轻松地将这两行文本输出到控制台。这个逻辑的真正优势在于你可以使用文件集和文件掩码来多次执行循环，每个文件执行一次。

> 注意

*“for”命令*和*for*循环*在很大程度上可以互换使用，但存在一个细微的差别。从技术上讲，循环可以执行零次到多次，但我通常在确定输入的性质使得循环会执行多次时，使用*循环*这个术语。相反，我会在知道代码块中的逻辑只会执行一次时使用*命令*，比如在所有之前的例子中，但如果存在歧义，我也会使用这个术语，因为它是更一般且包含的术语。*

### 文件集、文件掩码和循环

*文件集*，正如你可能预期的那样，是一组文件，而 `for` 命令接受文件集作为输入，像接受单个文件一样简单。这里的输入文件集包含两个由逗号和空格分隔的文件，但你可以包含任意数量的文件：

```
for %%f in (C:\Batch\MyInputFile.txt, C:\AnotherFolder\AnotherFile.dat) do (
   > con echo Filename is %%f
) 
```

如果没有空格，仅使用逗号，也可以分隔这两个文件，空格而不使用逗号也是如此，但两者都能使代码更具可读性。

这是输出结果：

```
Filename is C:\Batch\MyInputFile.txt
Filename is C:\AnotherFolder\AnotherFile.dat 
```

这是第一个例子，展示了一个 `for` 命令如何转变为执行多次的操作——也就是更常见的所谓的 `for` 循环。解释器执行代码块两次，因为文件集包含正好两个文件。如果文件集中的文件数为三个，将会生成第三行输出。

在第七章中，我介绍了在 xcopy 和 robocopy 命令中使用通配符的文件掩码，创建文件掩码作为 for 命令输入时，适用相同的规则（以及注意事项）。星号代表任意数量的字符，甚至没有字符，问号通常表示恰好一个字符。然而，问号位于掩码末尾或后面跟着点时，也可以表示没有字符。

为了演示，我将从一个熟悉的 for 命令开始，替换文件名为最简单的掩码，即一个孤立的星号：

```
for %%f in (C:\Batch\*) do (
   > con echo Filename is %%f
) 
```

现在，解释器不会再将单个文件名写入控制台，而是会将文件夹中的每个文件逐一输出，因为每个文件都符合掩码。如果*C:\Batch\*中有 17 个文件，所有 17 个文件都符合掩码，解释器会为所有 17 个文件写一条消息到控制台。如果文件夹中只有一个文件，echo 命令只会执行一次，如果没有文件，echo 命令则完全不执行。

将文件名输出到控制台并不是很令人满足，但你可以使用文件掩码执行更有趣的任务。你可以重命名满足掩码条件的每个文件，或者可能为每个文件调用一次编译程序。无论任务是什么，for 循环的基本结构都不会改变，如果逻辑会比较复杂，最好将其设置为内部例程。这里是一个调用命令，它为每个文件调用这样的例程，并将每个文件的路径和文件名作为唯一参数传递：

```
for %%f in (C:\Batch\*) do (
   call :SomeComplexTask "%%~f"
) 
```

如果有十几个文件符合此掩码，call 命令会调用例程 12 次，每次针对一个文件。

Batch 甚至接受以逗号分隔的文件掩码列表作为 for 命令的输入。也就是说，你可以创建一个包含多个文件和/或文件掩码的文件集。

### 简单文本作为输入

另一个有趣的无选项 for 命令的用法在帮助文档中找不到。你可以通过将值逐一放入括号内作为输入，处理一个值的列表。Batch 用于分隔传递参数的字符集也用于分隔此列表，所以你可以使用逗号、分号、等号和制表符，但空格分隔的列表是常见的做法。语法与之前几个示例类似，但分隔的文本替代了文件名或掩码。例如，这个 for 循环会依次将括号中的五个单词传递给代码块：

```
for %%i in (Individual line for each word) do (
   > con echo %%i
) 
```

结果是每个单词都会被逐行写入控制台：

```
Individual
line
for
each
word 
```

注意，Batch 将括号内的 for 视为简单文本，而不是作为启动命令的保留字。我曾对解释器提出过一些质疑，但它足够聪明，能够根据上下文区分这些差异。

先前的输入列表是以空格分隔的，但解释器会将双引号包围的内容视为一个单独的值，这意味着以下 for 命令会执行两次其代码块：

```
for %%i in ("Just two lines for" "these seven words") do (
  > con echo %%~i
) 
```

结果是这两行输出到控制台，而不是七行：

```
Just two lines for
these seven words 
```

注意，使用波浪符号 `~` 解析 `for` 变量时，`%%~i` 会去掉每个字符串中的双引号。

这些简单的示例掩盖了该技巧的巨大实用性。为了说明这一点，我将从一个接受单个参数进行处理的 bat 文件开始。这里的处理过程不重要；也许传递的值会被添加到数据结构中，或者它是一个传递给可执行文件的文件名。无论是什么处理过程，关键在于，如果我有 17 项需要处理，我必须调用 bat 文件 17 次。但使用这个将列表作为 `for` 命令输入的技巧，我可以增强 bat 文件，使其能够接受任意数量的参数，并在一次执行中逐一处理它们。

我将首先把处理单个参数的逻辑放入一个可调用的例程中，并通过 `:ProcessParm` 标签进行定义。现在，我可以通过在 bat 文件顶部加入以下代码，调用该例程零次或多次：

```
for %%i in (%*) do (
   call :ProcessParm %%i
)
goto :eof 
```

我在括号中输入了 `%*` 作为 `for` 命令的输入。（记住在第十一章中，`%*` 会扩展为 bat 文件接收到的完整参数列表。）

如果有 99 个参数，所有 99 个值都会作为 `for` 命令的输入，解释器会执行循环体 99 次。在第一次执行时，`%%i` 解析为列表中的第一个参数，并作为参数传递给调用命令中的例程。第一次执行完后，第二个参数成为第二次执行的参数，以此类推，直到解释器处理完所有 99 个参数。

这种技巧的其他用途也很多。例如，你可以轻松地对一个空格分隔的数字列表求和。我还没有介绍数组，但这提供了一种很好的方法来将多个值添加到数组中。

### 检索文件信息

无选项的 `for` 命令还有一个更棒的功能。它可以检索关于文件的大量信息和数据，比如文件大小、最后修改日期/时间等等。在本章前面，我讨论了将文件名传递给 `for` 循环的技巧，目的是简单地将路径和文件名写入控制台。例如：

```
for %%f in ("C:\Program Files (x86)\Notepad++\notepad++.exe") do (
   > con echo Filename is %%~f
) 
```

让我们把这个变得更有意义。代码不再只是简单地回显路径和文件名，而是检索并输出关于文件的大量信息。如果文件有什么需要隐藏的，我们就把它暴露出来。我最终对前面示例中的代码所做的唯一修改是与 `for` 命令相关的代码块，但在此之前，我必须先介绍修饰符。

#### 修饰符

提取文件有用数据的工具被称为 *修饰符*，其中 9 个修饰符都是单个字母字符，巧妙地插入到 `for` 变量中进行解析。（我很快就会介绍第十个修饰符。）

要使用修饰符，请从一个 for 变量（例如 %%f）开始。然后在两个百分号之间和一个字符变量名之前插入波浪号和修饰符字符。例如，X 是用于检索文件扩展名的修饰符，这意味着对于 for 变量 %%f，解释器将 %%~Xf 解析为扩展名。

接下来的代码块现在有 11 个 echo 命令。前两个没有什么新意；它们都显示路径和文件名，第一个带双引号，第二个去除了双引号。其他九个 echo 命令使用特定的修饰符来修改 %%f 变量，这一点很容易理解：

```
for %%f in ("C:\Program Files (x86)\Notepad++\notepad++.exe") do (
   > con echo                  Filename = %%f
   > con echo   Filename Without Quotes = %%~f
   > con echo Fully Qualified Path Name = %%~Ff
   > con echo         Drive Letter Only = %%~Df
   > con echo                 Path Only = %%~Pf
   > con echo             Filename Only = %%~Nf
   > con echo       File Extension Only = %%~Xf
   > con echo           Short Name Only = %%~Sf
   > con echo           File Attributes = %%~Af
   > con echo        File Date and Time = %%~Tf
   > con echo                 File Size = %%~Zf
) 
```

我在代码中已记录了这九个修饰符。

执行此代码可能会将以下文本写入控制台。仔细检查每个修饰符对输出的影响：

```
 Filename = "C:\Program Files (x86)\Notepad++\notepad++.exe"
  Filename Without Quotes = C:\Program Files (x86)\Notepad++\notepad++.exe
Fully Qualified Path Name = C:\Program Files (x86)\Notepad++\notepad++.exe
        Drive Letter Only = C:
                Path Only = \Program Files (x86)\Notepad++\
            Filename Only = notepad++
      File Extension Only = .exe
          Short Name Only = C:\PROGRA~2\NOTEPA~1\NOTEPA~1.EXE
          File Attributes = --a--------
       File Date and Time = 03/11/2010 01:23 PM
                File Size = 2958480 
```

这确实是相当多的数据。从第三行开始，F 修饰符为我们提供了完全限定的路径名。通常，%%~Ff 解析出的值与 %%~f 相同，正如这里所示，但并非总是如此。如果输入仅由文件名和扩展名组成，没有路径，并且解释器在当前目录中找到了该文件，那么 %%~f 会模拟输入，省略路径，而 %%~Ff 会解析为完整的路径和文件名。

接下来，你可以在接下来的四个修饰符中看到这个完全限定路径名的各个组成部分：D（带冒号的驱动器字母）、P（没有驱动器字母的路径或目录）、N（裸文件名——即没有扩展名）、以及前面提到的 X（文件扩展名，包括前面的点）。

S 修饰符生成操作系统定义的短文件名（我答应过会在第七章中展示如何找到这个文件名），而 A 修饰符生成文件属性的列表。一个文件有 11 种可能的属性，如果文件没有某个特定属性，相应的字节会显示为破折号。此列表中唯一显示的属性是 a，表示文件被归档，但缺少其他值意味着文件不是隐藏的、压缩的、只读的，也不具有其他任何可能的属性。（我将在第三十章中进一步讨论属性。）

最后，T 修饰符提供了文件最后修改的日期和时间，而 Z 修饰符返回文件大小（以字节为单位）。(记住，S 已被占用。)缺乏逗号使得输出不易读取，但从输出中可以看到文件接近 3MB。

> 注意

*除非你直接跳到本书的这一部分，否则你应该知道我并不喜欢过度使用大写字母，但每种方式都有其适用的场合。修饰符不区分大小写，但我使用大写字母来使它们更加显眼。小写字母的变量，在这种情况下是 *f* 代表文件，终结了需要解析的内容，但我知道我是少数派。请注意，大多数程序员会做相反的操作，所以你更可能看到 %%~zI 来获取 %%I 的文件大小，而不是我用来获取 %%f 文件大小的 %%~Zf。*

修饰符的应用几乎是无限的，但一个简单的用途是对文件执行某种复杂的任务，但前提是文件中有数据。假设批处理代码是处理来自其他来源的数据文件。即使来源没有数据可报告，最好也让它创建一个空文件，因为根本没有文件将意味着一个失败的进程。为了使其生效，bat 文件需要判断文件是空的还是已填充数据。考虑以下内容：

```
for %%f in ("C:\Batch\IntermediateFile.dat") do (
   if %%~Zf gtr 0  call :SomeComplexTask "%%~Ff"
) 
```

for 命令内部的 if 命令有效地（甚至可能优雅地）验证了中间数据文件%%~Zf 的大小是否大于 0 字节，只有在通过验证后，才会调用一个例程并传递文件的路径和名称。

##### 路径修饰符

我欠你一个第十个修饰符，万一你还没有觉得这个语法足够复杂，路径修饰符的语法与其他九个完全不同。但这并不是问题，因为它的功能也完全不同。我会稍后解释它的作用，但首先要理解的是，这个修饰符实际上是一个奇特的分隔变量。其他修饰符都是单一字符，而路径修饰符是一个以美元符号开头并以冒号结尾的变量名。

为了设置这个，且为了马上就能明白的原因，让我们在修饰符中使用路径变量（与第八章中介绍的包含由分号分隔的目录的连接的相同变量）。这个变量应该已经在你的机器上设置好了，但你可以向其中添加或前置额外的目录：

```
path C:\Batch\SubDir\;C:\Batch\;%path%C:\Budget\;
```

为了看到这个修饰符的实际效果，让我们使用%%~$path:f 语法修改%%f 变量。注意路径变量夹在$和:字符之间；这三个部分组成了修饰符。现在我们可以在 for 命令中使用它：

```
for %%f in (FourBrits.txt) do (
   > con echo File Found: %%~$path:f
) 
```

这个修饰符的实际功能是什么？它指示解释器遍历路径变量，从其中列出的第一个目录开始，寻找第一个（并且只有第一个）名为*FourBrits.txt*的文件。如果该文件存在于路径变量的第二个目录中，但不在第一个目录中，结果输出将包含完整的路径和文件名：

```
File Found: C:\Batch\FourBrits.txt
```

如果解释器在路径变量定义的任何目录中找不到名为*FourBrits.txt*的文件，它会简单地将%%~$path:f 解析为 null。

这个功能显然是为路径变量设计的，帮助文档在示例中明确使用了路径变量；只有在文档底部才提到，你可以用任何有效的变量替换它，意味着任何包含目录列表的变量。尽管如此，它通常只是被称为*路径*修饰符，并几乎专门用于路径变量。

##### 堆叠修饰符

单独使用时，这些修饰符非常有用，但它们的真正威力在于将多个修饰符叠加使用时展现出来——也就是说，当它们一起使用时，可以一次解决多个文件特性。例如，你可以分别解析文件名和扩展名，然后将它们拼接为%%~Nf%%~Xf，但这有点混乱。相反，%%~NXf 巧妙地以更优雅的方式产生相同的结果。以下是三个典型的例子：

```
for %%f in ("C:\Batch\FourBrits.txt") do (
   > con echo  Drive Letter and Path = %%~DPf
   > con echo Filename and Extension = %%~NXf
   > con echo    File Date/Time/Size = %%~TZf bytes
) 
```

这段代码可能会向控制台输出以下内容：

```
 Drive Letter and Path = C:\Batch\
Filename and Extension = FourBrits.txt
   File Date/Time/Size = 04/20/2018 01:14 PM 518 bytes 
```

使用叠加修饰符，你可以轻松获取文件的完整路径而不带文件名，或者仅获取文件名和扩展名而不带路径。最后一个示例可能会在报告中显示，并在结尾添加硬编码的文本“bytes”。

叠加修饰符甚至可以与路径修饰符一起使用：

```
for %%f in (FourBrits.txt) do (
   > con echo Path Found: %%~DP$path:f
) 
```

这段代码输出在路径层级中找到的第一个文件的完整路径，不包括文件名和扩展名，该文件名为*FourBrits.txt*。

#### 带修饰符的参数

在进入几个实际示例之前，我将回到第十一章关于参数的讨论。事实证明，提取文件信息的修饰符在 for 命令的上下文中同样适用于参数。

我曾提到过，你可以将带或不带路径的文件名作为参数传递给批处理文件，并且被调用的批处理文件可以通过%~1、%~2 等解析它们。此外，你还可以将%~0 解析为正在执行的批处理文件的完整路径和文件名。好吧，前面讨论的相同修饰符（以及叠加修饰符）也适用于任何代表文件的参数。假设以下代码接收两个文件名作为前两个参数：

```
> con echo           Size of File #1 = %~Z1
> con echo  Date and Time of File #2 = %~T2 
```

第一个命令输出第一个文件的字节大小，第二个命令输出第二个文件的最后修改日期和时间。

将两个特定的叠加修饰符应用于隐藏参数，%~DP0 解析为正在执行的批处理文件的驱动器字母和路径。凭借这些信息，你可以创建子目录，将其他文件存放在此目录或兄弟目录中，或者更新与批处理文件相关的日志文件，而且不需要知道批处理文件最终将安装在哪里。也许它会部署在多台服务器上。

修饰符允许你通过最少的键盘操作检索大量的文件信息。

### 实际应用

让我们在两个实际示例中应用你刚刚在本章中学到的所有有用工具。

#### 备份中的文件重命名

使用文件掩码，无需选项的 for 命令可以生成文件列表，而修饰符可以提取每个文件路径和文件名的各个组件。结合这两种功能，你可以将一组文件复制到另一个驱动器上的镜像文件夹结构中，同时调整目标文件名。

假设我有一个名为*C:\Budget\*的文件夹，顾名思义，它包含预算信息。这个文件夹的名称显然表示应该进行备份，可能是备份到外部*D:\*驱动器，但保持相同的文件夹结构，以便文件容易找到和比较。更复杂的是，我希望在每个文件名前添加 Bkup_，因为当两个文件夹同时打开时，很容易在错误的文件夹中工作，但如果备份目录中的每个文件都以这个独特且具描述性的文本开头，就不容易出错。完成这个任务的一种方法是在`for`循环中使用单个命令（尽管在实际的实际应用中，你可能需要一些错误处理）：

```
for %%f in ("C:\Budget\*.*") do (
   echo f | xcopy "%%~Ff" "D:%%~PfBkup_%%~NXf" /Y /F
) 
```

我已经将源路径和目标路径都用双引号括起来，以处理文件名中可能包含空格的情况。源路径是完全限定的路径和文件名，%%~Ff，但目标路径则稍微复杂一些。尽管它看起来像是随机的按键输入，实际上它是四个项目的拼接，当我加粗了两个带修饰符的`for`变量与常量的对比时，它变得更易读：

```
D:**%%~Pf**Bkup_**%%~NXf**
```

目标路径以硬编码的驱动器字母和冒号 D:开头，后跟源文件变量的路径，去掉了驱动器字母%%~Pf；这模仿了源驱动器中的源文件夹。路径的开始和结束都有反斜杠，因此接下来的是文件名的开始部分 Bkup_。为了完成目标文件名，解释器找到第二个`for`变量，%%~NXf，这个变量包含了源文件名（N）和文件扩展名（X）的堆叠修饰符。

综合起来，如果解释器找到一个名为*C:\Budget\Budget.January2023.xlsx*的文件，结果目标字符串是：

```
D:**\Budget\**Bkup_**Budget.January2023.xlsx**
```

如果你习惯了由百分号分隔的批处理变量，变量的起始和结束位置可能会让你感到困惑。当编译器看到%%~时，它知道接下来将解析一个`for`变量——那是开始的位置。由于由这个`for`命令定义的变量是%%f，解释器会在看到小写字母 f 时结束该变量——那是结束的位置。在开始和结束之间，解释器会查找零个或几个有效的修饰符。终止后的部分可能是常量，一个百分号符号开始解析一个更传统的批处理变量，或者是另一个`for`变量。

源目录中每个符合条件的文件都会被复制到*D:\*驱动器的备份路径，并且目标文件的名称会经过调整。这个工具非常强大，虽然看起来只是一个简单的`for`命令，但要充分利用它的能力，必须对语法有深入的理解。

#### 处理可变数量的文件

在第十一章的末尾，我介绍了*包装器*批处理文件的概念——即一个批处理文件，它所做的几乎只是执行一个处理单个输入文件的程序。这个批处理文件是可执行文件的包装器。在那一章中，我还演示了如何将多个文件拖放到一个批处理文件上，从而使得批处理文件执行一次并带有多个参数。尽管这很令人印象深刻，但如果没有一个能够处理所有这些参数的批处理文件，或者能够处理不同数量参数的批处理文件，这个技巧就几乎没有用处。

在本章中，我讨论了两个对于构建此类包装器批处理文件非常重要的概念。一个是使用修饰符提取文件信息的非常有用的技巧，另一个是 for 命令处理值列表的能力。

现在，来介绍一下设置。我创建了一个已编译的程序，用于将 Java 代码转换为 C#代码，并且它接受两个参数：输入文件和输出文件。代码转换程序可以帮助减少将旧代码更新为新语言时的麻烦。一个语言的模块作为输入传递给程序，该程序将原始语法的大部分转换为另一种语言，并在相同的文件夹中输出一个同名但扩展名不同的文件。从批处理文件的角度来看，它接受一个或多个*.java*文件作为参数，确定相应的*.cs*输出文件的路径和文件名，然后使用这两个参数调用已编译的代码——而这些*.java*文件可以在任何文件夹中。

以下是一个批处理文件，去除了所有错误处理和注释，它完成了所有期望的功能。for 命令接受整个参数列表作为%*，将它们一个个传递到代码块中作为%%f，后者则是传递给:ConvOneFile 例程的唯一参数：

```
 for %%f in (%*) do (
    call :ConvOneFile %%f
 )
 goto :eof

:ConvOneFile
 ConvJava2CS.exe  %~F1  %~DPN1.cs
 goto :eof 
```

在调用*ConvJava2CS.exe*时，这段批处理代码将输入文件和输出文件作为两个参数传递给它。我使用%~F1 获取输入文件的完整文件名，这是第一个参数加上 F 修饰符。输出路径和文件名%~DPN1.cs 则更为复杂。我使用相同的参数，也就是%~1，但加上了驱动器（D）、路径（P）和文件名（N）的修饰符——也就是说，%~F1 去掉扩展名（通过 X 修饰符表示）。然后，我再加上硬编码的.cs 扩展名，形成输出文件名。注意，这些变量前面只有一个百分号，而不是两个，因为这些是参数，不是变量；我在一个例程中调用可执行文件，而不是在 for 命令中。

一个评论家（或者可能是一个不熟悉批处理的人）可能会对此提出异议，认为接受编译代码中的单个参数并在程序中进行文件名操作更好或更容易。但这种方法缺乏灵活性；如果其他人希望在许多文件甚至数百个文件上运行此过程，则可能希望将输出放入子文件夹，甚至放在另一个服务器上的文件夹中。通过在批处理代码中操作文件名，将输出放入子目录无需更改编译代码；而是简单地将%~DPN1.cs 更改为%~DP1%subDir%\%~N1.cs。您可以定义一个硬编码的子目录，但在这里我使用 subDir 作为子目录节点的变量。如果子目录不存在，甚至可以执行带有%~DP1%subDir%\作为其参数的 md 命令来创建子目录。

即使是对编译代码的简单更改，也总会有额外开销。您必须运行编译器并注意保持源代码和可执行文件同步。在可能的情况下，编码人员应该进行简单的更改，例如在批处理代码中获取文件连接器或文件名，至少在我看来是如此。

现在，您可以使用此批处理文件处理多个文件或单个文件，甚至不处理任何文件。如果没有传递参数，for 命令就没有输入，并且代码块永远不会执行。再次强调，几行代码正在执行比眼前看到的更多的工作。

### 在代码块中解析变量

在继续解锁 for 命令选项提供的所有功能和强大功能之前，我必须提到，到目前为止，我已经解析了与 for 命令相关联的代码块内部的单一用途变量，但这太过简单和幼稚。更常见的做法是将数据分配给一个变量，然后在复杂的代码块内使用它，甚至可能修改它。这就是第十六章详细描述的同一类型的代码块，解析变量的规则也适用于此。

例如，您可能希望为文件的日期和时间分别使用两个不同的字段，但 T 修饰符将它们解析为单个值，而在这段代码中这根本不是问题：

```
for %%f in ("C:\Program Files (x86)\Notepad++\notepad++.exe") do (
   set filDtTm=%%~Tf
   > con echo                 File Date = !filDtTm:~0,10!
   > con echo                 File Time = !filDtTm:~11!
) 
```

在代码块顶部，我将整个字符串分配给 filDtTm 变量，然后在接下来的两行分别截取日期和时间。这是一个微妙但至关重要的点：我使用感叹号和延迟扩展来解析刚在代码块内设置的变量。百分号分隔符将在代码块之前解析为 filDtTm 的值，而且由于这个值很可能根本没有被设置，结果可能会是垃圾（~0,10 和~11）。

最终，如果你在代码块内为变量赋值，你必须使用感叹号来获取其当前值。如果逻辑变得过于复杂，还有其他技巧，而在第二十章中，我将演示如何在这些更复杂的代码块中充分利用延迟扩展。但通常来说，要理解这些变量有两种可能的值，并尽量避免让代码过于复杂。

### 总结

在这一章中，我详细介绍了不带选项的`for`命令、它的组成部分、如何与文件集和文件掩码一起使用，以及如何通过修饰符检索大量文件信息。你了解到这个命令通常接受文件或多个文件作为输入，但它也可以接受一串文本。我希望你觉得这些实际应用既有趣又富有启发性，并且激发你思考这个重要命令的其他相关用途。我还提供了一些关于如何解析`for`命令代码块中定义的变量的提示。

第二部分的剩余章节将揭示更多内容，所有这些内容将有助于全面理解`for`命令的全貌。在下一章中，我将讨论一些通过选项开启的功能；其中一个列举目录而不是文件，另一个遍历子目录寻找文件，最后一个实现了一个至关重要的功能：迭代循环。
