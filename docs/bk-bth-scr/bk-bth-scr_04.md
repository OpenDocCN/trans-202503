

## 第三章：3 范围和延迟扩展



![](img/chapter.jpg)

在上一章中，你学习了变量的概念、如何设置它们以及如何解析它们的值。在本章中，我将重点介绍 setlocal 命令，这是批处理的一些重要且不同特性的核心，它改变了你处理变量的时机、地点和方式。首先，它定义了*范围*：这些变量在哪里、何时可以访问和操作。其次，它启用了一个叫做*延迟扩展*的功能，它改变了变量的解析方式，其中一个结果是允许你将一个变量存储在另一个变量中。

所有语言都以某种方式处理范围，但延迟扩展，或者类似的功能，要少得多，你会看到一些出乎意料的用途。最后，setlocal 命令启用了*命令扩展*，这是一个尴尬的术语，指的是为许多其他 Batch 命令启用的一堆附加功能。

### 范围

范围定义了一个变量的生命周期。*全局变量*可以在任何地方设置、解析、删除和修改，这对于大多数简单的批处理文件来说是有效的。*局部变量*在一个有限的生命周期内创建，旨在仅在某个代码段中可访问，在该段中它是*在范围内*的。如果在其他地方修改变量而无法识别，那么该变量就*超出范围*了。

在 Batch 中，setlocal 命令开始了一个代码段，在该段中变量是可访问的，而 endlocal 命令结束该代码段，使这些变量超出范围。在两个命令之间定义或操作的所有内容在该空间内有效，但在执行 endlocal 命令后，这些变量会恢复为先前的状态。

为了演示，以下代码将变量的状态输出到控制台，既在 setlocal 命令的范围内，也在范围外。一个变量仅在 setlocal 的范围内定义，一个仅在范围外定义，另一个则在范围内外都定义。在 echo 命令的右侧，我包含了备注，显示了结果，特别是解析后的变量，输出到控制台：

```
❶ set inAndOut=OUT    
set outer=OUT

❷ setlocal   

❸ set inAndOut=IN     
set inner=IN

❹ > con echo Inside Scope:                   &rem Inside Scope:
> con echo   Outer Variable = %outer%      &rem   Outer Variable = OUT
> con echo   Inner Variable = %inner%      &rem   Inner Variable = IN
> con echo  In/Out Variable = %inAndOut%   &rem  In/Out Variable = IN

❺ endlocal  

❻ > con echo Outside Scope:                  &rem Outside Scope:
> con echo   Outer Variable = %outer%      &rem   Outer Variable = OUT
> con echo   Inner Variable = %inner%      &rem   Inner Variable =
> con echo  In/Out Variable = %inAndOut%   &rem  In/Out Variable = OUT 
```

这里有很多内容需要解释。我们先来看定义的第一个变量：在 setlocal ❷ 执行之前，inAndOut 被设置为 OUT ❶，这意味着它是在命令的范围外设置的。在执行 setlocal 后，同一个变量被设置为 IN ❸，此时它在范围内。当首次查询 inAndOut 时，它解析为 IN ❹，因为它在范围内。但在执行 endlocal ❺ 后，它就超出了范围并恢复为先前的状态，即 OUT ❻。（顺便提一下，IN-N-OUT 始终是美味的。）

现在考虑一下内部变量，它只在范围内定义一次。也就是说，在执行 setlocal ❷ 后，它被设置为 IN ❸。然后在执行 endlocal ❺ 之前，该变量解析为 IN ❹ 的值，但有趣的地方在这里；在执行 endlocal ❺ 后，它恢复为先前未定义的状态——也就是 null 或空 ❻。

最终的变量是 outer，它也只定义了一次，但当它超出作用域时，它在 setlocal ❷ 执行前被设置为 OUT ❶。正如你所料，在 endlocal ❺ 执行时，当它超出作用域时，变量的值仍然是 OUT ❻。但如你所不料，它的值在 setlocal ❷ 的作用域内也可以使用，因为它的值在 endlocal ❺ 执行前也是 OUT ❹。

这个例子表明，setlocal 命令不会阻止我们使用已经在作用域内的变量。到目前为止存在的一切仍然可用。它的作用是：*setlocal 执行时会对环境进行快照，并在 endlocal 执行时返回该环境快照。*

使用 setlocal 和 endlocal 命令定义作用域只有一个用途，但它非常重要：隐藏或分隔代码中的变量，以防止冲突。默认情况下，Batch 变量是全局的；在一个 bat 文件中设置的变量可以在被调用的 bat 文件中解析或重置，甚至在被调用的内部例程中也是如此。默认情况下，许多其他编程语言使用相反的方法，限制在被调用的程序和例程内部使用的变量的作用域。有时，全局变量完全没问题，但在其他情况下，限制作用域是更好的选择。定义作用域的能力使你能够为你的应用选择最合适的方式。

如果你正在编写一个将被许多其他进程调用的工具 bat 文件，你可能不知道调用进程正在使用哪些变量。在 bat 文件的顶部放置一个 setlocal，并在末尾或接近末尾放置一个 endlocal，可以定义并限制作用域。这样做的结果是，如果你恰好使用了与调用 bat 文件相同的变量名，你不会覆盖它的变量，这样调用者可以放心地调用你的 bat 文件，确保没有不良副作用。对于被调用的内部例程，通常也会采取这种做法。（在第十章中，我们将研究如何调用内部例程和其他 bat 文件。）

定义作用域提出了一个有趣的问题。如果调用一个工具 bat 文件来执行特定任务，那么很有可能这个任务的部分内容是设置并返回某个变量。有一种方法可以让变量在执行 endlocal 命令后仍然生效，我将在第十六章中分享这个方法。

### 延迟扩展

setlocal 命令是一个多功能工具。除了定义作用域外，当与非常具体的参数一起使用时，它还启用了延迟扩展：

```
setlocal EnableDelayedExpansion
```

恰如其分，参数是完全展开的，没有任何缩写的迹象。

延迟扩展实现了两轮变量解析：初始解析和延迟解析或扩展。当解释器执行 bat 文件时，它会逐行处理代码，首先读取或解析一行，然后执行该行。初始解析发生在解释器解析这一行时，而延迟扩展发生在它执行这一行时。

这个特性允许一些在大多数编程语言中无法实现的有趣行为。例如，你可以将一个变量的值视为变量本身——或者它的值可以作为另一个变量名的一部分。在 列表 3-1 中，Toyota 既是变量名，也是值；这不是巧合。

```
setlocal EnableDelayedExpansion
set Car=Toyota
set Toyota=Prius 
```

列表 3-1：设置启用延迟扩展的 Car 和 Toyota

首先，我们需要使用 setlocal 命令并提供启用延迟扩展的参数。接下来，我们将 Car 设置为汽车的品牌，这里是 Toyota。但 Toyota 生产多个车型，如果我们想捕获特定的车型，可以将定义为 Toyota 的变量设置为 Prius 的值。

#### 值与变量

如前所述，Toyota 既是一个值，也是一个变量。它是 Car 变量的值，同时也是一个包含 Prius 值的变量。现在，我们可以执行三条语句，将三个变量输出到控制台，如 列表 3-2 所示。

```
> con echo                 Car = %Car%
> con echo           Car Again = !Car!
> con echo   Delayed Expansion = !%Car%! 
```

列表 3-2：通过三种不同方式解析 Car

下面是 列表 3-2 生成的输出：

```
 Car = Toyota
          Car Again = Toyota
  Delayed Expansion = Prius 
```

Car 的第一次解析现在显得相当平常。将变量用百分号包围（%）会解析为它的值 Toyota。第二条命令引入了新东西：使用感叹号（!）作为分隔符来解析变量 !Car!，而不是百分号。被感叹号包围的变量同样会解析为 Toyota，但为什么要使用两个不同的符号来完成相同的功能呢？答案将在我们查看最后一条命令后显现。

第三种解析方法真正展示了延迟扩展的强大功能。变量被百分号包围，接着又被感叹号包围。解释器首先将 %Car% 解析为 Toyota。请确保你坐好，接下来的部分可能让你吃惊：这个值现在被感叹号包围，这导致它再次被解析，因此 !Toyota! 变成了 Prius。将所有内容组合在一起，变量被解析如下：

!%Car%! → !Toyota! → Prius

为了回答关于两个不同符号执行相同功能的问题，解释器需要这两个符号来完成解析，因为现在我们有了两轮解析：百分号用于内层解析，而感叹号用于外层解析。（我们能不能用两组双百分号将变量包裹起来？不行，for 命令的语法对双百分号有特定用途，你将在 第十七章 中学习到这个内容。）

演示延迟扩展如何影响代码的最佳方式是运行相同的代码，但不启用延迟扩展。如果我们从列表 3-1 中移除 `setlocal`，则列表 3-2 的结果是：

```
 Car = Toyota
          Car Again = !Car!
  Delayed Expansion = !Toyota! 
```

如果没有延迟扩展，感叹号将被视为普通文本，对批处理没有任何意义。!Car! 变量根本没有被解析；解释器甚至不会把这三个字母当作一个变量。!%Car%! 变量经历了一轮变量解析，但感叹号只是陪衬。

在第二章中，我巧妙地避开了一个问题，提到过变量名不应该以数字开头。从技术上讲，你可以设置这样的变量，但你无法通过百分号解析它；只能通过感叹号，并且必须启用延迟扩展。处理这个小怪癖的最佳方法是避免让变量名以数字开头。

现在我们有一个变量，它可以解析为一个值，这个值再次被解析为另一个值。这通常在那些现代编译语言中难以做到，或者根本做不到。说实话，尽管整个词既是变量又是值听起来很酷，但在现实世界中并不常用，但部分变量名有很多应用场景。

#### 部分变量名

当解析值仅作为变量名的一部分使用时，这种技巧变得更加有趣和实用。为了演示，考虑以下设置命令，它们定义了五个城市的标志性美食：

```
set foodNash=Hot Chicken
set foodNYC=Thin Crust Pizza
set foodChic=Deep Dish Pizza
set foodNO=Muffuletta Sandwich
set foodSTL=Frozen Custard 
```

每个变量名是由食物和城市的常用缩写连接而成，并被设置为该城市著名的菜肴。这里只展示了五个变量，但你可以定义任意数量的变量。

以下一组变量使用了五个城市的相同缩写，每个缩写后附加了 "Full"，并被赋予该城市的全名：

```
set NashFull=Nashville
set NYCFull=New York City
set ChicFull=Chicago
set NOFull=New Orleans
set STLFull=St Louis 
```

现在，考虑这个带有两种延迟扩展示例的 `echo` 命令：

```
> con echo The best !food%city%! can be found only in !%city%Full!.
```

如果 city 被设置为 NO 并启用了延迟扩展，那么这个命令会将以下内容写入控制台：

```
The best Muffuletta Sandwich can be found only in New Orleans.
```

为了理解这一过程，让我们先看看 !food%city%! 变量。内部变量 city 和它的百分号符号被解析为 NO，从而揭示了 foodNO 变量。接着，感叹号定界符将其解析为最美味的三明治；不，这不是一份华丽的火腿芝士三明治。总结一下：

!food%city%! → !foodNO! → 穆夫尔塔三明治

同样，城市的全名也会通过两步解析。这里唯一的区别是，变量名中的硬编码部分位于要解析的部分之后：

!%city%Full! → !NOFull! → 新奥尔良

`echo` 命令对不同的城市值表现不同，这一点很重要。它会根据变量设置为 NYC、Nash、Chic 和 STL 时，依次向控制台输出以下四句：

```
The best Thin Crust Pizza can be found only in New York City.
The best Hot Chicken can be found only in Nashville.
The best Deep Dish Pizza can be found only in Chicago.
The best Frozen Custard can be found only in St Louis. 
```

我在这一节开始时提到过，将解析后的值作为变量名的一部分更为有用。这个例子是为了教学目的，但你可以很容易地将这种技术扩展到更实际的应用中。在专业领域中，与城市中心的美食领域不同，你可以创建一组变量，根据不同地点定义文件传输路径，例如 pathNYC、pathNash 和 pathSTL。然后，一条命令就可以利用相同的延迟扩展技术，将文件传输到多个目的地中的一个。（我将在第五章中再次使用这种技术，讨论子字符串操作。）

创意程序员可以几乎无限制地使用延迟扩展，我们将在第二十九章中探讨数组和哈希表时，深入了解一些这些应用。第二部分中的 `for` 命令（见第 II 部分）将大大依赖延迟扩展，或许它最有趣的应用将在第十六章中展示，在那里一个变量将能够同时保存两个值。

### 命令扩展

`setlocal` 命令也接受一个参数，用于开启命令扩展。与延迟扩展不同，命令扩展默认应处于激活状态，但你可以通过以下命令显式启用它们：

```
setlocal EnableExtensions
```

启用命令扩展解锁了大量额外的功能和可用选项，适用于多个批处理命令。例如，`for` 命令对于任何批处理程序员来说都是不可或缺的。我们尚未讨论它，但批处理有一种变体，当命令扩展禁用时使用。启用命令扩展后，它变成了一匹动力十足的工作马，至少有 10 种形式。即使是第二章中讨论的 `set` 命令（通常不被认为是动态或有趣的命令）也有了这个设置后，附加的功能和可用选项。具体功能因命令而异，你可以通过命令提示符上的 `help` 命令（在第二章中也有介绍）获取它们的详细信息。

为了演示通过启用命令扩展解锁的额外功能，返回命令提示符并输入上一章中的相同命令，以获取关于 `set` 命令的文档：

```
**help set**
```

在简短的几行文字后，解释当命令扩展未启用时命令的作用，解释器将显示以下行：

```
If Command Extensions are enabled SET changes as follows:
```

以下是所有已解锁的扩展功能。信息量太大，无法全部展示，但在这个小样本中，展示了两个先前无法使用的选项：

```
Two new switches have been added to the SET command:

    SET /A expression
    SET /P variable=[promptString] 
```

我在第二章中提到了这些选项，但没有提到命令扩展会启用它们。帮助命令在启用命令扩展时，比在禁用时提供更多的 set 命令功能信息，许多其他命令也同样如此。随着我介绍更多的命令，我鼓励你通过帮助命令进一步调查它们，以查看更多的用途和选项，并了解命令扩展开启时会启用哪些功能。

### 关于 setlocal 和 endlocal 的最终想法

在编写 bat 文件的二十年中，我对使用 setlocal 和 endlocal 命令有一些强烈的看法，我并不忌讳分享它们。每个我编写的高层 bat 文件，在代码的最前面或靠近最前面的位置都有这个命令：

```
setlocal EnableExtensions EnableDelayedExpansion
```

我将高层 bat 文件定义为没有从其他 bat 文件调用的 bat 文件。我很少遇到不希望启用命令扩展和延迟扩展的情况。这些额外的功能几乎没有成本。就像你可以把一辆丰田变成一辆兰博基尼，而没有像成本和油耗这样的问题。但在那种罕见的情况下，你可以通过 DisableExtensions 和 DisableDelayedExpansion 参数禁用这些功能。

此外，每当我编写可能对其他代码产生不良影响的逻辑时，我会在该逻辑前加上一个没有参数的简单 setlocal 命令，并用相应的 endlocal 命令结束它。别担心；延迟扩展仍然是从原始的 setlocal 命令中启用的。你甚至可以嵌套多个 setlocal 和 endlocal 命令，在子部分内创建具有定义范围的代码子区块，但不能超过 32 层深。我从未遇到过接近这个限制的情况，但如果你遇到，可以在被调用的例程或其他 bat 文件中进一步嵌套。（关于这些调用是如何执行的，我会在第十章中讲到。）

为了完整性起见，最好让原始的 setlocal 命令在 bat 文件的末尾有一个相应的 endlocal 命令，但如果省略，解释器会在退出高层 bat 文件前执行一个隐式的 endlocal。

重要的是，这本书是在假设启用了命令扩展和延迟扩展的前提下编写的。通常情况下，我不会让你感到无聊去了解在这些设置下解锁了哪些功能，哪些没有。如果你在测试中发现书中的示例无法正常工作，请确保你在执行该命令时使用了两个启用参数。

> 注意

*我只有一个例外，就是关于所有高级 bat 文件都以之前提到的特定 setlocal 命令开始的规则，这个例外出现在本书中。在后面的章节中，我将提供一些非常简短的 bat 文件示例，可能只有两三行。这些简单的示例可能不需要这个命令，它的使用可能会把注意力从当前话题中分散开。在这些情况下，我不会包含该命令，但请理解，它本来可以并且应该存在。*

### 总结

本章的主要内容是 setlocal 命令，它定义作用域并启用命令扩展。最重要的是，它启用了延迟扩展，为定义和使用变量开辟了广阔的可能性。

启用延迟扩展后，你看到如何仅通过一个命令，根据定义城市的变量值，输出五个句子中的一个。但如果禁用了延迟扩展，你可能不得不通过五个 if 命令来查询该变量。在本章中的示例中，这将是一个不优雅的解决方案，但一般来说，if 命令是任何语言中重要的工作马，Batch 也不例外。在下一章，我将详细讨论它——而且由于这是 Batch——还会谈到它的一些特性。
