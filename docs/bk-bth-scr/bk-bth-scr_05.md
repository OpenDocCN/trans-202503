

## 4 条件执行



![](img/chapter.jpg)

if 命令，几乎所有编程语言中都有，是在条件为真时执行一行或多行代码，而在该条件为假时执行不同的代码块。

基本概念很简单，但在 Batch 中，*条件子句*，或评估为真或假的实体，与其他语言中的类似子句有很大不同。大多数比较运算符在 Batch 中是独有的，在本章中你将学习如何使用语法来确定路径或文件是否存在，以及变量是否已赋值。了解评估返回码的不同技术也很重要。

此外，你还将学习如何有效管理需要评估多个条件的情况，以及如何避免一些常见的障碍。编写一个大部分时间都能正常工作的 if 命令并不难，但在某些数据条件下，它可能会中断或无法按预期执行。

### 基本的 if 命令

在最基本的形式中，if 命令会在条件为真时执行一行或多行代码。我将展示如何扩展此命令，在相同条件为假时执行不同的代码，但我们先从其基本结构开始。

几乎每个 Batch 命令实现都以命令名称本身开始，通常后跟参数和/或选项。例如，set 命令总是以这三个字母开始。通常，它后面跟着一个由变量名、等号和一个值组成的参数，但在第二章中，你已经学到它也可以在没有任何参数或选项的情况下工作。（这样的命令会输出活动变量的列表。）

if 命令是独特的。它也以命令名称开始，但相似之处止于此；它可以跨越多行，并且有两个主要组件。以下是一般形式，你可以用代码替换斜体部分的文本：

```
if `conditional clause` (
   `true code block`
) 
```

*条件子句*是一个会计算为真或假的表达式。如果它为真，解释器会执行*真代码块*中的命令；如果它为假，则不会执行这些代码。在第十六章中，我会更深入地讨论代码块，但目前为止，代码块只是放在括号之间的一行或多行代码。

使用这种语法时，左括号不仅必须紧跟在条件子句后面，而且还必须位于同一行。其他语言可能允许（甚至鼓励）你将左括号放在下一行，并与右括号对齐，但在 Batch 中这是不允许的。然而，良好的格式要求右括号应与 if 命令的开头对齐，而中间的命令需要缩进。我的惯例是使用三个空格缩进，但任何数量的缩进都可以。以下是一个有效的示例：

```
if "%today%" equ "07/04/2026" (
   set event=sestercentennial
) 
```

条件语句 "%today%" equ "07/04/2026" 正在寻找一个已解析的变量和一些硬编码文本之间的相等性。这个条件语句相对简单，但我很快会展示使用不同的比较运算符、关键字甚至选项的更为复杂的语句。许多编程语言将条件语句放在括号内；无论好坏，在 Batch 中，条件语句是独立存在的，括号用来包围即将出现的代码块。

如果条件语句为真，将执行代码块中的命令（在这个例子中是 set 命令），导致 event 被设置为一个表示四分之一千年庆典的术语。

以下更加紧凑的单行格式与之前的例子功能等效：

```
if "%today%" equ "07/04/2026"  (set event=sestercentennial)
```

使用单行时不再需要括号。以下代码在功能上与前面的两个例子等效：

```
if "%today%" equ "07/04/2026"  set event=sestercentennial
```

从技术上讲，由于缺少括号，set 命令不再位于代码块中。没有一个简洁的术语，它现在仅仅是当条件语句为真时执行的命令。

在前面的两个例子中，我在条件语句后留下了两个空格，而且我通常会留下超过两个空格。从语法上讲，这并不是必须的，但由于没有明确区分条件语句和后续内容，稍作分隔可以提高可读性。

你甚至可以在单行中执行多个命令，通过 & 命令分隔符，如第二章中所讨论：

```
if "%today%" equ "07/04/2026"  set event=sestercentennial& set code=ugly
```

如果条件语句为真，将执行一个额外的 set 命令，这个命令恰好对代码进行自我审查。我偶尔见过这种技巧，通常是在设置错误代码和错误信息时使用，但在这种情况下，使用单行代码会让代码难以理解。

如果执行的逻辑中有任何稍微有趣的地方，请使用多行代码：

```
if "%today%" equ "07/04/2026" (
   set event=sestercentennial
   set code=elegant
) 
```

“优雅”在这里无疑是个过誉的说法，但我希望你同意，这种技巧使得代码更加易读。只需一眼，读者就能知道，如果条件为真，两个变量将被设置。

### 条件语句

前一节中的例子都使用了简单的条件语句，但该语句可以更加动态，采取许多不同的形式，并使用不同的运算符和关键字。

#### 比较运算符

一个*比较运算符*，顾名思义，用于比较两个操作数是否相等，或者一个是否大于另一个。你可能已经猜到，前面例子中的 equ 运算符表示相等，没错。

这是 Batch 比较运算符的完整列表：

equ **或** ==    相等

neq    不相等

lss    小于

leq    小于或等于

gtr    大于

geq    大于或等于

你可以选择两个功能等效的替代选项作为等号运算符。为了与用于赋值的单个等号区分开来，例如在 set 命令中，Batch 使用双等号作为比较运算符。我偏好的语法是 equ 运算符，因为它看起来与其他的类似，但有些程序员因为相反的原因更喜欢使用 == 运算符。

neq 运算符会在比较的两个操作数不相等时将条件子句评估为 true。最后四个运算符用于判断哪个操作数大于或小于另一个。例如，假设 age 被设置为一个数字值，以下单行代码块仅在变量设置为大于 12 的值时执行：

```
if %age% gtr 12 (
   > con echo Adult Movie Theater Ticket Required
) 
```

你可能会尝试将 %age% > 12 作为条件子句，但大于符号在 Batch 中已经有一个定义的用途；事实上，它在此代码块中用于向控制台写一条短消息。因此，你必须使用三个字符的字母代码 gtr 作为运算符。同样，本节列出的运算符用于大于或等于、小于以及小于或等于比较。

不太直观的是，这些运算符也适用于字母数字值。所有数字小于所有字母；a 小于 A；A 小于 b；b 小于 B；以此类推。这不会结束更大的争论，但至少在 Batch 的世界里，Picard 大于 Kirk。

#### 条件子句关键字

你会在 if 命令的帮助文档中找到以下不可或缺的关键字，但不要搞错了；这些关键字是特定于条件子句的：

exist    exist 关键字检查路径或文件是否存在，如果找到则返回 true。你可以将路径或文件硬编码，或者为了灵活性，你可以使用包含潜在路径或文件的变量：

```
if exist C:\Batch\myFile.txt      set do=something
if exist %pathAndFileName%        set do=something 
```

你还可以将多个变量串联在一起以构建路径或文件名。

defined    使用 defined 关键字的以下条件子句检查变量是否已定义——也就是说，它是否解析为任何值，即使是一个空格？一个常见的错误是将百分号放在变量两边，但以下是使用该关键字的正确语法：

```
if defined varThatMayBeEmpty      set do=something 
```

这与以下使用百分号解析变量的代码功能等效：

```
if "%varThatMayBeEmpty%" neq ""  set do=something 
```

这个关键字常用于验证期望的输入变量。如果一个或多个变量未定义，你可以采取适当的措施，可能会启动中止操作。

not    not 关键字在条件子句的最前面时会否定整个条件子句。这在为变量设置默认值时非常有用，特别是在变量尚未被其他人或其他程序设置时。例如，下面的代码确保 skyColor 被设置为它通常的颜色：

```
if not defined skyColor           set skyColor=Blue 
```

你可以将 not 关键字与 exist 关键字结合使用，以判断特定文件是否不存在。掌握了这一点，你就可以创建文件、发起中止操作，或者根据你的应用需求做其他事情。一些程序员会将 not 关键字与 equ 运算符一起使用，但我认为这样做最多只是勉强可行，我更倾向于单独使用 neq 运算符。从逻辑上讲没有区别，但不论你偏好哪种方式，都要保持一致。

警告

*经过二十年的批处理编码，我仍然会不自觉地在 exist 关键字末尾加上 s，尽管我不太愿意承认这一点。Notepad++ 每次都会忠实地提醒我，因为它会加粗关键字；那个多余的字符会让整个单词失去加粗效果，从而使它显得突出。没有这样的编辑器，自己写代码要小心。*

#### 不区分大小写选项

if 命令有一个选项，就像我们之前看到的关键字一样，它适用于条件语句。/i 选项使得条件语句中的相等（和不等）运算符不区分大小写。

举个例子，下面的 if 命令中，如果没有选项，条件语句只有在 myMood 完全等于 happy 时才会返回 true——这是不等式右侧的硬编码值：

```
if "%myMood%" equ "happy"         set do=something
```

下面是添加了 /i 选项的相同代码：

```
if /i "%myMood%" equ "happy"      set do=something
```

现在，如果变量的值为 HAPPY、Happy、happy 或该词大小写变化的其他 29 种可能组合时，条件语句就会返回 true。

> 注意

*/i 选项可能看起来与我之前提到的其他选项以及未来提到的选项有点不同。如前所述，尽管解释器不区分大小写，我在写批处理命令时总是使用小写字母。选项也不受大小写影响。尽管如此，由于选项通常只是一个斜杠后跟一个字符，我通常会将其大写以突出显示。但根据字体的不同，大写字母 I 经常看起来像小写字母 L，因此我在使用 /i 选项时会偏离我的个人习惯，这个选项最常与 if 命令一起使用。是的，我知道这个选项与不区分大小写有关，讽刺的是这一点我并不忽视。*

#### errorlevel 变量

在调用可执行文件或执行多个批处理命令后，返回代码会存储在 errorlevel 伪环境变量中。（第一章中复制文件的命令就是一个会设置此变量的例子。）你将在第二十一章中了解更多关于伪环境变量的内容，但现在，先把 errorlevel 看作是一个包含返回代码的变量，你不应该使用 set 命令设置它。（如果你这样做，就会破坏 errorlevel 变量。）errorlevel 变量可以像其他变量一样在 Batch 中通过 if 命令进行评估。例如，下面的命令将返回代码为 1 或更大的情况视为失败：

```
if %errorlevel% geq 1    set msg=FAILURE
```

Batch 还支持一种古老的语法，仅适用于这个特殊变量，其中百分号符号和等号运算符被省略。以下代码与前面的示例功能等效：

```
if errorlevel 1          set msg=FAILURE
```

起初，这看起来可能简化且吸引人，因为省略了内容而没有新增任何内容，但语法掩盖了一个令人惊讶的陷阱。许多 Batch 编程人员误将这个条件语句理解为检查返回码是否等于 1。毕竟，用返回码 0 测试时，确实返回 false，用返回码 1 测试时，确实返回 true。但条件语句 `errorlevel 1` 等同于 `%errorlevel% geq 1` 和 `%errorlevel% gtr 0`。它对所有正整数返回 true。

将这种语法与 `not` 关键字结合使用，效果将更加晦涩：

```
if not errorlevel 0      set msg=The Return Code is NEGATIVE
```

这看起来像是一个在返回码不等于 0 时评估为 true 的条件语句吗？实际上它是返回码大于或等于 0 的否定。`%errorlevel% lss 0` 条件语句功能等效，且可读性更强。

缺乏比较运算符的语法的另一个问题是，通常情况下，0 代表良好的返回码，而其他所有值，包括负值，都表示某种问题。

`neq` 运算符使得这个条件语句对所有非零值返回 true：

```
if %errorlevel% neq 0    set msg=FAILURE
```

你可能会遇到这种晦涩的语法，因此理解其工作原理很重要，但更重要的是不要传播它。始终使用百分号符号（或感叹号）和比较运算符来评估 `errorlevel` 伪环境变量。

### if...else 结构

编程语言中的一条不成文规则是，if 命令必须配有 else 关键字。前面提到的关键字与条件语句相关，但这个关键字则与 if 命令本身紧密相连。下面是 if...else 结构的一般形式，再次提醒，斜体文本必须替换为代码：

```
if `conditional clause` (
   `true code block`
) else (
   `false code block`
) 
```

前两行和第三行开头的右括号与我在本章开头展示的通用形式相同。接下来是 else 关键字，紧随其后的是 false 代码块，用第二对括号括起来。这表示当条件语句评估为 false 时执行的代码。

下面是一个简单的 if...else 结构示例：

```
if %fahrenheit% gtr 70 (
   set pants=shorts
) else (
   set pants=jeans
) 
```

如果 `fahrenheit` 变量大于 70，则 `pants` 变量设置为 shorts。否则，`pants` 变量设置为 jeans。总有一个代码块会被执行。

你可以将此结构压缩成一行代码：

```
if %fahrenheit% gtr 70 (set pants=shorts) else (set pants=jeans)
```

包围 false 代码块的括号在技术上是可选的，但为了可读性，建议包含括号。

除非你对阅读你代码的人不屑一顾，否则单行的 if...else 结构通常不是一个好习惯，虽然对于最简单的任务你可能会例外。

与其他语言不同，在 Batch 中，else 关键字不能单独写在一行上；它甚至不能是行的开头或结尾。为了清晰地标记这两个代码块，最好将关键字夹在一对闭合和打开的括号之间，写在同一行。

### else if 构造

if...else 构造非常适合逻辑流程中只有两个分支的情况，一个用于 true，另一个用于 false。当分支超过两个时，else if 构造允许多个条件语句。清单 4-1 有三个语句和四个分支，每个条件语句对应一个分支，默认分支则在没有任何条件语句评估为 true 时执行。

```
if %fahrenheit% gtr 80 (
   set pants=shorts
) else if %fahrenheit% gtr 60 (
   set pants=light khakis
) else if %fahrenheit% gtr 32 (
   set pants=jeans
) else (
   set pants=lined jeans
) 
```

清单 4-1：具有四个逻辑分支的 else if 构造

该逻辑假设 fahrenheit 被设置为描述温度的整数。如果大于 80 度，第一个 set 命令将执行。如果大于 60 度，也就是说在 61 到 80 度之间（包括 80），第二个 set 命令将执行。如果前两个条件语句为 false 且温度高于冰点，第三个 set 命令将执行。如果所有三个条件语句为 false，则温度为 32 度或更低，第四个也是最后一个 set 命令会分配一条非常暖和的裤子。

在第一个 else 关键字后面没有紧跟着左括号。相反，它后面跟着另一个 if 命令，并带有自己的条件语句，然后才是左括号。

清单 4-1 包含两个 else if 语句，但根据需要你可以编写任意数量的条件语句。解释器会执行第一个评估为 true 的条件语句对应的代码块；之后，控制跳转到整个结构的末尾，不会继续评估其他语句。

很多时候，如果没有任何条件语句为 true，你可能需要执行一个最终的代码块，也就是默认的代码块。例如，如果清单 4-1 未能设置某个变量，那么有人可能会在没有穿适当衣物的情况下离开家。最后的 else 关键字后面没有 if 命令，因此它的代码块（默认代码块）会在前面三个条件语句都未评估为 true 时执行。

在清单 4-1 中，fahrenheit 被用来判断它落在哪四个范围中的哪个范围。这是使用 else if 条件语句的常见方式，但它们并不一定要紧密关联。每个条件语句可以检查完全不同的变量，或者使用之前提到的三个关键字。例如，下面是清单 4-1 的重新构想，只有三个条件语句发生了变化：

```
if /i "%season%" equ "Summer" (
   set pants=shorts
) else if exist C:\Batch\Spring.txt (
   set pants=light khakis
) else if %celsius% gtr 0 (
   set pants=jeans
) else (
   set pants=lined jeans
) 
```

第一个条件子句执行不区分大小写的相等比较，比较已解析的变量与硬编码文本。第二个子句是检查文件是否存在，第三个子句是检查 celsius 变量的值是否高于冰点。再次由于默认的代码块，这段代码保证将变量设置为四个值之一。

### 增强的相等性判定技巧

如果我不提到与这些条件子句相关的一个重要警告，我将感到遗憾。在本章的一些示例中，我将相等式两侧都用双引号括起来，但即使没有它们，命令通常仍然会工作。以下两个 if 命令非常相似，但*功能上不*等价：

```
if /i "%myMood%" equ "happy"      set do=something
if /i %myMood% equ happy          set do=something 
```

如果 myMood 设置为 happy，则子句评估为 true；如果设置为 sad，结果为 false。无论哪种情况，它对这两个命令都有效。

这很棒，但现在假设变量没有设置，或者它被设置为 null 或某些空格。没有双引号的命令会崩溃，但它通过以下含糊的消息提示了问题（假设你没有使用 第二章 中提到的 echo off 命令）：

```
happy was unexpected at this time.

C:\Batch>  if /i  equ happy          set do=something 
```

这里的第一行是错误消息，接下来是困惑解释器的内容。要理解这个错误，我们必须像解释器一样思考。一旦它看到 if 命令开始这一行，它期望接下来是有限列表中的某个项（可能是 not、exist、defined 或 /i），任何无法识别的内容都会被假定为条件语句的左侧部分。显然，它找到了 /i。假设接下来没有出现三个关键字之一，解释器现在期望的是三个特定顺序的项目：一些文本；一个运算符，如 equ、neq 或 ==；以及更多文本。如果 myMood 的值几乎是任何东西，它将被解析为第一个文本字段。解释器接着会很高兴地找到 equ 运算符，并且知道它正在处理一个相等式，它会将硬编码的 happy 解释为这个相等式的右侧。*成功*。

当变量解析为空或任何数量的空格时，所有的逻辑就会崩溃。解释器看到 if /i 开始语句，因此它不期望接下来看到 equ。not 关键字本来是合理的，但不是 equ。因此，它错误地认为 equ 是可能的相等式的左侧，而接下来的内容应该是运算符。但接下来是 happy 文本，而运算符列表显然不包含这个单词。正如消息所述，解释器此时不期望看到 happy。*失败*。

幸运的是，有两种评估可能解析为空的变量的方法。

#### 前导点技巧

解决这个问题的一种常见技巧是，在等式的每一边加上一个点符号，或者几乎任何字符，只要它一致应用，这样解释器就一定能在等式两边找到内容：

```
if /i .%myMood% equ .happy         set do=something
```

前导点技巧在变量设置为空时效果很好，因为命令会解析为 if /i . equ .happy。点符号不等于点符号加上单词，所以它被评估为 false，然后我们继续。如果变量被设置为 happy，命令将解析为 if /i .happy equ .happy，并且会找到相等性。*成功*。

但我不太喜欢这种技巧，因为它容易受到另一个陷阱的影响。现在假设变量被设置为一个由两个单词组成的情绪，比如“恼怒的沮丧”——从多个方面来看，这与 Batch 代码无关，实在不好处理。再次出现问题：

```
depressed was unexpected at this time.
C:\Batch>  if /i .irritably depressed equ .happy            set do=something 
```

别灰心。解释器被嵌入的空格骗了。别告诉别人，但它真的没有那么聪明。它认为.irritably 是子句的左边，并将 depressed 视为完全意外的运算符。*失败*。但是，还有另一种技巧。

#### 双引号技巧

回到最初的例子，这将我们带回到在等式两边加上双引号的情况：

```
if /i "%myMood%" equ "happy"      set do=something
```

这里的双引号与前导点提供的内容类似，但并不仅仅是如此。

解释器将双引号内的所有内容视为一个整体。当带有嵌入空格的变量被解析时，解释器会看到如下内容：

```
if /i "irritably depressed" equ "happy"
```

尽管有嵌入空格，解释器将“irritably depressed”视为一个整体，或者在这种情况下视为等式的左侧，右侧为“happy”。结果是 Batch 正确地识别出这两个实体是不相等的。*成功*。

如果被查询的字母数字变量可能未设置，或者可能包含嵌入的空格，我几乎总是会在等式的每一边加上双引号。然而，你可能注意到我在条件子句中没有加上双引号来包围%errorlevel%。该变量总是被设置为一个数字，因此不需要引号。更重要的是，当解释器看到没有引号的数字进行比较时，它会做数值比较，意味着 000 等于 0。加上引号则会进行文本比较，“000”就不等于“0”了。

#### 前导点与双引号

在比较字母数字值时，我*通常*会在等式的每一边加上双引号。当一个值为空时有效；当一个值是一个或多个空格时有效；当一个值中有嵌入的空格时有效；当一个值是更典型的非空格值时也有效。然而，我之所以使用非定语修饰词*通常*，是因为有一个非常细微的点。

假设有一个变量包含一个带有尾随空格的值。也许值 sad 是通过在尾部添加空格来填充的，变成了四个字符的值。这与三个字符的值 sad 相等吗？从最纯粹和最准确的角度来看，不，它们是不相等的——使用双引号方法正确地可以发现它们是不同的。但在一个不那么严格的场景下，你可能会认为这些值是相等的。

使用点号方法会找到两个值相等，因为尾随空格只是成为了等号左侧与操作符之间的一个普通空格。在这种尾随空格的狭窄情况中，点号方法更好，但它只在变量没有嵌入空格的情况下才有效。

最终分析，双引号技巧远胜于点号方法，虽然在某些特定情况下它不是。养成几乎在所有非数字比较中使用双引号的习惯。

> 注意

*Batch 提供了一个有趣且紧凑的替代方案来代替`if`命令，尽管它的行为有所不同。它不是一个命令，没有任何关键字，甚至不支持条件语句。在第二十八章中，我将回到条件执行的话题，并提供更多关于它是什么的信息，而不是它不是什么。*

### 总结

`if`命令在几乎所有，甚至是所有，编程语言中都是必不可少的，Batch 也不例外。在本章中，你了解了条件语句，包括其比较两个操作数的有效运算符，以及用于验证变量、路径或文件是否存在的关键字，以及当条件为真或假时会发生什么。你还学习了如何评估多个条件语句，以便有条件地执行多个逻辑分支。

如常见情况，Batch 给了你更多需要考虑的内容，因此我详细介绍了增强条件语句的有用技巧，比较了字母数字值和数字值。但是，什么样的值算作字母数字值或数字值呢？我将在接下来的两章中讨论数据类型，来回答这个问题。
