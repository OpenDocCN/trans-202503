

## 第十二章：12 输出、重定向和管道



![](img/chapter.jpg)

现在你可以使用 Batch 做很多事情，比如设置、重置和查询各种数据类型的变量，调用例程和其他 bat 文件，执行算术运算；然而，你学到的大部分内容不会产生持久的影响（除了文件移动和能够持久设置变量）。在 bat 文件的短暂执行结束时，所有被操作的位和字节可能会消失在空气中，就好像这个 bat 文件从未存在过一样。

我将留待以后再讨论 Batch 的形而上学问题，但每当任何类型的代码被执行时，目的就是产生某种变化。一些编码人员仅将 Batch 用作一个包装器，在调用可执行文件之前设置一些变量来实现这种变化，但 Batch 能做的远不止这些。在本章中，我将讨论两种输出类型：解释器输出（stdout 和 stderr）和你，编码人员的输出。了解了这一区别后，你将能够将不同类型的输出写入控制台、新文件和现有文件。通过这种方式，你可以将所有那些变量、调用和算术运算的结果存储在你的计算机上。

讨论这两种输出类型会引出几个相关且有趣的话题。其中一个是将任何 Batch 命令的输出重定向到文件，另一个是管道技术，将一个命令的输出传递到另一个命令。也许最重要的是，你将学会如何管理快速滚动的控制台内容——即要么保存它，要么抑制它。

### 解释器生成的输出与编码器生成的输出

当你打开或执行一个 bat 文件时，它会生成两种类型的输出：解释器生成的输出和编码器生成的输出。为了完全清楚，解释器技术上生成了所有的输出，但其中一部分输出是你，编码员，通过命令写入控制台或文件所产生的。这就是*编码员生成的输出*。作为运行的副产品，解释器还会生成你没有明确要求的输出，这就是*解释器生成的输出*。

所有 Batch 命令都会生成解释器输出；少数命令还会生成编码器输出。默认情况下，Batch 会将两种类型的输出写入控制台，如果 bat 文件稍微复杂一些，文本滚动得太快，以至于无法阅读。

echo 命令就是一个很好的例子，它可以生成两种类型的输出。在最简单的表现形式中，它会将所有的参数写入控制台。考虑以下命令：

```
echo Greetings, Earthlings.
```

执行此命令会将 清单 12-1 中所示的输出写入控制台。

```
C:\Batch>echo Greetings, Earthlings. 
Greetings, Earthlings. 
```

清单 12-1：解释器和编码器生成的输出

所需的文本“Greetings, Earthlings.”会被输出，但它并不孤单，会出现两次，且由于某种原因，当前目录会被附加到第一行之前。（假设本章中当前目录为*C:\Batch\*。）

Listing 12-1 中的两行表示完全不同类型的输出。第二行来自编码者——通过 echo 命令写入控制台的消息。第一行由解释器生成。它不是 echo 命令的输出；它是 echo 命令的*执行报告*。

这种区别既微妙又重要。至少，解释器会通过写入每个命令并附加提示符来记录每个命令的执行。默认情况下，提示符是当前目录，后跟一个大于符号。许多命令会产生额外的解释器生成的输出，比如 xcopy 命令，它通常会列出已复制的文件。

显然，交织的输出很乱，如果这个例子看起来不乱，那是因为我只展示了一个命令的输出。很快，我将向你展示如何通过将这些不同的输出发送到不同的目标来清理控制台，但首先你需要更好地理解由解释器生成的输出，实际上它是两个不同的输出。

### stdout 和 stderr

批处理将每一部分由解释器生成的输出写入两个数据流之一。*数据流*是从源（在本例中是解释器）到目标的传输信息，默认情况下目标是控制台。每个数据流由文件描述符表示，而最大的数据流是被描述为*stdout*的流，发音为*标准输出*（或较少使用的*标准输出*）。事实上，唯一不在 stdout 中的解释器生成的输出是错误消息，它们被写入文件描述符*stderr*，发音为*标准错误*。

stdout 数据流可能会变得复杂且难以理解，但它通常对你帮助极大，能帮助你确定批处理文件执行过程中到底发生了什么。你通常可以看到 if 命令的结果、哪些文件被创建等等。为了演示，以下 del 命令删除一个文件，接着是一个 set 命令，它捕获 errorlevel 作为返回代码：

```
del C:\Batch\DeleteMe.txt 
set rc=%errorlevel% 
```

这里没有产生由编码器生成的输出；所有输出都来自解释器。

如果存在*DeleteMe.txt*文件，前面的代码会删除它并将以下内容写入 stdout：

```
C:\Batch>del C:\Batch\DeleteMe.txt   

C:\Batch>set rc=0 
```

大多数变量在 stdout 中解析，比如在这个例子中，errorlevel 被解析为 0。（令人沮丧的是，解释器在某些情况下无法完全解析变量，比如在使用延迟扩展时。更多细节见第三十一章。）

标准输出（stdout）中间可以夹杂第二种解释器生成的输出，即写入到 stderr 数据流的输出，但仅在发生错误时才会有输出。例如，如果 del 命令中的文件不存在，解释器会输出如下内容：

```
C:\Batch>del C:\Batch\DeleteMe.txt   
Could Not Find C:\Batch\DeleteMe.txt   

C:\Batch>set rc=0 
```

第一行和最后一行被写入标准输出（stdout），但中间一行表示文件找不到的信息则写入标准错误输出（stderr）。理解这一点非常重要：错误消息被写入 stderr，而所有其他解释器生成的输出都会写入 stdout。为了全面了解批处理文件执行过程中发生的情况，两个输出都需要，并且除非我们采取措施干预，否则它们都会写入控制台。

（顺便说一下，别纠结于为什么即使生成了错误消息，返回代码仍然是 0。但如果非要解释的话，del 命令完成后文件不存在，从某种平凡的意义上来说，它是成功的，或者这算是个 bug。）

### 写入文件

创建、写入和追加文件是大多数编程语言的基本功能，而批处理（Batch）允许你构建包含编码器和解释器生成输出的文件。直到现在，你所看到的所有输出都被写入到控制台，并且当批处理文件完成时，窗口会关闭。

通常，你可能希望创建在批处理文件执行完毕后仍然存在的文件。你可以将数据写入文件，以便作为可执行文件或另一个批处理文件的输入。如果我想记录其他人运行我的批处理文件的频率，我可以设置它将一条记录写入到一个中央日志文件中，记录何时以及在哪个服务器上运行了该文件。你甚至可以生成报告，并将解释器生成的输出捕获到文件中，这样可以为你提供关于批处理文件执行过程中发生的事情的良好审计跟踪。

#### 来自编码器生成的输出

我已经展示了如何使用> con 语法将文本写入控制台。通过类似的语法，我们可以通过两个命令写入文件：熟悉的 echo 命令写入一条记录，而不那么熟悉的 type 命令将整个文件写入另一个文件。

##### 写入记录到文件

让我们回到外星人。与其通过控制台向我们问好，它们可能想把问候语写入一个简单的文本文件中，它们可以通过一行代码来实现：

```
echo Greetings, Earthlings.> C:\Batch\ET.txt
```

这行代码有四个不同的元素。第一个是 echo 命令，第二个是命令的参数：Greetings, Earthlings. 文本。第三个元素是大于符号（>），即重定向字符。这个字符将前面的命令输出重定向到目标，目标是第四个元素：*C:\Batch\ET.txt* 文件。将它们结合起来，前面的语句将问候语写入文本文件。

以下的替代语法执行相同的任务，但因为信息不再紧贴着大于符号，所以更容易阅读。我将重定向符号移到了前面，后面跟着目标：

```
> C:\Batch\ET.txt  echo Greetings, Earthlings.
```

如果你将此示例中的路径和文件名替换为 `con`，你将会认出这种常见的语法来写入控制台。

以下示例演示了这种语法的优势。如果外星人有多行信息需要传递，他们可以将目标文件路径和名称设置为变量，并在后续的 `echo` 命令中使用它。这种语法允许将多个重定向、目标和 `echo` 命令按顺序排列，使得更容易阅读写入文件的内容：

```
set alienFile=C:\Batch\ET.txt 
>  %alienFile%  echo Greetings, Earthlings.
>> %alienFile%  echo.
>> %alienFile%  echo Take us to your leader. 
```

在我们继续之前，我在之前的代码中悄悄加入了几个微妙但重要的功能。第一个 `echo` 命令使用了单一的大于符号来进行重定向，而后续的命令则每个使用了两个大于符号。单字符操作符会创建一个新的文件并写入内容，如果该文件已存在，则会删除它。两个字符操作符则会将内容追加到现有文件中。一个新手常犯的错误是对多个命令使用单一的大于符号，结果让初学者困惑，为什么只有最后一个命令有效，实际上每个命令都有效，只不过每次都会清空文件并写入一行文本。

另一个重要特性是 `echo` 命令后面紧跟一个点；它会写入一个空行，而不是一个点。执行完此代码后，*ET.txt* 的完整内容包括以下三行：

```
Greetings, Earthlings.

Take us to your leader. 
```

如果你需要在一行中写入一个单独的点，记得在 `echo` 和点之间留一个空格。

##### 写入文件到文件

另一个你可以与重定向结合使用的有用命令是 `type` 命令。单独使用时，该命令会将文件的完整内容写入标准输出和控制台。结合重定向时，它可以将该文件的完整内容插入到另一个文件中。以下示例将 *DetailRecs.txt* 的内容写入 *OutFile.txt*，并通过两个 `echo` 命令在前面添加一个头记录，在后面添加一个尾记录：

```
set outFil=C:\Batch\OutFile.txt
>  %outFil%  echo This is a Header Record
>> %outFil%  type C:\Batch\DetailRecs.txt
>> %outFil%  echo This is a Trailer Record 
```

请注意，只有第一个 `echo` 命令使用了单一的重定向符号，从而确保它是真正的头记录。

#### 来自解释器生成的输出

你现在知道，控制台上滚动的大多数杂乱信息是标准输出（stdout），可能还包含一些标准错误（stderr）和程序生成的输出。你也可以控制程序生成的输出的目标（控制台或文件）。缺失的一部分是如何处理解释器生成的输出。默认情况下，它会被发送到控制台，但通过一些努力，你可以将解释器生成的所有内容写入一个文件，通常称为 *跟踪文件*。

在上一节中，你学会了如何将 echo 和 type 命令的输出重定向到文件，但你可以将任何命令的输出重定向，尤其是 call 命令。在第十章中，我介绍了在 bat 文件中调用例程的概念，因此你可以创建一个包含 bat 文件主要逻辑的例程，并在文件的顶部调用它。这里的新内容是重定向操作符和在下面示例中追加到第一行的追踪文件：

```
 @call :GetTrace > C:\Batch\Trace.txt
 pause
 goto :eof

:GetTrace
 > con echo Greetings, Earthlings.
 > con echo.
 > con echo Take us to your leader.
 goto :eof 
```

这是一个完整的 bat 文件，它将问候语写入控制台并捕获追踪文件。

在第一个命令前加上@符号可以抑制 call 命令本身在控制台的显示，但不会抑制 call 命令的输出。关键的是，call 命令的输出是从被调用的例程中出来的 stdout，而该输出通过第一个命令中的大于符号被重定向，避免显示在控制台并转到追踪文件。注意，文件底部的问候语明确被发送到控制台，每个 echo 命令前都有> con 前缀。如果没有重定向，问候语将与其余的 stdout 一起写入追踪文件。

每个数据流都有一个引用或数字句柄，你可以用最少的按键引用其中之一。stdout 的引用是 1，将该引用号放在重定向符号之前，可以明确地将 stdout 重定向到追踪文件。但默认情况下，stdout 是通过大于符号（>）单独重定向的，因此以下两个命令在功能上是等效的：

```
@call :GetTrace > C:\Batch\Trace.txt
@call :GetTrace 1> C:\Batch\Trace.txt 
```

在这两个命令中，仅将 stdout 写入追踪文件，stderr 中的任何错误消息将显示在控制台上。

stderr 数据流由 2 引用，因此你可以在重定向符号之前通过修改一个字节来重定向这些错误消息：

```
@call :GetTrace 2> C:\Batch\Trace.txt
```

你甚至可以将每个数据流，stdout 和 stderr，同时重定向到完全不同的文件：

```
@call :GetTrace 1> C:\Batch\stdout.txt 2> C:\Batch\stderr.txt
```

在实际操作中，分离数据流很少有用，因为任何错误消息都不会与生成它们的命令关联。

一个远远优于此的解决方案，如 Listing 12-2 所示，是将两个输出都写入追踪文件，且通过在命令末尾使用特别晦涩的语法，其中 2 和 1 分别代表 stderr 和 stdout，来实现这一点。

```
@call :GetTrace > C:\Batch\Trace.txt 2>&1
```

Listing 12-2：将 stdout 和 stderr 重定向到追踪文件的理想技巧

如你所知，&符号是用于在单行中执行两个命令的命令分隔符。但在 Listing 12-2 中所示的方式使用时，解释器将&符号视为重定向语法的一部分。记住这一点作为另一个 bat 的警告，不要问为什么，但这是捕获追踪文件的最佳技巧。

### 抑制 stdout 和 stderr

你可以观察到 stdout 和 stderr 在控制台上滚动，或者你可以将这两个数据流保存到跟踪文件中。在其他情况下，这些数据根本不需要。有时为每次执行一个稳定且频繁运行的过程创建日志可能不值得占用磁盘空间，而且你可能不希望 stdout 和 stderr 输出到控制台，因为你希望控制台对任何程序员生成的输出保持整洁。在这种情况下，你将希望彻底抑制解释器生成的输出。有两种技巧可以做到；其中一种简单但只适用于 stdout，而稍微复杂的技巧也适用于 stderr。

#### @echo off 技巧

抑制 stdout 的简单技巧是使用 @echo off 命令。根据你对 echo 命令的了解，你可能会预期这个特定的命令会将内容输出到 stdout。毕竟，echo Hello 会将 Hello 输出到 stdout。通常，echo 会输出它的参数，但有两个例外。

off 参数指示解释器抑制（或关闭）stdout，on 参数则将其重新打开，但有一个限制。用于抑制 stdout 的 echo 命令本身是写入 stdout 的。幸运的是，Batch 允许通过在命令前加上 at 符号 (@) 来抑制单个命令对 stdout 的贡献。因此，抑制 stdout 的命令本身被抑制写入 stdout 为 @echo off。我在第二章中悄悄介绍了这个技巧来清理控制台，但并未做深入解释，今天来讲解（现在是时候了）。

如果外星人要通过控制台与我们沟通，这个简单的 bat 文件就能派上用场：

```
@echo off
echo Greetings, Earthlings.
echo.
pause 
```

第一个 echo 命令抑制了 stdout，以保持控制台的整洁和可读性。尝试去掉这一行，看看差异。效果很差；每个 echo 命令都会将两种类型的输出都发送到控制台。使用这个命令后，第二个 echo 命令仅将它的参数写入控制台。紧跟着点号的 echo 命令会写出一个空行。最后，pause 命令保持窗口打开，避免它迅速消失。最终的结果是：

```
Greetings, Earthlings.

Press any key to continue ... 
```

按下任意键，pause 命令允许 bat 文件继续执行并关闭窗口。在第三章中，我提到我在每个高级 bat 文件的开头都会使用 setlocal 命令，以启用命令扩展和延迟扩展。这个 echo 命令是唯一可能出现在 setlocal 之前的命令，从而保持控制台的整洁。不过，你也可以在 setlocal 命令前面加上一个 at 符号，以抑制其从 stdout 的执行。

作为附带说明，每个初学者 Batch 编程者可能会试图在 echo 命令后仅通过空格写出一行空白，即便这只是个意外。但这个命令只是写出 echo 的状态，而状态只有开或关。例如，在 bat 文件的开头执行以下两行，会将 ECHO is off. 输出到控制台：

```
echo off
> con echo 
```

同样，用 echo on 替换第一行会激活 stdout，输出为 ECHO is on。

@echo off 技巧还有一个注意点。尽管 stdout 被抑制，stderr 不受影响，这意味着任何未重定向的错误信息会在控制台上显示，且几乎没有上下文。

#### 重定向到 nul 的技巧

抑制所有解释器生成的输出的最佳技巧是将 stdout 和 stderr 重定向到第七章中介绍的*nul*文件。无论写入其中什么内容，这个文件始终为空，因此它有点像是一个 Batch 垃圾接收器。例如，将清单 12-2 中的 call 命令重新编写为将 stdout 和 stderr 发送到*nul*而不是跟踪文件，有效地抑制了所有解释器生成的输出：

```
@call :GetTrace > nul 2>&1
```

然而，例程的名称现在已经不准确了。（如果需要，重新命名标签为:SuppressTrace。）

这个技巧确实需要你为主线逻辑创建一个例程，但它非常有效，且相对简单，你可以用它来抑制所有被调用的 bat 文件和例程生成的输出。前导的@符号甚至可以将 call 命令本身从 stdout 中抑制。

你可以使用这种技巧来抑制任何命令的输出。例如，以下代码执行编译后的程序，同时简单地丢弃其命令行输出：

```
> nul SomeProgramWithUnwantedOutput.exe
```

在程序执行前添加（或甚至附加）重定向到*nul*文件，可以很好地解决这个问题。

### stdout 中的备注

我对 stdout 还有最后一点说明。在第二章中，我介绍了 rem 命令，它是将备注或注释简单地写入代码中的一种方式。还有另一种语法，它对 stdout 有影响。

使用 rem 命令生成的备注会被写入 stdout。然而，代码中任何以两个冒号(::)开头的行也会被视为备注，但它是一个隐藏的备注，且会从 stdout 中被抑制。请看这两个有效的备注：

```
rem This is a Remark shared to stdout.
::This is a Top Secret Remark not meant for the Hoi Polloi. 
```

你只会在 stdout 中看到第一个备注。还要注意，双冒号前不需要空格。 在第九章中，我提到标签必须以冒号开头，但第二个字符必须是不同的字符。这是因为双冒号表示隐藏的备注。

隐藏的备注并没有什么不当之处。解释代码的备注在 stdout 中可能很有用，但其他备注可能会让它变得杂乱。对于程序员来说，这是一个很好的技巧，可以在代码中仅为自己保留注释。例如，始终保持源代码修订的详细历史是件好事，但这些细节可能会把跟踪文件弄得一团糟。如果是这样，可以为此类备注使用双冒号。

### 任何命令的重定向

我已经展示过如何通过重定向 `echo`、`type` 和 `call` 命令将输出写入文件，但这只是三个例子。你可以重定向任何 Batch 命令的输出。举个例子，你可以将以下 `xcopy` 命令的输出发送到一个日志文件：

```
set copyLog=C:\Batch\Copy.log
>> %copyLog% xcopy C:\Batch\*.dat D:\Backup\ /Y /F 
```

无论是否重定向，*.dat* 文件都会被复制到 *D:\Backup\* 目录，但解释器会将列出所有刚刚复制的文件及其总数的文本附加到 *Copy.log* 文件中。它之所以是附加的，是因为使用了两个大于号；如果是单个字符运算符，则会创建一个新的文件来存储输出。

虽然你可以对任何命令进行重定向，但许多命令没有输出，或者其输出非常乏味，不值得捕捉。在下一章中，我将介绍 `dir` 命令，它将目录中所有文件和子文件夹的详细信息写入标准输出。这种信息通常很容易且经常被重定向到文件。编译程序的命令行输出是另一种值得捕捉的数据。

### 管道

重定向通常将输出发送到文件，而管道则将输出发送到完全不同的目标。*管道* 是将两个不同命令连接起来的概念。解释器通过某种方式将第一个命令的输出作为输入传递给第二个命令，像通过管子、软管、管道等 ... 其实有一个更合适的物理比喻，就是管道。用来建立这种连接的字符恰如其分地被称为管道字符，也叫竖线或直杠。在大多数键盘上，它位于回车键上方，按下 SHIFT-\ 就能输入。

到目前为止，你已经看到 `echo` 命令的结果被重定向到控制台、标准输出或某个特定文件，但你同样可以将这些结果通过管道传递给其他 Batch 命令。回想一下 第七章 中提到的 `xcopy` 命令，它在复制过程中将目标文件命名为与源文件不同的名字。当时我警告过，类似的命令有时会失败，并承诺在这一章提供解决方案，那个解决方案就是管道。以下命令显然是一个直接的复制操作，并将目标文件重新命名：

```
xcopy C:\Batch\OldName.txt C:\Target\NewName.txt /Y /F
```

如果目标路径下已经存在 *NewName.txt* 文件，这个命令会简单地覆盖该文件并继续执行。但由于 Batch 的不确定性（或者更直白地说，可能是一个 bug），如果 *NewName.txt* 不存在，解释器会有些困惑。源文件显然是 *OldName.txt*，但是 *NewName.txt* 是目标文件的名字，还是目标文件夹的名字呢？*.txt* 扩展名应该能让解释器明白，但目录名中也可以包含点（.）。（不过，给文件夹命名时加上常见的文件扩展名真是个让人羞愧的做法。）当解释器感到困惑时，它会像迷路的人一样寻求帮助：

```
C:\Batch>xcopy C:\Batch\OldName.txt C:\Target\NewName.txt /Y /F 
Does C:\Target\NewName.txt specify a file name
or directory name on the target
(F = file, D = directory)? 
```

如果你在命令提示符下输入了 xcopy 命令并看到了该信息被写入控制台，你无疑会直接输入 F 然后完成操作。如果这个 stdout 输出来自一个批处理文件，也会是同样的情况，但当这个命令在一个有重定向 stdout 的批处理文件中时，解释器本质上会向追踪文件请求响应，并会一直等待下去。某个时候，会有人调查这个长时间运行的进程，滚动到追踪文件的底部，找到前面示例中的文本。这就是程序员所说的*挂起*；它比中止更糟糕，因为执行永远不会结束。原因可能是一个无限循环，但在这种情况下，原因是解释器向一个无法响应的实体请求反馈。唯一的人工回应就是终止命令窗口，找到并修正问题，然后重新运行。

在程序中实时响应并给出答案的唯一方式是预测问题并在批处理文件执行之前编写相应代码。为此，我将在 xcopy 命令前加上 echo 命令的响应。以下的 echo F 命令只是写入 F，这是针对文件的响应，并且这个响应被作为输入传递给 xcopy 命令：

```
echo F | xcopy C:\Batch\OldName.txt C:\Target\NewName.txt /Y /F
```

现在标准输出显示 F 作为对问题的回答，尽管这个回应并不是来自一个人类：

```
C:\Batch>echo F   | xcopy C:\Batch\OldName.txt C:\Target\NewName.txt /Y /F 
Does C:\Target\NewName.txt specify a file name
or directory name on the target
(F = file, D = directory)? F
C:\Batch\OldName.txt -> C:\Target\NewName.txt
1 File(s) copied 
```

（是的，解释器和标准输出在管道符号之前的空格上做了一些处理。）

最终，解释器使用新名称将文件复制到目标文件夹。如果在管道符之前是 echo D，那么目标文件会是*C:\Target\NewName.txt\OldName.txt*。显然，这不是这里的意图，但在不同的情况下，你可以使用管道技术将目标定义为一个目录。

为了使这一过程更具通用性，你可以设置一个变量，根据目标的格式将其设置为 F 或 D。如果目标以句点和扩展名结尾，你可以假设它是一个文件；如果不是，它就是一个目录。然后你可以将解析后的变量通过回显命令传递给 xcopy 命令。

但是，当 xcopy 命令不要求反馈时，这种技术有什么效果呢？它就像试图向某人传授智慧，也许是一个不想听的青少年。就像父母的话语消失在空洞中一样，如果没有提出问题，管道传递给 xcopy 命令的信息会被完全忽略。就好像 echo 命令从未执行过一样。因此，如果需要回应，管道就会给出反馈；如果不需要回应，那它就是无害的。

管道有许多应用。在第二十四章中，你将学习如何通过将 echo 和 type 命令通过管道传递给 findstr 命令来执行一些相当复杂的文本搜索，从而允许你在字符串中找到特定文本，或者在文件中找到包含该文本的所有记录。你甚至可以通过将命令的输出传递给尚未讨论的 sort 命令来对其进行排序。

### 标准输入（stdin）

尽管本章讲的是输出，但任何关于 stdout 和 stderr 的讨论，如果不提及输入数据流 *stdin*（发音为 *standard in* 或不太常见的 *standard input*），以及它通过 0 来引用来自控制台的输入，都会是不完整的。不过，仅需简单提及即可。在大多数相关文献中，通常会将三者一起提及，仿佛它们同等重要，但尽管 stdout 和 stderr 是无处不在的，stdin 的使用却相对偶尔。

在下面的例子中，第一个命令通过 echo 将消息重定向到控制台。第二个命令则相对较新，可以视为对第一个命令的反转：

```
@> con echo Enter some data to be saved in a file:
@type con > C:\Batch\FromTheConsole.txt 
```

stdin 数据流是来自键盘或控制台的输入，在此上下文中通过保留字 con 来表示。直到现在，我只将 con 用作输出，特别是输出到控制台。最终，type 命令将 stdin 重定向到文本文件中。

该命令会暂时暂停处理。用户可以输入一行文本并按 ENTER 键将该行文本写入文件。文件可以接受多行文本，直到用户通过按 CTRL-Z 后再按 ENTER 键（当光标位于行首时）来终止命令。（我可没说过它是用户友好的。）

许多时候，你可能会在控制台请求用户的基本响应——通常是简单的“是”或“否”——我将在第十五章讨论这种交互式 bat 文件如何工作。在那些你请求用户提供更复杂输入的罕见情况下，重定向 stdin 会将数据保存到文件中，以便稍后使用。

### 总结

在本章中，我介绍了三个相关的主题：输出、重定向和管道。stdout 和 stderr 数据流是重要且有用的由解释器生成的输出，它们为你提供有关 bat 文件执行的详细信息。这些输出不同于由编码人员生成的输出——你显式创建的输出。你学会了如何通过重定向创建新文件并附加到现有文件。我展示了如何将解释器生成的输出捕获到跟踪文件中或完全抑制它。各个命令也有输出，你学会了如何将其重定向到文件并将其管道传输到其他命令。

在本书的后续章节中，我将讨论这些新工具的许多应用。在第二十二章中，使用批处理格式化简单报告将充分利用重定向。我已经提到过使用管道进行文本搜索以及通过 dir 命令进行重定向。在下一章中，我将讨论这个极为有用的命令以及你需要了解的有关目录的所有内容。
