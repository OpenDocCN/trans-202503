

## 23 递归



![](img/chapter.jpg)

本章介绍我最喜欢的主题之一：递归，或者说调用自身的代码。我将从一个更详细的定义开始，但理解这个概念的唯一真正方法是通过例子，所以我们将逐步讲解多个批处理递归的实例。其中一个将是阶乘的计算，这是一个真正经典的例子，另一个将是十进制转换为十六进制。最后一个例子将是批处理的典型应用：在目录及其子目录中进行递归搜索。然后，你将了解在编写调用自身的代码之前需要注意的一个重要限制。

### 定义递归

*递归*是一种技术，代码调用或自我调用。你可以在绝大多数编程语言中做到这一点。在面向对象语言中，一个方法内部的命令调用该方法。即使在像 COBOL 这样的过程语言中，程序内部的命令也会调用该程序。批处理语言也不例外。在递归批处理中，常规包含一个调用命令来调用该常规。较少情况下，一个批处理文件会包含一个调用命令来调用该批处理文件。

递归有一种简单的逻辑美感，可以用一个词来概括：*优雅*。在成为程序员之前，我接受过数学训练，在这两种学科中，“优雅”是最大的赞美，而“*实用*”充其量不过是间接的恭维，无论是在前者的证明中还是在后者的程序中都是如此。赞美代码的词语和短语有很多——结构良好、流畅、巧妙、聪明、深思熟虑——但“优雅”独树一帜，是程序员能听到的最佳形容词。但当有人称你的代码为“实用”时，隐含的意思是：“它会工作，但极其丑陋，甚至在逻辑上令人反感，我本可以做得更好。”在描述代码和超级模特的词汇的文氏图中，交集只有一个词：优雅。

如果你的第一反应是递归听起来像是一个无限循环的开始，那么你的谨慎是明智的。如果调用是无条件执行的，确实，结果将是一个无限循环（或者当调用堆栈溢出时，程序崩溃）。递归必须有某种条件逻辑，通常是一个 if 命令，它会根据递归情况或基准情况来执行代码。

*递归情况*会执行递归调用，而*基准情况*则不会。一个设计得当的递归调用会使你更接近基准情况。几次递归情况的执行通常会导致执行基准情况的调用，从而开始撤回递归调用的过程。理解这一点的最好方法是通过例子（接下来会讲解），逐步跟踪每一次递归调用，并记录每次调用中每个变量的状态，通常会用纸和笔记录。

递归与第九章中介绍的 while 和 do...while 命令有很大的不同。goto 命令是通过向后跳转到代码中某一部分重新执行已执行的代码，但并没有调用任何东西；没有控制权被返回。而递归技术则调用或调用它所属的代码。

递归是编程中等同于乌洛波洛斯的概念，乌洛波洛斯是一个传说中的蛇或龙在吃自己的尾巴（见图 23-1）。这个生物有着悠久的历史，源于中国、埃及和希腊的古代。它常常象征着“永恒的循环更新”、无穷、永恒，甚至炼金术。我一直认为它是代码调用自身的一个极好的隐喻，甚至在我知道它的名字之前就有这种感觉。

![](img/fig23-1.jpg)

图 23-1：代表乌洛波洛斯的图示

萨尔瓦多·达利在他的作品《乌洛波洛斯》中展现了他典型的非典型解读。虽然这肯定有些自负，但每当我完成一些递归逻辑的编码时，我总能感受到一种微小的亲近感，就像达利那样，想象他在与世界分享他的作品时所感受到的自豪。伟大的画家理应希望展示自己的作品，就像一位杰出的厨师一定期待食客品尝她的招牌菜一样。与画廊展览或餐厅开张不同，我期待的是与同行们共同进行的下一次代码审查。我稍微有点夸张（也不太愿意承认夸张的程度），但我确实为一段精妙的递归感到自豪，并且我希望你也能或将会如此。

### 阶乘

递归在任何数学或编程书籍中的经典例子都是阶乘，我认为没有理由反驳这一传统。*n* 的阶乘，表示为 *n*!，是 *n* × (*n* – 1) × (*n* – 2) … 2 × 1，或者更通俗地说，就是整数和所有小于它的整数相乘的结果，直到 1。

> 注意

*当我问一位数学家他多大岁数时，他回答：“我的最后一个阶乘生日。”他快 24 岁了，且不指望自己能活到 120 岁或 5!。我曾经装饰过一个 30 岁生日蛋糕，上面写着 6! / 4!。阶乘既有趣又有用，但我跑题了。*

4 的阶乘是 4 和 3 的阶乘的乘积，而 3 的阶乘又是 3 和 2 的阶乘的乘积，2 的阶乘是 2 和 1 的阶乘的乘积，1 的阶乘就是 1。这个模式自然要求使用递归。一个接受数字作为输入并返回其阶乘的例程可以将这个数字乘以比它小 1 的数字的阶乘。而找到第二个阶乘的最好方法就是让这个例程调用它自己。当计算一个大于 1 的整数的阶乘时，我们会触发递归情况，而当计算 1 的阶乘时，我们就达到了基本情况，并优雅地返回数字 1。那就是递归！现在我们需要将它转化为代码。

:Factorial 函数接受一个数值输入参数，并将该数值的阶乘通过我们在第二个参数中传递的变量名返回。在讲解函数本身之前，下面的调用将 4 的阶乘填充到变量 factorial 中：

```
call :Factorial 4 factorial
> con echo The Factorial of 4 is %factorial%. 
```

你可能期望一个更复杂的函数，但它其实非常简单。请注意调用命令是如何递归地调用 :Factorial 函数的：

```
:Factorial
 if %~1 equ 1 (
    set %~2=1
 ) else (
    set /A nbrLessOne = %~1 - 1
    call :Factorial !nbrLessOne! lessOneFact
    set /A %~2 = %~1 * !lessOneFact!
 )
 goto :eof 
```

如果输入参数 %~1 等于 1，if 命令会确认基本情况已满足，并将第二个参数 %~2 设置为 1，因为 1 的阶乘是 1，这样我们就完成了。

如果整数大于 1，控制将转到 else 关键字下的代码块，在这里执行递归情况的逻辑。接着，我们找出比输入值小 1 的数字：nbrLessOne。为了计算 nbrLessOne 的阶乘，我们递归地调用当前的函数并将结果存入 lessOneFact 变量。最后，我们将函数的输入值与递归调用返回的阶乘相乘，将结果赋值给第二个参数 %~2，并返回给调用代码，完成整个过程。

这种从上到下的读取方式有助于理解流程，并且是一个很好的第一步，但它忽略了后续递归调用中的具体细节。为了真正理解发生了什么，让我们通过输入参数为 4 的示例执行，重新梳理逻辑。

因为 4 大于 1，我们立即跳到 else 代码块，找出前一个数字 3，并进行递归调用。让我们留下一个关键步骤，稍后再回到这里。

第二次执行时，输入参数为 3，因此我们再次递归调用，计算 2 的阶乘。在调用命令处留下第二个关键步骤。

第三次执行时，输入为 2，因此我们再次递归调用，这次计算 1 的阶乘。在此处留下第三个关键步骤。

最终，if 命令为真，基本情况已满足，我们将值 1 作为第二个参数 %~2 返回。

现在我们可以按逆序拾取这些关键步骤，回到最初的调用。在第三个关键步骤处，我们获取到 1 的阶乘，存储在 lessOneFact 变量中，并将其与该调用的输入参数 %~1（即 2）相乘。我们将结果 2 赋值给返回参数，并将其传回。

现在，我们回到了第二个关键步骤，在这里我们将调用的输入参数 3 乘以 lessOneFact，而 lessOneFact 保存着刚刚返回的 2 的值。函数将返回结果 6，即 3 的阶乘，传回到第一个关键步骤的地方。

逻辑上，原始输入参数 4 会乘以现在包含 6 的`lessOneFact`。我们将结果 24 返回给最初的调用。这个最后的细节很微妙也非常关键：我们不是将结果传回递归调用中的某一项，而是最终将结果传回最初的调用。这样，任务就完成了。

这个概念一开始可能有些让人困惑，反复阅读最后几行是完全没有问题的。令人好奇的是，变量似乎在同一时间拥有多个状态。`nbrLessOne`和`lessOneFact`变量各自包含三个不同的值，输入参数有四个值，而我们将输出参数赋值了四次。批处理通过*调用堆栈*来完成这一过程。在执行递归调用之前，它会将相关数据存储在调用堆栈上，并且可以为多个调用执行此操作。

解释器会在执行第一次递归调用之前，将所有活跃的变量放置在调用堆栈上。在那次调用中，变量可能会赋予新的值，并再次将这些新值放在调用堆栈的顶部，然后再进行下一次递归调用。每次调用结束时，控制会从调用中返回，解释器会从调用堆栈顶部恢复相应的值，并继续处理。

顺便提一下，也可以通过非递归的方法来计算阶乘，但这些方法没有创意，远不如递归有趣。

### 十进制转十六进制

在使用递归批处理代码将十进制数字（基数 10）转换为十六进制数字（基数 16）之前，我们先来看看如何通过数学方法来做这件事。对于小于 256 的十进制数字，首先将数字除以 16，得到商和余数。这两个数字将成为十六进制数的两个数字，但有一个注意事项。每个数字的范围是从 0 到 15，但我们希望得到一个单一字符。数字 0 到 9 没问题，但如果值是两位数的十进制数，我们必须将其映射为十六进制数字。也就是说，10 映射为 A，11 映射为 B，依此类推，直到 15 映射为 F。

如果十进制数字介于 256 和 4,095 之间，它映射为一个三位的十六进制数。这需要两轮除法运算。第一次除法的余数就是最右边的十六进制数字，然后我们再将商除以 16。余数就是第二个最右边的十六进制数字，新的商则是最前面的十六进制数字。随着数字增大，类似的模式依旧适用；例如，一个六位的十六进制数字需要五次除法。

这正是适合递归的模式。以下的批处理程序将十进制数字转换为十六进制数字。与阶乘例子类似，这里有两个参数：第一个是十进制输入，第二个是包含十六进制输出的变量。以下是代码：

```
:GetHex
 set hexChars=0123456789ABCDEF
 set /A quotient = %~1 / 16
 set /A remainder = %~1 %% 16
 if %quotient% equ 0 (
    set %~2=!hexChars:~%remainder%,1!
 ) else (
    call :GetHex %quotient% recur
    set %~2=!recur!!hexChars:~%remainder%,1!
 )
 goto :eof 
```

我将 16 个十六进制字符存储在 hexChars 中，以备后用。这个例程将十进制数字除以 16，得到商，而对 16 取模得到余数。如果商是 0，结果就是一个字符。这是基本情况。我们从 hexChars 中提取适当的字符，使用余数作为偏移量。注意，0 映射到 0，1 映射到 1，以此类推，直到 9 映射到 9。然后 10 映射到 A，11 映射到 B，最终，15 映射到 F。我们返回这个单一的数字作为第二个参数的值，以完成基本情况。

当商大于 0 时，发生递归情况。商变量需要进一步转换，因此我们递归调用 :GetHex，并将其十六进制值返回到 recur 变量中，返回的值可以是一个或多个字符。我们将返回的参数赋值为该值与余数映射到十六进制数字的连接值，这就是我们刚才看到的内容。

（顺便提一下，注意那两个连接的值。我们用感叹号解决 recur 变量，因为它在代码块中作为调用命令的一部分进行赋值。最右边的字节是通过以下文本解析的：!hexChars:~%remainder%,1!。这次我在第一次解析偏移量或余数时，使用感叹号来进行延迟展开，或者使用百分号来解决。）

为了真正理解这个逻辑，让我们一步一步地进行操作，将 700 转换为十六进制数。首先，进行数学计算：700 / 16 = 43，余数是 12。12 对应于十六进制数字 C，这将是最终结果的最右边的字节。接下来，43 / 16 = 2，余数是 11，这对应于最终结果中的下一个字节，从右往左是 B。商 2 是一个一位数，因此它代表它自己。结果是十六进制数 2BC。

以下的调用命令返回值 2BC，作为 hexVal 变量的值：

```
call :GetHex 700 hexVal
```

一步步进行，由于输入参数是 700，商变量是 43，余数变量是 12。因为商不为 0，递归情况的逻辑执行。解释器将余数 12 放入堆栈中，并将 43 作为递归调用的第一个参数传入。

在这一轮中，商是 2，余数是 11。再次执行递归情况的逻辑，11 被放到堆栈中，我们将 2 作为另一个递归调用的参数传入。

在最终的一轮中，商是 0，余数是 2。由于商等于 0，基本情况的逻辑最终执行。十进制数字 2 映射到十六进制数字 2，我们将其作为输出参数传回。

现在让我们反向操作，回溯我们刚才做过的调用。解释器在 set 命令连接两个值之前，将余数恢复为 11。第一个值是刚刚返回的 2，第二个值是 B，它是从 11 映射过来的。因此，例程返回 2B 作为输出参数。

在初始遍历中，解释器从调用栈中恢复了余数变量 12。我们将两个值连接在一起，刚刚返回的 2B 和 C，这对应于 12 的十六进制值。最后，例程将 2BC 作为输出参数返回给原始调用命令。

每次调用时，递归逻辑都会确定另一个十六进制数字，最终返回一个多字节的十六进制值。乍一看，这几行代码似乎不算多，但仔细查看后，这段程序实际上相当复杂且有趣。

### 递归目录搜索

最后的两个例子很好地展示了递归，允许我们逐步跟踪递归调用，但在我的最后一个例子中，我想要一些带有 Batch 基因的东西，是其他语言中难以做到的。我们将递归地搜索一个目录及其所有子目录，以生成报告，详细列出每个文件夹中的字节数和文件数。

如果这听起来很熟悉，你可能在第十八章中学习过带有/D（目录）和/R（递归）选项的 for 命令。这个命令轻松创建了所有子目录的简单列表，但它为你处理了递归调用，并且没有留下太多修改的空间。真正的递归提供了更大的灵活性和更强大的输出控制，这正是我们在这里要做的。

在编写递归例程之前，我们需要一个计划和一些分析。为了生成详细记录，我们将使用一个 dir 命令，针对一个目录，并将其作为 for /F 命令的输入。这个例程会将目录的总数写入报告，并递归地调用自己，传递每个子目录。然后，它会处理每个子目录，对任何子目录的子目录进行递归调用。

编写这样的代码唯一的方法是查看嵌入命令的输出，在这个例子中是一个 dir 命令。根据目录的内容，dir C:\Batch\*命令可能会产生以下输出：

```
 Volume in drive C is OS
 Volume Serial Number is 2E6D-DBF0

 Directory of C:\Batch

10/31/2002  10:05 AM    <DIR>          .
10/31/2002  10:05 AM    <DIR>          ..
05/01/2001  11:18 AM               197 FourBrits.txt
02/14/2001  03:37 PM               178 FourBrits.csv
02/06/2002  12:47 PM    <DIR>          OrphanedFolder
06/20/2000  05:52 PM            89,402 outFile.dat
10/27/2002  08:36 AM    <DIR>          Subfolder
07/02/2002  02:03 PM            2,828 test.bat
               4 File(s)         92,605 bytes
               5 Dir(s)  147,918,372,864 bytes free 
```

我们需要跳过七行，五个标题记录加上两条显示一个或两个句点的目录项。在剩余的记录中，如果第二个标记等于 File(s)，我们找到了包含文件总数（标记 1）和这些文件的总字节数（标记 3）的条目。如果第四个标记等于<DIR>，我们找到了子目录的文件夹名称（标记 5）。我们还不知道子目录的详细信息，但递归调用会提供关于它的相同类型的信息。我们可以忽略其他记录，这些记录详细描述了每个文件和最后的尾部记录。

我们可以将数据写入控制台，但让我们使用第二十二章中的报告编写技巧。第一部分代码创建了标题数据，并首次调用递归的:GetFldrSz 例程，从*C:\Batch\*的内容开始获取文件夹信息：

```
 set rpt=C:\Report\FolderSizes.txt
 >  %rpt% echo  ==== In Search of Lost Disk Space ====
 >> %rpt% echo       Total Bytes    Files  Folder
 >> %rpt% echo       -----------    -----  ------
 call :GetFldrSz C:\Batch
 goto :eof

:GetFldrSz
 for /F "usebackq tokens=1-4* skip=7" %%a in (`dir "%~1\*"`) do (
    if /i "%%d" equ "<DIR>" (
       call :GetFldrSz "%~1\%%e"
    ) else if /i "%%b" equ "File(s)" (
       set ttlFiles=        %%a
       set ttlBytes=                  %%c
       >> %rpt% echo !ttlBytes:~-17! !ttlFiles:~-8!  %~1
)  )
 goto :eof 
```

集中在 :GetFldrSz 例程上，for /F 命令将 dir 命令作为输入，而该命令使用例程的唯一参数——一个目录，并在其后附加通配符作为参数。for /F 命令使用五个标记（tokens=1-5），并跳过不需要的标题记录（skip=7）。

如果第四个标记 %%d 等于 <DIR>，我们就找到了递归情况；递归调用将输入目录与第五个标记中的子文件夹名称拼接：%~1\%%e。否则，基本情况会查找第二个标记 %%b 是否匹配文本 File(s)。如果是，我们将文件夹中的文件总数和字节数存储到带有前导空格的变量中。使用那些新学到的格式化技巧，我们将记录写入报告，详细说明这三项信息。

如果目录结构不是很复杂，这段代码可能会递归生成以下报告：

```
 ==== In Search of Lost Disk Space ====
      Total Bytes    Files  Folder
      -----------    -----  ------
           24,533       12  C:\Batch\OrphanedFolder
        2,419,998        4  C:\Batch\Subfolder\SubSub\Child
           67,150        3  C:\Batch\Subfolder\Sub
              242        3  C:\Batch\Subfolder
           92,605        4  C:\Batch 
```

最后一行包含我们执行 dir 命令以了解预期输出时得到的信息，同时也显示了初始调用命令中的根目录参数。其他四行详细信息是递归调用的结果。

这个设计的美妙之处在于，无论子文件夹存在多少个，代码都会对每个子文件夹进行调用。如果没有子文件夹，代码也能正常运行。这个例程是一个框架，通过小的修改可以实现无数的辅助流程。或许只有文件数或字节数超过某个数量的目录才应当生成报告。转向文件，或许你想将最近修改过的文件标记出来，作为完全不同报告的一部分，或者将它们归档。也许你想删除旧的或过大的文件，或者删除符合某个掩码或具有某些属性的文件。可以做的事情不胜枚举。

然而，也有几个警告。之前的代码在根目录（如 *C:\*）上不起作用，因为我们跳过了 dir 命令生成的前两个详细记录（<DIR> 记录，目录后面跟着一个或两个点）。记得在第十三章中提到过，当参数仅是驱动器字母时，这个命令不会显示这两条记录。经过一些修改后，我们可以解决这个问题，但另一个警告更像是一个递归的陷阱，适用于递归的更一般情况，那就是栈溢出的可能性。

### 递归栈溢出

关于递归的一个主要警告很重要，但完全可以避免。随着每次递归调用，解释器会将数据放到调用栈中，使你可以使用一个可能有多个值的变量，每个调用一个值。但内存是有限的，且解释器为调用栈分配的内存不多。当调用栈的内存占用达到其分配的 90% 时，解释器会终止并显示类似以下的消息：

```
******  B A T C H  R E C U R S I O N  exceeds STACK limits ******
Recursion Count=507, Stack Usage=90 percent
******        B A T C H  PROCESSING IS   A B O R T E D      ****** 
```

除去对 Batch 似乎随意使用大写和空格分隔字母的所有合理批评外，这在 507 次递归调用后失败了，但 506 次并不是极限。我使用递归已经有一段时间了，从未见过在 300 次或更少的递归调用中出现崩溃，但这因机器和情况而异。每种语言都有递归的限制，但大多数通常允许更多的层级。这是可以管理的，但在编写解决方案时，你必须考虑到这一限制。

如果代码是一个更大过程的一部分，且在某种环境中中止可能会导致重大经济损失，甚至可能在半夜被叫醒来处理后果，那么你应该将递归调用限制在调用栈远低于可能溢出的阈值的情况。但请不要让这吓到你，避免使用这么棒的技术。设计良好的递归可以轻松保持在这些安全范围内。

例如，将整数转换为十六进制数字对于小于九万亿的数字只需要 10 次或更少的递归调用。即使是遍历目录结构的递归代码也不容易造成调用栈溢出。某些目录可能包含数百个子目录，但前一节中代码的仔细阅读表明，同级文件夹永远不会同时出现在调用栈上。解释器不断地从调用栈中添加和移除项目，因此它的深度永远不会超过从根目录到最深文件夹的层级，通常不会超过十几层。你可以在任何语言中安全地编写这些解决方案，包括 Batch。

### 总结

我希望你和我一样喜欢这一章。你已经从程序员的角度和解释器的角度学习了递归是如何工作的——也就是说，我展示了如何执行递归，并且还讨论了解释器如何在幕后使用调用栈。

我还展示了逐步调试代码的有用性，每次递归调用都有详细的示例。你必须小心避免递归栈溢出，但当明智地使用时，递归是一种优雅的工具。要留意需要递归解决的问提。对于任何需要迭代有限次重复步骤的过程，循环通常是第一个想到的解决方案，但要寻找递归案例和基本案例。如果你发现它们，你就能编写递归逻辑。（有关这个主题的更多内容，请参阅第二十三章。）

递归非常适合搜索目录。在下一章中，我还将讨论搜索，但焦点会更加狭窄。你将学习如何在更大的字符串、文件，甚至多个文件中搜索一个子字符串，而不是搜索你电脑上的每个目录。
