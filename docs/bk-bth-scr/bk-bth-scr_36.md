<hgroup>

## 33 堆栈、队列和现实世界中的对象

</hgroup>

![](img/chapter.jpg)

在本章中，我将从头开始构建两个 Batch 数据结构：堆栈和队列。它们都存储一组有序的有限值，唯一的区别是堆栈遵循后进先出（LIFO）原则，而队列遵循先进先出（FIFO）原则。我将详细介绍这两种数据结构的一般概念，并展示如何构建它们独特的功能。当然，你还将学习这些新工具的应用，甚至会制作一个将其他 bat 文件编译的 Batch 伪编译器。

然而，本章不仅仅是关于堆栈和队列的，它同样涉及现实世界中的 Batch 对象。我还将使用你在前一章学到的内容，为每个数据结构构建对象 bat 文件。这些对象将允许你同时维护多个堆栈或队列，并且它们理想地会激发你未来设计属于自己的现实世界 Batch 对象。我甚至会以对 Batch 面向对象设计的最终思考做结尾。

### 堆栈

*堆栈* 是一种包含有序数据项的结构，按*后进先出（LIFO）*的方式组织。毫无疑问，堆栈最好的比喻就是带弹簧的自助餐盘分配器。每个盘子的重量推动分配器底部的弹簧，使得只有堆栈最顶端的盘子可以拿到。增加更多盘子后，堆栈会下沉，只剩下新的顶盘露出。第一个添加的盘子在堆栈底部，而第一个被取出的盘子是堆栈顶端最近添加的盘子。你不能在不先移除上面的盘子的情况下访问堆栈下方的盘子。拿掉顶盘后，堆栈会升高一个盘子的高度，暴露出刚才位于下方的盘子，同时保护其他盘子免受可能不小心且不卫生的干扰。

同样，你可以将一个数据项添加或*压入*堆栈，接着添加更多的数据项。在任何时刻，你都可以检索或*弹出*堆栈顶端的数据项——即获取最近添加的项。大多数面向对象的编程语言都提供了内建的堆栈数据结构，包含将项压入堆栈、弹出最后一项和查看最后添加项（但不移除它）的方法。还应该有方法来清空堆栈，并确定堆栈是否为空。

Batch 没有这种内建的数据结构，但如果你还跟得上本章的内容，我会假设你也喜欢挑战创建非典型的 Batch 功能。Batch 中堆栈的底层结构仅仅是一个单一的变量。要将第一个值压入堆栈，我们只需将其赋值给堆栈变量。然后，我们通过在该变量前面添加新项来将后续数据项压入堆栈，这样会把现有项推到堆栈下方。

要执行 pop 操作，我们将从变量中提取出第一个项目，剩下的则保留不动。peek 操作则类似，只是我们不改变堆栈的内容。为了实现这一点，我们需要确保每个项目之间有一个分隔符，且该分隔符不会出现在数据中。空格、管道符和逗号都是不错的选择，具体取决于数据的预期内容，但我个人偏好使用制表符。如果你的数据中可能包含制表符，建议选择其他符号作为分隔符，甚至可以由用户自定义变量来设定分隔符。

为了展示实现堆栈所需的不同功能模块，我将构建并使用一个朋友堆栈。第一个任务是给变量命名；任何名字都可以，但我会使用 stkFriends 变量。我的惯例是将堆栈的名称前缀加上 stk，以便让任何偶然看到它（且知道这个惯例）的人清楚地知道这个变量是堆栈的体现。很快，我会把这些功能整合到一个对象中，但首先我将逐步讲解 push、pop 和 peek 函数的方法。

**Push**

合理的起点是*push*，这条独立的命令就足以将 Walter 推入堆栈：

```
set stkFriends=Walter▶%stkFriends% 
```

在这里以及以后的代码示例中，我使用实心箭头来表示制表符（tab）。默认情况下，大多数编辑器中它与一个或多个空格无法区分，但如果使用 Notepad++，你可以通过选择**视图** ▶ **显示符号** ▶ **显示空格和制表符**来显示制表符为箭头。（其他编辑器也有类似功能，如果你到现在一直在使用记事本，显然你是一个自虐狂。）

我在命令中两次使用了 stkFriends 变量，将其赋值给自身，并用百分号标记解析出来，前面加上我正在添加的项，Walter，以及分隔符——制表符。这实际上已经将该值添加到了堆栈顶部。你可以轻松地将硬编码的数值替换成解析后的变量，代表要添加的朋友。

如果堆栈已经为空，这条命令将其填充为第一个值，然后是一个制表符，后面没有其他内容。

**Peek**

*peek*函数能够查看堆栈顶部的项，但不会改变堆栈的内容。它只是“偷看”一下，而不是弹出一个项。我们无法知道堆栈中有多少个值，甚至是否有值，但我们知道如果 stkFriends 已被填充，其第一个制表符分隔的值位于堆栈顶部。

以下代码将堆栈顶部的内容赋值给 aFriend 变量：

```
set aFriend=&
for /F "delims=▶" %%s in ("%stkFriends%") do (
   set aFriend=%%s
) 
```

解析分隔数据显然是`for /F`命令的工作。我正在使用堆栈变量作为文本输入，由于我们用制表符分隔了变量，我将`delims`关键字设置为制表符。`tokens=1`子句是隐式的，这意味着定义为`%%s`的`for`变量解析为字符串中的第一个标记，并且由于第一个标记是最后放入堆栈的项，我们将其捕获为 aFriend。

还要注意，在`for`命令之前我清除了 aFriend 变量。如果堆栈为空，`for /F`命令不会执行，因此初始化变量可以确保空堆栈返回一个空值。

**弹出**

*pop*函数与`peek`函数非常相似，唯一的显著区别是，它还会从堆栈顶部移除返回的数据项。请注意，这个任务的逻辑模仿了之前的列表，但有两个补充：`tokens`子句和最后的`set`命令：

```
set aFriend=&
for /F "tokens=1* delims=▶" %%s in ("%stkFriends%") do (
   set aFriend=%%s
   set stkFriends=%%t
) 
```

我没有使用隐式的`tokens`子句，而是将关键字设置为`1*`。这对`for`变量`%%s`本身没有影响。它仍然解析为堆栈上的顶部项，但现在解释器将文本字段的其余部分分配给第二个标记`%%t`。由于文本字段的其余部分是整个堆栈减去第一个项，我只需使用最后一个`set`命令将缩略堆栈重新分配给堆栈变量。整个过程类似于从巧克力棒的一端掰下一块，然后把剩余的巧克力棒重新放回包装纸里。

### 队列

堆栈和队列就像巧克力和花生酱一样搭配。队列的核心是堆栈的*先进先出（FIFO）*版本。（这和后进先出相同，但 LILO 从未流行起来。）堆栈的比喻带我们去了自助餐厅，而队列的比喻带我们去了餐厅。如果你是没有预约的第一个到达者，在忙碌的时段，接待员可能会把你的名字写在名单的顶部。他们会将其他人添加到名单中，当桌子空出来时，你将是第一个被安排座位的人。名单上的其他人将按顺序上升，继续等待他们的轮次。

这是一个真正糟糕的商业创意。我将开一家煎饼餐厅，叫做 Stacks，并使用堆栈来等待入座的人。刚好在我们开始忙碌时到达的那一组人首先进入堆栈，他们会等待，或许耐心等待，因为其他人会被加入或从堆栈中移除（即被安排座位）。即使堆栈上有 20 组人，刚到的人也会得到下一个桌子。显然，这更适合用队列来实现。

在 Batch 中实现队列几乎与实现堆栈相同。唯一显著的区别是，当向队列添加数据项时，你需要将它附加到变量的末尾，而不是前面：

```
set queFriends=%queFriends%▶Walter
```

在命名法上也有一些区别。首先，因为变量代表的是队列，所以我将其前缀从 stk 改为 que，但这仅仅是其中一种约定。其次，*push*和*pop*这两个术语只有在考虑堆栈时才有意义，比如盘子分发器。当对队列进行值的添加和移除时，我将使用更简单且准确的术语*add*和*remove*，分别表示添加和移除。

其他方面，这两个数据结构是相同的。请注意，之前的 set 命令也使用了制表符作为分隔符。add 和 remove 函数分别与 push 和 pop 函数完全相同，唯一的区别是变量名称，因为它们都针对变量中第一个以分隔符分隔的数据项。事实上，它们是如此相似，以至于我将在构建队列对象时才向你展示这些函数。

警告

*我们生活在一个有限的世界中，就像自助餐盘分发器只能接受有限数量的盘子一样，批处理也有与堆栈和队列相关的限制。一个变量不能超过 32,767 字节，且由于堆栈和队列的设计依赖于单个变量来保存整个数据结构，因此堆栈或队列中所有数据项和分隔符的累积大小不能超过这一限制。例如，你可以存储 16,383 个一字节的值，或者 1,927 个十六字节的值。对于大多数应用来说，这已经足够，但如果不够，你可以使用数组和指针来构建这些数据结构，以跟踪相关的索引。*

### 现实世界中的批处理对象

在第三十二章中，我探讨了批处理面向对象的设计。我详细介绍了一个实现所有可能功能的模型，涉及面向对象编程的四个支柱，但事实上，这个模型并不代表典型的对象 bat 文件。幸运的是，堆栈和队列为批处理对象提供了有教育意义的现实世界示例。

#### 堆栈对象

我将分两部分展示堆栈对象 bat 文件，*oStack.bat*，首先是注释和主逻辑：

```
rem ****** Stack Object ******
rem parm 1 – Name of Stack 
rem parm 2 - Method: Push, Pop, Peek, Clear, or IsEmpty
rem parm 3 - Input/Output Variable:
rem            Value Pushed, Variable Popped, or Variable Peeked
rem            Boolean for isEmpty

  cmd /C exit 0
  call :%~2 "%~1" "%~3" || (
    > C:\Batch\Log.txt echo ** ERROR - Invalid Method Name "%~2"
     exit
  )
  goto :eof 
```

这段代码与上一章中的对象最显著的区别是，我将隐藏私有方法的“交通警察”替换为一个 call 命令，公开所有方法为公共方法。

在第三十二章中，所有的对象 bat 文件都有一个 for 命令，包含公共方法的列表，但*oStack.bat*对象 bat 文件只有公共方法。因此，call 命令不再维护列表，而是直接将执行引导到相应的方法，从而使所有方法都变为公共方法。由于第二个参数是要调用的方法名称，我将去掉可能的双引号，并在其前面加上冒号，以形成被调用标签的名称： :%~2。

堆栈的名称是传递到 bat 文件中的第一个参数，也是我传递给每个方法的第一个参数。传递给每个方法的第二个参数是第三个输入参数，它的用途因方法而异。但与其在这里讨论，不如直接指引你查看 bat 文件顶部的注释，明确列出了该对象及其公共方法所接受的参数。

两个管道符和调用命令后的代码块是条件执行的实际应用。（在第二十八章中，我提供了一个详细的示例，解释了为什么 bat 文件顶部的 cmd 命令会将返回代码重置为 0。）结论是，如果对象接收到有效的方法，它会成功调用该方法；如果参数是无效的方法名称，则此逻辑会将错误信息写入 *Log.txt* 并结束执行。因此，所有方法都是公共的。

如果没有这个条件执行和错误处理会发生什么呢？如果每次调用 bat 文件时都传递有效的方法名称，那么它会正常工作。然而，如果第一个参数错误地传递了指代山顶的 Peek 的同音词，解释器会将以下内容写入 stderr，且执行会继续进行：

```
The system cannot find the batch label specified - Peak
```

如果解释器没有找到或调用该方法，也没有设置返回变量（如果适用），则会导致下游结果无法预测。像这样的情况值得立即终止，以引起我们的注意，这正是条件执行和基础错误处理所要完成的任务。

以下是 *oStack.bat* 的其余部分及其在之前注释中提到的公共方法：

```
:Push
 set stk%~1=%~2▶!stk%~1!
 goto :eof& rem End :Push

:Pop
 set %~2=&
 for /F "tokens=1* delims=▶" %%s in ("!stk%~1!") do (
    set %~2=%%s
    set stk%~1=%%t
 )
 goto :eof& rem End :Pop

:Peek
 set %~2=&
 for /F "delims=▶" %%s in ("!stk%~1!") do (
    set %~2=%%s
 )
 goto :eof& rem End :Peek

:Clear
 set stk%~1=&
 goto :eof& rem End :Clear

:IsEmpty
 if defined stk%~1 (
    set %~2=false==x
 ) else (
    set %~2=true==true
 )
 goto :eof& rem End: IsEmpty 
```

我已经在“堆栈”部分讨论了推送（push）、弹出（pop）和查看（peek）功能的机制，在这个对象中，你会找到每个功能的多态版本，并且在适当命名的标签下。比如，:Push 方法将 stk%~1 变量设置为 stkFriends。为了使这个对象能够与多个堆栈一起工作，它不能显式地引用某个特定的堆栈变量。相反，它通过解析第一个参数并将其与 stk 文本连接起来，来构建堆栈的名称，然后将其设置为 %~2、制表符字符和 !stk%~1! 的拼接结果。第二个参数是被推送到堆栈上的值，制表符字符是分隔符。此命令第二次使用 stk%~1 变量来检索堆栈上的现有值，通过感叹号和延迟扩展解析该变量。最终，这会将第二个参数推送到堆栈上。

:Pop 和 :Peek 方法也使用 stk%~1 来设置和/或解析堆栈。这些方法中的唯一新特性是，我将 %~2 设置为返回值，因为这两个方法的第二个参数是要返回的变量的名称。

为了使这个对象成为一个合适的堆栈对象，它必须提供两个其他语言中堆栈数据结构典型的方法。第一个方法接受堆栈的名称作为唯一参数，并清空堆栈中的所有数据项。为了完成任务，:Clear 方法只需将 stk%~1 设置为空。

另一个方法返回一个布尔值，如果堆栈为空，则为 true；如果堆栈中有项，则为 false。:IsEmpty 方法决定 stk%~1 是否已定义。根据结果，它将第二个参数设置为 true 或 false。

现在我们准备使用堆栈对象。这四个调用将三个朋友添加到新的堆栈中，其中马蒂是最后一个加入的：

```
set stack=C:\Batch\oStack.bat
call %stack% Friends clear
call %stack% Friends push Walter
call %stack% Friends push Donny
call %stack% Friends push Marty 
```

第一个调用可能不必要，但如果 stkFriends 变量已定义，这个调用会初始化它。即使这个设计没有构造函数，你也可以把它当作构造函数来理解。

多次执行此操作后，aFriend 变量每次都会返回马蒂，因为它仅查看数据项：

```
call %stack% Friends peek aFriend
```

这在调用时也返回马蒂，但仅返回一次：

```
call %stack% Friends pop aFriend
```

下一个 pop 调用返回 Donny，这是在马蒂之前放入堆栈的值。

现在只有沃尔特仍然留在堆栈中。你可以再添加两个朋友，但沃尔特仍然处于底部位置：

```
call %stack% Friends push "The Stranger"
call %stack% Friends push Maude 
```

记住，包含空格的参数需要用双引号括起来，*oStack.bat* 使用波浪号巧妙地处理了这些。

isEmpty 调用返回一个布尔变量：

```
call %stack% Friends isEmpty bool
if %bool% (> con echo Empty) else (> con echo NOT Empty) 
```

由于堆栈中有三个项，因此布尔变量的值为 false，这条逻辑在控制台上显示“NOT Empty”。

最后，为了从头开始，我们可以清空堆栈中的所有数据项：

```
call %stack% Friends clear
```

再次调用该对象以调用 isEmpty 方法，它会返回布尔值 true。

#### 队列对象

由于堆栈和队列非常相似，我将队列对象建模为堆栈对象。但是，当你检查堆栈对象 bat 文件 *oQueue.bat* 的完整内容时，仍然可以注意到许多微妙的区别，只有一个显著的不同：

```
rem ****** Queue Object ******
rem parm 1 - Name of Queue 
rem parm 2 - Method: Add, Remove, Peek, Clear, or IsEmpty
rem parm 3 - Input/Output Variable:
rem            Value Added, Variable Removed, or Variable Peeked
rem            Boolean for isEmpty

  cmd /C exit 0
  call :%~2 "%~1" "%~3" || (
     >> C:\Batch\Log.txt echo ** ERROR - Invalid Method Name "%~2"
     exit
  )
  goto :eof

 :Add
❶ set que%~1=!que%~1!▶%~2
  goto :eof& rem End :Add

 :Remove
  set %~2=&
  for /F "tokens=1* delims=▶" %%q in ("!que%~1!") do (
     set %~2=%%q
     set que%~1=%%r
  )
  goto :eof& rem End :Remove

 :Peek
  set %~2=&
  for /F "delims=▶" %%q in ("!que%~1!") do (
     set %~2=%%q
  )
  goto :eof& rem End :Peek

 :Clear
  set que%~1=&
  goto :eof& rem End :Clear

 :IsEmpty
  if defined que%~1 (
     set %~2=false==x
  ) else (
     set %~2=true==true
  )
  goto :eof& rem End: IsEmpty 
```

我已经将变量名称前的 stk 文本改为 que，原因显而易见。:Push 和 :Pop 方法分别被 :Add 和 :Remove 方法替代，且对象顶部的注释清晰地反映了这些变化。显著的变化在于 set 命令❶，它将数据项添加到队列中，使用 :Add 方法。现在它将值添加到队列的末尾，而不是开头，这意味着第一个进来的项是第一个出去的项。

方法名称略有不同，但该对象的执行应该看起来很熟悉。以下是五个调用的示例：

```
set queue=C:\Batch\oQueue.bat
call %queue% Friends clear
call %queue% Friends add Walter
call %queue% Friends add Donny
call %queue% Friends add Marty
call %queue% Friends peek aFriend 
```

最后的调用返回一个名为 aFriend 的变量，里面包含沃尔特的值，这是第一个添加到队列中的数据项。与堆栈对象相比，它为一个非常类似的调用返回了马蒂。

### 堆栈和队列的应用

你可以在需要按顺序处理数据的地方找到队列对象的应用。你可能创建一个队列来保存从某个来源（可能是一个或多个文件）检索到的服务器名称列表。然后，当你从队列中移除每个服务器时，可以对该服务器执行特定的任务。任务可能是简单的验证服务器是否正常运行，或者可能涉及目录创建或复杂的文件移动。重要的是，队列允许你按顺序处理每个服务器。

使用交互式批处理，你可能会要求用户提供多个输入。与其一个接一个地获取数据并处理，再询问下一个，你可以提前要求所有数据，并将其全部添加到队列中。然后，bat 文件可以按顺序处理每个数据项，而无需再提问。

栈的应用并不总是显而易见的，但当你需要它时，通常它是唯一适合这个任务的工具。你可以使用栈来逆序排列字母或单词，寻找回文。递归是栈的另一个应用。每次递归调用时，解释器会将所有变量的当前状态推送到栈中。你无法直接访问这个栈，但在递归调用过多时，解释器会报告递归已超过“栈限制”（第二十三章）。这并非巧合。

使用栈，你甚至可以为 bat 文件或其他未编译的源代码创建一个伪编译器。我不想过度宣传这个功能；真正的编译器会执行许多任务，虽然我们可以在执行这些任务中的某一项（括号平衡）上取得很大进展，但它不会是万无一失的。这个伪编译器的概念是，一个开括号需要匹配的闭括号，就像大括号和方括号必须成对出现一样。它们可以深度嵌套，但方括号不能闭合大括号。

以下是 *PseudoCompiler.bat* 的完整内容，这是一个尝试平衡 bat 文件中所有括号的 bat 文件：

```
@setlocal EnableExtensions EnableDelayedExpansion
@echo off
set stack=C:\Batch\oStack.bat
call %stack% Compiler clear

❶ for /F "usebackq tokens=*" %%r in ("%~1") do (
   set rec=%%r
 ❷ for /L %%i in (0,1,100) do (
      set byte=!rec:~%%i,1!
    ❸ if .^!byte! neq .^" (
       ❹ for %%c in ({[^() do (
            if "!byte!" equ "%%c" (
             ❺ call %stack% Compiler push !byte!
          )  )
        ❻ for %%p in ("[:]" "{:}" "(:)") do (
           ❼ for /F "tokens=1,2 delims=:" %%x in (%%p) do (
               if "!byte!" equ "%%y" (
                ❽ call %stack% Compiler pop popped
                  if "!popped!" equ "" (
                     > con echo ABORT Unmatched Close Bracket
                     pause & exit
                  )
                  if "!popped!" neq "%%x" (
                    > con echo ABORT Bracket Mismatch
                    pause & exit
)  )  )  )  )  )  )

❾ call %stack% Compiler isEmpty bool
if not %bool% (
   > con echo ABORT Unmatched Open Bracket
   pause & exit
)
❿ > con echo Successful Pseudo-Compile
pause 
```

从高层次来看，这个 bat 文件接受一个文件作为唯一参数进行伪编译❶。当这段代码遇到任何类型的括号（包括圆括号）时，它会将该字符推送到栈中❺。然后，每当它遇到任何类型的闭括号时，它会从栈中弹出最后一个开括号❽，并检查它们是否是匹配的。如果不是，它将中止。当它完成读取 bat 文件后，需要验证栈是否为空❾，因为如果栈不为空，我们必须中止，因为输入中至少有一个未闭合的括号。

更深入的探讨展示了本书中介绍的许多技术，拆解一个四层嵌套的 for 命令总是很有趣。在清空编译器栈后，外层的 for /F 命令❶接受唯一的参数 %~1 作为输入，并按顺序读取每一条记录。你可以通过将 bat 文件拖放到 *PseudoCompiler.bat* 上来伪编译任何 bat 文件。

`for /L`命令❷遍历输入记录的前 100 个字节。双引号在后续的`if`命令解析时会引起问题，因此第一个`if`命令❸巧妙地过滤掉了有问题的字符。我使用了两个转义字符来进行比较，并且在下一行中，我执行了一个不带选项的`for`命令❹，将每一种可能的左括号传递给其代码块。它将大括号和中括号当作文本处理，但我必须对左圆括号进行转义。如果我发现了三个字符中的一个，我将左括号压入栈中❺。

另一个`for`命令❻是处理闭括号实例的驱动程序。它将三对左右括号（由冒号分隔）传递到其代码块中，最后的`/F`命令❼会将每一对括号拆分为两个标记。如果我检查的文件字节与第二个标记匹配，我就找到了一个闭括号，于是我将栈中最后添加的项目弹出❽。如果该字节为 null，则闭括号是孤立的，代码会中止并向控制台写入一个基础消息。如果弹出的字节与相应的左括号不匹配，程序会报告括号不匹配的错误信息。

如果我们在整个文件中都没有发现不匹配的括号，尾部逻辑会检查栈是否为空，确保所有括号都已经匹配❾，并使用布尔值进行判断。如果有孤立的括号存在，代码会中止，因为至少有一个没有匹配的左括号。在清除这个最后的`if`命令之后，括号已经全部平衡，代码成功地报告了匹配成功❿。

这段代码展示了栈的一个很好的应用，但它有局限性，正如前面提到的，远非万无一失。首先，它假设每个记录不超过 100 个字节。一般来说，错误处理方面也有很大的改进空间。至少，它应该追踪违规的行号。

当解释器处理每个记录时，它会解析由感叹号分隔的变量，因此此例程不会验证包含括号的变量名（例如数组和哈希表）。这些变量可能会解析为空，但如果两个批处理文件共享任何变量，也可能导致问题。例如，当我尝试递归伪编译*PseudoCompiler.bat*（通过复制并粘贴到自身），`popped`解析成了一个左圆括号，导致它错误地报告了一个不匹配错误。这个自我伪编译也在未配对的左括号❹被当作文本数据处理时失败。

即使在这些限制下，强调了伪编译器中的*伪*性质，这仍然是追踪典型批处理文件中大多数缺失括号的可靠方法——并且是栈的一个伟大应用。注意，这个批处理文件调用了我们之前构建的栈对象，用于四个不同的任务：清空栈、压栈、弹栈，以及判断栈是否为空。

> 注意

*关于嵌套 for 命令的最后一点，注意我为变量选择了描述性名称，确保它们之间不会冲突。我捕获整个记录（%%r），并用索引（%%i）迭代它，抓取单个字节（%%b）。然后，我将一对（%%p）括号传入循环，将它们拆分成开放括号（%%x）和隐含的闭合括号（%%y）。最后两个变量可能不够描述性，但由于它们必须是连续的字母字符，所以我的选择有限。*

### 批处理面向对象设计的最终思考

我本可以讨论堆栈和队列数据结构，而不将它们呈现为对象。本章中的方法本可以是普通批处理文件中的例程，数据结构的名称是硬编码的，但堆栈和队列的重要性使得本章不仅仅是关于这些数据结构，它还涉及到现实世界中的面向对象设计。

前一章中的面向对象示例（第三十二章）本质上是教学性的。它展示了尽可能多的批处理面向对象设计的各个方面，但本章中的这两个对象则是现实世界中批处理对象的示例。当我编写对象时，它们更可能类似于*oStack.bat*，而不是*oMovie.bat*或*oComedy.bat*。

我希望你能看到将所有与堆栈相关的代码放入一个可重用且简洁的批处理文件中的优势——也就是一个对象。这使得你能够通过这个对象编写数百个未来的堆栈，而不需要考虑堆栈本身是如何实现的。考虑到这一点，你可以重新审视数组和哈希表（第二十九章），想象为每个创建一个对象，并为其提供添加元素、检索元素和清除所有元素的方法。进一步想象为显示数组或哈希表内容、将所有元素写入文件，甚至对数组元素进行排序的其他方法。如果你敢于尝试，你甚至可以在数组对象中使用堆栈对象，反转数组元素的顺序。

现实世界中的批处理对象仅实现完成工作所需的面向对象编程功能。在严格的面向对象语言中，你必须先调用构造函数才能使用对象，但在批处理脚本中，无论好坏，你有更多的灵活性。本章中的对象甚至没有构造函数。由于批处理不是一种真正的面向对象语言，你可以自由选择只使用 OOP 范式的某些部分，而且没有编译器会对此提出异议。我本可以创建一个构造函数（它看起来会像:Clear 方法），但我之所以没有创建它，仅仅是因为我认为不需要它。

本章中也没有继承。你可以轻松地使用*oStack.bat*和*oQueue.bat*，而不需要继承，这正是我通常实现批处理面向对象设计的方式，但你总是可以扩展任何对象。未来的某个程序员，甚至可能是你，可能会创建一个继承自这些对象的子对象。

例如，如果你使用队列对象来维护一个需要以某种方式处理的服务器列表，你可能还需要查找每个服务器的 IP 地址，或者只是验证它是否在网络上。你可以将这种新逻辑封装到一个对象中，同时这个对象也继承了作为*父*队列对象的数据和方法，而程序员通常会通过笨拙地克隆队列逻辑来实现。（我希望你能感受到我输入最后那句时的轻蔑。）

我还展示了如何维护一个公共方法列表，或者简单地将所有方法暴露为公共方法。所有这些都展示了批处理面向对象设计的灵活性。你可以仅使用你想要或需要的设计元素，而不是那些你不需要或不想要的。如果需要构造函数，就创建一个；否则，不必创建。如果没有其他，针对小而专注任务的批处理文件是理想的。我鼓励你在你的批处理文件中使用我在这两章中展示的部分或全部批处理面向对象设计范式。

### 总结

在本章中，我详细介绍了两种新的数据结构——栈和队列，并向你展示了如何推入和弹出（或添加和移除）数据项。你还学会了如何查看下一个值、清除所有值，并确定数据结构是否为空。我分享了一些栈和队列应用的想法，甚至创建了一个伪编译器。它不是完美的，但非常有用，并很好地展示了如何使用栈。

我还将你学习的关于栈和队列的内容总结成了两个现实世界的批处理对象。你学会了如何构建类似的对象，使用那些对你有意义的面向对象设计组件，并学会了如何调用这些对象。我希望你能利用栈和队列对象，并寻找未来需要面向对象解决方案的问题。
