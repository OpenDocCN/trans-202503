<hgroup>

## 26 自动重启与多线程

</hgroup>

![](img/chapter.jpg)

在本章中，我将探讨程序员常遇到的两个令人头疼的问题：间歇性故障和挂起，特别是那种通常在重启后可以成功执行的类型。我将详细介绍如何在批处理文件中自动重启任何进程的间歇性故障。挂起问题稍微复杂一些，但我会介绍一种在重启前终止或杀死挂起进程的技巧。对于这两种问题，我将一步步展示如何创建解决方案，包括设计考虑、规格、编码，甚至是测试。

在过程中，我还会介绍一些有趣的命令，它们的应用不仅仅限于自动重启。其中一个命令可以让批处理文件在定义的时间段内“休眠”。另一个命令监控计算机上运行的所有进程（可以把它看作是批处理文件中的任务管理器）。还有一个命令可以终止计算机上的任何特定进程或多个进程。最终，这个讨论将引出一个看似无关的技巧——多线程或并发处理。

### 间歇性故障的五个阶段

程序员最头痛的事情之一就是间歇性故障。这可能是一个简单的 xcopy 命令，由于暂时的网络或服务器通信问题而失败。你可能需要调用一个由别人编写的程序，这个程序有时会因为无法连接到网络服务或莫名其妙地失败而无法正常运行。只需重新运行该进程就能“修复”问题，但这么做浪费了资源并造成了延迟。我曾参与过许多类似的情况，而且每次都遵循了这些“间歇性故障的五个阶段”（大致根据“悲伤的五个阶段”改编）：

**第一阶段：否认**    “这看起来像是偶发的。我找不到任何问题。就重试一下吧。”

**第二阶段：愤怒**    被分配负责追踪和重启故障的操作员感到恼火；没有控制网络或被调用的可执行文件的批处理程序员感到愤怒；控制更少的中层管理人员则感到烦躁。每一次故障都让情况变得更糟，直到每个人都怒不可遏。

**第三阶段：指责**    “是网络的问题，我们的服务器是用胶带和铁丝连起来的。” “不，是供应商的产品出了问题。” “不，你的环境无法支持我们的产品。” “是我们互联网服务提供商的问题。” “那个几个月前退休的人留下的都是废品。”

**阶段 4：探索**    一位经理哼了一声，“我不需要创可贴，我们需要找到根本原因。”这是每个人都能认同的，因为没有人愿意成为创可贴派的唯一成员——至少最初是如此。额外的日志记录被启用，诊断工具被安装到任何可能与问题远程相关的硬件上。不同的团队深入到他们的代码库中并提出理论。有时根本原因被找到，从而避免了最后阶段，但更多时候，机器中的幽灵依然是一个谜。

**阶段 5：接受**    最终听从伏尔泰的格言：“最好的往往是敌人，好的。”Batch 编码员通过自动重启可疑进程解决了问题。

只要一个人坚持寻找根本原因，就很难进入最终的接受阶段。这可能需要几天、几周或几个月，但当显而易见地发现根本原因不会出现，或者修复起来异常昂贵或困难时，唯一的选择就是从问题的表现着手。请注意，在第五阶段，我没有把*修复*一词放在引号里。尽管有些坚持的人仍然会称之为创可贴或权宜之计，但一个设计良好的自动重启过程会解决问题，确保再也不会被打扰。我称之为*修复*。

### 超时命令

在构建自动重启之前，我将介绍一个在设计中非常有用的新命令。在启动自动重启之前，我会希望将 bat 文件暂时睡眠一段时间，以便清除任何瞬时的服务器或连接问题。什么都不做对人类来说是容易的；对一些人来说，这是我们的默认状态，但计算机程序的设计目的是尽可能快速地执行。幸运的是，Batch 提供了超时命令，这可能是模仿运动中暂停的概念，或者是对不听话的孩子强制执行的。

这是一个简单的命令，接受一个参数：超时的长度，以秒为单位。这个命令将会睡眠一分钟：

```
timeout 60
```

Batch 允许最大超时为 99,999 秒，这相当于超过 27 小时。当这个命令以交互方式使用时，用户会在控制台上看到一个倒计时，直到处理恢复，并且可以按任意键提前结束超时并继续。

超时命令有几个轻微的怪异之处。首先，它接受一个值为 0 的参数。作为硬编码值，这没有意义，但考虑一下这个命令：

```
timeout %sleepSeconds%
```

如果你在代码中确定睡眠时间，它提供了一种简单的方式来实质上关闭命令，而无需用 if 命令包裹它。将 sleepSeconds 设置为 300 可以获得五分钟的休息，设置为 0 则跳过命令。-1 的参数会导致无限等待，直到按下任意键，这实际上是一个华丽的暂停命令。

### 自动重启

让我们一步步分析构建一个自动重启的过程，该过程偶尔会失败。设计考虑因素将指导规格的制定，从而进行代码编写和测试。

#### 设计考虑因素

自动重启的基本概念很简单。当任何进程生成错误的返回码时，主逻辑通常会有序地中止执行。自动重启则会回到原点，重新运行出错的进程。在批处理（Batch）中，这可能听起来仅仅是一个 if 命令和一个 goto 命令，但细节很快就变得复杂，需要精心设计。

理想情况下，重启会成功，过程会继续直到完成，但有时自动重启也会失败，如果继续失败，陷入无限循环的前景就愈加明显。必须有人决定在承认失败并启动中止之前，重启过程的次数。

如果一个进程在 100 次中无解释地失败一次，重启后的进程可能也会在 100 次中失败一次。基础概率理论表明，如果某个事件在 100 次尝试中发生一次，那么发生的概率是 1/100。要找到这个事件连续两次随机发生的概率，比例需要平方，结果是 1/10,000。将原始概率立方后，我们就得到三次连续尝试发生该事件的概率为 1/1,000,000。指数为 5 时，意味着 10 亿次尝试中仅有一次会出现连续五次失败。

这意味着，五到六次尝试应该能让我们达到一个实际的情况，即如果——这是一个巨大的如果——100 次尝试中的一次失败真的是随机的，那么这些失败就不会再发生了。

许多时候失败并非随机发生，这也会影响设计考虑。失败可能发生在服务器或数据库在高峰处理期间很忙的时候。偶尔，两个服务器会在没有明显原因的情况下断开连接，可能是片刻、几秒钟或几分钟。如果从其中一台服务器到另一台服务器的复制失败，那么接下来的 10 次自动重启可能会在你读完这句话之前发生，意味着这 10 次都发生在连接丢失的窗口期内。这并不是随机的。

对于这种类型的失败，你需要进行更多的分析。问题通常需要多长时间才能自行解决？在大多数情况下，最好在第一次自动重启之前睡几秒钟，正如之前提到的那样。在随后的失败之后，我们可以设置越来越长的等待时间。如果问题通常在一分钟内清除，总的重启尝试应该在大约三到四分钟内完成，并且从那里调整时间框架。

如果这一切看起来令人不知所措，那么是否有意义在几个小时内进行数百次自动重启尝试呢？不，没意义。如果自动重启过程尝试的次数过多，或者每次尝试之间的睡眠时间过长，解决方案反而会适得其反。如果一个服务器在周五中午失去连接，过于慷慨的自动重启可能会掩盖问题，直到晚上才被发现。处理过程可能会在几小时后才意识到问题，远远落后于预定计划。需要找到一个折衷方案。

另一个需要考虑的因素是故障的性质。你应该尽力区分合法的失败和可重启的失败。如果一个程序因为数据条件导致中止，而这个数据条件在重启后不会发生变化，那么自动重启只会浪费时间和 CPU 周期。有时候，你可以通过返回代码推测错误的性质。如果可以，你可以根据返回代码来决定下一步行动。如果不能，这也会影响决策；也许你应该尝试减少重启次数。

#### 规格说明

在这个练习中，我将编造一个需要自动重启的场景，并在考虑到刚才讨论的所有设计要素后编写一些规格说明。

一个与远程服务器上的数据库通信的已编译可执行文件大多数时候运行良好。它每天运行超过 30 次，但大约每三天会发生一次故障，返回错误级别为 7。最初几次发生时，有人重启了它，但每周几次的失败逐渐成为一种困扰。直到某个星期天早上的故障未被及时注意到，直到本周稍晚才成为了大家的巨大尴尬。必须采取一些措施了。

这种虚拟故障大约每 100 次尝试发生一次，这其实是幸运的，因为我刚好进行了假设这种频率的数学计算。在收集了所有统计数据之后，某些失败似乎确实是随机的，但数据库连接问题似乎会在不到五秒钟内恢复，因此我们不需要很长的休眠时间。

幸运的是，编写可执行文件的人在返回代码上做得很好。其他失败情况，比如无法在数据库中找到某些条目，返回的错误代码不是 7，而成功调用则总是返回 0。

现在我们有了编写规格说明所需的所有信息。第一个规格是显而易见的，但另外两个需要一点技巧，因为你可能会得出略有不同的数字：

1.  如果错误级别是 7，则启动自动重启。如果是 0，则继续；对于所有其他返回值，则中止。

2.  尝试最多四次自动重启，总共执行五次程序，超过第五次则中止。

3.  第一次尝试后暂停 2 秒钟，之后每次尝试将暂停时间加倍，即等待时间将是 2 秒、4 秒、8 秒和 16 秒。

稍微超过 30 秒后（加上可执行文件运行的时间），第五次失败将触发中止。在计算机艺术与计算机科学同样重要的工作中，这应该是一个不错的折衷。现在，我们准备好编码了。

#### 自动重启代码

列表 26-1 符合定义的规范。执行此代码的唯一前提是我们必须将 flakyExe 变量设置为正在经历间歇性故障的程序或进程。

```
❶ prompt $T$G
 if not defined sleepIncrmt  set sleepIncrmt=2
 if not defined maxAttempts  set maxAttempts=5
 set attempt=0

❷ :Restart
 set /A attempt += 1

 %flakyExe%

❸ if %errorlevel% equ 7 (
  ❹ if %attempt% lss %maxAttempts% (
     ❺ timeout %sleepIncrmt%
       set /A sleepIncrmt *= 2
       goto :Restart
    ) else (
    ❻ goto :Abort
    )
) else if %errorlevel% neq 0 (
  ❼ goto :Abort
) else (
  ❽ > con echo Successful Call of the Flaky Executable
) 
```

列表 26-1：启动最多四次自动重启不稳定可执行文件的代码

在代码的第一部分，提示命令❶（在第二十一章中介绍）将时间嵌入到提示字符串中，该字符串会添加到 stdout 中每个执行的行之前，从而更容易验证进程是否暂停了所需的时间。我将休眠增量的变量定义为 2 秒，将最大尝试次数的变量定义为 5 次尝试。我还初始化了尝试变量，该变量跟踪正在执行的尝试，初始值为 0。

为了增加代码的灵活性，我使用了仅在 sleepIncrmt 和 maxAttempts 尚未定义时才设置它们的技巧。尽管已经为规格付出了很多努力，但如果避免中止与最小化自动重启所需时间之间的折衷不完全合适，用户可以在调用此逻辑之前设置这些变量，或者在计算机上全局设置它们。如果每个月仍然发生一次中止，任何人都可以在不更改代码的情况下增加休眠增量或最大尝试次数，但为了本练习的方便，我将假设默认值。

逻辑继续经过:Restart 标签❷并将尝试变量增加到 1，然后解析 flakyExe，从而执行程序。（在此练习中，变量包含正在失败的不稳定可执行文件，但此调用可以是向远程服务器的 xcopy 命令，也可以是对一个不稳定的 bat 文件或任何可能失败并需要重启的进程的调用。）

接下来，我评估可执行文件返回的错误级别。如果代码遇到错误返回码 7❸，我检查是否已进行所需的 5 次尝试❹。由于这是第一次尝试，执行将进入代码块❺并执行 timeout 命令，休眠 2 秒钟。然后，我将休眠增量 sleepIncrmt 加倍，以便如果再次调用该进程时，进程将休眠 4 秒钟。接下来，我通过 goto 命令向后跳出此逻辑。

这将我们带回到刚刚执行过的:Restart 标签❷。这是第九章中 do...while 命令的一个很好的应用。注意标签的战略性放置。在调用第一次重启后，我将总尝试次数增加到 2，然后再次执行不稳定的进程。

如果返回码是 7 ❸，相同的过程将执行另一次重启，这次尝试次数增加到 3，仍然小于 5 ❹。回到代码块 ❺ 并在等待四秒超时后，我将睡眠时间增量加倍至 8，然后再次返回到 :Restart 标签 ❷。

如果这失败了四次，我将睡眠 16 秒 ❺ 并进行最后一次尝试。如果这次也失败，则尝试次数变为 5，并且不再小于 maxAttempts 中的目标值 ❹，因此代码将通过未显示的 :Abort 程序 ❻ 中止。

我们还需要像解释器一样思考另外两种情况。你已经知道错误级别为 7 时会发生什么。现在想象一下，那个不稳定的进程返回的不是 0 或 7。else if 子句 %errorlevel% neq 0 为真，代码会调用 :Abort 程序 ❼。

最后的情况是，假设返回码为 0。这是到达代码块 ❽ 的唯一可能途径，在默认的 else 子句之后，它验证执行是否成功。

中止程序应区分两种类型的中止。一种是在多次自动重启后失败 ❻，另一种则是在仅发生一次失败后，由与重启无关的原因导致的失败 ❼。

#### 测试

这显然是一些高级的批处理编码，但在你掌握了这个概念并编写了类似 Listing 26-1 中的代码后，可能看起来更难的任务会随之而来：测试。如果你运行这段代码 100 次，你可能会看到至少一次失败，但仍然有超过三分之一的概率完全没有失败。即使执行十亿次，也不能保证看到五次失败。（如果你对数学感兴趣，可以查阅泊松分布。）

我们需要一种模拟故障的方法，在 Listing 26-1 之前输入此命令将实现这一目的：

```
set flakyExe=cmd /C exit 7
```

当解释器解析代码中的 flakyExe 时，cmd 命令（在第二十一章中介绍）执行，运行 exit 命令，将 errorlevel 设置为 7。如果主逻辑编写正确，这将触发自动重启，然后它将重复相同的过程，总共进行五次后中止。

在你对测试结果满意后，将 exit 7 改为 exit 4，并重新运行；预期会看到一个不同的中止，且不会触发重启。再将其更改为 exit 0，你应该看到一个成功的运行结果（或至少是一个模拟的成功运行）。

理想的测试可能在两次失败后触发两次自动重启，返回码为 7，然后在第三次调用时成功，返回码为 0。你可以在此设置中将 cmd 命令替换为一个简单的 bat 文件调用命令，该文件包含一些条件逻辑，根据正在执行的尝试来设置返回码。更好的是，直接使用此设置：

```
set flakyExe=if ^^!attempt^^! lss 3 (cmd /C exit 7) else (cmd /C exit 0)
```

如你在第十四章中所学，我会转义感叹号，以便它们能存储在变量中。然后，当代码解析 flakyExe 时，attempt 变量中包含的值将成为条件子句的一部分。它将在前两次执行时为真，导致返回代码为 7；然后在第三次执行时，条件子句将为假。因此，返回代码将为 0。我在第四章中曾建议避免像这样的混乱 if 命令，但它非常适合这种类型的测试。

#### 中央日志

上面的例子已经简化并且完全可用，但在实际实施时，另一个关键特性是每次自动重启的中央日志。当此过程完成时，我们可以查询 attempt；任何大于 1 的值都意味着代码至少执行了一次自动重启。通过这些信息，我们可以将带有时间戳的条目写入日志文件，记录有关自动重启的详细信息，尤其是尝试次数。

如果自动重启完全掩盖了故障，你可能会成为自己成功的受害者。依然存在一个潜在的未解决问题，因此，保持已避免的中止记录很重要。一个月后，你可以利用日志明确说明没有自动重启的情况下，某些进程会中止。可能只有两三个，也可能是十几个，甚至几百个。

无论数字是多少，你都可以使用这个日志作为自动重启过程成功实施的证明。它还将监控潜在的根本问题。问题的频率可能在安装新硬件后减少或消失，或者随着现有硬件的老化而发生得更多。这些信息有助于确定针对根本原因解决方案的紧迫性。（它也可能成为你年度评估中的硬性指标。）

### 挂起

我已经讨论过自动重启失败的进程，它返回特定的值或错误级别值的集合。一个更大的挑战是挂起；*挂起*发生在一个调用的进程未能终止且永远不返回错误级别的值——更糟糕的是，挂起从不将控制权交回批处理代码。

挂起可能是由于一个无限循环造成的，该循环在重启时会再次发生，但有时当连接断开或无法找到资源时，一个有缺陷的进程也会挂起。简而言之，如果你可以进入任务管理器，杀死挂起的进程，重启它，并且它能够在没有其他干预的情况下成功处理，那么该进程就是一个非常适合自动终止和重启的候选者。

但任何自动杀死并重启进程的过程都面临一个重大障碍。自动重启在概念上是相当直接的。当你收到某些错误的返回代码时，你只需调用重启逻辑。但在挂起的情况下，Batch 代码是……挂起的。进程已经“拿着球回家”，并承诺再也不与任何人分享它了。根据定义，挂起不会将控制权交还给 Batch 代码，因此调用它的 bat 文件无法执行任何操作，更不用说杀死并重启该进程了。但总是有办法的：必须有某个东西或某个人来杀死挂起的进程。因此，程序员必须预见到并为挂起的可能性进行编码。

为了完成这个任务，我们需要一些在日常 bat 文件中没有的命令。start 命令（详见第十章）将打开一个第二个命令窗口，实际运行可能会挂起的进程。tasklist 命令将监控可能挂起的 bat 文件，而 taskkill 命令则...我想这个命令就不需要解释了。

仅仅列出这些命令大致勾画了计划的框架，但在深入细节之前，我必须正式介绍这两个新命令。

### 检索进程列表

tasklist 命令提供了你可以通过任务管理器在 Windows 机器上“手动”获取的大部分信息。它检索当前在机器上运行的所有或部分进程列表。我们将在 bat 文件中使用它，但首先打开命令提示符并输入 tasklist，你将获得一份正在机器上运行的所有程序的列表，包括内存使用情况、会话信息和进程标识符（PID）。在任何给定时间，成百上千的进程会在运行，但以下是其中几行的示例：

```
Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============
System Idle Process              0 Services                   0          8 K
System                           4 Services                   0      3,168 K
Registry                       120 Services                   0     51,168 K
cmd.exe                       8692 Services                   0        432 K 
```

PID 是操作系统在进程执行开始时分配给该进程的一个数字。系统空闲进程始终在运行，其 PID 始终为 0；System 通常使用 PID 4 或 8，具体取决于操作系统，所有其他进程都会分配一个可以被 4 整除的唯一数字。PID 会在某个时刻重新使用，但直到机器上运行了成千上万的不同进程之后才会发生。tasklist 命令显示每个执行中的 bat 文件，其映像名称为 *cmd.exe*，如第四行和最后一行所示。

该命令具有一些非常有用的参数。在解析命令输出时（我们很快会这么做），我们需要避免输出的前两行标题信息。/NH 选项（表示 *no headers*）会移除第一行标题信息，以及第二行的装饰性等号。

/FO 选项（表示 *format*）会改变数据的显示格式。可用的格式有逗号分隔（/FO:CSV）、列表（/FO:LIST）和表格（/FO:TABLE），后者也是示例输出中显示的默认格式。

/FI 选项将*过滤*掉不需要的条目或仅包含所需的条目。你可以包括或排除某些窗口标题，或者构建涉及 CPU 时间、PID、镜像名称等的过滤器。例如，以下命令列出机器上所有正在运行的记事本++实例：

```
tasklist /FI:"ImageName eq notepad++.exe"
```

（请不要问为什么这个选项使用等号操作符 eq 而不是 equ，但它确实是这样。）

使用通配符(*)会列出所有记事本、记事本++以及可能以这七个字母开头的任何其他程序：

```
tasklist /FI:"ImageName eq notepad*"
```

以下命令使用大于符号来显示当前占用大量内存的所有进程：

```
tasklist /FI:"MemUsage gt 250000"
```

使用帮助命令查看更多关于/FI 选项的详细信息；我展示的只是操作符和操作数的一部分。

### 终止进程

taskkill 命令可以一次终止一个或多个特定进程。它的一些参数与 tasklist 命令共享，最重要的是/FI 选项。以下命令尝试终止机器上所有正在运行的记事本实例：

```
taskkill /FI:"imagename eq notepad.exe"
```

该命令尝试关闭所有打开的记事本文件，对于所有已保存的文件，立即执行此操作。对于所有未保存的文件，记事本会生成一个弹窗，友好地提示用户保存文件，但/F 选项会*强制*终止进程。使用此选项会毫不留情地终止未保存的进程。/T 选项不仅会终止一个进程，还会终止它可能启动的任何进程。很快，我们将使用这两个选项来终止生成的 bat 文件，以确保它及其相关的所有进程都被真正终止。

与/PID 选项一起使用时，taskkill 命令基于进程指示符终止一个或多个特定进程。例如，以下命令会终止两个进程：

```
taskkill /PID 12348 /PID 6784
```

你还可以通过非常具体的窗口标题强制终止进程。（预示并不仅仅是小说中的技巧。）

### 自动关闭与重启

就像我们进行自动重启一样，让我们逐步构建一个自动杀死并重启偶尔会挂起的进程的过程，包括设计、规格、编码和测试。

在这个虚构的场景中，那个不稳定的可执行文件 99.9%的时间会完美运行，但每千次中有一次会挂起。我们知道根本原因不是一个简单的死循环，因为我们可以手动终止并重启它，并且看到它成功运行。团队推测与数据库的交互可能会导致问题，或者也许与数据库无关。它发生得如此罕见，几乎无法进行故障排除，但发生得足够频繁，成为一个问题，并且没人能找到根本原因。

在经历了五个阶段之后，我们决定通过自动终止并重启来修复问题。我们将把有问题的进程调用放入一个动态创建的 bat 文件中，并生成它来代替直接调用该进程。生成的进程将完全独立于主 bat 文件执行，然后主文件会监控生成的 bat 文件，如果检测到挂起，则会终止并重启它。

#### 设计考虑因素

设计中最棘手的部分无疑是确定在假设挂起之前，究竟应该等多长时间让执行文件完成。通常需要多长时间？在没有挂起的情况下，最大时间是多少？执行时间是一致的吗，还是会波动？如果波动，我们能否根据输入文件的大小预测，还是完全随机的？如果一个进程通常需要 3 或 4 分钟来执行，将最大执行时间设置为 10 分钟是合理的。但这将会终止并重启一个特别慢的执行，导致它刚好在完成之前被终止，完成时需要 10 分钟零一秒。

在确定时间长度之前，我们必须进行大量分析。如果执行时间比较一致，我通常将其设置为典型运行时间的三倍。如果执行时间由输入文件的大小决定，对于较大的文件可以等待更长时间。如果执行时间看起来是随机的，可以增加更多的时间，但不要设置过长的最大时间，以免适得其反。

在放弃之前尝试重启的次数是你必须确定的另一个因素。与自动重启进程时应用的相同考虑因素同样适用于这里。简而言之，挂起的频率和随机性有多大？

提议的自动终止并重启设计的另一个考虑因素是检查生成的 bat 文件状态的频率。如果一个进程通常需要 3 或 4 分钟，而最大执行时间设置为 10 分钟，那么在检查之前等满 10 分钟是没有意义的。我们可以每 15 秒检查一次；如果完成了，我们可以继续，不用再等；如果没有完成，我们可以再等 15 秒，最多等到 10 分钟。需要注意的是，所选的间隔是我们可能在单次执行中增加的最大时间。

#### 规范

继续这个假设的场景，执行文件通常在 10 或 20 秒内完成。经过大量测试，甚至是并行测试，我们观察到的最大运行时间是 35 秒。一个合理的最大等待时间似乎是 60 秒；这是典型长时间执行的三倍，并且轻松超过了观察到的最长执行时间。

每隔 10 秒检查一次生成的 bat 文件似乎是合理的。一次快速运行将在第一次检查前完成，大多数其他任务将在第二次检查时完成，所有任务中只有少数将在第三次完成，相较于直接调用不稳定的可执行文件，这种方式最多会增加 10 秒的执行时间。

总共四次尝试后再中止应该也能奏效。因为它每 1000 次尝试中会失败一次，四次完全随机的失败在万亿次尝试中才会发生一次。听起来这可能是过度的，但我们已经观察到多个几乎同时发生的卡死，这意味着这些失败并非完全随机。它们可能发生在网络连接丢失的时期。

最糟的情况是，四次失败的尝试将耗时略多于四分钟，然后我们会启动中止操作。这个过程旨在尽可能在短时间内减轻卡死的风险。就像自动重启一样，这些规格的制定也有一定的艺术性。合理的同事可能希望设置更长或更短的等待时间，或者更多或更少的重启次数。

#### 核心自动杀死与重启逻辑

在分享代码之前，我会讨论这个整个过程的核心——生成、跟踪和可能终止第二个 bat 文件的过程。

从高层次来看，我将通过`start`命令启动生成的 bat 文件，而不是使用`call`命令，这样两个 bat 文件就会独立执行。生成的 bat 文件会将其标题更改为一些主进程也知道的唯一文本。这将使得主进程能够通过`tasklist`命令跟踪或监视生成的 bat 文件，如果它花费的时间过长，我们将使用`taskkill`命令将其终止。然后我们会再次生成这个动态创建的 bat 文件，再次监控它……并可能再次终止它。

在第十五章中，我介绍了`title`命令，用来更改我们运行交互式 bat 文件时在命令窗口左上角显示的标题。为命令窗口命名总是有益的，这样我们可以区分不同的窗口，但`title`命令的用途不仅仅是外观上的。我将在这里使用它来附加一个跟踪设备。

就像海洋生物学家可能会在海龟的壳上安装电子跟踪设备一样，我们也会为生成的 bat 文件附加一个跟踪设备。生物学家利用卫星遥感追踪海龟在全球海洋和海滩上的运动，追踪它们交配、觅食和产卵的过程。我们的目标则没那么宏大；我们只是简单地跟踪在一台机器上执行的 bat 文件的生命周期。

如果`title`命令附加了跟踪设备，那么`tasklist`命令就类似于卫星追踪海龟。在主 bat 文件中，`tasklist`命令将使用生成的 bat 文件中`title`命令所用的相同唯一标题。以下命令将使用`uniqTitle`变量中包含的唯一标题来跟踪生成的 bat 文件：

```
tasklist /FI:"WindowTitle eq %uniqTitle%" /NH
```

/FI 选项允许我们根据机器上运行的各种进程的不同特征进行筛选。例如，生成的 bat 文件的 ImageName 将是 *cmd.exe*，但这对于所有 bat 文件（包括进行跟踪的主 bat 文件）来说都是正确的，因此在这里并无用处。但筛选 WindowTitle 将返回唯一的一个具有该标题的进程。（因此，在这种设计中，确保唯一标题的确具有唯一性至关重要。）

/NH 选项去除了那些讨厌的标题，因此如果在执行前一个命令时生成的 bat 文件正在运行，它将向 stdout 返回类似如下内容：

```
cmd.exe                      9736 Console                     1      4,996 K
```

这显示了镜像名称、PID、会话名称、会话编号和内存使用情况。我们对大多数信息不感兴趣，但我们确实关心的是这个条目与该进程未运行时该命令返回的内容的对比：

```
INFO: No tasks are running which match the specified criteria.
```

显而易见的区别会告诉我们生成的 bat 文件是否仍在运行。可以使用 for /F 命令提取第一个标记进行检查；如果是 *cmd.exe*，则带有唯一标题的 bat 文件正在运行；如果是 INFO:，则没有带有该标题的进程在运行。

在小心地确认挂起的进程后，以下 taskkill 命令将以精准的方式终止它。使用相同的 /FI 选项，并查找来自 tasklist 命令的相同 WindowTitle，确保我们不会过度操作并杀死其他进程：

```
taskkill /F /T /FI:"WindowTitle eq %uniqTitle%"
```

/F 和 /T 选项会强制终止生成的 bat 文件及其可能启动的任何子进程。

顺便说一下，这就是我结束海龟类比的地方。我们不想以任何方式伤害海龟。它们是世上最美丽、最迷人的动物之一，当然，蝙蝠除外。

现在让我们把这一切结合起来。

#### 自动终止并重启代码

清单 26-2 显然是书中最复杂的代码之一，但即便如此，我已经去除了大部分错误处理，并使用了硬编码的值，这些值实际上应该被参数化。我稍后会讨论这些问题，但假设 flakyExe 被分配给偶尔挂起的可执行文件，清单 26-2 满足所有规格。

```
 set spawnedBat=C:\Batch\Spawned.bat
 set uniqTitle=Spawned Bat - %date% %time%
❶ >  %spawnedBat%  echo   setlocal EnableExtensions EnableDelayedExpansion
 >> %spawnedBat%  echo   title %uniqTitle%
 >> %spawnedBat%  echo   %flakyExe%
 >> %spawnedBat%  echo   goto :eof

 set totHangs=0
❷ :Restart
 set totSleep=0
❸ start /MIN %spawnedBat%
 timeout 1
❹ for /F usebackq %%i in (`tasklist /FI:"WindowTitle eq %uniqTitle%" /NH`) do (
    if /i "%%i" equ "INFO:" (
      call :Abort "%uniqTitle% Not Spawned"
 )  )

❺ :WaitMore
 timeout 10
 set /A totSleep += 10
❻ for /F usebackq %%i in (`tasklist /FI:"WindowTitle eq %uniqTitle%" /NH`) do (
    if /i "%%i" equ "cmd.exe" (
     ❼ if %totSleep% lss 60 (
          goto :WaitMore
       ) else (
        ❽ taskkill /F /T /FI:"WindowTitle eq %uniqTitle%"
          set /A totHangs += 1
        ❾ if !totHangs! lss 4 (
             goto :Restart
          ) else (
             call :Abort "%uniqTitle% - 4 Hangs"
)  )  )  )
❿ > con echo The Spawned Bat Has Completed.
 pause
 goto :eof

:Abort
 > con echo Aborting: %~1
 > con pause
 exit 
```

清单 26-2：启动最多三次自动终止并重启 flaky 可执行文件的代码

这段代码的主要部分围绕着生成的 bat 文件展开：创建它、启动或执行它，以及监控它。我将更仔细地查看每个部分。

1. 创建 *Spawned.bat*：使用 第二十五章 中的 bat 创建 bat 技巧，我通过四个 echo 命令 ❶ 创建了 *Spawned.bat*。这是一个简单的 bat 文件，除了定义一个唯一标题 uniqTitle 并调用 flaky 执行文件外，几乎没有做其他事情。甚至没有错误处理。

完整的 *Spawned.bat* 内容可能如下所示，具体取决于 date、time 和 flakyExe 的内容：

```
setlocal EnableExtensions EnableDelayedExpansion
title Spawned Bat - Mon 11/01/2004 10:30:59.33
C:\Batch\Flaky.exe
goto :eof 
```

我们在创建生成的 bat 文件之前为唯一标题赋值，以便两个 bat 文件都知道它是什么。通过使用 uniqTitle 变量中的日期和时间，我假设不会有两个进程在百分之一秒内被调用，但理想情况下，每次执行 bat 文件时应该有一个唯一的变量可以添加到标题中。（为了本示例，我假设这个标题是真正唯一的。）

2.  启动 *Spawned.bat*：目前 :Restart 标签 ❷ 对代码没有影响，但最终我们会使用它在终止挂起后重新启动进程。我在标签之前将挂起的总次数 totHangs 初始化为 0，确保重启不会重置它。我还将总睡眠时间（以秒为单位）totSleep 设置为 0，但它在标签之后。如果此值累积到 60 秒的等待时间，我将启动重启并重新执行此命令，从而重新初始化 totSleep 为 0。

start 命令 ❸ 启动、生成或独立于主进程启动动态创建的 bat 文件。为了不让桌面被额外的窗口淹没，/MIN 选项会立即最小化生成的窗口。

为了验证生成的 bat 文件是否已启动并运行，我会暂停一秒钟，给它时间执行其标题命令，从而让这段代码能够找到它。这假设生成的进程会至少运行一秒钟。（如果有丝毫可能不成立，我可以在生成的 bat 文件末尾添加 timeout 1 命令，确保它至少运行一秒钟。）

for 命令 ❹ 的输入与前面详细介绍的 tasklist 命令相同，默认只将第一个令牌传入代码块。如果该令牌等于 INFO:，说明出现问题——生成的 bat 文件尚未启动，而且距离它完成还为时过早——我们会转到中止例程并传递适当的错误信息；否则，我们继续执行。

3.  监控 *Spawned.bat*：最后，我们进入核心逻辑。另一个 timeout 命令 ❺ 按照我们的规范睡眠 10 秒，并将这 10 秒加到 totSleep 中，表示等待生成的 bat 文件完成的总时间。接下来，另一个与之前相似的 for 命令 ❻ 执行，但代码块现在查找第一个令牌是否等于 *cmd.exe*，这表示该进程仍在运行。如果是，并且如果评估下一个 if 命令 ❼ 时显示我们还没有等待 60 秒，那么 goto 命令会返回到 :WaitMore 标签 ❺。

当总等待时间达到或超过 60 秒 ❼ 时，taskkill 命令 ❽ 会终止生成的 bat 文件。我们增加并检查挂起的总次数 totHangs。经过四次尝试 ❾ 后，如果仍然没有解决问题，就会发生更大的问题，因此我们启动中止操作。否则，我们会返回 :Restart 标签 ❷，重新启动整个过程。

请注意，代码中包含了两个重叠的 do...while 命令，这是 第九章 中介绍的技术的一种变体。较简单的命令会等待 10 秒钟，直到过去一分钟（:WaitMore ❺❼）。另一个命令则在遇到挂起时重新启动整个进程（:Restart ❷❾）。

如果一切顺利，for 命令 ❻ 中嵌入的 tasklist 命令最终将找不到带有特定标题的 *cmd.exe* 实例。这表明生成的 bat 文件已经完成，我们将继续执行 echo 命令来记录它的完成 ❿。

#### 测试

如果测试一个发生频率为 1% 的间歇性故障已经很困难，那么测试一个发生频率为 0.1% 的间歇性挂起几乎是不可能的，除非进行一些干预。要修复挂起问题，我们首先需要创建一个用于测试的挂起。你可以编写一个偶尔执行无限循环的程序（每个程序员在不经意间都会做过这个事情）。但由于这是一本关于批处理的书，让我们编写一个 bat 文件，让它在大约 20% 的情况下进入无限循环。*OccasionalHang.bat* 就是做这个的；以下是它的完整内容：

```
 timeout 15
 set /A rand = %random% %% 5
:EndlessLoop
 if %rand% equ 0  goto :EndlessLoop
 exit 
```

timeout 命令模拟了一个运行 15 秒的程序。如果没有这个命令，bat 文件通常会在短短的几分之一秒内完成。set /A 命令通过对随机伪环境变量（第二十一章）进行取余操作，捕获 0 到 4 之间的伪随机数，并将其存储在 rand 变量中。如果 rand 大于 0，我们就成功退出 bat 文件，但大约每五次中会有一次 rand 等于 0，这时我们会进入无限循环。如果 rand 等于 0，goto 命令会不断回到上一行的 :EndlessLoop 标签，无法逃脱。要让这个 bat 文件更频繁地挂起，你可以调整取余操作，例如 %% 2 会让程序大约一半的时间挂起。

要调用这个 bat 文件而不是那个不稳定的可执行文件，只需在主 bat 文件中输入以下命令，放在 Listing 26-2 中代码之前：

```
set flakyExe=call C:\Batch\OccasionalHang.bat
```

call 命令是变量值的一部分，因此当 flakyExe 被解析时，解释器会调用 *OccasionalHang.bat*。

#### 现实世界的调整

尽管 Listing 26-2 的内容非常复杂，我还是省略了一些错误处理，并且在通常情况下不会使用硬编码值，所有这些都是为了专注于自动终止和重启的逻辑，但我有一些关于现实应用的调整建议或改进。

代码中有三个硬编码的值应该是变量。我硬编码它们纯粹是为了可读性，但我应该像这样设置休眠间隔、最大挂起次数和最大休眠时间，使用可重写的默认值：

```
if not defined sleepIntrvl  set sleepIntrvl=10
if not defined maxHangs     set maxHangs=4
if not defined maxSleep     set maxSleep=60 
```

就像自动重启一样，这些变量应该替换代码中的硬编码数字。如果用户想更改任何这些值，可以在执行逻辑之前使用 set 命令进行更改。

我之前提到过，你可能可以根据输入文件的大小预测进程的预期执行时间。以下代码将最大休眠时间设置为基准的 30 秒，并根据输入文件中每 1,000 字节的数据增加 1 秒，前提是没有人已经定义过它：

```
if not defined maxSleep (
   for %%s in (C:\Batch\InputFile.txt) do (
      set /A maxSleep = 30 + %%~Zs / 1000
)  ) 
```

你可以通过一些分析，比较文件大小和典型运行时间来微调这个算法。

有时候，你可以通过查看预期的输出文件来识别程序是否挂起。如果经过了这么多秒文件仍然没有出现，你可能已经知道进程挂起了。你可以定期捕获文件的大小，如果在某个时间段内它没有变大，这也可能是挂起的一个迹象。进行一些小的分析将极大地提升进程的效率，找到在不终止一个良好但长时间运行的执行与仅暂停必要时间之间的平衡。

另一个可能的调整是增加最后一次尝试之前的最大休眠时间。即使在我们处理的这个场景中做了所有分析，一个执行可能确实需要超过一分钟。如果你已经在每次 60 秒后终止了进程三次，允许最终尝试有 2 分钟的时间也许并不是坏主意。如果尝试次数和最大挂起次数相等，只需将 maxSleep 乘以 2。如果未来的日志显示多次失败最终在最后一次尝试中成功，你可以重新评估最大休眠时间。

如果挂起现象似乎发生在两次运行同时启动时，很可能是一个竞争问题。如果我们在相同的时间表上终止并重启这两次运行，它可能再次发生，因为它们仍然同步。一种解决方法是在终止后稍等几秒钟。错开休眠时间可能会有些棘手，因为如果它们在同一时刻启动，两个 bat 文件中的随机伪环境变量也会同步，但通过一些努力，你可以理想地在每次执行中找到一个唯一的数字。

清单 26-2 中的一个明显遗漏是生成的 bat 文件内部的错误处理。主 bat 文件中的代码可以告诉我们生成的 bat 文件何时完成，但它无法知道是否成功执行。这就相当于运行一个程序但不检查返回码。一个解决方案是让生成的 bat 文件将 errorlevel 甚至状态信息写入一个小文件。主逻辑然后可以读取该文件并根据其内容继续执行。

一个良好的设计会使最终产品更易用、更稳定。这种类型的进程真的需要非常详细地思考，考虑到在两个线程同时运行时可能发生的所有情况。说到线程...

### 多线程

在进入下一章之前，让我们将我们用来构建自动杀死和重启过程的组件，重新构思成完全不同的东西：*多线程*或*并发*。

这是 Batch 的另一个功能，虽然它的创建者并未预见到，但后来由开发者实现。要完全实现其他语言中的多线程，我们需要执行三项任务。首先，我们需要创建两个或更多的被称为*线程*的进程。第二，我们需要监控这些进程，确定每个进程何时完成。第三，我们需要允许这些创建的进程彼此之间以及与主进程进行通信，甚至共享数据。

你可以通过本章所学完成前两项任务。`start`命令将启动或创建任何数量的其他批处理文件，我现在将这些称为线程。你可以使用`title`和`tasklist`命令跟踪具有唯一名称的线程，就像你跟踪容易挂起的进程一样。唯一的区别是，现在你将启动并监控多个进程，而不仅仅是一个。如果进程的数量可能变化，你可以将它们保存在一个数组中。（我将在第二十九章中讲解数组。）带有内置多线程工具的语言通常提供一种方法，能在一定时间后杀死所有仍在运行的线程，你也可以在 Batch 中使用`timeout`和`taskkill`命令实现同样的功能。

诚然，完全实现的一个难点是主进程和线程之间的通信能力。毫无疑问，不存在可以被多个线程访问的异步 Batch 代码块，但某些通信是可能的。每个线程可以在一个以其标题命名的简单文本文件中记录其状态和高层信息，如已处理记录的数量。由于主进程也知道每个线程的标题，主进程可以在每个线程完成时，甚至在每个线程执行时找到并处理这些信息。

多线程是一种很棒的技术，可以将耗时的过程拆分成更易管理的块，通过一些努力，你可以在 Batch 中实现这一点。

### 总结

开发人员可以将所有间歇性故障和挂起情况按从恼人到灾难的等级进行评分。在这一章中，你学习了一些高级 Batch 编程技巧来缓解这些问题。我详细介绍了自动重启和自动杀死与重启过程的设计、规范、编码，甚至是测试。你还学习了一些新的有用命令，以及对之前讨论的命令进行的新应用，甚至介绍了多线程。

最重要的是，我希望你能理解构建这些解决方案所需的细致入微的技巧。即使在深入讨论具体解决方案的细节之前，我们也需要进行大量分析，仅仅为了确定自动重启是否适用。并且记住，这是真正的修复，而不是一个“修复”。

在下一章中，我将深入探讨一个听起来应该是第四章中非常简短一节的主题，即在 if 命令的条件语句中使用 and 和 or 运算符。我在这里不剧透为什么这是第三部分的内容。
