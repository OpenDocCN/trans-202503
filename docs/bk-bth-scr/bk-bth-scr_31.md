

## 28 紧凑型条件执行



![](img/chapter.jpg)

在本章中，我将讨论条件执行... 但不，这不是一章关于 if 命令的内容。的确，if 命令是条件执行代码的经典示例，本章将从第四章重新审视这一讨论，但会有一个非常不同的角度。批处理有一个叫做*条件执行*的特殊构造，它基于前一个命令的成功或失败来执行一个或多个命令。这是 if...else 结构的一个紧凑且精简的替代方案，但也有显著的区别，理解这些差异在使用前至关重要。

我将介绍条件执行语法中使用的两个运算符，你会看到一些类似但不完全相同的内容，类似于 if...else 结构。我将演示如何依次执行多个命令，在这些命令中，如果任何一个命令失败，其余命令将不会执行。反转脚本后，我将展示如何依次执行多个命令，如果任何一个命令*成功*，则其余命令不会执行。

### 条件执行运算符

在许多编程语言中，双安培符号（&&）是“与”运算符，双管道符号（||）是“或”运算符，在第二十七章中，我详细说明了批处理（Batch）不支持这些功能。相反，条件执行语法使用双安培符号和双管道符号作为运算符，这对于熟悉其他语言的程序员来说可能会产生一定的认知失调，但这些运算符提供了一种简洁且独特的替代方法，代替了 if 命令：

**“&&” 运算符**

在以下的通用语法中，命令 1 总是执行，而命令 2 仅在命令 1 完成后，`errorlevel`的值为 0 时才会执行：

```
command1 && command2 
```

单个安培符号分隔的两条命令不加条件地执行，但额外的安培符号会触发条件逻辑。可以称之为“正向条件执行运算符”。

**“||” 运算符**

将安培符号替换为管道符号会改变逻辑。在以下示例中，命令 2 仅在命令 1 执行完毕后，`errorlevel`的值*不是*0 时才会执行：

```
command1 || command2 
```

单个管道符号（恰如其分）将一个命令的输出传递给另一个命令，但这里没有任何内容被传递到第二个命令，后者可能根本不会执行，因为它是负向条件执行运算符。

### 使用单个运算符

作为 if 命令的替代方案，你通常可以使用单个条件执行运算符来简化代码，但首先需要比较和对比这两种方法。

#### 正向条件执行

为了演示，列表 28-1 提供了这个简洁易懂的示例，用于创建一个空文件并检查返回代码。

```
copy nul C:\Batch\Empty.dat
if %errorlevel% equ 0 (
   > con echo Empty.dat Created Successfully
) 
```

列表 28-1：带有错误处理的空文件创建

使用条件执行，这一行代码在功能上是等效的：

```
copy nul C:\Batch\Empty.dat && > con echo Empty.dat Created Successfully
```

如果 copy 命令创建了空文件并返回 0，echo 命令会将消息写入控制台。实质上，&&等同于 if %errorlevel% equ 0。如果 copy 命令未能创建空文件，它会返回非 0 的值作为返回代码，echo 命令则不会执行。

由于在条件执行语法中，errorlevel 的值仅为暗示，因此其值并不会出现在 stdout 中，这有时会让我们无法确定某些代码是否执行过。如果你需要在跟踪文件中找到返回代码的值，那么更为详细的选项是明智的选择。

条件执行语法可以是 if 命令的一个简洁（有些人可能会说是难以理解）替代方式，但当你将其重写为多行时，它更易于阅读，也更接近 if 命令。你可以通过在&&运算符后面放一个左括号来启动代码块。然后，你可以将一个或多个命令放入代码块中，最后用一个右括号结束它。以下代码在功能上等同于之前的两种写法：

```
copy nul C:\Batch\Empty.dat && (
   > con echo Empty.dat Created Successfully
) 
```

与列表 28-1 进行对比，我减少了一行代码，并将 if 命令及其条件语句替换为&&运算符。代码显然被简化了，但是否简化取决于读者对条件执行的理解。

#### 否定条件执行

现在，让我们对这个逻辑进行一些修改，以实验否定条件执行运算符。首先，使用一个不存在的文件夹。（剧透：copy 命令未能创建空文件。）其次，将&&更改为||运算符，并使消息反映出失败情况：

```
copy nul C:\NonExistentFolder\Empty.dat || (
   > con echo Empty.dat NOT Created
) 
```

现在，echo 命令只有在 copy 命令失败时执行，因为当 copy 命令失败时，它会将 errorlevel 设置为 1。如果命令成功创建文件，它会将返回代码设置为 0，并且解释器不会向控制台输出任何内容。

#### 现实世界中的应用

应用场景有很多；我将在这里详细介绍几个使用单个条件执行运算符的例子。

##### 文本搜索

一种场景开始时，变量存储了一个程序名称。如果你能在其路径中找到特定的服务器名称，可能想要调用某个内部例程中包含的进程。

以下代码搜索 progName 的内容以查找 svrName 的值，如果找到服务器，则调用一个例程：

```
echo "%progName%" | findstr %svrName% && call :ServerFound
```

echo 命令将程序名称传递给 findstr 命令，如果在输入文本中找到服务器名称，findstr 会将 errorlevel 设置为 0。不要被单个管道符迷惑；那不是条件执行，而双&符号则确实代表了这种技术。

类似地，使用||运算符则会导致以下代码调用不同的例程，但只有在没有找到文本时才会调用：

```
echo "%progName%" | findstr %svrName% || call :ServerNotFound
```

这个例子也鲜明地说明了管道符和双管道符之间的区别。

##### 调用另一个 Bat 文件

有一个常见的条件执行用法是验证 `call` 命令，当参数是一个包含要调用的 bat 文件名称的变量时，但有一些常见的陷阱需要避免。

对于这个示范，`calledBat` 变量可能包含一个有效的 bat 文件的路径和名称，但它也可能包含垃圾数据，导致 `call` 命令失败。失败会触发解释器将 `errorlevel` 设置为 1，因此，如果你使用 || 运算符并配合以下错误处理，这是可以理解的：

```
call %calledBat% || (
   > con echo Called Bat File Invalid: %calledBat%
) 
```

然而，如果 `call` 命令成功调用了 bat 文件，解释器并不会将 `errorlevel` 设置为 0——实际上，它根本不会改变返回码。这个可能是一个 bug，但这并不会改变程序员的困境。如果 `call` 命令成功，返回码将保存最后一个命令返回的值来更新它。

我之所以要提到这一点，是因为这很容易被忽视。你可以用一个错误的 bat 文件测试这段代码，它会正常工作——也就是说，它会输出错误信息。然后你可以用一个正确的 bat 文件再次测试，可能看起来会正常工作——也就是说，它不会输出消息——但它*之所以工作*，仅仅是因为在执行 `call` 命令之前，`errorlevel` 正好被设置为 0，这是你可能无法始终依赖的。早些时候，我曾建议不要在使用 `robocopy` 命令时使用条件执行，因为它的返回码不规范。我并没有建议在使用那些没有统一重置返回码的命令时（比如 `call` 命令）采取相同的做法，但我确实推荐一定程度的谨慎。使用这种类型的命令和条件执行时，潜在的、但可以纠正的问题是存在的。

返回码问题绝不应妨碍你使用这种技术。事实上，如果你在执行 `call` 命令后在传统的 `if` 命令中评估返回码时，同样的问题也会存在。记住，这种技术本质上是将 `errorlevel` 的值与特定值（即 0）进行比较的高级方式。要使其生效，你需要确保在 `call` 命令执行之前返回码的值为 0。以下 `cmd` 命令确保你在 `call` 命令执行前重置返回码：

```
cmd /C exit 0
call %calledBat% || (
   > con echo Called Bat File Invalid: %calledBat%
) 
```

最后一个问题是，某些在被调用的 bat 文件中的命令可能会在完成后将 `errorlevel` 设置为非零值。不幸的是，这种错误处理不会将错误的返回码与失败的 `call` 命令区分开来。在这种情况下，这两者都会在 `call` 命令之后以非零 `errorlevel` 出现，从而可能导致被调用的 bat 文件中的一个不相关的失败错误，错误地触发 echo 命令，声明 bat 文件无效。

最佳的解决方案是两个 bat 文件之间达成协议。被调用的 bat 文件可以使用 `exit /B 0` 命令，确保在成功调用结束时始终返回 0。两个 bat 文件之间的错误处理可以采取另一种形式，也许是一个包含描述性错误信息的参数，其中被调用的 bat 文件将其设置为 null，以表示成功执行。

这是一个非常有用的工具，但你必须考虑在流程的不同阶段 errorlevel 的所有可能值。尤其在多个条件执行操作符联用时，这个建议更加重要。

### 使用多个操作符

单独来看，这些操作符相当直观，但当你将它们组合在一起使用时，它就变得既有趣又有用。

#### 一个伪 if...else 结构

你已经了解到伪随机数并不是真正的随机数，但它接近随机数；同样，伪 if...else 结构并不是真正的 if...else 结构，但它很相似。下面的代码看起来与这种结构非常相似，而且行为上也很像：

```
copy nul C:\Batch\Empty.dat && (
   > con echo Empty.dat Created Successfully
) || (
   > con echo Failure to Create Empty.dat
) 
```

我用 `&&` 操作符代替了 if 命令及其条件子句；更奇怪的是，`||` 操作符取代了 else 关键字（看起来有点像一个失败的表情符号尝试，夹在括号的开闭之间）。在实际操作中，这通常表现得像一个 if...else 结构。复制命令尝试创建一个空文件；如果成功，第一个 echo 命令执行，如果失败，第二个 echo 命令会写出不同的消息。这正是 if...else 结构会做的，但这种技术有一个重大的 batveat。

如果第一个代码块中的某个操作在完成时将 errorlevel 设置为非零值，那么这个结构也会触发第二个代码块。在这个例子中，每个代码块由一个单独的 echo 命令组成，但很容易想象括号之间会有更复杂的逻辑。

这非常违反直觉；如果这段代码成功创建了*Empty.dat*，那么第一个 echo 命令会执行，但如果那个命令失败，那么可以认为是 else 代码块中的 echo 命令也会执行。一个可以执行两个代码块的 if...else 结构并不是一个真正的 if...else 结构。

在这个特定实例中，这种行为可能是完全可以接受的，因为一个简单的 echo 命令向控制台输出不太可能失败，如果失败，那几乎是不可能的，但任何复杂到足以重置 errorlevel 的操作放在第一个代码块中都是不明智的。因为有这个 batveat，我不常使用这种技术，但接下来的几个例子展示了它的真正用处。

#### 多个 && 操作符

条件执行在你连续执行多个类似的命令并希望统一处理错误时最为强大和有用。例如，你可以使用四个不同的 xcopy 命令将四个不同的文件复制到目标路径。目标可能是，如果其中任何一个复制操作失败，就终止执行，但并不关心是哪个失败。同时，我不想重复四次询问返回码。你可以使用两种不同的方法来实现，一种使用条件执行，另一种不使用条件执行。

作为条件执行的替代方法，这种方法将每次复制尝试返回的 errorlevel 值连接起来。为了演示，我将只在控制台写出一条错误信息，而不是中止操作。假设四个源文件和目标路径在代码的前面已定义，这个示例完成了任务：

```
xcopy %sorc1% %targ%\ /Y /F
set cmlRC=%errorlevel%
xcopy %sorc2% %targ%\ /Y /F
set cmlRC=%cmlRC%%errorlevel%
xcopy %sorc3% %targ%\ /Y /F
set cmlRC=%cmlRC%%errorlevel%
xcopy %sorc4% %targ%\ /Y /F
if %cmlRC%%errorlevel% neq 0 (
   > con echo One or more of the four copies FAILED
) 
```

在第一个 xcopy 命令之后，我将 cmlRC（累计返回码）设置为 errorlevel 的值。然后，我将接下来两个命令返回的 errorlevel 附加到 cmlRC 的末尾。最后，我将 cmlRC 的三个返回码与最后一个 xcopy 命令的 errorlevel 一起连接，并在 if 命令的条件句中将其与 0 进行比较。解释器足够智能，可以进行数字比较——四个零被视为与一个零相等。（如果条件句的每一边都被双引号包围，Batch 会将它们视为字符串，实际上是不相等的字符串——即，0000 等于 0，但"0000"不等于"0"。）

如果只有第二个 xcopy 失败，条件句的左侧可能会解析为 0400。由于它不等于 0，错误处理逻辑将启动。这个方法是可行的、可读的，并且在 Batch 语法中占有一席之地，但现在让我们将其与使用条件执行的解决方案进行比较。

语法有几种变体。第一种要求所有命令都在一行上，我们可以使用插入符号作为续行符来使其更具可读性，如 Listing 28-2 所示。

```
xcopy %sorc1% %targ%\ /Y /F ^
  && xcopy %sorc2% %targ%\ /Y /F ^
  && xcopy %sorc3% %targ%\ /Y /F ^
  && xcopy %sorc4% %targ%\ /Y /F ^
  || > con echo Exactly one of four possible copies FAILED 
```

Listing 28-2：多个&&操作符后跟一个||操作符

与之前的方法相比，条件执行可以大大简化逻辑，但它的直观性不强。

每个&&操作符将一对 xcopy 命令分开，这意味着如果第一个命令成功，第二个命令就会执行，如果第二个成功，第三个命令也会执行，且如果这些命令都没有失败，最后一个 xcopy 命令也会执行。代码最后一行前面的||操作符表示只有在任何一个 xcopy 命令失败后，并且立即执行，echo 命令才会执行。这是一个微妙且重要的点，导致这两种方法*并不*在功能上等效。

在连接方法中，所有四个 xcopy 命令会在我们检查完整的返回代码集之前执行，无论是否有早期的失败。在条件执行方法中，如果一个命令失败，执行会立即跳转到两个管道符后的错误处理部分。那么，它到底是怎么工作的呢？

假设第一条 xcopy 命令执行成功。在下一个 xcopy 命令前看到 && 运算符，解释器会检查返回代码。返回值是 0，因此第二条命令也会执行，但假设它因磁盘空间不足而失败。第三条命令前的 && 运算符再次告诉解释器检查返回代码。这次返回的不是 0；解释器会跳过第三条命令，直到找到第三个也是最后一个 && 运算符。由于 errorlevel 仍然非零，第四条命令不会执行。接下来，解释器会找到 || 运算符，并执行 echo 命令，恰恰因为 errorlevel 不等于 0。只有当所有四个 xcopy 命令都成功执行（即每个返回 0）时，echo 命令才不会执行。

所以，如果即使一个命令失败，执行所有命令仍然有意义，那么返回代码连接方法更为优先。但通常来说，如果一个失败的复制意味着你会中止执行，那么尝试其他复制操作没有任何意义。在这种情况下，不去尝试其他复制操作会更高效；因此，条件执行方法是最佳选择。选择最适合你情况的方式。

我之前提到过一种条件执行的替代语法。对于那些喜欢使用括号而非插入符号的用户，以下版本的代码在功能上与之前的示例相同：

```
xcopy %sorc1% %targ%\ /Y /F && (
  xcopy %sorc2% %targ%\ /Y /F) && (
  xcopy %sorc3% %targ%\ /Y /F) && (
  xcopy %sorc4% %targ%\ /Y /F) || (
     > con echo Exactly one of four possible copies FAILED
  ) 
```

哪个更容易阅读是一个有争议的问题。我喜欢两者，都没有强烈的意见（这本身可能和任何语法一样奇怪）。

> 注意

*当使用多个运算符进行条件执行时，我通常会将继续的行缩进两个空格，以便与代码块区分开来，代码块通常会缩进三个空格。有时我会将继续的行缩进超过三个空格，但我从不将其缩进正好三个空格。*

#### 多个 || 运算符

让我们颠倒一下最后的场景。我们将使用相同的 xcopy 命令，并且我们不一定希望它们都执行。不同之处在于，我们只需要其中一个复制操作成功。也许某个资源文件有多个可能的位置，且有一个层级结构决定选择的顺序。如果我们成功复制了一个文件，我们希望跳过后续的复制尝试，并调用一些使用该文件的进程，但为了简化起见，echo 命令会简单地声明成功。

再次假设源文件和目标路径在代码前面已经定义，示例 28-3 中的代码至多复制一个文件。

```
(
   xcopy %sorc1% %targ%\ /Y /F ^
     || xcopy %sorc2% %targ%\ /Y /F ^
     || xcopy %sorc3% %targ%\ /Y /F ^
     || xcopy %sorc4% %targ%\ /Y /F
) && (
   > con echo Exactly one of four possible copies SUCCEEDED
) 
```

示例 28-3：多个 || 运算符后跟一个 && 运算符

与 Listing 28-2 相比，这里最显著的区别是多个||运算符分隔了 xcopy 命令，并且&&运算符位于尾部命令之前。一个更微妙的区别是，xcopy 命令构成了整个代码块。

假设源文件都不存在，我们逐步分析逻辑。第一个 xcopy 命令无条件执行，并且失败，设置 errorlevel 为 4；非零的返回码和第一个||运算符触发了第二个 xcopy 命令，该命令也失败；两个更多的||运算符和两次失败导致最后两个 xcopy 命令执行并失败。最后一次失败将 errorlevel 设置为 4，控制流退出第一个代码块。解释器立即找到&&运算符，快速检查 errorlevel，发现它不是 0，于是*不*执行 echo 命令。

当其中一个复制成功时，事情变得更加有趣。假设第一个 xcopy 命令成功地将 sorc1 表示的文件复制到目标路径。由于返回码良好和第一个||运算符，解释器不会执行下一个 xcopy 命令。此外，它甚至不会识别第三个和第四个命令。当你考虑到这四个 xcopy 命令实际上都是同一行继续代码的一部分时，这就更容易理解了。一旦解释器确定在||运算符之后的命令不会执行，之后的任何命令都不会执行。

更有趣的是，控制流在第一个成功复制之后退出第一个代码块，解释器找到了&&运算符。由于第一个 xcopy 命令成功，errorlevel 等于 0，因此包含 echo 命令的代码块会执行。

如果第一个 xcopy 命令失败，而第二个命令成功，第三个和第四个命令不会执行，因为第二个||运算符，但 echo 命令会执行，因为第一个代码块之后跟着&&运算符。同样，如果第三个或第四个 xcopy 命令是第一个成功复制文件的命令，echo 命令也会执行。

括号在这个例子中至关重要。在前面的部分，四个命令通过&&运算符分隔，最后一个命令在||运算符之后执行。在这个例子中，运算符被反转，展示了它们之间的显著差异。我稍后会解释括号为何存在，但首先，由于使用这种条件执行语法的主要原因之一是为了简化代码，注意下面这五行代码在功能上等同于之前的列表：

```
(xcopy %sorc1% %targ%\ /Y /F ^
  || xcopy %sorc2% %targ%\ /Y /F ^
  || xcopy %sorc3% %targ%\ /Y /F ^
  || xcopy %sorc4% %targ%\ /Y /F
) && > con echo Exactly one of four possible copies SUCCEEDED 
```

我不太喜欢这种语法，因为它确实违背了我关于裸代码块的括号对齐惯例（第十六章）。不过，它简洁明了，但我发现有更多空格的版本更具可读性。

这里是相同的基本逻辑，使用伪`if...else`结构来写一条消息，表示复制一个文件的成功或失败：

```
(
   xcopy %sorc1% %targ%\ /Y /F ^
     || xcopy %sorc2% %targ%\ /Y /F ^
     || xcopy %sorc3% %targ%\ /Y /F ^
     || xcopy %sorc4% %targ%\ /Y /F
) && (
   > con echo Exactly one of four possible copies SUCCEEDED
) || (
   > con echo One or more of four copies FAILED
) 
```

这里有一个必要的警告，如果第一个`echo`命令以某种方式将错误级别重置为非零值，那么第二个`echo`命令也会执行。

#### 多个`&&`与多个`||`运算符

我承诺在 Listing 28-3 中解释为什么在使用多个`||`运算符时需要括号，但在 Listing 28-2 中使用多个`&&`运算符时不需要。

要理解这一点，首先看一下这个由多个通过`&&`运算符分隔的命令以及后续`||`运算符组成的通用语法：

```
command1 && command2 && command3 && command4 && command5 || command6
```

假设`command1`返回 0。如果是这样，`command2`会执行；假设它执行失败并返回非 0。由于`&&`运算符在`command3`之前，解释器不会执行该命令，而是跳过它，继续寻找另一个`&&`运算符；错误级别仍然非 0，因此它也跳过`command4`。它又找到了一个`&&`运算符，所以`command5`不会执行。但接下来解释器找到了`||`运算符，第二条命令返回的非 0 错误级别触发了`command6`的执行。

现在让我们交换每个条件执行运算符。这更像是我们想让一个命令成功执行，但不超过一个的场景：

```
command1 || command2 || command3 || command4 || command5 && command6
```

假设这次`command1`返回的不是 0。由于`command2`之前有`||`运算符，第二条命令也会执行；现在假设它成功执行并返回 0。由于后面的`||`运算符，逻辑流程会跳过`command3`。这就是有趣的地方。

解释器*不会*继续查找另一个运算符。该行在此被放弃，无论后续的命令和运算符是什么。

这是非常重要的，也是我在 Listing 28-3 中加入括号并使用多个`||`运算符的原因。请考虑这种看似微小的语法调整：

```
(command1 || command2 || command3 || command4 || command5) && command6
```

如果用一对括号将通过`||`运算符分隔的命令包围起来，第一个命令会无条件执行。括号内的其他命令只有在前一个命令失败时才会执行。执行多少条命令并不重要；只要其中一条命令成功执行，或者它们全部失败，控制流就会退出括号内的逻辑。接着，解释器会立即遇到`&&`运算符，只有在某个命令（最后一个执行的命令）返回 0 时，`command6`才会执行。

使用多个条件执行运算符时不要做任何假设；一定要进行测试。

### 总结

如果从这一章没有别的东西要记住的话，`&&`不是一个与运算符，`||`也不是一个或运算符。它们分别是评估错误级别是否为 0 或不为 0 的条件执行运算符。我已经详细讲解了每个运算符单独、组合以及串联使用时的工作原理。

条件执行类似于 if 命令，但你已经了解了在成功使用该技巧之前必须知道的重要区别。尽管在所有情况下它并不理想，但它确实提供了一种非常简洁的替代语法。我还解释了解释器如何处理这两种运算符之间的重要区别，并演示了一些实际应用。

在下一章，我将回到在 Batch 中构建最初未曾设想的工具的概念，即数组和哈希表。
