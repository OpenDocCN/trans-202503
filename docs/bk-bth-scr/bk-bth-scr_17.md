

## 第十六章：16 代码块



![](img/chapter.jpg)

*代码块* 有时是一个相当通用的术语，指的是程序中的某个模糊部分或几行代码。在 Batch 中，它是一个明确定义的实体：一组在一对圆括号之间的命令。一个显著的例子是当 if 命令为真时经常执行的代码。

这看起来很简单，但实际上，正确且明智地使用代码块远比定义它要困难得多。Batch 的一个非常强大的功能是延迟扩展，它允许你在代码块内部以两种不同的方式解析变量，但初学者往往将这种功能误解为一个 bug。在本章中，我将详细介绍所有涉及的复杂问题，另外你还会学到如何使用代码块，特别是裸代码块，提供一种有趣的技术，使变量能够在有限范围的代码中生存。如果这听起来还不够令人印象深刻，我相信很快你会觉得它非常有用。

### 在代码块中解析变量

我在第二章中详细讨论了设置和解析变量的过程，但这些规则在代码块内部会有所不同。正如我很快将展示的那样，这是 Batch 的一个伟大功能，但它经常被误解，并可能导致程序员感到困惑和烦躁。即使是在多年的 Batch 编码经验之后，偶尔我也会碰到这个问题。虽然我通常能够相对迅速地找到并修复这个问题（在发出一声“哎呀！”后），但对于初学者来说，这可能会导致数小时的沮丧。这种警告最好通过一个示例来说明。

在许多情况下，同事们向我展示了一些看似简单的代码片段，比如列表 16-1 中的代码。

```
set price=$450
if %bSale% (
   set price=$350
   > con echo The sale price of a 50-inch TV is %price%.
) 
```

列表 16-1：在代码块中设置并解析的变量...以及一个谜团

代码块旁边跟着一条令人沮丧的提问：

一个变量有一个初始值，但我将其重设为另一个值，然而它似乎并没有“生效”。我将一台 50 英寸电视的价格设置为 450 美元，且我知道 bSale 布尔值为真，因为控制台确实输出了信息，但是变量的值并没有被重设为 350 美元。回显命令输出了 450 美元。这就像是代码块中的第一条命令没有执行，而第二条却执行了。疯狂吧？为了验证这个理论，我将回显命令从 if 命令代码块内部移动到其后面。突然，我得到了我想要的销售价格显示，但这并不是解决方法，因为我只想在有促销的情况下执行命令。我甚至尝试在 if 命令之前不设置变量，但结果它什么都没有。唉！这太不合逻辑了。到底发生了什么？

简短且过于简略的回答是：“将百分号替换为感叹号。”对列表 16-1 所需的唯一更改就是在回显命令的末尾解析价格：

```
set price=$450
if %bSale% (
   set price=$350
   > con echo The sale price of a 50-inch TV is !price!.
) 
```

结果正是那位困惑的程序员一直预料的：

```
The sale price of a 50-inch TV is $350.
```

当程序员难以置信地尝试并看到感叹号生效时，他们通常会感到更加恼火而非宽慰，并带着另一个问题和新的抱怨返回：“有时候你用百分号来解析一个变量，而有时又用感叹号。什么样的编程 sadist 会想到这个？难道 Batch 还不够深奥吗？当我设置一个变量时，我希望它被设置好。就这样。它有什么用？”这种抨击的唯一变化就是其强度和粗俗程度。这些评论来自一位非常温和且虔诚的同事。在回答这个功能用途的问题之前，我得先给你更好的解释，说明价格变量发生了什么。

一个变量同时拥有两个值是延迟展开的另一个应用，延迟展开首次在第三章中介绍，它允许在解析时或执行时解析变量。当一个变量在代码块内被设置时，你可以认为它此时拥有两个值。一个是它在代码块中设置时的当前值，在执行时解析。另一个是它进入代码块时被赋予的值，在解析时解析。

如果一个变量同时有两个不同的值，我们就需要两种不同的方式来解析这个变量。为此，*百分号是用于揭示其进入代码块时的值的分隔符*，而*感叹号是用于获取其在代码块内当前值的分隔符*。代码可以多次重设一个变量，而百分号分隔符仍然会将它解析为进入代码块之前的状态。

结果是，在列表 16-1 中的 echo 命令时，%price% 被解析为 $450，而 !price! 被解析为 $350。

尽管我的同事表示抗议，这根本不是什么虐待狂行为；它实际上代表了一个在大多数编程语言中缺乏的有趣特性。一个变量能够持有两个值可能很难理解，但一旦理解，它会带来许多可能性。为了演示，我将修改在列表 16-1 中写入控制台的消息。与其仅仅给出销售价格，展示原价和销售价格，显示节省的金额会更容易理解。我在列表 16-2 中为这两个值使用了相同的价格变量——一次使用百分号解析，一次使用感叹号解析。

```
set price=$450
if %bSale% (
   set price=$350
   > con echo A 50-inch TV has been marked down from %price% to !price!.
) 
```

列表 16-2：一个变量解析为两个不同的值

这一点从本质上来说是有意义的，因为这两个值实际上都是一个*价格*；一个是原始价格，另一个是销售价格。你本可以使用两个不同的变量，也许是 origPrice 和 salePrice，但具有敏锐眼光的程序员可能会称列表 16-2 为优雅，这是对作者的最高赞誉，尤其是在看到输出结果之后：

```
A 50-inch TV has been marked down from $450 to $350.
```

这个特性为富有想象力的编码者提供了许多可能性。你可能有一个计数器或一个变量在循环内部累计数字（在接下来的几章中，我将最终介绍 for 命令和循环）。在该循环内部，你可能需要访问原始的计数器或累计值以进行比较。循环的某些迭代中的数据条件可能会提醒你该循环本不该被处理。如果没有这个特性，你需要先执行一次循环进行验证，再执行一次处理核心逻辑。而有了延迟扩展，你只需一个循环，在任何时刻，你可以将所有变量恢复到原始值并退出循环。

这就引出了一个问题：嵌套代码块中会发生什么？在一个 if 命令的代码块内嵌套另一个 if 命令代码块时，是否会有三个活动的变量值？不会。只有两个值；一个是进入最外层代码块之前的值，另一个是代码块内部的当前值，无论嵌套层次如何。

F. Scott Fitzgerald 曾著名写道：“一流的智慧的考验是能够同时持有两个相反的观点，并且仍然保持功能。”在之前的章节中，我曾侮辱过解释器的智力，但 Batch 在这种二元性中的功能能力确实表明我可能过于苛刻了。也许解释器能处理更高级的话题，甚至是理论物理学。SchrodingersCat 变量可以同时保存两个值：生与死。

### 裸代码块

在之前的例子中，我仅处理了 if 命令代码块中的变量，但本章之前讨论的内容适用于任何代码块。请记住，代码块实际上只是一个或多个命令放在一对圆括号内。

另一个代码块的例子是 if 命令的 else 关键字后面的代码。我之前已经提到过，for 命令使用代码块，这些代码块可能会非常复杂，包含嵌套和频繁赋值与重新赋值的多个变量。这就是为什么这一章是接下来的讨论最重要 Batch 命令的最后先决条件。但是代码块不一定非得与命令关联。

一个 *裸代码块* 是作为其自身的实体创建的，而不是与 if 或 for 等命令相关联。例如，我们可以在没有 if 和条件子句的情况下重写 列表 16-2 中的 if 命令。列表 16-3 中的裸代码块刚开始看起来有些奇怪，但请注意，除了删除了文本 if %bSale% 外，其他一切都与之前相同。

```
set price=$450
(
   set price=$350
   > con echo A 50-inch TV has been marked down from %price% to !price!.
) 
```

列表 16-3：一个裸代码块，其中价格有两个值

这段代码仍然在进入代码块之前将价格变量设置为原始价格，而在代码块内，我们将该变量重置为销售价格。

在输出中，我们看到相同的文本，包括两个价格，唯一的区别是代码总是将以下内容写入控制台，因为原本是条件逻辑的部分现在无条件执行：

```
A 50-inch TV has been marked down from $450 to $350.
```

要真正展示这些括号的威力，只需移除它们并检查效果。这正是我在这里所做的，而且我甚至没有重新对齐缩进，尽管这么做对结果没有任何影响。将其与 清单 16-3 进行对比：

```
set price=$450
   set price=$350
   > con echo A 50-inch TV has been marked down from %price% to !price!. 
```

实际上，这段代码没有意义。我们在一行中设置变量，并在接下来的紧接一行中重置它，这完全废除了第一个 set 命令，那个命令不如注释掉或删除。现在，price 变量只有一个值，百分号符号和感叹号都将变量解析为其唯一值 $350，导致输出不合逻辑：

```
A 50-inch TV has been marked down from $350 to $350.
```

这组括号对代码清单产生了显著影响。它们创建了一个裸代码块，使得变量可以具有两个值，每个值可以通过不同的分隔符访问。没有括号时，代码就是废话。

使用裸代码块时，保持打开和关闭括号在同一列，并确保代码块中的代码按需缩进，就像它跟随一个 if 命令一样，这是一种良好的编码风格。你可以将 清单 16-3 中的第二个 set 命令与打开括号放在同一行，并将关闭括号放在 echo 命令后面，但这样做会让代码变得非常难以阅读。（我甚至不想展示它。）如果你在编写裸代码块时，可能有充分的理由这么做，如果你隐藏了它的存在，那么一个优雅的解决方案突然就变得难以理解。

使用裸代码块的一个很好的理由是交换两个变量的值，而不需要中介变量。这个代码将 fact 转换为 fiction，将 fiction 转换为 fact，做得比任何政治家都好：

```
(
   set fact=%fiction%
   set fiction=%fact%
) 
```

第一个 set 命令只是重置了 fact 变量，但第二个 set 命令在重置 fiction 时并没有使用这个更新后的值。相反，百分号符号在进入裸代码块之前将 fact 解析为其值。解释器在设置任何变量之前会读取并解析这两个 set 命令——并解析两个变量。如果你删除了括号，两个变量都会采用最初定义为 fiction 的值，从而完全失败了值交换。

### 生存于一个 endlocal 命令

任何代码块，尤其是裸代码块，还有一个非常有用的功能：让变量在 `endlocal` 命令之后依然生存。在第三章中，你学到了所有在 `setlocal` 命令和 `endlocal` 命令之间的变量都会在 `endlocal` 执行后恢复到它们的先前状态。这个很棒的批处理功能确保被调用的例程不会覆盖可能由调用者使用的变量，但它也提出了一个非常关键的问题。如果 `endlocal` 命令后什么都不能存活，那被调用的例程如何返回结果呢？

#### `endlocal` 命令的“问题”

为了演示这个问题，清单 16-4 中的例程接受一个以美元和美分表示的货币金额作为第一个参数，并尝试将加上 6% 销售税后的金额作为第二个参数返回。

```
:AddTax
 setlocal
 set factor=106
 set inAmt=%~1
 set amtNoDec=%inAmt:.=%
 set /A wTaxNoDec = amtNoDec * factor + 50
 set wTaxDec=%wTaxNoDec:~0,-4%.%wTaxNoDec:~-4,2%
❶ set %2=%wTaxDec%
❷ endlocal
 goto :eof 
```

清单 16-4：浪费的好数学

现在，不要被数学问题困住。（有关详细信息，请参阅“给我数学极客朋友的算术插曲”框。）与此讨论相关的是，`:AddTax` 例程以 `setlocal` 命令开始，随后是六个 `set` 命令。最后一个 `set` 命令 ❶ 将算术结果分配给第二个参数，但 `endlocal` 命令 ❷ 紧接着就清除了它。没有任何返回。我试图保护或隐藏对前五个变量的更改，使其不被例程外的代码看到，但我也希望让这个最后一个变量通过。到目前为止，我没有成功。

经过一番深思熟虑，倒退命令可能在 `goto :eof` 之前有意义。

```
endlocal
set %2=%wTaxDec%
goto :eof 
```

可惜，这个方法也不行。现在，`wTaxDec` 变量在 `endlocal` 后消失了，所以这个逻辑很可能将返回参数设置为“无”（或者 `wTaxDec` 在例程之前设置的值）。这是同一问题的不同表现；在 `setlocal` 和 `endlocal` 之间设置的内容都不会保存。

#### 裸代码块解决方案

只需简单地添加两个括号（并加上一些缩进以提高可读性），就可以创建一个以 `endlocal` 命令开始的代码块——并解决问题。与清单 16-4 相比：

```
:AddTax
 setlocal
 set factor=106
 set inAmt=%~1
 set amtNoDec=%inAmt:.=%
 set /A wTaxNoDec = amtNoDec * factor + 50
 set wTaxDec=%wTaxNoDec:~0,-4%.%wTaxNoDec:~-4,2%
 (
    endlocal
    set %2=%wTaxDec%
 )
 goto :eof 
```

左括号开始了代码块。`endlocal` 命令清除了五个变量的*当前*状态，将它们恢复到 `setlocal` 之前的状态。现在，事情变得有趣了。感叹号会将变量解析为代码块内部的当前状态，而百分号会将变量解析为代码块开始前的状态，即 `endlocal` 执行之前的值。因此，`!wTaxDec!` 解析为无（或垃圾），但 `%wTaxDec%` 解析为代码块前赋值的那个值，而那正是我在离开例程之前分配给第二个参数的值。

关键点是，在裸代码块内有一个狭窄的窗口——从 endlocal 到右括号之间——我们可以通过百分号解析这五个变量。我利用这个窗口，通过百分号解析出我需要的唯一一个变量，并将其值赋给返回参数。

现在我们只需要调用例程来查看它的效果：

```
call :AddTax 25.75 result
> con echo The amount with tax is $%result%. 
```

以下输出展示了成功将 6% 的销售税添加到原始金额中：

```
The amount with tax is $27.30.
```

这个例子设置了一个由例程返回的参数，但例程并不是这种技术的必需部分。在批处理文件的任何位置，你都可以通过调用 setlocal 命令来隐藏变量。在以下示例中，两个变量 survive 和 persist 在代码块中的 endlocal 之后依然存在，但 extinct 变量则不会：

```
setlocal
set survive=This variable will survive the endlocal
set persist=Multiple variables can survive and persist past the endlocal
set extinct=Time is very short for this variable
(
   endlocal
   set survive=%survive%
   set persist=%persist%
) 
```

这个代码块类似于之前的示例，但有两个相关的不同之处。首先，它保留了多个变量。其次，set 命令看起来是多余的——每个变量都被设置为其自身的解析值。每个变量的当前值在 endlocal 后是空的，但最后两个 set 命令将变量在代码块之前的值恢复过来。

这个技巧简单却不直观。endlocal 命令开始了一个裸代码块，接着是一条或多条 set 命令赋值变量，通常是赋值给它们自己。裸代码块外部的世界现在可以使用共享的变量，但不能使用任何未共享的变量。如果你希望有条件地进行赋值，只需在裸代码块中的 set 命令周围加上 if 命令和你选择的条件子句。

我必须承认，对于这个任务，还有一种不涉及裸代码块的替代方案。我的一部分心情有些后悔分享它，但我还是会分享，因为你可能某天会遇到它。你也可以通过将之前的裸代码块替换为这行非常丑陋的三条命令，使这两个变量在 endlocal 之后仍然生效：

```
endlocal&set survive=%survive%&set persist=%persist%
```

在每个命令分隔符（&）后添加一个或两个空格可能会使其更具可读性，但远远不够。请使用裸代码块。

### 总结

在本章中，你学习了如何在代码块中解析变量。下次当你听到有人说，“在代码块内使用感叹号，外部使用百分号”时，我希望你能有足够的知识为这场对话增添一些深度。现在你已经学会了延迟扩展和变量解析在代码块中的细微差别，你不仅能让某些东西工作，还能在适当的地方使用变量中的两个值。我还介绍了裸代码块，并展示了它在允许变量在 endlocal 命令后依然存在方面的重要作用。

接下来是久违的命令。现在我们已经准备好深入探讨这个非常重要的批处理命令，在第二部分中。
