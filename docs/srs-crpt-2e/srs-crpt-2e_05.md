

## 第四章：3 密码学安全



![](img/opener.jpg)

密码学中的安全定义与一般计算机安全的定义不同。软件安全和密码学安全的主要区别在于，我们可以*量化*后者。不同于软件领域，在那里我们通常说应用程序要么安全，要么不安全，在密码学领域，通常可以计算破解一个密码算法所需的努力程度。而且，软件安全侧重于防止攻击者滥用程序的代码，而密码学安全的目标是让某些明确的问题变得不可能解决。

密码学问题涉及数学概念，但不涉及复杂的数学——至少在本书中不涉及。本章将介绍一些这些安全性概念以及如何将它们应用于解决实际问题。在接下来的章节中，我将讨论如何以理论上严谨和实际相关的方式量化密码安全性。我将讨论无条件安全与计算安全、比特安全与完全攻击成本、可证明安全与启发式安全、对称与非对称密钥生成等概念。我将在本章结束时，通过一些看似强大的密码学失败的现实案例来总结。

### 定义不可能

在第一章中，我描述了一个密码的安全性相对于攻击者的能力和目标，并认为如果在已知攻击者的能力下无法实现这些目标，则该密码是安全的。那么，在这个背景下，*不可能*是什么意思呢？

有两个概念定义了密码学中“不可能”的含义：无条件安全和计算安全。大致来说，*无条件安全*是关于理论上的不可能性，而*计算安全*是关于实际上的不可能性。无条件安全并没有量化安全性，因为它将密码视为要么安全，要么不安全，没有中间地带；因此，它在实践中没有用，尽管在理论密码学中起着重要作用。计算安全是衡量密码强度的更相关和实用的标准。

#### 理论中的安全性：无条件安全

无条件安全并不是基于破解一个密码有多难，而是基于是否可以想象破解它。只有在给定无限的计算时间和内存时，密码无法被破解，这时它才是无条件安全的。即使破解一个密码需要数万亿年，这样的密码也是无条件的*不*安全。

例如，第一章中的一次性密码本是无条件安全的。回想一下，一次性密码本将明文 *P* 加密为密文 *C* = *P* ⊕ *K*，其中 *K* 是一个唯一的随机比特串，专用于每个明文。这个密码是无条件安全的，因为即使给定一个密文，并且有无限时间来尝试所有可能的密钥 *K* 并计算对应的明文 *P*，你仍然无法识别正确的 *K*，因为有多少个可能的 *P*，就有多少个可能的 *K*。

#### 实践中的安全性：计算安全

与无条件安全不同，计算安全将一个密码视为安全的标准是，如果它在*合理*的时间内，且在合理的资源限制下（如内存、硬件、预算和能量），无法被破解。计算安全是一种量化密码或任何加密算法安全性的方法。

例如，考虑一个密码**E**，你知道一个明文-密文对（*P*，*C*），但不知道计算 *C* = **E**(*K*，*P*) 的 128 位密钥 *K*。这个密码不是无条件安全的，因为你可以通过尝试 2¹²⁸ 个可能的 128 位 *K*，直到找到一个满足 **E**(*K*，*P*) = *C* 的密钥来破解它。但实际上，即便每秒测试 1000 亿个密钥，也需要超过 100,000,000,000,000,000,000 年。换句话说，合理来说，这个密码是计算上安全的，因为几乎不可能破解。

我们可以用两个值来表示计算安全性：

+   *t*，是攻击者将要执行的操作次数的上限

+   ε (*epsilon*)，是攻击成功概率的上限

然后我们可以说，一个加密方案是 (*t*, ε)-*安全的*，如果一个执行最多 *t* 次操作的攻击者——无论这些操作是什么——成功的概率不高于 ε，其中 ε 至少为 0，最多为 1。计算安全性提供了破解加密算法的难度的界限。

需要认识到 *t* 和 ε 只是上限：如果一个密码是 (*t*, ε)-安全的，那么在进行少于 *t* 次操作的攻击者将不会成功（成功概率为 ε）。然而，这并不意味着一个执行恰好 *t* 次操作的攻击者会成功，也没有提供所需的操作次数，这个次数可能远大于 *t*。我们说 *t* 是必要计算努力的*下限*，因为你至少需要 *t* 次操作才能破解安全性。

如果我们确切知道破解一个密码所需的努力量，我们就可以说 (*t*, ε)-安全提供了一个*紧密的界限*，当存在一个攻击，可以通过 ε 的概率和恰好 *t* 次操作来破解密码时。

例如，考虑一个具有 128 位密钥的对称加密算法。理想情况下，该加密算法应该是(*t*, *t/*2¹²⁸)-安全的，适用于任何值的*t*，其中 1 ≤ *t* ≤ 2¹²⁸。最好的攻击方式应为*暴力破解*（尝试所有密钥直到找到正确的）。任何更好的攻击都必须利用加密算法中的某些缺陷，因此我们努力创建那些暴力破解是最好的攻击方式的加密算法。

给定(*t*, *t*/2¹²⁸)-安全性，我们来检查三种可能攻击的成功概率：

+   在第一个情况下，*t* = 1，攻击者尝试一个密钥并以概率ε = 1/2¹²⁸成功。

+   在第二种情况下，*t* = 2¹²⁸，攻击者尝试所有 2¹²⁸个密钥，并且最终成功。因此，成功的概率ε = 1。（如果攻击者尝试所有密钥，正确的密钥必定在其中。）

+   在第三种情况下，攻击者仅尝试*t* = 2⁶⁴个密钥，并以概率ε = 2⁶⁴/2¹²⁸ = 2^(-64)成功。当攻击者只尝试部分密钥时，成功的概率与尝试的密钥数量成正比。

我们可以得出结论，一个具有*n*位密钥的加密算法，最好的安全性为(*t*, *t/*2*^n*)-安全，适用于任何 1 ≤ *t* ≤ 2*^n*，因为无论加密算法多么强大，对其进行暴力破解的攻击总是会成功。因此，密钥长度需要足够长，以有效抵御实际中的暴力破解攻击。

> 注意

*在这个例子中，我们计算的是加密算法的评估次数，而不是绝对的时间或处理器时钟周期数。计算安全性与技术无关，这意味着今天是(*t*, ε)-安全的加密算法，明天仍将是(*t*, ε)-安全的——但今天被认为安全的东西，明天可能不再被认为安全。*

### 量化安全性

当你发现一个攻击方式时，首先应弄清楚它在理论上有多高效，以及它在实际中有多可行。同样，给定一个声称安全的加密算法，你也需要知道它能承受多少工作量。为了回答这些问题，我将解释如何以比特为单位衡量密码学安全性（理论视角），以及哪些因素影响实际攻击的成本。

#### 以比特为单位衡量安全性

当谈到计算安全性时，如果一个加密算法的成功攻击至少需要*t*次操作，那么它被认为是*t*-安全的。因此，我们通过假设成功概率ε接近 1，或者我们在实际中关心的任何概率，来避免使用不直观的(*t*, ε)表示法。然后我们以比特为单位表示安全性，其中“*n*位安全性”意味着我们需要大约 2*^n*次操作来破坏某个特定的安全概念。

如果你大致知道破解一个密码需要多少操作，你可以通过取操作次数的二进制对数来确定其位安全级别：如果需要 1,000,000 次操作，安全级别就是 log2，大约是 20 位（因为 1,000,000 大约等于 2²⁰）。记住，一个*n*位的密钥最多只能提供*n*位的安全性，因为一个暴力破解攻击通过所有 2*^n*个可能的密钥总会成功。但密钥大小并不总是与安全级别相匹配——它只提供一个*上界*，即最高可能的安全级别。

安全级别可能会小于密钥大小，原因有二：

+   一种攻击用比预期更少的操作破解了密码——例如，使用一种方法，通过只尝试 2*^n*密钥的一个子集来恢复密钥。

+   密码的安全级别故意与其密钥大小不同，正如大多数公钥算法一样。例如，具有 1,024 位私钥元素（因此具有 2,048 位模数）的 RSA 算法提供的安全性不足 128 位。

位安全性在比较密码的安全级别时很有用，但它并未提供关于攻击实际成本的足够信息。它有时是一个过于简单的抽象，因为它假设一个*n*位安全的密码需要 2*^n*次操作才能破解，无论这些操作是什么。因此，两个具有相同位安全级别的密码在实际攻击成本上可能有着巨大的差异。

假设我们有两个密码，每个密码都有 128 位的密钥和 128 位的安全性。我们必须评估每个密码 2¹²⁸次才能破解它，但第二个密码比第一个慢 100 倍。因此，评估第二个密码 2¹²⁸次的时间相当于评估第一个密码 100 × 2¹²⁸ ≈ 2^(134.64)次。如果我们按照第一个快速密码来计算，那么破解第二个密码需要 2^(134.64)次操作。如果我们按照第二个慢密码来计算，则只需要 2¹²⁸次操作。那么我们是否应该说第二个密码比第一个更强？原则上是的，但我们很少看到常见密码之间有如此百倍的性能差异。

操作定义的不一致性在比较攻击效率时带来了更多困难。有些攻击声称通过执行 2¹²⁰次某种操作而不是 2¹²⁸次密码操作来降低密码的安全性，但每种攻击类型的速度在分析中被忽略了。2¹²⁰次操作的攻击并不总是比 2¹²⁸次暴力破解攻击更快。

然而，只要操作被合理定义——即大约与评估密码的速度相同——位安全性仍然是一个有用的概念。毕竟，在现实生活中，判断安全级别是否足够所需要的只是一个数量级。

#### 计算完整攻击成本

比特安全通过估算执行成功所需的操作数量的数量级来表示对加密算法最迅速攻击的成本。但其他因素也会影响攻击的成本，我们在估算实际安全水平时必须考虑这些因素。我将解释四个主要因素：并行性、内存、预计算和目标数量。

##### 并行性

第一个需要考虑的因素是计算并行性——即攻击实现是否能够利用并行计算，如多核系统。

例如，考虑这两次各自执行 2⁵⁶ 次操作的攻击：

+   第一次攻击执行 2⁵⁶ *顺序依赖* 操作，计算 *x*i [+ 1] = *f*i(*x*i)，其中 *x*[0] 是固定的，*f*i 是不同的函数（*i* 从 1 到 2⁵⁶）。

+   第二次攻击执行 2⁵⁶ *独立* 操作，计算 *x*i = *f*i(*x*)，其中 *x* 是固定的，*f*i 是不同的函数（*i* 从 1 到 2⁵⁶）。因为每个 *f*i(*x*) 互相独立，所以它们可以并行执行。

这两次攻击的区别在于，第二次攻击可以并行化，而第一次攻击不能。并行处理比顺序处理要快几个数量级。例如，如果你有 2¹⁶ = 65,536 个处理器可用，你可以将并行攻击的工作负载划分为 2¹⁶ 个独立任务，每个任务执行 2⁵⁶ / 2¹⁶ = 2⁴⁰ 次操作。然而，第一次攻击无法利用多个核心，因为每个操作依赖于前一个操作的结果。因此，尽管两次攻击执行相同数量的操作，平行攻击将比顺序攻击快 65,536 倍。

> 注意

*当* N *个核心可用时，*攻击速度会加速 N 倍的算法是* 极易并行化*；它们的执行时间与计算核心的数量成线性关系。*

##### 内存

在确定攻击成本时，第二个因素是内存。我们评估密码分析攻击时考虑时间和空间的使用：它们在时间上执行了多少操作，占用了多少内存或空间，如何利用这些空间，以及可用内存的速度如何？不幸的是，比特安全仅关注执行攻击所需的时间。

关于攻击如何使用空间，考虑攻击所需的内存查找次数、内存访问的速度（可能在读写操作之间有所不同）、访问数据的大小、访问模式（连续或随机内存地址）以及数据在内存中的结构是很重要的。例如，在 2021 年 Intel Xeon 8380 Ice Lake 处理器上，访问一个寄存器需要 1 个时钟周期，访问 L1 缓存（48KB）需要 5 个周期，访问 L2 缓存（1.25MB）需要 14 个周期，访问 L3 缓存（60MB）需要 63.5 个周期，而访问 DRAM 的速度最好和 L3 缓存一样快，但通常比访问 L3 缓存慢得多（具体延迟取决于多个因素）。

##### 预计算

预计算操作只需执行一次，并可以在随后的攻击执行中重用。我们有时称预计算为攻击的*离线阶段*。

考虑时间-内存权衡攻击，在这种攻击中，攻击者执行一次巨大的计算，生成大型查找表，然后存储并重用这些表来执行实际的攻击。例如，针对 2G 移动加密的一次攻击花费了两个月的时间来构建 2TB 的表格，攻击者随后使用这些表格在仅仅几秒钟内破解了 2G 加密，并恢复了一个秘密会话密钥。

##### 目标数量

最后，我们来讨论攻击的目标数量。目标数量越多，攻击面越大，攻击者能够了解到他们所追寻的密钥的信息就越多。

例如，考虑暴力破解密钥搜索：如果你目标是一个*n*位密钥，需要进行 2*^n*次尝试才能确定找到正确的密钥。如果你目标是多个*n*位密钥——比如一个数量*M*——并且对于一个单一的*P*，你有*M*个不同的密文，其中*C* = **E**(*K*, *P*)表示你想要的每个*M*密钥(*K*)，那么每个密钥仍然需要 2*^n*次尝试来找到。但如果你只对*M*个密钥中的*至少一个*感兴趣，而不是每一个，那么平均来说，你将需要进行 2*^n*/*M*次尝试才能成功。例如，要破解一个 128 位的密钥，如果目标是 2¹⁶ = 65,536 个密钥，那么平均需要进行 2^(128 − 16) = 2¹¹²次密码评估。也就是说，攻击的成本（和速度）随着目标数量的增加而降低。

#### 选择和评估安全级别

选择安全级别通常涉及在大多数标准加密算法和实现中选择 128 位和 256 位的安全级别。你会发现一些 64 位或 80 位的安全方案，但这些方案通常不足以在实际应用中保证安全。

从高层次来说，128 位安全意味着你需要进行大约 2¹²⁸次操作才能破解该加密系统。为了让你了解这个数字的含义，可以考虑这样一个事实：宇宙大约有 2⁸⁸纳秒的历史（1 秒有 10 亿纳秒）。由于今天的技术测试一个密钥至少需要 1 纳秒，你需要几倍宇宙年龄的时间才能成功进行一次攻击（准确地说是 2⁴⁰倍）。

那么，难道并行处理和多个目标不会显著缩短成功攻击的时间吗？并非完全如此。假设你想破解其中一个百万个目标中的任意一个，并且你有一百万个并行核心可用。这将把搜索时间从 2¹²⁸缩短到(2¹²⁸ / 2²⁰) / 2²⁰ = 2⁸⁸，这相当于“仅仅”一个宇宙的寿命。

评估安全级别时，还需要考虑技术的演变。摩尔定律认为计算效率大约每两年就会翻倍。我们可以将其视为每两年失去 1 位安全性：如果今天 1000 美元的预算可以在一小时内破解一个 40 位密钥，那么根据摩尔定律，两年后，你可以用相同的 1000 美元预算在一小时内破解一个 41 位的密钥（我在简化）。我们可以从中推测，根据摩尔定律，80 年后我们的安全性将比今天少 40 位。换句话说，80 年后，执行 2¹²⁸次操作的成本可能和今天执行 2⁸⁸次操作一样。考虑到并行处理和多个目标的因素，我们需要大约 2⁴⁸纳秒的计算时间，也就是大约三天。但这个推测并不准确，因为摩尔定律不会也不能如此大幅度地扩展。不过，你可以理解：今天看起来不可行的事情，可能在一个世纪后变得现实。

在某些情况下，低于 128 位的安全级别是可以被接受的，比如当你只需要短时间的安全保护，或者实现更高安全级别的成本会对系统的成本或可用性产生负面影响时。一个例子是付费电视系统，其中加密密钥为 48 位或 64 位。听起来可能非常低，但实际上是足够的，因为密钥每 5 到 10 秒就会刷新一次。

然而，为了确保长期安全，你应该选择 256 位安全级别或略低于此的安全级别。即使在最坏的情况下——量子计算机的出现（见第十四章）——我们也不太可能在可预见的未来破解 256 位的安全方案。256 位以上的安全性在实际应用中是没有必要的，除非作为营销手段。

正如密码学家约翰·凯尔西曾经说的：“80 位和 128 位密钥搜索之间的差距，就像是前往火星与前往半人马座阿尔法星的差距。就我看来，192 位和 256 位密钥在实际暴力破解攻击中没有实质性的区别；不可能的事就是不可能。”

### 实现安全性

一旦选择了一个安全级别，确保你的加密方案保持在这个级别是很重要的。换句话说，你希望有*信心*，而不仅仅是希望和不确定性，确保事情会按照计划进行，始终如此。

在建立对密码算法安全性的信心时，你可以依赖于数学证明，这种方法我们称之为*可证明的安全性*，或者依赖于未能破解算法的证据，我称之为*启发式安全性*（虽然它有时也被称为*可能*安全性）。这两种方法是互补的，没有哪一种比另一种更好，正如你将看到的那样。

#### 可证明的安全性

可证明的安全性是指证明破解你的密码学方案至少和解决另一个已知困难的问题一样难。这样的*安全证明*保证了只要该困难问题依然困难，密码学就保持安全。这类证明称为*归约*，源自复杂性理论领域。我们说问题 X 可归约为破解某个密码，如果任何破解该密码的方法也会产生解决问题 X 的方法。这样的归约保证了只要问题 X 是困难的，密码就安全。

安全证明有两种类型，取决于你使用的假定困难问题的类型：相对于数学问题的证明和相对于密码学问题的证明。

##### 相对于数学问题的证明

许多安全证明（例如针对公钥密码学的证明）表明，破解一个密码学方案至少和解决某个困难的数学问题一样难。我们说的是那些我们知道有解且一旦知道解就容易验证，但计算上很难找到解的问题。

> 注

*没有真正的证据表明看似困难的数学问题实际上是困难的。事实上，证明这一点对于特定类别的问题来说是复杂性理论领域的最大挑战之一。写这篇文章时，克雷数学研究所为任何能证明这一点的人提供了 100 万美元的奖金。我在第九章中详细讨论了这个问题。*

例如，考虑解决*因式分解问题*，这是密码学中最著名的数学问题：给定一个你知道是两个素数（*n* = *pq*）乘积的数字，找出这两个素数。例如，如果 *n* = 15，答案是 3 和 5。对于一个小数字来说这很容易，但随着数字大小的增加，它会变得呈指数级难。比如，如果一个数字 *n* 长达 3000 位（大约 900 位十进制数字）或更多，因式分解被认为实际上是不可行的。

Rivest–Shamir–Adleman (RSA) 是最著名的依赖于因式分解问题的加密方案：RSA 通过计算 *C* = *P**^e* mod *n* 对明文 *P*（看作一个大数）进行加密，其中 *e* 和 *n* = *pq* 是公钥。解密通过计算 *P* = *C**^d* mod *n* 恢复明文，其中 *d* 是与 *e* 和 *n* 相关的私钥。如果我们能够因式分解 *n*，那么就可以破解 RSA（通过从公钥恢复私钥），如果我们能获得私钥，那么就能因式分解 *n*（例如，参见文章 *[`<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2004<wbr>/208`](https://eprint.iacr.org/2004/208)*）。换句话说，恢复 RSA 私钥和因式分解 *n* 是等价的困难问题。这就是我们在可证明安全性中寻求的那种归约。然而，并不能保证恢复 RSA 明文和因式分解 *n* 是同样困难的，因为明文的信息并不能揭示私钥。

##### 相对于另一个加密问题的证明

你可以将加密方案与其他加密方案进行比较，而不是与数学问题进行比较，并证明只有在能够破解第一个方案时，才能破解第二个方案。对称加密算法的安全性证明通常采用这种方法。

例如，如果你只有一个单一的置换算法，那么你可以通过将置换与各种输入类型组合，构建对称加密算法、随机比特生成器和其他加密对象，如哈希函数（如你将在第六章中看到的那样）。然后，证明表明，如果置换是安全的，那么新创建的方案也是安全的。换句话说，我们知道新创建的算法*不比*原始算法弱。此类证明通常通过给定对较大组件的攻击，构造对较小组件的攻击来工作——即通过展示一个归约。

当证明某个加密算法不比另一个算法弱时，主要的好处是减少了攻击面：你可以仅仅分析新加密算法的核心算法，而无需分析核心算法和组合的两部分。具体来说，如果你编写了一个使用新开发的置换和新组合的加密算法，你可以证明该组合在安全性上不弱于核心算法。因此，要破解该组合，你需要破解新的置换。

##### 注意事项

密码学研究人员在很大程度上依赖于安全证明，无论是针对数学问题方案还是其他加密方案。但安全证明的存在并不保证加密方案是完美的，也不能作为忽视实施中更实际方面的借口。毕竟，正如密码学家拉尔斯·克努森曾经说过的，“如果它是可以证明安全的，它可能并不安全”，这意味着安全证明不应被视为绝对的安全保障。更糟糕的是，有多种原因可能导致“可证明安全”的方案最终导致安全失败。

一个问题在于“安全证明”这一短语本身。在数学中，证明是对*绝对真理*的展示，但在密码学中，证明仅仅是对*相对真理*的展示。例如，证明你的加密算法像计算离散对数一样难以破解——给定 *g* 和 *g**^x* mod *n* 来找到 *x*——保证了如果你的加密算法失败，其他许多算法也会失败，如果最坏的情况发生，没人会怪你。

另一个警告是，通常人们根据单一的安全概念来证明安全性。例如，你可能证明恢复加密算法的私钥与因式分解问题一样困难。但如果你能在没有密钥的情况下从密文中恢复明文，那么你就绕过了这个证明，而恢复密钥几乎没有意义。

但证明并不总是正确的，破解一个算法有时可能比最初想的更容易。

> 注意

*不幸的是，很少有研究人员仔细检查安全证明，而这些证明通常长达数十页，因此使得质量控制变得复杂。尽管如此，证明不正确并不一定意味着证明的目标完全错误；如果结果是正确的，可以通过修正错误来挽救证明。*

另一个重要的考虑因素是，困难的数学问题有时会比预期的更容易解决。例如，某些弱参数使得破解 RSA 加密系统变得容易。或者，数学问题在某些情况下可能很难，但在大多数情况下却并不难，正如常常发生的那样，当参考问题是新的且没有被充分理解时。这就是 1978 年梅尔克和赫尔曼的背包加密方案后来被使用格减法技术破解的原因。

最后，虽然算法的安全证明可能没问题，但算法的实现可能很脆弱。例如，攻击者可能利用侧信道信息，如功耗或执行时间，来了解算法的内部操作并破解它，从而绕过证明。或者实现者可能滥用加密方案：如果算法过于复杂，且有太多配置选项，用户或开发者出错的几率就会增加，这可能导致算法完全不安全。

#### 启发式安全性

可证明安全性是获得对加密方案信心的好工具，但并不适用于所有类型的算法。事实上，大多数对称加密算法并没有安全性证明。例如，我们每天依赖 AES 来通过手机、笔记本电脑和台式计算机安全地通信，但 AES 并不是可证明安全的；没有证明它和某些知名问题一样难以破解。AES 无法与数学问题或其他算法关联，因为它本身就是那个难题。

在无法证明安全性适用的情况下，信任某个密码算法的唯一理由就是很多技术人员曾尝试攻破它但失败了。我们称这种安全性为*启发式安全性*。

我们什么时候可以确信一个密码算法是安全的？我们永远无法完全确信，但我们可以相当有信心某个算法不会被攻破，当成百上千的经验丰富的密码分析师每人都花费了数百小时尝试攻破它并发表了他们的研究成果——通常是通过攻击密码算法的*简化版本*（通常是操作步骤较少的版本，或是操作步骤数较少的*轮*，这些轮次是加密算法反复执行的操作序列，用来混合数据位）。

在分析新的加密算法时，密码分析师首先会尝试攻破一轮，然后是两轮、三轮，甚至尽可能多的轮数。*安全边际*则是总轮数与成功攻击的轮数之间的差值。经过多年的研究，如果某个加密算法的安全边际仍然很高，我们就可以相当有信心它是（可能）安全的。

### 生成密钥

如果你计划加密某些内容，你将不得不生成密钥，无论是临时的“会话密钥”（就像浏览 HTTPS 网站时生成的那种）还是长期的公钥。回想一下第二章中提到的，秘密密钥是加密安全的关键，应当随机生成，以便它们不可预测且保密。

例如，当你浏览一个 HTTPS 网站时，浏览器接收该网站的公钥，并使用它建立一个只在当前会话中有效的对称密钥，而该网站的公钥及其关联的私钥可能会有效多年。因此，攻击者最好很难找到它。但生成一个密钥并不总是像丢出足够的伪随机位那样简单。我们可以通过三种方式生成加密密钥：

+   *随机地*，使用伪随机数生成器（PRNG）来为密钥生成算法提供输入

+   通过*密码*，使用基于密码的密钥派生函数（PBKDF），它将用户提供的密码转换为密钥

+   通过*密钥协商协议*，即两个或更多方之间通过一系列消息交换，最终建立共享密钥的过程

目前，我将解释最简单的方法：随机生成。

#### 对称密钥

对称密钥是由两方共享的秘密密钥，它们是最简单生成的。它们通常与所提供的安全级别相同长度：一个 128 位的密钥提供 128 位的安全性，任何 2¹²⁸ 个可能的密钥都是有效的。

要使用加密的伪随机数生成器（PRNG）生成 *n* 位的对称密钥，你只需向它请求 *n* 位伪随机比特，并将这些比特作为密钥。这就完成了。例如，你可以使用 OpenSSL 工具包通过转储伪随机字节来生成一个随机的对称密钥，如下命令所示：

```
$ **openssl rand -hex 16**
65a4400ea649d282b855bd2e246812c6
```

你的结果当然会与我的不同。

#### 非对称密钥

与对称密钥不同，非对称密钥通常比它们提供的安全级别要长。但主要问题来自于非对称密钥比对称密钥更难生成，因为你不能仅仅从伪随机数生成器（PRNG）中获取 *n* 位并得到有效结果。非对称密钥不仅仅是原始的比特序列，而是代表一种特定类型的对象，比如一个具有特定属性的大数（在 RSA 中，是两个素数的乘积）。一个随机的比特串值（因此是一个随机数）不太可能具备所需的属性，因此不能成为有效的密钥。

要生成一个非对称密钥，你将伪随机比特作为种子输入到一个 *密钥生成算法* 中。这个算法以一个至少与预期安全级别一样长的种子值为输入，并从中构造一个私钥及其相应的公钥，确保两者都满足必要的标准。例如，RSA 的一个简单密钥生成算法会通过生成两个大致相同长度的随机素数，使用算法得到一个 *n* = *pq* 的数值。该算法会选择随机数，直到有一个是素数，因此你还需要一个算法来检测某个数字是否为素数。

为了避免手动实现密钥生成算法的麻烦，你可以使用 OpenSSL 来生成一个 4,096 位的 RSA 私钥，如下所示：

```
$ **openssl genrsa 4096**
Generating RSA private key, 4096 bit long modulus (2 primes)
..............................................................................
...............................++
...............................................++
e is 65537 (0x10001)
-----BEGIN RSA PRIVATE KEY-----
MIIJKQIBAAKCAgEA3Qgm6OjMy61YVstaGawk22A9LyMXhiQUU4N8F5QZXEef2Pjq
vTtAIA1hzpK2AJsv16INpNkYcTjNmechAJ0xHraftO6cp2pZFP85dvknsMfUoe8u
btKXZiYvJwpS0fQQ4tzlDtH45Gj8sMHcwFxTO3HSIx0XV0owfJTLMzZbSE3TDlN+
JdW8d9Xd5UVB+o9gUCI8tSfnOjF2dHlLNiOhlfT4w0Rf+G35USIyUJZtOQ0Dh8M+
`--snip--`
zO/dbYtqRkMT8Ubb/0Q1IW0q8e0WnFetzkwPzAIjwZGXT0kWJu3RYj1OXbTYDr2c
xBRVC/ujoDL6O3NaqPxkWY5HJVmkyKIE5pC04RFNyaQ8+o4APyobabPMylQq5Vo5
N5L2c4mhy1/OH8fvKBRDuvCk2oZinjdoKUo8ZA5DOa4pdvIQfR+b4/4Jjsx4
-----END RSA PRIVATE KEY-----
```

请注意，密钥以特定格式呈现——即在 BEGIN RSA PRIVATE KEY 和 END RSA PRIVATE KEY 标记之间的 base64 编码数据。这是一个大多数系统支持的标准编码格式，可以转换为原始字节数据。开始的点序列是一种进度条，而 e 是 65537 (0x10001) 表示在加密时使用的参数（记住，RSA 通过计算 *C* = *P**^e* mod *n* 来加密）。

#### 密钥保护

一旦你拥有了一个秘密密钥，你需要保持它的机密性，同时在需要时能够使用它。有三种方法可以解决这个问题：

**密钥封装（使用第二个密钥加密密钥）**

这种方法的问题在于，第二个密钥必须在需要解密受保护密钥时可用。在实际操作中，这第二个密钥通常是由用户在需要使用受保护密钥时提供的密码生成的。这就是安全外壳（SSH）协议的私钥通常受到保护的方式。

**实时生成密码**

这不需要存储加密文件，因为密钥直接来自密码。像加密货币钱包和密码管理器这样的系统通常使用这种方法。

尽管这种方法比密钥包装更直接，但它的普及程度较低，部分原因是它更容易受到弱密码的攻击。例如，假设攻击者截获了一些加密消息：如果我们使用密钥包装，攻击者首先需要获取受保护的密钥文件，该文件可能存储在用户的本地文件系统中或在密钥管理系统（KMS）中，因此不容易访问。但如果我们使用实时生成，攻击者可以通过尝试使用候选密码解密加密消息，直接搜索正确的密码。如果密码较弱，密钥就会被破解。

**将密钥存储在硬件令牌（智能卡或 USB 加密狗）中**

在这种方法中，我们将密钥存储在安全内存中，即使计算机被攻击，密钥也保持安全。这是最安全的密钥存储方法，但也是最昂贵且最不方便的方法，因为它要求你随身携带硬件令牌，并且有丢失的风险。智能卡和 USB 加密狗通常需要你输入密码来解锁存储在安全内存中的密钥。

> 注意

*无论使用何种方法，交换密钥时请务必确保不要将私钥与公钥混淆，也不要通过电子邮件或源代码不小心发布私钥。（我实际上曾在 GitHub 上找到私钥。）*

要测试密钥包装，请运行以下 OpenSSL 命令，并使用参数-aes128告知 OpenSSL 使用 AES-128（128 位密钥的 AES 加密算法）加密密钥：

```
$ **openssl genrsa -aes128 4096**
Generating RSA private key, 4096 bit long modulus (2 primes)
..........++
.............................................................................
................................................++
e is 65537 (0x10001)
Enter pass phrase:
```

OpenSSL 将使用请求的密码短语来加密新创建的密钥。

### 问题所在

加密安全可能以多种方式出错。最大风险是由于安全证明或研究透彻的协议而产生的虚假安全感，以下示例对此进行了说明。

#### 错误的安全证明

即使是著名研究人员的安全性证明也可能是错误的。最引人注目的错误证明之一就是*最优非对称加密填充（OAEP）*，这是一种使用 RSA 进行安全加密的方法，已在许多应用中实现。关于 OAEP 在对抗选择密文攻击者时的安全性，曾有一个错误的证明被接受为有效长达七年，直到 2001 年一位研究人员发现了其中的缺陷。不仅证明是错的，结果也是错的。后来的一项新证明显示，OAEP 对于选择密文攻击者来说几乎是安全的。现在我们只能相信新的证明，并希望它没有问题。（更多细节，请参阅 Victor Shoup 在 2001 年发表的论文《OAEP 重新考虑》）

#### 遗留支持的快捷键

2015 年，研究人员发现一些 HTTPS 网站和 SSH 服务器支持的公钥加密使用的密钥比预期的要短——即 512 位，而不是至少 2048 位。记住，对于公钥方案，安全级别不等于密钥大小，在 HTTPS 的情况下，512 位的密钥提供约 60 位的安全级别。这些密钥在大约两周的计算时间内就能被破解，计算过程中使用了 72 个处理器的集群。许多网站都受到影响，包括美国联邦调查局（FBI）的网站。尽管最终通过为 OpenSSL 和其他软件提供修补程序修复了这一问题，但这一问题仍然是一个令人不愉快的惊喜。

### 进一步阅读

要了解更多关于对称加密算法的可证明安全性，请阅读海绵函数文档 (*[`<wbr>keccak<wbr>.team<wbr>/sponge<wbr>_duplex<wbr>.html`](https://keccak.team/sponge_duplex.html)*)。海绵函数在对称加密中引入了基于置换的方法，描述了如何仅使用一种置换来构造多种不同的加密函数。

关于攻击的真实成本，有一些必读材料，包括 Daniel J. Bernstein 在 2005 年发表的论文《理解暴力破解》和 Michael Wiener 在 2004 年发表的论文《密码分析攻击的完整成本》，两篇论文都可以在线免费获取。

要确定给定密钥大小的安全级别，请访问 *[`<wbr>www<wbr>.keylength<wbr>.com`](https://www.keylength.com)*。该网站展示了多个政府机构关于密钥大小的建议，以及根据公钥大小保证的安全级别的数量级。

最后，作为练习，选择一个应用程序（如安全消息传递应用程序），并识别其加密方案、密钥长度和相应的安全级别。你会常常发现一些令人惊讶的不一致性，例如一个方案提供 256 位的安全级别，而第二个方案仅提供 100 位安全级别。整个系统的安全性往往只有最弱组件的安全性那么强。
