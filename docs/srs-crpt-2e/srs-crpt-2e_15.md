

## 第十二章：11 迪菲–赫尔曼



![](img/opener.jpg)

1976 年 11 月，斯坦福大学的研究人员**惠特菲尔德·迪菲**和**马丁·赫尔曼**发表了一篇名为《密码学的新方向》的研究论文，彻底改变了密码学的面貌。他们的论文提出了公钥加密和签名的概念，尽管他们实际上并没有这些方案；他们仅提出了一个他们称之为*公钥密码系统*的协议，这种协议允许双方通过交换对窃听者可见的信息来建立共享的秘密。这就是现在所称的*迪菲–赫尔曼（DH）协议*。在迪菲–赫尔曼之前，建立共享秘密需要繁琐的程序，例如手动交换密封的信封。

一旦通信双方通过 DH 协议建立了共享的秘密值，他们就可以利用该秘密值建立一个*安全通道*，通过将秘密转化为一个或多个对称密钥，然后用这些密钥加密和验证随后的通信。因此，DH 协议及其变种被称为*密钥协商*协议。

在本章的第一部分，你将了解迪菲–赫尔曼协议的数学基础，包括 DH 依赖的计算问题，这些问题使得它的魔力得以实现。接下来，你将学习可以用来创建安全通道的不同版本的迪菲–赫尔曼协议。最后，由于迪菲–赫尔曼方案只有在其参数选择得当时才是安全的，你将看到一些迪菲–赫尔曼可能失败的场景。

> 注意

**迪菲**和**赫尔曼**因发明了公钥密码学和数字签名，于 2015 年荣获了声望极高的图灵奖，但其他人也应当获得认可。1974 年，当时还是计算机科学本科生的**拉尔夫·梅尔克**提出了公钥密码学的概念，并引入了**梅尔克谜题**。大约在同一时期，英国政府通信总部（GCHQ），即英国版的美国国家安全局（NSA）的研究人员发现了**里维斯特–沙米尔–阿德尔曼（RSA）**和**迪菲–赫尔曼**密钥协商的原理，尽管这一事实直到几十年后才被解密。

### 迪菲–赫尔曼函数

要理解 DH 密钥协商协议，你必须理解其核心操作，即*DH 函数*。迪菲和赫尔曼最初定义了 DH 函数，要求其与**Z**p^*群一起工作，该群由模素数 p 的非零整数构成（通常用*p*表示，见第九章）。另一个公共参数是基数或*生成元*，即*g*。

DH 函数涉及两个私有值，由两方从群体 **Z**p^* 中随机选择，我们将其写作 *a* 和 *b*。私有值 *a* 与公有值 *A* = *g**^a* mod *p* 相关，或者说 *g* 的 *a* 次方对 *p* 取模。这个 *A* 会通过一个对窃听者可见的消息发送给另一方。与 *b* 相关的公有值是 *B* = *g**^b* mod *p*，它会发送给 *a* 的拥有者。因此，攻击者可以得知 *A* 和 *B*。

DH 的工作原理是将一个公有值与另一个私有值结合，使得两者的结果相同：*A**^b* = (*g**^a*)*^b* = *g**^(ab)* 和 *B* *^a* = (*g**^b*)*^a* = *g**^(ba)* = *g**^(ab)*。得到的值 *g**^(ab)* 是 *共享密钥*；然后，你将其传递给 *密钥派生函数 (KDF)* 以生成一个或多个共享的对称密钥。KDF 是一种哈希函数，它返回一个看起来随机的字符串，其长度等于所需的密钥长度。

就这样。像许多伟大的科学发现（重力、相对论、量子计算或 RSA）一样，Diffie–Hellman 方法事后看相对简单。

然而，Diffie–Hellman 的简单性可能会令人误解。首先，它并不是任何素数 *p* 或基数 *g* 都能奏效。一些 *g* 的值会将共享密钥 *g**^(ab)* 限制在一个较小的子集范围内，而你可能期望共享密钥的值范围与 **Z**p^* 中的元素数量相当，因此应该有尽可能多的共享密钥值。为了确保最高的安全性，安全的 DH 参数应与一个素数 *p* 一起工作，使得 (*p* – 1)/2 也是素数。这样的 *安全素数* 可以确保群体中没有小的子群，这些子群可能使 DH 更容易被破解。使用安全素数时，DH 可以与 **Z**p^* 中的任何元素一起工作，除了 1 和 *p* – 1；特别地，*g* = 2 会使计算稍微加快。不过，生成一个安全素数 *p* 比生成一个完全随机的素数需要更多时间。

例如，OpenSSL 工具包中的 dhparam 命令仅生成安全的 DH 参数，但算法内置的额外检查会显著增加执行时间，如示例 11-1 所示。

```
$ **time openssl dhparam 2048**
Generating DH parameters, 2048 bit long safe prime, generator 2
This is going to take a long time
`--snip--`
-----BEGIN DH PARAMETERS-----
MIIBCAKCAQEAoSIbyA9e844q7V89rcoEV8vd/l2svwhIIjG9EPwWWr7FkfYhYkU9
fRNttmilGCTfxc9EDf+4dzw+AbRBc6oOL9gxUoPnOd1/G/YDYgyplF5M3xeswqea
SD+B7628pWTaCZGKZham7vmiN8azGeaYAucckTkjVWceHVIVXe5fvU74k7+C2wKk
iiyMFm8th2zm9W/shiKNV2+SsHtD6r3ZC2/hfu7XdOI4iT6ise83YicU/cRaDmK6
zgBKn3SlCjwL4M3+m1J+Vh0UFz/nWTJ1IWAVC+aoLK8upqRgApOgHkVqzP/CgwBw
XAOE8ncQqroJ0mUSB5eLqfpAvyBWpkrwQwIBAg==
-----END DH PARAMETERS-----
openssl dhparam 2048  7.46s user 0.10s system 99% cpu 7.593 total
```

示例 11-1：测量生成 2,048 位 Diffie–Hellman 参数的执行时间（使用 OpenSSL 工具包）

使用 OpenSSL 工具包生成 DH 参数大约需要 8 秒（常见的生成时间为 30 秒，甚至超过 1 分钟）。

为了进行比较，示例 11-2 显示了在相同系统上生成相同大小的 RSA 参数（即两个素数，*p* 和 *q*，每个素数的大小是 DH 所用 *p* 的一半）所需的时间。

```
$ **time openssl genrsa 2048**
Generating RSA private key, 2048 bit long modulus
...................................................+++
.............................................................+++
e is 65537 (0x10001)
-----BEGIN RSA PRIVATE KEY-----
`--snip--`
-----END RSA PRIVATE KEY-----
openssl genrsa 2048  0.16s user 0.01s system 95% cpu 0.171 total
```

示例 11-2：生成 2,048 位 RSA 参数并测量执行时间

生成 DH 参数的时间大约是生成相同安全级别的 RSA 参数的 50 倍，主要是由于在生成 DH 参数时对素数施加了额外的约束。### Diffie–Hellman 问题

DH 协议的安全性依赖于计算问题的难度，尤其是离散对数问题（DLP）的难度，详见第九章。你可以通过从公有值 *g**^a* 中恢复私有值 *a* 来破解 DH，这实际上是解决一个 DLP 实例。但当我们使用 DH 来计算共享秘密时，我们不仅关心离散对数问题。我们还关心两个 DH 特有的问题。

#### 计算问题

*计算 Diffie–Hellman (CDH)* 问题是给定公有值 *g* *^a* 和 *g* *^b*，在不知道私有值 *a* 和 *b* 的情况下，计算共享秘密 *g* *^(ab)*。其动机是确保即使窃听者捕获了 *g* *^a* 和 *g* *^b*，他们也无法确定共享秘密 *g* *^(ab)*。

如果你能够解决 DLP，那么你也可以解决 CDH；也就是说，如果给定 *g* *^a* 和 *g* *^b* 能确定 *a* 和 *b*，那么你就能计算出 *g* *^(ab)*。换句话说，DLP 至少和 CDH 一样难。但你不能确定 CDH 是否至少和 DLP 一样难，这会使得这两个问题同样困难。换句话说，DLP 对 CDH 就像因式分解问题对 RSA 问题一样。（回想一下，因式分解可以解决 RSA 问题，但不一定能反过来解决。）

Diffie–Hellman 与 RSA 还有另一个相似之处，即 DH 在给定模数大小时提供与 RSA 相似的安全级别。例如，具有 2,048 位素数 *p* 的 DH 协议提供大约与 2,048 位模数的 RSA 相当的 90 位安全性。实际上，破解 CDH 的最快方法是使用 *数域筛法* 算法来解决离散对数问题（DLP），这种方法与通用数域筛法（GNFS）相似，但不完全相同，GNFS 是通过对 RSA 的模数进行因式分解来破解 RSA 的方法。

#### 可判定问题

当你需要比 CDH 的难度更强的假设时，就需要引入 *可判定 Diffie–Hellman (DDH)* 问题。给定 *g* *^a*、*g* *^b*，以及一个值，它要么是 *g* *^(ab)*，要么是 *g* *^c*（其中 *c* 是某个随机数，每个值的概率为 1/2），DDH 问题的目标是判断 *g* *^(ab)*（对应于 *g* *^a* 和 *g* *^b* 的共享秘密）是否被选择。

在以下情况下，依赖 DDH 而非 CDH 是有意义的：假设攻击者仅能计算给定 *g* *^a* 和 *g* *^b* 的 2,048 位值中的前 32 位 *g* *^(ab)*。虽然 CDH 仍然没有被攻破，因为 32 位可能不足以完全恢复 *g* *^(ab)*，但攻击者已经从中学到了一些关于共享密钥的信息，这可能允许他们破坏应用程序的安全性。

为了确保攻击者无法得知共享密钥 *g* *^(ab)* 的任何信息，该值需要与一个随机群元素 *不可区分*，就像加密方案在密文与随机字符串不可区分时是安全的。这就是说，攻击者不应该能够确定给定的数字是 *g* *^(ab)* 还是 *g**^c*（其中 *c* 是某个随机值），给定 *g**^a* 和 *g**^b*。*判定性 Diffie–Hellman 假设* 假设没有攻击者可以有效地解决 DDH 问题。

如果 DDH 很困难，那么 CDH 也是如此，你无法得知 *g* *^(ab)* 的任何信息。所以，如果你能解决 CDH，那么你也能解决 DDH：给定一个三元组 (*g* *^a*, *g* *^b*, *x*)，你将能够从 *g**^a* 和 *g* *^b* 中推导出 *g* *^(ab)* 并检查结果是否等于给定的 *x*。

结论是，DDH 从根本上比 CDH 更简单（值得注意的是，DDH 在 **Z**p^* 上并不困难，与 CDH 相反），然而，DDH 难度是密码学中的一个重要假设，并且是最研究的假设之一。

#### Diffie–Hellman 的变体

有时，密码学家设计新的方案，并证明它们至少像解决某些困难问题一样困难。但这些困难问题并不总是 CDH 或 DDH，可能是它们的变体。我们希望能够证明，破解一个密码系统的难度和解决 CDH 或 DDH 的难度一样大，但对于一些先进的密码学机制，这并不总是可能的，通常是因为这些方案涉及比基本的 Diffie–Hellman 协议更复杂的操作。

例如，在一个类似 DH 的问题中，给定 *g**^a*，攻击者试图计算 *g*^(1/)*^a*，其中 1/*a* 是群中 *a* 的逆元（通常是 **Z**p^*，其中 *p* 是某个质数）。在另一个问题中，攻击者可能通过随机的 *a* 和 *b* 区分对 (*g**^a*, *g**^b*) 和对 (*g**^a*, *g*^(1/)*^a*)。最后，在 *双重 Diffie–Hellman 问题* 中，给定 *g**^a*、*g**^b* 和 *g**^c*，攻击者试图计算两个值 *g**^(ab)* 和 *g**^(ac)*。有时这些 DH 变体的难度与 CDH 或 DDH 一样困难，有时它们则更容易——因此提供的安全保证较低。作为练习，试着找出这些问题的难度与 CDH 和 DDH 难度之间的联系。（双重 Diffie–Hellman 实际上与 CDH *同样困难*，但这并不容易证明！）

### 密钥协议

Diffie–Hellman 问题旨在构建安全的密钥协商协议，确保两个或多个在网络上通信的各方通过共享秘密来加密通信。这些各方将这个秘密转化为一个或多个 *会话密钥*—对称密钥，在会话期间加密和认证交换的信息。

在研究实际的 DH 协议之前，你应该了解一个密钥协商协议安全的因素，以及更简单的协议是如何工作的。我们将从一个常见的密钥协商协议开始，这个协议不依赖于 DH。

#### 非 DH 密钥协商

为了让大家了解一个密钥协商协议是如何工作的，以及它如何确保安全，我们来看看 4G 和 5G 电信标准中用于在 SIM 卡和电信运营商之间建立通信的协议：*认证密钥协商 (AKA)*。它不使用 Diffie–Hellman 函数，而是仅使用对称密钥操作。图 11-1 详细描述了该协议是如何工作的。

![](img/fig11-1.jpg)

图 11-1：4G 和 5G 电信中的 AKA 协议

在此协议描述中，SIM 卡有一个秘密密钥 *K*，该密钥由运营商知晓。运营商通过选择一个随机值 *R* 开始会话，然后基于两个伪随机函数 **PRF**0 和 **PRF**1 计算出两个值 *SK* 和 *V*[1]。接下来，运营商向 SIM 卡发送包含 *R* 和 *V*[1] 的消息，这些值对攻击者是可见的。一旦 SIM 卡获取到 *R*，它便可以使用 **PRF**0 来计算 *SK*，并且确实计算出了这个值。会话中的两方最终得到一个共享密钥 *SK*，攻击者无法仅通过查看双方交换的消息，甚至通过修改它们或注入新的消息来确定该密钥。SIM 卡通过重新计算 *V*[1]，使用 **PRF**1、*K* 和 *R*，并检查计算出的 *V*[1] 是否与运营商发送的 *V*[1] 匹配，从而验证它正在与运营商通信。然后，SIM 卡使用新的函数 **PRF**2 和 *K*、*R* 作为输入计算一个验证值 *V*[2]，并将 *V*[2] 发送给运营商。运营商通过计算 *V*[2] 并检查计算出的值是否与接收到的 *V*[2] 匹配来验证 SIM 卡是否知道 *K*。

在我描述的协议中，有一种方法可以通过重放攻击欺骗 SIM 卡。本质上，如果攻击者捕获了一对 (*R*, *V*[1])，他们可以将其发送到 SIM 卡，并欺骗 SIM 卡相信该对数据来自一个合法的运营商，该运营商知道 *K*。为了防止这种攻击，协议包含了额外的检查，以确保同一 *R* 不会被重用。

如果*K*被泄露，就会出现问题。例如，一个泄露了*K*的攻击者可以进行中间人攻击，监听所有明文通信。这样的攻击者可能在两个方之间发送消息，同时冒充合法的 SIM 卡运营商和 SIM 卡。即使*K*在某次通信时并没有被泄露，攻击者也可以记录通信和密钥协议期间交换的任何消息，并在找到*K*时使用捕获的*R*值解密这些通信。攻击者可以通过此方式确定过去的会话密钥，并用它们解密已录制的流量——在这种情况下，协议没有提供*前向保密性*。

#### 密钥协议的攻击模型

密钥协议没有单一的安全定义，且没有考虑攻击模型和安全目标的上下文情况下，任何密钥协议都不可能完全安全。例如，你可以认为之前的 4G/5G 协议是安全的，因为被动攻击者无法找到会话密钥，但它也不安全，因为一旦密钥*K*泄露，这会危及所有之前和之后的通信。

密钥协议中有不同的安全概念，以及三个主要的攻击模型，这些模型取决于协议泄露的信息。从最弱到最强，这些模型是*网络攻击者*、*数据泄漏*和*突破*：

**网络攻击者** 该攻击者观察两个合法方之间交换的消息，并且可以记录、修改、丢弃或注入消息。为了防范此类攻击者，密钥协议必须确保不会泄漏任何关于已建立共享秘密的信息。

**数据泄漏** 在这个模型中，攻击者通过一次或多次协议执行获得会话密钥和所有*临时*秘密（例如电信协议示例中的*SK*），但不会获得长期秘密（如该协议中的*K*）。

**突破（或篡改）** 在这个模型中，攻击者获知一个或多个方的长期密钥。一旦发生突破，安全性就无法再保证，因为攻击者可以在后续的协议会话中冒充其中一个或两个方，因为这是唯一可以标识一个方的信息（至少在理论上如此，因为在实践中像 IP 白名单这样的机制可以降低冒充的风险）。尽管如此，攻击者不应该能够从发生在获取密钥之前的会话中恢复秘密。

现在我们已经了解了攻击模型并看到了攻击者可能采取的行动，让我们来探讨一下安全目标——即协议应该提供的安全保障。你可以设计一个密钥协议来满足多个安全目标。这里描述了四个最相关的目标，按从简单到复杂的顺序排列：

**认证** 协议应该允许*互相认证*，即每一方都能认证另一方。AKA 是指协议认证双方。

**密钥控制** 任何一方都不应能够选择最终的共享密钥或强迫其属于特定子集。前面讨论过的 4G/5G 密钥协商协议缺乏这一特性，因为运营商选择了完全决定最终共享密钥的*R*值。

**前向保密性** 即使所有长期密钥都被泄露，攻击者也应该无法从协议的先前执行中计算出共享密钥，即使他们记录了所有先前的执行或能够注入或修改先前执行中的消息。*前向保密*，或称为*前向安全*协议，保证即使你必须将设备及其密钥交给某个机构，他们也无法解密你之前加密的通讯。（4G/5G 密钥协商协议不提供前向保密性。）

**抵抗密钥泄露冒充（KCI）** KCI 发生在攻击者泄露某一方的长期密钥，并利用该密钥冒充另一方。例如，4G/5G 密钥协商协议允许轻易的密钥泄露冒充，因为双方共享相同的密钥*K*。理想的密钥协商协议应该防止这种攻击。

#### 性能

为了有用，密钥协商协议应该既高效又安全。在考虑一个密钥协商协议的效率时，你应该考虑多个因素，包括交换的消息数量、消息的长度、实现协议的计算工作量以及是否可以进行预计算以节省时间。协议通常在交换较少、较短的消息时更高效，如果能够最小化交互性，使得双方无需等待收到消息再发送下一个消息，那是最理想的。你通常可以通过协议的持续时间来衡量其效率，以*往返时间*为标准，即发送消息并接收响应所需的时间。

往返时间通常是协议延迟的主要原因，但双方需要执行的计算量也很重要；所需计算越少，能进行的预计算越多，效果越好。例如，4G/5G 密钥协商协议交换两条每条几百比特的消息，且必须按照特定顺序发送。你可以使用预计算来节省时间，因为运营商可以提前选择多个*R*值；预计算与*SK*、*V*[1]、*V*[2]的匹配值，并将它们都存储在数据库中。在这种情况下，预计算的优点是减少了长期密钥的暴露。

### Diffie–Hellman 协议

Diffie–Hellman 函数是大多数已部署的公钥协商协议的核心——例如 TLS 和 SSH。但并没有单一的 Diffie–Hellman 协议，而是有多种方法可以使用 DH 函数来建立共享密钥。我们将在接下来的章节中回顾三种协议。在每个讨论中，我将坚持使用常见的加密占位符名称，称两方为 Alice 和 Bob，攻击者为 Eve。我将写 *g* 作为用于算术运算的群生成元，这是一个在 Alice、Bob 和 Eve 之间预先固定并已知的值。

#### 匿名 Diffie–Hellman

*匿名 Diffie–Hellman* 是最简单的 Diffie–Hellman 协议。它之所以匿名，是因为没有认证机制；参与者没有任何加密身份，双方都无法验证对方的身份，也没有持有长期密钥。Alice 无法证明自己是 Alice，Bob 也是如此。

在匿名 Diffie–Hellman 中，每一方选择一个随机值（*a* 代表 Alice，*b* 代表 Bob）作为私钥，并将对应的公钥发送给对方。图 11-2 详细展示了这一过程。

![](img/fig11-2.jpg)

图 11-2：匿名 Diffie–Hellman 协议

Alice 使用她的指数 *a* 和群基 *g* 计算 *A* = *g**^a*，并将其发送给 Bob。Bob 收到 *A* 后计算 *A**^b*，这等同于 (*g**^a*)*^b*。Bob 现在获得值 *g**^(ab)*，并根据他的随机指数 *b* 和值 *g* 计算 *B*。然后他将 *B* 发送给 Alice，Alice 使用该值计算 *g**^(ab)*。Alice 和 Bob 在进行相似的操作后，最终得到相同的值 *g**^(ab)*，这些操作涉及将 *g* 和接收到的值分别提升到各自私有指数的幂。一个简单的协议，只能抵抗最懒的攻击者。

攻击者可以通过中间人攻击摧毁匿名 Diffie–Hellman 协议。网络攻击者只需要拦截消息，并假装是 Bob（对 Alice），又假装是 Alice（对 Bob），如图 11-3 所示。

![](img/fig11-3.jpg)

图 11-3：中间人攻击匿名 Diffie–Hellman 协议

如同之前的交换过程，Alice 和 Bob 各自选择随机指数，*a* 和 *b*。Alice 现在计算并发送 *A*，但 Eve 拦截并丢弃了该消息。然后，Eve 选择一个随机指数 *c*，计算 *C* = *g**^c* 并发送给 Bob。由于该协议没有认证机制，Bob 以为他收到了来自 Alice 的 *C*，并继续计算 *g**^(bc)*。接着，Bob 计算 *B* 并将该值发送给 Alice，但 Eve 再次拦截并丢弃了消息。Eve 现在计算 *g**^(bc)*，选择一个新的指数 *d*，计算 *g**^(ad)*，从 *g**^d* 计算出 *D*，并将 *D* 发送给 Alice。然后，Alice 也计算 *g**^(ad)*。

由于这种攻击，攻击者 Eve 与 Alice 共享一个秘密 (*g**^(ad)*)，并与 Bob 共享另一个秘密 (*g**^(bc)*)，而 Alice 和 Bob 认为他们共享的是一个彼此之间的秘密。在协议执行完成后，Alice 从 *g**^(ad)* 推导出对称密钥来加密发送给 Bob 的数据，但 Eve 拦截了加密消息，解密后使用另一个由 *g**^(bc)* 推导出的密钥重新加密并发送给 Bob——可能还会修改明文。所有这些操作都是在 Alice 和 Bob 不知情的情况下进行的；他们注定会失败。

为了防止这种攻击，你需要一种认证双方身份的方法，这样 Alice 就可以证明她是真正的 Alice，Bob 也能证明他是真正的 Bob。幸运的是，确实有办法做到这一点。

#### 认证的 Diffie–Hellman

*认证的 Diffie–Hellman* 解决了可能影响匿名 DH 的中间人攻击问题。认证的 DH 为双方提供了私钥和公钥，从而使得 Alice 和 Bob 可以对他们的消息进行签名，以防止 Eve 代表他们发送消息。在这里，签名不是通过 DH 函数计算的，而是通过公钥签名方案（如 RSA-PSS）计算的。因此，要成功地代表 Alice 发送消息，攻击者需要伪造一个有效的签名，而在安全的签名方案下，这是不可能的。图 11-4 展示了认证 DH 的工作原理。

![](img/fig11-4.jpg)

图 11-4：认证的 Diffie–Hellman 协议

第一行中的标签 **Alice** (*priv*A, *pub*B) 表示 Alice 持有她自己的私钥 *priv*A，以及 Bob 的公钥 *pub*B。这个 *priv*/*pub* 密钥对被称为 *长期密钥*，因为它是预先固定的，并且在协议的连续执行中保持不变。Alice 可以使用她的密钥对 *priv*A/*pub*A 与除 Bob 以外的其他方进行通信，只要他们知道 *pub*A（*他们怎么知道这个*是另一个问题，也是密码学中最难解决的操作问题之一）。这些长期私钥应该保密，而公钥则被认为是攻击者已知的。

Alice 和 Bob 首先选择随机指数 *a* 和 *b*，就像在匿名 DH 中一样。然后，Alice 基于她的签名函数 **sign**、她的私钥 *priv*A 和 *A* 计算 *A* 和一个签名 *sig*A。现在，Alice 将 *A* 和 *sig*A 发送给 Bob，后者使用 Alice 的公钥 *pub*A 来验证 *sig*A。如果签名无效，Bob 知道该消息不是来自 Alice，并会丢弃 *A*。

如果签名是正确的，Bob 会根据 *A* 和他自己的随机指数 *b* 计算 *g**^(ab)*。然后，他通过 **sign** 函数、自己的私钥 *priv*B 和 *B* 的组合计算 *B* 和他的签名 *sig*B。接着，他将 *B* 和 *sig*B 发送给 Alice，后者尝试用 Bob 的公钥 *pub*B 来验证 *sig*B。如果 Bob 的签名成功验证，Alice 才会计算 *g**^(ab)*。

##### 防止网络攻击者的安全性

认证 DH 对网络攻击者是安全的，因为他们无法从共享秘密 *g**^(ab)* 中获取任何信息，因为他们忽略了 DH 指数。认证 DH 还提供前向保密性：即使攻击者在某个时刻破坏了任何一方，正如之前讨论的 *泄漏* 攻击模型那样，他们将获得私有签名密钥，但无法获得任何临时 DH 指数；因此，他们无法得知任何先前共享秘密的值。

DH 的认证变体只提供了对 *密钥控制* 的部分保护。Alice 不能构造特殊的 *a* 值来限制共享秘密 *g**^(ab)* 的选择，因为她还不知道 *g**^b*，而 *g**^b* 对结果的影响与 *a* 一样大。（一个例外是如果 Alice 选择 *a* = 0，在这种情况下无论 *b* 取什么值，*g**^(ab)* 都会等于 1。协议因此应该拒绝 0，尽管实际实现可能不会这么做。）然而，Bob 可以尝试多个 *b* 值，直到找到一个“适合他的”值；例如，对于某些值，使得 *g**^(ab)* 具有某些属性，如其前 16 位为 1。

你可以通过在 Alice 发送她的 *g**^a* 之前，先从 Bob 发送 **Hash**(*g**^b*) 到 Alice 作为第一个消息，来消除 Bob 对秘密值的控制。我将留给你分析这个修改并理解为什么它有效（新发送的消息是 Bob 公钥的*承诺*）。

认证 DH 还有其他局限性。例如，Eve 可以通过记录之前的 *A* 和 *sig*A 值并将其重放给 Bob 来伪装成 Alice。Bob 错误地认为他正在与 Alice 共享秘密，尽管 Eve 无法得知该秘密，因为她不知道 Alice 的秘密 *a*。因此，她无法从 Bob 发送的 *B* 计算出 *B**^a*。

你可以通过添加 *密钥确认* 程序来消除这个风险，其中 Alice 和 Bob 互相证明他们拥有共享秘密。例如，Alice 和 Bob 可以通过分别发送 **Hash**(*pub*A || *pub*B || *g**^(ab)*) 和 **Hash**(*pub*B || *pub*A || *g**^(ab)*) 来执行密钥确认，其中 **Hash** 是某个哈希函数。双方可以通过重新计算结果来验证这些哈希值的正确性。公钥 *pub*A || *pub*B 和 *pub*B || *pub*A 的不同顺序确保了 Alice 和 Bob 发送不同的值，且攻击者不能通过复制 Bob 的哈希值来伪装成 Alice。

##### 防止数据泄露的安全性

经过身份验证的 DH 在面对数据泄露攻击者时的脆弱性更为令人关注。在此类攻击中，攻击者获取了临时、短期秘密（即指数 *a* 和 *b*）的值，并利用这些信息冒充其中一方通信者。如果 Eve 获取了指数 *a* 的值以及发送给 Bob 的 *sig*A 的值，她就可以发起协议的新执行并冒充 Alice，正如图 11-5 所示。

![](img/fig11-5.jpg)

图 11-5：对经过身份验证的 Diffie–Hellman 协议的冒充攻击

在这种攻击场景中，Eve 获取了 *a* 的值，并重放了相应的 *A* 及其签名 *sig*A，假装自己是 Alice。Bob 验证签名并根据 *A* 计算 *g**^(ab)*，然后发送 *B* 和 *sig*B，Eve 接着利用窃取的 *a* 来计算 *g**^(ab)*，从而两者达成了共享秘密。此时，Bob 认为他在与 Alice 进行通信。

你可以通过将长期密钥整合到共享秘密计算中，来保护经过身份验证的 DH 免受临时秘密泄露的风险，这样就无法在不知道长期秘密的情况下确定共享秘密。

#### Menezes–Qu–Vanstone

*Menezes–Qu–Vanstone (MQV)* 协议是 DH 基础协议历史上的一个里程碑。MQV 于 1998 年设计，获得批准用于保护大多数关键资产，当时 NSA 将其纳入其 Suite B，后者是为了保护机密信息而设计的一组算法。（NSA 最终放弃了 MQV，原因据说是其未被广泛使用。稍后我会讨论原因。）

MQV 是经过加强的 Diffie–Hellman。它比经过身份验证的 DH 更安全，并且改善了经过身份验证的 DH 的性能特性。特别是，MQV 允许用户发送仅有的两条消息，彼此独立，顺序任意。用户还可以发送比经过身份验证的 DH 更短的消息，而且不需要发送显式的签名或验证消息。换句话说，你不需要在 Diffie–Hellman 函数之外使用签名方案。

与经过身份验证的 DH 相同，在 MQV 中，Alice 和 Bob 各自持有一个长期私钥以及对方的长期公钥。不同之处在于，MQV 密钥不是签名密钥：它们由一个私有指数 *x* 和一个公有值 *g**^x* 组成。图 11-6 展示了 MQV 协议的操作。

![](img/fig11-6.jpg)

图 11-6：MQV 协议

*x*和*y*分别是 Alice 和 Bob 的长期私钥，*X*和*Y*是他们的公钥。Bob 和 Alice 从各自的私钥和对方的公钥开始，公钥是*g*的私钥幂。每人选择一个随机的指数，然后 Alice 计算*A*并将其发送给 Bob，接着 Bob 计算*B*并将其发送给 Alice。一旦 Alice 得到 Bob 的短期公钥*B*，她将其与自己的长期私钥*x*、短期私钥*a*以及 Bob 的长期公钥*Y*结合，计算出结果（*B* × *Y**^B*）*^a* ^+ *^(xA)*，如图 11-6 所示。展开这个表达式，你可以得到以下结果：

![](img/pg228-1.jpg)

与此同时，Bob 计算（*A* × *X**^A*）*^b* ^+ *^(yB)*的结果，你可以验证它等于 Alice 计算出的值：

![](img/pg228-2.jpg)

Alice 和 Bob 都得到相同的值，*g*^(*^b* ^+ *^(yB)*^()()*^a* ^+ *^(xA)*^)，这表明 Alice 和 Bob 共享相同的密钥。

与认证 DH 不同，通过单纯泄露短期密钥并不能破解 MQV。知道*a*或*b*并不能让攻击者确定最终的共享密钥，因为他们需要长期私钥才能计算出来。

在最强的攻击模型——破坏模型中，如果长期密钥被破坏，会发生什么？如果 Eve 破坏了 Alice 的长期私钥*x*，那么先前建立的共享密钥仍然是安全的，因为它们的计算过程也涉及了 Alice 的短期私钥。

然而，MQV 并不能提供*完美*的前向保密性，原因是存在以下攻击。例如，假设 Eve 拦截了 Alice 的*A*消息，并将其替换为她自己选择的*a*值，使得*A* = *g**^a*。与此同时，Bob 向 Alice 发送*B*（Eve 记录了*B*的值），并计算共享密钥。如果 Eve 后来获取了 Alice 的长期私钥*x*，她就能确定 Bob 在此会话中计算出的密钥。这破坏了前向保密性，因为 Eve 已经恢复了先前执行协议时的共享密钥。然而，在实践中，你可以通过一个密钥确认步骤来消除这一风险，Alice 和 Bob 可以意识到他们没有共享相同的密钥，并且在派生任何会话密钥之前终止协议。

尽管 MQV 具有优雅性和安全性，但在实践中却很少使用，原因有几个。它曾经受到专利的限制，阻碍了其广泛采用。与此同时，正确实现 MQV 比看起来要困难得多。事实上，考虑到它增加的复杂性，MQV 的安全性优势通常被认为相较于简单的认证 DH 较低。

### 事情如何出错

Diffie–Hellman 协议可能以各种方式失败，下面的章节将突出显示一些实践中常见的情况。

#### 没有对共享密钥进行哈希处理

我曾提到过，结束 DH 会话交换的共享密钥（我们示例中的 *g**^(ab)*）被作为输入用于派生会话密钥，但它本身并不是密钥。而它不应该是密钥。对称密钥应该看起来是随机的，每一位应该有相同的概率是 0 或 1。但是 *g**^(ab)* 并不是一个随机字符串；它是某个数学群中的随机元素，其位可能会偏向 0 或 1。一个随机的群元素与一个随机的位字符串是不同的。

比如说，假设你在使用乘法群**Z**[13]^* = {1, 2, 3, . . . , 12}，并且使用 *g* = 2 作为该群的生成元，这意味着 *g**^i*遍历所有**Z**[13]^*中的值，i 取 1, 2, . . . 12：*g*¹ = 2，*g*² = 4，*g*³ = 8，*g*⁴ = 3，依此类推。如果 *g*的指数是随机的，你将得到**Z**[13]^*中的一个随机元素，但将**Z**[13]^*元素编码为 4 位字符串时，不会是均匀随机的：并非所有位都有相同的概率是 0 或 1。在**Z**[13]^*中，七个值的最高有效位是 0（群中从 1 到 7 的数字），但只有五个值的最高有效位是 1（从 8 到 12）。也就是说，这个位是 0 的概率是 7/12 ≈ 0.58，而随机位理想情况下应该是 0 的概率为 0.5。此外，4 位序列 1101、1110 和 1111 永远不会出现。

为了避免从 DH 共享密钥派生的会话密钥存在这种偏差，可以使用加密哈希函数，如 BLAKE3 或 SHA-3，或者更好的是，使用密钥派生函数（KDF）。KDF 构造的一个例子是 HKDF，或基于 HMAC 的 KDF（如 RFC 5869 中所规定），但如今 BLAKE2 和 SHA-3 都有专门的模式来充当 KDF。

#### TLS 1.0 中的匿名 Diffie–Hellman

TLS 协议是 HTTPS 安全网站以及其他许多协议背后的安全机制，比如使用简单邮件传输协议（SMTP）的电子邮件传输。TLS 采用多个参数，包括它将使用的 Diffie–Hellman 协议的类型。出于向后兼容的原因，TLS 从 1.0 版本到 1.2 版本支持匿名 DH（即没有任何服务器认证），但在 1.3 版本中不再支持。由于 DH 仅对被动攻击者具有安全性，它可能会给人一种错误的安全感。

TLS 的原始文档描述了该协议的风险 (*[`<wbr>www<wbr>.rfc<wbr>-editor<wbr>.org<wbr>/rfc<wbr>/rfc2246`](https://www.rfc-editor.org/rfc/rfc2246)*):

> 完全匿名的连接仅能防止被动窃听。除非使用独立的防篡改通道来验证完成的消息未被攻击者替换，否则在存在主动中间人攻击风险的环境中，需要服务器认证。

#### 不安全的组参数

在 2016 年 1 月，OpenSSL 工具包的维护者修复了一个高严重性的漏洞（CVE-2016-0701），该漏洞允许攻击者利用不安全的 Diffie-Hellman 参数。漏洞的根本原因是 OpenSSL 允许用户使用不安全的 DH 组参数（即不安全的素数*p*），而不是在执行任何算术操作之前抛出错误并完全中止协议。

实质上，OpenSSL 接受了一个素数*p*，其乘法群**Z**p^*（所有 DH 操作发生的地方）包含小子群。正如你在本章开头所学到的，密码学协议中较大群体内的小子群的存在是非常不利的，因为它将共享的密钥限制在一个比使用整个群**Z**p^*更小的值集上。更糟糕的是，攻击者可以构造一个 DH 指数*x*，当它与受害者的公钥*g**^y*结合时，泄露私钥*y*的部分信息，最终揭示其完整内容。

尽管实际漏洞源自 2016 年，但该攻击所采用的原理可以追溯到 1997 年 Chae Hoon Lim 和 Pil Joong Lee 的论文《使用素数阶子群的离散对数方案的密钥恢复攻击》。修复此漏洞的方法很简单：当接受素数*p*作为群模数时，协议必须通过验证(*p* – 1) / 2 是否为素数来检查*p*是否为安全素数，从而确保群**Z**p^*没有小子群，攻击者无法利用此漏洞进行攻击。

### 进一步阅读

你可以通过阅读多个标准和官方出版物，深入了解 DH 密钥协商协议，包括 ANSI X9.42、RFC 2631 和 RFC 5114、IEEE 1363 和 NIST SP 800-56A。这些文献作为参考，确保互操作性并为群参数提供建议。

要了解更多关于高级 DH 协议（如 MQV 及其相关协议 HMQV 和 OAKE 等）及其安全性概念（包括未知密钥共享攻击和群表示攻击），请阅读 Hugo Krawczyk 的 2005 年文章《HMQV：一种高效的安全 Diffie-Hellman 协议》（*[`<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2005<wbr>/176`](https://eprint.iacr.org/2005/176)*)和 Andrew C. Yao 与 Yunlei Zhao 的 2011 年文章《一种新的隐式认证 Diffie-Hellman 协议家族》（*[`<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2011<wbr>/035`](https://eprint.iacr.org/2011/035)*）。这些文章以不同于本章的方式表达 Diffie-Hellman 操作。例如，它们将共享密钥表示为*xP*而不是*g**^x*。通常，你会发现乘法被加法取代，指数运算被乘法取代，因为这些协议通常不是定义在整数群上，而是定义在椭圆曲线上，正如你在第十二章中将学到的。
