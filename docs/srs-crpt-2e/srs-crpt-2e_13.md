

## 9 难题



![](img/opener.jpg)

困难的计算问题是现代密码学的基石。这些问题即使是最好的算法，也无法在太阳燃尽之前找到解决方案。

在 1970 年代，对困难问题的严格研究催生了一个新的科学领域——*计算复杂性理论*，它对密码学及许多其他领域（包括经济学、物理学和生物学）产生了深远影响。在本章中，你将学习理解密码学安全基础所必需的复杂性理论概念工具。我还将介绍公钥方案背后的难题，例如 RSA 加密和 Diffie-Hellman 密钥交换。我会涉及一些深奥的概念，但我会最小化技术细节，仅触及表面。尽管如此，我希望你能够看到密码学如何利用计算复杂性理论最大化安全保障的美妙之处。

### 计算困难性

计算问题是一个通过足够的计算可以回答的问题——例如，“217 是质数吗？”或“*incomprehensibilities*中有多少个*i*？”第一个问题是决策问题，因为它的答案只有“是”或“否”，而第二个问题则是搜索问题。

*计算困难性*是指那些没有可以在合理时间内运行的算法的计算问题。这类问题也被称为*难以处理的问题*。计算困难性与所使用的计算设备类型无关，无论是通用中央处理单元（CPU）、图形处理单元（GPU）、集成电路，还是机械图灵机。事实上，计算复杂性理论的初步发现之一是，所有计算模型都是等效的。如果某个计算设备能高效解决一个问题，任何其他设备通过将算法移植到其他设备的语言上也能高效解决该问题——量子计算机是个例外，我们将在第十四章讨论它。 因此，在讨论计算困难性时，我无需指定底层计算设备或硬件；我们只需要讨论算法。

为了评估计算困难性，首先需要一种方法来衡量算法的复杂性，或者说其运行时间。然后你将运行时间分类为困难或容易。

#### 运行时间

算法的*计算复杂度*是其执行的操作次数的近似值，作为输入大小的函数。你可以用比特数或作为输入的元素个数来衡量大小。例如，参考 Listing 9-1 中的算法，它是用伪代码编写的。该算法在一个包含*n*个元素的数组中查找值*x*，并返回其索引位置，如果没有找到*x*，则返回-1。

```
search(x, array, n) {
    for i from 0 to n - 1 {
        if (array[i] == x) {
            return i;
        }
    }
    return -1;
}
```

Listing 9-1: 一个复杂度与数组长度线性相关的简单搜索算法 n

该算法使用一个for循环在数组中查找特定值*x*，它对变量*i*的值进行迭代，从 0 开始。它检查数组中位置*i*的值是否等于*x*。如果是，则返回位置*i*。否则，它会增加*i*并尝试下一个位置，直到达到*n* – 1，即数组中的最后一个位置，此时它返回-1。

对于这种算法，你将复杂度定义为for循环的迭代次数：最好的情况为 1（如果*x*等于array[0]），最坏的情况为*n*（如果*x*等于array[n - 1]，或者如果*x*在array中找不到），平均情况下为*n*/2（如果*x*在*n*个数组元素中是均匀随机分布的）。对于一个大小是原数组 10 倍的数组，算法的速度会变慢 10 倍。因此，复杂度与*n*成正比，也就是*n*的“线性”复杂度。与输入大小成线性关系的复杂度被认为是快速的，不像指数级复杂度那样。虽然在这个例子中，处理更大输入值的速度变慢，但计算成本不会指数级地膨胀，而是与表格大小成正比。

然而，许多有用的算法比这更慢，且其复杂度高于线性。教科书中的例子是排序算法：给定一个随机顺序的*n*个值，最坏情况下你需要*n* × log *n* 次基本操作来排序该列表，这种复杂度有时被称为*线性对数复杂度*。由于*n* × log *n* 增长速度快于*n*，排序的速度减慢的比*n*增长得更快。然而，这种排序算法仍然属于*实用*计算的范畴，即在合理时间内可以完成的计算。

通常*不*合理的是输入大小呈指数增长的复杂度。到了一定程度，即使对于相对较小的输入长度，你也会遇到不可行的上限。以密码分析中最简单的例子为例：暴力破解密钥。回想一下第一章中提到的，给定一个明文 *P* 和密文 *C* = **E**(*K*, *P*)，恢复一个 *n* 位对称密钥最多需要 2*^n* 次尝试，因为有 2*^n* 个可能的密钥——这是一个复杂度呈指数增长的例子。一个具有*指数复杂度*的问题实际上是无法解决的，因为随着 *n* 增长，计算量会迅速变得无法承受。

你可能会反驳说我们这里在比较橙子和苹果：在清单 9-1 中的 search() 函数中，我们计算了 if (array[i] == x) 操作的次数，而密钥恢复计算的是加密操作的次数，每次加密的速度比单次 == 比较慢上千倍。这个看似的不一致，如果你比较两个复杂度非常相似的算法，可能会有所不同，但大多数情况下它并不重要，因为操作次数的影响比单个操作的成本更大。此外，复杂度估算忽略了*常数因子*：当我们说一个算法的时间复杂度是 *n*³（即*立方复杂度*）时，它可能实际上需要 41 × *n*³ 次操作，甚至是 12,345 × *n*³ 次操作——但随着 *n* 增长，常数因子的影响变得不重要，甚至可以忽略。复杂度分析关注的是输入大小对理论难度的影响；它不关心你计算机上需要多少个 CPU 周期。

你通常可以使用 *O*() 符号（*大 O*）来表示复杂度。例如，*O*(*n*³) 表示复杂度增长不会超过 *n*³，忽略潜在的常数因子。*O*() 表示算法复杂度的*上界*。*O*(1) 表示一个算法运行在*常数时间*内——即运行时间与输入长度无关。例如，通过查看整数的最低有效位（LSB）并返回“偶数”如果为零，返回“奇数”否则，来确定整数的奇偶性，这个算法无论整数的长度如何，都会以相同的成本完成相同的操作。

要查看线性、二次和指数时间复杂度之间的差异，可以查看 图 9-1 中 *O*(*n*)（线性）、*O*(*n*²)（二次）和 *O*(2*^n*)（指数）复杂度的增长情况。

![](img/fig9-1.jpg)

图 9-1：从最快到最慢增长的指数、二次和线性复杂度

指数复杂度意味着问题几乎不可能解决，线性复杂度意味着解决方案是可行的，而二次复杂度介于两者之间。

#### 多项式时间与超多项式时间

二次 *O*(*n*²) 复杂度（图 9-1 中的中间曲线）是更广泛的多项式复杂度类 *O*(*n**^k*) 的特例，其中 *k* 是一些固定的数值，比如 3、2.373、7/10 或者 17 的平方根。多项式时间算法在复杂度理论和密码学中非常重要，因为它们是实际可行性的定义。当一个算法在*多项式时间*内运行，简称*polytime*，即使输入很大，它也能在合理的时间内完成。这就是为什么对于复杂度理论家和密码学家来说，多项式时间就是“高效”的代名词。

相反，你可以将运行在*超多项式时间*下的算法视为不切实际的——即在*O*(*f*(*n*)), 其中 *f*(*n*) 是任何比任何多项式增长更快的函数——不切实际。我说的是超多项式时间，而不仅仅是指数时间，因为在多项式复杂度和著名的指数复杂度 *O*(2*^n*) 之间，还有一些复杂度，例如 *O*(*n*^(log()*^n*^))，正如图 9-2 所示。

![](img/fig9-2.jpg)

图 9-2：2 n、 nlog(n)以及 n² 函数，从最快到最慢增长

*O*(*n*²) 或 *O*(*n*³) 可能是高效的，但 *O*(*n*^(99,999,999,999)) 显然不是。换句话说，只要指数不太大，多项式时间在实际中是快速的。幸运的是，所有实际问题中找到的多项式时间算法都有较小的指数。例如，*O*(*n*^(2.373)) 是理论上已知的最佳 *n* × *n* 矩阵乘法算法的时间复杂度，但这个算法在实际中从未使用。2002 年，突破性的多项式时间确定性算法首次用于识别 *n* 位素数，初始复杂度为 *O*(*n*¹²)，但后来改进为 *O*(*n*⁶)。因此，多项式时间可能不是算法实际时间的完美定义，但它是我们目前最好的定义。

扩展来看，你可以认为无法通过多项式时间算法解决的问题是不切实际的，或者是*困难*的。例如，对于一个简单的密钥搜索，除非加密算法被某种方式破解，否则无法突破 *O*(2*^n*) 的复杂度。

> 注意

*指数复杂度* O*(2*^n*) 并不是你能遇到的最糟糕的复杂度。有些复杂度增长得更快，因此使得算法的计算速度更慢——例如，复杂度 O*(*n^n*) 或 *指数阶乘 O*(*n*^(f()*^n *^(– 1))**)，其中对于任何* x*，函数* f *在此递归地定义为* f*(*x*) =* x*^(f()*^x *^(– 1))**。实际上，你几乎不可能遇到具有如此荒谬复杂度的算法。

你知道，对于一个蛮力密钥搜索算法，无法突破 *O*(2*^n*) 的复杂度（只要加密算法是安全的），但你并不总是能知道解决一般计算问题的最快方法。复杂度理论的大部分研究都集中在证明解决给定问题的算法的复杂度*界限*。为了让他们的工作更轻松，复杂度理论家将计算问题按解决它们所需的努力分成了不同的组，或者说是*类*。

### 复杂度类

在数学中，*类*是具有某些相似属性的一组对象。例如，所有在时间 *O*(*n*²) 内可以解决的计算问题，复杂度理论家简化地称为 **TIME**(*n*²)，就构成了一个类。同样，**TIME**(*n*³) 是在时间 *O*(*n*³) 内可解决的问题类，**TIME**(2*^n*) 是在时间 *O*(2*^n*) 内可解决的问题类，以此类推。正如超级计算机可以计算任何笔记本电脑能计算的内容一样，任何在 *O*(*n*²) 内可解的问题也可以在 *O*(*n*³) 内解决。因此，**TIME**(*n*²) 类中的任何问题也属于 **TIME**(*n*³) 类，而这两个类也都属于 **TIME**(*n*⁴) 类，以此类推。所有类 **TIME**(*n**^k*), 对于所有常数 *k* 的并集是 **P**，表示多项式时间。

如果你编写过计算机程序，你会知道看似快速的算法仍然可能通过耗尽所有内存资源而导致系统崩溃。在选择算法时，你不仅要考虑它的时间复杂度，还要考虑它使用的内存量，或者说它的*空间复杂度*。这尤其重要，因为一次内存访问通常比 CPU 中的基本算术操作慢几个数量级。

正式地，你将算法的内存消耗定义为其输入长度*n*的函数，方法与时间复杂度的定义相同。使用*f*(*n*)位内存能够解决的问题类是**SPACE**(*f*(*n*)）。例如，**SPACE**(*n*³)是使用大约*n*³位内存可以解决的问题类。就像**P**是所有**TIME**(*n**^k*)的并集一样，所有**SPACE**(*n**^k*)问题的并集是**PSPACE**。

虽然内存越少越好，但多项式数量级的内存并不一定意味着一个算法是实用的。以暴力穷举密钥搜索为例，虽然它几乎不消耗内存，但却极其缓慢。更一般地说，即使一个算法只使用很少的内存，它也可能需要永远运行。

任何能够在时间*f*(*n*)内解决的问题，最多需要*f*(*n*)的内存，因此**TIME**(*f*(*n*))包含在**SPACE**(*f*(*n*)）中。在时间*f*(*n*)内，你可以写入最多*f*(*n*)位数据，不能再多，因为写入（或读取）1 位被假设为需要一个单位的时间；因此，任何**TIME**(*f*(*n*))中的问题不能使用超过*f*(*n*)的空间。因此，**P**是**PSPACE**的子集。

#### 非确定性多项式时间

**NP**，即*非确定性*多项式时间，是第二重要的复杂度类，仅次于**P**类（所有多项式时间算法类）。

**NP**是决策问题的类，对于这些问题，你可以在多项式时间内验证一个解——也就是说，高效地验证——尽管该解可能很难找到。所谓的*验证*是指，给定一个潜在解，你可以运行某个多项式时间的算法来检查你是否找到了一个实际的解。例如，判断是否存在一个密钥*K*，使得*P*和*C*在对称加密系统**E**下满足*C* = **E**(*K*, *P*)的问题属于**NP**类。这是因为，给定一个候选密钥*K*[0]，你可以通过验证**E**(*K*[0], *P*)是否等于*C*来检查*K*[0]是否是正确的密钥。你不能在多项式时间内找到潜在密钥（如果存在的话），但你可以检查一个密钥是否正确。

现在来看一个反例：已知密文攻击怎么样？这次，你只能得到一些**E**(*K*, *P*)的值，其中*P*是随机的未知明文。如果你不知道*P*是什么，那么就无法验证一个潜在的密钥*K*[0]是否正确。换句话说，在已知密文攻击下，密钥恢复问题不在**NP**类中（更不用说在**P**类中了），因为你无法将其表示为一个决策问题。

另一个不在**NP**中的问题是验证一个问题**无解**。验证一个解是否正确归结为计算某个算法，将候选解作为输入，然后检查返回值。然而，要验证**没有解**，你可能需要遍历所有可能的输入。如果输入数量是指数级的，你将无法高效地证明没有解存在。对于**NP**类中最难的问题——所谓的**NP**-完全问题来说，证明没有解是很困难的。

#### NP-完全问题

***NP****-完全*问题是**NP**类中最难的决策问题；你无法在多项式时间内解决这些问题的最坏情况实例。正如复杂性理论学者在 1970 年代发展**NP**-完全性理论时发现的那样，**NP**中最难的问题本质上是同样困难的。通过展示你可以将任何**NP**-完全问题的有效解决方案转化为另一个**NP**-完全问题的有效解决方案，证明了这一点。换句话说，如果你能够高效地解决任何**NP**-完全问题，你就能解决所有问题，包括**NP**中的所有问题。这是怎么回事呢？

**NP**- 完全问题有不同的表现形式，但从数学角度来看它们本质上是相似的。实际上，你可以将任何**NP**-完全问题转化为另一个**NP**-完全问题，且解决第二个问题的能力意味着能够解决第一个问题。记住，**NP**包含的是决策问题，而不是搜索问题。你可以高效地将一个能够解决搜索问题的算法转化为能够解决相应决策问题的算法，尽管反方向并不总是可能的。幸运的是，对于 NP-完全问题来说，这种转化是可行的，这也解释了为什么人们常常将这两者混淆。

以下是一些**NP**-完全问题的例子：

**旅行商问题** 给定一组地图上的点（如城市）以及每个点之间的距离，并给定一个最大距离 *x*，决定是否存在一条路径能够访问每个点，并且总距离小于 *x*。（注意，你可以以基本相同的复杂度找到这样一条路径，作为决策问题，但判断路径是否最优并不在**NP**中，因为你不能高效地验证一个解的正确性。）

**团问题** 给定一个数字 *x* 和一个图（一个由边连接的节点集合，如图 9-3 所示），判断是否存在一个最多包含 *x* 个节点的集合，这些节点之间都是相互连接的。

![](img/fig9-3.jpg)

图 9-3：包含四个节点的团体的图形。给定大小的团体（所有节点都互相连接）的查找问题是 NP-完全问题。

**背包问题**给定两个数字，*x*和*y*，以及一组物品，每个物品都有已知的价值和重量，决定是否存在一组物品，使得总价值至少为*x*，并且总重量不超过*y*。

你可以在许多地方找到这样的**NP**-完全问题，从调度问题（给定一些优先级和持续时间的任务，以及一个或多个处理器，按照优先级将任务分配给处理器，同时最小化总执行时间）到约束满足问题（确定满足一组数学约束的值，如逻辑方程）。甚至某些视频游戏的获胜任务也被证明是**NP**-难题（包括*俄罗斯方块*、*超级马里奥*、*口袋妖怪*和*糖果传奇*等著名游戏）。例如，文章《经典任天堂游戏是（计算上）困难的》探讨了“可达性决策问题”，以确定从某个特定起点到达目标点的可能性（* [`<wbr>arxiv<wbr>.org<wbr>/abs<wbr>/1203<wbr>.1895`](https://arxiv.org/abs/1203.1895) *）。

其中一些视频游戏问题至少与**NP**-完全问题一样困难，称为**NP**-*难*。当一个（不一定是可判定的）问题至少与**NP**-完全（决策）问题一样困难，并且任何解决该问题的方法都可以高效地用于解决**NP**-完全问题时，该问题被称为**NP**-难问题。

**NP**-完全问题必须是可判定问题；也就是说，问题的答案必须是“是”或“否”。因此，严格来说，计算解决方案“最佳”值的问题不能是**NP**-完全问题，但可以是**NP**-难题。例如，考虑旅行商问题：问题“是否存在一条路径，经过所有点，且距离小于*X*？”是**NP**-完全问题，而“找到一条更快的路径，经过所有点”是**NP**-难题。

请注意，并非所有**NP**-难问题的*实例*都难以解决。你可能能够高效地解决某些实例，因为它们很小或具有特定结构。例如，考虑图 9-3 中的图形。你可以快速找到其中的团体，也就是顶部的四个连接节点——尽管前述的团体查找问题是**NP**-难题，但这里并没有什么难度。**NP**-难并不意味着给定问题的所有实例都很难，而是随着问题规模的增长，其中一些实例变得更难。这就是为什么密码学家更关心那些在平均情况下很难解决的问题，而不仅仅是最坏情况下的问题。

#### P 与 NP 问题

如果你能够在多项式时间内解决最难的**NP**问题，那么你就能够在多项式时间内解决*所有*的**NP**问题，因此**NP**将等于**P**。这样的等式听起来荒谬：难道不是有些问题，解法很容易验证，但却很难找到吗？例如，难道不显而易见，指数时间的暴力破解是恢复对称密码密钥最快的方法，因此这个问题不可能属于**P**吗？

尽管听起来疯狂，但至今没有人证明**P**与**NP**不同，尽管有 100 万美元的奖金。克雷数学研究所将奖励任何证明**P** ≠ **NP**或**P** = **NP**的人。这个问题，称为**P**与**NP**问题，被著名的复杂性理论学家 Scott Aaronson 称为“人类曾经提出的最深刻的问题之一”。想一想：如果**P**等于**NP**，那么任何容易验证的解法也会很容易找到。所有实践中使用的加密技术都将不再安全，因为你可以高效地恢复对称密钥并反转哈希函数。

但别惊慌：大多数复杂性理论学家认为**P**不等于**NP**，因此**P**是**NP**的一个严格子集，正如图 9-4 所示，**NP**-完全问题是**NP**的另一个子集，与**P**没有交集。换句话说，看起来困难的问题实际上确实是困难的，只是很难用数学证明这一点。虽然证明**P** = **NP**只需要为一个**NP**-完全问题提供一个多项式时间算法，但证明不存在这样的算法则要困难得多。尽管如此，这并没有阻止数学家们提出一些简单的证明，虽然通常显然是错误的，但却往往很有趣；例如，可以参考“P 与 NP 页面”（* [`www.win.tue.nl/~wscor/woeginger/P-versus-NP.htm`](https://www.win.tue.nl/~wscor/woeginger/P-versus-NP.htm) *）。

![](img/fig9-4.jpg)

图 9-4: 类别 NP 和 P 以及 NP-完全问题的集合

如果我们几乎可以确定**NP**中存在困难问题，那么如何利用它们来构建强大的、可证明安全的加密呢？想象一下，如果我们能证明破解某些密码是**NP**-难的，因此，只要**P**不等于**NP**，该密码就是不可破解的。但现实令人失望：**NP**-完全问题的搜索版本已证明在加密中难以使用，因为正是这种使它们在最坏情况下变得困难的结构，有时会在加密中出现特定的情况，从而使得它们变得容易。相反，密码学通常依赖于那些*可能不是***NP**-难的问题。

### 因式分解问题

因式分解问题的任务是，给定一个大数*N* = *p* × *q*，找出质数*p*和*q*。广泛使用的 RSA 算法正是基于因式分解的困难：RSA 加密和签名方案是安全的，因为因式分解是一个困难的问题。在我们了解 RSA 如何在第十章中利用因式分解问题之前，我想说服你，关于该问题的判定版本（“*N*是否有一个小于*k*且不等于 1 的因子？”）确实是困难的，但可能不是**NP**-完全的。

首先，一些基本的数学知识。*质数*不能被任何其他数字整除，除了它本身和 1。例如，3、7 和 11 是质数；而 4（即 2 × 2）、6（2 × 3）和 12（2 × 2 × 3）则不是。数论的一个基本定理表明，你可以将任何整数唯一地表示为质数的乘积，这种表示方式称为该数的*因式分解*。例如，123,456 的因式分解是 2⁶ × 3 × 643，1,234,567 的因式分解是 127 × 9,721，等等。任何整数都有一个唯一的因式分解，或者说，唯一的方式将其表示为质数的乘积。多项式时间质数测试算法使我们能够高效地测试一个给定的数字是否是质数，或者一个给定的因式分解是否仅包含质数。然而，从一个数字得到它的质因数，则是另一个问题。

#### 因式分解大数

那么如何从一个数字得到它的因式分解——也就是将它分解成质数的乘积呢？分解一个数字*N*的最基本方法是尝试用所有比它小的数字去除，直到找到一个数字*x*，它能整除*N*。然后尝试用下一个数字*x* + 1 去除*N*，以此类推。最终你会得到*N*的因子列表。那么，这种方法的时间复杂度是多少呢？首先，记住我们将复杂度表示为输入*长度*的函数。数字*N*的比特长度是*n* = log[2] *N*。根据对数的定义，这意味着*N* = 2*^n*。因为所有小于*N*/2 的数字都是*N*的可能因子，因此我们需要尝试大约*N*/2 = 2*^n*/2 个值。因此，我们的朴素因式分解算法的复杂度是*O*(2*^n*)，忽略了*O*()符号中的 1/2 系数。

虽然许多数字通过首先找到任何小因子（2、3、5 等）并且迭代地分解其他非质数因子很容易，但在这里我们关注的是形如*N* = *p* × *q*的数字，其中*p*和*q*较大，这在密码学中很常见。

让我们更聪明一点：因为我们不需要测试所有小于*N*/2 的数字，而只需要测试小于*N*平方根的质数，因此我们可以从小于*N*平方根的质数开始。如果*N*不是质数，那么它至少有一个小于它平方根√*N*的因子。这是因为如果*N*的两个因子*p*和*q*都大于√*N*，那么它们的乘积将大于√*N* × √*N* = *N*，这显然是不可能的。例如，如果*N* = 100，它的因子*p*和*q*不可能都大于 10，因为那样它们的乘积会大于 100。*p*或*q*必须小于或等于√*N*。

那么，测试所有小于√*N*的质数的复杂度是多少呢？*质数定理*指出，小于*N*的质数大约有*N*/log *N*个。因此，小于√*N*的质数大约有√*N*/log √*N*个。将这个值用*n* = log[2] *N*表示，我们得到大约 2*^n*^(/2 + 1)/*n*个可能的质因子，因此复杂度为*O*(2*^n*^(/2)/*n*)，因为√*N* = 2*^n*^(/2)，而 1/log √*N* = 1/(*n*/2) = 2/*n*。这比测试所有质数要快，但仍然非常慢——对于一个 256 位的数字来说，大约需要 2¹²⁰次操作。这是一个相当不切实际的计算量。不过，我们可以做得更好。

最快的分解算法是*通用数域筛法（GNFS）*，我在这里不做描述，因为它需要引入几个高级数学概念。GNFS 的复杂度粗略估算为 exp(1.91 × *n*^(1/3) (log *n*)^(2/3))，其中*n* = log[2] *N*是*N*的位长，exp(. . .)只是指数函数*e* *^x*的另一种表示方式，其中*e*是大约等于 2.718 的指数常数。然而，确切估算 GNFS 在特定数字大小下的实际复杂度是困难的。因此，我们必须依赖启发式复杂度估算，显示随着*n*值的增加，安全性如何提升。例如：

+   分解一个**1,024 位**的数字，该数字有两个大约为 500 位的素因子，需要进行大约 2⁷⁰次基本操作。

+   分解一个**2,048 位**的数字，该数字有两个大约为 1,000 位的素因子，需要进行大约 2⁹⁰次基本操作——比分解 1,024 位数字慢约一百万倍。

你可以估算，达到 128 位安全性至少需要 4,096 位。请对这些值持保留态度，因为研究人员对这些估算并不总是达成一致。以下实验结果揭示了分解的实际成本：

+   2005 年，在大约 18 个月的计算之后——得益于一个由 80 个处理器组成的计算集群，总计算量相当于单个处理器上 75 年的计算——一组研究人员分解了一个**663 位**（200 位十进制数字）数字。

+   2009 年，在大约两年的时间里，使用数百个处理器，总计算量相当于单个处理器上约 2,000 年的计算，另一个研究小组分解了一个**768 位**（232 位十进制数字）数字。

+   2020 年，在几个月的计算之后，使用了数万个处理器和一台超级计算机，总计算量相当于单个处理器上约 2,700 年的计算，另一个团队分解了一个**829 位**（250 位十进制数字）数字。

如你所见，研究人员分解的数字比实际应用中的数字要短，实际应用中的数字至少是 1,024 位，通常超过 2,048 位。就我所写的内容来看，目前没有人报告过分解 1,024 位数字的情况，但许多人猜测像 NSA 这样资金充裕的组织可能已经做到了。

总结来说，你应该将 1,024 位的 RSA 视为不安全的，并使用至少 2,048 位的 RSA，但最好使用 4,096 位的 RSA 以确保更高的安全性。

#### 分解问题可能不是 NP 难的

我们不知道如何高效地分解大数，这表明分解问题不属于**P**类。然而，分解问题的决策版本显然属于**NP**类，因为给定一个因式分解结果，我们可以通过检查所有因子是否为质数来验证答案，感谢前述的质数测试算法，并且当这些因子相乘时，它们的乘积等于预期的数值。例如，要检查 3 × 5 是否是 15 的因式分解，只需确认 3 和 5 都是质数，并且 3 乘以 5 等于 15。

所以我们有一个**NP**类中的问题，看起来很困难，但它真的有**NP**最困难的问题那么难吗？换句话说，分解问题的决策版本是否是**NP**-完全的，因此，分解问题是否是**NP**-困难的？剧透：可能不是。

目前没有数学证明表明分解问题不是**NP**-困难的，但我们有一些间接证据。首先，所有已知的**NP**-困难问题在**NP**类中可能有一个解、多个解或没有解。而分解问题始终只有一个解。此外，分解问题具有数学结构，使得 GNFS 算法能够显著超越朴素算法，而**NP**-困难问题并不具备这样的结构。使用*量子计算机*解决分解问题将变得简单，量子计算机是一种利用量子力学现象运行各种算法的计算模型，具有高效分解大数的能力（不是因为它能更快地运行算法，而是因为它能运行专门用于分解大数的量子算法）。然而，这种量子计算机目前尚不存在——而且可能永远也不会存在。不管怎样，人们认为量子计算机在解决**NP**-困难问题上是无用的，因为它的速度不会比经典计算机快（见第十四章）。

理论上，分解问题可能比解决**NP**-困难问题稍微简单一些，但就密码学而言，它足够困难，而且比**NP**-困难问题更可靠。事实上，基于分解问题构建密码系统比基于**NP**-完全问题的搜索版本更容易，因为很难确切知道破解基于此类问题的密码系统到底有多难——换句话说，你能获得多少位的安全性。如前所述，这与**NP**关心最坏情况的困难度，而密码学家们关注的是平均情况的困难度相关。

分解问题是你可以在密码学中使用的多个*难度假设*之一，难度假设是指某个问题在计算上是困难的。你可以在证明打破密码系统安全性至少和解决该问题一样困难时使用这个假设。另一个你可以用作难度假设的问题是*离散对数问题（DLP）*，它实际上是一个问题族。

### 离散对数问题

离散对数问题（DLP）早于因数分解问题出现在密码学的官方历史中。尽管 RSA 算法出现在 1977 年，但另一个密码学突破——Diffie–Hellman 密钥交换协议（见第十一章）大约在一年前就已出现，其安全性依赖于 DLP 的难解性。与因数分解问题类似，DLP 也涉及大数，但它比因数分解问题更复杂，需要更多的数学知识。让我们从在离散对数背景下引入群的数学概念开始。

#### 群

在数学中，*群*是一个元素的集合（通常是数字），这些元素根据某些明确定义的规则相互关联。群的一个例子是非零整数模素数*p*的集合（即 1 到*p*–1 之间的数字），其群运算是模乘法。我们将这样的群记作（**Z**p^*, ×），或者在群运算明确为乘法时简写为**Z**p^*。

对于*p* = 5，得到群**Z**[5]^* = {1, 2, 3, 4}。在群**Z**[5]^*中，运算是模 5 进行的；因此，3 × 4 ≠ 12，而是 3 × 4 = 2，因为 12 mod 5 = 2。你仍然可以使用常规整数乘法中使用的符号（×）。你还可以使用指数表示法来表示群元素与自身的乘法模*p*，这是密码学中常见的运算。例如，在**Z**[5]^*中，2³ = 2 × 2 × 2 = 3，而不是 8，因为 8 mod 5 = 3。

要成为一个群，数学集合及其运算必须具备以下特征，这些特征被称为*群公理*：

**封闭性 **对于任何两个群元素*x*和*y*，*x* × *y*也在该群中。在**Z**[5]^*中，2 × 3 = 1（因为 6 = 1 mod 5），2 × 4 = 3，等等。

**结合性 **对于任何群元素*x*、*y*、*z*，(*x* × *y*) × *z* = *x* × (*y* × *z*)。在**Z**[5]^*中，(2 × 3) × 4 = 1 × 4 = 2 × (3 × 4) = 2 × 2 = 4。

**单位元存在 **群中包含一个元素*e*，使得*e* × *x* = *x* × *e* = *x*。这样的元素称为*单位元*。在任何**Z**p^*中，单位元是 1。

**逆元存在 **对群中的任何*x*，存在一个*y*使得*x* × *y* = *y* × *x* = *e*。在**Z**[5]^*中，2 的逆元是 3，3 的逆元是 2，而 4 是它自身的逆元，因为 4 × 4 = 16 = 1 mod 5。

此外，如果群是*交换的*或*阿贝尔的*，即对任何群元素*x*和*y*都有*x* × *y* = *y* × *x*，那么该群是交换群。对于任何整数乘法群**Z**p^*，这一点也成立。特别地，**Z**[5]^*是交换的：3 × 4 = 4 × 3，2 × 3 = 3 × 2，依此类推。

如果存在至少一个元素 *g*，使得它的幂次（*g*¹、*g*²、*g*³ 等）对 *p* 取模后能够覆盖所有不同的群元素，那么该群就是*循环*的。此时，元素 *g* 被称为该群的*生成元*。**Z**[5]^* 是循环群，并且有两个生成元，2 和 3，因为 2¹ = 2，2² = 4，2³ = 3，2⁴ = 1，3¹ = 3，3² = 4，3³ = 2，3⁴ = 1。

请注意，我这里使用的是乘法作为群运算符，但你也可以使用其他运算符来构造群。例如，最简单的群是所有整数的集合，包括正整数和负整数，以加法作为群运算。让我们检查加法是否满足群公理，按以下顺序：*x* + *y* 是整数，如果 *x* 和 *y* 是整数（封闭性）；(*x* + *y*) + *z* = *x* + (*y* + *z*)，对任意 *x*、*y* 和 *z* 都成立（结合性）；零是单位元素；群中任何数字 *x* 的逆元素是 –*x*，因为 *x* + (–*x*) = 0，对任何整数 *x* 都成立。然而，一个很大的不同是，这个整数群是无限大的，而在密码学中，你只会处理*有限群*，即包含有限个元素的群，这是出于实现的考虑。通常，你会使用群 **Z**p^*，其中 *p* 是*成千上万*比特长的（也就是说，如果 *p* 是 *m* 比特长的，则该群包含大约 2*^m* 个数字）。

#### 困难之处

最初在密码学中使用的离散对数问题是寻找 *y*，使得 *g**^y* = *x*，已知生成元 *g* 位于某个群 **Z**p^* 中，其中 *p* 是素数，已知群元素 *y*。我们通常以加法而非乘法表示 DLP，如椭圆曲线群中的情况。在这种情况下，问题是找到乘法因子 *k*，使得 *k* × *P* = *Q*，其中已知点 *P* 和 *Q*。这被称为*椭圆曲线离散对数问题（ECDLP）*。

DLP 是*离散*的，因为你处理的是可数的整数，而不是不可数的实数，并且它是*对数*问题，因为你要找的是以 *g* 为底的 *x* 的对数。例如，256 以二为底的对数是 8，因为 2⁸ = 256。

因式分解的难度与离散对数问题差不多，因此它们的安全性也相似。事实上，解决 DLP 的算法与因式分解整数的算法有相似之处，处理 *n* 比特的难以因式分解的数字与在 *n* 比特群中求离散对数的安全级别差不多。与因式分解一样，DLP 并不是 **NP**-困难问题。（有一些群，在这些群中，DLP 更容易解决，但它们在密码学中不会使用，至少在需要 DLP 难度的地方不会使用。）

### 事情如何出错

40 多年后，我们仍然不知道如何有效地分解大数或解决离散对数问题。在没有数学证明的情况下，总是可以猜测它们有一天会被破解。但我们也没有证明 **P** ≠ **NP**，因此你可以猜测 **P** 可能等于 **NP**；然而，根据专家的看法，这个惊讶的可能性不大。目前大多数公共密钥加密系统依赖于分解（RSA）或 DLP（迪菲-赫尔曼，ElGamal，椭圆曲线密码学）。虽然数学可能不会失败，但现实世界的问题和人为错误可能会悄悄地潜入。

#### 当分解变得容易时

分解大数并不总是困难的。例如，考虑以下 1,024 位的数字 *N*：

![](img/pg191-1.jpg)

对于在 RSA 加密或签名方案中使用的 1,024 位数字，其中 *N* = *pq*，我们预期最佳的分解算法大约需要 2⁷⁰ 次操作，正如我们之前讨论的那样。但你可以使用 SageMath 这个基于 Python 的数学软件，在几秒钟内分解这个示例数字。在我的 2023 年款 MacBook 上，使用 SageMath 的 factor() 函数，不到一秒钟就找到了以下的分解：

![](img/pg191-2.jpg)

对，我作弊了。这个数字不是 *N* = *pq* 的形式，因为它不仅有两个大素数因子，而是有五个，包括一些非常小的因子，这使得它很容易分解。首先，你通过尝试一个预先计算好的素数列表中的小素数，识别出 2⁸⁰⁰ × 641 × 6,700,417 这一部分，剩下的就是一个 192 位的数字，比一个有两个大因子的 1,024 位数字更容易分解。

分解不仅仅在 *n* 有小素数因子的情况下容易，*N* 或其因子 *p* 和 *q* 也有特定形式时也可能容易——例如，当 *N* = *pq*，并且 *p* 和 *q* 都接近某个 2*^b* 时，当 *N* = *pq* 且 *p* 或 *q* 的某些位已知时，或者当 *N* 的形式是 *N* = *p**^r**q**^s* 且 *r* 大于 log *p* 时。然而，详细阐述这些弱点的原因对于本书来说过于技术化。

结果是，RSA 加密和签名算法（见 第十章）需要使用 *N* = *pq* 的值，其中 *p* 和 *q* 必须精心选择，以避免 *N* 的简单分解，这可能会导致安全灾难。

#### 小的难题并不难

计算上困难的问题，甚至是指数时间的算法，当它们足够小的时候也能变得实用。对称加密可能在某种意义上是安全的，因为没有比 2*^n* 次暴力破解更快的攻击，但如果密钥长度是 *n* = 32，你将在几分钟内破解这个加密。这听起来很显然，你可能会认为没有人会天真到使用小密钥，但实际上，确实有很多原因可能导致这种情况。以下是两个真实的故事。

假设你是一个对加密一无所知的开发者，但你有一些 API 可以用 RSA 进行加密，而且被要求使用 128 位安全性进行加密。你会选择什么样的 RSA 密钥大小？我见过真实案例中使用 128 位 RSA，或者基于 128 位数字*N* = *pq*的 RSA。然而，虽然对一个长度达到几千位的*N*进行因式分解几乎是不可能的，但对 128 位数字进行因式分解却很容易。使用 SageMath 软件，列表 9-2 中的命令几乎可以瞬间完成。

```
sage: p = random_prime(2**64)
sage: print(p)
6822485253121677229
sage: q = random_prime(2**64)
sage: print(q)
17596998848870549923
Sage: N = p*q
sage: factor(N)
6822485253121677229 * 17596998848870549923
```

列表 9-2：通过选择两个随机质数生成 RSA 模数，并即时进行因式分解

列表 9-2 显示了你可以轻松地将一个 128 位数字随机作为两个 64 位质数的乘积进行因式分解，且这一过程在典型的笔记本电脑上几乎瞬间完成。然而，如果我选择使用 1,024 位质数，通过命令p = random _prime(2**1024)，则命令factor(p*q)将永远无法完成，至少在我有生之年是如此。

公平地说，现有的工具并不能有效防止天真的使用不安全的短参数。例如，OpenSSL 工具包曾允许你生成短至 31 位的 RSA 密钥，且没有任何警告；这些短密钥是完全不安全的，如列表 9-3 所示。OpenSSL 后来已修复，在其 2023 年 2 月发布的版本 1.1.1t 中，如果你请求一个小于 512 位的密钥，会返回“密钥大小太小”的错误。

```
$ **openssl genrsa 31**
Generating RSA private key, 31 bit long modulus
.+++++++++++++++++++++++++++
.+++++++++++++++++++++++++++
e is 65537 (0x10001)
-----BEGIN RSA PRIVATE KEY-----
MCsCAQACBHHqFuUCAwEAAQIEP6zEJQIDANATAgMAjCcCAwCSBwICTGsCAhpp
-----END RSA PRIVATE KEY-----
```

列表 9-3：使用旧版本的 OpenSSL 工具包生成不安全的 RSA 私钥

在审查密码学时，你不仅要检查所使用的算法类型，还要检查它们的参数以及它们的秘密值的长度。然而，正如你将在接下来的故事中看到的那样，今天足够安全的东西明天可能就不再安全了。

2015 年，研究人员发现许多 HTTPS 服务器和邮件服务器支持一个旧版本的不安全的 Diffie–Hellman 密钥交换协议。具体来说，底层的 TLS 实现支持在一个由一个 512 位质数*p*定义的组**Z**p^*中使用 Diffie–Hellman，其中离散对数问题已经不再是不可计算的。

服务器不仅支持了一个弱算法，攻击者还可以通过在客户端会话中注入恶意流量，迫使一个无害的客户端使用这个算法。更糟糕的是，对于攻击者来说，攻击的最大部分可以一次性执行并循环使用，以攻击多个客户端。在对特定群体进行大约一周的计算后，**Z**p^*，破解不同用户的单独会话仅需 70 秒。

如果安全协议被一个弱化的算法削弱，那么它是毫无价值的；如果一个可靠的算法被弱参数破坏，那么它也是无用的。在密码学中，你应该始终注意细节。

有关此故事的更多细节，请查看研究文章《不完美的前向保密：Diffie–Hellman 在实践中的失败》 (*[`weakdh.org/imperfect-forward-secrecy-ccs15.pdf`](https://weakdh.org/imperfect-forward-secrecy-ccs15.pdf)*)。

### 进一步阅读

我鼓励你深入探讨计算理论中的基础内容，尤其是在可计算性（什么函数可以计算？）和复杂性（以什么代价？）的背景下，以及它们如何与密码学相关。我主要讲解了**P**和**NP**类问题，但对于密码学家来说，还有许多其他类和有趣的研究点。我强烈推荐 Scott Aaronson 的《自德谟克里特以来的量子计算》（剑桥大学出版社，2013 年）。这本书大部分内容讲的是量子计算，但其前几章巧妙地介绍了复杂性理论和密码学。

在密码学研究文献中，你会找到其他困难的计算问题。我将在后续章节中提到这些问题，但这里有一些例子，展示了密码学家利用的各种问题：

+   Diffie–Hellman 问题（给定 *g**^x* 和 *g* *^y*，求 *g**^(xy)*) 是离散对数问题的一种变体，广泛应用于密钥协议中。

+   格问题，如最短向量问题（SVP）、短整数解问题（SIS）以及带错误学习问题（LWE），根据其参数的不同，可能是**NP**-困难的。

+   编码问题依赖于解码错误纠正码的困难性，通常信息不足，并且自 1970 年代末以来就一直是研究的课题。这些问题也可能是**NP**-困难的。

+   多变量问题是指求解非线性方程组的问题，可能是**NP**-困难的，但它们未能提供可靠的密码系统，因为困难版本的规模过大且速度过慢，且实际应用的版本被发现不安全。

在第十章中，我们将继续探讨困难问题，特别是因式分解及其主要变体——RSA 问题。
