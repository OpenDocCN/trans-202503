

## 第十六章：15 加密货币加密学



![](img/opener.jpg)

本章并未包含在 2017 年秋季初版的书中，那时加密货币和区块链正处于 hype 的巅峰期。虽然区块链并未完全实现其颠覆多个行业的承诺，但它已深刻影响了加密学研究和工程领域。区块链应用带来了新的激动人心的挑战，吸引了新的人才，并提供了一种新的方式来弥合理论与实践之间的差距。

在“加密”成为加密货币的代名词之前，加密算法和协议主要涉及标准功能，如加密和安全通道。那些较为深奥的协议通常局限于小众研究领域和技术文章，通常服务于研究人员的兴趣，并仅在学术会议上呈现。新的算法主要由学术研究人员设计，并且至少在经过五年的同行评审和分析，以及众多未成功破解的加密分析文章之后，才会在现实世界中部署（如果有的话）。

区块链颠覆了这一过程。就像 Signal 和 Tor 的加密协议避开了传统的学术途径一样，区块链爱好者在某种程度上也不受传统束缚。突破性的协议通常会在博客文章或非正式的白皮书中首次亮相，随后很快进行实现。有时，他们会完全放弃书面规范，让代码本身发声。只有在广泛采用后，学术界才会注意到它们。最著名的案例是比特币协议，在部署之前并没有经过正式的同行评审。

许多资深研究人员在区块链领域识别出了新颖的挑战，通常与区块链实体直接合作。他们开发了复杂的协议，这些协议不仅突破了边界并获得同行认可，而且在现实世界中得到了迅速实施，影响了成千上万，甚至百万个系统。重要的例子包括高效的 ECDSA 门限签名方案和零知识证明系统。在某些情况下，现有的几乎没有实际应用的协议找到了具有重大影响的应用场景，例如 Boneh–Lynn–Shacham（BLS）签名。

本章提供了这些加密算法和协议的概述——那些专为区块链量身定制的协议以及由于区块链而蓬勃发展的协议。我不会深入定义区块链或其工作原理，因为网络上有大量资源可以参考。相反，我强调的是支撑区块链的加密方案，这些方案在任何区块链应用场景中都有重要意义。即使你对区块链现象仍持怀疑态度，我相信你会发现本章内容具有启发性。

### 哈希应用

哈希函数，密码学的瑞士军刀，在区块链系统中担任着多种应用，包括：

**哈希交易的数据**

哈希函数可以生成由交易发行者签名的摘要，通常使用 ECDSA-secp256k1 或 Ed25519。验证签名确保给定地址的所有者批准了被哈希的信息，从而将交易包含在链的分类帐中。

在以太坊区块链中，交易的哈希作为其唯一标识符；例如，您可以在*[`<wbr>etherscan<wbr>.io`](https://etherscan.io)*的搜索字段中输入哈希来检索相关交易。以太坊交易哈希使用 Keccak-256——这与 SHA3-256 类似但不完全相同——并处理编码数据。该数据包括收款人地址、发送的以太（代号 ETH）数量、任何智能合约输入、燃气价格和限制、一个随机数（每个新交易递增）以及交易的签名。

**哈希块的内容**

哈希函数可以在后续块中包含摘要以“链接”这些块。例如，每个比特币块都有一个*块头*，其中包括上一个块的哈希，记录的交易的树哈希，以及一些元数据（版本、时间戳、随机数等）。比特币通过对上一个块的头部进行双 SHA-256 哈希或**SHA-256**（**SHA-256**（块头））来计算上一个块的哈希。这种非正统的构建消除了长度扩展攻击的风险，并在 SHA-256 被发现不安全时提供了安全保障——尽管这种情况不太可能发生。

除了这些基本用例外，哈希函数是区块链系统关键组件中的主要构建块。

#### Merkle 树

*Merkle 树*是一种哈希树，它是一种根据树模式从叶子值计算根值的数据结构。在哈希树中，父节点通过对子节点进行哈希计算而生成。例如，Merkle 树用于创建比特币块的头部。它们以计算机科学家拉尔夫·默克尔命名，其 1979 年的加密方案构建使用了二进制哈希树。

##### 树哈希计算

Merkle 树将构成其*叶子*的值作为输入，即计算其*根*（输出）的值。通常，您将数据结构树的根表示为顶部，叶子表示为底部。

例如，图 15-1 展示了一个 Merkle 树对四个值（*A*、*B*、*C*、*D*）进行哈希。

![](img/fig15-1.jpg)

图 15-1：一个哈希树，其中叶子是输入，根是输出

然后，树哈希工作如下：

+   对四个值中的每一个进行哈希以获得四个哈希**H**（*A*）、**H**（*B*）、**H**（*C*）和**H**（*D*）。

+   将每一对连续的哈希值组合起来得到**H**(**H**(*A*) || **H**(*B*))和**H**(**H**(*C*) || **H**(*D*)）。这里你将哈希值进行连接（如符号||所示）。

+   将两个哈希值组合在一起，得到树的根节点，这是树哈希的最终输出：**H**(**H**(**H**(*A*) || **H**(*B*)) || **H**(**H**(*C*) || **H**(*D*))).

如果省略了输入值的初始哈希——仅在输入值不是哈希大小时才需要——你将从四个值开始，最终得到一个具有两层树结构的单一值，或者说*高度*为二。注意，虽然输入数据可能具有不同的大小，但所有哈希值的大小都是相同的。通常，一个*高度*为*n*的树具有 2*^n*个叶子，允许你通过计算 2*^n* - 1 个哈希值（从哈希后的叶子开始）来处理最多 2*^n*个值。

如果输入值的数量不是 2*^n*（对于某个整数*n*），一种常见的技术是添加虚拟值（例如，将其设为零或列表中的最后一个值）；但是，填充规则应该仔细选择，以避免出现简单的冲突。

##### Merkle 证明

Merkle 树的结构可以用来证明某个给定的值属于被哈希的 2*^n*个值的列表，而无需重新计算整个树（这将涉及 2*^n*次操作），而只需要与树的*高度*（即其层数*n*）成比例的时间。根据具体情况，这种证明被称为*成员路径*、*包含证明*或*Merkle 证明*。这是 Merkle 树的一个杀手级特性，而通用哈希函数则不提供这一功能。

图 15-2 展示了这一过程的工作原理。阴影单元格是足够证明*V*[1]是被哈希得到根节点的值之一。

![](img/fig15-2.jpg)

图 15-2：一个 Merkle 树，其中阴影单元格构成了 A的成员路径

假设你想证明*A*是被哈希的值之一，而不暴露*B*、*C*或*D*。首先，对*A*进行哈希处理，得到哈希树的实际叶子节点。然后，假设你已经收到了*A*的成员路径，该路径包含其他阴影值，**H**(*B*)和**H**(**H**(*C*) || **H**(*D*)）。为了验证*A*是否属于这棵树，计算以下内容：

+   *X* = **H**(**H**(*A*) || **H**(*B*))，因为你知道*A*和**H**(*B*)

+   **H(H**(*X*) || **H**(**H**(*C*) || **H**(*D*)))，因为你知道**H**(**H**(*C*) || **H**(*D*))

仅通过两次哈希操作就能证明*A*的包含性，或者根据树的高度，进行的哈希操作次数即为树的高度。具有八个叶子的树的高度为三；因此，验证成员路径需要三个兄弟哈希。对于 16 个叶子，您需要四个兄弟哈希，以此类推，对于具有 2*^n*个叶子的树，需要*n*个兄弟哈希。

区块链应用通常使用梅克尔树将交易哈希成一个单一的*梅克尔根*，例如比特币区块头中包含的那个。一个典型的比特币区块注册大约 2,000 个交易，这需要一个高度为 11 的树（2¹¹ = 2,048）。在这种情况下，从叶子节点计算根节点需要 2,048 - 1 = 2,047 个兄弟哈希，每个叶子节点是交易数据的哈希。每个哈希计算一次双重 SHA-256，因此，在 2,048 个交易的情况下，需要 2,047 + 2,048 = 4,095 次双重 SHA-256 计算，或者 8,190 次 SHA-256 调用。

以太坊使用一种稍微复杂的基于树的数据结构，将梅克尔树与*帕特里夏树*（这不是打字错误；“trie”来自“检索”）结合起来，帕特里夏树是一种存储键值对的树状结构。该结构服务于以太坊的状态模型，这与比特币的 UTXO（未花费交易输出）模型有显著不同，后者对于简单的梅克尔树就足够了。 #### 工作量证明

工作量证明（PoW）可以说是区块链共识协议中最关键的组成部分——对于那些基于 PoW 而非权益证明（PoS）或其他协议的区块链。

*PoW*本质上是一个哈希函数，它接受一些固定输入和可变输入，并且其结果必须匹配某种模式才能有效。旨在*解决* PoW 的各方会重复计算哈希，使用不同的可变输入值，直到结果满足某种约束条件。

例如，在比特币和一些其他基于 PoW 的区块链中，约束条件是将哈希值视为一个 256 位数字时，该值必须小于给定的数字。也可以将其视为哈希值具有一定数量的前导零，前提是将哈希值视为一个 256 位数字的大端编码。

例如，在 2022 年，比特币的最高难度值（如* [`<wbr>btc<wbr>.com<wbr>/stats<wbr>/diff`](https://btc.com/stats/diff) *上报道）是 34,244,331,613,176，约为 2⁴⁵。你将其乘以 2³²，得到哈希值必须小于的实际值，即 2⁷⁷。对于每个区块，所有网络参与者（*矿工*）共同计算大约 2⁷⁷次双重 SHA-256 计算，以找到 PoW 的解决方案。这样的解决方案包括一个 nonce（PoW 哈希输入的可变部分），该 nonce 使哈希值小于 2⁷⁷。PoW 哈希输入的固定部分包括区块头的值（版本、前一个区块哈希、梅克尔树根、时间戳和难度目标值）。

如果没有 PoW“减缓”区块链中区块生产的速度，新有效区块可能会瞬间生成，这意味着交易历史可以随意创建和重建。这样就不可能实现*最终性*（即，一旦区块被网络接受，不能被撤回或更改，交易也无法被修改）。特别是，无法保护网络免受*双重支付*攻击，即在两笔不同交易中花费相同的币。

并非所有 PoW 方案都像比特币那样简单，它使用了一种通用哈希函数（SHA-256）。一些 PoW 尝试使其在专用硬件上的计算效率低于通用 CPU，从而阻止由投资于优化硬件矿机技术的组织垄断挖矿——与任何人都能使用的现成服务器和计算机不同。实施的技巧包括以下几种：

**内存难度** 你可以强迫工作量证明（PoW）使用大量内存，通常通过生成一个巨大的表格并访问不可预测的地址。例如，以太坊的 PoW 使用了 Ethash 算法，需要大约 4GB 的内存。（在 2022 年 9 月，以太坊放弃了 Ethash，并从 PoW 机制切换为权益证明机制。）

**虚拟机** 就像一些恶意软件那样，你可以创建一组自定义的计算机指令，这些指令将由虚拟机应用程序转换为标准指令，同时还可能使用大量内存来计算 PoW 的解决方案。这是 Monero 区块链采用的 PoW 算法——RandomX 的做法。

#### 分层密钥派生

区块链用户通常希望管理多个账户，每个账户由一对密钥组成，其中：

+   *私钥*必须保密，因为它是签名密钥，用于签署交易并从账户中转移资金。

+   *公钥*必须公开，因为它用于验证交易的签名。它也是从中衍生出账户地址的值。例如，比特币通过 SHA-256 和 RIPEMD-160 哈希的组合从公钥衍生出地址。需要注意的是，在一些区块链中，如比特币，公钥在账户发起交易之前并不公开。

为了可靠地管理所有这些密钥，区块链开发人员定义了*分层确定性钱包（HD 钱包）*，这种方式比为每个新账户生成并备份一个随机密钥更加简便且减少风险。

使用 HD 钱包时，你生成并存储一个秘密，即*种子*（也称为*主密钥*或*熵*）。该种子是唯一随机生成的值，是唯一提供熵或不确定性，从而保证通过它推导出来的私有签名密钥的保密性。因此，钱包软件应用通常将种子编码为*种子短语*或*助记符*，这是一组由 12 到 24 个单词组成的序列，便于保存和记忆。

让我们回顾一下如何使用 HMAC-SHA-512 伪随机函数（通过 SHA-512 实现的 HMAC 构造）来执行此密钥推导：从一个 128 或 256 位的种子 *S* 开始，使用该种子作为密钥输入计算 HMAC-SHA-512，将底层椭圆曲线的标识符作为消息输入（该字符串可以是“比特币种子”，“Nist256p1 种子”或“ed25519 种子”）。结果的前 256 位是主密钥 *k*，后 256 位是主链码 *c*，该值用于推导更多的密钥。

你可以从 *k* 和 *c* 推导一个*子私钥*，方法如下：给定一个标识符 *i*（最大为 2³¹ 的数字），使用链码 *c* 作为密钥计算 HMAC-SHA-512，并将 *k* 和 *i* 作为消息输入。512 位的结果被解析为 256 位的值 *L*，后跟 256 位的链码 *R*。简化表示为 *L* || *R* = HMAC-SHA-512(*c*, *k* || *i*)。然后将子私钥设置为 *k* + *L*，其链码为 *R*。

你可以依此推导密钥，并通过获得的密钥和链码建立密钥的*层次结构*。例如，从标识符为 0 的密钥推导出所有比特币的密钥，从标识符为 60 的密钥推导出所有以太坊的密钥。将一个数字与每个区块链网络关联的约定已在文档“SLIP-0044: BIP-0044 注册硬币类型”中标准化。

如果你首先通过标识符 0 推导一个子密钥，然后再通过该密钥及其链码推导一个标识符为（假设）29 的密钥，那么该密钥的*推导路径*为 0/29。你将执行两次 HMAC-SHA-512 调用，分别生成*L*[1]和*L*[2]作为它们的前 256 位，最终的私钥为 *k* + *L*[1] + *L*[2]。因此，你可以将所有由给定主密钥 *k* 推导的密钥视为 *k* 加上 HMAC-SHA-512 返回的值的总和。此推导称为*硬化*，因为你需要父密钥的私钥 *k* 和链码 *c*。

> 注意

*对于* 非硬化 *版本，请使用公钥而不是私钥，这样可以从父公钥确定子公钥。详细信息，请参阅初始比特币标准文档“BIP32: 分层确定性钱包”和其通用标准文档“SLIP-0010: 从主私钥推导通用私钥”。*

#### 代数哈希函数

哈希函数如 SHA-3 和 BLAKE3 作用于*字节*，或者 4 字节或 8 字节的*字*，其中一个字节是 8 位的一个数据单元。输入数据是一系列字节，每个字节可以取从 0x00 到 0xff（255）之间的 256 个可能值，输出数据同样是任意字节的序列。当数据有效地转化为字节序列时，并且字节或字的操作（如 XOR、字移位和整数加法）高效时，这种方式效果很好。

##### 数学计算机

假设你有一台计算机，它只能处理特定范围内的数字，比如模 13 的数字。XOR 操作对这些数字的效果不好，因为并非所有 4 位数字都小于 13；例如，10 和 4 的 XOR 运算结果是 14，这超出了范围。你可能会将结果按模 13 进行缩减，得到 1，但这样一来，10 XOR 4 和 10 XOR 11 会产生相同的结果，而在处理字节时不会出现这种问题。这通常会显著降低哈希函数的安全性——例如，通过碰撞。

更糟的是，你的计算机只能进行模 13 的运算：加法、减法、乘法和除法。它没有内建的按位 XOR 指令，所以只能用模 13 的算术运算来模拟，这既不直接也不高效。我将把这个模拟过程的细节留给你作为练习。

你的任务是创建一个只使用（或主要使用）算术运算的哈希函数，适用于给定数字范围，并且不使用按位操作，包括 XOR、OR、AND 或位移运算。

你需要这种类型的函数来高效地运行某些高级加密协议——即多方计算（MPC）和零知识证明，后面你将看到这一章的内容。此类协议通常在数学结构的范围内操作，比如有限域（例如，模素数的整数集合），有时还需要将程序“转化”为数学方程。从原则上讲，任何程序都可以转化为方程。但当程序没有针对底层数学结构进行优化时，方程会变得非常庞大且计算缓慢。*代数哈希函数*旨在通过设计既安全又易于仅使用有限域中的算术运算实现的哈希函数来解决这个问题。

##### 设计原则

让我们来考虑 *Poseidon* 的设计原则，这是一个在 2019 年为零知识证明系统设计的哈希函数，并迅速被许多区块链系统采纳。这类证明有时需要将哈希函数表示为一个关于大有限域的算术运算电路，比如模 255 位素数的整数集合。在这种情况下，Poseidon 比像 SHA-256 这样的通用哈希函数高效几个数量级。

Poseidon 使用海绵哈希函数构造（参见 第七章），因此需要构建一个 *置换*，这是一种输入输出大小相同的可逆变换。它将这个置换应用于一个有限域元素的向量状态。在相关应用中，这样的有限域通常由模素数的数字组成，大小可能从 31 位小到 381 位不等，具体取决于应用。

然后，像大多数哈希函数一样，置换会迭代一系列轮次，因此需要设计一个 *轮次函数*。

最后，Poseidon 将其置换分解为三个层，具有三个不同的目的，类似于 AES 的轮次：

+   一个 *唯一性* 层，*AddRoundConstants*，在 Poseidon 文档中标记为 *ARC*()。这个层向状态的元素添加常数值，使得每一轮的常数都不同。使每一轮具有唯一性可以防止包括滑动攻击在内的攻击。为了避免定义和存储许多常数，Poseidon 使用一个确定性随机位生成器来生成常数，该生成器初始化时使用 Poseidon 实例特征（如轮次数量、有限域、S-box 类型等）的编码。

+   一个 *非线性* 层或 *S-box 层*，*SubWords*，在 Poseidon 文档中标记为 *S*。这个层引入了 *混淆*，即输入和输出值之间通过高阶代数方程关联的特性——因此它们尽可能远离线性和低阶方程，后者是差分密码分析可以利用的。S-box 会独立地转换其状态的每个元素，通常将域元素 *x* 映射到 *x*³ 或 *x*⁵。指数保持相对较低，以便高效计算。

+   一个 *线性* 层，*MixLayer*，在 Poseidon 文档中标记为 *M*()。MixLayer 引入了 *扩散*，即初始状态中各元素之间差异的传播。例如，如果状态由四元素向量（*x*[1], *x*[2], *x*[3], *x*[4]）组成，则 *M*() 会将每个元素替换为所有元素的线性组合。它可能会用 2*x*[1] + 10*x*[2] + *x*[3] + 3*x*[4] 的结果替换 *x*[1]。这样的变换对应于将一个向量乘以一个矩阵。Poseidon 的矩阵必须满足某些安全性要求，并应为高效实现而设计。

一个 *完整轮次* 的 Poseidon 按以下顺序应用三个层：*ARC*()，*S* 到每个元素，再应用 *M*()。一个 *部分轮次* 只对一个元素应用 *S*，并且可能在 *M*() 中使用不同的矩阵。一个 Poseidon *实例* 会反复执行完整轮次、部分轮次和完整轮次——这些轮次的数量取决于实例、元素数量、有限域和目标安全等级。

> 注意

*欲了解更多关于 Poseidon 的详细信息，请参见* [`<wbr>www<wbr>.poseidon<wbr>-hash<wbr>.info`](https://www.poseidon-hash.info) *以及初始的 Poseidon 论文(*[`<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2019<wbr>/458<wbr>.pdf`](https://eprint.iacr.org/2019/458.pdf)*)和改进版 Poseidon2 论文(*[`<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2023<wbr>/323<wbr>.pdf`](https://eprint.iacr.org/2023/323.pdf)*)。*

Poseidon 是为了解决实际应用问题而创建的众多代数哈希函数之一。其他设计包括 MiMC、Monolith、Rescue-Prime 和 Tip5。

#### 事情是如何出错的

让我们来看一下在区块链世界中涉及哈希函数及其应用的一些安全失败案例。

##### 破损的自定义哈希

2017 年的区块链项目 Iota 相当奇怪。它声称采用不同于大多数区块链顺序区块链结构的架构，更接近直接无环图（DAG），这使得它的安全性大大降低。它还不是用位来编码数据，而是用*三值*（trit），这种单位有三种值而不是两种，目的是让计算在不存在的处理器上更高效。

Iota 并没有使用像 ECDSA 或 Ed25519 那样基于椭圆曲线的签名方案，而是使用了一种基于已建立的 Winternitz 结构的基于哈希的签名方案，从而提供了后量子安全性——然而 Iota 也设计了自己的自定义哈希函数 Curl。

Iota 成为了十大最流行的加密货币之一，并对其潜在的有用性和安全性做出了宏大的声明。但它声称通过人工智能的帮助开发的自定义哈希函数，在碰撞攻击面前却非常脆弱。研究人员使用市售硬件，在几分钟内就发现了碰撞，这些碰撞仅在设计好的攻击场景中才能被利用。Iota 很快修补了其哈希函数。

在这次失败之后，著名的密码学和安全专家布鲁斯·施奈尔评论道：“在 2017 年，让你的加密算法容易受到差分密码分析攻击是一个新手错误。这表明没有任何有能力的人分析他们的系统，而他们的修复措施让系统变得安全的可能性很低。”

##### 低熵钱包

本节早些时候提到的分层密钥派生模型在理论上是安全的，但在实践中只有在正确实现时才是安全的。通常可以通过使用 BIP32 和 SLIP-0010 标准文档中的测试向量来验证这一点。如果你得到的输入/输出值与文档中记录的相同，那么你的实现很可能是正确的，尽管不一定是安全的。

2022 年，流行的加密货币移动钱包应用 Trust Wallet 宣布发布了一款浏览器扩展版本，采用 WebAssembly（Wasm）技术，能够在不同的浏览器中高效运行。然而，Wasm 无法使用与移动版本相同的 PRNG，它必须定义一个不同的 PRNG。

一个糟糕的 PRNG 可能是加密学的致命弱点（参见 第二章）。在 Trust Wallet 中，开发者使用了 Mersenne Twister PRNG（mt19937），它并不是一个加密学 PRNG。它的熵最多为 32 位，且通过对内部状态值的简单线性组合来生成输出比特。

由于 Trust Wallet 的 PRNG 具有 32 位的熵，它只能为用户的钱包生成 2³² 个不同的种子。攻击者可以计算出所有 2³² 个可能的种子，并针对每个种子，计算出通过层级密钥派生法得到的私钥和地址。然后，他们可以扫描区块链，找到由 Trust Wallet 生成的地址并窃取其代币。发现该漏洞的 Ledger 公司研究人员评论道：“执行这样的攻击需要的时间远不止几个小时，但只需几张 GPU，便可在一天之内完成。”

##### 来自域分离失败的碰撞

让我们讨论如何找到一个抗碰撞的哈希函数的碰撞。正如加密学家 Moti Yung 所说：“如果这听起来不可能，那就从加密学的角度来看非常有趣。”

假设以下简单情况：一个应用从两方，Alice 和 Bob，接收消息 *A* 和 *B*，然后将这两条消息一起哈希，生成一个唯一的哈希值。它接着可以通过对字符串 *A* 后跟 *B* 进行哈希来计算 **H**(*A* || *B*)。即使你的哈希函数是抗碰撞的，当 *A* = COL 且 *B* = LISION 时，得到的哈希值与 *A* = CO 且 *B* = LLISION 时的哈希值相同。你会遇到针对应用输入值的哈希碰撞，尽管对哈希函数而言并不算碰撞，因为哈希函数 **H** 在这两种情况下处理的是相同的字符串，即 COLLISION。

为了避免这个问题，将应用的输入值编码为唯一的字符串，并且不采用模糊的编码方式：对于每个字符串，你应该能够唯一识别原始的输入值集合。在我们的例子中，在两个输入之间添加美元符号（$）作为分隔符似乎可以避免 COL || LISION 和 CO || LLISION 之间的碰撞：你将得到字符串 COL$LISION 和 CO$LLISION，从而生成不同的哈希值。

但是，仅仅使用分隔符符号不足以消除当字符在应用程序的输入值中被授权时产生的歧义。例如，考虑字符串 COL$$LISION，它是两个输入字符串通过$符号连接起来的结果。你可以从两个输入对中得到该字符串：COL 和$LISION，或者 COL$和 LISION。注意，当输入值的大小固定且常量时，问题不会出现——例如，第一个字符串由两个字符组成，第二个字符串由三个字符组成。即便如此，仍然更安全使用某些分隔符或编码来防止冲突，因为未来的补丁可能会引入可变长度的输入。

研究人员发现了在门限签名协议中存在这种类型的漏洞，稍后你将在本章中看到，此外在电子投票协议中也有类似问题，其中生成的哈希冲突可能被利用来破坏这些协议的安全属性。

### 多重签名协议

在加密的*多重签名协议*中，参与者共同生成一条消息的签名，功能上相当于所有方分别签署消息；获得的签名意味着所有参与者同意签署该消息。其优点是，签名的数量不再与签署者的数量相等，而只有一个。任何拥有所有签署者公钥的人都可以验证该签名。

区块链平台在多个参与方共同管理账户时使用多重签名，以确保所有参与方都支持已发起的交易。如果单个方在多个设备上有多个密钥，他们也可以使用多重签名，以防止单个被泄露的密钥允许攻击者发起交易。此类多重签名协议是*集体签名*协议的众多类型之一，在这些协议中，参与方运行一个协议以生成签名。

在深入技术细节之前，让我们先澄清这些多重签名与相关协议的不同之处。

#### 多方多重签名

尽管名称相似，我们将要讨论的多重签名协议与比特币和以太坊中使用的链上多重签名脚本或多重签名智能合约不同。后者并不是加密协议，因为参与者独立提交各自的签名到区块链网络，网络则验证如“如果交易拥有来自*pub*[1]和*pub*[2]的签名，则接受它”或“如果交易由*pub*[1]、*pub*[2]和*pub*[3]中的任意两方签署，则接受它”这样的规则——否则拒绝该交易。在这里，我们隐含地将公钥*pub*视为参与方的标识符，这在区块链协议中是常见的做法。

与链上多签不同，多签名协议生成单一签名；然后只需要验证一个签名，而不是多个签名。多签名脚本和智能合约代替处理几个签名并包含验证规则，而不是签署者端的协议。在两种情况下，验证都需要所有签署者的公钥。

多签名协议也不同于其他两种集体签名协议类型，你将在以下部分看到。在这两种协议中，结果是一个单一的签名，但不同之处在于如何以及从何创建：

**聚合签名协议**

+   像在多签名中一样，每个参与者都有自己的密钥对（公钥和私钥）。

+   不像在多签名中一样，参与者可以签署不同的消息，而不是相同的消息。一个参与者还可以签署多个消息。

+   像在多签名中一样，验证签名需要多个公钥（或其单个聚合版本，用于支持协议）。

**门限签名协议**

+   与多签名不同，参与者不使用自己的密钥。相反，他们有一个单一私钥的份额（也称为*碎片*），以便在协议执行期间没有单个参与者知道完整的密钥。

+   像在多签名中一样，参与者签署单个消息。

+   与多签名不同，验证只需要单个公钥。

现在我们已经定义了多签名，让我们看看它们在它们最显著的用例中是如何工作的：Schnorr 签名。

#### 施诺尔签名协议

数学家克劳斯-彼得·施诺尔于 1989 年创建了同名签名方案，并对其进行了专利申请，这阻碍了其广泛采用，直到 2008 年 EdDSA 方案（参见第十二章）优化了它以适应现代椭圆曲线。施诺尔的方案比 ECDSA 标准更简单，更容易转换为多签名方案。比特币支持施诺尔签名，这些签名在 2022 年作为更好的多签名协议支持引入。

> 注意

*我们将使用加法表示法（与 EdDSA 以及处理椭圆曲线时一样），而不是原始的乘法表示法（用于整数的乘法群中使用）。因此，与私钥* a *相关联的公钥* A *是椭圆曲线点* A *=* aG*，其中* G *是预定义的基点，而组元素是通过加法组合的点。这与在乘法表示法中的情况相反，那里我们会有* A *=* g^a *，其中组元素是相乘在一起的数字。*

##### 单签名 Schnorr 签名

在了解如何进行多方签名之前，我们先看看单方 Schnorr 签名是如何工作的。假设 Alice 有一个私钥 *a*，对应的公钥是 *A* = *aG*。这里的 *a* 是一个数字，或者说是一个标量，在给定的数字范围内（具体来说，是椭圆曲线定义的有限域，通常是模某些大质数的正整数，至少大约为 256 位），而 *G* 是曲线的固定基点。

为了签署一条消息 *M*，Alice 按以下步骤进行：

1.  选择一个秘密随机数 *r*，并计算点 *R* = *rG*。值 *r* 是一个 *nonce*，即一次性的私钥，*R* 是其公钥。

2.  计算 *h* = **H**(*R* || *A* || *M*)，这是你将“连接”到私钥 *a* 和一次性私钥 *r* 以签署 *M* 的值。我们不仅对消息进行哈希处理，而且通过非秘密值 *A* 和 *R* 分别将 *h* 绑定到签名者和 nonce 上。如果没有这些，不同的攻击将成为可能。

3.  计算 *s* = *r* + *ha*，并返回一对 (*R*, *s*) 作为签名。你可以把 *s* 看作是私钥和数据进行签名时的乘积，其中秘密 *r* 对结果进行掩码；如果没有这个，恢复私钥从签名中将变得很容易。

验证签名时，检查 *sG* 是否等于 *R* + **H**(*R* || *A* || *M*)*A*。这是因为从 *s* = *r* + *ha*，将 *r* + *ha* 代入 *sG*，你会得到：

![](img/pg308-1.jpg)

其中 *h* = **H**(*R* || *A* || *M*)，验证者必须根据消息*M*、公钥*A*和签名的*R*部分来计算该值。

##### Schnorr 多重签名

在多重签名中，我们不仅仅有一个签名者，而是多个签名者。为了简化，我们描述两位共同签名者的情况：见 Bob，他将与 Alice 共同签署消息。Bob 的私钥是*b*，他的公钥是*B* = *bG*。为了共同创建一个多重签名，Alice 和 Bob 可以按照以下步骤来签署消息*M*：

1.  Alice 选择一个 nonce *r*[A]，计算 *R*[A] = *r*[A]*G*，并将 *R*[A]发送给 Bob。

2.  Bob 选择一个 nonce *r*[B]，计算 *R*[B] = *r*[B]*G*，并将 *R*[B]发送给 Alice。

3.  他们计算 *R* = *R*[A] + *R*[B]，并设置 *h* = **H**(*R* || *A* || *B* || *M*)，这是 Alice 和 Bob 将用来生成其签名部分的值。*h*的特定值通过他们的公钥(*A*和*B*)与签名者绑定，并且仅通过 nonce *R*与当前的签名会话绑定，这个绑定只适用于由 nonce *R*定义的特定签名执行。

4.  Alice 计算 *s*[A] = *r*[A] + *ha*，并将其发送给 Bob。

5.  Bob 计算 *s*[B] = *r*[B] + *hb*，并将其发送给 Alice。

6.  他们一起计算 *R* = *R*[A] + *R*[B] 和 *s* = *s*[A] + *s*[B]，并返回 (*R*, *s*) 作为签名。

验证签名时，检查 *sG* 是否等于 *R* + *h*(*A + B*)。将 *s* 代入 *sG* 后，结果如下：

![](img/pg309-1.jpg)

请注意，验证者需要知道 *A* 和 *B*，而不仅仅是它们的和 *A* + *B*，因为他们需要这两个值来计算 **H**(*R* || *A* || *B* || *M*)。然而，如果 *h* 被定义为 **H**(*R* || *A* + *B* || *M*), 那么验证者就可以使用一个公钥 *A* + *B*，而无需知道签名是由两方发布的。我们称将多个公钥合并为一个的方式为 *密钥聚合*。这在有多个签名者的情况下尤其有用，可以减少哈希时数据的大小。

> 注意

*我描述了基本的 Schnorr 多重签名方案，适用于两方的情况，但该协议可以扩展到任意数量的公钥 *P1*, *P2*, …, *P[n]* 的情况。在定义中，替换 *A* + *B* 为 *P1* + *P2* + … + *P[n]*，将 *A* || *B* 替换为 *P1* || *P2* || … || *P[n]*，并将“发送给 Bob/Alice”替换为“发送给所有人”。你可以将类似的协议应用到 EdDSA 和 Ed25519，这些是 Schnorr 方案的变种。*

#### 事情可能出错的方式

Schnorr 多重签名协议相对简单，但在以下攻击场景中可能会失败。

##### 密钥取消攻击

在此攻击中，Bob 让签名验证者相信他与 Alice 一起签署了消息，而实际上 Alice 没有看到这条消息，也没有与 Bob 互动。攻击者可以在你期望 Alice 和 Bob 一起签署消息的场景中利用这一点——例如，在需要双方批准的交易中。在正常情况下，验证者会知道 Alice 的公钥 *A* 和 Bob 的公钥 *B*，并且 Bob 和 Alice 会知道彼此的公钥。

假设发生以下情况：Alice 将她的公钥 *A* 发送给所有人，包括 Bob，但 Bob 并没有分享他的公钥 *B*，而是将 *C* = *B* – *A* = (*b* – *a*)*G* 分享给验证者，并将 *B* 分享给 Alice。Bob 不知道与 *C* 对应的私钥，对于攻击来说并不重要。

Bob 必须使用他的私钥 *b* 来签署消息，就像单签名者的情况一样，但此时 *h* = **H**(*R* || *A* || *C* || *M*), 就像他在与 Alice 一起签名一样。他返回 (*R*, *s*) 作为签名，其中 *R* = *rG*（*r* 为他选择的值），*s* = *r* + *hb*。

在期望 Alice 和 Bob 签名的情况下，验证者检查 *sG* 是否等于 *R* + *h*(*A + C*), 这是正确的，因为 *A* + *C* = *A* + (*B* – *A*) = *B*。因此，Bob 可以伪造多重签名，而无需与 Alice 交互，也无需知道她的私钥。

实际上，你可以通过要求签名者证明他们知道私钥（例如，通过签署一条消息）来避免这种攻击。由于 Bob 不知道与 *C* 对应的私钥，他无法提供这种证明。如你在 MuSig 协议中看到的，你也可以在协议层面避免这种攻击。

该攻击可以扩展到任意数量的参与方，这种情境通常被称为 *流氓密钥攻击*。攻击者 Bob 在接收到所有其他方的公钥后，只需将他的公钥定义为 *B* – *X*，其中 *X* 是所有其他方公钥的总和。

##### 重复随机数

就像在 ECDSA 中一样，重复的随机数对 Schnorr 多重签名协议致命。假设 Alice 的伪随机生成器出现故障，她在协议的两次运行中生成了相同的秘密随机数 *r*[A]：她第一次发送 *s*[A] = *r*[A] + *ha* 给 Bob，第二次发送 *s*[A]*'* = *r*[A] + *h'a*，其中第一次的 *h* 和第二次的 *h'* 也依赖于 Bob 的随机性。这样，你得到 *r*[A] = *ha – s*[A] 和 *r*[A] = *h'a – s*[A]*'，这意味着 *ha – s*[A] = *h'a – s*[A]*'，或者等价地，

![](img/pg310-1.jpg)

通过此方法，你可以计算出 Alice 的私钥 *a* = (*s*[A] – *s*[A]*'*) / (*h – h'* )。

消除由随机性失败引起的安全风险的一种方法是去除随机性。例如，通过对消息和私钥进行哈希计算来生成随机数，像在 Ed25519 中那样，当只有一个签名者时是有效的。然而，在多重签名的情况下，设置 *r* 为 **H**(*a* || *M*) 是行不通的：如果 Alice 和 Bob 两次签署相同的消息，Alice 会计算第一次的 *s*[A] = *r*[A] + *ha* 和第二次的 *s*[A]*'* = *r*[A] + *h'a*，在这两种情况下，*r*[A] = **H**(*a* **||** *M*)，如果恶意的 Bob 发送了与 **H**(*b* **||** *M*) 不同的值，则 *h'* 会与 *h* 不同。在这种情况下，Bob——以及任何监听通信的人——都可以再次计算 *a* 为 (*s*[A] – *s*[A]*'*) / (*h – h'* )。

##### 并行执行的不安全性

当攻击者能够发起多个同时进行的签名协议时，Schnorr 多重签名协议是不安全的。这个攻击过程太复杂，无法在这里详细描述，但可以在以下研究文章中找到相关文献：*[`eprint.iacr.org/2018/417`](https://eprint.iacr.org/2018/417)* 和 *[`eprint.iacr.org/2020/945`](https://eprint.iacr.org/2020/945)*。

#### 更安全的 Schnorr 多重签名

为了避免密钥冲突攻击和重复随机数问题，研究人员开发了更先进的多重签名协议，特别是 MuSig 协议：MuSig、MuSig2 和 MuSig-DN，其中 *MuSig* 代表 *多重签名*，*DN* 代表 *确定性随机数*。MuSig 协议还支持密钥聚合，允许验证者仅使用一个由签名者的密钥衍生出的公钥来检查签名，从而聚合的密钥不会泄露签名者的数量或公钥。

让我们看看 MuSig 的主要技巧如何运作。如果我们处于最简单的情况，只有两个签名者，Alice 和 Bob，并且使用与前面章节相同的符号，那么 Alice 不再计算*s*[A] = *r*[A] + *ha*作为她的签名部分，而是计算*s*[A] = *r*[A] + *μ*[A]*ha*，从而将* ha*部分与* μ*[A]值相乘。她通过哈希参与者的公钥列表，再加上 Alice 的密钥，**H**(*A* || *B* || *A*)，来计算* μ*[A]（其中* μ*是希腊字母 mu）。同样，Bob 通过哈希公钥列表，再加上他的密钥，**H**(*A* || *B* || *B*)来计算* μ*[B]，从而计算*s*[B] = *r*[B] + *μ*[B]*hb*。

然后，Alice 计算*聚合公钥*为*X* = *μ*[A]*A* + *μ*[B]*B*，即公钥与各自* μ*值的乘积之和。消息的哈希值为*h* = **H**(*R* || *X* || *M*)，而不是脆弱版本的多重签名方案中支持密钥聚合的**H**(*R* || (*A* + *B*) || *M*)。

这个技巧之所以有效，是因为恶意的 Bob 不再能够伪造另一个“取消”Alice 的公钥* A*，就像他可以通过设置*C* = *B* – *A* 在密钥取消攻击中做到的那样。在方程式* X* = *μ*[A]*A* + *μ*[B]*B*中，Bob 必须找到一个新的* B*值，得出“正确”的* μ*系数，以从方程中移除* A*。但这现在是不可能的，因为该方程式对* A*和* B*是非线性的（线性通常意味着不安全——参见第二章）。

当签名者超过两个时，可以以类似的方式应用这个技巧，通过哈希公钥列表和签名者的密钥来计算* μ*系数，然后通过计算公钥乘以各自的* μ*值，将公钥聚合为一个单一的* X*。

> 注意

*有关 MuSig 协议的更多详情，以及 MuSig-DN 版本如何从消息中安全地推导出随机数，请参见* [`<wbr>bitcoinops<wbr>.org<wbr>/en<wbr>/topics<wbr>/musig<wbr>/`](https://bitcoinops.org/en/topics/musig/)。

### 聚合签名协议

*聚合签名*有多个签名者，每个签名者签署一条消息（每个签名者的消息可以不同）；然后将这些签名合并为一个单一的签名。通过这个签名、签名者的公钥和他们签署的消息，验证过程检查所有签名者是否都签署了各自的消息。由于只需要存储一个签名，而不是与签名者数量相等的签名，因此验证时间与消息的数量成正比。当所有签名者签署相同的消息时，验证速度可以和单一签名者的签名验证一样快，无论签名者有多少个。

聚合签名在以太坊中特别用于其共识层。在这种用例中，验证节点支持提议以改变系统状态（作为区块），并利用聚合签名来最小化签名存储空间和验证时间。它们使用 Boneh-Lynn-Shacham（BLS）签名方案，你将在本节中了解到，从 BLS 签名的魔力开始：密码学配对。

#### 配对

在椭圆曲线密码学中，*配对*是一种操作，它将两个来自两个椭圆曲线群（不一定相同）的点转换为有限域元素。两个椭圆曲线点*P*和*Q*之间的配对的标准表示法是*e*(*P*, *Q*)。在密码学中使用的配对具有称为*双线性*的属性，因此称为*双线性配对*，这意味着对于任何点*P*、*Q*和*R*，它们满足以下条件：

![](img/pg312-1.jpg)

在这里，将点*R*添加到操作数相当于将结果乘以*R*与另一个操作数之间的配对。因此，如果你将一个点加上它自身*n*次，也就是说，将其乘以一个数字*n*，那么你得到的是

![](img/pg312-2.jpg)

或者是*e*(*P*, *Q*)乘以它自身*n*次，这也等同于*e*(*P*, *nQ*)。

如果你有不同的点*P*[1]、*P*[2]、...、*P*[n]，你可以将输入值的加法转换为输出值的乘法：

![](img/pg312-3.jpg)

配对的内部工作原理超出了本书的范围。更多详情请参阅 Kristin Lauter 和 Michael Naehrig 的文章“密码学配对”（*[`<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2017<wbr>/1108`](https://eprint.iacr.org/2017/1108)*）以及 Nadia El Mrabet 和 Marc Joye 的书籍《基于配对的密码学指南》（Chapman and Hall/CRC, 2016）。

#### BLS 签名

2006 年，Dan Boneh，Ben Lynn 和 Hovav Shacham 在文章“从 Weil 配对获得的短签名”中提出了 BLS 签名。文章指出，该方案设计用于“由人类输入签名或通过低带宽信道发送签名的系统”。BLS 签名后来被用于高度自动化的系统，这些系统通过后续论文描述的一种特性受益匪浅：签名和公钥的聚合。

> 注意

*不要将 BLS 签名与 BLS（Barreto-Lynn-Scott）曲线混淆，这两者共同的作者是（Lynn）。BLS 曲线是设计成配对友好的椭圆曲线，允许安全高效的配对操作。事实上，BLS 签名通常使用 BLS 曲线上的点。例如，以太坊的 BLS 签名依赖于曲线 BLS12-381。*

##### 单签名签名与验证

在 BLS 签名中，爱丽丝的私钥是标量数值*a*，她的公钥是*A* = *aG*，其中*G*是预定义的基点。要对消息*M*进行签名，她首先计算*H* = **H**(*M*)，其中哈希函数返回的是一个曲线点，而不是比特串或标量——*H*符号遵循一般惯例，将点表示为大写字母。签名是*S* = *aH*。这看起来比 Schnorr 或 ECDSA 签名要简单得多：只需对消息进行哈希，并将结果与私钥相乘。

要验证 BLS 签名，计算两个配对操作：

+   *e*(*A*, *H*)是公钥和哈希消息之间的配对（注意*A* = *aG*）

+   *e*(*G*, *S*)是基点和签名之间的配对（注意*S* = *aH*）

由于配对的双线性特性，这些值应该相等：

![](img/pg313-1.jpg)

如果等式成立，则接受该签名；否则，拒绝该签名。

忽略配对操作的复杂性，这种基于配对的签名是最简单的签名方案。

##### 来自多个签名者的聚合签名

让我们进一步利用 BLS 签名和双线性配对的神奇，考虑这样一个场景：*n*个签名者，私钥为*k*[1]、*k*[2]、…、*k*n，公钥为*P*[1]、*P*[2]、…、*P*n，签署*n*条消息*M*[1]、*M*[2]、…、*M*n，并生成签名*S*[1]、*S*[2]、…、*S*n。注意，*H*i = **H**(*M*i)是第*i*条消息的哈希。

你可以通过将多个签名*S*i = *k*i*H*i 相加，聚合成一个签名*S* = *S*[1] + *S*[2] + . . . + *S*n。观察到，在验证单个签名时，计算*e*(*G*, *S*)会因双线性特性而得到以下结果：

![](img/pg313-2.jpg)

记住，配对满足*e*(*nP*, *Q*) = *e*(*P*, *nQ*)。因此，你可以通过将乘法因子*k*i“移到”配对的左操作数，来将每个*e*(*G*, *S*i)项替换为*e*(*P*i, *H*i)：第一个操作数将是*k*i*G* = *P*i，而不是*G*，第二个操作数将是*H*i，而不是*S*i = *k*i*H*i。

将多个签名者在多个消息上的多个签名聚合成一个单一签名后，你可以通过签名者的公钥和签名消息来验证聚合签名。验证只需检查*e*(*G*, *S*)与所有配对乘积*e*(*P*i, *H*i)之间的相等性。需要计算 1 + *n*个配对，而不是如果没有聚合签名时需要计算的 2*n*个配对——在这种情况下，签名占用了聚合签名的*n*倍内存。

让我们考虑一个同时聚合签名和公钥的场景。

##### 聚合公钥

假设所有签名者都对相同的消息 *M* 进行签名，并且你将所有公钥聚合成一个：*P* = *P*[1] + *P*[2] + . . . + *P*n。注意，*k*[1]、*k*[2]、. . . 、*k*n 仍然代表各自的私钥，*H* = **H**(*M*) 是消息的哈希值。给定有效的签名 *S*i，你得到以下等式：

![](img/pg314-1.jpg)

因此，你仅使用两个配对操作 *e*(*P*, *H*) 和 *e*(*G*, *S*) 来验证 *n* 方对相同消息的签名。这是非常高效的，因为它使得签名验证基本上不依赖于参与方的数量，你可以高效地添加点，而配对运算的计算成本较高。除了计算效率外，聚合密钥和签名还能节省内存。

#### 事情如何出错

与许多椭圆曲线密码学方案一样，BLS 签名在确保安全性时应避免无效密钥和弱参数。与之前的协议类似，BLS 签名也可能受到密钥取消攻击的威胁。让我们来探讨一下具体细节。

##### 无效密钥

BLS 签名在一份互联网草案中有明确规定，这是 IETF 的一份工作文档，地址为 *[`<wbr>github<wbr>.com<wbr>/cfrg<wbr>/draft<wbr>-irtf<wbr>-cfrg<wbr>-bls<wbr>-signature`](https://github.com/cfrg/draft-irtf-cfrg-bls-signature)*。该文档指定了包括密钥生成（算法 KeyGen）、签名（CoreSign）、验证（CoreVerify）和密钥验证（KeyValidate）在内的核心操作。给定公钥，后者确保公钥的有效性，即它“表示一个有效的非单位点，且在正确的子群中。”

密钥验证可以防止使用弱的私钥/公钥对，因为这类密钥的签名更容易伪造。例如，考虑一个简单的情况，零秘密密钥 *a* = 0\. 由此可得，任何消息 *M* 的签名为 0 × **H**(*M*) = 0\. 因此，伪造任何消息的签名变得极其简单。在这种情况下，公钥则为 0 × *G* = *O*，即无穷远点。如果密钥验证拒绝等于 *O* 的公钥，它就能确保秘密密钥不是零。

一个不那么简单的情况是，当公钥作为椭圆曲线点时，其值使得伪造签名更容易——也就是说，可以在不知道私钥的情况下创建有效的签名。并非所有的椭圆曲线上的点都同样安全——特别是属于小子群而非主子群的点。如果公钥点属于这样的小子群，那么可能的有效签名会少得多，从而使伪造签名变得更加容易。同样，如果提供给验证函数的公钥不属于椭圆曲线，那么有效签名也容易被伪造。

因此，使用上述规范中的 KeyValidate 算法检查公钥是否有效是至关重要的，正如 清单 15-1 中所复制的那样。

```
Inputs:
- PK, a public key in the format output by SkToPk.

Outputs:
- result, either VALID or INVALID

Procedure:
1\. xP = pubkey_to_point(PK)
2\. If xP is INVALID, return INVALID
3\. If xP is the identity element, return INVALID
4\. If pubkey_subgroup_check(xP) is INVALID, return INVALID
5\. return VALID
```

清单 15-1：该 KeyValidate 算法确保 BLS 公钥是有效的。

如果你实现 BLS 签名，确保你的代码在验证公钥和签名时执行 BLS 规范中描述的所有检查。

##### 密钥取消攻击

在其基本形式中，带有聚合公钥的 BLS 聚合签名会受到与 Schnorr 签名相同类型的密钥取消攻击：如果攻击者知道前 *n* - 1 个签名者的公钥 *P*[1], *P*[2], . . . , *P*n – [1]，他们可以声称自己的公钥是

![](img/pg315-1.jpg)

其中 *X* 是他们知道私钥 *x* 的公钥，满足 *X* = *xG*。当攻击者提供一个由 *x* 创建的签名时，毫不怀疑的用户使用公钥 *P*[1] + *P*[2] + . . . + *P*n 验证消息签名，这等于 *X*。攻击者可以单方面代表假定的签名者集合签署一条消息。

为了防止这种攻击，用户可以通过签名消息来证明他们知道其公钥的私钥。由于攻击者不知道 *P*n 的私钥，他们会未能通过此测试。

另一种缓解方法是修改聚合签名方案，使返回的签名不仅仅是签名的和 *S* = *S*[1] + *S*[2] + . . . + *S*n，而是通过从公钥派生的系数和，如下所示

![](img/pg315-2.jpg)

其中 *t*i = **H**(*P*i || *P*[1] || *P*[2] || . . . || *P*n)，对于 *i* = 1, 2, . . . , *n*。然后用于验证签名的聚合公钥是 *P* = *t*[1]*P*[1] + *t*[2]*P*[2] + . . . + *t*n*P*n。你可以通过检查 *e*(*P*, **H**(*M*)) 是否仍然等于 *e*(*G*, *S*) 来验证这个技巧。

### 门限签名协议

*门限签名*与多重签名和聚合签名不同——后者要求所有参与签名协议的成员都必须有自己的公钥和私钥——其区别在于，门限签名有一个单一的私钥*k*和一个单一的公钥*P*，并且有*n*个参与者，每个参与者拥有私钥*k*的一个独特的*份额* *k*i，其中定义了一个参数*t*（*门限*），使得*t* < *n*，并且：

+   *t* + 1 个签名者可以共同签署一个有效的消息签名，使用公钥*P*进行验证，从而确保没有任何签名者了解私钥*k*。这是通过运行一个协议来实现的，协议使用每个签名者的*k*i 份额和需要签名的消息，在过程中永远不暴露私钥给任何一方。

+   少于*t*个签名者无法创建签名，因此也无法确定私钥*k*。

已签发的签名看起来像是一个普通的单签名签名，并且以这种方式进行验证。

门限签名是一种特定类型的*多方计算（MPC）*，这是一个协议类，其中*n*个参与者计算某个函数*f*(*x*[1], *x*[2], . . . , *x*n)的输出，其中每个参与者知道自己的输入*x*i 并学习函数的输出，但不会知道其他参与者的*x*i 输入。对于门限签名而言，*x*i 是私钥的份额，输出是签名。我将在“秘密共享技术”部分的第 319 页详细说明什么是份额。

门限签名的好处是“隐藏”了共同签名者的数量和身份，因为验证者只看到来自单一私钥的签名。尽管一些多重签名和聚合签名方案也具有这个特性，但门限签名更适合加密资产托管的使用场景，因为只有一个私钥和一个公钥；你可以直接将门限签名应用于分配任何地址的控制权。

#### 使用案例

门限签名被广泛应用于加密货币和数字资产管理，用于在多个系统或各方之间分配对某个地址的控制权。它们可以用于在服务提供商和用户设备之间共享账户控制权：每个方拥有一个密钥份额，必须共同运行协议来签署交易，从而支出资金。这种设置确保了攻击者无法单独授权交易，即使他们突破了用户设备并获取了密钥份额。同样，服务提供商也无法在没有用户同意的情况下发起交易。然而，可靠地实现这一模型面临着挑战，尤其是在密钥管理方面（密钥生成、密钥轮换、备份等）。

一个组织还可以使用门限签名将资金的托管分布在多个系统之间，例如不同的设备类型、数据中心、操作系统和软件组件。此方法特别适用于冷钱包和包含大量资产的账户。仅依赖门限签名是不够的，因为全面的安全措施和控制至关重要。例如，必须正确分离对 IT 组件的访问，确保不同的个人或 IT 服务提供商只能访问不同的系统（从而获得不同的份额）。此外，交易的发起和批准必须受到严格的控制，并具有审计跟踪。

#### 安全模型

与所有密码学协议一样，我们需要定义门限签名方案安全的含义。这样的安全模型包括安全目标（攻击者应该难以做的事）和攻击者模型（对攻击者能力的假设）。让我们深入探讨这两个特性。

##### 安全目标

门限签名的主要安全目标与单一签名的安全目标相同：攻击者必须无法伪造有效签名，这意味着他们必须无法确定私钥。这还意味着协议必须确保*输入隐私*：各方持有的密钥份额不应泄漏给任何其他方。最后，协议必须确保*正确性*：协议计算出的签名必须有效，并且所有参与者在协议执行过程中都能够访问该签名。

##### 攻击者模型

门限签名没有统一的安全模型；相反，攻击者是根据多个维度来定义的。所有攻击场景中的共同威胁是假设攻击者可以主动攻击网络通信——捕获、修改和注入消息。通过使用安全通道来建立参与方之间的身份验证和加密通信，可以防止此类攻击。协议设计者还假设通信是可靠的，即所有传输的消息应按发送的顺序接收。

门限签名的攻击者模型考虑了*参与者的腐化*——即攻击者妥协其系统，获取其秘密，并基本上让他们做攻击者想做的事。该模型假设攻击者无法腐化超过*t*个参与者；否则，攻击者就能伪造签名，这符合门限签名功能的定义。

让我们来审视当攻击者能够腐化参与者时需要考虑的参数。

首先，我们通过攻击者可以破坏的*方的数量*来描述攻击者。存在两类阈值签名，每类都由可以被攻破的恶意参与者的最大数量定义，而不破坏协议的安全性：

**诚实的多数**在此模型下，攻击者仅限于破坏少于一半的密钥共享方。因此，阈值 *t* 必须满足 *t* < *n*/2。根据定义，具有参数（*t*, *n*）的阈值签名协议即使在 *t* 个参与方被破坏的情况下也必须是安全的。在诚实多数假设下设计的协议通常更高效，但它们无法容纳任意值的 *t*。例如，具有参数（4，5）的协议在此模型下是不可行的，因为它要求容忍最多四个被破坏的方。

**不诚实的多数**该模型允许协议支持从 1 到 *n* - 1 的任何 *t* 值。它使得创建协议成为可能，在这种协议中，*n* 个参与方中，除了一个，其他的都可能被攻破，但恶意方仍然无法伪造签名或恢复私钥。该模型在阈值值方面提供了更多的灵活性，但通常需要更复杂和更强大的安全机制。

我们还通过攻击者在破坏一个方并获取其秘密值（包括密钥份额）后的行为来描述攻击者。有两种攻击者模型定义了这一点：

**被动或诚实但好奇**他们从被破坏的方那里获取信息，但不能强迫其偏离协议。这种模型描述的是“只读”破坏，其中攻击者获得系统内存的快照，包括存储内存和易失性内存（RAM、处理器寄存器）。

**主动或恶意**各方可以任意偏离规定的协议。这种模型描述的是系统完全被攻击者攻破或被恶意内部人员（例如操作员、管理员或云服务提供商）控制的情况。

因此，一个对主动攻击者安全的协议总是对被动攻击者安全，但反之则不然。

攻击者有两种选择破坏哪些方的方式，这由以下破坏类型模型定义：

**静态破坏**攻击者必须在协议开始之前选择哪些参与方进行破坏。

**自适应破坏**攻击者可以等到协议开始后再选择破坏哪些参与方，并在协议过程中了解他们的操作历史。

一个对静态破坏安全的协议总是对自适应破坏安全，但反之则不然。然而，有一些技术可以将一个协议从对静态破坏安全转化为对自适应破坏安全。

#### 秘密共享技术

阈值签名的一个关键组成部分是 *秘密共享* 协议，或者是将秘密分割成多个部分（*共享*）并分发给不同方的技术，这样各方可以共同重建初始的秘密。秘密共享协议可以特别用于创建私钥的备份，其中不同方在不同位置存储不同的共享。

##### 加法共享

分享你认为是数字的秘密的最简单方法是通过 *加法共享*：给定一个数字 *s*，你将其分享为 *n* 个值 *s*[1]、*s*[2]、…、*s*n，使得 *s*[1] + *s*[2] + … + *s*n = *s*。例如，如果你使用模 100 的数字，可以将数字 *s* = 47 随机加法共享成四个份额，如下所示：随机选择三个介于 0 和 99 之间的数字，假设 *s*[1] = 12、*s*[2] = 94、*s*[3] = 80，然后设定 *s*[4] = *s* – *s*[1] – *s*[2] – *s*[3] = 61。 （注意，减法是按模 100 计算的，因此 –1 = 99，–2 = 98，依此类推。）

这种方法非常简单，但需要使用所有的共享来恢复原始秘密。

##### 阈值共享

阈值共享更接近阈值签名的功能：给定参数 *n* 和 *t* < *n* 以及秘密 *s*，它生成共享，使得你可以通过任意 *t* 个共享来恢复秘密，*n* 个共享中任意选取。

最著名的阈值共享方法是 *Shamir 的秘密共享*，它利用多项式的以下特性：给定一个次数为 *t* 的多项式，形式为

![](img/pg319-1.jpg)

你只需要对 *f*(*x*) 在 *t* + 1 个不同的 *x* 值上进行 *t* + 1 次评估，就可以确定所有的 *a*i 系数，这些系数是固定值。

要从这个性质创建阈值秘密共享，设定 *a*[0] = *s*，即秘密。然后随机选择 *a*[1] 到 *a*t 的值，并计算 *f*(*x*) 在 *n* 个不同的 *x* 值上，这些将是 *n* 个秘密的共享。

从 *f*(*x*) 值重新计算系数是一种叫做 *拉格朗日插值* 的技术，这项技术源自 18 世纪的意大利数学家，他开发了一种通用方法来确定给定曲线上多个点的曲线方程。实际上，你可以从几何角度来看这个问题。如果方程的次数是 1（形式为 *a*[0] + *a*[1]*x*），那么它是直线方程，知道直线上的两个点足以唯一确定这条直线。同样，如果方程的次数是 2（形式为 *a*[0] + *a*[1]*x* + *a*[2]*x*²），那么曲线是抛物线，可以通过三个点来确定其方程。

我们有时会发现 Shamir 秘密共享的实现中定义了一个函数**拉格朗日**()，该函数计算插值并返回*a*[0]系数，即共享秘密。如果你有*f*(*x*)值要组合以恢复秘密，你可以定义操作**拉格朗日**(*s*[1], *s*[2], . . . , *s*t)，返回共享秘密*s*。这适用于任何*t*个不同共享的组合，而不一定是前*t*个共享。**拉格朗日**()操作的细节对于本书来说有些过于技术性，但你可以将其实现为一系列基本的加法、乘法和求逆运算。

#### 平凡情况

最简单的门限签名类型之一使用了 BLS 签名，如前文在聚合签名的上下文中所提到的。回顾一下，给定一个私钥*k*，BLS 签名通过将*k*与曲线点*H* = **H**(*M*)相乘来计算签名。你可以使用加法共享创建一个门限方案，其参数为(*n* – 1, *n*)。例如，如果*n* = 3，将密钥分为三个共享，使得*k*[1] + *k*[2] + *k*[3] = *k*。然后，每个参与方通过将各自的共享*k*i 与*H*相乘来计算他们的签名部分。将三个共享相加后，得到如下结果：

![](img/pg320-1.jpg)

通过加法组合三个共享，可以得到一个有效的签名，即使没有任何一方知道*k*。各方还可以通过相加各自的共享来恢复*k*，但如果共享是随机生成的，两个参与方共享相加不会泄露任何关于*k*的信息。

要创建一个具有任意*t*和*n*的门限签名方案，使用 Shamir 秘密共享技术，并利用**拉格朗日**()运算的线性特性：你生成如“门限共享”部分中描述的密钥共享*k*i，并按照以下方式计算签名：

![](img/pg320-2.jpg)

同样，你可以用密钥*k*得到一个有效的签名。

#### 简单情况

你现在将在门限设置中计算 Schnorr 签名，这比使用 BLS 签名更为技术性。回顾一下，Schnorr 方案通过*s* = *r* + *ha*来计算签名，其中*h* = **H**(*R* || *A* || *M*)，*r*是每个签名的随机 nonce，*a*是签名者的私钥。签名还包括*R* = *rG*，即公共 nonce 值。由于它对秘密值的线性关系，这相对容易转化为一个门限签名方案：注意到秘密*r*与秘密*a*相加，乘以哈希*h*（哈希*h*不是秘密）。

想象最简单的情况：两个签名者，私钥*k* = *a* + *b*的加法共享，其中*a*和*b*是两个签名者的各自密钥份额。为了签名，两个参与方可以生成秘密随机数*r*[A] 和 *r*[B]*，其相应的公钥值为*R*[A] = *r*[A]*G* 和 *R*[B] = *r*[B]*G*。参与方然后可以交换这些值并计算公钥随机数*R* = *R*[A] + *R*[B]*，该值将成为签名的一部分。*R*即是你从私有值*r* = *r*[A] + *r*[B]中派生出来的公共值，因为你有：

![](img/pg320-3.jpg)

接下来，参与方计算他们的签名份额：*s*[A] = *r*[A] + *ha* 和 *s*[B] = *r*[B] + *hb*，然后将其加起来得到：

![](img/pg321-1.jpg)

因此，你得到*r* + *hk*，一个来自密钥*k*的签名，尽管参与方只在计算中使用了加法共享的*a*和*b*。要获得任意参数*t*和*n*的门限构造，可以使用 Shamir 的秘密共享，而不是加法共享。

之前的构造不足以满足门限签名方案的所有安全要求。特别是，除非参与方在协议的预备阶段*承诺*他们的随机数，否则它容易受到密钥撤销攻击——例如，通过发送其随机数的哈希值。它还存在一些微妙的漏洞，这些漏洞已通过协议“灵活轮次优化 Schnorr 门限（FROST）签名”得以解决，该协议由密码学家 Chelsea Komlo 和 Ian Goldberg 于 2020 年设计，并在*[`<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2020<wbr>/852`](https://eprint.iacr.org/2020/852)*中有文档说明。

> 注意

*第十二章中的 EdDSA 签名协议类似于 Schnorr 签名，但它是将消息的哈希值作为随机的、任意的值来计算 nonce，而不是一个随机数值。这使得根据原始 EdDSA 规范构建符合要求的门限签名协议变得复杂。*

#### 复杂情况

在门限设置中，最难运行的签名方案也是最常见的。ECDSA 签名算法（参见第十二章）比 Schnorr 签名和 EdDSA 更复杂，因为它涉及除法。给定消息哈希*h* = **H**(*M*)，签名者选择一个随机数*k*，根据点*kG*的坐标计算数字*r*，并将签名计算为*s* = (*h* + *ra*) / *k*，其中*a*是签名者的私钥。

高效且安全的 ECDSA 门限签名仍然是密码学家们面临的一个具有挑战性的研究课题。第一个实际协议出现在 2010 年代末期，受到加密货币使用案例的推动——当时，大多数领先的加密货币，包括比特币和以太坊，只支持 ECDSA 作为交易签名方案。

密码学家们设计了几种方法来构建 ECDSA 阈值签名协议。例如，Yehuda Lindell 在 2017 年提出的“快速安全的双方 ECDSA 签名” (*[`<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2017<wbr>/552`](https://eprint.iacr.org/2017/552)*) 需要一个承诺方案、同态加密方案和零知识证明系统。这些协议的复杂性使得它们的理解、实现和安全分析变得困难，从而导致了已部署系统中的一些安全漏洞。

#### 事物如何出错

阈值签名协议中的具体安全问题通常非常复杂，涉及密码学构造的细节，而这些内容我在本书中没有涵盖。因此，我将讨论影响阈值签名实际部署的各种问题，而不是具体问题，这些问题来自广泛使用的开源软件到商业解决方案。

##### 论文与代码

当工程师们需要根据研究论文实现一个阈值签名协议时，他们会遇到挑战。这些论文主要面向密码学研究人员，通常编辑质量不一，内容复杂、数学重，并且相当新颖。正因为如此，这些协议可能在实验中并没有达到预期的安全性。这些因素导致了一系列现实世界中的安全问题，可以分为四个主要领域：

**不安全的协议** 如果协议在纸面上不安全，那么在实现过程中也不会更安全。常见的问题包括忽略了边缘情况或在接收来自其他方的输入时缺乏充分的验证。例如，一些协议未能验证加密后的数字是否在预期范围内，从而导致实际攻击的发生。

**描述不完整** 研究论文不是技术规格，而是为学术读者编写的，因此通常缺乏像网络和编码这样的实际实现细节。一个显著的例子是 TSSHOCK 攻击，它利用了阈值签名中的哈希函数输入元素中的模糊编码，正如在“领域分离失败导致的冲突”一文中描述的那样，见第 305 页。

**实现不完整** 阈值签名协议的复杂性，包括其众多子组件和详细要求，可能导致一些安全验证被忽视，尤其是当这些验证仅在附录中提及时。一个例子是，当一个协议要求对一个数字 *N* = *pq*（用于 Paillier 加密）进行零知识证明，验证其为两个足够大的素数的乘积时，但在实现中忽略了这个验证，从而允许不安全的 *N* 值。

**不安全的组件选择** 协议的描述通常不会说“使用哈希函数 BLAKE3”或“使用 256 位椭圆曲线 nistp256”；相反，它们会说“使用提供所需安全级别的哈希函数和椭圆曲线”。因此，选择合适的原语并安全地使用它们的编程接口是由实现者来决定的。例如，使用 1,024 位的 RSA 模数并不足以确保 128 位的安全性。

此外，当实现者故意修改协议时，也会产生风险，可能是为了提高效率或适应特定的使用案例。这通常不会有好的结果。有关阈值签名攻击的示例，请参阅 Dmytro Tymokhanov 和 Omer Shlomovits 的论文“Alpha-Rays: Key Extraction Attacks on Threshold ECDSA Implementations”（*[`<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2021<wbr>/1621`](https://eprint.iacr.org/2021/1621)）以及 Nikolaos Makriyannis、Oren Yomtov 和 Arik Galansky 的论文“Practical Key-Extraction Attacks in Leading MPC Wallets”（*[`<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2023<wbr>/1234`](https://eprint.iacr.org/2023/1234)*）。

##### 密钥管理方面

一位朋友曾经说过：“每 10 行加密代码，就有 1,500 行密钥管理代码”，这强调了密钥管理过程的关键性和复杂性，包括密钥创建、存储、备份和恢复。尽管这些方面在专注于理论方面的学术论文中可能被忽视，但它们在实际应用中至关重要。在生产环境中实现阈值签名的工程师和安全专家必须优先考虑这些密钥管理问题——即使是最强大的阈值签名协议也无法替代全面的密钥管理实践。

让我们回顾一下一个组织在使用阈值签名来保护大量加密货币资产时的主要密钥管理考虑因素：

**密钥生成** 无论是使用分布式密钥生成还是集中式生成，必须确保在密钥生成期间或之后，秘密值不会暴露给未经授权的系统或方。这种保证通常通过严格的流程提供，如密钥仪式、确保供应链的完整性和审计跟踪，以证明密钥已正确生成。不要允许其他方（如云服务提供商）代表你生成密钥，或随时有能力读取它们。

**密钥存储** 将密钥作为多个份额存储而不是单一值，并不会减少对安全存储的必要性。在不同平台上保护多个秘密可能比在统一平台上保护单一秘密更加具有挑战性。密钥份额必须存储在某种类型的安全内存中，防止未经授权的访问、篡改和物理攻击。

**密钥备份和恢复** 实施一种阈值方案，例如要求六个共享中的三个签名以执行交易，可以防止密钥共享丢失或系统停机。然而，这并不意味着不再需要密钥备份，你仍然需要将备份作为阈值共享进行保存。至关重要的是，将这些备份共享的访问权限分配给不同的方。此外，定期验证备份的可靠性，以确保它们未被破坏，并且在需要时能够有效地用来重建密钥，例如在灾难恢复演练中。

### 零知识证明

*零知识证明（ZKP）*是密码学家最强大的工具之一。这些协议涉及两个参与方，一个是*证明者*，另一个是*验证者*，其中证明者向验证者证明某个事情是真实的，但并不会透露任何有关原因的信息。例如，证明者可以证明他们知道某个困难计算问题的解决方案，但并不透露该解决方案。你可能会为任何**NP**-完全问题创建一个 ZKP，以证明你知道解决方案，但不透露它。

更一般地说，ZKP 用于证明某个陈述，例如“这个密文中加密的数字在 100 和 200 之间”或“对于给定的明文*P*和密文*C*，我知道一个秘密密钥*K*，使得*C* = **AES**(*K*, *P*)。”

对于零知识证明的非技术性介绍，我推荐密码学家 Amit Sahai 的的视频“计算机科学家用 5 个难度级别解释一个概念”（* [`<wbr>youtu<wbr>.be<wbr>/fOGdb1CTu5c`](https://youtu.be/fOGdb1CTu5c)*）。如需数学细节，请参阅*[`<wbr>github<wbr>.com<wbr>/matter<wbr>-labs<wbr>/awesome<wbr>-zero<wbr>-knowledge<wbr>-proofs`](https://github.com/matter-labs/awesome-zero-knowledge-proofs)*上的链接。

> 注意

*零知识证明*这一术语是对研究文献中更准确术语的简化。例如，许多“零知识证明”协议实际上是*零知识论证*。研究人员将“证明”一词保留给无条件安全性，并将“论证”一词用于计算安全性。此外，“见证人”一词指的是使证明者能够证明其陈述的秘密，作为*秘密*或*密钥*的广义化，因为其涵盖范围更广。

#### 安全模型

对于 ZKP 协议来说，什么才算安全？攻击者是证明者还是验证者？他们如何攻击该协议？让我们通过检查安全目标和攻击者模型来回答这些问题。

##### 安全目标

一个安全的零知识证明（ZKP）必须满足以下概念：

**完整性** 如果证明者遵循协议并使用正确的密钥，诚实的验证者会确信陈述的真实性。换句话说，协议总是有效的。

**健全性** 如果证明者不知道秘密，他们无法说服诚实的验证者一个虚假的陈述（除非是极小的概率）。换句话说，证明者不能作弊。

**零知识** 验证者除了知道陈述为真之外，什么也不会学到。具体来说，他们不能学到任何关于证明者秘密的信息。

“验证者将被说服相信陈述的真实性”这一概念由协议满足这三项属性的相互一致性保证——即如果陈述为假（例如，如果他们不知道自己声称知道的解决方案），证明者将无法完成协议。

##### 攻击者模型

双方都有可能是攻击者，分别尝试妥协健全性和零知识属性：

**恶意证明者** 想要证明一个虚假的陈述——例如，错误地说服验证者他们知道某个难题的解决方案。这样的攻击者可能会偏离协议，试图欺骗验证者。实际上，这对像机密程序执行这样的应用中的零知识证明（ZKP）构成了最大的威胁。

**恶意验证者** 想要提取关于秘密的信息（即 *证人*），从而破坏零知识特性。攻击者模型区分了 *被动* 验证者攻击者（诚实但好奇）和 *主动* 验证者攻击者（可以任意偏离协议）。

请注意，恶意验证者可能通过声称他们不相信陈述的真实性来挑战完整性。实际上，这不是问题，因为证明者可以为其他（诚实的）验证者重复证明协议，从而揭露撒谎的验证者。

#### Schnorr 协议

Claus-Peter Schnorr，发明了同名签名方案的他，也描述了一种类似的构造，它是零知识的 *离散对数知识证明*。这构成了 Schnorr 和 EdDSA 签名的基础，以及许多更复杂的零知识证明的基础。

Schnorr 协议通过三个步骤证明 *a* 的知识，即 *aG* = *A*——也就是 *A* 相对于生成元 *G* 的离散对数：

1.  *承诺*：证明者选择一个随机数 *r* 并发送 *R* = *rG*。

2.  *挑战*：验证者发送一个随机数 *c*。

3.  *响应*：证明者发送 *s* = *r* + *ca*，且当且仅当 *sG* = *R + cA* 时，验证者接受。

> 注意

*这种具有承诺、挑战和响应的三步协议称为* sigma 协议，以大写希腊字母 Sigma（Σ）的形状命名。*

*Schnorr 协议* 的 **完整性** 最容易验证：如果 *a* 满足 *aG* = *A*，你将得到

![](img/pg325-1.jpg)

这是证明者的验证条件。

为了证明协议的*健全性*——即证明者必须知道 *a*——假设证明者在协议的两次运行中使用相同的 *r*。验证者将得到两个回应，*s*[1] = *r* + *c*[1]*a* 和 *s*[2] = *r* + *c*[2]*a*，分别对应于两个不同的挑战者 *c*[1] 和 *c*[2]。现在他们可以计算

![](img/pg326-1.jpg)

然后将结果除以 (*c*[1] - *c*[2]) 来得到 *a*。由于检查 *sG* 是否等于 *R* + *cA* 能确保 *s* = *r* + *ca*，因此可以推导出证明者在正确执行此协议时必须知道 *a*。这种逻辑推理被称为*知识提取器*，它是证明 ZKP（零知识证明）健全性的主要技术。

该协议也可以通过一种叫做*模拟器*的技术来证明其为零知识的。模拟器是一种算法，它生成的消息（或*通信记录*）与真实的零知识证明执行结果无法区分。然而，与真实的证明者不同，模拟器不一定知道正在证明的秘密（或见证）。尽管如此，它生成的消息在证明系统的上下文中依然看起来有效且具有说服力。

在 Schnorr 协议中，模拟器从后向前工作，首先选择一个随机回应 *s*，以证明一个真实的 *s* 将会和纯随机的 *s* “一样随机”。然后它挑选一个随机的挑战 *c*，并计算原始的承诺 *R* = *sG* - *cA*。随后，协议的零知识证明展示了这三个值与协议的真实执行结果无法区分，但不需要知道秘密 *a*。（注意，在 Schnorr 的情况下，你必须假设验证者遵循协议并选择一个随机的 *c*。）

#### 非交互式证明

Schnorr 协议是*交互式*的：证明者发送第一个消息，验证者回应一个挑战，证明者再发送回应——双方在三个回合的消息交换中互动。那么，如果验证者无法发送消息，只想接收一个能够说服他们的单一消息，该如何创建这种*非交互式*证明呢？

让我们再看一遍 Schnorr 协议，其中验证者发送一个随机挑战 *c*，这个值对证明者来说必须是不可预测的。如果证明者在发送 *R* 之前知道 *c*，他们就可以作弊，如下所示：给定 *c*，选择任意一个 *s* 值，然后计算 *R* = *sG* - *cA*；接着将这个 *R* 发送给验证者，并将 *s* 作为对 *c* 的回应发送。验证成功，但证明者并没有使用秘密值 *a*。

如何在不与验证者交互的情况下使*c*对证明者不可预测？技巧是通过哈希函数从*R*派生出*c*，这阻止了证明者找到满足 *sG* = *R* + *cA* 的一对(*R*, *c*)，因为哈希函数的伪随机行为。

为了使用 Schnorr 协议生成一个*非交互式零知识（NIZK）*知识证明，证明者按以下步骤进行：

1. *承诺*：证明者选择一个随机数 *r* 并计算 *R* = *rG*。

2. *挑战*：证明者计算 *c* = **H**(*G* || *R* || *A*)；你必须包括值 *G* 和 *A*，以将 *c* 的生成绑定到生成器参数 *G* 和证明者的公钥 *A*。

3. *响应*：证明者计算 *s* = *r* + *ca* 并生成证明，作为 *R* 和 *s* 的编码。

为了验证从证明者那里收到的证明(*R*, *s*)，并使用公钥*A*，验证者重新计算挑战*c* = **H**(*G* || *R* || *A*)，并检查是否满足 *sG* = *R* + *cA*。

哈希函数协议数据中的技巧，替代了验证者生成的挑战，它由*Fiat–Shamir 变换*正式化，这是一种将交互式协议转化为非交互式协议的通用技术。为了使该变换适用，验证者的随机挑战必须与证明者的消息独立，并且是公开的（非保密）值。

#### zkSNARKs

让我们讨论一种因其强大和高效性而在区块链应用中得到广泛应用的零知识证明。例如，zkSNARK 是 Zcash 机密交易平台的基石：在 Zcash 中，zkSNARK 证明某个金额已从一个账户扣除并已存入另一个账户，而不透露账户金额，也不导致计算或存储量过大。

*zkSNARK*是一种非交互式知识证明，它提供了零知识(*zk*)特性，其中*SNARK*代表以下含义：

**简洁** 证明相较于声明和秘密的大小非常小。它的大小可能与声明大小的对数相似，甚至是*常量大小*——无论声明的大小如何，证明的大小始终相同。

**非交互式** A SNARK 是一个非交互式知识论证，通常使用 Fiat–Shamir 变换将交互式协议转化为非交互式协议。它不需要验证者向证明者发送消息。

**论证** 知识的*论证*是一种计算上安全的证明，但其安全性是有条件的。换句话说，它不会抵抗拥有无限计算能力的攻击者，这通常是可以接受的限制。

**知识** A SNARK 提供了完整性和健壮性，作为一种知识论证。

此外，证明和验证 zkSNARK 必须在计算上高效。

当你想证明一个问题的解的知识，而这个问题的描述甚至无法适应证明大小时，生成这样一个简洁的证明听起来似乎违反直觉。例如，像“我知道方程 *f*(*x*) = 0 的解”这样的陈述，如何处理，当方程 *f*(*x*) 可能是任意大小时？从理论角度看，简短的证明是有意义的，因为证明必须传达的信息仅仅是*解的知识*，以及通常是某个陈述的*正确性*，而不是实际的解和秘密；证明必须是零知识的，并且仅向验证者揭示这些信息。

2016 年，密码学家 Jens Groth 发布了文章《On the Size of Pairing-Based Non-interactive Arguments》 (*[`eprint.iacr.org/2016/260`](https://eprint.iacr.org/2016/260)*)，该文描述了一种极为高效的 zkSNARK。该证明只包含三个群元素，并且可以通过计算三个配对操作来验证（与 BLS 签名使用的配对类型相同）。Zcash 协议采用了这一突破性结果，为其他几种 zkSNARK 奠定了基础。Groth 的 zkSNARK 通常被称为*Groth16*。

#### 从陈述到证明

zkSNARKs 是一些最复杂的密码学构造，其中最复杂和最昂贵的步骤之一是*算术化*，这是一种将待证明的陈述转换为固定数量的多项式方程的操作，这些方程通常的形式是：

![](img/pg328-1.jpg)

对于一个*n*次多项式，其中系数*a*i 是某些有限环或有限域结构的元素。然后，证明算法处理这些多项式来创建 zkSNARK 证明。

算术化遵循一个通用的工作流程：

1.  使用正式符号描述待证明的陈述，如计算机程序、方程或逻辑公式。

2.  将步骤 1 中的正式表达式转化为一个*电路*，该电路通过对输入应用一系列*门*来定义输出值，类似于布尔或电子电路中的逻辑门，除了这些门可能是加法和乘法等代数运算。

3.  根据 zkSNARK 证明系统的约束系统，将电路转化为一个结构化的*约束*列表。这些约束是输入必须满足的条件列表，以证明所要证明的陈述。

要证明的陈述可能是如此简单，如“我知道整数*x*和*y*，它们满足方程 *x*³ + *y*² + *xy* + 55 = 0 mod 57。”通过得到一个正式的方程来表达问题，完成步骤 1。要完成步骤 2，你可以将该方程分解为一系列涉及两个操作数的简单操作（Groth16 要求这样做）。具体如下，你需要写出中间值 *v*[0]、*v*[1]、...、*v*[6]：

设置 *v*[0] = *x* × *x*。

设置 *v*[1] = *x* × *v*[0]；因此 *v*[1] = *x*³。

设置 *v*[2] = *y* × *y*。

设置 *v*[3] = *x* × *y*。

设置 *v*[4] = *v*[1] + *v*[2]。

设置 *v*[5] = *v*[4] + *v*[3]。

设置 *v*[6] = *v*[5] + 55；因此 *v*[6] = *x*³ + *y*² + *xy* + 55。

将一个长方程转化为一系列小方程的过程称为*展平*。

然后，证明者将这些操作——电路——转换为一组数学结构，用于构建由证明者处理的多项式。这些长多项式最终通过使用随机性，特别是*概率可验证证明（PCP）*的概念，进行“压缩”以形成证明，这是复杂性理论领域的一个重大发现。这使得验证者能够通过少量的实际约束检查，确信许多约束条件已被满足，同时保持零知识特性。

要了解算术化的复杂性，研究 zkSNARKs 使用的两种主要方法：等级-1 约束系统（R1CS）和代数中间表示（AIR）。

最后，注意我们区分*非通用*和*通用* zkSNARK 证明系统：在前者中，证明者仅适用于特定的预定义声明。特别地，证明系统的设置阶段会创建仅适用于给定声明的参数。然而，像 Marlin 和 Plonk 这样的通用证明系统则接受声明并为其生成证明。它们更灵活，但构建起来更为复杂，并且计算开销更高。

#### 事情如何出错

zkSNARKs 可能会遇到与阈值签名上下文中相同的问题类别，从不安全的协议到实现缺陷。安全问题可能出现在工作流程的不同阶段，从声明定义到算术化步骤和证明计算。受影响的安全性概念可能是完备性、健壮性或零知识。但大多数情况下，最大风险涉及健壮性，或者攻击者可能欺骗并愚弄验证者——因为对应用的潜在影响以及健壮性缺陷的微妙性，而“知识”泄露的可能性较小，特别是当证明必须保持验证者接受的有效证明时。

在接下来的示例中，我们将重点介绍 Schnorr 的协议。这些问题相对简单，但更复杂的证明系统可能会有更微妙的问题。

回想一下，Schnorr 的非交互式协议通过发送验证者 *s* = *r* + *ca* 和 *R* = *rG* 来证明知识 *a*，其中 *A* = *aG*，并且 *c* = **H**(*G* || *R* || *A*)。然后验证者通过重新计算 *c* 来检查等式 *sG* = *R* + *cA*。在交互式版本中，验证者随机选择 *c*。

##### 不充分的 Fiat–Shamir 哈希

想象一下，如果非交互式 Schnorr 证明中，*c* = **H**(*G* || *A*)，使得挑战值*c*与随机数*R*无关，攻击者可以选择任意的*s*值，并计算出*R* = *sG* – *cA*。这样得到的证明，由*s*和*R*组成，是有效的，但攻击者并不需要知道*a*，从而破坏了协议的安全性。

同样，如果*c* = **H**(*G* || *R*)，并且在定义挑战值*c*时省略了公钥*A*，则可能会发生攻击：攻击者可以选择任意的*R*和*s*值，并计算出点*B* = (1/*c*) × (*sG* – *R*)，满足*sG* = *R* + *cB*。这使攻击者得到了*B*的离散对数证明——即*b*，使得*B* = *bG*——然而他们并不知道*b*。

这些攻击展示了在使用 Fiat–Shamir 变换将协议非交互化时，将所有必要的值包含在哈希函数输入中的重要性。

##### 重放攻击

重放攻击是一种简单但可能造成严重后果的攻击。如果攻击者获知某个非交互式知识证明的值，他们可以将其发送给另一方并声称是自己创建的，从而窃取证明的信用。

你可以通过将证明绑定到证明者的身份，包含他们的公钥在哈希数据中来避免这种攻击。为了防止同一方随着时间的推移进行重放攻击，你可以通过将证明绑定到会话标识符或时间戳来避免这种情况，方法是将这些值包含在 Fiat–Shamir 哈希处理的数据中。

##### 随机性重用

以交互式 Schnorr 协议为例，验证者选择一个随机的*c*。如果证明者拥有一个有缺陷的伪随机生成器，并且两次重用了相同的挑战值*r*，那么观察到交换值的攻击者可以通过使用两个不同挑战值*c*[1]和*c*[2]的两个证明*s*[1] = *r* + *c*[1]*a*和*s*[2] = *r* + *c*[2]*a*来恢复秘密*a*，并计算出*a* = (*s*[1] – *s*[2]) / (*c*[1] – *c*[2])。

### 真正严肃的加密学

在本章中，我们回顾了加密学领域中一些最引人入胜的话题，从理论和实践的角度进行探讨。尽管如此，我们仅仅触及了表面，特别是在零知识证明系统领域，这个领域是一个活跃的研究和工程领域，具有广泛的应用，超出了区块链技术的范畴。然而，酷炫的加密学并不是区块链的万能良方。从多方计算协议，如私密集合交集（PSI）到同态加密技术，应用于人工智能模型的私密评估，新的应用场景和用例要求更好、更快的加密功能。

我们正见证着密码学的黄金时代，理论原理与实际应用前所未有地融合。这种协同效应为一些最具挑战性的安全和隐私问题提供了几乎魔法般的解决方案。尽管如此，仍然有许多重大挑战需要解决，尤其是在法律和监管领域。技术人员和政策制定者必须密切合作，共同应对这些挑战，并且双方都要努力理解对方的观点。希望这本书，特别是最后一章，能够帮助解开密码学的神秘面纱，使其对所有读者更易理解，更加亲民。
