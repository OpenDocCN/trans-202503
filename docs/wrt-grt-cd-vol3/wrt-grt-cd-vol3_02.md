## 第二章：**软件开发隐喻**

![Image](img/com.jpg)

我们如何定义软件开发过程？这个问题看起来可能有些傻。为什么不直接说“软件开发就是软件开发”然后就算了呢？其实，如果我们能够将软件开发任务与其他专业领域进行类比，就能更深入地理解软件开发过程。然后我们可以通过研究相关领域的过程改进来优化软件开发过程。为此，本章将探讨一些理解软件开发的常见方式。

### 1.1 什么是软件？

为了更好地理解程序员如何创建软件，我们可以将软件与其他人类创造的事物进行比较。这样做将为我们提供重要的见解，帮助我们理解为什么某些创意隐喻适用于软件开发，或者为什么不适用。

在他的著作《软件工程：初学者的入门》中，罗伯特·普雷斯曼列出了软件的几个特点。本节将探讨这些特点，以阐明软件的本质以及它如何定义计算机程序员的工作。

#### *1.1.1 软件不是制造出来的*

*软件是开发或工程化的；它不像传统意义上的产品那样被制造出来。*

—罗伯特·普雷斯曼

与硬件产品相比，软件产品的制造成本非常低：刻录一张 CD 或 DVD 的费用仅为几分钱，再加上一小部分运输和处理费用（而电子分发的成本更低）。此外，软件设计对制造的 CD/DVD 的质量或最终成本几乎没有影响。假设制造厂有合理的质量控制，计算机程序员在设计软件应用时很少需要考虑制造问题。^(1) 与其他工程专业相比，工程师必须考虑如何设计产品的*可制造性*。

#### *1.1.2 软件不会磨损*

软件和硬件都可能因为设计不良而在产品生命周期早期出现故障。然而，如果我们能够消除产品中的设计缺陷（即交付一款没有缺陷的软件或硬件），那么二者之间的区别就变得明显了。一旦软件是正确的，它就不会出现故障或“磨损”。只要基础计算机系统正常运行，软件将继续工作。^(2) 与硬件工程师不同，软件工程师不需要担心设计出能够轻松更换随时间失效的组件。

#### *1.1.3 大多数软件是定制开发的*

*大多数软件是定制开发的，而不是从现有的[标准]组件中组装而成。*

—罗伯特·普雷斯曼

尽管有很多尝试旨在创建类似的标准化软件组件，以供软件工程师将其组装成大型应用程序，但*软件集成电路*（即电子集成电路的等效物）的概念从未实现。软件库和面向对象编程技术鼓励重用预先编写的代码，但从较小的预组装组件构建大型软件系统的前提未能产生接近硬件设计所能实现的成果。

#### *1.1.4 软件可以轻松升级*

在许多情况下，完全可以在现场用新版本（甚至是完全不同的应用程序）替代现有的一个软件应用程序，而不会产生巨大的成本。^(3) 应用程序的最终用户只需用新的软件替换旧的，并享受升级版本带来的好处。事实上，大多数现代软件系统和应用程序在正常运行过程中都会通过互联网自动更新。

#### *1.1.5 软件不是独立存在的实体*

软件不是独立的产品。电气工程师可以设计一个完全独立运行的硬件设备。然而，软件依赖于其他东西（通常是计算机系统）才能正常运行。因此，软件开发者在设计和实现软件应用程序时，必须遵循外部系统（计算机系统、操作系统、编程语言等）所施加的限制。

### 1.2 与其他领域的类比

计算机程序员常被与艺术家、工匠、工程师、建筑师和技术员相比。虽然计算机编程与这些职业没有完全相同的对应关系，但我们可以从这些领域中汲取有益的类比，获得它们所采用技术的启发。

#### *1.2.1 程序员作为艺术家*

在计算机编程的早期，软件开发被视为一种艺术。编写软件的能力——即将大量杂乱无章的东西整理成一个可工作的程序——似乎是一种上天赋予的天赋，只有少数人具备，就像大师级画家或音乐天才一样。（事实上，许多轶事证据表明，音乐家和计算机程序员在进行创作活动时，使用的是大脑相同的区域，而且相当一部分程序员曾是或现在是音乐家。^(4))

那么，软件开发是否真的是一种艺术形式？*艺术家*通常被定义为拥有某些天赋并能够以创造性方式使用这些天赋的人。这里的关键字是*天赋*，即一种与生俱来的能力。由于不是每个人天生都具备相同的天赋，所以并不是每个人都能成为艺术家。根据这个类比，似乎如果你想成为一名程序员，你必须天生具备这种能力；事实上，有些人似乎天生就具有编程的天赋或才能。

"程序员作为艺术家"的比喻似乎适用于那些最优秀的程序员。尽管艺术家遵循自己的一套规则来创作高质量的艺术作品，但他们往往在突破规则、探索新的创作领域时，创造出最具非凡性的作品。类似地，最优秀的程序员熟悉良好的软件开发规则，但也愿意尝试新技术，以期改进开发过程。就像真正的艺术家不满足于复制现有的作品或风格一样，"程序员作为艺术家"更愿意创造新的应用程序，而不是重复做一个旧版的程序。

**注意**

*计算机科学中最受尊敬的教科书系列之一是 Donald Knuth 的《计算机程序设计的艺术》。显然，编程作为一种艺术形式的概念在计算机科学领域中根深蒂固。*

#### *1.2.2 程序员作为架构师*

艺术家比喻非常适用于小型项目，在这些项目中，艺术家创造理念并实现一件艺术作品，就像程序员设计并实现一个小型软件系统一样。然而，对于更大的软件系统，"程序员作为架构师"的类比可能更为贴切。建筑师设计结构，但将实施工作留给他人（因为通常一个人无法完成所有建造工作）。在计算机科学中，那些为他人设计系统以便实施的人通常被称为*程序员/分析师*。

建筑师对项目行使大规模的创意控制。例如，设计一座豪华建筑的建筑师定义它的外观、使用的材料以及施工工人需要遵循的指导方针，但不负责施工本身。建筑师可能会监督建筑（就像程序员/分析师审查他人添加到软件系统中的模块一样）；然而，建筑师并不拿起锤子或操作起重机。

这个类比似乎不适用于小型项目，但如果允许个人"更换角色"，它同样适用。也就是说，在项目的第一阶段，程序员戴上他们的架构师/程序员/分析师帽子，创造系统的设计。然后，程序员换上他们的程序员/编码员帽子来实现该系统。

"程序员作为架构师"这一范式在"程序员作为艺术家"模型之上增加了验证和安全措施。当艺术家绘画、创作音乐或雕塑时，他们通常不会担心这件作品是否符合除他们自己外的任何要求。此外，他们也不必担心这件艺术品可能会对生命或财产造成物理伤害^(5)。另一方面，建筑师必须考虑物理现实，且糟糕的设计可能导致伤害或损害。"程序员作为架构师"的范式为程序员的任务引入了个人责任、审查（测试）和安全性。

#### *1.2.3 程序员作为工程师*

1968 年北约会议挑战了“优秀的程序员天生就有，而非通过培养”的观点。正如本书介绍中所提到的，世界正面临软件危机——新软件应用的需求远远超过了程序员能够被训练出来的速度。因此，北约赞助了 1968 年的会议，创造了*软件工程*这一术语，来描述通过将工程学原理应用于计算机编程的混乱世界，来解决这一问题。

工程师关注的是以具有成本效益的方式解决实际问题，无论是在设计工作量方面，还是在生产成本方面。正因为如此，再加上工程职业历史悠久（特别是机械和化学工程领域），因此多年来为工程师们创造了大量程序和政策，以简化他们的工作。

在许多今天的工程领域中，工程师的任务是将大型系统从较小的预设计构件中构建出来。一位想要设计计算机系统的电气工程师不会从设计定制晶体管或其他小型部件开始；相反，他们会使用预设计的中央处理器（CPU）、存储单元和输入输出设备，将它们组装成一个完整的系统。同样，一位机械工程师可以使用预设计的桁架和基座来设计一座新桥。设计重用是工程职业的标志。它是生产安全、可靠、功能齐全且具成本效益的设计的关键要素之一，也是尽可能快速完成设计的重要因素。

软件工程师还遵循一套明确的程序和政策，从较小的预定义系统构建出大型系统。事实上，电气和电子工程师协会（IEEE）将*软件工程*定义如下：

采用一种系统化、纪律化、量化的方式进行软件的开发、操作和维护；也就是将工程学应用于软件。

#### *1.2.4 程序员作为工匠*

工匠模型介于艺术家和工程师之间。这个范式的核心思想是程序员是独立的个体；也就是说，软件工匠的比喻认识到人是重要的。增加人手和制定严格的规则并不会提高软件的质量，而是更好地培训个体，允许他们发挥自己的天赋和技能，才能做得更好。

传统工匠的开发过程与软件工匠的过程之间有许多相似之处。像所有工匠一样，软件工匠从*学徒*或*实习生*开始。学徒在另一位工匠的密切指导下工作。学会了基本技能后，学徒程序员成为*熟练工*，通常在其他程序员的团队中工作，且由一位软件工匠进行监督。最终，程序员的技能提升到一定程度后，他们会成为*大师工匠*。

工匠模型为那些有志成为优秀程序员的程序员提供了最好的比喻。我将在本章稍后的部分中回到这一比喻，具体在第 13 页的“软件工艺”部分。

#### *1.2.5 艺术家、建筑师、工程师还是工匠？*

要写出优秀的代码，你必须理解什么才是优秀的代码。在编写代码时，你需要使用最好的工具、编码技巧、程序、流程和政策。此外，你还必须不断增加自己的知识，改进所使用的开发流程，从而提升你所开发软件的质量。这就是为什么考虑不同的软件开发方法、理解软件产品并选择最佳方法如此重要的原因。

你需要努力学习如何编写优秀的代码，然后再努力去编写它。一个优秀的软件开发者会采纳各个领域中行之有效的思想，摒弃那些行不通的部分。总结一下：

+   **优秀的艺术家**通过练习自己的技能来发展他们的才能。他们进行发散性思维，探索传递信息的新方式。

+   **优秀的建筑师**懂得如何利用现有设计和标准组件，构建定制对象。他们理解成本限制、安全问题、需求，以及为了确保可靠运行所需的过度设计。优秀的建筑师理解形式与功能之间的关系，以及满足客户需求的重要性。

+   **优秀的工程师**认识到一致性的重要性。他们记录并自动化开发步骤，以避免遗漏任何步骤。像建筑师一样，工程师鼓励重用现有设计，提供更强大且具成本效益的解决方案。工程学提供了帮助克服项目中个人局限性的程序和政策。

+   **优秀的工匠**在大师的指导下训练和练习技能，最终目标是成为一名大师级工匠。这一比喻强调了个体的素质，如他们解决问题的能力和组织能力。

### 1.3 软件工程

自 20 世纪 60 年代末软件工程兴起以来，它已经成为一个无可争议的成功。今天，几乎没有专业程序员会接受那个时代“标准程序”中的编程噩梦。现代程序员理所当然接受的概念——如结构化编程、适当的程序布局（如缩进）、注释和良好的命名政策——都源于软件工程的研究。事实上，数十年的这类研究极大地影响了现代编程语言和其他编程工具。

软件工程已经存在了很长时间，并且对计算机编程的各个方面产生了深远影响，以至于许多人认为*软件工程师*一词与*计算机程序员*同义。毫无疑问，任何专业的软件工程师应该也是一名合格的计算机程序员，但计算机编程仅构成软件工程的一小部分。软件工程主要涉及经济学和项目管理。有趣的是，那些负责管理项目、保持进度、选择使用的方法论等的人并不叫软件工程师；他们被称为经理、项目负责人以及其他表示权威职位的头衔。同样，我们所称的软件工程师实际上并不做软件工程工作——他们只是编写由真正的软件工程师（经理和项目负责人）指定的代码。这或许就是为什么“软件工程”一词如此令人困惑的原因。

#### *1.3.1 正式定义*

没有一个*软件工程*的定义能够满足所有人的需求。不同的作者会加入他们自己的“见解”，使他们的定义与其他文本中的定义略有不同（或大不相同）。本书之所以命名为*工程软件*，是因为我希望避免再为这一概念添加另一个定义。作为提醒，IEEE 将*软件工程*定义为：

对软件的开发、运营和维护应用一种系统化、规范化、可量化的方法；也就是说，将工程学应用于软件。

我使用的原始软件工程定义是：

软件工程是关于大型软件系统的开发与管理的研究。

这里的关键术语是*大型*。软件工程的进展大多由国防合同等资助，因此软件工程与大型系统几乎是同义词。IEEE 的定义可以适用于几乎任何规模的系统，但由于大多数关于软件工程的研究都涉及非常大型的系统，我更倾向于采用第二种定义。

**注意**

*为了避免与通用的*软件工程*一词混淆，我使用一个更为专业的术语，*个人软件工程*，来描述那些适用于单个程序员在一个小型项目或大型项目的小部分上工作的过程和方法论。我的目的是描述计算机程序员认为的软件工程的本质，而不涉及那些与编写优秀代码无关的多余细节。*

在软件开发中，人们对于“庞大”的定义完全不同。一名计算机科学专业的本科生可能认为一个包含几千行源代码的程序是一个大型系统。而对于波音（或其他大型公司）的项目经理来说，一个大型系统的代码行数通常超过一百万行。我上次统计的时候（那已经是很久以前的事了），微软的 Windows 操作系统（OS）超过了五千万行源代码；没有人会怀疑 Windows 是一个大型系统！

由于传统的软件工程定义通常适用于大型软件系统，我们需要提出一个合理的大型（和小型）软件系统定义。尽管*代码行数（LOC）*是软件工程师常用来描述软件系统大小的指标，但它是一个低质量的指标，具有接近两个数量级的误差范围。^(6) 本书将经常使用 LOC 或*千行代码（KLOC）*指标。但依赖这样一个糟糕的指标来构建正式定义并不是一个好主意。这样做会削弱定义的严谨性。

#### *1.3.2 项目大小*

*小型项目*是指一个普通程序员可以在合理的时间内（少于两年）完成的项目。*中型项目*则太大，个体在合理的时间内无法完成，但一个由两到五名程序员组成的小团队能够完成它。*大型项目*则需要一个庞大的程序员团队（超过五人）。就 LOC 而言，小型项目大约包含 50 到 100 KLOC；中型项目的 LOC 在 50 到 1000 KLOC（即一百万行源代码）之间；而大型项目的 LOC 则从约 500 到 1000 KLOC 起步。

小型项目很容易管理。因为小型项目不需要程序员之间的互动，也几乎不需要程序员与外界的互动，生产力几乎完全依赖于程序员的能力。

中型项目带来了新的挑战。因为有多名程序员在参与项目，沟通可能会成为一个问题，但团队足够小，这种开销是可以管理的。尽管如此，团队内部的动态仍需要额外支持，这增加了每行代码编写的成本。

大型项目需要一个庞大的程序员团队。沟通和其他开销往往消耗每个工程师 50%的生产力。有效的项目管理至关重要。

软件工程处理需要大型程序员团队成功管理项目的方法、实践和政策。不幸的是，适用于个人甚至小团队的实践，无法扩展到大型团队，而大型项目的方法、实践和政策也无法缩小到适应小型和中型项目。适用于大型项目的实践通常会给小型和中型项目带来不合理的开销，降低这些小团队的生产力。

让我们更深入地了解不同规模项目的一些优缺点。

##### 1.3.2.1 小型项目

在小型项目中，单个软件工程师完全负责系统设计、实施、测试、调试、部署和文档编写。在这样的项目中，单一工程师需要负责的任务远多于中型或大型项目中的单个工程师。但这些任务相对较小，因此是可管理的。由于小型项目要求个人承担广泛的任务，程序员必须具备多样化的技能。个人软件工程学涵盖了开发者在小型项目中会做的所有活动。

小型项目能够最有效地利用工程资源。工程师可以采用最具生产力的方法来解决问题，因为他们不必与项目中的其他工程师达成共识。工程师还可以优化他们在每个开发阶段所花费的时间。在结构化的软件设计流程中，通常会花费大量时间进行操作文档记录，但当项目中只有一个程序员时，这显得不太合理（尽管在产品生命周期的后期，可能会有其他程序员需要与代码合作）。

小型项目的缺点和陷阱在于，工程师必须能够处理所需的各种任务。许多小型项目失败（或其开发成本过高），因为工程师缺乏足够的培训来独立处理整个项目。*Write Great Code*系列的目标之一，甚至比其他任何目标都更加重要，就是教会程序员如何正确地完成小型项目。

##### 1.3.2.2 中型项目

在一个中型项目中，个人软件工程包括了项目中由单个工程师负责的那些方面。这通常包括他们系统组件的设计、实现（编码）以及该模块的文档。通常，他们还负责对其组件进行测试（*单元测试*），然后由整个团队进行系统测试（*集成测试*）。通常会有一名工程师负责完整的系统设计（*项目负责人*或*首席程序员*），并负责部署。根据项目的不同，技术文档可能由技术写作人员来负责。由于工程师在中型项目中共享任务，因此可以实现专业化，项目也不要求每个工程师都能完成所有单独的任务。首席程序员可以指导经验较少的工程师，以确保项目的整体质量。

在一个小型项目中，单个工程师能够看到整体情况，并根据对整个项目的理解优化某些活动。而在一个大型项目中，单个工程师对除自己负责的小部分外，其他部分几乎不了解。中型项目则提供了这两种极端的混合：个人可以看到大部分整个项目，并根据实际情况调整他们的系统实施方法。同时，他们也可以在不被其他系统细节压倒的情况下，专注于系统的某些方面。

##### 1.3.2.3 大型项目

在大型项目中，各团队成员有着更为专业化的角色，从系统设计到实现、测试、文档、部署以及系统的增强和维护。与中型项目一样，在大型项目中，个人软件工程只包括程序员自己负责的那些活动。大型项目中的软件工程师通常只做几项任务（例如编码和单元测试），因此他们不需要像小型项目中的单个工程师那样广泛的技能。

除了活动的范围外，项目的大小也会影响工程师的生产力。在大型项目中，工程师可以变得非常专业化，专注于自己擅长的领域。这使得他们能够比起使用更广泛的技能集时，更高效地完成工作。然而，大型项目必须使用统一的软件开发方法才能有效，而一些工程师可能因为不喜欢这种方法而生产力下降。

#### *1.3.3 软件工程失败的原因*

确实可以将工程技术应用于软件开发，以更具成本效益的方式生产应用程序。然而，正如皮特·麦克布林在《软件工艺：新的必然性》中所指出的，软件工程面临的最大问题是认为“系统化、严谨、可量化的方法”是唯一合理的途径。事实上，他提出了一个非常好的问题：软件开发是否真的可能变得系统化和量化？引用 *[`www.controlchaos.com/`](http://www.controlchaos.com/)*，麦克布林说：

如果一个过程可以被完全定义，所有相关内容都已知，可以设计并反复执行，且结果可预测，那么它被称为已定义过程，并且可以进行自动化。如果一个过程的所有内容并不完全已知——只知道当你混合这些输入时通常会发生什么，以及如何测量和控制以获得期望的输出——这些则被称为经验过程。

软件开发不是一个已定义过程；它是一个经验过程。因此，软件开发不能完全自动化，且通常很难将工程原理应用于软件开发。问题的一部分在于，实际的工程工作高度依赖于现有设计的重用。尽管在计算机编程中也可以进行大量的重用，但它需要比其他工程领域更多的定制化。

软件工程的另一个重要问题，正如本书引言中简要讨论的那样，是软件工程将软件工程师视为可以随意调换进出项目的商品资源，这忽视了个体才能的重要性。问题并不在于工程技术从未有价值，而在于管理层试图将这些技术普遍应用于每个人，并鼓励使用当前的一些“最佳实践”进行软件开发。这种方法能够产生高质量的软件，但它不允许跳出框架思考，去创造可能更好的新实践。

### 1.4 软件工艺

软件工艺，指程序员在大师的指导下培养和实践技能，是为了终身学习，成为最优秀的软件开发者。遵循工艺模型，程序员接受教育，完成学徒期，成为中级程序员，并努力开发出杰作。

#### *1.4.1 教育*

大学为实习生成为软件工匠提供了必备的基础。如果一个实习生（学徒）能够接触到和正规教育相同的信息和挑战，那么这次实习可能与正式教育等效。不幸的是，很少有软件工匠有时间或能力从零开始培养一个学徒。他们太忙于处理实际项目，无法投入足够的时间来教导实习生所有他们需要知道的内容。因此，教育是通向软件工匠之路的第一步。

此外，大学的正规教育实现了两个主要目标：首先，你必须学习那些如果你自己学习可能会跳过的计算机科学主题；其次，你向全世界证明了你有能力完成一个你开始的重大承诺。特别是，在完成正规的计算机科学课程后，你已准备好*真正*开始学习软件开发。

然而，无论学位多么高级，都无法自动将你资格化为软件工匠。拥有研究生学位的人，因其需要深入且专门化的计算机科学研究，和拥有本科学位的人一样，也从实习生做起。拥有研究生学位的实习生可能作为学徒的年限较短，但仍然需要大量的培训。

#### *1.4.2 学徒制*

完成正规的计算机科学课程为你准备了以学徒身份开始学习如何成为一名工匠的基础。典型的计算机科学课程会教授你编程语言（其语法和语义）、数据结构、编译器、操作系统等理论，但不会教授你*如何编程*，除非是在第一或第二学期的编程入门课程中。学徒训练则展示了当你进入实际工作后，编程究竟是什么。学徒训练的目的是获得必要的经验，以便将你所学的知识用来从多种不同角度解决问题，并尽可能多地积累不同的经验。

学徒在一位掌握了高级编程技巧的人指导下学习。这个人可以是*软件学徒*（见下一节）或者*软件工匠*。这位“导师”给学徒分配任务，展示如何完成任务，并检查学徒的工作，做出适当的中途调整，以确保高质量的工作。最重要的是，学徒还需要检查导师的工作。这可以通过多种形式进行，包括测试、结构化演练和调试。关键是学徒要了解导师的代码是如何工作的。^(7) 通过这样做，学徒能够掌握一些自己无法独立掌握的编程技巧。

如果学徒足够幸运，他们将有机会在几位大师的指导下学习，并从他们那里学习到扎实的技术。每完成一个项目，学徒就会在高级程序员的指导下接近学徒生涯的尽头，并进入软件工匠之路的下一阶段：软件中级工匠。

从某种意义上说，学徒生涯永远不会结束。你应该始终关注新的技术和新技能。例如，考虑那些从结构化编程成长起来的软件工程师，他们曾经需要学习面向对象编程。然而，在某个时刻，你会达到这样一个阶段：你更多地使用已有的技能，而不是开发新的技能。到了那个时候，你开始把自己的智慧传授给他人，而不是从他人那里学习。此时，你和“大师们”合作的同事会觉得你已经准备好独立承担项目，无需帮助或监督。那时，你就成为了一名软件中级工匠。

#### *1.4.3 软件中级工匠*

软件中级工匠负责大部分软件开发工作。如其名所示，他们通常在不同项目之间流动，运用他们的技能解决应用问题。尽管软件开发者的教育从未结束，但软件中级工匠更专注于应用开发，而不是学习如何开发应用。

软件中级工匠还承担着另一个重要任务，那就是培训新的软件学徒。他们会审查学徒在项目中的工作，并与他们分享编程技术和知识。

一名软件中级工匠不断寻找能够改善软件开发过程的新工具和新技术。通过尽早采纳新的（但经过验证的）技术，他们保持领先于学习曲线，跟上当前趋势，避免落后。利用行业最佳实践为客户创造高效且具有成本效益的解决方案是这一阶段工艺的标志。软件中级工匠高效、知识丰富，正是大多数项目经理在组建软件团队时希望找到的类型的开发人员。

#### *1.4.4 大师工匠*

成为一名高级工匠的传统方式是创作一个*杰作*，这是使你脱颖而出的作品。一些（高端）软件杰作的例子包括 VisiCalc，^(8) Linux 操作系统，以及 vi 和 emacs 文本编辑器。这些产品最初是一个人的创意和创作，尽管后来涉及了数十甚至数百名不同的程序员。杰作不一定像 Linux 或某些 GNU 工具那样成名。然而，你的同行必须认可你的杰作作为解决问题的有用和创造性的解决方案。杰作也不一定是独立的原创代码。为操作系统编写复杂的设备驱动程序，或者在几个有用的方面扩展其他程序，完全可以算作是杰作。杰作的目的是创建一个告诉世界的作品：「我有能力制作严肃的软件——请认真对待我！」杰作让他人知道他们应该认真考虑你的意见，并信任你所说的话。

通常，高级工匠的领域是确定当前的最佳实践并发明新的实践。最佳实践描述了完成任务的最佳*已知*方法，不一定是绝对最佳方法。高级工匠研究是否有更好的方法来设计应用程序，认识到新技术或方法论对广泛应用的实用性，并验证该实践是否最佳，并将这些信息传达给他人。

#### *1.4.5 软件工艺失败的地方*

史蒂夫·麦康奈尔在他的经典软件工程著作*代码大全*中声称，经验是那些特征之一，其重要性并不像人们想象的那么大：“如果一个程序员在一两年后还没学会 C 语言，接下来的三年也不会有多大改变。”然后他问道：“如果你工作了 10 年，你获得了 10 年的经验还是获得了 1 年的经验 10 次？”麦康奈尔甚至暗示，书本学习可能比编程经验更重要。他声称，计算机科学领域变化如此之快，以至于在过去十年里，有 10 年编程经验的人错过了新程序员接触到的所有重要研究。

### 1.5 通向编写优秀代码的道路

写出优秀的代码并不是因为你遵循了一串规则。你必须做出个人决定，付出努力，确保你写的代码真的很出色。违反公认的软件工程原则是确保你的代码不优秀的好方法，但严格遵循这些规则也不能保证代码的伟大。一位经验丰富、严谨的开发者或软件工匠能够在两种方法之间游刃有余：在需要时遵循既定的实践，但当需要时，也敢于尝试不同的技术或策略。

不幸的是，一本书只能教给你规则和方法论。创造力和智慧是你需要自己培养的品质。本书教给你规则，并建议你何时可以考虑打破这些规则。然而，是否打破规则仍然取决于你自己。

### 1.6 更多信息

Hunt, Andrew, 和 David Thomas. *程序员修炼之道*. Upper Saddle River, NJ: Addison-Wesley Professional, 1999.

Kernighan, Brian, 和 Rob Pike. *编程实践*. Upper Saddle River, NJ: Addison-Wesley Professional, 1999.

McBreen, Pete. *软件工艺：新的命令*. Upper Saddle River, NJ: Addison-Wesley Professional, 2001.

McConnell, Steve. *代码大全*. 第二版. Redmond, WA: Microsoft Press, 2004.

———. *快速开发：驾驭混乱的软件进度*. Redmond, WA: Microsoft Press, 1996.

Pressman, Robert S. *软件工程：实践者的方案*. 纽约: McGraw-Hill, 2010.
