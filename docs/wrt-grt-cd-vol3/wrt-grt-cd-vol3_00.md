# 前言

![Image](img/com.jpg)

在 20 世纪 60 年代末，计算机软件的需求远远超过了技术学校、大学和高等院校培养训练有素的计算机专业人员来开发这些软件的能力——这一现象被称为*软件危机*。提高大学和院校的输出并不是一种切实可行的方法；当时，计算机科学专业的合格学生人数太少，无法满足需求。研究人员当时认为，更好的解决方案是提高现有程序员的生产力。注意到软件开发和其他工程活动之间的相似性，这些研究人员得出结论，其他工程学科行之有效的程序和政策可以解决软件危机。于是，*软件工程*应运而生。

在软件工程领域繁荣之前，软件开发是一项神秘的技艺，由能力和成就各异的高手们所实践。在那时，软件项目的成功完全依赖于一两位关键程序员的能力，而不是整个团队的能力。软件工程旨在平衡软件团队的技能，使它们更具生产力，减少对那一两位高才的依赖。

在很大程度上，软件工程的实践是成功的。由程序员团队构建的大型项目，过去使用临时组织方法是无法完成的。但与此同时，重要的品质却丧失了。软件工程鼓励团队的生产力，却以牺牲个人的创造力、技能和成长为代价。尽管软件工程技术有可能将差劲的程序员培养成优秀的程序员，但它们也可能限制杰出程序员发挥最佳能力。世界上优秀程序员太少了。我们最不希望做的就是让程序员失去发挥潜力的动力；然而，这正是软件工程模式常常做的事情。

*《写出优秀的代码》*系列的目标是恢复一些丧失的个人创造力、技能和成长。它讲述了我所称之为*个人软件工程*的内容，即程序员如何提高代码质量。具体来说，它描述了如何从平庸的代码中编写出优秀的代码——一种易于维护、增强、测试、调试、文档化、部署，甚至退休的代码。优秀的代码没有那些往往是工程师或管理层由于不合理压力或糟糕计划所产生的杂乱和临时解决办法。优秀的代码是你可以为之自豪的代码。

当我完成了*《写出优秀的代码，第 2 卷：低层次思维，高层次写作》*（*WGC2*）时，我原本打算在这本书中加入更多的内容。在*WGC2*的最后一章中，我写下了以下内容：

[*写出优秀代码，第三卷：工程软件*]开始讨论编程的*个人软件工程*方面。软件工程领域主要关注大型软件系统的管理。而个人软件工程则涵盖了那些与个人层面上写出优秀代码相关的话题——工艺、艺术和对工艺的自豪感。因此，在*工程软件*中，我们将通过讨论软件开发隐喻、软件开发者隐喻以及*系统文档* [重点强调]等话题，来考虑这些方面。

系统文档（包括需求、测试程序、设计文档等）是软件工程的一个重要部分。因此，关于这一主题的书籍至少必须提供这些内容的概述。好吧，在本书写到第七章时，我意识到单一的一本书无法涵盖所有这些内容。最终，我将本卷《工程软件》拆分成四卷。这四卷中的第一卷就是本书，它是《*写出优秀代码*》系列的第三卷。它集中讨论软件开发模型和系统文档。系列的第四卷将讲解软件设计；第五卷将进一步发展优秀编码的主题；第六卷将涉及测试。

当我写这篇文章时，距离我完成《*写出优秀代码*》系列第二卷已经过去了 10 年。是时候完成第三卷了，即使这意味着将原本的信息分成两卷或更多卷。如果你读过我之前的书，你会知道我喜欢深入探讨课题；我不感兴趣写那些仅仅触及主题的书。因此，我面临着将这项工作分成多个卷并尽快发布，或者制作一本 2000 页的巨著，而历史常常证明，这本书可能永远无法完成。我为那些期待本书涵盖更多内容的人道歉。别担心——这些信息会在未来的卷中出现。你只是提前在本书中获得了第一部分内容。

### 假设与前提条件

为了专注于工程软件，本书必须做出一些假设。虽然我尽力将这些假设保持在最低限度，但如果你的个人技能集符合某些前提条件，你将从本书中受益最多。

你应该至少对一种命令式（过程式）或面向对象的编程语言有相当的熟练度。这包括 C 和 C++、C#、Swift、Pascal、BASIC、Java 以及汇编语言。你应该知道如何根据一个小问题的描述，进行设计和实现其软件解决方案。一门典型的大学课程或几个月的自学经验应该足以让你使用本书。

你还应该具备计算机组织和数据表示的基本知识。例如，你应该理解十六进制和二进制数字系统，以及计算机如何在内存中表示各种高级数据类型，如有符号整数、字符和字符串。如果你在这方面的知识较弱，*Write Great Code, Volume* *1: Understanding the Machine (WGC1)* 完整地覆盖了计算机组织。尽管我可能会参考*WGC1*中的内容，但你应该能够独立阅读本书，而不依赖于那本书。

### 什么是优秀的代码？

优秀的代码是遵循一套规则的软件，这些规则指导程序员在将算法实现为源代码时所做的决策。优秀的代码是以其他程序员为考虑对象编写的——其文档使其他人能够阅读、理解并维护该软件。我称之为*软件开发黄金法则*，它是软件工程的关键。

降低一个层次，优秀的代码：

+   高效且使用 CPU、系统资源和内存

+   文档完善，易于阅读、维护和扩展

+   遵循一致的风格指南

+   使用明确的设计，遵循已建立的软件工程惯例

+   经过充分测试且健壮

+   按时完成并且预算内

虽然*Write Great Code*系列的第 1 卷和第 2 卷涉及许多与优秀代码相关的效率方面，系列中的其他书籍，从这一卷开始，专注于创建符合前述标准的代码。

### 程序员分类

为了理解是什么让一个程序员变得伟大，让我们首先考虑业余程序员、各级程序员和软件工程师之间的差异。

#### *业余程序员*

业余程序员是自学成才，经验有限，因此是伟大程序员的对立面。在计算机的早期，这些程序员被称为*黑客*。这个术语今天已经演变成几种不同的含义，不一定指没有足够教育或经验做专业软件工程的程序员。

业余程序员编写的代码问题在于，他们通常是为自己或朋友编写代码；因此，这些代码通常不符合当代软件工程项目的标准。然而，业余程序员可以通过一些教育提升自己的水平（*WGC*系列可以提供帮助）。

#### *程序员*

计算机程序员拥有广泛的经验和职责，这通常反映在职称中，如初级程序员、编码员、程序员 I 和 II、分析师/系统分析师和系统架构师。我们在这里探讨其中一些角色及其差异。

##### 实习生

通常，实习生是兼职的学生，他们被分配所谓的*苦力活*——如运行一套固定的测试程序或编写软件文档。

##### 初级程序员

应届毕业生通常担任初级程序员职务。通常，他们从事测试或维护任务。很少有机会参与新项目；相反，他们大部分编程时间都用于重写现有代码或处理遗留代码。

##### 编码员

程序员在获得足够经验后晋升为编码员，管理层也开始信任他们进行项目的新代码开发。一名更资深的程序员将（较不复杂的）子组件分配给编码员，以帮助加快项目的完成速度。

##### 程序员 I 和 II

随着程序员积累更多经验，并能独立处理复杂的实现任务，他们从编码员晋升为程序员 I，再到程序员 II。系统分析师通常可以为程序员 I 或 II 提供一个大致的需求，程序员能够填补细节并生成符合系统分析师预期的应用程序。

##### 系统分析师

系统分析师研究问题并确定最佳的解决方案实现方式。通常，系统分析师选择要使用的主要算法并创建最终应用的组织结构。

##### 系统架构师

系统架构师决定系统分析师在大型系统中设计的各个组件如何协同工作。通常，系统架构师会指定流程、硬件及其他与软件无关的部分作为整体解决方案的一部分。

##### 完整的程序员

一名*完整的* *程序员*是这些子领域的融合。也就是说，一名完整的程序员能够研究问题、设计解决方案、使用编程语言实现解决方案并测试结果。

程序员分类问题

实际上，大多数程序员分类都是人为设定的；它们的存在仅仅是为了为初级程序员和有经验的程序员设定不同的薪酬标准。例如，系统分析师设计特定应用的算法和整体数据流，然后将设计交给编码员，由他们用特定的编程语言实现。我们通常将这两个任务与*编程*联系在一起，但初级程序员没有足够的经验从零开始设计大型系统，尽管他们完全有能力将设计转化为适当的编程语言。系统分析师和架构师通常拥有处理整个项目的经验和能力。然而，管理层通常认为让他们处理那些需要经验的项目部分比让他们做低级别的编码更具成本效益，而后者是应届毕业生也能做的（且成本更低）。

#### *软件工程师*

在工程领域，工程师通过遵循一套规定的规则来处理特定问题，利用预定解决方案的组合来构建定制的解决方案。这种方法使得即使是技术不太出众的工程师也能在不从零开始开发系统的情况下，产出有效的解决方案。软件工程作为一种尝试，通过将传统工程概念应用于软件开发，最大化整个编程团队的价值而产生。总体来看，软件工程革命是成功的。拥有正确培训和领导的工程师可以在比以往更短的时间和更少的资金投入下，编写出高质量的代码。

纯粹的软件工程不鼓励发散性思维，因为它可能会浪费时间，并使工程师走上失败的道路（导致更高的开发成本和更长的开发时间）。一般来说，软件工程更关注按时和按预算开发应用程序，而不是以*最佳方式*编写代码。但是，如果软件工程师从不尝试新事物，他们通常会错失机会，无法产生优秀的设计，永远不会开发出新的实践，也无法成为伟大的程序员。

#### *伟大的程序员*

伟大的程序员意识到预算问题，但他们也明白，探索新想法和方法对于推动这个领域的发展非常重要。他们知道何时必须遵循规则，但也知道何时可以打破（或至少弯曲）规则。但最重要的是，伟大的程序员充分利用自己的技能集，取得仅凭思维局限无法实现的成果。黑客天生如此，软件工程师是后天培养的，而伟大的程序员则是两者的结合体。他们有三个主要特点：对工作有真正的热爱、持续的教育和培训，以及在解决问题时能够跳出框架思考的能力。

##### 热爱你所做的，做你所爱的

人们往往在自己喜欢的任务上表现出色，而在自己不喜欢的活动上表现不佳。底线是，如果你讨厌计算机编程，你将不会成为一个很好的程序员。如果你天生没有解决问题和克服挑战的欲望，再多的教育和培训也无法改变你的性格。因此，成为一名伟大的程序员最重要的前提是你真正热爱编写计算机程序。

##### 优先考虑教育和培训

伟大的程序员喜欢这个领域所要求的任务，但他们还需要其他东西——正规教育和培训。我们将在后续章节中更深入地讨论教育和培训，但现在可以说，伟大的程序员受过良好的教育（或许拥有大专以上学位），并且在整个职业生涯中持续接受教育。

##### 跳出框架思考

如前所述，按照预定的规则生成代码是软件工程师的典型期望。然而，正如你将在第一章中看到的，要成为一名伟大的程序员（“大宗师程序员”），你需要愿意并能够设计出新的编程技巧，这些技巧来源于发散性思维，而不是盲目遵循规则。伟大的程序员天生有推动边界并探索新解决方案的渴望。

### 所以你想成为一名伟大的程序员

总结来说，如果你想成为一名真正伟大的程序员并赢得同行的敬佩，你需要具备以下几点：

+   对计算机编程和问题解决的热爱

+   基于大学或高等院校学位的广泛计算机科学知识^(1)

+   对教育和培训的终身承诺

+   在探索解决方案时，具备跳出框框思考的能力和意愿

+   个人对卓越表现的渴望和动力，以及始终力求做到最好

具备这些特质，阻碍你成为一名伟大程序员的唯一因素就是更多的知识。这就是本书的作用所在。

### 关于伦理与品格的最终说明

软件工程师的工作是根据冲突的需求，通过在系统设计中做出适当的妥协来创造最佳的产品。在这个过程中，工程师必须优先考虑需求，并在项目的限制下选择最佳解决方案。伦理和个人品格常常会影响个体在处理复杂项目时，尤其是压力较大的项目时做出的决策。做出不诚实的智力决策（例如，虚报项目估算或声称某个软件在未经充分测试的情况下就可以工作），盗版软件开发工具（或其他软件），在软件中引入未经文档化的功能（如后门）而未获得管理层批准，或采纳精英主义态度（认为自己比其他团队成员更优秀）都是软件工程伦理失范的例子。践行正确的道德判断和良好的伦理将使你成为更好的人，也会让你成为更优秀的程序员。

### 更多信息

Barger, Robert N. *《计算机伦理学：基于案例的方法》*。剑桥，英国：剑桥大学出版社，2008 年。

Floridi, Luciano, ed. *《剑桥信息与计算机伦理学手册》*。剑桥，英国：剑桥大学出版社，2006 年。

Forester, Tom, 和 Perry Morrison. *《计算机伦理：计算中的警示故事与伦理困境》*。第二版。剑桥，马萨诸塞州：麻省理工学院出版社，1993 年。

Parker, Donn B. “信息处理中的伦理规则。” *《ACM 通讯》* 11，第三期（1968 年）：198-201。*[`dl.acm.org/doi/10.1145/362929.362987`](https://dl.acm.org/doi/10.1145/362929.362987)*。

Wiener, Norbert. *《人类对人类的使用：控制论与社会》*。波士顿：霍顿·米夫林·哈考特出版社，1950 年。

WikiWikiWeb. “大师级程序员。”最后更新时间为 2014 年 11 月 23 日。*[`c2.com/cgi/wiki?GrandMasterProgrammer/`](http://c2.com/cgi/wiki?GrandMasterProgrammer/)*。
