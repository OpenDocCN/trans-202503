# 第十四章：关注儿童：对策、认证和 Goodbytes

![](img/chapterart.png)

我们已经写了很多关于各种攻击的内容，但防御型黑客的最终目标是提高安全性。考虑到这一点，我们将本章专门献给减轻故障攻击和侧信道分析的对策，现有的各种认证，以及如何提升自己。这也是本书的结尾章节，我们认为这为我们的下一个阶段搭建了桥梁，那就是修复你将暴露的问题。

对策与侧信道功率分析领域一样古老，且是一个活跃的研究领域。我们将介绍几种经典的对策，它们是良好的入门步骤，同时也会说明其局限性。当你第一次听到侧信道分析时，一些显而易见的对策会出现在脑海中，但始终重要的是要对其进行评估。例如，给系统添加噪声可能听起来是个不错的对策，但实际上这只会稍微增加攻击的难度。本章中的对策是公开已知的（本书制作过程中没有违反任何保密协议），通常是一些在行业中有一定应用并代表“合理努力”的对策。在高安全性产品中，对策的开发需要大量投资，并且需要硬件设计和软件设计团队之间的协作。然而，即使只进行一些软件上的更改，我们也可以让 SCA 和 FI 攻击变得更难执行。

评估你的对策的有效性至关重要。对于功率分析和故障注入对策，这必须是一个持续的评估过程。例如，如果你编写的是 C 代码，C 编译器可能会简单地优化掉对策。在嵌入式安全领域，一个非常常见的故事是，某个“安全”的产品在设计的某些阶段仅进行了对策的评估。编译器、综合工具或实现破坏了对策的有效性。如果你不及早且频繁地进行测试，最终你会发布那些你认为是受保护的产品，但实际上根本就不安全。

本书中我们教授的工具是进行这种评估的绝佳起点。例如，你甚至可以开始设置一个完全自动化的分析系统，使你的产品在实际使用的工具链下得到持续评估。

## 对策

理想的对策并不存在，但将多个对策结合起来可以让攻击者的工作变得足够困难，从而让他们放弃。在本节中，我们将提供几种可以应用于软件或硬件的对策构建方法。我们还将讨论对策验证，这实际上是将你在不同章节中学到的技术应用到实际中，看看攻击变得多么困难。接下来的示例经过简化，以演示每个原理；因此，我们“忽略”了一些其他原理的建议。许多这些对策已在 Marc Witteman 等人的白皮书《在旁路攻击存在下的安全应用编程》中进行了详细介绍。

### 实现对策

在商业产品中实现对策是非常困难的，因此很难第一次就做到“正确”；在这个语境中，“正确”意味着成本、功率、性能、安全性、可调试性、开发复杂性以及你关心的其他因素之间的正确平衡。大多数成功的制造商会在几次产品迭代后达成这些考虑因素的良好平衡。一旦你开始探索安全性与其他方面之间的冲突，至少你知道自己在做正确的事情。你希望已经实现了容易解决的基础对策，并且现在正进入需要做出真正权衡的阶段。这意味着你正在积极进行成本/收益分析，并意识到没有绝对的安全性；这就是生活，这很好。

你确实需要避免一些常见的陷阱。我们通常看到的是，泄漏抽象法则（“所有非平凡的抽象，在某种程度上，都是泄漏的，” 乔尔·斯波尔斯基所说）适用于安全漏洞；旁路攻击和故障显然是它的体现，但它同样适用于对策。电气工程师会提出新的电路，计算机科学家会改进代码，加密专家会提出新的加密算法。问题在于，他们通常在设计对策时使用与设计包含漏洞的对象相同的抽象方式，这导致了对策的无效性。在本章稍后的“无相关/恒定功率消耗”一节中，你将看到一个简单的例子，展示如何一个安全的对策在一种实现（软件）中有效，但在另一种实现（硬件）中失败。

打破抽象层次需要对你堆栈中的每一层有基本的理解、足够好的模拟器和/或对最终产品的彻底测试。换句话说，这是一个困难且反复迭代的过程；你不会第一次就做对，但如果做对了，你会逐渐变得更好。

对策的一个关键见解是，它们通过破坏攻击的假设来起作用。每个攻击都会做出一些假设，这些假设在攻击成功时必须为真。例如，在差分功率分析（DPA）中，假设你的操作是时间对齐的，因此引入错位的对策破坏了这个假设，从而减少了 DPA 的有效性。准备好攻击树并选择破坏这些攻击假设的对策是一种好的策略。

这一推理也适用于相反的方向：对策依赖于对攻击的假设，而攻击者的任务是破坏这些假设。之前提到的通过引入错位来对抗差分功率分析（DPA）的对策，是基于假设攻击者无法识别跟踪中的特征并执行对齐的前提下进行的。这就是猫鼠游戏开始的地方。

在这些猫鼠游戏中，对策被破坏和升级，攻击被阻止和改进。在软件中，主要的游戏计划是打补丁。在硬件中，这种策略是不可行的。在某些情况下，你可以通过软件对策来修补硬件漏洞，这意味着你可以让产品保持安全一段时间。在其他情况下，你将依赖产品出厂时的安全性。理想情况下，产品在出厂时应该具备硬件安全余量，使其能抵抗未来*X*年后的攻击（尽管由于攻击的非线性特性，确定*X*是不可行的），就像药品需要有使用安全期一样。实际上，这是不可能的，常见的策略是“尽力而为”，并通过固件更新和配置更改允许打补丁。

这里提出的所有对策都不完美，但它们不需要完美。通过一些额外的努力或更聪明的攻击，攻击者能够绕过这些对策。重点不是创造一个无法攻破的系统，而是设计一个成功攻击的成本低于对策成本，或者攻击的成本高于攻击者的预算的系统。

#### 非相关/常量时间 everywhere

如果某个操作的持续时间取决于某个秘密，那么简单的功率分析（SPA）或定时分析可能能够恢复这个秘密。关联时间的经典示例是使用`strcmp()`或`memcmp()`来验证密码或 PIN 码。（将明文密码或 PIN 码存储而不是存储其哈希值本身就是不安全的，但我们暂且将其作为一个示例。）这两个 C 函数都有一个提前终止的条件，因为它们在第一个不同的字节后就会返回，这使得攻击者在可以测量时间的情况下，能够得知输入的 PIN 码中哪个字符与存储的 PIN 码不同。有关示例，请参见第八章关于定时攻击的内容，以及本章附带笔记本中的`memcmp()`示例（可在[`nostarch.com/hardwarehacking/`](https://nostarch.com/hardwarehacking/)查看）。

诀窍是实现一个对策，使得操作与秘密之间的时间不再相关，这意味着要使操作的*时间保持常量*（并可能在此基础上添加*定时随机化*），如列表 14-7 所示。一种解决方案是实现一个常量时间内存比较，比如本章笔记本中的`memcmp_consttime()`。我们在列表 14-1 中展示了该函数的核心。

```
def memcmp_consttime(c1, c2, num):
    # Accumulate differing bits in diff
    diff = 0
    for i in range(num):
        # If bits differ, the xor is nonzero, therefore diff will be nonzero
        diff = diff | (c1[i] ^ c2[i])
    return diff
```

列表 14-1：一个常量时间的`memcmp()`函数

我们没有在第一个不同的字节上终止，而是对于两个缓冲区中的每一组字节，计算它们的异或值，如果字节相同则结果为零，否则为非零。然后我们通过将所有异或值按位或（OR）到`diff`中来累加它们，这意味着一旦某个位不同，该位将在`diff`中保持不变。从泄漏角度来看，更好的做法是比较值的哈希，而不是直接比较字节，但这样做会更慢。请注意，为了简化，此示例没有包括溢出检查。

基于哈希的消息认证码（HMAC）比较中的定时攻击在加密实现中很常见。如果你有一个使用 HMAC 签名的数据块，目标系统会计算该数据块的 HMAC 并与签名进行比较。如果该比较泄露了定时信息，就像前面的密码示例一样，它允许暴力破解 HMAC 值，而不需要知道 HMAC 密钥。这个攻击被用来绕过 Xbox 360 的代码验证，称为*Xbox 360 定时攻击*（与第十三章中的 FI 攻击不同）。要修复此问题，可以使用*常量时间比较*。

另一个重要方面是基于敏感值的条件分支的定时。一个简单的示例是列表 14-2 中显示的代码。如果传递的秘密值是`0xCA`，那么执行`leakSecret()`的时间比传递其他值时要长得多。

```
if secret == 0xCA:
    res = takesLong()
else:
    res = muchShorter()
```

列表 14-2：我们可以通过测量这段代码的执行时间来判断`secret`是否为`0xCA`。

现在，攻击者只需通过测量过程的持续时间，或者查看 SPA 信号，就可以推测秘密值是否等于`0xca`。攻击者还可以利用`if()`语句的时序知识来尝试使其故障。

一种解决方案是使相关代码*无分支*，如示例 14-3 中的`dontLeakSecret()`。

```
def dontLeakSecret(secret):
    # Run both sides of the if() condition
    res1 = takesLong()
    res2 = muchShorter()
    # Mask is either all bits 0 or all bits 1, depending on if() condition
    mask = int(secret == 0xCA) - 1 
    res = (res1 & ~mask) | (res2 & mask) # Use mask to select one value return res
    return res
```

示例 14-3：我们通过始终执行两个操作来避免明显的功率分析。

其思路是执行分支的两个部分并分别存储结果。然后我们计算一个`mask`，该掩码在二进制中要么全为零，要么全为一，具体取决于`if()`条件的结果。我们可以使用这个掩码通过逻辑运算合并结果：如果掩码全为零，我们取分支一侧的结果；如果全为一，我们取另一侧的结果。我们也尝试过使用操作来生成和赋值掩码，而不采用条件代码流程，但正如我们稍后提到的，这里有风险，聪明的编译器可能会检测到我们正在做的事情，并将我们的代码替换为条件代码。从示例 14-3（以及所有示例）中可以看到，自己运行代码可能更容易理解，因此请务必查看本章的伴随笔记本，以便更好地理解程序流程。这里有一些明显的限制：`takesLong()`和`muchShorter()`不应有任何副作用，并且该代码的性能会较差。

最后，*时序随机化*是指插入与秘密无关的非恒定时间操作。最简单的方式是使用一个循环，随机迭代若干次，其迭代次数需要调节到足以为处理的秘密引入足够的不确定性。如果一个秘密通常会在某个特定的时钟周期泄漏，你希望将其分散到至少几十个或几百个时钟周期中。如果时序随机化结合足够的噪声添加（参见下一节“非相关/恒定功耗”部分），对于攻击者来说，重新对齐是非平凡的。

时序随机化也有助于防止故障注入，因为攻击者现在要么必须幸运地让故障时序与随机化时序巧合，要么需要花费额外的时间来同步目标操作。

由 PLL 驱动而非直接由外部晶体驱动的设备时钟通常不是完全稳定的。因此，一些时序随机化已经“自然”地出现。类似地，中断可以为时序增加不稳定性。这些效应可能为某些使用场景添加足够的随机化。

如果没有实现此类方法，建议在敏感操作之前明确添加时序随机化。时序随机化可能会在旁道信道追踪中轻易看到，因此它会指向敏感操作。噪声的添加可能有助于此，因为它使得对抗技术如对齐和傅里叶变换等丢失时序信息的攻击变得更加困难。如果你可以承受性能损失，你应该在硬件设计或软件代码中遍布添加时序随机化。

#### 无相关/恒定功耗

你可以观察到功耗信号幅度中的泄漏。敏感数据/操作与功耗之间的相关性越小越好，但要实现这一点并不简单。最基本的方法是通过并行运行任何硬件或软件向功耗中加入*噪声*。这种策略并不能完全去相关信号，但它增加了噪声，因此也增加了攻击成本。在硬件中，生成这种噪声可以通过运行一个随机数生成器、一个特殊的噪声生成器或一个视频解码器来处理虚拟数据。在软件中，你可以在另一个 CPU 核心上运行一个并行线程，执行诱饵或虚拟操作。

在硬件中，设计一个*平衡*电路是可能的——即，对于每个时钟周期，不管处理的数据是什么，都会发生相同数量的位翻转。这种平衡叫做*双轨逻辑*，其背后的理念是每个门和线路都有一个反转版本，使得零到一的转换与一到零的转换同时发生。加入这种平衡在芯片面积上非常昂贵，并且需要极其小心和低级别的平衡，以确保每个转换同时发生。然而，不平衡仍然会导致泄漏，尽管比没有这种技术时要少得多。此外，电磁信号也必须考虑进去：两个反向信号可能会相互放大或相互抵消，具体取决于信号的空间布局。

对于加密，我们可以通过添加随机噪声来进一步使用一些巧妙的*掩码*技巧。理想情况下，在每次加密或解密时，生成一个随机掩码值，并将其与数据混合在一起，作为密码的开始。然后我们修改密码实现，使得中间值始终保持掩码状态，在密码结束时，我们“解掩”结果。从理论上讲，在密码执行过程中，任何中间值都不应无掩码地存在。这意味着差分功耗分析（DPA）应该会失败，因为 DPA 严重依赖于能够预测一个（未掩码的）中间值。因此，掩码应该没有*一阶* *泄漏*，一阶泄漏是指通过仅查看某一时间点的内容来利用的泄漏。

掩码的一个例子是 AES 的旋转 S-box 掩码（见 Maxime Nassar、Youssef Souissi、Sylvain Guilley 和 Jean-Luc Danger 撰写的“RSM：一种小巧且快速的 AES 防护措施，能够防范 1 阶和 2 阶零偏旁路攻击”）。在*旋转 S-box 掩码（RSM）*中，我们修改每个 16 个 S-box，使它们接受一个掩码值 *M*[*i*]，并生成一个用 *M*[(][*i+1*][)] [*mod*] [16] 掩码的输出值，其中 *M*[*i*] 是一个随机选择的 8 位值，0 ≤ *i* < 16。掩码仅通过 XOR 完成。S-box 表只在执行密码算法之前计算一次。在密码调用时，我们将初始掩码与密钥进行 XOR 操作，进而在 `AddRoundKey` 中 XOR 掩码数据。XOR 掩码会在 `SubBytes` 和 `ShiftRows` 操作中由修改后的 S-box 保持。`MixColumns` 操作按原样执行，但之后通过 XOR 操作“修正”，使得状态向量有效地重新掩码。最终，经过第一轮后得到一个掩码的 AES 状态向量，并且在整个计算过程中都保持掩码的中间值。这些步骤会为所有轮次重复执行，最后通过一次 XOR 操作将数据解除掩码。

掩码的一个问题通常是“完美”的模型在现实中并不总是适用。就像 RSM 的情况一样，掩码会被重复使用，因此“完美”被换取了性能的提升。Guilherme Perin、Baris Ege 和 Jasper van Woudenberg 撰写的论文“降低门槛：用于旁路分析的深度学习”表明，对于某些 RSM 实现，依然存在一阶泄漏。

即使掩码是“完美的”，也存在所谓的*二阶攻击*，其原理是我们观察两个中间值，*X* 和 *Y*。例如，*X* 可能是 `AddRoundKey` 后的一个字节，*Y* 可能是 `SubBytes` 后的一个字节。如果它们在执行过程中都使用相同的掩码 *M*，也就是 *X* ⊕ *M* 和 *Y* ⊕ *M*，我们可以执行以下操作。我们测量 *X* ⊕ *M* 和 *Y* ⊕ *M* 的旁路信号。假设我们知道信号 *X* ⊕ *M* 和 *Y* ⊕ *M* 泄漏的时间点 *x* 和 *y*，这意味着我们可以获取它们对应的采样值 *t*[*x*] 和 *t*[*y*]。我们可以结合这两个测量点（例如，通过计算它们的绝对差值 |*t*[*x*] − *t*[*y*]|）。我们还知道 (*X* ⊕ *M*) ⊕ (*Y* ⊕ *M*) = *X* ⊕ *Y*。事实证明，|*t*[*x*] − *t*[*y*]| 和 *X* ⊕ *Y* 之间实际上存在相关性，基于这种相关性，我们可以执行 DPA。这就是所谓的二阶攻击，因为我们将跟踪中的两个点结合起来，但这个思路可以扩展到任何*更高阶攻击*：一阶掩码对一个值应用一个掩码（也就是 *X* ⊕ *M*），并且可以通过二阶 DPA 攻击。二阶掩码对一个值应用两个掩码（也就是 *X* ⊕ *M*[*1*] ⊕ *M*[*2*]），并且可以通过三阶 DPA 攻击，以此类推。一般来说，*n*阶掩码可以通过 (*n* + 1)阶 DPA 攻击。

第二阶攻击的问题在于找到 *x* 和 *y* 这两个时间点，其中 *X* ⊕ *M* 和 *Y* ⊕ *M* 的信号存在泄漏。在正常的 DPA 中，我们只是对踪迹中某一时间点的所有样本进行相关分析来找到泄漏。如果我们不知道时间 *x* 和 *y*，就必须通过暴力方法将踪迹中的所有可能样本组合起来，进行 DPA 分析。这是一个二次复杂度问题，复杂度与踪迹中的样本数有关。同时，相关性并不完美，因此适当的遮掩技术迫使攻击者进行更多的测量和计算。换句话说，尽管遮掩技术实现起来昂贵且容易出错，但它也给攻击者带来了很大的负担。

*遮掩（Blinding）* 类似于遮掩技术，只不过这些技术的起源是在（非侧信道）密码学中。RSA 和 ECC 有各种各样的遮掩技术，它们依赖于数学原理。一个例子是 RSA 消息遮掩。对于密文 *C*、消息 *M*、模数 *N*、公钥指数 *e* 和私钥指数 *d* 以及随机遮掩 *1* < *r* < *N*，我们首先计算被遮掩的消息 *R* = *M* × *r*^(*e*) mod *N*。接下来，我们对被遮掩的消息进行 RSA 签名，*R*^(*d*) = (*M* × *r*^(*e*))^(*d*) = *M*^(*d*) × *r*^(*ed*) = *C* × *r*，然后通过计算 (*C* × *r*) × *r*^(*–1*) = *C* 来去除遮掩。这样得到的值与不进行遮掩的经典 RSA 相同，后者直接计算 *M*^(*d*) = *C*。然而，由于 *R* 在 *R*^(*d*) 中对攻击者是不可预测的，因此需要消息 *M* 提升到 *d* 的时序攻击会失败。这就是所谓的 *消息遮掩（message blinding）*。

由于 RSA 每次只使用一个或几个指数位 *d*，因此指数也容易受到时序攻击或其他侧信道攻击的影响。为了减轻指数值的侧信道泄漏，需要进行指数遮掩（exponent blinding），这确保了每次 RSA 计算中使用的指数都是不同的，通过生成一个随机数 1 ≤ *r* < 2⁶⁴，并生成一个新的指数 *d′* = *d* + ϕ(*N*) × *r*，其中 ϕ(*N*) = (*p* – 1) × (*q* – 1) 是群的阶。新的指数通过模约简“自动”去除遮掩（即，*M*^(*d*) = *M*^(*d′*) mod *N*），但从侧信道攻击者的角度来看是不可预测的。被遮掩的指数 *d′* 可以是每次加密调用时的随机值，因此攻击者无法通过获取更多的踪迹来逐渐了解 *d* 或单一的 *d′*。这增加了攻击者的难度。攻击者无法通过获取更多的踪迹获得更多的信息，而是必须破解单一的踪迹。然而，如果实现非常泄漏，SPA 攻击可能会有效：从单个踪迹完全提取 *d′* 相当于找到了未遮掩的私钥 *d*。

还有许多其他的模糊和掩码技术，以及*时间常数*或*随机化指数运算算法*（用于 RSA）和*标量乘法算法*（用于 ECC）：*模数掩蔽*、*蒙哥马利阶梯*、*随机加法链*、*随机投影坐标*和*高阶掩蔽*。这是一个活跃的研究领域，我们建议研究最新的攻击和防御措施。

在使用这些对策时，要注意其潜在的假设。前面部分提到的掩蔽示例假设了哈明重量泄露。但如果我们在硬件中实现这个方法，而一个寄存器泄露了连续值之间的哈明距离呢？那么掩蔽可能就会被消除。当寄存器连续包含两个掩蔽值，*X* ⊕ *M* 和 *Y* ⊕ *M* 时，就会泄露 HD(*X* ⊕ *M*, *Y* ⊕ *M*)。如果我们将其重新写成如下形式，就能看出这个问题：HD(*X* ⊕ *M*, *Y* ⊕ *M*) = HW(*X* ⊕ *M* ⊕ *Y* ⊕ *M*) = HW(*X* ⊕ *Y*) = HD(*X*, *Y*)。实际上，硬件已经为你解除了掩蔽，并泄露了相同的哈明距离。因此，从算法层面来看，这个对策似乎是有效的，但在实现时可能会带来反效果。

#### 随机化访问机密数组值

这个对策很简单。如果你正在遍历存储在数组中的某个机密信息，可以采用*随机顺序*，或者至少选择一个*随机起始点*，然后按顺序遍历数组。此方法可以防止具有侧信道攻击可能性的攻击者从数组中学习特定条目。此方法有用的例子包括验证 HMAC（或明文密码）或从内存中清除/擦除密钥，因为你不希望在一个可预测的时间点不小心泄露这些信息。有关例子，可以查看伴随笔记本中的`memcmp_randorder()`函数，该函数从两个数组中的任意位置开始，不根据缓冲区数据进行分支。或者，你可以参考 Listing 14-4。

#### 执行诱饵操作或感染计算

*诱饵操作*旨在模拟实际的敏感操作（从旁路角度来看），但它们对操作的输出没有实际影响。它们会欺骗攻击者分析旁路跟踪中的错误部分，并且可以用作解耦时间的手段。一个例子是 RSA 中模幂运算的*平方乘法始终对策*。在教科书 RSA 中，对于每个位的指数，如果指数位为 0，就执行平方操作，如果指数位为 1，就执行乘法加平方操作。对于 0 和 1 位的操作差异，会造成非常明显的（SPA）旁路泄漏。为了平衡这一差异，你可以执行诱饵乘法，并在指数位为 0 时丢弃结果。这样，平方和乘法的次数就能保持平衡。另一个例子是在 AES 中增加额外的轮次并丢弃它们的结果。

为了继续使用笔记本中的内存比较示例，我们在`memcmp_decoys()`中添加了一些随机诱饵轮次。它的工作原理是随机执行诱饵 XOR 操作，并确保结果不被累积。这也用于 Listing 14-4。

*感染性计算*更进一步：它使用诱饵操作作为“感染”输出的一种方式。如果诱饵操作发生错误，它会破坏输出。这在加密操作中尤为有用；可以参考 Benedikt Gierlichs、Jörn-Marc Schmidt 和 Michael Tunstall 的《Infective Computation and Dummy Rounds: Fault Protection for Block Ciphers Without Check Before-Output》。

诱饵操作的另一个良好应用是检测故障（检测并响应故障）。如果诱饵操作有已知的输出，你可以验证该输出是否正确；如果不正确，则说明一定发生了故障。

#### 旁路抵抗加密库、原语和协议

说“使用经过验证的*加密库*”与加密 101 规则“不要自己实现加密”类似。这里的警告是，大多数开源加密库并不提供任何功率分析旁路抵抗或故障抵抗的保障。常见的库（如 OpenSSL 和 NaCl）和原语（如 Ed25519）确实能防范时间旁路攻击，主要是因为时间攻击可以被远程利用。如果你在微控制器或安全元素上构建，芯片自带的加密核心和/或库可能声称具有某些抵抗能力。查看数据手册中的*对策*、*旁路*或*故障*等词，或检查任何认证。更好的做法是，测试芯片！

如果你被迫使用一个不具备抗电源侧信道攻击能力的加密库或原语，你或许可以使用*抗泄漏协议*。这些协议基本上确保密钥只被使用一次或少数几次，从而使得差分功率分析（DPA）变得更加困难。例如，你可以对密钥进行哈希处理，以便为下一条消息创建一个新的密钥。这类操作例如在 NXP 实现的 AES 模式中使用，该模式在 LPC55S69 中被称为*索引代码块*模式。

最后，你可以*封装*库以执行一些针对故障的安全检查。例如，在使用 ECC 或 RSA 签名后，你可以验证签名，检查它是否通过。如果没有，肯定发生了某些故障。同样，你可以在加密后解密，检查是否重新获得了明文。执行这些检查会迫使攻击者进入双重故障：一个针对算法，另一个绕过故障检查。

#### 尽量避免处理密钥，除非必要

假设你是超人，密钥就是氪石；请小心处理它们，只在绝对必要时使用。不要复制（或进行完整性检查）它们，且在应用中应通过*引用*传递密钥，而不是通过值传递。当使用加密引擎时，避免不必要地加载密钥到引擎中，以避免*密钥加载攻击*。这种做法显然减少了侧信道泄漏的可能性，也减少了对密钥的故障攻击。差分故障分析是一种复杂的加密故障攻击，但加密还面临更多的故障攻击。

假设一个攻击者只需将密钥的一部分（例如，在密钥复制操作中）归零。这样做可以破坏挑战响应协议。挑战响应协议基本上由一方用来确认另一方是否知道某个密钥：爱丽丝向鲍勃发送一个随机数*c*（挑战），鲍勃用共享密钥*k*加密*c*并发送响应*r*。爱丽丝进行相同的加密，并验证鲍勃是否发送了正确的*r*。现在爱丽丝知道鲍勃知道密钥*k*。

这一切都好，问题是现在故障精灵可以物理访问到爱丽丝的加密设备。爱丽丝用于验证的密钥现在因为故障被破坏，变成了全零。因为故障精灵知道这一点，她可以通过用零密钥加密*r*来伪装鲍勃。或者，如果故障精灵能够访问鲍勃的加密设备，并能部分将密钥归零（例如，除了一个字节外的所有字节），她可以使用一对*c*和*r*暴力破解那个非零的密钥字节。通过迭代其他密钥字节，可以暴露整个密钥。如果设备频繁重新加载密钥，故障精灵将有多次机会将密钥的不同部分归零。

#### 使用非平凡的常量

在现代 CPU 上，软件中的布尔值被存储为 32 位或 64 位。你可以利用这些额外的位来构建故障缓解和检测机制。在第七章，你通过 Trezor One 故障的演示看到，简单的比较操作可能被跳过。同样，假设你使用以下代码来验证签名操作：

```
if verify_signature(new_code_array):
    erase_and_flash(new_code_array)
```

`verify_signature()`的唯一返回值是`0`，它*不会*导致相关代码被闪存写入。其他所有可能的返回值都会被代码评估为“真”！这是使用平凡常数的一个例子，导致代码非常容易被故障注入。

一个典型的故障模型是，攻击者可以将一个字设置为零，或者“`0xffffffff`”，在这个模型中，攻击者不太可能设置一个特定的 32 位值。因此，我们可以用*非平凡常数*来代替布尔值的零和一，这些常数有较大的哈明距离（例如`0xA5C3B4D2`和`0x5A3C4B2D`）。要从一个常数转换到另一个常数，通常需要大量的比特翻转（通过故障）。同时，我们可以将`0x0`和`0xffffffff`定义为无效值，以捕捉故障。

这个思路可以扩展到枚举中的状态，类似地也可以在硬件状态机中实现。请注意，将这个构造应用于枚举中的状态通常很简单，但对于布尔值来说，当使用标准函数时，可能很难始终如一地实现。

在笔记本中的示例`memcmp_nontrivial()`中，我们使用非平凡值扩展了我们的内存比较函数，以处理重要的状态。这个版本也展示在 Listing 14-4 中，包括了诱饵函数，从随机索引开始，并具有常数时间特性。

```
def memcmp_nontrivial(c1, c2, num):
    # Prep decoy values, initialize to 0
    decoy1 = bytes(len(c1))
    decoy2 = bytes(len(c2))

    # Init diff accumulator and random starting point
    diff = 0
    rnd = random.randint(0, num-1)

    i = 0 
 while i < num:
        # Get index, wrap around if needed
        idx = (i + rnd) % num

        # Flip coin to check we have a decoy round
        do_decoy = random.random() < DECOY_PROBABILITY
        if do_decoy:
            decoy = (CONST1 | decoy1[idx]) ^ (CONST2 | decoy2[idx]) # Do similar operation
            tmpdiff = CONST1 | CONST2 # Set tmpdiff so we still have nontrivial consts
        else: 
            tmpdiff = (CONST1 | c1[idx]) ^ (CONST2 | c2[idx]) # Real operation, put in tmpdiff
            decoy = CONST1 | CONST2 # Just to mimic other branch 

        # Accumulate diff 
        diff = diff | tmpdiff 

        # Adjust index if not a decoy 
        i = i + int(not do_decoy) 

return diff
```

Listing 14-4: 一个复杂的`memcmp`函数，包含诱饵函数和非平凡常数

诀窍在于将`diff`和`tmpdiff`的值编码成，它们永远不会是全 1 或全 0。为此，我们使用两个特殊的值：`CONST_1==` `0xC0A0B000`和`CONST_2==0x03050400`。它们被设计成较低的字节被设置为 0。这个较低的字节将用于存储内存中两个字节的异或结果，我们将这个值累积到`diff`变量中。此外，我们还将`diff`的高 24 位作为一个非平凡常数。正如代码所示，我们还将`CONST_1`和`CONST_2`的值累积到`diff`中。这样做的方式是，在正常情况下，`diff`的高 24 位将有一个固定且已知的值——即与`CONST_1`和`CONST_2`的高 24 位相同。如果数据故障导致`tmpdiff`的高 24 位发生比特翻转，就可以检测到；你将在“检测并响应故障”部分看到如何处理这种情况。

不同内存比较函数的示例展示了编写能够减轻故障的代码有多么困难。当你使用优化（JIT）编译器时，更难写出代码，确保这些对策不会被编译掉。显而易见的解决方案是使用汇编语言（虽然这有在汇编中编写代码的缺点），或者开发一个能够注入此类对策的编译器。关于这个主题已经有一些学术出版物，但问题似乎在于接受度——无论是出于性能原因，还是担心可能引入会影响已充分测试的编译器行为的问题。

在硬件中，*错误更正码（ECC）*可以视为用来减轻故障的“非平凡常量”。它们通常具有有限的错误更正和检测能力，对于能够翻转多个位的攻击者（例如，整个字），这可能使得故障的有效性减少不到一个数量级。还需要注意的是，举例来说，一个全零的字（包括 ECC 位）并不是一个正确的编码。

#### 状态变量重用

使用非平凡常量是一个不错的选择，但请考虑在配套笔记本中 `check_fw()` 函数的代码流，该函数在 Listing 14-5 中也有展示。它设置了 `rv = validate_address(a)`，返回一个非平凡常量。如果常量是 `SECURE_OK`，它将执行 `rv = validate_signature(a)`。

```
SECURE_OK = 0xc001bead
def check_fw(a, s, fault_skip):
  1 rv = validate_address(a) 
    if rv == SECURE_OK: 
      2 rv = validate_signature(s) 

        if rv == SECURE_OK: 
            print("Firmware ok. Flashing!")
```

Listing 14-5：使用非平凡常量并不是所有问题的立竿见影的解决办法。

攻击者在这里可以轻松地做一些事情；他们可以使用故障注入（FI）跳过第 2 步对 `validate_signature()` 的调用。变量 `rv` 已经在之前对 `validate_address()` 的调用（第 1 步）中设置了 `SECURE_OK` 值。因此，我们应该在使用后清除该值。在支持宏的语言中，我们可以通过一个宏轻松地包装这些调用。或者，我们可以使用一个不同的变量（例如，通过为第二次调用引入 `rv2`）或验证控制流（见下节）。请注意，所有这些方法都容易受到编译器优化的影响（请参阅本章后面的“与编译器作斗争”部分）。

#### 验证控制流

故障注入可以改变控制流，因此任何关键的控制流应当进行*验证*，以降低故障成功的概率。一个简单的例子是在 C 语言中的 `switch` 语句中的“默认失败”语句；`case` 语句应该列出所有有效的情况，因此默认情况应该永远不会被触及。如果默认情况被触及，我们就知道发生了故障。类似地，你可以对 `if` 语句做同样的处理，其中最终的 `else` 是一种失败模式。在笔记本中的 `default_fail()` 函数中，你可以看到一个例子。

在实现任何 *条件分支*（包括使用那些“非平凡常数”的分支）时，也要意识到编译器如何实现你的条件分支，可能会极大地影响攻击者绕过某个代码检查的能力。高级的 `if` 语句可能会被实现为“相等分支”或“不相等分支”类型的指令。像第四章中一样，我们将回到汇编代码中，看看它是如何实现的。典型的 `if`…`else` 语句生成的汇编代码见 列表 14-6。

```
 1 bl      signature_ok(IMG_PTR)
        mov     r3, r0
        cmp     r3, #0
        movne   r3, #1
        moveq   r3, #0
        and     r3, r3, #255
        cmp     r3, #0
      2 beq     .L2
        ldr     r0, [fp, #-8]
      3 bl      boot_image(IMG_PTR)
        b       .L3
.L2:
      4 bl      panic()
.L3:
        nop
```

列表 14-6：展示 `if` 语句的 ARM 汇编代码，编译器实现方式

这个 `if` 语句的设计是用来检查是否应该启动一个图像（通过 `IMG_PTR` 指针指向）。在 1 处调用了 `signature_ok()` 函数，该函数会在 `r0` 寄存器中返回一个特殊的值，指示签名是否允许该图像启动。这个比较最终会通过 2 处的相等分支（`beq`）进行判断，如果分支跳转到 `.L2`，则会在 4 处调用 `panic()` 函数。问题在于，如果攻击者跳过了 2 处的 `beq`，它将直接跳转到 3 处的 `boot_image()` 函数。将比较的顺序调整为跳过 2 处的 `beq` 会直接跳转到 `panic()` 函数，在这个例子中是一个更好的做法。你可能需要和你的编译器配合，以实现这个效果（可以查看 gcc 和 clang 编译器中的 `__builtin_expect`），这也提醒我们为什么调查实际的汇编输出是非常重要的。有关帮助你自动化这些测试的工具，请参见本章后面的“仿真与模拟”部分。

对敏感决策进行双重或多重检查也是验证控制流的一种手段。具体而言，你实现多个逻辑上等价但包含不同操作的 `if` 语句。在笔记本中的 `double_check()` 示例中，内存比较操作执行了两次，并用略微不同的逻辑进行检查。如果第二次比较的结果与第一次不一致，我们就发现了故障。

`double_check()` 示例已经针对单一故障进行了加固，但在 `memcmp()` 调用之间恰好间隔一定周期的多个故障可以跳过两次检查。因此，最好在它们之间加入一些 *随机等待状态*，理想情况下还要执行一些 *非敏感操作*，如笔记本中的 `double_check_wait()` 示例所示，且在 列表 14-7 中也有展示。非敏感操作的帮助在于：首先，长时间的故障可能会破坏连续的条件分支；其次，随机等待的侧信道信号会向攻击者透露敏感操作发生的时机。与之前的例子相比，曾经 100% 成功的故障现在变得不太可能。

```
def double_check_wait(input, secret):
    # Check result
    result = memcmp(input, secret, len(input))

    if result == 0:
        # Random wait
        wait = random.randint(0,3)
        for i in range(wait):
            None 

        # This is also a good point to insert some not-so-sensitive other operations
        # Just to decouple the random wait loop from the sensitive operation

        # Do memcmp again
        result2 = memcmp(input, secret, len(input))

        # Double check with some different logic
        if not result2 ^ 0xff != 0xff:
            print("Access granted, my liege")
        else: 
            print("Fault2 detected!") 1
```

列表 14-7：通过随机延迟双重检查 `memcmp` 操作

另一个简单的控制流检查是查看敏感的循环操作是否以正确的循环计数结束。附带的笔记本中的`check_loop_end()`示例演示了这一点；循环结束后，迭代器的值会与一个“已知良好”的值进行检查。

一种更复杂但更广泛的对策是*控制流完整性*。有很多种实现方式，但我们提供了一个使用*循环冗余检查（CRC）*的示例。CRC 非常快速。其理念是将一系列操作表示为字节序列，并对其计算 CRC。最后，我们检查 CRC 是否与预期值匹配，这应该始终成立，除非某个故障改变了操作顺序。你将需要添加一些代码来帮助进行控制流完整性工作。

附带的笔记本中展示了`crc_check()`，其中多个函数调用更新了一个运行中的 CRC。首先，我们启用了`DEBUG`模式，这会导致最终的 CRC 被打印出来。接着，这个 CRC 被嵌入到代码中作为检查项，并关闭调试模式。现在，控制流检查处于激活状态。如果一个函数调用被跳过，最终的 CRC 值将不同。你可以通过将`FAULT`变量设置为 0 和 1 来验证它是否有效。

你可以在没有条件分支的地方执行这种简单的控制流检查。如果程序中有一些条件分支，你仍然可以为每条路径硬编码一些有效的 CRC 值。或者，你还可以在仅限于一个函数内部的局部控制流中进行操作。

CRC 当然并不是加密安全的。加密安全在这里并不重要，因为我们需要的仅仅是一个难以伪造的校验码。在这种情况下，伪造意味着通过故障注入将 CRC 设置为一个特定值，而我们假设攻击者的能力不足以做到这一点。

#### 检测并响应故障

通过使用复杂的常量、双重检查或诱饵操作，我们可以开始构建*故障检测*。如果遇到无效状态，我们就知道是故障引起的。这意味着在`if`语句中，我们检查`condition==TRUE`，然后是`condition==FALSE`，如果最终进入`else`，我们就知道发生了故障。对于“switch”语句来说，“default”情况应该始终是故障选项。请参见笔记本中的`memcmp_fault_detect()`，它通过简单地检查`diff`和`tmpdiff`中非平凡位的比特是否正确设置，如果没有正确设置，则返回`None`。另一个例子是 Listing 14-7 中的 1，在这个例子中，第一个检查成功，但第二个检查失败。

类似于诱饵操作，我们可以使用任何并行的软硬件进程来构建通用的*故障金丝雀*。在正常情况下，它们应该有一些固定的、可验证的输出，但在遭受攻击时，它们的输出会发生变化。

在硬件中，我们可以构建类似的结构。此外，硬件还可以包括特定的*故障传感器*，用于检测供应电压或外部时钟的异常，甚至是芯片上的*光学传感器*。这些可以有效应对特定类型的故障，但另一种类型的攻击可能绕过它们。例如，光学传感器会检测激光脉冲，但不会检测电压扰动。

*故障响应*是指在检测到故障时应采取的措施。这里的目标是将成功攻击的机会降低到攻击者放弃的程度。在这个光谱的一端，你可以实现程序退出、操作系统重启或芯片重置。这些措施会延迟攻击者，但原则上仍然允许他们进行无限次尝试。光谱的中间部分是向后端系统发出信号，标记该设备为可疑设备，并可能禁用该账户。在光谱的另一端，你可以实施永久性措施，如清除密钥、禁用账户，甚至烧毁熔丝，阻止芯片启动。

如何响应故障可能很难决定，因为这在很大程度上取决于你对假阳性的容忍度、系统是否是安全关键型以及妥协带来的影响有多严重。在信用卡应用中，当遭受攻击时，清除密钥和禁用所有功能是完全可以接受的。与此同时，如果由于假阳性导致这种情况发生在大规模范围内，则是不可接受的。需要在一定的时间框架或生命周期内找到一个平衡点，确定可以容忍多少假阳性（和故障！）。

为了平衡假阳性和实际故障，可以使用*故障计数器*。初始的计数器增量被视为假阳性，直到计数器增加到一定的*计数阈值*。当达到该阈值时，我们认为系统正在遭受（故障）攻击。这个计数器必须是非易失性的，因为你不希望断电后计数器被重置。攻击者可以通过在每次故障尝试之间重置计数器轻松利用这一点。

即使是非易失性计数器也必须小心实现。我们曾经进行过攻击，通过侧信道测量检测到检测机制，然后在计数器更新到非易失性存储之前关闭目标设备。通过在*敏感操作*之前增加计数器，存储计数器值，执行敏感操作，且只有在未检测到故障的情况下再减少计数器，可以抵御这种攻击。现在，关机只意味着计数器已被增加。

对策的阈值取决于应用的暴露度和对假阳性的容忍度；在汽车和航空航天/太空应用中，由于暴露于辐射和强电磁场中，由自然引起的故障更加常见。容忍度取决于应用。在信用卡的情况下，清除密钥和有效地禁用功能是可以接受的。然而，这在具有安全功能的设备（例如医疗或汽车设备）中则不可接受。从其他应用的现场故障率角度来看，这甚至可能是不可接受的。在这种情况下，一种应对方法可能是偷偷通知后端设备，表明该设备可能正受到攻击。此时，采取什么措施是一个产品设计决策，但它通常涉及在安全性、可靠性、成本、性能等方面进行权衡。

### 验证对策

本节中的对策可能会使攻击更加困难。这是一个故意的弱声明。不幸的是，我们并不处于一个干净的加密世界，在这个世界里，存在能够简化为现有并且经过充分研究的数学难题的优雅证明。我们甚至没有像加密学中那样的启发式安全性，因为对策的有效性因芯片类型而异，有时甚至因单个芯片而异。最好的情况是，文献在无噪声的环境下分析对策，并在（通常）表现相对“干净”的简单微控制器或 FPGA 上验证它们。这就是为什么——直到我们有更好的理论方法来预测对策的有效性——在实际系统上测试有效性是至关重要的。

#### 强度和可绕过性

验证对策时需要分析两个主要角度：强度和可绕过性。在现实世界的类比中，*强度*是指撬开门锁有多困难，*可绕过性*是指是否可以通过窗户进入，从而避开锁。

强度可以通过开关对策并验证攻击抵抗差异来衡量。对于故障注入，您可以将这种差异表示为故障概率的降低。对于侧信道分析，您可以将这种差异表示为密钥暴露前所需的跟踪次数的增加。

查看笔记本中的示例，测试`memcmp_fault_detect()`函数中非平凡常数对策的强度。此函数使用顶部 24 位非平凡常数位（参见 Listing 14-4）作为故障检测机制。我们模拟`diff`和`tmpdiff`值中的单字节故障。我们可以观察到，大约 81.2%的情况下，故障被成功检测到，而约 18.8%的情况下，则没有故障，或者没有可观察到的效果。然而，我们的对策并不完美：大约 0.0065%的情况下，故障会成功翻转`diff`或`tmpdiff`的位，使得`memcmp_fault_detect()`得出输入值相等的结论。虽然这听起来成功率很低，但如果这是一个密码检查，我们期望在 15,385 次故障注入后成功登录（1/0.000065）。如果每秒能注入一次故障，那么你将在五小时内成功。

第二个（也是更棘手的）角度是绕过性：绕过对策的难度有多大？为了确定这一点，可以考虑构建一个攻击树（参见第一章），它可以帮助你列举其他的攻击方式。你可能会缓解电压故障，但攻击者仍然可以进行电磁故障注入。

#### 对抗编译器

一旦你验证了几次你的对策，你会发现它们有时完全无效，这可能是由于覆盖不完全（例如，你只堵住了一个漏洞，而实际上有很多漏洞）。还有一种情况是，你的工具链可能会优化掉你的对策，因为它们没有副作用。例如，双重检查一个值与检查一次该值在逻辑上是等价的，因此优化编译器会巧妙地去除你的双重检查。在硬件综合过程中，也会发生类似的情况，其中重复的逻辑可能会被优化掉。

如果在 C 或 C++中的变量上使用`volatile`关键字，可以帮助避免对策被优化掉。使用`volatile`时，编译器不会假设对同一个变量的两次读取会得到相同的值。因此，如果你对一个变量进行双重检查，它将不会被编译器去除。请注意，这会产生更多的内存访问，因此，如果芯片对内存访问故障特别敏感，这就是一把双刃剑。你还可以使用`__attribute__((optnone))`来关闭特定函数的优化。

Listing 14-6 中的代码是另一个例子，编译器优化将导致你的故障对策发生变化。编译器可能会选择重新排序生成的汇编代码，如果攻击者跳过了单一的分支指令，就会导致发生“掉落”条件。

目前有一些研究致力于使编译器输出更能抵抗故障的代码，这显然是一个解决方向；参见 Hillebold Christoph 的论文《编译器辅助的完整性防御抗故障注入攻击》。由于性能原因，这类技术的全面应用并不理想。

#### 仿真与模拟

在验证过程中使用仿真器也非常重要。对于硬件设计来说，从初步设计到首次硅片的周期可能需要数年。理想情况下，我们希望在硅片出现之前就能“测量”泄漏，这时还有时间进行修正。请参见 Alessandro Barenghi 等人的论文《侧信道抗性密码实现的设计时工程》。

类似的故障注入研究正在进行中：通过模拟各种指令损坏，我们可以测试是否存在单点故障注入。更多信息，请参见 Martijn Bogaard 和 Niek Timmers 的《攻击下的安全启动：通过仿真增强故障注入与防御》。Riscure 有一个开源的 CPU 仿真器，实施指令跳过和损坏，地址为[`github.com/Riscure/FiSim/`](https://github.com/Riscure/FiSim/)，你可以尝试测试你的软件反制措施。我们建议你试用这个仿真器——你可以迅速了解哪些反制措施有效，哪些无效。更重要的是，你会发现哪些反制措施组合能将故障率降到较低水平。将故障率降到零并不容易！

#### 验证与启蒙

对于反制措施的强度，你可以自己测量；对于反制措施的绕过性，最好找一个没有参与设计的人来进行评估。反制措施可以被视为一种安全系统，正如施奈尔定律所说：“任何人都能发明出一种足够巧妙的安全系统，以至于他或她无法想象任何破解的方法。”

在这个话题上，允许我们稍微偏离一下，探讨一下我们所称的*安全启蒙的四个阶段*。这是我们完全不科学的观察和主观经验，讲述人们通常如何回应硬件攻击的概念以及如何解决这些问题。

*第一阶段*是基本否认侧信道或故障攻击的可能性或实用性。问题在于，基本的软件工程假设——这些假设你一直在体验和听到——是可以被打破的：硬件实际上并没有执行它接收到的指令，并且它正将其处理的数据公之于众。这就像发现世界不是平的。

一旦通过了第一阶段，*第二阶段*就是反制措施容易或是无法被打破的。这是因为尚未完全理解安全问题的深度，反制措施的成本，或者攻击者是具有适应性的生物。通常需要一些反制措施被突破（或与安全专家进行一些“是的，但如果你这么做……”的对话）才能进入下一个阶段，也就是*安全虚无主义*。

安全虚无主义是指一切都是脆弱的，所以我们无论如何都无法防止攻击。确实，任何东西都可以被破坏，只要有动机和充足资源的攻击者——这就是关键所在。攻击者数量有限，且他们的动机和资源各不相同。就目前而言，复制一张磁条信用卡要比对一张信用卡进行旁道攻击容易得多。正如 James Mickens 所说：“如果你的威胁模型中包括摩萨德，你最终还是会被摩萨德击败。”不过，如果你不是摩萨德的目标，你大概率不会被摩萨德盯上。他们也需要做出优先级排序。

第四个也是最后一个阶段是*启蒙*：理解安全性与风险相关；风险永远不可能为零，但风险并不意味着最坏的情况总是发生。换句话说，安全性是关于让攻击者尽可能对攻击失去兴趣。理想情况下，防御措施应该提高门槛，直到攻击的成本超过了回报。或者更现实的说，防御措施使得另一个产品比你的更有攻击吸引力。启蒙是意识到防御措施的局限性，并在包含哪些防御措施时做出基于风险的权衡。这也是关于能够再次安心入睡。

## 行业认证

针对旁道分析和故障注入抗性，已经通过多个组织提供认证，我们将在本节中列出。我们从第一章知道，安全性不是二元的，那么如果没有不可打破的产品，行业认证意味着什么呢？

这些认证的目标是让供应商向第三方展示他们在某种程度上具有*保障*和*抗攻击能力*。这也意味着认证只在有限的时间内有效；一张几年前的证书显然不包括最近发现的攻击。

我们先简要考虑一下抗攻击能力。如果一个产品通过了*通用准则 PP-0084 (CC)/EMVCo*认证，说明它具备所有必要的安全功能，并且认证实验室无法证明存在一个攻击路径，其*JIL 评分*（参见第一章的“硬件攻击路径评分”）少于 31 个点。攻击路径只有在最终导致一个定义明确的资产（如密钥）遭到破坏时，才算作攻击路径。这意味着使用了正向测试和负向测试，既要确认“它做了它应该做的事”，也要确认“它没有做它不应该做的事”。后一项在面对聪明且具有适应能力的对手时尤为重要。

实际上，JIL 评分限制了可用于攻击的时间、设备、知识、人员和（开放）样本的数量。无论实验室了解或能够开发哪些攻击，只要评分在 31 分以内，这些攻击对 CC/EMVCo 都具有相关性。有关如何进行评分的良好参考，详见 JIL 文档的最新版本，标题为“攻击潜力在智能卡和类似设备上的应用”（该文档可在网上公开获取）。证书告知你该实验室未能识别出任何得分低于 31 分的攻击。实验室甚至不会测试得分为 31 分及以上的攻击是否有效。回到我们之前提到的不可破解产品，评分系统意味着你仍然可以在高评分的攻击中找到攻击方法。一个很好的例子是“解构一个‘安全’处理器”，由 Christopher Tarnovsky 于 2010 年 Black Hat 大会上展示，他令人印象深刻地超越了实验室在认证过程中可能投入的努力。

现在，让我们考虑保证级别，这是“我们有多*确定*它能抵抗相关攻击”这一方面。一方面，你可以阅读产品数据表，看到“侧信道对策”，根据数据表你可以得出结论，认为这是正确的，但它只提供了*低*级别的保证。或者，你可以花费一年的时间测试所有内容，并在你的特殊协议上通过数学证明泄漏的下限，然后你就有了*高*级别的保证。

对于 CC，保证级别定义为*评估保证级别（EAL）*；对于智能卡，你通常会看到 EAL5、EAL5+、EAL6 或 EAL6+。我们在这里不会详细讨论，但只需确保你能比你的朋友聪明，知道 EAL 并不意味着“它有多安全”。相反，它意味着“我有多确定它的安全性？”（如果你想更聪明一点，知道+表示一些额外的保证要求。）

说到*实验室*，实验室必须证明它们有能力进行最先进的攻击，这一点由标准机构进行验证。此外，对于 CC，实验室必须参与并在*联合硬件攻击小组（JHAS）*中共享新攻击。JHAS 维护着前面提到的 JIL 文档，并通过新攻击和分数更新它。通过这种方式，标准不必规定必须执行哪些攻击，这很好，因为硬件安全是一个不断发展的领域。由于攻击已包含在 JIL 中，主要由实验室选择适用于产品的相关攻击。这就带来了实验室方法的“变动”成本。后者的问题在于，供应商可以选择那些找到较少问题的实验室，因此实验室实际上面临着找到更少问题的竞争压力。确保实验室仍然符合标准的责任在于标准机构。

*全球平台（GlobalPlatform）*为其*受信执行环境（TEE）*认证采用了类似于 CC 的方法。所需的得分为 21，低于智能卡，这意味着只有当硬件攻击明显可扩展时，才被认为是相关攻击，例如通过软件手段进行的攻击。例如，如果我们使用故障注入或侧信道攻击来提取一个主密钥，从而破解任何类似的设备，则被视为相关攻击。如果我们必须对每个想要破解的设备进行侧信道攻击，并且每个设备需要一个月的时间才能提取密钥，则被视为超出认证范围，因为攻击评级将超过 21。

Arm 有一个认证程序，叫做*平台安全架构（PSA）*。PSA 有多个认证等级，三级包括对物理攻击的防护，如侧信道攻击和故障注入抵抗。PSA 总体上是为物联网（IoT）和嵌入式平台设计的。因此，它可能更适合通用平台，但如果你正在使用通用微控制器构建产品，那么 PSA 等级是你最可能看到这些设备被认证的级别。在较低的等级上，PSA 还帮助解决我们今天仍然面临的一些基本问题，比如调试接口未关闭。

另一种方法是*ISO 19790*，它与美国/加拿大标准*FIPS 140-3*对接，重点关注加密算法和模块。*加密模块验证程序（CMVP）*验证模块是否符合 FIPS 140-3 的要求。这里的方法偏重于*验证*——即确保产品符合安全功能要求。换句话说，它偏向于测试产品的强度，而非绕过能力。该标准规定了必须在产品上执行的测试类型，帮助各实验室之间的可复现性。问题在于，攻击手段发展迅速，而“由政府机构定义的标准测试集”却没有相应的更新。FIPS 140-2（FIPS 140-3 的前身）于 2001 年发布，但并没有包括验证侧信道攻击的方式。换句话说，某产品如果获得 FIPS 140-2 认证，意味着其 AES 引擎能够正确地进行 AES 加密，密钥仅限授权方访问，等等，但这也意味着密钥可能在 100 次侧信道攻击中泄露，因为 FIPS 140-2 的测试范围没有包括 SCA（侧信道攻击）。它的继任者 FIPS 140-3 用了 18 年时间才生效，且已包括以*测试向量泄漏评估（TVLA）*形式进行的侧信道测试。通过 TVLA，测试被精确地规范，但如果攻击者在过滤等方面过于巧妙，则会被排除在外。这意味着通过测试并不代表没有侧信道泄漏，而仅仅是最直观的泄漏没有被检测出来。

另一种侧信道泄漏认证方法在*ISO 17825*中有所探讨，该标准再次采用了我们在第十一章中描述的一些 TVLA 测试并进行了标准化。最终目标可能是为了达到泄漏的“数据表数据”。像 ISO 19790 一样，ISO 17825 的测试并不旨在执行与通用标准相同的工作。通用标准主要关注攻击抵抗力，而 ISO 17825 试图提供一种通过自动化方法比较特定侧信道泄漏的方式。这意味着 ISO 17825 并不打算提供跨各种攻击的通用安全度量，但当你试图理解启用某些侧信道对策的影响时，它是非常有用的。换句话说，它衡量的是对策的强度，而不是绕过的可能性。

ISO/SAE 21434 是一项汽车网络安全标准，自 2022 年 7 月起在欧盟对新车型强制实施。它规定了*安全工程*要求，并要求考虑硬件攻击。这将本书中介绍的所有攻击都纳入了汽车领域的范畴！当认证进入市场部门时，你会发现“它是安全的！”常常与“它已按某一保障级别通过了有限威胁集的认证”混为一谈。这是可以理解的，因为后者表述起来太复杂。然而，这意味着你需要了解某个产品的认证实际意味着什么，以及它如何适配你的威胁模型。例如，如果你试图验证某个系统对各种先进攻击的一般抵抗力，那么提供 ISO 17825 测试的公司显然无法满足你所需的范围。但如果你仅仅依赖标准标题（“针对密码模块的非侵入攻击类别的缓解测试方法”）和测试供应商提供的些许市场材料，你可能很容易被其价值所迷惑。当然，不同认证之间的成本和努力差异也是显著的。

认证至少帮助了智能卡行业在抗侧信道攻击和故障注入方面达到了较高的水平。没有人能轻易破解一张现代的、经过认证的卡片。与此同时，必须关注认证背后的内容，因为认证总是有其限制。

## 改进中

有许多不同的培训课程可供学习侧信道分析和故障注入。选择课程时，我们建议先了解课程大纲。本书涵盖了基础知识和理论，如果你已经掌握这些内容，那么更好的选择可能是专注于实践的课程。硬件黑客领域有来自各行各业的人。有些人可能从事了十年的低级芯片设计，但从未接触过有限域算术；而有些人则可能拥有理论数学博士学位，但从未使用过示波器。因此，当你接触某个主题时，务必搞清楚对你来说最有价值的背景知识。无论你想了解更多关于加密学、信号处理，还是 DPA 背后的数学，都要找到专注于这些主题的课程。类似地，一些培训课程更侧重于进攻而非防守，因此请找到最符合你需求的课程。（完全披露：两位作者的公司也提供培训课程。）

你还可以参加会议上的讲座，与该领域已有的专家们交流和讨论。你可以在学术会议上找到他们，例如 CHES、FDTC、COSADE，同时也可以在更多面向硬件黑客的会议上找到他们，比如 Black Hat、Hardwear.io、DEF CON、CCC 和 REcon。遇到我们时，欢迎主动打个招呼！我们期待在这些活动中见到你。

参加培训课程和参加活动也是学习新事物的绝佳方式，这不仅能拓宽你自己的背景经验，还能与他人分享你独特的背景。你可能花了多年时间从事模拟集成电路的设计，我们敢打赌你能洞察到一些电压尖峰如何在芯片内传播，而那些只接触过 FPGA 的人可能没有这种见解。

## 摘要

在本章中，我们描述了许多对策策略。每个对策都可以构成一个“足够安全”的系统的构建块，但单独任何一个都不足以保证安全。在构建对策时，还需要注意许多警告，因此请确保在开发的每个阶段验证它们是否按预期工作。我们通过各种认证策略提到了验证的专业方面。

最后，我们聊了一下如何在这个领域中持续进步。最好的老师仍然是实践。首先从简单的微控制器开始。例如，尝试使用时钟频率低于 100 MHz 的设备，并且完全由你控制，这样就没有操作系统向你抛出中断和多任务处理。接下来，开始构建反制措施，并观察它们如何抵御你的攻击，或者更好的是，找个朋友为自己构建反制措施，然后互相试图攻破对方的防线。你会发现，测试防御强度比绕过性要容易得多。一旦你在攻击和防守方面都比较得心应手，就开始增加难度：更高的时钟频率，更复杂的 CPU，目标应用的控制力下降，对目标应用的了解减少，等等。意识到你仍在学习中；一个新的目标可能让你重新感到像个初学者。继续努力，最终耐心会带来运气，运气会带来技巧。祝你在这条路上好运！
