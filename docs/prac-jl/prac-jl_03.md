## **2

**语言基础**

*学习另一种语言不仅仅是学习用不同的词表达相同的事物，而是学习另一种思维方式。*

*—*弗洛拉·路易斯

![Image](img/common.jpg)

有时刚接触编程的人会问，为什么有这么多计算机语言。它们都有不同的语法。有些使用大括号和分号，比如 C 和 JavaScript；有些使用空格，比如 Python；有些因括号多而臭名昭著，比如 Lisp 家族；还有些使用关键词，比如 Julia。

然而，语法差异并不是根本原因。有了经验，语言标点的差异变得微不足道。确实，一些语言比其他语言更快，或者在内存上有不同的要求，尽管这些通常是实现的属性，而非语言本身，但性能也不是根本原因。

不同语言和语言家族持续存在的根本原因在于它们基于不同的思想。每种语言代表了一个独特的概念框架，用来表达计算。当我们编写程序时，我们不仅仅是在告诉机器该做什么。如果真是这样，我们都应该直接写入程序最终会翻译成的机器代码。相反，我们是在告诉*人类*，包括我们自己，关于一个计算。计算机语言是人类语言。

当你开始学习 Julia 时，重要的是要牢记这一点。你并不是在学习一系列让计算机按你想要的方式做事的咒语。你是在学习一种思维方式：一套你可以用来组织计算概念的思想。如果你掌握了这些思想，你的程序将如你所期望的那样运行，性能良好，并且对其他人甚至是未来的你自己都清晰易懂。

尽管如此，这些宏观的概念将在第二部分的应用章节中展现出来。在这一章中，我们将深入细节：你将用来构建“大教堂”的砖石。

这些元素是你构建 Julia 程序的模块——函数、循环和决策——以及它们与之交互的数据类型，如字符串、各种数字和集合。完成这一章后，你将掌握足够的 Julia 知识，能够编写你的第一个程序。

### **语法：数据类型、表达式和代码块**

在这一节中，我们将学习 Julia 语法的基础，了解在几乎每个 Julia 程序中都会使用的基本结构。我们还将介绍第一个 Julia 数据类型。

在本章中，我将提到 REPL，但这些引用同样适用于任何 Julia 的交互式环境，比如 Pluto 或 VS Code。

#### ***数字类型***

Julia 中的所有值都有一个*类型*，就像几乎所有编程语言一样。基本类型之一是数字类型，但就像数学中一样，数字也有不同的类型。在数学中，我们有正数和负数，整数和实数，还有一些更为复杂的类型，如复数和四元数。正整数，或者说计数数，自古以来就存在，但其他类型的数字是由某些人发明出来的。在《用户自定义类型》一节中，第 234 页，你将学习如何在 Julia 中发明自己的数字类型，但现在让我们先看看一些内建的类型。

**注意**

*也许比本书中的任何其他章节都更重要的是，在阅读本章时一定要打开 Julia REPL 并实践你所学的内容。你可以尝试本章中的示例变体，直到你对语法感到熟悉。你将在所有的程序中反复使用本章的内容，因此现在就将这些细节变成你的第二天性将对你有所帮助。*

如果你在 REPL 中输入一个没有小数点的数字并按下 RETURN 或 ENTER，Julia 会返回相同的数字。单独的数字是一个*表达式*，意思是会返回一个结果的东西。由于计算一个普通数字的结果就是它本身，所以你会得到那个数字。这些整数默认被赋予 `Int64` 类型，意思是占用 64 位存储空间的整数。（我假设是 64 位系统，现在这个假设很安全。如果你使用的是 32 位系统，可以在本章中将 `Int64` 替换为 `Int32`。）

带有小数点的数字是 `Float64` 类型。数字 1 和 1.0 可能具有相同的值，但对计算机来说它们是不同的。第一个是 `Int64`，而第二个是 `Float64`。这种区别会在我们后续的工作中产生各种影响。

由于 Julia 的设计目的是进行科学计算，当然它也能处理复数。输入复数的语法使用 `im` 表示虚数单位（即 -1 的平方根）。因此，要输入数字 3 + 4*i*，你可以写成 `3 + 4im`。这个数字的类型叫做 `Complex{Int64}`，因为数字部分恰好是整数。`3.4 + 1.1im` 的类型叫做 `Complex{Float64}`。这个表示法意味着它是一个 `Complex` 类型，包含 `Float64` 类型的部分。

你可以使用通常的计算机科学计数法表示非常大或非常小的数字：`6.02e23` 表示 6.02 × 10²³。以这种方式书写的数字是 `Float64` 类型，即使你将尾数写成整数。指数必须是整数，如果你愿意，也可以使用大写字母 E。

Julia 会将你的输入转换为“标准”的科学计数法。例如，如果你在 REPL 中输入 `1234e19`，它会以 `1.234e22` 的形式返回该值。而且显然，它更喜欢使用小写的 `e`。

还有一些其他的数字类型，比如无符号整数 `UInt64`，但目前这些已经足够了。我们将在 第八章 中深入了解类型系统。

#### ***运算与表达式***

加法、减法和乘法在所有这些数字类型上都按预期工作。运算顺序与数学中的顺序相同，并且可以通过括号覆盖。

当需要时，Julia 会显式进行*类型提升*。表达式 `1 + 1` 仅涉及整数，结果将是整数 `2`；没有理由返回其他类型。但表达式 `1.0 + 1` 涉及浮点数，因此它将返回 `Float64` 类型的结果 `2.0`。

在 REPL 中尝试一些包含各种类型操作数的算术运算，包括复数，确保你理解类型提升是如何工作的。整数会提升为浮点数，而浮点数又会根据需要提升为复数。

##### **除法与有理数**

Julia 有*三种*除法。每种语言都必须决定如何处理类似 `1/2` 这样的表达式。问题是，两个操作数都是整数，但结果却不是。有些语言，比如 Fortran 和 Python 2，会将这个表达式的结果计算为零，因为这表示截取答案的小数点前的整数部分。其他语言会将结果提升为浮点数并返回 `0.5`；这就是 Julia 所做的。

如果你想要类似于 Fortran 的除法方式，可以使用除法符号 (`÷`)：`1` ÷ `2` 给出 `0`，而 `4` ÷ `3` 给出 `1`。要在 REPL 中输入此运算符，输入 \div 然后按 TAB（请参阅 第 13 页的“Unicode 字符”部分）。

第三种除法形式使用 `//` 运算符定义 `Rational` 数字，即两个整数的比值。使用这种数据类型，你可以对有理数进行精确的算术运算，而无需将结果转换为浮点数。例如，表达式 `1//2 + 1//3` 计算结果为 `5//6`。Julia 会将有理数简化为最简形式，因此，如果你在 REPL 中输入 `4//6`，它将返回结果 `2//3`。

如果你在 REPL 中输入 `1//2 + 1//2`，你认为会得到什么结果？如果你尝试了，可能会惊讶地发现结果打印为 `1//1`，而不是简单的 `1`。仅包含 `Rational` 数字的表达式的结果是一个 `Rational` 数字。如果你改为计算 `1//2 + 0.5`，你将得到 `Float64` 类型的数字 `1.0`。

##### **指数运算与无穷大**

要将一个数字提高到幂，使用 `^` 运算符。以下是对不同类型数字进行指数运算的结果：

```
julia> 2³
8

julia> 2⁰.5
1.4142135623730951

julia> 2^-1
0.5

julia> (1 + im)²
0 + 2im

julia> (1 + im)^(1 + im)
0.2739572538301211 + 0.5837007587586147im

julia> 0^-1
Inf

julia> (0//1)^-1
1//0
```

所有这些结果应该都是预期的，但最后两个无限大结果值得讨论。除以零，如倒数第二个表达式所示或等同于 `1/0`，结果为 `Inf`，其数据类型是 `Float64`。而 `Rational` 类型的 `1//0` 也是无限大的，但它的数据类型是 `Rational`。它的行为符合无限大的特性：由于向无限大加上一个有限数不会改变它，我们有 `1//0 + 1` 结果仍然是 `1//0`。类型提升规则依然适用，因此如果我们评估 `1//0 + 1.0`，则会得到 `Inf`：依然是无限大，但它是 `Float64` 类型的无限大。

除以无限大得到零，这是符合预期的。然而，得到的零是一个 `Rational` 零或 `Float64` 零，这取决于操作数的类型：

```
julia> 1/(1//0)
0//1

julia> 1.0/(1//0)
0.0
```

浮点数还有其他的大小，就像整数一样。如果我们设法计算 `a/b`，其中 `a` 的值为 `Float32` 类型的 1.0，而 `b` 的值为相同数据类型的 0.0，Julia 会返回另一种类型的无限大：`Inf32`。你将在第 234 页的《用户自定义类型》章节中学习如何让变量包含你选择的类型。

##### **模运算**

另一个有用的运算符 `%`，用于返回第一个操作数除以第二个操作数后的余数。例如，`5 % 2` 返回 `1`。与其他算术运算符类似，整数会返回整数，浮点数则返回浮点结果。

##### **表达式链**

我们简要地看了如何使用分号分隔表达式，并且在 REPL 中使用分号来抑制结果的打印（参见第 11 页）。如果一行中有多个用分号分隔的表达式，那么一连串表达式的结果就是最后一个表达式的结果：

```
julia> 1; 2; 5+3
8
```

我们使用 `=` 运算符在 Julia 中给变量赋值。由于表达式链的值是最后一个，因此赋值

```
r = (1; 2; 5+3)
```

结果是 `r` 的值为 8。如果我们省略了括号，`r` 的值将被赋为 1，因为此时赋值 `r = 1` 会成为一个独立的表达式。

##### **系数语法**

在没有歧义的情况下，我们可以将一个字面量数与一个变量（或稍后我们将看到的函数）并排，以表示乘法。如果并排的组合造成歧义，Julia 会报错，我们必须改用 `*` 运算符。

这种写法的乘法与使用 `*` 运算符的乘法有一个重要的区别。它的运算优先级高于其他算术运算符，因此它是运算优先级规则的例外。几个例子应该能让这一点更清楚：

```
julia> w = 2
2

julia> 2w
4

julia> 2²w
16

julia> 2²*w
8

julia> 1/2w
0.25

julia> 1/2*w
1.0
```

在表达式 `1/2*w` 中，`1/2` 先计算，结果再与 `2` 相乘。但由于连接符的优先级高于显式的算术运算符，在表达式 `1/2w` 中，`2w` 会先计算。

这种不寻常的语法特性，以及能够使用希腊字母和其他 Unicode 符号，使得代码中的数学表达更像数学公式。

##### **表达式块**

另一种将表达式组合在一起的方式是使用`begin...end`块。这个代码单元从`begin`关键字开始，就像所有 Julia 中的块一样，最终用`end`关键字结束。你可以直接在 REPL 中输入这些块。Julia 会识别你正在定义一个块，直到结构完成，才会停止提示符的输出：

```
julia> begin
           1
           2
           5 + 3
       end
8

julia>
```

与由分号分隔的表达式链一样，这组表达式的结果是最后一个表达式的结果。你甚至可以将这个块的结果赋值给一个变量：

```
julia> eight = begin
           1
           2
           5 + 3
       end
8

julia> eight
8
```

在 REPL 和其他交互式环境中（如 Pluto），表达式的值会默认打印出来。然而，如果你在运行存储在文件中的程序，你需要使用`print(expression)`才能在终端上看到值。

#### ***逻辑***

逻辑值由`true`和`false`表示，它们的类型是`Bool`。重要的逻辑运算符包括逻辑与（AND），用`&&`表示，以及逻辑或（OR），用`||`表示。这些运算符是*短路*的，这意味着，在从左到右的表达式中，一旦可以确定表达式的最终值是`true`或`false`，Julia 会停止计算并不会再评估剩余部分。例如，在表达式`false && more stuff`中，一旦 Julia 遇到`&&`运算符，它就会停止并返回`false`，而不会再尝试评估`more stuff`。它之所以能这么做，是因为这个表达式的结果必须是`false`，无论`more stuff`是`true`还是`false`。程序员需要意识到这一点，不要依赖逻辑表达式的所有部分都会被评估。在表达式如`false && (cc = 17)`中，`&&`后面的部分根本不会被查看，因此赋值操作也不会发生。

如果你需要确保逻辑表达式的所有部分都被评估，使用`&`和`|`运算符代替它们。这些是按位与和按位或运算符。它们会转换数字，正如我们将在后面的章节中看到的那样，但在应用于`Bool`类型时，它们也作为逻辑运算符使用。

`Bool`值通常来源于比较的结果，这些比较使用运算符`>`、`<`、`<=`、`>=`、`==`和`===`。等式比较的否定形式是`!=`和`!==`。`<=`运算符也可以用更好看的 Unicode 符号`≤`来表示，`>=`与`≥`同义。表达式`1 < 5`的结果是`true`，`5 ≥ 5`也是`true`，以此类推。

你可能已经注意到有两个等式比较。第一个`==`比较两个值，而不考虑类型。因此，`5 == 5.0`会返回`true`，即使一个数字是整数，另一个是浮点数。另一个等式比较测试两个值在各方面是否相同。只有当没有程序可以写出它能区分这两个值时，才会返回`true`。因此，表达式`5 === 5.0`返回`false`，因为程序确实可以区分整数和浮点数。

像`>`这样的比较运算符通常不需要配套的否定运算符，因为`>`的否定是`<=`。事实上，数学家有时会把这个比较说成“不是大于”。如果你需要将其表示为明确的否定，你必须使用语法`!(a > b)`来否定整个表达式，至少在写作时是这样。语言中是否包含否定的比较运算符（例如`!<`）正在考虑之中。

#### ***循环：while 块***

到目前为止，我们学习了一种代码块：使用`begin`的表达式块。写一个*循环*（即一段会根据某个条件持续重复的代码）的常见方式是使用另一种代码块：`while`块。像所有代码块一样，它以`end`关键字结束。终止该块的条件使用我们在上一节中学到的比较运算符。清单 2-1 展示了一个在 REPL 中执行的简单`while`块示例。

```
julia> j = 0;

julia> while j < 5
           println(j²)
           j = j + 1
       end
0
1
4
9
16
```

*清单 2-1：在 REPL 中循环*

`println()`函数会将其值打印在单独的一行上。但为什么我们需要使用它呢？因为 REPL 中的表达式应该自动打印。

`begin`块会返回一个结果，即该块中最后一个被评估的表达式。而`while`块不会返回结果，因此没有任何内容会被自动打印。我们想看到的任何内容都必须显式地打印出来。这可能是件好事，因为循环可能会评估许多表达式，并产生大量我们不想要的输出。

注意到在循环开始前对`j`变量的初始化。在 REPL 中，这会创建一个*全局*变量，任何地方都可以访问和修改它。循环结束后，`j`的值为 5。这是 REPL（以及其他交互式环境，如 Pluto）与文件中的程序行为之间的另一个不同之处。（我将在“作用域”一节中详细解释这个问题，见第 52 页。）

#### ****if 块****

Julia 具有传统的条件评估控制流，使用逻辑比较运算符（参见“逻辑”一节，第 31 页）以及关键字`if`、`elseif`和`else`。你可以根据需要嵌套`if`块；每个`if`块以`end`关键字结束。

这是一个小程序，我们可以在 REPL 中运行它，告诉我们一个数字是偶数还是奇数：

```
if n % 2 === 0
    "That number is even."
elseif n % 2 === 1
    "That number is odd."
else
    "I only deal with integers."
end
```

如果在进入这个代码块之前，你将`n`定义为一个数字，它将给你正确的答案。如果`n`未定义或不是数字，你将收到错误消息。

`===`比较两个整数时，代码会拒绝处理任何非整数类型的数字。试试将`n = 6`和`n = 6.0`代入代码，看看会发生什么。

与`while`块不同，`if`块会返回一个结果，因此不需要显式的`print()`语句。

**注意**

*我在本书中通过缩进来明确代码块的结构。缩进在 Julia 中没有语法意义，但使用它是一个好习惯，可以让程序更容易阅读。你可以根据需要缩进代码行，或者根本不缩进，它不会影响代码的执行。空格用于分隔标记，换行符在作为语句和表达式分隔符的作用上等同于分号。除此之外，Julia 一般不在意空白符。*

### **数组**

到目前为止，我们看到的各种数字都是存储单一值的类型。数组是 Julia 数据类型的一类，用于存储*值的集合*。科学计算通常涉及对向量、矩阵或更高维度数组的操作，而 Julia 提供了一个便捷、简洁的语法来操作这些数据结构，同时提供了优秀的数组性能。

尝试在 REPL 中输入 [1, 2, 3]。这是创建一个一维数组的语法，也叫做*向量*，包含三个元素。它的数据类型叫做 `Vector`。与之前一样，REPL 会将表达式打印出来，但这次以不同的形式：

```
julia> [1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3
```

它还会在值之前打印出一些关于即将显示的值类型的信息。当在 REPL 中打印比简单数据类型更复杂的内容时，Julia 通常会这样做。提供这些信息是为了帮助你解读显示内容。这是有用的，因为在构造数组时，Julia 可能会在某些情况下更改你包含的某些元素的类型，了解这一点是很有帮助的。此外，关于数组形状的反馈可以告诉你数组操作是否按预期执行。

这是一个 Julia 改变某些数字类型的例子：

```
julia> a = [4, 5.0, 6]
3-element Vector{Float64}:
 4.0
 5.0
 6.0
```

我们给 `a` 赋一个值，作为一个包含三个元素的字面量数组：一个整数、一个浮点数和另一个整数。REPL 返回的消息确认这是一个 `3-element Vector`，但 `Vector{Float64}` 表示 `Vector` 的元素都是 `Float64` 类型。Julia 已经将整数提升为浮点数。我们可以通过查看它打印的数字来确认这一点，现在这些数字都带有小数点。当你用像刚才显示的那种字面量表达式初始化数组时，Julia 总是会尝试通过提升值来使其元素类型统一。这有助于后续对数组的计算性能。数字的垂直排列是 Julia 在可能的情况下打印向量的方式。正如我们稍后将看到的，它有打印各种形状数组的惯例。

有时，无法对元素进行提升，使它们都具有相同的类型。数组的元素可以是任何东西，包括其他数组，如示例 2-2 所示。

```
julia> a = [4, [5.0, 6], 7]
3-element Vector{Any}:
 4
  [5.0, 6.0]
 7
```

*示例 2-2：一个异质数组*

Julia 仍然遵循打印约定，将元素按列排列。第一个和第三个元素是整数，第二个元素是一个向量。但请注意，Julia 如何将该向量中的整数`6`提升为浮点数，以确保*它*的所有元素类型一致。REPL 中的信息告诉我们，这个完整向量的类型是`Vector{Any}`，这意味着它是一个可以容纳任意类型混合的`Vector`。这个特定的数组包含两个`Int64`类型元素和一个`Vector{Float64}`类型元素。

我们可以通过*索引*使用方括号来获取或赋值数组元素。与 Fortran 及许多其他为科学和数学工作设计的语言一样，Julia 中的数组索引是从 1 开始的。

在以下示例中，我在进行 Listing 2-2 中的赋值后，将一些数组索引表达式输入到 REPL 中：

```
julia> a[1]
4

julia> a[end]
7

julia> a[2]
2-element Vector{Float64}:
 5.0
 6.0

julia> a[2][2]
6.0
```

注意使用关键字`end`来指向数组的最后一个元素；当你不知道数组长度时，这非常方便。数组的第二个元素是另一个数组；我们可以通过双重索引在一个表达式中索引该数组，如最后一个表达式所示。如果你确实需要找出数组的长度，可以使用`length()`函数。

### **范围**

Julia 可以通过一种特殊的表示法构造数字范围。语法`1:5`表示一个从`1`到`5`（包含 5）的整数范围，步长为 1。你可以通过使用包含三个数字的语法版本来按 1 以外的数字进行计数。例如，`1:3:12`表示一个包含数字`1, 4, 7, 10`的范围。范围也可以倒序计数，使用负步长，例如`5:-1:2`。最后，范围中的任何数字都可以是浮点数而非整数，这种情况下范围中的所有数字都将是浮点数。

范围不是数组。它们处于一种潜在的维度中，随时可以通过使用将其带入现实。与此同时，它们几乎不占用空间。将它们带入现实的一种方法是使用`collect()`函数，将其转化为真正的`Vector`：

```
julia> collect(1:5)
5-element Vector{Int64}:
 1
 2
 3
 4
 5
julia> [collect(1:2:10), collect(2.5:-0.5:0)]
2-element Vector{Vector{Float64}}:
 [1.0, 3.0, 5.0, 7.0, 9.0]
 [2.5, 2.0, 1.5, 1.0, 0.5, 0.0]
```

第一个示例将范围转换为向量，而第二个示例在字面向量内部使用了两个`collect()`操作，从而得到了一个包含两个向量的向量。

范围最常用的方式是在`for`循环中，具体内容请见“更多循环：for 块”章节，位于第 46 页。

范围在索引表达式中也很有用，可以从数组中提取多个元素：

```
julia> v = collect(0:5:20)
5-element Vector{Int64}:
  0
  5
 10
 15
 20

julia> v[2:4]
3-element Vector{Int64}:
  5
 10
 15

julia> v[end:-2:1]
3-element Vector{Int64}:
 20
 10
  0
```

这些示例展示了我们如何通过使用递减范围提取数组的子集并方便地反转元素顺序。我们可以通过提供带有步长的范围来提取不连续的元素。例如，`v[1:2:5]`将得到`[0, 10, 20]`。

#### ***数组：超越第一维***

到目前为止我们看到的`Vector`（向量）是一个一维的`Array`（数组）。尽管`Vector`的元素可能包含其他集合，但`Vector`本身仍然是一维的。Julia 有任意维度的数组。一维数组有自己的类型，因为它们是一个常见的特殊情况，并且可以对处理它们的程序进行优化。

##### **矩阵**

具有两维的数组也有一种特定类型，称为`Matrix`（矩阵）。矩阵在数学和物理学的许多场合以及各种计算中都有应用。它们表示线性变换，能够旋转向量，编码线性方程组的系数，用作简单的数据表等等。

可以把矩阵看作是一个矩形的值表。你可以直接输入这样的表来定义它们：

```
julia> m = [5 6
            7 8]
2×2 Matrix{Int64}:
 5  6
 7  8
```

当我将矩阵`m`的定义输入 REPL 时，我在数字`6`后按下 ENTER 键以插入换行符。Julia 的 REPL 知道由于方括号未关闭，输入还未完成，因此不会尝试计算任何内容，而是等待更多的输入。在我关闭括号并按下 ENTER 键后，REPL 看到一个完整的表达式，将其赋值给变量`m`，并返回该表达式，前面附带了它的形状（`2`×`2`）、类型（`Matrix`）以及集合元素的类型（`Int64`）的描述。

你可以利用这种行为将表达式分割到多行，如下例所示：

```
julia> (1 + 1
          + 1
       )
3
```

如果没有开括号，第一行的加法将会立即执行，因为它是一个完整的表达式。

##### **矩阵与向量的向量**

确保你理解`2`×`2`矩阵`m`和这个向量之间的区别：

```
julia> v = [[5, 6], [7, 8]]
2-element Vector{Vector{Int64}}:
 [5, 6]
 [7, 8]
```

后者是一个一维数组，而前者是一个二维数组。

一些索引操作应该能让这一点变得清晰：

```
julia> v[1]
2-element Vector{Int64}:
 5
 6
```

在这里，`Vector v`的第一个元素本身就是一个向量。

双重索引选择第一个元素的第二个元素：

```
julia> v[1][2]
6
```

在这种情况下，我们得到数字`6`。

单独的冒号表示选择所有内容——在这种情况下，选择整个第二个元素，即一个`Vector`（向量）：

```
julia> v[2][:]
2-element Vector{Int64}:
 7
 8
```

在这个例子中，单独的冒号是不必要的，因为仅使用`v[2]`就能得到相同的结果。

由于`m`是一个`Matrix`（矩阵），即二维数组，我们使用两个索引来选择它的元素：

```
julia> m[1, 1]
5
```

在这个表达式中，索引`[1, 1]`表示第一行第一列，其中数字`5`位于此处。

在`Matrix`中，冒号索引非常有用：

```
julia> m[2, :]
2-element Vector{Int64}:
 7
 8
```

这里选择的是整个第二行。

##### **标量索引**

对于一个*n*维数组，通常的索引方式是使用*n*个索引：一个用于向量，两个用于矩阵，依此类推，如上面所示的例子。如果使用错误数量的索引，会出现错误：

```
julia> m[1, 2, 3]
ERROR: BoundsError: attempt to access 2×2 Matrix{Int64} at index [1, 2, 3]
```

Julia 在抱怨我们试图将一个二维数组按三维数组的方式索引。

如果我们仅使用一个索引来访问`m`，就像它是一个向量一样，你认为会得到什么结果？奇怪的是，我们并不会得到错误，但一开始可能不容易理解为什么会得到这些特定的结果：

```
julia> m[1]
5

julia> m[2]
7

julia> m[3]
6

julia> m[4]
8
```

显然，我们可以像访问一维数组一样访问这个矩阵的四个元素，它们似乎是按列排列的。确实如此，这反映了矩阵中的数字在内存中的排列方式。数字 5、7、6 和 8 是按列顺序读取矩阵内容的，从第一列开始，接着是第二列。这被称为*列主序*，是元素在内存中的存储方式。

“二维数组”这样的概念是为了简化计算和编程而提出的抽象。在计算机中，数组的元素是以一长行存储的。Julia 中的`Vector`、`Matrix`或其他`Array`类型的数字保证是连续存储的。使用单一整数作为索引被称为*标量索引*。

标量索引的范围可以从 1 到矩阵的总大小。如果我们尝试使用`m[5]`，会得到一个错误信息，因为该矩阵只有四个元素。

Julia 程序员不必过于关注数据结构的机器表示，也不需要过多考虑它们在内存中的排列方式，但这个细节很重要。对矩阵元素进行循环的计算应该按照列主序进行，而不是行主序，因为前者会访问内存中连续的值，从而提高效率。

##### **使用数组索引数组**

除了数字和范围外，索引表达式的元素本身也可以是向量。列表 2-3 设置了一个稍大的矩阵，让我们有更多的空间来操作。

```
   julia> m = [11 12 13 14
               15 16 17 18
               19 20 21 22];

➊ julia> m[2, [2, 3]]
   2-element Vector{Int64}:
    16
    17

   julia> m[[1, 2], [3, 4]]
   2×2 Matrix{Int64}:
    13  14
    17  18
```

*列表 2-3：使用向量进行索引*

在定义了一个 3×4 的`Matrix`之后，我通过使用向量来表示列部分的索引表达式 ➊，提取了第二行的第二和第三列的元素。由于结果是一维的，Julia 会将这些元素放入一个`Vector`中。

然后我提取了前两行和第三、第四列的元素。由于结果是二维的，因此它变成了一个（较小的）`Matrix`。

我们已经看到，当我们使用单一索引访问多维数组的元素时，Julia 会将其解释为在按列主序排列的一个维数组中的索引。

在对数组进行索引时，您可以引用它的所有维度：

```
Array[rows, columns, third_dimension, fourth_dimension]
```

在这种风格下，每个用逗号分隔的表达式必须是一个`Vector`或数字。（数字被当作一个元素的`Vector`，正如`5[1]`的结果所示。）这些`Vector`可以是范围表达式或简单的冒号，冒号会被解释为它们所代表的`Vector`。

或者，您可以将其当作`Vector`来索引：

```
Array[Array]
```

使用第二种风格时，索引表达式中的 `Array` 可以具有任何形状。结果将具有该 `Array` 的形状。它可能比原始的 `Array` 更大，因为可以重复元素。唯一的限制是，如果原始 `Array` 有 *n* 个元素，你只能在范围 [1, *n*] 内使用索引。第一个风格也有相同的限制，但适用于每个单独的索引向量，其中 *n* 表示该维度上的数组长度。换句话说，你不能索引不存在的元素。

让我们再看看第二种索引风格，使用之前定义的 `Array m`，并通过几个示例来展示：

```
julia> m[[2 3
          4 5]]
2×2 Matrix{Int64}:
 15  19
 12  16

julia> m[[end 1 9
          9   1 end]]
2×3 Matrix{Int64}:
 22  11  21
 21  11  22
```

在这两种情况下，结果的形状与用作索引的数组相同。`end` 关键字选取源数组中的最后一个元素。在第一种索引风格中，它选取相关维度上的最后一个元素。

##### **连接操作符**

在定义矩阵时，使用换行符表示一行的结束并不总是方便的，因此在 Julia 中，你可以改用分号：

```
julia> m1 = [6 7
             8 9];

julia> m2 = [6 7; 8 9];

julia> m1 == m2
true
```

换行符和分号都是表示 *垂直连接操作符* 的方式。这也有一个名字，叫做 `vcat`，因此构造 `m1` 或 `m2` 矩阵的另一种方式是使用 `vcat([6 7], [8 9])`。在这个表达式中，`[6 7]` 和 `[8 9]` 是传递给 `vcat()` 函数的两个 *参数*。

在之前的 `m1` 和 `m2` 定义中，数字 `6` 和 `7` 之间使用的空格也是一个操作符，叫做 *水平连接操作符*。它也有自己的显式函数，叫做 `hcat()`。理解 `[6, 7]`（一个包含两个元素的 `Vector`）和 `[6 7]`（一个通过空格进行水平连接的 `1`×`2` 矩阵）之间的区别很重要。（标签也可以代替空格用于此目的。）

以下是一些最终示例，用于阐明两种不同连接方式的结果。这里有一种构造矩阵的方式：

```
julia> [[6 7]; [8 9]]
2×2 Matrix{Int64}:
 6  7
 8  9
```

这种构造将垂直和水平连接结合在一个表达式中。数字之间的空格将它们水平连接成每个有一行的数组。分号将这些矩阵垂直连接成一个更大的矩阵，第一行位于第二行之上。

用空格替换分号会产生不同的形状，将两个一行的矩阵水平连接成一个更长的一行矩阵：

```
julia> [[6 7] [8 9]]
1×4 Matrix{Int64}:
 6  7  8  9
```

在第三个示例中，我们将请求将两个 *向量* 水平连接：

```
julia> [[6, 7] [8, 9]]
2×2 Matrix{Int64}:
 6  8
 7  9
```

在这个示例中的结果让一些刚接触该语言的人感到惊讶。你可能不会立即明白为什么我们没有得到与前一个示例相同的结果。水平连接实际上意味着，对于一个 `Matrix`，沿着第二维度连接。由于 `Vector` 没有第二维度，Julia 必须先将每个 `Vector` 转换为 `2`×`1` 矩阵，然后沿着列维度将它们连接起来。

但是当我们要求 Julia *垂直* 拼接向量时，不会遇到这种问题，因为这意味着沿着它们的第一个维度进行连接：

```
julia> [[6, 7]; [8, 9]]
4-element Vector{Int64}:
 6
 7
 8
 9
```

结果是一个更长的 `Vector`。

#### ***元组***

`Tuple` 类似于 `Vector`，但重要的区别是，一旦创建，就不能再改变它。初始化 `Tuple` 的方式与创建 `Vector` 相同，只是使用圆括号而不是方括号，或者如果不造成歧义，可以完全省略圆括号，如 示例 2-4 中所示。

```
   julia> tup1 = (5, 6)
   (5, 6)

   julia> tup2 = 5, 6
   (5, 6)

   julia> tup1 === tup2
   true

➊ julia> tup1[1]
   5

➋ julia> tup1[1] = 9
   ERROR: MethodError: no method matching [...]
```

*示例 2-4：元组的一些属性*

这个示例展示了圆括号是可选的，并且两个包含相同值（顺序相同）的元组是不可区分的，因为它们通过了 `===` 比较。

**注意**

*当一个元组只包含一个元素时，它必须用圆括号括起来，并在元素后面加上逗号——例如，* (3,)*。*

我们可以像处理向量一样索引元组 ➊，但不能对元素位置 ➋ 进行 *赋值*，也不能以任何方式改变元组。

无法改变的类似向量的集合有什么用处？元组可以用来存储我们希望确保不会被意外修改的值列表。它们的主要用途是作为函数的参数和收集结果，正如我们稍后将看到的那样。

#### ***成员资格***

Julia 提供了另一个逻辑运算符，用于测试某个元素是否属于某个集合。它是 `in` 运算符，也可以表示为 `∊`，可以在 REPL 中通过输入 `\in` 然后按 TAB 键来实现。在这种情况下，建议使用 Unicode 版本，因为它有一个取反的形式，表示“not in”，看起来像 `∉`，可以在 REPL 中通过输入 `\notin` 然后按 TAB 键来实现。

下面是一些示例：

```
   julia> 2 ∈ [1, 2, 3]
   true

   julia> 2 ∉ [1, 2, 3]
   false

➊ julia> 2 ∈ [1, 2.0, 3]
   true

➋ julia> [2, 3] ∈ [2, 3, 4]
   false

➌ julia> [2, 3] ∈ [[2, 3], 4]
   true
```

成员资格使用值的比较 ➊，而不是对象身份，这可能不是你所期望的。

在 ➋ 中，我们得到 `false`，因为 `Vector [2, 3]` 不是 `Vector [2, 3, 4]` 的成员。在接下来的示例 ➌ 中，我们得到一个 `true` 结果，因为 `Vector [2, 3]` *是* `[[2, 3], 4]` 的成员。

### **字符串和字符**

Julia 有点不同，单引号和双引号有不同的含义：单引号表示字符，双引号表示字符串。`Char` 和 `String` 是两种不同的数据类型。

#### ***字符***

`Char` 是通过一对单引号输入的。Julia 是在 Unicode 时代诞生的，因此它免于像 Python 等旧语言的痛苦过渡。Julia 完全支持 Unicode。一个 `Char` 可以是任何 Unicode 字符，例如 `'5'`、`'a'`、`'ñ'` 或 `'∑'`。在底层，它是一个 32 位的值，代表该字符及其 UTF-8 编码。这个值具有一些数字的属性，但实际上并不是数字。

字符是有序的，所以你可以询问 `'a' < 'z'`，Julia 会告诉你 `true`。

**注意**

*在许多编程语言中，单引号和双引号可以互换使用，它们都表示字符串或字符，而字符是只有一个字母或符号的字符串。像 Elixir 和 SQL 一样，Julia 区分字符串和字符数据类型：* "ab" *是一个字符串，而* `'`*ab*`'` *则是一个语法错误。*

你可以将整数加到字符上，比如`'a' + 1`，Julia 会给你下一个字符`'b'`。减法也给出类似的结果。你甚至可以减去两个字符，找出它们之间的距离：`'c' - 'a'`等于`2`，这意味着`'a' + 2`等于`'c'`。然而，字符的加法是不允许的。

#### ***字符串***

`String`用双引号表示，比如`"François"`。它是一种集合类型，在某些方面类似于`Vector`，但有一些复杂性。由于它是由字符组成的序列，你可以通过将单个字符连接起来创建一个字符串。用于此的操作符通常是`*`。Julia 的设计者决定不使用更常见的`+`操作符，原因有几个，其中之一是加法是交换的，但字符的连接显然不是：`'a' * 'b'`产生字符串`"ab"`，但`'b' * 'a'`则产生不同的字符串`"ba"`。你也可以通过连接其他字符串来构建一个字符串：`"Fran" * "çois"`变成了`"François"`。

由于字符串是集合，你可以使用成员运算符来测试它们，但仅限于测试字符的出现情况：`'a' in "abc"`会返回`true`。

如果你想测试一个字符串中是否存在另一个字符串，甚至是一个由单个字符组成的字符串，可以使用`occursin()`函数：`occursin("a", "abc")`会返回`true`。

当像处理向量一样处理字符串时，会出现一个复杂的问题，即试图对它们进行索引时：

```
julia> n = "François"
"François"

julia> length(n)
8

julia> n[end]
's': ASCII/Unicode U+0073 (category Ll: Letter, lowercase)

julia> n[1]
'F': ASCII/Unicode U+0046 (category Lu: Letter, uppercase)

julia> n[5]
'ç': Unicode U+00E7 (category Ll: Letter, lowercase)

julia> n[6]
ERROR: StringIndexError: invalid index [6], valid nearby indices [5]=>'ç', [7]=>'o'
```

一切进展顺利，直到遇到最后一个表达式。从`String`中提取单个元素时，我们得到了预期的`Char`。为什么`n[6]`不能直接返回第六个字符呢？更奇怪的是，如果我们尝试`n[8]`，我们并没有得到最后一个字母，而是得到了`'i'`。如果我们尝试`n[end]`，我们*确实*得到了最后一个字母。

这些谜团的原因在于，不同的 Unicode 字符占用的空间不同。`String`中的索引是通过从`String`的开头开始计算字节数，或者说 8 位单位数来确定的。像“F”和“r”这样的普通 ASCII 字母每个占用一个字节，但“ç”恰好占用两个字节。因此，当按字节计数时，它从位置 5 开始，但下一个字符位于位置 7，正如错误信息所告知的那样。我们之所以收到错误，是因为不允许“内部”索引一个字符。

有一些复杂的方法可以避免这个问题，通过查找任何`String`的合法索引。幸运的是，你不必学习这些技巧，因为通常不需要直接索引字符串。如果你需要遍历`String`或任何其他集合的元素，有一种更简单的方法，我们将在下一节中介绍。

对于非常长的字符串，尤其是那些包含换行符并且可能包含引号字符的字符串，有一种更方便的语法。使用三个双引号来界定这些字符串：

```
julia> ls = """
       Line one.
       Line two "with a quoted section"!
       We're done.
       """
"Line one.\nLine two \"with a quoted section\"!\nWe're done.\n"

julia> print(ls)
Line one.
Line two "with a quoted section"!
We're done.
```

在这个例子中，使用`print()`显示字符串与它们作为结果返回时有所不同。

### **更多循环：for 块**

到目前为止，我们已经学会了通过使用`while`块并结合停止迭代的条件来迭代代码段或循环。这适用于我们想要重复执行某个操作直到某个条件变化的情况——例如，当从网络套接字读取数据直到套接字关闭，或者计算一个逐渐更精确的方程解直到误差小于某个容忍度。在其他情况下，我们只是希望循环固定次数或遍历集合的成员。此时，`for`循环就派上用场了。

要循环固定次数，可以使用范围表达式。这个循环重复计算清单 2-1 中的内容：

```
julia> for j in 0:4
           println(j²)
       end
0
1
4
9
16
```

这个版本更简单，因为我们不需要在每次迭代时给`j`加 1。变量会依次取范围表达式中的值，每次循环时进展到下一个值。与`while`循环一样，`for`循环不返回结果，因此我们需要显式的`println()`语句。

我们可以使用任何类型的范围表达式：

```
julia> for q in 8:-2:1
           println(1/q)
       end
0.125
0.16666666666666666
0.25
0.5
```

在这里，我们从 8 递减到 1，每次递减 2。

**注意**

*你可以将* = *替换为关键字* in *，在任何* block 中使用*，如果你更喜欢这样。还有一个更复杂的选项：你可以使用成员符号* `∈`*，我们第一次在“**成员**”中遇到它，见第 43 页**。*

你可以根据需要嵌套任意数量的`for`块。如果你有一个连续的循环体，意味着在任何循环变量（例如以下清单中的计数器`i`和`j`）的更新之间不需要执行任何操作，Julia 提供了一种简洁的语法，避免了页面上深度嵌套的结构：

```
julia> for i ∈ 0:3, j ∈ 4:6
           println([i, j, i + j])
       end
[0, 4, 4]
[0, 5, 5]
[0, 6, 6]
[1, 4, 5]
[1, 5, 6]
[1, 6, 7]
[2, 4, 6]
[2, 5, 7]
[2, 6, 8]
[3, 4, 7]
[3, 5, 8]
[3, 6, 9]
```

所有循环指令都在一行中，我们只需要一个`end`语句。

相同的`for`块语法允许我们遍历向量、矩阵或其他容器：

```
julia> for x in [-19 23 0]
           println(abs(x))
       end
19
23
0
```

在这个例子中，`x`取`1`×`3 矩阵`中的值，并对每个值应用绝对值函数。

循环也可以用于`Vector`和`Tuple`数据类型，但是如果在`for`语句中使用`Tuple`，则需要将其括在圆括号内。

你可以遍历任何维度的数组：

```
julia> for x in [[-19 23 0]; [-1 22 -17]]
           println(abs(x))
       end
19
1
23
22
0
17
```

元素以列主序打印，反映了它们在内存中的布局。

由于字符串也是容器，你可以对它们进行循环：François

```
julia> for c ∈ "François"
           print(c * " • ")
       end
F • r • a • n • ç • o • i • s •
```

在这个例子中，我们不必担心 Unicode 字符的不同长度，因为`for`循环知道如何从一个字符步进到下一个字符。

### **函数**

Julia 中的项目是围绕一组*函数*组织的。这些函数类似于数学中的函数，因为它们是值到其他值的映射。在 Julia 中，输入和输出的值可以是任何类型。

这是定义函数的方法：

```
julia> function double(x)
           2x
       end
double (generic function with 1 method)
```

`double()`函数接受一个数字并返回该数字的两倍。暂时不用担心 REPL 返回的信息，你会在“函数与方法：多重派发”一节中了解它的含义，详见第 229 页。

像这样的简单函数有一种替代语法。你可以将这个函数定义块简化为如下形式：

```
double(x) = 2x
```

注意，我们不需要`print()`语句，因为函数会返回它评估的最后一个表达式。通过在 REPL 中输入像`double(-3.1)`这样的表达式来试试吧。任何`2x`合理的地方都能正常工作，但如果你提供了一个不合适的参数，比如字符串，Julia 会返回一个错误信息。

在函数的定义中，`(x)`部分实际上是一个包含一个元素`x`的`Tuple`，它是`double()`的唯一*参数*。

函数可以有任意数量的参数。这里有一个函数，如果你提供它的终点的 x、y 和 z 坐标，它会返回从原点到该向量的长度：

```
julia> function length3d(x, y, z)
           sqrt(x² + y² + z²)
       end
length3d (generic function with 1 method)

julia> length3d(1, 1, 1)
1.7320508075688772
```

如果你希望函数停止并返回一个值，使用`return`语句。我们可以用它来修改我们的`length3d()`函数，只接受正坐标：

```
julia> function length3d(x, y, z)
           if x < 0 || y < 0 || z < 0
               return "I only work with positive coordinates."
           end
           sqrt(x² + y² + z²)
       end
length3d (generic function with 1 method)
```

如果我们用所有正数的参数调用`length3d()`，一切正常：

```
julia> length3d(1, 1, 1)
1.7320508075688772
```

但是一个负数参数会触发`return`语句：

```
julia> length3d(1, 1, -1)
"I only work with positive coordinates."
```

当你用括号和参数调用函数的名字时，你是在用这些参数执行该函数。这被称为*调用*函数。如果你提供了错误的参数个数，比如尝试调用`length3d(1, 1)`，你会收到一个错误。当我们想要*引用*函数而不调用它时，我们只需使用它的名字，不加括号或参数：例如，`length3d`。我们可以将函数赋值给变量，将它们作为参数传递给其他函数，并像对待其他任何值一样处理它们。

清单 2-5 中的函数接受一个值和另一个函数作为参数，并宣布应用提供的函数到该参数的结果。它适用于任何一个参数的函数，只要你提供一个`f`能够处理的参数`x`。

```
julia> function tellme(f, x)
           print("The result is ")
           f(x)
       end
tellme (generic function with 1 method)
```

*清单 2-5：一个函数接受另一个函数作为参数*

现在，如果我们调用`tellme(double, 3)`，我们将在终端看到字符串`The result is 6`。如果我们调用`tellme(abs, -17)`，函数会打印`The result is 17`。

这两个例子使用了我们定义的`double()`函数和内置的绝对值函数。

我之前提到过，你不需要使用`print()`语句来查看函数返回的结果，所以你可能会好奇这里为什么会有一个。一个函数返回它最后计算的表达式的值，或者如果遇到`return`语句会立即返回。如果我们省略了`print()`语句，仅保留字符串，它的值会被计算出来，但不会被返回，因为它不是最后的表达式。函数的执行会继续到下一行，并返回值`*f*(*x*)`。

`print()`语句不是一个表达式，而是一个*语句*，意味着它不会返回结果；相反，它具有在终端上输出内容的*副作用*。因此，这个函数产生了副作用，然后继续执行下一行（最后一行），那是一个表达式，函数返回它的值。

副作用是指任何改变世界状态的操作，比如创建文件、打印到终端，或者从互联网下载某些内容。*纯函数*是没有副作用的函数，它只返回结果。尽可能编写纯函数可以使你的代码更容易调试和推理，并且帮助函数变得*可组合*，这是下一节的主题。

#### ***函数组合***

就像在数学中一样，*组合*函数意味着将一个函数的输出作为下一个函数的输入。Julia 提供了三种函数组合的语法。前两种与常见的数学符号相同，而第三种则是一个稍微不同的概念。下面是所有三种方法，用于将我们的`double()`函数应用两次：

```
julia> double(double(3))
12

julia> (double ○ double)(3)
12

julia> 3 |> double |> double
12
```

第一种方法使用了应用函数到参数的语法，其中参数是应用于数字`3`的函数。数字被加倍，结果也被加倍。

第二种方法使用了数学家们有时用来表示组合的符号，外观更加整洁，特别是我们可以在第一个括号内组合任意多的函数，而使用第一种方法时会导致括号的不断增加。所有的函数被组合成一个单一的复合函数，应用到第二组括号中的参数列表上。你可以在 REPL 中输入小圆圈符号，通过` \circ `然后按 TAB 键。

最后一种选择是从左到右执行，而前两种从右到左执行。它使用*管道操作符*`|>`来创建一个*管道*。管道中的第一个函数接受开头的值（此处为 3），并将该值应用到该函数上，结果会传递到下一个函数，依此类推。这个方法是那些不喜欢括号的人特别钟爱的，它特别适用于表示数据通过一系列转换的处理过程。

三种函数组合的语法是完全等价的。选择使用哪一种语法取决于个人偏好以及特定情况中的便利性。

#### ***创建匿名函数***

有时你需要在“临时”情况下定义一个函数，而不赋予它一个名称。这通常发生在你想将一个函数作为参数传递给另一个函数时，但你传递的函数只需要在外部函数执行的计算期间存在。也就是说，它是一次性的。

匿名函数的语法使它们作为映射操作的作用变得明确，使用运算符`->`来表示映射。要定义一个匿名的倍增函数，可以写作 `x -> 2x`。

如果函数有多个变量，请将它们用括号括起来：`(x, y) -> x/(1 + y)`。

我们将在第四章中广泛使用匿名函数，届时它们将使我们能够轻松地绘制数学函数。

#### ***广播***

Julia 中最有用和最具创新性的运算符之一就是不起眼的点号。通过这个单一字符，你可以将任何函数转变为对数组逐元素操作的函数，这个过程称为*广播*。

你可以通过简单地在函数名称后加一个点号来将自己的函数转变为数组函数：

```
julia> f(x) = 2x
f (generic function with 1 method)

julia> f.([1, 2, 3])
3-element Vector{Int64}:
 2
 4
 6
```

在这里，我们定义了一个倍增函数并将其广播到一个向量的元素上。当然，广播适用于任何形状的数组。

关于 Julia 中函数的核心思想还有很多要说的。和本章中的大多数话题一样，这只是一个简介。你将在后续章节中遇到函数的其他方面，随着需求的变化我们会进一步学习。

### **作用域**

变量的*作用域*指的是代码中它可见且可修改的区域。当你在任何代码块之外定义一个变量，如 `a = 1`，变量 `a` 就是*全局的*，因为它是在*全局作用域*中定义的。

REPL 或 Pluto 中的交互式计算风格导致了全局变量的常规使用，因为我们在一个交互式的工作空间中进行即兴创作，方便让所有内容都能立即使用。然而，在编写文件中的永久程序时，最好限制对全局变量的使用。它们最好限制为需要在项目中多个函数之间共享的常量。

如果你需要使用这种全局常量，可以使用 `const` 关键字声明它们；例如，`const e = exp(1)`。这不仅确保你不会意外地更改它们的值，还能帮助编译器生成更快的代码。

这种做法有几个好处。首先，它允许你将一个函数从一个文件移动到另一个文件，或者在不担心它们是否依赖于其他地方定义的全局变量的情况下重用你的函数。它保持函数的自包含性。

在非交互式环境中，循环和函数的作用域规则有所不同。掌握它们之后，我们将学习一种规则的轻微修改，使得在 REPL 中工作更加方便。

不是所有的块都会创建局部作用域。以`begin`关键字开头的表达式块（参见《表达式块》在第 30 页）不会创建自己的作用域。它们的作用域与它们所包含的块相同。如果`begin`块位于顶层，那么它就在全局作用域中。

对于`if`块也是如此：就作用域而言，它们只是其直接环境的一部分。

本章引入的其他块建立了*局部作用域*，但有两种不同的类型。一个作用域适用于函数定义块，而另一个作用于`for`和`while`块。

#### ***函数的作用域规则***

在函数定义内，所有变量默认为局部变量，除非你使用`global`关键字修饰它们。你可以在函数定义的任何地方使用这种符号一次，因为在同一个块内，变量只能属于一种类型。

如果你将一个尚不存在的变量赋值给一个变量，则会创建一个新变量。如果它*已经*存在，由于函数定义位于另一个块内，并且它已经在该块中定义，那么会使用那个预先存在的变量。

这些都与作为函数参数传递的变量无关。那些只是局部变量；但请参见《可变性》一节，见第 55 页。

一些例子应该有助于澄清这一点：

```
s = 0
function glos()
    s = s + 1
end

glos()
```

如果你将这个列表保存到文件中，并通过输入`julia` `*filename*`来运行它，你会收到一个错误消息，提示`s`未定义。尽管`s`在全局作用域中已被定义为 0，但在函数定义内的赋值操作会创建一个新的局部变量。然而，在语句的右侧，这个变量是未定义的。

然而，这个程序文件在运行时没有错误：

```
s = 0
function glos()
    print(s)
end

glos()
```

它输出`0`。由于在函数体内没有对`s`进行*赋值*，因此没有创建新的局部变量，函数使用的是现有的全局变量。

如果我们确实在第一个例子中打算使用那个全局的`s`呢？

```
s = 0
function glos()
    global s = s + 1
    print(s)
end

glos()
```

这个程序输出`1`。在函数内声明`s`为`global`意味着函数内部的变量与外部的变量是相同的。

我们已经查看了函数内定义的变量与全局变量之间的关系。我们还需要考虑，如果函数块内的变量与函数外的*局部*变量同名会发生什么。这种情况可能发生在一切都被包含在另一个块内——比如另一个函数定义中：

```
function outer()
 ➊ s = 0
    function glos()
     ➋ s = s + 1
    end
    glos()
    print(s)
end

outer()
```

当这个程序运行时，它输出`1`。变量`s`是一个局部变量，因为它在函数块内定义 ➊。因此，根据作用域规则，当它在内部函数`glos()` ➋内被赋值时，并不会创建一个新的局部变量；相反，会使用现有的变量。

#### ***循环的作用域规则***

`for`块和`while`块都创建局部作用域，但它们与函数块的行为有一个小的不同之处。

如果在循环内给一个变量赋值，且全局作用域中已存在同名变量，两个事情会发生：变量在循环内被视为局部变量，循环内发生的任何操作都不会影响全局版本的值，Julia 会在你从文件运行程序时在终端显示警告（但在 REPL 中不会，如下一节所述）。

发出警告的原因是，*遮蔽*全局变量在循环内部会产生歧义：Julia 无法确定你是想创建一个新的局部变量还是使用全局变量。Julia 并不会拒绝运行你的程序，而是选择了一个选项，并警告你可能有不同的意图。通过在循环内使用`local`或`global`关键字来修饰变量，可以消除歧义。

对于程序文件，一个更好的解决方案是将循环和它引用的变量放入一个函数中。这样这些变量就不会在全局作用域中，Julia 也不会发出警告。通常，虽然我们在 REPL 中进行许多计算而不在函数内，但在编写程序文件时，将尽可能多的内容放在函数内部是一个好习惯。

因此，行为与函数块的情况完全相同，唯一的区别是警告。Julia 在循环中会发出这个警告，但在函数定义中不会，因为虽然函数通常只使用作为参数传入的变量和它们的私有局部变量，但循环通常会使用在循环外部设置的变量。当所有内容都在局部作用域内时，比如循环及其初始化都在函数内部时，程序员重复变量名的可能性很小。然而，当循环外部的变量是全局变量时，意外重复的可能性就大了。这个循环可能是从另一个文件中复制过来的，而那个文件恰巧使用了相同的变量名，或者全局变量可能在距离循环几千行之外的地方定义。为了帮助你避免这种情况，Julia 遵循作用域规则，并警告你关于在循环中被遮蔽的全局变量。

#### ***交互式上下文中的作用域规则修改***

在 REPL、Pluto 或其他交互式上下文中，`while`和`for`循环的作用域规则与函数块不同，后者在交互式和非交互式上下文中使用相同的规则。

在 REPL 中，如果在循环内给一个变量赋值，且该变量在全局 REPL 作用域中不存在，则会创建一个新的局部变量。然而，如果已经存在同名的全局变量，那么将使用这个全局变量，并且不会发出警告。

这种对作用域规则的修改使得在 REPL 中的工作更加便捷，尤其是在处理所有全局变量时。它还简化了调试 REPL 内部函数部分的过程。想象一下，某个循环及其初始化从一个大函数中复制出来，并粘贴到 REPL 中。在文件中，初始化变量是局部的，但当粘贴到 REPL 中时，它们就变成了全局作用域。REPL 中的规则例外使得循环及其初始化在 REPL 中的行为与它们在原始环境中（函数块内）一致。

### **可变性**

在本章的多个地方，`===`操作符作为严格相等的测试出现：只有当两个值具有相同的类型和相同的值时，它们在`===`意义上才相等，或者说相同。

现在我们了解得更多了，可以在其他上下文中重新审视`===`的比较。以下的例子可能会让你感到惊讶：

```
julia> [1] === [1]
false
```

比较的两边看起来一样：它们都是`Vector`，并且都包含相同的单一值，且都是`Int64`类型。而且，正如你所检查的，`1 === 1`为`true`。

上述例子中结果的原因是，每次你创建一个数组时，你都在创建一个新的对象，并且该对象在内存中有自己的位置。比较两边的两个数组并不相同，因为它们位于不同的内存地址。你可以编写一个程序来区分它们，这就是强制`===`比较返回`false`的正式标准。

数字则不同，它只是一个数字，在内存中没有特定的位置。整数`1`始终与自身相同。

如果我们将这些对象赋值给变量，就能更加清楚地理解。如果我们进行赋值`v1 = [1]`和`v2 = [1]`，那么比较`v1 === v2`会返回`false`，而`v1 == v2`则返回`true`。这两个变量有相同的*值*，但它们是不同的对象。它们并不相同。可以把这些变量看作是对数组起始位置的引用，或者是指向内存地址的指针。

数组是*可变*的。以下是数组可变性的一个结果：

```
   julia> a = [1]
   1-element Vector{Int64}:
    1

   julia> b = a
   1-element Vector{Int64}:
    1

➊ julia> b[1] = 7
    7

➋ julia> a
   1-element Vector{Int64}:
    7

   julia> b === a
   true
```

首先我们定义`a`为一个包含一个元素的`Vector`。然后我们将`b`设置为等于`a`。接着，我们将`b`的第一个（也是唯一一个）元素改为`7`。之后，当我们查看`a`时，我们发现*它*也发生了变化。它的第一个元素现在也变成了`7`。为什么会发生这种情况的线索就在最后一句：`b`和`a`不仅仅是相等，它们是*相同*的。当我们执行赋值`b = a`时，我们让`b`指向与`a`相同的内存地址。现在这两个变量都是指向同一对象的指针或名称。所以，如果我们更改或*修改*其中一个，另一个也会发生相同的变化。

在 Julia 中，有些对象是*不可变*的：

```
julia> a = 1
1

julia> b = a
1

julia> b = 7
7

julia> a
1
```

在对`a`和`b`进行赋值后，它们成为数字`1`和`7`的替代名称。一个表格跟踪我们为值所取的名称，并存储在内存中的某个地方，但变量是值的名称，而不是内存地址的名称。

在第二行，我们告诉 Julia 将 b 也作为数字`1`的名称。之后，我们改变主意，希望`b`代表`7`，但这并不会改变`a`作为数字`1`的名称。你不能修改数字`1`。它永远是`1`，也一直是`1`。但是，你可以通过改变一个数组的内容来修改它。

#### ***修改其参数的函数***

我们可以通过直接为其元素分配一个值来修改数组。我们也可以通过将一个元素添加到数组的末尾来修改数组，从而使它变大。我们始终可以通过连接来做到这一点。例如，如果`v`是一个数字的`Vector`，`v = [v; 7]`会将数字 7 附加到末尾，使其长度增加 1。

然而，在我们需要多次进行此类计算的情况下，这样做效率不高。如果我们到达一个内存空间不足以让`v`的元素连续存放的地步，Julia 将不得不移动它，可能是多次移动。更高效的选择是使用为此目的而设计的内置函数。如果我们调用`push! (v, 7)`，它就像连接版本一样修改`v`，但效率更高。当`push!()`没有足够的空间时，它会移动数组并为将来的扩展预留内存。每次它发现需要这样做时，它会预留一个几何增长的空间量。这个函数旨在处理常见场景：一个数组在时间和空间上都高效地被附加到一个循环中的情形。

`push!()`名称中的感叹号提醒用户这是一个会修改其参数的函数。它不是语法的一部分，而是一个强烈的约定。通常，Julia 中的函数将它们的参数作为输入用于计算并返回结果：我们之前称之为“纯函数”。带有`!`的函数会改变它们的参数，可能会或不会返回结果。`push!()`函数也会返回结果：被修改后的数组。

由于感叹号的使用是一个约定，而不是由语言强制执行的规则，因此任何函数都可以修改其可变的参数，但这个约定非常有价值，Julia 程序员在遵循它时非常小心。

`push!()`的反义操作是`pop!()`，它通过移除参数的最后一个元素并将该元素作为结果返回，来修改其参数。

#### ***字符串是不可变的***

尽管`String`类型是一个集合，像`Vector`、`Matrix`和其他数组类型一样，但它是不可变的。

我们可以索引字符串，但不能为其元素赋值，因为字符串是不可变的：

```
julia> s = "abc"
"abc"

julia> s[1:2]
"ab"

julia> s[3] = 'Z'
ERROR: MethodError: no method matching setindex!(::String, ::Char, ::Int64)
```

这表明我们可以像索引一个向量一样索引字符串，但我们不能更改它的任何元素。

如果我们想要创建一个新字符串，就必须字面定义它，或者通过拼接和索引，从现有字符串的部分或字符中构建它。这里有一个小函数，它接受一个字符串并返回一个装饰版的字符串：

```
julia> function string_decorator(s)
           decorated = ""
           for char in s
               decorated = decorated * char * " • "
           end
           decorated[1:end-5]
       end
string_decorator (generic function with 1 method)

julia> string_decorator("Julia")
"J • u • l • i • a"
```

函数最后一行的`end-5`用于省略最后的符号和它前面的空格——一个符号占用四个字节。

一般来说，这里使用的通过反复重新定义字符串来构建字符串的技巧，仅适用于小字符串和有限次数的重新定义。因为字符串是不可变的，每次进入循环都会创建一个新对象，这样会浪费内存。

下面是如何编写一个函数来执行相同任务，而不创建一堆字符串：

```
julia> function better_string_decorator(s)
           a = String[]
           for char in s
               push!(a, char * " • ")
           end
           join(a)[1:end-5]
       end
better_string_decorator (generic function with 1 method)

julia> better_string_decorator("PARTY!")
"P • A • R • T • Y • !"
```

内置的`join()`函数接受一个字符串数组，并将它们连接成一个更长的字符串。如果有合适的方法，它会将其他类型转换为字符串，这意味着`join([5, "6", 'X'])`会返回`"56X"`。

`join()`的对立函数是`split()`。这个函数将一个字符串拆分成一个由较短字符串组成的数组：

```
julia> split("a     b c")
3-element Vector{SubString{String}}:
 "a"
 "b"
 "c"

julia> split("a||b||c", "||")
3-element Vector{SubString{String}}:
 "a"
 "b"
 "c"
```

它会根据空白字符进行拆分，除非你提供一个第二个参数作为字符或字符串。在这种情况下，它将使用第二个参数作为分隔符；分隔符本身会被丢弃。

### **代码中的注释**

语言介绍如果不包括注释的语法，就不算完整。

Julia 中的单行注释以井号（`#`）开头，可以单独占一行，也可以跟在一行代码后面。换句话说，Julia 会忽略井号后面的所有内容。

要包含多行注释，需要以`#=`开头，以`=#`结尾。

### **恭喜**

如果你已经掌握了本章的所有内容，那么你现在可以编写有用的 Julia 程序来解决多种问题。

然而，你编写的大多数程序不会是完全自包含的。现代程序员通过将自己的代码与别人和自己编写的现有库中的函数结合，来构建解决方案。下一章将介绍 Julia 内置的一个系统，帮助你管理这些库和你自己的程序。
