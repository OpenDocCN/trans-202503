# 第十八章

脚注

第八章：自动化 Cuckoo 沙箱

1. [`www.briangrinstead.com/blog/multipart-form-post-in-c/`](http://www.briangrinstead.com/blog/multipart-form-post-in-c/)

目录

标题页

版权页

简要目录

详细目录

Matt Graeber 写的序言

前言

> > 我为什么要信任 Mono？
> > 
> > 这本书适合谁？
> > 
> > 本书的组织结构
> > 
> > 致谢
> > 
> > 最后的说明

第一章：C#速成课程

> > 选择 IDE
> > 
> > 一个简单的例子
> > 
> > 引入类和接口
> > 
> > > > > > 创建类
> > > > > > 
> > > > > > 创建接口
> > > > > > 
> > > > > > 从抽象类派生并实现接口
> > > > > > 
> > > > > > 通过 Main() 方法将一切联系起来
> > > > > > 
> > > > > > 运行 Main() 方法
> > > > > > 
> > 匿名方法
> > 
> > > > > > 为方法分配委托
> > > > > > 
> > > > > > 更新消防员类
> > > > > > 
> > > > > > 创建可选参数
> > > > > > 
> > > > > > 更新 Main() 方法
> > > > > > 
> > > > > > 运行更新后的 Main() 方法
> > > > > > 
> > 与本地库的集成
> > 
> > 结论

第二章：模糊测试与利用 XSS 和 SQL 注入漏洞

> > 设置虚拟机
> > 
> > > > > > 添加主机专用虚拟网络
> > > > > > 
> > > > > > 创建虚拟机
> > > > > > 
> > > > > > 从 BadStore ISO 启动虚拟机
> > > > > > 
> > SQL 注入
> > 
> > 跨站脚本攻击（XSS）
> > 
> > 使用变异模糊测试器模糊测试 GET 请求
> > 
> > > > > > 污染参数并测试漏洞
> > > > > > 
> > > > > > 构建 HTTP 请求
> > > > > > 
> > > > > > 测试模糊测试代码
> > > > > > 
> > 模糊测试 POST 请求
> > 
> > > > > > 编写 POST 请求模糊测试器
> > > > > > 
> > > > > > 模糊测试开始
> > > > > > 
> > > > > > 模糊测试参数
> > > > > > 
> > 对 JSON 进行模糊测试
> > 
> > > > > > 设置易受攻击的设备
> > > > > > 
> > > > > > 捕获易受攻击的 JSON 请求
> > > > > > 
> > > > > > 创建 JSON 模糊测试器
> > > > > > 
> > > > > > 测试 JSON 模糊测试器
> > > > > > 
> > 利用 SQL 注入漏洞
> > 
> > > > > > 手动执行基于 UNION 的漏洞利用
> > > > > > 
> > > > > > 通过程序化执行基于 UNION 的漏洞利用
> > > > > > 
> > > > > > 利用布尔盲 SQL 漏洞
> > > > > > 
> > 结论

第三章：模糊测试 SOAP 端点

> > 设置易受攻击的端点
> > 
> > 解析 WSDL
> > 
> > > > > > 为 WSDL 文档创建类
> > > > > > 
> > > > > > 编写初始解析方法
> > > > > > 
> > > > > > 为 SOAP 类型和参数编写类
> > > > > > 
> > > > > > 创建 SoapMessage 类以定义发送的数据
> > > > > > 
> > > > > > 实现消息部分的类
> > > > > > 
> > > > > > 通过 SoapPortType 类定义端口操作
> > > > > > 
> > > > > > 实现端口操作类
> > > > > > 
> > > > > > 定义 SOAP 绑定中使用的协议
> > > > > > 
> > > > > > 编译操作子节点列表
> > > > > > 
> > > > > > 查找端口上的 SOAP 服务
> > > > > > 
> > 自动化对 SOAP 端点进行 SQL 注入漏洞模糊测试
> > 
> > > > > > 对单个 SOAP 服务进行模糊测试
> > > > > > 
> > > > > > 对 HTTP POST SOAP 端口进行模糊测试
> > > > > > 
> > > > > > 对 SOAP XML 端口进行模糊测试
> > > > > > 
> > > > > > 运行模糊测试器
> > > > > > 
> > 结论

第四章：编写回连、绑定和 Metasploit 有效载荷

> > 创建回连有效载荷
> > 
> > > > > > 网络流
> > > > > > 
> > > > > > 运行命令
> > > > > > 
> > > > > > 运行有效载荷
> > > > > > 
> > 绑定有效载荷
> > 
> > > > > > 接受数据、执行命令并返回输出
> > > > > > 
> > > > > > 从流中执行命令
> > > > > > 
> > 使用 UDP 攻击网络
> > 
> > > > > > 目标机器的代码
> > > > > > 
> > > > > > 攻击者的代码
> > > > > > 
> > 从 C# 运行 x86 和 x86-64 Metasploit 有效载荷
> > 
> > > > > > 设置 Metasploit
> > > > > > 
> > > > > > 生成有效载荷
> > > > > > 
> > > > > > 以非管理代码执行原生 Windows 有效载荷
> > > > > > 
> > > > > > 执行原生 Linux 有效载荷
> > > > > > 
> > 结论

第五章：自动化 Nessus

> > REST 与 Nessus API
> > 
> > NessusSession 类
> > 
> > > > > > 发送 HTTP 请求
> > > > > > 
> > > > > > 登出并清理
> > > > > > 
> > > > > > 测试 NessusSession 类
> > > > > > 
> > NessusManager 类
> > 
> > 执行 Nessus 扫描
> > 
> > 结论

第六章：自动化 Nexpose

> > 安装 Nexpose
> > 
> > > > > > 激活和测试
> > > > > > 
> > > > > > 一些 Nexpose 行话
> > > > > > 
> > NexposeSession 类
> > 
> > > > > > ExecuteCommand() 方法
> > > > > > 
> > > > > > 登出并处理我们的会话
> > > > > > 
> > > > > > 查找 API 版本
> > > > > > 
> > > > > > 驱动 Nexpose API
> > > > > > 
> > NexposeManager 类
> > 
> > 自动化漏洞扫描
> > 
> > > > > > 创建带有资产的站点
> > > > > > 
> > > > > > 开始扫描
> > > > > > 
> > 创建 PDF 站点报告并删除站点
> > 
> > 综合应用
> > 
> > > > > > 开始扫描
> > > > > > 
> > > > > > 生成报告并删除站点
> > > > > > 
> > > > > > 运行自动化
> > > > > > 
> > 结论

第七章：自动化 OpenVAS

> > 安装 OpenVAS
> > 
> > 构建类
> > 
> > OpenVASSession 类
> > 
> > > > > > 使用 OpenVAS 服务器进行身份验证
> > > > > > 
> > > > > > 创建执行 OpenVAS 命令的方法
> > > > > > 
> > > > > > 读取服务器消息
> > > > > > 
> > > > > > 设置 TCP 流以发送和接收命令
> > > > > > 
> > > > > > 证书验证和垃圾回收
> > > > > > 
> > > > > > 获取 OpenVAS 版本
> > > > > > 
> > OpenVASManager 类
> > 
> > > > > > 获取扫描配置并创建目标
> > > > > > 
> > > > > > 总结自动化过程
> > > > > > 
> > > > > > 运行自动化过程
> > > > > > 
> > 结论

第八章：自动化 Cuckoo 沙箱

> > 设置 Cuckoo 沙箱
> > 
> > 手动运行 Cuckoo 沙箱 API
> > 
> > > > > > 启动 API
> > > > > > 
> > > > > > 检查 Cuckoo 的状态
> > > > > > 
> > 创建 CuckooSession 类
> > 
> > > > > > 编写 ExecuteCommand() 方法以处理 HTTP 请求
> > > > > > 
> > > > > > 使用 GetMultipartFormData() 方法创建 Multipart HTTP 数据
> > > > > > 
> > > > > > 使用 FileParameter 类处理文件数据
> > > > > > 
> > > > > > 测试 CuckooSession 和支持类
> > > > > > 
> > 编写 CuckooManager 类
> > 
> > > > > > 编写 CreateTask() 方法
> > > > > > 
> > > > > > 任务详情和报告方法
> > > > > > 
> > > > > > 创建 Task 抽象类
> > > > > > 
> > > > > > 排序并创建不同的类类型
> > > > > > 
> > 将其整合在一起
> > 
> > 测试应用程序
> > 
> > 结论

第九章：自动化 Sqlmap

> > 运行 sqlmap
> > 
> > > > > > sqlmap REST API
> > > > > > 
> > > > > > 使用 curl 测试 sqlmap API
> > > > > > 
> > 为 sqlmap 创建 Session
> > 
> > > > > > 创建一个方法来执行 GET 请求
> > > > > > 
> > > > > > 执行 POST 请求
> > > > > > 
> > > > > > 测试 Session 类
> > > > > > 
> > SqlmapManager 类
> > 
> > > > > > 列出 sqlmap 选项
> > > > > > 
> > > > > > 创建一个方法来执行扫描
> > > > > > 
> > > > > > 新的 Main() 方法
> > > > > > 
> > 扫描报告
> > 
> > 自动化完整的 sqlmap 扫描
> > 
> > 将 sqlmap 与 SOAP Fuzzer 集成
> > 
> > > > > > 将 sqlmap GET 请求支持添加到 SOAP Fuzzer
> > > > > > 
> > > > > > 添加 sqlmap POST 请求支持
> > > > > > 
> > > > > > 调用新方法
> > > > > > 
> > 结论

第十章：自动化 ClamAV

> > 安装 ClamAV
> > 
> > ClamAV 原生库与 clamd 网络守护进程
> > 
> > 通过 ClamAV 的原生库实现自动化
> > 
> > > > > > 设置支持的枚举和类
> > > > > > 
> > > > > > 访问 ClamAV 的原生库函数
> > > > > > 
> > > > > > 编译 ClamAV 引擎
> > > > > > 
> > > > > > 扫描文件
> > > > > > 
> > > > > > 清理工作
> > > > > > 
> > > > > > 通过扫描 EICAR 文件测试程序
> > > > > > 
> > 通过 clamd 实现自动化
> > 
> > > > > > 安装 clamd 守护进程
> > > > > > 
> > > > > > 启动 clamd 守护进程
> > > > > > 
> > > > > > 为 clamd 创建会话类
> > > > > > 
> > > > > > 创建 clamd 管理类
> > > > > > 
> > > > > > 使用 clamd 测试
> > > > > > 
> > 结论

第十一章：Metasploit 自动化

> > 运行 RPC 服务器
> > 
> > 安装 Metasploitable
> > 
> > 获取 MSGPACK 库
> > 
> > > > > > 为 MonoDevelop 安装 NuGet 包管理器
> > > > > > 
> > > > > > 安装 MSGPACK 库
> > > > > > 
> > > > > > 引用 MSGPACK 库
> > > > > > 
> > 编写 MetasploitSession 类
> > 
> > > > > > 为 HTTP 请求和与 MSGPACK 交互创建 Execute() 方法
> > > > > > 
> > > > > > 将 MSGPACK 响应数据转换
> > > > > > 
> > 测试会话类
> > 
> > 编写 MetasploitManager 类
> > 
> > 将所有内容整合在一起
> > 
> > > > > > 运行 Exploit
> > > > > > 
> > > > > > 与 Shell 交互
> > > > > > 
> > > > > > 获取 Shell
> > > > > > 
> > 结论

第十二章：Arachni 自动化

> > 安装 Arachni
> > 
> > Arachni REST API
> > 
> > > > > > 创建 ArachniHTTPSession 类
> > > > > > 
> > > > > > 创建 ArachniHTTPManager 类
> > > > > > 
> > 将会话和管理类整合在一起
> > 
> > Arachni RPC
> > 
> > > > > > 手动运行 RPC
> > > > > > 
> > > > > > ArachniRPCSession 类
> > > > > > 
> > > > > > ExecuteCommand() 的支持方法
> > > > > > 
> > > > > > ExecuteCommand() 方法
> > > > > > 
> > > > > > ArachniRPCManager 类
> > > > > > 
> > 整合所有内容
> > 
> > 结论

第十三章：逆向托管程序集

> > 逆向托管程序集
> > 
> > 测试反编译器
> > 
> > 使用 monodis 分析程序集
> > 
> > 结论

第十四章：读取离线注册表

> > 注册表信息结构
> > 
> > 获取注册表信息
> > 
> > 读取注册表信息
> > 
> > > > > > 创建解析注册表文件的类
> > > > > > 
> > > > > > 创建节点密钥类
> > > > > > 
> > > > > > 创建用于存储值密钥的类
> > > > > > 
> > 测试库
> > 
> > 获取引导密钥
> > 
> > > > > > GetBootKey() 方法
> > > > > > 
> > > > > > GetValueKey() 方法
> > > > > > 
> > > > > > GetNodeKey() 方法
> > > > > > 
> > > > > > StringToByteArray() 方法
> > > > > > 
> > > > > > 获取引导密钥
> > > > > > 
> > > > > > 验证引导密钥
> > > > > > 
> > 结论

索引

资源

电子前沿基金会 (EFF)

脚注

> > 第八章：自动化 Cuckoo Sandbox
