# 第二章：Web 应用程序如何工作

![](img/chapterart.png)

在你能够破解 API 之前，必须了解支持它们的技术。在本章中，我将涵盖你需要了解的关于 Web 应用程序的所有内容，包括超文本传输协议（HTTP）的基本方面、身份验证与授权以及常见的 Web 服务器数据库。因为 Web API 是由这些技术驱动的，所以理解这些基础知识将为你使用和破解 API 做好准备。

## Web 应用程序基础

Web 应用程序基于客户端/服务器模型运行：你的 Web 浏览器，作为客户端，生成对资源的请求并将其发送到称为 Web 服务器的计算机。这些 Web 服务器再通过网络将资源发送回客户端。*Web 应用程序*一词指的是运行在 Web 服务器上的软件，如 Wikipedia、LinkedIn、Twitter、Gmail、GitHub 和 Reddit。

尤其是，Web 应用程序是为最终用户交互而设计的。而网站通常是只读的，仅提供从 Web 服务器到客户端的单向通信，Web 应用程序则允许通信双向流动，从服务器到客户端以及从客户端到服务器。例如，Reddit 是一个作为信息流动的新闻源的 Web 应用程序。如果它仅仅是一个网站，访客只能接收网站背后组织提供的内容。而 Reddit 允许用户通过发布、点赞、点踩、评论、分享、举报不良帖子以及通过订阅自己想看的子版块来自定义他们的新闻源，从而与站点上的信息进行交互。这些功能将 Reddit 与静态网站区分开来。

为了让最终用户开始使用 Web 应用程序，必须在 Web 浏览器和 Web 服务器之间进行一次对话。最终用户通过在浏览器地址栏中输入 URL 来启动这次对话。在本节中，我们将讨论接下来会发生什么。

### URL

你可能已经知道，*统一资源定位符 (URL)* 是用于定位互联网上唯一资源的地址。这个 URL 由几个组件组成，在后面的章节中，你会发现了解它们对编写 API 请求非常有帮助。所有的 URL 都包含使用的协议、主机名、端口、路径以及任何查询参数：

> 协议://主机名[:端口号]/[路径]/[?查询][参数]

*协议*是计算机用来通信的一组规则。URL 中使用的主要协议是 HTTP/HTTPS 用于网页，FTP 用于文件传输。

*端口*是指定通信通道的数字，只有在主机无法自动将请求解析到正确端口时才会包含。通常，HTTP 通信使用 80 端口。HTTP 的加密版本 HTTPS 使用 443 端口，而 FTP 使用 21 端口。要访问托管在非标准端口上的 Web 应用程序，可以在 URL 中包含端口号，如：*https://www.example.com:8443*。（端口 8080 和 8443 分别是 HTTP 和 HTTPS 的常见替代端口。）

网络服务器上的文件目录*路径*指向 URL 中指定的网页和文件的位置。URL 中使用的路径与计算机中定位文件的文件路径相同。

*查询*是 URL 中的可选部分，用于执行如搜索、过滤和翻译请求信息语言等功能。网络应用提供商还可能使用查询字符串来跟踪某些信息，如指向该网页的 URL、您的会话 ID 或您的电子邮件。查询部分以问号开始，包含服务器被编程处理的字符串。最后，*查询参数*是描述如何处理给定查询的值。例如，查询`page?`后的查询参数`lang=en`可能表明网络服务器应提供英文版的请求页面。这些参数由另一个字符串组成，供服务器处理。查询可以包含多个用符号&（`&`）分隔的参数。

为了使这些信息更具具体性，考虑以下 URL：[`twitter.com/search?q=hacking&src=typed_query`](https://twitter.com/search?q=hacking&src=typed_query)。在这个例子中，协议是*https*，主机名是*twitter.com*，路径是*search*，查询是*q*（表示查询），查询参数是*hacking*，*src=typed_query*是一个跟踪参数。每当你在 Twitter Web 应用程序中点击搜索框，输入“hacking”并按下回车时，这个 URL 就会自动生成。浏览器被编程为以 Twitter Web 服务器能够理解的方式形成 URL，并收集一些以`src`参数形式的跟踪信息。Web 服务器将接收到关于黑客内容的请求，并返回与黑客相关的信息。

### HTTP 请求

当最终用户通过 Web 浏览器访问 URL 时，浏览器会自动生成一个 HTTP*请求*来获取资源。这个资源就是被请求的信息——通常是构成网页的文件。请求通过互联网或网络路由到 Web 服务器，在那里进行初步处理。如果请求格式正确，Web 服务器将请求传递给 Web 应用程序。

列表 1-1 显示了在向*twitter.com*进行认证时发送的 HTTP 请求的组成部分。

```
POST❶ /sessions❷ HTTP/1.1❸
Host: twitter.com❹
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded
Content-Length: 444
Cookie: _personalization_id=GA1.2.1451399206.1606701545; dnt=1;

username_or_email%5D=hAPI_hacker&❺password%5D=NotMyPassword❻%21❼
```

列表 1-1：一个用于与*twitter.com*认证的 HTTP 请求

HTTP 请求以方法 ❶、请求资源的路径 ❷ 和协议版本 ❸ 开始。方法在本章后面的“HTTP 方法”部分中进行描述，告诉服务器你想做什么。在这种情况下，你使用 POST 方法将登录凭证发送到服务器。路径可以包含完整的 URL、绝对路径或资源的相对路径。在这个请求中，路径 */sessions* 指定了处理 Twitter 身份验证请求的页面。

请求包含若干 *头部*，它们是键值对，用于在客户端和 Web 服务器之间传递特定信息。头部以头部的名称开头，后跟冒号（`:`），然后是头部的值。`Host` 头部 ❹ 指定了域名主机，*twitter.com*。`User-Agent` 头部描述了客户端的浏览器和操作系统。`Accept` 头部描述了浏览器可以接受 Web 应用程序在响应中返回的内容类型。并非所有头部都是必需的，客户端和服务器可能会包括未在此处显示的其他头部，具体取决于请求。例如，这个请求包括一个 `Cookie` 头部，它用于客户端和服务器之间建立有状态连接（稍后在本章中会讨论）。如果你想了解更多关于所有不同头部的内容，可以查看 Mozilla 开发者页面上的头部文档（[`developer.mozilla.org/en-US/docs/Web/HTTP/Headers`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)）。

所有在头部以下的部分是 *消息体*，它是请求方试图让 Web 应用程序处理的信息。在这种情况下，消息体包含了用于身份验证 Twitter 帐号的用户名 ❺ 和密码 ❻。消息体中的某些字符会自动进行编码。例如，感叹号（`!`）会被编码为 `%21` ❼。编码字符是 Web 应用程序安全处理可能引起问题的字符的一种方式。

### HTTP 响应

在 Web 服务器收到 HTTP 请求后，它会处理并响应该请求。响应的类型取决于资源的可用性、用户是否有权限访问该资源、Web 服务器的健康状况以及其他因素。例如，清单 1-2 显示了对 清单 1-1 中请求的响应。

```
HTTP/1.1❶ 302 Found❷
content-security-policy: default-src 'none'; connect-src 'self'
location: https://twitter.com/
pragma: no-cache
server: tsa_a
set-cookie: auth_token=8ff3f2424f8ac1c4ec635b4adb52cddf28ec18b8; Max-Age=157680000; Expires=Mon, 01 Dec 2025 16:42:40 GMT; Path=/; Domain=.twitter.com; Secure; HTTPOnly; SameSite=None

<html><body>You are being <a href="https://twitter.com/">redirected</a>.</body></html>
```

清单 1-2：身份验证到 *twitter.com* 的 HTTP 响应示例

Web 服务器首先以使用的协议版本作出响应（在这种情况下是 HTTP/1.1 ❶）。HTTP 1.1 目前是使用的标准 HTTP 版本。状态码和状态消息 ❷，在下一部分中会更详细地讨论，是 302 Found。302 响应码表示客户端已成功身份验证，并将被重定向到客户端被授权访问的登陆页面。

请注意，像 HTTP 请求头一样，也有 HTTP 响应头。HTTP 响应头通常为浏览器提供处理响应和安全要求的指令。`set-cookie`头是另一个指示身份验证请求成功的标志，因为 Web 服务器已经发出了包含`auth_token`的 Cookie，客户端可以使用该 Cookie 访问某些资源。响应消息正文将紧随响应头后的空行之后。在这个案例中，Web 服务器发送了一条 HTML 消息，表示客户端正在被重定向到一个新网页。

我在这里展示的请求和响应展示了 Web 应用程序通过使用身份验证和授权来限制对其资源的访问的常见方式。Web *身份验证*是向 Web 服务器证明你身份的过程。常见的身份验证方式包括提供密码、令牌或生物特征信息（例如指纹）。如果 Web 服务器批准身份验证请求，它将通过提供已认证用户的*授权*来允许访问特定资源。在清单 1-1 中，我们看到向 Twitter Web 服务器发出的身份验证请求，它通过 POST 请求发送了用户名和密码。Twitter Web 服务器通过 302 Found 响应成功的身份验证请求（见清单 1-2）。`set-cookie`头中的会话`auth_token`授权访问与 hAPI_hacker Twitter 账户相关的资源。

### HTTP 状态码

当 Web 服务器响应请求时，它会发出响应状态码以及响应消息。响应代码表示 Web 服务器如何处理请求。高层次来看，响应代码决定了客户端是否被允许或拒绝访问资源。它还可以指示资源不存在，Web 服务器出现问题，或者请求的资源已经被重定向到其他位置。

清单 1-3 和 1-4 分别展示了 200 响应和 404 响应之间的区别。

```
**HTTP/1.1 200 OK**
Server: tsa_a
**Content-length: 6552**

**<!DOCTYPE html>**
**<html dir="ltr" lang="en">**
**[****...****]**
```

清单 1-3：200 响应的示例

```
**HTTP/1.1 404 Not Found**
Server: tsa_a
**Content-length: 0**
```

清单 1-4：404 响应的示例

200 OK 响应将为客户端提供请求的资源访问权限，而 404 Not Found 响应则会提供某种错误页面或空白页面，因为请求的资源未找到。

因为 Web API 主要通过 HTTP 进行通信，所以了解你应该从 Web 服务器接收到的响应代码类型非常重要，具体内容见表格 1-1。如果你想了解更多关于各个响应代码的信息或 Web 技术的一般知识，可以查阅 Mozilla 的 Web 文档（[`developer.mozilla.org/en-US/docs/Web/HTTP`](https://developer.mozilla.org/en-US/docs/Web/HTTP)）。Mozilla 提供了大量关于 Web 应用程序结构的有用信息。

表格 1-1：HTTP 响应代码范围

| **响应代码** | **响应类型** | **描述** |
| --- | --- | --- |
| 100s | 信息类响应 | 100s 范围内的响应通常与请求的某种处理状态更新有关。 |
| 200s | 成功的响应 | 200s 范围内的响应表示请求成功并已被接受。 |
| 300s | 重定向 | 300s 范围内的响应是重定向通知。通常会在自动将你重定向到索引/主页时看到，或者当你请求从端口 80 的 HTTP 页面重定向到端口 443 的 HTTPS 页面时。 |
| 400s | 客户端错误 | 400s 范围内的响应表示客户端出现了问题。如果你请求一个不存在的页面，或者响应超时，或者你被禁止查看某个页面时，通常会收到此类响应。 |
| 500s | 服务器错误 | 500s 范围内的响应表示服务器出现了问题。这些包括内部服务器错误、服务不可用和无法识别的请求方法。 |

### HTTP 方法

HTTP *方法* 用于从 web 服务器请求信息。也称为 HTTP 动词，HTTP 方法包括 GET、PUT、POST、HEAD、PATCH、OPTIONS、TRACE 和 DELETE。

GET 和 POST 是最常用的请求方法。GET 请求用于从 web 服务器获取资源，POST 请求用于将数据提交到 web 服务器。表 1-2 提供了每个 HTTP 请求方法的更深入信息。

表 1-2：HTTP 方法

| **方法** | **目的** |
| --- | --- |
| GET | GET 请求尝试从 web 服务器获取资源。这可以是任何资源，包括网页、用户数据、视频、地址等等。如果请求成功，服务器将提供该资源；否则，服务器将提供响应，解释为什么无法获取请求的资源。 |
| POST | POST 请求将请求体中的数据提交到 web 服务器。这可能包括客户端记录、请求从一个账户向另一个账户转账、状态更新等。例如，如果客户端多次提交相同的 POST 请求，服务器将创建多个结果。 |
| PUT | PUT 请求指示 web 服务器将提交的数据存储在请求的 URL 下。PUT 主要用于向 web 服务器发送资源。如果服务器接受 PUT 请求，它将添加资源或完全替换现有资源。如果 PUT 请求成功，应该创建一个新的 URL。如果相同的 PUT 请求再次提交，结果应该保持一致。 |
| HEAD | HEAD 请求与 GET 请求类似，不同之处在于它仅请求 HTTP 头信息，不包括消息体。此请求是获取服务器状态信息并检查给定 URL 是否有效的快速方式。 |
| PATCH | PATCH 请求用于使用提交的数据部分更新资源。如果 HTTP 响应包含 `Accept-Patch` 头，PATCH 请求才可能可用。 |
| OPTIONS | OPTIONS 请求是一种客户端识别从给定 Web 服务器允许的所有请求方法的方式。如果 Web 服务器响应了 OPTIONS 请求，它应该返回所有允许的请求选项。 |
| TRACE | TRACE 请求主要用于调试从客户端发送到服务器的输入。TRACE 请求让服务器回显客户端的原始请求，这可以揭示是否有机制在服务器处理请求之前更改了客户端的请求。 |
| CONNECT | CONNECT 请求启动一个双向网络连接。在允许的情况下，此请求会在浏览器和 Web 服务器之间创建一个代理隧道。 |
| DELETE | DELETE 请求要求服务器删除给定的资源。 |

一些方法是*幂等*的，这意味着它们可以多次发送相同的请求，而不会改变服务器上资源的状态。例如，如果你执行开灯操作，那么灯会亮起来。当开关已经打开时，再次尝试打开开关，灯仍然亮着——没有任何变化。GET、HEAD、PUT、OPTIONS 和 DELETE 方法是幂等的。

另一方面，*非幂等*方法会动态地改变服务器上资源的结果。非幂等方法包括 POST、PATCH 和 CONNECT。POST 是最常用的改变 Web 服务器资源的方法。POST 用于在 Web 服务器上创建新资源，因此，如果提交了 10 次 POST 请求，服务器上将会有 10 个新的资源。相比之下，如果请求了一个像 PUT 这样的幂等方法，通常用于更新资源，那么即使请求了 10 次，只有一个资源会被覆盖 10 次。

DELETE 也是幂等的，因为如果删除资源的请求发送了 10 次，资源只会被删除一次。其后的请求将不会有任何变化。Web API 通常只会使用 POST、GET、PUT、DELETE，其中 POST 为非幂等方法。

### 有状态与无状态 HTTP

HTTP 是一种*无状态*协议，这意味着服务器不会跟踪请求之间的信息。然而，为了让用户在使用 Web 应用时有一致的体验，Web 服务器需要记住一些关于该客户端的 HTTP 会话信息。例如，如果用户登录到其账户并将多个物品添加到购物车中，Web 应用需要跟踪该用户购物车的状态。否则，每次用户导航到不同的网页时，购物车都会清空。

*有状态连接*允许服务器跟踪客户端的行为、个人资料、图片、偏好设置等。有状态连接使用称为*cookies*的小文本文件在客户端存储信息。Cookies 可能存储与网站相关的设置、安全设置以及身份验证相关的信息。同时，服务器通常在其自身、缓存或后台数据库中存储信息。为了继续会话，浏览器会将存储的 cookies 包含在请求中，黑客在攻击 web 应用时，可以通过窃取或伪造 cookies 来冒充最终用户。

与服务器保持有状态连接有扩展性限制。当客户端和服务器之间保持状态时，这种关系仅存在于创建状态时所使用的特定浏览器和服务器之间。如果用户从例如在一台计算机上使用浏览器切换到在移动设备上使用浏览器，客户端需要重新认证并与服务器创建一个新状态。此外，有状态连接要求客户端持续向服务器发送请求。当许多客户端与同一服务器保持状态时，问题开始出现。服务器只能处理其计算资源允许的有状态连接数量。而这可以通过无状态应用程序更容易地解决。

*无状态通信*消除了管理会话所需的服务器资源。在无状态通信中，服务器不会存储会话信息，每一个无状态请求都必须包含所有必要的信息，以便 web 服务器识别请求者是否有权访问特定资源。这些无状态请求可以包括密钥或某种形式的授权头，以维持类似有状态连接的体验。这些连接不会在 web 应用服务器上存储会话数据，而是利用后台数据库。

在我们的购物车示例中，无状态应用程序可以通过根据包含特定令牌的请求更新数据库或缓存来跟踪用户购物车的内容。最终用户的体验看起来相同，但 web 服务器处理请求的方式则大不相同。由于它们的状态表现得到维持，且客户端在每个请求中提供所有所需信息，无状态应用程序可以在不担心丢失有状态连接中的信息的情况下进行扩展。相反，只要请求中包含所有必要信息且这些信息在后台数据库中可访问，任何数量的服务器都可以用来处理请求。

在黑客攻击 API 时，攻击者可以通过窃取或伪造用户的令牌来冒充最终用户。API 通信是无状态的——这是我将在下一章详细探讨的话题。

## Web 服务器数据库

数据库允许服务器存储并快速向客户端提供资源。例如，任何允许你上传状态更新、照片和视频的社交媒体平台，肯定使用数据库来保存所有这些内容。该社交媒体平台可能会自行维护这些数据库；或者，这些数据库也可以作为服务提供给平台。

通常，网页应用程序会通过将资源从前端代码传递到后端数据库来存储用户资源。网页应用程序的前端是用户交互的部分，决定了它的外观和感觉，并包括按钮、链接、视频和字体。前端代码通常包括 HTML、CSS 和 JavaScript。此外，前端还可能包括如 AngularJS、ReactJS 和 Bootstrap 等网页应用框架。*后端*则由前端所需的技术组成，包括服务器、应用程序和任何数据库。后端编程语言包括 JavaScript、Python、Ruby、Golang、PHP、Java、C# 和 Perl 等。

在一个安全的网页应用程序中，用户和后端数据库之间不应该有直接的互动。直接访问数据库会移除一层防护，并使数据库容易受到额外的攻击。当向最终用户暴露技术时，网页应用程序提供者会增加其潜在攻击面，这个度量称为*攻击面*。限制对数据库的直接访问可以缩小攻击面的大小。

现代网页应用程序使用 SQL（关系型）数据库或 NoSQL（非关系型）数据库。了解 SQL 和 NoSQL 数据库之间的区别，将有助于你日后定制 API 注入攻击。

### SQL

*结构化查询语言（SQL）*数据库是*关系型数据库*，其中数据按表格组织。表格的行，称为*记录*，标识数据类型，如用户名、电子邮件地址或权限级别。其列是数据的*属性*，可能包括所有不同的用户名、电子邮件地址和权限级别。在表 1-3 到 1-5 中，UserID、Username、Email 和 Privilege 是数据类型。行则是给定表格的数据。

表 1-3：关系型用户表

| **用户 ID** | **用户名** |
| --- | --- |
| 111 | hAPI_hacker |
| 112 | Scuttleph1sh |
| 113 | mysterioushadow |

表 1-4：关系型电子邮件表

| **用户 ID** | **电子邮件** |
| --- | --- |
| 111 | *hapi_hacker@email.com* |
| 112 | *scuttleph1sh@email.com* |
| 113 | *mysterioushadow@email.com* |

表 1-5：关系型权限表

| **用户 ID** | **权限** |
| --- | --- |
| 111 | 管理员 |
| 112 | partner |
| 113 | 用户 |

要从 SQL 数据库中检索数据，应用程序必须构造一个 SQL 查询。一个典型的查询，以查找 ID 为 111 的客户为例，可能是这样的：

```
SELECT * FROM Email WHERE UserID = 111;
```

该查询请求从 Email 表中获取所有 UserID 列值为 111 的记录。`SELECT` 是用于从数据库中获取信息的语句，星号是通配符字符，表示选择表中的所有列，`FROM` 用于指定查询的表，`WHERE` 是用于筛选特定结果的子句。

SQL 数据库有多种类型，但它们的查询方式类似。SQL 数据库包括 MySQL、Microsoft SQL Server、PostgreSQL、Oracle 和 MariaDB 等。

在后续章节中，我将讲解如何发送 API 请求来检测注入漏洞，例如 SQL 注入。SQL 注入是一种经典的 web 应用攻击，已经困扰了 web 应用超过二十年，但它仍然是 API 中可能存在的攻击方法。

### NoSQL

*NoSQL 数据库*，也称为分布式数据库，是*非关系型*的，意味着它们不遵循关系型数据库的结构。NoSQL 数据库通常是开源工具，用于处理非结构化数据并将数据存储为文档。与关系型数据库不同，NoSQL 数据库通过键值对来存储信息，而不是通过关系存储。与 SQL 数据库不同，每种类型的 NoSQL 数据库都有其独特的结构、查询模式、漏洞和利用方式。以下是使用 MongoDB 进行查询的示例，MongoDB 是当前市场份额领先的 NoSQL 数据库：

```
db.collection.find({"UserID": 111})
```

在此示例中，`db.collection.find()` 是用于在文档中查找 UserID 值为 111 的信息的方法。MongoDB 使用多个可能有用的操作符：

1.  `$eq` 匹配等于指定值的值

1.  `$gt` 匹配大于指定值的值

1.  `$lt` 匹配小于指定值的值

1.  `$ne` 匹配所有不等于指定值的值

这些操作符可以在 NoSQL 查询中使用，用于选择和过滤查询中的特定信息。例如，我们可以使用之前的命令而无需知道确切的 UserID，像这样：

```
db.collection.find({"UserID": {$gt:110}})
```

该语句将找到所有 UserID 大于 110 的记录。理解这些操作符在本书后续讲解 NoSQL 注入攻击时会非常有用。

NoSQL 数据库包括 MongoDB、Couchbase、Cassandra、IBM Domino、Oracle NoSQL 数据库、Redis 和 Elasticsearch 等。

## API 在整个框架中的作用

如果一个 web 应用能够利用其他应用的功能，它将变得更强大。*应用程序编程接口（APIs）* 是一种促进不同应用程序之间通信的技术。特别是，*web* API 允许基于 HTTP 的机器对机器通信，提供了一个将不同应用程序连接在一起的通用方法。

这种能力为应用提供商开辟了广阔的机会，因为开发者不再需要在他们想要提供给最终用户的每个功能方面都成为专家。例如，假设我们考虑一个共享乘车应用。该应用需要一个地图来帮助司机导航城市，需要一个处理支付的方法，以及一个供司机和客户沟通的方式。开发者可以利用 Google Maps API 来实现地图功能，利用 Stripe API 来处理支付，利用 Twilio API 来访问短信功能。开发者可以将这些 API 结合起来，创建一个全新的应用。

这种技术的直接影响是双重的。首先，它简化了信息的交换。通过使用 HTTP，Web API 可以利用协议的标准化方法、状态码和客户端/服务器关系，使开发者能够编写可以自动处理数据的代码。其次，API 使得 Web 应用提供商能够专注于自己的专业领域，因为他们不再需要创建每个 Web 应用的各个方面。

API 是一项具有全球影响的令人难以置信的技术。然而，正如你将在接下来的章节中看到的，它们大大增加了每个使用它们的应用在互联网上的攻击面。

## 总结

本章介绍了 Web 应用的基本方面。如果你理解了 HTTP 请求和响应、身份验证/授权以及数据库的一般功能，你将能够轻松理解 Web API，因为 Web 应用的底层技术正是 Web API 的底层技术。在下一章中，我们将分析 API 的构成。

本章旨在为你提供足够的信息，以便作为一个 API 黑客而不是开发者或应用架构师。若你希望了解更多关于 Web 应用的资源，我强烈推荐*《Web 应用黑客手册》*（Wiley，2011），*《Web 应用安全》*（O’Reilly，2020），*《Web 开发者的 Web 安全》*（No Starch Press，2020）和*《错综复杂的 Web》*（No Starch Press，2011）。
