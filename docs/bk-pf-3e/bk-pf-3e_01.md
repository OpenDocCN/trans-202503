## 第一章：构建你需要的网络

![构建你需要的网络](img/httpatomoreillycomsourcenostarchimages2127149.png.jpg)

PF，OpenBSD 的*数据包过滤子系统*，在我看来是控制网络的最佳工具。在深入了解如何将你的网络打造成理想的精密机器之前，请先阅读本章。本章介绍了基本的网络术语和概念，提供了一些 PF 的历史，并概述了你可以在本书中找到的内容。

## 你的网络：高性能、低维护和安全

如果这个标题准确描述了你的网络，那么你很可能是为了纯粹的娱乐而阅读本书，希望你能享受接下来的内容。另一方面，如果你还在学习如何构建网络，或者还不太自信自己的技能，那么回顾一些基本的网络安全概念会很有帮助。

信息技术（IT）安全是一个庞大、复杂且有时令人困惑的话题。即使我们只将视角限定在网络安全上，也可能会觉得我们并没有大幅缩小领域范围，或消除足够多固有的困惑性术语。几年前，随着个人计算机加入联网世界，并配备了显然不适合网络环境的系统软件和应用程序，情况变得更为严重。

结果是可预测的。即使在小型计算机联网之前，它们也已经成为恶意软件的温床，例如*病毒*（半自动化软件，能够“感染”其他文件，以传递其有效载荷并制作更多副本）和*木马*（最初是*特洛伊木马*，包含嵌入式代码的软件或文档，一旦激活，会使受害者的计算机执行用户未曾预期的操作）。当小型计算机开始联网时，又引入了另一类恶意软件，称为*蠕虫*，这类软件利用网络传播其有效载荷^([1])。与此同时，网络化的各种诈骗方式也开始出现在网络安全的视野中，今天，计算机安全活动的一个重要部分（可能是行业中最大的部分）集中在威胁管理上，特别是打击和分类恶意软件，或称*恶意软件*（malware）。

枚举恶劣情况的无意义性已经在其他地方有力地讨论过（参考文献见附录 A，例如马库斯·拉努姆的精彩文章《计算机安全中最愚蠢的六个想法》）。OpenBSD 的方法是在一开始就正确地设计和编码。然而，即使是聪明的人偶尔也会犯错，产生漏洞，因此请确保设计系统时能够将任何此类失败的安全影响降到最低。然后，如果你后来发现错误且漏洞是可被利用的，请修复这些漏洞，无论它们出现在代码树中的哪个地方，即使这可能意味着彻底重做设计，最坏情况下会丧失向后兼容性。^([2])

在 PF 中，广义上在本书中，重点更狭窄，集中于网络层的网络流量。OpenBSD 4.7 中引入的 divert(4)套接字使得设置一个系统变得更加容易，在这个系统中，PF 有助于*深度数据包检查*，类似于一些经过激烈营销的产品。然而，这个接口在自由软件中还未广泛用于这个目的，尽管也有例外。因此，我们将重点讨论一些基于纯网络层行为的技术，这些技术在第六章的示例配置中最为显著。这些技术将在你已配置的内容检查产品中减轻负担。正如你在接下来的章节中所看到的，除了阻止或通过数据包之外，网络层还带来了许多乐趣和激动。

## 包过滤器的作用

包过滤器的主要功能正如其名，是通过匹配单个数据包的属性和由这些数据包构建的网络连接，按照其配置文件中定义的过滤标准来过滤网络数据包。包过滤器负责决定如何处理这些数据包。这可能意味着通过数据包或者拒绝它们，或者触发其他操作系统部分或外部应用程序预设的事件。

PF 允许你编写自定义过滤标准，以基于几乎任何数据包或连接属性来控制网络流量，包括地址族、源地址和目标地址、接口、协议、端口和方向。根据这些标准，包过滤器会执行你指定的操作。最简单和最常见的操作之一就是阻止流量。

包过滤器可以阻止不必要的流量进入你的网络。它还可以帮助将网络流量限制在你自己的网络内部。这两个功能对*防火墙*概念非常重要，但阻止流量远不是功能齐全的包过滤器唯一有用或有趣的功能。正如你在本书中将看到的，你可以使用过滤标准将某些类型的网络流量定向到特定的主机，将流量类别分配到队列中，执行流量整形，甚至将选定类型的流量交给其他软件进行特别处理。

所有这些处理都发生在网络层，基于数据包和连接属性。PF 是网络堆栈的一部分，深深嵌入操作系统内核。尽管也有在用户空间实现包过滤的例子，但在大多数操作系统中，过滤功能是在内核中执行的，因为这样做更快。

## PF 的崛起

如果你对历史感兴趣，你可能已经知道 OpenBSD 和其他 BSD^([3])是 BSD 系统的直接后裔（有时称为*BSD Unix*），这是一个包含了 1980 年代早期 TCP/IP 互联网协议原始参考实现的操作系统。

随着 90 年代初期 BSD 开发背后的研究项目逐渐结束，代码被解放出来，供世界各地的小型开发者团队进一步开发。这些开发者中的一些人负责确保新兴互联网的关键基础设施稳定运行，BSD 开发在多个团队中平行进行。OpenBSD 团队成为了 BSD 家族中最注重安全的团队。为了满足包过滤的需求，它使用了一个名为*IPFilter*的子系统，主要由 Darren Reed 编写。在这些早期的岁月里，OpenBSD 迅速赢得了“防火墙操作系统”的美誉，至今仍然有人认为 OpenBSD 是专门为此目的开发的。

当 Reed 在 2001 年初宣布，已经与 OpenBSD 紧密集成的 IPFilter 并不受 BSD 许可证的保护时，OpenBSD 社区感到震惊。事实上，它使用的是几乎逐字复制的许可证，只是省略了对代码进行修改和分发结果的权利。问题在于，OpenBSD 版本的 IPFilter 包含了几项更改和定制，而这些更改显然不符合许可证要求。结果，IPFilter 于 2001 年 5 月 29 日被从 OpenBSD 源代码树中删除，几周内，OpenBSD 的开发版本（-current）中没有任何包过滤软件。

幸运的是，在此时，丹尼尔·哈特迈尔（Daniel Hartmeier）在瑞士进行了一些涉及内核黑客技术的有限实验，实验内容涉及网络代码。他首先将自己编写的一个小函数挂接到网络堆栈中，然后让数据包经过它。接着，他开始思考过滤问题。当许可证危机发生时，PF 已经在小规模开发中。PF 代码的第一次提交发生在 2001 年 6 月 24 日星期天，19:48:58 UTC。接下来是几个月的开发者密集活动，最终 PF 的版本作为 OpenBSD 3.0 基础系统的默认部分于 2001 年 12 月发布。^([4]) 该版本包含了数据包过滤的实现，包括网络地址转换（NAT），并且其配置语言与 IPFilter 相似，因此迁移到新的 OpenBSD 版本时没有遇到重大问题。^([5])

PF 证明是一个开发成熟的软件。2002 年，哈特迈尔在 USENIX 会议上发表了一篇论文，进行的性能测试表明，在压力测试下，OpenBSD 3.1 的 PF 与 OpenBSD 3.1 上的 IPFilter 或 Linux 上的 iptables 性能相当，甚至更好。此外，在 OpenBSD 3.0 的原始 PF 上进行的测试表明，从 3.0 版本到 3.1 版本，代码的效率得到了显著提升。^([6])

OpenBSD 的 PF 代码，由经验丰富且注重安全性的开发人员编写，配备了全新的数据包过滤引擎， naturally 引起了其他 BSD 系统的兴趣。FreeBSD 项目逐渐采纳了 PF，最初作为一个包管理器软件包，之后从 5.3 版本开始，作为三种数据包过滤系统之一，集成到了基础系统中。PF 还被包括在 NetBSD 和 DragonFly BSD 中。^([7])

本书聚焦于 OpenBSD 5.5 中可用的 PF 版本。根据需要，我会指出该版本与其他系统中集成的版本之间的显著差异。

如果你准备好深入 PF 配置，可以跳到第二章开始。如果你想花更多时间在不熟悉的 BSD 领域中摸索，可以继续阅读本章。

更新版的 PF 发布性能更佳

与计算机世界的其余部分一样，OpenBSD 和 PF 也受到了硬件和网络条件快速变化的影响。我最近没有看到与丹尼尔·哈特迈尔 USENIX 论文中进行的测试相当的测试，但 PF 用户发现其过滤开销适中。

作为一个例子（主要是为了说明即使是平凡的硬件配置也可以有用），我负责管理的小型办公室网络与外界之间的网关机器是一台 450MHz 的 Pentium III，配备 384MB 的 RAM。每当我检查时，从`top(1)`命令的输出来看，这台机器从未低于 96%的空闲状态。

还值得注意的是，当前的 PF 开发者主要是 Henning Brauer 和 Ryan McBride，他们在最近的发布版本中对 OpenBSD 的 PF 代码进行了大量重写，提升了性能，并将性能提升作为主要目标，使得从 4.4 到 5.6 的每个版本在性能上都有明显改善。

## 如果你来自其他系统

如果你正在阅读本节内容，是因为你正在考虑将你的设置从其他系统迁移到 PF，那么这一节是为你准备的。

如果你想使用 PF，你需要安装并运行一个 BSD 系统，例如 OpenBSD、FreeBSD、NetBSD 或 DragonFly BSD。这些都是很好的操作系统，但我个人最喜欢的是 OpenBSD，主要是因为几乎所有 PF 的开发工作都发生在这个操作系统中。我也觉得开发者的务实态度和系统的简洁性令人耳目一新。

偶尔，来自其他系统的 PF 实现会将一些小的改动和 bug 修复反馈到主 PF 代码库，但最新、最更新的 PF 代码始终可以在 OpenBSD 上找到。本书中描述的某些功能仅在 OpenBSD 的最新版本中可用。其他 BSD 系统通常会将 OpenBSD 最新发布的 PF 版本移植到它们的代码库中，以便在下次发布时使用，但同步更新远非保证，而且有时延迟会相当显著。

如果你计划在 FreeBSD、NetBSD、DragonFly BSD 或其他系统上运行 PF，你应该查看你系统的发布说明和其他文档，了解包含的 PF 版本。

### Linux 用户指南

Linux 和 BSD 之间的差异和相似之处如果深入探讨，可能会成为一个庞大的话题，但如果你对基本知识有一定掌握，应该不会花太多时间就能适应 BSD 的操作方式。在本书的其余部分，我将假设你能够熟悉 BSD 网络配置的基本内容。所以，如果你对 Linux 或其他系统的配置更为熟悉而不是 BSD，值得注意一些关于 BSD 配置的要点：

+   Linux 和 BSD 在命名网络接口时使用不同的约定。Linux 的约定是按照顺序标记机器上的所有网络接口，依次为`eth0`、`eth1`等（尽管在某些 Linux 版本和驱动组合中，你还会看到`wlan0`、`wlan1`等无线接口）。

    在 BSD 系统中，接口会被分配一个名称，该名称由驱动程序名和一个序列号组成。例如，使用 ep 驱动的旧版 3Com 卡会显示为`ep0`、`ep1`，依此类推；Intel 千兆卡可能会显示为`em0`、`em1`，依此类推。某些 SMC 卡会列为`sn0`、`sn1`，依此类推。这种系统非常合乎逻辑，使得查找该接口的具体文档变得更容易。如果你的内核（在启动时或在`ifconfig`输出中）报告说你有一个名为`em0`的接口，你只需在 Shell 命令行中输入`man em`，即可查找该接口支持的速度——是否有任何特殊要求，需要下载固件等等。

+   你应该了解，在 BSD 系统中，配置是以*/etc/rc.conf*为中心的。一般来说，BSD 系统会从文件*/etc/rc.conf*读取配置，该文件在启动时由*/etc/rc*脚本读取。OpenBSD 建议使用*/etc/rc.conf.local*来进行本地自定义，因为*rc.conf*包含默认值。FreeBSD 使用*/etc/defaults/rc.conf*来存储默认设置，使得*/etc/rc.conf*成为进行更改的正确位置。此外，OpenBSD 使用每个接口的配置文件，名为*hostname.<if>*，其中*<if>*会被接口名替换。

+   为了学习 PF，你需要专注于一个*/etc/pf.conf*文件，这个文件大部分将是你自己的创作。

如果你需要对所选 BSD 操作系统有更广泛和更全面的了解，请查阅操作系统的文档，包括 FAQ 和指南，可以在项目的网站上找到。你还可以在附录 A 中找到一些进一步阅读的建议。

### 关于 PF 的常见问题解答

本节内容基于我在电子邮件、会议和研讨会上收到的提问，以及在邮件列表和其他讨论论坛中出现的一些问题。这里以 FAQ 样式^([8])的格式涵盖了一些更常见的问题。

#### 我可以在我的 Linux 机器上运行 PF 吗？

总的来说，不能。在过去的几年里，PF 邮件列表上曾有某人宣称已开始将 PF 移植到 Linux，但截至目前为止，还没有人声称已完成这一任务。其主要原因可能是 PF 主要作为 OpenBSD 网络栈的一个深度集成部分进行开发。即使在经过十多年并行开发后，OpenBSD 代码与其他 BSD 系统仍然共享足够的基础，使得移植成为可能，但将 PF 移植到非 BSD 系统将需要重写 PF 的很大一部分代码，以及根据目标平台的需要进行集成。

对于 Linux 用户如何在 BSD 网络配置中找到方向的一些基本指导，请参阅 Linux 用户指南。

#### 你能推荐一个 GUI 工具来管理我的 PF 规则集吗？

本书主要面向那些在自己喜欢的文本编辑器中编辑规则集的用户。本书中的示例规则集足够简单，你可能不会从各种 GUI 工具提供的可视化选项中获得显著的收益。

一个常见的说法是，PF 配置文件通常足够可读，以至于不需要图形可视化工具。然而，确实有几种可用的 GUI 工具可以编辑和/或生成 PF 配置，包括一个完整的、定制的 FreeBSD 版本，名为*pfSense*（* [`www.pfsense.org/`](http://www.pfsense.org/)*），它包含一个复杂的 GUI 规则编辑器。

我建议你根据本书中与你的情况相关的部分进行学习，然后决定是否需要使用 GUI 工具，以便更舒适地运行和维护你所构建的系统。

#### 有没有工具可以将我的 OtherProduct^®设置转换为 PF 配置？

将网络设置（包括防火墙设置）从一种产品转换到另一种产品时，最佳策略是回到网络或防火墙配置的规范或政策，然后使用新工具实施这些政策。

其他产品不可避免地会有稍微不同的功能集，而你为 OtherProduct^®创建的现有配置可能会在某些特定问题的处理方式上有所不同，这些差异可能无法直接映射到 PF 及其相关工具中的功能。

拥有一份文档化的政策，并随着需求的变化及时更新，将使你的工作更加轻松。这份文档应包含一份完整的文字说明，解释你的设置旨在实现什么目标。（你可以通过在配置文件中添加注释来解释规则的目的，作为起点。）这使得可以验证你当前运行的配置是否真正实现了设计目标。在一些公司环境中，甚至可能有书面政策的正式要求。

寻找一种自动化转换的方式是完全可以理解的，尤其是对于系统管理员来说，这也许是预期的。我建议你克制这个冲动，在重新评估你的业务和技术需求之后，再进行转换操作，并（最好）在此过程中创建或更新正式的规范或政策。

一些作为管理前端的 GUI 工具声称能够输出多个防火墙产品的配置文件，并可能作为转换工具使用。然而，这样做的结果是将你与规则集之间增加了一层抽象层，并且你将受制于工具作者对 PF 规则集工作原理的理解。我建议你至少学习本书中相关的部分，然后再考虑花费大量时间进行自动化转换。

#### 我听说 PF 基于 IPFilter，我曾在 Solaris 中使用过 IPFilter。我可以直接将我的 IPFilter 配置复制过去，并立即得到一个可用的配置吗？

如果有人声称 PF 是“基于”IPFilter 的，那是不准确的。PF 是从零开始编写的，目的是替代被新删除的 IPFilter 代码。在 PF 的第一个版本中，设计目标之一是尽量保持语法与旧软件兼容，这样从 OpenBSD 3.0 过渡时，能够尽量减少痛苦，并且不会过度破坏现有配置，或者以不可预测的方式破坏它们。

然而，在未来的一个或两个版本中，认为没有 OpenBSD 用户仍然可能从包含 IPFilter 的版本进行升级是合理的，因此保持与旧系统兼容不再是优先事项。即便经过了 25 个 OpenBSD 版本和 12 年以上的积极开发，仍然保持一些语法相似性。试图将一个系统的配置加载到另一个系统中——例如，将 IPFilter 的配置复制到 OpenBSD 系统并尝试加载，或者将现代 PF 配置复制到 Solaris 系统并尝试作为 IPFilter 配置加载——几乎在所有情况下都会失败，除非是一些特别精心制作但仍然相当简单且实际上非常无用的配置。

#### 为什么 PF 的规则语法突然发生了变化？

世界发生了变化，PF 也随之变化。更具体地说，OpenBSD 开发者对他们的代码有着非常积极且务实的批判性关系，像 OpenBSD 的所有部分一样，PF 代码也在不断审查之中。

在超过十年的 PF 开发和使用过程中获得的经验教训，促使了代码内部的变化，最终让开发者们意识到稍微调整语法是有意义的。这些变化使 PF 语法更加一致，并且从长远来看，使用户的使用更加轻松，代价只是对配置文件进行一些轻微编辑。对你来说，用户，现在 PF 变得更加易用，而且比早期版本性能更好。如果你正在将系统升级到 OpenBSD 4.7 或更高版本，你将体验到真正的惊喜。

在 OpenBSD 5.5 中，你将找到另一个升级的好理由：新的流量整形队列系统，旨在替代久负盛名的 ALTQ 系统。虽然 ALTQ 仍然是 OpenBSD 5.5 的一部分，且略有修改，但它已经在 OpenBSD 5.6 版本中被移除。关于迁移到新流量整形系统的内容可以在第七章找到专门的部分。

#### 我在哪里可以了解更多信息？

有几个很好的资源可以了解 PF 以及它运行的系统，你已经在本书中找到了一个。你可以在附录 A 中找到一些印刷版和在线资源的参考。

如果你有安装了 PF 的 BSD 系统，可以查阅在线手册页或 *man 页*，获取有关你所使用的软件版本的详细信息。除非另有说明，本书中的信息指的是从 OpenBSD 5.5 系统的命令行视角所看到的世界。

## 一点鼓励：PF 俳句

如果你还没有完全相信，或者即使你已经相信了，也许还是需要一点鼓励。多年来，很多人已经对 PF 发表了自己的看法——有时很奇怪，有时很精彩，有时则非常怪异。

这里引用的诗歌很好地反映了 PF 有时激发用户情感的程度。这首诗出现在 PF 邮件列表中，最初是一封主题为“Things pf can’t do?”的邮件，在 2004 年 5 月开始。这封邮件的作者是一个没有太多防火墙经验的人，因此在设置过程中遇到了困难。

当然，这引发了一些讨论，几位参与者表示，如果 PF 对新手来说很难，其他替代方案也不会更好。该讨论以 Jason Dixon 于 2004 年 5 月 20 日写的俳句结尾。

```
Compared to working with iptables, PF is like this haiku:

A breath of fresh air,
floating on white rose petals,
eating strawberries.

Now I'm getting carried away:

Hartmeier codes now,
Henning knows not why it fails,
fails only for n00b.

Tables load my lists,
tarpit for the asshole spammer,
death to his mail store.

CARP due to Cisco,
redundant blessed packets,
licensed free for me.
```

Dixon 在这里提到的一些概念可能听起来有些陌生，但如果你继续阅读，很快就会明白。

* * *

^([1]) Windows 时代之前著名的蠕虫包括 IBM 圣诞树 EXEC 蠕虫（1987 年）和第一只互联网蠕虫 Morris 蠕虫（1988 年）。有关这两者的丰富信息可以轻松通过你喜欢的搜索引擎找到。Windows 时代的网络蠕虫被认为是从 2000 年 5 月的 ILOVEYOU 蠕虫开始的。

^([2]) 有关 OpenBSD 安全方法的多个演讲可以通过* [`www.openbsd.org/papers/`](http://www.openbsd.org/papers/)* 的汇总找到。我最喜欢的一些包括 Theo de Raadt 的《Exploit Mitigation Techniques》（以及 2013 年的后续讲座《Security Mitigation Techniques: An Update After 10 Years》），Damien Miller 的《Security Measures in OpenSSH》，以及 Henning Brauer 和 Sven Dehmlow 的《Puffy at Work—Getting Code Right and Secure, the OpenBSD Way》。

^([3]) 如果 *BSD* 这个词听起来不熟悉，这里有一个简短的解释：这个缩写代表 *Berkeley Software Distribution*，最初指的是加利福尼亚大学伯克利分校的工作人员和学生为 Unix 操作系统开发的一系列有用软件。随着时间的推移，这些软件扩展成了一个完整的操作系统，而这个操作系统成为了一个系列操作系统的前身，包括 OpenBSD、FreeBSD、NetBSD、DragonFly BSD，甚至按某些定义，包括苹果的 Mac OS X。要了解 BSD 是什么，可以阅读 Greg Lehey 的《Explaining BSD》，该文发表于 *[`www.freebsd.org/doc/en/articles/explaining-bsd/`](http://www.freebsd.org/doc/en/articles/explaining-bsd/)*（当然，还有各个项目的官方网站）。

^([4]) IPFilter 版权事件促使 OpenBSD 团队对整个源代码树进行许可证审计，以避免未来出现类似情况。在接下来的几个月中，解决了几个潜在问题，最终消除了许多可能的许可证陷阱，惠及所有参与自由软件开发的人。Theo de Raadt 在 2003 年 2 月 20 日向*openbsd-misc*邮件列表发送的消息中总结了这一努力。许可证危机的初步剧烈波动已经平息，而最终的成果是一个新的基于自由许可证的包过滤系统，具备最佳的代码质量，并且 OpenBSD 本身及其他广泛使用的自由软件中的大量代码也获得了更好的自由许可证。

^([5]) 与 IPFilter 配置的兼容性是 PF 开发者早期的设计目标，但一旦可以安全地假设所有 OpenBSD 用户已经迁移到 PF（大约在 OpenBSD 3.2 发布时，如果不是更早的话），这一目标就不再是优先事项。你不应该假设现有的 IPFilter 配置在任何版本的 PF 中都能无修改地工作。随着 OpenBSD 4.7 引入的语法变化，即使是从早期 PF 版本的升级，也需要进行一定的转换工作。

^([6]) 提供这些测试详细信息的文章可以在 Daniel Hartmeier 的网站上找到。请参阅 *[`www.benzedrine.cx/pf-paper.html`](http://www.benzedrine.cx/pf-paper.html)*。

^([7]) 曾经存在过一款运行在 Microsoft Windows 上的个人防火墙产品，名为*Core Force*，它是基于 PF 的移植版本。到 2010 年初，开发 Core Force 的公司 Core Security（*http://force.coresecurity.com/*）似乎已经将重心转向了其他安全领域，如渗透测试，但该产品仍然可以下载。

^([8]) 三个字母的缩写 FAQ 可以扩展为*frequently asked questions*或*frequently answered questions*——两者都是有效的。
