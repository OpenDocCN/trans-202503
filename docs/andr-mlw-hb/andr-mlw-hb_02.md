## **1

ANDROID 安全基础**

![Image](img/common.jpg)

要理解 Android 恶意软件，必须理解 Android 操作系统的安全模型。特别是，必须识别在此模型边界内运行的恶意软件样本以及试图突破其限制的样本。本章介绍了使此成为可能的 Android 安全和恶意软件的基本概念。

### **Android 安全模型**

很久以前，第一个恶意软件上传到 Google Play 之前，Android 操作系统和安全团队做出了几项设计决策，以帮助保护用户免受恶意软件侵害。例如，他们重用 Linux 用户账户系统来隔离 Android 应用程序，这一选择使得应用程序之间几乎无法恶意互动或从文件系统中窃取数据。任何想要这样做的恶意软件都必须使用获取 root 权限的漏洞利用或其他类似稀缺的特权升级技术来降低设备安全性。同样，应用权限系统的引入比旧操作系统是一大进步，因为它给予用户更精细的控制，决定哪些敏感数据和功能应用程序允许访问。

当第一个恶意软件在 Google Play 上被发现时，威胁局势发生了变化。Android 已经如此流行，以至于恶意软件开发者通过滥用 Android 应用程序赚钱，之前可能会为其他平台开发恶意软件的人开始认真看待 Android。

针对这些新威胁，Android 安全团队专注于深度防御方法。Google 开发了 Android 生态系统的关键部分，尤其是 Google Play、操作系统和手机硬件（Nexus 和 Pixel 设备），使其处于强大的防御位置。随着新攻击的出现，Android 安全团队能够通过加固 Android 平台、改革 Google Play 的规则以及改进应用程序扫描器来发现 Android 开发者上传的应用程序中的恶意功能来对抗它们。

Google 构建了一个*Android 安全模型*，随着每个 Android 版本的更新而更新，采用多层防御方法，其中每一层防御都试图阻止攻击。即使一层不能完全阻止攻击，恶意软件开发者也必须找到绕过一个或多个额外保护层的方法，这增加了成本并降低了滥用的可能性。以下各节详细解释了这些层次及其互动。

#### ***应用隔离***

Android 安全模型的第一层是*应用隔离*。我们提到，从 Android 的第一个版本开始，操作系统就使用 Linux 用户账户系统来隔离应用程序和进程。每个应用程序被分配一个新的 Linux 用户 ID（UID），无法访问其他应用程序的私有数据或进程内存。

随着时间的推移，Google 使用其他技术增强了这种沙盒模型。Android 4.3（Jelly Bean）是第一个使用增强安全的 Linux（Security-Enhanced Linux，简称 SELinux）的版本。*SELinux* 是一个 Linux 内核模块，用于配置系统不同部分的访问控制安全策略。尽管它以难以部署而著称，且在其他版本的 Linux 中默认情况下很少启用，但事实证明，SELinux 是非常强大的，它的实现成为了保护 Android 免受特权提升恶意软件攻击的重要安全特性之一。即使是利用 root 权限漏洞获取提升特权的恶意软件，也会受到其访问控制的限制。

进程隔离技术也随着时间的推移得到了改进。例如，Android 10 引入了*范围存储*。以前，所有 Android 设备上的应用都共享访问设备外部存储的权限，因此一个应用写入的文件可以被设备上任何其他应用读取。如果一个应用想存储敏感信息，它应该使用内部存储系统，在那里每个应用都有自己的受保护空间。当然，许多应用行为不端，将敏感信息存储在外部存储中。间谍软件很容易访问这些信息，其他应用也可能无意中读取、写入或删除这些数据。为了保护应用数据，范围存储引入了类似内部存储使用的访问机制，现在每个应用都可以安全地在外部存储中存储敏感数据，而不会被其他应用盗取或篡改。

Android 11 引入了额外的功能来隔离应用之间的相互访问。在 Android 11 之前，设备上的应用程序可以查找其他已安装应用的信息。这使得应用程序能够对用户的个人生活做出假设。Android 11 严格限制了这种能力，这被称为*包可见性*，希望通过这种方式，应用程序不再能够识别用户的潜在敏感信息。

#### ***攻击面减少***

应用隔离无法防止那些能够突破 Linux 用户空间或绕过 SELinux 的攻击。Android 安全模型的第二层是*攻击面减少*，即最大限度地减少潜在攻击者访问代码、API、服务或应用其他部分的做法。

减少攻击面有很多方法。最明显的做法是移除不必要的代码、系统模块、开放端口或暴露给黑客的 API；系统中暴露的组件越少，安全性就越容易提高。类似地，减少代码的复杂性和大小也是一种良好的安全软件开发实践。复杂性使得代码难以理解，难以保护，也容易被利用，因为程序员必须考虑的边缘情况变得难以控制。代码越少，编程错误的机会越少，潜在的攻击点也越少。

如果无法减少复杂性，使代码对漏洞利用不可访问几乎是同样有效的策略，也是 Android 团队多年来采取的做法。例如，为了应对一系列统称为 Stagefright 的漏洞，Android 安全团队在 Android 7.0（Nougat）中彻底重构了脆弱的 `mediaserver` 组件，尽量减少暴露的 API 数量。此外，风险代码被移入更强的自定义沙箱中，且不需要的功能，如 *execmem*（一种危险的 SELinux 权限，用于将内存页面标记为可执行）被移除。2016 年的 Android 安全博客文章《加固媒体栈》提供了更多细节。

Android 安全团队添加的另一项攻击面减少技术是 *seccomp*，该技术在 Android 8.0（Oreo）中引入。*seccomp* 是 *安全计算模式* 的缩写，是一种 Linux 技术，充当用户级进程和内核之间的防火墙。通过使用伯克利数据包过滤器（BPF）编写的过滤规则，它可以阻止用户级进程执行某些系统调用，并且还可以终止用户级进程。在 Android 中启用 seccomp 可以移除那些在权限提升尝试中本可供应用使用的系统调用。

Android 9.0（Pie）通过禁止应用程序通过反射或本地代码访问内部 Android API 方法，再次显著减少了恶意应用的潜在攻击面。从此以后，只有属于公共 Android API 的方法才能被应用程序访问。除了通过强制应用程序使用官方 API 来改善跨 Android 版本的应用兼容性外，这一变化对安全性也至关重要。在引入这一限制之前，Android 应用开发者偶尔能够找到通过私有方法调用内部 API 的方式，这些方法绕过了权限系统和其他限制。

攻击面减少也可以采取完全不同的形式。例如，根据 Android 安全团队汇总的统计数据，迄今为止被最广泛利用的 Android 漏洞依赖于内存损坏。近期版本的 Android 开始引入使用 Rust 编写的组件，Rust 是一种内存安全的编程语言，预计能减少内存损坏漏洞的数量。

#### ***漏洞利用缓解***

Android 是一个复杂的通用操作系统，包含了数百万行代码。无论删除、使其无法访问还是将其沙盒化，总会有机会让漏洞出现。因此，许多安全团队假设每个攻击者都可能有一次运气好的机会；然而，运气好两次的可能性较小。这为 Android 众多的*漏洞缓解措施*提供了一个简化的正当理由，这些措施旨在让攻击者更难（甚至无法）成功攻陷系统。官方的 Android 安全网站维护了自 Android 1.5 以来引入的安全增强功能的详细列表，网址是 [*https://source.android.com/security/enhancements*](https://source.android.com/security/enhancements)。

Android 的早期版本专注于添加漏洞缓解技术，以赶上其他操作系统中的现有防御措施。在 Android 4.0（Ice Cream Sandwich）之前，它们加入了地址空间布局随机化（ASLR）、基于硬件的不可执行（NX）以及内存分配和释放的加固技术等防御措施。

这些缓解技术的加入意味着，编写传统的利用 shellcode（旨在运行在受控内存区域中的恶意代码）变得非常困难。Android 的内存布局变得不可预测，找到可执行的内存区域变得更加稀少。为了应对这一点，攻击者开始串联利用漏洞，逐个绕过这些防御。在现代 Android 系统中，这样的漏洞链条非常复杂，通常需要几个月的时间来开发。

#### ***设备完整性***

*设备完整性*尝试确保设备处于其原始预定状态。特别是，它旨在确保攻击者没有在设备的关键部分（如操作系统）植入后门或其他有害代码。当黑客绕过了前面各层的所有防御后，他们通常希望在系统中获得一个永久的立足点。多年来，Android 一直在让这一过程变得越来越困难。

Android 4.4（KitKat）引入了一项名为“验证启动”（Verified Boot）的技术，旨在阻止恶意行为者修改启动加载程序。验证启动的核心原理是，在执行设备启动过程的每个组件之前，都要确保其完整性已得到验证。如果启动过程中的任何部分未能通过验证，用户会收到警告，提示设备已被篡改，安全性无法得到保障。

全磁盘加密在 Android 5.0（Lollipop）中作为选项启用，并在 Android 6.0（Marshmallow）中成为强制性要求。Android 7.0（Nougat）进一步引入了基于文件的加密，这是对全磁盘加密的改进，允许磁盘上的不同文件使用不同的密钥进行加密。基于文件的加密在 Android 10 中成为强制要求。虽然它们不是防止设备上运行的漏洞攻击的防御手段，但全磁盘加密和基于文件的加密确实有助于防止攻击者在物理访问设备的情况下试图读取磁盘上的数据或篡改数据。

#### ***权限***

Android 安全模型的第五层是*权限*，它是 Android 用于控制访问敏感系统资源和数据的用户同意模型。对于每个敏感操作，应用必须在 Android 操作系统允许操作继续进行之前请求用户同意。例如，如果一个应用想要读取联系人列表的信息或发送短信，它需要首先获得用户的许可。

在早期版本的 Android 中，应用想要使用的所有权限必须在安装应用之前授予。那些不想授予所有请求权限的用户无法安装应用，这既不方便，也是滥用和用户投诉的常见来源。从 Android 6.0（Marshmallow）开始，Android 实现了运行时权限系统，应用在运行时请求权限。这一变化提高了应用控制，因为用户现在可以为敏感操作授予或拒绝单个、更细粒度的权限。例如，如果用户愿意让应用发送短信，但不希望其访问联系人列表，他们可以授予短信权限，同时拒绝联系人列表权限。

运行时模型还允许应用仅在需要时请求权限。如果用户从未尝试使用某个应用进行敏感操作，一个编写良好的应用将永远不会请求相关权限。这提高了用户对开发良好的应用的信任。

一些 Android 应用可用的权限尤其敏感，无法通过默认的权限对话框授予。例如，如果一个应用想要安装其他应用，用户必须首先进入设备设置并授予该应用此权限。同样，如果一个应用想要使用无障碍 API，该 API 会改变 Android 安全模型的某些部分，以更好地支持残障用户，用户必须首先通过一系列警告对话框。

#### ***安全更新***

Android 安全模型包括常规的*安全更新*。这些更新越快地推送到设备并被用户安装，攻击者利用已发现漏洞的时间就越少。

Android 的早期版本在更新时非常繁琐，无论安全更新多么小。更新流程和基础设施尚未成熟，导致从修补代码到实际部署到设备之间存在长时间的延迟。早期的更新也不够用户友好。在更新过程中，用户往往无法使用手机超过 10 分钟，降低了他们安装安全更新的意愿。

随着时间的推移，Android 操作系统使系统更新变得更加便捷，不仅用户体验更好，设备制造商也受益。更新现在可以在设备正常使用时在后台进行，用户只需重启设备来完成更新过程。更新流程的架构也得到了精细化改进。许多以前通过系统更新流程更新的关键组件，现在已经被重写成独立的应用程序，可以通过正常的 Google Play 应用更新流程进行更新。一个重要的例子就是默认的 WebView 组件，它用于解析和渲染 HTML 内容。解析和渲染过程的代码复杂性使得 WebView 成为黑客攻击的重点目标。如今，如果 WebView 漏洞被报告给 Android 安全团队，或者在网络中发现了漏洞，更新 WebView 组件的时间可以从几个月缩短到几天。

允许核心组件独立更新的架构变化同样影响到了核心 Android 操作系统。在 Android 8.0 (Oreo) 中，Google 宣布了 Project Treble，它引入了一种抽象层机制，将操作系统与设备制造商添加的修改和扩展分离。Treble 的目标是通过将设备制造商从更新流程中移除，使核心操作系统能够更快地进行更新：制造商将负责独立更新其自定义的部分，并按自己的节奏进行。

Android 9.0 (Pie) 和 Android 10 通过通用系统映像（Generic System Images，简称 GSI）进一步帮助原始设备制造商更高效地更新系统，这加快了新 Android 版本的测试进程；同时，Project Mainline 使得制造商可以通过 Google Play 分发系统更新。这些变化使得 Android 10 成为历史上部署最快的 Android 版本，其采用率约是 Android 9.0 (Pie) 的两倍，Android 8.0 (Oreo) 的四倍。

#### ***附加安全和安全服务***

Android 安全模型的第七层涉及运行在 Google 基础设施上的附加安全和安全服务。根据服务的不同，这些服务可供应用开发者或用户使用。

为 Google Play Protect 提供支持的 Android 恶意软件扫描器是这些服务之一。Google Play Protect 是 Google 的设备端恶意软件检测和警告系统，该扫描器会持续接收来自人类和机器的应用信号和决策，以主动识别并阻止设备和 Google Play 上的应用级威胁。用户可以通过 Google Play 应用或设备的安全设置查看恶意软件扫描的结果。

面向开发者的服务包括像“安全浏览”和“SafetyNet”这样的 API。安全浏览 API 可以保护用户免受 Chrome、Firefox 以及其他集成了安全浏览技术的浏览器中恶意网站的侵害。SafetyNet API 允许任何应用在执行敏感操作（如收集用户凭证或支付信息）之前，检查设备的多个完整性方面。由于这些服务依赖于访问 Google 的后台基础设施，因此它们仅在配备了 Google Play 和 Google Play 服务模块的 Android 认证设备上可用。

#### ***跨 Google 的合作***

除了多年来不断提升 Android 操作系统的安全性和隐私保护外，Android 安全团队还与 Google 的其他团队合作，致力于使平台使用起来更安全。

例如，Android 安全团队与负责推出新 Google Play 政策的团队进行合作，许多政策旨在让恶意应用更难进入 Google Play。2017 年 5 月，团队明确表示，应用不得从 Google Play 以外的来源下载额外的代码，因为这种技术仍然是绕过 Google Play 恶意软件扫描器的关键恶意软件手段。

举几个其他例子，2019 年 8 月，Google Play 禁止了非代理应用的网络代理行为，以应对代理工具在未经用户同意的情况下销售访问用户设备资源和网络的行为。2020 年 4 月，Google Play 在应对跟踪软件时采取了更为严格的立场，要求监控应用必须采取最低步骤以限制其滥用潜力。Google Play 政策团队维护着一个网站，[*https://support.google.com/googleplay/android-developer/answer/9934569*](https://support.google.com/googleplay/android-developer/answer/9934569)，该网站列出了自 2016 年以来 Google Play 政策的变更。

#### ***旁加载和预加载恶意软件保护***

即使 Android 安全团队致力于清除 Google Play 中的恶意软件，它也意识到应用*旁加载*，即从 Google Play 以外的来源安装应用，远比恶意软件更具危险性。根据每年发布的*Android 安全年度回顾*报告，恶意软件在 Google Play 外的出现频率约为 Google Play 的 7 到 15 倍，因此仅仅专注于 Google Play 不足以保护整个 Android 生态系统。

为了防御侧载恶意软件，Android 安全团队在 2012 年开发并推出了 SafetyNet 恶意软件防护系统。我们之前提到过的这项技术最终演变成了 Google Play Protect。SafetyNet 在所有安装了 Google Play 应用的 Android 设备上默默运行。用户与 SafetyNet 唯一的互动就是当它检测到设备上的恶意软件时。因为大多数 Android 设备从未安装过恶意软件，所以大多数用户从未与 SafetyNet 互动过。  

接下来，Android 安全团队建立了保护预装应用的系统，以应对一些厂商在设备上预装恶意软件的发现。特别是，团队在 2018 年推出了 Build Test Suite（BTS）。BTS 会扫描所有预装了常见 Google 应用（如 Gmail、Google Play 和 Google Maps）的 Android 品牌设备的系统映像。这项扫描适用于所有厂商，无论其受欢迎程度如何。平均而言，一款新设备会预装约 400 个应用，许多公司参与了这些应用的构建、维护和分发。采用这种模式且没有适当控制的情况下，一些新 Android 设备的用户可能会有意或无意地接触到问题应用。  

### **Android 包**  

尽管 Google 多年来实施了许多安全增强措施，恶意软件仍在不断演变，影响着全球众多用户。如今，有数百万个 Android 应用可以从 Google Play、网站和其他应用商店下载。它们都使用一种通用的文件格式，即 *Android 包（APK）*，而且大多数是用 Java 编写的。

APK 本质上是一个 ZIP 压缩的归档文件，存储着应用的代码。由于应用的类文件不能直接由 Android 设备的中央处理器（CPU）执行，它们需要被编译成 Android 特定的字节码，以便在 Android 运行时（ART）虚拟机或其前身 Dalvik 中执行。这些虚拟机为不同的硬件架构存在，使得应用能够在各种设备上运行，包括手机、平板、笔记本电脑、手表、家用电器、电视、车载控制台等。APK 包含供 ART 或 Dalvik 使用的 *.dex* 文件，还包含将代码编译成针对特定硬件的本地汇编语言的 *.so* 库文件。它还包括一个名为 *AndroidManifest.xml* 的文件，描述应用的元数据，以及应用的电子证书和其他资源，如 XML 代码或 *.png* 图像。  

成千上万的开发者，从个人到大型企业（包括谷歌），每天都会创建新的 APK 来更新应用，增加新功能、修复漏洞和提供新服务。不幸的是，并非所有开发者都遵守规则。有些开发者构建的应用可能会有害，滥用安卓的丰富 API、系统资源、权限和未修补的漏洞，从事欺诈行为、获取用户数据或窃取用户凭证。

### **安卓恶意软件的分类**

谷歌的安卓安全团队多年来跟踪了许多恶意软件类别。任何表现出至少一种以下行为的应用程序都被视为恶意软件，无论开发者是否故意在应用中包含有害代码，并将被安卓安全团队成员和恶意软件检测平台标记为恶意软件。需要指出的是，实际应用程序可能呈现多种有害或恶意行为，因此可能会被归类为多个类别。

许多恶意软件类别有共同特征。一般来说，恶意软件通常会尝试（1）通过隐藏其恶意功能来避免被扫描器和安全分析师发现，（2）保持安装状态并避免用户或安全软件删除，（3）直接或间接地赚钱，例如通过收集和出售用户数据、安装其他应用、虚假点击广告以及滥用设备能够访问的系统或网络。

以下部分描述了对安卓生态系统及其用户有影响的恶意软件类别。

#### ***拒绝服务***

*拒绝服务（DoS）*指的是设备、系统或服务的可用性受到破坏。例如，可以通过利用系统完整性问题（如堆栈或堆内存损坏漏洞）发起 DoS 攻击，这会导致系统崩溃，或者通过发送大量超出系统处理能力的请求来使系统崩溃。在尝试处理这些请求时，系统可能会关闭，或者至少在一段时间内对新请求没有响应。

DoS 攻击的后果可能非常严重。例如，对于接收在线订单或支付的系统，任何停机时间都可能直接影响到业务的盈利。恢复 DoS 攻击可能也需要高昂的成本，因为可能需要系统升级、修补漏洞、新的防护功能和工具、额外的容量等。对于像医院、食品供应链和公共事业等关键基础设施，DoS 攻击不仅可能造成经济损失，还可能引发大规模的公共安全问题。

提到 Android 时，主要的拒绝服务（DoS）问题是大量设备可能成为攻击者选择目标的滥用工具。一些 DoS 攻击是在用户不知情的情况下进行的；在许多情况下，用户的设备会被加入到一个*僵尸网络*中，僵尸网络是由特定黑客控制的一组设备，黑客的目标是执行*分布式拒绝服务（DDoS）*攻击。在这种攻击中，安装了相同恶意应用的大量设备可能每个都通过网络向目标 Web 服务器发送大量 HTTP 请求。流量量大到服务器最终无法处理过多的负载，这会导致服务器的接收队列和其他内部数据结构被淹没。结果，服务器开始丢弃或拒绝新的请求，包括合法的请求，这几乎让它脱机。

DDoS 攻击可以采取各种形式。在某些情况下，DDoS 攻击是由安装时随应用一起提供的代码执行的。在其他情况下，包含 DDoS 逻辑的代码会在执行时动态从指挥与控制服务器获取，同时获取目标 IP 地址、开始日期和时间、攻击持续时间等数据。Android 安全团队还遇到过安装在许多设备上的应用程序，这些应用使用 WebView 持续地一次又一次地获取和加载相同的资源，例如来自 Web 服务器的图像文件，从而导致性能急剧下降并无法响应。在其他情况下，一个恶意应用程序支持各种滥用功能，可以在远程指挥与控制服务器的请求下执行。服务器向所有安装了该应用的设备发送特定的执行参数。

来自移动僵尸网络的攻击到目前为止非常罕见，安全公司仅公开记录了其中几起。然而，随着全球移动连接变得更加稳定和强大，我们预计这一现状会发生变化。此外，*无意*的 DDoS 攻击被报告的较少。这种攻击发生在开发者将定时连接硬编码到 Web 服务器时。当带有定时连接的应用程序变得流行时，每个安装该应用的设备可能会在同一时间连接到 Web 服务器。一个较小的 Web 服务器在午夜突然面对百万个请求时，很容易遇到问题。在过去几年中，约一半的 DDoS 案例涉及到 Android 安全团队调解笨拙的应用开发者与不满的 Web 服务器所有者之间的纠纷，后者无法解决来自 Android 设备的大量连接问题。

#### ***后门***

一个*后门*应用会打开一个意外的通信通道，连接到一个指挥与控制服务器，服务器指示应用执行不需要的远程控制操作。这些操作可能包括其他恶意行为，这些行为本应将应用归入其他恶意软件类别（例如间谍软件、钓鱼或 DoS）。

后门应用执行广泛的操作，包括：

+   使用提升的系统应用权限（例如授予预安装应用的权限）从攻击者控制的服务器安装下载的应用

+   根植设备，以便能够自由地对文件系统进行写操作

+   从设备中收集用户信息，例如联系人列表、设备位置数据、短信、用户的电话号码和通话历史，或已安装应用程序的包名

+   向高收费短信号码发送短信

+   捕获敏感数据，包括凭据，并要求用户填写发送数据给欺诈者的网页表单

+   获取并展示广告

后门应用与命令控制服务器之间的通信通常是隐藏的、间接的，或通过混淆或加密方法进行保护。例如，一些恶意软件家族使用常见的加密算法（如 AES 和 3DES）加密数据或代码，使用 Base64 或 XOR 进行编码，使用代码压缩进行混淆。它们可能通过 TCP 端口跳跃以及使用 IRC 聊天、Firebase 和 X（前身为 Twitter）等平台的隐蔽通道来规避检测。如果用户阻止了命令控制服务器与应用之间的通信通道，感染的设备将无法再被管理，因此许多恶意软件作者会尽力保护这一点。

一些后门应用已知会积极尝试在设备上实现持久性，使用户或恶意软件扫描程序无法轻易禁用它们。一种方法是依赖于内置的应用程序，这些应用程序包含后门逻辑。然而，更常见的方法是使用相对简单的预安装应用的系统权限，稍后安装后门应用，并在检测到后门已被删除时重新安装该应用。其他保护恶意软件在设备上存在的技术包括将应用图标从主屏幕上隐藏，创建一个快捷方式来替代应用图标，禁用杀毒软件，以及将应用程序移动到只读位置（如*/system/app*）。

#### ***Rooting***

在 Android 中，*rooting*应用是一个无特权应用，通过利用 Android 操作系统或制造商特定设备组件中的漏洞，获得代码执行和管理员级别的权限，或者获得作为*root*的身份：系统中最特权的用户，标识为用户标识符（UID）0。由于 Android 采用了多种控制措施来隔离应用和操作系统资源，包括 Linux 文件系统权限、在不同 UID 下执行的进程以及 SELinux 访问控制策略，想要执行特权操作的无特权应用必须找到一个安全漏洞来绕过这些控制。

Root 应用通常依赖于已公开披露并分配了公共漏洞与曝光（CVE）ID 的已知 Android 漏洞。当设备上未打补丁时，这些漏洞可能会导致特权提升到 root。然而，利用新漏洞（即零日漏洞）的应用程序已经变得越来越罕见。如今，它们几乎完全是由一些国家支持的行为体所控制，这些行为体背后通常是所谓的高级持续性威胁（APT）。

这些漏洞通常是 Linux 内核组件和设备驱动程序中的内存损坏问题，这些驱动程序作为系统服务与外设和无特权应用程序之间的接口。一旦这些组件被攻破——例如，通过栈溢出或代码注入——攻击者可能能够在这些特权进程的上下文中执行他们的代码。当恶意应用获得 root 权限时，它可能会执行额外的操作以实现持久化、读取敏感数据或下载和安装其他应用。例如，应用可能会从另一个应用的目录中读取用户数据；进行系统配置更改，例如启用来自第三方来源的应用安装或禁用 Google Play Protect；读取身份验证令牌以访问用户账户；或将恶意代码注入系统运行时库中，以便即使在重启后它们仍然能继续执行。

通过设备上的恶意应用获取 root 权限并不意味着自动获得对系统资源的完全访问权限。在某些情况下，取决于 Android 操作系统版本和设备的 SELinux 配置，即使是以 root 身份运行的应用也无法访问某些后续的 root 技术。即便如此，由于每个设备的配置不同且可能随时间变化，仍然有一些 root 应用能够成功。

一些 root 恶意软件配备了一系列漏洞，这些漏洞会根据某些参数（如运行在受影响设备上的 Android 版本和特定设备驱动程序的存在）选择性地执行。在其他情况下，应用可能会顺序执行所有漏洞，一次一个，直到其中一个成功。此外，与其他恶意软件家族一样，该应用还可能在后期尝试动态加载恶意代码。例如，root 应用常常会收集其运行设备的指纹信息并将其发送到远程服务器，服务器会返回一个特定设备的漏洞模块。这使得 root 应用能够适应新类型的设备。与此同时，漏洞开发者不必通过公开所有漏洞来暴露自己。

需要注意的是，非恶意和恶意的 root 应用程序之间是有区别的。非恶意 root 应用明确宣传自己是用于 root 设备的工具，并且不会在后台执行其他有害操作。而恶意 root 则发生在应用未披露其目的并且未经用户同意执行 root 操作时。在这两种情况下，Android 安全团队会将这些应用标记为恶意软件，因为它们对系统安全的影响。然而，即使非恶意的 root 应用可能会让系统处于一个脆弱的状态，用户仍然可以选择安装该应用，并忽略来自 Google Play Protect 或其他恶意软件扫描器的警告。Android 生态系统赋予用户这种灵活性。

#### ***特洛伊木马***

*特洛伊木马*应用看似是良性的（例如，它们可能伪装成一个流行的应用），但却包含隐藏的功能，执行不良的操作。这些应用有一个无害的组件，用来通过提供一些有用的功能来获取用户的信任。然而，除了这个无害的组件，它们还包含对用户不可见的恶意逻辑。

特洛伊木马和其他恶意软件的创作者常用的一种技术是，首先发布一个通过所有 Google Play 检查的干净 APK 文件，以便到达用户设备。然后，几天或几周后，他们会创建并发布一个新版本的 APK，这次包含恶意功能，用户会将其作为应用更新安装。这种技术的优势在于，它允许恶意应用在不担心从 Google Play 或用户设备中被移除的情况下建立安装基础。如果恶意更新成功通过 Google Play 扫描，可能有成千上万的设备会安装这个新功能。

恶意应用，包括特洛伊木马，也滥用了 Android 系统中的一个特性，允许 Java 代码调用为设备硬件编译的非 Java 代码。这个*Java 本地接口（JNI）* 让应用加载通常存储在*.so*文件中的库，这些文件捆绑在 APK 中，可能包含恶意代码。如果恶意软件扫描器只检查 Java 字节码或反编译后的 Java 代码，可能无法察觉这些硬件特定库中存在的恶意逻辑。事实上，我们已经看到一些恶意软件样本明显使用本地代码，目的只是为了躲避恶意软件扫描器。例如，某些恶意软件完全使用 Java 编写，只有一个最小的解密功能是用本地代码编写的，或者甚至只是一个小的本地代码函数，什么也不做，只是返回 Java 代码使用的加密密钥。不支持跨架构控制和数据流分析的静态分析引擎将被这种简单的技术难住。

木马应用程序可以执行各种隐藏操作。例如，一些银行木马通过伪装成流行的应用程序，针对移动银行用户，这些应用程序提供转账、支票存款和其他账户服务。如果用户被欺骗下载了假冒应用程序，他们可能最终会将自己的账户凭证交给诈骗者。其他应用程序可能会等待用户执行合法的银行应用程序，然后通过在合法应用程序上覆盖显示输入表单来拦截用户名和密码，从而捕获用户数据。在身份验证过程中，银行应用程序可能会向用户的设备发送一次性密码（OTP）；木马应用程序可能会尝试读取这些短信。

其他木马家族操控在线用户评论，从指挥和控制服务器获取虚假评论文本，然后将其发布在各种平台上，以人为地抬高评分。这种滥用行为还涉及创建大量虚假用户帐户，以给人一种真实用户发布评分的假象。

在过去的几年里，一些代理网络应用程序因恶意软件行为而被标记。这些代理服务允许付费用户匿名访问在线资源，否则这些资源会受到防火墙和 IP 地址限制的保护。例如，它们可能允许国家 A 的用户访问国家 B 的资源。这些应用程序的问题在于，它们常常未告知用户，他们的设备将成为代理网络的出口节点，或者他们的系统资源将代表他人传输流量（可能与非法活动相关）。

另一种几年前出现的木马类型是加密货币挖矿恶意软件。这些应用程序感染大量设备，并使用系统资源（无论它们多么有限）在后台挖掘加密货币。在许多情况下，挖矿过程对用户没有任何披露，未经用户同意，恶意软件滥用设备的电池寿命和处理能力。如果用户意识到挖矿行为，他们所能获得的财务收益也非常有限。

一些木马应用程序允许攻击者远程管理目标设备。这些应用程序与后门应用程序有一些相似之处，通常被称为*远程访问木马（RATs）*。RAT 恶意软件通过伪装成无害程序来隐藏其目的，通常使用键盘记录器、root 权限和其他技术来安装应用程序、执行命令以及窃取用户数据。

#### ***间谍软件***

*间谍软件*的目标是找到、收集并传输个人数据，而未经用户同意。这些数据可以被卖给第三方，或用于了解用户的行为，或许可以为他们提供可能感兴趣的应用程序。在最严重的间谍软件案例中，应用程序可能通过访问用户的实际位置（无论是通过读取 GPS 数据还是通过其他方式）、照片、浏览历史、搜索历史、已安装的应用列表、短信和通话历史来有效地监视用户。有些间谍软件甚至会激活摄像头或麦克风，试图识别用户、观察他们的行为或监听他们的对话。

一些间谍软件家族针对社交媒体账户和存储在设备上的相关应用数据。如果一个应用管理的数据没有在应用层进行加密（意味着文件系统可能被加密，但任何具有适当权限的应用都能读取数据），间谍软件应用可能能够窃取这些数据。

间谍软件也滥用了无障碍 API，该 API 支持包括启动应用程序、执行自动点击和读取用户文本等强大功能。一些恶意软件家族利用这些权限读取 WhatsApp 消息并在未经用户同意的情况下执行系统配置更改。

#### ***跟踪软件***

Android 安全团队对间谍软件的定义集中在数据收集上，其中受害者的身份无关紧要；收集的数据会被批量转售或以其他方式变现，而不考虑受影响的个人。用于监视特定已知个人的恶意软件被称为*跟踪软件*，有时也叫做商业间谍软件或配偶软件。

宣传为跟踪某人的工具的移动应用程序，当然可以在所有相关方完全同意的情况下使用。然而，某些应用缺乏适当的控制，已被滥用，成为虐待关系中的常见工具，并且可以在数百万部手机中找到。如果有人想追踪伴侣的位置，或查看他们发送和接收的短信，快速搜索“间谍软件追踪你的女友/男友/丈夫/妻子”便会发现一个蓬勃发展的行业，在这个行业中，您可以支付约 50 美元购买这种监控软件。

跟踪软件应用程序，无论是免费的还是付费的，都未能显著通知设备的拥有者其存在。例如，某些应用可能将自己宣传为父母控制工具，允许家庭成员检查其他人的情况，并在某些情况下管理他们的移动设备（例如，查看已安装的应用程序和访问过的网址）。但是，如果设计不当，这些应用程序可能会允许用户偷偷地监视他人。

跟踪者通常在受害者设备无人看管时安装跟踪软件应用。在设置过程中，跟踪者会使用自己的电子邮件地址或电话号码来配置该应用。许多商业化的跟踪软件产品甚至提供基于网页的界面。跟踪者可以通过这个网页界面轻松地完全控制设备。

尽管某些应用程序提供的功能可能有合法的用途（例如，了解孩子的位置），但安卓安全团队认为，任何可以在未经他人知情或允许的情况下隐秘地追踪他人的应用都属于恶意软件。

#### ***钓鱼***

*钓鱼* 应用试图通过要求用户提供凭证或在数据传输时捕获数据来窃取用户凭证或支付信息。它们通常针对信用卡号、银行账户号、加密货币钱包凭证、用户名、密码、个人识别码（PIN）和其他身份验证因素，例如一次性密码（OTP）。一旦应用捕获到数据，它会通过网络将数据发送到第三方控制的系统。在某些情况下，如果被捕获的凭证能够访问私人系统或网络，影响可能超出个人层面，导致大规模的黑客攻击、间谍活动或机密信息盗窃，如知识产权。

应用程序使用各种钓鱼技巧。例如，某些钓鱼应用通过使用相似的包名、标志和应用布局来伪装成流行的电子邮件、社交网络或金融服务应用。一旦启动，应用可能会立即要求用户输入凭证，然后告诉他们登录过程中发生了错误，并将他们重定向到正确的站点。此时，损害已经发生；应用会将凭证发送到一个集中收集被盗数据的服务器，这些数据可能会被出售到暗网或其他地下论坛。此技巧也被用于针对加密钱包应用的恶意软件攻击，钓取用户的钱包凭证。这些凭证可以使攻击者将资金转移到他们自己的账户。

消息和通信应用也可能成为钓鱼攻击的工具。如果消息中嵌入的链接指向钓鱼网站或应用下载站点，用户可能会面临风险。利用社交工程，攻击者可能会说服用户点击链接，这样他们就可能下载恶意应用或将敏感信息泄露给欺诈网站。

拦截传输中的凭证（而不是直接从用户接收凭证）的应用程序也属于钓鱼恶意软件类别。例如，过去的恶意软件曾滥用一个服务，该服务允许移动运营商通过在设备和运营商之间插入代理来向手机发送流量路由配置。安装在设备上的应用程序首先通过 Android 权限`READ_PHONE_STATE`提取设备的*国际移动用户身份(IMSI)*，并将其发送到指挥控制服务器。然后，服务器向该设备发送一条短信，包含开放移动联盟客户端配置（OMA CP）设置，要求用户安装一个具有数据包路由更改的新配置。结果，设备上的应用程序生成的流量——包括电子邮件和网页流量，可能包含身份验证凭证、支付数据或其他用户信息——将发送到第三方控制的代理服务器。

#### ***恶意下载器***

如果一个应用程序被频繁下载，通常会出现将其货币化的机会。这个激励导致了大量应用程序的诞生，这些应用程序的主要任务就是安装其他应用程序。良性应用程序的开发人员有时会支付这些安装器应用程序来改善他们的指标。不幸的是，一些恶意软件开发人员也使用这些相同的服务。一个除了下载恶意软件应用程序外没有做任何有害事情的应用程序被视为*恶意下载器*。这种类型的应用程序多年来一直是许多恶意软件攻击的起点。

一些恶意下载器每次都会安装相同的一组应用程序。在其他情况下，它们安装的应用程序类型和数量会有所变化。在所有情况下，判断一个应用程序是否应被视为恶意下载器需要关于已安装应用程序类型和安装次数的数据。例如，一些应用程序只安装很少的有害应用程序，而另一些则主要分发恶意软件。Android 安全团队使用不同的标准来定义良性下载器和恶意下载器之间的界限，当应用程序跨越这一界限时，它将被标记为恶意软件。例如，在撰写本文时，如果该应用程序的下载中至少有 5％包含恶意软件，并且该应用程序已经下载了至少 500 个应用程序（无论是良性应用还是其他），则它将被视为恶意下载器。主要浏览器和文件共享应用程序不被视为恶意下载器，只要下载需要用户交互，且任何恶意软件下载都是由用户直接发起的。

恶意下载器通常利用两种可用权限来安装其他应用程序：`INSTALL_PACKAGES`和`REQUEST_INSTALL_PACKAGES`。其中，`INSTALL_PACKAGES`更为强大，因为它允许应用程序在不涉及用户的情况下安装其他应用程序。由于滥用的风险，只有预装的应用程序才能使用此权限。

更为温和的权限`REQUEST_INSTALL_PACKAGES`是在 Android 8.0（Oreo）中引入的，并且所有 Android 应用程序都可以使用该权限。此权限允许应用程序请求安装其他应用程序，例如，在原始应用程序成功安装后。当在应用的清单文件中声明`REQUEST_INSTALL_PACKAGES`时，用户将被要求确认，才能使用`ACTION_INSTALL_PACKAGE`意图来安装 APK 文件。这个权限使得恶意下载器开发者更难强制安装应用程序，因为它需要用户干预。在 Android 8.0（Oreo）之前，所有应用程序都有启动用户同意的应用程序安装流程的选项。这个新权限的引入明确了哪些应用程序可以作为其他应用程序的安装程序。

恶意软件开发者已经找到方法，将带有恶意下载功能的应用程序包含在手机运营商和设备制造商放入其产品中的系统镜像中。因此，一些设备上会预装许多恶意下载器。除了具有特殊权限和访问系统资源的权限外，这些预装应用程序还不能轻易卸载。这个特权地位使得恶意下载器能够在没有用户干预的情况下获取并安装 APK 文件。另一个挑战是，这些恶意下载器安装的应用程序可能对制造商或负责构建系统镜像的公司来说并不为人知。因此，用户可能会在全新设备上发现许多不需要的甚至有害的应用程序。

没有安装其他应用程序权限的恶意下载器可能会找到替代的方法来实现这一点。例如，它们可能会尝试获取设备的 root 权限，以便访问文件系统并复制 APK 文件。接着，它们可能会尝试在某些 Android 版本中滥用`PackageManager`来实际安装应用程序。最近的 Android 版本阻止了通过绝对路径直接复制文件，这正是一些恶意下载器曾经使用的方法，并且要求应用程序使用`FileProvider`，这是一种更安全的文件处理方式。在某些情况下，如果应用程序无法快速获取并安装，恶意下载器可能首先使用`INTERNET`权限下载*.apk*文件，然后使用`WRITE_EXTERNAL_STORAGE`将其写入 SD 卡（例如，写入*Downloads*文件夹）。稍后，在第二步中，下载器将尝试获取`INSTALL_PACKAGES`权限并安装它之前下载的文件。

一些恶意下载器开发者可能了解 Android 安全团队的检测阈值，并试图保持在这些水平以下。在某些情况下，为了保持较高的应用下载量，他们可能会在同一设备上安装多个恶意下载器。当发生这种情况时，可以调整检测方法来应对这种行为的变化。

#### ***特权提升***

*权限提升* 恶意软件类别涵盖了通过滥用系统或利用漏洞来提升权限的应用程序。该类别包括所有权限提升的情况，除了 root 操作，由于它对系统完整性的影响，已经有了独立的类别（如前所述）。

这一类恶意软件的四种行为特征，并不是所有的行为在其他上下文中都被认为是权限提升。它包括：

1.  能够访问（读取、写入或执行）它们原本没有权限访问的资源，从而突破 Android 应用沙箱的应用程序

1.  成功找到绕过权限的方法的应用程序

1.  禁用设备上的安全和保护功能的应用程序

1.  阻止用户管理其设备的应用程序

禁用安全功能或以修改系统配置的方式使设备处于脆弱状态的应用程序会被标记为权限提升应用程序。一个例子是预装的应用程序滥用系统权限（例如，`WRITE_SECURE_SETTINGS` 权限或 `Settings.Global` 和 `Settings.Secure` 方法）在自我更新或下载并安装其他恶意软件之前关闭 Google Play Protect 的恶意软件扫描。过去，其他权限提升的应用程序也通过执行 shell 命令而不是使用 Android API 来实现禁用安全设置的同样目标，第三类恶意软件则通过修改 `package_verifier_enable` 设置来操控安全设置，该设置修改了设备上的恶意软件扫描行为。

恶意软件攻击的另一个特性是 SELinux，它通过定义策略来补充文件系统权限模型，防止访问敏感资源，无论文件是否拥有相关权限。当启用 SELinux 时，一些漏洞可能会失败，因为获得的权限可能不足以访问它们想要的资源。例如，一些破解许可证的应用程序通过修改游戏应用程序的代码来绕过许可证检查和购买验证，这需要对文件系统的写入权限，以便创建修补过的应用版本。当启用相应的 SELinux 策略时，这类修改会被阻止，恶意软件必须在其首要步骤中尝试禁用 SELinux。它可能会通过运行 `setenforce 0` 命令将 SELinux 从所谓的 *强制执行* 模式切换到 *宽松* 模式。值得注意的是，在运行至少 Android 5.0（Lollipop）版本的现代设备上，宽松模式仅在 *userdebug* 和 *eng* 构建中支持，这些是通常用于开发和测试的特殊 Android 设备配置。普通终端用户设备不应当能够关闭 SELinux。

一些应用为了提升权限，会修改`install_non_market_apps`设置。安卓设备允许用户从任何来源安装应用。然而，这个设置可以阻止应用从 Google Play 以外的来源安装额外的应用，因为这些来源有更高的分发恶意软件的风险。当应用未经用户同意自动修改此设置时，应用将被标记为恶意软件，因为它可能会让设备处于易受攻击的状态。

恶意软件作者还滥用了设备管理器 API（如`DevicePolicyManager`或`DeviceAdminReceiver`类中实现的 API），这些 API 通过一系列策略启用设备管理操作，特别是在企业部署中，包括重置和过期密码、通过恢复出厂设置擦除用户数据分区，以及要求加密存储数据。恶意软件开发者利用设备管理器 API 阻止其应用被删除。例如，某些在野外发现的恶意软件家族会调用`resetPassword`和`lockNow`来锁定设备，当用户操作触发`onDisableRequested`回调时，后者会尝试从潜在有害应用中移除设备管理员权限。在其他情况下，应用可能会监视用户对系统设置的访问，并触发相同的行为：将设备锁定，阻止所有者访问。

自 Android 9.0（Pie）以来，设备管理器 API 已逐步淘汰（不推荐使用），部分原因是响应恶意软件的滥用，因为许多过去的权限提升应用曾使用这些 API 作为无用户同意的设备控制手段。在此之前，这些 API 经历了一些变化，减少了其被滥用的潜力。例如，从 Android 7.0（Nougat）开始，`resetPassword`方法只能用于设置新的设备密码，而不能更改已存在的密码。这可以防止拥有现有设备密码的用户被锁定在设备外。

另一个值得提到的设置是`upload_apk_enable`。该设置控制设备是否与 Google Play Protect 共享 APK 样本，以帮助识别恶意软件。恶意软件作者可能会尝试禁用该设置，以减缓其应用的检测速度。

还值得一提的是，一些应用依赖于其他应用在执行之前削弱设备的安全性。例如，一些恶意软件家族包含一个 root 组件，其任务是削弱执行环境和文件系统的安全性，为其他应用实际访问由 root 组件提供的数据做好准备。这些二级应用程序利用系统的脆弱状态来访问，例如*accounts.db*文件，其中包含令牌，允许设备访问多个服务。这些应用可能读取并发送 Google OAuth 主令牌和 Google Play 的 ClientLogin 令牌。在其他情况下，文件属性被修改，使得修改或删除更加困难，例如通过将文件声明为只读、将其移动到特权分区，或通过使用`chattr`命令为文件设置`+ia`属性，使得文件更加难以删除。具有这些属性的文件只能以附加模式打开进行写入；它不能被删除或重命名。

#### ***勒索软件***

如果一个应用控制了用户的数据或设备并要求释放这种控制，它就被认为是*勒索软件*。这些要求可能包括支付赎金，或要求用户执行违背其意愿的操作。在 Android 生态系统中观察到的两种主要勒索软件方法是：通过用攻击者控制的密钥加密设备上的数据来阻止用户访问数据，或者通过实际的屏幕锁定机制或使 GUI 无法用于除勒索软件应用之外的任何操作来锁定用户的设备。

加密用户数据的勒索软件应用首先需要获得写入文件系统的权限（例如，通过`WRITE_EXTERNAL_STORAGE`权限）。然后它们可以探索文件系统，通过`getExternalStorageState`检查特定文件和目录的状态。在某些情况下，应用会读取外部存储中的所有文件，并使用`java.io.File.*`方法和加密密钥将其重新写回加密的形式。在其他情况下，只有图像和消息会被加密，而其他文件格式则不会。在所有情况下，应用会向用户显示通知，说明如何进行支付，通常要求使用加密货币来隐藏攻击者的身份。该消息还描述了用户如何接收解密密钥并恢复其文件。

这些应用程序通常使用标准的加密算法，例如用于数据加密的 AES 和用于密钥保护的 RSA。采用这种方法时，用于加密文件的 AES 对称密钥会被用攻击者的 RSA 公钥加密，并发送到指挥与控制服务器，这样攻击者可以在收到付款后解密密钥并发送给用户。

其他应用则不会加密任何数据，而是通过显示一个勒索软件提示，覆盖整个屏幕，用户无法移除。即使重启后，提示仍然存在。这种攻击类型阻止用户访问设备的界面，包括执行拨打电话或读取消息等操作。一些应用使用`SYSTEM_ALERT_WINDOW`权限来显示这样的覆盖窗口。首先，它们通过调用`getRunningServices`、使用命令行检查`/proc`中的进程 ID，或者通过`getRunningTasks`识别顶层活动来识别设备上运行的进程。接着，它们调用`startActivity`来覆盖正在执行的其他应用。

勒索软件应用还可以使用某些 Android 版本中可用的`BIND_DEVICE_ADMIN`权限，然后使用`DevicePolicyManager`方法，如`resetPassword`和`lockNow`，来更改设备的密码。

#### ***短信欺诈***

一些应用会对用户造成直接的财务损失。例如，使用短信进行欺诈的恶意软件就是一种情况。*短信欺诈*类别包括向特殊号码发送短信或彩信的应用，这些号码被称为*短号*。这些短号通常是三到八位的数字代码，如 1234，当用户发送短信到这些号码时，会收取额外费用。这样的收费短信最初是为了合法目的而创建的，例如让用户向灾区捐款、在电视节目中为表演者投票，或订阅通过短信提供的信息服务（例如每日新闻、笑话、天气预报或星座运势）。尽管运营商支持这些服务，但实际的服务可能由第三方提供。

短信欺诈应用以故意欺骗的方式发送短信。它们通过调用如`sendTextMessage`、`sendMultimediaMessage`或`sendMultipartTextMessage`等 API，滥用`SEND_SMS`权限，在没有用户参与的情况下发送短信，并主动抑制任何通知以防被检测到。在某些情况下，只有当用户查看手机账单时，才会发现账户上出现了欺诈性收费。

即使目的地是普通号码，但如果没有向用户披露发送短信的行为，应用仍可能因违反 Google Play 的政策而被暂停，这些政策旨在保护用户不被未经同意的短信使用所困扰。然而，当号码是用于收费服务的短号时，应用将被标记为恶意软件，因为这些短信直接向用户收取费用。Android 会在发送收费短信时提醒用户。然而，这个警告并不等于披露；发送短信的应用必须在应用内以清晰且显眼的方式披露这种行为。

短信欺诈应用有时会预装一份付费号码的列表。然后，它们会检查设备所在的国家和移动运营商，从列表中选择一个特定的号码。在其他情况下，目标号码是动态加载的，来自指挥控制服务器，这样可以给欺诈者更大的灵活性，允许他们添加新的号码。

这些应用程序还可能通过隐藏披露协议或来自移动运营商的收费或新订阅通知消息，来伪装付费短信订阅。

#### ***话费欺诈***

*话费欺诈*应用程序是指通过向用户的电话账单收费，诱使用户订阅服务或购买内容的应用程序。它不包括通过付费短信产生的费用，后者有自己的分类（在前一部分中讨论过）。

许多支付和计费技术允许用户通过简单地将支付费用计入手机账单来购买产品和订阅服务，这在信用卡或借记卡使用不普及的国家是一种有用的解决方案。这些技术包括直接运营商计费（DCB）、无线应用协议（WAP）和移动话费转移（MAT），它们会跟踪用户的数据和话费余额、活动和购买情况。因为它们管理费用，而且购买可以相对默默进行（在某些情况下，只需点击一次或简单确认要收费的电话号码），这些系统成为了欺诈者的诱人目标。

话费欺诈应用最先做的事情之一就是禁用 Wi-Fi 连接。当设备使用 Wi-Fi 网络时，它就不会使用由运营商管理的移动数据连接，如 LTE、3G 或 4G。设备生成的任何流量将通过用户的 Wi-Fi 接入点和互联网服务提供商（ISP）进行，而不是通过移动网络。应用程序可以通过例如使用`setWifiEnabled` API 禁用 Wi-Fi，并使用`setMobileDataEnabled` API 启用移动数据。一旦完成，应用程序可能会使用启用了 JavaScript 的 WebView 打开一个服务订阅网页，然后注入 JavaScript 自动点击按钮完成订阅。服务可能会向移动设备发送短信确认订阅，但话费欺诈应用会拦截并删除这些短信，防止用户察觉到欺诈行为。

通常被话费欺诈应用滥用的权限包括`CHANGE_WIFI` `_STATE`，用于切换到移动数据；`RECEIVE_SMS`或`READ_SMS`，用于读取确认码或订阅提醒；以及`READ_PHONE_STATE`，用于获取用户的电话号码或其他设备标识符，以便将用户订阅到服务。最近，话费欺诈应用开始滥用`BIND` `_NOTIFICATION_LISTENER_SERVICE`权限，以在 Google Play 政策更改后访问接收到的短信，防止应用滥用短信。

实现欺诈功能的恶意代码通常会被混淆（例如，Base64 编码）或在安装后动态获取，以避免被检测到。

#### ***电话欺诈***

*电话欺诈*恶意软件类别包括通过拨打高费电话号、未经用户同意或知情，向用户电话账单中产生费用的应用程序。与短信欺诈类似，这种滥用行为依赖于许多电话运营商提供的便捷功能：通过将购买的产品或订阅的服务添加到用户的电话账单上，来通过电话支付未来费用。在某些情况下，账单账户可能会与信用卡或银行账户的自动支付挂钩。当这种情况发生时，用户可能未意识到他们正在为拨打收费电话支付费用。

为了隐藏调用，欺诈应用可能依赖`CALL_PHONE`权限在不使用设备拨号界面的情况下发起电话呼叫，以避免引起用户的视觉警觉。然而，用户仍然可能听到电话铃声。为了静音，一些恶意软件使用`AudioManager`类中的`setStreamVolume`方法来控制音频流的音量，将其设置为最低音量。

其他电话欺诈恶意软件的迹象包括使用如`PROCESS_OUTGOING_CALLS`等权限，这使应用程序能够获取拨打的电话号码、重定向电话或终止电话，以便应用程序能够在成功建立连接并产生通话费用几秒钟后关闭电话。它们还可能使用*电话意图*，即向操作系统发出请求以拨打电话，实际进行基于预定收费电话号码或从指挥与控制服务器动态接收到的电话号码的电话。

#### ***垃圾邮件***

*垃圾邮件*应用程序向用户发送未经请求的消息，或将设备用作电子邮件垃圾邮件中继，通常用于推广产品或服务。

垃圾邮件的目标列表可能来自用户的电话通讯录或社交网络应用（如 Facebook 和 WhatsApp）的联系人列表。它们也可以通过指挥与控制服务器动态提供或从网络服务器获取。一旦应用程序收集到目标列表，就会开始静默地向这些目标发送信息。在某些情况下，这可能是通过文本消息进行的。在其他情况下，应用程序可能会尝试通过 API（例如 Facebook API）发送消息，尽管这需要用户登录。如今，垃圾邮件恶意软件已经很少见，我们在这里列出它是为了完整性。

#### ***广告欺诈***

许多安卓应用程序能够从广告网络获取广告并将其展示给用户。当一个应用展示广告时，发布者和网络会因该广告而获得积分，这一指标被称为*曝光*。当用户实际点击广告时，广告商通常会因用户的点击行为而对发布者进行补偿。

只要有资金流动，就有滥用的可能。*广告欺诈*类别包括那些恶意操控移动广告平台以谋取经济利益的应用程序。广告欺诈有两个主要类别：点击欺诈和归因欺诈。

在*点击欺诈*中，应用从广告网络获取广告，并生成自动点击，无需用户干预或通知。例如，这些点击可能是通过 Java API 模拟的应用内点击，或者是通过加载到 WebView 中的 JavaScript 代码触发的点击。在某些情况下，应用通过使用最小尺寸（如 1×1 像素）隐藏广告，使用户难以察觉。其他情况下，用户可以看到广告，但并没有意识到应用在后台产生点击事件。

来自点击欺诈应用的流量最终会人为地增加与广告相关联的点击数量。网络追踪这个数量并将其传达给广告主，广告主随后会为这些点击付费，尽管这些点击并非由实际的用户兴趣驱动。这类恶意软件欺诈了广告主，可能会影响他们的广告预算和转化率，侵蚀他们对生态系统的信任。用户也可能会受到点击欺诈的影响，当大量虚假广告流量浪费了他们移动套餐的数据预算和电池电量，并向他们展示了不相关的广告时。

第二类广告欺诈是*归因欺诈*，它发生在应用尝试改变用于归因广告展示或应用安装的原始数据，以将这些展示或安装归因于某个推荐人或发布者时。例如，如果广告由应用展示，并且广告与推荐人标识符相关联，广告网络将追踪该标识符，以确保适当的推荐人得到报酬。然而，一个进行归因欺诈的应用可能会监听包含推荐人标识符的广播意图，然后向广告网络发送伪造的流量，改变标识符。结果，其他人将因这些展示获得报酬。在某些情况下，实施归因欺诈的代码可能是*软件开发工具包（SDK）*的一部分，SDK 是应用开发者可能会在他们的应用中包含的工具集，而他们并不知道其中包含了会尝试转移广告或应用安装积分的代码。

其他方案也可能符合广告欺诈的定义。例如，对于按展示付费的广告网络，*展示欺诈*，即操控广告展示数量和频率，可能被用来提高广告收入。我们还看到了一些更复杂的方案，比如广告网络监视其竞争对手的展示和点击信息，或者广告网络收集所有必要的信息来实施欺诈，发送到他们的服务器，然后在模拟的 Android 设备上服务器端执行实际的欺诈。然而，这些内容并未在本书中涉及，因为广告欺诈领域非常庞大，并且出于某种原因，历史上重要的 Android 广告欺诈恶意软件家族都使用了点击欺诈或归因欺诈。

#### ***非 Android 威胁***

Android 安全团队定义了最后一种恶意软件类别：*非 Android 威胁*。这些应用包含某种恶意行为，但无法直接危害 Android 用户。在大多数情况下，这一类别用于标记包含 Windows 恶意软件的 Android 应用，几乎总是因为应用开发者的计算机在构建时感染了 Windows 恶意软件。使用这一类别主要有助于应用开发者，因为它让他们意识到应用存在问题。实际上，Android 用户不会受到该应用恶意组件的影响。

### **接下来**

在介绍了 Android 安全模型和 Android 安全所追踪的恶意软件类别后，接下来的章节将回顾 10 年的 Android 恶意软件。我们将提供实际恶意软件家族的例子，并解释为什么某个恶意软件类别的流行度会随时间变化。

[*OceanofPDF.com*](https://oceanofpdf.com)
