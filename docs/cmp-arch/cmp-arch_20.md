## 第二十章：**附录**

## **操作系统支持**

![Image](img/f0425-01.jpg)

本书避免讨论操作系统，以便更清楚地看到“裸机”架构。操作系统是一个独立的研究领域，有专门的书籍。通常是先学习架构，再学习操作系统。然而，操作系统的需求促使架构层面加入了若干特性，而这些*确实*属于架构书的范畴。

这个附录是为你在学习操作系统时回顾的，它涵盖了两个领域交集的部分内容。我们将回顾操作系统的一些基本特性，然后看看现代架构是如何在硬件层面上支持这些特性的。

### 并发

操作系统最基本的功能是创建多个用户程序在单个 CPU 上同时运行的假象。执行这一功能的操作系统程序通常被称为*内核*。由内核运行的用户程序被称为*进程*。

内核轮流运行每个进程一小段时间，然后切换到下一个进程；这种方式叫做*周期*，这种执行方式被称为*并发*。这意味着进程看起来像是并行运行的，但实际上是通过时间切片方式按顺序执行的。并发大致上是与并行计算相对的概念。并行计算通常需要多个 CPU，使用它们同时执行一个程序。而并发则使用单个 CPU，在同一时间内执行多个进程。

内核通常使用架构定时器、IRQ 线和 IRQ 回调来控制进程之间以及内核代码本身的切换。在启动时，内核设置一个硬件定时器，定期向 CPU 发出 IRQ。内核还设有一个子程序，我们称之为*回调*，它在 IRQ 到达时被调用。内核被分配了一组需要运行的进程。它将所有进程加载到内存中，分别放置在不同的位置。然后，它跳转到第一个进程的主子程序，交出控制权让它正常运行。

第一个进程会运行一段时间，然后之前设置的定时器将触发一个 IRQ。IRQ 硬件会检测到这个信号，并将程序计数器的副本存储在某个地方（例如在专用的内部寄存器中），然后将程序计数器设置为回调的地址。

回调函数通常会先在一个为内核保留的 RAM 区域内保存每个寄存器的副本以及先前保存的程序计数器（即不被任何进程使用的区域）。然后，它决定（调度）下一个要运行的进程。最简单的方法是让进程按固定顺序轮流执行。新的进程的保存寄存器和程序计数器状态将被加载到寄存器和程序计数器中。更新后的程序计数器将控制权转交给新进程，直到定时器触发下一个 IRQ 并再次调用回调函数。

### 内核模式和用户模式

内核可以正常工作，只要进程能够相互信任——即，只要它们只访问各自独立的内存区域。如果进程存在恶意行为，系统将无法正常工作。显而易见的安全问题是，任何进程都可能读写本应由其他进程或内核使用的内存，这可能包括窃取数据、覆盖数据或覆盖代码，包括覆盖内核代码以完全控制机器。

现代 CPU 通过提供两种（或更多）*CPU 模式*，即*内核模式*和*用户模式*，从架构层面防止了这一点。在内核模式下，CPU 的所有特性都可以供内核使用，这包括对 RAM 的完全访问。在用户模式下，会强制执行限制，防止访问分配给用户进程的内存区域之外的指令和内存位置。

### 虚拟内存

现代操作系统不允许用户进程访问彼此的数据或内核的数据。操作系统为每个用户进程提供一个*虚拟内存*空间，这对进程来说看起来就像是裸机上的内存，与其他进程隔离。例如，所有进程可能都认为它们在使用地址 0x00000000 到 0xffffffff 之间的内存位置。物理内存地址对用户程序来说是不可见的，进程之间是相互隔离的，无法读写彼此的内存。用户程序中的加载和存储指令完全使用虚拟内存地址。

通过利用*交换空间*，虚拟内存的大小也可以比物理 RAM 大得多，这包括使用次级和主存储器。在这里，主存和次存被划分为标准大小的块，称为*页面*。缓存被用来根据最近的使用情况在主存和次存之间移动整个页面。

与我们之前看到的硬件 CPU 和 RAM 缓存不同，这通常是一个较慢的过程，至少部分由操作系统软件管理。硬件*内存管理单元（MMU）*可能会被添加到架构层面，以执行操作系统配置的物理地址和虚拟地址之间的转换。

不同的 CPU 和操作系统组合将以不同的方式使用虚拟内存。例如，一个关键的架构设计决策是是否在不同的 CPU-RAM 缓存中使用物理地址还是虚拟地址。

*翻译查找缓冲区（TLB）* 缓存是一个专门的缓存，它在架构级别上为操作系统提供虚拟内存实现所用的缓存。它可以作为第三个专业的 L1 缓存，与图 10-12 中看到的指令和数据 L1 缓存一起存在。当用户程序提到一个虚拟地址时，TLB 缓存会查找并将其转换为物理地址，用户无法看到。如果虚拟地址在 TLB 缓存中不存在，TLB 会通过中断请求（IRQ）调用操作系统代码，询问该如何处理。操作系统要么找到所需的虚拟-物理映射并将其添加到 TLB 缓存中，要么如果该映射不存在或不允许，就会给出*访问冲突*错误——通常称为*段错误*——如果它不可用或不被允许。如果你曾经在 C 代码中遇到段错误，它就是在这里出现的，当你试图访问未分配给你的内存时。

### 设备驱动程序

现代操作系统也不允许用户进程直接访问 I/O 地址。相反，它们必须调用被称为*设备驱动程序*的操作系统子程序，通过操作系统的 API 礼貌地请求 I/O 功能。与其他进程的内存一样，用户模式会阻止进程加载或存储到其指定地址空间之外的内存，如果尝试这样做，它会引发异常——例如段错误。

I/O 模块和设备驱动程序是不同的概念。I/O 模块是连接到总线的硬件。设备驱动程序是一个更高层次的概念，是一段软件，负责与 I/O 模块或通过它连接的设备（之一）进行所有通信；它还提供更高层次的接口（如 C 或 C++ 库），将内存映射指令进行封装。在 8 位时代，这些程序通常位于 ROM 中或加载到 RAM 中，供用户程序访问。今天，它们通常作为内核模块实现，只能由操作系统访问，用户程序通过操作系统请求它们的使用。

**架构操作系统安全**

学习架构级别为操作系统安全打开了许多有趣的机会。操作系统通常尝试限制用户程序访问计算机的大部分部分，但如果你能够访问架构级别，你可能能够绕过这一限制。例如，如果你能物理控制操作系统定时器回调使用的 IRQ 线路，通过打开计算机、将电线连接到 IRQ 引脚，并在你选择的时间施加电压，你能做什么呢？

一个持续的安全问题是设备驱动程序是否应该在内核模式或用户模式下运行。通常，它们被作为操作系统的一部分并获得对机器的完全访问权限，但这可能是危险的，因为它使得驱动程序的编写者能够访问你整个机器。这在以前只涉及少数几个声誉良好的打印机制造商，要求从打印机盒子中的 CD 上安装他们的驱动程序时是可以接受的，但现在问题更加严重，因为有越来越多的国际和不受信任的硬件制造商在运营，更不用提那些声称托管其产品驱动程序的无品牌网站了。

### 加载器

在没有操作系统的 8 位机器上，运行可执行文件只需将其内容复制到内存中的某个位置，然后将 CPU 的程序计数器设置为指向文件的第一行。这是由一个简单的程序，称为*加载器*，存储在 ROM 中完成的。在现代机器上有操作系统的情况下，加载器则更复杂：可执行文件将与其他进程一起运行，在虚拟内存区域中而非真实内存中运行。因此，加载器需要做一些工作来设置这一切，并修改可执行文件，使其使用虚拟地址而非程序所认为使用的物理地址。在 Linux 上，加载器通过类似`./myexecutable`的命令来调用，其中`./`在技术上出于安全原因是必须的，但实际上它充当了加载器命令的角色。

让我们尝试从操作系统内部编写、加载和运行一个“Hello, world!”程序。（我们之前在 BIOS 上做过这件事。）特别是，以下程序能够在像 X Window 系统这样的窗口系统中运行，并安排在终端中显示文本，而不是直接点亮 ASCII 模式的屏幕像素。它通过调用内核函数——而不是 BIOS 函数——来请求文本显示。操作系统的加载器假设有一个名为`_start`的外部可见（`global`）标签，加载器加载代码后会跳转到该标签：

```
          global    _start

_start:   mov       rax, 1                  ; system call for write
          mov       rdi, 1                  ; file handle 1 is stdout
          mov       rsi, message            ; address of string to output
          mov       rdx, 13                 ; number of bytes
          syscall                           ; invoke OS to do the write
          mov       rax, 60                 ; system call for exit
          xor       rdi, rdi                ; exit code 0
          syscall                           ; invoke OS to exit

message: db         "Hello, Kernel!", 10    ; note the newline at the end
```

这段代码仅在 64 位 Linux 上运行。要进行汇编和运行，请使用以下命令：

```
> nasm -felf64 hellok.asm && ld -o hellok hellok.o && ./hellok
```

这段代码应该仅通过系统调用将`Hello, Kernel!`写入控制台。

### 链接器

当操作系统托管的可执行文件调用其他库中的子程序时，虚拟内存地址需要进一步重新定位。这是为了确保每个库的可执行机器代码被加载到内存中的合适位置，即不与其他库发生冲突的位置。调整这些地址还确保库之间可以互相找到。如果一个程序或库调用另一个程序中的函数，则需要将目标子程序的地址更改为目标实际加载的位置。进行这些调整的过程叫做*链接*，通常由一个*链接器*程序完成，加载器通常会隐式地调用它。

作为链接的一个例子，这里有另一种向终端写入的方式，这次是通过调用标准 C 库的`printf`子程序：

```
global main
extern printf

msg: db "Hello libC!", 0   ; 0 = ASCII endofstring
fmtstr: db "%s", 10, 0     ; ASCII newline and endofstring
fmtint: db '%10d', 10, 0   ; ASCII newline and endofstring

main:
    mov rdi,fmtstr
    mov rsi,msg     ; pointer to msg
    mov rax,0       ; num of extra stack args used (none)
    call printf     ; call C function

    mov rdi,fmtint
    mov rsi,124     ; 124 is an int to print out
    mov rax,0       ; num of extra stack args used (none)
    call printf     ; call C function
    ret
```

采用这种方式，你可以从汇编程序中调用任何 C 库，只要你遵守它们的调用约定。因为它是 C 编译器栈的一部分，`gcc`编译器会寻找一个名为`main`的外部可见（`global`）子程序，和 C 语言中的做法一样。它会创建自己的低级`_start`子程序，并设置为调用`main`；它还会设置 C 库所需的任何结构。

请注意，由于`printf`可以接受可变数量的参数，我们必须告诉它在栈上使用了多少个额外的参数，并预期会出现多少个参数；我们在 RAX 中设置这个数字。这在大多数 x86 调用约定中是处理可变参数的标准做法。

要在 64 位 Linux 上汇编、链接并运行，请使用以下命令：

```
> nasm -felf64 helloc.asm ; gcc -no-pie -o helloc helloc.o ; ./helloc
```

你可以通过*反汇编*来查看链接器添加了哪些额外的代码——也就是将机器代码转换回人类可读的汇编代码。你可以使用像`objdump`这样的工具来做到这一点：

```
> objdump -d helloc
```

一些操作系统利用 x86 段——或者至少是它们的汇编指令——来强制代码中的`.text`部分为只读。它们通常允许在`.data`部分进行写操作。

### 额外的启动序列阶段

大多数系统在开机时无法直接启动操作系统。操作系统负责加载和配置设备驱动程序，而这些驱动程序在操作系统还没有加载时并不可用。相反，它们是在启动过程的后续阶段逐步加载的。

我们在第十三章中已经介绍过 BIOS 和 UEFI。通常，只有两个程序会在 BIOS 中运行：操作系统加载程序和操作系统加载程序选择器程序，比如 GRUB2（GRUB 版本 2）。PCBIOS 会从一个特定的硬盘位置，即主引导记录，运行第一个这样的程序。UEFI 现在对文件系统有比这更高层次的视图，它包括一个硬盘上的特定路径，用于寻找并运行这些程序中的第一个。GRUB2 提供了一个基于文本的用户界面，显示硬盘上可用的操作系统列表，并允许用户使用光标和其他按键输入他们的选择。GRUB2 会检查可用的 BIOS 类型，然后调用该 BIOS 中的可用子程序来在屏幕上显示字符并读取键盘。当用户做出选择时，它会加载相应的操作系统加载程序，并将控制权交给它。

操作系统加载器因此成为操作系统的第一个程序。它最初将依赖 BIOS 库来访问计算机，特别是硬盘，这个硬盘包含了其余操作系统的代码。操作系统可能有自己的驱动程序，最好比 BIOS 的驱动程序更好，并且它将逐步加载并切换到这些驱动程序。例如，BIOS 图形本身分辨率较低，以便在任何显示器上都能正常工作，但一旦操作系统加载，它可以考虑显示器的具体品牌和型号，并加载一个新的定制驱动程序，以便利用显示器的所有功能。

现代的启动过程因安全原因而备受争议。启动过程发生在操作系统启动之前，这意味着它可以访问整个计算机。UEFI 在操作系统启动后继续在后台运行，允许操作系统调用它的子程序。但这也意味着，任何嵌入 UEFI 固件的恶意代码都可能在正常操作系统运行期间保持对整个机器的访问权限。

UEFI 是由一个委员会设计的，委员会成员包括成功游说将“安全启动”作为标准一部分的专有操作系统供应商。这使得启动过程可以被锁定，以至于预装机器的买家无法安装 GRUB2 和其他操作系统。如果你能够重置安全启动系统本身，就有可能修复这个标准中的漏洞。通常这是通过将两根电线焊接到 UEFI 芯片上，并施加电压进行出厂重置。

自 2008 年左右以来，关于英特尔主板包含一个基于 MINIX3 的完整操作系统的传言开始流传，这个操作系统在 UEFI 和主操作系统之间的启动过程中运行，被称为“英特尔管理引擎”。如果这些传言属实，那么它们暗示了一个重大的安全漏洞，因为这个操作系统将拥有对整台机器的完全访问权限，包括互联网通信和自动更新系统，这将使得英特尔或其他方能够随时通过网络推送代码，并以完全的读写权限在你的计算机上运行。这些传言还暗示，MINIX 现在可能是世界上使用最广泛的操作系统——这有点讽刺，因为 MINIX 最初是作为一款教育操作系统创建的，而 Linux 则被认为是它的“现实世界”进化。

### 虚拟机监控器模式、虚拟化和容器

内核模式有时被称为*监控模式*，其中“监控者”是内核，它控制着正在运行的进程之间的切换。*虚拟监控器模式*是一个相关但更高级的概念，在该模式下，CPU 不是在操作系统内部切换多个进程，而是在多个操作系统之间切换，这些操作系统并行运行。这个概念在当前的云计算中尤为重要，因为计算机中心中的众多机器就是以这种方式共享的，旨在为每个用户提供类似于根用户操作可扩展机器组的体验。

相似的操作系统共享也可以仅通过软件实现：有些程序能够模拟或仿真虚拟机。然而，这样做会带来性能损失，而虚拟监控器则不会。有了虚拟监控器，每个操作系统实际上是直接运行在硬件上的。专用的虚拟监控器架构被用来管理硬件状态的进出交换，类似于软件监控器如何在执行中交换进程。一些虚拟机程序，比如第十三章中使用的 VirtualBox 程序，可以利用虚拟监控器在虚拟化处理器上运行其虚拟机。

*容器化*是虚拟化的替代方案。它并不是创建一套完全隔离的虚拟机，而是与额外的软件一起工作，创建出许多虚拟机的*外观*，同时让它们实际共享一个操作系统和其他组件，例如软件库。（这可以说是操作系统最初的设计目的。但与操作系统不同的是，容器能够让不同用户体验系统、库和已安装软件的不同安装和版本。）这是比虚拟机更轻量的解决方案，它可以让成千上万的容器在一台计算机上为不同的用户一起运行。容器化在云计算中特别有用，因为在云计算中，成千上万的用户希望运行隔离的程序，而服务提供商则希望通过让这些程序共享一台物理机器来最小化成本。

### 实时操作系统

大多数嵌入式系统只运行一个小而简单的程序，因此不需要操作系统。然而，随着某些嵌入式系统需求的复杂化，将它们编程为多个进程变得更加容易和常见。在这个阶段，开始在嵌入式系统上运行一个小型操作系统来管理这些多个进程是有意义的。

嵌入式环境通常对操作系统有特殊要求，最常见的是对所谓的*硬实时*的需求。普通操作系统可能会以一种看似随机的方式在进程之间切换；它们的设备驱动程序通常也会使用缓冲和中断来读取和写入数据，这些操作看起来也像是随机的。这样的行为对于比如说精密工业机器人控制器来说是灾难性的，因为它们需要在微秒和微米级别的精度下工作，这些行为会干扰其在现实世界中的精确运动要求。硬实时操作系统（RTOS）——例如 SMX、QNX、FreeRTOS 或 Zephyr——是专门从头开始设计的操作系统，旨在绝对保证此类任务的时间精度。这要求在调度和 I/O 方面采取不同的方法。通常，嵌入式微控制器的功耗远低于桌面计算机，因此操作系统设计要求还必须包括低计算开销。

为了在安全关键的环境中使用，像微控制器一样运行的 RTOS 通常会经历一个昂贵且严格的安全保障过程，该过程要么依赖于广泛的测试，要么在最严格的情况下，依靠形式化规范和验证，使用数学和逻辑来证明其在各种假设下都能始终可靠运行。

RTOS 与*软*实时操作系统有所区别，后者如为计算机音频制作任务修改过的 Linux 变种。在这些系统中，实时性是理想的，但并非绝对必要——如果不能每次都绝对保证，譬如说，它不会让核电站爆炸——因此偶尔的延迟是可以容忍的。

### 投机执行漏洞

在我们对架构的研究中，我们发现计算机会将程序转换为成千上万条不同的指令，混乱地调整这些指令执行的顺序，尝试同时执行多个指令的部分内容，在指令之间传递不完整的结果，并秘密地更新其微代码以采用新的执行方式。

这些行为及其相互作用在芯片设计和功能上产生了巨大的复杂性。由此产生的芯片设计是人类已知的最复杂系统之一，没有任何个人能够完全理解 CPU 中发生的所有事情。提出一个问题是很自然的——在如此多可能出错的部分下，我们能否确信我们的 CPU 设计是安全且可靠的？

最近发现这个问题的答案是“否”——这就是为什么我们现在有了*推测执行*漏洞，架构错误可能允许一个进程读取属于另一个进程的数据，如密码和银行信息。在大多数情况下，这包括不同用户在物理云机器上运行的虚拟化系统相互间窃听的能力。这被许多制造商认为是灾难性的安全威胁；一些人认为它是有史以来最严重的硬件问题。针对这些漏洞的软件补丁会导致性能降低 5%到 30%，而架构师目前正在努力重新设计硬件，以避免在下一代处理器中出现这些问题。

推测执行漏洞首次在 2018 年被发现，作为名为 Spectre 和 Meltdown 的错误，新的变种在撰写本文时仍在不断被发现。为了基本了解这一类大量的漏洞，我们将在这里讨论 Meltdown 变种。

Meltdown 是由多个现代架构特性之间复杂的意外交互引起的：推测执行、虚拟内存、CPU 内核模式切换、缓存时间效应以及间接寻址中的竞态条件。假设目标进程与我们自己的进程在操作系统下同时运行。操作系统为两个进程定义了独立的内存区域，并限制每个进程只能访问自己的内存空间。内存空间如下所示：

| **地址** | **数据** |
| --- | --- |
| 1 |  |
| 2 |  |
| 3=基础 |  |
| 4=测试 1 | FOO |
| 5=测试 2 | FOO |
| 6=测试 3 | FOO |
| **地址** | **目标数据** |
| --- | --- |
| 7 |  |
| 8=目标 | 密码 |
| 9 |  |
| 10 |  |
| 11 |  |
| 6 |  |

在这里，我们假设我们可以访问目标程序的源代码，这样我们就知道用户密码会存储在它的内存中的位置，因此`TARGET`地址的内容，即`*TARGET`，是`PASSWORD`，我们假设它已知并且是一个从 1 到 3 之间的整数。我们想从我们自己的进程中读取这个密码。我们自己进程的地址空间包含一系列标记为`TEST1`、`TEST2`和`TEST3`的地址。我们可以在这些位置存储任何虚拟数据，标记为`FOO`。我们将读取这些数据作为攻击的一部分，但我们其实并不关心它们的具体值。我们将把这些地址前面的地址称为`BASE`，因为它将作为基地址，我们可以使用偏移量来引用每个`TEST`地址。

为了进行攻击，我们首先执行一个间接偏移寻址指令，并带有一个条件：

```
if (0) LOAD BASE+(*TARGET) else LOAD 1
```

尽管`if (0)`的语义意味着条件永远不会为真——这意味着`LOAD BASE+(*TARGET)`在程序中不会完全执行——但急切执行（如在第八章中）最初会同时运行两个分支。当它这样做时，`BASE+(*TARGET)`将被评估，得到的地址必须是 4、5 或 6 之一。这个地址上的数据内容（其中之一为三个`FOO`项）将被加载到缓存中。（地址 1 的`FOO`也从分支的另一侧加载到缓存。）在此过程中，条件被测试并发现为假。此时，`LOAD BASE+(*TARGET)`指令被中止，但其值已经被加载到缓存中，尽管之后不会再被使用。

请注意，如果条件为真而非假，那么`LOAD BASE+(*TARGET)`将尝试完成，此时且仅此时，会发生安全异常，因为`TARGET`地址会被测试安全性，并发现它位于另一个进程的地址空间中。但因为条件实际上是假的，所以这个测试从未执行。

一旦值被加载到缓存中，我们就进行缓存计时攻击：

```
for (i=1:3) time(LOAD BASE+i)
```

循环中的三个指令都成功执行，将三个`FOO`值从它们的三个内存位置加载到寄存器中。但是如果我们为这三个`LOAD`操作计时，会发现其中一个比其他的更快，因为它在猜测执行期间被缓存了。如果`PASSWORD=i`，那么`LOAD BASE+i`会很快，因为（`BASE+i`）已被缓存。通过测量这些时间并找出最快的一个，可以揭示出`i`的值，它等于`PASSWORD`，这是所需要的。

Meltdown 漏洞在几乎所有主要商业 CPU 中存在了 20 年而未被发现！在此期间，可能有秘密的国家行为者知道并利用了这一漏洞，但据我们所知，尚未被任何其他恶意软件利用。

Meltdown 的公开披露过程是 2017 年一个关于道德安全漏洞披露的典范。在安全研究人员公开发现之后，制造商首先被秘密通知。研究人员、CPU 制造商和操作系统程序员随后合作，在操作系统软件层面为所有主要操作系统修补了该漏洞。这些操作系统通过向用户推送自动更新，在现场完成了更新。

操作系统级别的软件补丁叫做 KAISER。在这里，操作系统随机化进程的内存位置，以防止 Meltdown 攻击知道要搜索哪些地址来寻找目标数据。这仍然不是完全安全的，但使得该漏洞更难被利用。在用户计算机安装了 KAISER 补丁之后，Meltdown 的发现者在 2018 年发布了他们的研究成果，首先是在 arXiv 服务器上的预印本发布，然后提交进行正式的学术同行评审，最终在 2020 年完成并发表。

CISC 处理器采用微码构造，允许通过 CPU 固件更新在一定程度上“重新连接”硬件；这为 CISC 用户提供了更强的修复方法。推送微码更新比修补操作系统软件更为复杂和危险，开发硬件补丁也需要更长时间，部分原因是需要进行广泛的测试，确保补丁能够安全发布。将数百万用户的处理器“砖化”的成本远高于损坏操作系统，因为操作系统在发生错误更新时更容易重新安装。因此，微码补丁的开发在 Meltdown 论文发布后继续进行，并后来作为固件更新推送给 CISC 用户。

新的微码增加了清除缓存的逻辑，以清除所有推测执行后的漏洞。然而，这也带来了显著的性能损失，通常会导致 5% 到 30% 的性能下降。将这种性能损失强加给用户——通常是自动进行，而不告知或询问他们——引发了一些激烈的辩论，特别是在操作系统程序员之间，他们的软件级补丁工作被微码补丁所替代。

在撰写本文时，CPU 架构师正在努力重新设计其基本架构，以便在硬件层面正确修复 Meltdown 问题。2022 年，研究人员报告称，修复 Meltdown 的一些方法引入了一个新的推测执行漏洞，命名为 Retbleed。这可能会成为一场持续不断的“打地鼠”游戏，为架构师提供多年的就业机会。

### 练习

#### **6502 内核**

阅读 Joachim Deboy 的最小化 6502 内核的汇编代码，见 *[`6502.org/source/kernels/minikernel.txt`](http://6502.org/source/kernels/minikernel.txt)*。解释 IRQ、保存和恢复的发生位置。尝试制作一个 x86 或 RISC-V 版本的相同概念。

#### **推测执行漏洞审计**

查找并确认您的计算机是否以及如何修复了推测执行漏洞。在 Linux 系统中，`lscpu` 命令可能会显示一些相关信息。

### 进一步阅读

+   操作系统的经典教材是 Andrew Tanenbaum 和 Herbert Bos 编写的 *《现代操作系统》*（第 4 版，霍博肯：皮尔逊出版社，2014 年）。

+   要查看 Linux 为您提供的所有子程序，并从您的 x86 代码中调用，参见 R.A. Chapman 的“Linux 系统调用表（x86）”，* [`blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/`](https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/)*。

+   欲了解更多有关 Meltdown 漏洞的信息，参见 M. Lipp 等人，"Meltdown：从用户空间读取内核内存"，*《ACM 通讯》* 63，6 期（2020 年）：46-56。
