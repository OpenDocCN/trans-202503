# 第一章 Ruby 基础

1993 年，松本行弘（Yukihiro “Matz” Matsumoto）将他喜欢的几种语言（Perl、Smalltalk、Eiffel、Ada 和 Lisp）的部分特点结合起来，创造了他理想中的语言——Ruby。

Ruby 是一种动态的面向对象编程语言，同时也支持命令式和函数式编程风格。它注重简洁、生产力和开发者的愉悦感。Ruby 网站将其称为“程序员的最佳朋友”，而有其他语言经验的开发者通常会发现 Ruby 容易编写且自然易读。

扎实的 Ruby 基础对于理解 Ruby on Rails 至关重要，因此本章将介绍 Ruby 的基础知识。在我们逐步讲解语言特性时，我将展示一些经验丰富的 Ruby 开发人员常用的习惯用法，以便您以后能够在自己的程序中使用它们。

# 交互式 Ruby

我探索 Ruby 语言的最喜欢方式是通过*交互式 Ruby 解释器(IRB)*。大多数时候，我在文本编辑器中开发应用程序，但我仍然保持一个 IRB 会话以快速测试想法。

要启动 IRB，打开一个终端（或 Windows 上的命令提示符），输入**`irb`**，然后按 ENTER。您应该会看到类似于以下的提示符：

```
irb(main):001:0>
```

如果在输入`irb`后看到错误消息，可能是因为您没有安装 IRB。请查看引言并按照 Ruby 的安装说明来设置 IRB。

IRB 是一种名为*读取-评估-打印循环(REPL)*的程序。IRB 读取您的输入，评估它并显示结果。它会重复这个过程，直到您按 CTRL-D 或输入`quit`或`exit`。

通过输入几个被引号包围的单词来试试 IRB：

```
irb(main):001:0> **"Hello, Ruby"**
 => "Hello, Ruby"
```

Ruby 会评估您输入的表达式并显示结果。一个简单的字符串会评估为它本身，但这与打印字符串不同。要在屏幕上输出内容，可以使用 Ruby 方法`puts`，如下面所示：

```
irb(main):002:0> **puts "Hello, Ruby"**
Hello, Ruby
 => nil
```

现在，Ruby 将字符串输出到屏幕，并显示`nil`，这是评估`puts`方法的结果。在 Ruby 中，每个方法都会返回一个值。`puts`方法没有任何有用的返回值，因此返回`nil`。

在本章的其余部分中，您将看到更多的示例，您可以将其输入到 IRB 中。我鼓励您尝试这些示例，探索您可以在 IRB 和 Ruby 中做什么。

### 注意

*如果 IRB 停止评估您输入的内容，可能是因为您忘记了闭合的引号或其他预期的语法。遇到这种情况时，按* **CTRL-C** *取消当前操作并返回到可用的提示符。*

现在，让我们来看看 Ruby 中可用的数据类型。

# 数据类型

Ruby 有六种主要的数据类型：数字、字符串、符号、数组、哈希和布尔值。在本节中，我将简要介绍这些数据类型以及如何使用它们。

## 数字

Ruby 支持您在学校学到的数学运算，还有一些您可能没见过的运算。输入一个表达式到 IRB 并按 ENTER 键查看结果：

```
irb(main):003:0> **1 + 1**
 => 2
```

我们让 Ruby 计算表达式 1 + 1，它返回了结果 2。试试更多的数学操作。一切应该按预期工作，至少直到你尝试除法，如下所示：

```
irb(main):004:0> **7 / 3**
 => 2
```

Ruby 默认执行*整数除法*。换句话说，它会丢弃余数。你可以使用取模运算符（`%`）来找到余数。如果你想得到一个分数结果，则需要明确告诉 Ruby 使用浮点数运算，方法是在至少一个数字后面加上小数点和零。在 IRB 中，你可以看到取模运算符和浮点除法的例子：

```
irb(main):005:0> **7 % 3**
 => 1
irb(main):006:0> **7.0 / 3**
 => 2.3333333333333335
```

这个概念很重要：虽然这些看起来像简单的数学运算符，但它们实际上在 Ruby 中是方法。你甚至可以在其他语言认为是基本数据类型的数据上调用方法。

```
irb(main):007:0> **1.odd?**
 => true
```

在这里，我们询问数字 1 是否是奇数，IRB 的回答是`true`。

## 字符串

你可以通过用单引号或双引号将字符括起来来创建字符串，例如下面这个例子：

```
irb(main):008:0> **'A String!'**
 => "A String!"
```

你还可以在 Ruby 中将字符串组合成更大的字符串。Ruby 能理解两种操作：字符串相加和将字符串乘以一个数字。让我们看每种操作的一个例子：

```
irb(main):009:0> **"Hello" + "World"**
 => "HelloWorld"
irb(main):010:0> **"Hi" * 3**
 => "HiHiHi"
```

请注意，Ruby 在加法或乘法操作时不会自动在单词之间添加空格，这个细节由你负责处理。

到目前为止，我还没有区分单引号字符串和双引号字符串，但双引号字符串实际上允许你以更复杂的方式组合字符串。例如，它们支持一种叫做*字符串插值*的特性，在这种情况下，Ruby 会计算由`#{`和`}`括起来的表达式，将结果转换为字符串，并自动插入到字符串中，如下所示：

```
irb(main):011:0> **x = 10**
 => 10
irb(main):012:0> **"x is #{x}"**
 => "x is 10"
```

在这种情况下，`#{x}` 的值为 10，因此 Ruby 将数字 10 转换为字符串，并返回`"x is 10"`。

双引号字符串还支持特殊字符，如换行符和制表符。这些特殊字符由反斜杠后跟字母组成。输入**`\n`**可以创建换行符（见下文），或输入**`\t`**可以创建制表符。要在双引号字符串中添加字面意义上的反斜杠，请输入两个反斜杠。

```
irb(main):013:0> **puts "Line one\nLine two"**
Line one
Line two
 => nil
```

你已经看到了一些字符串方法，但还有许多其他方法也很有用，包括`length`和`empty?`。（是的，Ruby 中的方法可以以问号甚至感叹号结尾。）让我们来看一下这两个方法的实际应用：

```
irb(main):014:0> **"Hello".length**
 => 5
irb(main):015:0> **"Hello".empty?**
 => false
```

`length`方法返回字符串中的字符数，而`empty?`方法则告诉你字符串是否包含任何字符。

### 注意

*方法名末尾的问号，如`empty?`，表示它是一个谓词方法，将返回一个布尔值。感叹号（`!`）通常表示该方法执行某些危险操作，例如直接修改对象。*

## 符号

Ruby 有一种在其他编程语言中不常见的数据类型，那就是符号（Symbol）。符号与字符串类似，都是由字符组成的，但符号不是被引号括起来，而是以冒号为前缀，如下所示：

```
irb(main):016:0> **:name**
 => :name
```

符号通常用作标识符。它们只创建一次，并且是唯一的。这意味着它们既易于程序员读取为字符串，又节省内存。你可以通过创建一些字符串和符号，然后调用 `object_id` 方法来亲自验证这一点。

```
irb(main):017:0> **"name".object_id**
 => 70156617860420
irb(main):018:0> **"name".object_id**
 => 70156617844900
irb(main):019:0> **:name.object_id**
 => 67368
irb(main):020:0> **:name.object_id**
 => 67368
```

注意，这里的两个字符串内容相同，但对象 ID 不同。这是两个不同的对象。两个符号具有相同的内容和相同的对象 ID。

当 Ruby 比较两个字符串是否相等时，它会检查每个字符的相等性。而比较两个符号是否相等时，只需要进行数值比较，这样更加高效。

## 数组

数组表示 Ruby 中的对象列表。你可以通过用方括号将一组对象括起来来创建一个数组。例如，来创建一个数字数组：

```
irb(main):021:0> **list = [1, 2, 3]**
=> [1, 2, 3]
```

Ruby 数组可以包含任何类型的对象，甚至是其他数组。你可以通过将一个数字索引传递给数组的 `[]` 方法来访问数组中的单个元素。第一个元素的索引是零。尝试查看刚创建的数组中的第一个元素：

```
irb(main):022:0> **list[0]**
 => 1
```

输入 `list[0]` 告诉 Ruby 获取数组中的第一个数字，方法将返回 `1`。

### 注意

*如果你尝试访问一个数组中不存在的元素，`[]` 方法将返回 `nil`。*

你还可以向 `[]` 方法传递两个数字来创建一个数组*切片*，如下所示。你提供的第一个数字指定了起始索引，而第二个数字则告诉它你想要在数组切片中包含多少元素：

```
irb(main):023:0> **list[0, 2]**
 => [1, 2]
```

这里，`[]` 方法从索引零开始，并返回 `list` 中的前两个数字。

与字符串一样，你还可以使用 `+` 运算符将数组相加，创建一个新数组。如果你只是想将元素添加到现有数组的末尾，可以使用 `<<` 运算符。你可以在这里看到每种操作的示例：

```
irb(main):024:0> **list + [4, 5, 6]**
 => [1, 2, 3, 4, 5, 6]
irb(main):025:0> **list << 4**
 => [1, 2, 3, 4]
```

尽管 `+` 运算符返回一个新数组，但它不会修改现有数组。而 `<<` 运算符会修改现有数组。你还可以使用索引重新赋值给现有元素或向数组添加新元素。

## 哈希

哈希是一个键值对的集合。在 Ruby 中，哈希是用大括号括起来的。与数组索引不同，哈希的键可以是任何数据类型。例如，符号通常作为哈希键使用。当你需要访问哈希中的一个值时，只需将对应的键传递给 `[]` 方法，如下所示。尝试访问一个不存在的键会返回 `nil`。

```
irb(main):026:0> **some_guy = { :name => "Tony", :age => 21 }**
 => {:name=>"Tony", :age=>21}
irb(main):027:0> **some_guy[:name]**
 => "Tony"
```

键和值之间的等号和大于符号（`=>`）的组合通常被称为*哈希火箭*。由于符号经常用作哈希的键，Ruby 1.9 添加了一个专门为它们设计的简写语法。你可以将符号前的冒号移到后面，然后省略哈希火箭。以下是一个示例：

```
irb(main):028:0> **another_guy = { name: "Ben", age: 20 }**
 => {:name=>"Ben", :age=>20}
```

尽管你可以使用这种简写语法创建哈希，但 Ruby 似乎有些怀旧，在显示哈希时仍然使用旧语法。

你也可以使用`keys`方法获取哈希中所有键的数组。如果你需要哈希中所有值的数组，改用`values`方法即可。这里的代码展示了每个方法的示例，使用的是刚刚创建的相同哈希：

```
irb(main):029:0> **another_guy.keys**
 => [:name, :age]
irb(main):030:0> **another_guy.values**
 => ["Ben", 20]
```

哈希经常用来表示数据结构，如这些示例所示。它们有时也用来将命名参数传递给方法。如果哈希是方法调用的最后一个（或唯一）参数，你甚至可以省略大括号。

例如，`merge`方法将两个哈希合并。这里的代码将名为`another_guy`的哈希与一个包含`{ job: "none" }`的新哈希合并。

```
irb(main):031:0> **another_guy.merge job: "none"**
 => {:name=>"Ben", :age=>20, :job=>"none"}
```

由于这个方法调用的唯一参数是新的哈希，你可以省略大括号。Rails 有许多其他类似的这种方法调用示例。

## 布尔值

布尔表达式是任何可以计算为真或假的表达式。这些表达式通常涉及布尔运算符，Ruby 支持常见的运算符，包括*小于*(` < `)、*大于*(` > `)、*等于*(` == `)和*不等于*(` != `)。尝试在 IRB 提示符下使用这些布尔表达式：

```
irb(main):032:0> **1 < 2**
 => true
irb(main):033:0> **5 == 6**
 => false
```

Ruby 还提供了*and*(`&&`)和*or*(`||`)运算符，用于组合多个布尔表达式，如下所示：

```
irb(main):034:0> **1 < 2 || 1 > 2**
 => true
irb(main):035:0> **5 != 6 && 5 == 5**
 => true
```

这两个运算符*短路*。也就是说，`&&`只有在两侧的表达式都为真时才为真。如果第一个表达式为假，则第二个表达式不会被计算。类似地，`||`如果任一表达式为真，则为真。如果第一个表达式为真，则第二个表达式不会被计算。

`||`运算符有时也用于赋值。当你希望只在变量当前为`nil`时初始化它，否则保持当前值时，你可以这样做。Ruby 为此提供了`||=`运算符。这被称为*条件赋值*，你可以在这里看到一个示例：

```
irb(main):036:0> **x = nil**
 => nil
irb(main):037:0> **x ||= 6**
 => 6
```

如果变量`x`不是假值，那么条件赋值将返回`x`的值，而不是将其设置为 6。

### 注意

*Ruby 中的任何表达式都可以被评估为布尔表达式。在 Ruby 中，只有`nil`和`false`被认为是假的。其他所有值都被认为是真的。这与一些其他语言不同，在这些语言中，像空字符串、空集合和数字零这样的值被认为是假的。*

# 常量

*常量*为一个不变的值赋予一个名称。在 Ruby 中，常量的名称*必须*以大写字母开头。常量通常使用大写字母书写，像这样：

```
irb(main):038:0> **PI = 3.14**
=> 3.14
irb(main):039:0> **2 * PI**
=> 6.28
```

Ruby 实际上不会阻止你给常量重新赋值，但如果这么做，它会显示一个警告。

# 变量

在 Ruby 中，你无需提前声明变量或指定类型，只需像下面这样给一个名称赋值：

```
irb(main):040:0> **x = 10**
 => 10
```

变量 `x` 现在指向数字 10。变量名通常采用 *蛇形命名法*，即所有字母小写，单词之间用下划线连接。

```
irb(main):041:0> **first_name = "Matthew"**
 => "Matthew"
```

变量名可以包含字母、数字和下划线，但必须以字母或下划线开头。

# 控制流

到目前为止，我们看的例子都是线性的。真正的程序通常包含只有在满足某个条件时才会执行的语句，以及多次重复执行的语句。在这一部分，我将介绍 Ruby 的条件语句和迭代。

## 条件语句

*条件语句* 让你的程序根据你提供的表达式选择执行一个或多个代码分支。因此，在代码中做决策也叫做 *分支*。例如，下面的条件语句只有在表达式 `age < 13` 计算为 true 时才会打印 *Child* 这个词。

```
irb(main):042:0> **age = 21**
 => 21
irb(main):043:0> **if age < 13**
irb(main):044:1>   **puts "Child"**
irb(main):045:1> **end**
 => nil
```

变量 `age` 被设置为 21，因此 `age < 13` 会计算为 `false`，什么也不会被打印出来。

你还可以使用 `elsif` 和 `else` 来创建更复杂的条件语句。我们来看一个需要检查多个条件的代码示例：

```
irb(main):046:0> **if age < 13**
irb(main):047:1>   **puts "Child"**
irb(main):048:1> **elsif age < 18**
irb(main):049:1>   **puts "Teen"**
irb(main):050:1> **else**
irb(main):051:1>   **puts "Adult"**
irb(main):052:1> **end**
Adult
 => nil
```

这段代码可以根据 `age` 的值采取三种不同的分支。在我们的例子中，它应该跳过 `if` 和 `elsif` 语句中的代码，只打印 *Adult*。

之前所有的条件示例都检查了为 true 的表达式，但如果你想在表达式为 false 时执行一段代码该怎么办呢？像其他语言一样，Ruby 有一个逻辑 *非* 操作符（可以是 `not` 或 `!`），在这里非常有用。以下示例将在 `name` 不是空字符串时打印其值。

```
irb(main):053:0> **name = "Tony"**
 => "Tony"
irb(main):054:0> **if !name.empty?**
irb(main):055:1>   **puts name**
irb(main):056:1> **end**
 => nil
```

当 `name.empty?` 为 false 时，`!` 操作符应该将结果反转为 true，这样 `if` 语句中的代码就会执行。用更自然的方式来说，这个条件可能是“除非 `name` 为空，否则打印它的值。”与 `if` 语句不同，Ruby 的 `unless` 语句在表达式计算为 false 时执行代码。

```
irb(main):057:0> **name = "Tony"**
 => ""
irb(main):058:0> **unless name.empty?**
irb(main):059:1>   **puts name**
irb(main):060:1> **end**
 => nil
```

我觉得这还是有点啰嗦。对于像这样的单行表达式，Ruby 允许你把条件放在行尾：

```
irb(main):061:0> **name = "Tony"**
 => ""
irb(main):062:0> **puts name unless name.empty?**
 => nil
```

这个例子简洁且易读。对我来说，这段代码的意思是“除非 `name` 为空，否则打印它。”这段代码也是 Ruby 灵活性的一个很好的例子。你可以使用最符合你理解的风格来编写条件表达式。

## 迭代

当你处理一个对象集合时，比如数组或哈希，你通常会想对每个项目执行操作。除了其他语言中看到的 `for` 循环外，Ruby 集合提供了 `each` 方法。

`each` 方法接受一块代码，并对集合中的每个元素执行它。Ruby 中的块通常以 `do` 开头，以 `end` 结尾。块也可以接受一个或多个参数，这些参数列在一对管道符号中。`each` 方法返回整个集合的值。

下一个示例遍历数组 `list` 中的每个元素，`list` 是我们在本章前面创建的数组 [1, 2, 3, 4]。它将每个元素赋值给变量 `number`，然后打印 `number` 的值。

```
irb(main):063:0> **list.each do |number|**
irb(main):064:1>   **puts number**
irb(main):065:1> **end**
1
2
3
4
 => [1, 2, 3, 4]
```

像这样的简单块通常在 Ruby 中写成一行。你可以使用大括号来表示一个块，而不是写 `do` 和 `end`，这在单行块中非常常见。像前面的例子一样，这个示例遍历列表并打印每个元素，但它在一行代码中完成所有操作。

```
irb(main):066:0> **list.each { |n| puts n }**
1
2
3
4
 => [1, 2, 3, 4]
```

你还可以使用 `each` 方法遍历哈希。因为哈希是键值对的集合，所以块将接受两个参数。我们来尝试用 `each` 遍历我们之前的一个哈希：

```
irb(main):067:0> **some_guy.each do |key, value|**
irb(main):068:1>   **puts "The #{key} is #{value}."**
irb(main):069:1> **end**
The name is Tony.
The age is 21.
 => {:name=>"Tony", :age=>21}
```

块不仅对迭代有用。任何方法都可以接受一个块并使用它包含的代码。例如，你可以将一个块传递给 `File.open` 方法。Ruby 应该将文件句柄作为变量传递给块，执行块中的代码，然后自动关闭文件。

# 方法

一个 *方法* 是一个可重用代码的命名块。定义自己的方法在 Ruby 中很简单。方法定义以 `def` 开头，后面跟着一个名称，直到 `end` 结束。这个方法每次被调用时会打印 “Hello, World!”：

```
irb(main):070:0> **def hello**
irb(main):071:1>   **puts "Hello, World!"**
irb(main):072:1> **end**
 => nil
```

如你所见，示例中的方法定义应该返回 `nil`。

### 注意

*如果你使用的是 Ruby 2.1，方法定义会将方法名作为符号返回。*

一旦你定义了一个方法，你可以通过在 IRB 提示符中输入方法名来调用它：

```
irb(main):073:0> **hello**
Hello, World!
 => nil
```

Ruby 方法总是返回其最后一条语句的值；在这个例子中，最后一条语句是 `puts`，它返回 `nil`。你可以使用 `return` 显式返回一个值，或者直接将你希望返回的值作为方法的最后一行。

例如，如果你希望 `hello` 方法返回 `true`，你可以像这样修改它：

```
irb(main):074:0> **def hello**
irb(main):075:1>   **puts "Hello, World!"**
irb(main):076:1>   **true**
irb(main):077:1> **end**
 => nil
```

现在像之前一样调用该方法：

```
irb(main):078:0> **hello**
Hello, World!
 => true
```

因为方法的最后一行是 `true`，所以当调用该方法时，它会返回 `true`。

在 Ruby 中，你通过在方法名后面添加参数来指定方法参数，参数可以选择性地用括号括起来，如下一个例子所示。参数也可以有默认值。

```
irb(main):079:0> **def hello(name = "World")**
irb(main):080:1>   **puts "Hello, #{name}!"**
irb(main):081:1> **end**
 => nil
```

这个示例重新定义了 `hello` 方法，使其接受一个名为 `name` 的参数。这个参数的默认值为 `"World"`。这个方法可以像之前一样调用来显示 “Hello, World!”，或者你可以传递一个 `name` 参数的值来问候其他人。

```
irb(main):082:0> **hello**
Hello, World!
 => nil
irb(main):083:0> **hello "Tony"**
Hello, Tony!
 => nil
```

方法参数周围的括号也是可选的。如果意图不明确，可以加上括号；否则，可以省略它们。

# 类

在像 Ruby 这样的面向对象编程语言中，一个*类*表示一个独特类型对象的状态和行为。在 Ruby 中，对象的状态存储在实例变量中，方法定义了它的行为。Ruby 类的定义以`class`开头，后接大写字母的类名，并以匹配的`end`结束。

类定义可以包括一个名为`initialize`的特殊方法。创建类的新实例时，会调用该方法。通常用来为类所需的实例变量赋值。在 Ruby 中，实例变量以`@`开头，如以下类定义所示：

```
irb(main):084:0> **class Person**
irb(main):085:1>   **def initialize(name)**
irb(main):086:2>     **@name = name**
irb(main):087:2>   **end**
irb(main):088:1>   **def greet**
irb(main):089:2>     **puts "Hi, I'm #{@name}."**
irb(main):090:2>   **end**
irb(main):091:1> **end**
 => nil
```

这段代码定义了一个名为`Person`的新类。`initialize`方法接受一个参数，并将该参数的值赋给实例变量`@name`。`greet`方法打印一个友好的问候。让我们编写一些代码，来使用这个新类。

```
irb(main):092:0> **person = Person.new("Tony")**
 => #<Person:0x007fc98418d710 @name="Tony">
irb(main):093:0> **person.greet**
Hi, I'm Tony.
 => nil
```

你可以通过调用`Person.new`并传递所需的参数来创建`Person`类的实例。前面的示例创建了一个名为 Tony 的`Person`实例。

`Person.new`的返回值是该对象的字符串表示。它由类名、内存中的对象引用以及实例变量的列表组成。调用`greet`方法应该会显示我们预期的友好问候。

实例变量，如`@name`，在类外部是不可访问的。尝试在 IRB 提示符下访问`person.name`，你应该会看到一个错误。

```
irb(main):094:0> **person.name**
NoMethodError: undefined method 'name'
```

如果你需要在类外部访问或修改`@name`，你需要编写一个*getter*和一个*setter*。这两个方法分别用于*获取*或*设置*实例变量的值。幸运的是，Ruby 类提供了`attr_accessor`方法，可以为你自动生成 getter 和 setter。

通常你会在`Person`类的定义中包含`attr_accessor :name`。为了避免重新输入整个类定义，你可以重新打开该类并添加这一行：

```
irb(main):095:0> **class Person**
irb(main):096:1>   **attr_accessor :name**
irb(main):097:1> **end**
 => nil
```

这段代码将`attr_accessor`调用添加到`Person`类，并自动更新所有该类的对象。这也是 Ruby 灵活性的另一个例子。你可以重新打开一个类，甚至在运行时，根据需要添加新方法。

现在，如果我们想要更改这个人的名字，我们只需要将其设置为其他值，如下所示：

```
irb(main):098:0> **person.name**
 => "Tony"
irb(main):099:0> **person.name = "Wyatt"**
 => "Wyatt"
irb(main):100:0> **person.greet**
Hi, I'm Wyatt.
 => nil
```

`attr_accessor`方法使用符号`:name`来定义 getter `name`和 setter `name=`。现在你可以根据需要获取和设置实例变量的值。如果你只需要一个 getter，可以使用`attr_reader`替代`attr_accessor`。这样做允许你读取`@name`的值，但不能修改它。

## 类方法

`attr_accessor`方法与我之前讨论过的方法有所不同。请注意，`attr_accessor`是在类定义体内调用的。而你之前见过的方法，比如`greet`方法，是在类的实例上调用的。

在 Ruby 中，调用类的实例方法称为 *实例方法*。调用类本身的方法称为 *类方法*。`new` 方法就是一个类方法的例子。当你输入 `Person.new("Tony")` 时，你调用的是 `Person` 类的 `new` 类方法。

## 继承

在 Ruby 中，你可以定义一个新的类，基于现有类的状态和行为构建，新类将从现有类继承变量和方法。*继承*定义了这两个类之间的*是一个*关系。例如，学生是一个人。我们可以这样定义 `Student` 类：

```
irb(main):101:0> **class Student < Person**
irb(main):102:1>  **def study**
irb(main):103:2>    **puts "ZzzzZzzz"**
irb(main):104:2>  **end**
irb(main):105:1> **end**
 => nil
```

第一行中的 `< Person` 表示 `Student` 类继承自 `Person` 类。由 `Person` 定义的变量和方法现在对 `Student` 类可用：

```
  irb(main):106:0> **student = Student.new("Matt")**
  #<Student:0x007fd7c3ac4d90 @name="Matt">
➊ irb(main):107:0> **student.greet**
  Hi, I'm Matt.
   => nil
  irb(main):108:0> **student.study**
  ZzzzzZzzzz
  => nil
```

因为我们在本章早些时候已经在 `Person` 类中创建了 `greet` 方法，所以我们可以让任何 `Student` 调用这个方法 ➊，而无需在新类中重新定义它。

Ruby 只支持 *单继承*，这意味着一个类不能同时从多个类继承。不过，你可以通过使用 *模块* 来绕过这一限制。模块是一个方法和常量的集合，它不能被实例化，但可以包含到其他类中以提供额外的行为。我们在 第七章中讨论了模块和其他 Ruby 的高级特性。

# 摘要

你现在已经在成为一名优秀的 Ruby on Rails 程序员的道路上迈出了重要的一步。你在本章中学到的 Ruby 知识将使你更容易理解 Rails 框架。

我建议在你感到熟悉 Ruby 之前，尽量多使用 IRB。当你准备好开始探索 Rails 时，输入 `exit` 退出 IRB，然后继续阅读 第二章。

# 练习

| Q: | 1\. 你可以使用 Ruby 的 `File.read` 方法读取纯文本文件。创建一个包含一段或两段博客文章或书籍内容的文件，并将其命名为当前目录下的 *test.txt*。以下代码示例将名为 *test.txt* 的文件读取到变量 `file` 中，并显示文件的内容：

```
**file = File.read("test.txt")**
**puts file**
```

如你所见，`file` 包含一个字符串。使用 `file.split` 可以将字符串转换为一个单词数组。现在你可以使用 Ruby 内置的数组方法来操作文件的内容。例如，使用 `file.split.length` 来计算文件中的单词数。`file.split.uniq.length` 告诉你文件中有多少个 *独特* 的单词。

| Q: | 2\. 使用练习 1 中的单词数组，统计每个单词在文件中出现的次数。一种方法是遍历数组，并将每个单词的计数存储在一个哈希中，其中键是单词，值是计数。 |
| --- | --- |

| 问： | 3\. 创建一个`WordCounter`类，以执行练习 1 和练习 2 中的操作。该类在初始化时应接受一个文件名以读取，并包含名为`count`、`uniq_count`和`frequency`的方法，用于执行前两个练习中的操作。以下类定义可以帮助你开始：

```
class WordCounter
  def initialize(file_name)
    @file = File.read(file_name)
  end

  # your code here...
end
```

|
