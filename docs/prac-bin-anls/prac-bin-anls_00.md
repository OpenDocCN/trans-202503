## 前言

绝大多数计算机程序都是用像 C 或 C++这样的高级语言编写的，而计算机无法直接运行这些语言。在你使用这些程序之前，必须先将它们编译成包含计算机可以运行的机器代码的*二进制可执行文件*。但是，你如何知道编译后的程序与高级源代码的语义一致呢？令人生畏的答案是：*你不知道*！

高级语言和二进制机器代码之间存在很大的语义差距，而很多人不知道如何弥补这个差距。即便是大多数程序员，对程序在最低层的工作原理也了解有限，他们只是信任编译后的程序符合他们的意图。因此，许多编译器漏洞、微妙的实现错误、二进制级的后门以及恶意寄生虫可能都未被察觉。

更糟糕的是，有无数二进制程序和库——在工业、银行、嵌入式系统中——它们的源代码早已丢失或是专有的。这意味着，使用传统方法无法在源代码层面对这些程序和库进行修补或评估其安全性。即便是大型软件公司，也面临着这样的问题，微软最近发布了一个经过精心手工制作的二进制补丁，用来修复其 Equation Editor 程序中的缓冲区溢出漏洞，而该程序是微软 Office 套件的一部分。^(1)

本书将教你如何在二进制层面分析甚至修改程序。无论你是黑客、安全研究员、恶意软件分析师、程序员，还是单纯的感兴趣者，这些技术都将让你对你每天创建和使用的二进制程序拥有更多的控制权和洞察力。

### 什么是二进制分析，为什么你需要它？

*二进制分析* 是分析二进制计算机程序（称为 *二进制文件*）及其包含的机器代码和数据属性的科学与艺术。简而言之，所有二进制分析的目标都是弄清楚（并可能修改）二进制程序的真实属性——换句话说，弄清楚它们*真正*做了什么，而不是我们认为它们应该做什么。

很多人将二进制分析与逆向工程和反汇编联系在一起，这至少在某种程度上是正确的。反汇编是许多二进制分析形式中的重要第一步，而逆向工程是二进制分析的常见应用，通常是记录专有软件或恶意软件行为的唯一方法。然而，二进制分析的领域远不止这些。

广义来说，二进制分析技术可以分为两类，或者是这两类的组合：

**静态分析** *静态分析* 技术在不运行二进制文件的情况下对其进行推理。这种方法有几个优点：你可以一次性分析整个二进制文件，并且不需要能够运行该二进制文件的 CPU。例如，你可以在 x86 机器上静态分析一个 ARM 二进制文件。缺点是，静态分析无法了解二进制文件的运行时状态，这可能使得分析变得非常具有挑战性。

**动态分析** 相比之下，*动态分析* 运行二进制文件并在执行过程中进行分析。与静态分析相比，这种方法通常更简单，因为你能够全面了解整个运行时状态，包括变量的值和条件分支的结果。然而，你只能看到已执行的代码，因此分析可能会错过程序中的有趣部分。

静态分析和动态分析各有优缺点，在本书中你将学习到来自这两种思维方式的技术。除了被动的二进制分析，你还将学习到*二进制插桩*技术，这些技术可以在没有源代码的情况下修改二进制程序。二进制插桩依赖于像反汇编这样的分析技术，同时它也可以用于辅助二进制分析。由于二进制分析和插桩技术之间的这种共生关系，本书涵盖了这两者。

我之前提到过，你可以通过二进制分析来为没有源代码的程序进行文档编写或渗透测试。但即使源代码可用，二进制分析仍然可以用来查找一些在二进制级别比源代码级别更明显的微妙 bug。许多二进制分析技术对于高级调试也非常有用。本书涵盖了你可以在所有这些场景中使用的二进制分析技术，甚至更多。

### 什么让二进制分析变得具有挑战性？

二进制分析具有挑战性，比源代码级别的等效分析要困难得多。事实上，许多二进制分析任务本质上是不可判定的，这意味着不可能为这些问题构建一个始终返回正确结果的分析引擎！为了让你了解可能遇到的挑战，以下是一些让二进制分析变得困难的原因。不幸的是，这个列表远未详尽无遗。

**没有符号信息** 当我们用像 C 或 C++ 这样的高级语言编写源代码时，我们为变量、函数和类等构造命名。这些命名我们称之为*符号信息*，简称*符号*。良好的命名约定使得源代码更易于理解，但它们在二进制级别没有实际意义。因此，二进制文件通常会去除符号信息，这使得理解代码变得更加困难。

**没有类型信息** 另一个高级程序的特点是它们围绕具有明确定义类型的变量展开，例如`int`、`float` 或 `string`，以及更复杂的数据结构，如 `struct` 类型。相比之下，在二进制层面，类型从不显式声明，这使得数据的用途和结构很难推断。

**没有高级抽象** 现代程序被划分为类和函数，但编译器会丢弃这些高级构造。这意味着，二进制文件呈现为大量的代码和数据块，而不是结构良好的程序，恢复高级结构既复杂又容易出错。

**混合的代码和数据** 二进制文件可以（并且确实会）包含与可执行代码混合的数据片段。^(2) 这使得意外地将数据当作代码，或将代码当作数据，变得容易，从而导致错误的结果。

**依赖位置的代码和数据** 由于二进制文件并非设计用于修改，即使是添加一条机器指令，也可能引发问题，因为它会导致其他代码位置发生变化，从而使内存地址和代码中的其他引用失效。因此，任何类型的代码或数据修改都非常具有挑战性，并且容易破坏二进制文件。

由于这些挑战，在实践中我们往往必须接受不精确的分析结果。二进制分析的重要部分是尽管分析存在误差，我们仍能想出创造性的方法来构建可用的工具！

### 谁应该阅读这本书？

本书的目标读者包括安全工程师、学术安全研究人员、黑客和渗透测试人员、逆向工程师、恶意软件分析师，以及对二进制分析感兴趣的计算机科学学生。但实际上，我试图让这本书对任何对二进制分析感兴趣的人都能理解。

也就是说，由于本书涵盖了高级主题，因此需要具备一定的编程和计算机系统知识。为了从本书中获得最大收益，你应该具备以下内容：

• 对 C 和 C++ 编程语言有一定的掌握。

• 对操作系统内部原理有基本的了解（例如进程是什么，虚拟内存是什么，等等）。

• 需要了解如何使用 Linux shell（最好是`bash`）。

• 熟悉 x86/x86-64 汇编语言。如果你还不懂任何汇编语言，确保先阅读附录 A！

如果你以前从未编程过，或者不喜欢深入探讨计算机系统的底层细节，那么这本书可能不适合你。

### 本书内容

本书的主要目标是让你成为一名全面的二进制分析师，熟悉该领域的所有主要主题，包括基础主题和像二进制仪器化、污点分析、符号执行等高级主题。本书*并不*假设自己是一本全面的资源，因为二进制分析领域和工具发展迅速，一本全面的书籍可能在一年内就会过时。相反，目标是让你在所有重要主题上足够有知识，以便为进一步的独立学习做好准备。

同样，本书并没有深入探讨逆向工程 x86 和 x86-64 代码的所有细节（尽管附录 A 涵盖了基础知识），也没有涉及在这些平台上分析恶意软件。已经有许多专门的书籍讲解这些内容，重复它们在此并无意义。关于手动逆向工程和恶意软件分析的书籍，请参考附录 D。

本书分为四个部分。

**第一部分：二进制格式** 介绍了二进制格式，这是理解本书其余部分的关键。如果你已经熟悉 ELF 和 PE 二进制格式以及`libbfd`，可以安全地跳过这一部分的一个或多个章节。

**第一章：二进制程序的结构** 提供了二进制程序结构的一般介绍。

**第二章：ELF 格式** 介绍了 Linux 上使用的 ELF 二进制格式。

**第三章：PE 格式简要介绍** 介绍了 PE 格式，这是 Windows 上使用的二进制格式。

**第四章：使用 libbfd 构建二进制加载器** 介绍了如何使用`libbfd`解析二进制文件，并构建本书后续章节使用的二进制加载器。

**第二部分：二进制分析基础** 包含了基础的二进制分析技术。

**第五章：Linux 中的基础二进制分析** 介绍了 Linux 下的基础二进制分析工具。

**第六章：反汇编与二进制分析基础** 涵盖了基本的反汇编技术和基本分析模式。

**第七章：ELF 的简单代码注入技术** 让你初步了解如何使用寄生代码注入和十六进制编辑等技术修改 ELF 二进制文件。

**第三部分：高级二进制分析** 主要讲解高级二进制分析技术。

**第八章：自定义反汇编** 介绍了如何使用 Capstone 构建自定义反汇编工具。

**第九章：二进制仪器化** 介绍了如何使用 Pin，一个完整的二进制仪器化平台，来修改二进制文件。

**第十章：动态污点分析原理** 向你介绍了*动态污点分析*的原理，这是一种最先进的二进制分析技术，能够跟踪程序中的数据流。

**第十一章：使用 libdft 进行实用动态污点分析** 教你如何使用`libdft`构建自己的动态污点分析工具。

**第十二章：符号执行原理** 专门讲解*符号执行*，这是一种先进技术，可以帮助你自动推理复杂的程序属性。

**第十三章：使用 Triton 进行实用符号执行** 向你展示如何使用 Triton 构建实用的符号执行工具。

**第四部分：附录** 包含一些你可能会发现有用的资源。

**附录 A：x86 汇编语言速成课程** 为尚未熟悉 x86 汇编语言的读者提供了简短的入门介绍。

**附录 B：使用 libelf 实现 PT_NOTE 覆盖** 提供了`elfinject`工具的实现细节，该工具在第七章中使用，并作为`libelf`的入门介绍。

**附录 C：二进制分析工具列表** 包含你可以使用的二进制分析工具列表。

**附录 D：进一步阅读** 包含与本书讨论的主题相关的参考文献、文章和书籍列表。

### 如何使用本书

为了帮助你最大限度地利用本书，让我们简要回顾一下关于代码示例、汇编语法和开发平台的约定。

#### *指令集架构*

尽管你可以将本书中的许多技术推广到其他架构，但我将把实际示例集中在 Intel x86 *指令集架构（ISA）*及其 64 位版本 x86-64（简称 x64）上。我将把 x86 和 x64 ISA 统称为“x86 ISA”。通常，示例将处理 x64 代码，除非另有说明。

x86 ISA 很有趣，因为它在消费市场中非常常见，尤其是在桌面和笔记本电脑中，并且在二进制分析研究中也有广泛应用（部分原因是它在终端用户机器中的普及）。因此，许多二进制分析框架都是针对 x86 的。

此外，x86 指令集架构的复杂性使你能够学习一些在简化架构上不会出现的二进制分析挑战。x86 架构有着长久的向后兼容历史（可以追溯到 1978 年），这导致了一个非常密集的指令集，大多数可能的字节值都表示一个有效的操作码。这加剧了代码与数据的问题，使得反汇编器不易察觉到他们误将数据解析为代码。此外，指令集是可变长度的，并且允许所有有效字长进行未对齐的内存访问。因此，x86 允许一些独特的复杂二进制结构，如（部分）重叠和未对齐的指令。换句话说，一旦你学会了处理像 x86 这样复杂的指令集，其他指令集（如 ARM）将会变得很自然！

#### *汇编语法*

如附录 A 所述，有两种常用的语法格式用于表示 x86 机器指令：*Intel 语法*和*AT&T 语法*。在这里，我将使用 Intel 语法，因为它更简洁。在 Intel 语法中，将常数移动到`edi`寄存器的写法如下：

```
mov     edi,0x6
```

请注意，目标操作数（`edi`）排在前面。如果你不确定 AT&T 和 Intel 语法之间的区别，请参考附录 A，其中概述了每种风格的主要特征。

#### *二进制格式与开发平台*

我开发了本书中所有的代码示例，均在 Ubuntu Linux 上完成，除了少数几个用 Python 编写的示例。之所以这么做，是因为许多流行的二进制分析库主要针对 Linux 平台，且它们提供了方便的 C/C++或 Python API。不过，本书中使用的所有技术以及大多数库和工具同样适用于 Windows，因此如果 Windows 是你的首选平台，你应该不会在将所学知识转移到 Windows 上时遇到困难。在二进制格式方面，本书主要关注 ELF 二进制文件，这是 Linux 平台的默认格式，尽管许多工具也支持 Windows PE 二进制文件。

#### *代码示例与虚拟机*

本书中的每一章都包含了若干代码示例，并且有一个预配置的虚拟机（VM）与本书一起提供，包含了所有的示例。该虚拟机运行的是流行的 Linux 发行版 Ubuntu 16.04，并安装了所有讨论过的开源二进制分析工具。你可以使用这个虚拟机来实验代码示例，并解决每章末尾的练习题。虚拟机可以在本书的官方网站上找到，网址是*[`practicalbinaryanalysis.com`](https://practicalbinaryanalysis.com)*或*[`nostarch.com/binaryanalysis/`](https://nostarch.com/binaryanalysis/)*。

在书籍的官方网站上，您还会找到一个包含所有示例和练习源代码的存档。如果您不想下载整个虚拟机，可以下载此存档，但请记住，如果您选择不使用虚拟机，一些所需的二进制分析框架需要复杂的设置，您需要自行完成。

要使用虚拟机（VM），您需要虚拟化软件。虚拟机是与 VirtualBox 一起使用的，您可以从*[`www.virtualbox.org/`](https://www.virtualbox.org/)*免费下载 VirtualBox。VirtualBox 支持所有流行的操作系统，包括 Windows、Linux 和 macOS。

安装 VirtualBox 后，只需运行它，点击 **文件** → **导入虚拟设备** 选项，选择您从书籍网站下载的虚拟机。添加后，点击主 VirtualBox 窗口中标有 **启动** 的绿色箭头来启动虚拟机。虚拟机启动完成后，您可以使用“binary”作为用户名和密码进行登录。然后，使用键盘快捷键 CTRL-ALT-T 打开终端，您就可以开始跟随书中的内容操作了。

在目录 *~/code* 中，您会找到每个章节的一个子目录，其中包含该章节的所有代码示例和其他相关文件。例如，您将在 *~/code/chapter1* 目录中找到 第一章的所有代码。还有一个名为 *~/code/inc* 的目录，包含多个章节中使用的公共代码。我为 C++ 源文件使用 *.cc* 扩展名，为 C 源文件使用 *.c* 扩展名，为头文件使用 *.h* 扩展名，为 Python 脚本使用 *.py* 扩展名。

要构建给定章节的所有示例程序，只需打开终端，导航到该章节的目录，然后执行 `make` 命令来构建目录中的所有内容。除了我明确提到其他构建命令的情况，这种方法在所有情况下都适用。

大多数重要的代码示例在其对应的章节中都有详细讨论。如果书中讨论的代码清单在虚拟机上有对应的源文件，其文件名会显示在清单之前，如下所示。

***filename.c***

```
int
main(int argc, char *argv[])
{
  return 0;
}
```

该清单标题表明，您可以在文件 *filename.c* 中找到清单所示的代码。除非另有说明，您将会在该章节的目录下找到文件，文件名与清单中的一致。您还会遇到没有文件名的清单标题，这意味着这些示例只是书中的示例，没有对应的虚拟机副本。没有虚拟机副本的简短代码清单可能没有标题，例如之前显示的汇编语法示例。

显示 shell 命令及其输出的列表使用 `$` 符号来表示命令提示符，并且使用粗体字体来标识包含用户输入的行。这些行是你可以在虚拟机上尝试的命令，而后续未带提示符或未加粗的行则表示命令输出。例如，下面是虚拟机上*~/code*目录的概览：

```
$ cd ~/code && ls
chapter1 chapter2   chapter3  chapter4  chapter5  chapter6  chapter7
chapter8 chapter9   chapter10 chapter11 chapter12 chapter13 inc
```

请注意，我有时会编辑命令输出以提高可读性，因此你在虚拟机上看到的输出可能会略有不同。

#### *练习*

在每章的结尾，你会找到一些练习和挑战，帮助巩固你在该章节中学到的技能。部分练习应该比较容易用你在章节中学到的技能解决，而其他一些则可能需要更多的努力和独立的研究。
