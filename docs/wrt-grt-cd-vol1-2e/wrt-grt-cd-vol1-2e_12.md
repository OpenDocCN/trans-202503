## 第十三章：计算机外围总线**

![Image](img/comm1.jpg)

系统总线并不是计算机系统中唯一的总线。还有许多专用的外围总线。本章讨论了 SCSI、IDE/ATA、SATA、SAS、FibreChannel、Firewire 和 USB 总线，这些总线连接了计算机和各种外围设备。

### 13.1 小型计算机系统接口

*小型计算机系统接口*（* SCSI *，发音为“scuzzy”）是一种外围设备互连总线，用于将高速外围设备连接到个人计算机系统。SCSI 总线于 1980 年代初期设计，并在 1980 年代中期随着 Apple Macintosh 计算机系统的推出而广泛流行。最初的 SCSI 总线支持 8 位双向数据总线，并且能够每秒传输 5MB 的数据，这在当时的硬盘子系统中被视为高性能。尽管按现代标准来看其早期性能相当慢，但 SCSI 经过多次修订，依然是一个高性能的外围设备互连系统。在其最盛大的时候，这些老式的 SCSI 设备能够达到每秒传输 320MB（兆字节）的速度。

尽管 SCSI（小型计算机系统接口）互连系统最常用于磁盘驱动子系统，但 SCSI 的设计初衷是支持通过电缆连接的各种 PC 外围设备。事实上，随着 SCSI 在 1980 年代末期和 1990 年代的普及，你可以看到打印机、扫描仪、影像设备、摄影排版机、网络和显示适配器以及许多其他设备都与 SCSI 总线连接。

然而，随着 USB、FireWire 和 Thunderbolt 外围连接系统的出现，SCSI 作为通用外围总线的流行度已经下降。除了一些非常高性能的磁盘驱动子系统和一些非常专业化的外围设备外，很少有新的外围设备使用这一接口。为了理解为什么 SCSI 的流行度下降，我们来看一下 SCSI 用户多年来面临的问题。

#### *13.1.1 限制*

当 SCSI 最初推出时，SCSI 总线支持 SCSI 适配器卡和最多七个外围设备的并行连接。为了连接多个设备，你需要从主机控制卡引出一根电缆连接到第一个外围设备。要连接第二个设备，你需要从第一个设备的第二个连接器引出一根电缆连接到第二个设备。要连接第三个设备，你需要从第二个设备的独立连接器引出电缆连接到第三个设备，依此类推。在这个设备的“菊花链”末端，你需要在最后一个外围设备的最后一个连接器上连接一个特殊的终端设备。如果没有在 SCSI 链的末端加上特殊的“终端器”，许多 SCSI 系统将无法正常工作，甚至无法工作。

作为一种“便利”，许多外设制造商将终端电路设计集成到他们的设备中。不幸的是，在 SCSI 链中间连接多个终端器就像根本没有终端器一样糟糕。尽管许多设计了终端电路的制造商通常提供禁用终端器的选项，但有些并没有。确保这些具有主动终端电路的设备位于 SCSI 链的末端往往很麻烦，即便某些设备提供了启用或禁用终端器的选项，如果文档不在手边，了解适当的 DIP 开关设置也是一大挑战。因此，许多计算机用户在他们的系统中遇到了 SCSI 设备链无法正常工作的情况。

在原始的 SCSI 总线上，计算机系统所有者必须为每个设备分配一个 0 到 7 的八个数字“地址”，其中地址 7 通常保留给主机控制卡。如果 SCSI 链中的两个设备有相同的地址，它们将无法正常工作。这使得将 SCSI 外设从一台计算机系统迁移到另一台系统时变得有些困难，因为被移动的设备的地址通常已被新系统中的另一个设备占用。

原始的 SCSI 总线也有其他限制。首先，它仅支持七个外设设备。当 SCSI 最初设计时，这通常不是问题，因为像硬盘和扫描仪这样的常见 SCSI 外设非常昂贵，每个售价数千美元。当时，连接超过七个设备并不是普通计算机用户的做法。然而，随着硬盘和其他 SCSI 外设价格的下降，七个外设的限制变得非常繁琐。

其次，SCSI 并不是*热插拔*的；也就是说，在通电状态下，你无法拔出或连接外部设备。这样做可能会导致 SCSI 控制器、外部设备，甚至 SCSI 总线上的其他外设受到电气损坏。随着 SCSI 外设变得更加经济实惠，人们开始将多个设备连接到计算机系统中，因此希望能够将一个设备从一个系统中拔出并插入到另一个系统中的需求也随之增加，但 SCSI 并不支持这一功能。

#### *13.1.2 改进*

尽管存在这些缺点，SCSI 的受欢迎程度依然不断增长。为了保持这种受欢迎程度，SCSI 随时间进行了修改，以提升其功能。第一版修改是 SCSI-2，它将速度从 5 MHz 提高到 10 MHz，从而使得总线的数据传输速率翻倍。这是必要的，因为像磁盘驱动器等高性能设备的速度提升迅速，原始的 SCSI 实际上使它们变慢。接下来，将双向 SCSI 数据总线的大小从 8 位扩展到 16 位，不仅将数据传输速率从 10MBps 提升到 20MBps，还增加了可以连接到总线的外设数量，从 7 个增加到 15 个。SCSI-2 的变体被称为*快速 SCSI*（10 MHz）、*宽 SCSI*（16 位）和*快速宽 SCSI*（16 位，10 MHz）。

不足为奇的是，SCSI-3 紧随 SCSI-2 之后。SCSI-3 提供了各种不同的连接选项，同时保持与旧标准的兼容性。虽然 SCSI-3（使用如 Ultra、Ultra-Wide、Ultra2、Wide Ultra2、Ultra3 和 Ultra320 等名称）仍然以并行电缆模式作为 16 位总线操作，并且仍然支持最多 15 个外设，但它大幅提高了总线的操作速度以及 SCSI 外设可连接的最大物理距离。简而言之，SCSI-3 以高达 160 MHz 的速度运行，使得 SCSI 总线能够以高达 320MBps 的速率进行数据传输（也就是说，比许多 PCI 总线互连还要快！）。

SCSI 最初是一个并行接口。如今，它支持四种不同的互连标准：SCSI 并行接口（SPI）、通过 FireWire 的串行 SCSI、光纤通道仲裁环路以及串行附加 SCSI（SAS）。SPI 是大多数人所熟知的原始标准，通常与 SCSI 联系在一起。SCSI 并行电缆包含 8 或 16 条数据线，具体取决于所使用的 SCSI 接口类型。这使得 SCSI 电缆笨重、沉重且昂贵。并行 SCSI 接口还限制了系统中 SCSI 链的最大长度，仅为几米。这些问题，特别是经济因素，是现代计算机系统仅在需要极高性能时才使用 SCSI 外设的原因。

请注意，计算机系统并不拥有 SCSI 总线，也不一定会直接控制总线上各种外设之间的通信。SCSI 是一个真正的*对等总线*，任何两个外设都可以相互通信。事实上，两个计算机系统共享同一条 SCSI 总线是可能的（尽管不常见）。

这种对等操作能够极大地提高整体系统的性能。为了说明这一点，考虑一个磁带备份系统。在实际应用中，大多数磁带备份程序将一个数据块从磁盘驱动器读取到计算机内存中，然后将该数据块从计算机内存写入磁带驱动器。理论上，在 SCSI 总线上，磁带驱动器和磁盘驱动器可以直接相互通信。磁带备份软件会发送两个命令，一个给磁盘驱动器，一个给磁带驱动器，指示磁盘驱动器将数据块直接传输到磁带驱动器，而不是通过计算机系统。这样不仅减少了 SCSI 总线上传输的次数，加快了传输速度，还释放了计算机 CPU 做其他事情。尽管实际上，少数磁带备份系统是这样工作的，但也有许多例子显示，两个外设可以在不通过计算机作为中介的情况下直接在 SCSI 总线上进行通信。将 SCSI 外设编程以这种方式操作（而不是通过计算机内存传输数据）是优秀编程的一个典型例子。

#### *13.1.3 SCSI 协议*

SCSI 不仅仅是一个电气连接，还是一个*协议*。你不会仅仅通过向 SCSI 接口卡上的几个寄存器写入一些数据，再将数据通过 SCSI 电缆发送到外部设备来与 SCSI 外设通信。相反，你会在内存中构建一个数据结构，其中包含 SCSI 命令、命令参数、你想发送到 SCSI 外设的任何数据，以及可能包含外设返回的数据存储位置的指针。一旦构建了这个数据结构，你通常会提供数据结构的地址给 SCSI 控制器，然后 SCSI 控制器从系统内存中获取命令，并将其发送到 SCSI 总线上适当的外设。

##### 13.1.3.1 SCSI 命令集

随着 SCSI 硬件多年来的发展，SCSI 协议也不断演进——

或者是 SCSI *命令集*。SCSI 最初并不是为了仅仅作为硬盘接口而设计，随着新型计算机外设的出现，它所支持的外设种类也在不断增加。为了适应这些新的、意料之外的 SCSI 总线用途，SCSI 的设计者创建了一个与设备无关的命令协议，使其能够在新设备发明时轻松扩展。与此相比，某些设备接口，如最初的集成磁盘电子技术（IDE）接口，仅适用于硬盘驱动器。

SCSI 协议传输一个包含外设地址、命令和命令数据的数据包。SCSI-3 标准大致将这些命令分为以下几类：

**SCSI 控制器命令（SCC）** RAID 阵列的控制命令

**SCSI 外壳服务（SES）命令** 外壳服务命令

**SCSI 图形命令（SGC）** 打印机的图形命令

**SCSI 块命令（SBC）** 硬盘接口命令

**管理服务器命令（MSC）** 用于 SCSI 协议之间转换的命令

**多媒体命令（MMC）** 用于 DVD 驱动器等设备的多媒体命令

**基于对象的存储设备（OSD）命令** 用于管理对象的分配、放置和访问的命令

**SCSI 主命令（SPC）** 主命令

**简化块命令（RBC）** 用于简化硬盘子系统的命令

**SCSI 流命令（SSC）** 用于磁带驱动器的流命令

尽管 SCSI 命令本身是标准化的，但实际的 SCSI 主机控制器接口却不是。不同的主机控制器制造商使用不同的硬件将其 SCSI 控制器芯片连接到主机计算机系统，因此与 SCSI 控制器芯片的交互方式取决于特定的主机控制器设备。由于 SCSI 控制器是*非常*复杂且难以编程的，而且没有“标准”的 SCSI 接口芯片，程序员面临着必须编写多个不同版本的软件来控制 SCSI 设备的问题。

##### 13.1.3.2 SCSI 设备驱动程序

为了纠正这种情况，像 Adaptec 这样的 SCSI 主机控制器制造商创建了专门的设备驱动模块，提供一个统一的接口给他们的设备。程序员不再直接向 SCSI 芯片写数据，而是创建一个内存中的数据结构，包含要放在 SCSI 总线上的 SCSI 命令，调用设备驱动程序软件，让设备驱动程序将 SCSI 命令传输到 SCSI 总线。这样做有几个好处：

+   它使程序员不必了解每个特定主机控制器的复杂性。

+   它允许不同制造商为其 SCSI 控制器设备提供兼容的接口。

+   它允许制造商创建一个单一的优化驱动程序，正确支持其设备的能力，而不是促使个别程序员为该设备编写（可能是平庸的）代码。

+   它允许制造商在不破坏与现有软件兼容性的情况下，改变其设备未来版本的硬件。

这一概念被引入了现代操作系统。今天，SCSI 主机控制器制造商为 Windows 等操作系统编写 *SCSI miniport 驱动程序*。这些 miniport 驱动程序为主机控制器提供了一个硬件无关的接口，使得操作系统可以简单地说：“这是一个 SCSI 命令，把它放到 SCSI 总线上。”

#### *13.1.4 SCSI 优势*

SCSI 接口的一个大优点是它提供了并行处理 SCSI 命令的功能。也就是说，主机系统可以将多个不同的 SCSI 命令放到总线上，多个外设可以同时处理这些命令。一些设备，如磁盘驱动器，甚至可以同时接受多个命令并按最有效的顺序处理它们。例如，假设一个磁盘驱动器当前接近 1,000 块。如果系统发送的块读取请求是块 5,000、4,560、3,000 和 8,000，磁盘控制器可以重新排列这些请求，并按最有效的顺序处理它们（可能是 3,000、4,560、5,000，然后是 8,000），在磁头穿过磁盘表面时完成读取操作。这会大大提高在多任务操作系统中处理来自多个不同应用程序的磁盘 I/O 请求的性能。

SCSI 也是 RAID 系统的理想接口，因为 SCSI 是为数不多的支持在同一接口上连接大量驱动器的磁盘控制器接口之一。

原始的 SPI（并行 SCSI）几乎已经消失。即便是通过 FireWire 的 SCSI 也几乎不存在了（FireWire 本身也是如此）。然而，今天 SCSI 仍然以 SAS（串行附加 SCSI）的形式存在。高性能硬盘驱动器使用 SAS 命令集（而非标准的 SATA 命令集）。目前性能最强的 RAID 系统仍然是基于 SAS 硬盘构建的。

SCSI 命令集非常强大，专为高性能应用设计。它足够庞大且复杂，空间限制使得无法在此详细介绍。有兴趣深入了解 SCSI 编程的读者应该参考**Gary Field、Peter M. Ridge 等人**编著的《SCSI 书籍》（第 2 版，No Starch Press，2000 年）。完整的 SCSI 规范可以在网上的多个网站上找到。快速搜索“ SCSI 规范”应该能找到多个副本。

### 13.2 IDE/ATA 接口

尽管 SCSI 性能非常高，但它也很昂贵。一个 SCSI 设备需要一个复杂且快速的处理器来处理 SCSI 总线上所有可能的操作。此外，由于 SCSI 设备可以在对等基础上运行（也就是说，一个外设可以在没有主机计算机系统干预的情况下与另一个外设通信），每个 SCSI 设备必须在其控制器板上的 ROM 中携带大量复杂的软件。如果仅仅是为了连接一块硬盘到个人计算机系统，而需要添加支持完整 SCSI 的所有额外功能，显然是过度设计。*集成驱动电子学（IDE）*接口的出现，旨在提供一种简化的、低成本的大容量存储选项。

IDE 接口的设计理念是通过利用主机计算机的 CPU 来处理数据，从而降低磁盘驱动器的成本（SCSI 使用嵌入式 CPU 处理大部分工作）。由于 PC 的 CPU 通常在 SCSI 传输过程中是空闲的，这似乎是资源的一个好利用。IDE 驱动器由于比 SCSI 驱动器便宜数百美元，因此在 PC 系统中变得非常流行。IDE 接口和 IDE 驱动器的成本远低于 SCSI，确保了其受欢迎程度。

由于原始的 IDE 规范专门针对硬盘驱动器设计，并不特别适合其他类型的存储设备，因此设计 IDE 接口的委员会重新开始工作，开发了*带数据包接口的高级技术附加（ATAPI）*，通常简称为*ATA*。像 SCSI 一样，ATA 标准在过去的几年中经过了多次修订和改进。ATAPI 规范（截至 2013 年第八版）扩展了 IDE，以支持包括磁带驱动器、Zip 驱动器、CD-ROM、DVD、可移动磁带驱动器等在内的各种大容量存储设备。为了扩展 IDE 接口以支持所有这些不同的存储设备，ATAPI 的设计者采用了一种数据包命令格式，这种格式在某些情况下与 SCSI 数据包命令格式非常相似，甚至相同。

然而，在现代受保护模式操作系统（如 Windows 或 Linux）中，应用程序员通常不允许直接与硬件进行通信。理论上，可以为 IDE 编写一个迷你端口驱动程序，模拟 SCSI 的工作方式。然而，在实际操作中，操作系统供应商通常会提供一个软件库，提供*应用程序编程接口（API）*，用于与 IDE/ATAPI 设备进行交互。然后，应用程序员可以调用 API 函数，传递适当的参数，底层的库函数会处理与硬件直接通信的其余任务。

在现代系统中编程 ATAPI 设备与编程 SCSI 设备非常相似。你需要加载一个基于内存的数据结构，其中包含一个命令码和一组参数，然后将这个内存结构传递给驱动程序库函数，该函数将数据传递到 ATAPI，并最终到达目标存储设备。如果没有这样的低级库，并且你的操作系统允许，你可以编程控制 ATAPI 设备来获取这些数据（现代系统通常使用 DMA）。

完整的 ATAPI 规范几乎有 500 页长，因此我们这里没有足够的空间来全面介绍。如果你有兴趣更详细地了解 IDE/ATAPI，可以在线搜索“ATAPI 规范”。

现代机器使用串行 ATA（SATA）控制器。这是经典 IDE/ATAPI 并行接口的高性能串行版本。然而，对程序员而言，它看起来与 ATAPI 完全相同。

#### *13.2.1 SATA 接口*

随着时间的推移，硬盘的速度逐渐足够快，以至于 IDE/ATA 接口开始限制驱动器性能。*串行 AT 附件 (SATA)* 以及后来出现的 SATA-II 和 SATA-III，相比于并行 IDE/ATA（通常缩写为 *PATA*，即“并行 ATA”），提供了几个优势。PATA 的传输速度最大为 133MBps，而 SATA-I、II 和 III 分别支持 1.5Gbps（即 150MBps）、3.0Gbps（即 300MBps）和 6.0Gbps（即 600MBps）的数据传输速率，尽管很少有（RAID）系统能接近达到这些数据传输速率。与 PATA 相比，SATA 还具有其他优势，包括更小的电缆（7 根导线，而不是 40 或 80 根）和热插拔功能。今天，大多数连接到 PC 的硬盘驱动器都使用 SATA 接口（而其他大部分则使用 SAS 接口，这实际上是通过 SATA 传输的 SCSI，或 Fibre Channel 接口）。

#### *13.2.2 Fibre Channel*

Fibre Channel 是一种非常高性能的传输机制（最高可达 128Gbps）。虽然它是一个通用的网络协议，适用于大型主机计算机，但它的主要用途之一是将高性能的磁盘阵列连接到计算机系统（通常是服务器）。对于磁盘驱动器的使用，Fibre Channel 通过 Fibre Channel 电缆传输 SCSI 命令。因此，1980 年代的 SCSI 接口在今天的 Fibre Channel 中得以延续，依然是最高性能的磁盘接口协议。

### 13.3 通用串行总线

*通用串行总线 (USB)* 是一种机制，允许你通过一个接口将各种外设连接到 PC，类似于 SCSI。USB 支持 *热插拔设备*，意味着你可以在不关闭电源或重启计算机的情况下插拔设备，它还支持 *即插即用设备*，这意味着一旦插入设备，操作系统会自动加载设备驱动程序（如果有的话）。然而，这种灵活性是有代价的。与串行或并行端口的编程相比，USB 设备的编程要复杂得多。你不能通过读取或写入少量设备寄存器与 USB 外设进行通信。

#### *13.3.1 USB 设计*

为了理解 USB 背后的动机，可以考虑当 Windows 95 首次发布时，PC 用户所面临的情况，那时距 IBM PC 的推出已经近 14 年。IBM 设计其 PC 时，采用了多种外设连接方式，这些连接方式在 1970 年代后期的个人计算机和小型计算机中都很常见。然而，IBM 的设计人员并未预见（或考虑到）人们在接下来的几十年中会发明出如此多种类的外设来连接到 PC。它们也没有预计任何个别 PC 用户会将超过几个外设连接到他们的计算机上。当然，三条并行端口、四条串行端口和一个硬盘驱动器应该足够了！

当 Windows 95 推出时，人们已经开始将他们的 PC 连接到各种各样的设备，包括声卡、视频数字化器、数码相机、先进的游戏设备、扫描仪、电话、鼠标、数位板、SCSI 设备以及数百种原始 PC 设计者未曾想象过的其他设备。这些设备的创建者通过将硬件与 PC 进行连接，使用了原本为其他设备设计的外设 I/O 端口地址、中断和 DMA 通道。这样做的问题是端口地址、中断和 DMA 通道的数量有限，而大量设备却在争夺它们。为了绕过这一问题，设备制造商在他们的卡上添加了“跳线”，使购买者可以从一小部分不同的端口地址、中断和 DMA 通道中进行选择，以避免与其他设备的冲突。

创建一个无冲突的系统是一个复杂的过程，而且在某些外设组合的情况下是无法实现的。事实上，在这一时期，Apple Macintosh 的一个重要卖点就是你可以轻松连接多个外设设备，而无需担心设备冲突。所需要的是一种新的外设连接系统，它能在不产生冲突的情况下支持大量设备。USB 就是这个答案。

USB 通过使用 7 位地址，允许最多同时连接 127 个设备。USB 保留了第 128 个槽位，即地址 0，用于自动配置目的。在现实中，几乎不可能将这么多设备成功连接到单一 PC，但可以知道 USB 具有相当大的增长潜力，这一点与原始的 PC 不同。

尽管名称中有“总线”一词，但 USB 并不是一种真正的“总线”，因为它并不允许多个设备彼此通信。相反，USB 是一种控制器/外设连接，其中 PC 始终充当控制器。这意味着，例如，数字相机不能直接通过 USB 与打印机通信。为了将信息从相机传输到打印机，这两个设备都需要连接到 PC，相机必须先将数据发送到 PC，然后 PC 再将数据传递给打印机。PCIe、ISA、FireWire（IEEE 1394）和 Thunderbolt 总线允许两个设备进行点对点通信（即独立于主机的 CPU），但 USB 并没有设计成支持这种通信方式（为了降低外设和其包含的 USB 接口芯片的成本）。^(1)

USB 还通过将尽可能多的复杂性转移到主机（PC）端来降低外设成本。这里的思路是，PC 的 CPU 提供的性能远高于大多数 USB 外设中使用的低成本微控制器。这意味着为 USB 外设编写嵌入式软件的工作量并不会比使用其他接口更多。另一方面，在主机端编写 USB 软件则非常复杂——复杂到实际上不可能期望程序员能够完成。

相反，操作系统供应商必须提供一个 USB 主机控制器*堆栈*，使其能够与 USB 设备进行通信，大多数应用程序开发人员通过操作系统的设备驱动接口与这些设备进行交互。即使是需要为特定设备编写自定义 USB 设备驱动程序的开发人员，也不会直接与 USB 硬件进行交互。相反，他们会通过操作系统调用 USB 主机控制器堆栈，向其请求特定设备的服务。由于典型的 USB 主机控制器堆栈通常包含大约 20,000 到 50,000 行 C 代码，并且需要几年时间的开发，因此在没有原生 USB 堆栈（如 MS-DOS）的系统上编写 USB 设备程序的机会非常小。

#### *13.3.2 USB 性能*

初始的 USB 设计支持两种不同类型的外设——

慢速和快速——以支持不同价格区间的设备。慢速设备在 USB 上传输速度最高可达 1.5Mbps（每秒百万比特），而快速设备则能够达到 12Mbps（1.5MBps）的传输速度。成本敏感型设备可以以低成本制造为低速设备。非成本敏感型设备则可以使用 12Mbps 的数据传输速率。

USB 2.0 规范增加了一个高速模式，支持最高 480Mbps 的数据传输速率（60MBps），但这也带来了额外的复杂性和成本。USB 3.0 提高了性能，达到了 635MBps（超级速度）。最后，USB 3.1 和 USB-C（Thunderbolt 3）接口分别将速度提升到了 5GBps（每秒千兆字节；超级速度）、10GBps（超级速度+）和 40GBps。预计 USB 4.0 能够达到 80GBps 的传输速度。

USB 不会将整个可用带宽分配给一个外设，而是主控制器堆栈对 USB 上的数据进行*复用*，有效地给每个外设一个总线的“时间片”。USB 使用 1 毫秒时钟。在每个毫秒周期的开始，USB 主控制器开始一个新的 USB *帧*，在一个帧内，每个外设可以发送或接收一个数据包。数据包的大小会有所不同，取决于设备的速度和传输时间，但通常包含 4 到 64 字节的数据。如果你在四个外设之间以相等的速率传输数据，通常会期望 USB 堆栈以*轮询*的方式在主机和每个外设之间传输一个数据包，首先处理第一个外设，其次是第二个外设，依此类推。就像多任务操作系统中的时间切片一样，这种数据传输机制使得看起来像是主机和每个 USB 外设之间并发地传输数据，尽管实际上每次只能有一个传输在 USB 上进行。

尽管 USB 提供了一个非常灵活和可扩展的系统，但由于总线上共享带宽，可能会导致设备的速度变慢。例如，如果你将两个硬盘驱动器连接到 USB 并同时访问这两个驱动器，这两个驱动器必须共享 USB 上的可用带宽。对于 USB 1.*x* 设备，这会导致明显的速度下降。对于 USB 2.*x* 设备，可用带宽足够高（通常高于两个硬盘驱动器所能支持的带宽），因此你不会注意到性能下降。对于 USB 3.*x*（及更高版本）和 USB-C，性能与许多原生总线控制器相当。（例如，Thunderbolt-3/USB-C 提供了一个传输机制，用于 PCI 总线和 SCSI。）理论上，你可以使用多个主控制器来提供多个 USB 总线系统（每个总线提供完整的带宽），但这仅仅解决了性能问题的一部分。

另一个性能考虑因素是 USB 主控制器堆栈的开销。尽管 USB 1.*x* 硬件可能支持 12Mbps 带宽，但存在一些空闲时间——也就是没有数据传输的时间——因为主控制器堆栈需要一些时间来设置数据传输。在一些 USB 系统中，由于主控制器堆栈占用了大量的 CPU 时间来设置传输和移动数据，最多只能达到*理论 USB 带宽的一半*。在一些使用较慢处理器（如 486、StrongArm 或 MIPS）运行嵌入式 USB 1.*x* 主控制器设备的嵌入式系统中，这可能是一个实际问题。

如果某个主机控制器堆栈无法维持完整的 USB 带宽，通常意味着 CPU 处理 USB 信息的速度赶不上 USB 产生信息的速度，因为 CPU 的处理能力已经饱和——并且没有时间进行其他计算。请记住，USB 将所有复杂的计算留给主机控制器来处理，并且在主机上执行 USB 堆栈中的代码需要占用 CPU 周期。主机控制器可能会因为处理 USB 流量而过度占用资源，以至于导致非 USB 流量的整体系统性能下降。

幸运的是，在配备 USB 2.*x*控制器的 PC 上，主机控制器只消耗了 USB 带宽的一小部分。当 USB-3 和 USB-C 出现时，USB 硬件开始支持其他传输协议，如 SCSI 和 PCI，从而解决了许多与 USB 相关的性能问题。

#### *13.3.3 USB 传输类型*

USB 协议支持四种不同类型的数据传输：控制传输、批量传输、中断传输和等时传输。数据传输机制由外设制造商决定，而不是由应用程序员决定，即，如果一个设备使用等时数据传输模式与主机 PC 通信，程序员无法决定改为使用批量传输。应用程序可能甚至不会意识到底层的传输方案，只要软件能够处理设备产生或消耗数据的速率。

USB 通常使用*控制*传输来初始化外设设备，通过读取和写入数据到外设的寄存器。例如，如果你有一个 USB 转串口转换器设备，你通常会使用控制传输来设置波特率、数据位数、奇偶校验位、停止位数等，就像你将数据存储到 8250SCC 寄存器集一样。^(2) USB 保证控制传输的正确传递，并且保证至少 10%的 USB 带宽用于控制传输，以防止*饥饿*现象，即某个特定的传输永远不会发生，因为某些优先级更高的传输始终在进行。

USB 的*大容量*传输用于在主机和外设之间传输大量数据块。大容量传输仅在全速（12Mbps）、高速（480Mbps）和超高速（USB 3/USB-C）设备上可用，低速设备不支持此功能。在全速设备上，大容量传输通常每个数据包传输 4 到 64 字节的数据；在高速和超高速设备上，你可以每个数据包传输最多 1,023 字节的数据。USB 保证大容量数据包在主机和外设之间的正确传输，但不保证及时传输。如果 USB 正在处理大量其他传输，完成大容量传输可能需要一些时间。理论上，如果 USB 在正确组合的等时、interrupt 和控制传输下非常繁忙，大容量传输可能永远不会发生。然而，在实际操作中，大多数 USB 堆栈确实会为大容量传输预留一小部分带宽（通常约为 2 到 2.5%），以防止带宽“饿死”。

USB 旨在通过设备传输大量数据，这些设备需要正确地传输数据，但不一定要求快速。例如，当你将数据传输到打印机或在计算机和磁盘驱动器之间传输数据时，正确的传输远比及时传输更为重要。当然，等待似乎无尽的时间来保存文件到 USB 磁盘驱动器可能会让人觉得烦人，但比起将错误数据写入磁盘文件，缓慢操作要好得多。

对于那些既需要正确数据传输又要求及时交付的设备，USB 使用*中断*传输。尽管名称中有“中断”二字，但中断传输并不涉及计算机系统中的中断。相反，USB 协议将中断传输标记为高优先级事件。主机会轮询 USB 上的所有设备，但当设备有数据可用时，不会中断主机。使用中断传输类型的外设可以请求主机轮询它的频率，选择从 1 毫秒到 255 毫秒的间隔。^(3)

为了保证中断传输在主机和外设之间的正确和及时交付，USB 主机控制器堆栈必须在每次应用程序打开设备进行中断传输时预留一部分 USB 带宽。例如，如果某个特定设备希望每毫秒得到服务，并且每个数据包需要传输 16 字节数据，USB 主机控制器堆栈必须从总带宽中预留超过 128Kbps（千比特每秒）的带宽（16 字节 × 8 位每字节 × 1,000 个数据包每秒）。你需要预留稍多一点带宽，因为总线上还有一些协议开销——至少 10 到 20%，但根据 USB 堆栈的编写方式，可能还会更多。

由于 USB 带宽有限，并且每当你打开设备使用时，中断传输会消耗一定的带宽，因此在任何时候不能有任意数量的中断传输同时激活。一旦 USB 带宽（减去 USB 保留的 10%用于控制传输）被消耗完，堆栈就会拒绝激活任何新的中断传输。

中断传输的数据包大小在 4 到 64 字节之间，尽管大多数情况下它们都在这个范围的低端。较大的数据包会阻止系统保证所需的轮询频率。

许多设备使用中断传输来通知主机 CPU 有数据可用，然后主机使用大容量传输来实际读取设备中的数据。如果主机与外设之间需要传输的数据量足够小，外设可以将数据作为中断数据负载的一部分进行传输，以避免第二次传输。键盘、鼠标、操纵杆和类似设备通常以这种方式传输数据。磁盘驱动器、扫描仪和其他类似设备使用中断传输通知主机数据可用，然后使用大容量传输来移动数据。

*等时*（或*iso*）传输是 USB 支持的第四种传输类型。像中断传输一样，iso 传输需要及时传输。像大容量传输一样，它们通常涉及更大的数据包。然而，与其他三种传输类型不同，iso 传输不能保证主机与外设设备之间的正确传输。及时传输对于 iso 传输非常重要，以至于如果数据包延迟到达，它就可能完全无法到达。外设设备如音频输入（麦克风）、输出（扬声器）以及摄像头使用 iso 传输。如果丢失数据包，或者数据包在外设与主机之间传输错误，你可能会在视频显示或音频信号中看到短暂的卡顿，但只要这种问题不是频繁发生，就不会造成灾难性后果。

与中断传输类似，iso 传输也会消耗 USB 带宽。每当你打开与 iso USB 外设设备的连接时，该设备会请求一定的带宽。如果带宽可用，USB 主机控制器堆栈会为该设备保留带宽，直到应用程序使用完该设备。如果没有足够的带宽，USB 堆栈会通知应用程序，告知它在用户停止使用其他 iso 和中断设备，释放一些带宽之前无法使用所需的设备。

#### *13.3.4 USB-C*

USB 最初与 FireWire 竞争，争夺外围设备开发者的关注。最初，FireWire 是一个性能更高的接口和协议。然而，随着 USB-2 的出现，尤其是 USB-3 的推出，FireWire 的吸引力逐渐减弱。在这段时间里，Apple 与 Intel 合作开发了一种新的外部外围设备总线协议——Thunderbolt。Thunderbolt 在性能上完全超过了 USB。竞赛再次开始，这一次是在 USB 和 Thunderbolt 之间。然而，Intel（同时推广 USB 和 Thunderbolt）决定将这两个标准合并成一个：USB-C。USB-C 实际上是一个 Thunderbolt 3 硬件接口，它携带 USB、PCI、SCSI 以及其他协议通过串行总线传输。现在，你不必做出选择——USB-C（或 Thunderbolt-3）已经成为首选接口。

#### *13.3.5 USB 设备驱动程序*

大多数提供 USB 堆栈的操作系统都支持 USB 设备驱动程序的动态加载和卸载，这在 USB 术语中称为*客户端驱动程序*。每当你将 USB 设备连接到 USB 时，主机系统会收到一个信号，告知其*总线拓扑*已发生变化（即，USB 上有了一个新设备）。主机控制器会扫描新设备，这是一个被称为*枚举*的过程，然后从外设读取一些配置信息。除此之外，这些配置信息会告诉 USB 堆栈设备的类型、制造商和型号等信息。USB 主机堆栈使用这些信息来确定加载哪个设备驱动程序到内存中。如果 USB 堆栈找不到合适的驱动程序，它通常会弹出一个对话框，要求用户提供帮助；如果用户无法提供适当驱动程序的路径，系统就会忽略新设备。同样地，当用户拔掉设备时，如果该驱动程序没有用于其他设备，USB 堆栈会从内存中卸载相应的设备驱动程序。

为了简化许多常见设备（如键盘、磁盘驱动器、鼠标和游戏杆）的设备驱动程序实现，USB 标准定义了某些设备类。创建符合这些标准化设备类的外围设备制造商无需为其设备提供驱动程序。相反，USB 主机控制器堆栈中附带的类驱动程序提供了所需的唯一接口。类驱动程序的例子包括 HID（人机接口设备，如键盘、鼠标和游戏杆）、STORAGE（磁盘、CD 和磁带驱动器）、COMMUNICATIONS（调制解调器和串行转换器）、AUDIO（扬声器、麦克风和电话设备）和 PRINTERS（打印机）。外围设备制造商可以选择提供自己的专有功能，为其产品增添附加功能，但客户通常只需通过插入设备，无需专门安装驱动程序，就能通过现有的类驱动程序获得基本功能。

### 13.4 获取更多信息

Axelson, Jan. *USB 完整指南：开发者手册*。第 4 版。威斯康星州麦迪逊：Lakeview 出版社，2009 年。

Field, Gary, Peter M. Ridge 等. *SCSI 手册*。第 2 版。旧金山：No Starch Press，2000 年。

**注意**

*对于 USB、FireWire 和 TCP/IP（网络）协议栈，您可以在网上找到大量的信息。例如，* [`www.usb.org/`](http://www.usb.org/) *包含了 USB 协议的所有技术规格以及各种常见 USB 主控制器芯片组的编程信息。您还可以找到大量的在线代码资源，例如 Linux 中完整的 TCP/IP 和 USB 主控制器栈源代码。*
