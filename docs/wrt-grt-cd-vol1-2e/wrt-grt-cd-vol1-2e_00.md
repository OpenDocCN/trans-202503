# 第一章：编写伟大代码所需了解的知识**

![Image](img/comm1.jpg)

*写出伟大代码（WGC）*系列将教你如何编写你可以自豪的代码；那些会让其他程序员印象深刻、让客户满意、并受用户欢迎的代码；那些客户、你的老板等不会介意支付高价购买的代码。通常，*【WGC】(gloss01.xhtml#gloss01_262)* 系列中的书籍将讨论如何编写能达到传奇地位的软件，赢得其他程序员的敬畏与钦佩。

### 1.1 写出伟大代码系列

*写出伟大代码，第 1 卷：理解机器*（以下简称*【WGC1】(gloss01.xhtml#gloss01_263)*）是*【WGC】(gloss01.xhtml#gloss01_262)* 系列中的第一本书。编写伟大代码需要知识、经验和技能的结合，而程序员通常只有在经过多年的错误与发现后，才能获得这些。这个系列的目的是与新手和有经验的程序员分享几几十年的观察和经验。我希望这些书能够帮助减少学习“吃苦头”的时间和挫折。

本书，*【WGC1】(gloss01.xhtml#gloss01_263)*，填补了在典型计算机科学或工程课程中常常被忽略的低层次细节。这些细节是许多问题解决方案的基础，没有这些信息，你无法编写高效的代码。虽然我尽力使每本书独立成章，*【WGC1】(gloss01.xhtml#gloss01_263)* 可能被视为后续系列卷的先决条件。

*写出伟大代码，第 2 卷：低级思维，高级编程*（*【WGC2】(gloss01.xhtml#gloss01_264)*）立即应用本书中的知识。*【WGC2】(gloss01.xhtml#gloss01_264)* 将教你如何分析用高级语言编写的代码，以确定编译器为其生成的机器代码的质量。优化编译器并不总是生成最好的机器代码——你在源代码文件中选择的语句和数据结构会对编译器输出的效率产生很大影响。*【WGC2】(gloss01.xhtml#gloss01_264)* 将教你如何编写高效的代码，而无需使用汇编语言。

伟大代码的属性不仅仅是效率，系列中的第三本书，*写出伟大代码，第 3 卷：工程化软件*（*【WGC3】(gloss01.xhtml#gloss01_265)*），将涵盖其中一些内容。*【WGC3】(gloss01.xhtml#gloss01_265)* 将讨论软件开发的隐喻、开发方法论、开发人员类型、系统文档以及统一建模语言（UML）。*【WGC3】(gloss01.xhtml#gloss01_265)* 为个人软件工程奠定了基础。

优秀的代码始于优秀的设计。*《编写伟大代码，第 4 卷：设计伟大代码》* (*WGC4*) 将描述分析和设计的过程（包括结构化和面向对象设计）。* WGC4 * 将教你如何将初步概念转化为工作中的软件系统设计。

*《编写伟大代码，第 5 卷：伟大的编码》* (*WGC5*) 将教你如何创建其他人可以轻松阅读和维护的源代码，以及如何在没有许多软件工程书籍所讨论的“繁琐工作”负担的情况下，提高生产力。

优秀的代码*有效*。因此，我不能不包括一本关于测试、调试和质量保证的书。很少有程序员能够正确地测试他们的代码。这通常不是因为他们觉得测试无聊或不值得做，而是因为他们不知道*如何*测试他们的程序、消除缺陷并确保代码质量。为了帮助克服这个问题，*《编写伟大代码，第 6 卷：测试、调试和质量保证》* (*WGC6*) 将描述如何高效地测试你的应用程序，而不需要那些工程师通常与此任务相关的繁琐工作。

### 1.2 本书涵盖的内容

为了编写优秀的代码，你需要知道如何编写高效的代码，而要编写高效的代码，你必须理解计算机系统如何执行程序以及编程语言中的抽象如何映射到机器的低级硬件能力。

过去，学习伟大的编码技术需要学习汇编语言。虽然这不是一种不好的方法，但它有些过度。学习汇编语言涉及学习两个相关的主题：机器组织和汇编语言编程。学习汇编语言的真正好处来自于机器组织部分。因此，本书仅关注机器组织部分，让你在不需要学习汇编语言的情况下，能够编写出优秀的代码。

机器组织是计算机体系结构的一个子集，涉及低级数据类型、内部 CPU 组织、内存组织和访问、低级机器操作、大容量存储组织、外设以及计算机如何与外部世界通信。本书专注于计算机体系结构和机器组织中那些对程序员可见或有助于理解系统架构师选择特定系统设计原因的部分。学习机器组织以及本书的目标，并不是让你设计自己的 CPU 或计算机系统，而是让你能够高效利用现有的计算机设计。接下来，我们将快速浏览一下我们将要涵盖的具体主题。

第二章、4 章和 5 章处理了计算机数据表示的基础——计算机如何表示有符号和无符号整数值、字符、字符串、字符集、实数值、分数值以及其他数值和非数值量。如果没有扎实地掌握计算机如何在内部表示这些不同的数据类型，理解为什么某些操作效率低下将会非常困难。

第三章讨论了二进制算术和大多数现代计算机系统使用的位操作。它还提供了若干见解，教你如何通过以通常在初学编程课程中不教授的方式使用算术和逻辑操作来编写更好的代码。学习这些标准的“技巧”是成为一名优秀程序员的过程之一。

第六章介绍了内存，讨论了计算机如何访问内存，并描述了内存性能的特点。本章还涵盖了各种机器码*【寻址模式】(gloss01.xhtml#gloss01_8)*，这些模式是 CPU 用来访问内存中不同类型数据结构的。在现代应用中，性能不佳往往是因为程序员未意识到内存访问的后果，从而在程序中制造了瓶颈。第六章解决了许多这些问题。

第七章回到数据类型和表示，讨论了复合数据类型和内存对象：指针、数组、记录、结构和联合。程序员往往使用大型复合数据结构，而没有考虑到这样做的内存和性能影响。这些高级复合数据类型的低级描述将清楚地说明它们的固有成本，让你能够明智而节制地使用它们。

第八章讨论了布尔逻辑和数字设计。本章提供了理解 CPU 及其他计算机系统组件设计所需的数学和逻辑背景。特别地，本章讨论了如何优化布尔表达式，例如常见高级编程语言中的`if`和`while`语句。

延续第八章的硬件讨论，第九章讨论了 CPU 架构。如果你想写出高效的代码，基本理解 CPU 的设计和运行原理是必不可少的。通过以符合 CPU 执行方式的方式编写代码，你将能够在使用更少系统资源的情况下获得更好的性能。

第十章讨论了 CPU 指令集架构。机器指令是任何 CPU 执行的基本单元，程序执行的持续时间直接由 CPU 必须处理的机器指令的数量和类型决定。学习计算机架构师如何设计机器指令可以为你提供有价值的见解，帮助理解为什么某些操作比其他操作执行得更慢。一旦你理解了机器指令的局限性以及 CPU 如何解读这些指令，你就可以利用这些信息将普通的代码序列转化为优秀的代码。

第十一章回到了内存的话题，介绍了内存架构和组织。对于任何希望编写快速代码的人来说，这一章尤其重要。本章描述了内存层次结构，以及如何最大化缓存和其他高速内存组件的使用。你将学习到抖动问题以及如何避免在应用程序中发生低效的内存访问。

第十二章至第十五章描述了计算机系统如何与外部世界进行通信。许多外围设备（输入/输出设备）的操作速度远低于 CPU 和内存。你可以编写出最快执行的指令序列，但你的应用程序仍然运行缓慢，因为你没有理解系统中 I/O 设备的局限性。这四章讨论了通用 I/O 端口、系统总线、缓冲、握手、轮询和中断。它们还解释了如何高效使用许多流行的 PC 外围设备，包括键盘、并行（打印机）端口、串行端口、磁盘驱动器、磁带驱动器、闪存、SCSI、IDE/ATA、USB 和声卡。

### 1.3 本书假设的前提

本书是基于一些关于你先前知识的假设而写的。如果你的技能与以下内容相符，你将从本书中获得最大收益：

+   你应该在至少一种现代编程语言中具有合理的能力。这包括 C/C++、C#、Java、Swift、Python、Pascal/Delphi（对象 Pascal）、BASIC 和汇编语言，以及像 Ada、Modula-2 和 FORTRAN 等语言。

+   给定一个小问题描述，你应该能够通过设计和实现软件解决方案来解决该问题。一门典型的大学或学院的学期或季度课程（或几个月的自学经验）应该为你提供足够的背景知识来阅读本书。

与此同时，本书并不特定于某种语言；其概念超越了你所使用的编程语言。此外，本书并不假设你使用或了解任何特定的语言。为了让示例更易于理解，编程示例轮流使用几种不同的语言。本书详细解释了示例代码的操作方式，即使你不熟悉特定的编程语言，通过阅读附带的描述，你也能理解它的操作。

本书在不同的示例中使用了以下语言和编译器：

+   C/C++：GCC，微软的 Visual C++

+   Pascal：Embarcadero 的 Delphi，Free Pascal

+   汇编语言：微软的 MASM、HLA（高级汇编语言）、Gas（Gnu 汇编器；在 PowerPC 和 ARM 上使用）

+   Swift 5（苹果）

+   Java（v6 或更高版本）

+   BASIC：微软的 Visual Basic

通常，示例会以多种语言出现，因此如果你不理解某种语言的语法，通常可以忽略特定示例。

### 1.4 伟大代码的特征

不同的程序员对伟大代码有不同的定义，因此不可能提供一个能满足所有人需求的全面定义。然而，几乎每个人都会同意，伟大的代码：

+   高效使用 CPU（也就是说，它很快）

+   高效使用内存（也就是说，它很小）

+   高效使用系统资源

+   容易阅读和维护

+   遵循一致的风格指南

+   使用遵循已建立的软件工程规范的明确设计

+   容易扩展

+   经过充分测试且稳健（也就是说，它能正常工作）

+   有良好的文档记录

我们可以轻松地向这个列表中添加几十个条目。例如，一些程序员可能认为，伟大的代码必须是可移植的，必须遵循特定的编程风格指南，或者必须使用某种语言编写（或者*不能*使用某种语言编写）。一些人可能认为伟大的代码必须尽可能简单地编写，而另一些人则认为它必须迅速编写。还有一些人可能认为，伟大的代码是在按时并且不超预算的情况下创建的。

本书使用的定义如下：

伟大的代码是通过使用一套一致且优先级明确的良好软件特性来编写的软件。特别是，伟大的代码遵循一套规则，指导程序员在将算法实现为源代码时做出决策。

两个不同的程序不必遵循相同的规则（也就是说，它们不需要具备相同的特性）才能被认为是伟大的。在某些环境下，优先考虑的是编写可在不同 CPU 和操作系统之间移植的代码。而在另一些环境下，效率（速度）可能是首要目标，移植性则不那么重要。根据另一个环境的规则，这两个程序都无法被认为是伟大的，但只要软件始终遵循为该特定程序制定的指南，就可以认为它是伟大代码的一个例子。

### 1.5 本书的环境

尽管本书呈现的是通用信息，但部分讨论必然会涉及到特定系统的内容。由于 Intel 架构的 PC 目前仍是使用最广泛的，因此本书在讨论特定系统依赖的概念时将使用该平台。

本书中的大多数具体示例在现代的 Intel 架构（包括 AMD）CPU 上运行，操作系统包括 macOS、Windows 或 Linux，并且具有合理数量的 RAM 和现代 PC 通常配备的其他系统外设。本书尽量使用标准库接口与操作系统（OS）交互，只有在替代方案会导致写出“不太优秀”的代码时，才会进行操作系统特定的调用。虽然软件可能不完全适用，但这些概念将适用于 Android、Chrome、iOS、Mac、Unix 系统、嵌入式系统，甚至大型机，尽管你可能需要研究如何将概念应用到你的平台上。

### 1.6 额外提示

没有一本书可以完全覆盖你写出优秀代码所需要知道的所有内容。因此，本书集中在与机器组织最相关的领域，为那些希望编写最优代码的人提供 90%的解决方案。要获得最后的 10%，你将需要额外的帮助。以下是一些建议：

**学习汇编语言。**至少精通一门汇编语言将填补你仅通过学习机器组织无法获得的许多细节。除非你计划在你的软件系统中使用汇编语言，否则不必在你为其编写软件的平台上学习它。你最好的选择可能是在 PC 上学习 80x86 汇编语言，因为有许多优秀的软件工具可以帮助你学习 Intel 架构汇编语言（例如 HLA），这些工具在其他平台上并不存在。这里学习汇编语言的目的不是编写汇编代码，而是学习汇编的思维方式。如果你了解 80x86 汇编语言，你将对其他 CPU（如 ARM 或 IA-64 系列）如何工作有一个很好的了解。

**学习高级计算机架构。**机器组织是计算机架构的一个子集，但由于篇幅限制，本书未能全面覆盖这两者。虽然你可能不需要了解如何设计自己的 CPU，但学习计算机架构可能会教你一些这里没有涉及的内容。

### 1.7 更多信息

亨内西，约翰·L 和大卫·A·帕特森。*《计算机架构：量化方法》*（第 5 版）。马萨诸塞州沃尔瑟姆：摩根·考夫曼，2012 年。

海德，兰道尔。*《汇编语言的艺术》*（第 2 版）。旧金山：No Starch Press，2010 年。
