## 第十一章：## 显示生日

![](img/Image00001.jpg)

是时候展示那些生日了！在第十章中，你创建了 Add Birthday 视图控制器，以便你可以使用 Birthday 类将新的生日对象添加到你的应用中。在这一章中，你将创建一个 Birthdays 表格视图控制器，它可以在*表格视图*中显示你添加的生日。表格视图展示了一个可以滚动并选择的项列表。接着，你将学习如何让 Add Birthday 视图控制器在添加 Birthday 对象时通知 Birthdays 表格视图控制器，这样新生日就能显示在表格视图中。

### 制作生日列表

添加生日是一回事，但你还想展示生日列表。为此，你需要创建另一个类，BirthdaysTableViewController，它将继承 UITableViewController，这是一个具有表格视图的特殊视图控制器。UITableViewController 包含多个内置方法，允许你编写代码来设置表格视图应有多少行，以及每行显示什么内容。我们希望行数与生日的数量相同，并且每一行显示一个生日。

#### 创建生日表格视图控制器

在项目导航器中按住控制键点击*BirthdayTracker*文件夹，然后从菜单中选择**新建文件...**。在第十章中，我们创建了 Swift 文件*Birthday.swift*，Xcode 为我们准备了一个几乎没有内容的文件。这次创建新文件时，我们会告诉 Xcode，我们要继承一个现有的 iOS 类。根据基类，Xcode 会创建一个包含一些代码的文件，你可以根据需要定制这些代码。要创建文件，请在窗口顶部选择**iOS**，然后选择**Cocoa Touch Class**模板，它会自动格式化新类文件（见图 11-1）。

![](img/Image00234.jpg)

*图 11-1：要继承现有类，选择* ***iOS*** *然后选择* ***Cocoa Touch Class.***

当你选择这个选项时，你会看到一个第二个对话框，在这里你可以命名你的新类并指定你将要继承的类。首先，在子类字段（对话框中的第二个字段）中，输入 UITableViewController。这将自动填充类字段，并显示子类的名称。完成后，在 TableViewController 前面输入 Birthdays，使整个类名变为 BirthdaysTableViewController。这样做是一个快捷方式，你就不需要输入那么多内容。确保在语言下拉菜单中选择**Swift**，然后点击**下一步**。然后在最后一个对话框中选择**创建**，以创建你的新文件。

在*BirthdaysTableViewController.swift*中，Xcode 提供了一个包含多个注释掉的方法的模板。你可以通过删除我们不会使用的方法来清理代码。仅删除 viewDidLoad()中的注释，然后删除整个 didReceiveMemoryWarning()方法和与表视图行移动相关的方法 tableView(_:moveRowAt:to:)和 tableView(_:canMoveRowAt:)，这几个方法与你要移动表格中的行有关。完成后，BirthdaysTableViewController 的内容应如下图 11-2 所示。仍然有几个被注释掉的方法，但我们保留它们以便稍后使用！

![](img/Image00235.jpg)

*图 11-2：已清理的* BirthdaysTableViewController *

接下来，你需要将“Birthdays”表视图控制器设置为 BirthdaysTableViewController 类。为此，打开*Main.storyboard*并选择**Birthdays**场景。在右侧窗格中的身份检查器里，将类从 UITableViewController 更改为 BirthdaysTableViewController，如图 11-3 所示。

![](img/Image00236.jpg)

*图 11-3：将* BirthdaysTableViewController *设置为 Birthdays 场景的类*

现在你已经在故事板中设置好了“Birthdays”表视图控制器，下一步是创建你的表格中的单元格，用来显示每个生日。

#### 向表视图添加单元格

每个生日将在“Birthdays”表视图控制器中的 UITableViewCell 中显示。表格有按行和列组织的框，这些框包含信息。这些框被称为*单元格*。类似地，表视图也有单元格，这些单元格都是 UITableViewCell 类或其子类的实例。我们将把每个生日放入表视图中的单独单元格。

我们将从在故事板中创建这些单元格开始，然后稍后将它们填充为我们的生日对象。在左侧大纲菜单中，点击“Birthdays”旁的三角形，然后点击“Table View”旁的三角形以展开这些部分。然后选择**Table View Cell** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建一个 Subtitle 样式的表视图单元格并设置其标识符*

接下来，打开属性检查器。在**Style**下拉菜单中，将单元格的样式设置为**Subtitle** ➋，这样单元格就会有标题标签和副标题标签。你将把每个人的名字显示在标题中，生日显示在副标题中。

最后，在标识符字段➌中输入 birthdayCellIdentifier。稍后你将在填充单元格内容时使用这个标识符。

就这样！你已经完成了在故事板中的工作。

你可能会想，为什么我们在故事板中的表格视图中只有一个单元格，而实际上我们有多个生日需要显示。如果你再次查看图 11-4，你会注意到该单元格被标记为 *原型单元格*。这意味着你刚刚自定义的单元格是你想要在表格视图中显示的所有单元格的 *模板*。你给单元格的标识符将告诉你的代码如何让表格视图为你生成每一个单元格，用来显示生日。你将很快看到这一点是如何工作的。

**处理日期**

Swift 有一种特殊的数据类型叫做 Date，用于存储日期值。一个 Date 对象实际上是一个日期和时间。打开你的 playground，并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量 today。当你打印 today 时，它的格式是 "2017-11-21 10:45:31 +0000\n"。如果你希望它显示为 "Tuesday, November 21, 2017" 呢？或者只是 "11/21/17"？要以特定的方式显示日期，你需要使用 *日期格式化器*，即一个你创建的 DateFormatter 对象，并给它一个日期格式样式。DateFormatter 是一个辅助对象，用于从任何日期创建显示字符串，*日期格式样式* 是 DateFormatter 的一个属性，告诉格式化器使用什么样式。你可以手动创建自己的日期格式样式，但 Swift 中也包含了可供使用的样式。将以下代码添加到你的 playground 中：

![](img/Image00240.jpg)

在 ➊ 处，你创建了一个格式化器。然后在 ➋ 处，你将格式化器的样式设置为 Style.full，这样可以打印出星期几、完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:) 方法 ➌ 从日期中创建一个字符串。你可以看到，现在日期已经被转换成格式良好的字符串 "Tuesday, November 21, 2017"。表 11-1 显示了 Swift 中五种 DateFormatter.Style 选项所创建的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "Nov 21, 2017" |
| long | "November 21, 2017" |
| full | "Tuesday, November 21, 2017" |

你还可以使用 DateFormatter 的 dateFormat 属性指定自定义的日期显示方式。也许你只想显示月份和日期，或者你想以短格式显示四位数的年份。无论哪种方式都非常简单，你甚至不需要创建一个新的 DateFormatter——你只需要改变 formatter 上的 dateFormat 属性，然后请求一个新的字符串。将以下代码添加到你的 playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定只想要以 MM/dd 格式显示月份和日期——即两位数的月份，后跟两位数的日期。如果你想将月份显示为三个字母，可以使用 MMM。如果想要显示完整的月份名称，则使用 MMMM。在 ➋ 处，我们将日期格式更改为使用四位数年份。两位数年份将是 yy。这里是一些使用 dateFormat 显示自定义日期字符串的其他方法。

![](img/Image00242.jpg)

如果你想包括分隔符，可以将它们添加到 dateFormat 字符串中。例如，如果你希望使用句点作为分隔符，可以创建像 "MM.dd.yy" ➊ 这样的 dateFormat。如果你想显示简写的星期几，可以使用 EEE ➋。要显示完整的星期几，可以使用 EEEE ➌。这些只是一些示例。通过组合 M、d、y 和 E，你可以有无数种方式来显示日期！

#### 设置生日表视图控制器

生日表视图控制器将显示应用中存储的所有生日的列表。你还记得用什么来存储一系列项目吗？没错——数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有的生日。为此，在类的顶部，紧接着 viewDidLoad() 方法之上，插入这一行来添加一个名为 birthdays 的数组变量属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量，而不是常量，因为每次用户通过添加生日视图控制器添加一个生日时，你都需要将已保存的生日添加到这个数组中。你将在 “使生日表视图控制器符合协议” 中的 第 168 页 学到如何做到这一点。

**注意**

*记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *获取。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性来将出生日期显示为格式良好的字符串。将一个 dateFormatter 添加到 birthdays 数组正下方：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，通过 let 创建。尽管你会改变 dateFormatter 的属性，如 dateStyle 和 timeStyle，但你永远不会改变 dateFormatter 本身。

你还需要设置 dateFormatter，以便它能将出生日期显示为完全格式化的字符串，如 “Tuesday, December 17, 2008”。正如你在 第十章 中看到的，最好的做法是在 viewDidLoad() 方法中进行设置，该方法会在 Birthdays 表视图控制器加载视图时被调用。这是进行任何必要设置的完美位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 dateFormatter 的 dateStyle，这样它会为每个生日显示格式化的日期字符串。你有没有注意到我们只写了 .full 而不是 DateFormatter.Style.full？Swift 知道 DateFormatter 的 dateStyle 应该是什么类型，所以它允许我们使用这个小捷径。在 ➋ 处，你将 dateFormatter 的 timeStyle 设置为 .none，这样就不会显示时间。

#### 在表视图中显示生日

BirthdaysTableViewController 类有一个表视图，用来显示一列项目的列表。表视图包含一个或多个部分，每个部分包含若干行，每一行包含一个单元格。表视图中的一个部分是若干行的分组，可以选择显示或不显示标题。显示包含多个部分的表视图的应用程序的一个例子是设置应用程序，如 图 11-5 所示。它显示了一系列行，这些行被分成了不同的部分。

表视图的每个部分和行都通过一个索引号来标识。这些数字从 0 开始，随着你向下滚动表视图而增加 1。例如，设置应用中的隐私行位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为 *表视图数据源* 的部分，其中包含三个方法。表视图控制器使用这些方法来确定将显示在其表视图中的内容。

numberOfSections(in:) 告诉表视图它应该有多少个部分。

tableView(_:numberOfRowsInSection:) 告诉表视图每个部分中将显示多少行。

tableView(_:cellForRowAt:) 设置每个将要显示在表视图每一行中的单元格。

![](img/Image00243.jpg)

*图 11-5：设置应用程序使用多个部分来分组不同的设备设置行。*

每次表视图被重新加载时，表视图数据源方法都会被表视图控制器调用。当你创建一个 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现所有三个方法，以便应用程序能够正常工作，即使你在代码中永远不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议带有这些数据源方法，用于确定将显示在表视图中的内容。我们将在 “委托” 第 166 页讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要手动调用它们。

让我们从方法 numberOfSections(in:) 开始。生日表视图控制器是一个只显示生日实例的列表，因此它不需要多个部分。为了设置表视图中的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接收一个 `UITableView` 类型的 `tableView` 参数，它是使用此类作为数据源的表格视图。我们不需要担心建立这个连接，因为 `UITableViewController` 自带一个内建的表格视图，自动连接到这些方法。每个生日会显示在自己的一行中。因此，在 `tableView(_:numberOfRowsInSection:)` 方法中，为了确保你有正确数量的行来显示所有生日，你需要返回 `birthdays` 数组中生日实例的数量。你还记得数组的 `count` 属性吗？它是一个整数，告诉你数组中有多少项，非常适合这种情况！将此方法修改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 `tableView` 参数外，`tableView(_:numberOfRowsInSection:)` 还接收一个名为 `section` 的 `Int` 类型参数。当表格视图加载时，此方法会为表格视图中的每个区段被调用。在我们的案例中，只有一个区段，因此我们不需要担心检查当前显示的是哪个区段。我们知道它是第 0 区段，我们希望它有和生日数目相等的行数，因此我们写 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)` 方法，以便表格视图知道在每个单元格中放置什么内容。由于此方法被注释掉了，你需要通过删除包围它的 `/*` 和 `*/` 来取消注释。（小心不要不小心取消注释之后的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法 `tableView(_:cellForRowAt:)`。它会在表格视图加载到屏幕上时被调用。它会为屏幕上的每个单元格被调用，并接收两个参数，`tableView` 和 `indexPath`。你已经知道 `tableView` 参数的用途。`IndexPath` 是一个 Swift 结构体，用于表示表格视图中一行的位置。`IndexPath` 实例有一个 `section` 属性和一个 `row` 属性。由于此方法会被多次调用（每一行都会调用一次），我们需要 `indexPath` 来知道我们当前配置的是哪个区段和哪一行。`indexPath.section` 属性给出区段号，`indexPath.row` 给出表格视图单元格的行号。`tableView(_:cellForRowAt:)` 中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 `UITableViewCell`

• 找出在 `birthdays` 数组中将显示在单元格中的生日

• 在单元格中创建两个标签来显示生日人的名字和出生日期

• 返回准备好在表格视图中显示的单元格

让我们逐行解析这段代码。

首先，创建 UITableViewCell。➊ 处的代码通过 dequeueReusableCell(withIdentifier:for:) 方法实现了这一点。但是，在你开始使用这个方法之前，你需要告诉它你希望从 storyboard 中使用哪个单元格。早些时候，当你在 storyboard 中时，你给单元格设置了标识符 birthdayCellIdentifier（参见 图 11-4）。这个标识符将你的代码和单元格连接起来，并告诉方法正在使用正确的单元格。当你调用这个方法时，字符串需要和你在 storyboard 中设置的字符串完全一致，否则你会遇到错误，应用会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:) 中，你注意到 *可重用单元格* 这几个词了吗？表格视图中的单元格只会创建一次，然后可以被反复重用。这有助于提高性能，使一切运行更快更流畅，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但每次屏幕上只能显示 10 个，那么你只需要 10 个单元格来展示这些生日。当你滚动页面以查看更多生日时，滚出屏幕顶部的单元格会被重新使用。它们会被填充新的信息，并在屏幕底部重新显示。UITableView 会自动完成这些工作。当表格视图加载时，tableView(_:cellForRowAt:) 会为每一行可见的单元格调用。当用户滚动查看更多单元格时，它会在每行即将出现在屏幕上时再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日，位于 birthdays[0]，应该显示在第 0 行。第二个生日，位于 birthdays[1]，应该显示在第 1 行，以此类推，这意味着 indexPath 的 row 和我们希望访问的 birthdays 数组中的位置相同。➋ 处的代码通过 indexPath.row 从 birthdays 数组中访问正确的 Birthday 对象。一旦我们得到了正确的 Birthday 对象，就将其赋值给一个名为 birthday 的常量，以便设置该单元格中的标签。

请注意，我们使用 let 将生日赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都会得到自己的生日常量，并将其自己的 Birthday 对象赋值给它。由于我们不会改变任何生日常量——我们只是读取它们的属性——因此不需要将它们声明为变量。

现在你已经有了单元格和生日信息，接下来是填写细节。每个单元格需要两个标签来显示生日人的名字和生日日期。你将单元格设置为 Subtitle 样式，这样它就有了一个 Title 标签和一个 Subtitle 标签。每个单元格已经包含了这些标签，因此你不需要自己创建任何标签。

这些标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。在 ➌ 处，代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格隔开。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 会在 ➎ 处返回该单元格，以便它能够在该 table view 的 indexPath 上显示。

### 将一切整合在一起（PUTTING IT ALL TOGETHER）

现在，你可以使用 Add Birthday 视图控制器将生日实例添加到应用中，并且你有一个表视图来列出每个生日，在 Birthdays 表视图控制器中显示。但是当你尝试运行应用并添加生日时，它没有出现。为了让你添加的每个生日出现在表视图中，你需要让 Add Birthday 视图控制器与 Birthdays 表视图控制器进行通信。你可以通过使用 *委托（delegation）* 来实现这一点。

#### 委托（DELEGATION）

委托（Delegation）用于当一个视图控制器需要从另一个视图控制器获取信息时。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 展示在自己之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A，它只是突然出现的，不知道它从哪里来或者如何到达的。那么 B 怎么与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将任务交给另一个人来完成。*委托（delegate）* 就像是一个老板，告诉一个被委托的员工该做什么。当被委托的员工完成任务后，有时他们会将信息反馈给老板（委托）。

Swift 中的委托非常类似，只不过我们没有老板和员工，而是有委托（delegate）和委托对象（delegating object）。由于是类 B 被类 A 告诉该做什么，因此它是委托对象。我们给类 B 一个名为 delegate 的特殊属性，来告诉它谁是它的委托——这样它就知道与谁进行通信。委托可以是任何一个具有一组方法的类，这些方法是在 *协议（protocol）* 中定义的。协议就像是两个类之间的协议，告诉它们委托可以要求委托对象做些什么。协议有一个方法和属性名称的列表，委托可以使用这些方法与委托对象进行交互。

类 A 创建类 B，使自己成为类 B 的委托，并给类 B 分配一个在协议中定义的任务。一旦类 B 完成了任务，它会向类 A 报告。让我们看看在我们的应用中是如何实现的。

Birthdays 表视图控制器是视图控制器 A，Add Birthday 视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将由 Add Birthday 视图控制器用来报告信息。

看看 图 11-6。当用户点击添加按钮 ➊ 时，生日表格视图控制器创建 Add Birthday 视图控制器 ➋ 并将自身设置为 Add Birthday 视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：一个新生日被添加并通过代理从 Add Birthday 视图控制器传递到生日表格视图控制器。*

AddBirthdayViewControllerDelegate 协议定义了一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，添加生日视图控制器调用该方法 ➍ 并将新的生日传递给它的代理，即生日表格视图控制器。生日表格视图控制器接收该生日，将其添加到生日数组中，然后重新加载其表格视图 ➎，以便新生日能够显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并实现方法 addBirthdayViewController(_:didAddBirthday:)，该方法在每次向应用程序添加生日时由 Add Birthday 视图控制器调用。生日表格视图控制器将实现该协议方法，以便每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器只需对其代理说：“嘿！刚刚添加了这个生日。”而生日表格视图控制器会接收到该消息，并说：“哦！我会把它添加到我的列表中，并刷新显示，让新添加的生日显示出来。”

现在我们来实现这一功能吧！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类*之前*，添加定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 通过输入关键字 protocol 来定义协议，后跟协议名称 AddBirthdayViewControllerDelegate。这是一个较长的名称，但 Swift 程序员通常根据调用类的名称来命名协议，并在末尾加上 Delegate 这个词。这样你就可以通过查看协议的名称来知道是哪个类在使用该协议。既然你现在是 Swift 程序员，你也应该使用相同的命名约定。

在此协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，用于将 Birthday 对象传递回代理类 ➋。请注意，你在这个方法中包括了 AddBirthdayViewController 作为一个参数。再次强调，Swift 程序员在实现协议方法时通常根据约定这样做，因此你也应该遵循这一惯例。这样做有助于了解是谁发送了消息，并且代理可以访问该对象及其类。

当 Add Birthday 视图控制器调用此方法时，它会将自己作为 addBirthdayViewController 参数传递给该方法。你很快就会看到如何实现这一点。需要注意的另一点是外部参数名称 didAddBirthday。许多代理协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚完成或即将完成的操作。

现在你已经定义了协议，接下来需要告诉 Birthdays 表视图控制器去采用这个协议并使用协议中的方法。

##### 使 Birthdays Table View Controller 符合协议

为了采用这个协议，Birthdays 表视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，紧接在 UITableViewController 超类后面添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色错误提示会出现。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它尚未实现该协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快就会修复这个问题。

在这里需要注意的是，BirthdaysTableViewController 是从 UITableViewController 超类继承的。一个类只能有一个超类，并且超类的名称必须在任何协议之前写出。但是，虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议会在超类之后列出，并且由逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的位置是在类的末尾，即导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 的自动完成功能会建议你整个方法声明。这是因为它知道这个类采纳了 AddBirthdayViewController Delegate 协议，并且它期待你添加这个方法。请注意，与子类化方法不同，在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现 ➋。接下来，你需要刷新表视图，使其显示这个新的生日，通过在 tableView 属性上调用 reloadData() 方法 ➌。当调用 reloadData() 时，表视图的数据源方法会重新调用，新的生日将显示在生日列表的底部。

你可能注意到，我们在方法上方添加了一个注释来标记这一部分代码：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但标记类的不同部分是一种好的编码风格，它有助于保持代码整洁和易读。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键词，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单可以帮助你快速找到方法并跳转到代码中的不同位置。要使用此菜单，请点击编辑器面板顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 给 Add Birthday 视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知 Birthdays 表视图控制器它已添加一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 outlets 下面插入以下代码行，给 AddBirthdayViewController 类添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在 Add Birthday 视图控制器创建之前，你无法设置它。你很快会学到在哪里设置代理。

现在 Add Birthday 视图控制器已经有了一个代理，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日对象传递给代理。将 saveTapped(_:) 修改为如下代码：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

生日对象创建后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 将其传回给代理。

太好了！你已经完成了对 Add Birthday 视图控制器的修改。它现在有了一个代理，能够监听生日保存的事件。运行应用程序，看看会发生什么。

嗯……似乎没什么变化。当你添加生日时，仍然看不到它出现在 Birthdays 表视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

你还需要做最后一件事。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存了与之通信的代理，供保存生日时使用。但我们从未明确将代理属性设置为 Birthdays 表视图控制器。所以，现在是时候连接这两个视图控制器之间的通信管道了。

在“生日”表格视图控制器类的导航部分，有一个已被注释掉的方法 prepare(for:sender:)。通过删除/*和*/，取消注释该方法。

每当“生日”表格视图控制器放弃其屏幕并且应用程序通过故事板 segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将“生日”表格视图控制器传递到“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的代理。在 prepare(for:sender:)方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的代理为“生日”表格视图控制器只需三行代码。首先，你需要能够通过 segue 参数获取到 AddBirthdayViewController 对象。Xcode 中有一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，它位于准备中的 segue 的另一端，但对于这个应用程序，destination 并不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到了一个导航控制器中，这样你就可以拥有一个包含取消和保存按钮的导航栏。因此，你不应该在 segue 的另一端找到“添加生日”视图控制器。相反，destination 是一个包含“添加生日”视图控制器的 UINavigationController。第➊行代码可以获取 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是一个特定类型的视图控制器，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获得了 AddBirthdayViewController 后，你可以将代理设置为 self，即当前的“生日”表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在“生日”表格视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用并重新运行，之前添加的生日将会消失。我们仍然需要将生日保存到设备中，接下来的操作将在第十二章进行。

### 你学到了什么

在本章中，你学习了如何制作一个表格视图控制器来显示生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，然后通过代理将该生日添加到“生日”表格视图控制器中的生日数组中，以便它可以显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用并再次运行，生日也会显示。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

## 显示生日

![](img/Image00001.jpg)

是时候展示这些生日了！在第十章中，你创建了 Add Birthday 视图控制器，这样你就可以将新的 Birthday 对象添加到应用程序中。在本章中，你将创建一个 Birthdays 表视图控制器，能够在*表格视图*中显示你添加的生日，表格视图显示了一个用户可以滚动浏览并选择的项目列表。然后你将学习如何让 Add Birthday 视图控制器在添加 Birthday 对象时通知 Birthdays 表视图控制器，从而将新生日显示在表格视图中。

### 制作生日列表

能够添加生日是一回事，但你还需要展示一个生日列表。为此，你需要创建另一个类，BirthdaysTableViewController，它将作为 UITableViewController 的子类，UITableViewController 是一种具有表格视图的特殊视图控制器。UITableViewController 包含几个内置方法，允许你编写代码来处理例如表格视图应该有多少行以及每一行应该显示什么内容等。我们希望有和生日数量一样多的行，并且在每一行中显示一个生日。

#### 创建生日表视图控制器

在项目导航中，*BirthdayTracker*文件夹上按住 CONTROL 键点击，并从菜单中选择**New File…**。在第十章中，我们创建了 Swift 文件*Birthday.swift*，Xcode 为我们准备了几乎没有内容的文件。这次为了创建新文件，我们将告诉 Xcode 我们想要创建一个现有 iOS 类的子类。根据基类的不同，Xcode 会创建一个包含一些代码的文件，你可以根据需要自定义它。要创建该文件，首先在窗口顶部选择**iOS**，然后选择**Cocoa Touch Class**模板，Xcode 将自动格式化新类文件（参见图 11-1）。

![](img/Image00234.jpg)

*图 11-1：要创建一个现有类的子类，选择* ***iOS*** *，然后选择* ***Cocoa Touch Class.***

当你选择这个选项时，会弹出第二个对话框，你可以在其中为新类命名并指定你将要子类化的类。首先，在子类字段（对话框中的第二个字段）中输入 UITableViewController。这样会自动填充类字段，并给出子类名称。一旦出现这种情况，在 TableViewController 前输入 Birthdays，这样整个类名就是 BirthdaysTableViewController。这是一个快捷方式，可以避免输入过多的内容。确保在语言下拉菜单中选择**Swift**，然后点击**Next**。接着在最终对话框中选择**Create**，以创建新文件。

在*BirthdaysTableViewController.swift*中，Xcode 提供了一个模板，其中包含几个被注释掉的方法。你可以通过删除不使用的方法来清理代码。只需删除 viewDidLoad()中的注释，然后删除整个 didReceiveMemoryWarning()方法以及 tableView(_:moveRowAt:to:)和 tableView(_:canMoveRowAt:)方法，这些方法与在表格视图中移动行有关。完成后，BirthdaysTableViewController 的内容应如下图 11-2 所示。仍然有几个被注释掉的方法，但我们保留它们以便以后使用！

![](img/Image00235.jpg)

*图 11-2：* BirthdaysTableViewController *已清理完成！*

接下来，你需要将“Birthdays”表格视图控制器设置为 BirthdaysTableViewController 类。为此，打开*Main.storyboard*，并选择**Birthdays**场景。使用右侧窗格中的 Identity Inspector，将类从 UITableViewController 更改为 BirthdaysTableViewController，如图 11-3 所示。

![](img/Image00236.jpg)

*图 11-3：将* BirthdaysTableViewController *设置为 Birthdays 场景的类*

现在你已经在故事板中设置好了 Birthdays 表格视图控制器，下一步是创建表格中的单元格，用来显示每个生日。

#### 向表格视图添加单元格

每个生日将在 Birthdays 表格视图控制器中的 UITableViewCell 中显示。表格由排列成行和列的框组成，这些框包含信息。这些框称为*单元格*。类似地，表格视图也有单元格，这些单元格都是 UITableViewCell 类的实例或其子类。我们将在表格视图中为每个生日创建一个单独的单元格。

我们将从在故事板中创建这些单元格开始，然后稍后再用我们的 Birthday 对象填充它们。在左侧大纲菜单中，点击**Birthdays**旁边的三角形，然后点击**Table View**旁边的三角形以打开这些部分。然后选择**Table View Cell** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建一个 Subtitle 样式的表格视图单元格并设置其标识符*

接下来，打开 Attributes Inspector。使用**Style**下拉菜单，将单元格的样式设置为**Subtitle** ➋，这样单元格现在就有了一个 Title 标签和一个 Subtitle 标签。你将在 Title 中显示每个人的名字，在 Subtitle 中显示他们的生日。

最后，在 Identifier 字段中输入 birthdayCellIdentifier ➌。稍后你将在填充单元格内容时使用这个标识符。

就是这样！你已经完成了在故事板中的工作。

你可能会想，为什么我们在 storyboard 中的表格视图只有一个单元格，而列表中会有多个生日需要展示。如果你再看看图 11-4，你会注意到单元格被标记为 *原型单元格*。这意味着你刚刚自定义的单元格是所有你希望在表格视图中显示的单元格的 *模板*。你为单元格指定的标识符就是你的代码如何告诉表格视图为你生成每个单元格来显示生日。你很快就会看到它是如何工作的。

**处理日期**

Swift 有一种特殊的数据类型叫做 `Date`，用于存储日期值。`Date` 对象实际上是一个日期和时间。打开你的 playground 并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量 `today`。当你打印 `today` 时，它的格式是 "2017-11-21 10:45:31 +0000\n"。如果你想它显示为 "2017 年 11 月 21 日，星期二" 呢？或者只是 "11/21/17" 呢？为了以特定方式显示日期，你使用 *日期格式化器*，它是你创建的一个 `DateFormatter` 对象，并为其指定一个日期格式样式。`DateFormatter` 是一个帮助对象，用于根据任何日期生成显示字符串，*日期格式样式* 是 `DateFormatter` 的一个属性，告诉格式化器使用哪种样式。你可以手动创建自己的日期格式样式，但 Swift 中也包含了现成可用的样式。将以下内容添加到你的 playground 中：

![](img/Image00240.jpg)

在 ➊ 处，你创建了一个格式化器。然后在 ➋ 处，你将格式化器的样式设置为 `Style.full`，它会打印星期几以及完整的月份名称、日期和年份。最后，你通过 `DateFormatter` 类的 `string(from:)` 方法 ➌ 创建了一个日期字符串。你可以看到你已经将日期转换为格式化良好的字符串 "2017 年 11 月 21 日，星期二"。表 11-1 展示了从 Swift 中可用的五种 `DateFormatter.Style` 选项创建的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "2017 年 11 月 21 日" |
| long | "2017 年 11 月 21 日" |
| full | "2017 年 11 月 21 日，星期二" |

你还可以通过 `DateFormatter` 的 `dateFormat` 属性指定自定义的日期显示方式。也许你只想显示月份和日期，或者你可能希望以简短格式显示四位数的年份。做到这一点非常简单，你甚至不需要创建一个新的 `DateFormatter`——只需改变格式化器的 `dateFormat`，然后请求它返回一个新的字符串。将以下代码添加到你的 playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定了只需要以 MM/dd 格式显示月份和日期——也就是两位数的月份，后面跟着两位数的日期。如果你想以三字母表示月份，可以使用 MMM。如果你想显示月份的全名，可以使用 MMMM。在 ➋ 处，我们将日期格式更改为使用四位数的年份。两位数的年份使用 yy。这里有一些其他方式可以使用 dateFormat 显示自定义的日期字符串。

![](img/Image00242.jpg)

如果你想包含分隔符，可以将它们添加到你的 dateFormat 字符串中。例如，如果你想使用句点作为分隔符，可以创建像 "MM.dd.yy" ➊ 这样的 dateFormat。要显示缩写的星期几，可以使用 EEE ➋ 。要显示完整的星期几，可以使用 EEEE ➌ 。这些只是几个例子。通过组合 M 、 d 、 y 和 E ，你可以有无数种方式来显示日期！

#### 设置 BIRTHDAYS TABLE VIEW CONTROLLER

Birthdays table view controller 将显示应用中存储的所有生日的列表。你还记得用什么来存储一系列项目吗？没错——数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有的生日。为此，给 BirthdaysTableViewController 添加一个名为 birthdays 的属性，它是一个 Birthday 对象的数组。在类的顶部，紧接着 viewDidLoad() 方法的上方，插入以下行来添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量而不是常量，因为你希望每次用户通过 Add Birthday view controller 添加一个生日时，都将保存的 Birthday 添加到这个数组中。你将在“让 Birthdays Table View Controller 遵循协议”中看到如何操作，具体内容在第 168 页。

**注意**

*请记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性来将出生日期显示为格式化后的字符串。请在 birthdays 数组下方添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，通过 let 创建。即使你会更改 dateFormatter 的属性，例如 dateStyle 和 timeStyle，你也永远不会更改 dateFormatter 本身。

你还需要设置 dateFormatter，使它能够以完整格式的字符串形式显示出生日期，例如 "Tuesday, December 17, 2008"。正如你在第十章 中看到的，执行此操作的一个好地方是 viewDidLoad() 方法，它在 Birthdays table view controller 加载视图时被调用。这个方法是进行此类初始化操作的理想位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 dateFormatter 的 dateStyle，以便它为每个 Birthday 显示格式化的日期字符串。你是否注意到我们只写了.full，而不是 DateFormatter.Style.full？Swift 知道 DateFormatter 的 dateStyle 应该是什么类型，所以它允许我们使用这个小技巧。在 ➋ 处，你设置了 dateFormatter 的 timeStyle 为.none，这样就不会显示时间。

#### 在表格视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于显示单列的项目列表。表格视图有一个或多个部分，包含行，每行包含一个单元格。表格视图中的一个部分是行的分组，可以带有或不带有标题。一个展示了多个部分的表格视图应用的例子是设置应用，如图 11-5 所示。它显示了分成不同部分的行列表。

表格视图的每个部分和行都通过索引号进行标识。这些数字从 0 开始，向下增加。例如，设置应用中的“隐私”行位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为*表格视图数据源*的部分，包含三个方法。表格视图控制器使用这些方法来确定将显示在表格视图中的内容。

numberOfSections(in:) 告诉表格视图它应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表格视图每个部分将显示多少行

tableView(_:cellForRowAt:) 设置将显示在表格视图每行中的每个单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分将不同设备设置的行进行分组。*

表格视图数据源方法会在每次表格视图重新加载时由表格视图控制器调用。当你创建 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现这三个方法才能使应用程序正常工作，尽管你在代码中不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用于确定在表格视图中显示的内容。我们将在 “委托” 一节的第 166 页讨论协议。目前，你只需要知道 UITableViewController 使用这些方法来显示内容，并且会自动调用这些方法，因此你不需要手动调用它们。

我们从方法 numberOfSections(in:)开始。Birthdays 表格视图控制器是一个只显示 Birthday 实例的列表，因此它不需要多个部分。为了设置表格视图的部分数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个 UITableView 类型的 tableView 参数，它是使用这个类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内置的表格视图，并且自动与这些方法连接。每个生日将会显示在它自己的行中。所以，在 tableView(_:numberOfRowsInSection:) 方法中，为了确保每个生日都有正确的行数，你需要返回 birthdays 数组中所有 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少项，非常适合这个情况！将这个方法修改为以下代码：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，tableView(_:numberOfRowsInSection:) 还接收一个名为 section 的 Int 参数。当表格视图正在加载时，这个方法会为表格中的每个 section 调用。在我们的例子中，我们只有一个 section，所以这里不需要检查表格视图中显示的是哪个 section。我们知道它是 section 0，并且希望它有和生日数量一样多的行，所以我们写 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:) 方法，以便表格视图知道在每个单元格内放置什么内容。由于这个方法目前是被注释掉的，你需要通过删除 /* 和 */ 来取消注释它。（小心不要不小心取消注释它后面的其他方法！）完成后，将它修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要调用方法 tableView(_:cellForRowAt:)。该方法会在表格视图加载到屏幕上时自动调用。它会为屏幕上的每个单元格调用，接受两个参数，tableView 和 indexPath。你已经知道 tableView 参数的作用。IndexPath 是一个 Swift 结构体，用于表示表格视图中某一行的位置。一个 IndexPath 实例有两个属性：section 和 row。由于这个方法会被多次调用（每个表格中的每一行都会调用一次），我们需要 indexPath 来知道我们当前正在配置的是哪个 section 和 row。indexPath.section 属性返回 section 编号，而 indexPath.row 返回表格视图单元格的行号。tableView(_:cellForRowAt:) 中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定 birthdays 数组中哪个生日将显示在单元格内

• 创建两个标签，用于在单元格中显示生日人的姓名和出生日期

• 返回准备好显示的单元格，在表格视图中展示

让我们逐行分析这段代码。

首先，创建 UITableViewCell。➊处的代码使用方法 dequeueReusableCell(withIdentifier:for:)来完成这个操作。然而，在你开始使用这个方法之前，你需要告诉它你想使用哪个单元格。之前在故事板中，你已经为单元格设置了标识符 birthdayCellIdentifier（参见图 11-4）。这个标识符将你的代码与单元格链接，并告诉方法它正在使用正确的单元格。你调用该方法时的字符串必须与故事板中设置的字符串完全相同，否则你会遇到错误，应用程序在运行时会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:)中，你是否注意到*Reusable Cell*这两个词？表格视图中的单元格是一次创建，然后可以反复使用的。这有助于提高运行速度和流畅度，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，滚动出屏幕顶部的单元格会被重新使用。它们会填充新信息并再次出现在屏幕底部。UITableView 会自动完成这些工作。当表格视图加载时，会为每个可见的行调用 tableView(_:cellForRowAt:)。当用户滚动以查看更多单元格时，每个即将出现在屏幕上的行都会再次调用该方法。

接下来，我们需要找出在单元格中显示哪个生日。我们希望在每一行中显示生日数组中的一个生日。第一个生日，在 birthdays[0]，应该显示在第 0 行。第二个生日，在 birthdays[1]，应该显示在第 1 行，依此类推，这意味着 indexPath 的行数与我们想要访问的生日数组中的位置相同。➋处的代码通过使用 indexPath.row 从生日数组中获取正确的 Birthday 对象。一旦我们获得了正确的 Birthday 对象，就将其赋值给一个名为 birthday 的常量，以便设置这个单元格中的标签。

注意，我们使用 let 来将生日赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的 birthday 常量。每个单元格都会获得自己的 birthday 常量，并赋予它自己的 Birthday 对象。由于我们不会改变任何生日常量——我们只会读取它们的属性——所以我们不希望将它们设置为变量。

现在你有了单元格和生日，接下来是填充详细信息。每个单元格需要两个标签来显示生日人物的姓名和出生日期。你将单元格设置为 Subtitle 样式，这样它就有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，因此你现在不需要自己创建任何标签。

这些标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。代码 ➌ 设置 textLabel 的文本为由生日的 firstName 和 lastName 组成的字符串，中间有一个空格。到了 ➍，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好时，tableView(_:cellForRowAt:) 会返回该单元格（➎），以便它可以在表视图的该 indexPath 上显示。

### 将一切组合起来（PUTTING IT ALL TOGETHER）

现在，你可以使用添加生日视图控制器将生日实例添加到应用程序中，并且你有一个表视图用于在生日表视图控制器中列出每个生日。但是当你尝试运行应用程序并添加生日时，它没有显示出来。为了让你添加的每个生日出现在表视图中，你需要让添加生日视图控制器与生日表视图控制器进行通信。你可以通过使用*代理（delegation）*来实现这一点。

#### 代理（DELEGATION）

代理模式可以用于当一个视图控制器需要从另一个视图控制器获取信息时。例如，假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己之上。A 知道 B 的存在，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A 的存在——它只是突然被创建出来的，并不知道它是从哪里来的或怎么到达那里。所以 B 怎么能和 A 通信呢？通过代理！

![](img/Image00245.jpg)

代理就是将某项工作或任务交给别人做。一个*代理*就像是一个老板，告诉一个委托员工该做什么。当委托员工完成任务后，有时会将信息反馈给代理老板。

在 Swift 中，代理模式非常相似，不过这里没有老板和员工，而是有一个代理和一个委托对象。由于类 B 是被类 A 告诉该做什么的，所以它是委托对象。我们给类 B 一个特殊的属性，称为代理（delegate），用来告诉它它的代理是谁——这样它就知道该与谁通信。代理可以是任何一个已经在*协议（protocol）*中定义了一系列方法的类。协议就像是两者之间的协议，告诉它们代理可以要求委托对象做些什么。它包含了代理可以与委托对象一起使用的各种方法和属性名称。

类 A 创建类 B，使自己成为类 B 的代理，并给类 B 分配一个协议中的任务。一旦类 B 完成了任务，它会将结果报告回类 A。让我们看看在我们的应用程序中这是如何工作的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器使用来报告结果。

看一下图 11-6。当用户点击添加按钮➊时，生日表视图控制器创建了添加生日视图控制器➋并将自身设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从添加生日视图控制器传递到生日表视图控制器。*

定义了 AddBirthdayViewControllerDelegate 协议，该协议包含一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮➌时，添加生日视图控制器调用此方法➍并将新生日传递给它的委托，即生日表视图控制器。生日表视图控制器接收这个生日，将其添加到它的生日数组中，然后重新加载表视图➎，以便新生日能够显示在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义一个方法 addBirthdayViewController(_:didAddBirthday:)，当用户在应用中添加生日时，添加生日视图控制器可以调用此方法。生日表视图控制器将实现这个协议方法，以便每当通过添加生日视图控制器添加一个生日时，添加生日视图控制器可以对其委托说：“嘿！有人刚刚添加了这个生日”，而生日表视图控制器会接收到这个消息并回应：“哦！我会把这个添加到我的列表中并刷新显示，让新生日出现在表格里。”

所以现在让我们在代码中实现这个功能！

##### 创建一个协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类**之前**添加定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过在➊输入关键字 protocol 并跟上 AddBirthdayViewControllerDelegate 的名称来定义协议。这个名字很长，但 Swift 程序员通常会以调用类的名称为协议命名，并在后面加上“Delegate”一词。这是为了让你通过协议的名字就能知道哪个类在使用这个协议。既然你现在是 Swift 程序员，你也应该遵循这个命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传回给委托类➋。注意，在这个函数中，你把 AddBirthdayViewController 作为一个参数。再次说明，Swift 程序员在实现协议方法时通常这样做，这是一个约定，因此你也应该遵循这个约定。知道谁发送了消息并让委托类可以访问该对象及其类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为`addBirthdayViewController`参数传递。你很快就会看到这是如何做到的。另一个需要注意的是外部参数名`didAddBirthday`。许多委托协议方法中都包含*did*和*will*这两个词，因为它们用于描述调用类刚刚做过的事情或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表视图控制器采纳这个协议并使用协议中的方法。

##### 使 Birthdays 表视图控制器符合协议

为了采用这个协议，Birthdays 表视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，在 UITableViewController 超类之后添加 AddBirthdayViewControllerDelegate。你只需在类的顶部，在 UITableViewController 后面添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做了，一个红色的错误会出现。发生这种情况是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会修复这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，而且这个超类的名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采纳任意多个协议——这些协议将会在超类之后列出，并且用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将`addBirthdayViewController(_:didAddBirthday:)`方法添加到 Birthdays TableViewController。一个合适的位置是类的末尾，紧接着导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成会建议这个完整的方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它期待你添加这个方法。请注意，与子类方法不同，你在`addBirthdayViewController(_:didAddBirthday:)`前不需要使用`override`关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的`append(_:)`方法来实现这一点➋。接下来，你需要刷新表格视图，以便它显示这个新添加的生日，方法是调用`tableView`属性上的`reloadData()`方法➌。当`reloadData()`被调用时，表格视图的数据源方法会再次被调用，新添加的 Birthday 将显示在生日列表的底部。

你可能注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但标记类的不同部分是一种良好的编码风格，有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键词，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录中，你可以在类的顶部使用这个目录。这个下拉菜单帮助你找到方法，并允许你跳转到代码中的不同位置。要使用这个菜单，请点击编辑器窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，方便快速跳转到某个章节。*

##### 给 Add Birthday 视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来通知 Birthdays 表格视图控制器它已添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 outlets 下方插入以下代码，向 AddBirthdayViewController 类中添加一个可选的代理属性，类型为 AddBirthdayViewControllerDelegate，以此来安排：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在 Add Birthday 视图控制器创建之前，你无法设置它。你很快就会学习到在哪里设置代理。

现在 Add Birthday 视图控制器已经有了一个代理，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日传递给代理。将 saveTapped(_:) 改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

生日对象创建后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 将其传回给代理。

很棒！你已经完成了对 Add Birthday 视图控制器的更改。现在它有一个代理，用来监听生日保存的调用。运行应用查看发生了什么。

嗯……似乎没什么变化。当你添加一个生日时，仍然没有看到它显示在 Birthdays 表格视图控制器中。这是怎么回事呢？

#### 通过设置代理连接这两个控制器

你还有最后一件事需要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存它与之通信的代理，在生日被保存时调用。但我们从未专门将代理属性设置为 Birthdays 表格视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法`prepare(for:sender:)`。通过删除围绕它的/*和*/来取消注释该方法。

每当生日表视图控制器放弃其屏幕并且应用程序通过故事板 segue 过渡到另一个视图控制器时，此方法会自动被调用。我们将使用这个方法将生日表视图控制器传递给添加生日视图控制器，以便将其自己设置为添加生日视图控制器的委托。在`prepare(for:sender:)`方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

需要三行代码来将添加生日视图控制器的委托设置为生日表视图控制器。首先，您需要能够通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 中留有一个注释，提示如何做到这一点。一个 UIStoryboardSegue 在 segue 的另一端有一个名为 destination 的属性，它是在这个方法中准备的，但对于这个应用程序来说，目标并不是 AddBirthdayViewController。

在第九章中，您将添加生日视图控制器嵌入到一个导航控制器中，这样您就可以拥有一个带有取消和保存按钮的导航栏。所以，您不希望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊处的代码可以获取`navigationController`。代码 segue.destination 将返回一个 UIViewController，但由于我们的`navigationController`是一个特定类型的视图控制器，我们需要使用`as`将其强制转换为 UINavigationController。

接下来，您可以获取添加生日视图控制器，它是`navigationController`的 topViewController ➋。topViewController 就是当前在`navigationController`中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其强制转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的特定子类。最后，当你获得 AddBirthdayViewController 后，您可以将委托设置为 self，self 目前是生日表视图控制器 ➌。

现在运行应用程序并添加一些生日！在生日表视图控制器中看到什么？生日！生日！生日！不过我们还没有完全完成。如果您退出应用程序然后重新运行它，之前的生日将会消失。我们仍然需要将生日保存到设备中，我们将在第十二章中处理。

### 你学到了什么

在这一章中，您学会了如何制作一个表视图控制器来显示您的生日列表。您还学会了如何在添加生日视图控制器中添加一个生日，然后如何使用委托将该生日添加到生日表视图控制器中的生日数组，以便可以显示它。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用并重新运行，生日也会显示。为了保存生日，你将使用 Core Data，这是我们在项目开始时设置的。

![](img/Image00001.jpg)

是时候展示这些生日了！在第十章中，你创建了 Add Birthday 视图控制器，使用 Birthday 类将新的 Birthday 对象添加到你的应用中。在本章中，你将创建一个 Birthdays 表格视图控制器，能够在*表格视图*中显示你添加的生日，表格视图展示了一个可供用户滚动浏览和选择的项目列表。接着，你将学习如何让 Add Birthday 视图控制器在添加了一个 Birthday 对象后通知 Birthdays 表格视图控制器，以便新的生日能显示在表格视图中。

### 创建生日列表

添加生日是一回事，但你还需要显示一个生日列表。为此，你需要创建另一个类，BirthdaysTableViewController，它将子类化 UITableViewController，这是一个带有表格视图的特殊视图控制器。UITableViewController 包含几个内置方法，允许你编写代码来设置表格视图的行数以及每一行应该显示什么内容。我们希望表格视图的行数与生日数量相同，并在每一行中显示一个生日。

#### 创建生日表格视图控制器

CONTROL -点击项目导航器中的*BirthdayTracker*文件夹，并从菜单中选择**新建文件...**。在第十章中，我们创建了 Swift 文件*Birthday.swift*，这是 Xcode 为我们准备的，里面几乎没有内容。为了这次创建新文件，我们需要告诉 Xcode 我们要从一个现有的 iOS 类进行子类化。根据基类，Xcode 会创建一个包含代码的文件，你可以根据需要进行自定义。为了创建这个文件，选择窗口顶部的**iOS**，然后选择**Cocoa Touch Class**模板，这将自动格式化新类文件（见图 11-1）。

![](img/Image00234.jpg)

*图 11-1：要从现有类进行子类化，选择* ***iOS*** *然后选择* ***Cocoa Touch Class***。

选择此选项后，你将看到第二个对话框，在这里你可以为新类命名，并指定你要子类化的类。首先，在子类字段（对话框中的第二个字段）中输入 UITableViewController。这将自动填充类字段，填写子类名称。完成后，输入 Birthdays，在 TableViewController 前面，这样完整的类名就是 BirthdaysTableViewController。这是一个快捷方式，你不需要输入那么多内容。确保在语言下拉菜单中选择**Swift**，然后点击**下一步**。接着，在最后一个对话框中选择**创建**，以创建你的新文件。

在 *BirthdaysTableViewController.swift* 中，Xcode 提供了一个带有多个注释掉的方法的模板。你可以通过删除我们不会使用的方法来清理代码。仅删除 viewDidLoad() 中的注释，然后删除整个 didReceiveMemoryWarning() 方法，以及与在表格视图中移动行相关的 tableView(_:moveRowAt:to:) 和 tableView(_:canMoveRowAt:) 方法。当你完成后，BirthdaysTableViewController 的内容应如下所示：图 11-2。虽然仍然有几个注释掉的方法，但我们保留这些方法以备后用！

![](img/Image00235.jpg)

*图 11-2：* BirthdaysTableViewController *整理完毕！*

接下来，你需要将 Birthdays 表格视图控制器设置为 BirthdaysTableViewController 类。为此，转到 *Main.storyboard* 并选择 **Birthdays** 场景。在右侧面板的身份检查器中，将类从 UITableViewController 更改为 BirthdaysTableViewController，如图 11-3 所示。

![](img/Image00236.jpg)

*图 11-3：将* BirthdaysTableViewController *设置为 Birthdays 场景的类*

现在你已经在故事板中设置好了 Birthdays 表格视图控制器，下一步是创建表格中的单元格来显示每个生日。

#### 向表格视图添加单元格

每个生日将在 Birthdays 表格视图控制器中显示为一个 UITableViewCell。一个表格有多个组织成行和列的框，这些框中包含信息，这些框被称为*单元格*。同样，表格视图也有单元格，它们都是 UITableViewCell 类的实例或其子类。我们将在表格视图中为每个生日创建一个单独的单元格。

我们将首先在故事板中创建这些单元格，然后稍后用我们的 Birthday 对象填充它们。在左侧大纲菜单中，点击 Birthdays 旁边的三角形，然后点击表格视图旁边的三角形以打开这些部分。然后选择 **表格视图单元格** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建副标题样式的表格视图单元格并设置其标识符*

接下来，打开属性检查器。在**样式**下的下拉菜单中，将单元格的样式设置为**副标题** ➋，这样单元格就会有一个标题标签和一个副标题标签。你将在标题中显示每个人的名字，在副标题中显示生日。

最后，在标识符字段 ➌ 中输入 birthdayCellIdentifier。稍后你将使用这个标识符来填写单元格内容。

就这样！你已经完成了在故事板中的工作。

你可能会好奇，为什么在故事板中的表视图只有一个单元格，而我们需要显示多个生日。如果你再次查看图 11-4，你会注意到该单元格标记为*原型单元格*。这意味着你刚刚自定义的单元格是所有希望出现在表视图中的单元格的*模板*。你为单元格指定的标识符将告诉你的代码如何指示表视图生成每个单元格，来显示生日信息。你很快就会看到它是如何工作的。

**处理日期**

Swift 有一个特殊的数据类型叫做`Date`，用于存储日期值。`Date`对象实际上包含日期和时间。打开你的 playground 并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将当前日期和时间（代码运行时的日期时间）赋值给了变量`today`。当你打印`today`时，它的格式为"2017-11-21 10:45:31 +0000\n"。如果你希望它显示为“2017 年 11 月 21 日，星期二”呢？或者只是“11/21/17”？要以特定方式显示日期，你需要使用*日期格式器*，它是一个`DateFormatter`对象，你创建并指定日期格式样式。`DateFormatter`是一个帮助对象，用于从任何日期创建显示字符串，*日期格式样式*是`DateFormatter`的一个属性，告诉格式器使用什么样式。你可以手动创建自己的日期格式样式，但 Swift 中也有一些预定义的样式可以直接使用。将以下代码添加到你的 playground 中：

![](img/Image00240.jpg)

在➊处你创建了一个格式器。然后在➋处，你将格式器的样式设置为`Style.full`，这样会打印星期几的名称以及完整的月份名称、日期和年份。最后，你使用`DateFormatter`类的`string(from:)`方法➌从日期创建一个字符串。你可以看到，你现在已经将日期转换为格式良好的字符串"星期二，2017 年 11 月 21 日"。表 11-1 显示了从 Swift 中五种`DateFormatter.Style`选项生成的不同字符串。

**表 11-1：** 日期格式器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "2017 年 11 月 21 日" |
| long | "2017 年 11 月 21 日" |
| full | "星期二，2017 年 11 月 21 日" |

你还可以使用`DateFormatter`的 dateFormat 属性指定自定义的日期显示方式。也许你只想显示月份和日期，或者你可能希望以短格式显示四位数年份。无论哪种方式，都非常简单，而且你甚至不需要创建一个新的`DateFormatter`——你只需修改`formatter`上的 dateFormat，然后请求它返回一个新的字符串。将以下代码添加到你的 playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定了只显示月份和日期，格式为 MM/dd，即两位数的月份后跟两位数的日期。如果你希望显示三字母的月份，使用 MMM 。如果要显示完整的月份名称，使用 MMMM 。在 ➋ 处，我们将日期格式更改为四位数的年份。两位数的年份使用 yy 。以下是几种使用 dateFormat 显示自定义日期字符串的方法。

![](img/Image00242.jpg)

如果你想包含分隔符，可以将它们添加到你的 dateFormat 字符串中。例如，如果你想使用句点作为分隔符，可以创建一个像 "MM.dd.yy" ➊ 这样的 dateFormat 。要显示简短的星期几，使用 EEE ➋ 。要显示完整的星期几，使用 EEEE ➌ 。这些只是几个示例。通过组合 M 、 d 、 y 和 E ，你可以创建无限多种日期显示方式！

#### 设置 Birthdays 表格视图控制器

Birthdays 表格视图控制器将显示存储在应用中的所有生日列表。你还记得用什么来存储项目列表吗？没错——数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有的生日。为此，在类的顶部、viewDidLoad() 方法上方，插入以下行来添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量而非常量，因为你希望每次用户通过添加生日视图控制器添加生日时，将一个已保存的生日添加到这个数组中。你将在 “让 Birthdays Table View 控制器符合协议” 中看到如何做到这一点，详见 第 168 页。

**注意**

*记得项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *获取。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性，以便将出生日期显示为格式化字符串。请在 birthdays 数组下方添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

注意，dateFormatter 是一个常量，它是通过 let 创建的。尽管你会改变 dateFormatter 的属性，比如 dateStyle 和 timeStyle ，但你永远不会改变 dateFormatter 本身。

你还需要设置 dateFormatter，以便它能将出生日期显示为格式化的字符串，如 "Tuesday, December 17, 2008"。正如你在 第十章 中看到的，最佳位置是 viewDidLoad() 方法，这个方法会在 Birthdays 表格视图控制器加载视图时被调用。这是进行任何类所需设置的完美时机。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 dateFormatter 的 dateStyle，以便它为每个生日显示格式化的日期字符串。你注意到我们只写了 .full 而不是 DateFormatter.Style.full 吗？Swift 知道 DateFormatter 的 dateStyle 应该是什么类型，因此它允许我们使用这个小技巧。在 ➋ 处，你将 dateFormatter 的 timeStyle 设置为 .none，这样时间就不会显示出来。

#### 在表格视图中显示生日

BirthdaysTableViewController 类具有一个用于显示单列项目列表的表格视图。该表格视图有一个或多个部分，其中包含行，每行包含一个单元格。表格视图中的部分是行的分组，可以选择带有或不带有标题显示。一个显示具有多个部分的表格视图的应用程序示例是设置应用程序，如图 11-5 所示。它显示已被分为不同部分的行列表。

表格视图的每个部分和行都通过索引号进行标识。这些数字从 0 开始，然后随着你向下滚动表格视图而增加 1。例如，设置应用程序中的隐私行位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为 *表格视图数据源* 的部分，其中包含三个方法。表格视图控制器使用这些方法来确定其表格视图中要显示的内容。

numberOfSections(in:) 告诉表格视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表格视图在每个部分中将显示多少行

tableView(_:cellForRowAt:) 设置要显示在每一行中的每个单元格

![](img/Image00243.jpg)

*图 11-5：设置应用程序使用多个部分将不同的设备设置分组。*

每次重新加载表格视图时，表格视图控制器都会调用表格视图的数据源方法。Xcode 在你创建 UITableViewController 子类时会自动提供这些方法模板。你需要实现这三个方法中的所有方法，尽管你在代码中永远不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，协议中包含这些数据源方法，用于确定将显示在表格视图中的内容。我们将在“委托”第 166 页讨论协议。目前，你只需要知道，UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，因此你无需手动调用它们。

让我们从方法 numberOfSections(in:) 开始。生日表格视图控制器是一个仅显示生日实例的列表，因此不需要多个部分。为了设置表格视图中的部分数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个 UITableView 类型的参数 tableView，表示使用这个类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内置的表格视图，并且自动将这些方法连接起来。每个生日将会显示在它自己的行中。所以在 `tableView(_:numberOfRowsInSection:)` 中，为了让表格视图有正确的行数来显示所有生日，你需要返回 `birthdays` 数组中生日实例的数量。你还记得数组的 `count` 属性吗？它是一个整数，告诉你数组中有多少个项目，非常适合这种情况！将这个方法更改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，`tableView(_:numberOfRowsInSection:)` 还接受一个名为 section 的 Int 类型参数。当表格视图加载时，这个方法会为表格视图中的每个节调用。在我们的例子中，我们只有一个节，所以不需要检查表格视图显示的是哪个节。我们知道它是第零部分，我们希望它有和生日数量相等的行数，因此我们写 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)`，这样表格视图就知道在每个单元格中放置什么内容。由于这个方法被注释掉了，你需要删除它周围的 `/*` 和 `*/` 来取消注释。（小心不要误删其他方法的注释！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要手动调用方法 `tableView(_:cellForRowAt:)`。这个方法会在表格视图加载到屏幕时自动调用。它会为屏幕上的每个单元格被调用，并接受两个参数：tableView 和 indexPath。你已经知道 tableView 参数的用途。IndexPath 是一个 Swift 结构体，用于表示表格视图中某行的位置。一个 IndexPath 实例有一个 section 属性和一个 row 属性。由于这个方法会被多次调用（每次调用时都是为了每一行），我们需要 indexPath 来知道当前正在配置的是哪个 section 和 row。indexPath.section 属性给出节号，而 indexPath.row 给出表格视图单元格的行号。`tableView(_:cellForRowAt:)` 中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 找出将要显示在单元格中的 birthdays 数组中的哪一个生日

• 创建两个标签来显示生日人的姓名和出生日期在单元格中

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。➊ 处的代码使用方法 `dequeueReusableCell(withIdentifier:for:)` 来实现这一点。然而，在你可以开始在单元格上使用这个方法之前，你需要告诉这个方法你想从故事板中使用哪个单元格。之前，当你在故事板中时，你为单元格指定了标识符 `birthdayCellIdentifier`（见 图 11-4）。这个标识符将你的代码与单元格关联，并告诉你的方法它正在使用正确的单元格。当你调用这个方法时，字符串必须与在故事板中设置的字符串完全相同，否则你会遇到错误，应用程序会崩溃。

在 `dequeueReusableCell(withIdentifier:for:)` 方法中，你注意到 "*Reusable Cell*" 这个词了吗？表格视图中的单元格是一次性创建的，然后可以反复使用。这有助于加快程序运行速度，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但屏幕上一次只能显示 10 个，那么你只需要 10 个单元格来展示这些生日。当你向下滚动以显示更多的生日时，屏幕上方滚动出去的单元格会被重新使用。它们会被填充新信息并重新出现在屏幕底部。`UITableView` 会自动完成这些工作。当表格视图加载时，`tableView(_:cellForRowAt:)` 会为每一行可见的单元格调用。当用户滚动以查看更多单元格时，它会在每一行即将出现在屏幕上时再次调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行显示 `birthdays` 数组中的一个生日。第一个生日，即 `birthdays[0]`，应该显示在第 0 行；第二个生日，即 `birthdays[1]`，应该显示在第 1 行，依此类推，这意味着 `indexPath` 的行号与我们想要访问的 `birthdays` 数组中的位置相同。➋ 处的代码通过使用 `indexPath.row` 来访问正确的生日对象。一旦我们获得了正确的生日对象，就将其赋值给一个名为 `birthday` 的常量，以便我们可以设置该单元格中的标签。

请注意，我们使用 `let` 将生日赋值给常量，而不是变量。我们可以使用 `let`，因为每次调用 `tableView(_:cellForRowAt:)` 时，都会创建一个新的生日常量。每个单元格都会获得自己的生日常量，并将其分配给自己的生日对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——因此不需要将它们设置为变量。

现在你有了单元格和生日，是时候填充详细信息了。每个单元格需要两个标签来显示生日人的姓名和出生日期。你将单元格设置为“副标题”样式，这样它就有了一个标题标签和一个副标题标签。每个单元格已经包含这些标签，因此你现在不需要自己创建标签了。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。代码 ➌ 设置 textLabel 的文本为由生日的 firstName 和 lastName 组成的字符串，中间有一个空格。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法来显示出生日期在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 会返回单元格 ➎，以便将其显示在表视图的该 indexPath 位置。

### 整合所有内容

现在，你可以通过使用“添加生日”视图控制器将生日实例添加到应用中，并且你有一个表视图来列出每个生日，在“生日表视图控制器”中显示。但是，当你尝试运行应用并添加一个生日时，它没有出现。为了让每个你添加的生日出现在表视图中，你需要让“添加生日”视图控制器与“生日表视图控制器”进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 展示在自己之上。A 知道 B 的存在，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 并不知道 A——它只是被创建出来的，并不知道自己从哪里来或怎么到的。那么 B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将工作或任务交给别人。*委托人*就像一个老板，告诉被委托的员工该做什么。当被委托的员工完成任务后，有时他们会将信息反馈给委托的老板。

Swift 中的委托非常相似，但我们不再是老板与员工的关系，而是有一个委托对象和一个委托方对象。由于是类 A 告诉类 B 做什么，所以类 B 是委托方对象。我们给类 B 一个特殊的属性，叫做 delegate，用来告诉它谁是它的委托人——这样，类 B 就知道该与谁沟通。委托人可以是任何一个拥有定义在*协议*中的方法集合的类。协议就像是两个类之间的约定，告诉它们委托人可以要求委托方做些什么。它有一个方法和属性名称的列表，委托人可以使用这些方法与委托方对象进行交互。

类 A 创建类 B，让自己成为类 B 的委托，并给类 B 分配一个协议中的任务。一旦类 B 完成了任务，它会向类 A 汇报。让我们看看这个在我们的应用中是如何工作的。

“生日表视图控制器”是视图控制器 A，“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由“添加生日”视图控制器使用来进行反馈。

请查看 图 11-6。当用户点击添加按钮 ➊ 时，Birthdays 表格视图控制器会创建 Add Birthday 视图控制器 ➋ 并将自身设置为 Add Birthday 视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，Add Birthday 视图控制器会调用这个方法 ➍ 并将新生日传递给它的委托，即 Birthdays 表格视图控制器。Birthdays 表格视图控制器会将这个生日添加到它的生日数组中，并重新加载它的表格视图 ➎ ，这样新生日就会显示在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，包含方法 addBirthdayViewController(_:didAddBirthday:)，该方法可以在每次向应用程序添加生日时由 Add Birthday 视图控制器调用。Birthdays 表格视图控制器将实现该协议方法，这样每次通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器就可以对它的委托说：“嘿！有人刚刚添加了这个生日”，然后 Birthdays 表格视图控制器就会收到这个消息并回应：“哦！我会把它加入到我的列表中，并刷新显示，这样新的生日就能显示出来。”

现在让我们在代码中实现这个功能吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的*上方*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处通过输入关键字 protocol 后跟协议名 AddBirthdayViewControllerDelegate 来定义协议。这个名字比较长，但 Swift 程序员通常会根据调用类命名协议，并在后面加上 Delegate 这个词。这样你就可以通过查看协议的名字知道是哪个类在使用这个协议。既然你现在是 Swift 程序员，你应该遵循同样的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，用于将 Birthday 对象传递回委托类 ➋ 。注意，你在这个函数中包含了 AddBirthdayViewController 作为参数。再次强调，Swift 程序员通常根据约定在实现协议方法时这么做，所以你也应该坚持这么做。这样做有助于了解是谁发送了消息，并且让委托类能够访问那个对象及其类。

当 AddBirthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递给你。你很快就会看到这是如何做到的。另一个需要注意的点是外部参数名 didAddBirthday。许多委托协议方法都包含 *did* 和 *will* 这两个词，因为它们用于描述调用类刚刚做过的或即将做的事情。

现在你已经定义了协议，需要告诉 Birthdays 表视图控制器采纳这个协议并使用协议的方法。

##### 使生日表视图控制器符合协议

为了采纳协议，Birthdays 表视图控制器需要将自身设置为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中紧跟 UITableViewController 超类后面添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，就会出现一个红色错误。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心，我们很快会修复这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，并且该超类的名称必须写在任何协议之前。但是，虽然一个类只能有一个超类，它可以采纳任意多个协议——这些协议会在超类之后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要向 Birthdays TableViewController 添加 addBirthdayViewController(_:didAddBirthday:) 方法。添加该方法的好位置是在类的末尾，紧接着导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类采纳了 AddBirthdayViewController Delegate 协议，并且它期待你添加这个方法。请注意，与子类方法不同，在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来做到这一点 ➋。接下来，你需要刷新表视图，以便它显示这个新生日，方法是调用 tableView 属性上的 reloadData() 方法 ➌。当调用 reloadData() 时，表视图的数据源方法将会重新调用，新的生日将会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释，用来标记这一部分代码：// MARK: - AddBirthdayViewControllerDelegate ➊。虽然这不是必须的，但在类中标明不同的部分是一种良好的编码风格，它有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的一个特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录中，你可以在类的顶部使用该目录。这个下拉菜单帮助你查找方法，并且可以让你跳转到代码中的不同位置。要使用此菜单，请点击编辑窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器设置委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在，是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知 Birthdays 表格视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中，在 outlets 下方插入以下一行代码来实现这一点，声明一个可选的 AddBirthdayViewControllerDelegate 类型的委托属性：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是一个可选项，因为你不能在 Add Birthday 视图控制器创建之前设置它。稍后你会学习如何设置委托。

现在，Add Birthday 视图控制器有了一个委托，在 saveTapped(_:)方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:)方法将一个 Birthday 传递给委托。将 saveTapped(_:)修改为如下代码：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象后，位于 ➊ 的代码通过 addBirthdayViewController(_:didAddBirthday:)方法将其传递回委托。

很好！你已经完成了对 Add Birthday 视图控制器的所有修改。现在它有了一个委托，可以监听生日保存的通知。运行应用程序看看发生了什么。

嗯……似乎没有什么变化。当你添加一个生日时，依然看不到它出现在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置委托连接这两个控制器

还有一件事需要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 类型的属性，保存它与之通信的委托（当一个生日被保存时）。但我们从未明确将委托属性设置为 Birthdays 表格视图控制器。所以，现在是时候连接这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个已被注释掉的方法 prepare(for:sender:)。通过删除围绕它的/*和*/来取消注释该方法。

每当“生日”表视图控制器退出其屏幕并且应用通过故事板 segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将利用这个方法将“生日”表视图控制器传递给“添加生日”视图控制器，以将其设置为“添加生日”视图控制器的委托。在 prepare(for:sender:)方法中编写以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需三行代码，就可以将“添加生日”视图控制器的委托设置为“生日”表视图控制器。首先，您需要能够通过 segue 参数访问 AddBirthdayViewController 对象。Xcode 在注释中提供了如何实现这一点的提示。一个 UIStoryboardSegue 在准备这个方法时有一个名为 destination 的属性，但本应用的 destination 并不是 AddBirthdayViewController。

在第九章中，您将“添加生日”视图控制器嵌入到一个导航控制器中，以便可以拥有带有“取消”和“保存”按钮的导航栏。因此，您不会期待在 segue 的另一端找到“添加生日”视图控制器。相反，destination 是一个包含“添加生日”视图控制器的 UINavigationController。➊行代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定子类，我们需要通过 as 将其类型转换为 UINavigationController。

接下来，您可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其类型转换为 AddBirthdayViewController，以表示这个控制器是 UIViewController 的一个特定子类。最后，当您获取到 AddBirthdayViewController 时，您可以将委托设置为 self，即当前的“生日”表视图控制器 ➌。

现在运行应用并添加一些生日！您在“生日”表视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果您退出应用然后重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 您学到的内容

在本章中，您学会了如何创建一个表视图控制器来显示生日列表。您还学会了如何在“添加生日”视图控制器中添加一个生日，并使用委托将生日添加到“生日”表视图控制器中的生日数组，以便显示它。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使退出应用程序并重新运行，它们也能显示。为了保存生日，你将使用 Core Data，这是我们在项目开始时就设置好的。

是时候展示那些生日了！在第十章中，你创建了“添加生日”视图控制器，这样你就可以使用“生日”类将新的生日对象添加到你的应用中。在这一章中，你将创建一个“生日”表格视图控制器，能够在*表格视图*中显示你添加的生日，表格视图显示一个可以滚动浏览并选择的项目列表。然后你将学习如何让“添加生日”视图控制器在添加生日对象时通知“生日”表格视图控制器，以便在表格视图中显示新添加的生日。

### 制作生日列表

添加生日是一个方面，但你还需要显示一个生日列表。为此，你需要创建另一个类，BirthdaysTableViewController，它将子类化 UITableViewController，这是一个带有表格视图的特殊视图控制器。UITableViewController 包含一些内置方法，可以让你编写代码来指定表格视图的行数以及每一行中应该显示的内容。我们希望表格视图的行数与生日的数量相同，并且每一行显示一个生日。

#### 创建生日表格视图控制器

在项目导航器中，*控制-点击*“BirthdayTracker”文件夹，并从菜单中选择**新建文件…**。在第十章中，我们创建了 Swift 文件*Birthday.swift*，Xcode 为我们准备了几乎没有内容的文件。为了这次创建一个新文件，我们将告诉 Xcode 我们想要子类化一个现有的 iOS 类。根据基础类的不同，Xcode 将创建一个包含一些代码的文件，你可以根据需要进行定制。要创建文件，选择窗口顶部的**iOS**，然后选择**Cocoa Touch Class**模板，Xcode 会自动格式化新类文件（参见图 11-1）。

![](img/Image00234.jpg)

*图 11-1：要对子类化现有的类，选择* ***iOS*** *，然后选择* ***Cocoa Touch Class.***

当你选择这个选项时，你会看到一个第二个对话框，你可以在其中为你的新类命名并指定你要子类化的类。首先，在子类字段（对话框中的第二个字段）中输入 UITableViewController。这会自动填充类字段为子类名称。一旦完成，输入 Birthdays 作为 TableViewController 前缀，使整个类名变为 BirthdaysTableViewController。这是一个快捷方式，避免你输入过多内容。确保在语言下拉菜单中选择**Swift**，然后点击**下一步**。接着在最后一个对话框中选择**创建**，以创建你的新文件。

在*BirthdaysTableViewController.swift*中，Xcode 已经提供了一个模板，包含几个注释掉的方法。你可以通过删除我们不会使用的方法来清理代码。仅删除 viewDidLoad()中的注释，然后删除整个 didReceiveMemoryWarning()方法，以及与移动表格视图中的行有关的 tableView(_:moveRowAt:to:)和 tableView(_:canMoveRowAt:)方法。完成后，BirthdaysTableViewController 的内容应如下图 11-2 所示。虽然仍然有几个被注释掉的方法，但我们保留这些方法是为了以后使用！

![](img/Image00235.jpg)

*图 11-2：已清理的* BirthdaysTableViewController *！*

接下来，你需要将生日表视图控制器设置为 BirthdaysTableViewController 类。为此，打开*Main.storyboard*，选择**生日**场景。然后，在右侧面板的身份检查器中，将类从 UITableViewController 更改为 BirthdaysTableViewController，如图 11-3 所示。

![](img/Image00236.jpg)

*图 11-3：将* BirthdaysTableViewController *设置为生日场景的类*

现在，你已经在故事板中设置了生日表视图控制器，下一步是创建表格中的单元格，用于显示每个生日。

#### 向表格视图中添加单元格

每个生日将显示在**生日**表视图控制器中的一个 UITableViewCell 中。一个表格由按行和列组织的框组成，里面包含信息。这些框被称为*单元格*。类似地，表格视图也有单元格，它们都是 UITableViewCell 类的实例或其子类。我们将在表格视图中为每个生日创建一个单独的单元格。

我们将从在故事板中创建这些单元格开始，然后稍后用我们的生日对象填充它们。在左侧大纲菜单中，点击“生日”旁边的三角形，然后点击“表格视图”旁边的三角形，以展开这些部分。然后选择**表格视图单元格** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建一个副标题样式的表格视图单元格并设置其标识符*

接下来，打开属性检查器。在**样式**的下拉菜单中，将单元格的样式设置为**副标题** ➋，这样单元格就会有一个标题标签和一个副标题标签。你将在标题中显示每个人的名字，在副标题中显示生日。

最后，在标识符字段中输入 birthdayCellIdentifier ➌。稍后你会使用这个标识符来填充单元格内容。

就这样！你已经完成了故事板中的工作。

你可能会想，为什么在我们的 Storyboard 中的表视图里只有一个单元格，而我们将要显示多个生日。如果你再次查看图 11-4，你会注意到这个单元格被标记为*原型单元格*。这意味着你刚刚自定义的单元格是所有你希望在表视图中显示的单元格的*模板*。你给单元格指定的标识符是代码如何告诉表视图生成每个单元格，以便将生日放入其中。你很快就会看到它是如何工作的。

**处理日期**

Swift 有一个特殊的数据类型，叫做 Date，用于存储日期值。一个 Date 对象实际上包含日期和时间。打开你的 Playground 并输入以下代码：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量 today。当你打印 today 时，它的格式是"2017-11-21 10:45:31 +0000\n"。如果你想让它显示为 "Tuesday, November 21, 2017" 呢？或者只是 "11/21/17" 呢？要以特定方式显示日期，你需要使用*日期格式化器*，它是一个 DateFormatter 对象，你创建并赋予它一个日期格式样式。DateFormatter 是一个辅助对象，用于根据任何日期创建显示字符串，而*日期格式样式*是 DateFormatter 的一个属性，告诉格式化器使用什么样式。你可以手动创建自己的日期格式样式，但 Swift 中也有一些现成的样式可以使用。将以下代码添加到你的 Playground 中：

![](img/Image00240.jpg)

在➊，你创建了一个格式化器。然后在➋，你将格式化器的样式设置为 Style.full，这将显示星期几以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:)方法➌将日期转换为字符串。你可以看到，日期已被转换为格式良好的字符串 "Tuesday, November 21, 2017"。表格 11-1 展示了从 Swift 中可用的五种 DateFormatter.Style 选项创建的不同字符串。

**表格 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "2017 年 11 月 21 日" |
| long | "2017 年 11 月 21 日" |
| full | "Tuesday, November 21, 2017" |

你还可以使用 DateFormatter 的 dateFormat 属性指定自己的日期显示方式。也许你只想要显示月份和日期。或者你希望以简短样式显示四位数的年份。做任何一种都非常简单，而且你甚至不需要创建一个新的 DateFormatter——你只需更改格式化器的 dateFormat 属性，然后请求它生成一个新的字符串。将以下代码添加到你的 Playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定只想要月份和日期，格式为 MM/dd——即两位数的月份后跟两位数的日期。如果你想要将月份显示为三个字母，可以使用 MMM。如果要显示月份的全名，使用 MMMM。在 ➋ 处，我们将日期格式更改为使用四位数的年份。两位数的年份则使用 yy。以下是几种使用 dateFormat 来显示自定义日期字符串的方式。

![](img/Image00242.jpg)

如果你想包含分隔符，可以将它们添加到你的 dateFormat 字符串中。例如，如果你想使用句号作为分隔符，可以创建类似“MM.dd.yy” ➊ 的 dateFormat。如果要显示简写的星期几，可以使用 EEE ➋ 。要显示完整的星期几，可以使用 EEEE ➌ 。这些只是一些例子。通过组合 M 、 d 、 y 和 E，你可以有无数种方式来显示日期！

#### 设置 Birthdays 表视图控制器

Birthdays 表视图控制器将显示应用中存储的所有生日的列表。你记得用什么来存储一组项目吗？没错——一个数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有的生日。为此，给 BirthdaysTableViewController 添加一个 birthdays 属性，类型为 Birthday 对象数组。在类的顶部，紧接着 viewDidLoad() 方法上方，插入这一行，添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量而不是常量，因为每次用户通过“添加生日”视图控制器添加一个生日时，你都希望将保存的生日添加到这个数组中。你将在“让 Birthdays 表视图控制器符合协议”中看到如何实现这一点，见第 168 页。

**注意**

*请记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *获取。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性，用于将出生日期显示为格式良好的字符串。在 birthdays 数组下方添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，通过 let 创建。即使你会改变 dateFormatter 的属性，例如 dateStyle 和 timeStyle，你也永远不会改变 dateFormatter 本身。

你还需要设置 dateFormatter，以便它将出生日期显示为完整格式的字符串，例如“Tuesday, December 17, 2008”。正如你在第十章中看到的，设置的最佳位置是在 viewDidLoad() 方法中，该方法会在 Birthdays 表视图控制器加载视图时调用。这是进行此类初始化的最佳时机。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 dateFormatter 的 dateStyle，以便它为每个生日显示格式化的日期字符串。你有没有注意到我们只是写了 .full，而不是 DateFormatter.Style.full？Swift 知道 DateFormatter 的 dateStyle 应该是什么类型，因此它允许我们使用这个小技巧。 在 ➋ 处，你将 dateFormatter 的 timeStyle 设置为 .none，以便不会显示时间。

#### 在表格视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于在单列中显示项目列表。表格视图包含一个或多个节，每个节包含行，而每行包含一个单元格。表格视图中的节是行的分组，可以显示或不显示标题。一个展示了多个节的表格视图的应用示例是设置应用，如 图 11-5 所示。它显示了被拆分为不同节的行列表。

表格视图的每个节和每一行都有一个索引号。这些数字从 0 开始，然后在表格视图中向下时每次增加 1。例如，设置应用中的隐私行位于节 0，行 1。新闻设置位于节 1，行 3。

在 BirthdaysTableViewController 类的中间，有一个名为 *Table view data source* 的部分，其中有三个方法。表格视图控制器使用这些方法来确定在其表格视图中显示的内容。

numberOfSections(in:) 告诉表格视图应该有多少个节。

tableView(_:numberOfRowsInSection:) 告诉表格视图每个节中将显示多少行。

tableView(_:cellForRowAt:) 设置将显示在表格视图每行中的每个单元格。

![](img/Image00243.jpg)

*图 11-5：设置应用使用节来分组不同设备设置的行。*

每当表格视图被重新加载时，表格视图控制器都会调用表格视图数据源方法。当你创建一个 UITableViewController 子类时，Xcode 会自动为你提供这些方法模板。你需要实现这三个方法中的所有方法，以便应用程序正常工作，即使你在代码中永远不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议带有这些数据源方法，用于确定在表格视图中显示的内容。我们将在 “委托” 第 166 页讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，所以你不需要手动调用它们。

让我们从方法 numberOfSections(in:) 开始。Birthdays 表格视图控制器是一个只显示 Birthday 实例的列表，因此它不需要多个节。为了设置表格视图中的节数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

该方法接受一个`UITableView`类型的`tableView`参数，这是使用该类作为数据源的表格视图。我们不需要担心建立这个连接，因为`UITableViewController`自带一个内置的表格视图，且自动与这些方法连接。每个生日将在自己的行中显示。因此，在`tableView(_:numberOfRowsInSection:)`中，为了确保你有正确数量的行来显示所有的生日，你需要返回`birthdays`数组中`Birthday`实例的数量。你还记得数组的`count`属性吗？它是一个整数，表示数组中有多少个元素，非常适合这种情况！将此方法改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了`tableView`参数外，`tableView(_:numberOfRowsInSection:)`方法还接受一个名为`section`的`Int`类型参数。当表格视图加载时，此方法会为表格中的每个部分调用。在我们的例子中，只有一个部分，所以我们不需要检查当前显示的是哪个部分。我们知道它是第零部分，而且我们希望它有和生日数量一样多的行，所以我们写`return birthdays.count`。

最后，你需要实现`tableView(_:cellForRowAt:)`方法，以便表格视图知道在每个单元格中放入什么内容。由于此方法被注释掉了，你需要通过删除包围它的`/*`和`*/`来取消注释。（小心不要不小心取消注释它后面的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你并不直接调用`tableView(_:cellForRowAt:)`方法。它会在表格视图加载到屏幕时被调用。它会为屏幕上的每个单元格调用，并接受两个参数，`tableView`和`indexPath`。你已经知道`tableView`参数是做什么的。`IndexPath`是一个 Swift 结构体，用来表示表格视图中某一行的位置。`IndexPath`实例有`section`属性和`row`属性。由于此方法会被多次调用（每调用一次针对表格中的每一行），我们需要使用`indexPath`来知道我们当前正在配置的是哪个部分和行。`indexPath.section`属性提供部分号，`indexPath.row`提供表格视图单元格的行号。`tableView(_:cellForRowAt:)`中的五行代码将会执行以下操作：

![](img/Image00244.jpg)

• 创建一个`UITableViewCell`

• 确定在`birthdays`数组中的哪一个生日会显示在单元格中

• 创建两个标签来显示生日人的姓名和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行查看这段代码。

首先，创建 UITableViewCell。代码在➊处通过方法 dequeueReusableCell(withIdentifier:for:)完成这项工作。不过，在你开始在单元格上使用这个方法之前，你需要告诉它你想从故事板中使用哪个单元格。早些时候，在故事板中，你为你的单元格设置了标识符 birthdayCellIdentifier（参见图 11-4）。这个标识符将你的代码与单元格关联，并告诉方法它正在使用正确的单元格。当你调用这个方法时，字符串必须与在故事板中设置的字符串完全相同，否则会出现错误，并且在运行应用时会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:)中，你注意到*Reusable Cell*这两个词了吗？表格视图中的单元格只会创建一次，然后可以反复使用。这有助于提升运行速度，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动查看更多生日时，屏幕上方滚动出去的单元格会被重复使用。它们会被填充上新的信息，然后重新出现在屏幕底部。UITableView 会自动处理这些工作。当表格视图加载时，tableView(_:cellForRowAt:)会为每一行可见的单元格被调用。当用户滚动以查看更多单元格时，它会在每个即将出现在屏幕上的行上再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望从生日数组中在每一行显示一个生日。第一个生日，即 birthdays[0]，应该显示在第 0 行。第二个生日，即 birthdays[1]，应该显示在第 1 行，依此类推，这意味着 indexPath 的 row 与我们想要访问的生日数组的位置相同。代码在➋处通过使用 indexPath.row 访问 birthday 数组中的正确 Birthday 对象。一旦我们获得了正确的 Birthday 对象，我们将其分配给一个名为 birthday 的常量，以便设置该单元格中的标签。

请注意，我们使用 let 将生日分配给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格会获得自己的生日常量，并赋予自己的 Birthday 对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以我们不需要将它们设为变量。

现在你有了单元格和生日信息，是时候填充详细内容了。你需要为每个单元格设置两个标签来显示生日人的姓名和生日日期。你将单元格设置为 Subtitle 样式，以便它有一个标题标签和一个副标题标签。每个单元格已经包含这些标签，因此现在你无需自己创建标签。

这些标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格分隔。➍ 处，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 会在 ➎ 处返回该单元格，以便它可以在表格视图的该 indexPath 上显示。

### 整合所有内容

现在，你可以使用“添加生日”视图控制器将生日实例添加到应用中，并且你有一个表格视图来列出每个生日在“生日”表格视图控制器中。但是当你尝试运行应用并添加一个生日时，它并没有出现。为了让你添加的每个生日都能出现在表格视图中，你需要让“添加生日”视图控制器与“生日”表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己之上。A 知道 B，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但 B 并不知道 A——它只是突然出现，并不知道自己从哪里来或如何到达那里。那么 B 怎么与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指将工作或任务交给别人。*委托*就像一个老板，告诉委托对象该做什么。当委托对象完成任务后，有时会将信息汇报给委托的老板。

在 Swift 中，委托与此非常相似，不过我们不再有老板和员工，而是有一个委托和一个委托对象。由于类 B 是由类 A 告诉它做什么的，所以它是委托对象。我们给类 B 设置一个特殊的属性，叫做 delegate，来告诉它谁是它的委托对象——这样它就知道应该与谁通信。委托可以是任何具有在*协议*中定义的一组方法的类。协议就像是两个类之间的约定，告诉它们委托可以要求委托对象做什么。协议有一个方法和属性的列表，委托可以用来与委托对象进行交互。

类 A 创建了类 B，将自己设置为类 B 的委托，并给类 B 分配一个协议中规定的任务。一旦类 B 完成任务，它会向类 A 汇报。让我们看看在我们的应用中这是如何工作的。

“生日”表格视图控制器是视图控制器 A，而“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法：addBirthdayViewController(_:didAddBirthday:)，该方法将由“添加生日”视图控制器用来进行汇报。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表格视图控制器创建了添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从添加生日视图控制器传递到生日表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为包含一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，添加生日视图控制器调用此方法 ➍ 并将新生日传递给它的委托——生日表格视图控制器。生日表格视图控制器接收这个生日，将其添加到它的生日数组中，然后重新加载表格视图 ➎ ，以便新添加的生日能在表格中显示出来。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并通过方法 addBirthdayViewController(_:didAddBirthday:)让添加生日视图控制器在每次添加生日时都能调用该方法。生日表格视图控制器将实现该协议方法，这样每次通过添加生日视图控制器添加生日时，添加生日视图控制器就可以对其委托说：“嘿！刚刚有人添加了这个生日，”然后生日表格视图控制器会听到这个消息并说：“哦！我会把它添加到我的列表中，并刷新显示以便新添加的生日能显示出来。”

所以现在，让我们在代码中实现这个功能吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类**上方**添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过在 ➊ 处输入关键字 protocol 来定义协议，后面跟上协议名 AddBirthdayViewControllerDelegate。这名字很长，但 Swift 程序员通常会以调用类的名字为协议命名，并在后面加上 Delegate 一词。这样，你就能通过协议的名字判断是哪个类在使用该协议。既然你现在是一个 Swift 程序员，你应该使用相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传回给委托类 ➋ 。请注意，你在这个函数中包含了 AddBirthdayViewController 作为参数。再强调一下，Swift 程序员在实现协议方法时通常会根据约定这么做，因此你也应该遵循这一约定。知道是谁发送了消息，并且让委托有机会访问该对象及其类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递进来。你很快就会看到这是如何实现的。需要注意的另一个地方是外部参数名 didAddBirthday。许多代理协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚做完或即将做的事情。

现在你已经定义了协议，接下来需要告诉 Birthdays 表格视图控制器遵循该协议并使用协议的方法。

##### 让 Birthdays 表格视图控制器遵循协议

为了遵循协议，Birthdays 表格视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，在 UITableViewController 超类后面添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加上一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色错误提示就会出现。这是因为 BirthdaysTableViewController 表示它是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！别担心——我们很快就会解决这个问题。

在这里需要特别注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，而这个超类的名称必须写在任何协议之前。但是，虽然一个类只能有一个超类，它可以遵循任意多个协议——这些协议将都列在超类之后，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays 表格视图控制器中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类遵循了 AddBirthdayViewController Delegate 协议，并且它预期你会添加这个方法。注意，与子类化方法不同，在 addBirthdayViewController(_:didAddBirthday:) 方法前你不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递的生日添加到 birthdays 数组中。你可以使用数组的 append(_:) 方法 ➋ 来实现这一点。接下来，你需要刷新表格视图，让它显示这个新的生日，通过调用 tableView 属性的 reloadData() 方法 ➌ 。当调用 reloadData() 时，表格视图的数据源方法会再次被调用，新增的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一条注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这虽然不是必须的，但良好的编码风格是标记类的不同部分，并帮助保持代码的整洁和可读性。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单帮助你查找方法，并允许你跳转到代码中的不同位置。要使用这个菜单，点击编辑器窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为添加生日视图控制器设置委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知生日表视图控制器它已经添加了一个生日。为此，添加生日视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性，并将以下代码插入到 outlets 下面来实现这一点：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在添加生日视图控制器被创建之前，你无法设置它。你很快就会学到在哪里设置委托。

现在添加生日视图控制器已经有了委托，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将一个生日传递给委托。将 saveTapped(_:)方法修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)方法将其传递给委托。

太好了！你已经完成了对添加生日视图控制器的修改。它现在有了一个委托，能够监听生日被保存的通知。运行应用程序看看会发生什么。

嗯……似乎没有什么变化。当你添加一个生日时，仍然看不到它出现在生日表视图控制器中。怎么回事？

#### 通过设置委托连接这两个控制器

还有一件事你必须做。生日表视图控制器是 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存与其通信的委托，即当生日被保存时。然而，我们从未明确地将委托属性设置为生日表视图控制器。因此，现在是时候建立我们两个视图控制器之间的通信连接了。

在“BirthdaysTableViewController”类的导航部分，有一个已被注释掉的方法 `prepare(for:sender:)`。通过删除围绕它的 `/*` 和 `*/` 来取消注释此方法。

每当“生日”表格视图控制器放弃其屏幕并且应用程序通过故事板 segue 切换到另一个视图控制器时，此方法会自动被调用。我们将使用此方法将“生日”表格视图控制器传递给“添加生日”视图控制器，并将其自身设置为“添加生日”视图控制器的代理。在 `prepare(for:sender:)` 方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的代理为“生日”表格视图控制器需要三行代码。首先，你需要能够通过 `segue` 参数访问到 `AddBirthdayViewController` 对象。Xcode 留下了一个注释，提示你如何做到这一点。一个 `UIStoryboardSegue` 有一个名为 `destination` 的属性，这个属性指向即将准备的视图控制器，但这个应用程序的目标视图控制器并不是 `AddBirthdayViewController`。

在第九章中，你将“添加生日”视图控制器嵌入到一个导航控制器中，这样就可以有一个带有取消和保存按钮的导航栏。所以你并不期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 `UINavigationController`。在➊这一行，你获取了 `navigationController`。代码 `segue.destination` 会返回一个 `UIViewController`，但由于我们的 `navigationController` 是 `UIViewController` 的特定子类，所以我们需要使用 `as` 来将其类型转换为 `UINavigationController`。

接下来，你可以获取“添加生日”视图控制器，它是 `navigationController` 的 `topViewController` ➋。`topViewController` 就是当前在 `navigationController` 中显示的视图控制器，但它的属性是 `UIViewController` 类型，因此需要将其类型转换为 `AddBirthdayViewController`，以表示这个控制器是 `UIViewController` 的一个特定子类。最后，当你获得了 `AddBirthdayViewController` 后，可以将代理设置为 `self`，即当前的“生日”表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在“生日”表格视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用程序然后再次运行它，之前的生日将会消失。我们仍然需要将生日保存到设备中，这部分内容将在第十二章中完成。

### 你学到了什么

在这一章中，你学会了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，然后如何使用代理将生日添加到“生日”表格视图控制器中的生日数组，以便显示出来。

在第十二章中，你将学习如何将生日保存到你的设备上，这样即使退出应用程序并重新运行，它们仍然会显示出来。为了保存生日，你将使用 Core Data，这是我们在项目一开始时就已经设置好的。

### 创建生日列表

能够添加生日是一回事，但你还需要显示生日列表。为此，你需要创建另一个类，`BirthdaysTableViewController`，它将继承自`UITableViewController`，后者是一种带有表格视图的特殊视图控制器。`UITableViewController`包含多个内置方法，允许你编写代码来处理表格视图的行数以及每一行应显示的内容。我们希望表格视图的行数与生日数目相同，并且每一行显示一个生日。

#### 创建生日表格视图控制器

在项目导航栏中，按住 CONTROL 键点击*BirthdayTracker*文件夹，然后从菜单中选择**New File…**。在第十章中，我们创建了 Swift 文件*Birthday.swift*，该文件几乎没有任何内容，是由 Xcode 为我们准备的。为了这次创建新文件，我们将告诉 Xcode 我们要继承一个现有的 iOS 类。根据基类的不同，Xcode 会创建一个包含一些代码的文件，你可以根据需要进行自定义。创建文件时，选择窗口顶部的**iOS**，然后选择**Cocoa Touch Class**模板，这将自动格式化新的类文件（参见图 11-1）。

![](img/Image00234.jpg)

*图 11-1：要继承一个现有类，选择* ***iOS*** *，然后选择* ***Cocoa Touch Class***。

当你选择这个选项时，你将看到第二个对话框，在那里你可以为新类命名并指定你将要继承的类。首先，在“Subclass”字段（对话框中的第二个字段）中输入`UITableViewController`。这将自动填充类字段，显示子类名。接着，输入`Birthdays`作为`TableViewController`的前缀，使得整个类名变为`BirthdaysTableViewController`。这是一个快捷方式，免去了你需要输入的部分。确保在“Language”下拉菜单中选择**Swift**，然后点击**Next**。接下来，在最后一个对话框中选择**Create**来创建你的新文件。

在`BirthdaysTableViewController.swift`中，Xcode 提供了一个模板，里面有几个被注释掉的方法。你可以通过删除我们不使用的方法来清理代码。首先删除`viewDidLoad()`中的注释，然后删除整个`didReceiveMemoryWarning()`方法，以及与表格视图中的行移动相关的`tableView(_:moveRowAt:to:)`和`tableView(_:canMoveRowAt:)`方法。完成后，`BirthdaysTableViewController`的内容应该像图 11-2 所示。尽管仍然有几个被注释掉的方法，但我们会保留这些方法，以便以后使用！

![](img/Image00235.jpg)

*图 11-2：清理后的* `BirthdaysTableViewController` *！*

接下来，你需要将生日表视图控制器设置为 BirthdaysTableViewController 类。为此，打开*Main.storyboard*并选择**生日**场景。使用右侧窗格中的身份检查器，将类从 UITableViewController 更改为 BirthdaysTableViewController，如图 11-3 所示。

![](img/Image00236.jpg)

*图 11-3：设置* BirthdaysTableViewController *作为生日场景的类*

现在，你已经在故事板中设置好了生日表视图控制器，下一步是创建表格中的单元格，以显示每个生日。

#### 向表视图添加单元格

每个生日将显示在生日表视图控制器中的 UITableViewCell 内。一个表格由按行和列组织的框组成，框内包含信息。这些框被称为*单元格*。同样，表视图也有单元格，这些单元格都是 UITableViewCell 类的实例或子类。我们将在表视图中为每个生日创建一个单独的单元格。

我们将首先在故事板中创建这些单元格，然后稍后再填充我们的生日对象。在左侧大纲菜单中，点击**生日**旁边的三角形，然后点击**表视图**旁边的三角形以打开这些部分。然后选择**表视图单元格** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建副标题样式的表视图单元格并设置其标识符*

接下来，打开属性检查器。在**样式**下的下拉菜单中，将单元格的样式设置为**副标题** ➋，这样单元格就会有一个标题标签和一个副标题标签。你将把每个人的名字显示在标题中，生日显示在副标题中。

最后，在标识符字段 ➌ 中输入 birthdayCellIdentifier。稍后在填充单元格内容时，你将使用这个标识符。

就这样！你已经完成了在故事板中的工作。

你可能会想，为什么在故事板中的表视图只有一个单元格，而列表中要显示的不止一个生日。如果你再次查看图 11-4，你会注意到单元格被标记为*原型单元格*。这意味着你刚刚自定义的单元格是所有你希望在表视图中显示的单元格的*模板*。你为单元格指定的标识符将告诉代码如何生成每个单元格以填充生日信息。你很快就会看到这个如何运作。

**处理日期**

Swift 有一个特殊的数据类型叫做 Date，用于存储日期值。Date 对象实际上包含日期和时间。打开你的 playground 并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给了变量 today。当你打印 today 时，它的格式是 "2017-11-21 10:45:31 +0000\n"。如果你想要它显示为 "2017 年 11 月 21 日，星期二" 或者只是 "11/21/17" 呢？要以特定方式显示日期，你需要使用一个 *日期格式化器*，它是一个 DateFormatter 对象，你可以创建并为其指定一个日期格式样式。DateFormatter 是一个辅助对象，用于从任何日期创建显示字符串，而 *日期格式样式* 是 DateFormatter 的一个属性，告诉格式化器使用哪种样式。你可以手动创建自己的日期格式样式，但 Swift 中也包含了一些可以直接使用的样式。将以下内容添加到你的 Playground 中：

![](img/Image00240.jpg)

在 ➊ 处，你创建了一个格式化器。然后在 ➋ 处，你将格式化器的样式设置为 Style.full，这将打印出星期几以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:) 方法从日期中创建一个字符串 ➌。你可以看到，现在你已经将日期转换为格式良好的字符串 "2017 年 11 月 21 日，星期二"。表格 11-1 展示了从 Swift 中五种 DateFormatter.Style 选项所创建的不同字符串。

**表格 11-1:** 日期格式化样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "2017 年 11 月 21 日" |
| long | "2017 年 11 月 21 日" |
| full | "2017 年 11 月 21 日，星期二" |

你还可以通过 DateFormatter 的 dateFormat 属性指定自己的日期显示方式。也许你只想要显示月份和日期，或者你可能想在短样式中显示四位数的年份。做这两件事都非常简单，你甚至不需要创建一个新的 DateFormatter ——你只需更改 formatter 的 dateFormat，然后请求它生成一个新的字符串。将以下代码添加到你的 Playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定只想要月份和日期，使用 MM/dd 格式——也就是两位数的月份，后面跟着两位数的日期。如果你想将月份显示为三个字母的缩写，可以使用 MMM。如果你想显示月份的全名，使用 MMMM。在 ➋ 处，我们将日期格式更改为使用四位数的年份。两位数的年份使用 yy。以下是一些使用 dateFormat 显示自定义日期字符串的其他方式。

![](img/Image00242.jpg)

如果你想要包含分隔符，可以将它们添加到 dateFormat 字符串中。例如，如果你想要使用句点作为分隔符，你可以创建一个类似 "MM.dd.yy" 的 dateFormat ➊。要显示缩写的星期几，使用 EEE ➋。要显示完整的星期几，使用 EEEE ➌。这只是一些示例。通过组合 M、d、y 和 E，你可以有无限多种方式来显示日期！

#### 设置生日表视图控制器

Birthdays 表格视图控制器将显示存储在应用中的所有生日列表。您还记得用什么来存储项目列表吗？没错——是数组！您将在 BirthdaysTableViewController 中创建一个数组来存储所有生日。为此，在类的顶部，紧接在 viewDidLoad()方法上方，插入这一行，添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量而不是常量，因为每次用户通过添加生日视图控制器添加一个生日时，您都需要将其保存到这个数组中。您将在“让 Birthdays 表格视图控制器遵循协议”中看到如何操作，第 168 页也会详细说明。

**注意**

*请记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *获得。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性，以便将出生日期显示为格式良好的字符串。在 birthdays 数组下面添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，通过 let 创建。即使您会更改 dateFormatter 的属性，例如 dateStyle 和 timeStyle，您也永远不会更改 dateFormatter 本身。

您还需要设置 dateFormatter，以便它可以显示完整格式的出生日期字符串，如“2008 年 12 月 17 日，星期二”。正如您在第十章中看到的，做这项工作的好地方是在 viewDidLoad()方法中，这个方法会在 Birthdays 表格视图控制器加载其视图时调用。这是进行此类任何设置的最佳位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在➊处，您设置了 dateFormatter 的 dateStyle，这样它就会为每个生日显示格式化的日期字符串。您是否注意到我们只是写了.full，而不是 DateFormatter.Style.full？Swift 知道 dateFormatter 的 dateStyle 应该是什么类型，因此它允许我们使用这个小的快捷方式。在➋处，您将 dateFormatter 的 timeStyle 设置为.none，这样就不会显示时间。

#### 在表格视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于显示单列项目列表。该表格视图包含一个或多个包含行的区段，每行包含一个单元格。表格视图中的区段是按行分组的，可以选择是否显示标题。显示多个区段的表格视图的应用示例是设置应用，如图 11-5 所示。它显示了已分为不同区段的行列表。

表格视图的每个分区和行都通过索引号来标识。这些数字从 0 开始，然后随着你向下滚动表格视图逐渐增加。例如，设置应用中的隐私选项位于分区 0，第 1 行。新闻设置位于分区 1，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为 *Table view data source* 的部分，其中包含三个方法。表格视图控制器使用这些方法来确定将要在表格视图中显示的内容。

`numberOfSections(in:)` 告诉表格视图应该有多少个分区

`tableView(_:numberOfRowsInSection:)` 告诉表格视图每个分区将显示多少行

`tableView(_:cellForRowAt:)` 设置将显示在每一行中的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用程序使用分区来将不同设备设置的行分组。*

表格视图的数据源方法会在每次表格视图重新加载时由表格视图控制器调用。当你创建 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。即使你在代码中不会直接调用这些方法，你也需要实现所有三个方法才能让应用正常工作。UITableViewController 类实现了 UITableViewDataSource 协议，这个协议包含这些数据源方法，用于确定将显示在表格视图中的内容。我们将在 “委托” 一节的第 166 页讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，所以你不需要手动调用它们。

让我们从方法 `numberOfSections(in:)` 开始。Birthdays 表格视图控制器是一个仅显示生日实例的列表，因此它不需要多个分区。为了设置表格视图的分区数，我们只需返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接收一个名为 `tableView` 的 UITableView 作为参数，它是使用此类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内置的表格视图，并且这个表格视图会自动与这些方法连接。每个生日将在其自己的行中显示。因此，在 `tableView(_:numberOfRowsInSection:)` 中，为了确保所有生日的行数正确，你需要返回 `birthdays` 数组中生日实例的数量。你还记得数组的 `count` 属性吗？它是一个整数，告诉你数组中有多少项，正好适合这个情况！将这个方法修改为如下：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了`tableView`参数，`tableView(_:numberOfRowsInSection:)`方法还接收一个`Int`类型的`section`参数。当表格视图加载时，这个方法会为表格视图中的每个节调用。在我们的例子中，我们只有一个节，因此不需要检查当前显示的是哪个节。我们知道它是节 0，并希望它包含和生日人数一样多的行，因此我们写`return birthdays.count`。

最后，你需要实现`tableView(_:cellForRowAt:)`，以便表格视图知道在每个单元格中放置什么内容。由于这个方法被注释掉了，你需要通过删除/*和*/来取消注释它。（小心不要不小心取消注释后面的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你并没有直接调用方法`tableView(_:cellForRowAt:)`。它是在表格视图加载到屏幕时自动调用的。它会为屏幕上的每个单元格调用，并接收两个参数，`tableView`和`indexPath`。你已经知道`tableView`参数的用途。`IndexPath`是一个 Swift 结构体，用于表示表格视图中某一行的位置。`IndexPath`实例有`section`属性和`row`属性。由于这个方法会被多次调用（每个表格行调用一次），我们需要`indexPath`来知道当前正在配置的是哪个 section 和 row。`indexPath.section`属性返回节的编号，而`indexPath.row`则返回表格视图单元格的行号。`tableView(_:cellForRowAt:)`方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个`UITableViewCell`

• 找出`birthdays`数组中哪一个`Birthday`将在单元格中显示

• 在单元格中创建两个标签来显示生日人物的名字和出生日期

• 返回准备好在表格视图中显示的单元格

让我们逐行查看这段代码。

首先，创建`UITableViewCell`。代码中的➊部分通过`dequeueReusableCell(withIdentifier:for:)`方法实现了这一点。在你开始在单元格上使用这个方法之前，你需要告诉该方法你想从故事板中使用哪个单元格。早些时候，在故事板中，你为你的单元格指定了标识符`birthdayCellIdentifier`（参见图 11-4）。这个标识符将你的代码与单元格连接起来，并告诉你的方法它正在使用正确的单元格。当你调用这个方法时，字符串必须与在故事板中设置的字符串完全相同，否则会出现错误，导致应用程序崩溃。

在方法 dequeueReusableCell(withIdentifier:for:) 中，你注意到 *可重用单元格* 这个词了吗？表格视图中的单元格只会被创建一次，然后可以反复重用。这帮助所有内容运行得更快、更流畅，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日，但一次只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你滚动下去显示更多生日时，滚出屏幕顶部的单元格会被重用。它们会填充新的信息，并重新出现在屏幕的底部。UITableView 会自动完成这项工作。当表格视图加载时，tableView(_:cellForRowAt:) 会为每个可见的行调用一次。当用户滚动以查看更多单元格时，它会再次为每个即将出现在屏幕上的行调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行显示一个来自生日数组的生日。第一个生日，在 birthdays[0] 处，应显示在第 0 行。第二个生日，在 birthdays[1] 处，应显示在第 1 行，依此类推，这意味着 indexPath 的行号与我们想要访问的生日数组中的位置相同。代码 ➋ 使用 indexPath.row 从生日数组中访问正确的 Birthday 对象。一旦我们得到了正确的 Birthday 对象，就将其赋值给名为 birthday 的常量，以便设置该单元格中的标签。

请注意，我们使用 let 将生日赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都会得到它自己的生日常量，并赋值给它自己的 Birthday 对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以不需要将它们定义为变量。

现在你有了单元格和生日，是时候填充详细信息了。你需要为每个单元格添加两个标签，用来显示生日人物的姓名和出生日期。你将单元格设置为副标题样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，因此你无需自己创建任何标签。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。代码 ➌ 将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格隔开。在 ➍ 中，你使用 dateFormatter 的 string(from:) 方法，将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好时，tableView( _:cellForRowAt:) 会返回位于 ➎ 的单元格，以便它可以在该 indexPath 的表格视图中显示。

### 将一切整合在一起

现在，你可以使用添加生日视图控制器将生日实例添加到应用中，并且你有一个表格视图来列出每个生日，在生日表视图控制器中显示。但是当你尝试运行应用并添加一个生日时，它并没有显示出来。为了让你添加的每个生日出现在表格视图中，你需要让添加生日视图控制器与生日表视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将其呈现到自己之上。A 知道 B，因为它创建并呈现了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它刚刚被创建出来，并不知道自己是从哪里来的，也不知道如何到达这里。那么 B 该如何与 A 沟通呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将任务或工作交给其他人。*委托*就像是老板告诉委托员工该做什么。当委托员工完成任务时，有时他们会将信息报告给老板。

Swift 中的委托机制非常相似，但与其说是有一个老板和一个员工，不如说是有一个委托和一个委托对象。由于类 B 是由类 A 告诉它该做什么的，所以它是委托对象。我们给类 B 一个特殊的属性，叫做 delegate，用来告诉它它的委托是谁——这样，类 B 就知道要与谁通信。委托可以是任何具有在*协议*中定义的一组方法的类。协议就像是两个类之间的约定，告诉它们委托可以要求委托对象做什么。它有一份方法和属性名称的列表，委托可以使用这些方法和属性与委托对象进行交互。

类 A 创建类 B，将自己设置为类 B 的委托，并给类 B 分配一个协议中的任务。一旦类 B 完成任务，它会向类 A 报告。让我们看看在我们的应用中是如何工作的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用于报告结果。

看一下图 11-6。当用户点击添加按钮➊时，生日表视图控制器创建添加生日视图控制器➋，并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日通过委托从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为包含一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮➌时，Add Birthday 视图控制器会调用这个方法➍并将新的生日对象传递给它的委托——Birthdays Table View Controller。Birthdays Table View Controller 接收到这个生日对象后，将其添加到自己的生日数组中，并重新加载表格视图➎，以便新添加的生日能出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并在其中定义 addBirthdayViewController(_:didAddBirthday:)方法，这样当添加生日到应用时，Add Birthday 视图控制器就可以调用这个方法。Birthdays Table View Controller 将实现这个协议方法，这样当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器可以告诉它的委托，“嘿！有人刚刚添加了这个生日，”而 Birthdays Table View Controller 会接收到这个消息并回应，“哦！我会将它添加到我的列表中并刷新显示，以便新添加的生日能出现在表格中。”

现在，让我们开始编写代码吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类*上方*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你可以在➊定义这个协议，通过输入关键字 protocol，后面跟着协议名称 AddBirthdayViewControllerDelegate。这个名字比较长，但 Swift 程序员通常会根据调用类的名称命名协议，并在后面加上 Delegate 这个词。这样，你可以通过查看协议的名称来判断哪个类正在使用这个协议。既然你现在已经是 Swift 程序员了，应该遵循这种命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传回委托类➋。请注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。Swift 程序员通常会根据约定在实现协议方法时这么做，所以你也应该遵循这一做法。了解是谁发送了消息并且让委托类能够访问该对象及其类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它将自身作为 addBirthdayViewController 参数传递。你很快就会看到如何做到这一点。另一个要注意的点是外部参数名称 didAddBirthday。许多委托协议方法包含*did*和*will*这两个词，因为它们用于描述调用类已经做过的事情或将要做的事情。

现在你已经定义好了协议，你需要告诉 Birthdays Table View Controller 去采纳这个协议并使用该协议的方法。

##### 让 Birthdays Table View Controller 符合协议

要采用这个协议，Birthdays 表视图控制器需要让自己成为一个 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，紧跟 UITableViewController 超类后，添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色错误就会出现。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快会解决这个问题。

在这里需要注意，BirthdaysTableViewController 是继承自 UITableViewController 超类的。一个类只能有一个超类，并且该超类的名称必须写在所有协议之前。但虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议会列在超类之后，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 BirthdaysTableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的添加位置是类的末尾，就在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它预期你会添加这个方法。注意，与子类化方法不同，*在 addBirthdayViewController(_:didAddBirthday:) 前你不需要使用 override 关键字*，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将由 Add Birthday 视图控制器传递进来的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现 ➋。接下来，你需要刷新表格视图，显示这个新添加的生日，通过调用 tableView 属性的 reloadData() 方法 ➌。当调用 reloadData() 时，表格视图的数据源方法会再次被调用，新的 Birthday 会显示在生日列表的底部。

你可能注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这并不是必须的，但这是良好的编码风格，可以将类的不同部分标记出来，并帮助保持代码的整洁和可读性。注释的第一部分，MARK: -，是一个 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部可用的下拉目录菜单中。这个下拉菜单帮助你找到方法，并让你快速跳转到代码中的不同位置。要使用此菜单，请点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类内置了一个目录，可以快速跳转到某个部分。*

##### 为添加生日视图控制器设置委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议，告知 Birthdays 表视图控制器它已添加一个生日。为此，添加生日视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个可选的委托属性（类型为 AddBirthdayViewControllerDelegate），并将以下代码插入到 outlets 下面来安排这一点：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为你无法在*添加生日视图控制器创建之前*设置它。你很快就会学到在哪里设置委托。

现在，添加生日视图控制器已经有了一个委托，在 saveTapped(_:)方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:)方法将一个生日传递给委托。将 saveTapped(_:)修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码在➊位置通过 addBirthdayViewController(_:didAddBirthday:)方法将其传递回委托。

太好了！你已经完成了对添加生日视图控制器的更改。它现在有了一个委托，用于监听“生日已保存”这一事件。运行应用程序看看会发生什么。

嗯……变化不大。当你添加一个生日时，仍然看不到它在 Birthdays 表视图控制器中显示。怎么回事？

#### 通过设置委托连接两个控制器

还有一件事需要做。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，存储它与之沟通的委托对象——即在生日保存时与之对话的对象。但我们从未明确地将委托属性设置为 Birthdays 表视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个被注释掉的方法，名为`prepare(for:sender:)`。通过删除/*和*/来取消注释这个方法。

这个方法会在“生日”表视图控制器放弃其屏幕并且应用通过 storyboard segue 过渡到另一个视图控制器时自动调用。我们将使用这个方法将“生日”表视图控制器传递到“添加生日”视图控制器中，并将其设置为“添加生日”视图控制器的代理。在`prepare(for:sender:)`方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的代理为“生日”表视图控制器需要三行代码。首先，你需要能够从`segue`参数中获取`AddBirthdayViewController`对象。Xcode 在注释中给出了一个提示，告诉你如何做到这一点。`UIStoryboardSegue`有一个属性叫做`destination`，它表示正在准备的 segue 的另一端，但这个应用的目的地并不是`AddBirthdayViewController`。

在第九章中，你将“添加生日”视图控制器嵌入到导航控制器中，以便有一个包含“取消”和“保存”按钮的导航栏。所以你不会期望在 segue 的另一端找到“添加生日”视图控制器。相反，目的地是一个包含“添加生日”视图控制器的`UINavigationController`。➊的这一行代码将获取到`navigationController`。`segue.destination`将返回一个`UIViewController`，但由于我们的`navigationController`是`ViewController`的特定类型，我们需要通过`as`将其类型转换为`UINavigationController`。

接下来，你可以获取“添加生日”视图控制器，它是`navigationController`的`topViewController` ➋。`topViewController`只是当前在`navigationController`中显示的视图控制器，但它的属性类型是`UIViewController`，所以必须将其类型转换为`AddBirthdayViewController`，以指示这个控制器是`UIViewController`的特定子类。最后，当你拥有一个`AddBirthdayViewController`时，你可以将代理设置为`self`，即当前的“生日”表视图控制器 ➌。

现在运行应用并添加一些生日！你在生日表视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用再重新启动，之前添加的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在这一章中，你学习了如何创建一个表视图控制器来显示生日列表。你还学会了如何在“添加生日”视图控制器中添加生日，然后使用代理将生日添加到“生日”表视图控制器中的生日数组，从而使其能够显示出来。

在 第十二章 中，你将学习如何将生日保存到你的设备中，以便即使退出应用并重新启动后，生日依然显示出来。为了保存生日，你将使用 Core Data，这是我们在项目开始时就设置好的。

能够添加生日是很重要的，但你还需要展示一个生日列表。为此，你需要创建另一个类 BirthdaysTableViewController，它将继承自 UITableViewController，这是一个带有表格视图的特殊视图控制器。UITableViewController 包含几个内置方法，允许你编写代码，决定表格视图应该有多少行，以及每一行应该展示什么内容。我们希望有和生日数量一样多的行，并且在每一行中展示一个生日。

#### 创建生日表格视图控制器

在项目导航器中 *BirthdayTracker* 文件夹上 **控制点击**，然后从菜单中选择 **New File…**。在 第十章 中，我们创建了 Swift 文件 *Birthday.swift*，Xcode 为我们准备了一个几乎为空的文件。这次创建新文件时，我们告诉 Xcode 要继承一个现有的 iOS 类。根据基类的不同，Xcode 将创建一个包含一些代码的文件，你可以根据需要进行自定义。为了创建文件，选择窗口顶部的 **iOS**，然后选择 **Cocoa Touch Class** 模板，这将自动格式化新类文件（见 图 11-1）。

![](img/Image00234.jpg)

*图 11-1：要继承现有类，选择* ***iOS*** *然后选择* ***Cocoa Touch Class***。

当你选择这个选项时，你会看到第二个对话框，在这里你可以为新类命名并指定它将继承哪个类。首先，在子类字段（对话框中的第二个字段）中输入 UITableViewController。这样会自动填充类字段为子类名称。一旦完成，输入 Birthdays 并放在 TableViewController 前面，使得整个类名变成 BirthdaysTableViewController。这是一个快捷方式，可以避免输入过多内容。确保在语言下拉菜单中选择 **Swift**，然后点击 **Next**。接着，在最后一个对话框中选择 **Create** 来创建你的新文件。

在 *BirthdaysTableViewController.swift* 中，Xcode 提供了一个模板，其中包含了几个已注释掉的方法。你可以通过去除我们不会使用的方法来清理代码。只需删除 viewDidLoad() 中的注释，然后删除整个 didReceiveMemoryWarning() 方法，以及与表格视图中行的移动相关的 tableView(_:moveRowAt:to:) 和 tableView(_:canMoveRowAt:) 方法。完成后，BirthdaysTableViewController 的内容应如下所示 图 11-2。仍然有几个注释掉的方法，但我们保留这些方法以备后用！

![](img/Image00235.jpg)

*图 11-2：已清理的* BirthdaysTableViewController *！*

接下来，你需要将生日表视图控制器的类设置为 BirthdaysTableViewController 类。为此，打开*Main.storyboard*，并选择**生日**场景。使用右侧窗格中的身份检查器，将类从 UITableViewController 更改为 BirthdaysTableViewController，如图 11-3 所示。

![](img/Image00236.jpg)

*图 11-3：将*BirthdaysTableViewController*设置为生日场景的类*

现在你已经在故事板中设置好了生日表视图控制器，下一步是创建表格中的单元格，用于显示每个生日。

#### 向表视图添加单元格

每个生日将显示在生日表视图控制器的 UITableViewCell 中。表格有按行和列组织的框，这些框包含信息。这些框被称为*单元格*。类似地，表视图也有单元格，它们都是 UITableViewCell 类的实例或子类。我们将在表视图中为每个生日创建一个单独的单元格。

我们将从在故事板中创建这些单元格开始，然后稍后再将我们的生日对象填充到单元格中。在左侧大纲菜单中，点击“生日”旁边的三角形，然后点击“表视图”旁边的三角形以展开这些部分。接着选择**表视图单元格** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建一个副标题样式的表视图单元格并设置其标识符*

接下来，打开属性检查器。在**样式**下拉菜单中，将单元格样式设置为**副标题** ➋，这样单元格就会有一个标题标签和一个副标题标签。你将在标题中显示每个人的名字，在副标题中显示生日。

最后，在标识符字段中输入 birthdayCellIdentifier ➌。稍后你将在填充单元格内容时使用这个标识符。

就这样！你已经完成了在故事板中的工作。

你可能会想，为什么我们在故事板中的表视图里只有一个单元格，而列表中将显示多个生日。如果你再看一遍图 11-4，你会注意到单元格被标记为*原型单元格*。这意味着你刚刚自定义的单元格是你想在表视图中显示的所有单元格的*模板*。你为单元格设置的标识符就是代码用来告诉表视图为你生成每个单元格并放入生日信息的方式。你很快就会看到这个是如何工作的。

**处理日期**

Swift 有一种特殊的数据类型叫做 Date，用于存储日期值。Date 对象实际上包含一个日期和一个时间。打开你的 Playground 并输入以下代码：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间分配给变量 today。当你打印 today 时，它的格式为"2017-11-21 10:45:31 +0000\n"。如果你希望它显示为"2017 年 11 月 21 日，星期二"呢？或者只是"11/21/17"呢？要以特定方式显示日期，你需要使用*日期格式化器*，这是一种 DateFormatter 对象，你创建它并为其指定日期格式样式。DateFormatter 是一个辅助对象，用于从任何日期创建显示字符串，而*日期格式样式*是 DateFormatter 的一个属性，告诉格式化器使用什么样式。你可以手动创建自己的日期格式样式，但 Swift 中也有一些预定义的样式可以直接使用。将以下代码添加到你的游乐场中：

![](img/Image00240.jpg)

在➊处，你创建了一个格式化器。然后在➋处，你将格式化器的样式设置为 Style.full，这将打印出星期几以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:)方法在➌处将日期转化为字符串。你可以看到，现在你已经将日期转化为格式良好的字符串"Tuesday, November 21, 2017"。表格 11-1 展示了使用 Swift 中五种 DateFormatter.Style 选项生成的不同日期字符串。

**表格 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "2017 年 11 月 21 日" |
| long | "2017 年 11 月 21 日" |
| full | "2017 年 11 月 21 日，星期二" |

你还可以通过 DateFormatter 的 dateFormat 属性指定自定义的日期显示方式。也许你只想显示月份和日期，或者你可能希望年份显示为四位数的简短样式。无论哪种方式都非常简单，你甚至不需要创建一个新的 DateFormatter——只需更改格式化器的 dateFormat 属性，然后请求一个新的字符串即可。将以下代码添加到你的游乐场中，以显示特定格式的日期：

![](img/Image00241.jpg)

在➊处，你指定只希望以 MM/dd 格式显示月份和日期——即，先显示两位数的月份，再显示两位数的日期。如果你想将月份显示为三个字母，可以使用 MMM。要显示完整的月份名称，使用 MMMM。在➋处，我们将日期格式更改为使用四位数的年份。两位数的年份使用 yy。以下是一些其他使用 dateFormat 显示自定义日期字符串的方法。

![](img/Image00242.jpg)

如果你想包含分隔符，可以将它们添加到 dateFormat 字符串中。例如，如果你希望使用句点作为分隔符，可以创建一个像"MM.dd.yy"的 dateFormat ➊。要显示简短的星期几，可以使用 EEE ➋。要显示完整的星期几，可以使用 EEEE ➌。这些只是几个例子。通过使用 M、d、y 和 E 的组合，你可以有无数种方式来显示日期！

#### 设置生日表格视图控制器

生日表格视图控制器将显示应用中存储的所有生日的列表。你记得用什么来存储项目列表吗？没错——是数组！你将在 `BirthdaysTableViewController` 中创建一个数组来存储所有的生日。为此，给 `BirthdaysTableViewController` 添加一个名为 `birthdays` 的属性，该属性是一个 `Birthday` 对象的数组。在类的顶部，紧接着 `viewDidLoad()` 方法上方，插入这一行来添加一个名为 `birthdays` 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 `Birthday` 实例数组。它需要是一个变量，而不是常量，因为你每次用户通过添加生日视图控制器添加生日时，都想将一个保存的生日添加到这个数组中。你将在 “使生日表格视图控制器符合协议” 中了解如何做到这一点，见 第 168 页。

**注意**

*记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

`BirthdaysTableViewController` 还需要一个 `dateFormatter` 属性来将生日日期显示为格式良好的字符串。在 `birthdays` 数组下方添加一个 `dateFormatter`：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，`dateFormatter` 是一个常量，它是通过 `let` 创建的。即使你会更改 `dateFormatter` 的属性，如 `dateStyle` 和 `timeStyle`，你也不会更改 `dateFormatter` 本身。

你还需要设置 `dateFormatter`，以便它将生日日期显示为格式完整的字符串，例如 "2008 年 12 月 17 日，星期二"。正如你在 第十章 中看到的，进行此设置的好地方是在 `viewDidLoad()` 方法中，该方法在 `Birthdays` 表格视图控制器加载视图时被调用。这是进行该类所需任何设置的完美时机。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 `dateFormatter` 的 `dateStyle`，这样它就会为每个生日显示一个格式化的日期字符串。你注意到我们直接写了 `.full` 而不是 `DateFormatter.Style.full` 吗？Swift 知道 `DateFormatter` 的 `dateStyle` 应该是什么类型，所以它允许我们使用这个小的简写。 在 ➋ 处，你设置了 `dateFormatter` 的 `timeStyle` 为 `.none`，以确保不显示时间。

#### 在表格视图中显示生日

`BirthdaysTableViewController` 类有一个表格视图，用于显示单列的项目列表。表格视图包含一个或多个包含行的分区，每行包含一个单元格。表格视图中的一个分区是包含行的组，这些行可以有或没有标题。例如，显示多个分区的表格视图应用是设置（Settings）应用，如 图 11-5 所示。它显示了一个已被分成不同分区的行列表。

表视图的每个部分和行都由索引号标识。这些数字从 0 开始，然后随着向下滚动表视图逐渐增加。例如，设置应用中的隐私行位于部分 0，第 1 行。新闻设置位于部分 1，第 3 行。

在 BirthdaysTableViewController 类的中间部分，有一个名为 *表视图数据源* 的部分，其中包含三个方法。表视图控制器使用这些方法来确定表视图中将显示的内容。

numberOfSections(in:) 告诉表视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表视图每个部分中将显示多少行

tableView(_:cellForRowAt:) 设置每一行中将要显示的每个单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分来对不同的设备设置进行分组。*

每次表视图重新加载时，表视图控制器都会调用表视图数据源方法。当你创建 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现所有三个方法，才能使应用程序正常工作，尽管你永远不会在代码中直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用于确定表视图中将显示的内容。我们将在 “委托” 一节中讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，因此你无需手动调用它们。

让我们从方法 numberOfSections(in:) 开始。Birthdays 表视图控制器是一个仅显示 Birthday 实例的列表，因此它不需要多个部分。为了设置表视图中的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法将一个名为 tableView 的 UITableView 作为参数，该表视图使用此类作为数据源。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内置的表视图，该视图会自动与这些方法连接。在每个生日都会显示在自己的一行中。因此，在 tableView(_:numberOfRowsInSection:) 中，为了确保显示所有生日的正确行数，你需要返回你在 birthdays 数组中的 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少个项目，非常适合这种情况！将这个方法修改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了`tableView`参数，`tableView(_:numberOfRowsInSection:)`还接受一个名为`section`的`Int`。当表格视图加载时，这个方法会为每个部分调用。在我们的例子中，我们只有一个部分，所以不需要检查表格视图中显示的是哪一部分。我们知道它是部分 0，并且希望它的行数与生日的数量相等，因此我们写`return birthdays.count`。

最后，你需要实现`tableView(_:cellForRowAt:)`，以便表格视图知道每个单元格中应该放入什么内容。由于这个方法被注释掉了，你需要通过删除包围它的`/*`和`*/`来取消注释它。（小心不要不小心取消注释它之后的其他方法！）完成这一步后，改成如下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用`tableView(_:cellForRowAt:)`方法。它是在表格视图加载到屏幕上时被调用的。它会为屏幕上的每个单元格调用，并接受两个参数，`tableView`和`indexPath`。你已经知道`tableView`参数的作用。`IndexPath`是一个 Swift 结构体，用来表示表格视图中某一行的位置。`IndexPath`实例有`section`属性和`row`属性。由于这个方法会被多次调用（每次为表格中的一行），我们需要`indexPath`来知道当前正在配置的是哪个部分和哪一行。`indexPath.section`属性提供部分号，`indexPath.row`提供表格视图单元格的行号。`tableView(_:cellForRowAt:)`内部的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个`UITableViewCell`

• 确定在`birthdays`数组中哪个生日将显示在单元格内

• 创建两个标签以在单元格中显示生日人物的姓名和出生日期

• 返回准备好在表格视图中显示的单元格

让我们逐行查看这段代码。

首先，创建`UITableViewCell`。代码在➊处使用`dequeueReusableCell(withIdentifier:for:)`方法完成这项任务。不过，在你开始使用这个方法之前，需要告诉它你希望使用哪个单元格。早些时候，在故事板中，你给你的单元格指定了`birthdayCellIdentifier`（见图 11-4）。这个标识符将你的代码与单元格关联，并告诉你的方法它正在使用正确的单元格。当你调用这个方法时，传入的字符串需要与在故事板中设置的字符串完全一致，否则你会遇到错误，应用程序在运行时会崩溃。

在方法 `dequeueReusableCell(withIdentifier:for:)` 中，你注意到 *可重用单元格* 这几个字了吗？表视图中的单元格只创建一次，然后可以反复重用。这有助于加快速度并使操作更加流畅，因为创建单元格是最耗时的。如果你的应用中有 200 个生日，但每次屏幕上只能显示 10 个，那么你只需要 10 个单元格来展示这些生日。当你向下滚动以显示更多的生日时，屏幕上方滚动出去的单元格将被重用。它们会被填充新信息，并再次出现在屏幕的底部。`UITableView` 会自动处理这个工作。当表视图加载时，`tableView(_:cellForRowAt:)` 会为每个可见行调用一次。当用户滚动以查看更多单元格时，每次即将出现在屏幕上的行也会调用该方法。

接下来，我们需要找出应显示在单元格中的生日。我们希望在每一行显示 `birthdays` 数组中的一个生日。数组中的第一个生日，即 `birthdays[0]`，应该显示在第 0 行；第二个生日，`birthdays[1]`，应该显示在第 1 行，以此类推，这意味着 `indexPath` 的 `row` 与我们想要访问的 `birthdays` 数组中的位置相同。➋ 处的代码通过使用 `indexPath.row` 访问 `birthdays` 数组中的正确 `Birthday` 对象。一旦我们获得了正确的 `Birthday` 对象，就将其赋值给一个名为 `birthday` 的常量，以便我们可以设置该单元格中的标签。

请注意，我们使用 `let` 来将生日分配给常量，而不是变量。我们可以使用 `let`，因为每次调用 `tableView(_:cellForRowAt:)` 时，都会创建一个新的生日常量。每个单元格都有自己独立的生日常量，并且该常量被赋予自己的 `Birthday` 对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以不需要将它们设置为变量。

现在你已经有了单元格和生日，是时候填充详细信息了。每个单元格需要两个标签来显示生日人物的姓名和出生日期。你将单元格设置为副标题样式，这样它就有了一个标题标签和一个副标题标签。每个单元格已经包含这些标签，所以现在你不需要自己创建标签了。

这些标签作为 `UITableViewCell` 的属性存在，分别叫做 `textLabel` 和 `detailTextLabel`。➌ 处的代码将 `textLabel` 的文本设置为由生日人物的 `firstName` 和 `lastName` 组成的字符串，两者之间有一个空格。在 ➍ 处，你使用 `dateFormatter` 的 `string(from:)` 方法来将出生日期显示在 `detailTextLabel` 中。

当你的单元格完全配置好后，`tableView(_:cellForRowAt:)` 会在 ➎ 返回该单元格，以便它可以在表视图的对应 `indexPath` 位置显示。

### 整合所有内容

现在，你可以使用添加生日视图控制器向应用程序中添加生日实例，并且有一个表视图列出每个生日，这些生日显示在生日表视图控制器中。但是，当你尝试运行应用程序并添加一个生日时，它并没有显示。为了让每个你添加的生日出现在表视图中，你需要使添加生日视图控制器与生日表视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 呈现到 A 之上。A 知道 B，因为它创建并呈现了 B，所以 A 可以将信息传递给 B。但 B 并不了解 A——它只是被弹出来的，不知道自己从哪里来，也不知道怎么到达那里的。那么，B 如何与 A 进行通信呢？通过委托！

![](img/Image00245.jpg)

委托是当某人将任务或工作交给别人做时。*委托*就像是一个老板，告诉委托的员工该做什么。当委托的员工完成任务后，有时他们会将信息报告给委托的老板。

在 Swift 中，委托（Delegation）非常相似，但我们没有老板和员工，而是有委托者和委托对象。由于类 B 是被类 A 指派做事情的，因此它是委托对象。我们为类 B 设置了一个特殊的属性，叫做 delegate，用来告诉它它的委托者是谁——这样它就知道该与谁通信。委托者可以是任何具有在*协议*中定义的方法集的类。协议就像是两个类之间的约定，告诉它们委托者可以要求委托对象做什么。协议中列出了委托者可以与委托对象一起使用的方法和属性名称。

类 A 创建类 B，使自己成为类 B 的委托，并给类 B 一个协议中规定的任务。一旦类 B 完成了任务，它会向类 A 报告。让我们看看在我们的应用程序中是如何工作的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将被添加生日视图控制器用来报告返回信息。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，AddBirthday 视图控制器调用这个方法 ➍ 并将新的生日信息传递给它的代理——Birthdays 表视图控制器。Birthdays 表视图控制器接收到这个生日信息后，将其添加到自己的 birthdays 数组中，然后重新加载表视图 ➎，这样新添加的生日就会出现在表格中。

我们将向您展示如何创建一个 AddBirthdayViewControllerDelegate 协议，其中包含 addBirthdayViewController(_:didAddBirthday:)方法，这样 Add Birthday 视图控制器每当向应用程序中添加生日时都可以调用它。Birthdays 表视图控制器将实现该协议方法，这样每当通过 Add Birthday 视图控制器添加一个生日时，Add Birthday 视图控制器就可以对其代理说：“嘿！有人刚刚添加了这个生日，”然后 Birthdays 表视图控制器会收到这个消息并说：“哦！我会把它添加到我的列表中，并刷新显示以便新生日能显示出来。”

那么现在我们来实现代码吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类的*上方*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

您通过输入关键字 protocol 并跟随协议名称 AddBirthdayViewControllerDelegate 来定义协议 ➊。这个名称虽然很长，但 Swift 程序员通常会根据调用类的名称来命名协议，并在末尾加上 Delegate 一词。这是为了让您通过查看协议的名称就能知道哪个类正在使用该协议。既然您现在是 Swift 程序员，您也应该遵循这种命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传递回代理类 ➋。请注意，您在这个函数中包含了 AddBirthdayViewController 作为一个参数。再次强调，Swift 程序员在实现协议方法时，通常会遵循这种约定，所以您也应该坚持这样做。知道是谁发送回了消息并让代理能够访问该对象及其类是非常有用的。

当 Add Birthday 视图控制器调用此方法时，它会将自己作为 addBirthdayViewController 参数传递。您很快就会看到这如何实现。另一个需要注意的点是外部参数名 didAddBirthday。许多代理协议方法都包含了*did*和*will*这两个词，因为它们用于描述调用类刚刚做了某事或者即将做某事。

现在您已经定义了协议，接下来需要告诉 Birthdays 表视图控制器遵循这个协议并使用协议中的方法。

##### 使 Birthdays 表视图控制器遵循协议

为了遵循该协议，Birthdays 表视图控制器需要使自己成为 AddBirthdayViewControllerDelegate 。为此，你需要在类定义中，紧接着 UITableViewController 超类后添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate ：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色错误就会出现。这是因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate ，但是它还没有实现这个协议！为了实现它，我们需要在后面进行修复。

这里需要特别注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，并且超类的名称必须在任何协议之前写出。但是，尽管一个类只能有一个超类，它可以采用任意多个协议——这些协议都会在超类之后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个好的添加位置是在类的末尾，就在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类遵循了 AddBirthdayViewControllerDelegate 协议，并且它期望你添加这个方法。注意，不同于子类化的方法，在 addBirthdayViewController(_:didAddBirthday:) 前你不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递的 Birthday 添加到 birthdays 数组中。你可以通过使用 append(_:) 方法来实现这一点 ➋。接下来，你需要刷新表视图，以便它能显示这个新的生日，方法是调用 tableView 属性上的 reloadData() 方法 ➌。当 reloadData() 被调用时，表视图的数据源方法将会再次被调用，新增的 Birthday 会显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但标记类的不同部分是良好的编码风格，它有助于保持代码的清晰和可读性。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，用于代码注释，并将 AddBirthdayViewControllerDelegate 部分添加到下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你查找方法，并让你跳转到代码中的不同位置。要使用这个菜单，点击编辑器窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 给 Add Birthday 视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来通知 Birthdays 表视图控制器它已添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 outlets 下方插入以下代码来安排这一点，为 AddBirthdayViewController 类添加一个可选的代理属性，类型为 AddBirthdayViewControllerDelegate：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是一个可选类型，因为在创建 Add Birthday 视图控制器之前你无法设置它。你将很快学到在哪里设置代理。

现在，Add Birthday 视图控制器有了代理，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将一个 Birthday 传递给代理。将 saveTapped(_:) 修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 将其传回给代理。

很好！你已经完成了对 Add Birthday 视图控制器的修改。它现在有一个代理，能够监听生日已保存的调用。运行应用程序，看看发生了什么。

嗯……似乎没有太大变化。当你添加一个 Birthday 时，依然没有看到它出现在 Birthdays 表视图控制器中。这是怎么回事？

#### 通过设置代理连接两个控制器

你还需要做最后一件事。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，当保存生日时，它会与代理进行通信。但是我们从未明确设置代理属性为 Birthdays 表视图控制器。所以现在是时候连接两个视图控制器之间的通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个被注释掉的方法`prepare(for:sender:)`。通过删除/*和*/来取消注释该方法。

每当`Birthdays`表视图控制器放弃其屏幕并且应用程序通过故事板 segue 过渡到另一个视图控制器时，系统会自动调用此方法。我们将使用这个方法将`Birthdays`表视图控制器传递给`Add Birthday`视图控制器，并将其设置为`Add Birthday`视图控制器的代理。在`prepare(for:sender:)`方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

仅需要三行代码即可将`Add Birthday`视图控制器的代理设置为`Birthdays`表视图控制器。首先，您需要能够通过 segue 参数访问`AddBirthdayViewController`对象。Xcode 留下了一个注释，提示您如何做到这一点。`UIStoryboardSegue`有一个名为`destination`的属性，它指向正在此方法中准备的 segue 的另一端，但对于此应用程序来说，目标并不是`AddBirthdayViewController`。

在第九章中，您将`Add Birthday`视图控制器嵌入到导航控制器中，这样您就可以拥有带有“取消”和“保存”按钮的导航栏。因此，您不会期望在 segue 的另一端找到`Add Birthday`视图控制器。相反，目标是一个包含`Add Birthday`视图控制器的`UINavigationController`。➊处的代码获取了`navigationController`。代码`segue.destination`会返回一个`UIViewController`，但由于我们的`navigationController`是一个特定类型的视图控制器，我们需要通过`as`将其类型转换为`UINavigationController`。

接下来，您可以获取`Add Birthday`视图控制器，它是`navigationController`的`topViewController` ➋。`topViewController`是指当前在`navigationController`中显示的视图控制器，但它的属性类型是`UIViewController`，因此必须将其类型转换为`AddBirthdayViewController`，以表明这个控制器是`UIViewController`的一个特定子类。最后，当你得到`AddBirthdayViewController`后，你可以将其代理设置为`self`，即当前的`Birthdays`表视图控制器 ➌。

现在运行应用并添加一些生日！在`Birthdays`表视图控制器中你看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序并重新运行，之前添加的生日将会消失。我们仍然需要将生日保存到设备上，这将在第十二章中完成。

### 你学到了什么

在本章中，您学习了如何创建一个表视图控制器来显示您的生日列表。您还学会了如何在`Add Birthday`视图控制器中添加生日，然后通过代理将生日添加到`Birthdays`表视图控制器中的生日数组中，以便显示。

在 第十二章 中，你将学习如何将生日保存到设备上，以便即使退出应用程序后再次运行时，它们仍然会显示。要保存生日，你将使用我们在项目开始时设置的 Core Data。

#### 创建 BIRTHDAYS 表格视图控制器

控制键 - 单击 *BirthdayTracker* 文件夹，在项目导航器中选择菜单中的 **New File…**。在 第十章 中，我们创建了 Swift 文件 *Birthday.swift*，这是 Xcode 为我们准备的几乎为空的文件。要这次创建一个新文件，我们将告诉 Xcode 我们想要继承一个现有的 iOS 类。根据基类的不同，Xcode 会创建一个包含一些代码的文件，你可以根据需要进行自定义。要创建文件，请选择窗口顶部的 **iOS**，然后选择 **Cocoa Touch Class** 模板，这将自动格式化新类文件（参见 图 11-1）。

![](img/Image00234.jpg)

*图 11-1：要继承现有类，请选择* ***iOS*** *然后选择* ***Cocoa Touch Class***。

当你选择这个选项时，你会看到第二个对话框，在这里你可以为新类命名并指定你将要继承的类。首先，在子类字段（对话框中的第二个字段）中，输入 UITableViewController 。这将自动将子类名填入类字段。一旦完成，在 TableViewController 前面输入 Birthdays，使得整个类名变为 BirthdaysTableViewController 。这是一个快捷方式，这样你就不必输入这么多。确保在语言下拉菜单中选择 **Swift**，然后点击 **Next**。然后在最后一个对话框中选择 **Create** 来创建你的新文件。

在 *BirthdaysTableViewController.swift* 中，Xcode 提供了一个模板，包含几个注释掉的方法。你可以通过删除我们不需要的方法来清理代码。只需删除 viewDidLoad() 中的注释，然后删除整个 didReceiveMemoryWarning() 方法，以及与在表格视图中移动行相关的 tableView(_:moveRowAt:to:) 和 tableView(_:canMoveRowAt:) 方法。完成后，BirthdaysTableViewController 的内容应如 图 11-2 所示。虽然仍然有几个被注释掉的方法，但我们会保留它们，稍后会用到！

![](img/Image00235.jpg)

*图 11-2：* BirthdaysTableViewController *已清理！*

接下来，你需要将 Birthdays 表格视图控制器设置为 BirthdaysTableViewController 类。为此，打开 *Main.storyboard* 并选择 **Birthdays** 场景。使用右侧窗格中的 Identity Inspector，将类从 UITableViewController 改为 BirthdaysTableViewController ，如 图 11-3 所示。

![](img/Image00236.jpg)

*图 11-3：将* BirthdaysTableViewController *设置为 Birthdays 场景的类*

现在你已经在 storyboard 中设置好了`Birthdays`表格视图控制器，下一步是创建表格中的单元格，用于显示每个生日。

#### 向表格视图添加单元格

每个生日将在`Birthdays`表格视图控制器的`UITableViewCell`中显示。表格由组织成行和列的框组成，这些框包含信息，这些框被称为*单元格*。类似地，表格视图也有单元格，它们都是`UITableViewCell`类的实例或其子类。我们将把每个生日放入表格视图中的一个单元格。

我们将首先在 storyboard 中创建这些单元格，然后稍后再用我们的生日对象填充它们。在左侧大纲菜单中，点击`Birthdays`旁边的三角形，然后点击`Table View`旁边的三角形，打开这些部分。然后选择**表格视图单元格**➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建副标题样式的表格视图单元格并设置其标识符*

接下来，打开属性检查器。在**样式**下的下拉菜单中，选择**副标题**样式➋，这样单元格就会有一个标题标签和一个副标题标签。你将在标题标签中显示每个人的名字，在副标题标签中显示生日。

最后，在标识符字段中输入`birthdayCellIdentifier`➌。稍后你将在填充单元格内容时使用这个标识符。

就这样！你已经完成了在 storyboard 中的工作。

你可能会想，为什么在 storyboard 中的表格视图里只有一个单元格，而我们在列表中要显示多个生日？如果你再次查看图 11-4，你会注意到该单元格被标记为*原型单元格*。这意味着你刚刚自定义的单元格是所有你希望出现在表格视图中的单元格的*模板*。你为单元格指定的标识符将告诉代码如何生成每个单元格，以便你放入生日信息。你很快就会看到它是如何工作的。

**处理日期**

Swift 有一种特殊的数据类型叫做`Date`，用于存储日期值。`Date`对象实际上包含了日期和时间。打开你的 playground 并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量`today`。当你打印`today`时，它的格式是“2017-11-21 10:45:31 +0000\n”。如果你希望它显示为“2017 年 11 月 21 日星期二”呢？或者只是“11/21/17”呢？要以特定的方式显示日期，你需要使用*日期格式化器*，它是一个`DateFormatter`对象，你可以创建它并设置日期格式样式。`DateFormatter`是一个帮助对象，用于从任何日期创建显示字符串，而*日期格式样式*是`DateFormatter`的一个属性，用于告诉格式化器应使用何种样式。你可以手动创建自己的日期格式样式，但 Swift 也提供了一些预定义的样式，方便直接使用。将以下内容添加到你的 playground 中：

![](img/Image00240.jpg)

在 ➊ 处，你创建了一个格式化器。然后在 ➋ 处，你将格式化器的样式设置为 Style.full，这将打印出星期几以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:) 方法从日期中创建一个字符串 ➌。你可以看到，现在你已经将日期转换成了格式良好的字符串 "Tuesday, November 21, 2017"。 表格 11-1 展示了通过 Swift 中五种 DateFormatter.Style 选项创建的不同日期字符串。

**表格 11-1：** 日期格式器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| 无 | "" |
| 短格式 | "11/21/17" |
| 中等 | "Nov 21, 2017" |
| 长格式 | "November 21, 2017" |
| 完整格式 | "Tuesday, November 21, 2017" |

你还可以通过 DateFormatter 的 dateFormat 属性指定自定义的日期显示方式。也许你只想显示月份和日期，或者你希望年份以四位数的短格式显示。实现这两种方式都非常简单，你甚至不需要创建新的 DateFormatter——你只需更改格式化器的 dateFormat 属性，然后请求它返回新的字符串。将以下代码添加到你的 playground，以特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定了只想要以 MM/dd 格式显示月份和日期——即两位数的月份后跟两位数的日期。如果你想以三个字母显示月份，可以使用 MMM。如果要显示完整的月份名称，则使用 MMMM。在 ➋ 处，我们更改日期格式，使用四位数的年份。两位数的年份可以用 yy 表示。以下是几种使用 dateFormat 显示自定义日期字符串的方式。

![](img/Image00242.jpg)

如果你想包含分隔符，可以将它们添加到你的 dateFormat 字符串中。例如，如果你想使用句点作为分隔符，那么可以创建一个像 "MM.dd.yy" 这样的 dateFormat ➊。要显示缩写的星期几，使用 EEE ➋。要显示完整的星期几，使用 EEEE ➌。这些只是一些示例。通过组合 M、d、y 和 E，你可以有无数种方式来显示日期！

#### 设置生日表视图控制器

生日表视图控制器将显示应用中存储的所有生日列表。你还记得用什么存储一组项目吗？没错——是数组！你将在 BirthdaysTableViewController 中创建一个数组，用于存储所有的生日。为此，在类的顶部（紧接在 viewDidLoad() 方法之前），插入以下代码来添加一个名为 birthdays 的数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量而不是常量，因为每当用户通过 Add Birthday 视图控制器添加一个生日时，你希望将其保存到这个数组中。你将看到如何在“让 Birthdays Table View Controller 遵循协议”中做到这一点，参见 第 168 页。

**注意**

*记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *获取。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性，以便将出生日期显示为格式良好的字符串。请在 birthdays 数组下面添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个用 `let` 创建的常量。尽管你会改变 dateFormatter 的属性，比如 dateStyle 和 timeStyle，但你永远不会改变 dateFormatter 本身。

你还需要设置 dateFormatter，使其能够将出生日期显示为完全格式化的字符串，例如 "Tuesday, December 17, 2008"。正如你在第十章中看到的，进行此操作的一个好地方是 viewDidLoad() 方法，该方法会在 Birthdays 表格视图控制器加载视图时被调用。这是进行任何必要设置的完美位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 dateFormatter 的 dateStyle，使其能够为每个生日显示一个格式化的日期字符串。你是否注意到我们只是写了 `.full` 而不是 `DateFormatter.Style.full`？Swift 知道 DateFormatter 的 dateStyle 需要什么类型，所以它允许我们使用这个简便的写法。在 ➋ 处，你将 dateFormatter 的 timeStyle 设置为 `.none`，以便不显示时间。

#### 在表格视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于在单列中显示项的列表。表格视图包含一个或多个包含行的部分，每行包含一个单元格。表格视图中的一个部分是包含行的分组，可以显示带有或不带有标题。一个展示多个部分的表格视图应用示例是设置应用，如图 11-5 所示。它显示了一些行，这些行被分成不同的部分。

表格视图的每个部分和每行都通过索引号来标识。这些数字从 0 开始，然后随着你向下滚动表格视图而增加。例如，在设置应用中，隐私选项位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为 *Table view data source* 的部分，包含三个方法。表格视图控制器使用这些方法来决定在其表格视图中显示什么内容。

numberOfSections(in:) 告诉表格视图它应该有多少个部分。

tableView(_:numberOfRowsInSection:) 告诉表格视图每个 section 中将显示多少行。

tableView(_:cellForRowAt:) 设置将要在每行中显示的每个单元格。

![](img/Image00243.jpg)

*图 11-5：设置应用使用 section 将不同设备设置的行分组。*

表格视图的数据源方法每次表格视图重新加载时都会由表格视图控制器调用。Xcode 会在你创建一个 UITableViewController 的子类时自动为你提供这些方法模板。你需要实现这三个方法，才能使应用正常工作，尽管你不会在代码中直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用来确定表格视图中将显示什么内容。我们将在 “委托” 第 166 页讨论协议。目前，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，所以你不需要调用它们。

让我们从方法 numberOfSections(in:) 开始。Birthdays 表格视图控制器是一个仅显示 Birthday 实例的列表，因此它不需要多个 section。要设置表格视图中的 section 数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 tableView 的 UITableView 作为参数，这是使用该类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内建的表格视图，并且这些方法会自动与其连接。每个生日都会显示在自己的行中。所以在 tableView(_:numberOfRowsInSection:) 中，为了正确显示所有生日的行数，你需要返回你在 birthdays 数组中拥有的 Birthday 实例的数量。你记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少个项目，非常适合这种情况！将这个方法修改为如下：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，tableView(_:numberOfRowsInSection:) 还接受一个名为 section 的 Int。当表格视图加载时，这个方法会被调用以处理表格视图中的每个 section。在我们的例子中，我们只有一个 section，所以我们不需要担心检查哪个 section 被显示。我们知道它是 section 0，我们希望它有与生日数量相同的行数，所以我们写 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:) 使表格视图知道每个单元格中应该放置什么内容。由于这个方法已被注释掉，你需要通过删除 /* 和 */ 来取消注释它。（小心不要不小心取消注释后面的其他方法！）在你完成这一操作后，将其修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法 tableView(_:cellForRowAt:)。当表格视图加载到屏幕上时，它会被调用。它会为屏幕上的每个单元格调用，并接受两个参数，tableView 和 indexPath。你已经知道 tableView 参数是干什么的。IndexPath 是一个 Swift 结构体，用于表示表格视图中某一行的位置。一个 IndexPath 实例有一个 section 属性和一个 row 属性。由于这个方法会被多次调用（每一行都会调用一次），我们需要 indexPath 来知道当前正在配置的是哪个 section 和 row。indexPath.section 属性返回 section 编号，而 indexPath.row 返回表格视图单元格的行号。tableView(_:cellForRowAt:)中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定在生日数组中哪个生日将在单元格内显示

• 创建两个标签，在单元格中显示生日人的名字和出生日期

• 返回准备好在表格视图中显示的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。➊处的代码使用了方法 dequeueReusableCell(withIdentifier:for:)来实现这一点。然而，在你开始使用这个方法之前，你需要告诉方法你想使用哪个单元格，通常是从 Storyboard 中指定的。早些时候，在 Storyboard 中，你给单元格设置了标识符 birthdayCellIdentifier（见图 11-4）。这个标识符将你的代码与单元格连接起来，并告诉方法它正在使用正确的单元格。当你调用这个方法时，字符串需要与 Storyboard 中设置的字符串完全相同，否则你会遇到错误，应用会在运行时崩溃。

在方法 dequeueReusableCell(withIdentifier:for:)中，你注意到“*可重用单元格*”这几个字了吗？表格视图中的单元格只会创建一次，然后可以反复重用。这有助于提高性能，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多的生日时，滚出屏幕顶部的单元格会被重用。它们会被填充上新的信息，并重新出现在屏幕底部。UITableView 会自动完成这项工作。当表格视图加载时，tableView(_:cellForRowAt:)会为每个可见的行调用。当用户滚动查看更多单元格时，它会在每个即将出现在屏幕上的行上再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行显示来自生日数组的一个生日。第一个生日，即`birthdays[0]`，应该显示在第 0 行；第二个生日，即`birthdays[1]`，应该显示在第 1 行，以此类推，这意味着 indexPath 的行数与我们想要访问的生日数组中的位置相同。代码➋通过使用`indexPath.row`来从生日数组中访问正确的生日对象。一旦我们有了正确的生日对象，我们将其赋值给一个名为`birthday`的常量，以便设置此单元格中的标签。

请注意，我们使用`let`将生日赋值给常量，而不是变量。我们可以使用`let`是因为每次调用`tableView(_:cellForRowAt:)`时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并为其分配自己的生日对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以我们不需要将它们设置为变量。

现在，您已经有了单元格和生日对象，是时候填充细节了。每个单元格需要两个标签来显示生日人的姓名和出生日期。您将单元格设置为“副标题”样式，这样它就有了标题标签和副标题标签。每个单元格已经包含这些标签，所以现在您不需要自己创建标签了。

标签作为`UITableViewCell`的属性存在，分别叫做`textLabel`和`detailTextLabel`。代码➌将`textLabel`的文本设置为由生日的`firstName`和`lastName`组成的字符串，中间用空格隔开。在➍处，您使用`dateFormatter`的`string(from:)`方法将出生日期显示在`detailTextLabel`中。

当单元格完全配置好后，`tableView(_:cellForRowAt:)`会在➎处返回该单元格，以便在表格视图的该 indexPath 处显示。

### 将所有内容整合在一起

现在，您可以使用“添加生日”视图控制器将生日实例添加到应用中，并且您有一个表格视图来列出每个生日，位于“生日”表格视图控制器中。但是，当您尝试运行应用并添加生日时，生日不会显示。为了让每个添加的生日出现在表格视图中，您需要使“添加生日”视图控制器与“生日”表格视图控制器进行通信。您可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设您有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 展示在自己之上。A 知道 B，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但 B 不知道 A——它只是突然出现的，根本不知道它从哪里来或怎么到达的。那么，B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项任务或工作交给他人。*委托人*就像一个老板，告诉下属员工该做什么。当下属员工完成任务后，有时他们会将信息报告给老板。

在 Swift 中，委托非常相似，但不是由老板和员工组成，而是由委托和委托对象组成。由于是类 A 告诉类 B 做什么，因此类 B 是委托对象。我们给类 B 一个特殊的属性叫做 delegate，告诉它谁是它的委托—这样它就知道与谁沟通。委托可以是任何一个有一套方法的类，这些方法是在*协议*中定义的。协议就像是两者之间的协议，告诉它们委托可以要求委托对象做什么。它包含一系列方法和属性名称，委托可以使用这些方法与委托对象交互。

类 A 创建类 B，使自己成为类 B 的委托，并给类 B 分配一个协议中的任务。一旦类 B 完成任务，它会向类 A 报告结果。让我们看看在我们的应用程序中是如何工作的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用于报告结果。

请查看图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议定义了一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，添加生日视图控制器调用此方法 ➍ 并将新的生日传递给它的委托，即生日表视图控制器。生日表视图控制器将该生日添加到其生日数组中，然后重新加载其表视图 ➎ 以便新添加的生日显示在表格中。

我们将向您展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义 addBirthdayViewController(_:didAddBirthday:) 方法，添加生日视图控制器可以在每次向应用程序添加生日时调用该方法。生日表视图控制器将实现该协议方法，这样每当通过添加生日视图控制器添加生日时，添加生日视图控制器可以直接对其委托说：“嘿！有人刚刚添加了这个生日。” 生日表视图控制器会收到这个信息并说：“哦！我会把它加入我的列表并刷新显示，以便新的生日显示出来。”

现在，让我们在代码中实现这一点！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，*在* AddBirthdayViewController 类的上方，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处定义协议，通过输入关键字 protocol，后面跟着协议名 AddBirthdayViewControllerDelegate。这是个很长的名字，但 Swift 程序员通常会根据调用类的名称命名协议，并在末尾加上 Delegate 这个词。这样你就能通过查看协议的名称知道是哪个类在使用该协议。既然你现在是 Swift 程序员，应该遵循相同的命名惯例。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传回委托类 ➋ 。请注意，你在这个函数中包括了 AddBirthdayViewController 作为参数。再次提醒，Swift 程序员在实现协议方法时基于惯例这么做，所以你也应该坚持这样做。知道是谁发回了消息，并且让委托访问该对象及其类是非常有用的。

当 AddBirthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递给方法。你很快就会看到是如何做到的。另一个需要注意的是外部参数名称 didAddBirthday。许多委托协议方法都包含 *did* 和 *will*，因为它们用来描述调用类刚刚做过的事或将要做的事。

现在你已经定义了协议，你需要告诉 Birthdays 表格视图控制器采纳这个协议并使用该协议的方法。

##### 使 Birthdays 表格视图控制器符合协议

为了采用这个协议，Birthdays 表格视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在 UITableViewController 超类后立即将 AddBirthdayViewControllerDelegate 添加到类定义中。在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做了，红色错误就会出现。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会解决这个问题。

在这里需要注意的是，BirthdaysTableViewController 是继承自 UITableViewController 超类的。一个类只能有一个超类，且该超类名称必须在任何协议之前写出。但尽管一个类只能有一个超类，它可以采用任意多个协议——这些协议将被列在超类之后，并用逗号分隔。

现在，为了符合`AddBirthdayViewControllerDelegate`协议并修复错误，我们需要将`addBirthdayViewController(_:didAddBirthday:)`方法添加到`Birthdays TableViewController`中。一个好的位置是在类的末尾，紧接着导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动补全会建议整个方法声明。这是因为它知道这个类采纳了`AddBirthdayViewController Delegate`协议，并且它期望你添加这个方法。注意，与子类化方法不同，你在`addBirthdayViewController(_:didAddBirthday:)`前不需要使用`override`关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将由*Add Birthday*视图控制器传入的生日添加到生日数组中。你可以通过使用数组的`append(_:)`方法来完成这一操作 ➋。接下来，你需要刷新表格视图，以便显示这个新添加的生日，方法是调用表格视图的`reloadData()`方法 ➌。当调用`reloadData()`时，表格视图的数据源方法会被重新调用，新的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：`// MARK: - AddBirthdayViewControllerDelegate` ➊。这不是必须的，但在代码中标记不同的部分是良好的编码风格，它有助于保持代码整洁且易于阅读。注释的第一部分，`MARK: -`，是 Xcode 识别的特殊关键字，它将`AddBirthdayViewControllerDelegate`部分添加到一个可用于类顶部的下拉目录菜单中。这个下拉菜单帮助你快速找到方法并跳转到代码中的不同位置。要使用此菜单，请点击编辑窗格顶部的`Birthdays TableViewController`，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类具有内置的目录，方便快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器指定一个委托

`BirthdaysTableViewController`已经采纳了`AddBirthdayViewControllerDelegate`协议。现在是时候让`Add Birthday`视图控制器使用`AddBirthdayViewControllerDelegate`协议，通知生日表格视图控制器它已经添加了一个生日。为此，`Add Birthday`视图控制器首先需要定义一个委托。我们通过在`AddBirthdayViewController`类的 outlets 下面添加一行代码来安排这一点，定义一个类型为`AddBirthdayViewControllerDelegate`的可选委托属性：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是一个可选项，因为在*Add Birthday*视图控制器创建之前，你无法设置它。稍后你将学习如何设置委托。

现在，`Add Birthday`视图控制器有了一个委托，在`saveTapped(_:)`方法中，你可以通过`addBirthdayViewController(_:didAddBirthday:)`方法将一个生日对象传递给委托。将`saveTapped(_:)`更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊处的代码通过`addBirthdayViewController(_:didAddBirthday:)`将其传递回委托。

太棒了！你已经完成了对`Add Birthday`视图控制器的修改。现在它有了一个委托，会监听生日被保存的调用。运行应用程序查看发生了什么。

嗯...没有太大变化。当你添加一个生日时，它仍然没有出现在`Birthdays`表格视图控制器中。这是怎么回事？

#### 通过设置委托连接两个控制器

你还需要做最后一件事。`Birthdays`表格视图控制器是一个`AddBirthdayViewControllerDelegate`，而`Add Birthday`视图控制器有一个`AddBirthdayViewControllerDelegate`属性，保存了它在生日保存时与之通信的委托。但我们从未明确地将委托属性设置为`Birthdays`表格视图控制器。所以现在是时候在这两个视图控制器之间建立通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个被注释掉的方法`prepare(for:sender:)`。通过删除它周围的/*和*/，取消注释该方法。

当`Birthdays`表格视图控制器放弃其屏幕并且应用程序通过故事板 segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将`Birthdays`表格视图控制器传递给`Add Birthday`视图控制器，以便将其自身设置为`Add Birthday`视图控制器的委托。在`prepare(for:sender:)`方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置`Add Birthday`视图控制器的委托为`Birthdays`表格视图控制器需要三行代码。首先，你需要能够通过 segue 参数访问到`AddBirthdayViewController`对象。Xcode 已经留下了一个注释，提示你如何做这一点。`UIStoryboardSegue`有一个叫做`destination`的属性，它代表了这个方法中准备的 segue 的目标，但这个应用的目标并不是`AddBirthdayViewController`。

在第九章中，你将`Add Birthday`视图控制器嵌入到一个导航控制器中，以便你可以拥有一个带有“取消”和“保存”按钮的导航栏。所以你不会在 segue 的另一端找到`Add Birthday`视图控制器。相反，目标是一个包含`Add Birthday`视图控制器的`UINavigationController`。➊处的代码可以让你访问到`navigationController`。代码`segue.destination`将返回一个`UIViewController`，但是由于我们的`navigationController`是特定类型的`ViewController`，我们需要使用`as`将其类型转换为`UINavigationController`。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须强制转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你拥有 AddBirthdayViewController 时，你可以将代理设置为 self，而当前的代理是 Birthdays 表视图控制器 ➌。

现在运行应用并添加一些生日！你在 Birthdays 表视图控制器中看到什么？生日！生日！生日！不过，我们还没有完成。如果你退出应用然后再重新运行，之前添加的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学会了如何创建一个表视图控制器来显示生日列表。你还学会了如何在 Add Birthday 视图控制器中添加生日，并通过代理将生日添加到 Birthdays 表视图控制器中的生日数组，以便它能显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用并再次运行，生日数据仍然能够显示。为了保存生日，你将使用 Core Data，这是我们在项目一开始就设置好的。

控制键点击 Project 导航栏中的 *BirthdayTracker* 文件夹，并从菜单中选择 **New File…**。在第十章中，我们创建了 Swift 文件 *Birthday.swift*，这是 Xcode 为我们准备的几乎为空的文件。此次创建新文件时，我们会告诉 Xcode，我们想继承一个现有的 iOS 类。根据基类，Xcode 将创建一个包含一些代码的文件，你可以根据需要进行自定义。要创建文件，请在窗口顶部选择 **iOS**，然后选择 **Cocoa Touch Class** 模板，这会自动格式化新的类文件（见图 11-1）。

![](img/Image00234.jpg)

*图 11-1：要继承一个已有的类，选择* ***iOS*** *然后选择* ***Cocoa Touch Class***。

选择此选项后，你将看到一个第二个对话框，在其中你可以命名新类并指定要继承的类。首先，在 Subclass 字段（对话框中的第二个字段）输入 UITableViewController。这样会自动填充类字段为子类名称。一旦完成，输入 Birthdays 以便将类名改为 BirthdaysTableViewController。这样是为了省略输入的步骤。确保在 Language 下拉菜单中选择 **Swift**，然后点击 **Next**。在最后的对话框中选择 **Create** 来创建新文件。

在*BirthdaysTableViewController.swift*中，Xcode 已经提供了一个包含多个注释掉的方法的模板。您可以通过删除我们不会使用的方法来清理代码。仅删除 viewDidLoad()中的注释，然后删除整个 didReceiveMemoryWarning()方法，以及与表格视图中移动行相关的 tableView(_:moveRowAt:to:)和 tableView(_:canMoveRowAt:)方法。完成后，BirthdaysTableViewController 的内容应如下图 11-2 所示。虽然还有几个注释掉的方法，但我们将保留这些方法以便以后使用！

![](img/Image00235.jpg)

*图 11-2：清理后的* BirthdaysTableViewController *

接下来，您需要将生日表格视图控制器设置为 BirthdaysTableViewController 类。为此，请转到*Main.storyboard*并选择**Birthdays**场景。在右侧窗格中的“Identity Inspector”中，将类从 UITableViewController 更改为 BirthdaysTableViewController，如图 11-3 所示。

![](img/Image00236.jpg)

*图 11-3：将* BirthdaysTableViewController *设置为 Birthdays 场景的类*

现在您已经在故事板中设置了生日表格视图控制器，下一步是创建表格中的单元格来显示每个生日。

#### 向表格视图添加单元格

每个生日将在生日表格视图控制器中的 UITableViewCell 中显示。表格由组织成行和列的框组成，这些框包含信息。这些框被称为*单元格*。类似地，表格视图也有单元格，它们都是 UITableViewCell 类的实例或其子类。我们将在表格视图中的每个单元格中放入一个生日。

我们将首先在故事板中创建这些单元格，然后稍后再用我们的生日对象填充它们。在左侧大纲菜单中，点击“Birthdays”旁边的三角形，然后点击“Table View”旁边的三角形以展开这些部分。然后选择**Table View Cell** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建 Subtitle 样式的表格视图单元格并设置其标识符*

接下来，打开“Attributes Inspector”。使用**Style**下拉菜单，将单元格样式设置为**Subtitle** ➋，这样单元格就会有一个标题标签和一个副标题标签。您将把每个人的名字显示在标题中，生日显示在副标题中。

最后，在“Identifier”字段中输入 birthdayCellIdentifier ➌。您将在稍后填写单元格内容时使用此标识符。

就这样！您已经完成了故事板中的工作。

你可能会想，为什么在我们的故事板中表格视图只有一个单元格，而我们会在列表中显示多个生日呢？如果你再次查看图 11-4，你会注意到该单元格标记为 *原型单元格*。这意味着你刚刚自定义的单元格是你希望在表格视图中显示的所有单元格的 *模板*。你给单元格的标识符是你的代码告诉表格视图为你生成每个单元格、并将生日放入其中的方式。你很快就会看到它是如何工作的。

**处理日期**

Swift 有一种特殊的数据类型叫做 Date，用于存储日期值。Date 对象实际上是一个日期和时间。打开你的 Playground 并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量 today。当你打印 today 时，它的格式是 "2017-11-21 10:45:31 +0000\n"。如果你希望它以“2017 年 11 月 21 日星期二”或仅显示“11/21/17”的形式显示该怎么做呢？要以特定方式显示日期，你需要使用 *日期格式化器*，这是一种你创建并赋予日期格式样式的 DateFormatter 对象。DateFormatter 是一个辅助对象，用于从任何日期创建显示字符串，*日期格式样式* 是 DateFormatter 的一个属性，告诉格式化器使用哪种样式。你可以手动创建自己的日期格式样式，但 Swift 中也包含了一些现成的样式可供使用。将以下内容添加到你的 Playground：

![](img/Image00240.jpg)

在 ➊ 你创建了一个格式化器。然后在 ➋ 你将格式化器的样式设置为 Style.full，这样就会打印出星期几、完整的月份名称、日期和年份。最后，你通过 DateFormatter 类的 string(from:) 方法 ➌ 创建了一个日期字符串。你可以看到现在你已经将日期转化为漂亮格式化的字符串 "Tuesday, November 21, 2017"。表格 11-1 显示了来自 Swift 中五个可用的 DateFormatter.Style 选项所创建的不同字符串。

**表格 11-1:** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "Nov 21, 2017" |
| long | "November 21, 2017" |
| full | "Tuesday, November 21, 2017" |

你还可以使用 DateFormatter 的 dateFormat 属性来指定自定义的日期显示方式。也许你只想要显示月份和日期，或者你希望以简短的样式显示四位数的年份。做到这一点非常简单，而且你甚至不需要创建一个新的 DateFormatter——你只需更改格式化器上的 dateFormat，然后请求一个新的字符串。将以下代码添加到你的 Playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定只想要显示 MM/dd 格式的月份和日期——也就是两位数的月份后跟两位数的日期。如果你想显示三字母的月份，可以使用 MMM。如果要显示月份的全名，可以使用 MMMM。在 ➋ 处，我们将日期格式改为使用四位数的年份。两位数的年份则用 yy。这里有几种其他方式可以使用 dateFormat 来显示自定义的日期字符串。

![](img/Image00242.jpg)

如果你想添加分隔符，可以将它们添加到你的 dateFormat 字符串中。例如，如果你想使用句点作为分隔符，你可以创建一个类似 "MM.dd.yy" 的 dateFormat ➊。如果你想显示缩写的星期几，可以使用 EEE ➋。要显示完整的星期几，可以使用 EEEE ➌。这些只是几个例子。通过组合 M、d、y 和 E，你可以以无尽的方式显示日期！

#### 设置生日表视图控制器

生日表视图控制器将显示应用中存储的所有生日的列表。你记得用什么来存储一系列项目吗？没错——是数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有生日。为此，在类的顶部，即 viewDidLoad() 方法的上方，插入这一行，添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量而不是常量，因为每次用户通过添加生日视图控制器添加一个生日时，你都希望将保存的生日添加到这个数组中。你将在 “让生日表视图控制器遵循协议” 中看到如何做到这一点，参见 第 168 页。

**注意**

*请记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

生日表视图控制器还需要一个 dateFormatter 属性来将出生日期显示为格式化良好的字符串。在 birthdays 数组下方添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，使用 let 创建。即使你会更改 dateFormatter 的属性，比如 dateStyle 和 timeStyle，你也不会更改 dateFormatter 本身。

你还需要设置 dateFormatter，以便它能将出生日期显示为完全格式化的字符串，如 "Tuesday, December 17, 2008"。正如你在 第十章 中看到的，一个合适的地方是在 viewDidLoad() 方法中，该方法会在生日表视图控制器加载其视图时调用。这是进行该类所需任何设置的完美位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 `dateFormatter` 的 `dateStyle`，使其能够为每个生日显示格式化的日期字符串。你是否注意到我们只写了 `.full` 而不是 `DateFormatter.Style.full`？Swift 知道 `DateFormatter` 的 `dateStyle` 应该是什么类型，因此它允许我们使用这个小的快捷方式。在 ➋ 处，你将 `dateFormatter` 的 `timeStyle` 设置为 `.none`，以确保不显示时间。

#### 在表格视图中显示生日

`BirthdaysTableViewController` 类有一个表格视图，用于显示一个单列的项目列表。表格视图有一个或多个部分，每个部分包含若干行，每行包含一个单元格。表格视图中的一个部分是一个行的分组，可以选择是否显示标题。显示多个部分的表格视图的应用实例有设置应用，如图 11-5 所示。它显示了一系列行，并将这些行分组到不同的部分中。

表格视图的每个部分和行都由一个索引号标识。这些数字从 0 开始，向下递增 1。例如，设置应用中的“隐私”一行位于第零部分，第 1 行；“新闻”设置位于第一部分，第 3 行。

在`BirthdaysTableViewController`类的中间，有一个名为*Table view data source*的部分，其中包含三个方法。表格视图控制器使用这些方法来决定在其表格视图中显示什么内容。

numberOfSections(in:) 告诉表格视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表格视图每个部分会显示多少行

tableView(_:cellForRowAt:) 设置要在表格视图中每一行显示的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用通过部分将不同设备设置的行分组。*

每次重新加载表格视图时，表格视图控制器都会调用表格视图数据源方法。当你创建一个 `UITableViewController` 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现所有三个方法，才能让应用正常工作，即使你在代码中不会直接调用它们。`UITableViewController` 类实现了 `UITableViewDataSource` 协议，该协议带有这些数据源方法，用于决定在表格视图中显示什么内容。我们将在 “代理” 第 166 页讨论协议。现在，你只需要知道，`UITableViewController` 使用这些方法来显示内容，并且它会自动调用这些方法，因此你不需要手动调用它们。

我们从方法 `numberOfSections(in:)` 开始。`Birthdays` 表格视图控制器是一个只显示生日实例的列表，因此它不需要多个部分。为了设置表格视图的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 tableView 的 UITableView 类型参数，它是使用此类作为数据源的表格视图。我们不需要担心如何建立这个连接，因为 UITableViewController 自带一个内置的表格视图，并且这些方法会自动连接到该视图。每个生日将显示在自己的行中。因此，在 `tableView(_:numberOfRowsInSection:)` 方法中，为了为所有生日提供正确数量的行，你需要返回 `birthdays` 数组中 Birthday 实例的数量。你还记得数组的 `count` 属性吗？它是一个整数，表示数组中的项数，正好适合这种情况！将这个方法更改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，`tableView(_:numberOfRowsInSection:)` 还接受一个名为 section 的 Int 类型参数。当表格视图加载时，这个方法会为每个 section 调用。在我们的例子中，只有一个 section，所以我们不需要担心检查正在显示哪个 section。我们知道它是 section 0，并且我们希望它的行数与生日人数相等，因此我们写 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)` 方法，以便表格视图知道在每个单元格中显示什么内容。由于这个方法被注释掉了，你需要删除围绕它的 `/*` 和 `*/` 来取消注释。（小心不要意外取消注释它后面的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法 `tableView(_:cellForRowAt:)`。它是在表格视图加载到屏幕上时被调用的。每个屏幕上的单元格都会调用这个方法，并且接收两个参数：tableView 和 indexPath。你已经知道 tableView 参数的用途了。IndexPath 是一个 Swift 结构体，用于表示表格视图中某一行的位置。一个 IndexPath 实例包含一个 section 属性和一个 row 属性。由于这个方法会被多次调用（每一行都会调用一次），所以我们需要 indexPath 来知道当前配置的是哪个 section 和 row。indexPath.section 属性返回 section 的编号，indexPath.row 返回表格视图单元格的行号。`tableView(_:cellForRowAt:)` 方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定在 `birthdays` 数组中哪个 Birthday 会显示在该单元格中

• 创建两个标签来显示生日人物的名字和出生日期

• 返回准备好在表格视图中显示的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。➊处的代码使用了`dequeueReusableCell(withIdentifier:for:)`方法来实现这一点。不过，在你开始使用这个方法之前，需要告诉方法你要使用哪个单元格来自故事板。之前在故事板中，你为单元格设置了标识符 birthdayCellIdentifier（见图 11-4）。这个标识符将你的代码与单元格关联，并告诉方法它正在使用正确的单元格。调用这个方法时的字符串必须与在故事板中设置的字符串完全相同，否则会出现错误，导致应用程序崩溃。

在`dequeueReusableCell(withIdentifier:for:)`方法中，你有没有注意到*可重用单元格*这几个字？表视图中的单元格只会创建一次，然后可以反复重用。这有助于提高程序的运行速度和流畅度，因为创建单元格是最耗时的部分。如果你的应用程序中有 200 个生日，但一次只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以查看更多生日时，滚出屏幕顶部的单元格会被重用。它们会被填充新的信息，并再次出现在屏幕底部。UITableView 会自动完成这项工作。当表视图加载时，会为每个可见的行调用`tableView(_:cellForRowAt:)`。当用户滚动查看更多单元格时，它会在每一行即将出现在屏幕上时再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中显示`birthdays`数组中的一个生日。第一个生日，即`birthdays[0]`，应该显示在第 0 行。第二个生日，即`birthdays[1]`，应该显示在第 1 行，依此类推，这意味着`indexPath`的行号与我们想要访问的`birthdays`数组中的位置相同。➋处的代码通过`indexPath.row`从`birthdays`数组中获取正确的 Birthday 对象。一旦我们拿到正确的 Birthday 对象，就将它赋值给一个名为`birthday`的常量，以便我们可以设置单元格中的标签。

注意，我们使用`let`将生日赋值给常量，而不是变量。之所以使用`let`，是因为每次`tableView(_:cellForRowAt:)`被调用时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并将其对应的 Birthday 对象赋值给该常量。由于我们不会修改任何生日常量——我们只是读取它们的属性——因此不需要将它们设为变量。

现在你已经有了单元格和生日数据，接下来是填写详细信息。你需要为每个单元格准备两个标签，分别显示生日人的姓名和出生日期。你将单元格设置为 Subtitle 风格，这样它就有一个 Title 标签和一个 Subtitle 标签。每个单元格已经包含这些标签，因此现在你无需自己创建标签。

这些标签是 UITableViewCell 的属性，分别叫做 textLabel 和 detailTextLabel。代码中的 ➌ 将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，两个名字之间有一个空格。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 上。

当你的单元格完全配置好后，tableView( _:cellForRowAt:) 方法会返回该单元格（➎），以便它可以在表视图的该 indexPath 位置显示。

### 综合应用

现在，你可以使用添加生日视图控制器将生日实例添加到应用中，并且你有一个表视图来列出每个生日，这些生日会显示在生日表视图控制器中。但是，当你尝试运行应用并添加一个生日时，它并没有出现在列表中。为了让你添加的每个生日出现在表视图中，你需要让添加生日视图控制器与生日表视图控制器进行通信。你可以通过使用*委托模式*来实现这一点。

#### 委托模式

委托模式可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 展示在 A 上面。A 知道 B，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但 B 并不知道 A——它只是突然出现，完全不知道自己是从哪里来的，也不知道是怎么到达这里的。那么，B 怎么与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托就是当一个人把任务交给别人去做时。*委托人*就像是一个老板，告诉一个委托员工该做什么。当委托员工完成任务后，有时会向委托老板报告一些信息。

在 Swift 中，委托模式非常相似，但我们没有老板和员工，而是有一个委托对象和一个委托者对象。由于是类 A 告诉类 B 要做什么，因此类 B 是委托者对象。我们为类 B 定义一个名为 delegate 的特殊属性，用来告诉它谁是它的委托对象——这样，它就知道要与谁进行通信。委托对象可以是任何实现了某个*协议*的类。协议就像是两类之间的约定，告诉它们委托对象可以要求委托者对象做些什么。它包含了一系列方法和属性名称，委托对象可以在委托者对象上使用这些方法。

类 A 创建类 B，将自己设置为类 B 的委托，并为类 B 指派一个协议中定义的任务。一旦类 B 完成了任务，它就会向类 A 汇报。让我们来看一下在我们的应用中是如何工作的。

生日表视图控制器是视图控制器 A，而添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议定义一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将被添加生日视图控制器用于报告回传信息。

看一下 图 11-6。当用户点击添加按钮 ➊ 时，Birthdays 表格视图控制器创建 Add Birthday 视图控制器 ➋ 并将自己设置为 Add Birthday 视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为有一个方法，`addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存 ➌ 时，Add Birthday 视图控制器调用这个方法 ➍，并将新的生日传递给它的委托，即 Birthdays 表格视图控制器。Birthdays 表格视图控制器接收到该生日后，会将其添加到生日数组中，并重新加载表格视图 ➎，这样新添加的生日就会出现在表格中。

我们将向您展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义 `addBirthdayViewController(_:didAddBirthday:)` 方法。每当有新的生日添加到应用中时，Add Birthday 视图控制器就可以调用此方法。Birthdays 表格视图控制器将实现该协议方法，以便每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器可以对其委托说：“嘿！有人刚刚添加了这个生日。”然后，Birthdays 表格视图控制器会接收到该消息并回应：“哦！我会把它添加到我的列表中，并刷新显示，让新添加的生日出现。”

那么现在让我们开始编写代码吧！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方*，添加定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

您通过输入关键字 `protocol` 来定义协议，后跟协议名称 AddBirthdayViewControllerDelegate 来定义协议。这个名称很长，但 Swift 程序员通常会根据调用类的名称来命名协议，并在末尾加上 “Delegate” 一词。这样，您就可以通过查看协议的名称来知道是哪个类在使用该协议。既然您现在是一个 Swift 程序员，您也应该遵循这种命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)` 是唯一的函数，它用于将 Birthday 对象传递回委托类 ➋。请注意，您在此函数中包含了 AddBirthdayViewController 作为参数。再强调一次，Swift 程序员在实现协议方法时，通常会遵循这个约定，因此你也应该坚持这样做。了解谁发送了消息并让委托能够访问该对象及其类是非常有用的。

当添加生日视图控制器调用此方法时，它会将自身作为 addBirthdayViewController 参数传递给方法。很快你就会看到如何实现这一点。另一个需要注意的点是外部参数名 didAddBirthday。许多代理协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚做过的或将要做的事情。

现在你已经定义了协议，接下来需要告诉 Birthdays 表视图控制器去采用这个协议并使用协议的方法。

##### 使生日表视图控制器遵循协议

为了采用该协议，Birthdays 表视图控制器需要使自身成为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，在 UITableViewController 超类后面添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加上一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦这样做，就会出现一个红色错误。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了解决这个问题，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心，我们很快就会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是继承自 UITableViewController 超类的。一个类只能有一个超类，并且超类名称必须在任何协议之前写出。但虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议会列在超类之后，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且期待你添加这个方法。注意，与子类化方法不同，在 addBirthdayViewController(_:didAddBirthday:) 方法前不需要使用 override 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将由添加生日视图控制器传递的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现 ➋。接下来，你需要刷新表视图，确保它显示出这个新生日，通过在 tableView 属性上调用 reloadData() 方法 ➌。当调用 reloadData() 方法时，表视图的数据源方法将再次被调用，新的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但标记类的不同部分是良好的编程风格，有助于保持代码简洁和易于阅读。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单可以帮助你快速找到方法，并跳转到代码中的不同位置。要使用此菜单，请点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 给添加生日视图控制器设置代理

`BirthdaysTableViewController` 已经实现了 `AddBirthdayViewControllerDelegate` 协议。现在是时候让添加生日视图控制器使用 `AddBirthdayViewControllerDelegate` 协议来通知生日表格视图控制器它已添加一个生日了。为此，添加生日视图控制器首先需要定义一个代理。我们通过在 `AddBirthdayViewController` 类中添加一个类型为 `AddBirthdayViewControllerDelegate` 的可选代理属性来安排这一点，插入以下代码行，放在 outlets 下方：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在创建添加生日视图控制器后你才能设置它。你很快就会知道在哪里设置代理。

现在，添加生日视图控制器已经有了代理，在 `saveTapped(_:)` 方法中，你可以使用 `addBirthdayViewController(_:didAddBirthday:)` 方法将一个生日传递给代理。将 `saveTapped(_:)` 方法更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊处的代码使用 `addBirthdayViewController(_:didAddBirthday:)` 将其传回代理。

太棒了！你已经完成了对添加生日视图控制器的更改。它现在有一个代理，将会监听生日被保存的事件。运行应用程序看看会发生什么。

嗯……变化不大。当你添加生日时，仍然没有看到它出现在生日表格视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事需要做。生日表格视图控制器是 AddBirthdayViewControllerDelegate 协议的实现者，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存它与生日保存时通信的代理。但我们从未明确地将代理属性设置为生日表格视图控制器。所以，现在是时候连接我们两个视图控制器之间的通信管道了。

在“生日表格视图控制器”类的导航部分，有一个被注释掉的方法 prepare(for:sender:)。通过删除它周围的 /* 和 */ 注释，你可以取消注释这个方法。

每当“生日表格视图控制器”放弃其屏幕并且应用通过 storyboard segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将“生日表格视图控制器”传递给“添加生日”视图控制器，以将其设置为“添加生日”视图控制器的代理。在 prepare(for:sender:) 方法中编写如下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的代理为生日列表视图控制器需要三行代码。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 在注释中留下了一个提示，告诉你该如何实现这一点。UIStoryboardSegue 在其 destination 属性中存储着准备好的目标视图控制器，但是对于这个应用来说，目标并不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到一个导航控制器中，这样你就可以在导航栏中添加取消和保存按钮。所以你不会期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。在➊这一行代码中，你获取到了 navigationController。代码中的 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是特定类型的视图控制器，我们需要使用 as 进行类型转换，将其转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，所以必须将其类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获取到 AddBirthdayViewController 时，你可以将代理设置为 self，而 self 当前是“生日表格视图控制器” ➌。

现在运行应用并添加一些生日！你在“生日表格视图控制器”中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用然后重新运行，之前添加的生日会消失。我们还需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在这一章中，你学会了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，并通过使用代理将这个生日添加到“生日表格视图控制器”的生日数组中，以便它能够显示出来。

在 第十二章 中，你将学习如何将生日保存到你的设备上，这样即使你退出应用程序并再次运行，它们仍然会显示。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

![](img/Image00234.jpg)

*图 11-1：要创建一个现有类的子类，选择* ***iOS*** *然后选择* ***Cocoa Touch Class***。

当你选择此选项时，你会看到第二个对话框，在这里你可以为你的新类命名并指定你要继承的类。首先，在子类字段（对话框中的第二个字段）输入 `UITableViewController` 。这将自动填充类字段为子类名称。一旦完成，输入 *Birthdays* 到 *TableViewController* 前面，使整个类名变为 *BirthdaysTableViewController* 。这是一个快捷方式，可以减少输入的内容。确保在语言下拉菜单中选择 **Swift** ，然后点击 **Next** 。接着，在最后一个对话框中选择 **Create** 来创建你的新文件。

在 *BirthdaysTableViewController.swift* 中，Xcode 提供了一个包含多个注释掉的方法的模板。你可以通过删除我们不使用的方法来清理代码。删除 `viewDidLoad()` 中的注释，然后删除整个 `didReceiveMemoryWarning()` 方法，以及与移动表格行相关的 `tableView(_:moveRowAt:to:)` 和 `tableView(_:canMoveRowAt:)` 方法。当你完成后，`BirthdaysTableViewController` 的内容应与 图 11-2 中显示的一样。虽然仍有一些注释掉的方法，但我们保留它们是为了以后使用！

![](img/Image00235.jpg)

*图 11-2：已清理的* BirthdaysTableViewController *！*

接下来，你需要将 *Birthdays* 表视图控制器设置为 *BirthdaysTableViewController* 类。为此，打开 *Main.storyboard* 并选择 **Birthdays** 场景。在右侧面板的 Identity Inspector 中，将类从 `UITableViewController` 更改为 `BirthdaysTableViewController` ，如 图 11-3 所示。

![](img/Image00236.jpg)

*图 11-3：将* BirthdaysTableViewController *设置为 Birthdays 场景的类*

现在你已经在故事板中设置了 *Birthdays* 表视图控制器，下一步是创建表格中的单元格来显示每个生日。

#### 向表格视图添加单元格

每个生日将在 *Birthdays* 表视图控制器中的一个 `UITableViewCell` 中显示。一个表格包含按行和列组织的包含信息的框，这些框叫做 *cells* 。类似地，表视图也有单元格，它们都是 `UITableViewCell` 类的实例或其子类。我们会将每个生日放入表视图中的单独单元格中。

我们将从创建故事板中的这些单元格开始，然后稍后再填充我们的生日对象。在左侧的大纲菜单中，点击 Birthdays 旁边的三角形，然后点击 Table View 旁边的三角形以展开这些部分。然后选择**Table View Cell** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建副标题样式的表格视图单元格并设置其标识符*

接下来，打开属性检查器。在**样式**下拉菜单中，设置单元格的样式为**副标题** ➋，这样单元格就会有一个标题标签和一个副标题标签。你将在标题中显示每个人的名字，在副标题中显示生日。

最后，在标识符字段中输入 birthdayCellIdentifier ➌。稍后你将在填充单元格内容时使用这个标识符。

就是这样！你已经完成了故事板中的工作。

你可能会好奇，为什么在故事板中的表格视图里只有一个单元格，而我们要显示的生日列表会有多个条目。如果你再看一遍图 11-4，你会注意到这个单元格被标注为*原型单元格*。这意味着你刚刚自定义的单元格是你希望在表格视图中显示的所有单元格的*模板*。你给单元格的标识符将告诉你的代码如何生成每个单元格，用于填充生日。你很快就会看到这个是如何工作的。

**处理日期**

Swift 有一种特殊的数据类型叫做 Date，用于存储日期值。一个 Date 对象实际上包含了日期和时间。打开你的 playground，并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量 today。当你打印 today 时，它的格式是 "2017-11-21 10:45:31 +0000\n"。如果你希望它显示为 2017 年 11 月 21 日星期二 呢？或者只是 11/21/17 呢？要以特定的方式显示日期，你需要使用*日期格式化器*，它是一个 DateFormatter 对象，你可以创建并给它一个日期格式样式。DateFormatter 是一个帮助对象，用于从任何日期创建显示字符串，*日期格式样式*是 DateFormatter 的一个属性，告诉格式化器使用什么样式。你可以手动创建自己的日期格式样式，但 Swift 也提供了一些已经准备好的样式。将以下内容添加到你的 playground：

![](img/Image00240.jpg)

在 ➊ 处，你创建了一个格式化器。然后在 ➋ 处，你将格式化器的样式设置为 Style.full，这将打印出星期几以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:) 方法从日期创建一个字符串 ➌。你可以看到，现在你已经将日期转换为格式良好的字符串 "Tuesday, November 21, 2017"。表 11-1 显示了 Swift 中可用的五种 DateFormatter.Style 选项所创建的不同字符串。

**表 11-1：** 日期格式化样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "17/11/21" |
| medium | "2017 年 11 月 21 日" |
| long | "2017 年 11 月 21 日" |
| full | "2017 年 11 月 21 日，星期二" |

你还可以使用 `DateFormatter` 的 `dateFormat` 属性来指定自定义的日期显示方式。也许你只想显示月和日，或者你可能希望以短格式显示四位数年份。无论哪种方式都非常简单，而且你甚至不需要创建一个新的 `DateFormatter` ——你只需要更改格式化器的 `dateFormat`，然后请求它生成一个新的字符串。将以下代码添加到你的 playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 中，你指定只希望以 MM/dd 格式显示月和日，也就是两位数的月份后跟两位数的日期。如果你想将月份显示为三字母缩写，可以使用 `MMM`。要显示完整的月份名称，请使用 `MMMM`。在 ➋ 中，我们将日期格式更改为使用四位数年份。两位数年份是 `yy`。以下是使用 `dateFormat` 显示自定义日期字符串的其他几种方式：

![](img/Image00242.jpg)

如果你想包含分隔符，可以将它们添加到你的 `dateFormat` 字符串中。例如，如果你想用句点作为分隔符，你可以创建一个类似于 "MM.dd.yy" ➊ 的 `dateFormat`。要显示缩写形式的星期几，使用 `EEE` ➋。要显示完整的星期几名称，使用 `EEEE` ➌。这些只是几个例子。通过组合使用 `M`、`d`、`y` 和 `E`，你可以有无数种方式来显示日期！

#### 设置生日表视图控制器

`Birthdays` 表视图控制器将显示应用中存储的所有生日列表。你还记得用什么来存储一系列项吗？没错—一个数组！你将在 `BirthdaysTableViewController` 中创建一个数组来存储所有生日。为此，请给 `BirthdaysTableViewController` 添加一个名为 `birthdays` 的属性，这个属性是 `Birthday` 对象的数组。在类的顶部，`viewDidLoad()` 方法之前，插入以下代码来添加一个名为 `birthdays` 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 `Birthday` 实例数组。它需要是一个变量，而不是常量，因为你每次用户通过“添加生日”视图控制器添加生日时，都会将已保存的生日添加到这个数组中。你将在“使生日表视图控制器符合协议”中看到如何实现这一点，见第 168 页。

**注意**

*请记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

`BirthdaysTableViewController` 还需要一个 `dateFormatter` 属性来以漂亮的格式显示出生日期。请在 `birthdays` 数组下方添加一个 `dateFormatter`：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个使用 let 创建的常量。尽管你会更改 dateFormatter 的属性，如 dateStyle 和 timeStyle，但你永远不会更改 dateFormatter 本身。

你还需要设置 dateFormatter，以便它能够将出生日期显示为完全格式化的字符串，如“Tuesday, December 17, 2008”。正如你在第十章中看到的，最好的做法是在 viewDidLoad() 方法中进行设置，该方法在 Birthdays 表视图控制器加载其视图时被调用。这是进行任何所需设置的完美位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ ，你设置了 dateFormatter 的 dateStyle，使其能够为每个生日显示格式化的日期字符串。你注意到我们直接写了 .full 而不是 DateFormatter.Style.full 吗？Swift 知道 dateStyle 的类型是什么，所以它允许我们使用这个小快捷方式。在 ➋ ，你将 dateFormatter 的 timeStyle 设置为 .none，以便不显示时间。

#### 在表视图中显示生日

BirthdaysTableViewController 类有一个表视图，用于显示单列项的列表。表视图有一个或多个包含行的部分，每行包含一个单元格。表视图中的一个部分是行的分组，可以选择是否显示标题。一个显示具有多个部分的表视图的应用程序示例是设置应用程序，如图 11-5 所示。它显示了被分成不同部分的行列表。

表视图的每个部分和行都有一个索引号进行标识。这些数字从 0 开始，随着表视图向下滚动，每行的索引号依次增加。例如，设置应用中的隐私选项位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间部分，有一个名为 *Table view data source* 的部分，其中包含三个方法。表视图控制器使用这些方法来确定在其表视图中显示什么内容。

numberOfSections(in:) 告诉表视图它应该有多少个部分。

tableView(_:numberOfRowsInSection:) 告诉表视图每个部分将显示多少行。

tableView(_:cellForRowAt:) 设置每个将显示在表视图每一行中的单元格。

![](img/Image00243.jpg)

*图 11-5：设置应用程序使用分组将不同设备设置的行分类。*

每当表视图被重新加载时，表视图控制器会调用表视图的数据源方法。当你创建 UITableViewController 的子类时，Xcode 会自动给你这些方法模板。你需要实现这三个方法，才能让应用正常工作，尽管你不会在代码中直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，其中包含这些数据源方法，用于确定表视图中显示的内容。我们将在“代理模式”的第 166 页讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要手动调用它们。

让我们从方法 numberOfSections(in:) 开始。Birthdays 表视图控制器是一个只显示 Birthday 实例的列表，所以它不需要多个部分。为了设置表视图中的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法将一个名为 tableView 的 UITableView 作为参数传入，它是使用此类作为数据源的表视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内建的表视图，并且会自动与这些方法连接。在每一行中都会显示一个生日。因此，在 tableView(_:numberOfRowsInSection:) 方法中，为了确保表格中有正确数量的行来显示所有的生日，你需要返回 birthdays 数组中 Birthday 实例的数量。你记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少个元素，非常适合这个情况！将这个方法改成以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，tableView(_:numberOfRowsInSection:) 还接收一个名为 section 的 Int 类型参数。当表视图加载自己时，这个方法会为表视图中的每个部分调用。在我们的案例中，我们只有一个部分，所以这里不需要检查表视图显示的是哪个部分。我们知道它是部分 0，我们希望它有与生日数量相同的行数，因此我们写 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:) 方法，这样表视图才能知道在每个单元格中显示什么。由于这个方法被注释掉了，你需要通过删除 /* 和 */ 来取消注释它。（小心不要不小心取消注释后面的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要调用`tableView(_:cellForRowAt:)`方法。这个方法会在表视图加载到屏幕上时被调用。它会为屏幕上的每个单元格被调用，并且接受两个参数，`tableView`和`indexPath`。你已经知道`tableView`参数的作用了。`IndexPath`是一个 Swift 结构体，用于表示表视图中某行的位置。`IndexPath`实例有一个`section`属性和一个`row`属性。由于此方法会被调用多次（每个表行一次），我们需要`indexPath`来知道当前配置的是哪个节和行。`indexPath.section`属性给出节的编号，`indexPath.row`给出表视图单元格的行号。`tableView(_:cellForRowAt:)`中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定哪个生日记录将在单元格中显示

• 创建两个标签来显示生日人的姓名和出生日期

• 返回已准备好显示在表视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。➊处的代码使用`dequeueReusableCell(withIdentifier:for:)`方法实现此功能。在你开始在单元格上使用此方法之前，你需要告诉它从故事板中选择哪个单元格。早些时候，当你在故事板中时，你给单元格设置了标识符 birthdayCellIdentifier（见图 11-4）。这个标识符将你的代码与单元格关联，并告诉方法你正在使用正确的单元格。当你调用此方法时，传递的字符串必须与在故事板中设置的字符串完全相同，否则你会遇到错误，应用程序会在运行时崩溃。

在`dequeueReusableCell(withIdentifier:for:)`方法中，你注意到“*Reusable Cell*”这几个字了吗？表视图中的单元格是创建一次后，可以反复重用的。这有助于提升应用程序的运行速度和流畅度，因为创建单元格是最耗时的。如果你的应用中有 200 个生日记录，但一次屏幕上只显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，滚出屏幕顶部的单元格会被重用。它们会填充新的信息并再次出现在屏幕底部。`UITableView`会自动完成这个工作。当表视图加载时，`tableView(_:cellForRowAt:)`会为每个可见的行调用。当用户滚动查看更多单元格时，它会再次被调用，每次在单元格即将显示在屏幕上时。

接下来，我们需要找出哪个生日应该显示在单元格中。我们想要在每一行显示 birthdays 数组中的一个生日。第一个生日，在 birthdays[0] 处，应该显示在第 0 行。第二个生日，在 birthdays[1] 处，应该显示在第 1 行，依此类推，这意味着 indexPath 的行数与我们想要访问的 birthdays 数组中的位置相同。➋ 处的代码通过使用 indexPath.row 来访问 birthdays 数组中的正确 Birthday 对象。一旦我们拿到正确的 Birthday 对象，我们就将其赋值给一个名为 birthday 的常量，以便我们可以设置该单元格中的标签。

请注意，我们使用 let 将生日赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并且会分配自己的 Birthday 对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以我们不希望把它们设置为变量。

现在你有了单元格和生日信息，是时候填充细节了。你需要两个标签来显示生日人的名字和出生日期。你将单元格设置为 Subtitle 风格，这样它就会有一个 Title 标签和一个 Subtitle 标签。每个单元格已经包含了这些标签，所以现在你不需要自己创建标签了。

这些标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，二者之间有一个空格。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法来显示出生日期到 detailTextLabel 中。

当你的单元格完全配置好后，tableView( _:cellForRowAt:) 会返回 ➎ 位置的单元格，以便它可以在该 table view 的 indexPath 处显示。

### 将一切整合在一起

现在，你可以使用“添加生日”视图控制器将 Birthday 实例添加到应用程序中，并且你有一个 table view 来列出每个生日在 Birthdays table view controller 中。但当你尝试运行应用并添加生日时，它不会显示。为了使你添加的每个生日在 table view 中显示，你需要让“添加生日”视图控制器与 Birthdays table view controller 进行通信。你可以通过使用 *委托* 来实现这一点。

#### 委托

委托（Delegation）可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 展示在自己之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 不知道 A——它只是突然出现，并且不知道它来自哪里，也不知道它是如何到达那里的。那么 B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是一种将工作或任务交给他人的行为。*委托人*就像是一个老板，告诉被委托的员工该做什么。当被委托的员工完成任务后，有时他们会将信息反馈给委托的老板。

在 Swift 中，委托的概念非常相似，不过我们不是老板和员工，而是委托人和委托对象。由于是类 A 告诉类 B 做什么，所以类 B 是委托对象。我们给类 B 一个特殊的属性叫做 delegate，用来告诉它谁是它的委托对象——这样它就知道该与谁通信。委托对象可以是任何拥有在 *协议* 中定义的一组方法的类。协议就像是两类之间的协议，告诉它们委托对象可以要求委托对象做什么。协议包含委托对象可以与委托对象一起使用的方法和属性名称列表。

类 A 创建类 B，将自己设置为类 B 的委托，并赋予类 B 一个在协议中定义的任务。一旦类 B 完成任务，它会向类 A 汇报。让我们看看这个在应用中是如何工作的。

Birthdays 表格视图控制器是视图控制器 A，而 Add Birthday 视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，Add Birthday 视图控制器将使用该方法进行回调。

看一下 图 11-6。当用户点击添加按钮 ➊ 时，Birthdays 表格视图控制器创建 Add Birthday 视图控制器 ➋ 并将自己设置为 Add Birthday 视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日通过委托从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为包含一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，Add Birthday 视图控制器会调用该方法 ➍，并将新的生日传递给其委托，即 Birthdays 表格视图控制器。Birthdays 表格视图控制器接收该生日，将其添加到其生日数组中，然后重新加载表格视图 ➎，以便新生日能出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，其中包含 addBirthdayViewController(_:didAddBirthday:) 方法，Add Birthday 视图控制器可以在每次添加生日时调用该方法。Birthdays 表格视图控制器将实现该协议方法，以便每次通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器可以向其委托说：“嘿！有人刚刚添加了这个生日”，然后 Birthdays 表格视图控制器会接收到消息并说：“哦！我会把它加到我的列表中，并刷新显示，以便新生日出现在视图中。”

现在让我们在代码中实现这个功能！

##### 创建一个协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过输入关键词 protocol 来定义协议，如在 ➊ 处所示，后面跟上协议名 AddBirthdayViewControllerDelegate。这个名字比较长，但 Swift 开发者通常会在调用类的基础上命名协议，并在后面加上 Delegate 这个词。这样，你就能通过查看协议的名字知道是哪个类在使用这个协议。既然你现在是一个 Swift 开发者，你也应该遵循这个命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，用于将 Birthday 对象传递回委托类 ➋。请注意，你在此函数中包括了 AddBirthdayViewController 作为参数。同样，Swift 开发者在实现协议方法时通常这样做，所以你也应该遵循这个做法。知道是谁发送回了消息，并让委托能够访问该对象及其类，这是很有用的。

当添加生日视图控制器调用此方法时，它将自身作为 addBirthdayViewController 参数传递给该方法。你很快就会看到如何完成这一步。另一个需要注意的点是外部参数名 didAddBirthday。许多委托协议方法中都包含 *did* 和 *will* 这两个词，因为它们用于描述调用类刚刚做了什么或将要做什么。

现在你已经定义了协议，你需要告诉 Birthdays 表视图控制器采用这个协议并使用协议中的方法。

##### 使生日表视图控制器符合协议

为了采用该协议，Birthdays 表视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要将 AddBirthdayViewControllerDelegate 添加到类定义中，紧跟在 UITableViewController 父类之后。在类的顶部，在 UITableViewController 后添加逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，一个红色的错误就会出现。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了解决这个问题，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会修复这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 的子类。一个类只能有一个父类，而且该父类的名称必须写在任何协议之前。但虽然一个类只能有一个父类，它可以采用任意多个协议——这些协议将在父类之后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动补全功能会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它期望你添加这个方法。请注意，与子类化方法不同，addBirthdayViewController(_:didAddBirthday:) 前面不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现 ➋ 。接下来，你需要刷新表格视图，以便它显示这个新添加的生日，通过调用 tableView 属性上的 reloadData() 方法 ➌ 。当调用 reloadData() 时，表格视图的数据源方法将被重新调用，新添加的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必需的，但标记出类的不同部分是良好的编码风格，有助于保持代码整洁且易于阅读。注释的第一部分，MARK: - ，是 Xcode 识别的一个特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录中，你可以在该菜单中快速查找方法并跳转到代码的不同位置。要使用此菜单，点击编辑器窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类内置了一个目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器设置委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来告诉 Birthdays 表格视图控制器它何时添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 outlets 下面插入以下代码行，向 AddBirthdayViewController 类添加一个可选的委托属性，类型为 AddBirthdayViewControllerDelegate 来完成这项工作：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在创建 Add Birthday 视图控制器之前，你无法设置它。你将在稍后了解如何设置委托。

现在，“添加生日”视图控制器已经有了代理，在 `saveTapped(_:)` 方法中，你可以通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将一个生日对象传递给代理。将 `saveTapped(_:)` 修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象后，➊ 处的代码将它通过 `addBirthdayViewController(_:didAddBirthday:)` 方法传回给代理。

太好了！你已经完成了对“添加生日”视图控制器的修改。现在它有了一个代理，用于监听“生日已保存”的回调。运行应用程序，看看会发生什么。

嗯...变化不大。当你添加生日时，它仍然没有在“生日”表视图控制器中显示出来。这是怎么回事？

#### 通过设置代理连接这两个控制器

还有最后一件事需要做。“生日”表视图控制器是一个 AddBirthdayViewControllerDelegate，而“添加生日”视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存它与之通信的代理，当生日被保存时会触发。但是我们从未明确地将代理属性设置为“生日”表视图控制器。所以现在是时候将这两个视图控制器之间的通信管道连接起来了。

在“生日”表视图控制器类的导航部分，有一个已被注释掉的方法 `prepare(for:sender:)`。通过删除 /* 和 */ 注释符号来取消注释这个方法。

每当“生日”表视图控制器失去屏幕控制并且应用程序通过 storyboard segue 转到另一个视图控制器时，这个方法会自动调用。我们将使用这个方法将“生日”表视图控制器传递到“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的代理。在 `prepare(for:sender:)` 方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需三行代码即可将“添加生日”视图控制器的代理设置为“生日”表视图控制器。首先，你需要能够从 segue 参数获取到 AddBirthdayViewController 对象。Xcode 已经在注释中提示了你如何做到这一点。一个 UIStoryboardSegue 在其另一端有一个名为 destination 的属性，它代表着这个方法中正在准备的 segue 的目标，但在这个应用程序中，目标并不是 AddBirthdayViewController。

在 第九章 中，你将“添加生日”视图控制器嵌入到一个导航控制器中，这样你就可以拥有带有取消和保存按钮的导航栏。因此，你不会期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊ 处的代码让你获取到 `navigationController`。`segue.destination` 将返回一个 UIViewController，但由于我们的 `navigationController` 是一种特定类型的视图控制器，我们需要使用 `as` 将其类型转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，这是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须强制转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 时，可以将委托设置为 self，当前是 Birthdays 表格视图控制器 ➌。

现在运行应用并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用再重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，我们将在第十二章中进行操作。

### 你学到了什么

在本章中，你学会了如何创建一个表格视图控制器来显示生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，然后如何使用委托将生日添加到 Birthdays 表格视图控制器中的生日数组，以便显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用并重新运行，它们也会显示出来。为了保存生日，你将使用 Core Data，这是我们在项目开始时就已设置好的。

*图 11-1：要继承一个现有的类，选择* ***iOS*** *然后选择* ***Cocoa Touch Class.***

当你选择这个选项时，会弹出第二个对话框，你可以在其中命名你的新类并指定将要继承的类。首先，在子类字段（对话框中的第二个字段）中，输入 UITableViewController。这将自动填充类字段，使用子类名。一旦完成，输入“Birthdays”作为前缀，整个类名应为 BirthdaysTableViewController。这是一个快捷方式，可以减少输入的内容。确保在语言下拉菜单中选择**Swift**，然后点击**Next**。接着在最后一个对话框中选择**Create**，以创建你的新文件。

在*BirthdaysTableViewController.swift*中，Xcode 提供了一个包含多个注释掉的方法的模板。你可以通过删除我们不会使用的方法来清理代码。只需删除 viewDidLoad()中的注释，然后删除整个 didReceiveMemoryWarning()方法以及 tableView(_:moveRowAt:to:)和 tableView(_:canMoveRowAt:)方法，它们与在表格视图中移动行有关。当你完成后，BirthdaysTableViewController 的内容应该如图 11-2 所示。仍然有一些注释掉的方法，但我们保留它们，以便稍后使用！

![](img/Image00235.jpg)

*图 11-2：清理后的* BirthdaysTableViewController *！*

接下来，你需要将“Birthdays”表视图控制器设置为 BirthdaysTableViewController 类。为此，进入*Main.storyboard*并选择**Birthdays**场景。在右侧窗格中的身份检查器（Identity Inspector）中，将类从 UITableViewController 更改为 BirthdaysTableViewController，如图 11-3 所示。

![](img/Image00236.jpg)

*图 11-3：将*BirthdaysTableViewController*设置为 Birthdays 场景的类*

现在你已经在故事板中设置好了 Birthdays 表视图控制器，下一步是创建表视图中的单元格，用来显示每个生日。

#### 向表视图中添加单元格

每个生日将在 Birthdays 表视图控制器中的 UITableViewCell 中显示。表格有按行和列组织的信息框，这些框称为*单元格*。同样，表视图也有单元格，这些单元格都是 UITableViewCell 类的实例或子类。我们将在表视图中为每个生日创建自己的单元格。

我们将从在故事板中创建这些单元格开始，然后稍后将它们填充上我们的 Birthday 对象。在左侧大纲菜单中，点击“Birthdays”旁边的三角形，然后点击“Table View”旁边的三角形以展开这些部分。然后选择**Table View Cell** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建一个 Subtitle 样式的表视图单元格并设置其标识符*

接下来，打开属性检查器。在**Style**下拉菜单中，将单元格的样式设置为**Subtitle** ➋，这样单元格就会有一个标题标签和一个副标题标签。你将把每个人的名字显示在标题中，把生日显示在副标题中。

最后，在标识符字段中输入 birthdayCellIdentifier ➌。稍后你将使用这个标识符来填充单元格内容。

就这样！你已经完成了故事板中的工作。

你可能会想，为什么在故事板中我们的表视图只显示一个单元格，而实际上我们有多个生日要在列表中显示呢？如果你再看看图 11-4，你会注意到单元格上标注了*Prototype Cells*。这意味着你刚刚自定义的单元格是你希望在表视图中显示的所有单元格的*模板*。你给单元格设置的标识符将是你的代码告诉表视图为你生成每个单元格的方式，用来显示生日内容。你将很快看到这个是如何工作的。

**处理日期**

Swift 有一种特殊的数据类型叫做 Date，用于存储日期值。Date 对象实际上包含了日期和时间。打开你的 Playground 并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量 today。当你打印 today 时，它的格式是"2017-11-21 10:45:31 +0000\n"。如果你希望它显示为"Tuesday, November 21, 2017"呢？或者只是"11/21/17"？为了以特定方式显示日期，你使用一个*日期格式化器*，这是一个 DateFormatter 对象，你为其指定一个日期格式样式。DateFormatter 是一个帮助对象，用来从任何日期创建一个显示字符串，而*日期格式样式*是 DateFormatter 的一个属性，告诉格式化器使用哪种样式。你可以手动创建自己的日期格式样式，但 Swift 中也有一些样式可以直接使用。将以下内容添加到你的 playground：

![](img/Image00240.jpg)

在➊，你创建了一个格式化器。然后在➋，你将格式化器的样式设置为 Style.full，这将打印出星期几以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:)方法从日期创建一个字符串 ➌。你可以看到，你现在已经将日期转化为格式良好的字符串"Tuesday, November 21, 2017"。表 11-1 显示了在 Swift 中从五种 DateFormatter.Style 选项中创建的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "Nov 21, 2017" |
| long | "November 21, 2017" |
| full | "Tuesday, November 21, 2017" |

你还可以通过 DateFormatter 的 dateFormat 属性指定自己的日期显示方式。也许你只想显示月份和日期，或者你希望以简短样式显示四位数的年份。做这两件事都非常简单，而且你甚至不需要创建一个新的 DateFormatter——你只需改变 formatter 上的 dateFormat，然后请求它返回一个新的字符串。将以下代码添加到你的 playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在➊，你指定了只需要显示月份和日期，格式为 MM/dd——即两位数的月份后面跟两位数的日期。如果你想以三个字母显示月份，可以使用 MMM。如果你想显示完整的月份名称，则使用 MMMM。在➋，我们将日期格式更改为使用四位数年份。两位数的年份可以使用 yy。以下是几种其他使用 dateFormat 来显示自定义日期字符串的方式。

![](img/Image00242.jpg)

如果你想要包含分隔符，可以将它们添加到你的 dateFormat 字符串中。例如，如果你想要使用句点作为分隔符，可以创建一个像"MM.dd.yy"这样的 dateFormat ➊。要显示缩写的星期几，使用 EEE ➋。要显示完整的星期几，使用 EEEE ➌。这些只是一些例子。通过使用 M、d、y 和 E 的组合，你可以有无尽的方式来显示日期！

#### 设置生日表视图控制器

Birthdays 表格视图控制器将显示应用程序中存储的所有生日的列表。你还记得用什么来存储项列表吗？没错——数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有的生日。为此，在类的顶部，紧接着 viewDidLoad() 方法，插入这一行来添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量而非常量，因为每次用户通过添加生日视图控制器添加生日时，你都需要将保存的生日添加到这个数组中。你将在“使 Birthdays Table View Controller 遵守协议”一节中看到如何实现这一点，第 168 页也有相关内容。

**注意**

*记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *获取。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性，以便将出生日期显示为格式化字符串。将 dateFormatter 添加到 birthdays 数组的下方：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，它通过 let 创建。即使你会更改 dateFormatter 的属性，如 dateStyle 和 timeStyle，但你永远不会更改 dateFormatter 本身。

你还需要设置 dateFormatter 以便将出生日期显示为完整格式的字符串，比如“Tuesday, December 17, 2008”。正如你在第十章中看到的，进行此设置的好地方是 viewDidLoad() 方法，当 Birthdays 表格视图控制器加载视图时，该方法会被调用。这是进行此类任何必要设置的完美位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 dateFormatter 的 dateStyle 属性，以便它为每个 Birthday 显示一个格式化的日期字符串。你是否注意到我们只是写了 .full 而不是 DateFormatter.Style.full？Swift 知道 dateStyle 应该是什么类型，所以它允许我们简化书写。在 ➋ 处，你将 dateFormatter 的 timeStyle 设置为 .none，这样时间就不会显示出来。

#### 在表格视图中显示生日

BirthdaysTableViewController 类具有一个表格视图，用于显示单列项列表。表格视图包含一个或多个部分，每个部分包含若干行，每行包含一个单元格。表格视图中的一个部分是若干行的分组，可以带有或不带有标题。一个展示多个部分的表格视图应用程序示例是设置应用程序，如图 11-5 所示。它展示了一个将行分成不同部分的列表。

表视图的每个分区和行都有一个索引号来标识。这些数字从 0 开始，然后随着你向下滚动表视图，每行的数字会增加 1。例如，设置应用中的隐私行位于第 0 分区，第 1 行。新闻设置位于第 1 分区，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为*表视图数据源*的部分，其中包含三个方法。表视图控制器使用这些方法来确定在其表视图中显示的内容。

numberOfSections(in:) 告诉表视图它应该有多少个分区

tableView(_:numberOfRowsInSection:) 告诉表视图每个分区将显示多少行

tableView(_:cellForRowAt:) 设置每个将要显示在表视图每行中的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用分区来分组不同设备设置的行。*

每次表视图重新加载时，表视图控制器都会调用表视图数据源方法。当你创建一个 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现所有三个方法，以确保应用正常工作，尽管你不会在代码中直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，协议中包含这些数据源方法，用于确定在表视图中显示的内容。我们将在“委托”一节中讨论协议（第 166 页）。目前，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要自己调用它们。

让我们从方法 numberOfSections(in:)开始。Birthdays 表视图控制器是一个只显示 Birthday 实例的列表，因此它不需要多个分区。为了设置表视图中的分区数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

该方法接受一个名为 tableView 的 UITableView 作为参数，这是一个使用此类作为数据源的表视图。我们不需要担心如何建立这个连接，因为 UITableViewController 自带了一个内置的表视图，并且这个表视图会自动与这些方法连接。每个生日都会显示在自己的行中。因此，在 tableView(_:numberOfRowsInSection:)方法中，为了正确显示所有生日的行数，你需要返回 birthday 数组中 Birthday 实例的数量。你记得数组的 count 属性吗？它是一个整数，表示数组中有多少个项目，非常适合这种情况！将此方法更改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，tableView(_:numberOfRowsInSection:) 方法还接受一个名为 section 的 Int。当表视图加载时，这个方法会为表视图中的每个 section 调用。在我们的例子中，只有一个 section，因此我们不需要检查当前显示的是哪个 section。我们知道它是 section 0，并且我们希望它包含与生日数量相同的行，因此我们写 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:) 方法，以便表视图知道在每个单元格中显示什么内容。由于这个方法已被注释掉，你需要通过删除 /* 和 */ 来取消注释它。（小心不要不小心取消注释其后的其他方法！）完成后，将其改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要调用方法 tableView(_:cellForRowAt:)。它会在表视图加载到屏幕时被调用。它会为屏幕上的每个单元格调用，并接受两个参数：tableView 和 indexPath。你已经知道 tableView 参数的作用了。IndexPath 是一个 Swift 结构体，用于表示表视图中某一行的位置。IndexPath 实例有 section 属性和 row 属性。由于这个方法会被多次调用（每个表格行都会调用一次），我们需要 indexPath 来知道当前配置的是哪个 section 和 row。indexPath.section 属性给出 section 的编号，indexPath.row 给出表视图单元格的行号。tableView(_:cellForRowAt:) 内的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定在 birthdays 数组中哪个生日将在单元格中显示

• 创建两个标签，以在单元格中显示生日人物的姓名和出生日期

• 返回准备好显示在表视图中的单元格

让我们逐行解析这段代码。

首先，创建 UITableViewCell。代码在 ➊ 处通过方法 dequeueReusableCell(withIdentifier:for:) 实现。在你开始在单元格上使用这个方法之前，你需要告诉这个方法你要使用哪个单元格。在之前的 storyboard 中，你为你的单元格设置了标识符 birthdayCellIdentifier（见 图 11-4）。这个标识符将你的代码和单元格关联起来，并告诉你的方法正在使用正确的单元格。调用此方法时传入的字符串必须与在 storyboard 中设置的字符串完全相同，否则你会遇到错误，并且应用程序在运行时会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:)中，你有没有注意到“*可重用单元格*”这个词？表格视图中的单元格只创建一次，然后可以反复使用。这有助于提高性能，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只会显示 10 个，那么你只需要 10 个单元格来展示这些生日。当你向下滚动以显示更多生日时，滚出屏幕顶部的单元格将被重用。它们会填充新的信息并再次出现在屏幕底部。UITableView 会自动完成这些工作。当表格视图加载时，会为每个可见行调用 tableView(_:cellForRowAt:)。当用户滚动查看更多单元格时，每一行都会在即将出现在屏幕上的时候再次调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日，位于 birthdays[0]，应该显示在第 0 行。第二个生日，位于 birthdays[1]，应该显示在第 1 行，以此类推，这意味着 indexPath 的行号与我们想要访问的 birthdays 数组中的位置相同。➋处的代码通过使用 indexPath.row 从 birthdays 数组中获取正确的 Birthday 对象。一旦我们得到了正确的 Birthday 对象，就将其赋值给一个名为 birthday 的常量，以便在此单元格中设置标签。

请注意，我们使用 let 将生日赋值给常量而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的 birthday 常量。每个单元格都会得到自己的 birthday 常量，并且赋予自己的 Birthday 对象。由于我们不打算更改任何生日常量——我们只是读取它们的属性——所以我们不想把它们设为变量。

现在你已经有了单元格和生日，接下来就是填写详细信息了。你需要为每个单元格设置两个标签，一个用于显示生日人的姓名，另一个用于显示出生日期。你将单元格设置为副标题样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，所以你现在不需要自己创建任何标签了。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间有一个空格。➍处，你使用 dateFormatter 的 string(from:)方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:)会返回该单元格，编号为➎，这样它就可以在表格视图的该 indexPath 处显示。

### 将一切整合起来

现在，你可以使用添加生日视图控制器向应用程序添加生日实例，并在生日表视图控制器中通过表视图列出每个生日。但当你运行应用并尝试添加生日时，它并没有出现在表中。为了让你添加的每个生日都出现在表视图中，你需要让添加生日视图控制器与生日表视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 展示在自己之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 并不知道 A——它只是被创建出来的，并不知道它来自哪里，也不知道它是怎么到那里的。那么 B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项工作或任务交给别人。*委托*就像是一个老板，告诉一个委托的员工该做什么。当委托员工完成任务时，有时他们会将信息报告给委托的老板。

在 Swift 中，委托与此非常相似，但我们没有老板和员工，而是有委托和委托对象。由于类 B 是被类 A 告诉该做什么的，所以它是委托对象。我们给类 B 一个特别的属性叫做委托，用来告诉它谁是它的委托——这样它就知道该与谁沟通。委托可以是任何拥有在*协议*中定义的一组方法的类。协议就像是两类之间的协议，它告诉它们委托可以要求委托对象做什么。它有一个方法和属性名称的列表，委托可以与委托对象一起使用。

类 A 创建类 B，使自己成为类 B 的委托，并给类 B 分配一个协议中的任务。一旦类 B 完成任务，它会向类 A 汇报。让我们看看在我们的应用程序中是如何工作的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个协议，名为 AddBirthdayViewControllerDelegate，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用来报告。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器会创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，Add Birthday 视图控制器会调用这个方法 ➍，并将新的生日传递给它的代理——Birthdays 表视图控制器。Birthdays 表视图控制器会接收这个生日，添加到它的生日数组中，然后重新加载表视图 ➎，以便新添加的生日能够显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并使用方法 addBirthdayViewController(_:didAddBirthday:)，每当向应用程序中添加一个生日时，Add Birthday 视图控制器都可以调用这个方法。Birthdays 表视图控制器将实现这个协议方法，这样每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器只需对它的代理说：“嘿！有人刚刚添加了这个生日”，而 Birthdays 表视图控制器会收到消息并说：“哦！我会把它添加到我的列表中，并刷新我的显示，以便新生日能够显示出来。”

那么现在让我们在代码中实现这一切吧！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，*在* AddBirthdayViewController 类的上方，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你可以通过输入关键字 protocol 后跟协议名称 AddBirthdayViewControllerDelegate 来定义协议 ➊。虽然名字很长，但 Swift 程序员通常会以调用类的名称来命名协议，并在末尾加上 Delegate 一词。这样你就能通过查看协议的名称来判断哪个类在使用该协议。既然你现在是 Swift 程序员了，你应该遵循这种命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，用来将 Birthday 对象传回给代理类 ➋。注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。再次提醒，这是 Swift 程序员在实现协议方法时的惯例，所以你也应该遵循这一做法。这样做的好处是，你能够知道是谁发送回了消息，并且代理可以访问该对象及其类。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递。你很快就会看到这个是如何实现的。另一个需要注意的是外部参数名称 didAddBirthday。许多代理协议方法中都包含 *did* 和 *will*，因为它们用来描述调用类刚刚做了某事或将要做某事。

现在你已经定义了协议，接下来需要告诉 Birthdays 表视图控制器采用这个协议并使用协议的方法。

##### 让 Birthdays 表视图控制器遵循协议

为了采用该协议，Birthdays 表视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，紧接 UITableViewController 超类之后，添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色错误就会出现。这是因为 BirthdaysTableViewController 说它是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快就会修复这个问题。

需要注意的是，BirthdaysTableViewController 是继承自 UITableViewController 超类的。一个类只能有一个超类，而且这个超类的名称必须写在任何协议之前。但是，虽然一个类只能有一个超类，但它可以采用任意数量的协议——这些协议会在超类之后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将`addBirthdayViewController(_:didAddBirthday:)`方法添加到 Birthdays TableViewController 中。一个合适的位置是类的末尾，紧接着导航部分：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 的自动完成功能会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期望你添加这个方法。需要注意的是，与子类化的方法不同，添加`addBirthdayViewController(_:didAddBirthday:)`时，你不需要在方法前使用`override`关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的`append(_:)`方法来完成这一操作➋。接下来，你需要刷新表视图，以便它显示这个新添加的生日，方法是调用 tableView 属性上的`reloadData()`方法➌。当调用`reloadData()`时，表视图的数据源方法会重新被调用，新的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但在代码中标记不同的部分是一个良好的编程风格，有助于保持代码的简洁和可读性。注释的第一部分，`MARK: -`，是 Xcode 识别的一个特殊关键词，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录中，你可以在类的顶部使用该目录。这个下拉菜单帮助你找到方法，并可以让你跳转到代码的不同位置。要使用这个菜单，只需点击编辑窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内建的目录，方便快速跳转到某个章节。*

##### 为 Add Birthday 视图控制器设置委托

BirthdaysTableViewController 已经遵循了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来通知 Birthdays 表格视图控制器它已添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个可选的委托属性，类型为 AddBirthdayViewControllerDelegate，来安排此事，代码如下所示：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为直到*Add Birthday 视图控制器创建之后*，你才可以设置它。你将很快学到在哪里设置委托。

现在 Add Birthday 视图控制器已经有了一个委托，在 `saveTapped(_:)` 方法中，你可以通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将一个生日传递给委托。将 `saveTapped(_:)` 方法修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象后，➊ 处的代码通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将其传回给委托。

很棒！你已经完成了对 Add Birthday 视图控制器的修改。它现在有了一个委托，能够监听保存生日的调用。运行应用看看会发生什么。

嗯...似乎没有太大变化。当你添加一个生日时，仍然看不到它出现在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置委托连接两个控制器

你还有最后一件事需要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存它在保存生日时与之通信的委托。但是我们从未专门设置过这个委托属性为 Birthdays 表格视图控制器。所以，现在是时候连接这两个视图控制器之间的通信管道了。

在“生日表格视图控制器”类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除围绕它的/*和*/，取消注释这个方法。

每当“生日”表格视图控制器放弃屏幕并且应用程序通过 storyboard segue 转换到另一个视图控制器时，这个方法会自动调用。我们将使用这个方法将“生日”表格视图控制器传递给“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的代理。请在 prepare(for:sender:)方法中编写以下内容：

*BirthdayTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

需要三行代码将“添加生日”视图控制器的代理设置为“生日”表格视图控制器。首先，你需要能够从 segue 参数中获取到 AddBirthdayViewController 对象。Xcode 在注释中提示了你如何做到这一点。一个 UIStoryboardSegue 有一个名为 destination 的属性，指向这个方法中准备的 segue 的另一端，但对于这个应用程序来说，目标并不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到导航控制器中，这样你就可以拥有一个带有“取消”和“保存”按钮的导航栏。所以你不期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊行代码可以让你获取到 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定子类，我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取到“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前显示在 navigationController 中的视图控制器，但它的属性是 UIViewController 类型，因此必须将其强制转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的特定子类。最后，当你获得 AddBirthdayViewController 后，你可以将代理设置为 self，当前是“生日”表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在“生日”表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序并重新运行它，之前的生日将消失。我们仍然需要将生日保存到设备中，我们将在第十二章中实现这一点。

### 你学到的内容

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学习了如何在“添加生日”视图控制器中添加生日，然后如何使用代理将生日添加到“生日”表格视图控制器中的生日数组中，以便进行展示。

在第十二章中，你将学习如何将生日保存到设备中，以便即使退出应用并重新运行，它们依然会显示。为了保存生日，你将使用 Core Data，这是我们在项目开始时就设置好的。

当你选择这个选项时，会看到一个第二个对话框，在那里你可以为你的新类命名并指定要继承的类。首先，在子类字段（对话框中的第二个字段）中，输入 UITableViewController。这将自动填充类字段为子类名称。完成后，在 TableViewController 前输入 Birthdays，使得整个类名为 BirthdaysTableViewController。这是一个快捷方式，可以减少输入量。确保在语言下拉菜单中选择 **Swift**，然后点击 **Next**。接着，在最后一个对话框中选择 **Create** 来创建你的新文件。

在*BirthdaysTableViewController.swift* 中，Xcode 提供了一个模板，包含了几个被注释掉的方法。你可以通过删除我们不会使用的方法来清理代码。只需删除 viewDidLoad() 中的注释，然后删除整个 didReceiveMemoryWarning() 方法，以及与表视图中行的移动相关的方法 tableView(_:moveRowAt:to:) 和 tableView(_:canMoveRowAt:)。完成后，BirthdaysTableViewController 的内容应如下所示 图 11-2。虽然还有一些被注释掉的方法，但我们会保留它们以备后用！

![](img/Image00235.jpg)

*图 11-2：清理后的* BirthdaysTableViewController *！*

接下来，你需要将 Birthdays 表视图控制器设置为 BirthdaysTableViewController 类。为此，请进入 *Main.storyboard* 并选择 **Birthdays** 场景。在右侧窗格中使用身份检查器，将类从 UITableViewController 更改为 BirthdaysTableViewController，如 图 11-3 所示。

![](img/Image00236.jpg)

*图 11-3：将* BirthdaysTableViewController *设置为 Birthdays 场景的类*

现在你已经在 storyboard 中设置了 Birthdays 表视图控制器，接下来的步骤是创建表视图中的单元格，用于显示每个生日。

#### 向表视图添加单元格

每个生日将在 Birthdays 表视图控制器中的 UITableViewCell 中显示。表格由按行和列组织的信息框组成，这些框称为 *单元格*。类似地，表视图也有单元格，它们都是 UITableViewCell 类的实例或子类。我们将把每个生日放入表视图中的独立单元格中。

我们将从在 storyboard 中创建这些单元格开始，稍后再将它们填充到我们的 Birthday 对象中。在左侧大纲菜单中，点击 Birthdays 旁的三角形，然后点击 Table View 旁的三角形以打开这些部分。然后选择 **Table View Cell** ➊，如 图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建一个副标题样式的表格视图单元格并设置其标识符*

接下来，打开属性检查器。使用**样式**下拉菜单，将单元格的样式设置为**副标题** ➋，这样单元格就有了标题标签和副标题标签。你将在标题中显示每个人的姓名，在副标题中显示生日。

最后，在标识符字段中输入 birthdayCellIdentifier ➌。稍后你会使用这个标识符来填写单元格内容。

就这样！你已经完成了故事板中的工作。

你可能会想，为什么在故事板中的表格视图里只有一个单元格，而我们要在列表中显示多个生日？如果你再看看图 11-4，你会注意到单元格被标记为*原型单元格*。这意味着你刚刚自定义的单元格是你想要在表格视图中显示的所有单元格的*模板*。你为单元格指定的标识符是你的代码用来告诉表格视图生成每个单元格的方式，以便你将生日信息填充进去。很快你就会看到这如何工作。

**处理日期**

Swift 有一种特殊的数据类型，叫做 Date，用于存储日期值。一个 Date 对象实际上包括日期和时间。打开你的 playground，输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给了变量 today。当你打印 today 时，它的格式是 "2017-11-21 10:45:31 +0000\n"。如果你希望它显示为 Tuesday, November 21, 2017 呢？或者只是 11/21/17 呢？为了以特定的方式显示日期，你需要使用*日期格式化器*，它是一个 DateFormatter 对象，你可以创建并为它指定一个日期格式样式。DateFormatter 是一个辅助对象，用于从任何日期创建显示字符串，而*日期格式样式*是 DateFormatter 的一个属性，用来告诉格式化器使用哪种样式。你可以手动创建自己的日期格式样式，但 Swift 中也包含了一些现成的样式可以使用。将以下内容添加到你的 playground 中：

![](img/Image00240.jpg)

在 ➊ 处，你创建了一个格式化器。然后在 ➋ 处，你将格式化器的样式设置为 Style.full，这将打印星期几以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:) 方法 ➌ 从日期创建一个字符串。你可以看到，日期已经被转化为格式化好的字符串 "Tuesday, November 21, 2017"。表格 11-1 显示了使用 Swift 中五种 DateFormatter.Style 选项生成的不同字符串。

**表格 11-1：** 日期格式化样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "Nov 21, 2017" |
| long | "2017 年 11 月 21 日" |
| full | "Tuesday, November 21, 2017" |

你还可以使用 DateFormatter 的 dateFormat 属性来指定自定义的日期显示方式。也许你只想显示月和日，或者你可能想以简短样式显示四位数年份。做这两件事都非常简单，你甚至不需要创建一个新的 DateFormatter ——你只需要更改 formatter 上的 dateFormat，然后要求它生成一个新的字符串。将以下代码添加到你的 playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定只需要 MM/dd 格式的月和日——即两位数字的月份后跟两位数字的日期。如果你想显示三字母的月份，可以使用 MMM。如果想显示完整的月份名称，可以使用 MMMM。在 ➋ 处，我们将日期格式更改为使用四位数的年份。两位数的年份为 yy。这里有一些其他的方式，可以使用 dateFormat 来显示自定义的日期字符串。

![](img/Image00242.jpg)

如果你想包括分隔符，可以将它们添加到你的 dateFormat 字符串中。例如，如果你想使用句点作为分隔符，你可以创建一个类似 "MM.dd.yy" ➊ 的 dateFormat。要显示缩写形式的星期几，使用 EEE ➋。要显示完整的星期几，使用 EEEE ➌。这只是一些示例。通过使用 M、d、y 和 E 的组合，你可以用无尽的方式来显示日期！

#### 设置生日表视图控制器

生日表视图控制器将显示应用程序中所有存储的生日列表。你记得用什么来存储一系列的项目吗？没错——是数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有的生日。为此，在类的顶部，viewDidLoad() 方法的上方，插入这一行代码来添加一个名为 birthdays 的数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量而不是常量，因为你每次用户通过添加生日视图控制器添加一个生日时，都需要将已保存的 Birthday 添加到这个数组中。你将在 “使生日表视图控制器符合协议” 第 168 页 中看到如何做到这一点。

**注意**

*记得，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

生日表视图控制器还需要一个 dateFormatter 属性来将出生日期显示为格式良好的字符串。在 birthdays 数组下方添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，通过 `let` 创建。虽然你会改变 dateFormatter 的属性，例如 dateStyle 和 timeStyle，但你永远不会改变 dateFormatter 本身。

你还需要设置 dateFormatter，以便它能将出生日期显示为完整格式的字符串，比如“星期二，2008 年 12 月 17 日”。正如你在第十章中看到的，执行这个操作的好地方是 viewDidLoad() 方法，它会在“生日”表格视图控制器加载其视图时被调用。这是执行此类所需任何设置的完美时机。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 dateFormatter 的 dateStyle，使其能够为每个生日显示格式化的日期字符串。你是否注意到我们只写了 .full，而不是 DateFormatter.Style.full？Swift 知道 dateStyle 应该是 DateFormatter 的哪种类型，因此它允许我们用这个小快捷方式。 在 ➋ 处，你将 dateFormatter 的 timeStyle 设置为 .none，这样时间就不会显示。

#### 在表格视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于在单列中显示一系列项。表格视图有一个或多个包含行的部分，每一行都有一个单元格。表格视图中的一个部分是包含行的分组，这些行可以选择性地带有或不带有标题。一个展示多个部分的表格视图的应用示例是设置应用，如图 11-5 所示。它展示了一系列已被分为不同部分的行。

表格视图的每个部分和行都有一个索引号来进行标识。这些编号从 0 开始，往下排列时每一行的索引号会增加 1。例如，设置应用中的“隐私”行位于第零部分，第 1 行；“新闻”设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为 *表格视图数据源* 的部分，里面包含三个方法。表格视图控制器使用这些方法来确定将在其表格视图中显示的内容。

numberOfSections(in:) 告诉表格视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表格视图每个部分会显示多少行

tableView(_:cellForRowAt:) 设置每一行中将要显示的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用通过部分来分组不同的设备设置行。*

每当表格视图重新加载时，表格视图数据源方法会被表格视图控制器调用。当你创建 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。尽管你永远不会在代码中直接调用这些方法，但你仍然需要实现所有三个方法，以确保应用程序正常工作。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用于决定表格视图中将显示什么内容。我们将在“委托”一章的第 166 页讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要手动调用它们。

让我们从方法 numberOfSections(in:) 开始。Birthdays 表格视图控制器是一个仅展示 Birthday 实例的列表，因此它不需要多个 section。要设置表格视图中的 section 数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接收一个名为 tableView 的 UITableView 作为参数，它是使用这个类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 已经内置了一个表格视图，并且它会自动与这些方法连接。每个生日都会显示在自己的行中。因此，在 tableView(_:numberOfRowsInSection:) 中，为了确保有正确数量的行来展示所有生日，你需要返回 birthdays 数组中 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少项，它非常适用于这种情况！将这个方法改为以下代码：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，tableView(_:numberOfRowsInSection:) 还接收一个名为 section 的 Int 类型参数。当表格视图加载时，这个方法会为表格视图中的每个 section 被调用。在我们的例子中，我们只有一个 section，所以我们不需要担心检查哪个 section 正在显示。我们知道它是 section 0，并且我们希望它的行数等于生日的数量，因此我们写下 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:) 方法，以便表格视图知道在每个单元格中放入什么内容。由于这个方法已经被注释掉，你需要通过删除它两侧的 /* 和 */ 来取消注释它。（小心不要不小心取消注释它之后的其他方法！）在你完成这一操作后，将其改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法 tableView(_:cellForRowAt:)。它会在表格视图加载到屏幕时被调用。它会为屏幕上的每个单元格调用，并且需要两个参数：tableView 和 indexPath。你已经知道 tableView 参数是干什么的。IndexPath 是一个 Swift 结构体，用于表示表格视图中某一行的位置。一个 IndexPath 实例包含 section 属性和 row 属性。由于这个方法会被多次调用（每个表格行一次），我们需要 indexPath 来知道我们当前正在配置的是哪个 section 和 row。indexPath.section 属性给出节号，而 indexPath.row 给出表格视图单元格的行号。tableView(_:cellForRowAt:)方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定哪个生日在生日数组中会显示在单元格内

• 创建两个标签来显示生日人的姓名和出生日期

• 返回一个准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。➊处的代码通过调用方法 dequeueReusableCell(withIdentifier:for:)来完成这项操作。然而，在你开始使用该方法之前，你需要告诉它你想使用哪个单元格。早些时候，当你在故事板中时，你给单元格设置了标识符 birthdayCellIdentifier（见图 11-4）。这个标识符将你的代码与单元格关联起来，并告诉方法你正在使用正确的单元格。当你调用该方法时，字符串必须与你在故事板中设置的字符串完全相同，否则会报错，应用程序会在运行时崩溃。

在方法 dequeueReusableCell(withIdentifier:for:)中，你是否注意到“*Reusable Cell*”这几个词？表格视图中的单元格只会创建一次，然后可以反复使用。这有助于一切运行得更快、更流畅，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以查看更多生日时，滚动出屏幕顶部的单元格会被重新使用。它们会被填充新的信息，并在屏幕底部再次出现。UITableView 会自动完成这项工作。当表格视图加载时，tableView(_:cellForRowAt:)会为每一行可见的单元格调用。当用户滚动查看更多单元格时，它会再次为每一行调用，就在单元格即将出现在屏幕上时。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中显示生日数组中的一个生日。第一个生日，位于 birthdays[0]，应该显示在第 0 行。第二个生日，位于 birthdays[1]，应该显示在第 1 行，依此类推，这意味着 indexPath 的 row 和我们想要访问的生日数组中的位置相同。在 ➋ 处的代码通过使用 indexPath.row 从生日数组中获取正确的 Birthday 对象。一旦我们有了正确的 Birthday 对象，我们将其赋值给名为 birthday 的常量，以便我们可以设置此单元格中的标签。

注意，我们使用 let 将生日赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都会有自己的生日常量，并为其分配相应的 Birthday 对象。由于我们不打算修改任何生日常量 —— 我们只是读取它们的属性 —— 所以我们不需要将它们设置为变量。

现在你已经有了单元格和生日，是时候填充细节了。你需要为每个单元格添加两个标签，以显示生日人的名字和出生日期。你将单元格设置为副标题（Subtitle）样式，这样它就会有一个标题标签和一个副标题标签。每个单元格将已经包含这些标签，所以你现在不需要自己创建任何标签。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。代码在 ➌ 处将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格隔开。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法在 detailTextLabel 中显示出生日期。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 在 ➎ 返回该单元格，以便它可以在表视图的该 indexPath 上显示。

### 将所有内容整合在一起

现在，你可以通过添加生日视图控制器向应用程序中添加生日实例，并且你有了一个表视图来列出每个生日，显示在生日表视图控制器中。但当你尝试运行应用并添加一个生日时，它并没有显示出来。为了使你添加的每个生日出现在表视图中，你需要让添加生日视图控制器与生日表视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托（Delegation）可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 并不知道 A —— 它只是突然出现，并不知道它是从哪里来的，也不知道是如何到达的。那么 B 怎么能与 A 交流呢？通过委托！

![](img/Image00245.jpg)

委托是指将某个任务或工作交给别人做。*委托*就像是一个老板，告诉委托员工该做什么。当委托员工完成任务时，有时他们会将信息回报给委托的老板。

在 Swift 中，委托模式非常相似，但不是拥有老板和员工的关系，而是有一个委托和一个委托对象。由于是类 B 被类 A 告知该做什么，所以它是委托对象。我们给类 B 设置一个特殊的属性，叫做 delegate，用来告诉它谁是它的委托对象——这样，它就知道与谁进行通信。委托对象可以是任何具有在*协议*中定义的若干方法的类。协议就像是两个类之间的协议，告诉它们委托对象可以要求委托对象做什么。它有一个方法和属性名称的列表，委托对象可以使用这些方法与委托对象进行交互。

类 A 创建类 B，将自己设置为类 B 的委托，并给类 B 分配一个在协议中定义的任务。一旦类 B 完成了任务，它就会向类 A 回报。让我们看看在我们的应用程序中是如何工作的。

Birthdays 表视图控制器是视图控制器 A，Add Birthday 视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，Add Birthday 视图控制器将使用该方法进行回传。

请查看 图 11-6。当用户点击添加按钮 ➊ 时，Birthdays 表视图控制器创建 Add Birthday 视图控制器 ➋ 并将自己设置为 Add Birthday 视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托模式从 Add Birthday 视图控制器传递到 Birthdays 表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为具有一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，Add Birthday 视图控制器调用该方法 ➍ 并将新添加的生日传递给它的委托对象，Birthdays 表视图控制器。Birthdays 表视图控制器接收到这个生日后，将其添加到它的 birthdays 数组中，并重新加载表视图 ➎，这样新生日就会出现在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并为该协议定义方法 addBirthdayViewController(_:didAddBirthday:)，Add Birthday 视图控制器可以在每次添加生日时调用该方法。Birthdays 表视图控制器将实现该协议方法，以便每当通过 Add Birthday 视图控制器添加一个生日时，Add Birthday 视图控制器只需告诉它的委托：“嘿！刚刚有人添加了这个生日”，然后 Birthdays 表视图控制器就会听到这个消息并说：“哦！我会将其添加到我的列表中，并刷新显示，这样新的生日就会显示出来。”

现在，让我们开始编写代码！

##### 创建协议

首先，我们需要创建协议。在`*AddBirthdayViewController.swift*`文件中，在`AddBirthdayViewController`类之前，添加这段代码来定义`AddBirthdayViewControllerDelegate`协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过在➊处输入关键字`protocol`，后跟名称`AddBirthdayViewControllerDelegate`来定义协议。这个名字很长，但 Swift 程序员通常会根据调用类的名称命名他们的协议，并在末尾加上`Delegate`这个词。这样，你就能通过查看协议的名称来判断是哪个类在使用该协议。既然你现在是 Swift 程序员，你也应该遵循相同的命名惯例。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)`是唯一的函数，它用于将`Birthday`对象传回给代理类➋。注意，在这个函数中你将`AddBirthdayViewController`作为参数包含了进来。同样，Swift 程序员在实现协议方法时，通常会这样做，因此你也应该遵循这一惯例。这样做的好处是你可以知道是谁发送回了消息，并且代理可以访问该对象及其类。

当`Add Birthday`视图控制器调用此方法时，它将自身作为`addBirthdayViewController`参数传递。你很快就会看到这是如何实现的。另一个需要注意的点是外部参数名`didAddBirthday`。许多代理协议方法包含`*did*`和`*will*`这两个词，因为它们用于描述调用类刚刚做过或将要做的事情。

现在你已经定义了协议，接下来需要告诉`Birthdays`表视图控制器采纳该协议并使用协议中的方法。

##### 让 Birthdays 表视图控制器符合协议

为了采纳该协议，`Birthdays`表视图控制器需要让自己成为`AddBirthdayViewControllerDelegate`。为此，你需要在类定义中，紧跟`UITableViewController`超类之后，添加`AddBirthdayViewControllerDelegate`。在类的顶部，在`UITableViewController`后面添加一个逗号，然后输入`AddBirthdayViewControllerDelegate`：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做了，就会出现一个红色错误。这是因为`BirthdaysTableViewController`声明它是一个`AddBirthdayViewControllerDelegate`，但是它还没有实现这个协议！为了实现这一点，它需要实现`AddBirthdayViewControllerDelegate`协议的定义。别担心，我们很快就会解决这个问题。

这里需要注意的是，`BirthdaysTableViewController`是`UITableViewController`的子类。一个类只能有一个超类，且超类的名称必须写在任何协议之前。但是，虽然一个类只能有一个超类，它可以采纳任意多个协议——这些协议会列在超类后面，并用逗号隔开。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它预期你会添加这个方法。注意，与子类化的方法不同，你不需要在 addBirthdayViewController(_:didAddBirthday:) 前面使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递的生日添加到 birthdays 数组中。你可以使用数组的 append(_:) 方法来完成这件事 ➋ 。接下来，你需要刷新表格视图，以便显示这个新添加的生日，方法是调用 tableView 属性的 reloadData() 方法 ➌ 。当调用 reloadData() 时，表格视图的数据源方法将再次被调用，新增的生日将显示在生日列表的底部。

你可能注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必须的，但标记类的不同部分是一种良好的编码风格，有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的一个特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你找到方法，并让你跳转到代码中的不同位置。要使用这个菜单，请点击编辑器窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个章节。*

##### 给 Add Birthday 视图控制器设置代理

BirthdaysTableViewController 已采用 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来通知 Birthdays 表格视图控制器它已添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性来安排此操作，代码如下所示，紧跟在 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在创建 Add Birthday 视图控制器之后，你才可以设置它。稍后你将学习如何设置代理。

现在添加生日视图控制器有了代理，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将生日传递给代理。将 saveTapped(_:) 改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 将其传回给代理。

太好了！你已经完成了对添加生日视图控制器的更改。它现在有了一个代理，将监听生日保存的调用。运行应用程序看看发生了什么。

嗯……没什么变化。当你添加生日时，生日表格视图控制器仍然没有显示它。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事。生日表格视图控制器是 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用于保存它在保存生日时与之通信的代理。但我们从未明确将代理属性设置为生日表格视图控制器。所以现在是时候连接这两个视图控制器之间的通信管道了。

在 BirthdayTableViewController 类的导航部分，有一个已经被注释掉的方法叫做 prepare(for:sender:)。通过删除/*和*/将该方法取消注释。

每当生日表格视图控制器放弃其屏幕并且应用通过故事板 segue 切换到另一个视图控制器时，系统会自动调用此方法。我们将使用此方法将生日表格视图控制器传递给添加生日视图控制器，并将其设置为添加生日视图控制器的代理。请在 prepare(for:sender:) 方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需三行代码即可将添加生日视图控制器的代理设置为生日表格视图控制器。首先，你需要能够通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 在准备此方法时，在 segue 的另一端有一个名为 destination 的属性，但该应用的目标并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到一个导航控制器中，这样你就可以拥有一个包含“取消”和“保存”按钮的导航栏。所以你不会期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊ 处的代码可以获得 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是一个特定类型的视图控制器，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是导航控制器的 topViewController ➋。topViewController 就是在导航控制器中显示的视图控制器，但它的属性是 UIViewController 类型，所以必须将其类型转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 时，可以将代理设置为 self，当前它是 Birthdays 表视图控制器 ➌。

现在运行应用并添加一些生日！你在生日表视图控制器中看到什么？生日！生日！生日！不过，我们还没有完成。如果你退出应用程序并重新运行，之前的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学习了如何创建一个表视图控制器来显示你的生日列表。你还学习了如何在添加生日视图控制器中添加生日，然后如何使用代理将生日添加到 Birthdays 表视图控制器中的生日数组，以便能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用程序并重新运行，它们仍然会显示。要保存生日，你将使用我们在项目开始时设置的 Core Data。

在*BirthdaysTableViewController.swift*中，Xcode 提供了一个包含多个已注释掉的方法的模板。你可以通过删除我们不会使用的方法来清理代码。只删除 viewDidLoad()中的注释，然后删除整个 didReceiveMemoryWarning()方法以及与表视图中移动行相关的 tableView(_:moveRowAt:to:)和 tableView(_:canMoveRowAt:)方法。当你完成后，BirthdaysTableViewController 的内容应如下所示：图 11-2。虽然仍有几个已注释掉的方法，但我们将保留它们以便以后使用！

![](img/Image00235.jpg)

*图 11-2：* BirthdaysTableViewController *清理完毕！*

接下来，你需要将 Birthdays 表视图控制器设置为 BirthdaysTableViewController 类。为此，请打开*Main.storyboard*并选择**生日**场景。使用右侧面板中的身份检查器，将类从 UITableViewController 更改为 BirthdaysTableViewController，如图 11-3 所示。

![](img/Image00236.jpg)

*图 11-3：将* BirthdaysTableViewController *设置为生日场景的类*

现在你已经在故事板中设置了 Birthdays 表视图控制器，下一步是制作表中的单元格，以显示每个生日。

#### 向表视图添加单元格

每个生日都会显示在 Birthdays 表视图控制器中的 UITableViewCell 中。表格由组织成行和列的框组成，这些框中包含信息。这些框被称为*单元格*。类似地，表视图也有单元格，所有单元格都是 UITableViewCell 类的实例或其子类。我们将把每个生日放入表视图中的单独单元格。

我们将从在故事板中创建这些单元格开始，然后稍后会用我们的 Birthday 对象填充它们。在左侧大纲菜单中，点击 Birthdays 旁边的三角形，然后点击 Table View 旁边的三角形以展开这些部分。接着选择**Table View Cell** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建一个副标题样式的表视图单元格并设置其标识符*

接下来，打开属性检查器。在**样式**下拉菜单中，将单元格的样式设置为**Subtitle** ➋，这样单元格就会有标题标签和副标题标签。你将在标题中显示每个人的姓名，在副标题中显示生日。

最后，在 Identifier 字段中输入 birthdayCellIdentifier ➌。你将在稍后填充单元格内容时使用这个标识符。

就这样！你已经完成了在故事板中的工作。

你可能会想，为什么我们在故事板中只在表视图中有一个单元格，而列表中会有多个生日需要显示呢？如果你再看一眼图 11-4，你会注意到这个单元格被标记为*原型单元格*。这意味着你刚刚自定义的单元格是你想要在表视图中显示的所有单元格的*模板*。你给单元格指定的标识符就是你的代码告诉表视图如何为你生成每个单元格以便放入生日的方式。你很快就会看到它是如何工作的。

**处理日期**

Swift 有一个特殊的数据类型叫做 Date，用于存储日期值。Date 对象实际上表示一个日期和一个时间。打开你的 playground 并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将运行代码时的当前日期和时间赋值给了变量 today。当你打印 today 时，它的格式是"2017-11-21 10:45:31 +0000\n"。如果你想让它显示为"2017 年 11 月 21 日，星期二"呢？或者只显示"11/21/17"呢？要以特定方式显示日期，你需要使用*日期格式化器*，它是一个 DateFormatter 对象，你可以创建它并指定日期格式样式。DateFormatter 是一个辅助对象，用于从任何日期创建显示字符串，*日期格式样式*是 DateFormatter 的一个属性，用来告诉格式化器使用哪种样式。你可以手动创建自己的日期格式样式，但 Swift 也提供了一些现成的样式，可以直接使用。将以下内容添加到你的 playground 中：

![](img/Image00240.jpg)

在➊，你创建一个格式化器。然后在➋，你将格式化器的样式设置为 Style.full，这将打印星期几以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:)方法从日期中创建一个字符串 ➌。你可以看到，现在你已经将日期转换成了格式良好的字符串"2017 年 11 月 21 日，星期二"。表 11-1 展示了 Swift 中可用的五种 DateFormatter.Style 选项所创建的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "2017 年 11 月 21 日" |
| long | "2017 年 11 月 21 日" |
| full | "2017 年 11 月 21 日，星期二" |

你也可以通过 DateFormatter 的 dateFormat 属性指定自己定制的日期显示方式。也许你只想显示月份和日期。或者你可能希望以简短的方式显示四位数的年份。无论哪种方式都很简单，而且你甚至不需要创建新的 DateFormatter——你只需要修改格式化器的 dateFormat，然后请求它返回一个新的字符串。将以下代码添加到你的 playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在➊，你指定只想要月份和日期，格式为 MM/dd——也就是两位数的月份，后面跟着两位数的日期。如果你想将月份显示为三个字母，可以使用 MMM。要显示完整的月份名称，使用 MMMM。在➋，我们将日期格式改为使用四位数年份。两位数的年份使用 yy。这里有一些其他方式可以使用 dateFormat 来显示自定义的日期字符串。

![](img/Image00242.jpg)

如果你想要包含分隔符，可以将它们添加到你的 dateFormat 字符串中。例如，如果你想要使用句点作为分隔符，你可以创建一个像"MM.dd.yy"这样的 dateFormat ➊。要显示缩写的星期几，使用 EEE ➋。要显示完整的星期几，使用 EEEE ➌。这些只是几个示例。通过使用 M、d、y 和 E 的组合，你可以有无数种方式来显示日期！

#### 设置生日表视图控制器

生日表视图控制器将显示应用程序中存储的所有生日的列表。你记得用什么来存储一系列项目吗？没错——是数组！你将在 BirthdaysTableViewController 中创建一个数组，用来存储所有的生日。为此，在类的顶部，紧接着 viewDidLoad()方法上方，插入这一行代码，为生日添加一个名为 birthdays 的属性，它是一个包含 Birthday 对象的数组：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的生日实例数组。它需要是一个变量而不是常量，因为每次用户通过添加生日视图控制器添加生日时，你都希望将保存的生日添加到这个数组中。你将在“使生日表视图控制器遵循协议”中看到如何实现这一点，位于第 168 页。

**注意**

*请记住，项目文件的最终版本可从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *获取。*

`BirthdaysTableViewController` 还需要一个 `dateFormatter` 属性，用于将出生日期显示为格式化的字符串。在生日数组下方添加一个 `dateFormatter`：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，`dateFormatter` 是一个通过 `let` 创建的常量。尽管你会更改 `dateFormatter` 的属性，例如 `dateStyle` 和 `timeStyle`，但你永远不会更改 `dateFormatter` 本身。

你还需要设置 `dateFormatter`，以便它能够将出生日期显示为完全格式化的字符串，如“2008 年 12 月 17 日，星期二”。正如你在第十章中看到的，执行此操作的一个好地方是 `viewDidLoad()` 方法，它在生日表视图控制器加载其视图时被调用。这是进行任何所需设置的最佳位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在➊处，你设置了 `dateFormatter` 的 `dateStyle`，以便它为每个生日显示格式化的日期字符串。你是否注意到我们只写了 `.full`，而不是 `DateFormatter.Style.full`？Swift 知道 `DateFormatter` 的 `dateStyle` 应该是什么类型，因此它允许我们采用这个简短的写法。在➋处，你将 `dateFormatter` 的 `timeStyle` 设置为 `.none`，以确保不会显示时间。

#### 在表视图中显示生日

`BirthdaysTableViewController` 类有一个表视图，用于显示单列项目的列表。表视图包含一个或多个部分，每个部分包含若干行，每行都有一个单元格。表视图中的部分是行的分组，可以显示有无标题。一个显示多个部分的表视图应用示例是设置应用程序，如图 11-5 所示。它显示了一个将行分为不同部分的列表。

表视图的每个部分和行都有一个索引号。这些数字从 0 开始，然后按顺序递增。例如，设置应用中的“隐私”一行位于部分 0，行 1。新闻设置位于部分 1，行 3。

在 `BirthdaysTableViewController` 类的中间，有一个名为 *表视图数据源* 的部分，包含三个方法。表视图控制器使用这些方法来确定在其表视图中显示什么内容。

`numberOfSections(in:)` 告诉表视图它应该有多少个部分

`tableView(_:numberOfRowsInSection:)` 告诉表格视图每个部分将显示多少行

`tableView(_:cellForRowAt:)` 设置将在每个表格视图行中显示的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用程序使用部分将不同设备设置的行分组。*

表格视图的数据源方法在每次表格视图重新加载时由表格视图控制器调用。当你创建 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现这三个方法才能使应用程序正常工作，尽管你在代码中永远不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用于确定表格视图中将显示的内容。我们将在 “委托” 一节中讨论协议。在此之前，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要手动调用它们。

我们从 `numberOfSections(in:)` 方法开始。Birthdays 表格视图控制器是一个只显示 Birthday 实例的列表，因此它不需要多个部分。为了设置表格视图的部分数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 `tableView` 的 UITableView 作为参数，它是使用这个类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 内建了一个表格视图，并且自动与这些方法连接。每个生日将显示在它自己的行中。因此，在 `tableView(_:numberOfRowsInSection:)` 方法中，为了确保表格视图有正确的行数来显示所有的生日，你需要返回 `birthdays` 数组中 Birthday 实例的数量。你还记得数组的 `count` 属性吗？它是一个整数，告诉你数组中有多少项，这在这里非常适用！将这个方法更改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 `tableView` 参数，`tableView(_:numberOfRowsInSection:)` 还接受一个名为 `section` 的 `Int` 参数。当表格视图加载时，这个方法会为表格视图的每个部分调用。在我们的例子中，只有一个部分，所以我们不需要检查这里显示的是表格视图的哪一部分。我们知道是第零部分，并且我们希望它有与生日数量相同的行数，所以我们写 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)` 方法，这样表格视图就知道在每个单元格中放置什么内容。由于这个方法已经被注释掉了，你需要通过删除它周围的 `/*` 和 `*/` 来取消注释。（小心不要意外地取消注释后面的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用 `tableView(_:cellForRowAt:)` 方法。它会在表格视图加载到屏幕时被调用。它会为屏幕上的每个单元格被调用，并接受两个参数：`tableView` 和 `indexPath`。你已经知道 `tableView` 参数的作用。`IndexPath` 是一个 Swift 结构体，用来表示表格视图中某一行的位置。`IndexPath` 实例有一个 `section` 属性和一个 `row` 属性。由于这个方法会被多次调用（每次为表格中的一行），我们需要 `indexPath` 来知道我们正在配置的是哪一节和哪一行。`indexPath.section` 属性给出节号，而 `indexPath.row` 给出表格视图单元格的行号。`tableView(_:cellForRowAt:)` 方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 `UITableViewCell`

• 确定在 `birthdays` 数组中哪个生日将在单元格内显示

• 创建两个标签来显示生日人的名字和出生日期

• 返回准备好在表格视图中显示的单元格

让我们逐行分析这段代码。

首先，创建 `UITableViewCell`。在 ➊ 处的代码使用 `dequeueReusableCell(withIdentifier:for:)` 方法实现这一点。不过，在你开始在单元格上使用此方法之前，你需要告诉它你想从故事板中使用哪个单元格。早些时候，当你在故事板中时，你为单元格设置了标识符 `birthdayCellIdentifier`（见 图 11-4）。这个标识符将你的代码和单元格连接起来，并告诉方法它正在使用正确的单元格。你调用此方法时的字符串需要与在故事板中设置的字符串完全相同，否则会报错，应用程序在运行时会崩溃。

在 `dequeueReusableCell(withIdentifier:for:)` 方法中，你注意到“*可重用单元格*”这几个字了吗？表格视图中的单元格只会创建一次，然后可以被反复重用。这有助于提升运行速度和平滑度，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但每次屏幕上只能显示 10 个，那么你只需要 10 个单元格来展示这些生日。当你向下滚动显示更多生日时，屏幕上方滚出的单元格会被重用。它们会被填充新的信息，并出现在屏幕底部。`UITableView` 会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)` 会为每一行被调用。当用户滚动以查看更多单元格时，每当行即将出现在屏幕上时，方法会再次被调用。

接下来，我们需要找出应该在单元格内显示的生日。我们希望在每一行显示 birthdays 数组中的一个生日。第一个生日，即 birthdays[0]，应该显示在第 0 行。第二个生日，即 birthdays[1]，应该显示在第 1 行，以此类推，这意味着 indexPath 的行与我们希望访问的 birthdays 数组中的位置相同。➋处的代码通过使用 indexPath.row 从 birthdays 数组中访问正确的 Birthday 对象。一旦我们获得正确的 Birthday 对象，就将其分配给名为 birthday 的常量，以便在此单元格中设置标签。

请注意，我们使用 let 将生日分配给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的 birthday 常量。每个单元格都会有自己的 birthday 常量，且会分配自己的 Birthday 对象。由于我们不会改变任何生日常量——我们只是读取它们的属性——因此我们不需要将它们设置为变量。

现在你有了单元格和生日，是时候填充细节了。你需要两个标签来显示生日者的姓名和出生日期。你将单元格设置为副标题样式，这样它就有一个标题标签和一个副标题标签。每个单元格已经包含这些标签，因此现在你不需要自己创建标签了。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌处的代码将 textLabel 的文本设置为由 birthday 的 firstName 和 lastName 组成的字符串，两者之间有一个空格。在➍处，使用 dateFormatter 的 string(from:)方法，将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好时，tableView(_:cellForRowAt:)会返回该单元格，以便它可以显示在表格视图的该 indexPath 处。

### 整合所有内容

现在，你可以使用“添加生日”视图控制器将生日实例添加到应用程序中，并且有一个表格视图列出每个生日，在 Birthdays 视图控制器中显示。但当你尝试运行应用程序并添加生日时，它没有显示出来。为了让你添加的每个生日出现在表格视图中，你需要让“添加生日”视图控制器与 Birthdays 视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建 B 并将其展示在自己之上。A 知道 B，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但 B 并不知道 A——它只是突然出现的，并不知道它是从哪里来的或者怎么到达的。那么 B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项工作或任务交给另一个人。*委托人*就像一个老板，告诉被委托的员工该做什么。当被委托的员工完成任务后，有时他们会向委托人报告信息。

在 Swift 中，委托机制非常相似，但不同于老板和员工，我们有委托者和被委托对象。由于 B 类是由 A 类告知该做什么的，因此 B 类是被委托对象。我们给 B 类一个特殊的属性，称为 delegate，用来告诉它它的委托者是谁——这样，它就知道该与谁进行沟通。委托者可以是任何具有一组在*协议*中定义方法的类。协议就像是两个类之间的约定，告诉它们委托者可以要求被委托对象做什么。协议中列出了委托者可以与被委托对象一起使用的方法和属性名称。

类 A 创建类 B，令自己成为类 B 的委托者，并为类 B 分配协议中的任务。一旦类 B 完成了任务，它就会向类 A 报告。让我们看看这个在应用中是如何工作的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，添加生日视图控制器将使用该方法进行报告。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器创建了添加生日视图控制器 ➋ 并将自己设置为该视图控制器的委托者。

![](img/Image00246.jpg)

*图 11-6：一个新生日通过委托从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为具有一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，添加生日视图控制器调用该方法 ➍ 并将新生日传递给它的委托者，即生日表视图控制器。生日表视图控制器接收到这个生日，将其添加到它的生日数组中，然后重新加载表视图 ➎，这样新生日就会显示在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并包含方法 addBirthdayViewController(_:didAddBirthday:)，该方法可以在每次将生日添加到应用程序时由添加生日视图控制器调用。生日表视图控制器将实现该协议方法，这样每当通过添加生日视图控制器添加一个生日时，添加生日视图控制器就可以对其委托者说：“嘿！有人刚刚添加了这个生日，”而生日表视图控制器将听到这个消息并说：“哦！我会将它添加到我的列表中，并刷新显示，以便新的生日会显示出来。”

那么现在让我们在代码中实现这一功能！

##### 创建一个协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类*之前*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处通过键入关键字 protocol 来定义协议，后面跟着协议的名字 AddBirthdayViewControllerDelegate。这个名字很长，但 Swift 程序员通常会在协议名称中使用调用类的名称，并在结尾加上 Delegate。这样你就可以通过查看协议的名字来知道哪个类在使用这个协议。既然你现在是 Swift 程序员，你应该遵循相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传递回委托类➋。注意，在这个函数中你将 AddBirthdayViewController 作为一个参数包含进来。再一次，Swift 程序员在实现协议方法时，通常会这样做，因此你也应该坚持这么做。这对于知道是谁发送回了消息，并且让委托类可以访问该对象及其类非常有用。

当 AddBirthday 视图控制器调用此方法时，它会将自己作为 addBirthdayViewController 参数传递。你很快就会看到这是如何做到的。另一个需要注意的点是外部参数名称 didAddBirthday。许多委托协议方法包含*did*和*will*这两个词，因为它们用于描述调用类刚刚做完的事情或即将做的事情。

现在你已经定义了协议，需要告诉 Birthdays 表视图控制器采用这个协议并使用协议中的方法。

##### 使 Birthdays 表视图控制器符合协议

为了采用该协议，Birthdays 表视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，将 AddBirthdayViewControllerDelegate 添加到 UITableViewController 父类之后。在类的顶部，在 UITableViewController 后添加逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，就会出现一个红色的错误。这是因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会修复这个问题。

在这里需要注意的是，BirthdaysTableViewController 是继承自 UITableViewController 的子类。一个类只能有一个父类，而且父类的名字必须在任何协议之前写出。但是，虽然一个类只能有一个父类，它可以采用任意多个协议——这些协议将会在父类之后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的地方是将其添加到类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成功能会建议你完整的方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期望你添加这个方法。请注意，不同于子类化的方法，你在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的生日添加到 birthdays 数组中。你可以通过使用 append(_:) 方法来完成这项工作 ➋。接下来，你需要刷新表格视图，以便它显示这个新生日，可以通过调用 tableView 属性上的 reloadData() 方法来实现 ➌。当 reloadData() 被调用时，表格视图的数据源方法会重新调用，新增的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但标记类的不同部分是一种良好的编码风格，它有助于保持代码的整洁和可读性。注释的第一部分，MARK: -，是一个 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单帮助你查找方法，并可以让你跳转到代码中的不同位置。要使用此菜单，请点击编辑器窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类内置了一个目录，可以快速跳转到某个章节。*

##### 给添加生日视图控制器设置委托

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知 Birthdays 表格视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性来安排这一点，方法是在 outlets 部分下方插入以下代码：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在**添加生日**视图控制器创建之前，你无法设置它。你将很快了解到在哪里设置委托。

现在“添加生日”视图控制器有了一个代理，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将生日对象传递给代理。将 saveTapped(_:) 修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建了生日对象之后，➊ 这一行代码通过 addBirthdayViewController(_:didAddBirthday:) 将其传递回代理。

太好了！你已经完成了对“添加生日”视图控制器的更改。现在它有了一个代理，能够监听生日保存的事件。运行应用程序，看看会发生什么。

嗯……似乎没有太大变化。当你添加一个生日时，仍然看不到它出现在“生日”表视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

你还需要做最后一件事。“生日”表视图控制器是一个 AddBirthdayViewControllerDelegate，而“添加生日”视图控制器有一个名为 AddBirthdayViewControllerDelegate 的属性，它存储了与之通信的代理，当生日被保存时会通知代理。但是我们从未明确将代理属性设置为“生日”表视图控制器。因此，现在是时候将这两个视图控制器之间的通信管道连接起来了。

在 BirthdaysTableViewController 类的“导航”部分，有一个被注释掉的方法，名为 prepare(for:sender:) 。通过删除 /* 和 */，取消注释该方法。

每当“生日”表视图控制器放弃其屏幕并且应用通过 storyboard segue 转到另一个视图控制器时，都会自动调用这个方法。我们将使用这个方法将“生日”表视图控制器传递给“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的代理。请在 prepare(for:sender:) 方法中写下以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的代理为“生日”表视图控制器需要三行代码。首先，你需要能够从 segue 参数中获取到 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何实现。UIStoryboardSegue 有一个名为 destination 的属性，它指向在这个方法中正在准备的 segue 目标，但对于这个应用程序来说，目标并不是 AddBirthdayViewController。

在第九章，你将“添加生日”视图控制器嵌入到导航控制器中，以便拥有带有“取消”和“保存”按钮的导航栏。因此，你不应该期待在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊ 这一行代码为你提供了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定类型，我们需要使用 as 进行类型转换，将其转换为 UINavigationController。

接下来，您可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以指示该控制器是 UIViewController 的一个特定子类。最后，当您获得 AddBirthdayViewController 时，可以将代理设置为 self，即当前的“生日”表视图控制器 ➌。

现在运行应用程序并添加一些生日！您在“生日”表视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果您退出应用程序然后再次运行它，之前的生日将会消失。我们仍然需要将生日保存到设备中，我们将在第十二章中实现这一点。

### 您学到的内容

在本章中，您学习了如何制作一个表视图控制器来显示您的生日列表。您还学会了如何在“添加生日”视图控制器中添加一个生日，然后如何使用代理将生日添加到“生日”表视图控制器中的生日数组中，以便它可以显示出来。

在第十二章中，您将学习如何将生日保存到您的设备中，这样即使您退出应用程序并重新运行，它们也会显示出来。为了保存生日，您将使用 Core Data，我们在项目一开始就已经设置了 Core Data。

![](img/Image00235.jpg)

*图 11-2：“BirthdayTableViewController”清理后的样子！*

接下来，您需要将“生日”表视图控制器设置为 BirthdaysTableViewController 类。为此，请打开*Main.storyboard*并选择**生日**场景。在右侧窗格的 Identity Inspector 中，将类从 UITableViewController 更改为 BirthdaysTableViewController，如图 11-3 所示。

![](img/Image00236.jpg)

*图 11-3：将* BirthdaysTableViewController *设置为生日场景的类*

现在，您已经在故事板中设置了“生日”表视图控制器，下一步是创建显示每个生日的表格单元格。

#### 向表视图添加单元格

每个生日将显示在“生日”表视图控制器中的一个 UITableViewCell 中。表格由按行列组织的包含信息的框组成，这些框被称为*单元格*。类似地，表视图也有单元格，所有这些单元格都是 UITableViewCell 类的实例或其子类。我们将每个生日放入表视图中的一个单独的单元格。

我们将从在故事板中创建这些单元格开始，然后稍后将它们填充为我们的生日对象。在左侧的轮廓菜单中，点击“生日”旁边的三角形，然后点击“表格视图”旁边的三角形以展开这些部分。然后选择**表格视图单元格** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建一个字幕样式的表格视图单元格并设置其标识符*

接下来，打开属性检查器。使用**样式**下拉菜单，将单元格的样式设置为**字幕** ➋，这样单元格就会有一个标题标签和一个字幕标签。你将在标题中显示每个人的名字，在字幕中显示生日。

最后，在标识符字段中输入 birthdayCellIdentifier ➌。稍后你会用这个标识符来填写单元格内容。

就这样！你已经完成了故事板中的工作。

你可能会想，为什么在我们的故事板中表格视图只有一个单元格，而我们需要显示多个生日呢？如果你再次查看图 11-4，你会注意到单元格标记为*原型单元格*。这意味着你刚才定制的单元格是你希望在表格视图中显示的所有单元格的*模板*。你为单元格指定的标识符就是你的代码指示表格视图为你创建每个单元格并放入生日数据的方式。你很快就会看到这是如何工作的。

**日期处理**

Swift 有一种特殊的数据类型叫做 Date，用于存储日期值。Date 对象实际上是一个日期和时间。打开你的 playground 并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量 today。当你打印 today 时，它的格式是"2017-11-21 10:45:31 +0000\n"。如果你想让它显示为 2017 年 11 月 21 日，星期二呢？或者仅仅是 11/21/17 呢？为了以特定的方式显示日期，你需要使用*日期格式化器*，这是一个你创建并指定日期格式样式的 DateFormatter 对象。DateFormatter 是一个辅助对象，用于从任何日期创建显示字符串，而*日期格式样式*是 DateFormatter 的一个属性，告诉格式化器使用什么样式。你可以手动创建自己的日期格式样式，但 Swift 中也提供了现成的样式可以使用。将以下内容添加到你的 playground 中：

![](img/Image00240.jpg)

在➊处，你创建了一个格式化器。然后在➋处，你将格式化器的样式设置为 Style.full，这样就会打印出星期几、完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:)方法➌将日期转化为字符串。你可以看到，现在你已经将日期转换为格式良好的字符串"2017 年 11 月 21 日，星期二"。 表 11-1 展示了从 Swift 中五种 DateFormatter.Style 选项生成的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "2017 年 11 月 21 日" |
| long | "2017 年 11 月 21 日" |
| full | "2017 年 11 月 21 日，星期二" |

你还可以指定自定义的日期显示方式，使用 DateFormatter 的 dateFormat 属性。也许你只想显示月份和日期，或者你可能希望以简短样式显示四位数的年份。做到这点很简单，你甚至不需要创建新的 DateFormatter——只需要更改 formatter 上的 dateFormat，然后请求一个新的字符串。将以下代码添加到你的 playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在➊，你指定只想要以 MM/dd 格式显示月份和日期——即一个两位数的月份，后跟一个两位数的日期。如果你希望显示月份的三个字母缩写，可以使用 MMM。如果要显示完整的月份名称，则使用 MMMM。在➋，我们将日期格式更改为使用四位数的年份。两位数的年份用 yy 表示。以下是几种其他使用 dateFormat 显示自定义日期字符串的方式。

![](img/Image00242.jpg)

如果你想要包含分隔符，可以将其添加到你的 dateFormat 字符串中。例如，如果你想使用句点作为分隔符，可以创建一个像"MM.dd.yy"这样的 dateFormat ➊。要显示简写的星期几，可以使用 EEE ➋。要显示完整的星期几，可以使用 EEEE ➌。这些只是一些示例。通过组合 M、d、y 和 E，你可以有无数种显示日期的方式！

#### 设置生日表视图控制器

生日表视图控制器将显示应用中存储的所有生日的列表。你还记得用什么来存储项目列表吗？没错——是数组！你将在 BirthdaysTableViewController 中创建一个数组，用来存储所有的生日。为此，给 BirthdaysTableViewController 添加一个名为 birthdays 的属性，这个属性是一个 Birthday 对象的数组。在类的顶部，紧接着 viewDidLoad()方法，插入这一行代码来添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量，而不是常量，因为每次用户通过 Add Birthday 视图控制器添加生日时，你都需要将一个已保存的生日添加到这个数组中。你将在“使生日表视图控制器遵循协议”的第 168 页中看到如何做到这一点。

**注意**

*请记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

生日表视图控制器还需要一个 dateFormatter 属性来将生日以格式良好的字符串显示。将 dateFormatter 添加到 birthdays 数组的下方：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，用 let 创建。虽然你会更改 dateFormatter 的属性，如 dateStyle 和 timeStyle，但你永远不会更改 dateFormatter 本身。

你还需要设置 dateFormatter，这样它就能以完整格式的字符串（例如 "Tuesday, December 17, 2008"）显示出生日期。正如你在第十章中看到的，最好的做法是在 viewDidLoad() 方法中进行设置，该方法在出生日期表格视图控制器加载视图时被调用。这是进行该类所需设置的完美位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊，你设置了 dateFormatter 的 dateStyle，使其显示格式化的日期字符串以表示每个生日。你是否注意到我们只是写了 .full，而不是 DateFormatter.Style.full？Swift 知道对于 DateFormatter 的 dateStyle 应该期待什么类型，所以它允许我们使用这个小技巧。在 ➋，你将 dateFormatter 的 timeStyle 设置为 .none，这样就不会显示时间。

#### 在表格视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于显示单列项目列表。该表格视图有一个或多个包含行的部分，每行包含一个单元格。表格视图中的部分是行的分组，可以显示或不显示标题。一个显示包含多个部分的表格视图的应用示例是设置应用，如图 11-5 所示。它显示了被分成不同部分的行列表。

表格视图的每个部分和行都有一个索引号。这些数字从 0 开始，向下增加 1。例如，设置应用中的隐私行位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为*表格视图数据源*的部分，包含三个方法。表格视图控制器使用这些方法来确定将在表格视图中显示的内容。

numberOfSections(in:) 告诉表格视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表格视图每个部分将显示多少行

tableView(_:cellForRowAt:) 设置每个将要显示的表格视图行的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分来分组不同设备设置的行。*

每次重新加载表视图时，表视图控制器都会调用表视图数据源方法。当你创建一个 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现这三个方法，才能让应用正常工作，尽管你永远不会在代码中直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用于确定表视图中将显示的内容。我们将在第 166 页的“代理”中讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要手动调用它们。

我们从方法 numberOfSections(in:)开始。Birthdays 表视图控制器是一个仅显示生日实例的列表，因此它不需要多个部分。为了设置表视图中的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

该方法接受一个名为 tableView 的 UITableView 作为参数，表示使用此类作为数据源的表视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内置的表视图，它会自动与这些方法连接。每个生日将显示在它自己的行中。因此，在 tableView(_:numberOfRowsInSection:)方法中，为了让所有生日的行数正确，你需要返回你在 birthdays 数组中的 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少项，非常适合这种情况！将该方法修改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，tableView(_:numberOfRowsInSection:)方法还接受一个名为 section 的 Int 类型参数。当表视图加载时，这个方法会为表视图中的每个部分调用。在我们的例子中，只有一个部分，因此我们不需要担心检查当前显示的是哪个部分。我们知道它是第零部分，我们希望它的行数与生日的数量相同，因此我们写`return birthdays.count`。

最后，你需要实现 tableView(_:cellForRowAt:)方法，这样表视图才知道在每个单元格中放置什么内容。由于这个方法被注释掉了，你需要通过删除/*和*/来取消注释它。（小心不要不小心取消注释它后面的其他方法！）完成后，将其改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法 `tableView(_:cellForRowAt:)`。这个方法会在表格视图加载到屏幕时自动调用。它会为屏幕上的每个单元格调用，并接受两个参数：tableView 和 indexPath。你已经知道 tableView 参数的作用了。IndexPath 是一个 Swift 结构体，用来表示表格视图中一行的位置。一个 IndexPath 实例有 section 属性和 row 属性。由于这个方法会被多次调用（每个表格行一次），我们需要使用 indexPath 来了解我们当前正在配置的是哪一节和哪一行。indexPath.section 属性返回节号，而 indexPath.row 返回表格视图单元格的行号。`tableView(_:cellForRowAt:)` 方法中的五行代码将完成以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定在 birthdays 数组中哪一项生日将显示在单元格内

• 在单元格中显示生日人的姓名和出生日期，创建两个标签

• 返回已经准备好在表格视图中显示的单元格

让我们逐行解析这段代码。

首先，创建 UITableViewCell。➊ 处的代码使用方法 `dequeueReusableCell(withIdentifier:for:)` 完成这一操作。不过，在你开始使用这个方法之前，你需要告诉方法你希望从 storyboard 中使用哪个单元格。早些时候，当你在 storyboard 中时，你为单元格指定了标识符 `birthdayCellIdentifier`（见 图 11-4）。这个标识符将你的代码与单元格链接，并告诉方法它正在使用正确的单元格。你调用该方法时使用的字符串必须与 storyboard 中设置的字符串完全一致，否则你会遇到错误，运行时应用程序会崩溃。

在方法 `dequeueReusableCell(withIdentifier:for:)` 中，你是否注意到 *可重用单元格* 这几个字？表格视图中的单元格会被创建一次，然后可以反复重用。这能帮助提高性能，使一切运行得更快更顺畅，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你滚动页面显示更多的生日时，已经滚出屏幕顶部的单元格会被重用。它们会被填充上新的信息，并在屏幕底部重新显示。UITableView 会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)` 方法会为每一行可见的单元格被调用。当用户滚动查看更多单元格时，方法会在每一行即将显示到屏幕上时再次被调用。

接下来，我们需要找出应该显示在单元格中的生日。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日，在 birthdays[0]，应该显示在第 0 行。第二个生日，在 birthdays[1]，应该显示在第 1 行，以此类推，这意味着 indexPath 的行数与我们想要访问的 birthdays 数组中的位置相同。代码中的 ➋ 通过使用 indexPath.row 来访问 birthdays 数组中的正确生日对象。一旦我们找到了正确的生日对象，我们将其赋值给一个名为 birthday 的常量，以便在这个单元格中设置标签。

请注意，我们使用 let 将生日赋值给常量而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都会获得自己的生日常量，并将自己的生日对象赋值给它。由于我们不打算更改任何生日常量——我们只会读取它们的属性——所以我们不需要将它们设置为变量。

现在，您已经有了单元格和生日，是时候填写细节了。每个单元格需要两个标签来显示生日人的姓名和出生日期。您将单元格设置为副标题样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，所以现在您不需要自己创建任何标签了。

这些标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。代码中的 ➌ 将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格隔开。 在 ➍ 处，您使用 dateFormatter 的 string(from:)方法将出生日期显示在 detailTextLabel 中。

当您的单元格完全配置好后，tableView(_:cellForRowAt:) 在 ➎ 返回该单元格，以便它可以在表格视图的该 indexPath 处显示。

### 综合应用（PUTTING IT ALL TOGETHER）

现在，您可以使用添加生日视图控制器将生日实例添加到应用程序中，并且您有一个表格视图来列出每个生日，显示在生日表格视图控制器中。但是，当您尝试运行应用并添加一个生日时，它并没有显示。为了让您添加的每个生日都出现在表格视图中，您需要让添加生日视图控制器与生日表格视图控制器进行通信。您可以通过使用*委托（delegation）*来实现这一点。

#### 委托（DELEGATION）

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设您有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 呈现在自己之上。A 知道 B，因为它创建并呈现了 B，因此 A 可以将信息传递给 B。但 B 并不知道 A——它只是突然出现的，不知道自己是从哪里来的或是如何到达的。那么，B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项工作或任务交给别人。*委托人*就像一个老板，告诉被委托的员工该做什么。当被委托的员工完成任务后，有时他们会将信息报告给委托的老板。

在 Swift 中，委托的实现方式非常相似，只不过我们不再用老板和员工的关系，而是用委托和被委托对象的关系。由于类 B 是被类 A 告知该做什么的，所以它是被委托对象。我们给类 B 一个特殊的属性，称为 delegate，用来告诉它它的委托对象是谁，这样它就知道应该与谁进行沟通。委托对象可以是任何一个拥有在*协议*中定义的一组方法的类。协议就像是两个类之间的约定，告诉它们委托可以要求被委托对象做什么。协议中有一系列方法和属性名称，委托对象可以使用这些方法与被委托对象进行交互。

类 A 创建类 B，使其成为类 B 的委托，并给类 B 一个在协议中定义的任务。一旦类 B 完成任务，它会向类 A 报告。让我们看看这个在应用中的具体实现。

生日列表视图控制器是视图控制器 A，而“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由“添加生日”视图控制器用于回传信息。

看看图 11-6。当用户点击“添加”按钮 ➊ 时，生日列表视图控制器会创建“添加生日”视图控制器 ➋ 并将自身设置为“添加生日”视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：通过委托，新的生日从“添加生日”视图控制器传递到生日列表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为有一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击“保存”按钮 ➌ 时，“添加生日”视图控制器调用此方法 ➍ 并将新生日传递给它的委托，即生日列表视图控制器。生日列表视图控制器接收到这个生日后，将其添加到自己的生日数组中，然后重新加载表格视图 ➎ ，这样新生日就会出现在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义其中的 addBirthdayViewController(_:didAddBirthday:)方法，这样当有生日被添加到应用中时，“添加生日”视图控制器就可以调用这个方法。生日列表视图控制器将实现这个协议方法，这样每当通过“添加生日”视图控制器添加生日时，“添加生日”视图控制器只需要对其委托说：“嘿！有人刚刚添加了这个生日。”然后生日列表视图控制器会收到这个信息并回应：“哦！我会把它添加到我的列表中，并刷新显示，让新生日出现在列表里。”

现在，让我们用代码来实现这个功能！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处定义协议，通过输入关键字 protocol，后跟协议名称 AddBirthdayViewControllerDelegate。这个名字很长，但 Swift 程序员通常会以调用类的名称命名他们的协议，并在末尾加上 Delegate 这个词。这样，你就可以通过查看协议的名称来知道哪个类正在使用这个协议。既然你现在是 Swift 程序员了，你应该遵循相同的命名惯例。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传回给代理类 ➋。注意，你在这个函数中包括了 AddBirthdayViewController 作为参数。同样，Swift 程序员在实现协议方法时通常会这样做，所以你也应该坚持这样做。知道是谁发送了消息并让代理类能够访问该对象及其类是非常有用的。

当 Add Birthday 视图控制器调用此方法时，它将把自己作为 addBirthdayViewController 参数传递。你很快就会看到这是如何实现的。另一个需要注意的是外部参数名称 didAddBirthday。许多代理协议方法都包含 *did* 和 *will*，因为它们用来描述调用类刚刚做过的或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表视图控制器采用这个协议并使用协议的方法。

##### 使 Birthdays 表视图控制器符合协议

要采用该协议，Birthdays 表视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为此，你需要在 UITableViewController 超类之后的类定义中添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加上一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色错误就会出现。因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心，我们很快就会修复这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，这个超类名称必须写在任何协议之前。但尽管一个类只能有一个超类，它可以采纳任意多个协议——这些协议将会在超类后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:) 方法添加到 Birthdays TableViewController 中。一个合适的添加位置是在类的末尾，紧跟在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它预期你会添加这个方法。请注意，不像子类化的方法，在 addBirthdayViewController(_:didAddBirthday:) 前你不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将由添加生日视图控制器传入的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现这一点 ➋。接下来，你需要刷新表格视图，以便它显示这个新的生日，这可以通过调用 tableView 属性的 reloadData() 方法来完成 ➌。当调用 reloadData() 时，表格视图的数据源方法将再次被调用，新增的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。虽然这不是必须的，但为了保持良好的编码风格，标记类的不同部分是一个好习惯，它有助于保持代码整洁和易读。注释的第一部分，MARK: - ，是一个特殊的关键字，Xcode 用于代码注释，并将 AddBirthdayViewControllerDelegate 部分添加到一个下拉式目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你查找方法并让你跳转到代码的不同位置。要使用此菜单，请点击编辑面板顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为添加生日视图控制器指定代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议来告诉 Birthdays 表格视图控制器它已经添加了一个生日。为此，添加生日视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个可选的代理属性（类型为 AddBirthdayViewControllerDelegate）来安排这件事，具体做法是在 outlets 下方插入以下代码：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在添加生日视图控制器创建之前，你无法设置它。稍后你会学到如何设置代理。

现在，添加生日视图控制器拥有了代理，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将一个生日传递给代理。将 saveTapped(_:)更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)将其传递给代理。

太棒了！你已经完成了对添加生日视图控制器的更改。现在它拥有一个代理，能够监听生日已保存的调用。运行应用程序查看会发生什么。

嗯……似乎没有太大变化。当你添加生日时，仍然看不到它出现在 Birthdays 表视图控制器中。这是怎么回事？

#### 通过设置代理连接这两个控制器

还有最后一件事需要做。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用于保存与其通信的代理，当生日被保存时。然而，我们从未专门设置代理属性为 Birthdays 表视图控制器。所以现在是时候在这两个视图控制器之间建立通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除围绕它的/*和*/注释，将该方法取消注释。

这个方法会在 Birthdays 表视图控制器放弃其屏幕并通过故事板 segue 切换到另一个视图控制器时自动调用。我们将利用这个方法将 Birthdays 表视图控制器传递给添加生日视图控制器，并将其设置为添加生日视图控制器的代理。在 prepare(for:sender:)方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的代理为 Birthdays 表视图控制器只需要三行代码。首先，你需要能够通过 segue 参数访问到 AddBirthdayViewController 对象。Xcode 在注释中暗示了如何做到这一点。一个 UIStoryboardSegue 有一个名为 destination 的属性，用于指向正在此方法中准备的 segue 的目标，但本应用的目标并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到了一个导航控制器中，这样你就可以拥有一个带有“取消”和“保存”按钮的导航栏。因此，你不会期待在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊处的代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是一个特定类型的视图控制器，我们需要使用 as 进行类型转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是导航控制器的 topViewController ➋。topViewController 只是当前显示在导航控制器中的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，表示这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 后，可以将代理设置为 self，即当前的生日表视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表视图控制器中看到什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序再重新运行，之前的生日记录会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在这一章中，你学会了如何制作一个表视图控制器来显示生日列表。你还学会了如何在“添加生日”视图控制器中添加生日，并使用代理将生日添加到生日表视图控制器中的生日数组中，以便它能够显示。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用程序再重新运行，它们仍然会显示。为了保存生日，我们将使用 Core Data，这是我们在项目开始时设置的。

*图 11-2：* 生日表视图控制器 *已清理！*

接下来，你需要将生日表视图控制器设置为 BirthdaysTableViewController 类。为此，进入 *Main.storyboard* 并选择 **生日** 场景。然后，在右侧窗格中使用身份检查器，将类从 UITableViewController 更改为 BirthdaysTableViewController，如图 11-3 所示。

![](img/Image00236.jpg)

*图 11-3：将* 生日表视图控制器 *设置为生日场景的类*

现在你已经在故事板中设置好了生日表视图控制器，下一步是创建表格中的单元格来显示每个生日。

#### 向表视图添加单元格

每个生日将显示在生日表视图控制器的 UITableViewCell 中。表格有按行和列组织的信息框，这些框被称为*单元格*。类似地，表视图也有单元格，这些单元格都是 UITableViewCell 类的实例或其子类。我们将在表视图中为每个生日创建一个单独的单元格。

我们将首先在故事板中创建这些单元格，然后稍后将它们填充为我们的生日对象。在左侧大纲菜单中，点击“生日”旁边的三角形，然后点击“表视图”旁边的三角形以展开这些部分。然后选择**表视图单元格** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建副标题样式的表格视图单元格并设置其标识符*

接下来，打开属性检查器。在 **样式** 下拉菜单中，将单元格样式设置为 **副标题** ➋，这样单元格现在就会有一个标题标签和一个副标题标签。你将把每个人的名字显示在标题中，将生日显示在副标题中。

最后，在标识符字段 ➌ 中输入 birthdayCellIdentifier。你稍后将使用这个标识符来填充单元格内容。

就是这样！你已经完成了故事板中的工作。

你可能会想，为什么在故事板中的表格视图中只有一个单元格，而我们将要显示多个生日。如果你再看一眼图 11-4，你会注意到该单元格被标记为 *原型单元格*。这意味着你刚刚自定义的单元格是你想要在表格视图中显示的所有单元格的 *模板*。你给单元格设置的标识符就是你的代码告诉表格视图如何为你生成每个单元格以放置生日的方式。你很快就会看到这个是如何工作的。

**日期操作**

Swift 有一个特殊的数据类型叫做 Date，用于存储日期值。一个 Date 对象实际上包含了日期和时间。打开你的 Playground 并输入以下代码：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量 today。当你打印 today 时，它的格式是 "2017-11-21 10:45:31 +0000\n"。如果你希望它显示为 Tuesday, November 21, 2017 呢？或者仅仅是 11/21/17 呢？为了以特定的方式显示日期，你需要使用 *日期格式化器*，它是一个 DateFormatter 对象，你可以创建并给它一个日期格式样式。DateFormatter 是一个帮助对象，用于从任何日期创建显示字符串，*日期格式样式* 是 DateFormatter 的一个属性，告诉格式化器使用哪种样式。你可以手动创建自己的日期格式样式，但 Swift 中也有内置的样式，随时可以使用。将以下代码添加到你的 Playground：

![](img/Image00240.jpg)

在 ➊，你创建了一个格式化器。然后在 ➋，你将格式化器的样式设置为 Style.full，这将显示星期几以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:) 方法 ➌ 从日期创建一个字符串。你可以看到，现在你已经将日期转化为格式良好的字符串 "Tuesday, November 21, 2017"。表 11-1 显示了 Swift 中可用的五种 DateFormatter.Style 选项所创建的不同字符串。

**表 11-1:** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "Nov 21, 2017" |
| long | "November 21, 2017" |
| full | "Tuesday, November 21, 2017" |

你还可以使用 DateFormatter 的 dateFormat 属性指定自定义的日期显示方式。也许你只想显示月份和日期，或者你希望以简短样式显示四位数的年份。实现这两种方式都非常简单，你甚至不需要创建新的 DateFormatter ——只需更改 formatter 的 dateFormat，然后要求它返回一个新的字符串。将以下代码添加到你的 playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定只显示月份和日期，格式为 MM/dd——即两位数的月份后跟两位数的日期。如果你希望显示三字母的月份，可以使用 MMM。如果要显示月份的全名，请使用 MMMM。在 ➋ 处，我们将日期格式更改为使用四位数的年份。两位数的年份则使用 yy。以下是几种使用 dateFormat 显示自定义日期字符串的方式。

![](img/Image00242.jpg)

如果你想包含分隔符，可以将它们添加到 dateFormat 字符串中。例如，如果你希望使用句点作为分隔符，可以创建一个像 "MM.dd.yy" 这样的 dateFormat ➊。若要显示缩写的星期几，使用 EEE ➋。要显示完整的星期几，使用 EEEE ➌。这些只是几个例子。通过组合 M、d、y 和 E，你可以有无数种方式来显示日期！

#### 设置 Birthdays 表格视图控制器

Birthdays 表格视图控制器将显示应用中存储的所有生日的列表。你记得用什么存储项的列表吗？没错——是数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有的生日。为此，在类的顶部，紧接着 viewDidLoad() 方法上方，插入以下代码来添加一个名为 birthdays 的数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量，而不是常量，因为每次用户通过添加生日视图控制器添加一个生日时，你都希望将一个保存的 Birthday 添加到此数组中。你将在 “使 Birthdays 表格视图控制器遵循协议” 中看到如何做到这一点，见 第 168 页。

**注意**

*请记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性来将出生日期显示为格式化的字符串。请在 birthdays 数组下方添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个使用 let 创建的常量。即使你会更改 dateFormatter 的属性，如 dateStyle 和 timeStyle，你也永远不会改变 dateFormatter 本身。

您还需要设置 dateFormatter，以便它可以将出生日期显示为完全格式化的字符串，例如“Tuesday, December 17, 2008”。正如您在第十章中看到的，做这件事的好地方是 viewDidLoad()方法，当 Birthdays 表格视图控制器加载其视图时会调用该方法。这是进行任何必要设置的完美时机。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在➊处，您设置了 dateFormatter 的 dateStyle，以便它可以为每个生日显示格式化的日期字符串。您是否注意到我们直接写了.full，而不是 DateFormatter.Style.full？Swift 知道 dateStyle 的类型是什么，所以它允许我们使用这个小技巧。 在➋处，您将 dateFormatter 的 timeStyle 设置为.none，这样就不会显示时间。

#### 在表格视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于显示单列中的项目列表。该表格视图有一个或多个部分，包含若干行，每一行都有一个单元格。表格视图中的一个部分是若干行的分组，可以带有或不带有标题显示。一个展示具有多个部分的表格视图的应用程序示例是设置应用，如图 11-5 所示。它显示了一个已经被拆分成不同部分的行列表。

表格视图的每个部分和每一行都有一个索引号。这些数字从 0 开始，然后在您向下浏览表格视图时递增 1。例如，设置应用中的隐私行位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为*表格视图数据源*的部分，其中包含三个方法。表格视图控制器使用这些方法来确定将显示在其表格视图中的内容。

numberOfSections(in:) 告诉表格视图它应该有多少个部分。

tableView(_:numberOfRowsInSection:) 告诉表格视图每个部分将显示多少行。

tableView(_:cellForRowAt:) 设置了将要显示在表格视图每一行中的每个单元格。

![](img/Image00243.jpg)

*图 11-5：设置应用使用各个部分将不同设备设置的行分组。*

表格视图的数据源方法在每次重新加载表格视图时由表格视图控制器调用。当你创建一个 `UITableViewController` 的子类时，Xcode 会自动给你这些方法模板。你需要实现所有三个方法，才能让应用正常工作，即使你在代码中不会直接调用它们。`UITableViewController` 类实现了 `UITableViewDataSource` 协议，该协议带有这些数据源方法，用来确定在表格视图中显示什么内容。我们将在 “委托” 第 166 页讨论协议。目前，你只需要知道，`UITableViewController` 使用这些方法来显示其内容，并且它会自动调用这些方法，你不需要手动调用它们。

我们从 `numberOfSections(in:)` 方法开始。`Birthdays` 表格视图控制器是一个只显示 `Birthday` 实例的列表，因此不需要多个 section。为了设置表格视图的 section 数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 `tableView` 的 `UITableView` 参数，它是使用这个类作为数据源的表格视图。我们不需要担心建立这个连接，因为 `UITableViewController` 自带一个内置的表格视图，自动连接到这些方法。每个生日将显示在自己的行中。所以在 `tableView(_:numberOfRowsInSection:)` 中，为了让表格视图有正确的行数来显示所有的生日，你需要返回 `birthdays` 数组中 `Birthday` 实例的数量。你还记得数组的 `count` 属性吗？它是一个整数，表示数组中有多少个元素，非常适合这个情况！将这个方法改成以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 `tableView` 参数外，`tableView(_:numberOfRowsInSection:)` 还需要一个名为 `section` 的 Int 参数。当表格视图加载时，这个方法会为表格视图的每个 section 被调用。在我们的例子中，只有一个 section，所以我们不需要关心正在显示的是哪个 section。我们知道它是 section 0，我们希望它的行数等于生日的数量，所以我们写 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)`，这样表格视图才能知道在每个单元格中放入什么内容。由于这个方法被注释掉了，你需要通过删除 `/*` 和 `*/` 注释符号来取消注释它。（小心不要不小心取消注释它后面的其他方法！）完成后，将它改成以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你并不会直接调用方法`tableView(_:cellForRowAt:)`。它是在表格视图加载到屏幕时被调用的。它会为屏幕上的每个单元格调用，并接受两个参数，tableView 和 indexPath。你已经知道 tableView 参数是用来做什么的。IndexPath 是一个 Swift 结构体，用于表示表格视图中一行的位置。一个 IndexPath 实例有一个 section 属性和一个 row 属性。由于这个方法会被多次调用（每次为表格中的一行），我们需要 indexPath 来知道当前正在配置的是哪一部分和哪一行。indexPath.section 属性提供部分号，而 indexPath.row 提供表格视图单元格的行号。`tableView(_:cellForRowAt:)`方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定 birthday 数组中哪一个生日将在单元格中显示

• 创建两个标签来显示单元格中生日人的姓名和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。➊处的代码通过`dequeueReusableCell(withIdentifier:for:)`方法实现这一点。然而，在你开始使用此方法之前，你需要告诉它从 storyboard 中使用哪个单元格。之前，当你在 storyboard 中时，你给单元格指定了标识符`birthdayCellIdentifier`（见图 11-4）。这个标识符将你的代码与单元格关联起来，告诉方法它正在使用正确的单元格。调用此方法时使用的字符串必须与在 storyboard 中设置的字符串完全相同，否则你会遇到错误，应用程序在运行时会崩溃。

在方法`dequeueReusableCell(withIdentifier:for:)`中，你是否注意到*可重用单元格*这几个字？表格视图中的单元格是创建一次后可以重复使用的。这有助于提高运行速度，因为创建单元格是最耗时的。如果你的应用中有 200 个生日，但一次只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多的生日时，滚出屏幕顶部的单元格将被重用。它们会被填充新信息并重新出现在屏幕底部。UITableView 会自动执行这些工作。当表格视图加载时，`tableView(_:cellForRowAt:)`会为每一行调用一次。当用户滚动查看更多单元格时，每次即将出现在屏幕上的行也会调用一次该方法。

接下来，我们需要找出在单元格中显示哪个生日。我们想要在每一行中显示一个来自 `birthdays` 数组的生日。第一个生日，位于 `birthdays[0]`，应该显示在第 0 行。第二个生日，位于 `birthdays[1]`，应该显示在第 1 行，依此类推，这意味着 `indexPath` 的 `row` 与我们要访问的 `birthdays` 数组中的位置相同。代码 ➋ 使用 `indexPath.row` 从 `birthdays` 数组中访问正确的 Birthday 对象。一旦我们拿到正确的 Birthday 对象，我们就将其赋值给一个名为 `birthday` 的常量，以便我们设置该单元格中的标签。

请注意，我们使用 `let` 将生日赋值给常量，而不是变量。我们可以使用 `let`，因为每次调用 `tableView(_:cellForRowAt:)` 时，都会创建一个新的生日常量。每个单元格会获得自己的生日常量，并赋值为对应的 Birthday 对象。由于我们不打算更改任何生日常量——我们只是读取它们的属性——所以我们不需要将它们设为变量。

现在你已经有了单元格和生日，是时候填写详细信息了。你需要为每个单元格设置两个标签来显示生日者的姓名和生日日期。你将单元格设置为副标题样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，因此现在你不需要自己创建任何标签。

这些标签作为 `UITableViewCell` 的属性存在，分别叫做 `textLabel` 和 `detailTextLabel`。代码 ➌ 设置 `textLabel` 的文本为由生日者的 `firstName` 和 `lastName` 组成的字符串，中间用空格分隔。在 ➍，你使用 `dateFormatter` 的 `string(from:)` 方法在 `detailTextLabel` 中显示生日日期。

当你的单元格完全配置好后，`tableView(_:cellForRowAt:)` 会返回单元格，位置为 ➎，以便它能显示在表视图的该 `indexPath` 位置。

### 整合所有内容

现在，你可以通过添加生日视图控制器将 Birthday 实例添加到应用中，并且你有一个表视图来列出每个 Birthday，显示在 Birthdays 表视图控制器中。但是当你尝试运行应用并添加一个 Birthday 时，它并没有显示出来。为了让你添加的每个 Birthday 在表视图中出现，你需要让 Add Birthday 视图控制器与 Birthdays 表视图控制器进行通信。你可以通过使用 *委托* 来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 显示在 A 上方。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 并不知道 A——它只是突然出现，并不知道它是从哪里来的或如何到达这里的。那么 B 怎么与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项工作或任务交给别人。*委托*就像一个老板，告诉一个委托员工该做什么。当委托员工完成任务时，有时他们会向委托的老板报告信息。

Swift 中的委托模式很相似，但与其有一个老板和员工，我们有一个委托和一个委托对象。由于 B 类是被 A 类指示该做什么的，所以它是委托对象。我们给 B 类一个特别的属性，称为 delegate，来告诉它谁是它的委托——这样它就知道该与谁进行沟通。委托可以是任何一个具有在*协议*中定义的一组方法的类。协议就像是两个类之间的约定，告诉它们委托可以要求委托对象做些什么。它包含了一组委托可以与委托对象一起使用的方法和属性名称。

A 类创建 B 类，将自己设为 B 类的委托，并给 B 类一个协议中的任务。一旦 B 类完成任务，它会向 A 类报告。让我们看看在我们的应用中是如何实现的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，添加生日视图控制器将使用该方法来报告结果。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从“添加生日”视图控制器传递到“生日”表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为具有一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，添加生日视图控制器会调用此方法 ➍ 并将新生日传递给其委托，即生日表视图控制器。生日表视图控制器接收该生日，加入到它的生日数组中，然后重新加载它的表视图 ➎，这样新生日就会显示在表中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并实现 addBirthdayViewController(_:didAddBirthday:)方法，这样每当在应用中添加一个生日时，添加生日视图控制器就可以调用该方法。生日表视图控制器将实现该协议方法，这样每当通过添加生日视图控制器添加一个生日时，添加生日视图控制器只需对其委托说：“嘿！刚刚有人添加了这个生日”，而生日表视图控制器会收到消息并回应：“哦！我会把它加到我的列表里并刷新显示，以便新生日能够显示出来。”

现在让我们在代码中实现这个功能！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，*在* `AddBirthdayViewController` 类的上方，添加以下代码来定义 `AddBirthdayViewControllerDelegate` 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过在 ➊ 处输入关键字 `protocol`，然后跟上协议名称 `AddBirthdayViewControllerDelegate` 来定义协议。这个名称很长，但 Swift 程序员通常会按照调用类的名称命名协议，并在结尾加上 `Delegate` 一词。这样你就能通过查看协议的名称来判断哪个类正在使用这个协议。既然你现在是 Swift 程序员，应该遵循相同的命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)` 是唯一的函数，它用于将 `Birthday` 对象传递回代理类 ➋ 。注意，在这个函数中你包括了 `AddBirthdayViewController` 作为参数。再次强调，Swift 程序员在实现协议方法时通常会根据约定这样做，所以你也应该坚持这样做。知道谁发送了消息，并且让代理能够访问该对象及其类是非常有用的。

当 `AddBirthday` 视图控制器调用这个方法时，它会将自身作为 `addBirthdayViewController` 参数传递。你很快就会看到这是如何完成的。另一个需要注意的是外部参数名称 `didAddBirthday`。许多代理协议方法都包含 *did* 和 *will* 这两个词，因为它们用于描述调用类已经做过或将要做的事情。

现在你已经定义了协议，接下来需要告诉 `BirthdaysTableViewController` 采纳这个协议并使用协议的方法。

##### 使 Birthdays Table View Controller 遵循协议

要采纳这个协议，`BirthdaysTableViewController` 需要使自己成为 `AddBirthdayViewControllerDelegate`。为了做到这一点，你需要将 `AddBirthdayViewControllerDelegate` 添加到类定义中，紧跟在 `UITableViewController` 超类后面。在类的顶部，在 `UITableViewController` 后面添加一个逗号，然后输入 `AddBirthdayViewControllerDelegate`：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，就会出现一个红色的错误提示。这是因为 `BirthdaysTableViewController` 表示它是一个 `AddBirthdayViewControllerDelegate`，但它还没有实现这个协议！为了做到这一点，它需要实现 `AddBirthdayViewControllerDelegate` 协议的定义。别担心——我们很快会解决这个问题。

这里需要注意的是，`BirthdaysTableViewController` 是 `UITableViewController` 超类的子类。一个类只能有一个超类，而且超类的名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采纳任意多个协议——这些协议会在超类后面列出，并用逗号分隔。

现在，为了遵守 `AddBirthdayViewControllerDelegate` 协议并修复错误，我们需要将 `addBirthdayViewController(_:didAddBirthday:)` 方法添加到 `Birthdays TableViewController` 中。一个合适的位置是将它添加到类的末尾，在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类采用了 `AddBirthdayViewController Delegate` 协议，并且它预期你会添加这个方法。请注意，与子类方法不同，你不需要在 `addBirthdayViewController(_:didAddBirthday:)` 前加上 `override` 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 `Add Birthday` 视图控制器传入的 `Birthday` 添加到 `birthdays` 数组中。你可以使用数组的 `append(_:)` 方法来做到这一点 ➋ 。接下来，你需要刷新表视图，以便它显示这个新添加的生日，通过调用 `tableView` 属性的 `reloadData()` 方法 ➌ 。当调用 `reloadData()` 时，表视图的数据源方法会再次被调用，新添加的生日会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必须的，但标记类的不同部分是一个良好的编码风格，它有助于保持代码简洁和易读。注释的第一部分，`MARK: -`，是 Xcode 识别的一个特殊关键字，它会将 `AddBirthdayViewControllerDelegate` 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你找到方法，并让你跳转到代码中的不同位置。要使用这个菜单，请点击编辑器面板顶部的 `Birthdays TableViewController`，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类内有一个内置的目录，可以快速跳转到某个部分。*

##### 给 Add Birthday 视图控制器设置代理

`BirthdaysTableViewController` 已经采用了 `AddBirthdayViewControllerDelegate` 协议。现在，应该让 `Add Birthday` 视图控制器使用 `AddBirthdayViewControllerDelegate` 协议，在它添加了一个生日时通知 `Birthdays` 表视图控制器。为此，`Add Birthday` 视图控制器首先需要定义一个代理。我们通过在 `AddBirthdayViewController` 类的 outlets 下方插入以下代码来安排这一点，添加一个可选的代理属性，类型为 `AddBirthdayViewControllerDelegate`：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在 `Add Birthday` 视图控制器创建之前，你不能设置它。你将很快学到在哪里设置代理。

现在，添加生日视图控制器有了委托，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将生日传递给委托。将 saveTapped(_:) 方法改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:) 方法将其返回给委托。

太好了！你已经完成了对添加生日视图控制器的修改。现在它有了一个委托，能够监听到生日已被保存的通知。运行应用程序，看看会发生什么。

嗯。。。没什么变化。当你添加一个生日时，你仍然看不到它出现在生日表视图控制器中。怎么回事？

#### 通过设置委托连接两个控制器

还有一件最后的事情需要做。生日表视图控制器是 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存着它在保存生日时会与之通信的委托。但是我们从未明确设置该委托属性为生日表视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除它两侧的 /* 和 */ 注释符号来取消注释该方法。

每当生日表视图控制器放弃屏幕并且应用通过 storyboard segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将生日表视图控制器传递给添加生日视图控制器，并将其设置为添加生日视图控制器的委托。在 prepare(for:sender:) 方法中写下以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的委托为生日表视图控制器需要三行代码。首先，你需要能够从 segue 参数中获取到 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你可以如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，它代表正在该方法中准备的 segue 另一端的目标，但这个应用的目标并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到一个导航控制器中，这样你就可以在导航栏中有取消和保存按钮。所以你不指望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊ 处的代码获取了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是特定类型的视图控制器，我们需要通过 as 进行类型转换，将其转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是导航控制器的 topViewController ➋。topViewController 就是当前在导航控制器中显示的视图控制器，但它的属性类型是 UIViewController，因此需要强制类型转换为 AddBirthdayViewController，表示该控制器是 UIViewController 的一个特定子类。最后，当你得到一个 AddBirthdayViewController 时，你可以将代理设置为 self，即当前的“生日”表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在“生日”表格视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用程序然后再次运行它，之前添加的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到的内容

在这一章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，然后如何使用代理将生日添加到“生日”表格视图控制器中的生日数组中，以便能够显示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，以便即使退出应用程序并再次运行，生日仍然会显示出来。为了保存生日，你将使用我们在项目一开始设置的 Core Data。

接下来，你需要将“生日”表格视图控制器设置为 BirthdaysTableViewController 类。为此，前往*Main.storyboard*并选择**生日**场景。使用右侧面板中的身份检查器，将类从 UITableViewController 更改为 BirthdaysTableViewController，如图 11-3 所示。

![](img/Image00236.jpg)

*图 11-3：设置* BirthdaysTableViewController *为“生日”场景的类*

现在你已经在故事板中设置好了“生日”表格视图控制器，下一步是创建表格中的单元格来显示每个生日。

#### 向表格视图添加单元格

每个生日将显示在“生日”表格视图控制器中的一个 UITableViewCell 中。表格由按行和列组织的信息框组成，这些框被称为*单元格*。同样，表格视图也有单元格，这些单元格都是 UITableViewCell 类或其子类的实例。我们将在表格视图中为每个生日创建一个单独的单元格。

我们将从在故事板中创建这些单元格开始，然后稍后将它们填充到我们的生日对象中。在左侧大纲菜单中，点击“生日”旁的三角形，再点击“表格视图”旁的三角形以展开这些部分。然后选择**表格视图单元格** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建一个副标题样式的表格视图单元格并设置其标识符*

接下来，打开 Attributes Inspector。通过在 **Style** 下拉菜单中选择，设置单元格样式为 **Subtitle** ➋ ，这样单元格现在就有了标题标签和副标题标签。你将在标题中显示每个人的姓名，在副标题中显示生日。

最后，在 Identifier 字段中输入 birthdayCellIdentifier ➌ 。你将在稍后使用这个标识符来填充单元格内容。

就这样！你已经完成了故事板中的工作。

你可能会想，为什么我们在故事板中的表格视图里只有一个单元格，而列表中会显示多个生日？如果你再次查看 图 11-4，你会注意到单元格标记为 *Prototype Cells* 。这意味着你刚刚自定义的单元格是你希望在表格视图中显示的所有单元格的 *模板* 。你给单元格指定的标识符就是你的代码告诉表格视图如何生成每个单元格来放置生日的方式。你很快就能看到这是如何工作的。

**处理日期**

Swift 有一个特殊的数据类型叫做 Date，用于存储日期值。一个 Date 对象实际上包含了日期和时间。打开你的 playground 并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量 today 。当你打印 today 时，它的格式是 "2017-11-21 10:45:31 +0000\n" 。如果你希望它显示为 Tuesday, November 21, 2017 呢？或者只是 11/21/17 呢？为了以特定的方式显示日期，你需要使用 *日期格式化器* ，它是一个 DateFormatter 对象，你可以创建它并为其设置日期格式样式。DateFormatter 是一个辅助对象，用于从任何日期创建显示字符串，而 *日期格式样式* 是 DateFormatter 的一个属性，告诉格式化器应使用哪种样式。你可以手动创建自己的日期格式样式，但 Swift 中也有一些内置样式，随时可以使用。请将以下内容添加到你的 playground 中：

![](img/Image00240.jpg)

在 ➊ 处你创建了一个格式化器。然后在 ➋ 处，你将格式化器的样式设置为 Style.full，这样会打印出星期几的名称以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:) 方法 ➌ 从日期中创建一个字符串。你可以看到，现在你已经将日期转换成了格式良好的字符串 "Tuesday, November 21, 2017" 。表 11-1 显示了通过五种 DateFormatter.Style 选项创建的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "2017 年 11 月 21 日" |
| long | "November 21, 2017" |
| full | "Tuesday, November 21, 2017" |

你还可以通过 DateFormatter 的 dateFormat 属性来指定自定义的日期显示方式。也许你只想显示月和日，或者你想以短格式显示四位数的年份。无论哪种方式，都非常简单，而且你甚至不需要创建一个新的 DateFormatter ——你只需要修改 formatter 上的 dateFormat 属性，然后请求它生成一个新的字符串。在你的 playground 中添加以下代码来以特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定了只显示月份和日期，采用 MM/dd 格式——也就是两位数的月份后跟两位数的日期。如果你想将月份显示为三个字母，可以使用 MMM 。要显示完整的月份名称，使用 MMMM 。在 ➋ 处，我们将日期格式更改为使用四位数的年份。两位数的年份使用 yy 。以下是几种其他使用 dateFormat 来显示自定义日期字符串的方法。

![](img/Image00242.jpg)

如果你想要包含分隔符，可以将它们添加到你的 dateFormat 字符串中。例如，如果你想要用句点作为分隔符，你可以创建一个类似 "MM.dd.yy" 的 dateFormat ➊ 。要显示缩写的星期几，使用 EEE ➋ 。要显示完整的星期几，使用 EEEE ➌ 。这些只是其中几个例子。通过组合 M 、d 、y 和 E，你可以有无尽的方式来显示日期！

#### 设置 Birthdays 表视图控制器

Birthdays 表视图控制器将显示应用中存储的所有生日列表。你还记得用什么来存储一系列项吗？没错—是数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有的生日。为此，给 BirthdaysTableViewController 添加一个名为 birthdays 的属性，它是一个 Birthday 对象的数组。在类的顶部，紧挨着 viewDidLoad() 方法上方，插入这一行代码来添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行代码创建了一个空的 Birthday 实例数组。它需要是一个变量而不是常量，因为每次用户通过添加生日视图控制器添加一个新的生日时，你都需要将其保存到这个数组中。你将在 “让 Birthdays 表视图控制器符合协议” 的 第 168 页 中看到如何操作。

**注意**

*请记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性来将出生日期格式化为字符串并显示。将一个 dateFormatter 属性添加到 birthdays 数组下方：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，通过 let 创建。尽管你会修改 dateFormatter 的属性，比如 dateStyle 和 timeStyle，但你永远不会改变 dateFormatter 本身。

你还需要设置 `dateFormatter`，使其能够将出生日期显示为格式化后的字符串，例如“2008 年 12 月 17 日，星期二”。正如你在第十章中看到的，设置的最佳位置是 `viewDidLoad()` 方法，它会在“生日”表视图控制器加载视图时调用。这是进行任何必要设置的理想位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 `dateFormatter` 的 `dateStyle`，使其能够显示每个生日的格式化日期字符串。你注意到我们直接写了 `.full` 而不是 `DateFormatter.Style.full` 吗？Swift 知道 `dateStyle` 的期望类型，因此它允许我们使用这个简便写法。在 ➋ 处，你将 `dateFormatter` 的 `timeStyle` 设置为 `.none`，以确保时间不会被显示。

#### 在表视图中显示生日

`BirthdaysTableViewController` 类具有一个表视图，用于显示一列项的列表。表视图有一个或多个包含行的部分，每一行都包含一个单元格。表视图中的部分是行的分组，可以选择性地显示或不显示标题。一个展示多个部分的表视图应用程序示例是“设置”应用程序，如图 11-5 所示。它显示了一系列已分组为不同部分的行。

表视图的每个部分和行都有一个索引号，这些数字从 0 开始，然后随着向下滚动表视图而增加 1。例如，在“设置”应用程序中，“隐私”行位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 `BirthdaysTableViewController` 类的中间，有一个名为 *表视图数据源* 的部分，其中包含三个方法。表视图控制器使用这些方法来确定将在表视图中显示什么内容。

numberOfSections(in:) 告诉表视图应该有多少个部分。

tableView(_:numberOfRowsInSection:) 告诉表视图在每个部分中将显示多少行。

tableView(_:cellForRowAt:) 设置将在表视图的每一行中显示的每个单元格。

![](img/Image00243.jpg)

*图 11-5：设置应用程序使用部分来分组不同设备设置的行。*

表格视图的数据源方法在每次表格视图重新加载时都会被表格视图控制器调用。当你创建一个 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。为了让应用正常工作，你需要实现所有三个方法，即使你在代码中不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用来确定表格视图中将要显示的内容。我们将在 “代理模式” 一节（第 166 页）讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，所以你不需要手动调用它们。

我们先从方法 numberOfSections(in:) 开始。Birthdays 表格视图控制器是一个仅显示 Birthday 实例的列表，所以它不需要多个部分。为了设置表格视图的部分数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 tableView 的 UITableView 作为参数，它是使用此类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内建的表格视图，并且已经自动与这些方法连接。每个生日将会显示在它自己的行中。因此，在 tableView(_:numberOfRowsInSection:) 中，为了正确显示所有生日的行数，你需要返回 birthdays 数组中 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少项，正好适合这种情况！将这个方法修改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，tableView(_:numberOfRowsInSection:) 还接受一个名为 section 的 Int 参数。当表格视图加载时，这个方法会被为每个部分调用。在我们的例子中，只有一个部分，所以我们不需要检查表格视图显示的是哪个部分。我们知道它是第零部分，并且我们希望它有与生日数量相同的行数，因此我们写 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:) 方法，这样表格视图就知道在每个单元格中放入什么内容。由于这个方法已经被注释掉，你需要通过删除包围它的 /* 和 */ 来取消注释。（小心不要不小心取消注释其后的其他方法！）完成后，将其修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用 `tableView(_:cellForRowAt:)` 方法。它会在表格视图加载到屏幕时被调用。每个屏幕上的单元格都会调用这个方法，并传递两个参数：`tableView` 和 `indexPath`。你已经知道 `tableView` 参数的作用。`IndexPath` 是一个 Swift 结构体，用来表示表格视图中某一行的位置。`IndexPath` 实例有两个属性：`section` 和 `row`。由于这个方法会被多次调用（每个表格行一次），我们需要通过 `indexPath` 来知道我们当前配置的是哪个节（section）和行（row）。`indexPath.section` 属性表示节号，`indexPath.row` 属性表示表格视图单元格的行号。`tableView(_:cellForRowAt:)` 中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 `UITableViewCell`

• 确定哪个生日在 `birthdays` 数组中会显示在单元格内

• 创建两个标签以显示生日人的姓名和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 `UITableViewCell`。➊ 处的代码使用了方法 `dequeueReusableCell(withIdentifier:for:)`。不过，在你开始使用这个方法之前，你需要告诉它从故事板中选择哪个单元格。之前在故事板中，你为你的单元格指定了标识符 `birthdayCellIdentifier`（见 图 11-4）。这个标识符将你的代码和单元格关联起来，并告诉方法你正在使用正确的单元格。当你调用这个方法时，传递的字符串必须与在故事板中设置的字符串完全一致，否则会报错，并且应用在运行时会崩溃。

在方法 `dequeueReusableCell(withIdentifier:for:)` 中，你是否注意到“*可重用单元格*”这几个字？表格视图中的单元格只会创建一次，然后可以反复使用。这有助于提高性能，使一切运行得更快更顺畅，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但每次屏幕上只能显示 10 个，那么你只需要 10 个单元格来展示这些生日。当你向下滚动以查看更多生日时，已经滚出屏幕顶部的单元格会被重用。它们会被填充上新信息，并出现在屏幕底部。`UITableView` 会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)` 会为每个可见行被调用。当用户滚动查看更多单元格时，它会再次被调用，每次为即将出现在屏幕上的行。

接下来，我们需要找出应该显示在单元格中的哪个生日。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日（即 birthdays[0]）应该显示在第 0 行，第二个生日（即 birthdays[1]）应该显示在第 1 行，依此类推，这意味着 indexPath 的行号与我们想要访问的 birthdays 数组中的位置相同。➋处的代码通过使用 indexPath.row 访问 birthdays 数组中的正确生日对象。一旦我们找到了正确的 Birthday 对象，我们将其赋值给名为 birthday 的常量，以便设置该单元格中的标签。

请注意，我们使用 let 将 birthday 赋值给常量而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的 birthday 常量。每个单元格都会有自己独立的 birthday 常量，并且该常量会被赋予对应的 Birthday 对象。由于我们不会更改任何 birthday 常量——我们只是读取它们的属性——因此不需要将其声明为变量。

现在您有了单元格和生日，是时候填写详细信息了。每个单元格需要两个标签来显示生日人的名字和出生日期。您将单元格设置为“副标题”样式，以便它有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，因此现在您无需自己创建标签。

标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。➌处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格隔开。在➍处，您使用 dateFormatter 的 string(from:)方法，将出生日期显示在 detailTextLabel 中。

当您的单元格完全配置好后，tableView(_:cellForRowAt:)会在➎处返回该单元格，以便它可以在表视图的对应 indexPath 处显示。

### 整合所有内容

现在，您可以通过“添加生日”视图控制器将 Birthday 实例添加到应用程序中，并且您有一个表视图来列出每个生日，在 Birthdays 表视图控制器中显示。但当您尝试运行应用并添加一个 Birthday 时，它并没有显示。为了让您添加的每个 Birthday 都出现在表视图中，您需要使“添加生日”视图控制器与“Birthdays 表视图控制器”进行通信。您可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设您有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 呈现在自己之上。A 知道 B，因为它创建并呈现了 B，所以 A 可以将信息传递给 B。但 B 并不知道 A——它只是突然出现，并不知道自己从哪里来，怎么到达这里。那么 B 怎么能与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托模式是指将某个任务或工作交给别人做。*委托对象* 就像一个老板，告诉委托员工该做什么。当委托员工完成任务后，有时会将信息反馈给委托的老板。

在 Swift 中，委托模式非常类似，但不同的是，我们没有老板和员工，而是有一个委托和一个委托对象。由于类 B 是由类 A 告诉要做什么的，所以它是委托对象。我们给类 B 一个特殊的属性，叫做 delegate，用来告诉它谁是它的委托对象——这样它就知道该与谁进行沟通。委托对象可以是任何拥有一组在 *协议* 中定义的方法的类。协议就像是两者之间的一项约定，告诉它们委托对象可以要求委托对象做什么。它包含了委托对象可以使用的方法和属性名称列表。

类 A 创建类 B，将自己设置为类 B 的委托对象，并给类 B 指派协议中的任务。等类 B 完成任务后，它会向类 A 报告。让我们看看这个在我们的应用中是如何工作的。

Birthdays 表格视图控制器是视图控制器 A，Add Birthday 视图控制器是视图控制器 B。我们将创建一个协议，名为 AddBirthdayViewControllerDelegate，并为该协议创建一个方法 `addBirthdayViewController(_:didAddBirthday:)`，Add Birthday 视图控制器将使用这个方法来报告信息。

看一下 图 11-6。当用户点击“添加”按钮 ➊ 时，Birthdays 表格视图控制器会创建 Add Birthday 视图控制器 ➋ 并将自己设置为 Add Birthday 视图控制器的委托对象。

![](img/Image00246.jpg)

*图 11-6：新生日通过委托模式从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议定义了一个方法 `addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存 ➌ 时，Add Birthday 视图控制器会调用此方法 ➍ 并将新的生日传递给它的委托对象——Birthdays 表格视图控制器。Birthdays 表格视图控制器将这个生日加入到它的生日数组中，然后重新加载它的表格视图 ➎，这样新添加的生日就会出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义方法 `addBirthdayViewController(_:didAddBirthday:)`，每当添加生日时，Add Birthday 视图控制器都可以调用该方法。Birthdays 表格视图控制器将实现该协议方法，这样每当通过 Add Birthday 视图控制器添加一个生日时，Add Birthday 视图控制器只需对其委托说：“嘿！刚刚有人添加了这个生日”，然后 Birthdays 表格视图控制器就会收到这个消息并回应：“哦！我会将它加入到我的列表中并刷新显示，以便新的生日能够显示出来。”

所以现在我们来写代码吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类的*上方*添加这段定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处通过输入关键字 protocol 并跟上名称 AddBirthdayViewControllerDelegate 来定义协议。这个名字很长，但 Swift 程序员通常会根据调用类的名称来命名协议，并在末尾加上 Delegate 一词。这样，你就可以通过协议的名称知道是哪个类在使用这个协议。既然你现在是一个 Swift 程序员，应该遵循相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传递回代理类➋。注意，在这个函数中，你将 AddBirthdayViewController 作为一个参数再次传入。Swift 程序员通常会根据约定在实现协议方法时这样做，因此你也应该遵循这个做法。知道是谁发送了回调消息，并且代理可以访问该对象及其类，这是非常有用的。

当 Add Birthday 视图控制器调用此方法时，它会将自身作为 addBirthdayViewController 参数传入。你很快就能看到如何做到这一点。另一个需要注意的点是外部参数名称 didAddBirthday。许多代理协议方法都包含*did*和*will*这两个词，因为它们用来描述调用类刚刚做过的或将要做的事情。

现在你已经定义了协议，需要告诉 Birthdays 表视图控制器采用这个协议并使用协议中的方法。

##### 让 Birthdays 表视图控制器符合协议

为了采用协议，Birthdays 表视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在 UITableViewController 超类后，在类定义中添加 AddBirthdayViewControllerDelegate。将逗号添加到 UITableViewController 后面，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，就会出现一个红色错误。这是因为 BirthdaysTableViewController 声明自己是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现它，BirthdaysTableViewController 需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，并且该超类的名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采用任意数量的协议——这些协议会在超类之后列出，并且用逗号隔开。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动补全功能会建议整个方法声明。这是因为它知道这个类实现了 AddBirthdayViewController Delegate 协议，并且它期待你添加这个方法。请注意，与子类化方法不同，你在 addBirthdayViewController(_:didAddBirthday:) 前并不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将由 Add Birthday 视图控制器传递的生日添加到 birthdays 数组中。你可以通过使用 append(_:) 方法来实现 ➋ 。接下来，你需要刷新表格视图，以便显示这个新添加的生日，可以通过调用 tableView 属性上的 reloadData() 方法 ➌ 来做到这一点。当调用 reloadData() 时，表格视图的数据源方法会被重新调用，新增的生日会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必须的，但标记类的不同部分是良好的编码风格，并且有助于保持代码的整洁和可读性。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你查找方法，并让你可以快速跳转到代码的不同位置。要使用这个菜单，请点击编辑器面板顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个章节。*

##### 给 Add Birthday 视图控制器设置代理

BirthdaysTableViewController 已经实现了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知 Birthdays 表格视图控制器它已成功添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性，方法是将以下代码行插入到 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在 Add Birthday 视图控制器创建之前设置它。稍后你将学到在哪里设置代理。

现在 AddBirthday 视图控制器有了一个委托，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将生日对象传递给委托。将 saveTapped(_:)方法修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)方法将它传回委托。

太好了！你已经完成了对 AddBirthday 视图控制器的修改。现在它有了一个委托，可以监听生日被保存的调用。运行应用程序，看看会发生什么。

嗯……似乎没有太大变化。当你添加一个生日时，仍然没有看到它出现在生日表视图控制器中。怎么回事？

#### 通过设置委托连接两个控制器

你还有最后一件事需要做。生日表视图控制器是一个 AddBirthdayViewControllerDelegate，而 AddBirthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存着当生日被保存时它与之沟通的委托对象。但我们从未特别设置委托属性为生日表视图控制器。所以，现在是时候在两个视图控制器之间建立通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，叫做 prepare(for:sender:)。删除围绕它的/*和*/来取消注释该方法。

每当 Birthdays 表视图控制器放弃其屏幕，应用程序通过故事板 segue 过渡到另一个视图控制器时，都会自动调用这个方法。我们将使用这个方法将 Birthdays 表视图控制器传递给 AddBirthday 视图控制器，从而将其自身设置为 AddBirthday 视图控制器的委托。在 prepare(for:sender:)方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码，就可以将 AddBirthday 视图控制器的委托设置为生日表视图控制器。首先，你需要能够通过 segue 参数访问 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个叫做 destination 的属性，指向在此方法中正在准备的 segue 的另一端，但这个应用的 destination 并不是 AddBirthdayViewController。

在第九章中，你将 AddBirthday 视图控制器嵌入到导航控制器中，这样你就可以有一个带有取消和保存按钮的导航栏。所以你不期望在 segue 的另一端找到 AddBirthday 视图控制器。相反，目标是一个包含 AddBirthday 视图控制器的 UINavigationController。➊处的代码会获取到 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是一个特定类型的 ViewController，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表示这个控制器是 UIViewController 的一个具体子类。最后，当你得到一个 AddBirthdayViewController 时，你可以将代理设置为 self，这里 self 指的是当前的生日表视图控制器 ➌。

现在运行应用并添加一些生日！在生日表视图控制器中你看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用然后再次运行它，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学会了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表视图控制器中的生日数组中，以便它能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，以便即使你退出应用并再次运行，它们仍然显示。为了保存生日，你将使用 Core Data，这是我们在项目一开始时设置的。

![](img/Image00236.jpg)

*图 11-3：将* BirthdaysTableViewController *设置为生日场景的类*

现在你已经在故事板中设置了生日表视图控制器，下一步是制作表格中的单元格来显示每个生日。

#### 向表格视图添加单元格

每个生日将显示在生日表视图控制器中的一个 UITableViewCell 中。表格由按行和列组织的框组成，这些框包含信息。这些框被称为*单元格*。类似地，表格视图也有单元格，这些单元格都是 UITableViewCell 类的实例或其子类。我们将把每个生日放入我们表格视图中的独立单元格。

我们将首先在故事板中创建这些单元格，然后稍后将它们填充我们的生日对象。在左侧大纲菜单中，点击“生日”旁边的三角形，然后点击“表格视图”旁边的三角形以展开这些部分。然后选择**表格视图单元格** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建一个副标题样式的表格视图单元格并设置其标识符*

接下来，打开属性检查器。使用**样式**下拉菜单，将单元格的样式设置为**副标题** ➋，这样单元格就会有一个标题标签和一个副标题标签。你将把每个人的名字显示在标题中，生日显示在副标题中。

最后，在 Identifier 字段中输入 birthdayCellIdentifier➌。你稍后将在填充单元格内容时使用这个标识符。

就这样！你已经完成了 storyboard 中的工作。

你可能会想知道，为什么我们在 storyboard 中的表视图里只有一个单元格，而实际上我们会有多个生日要显示。如果你再看一下图 11-4，你会注意到该单元格标记为*原型单元格*。这意味着你刚刚自定义的单元格是你希望在表视图中显示的所有单元格的*模板*。你给单元格指定的标识符就是你的代码告诉表视图生成每个单元格的方式，以便你放入生日信息。你很快就会看到这个是如何工作的。

**处理日期**

Swift 有一个特殊的数据类型叫做 Date，用来存储日期值。一个 Date 对象实际上是一个日期和时间。打开你的 playground 并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给了变量 today。当你打印 today 时，它的格式是 "2017-11-21 10:45:31 +0000\n"。如果你想让它显示为 Tuesday, November 21, 2017 呢？或者仅仅是 11/21/17？要以特定的方式显示日期，你需要使用*日期格式化器*，这是一种 DateFormatter 对象，你可以创建并给它一个日期格式样式。DateFormatter 是一个帮助对象，用于从任何日期创建显示字符串，*日期格式样式*是 DateFormatter 的一个属性，用来告诉格式化器使用哪种样式。你可以手动创建自己的日期格式样式，但 Swift 中也有一些现成的样式可以直接使用。将以下代码添加到你的 playground 中：

![](img/Image00240.jpg)

在➊，你创建了一个格式化器。然后在➋，你将格式化器的样式设置为 Style.full，这将打印星期几以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:)方法➌ 从日期中创建一个字符串。你可以看到，现在你已经将日期转换成了格式良好的字符串 "Tuesday, November 21, 2017"。表 11-1 展示了从 Swift 中五种 DateFormatter.Style 选项生成的不同字符串。

**表 11-1：** 日期格式化样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "Nov 21, 2017" |
| long | "November 21, 2017" |
| full | "Tuesday, November 21, 2017" |

你还可以通过 DateFormatter 的 dateFormat 属性指定自定义的日期显示方式。也许你只想要显示月份和日期。或者你可能想要以简短的样式显示四位数的年份。做任何一种都非常简单，你甚至不需要创建新的 DateFormatter——你只需要改变格式化器的 dateFormat，然后要求它返回一个新的字符串。将以下代码添加到你的 playground 中，以显示特定格式的日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定只希望以 MM/dd 格式显示月份和日期——即两位数的月份，后跟两位数的日期。如果你希望以三字母的形式显示月份，则使用 MMM。要显示完整的月份名称，使用 MMMM。在 ➋ 处，我们将日期格式更改为使用四位数的年份。两位数的年份为 yy。这里是一些其他使用 dateFormat 显示自定义日期字符串的方式。

![](img/Image00242.jpg)

如果你想包括分隔符，可以将它们添加到你的 dateFormat 字符串中。例如，如果你希望使用句点作为分隔符，可以创建一个类似"MM.dd.yy"的 dateFormat ➊ 。要显示星期几的缩写，使用 EEE ➋ 。如果需要显示完整的星期几名称，使用 EEEE ➌ 。这些只是一些示例。通过组合 M、d、y 和 E，你可以拥有无穷无尽的方式来显示日期！

#### 设置生日表视图控制器

生日表视图控制器将显示应用中存储的所有生日列表。你记得用什么来存储一系列项目吗？没错——是一个数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有的生日。为此，在类的顶部，紧挨着 viewDidLoad()方法，插入以下这一行来添加一个名为 birthdays 的数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量而不是常量，因为你每次用户通过“添加生日”视图控制器添加生日时，都会将一个保存的 Birthday 添加到这个数组中。你将在“让生日表视图控制器符合协议”第 168 页看到如何实现。

**注意**

*请记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

生日表视图控制器还需要一个 dateFormatter 属性来将出生日期显示为格式化的字符串。在 birthdays 数组下方添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，它是通过 let 创建的。尽管你将更改 dateFormatter 的属性，如 dateStyle 和 timeStyle，但你永远不会更改 dateFormatter 本身。

你还需要设置 dateFormatter，以便它将出生日期显示为完全格式化的字符串，如"Tuesday, December 17, 2008"。正如你在第十章中看到的那样，设置它的一个好地方是在 viewDidLoad()方法中，该方法在生日表视图控制器加载其视图时被调用。这是进行类所需的任何设置的完美时机。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了日期格式化器的 dateStyle，使其能够显示每个生日的格式化日期字符串。你是否注意到我们只是写了.full，而不是 DateFormatter.Style.full？Swift 知道 DateFormatter 的 dateStyle 应该是什么类型，因此允许我们使用这个小的快捷方式。在 ➋ 处，你将日期格式化器的 timeStyle 设置为.none，这样时间就不会显示出来。

#### 在表格视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于显示单列中的项目列表。表格视图有一个或多个节，每个节包含多行，每行包含一个单元格。表格视图中的一个节是行的分组，可以带有或不带有标题。一个显示多个节的表格视图应用实例是设置应用，如图 11-5 所示。它显示了分为不同节的行列表。

表格视图的每个节和行都有一个索引号。这些数字从 0 开始，然后随着你向下滚动表格视图逐渐增加。例如，设置应用中的隐私行位于节 0，行 1。新闻设置位于节 1，行 3。

在 BirthdaysTableViewController 类的中间，有一个名为*Table view data source*的节，包含三个方法。表格视图控制器使用这些方法来确定在其表格视图中显示什么内容。

numberOfSections(in:) 告诉表格视图应该有多少个节。

tableView(_:numberOfRowsInSection:) 告诉表格视图每个节中将显示多少行。

tableView(_:cellForRowAt:) 设置要显示在表格视图每一行中的每个单元格。

![](img/Image00243.jpg)

*图 11-5：设置应用使用节来分组不同设备设置的行。*

表格视图的数据源方法在每次重新加载表格视图时都会被表格视图控制器调用。当你创建一个 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现这三个方法才能使应用正常工作，尽管你永远不会在代码中直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用于确定表格视图中将显示的内容。我们将在“委托”一节中讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，所以你不需要调用它们。

让我们从方法 numberOfSections(in:)开始。Birthdays 表格视图控制器是一个只显示生日实例的列表，因此它不需要多个节。为了设置表格视图中的节数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个 UITableView 参数 tableView，这是使用此类作为数据源的表格视图。我们无需担心建立这个连接，因为 UITableViewController 自带一个内建的表格视图，它会自动与这些方法连接。每个生日将显示在自己的一行中。所以，在 tableView(_:numberOfRowsInSection:) 中，为了保证你的表格视图显示正确数量的行，你需要返回 birthdays 数组中 Birthday 实例的数量。你记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少个元素，非常适合这种情况！将此方法修改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，tableView(_:numberOfRowsInSection:) 还接受一个名为 section 的 Int 参数。当表格视图加载时，针对每个部分都会调用这个方法。在我们的例子中，我们只有一个部分，因此不需要检查正在显示的是哪个部分。我们知道是部分 0，并且我们希望它有与生日数量相等的行数，所以我们写 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:) 方法，以便表格视图能够知道在每个单元格中放置什么内容。由于这个方法被注释掉了，你需要通过删除 /* 和 */ 来取消注释它。（小心不要意外取消注释它后面的其他方法！）完成后，将其修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要手动调用 tableView(_:cellForRowAt:) 方法。它会在表格视图加载到屏幕时被自动调用。它会为每个单元格调用一次，接受两个参数，tableView 和 indexPath。你已经知道 tableView 参数的作用了。IndexPath 是一个 Swift 结构体，用于表示表格视图中行的位置。一个 IndexPath 实例有一个 section 属性和一个 row 属性。由于这个方法会被调用多次（每行调用一次），我们需要 indexPath 来知道当前正在配置的是哪个部分和哪一行。indexPath.section 属性给出部分号，indexPath.row 给出表格视图单元格的行号。tableView(_:cellForRowAt:) 中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 找出 birthdays 数组中将要显示在单元格中的 Birthday

• 创建两个标签，用于在单元格中显示生日人的姓名和生日日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。在➊处的代码使用方法`dequeueReusableCell(withIdentifier:for:)`来实现这一点。不过，在你开始在单元格上使用此方法之前，你需要告诉该方法你想从故事板中使用哪个单元格。之前，当你在故事板中时，你给单元格指定了标识符`birthdayCellIdentifier`（见图 11-4）。这个标识符将你的代码与单元格关联起来，并告诉方法它正在使用正确的单元格。当你调用此方法时，字符串必须与在故事板中设置的字符串完全相同，否则你会遇到错误，应用程序在运行时会崩溃。

在`dequeueReusableCell(withIdentifier:for:)`方法中，你注意到有*可重用单元格*这几个词吗？表格视图中的单元格只会创建一次，然后可以反复使用。这有助于提升性能，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以查看更多生日时，已经滚出屏幕顶部的单元格会被重用。它们会被填充新的信息，并重新出现在屏幕底部。UITableView 会自动执行这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)`会为每一行可见的单元格调用一次。当用户滚动查看更多单元格时，每当某行即将显示在屏幕上时，它会再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中显示`birthdays`数组中的一个生日。第一个生日，即`birthdays[0]`，应该显示在第 0 行。第二个生日，即`birthdays[1]`，应该显示在第 1 行，依此类推，这意味着`indexPath`的行数与我们想访问的`birthdays`数组中的位置相同。在➋处的代码通过使用`indexPath.row`来访问`birthdays`数组中的正确`Birthday`对象。一旦我们得到了正确的`Birthday`对象，就将其赋值给名为`birthday`的常量，以便设置此单元格中的标签。

请注意，我们使用`let`将生日赋值给常量，而不是变量。我们可以使用`let`，因为每次调用`tableView(_:cellForRowAt:)`时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并赋值为相应的`Birthday`对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以我们不需要将它们设置为变量。

现在你有了单元格和生日，接下来是填写详细信息。你需要为每个单元格设置两个标签，分别显示生日人的姓名和出生日期。你将单元格设置为“副标题”样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含这些标签，所以你现在无需自己创建标签。

标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，两者之间有一个空格。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 会返回该单元格，以便它能够在表格视图的指定索引路径位置显示。

### 整合所有内容

现在，你可以通过“添加生日”视图控制器将生日实例添加到应用中，并且有一个表格视图来列出每个生日，在生日表格视图控制器中显示。但是，当你尝试运行应用并添加生日时，它没有出现在表格中。为了让你添加的每个生日出现在表格视图中，你需要让“添加生日”视图控制器与生日表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 展示在自己之上。A 知道 B，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但 B 并不知道 A —— 它只是突然出现，根本不知道自己来自哪里或如何到达这里。那么 B 如何与 A 进行沟通呢？通过委托！

![](img/Image00245.jpg)

委托是指将一项任务或工作交给别人。*委托*就像一个老板，告诉一个被委派的员工该做什么。当被委派的员工完成任务时，有时他们会向委托的老板报告信息。

在 Swift 中，委托非常相似，不过我们不再是老板和员工的关系，而是委托和被委托对象的关系。由于类 B 是由类 A 告诉该做什么的，因此它是被委托对象。我们给类 B 设置一个特殊的属性，叫做 delegate，用来告诉它谁是它的委托对象——这样它就知道该与谁进行沟通。委托对象可以是任何一个拥有在*协议*中定义的一组方法的类。协议就像是两个类之间的约定，告诉它们委托可以要求被委托对象做什么。协议中列出了委托可以与被委托对象使用的方法和属性名称。

类 A 创建类 B，将自己设置为类 B 的委托，并给类 B 一个任务，该任务存在于协议中。当类 B 完成任务时，它会向类 A 报告。让我们看看在我们的应用中这是如何工作的。

生日表格视图控制器是视图控制器 A，“添加生日”视图控制器是视图控制器 B。我们将创建一个协议，叫做 AddBirthdayViewControllerDelegate，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将被“添加生日”视图控制器用来回传信息。

看一下图 11-6。当用户点击 Add 按钮 ➊ 时，Birthdays 表格视图控制器创建 Add Birthday 视图控制器 ➋ 并将自己设置为 Add Birthday 视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过代理从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，Add Birthday 视图控制器调用这个方法 ➍ 并将新添加的生日传递给它的代理——Birthdays 表格视图控制器。Birthdays 表格视图控制器接收这个生日，将其添加到自己的生日数组中，然后重新加载其表格视图 ➎，以便新生日显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，其中包含方法 addBirthdayViewController(_:didAddBirthday:)，该方法允许 Add Birthday 视图控制器在每次有生日被添加到应用时调用。Birthdays 表格视图控制器将实现这个协议方法，这样每当 Add Birthday 视图控制器添加一个生日时，Add Birthday 视图控制器只需要对它的代理说：“嘿！有人刚刚添加了这个生日，”而 Birthdays 表格视图控制器会收到消息并回应：“哦！我会将它添加到我的列表中并刷新显示，这样新添加的生日就会出现。”

现在让我们来编写代码吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类*上方*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处定义协议，通过键入关键字 protocol，后跟 AddBirthdayViewControllerDelegate 的名称。这个名字有点长，但 Swift 程序员通常根据调用类的名称命名协议，并在末尾加上 Delegate 一词。这样，你就能通过查看协议名称知道是哪个类在使用该协议。既然你现在是一个 Swift 程序员，你应该遵循相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传递回代理类 ➋ 。注意，在这个函数中，你包括了 AddBirthdayViewController 作为参数。再次强调，Swift 程序员通常在实现协议方法时根据约定这样做，所以你也应该遵循这个做法。这样做有助于知道是谁发送了消息，并且让代理能够访问那个对象及其类。

当 `Add Birthday` 视图控制器调用这个方法时，它会将自己作为 `addBirthdayViewController` 参数传递进来。你很快就会看到是如何实现的。另一个需要注意的是外部参数名 `didAddBirthday`。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类已经做过的事或即将做的事。

现在你已经定义了协议，接下来需要告诉 `Birthdays` 表格视图控制器采用这个协议并使用协议的方法。

##### 让 `Birthdays Table View Controller` 符合协议

为了采用这个协议，`Birthdays` 表格视图控制器需要声明自己是 `AddBirthdayViewControllerDelegate`。为此，你需要在类定义中，在 `UITableViewController` 超类之后，添加 `AddBirthdayViewControllerDelegate`。在类的顶部，在 `UITableViewController` 后添加一个逗号，然后输入 `AddBirthdayViewControllerDelegate`：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，就会出现一个红色错误。这是因为 `BirthdaysTableViewController` 声明它是 `AddBirthdayViewControllerDelegate`，但它尚未实现该协议！为了实现它，它需要实现 `AddBirthdayViewControllerDelegate` 协议的定义。别担心，我们很快就能解决这个问题。

这里需要注意的是，`BirthdaysTableViewController` 是从 `UITableViewController` 超类继承的。一个类只能有一个超类，而且这个超类名称必须写在所有协议之前。但尽管一个类只能有一个超类，它可以采用任意数量的协议——这些协议将列在超类之后，并通过逗号分隔。

现在，为了符合 `AddBirthdayViewControllerDelegate` 协议并修复错误，我们需要在 `Birthdays TableViewController` 中添加 `addBirthdayViewController(_:didAddBirthday:)` 方法。一个合适的位置是类的末尾，即导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议你整个方法声明。这是因为它知道这个类采用了 `AddBirthdayViewController Delegate` 协议，并且它期望你添加这个方法。需要注意的是，与子类化方法不同，`addBirthdayViewController(_:didAddBirthday:)` 方法前并不需要使用 `override` 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将 `Add Birthday` 视图控制器传入的生日添加到 `birthdays` 数组中。你可以使用数组的 `append(_:)` 方法来完成这项操作 ➋。接下来，你需要刷新表格视图，以便它能显示这个新的生日，可以通过调用 `tableView` 属性的 `reloadData()` 方法来实现 ➌。当调用 `reloadData()` 时，表格视图的数据源方法会被重新调用，新增的生日将会显示在生日列表的底部。

你可能注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但良好的编码风格是将类的不同部分标记出来，这有助于保持代码清晰和易读。注释的第一部分`MARK: -`是 Xcode 识别的特殊关键字，它将`AddBirthdayViewControllerDelegate`部分添加到一个下拉目录菜单中，你可以在类的顶部使用该菜单。这个下拉菜单帮助你查找方法，并能快速跳转到代码的不同位置。要使用这个菜单，只需点击编辑器面板顶部的`Birthdays TableViewController`，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个章节。*

##### 给“添加生日”视图控制器设置代理

`BirthdaysTableViewController`已经采纳了`AddBirthdayViewControllerDelegate`协议。现在是时候让“添加生日”视图控制器使用`AddBirthdayViewControllerDelegate`协议，在添加一个生日时通知生日列表视图控制器了。为此，“添加生日”视图控制器首先需要定义一个代理。我们通过在`AddBirthdayViewController`类中添加一个可选的`AddBirthdayViewControllerDelegate`类型的代理属性来安排这一点，方法是将以下代码插入到 outlets 下方：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是一个可选项，因为在“添加生日”视图控制器创建之前，你无法设置它。你将很快学到如何设置代理。

现在，既然“添加生日”视图控制器已经有了代理，在`saveTapped(_:)`方法中，你可以通过`addBirthdayViewController(_:didAddBirthday:)`方法将一个生日传递给代理。将`saveTapped(_:)`改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊处的代码通过`addBirthdayViewController(_:didAddBirthday:)`将其传递回代理。

太棒了！你已经完成了“添加生日”视图控制器的更改。现在它有一个代理，能够监听生日被保存的事件。运行应用程序，看看会发生什么。

嗯……变化不大。当你添加一个生日时，依然没有看到它出现在生日列表视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事需要做。“生日”列表视图控制器是一个`AddBirthdayViewControllerDelegate`，而“添加生日”视图控制器有一个`AddBirthdayViewControllerDelegate`属性，它保存着在生日被保存时与之通信的代理。但我们从未明确地将代理属性设置为生日列表视图控制器。所以现在是时候连接这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，叫做 prepare(for:sender:)。通过删除/*和*/来取消注释这个方法。

每当 Birthdays 表格视图控制器放弃其屏幕并且应用程序通过故事板 segue 转换到另一个视图控制器时，这个方法会自动调用。我们将使用这个方法将 Birthdays 表格视图控制器传递给添加生日视图控制器，并将其设置为添加生日视图控制器的委托。在 prepare(for:sender:)方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码，就可以将添加生日视图控制器的委托设置为 Birthdays 表格视图控制器。首先，你需要能够通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 在注释中留下了提示，说明你可以如何做到这一点。一个 UIStoryboardSegue 有一个叫做 destination 的属性，它位于这个方法中正在准备的 segue 的另一端，但对于这个应用程序，destination 并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到导航控制器中，以便能够拥有带有“取消”和“保存”按钮的导航栏。所以你不应该期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊这一行代码可以让你获得 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定子类，我们需要使用 as 进行类型转换，将其转换为 UINavigationController。

接下来，你可以获得添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的特定子类。最后，当你获得 AddBirthdayViewController 后，可以将其委托设置为 self，也就是当前的 Birthdays 表格视图控制器 ➌。

现在运行应用程序并添加一些生日！在 Birthdays 表格视图控制器中你看到了什么？生日！生日！生日！不过我们还没有完成。如果你退出应用程序然后再次运行，之前的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中进行。

### 你学到的内容

在本章中，你学会了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，然后如何使用委托将生日添加到 Birthdays 表格视图控制器中的生日数组中，以便它能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用并重新启动，它们依然会显示。为了保存生日，你将使用 Core Data，这是我们在项目一开始就设置的。

*图 11-3：将* BirthdaysTableViewController *设置为 Birthdays 场景的类*

现在，你已经在故事板中设置了 Birthdays 表格视图控制器，下一步是创建表格中的单元格来显示每个生日。

#### 向表格视图添加单元格

每个生日都将在 Birthdays 表格视图控制器中的 UITableViewCell 中显示。表格有按行列组织的信息框，这些框被称为*单元格*。同样，表格视图也有单元格，它们都是 UITableViewCell 类或其子类的实例。我们将把每个生日放入表格视图中的各自单元格中。

我们将先在故事板中创建这些单元格，然后稍后用我们的生日对象填充它们。在左侧大纲菜单中，点击 Birthdays 前的三角形，然后点击 Table View 前的三角形来打开这些部分。然后选择 **Table View Cell** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建一个 Subtitle 风格的表格视图单元格并设置其标识符*

接下来，打开属性检查器。在 **Style** 下拉菜单中，将单元格的样式设置为 **Subtitle** ➋，这样单元格就会有一个标题标签和一个副标题标签。你将在标题中显示每个人的名字，在副标题中显示生日。

最后，在标识符字段 ➌ 中输入 birthdayCellIdentifier。你稍后在填充单元格内容时会使用这个标识符。

就是这样！你已经完成了故事板中的工作。

你可能会想，为什么在故事板中的表格视图里只有一个单元格，而实际上我们要展示的生日会有多个？如果你再看一下图 11-4，你会注意到这个单元格标记为*原型单元格*。这意味着你刚刚自定义的单元格是所有你想在表格视图中显示的单元格的*模板*。你给单元格设置的标识符将告诉你的代码如何生成每一个单元格，以便你能放入生日数据。很快你就会明白这是如何工作的。

**处理日期**

Swift 有一个特殊的数据类型叫做 Date，用于存储日期值。Date 对象实际上表示一个日期和时间。打开你的 playground，并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将当前日期和时间（即代码运行时的时间）赋值给变量 `today`。当你打印 `today` 时，它的格式是 "2017-11-21 10:45:31 +0000\n"。如果你想它显示为 "Tuesday, November 21, 2017" 呢？或者只显示为 "11/21/17"？要以特定方式显示日期，你可以使用 *日期格式化器*，它是你创建并为其设置日期格式样式的 `DateFormatter` 对象。`DateFormatter` 是一个帮助对象，用于从任何日期创建显示字符串，而 *日期格式样式* 是 `DateFormatter` 的一个属性，用来告诉格式化器使用哪种样式。你可以手动创建自己的日期格式样式，但 Swift 也提供了几种现成的样式供使用。将以下内容添加到你的 Playground：

![](img/Image00240.jpg)

在 ➊ 处，你创建了一个 `formatter`。然后在 ➋ 处，你将格式化器的样式设置为 `Style.full`，这将打印星期几以及完整的月份名称、日期和年份。最后，你使用 `DateFormatter` 类的 `string(from:)` 方法从日期创建一个字符串 ➌。你可以看到，你现在已经将日期转换成了格式良好的字符串 "Tuesday, November 21, 2017"。 表 11-1 显示了在 Swift 中使用五种 `DateFormatter.Style` 选项生成的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "Nov 21, 2017" |
| long | "November 21, 2017" |
| full | "Tuesday, November 21, 2017" |

你还可以使用 `DateFormatter` 的 `dateFormat` 属性指定自定义的日期显示方式。也许你只想显示月份和日期，或者你希望年份以四位数短格式显示。无论哪种方式都非常简单，你甚至不需要创建新的 `DateFormatter` ——只需更改 `formatter` 的 `dateFormat` 属性，然后请求它返回新的字符串。将以下代码添加到你的 Playground 中，以使用特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定只想使用 MM/dd 格式显示月份和日期——即两位数的月份后跟两位数的日期。如果你想用三字母显示月份，可以使用 MMM。要显示月份的全名，使用 MMMM。在 ➋ 处，我们将日期格式更改为四位数的年份。两位数的年份应使用 yy。这里有其他几种方法可以使用 `dateFormat` 来显示自定义日期字符串。

![](img/Image00242.jpg)

如果你想包含分隔符，可以将它们添加到 `dateFormat` 字符串中。例如，如果你想使用句号作为分隔符，可以创建一个类似 "MM.dd.yy" ➊ 的 `dateFormat`。要显示缩写形式的星期几，可以使用 EEE ➋。要显示完整的星期几，可以使用 EEEE ➌。这只是一些示例。通过组合 M、d、y 和 E，你可以有无尽的方式来显示日期！

#### 设置生日表视图控制器

Birthdays 表视图控制器将显示应用程序中存储的所有生日列表。你还记得用什么来存储一个项目列表吗？没错——一个数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有的生日。为此，给 BirthdaysTableViewController 添加一个 birthdays 属性，类型是 Birthday 对象的数组。在类的顶部，紧接着 viewDidLoad() 方法上方，插入以下代码以添加名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行代码创建了一个空的 Birthday 实例数组。它需要是一个变量，而不是常量，因为你每次用户通过添加生日视图控制器添加生日时，都希望向这个数组中添加一个已保存的生日。你将在 “让 Birthdays 表视图控制器遵守协议” 中看到如何做到这一点，详见 第 168 页。

**注意**

*记得项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *获取。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性，以便将出生日期显示为格式化良好的字符串。将一个 dateFormatter 添加到 birthdays 数组的正下方：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

注意，dateFormatter 是一个常量，用 let 创建。尽管你会修改 dateFormatter 的属性，比如 dateStyle 和 timeStyle，但你永远不会修改 dateFormatter 本身。

你还需要设置 dateFormatter，使其能够将出生日期显示为完整格式的字符串，例如“Tuesday, December 17, 2008”。正如你在 第十章 中看到的，设置的最佳位置是 viewDidLoad() 方法，在此方法中，Birthdays 表视图控制器加载视图时会被调用。这是进行任何必要设置的最佳时机。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 dateFormatter 的 dateStyle，使其能够为每个 Birthday 显示格式化的日期字符串。你是否注意到我们直接写了 .full，而不是 DateFormatter.Style.full？Swift 知道 dateStyle 的类型，所以允许我们省略类型名。 在 ➋ 处，你将 dateFormatter 的 timeStyle 设置为 .none，这样就不会显示时间。

#### 在表视图中显示生日

BirthdaysTableViewController 类包含一个表视图，用于在单列中显示项目列表。表视图包含一个或多个包含行的部分，每一行包含一个单元格。表视图中的一个部分是对行的分组，可以选择性地显示或不显示标题。一个展示了多个部分的表视图的应用程序示例如设置应用程序，如图 11-5 所示。它显示了被分割成不同部分的行列表。

表视图的每个部分和每一行都有一个索引号。这些数字从 0 开始，然后随着向下滚动表视图而增加。例如，设置应用中的隐私选项在第零部分，第 1 行。新闻设置在第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为 *Table view data source* 的部分，包含三个方法。表视图控制器使用这些方法来确定在其表视图中将显示什么内容。

numberOfSections(in:) 告诉表视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表视图每个部分中将显示多少行

tableView(_:cellForRowAt:) 设置每个将在表视图每行中显示的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分来分组不同的设备设置行。*

每次表视图重新加载时，表视图控制器都会调用表视图数据源方法。Xcode 在你创建 UITableViewController 子类时会自动为你提供这些方法模板。即使你不会在代码中直接调用它们，你也需要实现这三个方法才能使应用正常工作。UITableViewController 类实现了 UITableViewDataSource 协议，协议中包含这些数据源方法，用于确定表视图中将显示什么内容。我们将在“委托”的第 166 页讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，所以你不需要手动调用它们。

让我们从方法 numberOfSections(in:) 开始。Birthdays 表视图控制器是一个只显示 Birthday 实例的列表，因此它不需要多个部分。为了设置表视图中的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法将一个名为 tableView 的 UITableView 作为参数，tableView 是使用该类作为数据源的表视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内置的表视图，并且会自动将这些方法连接起来。每个生日都会显示在它自己的行中。因此，在 tableView(_:numberOfRowsInSection:) 中，为了让你的表格展示所有生日的正确行数，你需要返回 birthdays 数组中 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少个元素，正好适用于这种情况！将这个方法更改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了`tableView`参数，`tableView(_:numberOfRowsInSection:)`方法还需要一个名为`section`的`Int`类型参数。当表格视图加载时，这个方法会为每个表格视图的部分调用。在我们的案例中，只有一个部分，因此我们不需要检查当前显示的是哪个部分。我们知道是第零部分，我们希望它的行数与生日数量相同，因此我们写下`return birthdays.count`。

最后，你需要实现`tableView(_:cellForRowAt:)`方法，这样表格视图就知道在每个单元格中显示什么内容。由于这个方法被注释掉了，你需要通过删除包围它的/*和*/来取消注释。（小心不要意外取消其他方法的注释！）完成后，将其改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要手动调用`tableView(_:cellForRowAt:)`方法。它会在表格视图加载到屏幕上时自动被调用。它会为屏幕上的每个单元格调用一次，且接受两个参数：`tableView`和`indexPath`。你已经知道`tableView`参数的作用。`IndexPath`是一个 Swift 结构体，用于表示表格视图中某一行的位置。一个`IndexPath`实例有`section`属性和`row`属性。由于这个方法会被多次调用（每一行都会调用一次），我们需要`indexPath`来知道当前正在配置的是哪个部分和行。`indexPath.section`属性给出部分号，`indexPath.row`给出表格视图单元格的行号。`tableView(_:cellForRowAt:)`中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个`UITableViewCell`

• 确定在`birthdays`数组中哪个生日会显示在单元格内

• 创建两个标签来显示生日人的名字和出生日期

• 返回准备好在表格视图中显示的单元格

让我们逐行分析这段代码。

首先，创建`UITableViewCell`。➊处的代码使用`dequeueReusableCell(withIdentifier:for:)`方法来实现这一点。不过，在你开始在单元格上使用这个方法之前，你需要告诉它你想从故事板中使用哪个单元格。早些时候，在故事板中，你给单元格设置了`birthdayCellIdentifier`这个标识符（见图 11-4）。这个标识符将你的代码与单元格关联起来，并告诉方法它正在使用正确的单元格。当你调用这个方法时，传入的字符串必须与在故事板中设置的字符串完全一致，否则会出错，应用程序在运行时会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:)中，你注意到*Reusable Cell*这两个词了吗？表格视图中的单元格只创建一次，然后可以反复使用。这有助于加快一切运行，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日，但一次只显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，滚出屏幕顶部的单元格会被重用。它们会填充新的信息，并再次出现在屏幕的底部。UITableView 会自动完成这项工作。当表格视图加载时，tableView(_:cellForRowAt:)会为每一行可见的单元格调用。当用户滚动查看更多单元格时，它会在每一行即将出现在屏幕上时再次调用。

接下来，我们需要找出哪一个 Birthday 应该显示在单元格内。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日，位于 birthdays[0]，应该显示在第 0 行。第二个生日，位于 birthdays[1]，应该显示在第 1 行，以此类推，这意味着 indexPath 的 row 与我们希望访问的 birthdays 数组中的位置相同。➋处的代码通过使用 indexPath.row 从 birthdays 数组中访问正确的 Birthday 对象。一旦我们得到了正确的 Birthday 对象，我们将其赋值给一个名为 birthday 的常量，以便在这个单元格中设置标签。

请注意，我们使用`let`来将生日赋值给一个常量，而不是变量。我们可以使用`let`，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并分配给自己的 Birthday 对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以我们不需要将它们定义为变量。

现在你已经有了单元格和生日，是时候填写详细信息了。每个单元格需要两个标签来显示生日人的名字和出生日期。你将单元格设置为 Subtitle 样式，这样它就有一个 Title 标签和一个 Subtitle 标签。每个单元格已经包含了这些标签，所以你现在不需要自己创建标签了。

这些标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。➌处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间以空格隔开。➍处，你使用 dateFormatter 的 string(from:)方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:)在➎处返回该单元格，以便它能够在 table view 的该 indexPath 处显示。

### 汇总

现在，你可以使用添加生日视图控制器向应用中添加生日实例，并且在生日列表视图控制器的表格视图中列出每个生日。但是当你运行应用并尝试添加生日时，新的生日并没有显示出来。为了让你添加的每个生日都出现在表格视图中，你需要让添加生日视图控制器与生日列表视图控制器进行通信。你可以通过使用*委托机制*来实现这一点。

#### 委托机制

委托机制可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 呈现到自己之上。A 知道 B 的存在，因为它创建并展示了 B，所以 A 可以向 B 传递信息。但 B 并不知道 A——它只是突然被创建出来，完全不知道自己从哪里来，也不知道自己是怎么到达这个位置的。那么 B 如何与 A 进行交流呢？通过委托机制！

![](img/Image00245.jpg)

委托机制是指某人将工作或任务交给其他人处理。*委托*就像是一个老板，他告诉委托的员工做什么。当被委托的员工完成任务后，有时会将信息反馈给委托的老板。

Swift 中的委托机制非常相似，不同的是我们不是有老板和员工，而是有委托对象和被委托对象。由于 B 类是被 A 类指示要做事情的对象，因此它是被委托对象。我们给 B 类一个特殊的属性，叫做委托（delegate），用来告诉它谁是它的委托对象——这样它就知道该与谁沟通。委托可以是任何一个拥有已定义方法集合的类，这些方法集合在*协议*中进行了定义。协议就像是两者之间的约定，告诉它们委托对象可以要求被委托对象做什么。协议包含了一些方法和属性名称，委托对象可以用这些方法和属性与被委托对象进行交互。

A 类创建 B 类，并将自己设为 B 类的委托对象，同时给 B 类分配一个在协议中定义的任务。一旦 B 类完成任务，它会向 A 类报告。让我们来看一下在应用中是如何实现的。

生日列表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议定义一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将被添加生日视图控制器用来报告结果。

看一下图 11-6。当用户点击“添加”按钮 ➊ 时，生日列表视图控制器创建了添加生日视图控制器 ➋ 并将自己设为添加生日视图控制器的委托对象。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托机制从添加生日视图控制器传递到生日列表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，Add Birthday 视图控制器会调用这个方法 ➍ 并将新的生日传递给它的代理，即 Birthday 表格视图控制器。Birthday 表格视图控制器会接受这个生日，添加到它的 birthdays 数组中，然后重新加载它的表格视图 ➎ ，以便新生日能出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，包含方法 addBirthdayViewController(_:didAddBirthday:)，当用户在应用中添加生日时，AddBirthdayViewController 可以调用该方法。Birthday 表格视图控制器将实现该协议方法，这样当生日通过 Add Birthday 视图控制器添加时，AddBirthdayViewController 可以对其代理说：“嘿！刚有人添加了这个生日，”然后 Birthday 表格视图控制器就会听到消息，并回应：“哦！我会把它加到我的列表中，并刷新显示，让新生日显示出来。”

那么现在让我们在代码中实现这一点！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift* 文件中，*在* AddBirthdayViewController 类之上，添加定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处定义协议，通过键入关键字 protocol 然后是协议名称 AddBirthdayViewControllerDelegate。这个名字很长，但 Swift 程序员通常会以调用类的名字命名协议，并在后面加上 Delegate 这个词。这样，你就能通过协议的名称看出是哪个类在使用该协议。既然你现在是 Swift 程序员，你也应该遵循这种命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，用于将 Birthday 对象传递回代理类➋。注意，你在这个函数中包括了 AddBirthdayViewController 作为参数。再次强调，Swift 程序员在实现协议方法时，通常会这么做，你也应该保持这种做法。知道是谁发回了消息以及代理可以访问该对象及其类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递。很快你就会看到怎么做到这一点。另一个需要注意的点是外部参数名称 didAddBirthday。许多代理协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚做完的事情或将要做的事情。

现在你已经定义了协议，接下来需要告诉 Birthday 表格视图控制器采用这个协议并使用协议的方法。

##### 让生日表格视图控制器符合协议

为了采用该协议，Birthdays 表格视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中添加 AddBirthdayViewControllerDelegate，紧接在 UITableViewController 超类之后。在类的顶部，在 UITableViewController 后面加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做了，红色的错误提示就会出现。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心，我们很快就会修复这个问题。

这里需要特别注意的是，BirthdaysTableViewController 是在继承 UITableViewController 超类。一个类只能有一个超类，且超类名称必须写在所有协议之前。但尽管一个类只能有一个超类，它可以采用任意多个协议——这些协议会在超类之后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 `addBirthdayViewController(_:didAddBirthday:)` 方法。一个合适的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动补全功能会建议这个完整的方法声明。这是因为它知道这个类已经采用了 AddBirthdayViewControllerDelegate 协议，并且期望你添加这个方法。需要注意的是，与子类方法不同，你在 `addBirthdayViewController(_:didAddBirthday:)` 前不会使用 `override` 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的生日添加到 birthdays 数组中。你可以使用数组的 `append(_:)` 方法来完成这项工作 ➋。接下来，你需要刷新表格视图，以便它显示这个新添加的生日，通过调用 tableView 属性上的 `reloadData()` 方法 ➌。当 `reloadData()` 被调用时，表格视图的数据源方法会再次被调用，新增的生日将会显示在生日列表的底部。

你可能注意到，我们在方法上方添加了一个注释来标记这一部分：`// MARK: - AddBirthdayViewControllerDelegate ➊`。这并不是必需的，但这是良好的编码风格，可以标出类的不同部分，帮助保持代码清晰可读。注释的第一部分`MARK: -`是 Xcode 识别的特殊关键字，用于代码注释，它将`AddBirthdayViewControllerDelegate`部分添加到类顶部的下拉目录中，方便你使用。这个下拉菜单有助于你查找方法并跳转到代码中的不同位置。要使用这个菜单，只需点击编辑面板顶部的`Birthdays TableViewController`，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内建的目录，方便快速跳转到某个部分。*

##### 为添加生日视图控制器设置委托

`BirthdaysTableViewController`已经遵循了`AddBirthdayViewControllerDelegate`协议。现在是时候让添加生日视图控制器使用`AddBirthdayViewControllerDelegate`协议，告诉`Birthdays`表视图控制器它已添加了一个生日。为此，添加生日视图控制器首先需要定义一个委托。我们通过在`AddBirthdayViewController`类的出口下方添加一行代码，来为该类添加一个可选的委托属性，类型为`AddBirthdayViewControllerDelegate`：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在创建添加生日视图控制器之前，你无法设置它。你将很快学到如何设置委托。

现在，添加生日视图控制器有了委托，在`saveTapped(_:)`方法中，你可以通过`addBirthdayViewController(_:didAddBirthday:)`方法将生日对象传递给委托。将`saveTapped(_:)`方法更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象后，➊处的代码通过`addBirthdayViewController(_:didAddBirthday:)`方法将其传递回委托。

太棒了！你已经完成了对添加生日视图控制器的修改。现在它有了一个委托，能够监听生日保存的调用。运行应用程序，看看会发生什么。

嗯……没有太大变化。当你添加一个生日时，仍然看不到它出现在`Birthdays`表视图控制器中。怎么回事？

#### 通过设置委托连接这两个控制器

你还有一件事需要做。`Birthdays`表视图控制器是`AddBirthdayViewControllerDelegate`，而添加生日视图控制器有一个`AddBirthdayViewControllerDelegate`属性，它存储了与之通信的委托，用于在生日保存时进行交互。但我们从未明确将委托属性设置为`Birthdays`表视图控制器。所以，现在是时候将这两个视图控制器之间的通信管道连接起来了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个已经被注释掉的方法 prepare(for:sender:)。通过删除 /* 和 */ 注释符号，取消注释该方法。

每当 Birthdays 表格视图控制器放弃其屏幕并且应用程序通过 storyboard segue 过渡到另一个视图控制器时，都会自动调用此方法。我们将使用此方法将 Birthdays 表格视图控制器传递到 Add Birthday 视图控制器，以便将其自身设置为 Add Birthday 视图控制器的委托。请在 prepare(for:sender:) 方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的委托为 Birthdays 表格视图控制器只需要三行代码。首先，您需要能够通过 segue 参数获取到 AddBirthdayViewController 对象。Xcode 在注释中提供了如何做到这一点的提示。UIStoryboardSegue 有一个名为 destination 的属性，在这个方法中正在准备 segue 的另一端，但对于这个应用程序来说，destination 并不是 AddBirthdayViewController。

在第九章中，您将 Add Birthday 视图控制器嵌入到导航控制器中，以便拥有带有取消和保存按钮的导航栏。所以您不会期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是包含 Add Birthday 视图控制器的 UINavigationController。➊ 这一行代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定类型，因此我们需要通过 as 将其强制转换为 UINavigationController。

接下来，您可以获取 Add Birthday 视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其强制转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的一个特定子类。最后，当您拥有 AddBirthdayViewController 后，可以将其委托设置为 self，当前是 Birthdays 表格视图控制器 ➌。

现在运行应用程序并添加一些生日！您在 Birthdays 表格视图控制器中看到了什么？生日！生日！生日！不过我们还没完全结束。如果您退出应用程序然后重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中进行。

### 你学到了什么

在本章中，您学会了如何创建一个表格视图控制器来显示您的生日列表。您还学会了如何在 Add Birthday 视图控制器中添加生日，然后如何使用委托将生日添加到 Birthdays 表格视图控制器中的生日数组中，以便显示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，以便即使退出应用程序并重新启动，生日仍然能够显示。为了保存生日，你将使用我们在项目开始时就设置好的 Core Data。

现在，你已经在故事板中设置好了 Birthdays 表格视图控制器，下一步是创建表格中的单元格来显示每个生日。

#### 向表格视图添加单元格

每个生日将显示在 Birthdays 表格视图控制器中的一个 UITableViewCell 中。一个表格有按行和列组织的信息框，这些框被称为*单元格*。类似地，表格视图也有单元格，所有这些单元格都是 UITableViewCell 类的实例或其子类。我们将在表格视图中为每个生日创建一个单独的单元格。

我们将从在故事板中创建这些单元格开始，然后稍后用我们的生日对象填充它们。在左侧大纲菜单中，点击“Birthdays”旁的三角形，再点击“Table View”旁的三角形打开这些部分。然后选择**Table View Cell** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建一个副标题样式的表格视图单元格并设置其标识符*

接下来，打开属性检查器。在**Style**下拉菜单中，将单元格的样式设置为**Subtitle** ➋，这样单元格现在就有了一个标题标签和一个副标题标签。你将在标题中显示每个人的名字，在副标题中显示生日。

最后，在标识符字段中输入 birthdayCellIdentifier ➌。你稍后将使用这个标识符来填充单元格内容。

就这样！你已经完成了故事板中的工作。

你可能会想，为什么在我们的故事板中表格视图只有一个单元格，而在列表中我们会显示多个生日。如果你再看看图 11-4，你会注意到这个单元格被标记为*原型单元格*。这意味着你刚才自定义的单元格是你希望在表格视图中显示的所有单元格的*模板*。你为单元格设置的标识符就是你的代码告诉表格视图生成每个单元格的方式，之后你会看到它是如何工作的。

**处理日期**

Swift 有一种特殊的数据类型，叫做 Date，用于存储日期值。一个 Date 对象实际上是一个日期和时间。打开你的 playground 并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间分配给变量 today。当您打印 today 时，显示格式为 "2017-11-21 10:45:31 +0000\n"。如果您想让它显示为 Tuesday, November 21, 2017 呢？或者仅显示 11/21/17？要以特定方式显示日期，您需要使用 *日期格式化器*，即您创建的 DateFormatter 对象，并为其指定一个日期格式样式。DateFormatter 是一个辅助对象，用于从任何日期创建显示字符串，而 *日期格式样式* 是 DateFormatter 的一个属性，指示格式化器使用什么样式。您可以手动创建自己的日期格式样式，但 Swift 中也包含了现成的样式供您使用。将以下内容添加到您的 playground 中：

![](img/Image00240.jpg)

在 ➊ 中，您创建一个格式化器。然后，在 ➋ 中，您将格式化器的样式设置为 Style.full，它将打印星期几以及完整的月份名称、日期和年份。最后，您使用 DateFormatter 类的 string(from:) 方法 ➌ 从日期创建一个字符串。您可以看到，您现在已经将日期转换成了格式化良好的字符串 "Tuesday, November 21, 2017"。表 11-1 显示了从 Swift 中五种可用的 DateFormatter.Style 选项创建的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "Nov 21, 2017" |
| long | "November 21, 2017" |
| full | "Tuesday, November 21, 2017" |

您还可以使用 DateFormatter 的 dateFormat 属性指定自定义的日期显示方式。也许您只想显示月份和日期，或者您想在简短样式中显示四位数的年份。无论哪种方式，都非常简单，您甚至不需要创建一个新的 DateFormatter——只需更改 formatter 上的 dateFormat，然后请求一个新的字符串。将以下代码添加到您的 playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 中，您指定只想要 MM/dd 格式的月份和日期——即两位数的月份后跟两位数的日期。如果您想显示月份的三个字母，可以使用 MMM。如果要显示完整的月份名称，请使用 MMMM。在 ➋ 中，我们将日期格式更改为四位数的年份。两位数的年份使用 yy。以下是几种使用 dateFormat 来显示自定义日期字符串的方法。

![](img/Image00242.jpg)

如果您想包括分隔符，只需将它们添加到您的 dateFormat 字符串中。例如，如果您想使用句点作为分隔符，可以创建一个像 "MM.dd.yy" 这样的 dateFormat ➊。要显示缩写的星期几，请使用 EEE ➋。如果要显示完整的星期几，请使用 EEEE ➌。这只是一些例子。通过使用 M、d、y 和 E 的组合，您可以创建无数种显示日期的方式！

#### 设置生日表视图控制器

`BirthdaysTableViewController` 将显示一个包含所有存储在应用中的生日的列表。你记得用什么来存储一系列的项目吗？没错——数组！你将在 `BirthdaysTableViewController` 中创建一个数组来存储所有的生日。为此，在类的顶部，`viewDidLoad()` 方法上方，插入以下代码来添加一个名为 `birthdays` 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 `Birthday` 实例数组。它需要是一个变量，而不是常量，因为你希望每次用户通过“添加生日”视图控制器添加生日时，都将已保存的生日添加到这个数组中。你将在“使生日表视图控制器遵循协议”中看到如何操作，第 168 页有详细说明。

**注意**

*请记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

`BirthdaysTableViewController` 还需要一个 `dateFormatter` 属性来将出生日期显示为格式化的字符串。在 `birthdays` 数组下方添加一个 `dateFormatter`：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

注意，`dateFormatter` 是一个常量，是通过 `let` 创建的。尽管你会修改 `dateFormatter` 的属性，如 `dateStyle` 和 `timeStyle`，但你永远不会改变 `dateFormatter` 本身。

你还需要设置 `dateFormatter`，以便它将出生日期显示为完全格式化的字符串，如“Tuesday, December 17, 2008”。正如你在第十章中看到的，进行此设置的一个好地方是在 `viewDidLoad()` 方法中，该方法会在生日表视图控制器加载其视图时调用。这是进行任何必要设置的完美位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 `dateStyle`，使得 `dateFormatter` 可以为每个生日显示格式化的日期字符串。你注意到我们直接写了 `.full`，而不是 `DateFormatter.Style.full` 吗？Swift 知道 `dateStyle` 对应的类型是什么，所以允许我们使用这个小快捷方式。在 ➋ 处，你将 `dateFormatter` 的 `timeStyle` 设置为 `.none`，这样时间就不会显示。

#### 在表视图中显示生日

`BirthdaysTableViewController` 类有一个表视图，用来在单列中显示一个项目列表。表视图有一个或多个包含行的部分，每一行都包含一个单元格。表视图中的一个部分是行的分组，可以选择显示或不显示标题。一个展示有多个部分的表视图的应用示例是设置应用，如图 11-5 所示。它显示了一个行列表，这些行被分成了不同的部分。

表视图的每个区块和行都有一个索引号。这些数字从 0 开始，然后随着向下滚动表视图而增加 1。例如，设置应用中的隐私行位于区块 0，行 1。新闻设置位于区块 1，行 3。

在 `BirthdaysTableViewController` 类的中间，有一个名为 *Table view data source* 的部分，其中包含三个方法。表视图控制器使用这些方法来确定在其表视图中将显示什么内容。

`numberOfSections(in:)` 告诉表视图应该有多少个区块

`tableView(_:numberOfRowsInSection:)` 告诉表视图每个区块将显示多少行

`tableView(_:cellForRowAt:)` 设置每个将在表视图每一行中显示的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用区块来分组不同设备设置的行。*

表视图的数据源方法会在每次表视图重新加载时由表视图控制器调用。当你创建一个 `UITableViewController` 的子类时，Xcode 会自动为你提供这些方法的模板。你需要实现这三个方法，以确保应用正常工作，尽管你在代码中永远不会直接调用它们。`UITableViewController` 类实现了 `UITableViewDataSource` 协议，该协议包含这些数据源方法，用于确定表视图中将显示什么内容。我们将在 “代理模式” 第 166 页讨论协议。现在，你只需要知道，`UITableViewController` 使用这些方法来显示其内容，并且它会自动调用这些方法，所以你不需要手动调用它们。

让我们从 `numberOfSections(in:)` 方法开始。`Birthdays` 表视图控制器是一个仅展示生日实例的列表，因此不需要多个区块。为了设置表视图的区块数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 `tableView` 的 UITableView 参数，它是使用此类作为数据源的表视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内建的表视图，并且会自动连接到这些方法。每个生日都会显示在自己的行中。因此，在 `tableView(_:numberOfRowsInSection:)` 方法中，为了确保正确的行数来展示所有生日，你需要返回 `birthdays` 数组中生日实例的数量。你还记得数组的 `count` 属性吗？它是一个整数，表示数组中有多少个元素，非常适合这种情况！将此方法改为如下：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了`tableView`参数外，`tableView(_:numberOfRowsInSection:)`方法还接收一个名为`section`的`Int`类型参数。当表视图加载自身时，这个方法会为表视图中的每一部分调用。在我们的案例中，只有一个部分，所以我们不需要检查正在显示的是哪个部分。我们知道它是第零部分，并希望它包含与生日数目相等的行数，因此我们写`return birthdays.count`。

最后，你需要实现`tableView(_:cellForRowAt:)`方法，这样表视图才能知道在每个单元格中放入什么内容。由于这个方法被注释掉了，你需要删除围绕它的`/*`和`*/`，取消注释。（小心不要不小心取消注释后面的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法`tableView(_:cellForRowAt:)`。它会在表视图加载到屏幕时被调用。每个屏幕上的单元格都会调用此方法，并传入两个参数，`tableView`和`indexPath`。你已经知道`tableView`参数的作用。`IndexPath`是一个 Swift 结构体，用于表示表视图中某一行的位置。`IndexPath`实例包含`section`属性和`row`属性。由于这个方法会被多次调用（每次为表中的每一行），我们需要`indexPath`来知道当前正在配置的是哪个部分和哪一行。`indexPath.section`属性提供部分号，而`indexPath.row`则提供表视图单元格的行号。`tableView(_:cellForRowAt:)`方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个`UITableViewCell`

• 确定在`birthdays`数组中哪个生日将在单元格内显示

• 创建两个标签，在单元格中显示生日人的姓名和出生日期

• 返回准备好显示在表视图中的单元格

让我们逐行分析这段代码。

首先，创建一个`UITableViewCell`。代码➊使用方法`dequeueReusableCell(withIdentifier:for:)`来实现这一点。不过，在你开始使用这个方法之前，你需要告诉它从故事板中使用哪个单元格。之前在故事板中，你为单元格设置了标识符`birthdayCellIdentifier`（参见图 11-4）。这个标识符将你的代码与单元格关联起来，告诉方法它正在使用正确的单元格。调用这个方法时使用的字符串必须与在故事板中设置的字符串完全一致，否则你会得到错误，应用程序在运行时会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:) 中，你注意到 *Reusable Cell* 这个词了吗？表视图中的单元格是一次性创建的，然后可以反复使用。这有助于加速运行，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日，但是一次只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以查看更多生日时，滚出屏幕顶部的单元格会被重用。它们会被填充新信息，并重新出现在屏幕底部。UITableView 会自动完成这项工作。当表视图加载时，tableView(_:cellForRowAt:) 会为每个可见的行调用一次。当用户滚动查看更多单元格时，方法会再次被调用，每次当该行即将出现在屏幕上时。

接下来，我们需要找出应当在单元格内显示的生日。我们希望在每一行中显示一个来自生日数组（birthdays）中的生日。第一个生日，位于 birthdays[0]，应显示在第 0 行。第二个生日，位于 birthdays[1]，应显示在第 1 行，以此类推，这意味着 indexPath 的行号与我们想要访问的生日数组中的位置相同。➋处的代码通过使用 indexPath.row 来访问生日数组中的正确生日对象。一旦我们得到了正确的生日对象，我们将其分配给一个名为 birthday 的常量，以便在该单元格中设置标签。

请注意，我们使用 let 将生日赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并为其分配了对应的生日对象。由于我们不会修改这些生日常量——我们只是读取它们的属性——所以我们不需要将它们设为变量。

现在你已经有了单元格和生日信息，是时候填写细节了。你需要为每个单元格添加两个标签，一个显示生日人的姓名，另一个显示生日日期。你将单元格的样式设置为副标题（Subtitle），这样它就有了标题（Title）标签和副标题（Subtitle）标签。每个单元格已经包含了这些标签，因此现在你不需要自己创建标签了。

这些标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 拼接成的字符串，中间以空格分隔。➍ 处，你使用 dateFormatter 的 string(from:) 方法将生日日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 在 ➎ 返回该单元格，以便它能够在表视图的该 indexPath 位置显示出来。

### 将所有内容整合在一起

现在，你可以使用添加生日视图控制器向应用中添加生日实例，并且你有一个表视图来列出每个生日，这些生日会显示在生日表视图控制器中。但当你尝试运行应用并添加生日时，它并没有显示出来。为了让你添加的每个生日出现在表视图中，你需要让添加生日视图控制器与生日表视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 显示在自己之上。A 知道 B 的存在，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但是 B 并不知道 A——它刚刚被创建出来，不知道自己是从哪里来的或怎么到达那里的。那么，B 怎么能与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项工作或任务交给另一个人。*委托人*就像一个老板，告诉委派的员工该做什么。当委派的员工完成任务时，有时他们会向委托人报告信息。

在 Swift 中，委托的概念非常相似，但我们不是老板和员工的关系，而是委托对象和被委托对象的关系。由于类 B 是被类 A 告知该做什么的对象，它是被委托对象。我们给类 B 一个特殊的属性叫做委托（delegate），用来告诉它谁是它的委托对象——这样它就知道要与谁进行通信。委托对象可以是任何具有在*协议*中定义的一组方法的类。协议就像是两者之间的一个约定，告诉它们委托对象可以要求被委托对象做什么。协议中列出了委托对象可以与被委托对象一起使用的方法和属性名称。

类 A 创建类 B，将自己设为类 B 的委托，并给类 B 安排一个协议中的任务。一旦类 B 完成了任务，它就会向类 A 报告。让我们看看这个在我们的应用中是如何工作的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议添加一个方法：addBirthdayViewController(_:didAddBirthday:)，该方法将用于添加生日视图控制器向我们报告结果。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器创建了添加生日视图控制器 ➋ 并将自己设置为该视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议定义了一个方法 addBirthdayViewController(_:didAddBirthday:) 。当用户点击保存 ➌ 时，Add Birthday 视图控制器会调用这个方法 ➍ 并将新的生日传递给它的委托，Birthdays 表格视图控制器。Birthdays 表格视图控制器会将该生日添加到它的 birthdays 数组中，然后重新加载它的表格视图 ➎ ，以便新生日出现在表格中。

我们将向你展示如何创建一个名为 AddBirthdayViewControllerDelegate 的协议，其中包含方法 addBirthdayViewController(_:didAddBirthday:)，该方法会在每次添加生日到应用时被 Add Birthday 视图控制器调用。Birthdays 表格视图控制器将实现该协议方法，这样每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器只需要对其委托说：“嘿！有人刚刚添加了这个生日”，然后 Birthdays 表格视图控制器会收到消息并回应：“哦！我会把它添加到我的列表中并刷新显示，让新的生日出现。”

现在让我们来写代码吧！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方*，添加定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过在 ➊ 处输入关键字 protocol 并跟上协议名称 AddBirthdayViewControllerDelegate 来定义协议。这个名字比较长，但 Swift 程序员通常会以调用类的名称命名协议，并在后面加上 Delegate 这个词。这样，你就能通过协议的名称看出是哪个类在使用这个协议。既然你现在是 Swift 程序员，你也应该使用相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传递回委托类 ➋ 。请注意，在这个函数中你将 AddBirthdayViewController 作为一个参数包含在内。Swift 程序员通常会遵循这种约定来实现协议方法，所以你也应该这样做。这样做有助于知道是谁发送了消息，以及委托可以访问那个对象和它的类。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递。你很快就会看到这是如何实现的。另一个需要注意的点是外部参数名 didAddBirthday 。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚做了什么或者将要做什么。

现在你已经定义了协议，接下来需要告诉 Birthdays 表格视图控制器遵循这个协议并使用协议的方法。

##### 让 Birthdays 表格视图控制器遵循协议

要采用这个协议，`BirthdaysTableViewController` 需要将自己声明为 `AddBirthdayViewControllerDelegate`。为此，你需要在类定义中，紧跟在 `UITableViewController` 父类之后，添加 `AddBirthdayViewControllerDelegate`。在类的顶部，在 `UITableViewController` 后添加一个逗号，然后输入 `AddBirthdayViewControllerDelegate`：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色错误提示就会出现。这是因为 `BirthdaysTableViewController` 声明自己是 `AddBirthdayViewControllerDelegate`，但它还没有实现这个协议！为了实现这个协议，它需要实现 `AddBirthdayViewControllerDelegate` 协议定义。别担心——我们很快就会解决这个问题。

在这里需要注意的是，`BirthdaysTableViewController` 是从 `UITableViewController` 类派生的。一个类只能有一个父类，且父类名必须写在任何协议之前。但虽然一个类只能有一个父类，它可以采用任意多个协议——这些协议会在父类后列出，并用逗号分隔。

现在，为了符合 `AddBirthdayViewControllerDelegate` 协议并修复错误，我们需要将 `addBirthdayViewController(_:didAddBirthday:)` 方法添加到 `BirthdaysTableViewController` 中。一个好的位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它预期你会添加这个方法。请注意，与子类化的方法不同，你在 `addBirthdayViewController(_:didAddBirthday:)` 前不需要使用 override 关键字，因为没有原始的方法需要被覆盖。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递进来的生日添加到 `birthdays` 数组中。你可以使用数组的 `append(_:)` 方法来完成这一操作 ➋。接下来，你需要刷新表格视图，以便它显示这个新添加的生日，可以通过调用 `reloadData()` 方法来刷新 `tableView` 属性 ➌。当 `reloadData()` 被调用时，表格视图的数据源方法会重新被调用，新增的生日会显示在生日列表的底部。

你可能注意到，我们在方法上方添加了一条注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但良好的编码风格是将类的不同部分标记出来，这有助于保持代码清晰和易读。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，供你在类顶部使用。这个下拉菜单帮助你快速找到方法并跳转到代码的不同部分。要使用这个菜单，请点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类内置了一个目录，方便快速跳转到某个章节。*

##### 为添加生日视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议，告知 Birthdays 表格视图控制器已添加一个生日。为此，添加生日视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性来实现这一点，代码如下：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为直到*添加生日视图控制器*创建之后，你才能设置它。稍后你将了解在哪里设置代理。

现在添加生日视图控制器已经有了代理，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将生日对象传递给代理。将 saveTapped(_:)修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码在➊处通过 addBirthdayViewController(_:didAddBirthday:)方法将其传递回代理。

太好了！你已经完成了对添加生日视图控制器的修改。它现在有了一个代理，能够监听生日已保存的调用。运行应用查看效果吧。

嗯……没有太大变化。当你添加一个生日时，你仍然看不到它出现在 Birthdays 表格视图控制器中。到底怎么回事？

#### 通过设置代理连接两个控制器

还有一件事必须做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存它与之通信的代理。当生日被保存时，它与代理进行通信。但我们从未明确将代理属性设置为 Birthdays 表格视图控制器。所以现在是时候将这两个视图控制器之间的通信管道连接起来了。

在 **BirthdaysTableViewController** 类的导航部分，有一个被注释掉的方法叫做 `prepare(for:sender:)`。通过删除 /* 和 */ 来取消注释这个方法。

每当**生日表格视图控制器**放弃其屏幕并且应用通过故事板 segue 切换到另一个视图控制器时，这个方法会被自动调用。我们将使用这个方法将生日表格视图控制器传递给“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的委托。请在 `prepare(for:sender:)` 方法中写下以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码就能将“添加生日”视图控制器的委托设置为生日表格视图控制器。首先，你需要能够从 segue 参数中访问到 AddBirthdayViewController 对象。Xcode 已经在代码中留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 在该方法中正准备的 segue 的另一端有一个名为 `destination` 的属性，但对于这个应用来说，`destination` 并不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到了一个导航控制器中，以便你可以有一个带有取消和保存按钮的导航栏。所以你不会期望在 segue 的另一端找到“添加生日”视图控制器。相反，`destination` 是一个包含“添加生日”视图控制器的 `UINavigationController`。➊ 这一行代码获取了 `navigationController`。`segue.destination` 会返回一个 UIViewController，但由于我们的 `navigationController` 是一种特定类型的视图控制器，因此我们需要使用 `as` 将其强制转换为 `UINavigationController`。

接下来，你可以通过 navigationController 的 `topViewController` 获取“添加生日”视图控制器 ➋。`topViewController` 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，所以必须将其强制转换为 AddBirthdayViewController，以指明该控制器是 UIViewController 的特定子类。最后，当你得到了 AddBirthdayViewController，你可以将委托设置为 `self`，此时 `self` 就是生日表格视图控制器 ➌。

现在运行应用并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用然后重新运行，之前添加的生日将会消失。我们仍然需要将生日保存到设备中，我们将在第十二章中实现这一功能。

### 你学到了什么

在本章中，你学会了如何创建一个表格视图控制器来展示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加生日，然后如何使用委托将生日添加到生日表格视图控制器中的生日数组，从而让它显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用并重新运行，它们也会显示出来。为了保存生日信息，你将使用 Core Data，这是我们在项目开始时设置的。

#### 向表视图添加单元格

每个生日将在“生日”表视图控制器的 UITableViewCell 中显示。表格由按行和列排列的信息框组成，这些框被称为*单元格*。类似地，表视图也有单元格，所有单元格都是 UITableViewCell 类的实例或其子类。我们将在表视图中为每个生日创建一个单独的单元格。

我们将从在故事板中创建这些单元格开始，然后稍后再用我们的生日对象填充它们。在左侧大纲菜单中，点击“生日”旁边的三角形，然后点击“表格视图”旁边的三角形以展开这些部分。然后选择**表格视图单元格** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建副标题样式的表视图单元格并设置其标识符*

接下来，打开属性检查器。通过**样式**下拉菜单，将单元格样式设置为**副标题** ➋，这样单元格就会有一个标题标签和一个副标题标签。你将把每个人的名字显示在标题中，生日显示在副标题中。

最后，在标识符字段中输入 birthdayCellIdentifier ➌。你稍后将在填充单元格内容时使用这个标识符。

就是这样！你已经完成了故事板中的工作。

你可能会想，为什么我们在故事板中的表视图里只有一个单元格，而在列表中会有多个生日要显示。如果你再次查看图 11-4，你会注意到这个单元格标记为*原型单元格*。这意味着你刚刚自定义的单元格是所有你希望出现在表视图中的单元格的*模板*。你为单元格设置的标识符将告诉你的代码如何让表视图为你生成每个单元格，以便填充生日信息。你很快就会看到这个是如何工作的。

**处理日期**

Swift 有一种特殊的数据类型，叫做 Date，用于存储日期值。Date 对象实际上包含日期和时间。打开你的 playground，并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量 today。当你打印 today 时，它的格式为 "2017-11-21 10:45:31 +0000\n"。如果你希望它以 Tuesday, November 21, 2017 的格式显示呢？或者只显示 11/21/17？要以特定方式显示日期，你需要使用 *日期格式化器*，它是你创建并指定日期格式样式的 DateFormatter 对象。DateFormatter 是一个帮助对象，用于从任何日期创建显示字符串，*日期格式样式* 是 DateFormatter 的一个属性，用来告诉格式化器使用哪种样式。你可以手动创建自己的日期格式样式，但 Swift 中也提供了可直接使用的样式。将以下内容添加到你的 playground 中：

![](img/Image00240.jpg)

在 ➊ 处你创建了一个格式化器。然后在 ➋ 处，你将格式化器的样式设置为 Style.full，这将打印出星期几以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:) 方法 ➌ 从日期创建字符串。你可以看到，你已经将日期转化为格式良好的字符串 "2017 年 11 月 21 日，星期二"。表 11-1 显示了从 Swift 中可用的五个 DateFormatter.Style 选项生成的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "2017 年 11 月 21 日" |
| long | "2017 年 11 月 21 日" |
| full | "2017 年 11 月 21 日，星期二" |

你还可以使用 DateFormatter 的 dateFormat 属性来指定自定义的日期显示方式。也许你只想显示月份和日期，或者你想以短格式显示四位数字的年份。做这些都很简单，你甚至不需要创建一个新的 DateFormatter——你只需更改格式化器上的 dateFormat，然后请求它返回一个新的字符串。将以下代码添加到你的 playground 中，以显示特定格式的日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定只需要以 MM/dd 格式显示月份和日期——即两位数字的月份后跟两位数字的日期。如果你希望以三个字母显示月份，可以使用 MMM。如果想显示完整的月份名称，则使用 MMMM。在 ➋ 处，我们将日期格式更改为使用四位数字的年份。两位数字的年份则是 yy。以下是一些其他使用日期格式来显示自定义日期字符串的方法。

![](img/Image00242.jpg)

如果你想包含分隔符，可以将它们添加到你的 dateFormat 字符串中。例如，如果你想要使用句点作为分隔符，可以创建一个像 "MM.dd.yy" 这样的 dateFormat ➊。要显示缩写的星期几，请使用 EEE ➋。如果要显示完整的星期几，请使用 EEEE ➌。这些只是一些示例。通过组合 M、d、y 和 E，你可以用无数种方式来显示日期！

#### 设置生日表格视图控制器

Birthdays 表格视图控制器将显示存储在应用中的所有生日列表。你记得用什么来存储一组项目吗？没错——数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有的生日。为此，给 BirthdaysTableViewController 添加一个名为 birthdays 的属性，它是一个 Birthday 对象的数组。在类的顶部，viewDidLoad()方法上方，插入以下代码来添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这行代码创建了一个空的 Birthday 实例数组。它需要是一个变量而不是常量，因为你希望每次用户通过添加生日视图控制器添加一个生日时，将已保存的 Birthday 添加到这个数组中。你将在“使 Birthdays 表格视图控制器符合协议”中看到如何做到这一点，第 168 页会有详细说明。

**注意**

*记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *获取。*

BirthdaysTableViewController 还需要一个日期格式化器属性，用于将出生日期显示为格式化好的字符串。在 birthdays 数组下面添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

注意，dateFormatter 是一个用 let 创建的常量。尽管你会更改 dateFormatter 的属性，如 dateStyle 和 timeStyle，但你永远不会改变 dateFormatter 本身。

你还需要设置日期格式化器，以便它将出生日期显示为完整格式的字符串，如“星期二，2008 年 12 月 17 日”。正如你在第十章中看到的，设置日期格式化器的好时机是在 viewDidLoad()方法中，该方法在 Birthdays 表格视图控制器加载视图时被调用。这里是进行任何类设置的理想位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在➊处，你设置了 dateFormatter 的 dateStyle，使其为每个 Birthday 显示一个格式化的日期字符串。你注意到我们只是写了.full，而不是 DateFormatter.Style.full 吗？Swift 知道 dateFormatter 的 dateStyle 应该是什么类型，所以它允许我们使用这个小技巧。在➋处，你将 dateFormatter 的 timeStyle 设置为.none，这样时间就不会显示出来。

#### 在表格视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于在单列中显示项目列表。表格视图包含一个或多个包含行的部分，每行包含一个单元格。表格视图中的部分是行的分组，可以带有或不带有标题。一个显示有多个部分的表格视图的应用示例是设置应用，如图 11-5 所示。它显示了一个被划分为不同部分的行列表。

表格视图的每个节和行都有一个索引号进行标识。这些数字从 0 开始，然后随着你向下浏览表格视图逐渐增加。例如，设置应用中的“隐私”项位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为 *Table view data source* 的部分，包含三个方法。表格视图控制器使用这些方法来决定在表格视图中显示什么内容。

numberOfSections(in:) 告诉表格视图应该有多少个节

tableView(_:numberOfRowsInSection:) 告诉表格视图每个节中将显示多少行

tableView(_:cellForRowAt:) 设置将要在表格视图的每一行中显示的每个单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用节来对不同的设备设置进行分组。*

每次表格视图重新加载时，表格视图控制器都会调用表格视图数据源方法。当你创建一个 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现这三个方法，才能使应用正常工作，即使你在代码中永远不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，其中包含这些数据源方法，用于确定表格视图中将显示的内容。我们将在 “委托” 第 166 页讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，你无需手动调用它们。

让我们从方法 numberOfSections(in:) 开始。Birthdays 表格视图控制器是一个仅显示生日实例的列表，因此它不需要多个节。为了设置表格视图中的节数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 tableView 的 UITableView 作为参数，它是使用这个类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 内建了一个自动连接到这些方法的表格视图。每个生日将显示在自己的行中。因此，在 tableView(_:numberOfRowsInSection:) 中，为了显示所有生日的正确行数，你需要返回在 birthdays 数组中拥有的 Birthday 实例的数量。你记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少个项目，非常适合这个情况！将这个方法修改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了`tableView`参数外，`tableView(_:numberOfRowsInSection:)`还接受一个名为`section`的 Int 类型。当表格视图加载时，该方法会针对表格视图中的每个部分被调用。在我们的例子中，我们只有一个部分，因此不需要检查哪个部分的表格视图正在显示。我们知道是第零部分，并且希望它的行数与生日的数量相同，所以我们写`return birthdays.count`。

最后，你需要实现`tableView(_:cellForRowAt:)`，以便表格视图知道在每个单元格中显示什么内容。由于此方法已被注释掉，你需要通过删除/*和*/来取消注释它。（小心不要不小心取消注释它后面的其他方法！）完成这一步后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要手动调用`tableView(_:cellForRowAt:)`方法。它会在表格视图加载到屏幕上时自动调用。它会为每个屏幕上的单元格调用，并且接受两个参数，`tableView`和`indexPath`。你已经知道`tableView`参数的作用。`IndexPath`是一个 Swift 结构体，用于表示表格视图中行的位置。`IndexPath`实例有`section`属性和`row`属性。由于这个方法会被调用多次（每次针对表格中的一行），我们需要`indexPath`来知道我们当前正在配置的是哪个部分和行。`indexPath.section`属性提供部分号，`indexPath.row`提供表格视图单元格的行号。`tableView(_:cellForRowAt:)`方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定要在单元格中显示的生日数组中的哪一项

• 创建两个标签以显示生日人物的姓名和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。在➊处的代码使用了方法`dequeueReusableCell(withIdentifier:for:)`来实现这一点。不过，在你开始使用该方法之前，需要告诉方法从故事板中使用哪个单元格。早些时候，在故事板中，你为单元格指定了标识符 birthdayCellIdentifier（见图 11-4）。这个标识符将你的代码与单元格关联，并告知方法它正在使用正确的单元格。调用该方法时的字符串必须与在故事板中设置的字符串完全相同，否则会出现错误，应用程序在运行时会崩溃。

在`dequeueReusableCell(withIdentifier:for:)`方法中，你注意到*Reusable Cell*这个词了吗？表格视图中的单元格只会创建一次，然后可以反复使用。这有助于提高运行速度和流畅度，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但屏幕一次只能显示 10 个，那么你只需要 10 个单元格来展示这些生日。当你向下滚动以显示更多生日时，屏幕上方滚动出去的单元格会被重复使用。它们会被填充上新的信息，并再次出现在屏幕的下方。`UITableView`会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)`会为每一行可见的单元格被调用。当用户滚动查看更多单元格时，每一行在即将出现在屏幕上时会再次被调用。

接下来，我们需要找出应该在单元格内显示的生日。我们希望在每一行中显示一个生日，来自`birthdays`数组。第一个生日，位于`birthdays[0]`，应该显示在第 0 行。第二个生日，位于`birthdays[1]`，应该显示在第 1 行，以此类推，这意味着`indexPath`的行号与我们要访问的`birthdays`数组中的位置相同。➋处的代码通过使用`indexPath.row`访问`birthdays`数组中的正确生日对象。获取到正确的生日对象后，我们将其赋值给一个名为`birthday`的常量，以便设置单元格中的标签。

请注意，我们使用`let`将生日赋值给常量，而不是变量。我们可以使用`let`，因为每次`tableView(_:cellForRowAt:)`被调用时，都会创建一个新的生日常量。每个单元格都会拥有自己的生日常量，并且赋值为自己的`Birthday`对象。由于我们不会修改任何生日常量——我们只是读取它们的属性——所以我们不想把它们设为变量。

现在你已经有了单元格和生日，是时候填充细节了。每个单元格需要两个标签来显示生日人的姓名和出生日期。你将单元格设置为`Subtitle`样式，这样它就有了一个`Title`标签和一个`Subtitle`标签。每个单元格已经包含了这些标签，因此你现在不需要自己创建标签了。

标签作为`UITableViewCell`的属性存在，分别叫做`textLabel`和`detailTextLabel`。➌处的代码将`textLabel`的文本设置为由生日的`firstName`和`lastName`组成的字符串，中间用一个空格分隔。在➍处，你使用`dateFormatter`的`string(from:)`方法在`detailTextLabel`中显示出生日期。

当你的单元格完全配置好后，`tableView(_:cellForRowAt:)`会在➎处返回单元格，以便它可以在表格视图的该`indexPath`位置显示。

### 综合总结

现在，你可以使用添加生日视图控制器向应用程序添加生日实例，并且你有一个表视图来列出每个生日在生日表视图控制器中。但是，当你尝试运行应用并添加生日时，它并没有显示出来。为了让你添加的每个生日都出现在表视图中，你需要让添加生日视图控制器与生日表视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 展示在自己之上。A 知道 B，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但 B 不知道 A——它刚刚被创建出来，并不知道自己是从哪里来的，或者是如何来到这里的。那么 B 怎么能与 A 沟通呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项工作或任务交给别人。*委托人*就像是老板，告诉被委托的员工该做什么。当被委托的员工完成任务后，有时会将信息反馈给委托的老板。

在 Swift 中，委托的概念非常相似，但我们不是有老板和员工，而是有委托对象和被委托对象。因为是类 A 告诉类 B 该做什么，所以类 A 是被委托的对象。我们给类 B 一个特殊的属性叫做委托，用来告诉它委托对象是谁——这样它就知道该与谁沟通。委托可以是任何实现了*协议*中方法的类。协议就像是两个类之间的协议，告诉它们委托可以要求被委托对象做什么。它有一个方法和属性名称的列表，委托可以使用这些方法与被委托对象进行交互。

类 A 创建类 B，设置自己为类 B 的委托，并给类 B 一个在协议中定义的任务。一旦类 B 完成任务，它会向类 A 报告。让我们看看这个在我们的应用中是如何工作的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用来进行反馈。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器创建了添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，Add Birthday 视图控制器会调用此方法 ➍ 并将新的生日传递给它的代理，Birthdays 表格视图控制器。Birthdays 表格视图控制器接收这个生日，将其添加到它的 birthdays 数组中，然后重新加载它的表格视图 ➎，以便新的生日能够显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义一个方法 addBirthdayViewController(_:didAddBirthday:)，每当一个生日被添加到应用时，Add Birthday 视图控制器就会调用这个方法。Birthdays 表格视图控制器将实现该协议方法，以便每当通过 Add Birthday 视图控制器添加一个生日时，Add Birthday 视图控制器可以对其代理说：“嘿！有人刚刚添加了这个生日”，而 Birthdays 表格视图控制器会收到这个消息并回应：“哦！我会把它添加到我的列表中，并刷新我的显示，以便新的生日能显示出来。”

现在，让我们在代码中实现它！

##### 创建一个协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，*在* AddBirthdayViewController 类的上方，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过键入关键字 protocol 并跟上协议名 AddBirthdayViewControllerDelegate 来定义协议 ➊。这个名字有点长，但 Swift 程序员通常会用调用类的名字命名协议，并在后面加上 Delegate 这个词。这样你就可以通过协议的名字知道哪个类在使用这个协议。既然你现在是 Swift 程序员，你应该遵循同样的命名惯例。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，用于将 Birthday 对象传递回代理类 ➋。注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员在实现协议方法时通常会这么做，所以你也应该遵循这个惯例。知道是谁发送回消息，以及让代理可以访问该对象及其类是很有用的。

当 Add Birthday 视图控制器调用此方法时，它会将自己作为 addBirthdayViewController 参数传入。你很快就会看到这怎么做。另一个需要注意的是外部参数名 didAddBirthday。许多代理协议方法包含 *did* 和 *will* 这两个词，因为它们用于描述调用类已经做了或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表格视图控制器去采用这个协议，并使用协议的方法。

##### 使 Birthdays 表格视图控制器符合协议

为了采纳这个协议，Birthdays table view controller 需要使自己成为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中将 AddBirthdayViewControllerDelegate 添加到 UITableViewController 超类后面。在类的顶部，紧跟 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色错误就会出现。这是因为 BirthdaysTableViewController 声明自己是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会修复这个问题。

这里需要特别注意的是，BirthdaysTableViewController 是在子类化 UITableViewController 超类。一个类只能有一个超类，且超类名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采纳任意多个协议——这些协议都会列在超类之后，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要向 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个好的添加位置是在类的末尾，紧接着导航部分：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动补全会建议这个完整的方法声明。这是因为它知道这个类采纳了 AddBirthdayViewController Delegate 协议，并且期待你添加这个方法。请注意，与子类方法不同，你在 addBirthdayViewController(_:didAddBirthday:) 方法前不需要使用 override 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传入的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现这一点 ➋。接下来，你需要刷新表格视图，以便它显示这个新添加的生日，方法是调用 tableView 属性的 reloadData() 方法 ➌。当调用 reloadData() 方法时，表格视图的数据源方法会再次被调用，新增的生日会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但标记类的不同部分是一个好的编码风格，这有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的一个特殊关键词，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单可以帮助你找到方法，并让你跳转到代码的不同位置。要使用这个菜单，只需点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个章节。*

##### 给“添加生日”视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让“添加生日”视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知生日表视图控制器它已经添加了一个生日。为此，“添加生日”视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个可选的 AddBirthdayViewControllerDelegate 类型的代理属性来安排此事，将以下代码插入到 outlets 下方：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是一个可选类型，因为你不能在“添加生日”视图控制器创建之前设置它。你将很快了解在哪里设置代理。

现在，“添加生日”视图控制器有了代理，在 saveTapped(_:)方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:)方法将一个生日传递给代理。将 saveTapped(_:)方法修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，代码➊通过 addBirthdayViewController(_:didAddBirthday:)将其传递给代理。

太好了！你已经完成了对“添加生日”视图控制器的修改。现在，它有了一个代理，将监听生日保存的调用。运行应用程序看看会发生什么。

嗯……变化不大。当你添加一个生日时，你仍然看不到它出现在生日表视图控制器中。怎么回事？

#### 通过设置代理连接这两个控制器

还有最后一件事需要做。生日表视图控制器是一个 AddBirthdayViewControllerDelegate，而“添加生日”视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来存储它在生日保存时与之通讯的代理。但我们从未明确将代理属性设置为生日表视图控制器。所以现在是时候连接这两个视图控制器之间的通讯管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法 prepare(for:sender:)，通过删除包围它的 /* 和 */ 来取消注释这个方法。

每当 Birthdays 表格视图控制器放弃其屏幕并且应用程序通过 storyboard segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将 Birthdays 表格视图控制器传递给 Add Birthday 视图控制器，以便设置自身为 Add Birthday 视图控制器的委托。请在 prepare(for:sender:) 方法中写下以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的委托为 Birthdays 表格视图控制器只需要三行代码。首先，你需要能够通过 segue 参数访问到 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何做到这一点。一个 UIStoryboardSegue 有一个叫做 destination 的属性，位于正在准备中的 segue 的另一端，但对于这个应用来说，destination 不是 AddBirthdayViewController。

在 第九章 中，你将 Add Birthday 视图控制器嵌入到一个导航控制器中，以便可以拥有带有取消和保存按钮的导航栏。因此，你不指望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊ 这一行获取了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 ViewController 的一个特定类型，我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其强制转换为 AddBirthdayViewController，以指明该控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 后，你可以将委托设置为 self，即当前的 Birthdays 表格视图控制器 ➌。

现在运行应用并添加一些生日！你在 Birthdays 表格视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用并再次运行，之前的生日会消失。我们还需要将生日保存到设备中，我们将在 第十二章 中完成这个工作。

### 你学到了什么

在本章中，你学习了如何创建一个表格视图控制器来显示生日列表。你还学习了如何在 Add Birthday 视图控制器中添加生日，然后如何通过使用委托将生日添加到 Birthdays 表格视图控制器中的生日数组中，以便能够显示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使你退出应用并再次运行它，生日仍然会显示出来。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

每个生日将显示在生日表视图控制器中的 UITableViewCell 中。表格由按行和列组织的框组成，这些框包含信息。这些框被称为*单元格*。类似地，表视图也有单元格，它们都是 UITableViewCell 类的实例或子类。我们将把每个生日放到表视图中的一个单独单元格里。

我们将首先在 Storyboard 中创建这些单元格，然后稍后用我们的生日对象填充它们。在左侧的大纲菜单中，点击生日旁边的三角形，然后点击表视图旁边的三角形以展开这些部分。然后选择**Table View Cell** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建一个 Subtitle 样式的表视图单元格并设置其标识符*

接下来，打开 Attributes Inspector。在**Style**下拉菜单中，将单元格的样式设置为**Subtitle** ➋，这样单元格现在就会有一个 Title 标签和一个 Subtitle 标签。你将把每个人的名字显示在 Title 中，把生日显示在 Subtitle 中。

最后，在 Identifier 字段中输入 birthdayCellIdentifier ➌。你将在稍后使用这个标识符来填充单元格内容。

就这样！你已经完成了在 Storyboard 中的工作。

你可能会想，为什么我们在 Storyboard 中的表视图里只有一个单元格，而列表中实际上会显示多个生日。如果你再次查看图 11-4，你会注意到单元格标记为*原型单元格*。这意味着你刚刚自定义的单元格是所有你希望出现在表视图中的单元格的*模板*。你给单元格指定的标识符就是代码告诉表视图为你生成每个单元格并填充生日内容的方式。你很快就会看到它是如何工作的。

**处理日期**

Swift 有一种特殊的数据类型，叫做 Date，它用于存储日期值。一个 Date 对象实际上包含日期和时间。打开你的 Playground 并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量 today。当你打印 today 时，它的格式是 "2017-11-21 10:45:31 +0000\n"。如果你想让它显示为 "2017 年 11 月 21 日，星期二"？或者只是 "11/21/17" 呢？要以特定方式显示日期，你需要使用 *日期格式化器*，它是一个 DateFormatter 对象，你可以创建并为其指定日期格式样式。DateFormatter 是一个帮助对象，用于从任何日期创建显示字符串，而 *日期格式样式* 是 DateFormatter 的一个属性，指示格式化器使用哪种样式。你可以手动创建自己的日期格式样式，但 Swift 中也有一些内置的样式可以直接使用。将以下内容添加到你的 Playground 中：

![](img/Image00240.jpg)

在 ➊ 处，你创建了一个格式化器。然后，在 ➋ 处，你将格式化器的样式设置为 Style.full，它将显示星期几以及完整的月份名称、日期和年份。最后，使用 DateFormatter 类的 string(from:) 方法 ➌ 从日期创建一个字符串。你可以看到，日期现在已经变成了格式化良好的字符串 "2017 年 11 月 21 日，星期二"。表 11-1 展示了 Swift 中五种 DateFormatter.Style 选项所创建的不同字符串。

**表 11-1:** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "2017 年 11 月 21 日" |
| long | "2017 年 11 月 21 日" |
| full | "2017 年 11 月 21 日，星期二" |

你还可以使用 DateFormatter 的 dateFormat 属性指定自己自定义的日期显示方式。也许你只想要显示月份和日期，或者你希望年份以四位数的短格式显示。完成这些操作非常简单，你甚至不需要创建一个新的 DateFormatter——你只需改变格式化器上的 dateFormat，然后请求它返回一个新的字符串。将以下代码添加到你的 Playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定只需要以 MM/dd 格式显示月份和日期——即两位数字的月份后跟两位数字的日期。如果你希望显示月份的三个字母，可以使用 MMM。如果要显示月份的全名，使用 MMMM。在 ➋ 处，我们将日期格式更改为使用四位数的年份。两位数的年份为 yy。以下是使用 dateFormat 显示自定义日期字符串的几种方式。

![](img/Image00242.jpg)

如果你想包含分隔符，只需将它们添加到你的 dateFormat 字符串中。例如，如果你希望使用句点作为分隔符，可以创建一个像 "MM.dd.yy" 这样的 dateFormat ➊。要显示缩写版的星期几，可以使用 EEE ➋。要显示完整的星期几，可以使用 EEEE ➌。这只是其中的一些例子。通过组合 M、d、y 和 E，你可以得到无数种显示日期的方式！

#### 设置生日表视图控制器

生日表视图控制器将显示存储在应用中的所有生日的列表。你还记得用什么来存储一组项目吗？没错—数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有的生日。为此，给 BirthdaysTableViewController 添加一个名为 birthdays 的属性，类型为生日对象的数组。在类的顶部，紧接着 viewDidLoad()方法之前，插入这一行来添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的生日实例数组。它需要是一个变量而不是常量，因为每次用户通过“添加生日”视图控制器添加生日时，你需要将一个保存的生日添加到这个数组中。你将在《让生日表视图控制器遵循协议》一节和第 168 页中看到如何做到这一点。

**注意**

*记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

生日表视图控制器还需要一个日期格式化器属性，以便将生日日期显示为格式化的字符串。在生日数组下方添加一个日期格式化器：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，日期格式化器是一个常量，用 let 创建。尽管你会更改日期格式化器的属性，如 dateStyle 和 timeStyle，但你永远不会改变日期格式化器本身。

你还需要设置日期格式化器，使其能够将生日显示为格式化的字符串，例如“Tuesday, December 17, 2008”。正如你在第十章中看到的，做这个操作的好地方是在 viewDidLoad()方法中，该方法在生日表视图控制器加载其视图时被调用。这是进行任何类初始化设置的最佳位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了日期格式化器的 dateStyle，以便它为每个生日显示一个格式化的日期字符串。你注意到我们只是写了.full，而不是 DateFormatter.Style.full 吗？Swift 知道日期格式化器的 dateStyle 应该是什么类型，所以它允许我们使用这个小技巧。在 ➋ 处，你将日期格式化器的 timeStyle 设置为.none，这样时间就不会显示了。

#### 在表视图中显示生日

BirthdaysTableViewController 类具有一个表视图，用于在单列中显示项目列表。该表视图包含一个或多个包含行的部分，每一行包含一个单元格。表视图中的部分是行的分组，可以显示也可以不显示标题。一个展示多个部分的表视图应用的例子是设置应用，如图 11-5 所示。它显示了按不同部分分组的行列表。

表格视图的每个部分和行都有一个索引号。这些数字从 0 开始，然后随着表格视图向下增加 1。例如，设置应用中的隐私项位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为*Table view data source*的部分，包含三个方法。表格视图控制器使用这些方法来确定将显示在其表格视图中的内容。

numberOfSections(in:) 告诉表格视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表格视图每个部分会显示多少行

tableView(_:cellForRowAt:) 设置将要在表格视图每一行中显示的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分将不同设备设置的行进行分组。*

每次重新加载表格视图时，表格视图控制器都会调用表格视图数据源方法。当你创建一个 UITableViewController 的子类时，Xcode 会自动为你生成这些方法模板。为了让应用正常工作，你需要实现所有三个方法，尽管你在代码中永远不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议提供了这些数据源方法，用于确定表格视图中显示的内容。我们将在第 166 页的“委托”中讨论协议。目前，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且会自动调用这些方法，因此你无需显式调用它们。

让我们从方法 numberOfSections(in:)开始。Birthdays 表格视图控制器是一个仅显示生日实例的列表，因此不需要多个部分。为了设置表格视图中的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 tableView 的 UITableView 参数，这是使用此类作为其数据源的表格视图。我们无需担心建立这个连接，因为 UITableViewController 自带一个内置的表格视图，它会自动与这些方法连接。每个生日将显示在自己的行中。因此，在 tableView(_:numberOfRowsInSection:)方法中，为了确保每个生日都能显示正确的行数，你需要返回 birthdays 数组中生日实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少项，非常适合这种情况！将此方法修改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了`tableView`参数，`tableView(_:numberOfRowsInSection:)`方法还接受一个名为`section`的`Int`类型参数。当表格视图加载时，这个方法会为表格视图中的每个部分调用。在我们的例子中，只有一个部分，因此我们无需检查显示的是哪个部分。我们知道是第零部分，并且希望它包含和生日数目相等的行数，所以我们写`return birthdays.count`。

最后，你需要实现`tableView(_:cellForRowAt:)`方法，以便表格视图知道在每个单元格中放入什么内容。由于该方法已被注释掉，你需要通过删除包围它的/*和*/来取消注释。（小心不要不小心取消注释它之后的其他方法！）完成这一步后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你并不直接调用`tableView(_:cellForRowAt:)`方法。它会在表格视图加载到屏幕上时自动调用。它会为每个屏幕上的单元格调用，并接受两个参数：`tableView`和`indexPath`。你已经知道`tableView`参数的作用。`IndexPath`是一个 Swift 结构体，用于表示表格视图中某一行的位置。`IndexPath`实例有`section`属性和`row`属性。由于这个方法会被多次调用（每一行都会调用一次），我们需要`indexPath`来知道我们当前正在配置的是哪个部分和行。`indexPath.section`属性表示部分号，`indexPath.row`表示表格视图单元格的行号。`tableView(_:cellForRowAt:)`方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个`UITableViewCell`

• 确定在`birthdays`数组中将显示哪一个生日

• 创建两个标签，在单元格中显示生日人的名字和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建`UITableViewCell`。代码在➊处使用了`dequeueReusableCell(withIdentifier:for:)`方法来实现。在你开始使用此方法之前，你需要告诉该方法你要使用的是哪个单元格。从故事板中选择的单元格会作为标识符。在早些时候，你已经为单元格指定了标识符`birthdayCellIdentifier`（参见图 11-4）。这个标识符将你的代码与单元格关联，并告诉你的方法它正在使用正确的单元格。当你调用此方法时，传入的字符串必须与在故事板中设置的字符串完全相同，否则你会遇到错误，并且运行时应用程序会崩溃。

在方法 `dequeueReusableCell(withIdentifier:for:)` 中，你注意到 *可重用单元格* 这个词了吗？表视图中的单元格只创建一次，然后可以反复重用。这有助于加快运行速度，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，滚出屏幕顶部的单元格会被重用。它们会被填充新的信息，并再次出现在屏幕的底部。`UITableView` 会自动完成这项工作。当表视图加载时，`tableView(_:cellForRowAt:)` 会为每一行可见的单元格调用。当用户滚动以查看更多单元格时，它会在每个单元格即将出现在屏幕上时再次被调用。

接下来，我们需要找出应该在单元格内显示哪个生日。我们希望在每一行中显示 `birthdays` 数组中的一个生日。第一个生日，位于 `birthdays[0]`，应该显示在第 0 行。第二个生日，位于 `birthdays[1]`，应该显示在第 1 行，以此类推，这意味着 `indexPath` 的行数与我们想要访问的 `birthdays` 数组中的位置相同。在 ➋ 处的代码通过使用 `indexPath.row` 来访问 `birthdays` 数组中的正确的生日对象。一旦我们获得了正确的生日对象，我们将其分配给名为 `birthday` 的常量，以便可以设置该单元格中的标签。

请注意，我们使用 `let` 来将生日赋值给常量，而不是变量。我们可以使用 `let`，因为每次调用 `tableView(_:cellForRowAt:)` 时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并分配了它自己的生日对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以我们不想将它们设为变量。

现在你已经有了单元格和生日，是时候填写详细信息了。你需要为每个单元格准备两个标签，用于显示生日人的姓名和出生日期。你将单元格设置为 `Subtitle` 样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，所以现在你不需要自己创建任何标签。

标签作为 `UITableViewCell` 的属性存在，分别叫做 `textLabel` 和 `detailTextLabel`。在 ➌ 处的代码将 `textLabel` 的文本设置为由生日的 `firstName` 和 `lastName` 组成的字符串，两者之间用空格分隔。在 ➍ 处，你使用 `dateFormatter` 的 `string(from:)` 方法将出生日期显示在 `detailTextLabel` 中。

当你的单元格完全配置好后，`tableView(_:cellForRowAt:)` 会在 ➎ 处返回该单元格，以便在表视图的该 `indexPath` 上显示。

### 将一切整合在一起

现在，您可以使用“添加生日”视图控制器将生日实例添加到应用程序中，并且在“生日”表格视图控制器中有一个表格视图来列出每个生日。但是，当您尝试运行应用程序并添加一个生日时，它并没有显示出来。为了让您添加的每个生日出现在表格视图中，您需要让“添加生日”视图控制器与“生日”表格视图控制器进行通信。您可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设您有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它只是突然出现的，不知道自己从哪里来，也不知道是如何到达这里的。那么 B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项工作或任务交给另一个人。*委托人*就像一个老板，告诉委托员工该做什么。当委托员工完成任务时，有时他们会向委托老板报告信息。

在 Swift 中，委托与此非常相似，但我们不再有老板和员工，而是有委托和委托对象。由于类 B 是由类 A 告诉它做什么的，所以它是委托对象。我们为类 B 设置一个特殊的属性，称为委托(delegate)，用来告诉它谁是它的委托对象——这样，它就知道该与谁进行通信。委托对象可以是任何一个具有在*协议*中定义的一组方法的类。协议就像是两个类之间的约定，告诉它们委托可以要求委托对象做什么。协议包含了一组方法和属性名称，委托可以使用这些方法和属性与委托对象进行交互。

类 A 创建类 B，使自己成为类 B 的委托，并给类 B 一项任务，任务在协议中定义。完成任务后，类 B 会向类 A 报告。让我们看看在我们的应用程序中是如何工作的。

生日表格视图控制器是视图控制器 A，“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由“添加生日”视图控制器使用来回报信息。

看一下图 11-6。当用户点击“添加”按钮 ➊ 时，生日表格视图控制器创建“添加生日”视图控制器 ➋ 并将自己设置为“添加生日”视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从“添加生日”视图控制器传递到“生日”表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为包含一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，Add Birthday 视图控制器会调用这个方法 ➍，并将新生日传递给它的委托对象——Birthdays 表格视图控制器。Birthdays 表格视图控制器接收这个生日，将其添加到它的生日数组中，然后重新加载表格视图 ➎，这样新生日就会显示在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，包含 addBirthdayViewController(_:didAddBirthday:)方法，Add Birthday 视图控制器在每次添加生日时都可以调用这个方法。Birthdays 表格视图控制器将实现这个协议方法，以便每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器只需对其委托说：“嘿！有人刚刚添加了这个生日”，然后 Birthdays 表格视图控制器会听到这个消息并说：“哦！我会把它添加到我的列表中并刷新我的显示，这样新生日就会显示出来。”

现在让我们在代码中实现这一点！

##### 创建一个协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类的*上方*添加以下代码，定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处通过输入关键字 protocol 并跟上名称 AddBirthdayViewControllerDelegate 来定义协议。这个名称比较长，但 Swift 程序员通常会根据调用类的名称命名协议，并在后面加上 Delegate 一词。这样，你就可以通过查看协议的名称来知道哪个类在使用该协议。既然你现在是 Swift 程序员，应该遵循相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，用于将 Birthday 对象传递回委托类 ➋。注意，你在这个函数中包括了 AddBirthdayViewController 作为参数。同样，Swift 程序员在实现协议方法时通常会这么做，所以你也应该坚持这样做。这有助于知道是谁发送了消息，并且让委托对象能够访问该对象及其类。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递给方法。你很快就会看到如何实现这一点。另一个需要注意的是外部参数名称 didAddBirthday。许多委托协议方法包含*did*和*will*，因为它们用来描述调用类刚刚做过的事情或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表格视图控制器采用这个协议并使用协议的方法。

##### 让 Birthdays 表格视图控制器遵循协议

要采用该协议，Birthdays 表视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为此，您需要在 UITableViewController 超类之后的类定义中添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后添加一个逗号，然后键入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦您这么做，就会出现一个红色错误。这是因为 BirthdaysTableViewController 表示它是一个 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快就会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是在子类化 UITableViewController 超类。一个类只能有一个超类，且该超类名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采纳任意多个协议——这些协议都会列在超类之后，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:) 方法添加到 BirthdaysTableViewController。一个合适的地方是在类的末尾，在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当您开始输入函数名时，Xcode 自动完成会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它期望您添加这个方法。请注意，与子类化方法不同，您在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法可以被重写。

在这个方法中，您需要做两件事。首先，您需要将 Add Birthday 视图控制器传递的生日添加到 birthdays 数组中。您可以通过使用 append(_:) 方法来实现这一点 ➋。接下来，您需要刷新表视图，以便显示这个新生日，方法是调用 tableView 属性上的 reloadData() 方法 ➌。当 reloadData() 被调用时，表视图的数据源方法将会再次被调用，新增的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这并不是必需的，但良好的编码风格是为你的类标出不同的部分，它有助于保持代码的整洁和可读性。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你找到方法，并让你能够跳转到代码的不同位置。要使用这个菜单，点击编辑器窗格顶部的**生日表格视图控制器**，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器指定委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉生日表格视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个可选的 AddBirthdayViewControllerDelegate 类型的委托属性来安排此操作，插入以下行到 outlets 下方：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为你不能在*Add Birthday 视图控制器创建之后*才能设置它。稍后你会学习在哪里设置委托。

现在，Add Birthday 视图控制器已经有了委托，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将一个生日传递给委托。将 saveTapped(_:)方法改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象之后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)将其返回给委托。

很好！你已完成对 Add Birthday 视图控制器的更改。现在它有了一个委托，会监听生日保存的调用。运行应用程序，看看会发生什么。

嗯……没有太大变化。当你添加一个生日时，你仍然看不到它出现在生日表格视图控制器中。怎么回事？

#### 通过设置委托连接这两个控制器

还有最后一件事你需要做。**生日表格视图控制器**是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用于保存它在生日被保存时与之通信的委托。但我们从未明确将委托属性设置为生日表格视图控制器。所以现在是时候在这两个视图控制器之间建立通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个已被注释掉的方法叫做 prepare(for:sender:)。通过删除 /* 和 */，取消注释该方法。

每当 Birthdays 表格视图控制器放弃其屏幕，并且应用程序通过 storyboard segue 切换到另一个视图控制器时，此方法会自动调用。我们将使用此方法将 Birthdays 表格视图控制器传递到 Add Birthday 视图控制器，并将其设置为 Add Birthday 视图控制器的代理。请在 prepare(for:sender:) 方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

需要三行代码将 Add Birthday 视图控制器的代理设置为 Birthdays 表格视图控制器。首先，您需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 已经在注释中提示了如何做到这一点。一个 UIStoryboardSegue 在其准备的这一端有一个叫做 destination 的属性，但是对于这个应用程序，目标并不是 AddBirthdayViewController。

在第九章中，您将 Add Birthday 视图控制器嵌入到一个导航控制器中，这样您就可以拥有一个带有取消和保存按钮的导航栏。所以您不需要期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊ 这一行代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是一个特定类型的 ViewController，因此我们需要使用 as 将其类型转换为 UINavigationController。

接下来，您可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当您拥有 AddBirthdayViewController 后，可以将代理设置为 self ，即当前的 Birthdays 表格视图控制器 ➌。

现在运行应用程序并添加一些生日！您在 Birthdays 表格视图控制器中看到什么？生日！生日！生日！不过，我们还没有完全完成。如果您退出应用程序并再次运行它，之前的生日将消失。我们仍然需要将生日保存到设备中，这将在第十二章中进行。

### 您学到了什么

在本章中，您学习了如何创建一个表格视图控制器来显示您的生日列表。您还学习了如何在 Add Birthday 视图控制器中添加一个生日，然后如何使用代理将生日添加到 Birthdays 表格视图控制器中的 birthdays 数组中，以便显示出来。

在第十二章中，你将学习如何将生日保存到你的设备上，这样即使退出应用并重新运行，它们仍然会显示出来。要保存生日，你将使用我们在项目开始时就设置的 Core Data。

我们将从在故事板中创建这些单元格开始，然后稍后用我们的生日对象填充它们。在左侧的大纲菜单中，点击 Birthdays 旁边的三角形，然后点击 Table View 旁边的三角形，展开这些部分。然后选择**Table View Cell** ➊，如图 11-4 所示。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建一个副标题样式的表格视图单元格并设置其标识符*

接下来，打开属性检查器。使用**样式**下拉菜单，将单元格的样式设置为**副标题** ➋，这样单元格就会有一个标题标签和一个副标题标签。你将在标题中显示每个人的名字，在副标题中显示生日。

最后，在标识符字段➌中输入`birthdayCellIdentifier`。稍后你将使用这个标识符来填充单元格内容。

就这样！你已经完成了在故事板中的工作。

你可能会想，为什么我们在故事板中的表格视图里只有一个单元格，而列表中会显示多个生日。如果你再看看图 11-4，你会注意到这个单元格被标记为*原型单元格*。这意味着你刚刚自定义的单元格是你希望出现在表格视图中的所有单元格的*模板*。你为单元格设置的标识符是你的代码告诉表格视图生成每个单元格的方式，以便将生日放入其中。你很快就会看到这一点是如何工作的。

**处理日期**

Swift 有一个特殊的数据类型叫做 Date，用于存储日期值。一个 Date 对象实际上包含了日期和时间。打开你的 Playground 并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量`today`。当你打印`today`时，它的格式是"2017-11-21 10:45:31 +0000\n"。如果你想将其显示为 2017 年 11 月 21 日星期二呢？或者仅仅是 11/21/17 呢？要以特定的方式显示日期，你需要使用*日期格式化器*，它是一个 DateFormatter 对象，你可以创建并给它一个日期格式样式。DateFormatter 是一个辅助对象，用于从任何日期创建一个显示字符串，而*日期格式样式*是 DateFormatter 的一个属性，告诉格式化器使用哪种样式。你可以手动创建自己的日期格式样式，但 Swift 中也有一些内置的样式，可以直接使用。将以下内容添加到你的 Playground 中：

![](img/Image00240.jpg)

在➊处，你创建了一个格式化器。然后在➋处，你将格式化器的样式设置为 Style.full，这将打印出星期几以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:)方法从日期创建字符串➌。你可以看到，你现在已经将日期转换为格式化良好的字符串"2017 年 11 月 21 日，星期二"。表 11-1 显示了在 Swift 中使用五种 DateFormatter.Style 选项创建的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "2017 年 11 月 21 日" |
| long | "2017 年 11 月 21 日" |
| full | "2017 年 11 月 21 日，星期二" |

你还可以使用 DateFormatter 的 dateFormat 属性指定自定义的日期显示方式。也许你只希望显示月份和日期，或者你希望以短格式显示四位数字的年份。做任何一件事都很容易，而且你甚至不需要创建新的 DateFormatter——你只需更改 formatter 的 dateFormat，然后请求它返回一个新的字符串。将以下代码添加到你的 playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在➊处，你指定只希望按 MM/dd 格式显示月份和日期——即两位数字的月份，后面跟着两位数字的日期。如果你想显示月份的三个字母缩写，则使用 MMM。要显示完整的月份名称，使用 MMMM。在➋处，我们将日期格式更改为使用四位数字的年份。两位数字的年份用 yy 表示。以下是几种使用 dateFormat 来显示自定义日期字符串的方法。

![](img/Image00242.jpg)

如果你想添加分隔符，可以将它们添加到你的 dateFormat 字符串中。例如，如果你想使用句点作为分隔符，可以创建像"MM.dd.yy"这样的 dateFormat ➊。如果你想显示星期几的缩写，使用 EEE ➋。要显示完整的星期几，使用 EEEE ➌。这些只是几个示例。通过组合 M、d、y 和 E，你可以有无数种方式来显示日期！

#### 设置生日表视图控制器

生日表视图控制器将显示应用中存储的所有生日的列表。你还记得用什么来存储一组项目吗？没错——数组！你将在 BirthdaysTableViewController 中创建一个数组，用于存储所有的生日。为此，给 BirthdaysTableViewController 添加一个名为 birthdays 的属性，这是一个 Birthday 对象的数组。在类的顶部，紧挨着 viewDidLoad()方法的上方，插入这一行代码来添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的生日实例数组。它需要是一个变量而不是常量，因为你希望每次用户通过添加生日视图控制器添加一个生日时，都将一个保存的生日添加到这个数组中。你将在“让 Birthdays Table View Controller 遵循协议”中看到如何做，第 168 页。

**注意**

*记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性，用来将出生日期显示为格式化好的字符串。在生日数组下方添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

注意，dateFormatter 是一个常量，通过 let 创建的。即使你会改变 dateFormatter 的属性，如 dateStyle 和 timeStyle，你也永远不会改变 dateFormatter 本身。

你还需要设置 dateFormatter，以便它能够将出生日期显示为完整格式的字符串，比如“星期二，2008 年 12 月 17 日”。正如你在第十章中看到的，做这个设置的一个好地方是 viewDidLoad() 方法，该方法在生日表视图控制器加载其视图时被调用。这是进行任何所需设置的完美位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 dateFormatter 的 dateStyle，以便它能够为每个生日显示格式化的日期字符串。你有没有注意到我们只是写了 .full，而不是 DateFormatter.Style.full？Swift 知道期望什么类型作为 DateFormatter 的 dateStyle，所以它允许我们使用这个简短的写法。在 ➋ 处，你将 dateFormatter 的 timeStyle 设置为 .none，这样时间就不会显示出来。

#### 在表视图中显示生日

BirthdaysTableViewController 类有一个表视图，用于显示单列的项目列表。表视图包含一个或多个部分，每个部分包含若干行，每一行包含一个单元格。表视图中的一个部分是行的分组，可以选择是否显示标题。一个展示多个部分的表视图应用示例是设置应用，如图 11-5 所示。它显示了被拆分成不同部分的行列表。

表视图的每个部分和行都通过索引号进行标识。这些数字从 0 开始，然后每下移一行增加 1。例如，在设置应用中，隐私行位于第零部分，第 1 行；新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为 *表视图数据源* 的部分，其中包含三个方法。表视图控制器使用这些方法来确定在其表视图中显示的内容。

numberOfSections(in:) 告诉表视图它应该有多少个部分

`tableView(_:numberOfRowsInSection:)` 告诉表格视图每个部分将显示多少行

`tableView(_:cellForRowAt:)` 设置将显示在表格视图每一行中的每个单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分将不同的设备设置分组*

表格视图数据源方法会在每次表格视图重新加载时由表格视图控制器调用。当你创建 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。即使你在代码中不会直接调用它们，你也需要实现这三个方法，才能让应用正常工作。UITableViewController 类实现了 UITableViewDataSource 协议，后者包含这些数据源方法，用来确定表格视图中将显示的内容。我们将在“委托”一节中讨论协议。在此，你只需要知道，UITableViewController 使用这些方法来显示其内容，并会自动调用这些方法，因此你无需手动调用它们。

我们从方法 `numberOfSections(in:)` 开始。Birthday 表格视图控制器是一个仅显示 Birthday 实例的列表，因此它不需要多个部分。为了设置表格视图中的部分数量，我们只需返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 tableView 的 UITableView 参数，这是使用此类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内置的表格视图，且自动与这些方法连接。每个生日都会显示在它自己的行中。因此，在 `tableView(_:numberOfRowsInSection:)` 中，为了正确显示所有生日的行数，你需要返回 `birthdays` 数组中 Birthday 实例的数量。你记得数组的 `count` 属性吗？它是一个整数，表示数组中的项数，正好适合这种情况！将此方法更改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，`tableView(_:numberOfRowsInSection:)` 还接受一个名为 section 的 Int 参数。当表格视图加载自身时，这个方法会为每个部分调用一次。在我们的例子中，只有一个部分，所以我们不需要检查表格视图显示的是哪个部分。我们知道是部分 0，并希望它有和生日数量一样多的行，因此我们写下 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)`，以便表格视图知道在每个单元格中放置什么内容。由于此方法被注释掉了，你需要通过删除包围它的 `/*` 和 `*/` 来取消注释。（小心不要不小心取消注释后面的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法`tableView(_:cellForRowAt:)`。它会在表格视图加载到屏幕上时被调用。它会为屏幕上的每个单元格被调用，并且接受两个参数：`tableView`和`indexPath`。你已经知道`tableView`参数的作用。`IndexPath`是一个 Swift 结构体，用于表示表格视图中某行的位置。`IndexPath`实例有一个`section`属性和一个`row`属性。由于这个方法会被多次调用（每次为表格中的一行），我们需要使用`indexPath`来知道我们当前正在配置的是哪个部分和哪一行。`indexPath.section`属性提供部分号，而`indexPath.row`提供表格视图单元格的行号。`tableView(_:cellForRowAt:)`方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个`UITableViewCell`

• 确定在`birthdays`数组中哪个生日将显示在单元格内

• 创建两个标签以在单元格中显示生日人员的姓名和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行查看这段代码。

首先，创建`UITableViewCell`。代码中的➊部分使用方法`dequeueReusableCell(withIdentifier:for:)`来完成这一操作。在开始使用此方法之前，你需要告诉它从故事板中使用哪个单元格。早些时候，当你在故事板中时，你给单元格设置了标识符`birthdayCellIdentifier`（见图 11-4）。这个标识符将你的代码和单元格关联起来，并告诉你的方法它正在使用正确的单元格。当你调用此方法时，字符串必须与故事板中设置的字符串完全相同，否则你会遇到错误，应用在运行时会崩溃。

在方法`dequeueReusableCell(withIdentifier:for:)`中，你注意到“*可重用单元格*”这个词了吗？表格视图中的单元格是创建一次后可以反复重用的。这有助于一切运行得更快、更顺畅，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但每次屏幕上只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，滚动出屏幕顶部的单元格会被重用。它们会被填充新的信息，然后出现在屏幕底部。`UITableView`会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)`会为每个可见的行被调用。当用户滚动查看更多单元格时，它会在每个行即将出现在屏幕上时再次被调用。

接下来，我们需要找出应该在单元格中显示哪一个生日。我们想要在每一行中显示 birthdays 数组中的一个生日。第一个生日，即 birthdays[0]，应该显示在第 0 行；第二个生日，即 birthdays[1]，应该显示在第 1 行，以此类推，这意味着 indexPath 的 row 就是我们想要访问的 birthdays 数组中对应的位置。代码 ➋ 通过使用 indexPath.row 从 birthdays 数组中访问正确的 Birthday 对象。一旦我们获得了正确的 Birthday 对象，我们将其分配给一个名为 birthday 的常量，以便我们能够设置此单元格中的标签。

请注意，我们使用 let 将生日分配给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的 birthday 常量。每个单元格都有自己的 birthday 常量，并将其分配给自己的 Birthday 对象。由于我们不会改变任何生日常量——我们只是读取它们的属性——所以我们不需要将它们设为变量。

现在你有了单元格和生日，是时候填写详细信息了。每个单元格需要两个标签来显示生日人员的名字和出生日期。你将单元格设置为 Subtitle 样式，这样它就会有一个 Title 标签和一个 Subtitle 标签。每个单元格已经包含这些标签，所以现在你不需要自己创建任何标签了。

这些标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。代码 ➌ 将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，并在它们之间加上空格。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法来在 detailTextLabel 中显示出生日期。

当你的单元格完全配置好时，tableView(_:cellForRowAt:) 方法会返回位于 ➎ 的单元格，以便它可以在表视图的对应 indexPath 中显示。

### 将一切组合起来

现在，你可以通过添加生日视图控制器将生日实例添加到应用程序中，并且你有一个表视图来列出每个生日，展示在 Birthdays 表视图控制器中。但是，当你尝试运行应用程序并添加生日时，生日没有显示出来。为了让你添加的每个生日都出现在表视图中，你需要让添加生日的视图控制器与 Birthdays 表视图控制器进行通信。你可以通过使用 *委托（delegation）* 来实现这一点。

#### 委托（DELEGATION）

委托（Delegation）可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己之上。A 知道 B 的存在，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它只是突然出现的，并不知道自己是从哪里来的或者是如何到达那里的。那么，B 如何与 A 进行沟通呢？通过委托（delegation）！

![](img/Image00245.jpg)

委托（Delegation）是指某人将一项工作或任务交给另一个人。一个*委托人*就像一个老板，他告诉一个被委托的员工该做什么。当这个被委托的员工完成任务时，有时他们会将信息反馈给委托人（老板）。

在 Swift 中，委托的概念非常相似，不过我们不再有老板和员工，而是有一个委托对象和一个被委托对象。由于类 B 是由类 A 告诉该做什么的，所以它是被委托对象。我们为类 B 提供一个特殊的属性，称为委托（delegate），用来告诉它谁是它的委托人——这样它就知道该与谁进行沟通。委托可以是任何拥有在*协议*中定义方法集的类。协议就像是两个类之间的约定，告诉它们委托人可以要求被委托对象做什么。协议中包含了一组方法和属性名称，委托人可以利用这些方法与被委托对象进行交互。

类 A 创建类 B，将自己设置为类 B 的委托，并给类 B 分配一个在协议中定义的任务。一旦类 B 完成任务，它会向类 A 报告。让我们看看在我们的应用中是如何工作的。

生日列表视图控制器是视图控制器 A，而添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法`addBirthdayViewController(_:didAddBirthday:)`，该方法将由添加生日视图控制器用来报告回调信息。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日列表视图控制器会创建添加生日视图控制器 ➋ 并将自己设置为该添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：通过委托，新的生日从添加生日视图控制器传递到生日列表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为拥有一个方法`addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存按钮 ➌ 时，添加生日视图控制器调用该方法 ➍ 并将新的生日信息传递给它的委托，即生日列表视图控制器。生日列表视图控制器接收这个生日，添加到它的生日数组中，并重新加载其表格视图 ➎，以便新的生日能够显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并包含方法`addBirthdayViewController(_:didAddBirthday:)`，该方法可以在每次向应用中添加生日时被添加生日视图控制器调用。生日列表视图控制器将实现该协议方法，这样每当通过添加生日视图控制器添加生日时，添加生日视图控制器就可以对其委托说：“嘿！有人刚刚添加了这个生日。”然后生日列表视图控制器会收到这个消息并说：“哦！我会将其添加到我的列表中，并刷新我的显示，以便新添加的生日可以显示出来。”

现在，让我们开始编写代码吧！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，*在* `AddBirthdayViewController` 类之前，添加这段代码来定义 `AddBirthdayViewControllerDelegate` 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处定义协议，方法是键入关键字 `protocol`，然后跟上协议名称 `AddBirthdayViewControllerDelegate`。这是一个比较长的名称，但 Swift 程序员通常会根据调用类命名协议，并在名称后添加 `Delegate` 这个词。这样，你就能通过查看协议的名称来知道是哪个类在使用该协议。既然你现在是 Swift 程序员了，应该也遵循这个命名惯例。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)` 是唯一的函数，用于将 `Birthday` 对象传回给委托类 ➋。注意，在这个函数中你包括了 `AddBirthdayViewController` 作为一个参数。再说一次，Swift 程序员在实现协议方法时会遵循这个惯例，所以你也应该这样做。了解是谁发送回消息并让委托可以访问那个对象及其类是很有用的。

当添加生日视图控制器调用此方法时，它将自身作为 `addBirthdayViewController` 参数传递。你很快就会看到如何做到这一点。另一个需要注意的地方是外部参数名称 `didAddBirthday`。许多委托协议方法包含*did*和*will*这两个词，因为它们用来描述调用类刚刚完成或将要完成的事情。

现在你已经定义了协议，接下来需要告诉生日表视图控制器采用此协议并使用协议的方法。

##### 让生日表视图控制器遵守协议

为了采纳协议，生日表视图控制器需要让自己成为 `AddBirthdayViewControllerDelegate`。为了实现这一点，你需要在类定义中将 `AddBirthdayViewControllerDelegate` 添加到 `UITableViewController` 父类之后。在类的顶部，在 `UITableViewController` 后面添加逗号，然后输入 `AddBirthdayViewControllerDelegate`：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色的错误提示就会出现。这是因为 `BirthdaysTableViewController` 声明自己是一个 `AddBirthdayViewControllerDelegate`，但它还没有实现该协议！为了实现它，需要实现 `AddBirthdayViewControllerDelegate` 协议定义。别担心，我们很快就会解决这个问题。

这里需要特别注意的是，`BirthdaysTableViewController` 是 `UITableViewController` 类的子类。一个类只能有一个父类，而且该父类的名称必须写在所有协议之前。但虽然一个类只能有一个父类，它可以采用任意多个协议——这些协议会在父类之后列出，并用逗号隔开。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个好的添加位置是在类的末尾，即导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议整个方法声明。这是因为它知道该类采用了 AddBirthdayViewController Delegate 协议，并且它预期你会添加这个方法。请注意，与子类化方法不同，你在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将添加生日视图控制器传入的生日添加到 birthdays 数组中。你可以使用数组的 append(_:) 方法 ➋ 来实现。接下来，你需要刷新表视图，以便它显示这个新添加的生日，方法是调用 tableView 属性上的 reloadData() 方法 ➌ 。当调用 reloadData() 时，表视图的数据源方法将重新调用，新增的生日会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必需的，但将类的不同部分进行标记是良好的编码风格，它有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，用于代码注释，并将 AddBirthdayViewControllerDelegate 部分添加到下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你找到方法，并让你跳转到代码中的不同位置。要使用这个菜单，请点击编辑器面板顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，方便快速跳转到某个部分。*

##### 为添加生日视图控制器设置委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议，告知 Birthdays 表视图控制器它已经添加了一个生日。为此，添加生日视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性来安排此事，方法是在 outlets 下面插入以下代码：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为你无法在添加生日视图控制器创建之前设置它。你很快就会学到在哪里设置委托。

现在 Add Birthday 视图控制器有了一个委托，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日传递给委托。将 saveTapped(_:) 改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 将其返回给委托。

很好！你已经完成了对 Add Birthday 视图控制器的修改。现在它有了一个委托，能够监听生日被保存的通知。运行应用程序看看会发生什么。

嗯……变化不大。当你添加一个生日时，仍然看不到它出现在 Birthdays 表视图控制器中。怎么回事？

#### 通过设置委托连接这两个控制器

还有最后一件事你需要做。**Birthdays** 表视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存它与之通信的委托对象，当一个生日被保存时会调用它。但是我们从未明确设置委托属性为 Birthdays 表视图控制器。所以现在是时候连接我们的两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个方法被注释掉了，名为 prepare(for:sender:)。通过删除 /* 和 */ 来取消注释该方法。

每当 Birthdays 表视图控制器放弃其屏幕并且应用程序通过 storyboard segue 转到另一个视图控制器时，这个方法会自动调用。我们将利用这个方法将 Birthdays 表视图控制器传递给 Add Birthday 视图控制器，以便它自己设置为 Add Birthday 视图控制器的委托。在 prepare(for:sender:) 方法中写下如下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的委托为 Birthdays 表视图控制器只需要三行代码。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，它位于此方法中正在准备的 segue 的另一端，但是对于这个应用程序，destination 并不是 AddBirthdayViewController。

在 第九章 中，你将 Add Birthday 视图控制器嵌入到一个导航控制器中，这样你就可以有一个带有取消和保存按钮的导航栏。所以你不期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊ 处的代码获取了 navigationController。代码 segue.destination 会返回一个 UIViewController，但因为我们的 navigationController 是特定类型的视图控制器，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其强制转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你拥有一个 AddBirthdayViewController 时，你可以将代理设置为 self，即当前的 Birthdays 表视图控制器 ➌。

现在运行应用并添加一些生日！你在 Birthdays 表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用并再次运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中进行。

### 你学到的内容

在本章中，你学习了如何制作一个表视图控制器来显示你的生日列表。你还学会了如何在 Add Birthday 视图控制器中添加一个生日，并通过代理将生日添加到 Birthdays 表视图控制器中的生日数组，以便能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，以便即使退出应用并再次运行，它们依然存在。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

![](img/Image00237.jpg)![](img/Image00238.jpg)

*图 11-4：创建 Subtitle 样式的表视图单元格并设置其标识符*

接下来，打开属性检查器。在 **Style** 下拉菜单中，将单元格的样式设置为 **Subtitle** ➋，这样单元格现在就有了 Title 标签和 Subtitle 标签。你将在 Title 中显示每个人的名字，在 Subtitle 中显示生日。

最后，在标识符字段中输入 birthdayCellIdentifier ➌。稍后你会使用这个标识符来填充单元格内容。

就这样！你已经完成了 storyboard 中的工作。

你可能会想，为什么在 storyboard 中我们的表视图中只有一个单元格，而我们需要显示多个生日。如果你再次查看图 11-4，你会注意到单元格被标记为 *Prototype Cells*。这意味着你刚才自定义的单元格是你想要在表视图中显示的所有单元格的 *模板*。你为单元格指定的标识符是你的代码用来告诉表视图为你生成每个单元格，并将生日放入其中的方式。你很快就会看到它是如何工作的。

**处理日期**

Swift 有一个特殊的数据类型叫做 Date，用于存储日期值。一个 Date 对象实际上包含了日期和时间。打开你的 Playground，并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量 today 。当你打印 today 时，它的格式是 "2017-11-21 10:45:31 +0000\n" 。如果你想将其显示为 "2017 年 11 月 21 日，星期二" 呢？或者只是 "11/21/17" 呢？为了以特定的方式显示日期，你需要使用 *日期格式化器*（date formatter），它是你创建并设置日期格式样式的 DateFormatter 对象。DateFormatter 是一个帮助对象，用于根据任意日期创建显示字符串，*日期格式样式* 是 DateFormatter 的一个属性，它告诉格式化器使用什么样式。你可以手动创建你自己的日期格式样式，但 Swift 中也包含了一些预设的样式，随时可以使用。将以下代码添加到你的 playground 中：

![](img/Image00240.jpg)

在 ➊ 处，你创建了一个格式化器。然后在 ➋ 处，你将格式化器的样式设置为 Style.full，它将打印出星期几、完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:) 方法创建一个日期字符串 ➌ 。你可以看到，现在你已经将日期转换为格式化好的字符串 "2017 年 11 月 21 日，星期二" 。表 11-1 显示了 Swift 中可用的五个 DateFormatter.Style 选项所创建的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "2017 年 11 月 21 日" |
| long | "2017 年 11 月 21 日" |
| full | "2017 年 11 月 21 日，星期二" |

你也可以使用 DateFormatter 的 dateFormat 属性来指定自定义的日期显示方式。也许你只想显示月份和日期。或者你可能希望以简短的格式显示四位数的年份。做这两件事都非常简单，而且你甚至不需要创建一个新的 DateFormatter——你只需要改变 formatter 的 dateFormat，然后请求一个新的字符串。将以下代码添加到你的 playground 中，使用特定的格式显示日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定只想要月和日，以 MM/dd 格式显示——即，先是两位数的月份，再是两位数的日期。如果你想显示月份的前三个字母，可以使用 MMM 。要显示月份的全名，可以使用 MMMM 。在 ➋ 处，我们将日期格式更改为使用四位数的年份。两位数的年份则是 yy 。这里有一些其他的方式来使用 dateFormat 显示自定义的日期字符串。

![](img/Image00242.jpg)

如果你想包含分隔符，可以将它们添加到你的 dateFormat 字符串中。例如，如果你想使用句点作为分隔符，你可以创建类似 "MM.dd.yy" ➊ 的 dateFormat。要显示简写的星期几，可以使用 EEE ➋ 。要显示完整的星期几名称，可以使用 EEEE ➌ 。这些只是一些示例。通过使用 M 、 d 、 y 和 E 的组合，你可以有无数种方式来显示日期！

#### 设置生日表格视图控制器

Birthdays 表格视图控制器将显示应用中存储的所有生日列表。你记得用什么来存储项列表吗？没错——数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有的生日。为此，在类的顶部，紧接着 viewDidLoad() 方法之前，插入这一行，添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量，而不是常量，因为你希望每次用户通过添加生日视图控制器添加一个生日时，将一个保存的生日添加到这个数组中。你将在“使 Birthdays 表格视图控制器遵守协议”一节的第 168 页中看到如何实现这一点。

**注意**

*请记住，项目文件的最终版本可通过* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *获取。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性，用于将出生日期显示为格式化的字符串。在 birthdays 数组下方添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，使用 let 创建。即使你会改变 dateFormatter 的属性，如 dateStyle 和 timeStyle，你也不会改变 dateFormatter 本身。

你还需要设置日期格式化器，以便它能够将出生日期显示为像“2008 年 12 月 17 日，星期二”这样的完整格式化字符串。正如你在第十章中看到的，做这个操作的一个好地方是 viewDidLoad() 方法，它在 Birthdays 表格视图控制器加载其视图时被调用。这是执行任何必要设置的完美位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了日期格式化器（dateFormatter）的 dateStyle，以便它为每个生日显示格式化的日期字符串。你是否注意到我们只写了.full，而不是 DateFormatter.Style.full？Swift 知道日期格式化器的 dateStyle 应该是什么类型，所以允许我们采用这个小小的快捷方式。在 ➋ 处，你设置了日期格式化器的 timeStyle 为.none，这样时间就不会显示出来。

#### 在表格视图中显示生日

BirthdaysTableViewController 类拥有一个表格视图，用于显示单列项的列表。表格视图包含一个或多个节，每个节包含若干行，而每一行包含一个单元格。表格视图中的节是行的分组，可以选择是否显示标题。一个显示多个节的表格视图的应用示例是设置应用，如图 11-5 所示。它显示了一系列已被拆分成不同节的行。

表格视图的每个分区和行都有一个索引编号。这些编号从 0 开始，然后随着向下滚动表格视图，每行的编号增加 1。例如，设置应用中的隐私行位于第 0 个分区，第 1 行。新闻设置位于第 1 个分区，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个叫做 *Table view data source* 的部分，里面有三个方法。表格视图控制器使用这些方法来决定在其表格视图中显示什么内容。

numberOfSections(in:) 告诉表格视图它应该有多少个分区

tableView(_:numberOfRowsInSection:) 告诉表格视图每个分区中将显示多少行

tableView(_:cellForRowAt:) 设置将要在表格视图每一行显示的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用分区来分组不同设备设置的行。*

每当表格视图重新加载时，表格视图控制器会调用表格视图数据源方法。Xcode 在你创建 UITableViewController 子类时会自动给你这些方法模板。你需要实现这三个方法，以确保应用正常运行，尽管你不会直接在代码中调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，后者提供了这些数据源方法，用来确定表格视图中将显示什么内容。我们将在 “委托” 第 166 页中讨论协议。现在，你只需要知道，UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，所以你无需手动调用它们。

让我们从方法 numberOfSections(in:) 开始。生日表格视图控制器是一个仅显示生日实例的列表，因此它不需要多个分区。要设置表格视图中的分区数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

此方法接受一个 UITableView 类型的参数 tableView，该表格视图使用这个类作为其数据源。我们无需担心建立这个连接，因为 UITableViewController 自带了一个内置的表格视图，并且它会自动与这些方法连接。每个生日都会显示在自己的行中。所以在 tableView(_:numberOfRowsInSection:) 方法中，为了确保你的生日列表有正确数量的行，你需要返回你在 birthdays 数组中拥有的生日实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少个项目，它非常适合这个场景！将这个方法修改为如下：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，tableView(_:numberOfRowsInSection:)还接受一个名为 section 的 Int 类型参数。当表格视图加载时，这个方法会为表格视图中的每个 section 调用。在我们的案例中，只有一个 section，所以我们不需要检查当前显示的是表格视图的哪个 section。我们知道是 section 0，并且希望它有与生日数量相同的行数，因此我们写 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:)方法，以便表格视图知道在每个单元格中放置什么内容。由于这个方法已被注释掉，你需要通过删除/*和*/来取消注释它。（小心不要不小心取消注释后面的其他方法！）取消注释后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要手动调用方法 tableView(_:cellForRowAt:)。它会在表格视图加载到屏幕时自动被调用。每当屏幕上显示一个单元格时，都会调用该方法，并传入两个参数：tableView 和 indexPath。你已经知道 tableView 参数的作用了。IndexPath 是一个 Swift 结构体，用于表示表格视图中某一行的位置。一个 IndexPath 实例包含 section 属性和 row 属性。由于这个方法会被调用多次（每次为表格中的一行），我们需要通过 indexPath 来知道当前正在配置的是哪个 section 和 row。indexPath.section 属性表示 section 编号，indexPath.row 表示表格视图单元格的行号。tableView(_:cellForRowAt:)中的五行代码将完成以下操作：

![](img/Image00244.jpg)

• 创建 UITableViewCell

• 确定在生日数组中哪个生日将显示在单元格内

• 创建两个标签来显示生日人的名字和出生日期

• 返回准备好显示的单元格以供表格视图展示

让我们逐行分析这段代码。

首先，创建 UITableViewCell。在➊处的代码使用方法 dequeueReusableCell(withIdentifier:for:)来完成这项操作。在你开始使用该方法时，必须先告诉它你想使用的单元格来自故事板。之前，你在故事板中为单元格指定了标识符 birthdayCellIdentifier（参见图 11-4）。这个标识符将你的代码与单元格关联起来，并告诉方法它正在使用正确的单元格。当你调用此方法时，字符串必须与故事板中设置的字符串完全相同，否则会出现错误，导致应用崩溃。

在 dequeueReusableCell(withIdentifier:for:) 方法中，你注意到 *Reusable Cell* 这几个词了吗？表格视图中的单元格只会创建一次，然后可以反复使用。这有助于提高运行速度和流畅度，因为创建单元格是最费时的操作。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多的生日时，滚出屏幕顶部的单元格会被重用。它们会被填充新信息，并再次出现在屏幕底部。UITableView 会自动完成这项工作。当表格视图加载时，tableView(_:cellForRowAt:) 会为每一行可见的单元格调用。当用户滚动查看更多单元格时，每当一个单元格即将出现在屏幕上时，它会再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中显示数组中的一个生日。第一个生日，即在 birthdays[0] 处的生日，应该显示在第 0 行。第二个生日，即在 birthdays[1] 处的生日，应该显示在第 1 行，依此类推，这意味着 indexPath 的行号与我们要访问的 birthdays 数组中的位置相同。➋ 处的代码通过使用 indexPath.row 从 birthdays 数组中获取正确的 Birthday 对象。一旦我们得到了正确的 Birthday 对象，我们将其赋值给一个名为 birthday 的常量，以便我们可以设置该单元格中的标签。

注意，我们使用 let 来将生日赋值给常量而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并赋予它自己的 Birthday 对象。由于我们不打算修改任何生日常量——我们只是读取它们的属性——因此不需要将它们声明为变量。

现在你已经有了单元格和生日，是时候填充细节了。你需要为每个单元格准备两个标签，用于显示生日人的姓名和出生日期。你将单元格设置为 Subtitle 样式，这样它就有了 Title 标签和 Subtitle 标签。每个单元格已经包含这些标签，因此你现在不需要自己创建标签。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，两个名字之间有一个空格。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 会在 ➎ 处返回该单元格，以便它可以在表格视图的该 indexPath 位置显示。

### 整合所有内容

现在你可以使用添加生日视图控制器向应用程序中添加生日实例，并且你有一个表视图来列出每个生日，在生日表视图控制器中显示。但是，当你尝试运行应用程序并添加一个生日时，它并没有显示。为了使你添加的每个生日出现在表视图中，你需要让添加生日视图控制器与生日表视图控制器进行通信。你可以通过使用*委托*来做到这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 显示在自己之上。A 知道 B 的存在，因为它创建并呈现了 B，因此 A 可以将信息传递给 B。但 B 并不知道 A——它只是突然出现，并不知道自己是从哪里来的或如何到达的。那么，B 如何与 A 沟通呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将工作或任务交给另一个人做。*委托对象*就像是一个老板，告诉一个被委托的员工做什么。当被委托的员工完成任务时，有时会将信息报告给委托老板。

在 Swift 中，委托（Delegation）非常相似，但不同于有一个老板和员工，我们有一个委托对象和一个委托方对象。由于类 B 是被类 A 告知要做什么的，所以它是委托方对象。我们给类 B 一个特别的属性，称为 delegate，来告诉它它的委托对象是谁——这样，它就知道应该与谁沟通。委托对象可以是任何拥有一组已在*协议*中定义的方法的类。协议就像是两个类之间的协议，告诉它们委托对象可以要求委托方对象做什么。它有一份方法和属性的名称清单，委托对象可以使用这些方法与委托方对象交互。

类 A 创建类 B，将自己设置为类 B 的委托对象，并给类 B 分配一个协议中的任务。一旦类 B 完成它的任务，它会向类 A 报告。让我们来看看在我们的应用中是如何实现的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个协议，称为 AddBirthdayViewControllerDelegate，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用于报告信息。

看一下图 11-6。当用户点击“添加”按钮 ➊ 时，生日表视图控制器会创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托对象。

![](img/Image00246.jpg)

*图 11-6：一个新的生日通过委托从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为包含一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮➌时，AddBirthday 视图控制器会调用此方法 ➍ 并将新的生日对象传递给它的委托——生日表格视图控制器。生日表格视图控制器接收这个生日对象，添加到它的生日数组中，然后重新加载它的表格视图 ➎，这样新的生日就会出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，其中包含方法 addBirthdayViewController(_:didAddBirthday:)，该方法可以在每次向应用程序添加生日时由 Add Birthday 视图控制器调用。生日表格视图控制器将实现这个协议方法，这样每当通过 Add Birthday 视图控制器添加一个生日时，Add Birthday 视图控制器只需告诉它的委托：“嘿！刚刚添加了这个生日。”然后生日表格视图控制器会收到这个消息并回应：“哦！我会把这个加入到我的列表，并刷新显示，确保新的生日出现在表格中。”

现在，让我们在代码中实现这个！

##### 创建一个协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类的*上方*，添加这段代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处定义协议，通过输入关键字 protocol，后跟协议名称 AddBirthdayViewControllerDelegate。这个名字有点长，但 Swift 程序员通常会将协议命名为调用类的名字，然后在末尾加上 Delegate。这样你就可以通过协议的名字知道是哪个类在使用这个协议。既然你现在是一个 Swift 程序员，你应该也遵循这种命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，用于将 Birthday 对象传递回委托类➋。请注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。再次提醒，Swift 程序员通常遵循这种约定来实现协议方法，所以你也应该坚持这样做。这有助于了解是谁发送回了消息，且委托对象可以访问该对象及其类。

当 AddBirthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递进去。你很快就会看到如何做到这一点。另一个需要注意的点是外部参数名 didAddBirthday。许多委托协议方法都包含*did*和*will*这两个词，因为它们用来描述调用类刚做完的事情或将要做的事情。

现在你已经定义了协议，接下来需要告诉生日表格视图控制器采纳这个协议并使用协议中的方法。

##### 让生日表格视图控制器遵循该协议

为了采用协议，Birthdays 表格视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为此，你需要在 UITableViewController 超类之后的类定义中添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate ：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色错误提示就会出现。这是因为 BirthdaysTableViewController 表示它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！别担心，我们很快就会修复这个问题。

在这里需要注意的是，BirthdaysTableViewController 是继承自 UITableViewController 超类的。一个类只能有一个超类，而且这个超类的名字必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议会在超类之后列出，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 BirthdaysTableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。添加该方法的一个好地方是在类的末尾，即导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它预期你会添加这个方法。请注意，与子类方法不同，在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将由 Add Birthday 视图控制器传递的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现这一点 ➋。接下来，你需要刷新表格视图，以便显示这个新生日，方法是调用 tableView 属性的 reloadData() 方法 ➌。当调用 reloadData() 时，表格视图的数据源方法会再次被调用，新的 Birthday 会显示在生日列表的底部。

你可能注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但为了保持良好的编码风格，标记不同的类部分是个不错的做法，它有助于让代码保持清晰易读。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单可以帮助你快速找到方法并跳转到代码中的不同位置。要使用这个菜单，只需点击编辑窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为 AddBirthdayViewController 设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 AddBirthdayViewController 使用该协议来通知 Birthdays 表视图控制器何时添加了生日。为此，AddBirthdayViewController 首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个可选的代理属性，类型为 AddBirthdayViewControllerDelegate，来完成此操作，插入以下代码行到 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在 AddBirthdayViewController 创建之前设置它。稍后你将学习在哪里设置代理。

现在 AddBirthdayViewController 已有了代理，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将生日传递给代理。将 saveTapped(_:) 更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码在 ➊ 通过 addBirthdayViewController(_:didAddBirthday:) 将其传递回代理。

很好！你已经完成了对 AddBirthdayViewController 的更改。现在它有了一个代理，将监听生日已保存的调用。运行应用程序，看看会发生什么。

嗯……似乎变化不大。当你添加一个生日时，你仍然看不到它显示在 Birthdays 表视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

你还需要做最后一件事。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而 AddBirthdayViewController 有一个 AddBirthdayViewControllerDelegate 属性，该属性持有与之通信的代理，当生日被保存时会通知它。但是我们从未明确地将代理属性设置为 Birthdays 表视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在 `BirthdaysTableViewController` 类的导航部分，有一个被注释掉的方法叫做 `prepare(for:sender:)`。请通过删除它前后的 `/*` 和 `*/` 来取消注释该方法。

每当 `Birthdays` 表视图控制器放弃其屏幕并且应用通过 storyboard segue 转到另一个视图控制器时，这个方法会被自动调用。我们将使用这个方法将 `Birthdays` 表视图控制器传递给 `Add Birthday` 视图控制器，并将其设置为 `Add Birthday` 视图控制器的代理。在 `prepare(for:sender:)` 方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

需要三行代码来将 `Add Birthday` 视图控制器的代理设置为 `Birthdays` 表视图控制器。首先，你需要能够从 `segue` 参数中获取到 `AddBirthdayViewController` 对象。Xcode 留下了一个注释，提示你如何做到这一点。`UIStoryboardSegue` 有一个叫做 `destination` 的属性，指向正在准备的 segue 的另一端，但对于这个应用程序，目标并不是 `AddBirthdayViewController`。

在第九章中，你将 `Add Birthday` 视图控制器嵌入到了一个导航控制器中，以便你能够拥有带有取消和保存按钮的导航栏。因此，你并不期望在 segue 的另一端找到 `Add Birthday` 视图控制器。相反，目标是一个包含 `Add Birthday` 视图控制器的 `UINavigationController`。➊ 处的代码可以获取到 `navigationController`。代码 `segue.destination` 将返回一个 `UIViewController`，但由于我们的 `navigationController` 是 `ViewController` 的一个特定类型，我们需要使用 `as` 进行类型转换，将其转换为 `UINavigationController`。

接下来，你可以获取 `Add Birthday` 视图控制器，它是 `navigationController` 的 `topViewController` ➋。`topViewController` 就是当前在 `navigationController` 中显示的视图控制器，但它的属性类型是 `UIViewController`，所以必须进行类型转换，将其转换为 `AddBirthdayViewController`，以表示该控制器是 `UIViewController` 的一个特定子类。最后，当你获得 `AddBirthdayViewController` 后，你可以将代理设置为 `self`，也就是当前的 `Birthdays` 表视图控制器 ➌。

现在运行应用并添加一些生日！你在 `Birthdays` 表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用并重新运行，之前的生日会消失。我们还需要将生日保存到设备中，这将在第十二章中进行。

### 你学到了什么

在本章中，你学会了如何创建一个表视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，并通过代理将生日添加到 `Birthdays` 表视图控制器中的生日数组，以便能够显示出来。

在 第十二章 中，你将学习如何将生日保存到设备上，这样即使退出应用后重新启动，它们依然会显示。为了保存生日，你将使用 Core Data，这是我们在项目开始时设置的。

![](img/Image00238.jpg)

*图 11-4：创建一个副标题样式的表视图单元格并设置其标识符*

接下来，打开属性检查器。使用 **Style** 下拉菜单，将单元格的样式设置为 **Subtitle** ➋，这样单元格就会有一个标题标签和一个副标题标签。你将把每个人的名字显示在标题中，将生日显示在副标题中。

最后，在标识符字段 ➌ 中输入 birthdayCellIdentifier。你将在稍后使用这个标识符来填写单元格的内容。

就这样！你已经完成了故事板中的工作。

你可能会想，为什么在故事板中的表视图里我们只有一个单元格，而列表中有多个生日需要展示。如果你再次查看 图 11-4，你会注意到这个单元格被标记为 *Prototype Cells* 。这意味着你刚刚自定义的单元格是你想要在表视图中显示的所有单元格的 *模板* 。你给单元格的标识符将是你的代码告诉表视图为你创建每个单元格的方式，你将很快看到这如何工作。

**日期操作**

Swift 有一种特殊的数据类型叫做 Date，用于存储日期值。一个 Date 对象实际上包含了日期和时间。打开你的 playground 并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将当前日期和时间（代码运行时的日期和时间）赋值给变量 today。当你打印 today 时，它的格式是 "2017-11-21 10:45:31 +0000\n"。如果你想把它显示为 2017 年 11 月 21 日星期二 呢？或者仅显示 11/21/17 呢？要以特定的方式显示日期，你可以使用 *日期格式化器*，这是一种你创建并为其设置日期格式样式的 DateFormatter 对象。DateFormatter 是一个辅助对象，用于从任何日期创建显示字符串，*日期格式样式* 是 DateFormatter 的一个属性，它告诉格式化器使用哪种样式。你可以手动创建自己的日期格式样式，但 Swift 中也有一些内置的样式，可以直接使用。将以下代码添加到你的 playground 中：

![](img/Image00240.jpg)

在 ➊，你创建了一个格式化器。然后在 ➋，你将格式化器的样式设置为 Style.full，这样就会显示星期几以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:) 方法 ➌ 从日期创建了一个字符串。你可以看到，现在日期已经被转化为格式良好的字符串 "Tuesday, November 21, 2017"。 表 11-1 显示了从 Swift 中五种 DateFormatter.Style 选项创建的不同字符串。

**表 11-1：** 日期格式化样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "2017 年 11 月 21 日" |
| long | "2017 年 11 月 21 日" |
| full | "2017 年 11 月 21 日，星期二" |

你也可以通过`DateFormatter`的 dateFormat 属性指定自定义的日期显示方式。也许你只想显示月份和日期，或者你想以短格式显示四位数的年份。做到这一点其实非常简单，你甚至不需要创建一个新的`DateFormatter` — 只需更改 formatter 的 dateFormat，然后请求一个新的字符串。将以下代码添加到你的 playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在➊，你指定只想要月份和日期，以"MM/dd"格式显示——即，两位数的月份，后跟两位数的日期。如果你想用三个字母显示月份，可以使用 MMM。要显示完整的月份名称，使用 MMMM。在➋，我们将日期格式更改为使用四位数的年份。两位数的年份可以使用 yy。这里有几种其他方式可以使用`dateFormat`来显示自定义日期字符串。

![](img/Image00242.jpg)

如果你想要包含分隔符，可以将它们添加到你的`dateFormat`字符串中。例如，如果你希望使用句号作为分隔符，可以创建像"MM.dd.yy" ➊这样的`dateFormat`。若要显示缩写版的星期几，使用 EEE ➋。要显示完整的星期几，使用 EEEE ➌。这只是几个例子。通过结合使用 M、d、y 和 E，你可以展示日期的无数种方式！

#### 设置 Birthdays 表视图控制器

Birthdays 表视图控制器将显示应用中存储的所有生日的列表。你还记得用什么存储一组数据吗？没错 — 是数组！你将在`BirthdaysTableViewController`中创建一个数组来存储所有的生日。为此，给`BirthdaysTableViewController`添加一个名为`birthdays`的属性，它是一个`Birthday`对象的数组。在类的顶部，即`viewDidLoad()`方法的上方，插入这一行来添加一个名为`birthdays`的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这行代码创建了一个空的`Birthday`实例数组。它需要是一个变量而不是常量，因为你每次通过`Add Birthday`视图控制器添加生日时，都需要将一个保存的生日添加到这个数组中。你将在“使 Birthdays Table View Controller 符合协议”中的第 168 页看到如何操作。

**注意**

*记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

`BirthdaysTableViewController`还需要一个`dateFormatter`属性来以格式化的字符串显示出生日期。将`dateFormatter`添加到`birthdays`数组的下面：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

注意，dateFormatter 是通过 let 创建的常量。即使你会改变 dateFormatter 的属性，比如 dateStyle 和 timeStyle，你也永远不会改变 dateFormatter 本身。

你还需要设置 dateFormatter，以便它将生日日期显示为完整格式的字符串，如“2008 年 12 月 17 日，星期二”。正如你在第十章中看到的，做这件事的好地方是 viewDidLoad() 方法，它在 Birthdays 表格视图控制器加载视图时被调用。这里是进行任何必要设置的理想位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 dateFormatter 的 dateStyle，以便它显示每个生日的格式化日期字符串。你注意到我们只写了 .full 而不是 DateFormatter.Style.full 吗？Swift 知道期望 DateFormatter 的 dateStyle 类型，所以它允许我们使用这个小技巧。在 ➋ 处，你将 dateFormatter 的 timeStyle 设置为 .none，以便不显示时间。

#### 在表格视图中显示生日

BirthdaysTableViewController 类包含一个表格视图，用于显示单列项的列表。表格视图有一个或多个包含行的部分，每一行包含一个单元格。表格视图中的部分是行的分组，可以带有或不带有标题显示。一个显示包含多个部分的表格视图的应用示例是设置应用，如图 11-5 所示。它显示一个已按不同部分拆分的行列表。

表格视图的每个部分和行都通过索引号来标识。这些数字从 0 开始，然后随着你向下浏览表格视图而增加。例如，设置应用中的隐私行位于第零部分，第 1 行。新闻设置则位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为*表格视图数据源*的部分，包含三个方法。表格视图控制器使用这些方法来确定在其表格视图中显示的内容。

numberOfSections(in:) 告诉表格视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表格视图每个部分将显示多少行

tableView(_:cellForRowAt:) 设置要在表格视图的每一行中显示的每个单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分来分组不同设备设置的行。*

表格视图数据源方法在每次表格视图重新加载时都会被表格视图控制器调用。当你创建一个 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现这三个方法才能让应用正常工作，尽管你在代码中不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，协议中包含了这些数据源方法，用于确定表格视图中会显示什么内容。我们将在 “委托” 章节的第 166 页讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，所以你不需要手动调用它们。

我们从方法 `numberOfSections(in:)` 开始。Birthday 表格视图控制器是一个只显示生日实例的列表，所以它不需要多个分区。为了设置表格视图中的分区数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 tableView 的 UITableView 作为参数，它是使用此类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内置的表格视图，并且它会自动连接到这些方法中。每个生日都会显示在自己的行中。所以在 `tableView(_:numberOfRowsInSection:)` 中，为了正确显示所有生日的行数，你需要返回在 birthdays 数组中的生日实例数量。你还记得数组的 `count` 属性吗？它是一个整数，表示数组中有多少项，非常适合这个情况！将这个方法改成如下代码：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，`tableView(_:numberOfRowsInSection:)` 还接受一个名为 section 的 Int 参数。当表格视图加载时，这个方法会为每个分区调用。在我们的例子中，只有一个分区，所以我们不需要费力检查表格视图正在显示哪个分区。我们知道是分区 0，并且我们希望它的行数等于生日的数量，所以我们写 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)`，以便表格视图知道在每个单元格中显示什么内容。由于这个方法被注释掉了，你需要通过删除包围它的 `/*` 和 `*/` 来取消注释它。（小心不要不小心取消注释它后面的其他方法！）完成后，将其修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要手动调用 `tableView(_:cellForRowAt:)` 方法。它会在表格视图加载到屏幕时被调用。对于屏幕上的每个单元格，方法会接受两个参数：`tableView` 和 `indexPath`。你已经知道 `tableView` 参数的作用了。`IndexPath` 是一个 Swift 结构体，用于表示表格视图中一行的位置。一个 `IndexPath` 实例有一个 `section` 属性和一个 `row` 属性。由于这个方法会被多次调用（每次为表格中的一行），我们需要通过 `indexPath` 来知道当前配置的是哪个分区和哪一行。`indexPath.section` 属性返回分区号，而 `indexPath.row` 则返回表格视图单元格的行号。`tableView(_:cellForRowAt:)` 中的五行代码将完成以下工作：

![](img/Image00244.jpg)

• 创建一个 `UITableViewCell`

• 确定在 `birthdays` 数组中的哪个生日会显示在单元格内

• 创建两个标签来显示生日人的名字和生日日期

• 返回准备好显示的单元格

让我们逐行分析这段代码。

首先，创建 `UITableViewCell`。➊ 处的代码通过 `dequeueReusableCell(withIdentifier:for:)` 方法实现这一点。不过，在你使用该方法创建单元格之前，你需要告诉它从故事板中选择哪个单元格。之前在故事板中，你为单元格设置了标识符 `birthdayCellIdentifier`（参见 图 11-4）。这个标识符将你的代码和单元格关联起来，告诉方法它正在使用正确的单元格。当你调用这个方法时，传入的字符串必须与故事板中设置的字符串完全一致，否则会导致错误，应用程序在运行时崩溃。

在方法 `dequeueReusableCell(withIdentifier:for:)` 中，你注意到 *可重用单元格* 这几个词了吗？表格视图中的单元格只会创建一次，然后可以反复使用。这有助于让一切运行得更快、更流畅，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多的生日时，滚出屏幕顶部的单元格会被重用。它们会被填充上新的信息，然后再次出现在屏幕底部。`UITableView` 会自动完成这项工作。当表格视图加载时，会调用 `tableView(_:cellForRowAt:)` 来为每一行生成单元格。当用户滚动查看更多单元格时，方法会在每一行即将显示时再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行显示一个生日，来自生日数组中的一个元素。第一个生日，即 birthday[0]，应该显示在第 0 行。第二个生日，即 birthday[1]，应该显示在第 1 行，依此类推，这意味着 indexPath 的行号与我们想要访问的生日数组中的位置相同。➋处的代码通过使用 indexPath.row 从生日数组中获取正确的生日对象。一旦得到正确的生日对象，我们将其赋值给一个名为 birthday 的常量，以便我们能够设置该单元格中的标签。

注意，我们使用 let 将生日赋值给常量而不是变量。我们之所以使用 let，是因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并且赋值为自己的生日对象。由于我们不打算修改任何生日常量——我们只是读取它们的属性——所以我们不需要将它们定义为变量。

现在你已经有了单元格和生日，是时候填写详细信息了。每个单元格需要两个标签来显示生日人的名字和出生日期。你将单元格设置为副标题样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含这些标签，因此现在你不需要自己创建标签了。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格隔开。➍处，使用 dateFormatter 的 string(from:)方法将出生日期显示在 detailTextLabel 中。

当单元格完全配置好时，tableView(_:cellForRowAt:)在➎处返回该单元格，以便在表格视图的该 indexPath 处显示。

### 将一切结合起来

现在，你可以使用添加生日视图控制器将生日实例添加到应用中，并且你有一个表格视图来列出每个生日，显示在生日表格视图控制器中。但是当你尝试运行应用并添加生日时，它并没有显示。为了让你添加的每个生日出现在表格视图中，你需要让添加生日视图控制器与生日表格视图控制器进行通信。你可以通过使用*委托*来做到这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 展示在自己之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 并不知道 A——它只是突然出现的，根本不知道自己从哪里来，也不知道怎么到达的。那么，B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指将工作或任务交给别人做。一个*委托*就像是一个老板，告诉一个委托员工该做什么。当委托员工完成任务后，有时他们会将信息报告回委托老板。

在 Swift 中，委托模式非常类似，但不是有一个老板和员工，而是有一个委托和一个委托对象。由于类 B 是由类 A 告诉该做什么的，所以它是委托对象。我们给类 B 一个特殊的属性，叫做委托(delegate)，用来告诉它谁是它的委托，这样它就知道应该与谁通信。委托可以是任何具有一组在*协议*中定义的方法的类。协议就像是两个类之间的协议，告诉它们委托可以要求委托对象做什么。它包含了一些方法和属性名称，委托可以使用这些方法和属性与委托对象进行交互。

类 A 创建类 B，将自己设为类 B 的委托，并给类 B 一个需要做的任务，这个任务是在协议中定义的。一旦类 B 完成任务，它会向类 A 报告。让我们来看一下这个在我们的应用中是如何工作的。

Birthdays 表格视图控制器是视图控制器 A，Add Birthday 视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议定义一个方法 addBirthdayViewController(_:didAddBirthday:)，Add Birthday 视图控制器将使用此方法进行回调。

请看一下图 11-6。当用户点击添加按钮➊时，Birthdays 表格视图控制器会创建 Add Birthday 视图控制器➋并将自身设置为 Add Birthday 视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议定义了一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮➌时，Add Birthday 视图控制器调用这个方法➍，并将新的生日传递给它的委托——Birthdays 表格视图控制器。Birthdays 表格视图控制器接收到这个生日，将其添加到它的生日数组中，然后重新加载它的表格视图➎，使新的生日出现在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，其中包含方法 addBirthdayViewController(_:didAddBirthday:)，当在应用中添加生日时，Add Birthday 视图控制器可以调用此方法。Birthdays 表格视图控制器将实现该协议方法，这样每当使用 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器只需对其委托说：“嘿！有人刚刚添加了这个生日。”，而 Birthdays 表格视图控制器将接收到这个消息并回应：“哦！我会把它添加到我的列表中并刷新显示，以便新的生日出现在列表中。”

现在，让我们在代码中实现这个功能吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，*在*AddBirthdayViewController 类之前，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处定义协议，通过键入关键字 protocol 并随后写上协议名 AddBirthdayViewControllerDelegate。这个名字比较长，但 Swift 程序员通常会按照调用类的名称命名协议，并在名称后加上 Delegate 这个词。这样你就可以通过查看协议的名称来知道是哪个类在使用该协议。既然你现在是 Swift 程序员了，你应该遵循同样的命名惯例。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传递回委托类➋。注意，在这个函数中你包含了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员在实现协议方法时，通常会这样做，所以你也应该遵循这一惯例。知道是谁发送了消息，以及让委托能够访问这个对象及其类，是非常有用的。

当 Add Birthday 视图控制器调用此方法时，它会将自身作为 addBirthdayViewController 参数传递。你很快就会看到这是如何实现的。需要注意的另一点是外部参数名 didAddBirthday。许多委托协议方法包含*did*和*will*这两个词，因为它们用来描述调用类刚刚做过的或将要做的事情。

现在你已经定义了协议，接下来需要告诉 Birthdays 表视图控制器去采纳这个协议并使用协议中的方法。

##### 让 Birthdays 表视图控制器遵守协议

为了采纳该协议，Birthdays 表视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，在 UITableViewController 超类之后，添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加一个逗号，然后键入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做了，就会出现一个红色错误。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心，我们很快就会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是从 UITableViewController 超类继承的。一个类只能有一个超类，而且超类的名称必须在任何协议之前写出。但是，尽管一个类只能有一个超类，它可以采纳任意多个协议——这些协议会列在超类之后，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:)方法。一个合适的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期待你添加这个方法。请注意，与子类方法不同，你在 addBirthdayViewController(_:didAddBirthday:)前不会使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递进来的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:)方法来完成这一操作 ➋。接下来，你需要刷新表格视图，以便它显示这个新添加的生日，可以通过在 tableView 属性上调用 reloadData()方法来实现 ➌。当调用 reloadData()时，表格视图的数据源方法将重新被调用，新增的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。虽然这不是必须的，但将类的不同部分进行标记是良好的编码风格，它有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是一个 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单帮助你找到方法，并允许你跳转到代码中的不同位置。要使用这个菜单，点击编辑窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内建的目录，可以快速跳转到某一部分。*

##### 为 Add Birthday 视图控制器设置委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表格视图控制器何时添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性来安排这件事，将以下一行插入到 outlets 下方：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为直到*Add Birthday 视图控制器*被创建后，你才能设置它。你很快就会学到在哪里设置委托。

现在“添加生日”视图控制器有了代理，在 `saveTapped(_:)` 方法中，你可以通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将一个生日对象传递给代理。将 `saveTapped(_:)` 方法改成如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象后，➊ 处的代码通过 `addBirthdayViewController(_:didAddBirthday:)` 将其传回给代理。

很棒！你已经完成了对“添加生日”视图控制器的修改。现在它有了一个代理，用来监听生日保存的事件。运行应用程序，看看会发生什么。

嗯……没有太大变化。当你添加一个生日时，它仍然没有出现在“生日”表视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有一件事需要做。“生日”表视图控制器是 `AddBirthdayViewControllerDelegate`，而“添加生日”视图控制器有一个 `AddBirthdayViewControllerDelegate` 类型的属性，用来存储它在保存生日时与之通信的代理。但我们从未明确设置该代理属性为“生日”表视图控制器。因此，现在是时候连接这两个视图控制器之间的通信管道了。

在 `BirthdaysTableViewController` 类的导航部分，有一个被注释掉的方法 `prepare(for:sender:)`。通过删除其前后的 `/*` 和 `*/` 注释符号来取消注释该方法。

当“生日”表视图控制器离开当前界面并通过 storyboard segue 转到另一个视图控制器时，该方法会自动被调用。我们将使用此方法将“生日”表视图控制器传递到“添加生日”视图控制器，以将其自身设置为“添加生日”视图控制器的代理。在 `prepare(for:sender:)` 方法中编写如下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的代理为“生日”表视图控制器只需三行代码。首先，你需要能够通过 segue 参数访问 `AddBirthdayViewController` 对象。Xcode 在注释中提供了如何实现这一点的提示。一个 `UIStoryboardSegue` 有一个名为 `destination` 的属性，指向正在此方法中准备的 segue 另一端的目标视图控制器，但该应用的目标视图控制器并不是 `AddBirthdayViewController`。

在第九章中，你将“添加生日”视图控制器嵌入到了导航控制器中，这样你就可以拥有带有“取消”和“保存”按钮的导航栏。因此，你不指望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 `UINavigationController`。➊ 处的代码让你获取到 `navigationController`。代码 `segue.destination` 将返回一个 `UIViewController`，但是由于我们的 `navigationController` 是特定类型的视图控制器，我们需要使用 `as` 将其强制转换为 `UINavigationController`。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其强制转换为 AddBirthdayViewController，表明这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 后，可以将代理设置为 self，当前的代理是 Birthdays 表格视图控制器 ➌。

现在运行应用并添加一些生日！你会在 Birthdays 表格视图控制器中看到什么？生日！生日！生日！不过，我们还没有完成。如果你退出应用，然后重新启动它，之前添加的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在这一章中，你学会了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加生日，然后如何使用代理将生日添加到 Birthdays 表格视图控制器中的 birthdays 数组中，以便可以显示它。

在第十二章中，你将学会如何将生日保存到你的设备中，这样即使退出应用再重新运行，生日也会显示出来。为了保存生日，你将使用 Core Data，这是我们在项目开始时就设置好的。

*图 11-4：创建一个副标题样式的表格视图单元格并设置其标识符*

接下来，打开属性检查器。在 **样式** 下拉菜单中，将单元格样式设置为 **副标题** ➋，这样单元格就会有一个标题标签和一个副标题标签。你将把每个人的名字显示在标题中，把生日显示在副标题中。

最后，在标识符字段 ➌ 中输入 birthdayCellIdentifier。稍后你将使用此标识符来填充单元格内容。

就是这样！你已经完成了 storyboard 中的工作。

你可能会想，为什么我们在 storyboard 中的表格视图只有一个单元格，而我们需要在列表中显示多个生日。如果你再看一下图 11-4，你会注意到单元格标有 *原型单元格*。这意味着你刚刚自定义的单元格是所有你想要在表格视图中显示的单元格的 *模板*。你给单元格的标识符是你的代码用来告诉表格视图生成每个单元格的方式，以便将生日放入其中。你很快就会看到它是如何工作的。

**处理日期**

Swift 有一个名为 Date 的特殊数据类型，用于存储日期值。Date 对象实际上是日期和时间。打开你的 playground，输入以下内容：

![](img/Image00239.jpg)

我们刚刚将运行代码时的当前日期和时间赋值给变量 today。当你打印 today 时，它的格式是 "2017-11-21 10:45:31 +0000\n"。如果你希望它显示为 Tuesday, November 21, 2017，或者只是 11/21/17 该怎么办？为了以特定方式显示日期，你可以使用*日期格式化器*，它是一个你创建的 DateFormatter 对象，并给它指定一个日期格式样式。DateFormatter 是一个帮助对象，用来从任何日期创建显示字符串，而*日期格式样式*是 DateFormatter 的一个属性，用来告诉格式化器使用什么样式。你可以手动创建自己的日期格式样式，但 Swift 中也包含了一些现成的样式可以使用。将以下代码添加到你的 Playground 中：

![](img/Image00240.jpg)

在➊，你创建了一个格式化器。然后在➋，你将格式化器的样式设置为 Style.full，这样就会打印星期几以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:)方法➌将日期转换为字符串。你可以看到，现在你已经将日期转换为格式良好的字符串 "Tuesday, November 21, 2017"。表 11-1 展示了使用 Swift 中五种 DateFormatter.Style 选项创建的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "Nov 21, 2017" |
| long | "November 21, 2017" |
| full | "Tuesday, November 21, 2017" |

你还可以使用 DateFormatter 的 dateFormat 属性指定自定义的日期显示方式。也许你只想要月份和日期，或者你可能想要以短格式显示四位数的年份。做这两件事都非常简单，而且你不需要创建新的 DateFormatter——只需更改 formatter 的 dateFormat，然后请求它返回新的字符串。将以下代码添加到你的 Playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在➊，你指定只想要月份和日期，采用 MM/dd 格式——即两位数的月份，后跟两位数的日期。如果你想要将月份显示为三个字母，可以使用 MMM。如果想要显示月份的全名，使用 MMMM。在➋，我们将日期格式改为使用四位数的年份。两位数的年份使用 yy。这里还有一些其他使用 dateFormat 显示自定义日期字符串的方法。

![](img/Image00242.jpg)

如果你想包含分隔符，可以将它们添加到你的 dateFormat 字符串中。例如，如果你想要句点作为分隔符，可以创建一个像 "MM.dd.yy" ➊ 的 dateFormat。如果想要显示缩写的星期几，使用 EEE ➋。如果显示完整的星期几，使用 EEEE ➌。这些只是一些示例。通过使用 M、d、y 和 E 的组合，你可以用无数种方式显示日期！

#### 设置生日表视图控制器

Birthdays 表视图控制器将显示应用中存储的所有生日的列表。你还记得用什么来存储项目列表吗？没错——数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有生日。为此，给 BirthdaysTableViewController 添加一个名为 birthdays 的属性，它是一个 Birthday 对象数组。在类的顶部，紧接着 viewDidLoad() 方法上方，插入以下代码来添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这行代码创建了一个空的 Birthday 实例数组。它需要是变量而非常量，因为你每次用户通过添加生日视图控制器添加生日时，都需要将已保存的生日添加到这个数组中。你将在 “使 Birthdays Table View Controller 遵循协议” 章节中看到如何操作，第 168 页。

**注意**

*请记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性，以便将出生日期显示为格式化良好的字符串。请在出生日期数组下方添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，通过 let 创建。尽管你会更改 dateFormatter 的属性，如 dateStyle 和 timeStyle，但你永远不会更改 dateFormatter 本身。

你还需要设置 dateFormatter，以便它将出生日期显示为完全格式化的字符串，如 "Tuesday, December 17, 2008"。正如你在 第十章 中看到的，执行此操作的好地方是 viewDidLoad() 方法，它在 Birthdays 表视图控制器加载其视图时被调用。这是进行此类设置的理想位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 dateFormatter 的 dateStyle，使其为每个生日显示格式化的日期字符串。你注意到我们只是写了 .full 而不是 DateFormatter.Style.full 吗？Swift 知道 DateFormatter 的 dateStyle 应该是什么类型，所以它允许我们使用这个小技巧。在 ➋ 处，你将 dateFormatter 的 timeStyle 设置为 .none，这样时间就不会显示了。

#### 在表视图中显示生日

BirthdaysTableViewController 类具有一个表视图，用于显示单列中的项目列表。表视图包含一个或多个部分，每个部分中有若干行，每行包含一个单元格。表视图中的部分是按行分组的，可以带有或不带有标题。例如，显示多个部分的表视图应用有设置应用程序，如 图 11-5 所示。它显示了一列已分组为不同部分的行。

表视图的每个部分和每一行都有一个索引号来标识。这些数字从 0 开始，向下递增。例如，设置应用程序中的“隐私”行位于部分 0，行 1。新闻设置位于部分 1，行 3。

在`BirthdaysTableViewController`类的中间，有一个名为*表视图数据源*的部分，包含了三个方法。表视图控制器使用这些方法来确定在表视图中显示的内容。

numberOfSections(in:) 告诉表视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表视图每个部分将显示多少行

tableView(_:cellForRowAt:) 设置每一行中要显示的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用程序使用部分来将不同的设备设置分组。*

表视图数据源方法每次表视图重新加载时都会被表视图控制器调用。Xcode 在你创建`UITableViewController`的子类时会自动为你提供这些方法模板。即使你在代码中从不直接调用这些方法，你也需要实现这三个方法以保证应用的正常运行。`UITableViewController`类实现了`UITableViewDataSource`协议，该协议包含这些数据源方法，用于确定表视图中将显示的内容。我们将在“委托”一章的第 166 页讨论协议。现在，你只需要知道`UITableViewController`使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要手动调用它们。

让我们从方法`numberOfSections(in:)`开始。`Birthdays`表视图控制器是一个仅显示生日实例的列表，因此它不需要多个部分。要设置表视图中的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

该方法接受一个名为`tableView`的 UITableView 作为参数，这是使用该类作为数据源的表视图。我们无需担心建立这个连接，因为`UITableViewController`自带一个内建的表视图，并且这个表视图会自动连接到这些方法上。每个生日将显示在它自己的行中。因此，在`tableView(_:numberOfRowsInSection:)`方法中，为了确保有正确数量的行来展示所有的生日，你需要返回`birthdays`数组中生日实例的数量。你还记得数组的`count`属性吗？它是一个整数，告诉你数组中有多少项，非常适合这种情况！将这个方法修改为如下：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，tableView(_:numberOfRowsInSection:) 还需要一个名为 section 的 Int 类型参数。当表格视图加载自身时，这个方法会为表格中的每一节调用一次。在我们的例子中，只有一个节，所以我们不需要担心检查当前显示的是哪个节。我们知道是第零部分，并且我们希望它有和 birthdays 数量一样多的行数，所以我们写下 return birthdays.count 。

最后，你需要实现 tableView(_:cellForRowAt:) 方法，以便表格视图知道在每个单元格中放入什么内容。由于这个方法已经被注释掉，你需要通过删除包围它的 /* 和 */ 来取消注释。（小心不要不小心取消注释它后面的其他方法！）在你做完这些后，将其修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法 tableView(_:cellForRowAt:) 。它是在表格视图加载到屏幕上时被调用的。它会为屏幕上的每个单元格调用一次，并且接受两个参数：tableView 和 indexPath 。你已经知道 tableView 参数是干什么用的了。IndexPath 是一个 Swift 结构体，用于表示表格视图中某一行的位置。一个 IndexPath 实例有一个 section 属性和一个 row 属性。由于这个方法会被多次调用（每个表格中的行会调用一次），所以我们需要 indexPath 来知道当前配置的是哪一节和哪一行。indexPath.section 属性给出节号，indexPath.row 给出表格视图单元格的行号。tableView(_:cellForRowAt:) 中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定在 birthdays 数组中哪个生日将显示在单元格中

• 创建两个标签来显示生日者的名字和生日日期

• 返回准备好显示的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell 。➊ 处的代码使用方法 dequeueReusableCell(withIdentifier:for:) 来完成这一操作。虽然在你可以开始使用这个方法之前，你需要告诉它想要从故事板中使用哪个单元格。早些时候，当你在故事板中时，你给你的单元格设置了标识符 birthdayCellIdentifier （见 图 11-4 ）。这个标识符将你的代码与单元格关联起来，并告诉你的方法它正在使用正确的单元格。调用此方法时传递的字符串必须与故事板中设置的字符串完全一致，否则你会遇到错误，应用程序在运行时会崩溃。

在方法`dequeueReusableCell(withIdentifier:for:)`中，你是否注意到*Reusable Cell*这几个词？表视图中的单元格只会创建一次，然后可以反复使用。这有助于提高运行速度和流畅度，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能显示 10 个，那么你只需要 10 个单元格来展示这些生日。当你向下滚动以查看更多生日时，滚出屏幕顶部的单元格会被重新使用。它们会被填充新的信息，然后再次出现在屏幕底部。UITableView 会自动完成这些工作。当表视图加载时，`tableView(_:cellForRowAt:)`会为每一行可见的单元格调用。当用户滚动查看更多单元格时，它会在每个即将出现在屏幕上的行上再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们想要在每一行中显示`birthdays`数组中的一个生日。第一个生日，位于`birthdays[0]`，应该显示在第 0 行。第二个生日，位于`birthdays[1]`，应该显示在第 1 行，依此类推，这意味着`indexPath`的行数与我们想要访问的`birthdays`数组中的位置相同。➋处的代码通过使用`indexPath.row`访问`birthdays`数组中的正确生日对象。一旦我们获得了正确的生日对象，我们将其分配给一个名为`birthday`的常量，以便我们可以设置该单元格中的标签。

请注意，我们使用`let`将生日分配给常量，而不是变量。我们可以使用`let`是因为每次调用`tableView(_:cellForRowAt:)`时，都会创建一个新的`birthday`常量。每个单元格都会获得一个自己的`birthday`常量，并分配给自己的生日对象。由于我们不会改变任何生日常量——我们只是读取它们的属性——因此我们不希望将它们设置为变量。

现在你已经有了单元格和生日，是时候填充细节了。你需要为每个单元格添加两个标签来显示生日人的名字和出生日期。你将单元格设置为“副标题”样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，因此现在你不需要自己创建标签了。

这些标签作为`UITableViewCell`的属性存在，分别称为`textLabel`和`detailTextLabel`。➌处的代码将`textLabel`的文本设置为由生日人的名字（`firstName`）和姓氏（`lastName`）组成的字符串，两者之间有一个空格。在➍处，你使用`dateFormatter`的`string(from:)`方法在`detailTextLabel`中显示出生日期。

当你的单元格完全配置好后，`tableView(_:cellForRowAt:)`会在➎返回该单元格，以便它可以在表视图的该`indexPath`位置显示。

### 将所有内容整合起来

现在你可以使用添加生日视图控制器向应用程序添加生日实例，并且在生日表格视图控制器中有一个表格视图来列出每个生日。但是，当你尝试运行应用并添加一个生日时，它并没有显示出来。为了使你添加的每个生日在表格视图中显示，你需要让添加生日视图控制器与生日表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托模式。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己的上面。A 知道 B，因为它创建并呈现了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它只是突然出现，并不知道自己是从哪里来的或者是如何到达那里的。那么 B 怎么能与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将工作或任务交给他人执行。*委托者*就像是一个老板，告诉委托员工该做什么。当委托员工完成任务时，他们有时会向委托者报告信息。

在 Swift 中，委托模式与之非常相似，但我们没有老板和员工，而是有委托者和委托对象。由于类 B 是被类 A 告诉该做什么的，因此它是委托对象。我们给类 B 一个特殊的属性，称为 delegate，用来告诉它它的委托者是谁——这样它就知道该与谁进行通信。委托者可以是任何实现了*协议*中定义的一组方法的类。协议就像是两类之间的约定，告诉它们委托者可以要求委托对象做什么。协议中列出了委托者可以与委托对象一起使用的方法和属性名称。

类 A 创建类 B，将自己设为类 B 的委托者，并给类 B 分配一个在协议中定义的任务。一旦类 B 完成任务，它会向类 A 报告。我们来看看这个在我们的应用中是如何工作的。

生日表格视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用来报告结果。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表格视图控制器会创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托者。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从添加生日视图控制器传递到生日表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮➌时，AddBirthdayViewController 会调用这个方法 ➍，并将新添加的生日传递给它的代理——Birthdays 表视图控制器。Birthdays 表视图控制器会将这个生日添加到它的生日数组中，然后重新加载表视图 ➎，这样新添加的生日就会出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，其中包含方法 addBirthdayViewController(_:didAddBirthday:)，该方法会在每次添加生日到应用程序时由 AddBirthdayViewController 调用。Birthdays 表视图控制器将实现该协议方法，这样每当通过 AddBirthdayViewController 添加一个生日时，AddBirthdayViewController 就可以告诉它的代理，“嘿！有人刚刚添加了这个生日，”然后 Birthdays 表视图控制器会收到消息并说，“哦！我会把这个添加到我的列表中，并刷新显示，这样新添加的生日就会显示出来。”

现在，让我们在代码中实现这一点！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，*在*AddBirthdayViewController 类的上方，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在第 ➊ 步通过输入关键字 protocol 并随后输入 AddBirthdayViewControllerDelegate 这个名字来定义协议。这个名字很长，但 Swift 程序员通常会根据调用类的名字来命名协议，并在末尾加上“Delegate”一词。这样你就可以通过协议的名字来知道是哪个类在使用这个协议。既然你现在是一个 Swift 程序员，你也应该遵循这种命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，用于将 Birthday 对象传递回代理类 ➋。请注意，在这个函数中你包含了 AddBirthdayViewController 作为一个参数。再次强调，Swift 程序员在实现协议方法时通常按照约定这么做，所以你也应该遵循这一做法。这样做的好处是你可以知道是谁发送了消息，同时代理可以访问该对象及其类。

当 AddBirthdayViewController 调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递。你很快就会看到这怎么实现。另一个需要注意的是外部参数名 didAddBirthday。许多代理协议方法中都会包含*did*和*will*这两个词，因为它们用来描述调用类刚刚完成的或即将完成的某个操作。

现在你已经定义了协议，接下来需要告诉 Birthdays 表视图控制器采用这个协议，并使用协议的方法。

##### 使 Birthdays 表视图控制器符合协议

为了采用这个协议，`BirthdaysTableViewController`需要让自己成为`AddBirthdayViewControllerDelegate`。为了实现这一点，你需要在类定义中，在`UITableViewController`超类之后添加`AddBirthdayViewControllerDelegate`。在类的顶部，在`UITableViewController`后面加一个逗号，然后输入`AddBirthdayViewControllerDelegate:`。

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，就会出现一个红色错误提示。发生这种情况是因为`BirthdaysTableViewController`声明自己是一个`AddBirthdayViewControllerDelegate`，但是它还没有实现这个协议！为了做到这一点，它需要实现`AddBirthdayViewControllerDelegate`协议定义。别担心，我们很快就会修复这个问题。

这里需要特别注意的是，`BirthdaysTableViewController`是`UITableViewController`的子类。一个类只能有一个超类，并且超类名必须写在任何协议之前。但是，虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议会在超类之后列出，并且用逗号分隔。

现在，为了遵循`AddBirthdayViewControllerDelegate`协议并修复错误，我们需要在`BirthdaysTableViewController`中添加`addBirthdayViewController(_:didAddBirthday:)`方法。一个好的添加位置是类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成功能会建议你整个方法声明。这是因为它知道这个类采用了`AddBirthdayViewControllerDelegate`协议，并且它期待你添加这个方法。请注意，与子类化方法不同，在`addBirthdayViewController(_:didAddBirthday:)`之前，你不需要使用`override`关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将`AddBirthday`视图控制器传递过来的`Birthday`添加到`birthdays`数组中。你可以使用数组的`append(_:)`方法来实现这一点 ➋。接下来，你需要刷新表格视图，以便显示这个新的生日，通过调用`tableView`属性的`reloadData()`方法 ➌。当调用`reloadData()`时，表格视图的数据源方法将被重新调用，新的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但标记类的不同部分是一个良好的编程风格，它有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是一个 Xcode 识别的特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录中，你可以在类的顶部使用该菜单。这个下拉菜单帮助你找到方法，并让你跳转到代码中的不同位置。要使用这个菜单，点击编辑窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知 Birthdays 表视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个可选的代理属性，类型为 AddBirthdayViewControllerDelegate，来安排这一点，方法是在 outlets 下面插入以下行：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在 Add Birthday 视图控制器创建之前设置它。你将很快学到在哪里设置代理。

现在 Add Birthday 视图控制器有了代理，在`saveTapped(_:)`方法中，你可以使用`addBirthdayViewController(_:didAddBirthday:)`方法将生日传递给代理。将`saveTapped(_:)`更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象后，➊处的代码通过`addBirthdayViewController(_:didAddBirthday:)`将其传回给代理。

很棒！你已经完成了对 Add Birthday 视图控制器的更改。它现在有了一个代理，能够监听生日保存的调用。运行应用程序，看看会发生什么。

嗯...没有太大变化。当你添加一个生日时，你仍然看不到它出现在 Birthdays 表视图控制器中。怎么回事？

#### 通过设置代理连接这两个控制器

还有一件事你需要做。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，持有它在保存生日时与之通信的代理。但是我们从未特别设置代理属性为 Birthdays 表视图控制器。所以现在是时候在两个视图控制器之间建立通信管道了。

在“生日”表视图控制器类的“导航”部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除 /* 和 */ 来取消注释此方法。

当“生日”表视图控制器放弃其屏幕并通过 storyboard segue 转到另一个视图控制器时，此方法会被自动调用。我们将使用此方法将“生日”表视图控制器传递到“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的委托。在 prepare(for:sender:) 方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器委托到“生日”表视图控制器需要三行代码。首先，您需要能够通过 segue 参数访问到 AddBirthdayViewController 对象。Xcode 已经在注释中提示了如何实现这一点。一个 UIStoryboardSegue 有一个名为 destination 的属性，它指向正在此方法中准备的 segue 另一端，但该应用的目的地并不是 AddBirthdayViewController。

在第九章中，您将“添加生日”视图控制器嵌入到一个导航控制器中，这样您就可以拥有一个带有取消和保存按钮的导航栏。因此，您不会期望在 segue 的另一端找到“添加生日”视图控制器。相反，目的地是一个 UINavigationController，它包含“添加生日”视图控制器。➊ 这一行代码帮助你获取 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定子类，因此需要使用 as 进行类型转换，将其转换为 UINavigationController。

接下来，您可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 是当前显示在 navigationController 中的视图控制器，但其属性类型是 UIViewController，因此必须将其强制转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的特定子类。最后，当您获得 AddBirthdayViewController 后，您可以将委托设置为 self，即当前的“生日”表视图控制器 ➌。

现在运行应用并添加一些生日！在“生日”表视图控制器中看到什么？生日！生日！生日！不过我们还没有完成。如果退出应用并重新运行，之前添加的生日将会消失。我们仍然需要将生日保存到设备上，这将在第十二章中进行。

### 你学到了什么

在本章中，您学习了如何创建一个表视图控制器来显示您的生日列表。您还学会了如何在“添加生日”视图控制器中添加生日，然后如何使用委托将生日添加到“生日”表视图控制器中的生日数组，以便显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用程序并重新运行，它们也会显示出来。为了保存生日，你将使用 Core Data，这是我们在项目开始时设置的。

接下来，打开属性检查器。在 **Style** 下拉菜单中，设置单元格的样式为 **Subtitle** ➋，这样单元格就有了一个标题标签和一个副标题标签。你将在标题中显示每个人的姓名，在副标题中显示生日。

最后，在标识符字段 ➌ 中输入 birthdayCellIdentifier。稍后在填写单元格内容时，你会用到这个标识符。

就这样！你已经完成了故事板中的工作。

你可能会想，为什么我们在故事板中只在表视图中有一个单元格，而我们实际上会在列表中显示多个生日。如果你再看看图 11-4，你会注意到该单元格标记为 *原型单元格*。这意味着你刚刚自定义的单元格是你希望出现在表视图中的所有单元格的 *模板*。你为单元格指定的标识符就是你的代码用来告诉表视图为你生成每个单元格，以便你可以填充生日的方式。你很快就会看到这个是如何工作的。

**处理日期**

Swift 有一个特殊的数据类型叫做 Date，用于存储日期值。Date 对象实际上包含日期和时间。打开你的 playground，输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量 today。当你打印 today 时，它的格式是 "2017-11-21 10:45:31 +0000\n"。如果你希望它显示为 Tuesday, November 21, 2017 呢？或者只是 11/21/17 呢？要以特定的方式显示日期，你需要使用 *日期格式化器*，它是一个 DateFormatter 对象，你可以创建并为其设置日期格式样式。DateFormatter 是一个帮助对象，用于从任何日期创建显示字符串，*日期格式样式* 是 DateFormatter 的一个属性，告诉格式化器使用哪种样式。你可以手动创建自己的日期格式样式，但 Swift 中也包含了一些预定义的样式，可以直接使用。将以下内容添加到你的 playground：

![](img/Image00240.jpg)

在 ➊ 处，你创建了一个格式化器。然后在 ➋ 处，你将格式化器的样式设置为 Style.full，这将打印出星期几以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:) 方法从日期中创建一个字符串 ➌。你可以看到，现在你已经将日期转换成了格式良好的字符串 "Tuesday, November 21, 2017"。表 11-1 显示了 Swift 中从五种 DateFormatter.Style 选项创建的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "Nov 21, 2017" |
| long | "November 21, 2017" |
| full | "Tuesday, November 21, 2017" |

你还可以使用 DateFormatter 的 dateFormat 属性来指定自定义的日期显示方式。也许你只想显示月份和日期，或者你希望四位数的年份以简短样式显示。无论哪种方式，都非常简单，你甚至不需要创建一个新的 DateFormatter ——只需更改 formatter 上的 dateFormat，然后请求它返回一个新的字符串。将以下代码添加到你的 Playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定只想显示 MM/dd 格式的月份和日期——也就是两位数的月份后跟两位数的日期。如果你想将月份显示为三字母缩写，则使用 MMM。如果要显示完整的月份名称，使用 MMMM。在 ➋ 处，我们将日期格式更改为使用四位数的年份。两位数的年份为 yy。这里有一些其他使用 dateFormat 来显示自定义日期字符串的方法。

![](img/Image00242.jpg)

如果你想添加分隔符，可以将它们添加到 dateFormat 字符串中。例如，如果你想使用句点作为分隔符，你可以创建一个类似 "MM.dd.yy" ➊ 的 dateFormat。要显示简写的星期几，可以使用 EEE ➋。要显示完整的星期几名称，使用 EEEE ➌。这些只是一些例子。通过组合 M、d、y 和 E，你可以创建无数种显示日期的方式！

#### 设置 Birthdays 表格视图控制器

Birthdays 表格视图控制器将显示应用中存储的所有生日列表。你还记得用什么来存储项目列表吗？没错——数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有的生日。为此，在类的顶部，即 `viewDidLoad()` 方法上方，插入这一行代码，添加一个名为 birthdays 的数组属性，用于存储 Birthday 对象：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行代码创建了一个空的 Birthday 实例数组。它需要是一个变量，而不是常量，因为每当用户通过添加生日视图控制器添加一个生日时，你将需要将该生日添加到这个数组中。你将在 “使 Birthdays 表格视图控制器符合协议” 第 168 页 中看到如何做到这一点。

**注意**

*记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性来将生日显示为格式化良好的字符串。在 birthdays 数组下方添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，使用 let 创建。尽管你会更改 dateFormatter 的属性，例如 dateStyle 和 timeStyle，但你永远不会改变 dateFormatter 本身。

你还需要设置 `dateFormatter`，使其能够将出生日期显示为完全格式化的字符串，如 "Tuesday, December 17, 2008"。正如你在 第十章 中看到的，一个很好的地方是 `viewDidLoad()` 方法，它会在 `Birthdays` 表格视图控制器加载其视图时调用。这是进行此类初始化设置的完美时机。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 `dateFormatter` 的 `dateStyle`，使其能够显示每个生日的格式化日期字符串。你有没有注意到我们是写 `.full` 而不是 `DateFormatter.Style.full`？Swift 知道 `DateFormatter` 的 `dateStyle` 应该是什么类型，所以它允许我们使用这个小快捷方式。在 ➋ 处，你将 `dateFormatter` 的 `timeStyle` 设置为 `.none`，这样时间就不会显示出来。

#### 在表格视图中显示生日

`BirthdaysTableViewController` 类有一个表格视图，用于显示单列项的列表。表格视图包含一个或多个部分，每个部分包含几行，而每一行包含一个单元格。表格视图中的一个部分是行的分组，可以选择带有或不带有标题来显示。一个显示有多个部分的表格视图的应用示例是设置应用，如 图 11-5 所示。它显示了被分成不同部分的行列表。

表格视图的每个部分和行都有一个索引号来标识。这些数字从 0 开始，然后随着你向下滚动表格视图依次增加。例如，设置应用中的隐私选项位于第零部分，第 1 行；新闻设置位于第一部分，第 3 行。

在 `BirthdaysTableViewController` 类的中间，有一个名为 *Table view data source* 的部分，其中包含三个方法。表格视图控制器使用这些方法来决定在其表格视图中显示什么内容。

numberOfSections(in:) 告诉表格视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表格视图每个部分将显示多少行

tableView(_:cellForRowAt:) 设置每个将要在表格视图每一行中显示的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分将不同的设备设置行分组。*

表视图数据源方法会在每次表视图重新加载时被表视图控制器调用。当你创建 `UITableViewController` 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现所有三个方法，以便应用正常工作，即使你在代码中从未直接调用它们。`UITableViewController` 类实现了 `UITableViewDataSource` 协议，其中包含这些数据源方法，用于确定在表视图中显示什么内容。我们将在第 166 页的 “委托” 章节中讨论协议。现在，你只需要知道 `UITableViewController` 使用这些方法来显示内容，并且会自动调用这些方法，所以你不需要手动调用它们。

让我们从方法 `numberOfSections(in:)` 开始。生日表视图控制器是一个仅显示生日实例的列表，因此它不需要多个部分。为了设置表视图中的部分数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法以一个 `UITableView`（命名为 `tableView`）作为参数，表示使用这个类作为其数据源的表视图。我们不需要担心建立这个连接，因为 `UITableViewController` 自带了一个内建的表视图，自动与这些方法连接。每个生日将显示在自己的一行中。因此，在 `tableView(_:numberOfRowsInSection:)` 方法中，为了拥有正确数量的行来显示所有生日，你需要返回 `birthdays` 数组中 `Birthday` 实例的数量。你还记得数组的 `count` 属性吗？它是一个整数，告诉你数组中有多少个元素，非常适合这种情况！将此方法更改为以下代码：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 `tableView` 参数外，`tableView(_:numberOfRowsInSection:)` 还接受一个名为 `section` 的 `Int`。当表视图加载时，这个方法会为表视图中的每个部分被调用。在我们的例子中，只有一个部分，所以我们不需要检查正在显示的是表视图的哪个部分。我们知道是第零部分，并且我们希望它有和生日数量一样多的行，所以我们写 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)`，这样表视图就知道每个单元格里应该放什么内容。由于这个方法被注释掉了，你需要通过删除围绕它的 `/*` 和 `*/` 来取消注释。（小心不要不小心取消注释后面的其他方法！）完成后，将其改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用`tableView(_:cellForRowAt:)`方法。它是在表格视图加载到屏幕时被调用的。它会为屏幕上的每个单元格被调用，并且有两个参数，tableView 和 indexPath。你已经知道 tableView 参数的用途了。IndexPath 是一个 Swift 结构体，用来表示表格视图中某一行的位置。一个 IndexPath 实例有一个 section 属性和一个 row 属性。由于这个方法会被多次调用（每次调用对应一个表格中的行），我们需要 indexPath 来知道当前正在配置的是哪一节和哪一行。indexPath.section 属性返回节号，而 indexPath.row 返回表格视图单元格的行号。`tableView(_:cellForRowAt:)`方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建 UITableViewCell

• 找出将在单元格中显示的 birthdays 数组中的生日

• 创建两个标签，用于在单元格中显示生日人的姓名和出生日期

• 返回准备好在表格视图中显示的单元格

让我们逐行查看这段代码。

首先，创建 UITableViewCell。➊处的代码使用`dequeueReusableCell(withIdentifier:for:)`方法来实现这一点。不过，在开始使用这个方法之前，你需要告诉它你要在故事板中使用哪个单元格。早些时候，当你在故事板中时，你给你的单元格指定了标识符 birthdayCellIdentifier（见图 11-4）。这个标识符将你的代码和单元格连接起来，并告诉你的方法它正在使用正确的单元格。当你调用这个方法时，传入的字符串必须与在故事板中设置的字符串完全一致，否则你会收到错误，应用程序运行时会崩溃。

在`dequeueReusableCell(withIdentifier:for:)`方法中，你注意到有“*Reusable Cell*”这个词吗？表格视图中的单元格只会创建一次，然后可以重复使用。这有助于提升性能，使得应用运行得更快、更流畅，因为创建单元格是最耗时的。如果你的应用中有 200 个生日，但一次只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动显示更多的生日时，滚出屏幕的单元格会被重用。它们会被填充新数据，并再次出现在屏幕的底部。UITableView 会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)`方法会为每个可见的行被调用。当用户滚动查看更多单元格时，每当新行即将出现在屏幕上时，这个方法会再次被调用。

接下来，我们需要找出应该显示在哪个单元格中的生日。我们希望在每一行显示 birthdays 数组中的一个生日。第一个生日，位于 birthdays[0]，应该显示在第 0 行；第二个生日，位于 birthdays[1]，应该显示在第 1 行，依此类推，这意味着 indexPath 的 row 与我们想要访问的 birthdays 数组中的位置相同。➋ 处的代码通过使用 indexPath.row 从 birthdays 数组中访问正确的 Birthday 对象。一旦我们得到了正确的 Birthday 对象，我们将其赋值给一个名为 birthday 的常量，以便我们可以设置这个单元格中的标签。

请注意，我们使用 let 来将生日赋值给常量而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的 birthday 常量。每个单元格都会有自己的 birthday 常量，并为其分配自己的 Birthday 对象。由于我们不会更改任何 birthday 常量——我们只是读取它们的属性——所以我们不想将它们定义为变量。

现在你已经有了单元格和生日，接下来是填充详细信息。每个单元格需要两个标签来显示生日人的姓名和出生日期。你将单元格设置为 Subtitle 样式，这样它就会有一个 Title 标签和一个 Subtitle 标签。每个单元格已经包含了这些标签，因此现在你不需要自己创建标签了。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。 ➌ 处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格隔开。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView( _:cellForRowAt:) 在 ➎ 返回该单元格，以便它可以显示在表格视图的该 indexPath 位置。

### 整合所有内容

现在你可以使用 Add Birthday 视图控制器向应用程序中添加生日实例，并且你有一个表格视图来列出每个生日，显示在 Birthdays 表格视图控制器中。但是，当你尝试运行应用程序并添加一个生日时，它并没有显示出来。为了让你添加的每个生日都出现在表格视图中，你需要让 Add Birthday 视图控制器与 Birthdays 表格视图控制器进行通信。你可以通过使用 *代理模式* 来实现这一点。

#### 代理模式

代理模式可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在它自己上面。A 知道 B，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但是 B 不知道 A——它只是突然出现的，根本不知道它来自哪里或是如何到达那里。那么 B 如何与 A 通信呢？通过代理模式！

![](img/Image00245.jpg)

委托是指某人将任务或工作交给别人来做。*代理* 就像是告诉委托员工该做什么的老板。当委托员工完成任务后，有时他们会将信息报告给代理老板。

Swift 中的委托与此类似，不过我们不再有老板和员工，而是有代理和委托对象。由于类 B 是由类 A 告诉该做什么的，所以它是委托对象。我们给类 B 一个特殊的属性，叫做代理，来告诉它谁是它的代理，这样它就知道该与谁通信。代理可以是任何实现了*协议*中定义方法的类。协议就像是两个类之间的协议，告诉它们代理可以要求委托对象做什么。它列出了代理可以与委托对象一起使用的方法和属性名。

类 A 创建类 B，使其成为类 B 的代理，并给类 B 分配一个协议中定义的任务。一旦类 B 完成任务，它会向类 A 报告。让我们看看这个在我们的应用中是如何工作的。

生日表格视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议定义一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用来报告结果。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表格视图控制器创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：新生日通过代理从添加生日视图控制器传递到生日表格视图控制器。*

定义 AddBirthdayViewControllerDelegate 协议时，协议中包含一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，添加生日视图控制器会调用此方法 ➍ 并将新生日传递给其代理，即生日表格视图控制器。生日表格视图控制器接收到这个生日后，将其添加到生日数组中，然后重新加载表格视图 ➎，使新生日在表格中显示出来。

我们将展示如何创建一个名为 AddBirthdayViewControllerDelegate 的协议，其中包含一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法由添加生日视图控制器在每次向应用添加生日时调用。生日表格视图控制器将实现该协议方法，这样每当通过添加生日视图控制器添加生日时，添加生日视图控制器只需对其代理说：“嘿！有人刚刚添加了这个生日”，而生日表格视图控制器会接收到这个消息，并回应说：“哦！我会把它添加到我的列表中并刷新显示，这样新生日就能显示出来。”

现在让我们用代码来实现这一点吧！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，*在* AddBirthdayViewController 类上方，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过输入关键字 `protocol` 后跟协议名称 AddBirthdayViewControllerDelegate 来定义协议 ➊。这个名字虽然很长，但 Swift 程序员通常会以调用类的名称命名协议，并在名称后加上 Delegate 这个词。这样你就能通过协议的名称知道是哪个类在使用这个协议。既然你现在是一个 Swift 程序员，你也应该使用相同的命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)` 是唯一的函数，它用于将 Birthday 对象传递回委托类 ➋。注意，你在这个函数中包括了 AddBirthdayViewController 作为一个参数。再次强调，Swift 程序员在实现协议方法时通常遵循这一惯例，所以你也应该遵循这种做法。知道是谁发送回消息并且让委托能够访问这个对象及其类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 `addBirthdayViewController` 参数传递进来。你将很快看到如何实现这一点。另一个需要注意的事情是外部参数名 `didAddBirthday`。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用于描述调用类刚刚做完的事情或者将要做的事情。

现在你已经定义了协议，接下来你需要告诉 Birthdays 表视图控制器去采纳这个协议并使用协议的方法。

##### 使 Birthdays Table View Controller 遵循协议

要采用协议，Birthdays 表视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中将 AddBirthdayViewControllerDelegate 添加到 UITableViewController 超类之后。你需要在类顶部的 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做了，就会出现一个红色的错误。这是因为 BirthdaysTableViewController 声明自己是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快会修复这个问题。

这里需要特别注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，且这个超类的名称必须写在任何协议之前。但尽管一个类只能有一个超类，它可以采用任意数量的协议——这些协议会在超类后面列出，并用逗号隔开。

现在，为了遵守 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:)方法。一个好的添加位置是在类的末尾，紧接着导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成建议了整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它期待你添加这个方法。请注意，不同于子类化的方法，在 addBirthdayViewController(_:didAddBirthday:)前你不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递进来的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:)方法来完成这一点 ➋。接下来，你需要刷新表视图，以便它显示这个新添加的生日，通过在 tableView 属性上调用 reloadData()方法 ➌。当调用 reloadData()时，表视图的数据源方法将被重新调用，新增的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。虽然这不是必须的，但用这种方式标记类的不同部分是一种良好的编码风格，有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的一个特殊关键词，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉式目录菜单中，你可以在类的顶部使用该菜单。这个下拉菜单帮助你找到方法，并让你能够跳转到代码中的不同位置。要使用这个菜单，点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内建的目录，帮助你快速跳转到某个部分。*

##### 给 Add Birthday 视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在，轮到让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来告诉 Birthdays 表视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中插入以下一行来安排这一点，这一行应该放在 outlets 之后：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你无法在 Add Birthday 视图控制器创建之前设置它。你很快就会学到在哪里设置代理。

现在，添加生日视图控制器已经有了委托，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日对象传递给委托。将 saveTapped(_:) 方法改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 方法将其传回给委托。

很好！你已经完成了对添加生日视图控制器的更改。它现在有了一个委托，用于监听生日保存的事件。运行应用程序，看看会发生什么。

嗯……似乎没什么变化。当你添加生日时，你依然看不到它在 Birthdays 表视图控制器中显示出来。怎么回事？

#### 通过设置委托连接两个控制器

还有一件事需要做。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它存储与之通讯的委托对象，当生日被保存时会与它沟通。但我们从未明确设置委托属性为 Birthdays 表视图控制器。因此，现在是时候连接我们两个视图控制器之间的通讯管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除其前后的 /* 和 */ 注释符号来取消注释该方法。

每当 Birthdays 表视图控制器放弃屏幕并且应用程序通过 storyboard segue 切换到另一个视图控制器时，这个方法会自动调用。我们将使用此方法将 Birthdays 表视图控制器传递给添加生日视图控制器，并将其设置为添加生日视图控制器的委托。在 prepare(for:sender:) 方法中写入如下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码就可以将添加生日视图控制器的委托设置为 Birthdays 表视图控制器。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 提供了一条注释，提示你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，指向正在准备的 segue 目标，但对于这个应用程序，目标并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到一个导航控制器中，这样你就可以拥有一个带有“取消”和“保存”按钮的导航栏。因此，你不期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊ 处的代码将获取 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定类型，因此我们需要使用 `as` 进行类型转换，将其转为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你得到一个 AddBirthdayViewController 时，你可以将代理设置为 self，它当前是 Birthdays 表视图控制器 ➌。

现在运行应用并添加一些生日！你在 Birthdays 表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用并重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备，这将在 第十二章 中完成。

### 你学到的知识

在本章中，你学会了如何制作一个表视图控制器来显示你的生日列表。你还学会了如何在 Add Birthday 视图控制器中添加生日，然后如何使用代理将生日添加到 Birthdays 表视图控制器中的生日数组，以便显示出来。

在 第十二章 中，你将学习如何将生日保存到你的设备中，这样即使退出应用并重新运行，它们也会显示出来。为了保存生日，你将使用 Core Data，这是我们在项目开始时设置的。

最后，在 Identifier 字段 ➌ 中输入 birthdayCellIdentifier。你稍后将在填充单元格内容时使用这个标识符。

就这样！你已经完成了故事板中的工作。

你可能会想，为什么在我们的故事板中的表视图里只有一个单元格，而我们要显示多个生日。如果你再次查看 图 11-4，你会注意到这个单元格被标记为 *原型单元格*。这意味着你刚刚自定义的单元格是所有你想在表视图中显示的单元格的 *模板*。你给单元格的标识符就是你的代码告诉表视图为你生成每个单元格的方式，以便填入生日。你很快就会看到这如何工作。

**处理日期**

Swift 有一个特殊的数据类型叫做 Date，用于存储日期值。一个 Date 对象实际上包含了日期和时间。打开你的 Playground 并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间分配给变量 today。当你打印 today 时，它的格式是"2017-11-21 10:45:31 +0000\n"。如果你希望它以"Tuesday, November 21, 2017"的形式显示呢？或者只显示"11/21/17"呢？为了以特定的方式显示日期，你可以使用*日期格式化器*，这就是你创建的一个 DateFormatter 对象，并为其设置日期格式样式。DateFormatter 是一个辅助对象，用于从任何日期创建显示字符串，而*日期格式样式*是 DateFormatter 的一个属性，用来告诉格式化器应该使用什么样式。你可以手动创建自己的日期格式样式，但 Swift 中也有一些样式已经包含并准备好使用。将以下代码添加到你的 playground 中：

![](img/Image00240.jpg)

在➊处，你创建了一个格式化器。然后在➋处，你将格式化器的样式设置为 Style.full，这样它将显示星期几的名称，以及完整的月份名称、日期和年份。最后，你通过 DateFormatter 类的 string(from:)方法➌将日期转化为字符串。你可以看到，你现在已经将日期转化为格式良好的字符串"Tuesday, November 21, 2017"。 表 11-1 显示了 Swift 中五种 DateFormatter.Style 选项所生成的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "2017 年 11 月 21 日" |
| long | "November 21, 2017" |
| full | "Tuesday, November 21, 2017" |

你还可以使用 DateFormatter 的 dateFormat 属性指定自定义的日期显示方式。也许你只想显示月份和日期，或者你希望在简短格式中显示四位数的年份。做任何一项都非常简单，你甚至不需要创建新的 DateFormatter——你只需更改 formatter 的 dateFormat，然后要求它生成一个新的字符串。将以下代码添加到你的 playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在➊处，你指定了只想要月份和日期，以 MM/dd 格式显示——也就是两位数的月份后面跟着两位数的日期。如果你想将月份显示为三个字母，可以使用 MMM。要显示完整的月份名称，使用 MMMM。在➋处，我们将日期格式更改为四位数的年份。两位数的年份则使用 yy。这里是一些其他方式，使用 dateFormat 来显示自定义的日期字符串。

![](img/Image00242.jpg)

如果你想包含分隔符，可以将它们添加到你的 dateFormat 字符串中。例如，如果你想要使用句点作为分隔符，你可以创建一个像"MM.dd.yy"的 dateFormat➊。要显示简写的星期几，使用 EEE➋。要显示完整的星期几，使用 EEEE➌。这只是一些例子。通过使用 M、d、y 和 E 的组合，你可以有无数种方式来显示日期！

#### 设置生日表视图控制器

Birthdays 表格视图控制器将显示应用程序中存储的所有生日的列表。你记得用什么来存储项目列表吗？没错——数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有生日。为此，在类的顶部，viewDidLoad() 方法的上方，插入这一行来添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量，而不是常量，因为你希望每次用户通过添加生日视图控制器添加生日时，都会将一个保存的生日添加到此数组中。你将会在 “使 Birthdays 表格视图控制器符合协议” 中看到如何实现这一点，见第 168 页。

**注意**

*请记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *获取。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性，以便将出生日期显示为格式良好的字符串。在 birthdays 数组下方添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，它是通过 let 创建的。即使你会修改 dateFormatter 的属性，比如 dateStyle 和 timeStyle，你永远不会改变 dateFormatter 本身。

你还需要设置 dateFormatter，以便它可以将出生日期显示为完全格式化的字符串，例如 "Tuesday, December 17, 2008"。正如你在第十章中看到的，进行此操作的好地方是 viewDidLoad() 方法，该方法会在 Birthdays 表格视图控制器加载视图时被调用。这里是进行任何所需设置的完美地点。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 dateFormatter 的 dateStyle 属性，以便它能够为每个生日显示格式化的日期字符串。你注意到我们直接写了 .full 而不是 DateFormatter.Style.full 吗？Swift 知道 dateStyle 应该是什么类型，因此允许我们使用这个小快捷方式。在 ➋ 处，你将 dateFormatter 的 timeStyle 设置为 .none，以便不显示时间。

#### 在表格视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于显示单列项目列表。表格视图包含一个或多个包含行的节，每一行都包含一个单元格。表格视图中的节是行的分组，可以带有或不带有标题。一个显示多个节的表格视图应用程序的示例是设置应用，如图 11-5 所示。它显示了一列已被拆分成不同节的行。

表视图的每个部分和行都有一个索引号来标识。这些数字从 0 开始，然后在你向下滚动表视图时，每行的数字递增 1。例如，在设置应用中，隐私行位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为 *Table view data source* 的部分，包含三个方法。表视图控制器使用这些方法来确定将显示在其表视图中的内容。

numberOfSections(in:) 告诉表视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表视图每个部分将显示多少行

tableView(_:cellForRowAt:) 设置每个将显示在表视图每一行中的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用通过部分来分组不同设备设置的行。*

每当表视图被重新加载时，表视图控制器会调用表视图的数据源方法。当你创建一个 UITableViewController 的子类时，Xcode 会自动为你提供这些方法的模板。你需要实现所有三个方法才能使应用程序正常工作，即使你在代码中从未直接调用过它们。UITableViewController 类实现了 UITableViewDataSource 协议，其中包含这些数据源方法，用于确定表视图中将显示什么内容。我们将在“委托”第 166 页讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要自己调用它们。

让我们从方法 numberOfSections(in:) 开始。Birthdays 表视图控制器是一个仅显示生日实例的列表，因此它不需要多个部分。要设置表视图的部分数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法以一个 UITableView 类型的参数 tableView，它是使用此类作为数据源的表视图。我们不需要担心建立这个连接，因为 UITableViewController 内置了一个自动连接到这些方法的表视图。每个生日将显示在自己的行中。因此，在 tableView(_:numberOfRowsInSection:) 方法中，为了拥有正确数量的行来显示所有生日，你需要返回你在 birthdays 数组中的 Birthday 实例数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少项，它非常适合这个情况！将此方法更改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，tableView(_:numberOfRowsInSection:) 方法还接受一个名为 section 的 Int。当表视图加载时，这个方法会为每个部分调用一次。在我们的例子中，只有一个部分，所以我们不需要检查当前显示的是表视图的哪个部分。我们知道它是部分 0，我们希望它有和 birthdays 数组一样多的行数，因此我们写 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:) 方法，以便表视图知道在每个单元格中放置什么内容。由于这个方法被注释掉了，你需要删除它前后的 /* 和 */ 来取消注释。（小心不要不小心取消注释它后面的其他方法！）完成后，将其改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会调用方法 tableView(_:cellForRowAt:)。这个方法在表视图加载到屏幕时被调用。它会为屏幕上的每个单元格调用，并且接受两个参数：tableView 和 indexPath。你已经知道 tableView 参数的用途了。IndexPath 是一个 Swift 结构体，用来表示表视图中某行的位置。一个 IndexPath 实例有两个属性：section 和 row。由于这个方法会被多次调用（每行都会调用一次），我们需要 indexPath 来知道当前正在配置的是哪个部分和行。indexPath.section 属性返回部分号，而 indexPath.row 返回表视图单元格的行号。tableView(_:cellForRowAt:) 中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建 UITableViewCell

• 确定 birthdays 数组中将显示在单元格中的生日

• 创建两个标签，用于在单元格中显示生日人物的姓名和出生日期

• 返回已准备好显示在表视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。代码 ➊ 使用方法 dequeueReusableCell(withIdentifier:for:) 来实现这个功能。然而，在你开始在单元格上使用这个方法之前，你需要告诉这个方法你想从故事板中使用哪个单元格。之前，当你在故事板中时，你为单元格设置了标识符 birthdayCellIdentifier（参见 图 11-4）。这个标识符将你的代码与单元格连接起来，并告诉你的方法它正在使用正确的单元格。当你调用这个方法时，传递的字符串必须与在故事板中设置的字符串完全相同，否则会出现错误，并且在运行时应用程序会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:)中，你注意到*Reusable Cell*这个词了吗？表格视图中的单元格只会创建一次，然后可以反复使用。这有助于提高运行速度，因为创建单元格是最耗时的。如果你的应用中有 200 个生日，但一次只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以查看更多生日时，屏幕顶部滚动出去的单元格会被重用。它们会填充新的信息并再次出现在屏幕底部。UITableView 会自动完成这些工作。当表格视图加载时，tableView(_:cellForRowAt:)会为每个可见的行调用。当用户滚动查看更多单元格时，它会再次为每一行调用，就在它即将出现在屏幕上时。

接下来，我们需要找出哪一个生日应该显示在单元格中。我们希望每一行显示一个生日，生日数组中的第一个生日（即 birthdays[0]）应该显示在第 0 行。第二个生日（即 birthdays[1]）应该显示在第 1 行，以此类推，这意味着 indexPath 的行数与我们想要访问的生日数组中的位置相同。➋处的代码通过使用 indexPath.row 来从 birthdays 数组中获取正确的 Birthday 对象。一旦我们得到了正确的 Birthday 对象，我们将其赋值给一个名为 birthday 的常量，以便我们可以在这个单元格中设置标签。

请注意，我们使用 let 将生日赋值给一个常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，且每个常量都被赋予了自己的 Birthday 对象。由于我们不会改变任何生日常量——我们只是读取它们的属性——所以不需要将它们设为变量。

现在你已经有了单元格和生日，是时候填写详细信息了。你需要为每个单元格添加两个标签来显示生日人的姓名和出生日期。你将单元格设置为副标题样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，所以现在你不需要自己创建任何标签。

这些标签作为 UITableViewCell 的属性存在，分别被称为 textLabel 和 detailTextLabel。在➌的代码中，textLabel 的文本被设置为由生日人的 firstName 和 lastName 组成的字符串，中间用一个空格隔开。在➍处，你使用 dateFormatter 的 string(from:)方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:)会返回单元格➎，以便它能够在表格视图的那个 indexPath 上显示。

### 将一切整合在一起

现在，你可以通过添加生日视图控制器将生日实例添加到应用程序中，并且你有一个表格视图来列出每个生日，在生日表格视图控制器中显示。但是，当你尝试运行应用并添加生日时，它没有显示。为了让你添加的每个生日在表格视图中显示，你需要使添加生日视图控制器与生日表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 呈现在自己之上。A 知道 B，因为它创建并呈现了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它只是突然出现的，并不知道它是从哪里来的或如何到达的。那么，B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托就是当某人将工作或任务交给另一个人时。一个*委托*就像是老板告诉委托员工做什么。当委托员工完成任务后，有时他们会将信息报告给委托的老板。

Swift 中的委托与其他语言中的委托非常相似，但我们没有老板和员工，而是有一个委托者和一个委托对象。由于类 B 是被类 A 告知做什么的，它就是委托对象。我们给类 B 一个特殊的属性，称为 delegate，来告诉它它的委托是谁——这样，类 B 就知道与谁进行通信。委托可以是任何具有一组在*协议*中定义的方法的类。协议就像是两个类之间的约定，告诉它们委托可以要求委托对象做什么。它包含了委托可以与委托对象一起使用的方法和属性名称列表。

类 A 创建类 B，使自己成为类 B 的委托，并赋予类 B 一个在协议中规定的任务。一旦类 B 完成任务，它就会向类 A 报告。让我们看看这个如何在我们的应用中运作。

生日表格视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法：addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用来回报。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表格视图控制器创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：通过委托，新的生日被添加并从添加生日视图控制器传递到生日表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为具有一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，添加生日视图控制器会调用该方法 ➍，并将新添加的生日传递给其委托——生日表格视图控制器。生日表格视图控制器接收该生日，将其添加到其生日数组中，然后重新加载其表格视图 ➎，这样新生日就能显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，该协议包含方法 addBirthdayViewController(_:didAddBirthday:)，该方法可以在每次向应用程序添加生日时由添加生日视图控制器调用。生日表格视图控制器将实现该协议方法，以便每当使用添加生日视图控制器添加生日时，添加生日视图控制器可以对其委托对象说：“嘿！刚刚有人添加了这个生日”，生日表格视图控制器将听到这个消息并说：“哦！我会将其添加到我的列表中，并刷新我的显示，使新的生日能够显示出来。”

现在，让我们开始编写代码吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类的*上方*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过在 ➊ 处输入关键字 protocol，后跟协议名 AddBirthdayViewControllerDelegate 来定义该协议。这个名字很长，但 Swift 程序员通常会根据调用类的名称来命名协议，并在最后加上 Delegate 这个词。这样，你就可以通过查看协议的名称来知道哪个类在使用该协议。既然你现在是一个 Swift 程序员，你也应该遵循相同的命名规范。

在此协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，用于将生日对象传递回委托类 ➋。请注意，你在此函数中包含了 AddBirthdayViewController 作为参数。同样，Swift 程序员在实现协议方法时，通常会这么做，所以你也应该遵循这一做法。知道是谁发送了消息并让委托有机会访问该对象及其类是很有用的。

当添加生日视图控制器调用此方法时，它会将自身作为 addBirthdayViewController 参数传递。你很快就会看到如何实现这一点。另一个需要注意的点是外部参数名称 didAddBirthday。许多委托协议方法包含*did*和*will*这两个词，因为它们用来描述调用类刚刚做了某事或将要做某事。

现在，你已经定义好了协议，需要告诉生日表格视图控制器采用这个协议并使用该协议的方法。

##### 让生日表格视图控制器符合协议

为了采用该协议，BirthdaysTableViewController 需要将自己声明为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中，在 UITableViewController 超类之后添加 AddBirthdayViewControllerDelegate。你只需在类的顶部，在 UITableViewController 后面加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，一个红色错误就会出现。之所以会发生这种情况，是因为 BirthdaysTableViewController 表示它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会修复这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，而且超类的名称必须在任何协议之前写出。但尽管一个类只能有一个超类，它可以采用任意多个协议——这些协议将被列在超类之后，并且用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个好的位置是在类的末尾，紧接在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它期待你添加这个方法。请注意，与子类方法不同，你在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法需要被覆盖。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传入的 Birthday 添加到 birthdays 数组中。你可以使用数组的 append(_:) 方法来实现这一点 ➋。接下来，你需要刷新表格视图，确保它显示这个新的生日，通过调用 tableView 属性的 reloadData() 方法 ➌。当调用 reloadData() 时，表格视图的数据源方法会重新被调用，新的生日会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但标记类的不同部分是良好的编码风格，它有助于保持代码的清晰和可读性。注释的第一部分 `MARK: -` 是一个 Xcode 识别的特殊关键词，它将 `AddBirthdayViewControllerDelegate` 部分添加到一个下拉目录中，你可以在类的顶部使用该菜单。这个下拉菜单帮助你找到方法，并让你跳转到代码中的不同位置。要使用这个菜单，点击编辑器窗格顶部的 `Birthdays TableViewController`，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类内置了一个目录，可以快速跳转到某个章节。*

##### 给 Add Birthday 视图控制器设置委托

`BirthdaysTableViewController` 已经采用了 `AddBirthdayViewControllerDelegate` 协议。现在是时候让 `Add Birthday` 视图控制器使用 `AddBirthdayViewControllerDelegate` 协议，告诉 `Birthdays` 表视图控制器它已经添加了一个生日。为此，`Add Birthday` 视图控制器首先需要定义一个委托。我们通过在 `AddBirthdayViewController` 类中添加一个可选的 `AddBirthdayViewControllerDelegate` 类型的委托属性，并将以下代码插入到 outlets 下面来安排这一点：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为你不能在 *Add Birthday* 视图控制器创建之前设置它。你稍后将学到在哪里设置委托。

现在，既然 Add Birthday 视图控制器有了委托，那么在 `saveTapped(_:)` 方法中，你可以使用 `addBirthdayViewController(_:didAddBirthday:)` 方法将一个 Birthday 传递给委托。将 `saveTapped(_:)` 修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象后，➊ 处的代码使用 `addBirthdayViewController(_:didAddBirthday:)` 方法将其传回委托。

很棒！你已经完成了对 Add Birthday 视图控制器的更改。它现在有一个委托，将监听生日保存的回调。运行应用程序看看会发生什么。

嗯……似乎没有太大变化。当你添加一个生日时，仍然没有在 `Birthdays` 表视图控制器中看到它。怎么回事？

#### 通过设置委托连接两个控制器

还有一件事需要做。`Birthdays` 表视图控制器是 `AddBirthdayViewControllerDelegate`，而 `Add Birthday` 视图控制器有一个 `AddBirthdayViewControllerDelegate` 属性，用于保存它在保存生日时所交互的委托。但我们从未明确设置委托属性为 `Birthdays` 表视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在“BirthdayTableViewController”类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除其前后的/*和*/，取消注释该方法。

每当“生日”表视图控制器放弃其屏幕并且应用通过 storyboard segue 过渡到另一个视图控制器时，这个方法会自动调用。我们将使用这个方法将“生日”表视图控制器传递到“添加生日”视图控制器，并将其自身设置为“添加生日”视图控制器的委托。在 prepare(for:sender:)方法中写入以下内容：

*BirthdayTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码就可以将“添加生日”视图控制器的委托设置为“生日”表视图控制器。首先，你需要能够通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 已经在注释中提示了如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，表示正在准备的 segue 的目标，但这个应用的目标并不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到了一个导航控制器中，这样你就可以有一个带有“取消”和“保存”按钮的导航栏。所以你不期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊的这一行代码可以获取 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 ViewController 的特定类型，我们需要使用 as 进行类型转换。

接下来，你可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须进行类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获得一个 AddBirthdayViewController 时，你可以将委托设置为 self，当前是“生日”表视图控制器 ➌。

现在运行应用并添加一些生日！你在“生日”表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用然后重新运行，之前添加的生日将会消失。我们还需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在这一章中，你学会了如何制作一个表视图控制器来展示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，然后通过使用委托将生日添加到“生日”表视图控制器的生日数组中，以便可以展示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用程序并重新运行，它们仍然会显示出来。为了保存生日，你将使用 Core Data，这也是我们在项目一开始时设置的内容。

就这样！你已经完成了故事板中的工作。

你可能会想，为什么在我们的故事板中的表格视图里只有一个单元格，而我们在列表中会展示多个生日。如果你再次查看图 11-4，你会注意到该单元格被标记为*原型单元格*。这意味着你刚刚自定义的单元格是你希望在表格视图中显示的所有单元格的*模板*。你给单元格的标识符是你的代码如何告诉表格视图为你生成每个单元格以放入生日的方式。你很快就会看到它是如何工作的。

**日期处理**

Swift 有一个特殊的数据类型叫做 Date，用于存储日期值。一个 Date 对象实际上包含了日期和时间。打开你的 playground 并输入以下内容：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量 today。当你打印 today 时，它的格式是"2017-11-21 10:45:31 +0000\n"。如果你想让它显示为“2017 年 11 月 21 日，星期二”呢？或者仅仅是 11/21/17 呢？为了以特定方式显示日期，你需要使用*日期格式化器*，它是一个你创建并赋予日期格式样式的 DateFormatter 对象。DateFormatter 是一个辅助对象，用于从任何日期创建显示字符串，*日期格式样式*是 DateFormatter 的一个属性，告诉格式化器使用什么样式。你可以手动创建自己的日期格式样式，但 Swift 中也有一些现成的样式可以使用。将以下内容添加到你的 playground：

![](img/Image00240.jpg)

在➊你创建了一个格式化器。然后在➋，你将格式化器的样式设置为 Style.full，它将打印出星期几以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:)方法在➌中从日期创建了一个字符串。你可以看到，你现在已经将日期转换为格式良好的字符串"2017 年 11 月 21 日，星期二"。表 11-1 显示了通过 Swift 中五种 DateFormatter.Style 选项生成的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "2017 年 11 月 21 日" |
| long | "2017 年 11 月 21 日" |
| full | "2017 年 11 月 21 日，星期二" |

你还可以使用 `DateFormatter` 的 dateFormat 属性指定自定义的日期显示方式。也许你只想显示月份和日期，或者你可能希望年份以简短样式显示四位数字。实现这两种方式都非常简单，而且你甚至不需要创建一个新的 `DateFormatter` ——你只需更改 formatter 上的 dateFormat，然后请求一个新的字符串。将以下代码添加到你的 Playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定了只想要显示月份和日期，格式为 MM/dd——也就是两位数的月份，后面跟着两位数的日期。如果你想显示三字母缩写的月份，可以使用 MMM。如果想显示完整的月份名称，使用 MMMM。在 ➋ 处，我们将日期格式更改为使用四位数的年份。两位数的年份是 yy。以下是其他一些使用 `dateFormat` 来显示自定义日期字符串的方法。

![](img/Image00242.jpg)

如果你想包括分隔符，可以将它们添加到 `dateFormat` 字符串中。例如，如果你想要句点作为分隔符，你可以创建一个类似 "MM.dd.yy" 的 `dateFormat` ➊ 。要显示缩写的星期几，使用 EEE ➋ 。要显示完整的星期几，使用 EEEE ➌ 。这些只是一些例子。通过组合 M、d、y 和 E，你可以有无尽的方式来显示日期！

#### 设置 Birthdays 表格视图控制器

Birthdays 表格视图控制器将显示应用程序中存储的所有生日的列表。你还记得用什么来存储一个项目列表吗？没错——是数组！你将在 `BirthdaysTableViewController` 中创建一个数组来存储所有的生日。为此，给 `BirthdaysTableViewController` 添加一个名为 birthdays 的属性，它是一个 `Birthday` 对象的数组。在类的顶部，紧接着 `viewDidLoad()` 方法上方，插入这一行来添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 `Birthday` 实例数组。它需要是一个变量，而不是常量，因为每次用户通过添加生日视图控制器添加生日时，你都需要将一个已保存的生日添加到这个数组中。你将在 “使 Birthdays 表格视图控制器符合协议” 的 第 168 页 中看到如何操作。

**注意**

*记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

`BirthdaysTableViewController` 还需要一个 `dateFormatter` 属性，用来将出生日期显示为格式化的字符串。在 birthdays 数组下方添加一个 `dateFormatter`：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，`dateFormatter` 是一个常量，它是通过 `let` 创建的。尽管你会更改 `dateFormatter` 的属性，例如 `dateStyle` 和 `timeStyle`，你永远不会改变 `dateFormatter` 本身。

你还需要设置 `dateFormatter`，以便它将生日显示为完整格式的字符串，如 "Tuesday, December 17, 2008"。正如你在第十章中看到的，进行此设置的好地方是 `viewDidLoad()` 方法，该方法在 `Birthdays` 表视图控制器加载其视图时调用。这是进行任何必要设置的完美时机。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 `dateFormatter` 的 `dateStyle`，使其显示每个生日的格式化日期字符串。你是否注意到我们只写了 `.full`，而不是 `DateFormatter.Style.full`？Swift 知道 `DateFormatter` 的 `dateStyle` 应该是什么类型，所以它允许我们使用这个小捷径。在 ➋ 处，你将 `dateFormatter` 的 `timeStyle` 设置为 `.none`，以确保时间不会显示出来。

#### 在表视图中显示生日

`BirthdaysTableViewController` 类有一个表视图，用于在单列中显示项目列表。该表视图有一个或多个包含行的部分，每一行都包含一个单元格。表视图中的部分是行的分组，可以选择性地显示或不显示标题。显示多个部分的表视图的应用示例是设置应用，如图 11-5 所示。它显示了一个将行分成不同部分的列表。

表视图的每个部分和行都有一个索引编号。这些数字从 0 开始，向下递增。例如，设置应用中的隐私行位于部分 0，第 1 行。新闻设置位于部分 1，第 3 行。

在 `BirthdaysTableViewController` 类的中间，有一个名为 *Table view data source* 的部分，包含三个方法。该表视图控制器使用这些方法来确定将显示在其表视图中的内容。

`numberOfSections(in:)` 告诉表视图应该有多少个部分

`tableView(_:numberOfRowsInSection:)` 告诉表视图每个部分将显示多少行

`tableView(_:cellForRowAt:)` 设置将显示在表视图每一行中的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分来将不同设备设置的行分组。*

每次表格视图重新加载时，表格视图控制器都会调用表格视图的数据源方法。当你创建一个 `UITableViewController` 的子类时，Xcode 会自动为你提供这些方法模板。为了让应用正常工作，你需要实现所有三个方法，尽管你在代码中永远不会直接调用它们。`UITableViewController` 类实现了 `UITableViewDataSource` 协议，其中包含这些数据源方法，用于确定表格视图中将显示的内容。我们将在 “委托” 第 166 页讨论协议。现在，你只需要知道，`UITableViewController` 使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要手动调用它们。

我们从方法 `numberOfSections(in:)` 开始。Birthdays 表格视图控制器是一个只显示生日实例的列表，因此不需要多个部分。为了设置表格视图中的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

该方法接受一个名为 `tableView` 的 `UITableView` 作为参数，`tableView` 是使用此类作为数据源的表格视图。我们不需要担心建立此连接，因为 `UITableViewController` 附带了一个内置的表格视图，该表格视图会自动连接到这些方法。每个生日都会显示在自己的行中。因此，在 `tableView(_:numberOfRowsInSection:)` 中，为了正确显示所有生日的行数，你需要返回 `birthdays` 数组中生日实例的数量。你还记得数组的 `count` 属性吗？它是一个整数，告诉你数组中有多少项，正好适合这种情况！将此方法更改为以下代码：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 `tableView` 参数，`tableView(_:numberOfRowsInSection:)` 还接受一个名为 `section` 的 `Int` 参数。当表格视图正在加载时，该方法会为表格视图中的每个部分被调用。在我们的例子中，只有一个部分，因此我们不需要担心检查正在显示哪个部分。我们知道是第零部分，并且我们希望它有与生日数量相等的行数，所以我们写下 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)`，以便表格视图知道每个单元格中应该放入什么内容。由于此方法被注释掉了，你需要通过删除包围它的 `/*` 和 `*/` 来取消注释它。（小心不要不小心取消注释它后面的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法 `tableView(_:cellForRowAt:)`。它是在表格视图加载到屏幕上时被调用的。它会为屏幕上的每一行单元格调用，并接受两个参数，tableView 和 indexPath。你已经知道 tableView 参数的作用。IndexPath 是一个 Swift 结构体，用于表示表格视图中某一行的位置。一个 IndexPath 实例有一个 section 属性和一个 row 属性。由于这个方法会被多次调用（每行调用一次），我们需要 indexPath 来知道我们当前正在配置的是哪一节和哪一行。indexPath.section 属性提供节号，indexPath.row 提供表格视图单元格的行号。`tableView(_:cellForRowAt:)` 方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定 `birthdays` 数组中哪一个生日会显示在单元格中

• 创建两个标签来显示生日人的名字和出生日期

• 返回准备好在表格视图中显示的单元格

让我们逐行查看这段代码。

首先，创建 UITableViewCell。代码 ➊ 使用方法 `dequeueReusableCell(withIdentifier:for:)` 来完成这一操作。然而，在你可以开始使用此方法之前，你需要告诉方法你要使用哪个单元格，这个单元格是在故事板中定义的。之前，当你在故事板中时，你给单元格设置了标识符 `birthdayCellIdentifier`（参见 图 11-4）。这个标识符将你的代码与单元格连接起来，告诉你的方法它正在使用正确的单元格。调用此方法时的字符串必须与在故事板中设置的字符串完全一致，否则你会遇到错误，应用程序在运行时会崩溃。

在方法 `dequeueReusableCell(withIdentifier:for:)` 中，你注意到 *Reusable Cell* 这几个字了吗？表格视图中的单元格只会创建一次，然后可以反复使用。这有助于提高运行速度和流畅度，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，屏幕上方滚出的单元格会被重用。它们会被填充上新信息并出现在屏幕底部。UITableView 会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)` 会为每个可见的行调用。当用户滚动以查看更多单元格时，它会在每一行即将出现在屏幕上时再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日，即 birthdays[0]，应该显示在第 0 行。第二个生日，即 birthdays[1]，应该显示在第 1 行，以此类推，这意味着 indexPath 的 row 与我们想要访问的 birthdays 数组中的位置相同。➋ 处的代码通过使用 indexPath.row 访问 birthdays 数组中的正确 Birthday 对象。一旦我们获取到正确的 Birthday 对象，我们将其赋值给一个名为 birthday 的常量，以便我们可以设置该单元格中的标签。

请注意，我们使用 let 将生日赋值给一个常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并且被赋予自己的 Birthday 对象。由于我们不会改变任何生日常量——我们只是读取它们的属性——所以我们不希望将它们设置为变量。

现在你已经有了单元格和生日，是时候填写详细信息了。你需要为每个单元格设置两个标签，分别显示生日人的姓名和出生日期。你将单元格的样式设置为副标题样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含这些标签，因此现在你不需要自己创建任何标签。

这些标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为由生日人的 firstName 和 lastName 组成的字符串，二者之间有一个空格。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 会在 ➎ 处返回该单元格，以便在该 indexPath 的表视图中显示它。

### 整合所有内容

现在，你可以通过添加生日视图控制器将生日实例添加到应用中，并且你有一个表视图来列出每个生日，显示在生日表视图控制器中。但是，当你尝试运行应用并添加生日时，它并没有出现。为了让你添加的每个生日都能出现在表视图中，你需要让添加生日视图控制器与生日表视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己的上面。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它只是被弹出并且不知道来自哪里，也不知道怎么到达那里。那么 B 如何与 A 交流呢？通过委托！

![](img/Image00245.jpg)

委托模式是指某人将一个任务或工作交给别人做。*委托* 就像是一个老板，他告诉委托员工该做什么。当委托员工完成任务后，有时他们会将信息报告给委托的老板。

在 Swift 中，委托模式非常相似，不过我们不是老板和员工的关系，而是委托者和委托对象的关系。由于类 B 是被类 A 告知该做什么的，因此它是委托对象。我们给类 B 一个名为 delegate 的特殊属性，告诉它谁是它的委托人——这样它就知道应该与谁进行通信。委托可以是任何拥有一组在*协议*中定义方法的类。协议就像是两个类之间的约定，告诉它们委托可以要求委托对象做什么。协议包含了委托可以与委托对象一起使用的方法和属性名称列表。

类 A 创建类 B，将自己设为类 B 的委托，并为类 B 分配一个协议中的任务。一旦类 B 完成了任务，它会向类 A 汇报。让我们看看这个在我们的应用中是如何工作的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 `addBirthdayViewController(_:didAddBirthday:)`，该方法将由添加生日视图控制器用来回报信息。

看看图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器会创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新生日被添加，并通过委托传递从添加生日视图控制器到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议定义了一个方法 `addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存 ➌ 时，添加生日视图控制器调用此方法 ➍ 并将新生日传递给它的委托，即生日表视图控制器。生日表视图控制器将该生日添加到它的生日数组中，然后重新加载其表视图 ➎，以便新生日能够出现在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义 `addBirthdayViewController(_:didAddBirthday:)` 方法，以便添加生日视图控制器每次添加生日时都可以调用该方法。生日表视图控制器将实现该协议方法，以便每当通过添加生日视图控制器添加生日时，添加生日视图控制器只需对它的委托说：“嘿！有人刚刚添加了这个生日。”然后生日表视图控制器会听到这个消息并说：“哦！我会把这个添加到我的列表中，并刷新我的显示，让新生日显示出来。”

现在让我们在代码中实现这个功能吧！

##### 创建一个协议

首先，我们需要创建这个协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 定义协议时，使用关键字 protocol 后跟协议名 AddBirthdayViewControllerDelegate。这是一个很长的名字，但 Swift 程序员通常会以调用类的名字命名协议，并在末尾加上 Delegate 这个词。这样，你就能通过协议的名字看出是哪个类在使用这个协议。既然你现在是一个 Swift 程序员，你也应该遵循同样的命名惯例。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，用来将 Birthday 对象传回给委托类 ➋。请注意，你在这个函数中包含了 AddBirthdayViewController 作为参数。再次强调，Swift 程序员通常会根据约定实现协议方法，所以你也应该坚持这么做。知道谁发送了消息，并且让委托类能够访问该对象及其类，是很有用的。

当 AddBirthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递。你很快就会看到这是如何实现的。另一个需要注意的是外部参数名 didAddBirthday。许多委托协议方法都包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚做过的或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表格视图控制器采纳这个协议并使用协议中的方法。

##### 使 Birthdays 表格视图控制器符合协议

为了采纳这个协议，Birthdays 表格视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在 UITableViewController 超类之后，向类定义中添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色错误就会出现。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！别担心，我们很快会修复这个问题。

这里需要特别注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，而且超类的名字必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采纳任意多个协议——这些协议都会在超类之后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:)方法。一个合适的地方是将其添加到类的末尾，紧接着导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动完成功能会建议你输入整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期望你添加这个方法。注意，与子类化方法不同，在 addBirthdayViewController(_:didAddBirthday:)方法前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这种方法中，你需要做两件事。首先，你需要将通过添加生日视图控制器传入的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:)方法来实现这一点 ➋。接下来，你需要刷新表格视图，使其显示这个新添加的生日，方法是调用 tableView 属性上的 reloadData()方法 ➌。当调用 reloadData()时，表格视图的数据源方法会再次被调用，新增的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但良好的编码风格是将类的不同部分进行标记，并帮助保持代码整洁和可读。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，它会将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单帮助你快速找到方法并跳转到代码中的不同位置。要使用这个菜单，点击编辑面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内建的目录，方便快速跳转到某个部分。*

##### 为添加生日视图控制器指定委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议来告诉 Birthdays 表格视图控制器它已经添加了一个生日。为此，添加生日视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个可选的委托属性，并将其类型设置为 AddBirthdayViewControllerDelegate 来安排这件事。可以在以下插入代码，将其添加到 outlets 下方：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是一个可选项，因为你在*添加生日*视图控制器创建之后才能设置它。你将很快学到如何设置委托。

现在添加生日视图控制器已经有了一个代理，在`saveTapped(_:)`方法中，你可以使用`addBirthdayViewController(_:didAddBirthday:)`方法将一个生日传递给代理。将`saveTapped(_:)`改成以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊处的代码会通过`addBirthdayViewController(_:didAddBirthday:)`方法将其传递回代理。

太棒了！你完成了对添加生日视图控制器的更改。它现在有了一个代理，将监听生日被保存的事件。运行应用程序看看会发生什么。

嗯……变化不大。当你添加一个生日时，你仍然看不到它出现在生日表格视图控制器中。这是怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事需要做。生日表格视图控制器是`AddBirthdayViewControllerDelegate`，而添加生日视图控制器有一个`AddBirthdayViewControllerDelegate`属性，用于保存当生日被保存时与之通信的代理。但我们从未特别设置该代理属性为生日表格视图控制器。所以现在是时候连接这两个视图控制器之间的通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个被注释掉的方法`prepare(for:sender:)`。删除其周围的`/*`和`*/`以取消注释该方法。

每当生日表格视图控制器放弃其屏幕并且应用程序通过故事板 segue 转换到另一个视图控制器时，这个方法会被自动调用。我们将使用这个方法将生日表格视图控制器传递给添加生日视图控制器，并设置它为添加生日视图控制器的代理。在`prepare(for:sender:)`方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的代理为生日表格视图控制器需要三行代码。首先，你需要能够从 segue 参数中获取`AddBirthdayViewController`对象。Xcode 已经留下了一个注释，提示你如何做到这一点。`UIStoryboardSegue`有一个名为`destination`的属性，它代表正在这个方法中准备的 segue 的另一端，但对于这个应用来说，目标并不是`AddBirthdayViewController`。

在第九章，你将添加生日视图控制器嵌入到一个导航控制器中，这样你就可以拥有带有取消和保存按钮的导航栏。所以你不期待在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的`UINavigationController`。➊处的代码会获取`navigationController`。代码`segue.destination`将返回一个`UIViewController`，但是因为我们的`navigationController`是一个特定类型的视图控制器，我们需要使用`as`进行类型转换为`UINavigationController`。

接下来，你可以获取到添加生日视图控制器（Add Birthday view controller），它是导航控制器（navigationController）中的 topViewController ➋。topViewController 就是当前在导航控制器中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其类型转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的一个特定子类。最后，当你获得一个 AddBirthdayViewController 时，你可以将其代理设置为 self，而此时 self 就是当前的生日表视图控制器（Birthdays table view controller） ➌。

现在运行应用并添加一些生日！你在生日表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序然后重新运行，之前的生日会消失。我们仍然需要将生日保存到设备中，这一点将在第十二章 中完成。

### 你学到了什么

在本章中，你学会了如何创建一个表视图控制器来展示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，然后如何使用代理将这个生日添加到生日表视图控制器中的 birthdays 数组中，以便它能够显示出来。

在第十二章 中，你将学会如何将生日保存到你的设备中，这样即使退出应用程序再重新运行，生日依然会显示出来。为了保存生日，我们将使用 Core Data，这是我们在项目一开始就设置好的。

你可能会疑惑，为什么在 storyboard 中我们的表视图只有一个单元格，尽管我们有多个生日要展示。如果你再看一下图 11-4，你会注意到单元格被标记为 *原型单元格*。这意味着你刚刚自定义的单元格是所有要出现在表视图中的单元格的 *模板*。你给单元格设置的标识符是你的代码告知表视图如何生成每个单元格以放入生日的方式。你很快就会看到这一点是如何工作的。

**处理日期**

Swift 有一个特殊的数据类型，叫做 Date，用于存储日期值。Date 对象实际上包含了日期和时间。打开你的 playground，并输入以下代码：

![](img/Image00239.jpg)

我们刚刚将当前代码运行时的日期和时间分配给变量 today。当你打印 today 时，它的格式是 "2017-11-21 10:45:31 +0000\n"。如果你希望它显示为“2017 年 11 月 21 日，星期二”呢？或者只是“11/21/17”呢？要以特定方式显示日期，你可以使用 *日期格式化器*，它是一个你创建并赋予日期格式样式的 DateFormatter 对象。DateFormatter 是一个帮助对象，用于从任何日期创建显示字符串，*日期格式样式* 是 DateFormatter 的一个属性，告诉格式化器使用什么样式。你可以手动创建自己的日期格式样式，但也有一些 Swift 内置并可直接使用的样式。将以下内容添加到你的 Playground 中：

![](img/Image00240.jpg)

在 ➊ 处，你创建一个格式化器。然后在 ➋ 处，你将格式化器的样式设置为 Style.full，这将打印出星期几，以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:) 方法创建一个字符串 ➌。你可以看到，你现在已经将日期转化为格式良好的字符串 "Tuesday, November 21, 2017"。表 11-1 显示了在 Swift 中可用的五种 DateFormatter.Style 选项创建的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **日期字符串** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "2017 年 11 月 21 日" |
| long | "2017 年 11 月 21 日" |
| full | "Tuesday, November 21, 2017" |

你还可以使用 DateFormatter 的 dateFormat 属性指定你自己的自定义日期显示方式。也许你只想显示月份和日期。或者你希望以简短样式显示四位数的年份。无论哪种方式都非常简单，你甚至不需要创建一个新的 DateFormatter ——你只需改变 formatter 上的 dateFormat，然后请求它生成一个新的字符串。将以下代码添加到你的 Playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在 ➊ 处，你指定只想要月和日，使用 MM/dd 格式——即一个两位数的月份，后跟一个两位数的日期。如果你想将月份显示为三个字母，可以使用 MMM。如果要显示完整的月份名称，使用 MMMM。在 ➋ 处，我们将日期格式更改为使用四位数的年份。两位数的年份应使用 yy。以下是几种其他使用 dateFormat 显示自定义日期字符串的方法。

![](img/Image00242.jpg)

如果你想包括分隔符，你可以将它们添加到你的 dateFormat 字符串中。例如，如果你希望使用句点作为分隔符，你可以创建一个像 "MM.dd.yy" 这样的 dateFormat ➊。要显示缩写的星期几，可以使用 EEE ➋。要显示完整的星期几名称，使用 EEEE ➌。这些只是一些例子。通过使用 M、d、y 和 E 的组合，你可以有无限多种方式来显示日期！

#### 设置生日表格视图控制器

Birthdays 表视图控制器将显示存储在应用中的所有生日列表。您还记得用来存储项目列表的是什么吗？没错——是数组！您将在 BirthdaysTableViewController 中创建一个数组来存储所有生日。为此，给 BirthdaysTableViewController 添加一个 birthdays 属性，这是一个 Birthday 对象数组。在类的顶部，紧接着 viewDidLoad() 方法之前，插入这一行代码，添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这行代码创建了一个空的 Birthday 实例数组。它需要是一个变量，而不是常量，因为每当用户通过添加生日视图控制器添加一个保存的生日时，您都会想将其添加到这个数组中。在 “使 Birthdays 表视图控制器符合协议” 中，您将看到如何做到这一点，第 168 页 详细讲解了这一部分。

**注意**

*请记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *获得。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性，以便将出生日期显示为格式良好的字符串。在生日数组下面添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，是用 let 创建的。尽管您会更改 dateFormatter 的属性，如 dateStyle 和 timeStyle，但您永远不会更改 dateFormatter 本身。

您还需要设置 dateFormatter，以便它可以将出生日期显示为完全格式化的字符串，如“Tuesday, December 17, 2008”。正如您在 第十章 中看到的，做这件事的好地方是 viewDidLoad() 方法，它会在 Birthdays 表视图控制器加载其视图时被调用。这是进行此类任何必要设置的完美地点。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，您设置了 dateFormatter 的 dateStyle，以便它能为每个生日显示格式化的日期字符串。您是否注意到我们只是写了 .full，而不是 DateFormatter.Style.full？Swift 知道 dateFormatter 的 dateStyle 应该是什么类型，所以它允许我们使用这个小的快捷方式。在 ➋ 处，您将 dateFormatter 的 timeStyle 设置为 .none，这样就不会显示时间。

#### 在表视图中显示生日

BirthdaysTableViewController 类有一个表视图，用于显示单列的项目列表。该表视图有一个或多个包含行的部分，每一行包含一个单元格。表视图中的一个部分是行的分组，可以显示带有或不带有标题。一个显示有多个部分的表视图应用示例是设置应用，如 图 11-5 所示。它显示了被分割成不同部分的行列表。

表格视图的每个部分和行都有一个索引号。这些数字从 0 开始，然后随着你向下滚动表格视图，每个数字增加 1。例如，在设置应用中，隐私行位于第零部分，第 1 行；新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间部分，有一个名为 *Table view data source* 的部分，其中包含三个方法。表格视图控制器使用这些方法来确定将显示在其表格视图中的内容。

numberOfSections(in:) 告诉表格视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表格视图每个部分中将显示多少行

tableView(_:cellForRowAt:) 设置每个将显示在表格视图中每一行的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用分区来将不同设备设置的行分组。*

每次表格视图重新加载时，表格视图控制器都会调用表格视图数据源方法。Xcode 在你创建一个 UITableViewController 的子类时，自动为你提供这些方法模板。即使你不会在代码中直接调用这些方法，你也需要实现所有三个方法才能使应用程序正常工作。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用于确定表格视图中将显示的内容。我们将在 “代理” 章节第 166 页讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，所以你不需要手动调用它们。

我们从方法 numberOfSections(in:) 开始。Birthdays 表格视图控制器是一个只显示生日实例的列表，因此它不需要多个部分。为了设置表格视图中的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 tableView 的 UITableView 作为参数，它是使用这个类作为数据源的表格视图。我们不需要担心如何建立这个连接，因为 UITableViewController 自带一个内置的表格视图，并且这些方法会自动连接。每个生日将显示在它自己的行中。因此，在 tableView(_:numberOfRowsInSection:) 方法中，为了拥有正确数量的行来显示所有的生日，你需要返回 birthdays 数组中 Birthday 实例的数量。你记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少项，非常适合这个场景！将这个方法更改为如下所示：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 `tableView` 参数外，`tableView(_:numberOfRowsInSection:)` 方法还接收一个名为 `section` 的 `Int` 参数。当表格视图加载时，这个方法会为表格中的每个 section 被调用。在我们的例子中，表格视图只有一个 section，因此我们无需担心检查当前显示的是哪个 section。我们知道它是 section 0，并且希望它的行数等于生日的数量，因此我们写 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)` 方法，以便表格视图知道在每个单元格中放置什么内容。由于这个方法被注释掉了，你需要通过删除 `/*` 和 `*/` 来取消注释它。（小心不要误删它后面的其他方法！）取消注释后，将其改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法 `tableView(_:cellForRowAt:)`。它会在表格视图加载到屏幕时被调用。它会为屏幕上的每个单元格调用，并接收两个参数，tableView 和 indexPath。你已经知道 `tableView` 参数的作用。`IndexPath` 是一个 Swift 结构体，用于表示表格视图中一行的位置。一个 `IndexPath` 实例有两个属性：section 和 row。由于这个方法会被多次调用（每次为表格中的一行调用），我们需要 `indexPath` 来知道当前正在配置的是哪个 section 和 row。`indexPath.section` 属性返回 section 的编号，`indexPath.row` 返回表格视图单元格的行号。`tableView(_:cellForRowAt:)` 方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 `UITableViewCell`

• 确定 `birthdays` 数组中哪个生日将显示在单元格内

• 创建两个标签来显示生日人的姓名和出生日期在单元格中

• 返回已准备好在表格视图中显示的单元格

让我们逐行查看这段代码。

首先，创建 `UITableViewCell`。在 ➊ 处的代码通过方法 `dequeueReusableCell(withIdentifier:for:)` 来实现这一点。然而，在你开始使用这个方法之前，你需要告诉它你想从 storyboard 中使用哪个单元格。早些时候，在 storyboard 中，你给你的单元格指定了标识符 `birthdayCellIdentifier`（见 图 11-4）。这个标识符将你的代码与单元格连接起来，并告诉方法它使用的是正确的单元格。当你调用这个方法时，传入的字符串必须与 storyboard 中设置的字符串完全一致，否则你会遇到错误，应用程序在运行时会崩溃。

在`dequeueReusableCell(withIdentifier:for:)`方法中，你注意到“*可重用单元格*”这几个字了吗？表格视图中的单元格是一次性创建的，然后可以反复使用。这有助于提高运行效率，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但每次屏幕上只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，滚出屏幕顶部的单元格将被重新使用。它们会被填充上新的信息，并出现在屏幕的底部。`UITableView`会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)`会为每个可见的行被调用。当用户滚动查看更多单元格时，它会再次为每一行调用，就在该行即将出现在屏幕上时。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中显示`birthdays`数组中的一个生日。第一个生日，也就是`birthdays[0]`，应该显示在第 0 行。第二个生日，即`birthdays[1]`，应该显示在第 1 行，以此类推，这意味着`indexPath`的行数与我们要访问的`birthdays`数组中的位置相同。在➋的代码中，通过使用`indexPath.row`访问`birthdays`数组中的正确的生日对象。一旦我们得到正确的生日对象，我们将其赋值给一个名为`birthday`的常量，这样我们就可以设置这个单元格中的标签。

注意，我们使用`let`将生日赋值给一个常量，而不是变量。我们可以使用`let`是因为每次调用`tableView(_:cellForRowAt:)`时，都会创建一个新的生日常量。每个单元格都会有自己的生日常量，并被赋予自己的生日对象。由于我们不会修改任何生日常量——我们只是读取它们的属性——所以不需要将它们定义为变量。

现在你有了单元格和生日，接下来就是填写详细信息了。你需要为每个单元格设置两个标签，用来显示生日人物的姓名和出生日期。你将单元格设置为`Subtitle`样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含这些标签，所以你不需要自己创建标签了。

这些标签是`UITableViewCell`的属性，分别叫做`textLabel`和`detailTextLabel`。在➌的代码中，`textLabel`的文本被设置为由生日的`firstName`和`lastName`组成的字符串，两者之间用空格分开。在➍处，你使用`dateFormatter`的`string(from:)`方法将出生日期显示在`detailTextLabel`中。

当你的单元格完全配置好后，`tableView(_:cellForRowAt:)`会在➎返回这个单元格，以便它可以在表格视图的`indexPath`位置显示出来。

### 整合所有内容

现在，你可以通过“添加生日”视图控制器向应用程序添加生日实例，并且可以在“生日”表格视图控制器中列出每个生日。但是，当你运行应用程序并尝试添加生日时，生日并不会显示。为了让你添加的每个生日出现在表格视图中，你需要让“添加生日”视图控制器与“生日”表格视图控制器进行通信。你可以通过使用*代理*来实现这一点。

#### 代理

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用代理。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在它自己之上。A 知道 B，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但是 B 不知道 A——它刚刚被创建出来，根本不知道它从哪里来，也不知道它是如何到达那里。那么，B 如何与 A 进行通信呢？通过代理！

![](img/Image00245.jpg)

代理是一种将工作或任务委托给他人的方式。*代理*就像是老板，告诉被委托的员工该做什么。当被委托的员工完成任务时，有时他们会向代理老板报告信息。

在 Swift 中，代理非常相似，但不同的是，我们没有老板和员工的关系，而是有代理和委托对象。由于类 B 是由类 A 告诉做什么的，因此它是委托对象。我们给类 B 一个特殊的属性，叫做代理，来告诉它它的代理是谁——这样，它就知道该与谁通信。代理可以是任何具有在*协议*中定义的相关方法的类。协议就像是两个类之间的约定，告诉它们代理可以要求委托对象做什么。它列出了代理可以在委托对象上使用的方法和属性名称。

类 A 创建类 B，设置自己为类 B 的代理，并给类 B 分配一个任务，任务在协议中定义。一旦类 B 完成任务，它会向类 A 报告。让我们看看这个在我们的应用中是如何工作的。

“生日”表格视图控制器是视图控制器 A，而“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议定义一个方法 addBirthdayViewController(_:didAddBirthday:) ，该方法将由“添加生日”视图控制器用来报告结果。

看一下图 11-6。当用户点击添加按钮 ➊ 时，“生日”表格视图控制器创建“添加生日”视图控制器 ➋ 并将自己设置为“添加生日”视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过代理从“添加生日”视图控制器传递到“生日”表格视图控制器。*

AddBirthdayViewControllerDelegate 协议定义了一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击“保存” ➌ 时，Add Birthday 视图控制器会调用这个方法 ➍ 并将新的生日传递给其代理——Birthdays 表格视图控制器。Birthdays 表格视图控制器接收这个生日，将其添加到生日数组中，然后重新加载表格视图 ➎，这样新添加的生日就会出现在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义 addBirthdayViewController(_:didAddBirthday:) 方法，供 Add Birthday 视图控制器在每次添加生日时调用。Birthdays 表格视图控制器将实现这个协议方法，这样每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器就可以对其代理说：“嘿！刚刚有人添加了这个生日。”然后，Birthdays 表格视图控制器会接收到这个消息并回应：“哦！我会把它添加到我的列表中，并刷新显示，确保新添加的生日出现在表格中。”

所以现在让我们在代码中实现这一点吧！

##### 创建一个协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，*在* AddBirthdayViewController 类的上方，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处通过键入关键字 protocol 和协议名 AddBirthdayViewControllerDelegate 来定义该协议。这是一个较长的名字，但 Swift 程序员通常会按照调用类的名称命名协议，并在末尾添加 Delegate。这样，你就能通过查看协议名称来知道哪个类正在使用这个协议。既然你现在是 Swift 程序员，你也应该遵循这种命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传递回代理类 ➋。请注意，在这个函数中你包含了 AddBirthdayViewController 作为参数。再次强调，Swift 程序员通常会根据约定在实现协议方法时这样做，所以你也应该坚持这么做。这样做有助于了解是谁发送了消息，并让代理可以访问该对象及其类。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递给方法。你很快就会看到这是怎么做的。另一个需要注意的点是外部参数名 didAddBirthday。许多代理协议方法都包含 *did* 和 *will*，因为它们用于描述调用类已经做了或者即将做的事情。

现在你已经定义了协议，接下来需要告诉 Birthdays 表格视图控制器遵循这个协议并使用协议的方法。

##### 让 Birthdays 表格视图控制器遵循协议

为了遵循这个协议，Birthdays 表格视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在 UITableViewController 超类后紧接着将 AddBirthdayViewControllerDelegate 添加到类定义中。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate :

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色错误提示就会出现。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心，我们很快会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，并且这个超类的名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以遵循多个协议——这些协议会在超类后列出，并由逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 `addBirthdayViewController(_:didAddBirthday:)` 方法添加到 Birthdays TableViewController 中。一个很好的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类遵循了 AddBirthdayViewController Delegate 协议，并且它期望你添加这个方法。请注意，与子类化方法不同，在 `addBirthdayViewController(_:didAddBirthday:)` 前你不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的生日信息添加到 birthdays 数组中。你可以通过使用数组的 `append(_:)` 方法来实现这一点 ➋。接下来，你需要刷新表格视图，以便它能够显示这个新的生日，方法是调用 tableView 属性的 `reloadData()` 方法 ➌。当 `reloadData()` 被调用时，表格视图的数据源方法将会重新调用，新增的生日将会显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释，以标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但将类的不同部分标记出来是良好的编码风格，有助于保持代码整洁易读。注释的第一部分 `MARK: -` 是 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部下拉目录菜单中，你可以用它来浏览类中的方法并跳转到代码中的不同位置。要使用这个菜单，点击编辑器面板顶部的“生日表格视图控制器”，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个章节。*

##### 给“添加生日”视图控制器设置代理

BirthdaysTableViewController 已经实现了 AddBirthdayViewControllerDelegate 协议。现在是时候让“添加生日”视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉生日表格视图控制器它已经添加了一个生日。为此，“添加生日”视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中插入以下代码行，将一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性添加到 AddBirthdayViewController 类中，来安排这一点：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在“添加生日”视图控制器创建之前，无法设置它。你将很快学到在哪里设置代理。

现在，“添加生日”视图控制器已经有了代理，在 `saveTapped(_:)` 方法中，你可以通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将生日传递给代理。将 `saveTapped(_:)` 更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

生日对象创建后，➊处的代码通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将它传回给代理。

很棒！你已经完成了对“添加生日”视图控制器的更改。现在，它有了一个代理，可以监听生日保存的通知。运行应用程序查看发生了什么。

嗯……变化不大。你添加了一个生日，但在生日表格视图控制器中仍然看不到它显示出来。怎么回事？

#### 通过设置代理连接这两个控制器

你还需要做最后一件事。生日表格视图控制器是一个 AddBirthdayViewControllerDelegate，而“添加生日”视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存它与之通讯的代理，即当一个生日被保存时。但是我们还没有明确地将代理属性设置为生日表格视图控制器。现在是时候连接我们两个视图控制器之间的通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个已被注释掉的方法，名为`prepare(for:sender:)`。通过删除其前后的`/*`和`*/`来取消注释该方法。

每当“生日”表格视图控制器放弃其屏幕，并且应用程序通过故事板 segue 过渡到另一个视图控制器时，`prepare(for:sender:)`方法会自动被调用。我们将使用这个方法将“生日”表格视图控制器传递给“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的代理。在`prepare(for:sender:)`方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的代理为“生日”表格视图控制器只需要三行代码。首先，你需要能够通过 segue 参数获取到`AddBirthdayViewController`对象。Xcode 已经在注释中提示了你可以如何做到这一点。`UIStoryboardSegue`在其准备过程中有一个名为`destination`的属性，指向 segue 的目标视图控制器，但这个应用的目标并不是`AddBirthdayViewController`。

在第九章中，你将“添加生日”视图控制器嵌入到了一个导航控制器中，这样就可以拥有一个包含取消和保存按钮的导航栏。所以你不会期望在 segue 的另一端找到`AddBirthdayViewController`。相反，目标是一个包含`AddBirthdayViewController`的`UINavigationController`。在➊那一行，你可以获取到`navigationController`。代码`segue.destination`会返回一个`UIViewController`，但是由于我们的`navigationController`是一个特定类型的视图控制器，所以需要使用`as`将其强制转换为`UINavigationController`。

接下来，你可以获取“添加生日”视图控制器，它是`navigationController`的`topViewController` ➋。`topViewController`只是当前显示在`navigationController`中的视图控制器，但它的属性类型是`UIViewController`，所以必须将其强制转换为`AddBirthdayViewController`，以指明该控制器是`UIViewController`的一个特定子类。最后，当你拥有了`AddBirthdayViewController`后，你可以将代理设置为`self`，而`self`当前是“生日”表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在“生日”表格视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用程序再重新运行，之前的生日将会消失。我们还需要将生日保存到设备中，我们将在第十二章中实现。

### 你所学到的

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学习了如何在“添加生日”视图控制器中添加一个生日，然后如何使用代理将生日添加到“生日”表格视图控制器中的生日数组中，以便它能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，以便在你退出应用程序后重新启动时仍然显示。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

**日期处理**

Swift 有一种特殊的数据类型，叫做 Date，用于存储日期值。一个 Date 对象实际上包含了日期和时间。打开你的 Playground 并输入以下代码：

![](img/Image00239.jpg)

我们刚刚将代码运行时的当前日期和时间赋值给变量`today`。当你打印`today`时，它的格式是"2017-11-21 10:45:31 +0000\n"。如果你希望它以"2017 年 11 月 21 日星期二"的格式显示怎么办？或者仅仅显示 11/21/17 呢？为了以特定方式显示日期，你需要使用一个*日期格式化器*，它是一个 DateFormatter 对象，你可以创建并设置一个日期格式样式。DateFormatter 是一个帮助对象，用于从任何日期创建显示字符串，*日期格式样式*是 DateFormatter 的一个属性，用于告知格式化器应使用哪种样式。你可以手动创建自己的日期格式样式，但 Swift 中也包含了一些现成的样式。将以下代码添加到你的 Playground 中：

![](img/Image00240.jpg)

在➊处，你创建了一个格式化器。然后在➋处，你将格式化器的样式设置为 Style.full，这样它就会打印出星期几的名称，以及完整的月份名称、日期和年份。最后，你使用 DateFormatter 类的 string(from:)方法➌从日期创建字符串。你可以看到，你现在已经将日期转换成了格式良好的字符串"Tuesday, November 21, 2017"。表 11-1 展示了从 Swift 中五个 DateFormatter.Style 选项生成的不同字符串。

**表 11-1：** 日期格式化器样式及其日期字符串

| DateFormatter.Style | **Date string** |
| --- | --- |
| none | "" |
| short | "11/21/17" |
| medium | "Nov 21, 2017" |
| long | "November 21, 2017" |
| full | "Tuesday, November 21, 2017" |

你还可以使用 DateFormatter 的 dateFormat 属性指定自己定义的日期显示方式。也许你只想显示月份和日期。或者你想在短格式中显示四位数的年份。做这两件事都非常简单，你甚至不需要创建新的 DateFormatter——你只需更改 formatter 的 dateFormat，然后请求它生成一个新的字符串。将以下代码添加到你的 Playground 中，以特定格式显示日期：

![](img/Image00241.jpg)

在➊处，你指定了只想以 MM/dd 格式显示月份和日期——即两位数的月份后跟两位数的日期。如果你希望月份显示为三个字母，那么使用 MMM。要显示月份的全名，使用 MMMM。在➋处，我们将日期格式更改为使用四位数的年份。两位数的年份应使用 yy。以下是一些使用 dateFormat 显示自定义日期字符串的其他方式。

![](img/Image00242.jpg)

如果你想包含分隔符，可以将它们添加到你的 dateFormat 字符串中。例如，如果你想要句点作为分隔符，可以创建一个像"MM.dd.yy" ➊这样的 dateFormat。如果你想显示缩写的星期几，使用 EEE ➋；若要显示完整的星期几，使用 EEEE ➌。这些只是几个示例。通过组合 M、d、y 和 E，你可以有无限多种方式来显示日期！

#### 设置 Birthdays Table View Controller

Birthdays 表视图控制器将显示应用程序中存储的所有生日列表。你记得用什么来存储项目列表吗？没错——一个数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有的生日。为此，在类的顶部，在 viewDidLoad()方法之上，插入这一行来添加一个名为 birthdays 的数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的生日实例数组。它需要是一个变量而非常量，因为每次用户通过“添加生日”视图控制器添加生日时，你都希望将已保存的生日添加到这个数组中。你将在“让 Birthdays Table View Controller 遵循协议”中学习如何做到这一点，详见第 168 页。

**注意**

*记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *获得。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性，用于以良好格式化的字符串显示出生日期。在 birthdays 数组下面添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，是通过 let 创建的。尽管你会改变 dateFormatter 的属性，例如 dateStyle 和 timeStyle，但你永远不会改变 dateFormatter 本身。

你还需要设置日期格式化器，以便它将出生日期显示为完全格式化的字符串，例如“2008 年 12 月 17 日，星期二”。正如你在第十章中看到的，最好的做法是在 viewDidLoad()方法中进行设置，这个方法在 Birthday 表视图控制器加载其视图时被调用。这是进行任何所需设置的最佳位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在➊处，你设置了 dateFormatter 的 dateStyle，以便它会为每个生日显示格式化的日期字符串。你注意到我们只是写了.full 而不是 DateFormatter.Style.full 吗？Swift 知道 DateFormatter 的 dateStyle 应该是什么类型，所以它允许我们使用这个小技巧。在➋处，你将 dateFormatter 的 timeStyle 设置为.none，以便不会显示时间。

#### 在表视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于显示一列项的列表。表格视图有一个或多个部分，每个部分包含若干行，而每行包含一个单元格。表格视图中的一个部分是若干行的分组，可以选择显示或不显示标题。一个显示多个部分的表格视图应用示例是设置应用，如图 11-5 所示。它显示了一个被划分为不同部分的行列表。

表格视图的每个部分和行都有一个索引编号。这些编号从 0 开始，随着表格视图的向下滚动，编号会增加 1。例如，在设置应用中，隐私项位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为*Table view data source*的部分，包含三个方法。表格视图控制器使用这些方法来确定在其表格视图中将显示什么内容。

numberOfSections(in:) 告诉表格视图应该有多少个部分。

tableView(_:numberOfRowsInSection:) 告诉表格视图每个部分将显示多少行。

tableView(_:cellForRowAt:) 设置将要显示在每一行的单元格。

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分来分组不同设备设置的行。*

表格视图数据源方法在每次表格视图重新加载时都会被表格视图控制器调用。当你创建 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现这三个方法才能使应用正常工作，即使你在代码中永远不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用于确定在表格视图中将显示什么内容。我们将在“代理”一节（第 166 页）讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且会自动调用这些方法，所以你无需手动调用它们。

我们先从方法 numberOfSections(in:)开始。Birthdays 表格视图控制器是一个仅显示生日实例的列表，因此它不需要多个部分。为了设置表格视图的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 tableView 的 UITableView 作为参数，它是使用该类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内建的表格视图，它会自动与这些方法连接。在每一行中，都会显示一个生日。因此，在 tableView(_:numberOfRowsInSection:)中，为了正确地显示所有生日的行数，你需要返回你在 birthdays 数组中拥有的 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少个元素，正好适用于这种情况！将这个方法改为如下：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，tableView(_:numberOfRowsInSection:)方法还接受一个名为 section 的 Int 参数。当表格视图加载时，这个方法会针对表格视图中的每个 section 调用。在我们的例子中，只有一个 section，所以我们不需要关心显示的是哪个 section。我们知道它是 section 0，并且希望它的行数和生日的数量一样，所以我们写下 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:)方法，以便表格视图知道在每个单元格中放置什么内容。由于这个方法已经被注释掉了，你需要通过删除/*和*/来取消注释它。（小心不要不小心取消注释它后面的其他方法！）完成后，将其修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要调用 tableView(_:cellForRowAt:)方法。它是在表格视图加载到屏幕上时调用的。每个屏幕上的单元格都会调用它，并且传入两个参数，tableView 和 indexPath。你已经知道 tableView 参数的作用。IndexPath 是一个 Swift 结构体，用于表示表格视图中某行的位置。一个 IndexPath 实例有 section 属性和 row 属性。由于这个方法会被多次调用（每行都会调用一次），我们需要使用 indexPath 来知道当前正在配置的是哪个 section 和 row。indexPath.section 属性给出 section 的编号，而 indexPath.row 则给出表格视图单元格的行号。tableView(_:cellForRowAt:)方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 找出在 birthdays 数组中将要显示在单元格中的 Birthday 实例

• 创建两个标签，以显示生日者的姓名和出生日期

• 返回准备好在表格视图中显示的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。➊处的代码通过使用方法 dequeueReusableCell(withIdentifier:for:)来实现此操作。但是，在你可以在单元格上使用此方法之前，你需要告诉该方法从故事板中使用哪个单元格。之前，当你在故事板中时，你给你的单元格设置了标识符 birthdayCellIdentifier（参见图 11-4）。这个标识符将你的代码与单元格关联，并告诉你的方法它正在使用正确的单元格。你在调用该方法时传入的字符串必须与在故事板中设置的字符串完全相同，否则你将遇到错误，并且在运行时应用程序会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:)中，你注意到*Reusable Cell*这两个字了吗？表格视图中的单元格是一次创建，然后可以反复使用。这有助于提高运行速度和流畅度，因为创建单元格是最费时的。如果你的应用中有 200 个生日，但是一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多的生日时，滚出屏幕顶部的单元格会被重新使用。它们会填充新的信息，并再次出现在屏幕底部。UITableView 会自动完成这项工作。当表格视图加载时，会为每一行可见的单元格调用 tableView(_:cellForRowAt:)。当用户滚动查看更多单元格时，每当单元格即将出现在屏幕上时，这个方法也会被再次调用。

接下来，我们需要找出在单元格中应该显示哪个生日。我们希望在每一行中显示生日数组中的一个生日。第一个生日（在 birthdays[0]）应该显示在第 0 行，第二个生日（在 birthdays[1]）应该显示在第 1 行，依此类推，这意味着 indexPath 的 row 与我们要访问的 birthday 数组中的位置相同。➋处的代码通过使用 indexPath.row 从 birthday 数组中访问正确的 Birthday 对象。一旦我们获得了正确的 Birthday 对象，就将其赋值给一个名为 birthday 的常量，以便我们可以设置该单元格中的标签。

注意，我们使用 let 将生日赋值给一个常量而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都会获得自己的生日常量，并为其分配自己的 Birthday 对象。由于我们不会改变任何生日常量——我们只是读取它们的属性——因此我们不需要将它们设置为变量。

现在你有了单元格和生日信息，接下来是填写详细内容。每个单元格需要两个标签来显示生日人的姓名和出生日期。你将单元格设置为 Subtitle 样式，这样它就会有一个 Title 标签和一个 Subtitle 标签。每个单元格已经包含这些标签，所以你现在不需要自己创建任何标签。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格隔开。➍ 处，你使用 dateFormatter 的 string(from:) 方法在 detailTextLabel 中显示出生日期。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 在 ➎ 处返回该单元格，以便将其显示在表格视图的相应 indexPath 位置。

### 整合（PUTTING IT ALL TOGETHER）

现在，你可以通过 Add Birthday 视图控制器向应用中添加 Birthday 实例，并且你有一个表格视图来列出每个生日项，显示在 Birthdays 表格视图控制器中。但当你尝试运行应用并添加一个生日时，它并没有显示。为了让你添加的每个生日都能出现在表格视图中，你需要让 Add Birthday 视图控制器与 Birthdays 表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托（DELEGATION）

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己的上方。A 知道 B，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但是 B 并不知道 A——它只是突然出现，并不知道自己来自哪里，也不知道是如何到达的。那么，B 如何与 A 进行沟通呢？通过委托！

![](img/Image00245.jpg)

委托是指将工作或任务交给其他人做。*委托人*就像是一个老板，告诉委托员工该做什么。当委托员工完成任务时，有时他们会将信息报告回委托人老板。

在 Swift 中，委托（Delegation）非常相似，但我们不是有老板和员工，而是有委托者和委托对象。由于 B 类是被 A 类告知该做什么的，所以它是委托对象。我们给 B 类一个特殊的属性，叫做 delegate，用来告诉它它的委托人是谁——这样，它就知道该与谁进行沟通。委托人可以是任何一个拥有在*协议*中定义的一组方法的类。协议就像是两个类之间的约定，告诉它们委托人可以要求委托对象做什么。它包含了委托人可以在委托对象上使用的方法和属性名称的列表。

A 类创建了 B 类，使自己成为 B 类的委托人，并给 B 类分配了一个协议中的任务。一旦 B 类完成了任务，它就会向 A 类报告。让我们看看在我们的应用中是如何运作的。

Birthdays 表格视图控制器是视图控制器 A，Add Birthday 视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由 Add Birthday 视图控制器用于报告结果。

看一下 图 11-6。当用户点击添加按钮 ➊ 时，Birthdays 表格视图控制器创建 Add Birthday 视图控制器 ➋ 并将自己设置为 Add Birthday 视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：通过委托，新的生日从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议定义了一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，Add Birthday 视图控制器调用这个方法 ➍ 并将新添加的生日传递给它的委托——Birthdays 表格视图控制器。Birthdays 表格视图控制器接收到这个生日后，将其添加到生日数组中，然后重新加载表格视图 ➎ ，以便新添加的生日显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，其中包含一个方法 addBirthdayViewController(_:didAddBirthday:)，当在应用中添加生日时，Add Birthday 视图控制器可以调用该方法。Birthdays 表格视图控制器将实现该协议方法，这样每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器只需告诉其委托：“嘿！有人刚刚添加了这个生日。”然后 Birthdays 表格视图控制器会接收到这个消息并说：“哦！我会把这个添加到我的列表里，并刷新显示，这样新的生日就会显示出来。”

现在让我们用代码实现这个功能！

##### 创建一个协议

首先，我们需要创建这个协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方* 添加定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处定义协议，通过输入关键字 protocol 后跟协议名称 AddBirthdayViewControllerDelegate。这个名字很长，但 Swift 程序员通常会根据调用类的名称命名协议，并在末尾加上 Delegate 这个词。这样，你就可以通过查看协议的名称来知道是哪个类在使用这个协议。既然你现在是一个 Swift 程序员，你也应该遵循相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象返回给委托类 ➋。注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。再次提醒，Swift 程序员在实现协议方法时，通常会这样做，因此你也应该遵循这种约定。这是为了能够知道消息是由谁发送的，并且使委托能够访问该对象及其类。

当 AddBirthdayViewController 调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递。你很快就会看到这是如何实现的。另一个需要注意的是外部参数名 didAddBirthday。许多代理协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类已经做过或将要做的事情。

既然你已经定义了协议，你需要告诉 Birthdays table view controller 采用这个协议并使用协议的方法。

##### 让 Birthdays Table View Controller 遵循协议

为了采用这个协议，Birthdays table view controller 需要让自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中，在 UITableViewController 超类之后添加 AddBirthdayViewControllerDelegate。将一个逗号添加到 UITableViewController 后，然后键入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色错误就会出现。这是因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会修复这个问题。

在这里需要注意的是，BirthdaysTableViewController 是子类化自 UITableViewController 超类。一个类只能有一个超类，而且该超类的名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议会在超类之后列出，并用逗号隔开。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 BirthdaysTableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个好的位置是在类的末尾，即导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成建议了整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它期待你添加这个方法。注意，与子类方法不同，在 addBirthdayViewController(_:didAddBirthday:) 前你不需要使用 override 关键字，因为没有原始方法可以重写。

在这个方法中，你需要做两件事。首先，你需要将 AddBirthdayViewController 传入的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来做到这一点 ➋。接下来，你需要刷新表视图，以便它显示这个新的生日，通过在 tableView 属性上调用 reloadData() 方法 ➌。当调用 reloadData() 时，表视图的数据源方法会再次被调用，新增的 Birthday 会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但在类中标记不同的部分是良好的编码风格，并有助于保持代码整洁、易读。注释的第一部分，`MARK: -`，是 Xcode 识别的一个特殊关键字，它会将`AddBirthdayViewControllerDelegate`部分添加到一个下拉目录中，供你在类的顶部使用。这个下拉菜单帮助你快速找到方法，并让你跳转到代码中的不同位置。要使用这个菜单，点击编辑器面板顶部的`Birthdays TableViewController`，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为添加生日视图控制器设置委托

`BirthdaysTableViewController`已经遵循了`AddBirthdayViewControllerDelegate`协议。现在是时候让添加生日视图控制器使用`AddBirthdayViewControllerDelegate`协议来通知生日表视图控制器它已添加一个生日。为此，添加生日视图控制器首先需要定义一个委托。我们通过在`AddBirthdayViewController`类中添加一个可选的`AddBirthdayViewControllerDelegate`类型的委托属性来安排此事，具体是在 outlets 下方插入以下行：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为你不能在**添加生日视图控制器创建之后**设置它。你将很快学到在哪里设置委托。

现在，添加生日视图控制器已经有了一个委托，在`saveTapped(_:)`方法中，你可以通过`addBirthdayViewController(_:didAddBirthday:)`方法将一个生日对象传递给委托。将`saveTapped(_:)`改成如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码在➊处通过`addBirthdayViewController(_:didAddBirthday:)`将其传递回委托。

很好！你已经完成了对添加生日视图控制器的修改。它现在有了一个委托，能够监听生日保存的事件。运行应用看看会发生什么。

嗯……没有太大变化。当你添加一个生日时，仍然看不到它在生日表视图控制器中显示出来。这是怎么回事？

#### 通过设置委托连接两个控制器

你还需要做一件事。生日表视图控制器是`AddBirthdayViewControllerDelegate`，而添加生日视图控制器有一个`AddBirthdayViewControllerDelegate`类型的属性，保存它在保存生日时会与之通信的委托。但是我们从未明确将委托属性设置为生日表视图控制器。因此，现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除 /* 和 */，取消注释该方法。

每当 Birthdays 表视图控制器放弃其屏幕并且应用通过 storyboard segue 转到另一个视图控制器时，此方法会自动调用。我们将使用此方法将 Birthdays 表视图控制器传递给 Add Birthday 视图控制器，以便将自身设置为 Add Birthday 视图控制器的委托。在 prepare(for:sender:) 方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的委托为 Birthdays 表视图控制器只需要三行代码。首先，您需要通过 segue 参数访问 AddBirthdayViewController 对象。Xcode 中留有一个注释，提示您如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，它指向正在此方法中准备的 segue 的另一端，但对于这个应用，destination 不是 AddBirthdayViewController。

在第九章中，您将 Add Birthday 视图控制器嵌入到了导航控制器中，以便拥有一个带有取消和保存按钮的导航栏。因此，您不会期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。在 ➊ 这一行中，您获取了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是一种特定类型的视图控制器，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，您可以获取 Add Birthday 视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表示这个控制器是 UIViewController 的一个特定子类。最后，当您获得 AddBirthdayViewController 后，可以将委托设置为 self，它当前是 Birthdays 表视图控制器 ➌。

现在运行应用并添加一些生日！您在 Birthdays 表视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果您退出应用然后再次运行它，之前添加的生日将会消失。我们仍然需要将生日保存到设备上，这部分内容将在第十二章中介绍。

### 你学到了什么

在本章中，您学习了如何创建一个表视图控制器来显示您的生日列表。您还学习了如何在 Add Birthday 视图控制器中添加一个生日，然后如何使用委托将生日添加到 Birthdays 表视图控制器中的 birthdays 数组，以便它可以被显示。

在第十二章中，你将学习如何将生日保存到设备中，以便即使退出应用后再次启动，生日仍然能够显示。为了保存生日，你将使用 Core Data，这是我们在项目初期设置的。

#### 设置 Birthdays Table View Controller

BirthdaysTableViewController 将显示应用中存储的所有生日的列表。你还记得用什么来存储项目列表吗？没错——是数组！你将在 BirthdaysTableViewController 中创建一个数组来存储所有的生日。为此，给 BirthdaysTableViewController 添加一个名为 birthdays 的属性，它是一个 Birthday 对象的数组。在类的顶部，紧接在 viewDidLoad()方法上方，插入这一行代码来添加一个名为 birthdays 的变量数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量而不是常量，因为你希望每次用户通过 Add Birthday 视图控制器添加生日时，将一个已保存的 Birthday 添加到这个数组中。你将在“让 Birthdays Table View Controller 遵循协议”中学习如何做到这一点，见第 168 页。

**注意**

*记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性，用于将生日日期显示为格式化的字符串。将 dateFormatter 添加到 birthdays 数组下方：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，用 let 创建。尽管你将更改 dateFormatter 的属性，比如 dateStyle 和 timeStyle，但你永远不会更改 dateFormatter 本身。

你还需要设置 dateFormatter，使其能够将生日日期显示为完整格式的字符串，比如“2008 年 12 月 17 日，星期二”。正如你在第十章中看到的，做这件事的好地方是 viewDidLoad()方法，它在 Birthdays table view controller 加载视图时被调用。这是进行该类所需设置的完美时机。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在➊处，你设置了 dateFormatter 的 dateStyle，使它能够为每个 Birthday 显示一个格式化的日期字符串。你有没有注意到我们直接写了.full 而不是 DateFormatter.Style.full？Swift 知道 DateFormatter 的 dateStyle 应该是什么类型，因此它允许我们使用这个小技巧。在➋处，你设置了 dateFormatter 的 timeStyle 为.none，这样就不会显示时间。

#### 在表格视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于显示单列项目的列表。表格视图有一个或多个包含行的部分，每一行包含一个单元格。表格视图中的部分是一个行的分组，可以选择是否显示标题。一个展示了多个部分的表格视图应用程序示例是设置应用，如图 11-5 所示。它展示了一些被拆分成不同部分的行列表。

表格视图的每个部分和行都有一个索引号来标识。这些数字从 0 开始，然后随着表格视图的向下滚动而增加 1。例如，设置应用中的隐私行位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为*表格视图数据源*的部分，其中包含三个方法。表格视图控制器使用这些方法来确定在其表格视图中显示的内容。

numberOfSections(in:) 告诉表格视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表格视图每个部分中将显示多少行

tableView(_:cellForRowAt:) 设置将要显示在表格视图每一行中的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分来分组不同设备设置的行。*

每次重新加载表格视图时，表格视图控制器都会调用表格视图数据源方法。当你创建一个 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现这三个方法以确保应用程序的正常运行，尽管你在代码中永远不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，包含这些数据源方法，用于确定表格视图中将显示的内容。我们将在“代理”一节（第 166 页）中讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示内容，并且它会自动调用这些方法，所以你不需要手动调用它们。

让我们从方法 numberOfSections(in:) 开始。Birthdays 表格视图控制器是一个仅显示生日实例的列表，因此它不需要多个部分。为了设置表格视图中的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 `tableView` 的 `UITableView` 参数，它是使用此类作为数据源的表格视图。我们不需要担心建立这个连接，因为 `UITableViewController` 自带一个内建的表格视图，并且自动将这些方法连接起来。每个生日将在其自己的行中显示。因此，在 `tableView(_:numberOfRowsInSection:)` 方法中，为了确保有足够的行数来显示所有的生日，你需要返回 `birthdays` 数组中 `Birthday` 实例的数量。你还记得数组的 `count` 属性吗？它是一个整数，告诉你数组中有多少个元素，正好适用于这种情况！将这个方法修改为以下代码：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 `tableView` 参数，`tableView(_:numberOfRowsInSection:)` 还接受一个名为 `section` 的 `Int` 参数。当表格视图加载时，这个方法会为表格视图中的每个部分被调用。在我们的例子中，只有一个部分，所以我们不需要担心检查显示的是哪个部分。我们知道是第零部分，并且希望它有与生日数量相同的行数，所以我们写 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)`，这样表格视图就会知道在每个单元格中放置什么内容。由于这个方法被注释掉了，你需要通过删除包围它的 `/*` 和 `*/` 来取消注释它。（小心不要不小心取消注释它后面的其他方法！）做完后，将其修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法 `tableView(_:cellForRowAt:)`。它会在表格视图加载到屏幕时被调用。每当屏幕上有单元格时，它会被调用，并且接受两个参数，`tableView` 和 `indexPath`。你已经知道 `tableView` 参数的作用。`IndexPath` 是一个 Swift 结构体，用于表示表格视图中某一行的位置。一个 `IndexPath` 实例有 `section` 属性和 `row` 属性。由于这个方法会被调用多次（每次对应表格中的一行），我们需要 `indexPath` 来知道当前正在配置的是哪个部分和哪一行。`indexPath.section` 属性给出部分号，`indexPath.row` 给出表格视图单元格的行号。`tableView(_:cellForRowAt:)` 方法中的五行代码将完成以下操作：

![](img/Image00244.jpg)

• 创建一个 `UITableViewCell`

• 确定在 `birthdays` 数组中哪个生日将显示在单元格中

• 创建两个标签，在单元格中显示生日人的名字和生日日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。在 ➊ 处的代码使用方法 dequeueReusableCell(withIdentifier:for:) 来实现这个操作。然而，在你开始使用这个方法之前，你需要告诉方法你想使用哪个来自故事板的单元格。之前，当你在故事板中时，你为单元格指定了标识符 birthdayCellIdentifier（参见 图 11-4）。这个标识符将你的代码与单元格关联起来，并告诉你的方法它正在使用正确的单元格。当你调用这个方法时，字符串必须与在故事板中设置的字符串完全一致，否则会出现错误，导致应用程序在运行时崩溃。

在方法 dequeueReusableCell(withIdentifier:for:) 中，你注意到 *Reusable Cell* 这个词了吗？表格视图中的单元格只会创建一次，然后可以反复使用。这有助于提高性能，使一切运行得更快更顺畅，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多的生日时，滚出屏幕顶部的单元格会被重用。它们会被填充上新信息，并重新出现在屏幕底部。UITableView 会自动完成这个工作。当表格视图加载时，tableView(_:cellForRowAt:) 会为每一行调用一次。当用户滚动查看更多单元格时，每当一个单元格即将出现在屏幕上时，它会再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日，在 birthdays[0] 中，应该显示在第 0 行。第二个生日，在 birthdays[1] 中，应该显示在第 1 行，以此类推，这意味着 indexPath 的行号与我们想要访问的 birthdays 数组中的位置相同。在 ➋ 处的代码通过使用 indexPath.row 来访问正确的 Birthday 对象。一旦我们得到了正确的 Birthday 对象，就将其赋值给一个名为 birthday 的常量，这样我们就可以设置该单元格中的标签。

请注意，我们使用 let 将生日赋值给常量而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的 birthday 常量。每个单元格都会得到一个自己的 birthday 常量，并被赋予自己的 Birthday 对象。由于我们不打算更改任何生日常量——我们只是读取它们的属性——因此我们不需要将它们设为变量。

现在你有了单元格和生日，是时候填写详细信息了。每个单元格需要两个标签来显示生日人的名字和出生日期。你将单元格设置为副标题样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含这些标签，所以现在你不需要自己创建任何标签了。

这些标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。在 ➌ 处，代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，两者之间用空格隔开。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView( _:cellForRowAt:) 在 ➎ 返回该单元格，以便它可以在表视图的那个 indexPath 上显示。

### 将一切整合在一起

现在，你可以使用 Add Birthday 视图控制器将生日实例添加到应用中，并且你有一个表视图来列出每个生日，在 Birthdays 表视图控制器中显示。但当你尝试运行应用并添加生日时，它并没有出现。为了让每个添加的生日出现在表视图中，你需要让 Add Birthday 视图控制器与 Birthdays 表视图控制器进行通信。你可以通过使用 *委托* 来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 展示在自己之上。A 知道 B 的存在，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它只是被创建出来的，不知道自己是从哪里来的，也不知道怎么到达这里的。那么 B 怎么与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项任务或工作交给别人。一个 *委托* 就像是一个老板，告诉被委托的员工该做什么。当被委托的员工完成任务后，有时会向委托的老板汇报信息。

Swift 中的委托与此类似，不过我们不是用老板和员工的方式，而是使用委托对象和被委托对象。由于是类 A 告诉类 B 要做什么，类 B 是被委托对象。我们给类 B 一个特殊的属性，称为 delegate，用来告诉它谁是它的委托——这样它就知道该与谁进行通信。委托可以是任何拥有在 *协议* 中定义的方法集合的类。协议就像是两者之间的约定，告知它们委托可以要求被委托对象执行什么操作。它列出了委托可以使用的被委托对象的各种方法和属性名。

类 A 创建类 B，使自己成为类 B 的委托，并给类 B 赋予一个符合协议的任务。一旦类 B 完成了任务，它就会向类 A 报告。让我们看看这个在我们的应用中是如何工作的。

Birthdays 表视图控制器是视图控制器 A，而 Add Birthday 视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将被 Add Birthday 视图控制器用来报告结果。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日列表视图控制器创建了添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从添加生日视图控制器传递到生日列表视图控制器。*

`AddBirthdayViewControllerDelegate` 协议被定义为只有一个方法 `addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存按钮 ➌ 时，添加生日视图控制器调用这个方法 ➍ 并将新的生日传递给它的委托，即生日列表视图控制器。生日列表视图控制器接收这个生日，将其添加到它的生日数组中，然后重新加载它的表格视图 ➎，以便新的生日显示在表格中。

我们将向你展示如何创建一个 `AddBirthdayViewControllerDelegate` 协议，包含方法 `addBirthdayViewController(_:didAddBirthday:)`，该方法可以在每次有生日被添加到应用时，由添加生日视图控制器调用。生日列表视图控制器将实现该协议方法，这样当使用添加生日视图控制器添加生日时，添加生日视图控制器就可以对其委托说：“嘿！有人刚刚添加了这个生日，”然后生日列表视图控制器会收到消息并回应：“哦！我会把它添加到我的列表中，并刷新显示，确保新的生日会显示出来。”

那么现在，让我们来写这段代码吧！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，*在* `AddBirthdayViewController` 类的上方，添加这段代码来定义 `AddBirthdayViewControllerDelegate` 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处定义协议，通过键入关键字 `protocol` 后跟协议名称 `AddBirthdayViewControllerDelegate`。这个名字很长，但 Swift 程序员通常会根据调用类的名称来命名协议，并在末尾加上单词 `Delegate`。这样，你就能通过查看协议的名称来分辨哪个类正在使用该协议。既然你现在是一个 Swift 程序员，你应该遵循相同的命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)` 是唯一的函数，它用于将生日对象传回给委托类 ➋。注意，在这个函数中你包含了 `AddBirthdayViewController` 作为参数。再次强调，Swift 程序员通常会根据约定来实现协议方法，因此你也应该这样做。这样做有助于知道是谁发回了消息，并且让委托能够访问该对象及其类。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为`addBirthdayViewController`参数传入。你很快就会看到这是如何完成的。另一个需要注意的事情是外部参数名`didAddBirthday`。许多代理协议方法包含*did*和*will*，因为它们用来描述调用类刚刚做了什么或将要做什么。

现在你已经定义了协议，接下来需要告诉 Birthdays 表视图控制器采用这个协议并使用协议的方法。

##### 让 Birthdays 表视图控制器遵循协议

为了采用该协议，Birthdays 表视图控制器需要将自己设为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，在 UITableViewController 父类之后，添加 AddBirthdayViewControllerDelegate。 在类的顶部，在 UITableViewController 后面加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做了，一个红色错误就会出现。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！别担心——我们很快就会修复这个问题。

在这里需要注意的是，BirthdaysTableViewController 是从 UITableViewController 父类继承的。一个类只能有一个父类，并且该父类的名称必须写在任何协议之前。但是，虽然一个类只能有一个父类，它可以采用任意数量的协议——这些协议会列在父类之后，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加`addBirthdayViewController(_:didAddBirthday:)`方法。一个合适的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成会建议你整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它期待你添加这个方法。注意，不像子类方法那样，你在`addBirthdayViewController(_:didAddBirthday:)`前面不需要使用`override`关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的`append(_:)`方法来完成这个操作 ➋。接下来，你需要刷新表视图，调用 tableView 属性的`reloadData()`方法来显示这个新的生日 ➌。当`reloadData()`被调用时，表视图的数据源方法会重新被调用，新的生日会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这并不是必须的，但将类的不同部分进行标记是一种良好的编码风格，有助于保持代码清晰和可读。注释的第一部分，MARK: -，是一个 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单帮助你快速找到方法，并让你能够跳转到代码中的不同位置。要使用这个菜单，点击编辑器面板顶部的“Birthdays TableViewController”，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为添加生日视图控制器设置委托

BirthdaysTableViewController 已经遵循了 AddBirthdayViewControllerDelegate 协议。现在是时候让“添加生日”视图控制器使用 AddBirthdayViewControllerDelegate 协议来通知“生日”表视图控制器它已经添加了一个生日。为此，“添加生日”视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个可选的委托属性（类型为 AddBirthdayViewControllerDelegate），并将以下行插入到 outlets 下方来安排这一步：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是一个可选项，因为你不能在“添加生日”视图控制器创建之前设置它。你很快就会知道在哪里设置委托。

既然“添加生日”视图控制器已经有了委托，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日传递给委托。将 saveTapped(_:) 方法修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码在 ➊ 处通过 addBirthdayViewController(_:didAddBirthday:) 将其传回委托。

很棒！你已经完成了对“添加生日”视图控制器的修改。现在它已经拥有一个委托，会监听生日保存的回调。运行应用程序，看看会发生什么。

嗯……似乎没什么变化。当你添加一个生日时，仍然看不到它出现在“生日”表视图控制器中。怎么回事？

#### 通过设置委托连接这两个控制器

还有最后一件事需要做。“生日”表视图控制器是 AddBirthdayViewControllerDelegate，且“添加生日”视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来存储它在保存生日时与之通信的委托。但是我们从未明确地将委托属性设置为“生日”表视图控制器。所以，现在是时候在这两个视图控制器之间建立通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除包围它的/*和*/，取消注释该方法。

每当 Birthdays 表视图控制器失去屏幕控制并且应用程序通过故事板 segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将 Birthdays 表视图控制器传递给 Add Birthday 视图控制器，并将其设置为 Add Birthday 视图控制器的委托。请在 prepare(for:sender:)方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的委托为 Birthdays 表视图控制器只需要三行代码。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 已经留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，它位于准备该方法时的 segue 另一端，但对于这个应用程序，目标并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到导航控制器中，以便拥有带有取消和保存按钮的导航栏。因此，你不会期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊这一行获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定子类，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController➋。topViewController 就是在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其强制转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的特定子类。最后，当你获得 AddBirthdayViewController 时，你可以将委托设置为 self，而 self 当前是 Birthdays 表视图控制器➌。

现在运行应用程序并添加一些生日！你在 Birthdays 表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序，然后重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在这一章中，你学会了如何创建一个表视图控制器来显示你的生日列表。你还学会了如何在 Add Birthday 视图控制器中添加生日，并且如何使用委托将生日添加到 Birthdays 表视图控制器中的生日数组，以便显示出来。

在 第十二章 中，你将学习如何将生日保存到设备中，这样即使退出应用程序并重新启动，它们仍然会显示。为了保存生日，你将使用我们在项目一开始设置的 Core Data。

Birthdays 表视图控制器将显示应用程序中所有存储的生日列表。你还记得用什么来存储一系列项目吗？没错——数组！你将在 BirthdaysTableViewController 中创建一个数组，用于存储所有的生日。为此，在类的顶部，紧接着 viewDidLoad() 方法上方，插入这行代码以添加一个名为 birthdays 的数组属性：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行代码创建了一个空的 Birthday 实例数组。它需要是一个变量而不是常量，因为你希望每次用户通过添加生日视图控制器添加生日时，将一个保存的 Birthday 添加到这个数组中。你将在 “使 Birthdays 表视图控制器符合协议” 中，具体位置在 第 168 页 中看到如何做。

**注意**

*记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *获取。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性，以便将出生日期显示为格式化的字符串。在 birthdays 数组下面添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，通过 let 创建。尽管你会修改 dateFormatter 的属性，例如 dateStyle 和 timeStyle，但你永远不会改变 dateFormatter 本身。

你还需要设置 dateFormatter，使其能够以完整的格式显示出生日期，例如“2008 年 12 月 17 日，星期二”。正如你在 第十章 中看到的，设置这个的一个好地方是在 viewDidLoad() 方法中，这个方法在 Birthdays 表视图控制器加载视图时被调用。这里是进行任何所需设置的完美位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 dateFormatter 的 dateStyle，使其能够为每个 Birthday 显示格式化的日期字符串。你有没有注意到我们只写了 .full，而不是 DateFormatter.Style.full？Swift 知道 dateFormatter 的 dateStyle 应该是什么类型，所以允许我们用这个小技巧。在 ➋ 处，你将 dateFormatter 的 timeStyle 设置为 .none，以便时间不会显示出来。

#### 在表视图中显示生日

BirthdaysTableViewController 类有一个表视图，用于显示单列中的项目列表。该表视图有一个或多个包含行的部分，每个行中包含一个单元格。表视图中的部分是一个行的分组，可以选择是否显示标题。显示多个部分的表视图的应用程序示例是设置应用，如 图 11-5 所示。它显示了已拆分成不同部分的行列表。

表视图的每个部分和行都通过一个索引号来标识。这些数字从 0 开始，然后随着你向下滚动表视图逐渐增加。例如，在设置应用中，Privacy 行位于第零部分，第 1 行；News 设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为 *表视图数据源* 的部分，其中包含三个方法。表视图控制器使用这些方法来确定将显示在表视图中的内容。

numberOfSections(in:) 告诉表视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表视图在每个部分中将显示多少行

tableView(_:cellForRowAt:) 设置将要在每行显示的每个单元格

![](img/Image00243.jpg)

*图 11-5：设置应用程序使用部分将不同设备设置的行进行分组。*

每次表视图重新加载时，表视图控制器都会调用表视图数据源方法。Xcode 在你创建 UITableViewController 的子类时会自动为你提供这些方法模板。你需要实现这三个方法，才能让应用程序正常工作，即使你在代码中不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，带有这些数据源方法，用于确定表视图中将显示的内容。我们将在 “代理” 章节的第 166 页讨论协议。目前，你只需要知道，UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要手动调用它们。

我们从方法 numberOfSections(in:) 开始。Birthdays 表视图控制器是一个只显示生日实例的列表，因此它不需要多个部分。为了设置表视图中的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 tableView 的 UITableView 作为参数，它是使用这个类作为数据源的表格视图。我们不需要担心如何建立这个连接，因为 UITableViewController 自带一个内建的表格视图，并且自动与这些方法关联。每个生日都会显示在自己的行中。所以在 tableView(_:numberOfRowsInSection:)方法中，为了能够为所有的生日显示正确的行数，你需要返回 birthdays 数组中 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，表示数组中有多少项，非常适合这种情况！将这个方法改成以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，tableView(_:numberOfRowsInSection:)方法还接受一个名为 section 的 Int 类型参数。当表格视图加载时，该方法会针对表格视图中的每个 section 被调用。在我们的例子中，只有一个 section，所以我们无需关心当前显示的是表格视图的哪个 section。我们知道它是 section 0，并且我们希望它的行数等于生日的数量，因此我们写下 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:)方法，以便表格视图知道每个单元格中要显示什么内容。由于这个方法被注释掉了，你需要通过删除/*和*/将其取消注释。（小心不要不小心取消注释后面的其他方法！）取消注释后，将其修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要直接调用 tableView(_:cellForRowAt:)方法。它会在表格视图加载到屏幕上时被调用。它会针对屏幕上的每个单元格被调用，并且接受两个参数，tableView 和 indexPath。你已经知道 tableView 参数是干什么的了。IndexPath 是 Swift 中的一个结构体，用来表示表格视图中某一行的位置。IndexPath 实例有两个属性：section 和 row。由于这个方法会被多次调用（每一行调用一次），所以我们需要使用 indexPath 来知道当前正在配置的是哪个 section 和 row。indexPath.section 属性表示 section 的编号，indexPath.row 表示表格视图单元格的行号。tableView(_:cellForRowAt:)方法中的五行代码将完成以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 找出在 birthdays 数组中将要在单元格中显示的生日

• 创建两个标签，以便在单元格中显示生日人的姓名和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 `UITableViewCell`。代码 ➊ 使用方法 `dequeueReusableCell(withIdentifier:for:)` 来实现这个操作。不过，在你开始使用这个方法之前，需要告诉方法你希望从 storyboard 中使用哪个单元格。之前在 storyboard 中，你为单元格设置了标识符 `birthdayCellIdentifier`（参见图 11-4）。这个标识符将你的代码和单元格链接起来，并告诉你的方法正在使用正确的单元格。当你调用这个方法时，传入的字符串必须与在 storyboard 中设置的字符串完全一致，否则你会遇到错误，应用程序在运行时会崩溃。

在方法 `dequeueReusableCell(withIdentifier:for:)` 中，你注意到有 *Reusable Cell* 这几个字吗？表视图中的单元格只会被创建一次，然后可以反复使用。这有助于提高运行速度和流畅度，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日，但一次只会显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以查看更多生日时，滚动出屏幕顶部的单元格会被重用。它们会被填充新的信息，然后出现在屏幕底部。`UITableView` 会自动处理这些工作。当表视图加载时，`tableView(_:cellForRowAt:)` 会为每一行调用一次。当用户滚动查看更多单元格时，它会在每一行即将出现在屏幕上时再次调用。

接下来，我们需要找出哪个 `Birthday` 应该显示在单元格中。我们希望在每一行中显示 `birthdays` 数组中的一个生日。第一个生日，位于 `birthdays[0]`，应该显示在第 0 行。第二个生日，位于 `birthdays[1]`，应该显示在第 1 行，以此类推，这意味着 `indexPath` 的 `row` 与我们想要访问的 `birthdays` 数组中的位置相同。代码 ➋ 使用 `indexPath.row` 来访问 `birthdays` 数组中的正确 `Birthday` 对象。拿到正确的 `Birthday` 对象后，我们将其赋值给一个名为 `birthday` 的常量，以便设置单元格中的标签。

请注意，我们使用 `let` 来将生日赋值给常量，而不是变量。我们之所以使用 `let`，是因为每次调用 `tableView(_:cellForRowAt:)` 时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并且被赋予自己对应的 `Birthday` 对象。由于我们不会改变任何生日常量——只是读取它们的属性——所以不需要将它们设置为变量。

现在你已经有了单元格和生日，接下来是时候填写详细信息了。每个单元格需要两个标签来显示生日人的名字和出生日期。你将单元格设置为标题样式，以便它有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，所以现在你不需要自己创建标签了。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。在➌处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格隔开。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView( _:cellForRowAt:) 在➎处返回该单元格，以便在表视图的相应 indexPath 位置显示它。

### 将所有内容结合起来

现在你可以通过 Add Birthday 视图控制器向应用中添加生日实例，并且你有一个表视图来列出每个生日，显示在 Birthdays 表视图控制器中。但当你尝试运行应用并添加生日时，它并没有出现。为了让你添加的每个生日在表视图中显示出来，你需要让 Add Birthday 视图控制器与 Birthdays 表视图控制器进行通信。你可以通过使用*委托（delegation）*来实现这一点。

#### 委托

委托（Delegation）可用于当一个视图控制器需要从另一个视图控制器获取信息时。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己之上。A 知道 B，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但 B 并不知道 A，它只是被创建出来并且不知道自己是如何被创建或在哪里被创建的。那么 B 怎么与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托就是当某人将工作或任务交给其他人做。*委托（delegate）*就像一个老板，告诉委托员工做什么。当委托员工完成任务后，他们有时会将信息报告给老板。

在 Swift 中，委托的概念非常相似，但不再是老板和员工的关系，而是有一个委托（delegate）和一个委托对象（delegating object）。由于类 B 是由类 A 告诉做什么的，所以它是委托对象。我们给类 B 一个特殊的属性，叫做 delegate，用来告诉它它的委托对象是谁——这样它就知道该与谁通信。委托可以是任何一个类，这个类定义了一些方法，这些方法在一个*协议（protocol）*中进行定义。协议就像是两个类之间的约定，告诉它们委托可以要求委托对象做些什么。协议列出了委托可以用来与委托对象交互的方法和属性。

类 A 创建类 B，使自己成为类 B 的委托对象，并为类 B 分配一个在协议中定义的任务。类 B 完成任务后，会向类 A 报告。让我们看看在我们的应用中是如何工作的。

Birthdays 表视图控制器是视图控制器 A，Add Birthday 视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，Add Birthday 视图控制器将使用这个方法向 A 控制器报告。

看一下 图 11-6。当用户点击添加按钮 ➊ 时，生日表格视图控制器创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从添加生日视图控制器传递到生日表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为具有一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，添加生日视图控制器会调用这个方法 ➍ 并将新生日传递给它的委托，即生日表格视图控制器。生日表格视图控制器会接受这个生日，将其添加到生日数组中，然后重新加载表格视图 ➎ ，以便新生日能够显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，该协议包含方法 addBirthdayViewController(_:didAddBirthday:)，当在应用中添加生日时，添加生日视图控制器可以调用该方法。生日表格视图控制器将实现这个协议方法，以便每当通过添加生日视图控制器添加生日时，添加生日视图控制器只需对它的委托说：“嘿！有人刚刚添加了这个生日，”生日表格视图控制器会收到这个消息并说：“哦！我会将其添加到我的列表中，并刷新我的显示，这样新的生日就会显示出来。”

所以现在让我们在代码中实现这个功能吧！

##### 创建一个协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，*在* AddBirthdayViewController 类的上方，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过键入关键字 protocol 来定义协议，然后是协议的名称 AddBirthdayViewControllerDelegate，位置在 ➊ 。这个名字很长，但 Swift 程序员通常会根据调用类的名称来命名协议，并在末尾加上 Delegate 一词。这样，你就能通过查看协议的名字来知道哪个类在使用这个协议。既然你现在是 Swift 程序员了，就应该遵循这个命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传回给委托类 ➋ 。注意，你在这个函数中包括了 AddBirthdayViewController 作为一个参数。再次强调，Swift 程序员在实现协议方法时通常按照约定这么做，因此你也应该遵循这个约定。这样做有助于了解是谁发送回了消息，并且让委托能够访问该对象及其类。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递进来。你很快就会看到这是如何实现的。需要注意的另一个问题是外部参数名 didAddBirthday。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚做完或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表格视图控制器采用这个协议，并使用该协议的方法。

##### 使 Birthdays 表格视图控制器遵循协议

为了采纳协议，Birthdays 表格视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，紧接着 UITableViewController 超类后面，添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后面加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色错误就会出现。这是因为 BirthdaysTableViewController 表示它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心，我们很快就会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是从 UITableViewController 超类继承而来。一个类只能有一个超类，并且这个超类名必须在任何协议之前写明。但尽管一个类只能有一个超类，它可以采纳任意多个协议——这些协议将列在超类之后，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要向 Birthdays TableViewController 添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成会建议你使用整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它预期你会添加这个方法。注意，不像子类化的方法，你不需要在 addBirthdayViewController(_:didAddBirthday:) 前使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现这一点 ➋。接下来，你需要刷新表格视图，以便显示这个新生日，可以通过调用 tableView 属性上的 reloadData() 方法 ➌。当调用 reloadData() 时，表格视图的数据源方法将会再次被调用，新增的 Birthday 会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必需的，但它是一种良好的编码风格，可以帮助标记类的不同部分，同时保持代码的清晰和可读性。注释的第一部分 `MARK: -` 是 Xcode 识别的特殊关键字，用于代码注释，它会将 *AddBirthdayViewControllerDelegate* 部分添加到一个下拉目录菜单中，这个菜单可以在类的顶部使用。这个下拉菜单帮助你快速找到方法，并跳转到代码中的不同位置。要使用这个菜单，可以点击编辑器面板顶部的 *Birthdays TableViewController*，正如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器提供委托

*BirthdaysTableViewController* 已经采用了 *AddBirthdayViewControllerDelegate* 协议。现在是时候让 *Add Birthday* 视图控制器使用 *AddBirthdayViewControllerDelegate* 协议，通知 *Birthdays* 表格视图控制器它已经添加了一个生日。为此，*Add Birthday* 视图控制器首先需要定义一个委托。我们通过在 *AddBirthdayViewController* 类中添加一个可选的委托属性，类型为 *AddBirthdayViewControllerDelegate*，来实现这一点，并将以下代码插入到 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在创建 *Add Birthday* 视图控制器之后，你无法设置它。你将在稍后了解如何设置委托。

现在 *Add Birthday* 视图控制器有了一个委托，在 `saveTapped(_:)` 方法中，你可以通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将一个生日传递给委托。将 `saveTapped(_:)` 方法修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码在 ➊ 处通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将其传回委托。

太好了！你已经完成了对 *Add Birthday* 视图控制器的更改。现在它有一个委托，能够监听生日保存的调用。运行应用程序，看看会发生什么。

嗯……变化不大。当你添加一个生日时，它仍然没有显示在 *Birthdays* 表格视图控制器中。这是怎么回事？

#### 通过设置委托连接这两个控制器

还有最后一件事需要做。*Birthdays* 表格视图控制器是一个 *AddBirthdayViewControllerDelegate*，而 *Add Birthday* 视图控制器有一个 *AddBirthdayViewControllerDelegate* 类型的属性，用于保存与其通信的委托，当生日保存时就会触发。然而，我们还没有明确地将委托属性设置为 *Birthdays* 表格视图控制器。现在是时候连接这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除其前后的/*和*/来取消注释该方法。

每当生日表视图控制器退出其屏幕并且应用程序使用故事板 segue 转到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将生日表视图控制器传递给添加生日视图控制器，并将其自身设置为添加生日视图控制器的代理。在 prepare(for:sender:)方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的代理为生日表视图控制器只需要三行代码。首先，你需要能够通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 在注释中提示了如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，指向在此方法中正在准备的 segue 的另一端，但本应用程序的目标不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到导航控制器中，这样你就可以拥有带有“取消”和“保存”按钮的导航栏。因此，你不期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。在➊这一行，你可以获得 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定子类，我们需要使用`as`将其强制转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其强制转换为 AddBirthdayViewController，以表示该控制器是 UIViewController 的特定子类。最后，当你获得 AddBirthdayViewController 时，可以将代理设置为 self，也就是当前的生日表视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表视图控制器中看到了什么？生日！生日！生日！不过，我们还没完全完成。如果你退出应用并再次运行，之前的生日会消失。我们还需要将生日保存到设备中，具体操作将在第十二章中完成。

### 你学到了什么

在本章中，你学习了如何创建一个表视图控制器来显示你的生日列表。你还学习了如何在添加生日视图控制器中添加生日，然后如何使用代理将生日添加到生日表视图控制器中的生日数组中，以便显示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使你退出应用并重新运行，它们也会显示出来。为了保存生日，你将使用 Core Data，我们在项目一开始就已经设置了它。

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的`Birthday`实例数组。它需要是一个变量而非常量，因为你希望每次用户通过“添加生日”视图控制器添加生日时，都将一个保存的生日添加到这个数组中。你将在“使 Birthdays 表格视图控制器符合协议”中看到如何实现这一点，第 168 页。

**注意**

*请记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *获取。*

`BirthdaysTableViewController`还需要一个`dateFormatter`属性，用于将生日显示为格式化的字符串。在`birthdays`数组下方添加一个`dateFormatter`：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

注意，`dateFormatter`是一个使用`let`创建的常量。尽管你会改变`dateFormatter`的属性，如`dateStyle`和`timeStyle`，但你永远不会改变`dateFormatter`本身。

你还需要设置`dateFormatter`，使其将生日显示为完整的格式化字符串，如"Tuesday, December 17, 2008"。正如你在第十章中看到的，做这件事的一个好地方是`viewDidLoad()`方法，该方法在`Birthdays`表格视图控制器加载视图时调用。这是为该类进行任何设置的理想位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在➊，你设置了`dateFormatter`的`dateStyle`，使其显示每个生日的格式化日期字符串。你有没有注意到我们写的是`.full`而不是`DateFormatter.Style.full`？Swift 知道`DateFormatter`的`dateStyle`需要什么类型，所以它允许我们简化写法。在➋，你将`dateFormatter`的`timeStyle`设置为`.none`，这样就不会显示时间。

#### 在表格视图中显示生日

`BirthdaysTableViewController` 类包含一个用于显示单列项目列表的表格视图。表格视图有一个或多个包含行的部分，每行包含一个单元格。表格视图中的部分是行的分组，可以显示也可以不显示标题。一个显示有多个部分的表格视图应用实例是设置应用，如图 11-5 所示。它显示了已拆分为不同部分的行列表。

表格视图的每个部分和行都有一个索引编号。这些编号从 0 开始，往下每行加 1。例如，设置应用中的隐私选项在部分 0，行 1。新闻设置位于部分 1，行 3。

在 `BirthdaysTableViewController` 类的中间，有一个名为 *Table view data source* 的 section，包含三个方法。表格视图控制器使用这些方法来确定将要在表格视图中显示的内容。

`numberOfSections(in:)` 告诉表格视图它应该有多少个 section。

`tableView(_:numberOfRowsInSection:)` 告诉表格视图每个 section 中将显示多少行。

`tableView(_:cellForRowAt:)` 设置将要显示在表格视图每一行中的每个单元格。

![](img/Image00243.jpg)

*图 11-5：设置应用使用 section 来分组不同的设备设置行。*

每次表格视图重新加载时，表格视图控制器都会调用表格视图的数据源方法。当你创建一个 `UITableViewController` 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现这三个方法，才能让应用正常工作，尽管你在代码中不会直接调用它们。`UITableViewController` 类实现了 `UITableViewDataSource` 协议，其中包含这些数据源方法，用来确定表格视图中将显示的内容。我们将在 “委托” 一节中讨论协议。现在，你只需要知道 `UITableViewController` 使用这些方法来显示内容，并且会自动调用这些方法，因此你无需手动调用它们。

我们先从方法 `numberOfSections(in:)` 开始。`Birthdays` 表格视图控制器是一个只显示 `Birthday` 实例的列表，因此它不需要多个 section。要设置表格视图中的 section 数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 `tableView` 的 UITableView 作为参数，这个表格视图使用这个类作为其数据源。我们不需要担心建立这个连接，因为 `UITableViewController` 自带一个内建的表格视图，它会自动连接到这些方法。每个生日都会显示在自己的一行中。所以在 `tableView(_:numberOfRowsInSection:)` 中，为了让所有的生日有正确的行数，你需要返回 `birthdays` 数组中生日实例的数量。你记得数组的 `count` 属性吗？它是一个整数，告诉你数组中有多少项，非常适合这个场景！将这个方法改为如下：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 `tableView` 参数，`tableView(_:numberOfRowsInSection:)` 还接受一个名为 `section` 的 Int 类型参数。当表格视图加载时，这个方法会为表格视图中的每个 section 调用。在我们的例子中，我们只有一个 section，因此不需要担心这里是哪个 section 正在显示。我们知道它是 section 0，并且希望它有与生日数量相同的行数，所以我们写下 `return birthdays.count`。

最后，你需要实现 tableView(_:cellForRowAt:) 方法，这样表视图就会知道在每个单元格中放入什么内容。由于这个方法已被注释掉，你需要通过删除包围它的 /* 和 */ 来取消注释。（小心不要不小心取消注释它后面的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你并不直接调用方法 tableView(_:cellForRowAt:)。它会在表视图加载到屏幕时自动调用。它会为屏幕上的每个单元格调用，并接收两个参数：tableView 和 indexPath。你已经知道 tableView 参数的作用了。IndexPath 是一个 Swift 结构体，用于表示表视图中某一行的位置。一个 IndexPath 实例有两个属性：section 和 row。由于这个方法会被多次调用（每次针对表中的一行），我们需要通过 indexPath 来确定当前正在配置的是哪一节和哪一行。indexPath.section 属性提供节的编号，indexPath.row 提供表视图单元格的行号。tableView(_:cellForRowAt:) 中的五行代码会执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定在 birthdays 数组中哪一个生日将在单元格内显示

• 创建两个标签，用于在单元格中显示生日人的名字和出生日期

• 返回准备好显示在表视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。代码 ➊ 使用 dequeueReusableCell(withIdentifier:for:) 方法来实现这一点。不过，在你开始使用这个方法之前，你需要告诉它你想从 storyboard 中使用哪个单元格。之前在 storyboard 中，你为单元格设置了标识符 birthdayCellIdentifier（见 图 11-4）。这个标识符将你的代码与单元格关联起来，并告诉方法它正在使用正确的单元格。当你调用这个方法时，传入的字符串需要与 storyboard 中设置的字符串完全相同，否则你会遇到错误，且应用会在运行时崩溃。

在方法 dequeueReusableCell(withIdentifier:for:) 中，你注意到 *Reusable Cell* 这两个词了吗？表视图中的单元格是创建一次，然后可以反复使用。这有助于加快程序的运行速度，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，滚出屏幕顶部的单元格会被重新使用。它们会被填充上新的信息，并重新出现在屏幕的底部。UITableView 会自动处理这个工作。当表视图加载时，tableView(_:cellForRowAt:) 会为每一行调用一次。当用户滚动查看更多单元格时，它会在每一行即将出现在屏幕上时再次被调用。

接下来，我们需要找出应该显示在单元格中的生日。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日，即 birthdays[0]，应该显示在第 0 行。第二个生日，位于 birthdays[1]，应该显示在第 1 行，依此类推，这意味着 indexPath 的行与我们想要访问的 birthdays 数组中的位置相同。➋ 处的代码通过使用 indexPath.row 访问正确的 Birthday 对象。一旦我们得到了正确的 Birthday 对象，我们就将其赋值给一个名为 birthday 的常量，以便设置这个单元格中的标签。

请注意，我们使用 let 将生日赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并且赋值为它自己的 Birthday 对象。由于我们不打算修改任何生日常量——我们只是读取它们的属性——所以我们不想将它们设为变量。

现在你已经有了单元格和生日，是时候填写详细信息了。你需要为每个单元格添加两个标签，以显示生日人物的名字和出生日期。你将单元格设置为 Subtitle 样式，这样它就有了 Title 标签和 Subtitle 标签。每个单元格已经包含这些标签，因此你现在不需要自己创建标签。

这些标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，二者之间有一个空格。➍ 处，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 会在 ➎ 返回该单元格，以便在该 indexPath 显示在表格视图中。

### 将一切整合在一起

现在，你可以使用添加生日视图控制器向应用程序中添加 Birthday 实例，并且你已经有了一个表格视图来列出 Birthdays 表格视图控制器中的每个 Birthday。但是当你尝试运行应用并添加一个 Birthday 时，它并没有出现。为了让你添加的每个 Birthday 在表格视图中显示，你需要让添加生日视图控制器与 Birthdays 表格视图控制器进行通信。你可以通过使用 *委托* 来实现。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 展示在自己之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它刚刚被创建，并不知道它是从哪里来的或如何到达的。那么 B 怎么和 A 交流呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将工作或任务交给别人。一个*委托*就像一个老板，告诉委托的员工该做什么。当委托的员工完成任务时，有时他们会向委托的老板报告信息。

Swift 中的委托非常相似，不过我们用的是委托对象和委托的对象，而不是老板和员工。由于类 B 是由类 A 告诉该做什么的，因此类 B 是委托对象。我们给类 B 一个特殊的属性，称为 delegate，来告诉它谁是它的代理—这样它就知道应该与谁沟通。代理可以是任何实现了在*协议*中定义方法的类。协议就像是两类之间的约定，告诉它们代理可以要求委托对象执行什么操作。它列出了代理可以与委托对象一起使用的方法和属性名。

类 A 创建类 B，将自己设为类 B 的代理，并给类 B 分配协议中的任务。一旦类 B 完成任务，它会向类 A 报告。让我们看看在我们的应用中是如何实现的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法由添加生日视图控制器用于报告返回。

请查看图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器会创建添加生日视图控制器 ➋，并将自己设置为添加生日视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议定义了一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，添加生日视图控制器会调用此方法 ➍，并将新添加的生日传递给其代理，生日表视图控制器。生日表视图控制器接收这个生日，将其添加到生日数组中，然后重新加载表视图 ➎，这样新添加的生日就会出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并实现 addBirthdayViewController(_:didAddBirthday:) 方法，这样每当有生日被添加到应用时，添加生日视图控制器就可以调用这个方法。生日表视图控制器将实现这个协议方法，以便每当通过添加生日视图控制器添加生日时，添加生日视图控制器可以对其代理说：“嘿！有人刚刚添加了这个生日”，然后生日表视图控制器会收到这个消息并说：“哦！我会把它添加到我的列表中，并刷新显示，让新生日出现在表中。”

现在让我们在代码中实现这一过程！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类之前，添加这段代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过在 ➊ 处输入关键字 protocol 并随后输入协议名 AddBirthdayViewControllerDelegate 来定义协议。这是个长名字，但 Swift 程序员通常会根据调用类的名称来命名协议，并在后面加上 Delegate 这个词。这样你就可以通过查看协议的名字来判断哪个类在使用这个协议。既然你现在是 Swift 程序员，你也应该遵循相同的命名规范。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传回给委托类 ➋。注意你在这个函数中包含了 AddBirthdayViewController 作为参数。再说一次，Swift 程序员在实现协议方法时通常这样做，因此你也应该坚持这么做。了解是谁发送回消息，以及委托方能够访问该对象及其类是很有用的。

当 Add Birthday 视图控制器调用此方法时，它将作为 addBirthdayViewController 参数传入。你很快就会看到如何实现这一点。另一个需要注意的点是外部参数名 didAddBirthday。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类已经做了或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays table view controller 去采用这个协议并使用协议的方法。

##### 使 Birthdays Table View Controller 遵循协议

要采用该协议，Birthdays table view controller 需要让自己成为一个 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，将 AddBirthdayViewControllerDelegate 添加到 UITableViewController 超类之后。在类的顶部，在 UITableViewController 后加上逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色错误就会出现。之所以会发生这种情况，是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心，我们很快会修复这个问题。

在这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，而且超类的名称必须在任何协议之前写出。但是，尽管一个类只能有一个超类，它可以采用任意数量的协议——这些协议都会列在超类之后，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:) 方法添加到 Birthdays TableViewController 中。添加这个方法的一个好位置是在类的末尾，就在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 的自动补全功能会建议整个方法声明。这是因为它知道这个类采纳了 AddBirthdayViewController Delegate 协议，并且它期望你添加这个方法。请注意，与子类方法不同，在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递进来的生日添加到 birthdays 数组中。你可以通过使用 append(_:) 方法来完成这个操作 ➋。接着，你需要刷新表格视图，以便它显示这个新添加的生日，可以通过调用 tableView 属性的 reloadData() 方法 ➌ 来完成。当调用 reloadData() 时，表格视图的数据源方法会再次被调用，新的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了注释来标记这一部分代码：// MARK: - AddBirthdayViewControllerDelegate ➊。这并不是必须的，但标记类的不同部分是良好的编码风格，它有助于保持代码整洁易读。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你查找方法，并跳转到代码的不同位置。要使用这个菜单，可以点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器设置委托

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在，轮到 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表格视图控制器它已添加一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中插入以下代码行，在 outlets 下方添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性来安排这一点：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托(delegate)必须是可选的，因为在创建完*Add Birthday*视图控制器之后，才能设置它。稍后你会了解到如何设置委托。

现在，添加生日视图控制器有了代理，在 saveTapped(_:)方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:)方法将一个生日传递给代理。将 saveTapped(_:)方法修改如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)方法将其返回给代理。

很棒！你已经完成了对添加生日视图控制器的修改。现在，它有了一个代理，可以监听到生日保存的调用。运行应用程序看看会发生什么。

嗯……似乎变化不大。当你添加生日时，仍然看不到它出现在生日表格视图控制器中。这是怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事需要做。生日表格视图控制器是一个 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存了它在生日保存时与之通信的代理。但是我们从未明确地将代理属性设置为生日表格视图控制器。所以，现在是时候将我们的两个视图控制器之间的通信管道连接起来了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个已被注释掉的方法叫做 prepare(for:sender:)。通过删除/*和*/注释符号，取消注释这个方法。

这个方法会在生日表格视图控制器放弃其屏幕并且应用程序通过 storyboard segue 过渡到另一个视图控制器时自动调用。我们将使用这个方法将生日表格视图控制器传递到添加生日视图控制器中，并设置它作为添加生日视图控制器的代理。在 prepare(for:sender:)方法中编写以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码，就能将添加生日视图控制器的代理设置为生日表格视图控制器。首先，你需要能够通过 segue 参数访问到 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何实现这一点。UIStoryboardSegue 在这个方法中准备的 segue 的另一端有一个叫做 destination 的属性，但是这个应用的 destination 并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到了一个导航控制器中，这样你就可以有一个带有取消和保存按钮的导航栏。所以，你不期望在 segue 的另一端找到添加生日视图控制器。相反，destination 是一个包含 Add Birthday 视图控制器的 UINavigationController。➊处的代码可以得到 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是一个特定类型的 ViewController，所以我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 就是在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的特定子类。最后，当你拥有 AddBirthdayViewController 时，你可以将委托设置为 self，它当前是 Birthdays 表格视图控制器 ➌。

现在运行应用并添加一些生日！你在 Birthdays 表格视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果退出应用并重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，方法将在第十二章中介绍。

### 你学到了什么

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学习了如何在 Add Birthday 视图控制器中添加一个生日，然后如何使用委托将生日添加到 Birthdays 表格视图控制器中的生日数组，以便显示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使退出应用程序并重新运行，它们依然会显示。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

```
class BirthdaysTableViewController: UITableViewController {

    var
 birthdays = [Birthday
 ]()

    override func viewDidLoad() {

```

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量而不是常量，因为每次用户通过 Add Birthday 视图控制器添加生日时，你都会希望将保存的生日添加到这个数组中。你将在“让 Birthdays 表格视图控制器符合协议”中看到如何做到这一点，详见第 168 页。

**注意**

*请记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性来将出生日期显示为格式化良好的字符串。请在 birthdays 数组下方添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，是通过 let 创建的。尽管你会更改 dateFormatter 的属性，如 dateStyle 和 timeStyle，但你永远不会更改 dateFormatter 本身。

你还需要设置 dateFormatter，以便它能够显示完整格式化的出生日期字符串，如“Tuesday, December 17, 2008”。正如你在第十章中看到的，做这件事的好地方是 viewDidLoad()方法，它在 Birthdays 表格视图控制器加载视图时被调用。这是进行类所需任何设置的完美位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在➊，你设置了 dateFormatter 的 dateStyle，以便它为每个生日显示格式化的日期字符串。你注意到我们直接写了.full 而不是 DateFormatter.Style.full 吗？Swift 知道 DateFormatter 的 dateStyle 应该是什么类型，所以它允许我们使用这个小技巧。在➋，你将 dateFormatter 的 timeStyle 设置为.none，这样时间就不会显示了。

#### 在表格视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于在单列中显示项的列表。表格视图有一个或多个区段，每个区段包含若干行，每一行包含一个单元格。表格视图中的一个区段是若干行的分组，这些行可以带有或者不带有头部。一个显示多个区段的表格视图的应用实例是设置应用，如图 11-5 所示。它展示了一个被分成不同区段的行列表。

表格视图中的每个区段和行都有一个索引编号。这些编号从 0 开始，然后随着你向下浏览表格视图而增加。例如，设置应用中的“隐私”行位于区段 0，行 1。新闻设置位于区段 1，行 3。

在 BirthdaysTableViewController 类的中间，有一个名为*Table view data source*的区段，包含三个方法。表格视图控制器使用这些方法来确定将显示在其表格视图中的内容。

numberOfSections(in:) 告诉表格视图应该有多少个区段

tableView(_:numberOfRowsInSection:) 告诉表格视图每个区段中将显示多少行

tableView(_:cellForRowAt:) 设置将要在表格视图的每一行中显示的每个单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用区段来分组不同设备设置的行。*

每次表格视图重新加载时，表格视图控制器会调用表格视图数据源方法。当你创建一个 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。尽管你不会在代码中直接调用这些方法，但你需要实现所有三个方法才能让应用正常工作。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用于确定表格视图中将显示的内容。我们将在“委托”第 166 页讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要手动调用它们。

让我们从方法 numberOfSections(in:)开始。Birthdays 表格视图控制器是一个只显示 Birthday 实例的列表，因此它不需要多个区段。为了设置表格视图中的区段数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

该方法接受一个名为 tableView 的 UITableView 参数，它是使用该类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内置的表格视图，并且会自动与这些方法连接。每个生日将会在自己的行中显示。因此，在 `tableView(_:numberOfRowsInSection:)` 中，为了显示所有生日的正确行数，你需要返回 `birthdays` 数组中 Birthday 实例的数量。你还记得数组的 `count` 属性吗？它是一个整数，告诉你数组中有多少项，非常适合这种情况！将该方法修改为如下：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，`tableView(_:numberOfRowsInSection:)` 还接受一个名为 section 的 Int 参数。当表格视图加载时，该方法会为每个 section 被调用。在我们的例子中，我们只有一个 section，因此不需要担心检查表格视图显示的是哪个 section。我们知道它是 section 0，并且我们希望它有与生日数量相同的行数，所以我们写 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)`，让表格视图知道每个单元格应该显示什么内容。由于该方法目前被注释掉了，你需要通过删除 /* 和 */ 来取消注释它。（小心不要意外取消注释它后面的其他方法！）完成后，将其修改为如下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法 `tableView(_:cellForRowAt:)`。当表格视图加载到屏幕上时，系统会调用它。每当屏幕上显示一个单元格时，都会调用该方法，它接受两个参数：tableView 和 indexPath。你已经知道 tableView 参数的作用。IndexPath 是一个 Swift 结构体，用来表示表格视图中某一行的位置。一个 IndexPath 实例有一个 section 属性和一个 row 属性。由于该方法会被多次调用（每一行都会调用一次），我们需要 indexPath 来知道当前正在配置的是哪个 section 和 row。indexPath.section 属性提供了 section 编号，indexPath.row 提供了表格视图单元格的行号。`tableView(_:cellForRowAt:)` 方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定 `birthdays` 数组中哪个 Birthday 将显示在单元格中

• 创建两个标签来显示生日者的名字和出生日期

• 返回已准备好显示的单元格

让我们逐行解析这段代码。

首先，创建 UITableViewCell。➊ 处的代码使用 dequeueReusableCell(withIdentifier:for:) 方法来完成这项工作。但是，在你开始使用此方法之前，你需要告诉方法你想要使用哪个单元格，这个单元格来自于故事板。之前在故事板中，你为单元格设置了标识符 birthdayCellIdentifier（见 图 11-4）。这个标识符将你的代码与单元格关联起来，并告诉方法它正在使用正确的单元格。你调用此方法时的字符串需要与在故事板中设置的字符串完全一致，否则会出现错误，应用在运行时崩溃。

在方法 dequeueReusableCell(withIdentifier:for:) 中，你注意到 *Reusable Cell* 这个词了吗？表格视图中的单元格是创建一次后可以反复使用的。这有助于加速和优化性能，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动显示更多生日时，屏幕顶部滚动出去的单元格会被重用。这些单元格会被填充上新信息，并再次出现在屏幕底部。UITableView 会自动处理这些工作。当表格视图加载时，tableView(_:cellForRowAt:) 会为每一行可见的单元格被调用。当用户滚动查看更多单元格时，它会在每个即将出现在屏幕上的行上再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中从生日数组中显示一个生日。第一个生日，在 birthdays[0] 处，应显示在第 0 行。第二个生日，在 birthdays[1] 处，应显示在第 1 行，以此类推，这意味着 indexPath 的 row 与我们要访问的生日数组中的位置相同。➋ 处的代码通过使用 indexPath.row 从生日数组中访问正确的 Birthday 对象。一旦我们得到正确的 Birthday 对象，我们将其赋值给一个名为 birthday 的常量，以便在此单元格中设置标签。

请注意，我们使用 let 将生日赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都会有自己的生日常量，并且每个常量会被赋予它自己的 Birthday 对象。由于我们不会修改任何生日常量——我们只是读取它们的属性——因此我们不需要将它们设置为变量。

现在你已经有了单元格和生日，接下来是填充细节。你需要两个标签来显示生日人的名字和出生日期。你将单元格设置为 Subtitle 样式，这样它就会有一个 Title 标签和一个 Subtitle 标签。每个单元格已经包含了这些标签，所以现在你不需要自己创建任何标签。

标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。➌处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格隔开。在➍处，您使用 dateFormatter 的 string(from:)方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好时，tableView(_:cellForRowAt:) 返回该单元格（➎），以便它可以在表视图的相应索引路径处显示。

### 整合所有内容

现在你可以使用“添加生日”视图控制器向应用中添加生日实例，并且有一个表视图来列出每个生日，在“生日”表视图控制器中显示。然而，当你尝试运行应用并添加生日时，它并没有显示出来。为了让你添加的每个生日在表视图中显示出来，你需要让“添加生日”视图控制器与“生日”表视图控制器进行通信。你可以通过使用*代理*来实现这一点。

#### 代理模式

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用代理模式。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 展示在自己之上。A 知道 B 的存在，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但是 B 并不知道 A 的存在——它只是突然出现在这里，并不知道它从哪里来，也不清楚自己是如何到达这里的。那么 B 如何与 A 沟通呢？通过代理模式！

![](img/Image00245.jpg)

代理是指将一个任务或工作交给别人去做。*代理*就像一个老板，告诉一个委托员工该做什么。当委托员工完成任务后，有时会将信息报告给代理老板。

Swift 中的代理模式非常相似，不过我们不是用老板和员工的关系，而是用代理和委托对象。由于是类 A 告诉类 B 做什么，因此类 B 是委托对象。我们给类 B 一个特殊的属性，叫做代理（delegate），用来告诉它谁是它的代理，这样它就知道该与谁沟通。代理可以是任何一个具有协议中定义的某些方法的类。协议就像是两个类之间的约定，告诉它们代理可以要求委托对象做什么。协议中有一系列方法和属性的名称，代理可以用这些方法与委托对象进行交互。

类 A 创建类 B，使自己成为类 B 的代理，并给类 B 分配一个符合协议的任务。一旦类 B 完成任务，它会向类 A 报告。让我们看看这个在我们的应用中是如何运作的。

“生日”表视图控制器是视图控制器 A，“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为这个协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由“添加生日”视图控制器用来回报结果。

看一下 图 11-6。当用户点击添加按钮 ➊ 时，`Birthdays` 表视图控制器创建 `AddBirthdayViewController` ➋ 并将自己设置为 `AddBirthdayViewController` 的委托。

![](img/Image00246.jpg)

*图 11-6：新生日被添加并通过委托从 `AddBirthdayViewController` 传递到 `Birthdays` 表视图控制器。*

`AddBirthdayViewControllerDelegate` 协议被定义为只有一个方法，`addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存 ➌ 时，`AddBirthdayViewController` 调用这个方法 ➍ 并将新生日传递给它的委托，即 `Birthdays` 表视图控制器。`Birthdays` 表视图控制器接收这个生日，将其添加到它的生日数组中，然后重新加载表视图 ➎，确保新添加的生日会出现在表格中。

我们将向你展示如何创建一个 `AddBirthdayViewControllerDelegate` 协议，其中包含 `addBirthdayViewController(_:didAddBirthday:)` 方法，当生日被添加到应用时，`AddBirthdayViewController` 可以调用该方法。`Birthdays` 表视图控制器将实现该协议方法，以便每当通过 `AddBirthdayViewController` 添加生日时，`AddBirthdayViewController` 只需要告诉它的委托：“嘿！有人刚刚添加了这个生日，”然后 `Birthdays` 表视图控制器会接收到消息并回应：“哦！我会把它加到我的列表中并刷新显示，确保新添加的生日会出现。”

现在，让我们在代码中实现这一切吧！

##### 创建一个协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 `AddBirthdayViewController` 类的 *上方* 添加以下代码，定义 `AddBirthdayViewControllerDelegate` 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处通过输入关键字 `protocol` 后跟协议名 `AddBirthdayViewControllerDelegate` 来定义协议。这个名字很长，但 Swift 程序员通常会根据调用类的名称来命名协议，并在结尾加上 `Delegate` 这个词。这样，你就能通过协议的名称知道是哪个类在使用该协议。既然你现在是一个 Swift 程序员，你应该遵循相同的命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)` 是唯一的函数，用于将 `Birthday` 对象传回委托类 ➋。注意，你在这个函数中包含了 `AddBirthdayViewController` 作为一个参数。再次提醒，Swift 程序员通常会这样做，基于约定实现协议方法，所以你也应该这样做。知道是谁发送回了消息以及让委托访问该对象和其类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传入。很快你就会看到这是如何实现的。需要注意的另一点是外部参数名称 didAddBirthday。许多代理协议方法包含 *did* 和 *will*，因为它们用来描述调用类刚刚做了某事或即将做某事。

现在你已经定义了协议，接下来需要告诉 Birthdays 表格视图控制器采用这个协议并使用协议中的方法。

##### 使 Birthdays 表格视图控制器遵循协议

要采用这个协议，Birthdays 表格视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为此，你需要在 UITableViewController 超类后立即将 AddBirthdayViewControllerDelegate 添加到类定义中。在类的顶部，在 UITableViewController 后加上一个逗号，然后输入 AddBirthdayViewControllerDelegate ：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色错误就会出现。这是因为 BirthdaysTableViewController 表示它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！别担心，我们很快就会修复这个问题。

在这里需要特别注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，并且该超类的名称必须在任何协议之前写出。但是，尽管一个类只能有一个超类，它可以采用任意数量的协议——这些协议会在超类之后列出，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:) 方法添加到 Birthdays TableViewController 中。一个合适的地方是在类的末尾，紧接在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成功能建议了整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期待你添加这个方法。请注意，不像在子类化的方法中，你在 addBirthdayViewController(_:didAddBirthday:) 前不使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传入的 Birthday 添加到 birthdays 数组中。你可以使用 append(_:) 方法来实现这一点 ➋。接下来，你需要刷新表格视图，以便显示这个新添加的生日，可以通过调用 tableView 属性的 reloadData() 方法来实现 ➌。当 reloadData() 被调用时，表格视图的数据源方法会重新被调用，新增的 Birthday 会显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但在类中标记不同的部分是一个良好的编码风格，这有助于保持代码清晰且易于阅读。注释的第一部分，MARK: -，是一个 Xcode 识别的特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到下拉目录菜单中，您可以在类的顶部使用该菜单。这个下拉菜单帮助您找到方法，并允许您跳转到代码中的不同位置。要使用这个菜单，请点击编辑面板顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：您的类有一个内置的目录，可以快速跳转到某个章节。*

##### 为 Add Birthday 视图控制器设置委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表视图控制器它已经添加了一个 Birthday。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性，来实现这一点，将以下代码插入到 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为您无法在 Add Birthday 视图控制器创建之前设置它。您将很快学到在哪里设置委托。

现在，Add Birthday 视图控制器已经有了委托，在 saveTapped(_:) 方法中，您可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将一个 Birthday 传递给委托。将 saveTapped(_:) 更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建 Birthday 对象之后，代码 ➊ 使用 addBirthdayViewController(_:didAddBirthday:) 方法将其传递回委托。

很棒！您已经完成了对 Add Birthday 视图控制器的修改。它现在有了一个委托，可以监听保存 Birthday 的调用。运行应用程序看看会发生什么。

嗯……没有太大变化。当您添加 Birthday 时，仍然没有看到它出现在 Birthdays 表视图控制器中。怎么回事？

#### 通过设置委托连接这两个控制器

还有最后一件事。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存着当 Birthday 被保存时与之通信的委托。但我们从未特别设置委托属性为 Birthdays 表视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个已经被注释掉的方法叫做`prepare(for:sender:)`。通过删除包围它的/*和*/，取消注释该方法。

每当`Birthdays`表格视图控制器放弃屏幕并且应用程序通过故事板 segue 切换到另一个视图控制器时，该方法会自动调用。我们将使用这个方法将`Birthdays`表格视图控制器传递给`Add Birthday`视图控制器，并设置它为`Add Birthday`视图控制器的委托。请在`prepare(for:sender:)`方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码，就可以将`Add Birthday`视图控制器的委托设置为`Birthdays`表格视图控制器。首先，你需要能够从 segue 参数中获取`AddBirthdayViewController`对象。Xcode 已经留下了一个注释，提示如何实现这一点。`UIStoryboardSegue`有一个名为`destination`的属性，它表示正在此方法中准备的 segue 的目标视图控制器，但对于这个应用程序来说，目标并不是`AddBirthdayViewController`。

在第九章中，你将`Add Birthday`视图控制器嵌入到了一个导航控制器中，以便可以显示带有“取消”和“保存”按钮的导航栏。因此，你不期望在 segue 的另一端找到`Add Birthday`视图控制器。相反，目标是一个包含`Add Birthday`视图控制器的`UINavigationController`。在➊这行代码中，你获得了`navigationController`。`segue.destination`将返回一个`UIViewController`，但是因为我们的`navigationController`是`ViewController`的一个特定子类，我们需要使用`as`将其强制类型转换为`UINavigationController`。

接下来，你可以获取`Add Birthday`视图控制器，它是`navigationController`的`topViewController`➋。`topViewController`就是当前在`navigationController`中显示的视图控制器，但它的属性类型是`UIViewController`，所以必须将其强制类型转换为`AddBirthdayViewController`，以表明这个控制器是`UIViewController`的一个具体子类。最后，当你得到了`AddBirthdayViewController`时，你可以将其委托设置为`self`，即当前的`Birthdays`表格视图控制器➌。

现在运行应用程序并添加一些生日！你在`Birthdays`表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用并再次运行，之前的生日将消失。我们仍然需要将生日保存到设备中，这部分将在第十二章中完成。

### 你学到了什么

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在`Add Birthday`视图控制器中添加生日，并且如何通过委托将生日添加到`Birthdays`表格视图控制器中的生日数组，以便显示。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使退出应用程序并重新启动，生日也会显示出来。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

这一行创建了一个空的 Birthday 实例数组。它需要是一个变量，而不是常量，因为每当用户通过添加生日视图控制器添加生日时，你将想要将已保存的生日添加到这个数组中。你将在“使 Birthdays Table View Controller 遵循协议”中看到如何实现这一点，第 168 页。

**注意**

*请记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *下载。*

BirthdaysTableViewController 还需要一个 dateFormatter 属性来将出生日期显示为格式良好的字符串。在 birthdays 数组下面添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，通过 let 创建。即使你会更改 dateFormatter 的属性，如 dateStyle 和 timeStyle，但你永远不会更改 dateFormatter 本身。

你还需要设置 dateFormatter，以便它将出生日期显示为完全格式化的字符串，如“Tuesday, December 17, 2008”。正如你在第十章中看到的，进行此操作的好地方是 viewDidLoad()方法，该方法在加载 Birthdays 表视图控制器的视图时调用。这是进行任何必要设置的完美位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在➊，你设置了 dateFormatter 的 dateStyle，以便它显示每个 Birthday 的格式化日期字符串。你注意到我们只是写了.full 而不是 DateFormatter.Style.full 吗？Swift 知道 DateFormatter 的 dateStyle 应该是什么类型，所以它允许我们使用这个小的快捷方式。在➋，你将 dateFormatter 的 timeStyle 设置为.none，这样时间就不会显示。

#### 在表视图中显示生日

BirthdaysTableViewController 类有一个表视图，用于在单列中显示项目列表。表视图有一个或多个包含行的部分，每一行包含一个单元格。表视图中的一个部分是一个行的分组，可以显示有或没有头部。一个展示了多个部分的表视图的应用示例是设置应用，如图 11-5 所示。它显示了一个将行分成不同部分的列表。

表视图的每个部分和行都通过索引号来标识。这些数字从 0 开始，然后随着向下滚动表视图而增加。例如，在设置应用中，隐私行位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为 *表格视图数据源* 的部分，其中包含三个方法。表格视图控制器使用这些方法来确定在其表格视图中将显示什么内容。

numberOfSections(in:) 告诉表格视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表格视图每个部分将显示多少行

tableView(_:cellForRowAt:) 设置每个将在表格视图每行显示的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分将不同设备设置的行进行分组。*

每当表格视图重新加载时，表格视图控制器都会调用表格视图数据源方法。Xcode 在你创建 UITableViewController 的子类时会自动为你提供这些方法模板。你需要实现这三种方法才能让应用正常工作，尽管你在代码中永远不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，后者包含这些数据源方法，用于确定表格视图中将显示的内容。我们将在第 166 页的“委托”中讨论协议。目前，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，所以你不需要手动调用它们。

让我们从方法 numberOfSections(in:) 开始。Birthdays 表格视图控制器是一个只显示生日实例的列表，因此它不需要多个部分。为了设置表格视图中的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

该方法接受一个 UITableView 类型的参数 tableView，它是使用这个类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内置的表格视图，并且它会自动连接到这些方法。每个生日都会显示在它自己的行中。因此，在 tableView(_:numberOfRowsInSection:) 中，为了正确显示所有生日的行数，你需要返回你在 birthdays 数组中拥有的 Birthday 实例数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少个项目，非常适合这个场景！将该方法更改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，tableView(_:numberOfRowsInSection:) 还接受一个名为 section 的 Int。当表格视图加载时，该方法会为每个部分调用。在我们的例子中，我们只有一个部分，因此不需要检查当前显示的是哪个部分。我们知道它是第零部分，我们希望它的行数等于生日的数量，因此我们写下 return birthdays.count。

最后，您需要实现`tableView(_:cellForRowAt:)`，以便表格视图知道在每个单元格中放入什么内容。由于这个方法已被注释掉，您需要通过删除包围它的`/*`和`*/`来取消注释。（小心不要不小心取消注释它后面的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

您不会调用`tableView(_:cellForRowAt:)`方法。它会在表格视图加载到屏幕上时被自动调用。它会为屏幕上的每个单元格被调用，并接受两个参数：`tableView`和`indexPath`。您已经知道`tableView`参数的作用。`IndexPath`是一个 Swift 结构体，用于表示表格视图中某行的位置。`IndexPath`实例具有`section`属性和`row`属性。由于这个方法会被多次调用（每次为表格中的一行），我们需要`indexPath`来知道我们当前正在配置的是哪个部分和行。`indexPath.section`属性给出部分号，`indexPath.row`给出表格视图单元格的行号。`tableView(_:cellForRowAt:)`中的五行代码将完成以下操作：

![](img/Image00244.jpg)

• 创建一个`UITableViewCell`

• 找出`birthdays`数组中将在单元格内显示的生日

• 创建两个标签来显示生日人的名字和出生日期

• 返回准备好显示的单元格

让我们逐行分析这段代码。

首先，创建`UITableViewCell`。➊处的代码使用`dequeueReusableCell(withIdentifier:for:)`方法完成此操作。但是，在开始使用该方法之前，您需要告诉它您要从故事板中使用哪个单元格。稍早在故事板中，您为单元格指定了`birthdayCellIdentifier`标识符（参见图 11-4）。这个标识符将您的代码与单元格关联，并告诉方法它正在使用正确的单元格。当您调用此方法时，字符串必须与您在故事板中设置的字符串完全相同，否则会发生错误，并且应用在运行时会崩溃。

在方法`dequeueReusableCell(withIdentifier:for:)`中，您有没有注意到*Reusable Cell*这几个词？表格视图中的单元格只会被创建一次，之后可以重复使用。这有助于提高运行速度和流畅度，因为创建单元格是最耗时的操作。如果您的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么您只需要 10 个单元格来展示这些生日。当您向下滚动以查看更多生日时，屏幕上方滚动出去的单元格会被重用，它们会被填充上新的信息，并再次出现在屏幕的底部。UITableView 会自动执行这些操作。当表格视图加载时，`tableView(_:cellForRowAt:)`会为每一行可见的单元格被调用。当用户滚动查看更多单元格时，这个方法会在每一行即将出现在屏幕上时再次被调用。

接下来，我们需要找出哪个生日应该显示在单元格内。我们希望在每一行显示来自生日数组中的一个生日。第一个生日（即 birthdays[0]）应该显示在第 0 行。第二个生日（即 birthdays[1]）应该显示在第 1 行，以此类推，这意味着 indexPath 的行号与我们想要访问的生日数组中的位置是相同的。在 ➋ 处，代码通过使用 indexPath.row 来访问生日数组中的正确生日对象。得到正确的生日对象后，我们将其分配给一个名为 birthday 的常量，以便我们可以设置该单元格中的标签。

请注意，我们使用 let 来将生日分配给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的 birthday 常量。每个单元格都有自己的 birthday 常量，并且每个常量都被赋予自己的生日对象。由于我们不打算修改任何生日常量——我们只是读取它们的属性——因此不需要将它们设为变量。

现在你已经有了单元格和生日，是时候填充详细信息了。你需要为每个单元格添加两个标签，以显示生日人的姓名和出生日期。你将单元格设置为副标题样式，这样它就有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，因此你不需要自己创建标签。

这些标签是 UITableViewCell 的属性，分别称为 textLabel 和 detailTextLabel。代码在 ➌ 处将 textLabel 的文本设置为由生日的 firstName 和 lastName 拼接成的字符串，中间有一个空格。在 ➍ 处，使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 在 ➎ 处返回该单元格，这样它就可以在表格视图的对应 indexPath 中显示。

### 整合全部内容

现在，你可以使用添加生日视图控制器（Add Birthday view controller）向应用程序中添加生日，并且你有一个表格视图来列出每个生日，这些生日将显示在生日表视图控制器（Birthdays table view controller）中。但是，当你尝试运行应用并添加一个生日时，它没有出现。为了让你添加的每个生日都出现在表格视图中，你需要让添加生日视图控制器与生日表视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托（Delegation）可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 并不知道 A——它刚刚被创建出来，不知道它来自哪里，也不知道是如何到达那里的。那么 B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托（Delegation）是指某人将工作或任务交给另一个人执行。一个*委托人*就像一个老板，他告诉委派员工该做什么。当委派员工完成任务时，有时他们会将信息报告回委托人老板。

Swift 中的委托非常相似，不过我们没有老板和员工，而是有委托和委托对象。由于类 B 是由类 A 告知该做什么的对象，它就是委托对象。我们给类 B 一个特殊的属性，叫做委托（delegate），用来告诉它谁是它的委托人——这样它就知道该与谁沟通。委托可以是任何拥有在*协议*中定义的方法集的类。协议就像是两个类之间的约定，告诉它们委托可以要求委托对象做些什么。协议列出了委托可以在委托对象上使用的方法和属性名称。

类 A 创建类 B，将自己设置为类 B 的委托，并给类 B 一个在协议中定义的任务。一旦类 B 完成任务，它会将结果报告回类 A。让我们看看这个如何在我们的应用程序中运作。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议定义一个方法，addBirthdayViewController(_:didAddBirthday:)，这个方法将由添加生日视图控制器用于报告回传。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日通过委托从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为具有一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，添加生日视图控制器调用此方法 ➍ 并将新生日传递给其委托人，即生日表视图控制器。生日表视图控制器接收该生日，将其添加到生日数组中，然后重新加载表视图 ➎，以便新生日能够显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义方法 addBirthdayViewController(_:didAddBirthday:)，当应用程序添加新生日时，添加生日视图控制器可以调用该方法。生日表视图控制器将实现该协议方法，以便每当添加生日视图控制器添加新生日时，添加生日视图控制器可以对其委托说：“嘿！有人刚刚添加了这个生日。” 生日表视图控制器会收到信息并说：“哦！我将把它添加到我的列表中，并刷新我的显示，这样新添加的生日就会出现。”

所以现在我们来看看如何在代码中实现这个！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过键入关键字 protocol 来定义协议，后跟协议名 AddBirthdayViewControllerDelegate。这个名字很长，但 Swift 程序员通常会根据调用类的名称命名协议，并在后面加上 Delegate 这个词。这样，你通过查看协议的名称就能知道是哪个类在使用该协议。既然你现在是一个 Swift 程序员，你也应该遵循这种命名惯例。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传回委托类 ➋。请注意，你在这个函数中包含了 AddBirthdayViewController 作为参数。再说一次，Swift 程序员在实现协议方法时通常会这么做，因此你也应该遵循这种做法。了解是谁发送了消息并让委托访问该对象及其类是很有用的。

当 AddBirthdayViewController 调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递。你很快就会看到这个是如何完成的。另一个需要注意的是外部参数名 didAddBirthday。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用于描述调用类刚刚做完的或将要做的事情。

现在你已经定义了协议，需要告诉生日表视图控制器采用这个协议并使用协议的方法。

##### 使生日表视图控制器符合协议

为了采用该协议，生日表视图控制器需要让自己成为 AddBirthdayViewControllerDelegate。为了允许这一点，你需要在类定义中添加 AddBirthdayViewControllerDelegate，紧接着 UITableViewController 超类。在类的顶部，在 UITableViewController 后添加逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色错误就会出现。这是因为 BirthdayTableViewController 声明自己是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现这个协议，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会解决这个问题。

在这里需要特别注意的是，BirthdayTableViewController 正在继承 UITableViewController 超类。一个类只能有一个超类，而且该超类名称必须写在所有协议之前。但虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议都会列在超类后面并用逗号分隔。

现在，为了符合 `AddBirthdayViewControllerDelegate` 协议并修复错误，我们需要在 `Birthdays TableViewController` 中添加 `addBirthdayViewController(_:didAddBirthday:)` 方法。一个合适的位置是类的末尾，即导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当您开始输入函数名时，Xcode 的自动补全功能会建议整个方法声明。这是因为它知道这个类采纳了 `AddBirthdayViewControllerDelegate` 协议，并且期望您添加这个方法。请注意，与子类化方法不同，您在 `addBirthdayViewController(_:didAddBirthday:)` 方法前不需要使用 `override` 关键字，因为没有原始方法需要被重写。

在这个方法中，您需要做两件事。首先，您需要将通过“添加生日”视图控制器传递进来的生日添加到生日数组中。您可以通过使用数组的 `append(_:)` 方法来实现这一点 ➋。接下来，您需要刷新表格视图，以便显示这个新添加的生日，方法是调用 `reloadData()` 来刷新 `tableView` 属性 ➌。当调用 `reloadData()` 时，表格视图的数据源方法会重新调用，新添加的生日将显示在生日列表的底部。

您可能已经注意到，我们在方法上方添加了注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但这是一个好的编程风格，能够将类的不同部分标记出来，有助于保持代码的整洁和可读性。注释的第一部分，`MARK: -`，是 Xcode 识别的一个特殊关键字，它将 `AddBirthdayViewControllerDelegate` 部分添加到一个下拉目录菜单中，您可以在类的顶部使用这个菜单。这个下拉菜单帮助您查找方法，并且可以让您跳转到代码中的不同位置。要使用这个菜单，请点击编辑器窗格顶部的 `Birthdays TableViewController`，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：您的类具有内置的目录，可以快速跳转到某个部分。*

##### 为“添加生日”视图控制器设置代理

`BirthdaysTableViewController` 已经采纳了 `AddBirthdayViewControllerDelegate` 协议。现在是时候让“添加生日”视图控制器使用 `AddBirthdayViewControllerDelegate` 协议，通知 `Birthdays` 表格视图控制器它已经添加了一个生日。为此，“添加生日”视图控制器首先需要定义一个代理。我们通过在 `AddBirthdayViewController` 类中添加一个类型为 `AddBirthdayViewControllerDelegate` 的可选代理属性，来安排这一点，将以下行代码插入到 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为直到“添加生日”视图控制器创建后，您才能设置它。稍后您将学到如何设置代理。

现在 Add Birthday 视图控制器有了一个代理，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将生日传递给代理。将 saveTapped(_:) 更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 方法将其传回给代理。

太好了！你已经完成了对 Add Birthday 视图控制器的修改。现在它有一个代理，能够监听生日保存的调用。运行应用程序看看会发生什么。

嗯……变化不大。当你添加一个生日时，你仍然没有看到它出现在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置代理连接这两个控制器

还有一件事你必须做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate ，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存了它在保存生日时与之通信的代理。但我们从未明确设置代理属性为 Birthdays 表格视图控制器。因此，现在是时候连接这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个被注释掉的方法叫 prepare(for:sender:)。通过删除包围它的 /* 和 */ 来取消注释该方法。

当 Birthdays 表格视图控制器放弃屏幕并通过 storyboard segue 转到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将 Birthdays 表格视图控制器传递到 Add Birthday 视图控制器，并设置自己作为 Add Birthday 视图控制器的代理。在 prepare(for:sender:) 方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需三行代码，就能将 Add Birthday 视图控制器的代理设置为 Birthdays 表格视图控制器。首先，你需要能够通过 segue 参数访问到 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，它位于正在准备的 segue 的另一端，但对于这个应用程序，destination 并不是 AddBirthdayViewController。

在第九章，你将 Add Birthday 视图控制器嵌入到导航控制器中，以便你可以拥有一个带有取消和保存按钮的导航栏。所以你不期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊ 处的代码让你获得了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 ViewController 的特定类型，我们需要通过 `as` 将其类型转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其强制转换为 AddBirthdayViewController，表示这个控制器是 UIViewController 的一个具体子类。最后，当你获得 AddBirthdayViewController 时，你可以将代理设置为 self，它目前是生日表视图控制器 ➌。

现在运行应用并添加一些生日！你在生日表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用然后再重新运行，之前添加的生日会消失。我们还需要将生日保存到设备上，这将在第十二章中讲解。

### 你学到了什么

在本章中，你学习了如何创建一个表视图控制器来显示生日列表。你还学会了如何在 Add Birthday 视图控制器中添加生日，并通过代理将生日添加到生日表视图控制器中的 birthdays 数组中，以便显示。

在第十二章中，你将学习如何将生日保存到设备上，这样即使退出应用并重新运行，生日也会显示出来。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

**注意**

*记住，项目文件的最终版本可以从* [`www.nostarch.com/iphoneappsforkids/`](https://www.nostarch.com/iphoneappsforkids/) *获取。*

生日表视图控制器还需要一个 dateFormatter 属性，用于将生日显示为格式化的字符串。请在 birthdays 数组下方添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个使用 let 创建的常量。即使你会更改 dateFormatter 的属性，例如 dateStyle 和 timeStyle，但你永远不会更改 dateFormatter 本身。

你还需要设置 dateFormatter，这样它就会将生日显示为格式化的字符串，比如 "2008 年 12 月 17 日，星期二"。正如你在第十章中看到的，做这件事的好地方是在 viewDidLoad() 方法中，该方法在生日表视图控制器加载视图时被调用。这是进行任何需要设置的地方。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ ，你设置了 dateFormatter 的 dateStyle，这样它就会为每个生日显示格式化的日期字符串。你注意到我们只是写了 .full 而不是 DateFormatter.Style.full 吗？Swift 知道期望为 DateFormatter 的 dateStyle 设置哪种类型，因此它允许我们采用这个小的快捷方式。在 ➋ ，你将 dateFormatter 的 timeStyle 设置为 .none，这样时间就不会显示。

#### 在表视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于显示单列的项目列表。该表格视图包含一个或多个节，每个节内包含若干行，每行包含一个单元格。表格视图中的一节是若干行的分组，可以选择是否显示标题。一个显示了多个节的表格视图应用示例是设置应用，如图 11-5 所示。它显示了一列已被分成不同节的行。

每个表格视图的每一节和每一行都由一个索引号标识。这些数字从 0 开始，然后随着表格视图的向下滚动，每一行的数字递增。例如，设置应用中的隐私选项位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为 *表格视图数据源* 的部分，其中包含三个方法。表格视图控制器使用这些方法来确定将在其表格视图中显示的内容。

numberOfSections(in:) 告诉表格视图应该有多少节。

tableView(_:numberOfRowsInSection:) 告诉表格视图每节中将显示多少行。

tableView(_:cellForRowAt:) 设置每行在表格视图中将要显示的单元格。

![](img/Image00243.jpg)

*图 11-5：设置应用使用节将不同的设备设置行分组。*

每当表格视图重新加载时，表格视图数据源方法都会被表格视图控制器调用。当你创建一个 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。尽管你在代码中不会直接调用它们，但你需要实现所有三个方法，才能使应用程序正常工作。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用于确定表格视图中显示的内容。我们将在“委托”一节的第 166 页中讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，所以你不需要手动调用它们。

让我们从方法 numberOfSections(in:) 开始。Birthdays 表格视图控制器是一个只显示生日实例的列表，因此它不需要多个节。为了设置表格视图中的节数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

该方法接受一个名为 tableView 的 UITableView 类型参数，它是使用该类作为数据源的表视图。我们不需要担心如何建立这个连接，因为 UITableViewController 自带一个内建的表视图，并且自动与这些方法连接。每个生日将在它自己的行中显示。因此，在 tableView(_:numberOfRowsInSection:) 方法中，为了确保有正确数量的行来显示所有的生日，你需要返回 birthdays 数组中 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，表示数组中有多少个元素，非常适合这种情况！将该方法修改为如下：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，tableView(_:numberOfRowsInSection:) 方法还接受一个名为 section 的 Int 类型参数。当表视图加载时，该方法会为表视图中的每个部分被调用。在我们的例子中，只有一个部分，所以我们不需要去检查当前正在显示的是表视图的哪个部分。我们知道它是 section 0，我们希望它的行数与 birthdays 数组中的生日数量相等，因此我们返回 birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:) 方法，这样表视图才能知道每个单元格中该放置什么内容。由于该方法被注释掉了，你需要通过删除 /* 和 */ 来取消注释。（小心不要误操作，取消注释后面的其他方法！）完成这一步后，将其修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用 tableView(_:cellForRowAt:) 方法。它会在表视图加载到屏幕时被调用，并且会为屏幕上的每个单元格调用一次。它有两个参数，tableView 和 indexPath。你已经知道 tableView 参数的作用。IndexPath 是一个 Swift 结构体，用于表示表视图中某一行的位置。IndexPath 实例有一个 section 属性和一个 row 属性。由于此方法会被调用多次（每一行都会调用一次），我们需要通过 indexPath 来知道当前正在配置的是哪个部分和哪一行。indexPath.section 属性给出部分的编号，而 indexPath.row 给出表视图单元格所在的行号。tableView(_:cellForRowAt:) 中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定在 birthdays 数组中哪个生日将显示在单元格中

• 创建两个标签来显示生日人的姓名和出生日期

• 返回准备好显示的表视图单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。➊ 处的代码通过使用 dequeueReusableCell(withIdentifier:for:) 方法来实现。在开始使用此方法之前，你需要告诉方法你要从故事板中使用哪个单元格。之前在故事板中，你给单元格设置了标识符 birthdayCellIdentifier（见 图 11-4）。这个标识符将你的代码与单元格关联，并告诉你的方法它正在使用正确的单元格。调用此方法时传入的字符串必须与在故事板中设置的字符串完全相同，否则会出现错误，应用在运行时崩溃。

在方法 dequeueReusableCell(withIdentifier:for:) 中，你注意到 *Reusable Cell* 这两个词了吗？表格视图中的单元格只创建一次，然后可以反复重用。这有助于提高性能，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日记录，但屏幕一次只能显示 10 个，那么你只需要 10 个单元格来展示这些生日。当你向下滚动以查看更多生日时，滚出屏幕顶部的单元格会被重用，它们会被填充上新信息，并再次出现在屏幕底部。UITableView 会自动完成这些工作。当表格视图加载时，tableView(_:cellForRowAt:) 会被调用，针对每一行可见的单元格。当用户滚动以查看更多单元格时，每一行都会在即将显示时重新调用该方法。

接下来，我们需要找出哪个生日应该显示在单元格中。我们希望在每一行显示生日数组中的一个生日。第一个生日，即 birthdays[0]，应该显示在第 0 行。第二个生日，即 birthdays[1]，应该显示在第 1 行，依此类推。这意味着 indexPath 的行数与我们想要访问的生日数组中的位置相同。➋ 处的代码通过使用 indexPath.row 从生日数组中访问正确的 Birthday 对象。一旦得到正确的 Birthday 对象，我们将其分配给一个名为 birthday 的常量，以便设置该单元格中的标签。

请注意，我们使用 let 来将生日分配给一个常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并分配给它自己的 Birthday 对象。由于我们不会改变任何生日常量——我们只是读取它们的属性——所以我们不需要将它们设为变量。

现在你已经有了单元格和生日对象，接下来是填充详细信息。你需要为每个单元格创建两个标签，用于显示生日人的名字和出生日期。你将单元格设置为 Subtitle 样式，这样它就会有一个 Title 标签和一个 Subtitle 标签。每个单元格已经包含这些标签，因此你无需自己创建标签。

标签作为 UITableViewCell 的属性存在，分别被称为 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间有一个空格。➍ 处，使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 会在 ➎ 处返回该单元格，以便它可以在表视图的那个 indexPath 位置显示。

### 整合所有内容

现在你可以通过添加生日视图控制器来向应用中添加生日实例，并且你有一个表视图来列出每个生日，但当你尝试运行应用并添加生日时，它并没有出现。为了让你添加的每个生日都能出现在表视图中，你需要让添加生日视图控制器与生日表视图控制器进行通信。你可以通过使用 *委托* 来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 展示在自己的上方。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它刚刚被创建出来，不知道它来自哪里，也不知道它是如何到达那里的。那么 B 怎么与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指有人将工作或任务交给别人处理。*委托人*就像是一个老板，告诉被委托的员工该做什么。当被委托的员工完成任务时，有时会将信息反馈给委托的老板。

在 Swift 中，委托非常类似，但不同的是，我们不再有老板和员工的关系，而是有委托和委托对象。因为类 B 是被类 A 告诉该做什么的，所以它是委托对象。我们给类 B 一个特殊的属性，叫做 delegate，用来告诉它它的委托是谁——这样，类 B 就知道该和谁通信。委托可以是任何一个拥有一组在 *协议* 中定义的方法的类。协议就像是两个类之间的约定，告诉它们委托可以要求委托对象做什么。协议列出了委托可以与委托对象一起使用的方法和属性名称。

类 A 创建了类 B，使自己成为类 B 的委托，并给类 B 交代了协议中规定的任务。一旦类 B 完成任务，它会向类 A 汇报。让我们在我们的应用中看看是如何实现的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用于报告。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为有一个方法`addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存 ➌ 时，添加生日视图控制器会调用这个方法 ➍ 并将新添加的生日传递给它的委托——生日表视图控制器。生日表视图控制器接收这个生日，将其添加到自己的生日数组中，然后重新加载表视图 ➎，以便新添加的生日会出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，其中包含方法`addBirthdayViewController(_:didAddBirthday:)`，该方法会在每次添加生日时由添加生日视图控制器调用。生日表视图控制器会实现这个协议方法，这样每次使用添加生日视图控制器添加生日时，添加生日视图控制器可以告诉它的委托，“嘿！有人刚刚添加了这个生日。”然后，生日表视图控制器会收到这个消息并说，“哦！我会把这个添加到我的列表里并刷新显示，这样新添加的生日就能显示出来。”

所以现在我们就用代码来实现吧！

##### 创建一个协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类**上方**添加以下代码，定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过在➊处输入关键字`protocol`后跟协议名 AddBirthdayViewControllerDelegate 来定义协议。这个名字很长，但 Swift 程序员通常会根据调用类命名协议，并在后面加上“Delegate”一词。这样，你就可以通过协议的名称知道哪个类正在使用这个协议。既然你现在是 Swift 程序员了，你应该遵循同样的命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)`是唯一的函数，用于将生日对象传回给委托类 ➋。注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。再说一次，Swift 程序员通常根据约定实现协议方法时会这样做，所以你也应该遵循这种做法。知道是谁发送了消息并让委托类能够访问该对象及其类是很有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 `addBirthdayViewController` 参数传递。你很快就会看到这是如何实现的。另一个需要注意的事项是外部参数名 `didAddBirthday`。许多委托协议方法中包含 *did* 和 *will* 这两个词，因为它们用来描述调用类已经做过或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays TableViewController 采用这个协议并使用协议的方法。

##### 使 Birthdays Table View Controller 符合协议

为了采用协议，Birthdays TableViewController 需要将自己声明为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，在 UITableViewController 超类后面添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后添加逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色的错误就会出现。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！别担心——我们很快会修复这个问题。

在这里需要注意的是，BirthdaysTableViewController 是从 UITableViewController 超类继承的。一个类只能有一个超类，并且该超类的名称必须写在所有协议之前。但虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议将被列在超类之后，并且由逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 `addBirthdayViewController(_:didAddBirthday:)` 方法添加到 Birthdays TableViewController。一个合适的添加位置是在类的末尾，即导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它期望你添加这个方法。请注意，与子类化方法不同，你在 `addBirthdayViewController(_:didAddBirthday:)` 前不需要使用 `override` 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的生日添加到 birthdays 数组中。你可以通过使用数组的 `append(_:)` 方法来完成这一步 ➋。接下来，你需要刷新表格视图，以便它显示这个新添加的生日，通过在 `tableView` 属性上调用 `reloadData()` 方法 ➌。当调用 `reloadData()` 时，表格视图的数据源方法将会重新被调用，新增的生日将显示在生日列表的底部。

您可能注意到我们在方法上方添加了一个注释，用来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但将类的不同部分标记出来是良好的编码风格，它有助于保持代码清晰和易于阅读。注释的第一部分，MARK: -，是 Xcode 识别的一个特殊关键字，它会将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中，您可以通过这个菜单跳转到代码中的不同位置。要使用这个菜单，只需点击编辑器窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：您的类具有内置的目录，可以快速跳转到某个部分。*

##### 给 Add Birthday 视图控制器设置代理

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中插入以下代码行，在 outlets 下方添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性来安排此事：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是一个可选类型，因为在 Add Birthday 视图控制器创建之前，您无法设置它。稍后您将学习在哪里设置代理。

现在，Add Birthday 视图控制器已经有了一个代理，在 saveTapped(_:) 方法中，您可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将一个 Birthday 传递给代理。将 saveTapped(_:) 方法修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建 birthday 对象之后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 方法将其传回代理。

太棒了！您已经完成了对 Add Birthday 视图控制器的更改。它现在有了一个代理，能够监听 Birthday 被保存的事件。运行应用程序，看看会发生什么。

嗯……变化不大。当您添加一个 Birthday 时，您仍然看不到它显示在 Birthdays 表视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事需要做。Birthdays 表视图控制器是 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存它与之通信的代理，当一个 Birthday 被保存时。但是我们从未明确地将代理属性设置为 Birthdays 表视图控制器。所以现在是时候在我们两个视图控制器之间建立通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，叫做 prepare(for:sender:)。请通过删除/*和*/来取消注释这个方法。

这个方法会在每次 Birthdays 表格视图控制器放弃其屏幕，并且应用程序通过 storyboard segue 切换到另一个视图控制器时自动调用。我们将使用这个方法将 Birthdays 表格视图控制器传递给 Add Birthday 视图控制器，并将其设置为 Add Birthday 视图控制器的委托。请在 prepare(for:sender:)方法中写下以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码，就可以将添加生日视图控制器的委托设置为 Birthdays 表格视图控制器。首先，你需要能够通过 segue 参数访问 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个叫做 destination 的属性，表示正在准备中的 segue 的目标，但对于这个应用程序来说，目标并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到导航控制器中，这样你就可以拥有带有取消和保存按钮的导航栏。因此，你不应该期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。在➊这一行，你获取了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定子类，我们需要使用 as 将其转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的特定子类。最后，当你获得 AddBirthdayViewController 时，可以将委托设置为 self，即当前的 Birthdays 表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在 Birthdays 表格视图控制器中看到了什么？生日！生日！生日！不过我们还没完全结束。如果你退出应用程序然后重新启动，之前的生日将会消失。我们仍然需要将生日保存到设备中，接下来我们将在第十二章中完成这个工作。

### 你学到了什么

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学习了如何在添加生日视图控制器中添加一个生日，然后如何使用委托将生日添加到 Birthdays 表格视图控制器中的生日数组，以便可以显示出来。

在第十二章，你将学习如何将生日保存到设备中，这样即使你退出应用并重新启动，它们仍然会显示出来。为了保存生日，你将使用 Core Data，这是我们在项目开始时设置的。

BirthdaysTableViewController 还需要一个 dateFormatter 属性来将出生日期显示为格式化好的字符串。在 birthdays 数组下方添加一个 dateFormatter：

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

请注意，dateFormatter 是一个常量，它是通过 let 创建的。尽管你会改变 dateFormatter 的属性，比如 dateStyle 和 timeStyle，但你永远不会改变 dateFormatter 本身。

你还需要设置 dateFormatter，以便它能够将出生日期显示为完全格式化的字符串，例如 "Tuesday, December 17, 2008"。正如你在第十章中看到的，最好的做法是在 viewDidLoad() 方法中进行设置，该方法在 Birthdays 表格视图控制器加载视图时被调用。这是执行该类所需任何初始化的完美时机。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在 ➊ 处，你设置了 dateFormatter 的 dateStyle，使其显示格式化的日期字符串，例如每个 Birthday 的日期。你是否注意到我们直接写了 .full，而不是 DateFormatter.Style.full？Swift 知道 DateFormatter 的 dateStyle 应该是什么类型，所以它允许我们使用这个小技巧。 在 ➋ 处，你将 dateFormatter 的 timeStyle 设置为 .none，这样时间就不会显示出来。

#### 在表格视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于显示单列项的列表。表格视图有一个或多个包含行的 section，每一行包含一个 cell。表格视图中的一个 section 是若干行的分组，可以显示或不显示标题。一个显示有多个 section 的表格视图应用实例是设置应用，如图 11-5 所示。它显示了一个将行分成不同 section 的列表。

表格视图的每个 section 和 row 都通过索引号进行标识。这些数字从 0 开始，然后按顺序递增。例如，设置应用中的隐私选项在 section 0，第 1 行。新闻设置在 section 1，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为 *Table view data source* 的 section，其中包含三个方法。表格视图控制器使用这些方法来确定将显示在其表格视图中的内容。

numberOfSections(in:) 告诉表格视图它应该有多少个 section。

tableView(_:numberOfRowsInSection:) 告诉表格视图每个 section 中将显示多少行。

tableView(_:cellForRowAt:) 设置每一行在表格视图中显示的单元格。

![](img/Image00243.jpg)

*图 11-5：设置应用使用 section 来分组不同设备设置的行。*

每当表格视图重新加载时，表格视图控制器会调用表格视图数据源方法。Xcode 会在你创建 UITableViewController 子类时自动为你提供这些方法模板。你需要实现所有三个方法才能使应用正常工作，尽管你永远不会在代码中直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用于确定表格视图中显示的内容。我们将在第 166 页的 “委托” 中讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，所以你无需手动调用它们。

让我们从方法 `numberOfSections(in:)` 开始。Birthday 表格视图控制器是一个仅显示生日实例的列表，因此它不需要多个部分。为了设置表格视图中的部分数，我们只需返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

该方法接收一个名为 tableView 的 UITableView 参数，这个表格视图使用此类作为其数据源。我们无需担心如何建立此连接，因为 UITableViewController 自带一个内置的表格视图，并且这些方法会自动连接到它。每个生日将在自己的行中显示。因此，在 `tableView(_:numberOfRowsInSection:)` 中，为了确保所有生日的行数正确，你需要返回 `birthdays` 数组中生日实例的数量。你还记得数组的 `count` 属性吗？它是一个整数，告诉你数组中有多少项，正好适用于这个场景！将此方法更改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 `tableView` 参数外，`tableView(_:numberOfRowsInSection:)` 还接受一个名为 `section` 的 Int 参数。当表格视图加载自身时，该方法会为表格视图中的每个部分调用。在我们的例子中，我们只有一个部分，因此无需检查当前显示的是哪个部分。我们知道是第零部分，并且希望它有与生日数量相同的行数，因此我们写下 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)` 方法，这样表格视图才能知道在每个单元格中放置什么内容。由于该方法已被注释掉，你需要通过删除 `/*` 和 `*/` 来取消注释它。（小心不要不小心取消注释后面的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要直接调用方法 tableView(_:cellForRowAt:)。它会在表格视图加载到屏幕时被调用。它会为屏幕上的每个单元格被调用，并接受两个参数：tableView 和 indexPath。你已经知道 tableView 参数的作用了。IndexPath 是一个 Swift 结构体，用于表示表格视图中某行的位置。一个 IndexPath 实例有两个属性：section 和 row。由于这个方法会被调用很多次（每个表格中的行都会调用一次），我们需要 indexPath 来确定当前配置的是哪个 section 和 row。indexPath.section 属性表示节号，而 indexPath.row 表示表格视图单元格的行号。tableView(_:cellForRowAt:) 中的五行代码会做以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定在 birthdays 数组中哪个生日将显示在单元格中

• 创建两个标签来显示生日人的姓名和出生日期

• 返回一个准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。➊ 处的代码通过方法 dequeueReusableCell(withIdentifier:for:) 来实现这一点。然而，在你开始在单元格上使用这个方法之前，你需要告诉该方法你想从故事板中使用哪个单元格。之前，当你在故事板中时，你为单元格设置了标识符 birthdayCellIdentifier（参见 图 11-4）。这个标识符将你的代码与单元格关联，并告诉你的方法它正在使用正确的单元格。当你调用这个方法时，传入的字符串必须与在故事板中设置的字符串完全相同，否则会导致错误，应用程序在运行时会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:) 中，你注意到“*可重用单元格*”这几个字了吗？表格视图中的单元格是创建一次然后可以反复使用的。这有助于提升应用的运行速度和流畅度，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以查看更多生日时，滚出屏幕顶部的单元格将被重用。它们会填充新的信息，并在屏幕底部重新出现。UITableView 会自动完成这项工作。当表格视图加载时，tableView(_:cellForRowAt:) 会为每一行被调用。当用户滚动查看更多单元格时，这个方法会在每行即将显示到屏幕上时再次被调用。

接下来，我们需要找出应该显示在单元格中的哪个生日。我们希望在每一行显示来自生日数组中的一个生日。第一个生日，在`birthdays[0]`，应该显示在第 0 行。第二个生日，在`birthdays[1]`，应该显示在第 1 行，依此类推，这意味着`indexPath`的`row`与我们希望访问的生日数组中的位置相同。➋处的代码通过使用`indexPath.row`从生日数组中访问正确的 Birthday 对象。一旦我们拿到正确的 Birthday 对象，就将其赋值给名为`birthday`的常量，这样我们就可以设置该单元格中的标签了。

请注意，我们使用`let`将生日赋值给常量，而不是变量。我们可以使用`let`，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都会获得自己的生日常量，并且赋值给自己的 Birthday 对象。由于我们不会改变任何生日常量——我们只是读取它们的属性——所以我们不需要将它们设置为变量。

现在你已经有了单元格和生日，是时候填充详细信息了。你需要为每个单元格创建两个标签，用来显示生日人的姓名和出生日期。你将单元格设置为副标题样式，这样它就有了一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，所以现在你不需要自己创建任何标签。

标签是 UITableViewCell 的属性，分别称为`textLabel`和`detailTextLabel`。➌处的代码将`textLabel`的文本设置为由生日人的`firstName`和`lastName`组成的字符串，二者之间有一个空格。在➍处，你使用`dateFormatter`的`string(from:)`方法，将出生日期显示在`detailTextLabel`中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:)会返回该单元格（➎），以便它可以在表格视图的该`indexPath`处显示。

### 将一切整合在一起

现在你可以使用添加生日视图控制器将生日实例添加到应用中，并且你有一个表格视图来列出每个生日，显示在生日表格视图控制器中。但当你尝试运行应用并添加生日时，它并没有显示。为了让你添加的每个生日都出现在表格视图中，你需要让添加生日视图控制器与生日表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 呈现到自己的顶部。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 不知道 A——它只是突然出现的，根本不知道自己从哪里来，怎么到这里的。那么 B 如何与 A 进行交流呢？通过委托！

![](img/Image00245.jpg)

委托（Delegation）是指某人将一项工作或任务交给别人去做。一个*代理*就像一个老板，他告诉一个委托的员工应该做什么。当委托的员工完成了任务，有时他们会将信息报告给代理老板。

在 Swift 中，委托机制非常类似，但我们不再有老板和员工的关系，而是有代理和委托对象。由于是类 A 告知类 B 该做什么，所以类 B 是委托对象。我们给类 B 一个特别的属性，称为代理（delegate），用来告知它谁是它的代理——这样它就知道与谁进行沟通。代理可以是任何具有已定义方法集的类，这些方法集存在于一个*协议*中。协议就像是两个类之间的约定，告诉它们代理可以要求委托对象执行什么操作。协议包含了代理可以在委托对象上使用的方法和属性名称列表。

类 A 创建类 B，使自己成为类 B 的代理，并给类 B 分配一个任务，这个任务在协议中有定义。一旦类 B 完成了任务，它会向类 A 报告。让我们看看这在我们的应用中是如何工作的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用来报告回去。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器创建了添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：通过委托，新的生日被从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为包含一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，添加生日视图控制器调用此方法 ➍ 并将新的生日传递给它的代理——生日表视图控制器。生日表视图控制器接收这个生日，将其添加到它的生日数组中，然后重新加载表视图 ➎，以便新生日能够显示在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并包含 addBirthdayViewController(_:didAddBirthday:)方法，以便每当添加一个生日到应用时，添加生日视图控制器都可以调用此方法。生日表视图控制器将实现该协议方法，这样每当通过添加生日视图控制器添加一个生日时，添加生日视图控制器只需要对其代理说：“嘿！有人刚刚添加了这个生日。”生日表视图控制器会接收到消息，并说：“哦！我会把这个添加到我的列表中，并刷新我的显示，以便新生日能够显示出来。”

那么现在让我们来编写代码吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的*上方*，添加以下代码定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处通过输入关键字 protocol 然后跟上 AddBirthdayViewControllerDelegate 的名字来定义协议。这个名字比较长，但 Swift 程序员通常会根据调用类的名称来命名协议，并在后面加上 Delegate 这个词。这样，你就能通过查看协议的名称来判断是哪个类在使用该协议。既然你现在是一个 Swift 程序员，你应该遵循相同的命名规范。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传回给委托类 ➋ 。注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员在实现协议方法时，通常会按照这个约定来做，所以你也应该坚持这样做。知道是谁发回了消息并让委托有权限访问该对象及其类是很有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递进去。你很快就能看到这怎么做。另一个需要注意的点是外部参数名 didAddBirthday。许多委托协议方法都包含 *did* 和 *will* 这两个词，因为它们用于描述调用类刚刚做过的事情或将要做的事情。

现在你已经定义了协议，接下来需要告诉 Birthdays 表格视图控制器来采用这个协议并使用协议中的方法。

##### 让 Birthdays 表格视图控制器遵守协议

为了采用这个协议，Birthdays 表格视图控制器需要将自己设为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，在 UITableViewController 超类之后添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后面加上一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

当你这么做时，会出现一个红色的错误。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心，我们很快就会解决这个问题。

在这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，并且超类的名字必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议会列在超类之后，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。最好的添加位置是在类的末尾，紧跟在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成功能建议了整个方法声明。这是因为它知道这个类采纳了 AddBirthdayViewControllerDelegate 协议，并且它预计你会添加这个方法。注意，与子类化方法不同，在 addBirthdayViewController(_:didAddBirthday:) 前你不需要使用 override 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传入的 Birthday 添加到 birthdays 数组中。你可以使用数组的 append(_:) 方法来实现 ➋。接下来，你需要刷新表格视图，以便显示这个新添加的生日，通过在 tableView 属性上调用 reloadData() 方法 ➌。当 reloadData() 被调用时，表格视图的数据源方法将会再次调用，新的生日会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释，用来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但为了代码风格的优雅，标记类的不同部分是一个好习惯，它有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是一个特殊的关键字，Xcode 会识别它用于代码注释，并将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单帮助你快速找到方法，并可以跳转到代码中的不同位置。要使用这个菜单，点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内建的目录，可以快速跳转到某一部分。*

##### 给 Add Birthday 视图控制器设置代理

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告知 Birthdays 表格视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性来安排这件事，方法是将以下一行插入到 outlets 之后：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是一个可选类型，因为在创建 Add Birthday 视图控制器后才能设置它。你将很快学到在哪里设置代理。

现在，添加生日视图控制器有了一个代理，在`saveTapped(_:)`方法中，你可以通过`addBirthdayViewController(_:didAddBirthday:)`方法将一个生日对象传递给代理。将`saveTapped(_:)`方法改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊处的代码通过`addBirthdayViewController(_:didAddBirthday:)`方法将其传递回代理。

太好了！你已经完成了对添加生日视图控制器的更改。现在它有了一个代理，会监听生日被保存的事件。运行应用程序查看会发生什么。

嗯……没有太大变化。当你添加生日时，仍然看不到它出现在生日表视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事需要做。生日表视图控制器是一个`AddBirthdayViewControllerDelegate`，而添加生日视图控制器有一个`AddBirthdayViewControllerDelegate`属性，用于保存与之通信的代理，当生日被保存时。但我们从未明确地将代理属性设置为生日表视图控制器。所以，现在是时候连接我们两个视图控制器之间的通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个被注释掉的方法叫做`prepare(for:sender:)`。请通过删除前后的`/*`和`*/`来取消注释该方法。

当生日表视图控制器退出当前屏幕并通过故事板跳转到另一个视图控制器时，这个方法会被自动调用。我们将使用此方法将生日表视图控制器传递到添加生日视图控制器，以便将其设置为添加生日视图控制器的代理。请在`prepare(for:sender:)`方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的代理为生日表视图控制器需要三行代码。首先，你需要能够通过 segue 参数获取到`AddBirthdayViewController`对象。Xcode 在注释中提示了你如何做到这一点。`UIStoryboardSegue`有一个名为`destination`的属性，指向正在准备中的 segue 的另一端，但对于这个应用来说，目标并不是`AddBirthdayViewController`。

在第九章中，你将添加生日视图控制器嵌入到了一个导航控制器中，以便能够拥有带有取消和保存按钮的导航栏。所以你不应该在 segue 的另一端找到添加生日视图控制器。相反，目标应该是一个包含添加生日视图控制器的`UINavigationController`。➊处的代码会得到`navigationController`。代码`segue.destination`将返回一个`UIViewController`，但是由于我们的`navigationController`是特定类型的视图控制器，我们需要使用`as`将其强制转换为`UINavigationController`。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其类型转换为 AddBirthdayViewController，以表示该控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 后，你可以将代理设置为 self，即当前的生日表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序然后重新运行它，之前的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中进行。

### 你学到了什么

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表格视图控制器中的生日数组中，以便它可以被显示。

在第十二章中，你将学习如何将生日保存到设备中，以便即使退出应用程序再重新运行时，生日仍然能显示出来。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

```
    var birthdays = [Birthday]()

    let
 dateFormatter = DateFormatter
 ()

    override func viewDidLoad() {

```

注意，日期格式化器是一个通过 let 创建的常量。尽管你会更改日期格式化器的属性，比如 dateStyle 和 timeStyle，但你永远不会更改日期格式化器本身。

你还需要设置日期格式化器，以便它将出生日期显示为完整格式的字符串，如“星期二，2008 年 12 月 17 日”。正如你在第十章中看到的，执行此操作的一个好地方是 viewDidLoad()方法，当生日表格视图控制器加载其视图时，这个方法会被调用。这是进行任何必要设置的理想位置。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在➊处，你设置了日期格式化器的 dateStyle，以便它会为每个生日显示一个格式化的日期字符串。你注意到我们是写的.full，而不是 DateFormatter.Style.full 吗？Swift 知道 DateFormatter 的 dateStyle 应该是什么类型，所以它允许我们使用这个简化写法。在➋处，你将日期格式化器的 timeStyle 设置为.none，以便不显示时间。

#### 在表格视图中显示生日

BirthdaysTableViewController 类有一个表视图，用于显示一列项目的列表。表视图有一个或多个包含行的部分，每一行包含一个单元格。表视图中的部分是行的分组，可以选择是否显示标题。一个显示有多个部分的表视图应用实例是设置应用，如图 11-5 所示。它显示了一个将行分组到不同部分的列表。

表视图的每个部分和行都有一个索引号进行标识。这些数字从 0 开始，然后随着你向下滚动表视图而增加 1。例如，设置应用中的隐私行位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间部分，有一个名为*表视图数据源*的部分，其中包含三个方法。表视图控制器使用这些方法来确定在表视图中将显示什么内容。

numberOfSections(in:) 告诉表视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表视图在每个部分中将显示多少行

tableView(_:cellForRowAt:) 设置将要显示在表视图每一行中的每个单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分来分组不同设备设置的行。*

表视图数据源方法会在每次表视图重新加载时由表视图控制器调用。当你创建一个 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现这三个方法才能让应用正常工作，尽管你在代码中不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用来确定表视图中将要显示的内容。我们将在“代理”一节（第 166 页）讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，所以你不需要手动调用它们。

让我们从方法 numberOfSections(in:)开始。Birthdays 表视图控制器是一个只显示生日实例的列表，所以它不需要多个部分。为了设置表视图中的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个 UITableView 类型的参数 tableView，它是使用该类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 已经自带了一个内置的表格视图，并且自动与这些方法连接。每个生日都会显示在自己的一行中。因此，在 tableView(_:numberOfRowsInSection:) 中，为了正确显示所有生日的行数，你需要返回 birthdays 数组中所有 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，表示数组中的项目数，正好适用于这种情况！将这个方法修改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，tableView(_:numberOfRowsInSection:) 还接受一个名为 section 的 Int 参数。当表格视图加载时，这个方法会为每个表格视图的分区被调用。在我们的例子中，我们只有一个分区，所以我们不需要担心检查表格视图的哪个分区正在显示。我们知道它是分区 0，并且我们希望它有与生日数量相同的行数，所以我们写 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:) 方法，这样表格视图就知道每个单元格中应该放入什么内容。由于这个方法被注释掉了，你需要通过删除 /* 和 */ 注释符号来取消注释它。（小心不要不小心取消注释它后面的其他方法！）完成后，将其修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你并不直接调用 tableView(_:cellForRowAt:) 方法。它会在表格视图加载到屏幕时被调用。它会为屏幕上的每个单元格被调用，并且接受两个参数，tableView 和 indexPath。你已经知道 tableView 参数的作用。IndexPath 是一个 Swift 结构体，用于表示表格视图中一行的位置。IndexPath 实例有一个 section 属性和一个 row 属性。由于这个方法会被多次调用（每个表格中的行都会调用一次），我们需要 indexPath 来知道当前配置的是哪个分区和行。indexPath.section 属性提供了分区号，indexPath.row 提供了表格视图单元格的行号。tableView(_:cellForRowAt:) 方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定在 birthdays 数组中哪个生日将显示在单元格内

• 创建两个标签，用于在单元格中显示生日人的名字和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。➊处的代码通过方法 dequeueReusableCell(withIdentifier:for:)来实现。在你可以开始在单元格上使用这个方法之前，你需要告诉这个方法你希望从故事板中使用哪个单元格。早些时候，当你在故事板中时，你给你的单元格设置了标识符 birthdayCellIdentifier（见图 11-4）。这个标识符将你的代码与单元格链接，并告诉你的方法它正在使用正确的单元格。你在调用此方法时的字符串必须与故事板中设置的字符串完全相同，否则你会收到错误，并且应用在运行时会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:)中，你有没有注意到*可重用单元格*这几个字？表格视图中的单元格是一次性创建的，然后可以反复使用。这有助于提高性能和流畅度，因为创建单元格是最耗时的。如果你的应用中有 200 个生日，但一次只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你滚动查看更多生日时，屏幕顶部滚出的单元格会被重用。它们会被填充新的信息，并再次出现在屏幕底部。UITableView 会自动完成这项工作。当表格视图加载时，tableView(_:cellForRowAt:)会为每一行调用一次。当用户滚动查看更多单元格时，它会再次为每一行调用，正如它即将出现在屏幕上一样。

接下来，我们需要找出应该在单元格中显示的生日。我们希望在每一行中显示来自生日数组的一个生日。第一个生日，在 birthdays[0]，应该显示在第 0 行。第二个生日，在 birthdays[1]，应该显示在第 1 行，以此类推，这意味着 indexPath 的行数与我们要访问的生日数组中的位置相同。➋处的代码通过使用 indexPath.row 从生日数组中访问正确的 Birthday 对象。一旦我们获取到正确的 Birthday 对象，我们将其赋值给一个名为 birthday 的常量，这样我们就可以设置这个单元格中的标签。

请注意，我们使用 let 将生日赋值给常量而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并且赋值给它自己的 Birthday 对象。由于我们不会改变任何生日常量——我们只是读取它们的属性——因此我们不希望将它们定义为变量。

现在你有了单元格和生日，是时候填写详细信息了。每个单元格需要两个标签来显示生日人物的名字和出生日期。你将单元格设置为 Subtitle 样式，以便它有一个标题标签和一个副标题标签。每个单元格将已经包含这些标签，因此现在你不需要自己创建标签。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格隔开。➍处，使用 dateFormatter 的 string(from:) 方法来将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置完成时，tableView(_:cellForRowAt:) 会返回该单元格（➎），以便它能够在表格视图的该 indexPath 上显示。

### 将所有内容整合在一起

现在，你可以使用添加生日视图控制器向应用中添加生日实例，并且你有一个表格视图来列出每个生日，显示在生日表格视图控制器中。但是当你运行应用并尝试添加生日时，它并没有显示。为了让你添加的每个生日都出现在表格视图中，你需要让添加生日视图控制器与生日表格视图控制器进行沟通。你可以通过使用*委托*模式来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托模式。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但是 B 并不了解 A——它只是突然出现，并不知道自己是从哪里来的或如何到达的。那么 B 如何与 A 进行沟通呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将工作或任务交给另一个人完成。*委托*就像是一个老板，告诉一个被委托的员工该做什么。当被委托的员工完成任务后，有时会将信息报告给委托的老板。

Swift 中的委托与其他语言中的委托非常相似，但我们这里没有老板和员工，而是有委托和委托对象。由于类 B 是被类 A 告诉该做什么的，因此它是委托对象。我们为类 B 提供一个名为 delegate 的特殊属性，告诉它谁是它的委托对象——这样它就知道该与谁进行沟通。委托对象可以是任何拥有在*协议*中定义的一组方法的类。协议就像是两类之间的协议，告诉它们委托可以要求委托对象做什么。它列出了委托可以使用的所有方法和属性名称。

类 A 创建类 B，将自己设置为类 B 的委托，并给类 B 赋予一个协议中的任务。一旦类 B 完成任务，它会向类 A 汇报。让我们看看在应用中这是如何工作的。

生日表格视图控制器是视图控制器 A，而添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用于报告结果。

看看 图 11-6。当用户点击添加按钮 ➊ 时，Birthdays 表视图控制器创建了 Add Birthday 视图控制器 ➋ 并将自身设置为 Add Birthday 视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：一个新生日被添加并通过代理从 Add Birthday 视图控制器传递到 Birthdays 表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为包含一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，Add Birthday 视图控制器会调用此方法 ➍ 并将新生日传递给它的代理，即 Birthdays 表视图控制器。Birthdays 表视图控制器接收该生日，将其添加到其生日数组中，然后重新加载其表视图 ➎，这样新生日就会出现在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，包含方法 addBirthdayViewController(_:didAddBirthday:)，该方法可以在每次生日被添加到应用时由 Add Birthday 视图控制器调用。Birthdays 表视图控制器将实现该协议方法，这样每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器只需告诉其代理：“嘿！有人刚刚添加了这个生日”，而 Birthdays 表视图控制器会接收到消息并回应：“哦！我会把这个添加到我的列表中，并刷新我的显示，以便新生日能出现。”

现在让我们在代码中实现这个功能！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方* 添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 定义协议时，输入关键字 protocol，后跟协议名称 AddBirthdayViewControllerDelegate。这个名字很长，但 Swift 程序员通常会根据调用类的名称来命名协议，并在最后加上 “Delegate” 一词。这样你就能通过查看协议名称，知道哪个类正在使用这个协议。既然你现在是 Swift 程序员，应该遵循同样的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传回代理类 ➋。注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。再次强调，Swift 程序员在实现协议方法时通常会这么做，所以你也应该坚持这么做。这样做有助于知道是谁发送了消息，并且让代理能够访问该对象及其类。

当 Add Birthday 视图控制器调用此方法时，它会将自身作为 addBirthdayViewController 参数传入。你很快就会看到如何做到这一点。需要注意的另一件事是外部参数名 didAddBirthday。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚做过的事情或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表视图控制器去采用这个协议并使用协议的方法。

##### 使 Birthdays 表视图控制器符合协议

为了采用该协议，Birthdays 表视图控制器需要使自身成为 AddBirthdayViewControllerDelegate。为此，你需要在 UITableViewController 超类后添加 AddBirthdayViewControllerDelegate 到类定义中。在类的顶部，在 UITableViewController 后面添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做了，红色的错误提示就会出现。这是因为 BirthdaysTableViewController 表示它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了解决这个问题，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会修复这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，而且超类名称必须在任何协议之前写出。但虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议会在超类后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:) 方法添加到 Birthdays TableViewController。一个好的位置是在类的末尾，在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期待你添加这个方法。请注意，不同于子类方法，在 addBirthdayViewController(_:didAddBirthday:) 前你不需要使用 override 关键字，因为没有原始的方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现 ➋。接下来，你需要刷新表视图，以便它显示这个新的生日，通过调用 tableView 属性上的 reloadData() 方法 ➌。当 reloadData() 被调用时，表视图的数据源方法将被再次调用，新增的生日将会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这并不是必需的，但将类的不同部分进行标记是一个良好的编码风格，它有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是一个 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中，你可以在其中使用它。这个下拉菜单可以帮助你找到方法，并让你跳转到代码中的不同位置。要使用这个菜单，请点击编辑器窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为添加生日视图控制器设置委托

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 AddBirthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表格视图控制器它何时添加了一个生日。为此，AddBirthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类的 outlets 下面插入以下代码来安排这一点：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在*添加生日*视图控制器创建之前，你无法设置它。你将很快学习到在哪里设置委托。

现在 AddBirthday 视图控制器有了一个委托，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日传递给委托。将 saveTapped(_:) 修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:) 将其传递回委托。

很棒！你已经完成了对添加生日视图控制器的修改。它现在有了一个委托，能够监听生日已保存的调用。运行应用程序查看会发生什么。

嗯……变化不大。当你添加一个生日时，你依然看不到它出现在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置委托连接这两个控制器

你需要做最后一件事。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 AddBirthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存着在保存生日时与之通信的委托。但是我们从未明确地将委托属性设置为 Birthdays 表格视图控制器。所以，现在是时候在两个视图控制器之间建立通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，叫做 prepare(for:sender:) 。通过删除包围它的 /* 和 */ 注释符号来取消注释该方法。

每当 Birthdays 表视图控制器放弃当前屏幕并通过 storyboard segue 过渡到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将 Birthdays 表视图控制器传递到 Add Birthday 视图控制器，并将其设置为 Add Birthday 视图控制器的委托。在 prepare(for:sender:) 方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码，就能将 Add Birthday 视图控制器的委托设置为 Birthdays 表视图控制器。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 在注释中提示了如何做到这一点。UIStoryboardSegue 有一个叫做 destination 的属性，它位于正在准备的 segue 的另一端，但这个应用程序的目标并不是 AddBirthdayViewController。

在第九章中，你将添加生日的视图控制器嵌入到了导航控制器中，这样就可以拥有一个包含“取消”和“保存”按钮的导航栏。所以你不会在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。在➊这一行，你得到了 navigationController 。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定子类，所以我们需要使用 as 将其转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 后，你可以将委托设置为 self，即当前的 Birthdays 表视图控制器 ➌。

现在运行应用程序并添加一些生日！你在 Birthdays 表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序再重新启动，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中进行。

### 你学到的内容

在这一章中，你学习了如何制作一个表视图控制器来展示你的生日列表。你还学会了如何在 Add Birthday 视图控制器中添加一个生日，然后如何使用委托将该生日添加到 Birthdays 表视图控制器中的 birthdays 数组中，以便它能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用后重新运行，它们也会显示。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

请注意，dateFormatter 是一个常量，是通过 let 创建的。即使你会更改 dateFormatter 的属性，如 dateStyle 和 timeStyle，你永远不会更改 dateFormatter 本身。

你还需要设置 dateFormatter，以便它能够以完整格式的字符串显示出生日期，比如“星期二，2008 年 12 月 17 日”。正如你在第十章中看到的，最合适的地方是 viewDidLoad()方法，该方法在生日表格视图控制器加载其视图时被调用。这是进行任何所需设置的完美时机。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在➊处，你设置了 dateFormatter 的 dateStyle 属性，以便它为每个生日显示一个格式化的日期字符串。你有没有注意到我们直接写了.full，而不是 DateFormatter.Style.full？Swift 知道 dateFormatter 的 dateStyle 应该是什么类型，因此它允许我们使用这个小的快捷方式。在➋处，你将 dateFormatter 的 timeStyle 设置为.none，这样就不会显示时间。

#### 在表格视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于在单列中显示一项项内容。表格视图有一个或多个部分，每个部分包含若干行，每行包含一个单元格。表格视图中的部分是行的分组，可以带或不带标题。一个显示有多个部分的表格视图的应用示例是设置应用，如图 11-5 所示。它显示了一个将行分组到不同部分的列表。

表格视图的每一部分和每一行都有一个索引号。这些数字从 0 开始，然后随着向下滚动表格视图而增加。例如，设置应用中的隐私行位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为*表格视图数据源*的部分，包含三个方法。表格视图控制器使用这些方法来确定在其表格视图中将显示什么内容。

numberOfSections(in:) 告诉表格视图应该有多少个部分。

tableView(_:numberOfRowsInSection:) 告诉表格视图每个部分将显示多少行。

tableView(_:cellForRowAt:) 设置将显示在表格视图每一行中的每个单元格。

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分将不同的设备设置行分组。*

每次表格视图重新加载时，表格视图控制器都会调用表格视图的数据源方法。当你创建 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。即使你在代码中不会直接调用它们，你也需要实现这三个方法才能使应用正常工作。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用于确定在表格视图中显示的内容。我们将在 “代理模式” 一章第 166 页中讨论协议。现在，你只需要知道，UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要显式调用它们。

让我们从 numberOfSections(in:) 方法开始。Birthdays 表格视图控制器是一个仅显示生日实例的列表，因此它不需要多个 sections。为了设置表格视图中的 sections 数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 tableView 的 UITableView 作为参数，它是使用此类作为数据源的表格视图。我们不需要担心如何建立这个连接，因为 UITableViewController 自带一个内建的表格视图，并且它会自动与这些方法连接。每个生日会显示在它自己的行中。因此，在 tableView(_:numberOfRowsInSection:) 中，为了让表格视图显示所有生日的正确行数，你需要返回在 birthdays 数组中生日实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少项，正好适用于这种情况！将这个方法修改为如下代码：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，tableView(_:numberOfRowsInSection:) 还接受一个名为 section 的 Int 类型参数。当表格视图加载时，这个方法会为表格视图中的每个 section 被调用。在我们的例子中，只有一个 section，因此我们不需要关心表格视图正在显示的是哪个 section。我们知道它是 section 0，并且我们希望它的行数与生日数目相等，因此我们写下 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:) 方法，这样表格视图才能知道每个单元格中要显示什么内容。由于这个方法被注释掉了，你需要删除 /* 和 */ 来取消注释它。（小心不要意外取消注释它后面的其他方法！）完成后，将其修改为如下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会调用方法`tableView(_:cellForRowAt:)`。它是在表视图加载到屏幕上时被调用的。它会为屏幕上的每个单元格调用一次，并且有两个参数，tableView 和 indexPath。你已经知道 tableView 参数的用途。IndexPath 是一个 Swift 结构体，用于表示表视图中行的位置。一个 IndexPath 实例有一个 section 属性和一个 row 属性。由于这个方法会被多次调用（每个表格行都会调用一次），我们需要 indexPath 来知道我们当前正在配置哪个部分和行。indexPath.section 属性给出部分号，indexPath.row 给出表格视图单元格的行号。`tableView(_:cellForRowAt:)`方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定哪个生日数组中的生日将在单元格内显示

• 创建两个标签，用于在单元格中显示生日人的姓名和出生日期

• 返回准备好在表视图中显示的单元格

让我们逐行查看这段代码。

首先，创建 UITableViewCell。代码中的➊部分通过使用方法`dequeueReusableCell(withIdentifier:for:)`来实现这一点。在你开始在单元格上使用这个方法之前，你需要告诉这个方法你希望使用哪个单元格。之前，在故事板中，你为你的单元格指定了标识符 birthdayCellIdentifier（参见图 11-4）。这个标识符将你的代码与单元格连接，并告诉你的方法它正在使用正确的单元格。当你调用这个方法时，字符串必须与在故事板中设置的字符串完全相同，否则会出错，应用程序在运行时会崩溃。

在方法`dequeueReusableCell(withIdentifier:for:)`中，你是否注意到了*可重用单元格*这几个字？表视图中的单元格是创建一次后可以重复使用的。这有助于提高程序的运行效率，因为创建单元格是最耗时的。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，从屏幕顶部滚动出去的单元格将被重用。它们会被填充新的信息并再次出现在屏幕的底部。UITableView 会自动完成这项工作。当表视图加载时，`tableView(_:cellForRowAt:)`会为每个可见行调用一次。当用户滚动查看更多单元格时，它会在每个行即将出现在屏幕上时再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日（即 birthdays[0]）应该显示在第 0 行。第二个生日（即 birthdays[1]）应该显示在第 1 行，以此类推，这意味着 indexPath 的行数与我们想要访问的 birthdays 数组中的位置相同。➋处的代码通过使用 indexPath.row 访问 birthdays 数组中的正确 Birthday 对象。一旦我们获取到正确的 Birthday 对象，就将其赋值给一个名为 birthday 的常量，以便我们可以在这个单元格中设置标签。

请注意，我们使用 let 来将生日赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都会拥有自己的生日常量，并为其分配一个生日对象。由于我们不打算更改任何生日常量——我们只是读取它们的属性——所以我们不希望将它们设为变量。

现在您已经有了单元格和生日信息，是时候填写详细信息了。每个单元格需要两个标签来显示生日人的姓名和出生日期。您将单元格设置为 Subtitle 样式，这样它就会有一个 Title 标签和一个 Subtitle 标签。每个单元格已经包含了这些标签，因此您现在无需自己创建标签。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌处的代码将 textLabel 的文本设置为由 birthday 的 firstName 和 lastName 组成的字符串，中间有一个空格。➍处，您使用 dateFormatter 的 string(from:)方法，将出生日期显示在 detailTextLabel 中。

当您的单元格完全配置好后，tableView(_:cellForRowAt:)在➎处返回该单元格，以便可以在表视图的相应 indexPath 位置显示。

### 将一切整合在一起

现在，您可以使用“添加生日”视图控制器向应用程序添加生日实例，并且有一个表视图用于在“生日”表视图控制器中列出每个生日。但是当您尝试运行应用并添加生日时，生日并没有显示出来。为了让每个添加的生日出现在表视图中，您需要使“添加生日”视图控制器与“生日”表视图控制器进行通信。您可以通过使用*委托*来做到这一点。

#### 委托

委托（Delegation）可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设您有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 呈现在自己之上。A 了解 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 并不了解 A——它只是被弹出并且不知道自己从哪里来或是怎么来的。那么 B 如何与 A 进行沟通呢？通过委托！

![](img/Image00245.jpg)

委托是当某人将一个任务交给别人时发生的。一个*委托*就像是一个老板，告诉被委托的员工应该做什么。当被委托的员工完成任务后，他们有时会将信息反馈给委托的老板。

Swift 中的委托（Delegation）非常类似，但它不是由老板和员工组成，而是由委托对象和被委托对象组成。由于 B 类是由 A 类告诉它做什么的，所以 B 类是被委托对象。我们给 B 类一个特别的属性，叫做 delegate，用来告诉它谁是它的委托对象——这样，它就知道应该与谁进行沟通。委托对象可以是任何具有在*协议*中定义的一组方法的类。协议就像是两个类之间的协议，告诉它们委托对象可以要求被委托对象做什么。它包含了委托对象可以在被委托对象上使用的方法和属性名称。

A 类创建 B 类，将自己设置为 B 类的委托，并给 B 类分配一个协议中的任务。一旦 B 类完成它的任务，它会向 A 类报告。让我们看看这个在应用中是如何工作的。

Birthdays 表格视图控制器是视图控制器 A，而 Add Birthday 视图控制器是视图控制器 B。我们将创建一个协议，叫做 AddBirthdayViewControllerDelegate，并为该协议定义一个方法：addBirthdayViewController(_:didAddBirthday:)，该方法将由 Add Birthday 视图控制器用来报告。

查看一下图 11-6。当用户点击添加按钮 ➊ 时，Birthdays 表格视图控制器会创建 Add Birthday 视图控制器 ➋，并将自己设置为 Add Birthday 视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：通过委托，新的生日从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为包含一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，Add Birthday 视图控制器会调用这个方法 ➍，并将新的生日传递给它的委托对象——Birthdays 表格视图控制器。Birthdays 表格视图控制器接收这个生日，将它添加到它的 birthdays 数组中，然后重新加载表格视图 ➎，以便新添加的生日能够显示在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法会在每次向应用中添加生日时由 Add Birthday 视图控制器调用。Birthdays 表格视图控制器会实现该协议方法，这样每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器只需告诉它的委托，“嘿！刚刚添加了这个生日”，而 Birthdays 表格视图控制器会收到这个信息并回应，“哦！我会把它添加到我的列表中并刷新显示，确保新的生日能够显示出来。”

现在，让我们开始用代码来实现吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类*上方*，添加定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过输入关键字 protocol 并接着输入协议名 AddBirthdayViewControllerDelegate 来定义协议，这在➊处完成。这个名字很长，但 Swift 程序员通常会将协议命名为调用类的名称，并在末尾加上 Delegate。这样你就可以通过查看协议名称来判断哪个类在使用该协议。既然你现在是一个 Swift 程序员，你应该遵循这种命名惯例。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，用来将 Birthday 对象传回委托类➋。请注意，在这个函数中，你将 AddBirthdayViewController 作为参数之一。再次提醒，Swift 程序员在实现协议方法时通常会这样做，所以你也应该遵循这个约定。知道是谁发送了消息，并且让委托能够访问该对象及其类是很有用的。

当 Add Birthday 视图控制器调用此方法时，它会将自身作为 addBirthdayViewController 参数传递。你很快就会看到这是如何完成的。另一个需要注意的是外部参数名 didAddBirthday。许多委托协议方法中包含*did*和*will*，因为它们用来描述调用类已经做了或者将要做的事情。

现在你已经定义了协议，需要告诉 Birthdays 表视图控制器采用此协议并使用协议的方法。

##### 让 Birthdays 表视图控制器遵循协议

为了采用协议，Birthdays 表视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中，紧接着 UITableViewController 父类后面，添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做了，就会出现一个红色错误。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快会解决这个问题。

需要注意的是，BirthdaysTableViewController 是 UITableViewController 的子类。一个类只能有一个父类，并且该父类的名字必须写在任何协议之前。但虽然一个类只能有一个父类，它可以采用任意多个协议——这些协议都会列在父类之后，用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的添加位置是类的末尾，紧接着导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动补全会建议整个方法声明。这是因为它知道该类采用了 AddBirthdayViewController Delegate 协议，并且它期望你添加这个方法。请注意，与子类化方法不同，你在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将添加生日视图控制器传递过来的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来做到这一点 ➋ 。接下来，你需要刷新表视图，以便它显示这个新添加的生日，方法是调用 tableView 属性上的 reloadData() 方法 ➌ 。当调用 reloadData() 时，表视图的数据源方法会再次被调用，新增的生日会显示在生日列表的底部。

你可能注意到我们在方法上方添加了注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必须的，但良好的编码风格是标记出类的不同部分，这有助于保持代码的简洁和可读性。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你找到方法并让你跳转到代码中的不同位置。要使用这个菜单，点击编辑器窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为添加生日视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议来告知 Birthdays 表视图控制器它已经添加了一个生日。为此，首先需要在 AddBirthdayViewController 中定义一个代理。我们通过在 AddBirthdayViewController 类的 outlets 下方插入以下代码来设置代理：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在*添加生日视图控制器*创建之前设置它。你将很快学习到在哪里设置代理。

现在，Add Birthday 视图控制器有了代理，在 saveTapped(_:)方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:)方法将生日对象传递给代理。将 saveTapped(_:)修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)将其传递回代理。

很好！你已经完成了对 Add Birthday 视图控制器的更改。现在它有了一个代理，可以监听生日被保存的事件。运行应用程序看看会发生什么。

嗯……似乎没有什么变化。当你添加一个生日时，仍然看不到它显示在生日表格视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有一件事你需要做。生日表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，当生日被保存时，它会与这个代理进行交互。但我们从未特别将代理属性设置为生日表格视图控制器。所以，现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个已被注释掉的方法 prepare(for:sender:)。通过删除/*和*/来取消注释该方法。

每当生日表格视图控制器放弃其屏幕并且应用程序通过 Storyboard segue 过渡到另一个视图控制器时，系统会自动调用此方法。我们将使用此方法将生日表格视图控制器传递给 Add Birthday 视图控制器，并将其设置为 Add Birthday 视图控制器的代理。在 prepare(for:sender:)方法中编写以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码，就可以将 Add Birthday 视图控制器的代理设置为生日表格视图控制器。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 在注释中留下了一个提示，告诉你如何做到这一点。UIStoryboardSegue 在准备此方法时，segue 的另一端有一个名为 destination 的属性，但此应用程序的目标并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到一个导航控制器中，以便你可以有一个带有取消和保存按钮的导航栏。所以，你不指望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊处的代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，我们需要使用 as 进行类型转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是导航控制器的 topViewController ➋。topViewController 就是当前在导航控制器中显示的视图控制器，但它的属性类型是 UIViewController，因此必须强制转换为 AddBirthdayViewController，以表明这是 UIViewController 的一个具体子类。最后，当你得到一个 AddBirthdayViewController 时，你可以将委托设置为 self，即当前的生日表视图控制器 ➌。

现在运行应用程序并添加一些生日！在生日表视图控制器中，你看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序然后重新运行它，之前添加的生日会消失。我们还需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在这一章中，你学习了如何创建一个表视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加生日，然后通过委托将生日添加到生日表视图控制器中的生日数组中，以便它可以显示出来。

在第十二章中，你将学习如何将生日保存到设备中，以便即使退出应用程序并重新运行，它们也能显示出来。为了保存生日，你将使用 Core Data，这是我们在项目开始时设置的。

你还需要设置 dateFormatter，以便它可以将生日日期显示为完全格式化的字符串，例如“2008 年 12 月 17 日，星期二”。正如你在第十章中看到的，设置的好地方是 viewDidLoad()方法，它在生日表视图控制器加载视图时被调用。这是进行任何类所需设置的完美时机。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在➊处，你设置了 dateFormatter 的 dateStyle，以便它能够为每个生日显示格式化的日期字符串。你是否注意到我们只是写了.full，而不是 DateFormatter.Style.full？Swift 知道 DateFormatter 的 dateStyle 应该是什么类型，所以它允许我们使用这个小技巧。在➋处，你将 dateFormatter 的 timeStyle 设置为.none，这样就不会显示时间。

#### 在表视图中显示生日

BirthdaysTableViewController 类有一个表视图，用于在单列中显示项目列表。表视图有一个或多个包含行的区段，每一行包含一个单元格。表视图中的一个区段是行的分组，可以显示带有或不带有标题。一个显示带有多个区段的表视图的应用示例是设置应用程序，如图 11-5 所示。它显示了一列已被划分为不同区段的行。

表格视图的每个分区和行都通过索引号来标识。这些索引从 0 开始，随着你向下滚动表格视图，索引号逐渐增加。例如，在设置应用中，隐私选项位于第 0 个分区，第 1 行。新闻设置位于第 1 个分区，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个名为*表格视图数据源*的部分，其中包含三个方法。表格视图控制器使用这些方法来确定将显示在表格视图中的内容。

numberOfSections(in:) 告诉表格视图应该有多少个分区

tableView(_:numberOfRowsInSection:) 告诉表格视图每个分区将显示多少行

tableView(_:cellForRowAt:) 设置将在表格视图每一行中显示的每个单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用分区来对不同的设备设置行进行分组。*

每次表格视图重新加载时，表格视图控制器都会调用表格视图数据源方法。Xcode 会在你创建 UITableViewController 的子类时自动为你生成这些方法模板。你需要实现所有三个方法才能使应用正常工作，尽管你在代码中永远不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用来确定将显示在表格视图中的内容。我们将在 “代理” 第 166 页讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要手动调用它们。

让我们从方法 numberOfSections(in:) 开始。Birthdays 表格视图控制器是一个仅显示生日实例的列表，因此它不需要多个分区。为了设置表格视图中的分区数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

该方法接受一个名为 tableView 的 UITableView 参数，这是使用此类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 已经内置了一个自动连接到这些方法的表格视图。每个生日都会显示在自己的行中。因此，在 tableView(_:numberOfRowsInSection:) 方法中，为了确保正确的行数显示所有生日，你需要返回你在 birthdays 数组中拥有的生日实例的数量。你记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少个元素，它非常适合这个场景！将这个方法更改为如下：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，tableView(_:numberOfRowsInSection:)方法还接受一个名为 section 的 Int 类型参数。当表格视图加载时，此方法会为表格视图中的每个部分调用。在我们的例子中，我们只有一个部分，因此不需要检查当前显示的是表格视图的哪个部分。我们知道它是第零部分，并且希望它的行数与生日的数量相同，所以我们写下 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:)方法，这样表格视图才知道在每个单元格内放置什么内容。由于此方法被注释掉了，你需要通过删除/*和*/来取消注释它。（小心不要不小心取消注释它后面的其他方法！）完成这一步后，将其改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要调用 tableView(_:cellForRowAt:)方法。它是在表格视图加载到屏幕上时被调用的。它会为屏幕上的每个单元格调用，并接受两个参数，tableView 和 indexPath。你已经知道 tableView 参数的用途。IndexPath 是一个 Swift 结构体，用于表示表格视图中某行的位置。IndexPath 实例有一个 section 属性和一个 row 属性。由于这个方法会被多次调用（每一行都会调用一次），我们需要 indexPath 来知道当前配置的是哪个部分和哪一行。indexPath.section 属性给出部分号，indexPath.row 属性给出表格视图单元格的行号。tableView(_:cellForRowAt:)中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定在 birthdays 数组中哪个生日将显示在单元格内

• 创建两个标签，用于显示生日人的姓名和出生日期

• 返回表格视图中准备显示的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。在➊处的代码通过调用 dequeueReusableCell(withIdentifier:for:)方法来实现这一点。不过，在开始使用此方法之前，你需要告诉它从故事板中使用哪一个单元格。早些时候，在故事板中，你为单元格设置了标识符 birthdayCellIdentifier（见图 11-4）。这个标识符将你的代码与单元格关联，并告诉你的方法正在使用正确的单元格。调用此方法时使用的字符串必须与在故事板中设置的字符串完全相同，否则你会遇到错误，应用程序在运行时会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:)中，是否注意到*Reusable Cell*这两个词？表格视图中的 cell 是创建一次后就可以反复使用的。这有助于一切运行得更快更顺畅，因为创建 cell 是最耗时的操作。如果你的应用中有 200 个生日，但每次只能显示 10 个，那么你只需要 10 个 cell 来显示这些生日。当你向下滚动显示更多生日时，屏幕顶部滚动出去的 cell 会被重用。它们会被填充上新的信息，并再次出现在屏幕底部。UITableView 会自动处理这些工作。当 table view 加载时，tableView(_:cellForRowAt:)会为每一行调用一次。当用户滚动查看更多 cell 时，它会在每一行即将出现在屏幕上时再次调用。

接下来，我们需要找出哪一个 Birthday 应该显示在 cell 中。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日，位于 birthdays[0]，应该显示在第 0 行。第二个生日，位于 birthdays[1]，应该显示在第 1 行，依此类推，这意味着 indexPath 的 row 和我们想要访问的 birthdays 数组中的位置相同。➋处的代码通过使用 indexPath.row 从 birthdays 数组中获取正确的 Birthday 对象。一旦得到正确的 Birthday 对象，我们将其赋值给一个名为 birthday 的常量，以便设置该 cell 中的标签。

注意，我们使用 let 将 birthday 赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的 birthday 常量。每个 cell 都会得到一个自己的 birthday 常量，并且赋值给它自己的 Birthday 对象。由于我们不会修改任何 birthday 常量—我们只是读取它们的属性—因此不需要将它们设置为变量。

现在你已经有了 cell 和 birthday，接下来就是填写详细信息了。每个 cell 需要两个标签来显示生日人的姓名和出生日期。你将 cell 设置为 Subtitle 样式，这样它就会有一个 Title 标签和一个 Subtitle 标签。每个 cell 已经包含这些标签，因此你无需自己创建标签。

标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。➌处的代码将 textLabel 的文本设置为由 birthday 的 firstName 和 lastName 组成的字符串，两者之间用空格隔开。在➍处，使用 dateFormatter 的 string(from:)方法将出生日期显示在 detailTextLabel 中。

当你的 cell 完全配置好后，tableView(_:cellForRowAt:)会在➎处返回 cell，以便它可以在 table view 的 indexPath 处显示。

### 将所有内容整合起来

现在，你可以使用添加生日视图控制器将生日实例添加到应用中，并且在生日表视图控制器中查看每个生日的列表。但是当你尝试运行应用并添加生日时，它并没有显示。为了让你添加的每个生日在表视图中显示，你需要让添加生日视图控制器与生日表视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 展示在自身之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 不知道 A——它只是突然出现的，不知道来自哪里，也不知道如何到达那里。那么 B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将工作或任务交给别人。一个*委托人*就像是一个老板，告诉一个委托员工该做什么。当委托员工完成任务时，有时他们会向委托人报告信息。

Swift 中的委托与此非常相似，不过我们不再是老板和员工，而是委托和委托对象。由于是类 A 告诉类 B 做什么，所以类 B 是委托对象。我们为类 B 添加一个特殊的属性，叫做委托（delegate），用来指定它的委托对象，这样它就知道该与谁沟通。委托可以是任何符合*协议*的类。协议就像是两个类之间的约定，告诉它们委托对象可以要求委托对象做什么。它列出了委托对象可以与委托对象一起使用的方法和属性名称。

类 A 创建了类 B，使自己成为类 B 的委托，并给类 B 分配了协议中的任务。一旦类 B 完成任务，它就会向类 A 报告。让我们看看这在应用中是如何工作的。

生日表视图控制器是视图控制器 A，而添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议定义一个方法 `addBirthdayViewController(_:didAddBirthday:)`，这个方法将由添加生日视图控制器用于报告结果。

看看图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器创建了添加生日视图控制器 ➋，并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击“保存” ➌ 时，Add Birthday 视图控制器会调用这个方法 ➍ 并将新的生日传递给它的委托对象，即 Birthdays 表格视图控制器。Birthdays 表格视图控制器接收到这个生日后，会将其添加到自己的 birthdays 数组中，并重新加载表格视图 ➎ ，以便新生日出现在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，其中包含 addBirthdayViewController(_:didAddBirthday:) 方法，当生日被添加到应用时，Add Birthday 视图控制器可以调用该方法。Birthdays 表格视图控制器会实现这个协议方法，这样每当通过 Add Birthday 视图控制器添加一个生日时，Add Birthday 视图控制器就能对其委托对象说：“嘿！刚刚有人添加了这个生日”，然后 Birthdays 表格视图控制器会收到消息并说：“哦！我会把这个添加到我的列表中，并刷新我的显示，让新生日出现在表格里。”

现在让我们在代码中实现这个吧！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类 *上方* 添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过输入关键字 protocol 并跟上协议名称 AddBirthdayViewControllerDelegate 来定义协议 ➊ 。这个名字很长，但 Swift 程序员通常会根据调用类的名字来命名协议，并在后面加上 Delegate 一词。这样你就能通过查看协议的名字知道哪个类在使用这个协议。既然你现在是 Swift 程序员，也应该使用相同的命名惯例。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传回给委托类 ➋ 。请注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。再强调一次，Swift 程序员在实现协议方法时通常会这样做，所以你也应该遵循这个惯例。这对于知道消息是由哪个对象发出的，并且让委托对象能够访问该对象及其类是很有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传入。你很快就会看到这是如何实现的。另一点需要注意的是外部参数名 didAddBirthday。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚完成或即将完成的某些操作。

现在你已经定义了协议，需要告诉 Birthdays 表格视图控制器采用这个协议并使用协议的方法。

##### 让 Birthdays 表格视图控制器遵循协议

为了采用该协议，Birthdays 表视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在 UITableViewController 超类之后的类定义中添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做了，一个红色的错误就会出现。这是因为 BirthdaysTableViewController 声明自己是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现这个协议，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会修复这个问题。

这里需要注意的是，BirthdaysTableViewController 是继承自 UITableViewController 超类的。一个类只能有一个超类，并且该超类的名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议将会列在超类之后，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:) 方法添加到 Birthdays TableViewController 中。一个合适的位置是在类的末尾，紧跟着导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动完成功能会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它预计你会添加这个方法。请注意，与子类方法不同，你在 addBirthdayViewController(_:didAddBirthday:) 前不会使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将由 Add Birthday 视图控制器传入的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来完成这一步 ➋。接下来，你需要刷新表视图，使其显示这个新的生日，可以通过在 tableView 属性上调用 reloadData() 方法来实现 ➌。当调用 reloadData() 时，表视图的数据源方法将会再次被调用，新增的生日将会显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这并不是必需的，但标记类的不同部分是良好的编码风格，它有助于保持代码的整洁和可读性。注释的第一部分，`MARK: -`，是一个 Xcode 识别的特殊关键字，它将 `AddBirthdayViewControllerDelegate` 部分添加到一个下拉目录菜单中，你可以在类的顶部使用该菜单。这个下拉菜单帮助你找到方法，并让你跳转到代码中的不同位置。要使用这个菜单，请点击编辑器面板顶部的 `Birthdays TableViewController`，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，方便快速跳转到某个部分。*

##### 为添加生日视图控制器设置代理

`BirthdaysTableViewController` 已经采纳了 `AddBirthdayViewControllerDelegate` 协议。现在是时候让添加生日视图控制器使用 `AddBirthdayViewControllerDelegate` 协议，告诉生日表视图控制器它已经添加了一个生日。为此，添加生日视图控制器首先需要定义一个代理。我们通过在 `AddBirthdayViewController` 类中添加一个可选的代理属性，类型为 `AddBirthdayViewControllerDelegate`，并在 outlets 下面插入以下代码来实现这一点：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在添加生日视图控制器创建之前设置它。稍后你将学习在哪里设置代理。

既然添加生日视图控制器已经有了一个代理，那么在 `saveTapped(_:)` 方法中，你可以通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将一个生日传递给代理。将 `saveTapped(_:)` 方法改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊ 处的代码通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将它传回给代理。

太好了！你已完成对添加生日视图控制器的修改。现在它有了一个代理，这个代理会监听一个生日被保存的调用。运行应用看看会发生什么。

嗯……好像没有什么变化。当你添加一个生日时，你仍然没有看到它出现在生日表视图控制器中。这是怎么回事？

#### 通过设置代理连接这两个控制器

还有最后一件事你需要做。生日表视图控制器是 `AddBirthdayViewControllerDelegate`，而添加生日视图控制器有一个 `AddBirthdayViewControllerDelegate` 属性，它保存了当一个生日被保存时与之通信的代理。但是我们从未明确地将代理属性设置为生日表视图控制器。因此，现在是时候在这两个视图控制器之间建立通信管道了。

在生日表格视图控制器类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除/*和*/，取消注释该方法。

当生日表格视图控制器放弃其屏幕并且应用通过故事板 segue 转到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将生日表格视图控制器传递给添加生日视图控制器，并将其设置为添加生日视图控制器的委托。在 prepare(for:sender:)方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的委托为生日表格视图控制器只需要三行代码。首先，你需要能够通过 segue 参数获取到 AddBirthdayViewController 对象。Xcode 已经留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，指向在这个方法中被准备的 segue 的另一端，但对于这个应用来说，destination 并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到一个导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。因此，你不会期望在 segue 的另一端找到添加生日视图控制器。相反，destination 是一个包含添加生日视图控制器的 UINavigationController。➊行代码让你可以获取 navigationController。代码 segue.destination 会返回一个 UIViewController，但因为我们的 navigationController 是 UIViewController 的特定子类，所以我们需要使用 as 将其强制类型转换为 UINavigationController。

接下来，你可以获取到添加生日视图控制器，它是 navigationController 的 topViewController➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，所以必须将其强制类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获取到 AddBirthdayViewController 后，你可以将委托设置为 self，即当前的生日表格视图控制器➌。

现在运行应用并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用后再次运行，它之前的生日会消失。我们还需要将生日保存到设备上，接下来将在第十二章中完成这个操作。

### 你学到了什么

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学习了如何在添加生日视图控制器中添加生日，然后如何使用委托将生日添加到生日表格视图控制器中的生日数组，以便它可以被显示出来。

在第十二章，你将学习如何将生日保存到你的设备上，以便即使退出应用并重新运行后，它们依然会显示。为了保存生日，你将使用在项目开始时设置的 Core Data。

```
override func viewDidLoad() {

    super.viewDidLoad()

  ➊
 dateFormatter
 .dateStyle
 = .full

  ➋
 dateFormatter
 .timeStyle
 = .none

}

```

在➊，你设置了 `dateFormatter` 的 `dateStyle`，以便它能为每个生日显示一个格式化的日期字符串。你注意到我们只是写了 `.full` 而不是 `DateFormatter.Style.full` 吗？Swift 知道 `DateFormatter` 的 `dateStyle` 应该是什么类型，所以它允许我们使用这个小的简便方式。在➋，你设置了 `dateFormatter` 的 `timeStyle` 为 `.none`，这样就不会显示时间。

#### 在表格视图中显示生日

`BirthdaysTableViewController` 类有一个表格视图，用于在单列中显示项目列表。表格视图有一个或多个包含行的部分，每一行包含一个单元格。表格视图中的一个部分是行的分组，可以显示带或不带标题的行。一个显示多个部分的表格视图应用的示例是“设置”应用，如图 11-5 所示。它显示了已拆分成不同部分的行列表。

表格视图的每个部分和行都有一个索引号。这些数字从 0 开始，向下递增。例如，设置应用中的“隐私”行位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 `BirthdaysTableViewController` 类的中间部分，有一个名为*表格视图数据源*的部分，包含三个方法。表格视图控制器使用这些方法来确定在其表格视图中显示的内容。

`numberOfSections(in:)` 告诉表格视图应该有多少个部分

`tableView(_:numberOfRowsInSection:)` 告诉表格视图每个部分中将显示多少行

`tableView(_:cellForRowAt:)` 设置要在表格视图的每一行中显示的每个单元格

![](img/Image00243.jpg)

*图 11-5: 设置应用使用部分将不同设备设置的行分组。*

每当表格视图重新加载时，表格视图数据源方法都会被表格视图控制器调用。当你创建一个 `UITableViewController` 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现所有三个方法，以便应用正常工作，即使你在代码中不会直接调用它们。`UITableViewController` 类实现了 `UITableViewDataSource` 协议，协议中包含这些数据源方法，用于确定表格视图中将显示的内容。我们将在“代理”一节中讨论协议。现在，你只需要知道 `UITableViewController` 使用这些方法来显示内容，并且它会自动调用这些方法，所以你不需要手动调用它们。

我们从方法 numberOfSections(in:) 开始。Birthdays 表格视图控制器是一个仅显示 Birthday 实例的列表，因此它不需要多个分区。为了设置表格视图中的分区数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接收一个名为 tableView 的 UITableView 参数，它是使用这个类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内置的表格视图，自动与这些方法连接。每个生日将显示在自己的行中。因此，在 tableView(_:numberOfRowsInSection:) 中，为了使表格中有正确数量的行来显示所有生日，你需要返回 birthdays 数组中 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少个元素，这正好适用于这种情况！将这个方法更改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，tableView(_:numberOfRowsInSection:) 方法还接收一个名为 section 的 Int 类型参数。当表格视图加载时，这个方法会为表格中的每个分区调用。在我们的例子中，我们只有一个分区，因此我们不需要检查哪个分区正在显示。我们知道是第 0 个分区，并且我们希望它有与生日数量相等的行数，因此我们写下 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:) 方法，这样表格视图就知道每个单元格里应该放置什么内容。由于这个方法被注释掉了，你需要通过删除包围它的 /* 和 */ 来取消注释。（小心不要不小心取消注释后面其他的方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要调用方法 tableView(_:cellForRowAt:)。它会在表格视图加载到屏幕上时被调用。它会为屏幕上的每个单元格调用，并接收两个参数，tableView 和 indexPath。你已经知道 tableView 参数的作用。IndexPath 是一个 Swift 结构体，用于表示表格视图中一行的位置。IndexPath 实例有一个 section 属性和一个 row 属性。由于这个方法会被多次调用（每次为表格中的一行），我们需要 indexPath 来知道当前配置的是哪个分区和行。indexPath.section 属性给出分区号，indexPath.row 给出表格视图单元格的行号。tableView(_:cellForRowAt:) 中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定 birthdays 数组中哪一个 Birthday 会显示在单元格中

• 创建两个标签以显示生日人的姓名和出生日期

• 返回一个准备好在表格视图中显示的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。➊处的代码使用了`dequeueReusableCell(withIdentifier:for:)`方法。在你开始使用这个方法之前，你需要告诉它你想从 storyboard 中使用哪个单元格。之前，当你在 storyboard 中时，你给单元格设置了标识符 birthdayCellIdentifier（见图 11-4）。这个标识符将你的代码与单元格关联，并告诉方法它正在使用正确的单元格。调用这个方法时的字符串需要与你在 storyboard 中设置的字符串完全相同，否则你会遇到错误，应用程序在运行时会崩溃。

在`dequeueReusableCell(withIdentifier:for:)`方法中，你有没有注意到*可重用单元格*这个词？表格视图中的单元格只会创建一次，然后可以反复重用。这有助于提高运行速度和流畅度，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日，但一次屏幕上只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以查看更多的生日时，滚出屏幕顶部的单元格会被重用。它们会被填充上新的信息，然后再次出现在屏幕底部。UITableView 会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)`会为每一行可见的单元格调用一次。当用户滚动以查看更多单元格时，它会在每一行即将出现在屏幕上时再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们想要在每一行中显示`birthdays`数组中的一个生日。第一个生日，即`birthdays[0]`，应该显示在第 0 行。第二个生日，即`birthdays[1]`，应该显示在第 1 行，依此类推，这意味着`indexPath`的行号与我们想要访问的`birthdays`数组中的位置相同。➋处的代码通过使用`indexPath.row`从`birthdays`数组中获取正确的 Birthday 对象。一旦我们得到了正确的 Birthday 对象，我们将其赋值给一个名为`birthday`的常量，这样我们就可以设置该单元格中的标签。

注意，我们使用`let`将生日赋值给常量，而不是变量。我们可以使用`let`是因为每次调用`tableView(_:cellForRowAt:)`时，都会创建一个新的生日常量。每个单元格都会得到自己的生日常量，并且该常量会赋予自己的 Birthday 对象。由于我们不会修改任何生日常量——我们只是读取它们的属性——因此我们不希望将它们设为变量。

现在你已经有了单元格和生日信息，接下来是填写细节。你需要为每个单元格设置两个标签，分别显示生日人的名字和出生日期。你将单元格设置为 Subtitle 风格，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，因此你现在无需自己创建标签。

标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。在➌处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，两者之间有一个空格。在➍处，你使用 dateFormatter 的 string(from:)方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:)方法会返回单元格 ➎，这样它就可以在表格视图的该索引路径位置显示出来。

### 整合所有内容

现在，你可以通过“添加生日”视图控制器将生日实例添加到应用中，并且你有一个表格视图来列出每个生日的“生日表格视图控制器”。但是，当你尝试运行应用并添加一个生日时，它并没有显示出来。为了让你添加的每个生日出现在表格视图中，你需要让“添加生日”视图控制器与“生日表格视图控制器”进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建 B 并将 B 展示在自己之上。A 知道 B 的存在，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但 B 并不知道 A——它只是突然出现，并不知道它是从哪里来的或如何到达这里的。那么，B 如何与 A 沟通呢？通过委托！

![](img/Image00245.jpg)

委托（Delegation）是指某人将工作或任务交给其他人。*委托人*就像一个老板，告诉委派员工该做什么。当委派的员工完成任务后，有时会将信息反馈给委托人老板。

在 Swift 中的委托机制非常相似，但我们不再有老板和员工，而是有委托和委托对象。由于 B 类是被 A 类指示该做什么的对象，所以它是委托对象。我们给 B 类一个特殊的属性，称为 delegate，用来告诉它它的委托对象是谁——这样它就知道与谁进行通信。委托可以是任何实现了*协议*的类。协议就像是两个类之间的协议，告诉它们委托可以请求委托对象做什么。协议中定义了委托可以使用的一系列方法和属性名称。

A 类创建 B 类，并将自己设置为 B 类的委托，同时给 B 类安排了一个协议中的任务。一旦 B 类完成了任务，它会向 A 类报告。让我们看看这个在应用中的实现。

生日表格视图控制器是视图控制器 A，而“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由“添加生日”视图控制器用来报告任务完成情况。

看看图 11-6。当用户点击添加按钮➊时，Birthdays 表格视图控制器会创建 Add Birthday 视图控制器➋，并将自身设置为 Add Birthday 视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮➌时，Add Birthday 视图控制器会调用这个方法➍，并将新的生日传递给它的委托——Birthdays 表格视图控制器。Birthdays 表格视图控制器接收这个生日，加入到它的 birthday 数组中，然后重新加载表格视图➎，以便新生日能出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并使用方法 addBirthdayViewController(_:didAddBirthday:)，当一个生日被添加到应用中时，Add Birthday 视图控制器可以调用这个方法。Birthdays 表格视图控制器将实现这个协议方法，这样每当通过 Add Birthday 视图控制器添加一个生日时，Add Birthday 视图控制器就可以对其委托说：“嘿！有人刚刚添加了这个生日。”然后，Birthdays 表格视图控制器会听到这个消息并回应：“哦！我会把它加到我的列表里，并刷新我的显示，让新的生日出现在表格中。”

现在，让我们在代码中实现这一过程！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类*上方*添加以下代码，定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过在➊处输入关键字 protocol，后跟协议名称 AddBirthdayViewControllerDelegate 来定义协议。这个名字比较长，但 Swift 程序员通常会根据调用类的名字命名协议，并在后面加上 Delegate 这个词。这样，你通过查看协议的名称就能知道是哪个类在使用该协议。既然你现在是一个 Swift 程序员，你也应该遵循同样的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传递回委托类➋。请注意，在这个函数中，你包含了 AddBirthdayViewController 作为一个参数。再次强调，Swift 程序员在实现协议方法时通常会这样做，因此你也应该遵循这一做法。知道是谁发送的消息以及委托方能访问该对象及其类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递过来。你很快就会看到如何实现这一点。另一个需要注意的点是外部参数名 didAddBirthday。许多委托协议方法都包含*did*和*will*这两个词，因为它们用来描述调用类刚刚完成或即将完成的操作。

现在你已经定义了协议，你需要告诉 Birthdays 表视图控制器采用这个协议并使用协议的方法。

##### 使 Birthdays 表视图控制器符合协议

为了采用这个协议，Birthdays 表视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中添加 AddBirthdayViewControllerDelegate，在 UITableViewController 父类后面。你需要在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，就会出现一个红色错误。这是因为 BirthdaysTableViewController 声明自己是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现这个协议，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会修复这个问题。

在这里需要注意的是，BirthdaysTableViewController 是子类化了 UITableViewController 父类。一个类只能有一个父类，并且该父类的名称必须写在任何协议之前。但虽然一个类只能有一个父类，它可以采用任意多个协议——这些协议会列在父类之后，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:)方法添加到 Birthdays TableViewController 中。一个好的添加位置是在类的末尾，就在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动完成功能会建议你整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期望你添加这个方法。请注意，与子类化方法不同，你在 addBirthdayViewController(_:didAddBirthday:)前不需要使用 override 关键字，因为没有原始方法可以被重写。

在这个方法中，你需要做两件事。首先，你需要将由 Add Birthday 视图控制器传递过来的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:)方法来实现这一点➋。接下来，你需要刷新表格视图，以便显示这个新生日，你可以通过调用 tableView 属性上的 reloadData()方法来实现➌。当调用 reloadData()时，表格视图的数据源方法将再次被调用，新增的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但标记类的不同部分是良好的编码风格，有助于保持代码的整洁和可读性。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你找到方法，并让你快速跳转到代码的不同位置。要使用这个菜单，点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 给添加生日视图控制器设置代理

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知生日表格视图控制器它已添加了一个生日。为此，添加生日视图控制器首先需要定义一个代理。我们通过向 AddBirthdayViewController 类添加一个可选的 AddBirthdayViewControllerDelegate 类型的代理属性，来安排这一点，方法是将以下代码行插入到 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在创建*添加生日*视图控制器之前，你不能设置它。稍后你会学习在哪里设置代理。

现在，添加生日视图控制器有了一个代理，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将一个生日传递给代理。将 saveTapped(_:)方法改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码在➊通过 addBirthdayViewController(_:didAddBirthday:)方法将它传回给代理。

太好了！你已经完成了对添加生日视图控制器的修改。它现在有了一个代理，能够监听生日已保存的通知。运行应用程序看看会发生什么。

嗯……变化不大。当你添加一个生日时，仍然看不到它出现在生日表格视图控制器中。发生了什么事？

#### 通过设置代理连接两个控制器

还有最后一件事需要做。生日表格视图控制器是一个 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存与之通信的代理，以便在生日被保存时通知它。但我们从未明确地将代理属性设置为生日表格视图控制器。因此，现在是时候在这两个视图控制器之间建立通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除 /* 和 */ 注释符号，取消注释该方法。

每当 Birthdays 表视图控制器交出其屏幕并且应用程序通过 storyboard segue 切换到另一个视图控制器时，这个方法会被自动调用。我们将使用这个方法将 Birthdays 表视图控制器传递给 Add Birthday 视图控制器，以设置它作为 Add Birthday 视图控制器的代理。在 prepare(for:sender:) 方法中编写以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需三行代码就可以将 Add Birthday 视图控制器的代理设置为 Birthdays 表视图控制器。首先，您需要能够通过 segue 参数访问 AddBirthdayViewController 对象。Xcode 留下了一条注释，提示您可以如何做到这一点。UIStoryboardSegue 有一个叫做 destination 的属性，它位于此方法中正在准备的 segue 的另一端，但该应用程序的目标并不是 AddBirthdayViewController。

在 第九章 中，您将 Add Birthday 视图控制器嵌入到导航控制器中，以便可以拥有带有取消和保存按钮的导航栏。因此，您不会期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊ 处的代码获取了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是一种特定类型的视图控制器，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，您可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此需要将其类型转换为 AddBirthdayViewController，表示该控制器是 UIViewController 的特定子类。最后，获得 AddBirthdayViewController 后，您可以将代理设置为 self，即当前的 Birthdays 表视图控制器 ➌。

现在运行应用程序并添加一些生日！在 Birthdays 表视图控制器中看到什么？生日！生日！生日！不过我们还没有完成。如果您退出应用程序然后重新运行它，之前的生日将消失。我们仍然需要将生日保存到设备中，这将在 第十二章 中完成。

### 你学到了什么

在本章中，您学习了如何创建一个表视图控制器来显示您的生日列表。您还学习了如何在 Add Birthday 视图控制器中添加生日，然后如何使用代理将生日添加到 Birthdays 表视图控制器中的生日数组中，以便能够显示出来。

在 第十二章 中，你将学习如何将生日保存到设备中，这样即使退出应用程序并再次运行，它们仍会显示。为了保存生日，你将使用在项目开始时设置的 Core Data。

在 ➊ 处，你设置了 `dateFormatter` 的 `dateStyle`，使其能够显示每个生日的格式化日期字符串。你是否注意到我们直接写了 `.full`，而不是 `DateFormatter.Style.full`？Swift 知道 `DateFormatter` 的 `dateStyle` 应该是什么类型，所以它允许我们使用这个小快捷方式。在 ➋ 处，你将 `dateFormatter` 的 `timeStyle` 设置为 `.none`，这样就不会显示时间。

#### 在表格视图中显示生日

`BirthdaysTableViewController` 类有一个表格视图，用于在单列中显示项目列表。表格视图有一个或多个部分，每个部分包含若干行，而每行包含一个单元格。表格视图中的一个部分是对行的分组，可以选择显示或不显示头部。一个显示具有多个部分的表格视图的应用示例是设置应用，如 图 11-5 所示。它显示了一些已被分成不同部分的行列表。

表格视图的每个部分和行都有一个索引号。这些数字从 0 开始，随着你向下滚动，数字逐渐增加。例如，设置应用中的隐私行位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 `BirthdaysTableViewController` 类的中间，有一个名为 *表格视图数据源* 的部分，包含三个方法。表格视图控制器使用这些方法来确定将在表格视图中显示的内容。

`numberOfSections(in:)` 告诉表格视图它应该有多少个部分

`tableView(_:numberOfRowsInSection:)` 告诉表格视图每个部分将显示多少行

`tableView(_:cellForRowAt:)` 设置每个将要显示的行的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分将不同的设备设置行分组。*

每次表格视图重新加载时，表格视图控制器都会调用表格视图数据源方法。当你创建一个 `UITableViewController` 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现所有三个方法，才能使应用程序正常工作，尽管你在代码中不会直接调用它们。`UITableViewController` 类实现了 `UITableViewDataSource` 协议，该协议包含这些数据源方法，用于确定表格视图中将显示的内容。我们将在 “委托” 一节中讨论协议。现在，你只需要知道 `UITableViewController` 使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要手动调用它们。

让我们从方法 `numberOfSections(in:)` 开始。Birthdays 表格视图控制器是一个只显示生日实例的列表，因此不需要多个分区。为了设置表格视图中的分区数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 `tableView` 的 `UITableView` 作为参数，它是使用这个类作为数据源的表格视图。我们不需要担心建立这个连接，因为 `UITableViewController` 带有一个内置的表格视图，并且已经自动连接到这些方法中。每个生日会显示在它自己的行中。所以在 `tableView(_:numberOfRowsInSection:)` 中，为了确保表格中有正确数量的行来显示所有的生日，你需要返回 `birthdays` 数组中 `Birthday` 实例的数量。你还记得数组的 `count` 属性吗？它是一个整数，告诉你数组中有多少个元素，非常适合这个场景！将这个方法更改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 `tableView` 参数，`tableView(_:numberOfRowsInSection:)` 还接受一个名为 `section` 的整数。当表格视图加载时，这个方法会为表格视图中的每个分区被调用。在我们的例子中，只有一个分区，所以我们不需要担心检查当前显示的是哪个分区。我们知道它是第 0 个分区，并且希望它的行数和生日的数量一样多，所以我们写 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)`，这样表格视图才能知道在每个单元格中放入什么内容。由于这个方法被注释掉了，你需要通过删除围绕它的 `/*` 和 `*/` 来取消注释。（小心不要不小心取消注释它后面的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要直接调用 `tableView(_:cellForRowAt:)` 方法。它会在表格视图加载到屏幕上时被调用。它会为屏幕上的每个单元格调用，并且接受两个参数，`tableView` 和 `indexPath`。你已经知道 `tableView` 参数的作用。`IndexPath` 是一个 Swift 结构体，用于表示表格视图中行的位置。一个 `IndexPath` 实例有一个 `section` 属性和一个 `row` 属性。由于这个方法会被多次调用（每次为表格中的一行），我们需要通过 `indexPath` 来知道当前正在配置的是哪个分区和哪一行。`indexPath.section` 属性提供分区编号，而 `indexPath.row` 提供表格视图单元格的行号。`tableView(_:cellForRowAt:)` 方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 `UITableViewCell`

• 确定 `birthdays` 数组中哪个生日将显示在单元格中

• 创建两个标签，在单元格中显示生日人的名字和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。在➊处的代码通过使用方法`dequeueReusableCell(withIdentifier:for:)`来实现这一点。不过，在你开始在单元格上使用这个方法之前，需要告诉方法你想从故事板中使用哪个单元格。之前，当你在故事板中时，你为你的单元格设置了标识符`birthdayCellIdentifier`（参见图 11-4）。这个标识符将你的代码与单元格关联起来，并告诉方法它正在使用正确的单元格。当你调用此方法时，传入的字符串需要与在故事板中设置的字符串完全相同，否则你会遇到错误，应用程序运行时会崩溃。

在`dequeueReusableCell(withIdentifier:for:)`方法中，你注意到*Reusable Cell*这个词了吗？表格视图中的单元格只会创建一次，然后可以反复使用。这有助于提高运行速度和流畅度，因为创建单元格是最耗时的部分。如果你的应用程序中有 200 个生日，但一次只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，滚出屏幕顶部的单元格会被重复使用。它们被填充上新的信息，再次出现在屏幕底部。UITableView 会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)`会被调用，用于每一行的可见单元格。当用户滚动以查看更多单元格时，每当单元格即将出现在屏幕上时，这个方法会再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中显示`birthdays`数组中的一个生日。第一个生日（即`birthdays[0]`）应该显示在第 0 行。第二个生日（即`birthdays[1]`）应该显示在第 1 行，以此类推，这意味着`indexPath`的行号与我们想要访问的`birthdays`数组中的位置相同。➋处的代码通过使用`indexPath.row`从`birthdays`数组中获取正确的`Birthday`对象。获得正确的`Birthday`对象后，我们将其赋值给名为`birthday`的常量，以便在该单元格中设置标签。

请注意，我们使用`let`将生日赋值给一个常量，而不是变量。我们可以使用`let`是因为每次调用`tableView(_:cellForRowAt:)`时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并分配给自己的`Birthday`对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——因此不需要将它们定义为变量。

现在你有了单元格和生日信息，接下来是填充详细信息。你需要为每个单元格创建两个标签，分别显示生日人物的姓名和出生日期。你将单元格设置为“副标题”样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含这些标签，因此现在你不需要自己创建标签。

这些标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间有一个空格。➍ 处，你使用 dateFormatter 的 string(from:) 方法在 detailTextLabel 中显示出生日期。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 在 ➎ 处返回单元格，以便它可以在该 indexPath 处显示在表格视图中。

### 将一切组合在一起

现在，你可以通过添加生日视图控制器向应用中添加生日实例，并且你有一个表格视图来列出每个生日，在 Birthdays 表格视图控制器中显示。但当你尝试运行应用并添加一个生日时，它没有显示出来。为了让你添加的每个生日都出现在表格视图中，你需要让添加生日视图控制器与 Birthdays 表格视图控制器进行通信。你可以通过使用 *委托* 来实现这一点。

#### 委托（DELEGATION）

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建 B 并将 B 显示在自己之上。A 知道 B 的存在，因为它创建并呈现了 B，所以 A 可以将信息传递给 B。但 B 不知道 A 的存在——它只是突然出现，不知道自己从哪里来或如何到达那里。那么，B 怎么与 A 交流呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项工作或任务交给其他人。*委托* 就像是一个老板，告诉被委托的员工该做什么。当被委托的员工完成任务后，他们有时会将信息报告给委托的老板。

Swift 中的委托机制非常相似，但我们不再是老板和员工的关系，而是委托者和被委托对象的关系。由于 B 类是被 A 类指派任务的对象，所以它是被委托对象。我们给 B 类一个特殊的属性，叫做 delegate，用来指明它的委托对象是谁——这样，B 知道应该与谁进行沟通。委托对象可以是任何符合某个 *协议* 的类。协议就像是两个类之间的协议，规定了委托对象可以要求被委托对象做什么。协议列出了委托对象可以在被委托对象上使用的方法和属性名。

A 类创建了 B 类，将自己设为 B 类的委托对象，并为 B 类分配了协议中的任务。一旦 B 类完成任务，它会向 A 类报告。让我们看看在我们的应用中这是如何运作的。

Birthdays 表格视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议定义一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用于回传信息。

看一下 图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过代理从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为拥有一个方法 `addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存按钮 ➌ 时，添加生日视图控制器调用此方法 ➍ 并将新生日传递给它的代理，即生日表视图控制器。生日表视图控制器接收这个生日，将其添加到生日数组中，然后重新加载其表格视图 ➎，使得新生日能够出现在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并在该协议中定义方法 `addBirthdayViewController(_:didAddBirthday:)`，当一个生日被添加到应用时，添加生日视图控制器可以调用该方法。生日表视图控制器将实现该协议方法，以便每当通过添加生日视图控制器添加一个生日时，添加生日视图控制器只需要对其代理说：“嘿！有人刚刚添加了这个生日。” 然后生日表视图控制器会收到这个消息并说：“哦！我会把它添加到我的列表中并刷新显示，让新的生日出现在表格中。”

现在让我们用代码来实现吧！

##### 创建一个协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方*，添加定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处定义协议，通过键入关键字 `protocol`，后跟协议名 `AddBirthdayViewControllerDelegate`。这个名字有点长，但 Swift 开发者通常会根据调用的类来命名协议，并在名称末尾加上 "Delegate"。这样你就能通过查看协议名称判断是哪个类在使用该协议。既然你现在是 Swift 开发者，应该遵循相同的命名惯例。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)` 是唯一的函数，它用来将生日对象传回代理类 ➋。注意，在这个方法中你包含了 AddBirthdayViewController 作为一个参数。再次强调，Swift 开发者通常在实现协议方法时遵循这一惯例，所以你也应该坚持这么做。知道谁发送了消息以及代理能够访问那个对象和它的类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递。你很快就会看到如何做到这一点。另一个需要注意的点是外部参数名称 didAddBirthday。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用于描述调用类刚刚做了什么或将要做什么。

既然你已经定义了协议，现在需要告诉 Birthdays 表格视图控制器采用这个协议并使用协议的方法。

##### 使 Birthdays 表格视图控制器遵循协议

为了采用这个协议，Birthdays 表格视图控制器需要将自己定义为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中添加 AddBirthdayViewControllerDelegate，在 UITableViewController 超类之后。你只需要在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，一个红色错误就会出现。这是因为 BirthdaysTableViewController 表示它是一个 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了实现它，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快就会解决这个问题。

需要注意的是，BirthdaysTableViewController 是继承自 UITableViewController 超类的。一个类只能有一个超类，并且超类名称必须写在所有协议之前。但虽然一个类只能有一个超类，它可以采纳任意多个协议——这些协议会列在超类之后，并且用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:) 方法添加到 Birthdays TableViewController 中。一个好位置是将其添加到类的末尾，紧接着导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它预期你会添加这个方法。请注意，与子类化方法不同，在 addBirthdayViewController(_:didAddBirthday:) 方法前你不需要使用 override 关键字，因为没有原始方法需要被覆盖。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来完成这一点 ➋。接下来，你需要刷新表格视图，以便它显示这个新的生日，通过调用 tableView 属性上的 reloadData() 方法 ➌。当 reloadData() 被调用时，表格视图的数据源方法会再次被调用，新添加的生日将会显示在生日列表的底部。

你可能注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这并不是必须的，但标记类的不同部分是良好的编码风格，它有助于保持代码的整洁和可读性。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你找到方法并快速跳转到代码的不同位置。要使用这个菜单，请点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类内置了一个目录，方便快速跳转到某个章节。*

##### 给“添加生日”视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在，是时候让“添加生日”视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知 Birthdays 表视图控制器它已经添加了一个生日。为此，首先需要在 AddBirthdayViewController 类中定义一个代理。我们通过在 outlets 下面插入以下代码，为 AddBirthdayViewController 类添加一个可选的代理属性，类型为 AddBirthdayViewControllerDelegate：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你无法在*添加生日*视图控制器创建之前设置它。你将很快了解到在哪里设置代理。

现在，既然“添加生日”视图控制器有了代理，在 saveTapped(_:)方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:)方法将一个生日对象传递给代理。将 saveTapped(_:)方法修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)将其传递给代理。

太好了！你已经完成了对“添加生日”视图控制器的更改。它现在拥有一个代理，能够监听到生日保存的事件。运行应用程序看看会发生什么。

嗯……变化不大。当你添加一个生日时，仍然没有看到它显示在 Birthdays 表视图控制器中。这是怎么回事？

#### 通过设置代理连接两个控制器

你还有最后一件事需要做。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而“添加生日”视图控制器拥有一个 AddBirthdayViewControllerDelegate 类型的属性，持有它与之通信的代理，即在生日保存时与之交互的代理。但我们从未明确地将代理属性设置为 Birthdays 表视图控制器。所以，现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法 prepare(for:sender:)。通过删除/*和*/来取消注释该方法。

这个方法会在每当 Birthdays 表视图控制器放弃其屏幕并且应用程序通过 Storyboard segue 切换到另一个视图控制器时自动调用。我们将使用这个方法将 Birthdays 表视图控制器传递到 Add Birthday 视图控制器中，设置它作为 Add Birthday 视图控制器的委托。请在 prepare(for:sender:)方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码就能将 Add Birthday 视图控制器的委托设置为 Birthdays 表视图控制器。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 留了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，在此方法中正在准备 segue 的另一端，但对于这个应用程序，destination 并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到一个导航控制器中，这样你就可以拥有带有取消和保存按钮的导航栏。所以你不期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，destination 是一个包含 Add Birthday 视图控制器的 UINavigationController。➊处的代码可以让你获取 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，因此我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 只是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，所以需要将其强制转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的一个特定子类。最后，当你拥有一个 AddBirthdayViewController 时，你可以将委托设置为 self，即当前的 Birthdays 表视图控制器 ➌。

现在运行应用程序并添加一些生日！你在 Birthdays 表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完成。如果你退出应用程序然后再次运行，之前添加的生日会消失。我们还需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在这一章中，你学会了如何创建一个表视图控制器来显示你的生日列表。你还学会了如何在 Add Birthday 视图控制器中添加生日，然后如何使用委托将生日添加到 Birthdays 表视图控制器中的 birthday 数组中，以便它可以显示。

在第十二章中，你将学习如何将生日保存到设备中，以便即使退出应用程序并重新运行，生日仍然会显示。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

#### 在表格视图中显示生日

BirthdaysTableViewController 类有一个表格视图，用于显示单列的项目列表。表格视图有一个或多个节，每个节包含若干行，每行包含一个单元格。表格视图中的节是行的分组，可以有标题也可以没有标题。一个显示有多个节的表格视图的应用示例是设置应用程序，如图 11-5 所示。它显示了一个将行拆分为不同节的列表。

表格视图中的每个节和行都有一个索引号来标识。这些编号从 0 开始，向下递增。例如，设置应用中的隐私行位于第零部分，第 1 行。新闻设置位于第一部分，第 3 行。

在 BirthdaysTableViewController 类的中间，有一个叫做 *表格视图数据源* 的部分，包含三个方法。表格视图控制器使用这些方法来确定在表格视图中显示的内容。

numberOfSections(in:) 告诉表格视图应该有多少个节

tableView(_:numberOfRowsInSection:) 告诉表格视图每个节中将显示多少行

tableView(_:cellForRowAt:) 设置将要显示在表格视图每一行中的每个单元格

![](img/Image00243.jpg)

*图 11-5：设置应用程序使用节来分组不同设备设置的行。*

表格视图数据源方法在每次表格视图重新加载时都会被表格视图控制器调用。当你创建 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现这三个方法，以便应用程序正常工作，尽管你不会在代码中直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，后者包含这些数据源方法，用于确定表格视图中将显示的内容。我们将在“委托”一章的第 166 页讨论协议。现在，你只需要知道，UITableViewController 使用这些方法来显示它的内容，并且它会自动调用这些方法，所以你不需要显式地调用它们。

让我们从方法 numberOfSections(in:) 开始。Birthdays 表格视图控制器是一个只显示生日实例的列表，因此它不需要多个节。为了设置表格视图中的节数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为`tableView`的 UITableView 作为参数，这是一个使用此类作为数据源的表视图。我们不需要担心建立这个连接，因为`UITableViewController`自带一个内置的表视图，自动与这些方法连接。每个生日都会显示在自己的行中。所以，在`tableView(_:numberOfRowsInSection:)`方法中，为了正确显示所有生日的行数，你需要返回`birthdays`数组中`Birthday`实例的数量。你记得数组的`count`属性吗？它是一个整数，告诉你数组中有多少项，它非常适合这个情况！将这个方法更改为如下：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了`tableView`参数，`tableView(_:numberOfRowsInSection:)`方法还接受一个名为`section`的`Int`。当表视图正在加载时，这个方法会为表视图中的每个部分调用。在我们的例子中，我们只有一个部分，所以我们不需要担心检查显示的是哪个部分。我们知道它是部分 0，并且我们希望它有和生日数量一样多的行，因此我们写`return birthdays.count`。

最后，你需要实现`tableView(_:cellForRowAt:)`，这样表视图就知道在每个单元格中放置什么内容。由于这个方法被注释掉了，你需要通过删除包围它的`/*`和`*/`来取消注释它。（小心不要不小心取消注释它之后的其他方法！）完成后，将其更改为如下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法`tableView(_:cellForRowAt:)`。它是在表视图加载到屏幕上时被调用的。它会为屏幕上的每个单元格调用，并接受两个参数，`tableView`和`indexPath`。你已经知道`tableView`参数的用途。`IndexPath`是一个 Swift 结构体，用来表示表视图中某一行的位置。一个`IndexPath`实例有一个`section`属性和一个`row`属性。由于这个方法会被多次调用（每一行都会调用一次），我们需要`indexPath`来知道当前正在配置的是哪个部分和哪一行。`indexPath.section`属性给出部分号，`indexPath.row`给出表视图单元格的行号。`tableView(_:cellForRowAt:)`方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个`UITableViewCell`

• 找出将要在单元格中显示的`birthdays`数组中的`Birthday`

• 创建两个标签以显示生日人的名字和出生日期

• 返回准备好在表视图中显示的单元格

让我们逐行分析这段代码。

首先，创建`UITableViewCell`。代码➊通过`dequeueReusableCell(withIdentifier:for:)`方法实现了这一点。不过，在你开始使用此方法之前，你需要告诉方法你要从故事板中使用哪个单元格。早些时候，当你在故事板中时，你为单元格设置了标识符`birthdayCellIdentifier`（见图 11-4）。这个标识符将你的代码与单元格连接起来，并告诉你的方法它正在使用正确的单元格。当你调用这个方法时，字符串必须与你在故事板中设置的字符串完全相同，否则会报错并且应用程序在运行时崩溃。

在方法`dequeueReusableCell(withIdentifier:for:)`中，你有没有注意到*Reusable Cell*这几个词？表格视图中的单元格只会创建一次，然后可以反复使用。这帮助一切运行得更快更流畅，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，滚出屏幕顶部的单元格会被重复使用。它们会填充新信息，并再次出现在屏幕底部。UITableView 会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)`会为每一行可见的单元格调用。用户滚动查看更多单元格时，它会在每个即将出现在屏幕上的行上再次调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们想要在每一行显示`birthdays`数组中的一个生日。第一个生日（位于`birthdays[0]`）应该显示在第 0 行，第二个生日（位于`birthdays[1]`）应该显示在第 1 行，以此类推，这意味着`indexPath`的`row`与我们想要访问的`birthdays`数组中的位置相同。代码➋通过使用`indexPath.row`从`birthdays`数组中访问正确的生日对象。一旦我们得到了正确的生日对象，就将其赋值给名为`birthday`的常量，以便我们可以设置这个单元格中的标签。

请注意，我们使用`let`将生日赋值给常量，而不是变量。我们可以使用`let`，因为每次调用`tableView(_:cellForRowAt:)`时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并且每个常量会被分配给自己的生日对象。由于我们不会改变任何生日常量——我们只是读取它们的属性——所以不需要将它们设置为变量。

现在你已经有了单元格和生日，接下来就是填写详细信息了。你需要为每个单元格创建两个标签，分别显示生日人的名字和出生日期。你将单元格设置为副标题样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，因此你不需要自己创建标签了。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。在➌的代码中，将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格分开。在➍，你使用 dateFormatter 的 string(from:)方法将生日日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:)会返回这个单元格，以便它可以在表视图的那个 indexPath 位置显示出来。

### 整合所有内容

现在，你可以通过添加生日视图控制器将生日实例添加到应用中，并且你有一个表视图来列出每个生日，显示在生日表视图控制器中。但是，当你尝试运行应用并添加生日时，它并没有出现。为了让每个你添加的生日都能显示在表视图中，你需要让添加生日视图控制器与生日表视图控制器进行通信。你可以通过使用*委托模式*来实现这一点。

#### 委托模式

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托模式。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建 B，并将 B 显示在自己之上。A 知道 B，因为它创建并呈现了 B，因此 A 可以将信息传递给 B。但是 B 并不知道 A——它刚刚被创建出来，不知道自己是从哪里来的，也不清楚如何到达那里。那么，B 如何与 A 沟通呢？通过委托！

![](img/Image00245.jpg)

委托模式是指某人将工作或任务交给其他人去做。一个*委托对象*就像一个老板，告诉委托员工做什么。当委托员工完成任务时，有时它们会向委托老板报告信息。

Swift 中的委托模式非常类似，但我们不再有老板和员工，而是有委托对象和委托者对象。由于 B 类是被 A 类指示去做事情的对象，它就是委托者对象。我们给 B 类一个特殊的属性，叫做 delegate，用来告诉它谁是它的委托对象——这样，B 类就知道该与谁进行沟通。委托对象可以是任何一个符合*协议*要求的类。协议就像是两个类之间的约定，告诉它们委托对象可以要求委托者对象做些什么。协议包含了委托对象可以在委托者对象上使用的一系列方法和属性名。

A 类创建 B 类，将自己设置为 B 类的委托对象，并给 B 类分配一个任务，这个任务是在协议中定义的。一旦 B 类完成任务，它会向 A 类报告。让我们看看这个在我们的应用中是如何工作的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法由添加生日视图控制器用于回报信息。

看一下 图 11-6。当用户点击添加按钮 ➊ 时，Birthdays 表格视图控制器创建 Add Birthday 视图控制器 ➋ 并将自己设置为 Add Birthday 视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为有一个方法，`addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存 ➌ 时，Add Birthday 视图控制器调用此方法 ➍ 并将新生日传递给其委托，即 Birthdays 表格视图控制器。Birthdays 表格视图控制器接收该生日，将其添加到生日数组中，然后重新加载其表格视图 ➎，以便新的生日出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并包含 `addBirthdayViewController(_:didAddBirthday:)` 方法，这样每当向应用中添加一个生日时，Add Birthday 视图控制器就可以调用该方法。Birthdays 表格视图控制器将实现该协议方法，这样每当通过 Add Birthday 视图控制器添加一个生日时，Add Birthday 视图控制器只需对其委托说：“嘿！有人刚刚添加了这个生日，”而 Birthdays 表格视图控制器会听到这个消息，并说：“哦！我会将其添加到我的列表中，并刷新我的显示，让新生日出现在其中。”

现在，让我们在代码中实现这一点！

##### 创建一个协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，*在* AddBirthdayViewController 类之前，添加定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处通过输入关键字 `protocol` 后跟协议名 `AddBirthdayViewControllerDelegate` 来定义协议。这个名字比较长，但 Swift 程序员通常会以调用类的名称命名协议，并在后面加上“Delegate”这个词。这样你就可以通过协议的名字看到是哪个类在使用该协议。既然你现在是 Swift 程序员，应该遵循相同的命名惯例。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)` 是唯一的函数，它用于将 Birthday 对象传递回委托类 ➋。请注意，你在这个函数中包含了 AddBirthdayViewController 作为参数。再次强调，Swift 程序员在实现协议方法时会遵循这一惯例，因此你也应该遵循这一做法。知道是谁发送回了消息以及委托类能访问到该对象及其类，是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为 `addBirthdayViewController` 参数传递过来。你很快就会看到如何做到这一点。另一个需要注意的是外部参数名称 `didAddBirthday`。许多委托协议方法都包含 *did* 和 *will*，因为它们用来描述调用类刚刚做了或者将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays Table View Controller 去遵循这个协议并使用协议的方法。

##### 让 Birthdays Table View Controller 遵循协议

为了采用这个协议，Birthdays Table View Controller 需要使自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中，在 UITableViewController 父类之后添加 AddBirthdayViewControllerDelegate。你需要在类的顶部，在 UITableViewController 后加上一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做了，错误信息就会出现。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心，我们很快就会解决这个问题。

这里需要特别注意的是，BirthdaysTableViewController 是 UITableViewController 类的子类。一个类只能有一个父类，而且这个父类的名字必须写在任何协议之前。但尽管一个类只能有一个父类，它可以采用任意多个协议——这些协议都会在父类之后列出，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 `addBirthdayViewController(_:didAddBirthday:)` 方法。一个合适的添加位置是在类的末尾，就在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 自动完成功能会建议这个完整的方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它期待你添加这个方法。请注意，与子类化的方法不同，在 `addBirthdayViewController(_:didAddBirthday:)` 前你不需要使用 `override` 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 `append(_:)` 方法来实现这一点 ➋。接下来，你需要刷新表格视图，以便显示这个新的生日，方法是调用 tableView 属性的 `reloadData()` 方法 ➌。当调用 `reloadData()` 时，表格视图的数据源方法会被重新调用，新的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必需的，但良好的编码风格是标记类的不同部分，这有助于保持代码清晰可读。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，它会将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单帮助你找到方法，并让你跳转到代码的不同位置。要使用这个菜单，点击编辑面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器指定一个委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表视图控制器它何时添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 outlets 下面插入以下行，为 AddBirthdayViewController 类添加一个可选的委托属性，类型为 AddBirthdayViewControllerDelegate：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在 Add Birthday 视图控制器创建之前，不能设置委托。你很快就会知道在哪里设置委托。

现在 Add Birthday 视图控制器有了一个委托，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将生日传递给委托。将 saveTapped(_:) 改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊ 处的代码将其通过 addBirthdayViewController(_:didAddBirthday:) 方法传回给委托。

很棒！你已经完成了对 Add Birthday 视图控制器的更改。现在它有了一个委托，能够监听生日保存的调用。运行应用程序看看会发生什么。

嗯……似乎没有太大变化。当你添加生日时，仍然看不到它在 Birthdays 表视图控制器中显示出来。是怎么回事？

#### 通过设置委托连接两个控制器

还有一件事需要做。Birthdays 表视图控制器是 AddBirthdayViewControllerDelegate，Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存了当生日被保存时与之通信的委托。但我们从未明确将委托属性设置为 Birthdays 表视图控制器。所以，现在是时候连接这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除/*和*/来取消该方法的注释。

当 Birthdays 表格视图控制器放弃其屏幕并且应用程序通过 storyboard segue 过渡到另一个视图控制器时，这个方法会自动被调用。我们将利用这个方法将 Birthdays 表格视图控制器传递给添加生日视图控制器，并将其设置为添加生日视图控制器的委托。在 prepare(for:sender:)方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码就能将添加生日视图控制器的委托设置为 Birthdays 表格视图控制器。首先，你需要能够通过 segue 参数访问 AddBirthdayViewController 对象。Xcode 在注释中提供了提示，告诉你如何做到这一点。UIStoryboardSegue 在 segue 的另一端有一个叫做 destination 的属性，但对于这个应用程序而言，目标不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。因此，你不会期待在 segue 的另一端找到添加生日视图控制器。而是，目标是一个包含添加生日视图控制器的 UINavigationController。➊的那一行让你得到了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其强制转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的一个特定子类。最后，当你得到一个 AddBirthdayViewController 时，可以将委托设置为 self，当前是 Birthdays 表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在 Birthdays 表格视图控制器中看到什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序再重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，我们将在第十二章中完成这项工作。

### 你学到了什么

在本章中，你学会了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，并且如何通过委托将生日添加到 Birthdays 表格视图控制器中的 birthday 数组中，以便可以显示出来。

在第十二章中，你将学习如何将生日保存到设备中，以便即使退出应用程序并重新运行，它们仍然会显示。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

BirthdaysTableViewController 类有一个表格视图，用于在单列中显示项目列表。表格视图有一个或多个部分，其中包含行，每一行包含一个单元格。表格视图中的部分是一个行的分组，可以选择性地显示或不显示标题。一个显示多个部分的表格视图应用示例是设置应用，如图 11-5 所示。它显示了一系列已经分成不同部分的行。

表格视图中的每个部分和行都有一个索引编号。这些编号从 0 开始，向下递增。例如，在设置应用中，隐私行位于部分 0，行 1。新闻设置位于部分 1，行 3。

在 BirthdaysTableViewController 类的中间，有一个名为*表格视图数据源*的部分，包含三个方法。表格视图控制器使用这些方法来确定其表格视图中将显示什么内容。

numberOfSections(in:) 告诉表格视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表格视图每个部分将显示多少行

tableView(_:cellForRowAt:) 设置每个将要显示在表格视图每一行中的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用程序使用部分来分组不同设备设置的行。*

表格视图的数据源方法在每次表格视图重新加载时都会被表格视图控制器调用。当你创建一个 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。为了使应用程序正常工作，你需要实现这三个方法，尽管你在代码中不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用于确定表格视图中将显示什么内容。我们将在“代理”一节中讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，所以你不需要手动调用它们。

我们从方法 numberOfSections(in:)开始。生日表格视图控制器是一个只显示生日实例的列表，因此它不需要多个部分。为了设置表格视图中的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

此方法接受一个名为 tableView 的 UITableView 参数，这是使用此类作为数据源的表格视图。我们不需要担心建立此连接，因为 UITableViewController 已经内置了一个表格视图，并且会自动与这些方法连接。每个生日都会显示在自己的行中。因此，在 tableView(_:numberOfRowsInSection:) 中，为了拥有正确数量的行来显示所有的生日，你需要返回 birthdays 数组中 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少个项目，非常适合这个情况！将此方法修改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，tableView(_:numberOfRowsInSection:) 还接受一个名为 section 的 Int 类型参数。当表格视图加载时，此方法会为表格视图中的每个部分被调用。在我们的例子中，只有一个部分，所以我们不需要费心检查表格视图正在显示的是哪个部分。我们知道它是第零部分，并且我们希望它有与生日数量相等的行数，因此我们写下返回 birthdays.count 。

最后，你需要实现 tableView(_:cellForRowAt:) 方法，以便表格视图知道每个单元格中应该放置什么内容。由于此方法已被注释掉，你需要通过删除 /* 和 */ 来取消注释它。（小心不要不小心取消注释之后的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会调用方法 tableView(_:cellForRowAt:) 。它会在表格视图加载到屏幕时被调用。每个屏幕上的单元格都会调用此方法，并且有两个参数，tableView 和 indexPath 。你已经知道 tableView 参数的作用。IndexPath 是一个 Swift 结构体，用于表示表格视图中某一行的位置。IndexPath 实例有一个 section 属性和一个 row 属性。由于此方法会被多次调用（每个表格行调用一次），我们需要 indexPath 来了解当前正在配置的是哪个部分和哪一行。indexPath.section 属性提供了部分号，而 indexPath.row 提供了表格视图单元格的行号。tableView(_:cellForRowAt:) 中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 找出哪个 Birthday 实例将在单元格中显示

• 创建两个标签来显示生日人物的姓名和出生日期

• 返回一个准备好显示在表格视图中的单元格

让我们逐行查看这段代码。

首先，创建 UITableViewCell。在➊的代码中，使用方法 dequeueReusableCell(withIdentifier:for:)来实现这一点。然而，在你可以在单元格上使用这个方法之前，你需要告诉这个方法你想使用哪个单元格来自 storyboard。之前，当你在 storyboard 中时，你给单元格设置了标识符 birthdayCellIdentifier（见图 11-4）。这个标识符将你的代码与单元格连接，并告诉你的方法它正在使用正确的单元格。你在调用这个方法时使用的字符串需要与在 storyboard 中设置的字符串完全一致，否则会出现错误，应用运行时会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:)中，你注意到*可重用单元格*这几个字了吗？表格视图中的单元格只会创建一次，然后可以反复使用。这有助于提高运行速度和流畅度，因为创建单元格是最耗时的。如果你的应用中有 200 个生日，但一次只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动显示更多生日时，滚出屏幕顶部的单元格会被重用。它们会被填充新信息，并在屏幕底部重新显示。UITableView 会自动完成这些工作。当表格视图加载时，tableView(_:cellForRowAt:)会为每个可见的行被调用。当用户滚动查看更多单元格时，它会再次为每个即将出现在屏幕上的行调用。

接下来，我们需要找出应该显示在单元格中的生日。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日，位于 birthdays[0]，应该显示在第 0 行。第二个生日，位于 birthdays[1]，应该显示在第 1 行，依此类推，这意味着 indexPath 的行数与我们想要访问的 birthdays 数组中的位置相同。在➋的代码中，通过使用 indexPath.row，访问了 birthdays 数组中的正确 Birthday 对象。一旦我们获得了正确的 Birthday 对象，我们将其赋值给名为 birthday 的常量，这样我们就可以设置该单元格中的标签了。

请注意，我们使用 let 将生日赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都会有自己的生日常量，并分配给自己的 Birthday 对象。由于我们不打算修改任何生日常量——我们只是读取它们的属性——所以不需要将它们设置为变量。

现在你已经有了单元格和生日，接下来是填写详细信息。你需要为每个单元格设置两个标签，以显示生日人的姓名和出生日期。你将单元格设置为副标题样式，这样它就有了标题标签和副标题标签。每个单元格已经包含了这些标签，所以现在你不需要自己创建任何标签。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。代码 ➌ 设置了 textLabel 的文本为一个由生日的 firstName 和 lastName 组成的字符串，中间用一个空格分隔。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 会返回 ➎ 处的单元格，以便它可以在该索引路径的位置显示在表格视图中。

### 整合所有内容

现在，你可以通过添加生日视图控制器向应用中添加生日实例，并且你有一个表格视图来列出每个生日，展示在生日表格视图控制器中。但是，当你尝试运行应用并添加一个生日时，它并没有显示。为了让你添加的每个生日都能显示在表格视图中，你需要让添加生日视图控制器与生日表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。例如，你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 展示在自己之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它只是突然出现的，并不知道它从哪里来，也不知道怎么到达这里。那么，B 怎么与 A 进行沟通呢？通过委托！

![](img/Image00245.jpg)

委托（Delegation）是指有人将工作或任务交给另一个人处理。一个*委托人*就像一个老板，告诉被委托的员工该做什么。当被委托的员工完成任务后，有时他们会向委托人报告信息。

在 Swift 中，委托与此类似，但我们不再有老板和员工，而是有委托人和委托对象。由于类 B 是被类 A 告诉要做什么的对象，因此它是委托对象。我们为类 B 定义一个特殊属性，称为 delegate，用来告诉它它的委托人是谁——这样，它就知道与谁进行通信。委托人可以是任何拥有已定义方法集的类，这些方法集定义在一个*协议*中。协议就像是两个类之间的协议，告诉它们委托人可以要求委托对象做什么。协议包含了委托人可以在委托对象上使用的方法和属性的名称。

类 A 创建类 B，将自己设为类 B 的委托人，并给类 B 分配一个任务，该任务已在协议中定义。当类 B 完成任务后，它会向类 A 报告。让我们来看一下在我们的应用中如何实现这一点。

生日表格视图控制器是视图控制器 A，而添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用来报告信息。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表格视图控制器会创建“添加生日”视图控制器 ➋，并将自己设置为“添加生日”视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从“添加生日”视图控制器传递到“生日”表格视图控制器。*

AddBirthdayViewControllerDelegate 协议定义了一个方法：`addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存 ➌ 时，“添加生日”视图控制器会调用这个方法 ➍，并将新的生日传递给它的委托——生日表格视图控制器。生日表格视图控制器接收到这个生日后，将其添加到它的生日数组中，然后重新加载表格视图 ➎，这样新的生日就会显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并通过方法`addBirthdayViewController(_:didAddBirthday:)`让“添加生日”视图控制器在每次添加生日时调用。生日表格视图控制器将实现这个协议方法，这样每次通过“添加生日”视图控制器添加生日时，AddBirthdayViewController 就可以告诉它的委托：“嘿！有人刚刚添加了这个生日。” 然后，生日表格视图控制器会接收到这个消息并说：“哦！我会把它添加到我的列表中，并刷新我的显示，让新的生日显示出来。”

现在我们来看看如何在代码中实现这一过程！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，*在* AddBirthdayViewController 类上方，添加如下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 定义协议时，通过输入关键字`protocol`，后面跟上协议名称 AddBirthdayViewControllerDelegate。这个名字虽然比较长，但 Swift 程序员通常会用调用类的名称来命名协议，并在后面加上“Delegate”一词。这样，你就能通过协议的名称知道是哪个类在使用该协议。既然你现在是一个 Swift 程序员，你也应该使用相同的命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)`是唯一的函数，用来将 Birthday 对象传递回委托类 ➋。注意，在这个函数中你将 AddBirthdayViewController 作为参数包含进去。再次强调，Swift 程序员通常在实现协议方法时按照约定这样做，所以你也应该遵循这一做法。这有助于知道是谁发送了消息，并且让委托能够访问该对象及其类。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递。你将很快看到如何实现这一点。另一个需要注意的地方是外部参数名 didAddBirthday。许多代理协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚做过的事情或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays table view controller 采用这个协议并使用该协议的方法。

##### 让 Birthdays Table View Controller 遵守协议

为了采用该协议，Birthdays table view controller 需要使自己成为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中紧接 UITableViewController 超类之后添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你完成这个操作，红色错误提示就会出现。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了解决这个问题，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心，我们很快就会修复这个问题。

在这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，而且该超类的名称必须写在任何协议之前。但是，尽管一个类只能有一个超类，它可以采用任意多个协议——这些协议会列在超类之后，并用逗号分隔。

现在，为了遵守 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的位置是类的末尾，在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 的自动完成功能会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它预期你会添加这个方法。需要注意的是，与子类化方法不同，addBirthdayViewController(_:didAddBirthday:) 方法前不需要使用 override 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的 Birthday 添加到 birthdays 数组中。你可以使用数组的 append(_:) 方法 ➋ 来实现。接下来，你需要刷新表格视图，以便它能显示这个新的生日，通过在 tableView 属性上调用 reloadData() 方法 ➌ 来实现。当调用 reloadData() 时，表格视图的数据源方法将被重新调用，新的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必须的，但标记你类中的不同部分是一个良好的编码风格，有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的一个特殊关键字，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用该菜单。这个下拉菜单帮助你快速找到方法并跳转到代码中的不同位置。要使用这个菜单，点击编辑器窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类内建了一个目录，方便快速跳转到某一部分。*

##### 为 Add Birthday 视图控制器设置代理

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来通知 Birthdays 表视图控制器何时添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类的 outlets 下面插入以下行，来为它添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在 Add Birthday 视图控制器创建之前，你不能设置它。稍后你将学习在哪里设置代理。

现在，Add Birthday 视图控制器有了代理，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将一个 Birthday 传递给代理。将 saveTapped(_:) 修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象后，代码 ➊ 使用 addBirthdayViewController(_:didAddBirthday:) 方法将其传回给代理。

太好了！你已经完成了对 Add Birthday 视图控制器的修改。现在它有了一个代理，可以监听生日已保存的调用。运行应用程序，看看会发生什么。

嗯……似乎变化不大。当你添加一个生日时，你仍然看不到它在 Birthdays 表视图控制器中显示。怎么回事？

#### 通过设置代理连接两个控制器

你需要做最后一件事。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存与其通信的代理，用于在生日保存时进行通知。但我们从未专门将代理属性设置为 Birthdays 表视图控制器。所以，现在是时候在两个视图控制器之间连接通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。删除它两边的 /* 和 */，取消注释这个方法。

每当 Birthdays 表格视图控制器交出它的屏幕并且应用通过 storyboard segue 切换到另一个视图控制器时，这个方法会被自动调用。我们将使用这个方法将 Birthdays 表格视图控制器传递给 Add Birthday 视图控制器，设置它为 Add Birthday 视图控制器的委托。在 prepare(for:sender:) 方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的委托到 Birthdays 表格视图控制器只需要三行代码。首先，你需要能够通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 留下了一条注释，提示你如何做到这一点。一个 UIStoryboardSegue 在方法中被准备时有一个名为 destination 的属性，但这个 app 的目标视图控制器并不是 AddBirthdayViewController。

在第九章，你将 Add Birthday 视图控制器嵌入到一个导航控制器中，以便能够拥有带有取消和保存按钮的导航栏。因此，你不会期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊ 这一行代码让你获得了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其强制转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 时，你可以将委托设置为 self，当前是 Birthdays 表格视图控制器 ➌。

现在运行应用并添加一些生日！你在 Birthdays 表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完成。如果你退出应用再重新启动，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章 中完成。

### 你学到了什么

在这一章中，你学习了如何制作一个表格视图控制器来展示你的生日列表。你还学习了如何在 Add Birthday 视图控制器中添加一个生日，然后如何使用委托将生日添加到 Birthdays 表格视图控制器的 birthdays 数组中，以便可以展示它。

在 第十二章 中，你将学习如何将生日保存到设备上，这样即使你退出应用并重新运行，它们也会显示出来。为了保存生日，你将使用我们在项目一开始就设置好的 Core Data。

表视图的每个章节和行都有一个索引号来标识。这些数字从 0 开始，随着你向下滚动表视图，数字逐渐增加。例如，设置应用中的隐私行位于第零章节，第 1 行；新闻设置位于第一章节，第 3 行。

在 `BirthdaysTableViewController` 类的中间，有一个名为 *Table view data source* 的部分，包含三个方法。表视图控制器使用这些方法来确定将要在其表视图中显示的内容。

`numberOfSections(in:)` 告诉表视图应该有多少个章节。

`tableView(_:numberOfRowsInSection:)` 告诉表视图在每个章节中将显示多少行。

`tableView(_:cellForRowAt:)` 设置每一行在表视图中将显示的单元格。

![](img/Image00243.jpg)

*图 11-5：设置应用通过使用章节将不同设备设置的行分组。*

每当表视图重新加载时，表视图控制器都会调用表视图数据源方法。Xcode 会在你创建 `UITableViewController` 的子类时自动为你生成这些方法模板。即使你在代码中不会直接调用它们，你仍然需要实现所有三个方法才能让应用正常工作。`UITableViewController` 类实现了 `UITableViewDataSource` 协议，该协议包含这些数据源方法，用来确定表视图中将显示的内容。我们将在 “委托” 一节的第 166 页讨论协议。现在，你只需要知道 `UITableViewController` 使用这些方法来显示内容，并且它会自动调用这些方法，因此你不需要自己去调用它们。

让我们从 `numberOfSections(in:)` 方法开始。`Birthdays` 表视图控制器是一个只显示生日实例的列表，因此不需要多个章节。为了设置表视图的章节数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 `tableView` 的 `UITableView` 参数，表示使用该类作为数据源的表视图。我们不需要担心建立这种连接，因为 `UITableViewController` 已经带有一个内置的表视图，并且自动连接到这些方法。每个生日将显示在自己的行中。因此，在 `tableView(_:numberOfRowsInSection:)` 方法中，为了确保你的生日数量正确，你需要返回 `birthdays` 数组中 `Birthday` 实例的数量。你记得数组的 `count` 属性吗？它是一个整数，表示数组中有多少项，非常适合这种情况！将该方法修改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 `tableView` 参数外，`tableView(_:numberOfRowsInSection:)` 还接受一个名为 `section` 的 `Int` 类型的参数。当表视图加载时，这个方法会为每个表视图的部分调用。在我们的案例中，只有一个部分，因此我们不需要担心检查哪个部分的表视图正在显示。我们知道它是第零部分，并且我们希望它的行数与生日的数量相同，因此我们写 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)`，这样表视图才知道在每个单元格中放置什么内容。由于这个方法被注释掉了，你需要通过删除包围它的 `/*` 和 `*/` 来取消注释。（小心不要不小心取消注释它后面的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用 `tableView(_:cellForRowAt:)` 方法。它会在表视图加载到屏幕上时自动调用。它会为屏幕上的每个单元格调用，并接受两个参数：`tableView` 和 `indexPath`。你已经知道 `tableView` 参数的作用。`IndexPath` 是一个 Swift 结构体，用于表示表视图中某一行的位置。`IndexPath` 实例有 `section` 属性和 `row` 属性。由于这个方法会被多次调用（每个表视图行调用一次），我们需要 `indexPath` 来知道当前配置的是哪个部分和哪一行。`indexPath.section` 属性给出部分编号，`indexPath.row` 给出表视图单元格的行号。`tableView(_:cellForRowAt:)` 中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 `UITableViewCell`

• 确定 `birthdays` 数组中哪个生日将在单元格中显示

• 创建两个标签来在单元格中显示生日人物的姓名和出生日期

• 返回准备好显示在表视图中的单元格

让我们逐行分析这段代码。

首先，创建 `UITableViewCell`。第 ➊ 行代码使用 `dequeueReusableCell(withIdentifier:for:)` 方法来实现这一点。然而，在开始使用该方法之前，你需要告诉它你想要从 storyboard 中使用哪个单元格。之前，当你在 storyboard 中时，你给单元格指定了标识符 `birthdayCellIdentifier`（参见 图 11-4）。这个标识符将你的代码与单元格关联起来，并告诉你的方法你正在使用正确的单元格。当你调用这个方法时，字符串必须与在 storyboard 中设置的字符串完全相同，否则你会遇到错误，并且在运行应用时应用会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:) 中，你注意到*可重用单元格*这几个字了吗？表视图中的单元格只会创建一次，然后可以反复重用。这有助于提高运行速度和流畅度，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以查看更多生日时，滚出屏幕顶部的单元格会被重新使用。它们会被填充新信息，并再次出现在屏幕底部。UITableView 会自动完成这项工作。当表视图加载时，tableView(_:cellForRowAt:) 会为每个可见行调用一次。当用户滚动以查看更多单元格时，每当行即将出现在屏幕上时，它会再次被调用。

接下来，我们需要找出应该在单元格内显示哪个生日。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日，即 birthdays[0] ，应该显示在第 0 行。第二个生日，即 birthdays[1] ，应该显示在第 1 行，依此类推，这意味着 indexPath 的 row 和我们想要访问的 birthdays 数组中的位置是相同的。➋ 处的代码通过使用 indexPath.row 访问 birthdays 数组中的正确 Birthday 对象。一旦获得正确的 Birthday 对象，我们将其赋值给名为 birthday 的常量，以便设置该单元格中的标签。

请注意，我们使用 let 将生日赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并且赋予它自己的 Birthday 对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以我们不需要将它们声明为变量。

现在你已经有了单元格和生日信息，接下来是填充详细信息。你需要为每个单元格准备两个标签，分别显示生日人员的姓名和出生日期。你将单元格设置为 Subtitle 样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，所以现在你不需要自己创建任何标签。

这些标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，二者之间有一个空格。➍ 处，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当单元格完全配置好后，tableView(_:cellForRowAt:) 在 ➎ 处返回该单元格，以便在表视图的相应 indexPath 位置显示。

### 综合总结

现在，你可以使用添加生日视图控制器将生日实例添加到应用程序中，并在生日表格视图控制器中显示每个生日。但是，当你尝试运行应用并添加生日时，生日并没有显示出来。为了让你添加的每个生日在表格视图中显示，你需要让添加生日视图控制器与生日表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己的上方。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 不知道 A——它刚刚被创建，并不知道自己来自哪里，也不知道是如何到达这里的。那么，B 怎么与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项工作或任务交给别人。*委托人*就像是一个老板，告诉被委托的员工该做什么。当被委托的员工完成任务时，有时他们会将信息反馈给委托人老板。

Swift 中的委托非常相似，但不是有老板和员工，而是有委托对象和被委托对象。由于类 B 是被类 A 告知该做什么的对象，因此它是被委托对象。我们给类 B 一个特殊的属性叫做委托(delegate)，用来告诉它谁是它的委托——这样，它就知道该与谁通信。委托可以是任何符合*协议*中方法定义的类。协议就像是两个类之间的约定，告诉它们委托可以要求被委托对象做什么。它列出了委托可以在与被委托对象交互时使用的方法和属性名。

类 A 创建类 B，使自己成为类 B 的委托，并为类 B 设定一个协议中的任务。一旦类 B 完成任务，它会向类 A 汇报。让我们看看这个在我们的应用程序中是如何工作的。

生日表格视图控制器是视图控制器 A，而添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议定义一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用来反馈结果。

看看图 11-6。当用户点击添加按钮 ➊ 时，生日表格视图控制器会创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日通过委托从添加生日视图控制器传递到生日表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，添加生日视图控制器会调用此方法 ➍ 并将新的生日信息传递给它的代理，即生日表格视图控制器。生日表格视图控制器接收到这个生日信息后，将其添加到自己的生日数组中，然后重新加载表格视图 ➎，这样新生日就会出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并使用方法 addBirthdayViewController(_:didAddBirthday:)，这样当向应用程序添加生日时，添加生日视图控制器就能调用该方法。生日表格视图控制器将实现该协议方法，这样每当通过添加生日视图控制器添加一个生日时，添加生日视图控制器就可以告诉其代理：“嘿！有人刚刚添加了这个生日”，生日表格视图控制器会接收到这个消息，并说：“哦！我会将它添加到我的列表中，并刷新显示，以便新生日能够显示出来。”

那么现在让我们在代码中实现吧！

##### 创建协议

首先，我们需要创建这个协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类 *上方*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你可以通过在 ➊ 输入关键字 `protocol`，然后跟上协议名 AddBirthdayViewControllerDelegate 来定义协议。这个名字比较长，但 Swift 程序员通常会根据调用类的名称命名协议，并在末尾加上 "Delegate"。这样，通过查看协议的名称，你就能知道哪个类在使用这个协议。既然你现在是 Swift 程序员，你也应该遵循同样的命名规范。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传回给代理类 ➋。请注意，你在这个函数中包含了 AddBirthdayViewController 作为参数。同样，Swift 程序员在实现协议方法时通常会这样做，因此你也应该遵循这个约定。这样做可以帮助你知道是谁发回了消息，并且代理可以访问这个对象及其类。

当添加生日视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递。你很快就会看到如何实现这一点。另一个需要注意的地方是外部参数名 didAddBirthday。许多代理协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚完成或将要做的事情。

现在你已经定义了协议，接下来需要告诉生日表格视图控制器采用这个协议，并使用协议的方法。

##### 使生日表格视图控制器遵循协议

为了采用这个协议，**Birthdays TableViewController**需要让自己成为**AddBirthdayViewControllerDelegate**。为此，你需要在类定义中，紧接着`UITableViewController`父类后添加`AddBirthdayViewControllerDelegate`。在类的顶部，在`UITableViewController`后添加一个逗号，然后输入`AddBirthdayViewControllerDelegate`：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，一个红色的错误就会出现。之所以会发生这种情况，是因为**BirthdaysTableViewController**说它是一个**AddBirthdayViewControllerDelegate**，但是它还没有实现这个协议！为了实现这一点，它需要实现**AddBirthdayViewControllerDelegate**协议的定义。别担心——我们很快就会修复这个问题。

这里需要特别注意的是，**BirthdaysTableViewController**是`UITableViewController`父类的子类。一个类只能有一个父类，且父类的名字必须写在任何协议之前。但是，虽然一个类只能有一个父类，但它可以采用任意多个协议——这些协议都会在父类之后列出，并由逗号分隔。

现在，为了符合**AddBirthdayViewControllerDelegate**协议并修复错误，我们需要在**Birthdays TableViewController**中添加`addBirthdayViewController(_:didAddBirthday:)`方法。一个好的添加位置是在类的末尾，紧跟在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 自动完成会建议整个方法声明。这是因为它知道这个类采用了**AddBirthdayViewControllerDelegate**协议，并且它期待你添加这个方法。请注意，不同于子类方法，你在`addBirthdayViewController(_:didAddBirthday:)`前不需要使用`override`关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将由**AddBirthdayViewController**传入的生日添加到`birthdays`数组中。你可以使用数组的`append(_:)`方法来实现这一点 ➋。接下来，你需要刷新表视图，使其显示这个新的生日，方法是调用`tableView`属性上的`reloadData()`方法 ➌。当`reloadData()`被调用时，表视图的数据源方法会再次被调用，新的生日将会显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但这是良好的编码风格，可以标记类的不同部分，并有助于保持代码清晰和易读。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键词，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你查找方法，并让你跳转到代码中的不同位置。要使用此菜单，请点击编辑器窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器指定委托

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性，并将以下代码插入到 outlets 下面来安排这件事：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是一个可选类型，因为直到*Add Birthday 视图控制器被创建后*你才能设置它。稍后你将学习如何设置委托。

现在 Add Birthday 视图控制器已经有了委托，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日对象传递给委托。将 saveTapped(_:) 方法修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，代码在 ➊ 通过 addBirthdayViewController(_:didAddBirthday:) 方法将其传回给委托。

很好！你已经完成了对 Add Birthday 视图控制器的修改。现在它有了一个委托，会监听生日保存的调用。运行应用程序看看会发生什么。

嗯……似乎没什么变化。当你添加一个生日时，它仍然没有在 Birthdays 表视图控制器中显示出来。怎么回事？

#### 通过设置委托连接这两个控制器

你还需要做最后一件事。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 类型的属性，用来保存它与之通讯的委托，当生日被保存时会调用这个委托。但我们从未明确地设置委托属性为 Birthdays 表视图控制器。所以现在是时候连接这两个视图控制器之间的通信管道了。

在 `BirthdaysTableViewController` 类的导航部分，有一个被注释掉的方法，名为 `prepare(for:sender:)`。请删除它前后的 `/*` 和 `*/`，取消注释该方法。

每当 `Birthdays` 表视图控制器放弃其屏幕，应用通过 `storyboard` `segue` 转场到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将 `Birthdays` 表视图控制器传递给“添加生日”视图控制器，进而设置它为“添加生日”视图控制器的委托。请在 `prepare(for:sender:)` 方法中写下如下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码，就可以将“添加生日”视图控制器的委托设置为 `Birthdays` 表视图控制器。首先，你需要能够通过 `segue` 参数访问到 `AddBirthdayViewController` 对象。Xcode 留下了一条注释，提示你如何做到这一点。`UIStoryboardSegue` 在该方法中准备的 `segue` 的另一端有一个叫做 `destination` 的属性，但本应用的 `destination` 不是 `AddBirthdayViewController`。

在第九章中，你将“添加生日”视图控制器嵌入到了一个导航控制器中，这样你就可以拥有带有取消和保存按钮的导航栏。因此，你不会期望在 `segue` 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 `UINavigationController`。➊ 处的代码获取到 `navigationController`。`segue.destination` 返回的是一个 `UIViewController`，但由于我们的 `navigationController` 是一个特定类型的视图控制器，我们需要使用 `as` 将其类型转换为 `UINavigationController`。

接下来，你可以通过 `navigationController` 获取到“添加生日”视图控制器，它是 `topViewController` ➋。`topViewController` 就是当前在 `navigationController` 中显示的视图控制器，但它的属性类型是 `UIViewController`，因此需要将其类型转换为 `AddBirthdayViewController`，以表示这个控制器是 `UIViewController` 的特定子类。最后，获得 `AddBirthdayViewController` 后，你可以将委托设置为 `self`，即当前的 `Birthdays` 表视图控制器 ➌。

现在运行应用并添加一些生日！你在 `Birthdays` 表视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用然后再次运行，之前添加的生日会消失。我们还需要将生日保存到设备中，下一步我们会在第十二章中完成这部分内容。

### 你学到了什么

在本章中，你学习了如何创建一个表视图控制器来展示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，然后如何使用委托将该生日添加到 `Birthdays` 表视图控制器中的生日数组中，以便展示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使退出应用程序并重新运行，它们也会显示出来。为了保存生日，你将使用 Core Data，这是我们在项目开始时设置的。

在`BirthdaysTableViewController`类的中间，有一个叫做*表格视图数据源*的部分，其中包含三个方法。表格视图控制器使用这些方法来确定将显示在表格视图中的内容。

numberOfSections(in:) 告诉表格视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表格视图在每个部分中将显示多少行

tableView(_:cellForRowAt:) 设置将显示在表格视图每一行中的每个单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分来分组不同设备设置的行。*

表格视图数据源方法每次表格视图重新加载时都会被表格视图控制器调用。当你创建`UITableViewController`的子类时，Xcode 会自动为你提供这些方法模板。你需要实现所有三个方法才能让应用程序正常工作，尽管你永远不会在代码中直接调用它们。`UITableViewController`类实现了`UITableViewDataSource`协议，该协议提供了这些数据源方法，用于确定在表格视图中显示什么内容。我们将在“代理”一节中讨论协议。现在，你只需要知道，`UITableViewController`使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要手动调用它们。

让我们从方法`numberOfSections(in:)`开始。`Birthdays`表格视图控制器是一个仅显示生日实例的列表，因此它不需要多个部分。为了设置表格视图中的部分数量，我们只需要返回`1`。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为`tableView`的`UITableView`作为参数，它是使用此类作为数据源的表格视图。我们无需担心建立此连接，因为`UITableViewController`自带一个内置的表格视图，并且自动与这些方法连接。每个生日将显示在自己的行中。所以在`tableView(_:numberOfRowsInSection:)`中，为了确保你拥有正确数量的行来显示所有的生日，你需要返回`birthdays`数组中`Birthday`实例的数量。你还记得数组的`count`属性吗？它是一个整数，告诉你数组中有多少项，非常适合这个情况！将这个方法改成以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，`tableView(_:numberOfRowsInSection:)` 方法还需要一个名为 section 的 `Int` 参数。当表视图加载时，这个方法会为表视图中的每个节（section）被调用。在我们的例子中，只有一个节，因此我们不需要检查当前显示的是哪个节。我们知道它是节 0，并且希望它有与生日数量相等的行数，所以我们写 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)` 方法，这样表视图就知道该在每个单元格中放置什么内容。由于这个方法被注释掉了，你需要通过删除包围它的 `/*` 和 `*/` 来取消注释。（小心不要不小心取消注释后面的其他方法！）完成之后，将其修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用 `tableView(_:cellForRowAt:)` 方法。它会在表视图加载到屏幕上时被自动调用。每当表视图的每个单元格需要显示时，都会调用这个方法，并且它有两个参数：tableView 和 indexPath。你已经知道 tableView 参数是干什么的了。IndexPath 是一个 Swift 结构体，用于表示表视图中某行的位置。一个 IndexPath 实例有 section 属性和 row 属性。由于这个方法会被多次调用（每次对应表视图中的一行），我们需要 indexPath 来知道我们当前正在配置哪个 section 和 row。indexPath.section 属性提供节（section）号，而 indexPath.row 提供表视图单元格所在的行号。`tableView(_:cellForRowAt:)` 方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定哪个生日对象会显示在单元格中

• 创建两个标签，在单元格中显示生日人的姓名和出生日期

• 返回准备好显示在表视图中的单元格

让我们逐行查看这段代码。

首先，创建 UITableViewCell。➊ 处的代码通过调用 `dequeueReusableCell(withIdentifier:for:)` 方法来实现这一点。不过，在你开始使用这个方法之前，你需要告诉它你想要使用哪个单元格，这个单元格是在 storyboard 中定义的。早些时候，当你在 storyboard 中时，你为单元格设置了标识符 `birthdayCellIdentifier`（参见 图 11-4）。这个标识符将你的代码与单元格关联起来，告诉方法它正在使用正确的单元格。你在调用这个方法时使用的字符串必须与在 storyboard 中设置的字符串完全相同，否则会报错并导致应用程序崩溃。

在方法 dequeueReusableCell(withIdentifier:for:)中，你有没有注意到*可重用单元格*这几个词？表格视图中的单元格是一次性创建的，然后可以重复使用。这有助于让一切运行得更快更流畅，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但是一次只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以查看更多生日时，滚出屏幕顶部的单元格会被重新使用。它们会被填充新信息，并再次出现在屏幕底部。UITableView 会自动完成这些工作。当表格视图加载时，tableView(_:cellForRowAt:)会为每一行调用一次。当用户滚动查看更多单元格时，每当即将显示在屏幕上时，它会再次为每一行调用。

接下来，我们需要找出哪个生日应该显示在单元格内。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日，位于 birthdays[0]，应该显示在第 0 行。第二个生日，位于 birthdays[1]，应该显示在第 1 行，以此类推，这意味着 indexPath 的行号与我们要访问的 birthdays 数组中的位置相同。在➋处的代码通过使用 indexPath.row 来访问 birthdays 数组中的正确 Birthday 对象。一旦我们得到了正确的 Birthday 对象，就将其分配给名为 birthday 的常量，以便我们可以设置该单元格中的标签。

请注意，我们使用 let 来为生日赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都会得到自己的生日常量，并为其分配一个独立的 Birthday 对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——因此我们不需要将它们设置为变量。

现在你已经有了单元格和生日信息，接下来就是填写详细内容。你需要为每个单元格设置两个标签，以显示生日人的姓名和出生日期。你将单元格设置为副标题样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，所以现在你不需要自己创建任何标签。

标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。在➌处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，二者之间用空格隔开。在➍处，你使用 dateFormatter 的 string(from:)方法，将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好时，tableView(_:cellForRowAt:)在➎处返回单元格，以便在该 indexPath 处显示。

### 整合所有内容

现在你可以通过添加生日视图控制器将生日实例添加到应用程序中，并且有一个表格视图来列出生日表格视图控制器中的每个生日。但是，当你尝试运行应用程序并添加一个生日时，它并不会显示。为了使你添加的每个生日都出现在表格视图中，你需要让添加生日视图控制器与生日表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 显示在自己之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 并不知道 A——它只是突然出现在这里，并不知道自己来自哪里或如何到达这里。那么 B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托就是某人将任务或工作交给别人做。一个*委托者*就像是一个老板，告诉一个委托员工该做什么。当委托员工完成任务时，有时他们会向委托老板报告信息。

在 Swift 中，委托非常相似，但不是有一个老板和一个员工，而是有一个委托者和一个委托对象。由于类 B 是由类 A 指示做什么的，它是委托对象。我们给类 B 一个特殊的属性，叫做 delegate，用来告诉它谁是它的委托者——这样它就知道应该与谁通信。委托者可以是任何一个拥有在*协议*中定义的一系列方法的类。协议就像是两个类之间的约定，告诉它们委托者可以要求委托对象做什么。它包含了委托者可以使用的与委托对象交互的方法和属性名称列表。

类 A 创建类 B，将自己设置为类 B 的委托，并给类 B 分配一个在协议中定义的任务。一旦类 B 完成任务，它会向类 A 报告。让我们看看这个在我们的应用中是如何运作的。

生日表格视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法：addBirthdayViewController(_:didAddBirthday:)，该方法将被添加生日视图控制器用来反馈信息。

看一下图 11-6。当用户点击添加按钮➊时，生日表格视图控制器创建添加生日视图控制器➋，并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从添加生日视图控制器传递到生日表格视图控制器。*

`AddBirthdayViewControllerDelegate` 协议被定义为包含一个方法 `addBirthdayViewController(_:didAddBirthday:)` 。当用户点击“保存” ➌ 时，`AddBirthdayViewController` 会调用这个方法 ➍ 并将新生日传递给它的委托，`Birthdays` 表视图控制器。`Birthdays` 表视图控制器会接收这个生日，添加到它的生日数组中，然后重新加载表视图 ➎ ，以便新生日出现在表格中。

我们将展示如何创建一个 `AddBirthdayViewControllerDelegate` 协议，其中包含 `addBirthdayViewController(_:didAddBirthday:)` 方法，这样每当添加一个生日时，`AddBirthdayViewController` 就可以调用该方法。`Birthdays` 表视图控制器将实现这个协议方法，这样每当通过 `AddBirthdayViewController` 添加一个生日时，`AddBirthdayViewController` 可以告诉它的委托：“嘿！有人刚刚添加了这个生日。” 然后 `Birthdays` 表视图控制器会收到这个消息并说：“哦！我会把它加到我的列表里，并刷新显示，让新生日显示出来。”

那么现在让我们在代码中实现这一点！

##### 创建一个协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 `AddBirthdayViewController` 类的 *上方*，添加以下代码来定义 `AddBirthdayViewControllerDelegate` 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你可以通过键入关键字 `protocol` 后跟协议名 `AddBirthdayViewControllerDelegate` 来定义协议 ➊ 。这个名字很长，但 Swift 程序员通常会用调用类的名字来命名协议，并在末尾加上 `Delegate`。这样你就能通过协议名知道哪个类在使用该协议。既然你现在是一个 Swift 程序员，应该遵循相同的命名惯例。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)` 是唯一的函数，它用于将生日对象传递回委托类 ➋ 。注意，在这个函数中你会把 `AddBirthdayViewController` 作为一个参数。再次强调，Swift 程序员在实现协议方法时通常会这么做，所以你也应该遵循这个惯例。了解是谁发回消息，并且让委托类能够访问那个对象及其类，是非常有用的。

当 `AddBirthdayViewController` 调用这个方法时，它会将自身作为 `addBirthdayViewController` 参数传递。你很快就会看到这是如何实现的。需要注意的另一个点是外部参数名 `didAddBirthday`。许多委托协议方法都包含 *did* 和 *will*，因为它们用来描述调用类刚刚做了或即将做的事情。

现在你已经定义了协议，接下来需要告诉 `Birthdays` 表视图控制器遵循这个协议，并使用协议中的方法。

##### 让 Birthdays 表视图控制器遵循协议

为了采用这个协议，Birthdays 表格视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，将 AddBirthdayViewControllerDelegate 添加到 UITableViewController 超类之后。在类的顶部，在 UITableViewController 后添加逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你做完这些操作，一个红色错误会出现。发生这种情况是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现这个协议，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快会修复这个问题。

需要特别注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，而且这个超类的名字必须写在任何协议之前。但尽管一个类只能有一个超类，它可以采用任意多个协议——这些协议会列在超类之后，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:) 方法添加到 Birthdays TableViewController 中。一个好的添加位置是在类的末尾，紧接着导航部分：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类遵循了 AddBirthdayViewController Delegate 协议，并且它预计你会添加这个方法。注意，与子类化方法不同，你在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 AddBirthdayViewController 传递来的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现这一点 ➋。接下来，你需要刷新表格视图，以便它显示这个新添加的生日，方法是调用 tableView 属性上的 reloadData() 方法 ➌。当 reloadData() 被调用时，表格视图的数据源方法将会再次调用，新的生日将会显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必需的，但为了良好的编码风格，标记出类的不同部分是很好的做法，它有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是一个 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你找到方法并跳转到代码中的不同位置。要使用此菜单，点击编辑器窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器设置委托

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告知 Birthdays 表格视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个可选的委托属性 AddBirthdayViewControllerDelegate 类型，并将其插入到 outlets 下面来实现：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为你不能在 Add Birthday 视图控制器创建之前设置它。你很快就会学到在哪里设置委托。

现在 Add Birthday 视图控制器有了委托，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日传递给委托。将 saveTapped(_:) 改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 方法将其传回给委托。

太棒了！你已经完成了对 Add Birthday 视图控制器的修改。现在它有了一个委托，可以监听生日保存的回调。运行应用程序，看看会发生什么。

嗯……变化不大。当你添加一个生日时，仍然没有看到它出现在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置委托连接这两个控制器

还有一件事需要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存着在保存生日时与之通信的委托对象。但我们从未特别设置委托属性为 Birthdays 表格视图控制器。所以现在是时候连接这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除/*和*/来取消注释该方法。

每当 Birthdays 表视图控制器放弃其屏幕，且应用通过 storyboard segue 过渡到另一个视图控制器时，系统会自动调用此方法。我们将使用此方法将 Birthdays 表视图控制器传递到“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的委托。在 prepare(for:sender:)方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的委托为 Birthdays 表视图控制器需要三行代码。首先，你需要能够通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 在注释中给出了如何实现这一点的提示。一个 UIStoryboardSegue 有一个名为 destination 的属性，它位于此方法中正在准备的 segue 的另一端，但该应用的 destination 并不是 AddBirthdayViewController。

在第九章，你将“添加生日”视图控制器嵌入到导航控制器中，这样你就可以拥有一个带有“取消”和“保存”按钮的导航栏。所以你不会期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊处的代码获取了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定子类，我们需要使用`as`将其类型转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController➋。topViewController 就是在 navigationController 中显示的视图控制器，但其属性类型是 UIViewController，所以需要将其类型转换为 AddBirthdayViewController，以表示该控制器是 UIViewController 的特定子类。最后，当你获得 AddBirthdayViewController 时，可以将委托设置为 self，而 self 当前是 Birthdays 表视图控制器➌。

现在运行应用并添加一些生日！你在 Birthdays 表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果退出应用并重新运行，之前添加的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中进行。

### 你学到的内容

在这一章中，你学习了如何创建一个表视图控制器来显示你的生日列表。你还学习了如何在“添加生日”视图控制器中添加一个生日，并且如何通过委托将生日添加到 Birthdays 表视图控制器中的 birthdays 数组，以便可以显示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使你退出应用并重新启动，它们仍然会显示。为了保存生日信息，我们将使用 Core Data，这是我们在项目开始时设置的。

numberOfSections(in:) 告诉表格视图应该有多少个部分

tableView(_:numberOfRowsInSection:) 告诉表格视图每个部分将显示多少行

tableView(_:cellForRowAt:) 设置每一行将要显示的单元格

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分来分组不同设备设置的行。*

每次表格视图重新加载时，表格视图控制器都会调用数据源方法。当你创建一个 UITableViewController 的子类时，Xcode 会自动为你生成这些方法模板。你需要实现所有三个方法，才能让应用正常工作，即使你在代码中永远不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，协议中包含这些数据源方法，用来确定在表格视图中显示的内容。我们将在“代理模式”第 166 页讨论协议。现在，你只需要知道，UITableViewController 使用这些方法来显示内容，并且它会自动调用这些方法，所以你不需要手动调用它们。

让我们从方法 numberOfSections(in:)开始。Birthdays 表格视图控制器是一个仅显示 Birthday 实例的列表，因此它不需要多个部分。为了设置表格视图中的部分数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 tableView 的 UITableView 参数，它是使用此类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 自带了一个内置的表格视图，并且这个视图会自动与这些方法连接。每个生日将显示在它自己的行中。因此，在 tableView(_:numberOfRowsInSection:)方法中，为了确保行数与所有生日的数量匹配，你需要返回你在 birthdays 数组中拥有的生日实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少项，非常适合这种情况！将此方法改为如下：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，tableView(_:numberOfRowsInSection:)还接受一个名为 section 的 Int。当表格视图加载时，这个方法会为每个部分调用。在我们的例子中，我们只有一个部分，所以我们不需要检查表格视图正在显示哪个部分。我们知道它是部分 0，我们希望它拥有与生日数量相同的行数，因此我们写 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:) 方法，以便表格视图知道在每个单元格中放置什么内容。由于此方法被注释掉了，你需要通过删除 /* 和 */ 来取消注释它。（小心不要不小心取消注释后面的其他方法！）取消注释后，将其修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你并不直接调用方法 tableView(_:cellForRowAt:)。它会在表格视图加载到屏幕时自动调用。它会为屏幕上的每个单元格调用，并接受两个参数，tableView 和 indexPath。你已经知道 tableView 参数的作用了。IndexPath 是一个 Swift 结构体，用来表示表格视图中某一行的位置。IndexPath 实例有一个 section 属性和一个 row 属性。由于这个方法会被多次调用（每个表格行调用一次），我们需要 indexPath 来知道我们当前正在配置的是哪个 section 和 row。indexPath.section 属性提供了 section 的编号，而 indexPath.row 则提供了表格视图单元格的行号。tableView(_:cellForRowAt:) 中的五行代码将完成以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定在 birthdays 数组中哪个生日将在单元格中显示

• 创建两个标签，用于在单元格中显示生日人物的名字和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。代码 ➊ 使用方法 dequeueReusableCell(withIdentifier:for:) 来完成这项工作。不过，在你开始使用这个方法之前，需要告诉方法你要从故事板中使用哪个单元格。之前，在故事板中，你给单元格设置了标识符 birthdayCellIdentifier（见 Figure 11-4）。这个标识符将你的代码与单元格关联起来，并告诉方法它正在使用正确的单元格。调用这个方法时使用的字符串必须与在故事板中设置的字符串完全相同，否则你会遇到错误，应用程序在运行时会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:) 中，你注意到 *Reusable Cell* 这几个词了吗？表格视图中的单元格只会创建一次，然后可以重复使用。这有助于提升性能，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，滚出屏幕顶部的单元格将会被重用。它们会被填充上新的信息，并重新出现在屏幕底部。UITableView 会自动完成这项工作。当表格视图加载时，tableView(_:cellForRowAt:) 会被调用一次，针对每个可见的行。当用户滚动查看更多单元格时，它会在每个行即将出现在屏幕上时再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日，即 birthdays[0]，应该显示在第 0 行。第二个生日，即 birthdays[1]，应该显示在第 1 行，依此类推，这意味着 indexPath 的行号与我们希望访问的 birthdays 数组中的位置相同。➋ 处的代码通过使用 indexPath.row 从 birthdays 数组中访问正确的 Birthday 对象。一旦我们得到了正确的 Birthday 对象，我们将其赋值给名为 birthday 的常量，以便我们可以设置该单元格中的标签。

请注意，我们使用 let 将生日赋值给常量而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并将自己的 Birthday 对象赋值给该常量。由于我们不会更改任何生日常量——我们只是读取它们的属性——因此我们不需要将它们设为变量。

现在你已经有了单元格和生日，接下来是填充细节。你需要为每个单元格添加两个标签，用于显示生日人的姓名和出生日期。你将单元格设置为副标题样式，这样它就有一个标题标签和一个副标题标签。每个单元格已经包含这些标签，因此你不必自己创建标签。

这些标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，两个名字之间用一个空格隔开。➍ 处，你使用 dateFormatter 的 string(from:) 方法来将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 在 ➎ 处返回该单元格，以便它可以在表视图的该 indexPath 显示出来。

### 将所有内容整合（PUTTING IT ALL TOGETHER）

现在你可以使用“添加生日”视图控制器将 Birthday 实例添加到应用程序中，并且你有一个表视图来列出 Birthdays 表视图控制器中的每个 Birthday。但是当你尝试运行应用并添加一个 Birthday 时，它没有显示出来。为了让你添加的每个 Birthday 显示在表视图中，你需要让“添加生日”视图控制器与 Birthdays 表视图控制器进行通信。你可以通过使用 *委托（delegation）* 来实现这一点。

#### 委托（DELEGATION）

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 显示在自己的上面。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它只是突然出现，并不知道它是从哪里来的，也不知道是如何到达那里的。那么，B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项工作或任务交给另一个人。一个*委托人*就像一个老板，告诉一个被委托的员工该做什么。当被委托的员工完成任务时，有时他们会将信息报告给委托人老板。

在 Swift 中，委托的工作方式很相似，但我们不再是老板和员工，而是委托者和被委托的对象。由于类 B 是由类 A 指示要做什么的，因此它是被委托对象。我们给类 B 一个特殊的属性，称为委托(delegate)，用于告知它委托人是谁——这样它就知道该与谁沟通。委托可以是任何具有一组方法的类，这些方法已经在*协议*中定义。协议就像是两个类之间的协议，告诉它们委托可以要求被委托对象做什么。协议包含了一些方法和属性的名称，委托可以用这些名称与被委托对象进行交互。

类 A 创建类 B，将自己设置为类 B 的委托，并赋予类 B 一个协议中定义的任务。一旦类 B 完成任务，它会向类 A 报告。让我们看看这个如何在我们的应用中实现。

生日表视图控制器是视图控制器 A，而“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，即 addBirthdayViewController(_:didAddBirthday:)，该方法将被“添加生日”视图控制器用来报告回调。

请查看图 11-6。当用户点击“添加”按钮 ➊ 时，生日表视图控制器会创建“添加生日”视图控制器 ➋ 并将自己设置为“添加生日”视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从“添加生日”视图控制器传递到“生日表视图控制器”。*

AddBirthdayViewControllerDelegate 协议被定义为包含一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击“保存”按钮 ➌ 时，“添加生日”视图控制器会调用这个方法 ➍ 并将新的生日传递给它的委托——“生日表视图控制器”。“生日表视图控制器”接收这个生日，将其添加到它的生日数组中，然后重新加载它的表视图 ➎ ，这样新生日就会在表中显示出来。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义方法 addBirthdayViewController(_:didAddBirthday:)，当在应用中添加生日时，添加生日视图控制器可以调用该方法。“生日表视图控制器”将实现该协议方法，这样每当通过“添加生日”视图控制器添加一个生日时，“添加生日”视图控制器只需对其委托说：“嘿！刚有人添加了这个生日”，而“生日表视图控制器”将收到这个消息并回应：“哦！我会把它加到我的列表中，并刷新我的显示，以便新生日能显示出来。”

现在，让我们开始用代码实现这个！

##### 创建协议

首先，我们需要创建这个协议。在 *AddBirthdayViewController.swift* 文件中，*在* AddBirthdayViewController 类之前，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处通过输入关键字 protocol 后跟协议名 AddBirthdayViewControllerDelegate 来定义这个协议。这个名字很长，但 Swift 程序员通常会将协议命名为调用类的名字，并在后面加上 Delegate 这个词。这样，你就可以通过查看协议的名称来知道哪个类在使用这个协议。既然你现在是 Swift 程序员，你也应该遵循相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传递回代理类 ➋ 。注意，在这个函数中你将 AddBirthdayViewController 作为一个参数包含进来。同样，Swift 程序员在实现协议方法时通常遵循这个约定，所以你也应该遵循这种做法。知道是谁发送了消息以及代理能够访问该对象和其类是很有用的。

当 Add Birthday 视图控制器调用这个方法时，它将把自身作为 addBirthdayViewController 参数传递进来。你很快就会看到这是如何实现的。需要注意的另一个点是外部参数名 didAddBirthday。许多代理协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚做完或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays Table View Controller 去遵循这个协议并使用协议的方法。

##### 让 Birthdays Table View Controller 遵守协议

为了遵循这个协议，Birthdays Table View Controller 需要将自己定义为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中将 AddBirthdayViewControllerDelegate 添加到 UITableViewController 超类后面。就在类的顶部，在 UITableViewController 后加上一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色错误就会出现。出现这种情况是因为 **BirthdaysTableViewController** 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会解决这个问题。

需要注意的是，BirthdaysTableViewController 是从 UITableViewController 超类派生的。一个类只能有一个超类，且超类的名字必须在任何协议之前书写。但虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议会列在超类之后，用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:)方法。一个合适的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 自动完成会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且期待你添加这个方法。请注意，与子类化方法不同，在 addBirthdayViewController(_:didAddBirthday:)之前你不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将由 Add Birthday 视图控制器传入的 Birthday 添加到 birthdays 数组中。你可以使用数组的 append(_:)方法来完成这一操作 ➋。接下来，你需要刷新表格视图，使其显示这个新的生日，通过调用 tableView 属性的 reloadData()方法 ➌。当调用 reloadData()时，表格视图的数据源方法会再次被调用，新添加的 Birthday 将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但标记类的不同部分是一个良好的编码风格，并且有助于保持代码的整洁和可读性。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你查找方法，并让你在代码中快速跳转到不同的位置。要使用这个菜单，点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：您的类具有内置的目录，可以快速跳转到某个章节。*

##### 为 Add Birthday 视图控制器设置委托

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来告诉 Birthdays 表格视图控制器何时已添加一个生日了。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中插入以下一行，紧跟在 outlets 之后来实现这一点：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为你无法在 Add Birthday 视图控制器创建之前设置它。稍后你会学习到在哪里设置委托。

现在，“添加生日”视图控制器有了委托，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日传递给委托。将 saveTapped(_:) 方法更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 将其传回委托。

很好！你已经完成了对“添加生日”视图控制器的修改。现在它有了一个委托，能够监听一个生日被保存的调用。运行应用看看会发生什么。

嗯。。。似乎没有太多变化。当你添加一个生日时，依然看不到它出现在“生日”表视图控制器中。到底怎么回事？

#### 通过设置委托连接这两个控制器

还有一件事需要做。“生日”表视图控制器是一个 AddBirthdayViewControllerDelegate，且“添加生日”视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存它与之通信的委托，当一个生日被保存时。然而，我们从未专门将委托属性设置为“生日”表视图控制器。所以现在是时候连接这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个方法 prepare(for:sender:) 被注释掉了。通过删除围绕它的 /* 和 */，取消注释该方法。

每当“生日”表视图控制器放弃其屏幕并且应用通过故事板 segue 转换到另一个视图控制器时，此方法会自动被调用。我们将使用此方法将“生日”表视图控制器传递给“添加生日”视图控制器，并将其自身设置为“添加生日”视图控制器的委托。在 prepare(for:sender:) 方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码就可以将“添加生日”视图控制器的委托设置为“生日”表视图控制器。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 已经留下了一个注释，暗示了你可以如何做到这一点。UIStoryboardSegue 有一个叫 destination 的属性，它是正在准备的 segue 的目标，但对于这个应用，目标不是 AddBirthdayViewController。

在 第九章 中，你将“添加生日”视图控制器嵌入到一个导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。所以你不会期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊ 处的代码会获取到 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 ViewController 的特定类型，所以我们需要使用 as 进行类型转换，转为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是`navigationController`的`topViewController` ➋。`topViewController`就是当前在`navigationController`中显示的视图控制器，但它的属性是`UIViewController`类型，因此必须强制转换为`AddBirthdayViewController`，以表示这个控制器是`UIViewController`的一个具体子类。最后，当你获得`AddBirthdayViewController`后，你可以将委托设置为`self`，即当前的生日表视图控制器 ➌。

现在运行应用程序并添加一些生日！你在“生日”表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序然后再次运行，之前添加的生日会消失。我们仍然需要将生日保存到设备中，接下来我们将在第十二章中实现这一点。

### 你学到了什么

在本章中，你学会了如何创建一个表视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，然后如何使用委托将生日添加到生日表视图控制器中的生日数组中，以便显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用程序并再次运行，它们仍然会显示。为了保存生日，你将使用 Core Data，这是我们在项目一开始时就设置好的。

`tableView(_:numberOfRowsInSection:)`告诉表视图每个部分将显示多少行。

`tableView(_:cellForRowAt:)`设置每一行将要显示的单元格。

![](img/Image00243.jpg)

*图 11-5：设置应用使用部分将不同的设备设置分组。*

每当表视图重新加载时，表视图控制器会调用表视图数据源方法。当你创建`UITableViewController`的子类时，Xcode 会自动为你提供这些方法模板。你需要实现所有三个方法才能让应用程序正常工作，尽管你在代码中不会直接调用它们。`UITableViewController`类实现了`UITableViewDataSource`协议，该协议带有这些数据源方法，用于确定表视图中将显示什么内容。我们将在“委托”第 166 页讨论协议。现在，你只需要知道，`UITableViewController`使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要显式调用它们。

让我们从`numberOfSections(in:)`方法开始。生日表视图控制器是一个只显示生日实例的列表，所以不需要多个部分。为了设置表视图中的部分数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个`UITableView`类型的`tableView`参数，这是使用这个类作为数据源的表格视图。我们不需要担心建立这个连接，因为`UITableViewController`自带一个内建的表格视图，并且自动连接到这些方法中。每个生日会显示在自己的行里。因此，在`tableView(_:numberOfRowsInSection:)`方法中，为了拥有与所有生日相对应的正确行数，你需要返回`birthdays`数组中生日实例的数量。你还记得数组的`count`属性吗？它是一个整数，告诉你数组中有多少个元素，非常适合这种情况！将此方法修改为如下：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了`tableView`参数，`tableView(_:numberOfRowsInSection:)`方法还接受一个名为`section`的`Int`类型参数。当表格视图正在加载时，这个方法会为表格中的每个部分调用。在我们的例子中，只有一个部分，所以我们不需要费心去检查当前显示的是哪个部分。我们知道它是部分 0，并且我们希望它有与生日数量相同的行数，因此我们写`return birthdays.count`。

最后，你需要实现`tableView(_:cellForRowAt:)`方法，以便表格视图知道每个单元格中应该放置什么内容。由于这个方法被注释掉了，你需要通过删除`/*`和`*/`来取消注释它。（小心不要不小心取消注释它后面的其他方法！）完成后，将其修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用`tableView(_:cellForRowAt:)`方法。它会在表格视图加载到屏幕时被调用。它会为屏幕上的每个单元格调用，并接受两个参数，`tableView`和`indexPath`。你已经知道`tableView`参数的作用。`IndexPath`是一个 Swift 结构体，用来表示表格视图中一行的位置。一个`IndexPath`实例包含`section`属性和`row`属性。由于这个方法会被多次调用（每个表格行调用一次），我们需要`indexPath`来知道当前正在配置的是哪个部分和哪一行。`indexPath.section`属性给出节号，而`indexPath.row`给出表格视图单元格的行号。`tableView(_:cellForRowAt:)`方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个`UITableViewCell`

• 确定在`birthdays`数组中的哪个生日将在单元格中显示

• 创建两个标签，在单元格中显示生日人的姓名和出生日期

• 返回准备好在表格视图中显示的单元格

让我们逐行分析这段代码。

首先，创建`UITableViewCell`。代码在➊处使用`dequeueReusableCell(withIdentifier:for:)`方法实现此功能。然而，在你开始在单元格上使用此方法之前，你需要告诉方法你想从故事板中使用哪个单元格。之前，在故事板中，你给你的单元格设置了标识符`birthdayCellIdentifier`（见图 11-4）。这个标识符将你的代码与单元格关联起来，并告诉你的方法它正在使用正确的单元格。调用此方法时的字符串必须与在故事板中设置的字符串完全相同，否则你会收到错误，应用程序在运行时会崩溃。

在`dequeueReusableCell(withIdentifier:for:)`方法中，你注意到*Reusable Cell*这两个词了吗？表格视图中的单元格只创建一次，然后可以反复使用。这有助于加速一切并使其更加流畅，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日，但一次屏幕上只会显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以查看更多生日时，屏幕上方滚动出去的单元格会被重用。它们会被填充新信息，并再次出现在屏幕底部。`UITableView`会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)`会为每一行可见的单元格被调用。当用户滚动查看更多单元格时，它会再次为每一行调用，就在它即将出现在屏幕上时。

接下来，我们需要找出哪个`Birthday`应该显示在单元格中。我们希望在每一行中显示`birthdays`数组中的一个生日。第一个生日，即`birthdays[0]`，应该显示在第 0 行。第二个生日，即`birthdays[1]`，应该显示在第 1 行，以此类推，这意味着`indexPath`的`row`与我们想要访问的`birthdays`数组中的位置相同。代码在➋处通过使用`indexPath.row`从`birthdays`数组中访问正确的`Birthday`对象。一旦我们获得了正确的`Birthday`对象，我们将其赋值给一个名为`birthday`的常量，这样我们就可以设置此单元格中的标签了。

请注意，我们使用`let`来将生日赋值给常量，而不是变量。我们可以使用`let`，因为每次调用`tableView(_:cellForRowAt:)`时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并且分配了它自己的`Birthday`对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以我们不想把它们设为变量。

现在你有了单元格和生日，是时候填写详细信息了。你需要为每个单元格准备两个标签，用来显示生日人物的姓名和出生日期。你将单元格设置为 Subtitle 样式，这样它就有了一个 Title 标签和一个 Subtitle 标签。每个单元格已经包含了这些标签，所以现在你不需要自己创建标签了。

标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为一个字符串，该字符串由生日的 firstName 和 lastName 组成，两者之间有一个空格。➍ 处，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 在 ➎ 处返回该单元格，以便它可以在表视图的该 indexPath 位置显示。

### 整合所有内容

现在，你可以使用 Add Birthday 视图控制器向应用中添加 Birthday 实例，并且你有一个表视图来列出每个 Birthday，在 Birthdays 视图控制器中显示。但当你尝试运行应用并添加一个 Birthday 时，它并没有显示。为了让你添加的每个 Birthday 都能出现在表视图中，你需要让 Add Birthday 视图控制器与 Birthdays 视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将其呈现到自身之上。A 知道 B，因为它创建并呈现了 B，因此 A 可以将信息传递给 B。但 B 并不知道 A——它只是突然出现的，不知道它从哪里来，也不知道是如何到达那里的。那么 B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托就是某人将任务或工作交给其他人。*委托*就像一个老板，他告诉一个被委托的员工该做什么。当被委托的员工完成任务时，有时他们会将信息报告给委托的老板。

Swift 中的委托非常类似，但我们有一个委托和一个委托对象，而不是老板和员工。由于类 B 是被类 A 告诉该做什么的，因此它是委托对象。我们给类 B 一个特殊的属性，称为 delegate，用来告诉它谁是它的委托——这样，它就知道要与谁沟通。委托可以是任何拥有在*协议*中定义的方法集合的类。协议就像是两者之间的协议，告诉它们委托可以要求委托对象做什么。它有一个方法和属性名称列表，委托可以用这些方法和属性与委托对象交互。

类 A 创建类 B，使自己成为类 B 的委托，并给类 B 分配一个在协议中定义的任务。一旦类 B 完成了任务，它会向类 A 汇报。让我们看看这个在我们的应用中是如何工作的。

Birthdays 表视图控制器是视图控制器 A，而 Add Birthday 视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，Add Birthday 视图控制器将使用该方法进行报告。

看看图 11-6。当用户点击添加按钮 ➊ 时，Birthdays 表格视图控制器创建 Add Birthday 视图控制器 ➋ 并将自己设置为 Add Birthday 视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：通过委托，新的生日从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，Add Birthday 视图控制器调用此方法 ➍ 并将新的生日传递给它的代理——Birthdays 表格视图控制器。Birthdays 表格视图控制器接收这个生日，添加到它的生日数组中，然后重新加载表格视图 ➎，以便新生日会出现在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，其中包含一个方法 addBirthdayViewController(_:didAddBirthday:)，当添加生日到应用时，Add Birthday 视图控制器可以调用这个方法。Birthdays 表格视图控制器将实现该协议方法，以便每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器只需要对其代理说，“嘿！刚刚有人添加了这个生日”，然后 Birthdays 表格视图控制器会收到消息并说，“哦！我会把它加到我的列表中，并刷新显示，确保新的生日能够显示出来。”

所以现在，让我们在代码中实现这一点吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，*在*AddBirthdayViewController 类上方，添加这段定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊位置通过输入关键字 protocol 并跟随类名 AddBirthdayViewControllerDelegate 来定义协议。这个名字很长，但 Swift 程序员通常会根据调用类的名称来命名协议，并在最后加上“Delegate”这个词。这样你就能通过查看协议的名称，知道哪个类正在使用这个协议。既然你现在是 Swift 程序员，你也应该使用相同的命名惯例。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，用于将 Birthday 对象传回代理类 ➋。注意，在这个函数中，你将 AddBirthdayViewController 作为一个参数。再次强调，Swift 程序员在实现协议方法时通常会这么做，因此你也应该遵循这一惯例。这样做很有用，因为你可以知道是谁发送了消息，且代理可以访问该对象及其类。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递过来。你很快就会看到这是如何完成的。另一个需要注意的是外部参数名称 didAddBirthday。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类已经做了某件事或将要做的事。

现在你已经定义了协议，接下来需要告诉 Birthdays 表格视图控制器采用这个协议并使用协议中的方法。

##### 让 Birthdays Table View Controller 遵循协议

为了采用这个协议，Birthdays 表格视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为此，你需要在 UITableViewController 父类之后，将 AddBirthdayViewControllerDelegate 添加到类定义中。在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，就会出现一个红色错误。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会修复这个问题。

这里需要特别注意的是，BirthdaysTableViewController 是 UITableViewController 父类的子类。一个类只能有一个父类，而且该父类的名称必须写在任何协议之前。但尽管一个类只能有一个父类，它可以采用任意多个协议——这些协议会在父类之后列出，并且用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的地方是在类的末尾，在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成功能建议了整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且期望你添加这个方法。注意，与子类化的方法不同，你不需要在 addBirthdayViewController(_:didAddBirthday:) 前面使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的 Birthday 添加到 birthdays 数组中。你可以通过使用 append(_:) 方法来实现这一点 ➋。接下来，你需要刷新表格视图，使其显示这个新的生日，可以通过调用 tableView 属性上的 reloadData() 方法来做到这一点 ➌。当 reloadData() 被调用时，表格视图的数据源方法会再次被调用，新的 Birthday 会显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但良好的编码风格是对类的不同部分进行标记，它有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部下拉目录的菜单中。这个下拉菜单帮助你找到方法并跳转到代码中的不同位置。要使用此菜单，请点击编辑器窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置目录，便于快速跳转到某个部分。*

##### 为添加生日视图控制器设置委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议来告诉生日表格视图控制器它已添加了一个生日。为此，添加生日视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类的 outlets 下方插入以下代码，来安排添加一个可选的委托属性，类型为 AddBirthdayViewControllerDelegate：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在创建添加生日视图控制器之前，你无法设置它。稍后你将学习在哪里设置委托。

现在，添加生日视图控制器有了委托，在 `saveTapped(_:)` 方法中，你可以通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将生日传递给委托。将 `saveTapped(_:)` 改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊ 处的代码通过 `addBirthdayViewController(_:didAddBirthday:)` 将其传递回委托。

很好！你已经完成了对添加生日视图控制器的修改。它现在有了一个委托，用来监听保存生日的调用。运行应用程序，看看会发生什么。

嗯……变化不大。当你添加一个生日时，仍然看不到它出现在生日表格视图控制器中。怎么回事？

#### 通过设置委托连接两个控制器

还有最后一件事需要做。生日表格视图控制器是一个 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存它与之通信的委托对象，尤其是在保存生日时。但我们从未专门将委托属性设置为生日表格视图控制器。所以，现在是时候连接这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除围绕它的 /* 和 */ 来取消注释这个方法。

当 Birthdays 表格视图控制器放弃其屏幕，并且应用通过 storyboard segue 转到另一个视图控制器时，系统会自动调用这个方法。我们将使用这个方法将 Birthdays 表格视图控制器传递给 Add Birthday 视图控制器，以便将自己设置为 Add Birthday 视图控制器的代理。在 prepare(for:sender:) 方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的代理到 Birthdays 表格视图控制器只需要三行代码。首先，你需要能够通过 segue 参数获取到 AddBirthdayViewController 对象。Xcode 中已经留下了注释，提示你如何做到这一点。一个 UIStoryboardSegue 有一个属性叫做 destination，位于正在准备的 segue 的另一端，但对于这个应用来说，目的地并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。因此，你不期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊ 这一行获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定类型，所以我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 只是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，所以必须将其强制转换为 AddBirthdayViewController，表示该控制器是 UIViewController 的特定子类。最后，当你获得 AddBirthdayViewController 后，可以将代理设置为 self，也就是当前的 Birthdays 表格视图控制器 ➌。

现在运行应用并添加一些生日！你在 Birthdays 表格视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用再重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，接下来我们会在第十二章中完成这个任务。

### 你学到的内容

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学习了如何在 Add Birthday 视图控制器中添加生日，然后如何使用代理将生日添加到 Birthdays 表格视图控制器中的 birthdays 数组中，以便显示出来。

在第十二章中，你将学习如何将生日保存到设备中，以便在你退出应用后重新打开时，生日依然会显示出来。为了保存生日，你将使用 Core Data，我们在项目一开始就设置好了它。

tableView(_:cellForRowAt:) 设置每个要显示的单元格，这些单元格将显示在表视图的每一行中。

![](img/Image00243.jpg)

*图 11-5：设置应用使用分区来将不同设备设置的行分组。*

表视图的数据源方法会在每次重新加载表视图时被表视图控制器调用。当你创建一个 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。为了使应用正常工作，你需要实现这三个方法，即使你在代码中不会直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用于确定将显示在表视图中的内容。我们将在“委托”第 166 页讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示内容，并且它会自动调用这些方法，所以你不需要自己调用它们。

我们从 numberOfSections(in:)方法开始。Birthdays 表视图控制器是一个仅显示 Birthday 实例的列表，因此它不需要多个分区。为了设置表视图中的分区数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

该方法接受一个名为 tableView 的 UITableView 作为参数，它是使用此类作为数据源的表视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内置的表视图，并且这些方法会自动连接到它。每个生日都会显示在自己的行中。因此，在 tableView(_:numberOfRowsInSection:)方法中，为了确保你有足够的行数来显示所有生日，你需要返回你在 birthdays 数组中拥有的 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少项，正好适用于这种情况！将这个方法修改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，tableView(_:numberOfRowsInSection:)方法还接受一个名为 section 的 Int 类型参数。当表视图加载自身时，该方法会为表视图中的每个分区被调用。在我们的例子中，我们只有一个分区，所以我们不需要检查正在显示的表视图的分区。我们知道是第 0 个分区，并且希望它的行数与生日的数量一致，所以我们写下 return birthdays.count。

最后，您需要实现`tableView(_:cellForRowAt:)`方法，这样表格视图就能知道在每个单元格中放入什么内容。由于这个方法已被注释掉，您需要通过删除围绕它的`/*`和`*/`来取消注释它。（小心不要不小心取消注释它之后的其他方法！）完成后，将其修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

您不需要直接调用`tableView(_:cellForRowAt:)`方法。它会在表格视图加载到屏幕上时被自动调用。每个显示在屏幕上的单元格都会调用此方法，并传递两个参数，`tableView`和`indexPath`。您已经知道`tableView`参数的用途。`IndexPath`是一个 Swift 结构体，用于表示表格视图中某一行的位置。`IndexPath`实例包含一个`section`属性和一个`row`属性。由于该方法会被多次调用（每一行都会调用一次），我们需要`indexPath`来知道当前配置的是哪个分区和哪一行。`indexPath.section`属性给出分区号，`indexPath.row`则给出表格视图单元格的行号。`tableView(_:cellForRowAt:)`中的五行代码将完成以下操作：

![](img/Image00244.jpg)

• 创建一个`UITableViewCell`

• 确定在`birthdays`数组中哪个生日将在单元格中显示

• 创建两个标签，用于在单元格中显示生日人员的姓名和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建`UITableViewCell`。代码中的➊部分使用`dequeueReusableCell(withIdentifier:for:)`方法完成此操作。然而，在开始使用这个方法之前，您需要告诉它您想使用哪个单元格，这个单元格在故事板中已经定义过了。之前，当您在故事板中时，您给单元格设置了标识符`birthdayCellIdentifier`（参见图 11-4）。这个标识符将您的代码与单元格关联起来，并告诉您的方法正在使用正确的单元格。当您调用此方法时，传入的字符串必须与您在故事板中设置的字符串完全相同，否则您将遇到错误，且应用程序在运行时会崩溃。

在方法`dequeueReusableCell(withIdentifier:for:)`中，您有没有注意到“*可重用单元格*”这几个词？表格视图中的单元格只会创建一次，然后可以重复使用。这帮助所有操作更加快速和流畅，因为创建单元格是最耗时的部分。如果您的应用中有 200 个生日信息，但一次只能在屏幕上显示 10 个，那么您只需要 10 个单元格来显示这些生日。当您向下滚动以显示更多生日时，滚出屏幕顶部的单元格会被重新使用。它们会被填充新的信息并重新出现在屏幕底部。`UITableView`会自动完成这些工作。当表格视图加载时，`tableView(_:cellForRowAt:)`会被调用，针对每一行的可见单元格进行处理。当用户滚动查看更多单元格时，这个方法会再次被调用，处理即将出现在屏幕上的每一行。

接下来，我们需要找出应该显示在单元格中的生日。我们希望在每一行中显示 `birthdays` 数组中的一个生日。第一个生日，位于 `birthdays[0]`，应该显示在第 0 行。第二个生日，位于 `birthdays[1]`，应该显示在第 1 行，以此类推，这意味着 `indexPath` 的行数与我们想要访问的 `birthdays` 数组中的位置相同。➋处的代码通过使用 `indexPath.row` 来访问 `birthdays` 数组中的正确生日对象。一旦我们获取到正确的生日对象，就将其赋值给一个名为 `birthday` 的常量，以便我们可以设置这个单元格中的标签。

请注意，我们使用 `let` 将生日赋值给常量而不是变量。我们之所以使用 `let`，是因为每次调用 `tableView(_:cellForRowAt:)` 时，都会创建一个新的生日常量。每个单元格都会获得自己的生日常量，并将其赋予对应的生日对象。由于我们不会改变这些生日常量——我们只会读取它们的属性——所以我们不需要将它们设为变量。

现在你已经有了单元格和生日，是时候填写详细信息了。你需要为每个单元格准备两个标签，分别显示生日人的名字和出生日期。你将单元格设置为 "Subtitle" 样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，所以你现在不需要自己创建任何标签。

这些标签作为 `UITableViewCell` 的属性存在，分别叫做 `textLabel` 和 `detailTextLabel`。➌处的代码将 `textLabel` 的文本设置为由生日的 `firstName` 和 `lastName` 组成的字符串，中间用空格隔开。在 ➍ 处，你使用 `dateFormatter` 的 `string(from:)` 方法将出生日期显示在 `detailTextLabel` 中。

当你的单元格完全配置好后，`tableView(_:cellForRowAt:)` 在 ➎ 处返回单元格，以便它可以在表视图的那个 `indexPath` 处显示。

### 综合起来（PUTTING IT ALL TOGETHER）

现在你可以通过添加生日视图控制器向应用中添加生日实例，并且你有一个表视图来列出每个生日，在 "Birthdays" 表视图控制器中显示。但当你尝试运行应用并添加一个生日时，它没有显示出来。为了让你添加的每个生日在表视图中显示出来，你需要让 "Add Birthday" 视图控制器与 "Birthdays" 表视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托（DELEGATION）

委托（Delegation）可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 不知道 A——它刚刚被创建出来，并不知道它是从哪里来的或如何到达这里的。那么 B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项工作或任务交给别人。一个*委托人*就像一个老板，告诉被委托的员工该做什么。当被委托的员工完成任务时，有时他们会将信息报告给委托的老板。

在 Swift 中，委托也非常相似，但我们没有老板和员工，而是有委托人和委托对象。由于是类 A 告诉类 B 要做什么，因此类 A 是委托对象。我们给类 B 一个特殊的属性，称为 delegate，来告诉它谁是它的委托人——这样，它就知道要与谁进行沟通。委托人可以是任何实现了*协议*中定义方法的类。协议就像是两类之间的约定，告诉它们委托人可以要求委托对象做什么。协议列出了委托人可以在委托对象上使用的方法和属性名称。

类 A 创建类 B，将自己设为类 B 的委托，并给类 B 分配一个协议中的任务。一旦类 B 完成任务，它就会向类 A 报告。让我们看看这个在我们的应用程序中是如何运作的。

Birthdays 表格视图控制器是视图控制器 A，Add Birthday 视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将由 Add Birthday 视图控制器用来报告信息。

请查看图 11-6。当用户点击添加按钮 ➊ 时，Birthdays 表格视图控制器创建 Add Birthday 视图控制器 ➋ 并将自己设置为 Add Birthday 视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：通过委托，新的生日从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为拥有一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，Add Birthday 视图控制器调用该方法 ➍ 并将新生日传递给它的委托，即 Birthdays 表格视图控制器。Birthdays 表格视图控制器将该生日添加到它的 birthdays 数组中，然后重新加载它的表格视图 ➎，这样新生日就会显示在表格中。

我们将向您展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并使用方法 addBirthdayViewController(_:didAddBirthday:)，每当应用程序中添加生日时，Add Birthday 视图控制器可以调用这个方法。Birthdays 表格视图控制器将实现这个协议方法，以便每次通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器只需对它的委托说：“嘿！有人刚刚添加了这个生日”，然后 Birthdays 表格视图控制器会听到这个消息，并说：“哦！我会把它添加到我的列表中并刷新显示，这样新添加的生日就会显示出来。”

所以现在让我们用代码实现这个！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方* 添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处定义了协议，输入关键字 protocol，后跟协议名 AddBirthdayViewControllerDelegate。这个名字比较长，但 Swift 程序员通常会根据调用类的名称为协议命名，并在后面加上 Delegate 这个词。这样一来，你通过查看协议的名称就能知道是哪个类在使用该协议。既然你现在是 Swift 程序员，你也应该遵循相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传递回委托类 ➋。注意你在这个函数中包含了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员在实现协议方法时通常会这样做，因此你也应该遵循这个约定。这样做有助于知道是谁发送回了消息，并且让委托类能够访问该对象及其类。

当 Add Birthday 视图控制器调用此方法时，它将自身作为 addBirthdayViewController 参数传递给该方法。你很快就会看到如何操作。需要注意的另一个点是外部参数名 didAddBirthday。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚做了什么或将要做什么。

现在你已经定义了协议，接下来需要告诉生日表视图控制器采用这个协议并使用协议的方法。

##### 使生日表视图控制器遵循协议

要采用这个协议，生日表视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为了做到这一点，你需要在类定义中，紧跟 UITableViewController 父类后面添加 AddBirthdayViewControllerDelegate。将 AddBirthdayViewControllerDelegate 添加到类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你完成这一步，就会出现一个红色错误提示。出现这种情况是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！别担心，我们很快就会解决这个问题。

这里需要特别注意的是，BirthdaysTableViewController 是 UITableViewController 类的子类。一个类只能有一个父类，并且父类名称必须在协议之前写出。但尽管一个类只能有一个父类，它可以采用任意多个协议——这些协议将列在父类之后，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:)方法。一个合适的地方是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 的自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期望你添加这个方法。注意，与子类化的方法不同，你不需要在 addBirthdayViewController(_:didAddBirthday:)前加上 override 关键字，因为没有原始方法需要被重写。

在此方法中，你需要做两件事。首先，你需要将 AddBirthday 视图控制器传递进来的 Birthday 添加到 birthdays 数组中。你可以通过使用 append(_:)方法来实现 ➋。接下来，你需要刷新表视图，使其显示这个新添加的生日，可以通过在 tableView 属性上调用 reloadData()方法来完成 ➌。当调用 reloadData()时，表视图的数据源方法将再次被调用，新的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分代码：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但将类的不同部分标记出来是一种良好的编码风格，有助于保持代码的简洁和可读性。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单帮助你快速找到方法，并让你跳转到代码的不同位置。要使用此菜单，请点击编辑器窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类具有内置的目录，可以快速跳转到某一部分。*

##### 为 Add Birthday 视图控制器指定代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 AddBirthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表视图控制器它何时添加了一个生日。为此，AddBirthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类的 outlets 下面插入以下一行代码，来为该类添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在 AddBirthday 视图控制器创建之前设置它。你很快会学到在哪里设置代理。

现在，添加生日视图控制器已经有了一个委托，在 `saveTapped(_:)` 方法中，你可以使用 `addBirthdayViewController(_:didAddBirthday:)` 方法将一个生日传递给委托。将 `saveTapped(_:)` 方法修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊ 处的代码使用 `addBirthdayViewController(_:didAddBirthday:)` 方法将其传回给委托。

很棒！你已经完成了对添加生日视图控制器的修改。现在它有了一个委托，将会监听生日保存的调用。运行应用程序查看效果。

嗯。。。似乎没有太大变化。当你添加一个生日时，依然看不到它出现在生日列表视图控制器中。是怎么回事？

#### 通过设置委托连接两个控制器

还有一件事需要做。生日列表视图控制器是一个 `AddBirthdayViewControllerDelegate`，而添加生日视图控制器有一个 `AddBirthdayViewControllerDelegate` 属性，它用于保存与之通信的委托，当一个生日被保存时会与委托进行交互。但我们从未明确设置该委托属性为生日列表视图控制器。所以，现在是时候在这两个视图控制器之间建立通信管道了。

在 `BirthdaysTableViewController` 类的导航部分，有一个被注释掉的方法，名为 `prepare(for:sender:)`。通过删除 `/*` 和 `*/`，取消注释该方法。

这个方法会在每次生日列表视图控制器交出其屏幕并通过 storyboard segue 转到另一个视图控制器时自动调用。我们将使用这个方法将生日列表视图控制器传递给添加生日视图控制器，并将其设置为添加生日视图控制器的委托。请在 `prepare(for:sender:)` 方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的委托为生日列表视图控制器只需要三行代码。首先，你需要能够从 segue 参数访问到 `AddBirthdayViewController` 对象。Xcode 中已经留有注释，提示你如何做到这一点。`UIStoryboardSegue` 有一个名为 `destination` 的属性，指向该 segue 准备的目的地视图控制器，但对于这个应用程序来说，目的地并不是 `AddBirthdayViewController`。

在第九章中，你将添加生日视图控制器嵌入到了导航控制器中，以便可以使用带有取消和保存按钮的导航栏。因此，你不会期望在 segue 的另一端找到添加生日视图控制器。相反，目的地是一个包含添加生日视图控制器的 `UINavigationController`。➊ 处的代码会获取 `navigationController`。`segue.destination` 会返回一个 `UIViewController`，但由于我们的 `navigationController` 是 `ViewController` 的特定类型，因此我们需要使用 `as` 将其类型转换为 `UINavigationController`。

接下来，你可以获取添加生日的视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须强制转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你得到一个 AddBirthdayViewController 时，你可以将委托设置为 self，即当前的生日表视图控制器 ➌。

现在运行应用程序并添加一些生日！在生日表视图控制器中你看到什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序并再次运行，之前的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在这一章中，你学会了如何制作一个表格视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加生日，然后如何使用委托将生日添加到生日表视图控制器中的生日数组中，以便它能够被显示。

在第十二章中，你将学会如何将生日保存到你的设备中，这样即使退出应用程序并再次运行，它们仍然会显示。为了保存生日，你将使用 Core Data，这是我们在项目开始时就设置好的。

![](img/Image00243.jpg)

*图 11-5：设置应用程序使用分区来将不同设备设置的行进行分组。*

表格视图的数据源方法在每次表格视图重新加载时由表格视图控制器调用。当你创建 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。即使你在代码中从不直接调用它们，你也需要实现这三个方法以使应用程序正常工作。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用来决定表格视图中将显示什么内容。我们将在“委托”一节的第 166 页讨论协议。现在，你只需要知道 UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，因此你不需要手动调用它们。

让我们从方法 numberOfSections(in:)开始。生日表视图控制器是一个仅显示生日实例的列表，因此它不需要多个分区。为了设置表格视图中的分区数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接收一个名为 tableView 的 UITableView 作为参数，它是使用此类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内置的表格视图，它会自动与这些方法连接。每个生日将显示在自己的行中。因此，在 tableView(_:numberOfRowsInSection:)方法中，为了确保所有生日有正确的行数，你需要返回 birthdays 数组中 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少个项目，非常适合这种情况！将此方法修改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，tableView(_:numberOfRowsInSection:)还接收一个名为 section 的 Int。当表格视图加载时，这个方法会为表格视图中的每个部分调用。在我们的例子中，只有一个部分，因此我们不需要检查当前显示的是哪个部分。我们知道它是第零部分，且我们希望它的行数与生日的数量相同，所以我们写 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:)方法，以便表格视图知道在每个单元格中显示什么内容。由于这个方法被注释掉了，你需要通过删除它前后的/*和*/来取消注释。（小心不要不小心取消注释它后面的其他方法！）完成后，将它修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用 tableView(_:cellForRowAt:)方法。它会在表格视图加载到屏幕上时被调用，为每个屏幕上的单元格调用，并接收两个参数，tableView 和 indexPath。你已经知道 tableView 参数的作用。IndexPath 是一个 Swift 结构体，用于表示表格视图中行的位置。一个 IndexPath 实例有一个 section 属性和一个 row 属性。由于这个方法会被多次调用（每个表格行一次），我们需要 indexPath 来知道当前正在配置的是哪个部分和行。indexPath.section 属性给出部分号，indexPath.row 属性给出表格视图单元格的行号。tableView(_:cellForRowAt:)中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定 birthdays 数组中哪个 Birthday 将在单元格中显示

• 在单元格中创建两个标签，分别显示生日人的姓名和生日日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建`UITableViewCell`。➊处的代码使用了`dequeueReusableCell(withIdentifier:for:)`方法来实现这一点。在你开始使用这个方法之前，你需要告诉它从故事板中使用哪个单元格。早些时候，当你在故事板中时，你给单元格设置了标识符`birthdayCellIdentifier`（见图 11-4）。这个标识符将你的代码和单元格连接起来，并告诉方法它正在使用正确的单元格。当你调用这个方法时，传入的字符串必须与在故事板中设置的字符串完全一致，否则你会遇到错误，应用程序会崩溃。

在方法`dequeueReusableCell(withIdentifier:for:)`中，你注意到*可重用单元格*这个词了吗？表格视图中的单元格只创建一次，然后可以反复重用。这帮助一切运行得更快、更流畅，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日，但每次屏幕上只能显示 10 个，那么你只需要 10 个单元格来展示这些生日。当你向下滚动以显示更多的生日时，滚出屏幕顶部的单元格将被重用。它们会填充新信息，并重新出现在屏幕的底部。UITableView 会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)`会为每一行可见的单元格调用。当用户滚动查看更多单元格时，这个方法会在每个单元格即将出现在屏幕上时再次被调用。

接下来，我们需要找出应该显示在单元格中的生日。我们希望每行显示一个生日，来自`birthdays`数组。第一个生日，即`birthdays[0]`，应该显示在第 0 行；第二个生日，位于`birthdays[1]`，应该显示在第 1 行，以此类推。这意味着`indexPath`的`row`与我们想要访问的`birthdays`数组中的位置相同。➋处的代码通过使用`indexPath.row`从`birthdays`数组中访问正确的 Birthday 对象。一旦我们拿到正确的 Birthday 对象，我们将其赋值给名为`birthday`的常量，以便为这个单元格设置标签。

注意，我们使用`let`将生日赋值给常量，而不是变量。我们之所以使用`let`，是因为每次`tableView(_:cellForRowAt:)`被调用时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，赋值给各自的 Birthday 对象。由于我们不打算改变任何生日常量——我们只是读取它们的属性——因此我们不想将它们设置为变量。

现在你已经有了单元格和生日，是时候填充详细信息了。你需要两个标签来显示每个单元格中的生日人的姓名和出生日期。你将单元格设置为 Subtitle 样式，这样它就会有一个 Title 标签和一个 Subtitle 标签。每个单元格已经包含了这些标签，所以你现在不需要自己创建任何标签了。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格分隔。在➍处，你使用 dateFormatter 的 string(from:)方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:)会返回该单元格，➎处将其显示在表格视图的相应 indexPath 位置。

### 将所有内容结合起来

现在，你可以通过添加生日视图控制器来将 Birthday 实例添加到应用中，并且你有一个表格视图来列出每个 Birthday，在 Birthdays 表格视图控制器中显示。但是当你尝试运行应用并添加一个 Birthday 时，它没有显示。为了让你添加的每个 Birthday 出现在表格视图中，你需要让添加生日视图控制器与 Birthdays 表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 呈现到自己的上方。A 知道 B 的存在，因为它创建并呈现了 B，所以 A 可以将信息传递给 B。但 B 并不知道 A 的存在——它只是突然出现，并且不知道它是从哪里来的，也不知道怎么到达这里的。那么 B 怎么和 A 交流呢？通过委托！

![](img/Image00245.jpg)

委托就是某人将任务或工作交给另一个人。*委托*就像是一个老板，告诉一个被委托的员工该做什么。当被委托的员工完成任务时，有时会将信息反馈给委托的老板。

在 Swift 中，委托非常相似，但与其说有一个老板和员工，不如说有一个委托和一个委托对象。由于 B 类是被 A 类告知做什么的，所以它是委托对象。我们给 B 类一个名为 delegate 的特殊属性，告诉它它的委托是谁——这样它就知道该与谁沟通。委托可以是任何具有在*协议*中定义的若干方法的类。协议就像是两个类之间的约定，告诉它们委托可以要求委托对象做什么。它列出了委托可以与委托对象一起使用的方法和属性名称。

A 类创建 B 类，使自己成为 B 类的委托，并给 B 类分配一个协议中的任务。一旦 B 类完成任务，它会向 A 类报告。让我们看看在我们的应用程序中是如何工作的。

Birthdays 表格视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将被添加生日视图控制器用来反馈信息。

看一下 图 11-6。当用户点击添加按钮 ➊ 时，生日列表视图控制器会创建添加生日视图控制器 ➋ 并将其自身设置为添加生日视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过代理从添加生日视图控制器传递到生日列表视图控制器。*

`AddBirthdayViewControllerDelegate` 协议被定义为只有一个方法：`addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存按钮 ➌ 时，添加生日视图控制器会调用这个方法 ➍，并将新的生日传递给它的代理，生日列表视图控制器。生日列表视图控制器将该生日添加到它的生日数组中，并重新加载它的表格视图 ➎，以便新添加的生日显示在表格中。

我们将展示如何创建一个 `AddBirthdayViewControllerDelegate` 协议，其中的方法 `addBirthdayViewController(_:didAddBirthday:)` 将在每次生日被添加到应用时由添加生日视图控制器调用。生日列表视图控制器将实现该协议方法，以便每当通过添加生日视图控制器添加生日时，添加生日视图控制器可以告诉它的代理，“嘿！刚刚有人添加了这个生日，”而生日列表视图控制器会收到消息并说，“哦！我将把这个添加到我的列表中并刷新显示，让新的生日显示出来。”

现在我们开始写代码吧！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方*，添加这段代码来定义 `AddBirthdayViewControllerDelegate` 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处定义协议，通过输入关键字 `protocol` 后跟协议名称 `AddBirthdayViewControllerDelegate`。这个名字很长，但 Swift 程序员通常会按照调用类的名称命名协议，并在末尾加上“Delegate”一词。这样，你就能通过查看协议的名称知道哪个类在使用该协议。既然你现在是 Swift 程序员，你应该遵循相同的命名规范。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)` 是唯一的函数，它用于将 Birthday 对象传递回代理类 ➋。注意，你在这个函数中包含了 `AddBirthdayViewController` 作为一个参数。同样，Swift 程序员在实现协议方法时通常这么做，所以你也应该遵循这一做法。知道是谁发送了消息并且让代理能够访问该对象及其类是很有用的。

当 Add Birthday 视图控制器调用此方法时，它会将自身作为 addBirthdayViewController 参数传入。你很快就能看到如何实现这一点。另一个需要注意的点是外部参数名 didAddBirthday。许多代理协议方法包含*did*和*will*，因为它们用来描述调用类刚刚做了某事或将要做某事。

现在你已经定义了协议，接下来需要告诉 Birthdays 表视图控制器采用这个协议并使用该协议的方法。

##### 使 Birthdays 表视图控制器符合协议

为了采用该协议，Birthdays 表视图控制器需要将自己定义为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中添加 AddBirthdayViewControllerDelegate，紧跟在 UITableViewController 超类之后。在类的顶部，给 UITableViewController 后面加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色错误会出现。这是因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！别担心——我们很快就会修复这个问题。

这里需要特别注意的是，BirthdaysTableViewController 是从 UITableViewController 超类派生的。一个类只能有一个超类，而该超类的名称必须写在所有协议之前。但尽管一个类只能有一个超类，它可以采用任意数量的协议——这些协议会列在超类之后，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:)方法。一个合适的添加位置是在类的末尾，即导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期待你添加这个方法。需要注意的是，不像子类化的方法，在 addBirthdayViewController(_:didAddBirthday:)前面不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传入的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:)方法来实现 ➋ 。接下来，你需要刷新表视图，以便它显示这个新添加的生日，可以通过在 tableView 属性上调用 reloadData()方法来实现 ➌ 。当调用 reloadData()时，表视图的数据源方法会重新调用，新添加的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必须的，但将类的不同部分标记出来是一种良好的编码风格，它有助于保持代码的简洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到下拉目录菜单中，您可以在类的顶部使用该菜单。这个下拉菜单帮助你查找方法并跳转到代码中的不同位置。要使用此菜单，请点击编辑器窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：您的类具有内置的目录，可以快速跳转到某个章节。*

##### 为 Add Birthday 视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来告诉 Birthdays 表格视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性来安排这一点，插入以下代码行在 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为直到 Add Birthday 视图控制器创建完成后才能设置它。稍后你会学到在哪里设置代理。

现在 Add Birthday 视图控制器已经有了一个代理，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将生日传递给代理。将 saveTapped(_:) 改成以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

生日对象创建后，代码 ➊ 使用 addBirthdayViewController(_:didAddBirthday:) 将其传回代理。

太好了！你已经完成了对 Add Birthday 视图控制器的更改。现在它有了一个代理，能够监听生日已保存的调用。运行应用程序看看会发生什么。

嗯。。。似乎变化不大。当你添加一个生日时，仍然看不到它出现在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事需要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存与其通信的代理，当保存一个生日时与之对话。但我们从未专门将代理属性设置为 Birthdays 表格视图控制器。因此，现在是时候连接这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除 /* 和 */ 来取消注释该方法。

每当生日表视图控制器放弃其屏幕并且应用通过故事板 segue 切换到另一个视图控制器时，此方法会自动被调用。我们将使用此方法将生日表视图控制器传递到添加生日视图控制器，并将其设置为添加生日视图控制器的委托。请在 prepare(for:sender:) 方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的委托为生日表视图控制器需要三行代码。首先，你需要能够从 segue 参数中获取到 AddBirthdayViewController 对象。Xcode 已经留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个属性叫做 destination，指向正在准备中的 segue 的另一端，但对于这个应用来说，目标并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到导航控制器中，这样你就可以在导航栏中看到取消和保存按钮。所以，你并不指望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。在 ➊ 这一行代码中，你得到了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定子类，因此我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其强制转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你拥有 AddBirthdayViewController 时，可以将其委托设置为 self，即当前的生日表视图控制器 ➌。

现在运行应用并添加一些生日！你在生日表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完成。如果你退出应用后重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学习了如何制作一个表视图控制器来显示你的生日列表。你还学习了如何在添加生日视图控制器中添加生日，然后如何使用委托将生日添加到生日表视图控制器中的生日数组，以便可以显示出来。

在第十二章，你将学习如何将生日保存到你的设备中，这样即使你退出应用并再次启动，它们也会显示出来。为了保存生日，你将使用 Core Data，这是我们在项目开始时就设置好的。

*图 11-5：设置应用使用部分将不同的设备设置分组。*

表格视图的数据源方法会在每次重新加载表格视图时由表格视图控制器调用。当你创建 UITableViewController 的子类时，Xcode 会自动为你提供这些方法模板。你需要实现所有三个方法才能使应用正常工作，尽管你不会直接在代码中调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，这个协议包含了这些数据源方法，用于决定在表格视图中显示什么内容。我们将在“委托”章节（第 166 页）中讨论协议。现在你只需要知道，UITableViewController 使用这些方法来显示其内容，并且它会自动调用这些方法，所以你无需手动调用它们。

我们从 numberOfSections(in:)方法开始。生日表格视图控制器是一个仅显示 Birthday 实例的列表，因此它不需要多个部分。要设置表格视图中的部分数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个 UITableView 作为参数，这个 UITableView 是使用该类作为其数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 自带一个内置的表格视图，并且它会自动与这些方法连接。每个生日将显示在自己的行中。因此，在 tableView(_:numberOfRowsInSection:)方法中，为了为所有的生日显示正确的行数，你需要返回你在 birthdays 数组中拥有的 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少个项目，非常适合这个情况！将这个方法更改为以下内容：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，tableView(_:numberOfRowsInSection:)方法还接受一个名为 section 的 Int 类型参数。当表格视图加载时，该方法会针对每个表格视图中的部分调用。在我们的例子中，只有一个部分，因此我们无需检查表格视图正在显示的是哪一部分。我们知道它是第零部分，并且希望它的行数与生日的数量相同，因此我们写`return birthdays.count`。

最后，你需要实现 tableView(_:cellForRowAt:)方法，以便表格视图知道在每个单元格中放置什么内容。由于该方法已经被注释掉，你需要通过删除/*和*/来取消注释它。（小心不要不小心取消注释它后面的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法`tableView(_:cellForRowAt:)`。这个方法在表格视图加载到屏幕上时被调用。它会为屏幕上的每个单元格调用，并接收两个参数，`tableView`和`indexPath`。你已经知道`tableView`参数的作用了。`IndexPath`是一个 Swift 结构体，用来表示表格视图中某一行的位置。一个`IndexPath`实例有两个属性：`section`和`row`。由于这个方法会被调用多次（每次为表格中的一行），我们需要`indexPath`来知道当前正在配置的是哪个部分和哪一行。`indexPath.section`属性表示部分号，`indexPath.row`表示表格视图单元格的行号。`tableView(_:cellForRowAt:)`中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个`UITableViewCell`

• 确定在`birthdays`数组中的哪个生日将在单元格内显示

• 创建两个标签来显示生日人的姓名和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建`UITableViewCell`。代码在➊的位置通过方法`dequeueReusableCell(withIdentifier:for:)`来实现。在开始使用此方法之前，你需要告诉方法要使用哪个单元格来自故事板。早些时候，在故事板中，你为单元格指定了标识符`birthdayCellIdentifier`（参见图 11-4）。这个标识符将你的代码与单元格关联起来，并告诉方法它正在使用正确的单元格。当你调用这个方法时，字符串必须与在故事板中设置的字符串完全一致，否则会出现错误，导致应用在运行时崩溃。

在方法`dequeueReusableCell(withIdentifier:for:)`中，你注意到*Reusable Cell*这几个字了吗？表格视图中的单元格只会创建一次，然后可以反复使用。这有助于提高速度和流畅度，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来展示这些生日。当你向下滚动以显示更多生日时，滚出屏幕顶部的单元格会被重用。它们会被填充上新的信息，并再次出现在屏幕底部。UITableView 会自动处理这些工作。当表格视图加载时，`tableView(_:cellForRowAt:)`会为每一行可见的单元格调用。当用户滚动以查看更多单元格时，它会再次为每一行调用，正好在该行即将出现在屏幕上时。

接下来，我们需要找出应该显示在单元格中的哪个生日。我们希望在每一行中显示一个来自 birthdays 数组的生日。第一个生日，即 birthdays[0]，应该显示在第 0 行；第二个生日，即 birthdays[1]，应该显示在第 1 行，以此类推，这意味着 indexPath 的行号与我们想要访问的 birthdays 数组中的位置相同。在 ➋ 处，代码通过使用 indexPath.row 从 birthdays 数组中访问正确的 Birthday 对象。一旦我们得到了正确的 Birthday 对象，就将其赋值给一个名为 birthday 的常量，以便我们可以设置该单元格中的标签。

请注意，我们使用 let 将生日赋值给常量，而不是变量。我们之所以使用 let，是因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都会获取它自己的生日常量，并将其分配给对应的 Birthday 对象。由于我们不会修改任何生日常量——我们只是读取它们的属性——因此不需要将它们设为变量。

现在你有了单元格和生日，是时候填充详细信息了。你需要两个标签来显示生日人的名字和出生日期。你将单元格设置为 Subtitle 样式，这样它就有一个标题标签和一个副标题标签。每个单元格已经包含这些标签，因此你不必自己创建标签。

标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。在 ➌ 处，代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间有一个空格。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 在 ➎ 处返回该单元格，以便它可以在表格视图的对应 indexPath 位置显示出来。

### 整合所有内容

现在，你可以通过“添加生日”视图控制器将生日实例添加到应用程序中，并且你有一个表格视图来列出每个生日，显示在生日表格视图控制器中。但是当你尝试运行应用程序并添加一个生日时，它并没有显示。为了让你添加的每个生日在表格视图中显示，你需要让“添加生日”视图控制器与生日表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己之上。A 知道 B，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但 B 并不知道 A——它只是突然出现，并不知道它从哪里来或是如何到达的。那么，B 如何与 A 进行沟通呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项工作或任务交给其他人。*委托者*就像是一个老板，告诉委托员工该做什么。当委托员工完成任务时，有时他们会将信息反馈给委托老板。

Swift 中的委托模式非常相似，但我们不是有老板和员工，而是有委托者和委托对象。由于 B 类是被 A 类告知该做什么的，因此它是委托对象。我们为 B 类提供一个特殊的属性，称为 delegate，用来告诉它它的委托者是谁——这样，它就知道与谁进行通信。委托者可以是任何具有在*协议*中定义的一组方法的类。协议就像是两个类之间的约定，告诉它们委托者可以要求委托对象做什么。它列出了委托者可以在委托对象上使用的方法和属性名称。

A 类创建 B 类，使其成为 B 类的委托者，并给 B 类分配一个在协议中的任务。一旦 B 类完成任务，它会向 A 类报告。让我们看看在我们的应用中如何实现这个过程。

生日列表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议定义一个方法，addBirthdayViewController(_:didAddBirthday:)，这个方法将由添加生日视图控制器用来报告。

看一下图 11-6。当用户点击“添加”按钮 ➊ 时，生日列表视图控制器创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：通过委托将新的生日从添加生日视图控制器传递到生日列表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为有一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，添加生日视图控制器调用此方法 ➍ 并将新的生日传递给它的委托者——生日列表视图控制器。生日列表视图控制器接收到这个生日后，将其添加到它的生日数组中，然后重新加载其表格视图 ➎ ，以便新生日能显示在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并在该协议中定义方法 addBirthdayViewController(_:didAddBirthday:)，这样每当添加生日到应用时，添加生日视图控制器就可以调用该方法。生日列表视图控制器将实现该协议方法，这样每当通过添加生日视图控制器添加一个生日时，添加生日视图控制器只需对它的委托者说：“嘿！有人刚刚添加了这个生日，”然后生日列表视图控制器就会收到这个消息并说：“哦！我会把它加入我的列表并刷新我的显示，确保新生日出现在表格中。”

所以现在让我们在代码中实现这一点！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类的*上方*，添加这段代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处定义协议，通过输入关键字 protocol 后跟 AddBirthdayViewControllerDelegate 这个名称。这是一个很长的名字，但 Swift 程序员通常会根据调用类的名称来命名协议，并在末尾加上 Delegate 这个词。这样，你就能通过查看协议的名称来判断是哪个类在使用这个协议。既然你现在是 Swift 程序员，你也应该遵循这种命名规范。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传递回委托类➋。注意，你在这个函数中包括了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员在实现协议方法时通常遵循这个惯例，所以你也应该坚持这样做。了解是谁发送了消息并让委托类能够访问这个对象及其类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递。很快你就会看到这是如何做到的。另一个需要注意的事情是外部参数名 didAddBirthday。许多委托协议方法包含*did*和*will*这两个词，因为它们用于描述调用类刚刚做过的事情或将要做的事情。

现在你已经定义了协议，需要告诉 Birthdays 表格视图控制器采用这个协议并使用协议的方法。

##### 让 Birthdays 表格视图控制器遵循协议

为了采用协议，Birthdays 表格视图控制器需要将自己定义为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在 UITableViewController 父类之后将 AddBirthdayViewControllerDelegate 添加到类定义中。在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，就会出现一个红色的错误。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但还没有实现这个协议！为了实现它，需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 的子类。一个类只能有一个父类，并且父类的名称必须写在任何协议之前。但尽管一个类只能有一个父类，它可以采用任意多个协议——这些协议会在父类之后列出，并用逗号隔开。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期待你添加这个方法。请注意，与子类化方法不同，添加 addBirthdayViewController(_:didAddBirthday:) 时你不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将由 Add Birthday 视图控制器传递的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来完成这一操作 ➋。接下来，你需要刷新表格视图，以便显示这个新添加的生日，通过调用 tableView 属性的 reloadData() 方法 ➌。当调用 reloadData() 时，表格视图的数据源方法会被重新调用，新添加的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但标记类的不同部分是良好的编码风格，有助于保持代码清晰和易于阅读。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到一个可用于跳转的下拉目录菜单中。这个下拉菜单帮助你找到方法，并让你在代码中快速跳转到不同的位置。要使用这个菜单，点击编辑窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器设置委托

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知 Birthdays 表格视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性，来安排这一点，方法是在 outlets 下方插入以下代码：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在创建 Add Birthday 视图控制器之后才能设置委托。你很快就会学习到在哪里设置委托。

现在，“添加生日”视图控制器已经有了委托，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日传递给委托。将 saveTapped(_:) 更改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 将其传递给委托。

太好了！你已经完成了对“添加生日”视图控制器的修改。现在它有了一个委托，用于监听生日保存的调用。运行应用程序看看会发生什么。

嗯……似乎没什么变化。当你添加生日时，依然没有在生日表格视图控制器中看到它的显示。怎么回事？

#### 通过设置委托连接两个控制器

还有最后一件事需要做。生日表格视图控制器是 AddBirthdayViewControllerDelegate，且“添加生日”视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存着当生日被保存时，进行通信的委托。但我们从未专门将委托属性设置为生日表格视图控制器。所以现在是时候在两个视图控制器之间建立通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个方法被注释掉了，叫做 prepare(for:sender:)。通过删除它周围的 /* 和 */ 来取消注释这个方法。

每当生日表格视图控制器放弃其屏幕，并且应用程序通过 storyboard segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将生日表格视图控制器传递给“添加生日”视图控制器，以设置它为“添加生日”视图控制器的委托。在 prepare(for:sender:) 方法中写下以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的委托为生日表格视图控制器需要三行代码。首先，你需要能够通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，用于表示此方法中正在准备的 segue 的目标，但此应用程序的目标并不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到一个导航控制器中，这样你就能拥有带有取消和保存按钮的导航栏。因此，你并不期望在 segue 的另一端找到“添加生日”视图控制器。而是，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊ 处的代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 ViewController 的一个特定类型，我们需要使用 as 进行类型转换，转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前显示在 navigationController 中的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 后，你可以将代理设置为 self，即当前的生日表格视图控制器 ➌。

现在运行应用并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用并再次启动，之前的生日会消失。我们仍然需要将生日保存到设备中，接下来我们将在第十二章中完成这一步。

### 你学到了什么

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学习了如何在 Add Birthday 视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表格视图控制器中的生日数组，以便能够显示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使你退出应用并再次启动，它们依然会显示出来。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

每次表格视图重新加载时，表格视图控制器会调用表格视图数据源方法。当你创建 UITableViewController 的子类时，Xcode 会自动为你提供这些方法的模板。你需要实现所有三个方法，才能使应用正常工作，尽管你不会在代码中直接调用它们。UITableViewController 类实现了 UITableViewDataSource 协议，该协议包含这些数据源方法，用于确定表格视图中将显示的内容。我们将在第 166 页的“委托”中讨论协议。目前，你只需要知道 UITableViewController 使用这些方法来显示内容，并会自动调用这些方法，因此你不需要手动调用它们。

让我们从方法 numberOfSections(in:)开始。生日表格视图控制器是一个只显示 Birthday 实例的列表，因此它不需要多个部分。为了设置表格视图中的部分数，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个 UITableView 参数 tableView，它是使用该类作为数据源的表格视图。我们不需要担心如何建立这个连接，因为 UITableViewController 自带了一个内置的表格视图，并且已经自动与这些方法连接。每个生日都会显示在自己的行中。因此，在 tableView(_:numberOfRowsInSection:)方法中，为了获得所有生日的正确行数，你需要返回你在 birthdays 数组中拥有的 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，告诉你数组中有多少个项目，正好适用于这种情况！将这个方法更改为以下代码：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数，tableView(_:numberOfRowsInSection:)还接受一个名为 section 的 Int。当表格视图加载时，这个方法会为表格视图中的每个 section 调用。在我们的例子中，只有一个 section，所以我们不需要检查当前显示的是哪个 section。我们知道它是 section 0，并且希望它的行数等于生日的数量，所以我们写 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:)方法，以便表格视图知道在每个单元格中放入什么内容。由于这个方法被注释掉了，你需要通过删除/*和*/来取消注释它。（小心不要不小心取消注释它后面的其他方法！）完成后，将它更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要直接调用方法 tableView(_:cellForRowAt:)。它是在表格视图加载到屏幕时被调用的。它会为每个屏幕上的单元格调用，并接受两个参数：tableView 和 indexPath。你已经知道 tableView 参数的作用了。IndexPath 是一个 Swift 结构体，用于表示表格视图中行的位置。一个 IndexPath 实例包含 section 属性和 row 属性。由于这个方法会被多次调用（每个表格行调用一次），我们需要 indexPath 来知道当前配置的是哪个 section 和 row。indexPath.section 属性给出 section 的编号，indexPath.row 给出表格视图单元格的行号。tableView(_:cellForRowAt:)方法中的五行代码将完成以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 找出哪个 Birthday 将在单元格中显示

• 创建两个标签来显示生日人物的名字和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。代码 ➊ 使用 dequeueReusableCell(withIdentifier:for:) 方法来完成这项工作。然而，在开始使用这个方法之前，你需要告诉该方法你希望使用哪个来自故事板的单元格。之前在故事板中，你给单元格设置了标识符 birthdayCellIdentifier（见 图 11-4）。这个标识符将你的代码与单元格连接起来，并告诉你的方法它正在使用正确的单元格。当你调用这个方法时，传入的字符串必须与故事板中设置的字符串完全相同，否则你会遇到错误，应用程序在运行时会崩溃。

在 dequeueReusableCell(withIdentifier:for:) 方法中，你注意到 *可重用单元格* 这几个字了吗？表视图中的单元格只会创建一次，然后可以反复重用。这有助于提高程序的运行速度和流畅度，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，滚动出屏幕顶部的单元格将被重用。它们会被填充上新的信息，并重新出现在屏幕底部。UITableView 会自动完成这个工作。当表视图加载时，tableView(_:cellForRowAt:) 会为每个可见的行调用。当用户滚动查看更多单元格时，它会在每个单元格即将出现在屏幕上时再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日，即 birthdays[0]，应该显示在第 0 行；第二个生日，即 birthdays[1]，应该显示在第 1 行，以此类推，这意味着 indexPath 的行号与我们希望访问的 birthdays 数组中的位置相同。代码 ➋ 通过使用 indexPath.row 从 birthdays 数组中访问正确的生日对象。一旦我们获取到正确的生日对象，我们将其赋值给一个名为 birthday 的常量，这样我们就可以设置该单元格中的标签了。

注意，我们使用 let 将生日赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都会获得一个自己的生日常量，并将其分配给自己的 Birthday 对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以我们不想将它们设置为变量。

现在你已经有了单元格和生日，是时候填写详细信息了。你需要为每个单元格创建两个标签，用于显示生日人的名字和出生日期。你将单元格设置为 Subtitle 样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，因此现在你不需要自己创建任何标签。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 构成的字符串，中间有一个空格。在➍处，你使用 dateFormatter 的 string(from:)方法在 detailTextLabel 中显示出生日期。

当你的单元格完全配置好后，tableView( _:cellForRowAt:) 会返回该单元格，➎ 这样它就可以在表视图的对应 indexPath 位置显示。

### 将一切整合在一起

现在你可以使用“添加生日”视图控制器将生日实例添加到应用程序中，并且你有一个表视图来列出每个生日，在“生日”表视图控制器中。但当你尝试运行应用程序并添加一个生日时，它并没有出现。为了使你添加的每个生日都出现在表视图中，你需要让“添加生日”视图控制器与“生日”表视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 呈现在自己之上。A 知道 B，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但 B 不知道 A——它只是被创建出来，并不知道自己从哪里来，也不知道是怎么到那里的。那么，B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将任务或工作交给别人去做。*委托*就像是一个老板，告诉一个委托员工该做什么。当委托员工完成任务后，有时他们会向委托老板报告信息。

Swift 中的委托机制非常类似，但不是有一个老板和员工，而是有一个委托和一个委托对象。由于 B 类是被 A 类告知该做什么的对象，所以它是委托对象。我们为 B 类提供一个特殊的属性，称为 delegate，来告诉它谁是它的委托——这样它就知道应该与谁进行沟通。委托可以是任何一个类，只要它有一组在*协议*中定义的方法。协议就像是两个类之间的协议，告诉它们委托可以要求委托对象做什么。它有一个方法和属性的列表，委托可以在与委托对象交互时使用。

A 类创建 B 类，使自己成为 B 类的委托，并为 B 类分配一个在协议中定义的任务。B 类完成任务后，会向 A 类报告。让我们看看这个在应用中是如何工作的。

“生日”表视图控制器是视图控制器 A，而“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法：addBirthdayViewController(_:didAddBirthday:)，该方法将由“添加生日”视图控制器用来报告返回的信息。

看一下 图 11-6。当用户点击添加按钮 ➊ 时，Birthdays 表格视图控制器创建 Add Birthday 视图控制器 ➋ 并将自己设置为 Add Birthday 视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，Add Birthday 视图控制器调用此方法 ➍ 并将新的生日传递给其委托，Birthdays 表格视图控制器。Birthdays 表格视图控制器接收该生日，将其添加到 birthdays 数组中，然后重新加载其表格视图 ➎，以便新生日能够出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义 addBirthdayViewController(_:didAddBirthday:) 方法，Add Birthday 视图控制器可以在每次添加生日时调用该方法。Birthdays 表格视图控制器将实现该协议方法，这样每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器只需对其委托说：“嘿！有人刚刚添加了这个生日”，而 Birthdays 表格视图控制器将会收到消息并回应：“哦！我会将其添加到我的列表中并刷新显示，让新的生日显示出来。”

现在，让我们开始编写代码！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方*，添加定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过输入关键字 protocol 然后是 AddBirthdayViewControllerDelegate 来定义协议 ➊。这个名字很长，但 Swift 程序员通常会根据调用类的名称来命名协议，并在末尾加上 Delegate 这个词。这样你就能通过查看协议的名称来判断哪个类在使用该协议。既然你现在是 Swift 程序员，你应该遵循这种命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象返回给委托类 ➋。注意，在这个函数中你包含了 AddBirthdayViewController 作为参数。再次提醒，这是 Swift 程序员在实现协议方法时的惯例，因此你也应该遵循。这样做有助于了解是谁发回了消息，并且委托可以访问该对象及其类。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递。你很快就会看到如何实现这一点。另一个需要注意的是外部参数名 didAddBirthday。许多委托协议方法包含 *did* 和 *will*，因为它们用来描述调用类刚刚做过的事或将要做的事。

现在你已经定义了协议，你需要告诉 Birthdays table view controller 遵循这个协议并使用该协议的方法。

##### 让 Birthdays Table View Controller 遵守协议

为了遵循这个协议，Birthdays table view controller 需要使自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在 UITableViewController 超类之后，在类定义中添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，一个红色的错误就会出现。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心，我们很快就会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，而且这个超类的名称必须在任何协议之前写出。但尽管一个类只能有一个超类，它可以遵循任意多个协议——这些协议都会列在超类后面，并且由逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的位置是在类的末尾，紧接在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成会建议你整个方法声明。这是因为它知道这个类遵循了 AddBirthdayViewController Delegate 协议，并且期望你添加这个方法。请注意，不像子类化方法那样，你在 addBirthdayViewController(_:didAddBirthday:) 前面不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的生日添加到 birthdays 数组中。你可以通过使用 append(_:) 方法来做到这一点 ➋。接下来，你需要刷新表格视图，使其显示这个新添加的生日，通过调用 tableView 属性的 reloadData() 方法 ➌。当调用 reloadData() 时，表格视图的数据源方法会再次被调用，新的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必需的，但标记类的不同部分是一个良好的编码风格，有助于保持代码的整洁和可读性。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你找到方法，并让你跳转到代码中的不同位置。要使用这个菜单，点击编辑器面板顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个章节。*

##### 为 Add Birthday 视图控制器设置代理

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表格视图控制器它已经添加了一个生日。为了做到这一点，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性来安排这一点，并将以下代码插入到 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在创建 Add Birthday 视图控制器之前你无法设置它。稍后你会学习在哪里设置代理。

现在，Add Birthday 视图控制器有了代理，在 `saveTapped(_:)` 方法中，你可以通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将生日传递给代理。将 `saveTapped(_:)` 更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊ 处的代码通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将其传回给代理。

很好！你已经完成了对 Add Birthday 视图控制器的修改。它现在有了一个代理，能够监听生日已保存的调用。运行应用看看会发生什么。

嗯……变化不大。当你添加一个生日时，你仍然没有看到它出现在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有一件事你必须做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存着当生日保存时与之通信的代理。但是我们从未明确地将代理属性设置为 Birthdays 表格视图控制器。所以现在是时候在我们两个视图控制器之间建立通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除/*和*/来取消注释该方法。

每当生日表视图控制器放弃屏幕并且应用程序通过故事板 segue 过渡到另一个视图控制器时，这个方法会自动调用。我们将使用这个方法将生日表视图控制器传递给添加生日视图控制器，并将其设置为添加生日视图控制器的代理。在 prepare(for:sender:)方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

需要三行代码将添加生日视图控制器的代理设置为生日表视图控制器。首先，你需要能够通过 segue 参数访问 AddBirthdayViewController 对象。Xcode 已经在注释中给出了如何做到这一点的提示。UIStoryboardSegue 有一个叫做 destination 的属性，用于准备中的 segue 的另一端，但对于这个应用程序，destination 并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到一个导航控制器中，以便拥有一个带有取消和保存按钮的导航栏。所以你不应该期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。在➊处的代码可以让你获取到 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 ViewController 的特定类型，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其类型转换为 AddBirthdayViewController，以表示该控制器是 UIViewController 的特定子类。最后，当你拥有一个 AddBirthdayViewController 时，你可以将代理设置为 self，它当前是生日表视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表视图控制器中看到什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用程序然后重新运行它，之前的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在这一章中，你学习了如何创建一个表视图控制器来显示你的生日列表。你还学习了如何在添加生日视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表视图控制器中的生日数组，以便它能够被显示。

在 第十二章 中，你将学习如何将生日保存到设备上，这样即使你退出应用并再次运行，它们也会显示出来。为了保存这些生日，你将使用 Core Data，我们在项目的开始部分就已经设置好了它。

我们从 `numberOfSections(in:)` 方法开始。Birthdays 表格视图控制器是一个只显示 Birthday 实例的列表，因此它不需要多个 section。为了设置表格视图中的 section 数量，我们只需要返回 1。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 tableView 的 UITableView 参数，它是使用此类作为数据源的表格视图。我们不需要担心建立这个连接，因为 UITableViewController 自带了一个内置的表格视图，并且会自动与这些方法连接。每个生日将显示在自己的行中。所以在 `tableView(_:numberOfRowsInSection:)` 中，为了确保你的表格有正确数量的行，你需要返回你在 birthdays 数组中的 Birthday 实例数量。你记得数组的 count 属性吗？它是一个整数，表示数组中有多少个项目，正好适合这个情况！将这个方法改成如下：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，`tableView(_:numberOfRowsInSection:)` 还接受一个名为 section 的 Int 参数。当表格视图加载时，这个方法会为表格中的每个 section 调用一次。在我们的情况下，我们只有一个 section，所以我们不需要检查表格视图中正在显示哪个 section。我们知道它是 section 0，并且我们希望它有和生日数量一样多的行，所以我们写 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)`，这样表格视图就知道在每个单元格中放什么。由于这个方法已经被注释掉，你需要通过删除围绕它的 `/*` 和 `*/` 来取消注释它。（小心不要不小心取消注释它后面的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法 `tableView(_:cellForRowAt:)`。它会在表格视图加载到屏幕上时被调用。它会为屏幕上的每个单元格调用，并接受两个参数：tableView 和 indexPath。你已经知道 tableView 参数的用途。IndexPath 是一个 Swift 结构体，用于表示表格视图中某一行的位置。一个 IndexPath 实例有两个属性：section 和 row。由于这个方法会被多次调用（每一行都会调用一次），我们需要 indexPath 来知道我们当前正在配置哪个 section 和 row。indexPath.section 属性提供了 section 编号，indexPath.row 提供了表格视图单元格的行号。`tableView(_:cellForRowAt:)` 方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定应该在单元格内显示 birthdays 数组中的哪个生日

• 创建两个标签来显示生日人物的姓名和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。➊ 处的代码通过使用方法 dequeueReusableCell(withIdentifier:for:) 来实现这一点。然而，在你开始使用这个方法之前，你需要告诉它你想从故事板中使用哪个单元格。之前，当你在故事板中时，你给单元格设置了标识符 birthdayCellIdentifier（见 图 11-4）。这个标识符将你的代码和单元格联系起来，并告诉你的方法它正在使用正确的单元格。调用这个方法时传入的字符串必须与故事板中设置的字符串完全相同，否则你会遇到错误，应用程序会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:) 中，你注意到 *可重用单元格* 这个词了吗？表格视图中的单元格只会创建一次，然后可以反复重用。这有助于提高运行速度和流畅度，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能显示 10 个，那么你只需要 10 个单元格来展示你的生日。当你向下滚动以显示更多的生日时，滚出屏幕顶部的单元格将会被重用。它们会被填充新的信息，并再次出现在屏幕底部。UITableView 会自动完成这些工作。当表格视图加载时，会为每一行可见的行调用 tableView(_:cellForRowAt:)。当用户滚动以查看更多单元格时，它会在每行即将出现在屏幕上时再次被调用。

接下来，我们需要找出应该在单元格内显示哪个生日。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日，位于 birthdays[0]，应该显示在第 0 行。第二个生日，位于 birthdays[1]，应该显示在第 1 行，以此类推，这意味着 indexPath 的 row 和我们想要访问的 birthdays 数组中的位置是相同的。➋ 处的代码通过使用 indexPath.row 访问正确的 Birthday 对象。一旦我们拿到正确的 Birthday 对象，就将它赋值给名为 birthday 的常量，这样我们就可以设置这个单元格中的标签了。

注意，我们使用 let 来将 birthday 赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的 birthday 常量。每个单元格都有自己的 birthday 常量，并且赋值给它自己的 Birthday 对象。由于我们不会更改任何 birthday 常量——我们只是读取它们的属性——因此我们不希望将它们设置为变量。

现在，您已经有了单元格和生日，是时候填写详细信息了。您需要为每个单元格添加两个标签，分别显示生日人的姓名和出生日期。您将单元格设置为副标题样式，这样它就有一个标题标签和一个副标题标签。每个单元格已经包含这些标签，因此现在您不需要自己创建任何标签。

标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。➌处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，并且两者之间有一个空格。➍处，您使用 dateFormatter 的 string(from:)方法将出生日期显示在 detailTextLabel 中。

当您的单元格完全配置好时，tableView(_:cellForRowAt:)会在➎处返回该单元格，以便可以在表格视图的该 indexPath 上显示。

### 综合起来

现在，您可以使用“添加生日”视图控制器将 Birthday 实例添加到应用程序中，并且您有一个表格视图来列出 Birthdays 表格视图控制器中的每个 Birthday。但是当您尝试运行应用并添加一个 Birthday 时，它并没有显示出来。为了让您添加的每个 Birthday 都出现在表格视图中，您需要让“添加生日”视图控制器与 Birthdays 表格视图控制器进行通信。您可以通过使用*委托*来实现这一点。

#### 委托

委托可用于当一个视图控制器需要从另一个视图控制器获取信息时。假设您有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 呈现到自己之上。A 了解 B，因为它创建并呈现了 B，因此 A 可以将信息传递给 B。但 B 并不了解 A——它只是突然出现在那里，并不知道它从哪里来，也不知道是如何到达那里。那么，B 怎么与 A 进行通信呢？通过委托！

![](img/Image00245.jpg)

委托是指有人将工作或任务交给别人。*委托人*就像一个老板，告诉委派员工该做什么。当委派员工完成任务后，有时他们会将信息报告给委托人。

在 Swift 中，委托非常相似，但我们没有老板和员工的关系，而是有委托和委托对象。由于类 B 是由类 A 指示做什么的，因此它是委托对象。我们给类 B 一个特殊的属性，称为 delegate，以告诉它谁是它的委托对象——这样，它就知道要与谁进行通信。委托对象可以是任何具有已定义方法集合的类，这些方法是在*协议*中定义的。协议就像是两个类之间的协议，告诉它们委托对象可以要求委托对象做什么。协议包含委托可以与委托对象一起使用的方法和属性名称列表。

类 A 创建类 B，使自己成为类 B 的委托对象，并给类 B 一个在协议中定义的任务。一旦类 B 完成任务，它会将信息报告给类 A。让我们看看在我们的应用程序中是如何工作的。

生日表格视图控制器是视图控制器 A，而添加生日视图控制器是视图控制器 B。我们将创建一个协议，名为 AddBirthdayViewControllerDelegate，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用来报告。

看看 图 11-6。当用户点击添加按钮 ➊ 时，生日表格视图控制器创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从添加生日视图控制器传递到生日表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为包含一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，添加生日视图控制器调用这个方法 ➍，并将新生日传递给它的委托，即生日表格视图控制器。生日表格视图控制器将接收到这个生日，将其添加到自己的生日数组中，然后重新加载表格视图 ➎，以便新生日能够显示在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并为其定义方法 addBirthdayViewController(_:didAddBirthday:)，该方法将在每次有生日添加到应用时由添加生日视图控制器调用。生日表格视图控制器将实现该协议方法，以便每次通过添加生日视图控制器添加生日时，添加生日视图控制器只需对其委托说：“嘿！有人刚刚添加了这个生日。”而生日表格视图控制器会接收到这个消息并回应：“哦！我会把它添加到我的列表中，并刷新我的显示，让新添加的生日出现在列表中。”

现在让我们在代码中实现这个功能！

##### 创建一个协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，*在* AddBirthdayViewController 类的上方，添加以下定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处通过输入关键字 protocol 来定义协议，后面跟着协议名 AddBirthdayViewControllerDelegate。这是个长名字，但 Swift 程序员通常会根据调用类的名字来命名协议，并在后面加上 Delegate 这个词。这样，你就能通过协议的名字看出哪个类在使用这个协议。既然你现在是 Swift 程序员了，你也应该使用相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传递回委托类➋。注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员在实现协议方法时会基于约定这样做，所以你也应该遵循这种做法。这样做有助于知道是谁发送回了消息，并且使委托能够访问该对象及其类。

当 Add Birthday 视图控制器调用此方法时，它会将自己作为 addBirthdayViewController 参数传递。你很快就会看到这是如何做到的。另一个需要注意的地方是外部参数名 didAddBirthday。许多委托协议方法都包含*did*和*will*这两个词，因为它们用于描述调用类已经做了或将要做的事情。

现在你已经定义了协议，需要告诉 Birthdays table view controller 采用这个协议并使用协议的方法。

##### 使 Birthdays Table View Controller 符合协议

为了采用这个协议，Birthdays table view controller 需要使自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中紧接 UITableViewController 父类之后添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，就会出现一个红色的错误。这是因为 BirthdaysTableViewController 说它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快就会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是从 UITableViewController 类继承的。一个类只能有一个父类，并且这个父类的名称必须写在任何协议之前。但是，虽然一个类只能有一个父类，它可以采用尽可能多的协议——这些协议会在父类后列出，并且用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:)方法添加到 BirthdaysTableViewController 中。一个合适的地方是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动完成功能会建议你使用整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期待你添加这个方法。注意，与子类化的方法不同，你在 addBirthdayViewController(_:didAddBirthday:)前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将添加生日视图控制器传递进来的生日添加到 birthdays 数组中。你可以通过使用 append(_:) 方法来为数组添加元素 ➋ 。接下来，你需要刷新表格视图，以便显示这个新添加的生日，可以通过调用 tableView 属性上的 reloadData() 方法 ➌ 来实现。当调用 reloadData() 时，表格视图的数据源方法将再次被调用，新添加的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这并不是必需的，但标记类的不同部分是良好的编码风格，有助于保持代码整洁和可读。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单帮助你找到方法并跳转到代码中的不同位置。要使用这个菜单，请点击编辑窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类内置了一个目录，可以快速跳转到某个章节。*

##### 给添加生日视图控制器设置委托

BirthdaysTableViewController 已采用 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉生日列表视图控制器何时添加了一个生日。为此，添加生日视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中插入以下代码行，在 outlets 下面添加一个可选的委托属性，类型为 AddBirthdayViewControllerDelegate 来安排这一点：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在创建添加生日视图控制器之后才能设置它。你很快就会学到如何设置委托。

现在添加生日视图控制器有了一个委托，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将生日传递给委托。将 saveTapped(_:) 更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 将其传递给委托。

很好！你已经完成了对添加生日视图控制器的更改。现在它有了一个委托，将监听生日保存的调用。运行应用程序查看发生了什么。

嗯……似乎变化不大。当你添加一个生日时，仍然看不到它在生日列表视图控制器中显示。怎么回事？

#### 通过设置委托连接两个控制器

你还需要做最后一件事。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 类型的属性，用来保存与之通信的代理对象，当一个生日被保存时，它会与该代理进行交互。但我们从未明确设置代理属性为 Birthdays 表视图控制器。因此，现在是时候建立两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个名为 prepare(for:sender:) 的方法被注释掉了。通过删除/*和*/注释符号，取消注释该方法。

每当 Birthdays 表视图控制器放弃其屏幕并且应用通过 storyboard segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将 Birthdays 表视图控制器传递给 Add Birthday 视图控制器，以便将其设置为 Add Birthday 视图控制器的代理。在 prepare(for:sender:) 方法中编写以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的代理为 Birthdays 表视图控制器，只需三行代码。首先，你需要能够通过 segue 参数获取到 AddBirthdayViewController 对象。Xcode 在注释中提示了如何实现这一点。UIStoryboardSegue 在这个方法中准备的 segue 的另一端有一个名为 destination 的属性，但对于这个应用来说，目标视图控制器并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到导航控制器中，以便拥有带有取消和保存按钮的导航栏。因此，你不会在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个 UINavigationController，其中包含 Add Birthday 视图控制器。➊ 这一行代码让你获得了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定子类，因此我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取到 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但其属性类型是 UIViewController，因此必须将其强制转换为 AddBirthdayViewController，以表明这是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 后，你可以将代理设置为 self，也就是当前的 Birthdays 表视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过我们还没完成。如果你退出应用程序然后再运行，它之前的生日会消失。我们还需要将生日保存到设备上，接下来我们将在第十二章中完成这项工作。

### 你学到了什么

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表格视图控制器中的生日数组，以便它可以被显示出来。

在第十二章中，你将学习如何将生日保存到设备中，以便即使退出应用程序并重新运行，它们依然会显示出来。为了保存生日，你将使用 Core Data，这是我们在项目开始时设置的技术。

*BirthdaysTableViewController.swift*

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 `tableView` 的 UITableView 作为参数，它是使用此类作为数据源的表格视图。我们不需要担心建立这个连接，因为 `UITableViewController` 自带一个内建的表格视图，并且会自动连接到这些方法。每个生日都会显示在自己的行中。所以在 `tableView(_:numberOfRowsInSection:)` 中，为了让表格视图有正确数量的行来显示所有的生日，你需要返回 `birthdays` 数组中生日实例的数量。你还记得数组的 `count` 属性吗？它是一个整数，告诉你数组中有多少个项目，非常适合这种情况！将这个方法改为以下代码：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 `tableView` 参数外，`tableView(_:numberOfRowsInSection:)` 还接受一个名为 `section` 的 Int 类型参数。当表格视图加载时，这个方法会为表格视图中的每个部分调用一次。在我们的例子中，我们只有一个部分，因此不需要检查表格视图中正在显示的是哪个部分。我们知道是第零部分，我们希望它有与生日数量相同的行数，所以我们写 `return birthdays.count`。

最后，你需要实现 `tableView(_:cellForRowAt:)`，这样表格视图就知道在每个单元格中放入什么内容。由于这个方法被注释掉了，你需要通过删除 `/*` 和 `*/` 来取消注释它。（小心不要不小心取消注释它后面的其他方法！）完成后，将其改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要直接调用方法`tableView(_:cellForRowAt:)`。当表格视图被加载到屏幕上时，这个方法会被自动调用。它会为每个在屏幕上的单元格调用，并接受两个参数：`tableView`和`indexPath`。你已经知道`tableView`参数的作用了。`IndexPath`是一个 Swift 结构体，用于表示表格视图中某一行的位置。一个`IndexPath`实例有`section`和`row`属性。由于这个方法会被多次调用（每行一个），我们需要通过`indexPath`来知道当前配置的是哪个部分和哪一行。`indexPath.section`属性提供部分号，`indexPath.row`提供表格视图单元格的行号。`tableView(_:cellForRowAt:)`方法中的五行代码将完成以下操作：

![](img/Image00244.jpg)

• 创建一个`UITableViewCell`

• 确定`birthdays`数组中将显示在哪个生日的单元格里

• 在单元格中制作两个标签，显示生日人的名字和出生日期

• 返回准备好在表格视图中显示的单元格

让我们逐行分析这段代码。

首先，创建`UITableViewCell`。代码中的➊部分使用`dequeueReusableCell(withIdentifier:for:)`方法来完成这项工作。不过，在你开始使用此方法之前，你需要告诉它要使用哪个单元格。这是因为你需要在故事板中指定单元格的标识符。早些时候，当你在故事板中时，你给单元格设置了标识符`birthdayCellIdentifier`（见图 11-4）。这个标识符将你的代码与单元格关联起来，告诉方法你正在使用正确的单元格。当你调用此方法时，传递的字符串必须与在故事板中设置的字符串完全相同，否则你会遇到错误，应用程序会崩溃。

在方法`dequeueReusableCell(withIdentifier:for:)`中，你注意到*可重用单元格*这几个词了吗？表格视图中的单元格只创建一次，然后可以重复使用。这有助于提高效率，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日，但一次只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，屏幕顶部滚出的单元格会被重用。这些单元格会填充新的信息，并在屏幕底部重新显示。`UITableView`会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)`会为每一行可见的单元格被调用。当用户滚动查看更多单元格时，每当某一行即将出现在屏幕上时，`tableView(_:cellForRowAt:)`会再次被调用。

接下来，我们需要找出应该在单元格中显示哪一个生日。我们希望在每一行中显示 birthdays 数组中的一个生日。第一个生日，即 birthdays[0]，应该显示在第 0 行。第二个生日，位于 birthdays[1]，应该显示在第 1 行，依此类推，这意味着 indexPath 的 row 与我们希望访问的 birthdays 数组中的位置是相同的。代码在 ➋ 处通过使用 indexPath.row 来访问 birthdays 数组中的正确 Birthday 对象。一旦我们得到了正确的 Birthday 对象，我们将它分配给名为 birthday 的常量，以便我们能够设置此单元格中的标签。

注意，我们使用 let 将生日赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并且被分配了自己的 Birthday 对象。由于我们不打算更改任何生日常量——我们只是读取它们的属性——所以我们不需要将它们设为变量。

现在你已经有了单元格和生日信息，是时候填写细节了。你需要为每个单元格添加两个标签，用来显示生日人的名字和出生日期。你将单元格设置为副标题样式，这样它就有了标题标签和副标题标签。每个单元格已经包含了这些标签，所以现在你不需要自己创建标签了。

标签作为 UITableViewCell 的属性存在，分别被称为 textLabel 和 detailTextLabel。代码在 ➌ 处将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，并在两者之间加一个空格。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法来在 detailTextLabel 中显示出生日期。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 会返回在 ➎ 处的单元格，以便它可以在该 indexPath 位置的表格视图中显示。

### 将一切结合起来

现在你可以使用添加生日视图控制器将生日实例添加到应用程序中，并且你有一个表格视图来列出每个生日，显示在生日表格视图控制器中。但当你尝试运行应用程序并添加生日时，它没有显示出来。为了使你添加的每个生日都能出现在表格视图中，你需要让添加生日视图控制器与生日表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在它自身之上。A 知道 B 的存在，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 并不知道 A 的存在——它只是被突然创建出来的，不知道它从哪里来，也不知道怎么到达那里。那么，B 如何与 A 进行通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将工作或任务交给另一个人。*委托*就像是一个老板，告诉一个被委托的员工该做什么。当被委托的员工完成任务时，有时会将信息反馈给委托的老板。

Swift 中的委托模式非常相似，但不同于老板和员工，我们有委托对象和委托接收对象。由于 B 类是被 A 类指示要做某事的对象，所以 B 类是委托接收对象。我们给 B 类一个特殊的属性，称为 delegate，来告诉它它的委托对象是谁——这样，它就知道应该与谁进行通信。委托对象可以是任何一个拥有在*协议*中定义的方法集的类。协议就像是两个类之间的约定，告诉它们委托对象可以要求委托接收对象做什么。它包含了一系列方法和属性名称，委托对象可以用这些名称与委托接收对象交互。

A 类创建 B 类，使自己成为 B 类的委托对象，并给 B 类分配一个协议中的任务。一旦 B 类完成了任务，它会向 A 类报告。让我们看看在我们的应用中如何实现这一点。

Birthdays 表格视图控制器是视图控制器 A，而 Add Birthday 视图控制器是视图控制器 B。我们将创建一个协议，命名为 AddBirthdayViewControllerDelegate，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，这个方法将被 Add Birthday 视图控制器用来进行报告。

看看图 11-6。当用户点击添加按钮 ➊ 时，Birthdays 表格视图控制器创建 Add Birthday 视图控制器 ➋ 并将自己设置为 Add Birthday 视图控制器的委托对象。

![](img/Image00246.jpg)

*图 11-6：通过委托，新的生日从 Add Birthday 视图控制器传递给 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为包含一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，Add Birthday 视图控制器调用这个方法 ➍ 并将新的生日传递给它的委托对象，即 Birthdays 表格视图控制器。Birthdays 表格视图控制器接收该生日，将其添加到它的生日数组中，然后重新加载表格视图 ➎ ，以便新的生日能显示在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，其中包含 addBirthdayViewController(_:didAddBirthday:)方法，该方法将在每次为应用添加新生日时由 Add Birthday 视图控制器调用。Birthdays 表格视图控制器将实现该协议方法，这样每当 Add Birthday 视图控制器添加一个新生日时，Add Birthday 视图控制器可以对其委托对象说，“嘿！刚刚添加了这个生日，”然后 Birthdays 表格视图控制器会听到这个消息并回应，“哦！我会把它添加到我的列表中，并刷新我的显示以便新添加的生日显示出来。”

现在让我们在代码中实现这个功能吧！

##### 创建协议

首先，我们需要创建协议。在`*AddBirthdayViewController.swift*`文件中，*在*`AddBirthdayViewController`类的上方，添加这段代码来定义`AddBirthdayViewControllerDelegate`协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊定义协议时，通过输入关键字`protocol`后跟协议名称`AddBirthdayViewControllerDelegate`来实现。这个名称很长，但 Swift 程序员通常会根据调用类来命名协议，并在末尾加上“Delegate”这个词。这样，你就可以通过查看协议的名称，判断哪个类正在使用这个协议。既然你现在是 Swift 程序员了，就应该遵循相同的命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)`是唯一的函数，它用于将`Birthday`对象传回给代理类 ➋。请注意，你在这个函数中包含了`AddBirthdayViewController`作为参数。这是 Swift 程序员在实现协议方法时遵循的约定，所以你也应该这样做。了解是谁传回消息并让代理访问该对象及其类是很有用的。

当`AddBirthdayViewController`调用这个方法时，它会将自身作为`addBirthdayViewController`参数传入。你很快就会看到是如何做到的。另一个需要注意的是外部参数名`didAddBirthday`。许多代理协议方法包含`*did*`和`*will*`这两个词，因为它们用于描述调用类刚刚做过的事情或将要做的事情。

现在你已经定义了协议，需要告诉`Birthdays`表视图控制器采用这个协议并使用协议的方法。

##### 使 Birthdays Table View Controller 遵循协议

要采用这个协议，`Birthdays`表视图控制器需要让自己成为`AddBirthdayViewControllerDelegate`。为此，你需要将`AddBirthdayViewControllerDelegate`添加到类定义中，紧跟在`UITableViewController`父类之后。在类的顶部，在`UITableViewController`后面加上一个逗号，然后输入`AddBirthdayViewControllerDelegate:`。

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，就会出现一个红色的错误。这是因为`BirthdaysTableViewController`声明它是`AddBirthdayViewControllerDelegate`，但它还没有实现这个协议！为了做到这一点，它需要实现`AddBirthdayViewControllerDelegate`协议的定义。别担心，我们很快就会解决这个问题。

这里需要注意的是，`BirthdaysTableViewController`是从`UITableViewController`类继承的。一个类只能有一个父类，并且这个父类的名称必须写在任何协议之前。但虽然一个类只能有一个父类，它可以采纳多个协议——这些协议会在父类后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要向 Birthdays TableViewController 添加 `addBirthdayViewController(_:didAddBirthday:)` 方法。一个合适的添加位置是在类的末尾，紧跟在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 的自动补全功能会建议你输入整个方法声明。这是因为它知道该类采用了 AddBirthdayViewController Delegate 协议，并期待你添加这个方法。请注意，与子类方法不同，`addBirthdayViewController(_:didAddBirthday:)` 前面不需要使用 `override` 关键字，因为没有原始方法需要被覆盖。

在这个方法中，你需要做两件事。首先，你需要将添加的生日（由添加生日视图控制器传入）添加到 birthdays 数组中。你可以使用数组的 `append(_:)` 方法来实现 ➋。接下来，你需要刷新表视图，使其显示这个新添加的生日，通过在 tableView 属性上调用 `reloadData()` 方法 ➌。当调用 `reloadData()` 时，表视图的数据源方法将再次被调用，新增的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：`// MARK: - AddBirthdayViewControllerDelegate` ➊。这不是必须的，但为了保持良好的编码风格，标记类的不同部分是一个好习惯，这有助于保持代码的清晰和可读性。注释的第一部分 `MARK: -` 是一个 Xcode 识别的特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单帮助你找到方法并快速跳转到代码中的不同位置。要使用这个菜单，请点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为添加生日视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议来告诉 Birthdays 表视图控制器它已经添加了一个生日。为此，首先需要在 AddBirthdayViewController 中定义一个代理。我们通过在 outlets 下面插入以下代码行来添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在创建 Add Birthday 视图控制器之后才能设置它。你将很快学习到在哪里设置代理。

既然“添加生日”视图控制器已经有了一个委托，那么在`saveTapped(_:)`方法中，你可以通过`addBirthdayViewController(_:didAddBirthday:)`方法将生日传递给委托。将`saveTapped(_:)`方法改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊处的代码通过`addBirthdayViewController(_:didAddBirthday:)`将其传递回委托。

很棒！你已经完成了对“添加生日”视图控制器的修改。现在，它有了一个委托，用于监听生日保存的回调。运行应用程序看看会发生什么。

嗯...变化不大。当你添加一个生日时，你仍然看不到它出现在生日表格视图控制器中。怎么回事？

#### 通过设置委托连接两个控制器

还有最后一件事需要做。生日表格视图控制器是`AddBirthdayViewControllerDelegate`，而“添加生日”视图控制器有一个`AddBirthdayViewControllerDelegate`属性，用来保存它在生日保存时与之沟通的委托。但我们从未明确地将委托属性设置为生日表格视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个被注释掉的方法，叫做`prepare(for:sender:)`。通过删除围绕它的`/*`和`*/`注释来取消注释该方法。

每当生日表格视图控制器放弃其屏幕并通过故事板 segue 过渡到另一个视图控制器时，系统会自动调用此方法。我们将使用此方法将生日表格视图控制器传递给“添加生日”视图控制器，并设置其为“添加生日”视图控制器的委托。请在`prepare(for:sender:)`方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码就能将“添加生日”视图控制器的委托设置为生日表格视图控制器。首先，你需要能够从 segue 参数中获取`AddBirthdayViewController`对象。Xcode 在代码中留下了一个注释，提示你如何做到这一点。`UIStoryboardSegue`有一个叫做`destination`的属性，它指向此方法中正在准备的 segue 的另一端，但这个应用程序的目标并不是`AddBirthdayViewController`。

在第九章中，你将“添加生日”视图控制器嵌入到一个导航控制器中，以便你可以拥有带有“取消”和“保存”按钮的导航栏。所以你不会在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的`UINavigationController`。➊处的代码可以获得`navigationController`。`segue.destination`将返回一个`UIViewController`，但是由于我们的`navigationController`是`ViewController`的特定类型，我们需要使用`as`将其类型转换为`UINavigationController`。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其类型转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的特定子类。最后，当你获取到 AddBirthdayViewController 时，可以将委托设置为 self，当前的 self 是生日表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用程序并重新运行它，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学习了如何制作一个表格视图控制器来显示你的生日列表。你还学习了如何在添加生日视图控制器中添加一个生日，并通过委托将生日添加到生日表格视图控制器中的生日数组中，以便它可以显示出来。

在第十二章中，你将学习如何将生日保存到设备中，以便即使你退出应用程序并重新运行它，生日也会继续显示。为了保存生日，你将使用 Core Data，我们在项目一开始时就已经设置好了它。

```
override func numberOfSections(in tableView: UITableView) -> Int {

    return
 1

}

```

这个方法接受一个名为 tableView 的 UITableView 参数，它是使用该类作为数据源的表格视图。我们不需要担心如何建立这个连接，因为 UITableViewController 自带一个内置的表格视图，它会自动与这些方法连接。每个生日都会显示在它自己的行中。所以在 tableView(_:numberOfRowsInSection:)中，为了拥有正确数量的行来显示所有生日，你需要返回生日数组中 Birthday 实例的数量。你还记得数组的 count 属性吗？它是一个整数，表示数组中有多少个元素，它非常适合这种情况！将这个方法修改为如下所示：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，tableView(_:numberOfRowsInSection:)还接受一个名为 section 的 Int 类型参数。当表格视图加载时，该方法会为表格视图中的每个部分被调用。在我们的例子中，我们只有一个部分，因此我们不需要检查这里显示的是表格视图的哪个部分。我们知道它是部分 0，并且我们希望它有和生日数量相同的行数，因此我们写下了 return birthdays.count。

最后，你需要实现`tableView(_:cellForRowAt:)`方法，这样表格视图就会知道在每个单元格中放置什么内容。由于这个方法被注释掉了，你需要通过删除/*和*/来取消注释它。（小心不要不小心取消注释它后面的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要直接调用`tableView(_:cellForRowAt:)`方法。它会在表格视图加载到屏幕时被调用。它会为屏幕上的每个单元格调用一次，并且需要两个参数，`tableView`和`indexPath`。你已经知道`tableView`参数的作用了。`IndexPath`是一个 Swift 结构体，用来表示表格视图中行的位置。一个`IndexPath`实例有一个`section`属性和一个`row`属性。由于这个方法会被多次调用（每个表格中的行都会调用一次），所以我们需要通过`indexPath`来知道我们当前在配置哪个 section 和 row。`indexPath.section`属性给出 section 的编号，而`indexPath.row`给出表格视图单元格的行号。`tableView(_:cellForRowAt:)`中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定哪个生日信息会显示在单元格中

• 在单元格中创建两个标签来显示生日人物的姓名和出生日期

• 返回准备好在表格视图中显示的单元格

让我们逐行查看这段代码。

首先，创建 UITableViewCell。在➊处的代码通过调用方法`dequeueReusableCell(withIdentifier:for:)`来实现这一点。不过，在你可以开始在单元格上使用这个方法之前，你需要告诉这个方法你想从故事板中使用哪个单元格。早些时候，在故事板中，你为单元格指定了标识符 birthdayCellIdentifier（参见图 11-4）。这个标识符将你的代码与单元格连接起来，并告诉方法你正在使用正确的单元格。当你调用这个方法时，字符串必须与在故事板中设置的字符串完全相同，否则你会遇到错误，应用程序在运行时会崩溃。

在`dequeueReusableCell(withIdentifier:for:)`方法中，你有没有注意到*可重用单元格*这几个字？表格视图中的单元格是一次创建的，然后可以被重复使用。这有助于加快运行速度和提升流畅度，因为创建单元格是最费时的部分。如果你的应用中有 200 个生日信息，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以查看更多生日时，屏幕顶部滚动出去的单元格会被重新使用。它们会被填充新的信息，并出现在屏幕的底部。UITableView 会自动处理这些工作。当表格视图加载时，`tableView(_:cellForRowAt:)`会为每一行被显示的单元格调用一次。当用户滚动查看更多单元格时，它会在每行即将出现在屏幕上时再次被调用。

接下来，我们需要找出应该在单元格内显示哪个生日。我们希望在每一行显示 birthdays 数组中的一个生日。第一个生日，位于 birthdays[0]，应该显示在第 0 行；第二个生日，位于 birthdays[1]，应该显示在第 1 行，以此类推。这意味着 indexPath 的行数与我们想要访问的 birthdays 数组中的位置相同。➋ 处的代码通过使用 indexPath.row 来访问 birthdays 数组中的正确 Birthday 对象。一旦我们获得了正确的 Birthday 对象，就将其赋值给名为 birthday 的常量，这样我们就可以设置该单元格中的标签。

请注意，我们使用 let 将生日赋值给一个常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的 birthday 常量。每个单元格都会有自己独立的 birthday 常量，并将其分配给自己的 Birthday 对象。由于我们不会修改任何生日常量——我们只是读取它们的属性——因此我们不想将它们定义为变量。

现在，您已经有了单元格和生日，是时候填写详细信息了。每个单元格需要两个标签来显示生日人的姓名和出生日期。您将单元格设置为副标题样式，这样它就有一个标题标签和一个副标题标签。每个单元格已经包含这些标签，因此现在您无需自己创建任何标签。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格隔开。在 ➍ 处，您使用 dateFormatter 的 string(from:) 方法在 detailTextLabel 中显示出生日期。

当您的单元格完全配置好后，tableView(_:cellForRowAt:) 会在 ➎ 返回单元格，以便它可以在表格视图的相应 indexPath 处显示。

### 综合起来

现在，您可以使用添加生日视图控制器向应用程序添加生日实例，并且您有一个表格视图来列出每个生日，在生日表格视图控制器中显示。但是，当您尝试运行应用程序并添加生日时，它并没有显示出来。为了使您添加的每个生日在表格视图中显示，您需要让添加生日视图控制器与生日表格视图控制器进行通信。您可以通过使用*代理模式*来实现这一点。

#### 代理模式

代理模式可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设您有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将其呈现到自己之上。A 知道 B，因为它创建并呈现了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A，它只是突然出现，并不知道自己是从哪里来的或者是怎么来的。那么 B 如何与 A 通信呢？通过代理模式！

![](img/Image00245.jpg)

委托是指有人将工作或任务交给别人。一个*委托*就像一个老板，他告诉委派员工该做什么。当委派员工完成任务后，有时会向委托的老板报告信息。

在 Swift 中的委托与此相似，不过我们不是老板和员工，而是有一个委托对象和一个委托者对象。由于是 A 类告诉 B 类该做什么，B 类就是委托者对象。我们给 B 类一个特殊的属性，叫做 delegate，告诉它谁是它的委托对象——这样，它就知道与谁沟通。委托对象可以是任何具有在*协议*中定义的一组方法的类。协议就像是两者之间的协议，告诉它们委托对象可以要求委托者对象做什么。协议中包含了一些方法和属性名称，委托对象可以用这些方法与委托者对象交互。

A 类创建 B 类，将自己设置为 B 类的委托，并给 B 类一个在协议中定义的任务。一旦 B 类完成任务，它会向 A 类报告。让我们看看这在我们的应用程序中是如何工作的。

生日列表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用于报告。

看一下图 11-6。当用户点击“添加”按钮 ➊ 时，生日列表视图控制器创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从添加生日视图控制器传递到生日列表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为具有一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，添加生日视图控制器调用此方法 ➍ 并将新的生日传递给其委托对象——生日列表视图控制器。生日列表视图控制器接收该生日，将其添加到它的生日数组中，然后重新加载其表视图 ➎ ，使得新生日能够出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并使用 addBirthdayViewController(_:didAddBirthday:)方法，添加生日视图控制器每次在应用程序中添加一个生日时都可以调用。生日列表视图控制器将实现该协议方法，以便每当通过添加生日视图控制器添加生日时，添加生日视图控制器可以对其委托说：“嘿！有人刚刚添加了这个生日”，而生日列表视图控制器会接收到消息并说：“哦！我将把它添加到我的列表中，并刷新我的显示，让新生日出现在列表中。”

现在，让我们在代码中实现这一点！

##### 创建一个协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类的*上方*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处定义协议，通过输入关键字 protocol 后跟协议名称 AddBirthdayViewControllerDelegate。这个名字很长，但 Swift 程序员通常会将协议命名为调用类的名称并在末尾加上 Delegate。这是为了让你通过查看协议的名称就能知道是哪个类在使用这个协议。既然你现在是 Swift 程序员了，应该遵循相同的命名惯例。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，用于将 Birthday 对象传回代理类➋。注意，你在这个函数中包括了 AddBirthdayViewController 作为一个参数。再次强调，Swift 程序员在实现协议方法时，通常会按惯例这么做，所以你也应该遵循这个做法。这样做有助于了解是谁发送了消息，并且代理类可以访问该对象及其类。

当 AddBirthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传入。你很快就会看到如何实现。另一个需要注意的点是外部参数名称 didAddBirthday。许多代理协议方法都包含*did*和*will*，因为它们用于描述调用类已经做过或将要做的事情。

现在你已经定义了协议，接下来需要告诉 Birthdays 表格视图控制器去采用这个协议并使用协议中的方法。

##### 使 Birthdays 表格视图控制器符合协议

要采用这个协议，Birthdays 表格视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中紧跟 UITableViewController 父类后面添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后面添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，就会出现一个红色错误。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现协议！为了实现这个协议，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心，我们很快就会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 的子类。一个类只能有一个父类，而该父类的名称必须写在任何协议之前。但尽管一个类只能有一个父类，它可以采用任意数量的协议——这些协议会在父类后面列出，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:)方法。一个合适的添加位置是类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动完成功能会建议你整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且期望你添加这个方法。注意，不同于子类方法，你不需要在 addBirthdayViewController(_:didAddBirthday:)前面加上 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:)方法来做到这一点➋。接下来，你需要刷新表视图，以便显示这个新添加的生日，可以通过调用 tableView 属性上的 reloadData()方法➌来实现。当 reloadData()被调用时，表视图的数据源方法将重新调用，新添加的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但良好的编码风格是标记类的不同部分，它有助于保持代码的清晰和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单帮助你找到方法并让你跳转到代码中的不同位置。要使用这个菜单，可以点击编辑面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，方便快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器指定代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表视图控制器它何时添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中插入以下一行代码，紧接着 outlets 部分，来安排这一点：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你只能在 Add Birthday 视图控制器创建之后再设置它。你将很快学到如何设置代理。

现在，既然添加生日视图控制器已经有了代理，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将一个 Birthday 传递给代理。将 saveTapped(_:)方法修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)方法将其传递回代理。

太棒了！你已经完成了对添加生日视图控制器的修改。现在它有了一个代理，能够监听生日保存的调用。运行应用程序看看会发生什么。

嗯……没有太大变化。当你添加一个生日时，依然看不到它出现在生日表视图控制器中。怎么回事？

#### 通过设置代理连接这两个控制器

还有一件事需要做。生日表视图控制器是一个 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存了它与之通讯的代理，每当一个生日被保存时。但我们从未明确设置过代理属性为生日表视图控制器。所以现在是时候连接这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)，取消注释该方法，删除/*和*/。

这个方法会在每次生日列表表视图控制器放弃屏幕并且应用程序通过故事板 segue 过渡到另一个视图控制器时自动调用。我们将使用这个方法将生日列表表视图控制器传递给添加生日视图控制器，并将其设置为添加生日视图控制器的代理。在 prepare(for:sender:)方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的代理为生日表视图控制器只需要三行代码。首先，你需要能够从 segue 参数中获取到 AddBirthdayViewController 对象。Xcode 已经留了一条注释，提示你可以如何做到这一点。UIStoryboardSegue 有一个叫做 destination 的属性，指向在该方法中准备的 segue 的另一端，但对于这个应用来说，目标不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到了一个导航控制器中，以便你可以拥有带有取消和保存按钮的导航栏。所以你不会期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊处的代码让你得到了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定类型，因此我们需要通过 as 将其类型转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此需要将其类型转换为 AddBirthdayViewController，以指明该控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 后，可以将 delegate 设置为 self，self 目前是 Birthdays 表视图控制器 ➌。

现在运行应用并添加一些生日！你在 Birthdays 表视图控制器中看到了什么？生日！生日！生日！不过，我们还没完全完成。如果你退出应用然后再次运行，之前添加的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到的内容

在本章中，你学会了如何创建一个表视图控制器来显示生日列表。你还学会了如何在 Add Birthday 视图控制器中添加生日，然后如何使用 delegate 将生日添加到 Birthdays 表视图控制器中的 birthdays 数组，以便显示出来。

在第十二章中，你将学会如何将生日保存到设备中，这样即使退出应用并重新运行，它们也会显示出来。为了保存生日，你将使用我们在项目开始时就设置好的 Core Data。

这个方法接受一个 UITableView 类型的 tableView 作为参数，它是使用这个类作为数据源的表视图。我们不需要担心如何建立这个连接，因为 UITableViewController 自带一个内建的表视图，它会自动与这些方法连接。每个生日都会显示在自己的行中。所以在 tableView(_:numberOfRowsInSection:) 中，为了正确显示所有生日的行数，你需要返回 birthdays 数组中生日实例的数量。你还记得数组的 count 属性吗？它是一个整数，表示数组中有多少个元素，非常适合这个场景！将这个方法修改为如下：

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，tableView(_:numberOfRowsInSection:) 还接受一个名为 section 的 Int 类型参数。当表视图加载时，系统会为每个表视图中的分区调用该方法。在我们的案例中，只有一个分区，所以我们不需要担心检查哪个分区正在显示。我们知道它是第 0 个分区，我们希望它的行数与生日的数量相同，因此我们写上 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:)方法，这样表格视图就知道在每个单元格中放入什么内容。由于这个方法被注释掉了，你需要通过删除包围它的/*和*/来取消注释。（小心不要不小心取消注释它后面的其他方法！）完成这一步后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不需要调用方法 tableView(_:cellForRowAt:)。它在表格视图加载到屏幕上时自动调用。它会为屏幕上的每个单元格调用，并接受两个参数，tableView 和 indexPath。你已经知道 tableView 参数的用途。IndexPath 是一个 Swift 结构体，用于表示表格视图中一行的位置。一个 IndexPath 实例有一个 section 属性和一个 row 属性。由于此方法会被多次调用（每个表格行调用一次），我们需要 indexPath 来知道我们当前配置的是哪个节和行。indexPath.section 属性提供节的编号，indexPath.row 提供表格视图单元格的行号。tableView(_:cellForRowAt:)中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 找出哪个生日在 birthdays 数组中将在单元格内显示

• 创建两个标签来显示生日人的名字和出生日期

• 返回准备好在表格视图中显示的单元格

让我们逐行查看这段代码。

首先，创建 UITableViewCell。代码中的➊使用方法 dequeueReusableCell(withIdentifier:for:)来实现这一点。在你可以在单元格上开始使用此方法之前，你需要告诉方法你希望使用哪个来自 Storyboard 的单元格。之前，在 Storyboard 中，你给你的单元格设置了标识符 birthdayCellIdentifier（参见图 11-4）。这个标识符将你的代码与单元格关联起来，并告诉你的方法正在使用正确的单元格。调用此方法时的字符串需要与 Storyboard 中设置的字符串完全相同，否则你会遇到错误，应用程序在运行时会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:)中，你是否注意到“*可重用单元格*”这几个字？表格视图中的单元格是创建一次，然后可以反复使用的。这有助于提高性能，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，滚出屏幕顶部的单元格会被重新使用。它们会被填充新的信息，并再次出现在屏幕底部。UITableView 会自动完成这项工作。当表格视图加载时，tableView(_:cellForRowAt:)会为每一行调用一次。当用户滚动查看更多单元格时，它会在每一行即将出现在屏幕上时再次被调用。

接下来，我们需要找出哪个生日应该显示在单元格中。我们希望在每一行中显示来自生日数组的一个生日。第一个生日，即 birthday[0]，应该显示在第 0 行。第二个生日，birthday[1]，应该显示在第 1 行，以此类推，这意味着 indexPath 的行数与我们要访问的 birthday 数组中的位置相同。在➋处的代码通过使用 indexPath.row 来访问 birthday 数组中的正确 Birthday 对象。一旦我们得到了正确的 Birthday 对象，我们将其分配给一个名为 birthday 的常量，以便我们可以设置这个单元格中的标签。

注意，我们使用 let 将生日分配给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都会得到自己的生日常量，并将其分配给自己的 Birthday 对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以我们不想将它们声明为变量。

现在你已经有了单元格和生日，接下来是填写详细信息。你需要为每个单元格添加两个标签，分别显示生日人的名字和生日日期。你将单元格设置为副标题样式，这样它就有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，所以现在你不需要自己创建标签。

这些标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。在➌处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格隔开。在➍处，你使用 dateFormatter 的 string(from:)方法在 detailTextLabel 中显示生日日期。

当你的单元格完全配置好后，tableView(_:cellForRowAt:)将在➎处返回该单元格，以便它可以显示在表格视图的相应 indexPath 处。

### 整合所有内容

现在，你可以通过添加生日视图控制器将生日实例添加到应用程序中，并且你有一个表格视图来列出每个生日，显示在生日表视图控制器中。但是，当你尝试运行应用并添加一个生日时，它并没有显示。为了让你添加的每个生日都出现在表格视图中，你需要让添加生日视图控制器与生日表视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 展示在自己之上。A 知道 B，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但 B 并不知道 A——它只是被弹出并不知道自己从哪里来，也不知道是如何到达那里的。那么 B 怎么能与 A 沟通呢？通过委托！

![](img/Image00245.jpg)

代理是指将某项工作或任务交给他人去做。*代理*就像是一个老板，告诉委托员工该做什么。当委托员工完成任务后，有时会将信息报告回代理老板。

在 Swift 中，代理模式与其他语言类似，但不同的是，我们没有老板和员工，而是有代理和委托对象。由于是类 A 告诉类 B 该做什么，所以类 B 是委托对象。我们给类 B 一个特殊的属性，叫做 delegate，用来指明它的代理对象是谁——这样，它就知道与谁进行沟通。代理可以是任何实现了*协议*方法集的类。协议就像是两个类之间的约定，告知它们代理可以要求委托对象做什么。协议包含了一系列方法和属性名称，代理可以用这些方法与委托对象进行交互。

类 A 创建类 B，将自己设为类 B 的代理，并赋予类 B 一个在协议中定义的任务。一旦类 B 完成任务，它就会向类 A 报告。让我们看看这在我们的应用中是如何工作的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议定义一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用来向外报告。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器会创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：一个新生日被添加，并通过代理从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为包含一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，添加生日视图控制器会调用此方法 ➍ 并将新生日传递给它的代理，生日表视图控制器。生日表视图控制器接收这个生日，将其添加到生日数组中，然后重新加载表格视图 ➎，这样新生日就会出现在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义 addBirthdayViewController(_:didAddBirthday:)方法，让添加生日视图控制器在每次向应用中添加生日时都能调用该方法。生日表视图控制器将实现该协议方法，这样每当通过添加生日视图控制器添加一个生日时，添加生日视图控制器就能告诉它的代理：“嘿！有人刚刚添加了这个生日，”生日表视图控制器收到消息后会回应：“哦！我会把这个生日添加到我的列表中，并刷新我的显示，这样新生日就能显示出来。”

现在让我们来编写代码吧！

##### 创建协议

首先，我们需要创建这个协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过输入关键字 `protocol` 后跟协议名 AddBirthdayViewControllerDelegate 来定义协议。这个名字比较长，但 Swift 程序员通常会根据调用类的名字来命名协议，并在末尾加上 `Delegate`。这样，你就可以通过查看协议的名字来知道是哪个类在使用该协议。既然你现在是 Swift 程序员，也应该使用相同的命名规范。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)`是唯一的函数，用于将生日对象传回代理类 ➋。注意，在这个函数中，你将 AddBirthdayViewController 作为一个参数传入。再次提醒，Swift 程序员在实现协议方法时通常会这样做，所以你也应该遵循这种做法。知道是谁发送回消息以及让代理能够访问该对象及其类是非常有用的。

当 AddBirthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传入。你很快就会看到这是如何完成的。另一个需要注意的事情是外部参数名称 `didAddBirthday`。许多代理协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚做过的事情或将要做的事情。

现在你已经定义了协议，接下来需要告诉 Birthdays 表视图控制器采纳这个协议，并使用协议的方法。

##### 让 Birthdays 表视图控制器符合协议

要采用这个协议，Birthdays 表视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中，在 UITableViewController 超类之后，添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加上一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做了，就会出现一个红色错误。这是因为 BirthdaysTableViewController 声明自己是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了解决这个问题，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快就会解决这个问题。

需要特别注意的是，BirthdaysTableViewController 是在子类化 UITableViewController 超类。一个类只能有一个超类，而这个超类的名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采用任意数量的协议——这些协议会在超类之后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要向 Birthdays TableViewController 添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个好的位置是将其添加到类的末尾，紧接着导航部分：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类采纳了 AddBirthdayViewController Delegate 协议，并期望你添加这个方法。注意，与子类方法不同，在 addBirthdayViewController(_:didAddBirthday:) 方法前面你不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将由添加生日视图控制器传递过来的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法 ➋ 来完成这项工作。接下来，你需要刷新表视图，以便显示这个新的生日，方法是调用 tableView 属性上的 reloadData() 方法 ➌。当调用 reloadData() 时，表视图数据源方法将会再次被调用，新的生日将会显示在生日列表的底部。

你可能已经注意到我们在方法上方添加了一个注释，用于标记这一部分代码：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但良好的编码风格是标记类中的不同部分，并有助于保持代码的清晰和可读性。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中，你可以在其中使用该菜单。这个下拉菜单帮助你找到方法，并让你可以跳转到代码中的不同位置。要使用这个菜单，请点击编辑器面板顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：您的类具有内置的目录，可以快速跳转到某个章节。*

##### 为添加生日视图控制器设置代理

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知 Birthdays 表视图控制器何时添加了一个生日。为此，添加生日视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中插入以下代码行，在 outlets 下面添加一个可选的代理属性，类型为 AddBirthdayViewControllerDelegate，从而实现这一点：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在添加生日视图控制器创建之前，你无法设置它。稍后你将学习如何设置代理。

现在，添加生日视图控制器有了委托，在`saveTapped(_:)`方法中，你可以使用`addBirthdayViewController(_:didAddBirthday:)`方法将生日传递给委托。将`saveTapped(_:)`修改为如下代码：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象后，➊处的代码通过`addBirthdayViewController(_:didAddBirthday:)`方法将其传递回委托。

太好了！你已经完成了对添加生日视图控制器的修改。现在它有了一个委托，能够监听生日保存的回调。运行应用程序看看会发生什么。

嗯……似乎没有什么变化。当你添加生日时，仍然看不到它出现在生日表视图控制器中。怎么回事？

#### 通过设置委托连接两个控制器

还有最后一件事你需要做。生日表视图控制器是`AddBirthdayViewControllerDelegate`，而添加生日视图控制器有一个`AddBirthdayViewControllerDelegate`属性，保存了它在生日保存时与之通信的委托。但是我们从未明确地将委托属性设置为生日表视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个被注释掉的方法`prepare(for:sender:)`。通过删除包围它的/*和*/，取消注释该方法。

当生日表视图控制器放弃其屏幕并且应用程序通过 storyboard segue 过渡到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将生日表视图控制器传递给添加生日视图控制器，从而将其设置为添加生日视图控制器的委托。在`prepare(for:sender:)`方法中写入如下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的委托为生日表视图控制器只需要三行代码。首先，你需要能够从 segue 参数中获取到`AddBirthdayViewController`对象。Xcode 在注释中给出了提示，指示如何做到这一点。`UIStoryboardSegue`有一个`destination`属性，表示 segue 的另一端，在此方法中正在准备，但对于这个应用程序来说，目标并不是`AddBirthdayViewController`。

在第九章中，你将添加生日视图控制器嵌入到导航控制器中，这样你就能拥有一个带有取消和保存按钮的导航栏。所以你不期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的`UINavigationController`。➊处的代码帮助你获取`navigationController`。`segue.destination`将返回一个`UIViewController`，但由于我们的`navigationController`是一个特定类型的视图控制器，我们需要使用`as`将其强制转换为`UINavigationController`。

接下来，你可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表示这个控制器是 UIViewController 的一个特定子类。最后，当你拥有一个 AddBirthdayViewController 时，你可以将代理设置为 self，它当前是“生日”表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在“生日”表格视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用程序再重新运行，之前添加的生日会消失。我们还需要将生日数据保存到设备中，这个任务将在第十二章中完成。

### 你学到的内容

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，并且如何通过代理将生日添加到“生日”表格视图控制器中的生日数组，以便它可以显示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使你退出应用程序再重新运行，生日数据仍然会显示出来。为了保存生日数据，我们将使用 Core Data，这个功能我们在项目开始时就设置好了。

```
override func tableView(_ tableView: UITableView, ![](img/Image00184.jpg)

    numberOfRowsInSection section: Int) -> Int {

    return
 birthdays.count

}

```

除了 tableView 参数外，tableView(_:numberOfRowsInSection:)方法还接受一个名为 section 的 Int 参数。当表格视图加载时，此方法会为每个表格视图的部分被调用。在我们的例子中，只有一个部分，所以我们不需要检查正在显示哪个部分。我们知道它是第零部分，并且我们希望它有和生日数量相同的行数，因此我们写下 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:)方法，以便表格视图知道在每个单元格中放置什么内容。由于这个方法被注释掉了，你需要通过删除/*和*/来取消注释它。（小心不要不小心取消注释之后的其他方法！）完成后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法 `tableView(_:cellForRowAt:)`。当表格视图加载到屏幕上时，会自动调用这个方法。它会为每个屏幕上的单元格调用，并接受两个参数：tableView 和 indexPath。你已经知道 tableView 参数的用途。IndexPath 是一个 Swift 结构体，用于表示表格视图中某一行的位置。一个 IndexPath 实例包含一个 section 属性和一个 row 属性。由于这个方法会被多次调用（每个表格行调用一次），我们需要 indexPath 来知道当前配置的是哪个 section 和 row。indexPath.section 属性给出 section 的编号，indexPath.row 给出表格视图单元格的行号。`tableView(_:cellForRowAt:)` 方法中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定在 birthdays 数组中，哪一个生日会显示在单元格中

• 创建两个标签，用于在单元格中显示生日人物的姓名和出生日期

• 返回准备好显示的单元格，供表格视图使用

让我们逐行分析这段代码。

首先，创建 UITableViewCell。代码 ➊ 使用方法 `dequeueReusableCell(withIdentifier:for:)` 完成此操作。然而，在你开始使用这个方法之前，需要告诉它你要从 storyboard 中使用哪个单元格。早些时候，当你在 storyboard 中时，你给单元格指定了标识符 `birthdayCellIdentifier`（参见 图 11-4）。这个标识符将你的代码与单元格连接起来，并告诉方法你正在使用正确的单元格。调用这个方法时使用的字符串必须与 storyboard 中设置的字符串完全一致，否则会导致错误，应用程序会崩溃。

在方法 `dequeueReusableCell(withIdentifier:for:)` 中，你注意到 *Reusable Cell* 这个词了吗？表格视图中的单元格只会创建一次，然后可以被反复使用。这有助于提高效率，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，滚出屏幕顶部的单元格会被重用。它们会被填充上新的信息，并重新出现在屏幕底部。UITableView 会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)` 会为每一行可见单元格调用。当用户滚动查看更多单元格时，它会在每一行即将出现在屏幕上时再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们想在每一行中显示 `birthdays` 数组中的一个生日。第一个生日，即 `birthdays[0]`，应该显示在第 0 行。第二个生日，位于 `birthdays[1]`，应该显示在第 1 行，依此类推，这意味着 `indexPath` 的行号与我们想要访问的 `birthdays` 数组中的位置相同。在 ➋ 处的代码通过使用 `indexPath.row` 从 `birthdays` 数组中访问正确的 Birthday 对象。一旦获取到正确的 Birthday 对象，我们将其赋值给一个名为 `birthday` 的常量，以便我们可以设置该单元格中的标签。

请注意，我们使用 `let` 来将生日赋值给常量，而不是变量。我们可以使用 `let`，因为每次调用 `tableView(_:cellForRowAt:)` 时，都会创建一个新的 `birthday` 常量。每个单元格都会有自己的 `birthday` 常量，且每个常量都被分配了自己的 Birthday 对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——因此我们不想将它们设置为变量。

现在你有了单元格和生日，是时候填写详细信息了。你需要为每个单元格添加两个标签，用来显示生日人物的姓名和出生日期。你将单元格设置为副标题（Subtitle）样式，这样它就有了标题标签和副标题标签。每个单元格已经包含了这些标签，所以现在你不需要自己创建任何标签。

标签是作为 `UITableViewCell` 的属性存在的，分别叫做 `textLabel` 和 `detailTextLabel`。在 ➌ 处的代码将 `textLabel` 的文本设置为由生日的 `firstName` 和 `lastName` 组成的字符串，并在它们之间加上空格。在 ➍ 处，你使用 `dateFormatter` 的 `string(from:)` 方法将出生日期显示在 `detailTextLabel` 中。

当单元格完全配置好后，`tableView(_:cellForRowAt:)` 会在 ➎ 处返回该单元格，以便将其显示在表视图的该 `indexPath` 位置。

### 整合所有内容

现在，你可以通过“添加生日”视图控制器向应用程序中添加 Birthday 实例，并且你有一个表视图来列出每个 Birthday，在“生日”表视图控制器中显示它们。但是，当你尝试运行应用并添加一个 Birthday 时，它并没有出现。为了让你添加的每个 Birthday 显示在表视图中，你需要让“添加生日”视图控制器与“生日”表视图控制器进行通信。你可以通过使用 *代理（delegation）* 来实现这一点。

#### 代理（DELEGATION）

代理（delegation）可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将其展示在自己之上。A 知道 B 的存在，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 不知道 A 的存在——它只是突然出现的，并不知道自己是从哪里来的，也不知道是怎么到达那里的。那么 B 如何与 A 通信呢？通过代理！

![](img/Image00245.jpg)

委托是指某人将一项工作或任务交给他人。一个*委托人*就像是一个老板，他告诉被委托的员工该做什么。当被委托的员工完成任务后，有时他们会将信息报告给委托人老板。

Swift 中的委托与此相似，但不是老板和员工，而是委托对象和被委托对象。由于类 B 是被类 A 告诉该做什么的，因此它是被委托对象。我们给类 B 一个特殊的属性，称为委托(delegate)，用来告诉它它的委托对象是谁——这样，它就知道该与谁沟通。委托可以是任何具有在*协议*中定义的一组方法的类。协议就像是两个类之间的约定，告诉它们委托对象可以要求被委托对象做什么。它包含了一些方法和属性名称，委托可以使用这些方法和属性与被委托对象进行交互。

类 A 创建类 B，使自己成为类 B 的委托，并给类 B 一项在协议中定义的任务。一旦类 B 完成任务，它就会向类 A 报告。让我们看看这在我们的应用中是如何工作的。

“生日”表视图控制器是视图控制器 A，而“添加生日”视图控制器是视图控制器 B。我们将创建一个协议，称为 AddBirthdayViewControllerDelegate，并为该协议定义一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由“添加生日”视图控制器用来报告回调。

看看图 11-6。当用户点击“添加”按钮➊时，“生日”表视图控制器创建了“添加生日”视图控制器➋，并将自己设置为“添加生日”视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从“添加生日”视图控制器传递到“生日”表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只包含一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮➌时，“添加生日”视图控制器调用这个方法 ➍，并将新生日传递给它的委托，即“生日”表视图控制器。“生日”表视图控制器接收这个生日，将其添加到它的生日数组中，然后重新加载表视图 ➎，以便新生日能够显示在表中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由“添加生日”视图控制器在每次应用中添加生日时调用。“生日”表视图控制器将实现该协议方法，以便每次通过“添加生日”视图控制器添加生日时，“添加生日”视图控制器可以对它的委托说：“嘿！有人刚刚添加了这个生日”，然后“生日”表视图控制器会收到消息并回应：“哦！我会把这个添加到我的列表中，并刷新显示，以便新的生日能够显示出来。”

现在让我们在代码中实现这一点！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方*，添加以下代码以定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过输入关键字 protocol 和 AddBirthdayViewControllerDelegate 名称来定义协议 ➊。这个名字很长，但 Swift 程序员通常会根据调用类的名称命名协议，并在末尾加上 Delegate 这个词。这样，你就能通过查看协议名称来知道是哪个类在使用该协议。既然你现在是 Swift 程序员，你应该遵循相同的命名惯例。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，用于将 Birthday 对象传回给委托类 ➋。请注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员在实现协议方法时通常会这样做，所以你也应该遵循这一惯例。这样做的好处是，委托可以知道是谁发送了消息，并能够访问该对象及其类。

当 AddBirthday 视图控制器调用此方法时，它会将自身作为 addBirthdayViewController 参数传递。你很快就会看到如何实现。另一个需要注意的地方是外部参数名 didAddBirthday。许多委托协议方法包含 *did* 和 *will*，因为它们用来描述调用类刚做完或将要做的事情。

现在你已经定义了协议，接下来需要告诉 Birthdays 表格视图控制器采用这个协议并使用协议的方法。

##### 使 Birthdays 表格视图控制器符合协议

为了采用该协议，Birthdays 表格视图控制器需要让自己成为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，在 UITableViewController 超类之后，添加 AddBirthdayViewControllerDelegate。你只需在 UITableViewController 之后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色错误会出现。这是因为 BirthdaysTableViewController 声明自己是一个 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快就会修复这个问题。

这里需要特别注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，而且该超类名称必须写在任何协议之前。但是，尽管一个类只能有一个超类，它可以采纳任意多个协议——这些协议会在超类之后列出，并用逗号分隔。

现在，为了遵守 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的地方是将它添加到类的末尾，紧跟在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动补全功能会建议这个完整的方法声明。这是因为它知道这个类遵循了 AddBirthdayViewControllerDelegate 协议，并且预期你会添加这个方法。请注意，与子类化方法不同，在 addBirthdayViewController(_:didAddBirthday:) 前面不需要使用 override 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将从添加生日视图控制器传入的生日添加到生日数组中。你可以通过使用数组的 append(_:) 方法来完成这一操作 ➋。接着，你需要刷新表格视图，以便它能显示这个新添加的生日，通过调用 tableView 属性上的 reloadData() 方法 ➌。当调用 reloadData() 时，表格视图的数据源方法会被重新调用，新的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这并不是必需的，但良好的编码风格会将类的不同部分标记出来，这有助于保持代码的整洁和可读性。注释的第一部分，MARK: -，是一个 Xcode 识别的特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中，你可以使用该菜单快速导航到类中的不同位置。要使用此菜单，点击编辑窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为添加生日视图控制器设置委托

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知 Birthdays 表格视图控制器它已经添加了一个生日。为此，首先需要在 AddBirthdayViewController 类中定义一个委托。我们通过在 outlets 下方插入以下代码来添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在*添加生日视图控制器*创建之前，你无法设置它。稍后你将学习在哪里设置委托。

现在，添加生日视图控制器已经有了一个代理，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将 Birthday 传递给代理。将 saveTapped(_:)方法修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)将其传递回代理。

太好了！你已经完成了对添加生日视图控制器的更改。它现在有了一个代理，能够监听生日已保存的调用。运行应用程序看看发生了什么。

嗯。。。变化不大。当你添加一个生日时，你仍然没有看到它出现在生日表格视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

你还需要做一件最后的事情。生日表格视图控制器是 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用于保存它与之通信的代理，当生日被保存时。但是我们从未明确设置代理属性为生日表格视图控制器。因此，是时候建立我们两个视图控制器之间的通信管道了。

在生日表格视图控制器类的导航部分，有一个已经被注释掉的方法 prepare(for:sender:)。通过删除围绕它的/*和*/注释，取消注释这个方法。

每当生日表格视图控制器放弃其屏幕并通过故事板 segue 过渡到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将生日表格视图控制器传递到添加生日视图控制器，并设置它自己作为添加生日视图控制器的代理。请在 prepare(for:sender:)方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的代理为生日表格视图控制器只需要三行代码。首先，你需要能够从 segue 参数获取 AddBirthdayViewController 对象。Xcode 在注释中留下了提示，说明你可以如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，指向正在准备的 segue 的另一端，但对于此应用程序，destination 并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到导航控制器中，以便能够拥有带有取消和保存按钮的导航栏。因此，你不会期望在 segue 的另一端找到添加生日视图控制器。相反，destination 是一个包含添加生日视图控制器的 UINavigationController。➊处的代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定类型，我们需要使用`as`将其类型转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其类型转换为 AddBirthdayViewController，以表示这个控制器是 UIViewController 的一个特定子类。最后，当你得到一个 AddBirthdayViewController 时，你可以将代理设置为 self，而此时的 self 就是“生日”表格视图控制器 ➌。

现在运行应用并添加一些生日！你在“生日”表格视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用并重新运行，它之前添加的生日会消失。我们还需要将生日保存到设备中，这将在第十二章中讲解。

### 你学到的内容

在本章中，你学会了如何创建一个表格视图控制器来显示生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，并使用代理将生日添加到“生日”表格视图控制器中的生日数组中，从而将其显示出来。

在第十二章中，你将学会如何将生日保存到设备中，这样即使退出应用并重新运行，它们也能显示出来。为了保存生日，你将使用 Core Data，这是我们在项目开始时设置的。

除了 tableView 参数外，tableView(_:numberOfRowsInSection:) 方法还接受一个名为 section 的 Int 类型参数。当表格视图加载时，此方法会为表格视图中的每个部分调用。在我们的例子中，只有一个部分，因此我们不需要检查这里显示的是哪个部分。我们知道它是第零部分，并且希望它的行数与生日的数量相同，因此我们写下 return birthdays.count。

最后，你需要实现 tableView(_:cellForRowAt:) 方法，这样表格视图才能知道每个单元格中放置什么内容。由于这个方法被注释掉了，你需要通过删除 /* 和 */ 来取消注释。（小心不要不小心取消其他方法的注释！）完成这一步后，将其更改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

您不会直接调用方法 `tableView(_:cellForRowAt:)`。它会在表格视图加载到屏幕时被自动调用。它会为屏幕上的每个单元格调用，并接受两个参数：`tableView` 和 `indexPath`。您已经知道 `tableView` 参数的用途。`IndexPath` 是一个 Swift 结构体，用于表示表格视图中行的位置。`IndexPath` 实例具有 `section` 和 `row` 属性。由于这个方法会被多次调用（每个表格行调用一次），我们需要 `indexPath` 来确定我们正在配置的是哪个 section 和 row。`indexPath.section` 属性返回 section 的编号，`indexPath.row` 返回表格视图单元格的行号。`tableView(_:cellForRowAt:)` 中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 `UITableViewCell`

• 确定哪个生日在 `birthdays` 数组中将显示在单元格内

• 创建两个标签以显示生日人物的姓名和出生日期

• 返回已准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 `UITableViewCell`。代码中 ➊ 使用 `dequeueReusableCell(withIdentifier:for:)` 方法来完成这项工作。但是，在您开始使用此方法之前，您需要告诉它您要从故事板中使用哪个单元格。之前在故事板中，您给单元格设置了标识符 `birthdayCellIdentifier`（见 图 11-4）。这个标识符将您的代码与单元格关联，并告诉方法它正在使用正确的单元格。当您调用此方法时，字符串必须与您在故事板中设置的字符串完全一致，否则会出现错误，应用程序运行时会崩溃。

在方法 `dequeueReusableCell(withIdentifier:for:)` 中，您注意到“*可重用单元格*”这几个字了吗？表格视图中的单元格是一次性创建的，之后可以反复重用。这有助于一切运行得更快、更流畅，因为创建单元格是最费时的部分。如果您的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么您只需要 10 个单元格来展示这些生日。当您向下滚动以显示更多生日时，滚出屏幕顶部的单元格将被重用。它们被填充新的信息，并在屏幕底部重新出现。UITableView 会自动执行这一操作。当表格视图加载时，`tableView(_:cellForRowAt:)` 会被调用，处理每一行可见的单元格。当用户滚动查看更多单元格时，`tableView(_:cellForRowAt:)` 会在每行即将出现在屏幕上时再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望从生日数组中在每一行显示一个生日。第一个生日，即 birthdays[0]，应该显示在第 0 行。第二个生日，即 birthdays[1]，应该显示在第 1 行，以此类推，这意味着 indexPath 的行号与我们希望访问的生日数组中的位置相同。➋处的代码通过使用 indexPath.row 从生日数组中获取正确的生日对象。一旦我们得到了正确的生日对象，我们就将其赋值给一个名为 birthday 的常量，以便设置此单元格中的标签。

请注意，我们使用 let 将生日赋值给一个常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都会获得自己的生日常量，并将其分配给自己的生日对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以我们不想将它们设为变量。

现在你已经有了单元格和生日，是时候填充细节信息了。你需要为每个单元格添加两个标签，用来显示生日人的名字和出生日期。你将单元格设置为副标题样式，这样它就有了标题标签和副标题标签。每个单元格将已经包含这些标签，因此你现在不需要自己创建标签。

这些标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间有一个空格。➍ 处，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当单元格完全配置好后，tableView(_:cellForRowAt:) 会在 ➎ 返回该单元格，以便它可以显示在表格视图的对应 indexPath 位置。

### 整合（PUTTING IT ALL TOGETHER）

现在，你可以使用添加生日视图控制器将生日实例添加到应用程序中，并且在生日表格视图控制器中有一个表格视图来列出每个生日。但是，当你尝试运行应用并添加一个生日时，它没有显示。为了让你添加的每个生日都出现在表格视图中，你需要让添加生日视图控制器与生日表格视图控制器进行通信。你可以通过使用*代理（delegation）*来实现这一点。

#### 代理（DELEGATION）

代理可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己之上。A 知道 B 的存在，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 并不知道 A，它只是突然出现，并不知道自己是从哪里来的或者是如何到达的。那么 B 如何与 A 进行交流呢？通过代理！

![](img/Image00245.jpg)

委托是指有人将工作或任务交给另一个人。一个 *代理* 就像一个老板，告诉委托员工该做什么。当委托员工完成任务后，有时他们会向代理老板报告信息。

在 Swift 中，委托与传统的老板和员工关系非常相似，但我们有一个代理和一个委托对象。由于是类 A 告诉类 B 做什么，所以类 B 是委托对象。我们给类 B 一个特殊的属性叫做 delegate 来告知它代理是谁——这样，它就知道该与谁沟通。代理可以是任何一个定义了协议中方法集合的类。协议就像是两个类之间的约定，告诉它们代理可以要求委托对象做什么。协议包含了一组方法和属性名称，代理可以用这些方法和属性与委托对象交互。

类 A 创建类 B，将自己设置为类 B 的代理，并为类 B 分配一个协议中的任务。一旦类 B 完成任务，它会向类 A 报告。让我们看看这在我们的应用中如何工作。

`Birthdays` 表格视图控制器是视图控制器 A，而“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 `AddBirthdayViewControllerDelegate` 的协议，并为该协议定义一个方法 `addBirthdayViewController(_:didAddBirthday:)`，该方法将由“添加生日”视图控制器用于反馈信息。

请看一下 图 11-6。当用户点击“添加”按钮 ➊ 时，`Birthdays` 表格视图控制器创建“添加生日”视图控制器 ➋ 并将自己设置为该视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托传递给 `Birthdays` 表格视图控制器。*

`AddBirthdayViewControllerDelegate` 协议定义了一个方法 `addBirthdayViewController(_:didAddBirthday:)`。当用户点击“保存” ➌ 时，“添加生日”视图控制器调用这个方法 ➍ 并将新添加的生日传递给它的代理——`Birthdays` 表格视图控制器。`Birthdays` 表格视图控制器接受这个生日，将其添加到自己的生日数组中，然后重新加载其表格视图 ➎，这样新添加的生日就会出现在表格中。

我们将向你展示如何创建一个 `AddBirthdayViewControllerDelegate` 协议，里面包含方法 `addBirthdayViewController(_:didAddBirthday:)`，该方法可以在每次添加生日时由“添加生日”视图控制器调用。`Birthdays` 表格视图控制器将实现该协议方法，这样每当通过“添加生日”视图控制器添加一个生日时，`Add Birthday` 视图控制器只需对其代理说：“嘿！有人刚刚添加了这个生日”，然后 `Birthdays` 表格视图控制器会收到这个消息并说：“哦！我会将其添加到我的列表中，并刷新显示以便新生日能显示出来。”

那么现在让我们用代码实现这一过程！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类 *上方*，添加这段代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过在 ➊ 位置键入关键字 protocol，并跟上 AddBirthdayViewControllerDelegate 的名称来定义协议。这个名字比较长，但 Swift 程序员通常会根据调用类命名协议，并在末尾加上 Delegate 这个词。这样你就能通过协议的名称看出是哪个类在使用该协议。既然你现在是一个 Swift 程序员，应该遵循相同的命名规范。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传递回委托类 ➋。注意，在这个函数中，你将 AddBirthdayViewController 作为参数传入。同样，Swift 程序员在实现协议方法时通常会这么做，所以你也应该遵循这个惯例。这样做有助于知道是谁发送了消息，并且让委托能够访问该对象及其类。

当 Add Birthday 视图控制器调用此方法时，它会将自身作为 addBirthdayViewController 参数传入。你很快就会看到是如何实现的。另一个需要注意的点是外部参数名 didAddBirthday。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用于描述调用类已经做了或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays table view controller 采纳这个协议并使用协议的方法。

##### 使 Birthdays Table View Controller 遵循协议

为了采纳协议，Birthdays table view controller 需要将自己声明为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在 UITableViewController 超类之后将 AddBirthdayViewControllerDelegate 添加到类定义中。在类的顶部，在 UITableViewController 后加一个逗号，然后键入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色的错误就会出现。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了实现协议，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，并且该超类的名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采纳任意多个协议——这些协议将列在超类之后，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议你整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它预期你会添加这个方法。请注意，与子类化方法不同，在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传入的生日添加到 birthdays 数组中。你可以通过使用 append(_:) 方法来实现这一点 ➋。接下来，你需要刷新表视图，以便它能显示这个新添加的生日，通过调用 tableView 属性上的 reloadData() 方法 ➌。当调用 reloadData() 方法时，表视图的数据源方法会再次被调用，新的生日将会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但标记类的不同部分是一种良好的编码风格，它有助于保持代码整洁易读。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，供你在类的顶部使用。这个下拉菜单帮助你查找方法，并让你跳转到代码中的不同位置。要使用这个菜单，请点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告知 Birthdays 表视图控制器何时添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 outlets 下面插入以下代码，为 AddBirthdayViewController 类添加一个可选的代理属性，类型为 AddBirthdayViewControllerDelegate：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你无法在创建 Add Birthday 视图控制器之后设置它。稍后你会学习如何设置代理。

既然添加生日视图控制器已经有了代理，在`saveTapped(_:)`方法中，你可以通过`addBirthdayViewController(_:didAddBirthday:)`方法将生日对象传递给代理。将`saveTapped(_:)`修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊处的代码通过`addBirthdayViewController(_:didAddBirthday:)`方法将其传回给代理。

太棒了！你已经完成了对添加生日视图控制器的修改。它现在有了一个代理，会监听生日已保存的通知。运行应用，看看会发生什么。

嗯……没什么变化。当你添加一个生日时，依然看不到它出现在生日列表视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有一件事需要做。生日列表视图控制器是`AddBirthdayViewControllerDelegate`，而添加生日视图控制器有一个`AddBirthdayViewControllerDelegate`类型的属性，用于保存它在保存生日时与之通信的代理。但我们从未明确将代理属性设置为生日列表视图控制器。所以现在是时候建立我们两个视图控制器之间的通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个被注释掉的方法叫做`prepare(for:sender:)`。删除它前后的`/*`和`*/`，取消注释这个方法。

当生日列表视图控制器退出其屏幕并且应用通过故事板 segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将生日列表视图控制器传递给添加生日视图控制器，并将其设置为添加生日视图控制器的代理。在`prepare(for:sender:)`方法中写下以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码，就能将添加生日视图控制器的代理设置为生日列表视图控制器。首先，你需要能够从 segue 参数中获取到`AddBirthdayViewController`对象。Xcode 已经在注释中给出了如何做的提示。`UIStoryboardSegue`在准备过程中有一个名为`destination`的属性，但对于本应用来说，`destination`并不是`AddBirthdayViewController`。

在第九章中，你将添加生日视图控制器嵌入到一个导航控制器中，这样你就可以有一个带有“取消”和“保存”按钮的导航栏。所以你不会在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的`UINavigationController`。➊处的代码帮助你获取到`navigationController`。`segue.destination`会返回一个`UIViewController`，但是由于我们的`navigationController`是特定类型的视图控制器，我们需要通过`as`进行类型转换，将其转换为`UINavigationController`。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，所以必须进行类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 时，你可以将委托设置为 self，而 self 当前是 Birthdays 表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在 Birthdays 表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完成。如果你退出应用程序然后再运行，之前的生日将消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在这一章中，你学会了如何创建一个表格视图控制器来显示生日列表。你还学会了如何在 Add Birthday 视图控制器中添加一个生日，然后如何通过委托将生日添加到 Birthdays 表格视图控制器中的生日数组，以便它能够被显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用程序并再次运行，它们也能显示出来。为了保存生日，你将使用我们在项目一开始就设置的 Core Data。

最后，你需要实现 tableView(_:cellForRowAt:)方法，以便表格视图能够知道在每个单元格中放置什么内容。由于这个方法被注释掉了，你需要通过删除/*和*/来取消注释它。（小心不要意外取消注释它后面的其他方法！）完成后，将其修改为以下代码：

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用 tableView(_:cellForRowAt:)方法。它会在表格视图加载到屏幕上时被调用。它会为屏幕上的每个单元格调用一次，并接受两个参数，tableView 和 indexPath。你已经知道 tableView 参数的作用。IndexPath 是一个 Swift 结构体，用来表示表格视图中某一行的位置。一个 IndexPath 实例有 section 属性和 row 属性。由于这个方法会被调用多次（每个表格中的一行），我们需要 indexPath 来知道当前配置的是哪个 section 和 row。indexPath.section 属性提供 section 的编号，indexPath.row 提供表格视图单元格的行号。tableView(_:cellForRowAt:)中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 找出在生日数组中哪个生日将显示在单元格中

• 创建两个标签来显示生日人的姓名和出生日期

• 返回准备好在表格视图中显示的单元格

让我们逐行分析这段代码。

首先，创建`UITableViewCell`。➊处的代码使用`dequeueReusableCell(withIdentifier:for:)`方法来实现这一点。不过，在你开始使用这个方法之前，你需要告诉它你想要使用哪个单元格。之前，在 Storyboard 中，你为你的单元格设置了标识符`birthdayCellIdentifier`（参见图 11-4）。这个标识符将你的代码与单元格连接起来，并告诉你的方法正在使用正确的单元格。当你调用此方法时，字符串需要与在 Storyboard 中设置的字符串完全相同，否则你会遇到错误，应用程序在运行时会崩溃。

在方法`dequeueReusableCell(withIdentifier:for:)`中，你有没有注意到“*可重用单元格*”这几个词？表格视图中的单元格只创建一次，然后可以反复使用。这有助于提高性能，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日，但是每次屏幕上只能显示 10 个，那么你只需要 10 个单元格来展示这些生日。当你向下滚动以查看更多生日时，滚出屏幕顶部的单元格将被重用。它们会被填充新的信息，然后出现在屏幕底部。UITableView 会自动完成这项工作。当表格视图加载时，会为每一行可见的单元格调用`tableView(_:cellForRowAt:)`。当用户滚动以查看更多单元格时，它会在每一行即将出现在屏幕上时再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中显示`birthdays`数组中的一个生日。第一个生日（位于`birthdays[0]`）应该显示在第 0 行，第二个生日（位于`birthdays[1]`）应该显示在第 1 行，依此类推，这意味着`indexPath`的`row`与我们要访问的`birthdays`数组中的位置相同。➋处的代码通过使用`indexPath.row`从`birthdays`数组中访问正确的生日对象。一旦我们拿到正确的生日对象，我们将其赋值给一个名为`birthday`的常量，以便我们可以设置此单元格中的标签。

注意，我们使用`let`来将生日赋值给常量而不是变量。我们可以使用`let`，因为每次调用`tableView(_:cellForRowAt:)`时，都会创建一个新的生日常量。每个单元格都会得到自己的生日常量，并赋值为自己的生日对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以我们不需要将它们定义为变量。

现在你有了单元格和生日信息，接下来是填充详细信息。你需要为每个单元格设置两个标签来显示生日人的名字和出生日期。你将单元格设置为`Subtitle`样式，这样它就有了一个标题标签和一个副标题标签。每个单元格已经包含这些标签，所以现在你不需要自己创建任何标签。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。在➌处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格隔开。在➍处，你使用 dateFormatter 的 string(from:)方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:)会在➎处返回单元格，以便将其显示在该 indexPath 对应的表格视图中。

### 将一切整合在一起

现在，你可以通过添加生日视图控制器来向应用程序添加生日实例，并且你有一个表格视图来列出每个生日，显示在生日表格视图控制器中。但是，当你尝试运行应用程序并添加生日时，它并没有显示出来。为了让每个你添加的生日出现在表格视图中，你需要让添加生日视图控制器与生日表格视图控制器进行通信。你可以通过使用*代理模式*来实现这一点。

#### 代理模式

代理模式可以用于当一个视图控制器需要从另一个视图控制器获取信息时。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 呈现在自己之上。A 知道 B，因为它创建并呈现了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它只是突然出现的，并不知道它来自哪里或如何到达那里。那么 B 怎么能与 A 进行通信呢？通过代理模式！

![](img/Image00245.jpg)

代理模式是指某人将一个任务或工作交给别人。*代理*就像是一个老板，告诉委托员工该做什么。当委托员工完成任务后，他们有时会向代理老板报告信息。

在 Swift 中，代理模式与此类似，不过我们没有老板和员工，而是有代理和委托对象。由于类 B 是由类 A 告诉要做什么的，因此它是委托对象。我们给类 B 一个特殊的属性，称为 delegate，用来告诉它谁是它的代理——这样，它就知道与谁进行通信。代理可以是任何拥有在*协议*中定义的一组方法的类。协议就像是两个类之间的约定，告诉它们代理可以让委托对象做些什么。协议中有一系列方法和属性名，代理可以使用这些方法和属性与委托对象进行交互。

类 A 创建类 B，将自己设为类 B 的代理，并赋予类 B 一个协议中的任务。一旦类 B 完成其任务，它会向类 A 报告。让我们看看这个过程是如何在应用程序中工作的。

生日表格视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法由添加生日视图控制器用于反馈信息。

看看图 11-6。当用户点击添加按钮 ➊ 时，Birthdays 表格视图控制器会创建 Add Birthday 视图控制器 ➋，并将自己设置为 Add Birthday 视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从 Add Birthday 视图控制器传递给 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为具有一个方法`addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存按钮 ➌ 时，Add Birthday 视图控制器会调用这个方法 ➍，并将新的生日传递给它的委托对象，即 Birthdays 表格视图控制器。Birthdays 表格视图控制器接收到这个生日后，将其添加到它的生日数组中，然后重新加载表格视图 ➎，以便新生日能够显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义方法`addBirthdayViewController(_:didAddBirthday:)`，这样每当有生日被添加到应用时，Add Birthday 视图控制器就可以调用该方法。Birthdays 表格视图控制器会实现这个协议方法，这样每当通过 Add Birthday 视图控制器添加一个生日时，Add Birthday 视图控制器就可以对其委托说：“嘿！刚刚有人添加了这个生日，”而 Birthdays 表格视图控制器会收到这个消息并回应：“哦！我会把它添加到我的列表中，并刷新我的显示，以便新的生日能显示出来。”

现在让我们在代码中实现这个功能吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，*在* AddBirthdayViewController 类之前，添加这段代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过在➊位置输入关键字`protocol`并跟上名称 AddBirthdayViewControllerDelegate 来定义协议。这是一个很长的名字，但 Swift 程序员通常会根据调用类的名称命名协议，并在末尾加上"Delegate"一词。这样，你就可以通过查看协议的名称来知道哪个类在使用这个协议。既然你现在是 Swift 程序员，你应该遵循相同的命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)`是唯一的函数，用于将 Birthday 对象传回委托类 ➋。注意，在这个函数中你包含了 AddBirthdayViewController 作为参数。再次提醒，Swift 程序员在实现协议方法时通常遵循这个惯例，所以你也应该遵守这一点。知道是谁发送回的消息，以及委托能够访问那个对象及其类，是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递过来。你很快就会看到具体怎么做。另一个需要注意的点是外部参数名 didAddBirthday。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用于描述调用类刚刚做过的或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表格视图控制器遵循这个协议并使用协议的方法。

##### 使 Birthdays Table View Controller 遵循协议

为了遵循协议，Birthdays 表格视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中将 AddBirthdayViewControllerDelegate 添加到 UITableViewController 超类之后。在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色错误就会出现。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了解决这个问题，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快会修复这个问题。

这里需要注意的是，BirthdaysTableViewController 是在继承 UITableViewController 超类。一个类只能有一个超类，而且这个超类的名称必须写在任何协议之前。但尽管一个类只能有一个超类，它可以遵循尽可能多的协议——这些协议都会在超类后列出，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的添加位置是在类的末尾，紧接着导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成功能会建议整个方法声明。这是因为它知道这个类遵循了 AddBirthdayViewControllerDelegate 协议，并且它期待你添加这个方法。请注意，不像子类化的方法，你在 addBirthdayViewController(_:didAddBirthday:) 前不会使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传入的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来完成这一操作 ➋。接下来，你需要刷新表格视图，以便显示这个新的生日，方法是调用 tableView 属性的 reloadData() 方法 ➌。当调用 reloadData() 时，表格视图的数据源方法会被重新调用，新的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但标记类的不同部分是一个良好的编码风格，它有助于保持代码的清晰和可读。注释的第一部分，MARK: - ，是一个 Xcode 识别的特殊关键字，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录中，你可以在类的顶部使用该菜单。这个下拉菜单有助于你找到方法并跳转到代码中的不同位置。要使用这个菜单，请点击编辑窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内建的目录，可以快速跳转到某一部分。*

##### 给添加生日视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告知 Birthdays 表视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类的 outlet 下面插入以下代码来安排此操作：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你无法在 Add Birthday 视图控制器创建之前设置它。稍后你将学习在哪里设置代理。

现在，Add Birthday 视图控制器有了一个代理，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日传递给代理。将 saveTapped(_:) 方法修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 将其传回给代理。

很棒！你已经完成了对 Add Birthday 视图控制器的更改。现在它有了一个代理，可以监听生日被保存的事件。运行应用看看会发生什么。

嗯...没什么变化。当你添加一个生日时，它仍然没有出现在 Birthdays 表视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事需要做。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存着当生日被保存时，Add Birthday 视图控制器与之通信的代理。但我们从未明确地将代理属性设置为 Birthdays 表视图控制器。所以，现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个被注释掉的方法 prepare(for:sender:)。通过删除它周围的 /* 和 */，取消注释这个方法。

当 Birthdays 表视图控制器放弃其屏幕并且应用程序通过 storyboard segue 转到另一个视图控制器时，这个方法会自动调用。我们将使用这个方法将 Birthdays 表视图控制器传递给 Add Birthday 视图控制器，以便将自己设置为 Add Birthday 视图控制器的委托。在 prepare(for:sender:) 方法中编写如下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置将 Add Birthday 视图控制器委托传递给 Birthdays 表视图控制器的代码只需要三行。首先，你需要能够通过 segue 参数获取到 AddBirthdayViewController 对象。Xcode 留下了一条注释，提示你可以如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，它是这个方法中准备的 segue 的另一端，但这个应用的目标视图控制器并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到一个导航控制器中，这样你就可以有一个带有“取消”和“保存”按钮的导航栏。所以你不应该期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊ 这一行代码获取了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定子类，我们需要使用 as 强制类型转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的类型是 UIViewController，因此必须将其强制类型转换为 AddBirthdayViewController，以表明这是一个 UIViewController 的特定子类。最后，当你得到一个 AddBirthdayViewController 后，你可以将委托设置为 self，也就是当前的 Birthdays 表视图控制器 ➌。

现在运行应用并添加一些生日！你在 Birthdays 表视图控制器中看到什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用并再次运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学习了如何创建一个表视图控制器来显示你的生日列表。你还学习了如何在 Add Birthday 视图控制器中添加一个生日，然后如何使用委托将生日添加到 Birthdays 表视图控制器中的生日数组中，从而使其能够显示出来。

在第十二章，你将学习如何将生日保存到你的设备中，这样即使你退出应用并重新启动，它们依然会显示。为了保存生日，你将使用 Core Data，这在我们项目的最初设置中已经完成。

```
override func tableView(_ tableView: UITableView, cellForRowAt ![](img/Image00184.jpg)

    indexPath: IndexPath) -> UITableViewCell {

  ➊
 let
 cell = tableView.dequeueReusableCell
 (withIdentifier: 

        "birthdayCellIdentifier"
 , for: indexPath)

  ➋
 let
 birthday = birthdays
 [indexPath.row
 ]

  ➌
 cell.textLabel
 ?.text
 = birthday.firstName
 +
 " "
 +

        birthday.lastName

  ➍
 cell.detailTextLabel
 ?.text
 = dateFormatter
 .string
 (from: 

        birthday.birthdate
 )

  ➎
 return
 cell

}

```

你不会直接调用方法 `tableView(_:cellForRowAt:)`。这个方法在表格视图加载到屏幕时被调用。它会为屏幕上的每个单元格调用，并接受两个参数，`tableView` 和 `indexPath`。你已经知道 `tableView` 参数的作用。`IndexPath` 是一个 Swift 结构体，用于表示表格视图中某一行的位置。`IndexPath` 实例有两个属性：`section` 和 `row`。由于这个方法会被多次调用（每一行都会调用一次），我们需要 `indexPath` 来知道我们当前正在配置的是哪一节哪一行。`indexPath.section` 属性给出节的编号，而 `indexPath.row` 给出表格视图单元格的行号。`tableView(_:cellForRowAt:)` 中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 `UITableViewCell`

• 确定哪个生日在 `birthdays` 数组中将显示在单元格内

• 创建两个标签，用于在单元格中显示生日人的姓名和出生日期

• 返回准备好在表格视图中显示的单元格

让我们逐行分析这段代码。

首先，创建 `UITableViewCell`。代码 ➊ 使用方法 `dequeueReusableCell(withIdentifier:for:)` 来实现这一点。然而，在开始使用该方法之前，你需要告诉该方法你想要从故事板中使用哪个单元格。之前，在故事板中，你为单元格设置了标识符 `birthdayCellIdentifier`（见 图 11-4）。这个标识符将你的代码与单元格关联，并告诉方法它正在使用正确的单元格。当你调用此方法时，传递的字符串必须与故事板中设置的字符串完全一致，否则你会遇到错误，应用会崩溃。

在方法 `dequeueReusableCell(withIdentifier:for:)` 中，你是否注意到“*可重用单元格*”这几个词？表格视图中的单元格只会创建一次，然后可以反复重用。这有助于提高运行速度和流畅度，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只有 10 个能够显示在屏幕上，那么你只需要 10 个单元格来展示生日。当你向下滚动以显示更多生日时，滚动出屏幕顶部的单元格会被重用。它们会被填充新的信息，并在屏幕底部再次显示。`UITableView` 会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)` 会为每一行可见单元格调用。当用户滚动查看更多单元格时，这个方法也会在每个即将出现在屏幕上的行上再次被调用。

接下来，我们需要找出应该在单元格内显示哪个生日。我们希望在每一行中显示一个来自生日数组（birthdays array）的生日。第一个生日，即 birthday[0]，应该显示在第 0 行；第二个生日，即 birthday[1]，应该显示在第 1 行，依此类推，这意味着 indexPath 的行号和我们希望访问的生日数组中的位置相同。代码在➋通过使用 indexPath.row 访问 birthday 数组中的正确生日对象。一旦我们得到了正确的生日对象，就将其赋值给一个名为 birthday 的常量，这样我们就可以设置该单元格中的标签。

注意，我们使用 let 将生日赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并将自己的生日对象赋值给它。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以我们不需要将它们设为变量。

现在你已经有了单元格和生日，是时候填写详细信息了。你需要为每个单元格添加两个标签，分别显示生日人的名字和出生日期。你将单元格设置为副标题样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，因此现在你不需要自己创建标签了。

标签作为 UITableViewCell 的属性存在，分别被称为 textLabel 和 detailTextLabel。代码在➌将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格隔开。在➍处，你使用 dateFormatter 的 string(from:)方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:)会在➎返回该单元格，以便在表格视图的该 indexPath 位置显示它。

### 将所有内容组合起来（PUTTING IT ALL TOGETHER）

现在，你可以使用添加生日视图控制器（Add Birthday view controller）将生日实例添加到应用中，并且你有一个表格视图来列出每个生日，在生日表格视图控制器（Birthdays table view controller）中显示。但是，当你尝试运行应用并添加一个生日时，它并没有显示。为了让你添加的每个生日出现在表格视图中，你需要让添加生日视图控制器与生日表格视图控制器进行通信。你可以通过使用*委托（delegation）*来实现这一点。

#### 委托（DELEGATION）

委托（delegation）可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 显示在 A 之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 不知道 A——它刚刚被展示出来，不知道自己从哪里来，怎么到这儿的。那么，B 怎么和 A 沟通呢？通过委托！

![](img/Image00245.jpg)

委托是一种把工作或任务交给别人做的方式。*委托者*就像是一个老板，告诉委托员工该做什么。当委托员工完成任务后，他们有时会向委托者报告信息。

Swift 中的委托（Delegation）非常相似，但与其说是有一个老板和员工，不如说是有一个委托者和一个委托对象。由于类 B 是被类 A 告诉要做什么的，因此它是委托对象。我们给类 B 一个特殊的属性，叫做 delegate，用来告诉它它的委托者是谁——这样，它就知道该与谁进行通信。委托者可以是任何拥有在*协议*中定义的一组方法的类。协议就像是两个类之间的约定，告诉它们委托者可以要求委托对象做些什么。它包含了委托者可以与委托对象一起使用的所有方法和属性名称。

类 A 创建类 B，把自己设置为类 B 的委托，并给类 B 分配一个在协议中定义的任务。等到类 B 完成任务后，它会将结果报告给类 A。让我们看看在我们的应用中是如何实现的。

Birthdays 表格视图控制器是视图控制器 A，Add Birthday 视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将被 Add Birthday 视图控制器用于报告结果。

请查看图 11-6。当用户点击添加按钮 ➊ 时，Birthdays 表格视图控制器创建 Add Birthday 视图控制器 ➋ 并将自己设置为 Add Birthday 视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新生日被添加，并通过委托从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为包含一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，Add Birthday 视图控制器会调用此方法 ➍ 并将新添加的生日传递给它的委托，即 Birthdays 表格视图控制器。Birthdays 表格视图控制器会接收该生日，将其添加到其生日数组中，然后重新加载其表格视图 ➎，这样新添加的生日就会出现在表格中。

我们将向你展示如何创建一个名为 AddBirthdayViewControllerDelegate 的协议，协议中包含方法 addBirthdayViewController(_:didAddBirthday:)，当有生日被添加到应用程序时，Add Birthday 视图控制器可以调用这个方法。Birthdays 表格视图控制器将实现该协议方法，这样，每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器就可以对其委托者说：“嘿！有人刚刚添加了一个生日。”然后 Birthdays 表格视图控制器会收到这个消息并回应：“哦！我会把这个添加到我的列表里，并刷新显示，以便新添加的生日能够显示出来。”

现在让我们在代码中实现这一功能！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类*上方*，添加定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处通过输入关键字 protocol 来定义协议，后面跟着 AddBirthdayViewControllerDelegate 的名称。这个名字很长，但 Swift 程序员通常会根据调用类来命名他们的协议，并在末尾加上 Delegate 这个词。这样，你就能通过查看协议的名字知道是哪个类在使用这个协议。既然你现在是 Swift 程序员了，就应该遵循相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传回委托类 ➋ 。请注意，在这个函数中你包括了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员在实现协议方法时，通常会按约定这样做，因此你也应该遵循这个做法。知道是谁发送了消息，并且委托可以访问该对象及其类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它将把自身作为 addBirthdayViewController 参数传入。你很快就会看到是如何做到这一点的。另一个需要注意的点是外部参数名称 didAddBirthday。许多委托协议方法都包含*did*和*will*这两个词，因为它们用于描述调用类刚刚做过的事情或即将做的事情。

现在你已经定义了协议，接下来需要告诉 Birthdays 表视图控制器去采用这个协议并使用协议中的方法。

##### 使 Birthdays 表视图控制器遵循协议

为了采用这个协议，Birthdays 表视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中，在 UITableViewController 超类后添加 AddBirthdayViewControllerDelegate。在类的顶部，给 UITableViewController 后面加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色错误提示就会出现。这是因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate，但还没有实现这个协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会修复这个问题。

这里需要特别注意的是，BirthdaysTableViewController 是从 UITableViewController 超类继承的。一个类只能有一个超类，且超类的名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采用任意数量的协议——这些协议会在超类之后列出，并用逗号隔开。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个好的位置是在类的末尾，紧跟在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议这个完整的方法声明。这是因为它知道该类采用了 AddBirthdayViewControllerDelegate 协议，并且它期望你添加这个方法。请注意，与子类化方法不同，你不需要在 addBirthdayViewController(_:didAddBirthday:) 前使用 override 关键字，因为没有原始方法需要被重写。

在此方法中，你需要做两件事。首先，你需要将通过添加生日视图控制器传入的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来完成此操作 ➋ 。接下来，你需要刷新表格视图，以便它显示这个新的生日，方法是调用 tableView 属性的 reloadData() 方法 ➌ 。当 reloadData() 被调用时，表格视图的数据源方法将会重新调用，新增的生日将会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这并不是必须的，但良好的编程风格是标记类中的不同部分，并有助于保持代码清晰和易于阅读。注释的第一部分 MARK: - 是 Xcode 识别的特殊关键词，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单可以帮助你找到方法，并让你跳转到代码中的不同位置。要使用此菜单，请点击编辑器面板顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，方便快速跳转到某个部分。*

##### 为添加生日视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议来告知 Birthdays 表格视图控制器它已经添加了一个生日。为此，添加生日视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性来完成这一操作，将以下代码行插入到 outlets 下方：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在添加生日视图控制器创建之前设置它。你将在稍后学习如何设置代理。

现在`AddBirthdayViewController`已经有了一个委托，在`saveTapped(_:)`方法中，你可以通过`addBirthdayViewController(_:didAddBirthday:)`方法将生日传递给委托。将`saveTapped(_:)`修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊处的代码通过`addBirthdayViewController(_:didAddBirthday:)`将其传回给委托。

太棒了！你已经完成了对`AddBirthdayViewController`的修改。它现在有了一个委托，可以监听生日保存的调用。运行应用程序查看发生了什么。

嗯...变化不大。当你添加一个生日时，仍然没有看到它显示在`Birthdays`表视图控制器中。怎么回事？

#### 通过设置委托连接两个控制器

还有一件事需要做。`Birthdays`表视图控制器是`AddBirthdayViewControllerDelegate`的委托，而`AddBirthdayViewController`有一个`AddBirthdayViewControllerDelegate`属性，用来存储当生日保存时它与之通信的委托。但是我们从未明确设置过委托属性为`Birthdays`表视图控制器。所以现在是时候在这两个视图控制器之间建立通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个被注释掉的方法叫做`prepare(for:sender:)`。通过删除包围它的/*和*/来取消注释该方法。

每当`Birthdays`表视图控制器放弃屏幕并通过故事板 segue 过渡到另一个视图控制器时，这个方法会自动被调用。我们将使用此方法将`Birthdays`表视图控制器传递给`AddBirthdayViewController`，并将其自身设置为`AddBirthdayViewController`的委托。在`prepare(for:sender:)`方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码就能将`AddBirthdayViewController`的委托设置为`BirthdaysTableViewController`。首先，你需要能够从`segue`参数访问到`AddBirthdayViewController`对象。Xcode 在注释中留下了提示，告诉你如何做到这一点。`UIStoryboardSegue`有一个名为`destination`的属性，表示正在准备的 segue 的目标，但对于这个应用程序来说，目标并不是`AddBirthdayViewController`。

在第九章中，你将`AddBirthdayViewController`嵌入到了一个导航控制器中，这样就可以有一个带有取消和保存按钮的导航栏。所以你不会期望在 segue 的另一端找到`AddBirthdayViewController`。相反，目标是一个`UINavigationController`，它包含了`AddBirthdayViewController`。➊处的代码获取了`navigationController`。`segue.destination`将返回一个`UIViewController`，但是由于我们的`navigationController`是特定类型的视图控制器，我们需要使用`as`将其强制类型转换为`UINavigationController`。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的特定子类。最后，当你获取到 AddBirthdayViewController 时，你可以将 delegate 设置为 self，self 当前是生日表视图控制器 ➌。

现在运行应用并添加一些生日！在生日表视图控制器中你看到什么？生日！生日！生日！不过，我们还没完全完成。如果你退出应用并重新启动，之前的生日将消失。我们仍然需要将生日信息保存到设备中，这将在第十二章中完成。

### 你学到的内容

在本章中，你学习了如何制作一个表视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，然后通过使用委托将生日添加到生日表视图控制器中的生日数组中，以便它可以被显示出来。

在第十二章中，你将学习如何将生日信息保存到你的设备中，以便即使你退出应用程序并重新启动，它们仍然会显示出来。为了保存生日信息，你将使用我们在项目开始时设置的 Core Data。

你不会直接调用 tableView(_:cellForRowAt:)方法。它会在表视图加载到屏幕时被调用。它会为屏幕上的每个单元格被调用，并接受两个参数，tableView 和 indexPath。你已经知道 tableView 参数的作用了。IndexPath 是一个 Swift 结构体，用于表示表视图中某一行的位置。一个 IndexPath 实例有一个 section 属性和一个 row 属性。由于这个方法会被调用多次（每行调用一次），我们需要 indexPath 来知道我们当前在配置哪个 section 和 row。indexPath.section 属性提供了 section 的编号，indexPath.row 则提供了表视图单元格的行号。tableView(_:cellForRowAt:)中的五行代码将执行以下操作：

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 确定将在单元格中显示的生日数组中的哪个生日

• 创建两个标签来显示单元格中生日人物的姓名和出生日期

• 返回准备好在表视图中显示的单元格

让我们逐行查看这段代码。

首先，创建 UITableViewCell。➊处的代码使用方法 dequeueReusableCell(withIdentifier:for:)来完成这项工作。然而，在您开始在单元格上使用这个方法之前，您需要告诉方法您想要从故事板中使用哪个单元格。之前，在故事板中，您给单元格设置了标识符 birthdayCellIdentifier（请参见图 11-4）。这个标识符将您的代码与单元格关联，并告诉您的方法它正在使用正确的单元格。您调用此方法时所用的字符串必须与您在故事板中设置的字符串完全相同，否则您会收到错误，且应用程序在运行时会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:)中，您注意到*Reusable Cell*这个词了吗？表格视图中的单元格只会创建一次，然后可以重复使用。这有助于提高速度和流畅度，因为创建单元格是最耗时的部分。如果您的应用中有 200 个生日，但每次屏幕上只能显示 10 个，那么您只需要 10 个单元格来显示这些生日。当您向下滚动以显示更多的生日时，滚出屏幕顶部的单元格会被重新使用。它们会填充新的信息，并在屏幕底部重新显示。UITableView 会自动完成这项工作。当表格视图加载时，tableView(_:cellForRowAt:)会为每一行可见的单元格被调用。当用户滚动查看更多单元格时，方法会再次被调用，每次是当单元格即将出现在屏幕上时。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行显示 birthday 数组中的一个生日。第一个生日，位于 birthdays[0]，应该显示在第 0 行。第二个生日，位于 birthdays[1]，应该显示在第 1 行，以此类推，这意味着 indexPath 的行号与我们希望访问的 birthday 数组中的位置相同。➋处的代码通过使用 indexPath.row 从 birthdays 数组中获取正确的 Birthday 对象。一旦我们得到了正确的 Birthday 对象，我们就将它分配给一个名为 birthday 的常量，以便我们设置单元格中的标签。

请注意，我们使用 let 将生日分配给常量，而不是变量。我们之所以使用 let，是因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都会有一个自己的生日常量，该常量被分配一个独立的 Birthday 对象。由于我们不打算更改任何生日常量——我们只是读取它们的属性——所以我们不希望将它们设置为变量。

现在您已经有了单元格和生日，是时候填写详细信息了。每个单元格需要两个标签来显示生日人的名字和生日日期。您将单元格设置为 Subtitle 样式，这样它就会有一个 Title 标签和一个 Subtitle 标签。每个单元格已经包含了这些标签，因此现在您不需要自己创建标签了。

标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。在➌的代码中，textLabel 的文本被设置为由生日的 firstName 和 lastName 组成的字符串，两者之间有一个空格。在➍中，你使用 dateFormatter 的 string(from:)方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 会返回单元格 ➎，以便在表格视图的该索引路径处显示它。

### 汇总

现在，你可以使用“添加生日”视图控制器将生日实例添加到应用程序中，并在“生日”表格视图控制器中列出每个生日。但是，当你尝试运行应用并添加生日时，它并不会显示。为了让你添加的每个生日都出现在表格视图中，你需要让“添加生日”视图控制器与“生日”表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 展示在自己之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 并不知道 A——它只是突然出现在那里，根本不知道自己从哪里来，也不知道怎么到达的。那么 B 怎么和 A 沟通呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将工作或任务交给别人。一个*委托人*就像一个老板，告诉被委托的员工该做什么。当被委托的员工完成任务后，有时他们会将信息报告给委托的老板。

在 Swift 中，委托也类似，但我们不是有老板和员工，而是有委托人和委托对象。由于类 B 是被类 A 告知该做什么的对象，因此它是委托对象。我们给类 B 一个特殊的属性，叫做 delegate，用来告诉它它的委托是谁——这样它就知道该与谁通信。委托可以是任何拥有一组在*协议*中定义的方法的类。协议就像是两类之间的协议，告诉它们委托可以要求委托对象做什么。它包含了委托可以与委托对象一起使用的方法和属性名称的列表。

类 A 创建类 B，使其成为类 B 的委托，并给类 B 分配一个符合协议的任务。一旦类 B 完成了任务，它会向类 A 报告。让我们看看在我们的应用程序中是如何实现的。

“生日”表格视图控制器是视图控制器 A，“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将由“添加生日”视图控制器用来报告。

看一下图 11-6。当用户点击“添加”按钮➊时，生日表视图控制器创建了“添加生日”视图控制器➋，并将自己设置为“添加生日”视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日通过委托从“添加生日”视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为有一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击“保存”➌时，“添加生日”视图控制器调用这个方法➍并将新的生日对象传递给它的委托，即生日表视图控制器。生日表视图控制器将该生日对象添加到其生日数组中，并重新加载其表视图➎，以便新的生日出现在表中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，其中包含方法 addBirthdayViewController(_:didAddBirthday:)，每当一个生日被添加到应用中时，添加生日视图控制器就可以调用此方法。生日表视图控制器将实现该协议方法，以便每当通过添加生日视图控制器添加一个生日时，添加生日视图控制器只需要对其委托说：“嘿！有人刚刚添加了这个生日。”然后，生日表视图控制器会收到消息并说：“哦！我会把它添加到我的列表中，并刷新我的显示，以便新的生日出现在表格中。”

现在，让我们在代码中实现这个！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类*之前*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过输入关键字 protocol 来定义协议，后跟名称 AddBirthdayViewControllerDelegate，如➊所示。这个名称比较长，但 Swift 程序员通常会根据调用类的名称来命名协议，并在结尾加上“Delegate”一词。这样，你就可以通过查看协议的名称来知道是哪个类在使用该协议。既然你现在是一个 Swift 程序员，你也应该使用相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，用来将生日对象传递回委托类➋。请注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。再说一次，Swift 程序员在实现协议方法时通常会这样做，所以你也应该遵循这个约定。知道是谁发送了消息，并让委托能够访问这个对象及其类，是非常有用的。

当添加生日视图控制器调用此方法时，它会将自身作为 addBirthdayViewController 参数传递给此方法。你很快就会看到具体是如何操作的。另一个需要注意的是外部参数名 didAddBirthday。许多委托协议方法包含*did*和*will*，因为它们用于描述调用类已经完成或将要完成的操作。

现在你已经定义了协议，你需要告诉生日表视图控制器采用这个协议并使用协议中的方法。

##### 使生日表视图控制器符合协议

为了采用这个协议，生日表视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要将 AddBirthdayViewControllerDelegate 添加到类定义中，紧接在 UITableViewController 超类之后。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你执行了这个操作，红色错误提示就会出现。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快就会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，而且超类的名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采用多个协议——这些协议会在超类之后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:)方法。一个合适的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它预计你会添加这个方法。请注意，与子类化的方法不同，你不需要在 addBirthdayViewController(_:didAddBirthday:)之前使用 override 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将添加生日视图控制器传递过来的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:)方法来完成这项操作 ➋。接下来，你需要刷新表视图，以便它显示这个新的生日，方法是调用 tableView 属性的 reloadData()方法 ➌。当 reloadData()被调用时，表视图的数据源方法将会再次被调用，新添加的生日会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但标记类的不同部分是良好的编码风格，它有助于保持代码的清晰和可读性。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中，你可以使用这个菜单来快速浏览类中的方法。这个下拉菜单帮助你找到方法，并让你跳转到代码中的不同位置。要使用这个菜单，点击编辑面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 给 Add Birthday 视图控制器指定代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表格视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个可选的 AddBirthdayViewControllerDelegate 类型的代理属性来安排这件事，插入以下这一行代码，紧接着在 outlets 下方：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为直到*Add Birthday 视图控制器*被创建后，你才能设置它。你很快就会学到在哪里设置代理。

现在 Add Birthday 视图控制器有了代理，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将生日传递给代理。将 saveTapped(_:)方法改为以下代码：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码在 ➊ 处将其通过 addBirthdayViewController(_:didAddBirthday:)方法传回代理。

太好了！你已经完成了对 Add Birthday 视图控制器的修改。它现在有了一个代理，能够监听生日保存的回调。运行应用程序看看会发生什么。

嗯……没有太多变化。当你添加一个生日时，还是没有看到它出现在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存与之通信的代理，当一个生日被保存时，代理会被调用。但我们从未明确地将代理属性设置为 Birthdays 表格视图控制器。所以，现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除/*和*/来取消注释该方法。

每当生日表格视图控制器放弃其屏幕并且应用通过 storyboard segue 过渡到另一个视图控制器时，都会自动调用此方法。我们将使用此方法将生日表格视图控制器传递给添加生日视图控制器，以便设置它作为添加生日视图控制器的委托。在 prepare(for:sender:)方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码就能将添加生日视图控制器的委托设置为生日表格视图控制器。首先，你需要能够从 segue 参数中获取到 AddBirthdayViewController 对象。Xcode 已留下注释，提示你如何做到这一点。一个 UIStoryboardSegue 在正在准备的 segue 的另一端有一个名为 destination 的属性，但此应用的 destination 并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到一个导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。所以你不期望在 segue 的另一端找到添加生日视图控制器。相反，destination 是一个包含添加生日视图控制器的 UINavigationController。➊行代码获取到 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定类型，所以我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的特定子类。最后，当你获取到 AddBirthdayViewController 时，可以将委托设置为 self，也就是当前的生日表格视图控制器 ➌。

现在运行应用并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用并重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学习了如何创建一个表格视图控制器来显示生日列表。你还学习了如何在添加生日视图控制器中添加一个生日，然后如何使用委托将生日添加到生日表格视图控制器中的生日数组中，以便能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用程序并重新启动，它们也会显示出来。要保存生日，你将使用 Core Data，这在我们项目的最初阶段就已经设置好了。

![](img/Image00244.jpg)

• 创建一个 UITableViewCell

• 找出生日数组中哪个生日应该显示在单元格内

• 在单元格中创建两个标签，用来显示生日人的姓名和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。代码中的 ➊ 使用 dequeueReusableCell(withIdentifier:for:) 方法来实现这一点。然而，在你开始使用这个方法之前，你需要告诉这个方法你希望从故事板中使用哪个单元格。之前，当你在故事板中时，你给单元格设置了标识符 birthdayCellIdentifier（见图 11-4）。这个标识符将你的代码与单元格关联起来，并告诉方法它正在使用正确的单元格。当你调用这个方法时，字符串必须与在故事板中设置的字符串完全相同，否则你会遇到错误，应用程序在运行时会崩溃。

在 dequeueReusableCell(withIdentifier:for:) 方法中，你有没有注意到*可重用单元格*这几个词？表格视图中的单元格只会创建一次，然后可以反复重用。这有助于提高运行速度和流畅度，因为创建单元格是最耗时的部分。如果你的应用程序中有 200 个生日，但每次屏幕上只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以查看更多的生日时，滚动出屏幕顶部的单元格会被重用。它们会填充新的信息，然后出现在屏幕底部。UITableView 会自动完成这项工作。当表格视图加载时，tableView(_:cellForRowAt:) 会被调用，针对每个可见的行。当用户滚动以查看更多单元格时，每当行即将出现在屏幕上时，它会再次被调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中显示生日数组中的一个生日。第一个生日，位于 birthdays[0] ，应该显示在第 0 行。第二个生日，位于 birthdays[1] ，应该显示在第 1 行，以此类推，这意味着 indexPath 的行号与我们要访问的生日数组中的位置相同。代码中的 ➋ 使用 indexPath.row 从生日数组中访问正确的生日对象。一旦我们得到了正确的生日对象，我们将其赋值给一个名为 birthday 的常量，以便我们可以设置此单元格中的标签。

请注意，我们使用 let 将生日分配给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都会获取自己的生日常量，并将其分配给自己的 Birthday 对象。由于我们不打算更改任何生日常量——我们只是读取它们的属性——所以我们不需要将它们声明为变量。

现在你已经有了单元格和生日，是时候填充详细信息了。你需要为每个单元格准备两个标签，分别显示生日人的名字和出生日期。你将单元格设置为 Subtitle 样式，这样它就有了一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，所以现在你不需要自己创建标签。

这些标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。➌处的代码将 textLabel 的文本设置为由生日人的 firstName 和 lastName 组成的字符串，中间用空格隔开。➍处，你使用 dateFormatter 的 string(from:)方法在 detailTextLabel 中显示出生日期。

当你的单元格完全配置好后，tableView(_:cellForRowAt:)会在➎处返回该单元格，以便它能在表视图的该 indexPath 位置显示出来。

### 整合所有内容

现在，你可以使用添加生日视图控制器将 Birthday 实例添加到应用程序中，并且你有一个表视图来列出每个生日，显示在 Birthday 视图控制器的 Birthdays 表视图中。但是，当你尝试运行应用程序并添加一个生日时，它并没有出现。为了让你添加的每个生日都出现在表视图中，你需要让添加生日视图控制器与 Birthday 视图控制器进行通信。你可以通过使用*代理（delegation）*来实现这一点。

#### 代理模式

代理模式（Delegation）可用于当一个视图控制器需要从另一个视图控制器获取信息时。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 呈现在自己之上。A 知道 B，因为它创建并呈现了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它只是被弹出并不知道自己是从哪里来的，也不知道是怎么到那里的。那么 B 如何与 A 进行通信呢？通过代理！

![](img/Image00245.jpg)

代理模式是指某人将一项工作或任务交给其他人。*代理（delegate）*就像是一个老板，告诉一个被委派的员工该做什么。当被委派的员工完成任务时，有时他们会将信息反馈给代理老板。

Swift 中的委托与其他语言非常相似，但不是有一个老板和一个员工，而是有一个委托和一个委托对象。由于类 B 是由类 A 告诉要做什么的，因此它是委托对象。我们给类 B 一个特殊的属性，叫做委托（delegate），来告诉它它的委托是谁——这样，它就知道应该与谁通信。委托可以是任何拥有一组在*协议*中定义的方法的类。协议就像是两个类之间的协议，告诉它们委托可以要求委托对象做什么。它列出了委托可以与委托对象一起使用的方法和属性名称。

类 A 创建类 B，将自己设置为类 B 的委托，并给类 B 分配一个协议中的任务。一旦类 B 完成任务，它会向类 A 汇报。让我们看看在我们的应用中是如何实现的。

生日表视图控制器是视图控制器 A，而添加生日视图控制器是视图控制器 B。我们将创建一个名为 `AddBirthdayViewControllerDelegate` 的协议，并为该协议创建一个方法 `addBirthdayViewController(_:didAddBirthday:)`，该方法将由添加生日视图控制器用来报告结果。

看一下 图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从添加生日视图控制器传递到生日表视图控制器。*

`AddBirthdayViewControllerDelegate` 协议被定义为具有一个方法 `addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存按钮 ➌ 时，添加生日视图控制器会调用这个方法 ➍ 并将新的生日传递给它的委托——生日表视图控制器。生日表视图控制器接收这个生日，将其添加到它的生日数组中，然后重新加载它的表格视图 ➎ ，以便新生日出现在表格中。

我们将向你展示如何创建一个 `AddBirthdayViewControllerDelegate` 协议，定义一个方法 `addBirthdayViewController(_:didAddBirthday:)`，每当向应用添加生日时，添加生日视图控制器都可以调用该方法。生日表视图控制器将实现该协议方法，以便每当通过添加生日视图控制器添加一个生日时，添加生日视图控制器可以对它的委托说：“嘿！有人刚刚添加了这个生日。” 然后生日表视图控制器会接收到消息并说：“哦！我会把这个添加到我的列表中并刷新显示，以便新生日显示出来。”

现在让我们用代码来实现这一点！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类*上方*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 定义协议时，输入了关键字 `protocol`，后面跟着协议名 AddBirthdayViewControllerDelegate。这是个长名称，但 Swift 程序员通常会根据调用类的名称命名协议，并在结尾加上 Delegate 这个词。这样，你就可以通过查看协议名称来判断是哪个类在使用该协议。既然你现在是 Swift 程序员，你也应该遵循这种命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)` 是唯一的函数，它用于将 Birthday 对象传递回代理类 ➋。注意，你在这个函数中将 AddBirthdayViewController 作为一个参数传入。同样，Swift 程序员在实现协议方法时，通常会遵循这一约定，所以你也应该这样做。这样做的好处是，代理可以知道是谁发送了消息，并且能够访问该对象及其类。

当 AddBirthday 视图控制器调用这个方法时，它会将自己作为 `addBirthdayViewController` 参数传入。你很快就会看到这是如何实现的。另一个需要注意的地方是外部参数名称 `didAddBirthday`。许多代理协议方法中包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚做过的事情或即将做的事情。

现在你已经定义了协议，需要告诉 Birthdays 表格视图控制器采用这个协议并使用协议的方法。

##### 使 Birthdays Table View Controller 遵循协议

为了采用该协议，Birthdays 表格视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中将 AddBirthdayViewControllerDelegate 添加到 UITableViewController 超类之后。在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色错误提示就会出现。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心，我们很快就能修复这个问题。

这里需要特别注意的是，BirthdaysTableViewController 是从 UITableViewController 超类派生出来的。一个类只能有一个超类，而且超类名称必须写在任何协议之前。但是，虽然一个类只能有一个超类，但它可以采用任意数量的协议——这些协议会在超类之后列出，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 `addBirthdayViewController(_:didAddBirthday:)` 方法添加到 Birthdays TableViewController 中。一个合适的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动补全会建议这个完整的方法声明。这是因为它知道这个类遵循了 AddBirthdayViewController Delegate 协议，并且它期望你添加这个方法。请注意，与子类方法不同，在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法需要被覆盖。

在这个方法中，你需要做两件事。首先，你需要将通过添加生日视图控制器传入的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现 ➋ 。接下来，你需要刷新表视图，通过在 tableView 属性上调用 reloadData() 方法来显示这个新的生日 ➌ 。当调用 reloadData() 时，表视图的数据源方法会再次被调用，新添加的生日将会显示在生日列表的底部。

你可能已经注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必需的，但标记类的不同部分是良好的编码风格，有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到下拉目录菜单中，你可以在类的顶部使用该菜单。这种下拉菜单可以帮助你查找方法，并让你在代码中跳转到不同的地方。要使用此菜单，点击编辑器面板顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7: 你的类具有内置的目录，方便快速跳转到某个部分。*

##### 为添加生日视图控制器指定委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知 Birthdays 表视图控制器它已经添加了一个生日。为此，添加生日视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性来实现这一点，代码如下所示，插入在 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是一个可选项，因为直到添加生日视图控制器创建之后，你才能设置它。你将很快学到如何设置委托。

现在，添加生日视图控制器有了委托，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将生日传递给委托。将 saveTapped(_:) 方法修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊ 处的代码将它通过 addBirthdayViewController(_:didAddBirthday:) 方法传回给委托。

太好了！你已经完成了对“添加生日”视图控制器的修改。现在它有了一个代理，用于监听保存生日的回调。运行应用程序看看会发生什么。

嗯……变化不大。当你添加一个生日时，仍然看不到它显示在“生日”表视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事要做。“生日”表视图控制器是一个 AddBirthdayViewControllerDelegate，且“添加生日”视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存与其通信的代理，以便在生日被保存时进行交互。但是我们从未专门将代理属性设置为“生日”表视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除包围它的/*和*/，取消注释这个方法。

当“生日”表视图控制器放弃屏幕并且应用程序通过 storyboard segue 切换到另一个视图控制器时，这个方法会自动调用。我们将使用这个方法将“生日”表视图控制器传递给“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的代理。在 prepare(for:sender:)方法中写下以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的代理为“生日”表视图控制器只需要三行代码。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，它位于正在准备的 segue 的另一端，但这个应用程序的目标并不是 AddBirthdayViewController。

在第九章，你将“添加生日”视图控制器嵌入到导航控制器中，这样就可以拥有一个带有“取消”和“保存”按钮的导航栏。所以你不期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊这一行代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是特定类型的视图控制器，我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，所以需要将其强制类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 后，可以将委托设置为 self，也就是当前的 Birthdays 表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你会在 Birthdays 表格视图控制器中看到什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序然后再次运行它，之前添加的生日将消失。我们仍然需要将生日保存到设备中，接下来我们将在 第十二章 中实现这一功能。

### 你学到了什么

在本章中，你学会了如何创建一个表格视图控制器来显示生日列表。你还学会了如何在 Add Birthday 视图控制器中添加生日，然后如何使用委托将生日添加到 Birthdays 表格视图控制器中的 birthdays 数组，从而使其可以被显示出来。

在 第十二章 中，你将学习如何将生日保存到设备中，以便即使在退出应用程序后重新运行时，生日也能继续显示。为了保存生日，你将使用 Core Data，这是我们在项目开始时就设置好的。

• 创建一个 UITableViewCell

• 确定在 birthdays 数组中哪个生日将显示在单元格内

• 创建两个标签以显示生日人的名字和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行解析这段代码。

首先，创建 UITableViewCell。➊ 处的代码使用 `dequeueReusableCell(withIdentifier:for:)` 方法实现这一功能。在开始使用这个方法之前，你需要告诉该方法你想要在 storyboard 中使用哪个单元格。之前，当你在 storyboard 中时，你给单元格设置了标识符 `birthdayCellIdentifier`（参见 图 11-4）。这个标识符将你的代码与单元格连接起来，并告诉方法它正在使用正确的单元格。当你调用这个方法时，传递的字符串必须与在 storyboard 中设置的字符串完全相同，否则你会遇到错误，应用程序在运行时会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:)中，你注意到“*可重用单元格*”这几个字了吗？表格视图中的单元格是创建一次，然后可以反复使用的。这有助于提高效率并让操作更加流畅，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日，但每次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动查看更多生日时，滚出屏幕顶部的单元格会被重用。它们会被填充上新的信息，并重新出现在屏幕底部。UITableView 会自动完成这项工作。当表格视图加载时，tableView(_:cellForRowAt:)会为每一行调用一次。用户滚动查看更多单元格时，它会再次为每一行调用，直到该行即将出现在屏幕上。

接下来，我们需要找出应该在单元格中显示哪一个生日。我们想要在每一行中显示一个来自 birthday 数组的生日。第一个生日，即 birthdays[0]，应该显示在第 0 行。第二个生日，即 birthdays[1]，应该显示在第 1 行，依此类推，这意味着 indexPath 的行号与我们要访问的 birthday 数组中的位置相同。➋处的代码通过使用 indexPath.row 从 birthdays 数组中访问正确的 Birthday 对象。一旦我们得到了正确的 Birthday 对象，就将其分配给一个名为 birthday 的常量，以便我们可以设置这个单元格中的标签。

请注意，我们使用 let 来将生日分配给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都会获得自己的生日常量，并将其分配给自己的生日对象。由于我们不会改变任何生日常量——我们只是读取它们的属性——所以我们不需要将它们设置为变量。

现在你已经有了单元格和生日信息，是时候填写细节了。你需要为每个单元格添加两个标签，分别显示生日人的姓名和生日日期。你将单元格设置为副标题样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，因此你无需自己创建标签。

这些标签作为 UITableViewCell 的属性存在，分别被称为 textLabel 和 detailTextLabel。➌处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，两个名字之间有一个空格。在➍处，你使用 dateFormatter 的 string(from:)方法将生日日期显示在 detailTextLabel 中。

当你的单元格完全配置好之后，tableView(_:cellForRowAt:)会在➎处返回该单元格，以便它可以在表格视图的该 indexPath 位置上显示。

### 将一切组合在一起

现在你可以通过“添加生日”视图控制器向应用程序添加生日实例，并且你有一个表格视图来列出每个生日，在“生日”表格视图控制器中显示。但是当你尝试运行应用程序并添加一个生日时，它并没有显示。为了让每个添加的生日显示在表格视图中，你需要让“添加生日”视图控制器与“生日”表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托（DELEGATION）

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 展示在自己之上。A 了解 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 并不知道 A——它只是突然出现，并不知道自己从哪里来或者是如何到达的。那么 B 怎么能与 A 交流呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项工作或任务交给另一个人。*委托人*就像是一个老板，告诉被委托的员工该做什么。当被委托的员工完成任务时，有时他们会向委托的老板报告信息。

Swift 中的委托非常类似，但不同的是，我们不是有老板和员工，而是有委托人和被委托对象。由于类 B 是被类 A 告知做什么的，因此它是被委托对象。我们给类 B 一个名为委托的特殊属性，以告诉它谁是它的委托人——这样，它就知道该与谁沟通。委托可以是任何具有在*协议*中定义的一组方法的类。协议就像是两类之间的协议，告诉它们委托可以要求被委托对象做什么。它列出了委托可以与被委托对象一起使用的方法和属性名称。

类 A 创建类 B，使自己成为类 B 的委托，并给类 B 分配协议中的一项任务。一旦类 B 完成了任务，它会向类 A 报告。让我们看看这在我们的应用程序中是如何工作的。

生日表格视图控制器是视图控制器 A，而“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法：addBirthdayViewController(_:didAddBirthday:)，该方法将由“添加生日”视图控制器用来报告返回的结果。

看一下图 11-6。当用户点击“添加”按钮➊时，生日表格视图控制器会创建“添加生日”视图控制器➋，并将自己设置为“添加生日”视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新生日被添加并通过委托从“添加生日”视图控制器传递到“生日”表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为有一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，Add Birthday 视图控制器会调用这个方法 ➍ 并将新的生日传递给它的代理——Birthdays 表视图控制器。Birthdays 表视图控制器接收这个生日，将其添加到它的 birthdays 数组中，然后重新加载它的表视图 ➎，这样新的生日就会出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并使用方法 addBirthdayViewController(_:didAddBirthday:)，当添加生日到应用时，Add Birthday 视图控制器可以调用它。Birthdays 表视图控制器将实现该协议方法，以便每当使用 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器可以对其代理说：“嘿！有人刚刚添加了这个生日，”而 Birthdays 表视图控制器会收到这个消息并说：“哦！我会把它添加到我的列表中并刷新显示，这样新生日就会显示出来。”

现在让我们用代码来实现这个！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，*在* AddBirthdayViewController 类之前，添加这段代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处定义协议，通过键入关键字 protocol 后跟协议名 AddBirthdayViewControllerDelegate。这是一个较长的名称，但 Swift 程序员通常将协议命名为调用类的名称，并在末尾加上 Delegate 这个词。这样，你可以通过查看协议的名称来知道是哪个类在使用该协议。既然你现在是 Swift 程序员了，你也应该遵循这种命名惯例。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传递回代理类 ➋。注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。再说一次，Swift 程序员在实现协议方法时通常会这样做，这是基于惯例，所以你也应该遵循这种做法。知道是谁发送了消息并让代理能够访问该对象及其类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递。你很快就会看到这是怎么做的。另一个需要注意的是外部参数名称 didAddBirthday。许多代理协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚完成或即将完成的操作。

现在你已经定义了协议，你需要告诉 Birthdays 表视图控制器采用这个协议并使用协议的方法。

##### 使 Birthdays 表视图控制器符合协议

为了采用这个协议，Birthdays 表格视图控制器需要将自己设为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中紧接着 UITableViewController 父类之后添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，就会出现一个红色错误。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会解决这个问题。

在这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 的子类。一个类只能有一个父类，并且该父类的名称必须在任何协议之前写出。但是，虽然一个类只能有一个父类，但它可以采用任意多个协议——这些协议会在父类之后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个好的添加位置是在类的末尾，紧接着导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 的自动补全会建议这个完整的方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它期望你添加这个方法。请注意，与子类化方法不同，你在 addBirthdayViewController(_:didAddBirthday:) 前面不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现这一点 ➋。接下来，你需要刷新表格视图，以便它显示这个新的生日，通过在 tableView 属性上调用 reloadData() 方法 ➌。当调用 reloadData() 时，表格视图的数据源方法会重新调用，新增的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但在类中标记不同的部分是良好的编码风格，这有助于保持代码清晰易读。注释的第一部分，MARK: -，是一个特殊的关键字，Xcode 识别它用于代码注释，并将 AddBirthdayViewControllerDelegate 部分添加到可在类顶部使用的下拉目录菜单中。这个下拉菜单帮助你查找方法，并让你跳转到代码中的不同位置。要使用此菜单，请点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类内置了一个目录，可以快速跳转到某个章节。*

##### 为添加生日视图控制器指定代理

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议来告诉 Birthdays 表格视图控制器它已添加了一个生日。为此，添加生日视图控制器首先需要定义一个代理。我们通过在 outlets 下面添加以下行，将类型为 AddBirthdayViewControllerDelegate 的可选代理属性添加到 AddBirthdayViewController 类中：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在创建添加生日视图控制器之前，不能设置它。你很快就会知道在哪里设置代理。

现在，添加生日视图控制器有了一个代理，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将生日传递给代理。将 saveTapped(_:) 方法改为如下所示：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码在 ➊ 处通过 addBirthdayViewController(_:didAddBirthday:) 将其传递回代理。

太棒了！你已经完成了对添加生日视图控制器的更改。它现在有一个代理，能够监听生日已保存的调用。运行应用程序看看会发生什么。

嗯……似乎没什么变化。当你添加一个生日时，你仍然看不到它出现在 Birthdays 表格视图控制器中。这是怎么回事？

#### 通过设置代理连接这两个控制器

你还有最后一件事要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存了当生日被保存时与之通信的代理对象。但我们从未明确地将代理属性设置为 Birthdays 表格视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个被注释掉的方法，叫做 prepare(for:sender:)。通过删除 /* 和 */ 来取消注释该方法。

当 Birthdays 表视图控制器交出其屏幕并且应用程序通过 storyboard segue 切换到另一个视图控制器时，此方法会被自动调用。我们将使用此方法将 Birthdays 表视图控制器传递给 Add Birthday 视图控制器，并设置自己为 Add Birthday 视图控制器的代理。在 prepare(for:sender:) 方法中编写如下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的代理为 Birthdays 表视图控制器只需要三行代码。首先，您需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示您可以如何实现这一点。UIStoryboardSegue 在此方法中准备的 segue 的另一端有一个叫做 destination 的属性，但该应用的 destination 并不是 AddBirthdayViewController。

在第九章中，您将 Add Birthday 视图控制器嵌入到导航控制器中，以便拥有带有取消和保存按钮的导航栏。所以您不会期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，destination 是一个 UINavigationController，其中包含 Add Birthday 视图控制器。➊ 这一行代码可以获取 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 ViewController 的特定类型，因此我们需要使用 as 将其类型转换为 UINavigationController。

接下来，您可以获取 Add Birthday 视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须进行类型转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的特定子类。最后，当您获得 AddBirthdayViewController 时，可以将代理设置为 self，而此时的 self 是当前的 Birthdays 表视图控制器 ➌。

现在运行应用并添加一些生日！您在 Birthdays 表视图控制器中看到了什么？生日！生日！生日！不过，我们还没完全完成。如果您退出应用程序然后重新运行，它之前的生日将会消失。我们还需要将生日保存到设备中，这部分将在第十二章中进行。

### 您学到了什么

在本章中，您学习了如何创建一个表视图控制器来显示生日列表。您还学习了如何在 Add Birthday 视图控制器中添加一个生日，然后如何使用代理将生日添加到 Birthdays 表视图控制器中的 birthdays 数组，以便将其显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用再重新打开，它们也会显示出来。要保存这些生日，你将使用 Core Data，这是我们在项目一开始就设置好的。

• 找出在`birthdays`数组中应该显示哪个生日

• 创建两个标签，在单元格中显示生日人的姓名和出生日期

• 返回已准备好显示的单元格

让我们逐行查看这段代码。

首先，创建 UITableViewCell。➊处的代码使用了`dequeueReusableCell(withIdentifier:for:)`方法来实现这一点。不过，在你开始使用这个方法之前，你需要告诉它你希望使用哪个来自 storyboard 的单元格。之前在 storyboard 中，你给单元格设置了标识符`birthdayCellIdentifier`（见图 11-4）。这个标识符将你的代码和单元格关联起来，并告诉你的方法正在使用正确的单元格。当你调用这个方法时，传入的字符串必须和你在 storyboard 中设置的字符串完全相同，否则会出错，且应用在运行时会崩溃。

在`dequeueReusableCell(withIdentifier:for:)`方法中，你是否注意到了*Reusable Cell*这几个词？表格视图中的单元格是一次创建后可以反复使用的。这有助于提高运行效率，因为创建单元格是最耗时的部分。如果你的应用中有 200 个生日记录，但每次屏幕上只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以查看更多生日时，屏幕上方滚出的单元格会被重用。这些单元格会填充新的信息，并再次出现在屏幕底部。UITableView 会自动完成这项工作。当表格视图加载时，`tableView(_:cellForRowAt:)`方法会为每个可见行调用一次。当用户滚动以查看更多单元格时，它会在每个即将出现在屏幕上的行上再次调用。

接下来，我们需要找出应该在单元格中显示哪个生日。我们希望在每一行中显示`birthdays`数组中的一个生日。第一个生日，即`birthdays[0]`，应该显示在第 0 行。第二个生日，即`birthdays[1]`，应该显示在第 1 行，以此类推，这意味着`indexPath`的行号与我们希望访问的`birthdays`数组中的位置是一样的。➋处的代码通过使用`indexPath.row`来访问`birthdays`数组中的正确`Birthday`对象。一旦我们拿到正确的`Birthday`对象，我们将其赋值给一个名为`birthday`的常量，这样就可以在这个单元格中设置标签了。

请注意，我们使用`let`将生日赋值给常量，而不是变量。我们可以使用`let`，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都会获得自己的生日常量，并将其分配给自己的生日对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——因此我们不希望将它们设置为变量。

现在你已经有了单元格和生日，是时候填写详细信息了。你需要为每个单元格添加两个标签，用于显示生日人物的姓名和出生日期。你将单元格设置为“副标题”样式，这样它就有了一个标题标签和一个副标题标签。每个单元格已经包含这些标签，因此现在你不需要自己创建标签。

标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。在➌，代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，两者之间有一个空格。在➍，你使用 dateFormatter 的 string(from:)方法在 detailTextLabel 中显示出生日期。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 会在➎ 返回该单元格，以便它可以在表格视图的该索引路径处显示。

### 将所有内容结合起来

现在你可以使用“添加生日”视图控制器将生日实例添加到应用程序中，并且你有一个表格视图，用于列出“生日”表格视图控制器中的每个生日。但是，当你尝试运行应用程序并添加一个生日时，它并没有显示。为了让你添加的每个生日在表格视图中显示，你需要让“添加生日”视图控制器与“生日”表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以用于当一个视图控制器需要从另一个视图控制器获取信息时。例如，假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 呈现在自己之上。A 知道 B，因为它创建并呈现了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它只是突然出现，并不知道它来自哪里或是如何到达的。那么 B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将任务或工作交给他人。一个*委托人*就像一个老板，告诉一个被委托的员工该做什么。当被委托的员工完成任务时，有时会将信息反馈给委托的老板。

在 Swift 中，委托模式非常相似，但我们不是有老板和员工，而是有委托和委托对象。由于类 B 被类 A 告知要做什么，因此它是委托对象。我们给类 B 一个特殊的属性，叫做委托（delegate），告诉它谁是它的委托对象，这样它就知道应该与谁沟通。委托可以是任何具有一组在 *协议* 中定义的方法的类。协议就像是两个类之间的协议，告诉它们委托可以要求委托对象做些什么。它列出了委托可以与委托对象一起使用的方法和属性名称。

类 A 创建类 B，使自己成为类 B 的委托，并为类 B 指定一个协议中包含的任务。一旦类 B 完成任务，它会向类 A 汇报。让我们来看一下这个在我们的应用中是如何实现的。

Birthdays 表格视图控制器是视图控制器 A，Add Birthday 视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由 Add Birthday 视图控制器用来进行汇报。

请查看 图 11-6。当用户点击“添加”按钮 ➊ 时，Birthdays 表格视图控制器创建了 Add Birthday 视图控制器 ➋ 并将自己设置为 Add Birthday 视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：通过委托模式，新的生日被从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为具有一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击“保存”按钮 ➌ 时，Add Birthday 视图控制器调用此方法 ➍ 并将新添加的生日传递给它的委托，即 Birthdays 表格视图控制器。Birthdays 表格视图控制器接收该生日，将其添加到自己的生日数组中，然后重新加载表格视图 ➎，使新生日出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，其中包含一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将在每次应用中添加生日时由 Add Birthday 视图控制器调用。Birthdays 表格视图控制器将实现该协议方法，这样每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器只需告诉它的委托：“嘿！有人刚刚添加了这个生日。” 然后，Birthdays 表格视图控制器会接收到这个消息并说：“哦！我会把它添加到我的列表中并刷新我的显示，让新生日出现在视图中。”

现在，让我们在代码中实现这个功能！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处定义协议，通过输入关键字 protocol 后跟协议名 AddBirthdayViewControllerDelegate。这个名字很长，但 Swift 程序员通常会以调用类的名字命名他们的协议，并在结尾加上 Delegate。这样你就能通过查看协议的名字来判断是哪个类在使用该协议。既然你现在是 Swift 程序员，你也应该遵循这个命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传回给委托类 ➋ 。注意，你在这个函数中包含了 AddBirthdayViewController 作为参数。再次提醒，Swift 程序员在实现协议方法时遵循这种约定，因此你也应该这么做。这样做有助于了解谁发回了消息，并且让委托方能够访问该对象及其类。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传入。你很快就会看到这是如何实现的。另一个需要注意的是外部参数名 didAddBirthday。许多委托协议方法都包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚做过的事情或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays table view controller 采用这个协议并使用协议的方法。

##### 使 Birthdays Table View Controller 符合协议要求

为了采用协议，Birthdays table view controller 需要让自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中，紧接 UITableViewController 超类之后，添加 AddBirthdayViewControllerDelegate。在类的顶部，给 UITableViewController 后面加个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，就会出现一个红色的错误。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但是它还没有实现该协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会修复这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，并且该超类的名称必须写在任何协议之前。但是，尽管一个类只能有一个超类，它可以采用任意多个协议——这些协议会在超类之后列出，并且用逗号隔开。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个好的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动补全功能会建议整个方法声明。这是因为它知道该类采用了 AddBirthdayViewController Delegate 协议，并且它期待你添加这个方法。注意，与子类化的方法不同，在 `addBirthdayViewController(_:didAddBirthday:)` 前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传入的 Birthday 添加到 `birthdays` 数组中。你可以通过使用数组的 `append(_:)` 方法 ➋ 来完成这一操作。接下来，你需要刷新表视图，以便它能够显示这个新的生日，方法是调用表视图的 `reloadData()` 方法 ➌。当调用 `reloadData()` 时，表视图的数据源方法将被再次调用，新的 Birthday 将会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这并不是必须的，但这是一个良好的编码风格，可以将类的不同部分标记出来，有助于保持代码整洁和易读。注释的第一部分 `MARK: -` 是一个 Xcode 识别的特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到类顶部下拉目录菜单中。这个下拉菜单帮助你找到方法，并允许你跳转到代码中的不同位置。要使用这个菜单，请点击编辑器窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器指定代理

`BirthdaysTableViewController` 已经采用了 `AddBirthdayViewControllerDelegate` 协议。现在是时候让 Add Birthday 视图控制器使用 `AddBirthdayViewControllerDelegate` 协议，告知 Birthdays 表视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 `AddBirthdayViewController` 类的输出变量下方插入以下代码，来为其添加一个可选的 `AddBirthdayViewControllerDelegate` 类型的代理属性。

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在 Add Birthday 视图控制器创建之前，你无法设置它。稍后你将学习在哪里设置代理。

现在，Add Birthday 视图控制器已经有了代理，在 `saveTapped(_:)` 方法中，你可以使用 `addBirthdayViewController(_:didAddBirthday:)` 方法将一个 Birthday 传递给代理。将 `saveTapped(_:)` 修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊ 处的代码通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将其传回给代理。

太好了！你已经完成了对添加生日视图控制器的修改。它现在有了一个代理，能够监听生日被保存的调用。运行应用看看发生了什么。

嗯。。。没什么变化。当你添加一个生日时，你依然看不到它出现在生日表格视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事需要做。生日表格视图控制器是一个`AddBirthdayViewControllerDelegate`，而添加生日视图控制器有一个`AddBirthdayViewControllerDelegate`属性，用来保存它在生日保存时与之通信的代理。但是我们从未明确地将代理属性设置为生日表格视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个被注释掉的方法叫做`prepare(for:sender:)`。通过删除包围它的`/*`和`*/`，取消注释该方法。

这个方法会在每次生日表格视图控制器放弃屏幕并且应用通过故事板 segue 切换到另一个视图控制器时自动调用。我们将利用这个方法把生日表格视图控制器传递给添加生日视图控制器，并设置它作为添加生日视图控制器的代理。请在`prepare(for:sender:)`方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的代理为生日表格视图控制器需要三行代码。首先，你需要能够从`segue`参数中访问到`AddBirthdayViewController`对象。Xcode 在注释中提示了如何做到这一点。一个`UIStoryboardSegue`有一个`destination`属性，在这个方法中准备的 segue 的另一端就是目标视图控制器，但对于这个应用，目标不是`AddBirthdayViewController`。

在第九章中，你将添加生日视图控制器嵌入到了导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。因此，你不会期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的`UINavigationController`。➊这一行让你获取到`navigationController`。代码`segue.destination`会返回一个`UIViewController`，但是由于我们的`navigationController`是`ViewController`的一个特定类型，我们需要使用`as`将其类型转换为`UINavigationController`。

接下来，你可以获取添加生日视图控制器，它是`navigationController`的`topViewController` ➋。`topViewController`就是当前在`navigationController`中显示的视图控制器，但它的属性是`UIViewController`类型，因此必须进行类型转换为`AddBirthdayViewController`，以表明该控制器是`UIViewController`的一个特定子类。最后，当你获得`AddBirthdayViewController`时，你可以将委托设置为`self`，即当前的生日表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序并再次运行，之前添加的生日将会消失。我们仍然需要将生日信息保存到设备中，这一点我们将在第十二章中实现。

### 你学到了什么

在本章中，你学习了如何制作一个表格视图控制器来显示你的生日列表。你还学习了如何在添加生日视图控制器中添加一个生日，然后如何使用委托将生日添加到生日表格视图控制器中的生日数组中，以便它可以被显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用程序并再次运行，生日信息依然会显示。为了保存生日信息，你将使用 Core Data，这是我们在项目开始时就设置好的。

• 在单元格中创建两个标签来显示生日人的名字和出生日期

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 UITableViewCell。在➊处的代码通过使用`dequeueReusableCell(withIdentifier:for:)`方法实现这一点。不过，在你开始在单元格上使用这个方法之前，你需要告诉这个方法你想使用哪个来自故事板的单元格。之前，当你在故事板中时，你给你的单元格设置了标识符 birthdayCellIdentifier（见图 11-4）。这个标识符将你的代码与单元格链接起来，并告诉你的方法它正在使用正确的单元格。当你调用此方法时，字符串必须与你在故事板中设置的字符串完全相同，否则会出错，应用程序在运行时会崩溃。

在方法 dequeueReusableCell(withIdentifier:for:)中，您注意到了*可重用单元格*这几个词吗？表视图中的单元格只创建一次，然后可以反复使用。这有助于提高速度和流畅性，因为创建单元格是最耗时的部分。如果您的应用程序中有 200 个生日，但一次只能在屏幕上显示 10 个，那么您只需要 10 个单元格来显示您的生日。当用户滚动以显示更多生日时，屏幕顶部滚动出去的单元格将被重新使用。它们会填充新信息，并再次显示在屏幕底部。UITableView 会自动完成此工作。加载表视图时，对每一行调用 tableView(_:cellForRowAt:)以显示每个可见行。当用户滚动以查看更多单元格时，将再次为即将出现在屏幕上的每行调用它。

接下来，我们需要找出应在单元格内显示哪个生日。我们希望在每一行中从生日数组中显示一个生日。第一个生日，在 birthdays[0]处，应显示在第 0 行。第二个生日，在 birthdays[1]处，应显示在第 1 行，依此类推，这意味着 indexPath 的行与我们要访问的 birthdays 数组中的位置相同。➋处的代码通过使用 indexPath.row 从 birthdays 数组中访问正确的 Birthday 对象。一旦我们有了正确的 Birthday 对象，我们将其分配给一个名为 birthday 的常量，这样我们就可以设置该单元格中的标签。

请注意，我们使用 let 将生日分配给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的 birthday 常量。每个单元格都有自己的 birthday 常量，它被分配了自己的 Birthday 对象。由于我们不会改变任何 birthday 常量的值——我们只会读取它们的属性——我们不想把它们设为变量。

现在您有了单元格和生日，是时候填写细节了。每个单元格需要两个标签来显示生日人的姓名和出生日期。您将单元格设置为 Subtitle 样式，以便它具有一个 Title 标签和一个 Subtitle 标签。每个单元格已经包含这些标签，所以现在您不必再自己创建任何标签了。

标签作为 UITableViewCell 的属性存在，称为 textLabel 和 detailTextLabel。➌处的代码将 textLabel 的文本设置为由 firstName 和 lastName 组成的字符串，并在它们之间加上一个空格。在➍处，您使用 dateFormatter 的 string(from:)方法显示 detailTextLabel 中的出生日期。

当你的单元格完全配置好后，tableView(_:cellForRowAt:)返回➎处的单元格，以便在表视图的该 indexPath 处显示它。

### 将所有内容整合在一起

现在，你可以通过“添加生日”视图控制器将生日实例添加到应用中，并且你有一个表格视图来列出每个生日，在“生日”表格视图控制器中显示。但当你运行应用并添加一个生日时，它并没有显示出来。为了让你添加的每个生日出现在表格视图中，你需要让“添加生日”视图控制器与“生日”表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己的上方。A 知道 B 的存在，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但 B 并不知道 A，它只是突然出现，根本不知道自己是从哪里来的或者是如何到达这里的。那么，B 如何与 A 进行交流呢？通过委托！

![](img/Image00245.jpg)

委托是指有人将一项工作或任务交给另一个人。*委托人*就像是一个老板，告诉被委托的员工该做什么。当被委托的员工完成任务后，有时他们会将信息报告给委托的老板。

Swift 中的委托和上面描述的类似，但我们不是用老板和员工的比喻，而是有一个委托和一个委托对象。由于是类 B 被告知该做什么，所以它是委托对象。我们给类 B 添加一个特殊属性叫做 delegate，来告诉它谁是它的委托对象——这样，它就知道要与谁进行沟通。委托可以是任何具有协议中定义方法集合的类。协议就像是两个类之间的约定，告诉它们委托对象可以要求委托做些什么。它包含了委托可以与委托对象一起使用的方法和属性名称列表。

类 A 创建类 B，并使自己成为类 B 的委托，给类 B 指派一个在协议中定义的任务。一旦类 B 完成任务，它会将结果报告给类 A。让我们看看在我们的应用中是如何运作的。

“生日”表格视图控制器是视图控制器 A，“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法：addBirthdayViewController(_:didAddBirthday:)，该方法将由“添加生日”视图控制器用来报告结果。

看一下图 11-6。当用户点击“添加”按钮 ➊ 时，“生日”表格视图控制器创建了“添加生日”视图控制器 ➋ 并将自己设置为“添加生日”视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：通过委托，新的生日被添加并从“添加生日”视图控制器传递到“生日”表格视图控制器。*

`AddBirthdayViewControllerDelegate` 协议被定义为包含一个方法 `addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存 ➌ 时，添加生日视图控制器会调用这个方法 ➍，并将新生日传递给它的代理，即 Birthdays 表格视图控制器。Birthdays 表格视图控制器会将这个生日添加到它的生日数组中，然后重新加载它的表格视图 ➎，以便新生日能够显示在表格中。

我们将向你展示如何创建一个 `AddBirthdayViewControllerDelegate` 协议，并使用方法 `addBirthdayViewController(_:didAddBirthday:)`，该方法可以在每次在应用中添加生日时由添加生日视图控制器调用。Birthdays 表格视图控制器将实现该协议方法，这样每当使用添加生日视图控制器添加一个生日时，添加生日视图控制器只需告诉它的代理：“嘿！有人刚刚添加了这个生日”，而 Birthdays 表格视图控制器会接收到这个消息并说：“哦！我会将这个添加到我的列表中并刷新我的显示，以便新生日能够显示出来。”

现在我们开始在代码中实现吧！

##### 创建一个协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 `AddBirthdayViewController` 类的 *上方*，添加以下代码来定义 `AddBirthdayViewControllerDelegate` 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过在 ➊ 处键入关键字 `protocol` 并跟上协议名 `AddBirthdayViewControllerDelegate` 来定义协议。这个名字比较长，但 Swift 程序员通常会根据调用类的名字来命名协议，并在末尾加上 `Delegate`。这样你就可以通过查看协议的名字来知道是哪个类在使用该协议。既然你现在是 Swift 程序员，你也应该遵循这种命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)` 是唯一的函数，用于将生日对象传递回代理类 ➋。注意，你在这个函数中包含了 `AddBirthdayViewController` 作为一个参数。再次说明，Swift 程序员在实现协议方法时通常会这么做，这也是一种约定，因此你也应该遵循这种做法。了解是谁发送了回调消息，并让代理能够访问这个对象及其类是非常有用的。

当添加生日视图控制器调用此方法时，它会将自己作为 `addBirthdayViewController` 参数传递。很快你就会看到如何实现这一点。另一个需要注意的点是外部参数名 `didAddBirthday`。许多代理协议方法都包含 *did* 和 *will* 这两个词，因为它们用于描述调用类已经做了或将要做的事情。

既然你已经定义了协议，接下来你需要告诉 Birthdays 表格视图控制器采用这个协议并使用协议的方法。

##### 让 Birthdays 表格视图控制器遵循协议

为了采用这个协议，Birthdays 表格视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，紧跟 UITableViewController 父类后面，添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做了，红色错误就会出现。发生这种情况是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快会修复这个问题。

这里需要注意的是，BirthdaysTableViewController 是一个子类，它继承自 UITableViewController 父类。一个类只能有一个父类，并且这个父类的名称必须写在任何协议之前。不过，虽然一个类只能有一个父类，但它可以采用任意多个协议——这些协议将会在父类之后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 BirthdaysTableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的地方是在类的末尾，紧接着导航部分之后添加：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动完成功能会建议你整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，它期待你添加这个方法。注意，与子类方法不同，你在 addBirthdayViewController(_:didAddBirthday:) 前不会使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来做到这一点 ➋。接下来，你需要刷新表格视图，以便它显示这个新添加的生日，通过在 tableView 属性上调用 reloadData() 方法 ➌。当 reloadData() 被调用时，表格视图的数据源方法会被再次调用，新的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但良好的编码风格是将类的不同部分进行标记，并且它有助于保持代码简洁和可读。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你查找方法并跳转到代码中的不同位置。要使用此菜单，请点击编辑面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个章节。*

##### 给添加生日视图控制器设置代理

BirthdaysTableViewController 已经遵循了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知生日列表视图控制器它已经添加了一个生日。为此，添加生日视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性来安排这一点，代码插入位置在 outlets 下方：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在添加生日视图控制器创建之前你无法设置它。你将在稍后学习在哪里设置代理。

现在添加生日视图控制器有了代理，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将生日传递给代理。将 saveTapped(_:)方法修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码在➊处通过 addBirthdayViewController(_:didAddBirthday:)将其返回给代理。

太棒了！你已经完成了对添加生日视图控制器的修改。它现在有了一个代理，能够监听生日保存的事件。运行应用程序，看看会发生什么。

嗯...没有太大变化。当你添加生日时，仍然看不到它出现在生日列表视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事需要做。生日列表视图控制器是一个 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 类型的属性，用于保存它在生日保存时与之通信的代理。但我们还没有明确设置代理属性为生日列表视图控制器。所以，现在是时候在两个视图控制器之间建立通信管道了。

在 BirthdaysTableViewController 类的“导航”部分，有一个被注释掉的方法，叫做 prepare(for:sender:)。通过删除围绕它的/*和*/来取消注释该方法。

当“生日”表视图控制器退出屏幕并且应用通过故事板 segue 过渡到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将“生日”表视图控制器传递给“添加生日”视图控制器，并设置它为“添加生日”视图控制器的代理。在 prepare(for:sender:)方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需三行代码即可将“添加生日”视图控制器的代理设置为“生日”表视图控制器。首先，你需要能够通过 segue 参数访问 AddBirthdayViewController 对象。Xcode 中留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，它表示正在准备中的 segue 的目标视图控制器，但这个应用的目标视图控制器不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到一个导航控制器中，这样你就可以拥有带有“取消”和“保存”按钮的导航栏。因此，你不期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊处的代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，我们需要使用 as 进行类型转换，将其转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是在 navigationController 中显示的视图控制器，但其属性类型是 UIViewController，因此需要将其类型转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的一个特定子类。最后，当你获取到 AddBirthdayViewController 时，你可以将代理设置为 self，也就是当前的“生日”表视图控制器 ➌。

现在运行应用并添加一些生日！你在“生日”表视图控制器中看到什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用后再次运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，我们将在第十二章中完成这个操作。

### 你学到了什么

在本章中，你学习了如何创建一个表视图控制器来显示你的生日列表。你还学习了如何在“添加生日”视图控制器中添加一个生日，然后通过代理将该生日添加到“生日”表视图控制器中的生日数组中，以便显示出来。

在 第十二章 中，你将学习如何将生日保存到设备中，以便在退出应用程序并再次运行时能够显示出来。为了保存生日，你将使用我们在项目开始时就设置的 Core Data。

• 返回准备好显示在表格视图中的单元格

让我们逐行分析这段代码。

首先，创建 `UITableViewCell`。➊ 处的代码使用 `dequeueReusableCell(withIdentifier:for:)` 方法来实现这一点。不过，在你开始使用该方法之前，你需要告诉方法你想从 storyboard 中使用哪个单元格。之前，当你在 storyboard 中时，你给单元格设置了标识符 `birthdayCellIdentifier`（参见 图 11-4）。这个标识符将你的代码与单元格连接起来，并告诉你的方法它正在使用正确的单元格。调用该方法时使用的字符串必须与 storyboard 中设置的字符串完全一致，否则你会遇到错误，并且应用程序在运行时会崩溃。

在 `dequeueReusableCell(withIdentifier:for:)` 方法中，你是否注意到 *Reusable Cell* 这几个字？表格视图中的单元格是创建一次后可以重复使用的。这有助于提高效率，使一切运行得更快、更顺畅，因为创建单元格是最耗时的部分。如果你的应用程序中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，滚出屏幕顶部的单元格将被重用。它们被填充上新的信息，并再次出现在屏幕底部。`UITableView` 会自动处理这个工作。当表格视图加载时，`tableView(_:cellForRowAt:)` 会为每个可见的行调用一次。当用户滚动查看更多单元格时，它会在每一行即将出现在屏幕上时再次被调用。

接下来，我们需要找出哪个生日应该显示在单元格内。我们希望在每一行中显示 `birthdays` 数组中的一个生日。第一个生日，位于 `birthdays[0]`，应该显示在第 0 行。第二个生日，位于 `birthdays[1]`，应该显示在第 1 行，依此类推，这意味着 `indexPath` 的 `row` 与我们要访问的 `birthdays` 数组中的位置相同。在 ➋ 处的代码通过使用 `indexPath.row` 来访问 `birthdays` 数组中的正确 `Birthday` 对象。一旦我们得到了正确的 `Birthday` 对象，就将其分配给一个名为 `birthday` 的常量，以便我们设置该单元格中的标签。

请注意，我们使用的是 `let` 来将生日分配给常量，而不是变量。我们可以使用 `let`，因为每次调用 `tableView(_:cellForRowAt:)` 时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并且分配给自己的 `Birthday` 对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以不需要将它们设置为变量。

现在你有了单元格和生日，是时候填写详细信息了。你需要为每个单元格设置两个标签，分别显示生日人的姓名和出生日期。你将单元格设置为副标题样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含这些标签，所以现在你不需要自己创建标签了。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。在➌处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格分隔。在➍处，使用 dateFormatter 的 string(from:)方法将出生日期显示在 detailTextLabel 中。

当单元格完全配置好后，tableView(_:cellForRowAt:)方法会在➎处返回单元格，这样它就可以显示在表视图的对应 indexPath 位置。

### 综合起来

现在，你可以使用添加生日视图控制器将 Birthday 实例添加到应用程序中，并且你有一个表视图来列出每个生日，在 Birthdays 表视图控制器中显示。但是，当你尝试运行应用并添加一个生日时，它没有出现。为了让你添加的每个生日都出现在表视图中，你需要让添加生日视图控制器与 Birthdays 表视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以用于一个视图控制器需要从另一个视图控制器获取信息的场景。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建 B，并将 B 呈现到自己之上。A 知道 B 的存在，因为它创建并呈现了 B，所以 A 可以将信息传递给 B。但 B 并不知道 A——它只是突然出现，并不知道它来自哪里或者是如何到达那里。那么 B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项工作或任务交给别人。*委托人*就像是一个老板，告诉被委托的员工该做什么。当被委托的员工完成任务后，有时他们会将信息反馈给委托的老板。

Swift 中的委托非常相似，但与其说是老板和员工，我们不如说是委托人和委托对象。由于是类 A 告诉类 B 该做什么，所以类 B 是委托对象。我们为类 B 提供了一个特殊的属性，称为 delegate，来告诉它谁是它的委托对象——这样，类 B 就知道该与谁通信。委托对象可以是任何拥有一组已在*协议*中定义的方法的类。协议就像是两个类之间的约定，告诉它们委托对象可以要求委托对象做什么。协议中包含了委托对象可以与委托对象一起使用的方法和属性名称列表。

类 A 创建类 B，将自己设为类 B 的委托，并给类 B 一个需要在协议中完成的任务。一旦类 B 完成了任务，它会将结果反馈给类 A。让我们看看在我们的应用中是如何工作的。

生日列表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用来回传数据。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日列表视图控制器会创建添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：一个新生日通过代理从添加生日视图控制器传递到生日列表视图控制器。*

AddBirthdayViewControllerDelegate 协议定义了一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，添加生日视图控制器调用该方法 ➍ 并将新生日传递给它的代理——生日列表视图控制器。生日列表视图控制器接收到这个生日后，会将其添加到它的生日数组中，并重新加载其表视图 ➎，以便新的生日显示在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并在其中添加方法 addBirthdayViewController(_:didAddBirthday:)，以便每当向应用中添加一个生日时，添加生日视图控制器都可以调用该方法。生日列表视图控制器将实现该协议方法，这样每当通过添加生日视图控制器添加一个新生日时，添加生日视图控制器只需对其代理说：“嘿！有人刚刚添加了这个生日，”而生日列表视图控制器会接收到这个消息并回复：“哦！我会把它添加到我的列表中并刷新我的显示，以便新的生日能显示出来。”

现在让我们用代码来实现吧！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，*在* AddBirthdayViewController 类上方，添加定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你可以在➊定义协议，方法是输入关键字 protocol，然后是协议名 AddBirthdayViewControllerDelegate。这个名字有点长，但 Swift 程序员通常会根据调用类的名称来命名协议，并在末尾加上 Delegate 这个词。这样，你就能通过协议的名称轻松看出哪个类在使用这个协议。既然你现在是 Swift 程序员，你应该使用相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传回代理类 ➋。注意你在这个函数中包含了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员在实现协议方法时通常这样做，所以你也应该坚持这么做。这对于知道是谁发送了消息并让代理能够访问该对象及其类非常有用。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递进来。你很快就会看到这是如何实现的。另一个需要注意的事情是外部参数名称 didAddBirthday。许多代理协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类已经做了或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays table view controller 采用这个协议并使用协议中的方法。

##### 使 Birthdays Table View Controller 符合协议

为了采用该协议，Birthdays table view controller 需要使自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中紧跟 UITableViewController 超类之后添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，一个红色的错误就会出现。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快就会修复这个问题。

需要注意的是，BirthdaysTableViewController 是从 UITableViewController 超类继承而来的。一个类只能有一个超类，并且该超类的名称必须写在任何协议之前。但是，尽管一个类只能有一个超类，它可以采用尽可能多的协议——这些协议会在超类后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:) 方法添加到 Birthdays TableViewController。一个好的添加位置是在类的末尾，紧跟在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期待你添加这个方法。请注意，与子类方法不同，你在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法可以被覆盖。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的生日添加到 birthdays 数组中。你可以使用数组的 append(_:) 方法来实现 ➋。接下来，你需要刷新表视图，以便显示这个新添加的生日，方法是调用 tableView 属性的 reloadData() 方法 ➌。当调用 reloadData() 时，表视图的数据源方法会重新调用，新增的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但标记类的不同部分是良好的编码风格，有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键词，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单可以帮助你查找方法，并允许你跳转到代码中的不同位置。要使用这个菜单，点击编辑窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个章节。*

##### 为添加生日视图控制器设置委托

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告知 Birthdays 表视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中，在 outlets 下面插入以下代码，来添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为你无法在 Add Birthday 视图控制器创建之前设置它。稍后你会学习在哪里设置委托。

现在，Add Birthday 视图控制器已经有了一个委托，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将生日传递给委托。将 saveTapped(_:) 方法更改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，代码中的 ➊ 会通过 addBirthdayViewController(_:didAddBirthday:) 将其传回给委托。

太棒了！你已经完成了对 Add Birthday 视图控制器的修改。它现在有一个委托，可以监听保存生日的调用。运行应用程序看看会发生什么。

嗯。。。变化不大。当你添加一个生日时，仍然没有看到它显示在 Birthdays 表视图控制器中。这是怎么回事？

#### 通过设置委托连接这两个控制器

还有一件事你必须做。生日表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存当生日被保存时与之通信的代理。但我们从未明确设置该代理属性为生日表格视图控制器。所以，现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法 prepare(for:sender:)。通过删除/*和*/来取消注释该方法。

当生日表格视图控制器放弃其屏幕并且应用程序通过 Storyboard segue 过渡到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将生日表格视图控制器传递给 Add Birthday 视图控制器，设置它自己作为 Add Birthday 视图控制器的代理。在 prepare(for:sender:)方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器代理为生日表格视图控制器只需要三行代码。首先，你需要能够通过 segue 参数访问 AddBirthdayViewController 对象。Xcode 已留下一个注释，提示你如何实现这一点。一个 UIStoryboardSegue 有一个叫做 destination 的属性，它是这个方法中正在准备的 segue 的另一端，但这个应用程序的 destination 并不是 AddBirthdayViewController。

在第九章，你将 Add Birthday 视图控制器嵌入到一个导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。所以，你不期待在 segue 的另一端找到 Add Birthday 视图控制器。相反，destination 是一个包含 Add Birthday 视图控制器的 UINavigationController。➊行代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，我们需要通过 as 将其强制转换为 UINavigationController。

接下来，你可以获得 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其强制转换为 AddBirthdayViewController，以指示该控制器是 UIViewController 的特定子类。最后，当你获得 AddBirthdayViewController 后，你可以将代理设置为 self，self 当前是生日表格视图控制器 ➌。

现在运行应用并添加一些生日！你在“生日”表格视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用并重新运行，之前添加的生日将会消失。我们仍然需要将生日保存到设备中，接下来我们将在第十二章中进行操作。

### 你学到了什么

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，然后如何使用委托将该生日添加到“生日”表格视图控制器中的生日数组，以便它能被显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用并重新启动，它们依然会显示。为了保存生日，你将使用 Core Data，而这正是我们在项目一开始时设置的。

让我们逐行分析这段代码。

首先，创建 UITableViewCell。➊处的代码通过`dequeueReusableCell(withIdentifier:for:)`方法来实现这一点。然而，在你开始在单元格上使用此方法之前，你需要告诉方法你希望使用哪个来自 Storyboard 的单元格。之前，在 Storyboard 中，你给你的单元格设置了标识符`birthdayCellIdentifier`（见图 11-4）。这个标识符将你的代码和单元格联系起来，并告诉你的方法它正在使用正确的单元格。调用此方法时使用的字符串必须与 Storyboard 中设置的字符串完全一致，否则你会遇到错误，应用会崩溃。

在方法`dequeueReusableCell(withIdentifier:for:)`中，你有没有注意到“*Reusable Cell*”这个词？表格视图中的单元格只会创建一次，然后可以被反复重用。这有助于提高应用的运行速度和流畅度，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动查看更多生日时，屏幕上方滚出的单元格会被重用。这些单元格会被填充上新的信息并出现在屏幕底部。UITableView 会自动完成这些工作。当表格视图加载时，`tableView(_:cellForRowAt:)`会被调用，针对每一行可见的单元格进行设置。当用户滚动以查看更多单元格时，它会在每一行即将显示时再次被调用。

接下来，我们需要找出应该在单元格内显示的生日。我们希望在每一行中显示一个来自 birthdays 数组的生日。第一个生日，在 birthdays[0]中，应该显示在第 0 行；第二个生日，在 birthdays[1]中，应该显示在第 1 行，以此类推，这意味着 indexPath 的行数与我们希望访问的 birthdays 数组中的位置相同。➋处的代码通过使用 indexPath.row 从 birthdays 数组中访问正确的 Birthday 对象。一旦我们拿到正确的 Birthday 对象，我们将其分配给一个名为 birthday 的常量，以便设置这个单元格中的标签。

请注意，我们使用 let 将生日赋值给常量，而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:)时，都会创建一个新的生日常量。每个单元格都会得到自己的生日常量，并分配到自己的 Birthday 对象。由于我们不会改变任何生日常量—我们只是读取它们的属性—因此不希望将它们定义为变量。

现在你已经有了单元格和生日，是时候填充详细信息了。你需要为每个单元格设置两个标签来显示生日人物的名字和出生日期。你将单元格设置为副标题样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，所以你不需要自己创建标签。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌处的代码将 textLabel 的文本设置为由 birthday 的 firstName 和 lastName 构成的字符串，两个名字之间有一个空格。➍处，你使用 dateFormatter 的 string(from:)方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView(_:cellForRowAt:)会返回➎处的单元格，这样它就可以在表格视图中的 indexPath 位置显示出来。

### 将所有内容结合起来

现在，你可以通过使用“添加生日”视图控制器将 Birthday 实例添加到应用中，并且可以通过“生日”表格视图控制器列出每个生日。但当你运行应用并尝试添加一个生日时，它没有显示出来。为了让你添加的每个生日都出现在表格视图中，你需要让“添加生日”视图控制器与“生日”表格视图控制器进行通信。你可以通过使用*委托（delegation）*来实现这一点。

#### 委托（DELEGATION）

委托（Delegation）可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 呈现到自己之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 并不知道 A—它只是突然出现的，根本不知道它是从哪里来的，也不知道它是如何到达这里的。那么 B 怎么和 A 进行沟通呢？通过委托！

![](img/Image00245.jpg)

委托就是将一个工作或任务交给别人做。*代理*就像是一个老板，告诉委托员工该做什么。当委托员工完成任务时，有时他们会将信息报告给代理老板。

Swift 中的委托与此相似，但我们不是有一个老板和一个员工，而是有一个代理和一个委托对象。由于是类 A 告诉类 B 做什么，类 B 是委托对象。我们给类 B 一个特殊的属性，称为 delegate，用来告诉它谁是它的代理——这样，它就知道与谁进行通信。代理可以是任何拥有协议中定义的一组方法的类。协议就像是两个类之间的约定，告诉它们代理可以要求委托对象做什么。它列出了代理可以使用的委托对象的方法和属性名称。

类 A 创建类 B，将自己设置为类 B 的代理，并为类 B 分配一个协议中规定的任务。一旦类 B 完成任务，它会向类 A 报告。让我们看看在我们的应用中这如何实现。

Birthdays 表格视图控制器是视图控制器 A，而“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议定义一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将被“添加生日”视图控制器用于报告回传信息。

看一下图 11-6。当用户点击“添加”按钮➊时，Birthdays 表格视图控制器创建“添加生日”视图控制器 ➋并将自己设置为“添加生日”视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从“添加生日”视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为具有一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击“保存”按钮➌时，“添加生日”视图控制器会调用这个方法 ➍并将新的生日传递给它的代理，即 Birthdays 表格视图控制器。Birthdays 表格视图控制器接收这个生日，将其添加到自己的生日数组中，然后重新加载表格视图 ➎，这样新添加的生日就会显示在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法可以被“添加生日”视图控制器调用，每当有生日被添加到应用时，Birthdays 表格视图控制器将实现该协议方法，这样，每当生日通过“添加生日”视图控制器被添加时，“添加生日”视图控制器只需告诉它的代理：“嘿！有人刚刚添加了这个生日。”，然后 Birthdays 表格视图控制器会收到这个信息并说：“哦！我会把它添加到我的列表中并刷新显示，这样新的生日就能显示出来。”

现在，让我们用代码来实现这个！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，*在* AddBirthdayViewController 类上方，添加定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

在 ➊ 处，你通过输入关键字 protocol 来定义协议，后面跟上协议名称 AddBirthdayViewControllerDelegate。这个名字虽然很长，但 Swift 程序员通常会根据调用类的名称命名协议，并在后面加上 Delegate。这样你就能通过协议的名称看出是哪个类在使用该协议。既然你现在是 Swift 程序员了，应该也遵循这种命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传递回委托类 ➋ 。注意，在这个函数中你包含了 AddBirthdayViewController 作为参数。再次强调，Swift 程序员在实现协议方法时通常会这么做，因此你也应该遵循这一做法。这样做有助于知道是谁发回了消息，并让委托类能够访问该对象及其类。

当 Add Birthday 视图控制器调用此方法时，它会将自身作为 addBirthdayViewController 参数传入。你很快就会看到具体怎么做。另一个需要注意的是外部参数名称 didAddBirthday。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚做完或即将做的事情。

现在你已经定义了协议，接下来需要告诉 Birthdays 表视图控制器采用这个协议并使用协议中的方法。

##### 使 Birthdays 表视图控制器符合协议

要采用这个协议，Birthdays 表视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，您需要在类定义中紧跟 UITableViewController 超类后添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色的错误提示就会出现。这是因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了实现协议，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心，我们很快就会解决这个问题。

需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，且超类名必须写在所有协议之前。但虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议都会列在超类之后，并用逗号分隔。

现在，为了遵守 `AddBirthdayViewControllerDelegate` 协议并修复错误，我们需要将 `addBirthdayViewController(_:didAddBirthday:)` 方法添加到 `BirthdaysTableViewController`。一个合适的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成会建议整个方法声明。这是因为它知道这个类采用了 `AddBirthdayViewControllerDelegate` 协议，并且它预计你会添加这个方法。请注意，不同于子类方法，你不需要在 `addBirthdayViewController(_:didAddBirthday:)` 前面加上 `override` 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 `AddBirthdayViewController` 传递过来的生日添加到 `birthdays` 数组中。你可以通过使用数组的 `append(_:)` 方法来完成这个操作 ➋ 。接下来，你需要刷新表格视图，以便它显示这个新添加的生日，方法是调用 `tableView` 属性的 `reloadData()` 方法 ➌ 。当调用 `reloadData()` 时，表格视图的数据源方法会被重新调用，新的生日会显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：`// MARK: - AddBirthdayViewControllerDelegate` ➊ 。这不是必需的，但标记类的不同部分是良好的编码风格，它有助于保持代码的整洁和可读性。注释的第一部分 `MARK: -` 是 Xcode 识别的特殊关键字，用于代码注释，它会将 `AddBirthdayViewControllerDelegate` 部分添加到一个下拉目录中，你可以在类的顶部使用它。这个下拉菜单帮助你查找方法并跳转到代码中的不同位置。要使用这个菜单，请点击编辑器窗格顶部的 `BirthdaysTableViewController`，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类内置了一个目录，可以快速跳转到某个章节。*

##### 为 Add Birthday 视图控制器设置委托

`BirthdaysTableViewController` 已经采用了 `AddBirthdayViewControllerDelegate` 协议。现在是时候让 `AddBirthdayViewController` 使用 `AddBirthdayViewControllerDelegate` 协议来通知 `Birthdays` 表格视图控制器何时添加了一个生日。为此，`AddBirthdayViewController` 首先需要定义一个委托。我们通过在 outlets 下面插入以下代码行，将一个类型为 `AddBirthdayViewControllerDelegate` 的可选委托属性添加到 `AddBirthdayViewController` 类中：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在 `AddBirthdayViewController` 被创建之前，你无法设置它。稍后你将学习如何设置这个委托。

现在，Add Birthday 视图控制器已经有了代理，在 `saveTapped(_:)` 方法中，你可以通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将一个 Birthday 传递给代理。将 `saveTapped(_:)` 修改为如下代码：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建了生日对象之后，➊ 这一行代码通过 `addBirthdayViewController(_:didAddBirthday:)` 将它传递回代理。

太棒了！你完成了对 Add Birthday 视图控制器的所有修改。它现在有了一个代理，能够监听到生日被保存的调用。运行应用查看效果吧。

嗯……似乎没有太大变化。当你添加一个生日时，你仍然看不到它出现在 Birthdays 表视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事需要做。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 类型的属性，用来保存与其通信的代理对象，当一个 Birthday 被保存时。可是我们从未明确地将代理属性设置为 Birthdays 表视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法叫做 `prepare(for:sender:)`。删除它前后的 `/*` 和 `*/` 注释符号，取消注释这个方法。

当 Birthdays 表视图控制器放弃屏幕并且应用通过 storyboard segue 转场到另一个视图控制器时，这个方法会被自动调用。我们将使用这个方法将 Birthdays 表视图控制器传递到 Add Birthday 视图控制器，并设置它自己为 Add Birthday 视图控制器的代理。在 `prepare(for:sender:)` 方法中编写以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的代理为 Birthdays 表视图控制器需要三行代码。首先，你需要能够通过 segue 参数访问 AddBirthdayViewController 对象。Xcode 已经留下了一条注释，提示你可以如何做。一个 UIStoryboardSegue 在这个方法中被准备时，segue 的另一端有一个叫做 destination 的属性，但这个应用的目标并不是 AddBirthdayViewController。

在 第九章 中，你将 Add Birthday 视图控制器嵌入到一个导航控制器中，这样你就可以有一个带有取消和保存按钮的导航栏。所以你不会期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个 UINavigationController，它包含了 Add Birthday 视图控制器。在 ➊ 这一行代码中，你获取到了 navigationController。代码 `segue.destination` 会返回一个 UIViewController，但由于我们的 navigationController 是一种特定类型的视图控制器，所以我们需要使用 `as` 进行类型转换，转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须强制转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的特定子类。最后，当你得到一个 AddBirthdayViewController 时，你可以将代理设置为 self，而当前的 self 是 Birthday 表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在 Birthday 表格视图控制器中看到什么？生日！生日！生日！不过，我们还没完全做完。如果你退出应用程序并重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备上，这将在第十二章中完成。

### 你学到的内容

在本章中，你学习了如何制作一个表格视图控制器来显示你的生日列表。你还学会了如何在 Add Birthday 视图控制器中添加一个生日，然后如何使用代理将生日添加到 Birthday 表格视图控制器中的生日数组中，以便它能够显示出来。

在第十二章中，你将学习如何将生日保存到设备上，这样即使你退出应用程序后再运行，它们也会显示出来。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

首先，创建 UITableViewCell。➊中的代码通过使用方法`dequeueReusableCell(withIdentifier:for:)`来完成这一步。不过，在你开始在单元格上使用这个方法之前，你需要告诉这个方法你想使用哪个单元格来自 Storyboard。之前，在 Storyboard 中，你给你的单元格设置了标识符 birthdayCellIdentifier（见图 11-4）。这个标识符将你的代码与单元格关联起来，并告诉你的方法正在使用正确的单元格。当你调用这个方法时，传入的字符串必须与在 Storyboard 中设置的字符串完全相同，否则会出现错误，应用程序在运行时会崩溃。

在 dequeueReusableCell(withIdentifier:for:) 方法中，你有没有注意到 *可重用单元格* 这几个字？table view 中的单元格只会创建一次，然后可以被重复使用。这有助于提高效率，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多的生日时，滚动出屏幕顶部的单元格会被重用。它们会被填充上新信息，并再次出现在屏幕底部。UITableView 会自动完成这项工作。当表格视图加载时，tableView(_:cellForRowAt:) 会为每个可见的行调用一次。当用户滚动查看更多单元格时，每当行即将出现在屏幕上时，它会再次被调用。

接下来，我们需要找出哪个生日应该显示在单元格中。我们想要在每一行显示 birthdays 数组中的一个生日。第一个生日，位于 birthdays[0]，应该显示在第 0 行。第二个生日，位于 birthdays[1]，应该显示在第 1 行，以此类推，这意味着 indexPath 的行数与我们想要访问的 birthdays 数组中的位置相同。➋ 处的代码通过使用 indexPath.row 来访问 birthdays 数组中的正确 Birthday 对象。一旦我们得到了正确的 Birthday 对象，就将它赋值给一个名为 birthday 的常量，这样我们就可以在这个单元格中设置标签了。

请注意，我们使用 let 来将生日赋值给常量而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的 birthday 常量。每个单元格都有自己独立的 birthday 常量，并将其自己的 Birthday 对象赋值给它。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以我们不需要将它们定义为变量。

现在你已经有了单元格和生日，是时候填充详细信息了。每个单元格需要两个标签来显示生日人的姓名和出生日期。你将单元格设置为 Subtitle 样式，这样它就有了 Title 标签和 Subtitle 标签。每个单元格已经包含这些标签，因此现在你不需要自己创建标签了。

这些标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为由生日人的 firstName 和 lastName 组成的字符串，中间用空格隔开。➍ 处，你使用 dateFormatter 的 string(from:) 方法在 detailTextLabel 中显示出生日期。

当你的单元格完全配置好后，tableView(_:cellForRowAt:) 会返回位于 ➎ 的单元格，以便它可以在该 table view 的 indexPath 处显示。

### 整合所有内容

现在你可以使用“添加生日”视图控制器将生日实例添加到应用程序中，并且你有一个表格视图可以列出每个生日，在“生日”表格视图控制器中显示。但是当你尝试运行应用程序并添加一个生日时，它并没有显示出来。为了让你添加的每个生日都出现在表格视图中，你需要让“添加生日”视图控制器与“生日”表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建 B，并将 B 展示在自己之上。A 知道 B，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但是 B 并不知道 A——它只是突然出现，并不知道自己从哪里来或怎么到那里的。那么，B 如何与 A 进行沟通呢？通过委托！

![](img/Image00245.jpg)

委托是一种将工作或任务委派给他人的方式。*委托*就像一个老板，告诉委托员工应该做什么。当委托员工完成任务后，他们有时会将信息反馈给委托的老板。

在 Swift 中，委托的概念与其他语言类似，但我们不是有老板和员工，而是有委托对象和委托对象。由于类 B 是被类 A 告知做什么的，因此它是委托对象。我们给类 B 一个特殊的属性，称为委托（delegate），告诉它谁是它的委托对象，这样它就知道与谁进行通信。委托对象可以是任何类，它具有在*协议*中定义的一组方法。协议就像是两类之间的协议，告诉它们委托对象可以要求委托对象做什么。协议有一系列方法和属性名称，委托对象可以使用这些方法和属性与委托对象进行交互。

类 A 创建类 B，并将自己设置为类 B 的委托，给类 B 分配一个在协议中定义的任务。一旦类 B 完成任务，它会向类 A 报告。让我们看看这个在应用程序中的工作方式。

“生日”表格视图控制器是视图控制器 A，而“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将由“添加生日”视图控制器用来报告结果。

看一下图 11-6。当用户点击添加按钮➊时，生日表格视图控制器创建了“添加生日”视图控制器➋并将自己设置为“添加生日”视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从“添加生日”视图控制器传递到“生日”表格视图控制器。*

`AddBirthdayViewControllerDelegate` 协议被定义为包含一个方法 `addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存按钮 ➌ 时，添加生日视图控制器会调用这个方法 ➍ 并将新的生日传递给它的代理，即生日表视图控制器。生日表视图控制器会接收这个生日，将其添加到自己的生日数组中，然后重新加载表视图 ➎，以便新生日出现在表格中。

我们将向你展示如何创建一个 `AddBirthdayViewControllerDelegate` 协议，其中包含 `addBirthdayViewController(_:didAddBirthday:)` 方法，每当一个生日被添加到应用中时，添加生日视图控制器就可以调用这个方法。生日表视图控制器将实现该协议方法，这样每当通过添加生日视图控制器添加一个生日时，添加生日视图控制器可以直接告诉其代理，“嘿！有人刚刚添加了这个生日”，生日表视图控制器会接收到这个消息并回应，“哦！我会把它加入到我的列表中，并刷新我的显示以便新生日能够显示出来。”

现在，让我们用代码实现这一切吧！

##### 创建一个协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方*，添加以下代码来定义 `AddBirthdayViewControllerDelegate` 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处定义协议，方法是输入关键字 `protocol`，后跟协议名 `AddBirthdayViewControllerDelegate`。这个名字很长，但 Swift 程序员通常会根据调用类的名称来命名协议，并在末尾加上 `Delegate`。这样，你可以通过协议的名称判断是哪个类在使用它。既然你现在是 Swift 程序员，就应该遵循这样的命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)` 是唯一的函数，它用于将 Birthday 对象返回给代理类 ➋。请注意，你在这个函数中包括了 `AddBirthdayViewController` 作为参数。再次强调，Swift 程序员在实现协议方法时遵循这种做法，这是约定俗成的做法，所以你也应该坚持这样做。这样做很有用，因为可以知道是谁发回了消息，并且代理可以访问该对象及其类。

当**添加生日**视图控制器调用此方法时，它会将自身作为 `addBirthdayViewController` 参数传递。很快你就会看到这是如何实现的。需要注意的另一个点是外部参数名称 `didAddBirthday`。许多代理协议方法中包含了*did*和*will*这两个词，因为它们用来描述调用类刚刚做完或将要做的事情。

现在你已经定义了协议，接下来需要告诉生日表视图控制器让它采用这个协议并使用协议中的方法。

##### 让生日表视图控制器符合协议

为了采用这个协议，`BirthdaysTableViewController` 需要使自己成为 `AddBirthdayViewControllerDelegate`。为了实现这一点，你需要在类定义中，紧跟在 `UITableViewController` 父类之后，添加 `AddBirthdayViewControllerDelegate`。在类的顶部，在 `UITableViewController` 后面添加一个逗号，然后输入 `AddBirthdayViewControllerDelegate`：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色的错误就会出现。这是因为 `BirthdaysTableViewController` 声明它是一个 `AddBirthdayViewControllerDelegate`，但它还没有实现这个协议！为了实现这一点，它需要实现 `AddBirthdayViewControllerDelegate` 协议的定义。别担心——我们很快就会修复这个问题。

在这里需要注意的是，`BirthdaysTableViewController` 是 `UITableViewController` 的子类。一个类只能有一个父类，并且父类的名称必须写在任何协议之前。但尽管一个类只能有一个父类，它可以采用任意数量的协议——这些协议将会列在父类之后，并用逗号隔开。

现在，为了遵循 `AddBirthdayViewControllerDelegate` 协议并修复错误，我们需要在 `BirthdaysTableViewController` 中添加 `addBirthdayViewController(_:didAddBirthday:)` 方法。一个好的位置是将其添加在类的末尾，就在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 自动完成功能会建议你整个方法声明。这是因为它知道这个类采用了 `AddBirthdayViewControllerDelegate` 协议，并且它期待你添加这个方法。请注意，不同于子类方法，你在 `addBirthdayViewController(_:didAddBirthday:)` 方法前不需要使用 `override` 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将由添加生日视图控制器传递过来的生日添加到 `birthdays` 数组中。你可以通过使用数组的 `append(_:)` 方法来完成这个操作 ➋。接下来，你需要刷新表格视图，以便它显示这个新的生日，可以通过在 `tableView` 属性上调用 `reloadData()` 方法来实现 ➌。当调用 `reloadData()` 时，表格视图的数据源方法将再次被调用，新的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但它是良好的编码风格，可以帮助你标出类的不同部分，并保持代码简洁易读。注释的第一部分，MARK: -，是一个 Xcode 识别的特殊关键词，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录中，方便你查看。这个下拉菜单帮助你查找方法并跳转到代码的不同位置。要使用这个菜单，只需点击编辑面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类内置了一个目录，方便快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器指定代理

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知生日表视图控制器它已添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个可选的 AddBirthdayViewControllerDelegate 类型的代理属性来安排此事，将以下代码插入到 outlets 下方：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在*Add Birthday*视图控制器创建之前，无法设置它。你很快会学到在哪里设置代理。

现在 Add Birthday 视图控制器有了代理，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将生日传递给代理。将 saveTapped(_:)方法改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊的代码通过 addBirthdayViewController(_:didAddBirthday:)方法将其传递回代理。

很棒！你已经完成了对 Add Birthday 视图控制器的修改。它现在有了一个代理，可以监听生日保存的通知。运行应用程序看看会发生什么。

嗯……变化不大。即使你添加了一个生日，你仍然看不见它出现在生日表视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

现在你需要做最后一件事。生日表视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存了当生日保存时与之通信的代理。但是我们从未专门设置代理属性为生日表视图控制器。所以现在是时候将我们两个视图控制器之间的通信管道连接起来了。

在`BirthdaysTableViewController`类的导航部分，有一个被注释掉的方法`prepare(for:sender:)`。通过删除/*和*/来取消注释这个方法。

每当“生日”表格视图控制器放弃其屏幕并且应用程序通过故事板转场到另一个视图控制器时，这个方法会自动调用。我们将使用这个方法将“生日”表格视图控制器传递到“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的代理。在`prepare(for:sender:)`方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的代理为“生日”表格视图控制器只需要三行代码。首先，你需要能够通过`segue`参数访问到`AddBirthdayViewController`对象。Xcode 在注释中留下了一个提示，告诉你如何做到这一点。一个`UIStoryboardSegue`有一个`destination`属性，表示在此方法中正在准备的转场的目标，但是对于这个应用程序来说，目标并不是`AddBirthdayViewController`。

在第九章中，你将“添加生日”视图控制器嵌入到了一个导航控制器中，这样你就可以拥有一个带有“取消”和“保存”按钮的导航栏。因此，你不期望在转场的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的`UINavigationController`。第➊行代码获取了`navigationController`。`segue.destination`将返回一个`UIViewController`，但是由于我们的`navigationController`是`ViewController`的一个特定类型，因此我们需要通过`as`将其类型转换为`UINavigationController`。

接下来，你可以获取“添加生日”视图控制器，它是`navigationController`的`topViewController` ➋ 。`topViewController`就是当前在`navigationController`中显示的视图控制器，但它的属性是`UIViewController`类型，因此需要将其类型转换为`AddBirthdayViewController`，以表示这个控制器是`UIViewController`的一个特定子类。最后，当你获得`AddBirthdayViewController`时，你可以将代理设置为`self`，也就是当前的“生日”表格视图控制器 ➌ 。

现在运行应用程序并添加一些生日！你在“生日”表格视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用程序再重新运行，它之前添加的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，然后如何使用代理将生日添加到“生日”表格视图控制器中的生日数组，以便它能够显示出来。

在 第十二章 中，你将学习如何将生日保存到设备中，这样即使你退出应用程序并再次运行，它们仍然会显示。为了保存生日信息，你将使用 Core Data，我们在项目开始时已经设置好了。

在方法 `dequeueReusableCell(withIdentifier:for:)` 中，你注意到“*可重用单元格*”这个词了吗？表视图中的单元格只创建一次，然后可以重复使用。这有助于提高运行速度和流畅度，因为创建单元格是最耗时的操作。如果你的应用中有 200 个生日，但一次只能在屏幕上显示 10 个，那么你只需要 10 个单元格来显示这些生日。当你向下滚动以显示更多生日时，滚动出屏幕顶部的单元格将被重用。它们会被填充上新的信息，并再次出现在屏幕底部。`UITableView` 会自动执行这些工作。当表视图加载时，会为每个可见的行调用 `tableView(_:cellForRowAt:)`。当用户滚动查看更多单元格时，它会在每行即将出现在屏幕上时再次被调用。

接下来，我们需要找出哪个生日应该显示在单元格内。我们希望在每一行中显示 `birthdays` 数组中的一个生日。第一个生日，在 `birthdays[0]`，应该显示在第 0 行。第二个生日，在 `birthdays[1]`，应该显示在第 1 行，依此类推，这意味着 `indexPath` 的 `row` 与我们希望访问的 `birthdays` 数组中的位置相同。在 ➋ 处的代码通过使用 `indexPath.row` 从 `birthdays` 数组中访问正确的 `Birthday` 对象。获得正确的 `Birthday` 对象后，我们将其赋值给一个名为 `birthday` 的常量，以便我们可以设置这个单元格中的标签。

请注意，我们使用 `let` 将生日赋值给常量，而不是变量。我们可以使用 `let`，因为每次调用 `tableView(_:cellForRowAt:)` 时，都会创建一个新的生日常量。每个单元格都有自己的生日常量，并且赋予它自己的生日对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——所以不需要将它们设置为变量。

现在你有了单元格和生日信息，是时候填充详细信息了。每个单元格需要两个标签来显示生日人的姓名和出生日期。你将单元格设置为 Subtitle 样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含这些标签，所以现在你不需要自己创建标签了。

这些标签作为 `UITableViewCell` 的属性存在，分别叫做 `textLabel` 和 `detailTextLabel`。在 ➌ 处的代码将 `textLabel` 的文本设置为由生日人的名字和姓氏组成的字符串，中间有一个空格。在 ➍ 处，你使用 `dateFormatter` 的 `string(from:)` 方法将出生日期显示在 `detailTextLabel` 中。

当你的单元格完全配置好时，tableView(_:cellForRowAt:) 在 ➎ 位置返回单元格，以便它可以在该索引路径位置显示在表格视图中。

### 综合应用

现在，你可以通过“添加生日”视图控制器将生日实例添加到应用中，并且你有一个表格视图来列出“生日”表格视图控制器中的每个生日。但是，当你尝试运行应用并添加一个生日时，它并没有显示出来。为了使你添加的每个生日出现在表格视图中，你需要让“添加生日”视图控制器与“生日”表格视图控制器进行通信。你可以通过使用 *委托* 来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 显示在自己之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它只是突然出现，并不知道自己来自哪里或如何到达那里。那么 B 怎么能与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一个任务或工作交给另一个人。*委托*就像一个老板，告诉委托员工该做什么。当委托员工完成任务时，有时他们会将信息反馈给委托的老板。

在 Swift 中，委托非常相似，但我们不是有老板和员工，而是有委托和委托对象。由于 B 类是被 A 类告知要做什么的对象，所以它是委托对象。我们给 B 类一个特殊的属性叫做 delegate，用来告诉它谁是它的委托——这样，它就知道该与谁进行沟通。委托可以是任何一个拥有在 *协议* 中定义的一组方法的类。协议就像是两个类之间的约定，告诉它们委托可以要求委托对象做什么。协议包含了委托可以在委托对象上使用的方法和属性名称。

A 类创建 B 类，使自己成为 B 类的委托，并给 B 类分配一个协议中定义的任务。一旦 B 类完成任务，它会向 A 类报告。我们来看看这个在我们的应用中是如何工作的。

“生日”表格视图控制器是视图控制器 A，“添加生日”视图控制器是视图控制器 B。我们将创建一个协议叫做 AddBirthdayViewControllerDelegate，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由“添加生日”视图控制器用来报告结果。

看一下 图 11-6。当用户点击添加按钮 ➊ 时，“生日”表格视图控制器创建了“添加生日”视图控制器 ➋ 并将自己设置为“添加生日”视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从“添加生日”视图控制器传递到“生日”表格视图控制器。*

`AddBirthdayViewControllerDelegate`协议定义了一个方法，`addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存按钮 ➌ 时，添加生日视图控制器调用该方法 ➍ 并将新的生日信息传递给它的代理——**Birthdays**表格视图控制器。**Birthdays**表格视图控制器接收到生日信息后，将其添加到生日数组中，并重新加载表格视图 ➎ ，以便新添加的生日会显示在表格中。

我们将展示如何创建一个`AddBirthdayViewControllerDelegate`协议，其中包含方法`addBirthdayViewController(_:didAddBirthday:)`，这样每当应用中添加一个生日时，添加生日视图控制器就可以调用该方法。**Birthdays**表格视图控制器会实现该协议方法，这样每当通过添加生日视图控制器添加一个生日时，添加生日视图控制器只需要对其代理说：“嘿！有人刚刚添加了这个生日”，而**Birthdays**表格视图控制器会接收到这个消息并回应：“哦！我会把这个添加到我的列表中，并刷新显示，让新生日出现在表格中。”

现在，让我们在代码中实现这一部分吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在`AddBirthdayViewController`类的*上方*，添加如下代码来定义`AddBirthdayViewControllerDelegate`协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 定义协议时，输入关键字`protocol`，后跟协议名`AddBirthdayViewControllerDelegate`。这是一个较长的名称，但 Swift 程序员通常会根据调用类的名称来命名协议，并在结尾加上`Delegate`一词。这样，你就能通过协议的名称知道哪个类在使用该协议。既然你现在是 Swift 程序员了，应该遵循相同的命名规范。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)`是唯一的函数，它用于将生日对象传回给代理类 ➋ 。请注意，在这个函数中，你会包含`AddBirthdayViewController`作为参数。再说一次，Swift 程序员通常会按照惯例在实现协议方法时这样做，因此你也应该遵循这个做法。这有助于了解是谁发回了消息，并且让代理能够访问该对象及其类。

当添加生日视图控制器调用此方法时，它会将自身作为`addBirthdayViewController`参数传递。你很快就会看到这是如何实现的。另一个要注意的是外部参数名称`didAddBirthday`。许多代理协议方法都包含`*did*`和`*will*`这两个词，因为它们用于描述调用类刚刚做过的事或将要做的事。

现在你已经定义了协议，需要告诉**Birthdays**表格视图控制器遵循该协议并使用协议中的方法。

##### 让 Birthdays 表格视图控制器遵循协议

要采用这个协议，Birthdays 表格视图控制器需要让自己成为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，在 UITableViewController 超类后面添加 AddBirthdayViewControllerDelegate。要做到这一点，在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate ：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦这样做，就会出现一个红色错误。这是因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快就会解决这个问题。

这里需要特别注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，而这个超类的名字必须写在任何协议之前。但是，虽然一个类只能有一个超类，它可以采纳任意多个协议——这些协议会在超类之后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要向 BirthdaysTableViewController 添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的添加位置是在类的末尾，紧接着导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成功能会建议这个完整的方法声明。这是因为它知道这个类采纳了 AddBirthdayViewControllerDelegate 协议，并且它期望你添加这个方法。请注意，与子类化方法不同，在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将由 AddBirthday 视图控制器传递过来的 Birthday 添加到 birthdays 数组中。你可以通过使用 append(_:) 方法来实现 ➋。接下来，你需要刷新表格视图，以便显示这个新添加的生日，通过调用 tableView 属性的 reloadData() 方法 ➌。当 reloadData() 被调用时，表格视图的数据源方法会重新被调用，新增的 Birthday 会显示在生日列表的底部。

你可能注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这虽然不是必须的，但将类的不同部分标记出来是良好的编码风格，它有助于保持代码的整洁和可读性。注释的第一部分 `MARK: -` 是 Xcode 识别的特殊关键字，它会将 `AddBirthdayViewControllerDelegate` 部分添加到下拉目录中，你可以在类的顶部使用该菜单进行跳转。这个下拉菜单有助于你查找方法，并让你跳转到代码的不同位置。要使用这个菜单，请点击编辑器面板顶部的 `Birthdays TableViewController`，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 给添加生日视图控制器设置代理

`BirthdaysTableViewController` 已经遵循了 `AddBirthdayViewControllerDelegate` 协议。现在是时候让添加生日视图控制器使用 `AddBirthdayViewControllerDelegate` 协议，通知生日表视图控制器它已成功添加了一个生日。为此，添加生日视图控制器首先需要定义一个代理。我们通过在 `AddBirthdayViewController` 类中添加一个可选的代理属性 `AddBirthdayViewControllerDelegate` 来实现这一点，可以在 outlets 下面插入以下代码：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是一个可选类型，因为你不能在添加生日视图控制器创建之前就设置它。你将很快学到在哪里设置代理。

现在，既然添加生日视图控制器（Add Birthday view controller）已经有了一个代理（delegate），你可以在 `saveTapped(_:)` 方法中，通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将一个生日（Birthday）传递给代理。将 `saveTapped(_:)` 修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊ 处的代码使用 `addBirthdayViewController(_:didAddBirthday:)` 方法将其传回给代理。

很好！你已经完成了对添加生日视图控制器的修改。它现在有了一个代理，能够监听生日保存的事件。运行应用程序看看会发生什么。

嗯……好像没什么变化。当你添加一个生日时，生日依然没有出现在生日表视图控制器中。怎么回事？

#### 通过设置代理连接这两个控制器

还有一件事你必须做。`BirthdaysTableViewController` 是一个 `AddBirthdayViewControllerDelegate`，而添加生日视图控制器有一个 `AddBirthdayViewControllerDelegate` 类型的属性，用于存储它与之通信的代理对象，当一个生日被保存时，它会与代理进行交互。但我们从未明确地将代理属性设置为生日表视图控制器。所以，现在是时候将这两个视图控制器之间的通信连接起来了。

在**BirthdaysTableViewController**类的导航部分，有一个被注释掉的方法`prepare(for:sender:)`。通过删除包围它的`/*`和`*/`来取消注释该方法。

每当**生日表格视图控制器**失去屏幕控制并且应用通过故事板 segue 切换到另一个视图控制器时，这个方法会被自动调用。我们将利用这个方法将**生日表格视图控制器**传递给**添加生日视图控制器**，并将其设置为**添加生日视图控制器**的代理。请在`prepare(for:sender:)`方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置**添加生日视图控制器**的代理为**生日表格视图控制器**只需要三行代码。首先，你需要能够从 segue 参数中获取到`AddBirthdayViewController`对象。Xcode 在注释中给出了如何做的提示。`UIStoryboardSegue`有一个名为`destination`的属性，它表示正在准备的 segue 的目标，但这个应用的目标并不是`AddBirthdayViewController`。

在第九章中，你将**添加生日视图控制器**嵌入到一个导航控制器中，以便可以使用带有“取消”和“保存”按钮的导航栏。所以你不会在 segue 的另一端找到**添加生日视图控制器**。相反，目标是一个包含**添加生日视图控制器**的`UINavigationController`。在➊的那一行中，你可以获取到`navigationController`。代码`segue.destination`将返回一个`UIViewController`，但由于我们的`navigationController`是`ViewController`的特定类型，因此我们需要通过`as`进行类型转换，将其转换为`UINavigationController`。

接下来，你可以获取**添加生日视图控制器**，它是`navigationController`的`topViewController`➋。`topViewController`就是当前显示在`navigationController`中的视图控制器，但它的属性是`UIViewController`类型，因此必须进行类型转换，将其转换为`AddBirthdayViewController`，以指明这是`UIViewController`的一个特定子类。最后，当你拥有了`AddBirthdayViewController`，你可以将代理设置为`self`，而此时`self`就是**生日表格视图控制器**➌。

现在运行应用并添加一些生日！你在**生日表格视图控制器**中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用再重新运行，之前的生日将会消失。我们还需要将生日保存到设备中，稍后将在第十二章中进行处理。

### 你学到的内容

在这一章中，你学会了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在**添加生日视图控制器**中添加一个生日，然后如何使用代理将生日添加到**生日表格视图控制器**中的生日数组，以便进行显示。

在第十二章中，你将学习如何将生日保存到设备上，这样即使你退出应用程序并重新启动，它们仍然会显示。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

接下来，我们需要找出应该在单元格中显示哪个生日。我们想要在每一行显示`birthdays`数组中的一个生日。第一个生日，位于`birthdays[0]`，应该显示在第 0 行。第二个生日，位于`birthdays[1]`，应该显示在第 1 行，依此类推，这意味着`indexPath`的行与我们想要访问的`birthdays`数组中的位置是一样的。在➋的代码中，通过使用`indexPath.row`来访问`birthdays`数组中的正确生日对象。一旦我们得到了正确的生日对象，就将它赋值给一个名为`birthday`的常量，这样我们就可以在这个单元格中设置标签。

请注意，我们使用`let`将生日赋值给常量而不是变量。我们可以使用`let`，因为每次调用`tableView(_:cellForRowAt:)`时，都会创建一个新的生日常量。每个单元格都会获得自己的生日常量，并且会将其分配给自己的生日对象。由于我们不打算改变任何生日常量——我们只是读取它们的属性——所以我们不想将它们设置为变量。

现在你已经有了单元格和生日信息，是时候填写细节了。你需要为每个单元格添加两个标签，分别显示生日人的姓名和出生日期。你将单元格设置为副标题样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，所以现在你不需要自己创建任何标签。

这些标签作为`UITableViewCell`的属性存在，分别叫做`textLabel`和`detailTextLabel`。在➌的代码中，`textLabel`的文本被设置为由生日的`firstName`和`lastName`组成的字符串，中间有一个空格。在➍，你使用`dateFormatter`的`string(from:)`方法将出生日期显示在`detailTextLabel`中。

当你的单元格完全配置好后，`tableView(_:cellForRowAt:)`会在➎返回单元格，以便它可以在表格视图的该索引路径位置显示。

### 整合一切

现在你可以使用添加生日视图控制器将生日实例添加到应用程序中，并且你有一个表格视图来列出每个生日，显示在生日表格视图控制器中。但是，当你尝试运行应用程序并添加一个生日时，它并没有显示。为了让你添加的每个生日都出现在表格视图中，你需要让添加生日视图控制器与生日表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 显示在自己之上。A 知道 B 的存在，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但 B 并不知道 A 的存在——它只是突然出现的，不知道从哪里来或者怎么到达的。那么 B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将一项工作或任务交给其他人处理。一个*委托人*就像是一个老板，告诉被委托的员工该做什么。当被委托的员工完成任务后，有时会将信息反馈给委托人。

在 Swift 中，委托的实现非常相似，不过我们没有老板和员工，而是有委托者和被委托对象。由于类 B 是由类 A 告诉该做什么的，所以它是被委托对象。我们给类 B 一个特殊的属性，叫做委托（delegate），来告诉它委托者是谁——这样它就知道该与谁沟通。委托可以是任何具有一组在*协议*中定义的方法的类。协议就像是两个类之间的约定，告诉它们委托者可以要求被委托对象做什么。协议中列出了委托者可以在与被委托对象交互时使用的方法和属性名称。

类 A 创建类 B，将自己设为类 B 的委托，并为类 B 指派一个在协议中定义的任务。一旦类 B 完成任务，它就会向类 A 汇报。我们来看看在我们的应用程序中如何实现。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议定义一个方法：addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用来报告结果。

看看 图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器会创建添加生日视图控制器 ➋ 并将自己设为该控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为拥有一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，添加生日视图控制器会调用这个方法 ➍ 并将新的生日传递给它的委托——生日表视图控制器。生日表视图控制器接收到这个生日后，会将其添加到自己的生日数组中，然后重新加载表视图 ➎ ，这样新生日就会显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并在其中定义 addBirthdayViewController(_:didAddBirthday:)方法，供“添加生日”视图控制器在每次添加生日时调用。生日表格视图控制器将实现该协议方法，这样每当通过“添加生日”视图控制器添加生日时，“添加生日”视图控制器就可以告诉其代理：“嘿！有人刚刚添加了这个生日。” 生日表格视图控制器会接收到这个消息并回复：“哦！我会将它添加到我的列表中，并刷新我的显示，确保新添加的生日能够显示出来。”

所以现在让我们在代码中实现这一点！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，*在*AddBirthdayViewController 类的上方，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处定义协议，使用关键字 protocol，后面跟着协议名 AddBirthdayViewControllerDelegate。这个名字有点长，但 Swift 程序员通常会用调用类的名字命名协议，并在后面加上“Delegate”这个词。这样，你就可以通过查看协议的名字知道是哪个类在使用这个协议。既然你现在是 Swift 程序员了，应该遵循这个命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，用来将 Birthday 对象传回给代理类➋。注意，你在这个函数中包括了 AddBirthdayViewController 作为一个参数。再次强调，Swift 程序员在实现协议方法时，通常会按惯例这么做，所以你也应该遵循这个约定。这样做有助于了解是谁发送了消息，并且让代理类可以访问这个对象及其类。

当“添加生日”视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传入。你很快就会看到具体的实现方式。另一个需要注意的点是外部参数名称 didAddBirthday。许多代理协议方法中包含*did*和*will*这两个词，因为它们用来描述调用类刚刚做过的事或将要做的事。

现在你已经定义了协议，接下来需要告诉“生日表格视图控制器”采用这个协议并使用协议中的方法。

##### 让生日表格视图控制器遵循协议

为了遵循协议，生日表格视图控制器需要让自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中，紧接 UITableViewController 父类之后，添加 AddBirthdayViewControllerDelegate。然后在类顶部，UITableViewController 后加一个逗号，接着写上 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦您这样做，红色错误就会出现。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心，我们很快就会修复这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，而且这个超类的名称必须写在任何协议之前。但是，虽然一个类只能有一个超类，它可以采纳任意数量的协议——这些协议会在超类之后列出，并且用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:)方法。一个好的添加位置是在类的末尾，就在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当您开始输入函数名时，Xcode 自动完成会建议整个方法声明。这是因为它知道这个类采纳了 AddBirthdayViewController Delegate 协议，并期望您添加这个方法。请注意，与子类方法不同，您在 addBirthdayViewController(_:didAddBirthday:)前面不使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，您需要做两件事。首先，您需要将 Add Birthday 视图控制器传递的 Birthday 添加到 birthdays 数组中。您可以通过使用数组的 append(_:)方法来完成这项工作 ➋。接下来，您需要刷新表格视图，以便它显示这个新生日，方法是调用 tableView 属性的 reloadData()方法 ➌。当调用 reloadData()时，表格视图的数据源方法将再次被调用，新的生日将显示在生日列表的底部。

您可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但标记类的不同部分是良好的编码风格，这有助于保持代码清晰可读。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到下拉目录菜单中，您可以在类的顶部使用该菜单。这个下拉菜单帮助您查找方法，并让您跳转到代码中的不同位置。要使用此菜单，请点击编辑窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：您的类内置了一个目录，可以快速跳转到某个章节。*

##### 为 Add Birthday 视图控制器指定委托

BirthdaysTableViewController 已经遵循了 AddBirthdayViewControllerDelegate 协议。现在是时候让“添加生日”视图控制器使用 AddBirthdayViewControllerDelegate 协议来告诉“生日”表格视图控制器何时添加了一个生日。为此，“添加生日”视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中，在 outlets 下面插入以下代码来安排这一点：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在“添加生日”视图控制器创建之前设置它。你很快就会学到在哪里设置代理。

现在，“添加生日”视图控制器有了代理，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将生日传递给代理。将 saveTapped(_:) 改成如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码 ➊ 通过 addBirthdayViewController(_:didAddBirthday:) 将其传回给代理。

太好了！你已经完成了对“添加生日”视图控制器的修改。现在它有了一个代理，可以监听生日被保存时的回调。运行应用程序看看会发生什么。

嗯……变化不大。当你添加一个生日时，你仍然看不到它出现在“生日”表格视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有一件事需要做。“生日”表格视图控制器是 AddBirthdayViewControllerDelegate，而“添加生日”视图控制器有一个 AddBirthdayViewControllerDelegate 类型的属性，它保存了与之通信的代理，用于当生日被保存时。然而，我们从未明确地将代理属性设置为“生日”表格视图控制器。所以，现在是时候建立我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除/*和*/来取消注释这个方法。

每当“生日”表格视图控制器放弃其屏幕，并且应用通过 storyboard segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将“生日”表格视图控制器传递到“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的代理。在 prepare(for:sender:) 方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的委托为生日表格视图控制器只需要三行代码。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你可以如何做到这一点。一个 UIStoryboardSegue 有一个叫做 destination 的属性，它指向这个方法中准备的 segue 的另一端，但对于这个应用来说，目标并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到导航控制器中，以便你可以拥有一个带有取消和保存按钮的导航栏。因此，你不期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊这一行获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定子类，我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其强制转换为 AddBirthdayViewController，以表示这个控制器是 UIViewController 的特定子类。最后，当你获得 AddBirthdayViewController 时，你可以将委托设置为 self，这个 self 目前是生日表格视图控制器 ➌。

现在运行应用并添加一些生日！你在生日表格视图控制器中看到什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用程序然后重新运行它，之前添加的生日会消失。我们还需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学会了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，然后如何使用委托将这个生日添加到生日表格视图控制器中的生日数组，以便能够显示它。

在第十二章中，你将学习如何将生日保存到设备中，以便即使退出应用程序并重新运行，它们仍然会显示。为了保存生日，你将使用 Core Data，这是我们在项目开始时就已设置的功能。

请注意，我们使用 let 将生日赋值给常量而不是变量。我们可以使用 let，因为每次调用 tableView(_:cellForRowAt:) 时，都会创建一个新的生日常量。每个单元格都会获得自己的生日常量，并为其分配一个自己的 Birthday 对象。由于我们不会更改任何生日常量——我们只是读取它们的属性——因此我们不需要将它们设为变量。

现在你已经有了单元格和生日信息，接下来是时候填写详细信息了。你需要为每个单元格设置两个标签，分别显示生日人的姓名和出生日期。你将单元格设置为副标题样式，这样它就会有一个标题标签和一个副标题标签。每个单元格已经包含了这些标签，因此现在你不需要自己创建标签了。

标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。代码在 ➌ 处将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，两者之间有一个空格。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好后，tableView( _:cellForRowAt:) 在 ➎ 返回单元格，以便它可以在表视图的该 indexPath 显示。

### 将所有内容整合在一起

现在你可以使用“添加生日”视图控制器将生日实例添加到应用中，并且你有一个表视图来列出“生日”表视图控制器中的每个生日。但当你尝试运行应用并添加生日时，它并没有出现。为了让你添加的每个生日在表视图中显示出来，你需要让“添加生日”视图控制器与“生日”表视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己之上。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 并不知晓 A——它只是突然出现，并不知道它从哪里来，也不知道它是如何到达那里。所以 B 如何与 A 通信呢？通过委托！

![](img/Image00245.jpg)

委托是指某人将任务交给其他人。*委托人*就像一个老板，告诉委托的员工该做什么。当委托员工完成任务后，有时他们会将信息报告给委托的老板。

在 Swift 中，委托的概念与其他语言非常相似，但我们不再是老板和员工的关系，而是委托者和被委托对象的关系。由于 B 类是由 A 类告知该做什么的对象，它就是委托者。我们给 B 类一个特殊的属性，叫做 delegate，用来告诉它谁是它的委托对象——这样，B 类就知道该与谁进行通信。委托可以是任何拥有在*协议*中定义的一组方法的类。协议就像是两个类之间的约定，告知它们委托可以要求委托对象做什么。它包含了一些方法和属性名称，委托可以使用这些方法和属性与委托对象进行交互。

类 A 创建类 B，并将自己设置为类 B 的委托，给类 B 分配一个协议中定义的任务。一旦类 B 完成任务，它会向类 A 报告。让我们看看这个在我们的应用中是如何工作的。

Birthdays 表格视图控制器是视图控制器 A，而 Add Birthday 视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将被 Add Birthday 视图控制器用来报告信息。

看一下图 11-6。当用户点击添加按钮 ➊ 时，Birthdays 表格视图控制器会创建 Add Birthday 视图控制器 ➋ 并将自身设置为 Add Birthday 视图控制器的委托对象。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托传递，从 Add Birthday 视图控制器到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为具有一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，Add Birthday 视图控制器会调用这个方法 ➍ 并将新的生日传递给它的委托对象，即 Birthdays 表格视图控制器。Birthdays 表格视图控制器接收到这个生日后，会将其添加到自己的生日数组中，然后重新加载表格视图 ➎，这样新添加的生日就会出现在表格中。

我们将展示如何创建一个名为 AddBirthdayViewControllerDelegate 的协议，协议中包含方法 addBirthdayViewController(_:didAddBirthday:)，当有生日被添加到应用时，Add Birthday 视图控制器可以调用该方法。Birthdays 表格视图控制器将实现该协议方法，这样每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器就可以告诉它的委托对象：“嘿！刚刚有人添加了一个生日。”而 Birthdays 表格视图控制器会接收到这个消息，并说：“哦！我会把这个添加到我的列表中，并刷新显示，以便新添加的生日能够显示出来。”

现在，让我们在代码中实现这一点！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方* 添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处定义协议，通过输入关键字`protocol`，然后是协议名称`AddBirthdayViewControllerDelegate`。这个名字很长，但 Swift 程序员通常会以调用类的名称命名他们的协议，并在末尾加上`Delegate`。这样，你可以通过查看协议的名称来知道是哪个类在使用该协议。既然你现在是 Swift 程序员，你也应该遵循这种命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)`是唯一的函数，用于将`Birthday`对象传回给代理类➋。注意，在这个函数中你包括了`AddBirthdayViewController`作为参数。同样，Swift 程序员通常在实现协议方法时会这样做，所以你也应该遵循这个惯例。知道是谁发回了消息，并且让代理能够访问该对象及其类是很有用的。

当“添加生日”视图控制器调用此方法时，它将把自身作为`addBirthdayViewController`参数传递。你很快就会看到这是如何实现的。另一个需要注意的事项是外部参数名称`didAddBirthday`。许多代理协议方法包含*did*和*will*这两个词，因为它们用于描述调用类刚刚完成或即将完成的操作。

现在你已经定义了协议，接下来需要告诉`Birthdays`表视图控制器采纳该协议并使用协议的方法。

##### 使 Birthdays Table View Controller 符合协议

要采纳协议，`Birthdays`表视图控制器需要使自身成为`AddBirthdayViewControllerDelegate`。为此，你需要在类定义中将`AddBirthdayViewControllerDelegate`添加到`UITableViewController`超类之后。将`UITableViewController`后面加一个逗号，然后输入`AddBirthdayViewControllerDelegate:`。

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，就会出现一个红色的错误。这是因为`BirthdaysTableViewController`声明它是`AddBirthdayViewControllerDelegate`，但它还没有实现该协议！为此，它需要实现`AddBirthdayViewControllerDelegate`协议定义。别担心，我们很快就会解决这个问题。

这里需要注意的是，`BirthdaysTableViewController`是继承自`UITableViewController`超类的。一个类只能有一个超类，而且超类的名称必须写在任何协议之前。但是，虽然一个类只能有一个超类，它可以采纳任意多个协议——这些协议将全部列在超类之后，并由逗号分隔。

现在，为了遵守`AddBirthdayViewControllerDelegate`协议并修复错误，我们需要在`Birthdays TableViewController`中添加`addBirthdayViewController(_:didAddBirthday:)`方法。最好的位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成会建议整个方法声明。这是因为它知道该类采用了 AddBirthdayViewController Delegate 协议，并且它期望你添加这个方法。请注意，不像子类化方法，你在`addBirthdayViewController(_:didAddBirthday:)`前不需要使用`override`关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将由添加生日视图控制器传递过来的生日添加到`birthdays`数组中。你可以通过使用数组的`append(_:)`方法来做到这一点 ➋。接下来，你需要刷新表视图以显示这个新的生日，通过调用`tableView`属性上的`reloadData()`方法 ➌。当调用`reloadData()`时，表视图的数据源方法将再次被调用，新增的生日将显示在生日列表的底部。

你可能已经注意到我们在方法上方添加了一个注释来标记这一部分：`// MARK: - AddBirthdayViewControllerDelegate ➊`。这并不是必须的，但良好的编码风格是标记类的不同部分，这有助于保持代码的整洁和可读性。注释的第一部分，`MARK: -`，是 Xcode 识别的一个特殊关键字，用于代码注释，并将`AddBirthdayViewControllerDelegate`部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你找到方法，并让你跳转到代码中的不同位置。要使用这个菜单，点击编辑器面板顶部的`Birthdays TableViewController`，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类具有内建的目录，可以快速跳转到某个部分。*

##### 给添加生日视图控制器设置代理

`BirthdaysTableViewController`已经采用了`AddBirthdayViewControllerDelegate`协议。现在是时候让添加生日视图控制器使用`AddBirthdayViewControllerDelegate`协议来通知生日表视图控制器它已经添加了一个生日。为此，添加生日视图控制器首先需要定义一个代理。我们通过在`AddBirthdayViewController`类的插座下面添加一行代码来安排这个，创建一个类型为`AddBirthdayViewControllerDelegate`的可选代理属性：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在*添加生日视图控制器创建之后*设置它。你将很快学习到在哪里设置代理。

现在，添加生日视图控制器已经有了代理，在`saveTapped(_:)`方法中，你可以使用`addBirthdayViewController(_:didAddBirthday:)`方法将生日传递给代理。将`saveTapped(_:)`修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，代码在 ➊ 通过`addBirthdayViewController(_:didAddBirthday:)`方法将其传回给代理。

很好！你已经完成了对添加生日视图控制器的修改。现在它有了一个代理，能够监听生日保存的调用。运行应用程序看看会发生什么。

嗯……似乎没什么变化。当你添加一个生日时，你仍然看不到它出现在生日表格视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事要做。生日表格视图控制器是一个 AddBirthdayViewControllerDelegate，添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用于保存它与之通信的代理，当生日被保存时。但我们从未明确设置代理属性为生日表格视图控制器。所以，现在是时候连接这两个视图控制器之间的通信管道了。

在生日表格视图控制器类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除 /* 和 */，取消注释这个方法。

当生日表格视图控制器退出屏幕并且应用程序通过 storyboard segue 转到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将生日表格视图控制器传递给添加生日视图控制器，并将其设置为添加生日视图控制器的代理。请在 prepare(for:sender:)方法中编写以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的代理为生日表格视图控制器需要三行代码。首先，你需要能够从 segue 参数中获取到 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你可以如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，它指向在此方法中正在准备的 segue 的另一端，但对于这个应用程序，目标并不是 AddBirthdayViewController。

在第九章，你将添加生日视图控制器嵌入到导航控制器中，这样你就可以有一个带有取消和保存按钮的导航栏。所以，你不会在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊ 处的代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是特定类型的 ViewController，我们需要使用 as 进行类型转换，将其转换为 UINavigationController。

接下来，您可以获取添加生日视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表示该控制器是 UIViewController 的一个特定子类。最后，当您拥有 AddBirthdayViewController 时，您可以将代理设置为 self，当前它是生日表格视图控制器 ➌。

现在运行应用并添加一些生日吧！您在生日表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果您退出应用然后再重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，我们将在第十二章中进行。

### 您学到了什么

在本章中，您学习了如何创建一个表格视图控制器来显示您的生日列表。您还学习了如何在添加生日视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表格视图控制器中的生日数组，以便可以显示它。

在第十二章中，您将学习如何将生日保存到设备中，以便即使退出应用并重新运行，它们也会显示。为了保存生日，您将使用我们在项目开始时设置的 Core Data。

现在您已经有了单元格和生日，是时候填写详细信息了。您需要为每个单元格设置两个标签来显示生日者的姓名和出生日期。您将单元格设置为副标题样式，以便它具有标题标签和副标题标签。每个单元格已经包含这些标签，因此现在您不必自己创建标签。

这些标签作为 UITableViewCell 的属性存在，分别称为 textLabel 和 detailTextLabel。代码中的 ➌ 将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，中间用空格隔开。然后在 ➍ 中，您使用 dateFormatter 的 string(from:)方法在 detailTextLabel 中显示出生日期。

当您的单元格完全配置时，tableView( _:cellForRowAt:) 会返回该单元格 ➎，以便它可以在表格视图的该索引路径处显示。

### 综合应用

现在，您可以使用添加生日视图控制器向应用程序添加生日实例，并且您有一个表格视图来列出生日表格视图控制器中的每个生日。但是，当您尝试运行应用并添加一个生日时，它并没有出现。为了使每个您添加的生日都出现在表格视图中，您需要让添加生日视图控制器与生日表格视图控制器进行通信。您可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托模式。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自己的上方。A 知道 B，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它刚刚被创建出来，根本不知道它来自哪里或是怎么到达这里的。那么，B 怎么与 A 进行通信呢？通过委托！

![](img/Image00245.jpg)

委托就是某人将一项任务或工作交给别人。*委托*就像是一个老板，告诉一个委托的员工该做什么。当委托的员工完成任务时，有时会将信息报告给委托的老板。

Swift 中的委托模式非常相似，不过我们没有老板和员工，而是有委托和委托对象。由于 B 类是被 A 类告知要做什么的，因此它是委托对象。我们给 B 类一个特殊的属性，称为 delegate，用来告诉它谁是它的委托对象——这样，它就知道该与谁沟通了。委托可以是任何一个拥有在*协议*中定义的一组方法的类。协议就像是两类之间的协议，告诉它们委托可以要求委托对象做些什么。协议包含了委托可以与委托对象一起使用的方法和属性的名称列表。

A 类创建了 B 类，使自己成为 B 类的委托对象，并给 B 类一个要执行的任务，这个任务在协议中定义。当 B 类完成任务后，它会向 A 类报告。让我们看看这个在我们的应用中是如何实现的。

Birthdays 表格视图控制器是视图控制器 A，Add Birthday 视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将由 Add Birthday 视图控制器使用来报告结果。

请看一下 图 11-6。当用户点击添加按钮 ➊ 时，Birthdays 表格视图控制器创建了 Add Birthday 视图控制器 ➋ 并将自己设置为 Add Birthday 视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：通过委托，新的生日从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为包含一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮 ➌ 时，Add Birthday 视图控制器调用该方法 ➍ 并将新的生日传递给它的委托，Birthdays 表格视图控制器。Birthdays 表格视图控制器接收到该生日后，会将其添加到自己的 birthdays 数组中，然后重新加载表格视图 ➎，以便新生日会显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，其中包含 addBirthdayViewController(_:didAddBirthday:)方法，Add Birthday 视图控制器每当添加生日时，都可以调用这个方法。Birthdays 表视图控制器将实现这个协议方法，这样每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器就可以对其代理说：“嘿！有人刚刚添加了这个生日，”而 Birthdays 表视图控制器会收到这个消息并说：“哦！我会把这个添加到我的列表中，并刷新显示，让新的生日出现在屏幕上。”

那么现在让我们用代码来实现吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，*在*AddBirthdayViewController 类上方，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处通过键入关键字 protocol，然后跟上 AddBirthdayViewControllerDelegate 的名称来定义协议。这个名字比较长，但 Swift 程序员通常会以调用类的名称命名协议，并在末尾加上 Delegate 一词。这样，你就能通过协议的名称知道是哪个类在使用这个协议。既然你现在是 Swift 程序员，你应该遵循相同的命名惯例。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传递回代理类 ➋。请注意，你在这个函数中包含了 AddBirthdayViewController 作为参数。Swift 程序员在实现协议方法时，通常会这样做，因此你也应该遵循这一惯例。知道是谁发送回消息并让代理访问那个对象及其类是非常有用的。

当 Add Birthday 视图控制器调用此方法时，它会将自己作为 addBirthdayViewController 参数传入。你很快就会看到如何做到这一点。另一个需要注意的是外部参数名称 didAddBirthday。许多代理协议方法包含*did*和*will*这两个词，因为它们用于描述调用类刚刚完成或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表视图控制器去采用这个协议并使用协议中的方法。

##### 让 Birthdays 表视图控制器遵循协议

为了采用这个协议，Birthdays 表视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，在 UITableViewController 超类后添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后面加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色错误就会出现。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现它，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快就会修复这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 的子类。一个类只能有一个父类，并且这个父类的名称必须在任何协议之前写明。但虽然一个类只能有一个父类，它可以采用任意多个协议——这些协议都会列在父类之后，并且用逗号隔开。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:)方法。一个合适的位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 自动补全建议了整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它预计你会添加这个方法。请注意，不像在子类方法中，addBirthdayViewController(_:didAddBirthday:)方法前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传入的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:)方法来实现这一点 ➋。接下来，你需要刷新表格视图，以便显示这个新添加的生日，通过调用 tableView 属性上的 reloadData()方法 ➌。当调用 reloadData()时，表格视图的数据源方法将会再次被调用，新增的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但标记类的不同部分是一种良好的编码风格，这有助于保持代码的清晰和可读。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你找到方法，并让你跳转到代码的不同位置。要使用这个菜单，点击编辑器窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 给添加生日视图控制器添加代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来告诉 Birthdays 表格视图控制器它已添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个可选的 AddBirthdayViewControllerDelegate 类型的代理属性来安排这一点，代码插入位置在 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在创建 Add Birthday 视图控制器之前，不能设置它。稍后你会学到如何设置代理。

现在 Add Birthday 视图控制器已经有了一个代理，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日对象传递给代理。将 saveTapped(_:) 方法修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊ 处的代码使用 addBirthdayViewController(_:didAddBirthday:) 方法将其传递回代理。

很好！你已经完成了对 Add Birthday 视图控制器的修改。现在它有了一个代理，可以监听生日保存的调用。运行应用程序看看会发生什么。

嗯……变化不大。当你添加一个生日时，仍然没有看到它显示在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置代理连接这两个控制器

还有一件事需要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用于保存它与之通信的代理，当一个生日被保存时。但我们从未明确地将代理属性设置为 Birthdays 表格视图控制器。所以现在是时候连接这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个已被注释掉的方法，名为 prepare(for:sender:)。通过删除 /* 和 */，取消注释该方法。

这个方法会在每次 Birthdays 表格视图控制器放弃屏幕并且应用程序通过故事板 segue 转到另一个视图控制器时自动调用。我们将使用这个方法将 Birthdays 表格视图控制器传递给 Add Birthday 视图控制器，设置它自己为 Add Birthday 视图控制器的代理。在 prepare(for:sender:) 方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

需要三行代码才能将 Add Birthday 视图控制器的 delegate 设置为 Birthdays 表格视图控制器。首先，你需要能够从 segue 参数中获取到 AddBirthdayViewController 对象。Xcode 已经留下了一条注释，提示你如何做到这一点。UIStoryboardSegue 有一个叫做 destination 的属性，它位于此方法中正在准备的 segue 的另一端，但该应用程序的目标并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到了一个导航控制器中，这样你就可以有一个带有取消和保存按钮的导航栏。因此，你不会期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个 UINavigationController，它包含了 Add Birthday 视图控制器。➊ 这一行代码可以获取到 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是特定类型的视图控制器，因此我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其类型转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的一个特定子类。最后，当你有了 AddBirthdayViewController 后，可以将 delegate 设置为 self ，此时 self 就是当前的 Birthdays 表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在 Birthdays 表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序然后重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中实现。

### 你学到了什么

在这一章中，你学习了如何创建一个表格视图控制器来显示生日列表。你还学会了如何在 Add Birthday 视图控制器中添加生日，然后通过使用 delegate 将生日添加到 Birthdays 表格视图控制器中的 birthdays 数组中，以便显示出来。

在第十二章中，你将学习如何将生日保存到你的设备上，这样即使退出应用程序并重新运行，它们仍然会显示。为了保存生日，你将使用 Core Data，我们在项目的最开始就设置了它。

标签作为 UITableViewCell 的属性存在，分别叫做 textLabel 和 detailTextLabel。➌ 处的代码将 textLabel 的文本设置为由生日的 firstName 和 lastName 组成的字符串，二者之间用空格隔开。在 ➍ 处，你使用 dateFormatter 的 string(from:) 方法，将出生日期显示在 detailTextLabel 中。

当你的单元格完全配置好时，tableView( _:cellForRowAt:) 会返回该单元格 ➎，以便它可以在表视图的该索引路径处显示。

### 将所有内容结合起来

现在，你可以使用添加生日视图控制器向应用程序中添加生日实例，并且你有一个表视图来列出每个生日信息。但当你尝试运行应用并添加生日时，它并没有出现在表视图中。为了使你添加的每个生日能够出现在表视图中，你需要让添加生日视图控制器与生日表视图控制器进行通信。你可以通过使用*代理*来实现这一点。

#### 代理模式

代理模式可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 显示在自身之上。A 知道 B 的存在，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但 B 不知道 A——它只是被创建出来的，并不知道自己从哪里来，也不知道怎么到这里来的。那么 B 如何与 A 通信呢？通过代理！

![](img/Image00245.jpg)

代理是指有人把任务交给别人来做。*代理*就像是一个老板，告诉一个委托的员工该做什么。当委托员工完成任务时，他们有时会将信息回报给代理老板。

在 Swift 中，代理模式是相似的，但不是有一个老板和一个员工，而是有一个代理和一个委托对象。由于是类 A 告诉类 B 做什么，所以类 B 是委托对象。我们给类 B 一个特殊的属性，叫做代理（delegate），用来告诉它它的代理是谁——这样它就知道该与谁通信。代理可以是任何一个拥有在*协议*中定义的一组方法的类。协议就像是两个类之间的协议，告诉它们代理可以要求委托对象做什么。协议包含了代理可以与委托对象一起使用的方法和属性名称列表。

类 A 创建类 B，将自己设置为类 B 的代理，并给类 B 分配一个在协议中定义的任务。类 B 完成任务后，会向类 A 回报。让我们看看在我们的应用中这是如何工作的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用于回报。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器创建添加生日视图控制器 ➋ 并将自身设置为该添加生日视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：通过代理从添加生日视图控制器向生日表视图控制器传递并添加新生日。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法 `addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存按钮 ➌ 时，Add Birthday 视图控制器会调用这个方法 ➍，并将新的生日信息传给它的委托，即 Birthdays 表视图控制器。Birthdays 表视图控制器接收到这个生日信息后，将其添加到自己的生日数组中，然后重新加载表视图 ➎，这样新添加的生日就会出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义方法 `addBirthdayViewController(_:didAddBirthday:)`，当应用中添加生日时，Add Birthday 视图控制器可以调用这个方法。Birthdays 表视图控制器将实现该协议方法，这样每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器就可以对委托说，“嘿！有人刚刚添加了这个生日，”而 Birthdays 表视图控制器会收到这个消息，并说：“哦！我会把它添加到我的列表中，并刷新我的显示，让新生日出现在表格里。”

现在让我们来写代码吧！

##### 创建一个协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类 *之前*，添加以下代码定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 定义了协议，通过输入关键字 protocol 后接协议名 AddBirthdayViewControllerDelegate。这个名字很长，但 Swift 程序员通常会以调用类的名称命名协议，并在后面加上 Delegate 这个词。这样，你就能通过协议的名称知道是哪个类在使用该协议。既然你现在是 Swift 程序员了，你也应该使用相同的命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)` 是唯一的函数，它用于将 Birthday 对象传回给委托类 ➋。注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。再次提醒，Swift 程序员通常会根据约定，在实现协议方法时这样做，所以你也应该遵循这个做法。知道是谁发送回信息以及委托类可以访问该对象及其类是很有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 `addBirthdayViewController` 参数传递。你很快就会看到这个是怎么做的。另一个需要注意的点是外部参数名 `didAddBirthday`。许多委托协议方法都包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚做过的事情或即将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表视图控制器采纳这个协议并使用协议的方法。

##### 让 Birthdays 表视图控制器符合协议

为了采用这个协议，**BirthdaysTableViewController** 需要声明自己是一个 **AddBirthdayViewControllerDelegate**。为此，你需要在类定义中，紧跟在 **UITableViewController** 超类之后，添加 **AddBirthdayViewControllerDelegate**。在类的顶部，在 **UITableViewController** 后添加一个逗号，然后输入 **AddBirthdayViewControllerDelegate**：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色错误会出现。这是因为 **BirthdaysTableViewController** 声明自己是一个 **AddBirthdayViewControllerDelegate**，但它还没有实现这个协议！为了解决这个问题，它需要实现 **AddBirthdayViewControllerDelegate** 协议的定义。别担心——我们很快就能解决这个问题。

在这里需要注意的是，**BirthdaysTableViewController** 是对 **UITableViewController** 超类的子类化。一个类只能有一个超类，且该超类的名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采用任意数量的协议——这些协议会在超类之后列出，并用逗号分隔。

现在，为了遵守 **AddBirthdayViewControllerDelegate** 协议并修复错误，我们需要在 **BirthdaysTableViewController** 中添加 `addBirthdayViewController(_:didAddBirthday:)` 方法。一个合适的位置是在类的末尾，就在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成功能会建议整个方法声明。这是因为它知道这个类遵循了 **AddBirthdayViewControllerDelegate** 协议，并且它期待你添加这个方法。请注意，与子类化方法不同，你在 `addBirthdayViewController(_:didAddBirthday:)` 方法前面不需要使用 `override` 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 **AddBirthday** 视图控制器传递的 **Birthday** 添加到 **birthdays** 数组中。你可以使用数组的 `append(_:)` 方法来实现这一点 ➋。接下来，你需要刷新表格视图，使其显示这个新添加的生日，可以通过调用 **tableView** 属性的 `reloadData()` 方法来完成 ➌。当调用 `reloadData()` 时，表格视图的数据源方法将再次被调用，新的 **Birthday** 将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这并不是必需的，但标记类的不同部分是良好的编码风格，它有助于保持代码清晰易读。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你找到方法并让你跳转到代码的不同位置。要使用此菜单，请点击编辑器窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类具有内置的目录，可以快速跳转到某个部分。*

##### 给 Add Birthday 视图控制器添加委托

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在，轮到让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来告诉 Birthdays 表格视图控制器它已经添加了一个生日了。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个可选的 AddBirthdayViewControllerDelegate 类型的委托属性来安排这件事，代码如下，插入此行代码到 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在创建 Add Birthday 视图控制器之前，你无法设置它。你将很快了解在哪里设置委托。

现在，Add Birthday 视图控制器有了一个委托，在 saveTapped(_:)方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:)方法将一个生日传递给委托。将 saveTapped(_:)方法修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)将其传递回委托。

很棒！你已经完成了对 Add Birthday 视图控制器的修改。它现在有了一个委托，可以监听生日保存的调用。运行应用程序，看看会发生什么。

嗯……变化不大。当你添加一个生日时，仍然看不到它在 Birthdays 表格视图控制器中显示出来。怎么回事？

#### 通过设置委托连接两个控制器

你还有最后一件事需要做。Birthdays 表格视图控制器是 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存它在生日保存时与之通讯的委托。但我们从未明确地将委托属性设置为 Birthdays 表格视图控制器。因此，是时候连接我们两个视图控制器之间的通讯管道了。

在 `BirthdaysTableViewController` 类的导航部分，有一个被注释掉的方法，名为 `prepare(for:sender:)`。通过删除围绕它的 `/*` 和 `*/` 注释符号来取消注释该方法。

每当 `BirthdaysTableViewController` 放弃其屏幕并且应用通过 storyboard segue 切换到另一个视图控制器时，系统会自动调用此方法。我们将利用此方法将 `BirthdaysTableViewController` 传递给 `AddBirthdayViewController`，并将 `BirthdaysTableViewController` 设置为 `AddBirthdayViewController` 的代理。在 `prepare(for:sender:)` 方法中编写以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的代理为“生日”表视图控制器只需三行代码。首先，你需要能够通过 segue 参数访问到 `AddBirthdayViewController` 对象。Xcode 在注释中留下了提示，告诉你如何做到这一点。`UIStoryboardSegue` 有一个名为 `destination` 的属性，它位于正在此方法中准备的 segue 另一端，但对于这个应用来说，目的地并不是 `AddBirthdayViewController`。

在第九章中，你将“添加生日”视图控制器嵌入到一个导航控制器中，这样你就可以拥有一个带有“取消”和“保存”按钮的导航栏。因此，你不应该期待在 segue 另一端找到 `AddBirthdayViewController`。相反，目的地是一个包含 `AddBirthdayViewController` 的 `UINavigationController`。在 ➊ 这一行，你可以得到 `navigationController`。`segue.destination` 将返回一个 `UIViewController`，但是由于我们的 `navigationController` 是 `UIViewController` 的一个特定子类，我们需要使用 `as` 将其强制转换为 `UINavigationController`。

接下来，你可以获取 `AddBirthdayViewController`，它是 `navigationController` 的 `topViewController` ➋。`topViewController` 就是当前在 `navigationController` 中显示的视图控制器，但它的属性类型是 `UIViewController`，因此必须将其强制转换为 `AddBirthdayViewController`，以指明该控制器是 `UIViewController` 的特定子类。最后，当你获取到 `AddBirthdayViewController` 时，可以将代理设置为 `self`，即当前的 `BirthdaysTableViewController` ➌。

现在运行应用并添加一些生日！你在“生日”表视图控制器中看到什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用后再重新运行，之前添加的生日会消失。我们仍然需要将生日保存到设备中，具体方法将在第十二章中介绍。

### 你学到的内容

在这一章，你学会了如何创建一个表视图控制器来显示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加生日，然后通过代理将生日添加到“生日”表视图控制器中的生日数组，以便它能够被显示。

在第十二章中，你将学习如何将生日保存到你的设备中，以便即使退出应用程序后再次运行，它们依然会显示出来。为了保存生日，你将使用在项目开始时就设置好的 Core Data。

当你的单元格完全配置好时，tableView(_:cellForRowAt:)会返回单元格➎，以便它可以在表格视图的那个 indexPath 处显示。

### 将一切整合起来

现在，你可以通过添加生日视图控制器向应用程序中添加生日实例，并且在生日表格视图控制器中有一个表格视图列出每个生日。但当你尝试运行应用程序并添加生日时，它并没有出现。为了使每个添加的生日出现在表格视图中，你需要让添加生日视图控制器与生日表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将 B 展示在自己之上。A 知道 B，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但 B 并不知道 A，它只是突然出现，根本不知道自己是从哪里来的，也不知道怎么到达那里。那么 B 如何与 A 进行通信呢？通过委托！

![](img/Image00245.jpg)

委托是指将某项工作或任务交给别人去做。*委托*就像是一个老板，告诉委派的员工该做什么。当委派的员工完成任务时，有时他们会将信息反馈给委托的老板。

在 Swift 中，委托的实现非常相似，不过我们不是用老板和员工的关系，而是使用委托和委托对象的关系。因为类 B 是由类 A 告诉它做什么的，所以它是委托对象。我们给类 B 一个特殊的属性，叫做 delegate，来告诉它谁是它的委托——这样它就知道与谁通信。委托可以是任何一个符合*协议*的类。协议就像是两个类之间的约定，告诉它们委托可以要求委托对象做些什么。协议包含了委托可以在委托对象上使用的方法和属性的列表。

类 A 创建类 B，并使自己成为类 B 的委托，然后给类 B 一个任务，任务在协议中定义。一旦类 B 完成了任务，它就会将结果报告给类 A。让我们来看看在我们的应用中是如何实现的。

生日表格视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议定义一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用来报告回结果。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日列表视图控制器创建了添加生日视图控制器 ➋ 并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加，并通过委托从添加生日视图控制器传递到生日列表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法`addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存 ➌ 时，添加生日视图控制器调用这个方法 ➍ 并将新的生日传递给它的委托，即生日列表视图控制器。生日列表视图控制器接收到这个生日，将它添加到自己的生日数组中，然后重新加载其表格视图 ➎，以便新生日能够显示在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并且使用`addBirthdayViewController(_:didAddBirthday:)`方法，添加生日视图控制器可以在每次添加生日时调用这个方法。生日列表视图控制器将实现这个协议方法，这样每当通过添加生日视图控制器添加一个生日时，添加生日视图控制器就可以对它的委托说，“嘿！有人刚刚添加了这个生日”，而生日列表视图控制器会收到这个消息并说，“哦！我会把它添加到我的列表中，并刷新显示让新的生日出现在表格中。”

现在，让我们在代码中实现这个吧！

##### 创建一个协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类的*上方*，添加这段代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过输入关键字`protocol`，然后是协议的名字 AddBirthdayViewControllerDelegate，在➊处定义了这个协议。这个名字很长，但 Swift 程序员通常会根据调用类来命名他们的协议，并在末尾加上“Delegate”一词。这样，你就可以通过查看协议的名字来知道是哪个类在使用这个协议。既然你现在是 Swift 程序员，你也应该使用相同的命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)`是唯一的函数，它用于将 Birthday 对象传递回委托类 ➋。注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。再次强调，Swift 程序员在实现协议方法时，通常会按照约定这样做，因此你也应该遵循这种做法。知道是谁发送回消息并且让委托有机会访问那个对象及其类是非常有用的。

当 Add Birthday view controller 调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递过来。你很快就能看到如何做到这一点。另一个需要注意的点是外部参数名称 didAddBirthday。许多代理协议方法包含 *did* 和 *will*，因为它们用来描述调用类刚刚做过的事情或即将做的事情。

现在你已经定义了协议，你需要告诉 Birthdays table view controller 遵守这个协议并使用协议的方法。

##### 使 Birthdays Table View Controller 遵守协议

为了遵守协议，Birthdays table view controller 需要将自己设为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中紧跟 UITableViewController 超类之后，添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后面加上一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦这样做，红色错误就会出现。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！别担心，我们很快就会修复这个问题。

在这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，而且超类名称必须写在任何协议之前。但尽管一个类只能有一个超类，它可以采纳任意数量的协议——这些协议会在超类之后列出，并且用逗号分隔。

现在，为了遵守 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的地方是将它添加到类的末尾，就在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议这个完整的方法声明。这是因为它知道这个类采纳了 AddBirthdayViewController Delegate 协议，预计你会添加这个方法。需要注意的是，不同于子类化方法，在 addBirthdayViewController(_:didAddBirthday:) 前你不需要使用 override 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday view controller 传入的 Birthday 添加到 birthdays 数组中。你可以通过使用 append(_:) 方法来完成这一操作 ➋。接下来，你需要刷新表格视图，使其显示这个新添加的生日，方法是调用 tableView 属性的 reloadData() 方法 ➌。当 reloadData() 被调用时，表格视图的数据源方法会再次被调用，新添加的 Birthday 将会显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但标记类的不同部分是良好的编码风格，它有助于保持代码的整洁和可读性。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你查找方法，并让你可以跳转到代码中的不同位置。要使用这个菜单，请点击编辑器窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类具有内置的目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器设置委托

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来告诉 Birthdays 表格视图控制器它已添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个可选的委托属性 AddBirthdayViewControllerDelegate 类型，来完成此操作，在 outlets 下面插入以下代码：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为你不能在 Add Birthday 视图控制器创建之后再设置它。你将很快了解在哪里设置委托。

现在 Add Birthday 视图控制器有了一个委托，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日对象传递给委托。将 saveTapped(_:) 修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

生日对象创建后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 将其传递回委托。

很好！你已经完成了对 Add Birthday 视图控制器的修改。现在它有了一个委托，可以监听生日保存的回调。运行应用程序看看会发生什么。

嗯……变化不大。当你添加生日时，仍然看不到它出现在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置委托连接这两个控制器

你还需要做一件事。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，当生日被保存时，它会与委托进行通信。但是我们从未专门设置过委托属性为 Birthdays 表格视图控制器。所以现在是时候在两个视图控制器之间建立通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个被注释掉的方法叫做`prepare(for:sender:)`。删除包围它的`/*`和`*/`来取消注释该方法。

当“生日”表视图控制器放弃其屏幕并通过故事板 segue 过渡到另一个视图控制器时，此方法会自动调用。我们将使用此方法将“生日”表视图控制器传递给“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的委托。在`prepare(for:sender:)`方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的委托为“生日”表视图控制器只需三行代码。首先，你需要能够通过 segue 参数获取`AddBirthdayViewController`对象。Xcode 已经留下了一条注释，提示你如何做到这一点。一个`UIStoryboardSegue`有一个叫做`destination`的属性，它位于此方法中正在准备的 segue 的另一端，但这个应用的目标并不是`AddBirthdayViewController`。

在第九章中，你将“添加生日”视图控制器嵌入到了一个导航控制器中，这样你就可以有一个带有“取消”和“保存”按钮的导航栏。因此，你不期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的`UINavigationController`。➊处的代码会获取`navigationController`。`segue.destination`代码将返回一个`UIViewController`，但由于我们的`navigationController`是`ViewController`的特定类型，我们需要使用`as`进行类型转换，将其转换为`UINavigationController`。

接下来，你可以获取“添加生日”视图控制器，它是`navigationController`的`topViewController` ➋。`topViewController`只是当前在`navigationController`中显示的视图控制器，但它的属性是`UIViewController`类型，所以必须将其类型转换为`AddBirthdayViewController`，以表示该控制器是`UIViewController`的特定子类。最后，当你拥有一个`AddBirthdayViewController`时，你可以将委托设置为`self`，即当前的“生日”表视图控制器 ➌。

现在运行应用并添加一些生日！你在“生日”表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用然后再运行它，之前的生日会消失。我们还需要将生日保存到设备中，稍后我们将在第十二章中完成这部分内容。

### 你学到了什么

在本章中，你学习了如何创建一个表视图控制器来显示你的生日列表。你还学习了如何在“添加生日”视图控制器中添加生日，然后如何使用委托将生日添加到“生日”表视图控制器中的生日数组，以便它能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，以便即使你退出应用并再次运行，它们依然会显示。为了保存生日，你将使用在项目开始时就已设置的 Core Data。

### 整合所有内容

现在，你可以使用添加生日视图控制器将生日实例添加到应用中，并且在生日表格视图控制器中有一个表格视图列出每个生日。但当你尝试运行应用并添加生日时，它并没有显示。为了让你添加的每个生日都出现在表格视图中，你需要让添加生日视图控制器与生日表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并在自己之上展示了 B。A 知道 B 的存在，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但 B 并不了解 A——它只是突然出现的，不知道自己来自哪里，也不知道是如何来到这里的。那么 B 如何与 A 沟通呢？通过委托！

![](img/Image00245.jpg)

委托（Delegation）是指某人将任务或工作交给另一个人。一个*委托人*就像是一个老板，他告诉下属员工该做什么。当下属员工完成任务后，有时会将信息反馈给委托人。

Swift 中的委托与此类似，但不是有老板和员工，而是有委托和委托对象。由于 B 类是被 A 类告知要做什么的，因此它是委托对象。我们为 B 类提供一个特殊的属性，叫做 delegate，用来告诉它委托对象是谁——这样，它就知道与谁进行通信。委托可以是任何实现了*协议*（protocol）中一组方法的类。协议就像是两个类之间的协议，告知它们委托可以要求委托对象做些什么。协议中列出了委托可以在委托对象上使用的方法和属性。

A 类创建 B 类，使自己成为 B 类的委托，并为 B 类分配一个在协议中定义的任务。一旦 B 类完成任务，它就会向 A 类报告。让我们看看在应用中这是如何实现的。

生日表格视图控制器是视图控制器 A，而添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法：addBirthdayViewController(_:didAddBirthday:)，这个方法将由添加生日视图控制器用来回传信息。

看一下图 11-6。当用户点击“添加”按钮 ➊ 时，生日表格视图控制器创建了添加生日视图控制器 ➋，并将自己设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：通过委托，新的生日从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为有一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮时，添加生日视图控制器会调用这个方法 ➍，并将新生日传递给它的委托，即生日表视图控制器。生日表视图控制器接收这个生日，将其添加到生日数组中，然后重新加载表视图 ➎，这样新生日就会显示在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并实现 addBirthdayViewController(_:didAddBirthday:)方法，添加生日视图控制器可以在每次添加生日时调用这个方法。生日表视图控制器将实现该协议方法，这样每当使用添加生日视图控制器添加一个生日时，添加生日视图控制器就可以对它的委托说：“嘿！刚刚添加了这个生日”，而生日表视图控制器会收到这个消息并说：“哦！我会把它添加到我的列表中，并刷新我的显示，让新生日出现。”

现在让我们用代码实现这一点吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类的*上方*，添加这段定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处定义协议，通过输入关键字 protocol，后跟协议名称 AddBirthdayViewControllerDelegate。这个名字很长，但 Swift 程序员通常会根据调用类给协议命名，并在末尾加上“Delegate”一词。这样，你就能通过查看协议名称知道是哪个类在使用这个协议。既然你现在是 Swift 程序员，你也应该遵循这种命名惯例。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传递回委托类➋。注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员在实现协议方法时通常会这样做，所以你也应该遵循这个惯例。知道是谁发送的消息，并且让委托能够访问该对象及其类是很有用的。

当添加生日视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递。你很快就会看到这是如何实现的。另一个需要注意的点是外部参数名称 didAddBirthday。许多委托协议方法包含*did*和*will*这两个词，因为它们用来描述调用类刚刚做过的事情或即将做的事情。

现在你已经定义了协议，你需要告诉生日表视图控制器遵循这个协议并使用协议的方法。

##### 使 Birthdays Table View Controller 符合协议

为了采用这个协议，Birthdays table view controller 需要让自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中，在 UITableViewController 父类之后，添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做了，会出现一个红色的错误。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现它，必须实现 AddBirthdayViewControllerDelegate 协议的定义。别担心，我们很快就会修复这个问题。

在这里需要特别注意的是，BirthdaysTableViewController 是从 UITableViewController 父类派生出来的。一个类只能有一个父类，并且该父类名称必须在任何协议之前写出。但尽管一个类只能有一个父类，它可以采用任意多个协议——这些协议将列在父类之后，并且用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:)方法。添加该方法的好地方是在类的末尾，紧跟在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动完成功能会建议你整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期望你添加这个方法。注意，与子类方法不同，你在 addBirthdayViewController(_:didAddBirthday:)前面不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的 Birthday 添加到 birthdays 数组中。你可以使用数组的 append(_:)方法来完成这个操作➋。接下来，你需要刷新表视图，以便它显示这个新的生日，通过在 tableView 属性上调用 reloadData()方法➌。当调用 reloadData()时，表视图的数据源方法会再次被调用，新增的 Birthday 将显示在生日列表的底部。

你可能已经注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必须的，但将类的不同部分进行标记是良好的编码风格，有助于保持代码的清晰和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的一个特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单帮助你快速找到方法，并可以跳转到代码中的不同位置。要使用这个菜单，点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某一部分。*

##### 为 Add Birthday 视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告知 Birthdays 表视图控制器它已添加一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类的外部插入以下代码，添加一个可选的 AddBirthdayViewControllerDelegate 类型的代理属性：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在 Add Birthday 视图控制器创建之前设置它。你将在稍后学到在哪里设置代理。

现在，Add Birthday 视图控制器有了代理，在 saveTapped(_:)方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:)方法将生日传递给代理。将 saveTapped(_:)方法改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，代码中的➊部分会通过 addBirthdayViewController(_:didAddBirthday:)将其传回给代理。

太棒了！你已经完成了对 Add Birthday 视图控制器的修改。它现在有一个代理，用于监听保存生日的调用。运行应用程序看看会发生什么。

嗯……没有太大变化。当你添加一个生日时，依然没有在 Birthdays 表视图控制器中看到它出现。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事需要做。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存了与其通信的代理，在保存生日时进行交互。但我们从未明确设置代理属性为 Birthdays 表视图控制器。所以现在是时候连接两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除围绕它的 /* 和 */，取消注释该方法。

每当“生日”表视图控制器放弃其屏幕并且应用程序通过 storyboard segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将“生日”表视图控制器传递给“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的委托。请在 prepare(for:sender:) 方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码，就能将“添加生日”视图控制器的委托设置为“生日”表视图控制器。首先，你需要能够从 segue 参数获取到 AddBirthdayViewController 对象。Xcode 在代码中留下了注释，提示你如何实现这一点。UIStoryboardSegue 具有一个名为 destination 的属性，它位于此方法中正在准备的 segue 另一端，但对于这个应用程序来说，destination 不是 AddBirthdayViewController。

在第九章，你将“添加生日”视图控制器嵌入到一个导航控制器中，这样你就可以有一个带有取消和保存按钮的导航栏。因此，你不会在 segue 的另一端找到“添加生日”视图控制器。相反，destination 是一个包含“添加生日”视图控制器的 UINavigationController。➊ 这一行代码可以获取 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，因此我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 后，你可以将其委托设置为 self，也就是当前的“生日”表视图控制器 ➌。

现在运行应用程序并添加一些生日！你在“生日”表视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用程序然后重新运行它，之前的生日将会消失。我们仍然需要将生日保存到设备中，我们将在第十二章中完成这一任务。

### 你学到了什么

在这一章节中，你学会了如何创建一个表视图控制器来显示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，并如何使用委托将这个生日添加到“生日”表视图控制器的生日数组中，以便它能够显示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，以便即使退出应用并重新启动时它们仍然显示。为了保存生日，你将使用 Core Data，这部分在我们项目一开始就已经设置好了。

现在，你可以通过“添加生日”视图控制器将生日实例添加到应用中，并且在“生日”表格视图控制器中有一个表格视图列出每个生日。但当你运行应用并添加一个生日时，它并不会显示出来。为了让你添加的每个生日都出现在表格视图中，你需要让“添加生日”视图控制器与“生日”表格视图控制器进行通信。你可以通过使用*委托*来实现这一点。

#### 委托

委托机制可以在一个视图控制器需要从另一个视图控制器获取信息时使用。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B 并将其展示在自己上面。A 知道 B 的存在，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但 B 并不知道 A——它刚刚被创建并展示出来，不知道自己来自哪里，也不知道如何到达那里。那么，B 怎么与 A 沟通呢？通过委托！

![](img/Image00245.jpg)

委托机制是指某人将工作或任务交给其他人。*委托*就像是一个老板，告诉委托的员工要做什么。当委托的员工完成任务时，有时他们会将信息反馈给委托的老板。

Swift 中的委托机制与其类似，但不是有老板和员工，而是有委托者和委托对象。由于 B 类是由 A 类指示要做什么的，因此 B 类是委托对象。我们给 B 类一个特殊的属性，叫做 delegate，用来告诉它谁是它的委托对象——这样，它就知道要与谁进行沟通。委托对象可以是任何实现了*协议*中定义方法的类。协议就像是两类之间的约定，告诉它们委托对象可以要求委托者做什么。它包含了一组方法和属性名称，委托对象可以在与委托者的互动中使用这些方法。

类 A 创建了类 B，设定自己为类 B 的委托，并给类 B 一个需要在协议中完成的任务。一旦类 B 完成任务，它就会向类 A 报告。让我们看看这在我们的应用中是如何工作的。

“生日”表格视图控制器是视图控制器 A，“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法：addBirthdayViewController(_:didAddBirthday:)，这个方法将由“添加生日”视图控制器用来反馈结果。

请看一下图 11-6。当用户点击“添加”按钮 ➊时，生日表格视图控制器创建了“添加生日”视图控制器 ➋ 并将自己设置为“添加生日”视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日通过委托从添加生日视图控制器传递到生日表视图控制器。*

`AddBirthdayViewControllerDelegate`协议被定义为只有一个方法，`addBirthdayViewController(_:didAddBirthday:)`。当用户点击“保存” ➌ 时，**添加生日**视图控制器调用这个方法 ➍，并将新的生日传递给它的委托，即**生日**表视图控制器。**生日**表视图控制器接收到这个生日，将其添加到它的生日数组中，然后重新加载表视图 ➎，使得新的生日出现在表格中。

我们将向你展示如何创建一个`AddBirthdayViewControllerDelegate`协议，并实现方法`addBirthdayViewController(_:didAddBirthday:)`，这样**添加生日**视图控制器每次添加生日时，都可以调用该方法。**生日**表视图控制器将实现该协议方法，以便每当通过**添加生日**视图控制器添加一个生日时，**添加生日**视图控制器可以对它的委托说：“嘿！有人刚刚添加了这个生日”，而**生日**表视图控制器会听到这个消息并说：“哦！我会把它添加到我的列表中，并刷新我的显示，让新生日出现在表格中。”

所以现在，让我们通过代码来实现吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在`AddBirthdayViewController`类的*上方*，添加这段代码来定义`AddBirthdayViewControllerDelegate`协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处定义协议，通过输入关键字`protocol`，后面跟着协议名`AddBirthdayViewControllerDelegate`。这是一个较长的名称，但 Swift 程序员通常会按照调用类的名称命名协议，并在末尾加上“Delegate”一词。这样，你就能通过查看协议的名称来知道是哪个类在使用该协议。既然你现在是 Swift 程序员，应该遵循相同的命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)`是唯一的函数，它用于将生日对象传递回委托类 ➋。注意，你在这个函数中包括了`AddBirthdayViewController`作为参数。再次提醒，Swift 程序员在实现协议方法时，通常遵循这个约定，所以你也应该遵循。知道是谁传递回消息对委托方来说很有用，它可以访问该对象及其类。

当**添加生日**视图控制器调用这个方法时，它会将自己作为`addBirthdayViewController`参数传递进来。你很快就会看到这是如何实现的。另一个需要注意的地方是外部参数名`didAddBirthday`。许多委托协议方法包含*did*和*will*这两个词，因为它们用于描述调用类刚做完或者即将做的事情。

现在你已经定义了协议，你需要告诉**生日**表视图控制器采纳这个协议，并使用协议的方法。

##### 使 Birthdays 表格视图控制器符合协议

为了遵循协议，Birthdays 表格视图控制器需要让自己成为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中添加 AddBirthdayViewControllerDelegate，紧跟在 UITableViewController 超类之后。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，就会出现一个红色错误。这是因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现协议，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是在继承 UITableViewController 超类。一个类只能有一个超类，并且该超类名称必须在任何协议之前书写。但虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议会在超类之后列出，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 BirthdaysTableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的地方是在类的末尾，即导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成功能会建议你输入整个方法声明。这是因为它知道该类遵循了 AddBirthdayViewControllerDelegate 协议，并且它预计你会添加这个方法。请注意，与子类化方法不同，在 addBirthdayViewController(_:didAddBirthday:) 前面不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递进来的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来完成这一步 ➋。接下来，你需要刷新表格视图，确保它显示这个新添加的生日，这可以通过在 tableView 属性上调用 reloadData() 方法来实现 ➌。当调用 reloadData() 方法时，表格视图的数据源方法会再次被调用，新添加的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这并不是必需的，但在你的类中标记不同部分是一个良好的编码风格，它有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键词，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你查找方法，并让你快速跳转到代码中的不同位置。要使用这个菜单，请点击编辑窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个章节。*

##### 为添加生日视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表视图控制器它已经添加了一个生日。为此，添加生日视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中插入以下行，在 outlets 下方添加一个可选的代理属性 AddBirthdayViewControllerDelegate 来安排这件事：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在*添加生日视图控制器*创建之前设置它。你很快会学到在哪里设置代理。

现在，添加生日视图控制器已经有了代理，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将生日传递给代理。将 saveTapped(_:)修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码在➊使用 addBirthdayViewController(_:didAddBirthday:)将其传回给代理。

太好了！你已经完成了对添加生日视图控制器的修改。它现在有了一个代理，能够监听生日已保存的调用。运行应用看看会发生什么。

嗯……似乎没有太大变化。当你添加一个生日时，还是看不到它出现在 Birthdays 表视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

你还需要做一件事。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存与之通信的代理，当生日被保存时。然而，我们从未特别设置代理属性为 Birthdays 表视图控制器。所以是时候连接我们两个视图控制器之间的通信管道了。

在“BirthdayTableViewController”类的“导航”部分，有一个被注释掉的方法叫做 prepare(for:sender:)，请通过删除包围它的 /* 和 */ 来取消注释该方法。

每当“生日”表格视图控制器放弃屏幕并且应用通过 storyboard segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将“生日”表格视图控制器传递给“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的代理。在 prepare(for:sender:) 方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的代理为“生日”表格视图控制器需要三行代码。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 提供了一条注释提示，说明你可以如何做到这一点。UIStoryboardSegue 在这个方法中准备的另一个端点有一个名为 destination 的属性，但对于这个应用来说，目标不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到一个导航控制器中，这样你就可以有一个包含“取消”和“保存”按钮的导航栏。因此，你不应该期待在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊ 处的代码将返回 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定子类，我们需要使用 as 来将其类型转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的类型是 UIViewController，所以必须将其类型转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的一个特定子类。最后，当你获取到 AddBirthdayViewController 时，你可以将其代理设置为 self，即当前的“生日”表格视图控制器 ➌。

现在运行应用并添加一些生日！你在“生日”表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用并再次运行，之前的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学习了如何在“添加生日”视图控制器中添加一个生日，并且如何使用代理将生日添加到“生日”表格视图控制器中的生日数组，以便它能够显示出来。

在第十二章，你将学习如何将生日保存到设备中，这样即使退出应用程序后再次启动，它们仍然会显示出来。为了保存生日，你将使用 Core Data，这在我们项目开始时就已设置好。

#### 委托模式

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 展示在自己之上。A 知道 B 的存在，因为它创建并展示了 B，所以 A 可以将信息传递给 B。但是 B 并不知道 A——它只是突然出现的，并不知道自己从哪里来或如何到达这里。那么 B 如何与 A 进行沟通呢？通过委托！

![](img/Image00245.jpg)

委托就是指有人将工作或任务交给别人。*代理*就像是一个老板，告诉委托员工该做什么。当委托员工完成任务后，他们有时会将信息报告给代理老板。

Swift 中的委托模式很相似，不过我们不是有老板和员工，而是有委托对象和委托方对象。由于类 B 是被类 A 告知该做什么的，它是委托方对象。我们给类 B 一个特殊的属性，叫做代理(delegate)，用来告诉它它的代理是谁——这样它就知道该与谁进行通信。代理可以是任何一个类，只要它拥有在*协议*中定义的一组方法。协议就像是两个类之间的协议，它告诉它们代理可以要求委托方做什么。协议包含了一系列方法和属性名，代理可以使用这些方法与委托方对象进行交互。

类 A 创建类 B，将自己设置为类 B 的代理，并给类 B 分配一个在协议中定义的任务。一旦类 B 完成任务，它会向类 A 报告。让我们看看在我们的应用中这如何工作。

生日表格视图控制器是视图控制器 A，而“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议添加一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将由“添加生日”视图控制器用来反馈信息。

看一下图 11-6。当用户点击“添加”按钮 ➊ 时，生日表格视图控制器会创建“添加生日”视图控制器 ➋ 并将自己设置为“添加生日”视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：通过委托模式，新的生日从“添加生日”视图控制器传递到生日表格视图控制器。*

AddBirthdayViewControllerDelegate 协议定义了一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击 Save ➌时，Add Birthday 视图控制器会调用这个方法 ➍ 并将新的生日传递给它的委托，即 Birthdays 表视图控制器。Birthdays 表视图控制器会接收这个生日，将它添加到它的 birthday 数组中，然后重新加载它的表视图 ➎，以便新的生日会出现在表格中。

我们将展示如何创建一个 AddBirthdayViewControllerDelegate 协议，其中包含方法 addBirthdayViewController(_:didAddBirthday:)，当应用程序中添加生日时，Add Birthday 视图控制器可以调用该方法。Birthdays 表视图控制器将实现该协议方法，以便每当通过 Add Birthday 视图控制器添加一个生日时，Add Birthday 视图控制器可以对其委托说，“嘿！刚刚有人添加了这个生日”，然后 Birthdays 表视图控制器会接收到这个消息并说，“哦！我会把它添加到我的列表中并刷新我的显示，以便新生日能够显示出来。”

现在让我们在代码中实现这一点！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，*在* AddBirthdayViewController 类之前，添加这段定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处通过输入关键字 protocol 并跟随名称 AddBirthdayViewControllerDelegate 来定义协议。这个名字很长，但 Swift 程序员通常会根据调用类的名称来命名他们的协议，并在最后加上 Delegate 一词。这样，你就可以通过查看协议的名称来知道是哪个类在使用该协议。既然你现在是 Swift 程序员了，你应该遵循相同的命名规范。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传递回委托类➋。请注意，你在这个函数中包括了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员在实现协议方法时根据约定这样做，因此你也应该坚持这样做。这对于知道是谁发送了消息以及委托是否能够访问该对象及其类是很有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递。你很快就会看到如何做到这一点。另一个需要注意的地方是外部参数名称 didAddBirthday。许多委托协议方法包含*did*和*will*这两个词，因为它们用来描述调用类已经做了或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表视图控制器采纳这个协议并使用协议的方法。

##### 让 Birthdays 表视图控制器遵循协议

为了采用协议，Birthdays 表格视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中，在 UITableViewController 超类后面添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色的错误就会出现。发生这种情况是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心，我们很快就会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是子类化 UITableViewController 超类的。一个类只能有一个超类，而且这个超类的名字必须写在任何协议之前。但是，尽管一个类只能有一个超类，它可以采用任意多个协议——这些协议会被列在超类之后，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将`addBirthdayViewController(_:didAddBirthday:)`方法添加到 BirthdaysTableViewController 中。一个合适的位置是在类的末尾，就在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动完成功能会建议你整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它期望你添加这个方法。请注意，与子类方法不同，`addBirthdayViewController(_:didAddBirthday:)`前不需要使用`override`关键字，因为没有原始方法需要被重写。

在这种方法中，你需要做两件事。首先，你需要将由添加生日视图控制器传入的生日添加到生日数组中。你可以通过使用数组的`append(_:)`方法来实现这一点 ➋。接下来，你需要刷新表格视图，以便它显示这个新的生日，你可以通过在 tableView 属性上调用`reloadData()`方法来做到这一点 ➌。当调用`reloadData()`时，表格视图的数据源方法会再次被调用，新增的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但标记类的不同部分是良好的编码风格，并且有助于保持代码整洁、易读。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单有助于你查找方法，并让你能够跳转到代码中的不同位置。要使用这个菜单，请点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 给 Add Birthday 视图控制器设置一个委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来通知 Birthdays 表视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个可选的委托属性（类型为 AddBirthdayViewControllerDelegate）来安排此事，插入以下行，紧接在 outlets 后面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托（delegate）必须是可选的，因为你不能在*Add Birthday*视图控制器创建之后才设置它。稍后你将了解如何设置委托。

现在，Add Birthday 视图控制器有了一个委托，在`saveTapped(_:)`方法中，你可以通过`addBirthdayViewController(_:didAddBirthday:)`方法将生日传递给委托。将`saveTapped(_:)`方法改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，代码在➊处通过`addBirthdayViewController(_:didAddBirthday:)`方法将其传回给委托。

太好了！你已经完成了对 Add Birthday 视图控制器的所有修改。现在它有了一个委托，可以监听生日保存的通知。运行应用程序，看看会发生什么。

嗯。。。没有太大变化。当你添加一个生日时，仍然没有看到它出现在 Birthdays 表视图控制器中。怎么回事？

#### 通过设置委托来连接这两个控制器

你还需要做最后一件事。Birthdays 表视图控制器是 AddBirthdayViewControllerDelegate，且 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，该属性保存它在保存生日时与之通信的委托。但我们从未专门将委托属性设置为 Birthdays 表视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在“生日表视图控制器”类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除包围它的 /* 和 */ 注释来取消注释该方法。

这个方法会在“生日”表视图控制器放弃其屏幕并且应用通过 storyboard segue 转到另一个视图控制器时自动调用。我们将使用此方法将“生日”表视图控制器传递给“添加生日”视图控制器，并将其自身设置为“添加生日”视图控制器的代理。在 prepare(for:sender:) 方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需三行代码，就可以将“添加生日”视图控制器的代理设置为“生日”表视图控制器。首先，你需要能够从 segue 参数中获取到 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何实现这一点。UIStoryboardSegue 有一个名为 destination 的属性，它位于这个方法中准备的 segue 的另一端，但对于这个应用来说，目标并不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到导航控制器中，这样你就可以拥有一个带有“取消”和“保存”按钮的导航栏。因此，你不应该在 segue 的另一端找到“添加生日”视图控制器，而是目标应该是一个包含“添加生日”视图控制器的 UINavigationController。➊ 这一行代码获取的是 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是一个特定类型的视图控制器，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取到“添加生日”视图控制器，它是导航控制器的 topViewController ➋。topViewController 就是当前在导航控制器中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其类型转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的一个特定子类。最后，当你获得一个 AddBirthdayViewController 时，你可以将代理设置为 self，而 self 当前是“生日”表视图控制器 ➌。

现在运行应用并添加一些生日！你在“生日”表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用然后重新运行，之前添加的生日会消失。我们仍然需要将生日保存到设备中，接下来我们会在第十二章进行这部分操作。

### 你学到了什么

在本章中，你学会了如何制作一个表视图控制器来显示生日列表。你还学会了如何在“添加生日”视图控制器中添加生日，并通过代理将生日添加到“生日”表视图控制器的生日数组中，以便显示。

在第十二章中，你将学习如何将生日保存到设备中，以便即使退出应用程序并重新启动后，它们仍然显示。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

当一个视图控制器需要从另一个视图控制器获取信息时，可以使用委托。假设你有两个视图控制器：A 和 B。第一个视图控制器 A 创建了 B，并将 B 显示在自身之上。A 知道 B 的存在，因为它创建并展示了 B，因此 A 可以将信息传递给 B。但是 B 并不知道 A 的存在——它刚刚出现，并不知道自己是从哪里来的，也不清楚自己是如何到达那里。那 B 如何和 A 沟通呢？通过委托！

![](img/Image00245.jpg)

委托是指有人将工作或任务交给其他人。一个*委托人*就像是告诉委托员工做什么的老板。当委托员工完成任务后，有时他们会将信息反馈给委托人。

Swift 中的委托模式非常类似，但不是有老板和员工，而是有委托者和委托对象。由于类 B 是被类 A 告知做什么的，因此它是委托对象。我们给类 B 一个名为 delegate 的特殊属性来告诉它它的委托对象是谁——这样，它就知道要与谁进行沟通。委托对象可以是任何拥有一组在*协议*中定义的方法的类。协议就像是两类之间的约定，告诉它们委托对象可以要求委托者做什么。它有一个方法和属性的列表，委托对象可以在委托对象上使用。

类 A 创建类 B，使自己成为类 B 的委托对象，并给类 B 分配协议中定义的任务。一旦类 B 完成了它的任务，它就会向类 A 汇报。让我们看看在我们的应用程序中是如何工作的。

生日列表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法`addBirthdayViewController(_:didAddBirthday:)`，该方法将由添加生日视图控制器用于报告。

看一下图 11-6。当用户点击添加按钮➊时，生日列表视图控制器会创建添加生日视图控制器➋，并将自己设置为添加生日视图控制器的委托对象。

![](img/Image00246.jpg)

*图 11-6：一个新生日被添加并通过委托从添加生日视图控制器传递到生日列表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为具有一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮➌时，Add Birthday 视图控制器会调用这个方法➍并将新的生日传递给它的代理——Birthdays 表格视图控制器。Birthdays 表格视图控制器接收到这个生日后，将其添加到自己的 birthdays 数组中，然后重新加载其表格视图➎，这样新添加的生日就会显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并提供 addBirthdayViewController(_:didAddBirthday:)方法，Add Birthday 视图控制器可以在每次添加生日时调用这个方法。Birthdays 表格视图控制器会实现该协议方法，这样每当使用 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器只需对其代理说：“嘿！刚刚有人添加了这个生日，”而 Birthdays 表格视图控制器会听到这个消息，并说：“哦！我会把这个添加到我的列表中并刷新显示，这样新添加的生日就会出现了。”

现在，让我们在代码中实现这一切！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，*在* AddBirthdayViewController 类上方，添加以下代码定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处定义协议，通过输入关键字 protocol 后跟协议名 AddBirthdayViewControllerDelegate。这个名字很长，但 Swift 程序员通常根据调用类命名协议，并在末尾加上 Delegate 这个词。这样，你就能通过查看协议的名字来判断是哪个类在使用该协议。既然你现在是 Swift 程序员，你应该遵循相同的命名惯例。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传递回代理类➋。请注意，你在这个函数中包括了 AddBirthdayViewController 作为参数。再一次，Swift 程序员在实现协议方法时根据惯例这样做，所以你也应该遵循这个惯例。知道是谁发送回消息并让代理能够访问该对象及其类是很有用的。

当 Add Birthday 视图控制器调用此方法时，它会将自身作为 addBirthdayViewController 参数传递。你很快就会看到这是如何实现的。需要注意的另一点是外部参数名 didAddBirthday。许多代理协议方法都包含*did*和*will*这两个词，因为它们用来描述调用类刚刚做过的或将要做的事情。

现在你已经定义了协议，接下来需要告诉 Birthdays 表格视图控制器采用此协议并使用协议中的方法。

##### 使 Birthdays 表格视图控制器符合协议

为了采用这个协议，BirthdaysTableViewController 需要将自己声明为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中，在 UITableViewController 超类之后，添加 AddBirthdayViewControllerDelegate。你只需要在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做了，一个红色的错误就会出现。这是因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了实现协议，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快就能解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是在子类化 UITableViewController 超类。一个类只能有一个超类，而且这个超类的名称必须写在任何协议之前。但尽管一个类只能有一个超类，它可以采用任意数量的协议——这些协议会在超类之后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的地方是在类的末尾，即导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它期望你添加这个方法。请注意，与子类化方法不同，添加 addBirthdayViewController(_:didAddBirthday:) 时，你不需要在前面加上 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 AddBirthdayViewController 传入的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来完成这一操作 ➋。接下来，你需要刷新表格视图，以便它显示这个新的生日项，可以通过在 tableView 属性上调用 reloadData() 方法 ➌ 来实现。当调用 reloadData() 时，表格视图的数据源方法会再次被调用，新的生日项将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这并不是必须的，但这是良好的编码风格，可以将类的不同部分进行标记，帮助保持代码的清晰和可读。注释的第一部分，MARK: -，是 Xcode 识别的一个特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录中，你可以在类的顶部使用该目录。这个下拉菜单帮助你快速找到方法，并能跳转到代码的不同部分。要使用这个菜单，请点击编辑面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，方便快速跳转到某个章节。*

##### 给添加生日视图控制器设置代理

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议来告知生日表视图控制器它已经添加了一个生日。为此，添加生日视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个可选的 AddBirthdayViewControllerDelegate 类型的代理属性来实现这一点，代码如下，插入该行在 outlets 下方：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你无法在添加生日视图控制器创建之前设置它。你将很快学到如何设置代理。

现在添加生日视图控制器有了代理，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日传递给代理。将 saveTapped(_:) 方法改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:) 将其返回给代理。

太好了！你已经完成了对添加生日视图控制器的修改。它现在有了一个代理，能够监听到生日被保存的调用。运行应用程序看看会发生什么。

嗯……似乎没有什么变化。当你添加一个生日时，仍然没有看到它出现在生日表视图控制器中。到底怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事需要做。生日表视图控制器是一个 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用于保存与其通信的代理，当生日被保存时，代理会进行相应的处理。但我们从未明确地将代理属性设置为生日表视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除它周围的 /* 和 */ 来取消注释该方法。

每当 Birthdays 表视图控制器放弃屏幕，并且应用程序通过故事板 segue 转到另一个视图控制器时，这个方法会自动被调用。我们将利用这个方法将 Birthdays 表视图控制器传递到 Add Birthday 视图控制器，以便将其设置为 Add Birthday 视图控制器的 delegate。在 prepare(for:sender:) 方法中编写以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的 delegate 为 Birthdays 表视图控制器只需要三行代码。首先，你需要能够通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 已经留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 在准备过程中有一个叫做 destination 的属性，但该应用程序的目的地并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到导航控制器中，这样就能拥有一个带有取消和保存按钮的导航栏。因此，你不会期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目的地是一个包含 Add Birthday 视图控制器的 UINavigationController。➊ 处的代码可以让你获得 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取到 Add Birthday 视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获取到 AddBirthdayViewController 时，你可以将 delegate 设置为 self，当前的 self 是 Birthdays 表视图控制器 ➌。

现在运行应用程序并添加一些生日！在 Birthdays 表视图控制器中，你看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用程序然后再运行，之前的生日就会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到的内容

在这一章中，你学会了如何创建一个表视图控制器来显示你的生日列表。你还学会了如何在 Add Birthday 视图控制器中添加生日，然后如何使用委托将生日添加到 Birthdays 表视图控制器中的生日数组中，以便它能被显示出来。

在第十二章中，你将学习如何将生日保存到设备中，以便即使退出应用程序后再次启动，生日信息依然能够显示。为了保存生日，你将使用 Core Data，我们在项目一开始时就已经设置好了 Core Data。

![](img/Image00245.jpg)

委托是指某人将任务或工作交给别人。*委托对象*就像一个老板，告诉委托接收者该做什么。当委托接收者完成任务后，有时会将信息报告给委托对象。

Swift 中的委托机制非常相似，只不过我们不再有老板和员工，而是有委托对象和委托对象接收者。由于类 B 是由类 A 告诉做什么的，所以类 B 是委托接收者。我们给类 B 一个特殊的属性，叫做 delegate，用来告诉它它的委托对象是谁——这样它就知道要与谁进行沟通。委托对象可以是任何一个实现了特定方法集的类，这些方法集在*协议*中进行了定义。协议就像是两个类之间的协议，告诉它们委托对象可以要求委托接收者做什么。它包含了委托对象可以与委托接收者一起使用的方法和属性名称列表。

类 A 创建类 B，将自己设置为类 B 的委托，并给类 B 分配协议中的任务。一旦类 B 完成任务，它会将结果报告给类 A。让我们看看这个在我们的应用程序中是如何工作的。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法由添加生日视图控制器用来反馈结果。

看一下图 11-6。当用户点击添加按钮➊时，生日表视图控制器会创建添加生日视图控制器➋，并将自身设置为添加生日视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新生日被添加，并通过委托从添加生日视图控制器传递到生日表视图控制器。*

定义了 AddBirthdayViewControllerDelegate 协议，该协议包含一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮➌时，添加生日视图控制器会调用此方法➍，并将新生日传递给它的委托，即生日表视图控制器。生日表视图控制器接收该生日，将其添加到自己的生日数组中，然后重新加载其表视图➎，以便新生日能在表中显示出来。

我们将向您展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并使用其中的方法 addBirthdayViewController(_:didAddBirthday:)，让 AddBirthdayViewController 每次向应用程序添加生日时，都能调用该方法。Birthdays table view controller 会实现该协议方法，以便每当通过 AddBirthdayViewController 添加生日时，AddBirthdayViewController 可以简单地对其委托说：“嘿！刚刚添加了一个生日。”然后，Birthdays table view controller 会收到这个消息并回应：“哦！我会把它加到我的列表中并刷新显示，以便新添加的生日能显示出来。”

现在让我们用代码来实现这个功能！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方*，添加以下代码以定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

您在 ➊ 定义协议时，通过键入关键字 protocol 后跟协议名称 AddBirthdayViewControllerDelegate 来实现。这是一个较长的名称，但 Swift 程序员通常会根据调用类的名称来命名他们的协议，并在名称末尾加上 Delegate。这样，你可以通过协议的名称来判断哪个类正在使用这个协议。既然你现在是 Swift 程序员了，就应该遵循这种命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传回委托类 ➋。注意，您在这个函数中包含了 AddBirthdayViewController 作为参数。再次提醒，Swift 程序员在实现协议方法时，通常会遵循这样的约定，因此你也应该这么做。了解是谁发送了消息，并且让委托能够访问该对象及其类，这样会非常有用。

当 AddBirthdayViewController 调用此方法时，它会将自己作为 addBirthdayViewController 参数传入。你将很快看到如何做到这一点。另一个需要注意的是外部参数名 didAddBirthday。许多委托协议方法中都包含 *did* 和 *will*，因为它们用于描述调用类已经做了什么或者将要做什么。

现在您已经定义了协议，接下来需要告诉 Birthdays table view controller 去采用这个协议并使用协议中的方法。

##### 使 Birthdays Table View Controller 遵守协议

为了遵守协议，Birthdays table view controller 需要让自己成为 AddBirthdayViewControllerDelegate。为此，您需要在类定义中，紧接着 UITableViewController 超类之后，添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后添加一个逗号，然后键入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做了，红色的错误就会出现。发生这种情况是因为 `BirthdaysTableViewController` 表示它是 `AddBirthdayViewControllerDelegate`，但它还没有实现这个协议！为了做到这一点，它需要实现 `AddBirthdayViewControllerDelegate` 协议的定义。别担心——我们很快就会修复这个问题。

这里需要注意的是，`BirthdaysTableViewController` 是从 `UITableViewController` 超类继承的。一个类只能有一个超类，且这个超类的名称必须写在任何协议之前。但是，虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议会在超类之后列出，并用逗号隔开。

现在，为了遵循 `AddBirthdayViewControllerDelegate` 协议并修复错误，我们需要向 `Birthdays TableViewController` 添加 `addBirthdayViewController(_:didAddBirthday:)` 方法。一个好地方是在类的末尾，即导航部分之后添加：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 的自动补全会建议整个方法声明。这是因为它知道这个类采用了 `AddBirthdayViewControllerDelegate` 协议，并且它期望你添加这个方法。请注意，与子类方法不同，在 `addBirthdayViewController(_:didAddBirthday:)` 前你不需要使用 `override` 关键字，因为没有原始方法需要被覆盖。

在这种方法中，你需要做两件事。首先，你需要将由**添加生日视图控制器**传入的生日添加到生日数组中。你可以通过使用数组的 `append(_:)` 方法来实现这一点 ➋。接下来，你需要刷新表格视图，以便显示这个新的生日，方法是调用 `reloadData()` 方法在 `tableView` 属性上 ➌。当调用 `reloadData()` 时，表格视图的数据源方法会再次被调用，新增的生日会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但良好的编码风格会标记出类的不同部分，它有助于保持代码的整洁和可读性。注释的第一部分，`MARK: -`，是一个 Xcode 识别的特殊关键字，用于代码注释，它将 `AddBirthdayViewControllerDelegate` 部分添加到一个下拉目录菜单中，你可以在类的顶部使用该菜单。这个下拉菜单帮助你查找方法，并让你跳转到代码中的不同位置。要使用这个菜单，点击编辑窗格顶部的 `Birthdays TableViewController`，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类具有一个内置的目录，可以快速跳转到某个部分。*

##### 为添加生日视图控制器指定代理

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知生日表格视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性来安排这件事，插入以下代码行在 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为你不能在 Add Birthday 视图控制器创建之前设置它。你很快就会学到在哪里设置委托。

现在，Add Birthday 视图控制器有了一个委托，在 saveTapped(_:)方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:)方法将一个生日传递给委托。将 saveTapped(_:)修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)方法将其传递回委托。

太棒了！你已经完成了对 Add Birthday 视图控制器的所有修改。它现在有了一个委托，会监听生日已被保存的回调。运行应用程序看看会发生什么。

嗯……没有太大变化。当你添加一个生日时，你仍然无法在生日表格视图控制器中看到它的显示。怎么回事？

#### 通过设置委托连接这两个控制器

你还需要做最后一件事。生日表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它持有与之通信的委托，当一个生日被保存时它会与委托进行交互。但是我们从未特别指定委托属性为生日表格视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个被注释掉的方法 prepare(for:sender:)。取消注释该方法，删除/*和*/包围它。

每当生日表格视图控制器放弃其屏幕，且应用通过故事板 segue 过渡到另一个视图控制器时，这个方法会被自动调用。我们将使用这个方法将生日表格视图控制器传递给 Add Birthday 视图控制器，以便它将自己设置为 Add Birthday 视图控制器的委托。在 prepare(for:sender:)方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的委托为 Birthdays 表格视图控制器需要三行代码。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 在注释中提示了如何实现这一点。UIStoryboardSegue 在准备的这个方法中有一个名为 destination 的属性，但对于这个应用而言，destination 并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到一个导航控制器中，这样就能拥有带有取消和保存按钮的导航栏。因此，你不会期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊处的代码将返回 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定子类，因此我们需要使用 as 进行类型转换，转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须进行类型转换，转为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你拥有一个 AddBirthdayViewController 时，可以将其委托设置为 self，即当前的 Birthdays 表格视图控制器 ➌。

现在运行应用并添加一些生日！你在 Birthdays 表格视图控制器中看到什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用并再次运行，之前的生日会消失。我们仍然需要将生日保存到设备，这将在第十二章中完成。

### 你学到了什么

在这一章中，你学会了如何创建一个表格视图控制器来显示生日列表。你还学会了如何在 Add Birthday 视图控制器中添加一个生日，然后如何使用委托将这个生日添加到 Birthdays 表格视图控制器中的生日数组，以便显示出来。

在第十二章中，你将学习如何将生日保存到设备中，以便即使退出应用并再次运行时，生日信息依然会显示。为了保存生日，你将使用 Core Data，这是我们在项目一开始就设置好的。

委托（Delegation）是指某人将任务或工作交给其他人来完成。*委托人*就像一个老板，告诉被委托的员工该做什么。当被委托的员工完成任务后，有时他们会将信息反馈给委托人老板。

Swift 中的委托模式非常相似，但不是由老板和员工来定义，而是由委托对象和委托方对象来定义。由于类 B 是被类 A 告诉该做什么的，因此它是委托方对象。我们给类 B 添加一个叫做 delegate 的特殊属性，用来告诉它谁是它的委托对象——这样它就知道该与谁进行通信。委托对象可以是任何符合 *协议* 中一组已定义方法的类。协议就像是两个类之间的约定，告诉它们委托对象可以让委托方对象做些什么。它包含了委托对象可以与委托方对象一起使用的方法和属性列表。

类 A 创建类 B，使自己成为类 B 的委托对象，并给类 B 赋予协议中定义的任务。一旦类 B 完成任务，它就会向类 A 报告。让我们看看这个如何在我们的应用中运作。

生日表视图控制器是视图控制器 A，添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，该方法将由添加生日视图控制器用来报告结果。

看一下 图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器创建添加生日视图控制器 ➋ 并将自己设置为该视图控制器的委托对象。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从添加生日视图控制器传递到生日表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，添加生日视图控制器调用这个方法 ➍ 并将新的生日传递给它的委托对象——生日表视图控制器。生日表视图控制器接收这个生日，将其添加到它的生日数组中，然后重新加载其表视图 ➎，使得新添加的生日能够在表中显示出来。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义 addBirthdayViewController(_:didAddBirthday:) 方法，当应用中添加生日时，添加生日视图控制器就可以调用该方法。生日表视图控制器将实现这个协议方法，这样每当通过添加生日视图控制器添加生日时，添加生日视图控制器可以简单地对它的委托对象说：“嘿！刚有人添加了这个生日，”而生日表视图控制器会收到这个消息并说：“哦！我会将它添加到我的列表中，并刷新显示，使得新的生日显示出来。”

现在，让我们在代码中实现这一点！

##### 创建一个协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类 *上方* 添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过在 ➊ 处键入关键字 protocol 并跟上协议名称 AddBirthdayViewControllerDelegate 来定义协议。这个名字很长，但 Swift 程序员通常会以调用类的名称命名他们的协议，并在结尾加上 Delegate 这个词。这样，你就能通过查看协议的名字知道是哪个类在使用这个协议。既然你现在是 Swift 程序员了，你也应该使用相同的命名规范。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传递回代理类 ➋。请注意，在这个函数中，你将 AddBirthdayViewController 作为参数传递。再次提醒，Swift 程序员在实现协议方法时通常遵循这个惯例，所以你也应该坚持这样做。了解是哪个对象发送了消息，并且让代理类能够访问该对象及其类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递。你很快就会看到这是如何实现的。另一个需要注意的是外部参数名 didAddBirthday。许多代理协议方法都包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚做完或将要做的事情。

现在，你已经定义了协议，需要告诉 Birthdays 表视图控制器采纳这个协议并使用协议中的方法。

##### 使 Birthdays 表视图控制器遵循协议

要采纳这个协议，Birthdays 表视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为了做到这一点，你需要在类定义中将 AddBirthdayViewControllerDelegate 添加到 UITableViewController 超类之后。在类的顶部，在 UITableViewController 后面加一个逗号，然后键入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色的错误就会出现。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现它，必须定义并实现 AddBirthdayViewControllerDelegate 协议。别担心——我们很快就会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是继承自 UITableViewController 超类的。一个类只能有一个超类，并且这个超类的名称必须在任何协议之前写出。但是，虽然一个类只能有一个超类，它可以采纳任意数量的协议——这些协议会在超类之后列出，并由逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并解决错误，我们需要将 addBirthdayViewController(_:didAddBirthday:) 方法添加到 Birthdays TableViewController 中。一个合适的位置是在类的末尾，紧跟在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 自动完成建议了整个方法声明。这是因为它知道这个类采纳了 `AddBirthdayViewControllerDelegate` 协议，并且它预期你会添加这个方法。注意，与子类化方法不同，你在 `addBirthdayViewController(_:didAddBirthday:)` 前不需要使用 `override` 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的 Birthday 添加到 `birthdays` 数组中。你可以通过使用数组的 `append(_:)` 方法来完成这件事 ➋。接下来，你需要刷新表格视图，以便显示这个新添加的生日，方法是调用 `tableView` 属性的 `reloadData()` 方法 ➌。当调用 `reloadData()` 时，表格视图的数据源方法将再次被调用，新的 Birthday 将会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但用来标记类的不同部分是一个良好的编码风格，它有助于保持代码的整洁和可读性。注释的第一部分，`MARK: -`，是 Xcode 识别的特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你找到方法，并让你跳转到代码的不同位置。要使用这个菜单，点击编辑窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个章节。*

##### 为 Add Birthday 视图控制器设置代理

`BirthdaysTableViewController` 已经采纳了 `AddBirthdayViewControllerDelegate` 协议。现在，轮到 Add Birthday 视图控制器使用 `AddBirthdayViewControllerDelegate` 协议来告诉 `Birthdays` 表格视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 `AddBirthdayViewController` 类中添加一个可选的代理属性，类型为 `AddBirthdayViewControllerDelegate`，来安排这一点，具体做法是在 outlets 下面插入以下一行代码：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为直到 Add Birthday 视图控制器创建完成后，你才能设置它。你将在稍后学到在哪里设置代理。

现在，Add Birthday 视图控制器已经有了一个代理，在 `saveTapped(_:)` 方法中，你可以通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将一个 Birthday 传递给代理。将 `saveTapped(_:)` 修改为如下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码中的 ➊ 通过 `addBirthdayViewController(_:didAddBirthday:)` 将其传递回代理。

很棒！你已经完成了对 Add Birthday 视图控制器的修改。它现在有一个代理，可以监听保存生日的调用。运行应用程序，看看会发生什么。

嗯……没有太大变化。当你添加一个生日时，仍然看不到它出现在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置代理连接这两个控制器

还有一件事你必须做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存着在保存生日时与之通信的代理。但我们从未特别设置代理属性为 Birthdays 表格视图控制器。因此，现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除/*和*/注释符号来取消注释该方法。

每当 Birthdays 表格视图控制器放弃其屏幕并且应用程序通过 storyboard segue 转到另一个视图控制器时，这个方法会被自动调用。我们将使用此方法将 Birthdays 表格视图控制器传递给 Add Birthday 视图控制器，以将其自身设置为 Add Birthday 视图控制器的代理。在 prepare(for:sender:) 方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的代理为 Birthdays 表格视图控制器只需要三行代码。首先，你需要能够通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个叫做 destination 的属性，它位于正在准备的 segue 另一端，但这个应用程序的目标并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到导航控制器中，以便你可以拥有带有取消和保存按钮的导航栏。因此，你不应该期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊ 处的代码获取了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是特定类型的视图控制器，我们需要使用 as 进行类型转换，转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是`navigationController`的 topViewController ➋。topViewController 就是当前在`navigationController`中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其强制转换为 AddBirthdayViewController，以指明该控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 时，可以将委托设置为 self，这里 self 指的是当前的生日表视图控制器 ➌。

现在运行应用并添加一些生日！你在生日表视图控制器中看到什么？生日！生日！生日！不过我们还没有完成。如果你退出应用程序然后重新运行它，之前添加的生日会消失。我们仍然需要将生日保存到设备中，这部分内容我们将在第十二章中完成。

### 你学到了什么

在本章中，你学会了如何制作一个表视图控制器来显示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，然后如何使用委托将生日添加到生日表视图控制器中的生日数组，以便显示出来。

在第十二章，你将学习如何将生日保存到设备中，这样即使你退出应用程序并重新运行它，生日仍然会显示。为了保存生日，你将使用 Core Data，这部分我们在项目开始时就已设置好了。

在 Swift 中，委托（Delegation）的概念非常相似，但不同的是，我们不再是老板和员工的关系，而是委托对象和被委托对象。由于类 B 是由类 A 告诉它该做什么的，所以它是被委托对象。我们给类 B 一个特殊的属性，称为委托（delegate），用来告诉它谁是它的委托——这样它就知道该与谁进行通信。委托可以是任何一个类，这个类必须实现一个*协议*中的一组方法。协议就像是两个类之间的一份协议，告诉它们委托可以请求委托对象做什么。协议中包含了一些方法和属性的名称，委托可以使用这些方法和属性与委托对象进行交互。

类 A 创建类 B，并将自己设置为类 B 的委托，然后给类 B 分配一个在协议中定义的任务。一旦类 B 完成了任务，它就会向类 A 报告。让我们看看在我们的应用中是如何实现的。

生日表视图控制器是视图控制器 A，而“添加生日”视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法，addBirthdayViewController(_:didAddBirthday:)，这个方法将由“添加生日”视图控制器使用来回报结果。

看一下图 11-6。当用户点击添加按钮 ➊ 时，生日表视图控制器会创建“添加生日”视图控制器 ➋，并将自己设置为“添加生日”视图控制器的委托。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从 Add Birthday 视图控制器传递到 Birthdays 表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为有一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，Add Birthday 视图控制器会调用此方法 ➍ 并将新添加的生日传递给它的委托，即 Birthdays 表视图控制器。Birthdays 表视图控制器接收这个生日，将其添加到它的 birthdays 数组中，然后重新加载其表视图 ➎，这样新生日就会显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并使用方法 addBirthdayViewController(_:didAddBirthday:)，每当有生日被添加到应用时，Add Birthday 视图控制器都可以调用这个方法。Birthdays 表视图控制器会实现这个协议方法，这样每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器只需对它的委托说：“嘿！有人刚刚添加了这个生日”，而 Birthdays 表视图控制器会收到这个消息并说：“哦！我会将这个生日加入到我的列表中，并刷新显示，这样新生日就会显示出来。”

那么现在让我们开始写代码吧！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，*在* AddBirthdayViewController 类上方，添加以下定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过输入关键字 protocol 后跟名称 AddBirthdayViewControllerDelegate 来定义协议 ➊。这个名字很长，但 Swift 程序员通常会根据调用类命名协议，并在末尾添加 Delegate 一词。这样你就可以通过查看协议的名字来知道是哪个类在使用这个协议。既然你现在是一个 Swift 程序员，你也应该遵循这种命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传回委托类 ➋。注意，在这个函数中，你将 AddBirthdayViewController 作为一个参数。再次强调，Swift 程序员在实现协议方法时通常会这样做，因此你也应该遵循这个约定。知道是谁发送回消息，并且让委托能够访问这个对象及其类是很有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递。你很快就会看到这是怎么做的。另一个需要注意的点是外部参数名 didAddBirthday。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用于描述调用类刚刚完成或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表视图控制器采纳这个协议并使用协议的方法。

##### 使 Birthdays Table View Controller 遵循协议

为了采纳这个协议，`BirthdaysTableViewController`需要将自己声明为`AddBirthdayViewControllerDelegate`。为此，你需要在类定义中，在`UITableViewController`超类后添加`AddBirthdayViewControllerDelegate`。在类的顶部，在`UITableViewController`后面加上一个逗号，然后输入`AddBirthdayViewControllerDelegate`：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色错误提示就会出现。这是因为`BirthdaysTableViewController`声明自己是`AddBirthdayViewControllerDelegate`，但它还没有实现这个协议！别担心——我们很快就会修复这个问题。

这里需要注意的是，`BirthdaysTableViewController`是`UITableViewController`超类的子类。一个类只能有一个超类，而且超类的名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采纳任意多个协议——这些协议都会在超类之后列出，并用逗号分隔。

现在，为了遵循`AddBirthdayViewControllerDelegate`协议并修复错误，我们需要在`Birthdays TableViewController`中添加`addBirthdayViewController(_:didAddBirthday:)`方法。一个好的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动完成功能会建议你输入整个方法声明。这是因为它知道这个类采纳了`AddBirthdayViewController Delegate`协议，并且它期望你添加这个方法。注意，与子类化方法不同，在`addBirthdayViewController(_:didAddBirthday:)`前面不需要使用`override`关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将通过添加生日视图控制器传入的生日添加到`birthdays`数组中。你可以使用数组的`append(_:)`方法来完成这一操作➋。接下来，你需要刷新表格视图，以便它能够显示这个新添加的生日，方法是调用`tableView`属性的`reloadData()`方法➌。当调用`reloadData()`时，表格视图的数据源方法会重新调用，新添加的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但在类中标记不同的部分是一个良好的编码习惯，有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的一个特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录中，你可以在类的顶部使用它。这个下拉菜单可以帮助你快速查找方法，并跳转到代码中的不同位置。要使用这个菜单，点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，方便快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器赋予一个代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来告诉 Birthdays 表格视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个可选的代理属性，类型为 AddBirthdayViewControllerDelegate，来安排这一点，方法是将以下代码插入到 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在 Add Birthday 视图控制器创建之前设置它。你很快就会了解到在哪里设置代理。

现在 Add Birthday 视图控制器有了一个代理，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日传递给代理。将 saveTapped(_:) 方法修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

生日对象创建后，➊ 处的代码使用 addBirthdayViewController(_:didAddBirthday:) 方法将它传回给代理。

太棒了！你已经完成了对 Add Birthday 视图控制器的修改。现在它有了一个代理，可以监听生日保存的调用。运行应用看看会发生什么。

嗯……变化不大。当你添加一个生日时，仍然看不到它出现在生日表格视图控制器中。怎么回事？

#### 通过设置代理连接这两个控制器

还有一件事需要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存着它在生日保存时与之通讯的代理。但我们从未明确将代理属性设置为 Birthdays 表格视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在生日表格视图控制器类的导航部分，有一个被注释掉的方法，叫做 prepare(for:sender:)。通过删除它周围的/*和*/，取消注释该方法。

每当生日表格视图控制器放弃其屏幕并且应用通过 storyboard segue 过渡到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将生日表格视图控制器传递给添加生日视图控制器，以便将其设置为添加生日视图控制器的代理。在 prepare(for:sender:)方法中写下以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的代理到生日表格视图控制器只需要三行代码。首先，你需要能够通过 segue 参数获取到 AddBirthdayViewController 对象。Xcode 在注释中留下了提示，告诉你如何做到这一点。UIStoryboardSegue 有一个属性叫做 destination，它是在此方法中准备的 segue 的另一端，但是对于这个应用来说，目标不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到一个导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。因此，你不会期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊处的代码获取到 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个具体子类，因此我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此需要将其强制转换为 AddBirthdayViewController，以指示该控制器是 UIViewController 的一个具体子类。最后，当你获得 AddBirthdayViewController 后，你可以将代理设置为 self，当前是生日表格视图控制器 ➌。

现在运行应用并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用并重新启动，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中实现。

### 你学到了什么

在这一章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学习了如何在添加生日视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表格视图控制器中的生日数组中，以便能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，以便即使退出应用程序并重新运行，它们仍然会显示。为了保存生日，你将使用我们在项目一开始时设置的 Core Data。

类 A 创建类 B，使自己成为类 B 的代理，并给类 B 分配一个在协议中定义的任务。类 B 完成任务后，会向类 A 报告。让我们来看一下在我们的应用中如何实现这个过程。

生日列表视图控制器是视图控制器 A，而添加生日视图控制器是视图控制器 B。我们将创建一个名为 AddBirthdayViewControllerDelegate 的协议，并为该协议创建一个方法 addBirthdayViewController(_:didAddBirthday:)，该方法将被添加生日视图控制器用来回报。

看看图 11-6。当用户点击添加按钮 ➊时，生日列表视图控制器创建了添加生日视图控制器 ➋并将自己设置为添加生日视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：一个新生日被添加，并通过代理从添加生日视图控制器传递到生日列表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为包含一个方法 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌时，添加生日视图控制器会调用这个方法 ➍并将新生日传递给它的代理，即生日列表视图控制器。生日列表视图控制器接收这个生日，将它添加到自己的生日数组中，然后重新加载表视图 ➎，这样新生日就会出现在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并包含一个方法 addBirthdayViewController(_:didAddBirthday:)，每当添加一个生日到应用时，添加生日视图控制器都可以调用这个方法。生日列表视图控制器将实现该协议方法，这样每当通过添加生日视图控制器添加一个生日时，添加生日视图控制器只需要对它的代理说：“嘿！有人刚刚添加了这个生日”，生日列表视图控制器就会收到消息并回应：“哦！我会把它添加到我的列表中并刷新显示，让新生日出现在界面上。”

现在让我们在代码中实现这一过程！

##### 创建一个协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，*在* AddBirthdayViewController 类的上方，添加这段定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处定义协议，通过输入关键字 protocol 后跟协议名称 AddBirthdayViewControllerDelegate 。这个名字比较长，但 Swift 程序员通常会以调用类的名称命名协议，并在后面加上 Delegate 这个词。这样，你就能通过查看协议的名称知道是哪个类在使用这个协议。既然你现在是一个 Swift 程序员，你也应该遵循相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传回代理类 ➋ 。注意，你在这个函数中包括了 AddBirthdayViewController 作为参数。再次强调，Swift 程序员在实现协议方法时通常遵循这一约定，因此你也应该遵守这一规则。知道是谁发回消息以及代理类可以访问该对象和其类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递给该方法。你很快就会看到这是如何实现的。另一个需要注意的是外部参数名称 didAddBirthday 。许多代理协议方法包含 *did* 和 *will* 这两个词，因为它们用于描述调用类已经做过的或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表格视图控制器采纳这个协议并使用协议的方法。

##### 使 Birthdays 表格视图控制器符合协议

为了采纳协议，Birthdays 表格视图控制器需要让自己成为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，在 UITableViewController 超类之后添加 AddBirthdayViewControllerDelegate。 在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate ：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色错误就会出现。这是因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate ，但它还没有实现这个协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快就会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是从 UITableViewController 超类继承的。一个类只能有一个超类，而且超类名称必须写在任何协议之前。但尽管一个类只能有一个超类，它可以采用任意多个协议——这些协议会在超类之后列出，并由逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:) 方法添加到 Birthdays TableViewController。一个好的位置是将其添加到类的末尾，就在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类采纳了 AddBirthdayViewControllerDelegate 协议，并且它期待你添加这个方法。请注意，与子类化的方法不同，你在 addBirthdayViewController(_:didAddBirthday:)方法前并不需要使用 override 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将添加的生日对象添加到 birthdays 数组中。你可以通过使用数组的 append(_:)方法来完成这一操作 ➋。接下来，你需要刷新表格视图，以便显示这个新添加的生日，方法是调用 tableView 属性的 reloadData()方法 ➌。当调用 reloadData()时，表格视图的数据源方法将再次被调用，新添加的生日将会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但在类中标记不同的部分是一种良好的编码风格，它有助于保持代码整洁和可读。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，它会将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录中。这个下拉菜单可以帮助你找到方法，并且可以让你跳转到代码中的不同位置。要使用此菜单，请点击编辑窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，方便快速跳转到某个部分。*

##### 为添加生日视图控制器设置代理

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在，是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议来告诉生日表格视图控制器它已经添加了一个生日。为此，添加生日视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中，在 outlets 下方添加一个可选的代理属性（类型为 AddBirthdayViewControllerDelegate）来实现这一点，插入以下代码：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选类型，因为直到**添加生日视图控制器**创建完成后，你才能设置代理。你很快就会学习到在何处设置代理。

现在，添加生日视图控制器已经有了代理，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将一个生日对象传递给代理。将 saveTapped(_:)方法修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，代码在➊处通过 addBirthdayViewController(_:didAddBirthday:)方法将其传递给代理。

很棒！你已经完成了对“添加生日”视图控制器的修改。现在它有一个委托，会监听生日保存的调用。运行应用程序看看会发生什么。

嗯……似乎没有太大变化。当你添加一个生日时，你仍然看不到它在“生日”表视图控制器中显示。发生了什么？

#### 通过设置委托连接两个控制器

还有最后一件事需要做。“生日”表视图控制器是一个 AddBirthdayViewControllerDelegate，而“添加生日”视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存了它与之沟通的委托，当生日被保存时。然而，我们从未特别设置过这个委托属性为“生日”表视图控制器。所以，现在是时候在这两个视图控制器之间建立通信管道了。

在“生日表视图控制器”类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除包围它的 /* 和 */，取消注释该方法。

每当“生日”表视图控制器失去屏幕显示，并且应用通过 storyboard segue 转到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将“生日”表视图控制器传递给“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的委托。在 prepare(for:sender:) 方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的委托为“生日”表视图控制器需要三行代码。首先，你需要能够通过 segue 参数访问 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你可以如何做。UIStoryboardSegue 在其另一端有一个名为 destination 的属性，它是在此方法中准备的 segue 的目标，但这个应用程序的目标并不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到一个导航控制器中，这样你就能拥有带有取消和保存按钮的导航栏。所以，你不会期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊ 这一行获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定类型，所以我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以通过 `navigationController` 的 `topViewController` 获取 `Add Birthday` 视图控制器 ➋。`topViewController` 只是当前在 `navigationController` 中显示的视图控制器，但它的属性是 `UIViewController` 类型，因此需要将其强制转换为 `AddBirthdayViewController`，以表明该控制器是 `UIViewController` 的一个特定子类。最后，当你获得 `AddBirthdayViewController` 后，你可以将代理设置为 `self`，而 `self` 当前就是 `Birthdays` 表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你会在 `Birthdays` 表格视图控制器中看到什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用并再次运行，之前的生日会消失。我们仍然需要将生日保存到设备中，具体做法将在第十二章中介绍。

### 你学到的内容

在这一章中，你学习了如何创建一个表格视图控制器来展示你的生日列表。你还学会了如何在 `Add Birthday` 视图控制器中添加一个生日，并且如何使用代理将该生日添加到 `Birthdays` 表格视图控制器中的生日数组，以便能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用并再次运行，生日也会显示出来。为了保存生日，你将使用 `Core Data`，这在我们项目的最初阶段就已经设置好了。

`Birthdays` 表格视图控制器是视图控制器 A，而 `Add Birthday` 视图控制器是视图控制器 B。我们将创建一个名为 `AddBirthdayViewControllerDelegate` 的协议，并为该协议定义一个方法，`addBirthdayViewController(_:didAddBirthday:)`，该方法将由 `Add Birthday` 视图控制器用来回传数据。

看一下图 11-6。当用户点击添加按钮 ➊ 时，`Birthdays` 表格视图控制器会创建 `Add Birthday` 视图控制器 ➋ 并将自己设置为 `Add Birthday` 视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过代理从 `Add Birthday` 视图控制器传递到 `Birthdays` 表格视图控制器。*

`AddBirthdayViewControllerDelegate` 协议定义了一个方法，`addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存 ➌ 时，`Add Birthday` 视图控制器会调用这个方法 ➍ 并将新生日传递给其代理，即 `Birthdays` 表格视图控制器。`Birthdays` 表格视图控制器接收该生日，将其添加到生日数组中，然后重新加载表格视图 ➎，这样新生日就会显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并使用方法 addBirthdayViewController(_:didAddBirthday:)，让 AddBirthday 视图控制器在每次向应用程序添加生日时调用。Birthdays 表视图控制器将实现该协议方法，这样每当 Add Birthday 视图控制器添加一个生日时，AddBirthday 视图控制器可以告诉其代理：“嘿！有人刚刚添加了这个生日”，而 Birthdays 表视图控制器会听到这个消息并回应：“哦！我会把它添加到我的列表中并刷新显示，这样新添加的生日就会显示出来。”

那么现在我们来在代码中实现这一点！

##### 创建一个协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类上方，添加这段定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你可以通过在➊处输入关键字 protocol 并跟上协议名称 AddBirthdayViewControllerDelegate 来定义协议。这个名字很长，但 Swift 程序员通常会根据调用类的名称来命名他们的协议，并在结尾加上 Delegate 这个词。这样你就能通过协议的名称看出哪个类在使用该协议。既然你现在是 Swift 程序员，应该遵循这种命名规范。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传回代理类 ➋ 。注意，你在这个函数中包含了 AddBirthdayViewController 作为参数。再次强调，Swift 程序员通常在实现协议方法时这么做，这是一个惯例，所以你也应该遵循这一做法。了解是谁发送回信息，并且让代理类能够访问该对象及其类是很有用的。

当 AddBirthday 视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传入。你很快就会看到这是如何实现的。另一个需要注意的点是外部参数名 didAddBirthday 。许多代理协议方法包含 *did* 和 *will* 这两个词，因为它们用于描述调用类刚刚做过的事情或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表视图控制器采用这个协议并使用该协议的方法。

##### 使 Birthdays 表视图控制器符合协议

要采用该协议，Birthdays 表视图控制器需要使自己成为 AddBirthdayViewControllerDelegate 。为了实现这一点，你需要在 UITableViewController 超类之后，在类定义中添加 AddBirthdayViewControllerDelegate 。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate ：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做了，一个红色错误就会出现。这是因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了解决这个问题，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心，我们很快就会解决这个问题。

这里需要特别注意的是，BirthdaysTableViewController 是子类化了 UITableViewController 父类。一个类只能有一个父类，并且这个父类名必须在任何协议之前书写。但虽然一个类只能有一个父类，它可以采用多个协议——这些协议会列在父类之后，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:)方法添加到 Birthdays TableViewController 中。一个好的位置是在类的末尾，紧接着导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动完成功能会建议整个方法声明。这是因为它知道这个类遵循了 AddBirthdayViewControllerDelegate 协议，并且它期待你添加这个方法。请注意，不像子类化方法那样，你在 addBirthdayViewController(_:didAddBirthday:)前不会使用 override 关键字，因为没有原始方法可以被重写。

在这个方法中，你需要做两件事。首先，你需要将由 AddBirthday 视图控制器传递过来的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:)方法来完成这件事 ➋。接下来，你需要刷新表格视图，以便它显示这个新添加的生日，可以通过调用 tableView 属性的 reloadData()方法来实现 ➌。当 reloadData()方法被调用时，表格视图的数据源方法会重新被调用，新添加的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分代码：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但标记类的不同部分是一种良好的编码风格，它有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的一个特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到类顶部可以使用的下拉目录菜单中。这个下拉菜单帮助你查找方法并可以跳转到代码的不同位置。要使用这个菜单，点击编辑器窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，方便快速跳转到某个部分。*

##### 为添加生日视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 AddBirthdayViewController 使用 AddBirthdayViewControllerDelegate 协议，通知 Birthdays 表视图控制器何时添加了一个生日。为此，AddBirthdayViewController 首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性，并将以下代码插入到 outlets 下方来安排这一点：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在 AddBirthdayViewController 创建之前，你无法设置它。稍后你将了解在哪里设置代理。

既然 AddBirthdayViewController 已经有了代理，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将一个生日传递给代理。将 saveTapped(_:)方法更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码➊通过 addBirthdayViewController(_:didAddBirthday:)方法将其传递回代理。

很好！你已经完成了对 AddBirthdayViewController 的修改。现在它有了一个代理，这个代理将监听生日保存的调用。运行应用程序看看会发生什么。

嗯。。。变化不大。当你添加一个生日时，你仍然看不到它出现在 Birthdays 表视图控制器中。怎么回事？

#### 通过设置代理连接这两个控制器

还有最后一件事需要做。Birthdays 表视图控制器是 AddBirthdayViewControllerDelegate，而 AddBirthdayViewController 有一个 AddBirthdayViewControllerDelegate 属性，用于保存它与之通信的代理对象，以便在生日保存时进行通信。但我们从未明确将代理属性设置为 Birthdays 表视图控制器。所以现在是时候连接这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。取消注释这个方法，删除/*和*/的包围符号。

每当 Birthdays 表视图控制器放弃其屏幕并且应用程序通过 storyboard segue 过渡到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将 Birthdays 表视图控制器传递给 AddBirthdayViewController，以便将其设置为 AddBirthdayViewController 的代理。在 prepare(for:sender:)方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需三行代码即可将 Add Birthday 视图控制器的代理设置为 Birthdays 表视图控制器。首先，你需要能够通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 在注释中提示了如何操作。UIStoryboardSegue 在该方法中准备的 segue 另一端有一个叫 destination 的属性，但这个应用程序的目的地并不是 AddBirthdayViewController 。

在第九章中，你将 Add Birthday 视图控制器嵌入到导航控制器中，以便可以有一个带有取消和保存按钮的导航栏。所以你不会期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目的地是一个 UINavigationController，它包含了 Add Birthday 视图控制器。➊ 行获取了 navigationController 。代码 segue.destination 将返回一个 UIViewController ，但由于我们的 navigationController 是一个特定类型的视图控制器，我们需要使用 as 将其类型转换为 UINavigationController 。

接下来，你可以获得 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋ 。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController ，因此必须将其类型转换为 AddBirthdayViewController ，以表明该控制器是 UIViewController 的特定子类。最后，当你获得 AddBirthdayViewController 后，你可以将代理设置为 self ，它当前是 Birthdays 表视图控制器 ➌ 。

现在运行应用程序并添加一些生日！你在 Birthdays 表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完成。如果你退出应用程序并再次运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，我们将在第十二章中进行讲解。

### 你学到了什么

在本章中，你学会了如何创建一个表视图控制器来显示你的生日列表。你还学会了如何在 Add Birthday 视图控制器中添加一个生日，然后如何使用代理将生日添加到 Birthdays 表视图控制器中的生日数组中，以便它能够显示。

在第十二章中，你将学习如何将生日保存到你的设备上，以便即使退出应用程序并重新运行，它们仍会显示。要保存生日，你将使用 Core Data，这是我们在项目开始时设置的。

看一下图 11-6。当用户点击 Add 按钮 ➊ 时，Birthdays 表视图控制器创建 Add Birthday 视图控制器 ➋ 并将自己设置为 Add Birthday 视图控制器的代理。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过代理从 Add Birthday 视图控制器传递到 Birthdays 表视图控制器。*

`AddBirthdayViewControllerDelegate` 协议被定义为包含一个方法 `addBirthdayViewController(_:didAddBirthday:)`。当用户点击保存 ➌ 时，添加生日视图控制器会调用这个方法 ➍ 并将新的生日传递给它的委托，即生日表视图控制器。生日表视图控制器接收这个生日，将其添加到生日数组中，然后重新加载表视图 ➎，以便新生日能在表格中显示。

我们将向你展示如何创建一个 `AddBirthdayViewControllerDelegate` 协议，并定义方法 `addBirthdayViewController(_:didAddBirthday:)`，当添加生日到应用时，添加生日的视图控制器可以随时调用这个方法。生日表视图控制器将实现这个协议方法，这样每当使用添加生日视图控制器添加生日时，添加生日视图控制器只需对其委托说：“嘿！有人刚刚添加了这个生日，”而生日表视图控制器会听到这个消息并说：“哦！我会把这个添加到我的列表中并刷新显示，这样新生日就会显示出来。”

现在，让我们开始编写代码吧！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 `AddBirthdayViewController` 类 *上方*，添加这段定义 `AddBirthdayViewControllerDelegate` 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过键入关键字 `protocol` 后跟协议名称 `AddBirthdayViewControllerDelegate` 来定义协议。这个名字很长，但 Swift 程序员通常会根据调用类的名称来命名他们的协议，并在最后加上 `Delegate` 这个词。这样你就可以通过协议的名称来判断哪个类在使用该协议。既然你现在是一个 Swift 程序员，应该遵循相同的命名规范。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)` 是唯一的函数，它用于将 `Birthday` 对象传递回委托类 ➋。注意，你在这个函数中包含了 `AddBirthdayViewController` 作为参数。再次强调，这是 Swift 程序员在实现协议方法时的常规做法，所以你也应该坚持这样做。知道是谁发送回的消息，并且委托类可以访问该对象及其类，是非常有用的。

当添加生日视图控制器调用此方法时，它会将自身作为 `addBirthdayViewController` 参数传递。你很快就会看到如何实现这一点。另一个需要注意的点是外部参数名 `didAddBirthday`。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用于描述调用类刚刚做完的事情或将要做的事情。

现在你已经定义了协议，接下来你需要告诉生日表视图控制器去采纳这个协议并使用协议的方法。

##### 让生日表视图控制器遵循协议

要采用该协议，Birthdays 表格视图控制器需要将自身设置为 AddBirthdayViewControllerDelegate。为此，您需要在 UITableViewController 超类后立即将 AddBirthdayViewControllerDelegate 添加到类定义中。在类的顶部，在 UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色错误就会出现。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了实现该协议，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快会解决这个问题。

在这里需要注意的是，BirthdaysTableViewController 是在子类化 UITableViewController 超类。一个类只能有一个超类，而且超类的名称必须在任何协议之前写出。但是，虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议会在超类之后列出，并用逗号分隔。

现在，为了遵守 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个好的添加位置是在类的末尾，紧跟在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当您开始输入函数名时，Xcode 自动完成功能会建议整个方法声明。这是因为它知道该类采用了 AddBirthdayViewController Delegate 协议，并期望您添加此方法。请注意，与子类化方法不同，您在 addBirthdayViewController(_:didAddBirthday:) 前不会使用 override 关键字，因为没有原始方法需要被重写。

在此方法中，您需要做两件事。首先，您需要将 Add Birthday 视图控制器传递过来的生日添加到 birthdays 数组中。您可以通过使用 append(_:) 方法来为数组添加元素 ➋。接下来，您需要刷新表格视图，以便它显示这个新添加的生日，方法是调用 tableView 属性上的 reloadData() 方法 ➌。当调用 reloadData() 时，表格视图的数据源方法将会再次被调用，新增的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一条注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但良好的编码风格会标明类的不同部分，这有助于保持代码简洁且易于阅读。注释的第一部分 `MARK: -` 是 Xcode 识别的特殊关键字，用于代码注释，它将 `AddBirthdayViewControllerDelegate` 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单可以帮助你查找方法，并让你跳转到代码中的不同位置。要使用这个菜单，请点击编辑面板顶部的 `Birthdays TableViewController`，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，方便快速跳转到某个部分。*

##### 为“添加生日”视图控制器赋予代理

`BirthdaysTableViewController` 已经采用了 `AddBirthdayViewControllerDelegate` 协议。现在是时候让“添加生日”视图控制器使用 `AddBirthdayViewControllerDelegate` 协议，告诉“生日”表视图控制器它已经添加了一个生日。为此，“添加生日”视图控制器首先需要定义一个代理。我们通过在 `AddBirthdayViewController` 类中添加一个可选的代理属性 `AddBirthdayViewControllerDelegate`，并将其插入到 outlets 下面来实现这一点。

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在“添加生日”视图控制器创建之前设置它。你很快就会学习到在哪里设置代理。

现在“添加生日”视图控制器有了代理，在 `saveTapped(_:)` 方法中，你可以使用 `addBirthdayViewController(_:didAddBirthday:)` 方法将生日传递给代理。将 `saveTapped(_:)` 修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊ 处的代码通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将其传回代理。

太棒了！你已经完成了对“添加生日”视图控制器的修改。现在它有一个代理，可以监听生日保存的事件。运行应用程序，看看会发生什么。

嗯……变化不大。当你添加一个生日时，仍然看不到它显示在“生日”表视图控制器中。怎么回事？

#### 通过设置代理连接这两个控制器

还有最后一件事要做。“生日”表视图控制器是一个 `AddBirthdayViewControllerDelegate`，而“添加生日”视图控制器有一个 `AddBirthdayViewControllerDelegate` 属性，用来保存与之通讯的代理，在生日保存时使用。但我们从未明确将代理属性设置为“生日”表视图控制器。所以现在是时候建立这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除包围它的/*和*/来取消注释这个方法。

这个方法会在每次生日表格视图控制器放弃其屏幕并通过故事板转场到另一个视图控制器时自动调用。我们将使用这个方法将生日表格视图控制器传递给添加生日视图控制器，以将其自身设置为添加生日视图控制器的代理。在 prepare(for:sender:)方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的代理为生日表格视图控制器只需要三行代码。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你可以如何做到这一点。UIStoryboardSegue 有一个叫做 destination 的属性，它代表着在这个方法中准备的转场的目标，但这个应用的目标并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到一个导航控制器中，这样你就可以有一个包含取消和保存按钮的导航栏。因此，你不期望在转场的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。在➊这一行，你获得了 navigationController。代码 segue.destination 会返回一个 UIViewController，但是由于我们的 navigationController 是 UIViewController 的一个特定类型，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 时，你可以将代理设置为 self，也就是当前的生日表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用程序然后重新运行，之前添加的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到的内容

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学习了如何在添加生日视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表格视图控制器中的生日数组中，以便显示出来。

在 第十二章 中，你将学习如何将生日保存到设备中，这样即使退出应用并重新启动，它们依然会显示出来。为了保存生日，你将使用 Core Data，这是我们在项目开始时设置的。

![](img/Image00246.jpg)

*图 11-6：一个新的生日被添加并通过委托从 Add Birthday 视图控制器传递到 Birthdays 表格视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法，addBirthdayViewController(_:didAddBirthday:)。当用户点击保存 ➌ 时，Add Birthday 视图控制器调用这个方法 ➍ 并将新的生日传递给它的委托，Birthdays 表格视图控制器。Birthdays 表格视图控制器接收这个生日，将其添加到生日数组中，然后重新加载表格视图 ➎，这样新的生日就会显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并定义方法 addBirthdayViewController(_:didAddBirthday:)，每当有生日被添加到应用中时，Add Birthday 视图控制器就可以调用这个方法。Birthdays 表格视图控制器将实现该协议方法，以便每当 Add Birthday 视图控制器添加一个生日时，Add Birthday 视图控制器只需要告诉它的委托：“嘿！有人刚刚添加了这个生日”，而 Birthdays 表格视图控制器会收到这个消息并回应：“哦！我会把它加到我的列表中，并刷新显示，以便新生日出现在表格中。”

现在，让我们来实现这段代码吧！

##### 创建协议

首先，我们需要创建协议。在 *AddBirthdayViewController.swift* 文件中，在 AddBirthdayViewController 类的 *上方*，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处定义协议，通过输入关键字 protocol，后面跟上协议名 AddBirthdayViewControllerDelegate。这个名字比较长，但 Swift 程序员通常会根据调用类命名协议，并在末尾加上 Delegate 这个词。这样你可以通过查看协议的名称知道是哪个类在使用这个协议。既然你现在是 Swift 程序员，就应该遵循相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，用来将 Birthday 对象传递回委托类 ➋。注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员在实现协议方法时会按照惯例这么做，所以你也应该坚持这样做。这样做有助于知道是谁发送回消息，并且让委托有权限访问该对象及其类。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为 `addBirthdayViewController` 参数传递。你很快就会看到这个是如何完成的。另一个需要注意的是外部参数名 `didAddBirthday`。许多代理协议方法中包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚做过的事情或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表格视图控制器采用这个协议并使用协议中的方法。

##### 让 Birthdays 表格视图控制器遵守协议

为了采用这个协议，Birthdays 表格视图控制器需要使自己成为 AddBirthdayViewControllerDelegate 。为了实现这一点，你需要在类定义中，在 UITableViewController 超类后添加 AddBirthdayViewControllerDelegate 。在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate ：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色错误会出现。这是因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现这个协议，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心，我们很快就会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，且超类名必须在任何协议之前写出。但虽然一个类只能有一个超类，它可以采纳任意多个协议——这些协议会在超类之后列出，并用逗号分隔。

现在，为了遵守 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 `addBirthdayViewController(_:didAddBirthday:)` 方法添加到 BirthdaysTableViewController 。一个合适的添加位置是类的末尾，在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 自动完成会建议整个方法声明。这是因为它知道该类采用了 AddBirthdayViewController Delegate 协议，并且它预计你会添加这个方法。请注意，不像子类化方法，你在 `addBirthdayViewController(_:didAddBirthday:)` 前不会使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现 ➋ 。接下来，你需要刷新表格视图，以便它显示这个新添加的生日，你可以通过调用 tableView 属性的 reloadData() 方法来实现 ➌ 。当调用 reloadData() 时，表格视图的数据源方法会再次被调用，新增的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但标记类的不同部分是良好的编码风格，有助于保持代码整洁和可读。注释的第一部分 MARK: - 是 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用该菜单。这个下拉菜单帮助你快速找到方法，并跳转到代码中的不同位置。要使用此菜单，点击编辑窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内建的目录，便于快速跳转到某个部分。*

##### 给 Add Birthday 视图控制器指定委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来通知 Birthdays 表格视图控制器何时添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 outlets 下方插入以下代码，向 AddBirthdayViewController 类添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在 Add Birthday 视图控制器创建之前，无法设置它。稍后你将了解在哪里设置委托。

现在 Add Birthday 视图控制器已经有了一个委托，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将生日对象传递给委托。将 saveTapped(_:) 方法修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 方法将其传回给委托。

太棒了！你已经完成了对 Add Birthday 视图控制器的所有更改。现在它有了一个委托，将监听生日保存的回调。运行应用程序看看会发生什么。

嗯……变化不大。当你添加一个生日时，你仍然看不到它出现在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置委托连接两个控制器

还有一件最后的事情需要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用于保存与之通信的委托，来通知它生日已经被保存。但我们从未明确将委托属性设置为 Birthdays 表格视图控制器。所以现在是时候连接两个视图控制器之间的通信管道了。

在 `BirthdaysTableViewController` 类的导航部分，有一个被注释掉的方法，叫做 `prepare(for:sender:)`。通过删除 /* 和 */ 来取消注释该方法。

每当 `Birthdays` 表视图控制器失去屏幕控制，并且应用程序通过 storyboard segue 转到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将 `Birthdays` 表视图控制器传递给“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的委托。在 `prepare(for:sender:)` 方法中编写如下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码就能将“添加生日”视图控制器的委托设置为 `Birthdays` 表视图控制器。首先，你需要能够从 `segue` 参数中获取到 `AddBirthdayViewController` 对象。Xcode 在注释中留下了一个提示，告诉你如何做到这一点。`UIStoryboardSegue` 在这个方法中准备的另一端有一个名为 `destination` 的属性，但对于这个应用来说，目标并不是 `AddBirthdayViewController`。

在第九章，你将“添加生日”视图控制器嵌入到导航控制器中，这样你就可以拥有带有“取消”和“保存”按钮的导航栏。所以你不会期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 `UINavigationController`。➊ 这一行会获取 `navigationController`。代码 `segue.destination` 会返回一个 `UIViewController`，但由于我们的 `navigationController` 是 `ViewController` 的特定子类，所以需要使用 `as` 进行类型转换为 `UINavigationController`。

接下来，你可以获取“添加生日”视图控制器，它是 `navigationController` 的 `topViewController` ➋。`topViewController` 只是当前在 `navigationController` 中显示的视图控制器，但它的属性是 `UIViewController` 类型，因此必须将其强制转换为 `AddBirthdayViewController`，以表明该控制器是 `UIViewController` 的一个特定子类。最后，当你得到 `AddBirthdayViewController` 后，可以将其委托设置为 `self`，即当前的 `Birthdays` 表视图控制器 ➌。

现在运行应用并添加一些生日！你在 `Birthdays` 表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用然后再重新运行，之前添加的生日会消失。我们仍然需要将生日保存到设备中，这部分内容将在第十二章中讲解。

### 你学到了什么

在本章中，你学会了如何创建一个表视图控制器来显示生日列表。你还学会了如何在“添加生日”视图控制器中添加生日，然后如何使用委托将生日添加到 `Birthdays` 表视图控制器中的 `birthdays` 数组中，以便显示。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用并重新运行，它们仍然会显示。为了保存生日，你将使用我们在项目一开始就设置的 Core Data。

*图 11-6：一个新的生日被添加并通过委托从 Add Birthday 视图控制器传递到 Birthdays 表视图控制器。*

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法，即 addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮➌时，Add Birthday 视图控制器会调用这个方法➍并将新生日传递给它的委托——Birthdays 表视图控制器。Birthdays 表视图控制器接收该生日，并将其添加到生日数组中，然后重新加载表视图➎，使新生日在表格中显示出来。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并在其中实现方法 addBirthdayViewController(_:didAddBirthday:)，该方法会在添加生日到应用时由 Add Birthday 视图控制器调用。Birthdays 表视图控制器将实现该协议方法，这样每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器只需对其委托说：“嘿！有人刚刚添加了这个生日。”然后，Birthdays 表视图控制器会接收到消息并回应：“哦！我会把它添加到我的列表中，并刷新我的显示，使新生日出现在列表中。”

现在让我们用代码实现这个功能吧！

##### 创建一个协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，*在* AddBirthdayViewController 类的上方，添加定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊定义协议，通过输入关键字 protocol 并跟上协议名 AddBirthdayViewControllerDelegate。这个名字很长，但 Swift 程序员通常根据调用类的名称来命名协议，并在末尾加上 Delegate 这个词。这样，你就能通过协议的名称知道是哪个类在使用该协议。既然你现在是 Swift 程序员，应该遵循相同的命名规范。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，用来将 Birthday 对象传递回委托类➋。请注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员在实现协议方法时基于约定这么做，所以你也应该遵循这种做法。这样做有助于知道是谁发送了消息，并且让委托能够访问该对象及其类。

当 Add Birthday 视图控制器调用此方法时，它会将自身作为 addBirthdayViewController 参数传递给你。你很快就会看到如何实现这一点。另一个需要注意的是外部参数名称 didAddBirthday。许多代理协议方法包含 *did* 和 *will*，因为它们用于描述调用类刚做完或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表格视图控制器采用这个协议并使用协议中的方法。

##### 使 Birthdays 表格视图控制器遵循协议

为了采用这个协议，Birthdays 表格视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，紧接着 UITableViewController 父类后添加 AddBirthdayViewControllerDelegate。在类的顶部，添加一个逗号，紧接着输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色错误就会出现。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！不用担心——我们很快就会修复这个问题。

需要注意的是，BirthdaysTableViewController 是一个继承自 UITableViewController 的子类。一个类只能有一个父类，且父类的名字必须写在任何协议之前。不过，虽然一个类只能有一个父类，它可以采用任意数量的协议——这些协议会在父类之后列出，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。添加此方法的好位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成功能会建议你整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且预计你会添加这个方法。需要注意的是，与子类方法不同，你在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传入的 Birthday 添加到 birthdays 数组中。你可以使用 append(_:) 方法来实现这一点 ➋。接下来，你需要刷新表格视图，以便它能显示这个新添加的生日，通过调用 tableView 属性上的 reloadData() 方法 ➌。当调用 reloadData() 时，表格视图的数据源方法会重新调用，新增的 Birthday 会显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但在类中标记不同部分是良好的编码风格，并且有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单帮助你查找方法，并让你跳转到代码中的不同位置。要使用这个菜单，请点击编辑器窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类具有内置的目录，可以快速跳转到某个部分。*

##### 为“添加生日”视图控制器指定委托

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让“添加生日”视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表视图控制器它已经添加了一个生日。为此，首先需要在 AddBirthdayViewController 中定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个可选的 AddBirthdayViewControllerDelegate 类型的委托属性来安排这一点，代码如下所示，插入到 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为直到“添加生日”视图控制器创建后，你才能设置它。稍后你会学到在哪里设置委托。

现在，“添加生日”视图控制器已经有了一个委托，在 saveTapped(_:)方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:)方法将一个生日对象传递给委托。将 saveTapped(_:)方法更改为如下所示：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，代码中的➊部分将它通过 addBirthdayViewController(_:didAddBirthday:)方法传回给委托。

太棒了！你已经完成了对“添加生日”视图控制器的修改。现在它有一个委托，用于监听生日保存的调用。运行应用看看会发生什么。

嗯...变化不大。当你添加一个生日时，还是没有看到它出现在“生日”表视图控制器中，怎么回事？

#### 通过设置委托连接两个控制器

还有最后一件事需要做。Birthdays 表视图控制器是 AddBirthdayViewControllerDelegate，而“添加生日”视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用于保存它与之通信的委托，在生日保存时进行交互。但是我们从未专门设置委托属性为“生日”表视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除 /* 和 */ 来取消注释这个方法。

当 Birthdays 表格视图控制器放弃显示并且应用程序通过 storyboard segue 转换到另一个视图控制器时，这个方法会自动调用。我们将利用这个方法将 Birthdays 表格视图控制器传递给 Add Birthday 视图控制器，并将自己设置为 Add Birthday 视图控制器的 delegate。在 prepare(for:sender:) 方法中写下如下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的 delegate 为 Birthdays 表格视图控制器只需要三行代码。首先，你需要通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 在注释中给出了提示，告诉你如何做到这一点。UIStoryboardSegue 有一个叫 destination 的属性，表示 segue 的目标视图控制器，但对于这个应用程序来说，目标视图控制器不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到一个导航控制器中，这样就可以有一个带有取消和保存按钮的导航栏。因此，你不会在 segue 的目标处找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊ 这一行代码获取了 navigationController。代码 segue.destination 返回的是一个 UIViewController，但由于我们的 navigationController 是 ViewController 的一个特定类型，因此我们需要使用 as 强制转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，所以必须将其强制转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 后，可以将其 delegate 设置为 self，当前的 self 是 Birthdays 表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你会在 Birthdays 表格视图控制器中看到什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用程序然后重新运行，之前添加的生日将会消失。我们仍然需要将生日保存到设备中，下一步我们将在第十二章 中完成。

### 你学到了什么

在这一章中，你学会了如何创建一个表格视图控制器来显示生日列表。你还学会了如何在 Add Birthday 视图控制器中添加一个生日，然后如何使用 delegate 将生日添加到 Birthdays 表格视图控制器中的 birthdays 数组，这样就可以显示它。

在第十二章中，你将学习如何将生日保存到你的设备上，这样即使退出应用程序并重新启动，它们仍然会显示。为了保存生日，你将使用 Core Data，这是我们在项目一开始就设置好的。

AddBirthdayViewControllerDelegate 协议被定义为只有一个方法：addBirthdayViewController(_:didAddBirthday:)。当用户点击保存按钮➌时，Add Birthday 视图控制器会调用这个方法➍，并将新添加的生日传递给它的代理——Birthdays 表格视图控制器。Birthdays 表格视图控制器接收这个生日，将其添加到自己的生日数组中，然后重新加载它的表格视图➎，使得新的生日能够显示在表格中。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，并使用方法 addBirthdayViewController(_:didAddBirthday:)，当应用程序添加一个生日时，Add Birthday 视图控制器就会调用这个方法。Birthdays 表格视图控制器将实现这个协议方法，这样每当通过 Add Birthday 视图控制器添加一个生日时，Add Birthday 视图控制器就可以对它的代理说：“嘿！刚有人添加了这个生日”，然后 Birthdays 表格视图控制器会收到这个消息并说：“哦！我会把它加到我的列表中，并刷新我的显示，确保新的生日显示出来。”

现在让我们在代码中实现这个功能！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类*上方*，添加这段定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过输入关键字 protocol 并紧跟协议名称 AddBirthdayViewControllerDelegate 来定义协议➊。这个名字比较长，但 Swift 程序员通常会以调用类的名称命名协议，并在结尾加上 Delegate 这个词。这样，你就可以通过查看协议的名称来知道哪个类在使用这个协议。既然你现在是 Swift 程序员，你也应该使用相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，用于将 Birthday 对象传回给代理类➋。注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员在实现协议方法时，通常都会这么做，因此你也应该坚持这样做。知道是谁发送了消息并且让代理可以访问这个对象及其类是很有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递。你很快就会看到这个是怎么做的。另一个需要注意的地方是外部参数名 didAddBirthday。许多代理协议方法包含*did*和*will*这两个词，因为它们用来描述调用类刚做完或将要做的事情。

现在你已经定义了协议，需要告诉 Birthdays 表格视图控制器采用这个协议并使用协议的方法。

##### 使 Birthdays 表格视图控制器符合协议

要采用这个协议，Birthdays 表格视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在 UITableViewController 超类之后，将 AddBirthdayViewControllerDelegate 添加到类定义中。在类的顶部，在 UITableViewController 后面添加逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，一个红色错误就会出现。出现这种情况是因为 BirthdaysTableViewController 表示它是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心，我们很快就会修复这个问题。

在这里需要特别注意的是，BirthdaysTableViewController 是子类化了 UITableViewController 超类。一个类只能有一个超类，并且超类名称必须写在任何协议之前。但尽管一个类只能有一个超类，它可以采用任意多个协议——这些协议会在超类之后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个好的位置是在类的末尾，紧接着导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成会建议你使用整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它预计你会添加这个方法。请注意，与子类化方法不同，在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将由 Add Birthday 视图控制器传入的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现 ➋。接下来，你需要刷新表格视图，以便显示这个新添加的生日，这可以通过在 tableView 属性上调用 reloadData() 方法来实现 ➌。当调用 reloadData() 时，表格视图的数据源方法将被重新调用，新的生日将会显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但将类的不同部分进行标记是一个良好的编码风格，它有助于保持代码的整洁和可读性。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到下拉目录中，你可以在类的顶部使用该菜单。这个下拉菜单帮助你查找方法并让你快速跳转到代码的不同位置。要使用此菜单，点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 给 Add Birthday 视图控制器设置委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性来安排这一步，代码如下，插入在 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在创建 Add Birthday 视图控制器之前无法设置它。你将很快学到在哪里设置委托。

现在，Add Birthday 视图控制器有了委托，在`saveTapped(_:)`方法中，你可以使用`addBirthdayViewController(_:didAddBirthday:)`方法将生日传递给委托。将`saveTapped(_:)`修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊处的代码通过`addBirthdayViewController(_:didAddBirthday:)`将其传递回委托。

很棒！你已经完成了对 Add Birthday 视图控制器的修改。它现在有了一个委托，会监听生日保存的回调。运行应用程序，看看会发生什么。

嗯。。。似乎没什么变化。当你添加一个生日时，你仍然看不到它在 Birthdays 表视图控制器中显示出来。怎么回事？

#### 通过设置委托连接两个控制器

还有一件最后的事情。Birthdays 表视图控制器是 AddBirthdayViewControllerDelegate 协议的实现者，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存与其通信的委托，当生日被保存时触发。但是我们从未明确地将委托属性设置为 Birthdays 表视图控制器。所以，现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除/*和*/注释符号来取消注释该方法。

当 Birthdays 表视图控制器放弃其屏幕并通过故事板 segue 过渡到另一个视图控制器时，这个方法会自动被调用。我们将利用这个方法将 Birthdays 表视图控制器传递到添加生日视图控制器，以便将其自身设置为添加生日视图控制器的代理。在 prepare(for:sender:)方法中写下以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码就能将添加生日视图控制器的代理设置为 Birthdays 表视图控制器。首先，你需要能够通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 在注释中提示了如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，指向正在为此方法准备的 segue 另一端，但在这个应用中，destination 并不是 AddBirthdayViewController。

在第九章，你将添加生日视图控制器嵌入到导航控制器中，以便拥有一个带有取消和保存按钮的导航栏。所以，你不应该期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊处的代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定子类，我们需要通过`as`将其强制类型转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前显示的视图控制器，但它的属性类型是 UIViewController，所以需要将其强制类型转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的特定子类。最后，当你获取到 AddBirthdayViewController 后，你可以将代理设置为 self，也就是当前的 Birthdays 表视图控制器 ➌。

现在运行应用并添加一些生日！你在 Birthdays 表视图控制器中看到了什么？生日！生日！生日！不过，我们还没完全完成。如果你退出应用再重新运行，之前添加的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学习了如何创建一个表视图控制器来显示生日列表。你还学会了如何在添加生日视图控制器中添加生日，并且如何使用代理将生日添加到 Birthdays 表视图控制器中的生日数组，以便显示。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用程序并再次运行，它们仍然会显示。为了保存生日，你将使用 Core Data，这是我们在项目开始时设置的。

我们将向你展示如何创建一个 AddBirthdayViewControllerDelegate 协议，其中包含方法 addBirthdayViewController(_:didAddBirthday:)，该方法可供 Add Birthday 视图控制器在每次添加生日时调用。Birthdays 表视图控制器将实现这个协议方法，以便每当通过 Add Birthday 视图控制器添加生日时，Add Birthday 视图控制器可以向其代理发送消息：“嘿！有人刚刚添加了这个生日。” 然后，Birthdays 表视图控制器会收到这个消息并回应：“哦！我会将它添加到我的列表中并刷新显示，以便新生日能够显示出来。”

那么现在，让我们在代码中实现这个功能吧！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift*文件中，*在*AddBirthdayViewController 类的上方，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过输入关键字 protocol 并紧接着协议名称 AddBirthdayViewControllerDelegate 来定义协议，这个名字很长，但 Swift 程序员通常会根据调用类命名他们的协议，并在结尾加上 Delegate 这个词。这样你就可以通过查看协议的名称来判断是哪个类在使用该协议。既然你现在是 Swift 程序员，你也应该遵循同样的命名惯例。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传递回代理类 ➋。注意，你在这个函数中包含了 AddBirthdayViewController 作为参数。再次强调，Swift 程序员在实现协议方法时通常按照惯例这样做，因此你也应该遵循这个做法。知道是谁发送回的消息并且代理能够访问该对象及其类是非常有用的。

当 Add Birthday 视图控制器调用此方法时，它将把自身作为 addBirthdayViewController 参数传递。你很快就会看到如何做到这一点。需要注意的另一个点是外部参数名称 didAddBirthday。许多代理协议方法包含*did*和*will*这两个词，因为它们用来描述调用类已经做了什么或者将要做什么。

现在你已经定义了协议，你需要告诉 Birthdays 表视图控制器采纳这个协议并使用该协议的方法。

##### 使 Birthdays 表视图控制器遵循协议

为了采用这个协议，Birthdays table view controller 需要使自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中，紧跟在 UITableViewController 超类后添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，就会出现一个红色错误。这是因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现它，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 超类的子类。一个类只能有一个超类，且超类名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采用任意数量的协议——这些协议会在超类之后列出，并用逗号隔开。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 BirthdaysTableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 自动完成功能建议了整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它期待你添加这个方法。请注意，不同于子类方法，你在 addBirthdayViewController(_:didAddBirthday:) 前不会使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现这一点 ➋。接下来，你需要刷新表格视图，以便它显示这个新生日，可以通过调用 tableView 属性的 reloadData() 方法 ➌ 来完成。当调用 reloadData() 时，表格视图的数据源方法会被重新调用，新的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释，用于标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但在类中标记不同部分是一个好的编码风格，它有助于保持代码简洁和可读。注释的第一部分，`MARK: -`，是 Xcode 识别的特殊关键字，用于代码注释，它将`AddBirthdayViewControllerDelegate`部分添加到一个下拉目录中，你可以在类的顶部使用这个目录菜单。这个下拉菜单可以帮助你找到方法并跳转到代码的不同位置。要使用这个菜单，请点击编辑窗格顶部的`Birthdays TableViewController`，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为添加生日视图控制器设置委托

`BirthdaysTableViewController`已经遵循了`AddBirthdayViewControllerDelegate`协议。现在是时候让添加生日视图控制器使用`AddBirthdayViewControllerDelegate`协议来通知生日表视图控制器它已添加了一个生日。为此，添加生日视图控制器首先需要定义一个委托。我们通过在`AddBirthdayViewController`类中添加一个类型为`AddBirthdayViewControllerDelegate`的可选委托属性，并在所有输出（outlets）下方插入以下代码来安排这一点：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在创建添加生日视图控制器之后才能设置它。你将很快学到在哪里设置委托。

现在，添加生日视图控制器有了一个委托，在`saveTapped(_:)`方法中，你可以使用`addBirthdayViewController(_:didAddBirthday:)`方法将一个生日传递给委托。将`saveTapped(_:)`改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码在➊位置使用`addBirthdayViewController(_:didAddBirthday:)`将其传回委托。

很好！你已经完成了对添加生日视图控制器的更改。它现在有了一个委托，能够监听到一个生日被保存的消息。运行应用程序，看看会发生什么。

嗯……似乎没有什么变化。当你添加一个生日时，你仍然看不到它出现在生日表视图控制器中。发生了什么？

#### 通过设置委托连接这两个控制器

你还需要做最后一件事。生日表视图控制器是`AddBirthdayViewControllerDelegate`，而添加生日视图控制器有一个`AddBirthdayViewControllerDelegate`属性，用于保存它与之通信的委托，当生日被保存时。可是我们从未明确设置委托属性为生日表视图控制器。所以现在是时候连接我们的两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法 prepare(for:sender:)。通过删除围绕它的/*和*/来取消注释这个方法。

每当生日表视图控制器放弃其屏幕并且应用程序通过故事板 segue 过渡到另一个视图控制器时，这个方法会自动调用。我们将使用这个方法将生日表视图控制器传递给添加生日视图控制器，并设置它自己作为添加生日视图控制器的代理。在 prepare(for:sender:)方法中写下以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的代理为生日表视图控制器只需要三行代码。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 在其准备的方法中有一个名为 destination 的属性，指向 segue 的目标视图控制器，但此应用中的目标并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到一个导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。所以你并不期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。第➊行获取的是 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是特定类型的视图控制器，我们需要将其类型转换为 UINavigationController，使用 as。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此需要将其类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获得一个 AddBirthdayViewController 时，可以将 delegate 设置为 self，而当前的 self 是生日表视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用程序再重新运行，之前的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在这一章中，你学会了如何制作一个表视图控制器来显示生日列表。你还学会了如何在添加生日视图控制器中添加生日，然后如何使用代理将生日添加到生日表视图控制器中的生日数组中，以便可以显示出来。

在第十二章，你将学习如何将生日保存到你的设备上，以便即使退出应用程序并重新运行，它们依然会显示。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

现在让我们在代码中实现这一点！

##### 创建协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift* 文件中，*在* AddBirthdayViewController 类的上方，添加定义 AddBirthdayViewControllerDelegate 协议的代码：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过输入关键字 protocol 然后输入 AddBirthdayViewControllerDelegate 的名字来定义协议。这个名字很长，但 Swift 程序员通常会按照调用类的名称命名协议，并在后面加上 Delegate 这个词。这样，你就能通过查看协议的名称知道是哪个类在使用这个协议。既然你现在是一个 Swift 程序员，应该遵循相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，用于将 Birthday 对象传递回委托类 ➋。请注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员在实现协议方法时通常会这样做，所以你也应该遵循这种约定。这有助于你知道是谁发送回了消息，并且让委托有权限访问该对象及其类。

当 AddBirthdayViewController 调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递进去。你很快就会看到这是怎么做的。另一个需要注意的是外部参数名称 didAddBirthday。许多委托协议方法都包含 *did* 和 *will* 这两个词，因为它们用于描述调用类已经做过或将要做的事情。

既然你已经定义了协议，现在你需要告诉 Birthdays 表格视图控制器去采用这个协议并使用协议的方法。

##### 使 Birthdays 表格视图控制器遵循协议

为了采用这个协议，Birthdays 表格视图控制器需要让自己成为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中，紧接着 UITableViewController 超类之后，添加 AddBirthdayViewControllerDelegate。在类的顶部，在 UITableViewController 后面加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，系统会出现一个红色错误。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但还没有实现协议！为了解决这个问题，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快就会修复这个问题。

这里需要特别注意的是，BirthdaysTableViewController 是 UITableViewController 的子类。一个类只能有一个父类，并且这个父类的名字必须写在所有协议之前。但虽然一个类只能有一个父类，它可以采用任意数量的协议——这些协议将列在父类之后，并由逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 `addBirthdayViewController(_:didAddBirthday:)` 方法添加到 Birthdays TableViewController 中。一个合适的位置是在类的末尾，紧接着导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成会建议整个方法声明。这是因为它知道这个类遵循了 AddBirthdayViewControllerDelegate 协议，并且它期待你添加这个方法。注意，与子类方法不同，在 `addBirthdayViewController(_:didAddBirthday:)` 方法前不需要使用 `override` 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的生日添加到 birthdays 数组中。你可以通过使用数组的 `append(_:)` 方法来做到这一点 ➋ 。接下来，你需要刷新表格视图，以便它显示这个新添加的生日，通过调用 `reloadData()` 方法来刷新 tableView 属性 ➌ 。当 `reloadData()` 被调用时，表格视图的数据源方法将再次被调用，新的生日会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必须的，但良好的编码风格是将类的不同部分标记出来，这有助于保持代码的清晰和可读。注释的第一部分，`MARK: -` ，是 Xcode 识别的特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单帮助你查找方法并可以让你跳转到代码的不同位置。要使用这个菜单，请点击编辑面板顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为添加生日视图控制器指定代理

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表格视图控制器它已添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个可选的代理属性，该属性类型为 AddBirthdayViewControllerDelegate，并将以下行代码插入到 outlets 下面来实现：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为在创建 Add Birthday 视图控制器之前，你无法设置代理。你很快就会学到在哪里设置代理。

既然 Add Birthday 视图控制器有了代理，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日传递给代理。将 saveTapped(_:) 方法改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 将其传递回代理。

很好！你已经完成了对 Add Birthday 视图控制器的修改。现在它有了一个代理，能够监听生日被保存的调用。运行应用看看会发生什么。

嗯……似乎变化不大。当你添加一个生日时，仍然看不到它出现在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置代理连接这两个控制器

还有一件事你需要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存着在生日保存时与之通信的代理。但是我们从未专门将代理属性设置为 Birthdays 表格视图控制器。因此，现在是时候将这两个视图控制器之间的通信管道连接起来了。

在 BirthdaysTableViewController 类的导航部分，有一个已被注释掉的方法叫做 prepare(for:sender:)。通过删除包围它的 /* 和 */ 来取消注释该方法。

当 Birthdays 表格视图控制器放弃其屏幕并且应用通过故事板 segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将 Birthdays 表格视图控制器传递给 Add Birthday 视图控制器，设置其为 Add Birthday 视图控制器的代理。在 prepare(for:sender:) 方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的代理为生日表格视图控制器需要三行代码。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 在注释中给出了提示，告诉你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，它指向正在准备的 segue 目标，但对于这个应用来说，目标并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到一个导航控制器中，这样你就可以拥有一个带有“取消”和“保存”按钮的导航栏。因此，你不应该在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊ 处的代码获取了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定类型，我们需要将其类型转换为 UINavigationController，使用 as。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表示这个控制器是 UIViewController 的一个特定子类。最后，当你得到 AddBirthdayViewController 后，可以将代理设置为 self，当前为生日表格视图控制器 ➌。

现在运行应用并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用然后再运行它，之前添加的生日会消失。我们仍然需要将生日信息保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学会了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表格视图控制器中的生日数组中，以便可以显示出来。

在第十二章中，你将学习如何将生日信息保存到你的设备中，这样即使你退出应用并重新运行，它们仍然会显示。为了保存生日信息，你将使用我们在项目开始时就设置好的 Core Data。

##### 创建一个协议

首先，我们需要创建协议。在*AddBirthdayViewController.swift* 文件中，*在* AddBirthdayViewController 类上方，添加以下代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在➊处定义了协议，通过输入关键字`protocol`，然后是协议名`AddBirthdayViewControllerDelegate`。这个名字很长，但 Swift 程序员通常会根据调用类的名字来命名协议，并在结尾加上`Delegate`。这样，你就能通过协议的名字知道哪个类在使用这个协议。既然你现在是 Swift 程序员了，你也应该遵循相同的命名惯例。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)`是唯一的函数，它用于将 Birthday 对象传递回委托类 ➋。请注意，你在这个函数中包含了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员在实现协议方法时会根据惯例这么做，因此你也应该遵循这个惯例。知道谁发送了消息并让委托访问那个对象及其类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自身作为`addBirthdayViewController`参数传递进来。很快你就会看到如何实现这一点。另一个需要注意的点是外部参数名`didAddBirthday`。许多委托协议方法包含*did*和*will*这两个词，因为它们用来描述调用类刚刚做了什么或将要做什么。

现在你已经定义了协议，接下来需要告诉`Birthdays`表格视图控制器去采用这个协议并使用协议的方法。

##### 让 Birthdays Table View Controller 遵循协议

为了采用协议，`Birthdays`表格视图控制器需要让自己成为`AddBirthdayViewControllerDelegate`。为此，你需要在类定义中将`AddBirthdayViewControllerDelegate`添加到`UITableViewController`超类之后。在类的顶部，在`UITableViewController`后加上一个逗号，然后输入`AddBirthdayViewControllerDelegate`：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做了，红色错误提示就会出现。这是因为`BirthdaysTableViewController`声明它是`AddBirthdayViewControllerDelegate`，但它还没有实现这个协议！为了解决这个问题，它需要实现`AddBirthdayViewControllerDelegate`协议的定义。别担心——我们很快就会解决这个问题。

这里需要注意的是，`BirthdaysTableViewController`正在继承`UITableViewController`超类。一个类只能有一个超类，而且超类的名字必须写在所有协议之前。但尽管一个类只能有一个超类，它可以采用任意多个协议——这些协议会在超类后列出，并由逗号分隔。

现在，为了遵循`AddBirthdayViewControllerDelegate`协议并修复错误，我们需要在`Birthdays TableViewController`中添加`addBirthdayViewController(_:didAddBirthday:)`方法。一个好的位置是在类的末尾，紧接着导航部分：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期望你添加这个方法。请注意，与子类化方法不同，你不需要在 addBirthdayViewController(_:didAddBirthday:)前使用 override 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传入的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:)方法来实现这一点➋。接下来，你需要刷新表视图，以便显示这个新添加的生日，方法是调用 tableView 属性上的 reloadData()方法➌。当调用 reloadData()时，表视图的数据源方法将会重新调用，新增的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但将类的不同部分标记出来是一种良好的编码风格，它有助于保持代码的整洁和可读性。注释的第一部分，MARK: -，是 Xcode 识别的一个特殊关键词，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单可以帮助你查找方法并跳转到代码中的不同位置。要使用此菜单，点击编辑窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器指定委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知 Birthdays 表视图控制器何时添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个可选的 AddBirthdayViewControllerDelegate 类型的委托属性来安排这一点，将以下代码行插入到 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在创建 Add Birthday 视图控制器之前，你无法设置它。你将很快学习到在哪里设置委托。

现在 Add Birthday 视图控制器有了一个委托，在 saveTapped(_:)方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:)方法将生日传递给委托。将 saveTapped(_:)修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)将其传回给委托。

太好了！你已经完成了对 Add Birthday 视图控制器的修改。它现在有了一个代理，用来监听生日保存的调用。运行应用程序，看看会发生什么。

嗯……没有太大变化。当你添加一个生日时，你仍然无法在生日表格视图控制器中看到它的显示。怎么回事？

#### 通过设置代理连接这两个控制器

还有最后一件事需要做。生日表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存着它与之通信的代理对象，当生日被保存时会进行调用。但我们从未明确地将代理属性设置为生日表格视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在生日表格视图控制器类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除包围它的/*和*/来取消注释这个方法。

每当生日表格视图控制器放弃其屏幕，应用程序通过故事板 segue 过渡到另一个视图控制器时，都会自动调用这个方法。我们将利用这个方法将生日表格视图控制器传递给 Add Birthday 视图控制器，并设置它自己为 Add Birthday 视图控制器的代理。在 prepare(for:sender:)方法中写下以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码，就能将 Add Birthday 视图控制器的代理设置为生日表格视图控制器。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 留下了一条注释，提示你如何做到这一点。UIStoryboardSegue 有一个叫做 destination 的属性，它位于这个方法中正在准备的 segue 的另一端，但对于这个应用来说，目的地并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到导航控制器中，这样你就可以拥有带有取消和保存按钮的导航栏。所以你不期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目的地是一个包含 Add Birthday 视图控制器的 UINavigationController。在➊的这一行，你获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是特定类型的视图控制器，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋ 。topViewController 就是在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，所以必须进行类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你拥有 AddBirthdayViewController 时，你可以将委托设置为 self，而此时 self 就是当前的生日表视图控制器 ➌ 。

现在运行应用程序并添加一些生日！你在生日表视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用程序然后再运行，之前的生日信息会消失。我们仍然需要将生日保存到设备中，接下来我们将在第十二章中实现这一点。

### 你学到了什么

在这一章中，你学会了如何制作一个表视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，并如何通过使用委托将生日添加到生日表视图控制器中的生日数组中，以便显示它。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用程序并再次运行，它们仍然会显示。为了保存生日信息，你将使用 Core Data，这是我们在项目开始时就设置好的。

首先，我们需要创建这个协议。在*AddBirthdayViewController.swift*文件中，在 AddBirthdayViewController 类的*上方*，添加这段代码来定义 AddBirthdayViewControllerDelegate 协议：

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过键入关键字 protocol 并跟上 AddBirthdayViewControllerDelegate 名称来定义这个协议。这个名字很长，但 Swift 程序员通常会根据调用类的名称来命名协议，并在末尾加上 Delegate 一词。这样你就可以通过协议的名字知道是哪个类在使用这个协议。既然你现在是一个 Swift 程序员，你应该遵循相同的命名规范。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传递回委托类 ➋ 。注意，你在这个函数中包含了 AddBirthdayViewController 作为参数。Swift 程序员在实现协议方法时通常会这么做，所以你也应该遵循这种做法。这对于知道谁发送了消息以及委托方能够访问该对象和它的类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递进来。你很快就会看到怎么做。另一个需要注意的点是外部参数名 didAddBirthday。许多代理协议方法包含*did*和*will*这两个词，因为它们用来描述调用类刚刚做过的或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表格视图控制器去采纳这个协议并使用协议的方法。

##### 使 Birthdays 表格视图控制器符合协议

为了采用这个协议，Birthdays 表格视图控制器需要让自己成为 AddBirthdayViewControllerDelegate。为此，你需要在类定义中紧跟 UITableViewController 父类之后添加 AddBirthdayViewControllerDelegate。你可以在类的顶部，UITableViewController 后加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色的错误就会出现。这是因为 BirthdaysTableViewController 表示它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心——我们很快就会修复这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 类的子类。一个类只能有一个父类，并且这个父类的名称必须写在任何协议之前。但是，尽管一个类只能有一个父类，它可以采用任意多个协议——这些协议会在父类之后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:)方法。一个好的添加位置是在类的末尾，就在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动完成功能会建议这个完整的方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期待你添加这个方法。注意，与子类方法不同，你在 addBirthdayViewController(_:didAddBirthday:)方法前面不需要使用 override 关键字，因为没有原始的方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将由添加生日视图控制器传递进来的生日添加到生日数组中。你可以通过使用数组的 append(_:)方法来完成这一操作 ➋。接下来，你需要刷新表格视图，以便显示这个新的生日，这通过调用 tableView 属性上的 reloadData()方法来实现 ➌。当调用 reloadData()时，表格视图的数据源方法将被重新调用，新增的生日将会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释，以标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但将类的不同部分标记出来是一个很好的编码风格，能够帮助保持代码的整洁和可读性。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单帮助你查找方法并让你快速跳转到代码中的不同位置。要使用这个菜单，请点击编辑窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个章节。*

##### 给 Add Birthday 视图控制器一个代理

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知生日表视图控制器它已经添加了一个生日。为了做到这一点，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类的外部下方插入以下代码行来安排这一点，添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在创建 Add Birthday 视图控制器之后才设置它。你很快就会学到在哪里设置代理。

现在，Add Birthday 视图控制器有了代理，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将生日传递给代理。将 saveTapped(_:)更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，代码在➊将其通过 addBirthdayViewController(_:didAddBirthday:)方法传递回代理。

太棒了！你已经完成了对 Add Birthday 视图控制器的更改。现在它有了一个代理，能够监听生日保存的调用。运行应用程序看看会发生什么。

嗯……变化不大。当你添加一个生日时，你仍然看不到它出现在生日表视图控制器中。怎么回事？

#### 通过设置代理连接这两个控制器

还有一件事你必须做。生日表视图控制器是一个 AddBirthdayViewControllerDelegate，Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存它在保存生日时与之通信的代理。但我们从未明确将代理属性设置为生日表视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个被注释掉的方法，名为`prepare(for:sender:)`。通过删除包围它的`/*`和`*/`来取消注释这个方法。

当生日表格视图控制器放弃其屏幕并且应用通过 storyboard segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将生日表格视图控制器传递给添加生日视图控制器，并将自己设置为添加生日视图控制器的委托。在`prepare(for:sender:)`方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需三行代码，就可以将添加生日视图控制器的委托设置为生日表格视图控制器。首先，你需要能够从`segue`参数中获取到`AddBirthdayViewController`对象。Xcode 在注释中留下了提示，告诉你如何做到这一点。`UIStoryboardSegue`有一个名为`destination`的属性，指向正在准备的 segue 的目标视图控制器，但这个应用的目标视图控制器并不是`AddBirthdayViewController`。

在第九章中，你将添加生日视图控制器嵌入到导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。因此，你不应该期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的`UINavigationController`。在➊这一行，你获得了`navigationController`。`segue.destination`会返回一个`UIViewController`，但是因为我们的`navigationController`是`UIViewController`的一个特定子类，所以我们需要通过`as`进行类型转换，转为`UINavigationController`。

接下来，你可以获取添加生日视图控制器，它是`navigationController`的`topViewController`➋。`topViewController`就是在`navigationController`中显示的视图控制器，但它的属性类型是`UIViewController`，所以必须将其类型转换为`AddBirthdayViewController`，以表明这是`UIViewController`的一个特定子类。最后，当你获得`AddBirthdayViewController`时，你可以将委托设置为`self`，即当前的生日表格视图控制器➌。

现在运行应用并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序然后重新运行，之前的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在这一章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学习了如何在添加生日视图控制器中添加一个生日，并通过委托将该生日添加到生日表格视图控制器中的生日数组中，以便显示出来。

在 第十二章 中，你将学习如何将生日保存到设备中，以便在退出应用并重新运行时仍然能够显示这些数据。为了保存生日，你将使用 Core Data，这是我们在项目开始时就设置好的。

*AddBirthdayViewController.swift*

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你通过在 ➊ 处输入关键字 protocol 后跟协议名称 AddBirthdayViewControllerDelegate 来定义该协议。这是一个较长的名称，但 Swift 程序员通常会以调用类的名称命名协议，并在结尾加上 Delegate 这个词。这样，你就能通过查看协议的名称来判断是哪个类在使用该协议。既然你现在是 Swift 程序员了，应该遵循相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:) 是唯一的函数，它用于将 Birthday 对象传回委托类 ➋。注意，你在这个函数中包括了 AddBirthdayViewController 作为一个参数。同样，Swift 程序员通常在实现协议方法时基于约定这么做，所以你也应该遵循这一惯例。了解谁传回了消息，并让委托能够访问该对象及其类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传入。你很快就会看到这是怎么做的。另一个需要注意的是外部参数名称 didAddBirthday。许多委托协议方法包含 *did* 和 *will* 这两个词，因为它们用来描述调用类刚刚做完或将要做的事情。

现在你已经定义了协议，你需要告诉 Birthdays 表格视图控制器采纳这个协议并使用协议的方法。

##### 让 Birthdays 表格视图控制器遵循协议

为了采用这个协议，Birthdays 表格视图控制器需要让自己成为 AddBirthdayViewControllerDelegate。为此，你需要在 UITableViewController 超类后面添加 AddBirthdayViewControllerDelegate 到类定义中。在类的顶部，在 UITableViewController 后面加上逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

当你这么做时，会出现一个红色的错误提示。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会解决这个问题。

需要特别注意的是，BirthdaysTableViewController 是子类化了 UITableViewController 超类的。一个类只能有一个超类，且超类名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采纳任意数量的协议——这些协议会在超类之后列出，并用逗号隔开。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 `addBirthdayViewController(_:didAddBirthday:)` 方法添加到 Birthdays TableViewController 中。一个好的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动完成功能会建议整个方法声明。这是因为它知道这个类遵循了 AddBirthdayViewController Delegate 协议，并且它预期你会添加这个方法。注意，与子类化方法不同，你在 `addBirthdayViewController(_:didAddBirthday:)` 方法前并不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现 ➋。接下来，你需要刷新表格视图，以便它显示这个新的生日，通过调用 tableView 属性上的 reloadData() 方法 ➌。当调用 reloadData() 时，表格视图的数据源方法会再次被调用，新增的生日将显示在生日列表的底部。

你可能注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但标记类中的不同部分是一个良好的编码习惯，有助于保持代码的整洁和可读性。注释的第一部分，MARK: -，是 Xcode 识别的一个特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录中，你可以在类的顶部使用这个目录。这个下拉菜单帮助你找到方法，并可以让你跳转到代码中的不同位置。要使用这个菜单，请点击编辑窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类内置了一个目录，可以快速跳转到某个部分。*

##### 给 Add Birthday 视图控制器指定委托

BirthdaysTableViewController 已经遵循了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来通知 Birthdays 表格视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个可选的委托属性，类型为 AddBirthdayViewControllerDelegate，来安排此事，插入以下这一行代码，位于 outlets 之后：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为你不能在 Add Birthday 视图控制器创建之前设置它。你将很快学习在哪里设置委托。

现在，Add Birthday 视图控制器有了代理，在 saveTapped(_:)方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:)方法将生日传递给代理。将 saveTapped(_:)方法更改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码在➊处通过 addBirthdayViewController(_:didAddBirthday:)将其传回代理。

太好了！你已经完成了对 Add Birthday 视图控制器的更改。现在它有了一个代理，会监听生日已保存的调用。运行应用看看发生了什么。

嗯……没什么变化。当你添加一个生日时，你仍然看不到它出现在生日表格视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事需要做。生日表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存它与之通信的代理，当生日被保存时。但是我们从未明确地将代理属性设置为生日表格视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdayTableViewController 类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除包围它的/*和*/来取消注释这个方法。

这个方法会在每次生日表格视图控制器放弃其屏幕并且应用通过 storyboard segue 过渡到另一个视图控制器时自动调用。我们将使用这个方法将生日表格视图控制器传递给 Add Birthday 视图控制器，并将其设置为 Add Birthday 视图控制器的代理。在 prepare(for:sender:)方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的代理为生日表格视图控制器只需要三行代码。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 留下了一条注释，暗示你可以通过什么方式做到这一点。一个 UIStoryboardSegue 有一个名为 destination 的属性，在这个方法中准备的 segue 的另一端就是目标，但是对于这个应用来说，目标不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到了一个导航控制器中，这样你就可以拥有带有“取消”和“保存”按钮的导航栏。因此，你不会期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊处的代码获取了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是一个特定类型的视图控制器，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的一个特定子类。最后，当你获取到 AddBirthdayViewController 时，你可以将代理设置为 self，也就是当前的 Birthdays 表格视图控制器 ➌。

现在运行应用并添加一些生日！你在 Birthdays 表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用然后再次运行，之前添加的生日将会消失。我们还需要将生日保存到设备上，接下来我们将在第十二章中进行。

### 你学到的内容

在这一章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学习了如何在添加生日视图控制器中添加生日，然后如何通过使用代理将生日添加到 Birthdays 表格视图控制器中的生日数组中，从而可以显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用并再次运行，它们仍然会显示出来。为了保存生日，你将使用我们在项目一开始时就设置好的 Core Data。

```
➊
 protocol
 AddBirthdayViewControllerDelegate {

    ➋
 func
 addBirthdayViewController(_
 addBirthdayViewController: 

           AddBirthdayViewController
 , didAddBirthday birthday: 

           Birthday
 )

  }

  class AddBirthdayViewController: UIViewController {

      --*snip*
 --

```

你在 ➊ 处定义了协议，通过键入关键字 protocol 并后跟名称 AddBirthdayViewControllerDelegate。这个名字很长，但 Swift 程序员通常会根据调用类的名称来命名协议，并在末尾加上 Delegate。这样，你就可以通过查看协议的名称来知道是哪个类在使用该协议。既然你现在是 Swift 程序员，你也应该使用相同的命名约定。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传递回代理类 ➋。请注意，在这个函数中你将 AddBirthdayViewController 作为参数传入。再说一次，Swift 程序员通常在实现协议方法时遵循这一约定，因此你也应该坚持使用这个方式。了解是谁发送回消息以及代理类可以访问该对象及其类是非常有用的。

当 Add Birthday 视图控制器调用这个方法时，它会将自己作为 addBirthdayViewController 参数传递进来。你很快就会看到如何做到这一点。需要注意的另一点是外部参数名 didAddBirthday。许多代理协议方法中包含*did*和*will*这两个词，因为它们用于描述调用类刚刚完成的操作或即将进行的操作。

现在你已经定义了协议，你需要告诉 Birthdays 表格视图控制器采用这个协议并使用协议中的方法。

##### 使 Birthdays 表格视图控制器遵守协议

要采用该协议，Birthdays 表格视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在类定义中，紧跟着 UITableViewController 父类之后添加 AddBirthdayViewControllerDelegate。 在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色错误就会出现。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会修复这个问题。

在这里需要注意的是，BirthdaysTableViewController 是从 UITableViewController 父类继承的。一个类只能有一个父类，并且这个父类的名字必须写在任何协议之前。但是，虽然一个类只能有一个父类，它可以采用任意数量的协议——这些协议会列在父类之后，并由逗号分隔。

现在，为了遵守 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays 表格视图控制器中添加 `addBirthdayViewController(_:didAddBirthday:)` 方法。一个好的位置是将其添加到类的末尾，紧接着导航部分：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动补全会建议这个完整的方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期望你添加这个方法。请注意，与子类化方法不同，你在 `addBirthdayViewController(_:didAddBirthday:)` 前不需要使用 override 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递的生日添加到 birthdays 数组中。你可以通过使用数组的 `append(_:)` 方法来实现➋。接下来，你需要刷新表格视图，以便显示这个新添加的生日，方法是调用 `reloadData()` 来刷新 tableView 属性➌。当调用 `reloadData()` 时，表格视图的数据源方法将再次被调用，新的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但为了代码风格的整洁，标记不同部分是一个好习惯，它有助于保持代码简洁易读。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录中，你可以在类的顶部使用它。这个下拉菜单帮助你快速找到方法，并跳转到代码中的不同位置。要使用此菜单，点击编辑窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为添加生日视图控制器设置委托

生日表格视图控制器已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知生日表格视图控制器它已添加了一个生日。为此，添加生日视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性来安排此事，代码如下所示，紧接着控件的声明：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为直到*添加生日视图控制器*创建之后才能设置委托。稍后你将学习如何设置委托。

现在，添加生日视图控制器已经有了一个委托，在 saveTapped(_:)方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:)方法将一个生日传递给委托。将 saveTapped(_:)方法更改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)将其传回委托。

太棒了！你已完成对添加生日视图控制器的修改。它现在有了一个委托，负责监听生日保存的调用。运行应用看看会发生什么。

嗯……似乎没有什么变化。当你添加一个生日时，仍然看不到它出现在生日表格视图控制器中。怎么回事？

#### 通过设置委托连接这两个控制器

还有最后一件事要做。生日表格视图控制器是一个 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存着与之通信的委托，当生日被保存时它会与委托沟通。但我们从未明确将委托属性设置为生日表格视图控制器。所以，现在是时候将两个视图控制器之间的通信管道连接起来了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除/*和*/，取消该方法的注释。

每当 Birthdays 表格视图控制器放弃其屏幕并通过故事板 segue 过渡到另一个视图控制器时，这个方法会被自动调用。我们将使用这个方法将 Birthdays 表格视图控制器传递到 Add Birthday 视图控制器，并将其设置为 Add Birthday 视图控制器的委托。请在 prepare(for:sender:)方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需三行代码，就能将 Add Birthday 视图控制器的委托设置为 Birthdays 表格视图控制器。首先，你需要能够通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 在注释中给出了提示，指示你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，它表示在此方法中准备的 segue 的目标，但对于本应用来说，目标并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到导航控制器中，这样你就可以拥有一个带有“取消”和“保存”按钮的导航栏。因此，你不会在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊这一行获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定子类，我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其强制转换为 AddBirthdayViewController，以表示这是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 时，可以将委托设置为 self，这时 self 是当前的 Birthdays 表格视图控制器 ➌。

现在运行应用并添加一些生日！你在 Birthdays 表格视图控制器中看到什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用再重新启动，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到的内容

在这一章中，你学会了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在 Add Birthday 视图控制器中添加生日，然后如何使用委托将生日添加到 Birthdays 表格视图控制器中的 birthdays 数组，从而使其能够显示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使退出应用并重新运行，它们也能显示出来。为了保存生日，你将使用我们在项目一开始就设置好的 Core Data。

你通过在 ➊ 处输入`protocol`关键字并跟上`AddBirthdayViewControllerDelegate`的名称来定义协议。这个名字很长，但 Swift 程序员通常会根据调用类的名称命名协议，并在结尾加上“Delegate”一词。这样你就能通过查看协议的名字知道哪个类在使用这个协议。既然你现在是 Swift 程序员，你应该遵循这种命名约定。

在这个协议中，`addBirthdayViewController(_:didAddBirthday:)`是唯一的函数，它用于将“生日”对象传回给委托类 ➋ 。请注意，你在这个函数中包含了`AddBirthdayViewController`作为一个参数。同样，Swift 程序员通常会按照惯例这样做，以实现协议方法，所以你也应该遵循这个做法。了解是谁发回了消息，并让委托能够访问这个对象及其类，这是很有用的。

当“添加生日”视图控制器调用这个方法时，它会将自己作为`addBirthdayViewController`参数传入。你很快就能看到这如何实现。另一个需要注意的点是外部参数名`didAddBirthday`。许多委托协议方法包含“*did*”和“*will*”这两个词，因为它们用来描述调用类刚刚做过的或将要做的事情。

现在你已经定义了协议，接下来需要告诉“生日”表视图控制器采用这个协议，并使用协议的方法。

##### 使生日表视图控制器遵循协议

为了采用这个协议，生日表视图控制器需要让自己成为`AddBirthdayViewControllerDelegate`。为了实现这一点，你需要在类定义中，在`UITableViewController`父类之后添加`AddBirthdayViewControllerDelegate`。在类的顶部，在`UITableViewController`后加上一个逗号，然后输入`AddBirthdayViewControllerDelegate:`。

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色的错误就会出现。这是因为`BirthdaysTableViewController`声明自己是`AddBirthdayViewControllerDelegate`，但它还没有实现这个协议！为了实现这一点，它需要实现`AddBirthdayViewControllerDelegate`协议的定义。别担心——我们很快就会解决这个问题。

这里需要注意的是，`BirthdaysTableViewController`是继承自`UITableViewController`父类的。一个类只能有一个父类，而且这个父类的名称必须写在任何协议之前。但尽管一个类只能有一个父类，它可以采用任意多个协议——这些协议会在父类之后列出，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:) 方法添加到 Birthdays TableViewController。一个好的位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议你输入整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且期望你添加这个方法。请注意，与子类方法不同，你不需要在 addBirthdayViewController(_:didAddBirthday:) 前使用 override 关键字，因为没有原始方法需要重写。

在此方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递进来的 Birthday 添加到 birthdays 数组中。你可以使用数组的 append(_:) 方法来完成这一步 ➋ 。接下来，你需要刷新表视图，使其显示这个新添加的生日，通过调用 tableView 属性的 reloadData() 方法 ➌ 。当调用 reloadData() 时，表视图的数据源方法会重新调用，新增的生日将显示在生日列表的底部。

你可能已经注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必需的，但良好的编码风格建议将类的不同部分进行标记，它有助于保持代码整洁和易读。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单可以帮助你查找方法并快速跳转到代码中的不同位置。要使用此菜单，请点击编辑面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类内置了一个目录，可以快速跳转到某个章节。*

##### 为 Add Birthday 视图控制器设置委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告知 Birthdays 表视图控制器它已添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中插入以下行来添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性，放在 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在 Add Birthday 视图控制器创建之后才能设置它。你将很快学到在哪里设置委托。

现在“添加生日”视图控制器已经有了一个委托，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将一个生日对象传递给委托。将 saveTapped(_:)修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)将其传递回委托。

太好了！你已经完成了对“添加生日”视图控制器的修改。现在它有了一个委托，用来监听生日保存的调用。运行应用程序看看会发生什么。

嗯……变化不大。当你添加生日时，你仍然看不到它出现在生日列表视图控制器中。怎么回事？

#### 通过设置委托连接两个控制器

还有最后一件事要做。生日列表视图控制器是一个 AddBirthdayViewControllerDelegate，而“添加生日”视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用于保存它在生日保存时与之通信的委托。但我们从未明确设置该委托属性为生日列表视图控制器。所以，现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。取消注释该方法，删除包围它的/*和*/。

当生日列表视图控制器放弃其屏幕并且应用程序通过故事板 segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将使用此方法将生日列表视图控制器传递给“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的委托。在 prepare(for:sender:)方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需三行代码即可将“添加生日”视图控制器的委托设置为生日列表视图控制器。首先，你需要能够通过 segue 参数访问 AddBirthdayViewController 对象。Xcode 留下了一条注释，提示你如何实现这一点。UIStoryboardSegue 有一个名为 destination 的属性，指向正在准备中的 segue 的另一端，但对于这个应用程序来说，目标并不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到了导航控制器中，这样你就可以有一个包含取消和保存按钮的导航栏。所以你并不期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊处的代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是一个特定类型的 ViewController，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取添加生日的视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你有了 AddBirthdayViewController 时，可以将 delegate 设置为 self，这时的 self 就是当前的生日表视图控制器 ➌。

现在运行应用并添加一些生日！你在生日表视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完成。如果你退出应用并重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学习了如何制作一个表视图控制器来展示你的生日列表。你还学习了如何在添加生日视图控制器中添加生日，然后如何使用代理将生日添加到生日表视图控制器中的生日数组中，以便能够显示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使退出应用并重新运行，它们依然会显示出来。为了保存生日，你将使用 Core Data，这是我们在项目一开始就设置的。

在这个协议中，addBirthdayViewController(_:didAddBirthday:)是唯一的函数，它用于将 Birthday 对象传回给代理类 ➋。请注意，你在这个函数中包括了 AddBirthdayViewController 作为一个参数。再说一次，Swift 程序员在实现协议方法时通常这样做，所以你也应该遵循这个惯例。这样做有助于知道是谁发送了消息，并且使代理能够访问该对象及其类。

当添加生日的视图控制器调用此方法时，它会将自身作为 addBirthdayViewController 参数传递。你很快就会看到这是如何实现的。另一个需要注意的是外部参数名 didAddBirthday。许多代理协议方法包含*did*和*will*这两个词，因为它们用来描述调用类刚刚做过或将要做的事情。

现在你已经定义了协议，你需要告诉生日表视图控制器去采用这个协议并使用协议的方法。

##### 使生日表视图控制器符合协议

为了采用这个协议，生日表视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为了允许这一点，你需要在类定义中添加 AddBirthdayViewControllerDelegate，紧跟在 UITableViewController 的父类之后。在类的顶部，在 UITableViewController 后加上一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，红色错误就会出现。这是因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心，我们很快会解决这个问题。

在这里需要注意的是，BirthdaysTableViewController 是子类化了 UITableViewController 父类。一个类只能有一个父类，并且父类名称必须写在任何协议之前。不过，虽然一个类只能有一个父类，但它可以采纳任意数量的协议——这些协议会列在父类之后，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 BirthdaysTableViewController 中添加 addBirthdayViewController(_:didAddBirthday:)方法。一个合适的添加位置是在类的末尾，就在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类采纳了 AddBirthdayViewController Delegate 协议，并且它预期你会添加这个方法。请注意，与子类方法不同，在 addBirthdayViewController(_:didAddBirthday:)之前不需要使用 override 关键字，因为没有原始方法需要重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传入的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:)方法来做到这一点➋。接下来，你需要刷新表视图，以便它显示这个新添加的生日，这通过调用 tableView 属性的 reloadData()方法来实现➌。当调用 reloadData()时，表视图的数据源方法会重新调用，新的 Birthday 会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但这是良好的编码风格，可以帮助你标记类的不同部分，并保持代码的简洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单可以帮助你找到方法，并让你跳转到代码中的不同位置。要使用这个菜单，请点击编辑器窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，方便快速跳转到某个部分。*

##### 为 Add Birthday View Controller 设置代理

`BirthdaysTableViewController`已经采纳了`AddBirthdayViewControllerDelegate`协议。现在是时候让`Add Birthday`视图控制器使用`AddBirthdayViewControllerDelegate`协议，告知`Birthdays`表格视图控制器它已经添加了一个生日。为了做到这一点，`Add Birthday`视图控制器首先需要定义一个代理。我们通过在`AddBirthdayViewController`类中插入以下代码行来安排此事，这行代码将一个`AddBirthdayViewControllerDelegate`类型的可选代理属性添加到`AddBirthdayViewController`类中，位置紧跟在 outlets 之后：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是一个可选类型，因为直到*在*`Add Birthday`视图控制器创建之后，你才能设置它。稍后你会学习在哪里设置代理。

现在`Add Birthday`视图控制器有了一个代理，在`saveTapped(_:)`方法中，你可以使用`addBirthdayViewController(_:didAddBirthday:)`方法将一个生日对象传递给代理。将`saveTapped(_:)`修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊处的代码通过`addBirthdayViewController(_:didAddBirthday:)`将它传回给代理。

太棒了！你已经完成了对`Add Birthday`视图控制器的修改。它现在有了一个代理，会监听生日保存的调用。运行应用看看会发生什么。

嗯……变化不大。当你添加一个生日时，仍然看不到它出现在`Birthdays`表格视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有一件事你必须做。`Birthdays`表格视图控制器是一个`AddBirthdayViewControllerDelegate`，而`Add Birthday`视图控制器有一个`AddBirthdayViewControllerDelegate`属性，用于保存与之通信的代理对象，当一个生日被保存时，它会通知这个代理。但是我们从未明确将代理属性设置为`Birthdays`表格视图控制器。因此，现在是时候连接我们两个视图控制器之间的通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个被注释掉的方法，叫做`prepare(for:sender:)`。通过删除/*和*/将这个方法取消注释。

这个方法会在每次`Birthdays`表格视图控制器退出屏幕并且应用通过故事板 segue 过渡到另一个视图控制器时自动被调用。我们将利用这个方法把`Birthdays`表格视图控制器传递给`Add Birthday`视图控制器，并设置它为`Add Birthday`视图控制器的代理。请在`prepare(for:sender:)`方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的委托为生日表格视图控制器需要三行代码。首先，你需要能够通过 segue 参数获取到 AddBirthdayViewController 对象。Xcode 在注释中提示了你可以如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，它是正在准备的 segue 的另一端，但对于这个应用程序来说，目标并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到一个导航控制器中，这样你就可以拥有带有取消和保存按钮的导航栏。所以，你不应该在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。在➊这一行，你得到了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 只是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其强制转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你拥有了 AddBirthdayViewController 后，你可以将委托设置为 self，即当前的生日表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用程序，然后再次运行它，之前添加的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学习了如何制作一个表格视图控制器来显示你的生日列表。你还学习了如何在添加生日视图控制器中添加生日，然后如何使用委托将生日添加到生日表格视图控制器中的生日数组中，以便它能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，以便即使你退出应用程序并再次运行，它们仍然会显示出来。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

当添加生日视图控制器调用这个方法时，它会将自身作为 addBirthdayViewController 参数传递。你很快就会看到如何做到这一点。另一个需要注意的事项是外部参数名称 didAddBirthday。许多委托协议方法包含*did*和*will*这两个词，因为它们用来描述调用类刚做完的事情或即将做的事情。

现在你已经定义了协议，需要告诉 Birthday 表视图控制器遵循这个协议并使用协议的方法。

##### 使生日表视图控制器遵循协议

为了遵循协议，Birthdays 表视图控制器需要使自己成为 AddBirthdayViewControllerDelegate。为此，你需要在 UITableViewController 父类后面添加 AddBirthdayViewControllerDelegate 到类定义中。在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，就会出现一个红色错误。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心，我们很快就会修复这个问题。

这里需要注意的是，BirthdaysTableViewController 是从 UITableViewController 类继承而来的。一个类只能有一个父类，并且父类的名称必须写在任何协议之前。但是，虽然一个类只能有一个父类，它可以遵循任意数量的协议——这些协议会列在父类之后，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:)方法。一个好的位置是在类的末尾，在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 的自动完成功能会建议整个方法声明。这是因为它知道这个类遵循了 AddBirthdayViewControllerDelegate 协议，并且它期望你添加这个方法。请注意，与子类化方法不同，addBirthdayViewController(_:didAddBirthday:)前面不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 AddBirthday 视图控制器传递的 Birthday 添加到 birthdays 数组中。你可以通过使用 append(_:)方法来实现这一点➋。接下来，你需要刷新表视图，使其显示这个新添加的生日，方法是调用 tableView 属性上的 reloadData()方法➌。当调用 reloadData()时，表视图的数据源方法会再次被调用，新增的 Birthday 会显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但标记类的不同部分是良好的编码风格，有助于保持代码整洁和易读。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单可以帮助你找到方法并让你跳转到代码中的不同位置。要使用这个菜单，点击编辑器面板顶部的“Birthdays TableViewController”，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 给添加生日视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议来通知生日表视图控制器它已添加了一个生日。为此，添加生日视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个可选的 AddBirthdayViewControllerDelegate 类型的代理属性来安排这件事，方法是将以下一行代码插入到 outlets 下方：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在*添加生日*视图控制器创建之前设置它。你很快就会学到在哪里设置代理。

现在添加生日视图控制器已经有了代理，在 saveTapped(_:)方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:)方法将一个生日传递给代理。将 saveTapped(_:)更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，代码在➊处使用 addBirthdayViewController(_:didAddBirthday:)将它传递回代理。

很棒！你已经完成了对添加生日视图控制器的修改。它现在有一个代理，用于监听生日保存的回调。运行应用程序看看会发生什么。

嗯……没什么变化。当你添加一个生日时，仍然看不到它显示在生日表视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一件事。生日表视图控制器是一个 AddBirthdayViewControllerDelegate，且添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存它在保存生日时与之通信的代理。但我们从未明确设置代理属性为生日表视图控制器。所以是时候连接我们两个视图控制器之间的通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个被注释掉的方法，叫做`prepare(for:sender:)`。通过删除围绕它的`/*`和`*/`，取消注释这个方法。

每当“生日”表视图控制器放弃其屏幕并且应用通过 storyboard segue 过渡到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将“生日”表视图控制器传递给“添加生日”视图控制器，以便将其设置为“添加生日”视图控制器的委托。在`prepare(for:sender:)`方法中编写如下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码就能将“添加生日”视图控制器的委托设置为“生日”表视图控制器。首先，你需要能够从 segue 参数中获取到`AddBirthdayViewController`对象。Xcode 已经在注释中提示了如何实现这一点。`UIStoryboardSegue`在这个方法中准备的 segue 另一端有一个叫做`destination`的属性，但这个应用的目标视图控制器不是`AddBirthdayViewController`。

在第九章中，你将“添加生日”视图控制器嵌入到一个导航控制器中，这样你就可以拥有带有“取消”和“保存”按钮的导航栏。所以你不会在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的`UINavigationController`。➊处的代码将返回`navigationController`。代码`segue.destination`将返回一个`UIViewController`，但是由于我们的`navigationController`是`ViewController`的一个特定类型，我们需要使用`as`将其类型转换为`UINavigationController`。

接下来，你可以获取`AddBirthdayViewController`，它是`navigationController`的`topViewController` ➋。`topViewController`就是当前在`navigationController`中显示的视图控制器，但它的属性类型是`UIViewController`，因此需要将其类型转换为`AddBirthdayViewController`，以表明这个控制器是`UIViewController`的一个特定子类。最后，当你获得`AddBirthdayViewController`时，可以将其委托设置为`self`，即当前的“生日”表视图控制器 ➌。

现在运行应用并添加一些生日！你在“生日”表视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用然后再次运行，之前添加的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在这一章，你学会了如何创建一个表视图控制器来显示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，然后如何使用委托将这个生日添加到“生日”表视图控制器中的生日数组，以便进行展示。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使退出应用程序再重新运行，它们依然会显示出来。为了保存生日，你将使用我们在项目一开始时就设置的 Core Data。

现在你已经定义了协议，你需要告诉 Birthdays 表格视图控制器采纳这个协议并使用协议的方法。

##### 让 Birthdays 表格视图控制器遵守协议

要采用这个协议，Birthdays 表格视图控制器需要将自己设为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在 UITableViewController 超类之后的类定义中添加 AddBirthdayViewControllerDelegate。 在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate ：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做了，一个红色错误就会出现。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心，我们很快就会修复这个问题。

这里需要注意的是，BirthdaysTableViewController 是从 UITableViewController 超类继承的。一个类只能有一个超类，并且该超类名称必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采纳任意多个协议——这些协议会被列在超类之后，并用逗号分隔。

现在，为了遵守 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要向 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个好的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 的自动补全会建议整个方法声明。这是因为它知道这个类遵循了 AddBirthdayViewController Delegate 协议，并且它预期你添加这个方法。请注意，不像子类方法那样，你在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递的生日添加到生日数组中。你可以使用数组的 append(_:) 方法来实现这一点 ➋。接下来，你需要刷新表格视图，以便它显示这个新的生日，方法是调用 tableView 属性上的 reloadData() 方法 ➌。当 reloadData() 被调用时，表格视图的数据源方法会再次被调用，新的生日会显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分代码：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但在类中标记不同的部分是一个良好的编码风格，它有助于保持代码的简洁和可读性。注释的第一部分，`MARK: -`，是 Xcode 识别的特殊关键字，它将 `AddBirthdayViewControllerDelegate` 部分添加到下拉式目录菜单中，你可以在类的顶部使用该菜单。这个下拉菜单帮助你查找方法并快速跳转到代码中的不同位置。要使用这个菜单，点击编辑器面板顶部的 `Birthdays TableViewController`，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内建的目录，可以快速跳转到某个部分。*

##### 给添加生日视图控制器设置委托

`BirthdaysTableViewController` 已经采用了 `AddBirthdayViewControllerDelegate` 协议。现在，是时候让添加生日视图控制器使用 `AddBirthdayViewControllerDelegate` 协议来告诉生日表视图控制器它已经添加了一个生日。为此，添加生日视图控制器首先需要定义一个委托。我们通过在 `AddBirthdayViewController` 类中插入以下代码来安排这件事，放在 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为你不能在创建添加生日视图控制器之前设置它。稍后你将学到在哪里设置委托。

现在，添加生日视图控制器已经有了一个委托，在 `saveTapped(_:)` 方法中，你可以使用 `addBirthdayViewController(_:didAddBirthday:)` 方法将生日传递给委托。将 `saveTapped(_:)` 更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊ 处的代码通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将其传递回委托。

太棒了！你已经完成了对添加生日视图控制器的修改。现在它有了一个委托，能够监听到生日被保存的调用。运行应用程序看看会发生什么。

嗯……似乎没有太大变化。当你添加一个生日时，仍然看不到它出现在生日表视图控制器中。怎么回事？

#### 通过设置委托连接这两个控制器

你还有最后一步要做。生日表视图控制器是 `AddBirthdayViewControllerDelegate`，而添加生日视图控制器有一个 `AddBirthdayViewControllerDelegate` 属性，用于保存它与之通信的委托，尤其是在生日被保存时。但我们从未明确地将委托属性设置为生日表视图控制器。所以现在是时候将这两个视图控制器之间的通信管道连接起来了。

在“生日表格视图控制器”类的导航部分，有一个已被注释掉的方法叫做 prepare(for:sender:)。通过删除/*和*/，取消注释这个方法。

当“生日”表格视图控制器放弃屏幕并且应用程序通过 storyboard segue 切换到另一个视图控制器时，这个方法会自动调用。我们将使用这个方法将“生日”表格视图控制器传递给“添加生日”视图控制器，以便将其自身设置为“添加生日”视图控制器的委托。在 prepare(for:sender:)方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的委托为“生日”表格视图控制器只需要三行代码。首先，你需要能够通过 segue 参数访问 AddBirthdayViewController 对象。Xcode 在注释中提示了你如何做到这一点。UIStoryboardSegue 有一个叫做 destination 的属性，它位于正在准备的 segue 的另一端，但此应用程序的 destination 并不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到一个导航控制器中，这样你就可以拥有带有取消和保存按钮的导航栏。所以你不会在 segue 的另一端找到“添加生日”视图控制器。相反，destination 是一个包含“添加生日”视图控制器的 UINavigationController。➊处的代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是一个特定类型的视图控制器，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此需要将其类型转换为 AddBirthdayViewController，以指示这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 时，你可以将委托设置为 self，也就是当前的“生日”表格视图控制器➌。

现在运行应用程序并添加一些生日！你在“生日”表格视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用程序，然后重新运行它，之前添加的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学习了如何制作一个表格视图控制器来显示你的生日列表。你还学习了如何在“添加生日”视图控制器中添加生日，然后如何使用委托将生日添加到“生日”表格视图控制器中的生日数组中，以便它可以被显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用并重新启动，生日依然会显示。为了保存生日，你将使用 Core Data，这是我们在项目开始时设置的。

##### 让 Birthdays Table View Controller 遵循协议

要遵循协议，Birthdays 表视图控制器需要将自己声明为 AddBirthdayViewControllerDelegate。为了实现这一点，你需要在 UITableViewController 超类后面将 AddBirthdayViewControllerDelegate 添加到类定义中。在类的顶部，在 UITableViewController 后添加一个逗号，然后输入 AddBirthdayViewControllerDelegate：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做，就会出现一个红色的错误提示。出现这个错误是因为 BirthdaysTableViewController 宣称自己是 AddBirthdayViewControllerDelegate，但它还没有实现该协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心，我们很快就会修复这个问题。

这里需要注意的是，BirthdaysTableViewController 是继承自 UITableViewController 超类的。一个类只能有一个超类，并且该超类名称必须写在任何协议之前。但是虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议会列在超类之后，并且用逗号隔开。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 Birthdays TableViewController 中添加 addBirthdayViewController(_:didAddBirthday:) 方法。一个合适的添加位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 自动补全会建议整个方法声明。这是因为它知道这个类遵循了 AddBirthdayViewController Delegate 协议，并且它期望你添加这个方法。请注意，与子类化方法不同，addBirthdayViewController(_:didAddBirthday:) 方法前不需要使用 override 关键字，因为没有原始方法可以被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传入的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来完成这一操作 ➋。接下来，你需要刷新表视图，以便它显示这个新的生日，你可以通过调用 tableView 属性上的 reloadData() 方法来做到这一点 ➌。当调用 reloadData() 时，表视图的数据源方法会再次被调用，新的生日会显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但标记类的不同部分是一个好的编码风格，它有助于保持代码的整洁和可读性。注释的第一部分 MARK: - 是 Xcode 识别的一个特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你快速找到方法，并让你跳转到代码的不同位置。要使用此菜单，请点击编辑面板顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器指定代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来通知 Birthdays 表格视图控制器何时添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中插入以下代码来安排这一点，插入位置是在 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在 *Add Birthday 视图控制器创建之后* 之前设置它。你会很快学到如何设置代理的地方。

现在 Add Birthday 视图控制器有了代理，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将一个 Birthday 传递给代理。将 saveTapped(_:) 方法改成如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 方法将它传递回代理。

太棒了！你已经完成了对 Add Birthday 视图控制器的修改。它现在有了一个代理，能够监听 Birthday 保存的调用。运行应用程序，看看会发生什么。

嗯……变化不大。当你添加一个 Birthday 时，你仍然看不到它出现在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

你还有最后一件事需要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用于保存它与之通信的代理，在生日被保存时会调用该代理。但我们从未专门设置代理属性为 Birthdays 表格视图控制器。所以现在是时候连接这两个视图控制器之间的通信管道了。

在**生日**表视图控制器类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除包围它的/*和*/来取消注释该方法。

每当**生日**表视图控制器放弃其屏幕并且应用通过故事板 segue 过渡到另一个视图控制器时，这个方法会自动调用。我们将使用这个方法将**生日**表视图控制器传递给“添加生日”视图控制器，以便将其自身设置为“添加生日”视图控制器的委托。请在 prepare(for:sender:)方法中写下以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的委托为**生日**表视图控制器只需要三行代码。首先，你需要能够从 segue 参数获取 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 在其另一端有一个 destination 属性，它是正在准备的 segue 的一部分，但此应用的 destination 不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到导航控制器中，以便可以拥有一个带有取消和保存按钮的导航栏。所以你不指望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊行代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 ViewController 的特定类型，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是导航控制器的 topViewController ➋ 。topViewController 就是在导航控制器中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表示该控制器是 UIViewController 的一个特定子类。最后，当你拥有 AddBirthdayViewController 时，可以将委托设置为 self，即当前的**生日**表视图控制器 ➌ 。

现在运行应用并添加一些生日！你在**生日**表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用然后再次运行，之前的生日会消失。我们还需要将生日保存到设备上，这将在第十二章中完成。

### 你学到了什么

在本章中，你学会了如何制作一个表视图控制器来显示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，然后如何使用委托将生日添加到**生日**表视图控制器中的生日数组，以便显示它。

在第十二章中，你将学习如何将生日保存到你的设备上，以便即使退出应用并重新运行后，它们依然显示。为了保存生日，你将使用我们在项目开始时就设置好的 Core Data。

为了采用协议，Birthdays 表视图控制器需要使其自身成为 AddBirthdayViewControllerDelegate。为此，你需要在 UITableViewController 父类后面，添加 AddBirthdayViewControllerDelegate 到类定义中。在类的顶部，在 UITableViewController 后面加上逗号，然后输入 AddBirthdayViewControllerDelegate ：

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做，红色的错误提示就会出现。这是因为 BirthdaysTableViewController 声明自己是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了实现它，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心——我们很快就会修复这个问题。

需要注意的是，BirthdaysTableViewController 是一个继承自 UITableViewController 的子类。一个类只能有一个父类，且该父类名称必须写在任何协议之前。但虽然一个类只能有一个父类，它可以采用任意数量的协议——这些协议会在父类之后列出，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:) 方法添加到 Birthdays TableViewController 中。一个好的位置是在类的末尾，紧接着导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动完成功能会建议你输入整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期待你添加这个方法。请注意，不像子类化方法那样，你在 addBirthdayViewController(_:didAddBirthday:) 前面不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来实现 ➋。接下来，你需要刷新表视图，使其显示这个新的生日，这可以通过在 tableView 属性上调用 reloadData() 方法来完成 ➌。当调用 reloadData() 时，表视图的数据源方法会再次被调用，新增的生日会显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但在类中标记不同的部分是良好的编码风格，有助于保持代码整洁、易于阅读。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键词，用于代码注释，并将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中，你可以在这个菜单中快速跳转到方法。使用这个菜单时，只需点击编辑面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某一部分。*

##### 为 Add Birthday 视图控制器指定代理

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表格视图控制器何时添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个可选的代理属性，类型为 AddBirthdayViewControllerDelegate，并在输出属性下方插入以下代码行来实现这一点：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为直到*Add Birthday*视图控制器创建之后，你才能设置它。稍后你将了解在哪里设置代理。

现在，Add Birthday 视图控制器已经有了一个代理，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将一个生日传递给代理。将 saveTapped(_:)修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)将其传递回代理。

太好了！你已经完成了对 Add Birthday 视图控制器的修改。现在它拥有一个代理，可以监听生日保存的调用。运行应用程序，看看会发生什么。

嗯……变化不大。当你添加一个生日时，仍然看不到它出现在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有一件事需要做。Birthdays 表格视图控制器是 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存着它与之通信的代理，当生日保存时会与代理进行交互。但我们从未明确地将代理属性设置为 Birthdays 表格视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在生日表格视图控制器类（BirthdaysTableViewController）的导航部分，有一个已被注释掉的方法叫做 prepare(for:sender:)，通过删除它周围的/*和*/来取消注释该方法。

每当生日表格视图控制器放弃其屏幕并且应用通过故事板 segue 过渡到另一个视图控制器时，这个方法会自动调用。我们将使用这个方法将生日表格视图控制器传递给添加生日视图控制器，并将其设置为添加生日视图控制器的代理。在 prepare(for:sender:)方法中写下以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

需要三行代码才能将添加生日视图控制器的代理设置为生日表格视图控制器。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 在注释中给出了一个提示，指示你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，指向在此方法中正在准备的 segue 的另一端，但对于这个应用程序，目标并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到导航控制器中，以便你可以拥有一个包含取消（Cancel）和保存（Save）按钮的导航栏。因此，你不期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。在➊的那一行代码中，你获得了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是一个特定类型的视图控制器，因此我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取到添加生日视图控制器（Add Birthday view controller），它是导航控制器（navigationController）中的 topViewController ➋。topViewController 就是当前显示在导航控制器中的视图控制器，但它的属性类型是 UIViewController，因此必须将其强制转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你有了 AddBirthdayViewController 后，你可以将代理（delegate）设置为 self，self 当前是生日表格视图控制器（Birthdays table view controller）➌。

现在运行应用并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序，然后再次运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，具体操作将在第十二章中完成。

### 你学到了什么

在这一章中，你学会了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，然后如何使用代理将这个生日添加到生日表格视图控制器中的生日数组中，从而能够显示它。

在第十二章中，你将学习如何将生日保存到设备上，这样即使你退出应用程序并重新运行它，生日信息依然会显示出来。为了保存生日信息，你将使用我们在项目开始时就设置好的 Core Data。

*BirthdaysTableViewController.swift*

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这么做了，一个红色的错误就会出现。这是因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！别担心——我们很快就会修复这个问题。

在这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 类的子类。一个类只能有一个父类，并且该父类名称必须在任何协议之前写出。但虽然一个类只能有一个父类，它可以采纳任意数量的协议——这些协议将会列在父类之后，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在 BirthdaysTableViewController 中添加 addBirthdayViewController(_:didAddBirthday:)方法。一个合适的添加位置是类的末尾，紧接着导航部分：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动完成功能会建议你整个方法声明。这是因为它知道这个类采纳了 AddBirthdayViewControllerDelegate 协议，并且它期望你添加这个方法。需要注意的是，不像在子类化的方法中，你不需要在 addBirthdayViewController(_:didAddBirthday:)方法前使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 AddBirthday 视图控制器传入的 Birthday 添加到 birthdays 数组中。你可以通过使用数组的 append(_:)方法来做到这一点➋。接下来，你需要刷新表格视图，确保显示这个新添加的生日信息，方法是调用 tableView 属性的 reloadData()方法➌。当 reloadData()被调用时，表格视图的数据源方法将再次被调用，新添加的 Birthday 会显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必须的，但在类中标记不同的部分是一个好的编码习惯，有助于保持代码的整洁和可读性。注释的第一部分，MARK: -，是 Xcode 识别的一个特殊关键字，用于代码注释，它会将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用这个菜单。这个下拉菜单帮助你快速查找方法，并让你跳转到代码的不同位置。要使用这个菜单，点击编辑器面板顶部的 BirthdaysTableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个部分。*

##### 给 Add Birthday 视图控制器设置代理

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表格视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性来安排此事，插入以下代码行，在 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你无法在 Add Birthday 视图控制器创建之前设置它。稍后你将学习如何设置代理。

现在 Add Birthday 视图控制器有了代理，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将一个生日传递给代理。将 saveTapped(_:) 方法更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 将其返回给代理。

很棒！你已经完成了对 Add Birthday 视图控制器的更改。现在它有了一个代理，可以监听生日已保存的调用。运行应用程序看看会发生什么。

嗯。。。似乎变化不大。当你添加生日时，依然看不见它出现在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

还有一件事你需要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存它与之通信的代理对象，当生日被保存时。然而，我们从未明确地将代理属性设置为 Birthdays 表格视图控制器。所以现在是时候连接这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法 prepare(for:sender:) 。通过删除它周围的 /* 和 */ 来取消注释该方法。

当 Birthdays 表格视图控制器放弃其屏幕，并且应用程序通过 storyboard segue 转到另一个视图控制器时，此方法会自动调用。我们将使用此方法将 Birthdays 表格视图控制器传递给 Add Birthday 视图控制器，并将其设置为 Add Birthday 视图控制器的代理。在 prepare(for:sender:) 方法中写下以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码就可以将添加生日视图控制器的代理设置为生日表格视图控制器。首先，你需要能够通过 segue 参数获取到 AddBirthdayViewController 对象。Xcode 在注释中给出了一些提示，告诉你如何做。UIStoryboardSegue 有一个名为 destination 的属性，它位于正在准备的 segue 的另一端，但对于这个应用程序，destination 并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到一个导航控制器中，这样你就可以有一个带有“取消”和“保存”按钮的导航栏。所以你不会期望在 segue 的另一端找到添加生日视图控制器。相反，destination 是一个包含添加生日视图控制器的 UINavigationController。➊行代码让你获取到 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定类型，我们需要使用 as 进行类型转换。

接下来，你可以获取到添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表示这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 时，你可以将代理设置为 self，也就是当前的生日表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序然后重新运行，之前的生日将消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学习了如何在添加生日视图控制器中添加生日，然后如何使用代理将生日添加到生日表格视图控制器中的生日数组中，以便它可以显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用程序并再次运行，它们也会显示出来。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

```
class BirthdaysTableViewController: UITableViewController
 , 

    AddBirthdayViewControllerDelegate
 {

```

一旦你这样做了，一个红色的错误就会出现。这是因为 BirthdaysTableViewController 声明它是一个 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议定义。别担心，我们很快就会解决这个问题。

这里需要注意的是，BirthdaysTableViewController 是 UITableViewController 类的子类。一个类只能有一个父类，并且该父类的名称必须写在任何协议之前。但虽然一个类只能有一个父类，它可以采纳任意多个协议——这些协议会列在父类之后，并用逗号分隔。

现在，为了符合 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 `addBirthdayViewController(_:didAddBirthday:)` 方法添加到 Birthdays TableViewController。一个合适的位置是在类的末尾，导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当您开始输入方法名时，Xcode 自动补全会建议这个完整的方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期待您添加这个方法。请注意，与子类方法不同，您在 `addBirthdayViewController(_:didAddBirthday:)` 前不需要使用 `override` 关键字，因为没有原始方法需要重写。

在这个方法中，您需要做两件事。首先，您需要将 Add Birthday 视图控制器传递过来的生日添加到 birthdays 数组中。您可以通过使用数组的 `append(_:)` 方法来做到这一点 ➋。接下来，您需要刷新表格视图，以便它显示这个新添加的生日，这可以通过在 `tableView` 属性上调用 `reloadData()` 方法来实现 ➌。当调用 `reloadData()` 时，表格视图的数据源方法将会再次被调用，新增的生日会显示在生日列表的底部。

您可能已经注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这并不是必需的，但良好的编码风格是将类的不同部分进行标记，这有助于保持代码整洁易读。注释的第一部分，`MARK: -`，是 Xcode 识别的一个特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中，您可以使用该菜单快速导航到类中的不同位置。要使用这个菜单，请点击编辑窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：您的类有一个内置的目录，可以快速跳转到某个部分。*

##### 给 Add Birthday View Controller 设置代理

*BirthdaysTableViewController*已经遵循了*AddBirthdayViewControllerDelegate*协议。现在是时候让*Add Birthday*视图控制器使用*AddBirthdayViewControllerDelegate*协议，告诉*Birthdays*表视图控制器它何时添加了一个生日。为此，*Add Birthday*视图控制器首先需要定义一个委托。我们通过在*AddBirthdayViewController*类中添加一个可选的委托属性，该属性的类型是*AddBirthdayViewControllerDelegate*，来安排此事，方法是将以下代码插入到 outlets 下方：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为在*Add Birthday*视图控制器创建之前，你无法设置它。你很快就会学到在哪里设置委托。

现在*Add Birthday*视图控制器有了委托，在`saveTapped(_:)`方法中，你可以通过`addBirthdayViewController(_:didAddBirthday:)`方法将一个生日传递给委托。将`saveTapped(_:)`方法改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象后，➊处的代码通过`addBirthdayViewController(_:didAddBirthday:)`将其传递回委托。

太好了！你已经完成了对*Add Birthday*视图控制器的更改。它现在有了一个委托，能够监听生日已保存的回调。运行应用程序看看会发生什么。

嗯……似乎没有太大变化。当你添加一个生日时，你仍然没有看到它出现在*Birthdays*表视图控制器中。怎么回事？

#### 通过设置委托连接这两个控制器

还有一件事你必须做。*Birthdays*表视图控制器是一个*AddBirthdayViewControllerDelegate*，而*Add Birthday*视图控制器有一个*AddBirthdayViewControllerDelegate*属性，它保存与之沟通的委托，在保存生日时进行交互。但是我们从未明确地将委托属性设置为*Birthdays*表视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在*BirthdaysTableViewController*类的导航部分，有一个被注释掉的方法`prepare(for:sender:)`。请通过删除`/*`和`*/`来取消注释该方法。

每当*Birthdays*表视图控制器放弃屏幕，并且应用程序通过故事板 segue 过渡到另一个视图控制器时，此方法会自动调用。我们将使用此方法将*Birthdays*表视图控制器传递给*Add Birthday*视图控制器，以便它将自己设置为*Add Birthday*视图控制器的委托。请在`prepare(for:sender:)`方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的委托为生日表格视图控制器只需要三行代码。首先，您需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 已经在注释中提示了如何做到这一点。UIStoryboardSegue 有一个叫做 destination 的属性，在这个方法中正在准备的 segue 的另一端，但对于这个应用来说，目标并不是 AddBirthdayViewController。

在第九章中，您将添加生日视图控制器嵌入到导航控制器中，这样您就可以拥有一个带有取消和保存按钮的导航栏。因此，您不会在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。在➊这一行，您获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定子类，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，您可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 只是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，所以必须将其类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当您获得 AddBirthdayViewController 时，您可以将委托设置为 self，即当前的生日表格视图控制器 ➌。

现在运行应用并添加一些生日！在生日表格视图控制器中看到什么？生日！生日！生日！不过，我们还没有完全完成。如果您退出应用并重新运行，它之前的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中进行。

### 您学到了什么

在本章中，您学习了如何制作一个表格视图控制器来显示生日列表。您还学习了如何在添加生日视图控制器中添加生日，并通过委托将生日添加到生日表格视图控制器中的生日数组中，以便显示出来。

在第十二章中，您将学习如何将生日保存到设备中，这样即使您退出应用并重新启动，它们仍然会显示出来。为了保存生日，您将使用 Core Data，这在我们项目的开始时已经设置好了。

一旦您这样做，就会出现一个红色错误。这是因为 BirthdaysTableViewController 声明它是 AddBirthdayViewControllerDelegate，但它还没有实现这个协议！为了做到这一点，它需要实现 AddBirthdayViewControllerDelegate 协议的定义。别担心，我们很快会解决这个问题。

需要注意的是，BirthdaysTableViewController 是继承自 UITableViewController 超类的。一个类只能有一个超类，且超类名必须写在任何协议之前。但虽然一个类只能有一个超类，它可以采用任意多个协议——这些协议将会列在超类之后，并用逗号分隔。

现在，为了遵循 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:) 方法添加到 Birthdays TableViewController 中。添加它的一个好地方是在类的末尾，紧接着导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当您开始输入函数名时，Xcode 的自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期待您添加这个方法。请注意，与子类化方法不同，您在 addBirthdayViewController(_:didAddBirthday:) 方法前不会使用 override 关键字，因为没有原始方法需要重写。

在此方法中，您需要做两件事。首先，您需要将通过添加生日视图控制器传入的生日添加到生日数组中。您可以通过使用数组的 append(_:) 方法来完成这一操作 ➋ 。接下来，您需要刷新表格视图，以便它显示这个新添加的生日，方法是调用 tableView 属性上的 reloadData() 方法 ➌ 。当调用 reloadData() 时，表格视图的数据源方法将再次被调用，新添加的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必须的，但为了保持良好的编码风格，标记类的不同部分是有益的，这有助于保持代码清晰可读。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，您可以在类的顶部使用该菜单。这个下拉菜单帮助您找到方法，并让您跳转到代码中的不同位置。要使用这个菜单，请点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：您的类有一个内置的目录，方便快速跳转到某个部分。*

##### 为添加生日视图控制器指定委托

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉生日表视图控制器何时添加了一个生日。为了做到这一点，添加生日视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类的出口下方添加一行代码，来为其添加一个可选的 AddBirthdayViewControllerDelegate 类型的委托属性：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为你只能在*添加生日视图控制器创建之后*设置它。稍后你将学习在哪里设置委托。

现在，添加生日视图控制器有了一个委托，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将一个生日传递给委托。将 saveTapped(_:)方法改成如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)方法将其传回给委托。

太棒了！你已经完成了对添加生日视图控制器的修改。它现在有了一个委托，可以监听到生日被保存的事件。运行应用查看效果吧。

嗯……没什么变化。当你添加一个生日时，仍然看不见它出现在生日表视图控制器中。怎么回事？

#### 通过设置委托连接两个控制器

还有一件事你必须做。生日表视图控制器是一个 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存它与之通信的委托，在生日保存时与其交互。但我们从未明确将委托属性设置为生日表视图控制器。所以，现在是时候在两个视图控制器之间建立通信管道了。

在 BirthdayTableViewController 类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。取消注释该方法，删除围绕它的/*和*/。

这个方法会在每次生日表视图控制器退出屏幕，并且应用通过故事板 segue 过渡到另一个视图控制器时自动调用。我们将利用这个方法将生日表视图控制器传递给添加生日视图控制器，并设置它为添加生日视图控制器的委托。请在 prepare(for:sender:)方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的 delegate 为 Birthdays 表格视图控制器需要三行代码。首先，你需要能够从 segue 参数获取 AddBirthdayViewController 对象。Xcode 在注释中留下了提示，告诉你如何实现。UIStoryboardSegue 有一个叫做 destination 的属性，它指向正在准备的 segue 的另一端，但该应用的 destination 并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到一个导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。因此，你并不指望在 segue 的另一端找到 Add Birthday 视图控制器。相反，destination 是一个包含 Add Birthday 视图控制器的 UINavigationController。➊处的代码可以获取 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是一个特定类型的 ViewController，我们需要使用`as`将其强制转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此需要将其强制转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的一个具体子类。最后，当你有了 AddBirthdayViewController 时，可以将 delegate 设置为 self，当前它是 Birthdays 表格视图控制器 ➌。

现在运行应用并添加一些生日！你在 Birthdays 表格视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用后再重新运行，之前添加的生日将会消失。我们仍然需要将生日保存到设备中，接下来会在第十二章中进行讲解。

### 你学到的知识

在本章中，你学会了如何创建一个表格视图控制器来展示你的生日列表。你还学会了如何在 Add Birthday 视图控制器中添加一个生日，然后如何通过代理将这个生日添加到 Birthdays 表格视图控制器中的生日数组里，从而能够在界面上显示出来。

在第十二章中，你将学会如何将生日保存到设备中，以便即使退出应用后重新运行，它们仍然会显示。为了保存生日，你将使用 Core Data，这是我们在项目开始时就设置好的功能。

这里需要注意的是，BirthdaysTableViewController 是从 UITableViewController 类继承来的。一个类只能有一个父类，并且这个父类名必须写在任何协议之前。但虽然一个类只能有一个父类，它可以采用任意数量的协议——这些协议会在父类之后列出，并由逗号分隔。

现在，为了遵守 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要将 addBirthdayViewController(_:didAddBirthday:) 方法添加到 Birthdays TableViewController 中。一个好的位置是类的末尾，紧接在导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当您开始输入函数名时，Xcode 自动补全会建议整个方法声明。这是因为它知道该类采用了 AddBirthdayViewControllerDelegate 协议，并且预期您添加这个方法。请注意，与子类化方法不同，在 addBirthdayViewController(_:didAddBirthday:) 前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，您需要做两件事。首先，您需要将由 Add Birthday 视图控制器传入的 Birthday 添加到 birthdays 数组中。您可以通过使用 append(_:) 方法来实现这一点 ➋。接下来，您需要刷新表格视图，以便它显示这个新的生日，方法是调用 tableView 属性的 reloadData() 方法 ➌。当 reloadData() 被调用时，表格视图的数据源方法会再次被调用，新增的生日将显示在生日列表的底部。

您可能已经注意到，我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。虽然这不是必须的，但在类中标记不同的部分是一个良好的编码风格，有助于保持代码整洁和可读。注释的第一部分，MARK: -，是 Xcode 识别的特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，您可以在类的顶部使用该菜单。这个下拉菜单帮助您查找方法，并允许您跳转到代码的不同位置。要使用这个菜单，请点击编辑器窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：您的类具有内置的目录，可以快速跳转到某个章节。*

##### 为 Add Birthday 视图控制器指定代理

BirthdaysTableViewController 已经遵循了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来通知 Birthdays 表格视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类的 outlets 下方插入以下代码行来实现这一点，定义一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为您不能在 Add Birthday 视图控制器创建之前设置它。您将很快学习到在哪里设置代理。

现在，“添加生日”视图控制器有了代理，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将生日传递给代理。将 saveTapped(_:)方法更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)方法将它传回给代理。

很棒！你已经完成了对“添加生日”视图控制器的修改。它现在有了一个代理，用于监听“生日已保存”的回调。运行应用看看会发生什么。

嗯……变化不大。当你添加一个生日时，仍然看不到它出现在“生日”表视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

你还需要做最后一件事。“生日”表视图控制器是一个 AddBirthdayViewControllerDelegate，且“添加生日”视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用于保存它与之通信的代理，当生日被保存时会使用它。但是我们从未明确将代理属性设置为“生日”表视图控制器。所以现在是时候将这两个视图控制器之间的通信管道连接起来了。

在“生日”表视图控制器类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)，通过删除/*和*/来取消注释这个方法。

当“生日”表视图控制器放弃其屏幕并通过 storyboard segue 切换到另一个视图控制器时，此方法会自动被调用。我们将使用此方法将“生日”表视图控制器传递给“添加生日”视图控制器，并设置它为“添加生日”视图控制器的代理。在 prepare(for:sender:)方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的代理到“生日”表视图控制器只需要三行代码。首先，你需要能够从 segue 参数中获取到 AddBirthdayViewController 对象。Xcode 在注释中留下了提示，说明了如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，它位于此方法中准备的 segue 的另一端，但此应用的 destination 并不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到一个导航控制器中，这样你就可以拥有带有取消和保存按钮的导航栏。所以你不期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊处的代码将会获取 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是特定类型的视图控制器，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此需要将其类型转换为 AddBirthdayViewController，表明该控制器是 UIViewController 的特定子类。最后，当你得到一个 AddBirthdayViewController 时，你可以将代理设置为 self，这时 self 就是当前的生日表格视图控制器 ➌。

现在运行应用并添加一些生日！在生日表格视图控制器中你看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用再重新启动，之前添加的生日会消失。我们还需要将生日保存到设备中，这部分内容将在第十二章中讲解。

### 你学到了什么

在本章中，你学会了如何创建一个表格视图控制器来展示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表格视图控制器的生日数组中，这样它就可以显示出来了。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用并重新启动，它们也会显示出来。保存生日时，你将使用 Core Data，这是我们在项目开始时就设置好的。

现在，为了遵守 AddBirthdayViewControllerDelegate 协议并修复错误，我们需要在生日表格视图控制器中添加 addBirthdayViewController(_:didAddBirthday:)方法。一个好的添加位置是类的末尾，即导航部分之后：

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名称时，Xcode 的自动补全会建议完整的方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期待你添加这个方法。注意，与子类化方法不同，你在 addBirthdayViewController(_:didAddBirthday:)前不需要使用 override 关键字，因为没有原始的方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将从“添加生日”视图控制器传递过来的生日添加到生日数组中。你可以通过使用数组的 append(_:)方法来实现 ➋。接下来，你需要刷新表格视图，调用 tableView 属性上的 reloadData()方法，以便显示这个新的生日 ➌。当调用 reloadData()时，表格视图的数据源方法将会重新调用，新增的生日会显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但标记类的不同部分是一种良好的编码风格，有助于保持代码整洁且易于阅读。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，它会将 AddBirthdayViewControllerDelegate 部分添加到类顶部的下拉目录菜单中。这个下拉菜单帮助你快速找到方法，并能让你跳转到代码中的不同位置。要使用这个菜单，点击编辑器窗格顶部的 Birthdays TableViewController，如 图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内建的目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器指定委托

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来通知 Birthdays 表视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 outlets 下面插入以下代码，向 AddBirthdayViewController 类中添加一个可选的委托属性，类型为 AddBirthdayViewControllerDelegate：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为直到 Add Birthday 视图控制器创建之后，你才能设置它。稍后你会学习在哪里设置委托。

现在，Add Birthday 视图控制器有了一个委托，在 saveTapped(_:) 方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:) 方法将生日传递给委托。将 saveTapped(_:) 更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 将其传回委托。

太棒了！你已经完成了对 Add Birthday 视图控制器的修改。它现在有了一个委托，用来监听生日已保存的通知。运行应用程序看看会发生什么。

嗯……没什么变化。当你添加一个生日时，仍然没有看到它出现在 Birthdays 表视图控制器中。怎么回事？

#### 通过设置委托连接两个控制器

还有最后一件事。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存与之通信的委托，在生日保存时会与其进行交互。但我们从未明确设置该委托属性为 Birthdays 表视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个被注释掉的方法叫 prepare(for:sender:)。通过删除包围它的 /* 和 */ 来取消注释这个方法。

每当 Birthdays 表格视图控制器退出屏幕并且应用通过 storyboard segue 转到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将 Birthdays 表格视图控制器传递给 Add Birthday 视图控制器，以便将其设置为 Add Birthday 视图控制器的委托。请在 prepare(for:sender:) 方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的委托为 Birthdays 表格视图控制器只需要三行代码。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 在注释中提示了如何做到这一点。一个 UIStoryboardSegue 在这个方法中正在准备的另一端有一个叫做 destination 的属性，但这个应用的目的地并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到一个导航控制器中，以便拥有一个带有取消和保存按钮的导航栏。因此，你并不期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目的地是一个包含 Add Birthday 视图控制器的 UINavigationController。➊ 处的代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，因此我们需要使用 as 将其强制类型转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，所以必须将其强制类型转换为 AddBirthdayViewController，以表示该控制器是 UIViewController 的一个特定子类。最后，当你拥有了 AddBirthdayViewController 后，你可以将委托设置为 self，也就是当前的 Birthdays 表格视图控制器 ➌。

现在运行应用并添加一些生日！你在 Birthdays 表格视图控制器中看到什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用并重新启动，之前添加的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中实现。

### 你学到了什么

在本章中，你学会了如何创建一个表格视图控制器来显示生日列表。你还学会了如何在 Add Birthday 视图控制器中添加一个生日，然后如何使用委托将这个生日添加到 Birthdays 表格视图控制器中的 birthdays 数组，从而显示它。

在第十二章中，你将学习如何将生日保存到你的设备中，以便即使退出应用并重新运行，它们仍然显示出来。为了保存生日，你将使用在项目开始时设置的 Core Data。

```
➊
 // MARK: - AddBirthdayViewControllerDelegate

  func
 addBirthdayViewController(_
 addBirthdayViewController: 

      AddBirthdayViewController
 , didAddBirthday birthday: Birthday
 ) {

    ➋
 birthdays
 .append
 (birthday)

    ➌
 tableView
 .reloadData
 ()

  }
```

当你开始输入函数名时，Xcode 的自动完成功能会建议你整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewControllerDelegate 协议，并且它期望你添加这个方法。请注意，与子类方法不同，在 addBirthdayViewController(_:didAddBirthday:) 前你不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将 Add Birthday 视图控制器传递过来的生日添加到 birthdays 数组中。你可以通过使用数组的 append(_:) 方法来做到这一点 ➋。接下来，你需要刷新表格视图，以便它显示这个新添加的生日，方法是调用 tableView 属性的 reloadData() 方法 ➌。当调用 reloadData() 时，表格视图的数据源方法会再次被调用，新的生日将显示在生日列表的底部。

你可能注意到我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。这不是必需的，但标记类的不同部分是一种良好的编码风格，它有助于保持代码整洁和可读。注释的第一部分，MARK: -，是 Xcode 识别的一个特殊关键字，用于代码注释，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，你可以在类的顶部使用该菜单。这个下拉菜单帮助你找到方法，并让你跳转到代码中的不同位置。要使用此菜单，请点击编辑器窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内建的目录，可以快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器设置委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议来通知 Birthdays 表格视图控制器何时添加了一个生日了。为了做到这一点，Add Birthday 视图控制器首先需要定义一个委托。我们通过在 outlets 下方插入以下代码行来安排这一点，为 AddBirthdayViewController 类添加一个类型为 AddBirthdayViewControllerDelegate 的可选委托属性：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是一个可选项，因为在*添加生日*视图控制器创建之前，你无法设置它。稍后你将学习在哪里设置委托。

现在，既然 Add Birthday 视图控制器有了一个委托，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将一个 Birthday 传递给委托。将 saveTapped(_:) 方法修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建了生日对象之后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 将其传回给委托。

很棒！你已经完成了对 Add Birthday 视图控制器的所有更改。现在它有了一个委托，会监听 Birthday 被保存的调用。运行应用程序看看会发生什么。

嗯。。。没什么变化。当你添加一个 Birthday 时，你仍然看不到它显示在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置委托连接两个控制器

还有一件事需要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它在保存 Birthday 时与委托进行通信。但是我们从未明确将委托属性设置为 Birthdays 表格视图控制器。所以现在是时候在这两个视图控制器之间建立通信管道了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个已被注释掉的方法 prepare(for:sender:)。通过删除 /* 和 */ 注释符号取消注释这个方法。

这个方法会在 Birthdays 表格视图控制器放弃其屏幕并通过 storyboard segue 转场到另一个视图控制器时自动调用。我们将使用这个方法将 Birthdays 表格视图控制器传递给 Add Birthday 视图控制器，并设置它作为 Add Birthday 视图控制器的委托。在 prepare(for:sender:) 方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的委托为 Birthdays 表格视图控制器需要三行代码。首先，你需要能够从 segue 参数中获取到 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你可以如何做到这一点。一个 UIStoryboardSegue 有一个名为 destination 的属性，指向这个方法中正在准备的 segue 另一端，但对于这个应用程序来说，destination 不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到了导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。因此，你不应该期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个 UINavigationController，它包含了 Add Birthday 视图控制器。➊ 处的代码将获取 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是一种特定类型的视图控制器，我们需要通过 `as` 强制类型转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须进行类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 时，你可以将代理设置为 self，即当前的生日表格视图控制器 ➌。

现在运行应用并添加一些生日！在生日表格视图控制器中你看到了什么？生日！生日！生日！不过我们还没有完成。如果你退出应用并重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备，这将在第十二章中完成。

### 你学到了什么

在本章中，你学会了如何创建一个表格视图控制器来展示你的生日列表。你还学会了如何在 Add Birthday 视图控制器中添加生日，并且通过使用代理将生日添加到生日表格视图控制器中的生日数组中，从而能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用并重新运行，它们仍然会显示出来。为了保存生日，你将使用在项目一开始时设置的 Core Data。

当你开始输入函数名时，Xcode 的自动补全会建议整个方法声明。这是因为它知道这个类采用了 AddBirthdayViewController Delegate 协议，并且它期待你添加这个方法。请注意，与子类化方法不同，你在 addBirthdayViewController(_:didAddBirthday:)方法前不需要使用 override 关键字，因为没有原始方法需要被重写。

在这个方法中，你需要做两件事。首先，你需要将由 Add Birthday 视图控制器传递过来的生日添加到生日数组中。你可以使用数组的 append(_:)方法来完成这一步 ➋。接下来，你需要刷新表格视图，以便显示这个新的生日，方法是调用 tableView 属性的 reloadData()方法 ➌。当调用 reloadData()时，表格视图的数据源方法会再次被调用，新增的生日将显示在生日列表的底部。

你可能已经注意到我们在方法上方添加了一个注释来标记这一部分代码：// MARK: - AddBirthdayViewControllerDelegate ➊ 。这不是必须的，但在类中标记不同的部分是一种良好的编码风格，它有助于保持代码的清晰和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的一个特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到类顶部可用的下拉目录菜单中。这个下拉菜单帮助你快速找到方法，并能让你跳转到代码的不同位置。要使用此菜单，请点击编辑器窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，方便快速跳转到某个部分。*

##### 为添加生日视图控制器指定一个委托

BirthdaysTableViewController 已经遵循了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议来通知 Birthdays 表视图控制器它已添加了一个生日。为此，添加生日视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类的出口下方插入以下代码来安排这一点，添加一个可选的委托属性，类型为 AddBirthdayViewControllerDelegate：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是一个可选的，因为你不能在*添加生日*视图控制器创建之后再设置它。稍后你会学习到在哪里设置委托。

现在，添加生日视图控制器有了委托，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将生日传递给委托。将 saveTapped(_:)方法改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码在➊处通过 addBirthdayViewController(_:didAddBirthday:)将其传回给委托。

很棒！你已经完成了对添加生日视图控制器的修改。现在它有了一个委托，能够监听生日保存的事件。运行应用程序看看会发生什么。

嗯……没有太大变化。当你添加一个生日时，你仍然看不到它出现在 Birthdays 表视图控制器中。怎么回事？

#### 通过设置委托连接这两个控制器

还有最后一件事需要做。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存它在生日保存时与之通信的委托。但我们从未专门将委托属性设置为 Birthdays 表视图控制器。因此，现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个已被注释掉的方法，叫做 prepare(for:sender:)。通过删除包围它的/*和*/来取消注释这个方法。

这种方法会在每次生日表格视图控制器放弃其屏幕并通过故事板转场到另一个视图控制器时自动调用。我们将使用这个方法将生日表格视图控制器传递给添加生日视图控制器，并将其设置为添加生日视图控制器的委托。请在 prepare(for:sender:)方法中写下以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的委托为生日表格视图控制器需要三行代码。首先，你需要能够通过 segue 参数访问 AddBirthdayViewController 对象。Xcode 在注释中留下了提示，告诉你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，指向正在准备的转场的另一端，但这个应用程序的目标不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。因此，你不指望在转场的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。在➊的那一行代码中，你得到了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定类型，我们需要使用`as`进行类型转换，将其转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其强制转换为 AddBirthdayViewController，以表示该控制器是 UIViewController 的一个特定子类。最后，当你拥有 AddBirthdayViewController 时，你可以将其 delegate 设置为 self，而 self 当前是生日表格视图控制器➌。

现在运行应用程序并添加一些生日！你在生日表格视图控制器中看到什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用程序然后重新运行它，之前的生日会消失。我们仍然需要将生日保存到设备中，我们将在第十二章中完成这部分内容。

### 你学到了什么

在本章中，你学会了如何制作一个表格视图控制器来显示生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，并且如何使用委托将生日添加到生日表格视图控制器中的生日数组中，以便进行显示。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使你退出应用并重新运行，它们仍会显示。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

在这个方法中，你需要做两件事。首先，你需要将由添加生日视图控制器传入的生日添加到生日数组中。你可以通过使用数组的 append(_:)方法来实现 ➋。接下来，你需要刷新表格视图，使其显示这个新添加的生日，通过调用 tableView 属性上的 reloadData()方法 ➌。当调用 reloadData()时，表格视图的数据源方法将再次被调用，新添加的生日将显示在生日列表的底部。

你可能已经注意到，我们在方法上方添加了一个注释来标记这一部分：// MARK: - AddBirthdayViewControllerDelegate ➊。虽然这不是必须的，但标记不同部分的代码是一种良好的编程风格，有助于保持代码的整洁和可读性。注释的第一部分，MARK: - ，是 Xcode 识别的特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到你可以在类顶部使用的下拉目录菜单中。这个下拉菜单帮助你查找方法，并让你能够快速跳转到代码中的不同位置。要使用此菜单，请点击编辑器面板顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：你的类具有内置的目录，可以快速跳转到某一部分。*

##### 为添加生日视图控制器设置委托

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议来告知生日表格视图控制器何时已添加生日。为此，添加生日视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类的 outlets 下面插入以下行，来安排添加一个可选的 AddBirthdayViewControllerDelegate 类型的委托属性：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托（delegate）必须是可选的，因为在*添加生日*视图控制器创建之前，无法设置它。稍后你将学到在哪里设置委托。

现在，添加生日视图控制器有了委托，在 saveTapped(_:)方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:)方法将一个生日传递给委托。将 saveTapped(_:)方法更改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，代码在 ➊ 使用 addBirthdayViewController(_:didAddBirthday:)方法将其传回给委托。

太棒了！你已经完成了对 Add Birthday 视图控制器的修改。现在它有了一个代理，能够监听生日保存的调用。运行应用看看发生了什么。

嗯……似乎没有太大变化。当你添加一个生日时，仍然看不到它出现在 Birthdays 表格视图控制器中。这是怎么回事？

#### 通过设置代理连接两个控制器

你还需要做最后一件事。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存着它在保存生日时与之通信的代理。但我们从未明确设置该代理属性为 Birthdays 表格视图控制器。所以，现在是时候在这两个视图控制器之间连接通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除它周围的 /* 和 */，取消注释该方法。

每当 Birthdays 表格视图控制器失去屏幕控制权，并且应用通过 storyboard segue 切换到另一个视图控制器时，都会自动调用这个方法。我们将使用这个方法将 Birthdays 表格视图控制器传递给 Add Birthday 视图控制器，并设置它为 Add Birthday 视图控制器的代理。在 prepare(for:sender:) 方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的代理为 Birthdays 表格视图控制器只需要三行代码。首先，你需要能够通过 segue 参数访问 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个叫做 destination 的属性，它是正在准备的 segue 另一端的目标视图控制器，但对于这个应用来说，目标并不是 AddBirthdayViewController。

在 第九章 中，你将 Add Birthday 视图控制器嵌入到了一个导航控制器中，这样你就可以有一个带有取消和保存按钮的导航栏。所以你不指望在 segue 另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊ 这一行代码让你获取到 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是特定类型的视图控制器，我们需要使用 as 进行类型转换，转为 UINavigationController。

接下来，您可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 是正在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的特定子类。最后，当您获得 AddBirthdayViewController 后，您可以将代理设置为 self，而 self 当前是 Birthdays 表视图控制器 ➌。

现在运行应用并添加一些生日！在 Birthdays 表视图控制器中您看到什么？生日！生日！生日！不过我们还没有完全完成。如果退出应用然后重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，接下来我们将在第十二章中处理这个问题。

### 您学到的内容

在本章中，您学习了如何创建一个表视图控制器来显示您的生日列表。您还学习了如何在 Add Birthday 视图控制器中添加一个生日，然后如何使用代理将生日添加到 Birthdays 表视图控制器中的 birthdays 数组，从而进行显示。

在第十二章中，您将学习如何将生日保存到设备中，以便即使退出应用并重新运行时，生日仍然会显示。为保存生日，您将使用 Core Data，这是我们在项目开始时设置的。

您可能注意到我们在方法上方添加了一个注释来标记这个部分：// MARK: - AddBirthdayViewControllerDelegate ➊。虽然这不是必需的，但将类的不同部分进行标记是良好的编码风格，这有助于保持代码清晰易读。注释的第一部分，MARK: - ，是 Xcode 识别的一个特殊关键字，它将 AddBirthdayViewControllerDelegate 部分添加到一个下拉目录菜单中，您可以在类的顶部使用该菜单。这个下拉菜单可以帮助您查找方法，并让您跳转到代码中的不同位置。要使用此菜单，请点击编辑窗格顶部的 Birthdays TableViewController，如图 11-7 所示。

![](img/Image00247.jpg)

*图 11-7：您的类有一个内建的目录，便于快速跳转到某个部分。*

##### 为 Add Birthday 视图控制器指定代理

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中，在 outlets 下面添加一个可选的代理属性，类型为 AddBirthdayViewControllerDelegate，来完成这一设置。

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为你不能在添加生日视图控制器创建之前设置它。你将很快了解在哪里设置委托。

现在添加生日视图控制器有了委托，在 `saveTapped(_:)` 方法中，你可以使用 `addBirthdayViewController(_:didAddBirthday:)` 方法将一个生日传递给委托。将 `saveTapped(_:)` 改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象后，➊ 处的代码通过 `addBirthdayViewController(_:didAddBirthday:)` 将其传递回委托。

太好了！你已经完成了对添加生日视图控制器的更改。现在它有了一个委托，能够监听生日保存的调用。运行应用程序看看会发生什么。

嗯……没有太大变化。当你添加一个生日时，仍然看不到它出现在生日表视图控制器中。怎么回事？

#### 通过设置委托连接这两个控制器

还有最后一件事需要做。生日表视图控制器是一个 `AddBirthdayViewControllerDelegate`，而添加生日视图控制器有一个 `AddBirthdayViewControllerDelegate` 属性，用于保存它与之通信的委托，当一个生日被保存时。但我们从未明确设置委托属性为生日表视图控制器。所以现在是时候在两个视图控制器之间建立通信管道了。

在 `BirthdaysTableViewController` 类的导航部分，有一个被注释掉的方法，叫做 `prepare(for:sender:)`。通过删除 `/*` 和 `*/` 注释符号来取消注释该方法。

每当生日表视图控制器失去屏幕并且应用程序通过 storyboard segue 切换到另一个视图控制器时，这个方法会被自动调用。我们将使用这个方法将生日表视图控制器传递给添加生日视图控制器，并将其设置为添加生日视图控制器的委托。在 `prepare(for:sender:)` 方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

需要三行代码将添加生日视图控制器的委托设置为生日表视图控制器。首先，你需要能够通过 segue 参数访问到 `AddBirthdayViewController` 对象。Xcode 留下了一条注释，提示你如何做到这一点。`UIStoryboardSegue` 有一个名为 `destination` 的属性，指向在此方法中准备的 segue 终点，但对于这个应用程序，终点并不是 `AddBirthdayViewController`。

在第九章中，你将 Add Birthday 视图控制器嵌入到一个导航控制器中，以便你能拥有带有取消和保存按钮的导航栏。因此，你不会在 segue 的另一端找到 Add Birthday 视图控制器，而是目标是一个包含 Add Birthday 视图控制器的 UINavigationController。在➊这一行你得到了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定类型，所以需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前显示在 navigationController 中的视图控制器，但它的属性类型是 UIViewController，因此必须将其强制转换为 AddBirthdayViewController，以表明这是 UIViewController 的一个特定子类。最后，当你得到 AddBirthdayViewController 时，你可以将代理设置为 self，即当前的 Birthdays 表视图控制器 ➌。

现在运行应用并添加一些生日！在 Birthdays 表视图控制器中你看到了什么？生日！生日！生日！不过我们还没有完全结束。如果你退出应用并重新运行它，之前的生日将消失。我们仍然需要将生日保存到设备中，这一点将在第十二章中完成。

### 你学到了什么

在这一章中，你学会了如何创建一个表视图控制器来显示你的生日列表。你还学会了如何在 Add Birthday 视图控制器中添加一个生日，然后如何使用代理将生日添加到 Birthdays 表视图控制器中的生日数组，以便它能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用并重新运行它，生日也会显示出来。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

![](img/Image00247.jpg)

*图 11-7：你的类有一个内置的目录，方便快速跳转到某个章节。*

##### 为 Add Birthday 视图控制器指定一个代理

BirthdaysTableViewController 已采纳 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，通知 Birthdays 表视图控制器它已添加一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个可选的代理属性，类型为 AddBirthdayViewControllerDelegate，来安排这一操作，并将以下代码插入到 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在添加生日视图控制器创建之前设置它。你很快就会学到在哪里设置代理。

既然添加生日视图控制器有了代理，在 `saveTapped(_:)` 方法中，你可以通过 `addBirthdayViewController(_:didAddBirthday:)` 方法将生日传递给代理。将 `saveTapped(_:)` 改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊ 处的代码通过 `addBirthdayViewController(_:didAddBirthday:)` 将它传递回代理。

太棒了！你已经完成了对添加生日视图控制器的更改。现在，它有了一个代理，能够监听生日被保存的调用。运行应用程序看看会发生什么。

嗯……似乎没有太大变化。当你添加一个生日时，仍然看不到它出现在生日表格视图控制器中。怎么回事？

#### 通过设置代理连接两个控制器

你还需要做最后一件事。生日表格视图控制器是一个 `AddBirthdayViewControllerDelegate`，而添加生日视图控制器有一个 `AddBirthdayViewControllerDelegate` 属性，它保存着与之沟通的代理，特别是当生日被保存时。但我们从未明确设置代理属性为生日表格视图控制器。所以，现在是时候在这两个视图控制器之间建立通信管道了。

在 `BirthdaysTableViewController` 类的导航部分，有一个被注释掉的方法叫做 `prepare(for:sender:)`。删除它周围的 `/*` 和 `*/` 注释，取消注释这个方法。

这个方法会在生日表格视图控制器放弃其屏幕并且应用程序通过 storyboard segue 切换到另一个视图控制器时自动调用。我们将使用这个方法将生日表格视图控制器传递到添加生日视图控制器中，设置它为添加生日视图控制器的代理。在 `prepare(for:sender:)` 方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器代理到生日表格视图控制器需要三行代码。首先，你需要能够通过 segue 参数获取到 `AddBirthdayViewController` 对象。Xcode 在注释中给出了如何做到这一点的提示。`UIStoryboardSegue` 有一个属性叫做 `destination`，它指向正在准备的 segue 另一端的视图控制器，但这个应用程序的目的地并不是 `AddBirthdayViewController`。

在 第九章 中，你将添加生日视图控制器嵌入到导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。因此，你不需要期待在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊ 处的代码获取了 navigationController。segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，因此需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是导航控制器的 topViewController ➋。topViewController 就是当前在导航控制器中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 后，你可以将代理设置为 self，这里指的是当前的生日表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你会在生日表格视图控制器中看到什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序并重新运行，之前的生日会消失。我们仍然需要将生日保存到设备中，这将在 第十二章 中进行。

### 你所学到的内容

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学习了如何在添加生日视图控制器中添加生日，然后如何使用代理将生日添加到生日表格视图控制器中的生日数组，以便能够显示它。

在 第十二章 中，你将学习如何将生日保存到你的设备上，这样即使退出应用程序并重新运行，它们依然会显示。为了保存生日，你将使用 Core Data，这是我们在项目开始时就设置好的。

*图 11-7：你的类有一个内置的目录，可以快速跳转到某个章节。*

##### 为添加生日视图控制器设置代理

BirthdaysTableViewController 已经采纳了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议来告诉生日表格视图控制器何时添加了一个生日。为此，添加生日视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性来安排此操作，代码如下所示，在 outlets 下面插入该行：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为你不能在 Add Birthday 视图控制器创建之前设置它。稍后你将学到在哪里设置委托。

现在 Add Birthday 视图控制器有了委托，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将生日传递给委托。将 saveTapped(_:) 改为以下代码：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象后，➊ 处的代码通过 addBirthdayViewController(_:didAddBirthday:) 方法将其传回委托。

太好了！你已经完成了对添加生日视图控制器的修改。现在它有了一个委托，能够监听生日保存的调用。运行应用程序查看会发生什么。

嗯……似乎没有太大变化。当你添加生日时，你仍然没有看到它出现在 Birthdays 表格视图控制器中。怎么回事？

#### 通过设置委托连接两个控制器

还有最后一件事需要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存着它在生日保存时与之通信的委托。但我们从未明确设置委托属性为 Birthdays 表格视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除 /* 和 */ 来取消注释这个方法。

当 Birthdays 表格视图控制器放弃其屏幕并通过 storyboard segue 过渡到另一个视图控制器时，这个方法会自动调用。我们将利用这个方法将 Birthdays 表格视图控制器传递给 Add Birthday 视图控制器，将其设置为 Add Birthday 视图控制器的委托。在 prepare(for:sender:) 方法中写下以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

需要三行代码将 Add Birthday 视图控制器的委托设置为 Birthdays 表格视图控制器。首先，你需要能够通过 segue 参数访问 AddBirthdayViewController 对象。Xcode 提供了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个叫做 destination 的属性，它是正在准备的 segue 另一端的目标视图控制器，但对于这个应用程序，目标视图控制器并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到一个导航控制器中，这样就可以拥有带有取消和保存按钮的导航栏。所以你不指望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊ 行获取了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是特定类型的视图控制器，我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取到 Add Birthday 视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其强制转换为 AddBirthdayViewController，以指示该控制器是 UIViewController 的特定子类。最后，当你有了 AddBirthdayViewController 后，可以将代理设置为 self，而 self 目前是 Birthdays 表视图控制器 ➌。

现在运行应用程序并添加一些生日！你在 Birthdays 表视图控制器中看到了什么？生日！生日！生日！不过，我们还没完全完成。如果你退出应用程序然后重新运行，之前添加的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到的知识

在这一章中，你学习了如何创建一个表视图控制器来显示你的生日列表。你还学习了如何在 Add Birthday 视图控制器中添加一个生日，然后如何使用代理将生日添加到 Birthdays 表视图控制器中的生日数组，以便显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用程序并重新运行，它们依然会显示。为了保存生日，你将使用 Core Data，这是我们在项目开始时就设置好的。

##### 为 Add Birthday 视图控制器设置代理

BirthdaysTableViewController 已经遵循了 AddBirthdayViewControllerDelegate 协议。现在是时候让 Add Birthday 视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉 Birthdays 表视图控制器它已经添加了一个生日。为此，Add Birthday 视图控制器首先需要定义一个代理。我们通过在 AddBirthdayViewController 类中添加一个类型为 AddBirthdayViewControllerDelegate 的可选代理属性，并在 outlets 下方插入以下代码来安排这个任务：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在 Add Birthday 视图控制器创建之前设置代理。你很快就会学到在哪里设置代理。

现在，“添加生日”视图控制器有了一个代理，在 `saveTapped(_:)` 方法中，您可以使用 `addBirthdayViewController(_:didAddBirthday:)` 方法将一个生日传递给代理。将 `saveTapped(_:)` 修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在创建生日对象后，➊ 处的代码通过 `addBirthdayViewController(_:didAddBirthday:)` 将其传回给代理。

太棒了！您已经完成了对“添加生日”视图控制器的修改。它现在有了一个代理，能够监听生日已保存的通知。运行应用程序看看会发生什么。

嗯……似乎没有太大变化。当您添加一个生日时，您仍然看不到它出现在“生日”表视图控制器中。怎么回事？

#### 通过设置代理连接这两个控制器

还有最后一件事需要做。“生日”表视图控制器是一个 `AddBirthdayViewControllerDelegate`，而“添加生日”视图控制器有一个 `AddBirthdayViewControllerDelegate` 类型的属性，用来保存它与之通信的代理，以便在生日保存时进行通知。但我们从未明确设置代理属性为“生日”表视图控制器。所以现在是时候将这两个视图控制器之间的通信管道连接起来了。

在 `BirthdaysTableViewController` 类的导航部分，有一个被注释掉的方法 `prepare(for:sender:)`。通过删除它周围的 `/*` 和 `*/` 来取消注释该方法。

每当“生日”表视图控制器失去屏幕控制并且应用程序通过故事板 segue 切换到另一个视图控制器时，这个方法会被自动调用。我们将使用这个方法将“生日”表视图控制器传递到“添加生日”视图控制器，以便将自己设置为“添加生日”视图控制器的代理。在 `prepare(for:sender:)` 方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的代理为“生日”表视图控制器只需要三行代码。首先，您需要能够从 segue 参数获取到 `AddBirthdayViewController` 对象。Xcode 留下了一个注释，提示您如何做到这一点。`UIStoryboardSegue` 有一个名为 `destination` 的属性，它表示这个方法中正在准备的 segue 的目标，但对于这个应用程序来说，目标不是 `AddBirthdayViewController`。

在第九章中，您将“添加生日”视图控制器嵌入到一个导航控制器中，以便可以使用带有取消和保存按钮的导航栏。因此，您不应该在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 `UINavigationController`。➊ 处的代码获取了 `navigationController`。代码 `segue.destination` 将返回一个 `UIViewController`，但由于我们的 `navigationController` 是特定类型的视图控制器，我们需要使用 `as` 将其类型转换为 `UINavigationController`。

接下来，你可以获取添加生日视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 只是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其强制转换为 AddBirthdayViewController，以表示该控制器是 UIViewController 的特定子类。最后，当你拥有一个 AddBirthdayViewController 时，你可以将委托设置为 self，这时 self 就是当前的生日表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用程序然后再次运行，之前的生日将会消失。我们仍然需要将生日保存到设备，这将在第十二章中完成。

### 你学到了什么

在本章中，你学习了如何制作一个表格视图控制器来显示生日列表。你还学习了如何在添加生日视图控制器中添加一个生日，然后如何使用委托将生日添加到生日表格视图控制器中的生日数组，以便显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用程序并重新启动，生日也会显示出来。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

BirthdaysTableViewController 已经采用了 AddBirthdayViewControllerDelegate 协议。现在是时候让添加生日视图控制器使用 AddBirthdayViewControllerDelegate 协议，告诉生日表格视图控制器它已经添加了一个生日。为此，添加生日视图控制器首先需要定义一个委托。我们通过在 AddBirthdayViewController 类中添加一个可选的 AddBirthdayViewControllerDelegate 类型的委托属性，来安排这一点，代码如下所示，插入在 outlets 下面：

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为你不能在*添加生日视图控制器*创建之前设置它。稍后你将学习如何设置委托。

现在，添加生日视图控制器有了一个委托，在 saveTapped(_:)方法中，你可以使用 addBirthdayViewController(_:didAddBirthday:)方法将一个生日传递给委托。将 saveTapped(_:)更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)将其传回委托。

太棒了！你已经完成了对添加生日视图控制器的修改。现在它有了一个委托，用于监听生日已保存的回调。运行应用程序看看会发生什么。

嗯……变化不大。当你添加一个生日时，还是没有在生日表格视图控制器中看到它。怎么回事？

#### 通过设置委托连接两个控制器

还有最后一件事需要做。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 类型的属性，保存它与之通信的委托，当一个生日被保存时会触发。但是我们从未专门设置过该委托属性为 Birthdays 表视图控制器。所以，现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除/*和*/注释符号来取消注释该方法。

当 Birthdays 表视图控制器放弃当前屏幕并通过故事板 segue 转到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将 Birthdays 表视图控制器传递给 Add Birthday 视图控制器，以便将自己设置为 Add Birthday 视图控制器的委托。在 prepare(for:sender:)方法中写下以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的委托为 Birthdays 表视图控制器只需要三行代码。首先，你需要能够通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 在注释中给出了如何做到这一点的提示。UIStoryboardSegue 有一个叫做 destination 的属性，位于正在准备的 segue 的另一端，但这个应用的 destination 并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到导航控制器中，以便你可以有一个带有取消和保存按钮的导航栏。所以，你不会期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。在➊这一行代码中，你获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，我们需要通过 as 将其强制转换为 UINavigationController。

接下来，你可以通过 navigationController ➋ 获取 Add Birthday 视图控制器，navigationController 的 topViewController 就是当前显示的视图控制器，但它的属性类型是 UIViewController，因此需要将其强制类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 时，你可以将委托设置为 self，即当前的 Birthdays 表视图控制器 ➌。

现在运行应用并添加一些生日！你在生日列表视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用并再次运行它，之前添加的生日会消失。我们还需要将生日保存到设备中，这部分将在第十二章中讲解。

### 你学到的知识

在这一章中，你学会了如何制作一个表格视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，然后如何通过代理将生日添加到生日列表视图控制器中的生日数组里，以便能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用并再次运行，它们也能显示。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

*AddBirthdayViewController.swift*

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

代理必须是可选的，因为你不能在添加生日视图控制器创建之前设置它。你稍后将学会在哪里设置代理。

现在，既然添加生日视图控制器有了代理，在`saveTapped(_:)`方法中，你可以通过`addBirthdayViewController(_:didAddBirthday:)`方法将一个生日传递给代理。将`saveTapped(_:)`方法改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，代码在➊处将其通过`addBirthdayViewController(_:didAddBirthday:)`方法传递回代理。

很棒！你已经完成了对添加生日视图控制器的所有更改。现在它有了一个代理，能够监听生日保存的通知。运行应用看看会发生什么。

嗯……没什么变化。当你添加一个生日时，你仍然看不到它在生日列表视图控制器中显示。发生了什么问题？

#### 通过设置代理连接这两个控制器

还有最后一件事你必须做。生日列表视图控制器是`AddBirthdayViewControllerDelegate`，而添加生日视图控制器有一个`AddBirthdayViewControllerDelegate`属性，用来持有它在保存生日时会与之通信的代理。但是我们之前从未特别设置这个代理属性为生日列表视图控制器。所以现在是时候在这两个视图控制器之间建立通信管道了。

在`BirthdaysTableViewController`类的导航部分，有一个被注释掉的方法，名为`prepare(for:sender:)`。删除/*和*/符号，取消注释该方法。

这个方法会在每次生日列表视图控制器放弃屏幕并且应用通过故事板 segue 切换到另一个视图控制器时自动调用。我们将使用这个方法将生日列表视图控制器传递给添加生日视图控制器，并将其设置为添加生日视图控制器的代理。在`prepare(for:sender:)`方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的委托为“生日”表视图控制器只需要三行代码。首先，你需要能够通过 segue 参数获取到 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 在此方法中正在准备的 segue 另一端有一个叫做 destination 的属性，但这个应用的目标视图控制器并不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到了一个导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。因此，你不会期待在 segue 的另一端找到“添加生日”视图控制器。相反，目标视图控制器是一个包含“添加生日”视图控制器的 UINavigationController。➊ 处的代码让你获得了 navigationController。segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，所以我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其类型转换为 AddBirthdayViewController，以表明这是 UIViewController 的一个特定子类。最后，当你拥有 AddBirthdayViewController 时，你可以将委托设置为 self，也就是当前的“生日”表视图控制器 ➌。

现在运行应用并添加一些生日！你在“生日”表视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用并重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，这一点将在第十二章中实现。

### 你学到了什么

在本章中，你学习了如何创建一个表视图控制器来显示你的生日列表。你还学习了如何在“添加生日”视图控制器中添加一个 Birthday，然后如何使用委托将 Birthday 添加到“生日”表视图控制器中的 birthdays 数组，以便它能够被显示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使你退出应用并重新运行，生日依然会显示出来。为了保存生日，你将使用 Core Data，这是我们在项目开始时就设置好的功能。

```
class AddBirthdayViewController: UIViewController {

    --*snip*
 --

    @IBOutlet var birthdatePicker: UIDatePicker!

    var
 delegate: AddBirthdayViewControllerDelegate?

    override func viewDidLoad() {

```

委托必须是可选的，因为直到“添加生日”视图控制器创建之后，你才可以设置它。你将很快学到在哪里设置委托。

现在，既然“添加生日”视图控制器有了一个委托，在 saveTapped(_:) 方法中，你可以通过 addBirthdayViewController(_:didAddBirthday:) 方法将一个 Birthday 传递给委托。将 saveTapped(_:) 修改为如下：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

生日对象创建之后，➊ 处的代码通过 `addBirthdayViewController(_:didAddBirthday:)` 将其返回给委托。

很好！你已经完成了对添加生日视图控制器的修改。它现在有了一个委托，可以监听生日保存的调用。运行应用程序，看看会发生什么。

嗯……变化不大。当你添加一个生日时，生日表格视图控制器中仍然看不到它。怎么回事？

#### 通过设置委托连接两个控制器

还有最后一件事需要做。生日表格视图控制器是一个 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用于存储它与之通信的委托对象，当生日被保存时。但是我们从未明确将委托属性设置为生日表格视图控制器。所以现在是时候连接我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个被注释掉的方法，叫做 prepare(for:sender:)。通过删除包围它的 /* 和 */ 来取消注释该方法。

每当生日表格视图控制器放弃屏幕并且应用程序通过故事板 segue 转到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将生日表格视图控制器传递给添加生日视图控制器，并设置自己为添加生日视图控制器的委托。在 `prepare(for:sender:)` 方法中编写以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码，就可以将添加生日视图控制器的委托设置为生日表格视图控制器。首先，你需要能够从 segue 参数获取到 AddBirthdayViewController 对象。Xcode 中有一条注释提示你如何做到这一点。UIStoryboardSegue 在准备该方法时，segue 的另一端有一个叫做 destination 的属性，但对于这个应用程序，目的地并不是 AddBirthdayViewController。

在第九章，你将添加生日视图控制器嵌入到导航控制器中，以便你可以拥有一个带有取消和保存按钮的导航栏。所以你不期望在 segue 的另一端找到添加生日视图控制器。相反，目的地是一个 UINavigationController，它包含添加生日视图控制器。➊ 处的代码将获取到 navigationController。代码 `segue.destination` 会返回一个 UIViewController，但由于我们的 navigationController 是一种特定类型的视图控制器，我们需要使用 `as` 将其强制转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是`navigationController`的`topViewController` ➋。`topViewController`就是当前在`navigationController`中显示的视图控制器，但它的属性类型是`UIViewController`，所以必须将其类型转换为`AddBirthdayViewController`，以表明这个控制器是`UIViewController`的一个特定子类。最后，当你有了`AddBirthdayViewController`时，你可以将委托设置为`self`，即当前的“生日”表视图控制器 ➌。

现在运行应用并添加一些生日！你在“生日”表视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用然后重新运行，之前的生日会消失。我们仍然需要将生日保存到设备上，这将在第十二章中完成。

### 你学到了什么

在本章中，你学会了如何制作一个表视图控制器来显示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加生日，然后如何使用委托将生日添加到“生日”表视图控制器中的生日数组，以便它能够显示出来。

在第十二章中，你将学习如何将生日保存到设备上，这样即使退出应用并重新运行，它们也会显示出来。为了保存生日，你将使用我们在项目开始时就设置好的 Core Data。

委托必须是可选的，因为你不能在“添加生日”视图控制器创建之前设置它。你很快就会学到在哪里设置委托。

现在“添加生日”视图控制器有了委托，在`saveTapped(_:)`方法中，你可以通过`addBirthdayViewController(_:didAddBirthday:)`方法将生日传递给委托。将`saveTapped(_:)`更改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊处的代码通过`addBirthdayViewController(_:didAddBirthday:)`将其传回给委托。

很棒！你已经完成了对“添加生日”视图控制器的修改。它现在有了一个委托，能够监听到生日被保存的调用。运行应用看看会发生什么。

嗯……似乎没有太大变化。当你添加一个生日时，你仍然没有看到它出现在“生日”表视图控制器中。发生了什么？

#### 通过设置委托连接两个控制器

还有最后一件事需要做。“生日”表视图控制器是一个`AddBirthdayViewControllerDelegate`，而“添加生日”视图控制器有一个`AddBirthdayViewControllerDelegate`属性，保存了它在生日被保存时与之通信的委托。但我们从未明确将委托属性设置为“生日”表视图控制器。所以是时候连接这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，叫做 prepare(for:sender:)。通过删除围绕它的/*和*/来取消注释该方法。

每当生日表格视图控制器放弃其屏幕并且应用通过 storyboard segue 过渡到另一个视图控制器时，这个方法会自动调用。我们将使用这个方法将生日表格视图控制器传递到添加生日视图控制器，并设置它作为添加生日视图控制器的委托。在 prepare(for:sender:)方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的委托为生日表格视图控制器只需要三行代码。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 中有一个注释提示了你如何做到这一点。UIStoryboardSegue 有一个叫做 destination 的属性，它指向正在准备中的 segue 的另一端，但这个应用的目标并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到导航控制器中，这样就可以有一个带有取消和保存按钮的导航栏。所以你不会期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊处的代码可以让你获取到 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，我们需要使用 as 将其转换为 UINavigationController。

接下来，你可以通过 navigationController ➋获取添加生日视图控制器。topViewController 就是在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，所以必须将其类型转换为 AddBirthdayViewController，以指示该控制器是 UIViewController 的一个特定子类。最后，当你获得了 AddBirthdayViewController 后，你可以将委托设置为 self，即当前的生日表格视图控制器 ➌。

现在运行应用并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用并再次运行，之前的生日将会消失。我们还需要将生日保存到设备中，我们将在第十二章中进行。

### 你学到的内容

在本章中，你学会了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加生日，然后通过使用委托将生日添加到生日表格视图控制器中的生日数组中，以便进行显示。

在第十二章，你将学习如何将生日保存到设备中，这样即使退出应用后重新启动，它们依然会显示。要保存生日，你将使用我们在项目一开始设置的 Core Data。

现在，“添加生日”视图控制器有了一个代理，在`saveTapped(_:)`方法中，你可以通过`addBirthdayViewController(_:didAddBirthday:)`方法将一个生日传递给代理。将`saveTapped(_:)`修改为以下内容：

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建后，➊处的代码通过`addBirthdayViewController(_:didAddBirthday:)`将其传回代理。

太棒了！你已经完成了对“添加生日”视图控制器的修改。现在它有了一个代理，可以监听生日已保存的通知。运行应用查看效果吧。

嗯……变化不大。当你添加一个生日时，你仍然看不到它出现在“生日”表视图控制器中。这是怎么回事？

#### 通过设置代理连接两个控制器

你还需要做最后一件事。“生日”表视图控制器是一个`AddBirthdayViewControllerDelegate`，而“添加生日”视图控制器有一个`AddBirthdayViewControllerDelegate`属性，持有它在保存生日时与之通信的代理。但我们从未特别设置代理属性为“生日”表视图控制器。因此，现在是时候连接这两个视图控制器之间的通信管道了。

在“生日”表视图控制器类的导航部分，有一个已被注释掉的方法`prepare(for:sender:)`。删除包围它的`/*`和`*/`以取消注释该方法。

每当“生日”表视图控制器放弃屏幕，且应用通过故事板过渡到另一个视图控制器时，此方法会自动被调用。我们将使用此方法将“生日”表视图控制器传递给“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的代理。请在`prepare(for:sender:)`方法中写入以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码就能将“添加生日”视图控制器的代理设置为“生日”表视图控制器。首先，你需要能够通过 segue 参数访问到 AddBirthdayViewController 对象。Xcode 中有一条注释提示你如何实现。一个`UIStoryboardSegue`有一个名为`destination`的属性，它指向正在此方法中准备的 segue 的目标视图控制器，但该应用的目标并不是`AddBirthdayViewController`。

在第九章中，你将添加生日视图控制器嵌入到了一个导航控制器中，以便可以有一个带有取消和保存按钮的导航栏。所以你并不期待在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊处的代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定子类，因此我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是导航控制器的 topViewController ➋。topViewController 就是当前在导航控制器中显示的视图控制器，但它的属性类型是 UIViewController，所以需要将其强制转换为 AddBirthdayViewController，以表示这是 UIViewController 的一个具体子类。最后，当你获得 AddBirthdayViewController 时，可以将代理设置为 self，它目前是生日表视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序并再次运行，之前添加的生日将会消失。我们仍然需要将生日保存到设备中，接下来我们将在第十二章中完成这部分。

### 你学到了什么

在本章中，你学习了如何创建一个表视图控制器来显示生日列表。你还学习了如何在添加生日视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表视图控制器中的生日数组中，以便显示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使你退出应用程序并再次运行，它们依然会显示。为了保存生日，你将使用 Core Data，这是我们在项目一开始就设置好的。

```
@IBAction func saveTapped(_ sender: UIBarButtonItem) {

    --*snip*
 --

    let newBirthday = Birthday(firstName: firstName, ![](img/Image00184.jpg)

        lastName: lastName, birthdate: birthdate)

  ➊
 delegate
 ?.addBirthdayViewController
 (self
 , didAddBirthday: newBirthday)

    dismiss
 (animated: true
 , completion: nil
 )

}

```

在生日对象创建之后，➊处的代码通过 addBirthdayViewController(_:didAddBirthday:)将其传回给代理。

太好了！你已经完成了对添加生日视图控制器的修改。现在它有一个代理，将监听“生日已保存”的回调。运行应用程序，看看会发生什么。

嗯……变化不大。当你添加一个生日时，还是没有在生日表视图控制器中看到它显示出来。这是怎么回事？

#### 通过设置代理连接这两个控制器

还有最后一件事需要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存与之通信的代理，当一个生日被保存时，代理就会被触发。但是我们从未专门将代理属性设置为 Birthdays 表格视图控制器。所以，现在是时候连接这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法叫做 prepare(for:sender:)。通过删除/*和*/来取消注释这个方法。

每当 Birthdays 表格视图控制器退出当前屏幕，应用通过 storyboard segue 跳转到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将 Birthdays 表格视图控制器传递给 Add Birthday 视图控制器，以便将其设置为 Add Birthday 视图控制器的代理。在 prepare(for:sender:) 方法中写下以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置 Add Birthday 视图控制器的代理为 Birthdays 表格视图控制器只需要三行代码。首先，你需要从 segue 参数中获取到 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个属性叫做 destination，指向正被准备的 segue 的目标视图控制器，但对于这个应用，目标视图控制器并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到了一个导航控制器中，以便可以拥有一个包含取消和保存按钮的导航栏。所以你不指望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个 UINavigationController，其中包含 Add Birthday 视图控制器。➊ 这一行获取了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，所以我们需要使用 as 将其强制类型转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但是它的属性类型是 UIViewController，所以需要将其强制类型转换为 AddBirthdayViewController，以表明这是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 时，你可以将代理设置为 self，当前的 self 就是 Birthdays 表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表格视图控制器中看到什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用程序再重新启动，之前的生日会消失。我们还需要将生日保存到设备中，这将在第十二章中实现。

### 你学到了什么

在本章中，你学会了如何创建一个表格视图控制器来展示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加生日，并使用代理将生日添加到生日表格视图控制器的生日数组中，以便显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用程序再重新启动，生日信息依然会显示出来。为了保存生日信息，你将使用我们在项目初期就设置好的 Core Data。

在生日对象创建后，➊处的代码将通过 addBirthdayViewController(_:didAddBirthday:)方法将它传回给代理。

太棒了！你已经完成了对“添加生日”视图控制器的修改。现在它有一个代理，会监听生日被保存的调用。运行应用程序看看会发生什么。

嗯……似乎没什么变化。当你添加一个生日时，你依然没有看到它在生日表格视图控制器中显示出来。发生了什么事？

#### 通过设置代理连接两个控制器

还有一件事你需要做。生日表格视图控制器是一个 AddBirthdayViewControllerDelegate，而添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存与之通信的代理，尤其是在生日保存时。但我们从未明确将代理属性设置为生日表格视图控制器。因此，现在是时候连接这两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除/*和*/注释符号，取消注释该方法。

当生日表格视图控制器放弃屏幕并且应用程序通过故事板 segue 切换到另一个视图控制器时，这个方法会自动调用。我们将使用这个方法将生日表格视图控制器传递给“添加生日”视图控制器，以设置其为“添加生日”视图控制器的代理。在 prepare(for:sender:)方法中写下以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的委托为生日表视图控制器只需要三行代码。首先，你需要能够从 segue 参数中获取到 AddBirthdayViewController 对象。Xcode 已经留下了一个注释，提示你可以如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，指向正在准备的 segue 的另一端，但对于这个应用来说，目标并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。所以你不期待在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊的代码让你得到了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定类型，我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，所以必须将其强制转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的一个具体子类。最后，当你得到 AddBirthdayViewController 时，你可以将委托设置为 self，当前是生日表视图控制器 ➌。

现在运行应用并添加一些生日！你在生日表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用并重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中进行。

### 你学到的内容

在本章中，你学习了如何创建一个表视图控制器来显示生日列表。你还学会了如何在添加生日视图控制器中添加生日，然后如何使用委托将生日添加到生日表视图控制器中的生日数组中，以便它能够被显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用再重新运行，生日仍会显示。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

很好！你已经完成了对添加生日视图控制器的修改。现在它有了一个委托，会监听生日被保存的事件。运行应用程序，看看会发生什么。

嗯。。。似乎没有什么变化。当你添加生日时，你仍然看不到它出现在生日表视图控制器中。怎么回事？

#### 通过设置委托连接两个控制器

还有一件事你需要做。Birthdays 表格视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，它保存了与之通信的 delegate，当生日被保存时会与其交互。但我们从未明确将 delegate 属性设置为 Birthdays 表格视图控制器。所以现在是时候建立我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的导航部分，有一个已被注释掉的方法，名为 prepare(for:sender:) 。通过删除 /* 和 */ 注释符号来取消注释该方法。

当 Birthdays 表格视图控制器放弃其屏幕并且应用通过 storyboard segue 转到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将 Birthdays 表格视图控制器传递给 Add Birthday 视图控制器，并将其设置为 Add Birthday 视图控制器的 delegate。请在 prepare(for:sender:) 方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需三行代码即可将 Add Birthday 视图控制器的 delegate 设置为 Birthdays 表格视图控制器。首先，你需要能够从 segue 参数中获取 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，它位于准备中的 segue 的另一端，但这个应用的 destination 并不是 AddBirthdayViewController。

在第九章中，你将 Add Birthday 视图控制器嵌入到一个导航控制器中，这样就可以拥有一个带有取消和保存按钮的导航栏。所以你不会期望在 segue 的另一端找到 Add Birthday 视图控制器。而是，destination 是一个包含 Add Birthday 视图控制器的 UINavigationController。在 ➊ 这一行，你获取了 navigationController 。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是一个特定类型的视图控制器，因此我们需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其强制转换为 AddBirthdayViewController，以表明该控制器是 UIViewController 的特定子类。最后，当你获得 AddBirthdayViewController 时，可以将 delegate 设置为 self ，也就是当前的 Birthdays 表格视图控制器 ➌ 。

现在运行应用并添加一些生日！你在 Birthdays 表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完成。如果你退出应用后重新启动，之前的生日信息会消失。我们仍然需要将生日信息保存到设备中，这将在第十二章中进行讲解。

### 你学到了什么

在本章中，你学会了如何制作一个表视图控制器来显示你的生日列表。你还学会了如何在 Add Birthday 视图控制器中添加生日，并通过使用代理将生日添加到 Birthdays 表视图控制器中的生日数组，以便显示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使退出应用后重新启动，生日信息依然会显示。为了保存生日信息，我们将使用在项目开始时设置的 Core Data。

嗯……似乎变化不大。当你添加生日后，仍然无法在 Birthdays 表视图控制器中看到它。怎么回事？

#### 通过设置代理连接两个控制器

还有最后一步。Birthdays 表视图控制器是一个 AddBirthdayViewControllerDelegate，而 Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，保存着当生日被保存时与之通信的代理。但我们从未特别指定代理属性为 Birthdays 表视图控制器。因此，是时候将这两个视图控制器之间的通信管道连接起来了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个被注释掉的方法，叫做 prepare(for:sender:)。通过删除/*和*/来取消注释这个方法。

每当 Birthdays 表视图控制器退出屏幕并且应用通过 Storyboard segue 切换到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将 Birthdays 表视图控制器传递到 Add Birthday 视图控制器，并将其设置为 Add Birthday 视图控制器的代理。请在 prepare(for:sender:)方法中写下以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码就能将 Add Birthday 视图控制器的代理设置为 Birthdays 表视图控制器。首先，你需要通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 已经在注释中提示了如何实现这一点。UIStoryboardSegue 有一个名为 destination 的属性，指向正在准备的 segue 的目标视图控制器，但这个应用中的目标并不是 AddBirthdayViewController。

在第九章，你将 Add Birthday 视图控制器嵌入到一个导航控制器中，以便你可以拥有带有取消和保存按钮的导航栏。因此，你不期望在 segue 的另一端找到 Add Birthday 视图控制器。相反，目标是一个包含 Add Birthday 视图控制器的 UINavigationController。➊的这一行让你得到了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是特定类型的视图控制器，因此需要使用 as 将其强制转换为 UINavigationController。

接下来，你可以获取 Add Birthday 视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此需要将其强制转换为 AddBirthdayViewController，以指明这个控制器是 UIViewController 的一个特定子类。最后，当你有了 AddBirthdayViewController 时，可以将委托设置为 self，即当前的 Birthdays 表格视图控制器 ➌。

现在运行应用并添加一些生日！你在 Birthdays 表格视图控制器中看到什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用并重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在这一章中，你学会了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在 Add Birthday 视图控制器中添加生日，然后如何使用委托将生日添加到 Birthdays 表格视图控制器中的生日数组，以便它能够被显示。

在第十二章，你将学习如何将生日保存到你的设备中，以便在你退出应用并重新启动时，它们仍然显示。为了保存生日，你将使用 Core Data，这是我们在项目开始时设置的。

#### 通过设置委托连接两个控制器

还有一件事需要完成。Birthdays 表格视图控制器是 AddBirthdayViewControllerDelegate，Add Birthday 视图控制器有一个 AddBirthdayViewControllerDelegate 属性，用来保存当生日被保存时它所沟通的委托。但我们从未专门将委托属性设置为 Birthdays 表格视图控制器。所以现在是时候连接两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个被注释掉的方法叫 prepare(for:sender:)。通过删除/*和*/，取消注释该方法。

每当**生日表格视图控制器**放弃屏幕并且应用程序通过故事板 segue 转换到另一个视图控制器时，此方法会自动调用。我们将使用此方法将生日表格视图控制器传递给**添加生日**视图控制器，以将其自身设置为添加生日视图控制器的代理。在 prepare(for:sender:) 方法中编写以下内容：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的代理为生日表格视图控制器需要三行代码。首先，你需要能够从 segue 参数中获取到 AddBirthdayViewController 对象。Xcode 已经留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 在 segue 的另一端有一个 destination 属性，这里正在准备的 segue 目标，但对于这个应用程序，目标并不是 AddBirthdayViewController。

在第九章中，你将**添加生日**视图控制器嵌入到导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。所以你不会在 segue 的另一端找到添加生日视图控制器，而是目标是一个包含添加生日视图控制器的 UINavigationController。➊这一行让你得到了 navigationController。代码 segue.destination 会返回一个 UIViewController，但是由于我们的 navigationController 是 UIViewController 的特定子类，因此我们需要使用 as 将其强制类型转换为 UINavigationController。

接下来，你可以获取**添加生日**视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其强制类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的特定子类。最后，当你拥有一个 AddBirthdayViewController 时，你可以将代理设置为 self，当前是生日表格视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序并再次运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在本章中，你学会了如何创建一个表格视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表格视图控制器中的生日数组中，以便显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用程序再重新运行，它们依然会显示出来。为了保存生日，你将使用我们在项目一开始就设置好的 Core Data。

你还需要做最后一件事。生日表视图控制器是一个 AddBirthdayViewControllerDelegate，添加生日视图控制器有一个 AddBirthdayViewControllerDelegate 类型的属性，用于存储它与之通信的委托，当生日被保存时会与该委托通信。但是我们从未明确设置该委托属性为生日表视图控制器。所以现在是时候建立我们两个视图控制器之间的通信管道了。

在 BirthdaysTableViewController 类的 Navigation 部分，有一个被注释掉的方法，名为 prepare(for:sender:)。通过删除 /* 和 */ 注释符号来取消注释该方法。

每当生日表视图控制器放弃其屏幕，并且应用程序通过 storyboard segue 切换到另一个视图控制器时，此方法会自动被调用。我们将使用这个方法将生日表视图控制器传递给添加生日视图控制器，以便将其设置为添加生日视图控制器的委托。在 prepare(for:sender:) 方法中编写以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置添加生日视图控制器的委托为生日表视图控制器，只需要三行代码。首先，你需要能够从 segue 参数获取到 AddBirthdayViewController 对象。Xcode 留下了一个注释，提示你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，它位于该方法中正在准备的 segue 的另一端，但对于这个应用程序来说，destination 并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到了一个导航控制器中，这样你就可以拥有带有取消和保存按钮的导航栏。因此，你不会期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。第 ➊ 行获取了 navigationController。代码 segue.destination 会返回一个 UIViewController，但由于我们的 navigationController 是 ViewController 的特定类型，因此我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 时，你可以将委托设置为 self，当前是生日表视图控制器 ➌。

现在运行应用并添加一些生日！你在“生日”表格视图控制器中看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用然后再次运行它，之前的生日会消失。我们仍然需要将生日保存到设备上，我们将在第十二章中完成这项工作。

### 你学到了什么

在本章中，你学习了如何制作一个表格视图控制器来显示你的生日列表。你还学习了如何在“添加生日”视图控制器中添加一个生日，并通过委托将该生日添加到“生日”表格视图控制器中的生日数组中，以便可以显示出来。

在第十二章中，你将学习如何将生日保存到你的设备上，这样即使退出应用并重新运行，它们仍然会显示。为了保存生日，你将使用我们在项目开始时设置的 Core Data。

在“BirthdaysTableViewController”类的“Navigation”部分，有一个已被注释掉的方法`prepare(for:sender:)`。通过删除围绕它的/*和*/来取消注释该方法。

每当“生日”表格视图控制器放弃屏幕并且应用通过 storyboard segue 转到另一个视图控制器时，这个方法会自动被调用。我们将使用这个方法将“生日”表格视图控制器传递给“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的委托。在`prepare(for:sender:)`方法中写入以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需要三行代码，就能将“添加生日”视图控制器的委托设置为“生日”表格视图控制器。首先，你需要能够从 segue 参数中获取到`AddBirthdayViewController`对象。Xcode 在注释中给出了提示，说明如何做到这一点。`UIStoryboardSegue`有一个名为`destination`的属性，它是正在这个方法中准备的 segue 的目标，但这个应用的目标并不是`AddBirthdayViewController`。

在第九章中，你将“添加生日”视图控制器嵌入到一个导航控制器中，这样你就可以拥有一个带有“取消”和“保存”按钮的导航栏。所以，你不期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的`UINavigationController`。➊处的代码让你得到了`navigationController`。`segue.destination`将返回一个`UIViewController`，但由于我们的`navigationController`是一个特定类型的视图控制器，我们需要通过`as`将其强制转换为`UINavigationController`。

接下来，你可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController ➋ 。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性是 UIViewController 类型，所以必须将其强制转换为 AddBirthdayViewController，以表示这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 后，你可以将代理设置为 self，也就是当前的“生日”表视图控制器 ➌ 。

现在运行应用并添加一些生日！你在“生日”表视图控制器中看到了什么？生日！生日！生日！不过，我们还没有完全完成。如果你退出应用再重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，这将在第十二章中实现。

### 你学到了什么

在本章中，你学习了如何创建一个表视图控制器来显示生日列表。你还学习了如何在“添加生日”视图控制器中添加一个生日，然后通过代理将这个生日添加到“生日”表视图控制器的生日数组中，以便能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用并重新运行，它们也会显示出来。要保存生日，你将使用我们在项目开始时设置的 Core Data。

每当“生日”表视图控制器放弃其屏幕，并且应用通过故事板 segue 切换到另一个视图控制器时，此方法会自动被调用。我们将使用此方法将“生日”表视图控制器传递给“添加生日”视图控制器，并将其设置为“添加生日”视图控制器的代理。请在 prepare(for:sender:) 方法中编写以下代码：

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

设置“添加生日”视图控制器的代理为“生日”表视图控制器只需要三行代码。首先，你需要能够通过 segue 参数访问到 AddBirthdayViewController 对象。Xcode 已经在注释中给出了提示，告诉你如何做到这一点。UIStoryboardSegue 有一个名为 destination 的属性，指向正在准备中的 segue 目标，但对于这个应用，目标并不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到导航控制器中，这样你就可以拥有一个包含“取消”和“保存”按钮的导航栏。所以你不会期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊行代码获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，所以我们需要使用 as 将其强制类型转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其强制类型转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你有了 AddBirthdayViewController 后，你可以将委托设置为 self，self 目前是“生日”表格视图控制器 ➌。

现在运行应用并添加一些生日！你在“生日”表格视图控制器中看到了什么？生日！生日！生日！不过，我们还没完全完成。如果你退出应用并再次运行，之前的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到的内容

在本章中，你学习了如何创建一个表格视图控制器来显示生日列表。你还学习了如何在“添加生日”视图控制器中添加一个生日，然后如何使用委托将生日添加到“生日”表格视图控制器中的生日数组，以便能够显示出来。

在第十二章，你将学习如何将生日保存到设备中，这样即使你退出应用程序并再次运行，它们依然能够显示。为了保存生日，你将使用我们在项目开始时就设置好的 Core Data。

*BirthdaysTableViewController.swift*

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

需要三行代码将“添加生日”视图控制器的委托设置为“生日”表格视图控制器。首先，你需要能够从 segue 参数中访问到 AddBirthdayViewController 对象。Xcode 在注释中提示了如何做到这一点。一个 UIStoryboardSegue 有一个叫做 destination 的属性，它表示在这个方法中正在准备的 segue 的目标，但对于这个应用来说，目标不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到导航控制器中，这样你就可以拥有一个带有取消和保存按钮的导航栏。因此，你不会期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。在➊这一行，你获取了 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的特定子类，因此需要使用`as`将其强制类型转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是导航控制器➋的 topViewController。topViewController 就是在导航控制器中显示的视图控制器，但它的属性是 UIViewController 类型，因此必须将其强制类型转换为 AddBirthdayViewController，以表示该控制器是 UIViewController 的特定子类。最后，当你获得 AddBirthdayViewController 时，可以将代理设置为 self，这里 self 当前是生日表格视图控制器➌。

现在运行应用并添加一些生日！在生日表格视图控制器中你看到了什么？生日！生日！生日！不过我们还没有完全完成。如果你退出应用程序然后再次运行它，之前的生日将会消失。我们仍然需要将生日保存到设备中，我们将在第十二章中实现这一点。

### 你学到的内容

在本章中，你学习了如何创建一个表格视图控制器来显示你的生日列表。你还学习了如何在添加生日视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表格视图控制器中的生日数组中，以便能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使退出应用程序并重新运行，它们依然会显示出来。为了保存生日，你将使用 Core Data，这是我们在项目开始时设置的内容。

```
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

    // Get the new view controller using segue.destination

   ➊
 let
 navigationController = segue.destination
 as
 ! 

         UINavigationController

  ➋
 let
 addBirthdayViewController = 

         navigationController.topViewController
 as
 ! 

         AddBirthdayViewController

  ➌
 addBirthdayViewController.delegate
 = self

}

```

只需三行代码就可以将添加生日视图控制器的代理设置为生日表格视图控制器。首先，你需要能够从 segue 参数获取到 AddBirthdayViewController 对象。Xcode 已经在注释中留下了提示，告诉你如何实现这一点。UIStoryboardSegue 有一个名为 destination 的属性，用于指向正在准备的 segue 的目标视图控制器，但对于本应用程序来说，目标视图控制器并不是 AddBirthdayViewController。

在第九章中，你将添加生日视图控制器嵌入到一个导航控制器中，这样你就可以拥有带有取消和保存按钮的导航栏。因此，你并不期望在 segue 的另一端找到添加生日视图控制器。相反，目标是一个包含添加生日视图控制器的 UINavigationController。➊处的代码可以让你获取到 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是 UIViewController 的一个特定类型，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取添加生日视图控制器，它是 navigationController ➋ 的 topViewController。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，所以必须将其类型转换为 AddBirthdayViewController，以表示该控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 时，可以将代理设置为 self，而 self 当前是生日表视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表视图控制器中看到了什么？生日！生日！生日！不过我们还没有完成。如果你退出应用程序然后重新运行它，之前的生日会消失。我们仍然需要将生日保存到设备中，这将在第十二章中完成。

### 你学到了什么

在这一章中，你学会了如何创建一个表视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表视图控制器中的生日数组中，以便它能够显示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使你退出应用程序并重新运行它，生日信息仍然会显示。为了保存生日，你将使用在我们项目开始时设置的 Core Data。

设置添加生日视图控制器的代理为生日表视图控制器需要三行代码。首先，你需要能够通过 segue 参数获取 AddBirthdayViewController 对象。Xcode 在注释中提示了如何做到这一点。UIStoryboardSegue 有一个属性叫做 destination，表示该方法中正在准备的 segue 的目标，但是对于这个应用程序，目标并不是 AddBirthdayViewController。

在第九章中，你将“添加生日”视图控制器嵌入到了导航控制器中，这样你就可以拥有带有“取消”和“保存”按钮的导航栏。因此，你不应该期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊ 这一行代码可以获取到 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是一种特定类型的视图控制器，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取到“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 只是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此必须将其强制转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你拥有了 AddBirthdayViewController 后，你可以将其代理设置为 self，当前的 self 是生日表视图控制器 ➌。

现在运行应用程序并添加一些生日！你在生日表视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用程序然后重新运行，它之前的生日将会消失。我们还需要将生日保存到设备中，我们将在第十二章中进行处理。

### 你学到的内容

在这一章中，你学习了如何创建一个表视图控制器来显示你的生日列表。你还学会了如何在“添加生日”视图控制器中添加生日，并且如何使用代理将生日添加到生日表视图控制器中的生日数组中，以便它可以显示出来。

在第十二章中，你将学习如何将生日保存到你的设备中，这样即使你退出应用程序然后重新运行，它们也能显示出来。为了保存生日，你将使用 Core Data，这是我们在项目开始时就已经设置好的。

在第九章中，你将“添加生日”视图控制器嵌入到了导航控制器中，这样你就可以拥有带有“取消”和“保存”按钮的导航栏。因此，你不应该期望在 segue 的另一端找到“添加生日”视图控制器。相反，目标是一个包含“添加生日”视图控制器的 UINavigationController。➊ 这一行代码可以获取到 navigationController。代码 segue.destination 将返回一个 UIViewController，但由于我们的 navigationController 是一种特定类型的视图控制器，我们需要使用 as 将其类型转换为 UINavigationController。

接下来，你可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此需要将其强制转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 时，你可以将 delegate 设置为 self，而 self 当前是“生日”表格视图控制器 ➌。

现在运行应用并添加一些生日！你在“生日”表格视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用并重新运行，之前的生日将消失。我们仍然需要将生日保存到设备中，这将在第十二章中进行。

### 你学到了什么

在这一章中，你学习了如何创建一个表格视图控制器来展示你的生日列表。你还学习了如何在“添加生日”视图控制器中添加一个生日，然后如何使用委托将生日添加到“生日”表格视图控制器中的生日数组中，以便它能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，以便即使退出应用并重新运行，生日仍然能够显示出来。为了保存生日，你将使用 Core Data，这是我们在项目开始时设置的。

接下来，你可以获取“添加生日”视图控制器，它是 navigationController 的 topViewController ➋。topViewController 就是当前在 navigationController 中显示的视图控制器，但它的属性类型是 UIViewController，因此需要将其强制转换为 AddBirthdayViewController，以表明这个控制器是 UIViewController 的一个特定子类。最后，当你获得 AddBirthdayViewController 时，你可以将 delegate 设置为 self，而 self 当前是“生日”表格视图控制器 ➌。

现在运行应用并添加一些生日！你在“生日”表格视图控制器中看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用并重新运行，之前的生日将消失。我们仍然需要将生日保存到设备中，这将在第十二章中进行。

### 你学到了什么

在这一章中，你学习了如何创建一个表格视图控制器来展示你的生日列表。你还学习了如何在“添加生日”视图控制器中添加一个生日，然后如何使用委托将生日添加到“生日”表格视图控制器中的生日数组中，以便它能够显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用并重新运行，生日也能显示出来。为了保存生日，你将使用 Core Data，这是我们在项目一开始就设置好的。

现在运行应用并添加一些生日！在生日表视图控制器中你看到了什么？生日！生日！生日！不过我们还没完全完成。如果你退出应用再重新运行，之前的生日将会消失。我们仍然需要将生日保存到设备中，这部分内容将在第十二章中讲解。

### 你学到了什么

在这一章，你学会了如何创建一个表视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表视图控制器中的生日数组，以便显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用并重新运行，生日也能显示出来。为了保存生日，你将使用 Core Data，这是我们在项目一开始就设置好的。

### 你学到了什么

在这一章，你学会了如何创建一个表视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表视图控制器中的生日数组，以便显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用并重新运行，生日也能显示出来。为了保存生日，你将使用 Core Data，这是我们在项目一开始就设置好的。

在这一章，你学会了如何创建一个表视图控制器来显示你的生日列表。你还学会了如何在添加生日视图控制器中添加一个生日，然后如何使用代理将生日添加到生日表视图控制器中的生日数组，以便显示出来。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用并重新运行，生日也能显示出来。为了保存生日，你将使用 Core Data，这是我们在项目一开始就设置好的。

在第十二章中，你将学习如何将生日保存到设备中，这样即使你退出应用并重新运行，生日也能显示出来。为了保存生日，你将使用 Core Data，这是我们在项目一开始就设置好的。
