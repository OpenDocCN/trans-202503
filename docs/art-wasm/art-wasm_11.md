# 11

AssemblyScript

![](img/chapterart.png)

AssemblyScript 是一种高级语言，专门设计用于编译成 WebAssembly 或 WAT。AssemblyScript 比 WAT 更具表现力，但仍然可以编译成 WAT。当你使用 AssemblyScript 时，你失去了一些使用 WAT 时可以进行的细致优化控制，但编写起来要快得多。

本章我们将通过创建一个简单的 `AddInt``s` 函数开始，类似于我们在第一章中创建的 `AddInt`。我们将编写一个 AssemblyScript 的 Hello World 应用，并将其编译成 WAT，查看 AssemblyScript 编译器生成的 WebAssembly。我们将研究 AssemblyScript 如何使用长度前缀字符串，然后安装 AssemblyScript 加载器，看看它如何简化在 AssemblyScript 和 JavaScript 之间传递字符串。我们将通过编写一个字符串连接应用来将字符串传入 AssemblyScript。我们还将探索 AssemblyScript 中的面向对象编程（OOP）。我们将创建几个类来演示类继承，并讨论 `private` 属性，这些属性可以防止 AssemblyScript 将属性导出到嵌入环境。接下来，我们将编写 JavaScript，使我们能够直接创建 `public`、`private` 和 `protected` 成员，并使用 AssemblyScript 加载器。然后，我们将比较直接调用与加载器函数调用的性能。

AssemblyScript 团队设计时参考了 TypeScript 和 JavaScript。与 WAT 不同，AssemblyScript 是一种具有类、字符串和数组等特性的高级语言。除了高级特性外，AssemblyScript 还允许用户使用类似 WAT 的低级内存命令进行编程。AssemblyScript 提供了一个*命令行界面 (CLI)*，可以将 AssemblyScript 编译成 WebAssembly 模块，并在 JavaScript 应用程序中使用。

对于希望使用 WebAssembly 来提高 JavaScript 应用程序性能的 JavaScript 开发者来说，AssemblyScript 是一个很好的工具。不幸的是，正如 WebAssembly 中的所有内容一样，仅仅调整 TypeScript 直到它能够通过 AssemblyScript 编译器编译，并不一定会带来显著的性能提升。了解 AssemblyScript 在幕后是如何工作的，可以让你用看似 JavaScript 的语言编写代码，但运行时表现得像 C++。为了获得这种理解，我们将把 AssemblyScript 代码编译成 WAT，以探索 AssemblyScript 编译器的输出。

## AssemblyScript CLI

使用以下命令安装 AssemblyScript：

```
npm install assemblyscript -g
```

`npm` 命令全局安装 AssemblyScript，允许你从命令行使用 AssemblyScript 编译器 `asc` 命令。运行 `asc -h` 会提供编译器命令示例和选项的列表。

我不会解释所有的命令行参数，但会提到一些有用的参数。`-O`选项与第九章中的`wasm-opt`优化方式相同。你在`-O`后跟一个数字 0 至 3、s 或 z，指示编译器进行优化，优化目标是大小还是性能，以及应用多少优化。`-o`标志后跟*.wat*文件的名称时，会从 AssemblyScript 生成 WAT 代码；而后跟*.wasm*文件的名称时，会生成 WebAssembly 二进制模块。`--sourceMap`标志创建一个源映射文件，帮助你从浏览器调试 AssemblyScript。

我们首先创建一个简单的 AssemblyScript 模块。创建文件*as_add.ts*并添加清单 11-1 中的代码。这是第一章中`AddInt`函数的一个简化版本。

**as_add.ts**

```
1 export function AddInts(2a: i32, 3b: i32 ): i32 {
  4 return a + b;
}
```

清单 11-1：两个整数相加

我们使用`export` 1 关键字将`function`暴露给嵌入的 JavaScript。它接受两个`i32`类型的参数`a` 2 和`b` 3，并返回`a + b` 4，作为`i32`类型。使用清单 11-2 中的命令编译 *as_add.ts*。

```
asc as_add.ts -Oz -o as_add.wat
```

清单 11-2：将`AddInt`s`编译为 WAT

`-Oz`标志使输出的二进制文件尽可能小。最后一个标志`-o` `as_add.wat`告诉编译器输出 WAT 代码。或者，我们也可以编译一个*.wasm*文件，比如*as_add.wasm*，它将输出 WebAssembly 二进制文件。当我们查看输出的*as_add.wat*文件时，会看到清单 11-3 中的 WAT 代码。

**as_add.wat**

```
(module
  (type $i32_i32_=>_i32 (func (param i32 i32) (result i32)))
  (memory $0 0)
1 (export "AddInts" (func $as_add/AddInts))
  (export "memory" (memory $0))
2 (func $as_add/AddInts (param $0 i32) (param $1 i32) (result i32)
  3 local.get $0
  4 local.get $1
  5 i32.add
  )
)
```

清单 11-3：编译为 WAT 的 AssemblyScript `AddInts`函数

在 AssemblyScript 中编写代码比直接在 WAT 中编写代码要容易得多。这段代码生成了`AddInts` 1 函数，它导出了一个接受两个`i32`参数并返回一个`i32`的函数。输出函数使用`local.get`来获取第一个 3 和第二个 4 参数，并使用`i32.add`5 来将这两个值相加。

AssemblyScript 是一种美丽的小语言，对于熟悉 TypeScript 或 JavaScript 的人来说，相对容易学习。理解 WAT 是从你的 AssemblyScript 或你选择的任何高级语言中获取最大收益的好方法，尤其是用于 WebAssembly 开发时。

## Hello World AssemblyScript

接下来，我们将构建一个 AssemblyScript 版本的 WAT Hello World 应用程序，参考第二章的示例。创建一个名为*as_hello.ts*的新 AssemblyScript 文件，并添加清单 11-4 中的代码。

**as_hello.ts**

```
1 declare function console_log( msg: string ):void;

2 export function HelloWorld():void {
3 console_log("hello world!");
}
```

清单 11-4：一个 Hello World 的 AssemblyScript 应用

AssemblyScript 中的函数声明必须与传入 WebAssembly 模块的 JavaScript 函数相对应。因此，我们需要通过 `importObject` 传入一个将字符串记录到控制台的函数。`declare` `function` 1 从 JavaScript 导入了 `console_log` 函数。这个函数将把一个字符串从 AssemblyScript 传回调用的 JavaScript 应用程序。我们创建了一个 `export` `function`，名为 `HelloWorld` 2，它调用导入的 `console_log` 3 函数，并传入字符串 `"hello world!"`。在将其编译成 WebAssembly 模块之前，我们将使用 `asc` 编译一个 WAT 文件，这样我们就可以查看创建的 WebAssembly（列表 11-5）。

```
asc as_hello.ts -Oz -o as_hello.wat
```

列表 11-5：将 *as_hello.ts* AssemblyScript 文件编译为 *as_hello.wat*。

然后，我们可以打开 *as_hello.wat* 文件，在 列表 11-6 中查看 AssemblyScript 生成的 WebAssembly。

```
;; The comments were added by the author and not generated by asc 1
(module
  (type $none_=>_none (func))
  (type $i32_=>_none (func (param i32)))
 ;; the declare command at the top of the AssemblyScript created an import
 ;; that imports the console_log function inside of the outer as_hello
 ;; object.  AssemblyScript requires its imports in the AssemblyScript file name
 ;; not including the .ts extension
  (import "as_hello" "console_log" (func $as_hello/console_log (param i32))) 2
 ;; using a string automatically creates the memory expression
  (memory $0 1) 3
  ;; the data line below wraps because the line is too long
 ;; The "hello world!" string is preceded by a header and has a hex 00 byte in
 ;; between every letter in the string.  This is because AssemblyScript uses
 ;; the UTF-16 character set instead of ASCII as we did when we were manipulating
 ;; string data in WAT.
  (data (i32.const 16) 4
    "\18\00\00\00\01\00\00\00\01\00\00\00\18\00\00\00h\00e\00l\00l\00o\00 \00w\00o\00r\00l\00d\00!")
  (export "memory" (memory $0))
 ;; The module exports our function with the AssemblyScript name we gave it.
  (export "HelloWorld" (func $as_hello/HelloWorld)) 5
 ;; the function name we gave AssemblyScript is prefixed by the name of our file
 ;; without the .ts extension
  (func $as_hello/HelloWorld (; 1 ;) 6
 ;; 32 is the location in linear memory of the 'h' byte in "hello world"
  i32.const 32 7
 ;; the console_log function is called passing in the location of "hello world"
 ;; in linear memory
  call $as_hello/console_log 8
  )
)
```

列表 11-6：从 *as_hello.ts* AssemblyScript 生成的 *as_hello.wat* 文件。

我已添加注释以澄清代码 1。这个模块导入了 `console_log` 2，并将其包装在对象 `as_hello` 中，这是我们 AssemblyScript 文件的名称（不包括 *.ts* 扩展名）。这是 AssemblyScript 对 `importObject` 使用的命名约定；当你编写 JavaScript 时，必须在导入的对象中相应地命名你的对象。

AssemblyScript 创建了一个 `memory` 3 表达式来存储字符串数据。字符串有一个前缀头部，包含了字符串的长度，AssemblyScript 使用它来在 WebAssembly 内部操作数据。字符串 `data` 4 每个字符使用两个字节，因为 AssemblyScript 使用的是 UTF-16 编码，在这个例子中，每个字符之间由一个空字节 `\00` 分隔。UTF-16 是 Unicode 字符集的 16 位版本，允许使用许多 ASCII 中不可用的附加字符。

在数据表达式之后，WAT 导出了 5 个函数，函数的名称是我们在 AssemblyScript 中为其指定的，前面加上了 `$` 字符，并去掉了 *.ts* 扩展名。`HelloWorld` 6 函数调用了 `console_log` 8，传入了我们 `hello world!` 字符串在线性内存中的第一个字符的位置，即 `32` 7。

使用我们编译好的 WAT 文件，我们可以在 列表 11-7 中使用 `asc` 命令来编译我们的 WebAssembly 模块。

```
asc as_hello.ts -Oz -o as_hello.wasm
```

列表 11-7：将我们的 AssemblyScript 编译为 WebAssembly 二进制文件。

接下来，我们编写我们的 JavaScript。

### 我们的 Hello World 应用的 JavaScript

当前，我们有一个名为 *as_hello.wasm* 的 WebAssembly 模块。接下来，我们将编写一个 Node.js 应用程序来加载并运行这个模块。在本节中，我们将像在第五章中那样解码字符串数据，以了解 AssemblyScript 如何将字符串传输到 JavaScript。然后，我们将使用 AssemblyScript 加载工具为我们完成这项工作。

首先，我们将编写一个函数，通过 WebAssembly 模块传递的索引从线性内存中提取字符串数据。AssemblyScript 将字符串的长度存储在字符串数据之前的四个字节中。我们可以使用 `Uint32Array` 获取字符串长度的整数，并利用该长度在 JavaScript 中创建我们的字符串。创建一个名为 *as_hello.js* 的文件，并添加 清单 11-8 中的代码。

**as_hello.js**

```
const fs = require('fs');
const bytes = fs.readFileSync(__dirname + '/as_hello.wasm');

// The memory object is exported from AssemblyScript
1 var memory = null;

let importObject = {
```

// 模块的文件名（不带扩展名）用作外部对象名称

```
2 as_hello: {
 // AssemblyScript passes a length prefixed string with a simple index
 3 console_log: function (index) {
 // in case this is called before memory is set
      if (memory == null) {
        console.log('memory buffer is null');
        return;
      }

    4 const len_index = index - 4;

 // must divide by 2 to get from bytes to 16-bit unicode characters
    5 const len = new Uint32Array(memory.buffer, len_index, 4)[0];
    6 const str_bytes = new Uint16Array(memory.buffer,
        index, len);

 // decode the utf-16 byte array into a JS string
    7 const log_string = new TextDecoder('utf-16').decode(str_bytes);
      console.log(log_string);
    }
  },
  env: {
    abort: () => { } 
  }
};

(async () => {
  let obj = await WebAssembly.instantiate(new Uint8Array(bytes),
    importObject);

 // memory object exported from AssemblyScript
8 memory = obj.instance.exports.memory;
 // call the HelloWorld function
9  obj.instance.exports.HelloWorld();
})();
```

清单 11-8：从 JavaScript 调用 AssemblyScript 的 `HelloWorld`

AssemblyScript 生成的 WebAssembly 模块总是会创建并导出它自己的内存，除非使用 `--importMemory` 标志进行编译。默认情况下，AssemblyScript 会在 WebAssembly 模块中创建自己的线性内存。因此，在 JavaScript 中，我们不创建线性内存对象。相反，我们创建一个名为 `memory` 1 的 `var`，稍后我们会将其设置为 WebAssembly 模块导出的线性内存对象。

在 `importObject` 中，持有导入数据的对象必须与导入它的 AssemblyScript 文件同名：对于我们的 AssemblyScript 文件 *as_hello.ts*，就是 `as_hello` 2。在 `as_hello` 中是 `console_log` 3，当从 AssemblyScript 调用时会传递一个字符串参数。当 WebAssembly 模块调用 `as_hello` 时，JavaScript 函数只接收到一个指向 WebAssembly 线性内存的数字索引，该索引是字符串数据部分（包含长度前缀的字符串）的位置，这是 AssemblyScript 用来定义其字符串类型的方式。

长度是一个 32 位整数，位于 `index` 前的四个字节中。为了获取长度整数的索引，我们从字符串索引中减去四。通过创建新的 `Uint32Array`，传入 `memory.buffer`、`len_index` 4 和字节数 `4`，我们可以使用线性内存中存储的长度值。由于 `Uint32Array` 5 是一个 32 位整数数组，我们需要使用 `[0]` 获取数组中的第一个也是唯一的项。

我们使用 `new Uint16Array` 6 从线性内存中获取字符串字节数据，并通过使用新的 `TextDecoder` 将字节数组转换为 JavaScript 字符串，该解码器用于解码 `utf-16` 文本数据。代码调用 `TextDecoder` 7 的 `decode` 函数，传入字符串数据，返回的 JavaScript 字符串随后被打印到控制台。我们使用一个立即执行函数表达式（IIFE）来实例化 AssemblyScript 的 WebAssembly 模块。请注意，在调用 `HelloWorld` 9 函数之前，我们必须将 `memory` 8 对象设置为从 WebAssembly 模块导出的内存对象。`console_log` 函数使用 `memory` 对象，如果没有设置，调用 `HelloWorld` 将不会产生任何效果。

幸运的是，有一种更简单的方法可以在 AssemblyScript 和 JavaScript 之间传递字符串数据，那就是使用 AssemblyScript 加载器。这个代码是由 AssemblyScript 团队提供的。在“加载器与直接 WebAssembly 调用的性能对比”*部分，我们将看到是否能通过我们编写的代码来提升 AssemblyScript 加载器的性能。

### 使用 AssemblyScript 加载器的 Hello World

AssemblyScript 加载器是一组来自 AssemblyScript 团队的助手函数，旨在简化从 JavaScript 调用 AssemblyScript 的过程。我们将比较之前编写的代码与使用 AssemblyScript 加载器编写的代码。最初，我们将考虑易用性，之后再探讨使用或不使用加载器的性能影响。

我们使用 AssemblyScript 加载器将一个字符串从 AssemblyScript 传回 JavaScript。加载器助手函数将来自 WebAssembly 的索引转换为 JavaScript 字符串。现在，我们将使用 `npm` 安装加载器：

```
npm install @assemblyscript/loader --save
```

现在，我们将创建一个 JavaScript 文件来加载和运行我们的 WebAssembly 模块。创建一个名为 *as_hello_loader.js* 的文件，并添加 Listing 11-9 中的代码。

**as_hello_loader.js**

```
1 const loader = require("@assemblyscript/loader");
const fs = require('fs');
2 var module;

const importObject = {
3 as_hello: {
  4 console_log: (str_index) => {
    5 console.log(module.exports.__getString(str_index));
    }
  }
};

(async () => {
  let wasm = fs.readFileSync('as_hello.wasm');
6 module = await loader.instantiate(wasm, importObject);
7 module.exports.HelloWorld();
})();
```

Listing 11-9: 使用 AssemblyScript 加载器调用 WebAssembly 模块

这个 JavaScript 函数首先需要 1 个 AssemblyScript 加载器。我们使用这个加载器对象来加载声明为全局的 `module` 2 对象。`module` 对象是一个 AssemblyScript 加载器模块，其中包含额外的 AssemblyScript 加载器助手函数。在 `importObject` 中是一个子对象，命名为 `as_hello` 3，代表我们的 AssemblyScript 模块。这里是 AssemblyScript 代码期望找到导入函数的位置。在 `as_hello` 对象中有一个 `console_log` 4 函数，它将字符串索引 `str_index` 作为唯一参数。这个函数使用由加载器创建的 `module` 对象上的 `__getString` 5 函数。当传入字符串索引时，`__getString` 函数从线性内存中检索一个 JavaScript 字符串。这个字符串通过 `console.log` 打印到控制台。IIFE 函数使用 AssemblyScript `loader` 6 对象加载一个 AssemblyScript 模块。最后，IIFE 调用 `HelloWorld` 7 函数。当你使用 `node` 运行这个 JavaScript 文件时，你会在 Listing 11-10 中看到输出。

```
hello world!
```

Listing 11-10: AssemblyScript hello world 应用的输出

使用 AssemblyScript 加载器使得 JavaScript 代码显著简化。稍后，在“加载器与直接 WebAssembly 调用的性能对比”部分，我们将探讨性能影响。

### AssemblyScript 字符串拼接

现在我们知道如何从 AssemblyScript 接收字符串，接下来我们将把一个字符串发送到 AssemblyScript 模块。这个函数将两个字符串用管道符号(`|`)连接起来。我们将使用加载器来简化 JavaScript 端的代码编写。字符串连接是 WAT 中很难直接实现的功能，但在 AssemblyScript 中非常简单。创建一个名为*as_concat.ts*的新文件，并在其中添加列表 11-11 中的代码。

**as_concat.ts**

```
1 export function cat( str1: string, str2: string ): string {
2 return str1 + "|" + str2;
}
```

列表 11-11：使用 AssemblyScript 连接字符串

我们导出一个`cat`函数，它接收两个字符串参数并返回一个字符串。此函数将两个字符串连接在一起，中间用管道符号(`|`)分隔。

现在我们可以使用列表 11-12 中的`asc`命令编译*as_concat.ts*。

```
asc as_concat.ts --exportRuntime -Oz -o as_concat.wasm
```

列表 11-12：使用`asc`编译*as_concat.ts*文件

我们传递了`--exportRuntime`标志，这对于将字符串传递到 WebAssembly 模块中是必需的。使用`--exportRuntime`进行编译时，会添加允许你从 JavaScript 调用`__allocString`函数的代码。如果我们未能导出运行时，应用执行时会出现以下错误：

```
TypeError: alloc is not a function
```

当你将*as_concat.ts*编译成 WAT 时，会注意到 WAT 文件比我们的*as_hello.ts*文件大得多。原因在于运行时添加了几个字符串函数，这些函数执行必要的任务，例如复制内存、连接字符串以及获取/设置字符串长度方法。

现在我们可以编写我们的 JavaScript 应用了。列表 11-13 中的代码会在线性内存中创建两个字符串，并调用 WebAssembly 函数`cat`。创建一个名为*as_concat.js*的新 JavaScript 文件，并在其中添加列表 11-13 中的代码。

**as_concat.js**

```
const fs = require('fs');
const loader = require("@assemblyscript/loader");

(async () => {
  let module = await loader.instantiate(fs.readFileSync('as_concat.wasm'));

  //__newString, __getString functions require
  //compile with --exportRuntime flag
1 let first_str_index = module.exports.__newString("first string");
2 let second_str_index = module.exports.__newString("second string");
3 let cat_str_index = module.exports.cat(first_str_index,second_str_index);
4 let cat_string = module.exports.__getString(cat_str_index);
5 console.log(cat_string);
})();
```

列表 11-13：JavaScript 使用 AssemblyScript 加载器调用`cat` AssemblyScript 函数。

我们在 WebAssembly 模块中定义的`cat`函数并不直接接收字符串作为参数，因此需要一个线性内存中的索引来获取字符串位置。`module.exports.__newString`加载器助手函数接收一个 JavaScript 字符串，将其复制到线性内存中，并返回一个索引供`module.cat`使用。我们调用`module.exports.__newString`两次，第一次传入`"first string"` 1，然后传入`"second string"` 2。每次调用都会返回一个索引，我们将其分别存储在`first_str_index`和`second_str_index`中。接下来，我们调用`module.exports.cat`，传入这些索引，并返回一个 JavaScript 字符串索引，我们将其存储在`cat_str_index` 3 中。然后，我们调用`module.exports.__getString` 4，传入`cat_str_index`，并将获取到的字符串存储在`cat_string` 5 中，最后输出到控制台。

现在我们有了 JavaScript 和 WebAssembly，我们可以使用`node`运行我们的应用：

```
node as_concat.js
```

下面是输出到控制台的内容：

```
first string|second string
```

AssemblyScript 还有很多内容值得探索。如你所见，AssemblyScript 在处理字符串时比 WAT 更加简单。虽然这并不能直接告诉你何时应该在 WebAssembly 中处理字符串数据，但它提供了这一选项。AssemblyScript，像 WebAssembly 一样，是一个快速发展的项目。花时间从项目主页[assemblyscript.org](http://assemblyscript.org)了解更多内容是值得的。

## 在 AssemblyScript 中使用面向对象编程（OOP）

在 WAT 格式中几乎不可能使用 OOP，但由于 AssemblyScript 是基于 TypeScript 的，它提供了更多的 OOP 选项。在本节中，我们将介绍 AssemblyScript 中 OOP 的一些基础知识，以及一些它的限制，这些限制可能会在未来的版本中不再适用。

我们从创建一个名为*vector.ts*的 AssemblyScript 文件开始。目前，AssemblyScript 是基于 TypeScript 文件格式的，这在大多数情况下都能正常工作。

Saule Cabrera 为 VS Code 创建了一个 AssemblyScript 语言服务器插件，插件可通过[`marketplace.visualstudio.com/items?itemName=saulecabrera.asls.`](https://marketplace.visualstudio.com/items?itemName=saulecabrera.asls.)下载。

接下来，我们将编写一个 AssemblyScript 的`Vector2D`类，用于存储类似于第八章碰撞检测应用程序中所写的碰撞器对象的坐标。我们将代码编译成 WAT，以便查看 AssemblyScript 编译器的输出。更好地理解编译器及其输出，在优化 WebAssembly 代码时非常有帮助。将清单 11-14 添加到你的文件中，以创建`Vector2D`类。

**vector.ts**

```
1 export class Vector2D {
2 x: f32;
3 y: f32;

4 constructor(x: f32, y: f32) {
    this.x = x;
    this.y = y;
  }

5 Magnitude(): f32 {
    return Mathf.sqrt(this.x * this.x + this.y * this.y);
  }
}
```

清单 11-14：在 AssemblyScript 中创建一个向量类

我们导出了一个名为`Vector2D`的类，它有两个属性，`x`和`y`。它还有一个`constructor`，用于从`x`和`y`参数创建一个新的`Vector2D`对象。`Magnitude`方法通过对`x`和`y`的平方求和并对该和取平方根来计算向量的大小。

如果你熟悉 TypeScript，你会注意到这段代码看起来与 TypeScript 中的`class`结构非常相似。然而，我们并没有使用 TypeScript 中的`number`类型，而是使用了`f32`类型来表示 32 位浮动点数。如果你在 AssemblyScript 中使用`number`类型，它实际上相当于使用`f64`类型的 64 位浮动点数，而在大多数情况下，`f64`的性能是 WebAssembly 类型中最差的。

以下命令使用`asc`将*vector.ts*编译成 WAT 文件：

```
asc vector.ts -o vector.wat
```

这会创建一个我们可以在 VS Code 中查看的 WAT 文件。要进行 `asc` 编译，我们传递 AssemblyScript 文件的名称，然后传递 `-o` 标志并指定输出文件的文件名 `vector.wat`。扩展名决定了输出是 WAT 文件还是 WebAssembly 二进制文件。打开 *vector.wat* 文件并稍微向下滚动，直到看到在 清单 11-15 中显示的导出内容。

**vector.wat**

```
...
  (export "memory" (memory $0))
  (export "Vector2D" (global $vector/Vector2D))
1 (export "Vector2D#get:x" (func $vector/Vector2D#get:x))
2 (export "Vector2D#set:x" (func $vector/Vector2D#set:x))
3 (export "Vector2D#get:y" (func $vector/Vector2D#get:y))
  (export "Vector2D#set:y" (func $vector/Vector2D#set:y))
4 (export "Vector2D#constructor" (func $vector/Vector2D#constructor))
5 (export "Vector2D#Magnitude" (func $vector/Vector2D#Magnitude))
...
```

清单 11-15：我们 WAT 文件中导出的函数

注意编译器如何为 `x` 2 和 `y` 3 属性生成 `get` 1 和 `set` 2 访问函数，并将它们导出，以便你可以从嵌入环境访问它们。这表明，当用户通过加载器设置对象属性时，它会调用 WebAssembly 模块中的一个函数。这意味着，如果你一次设置多个属性，可能需要考虑创建一个函数来一次性完成这一操作，以提高性能。这样，你就不需要多次调用 WebAssembly 模块的函数。你还可以看到 WebAssembly 模块导出了 `constructor` 4 和 `Magnitude` 5 函数。

如果你想从 JavaScript 中调用 WebAssembly 模块的函数，命名约定是非常重要的。所有方法都以类名和哈希符号（`#`）作为前缀（`Vector2D#`）。`set` 和 `get` 方法有一个后缀，表示它们设置或获取的属性，例如 `:x` 或 `:y`。要在不使用 AssemblyScript 加载器的情况下从 JavaScript 访问这些函数和属性，我们需要遵循这种命名约定。

### 使用私有属性

如果你不想将所有属性导出到嵌入环境中，需要在 `x` 和 `y` 属性前使用 `private` 关键字。现在在你的 AssemblyScript 中进行此操作，并使用 `asc` 命令重新编译。清单 11-16 显示了新版本。

**vector.ts**

```
export class Vector2D {
  1 private x: f32;
  2 private y: f32;

  constructor(x: f32, y: f32) {
    this.x = x;
    this.y = y;
  }

  Magnitude(): f32 {
    return Mathf.sqrt(this.x * this.x + this.y * this.y);
  }

}
```

清单 11-16：在 AssemblyScript 中创建私有函数

在 `x` 1 和 `y` 2 前面的 `private` 修饰符告诉 AssemblyScript 编译器，这些属性不应该对外部公开访问。重新编译 WebAssembly 模块，该模块不再导出设置和获取 `x` 和 `y` 变量的访问方法到嵌入环境，如 清单 11-17 所示。

**vector.wat**

```
...
(export "memory" (memory $0))
(export "Vector2D" (global $vector/Vector2D))
(export "Vector2D#constructor" (func $vector/Vector2D#constructor))
(export "Vector2D#Magnitude" (func $vector/Vector2D#Magnitude))
...
```

清单 11-17：WAT 文件中的导出

TypeScript 有三个修饰符，`public`、`private` 和 `protected`，用来定义属性的访问方式。这些修饰符在 AssemblyScript 中的行为与其他语言（如 TypeScript）有所不同。在大多数语言中，protected 属性可以被继承该类的子类访问，但不能在父类或子类之外访问。而在 AssemblyScript 中，`protected` 方法没有完全实现，其行为与 `public` 修饰符相同。目前，建议避免使用它以免造成混淆。尽管这些关键字未来可能会像在 TypeScript 中那样工作，但需要注意这些限制仍然存在于 AssemblyScript 版本 0.17.7 中。

`private` 修饰符阻止 AssemblyScript 在编译模块时导出 `get` 和 `set` 方法。

与其他面向对象编程语言不同，AssemblyScript 中的 `private` 修饰符并不会阻止继承原始类的类访问该属性。

让我们使用以下命令将我们的 AssemblyScript 编译成 WebAssembly 模块，这样我们就可以从 JavaScript 中调用它：

```
asc vector.ts -o vector.wasm
```

当我们将 `-o` 标志改为 *vector.wasm* 时，我们告诉 `asc` 编译器输出 WebAssembly 二进制文件。这将允许我们从 JavaScript 嵌入环境加载并运行该模块。接下来，让我们看看如何使用 Node.js 加载和调用 WebAssembly 函数。

### JavaScript 嵌入环境

我们将使用 Node.js 来加载和执行 WebAssembly 模块。如果改用浏览器，JavaScript 会使用 `WebAssembly.instantiateStreaming` ````` ```` and `fetch` instead of using `fs` to load the WebAssembly module from the filesystem and calling `WebAssembly.instantiate``` `.` `` ```` `````

`````` ````` ````Create the file *vector.js* and add the code in Listing 11-18.    **vector.js**    ``` 1 const fs = require('fs');  2 (async () => { 3 let wasm = fs.readFileSync('vector.wasm'); 4 let obj = await WebAssembly.instantiate(wasm,{env:{abort:()=>{}}});  5 let Vector2D = {   6 init: function (x, y) {       return obj.instance.exports"Vector2D#constructor"     },   7 Magnitude: obj.instance.exports["Vector2D#Magnitude"], }  8 let vec1_id = Vector2D.init(3, 4);   let vec2_id = Vector2D.init(4, 5);    console.log(`   9 vec1.magnitude=${Vector2D.Magnitude(vec1_id)}     vec2.magnitude=${Vector2D.Magnitude(vec2_id)}     `); })(); ```    Listing 11-18: Calling functions on the `Vector2D` AssemblyScript class    We use the `fs` 1 Node.js module to load 3 the binary WebAssembly data from a file inside an asynchronous IIFE 2. Once we have the binary data, we pass it to `WebAssembly.instantiate` 4, which returns a WebAssembly module object. We then create the JavaScript object `Vector2D` 5, which mirrors the functions inside the WebAssembly module.    We create an `init` 6 function that calls the WebAssembly module’s `Vector2D` `constructor`, passing in `0` as the first parameter. Passing this value to the `constructor` function allows some degree of choice of object placement in linear memory. We are passing `0`, which makes the constructor create a new object at the next available memory location.The function will then return the location in linear memory where it created this object. The `Magnitude` 7 attribute in `Vector2D` takes its value from `obj.instance.exports["Vector2D#Magnitude"]`, which is a function in our WebAssembly module.    After defining the JavaScript `Vector2D` object, we call `Vector2D.init` 8 twice to create two `Vector2D` WebAssembly objects in linear memory, as well as return the linear memory address of these objects, which we use for method calls. We then call `Vector2D.Magnitude` twice inside a `console.log` template string. We pass in the vector ids (`vec1_id` and `vec2_id`) we saved in Listing 11-18, which tell the WebAssembly module which object it’s using. The `Magnitude` 9 function passes back the magnitude of the given vector, which the app logs to the console. Run this app using `node`:    ``` node vector.js ```    Here’s the result:    ``` vec1.magnitude=5 vec2.magnitude=6.4031243324279785 ```    The two values are the magnitude of our first vector where x = 3 and y = 4, and the magnitude of the second vector where x = 4 and y = 5\.    Now that we know how to make calls into our AssemblyScript app directly, let’s look at how to use the AssemblyScript loader to make coding the JavaScript a little easier.    ### AssemblyScript Loader    Now we’ll modify our AssemblyScript code to use the AssemblyScript loader library. This will allow us to compare the methods of interfacing with an AssemblyScript module in terms of ease of use and performance. As mentioned previously, it’s important to understand when it’s possible to improve your application’s performance and how much effort that requires. This information helps you make decisions concerning the trade-off between development time and application performance.    Open *vector_loader.ts* and add the code in Listing 11-19 to use the AssemblyScript loader.    **vector_loader.ts**    ``` export class Vector2D { 1 x: f32; 2 y: f32;    constructor(x: f32, y: f32) {     this.x = x;     this.y = y;   }   Magnitude(): f32 {     return Mathf.sqrt(this.x * this.x + this.y * this.y);   }  3 add(vec2: Vector2D): Vector2D {     this.x += vec2.x;     this.y += vec2.y;     return this;   } } ```    Listing 11-19: Remove the private modifier from the `x` and `y` attributes    There are two changes to *vector.ts* that we will add into *vector_loader.ts*. First, we remove the `private` modifiers from the `x` 1 and `y` 2 attributes so we can access `x` and `y` from JavaScript. Second, we create an `add` 3 function that adds a second vector. This function allows us to add two vectors together. In Listing 11-20, we compile *vector_loader.ts* using `asc`.    ``` asc vector_loader.ts -o vector_loader.wasm ```    Listing 11-20: Compiling *vector.ts* to a WebAssembly file using `asc`    Next, we’ll create a new JavaScript file named *vector_loader.js* so we can run the new WebAssembly module. Add the code in Listing 11-21 to *vector_loader.js*.    **vector_loader.js**    ``` const fs = require('fs'); 1 const loader = require('@assemblyscript/loader');  (async () => {   let wasm = fs.readFileSync('vector_loader.wasm');  // instantiate the module using the loader 2 let module = await loader.instantiate(wasm);     // module.exports.Vector2D mirrors the AssemblyScript class. 3 let Vector2D = module.exports.Vector2D;  4 let vector1 = new Vector2D(3, 4);   let vector2 = new Vector2D(4, 5);  5 vector2.y += 10; 6 vector2.add(vector1);    console.log(`   7 vector1=(${vector1.x}, ${vector1.y})     vector2=(${vector2.x}, ${vector2.y})      vector1.magnitude=${vector1.Magnitude()}     vector2.magnitude=${vector2.Magnitude()}    `); })(); ```    Listing 11-21: Using the AssemblyScript loader in JavaScript    When using the loader, you can interact with AssemblyScript classes almost as if they’re JavaScript classes. There is a slight difference in that you call the demangled constructor function without using the JavaScript `new` operator, as you would do if these classes were created in JavaScript. However, once you’ve instantiated the object, you can interact with it as if it were written in JavaScript.    We first require the AssemblyScript `loader` 1. Rather than using the `WebAssembly.instantiate` function from the IIFE, we call the `loader.instantiate` 2 function, which returns a loader module. This module works a little differently than the WebAssembly module object returned by the `WebAssembly.instantiate` call. The AssemblyScript loader adds functionality that allows the JavaScript to work with high-level AssemblyScript objects, such as classes and strings.    We then call `loader.demangle`, passing it the module returned by `loader.instantiate`. The `demangle` function returns an object structure that provides us with functions we can use to instantiate objects from our WebAssembly module. We pull the `Vector2D` 3 function out of the object structure so we can use it as a constructor function for creating `Vector2D` objects in JavaScript. Note that we didn't use the `new` operator when instantiating `Vector2D` 4. However, the current loader version supports use of the `new` operator.    We use the `Vector2D` function to create a `vector1` and `vector2` object, passing in the `x` and `y` values for those vectors. We can now use these objects as regular JavaScript objects. The loader wires everything up for us. For example, we call `vector2.y += 10` 5 to increase the value of `vector2.y` by 10, and `vector2.add(vector1)` 6 calls the `add` function on the `vector2` object, passing in `vector1`. In our `console.log` 7 call, we can use values like `vector1.x` and `vector1.y`.    Run the JavaScript using `node`:    ``` node vector_loader.js ```    You should see the following output:    ```  vector1=(3, 4)     vector2=(7, 19)      vector1.magnitude=5     vector2.magnitude=20.248456954956055 ```    The AssemblyScript loader interface allows you to work with WebAssembly modules created in AssemblyScript almost as if they were classes, objects, and functions created in JavaScript. This creates an ergonomic experience that you might not have when you write your own interface with the WebAssembly module. If you have specific performance targets, you’ll need to perform additional testing to see whether the loader meets all your needs. In the next section, we’ll extend our AssemblyScript class through inheritance.    ### Extending Classes in AssemblyScript    OOP allows developers to extend a class by adding additional attributes or functionality to a base class. The syntax for extending classes in AssemblyScript is the same as it is in TypeScript. In Listing 11-22, we’ll extend the `Vector2D` class with a `Vector3D` class that will add an additional attribute `z`, which will represent a third dimension for our vector.    Open the *vector_loader.ts* file and add the code in Listing 11-22 after the `Vector2D` definition.    **vector_loader.ts**    ``` ... 1 export class Vector3D extends Vector2D { 2 z: f32;    constructor(x: f32, y: f32, z: f32) {   3 super(x, y);     this.z = z;   }  4 Magnitude(): f32 {     return Mathf.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);   }    add(vec3: Vector3D): Vector3D {   5 super.add(vec3);   6 this.z += vec3.z;     return this;   } } ```    Listing 11-22: Extending the `Vector2D` class using the `Vector3D` class    The new `Vector3D` 1 class keeps the original `x` and `y` attributes, and adds a third `z` 2 attribute for the third dimension. Its constructor calls `super` 3, which runs the constructor from the `Vector2D` class. It then sets the value of `this.z` to the `z` parameter passed into the constructor. We override the `Magnitude` 4 method from `Vector2D` so it takes the third dimension into account when calculating the magnitude of the vector. Then the `add` function calls the `Vector2D` class’s `add` function using `super.add` 5 and increases the value of `this.z` 6 using the `vec3` parameter’s `z` attribute value.    Now we can recompile our WebAssembly module using `asc`:    ``` asc vector_loader.ts -o vector_loader.wasm ```    Next, in Listing 11-23, we modify the *vector_loader.js* file to pull in the `Vector3D` class.    **vector_loader.js**    ```  const fs = require('fs');   const loader = require("@assemblyscript/loader");    (async () => {     let wasm = fs.readFileSync('vector_loader.wasm');     let module = await loader.instantiate(wasm);  1let { Vector2D, Vector3D } = await loader.demangle(module).exports;      let vector1 = Vector2D(3, 4);     let vector2 = Vector2D(4, 5);   2let vector3 = Vector3D(5, 6, 7);      vector2.y += 10;     vector2.add(vector1);   3vector3.z++;      console.log(`     vector1=(${vector1.x}, ${vector1.y})     vector2=(${vector2.x}, ${vector2.y})   4vector3=(${vector3.x}, ${vector3.y}, ${vector3.z})      vector1.magnitude=${vector1.Magnitude()}     vector2.magnitude=${vector2.Magnitude()}   5vector3.magnitude=${vector3.Magnitude()}     `);   })(); ```    Listing 11-23: JavaScript using the AssemblyScript loader to load `Vector2D` and `Vector3D` classes    We modify the line that took the `Vector2D` function from the call to `demangle`, and change it to destructure 1 the result, creating a `Vector2D` and `Vector3D` function variable. We create an object `vector3` 2, using the function `Vector3D`, to which we pass `x`, `y`, and `z` values. We increment `vector3.z` 3 for no particular reason other than to show that we can do it. Inside the template string passed to `console.log`, we add a line that displays the `x`, `y`, and `z` 4 values in `vector3`, as well as the magnitude of `vector3` 5.    When you run this JavaScript from the command line using `node`, you get the output in Listing 11-24.    ```  vector1=(3, 4)   vector2=(7, 19)   vector3=(5, 6, 8)    vector1.magnitude=5   vector2.magnitude=20.248456954956055   vector3.magnitude=11.180339813232422 ```    Listing 11-24: Output from *vector_loader.js*    Now let’s look at how the performance of the loader compares to direct calls into the WebAssembly module.    ### Performance of Loader vs. Direct WebAssembly Calls    The AssemblyScript loader provides a more intuitive structure for interaction between the AssemblyScript module and our JavaScript. The final section of this chapter compares the loader with direct calls into the WebAssembly modules. To run this test, we don’t need to write any additional AssemblyScript. We’ll use the WebAssembly modules created earlier in this chapter, so we only need to create a new JavaScript file to call the existing modules. Create a new file named *vector_perform.js* and add the code in Listing 11-25.    **vector_perform.js**    ``` const fs = require('fs'); const loader = require("@assemblyscript/loader");  (async () => {   let importObject = {     env: {       abort: () => { }     }   };   let wasm = fs.readFileSync('vector_loader.wasm');   let module = await loader.instantiate(wasm);   let obj = await WebAssembly.instantiate(wasm, importObject);   // This JavaScript class will have all the functions  // exported from AssemblyScript 1 let dVector2D = {  // the init function will call the constructor on Vector2D     init: function (x, y) {       return obj.instance.exports"Vector2D#constructor"     },     getX: obj.instance.exports["Vector2D#get:x"],     setX: obj.instance.exports["Vector2D#set:x"],     getY: obj.instance.exports["Vector2D#get:y"],     setY: obj.instance.exports["Vector2D#set:y"],     Magnitude: obj.instance.exports["Vector2D#Magnitude"],     add: obj.instance.exports["Vector2D#add"],   }   // This JavaScript class will have all the functions  // exported from AssemblyScript   let dVector3D = {  // the init function will call the constructor on Vector3D     init: function (x, y, z) {       return obj.instance.exports"Vector3D#constructor"     },     getX: obj.instance.exports["Vector3D#get:x"],     setX: obj.instance.exports["Vector3D#set:x"],     getY: obj.instance.exports["Vector3D#get:y"],     setY: obj.instance.exports["Vector3D#set:y"],     getZ: obj.instance.exports["Vector3D#get:z"],     setZ: obj.instance.exports["Vector3D#set:z"],     Magnitude: obj.instance.exports["Vector3D#Magnitude"],     add: obj.instance.exports["Vector3D#add"],   }  // prepare to log the time it takes to run functions directly 2 let start_time_direct = (new Date()).getTime();  3 let vec1_id = dVector2D.init(1, 2);  let vec2_id = dVector2D.init(3, 4);   let vec3_id = dVector3D.init(5, 6, 7);  4 for (let i = 0; i < 1_000_000; i++) {     dVector2D.add(vec1_id, vec2_id);     dVector3D.setX(vec3_id, dVector3D.getX(vec3_id) + 10);     dVector2D.setY(vec2_id, dVector2D.getY(vec2_id) + 1);     dVector2D.Magnitude(vec2_id);   } 5 console.log("direct time=" + (new Date().getTime() - start_time_direct));  6 let { Vector2D, Vector3D } = await loader.demangle(module).exports;  7 let start_time_loader = (new Date()).getTime();  8 let vector1 = Vector2D(1, 2);   let vector2 = Vector2D(3, 4);   let vector3 = Vector3D(5, 6, 7);  9 for (i = 0; i < 1_000_000; i++) {     vector1.add(vector2);     vector3.x += 10;     vector2.y++;     vector2.Magnitude();   } a console.log("loader time=" + (new Date().getTime() - start_time_loader));  })(); ```    Listing 11-25: Comparing loader function calls with direct function calls    Now we can see what it costs for us to use that pretty AssemblyScript loader syntax. This JavaScript creates an object to hold the direct calls to the `Vector2D` AssemblyScript class `dVector2D` 1 and one for the `Vector3D` class called `dVector3D`. We then set the variable `start_direct_time` 2 to the current time, which we’ll use to track the performance, and initialize 3 three vector objects. Two of the vector objects are `Vector2D` objects, and one is a `Vector3D` object.    After initializing the vectors, we loop one million times 4, making calls to those objects. We didn’t test every function, so this isn’t a perfect performance test. The goal is simply to get some numbers and see how they compare. As long as we make the same calls to the direct and loader versions, we should be able to get a reasonable comparison. We then use `console.log` 5 to log out the amount of time it took to initialize the vectors and run through the loop. This first loop tests the performance of the direct call to the WebAssembly module without using the AssemblyScript loader. Next, the code tests the performance of the module with the loader.    We use the `loader.demangle` 6 function to create the `Vector2D` and `Vector3D` factory functions. We then initialize `start_time_loader` 7 to the current time and call the `Vector2D` 8 and `Vector3D` functions to create three objects mirroring the code in the first loop 4 that tested the direct initialization calls. We loop one million times 9, executing the same functions as earlier, except through the loader. Finally, we `log` a the amount of time it took to execute the code using the loader.    Run *vector_perform.js* from the command line using `node`:    ``` node vector_perform.js ```    This is the output I received when I executed the file:    ``` direct time=74 loader time=153 ```    As you can see, the version using the loader took roughly twice as long to execute. The difference is even starker when we include the initialization calls in a loop. If you’re going to use the AssemblyScript loader, it’s best to structure your code to make as few calls as possible between the JavaScript and AssemblyScript.    ## Summary    In this chapter, you learned about the AssemblyScript high-level language, the AssemblyScript CLI, and the `asc` command you can use to compile AssemblyScript apps.    We created an `AddInts` function and a hello world app to show how writing an app in AssemblyScript compares to writing the same app in WAT. We compiled it to WAT format, looked through the code that the AssemblyScript compiler generated, and wrote a JavaScript app that ran the hello world app directly. While doing this, you learned how to use WAT to understand what the WebAssembly, created by the AssemblyScript compiler, is doing under the hood.    We then installed the AssemblyScript loader and used the JavaScript functions written by the AssemblyScript team to help us write the JavaScript code.    We discussed using strings in AssemblyScript, wrote a string concatenation app, and looked at how we must use additional flags with the `asc` compiler to allow `asc` to include additional WebAssembly libraries when compiling.    In the latter half of the chapter, we explored OOP in AssemblyScript. We created a class and looked at the exports from the WAT file it generated. We looked at `private` attributes and how they prevent AssemblyScript from exporting those attributes so they can’t be used by the embedding environment. We wrote JavaScript that allowed us to create the glue classes directly, and then used the AssemblyScript loader to create the glue code for us. We compared the performance of the direct and the loader methods. Finally, we extended our `Vector2D` class with a `Vector3D` class and discussed the differences between class inheritance in AssemblyScript and TypeScript.```` ````` ``````
