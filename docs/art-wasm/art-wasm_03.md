# 3

函数与表格

![](img/chapterart.png)

在本章中，我们将探讨 WebAssembly 中的函数：我们应该如何以及何时从 JavaScript 或其他 WebAssembly 模块导入函数，如何将 WebAssembly 函数导出到嵌入环境，并从 JavaScript 调用这些函数。你将了解 WebAssembly 中的表格以及如何调用表格中定义的函数。我们还将研究调用在 WebAssembly 模块内外定义的函数对性能的影响。

WebAssembly 模块通过导入和导出函数与嵌入环境进行交互。为了让 WebAssembly 使用函数，我们必须从嵌入环境导入函数，并导出函数供网页调用。我们还可以编写 WebAssembly 模块内的函数，通过 `export statement` 导出到嵌入环境。否则，函数默认仅在模块内使用。

`````` Function calls will always result in some lost computing cycles. But it’s necessary to know that a WebAssembly module will lose *more* cycles when calling an imported JavaScript function than when calling a function defined inside your WebAssembly module.    ## When to Call Functions from WAT    Every function we’ve defined up to this point includes the `(export)` expression to export the function so JavaScript can call it. However, not every function should use `export`. Every call to a WebAssembly function from JavaScript incurs an overhead cost, so you generally wouldn’t export WAT functions that do only small tasks. Small functions that don’t use many computing cycles might be better kept in the JavaScript to reduce overhead. Make sure your WAT code does as much as possible before returning to JavaScript; smaller functions shouldn’t use `export`.    The WAT functions most suited for exporting are those that loop over and process a lot of data. We recommend using many WAT functions in the early versions of your code to aid in the debugging process. Stepping through your WAT code in a debugger is easier to follow when your code is broken into many small functions. Chapter 10 covers debugging WebAssembly code in detail. As you tune your code for performance, you might decide to remove some of these functions by placing their code inline wherever the function had been called. Any internal function that’s called thousands of times from your exported WebAssembly function is a good candidate for moving inline. Chapter 9 covers performance tuning in detail.    ## Writing an is_prime Function    We’ve already seen examples of exporting functions to JavaScript in previous chapters, but those functions were terrible candidates for WebAssembly performance improvement because they didn’t do a whole lot. Here we’ll write an intentionally slow algorithm to determine whether an input is a prime number. This function is a good candidate for creation in WebAssembly and improved performance over JavaScript because it involves a significant number of calculations. Create an *is_prime.js* file and an *is_prime.wat* file to start creating this app.    ### Passing Parameters    Let’s start with the basics. First, we create a module, and then create a function inside that module that can be exported as `is_prime`. This function takes a single 32-bit integer parameter and returns a 32-bit integer that is `1` if the number passed in is prime and `0` if it’s not. Place the code in Listing 3-1 in the *is_prime.wat* file.   ``` (module   (func (1export "is_prime") (2param $n i32) (3result i32)   4 i32.const 0 ;; remove later   ) ) ```    Listing 3-1: WebAssembly `is_prime` function stub    We export this function to JavaScript as `is_prime` 1. JavaScript passes in a single parameter `param` `$n` as an `i32` 2. When complete, the function returns a 32-bit integer to JavaScript 3. To compile, this function expects to find a 32-bit integer on the stack when the function completes, so we add the line `i32.const` `0` 4. Without this line, the compiler will throw an error when we run `wat2wasm` because it’s expecting to return a number when the function completes, and it needs that number to be on the stack when the function ends.    This function is set for export alone and is not labelled for internal use. The `(func``)` expression begins with an `export` expression, not a `$is_prime` label. If we wanted to call this function from within the WebAssembly module or from the JavaScript, we would label it as shown in Listing 3-2.    ``` (func 1$is_prime (export "is_prime") (param $n i32) (result i32) ```    Listing 3-2: Exporting the function    ### Creating Internal Functions    Let’s add a little more code to the *is_prime.wat* file. No prime numbers are even except for the number 2, so we’ll write a function that checks whether the input number is even by looking at the last bit in the integer. All odd numbers have a 1 in the integer’s lowest order bit. Listing 3-3 shows the code for the `$even_check` function that we’ll add to the *is_prime.wat* file.   **is_prime.wat (part 1 of 4)**    ``` (module  ;; add the $even_check function to the top of the module   (func $even_check (1param $n i32) (result i32)      local.get $n      i32.const 2    2 i32.rem_u   ;; if you take the remainder of a division by 2      i32.const 0 ;; even numbers will have a remainder 0    3 i32.eq      ;; $n % 2 == 0  ) ... ```    Listing 3-3: Defining the `$even_check` function    The `$even_check` function takes a single parameter `$n` 1 and will return a value of `1` if `$n` is even and `0` if `$n` is odd. We use the remainder operation `i32.rem_u` 2, which divides `$n` by 2 and finds the remainder. An even number will have a remainder of 0, so we compare the remainder returned from `i32.rem_u` with 0 using an `i32.eq` 3 expression.    Now let’s create another simple function to handle the exception case if the number being passed in is 2, which is the only even prime number. It takes a single parameter and returns a `1` (true) if the number passed in is 2 or `0` (false) if it isn’t. We’ll call this function `$eq_2`, as shown in Listing 3-4.    **is_prime.wat (part 2 of 4)**    ``` ... ;; add the $eq_2 function after $even_check (func $eq_2 (param $n i32) (result i32)   local.get $n   i32.const 2 1 i32.eq    ;; returns 1 if $n == 2 ) ... ```    Listing 3-4: The `$eq_2` function checks whether the value passed in is 2.    We use `i32.eq` 1 to determine whether `$n` has a value of `2`, return `1` if it does, and return `0` if it doesn’t. Writing the `$eq_2` function is overkill, but because we’re demonstrating how calling functions work, another example couldn’t hurt.    In Listing 3-5, we add a `$multiple_check` function that checks whether the first parameter `$n` is a multiple of the second parameter `$m`. If the input number has multiples, it means it’s divisible and therefore cannot be prime.    **is_prime.wat (part 3 of 4)**    ``` ... ;; add $multiple_check after $eq_2   (func $multiple_check (param $n i32) (param $m i32) (result i32)    1 local.get $n    2 local.get $m    3 i32.rem_u     ;; get the remainder of $n / $m      i32.const 0   ;; I want to know if the remainder is 0    4 i32.eq        ;; that will tell us if $n is a multiple of $m   ) ... ```    Listing 3-5: Defining a `$multiple_check` function that checks whether `$n` is a multiple of `$m`    The `$multiple_check` function takes in two parameters, an integer `$n` 1 and a second integer `$m` 2, and checks whether `$n` is a multiple of `$m`. To do this, we get the remainder of `$n / $m` using `i32.rem_u` ``3 and then check whether that remainder is `0` using `i32.eq` 4. If the remainder is `0`, the `$multiple_check` function returns `1`. If the remainder is anything else, the `$multiple_check` returns `0`.``   ````` ### Adding the is_prime Function    Now that we have all the internal functions defined, let’s change the definition of the `is_prime` exported function so it returns `1` if the number passed in is prime and `0` if it’s not. Listing 3-6 shows the new version of the `is_prime` function.    **is_prime.wat (part 4 of 4)**    ``` ...  ;; add the is_prime exported function after $multiple_check   (func (export "is_prime") (param $n i32) (result i32)   1 (local $i i32)     2 (if (i32.eq (local.get $n) (i32.const 1)) ;; 1 is not prime       (then         i32.const 0         return       ))     (if (call $eq_2 (local.get $n)) ;; check to see if $n is 2       (then         i32.const 1 ;; 2 is prime         return       )     )    (block $not_prime     (call $even_check (local.get $n))     br_if $not_prime ;; even numbers are not prime (except 2)          (local.set $i (i32.const 1))      (loop $prime_test_loop             (local.tee $i (i32.add (local.get $i) (i32.const 2) ) ) ;; $i += 2       local.get $n  ;; stack = [$n, $i]             i32.ge_u ;; $i >= $n       if  ;; if $i >= $n, $n is prime         i32.const 1         return       end        (call $multiple_check (local.get $n) (local.get $i))       br_if $not_prime    ;; if $n is a multiple of $i this is not prime       br $prime_test_loop ;; branch back to top of loop     ) ;; end of $prime_test_loop loop   )  ;; end of $not_prime block  i32.const 0 ;; return false   ) ) ;; end of module ```    Listing 3-6: The `$is_prime` function definition    Before we added the code in Listing 3-6, the `is_prime` function didn’t actually test for prime numbers. Previously, it always returned `0` (to be interpreted as false). Now that we’ve coded the `is_prime` function, it will return `1` if the number passed in is prime and `0` if it’s not. At the beginning of this function, we create a local variable `$i` 1, which we use later as a loop counter. We check whether `$n` is `1` and `return 0` 2 if it is because the number one isn’t a prime number. We then eliminate half of the numbers by checking whether the number is 2, or even. If the number is 2, it’s prime; if it’s even but not 2, it’s not prime. We divide the number by every odd number from 3 to `$n-1`. If `$n` is evenly divisible by any of those numbers, it’s not prime. If it’s not evenly divisible by any of those numbers, it’s prime. The `$is_prime` function is rather large, so we’ll review it a piece at a time.    Listing 3-7 is the portion of the code that tests whether the number is 2.    ``` ...   ;; the beginning of the $is_prime function in listing 3-6   (if 1(call $eq_2 (local.get $n)) ;; check to see if $n is 2   2 (then        i32.const 1 ;; 2 is prime        return      )   ) ... ```    Listing 3-7: The `$eq_2` number check from `$is_prime` in Listing 3-6    The `if` statement calls the `$eq_2` 1 function defined earlier and passes it `$n`. If the value of `$n` is `2`, this function returns `1`; if not, it returns `0`. The `then` expression 2 runs if the value returned by the call is `1`, indicating that the number is prime.    Then we begin a block of code called `$not_prime`. If at any time the number is determined not to be a prime number, we exit this block, causing the function to exit with a return value of `0`, denoting the input isn’t prime. Listing 3-8 shows the beginning of that `block`.    ``` ...   ;; code from the $is_prime function in listing 3-6 1 (block $not_prime   2 (call $even_check (local.get $n))   3 br_if $not_prime ;; even numbers are not prime (except 2) ... ```    Listing 3-8: If the number is even, jump to `$not_prime`; from `$is_prime` in Listing 3-6    This block first calls `$even_check` 2 to see whether the number is even. Because we verified earlier that this number isn’t 2, any other even number wouldn’t be a prime. If `$even_check` returns `1`, the code leaves the `$not_prime` 1 block using the `br_if` 3 statement.    Next, Listing 3-9 begins the loop that checks the numbers that `$n` might be divisible by.    ``` ...   ;; code from the $is_prime function in listing 3-6   1 (local.set $i (i32.const 1))    2 (loop $prime_test_loop     3 (local.tee $i       (4i32.add (local.get $i) (i32.const 2) ) ) ;; $i += 2       5 local.get $n   ;; stack = [$n, $i]       6 i32.ge_u        ;; $i >= $n      7 if              ;; if $i >= $n, $n is prime          i32.const 1          return        end ... ```    Listing 3-9: Prime number test loop; from `$is_prime` in Listing 3-6    Right before the loop, we set the value of `$i` to `1` 1 because we’re looping over odd values when we increment through the loop. We call the loop `$prime_test_loop` 2 so when we branch to `$prime_test_loop` 2, it jumps back to that label. We use the `local.tee` 3 command in combination with an `i32.add` 4 command to increment the value of `$i` by `2` (because we’re only testing odd numbers) and leave the value calculated by `i32.add` on the stack when `$i` is set. The `local.tee` command is like the `local.set` command in that it sets the value of the variable you pass to it to the value on top of the stack. The difference is that `local.set` pops that value off the top of the stack, whereas `local.tee` leaves the value on it. We want to keep the new value for `$i` on the stack to compare its value with `$n`, which we push onto the stack in the next line using a `local.get` 5 expression.    The `i32.ge_u` 6 expression pulls the last two values off the stack and checks whether the value we had in `$i` is greater than or equal to the value in `$n` (because a number can’t be divisible by a number greater than it) and assumes these integers are unsigned (because negative numbers can’t be prime). If this evaluates to true, the expression pushes `1` onto the stack, and if false, pushes `0` onto the stack.    The `if` 7 statement that follows pulls one value off the stack and then executes the code between the `if` and `end` statements if the value pulled off the stack isn’t `0`. The upshot is, if `$i` is greater than or equal to `$n`, the number is prime. That means we only execute the code between the `if` and `end` statements if we incremented `$i` until its value is greater than or equal to `$n` without having ever found a number that evenly divides `$n`.    Listing 3-10 shows the code that checks whether `$i` evenly divides `$n`, which would mean `$n` isn’t prime.   ``` ...   ;; code from the $is_prime function in listing 3-6   1 (call $multiple_check (local.get $n) (local.get $i))     2 br_if $not_prime    ;; if $n is a multiple of $i this is not prime     3 br $prime_test_loop ;; branch back to top of loop     ) ;; end of $prime_test_loop loop   )  ;; end of $not_prime block   4 i32.const 0 ;; return false   ) ```    Listing 3-10: Call `$multiple_check` inside the prime test loop; from `$is_prime` in Listing 3-6    The `call` 1 expression at the beginning calls `$multiple_check`, passing it `$n` and `$i`. That returns `1` if `$n` is evenly divisible by `$i` and `0` if it’s not. If the value returned is `1`, the `br_if` 2 statement jumps to the end of the `$not_prime` block, causing the `is_prime` function to return `0` 4 (false). If `$multiple_check` returns `0`, we branch back to the top of the `loop` 3. We do this to continue testing numbers until `$i` is greater than `$n`, or we find a `$i` where `$n` is evenly divisible by `$i`.    With all of our WAT code written, we can use `wat2wasm` to compile our WebAssembly module:    ``` wat2wasm is_prime.wat ```    ### The JavaScript    Once you’ve compiled the WebAssembly module, create a JavaScript file named *is_prime.js* and add the code in Listing 3-11 to load and call the WebAssembly `is_prime` function.    **is_prime.js**    ``` const fs = require('fs'); const bytes = fs.readFileSync(__dirname + '/is_prime.wasm'); const value = parseInt(process.argv[2]);  (async () => {   const obj =     await WebAssembly.instantiate(new Uint8Array(bytes));   if(1!!obj.instance.exports.is_prime(value)) {   2 console.log(`       ${value} is prime!     `);   }   else {   3 console.log(`       ${value} is NOT prime     `);   } })(); ```    Listing 3-11: The *is_prime.js* file calls the `is_prime` WebAssembly function.    When the `is_prime` function is called, passing in the value taken from a command line argument, the `!!` 1 operator coerces the value from an integer into a true or false boolean value. If the value returned is `true`, we log out a message stating that the value is prime 2. If the value returned is `false`, the message indicates that the value isn’t prime 3. Now we can run the JavaScript function using `node` like this to check if 7 is a prime number:    ``` node is_prime.js 7 ```    Here’s the output you should see.    ```  7 is prime! ```    We’ve created several functions in our WebAssembly module that we use to check whether or not a number is prime. You should now be familiar with the basics of creating functions and calling those functions from within a WAT module.    ## Declaring an Imported Function    In this section, we’ll look at declaring functions as imports in more detail. We’ll need to import the `"print_string"` function from JavaScript, as shown in Listing 3-13.    ``` (import "env" "print_string" (func $print_string( param i32 ))) ```    Listing 3-13: Declaring an imported function `print_string`    The `import` statement in Listing 3-13 tells the module to import an object called `print_string` passed inside an object called `env`. These names must correspond with the names in the JavaScript code. Within the JavaScript, you can call the object anything you like, but once you name it in the JavaScript, you must use the same name when you import it into WebAssembly.    Listing 3-14 shows what the import object looked like in the *helloworld.js* file.    **helloworld.js**    ``` let importObject = { 1 env: {   2 buffer: memory,   3 start_string: start_string_index,   4 print_string: function(str_len) {       const bytes = new Uint8Array( memory.buffer,                                    start_string_index, str_len );       const log_string = new TextDecoder('utf8').decode(bytes);       console.log(log_string);   } } }; ```    Listing 3-14: Defining the `importObject`    In the `"hello world"` app, we use a memory `buffer` 2 to set string data. We also let the WebAssembly module know the location of the string data (`start_string`) 3 inside the memory buffer. We put both objects inside an object called `env` to separate it from the JavaScript function. We then create the `print_string` function 4 inside the `env` 1 object as the JavaScript callback that prints a string from linear memory. At the time of this writing, there isn’t a standardized convention for naming objects inside the ``importObject. We’ve chosen the `env` object to represent objects related to the embedded environment and for the function callbacks, but you can organize the `importObject` in any way you like.``   ````### JavaScript Numbers    When you create a JavaScript callback function, the only data type that function can receive is a JavaScript number. If you look at the `print_string` function we created in the `"hello world"` application, it passed a single variable. That variable is `str_len`, and it’s the byte length of the string displayed in the console. Unfortunately, only numbers can be passed as parameters to JavaScript functions. Chapter 5 explains in detail what to do to pass other kinds of data back to JavaScript.    ### Passing Data Types    WebAssembly can pass three of the four main data types back to functions imported from JavaScript: they include 32-bit integers, 32-bit floating-point numbers, and 64-bit floating-point numbers. At the time of this writing, you can’t pass 64-bit integers to a JavaScript function. The BigInt WebAssembly proposal will change this when it’s implemented. Until then, you must choose the data type you want to convert it to and perform the conversion inside the WebAssembly module. If you pass a 32-bit integer or floating-point number to JavaScript, JavaScript converts it to a 64-bit float, which is the native JavaScript number type.    ### Objects in WAT    WAT doesn’t support object-oriented programming (OOP). Creating classes and objects using WAT could potentially be accomplished using a combination of data structures, the function table, and indirect function execution, but that is beyond the scope of this book. In Chapter 6, we’ll explore how to create more sophisticated data structures within linear memory that will allow you to group the data together into linear memory in a way that is similar to using a *struct* in C/C++. Unfortunately, implementing OOP features, such as object methods, class inheritance, and polymorphism, are beyond what we can accomplish in this book.    ## Performance Implications of External Function Calls    In this section, we’ll explore the performance implications of calling imported and exported functions. When you call a JavaScript function in WAT, you lose some cycles to overhead. This number isn’t extremely large, but if you execute an external JavaScript function in a loop that iterates 4,000,000 times, it can add up. To get an idea of the kind of performance hit an application suffers from calls to JavaScript versus internal WebAssembly function calls, we created a WebAssembly test module. It executes a simple increment 4,000,000 times in an external JavaScript function and 4,000,000 times in a WebAssembly function in the same module. Because the code does very little, most of the difference in execution time can be attributed to the overhead of calling an external JavaScript function. Calling an internal WebAssembly function executed four to eight times faster on Chrome than internal WebAssembly calls and two to two and a half times faster in Firefox than internal calls. In our tests, Chrome performed worse than Firefox when crossing the JavaScript/WebAssembly boundary.    Let’s walk through this performance test. You first need to create a new WAT file. Create an empty file and name it *func_perform.wat*. Then open the file and create a module with one import and one global variable, as shown in Listing 3-15.    **func_perform.wat (part 1 of 4)**    ``` (module  ;; external call to a JavaScript function 1 (import "js" "external_call" (func $external_call (result i32))) 2 (global $i (mut i32) (i32.const 0)) ;; global for internal function ... ```    Listing 3-15: Importing a JavaScript `external_call` function    The `import` expression 1 will import a function we’ll define in the JavaScript. That function will return a value to the WebAssembly module. The `global` expression 2 creates a mutable global variable with an initial value of `0`. In general, it’s considered bad practice to use mutable global variables, but this code is only intended as a means to test the difference in performance between a WebAssembly and JavaScript function call.    After we define the global variable, we define the WebAssembly function we’ll be calling 4,000,000 times, as shown in Listing 3-16.    **func_perform.wat (part 2 of 4)**    ``` ... 1 (func $internal_call (result i32) ;; returns an i32 to calling function     global.get $i     i32.const 1     i32.add   2 global.set $i  ;; The first 4 lines of code in the function increments $i    3 global.get $i  ;; $i is then returned to the calling function   ) ... ```    Listing 3-16: Internal call to the WebAssembly function    The function `$internal_call` 1 returns a 32-bit value to the calling function, which will be the incremented value of the `$i` global variable. All this function does is increment the value of `$i` 2 and then push it back on to the stack 3 to return it to the calling function.    Next, we need to create a function that JavaScript can call with an `export` expression. This function needs to call the `$internal_call` function 4,000,000 times. Listing 3-17 shows the code for that external function.    **func_perform.wat (part 3 of 4)**    ``` ... 1 (func (export "wasm_call") ;; function "wasm_call" exported for JavaScript   2 (loop $again             ;; $again loop     3 call $internal_call    ;; call $internal_call WASM function       i32.const 4_000_000     4 i32.le_u	            ;; is the value in $i <= 4,000,000?     5 br_if $again           ;; if so repeat the loop     )   ) ... ```    Listing 3-17: Four million calls to an internal function    This function 1 is exported to be called from the JavaScript code. It has a simple loop labeled `$again` 2 that will call the `$internal_call` function 3 4,000,000 times. The loop does this by comparing the value returned by `$internal_call` (the value in the global `$i`) to `4_000_000`. If the value of `$i` is less than 4,000,000 (`i32.le_u`) 4, it branches back to the beginning of the `$again` loop 5.    Now that we have a function that will test the internal call to the WebAssembly function, in Listing 3-18 we create an almost identical function that will make a call to an external JavaScript function.    **func_perform.wat (part 4 of 4)**    ``` ... 1 (func (export "js_call")     (loop $again     2 (call $external_call) ;; calls the imported $external_call function       i32.const 4_000_000       i32.le_u     ;; is the value returned by $external_call <= 4,000,000?       br_if $again ;; if so, branch to the beginning of the loop     )   ) )   ;; end of module 3 ```    Listing 3-18: Four million calls to an external JavaScript function    There are only two differences between this function and the one in Listing 3-19. The first is the name of the function we export, `"js_call"` 1, which calls the imported `$external_call` 2 function. The second is that we put a closing parenthesis at the end to close the `module` expression 3.    Once you’ve finished creating *func_perform.wat*, compile it into a WebAssembly module using the following command:    ``` wat2wasm func_perform.wat ```    Now compile this module with `wat2wasm`. Then create an empty JavaScript file named *func_perform.js.* This JavaScript will load and call our WebAssembly module. Add the JavaScript in Listing 3-19.   **func_perform.js (part 1 of 2)**    ```  const fs = require('fs');   const bytes = fs.readFileSync(__dirname + '/func_perform.wasm');  1 let i = 0;   let importObject = {   js: {   2 external_call: function () { // The imported JavaScript function       i++;     3 return i; // increment i variable and return it     }   } }; ... ```    Listing 3-19: The `external_call` function defined in the JavaScript `importObject`    We declare the variable `i` 1 and initialize its value to `0`. Inside `importObject` we create a function `"external_call"` 2 which we imported into the WebAssembly earlier. The only thing this function does is increment and then return the value in `i` 3.    Next, we need to instantiate the *func_perform.wasm* module and execute `wasm_call` and `js_call`, as shown in Listing 3-20.    **func_perform.js (part 2 of 2)**    ``` ... (async () => { 1 const obj = await WebAssembly.instantiate(new Uint8Array(bytes),                                             importObject);   // destructure wasm_call and js_call from obj.instance.exports 2 ({ wasm_call, js_call } = obj.instance.exports);    let start = Date.now(); 3 wasm_call();  // call wasm_call from WebAssembly module   let time = Date.now() - start; 4 console.log('wasm_call time=' + time); // execution time in ms    start = Date.now(); 5 js_call();   // call js_call from WebAssembly module   time = Date.now() - start; 6 console.log('js_call time=' + time); // execution time in milliseconds })(); ```    Listing 3-20: Asynchronous IIFE definition inside JavaScript    Like the other apps in this book so far, we must instantiate the *func_perform.wasm* module 1 in the JavaScript. We use the JavaScript destructuring syntax to create the `wasm_call` and `js_call` functions 2. This destructuring is an ECMAScript 2015 syntax that’s convenient for pulling multiple variables out of an object. Alternatively, you could set `wasm_call` and `js_call` variables to the values in `obj.instance.exports`.    After retrieving the functions from the WebAssembly module, we call `wasm_call` 3 and log the time it took to execute in milliseconds 4 to the console. Next, we call the `js_call` function 5 and log 6 the time it took to execute.    Run the JavaScript using node like so:    ``` node func_perform.js ```    You should see something like this output logged to the console.    ``` wasm_call time=7 js_call time=32 ```    It took 7 milliseconds to call the WebAssembly function 4,000,000 times and 32 milliseconds for JavaScript. This might seem like a large difference, but a 25-millisecond difference spread over 4,000,000 calls is actually pretty small. If this function is only being called once per frame, the difference is trivial. However, if you have a loop that executes hundreds or thousands of times per frame render, it might be worth considering arranging your code differently for performance reasons. In the next section, we’ll look at function tables and their performance.    ## Function Tables    JavaScript can set variables to functions, allowing an application to dynamically swap functions at runtime. WebAssembly doesn’t have this feature, but it does have *tables*, which at the time of this writing can only hold functions. For that reason, we’ll refer to them as *function tables*, although there are plans to support other types in the future. Function tables allow WebAssembly to dynamically swap functions at runtime, which allows compilers to support features such as function pointers and OOP virtual functions. For example, C/C++ programs use WebAssembly tables to implement function pointers. Currently, tables only support the `anyfunc` type (`anyfunc` is a generic WebAssembly function type), but in the future they might support JavaScript objects and DOM elements as well. Unlike import objects, JavaScript and WebAssembly can dynamically change tables at runtime. There is a performance cost to calling a function from a table rather than through an import because a function table entry must be called indirectly. Let’s compare the performance of functions called through a table and those called directly.    ### Creating a Function Table in WAT    In this section, we’ll create and export a simple function table in WAT. We’ll build a module with four functions; two of which are imported from JavaScript, and two are defined inside the WebAssembly module. These functions will be very simple because the goal is to compare the performance of table function execution to a direct import. Create a new file named *table_export.wat* and enter the code in Listing 3-21.   **table_export.wat**    ``` (module   ;; javascript increment function 1 (import "js" "increment" (func $js_increment (result i32)))   ;; javascript decrement function 2 (import "js" "decrement" (func $js_decrement (result i32)))  3 (table $tbl (export "tbl") 4 anyfunc) ;; exported table with 4 functions    (global $i (mut i32) (i32.const 0))  4 (func $increment (export "increment") (result i32)  5 (global.set $i (i32.add (global.get $i) (i32.const 1))) ;; $i++     global.get $i  )  6 (func $decrement (export "decrement") (result i32)  7 (global.set $i (i32.sub (global.get $i) (i32.const 1))) ;; $i--    global.get $i  )   ;; populate the table 8 (elem (i32.const 0) $js_increment $js_decrement $increment $decrement) ) ```    Listing 3-21: Exporting functions in a table    Two imports are in this module: a JavaScript `increment` function 1 and a JavaScript `decrement` function 2. However, you cannot add a JavaScript function to a function table from within JavaScript. There is a `WebAssembly.Table` function set that allows you to set functions in a table, only with a function defined in a WebAssembly module. We can work around this restriction by importing the JavaScript function into a WebAssembly module and adding it to the table there.    The `table` 3 expression creates the table and names it `$tbl`, which we can reference within the WAT code. We export `$tb1` and tell `table` the expression that there are four objects in this table of type `anyfunc` (currently the only type of table object supported). We then create two WebAssembly functions: the `$increment` function 4 sets the value of the global `$i` to `$i`+1 5 and the `$decrement` function 6 sets the value of `$i` to `$i`-1 7.    The last thing we do in this module is set the values in the table using the `elem` expression 8. As its first parameter, the `elem` expression takes the index of the first element we set. We set all four elements, so we use `(i32.const` `0)` because the first parameter is the starting index we want to update. We then follow that parameter with the four function variables we want in the table.    Alternatively, if we only wanted to set the first two items in the table, we wouldn’t need to pass in all four function names and would do this:    ``` (elem (i32.const 0) $js_increment $js_decrement) ;; set first 2 table func ```    To set the second two items, we would change the value of the first parameter to let the expression know we’re starting with the third item in the table, as shown here:    ``` (elem (i32.const 2) $increment $decrement) ;; set table items 3 and 4 ```    The first parameter of the `elem` statement in Listing 3-21 is an index of `0`, similar to an array. When you’ve finished adding this code, compile *table_export.wat* into *table_export.wasm* using the `wat2wasm` command.    #### Sharing a Table Between Modules    Now that we have a *table_export.wasm*, let’s create a second WebAssembly file that shares the same table. Create a new WAT file named *table_test.wat*. We’ll begin the new WebAssembly module with a series of `import` statements and a `type` definition expression, as shown in Listing 3-22.    **table_test.wat (part 1 of 3)**    ``` (module 1 (import "js" "tbl" (table $tbl 4 anyfunc))  ;; import increment function 2 (import "js" "increment" (func $increment (result i32)))  ;; import decrement function 3 (import "js" "decrement" (func $decrement (result i32)))   ;; import wasm_increment function 4 (import "js" "wasm_increment" (func $wasm_increment (result i32)))  ;; import wasm_decrement function 5 (import "js" "wasm_decrement" (func $wasm_decrement (result i32)))   ;; table function type definitions all i32 and take no parameters 6 (type $returns_i32 (func (result i32))) ... ```    Listing 3-22: Function imports in the WebAssembly module    The first `import` statement 1 imports the table, with four `anyfunc`functions, in the *table_export.wat* file. Next, we import the JavaScript functions `increment` 2 and `decrement` 3, which we’ll use to compare the performance of imported JavaScript functions against JavaScript functions defined in tables.    We then import the `wasm_increment` 4 and `wasm_decrement` 5 functions defined in the *table_export.wat* file in the table. With this we can test the performance of a `call_indirect` to a table element with a call to the same function imported directly with an `import` statement.    The last expression is a `type` expression 6 which defines the signature of the functions in the table. I have to provide this `$returns_i32` type as a static parameter to `call_indirect`. We can expect that `call_indirect` will be slower than `call` because the type of the indirectly called function must be dynamically checked to match this provided type.    Now, let’s use the code in Listing 3-23 to define four global variables that we’ll use to index into the function table.    **table_test.wat (part 2 of 3)**    ``` ... 1 (global $inc_ptr i32 (i32.const 0)) ;; JS increment function table index 2 (global $dec_ptr i32 (i32.const 1)) ;; JS decrement function table index  3 (global $wasm_inc_ptr i32 (i32.const 2)) ;; WASM increment function index 4 (global $wasm_dec_ptr i32 (i32.const 3)) ;; WASM decrement function index ... ```    Listing 3-23: Global variable function table indexes    These four global variables are indexes into the function table and give us an easier way to keep track of which index corresponds to which function. The `$inc_ptr` 1 and `$dec_ptr` 2 variables point to the JavaScript `increment` and `decrement` functions, and `$wasm_inc_ptr` 3 and `$wasm_dec_ptr` 4 point to the WebAssembly versions of the `increment` and `decrement` functions in the table.    #### Defining the Test Functions    With the imports and globals defined, we’ll define the four test functions. All of these functions will do the same task using different methods: they’ll call an `increment` function 4,000,000 times from a `loop` and then call a `decrement` function 4,000,000 times. One function will call the functions indirectly from the imported table; one will call them directly from an `import`; one will call a WebAssembly version from a table; and the last will call the `increment` and `decrement` functions from a direct `import`. In the end, we should be able to compare the performance of calling JavaScript functions through a table or directly, as well as compare the performance of calling a WebAssembly module function directly or through a table.    Listing 3-24 shows the four function definitions.    **table_test.wat (part 3 of 3)**    ``` ;; Test performance of an indirect table call of JavaScript functions 1 (func (export "js_table_test")     (loop $inc_cycle       ;; indirect call to JavaScript increment function       (call_indirect (type $returns_i32) (global.get $inc_ptr))       i32.const 4_000_000       i32.le_u  ;; is the value returned by call to $inc_ptr <= 4,000,000?       br_if $inc_cycle ;; if so, loop     )      (loop $dec_cycle       ;; indirect call to JavaScript decrement function       (call_indirect (type $returns_i32) (global.get $dec_ptr))       i32.const 4_000_000       i32.le_u  ;; is the value returned by call to $dec_ptr <= 4,000,000?       br_if $dec_cycle ;; if so, loop     )   )  ;; Test performance of direct call to JavaScript functions 2 (func (export "js_import_test")     (loop $inc_cycle       call $increment  ;; direct call to JavaScript increment function       i32.const 4_000_000       i32.le_u  ;; is the value returned by call to $increment<=4,000,000?       br_if $inc_cycle ;; if so, loop     )      (loop $dec_cycle       call $decrement  ;; direct call to JavaScript decrement function       i32.const 4_000_000       i32.le_u  ;; is the value returned by call to $decrement<=4,000,000?       br_if $dec_cycle ;; if so, loop     )   )   ;; Test performance of an indirect table call to WASM functions 3 (func (export "wasm_table_test")     (loop $inc_cycle       ;; indirect call to WASM increment function      (call_indirect (type $returns_i32) (global.get $wasm_inc_ptr))      i32.const 4_000_000      i32.le_u  ;; is the value returned by call to $wasm_inc_ptr<=4,000,000?      br_if $inc_cycle ;; if so, loop     )      (loop $dec_cycle       ;; indirect call to WASM decrement function       (call_indirect (type $returns_i32) (global.get $wasm_dec_ptr))       i32.const 4_000_000       i32.le_u  ;; is the value returned by call to $wasm_dec_ptr<=4,000,000?       br_if $dec_cycle ;; if so, loop     )   )   ;; Test performance of direct call to WASM functions 4 (func (export "wasm_import_test")     (loop $inc_cycle       call $wasm_increment  ;; direct call to WASM increment function       i32.const 4_000_000       i32.le_u       br_if $inc_cycle     )      (loop $dec_cycle       call $wasm_decrement  ;; direct call to WASM decrement function       i32.const 4_000_000       i32.le_u       br_if $dec_cycle     )   ) ) ```    Listing 3-24: Performance testing    The first function we define for `export` is `js_table_test` 1. This function runs 8,000,000 indirect calls to simple JavaScript functions. The function following `js_table_test` is `js_import_test` 2. The `js_import_test` function calls the same functions `js_table_test` does. However, it does it directly from an `import`. This allows us to compare the performance of 8,000,000 runs of the same function with and without the use of a table. The other two functions, `wasm_table_test` 3 and `wasm_import_test` 4, are the same as the `js` versions of those functions but call WebAssembly module functions instead of JavaScript functions.    Once you’ve created your *table_test.wasm* file, create a new JavaScript file named *table.js* and add the code in Listing 3-25.    **table.js (part 1 of 4)**    ``` const fs = require('fs'); const export_bytes = fs.readFileSync(__dirname+'/table_export.wasm'); const test_bytes = fs.readFileSync(__dirname + '/table_test.wasm');  let i = 0; let increment = () => {   i++;   return i; } let decrement = () => {   i--;   return i; } ... ```    Listing 3-25: JavaScript `increment` and `decrement` functions    We’ll test these functions by calling them directly using an `import` and indirectly using a table.    #### Creating the WebAssembly importObject in JavaScript    Now we need an `importObject` that we’ll use for both of the WebAssembly modules. This object defines all of the functions, values, and tables we want to pass from the JavaScript into a WebAssembly module. In Listing 3-27, we’ll also use it to pass a table from one WebAssembly module to another. We’ll initially set the `tbl`, `wasm_decrement`, and `wasm_increment` objects to `null` because they’re not yet being used by the *table_export.wasm* module. But they’ll be needed when we load the *table_test.wasm* module. Listing 3-26 shows the `importObject`.    **table.js (part 2 of 4)**    ``` ... const importObject = {   js: {   1 tbl: null, // tbl is initially null and is set for the second WASM module   2 increment: increment, // JavaScript increment function     decrement: decrement, // JavaScript decrement function   3 wasm_increment: null, // Initially null, set to function by second module  wasm_decrement: null  // Initially null, set to function by second module   } }; ... ```    Listing 3-26: JavaScript `importObject`    At this point, the `tbl` 1 value we pass in through the `importObject` is `null`, because it’s created in the *table_export.wasm* module, and we’ll need to initialize that value with the table exported from *table_export.wasm*. The `increment` and `decrement` 2 functions were defined earlier in the JavaScript. We haven’t defined the `wasm_increment` and `wasm_decrement` 3 functions yet because we’ll need to put them into the `import` function after they’re created in *table_export.wasm*.    #### Instantiating the WebAssembly Modules    Now let’s look at how to instantiate the two WebAssembly modules in Listing 3-27.    **table.js (part 3 of 4)**    ``` ... 1 (async () => {   // instantiate the module that uses a function table   2 let table_exp_obj = await WebAssembly.instantiate(       new Uint8Array(export_bytes), importObject);   // set the tbl variable to the exported table   3 importObject.js.tbl = table_exp_obj.instance.exports.tbl;    4 importObject.js.wasm_increment =       table_exp_obj.instance.exports.increment;   5 importObject.js.wasm_decrement =       table_exp_obj.instance.exports.decrement;   6 let obj = await WebAssembly.instantiate(               new Uint8Array(test_bytes), importObject); ... ```    Listing 3-27: Instantiating a WebAssembly module in asynchronous IIFE    As we’ve done previously, we use an asynchronous IIFE 1 to instantiate the WebAssembly modules. However, now we instantiate two WebAssembly modules instead of just a single module to demonstrate how we can share functions and function tables between WebAssembly modules. When we instantiate the *table_export.wasm* module, we put the WebAssembly object into a variable called `table_exp_obj` 2. In the past we’ve put all the WebAssembly module objects into a variable called `obj`, but because we’re using more than one module in this app, we need more specific names.    We use the `table_exp_obj` to set the `tbl` variable 3, defined earlier in the `importObject`, to the function table created in the *table_export.wasm* module. Next, we set the `wasm_increment` 4 and `wasm_decrement` 5 variables in the `importObject`. Then we instantiate the *table_test.wasm* module 6.    The last block of code in this section, in Listing 3-28, performs the test and measures the time in milliseconds each test took to run.    **table.js (part 4 of 4)**    ``` ...   // use destructuring syntax to create JS functions from exports 1 ({ js_table_test, js_import_test,      wasm_table_test, wasm_import_test } = obj.instance.exports);    i = 0; // i variable must be reinitialized to 0   let start = Date.now(); // get starting timestamp 2 js_table_test();        // run function that tests JS table calls   let time = Date.now() - start; // find out how much time it took to run   console.log('js_table_test time=' + time);    i = 0; // i must be reinitialized to 0   start = Date.now(); // get starting timestamp 3 js_import_test();   // run function that tests JS direct import calls   time = Date.now() - start;   console.log('js_import_test time=' + time);    i = 0; // i must be reinitialized to 0   start = Date.now(); // get starting timestamp 4 wasm_table_test();  // run function that tests WASM table calls   time = Date.now() - start; // find out how much time it took to run   console.log('wasm_table_test time=' + time);    i = 0; // i must be reinitialized to 0   start = Date.now(); // get starting timestamp 5 wasm_import_test(); // run function that tests WASM direct import calls   time = Date.now() - start; // find out how much time it took to run   console.log('wasm_import_test time=' + time); })(); ```    Listing 3-28: Calling the WebAssembly functions and recording the execution time    We use the JavaScript destructuring syntax to create four variables 1, `{js_table_test, js_import_test, wasm_table_test, wasm_import_test}`, from the `obj.instance.exports` object’s attributes. This is just a handy way to create all four of these function variables at once and set them to the functions of the same name exported by the WebAssembly module.    Then we run each of the functions one by one using `node`, like this:    ``` node table.js ```    Here are the four lines you should see displayed to the console that show the `js_table_test` 2, `js_import_test` 3, `wasm_table_test` 4, and `wasm_import_test` 5 runtime:    ``` js_table_test time=67 js_import_test time=60 wasm_table_test time=25 wasm_import_test time=20 ```    The line displaying the `js_import_test` 3 runtime shows that for this run, calling the JavaScript through an `import` executed about 10 percent faster than calling the same function using a table. Although this might not seem like a tremendous difference, it depends on your application’s needs.    We then see the time in milliseconds it takes to call similar WebAssembly versions of the `increment` and `decrement` functions. This difference is a bit more significant: the table call takes about 25 percent longer than the direct `import`.    In this section, you learned how to share functions and function tables between different WebAssembly modules. You also learned the difference between calling a function directly from an `import` and calling one indirectly through a table, and the performance implications of calling a function using a table. Understanding how functions are called, imported, exported, and used in function tables are fundamental features of the language you’ll need to understand before you master WebAssembly development.    ## Summary    In this chapter, we examined calling WebAssembly functions from JavaScript and JavaScript functions from WebAssembly. We covered what the performance implications of each type of call are. We also created an app that tests for prime numbers to demonstrate the kind of function that it makes sense to create in a WebAssembly module. We looked at passing parameters to functions defined in WebAssembly and how to create functions in WebAssembly that won’t be available to JavaScript. We looked into what it takes to create functions that manipulate strings within WebAssembly and how to access those strings from JavaScript. We dove further into data types in WebAssembly and how they translate into data types in JavaScript. We reviewed tables and how to use them to indirectly call WebAssembly and JavaScript functions, including WebAssembly functions created in a second module. We also spent time investigating the performance implications of using tables and functions created in a second WebAssembly module. In the next chapter, we’ll explore using WAT for low-level programming.```` ````` ``````
