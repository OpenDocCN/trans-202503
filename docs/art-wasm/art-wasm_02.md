# 第二章：WebAssembly 文本基础

![](img/chapterart.png)

在本章中，我们将深入探讨 WAT 代码的基础知识。我们将在本书中大部分时间编写 WAT 代码，这是你可以为 WebAssembly 部署编写的最低级别的编程（尽管对于有经验的汇编程序员来说，这可能显得相当高级）。

本章涵盖了很多内容。我们将从展示 WebAssembly 中的两种注释样式开始。接下来，我们将编写传统的 hello world 应用程序。我们不从 hello world 开始，因为在 WAT 中处理字符串比你想象的要复杂。

然后我们将讨论如何使用导入对象从 JavaScript 导入数据到 WebAssembly 模块。我们将研究命名和未命名的全局与局部变量，以及 WebAssembly 支持的数据类型。我们还会讨论 S-表达式语法，以及`wat2wasm`编译器如何在编译代码时解包这些 S-表达式。你将深入了解条件逻辑，包括`if`/`else`语句和分支表，并且学习如何结合条件逻辑使用循环和块。

到本章结束时，你应该能够编写简单的 WebAssembly 应用程序，并通过命令行使用 Node.js 执行它们。

## 编写最简单的模块

每个 WAT 应用程序都必须是一个模块，因此我们首先会看看模块语法。我们在一个块中声明模块，就像示例 2-1 中展示的那样。

```
(module
  ;; This is where the module code goes.
)
```

示例 2-1：单行 WAT 注释

我们通过`module`关键字声明一个模块，括号内的内容是模块的一部分。要添加注释，我们使用两个分号`;;`，之后的内容为注释。WAT 也有块注释语法；你可以用`(;`打开块注释，用`;)`关闭块注释，如示例 2-2 所示。

```
(module
 (;
 This is a module with a block comment.
 Like the /* and */ comments in JavaScript
 you can have as many lines as you like inside
 between the opening and closing parenthesis
 ;)
)
```

示例 2-2：多行 WAT 注释

由于此模块不做任何事情，我们不会费力去编译它。相反，我们将继续编写我们的 hello world 应用程序。

## WebAssembly 中的 Hello World

WAT 没有原生的字符串支持，因此处理字符串需要直接操作内存作为字符数据的数组。这些内存数据必须转换成 JavaScript 代码中的字符串，因为从 JavaScript 中操作字符串要简单得多。

在 WAT 中处理字符串时，你需要声明一个存储在 WebAssembly 线性内存中的字符数据数组。线性内存是我们将在第六章详细讨论的主题，但现在你只需知道线性内存类似于本地应用程序中的内存堆，或者 JavaScript 中的一个巨大的类型化数组。

你还需要从 WebAssembly 调用一个导入的 JavaScript 函数来处理 I/O 操作。与本地应用程序通常由操作系统处理 I/O 不同，在 WebAssembly 模块中，I/O 必须由嵌入环境来处理，无论这个环境是网页浏览器、操作系统还是运行时。

### 创建我们的 WAT 模块

在这一部分，我们将创建一个简单的 WebAssembly 模块，在线性内存中创建一个`hello world!`字符串，并调用 JavaScript 将该字符串写入控制台。创建一个新的 WAT 文件并命名为*helloworld.wat*。打开该文件并添加列表 2-3 中的 WAT 代码。

**helloworld.wat**

```
(module
  (import "env" "print_string" (func $print_string( param i32 )))
)
```

列表 2-3：导入一个函数

这段代码告诉 WebAssembly 预计从我们嵌入的环境中导入对象`env`，并且在该对象中我们期望得到函数`print_string`。当我们稍后编写 JavaScript 代码时，我们将创建这个`env`对象，并将`print_string`函数传递给 WebAssembly 模块，当我们实例化它时。

我们还设置了签名，要求一个`i32`类型的参数，表示我们字符串的长度。我们将此函数命名为`$print_string`，以便可以从我们的 WAT 代码中访问它。

接下来，我们将添加对内存缓冲区的导入。在列表 2-4 中添加加粗的行。

**helloworld.wat**

```
(module
  (import "env" "print_string" (func $print_string( param i32 )))
  **(import "env" "buffer" (memory 1))**
)
```

列表 2-4：导入一个函数和内存缓冲区

这个新的`import`告诉我们的 WebAssembly 模块，我们将从`env`对象导入一个内存缓冲区，并且该缓冲区将被称为`buffer`。`(memory` `1)`语句表示缓冲区将是一个线性内存页面：*页面*是你可以一次分配给线性内存的最小内存块。在 WebAssembly 中，一个页面是 64KB，这对这个模块来说足够了，所以我们只需要一个页面。接下来，在列表 2-5 中，我们将添加一些全局变量到*helloworld.wat*中。

**helloworld.wat**

```
(module
  (import "env" "print_string" (func $print_string( param i32 )))
  (import "env" "buffer" (memory 1))
1 (global $start_string (import "env" "start_string") i32) 
2 (global $string_len i32 (i32.const **12))**
)
```

列表 2-5：添加全局变量

第一个`global` 1 变量是一个从我们的 JavaScript 导入对象导入的数字；它映射到 JavaScript 中名为`env`的变量（我们还未创建）。该值将是我们字符串的起始内存位置，可以是线性内存页面中任何位置，最大为 65,535。当然，你不希望选择接近线性内存末尾的值，因为这会限制你能够存储的字符串长度。如果传入的值是`0`，你可以使用整个 64KB 来存储字符串。如果你传入的值是`65,532`，你只能使用最后四个字节来存储字符数据。如果你尝试写入一个超过已分配内存位置的值，你将会在 JavaScript 控制台中遇到内存错误。第二个全局变量`$string_len` 2 是一个常量，表示我们将定义的字符串的长度，我们将其设置为`12`。

在列表 2-6 中，我们使用数据表达式在线性内存中定义了我们的字符串。

**helloworld.wat**

```
(module
  (import "env" "print_string" (func $print_string( param i32 )))
  (import "env" "buffer" (memory 1))
  (global $start_string (import "env" "start_string") i32)
  (global $string_len i32 (i32.const 12))
  **(data (global.get $start_string) "hello world!")**
)
```

列表 2-6：添加数据字符串

我们首先传递模块将要写入数据的内存位置。数据存储在模块将从 JavaScript 导入的`$start_string`全局变量中。第二个参数是数据字符串，我们将其定义为字符串`"hello world!"`。

现在，我们可以定义我们的 `"helloworld"` 函数并将其添加到模块中，如 列表 2-7 所示。

**helloworld.wat**

```
(module
  (import "env" "print_string" (func $print_string (param i32)))
  (import "env" "buffer" (memory 1))
  (global $start_string (import "env" "start_string") i32)
  (global $string_len i32 (i32.const 12))
  (data (global.get $start_string) "hello world!")	
1 (func (export "helloworld")
  2 (call $print_string (global.get $string_len))
  )
)
```

列表 2-7：向 WebAssembly 模块添加 `"helloworld"` 函数

我们将函数定义并导出为 `"helloworld"`，以便在 JavaScript 1 中使用。这个函数唯一的功能就是调用导入的 `$print_string` 2 函数，并将我们定义为全局的字符串长度传递给它。现在，我们可以像下面这样编译 WebAssembly 模块：

```
wat2wasm helloworld.wat
```

运行 `wat2wasm` 会生成一个 *helloworld.wasm* 模块。为了执行这个 WebAssembly 模块，我们需要创建一个 JavaScript 文件来运行它。

### 创建 JavaScript 文件

现在，我们将创建 *helloworld.js* 来运行我们的 WebAssembly 模块。创建并打开 JavaScript 文件，在文本编辑器中添加 Node.js 文件常量和三个变量，如 列表 2-8 所示。

**helloworld.js**

```
const fs = require('fs');
const bytes = fs.readFileSync(__dirname + '/helloworld.wasm');

1 let hello_world = null; // function will be set later
2 let start_string_index = 100; // linear memory location of string
3 let memory = new WebAssembly.Memory ({ initial: 1 }); // linear memory
...
```

列表 2-8：声明 JavaScript 变量

`hello_world` 1 变量最终会指向 WebAssembly 模块导出的 `helloworld` 函数，因此我们暂时将其设置为 `null`。`start_string_index` 2 变量是我们字符串在线性内存数组中的起始位置。我们将其设置为 `100`，以避免接近 64KB 的限制。我们随意选择了地址 100。你可以选择任何地址，只要你使用的内存不超过 64KB 限制。

最后的变量保存了 `WebAssembly.Memory` 3 对象。传入的数字表示你希望分配的页面数。我们通过传入 `{initial: 1}` 作为唯一的参数来初始化它，表示分配一个页面。你最多可以通过这种方式分配两吉字节的内存，但如果设置的值过高，可能会导致错误，因为浏览器可能无法找到足够的连续内存来满足请求。

列表 2-9 展示了我们需要声明的下一个变量 `importObject`，它将在我们实例化 WebAssembly 模块时传入。

**helloworld.js**

```
...
let importObject = {
1 env: {
  2 buffer: memory,
  3 start_string: start_string_index,
  4 print_string: function (str_len) {
      const bytes = new Uint8Array (memory.buffer,
        start_string_index, str_len);
      const log_string = new TextDecoder('utf8').decode(bytes);
      console.log (log_string);
    }
 }
};
...
```

列表 2-9：在 JavaScript 中声明 `importObject`

在 `importObject` 内部，我们添加了一个名为 `env` 1 的对象，它是 *环境*（environment）的缩写，尽管你可以根据自己的喜好命名这个对象，只要它与 WebAssembly 导入声明中的名称匹配即可。这些是将传递给 WebAssembly 模块的值，当它被实例化时。如果你希望 WebAssembly 模块能够访问嵌入环境中的任何函数或值，可以将它们传递到这里。`env` 对象包含内存缓冲区 2 和我们字符串在 `buffer` 中的起始位置 3。`env` 中的第三个属性 4 包含我们的 JavaScript 函数 `print_string`，该函数将在 WebAssembly 模块中被调用，如 列表 2-9 所示。这个函数从我们的内存缓冲区中获取字符串的长度，并结合我们的起始字符串索引来创建一个字符串对象。然后，应用程序将在命令行上显示该字符串对象。

此外，我们添加了一个 IIFE，它异步加载我们的 WebAssembly 模块，然后调用`helloworld`函数，如示例 2-10 所示。

**helloworld.js**

```
...
( async () => {   
  let obj = await
1 WebAssembly.instantiate(new Uint8Array (bytes), importObject);
2 ({helloworld: hello_world} = obj.instance.exports);
3 hello_world();
})();
```

示例 2-10：在异步 IIFE 中实例化 WebAssembly 模块

`async`模块的第一行等待`WebAssembly.instantiate`函数调用，但与示例 1-1 中的简单加法示例不同，我们将之前声明的`importObject`传递给该函数。然后，我们使用解构语法从`obj.instance.exports`中提取`helloworld`函数，将`hello_world`变量设置为`obj.instance.exports`中的函数 2。

我们 IIFE 的最后一行调用了`hello_world` 3 函数。我们将箭头函数括在圆括号中，然后在函数声明的末尾添加函数调用圆括号，这会导致该函数立即执行。

````Once you have the JavaScript and WebAssembly files, run the following call to `node` from the command line:    ``` node helloworld.js ```    You should see the following output on the command line:    ``` hello world! ```    We’ve built the ubiquitous hello world application! Now that you have the hello world application under your belt, we’ll explore variables and how they work in WAT.    ## WAT Variables    WAT treats variables a little differently than other programming languages, so it’s worth providing you with some details here. However, the browser manages local or global WAT variables in the same way it manages JavaScript variables.    WAT has four global and local variable types: i32 (32-bit integer), i64 (64-bit integer), f32 (32-bit floating-point), and f64 (64-bit floating-point). Strings and other more sophisticated data structures need to be managed directly in linear memory. We’ll cover linear memory and the use of more complicated data structures in WAT in Chapter 6\. For now, let’s look at each variable type.    ### Global Variables and Type Conversion    As you might expect, you can access globals in WAT from any function, and we generally use globals as constants. *Mutable globals* can be modified after they’re set and are usually frowned upon because they can introduce side effects in functions that use them. You can import global variables from JavaScript, allowing the JavaScript portion of your application to set constant values inside your module.    When importing global variables, keep in mind that, at the time of this writing, standard JavaScript number variables don’t support 64-bit integer values. Numbers in JavaScript are 64-bit floating-point variables. A 64-bit floating-point variable can represent every value in a 32-bit integer, so JavaScript has no trouble making this conversion. However, you cannot represent all possible 64-bit integer values with a 64-bit floating-point value. Unfortunately, this means that you can work with 64-bit integers in WebAssembly, but if you want to send 64-bit values to JavaScript, it requires additional effort, which is beyond the scope of this book.    Another detail you must know about data types in WebAssembly and JavaScript is that JavaScript treats all numbers as 64-bit floating-point numbers. When you call a JavaScript function from WebAssembly, the JavaScript engine will perform an implicit conversion to a 64-bit float, no matter what data type you pass. However, WebAssembly will define the imported function as having a specific data type requirement. Even if you pass the same function into the WebAssembly module three times, you’ll need to specify a type that the parameter passed from WebAssembly.    Let’s create a module named *globals.wat* that imports three numbers from JavaScript. The WAT file in Listing 2-11 declares global variables for a 32-bit integer, a 32-bit floating-point, and a 64-bit floating-point numeric value.    **globals.wat**    ``` (module 1 (global $import_integer_32  (import "env" "import_i32") i32)   (global $import_float_32    (import "env" "import_f32") f32)   (global $import_float_64    (import "env" "import_f64") f64)  2 (import "js" "log_i32" (func $log_i32 (param i32)))   (import "js" "log_f32" (func $log_f32 (param f32)))   (import "js" "log_f64" (func $log_f64 (param f64)))    (func (export "globaltest")   3 (call $log_i32 (global.get $import_integer_32))   4 (call $log_f32 (global.get $import_float_32))   5 (call $log_f64 (global.get $import_float_64))   ) ) ```    Listing 2-11: Importing alternative versions of the JavaScript function    We first declare the globals, including their types and import location 1. We’re also importing a `log` function from JavaScript. WebAssembly requires us to specify data types, so we import three functions, each with different types for the parameter: a 32-bit integer, a 32-bit float, and a 64-bit float 2.    The variable passed into `$log_f64` is `(global.get` `$import_float_64)`, which tells WebAssembly that the variable we’re pushing onto the stack is global. If you wanted to push a local variable called `$x` onto the stack, you would need to execute the expression `(local.get` `$x)`. We’ll cover local variables later in this chapter.    In JavaScript, all of these functions take a dynamic variable. The JavaScript functions will be almost identical. In the function `globaltest`, we call the 32-bit integer version of the `log` function (`$log_i32`) 3, followed by the 32-bit float (`$log_f32`) 4 and the 64-bit float (`log_f64)` 5. These functions will log three different messages to demonstrate the perils of moving between the native 64-bit floating-point values in JavaScript and the data types supported by WebAssembly. Before we look at the output, we need to create a JavaScript file to run our WebAssembly module. We’ll start by declaring a `global_test` variable followed by a `log_message` function that will be called for each of our data types, as shown in Listing 2-12.   **globals.js**    ``` const fs = require('fs'); const bytes = fs.readFileSync('./globals.wasm'); let global_test = null;  let importObject = {   js: {     log_i32: (value) => { console.log ("i32: ", value) },     log_f32: (value) => { console.log ("f32: ", value) },     log_f64: (value) => { console.log ("f64: ", value) },   },   env: {     import_i32: 5_000_000_000, // _ is ignored in numbers in JS and WAT     import_f32: 123.0123456789,     import_f64: 123.0123456789,   } }; ... ```    Listing 2-12: Setting `importObject` functions and values    In Listing 2-12, there are three different JavaScript functions passed to the WebAssembly module using `importObject`: `log_i32`, `log_f32`, and `log_f64`. Each of these functions is a wrapper around the `console.log` function. The functions pass a string as a prefix to the value from the WebAssembly module. These functions take in only a single parameter called `value`. JavaScript doesn’t assign a type to the parameter in the same way WebAssembly does, so the same function could have been used three times. The only reason we didn’t use the same function three times is because we wanted to change the string that prefixed the values to keep the output clear.    We chose the values in Listing 2-12 to demonstrate the limitations of each data type. We set the global variable `import_int32` to a value of `5,000,000,000`, which we pass into WebAssembly as a 32-bit integer. That value is larger than can be held by a 32-bit integer. We set the global variable `import_f32` to `123.0123456789`, which has a higher level of precision than is supported by the 32-bit floating-point variable set in our WebAssembly module. The final global variable set in the `importObject` is `import_f64`, which, unlike the previous two variables, is large enough to hold the value passed into it.    The code in Listing 2-13 instantiates our WebAssembly module and executes the `globaltest` function.    **globals.js**    ``` ... ( async () => {   let obj = await WebAssembly.instantiate(new Uint8Array (bytes),                                           importObject);   ({globaltest: global_test} = obj.instance.exports);    global_test(); })(); ```    Listing 2-13: Instantiating the WebAssembly module in the asynchronous IIFE    Now that we have all our code in the JavaScript and WAT files, we can compile the WAT file into *globals.wasm* using the following `wat2wasm` call:    ``` wat2wasm globals.wat ```    After compiling *globals.wasm*, we run our application using the following `node` command:    ``` node globals.js ```    When you run this JavaScript file using `node`, you should see the output in Listing 2-14 logged to the console.    ``` i32: 705032704 f32: 123.01234436035156 f64: 123.0123456789 ```    Listing 2-14: Output logged to the console from *globals.js*    We passed in a value of `5,000,000,000` using our `importObject`, but our output shows a value of `705,032,704`. The reason is that a 32-bit unsigned integer has a maximum value of 4,294,967,295\. If you add `1` to that number, the 32-bit integer wraps back around to a value of `0`. So if you take the 5,000,000,000 number we passed in and subtract 4,294,967,296, the result is 705,032,704\. The lesson is, if you’re dealing with numbers larger than a few billion, you might not be able to work with 32-bit integers. Unfortunately, as mentioned earlier, you can’t pass 64-bit integers to JavaScript from WebAssembly. If you want to pass 64-bit integers to JavaScript from WebAssembly, you’ll need to convert them to 64-bit floats or pass them as two 32-bit integers.    We passed a value of `123.0123456789` to our WebAssembly module, but because the 32-bit floating-point number has such limited precision, the best it can do is approximate that number, and it doesn’t do a great job of it. A 32-bit floating-point number in JavaScript and WebAssembly uses 23 bits to represent the number and multiplies it by two raised to an 8-bit exponent value. All floating-point numbers are approximations, but 64-bit floating-point numbers do a much better job of those approximations. The performance differences you’ll see using 32-bit versus 64-bit floating-point numbers vary with your hardware. If you want to use 32-bit floating-point numbers to improve the performance of your application, it’s a good idea to know the target hardware. Some mobile devices might see a larger performance boost using 32-bit floating-point numbers.    The final message shows the 64-bit floating-point value returned to JavaScript as `f64: 123.0123456789`.    As you can see, this is the first number that remains unmodified from what we passed into the WebAssembly module. That by no means indicates that you should always use 64-bit floating-point numbers. Addition, subtraction, and multiplication typically perform three to five times faster with integers. Dividing by powers of two is also several times faster. However, division by anything but a power of two can be faster with floating-point numbers.    We’ll explore these data types in more detail in Chapter 4\. Now that you have a better understanding of globals and types, let’s examine local variables.    ### Local Variables    In WebAssembly, the values stored in local variables and parameters are pushed onto the stack with the `local.get` expression. In Chapter 1, we wrote a small function that performed the addition of two parameters passed into the function that looked like Listing 2-15.    **AddInt.wat**    ``` (module     (func (export "AddInt")     (param $value_1 i32) (param $value_2 i32)     (result i32)         local.get $value_1         local.get $value_2         i32.add     ) ) ```    Listing 2-15: WebAssembly module with a 32-bit integer add    Let’s make a few modifications to the code. To demonstrate how we can use local variables, we’ll square the value of the sum that `AddInt` returned. Create a new file named *SumSquared.wat* and add the code in Listing 2-16. The changes are called out with numbers.    **SumSquared.wat**    ``` (module   (func (export 1"SumSquared")     (param $value_1 i32) (param $value_2 i32)     (result i32)   2 (local $sum i32)         3 (i32.add (local.get $value_1) (local.get $value_2))  4 local.set $sum    5 **(**i32.mul (6local.get $sum) (local.get $sum))   ) ) ```    Listing 2-16: Bit integer parameter and local variable definition    First, we change the name in the export to `SumSquared` 1. We add a local variable called `$sum` 2 that we’ll use to store the result of the call to `i32.add` 3. We change `i32.add` to use the S-Expression syntax. Immediately after that, we call `local.set` `$sum` to pop the value off the stack and set the new local variable `$sum` 4. Then we call `i32.mul` 5 using the S-Expression syntax, passing in the value of `$sum` for both parameters. This is done through a call to `local.get` 6.    To test this function, create a new JavaScript file named *SumSquared.js* and add the code in Listing 2-17.   ``` const fs = require('fs'); const bytes = fs.readFileSync(__dirname + '/SumSquared.wasm'); const val1 = parseInt(process.argv[2]); const val2 = parseInt(process.argv[3]);  (async () => {   const obj =     await WebAssembly.instantiate(new Uint8Array (bytes));   let sum_sq =       obj.instance.exports.SumSquared(val1, val2);       console.log (         `(${val1} + ${val2}) * (${val1} + ${val2}) = ${sum_sq}`       ); })(); ```    Listing 2-17: JavaScript that executes the *SumSquared.js* WebAssembly module    Once you’ve created your *SumSquared.js* function, you can run it the same way you ran the *AddInt.js* file earlier, making sure to pass in two extra parameters that represent the values you want to sum and then square. The following command will add 2 and 3, and then square the result:    ``` node SumSquared.js 2 3 ```    The output of that run looks like this:    ``` (2 + 3) * (2 + 3) = 25 ```    You should now understand how to set a local variable from a value on the stack and how to add a value to the stack from a global variable. Next, let’s explore how to unpack the S-Expression syntax.    ### Unpacking S-Expressions    So far we’ve been mixing the use of S-Expressions with the linear WAT syntax. However, the browser debugger doesn’t keep your S-Expressions intact when you’re debugging; instead, it unpacks them. Because you’ll want to use your knowledge of WAT to decompile and debug WebAssembly, you’ll need to understand the unpacking process. We’ll walk through the process the `wat2wasm` compiler uses to unpack a short piece of WAT code. The unpacking process evaluates the expressions inside out first and then in order. It initially dives into each S-Expression looking for subexpressions. If subexpressions exist, it evaluates the subexpressions first. If two expressions are at the same depth, it evaluates them in order. Let’s look at Listing 2-18.    ``` 1  (i32.mul          ;; executes 7th (last) 2 (i32.add        ;; executes 3rd   3 (i32.const 3) ;; executes 1st   4 (i32.const 2) ;; executes 2nd   ) 5 (i32.sub        ;; executes 6th   6 (i32.const 9) ;; executes 4th   7 (i32.const 7) ;; executes 5th   ) ) ```    Listing 2-18: Using the S-Expression syntax    First, we need to go inside our `i32.mul` expression 1 to see if any subexpressions exist. We find two subexpressions, an `i32.add` expression 2 and an `i32.sub` expression 5. We look at the first of these two expressions and go inside `i32.add` 2, evaluating `(i32.const` `3)` 3, which pushes a 32-bit integer `3` onto our stack. Because nothing is left to evaluate inside that statement, we move on to evaluate `(i32.const` `2)` 4, which pushes a 32-bit integer `2` onto the stack. Then the S-Expression executes `i32.add` 2. The first three lines executed in the S-Expression are shown in Listing 2-19.    ``` i32.const 3 i32.const 2 i32.add ```    Listing 2-19: Code from `i32.add` after it’s unpacked    Now that `i32.add` is executed, the next piece to get unpacked is `i32.sub`. Similarly, the code first goes inside the S-Expression and executes the `(i32.const` `9)` expression 6 followed by the `(i32.const` `7)` expression 7. Once those two constants are pushed onto the stack, the code executes `i32.sub`. The unpacked subexpression looks like Listing 2-20.    ``` i32.const 9 i32.const 7 i32.sub ```    Listing 2-20: Code from `i32.sub` after the S-Expression is unpacked    After the `i32.add` and `i32.sub` S-Expressions have been executed, the unpacked version executes the `i32.mul` command.    The fully unpacked version of the S-Expression is shown in Listing 2-21.    ``` i32.const 3  ;; Stack = [3] i32.const 2  ;; Stack = [2, 3] i32.add      ;; 2 & 3 popped from stack, added sum of 5 pushed onto stack [5]  i32.const 9  ;; Stack = [9,5] i32.const 7  ;; Stack = [7,9,5] i32.sub      ;; 7 & 9 popped off stack . 9-7=2 pushed on stack [2,5]  i32.mul      ;; 2,5 popped off stack, 2x5=10 is pushed on the stack [10] ```    Listing 2-21: Example of using the WAT stack    How the stack machine works might seem a little daunting at first, but it will feel more natural once you get accustomed to it. We recommend using S-Expressions until you’re comfortable with the stack machine. The S-Expression syntax is an excellent way to ease your way into WAT if you’re only familiar with higher-level languages.    ### Indexed Variables    WAT doesn’t require you to name your variables and functions. Instead, you can use index numbers to reference functions and variables that you haven’t yet named. From time to time, you might see WAT code that uses these indexed variables and functions. Sometimes this code comes from disassembly, although we’ve also seen people write code that looks like this occasionally.    Code that calls `local.get` followed by a number is retrieving a local variable based on the order it appears in the WebAssembly code. For example, we could have written our *AddInt.wat* file in Listing 2-21 like the code in Listing 2-22.    ``` (module     (func (export "AddInt")   1 (param i32 i32)     (result i32)       2 local.get 0       3 local.get 1         i32.add     ) ) ```    Listing 2-22: Using variables    As you can see, we don’t name the parameters in the `param` 1 expression. A convenient part of this code style is that you can declare multiple parameters in a single expression by adding more types. When we call `local.get`, we need to pass in a zero indexed number to retrieve the proper parameter. The first call to `local.get` 2 retrieves the first parameter by passing in `0`. The second call to `local.get` 3 retrieves the second parameter by passing in `1`. You can also use this syntax for functions and global variables. I find this syntax difficult to read, so I won’t use it in this book. However, I felt it was necessary to introduce because some debuggers use it.    ### Converting Between Types    JavaScript developers don’t need to deal with converting between different numeric types. All numbers in JavaScript are 64-bit floating-point numbers. That simplifies coding for developers but comes at a performance cost. When you’re working with WebAssembly, you need to be more familiar with your numeric data. If you need to perform numeric operations between two variables with different data types, you’ll need to do some conversion. Table 2-1 provides the conversion functions you can use in WAT to convert between the different numeric data types.      Table 2-1: Numeric Type Conversion Functions       | **Function** | **Action** | | --- | --- | | i32.trunc_s/f64 i32.trunc_u/f64 | Convert a 64-bit float to a 32-bit integer  | | i32.trunc_s/f32 i32.trunc_u/f32 i32.reinterpret/f32 | Convert a 32-bit float to a 32-bit integer   | | i32.wrap/i64 | Convert a 64-bit integer to a 32-bit integer | | i64.trunc_s/f64 i64.trunc_u/f64 i64.reinterpret/f64 | Convert a 64-bit float to a 64-bit integer   | | i64.extend_s/i32 i64.extend_u/i32 | Convert a 32-bit integer to a 64-bit integer  | | i64.trunc_s/f32 i64.trunc_u/f32 | Convert a 32-bit float to a 64-bit integer  | | f32.demote/f64 | Convert a 64-bit float to a 32-bit float | | f32.convert_s/i32 f32.convert_u/i32 f32.reinterpret/i32 | Convert a 32-bit integer to a 32-bit float   | | f32.convert_s/i64 f32.convert_u/i64 | Convert a 64-bit integer to a 32-bit float  | | f64.promote/f32 | Convert a 32-bit float to a 64-bit float | | f64.convert_s/i32 f64.convert_u/i32 | Convert a 32-bit integer to a 64-bit float  | | f64.convert_s/i64 f64.convert_u/i64 f64.reinterpret/i64 | Convert a 64-bit integer to a 64-bit float   |    I omitted quite a bit of information from this table to stay focused. The `_u` and `_s` suffixes on expressions, such as `convert`, `trunc`, and `extend`, let WebAssembly know whether the integers you’re working with are unsigned (cannot be negative) or signed (can be negative), respectively. A `trunc` expression truncates the fractional portion of a floating-point number when it converts it to an integer. Floating-point numbers can be promoted from an `f32` to an `f64` or demoted from an `f64` to an `f32`. Integers are simply converted to floating-point numbers. The `wrap` command puts the lower 32 bits of a 64-bit integer into an `i32`. The `reinterpret` command keeps the bits of an integer or floating-point value the same when it reinterprets them as a different data type.    ## if/else Conditional Logic    One way that WAT differs from an assembly language is that it contains some higher-level control flow statements, such as `if` and `else`. WebAssembly doesn’t have a boolean type; instead, it uses `i32` values to represent booleans. An `if` statement requires an `i32` to be on the top of the stack to evaluate control flow. The `if` statement evaluates any non-zero value as true and zero as false. The syntax for an `if`/`else` statement using S-Expressions looks like Listing 2-23.    ``` ;; This code is for demonstration and not part of a larger app (if (local.get $bool_i32)   (then     ;; do something if $bool_i32 is not 0  ;; nop is a "no operation" opcode.      nop ;; I use it to stand in for code that would actually do something.   )   (else     ;; do something if $bool_i32 is 0     nop   ) ) ```    Listing 2-23: The `if`/`else` syntax using S-Expressions    Let’s also look at what the unpacked version of the `if`/`else` statements look like. Unpacking an `if`/`else` statement might look a little different than you would expect. There is no `(then``)` expression in the unpacked version. Listing 2-24 shows how the code in Listing 2-23 would look after it’s unpacked.    ``` ;; This code is for demonstration and not part of a larger app local.get $bool_i32  if   ;; do something if $bool_i32 is not 0   nop else  ;; do something if $bool_i32 is 0   nop end ```    Listing 2-24: The `if`/`else` statement using the linear syntax    The `then` S-Expression is pure syntactic sugar and doesn’t exist in the unpacked version of our code. The unpacked version requires an `end` statement that doesn’t exist in the S-Expression syntax.    When you’re writing high-level programs, you use boolean logic with your `if`/`else` statements. In JavaScript, you might have an `if` statement that looks something like this:    ``` if( x > y && y < 6 ) ```    To replicate this in WebAssembly, you would need to use expressions that conditionally return 32-bit integer values. Listing 2-25 shows how we would do the logic from the JavaScript `if` example with `x` and `y` as 32-bit integers.    ``` ;; This code is for demonstration and not part of a larger app (if   (i32.and     (i32.gt_s (local.get $x) (local.get $y) ) ;; signed greater than     (i32.lt_s  (local.get $y) (i32.const 6) ) ;; signed less than   )   (then     ;; x is greater than y and y is less than 6     nop   ) ) ```    Listing 2-25: An `if` expression with an `i32.and` using S-Expression syntax    It looks a bit complicated in comparison. The `i32.and` expression performs a bitwise AND operation on 32-bit integers. It ends up working out because `i32.gt_s` and `i32.lt_s` both return `1` if true and `0` if false. In WebAssembly, you must keep in mind that you’re using bitwise AND/OR operations; if you use an `i32.and` on a value of `2` and a value of `1`, it will result in `0` because of the way the binary AND works. You might want a logical AND instead of a binary AND, but `i32.and` is a binary AND. If you’re unfamiliar with binary AND/OR operations, we discuss them in more detail in Chapter 4\. In some ways, complicated `if` expressions look better when they’re unpacked. Listing 2-26 shows the code in Listing 2-25 without the sugar.    ``` ;; This code is for demonstration and not part of a larger app local.get $x local.get $y i32.gt_s      ;; pushes 1 on the stack if $x > $y  local.get $y i32.const 6 i32.lt_s      ;; pushes 1 on the stack if $y < 6  i32.and       ;; do a bitwise and on the last two values on the stack  if   ;; x is greater than y and y is less than 6   nop end ```    Listing 2-26: An `if` statement with `i32.and` using stack syntax    Listing 2-27 shows there are similar expressions you can use if `$x` and `$y` are 64-bit or 32-bit floating-point numbers.    ``` ;; This code is for demonstration and not part of a larger app (if  (i32.and  1 (f32.gt (local.get $x) (local.get $y) )   2 (f32.lt  (local.get $y) (f32.const 6) )   )   (then     ;; x is greater than y and y is less than 6     nop   ) ) ```    Listing 2-27: Using `f32` comparisons but `i32.and` results    Notice that we changed `i32.gt_s` and `i32.lt_s` to `f32.gt` 1 and `f32.lt` 2, respectively. Many integer operations must specify whether they support negative numbers using the `_s` suffix. You don’t have to do that for floating-point numbers, because all floating-point numbers are signed and have a dedicated sign bit.    There are a total of 40 comparison expressions in WebAssembly. Table 2-2 shows expressions that are useful in conjunction with the `if`/`else` expressions. Unless otherwise stated, these functions pop two values off the stack, compare them, and push `1` on the stack if true and `0` on the stack if false.      Table 2-2: Functions to Use with `if/else`       | **Function** | **Action** | | --- | --- | | i32.eq i64.eq f32.eq f64.eq | Test for equality    | | i32.ne i64.ne f32.ne f64.ne | Not equal    | | i32.lt_s i32.lt_u i64.lt_s i64.lt_u f32.lt f64.lt | Less than test. The `_s` suffix indicates signed comparison; `_u` indicates unsigned.     | | i32.le_s i32.le_u i64.le_s i64.le_u f32.le f64.le | Less than or equal test. The `_s` suffix indicates signed comparison; `_u` indicates unsigned.      | | i32.gt_s i32.gt_u f32.gt f64.gt i64.gt_s i64.gt_u | Greater than test. The `_s` suffix indicates signed comparison; `_u` indicates unsigned.      | | i32.ge_s i32.ge_u i64.ge_s i64.ge_u f32.ge f64.ge | Greater than or equal test. The `_s` suffix indicates signed comparison; `_u` indicates unsigned.      | | i32.and i64.and | Bitwise AND  | | i32.or i64.or | Bitwise OR  | | i32.xor i64.xor | Bitwise exclusive OR  | | i32.eqz i64.eqz | Test a floating-point number to see if it has a zero value  |    ## Loops and Blocks    The branching expressions in WAT are different than branching statements you might find in an assembly language. The differences prevent the spaghetti code that comes about as the result of jumps to arbitrary locations. If you want your code to jump backward, you must put your code inside a loop. If you want your code to jump forward, you must put it inside a block. For the kind of functionality you would see in a high-level programming language, you must use the loop and block statements together. Let’s explore these structures with some throwaway code examples that won’t be a part of a larger app.    ### The block Statement    First, we’ll look at the `block` expression. The block and loop statements in WAT work a bit like `goto` statements in assembly or some low-level programming languages. However, the code can only jump to the end of a `block` if it’s inside that `block`. That prevents the code from arbitrarily branching to a `block` label from anywhere within your program. If the code jumps to the end of a `block`, the code that performs that jump must exist inside that `block`. Listing 2-28 shows an example.   ``` ;; This code is for demonstration and not part of a larger app 1 (block $jump_to_end 2 br $jump_to_end   ;; code below the branch does not execute. br jumps to the end of the block 3 nop )  ;; This is where the br statement jumps to 4  nop ```    Listing 2-28: Declaring a `block` in WAT    The `br` 2 statement is a branch statement that instructs the program to jump to a different location in the code. You might expect `br` to jump back to the beginning of the block where the label is defined 1. But that isn’t what happens. If you use a `br` statement within a block to jump to the block’s label, it exits that block and begins to execute the code immediately outside the block 4. That means that the code directly below the `br` statement 3 never executes. As mentioned earlier, this code isn’t meant to be used, we only wanted to demonstrate how the `block` and `br` statements work.    The way we use the `br` statement here isn’t useful. Because the `br` statement always branches to the end of the labeled block, you want it to branch conditionally.    The `br_if` conditional branch in Listing 2-29 is used to branch given a condition, unlike the code in Listing 2-28.    ``` ;; This code is for demonstration and not part of a larger app (block $jump_to_end 1 local.get $should_I_branch 2 br_if $jump_to_end 	  ;; code below the branch will execute if $should_I_branch is 0 3 nop )  4  nop ```    Listing 2-29: Branching to the end of the block with `br_if`    The new version of the code pushes a 32-bit integer value `$should_I_branch` onto the stack 1. The `br_if` statement pops the top value off the stack 2, and if that value isn’t `0`, branches to the end of the `$jump_to_end` block 4. If `$should_I_branch` is `0`, the code in the block below the `br_if` statement 3 executes.    ## The loop Expression    The `block` expression always jumps to the end of the `block` on a branch. If you need to jump to the beginning of a block of code, use the `loop` statement. Listing 2-30 shows how a WAT `loop` statement works. You would be mistaken if you think this code executes in an infinite loop.    ``` ;; This code is for demonstration and not part of a larger app (loop $not_gonna_loop  ;; this code will only execute once 1 nop )  ;; because there is no branch in our loop, it exits the loop block at the end 2  nop ```    Listing 2-30: A `loop` expression that doesn’t loop    In fact, a `loop` expression in WAT doesn’t loop on its own; it needs a branch statement located inside the loop to branch back to the beginning of the `loop` expression. A `loop` block will execute the code inside it 1 just like a `block` expression and, without a branch, exits at the end of the block 2.    If for any reason you want to create an infinite loop, you need to execute a `br` statement at the end of your `loop`, as shown in Listing 2-31.    ``` ;; This code is for demonstration and not part of a larger app   (loop $infinite_loop     ;; this code will execute in an infinite loop     nop    1 br $infinite_loop   )   ;; this code will never execute because the loop above is infinite 2 nop ```    Listing 2-31: Branching in an infinite loop    The `br` statement 1 always branches back to the top of the `$infinite_loop` block with every iteration. The code below the `loop` 2 never executes.    ### Using block and loop Together    To make your loop able to break and continue, you need to use the `loop` and the `block` expressions together. Let’s put together a little WebAssembly module and JavaScript app that finds factorials. The program will run a loop until we have the factorial value of the number passed into the function. That will allow us to test the `continue` and `break` functionality of our `loop` expression. Our simple loop will calculate the factorial value for each number up to some parameter value `$n` that we’ll pass in from JavaScript. Then the value of `$n` factorial will be returned to JavaScript.    Create a new file named *loop.wat* and add the code in Listing 2-32.    **loop.wat**    ``` (module 1 (import "env" "log" (func $log (param i32 i32)))    (func $loop_test (export "loop_test") (param $n i32)     (result i32)      (local $i         i32)     (local $factorial i32)          (local.set $factorial (i32.const 1))    2 (loop $continue (block $break	;; $continue loop and $break block     3 (local.set $i            	;; $i++          (i32.add (local.get $i) (i32.const 1))       )    4 ;; value of $i factorial       (local.set $factorial ;; $factorial = $i * $factorial          (i32.mul (local.get $i) (local.get $factorial))       ) 	       ;; call $log passing parameters $i, $factorial     5 (call $log (local.get $i) (local.get $factorial))            6 (br_if $break        (i32.eq (local.get $i) (local.get $n)));;if $i==$n break from loop     7 br $continue        ;; branch to top of loop     ))    8 local.get $factorial ;; return $factorial to calling JavaScript   ) ) ```    Listing 2-32: Branching forward and backward with a `loop` and a `block`    The first expression in this module is an import of the `$log` function 1. In a moment, we’ll write this function in JavaScript and call it on every pass through our loop to log the value of `$i` factorial for each pass. We labeled the loop `$continue` 2 and the block `$break` 2 because branching to `$continue` will continue to execute the loop and branching to `$break` will break out of the loop. We could have done this without using the `$break` block, but we want to demonstrate how the loop can work in conjunction with a block. This allows your code to work like a `break` and a `continue` statement in a high-level programming language.    The `loop` increments `$i` 3 and then calculates a new `$factorial` value by multiplying `$i` by the old `$factorial` value 4. It then makes a call to log with `$i` and `$factorial` 5. We use a `br_if` to break out of the `loop` if `$i` == `$n` 6. If we don’t break out of `loop`, we branch back to the top of `loop` 7. When the `loop` exits, we push the value of `$factorial` onto the stack 8 so we can return that value to the calling JavaScript.    Once you have your WAT file, compile it into a WebAssembly file using the following command:    ``` wat2wasm loop.wat ```    Now we’ll create a JavaScript file to execute the WebAssembly. Create a *loop.js* file and enter the code in Listing 2-33.    **loop.js**    ``` const fs = require('fs'); const bytes = fs.readFileSync(__dirname + '/loop.wasm'); 1 const n = parseInt(process.argv[2] || "1"); // we will loop n times let loop_test = null;  let importObject = {   env: {   2 log: function(n, factorial) { // log n factorial to output tag       console.log(`${n}! = ${factorial}`);     }   } };   ( async() => { 3 let obj = await WebAssembly.instantiate( new Uint8Array(bytes),                                            importObject );  4 loop_test = obj.instance.exports.loop_test;  5 const factorial = loop_test(n); // call our loop test 6 console.log(`result ${n}! = ${factorial}`); 7 if (n > 12) {     console.log(`     ===============================================================     Factorials greater than 12 are too large for a 32-bit integer.     ===============================================================     `)   } })(); ```    Listing 2-33: Calling the `loop_test` from JavaScript    The `log` 2 function, which our WAT code will call, logs a string to the console with the values of `n` 1 and `n` factorial passed from the WAT `loop`. When we instantiate the module 3, we pass a value of `n` to the `loop_test` 4 function. The `loop_test` function finds the factorial as a result 5. We then use a `console.log` 6 call to display the value of `n` and `n` factorial. We have a check at the end to make sure the number we enter isn’t greater than a value of `12` 7, because signed 32-bit integers only support numbers up to about 2 billion. Run *loop.js* using `node` by executing the following on the command line:    ``` node loop.js 10 ```    Listing 2-34 shows the output you should see on the command line.    ``` 1! = 1 2! = 2 3! = 6 4! = 24 5! = 120 6! = 720 7! = 5040 8! = 40320 9! = 362880 10! = 3628800 result 10! = 3628800 ```    Listing 2-34: Output from *loop.js*    Now that you know how loops work in WAT, let’s look at branch tables.    ### Branching with br_table    Another way to use the `block` expression in WAT is in conjunction with a `br_table` *expression,* which allows you to implement a kind of `switch` statement. It’s meant to provide the kind of jump table performance you get with a `switch` statement when there are a large number of branches. The `br_table` expression takes a list of blocks and an index into that list of blocks. It then breaks out of whichever block your index points to. The awkward thing about using a branch table is that the code can only break out of a block it’s inside. That means you must declare all of your blocks ahead of time. Listing 2-35 shows what the WAT code looks like to build a `br_table`.    ``` ;; This code is for demonstration and not part of a larger app 1 (block $block_0 (block $block_1 (block $block_2 (block $block_3 (block $block_4 (block $block_5 2 (br_table $block_0 $block_1 $block_2 $block_3 $block_4 $block_5   (local.get $val) ) 3 ) ;; block 5 i32.const 55 return  )   ;; block 4 i32.const 44 return  )    ;; block 3 i32.const 33 return  )    ;; block 2 i32.const 22 return  )    ;; block 1 i32.const 11 return  )   ;; block 0 i32.const 0 return ```    Listing 2-35: Using the `br_table` syntax from within WAT    We define all the `block` expressions before the `br_table` expression 1. So when the `br_table` expression is called 2, it’s not always completely clear where in the code it will jump. This is why we added the comments 3 in the code indicating which `block` was ending.    The `br_table` provides some performance improvement over the use of `if` expressions when you have a large number of branches. In our testing, using the `br_table` expression wasn’t worthwhile until there were about a dozen branches. Of course this will depend on the embedding environment and hardware it runs on. Even at this number of branches, the `br_table` was still slower on Chrome than `if` statements. Firefox with about a dozen branches was noticeably faster with the `br_table` expression.    ## Summary    In this chapter, we covered many of the WAT programming basics. After learning to create and execute a WebAssembly module in Chapter 1, you moved on to creating the traditional hello world application in this chapter. Creating a hello world application is a bit more advanced in WAT than in most programming languages.    After completing a few initial programs, we began looking at some of the basic features of WAT and how they differ from a traditionally high-level language like JavaScript. We explored variables and constants and how they can be pushed onto the stack using WAT commands. We discussed the S-Expression syntax and how to unpack it. We also briefly mentioned indexed local variables and functions, and introduced you to that syntax. You learned the basic branching and looping structures, and how to use them within the WAT syntax. In the next chapter, we’ll explore functions and function tables in WAT, and how they interact with JavaScript and other WAT modules.````
