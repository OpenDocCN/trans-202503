# 第三章：10 数字与数学

![](img/opener-img.png)

在本书中，我一直在说 FPGAs 擅长快速执行数学运算。我还说过，FPGAs 擅长并行执行任务，而这两项优势——快速数学运算和并行处理——是它们的杀手级特性。然而，在低级 Verilog 或 VHDL 代码中，处理数字和数学是充满陷阱的。

在本章中，我们将探讨 FPGAs 如何管理数学运算，以便你可以避免那些陷阱。要了解加法、减法、乘法和除法等运算的细节，我们还需要了解如何在 FPGA 内部表示数字，不论是正数还是负数，是否带小数。现在是时候进入计算机算术的奇妙世界了。

## 数值数据类型

在 Verilog 或 VHDL 中表示数字有许多方法，这一点与所有编程语言一样。例如，如果你只需要存储整数，可以使用整数数据类型，但如果需要存储小数，则需要使用可以表示小数的数据类型。在任何编程语言中，为数据选择正确的类型至关重要。如果将数据分配给错误的数据类型，你可能会遇到编译错误，或者更糟糕的是，设计出现奇怪的行为。例如，试图将小数赋值给整数数据类型，可能会截断小数部分，导致意外的四舍五入操作。

此外，你还不想使用超过必要的资源。例如，你可以使用 64 位宽的数据类型来创建每个信号，但如果你只需要一个从 0 到 7 的计数器，显然这是一种过度设计。与大多数其他编程语言相比，FPGAs 对数据类型的控制更加精细。例如，C 语言有 uint8_t、uint16_t 和 uint32_t 数据类型，它们分别创建 8 位、16 位和 32 位的数据宽度，但没有中间值。相比之下，在 Verilog 和 VHDL 中，你可以创建 9 位、15 位、23 位宽的信号，或者任何其他位宽。本章后面我们将探讨信号尺寸的建议。

### 表示有符号与无符号值

当你处理数字时，需要知道它们是正数还是负数。有时候，比如当你计数时钟周期以跟踪时间，你会知道这些值都是正数。在这种情况下，你可以使用 *无符号* 数据类型来存储数字；符号（正数或负数）没有指定，默认假设为正数。其他时候，你需要处理负数：例如，当你读取温度值时，数字的符号可能会变化。在这些情况下，你需要使用 *有符号* 数据类型，其中符号（正数或负数）是明确指定的。

默认情况下，Verilog 和 VHDL 中的信号是无符号的。例如，如果我们需要一个从 0 到 7 的计数器，我们可以在 Verilog 中声明一个信号，如 reg [2:0] counter;，或者在 VHDL 中声明为 signal counter : std_logic_vector(2 downto 0);。我们在整本书中都使用了这样的代码。它会创建一个 3 位寄存器，且由于默认是无符号的，寄存器中的值将全部解释为正数。如果我们希望 counter 能表示负数和正数，我们必须显式声明它为有符号，使用 signed 关键字。在 Verilog 中，我们会写成 reg signed [2:0] counter;，在 VHDL 中，我们会使用 signal counter : signed(2 downto 0);。

注意

*要在 VHDL 中访问 signed 关键字，你需要使用 numeric_std 包，可以通过在文件顶部添加一行 use ieee.numeric_std.all; 来实现。你可能会看到一些代码使用了 std_logic_arith 包，但这不是一个官方的 IEEE 支持库，我不推荐使用它。使用这个包比使用 numeric_std 容易出错。*

使用 signed 关键字明确告诉工具，这个 3 位宽的寄存器可以表示负数和正数。但是我们实际能用它表示哪些值呢？表 10-1 比较了 3 位无符号寄存器和 3 位有符号寄存器表示的值。（我们将在下一节讨论如何确定有符号值。）

表 10-1： 3 位无符号与有符号十进制值

| 位 | 无符号十进制值 | 有符号十进制值 |
| --- | --- | --- |
| 000 | 0 | 0 |
| 001 | 1 | 1 |
| 010 | 2 | 2 |
| 011 | 3 | 3 |
| 100 | 4 | –4 |
| 101 | 5 | –3 |
| 110 | 6 | –2 |
| 111 | 7 | –1 |

请注意，当一个寄存器被声明为带符号时，我们会失去一些正数范围内的数字（在这个例子中是 4, 5, 6 和 7），但会在负数范围内获得一些数字（–1, –2, –3 和–4）。无符号寄存器能够表示的数字范围是 0 到 2*^N* − 1，其中*N*是可用的位数。对于这个 3 位寄存器，如果寄存器是无符号的，我们可以表示从 0 到 2³ − 1 = 7。另一方面，带符号寄存器能够表示的数字范围是 –2^(*^N*^(–1)) 到 2^(*^N*^(–1)) − 1。在这种情况下，它给我们的范围是 –2^((3–1)) 到 2^((3–1)) − 1，即 –4 到 3。数据仍然是 3 位的二进制数据，但*这些二进制数据表示的内容*是不同的。

另一个需要注意的特点是在表 10-1 中，所有负值的最高有效位都为 1。实际上，在带符号的数值中，最高有效位是*符号位*，它表示所表示的数字是正数还是负数。对于带符号的二进制数，符号位为 0 表示数字是正数，而符号位为 1 表示数字是负数。

### 求二的补码

如何知道一个带负号的二进制数应该表示什么十进制值呢？你需要进行*二补数*运算，这是一种数学操作，其中你将数值的位反转，然后加 1。例如，考虑二进制数101。如果它是无符号数，我们会将其解释为十进制的 5，但如果它是有符号数，那么符号位上的 1 告诉我们，表示的值应该是负数，因此我们必须进行二补数运算。首先，我们将101的位反转，得到010。然后加 1，得到011，它在十进制中是 3。最后，我们加上负号得到 –3。回到表 10-1，你会看到在101这一行就是这个结果。

注意

*反转加一法的替代方法是，从最右边（最低有效）位开始，向左移动，直到遇到第一个 1，然后将这个 1 左边的所有位反转。例如，100010 100 变成 011101 100。三个加粗的位，直到并包括右边第一个 1，保持不变，而其他位则反转。十进制中，011101100 是 236；加上负号后，我们知道 100010100 表示 –236。这个方法避免了加法操作，对于长数字可能更简单。*

我们也可以反向进行二补数运算，将一个负的十进制数转换为其带符号的二进制表示。例如，如何用 3 位二进制表示 –1 呢？首先，去掉负号得到 1，它的二进制表示是001。然后反转位，得到110，再加 1，得到111。同样，查看表 10-1，你会发现这是正确的结果。

取二进制补码是我们人类用来更好理解如何解释有符号数字的一个有用技巧，但这种“反转并加一”的逻辑*并不是 FPGA 在处理负值时实际执行的操作*。无论一个数字是有符号还是无符号，数据都是二进制的 1 和 0。不同之处在于这些 1 和 0 的*表示方式*。当你有一个 3 位无符号信号，设置为101时，它表示十进制值 5。当你有一个 3 位有符号信号，设置为101时，它表示十进制值-3。FPGA 并不需要反转并加上位来知道这一点。它只需要知道该信号是有符号数据类型。这是一个重要的点，随着我们在二进制中探索数学运算，这一点会更加清晰。

### 正确地调整信号大小

当你编写处理有符号和无符号数据类型的 Verilog 或 VHDL 代码时，必须确保你创建的信号大小正确。如果你试图将一个过大的数字存储到一个过小的信号中，你将会丢失数据。如我们刚才讨论的那样，例如，一个 3 位无符号计数器的最大值是 7。如果你尝试从 7 开始递增，它不会变成 8；实际上，它会回到 0。这有时被称为*回绕*，如果你没有预料到这一点，你可能会丢失计数。如本章后面所述，确保信号足够大以容纳你的数据，在信号用来保存数学运算结果时尤其重要。

为了避免数据丢失，你可能会倾向于将所有信号做得比实际需要的更大，但这样做也有一个弊端：你将使用更多 FPGA 宝贵的资源，这比实际需要的要多。然而，这个问题可能没有你想象的那么严重。如果综合工具足够智能，它们可能会检测到你的值的可能范围小于你创建的信号，并去除未使用的高位，以节省资源。例如，如果工具对我们的counter寄存器进行优化，我们会在综合报告中看到类似Pruning register counter的警告。通常，收到这样的警告不是问题，但它可能表明你可以重新检查代码，并调整信号的大小。

通常来说，你应该根据信号预期存储的值来选择大小，但要知道，设置信号大小过大比设置过小要更好。当然，你还需要记住，使用给定的位数表示的最大值会根据是否为有符号或无符号值而有所不同。为了进行对比，表 10-2 总结了你可以使用 2 到 8 位表示的无符号和有符号值的范围。

表 10-2: 无符号和有符号数据类型的 N 位大小

| 宽度 | 类型 | 最小整数 | 最小二进制 | 最大整数 | 最大二进制 |
| --- | --- | --- | --- | --- | --- |
| 2 | 无符号 | 0 | 00 | 3 | 11 |
| 2 | 有符号 | –2 | 10 | 1 | 01 |
| 3 | 无符号 | 0 | 000 | 7 | 111 |
| 3 | 有符号 | –4 | 100 | 3 | 011 |
| 4 | 无符号 | 0 | 0000 | 15 | 1111 |
| 4 | 有符号 | –8 | 1000 | 7 | 0111 |
| 5 | 无符号 | 0 | 00000 | 31 | 11111 |
| 5 | 有符号 | –16 | 10000 | 15 | 01111 |
| 6 | 无符号 | 0 | 000000 | 63 | 111111 |
| 6 | 有符号 | –32 | 100000 | 31 | 011111 |
| 7 | 无符号 | 0 | 0000000 | 127 | 1111111 |
| 7 | 有符号 | –64 | 1000000 | 63 | 0111111 |
| 8 | 无符号 | 0 | 00000000 | 255 | 11111111 |
| 8 | 有符号 | –128 | 10000000 | 127 | 01111111 |

从 2 位宽开始，我们可以表示 0 到 3 的无符号数，或者 –2 到 1 的有符号数。在 8 位宽时，我们可以表示 0 到 255 的无符号数，或者 –128 到 127 的有符号数。

绕过大小问题的一种方法是动态地调整信号的大小，而不是将其设置为固定宽度。我们在本书中已经看过一些这样的示例。例如，如果你需要索引到深度为 32 的某个东西，但该深度可能会在未来发生变化，你可以在 Verilog 中编写类似 reg [$clog2(DEPTH)-1:0] index;，而不是 reg [4:0] index;，或者在 VHDL 中编写 signal index : integer range 0 to DEPTH-1;，而不是 signal index : std_logic_vector(4 downto 0);。这里，DEPTH 是一个可以动态更改的参数/泛型。使用它将生成一个精确的比特宽度信号，足以索引从 0 到 DEPTH-1 的所有可能值，不会有多余的空余空间。在这种情况下，你可以将 DEPTH 设置为 32，但如果你的索引需求增长到更大的值（例如 1,024），代码也不会崩溃；你只需要更改 DEPTH。相比之下，如果你随意地说 index 会被固定为 8 位宽（最大值为 255，如你在 表 10-2 中看到的那样），那么如果你的需求超出该范围，代码可能会在未来崩溃。

### VHDL 中类型转换

VHDL 有许多数字数据类型，包括 signed 和 unsigned，其中二进制值被解释为正数或负数的十进制数；integer，可以直接在代码中输入数字；以及 std_logic_vector，其中默认情况下二进制值不会被解释为除二进制值以外的任何内容。由于 VHDL 是强类型语言，在处理数字时，通常需要在这些不同的数据类型之间进行转换。在进行任何数学运算之前，我们先看一些如何使用 numeric_std 包（而不是非官方的 std_logic_arith）实现常见 VHDL 类型转换的示例。

注意

*Verilog 用户无需担心执行这些转换，因为 Verilog 是弱类型语言。VHDL 用户应根据需要参考本节内容。*

#### 从无符号或有符号到整数

这个示例说明了如何将无符号或有符号类型转换为 integer 类型。为了简化起见，我们假设所有信号都是 4 位宽，但这种转换适用于任何位宽：

```
signal in1  : unsigned(3 downto 0);
signal in2  : signed(3 downto 0);
signal out1 : integer;
signal out2 : integer;
out1 <= to_integer(in1);
out2 <= to_integer(in2);
```

对于这些转换，我们只需要调用来自 numeric_std 包的 to_integer() 函数。我们已经知道输入的宽度和符号，因此输出会自动调整大小。无论输入是无符号（如 in1）还是有符号（如 in2），该方法都适用。

#### 从整数到无符号、有符号或 std_logic_vector

这个示例展示了如何将 integer 类型转换为其他类型。再次说明，我们假设信号为 4 位：

```
signal in1  : integer;
signal out1 : unsigned(3 downto 0);
signal out2 : signed(3 downto 0);
signal out3 : std_logic_vector(3 downto 0);
signal out4 : std_logic_vector(3 downto 0);
❶ out1 <= to_unsigned(in1, out1'length);
❷ out2 <= to_signed(in1, out2'length);
-- Positive integers:
❸ out3 <= std_logic_vector(to_unsigned(in1, out3'length));
-- Negative integers:
❹ out4 <= std_logic_vector(to_signed(in1, out4'length));
```

在这里，我们使用 to_unsigned() ❶ 和 to_signed() ❷ 函数，来自 numeric_std，将 integer 转换为 unsigned 或 signed 类型。除了要转换的值外，这些函数还需要输出信号的宽度作为参数。我们通过应用 VHDL 属性 'length 获取宽度，而不是手动输入。这样可以保持代码的灵活性；如果宽度发生变化，转换代码不需要做任何更改。

为了得到 std_logic_vector，我们必须将 integer 转换为 unsigned（如果整数是正数 ❸），或者转为 signed（如果整数是负数 ❹）。然后，一旦我们获得了具有适当宽度的无符号或有符号值，我们就可以使用 std_logic_vector() 进行类型转换。

#### 从 std_logic_vector 到无符号、有符号或整数

最后，这是如何将 std_logic_vector 类型转换为其他数字类型的示例：

```
signal in1  : std_logic_vector(3 downto 0);
signal out1 : unsigned(3 downto 0);
signal out2 : signed(3 downto 0);
signal out3 : integer;
signal out4 : integer;
❶ out1 <= unsigned(in1);
❷ out2 <= signed(in1);
-- Demonstrates the unsigned case:
❸ out3 <= to_integer(unsigned(in1));
-- Demonstrates the signed case:
❹ out4 <= to_integer(signed(in1));
```

要获取 unsigned ❶ 或 signed ❷，我们使用一个简单的类型转换。然而，VHDL 需要知道 std_logic_vector 是无符号的还是有符号的，才能转换为 integer 类型。我们通过使用 unsigned() ❸ 或 signed() ❹ 来执行适当的转换，然后调用 to_integer() 函数进行最终转换。

## 执行数学运算

现在我们将考虑在 FPGA 中如何执行基本的加法、减法、乘法和除法操作，以及如何在 Verilog 和 VHDL 中实现它们。我将建议一些规则，如果遵循这些规则，将帮助你避免在进行二进制数学运算时出现许多常见的陷阱。探索这些概念的最佳方法是通过示例。为此，我们将创建一个大型测试平台，你可以在像 EDA Playground 这样的仿真工具中运行它。该测试平台将执行数十个不同的数学方程，展示二进制数学运算应该如何进行，以及它们如何出错。

一般来说，在处理数字并进行代数运算时，测试平台是一个非常强大的工具。代码中隐藏的数学问题可能以奇怪的方式表现出来。测试平台通过运行大量不同的输入来加大设计的压力，从而查看代码的工作情况。我发现，在我的测试平台中注入数据，尤其是那些对数学运算施加压力的值，包括最小和最大输入，是非常有价值的。这有助于确保设计的稳健性。

在我们进行任何数学运算之前，让我们通过在 VHDL 版本中声明所有必要的输入和输出，以及一些辅助函数，来设置我们的测试平台，名为 Math_Examples。这段设置代码为接下来整个章节中的示例提供了框架。每个示例的代码将放置在设置代码中的 -- snip-- 位置：

Verilog

```
module Math_Examples();
  reg unsigned [3:0] i1_u4, i2_u4, o_u4;
  reg signed   [3:0] i1_s4, i2_s4, o_s4;
  reg unsigned [4:0] o_u5, i2_u5;
  reg signed   [4:0] o_s5, i1_s5, i2_s5;
  reg unsigned [5:0] o_u6;
  reg unsigned [7:0] o_u8, i_u8;
  reg signed   [7:0] o_s8;
  initial begin
     `--snip--`
     $finish();
  end
endmodule
```

VHDL

```
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use std.env.finish;
entity Math_Examples is
end entity Math_Examples;
architecture test of Math_Examples is
  -- Takes input unsigned, returns string for printing
❶ function str(val : in unsigned) return string is
  begin
    return to_string(to_integer(val));
  end function str;
  -- Takes input signed, returns string for printing
❷ function str(val : in signed) return string is
  begin
    return to_string(to_integer(val));
  end function str; -- Takes input real, returns string for printing
❸ function str(val : in real) return string is
  begin
    return to_string(val, "%2.3f");
  end function str;
begin
  process is
    variable i1_u4, i2_u4, o_u4 : unsigned(3 downto 0);
    variable i1_u5, i2_u5, o_u5 : unsigned(4 downto 0);
    variable i1_s4, i2_s4, o_s4 : signed(3 downto 0);
    variable i1_s5, i2_s5, o_s5 : signed(4 downto 0);
    variable i1_u6, i2_u6, o_u6 : unsigned(5 downto 0);
    variable i1_u8, i2_u8, o_u8 : unsigned(7 downto 0);
    variable i1_s8, i2_s8, o_s8 : signed(7 downto 0);
    variable real1, real2, real3 : real;
  begin
    `--snip--`
    wait for 1 ns;
    finish;
    end process;
end test;
```

这个测试平台的骨架设置了一个单独的 initial（在 Verilog 中）或 process（在 VHDL 中）块，该块只运行一次。我们将在本章后面用示例填充这个块。请注意，我们已经使用 reg（在 Verilog 中）和 variable（在 VHDL 中）声明了一些信号。这是我们第一次在 VHDL 中看到 variable 关键字：我们需要它以便在测试平台中编写阻塞赋值语句。有关更多信息，请参见第 214 页的“阻塞与非阻塞赋值”。

本章中的示例使用了一种通用的命名规则，以便快速识别信号的数据类型和宽度，这样你就不必不断回头查看信号定义。前缀 i 表示数学方程的输入，而 o 表示输出，即数学方程的结果。此外，我们有后缀 _uN 和 _sN，其中 u 代表无符号，s 代表有符号，N 代表信号的位宽。例如，o_s4 是一个 4 位宽的有符号输出。建立像这样的命名方案，可以帮助你更容易地记住数据类型和宽度，尤其是当一个文件中有很多值时，这对你的代码非常有帮助。

请注意，在 VHDL 中，我们声明了一个自定义函数 str()，用于将我们方程的输出转换为字符串以便打印。这将大大减少我们在后续示例中输入的工作量。我们实际上根据数据类型定义了三种不同的函数，因为 VHDL 是强类型语言，我们需要定义所有支持的函数输入，以便编译器知道使用哪个版本。第一个定义 ❶ 转换一个 unsigned 值，第二个 ❷ 转换一个 signed 值，第三个 ❸ 转换一个 real 值。这是函数 *重载* 的一个例子，重载是一个编程技巧，允许一个函数有多个实现。重载是一个相对高级的 VHDL 概念，但它非常有用。你甚至可以重载普通的 VHDL 运算符，如 + 和 –，使用任何你需要的实现，尽管我并不建议这样做。

现在我们已经设置好了测试平台，准备开始探索数学运算。

### 加法

加法二进制数据的方式与小学时教你加法的方式相同：逐位相加，从右向左。例如，以下是如何加法两个二进制数0010和1000：

```
0010
+ 1000
------
 01010
```

要得出结果，你只需要逐位相加，从最低有效位开始，将该列的数字相加。如果在某一列中得到 1 + 1 = 10，那么你在该列的底部写下 0，并将 1 进位到左边的下一位。

请注意，将两个 4 位数相加后的结果是 5 位宽。这是 FPGA 数学的第一个规则：

**规则 #1** 在加法时，结果的位数应至少比最大输入大 1 位。

当加法的最高有效位需要进位操作时，额外的位是必要的。如果没有这个额外的位，我们就会截断结果，可能会得到错误的答案。在第一个例子中，丢弃最高有效位并不会产生问题，但考虑这个例子，拥有额外的位是至关重要的：

```
 1001
+ 1011
------
 10100
```

在这里，结果的最高有效位是 1。如果我们假设输出宽度与输入宽度相同，那么我们就会丢掉这个位，得到错误的答案。我们的结果将是 0100 而不是 10100。

也许你注意到，我还没有明确说明这些二进制数字代表什么，也没有说明它们是正数还是负数。例如，1001 是无符号并等于 9，还是有符号并等于 9 的二进制补码，即 –7（反转位得到 0110，然后加 1 得到 0111）？我之所以没有明确说明这一点，是因为二进制数据的表示方式最终不会影响数学运算的执行方式，只要输入和输出的位数合适。无论 1001 代表 +9 还是 –7，加法操作都会以相同的方式进行。当然，我们关心结果是正数还是负数，但加法的实现不会因为数据类型是有符号还是无符号而有所不同。让我们重新回到第一个例子，考虑一下当我们为其分配不同的有符号和无符号组合时会发生什么。以下是这个例子：

```
 0010
+ 1000
------
 01010
```

如果两个加法输入都声明为无符号类型，那么我们有 2 + 8 = 10。相当简单。如果两个加法输入都声明为有符号类型，那么第一个输入仍然是 2，但第二个输入是 –8。 （反转位得到 0111，加 1 得到 1000，然后应用负号得到 –8。）所以现在我们有 2 + –8，结果应该是 –6，但结果 01010 仍然是 10。这里出了点问题！

问题是我们没有对输入进行符号扩展。*符号扩展*是将二进制数的位数增加，同时保持该数的符号和值的操作。输入为有符号时，需要进行此操作。如果没有，它会导致不正确的答案，就像你刚才看到的那样。要对有符号值执行符号扩展，只需复制最重要的位。例如，1000 变成 11000，而 0010 变成 00010。让我们再次尝试这个运算，这次先对输入应用符号扩展：

```
00010
+ 11000
-------
  11010
```

我们的输入仍然是 2 和 –8。 （对于后者，反转 11000 的位得到 00111，加 1 得到 01000，然后应用负号得到 –8。）答案 11010 是 –6 的有符号等效值，这正是我们想要的。符号扩展是确保我们得到预期答案的关键步骤。

符号扩展对于无符号值也非常有用。事实上，由于 VHDL 是强类型的，所有参与加法运算的输入和输出必须具有完全相同的宽度。例如，你不能将两个 4 位输入相加得到一个 5 位输出；所有的信号都必须是 5 位。这意味着我们应该重新审视规则 #1，并进行一个小的修改：

**规则 #1（修改 #1）** 在加法时，结果应至少比最大输入大 1 位，*在符号扩展之前*。一旦符号扩展应用，输入和输出的宽度应完全匹配。

对于无符号值，符号扩展意味着将 0 作为新的最高有效位。例如，无符号的 1000 变成 01000。对于使用 Verilog 的用户来说，好消息是，当你加法运算时，代码会自动执行符号扩展。然而，如果你使用的是 VHDL，你将需要通过 resize() 函数手动进行符号扩展，正如接下来的示例中所展示的那样。这两种方法各有优缺点。如果你知道自己在做什么，Verilog 更容易，因为你需要担心的东西较少，但也更容易出错（例如，试图将数据存储在一个过小的信号中）。VHDL 的额外步骤可能让初学者感到困惑，而且当规则没有遵循时，它会生成难以理解的错误。另一方面，VHDL 确保每一步都匹配宽度和类型，因此最终出错的可能性较小。

让我们通过一些代码示例来总结我们所学的内容。将以下代码添加到你的测试平台中，在你之前看到过的 -- snip-- 位置：

Verilog

```
 // Unsigned + Unsigned = Unsigned (Rule #1 violation)
   i1_u4 = 4'b1001; // dec 9
   i2_u4 = 4'b1011; // dec 11
   o_u4  = i1_u4 + i2_u4;
   $display("Ex01: %2d + %2d = %3d", i1_u4, i2_u4, o_u4);
   // Signed + Signed = Signed (Rule #1 violation)
   i1_s4 = 4'b1001; // dec -7
   i2_s4 = 4'b1011; // dec -5
   o_s4= i1_s4 + i2_s4;
   $display("Ex02: %2d + %2d = %3d", i1_s4, i2_s4, o_s4);
   // Unsigned + Unsigned = Unsigned (Rule #1 fix)
   i1_u4 = 4'b1001; // dec 9
   i2_u4 = 4'b1011; // dec 11
   o_u5  = i1_u4 + i2_u4;
   $display("Ex03: %2d + %2d = %3d", i1_u4, i2_u4, o_u5);
   // Signed + Signed = Signed (Rule #1 fix)
   i1_s4 = 4'b1001; // dec -7
   i2_s4 = 4'b1011; // dec -5
   o_s5  = i1_s4 + i2_s4;
   $display("Ex04: %2d + %2d = %3d", i1_s4, i2_s4, o_s5);
```

VHDL

```
 -- Unsigned + Unsigned = Unsigned (Rule #1 violation)
   i1_u4 := "1001"; -- dec 9
   i2_u4 := "1011"; -- dec 11
   o_u4  := i1_u4 + i2_u4;
   report "Ex01: " & str(i1_u4) & " + " & str(i2_u4) & " = " & str(o_u4);
   -- Signed + Signed = Signed (Rule #1 violation)
   i1_s4 := "1001"; -- dec -7
   i2_s4 := "1011"; -- dec -5
   o_s4  := i1_s4 + i2_s4;
   report "Ex02: " & str(i1_s4) & " + " & str(i2_s4) & " = " & str(o_s4);
   -- Unsigned + Unsigned = Unsigned (Rule #1 fix)
   i1_u4 := "1001"; -- dec 9
   i2_u4 := "1011"; -- dec 11
   ❶ i1_u5 := resize(i1_u4, i1_u5'length);
   i2_u5 := resize(i2_u4, i2_u5'length);
   o_u5  := i1_u5 + i2_u5;
   report "Ex03: " & str(i1_u5) & " + " & str(i2_u5) & " = " & str(o_u5);
   -- Signed + Signed = Signed (Rule #1 Fix)
   i1_s4 := "1001"; -- dec -7
   i2_s4 := "1011"; -- dec -5
   i1_s5 := resize(i1_s4, i1_s5'length);
   i2_s5 := resize(i2_s4, i2_s5'length);
   o_s5  := i1_s5 + i2_s5;
   report "Ex04: " & str(i1_s5) & " + " & str(i2_s5) & " = " & str(o_s5);
```

以下是输出结果：

Verilog

```
# Ex01:  9 + 11 =   4
# Ex02: -7 + -5 =   4
# Ex03:  9 + 11 =  20
# Ex04: -7 + -5 = -12
```

VHDL

```
# ** Note: Ex01: 9 + 11 = 4
#    Time: 0 ns  Iteration: 0   Instance: /math_examples
# ** Note: Ex02: -7 + -5 = 4
#    Time: 0 ns  Iteration: 0   Instance: /math_examples
# ** Note: Ex03: 9 + 11 = 20
#    Time: 0 ns  Iteration: 0   Instance: /math_examples
# ** Note: Ex04: -7 + -5 = -12
#    Time: 0 ns  Iteration: 0   Instance: /math_examples
```

首先，我们有两个情况（Ex01 和 Ex02），这两个例子没有遵循规则 #1。我们使用 4 位输入，并将结果存储在 4 位输出中，而且没有执行符号扩展。在这两个例子中，我们得到了错误的结果。在 Ex01 中，我们加了两个无符号数，9 和 11，但得到了 4 作为结果。问题在于我们丢失了最高有效位，而这个位的值应该是 16。（事实上，4 + 16 = 20，这才是我们应该得到的答案。）在 Ex02 中，我们加了两个表示负值的有符号数，结果依然是错误的。

解决方法是将结果存储在一个 5 位的输出中，我们在Ex03和Ex04中都这样做了。我们已经满足了规则#1，所以数学运算是正确的。注意，在 Verilog 版本中，符号扩展是自动进行的：我们可以简单地将 4 位输入赋值给 5 位输出，例如通过写o_u5 = i1_u4 + i2_u4;。然而，在 VHDL 中，我们必须显式地匹配输入和输出的位宽，同时保留每个输入的符号和值。为此，我们调用resize()函数❶。我们使用 VHDL 的 tick 属性'length来引用输出信号的长度，正如我们在进行类型转换时所做的那样。再说一次，这比通过写类似resize(i1_u4, 5)这样的硬编码宽度更灵活。

进行成功的加法运算的另一个技巧是不要混合带符号和不带符号的值。输入和输出应该是相同类型的；否则，你可能会得到错误的结果。这引出了我们的第二条 FPGA 数学规则：

**规则#2** 输入和输出类型要匹配。

对于 VHDL 来说，遵循规则#2 很容易，因为如果你尝试进行一个输入为带符号、另一个输入为不带符号的数学运算，它会抛出错误。例如，假设你在测试平台中写下以下代码，尝试将一个 4 位的不带符号值（i1_u4）与一个 4 位的带符号值（i2_s4）相加：

```
o_u4 := i1_u4 + i2_s4;
```

你会看到一个错误消息，指出工具无法理解给定输入下的+运算符：

```
** Error: testbench.vhd(49): (vcom-1581) No feasible entries for infix
operator '+'.
```

Verilog 的容错性更强。它会很高兴地让你执行该数学运算，而且不会告诉你它实际上是把带符号输入当作不带符号处理的。这很可能导致错误的结果，因此在 Verilog 中务必小心始终匹配数据类型。

### 减法

减法与加法没什么不同。毕竟，减法只是将其中一个输入变为负数的加法运算。从这个角度看，我们一直在做减法；2 + –8 就等同于 2 – 8。同样，你可以把类似 5 – 3 的运算看作 5 + –3，并以加法运算的方式进行处理。

但是，在进行两个数的减法时，有一件事需要特别注意：虽然你*可以*使用无符号输入和输出进行减法，但我不推荐这样做。如果结果应该是负数会怎样呢？例如，3 – 5 = -2，但如果你尝试将 -2 存入无符号数据类型中，你将无法获得正确的结果。这引出了我们的下一个规则：

**规则 #3** 在进行减法时，使用有符号的输入和输出。

即使你认为减法的结果不会产生负数，你也应该使用有符号数据类型，以确保安全。

因为减法实际上就是负数加法，所以减法存在相同的风险，即如果输出的大小不合适，可能会导致结果被截断。再次强调，最好在执行数学运算之前将输出大小增加 1 位，并对输入进行符号扩展。这给我们带来了进一步修改的规则 #1：

**规则 #1（修改版 #2）** 在加法*或减法*时，结果应比最大输入大至少 1 位，符号扩展前如此。符号扩展应用后，输入和输出的位宽应该完全匹配。

通过这两条规则，我们扩展了 Math_Examples 测试平台，来观察 Verilog 和 VHDL 中的一些减法操作：

Verilog

```
 // Unsigned - Unsigned = Unsigned (bad)
    i1_u4 = 4'b1001; // dec 9
    i2_u4 = 4'b1011; // dec 11
    o_u5  = i1_u4 - i2_u4;
    $display("Ex05: %2d - %2d = %3d", i1_u4, i2_u4, o_u5);
    // Signed - Signed = Signed (fix)
    i1_u4 = 4'b1001; // dec 9
    i2_u4 = 4'b1011; // dec 11
 ❶ i1_s5 = i1_u4;
    i2_s5 = i2_u4;
    o_s5  = i1_s5 - i2_s5;
    $display("Ex06: %2d - %2d = %3d", i1_s5, i2_s5, o_s5);
```

VHDL

```
 -- Unsigned - Unsigned = Unsigned (bad)
    i1_u4 := "1001"; -- dec 9
    i2_u4 := "1011"; -- dec 11
    i1_u5 := resize(i1_u4, i1_u5'length);
    i2_u5 := resize(i2_u4, i2_u5'length);
    o_u5:= i1_u5 - i2_u5;
    report "Ex05: " & str(i1_u5) & " - " & str(i2_u5) & " = " & str(o_u5);
    -- Signed - Signed = Signed (fix)
    i1_u4 := "1001"; -- dec 9
    i2_u4 := "1011"; -- dec 11
 ❷ i1_s5 := signed(resize(i1_u4, i1_s5'length));
    i2_s5 := signed(resize(i2_u4, i2_s5'length));
    o_s5:= i1_s5 - i2_s5;
    report "Ex06: " & str(i1_s5) & " - " & str(i2_s5) & " = " & str(o_s5);
```

这是输出：

Verilog

```
# Ex05: 9 - 11 = 30
# Ex06: 9 - 11 = -2
```

VHDL

```
# ** Note: Ex05: 9 - 11 = 30
#    Time: 0 nsIteration: 0  Instance: /math_examples
# ** Note: Ex06: 9 - 11 = -2
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
```

在 Ex05 中，我们尝试计算 9 – 11，但结果却是 30，显然是错误的答案。问题在于我们使用了无符号类型进行减法，这违反了规则 #3。我们在 Ex06 中通过将输入值从无符号转换为有符号数据类型来修复这一问题。在此过程中，我们还进行了符号扩展，将 4 位输入转换为 5 位输入。在 Verilog 代码中，我们通过将 4 位无符号信号直接赋值给 5 位有符号信号来处理转换 ❶。Verilog 会自动处理细节。而 VHDL 需要我们多做一些工作。我们首先调整输入大小，这将进行符号扩展，但调整大小后的结果仍然是无符号类型，因此我们需要显式地使用 signed() 将其转换为有符号数据类型 ❷。这样做是安全的，因为我们已经调整了信号大小，所以最高位将是 0。因此，转换为有符号类型后的值不会改变。

### 乘法

乘法运算与加法运算类似；毕竟，乘法运算只是重复加法的一个过程（4 × 3 = 4 + 4 + 4）。在将两个输入相乘时，首先要考虑的是如何正确设置输出的位宽。这引出了我们的下一个规则：

**规则 #4** 在乘法运算时，输出位宽必须至少等于输入位宽的总和（在符号扩展之前）。

这个规则对有符号数和无符号数都适用。例如，假设我们正在尝试乘法运算无符号输入 111 和 11（等于 7 × 3）。根据规则 #4，输出应该是 3 + 2 = 5 位宽。你可以自己试一下这个乘法运算，使用你在学校学过的多位数相乘的技巧——逐位相乘并将结果相加：

```
 111
×   11
------
   111
+ 1110
------
 10101
```

输出 10101（等于 21），确实是 5 位宽，符合预期。但如果我们将输入和输出视为有符号数而非无符号数，这个乘法运算会怎样呢？在这种情况下，相当于十进制的 –1 × –1，结果应该是 +1，但二进制的有符号 10101 等于十进制的 –11。那么这里到底出了什么问题呢？

问题在于，我们在进行乘法运算之前，没有将输入的位宽扩展到与输出位宽（5 位）相匹配。如果我们这样做，输入会变成 11111，乘法运算结果如下所示：

```
 11111
 ×    11111
-----------
      11111
     111110
    1111100
   11111000
+ 111110000
-----------
000000001
```

现在我们得到 00000001，或者实际上在将结果截断为 5 位宽后，得到 00001，即十进制的 +1。符号扩展给出了我们预期的结果。然而，与加法和减法不同，在使用 Verilog 或 VHDL 进行乘法运算时，你实际上不需要手动进行符号扩展。工具会自动处理这一过程；你只需要正确设置输出信号的位宽。

VHDL 也能帮助处理这个问题：如果你违反规则 #4，未正确设置乘法运算的输出大小，VHDL 根本无法编译代码。而在 Verilog 中，你需要更加小心。如果输出的位宽不正确，它不会发出警告，可能会得到意外的结果。让我们在 Math_Examples 测试平台中添加一些例子：

Verilog

```
 // Unsigned * Unsigned = Unsigned (Rule #4 violation)
   i1_u4 = 4'b1001; // dec 9
   i2_u4 = 4'b1011; // dec 11
   o_u4  = i1_u4 * i2_u4;
   $display("Ex07: %2d * %2d = %3d", i1_u4, i2_u4, o_u4);
   // Signed * Signed = Signed (Rule #4 violation)
   i1_s4 = 4'b1000; // dec -8
   i2_s4 = 4'b0111; // dec 7
   o_s4  = i1_s4 * i2_s4;
   $display("Ex08: %2d * %2d = %3d", i1_s4, i2_s4, o_s4);
```

VHDL

```
 -- Unsigned * Unsigned = Unsigned
   i1_u4 := "1001"; -- dec 9
   i2_u4 := "1011"; -- dec 11
   o_u4  := i1_u4 * i2_u4;
   report "Ex07: " & str(i1_u4) & " * " & str(i2_u4) & " = " & str(o_u4);
   -- Signed * Signed = Signed
   i1_s4 := "1000"; -- dec -8
   i2_s4 := "0111"; -- dec 7 o_s4  := i1_s4 * i2_s4;
   report "Ex08: " & str(i1_s4) & " * " & str(i2_s4) & " = " & str(o_s4);
```

这是输出结果：

Verilog

```
# Ex07:  9 * 11 =  3
# Ex08: -8 *  7 = -8
```

VHDL

```
** Error (suppressible): testbench.vhd(89): (vcom-1272) Length of expected
is 4; length of actual is 8.
```

Verilog 允许我们执行数学运算，尽管我们违反了规则 #4，即将 4 位数与 4 位数相乘，并将结果存储在一个 4 位输出中。这对于无符号（Ex07）和有符号（Ex08）输入值都会产生错误结果。另一方面，VHDL 甚至无法构建此代码；我们会得到一个详细的错误信息，告诉我们工具正在尝试将一个 8 位宽的结果赋值给一个 4 位宽的变量，这是不允许的。让我们在测试平台中添加几个例子来修复这些问题：

Verilog

```
 // Unsigned * Unsigned = Unsigned (Rule #4 fix)
   i1_u4 = 4'b1001; // dec 9
   i2_u4 = 4'b1011; // dec 11
   o_u8  = i1_u4 * i2_u4;
   $display("Ex09: %2d * %2d = %3d", i1_u4, i2_u4, o_u8);
   // Signed * Signed = Signed (Rule #4 fix)
   i1_s4 = 4'b1000; // dec -8
   i2_s4 = 4'b0111; // dec 7
   o_s8  = i1_s4 * i2_s4;
   $display("Ex10: %2d * %2d = %3d", i1_s4, i2_s4, o_s8);
```

VHDL

```
 -- Unsigned * Unsigned = Unsigned
   i1_u4 := "1001"; -- dec 9
   i2_u4 := "1011"; -- dec 11
   o_u8  := i1_u4 * i2_u4;
   report "Ex09: " & str(i1_u4) & " * " & str(i2_u4) & " = " & str(o_u8);
   -- Signed * Signed = Signed
   i1_s4 := "1000"; -- dec -8
   i2_s4 := "0111"; -- dec 7
   o_s8  := i1_s4 * i2_s4;
   report "Ex10: " & str(i1_s4) & " * " & str(i2_s4) & " = " & str(o_s8);
```

这是输出：

Verilog

```
# Ex09:  9 * 11 =  99
# Ex10: -8 *  7 = -56
```

VHDL

```
# ** Note: Ex09: 9 * 11 = 99
#    Time: 0 ns  Iteration: 0   Instance: /math_examples
# ** Note: Ex10: -8 * 7 = -56
#    Time: 0 ns  Iteration: 0   Instance: /math_examples
```

在 Ex09 中，我们通过将两个无符号 4 位值相乘的结果存储到一个 8 位信号中，解决了 Ex07 中的问题。类似地，Ex10 修复了 Ex08 中有符号值的问题。请注意，我们在 Verilog 或 VHDL 中都不需要扩展输入的符号。工具会自动处理这一点。

### 乘以 2 的幂

在乘以 2 的幂（例如 2、4、8、16、32 等）时，我们可以使用一个技巧。与其实例化一堆乘法逻辑，我们可以简单地实例化一个移位寄存器并执行左移操作。左移 *N* 位等同于乘以 2*^N*。例如，0011（十进制 3）左移 2 位，得到 1100（十进制 12）。这等同于计算 3 × 4，或 3 × 2²。这个技巧适用于有符号和无符号数。让我们在测试平台中试试：

Verilog

```
 i_u8 = 3;
   o_u8 = i_u8 << 1;
   $display("Ex11: %d * 2 = %d",  i_u8, o_u8);
   o_u8 = i_u8 << 2;
   $display("Ex12: %d * 4 = %d",  i_u8, o_u8);
   o_u8 = i_u8 << 4;
   $display("Ex13: %d * 16 = %d", i_u8, o_u8);
```

VHDL

```
 i1_u8 := to_unsigned(3, i1_u8'length);
   o_u8 := shift_left(i1_u8, 1);
   report "Ex11: " & str(i1_u8) & " * 2 = "  & str(o_u8);
   o_u8 := shift_left(i1_u8, 2);
   report "Ex12: " & str(i1_u8) & " * 4 = "  & str(o_u8);
   o_u8 := shift_left(i1_u8, 4);
   report "Ex13: " & str(i1_u8) & " * 16 = " & str(o_u8);
```

这是输出：

Verilog

```
# Ex11:  3 * 2 =  6
# Ex12:  3 * 4 = 12
# Ex13:  3 * 16 = 48
```

VHDL

```
# ** Note: Ex11: 3 * 2 = 6
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
# ** Note: Ex12: 3 * 4 = 12
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
# ** Note: Ex13: 3 * 16 = 48
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
```

我们从十进制值 3 开始，左移 1、2 和 4 位，分别将其乘以 2、4 和 16。在 Verilog 中，我们使用 << 运算符进行移位，而在 VHDL 中，我们使用函数 shift_left()。这两个方法的参数都是要移位的位数。

左移是节省 FPGA 资源的一个简单快捷的技巧，但你不一定需要显式地写出来。如果你硬编码了一个 2 的幂乘法，综合工具可能会足够聪明，自动识别出左移操作会占用更少的资源。

### Division

不幸的是，除法不像加法、减法或乘法那样简单。除法会带来各种复杂问题，比如余数和分数。一般来说，如果可以的话，最好避免在 FPGA 内部进行除法。除法是一个资源密集型的操作，尤其是在你需要让这个操作在高时钟频率下运行时。

我曾经参与一个项目，需要在现场为 FPGA 添加一个除法操作。那个 FPGA 是一个非常老旧的型号，根本无法在现有资源下完成这项操作。为了支持除法操作，我们最终不得不升级到同一家族的高资源 FPGA，这使得硬件成本增加了超过 100 万美元。我一直把那一次额外的操作当作百万美元除法！

如果你*必须*进行除法操作，有几种方法可以使这个操作更节省资源。这些方法包括限制自己只进行 2 的幂除法，使用预先计算好的答案表，或者将操作分解到多个时钟周期中进行。

#### 使用 2 的幂

我对减少在 FPGA 内部进行除法操作开销的最佳建议是将除数设为 2 的幂。类似于如何使用左移操作高效地进行 2 的幂乘法，2 的幂除法也可以通过右移操作高效地完成。右移*N*位相当于除以 2*^N*。让我们来看看几个例子：

Verilog

```
 i_u8 = 128;
   o_u8 = i_u8 >> 1;
   $display("Ex14: %d / 2 = %d",  i_u8, o_u8);
   o_u8 = i_u8 >> 2;
   $display("Ex15: %d / 4 = %d",  i_u8, o_u8);
   o_u8 = i_u8 >> 4;
   $display("Ex16: %d / 16 = %d", i_u8, o_u8);
```

VHDL

```
 i1_u8 := to_unsigned(128, i1_u8'length);
   o_u8 := shift_right(i1_u8, 1);
   report "Ex14: " & str(i1_u8) & " / 2 = "  & str(o_u8);
   o_u8 := shift_right(i1_u8, 2);
   report "Ex15: " & str(i1_u8) & " / 4 = "  & str(o_u8);
   o_u8 := shift_right(i1_u8, 4);
   report "Ex16: " & str(i1_u8) & " / 16 = " & str(o_u8);
```

下面是输出结果：

Verilog

```
# Ex14: 128 / 2 = 64
# Ex15: 128 / 4 = 32
# Ex16: 128 / 16 =  8
```

VHDL

```
# ** Note: Ex14: 128 / 2 = 64
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
# ** Note: Ex15: 128 / 4 = 32
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
# ** Note: Ex16: 128 / 16 = 8
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
```

Ex14执行了右移 1 位，在 Verilog 中使用的是 >> 运算符，而在 VHDL 中使用的是 shift_right() 函数。这完成了一个除以 2 的操作。要除以 4，可以右移 2 个位位置，如 Ex15 所示。同样，右移 4 位相当于除以 16，如 Ex16 所示。

当我们没有一个能被 2 的幂整除的数字作为除数时会发生什么呢？在这种情况下，右移操作有效地完成了一个向下取整到最接近整数的除法。接下来的几个例子将说明这是如何工作的：

Verilog

```
 i_u8 = 15;
   o_u8 = i_u8 >> 1;
   $display("Ex17: %d / 2 = %d", i_u8, o_u8);
   o_u8 = i_u8 >> 2;
   $display("Ex18: %d / 4 = %d", i_u8, o_u8);
   o_u8 = i_u8 >> 3;
   $display("Ex19: %d / 8 = %d", i_u8, o_u8);
```

VHDL

```
 i1_u8 := to_unsigned(15, i1_u8'length);
   o_u8 := shift_right(i1_u8, 1);
   report "Ex17: " & str(i1_u8) & " / 2 = " & str(o_u8);
   o_u8 := shift_right(i1_u8, 2);
   report "Ex18: " & str(i1_u8) & " / 4 = " & str(o_u8);
   o_u8 := shift_right(i1_u8, 3);
   report "Ex19: " & str(i1_u8) & " / 8 = " & str(o_u8);
```

这是输出结果：

Verilog

```
# Ex17: 15 / 2 =  7
# Ex18: 15 / 4 =  3
# Ex19: 15 / 8 =  1
```

VHDL

```
# ** Note: Ex17: 15 / 2 = 7
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
# ** Note: Ex18: 15 / 4 = 3
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
# ** Note: Ex19: 15 / 8 = 1
```

在 Ex17 中，我们尝试执行 15 / 2\。这应该得到 7.5，但我们无法表示 .5 部分，因此最终会向下取整为 7。将其视为右移操作，我们从 00001111 变为 00000111。在 Ex18 中，我们尝试计算 15 / 4，这应该得到 3.75，但我们会去掉小数部分，只得到 3\。最后，在 Ex19 中，我们得到 15 / 8 = 1\。如果你没有预料到这种情况，这种舍入可能会引发问题，因此请注意在执行右移操作时可能会发生这种情况。

#### 使用预计算表

另一种除法操作的选项是为所有可能的输入组合预先计算结果。例如，如果我们尝试将数字 1 到 7 中的任何数字除以 1 到 7 中的任何其他数字，我们可以在 FPGA 中创建类似表 10-3 的内容。

表 10-3： 全范围除法输入的预计算表

|  | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | 1.00 | 0.50 | 0.33 | 0.25 | 0.20 | 0.17 | 0.14 |
| 2 | 2.00 | 1.00 | 0.67 | 0.50 | 0.40 | 0.33 | 0.29 |
| 3 | 3.00 | 1.50 | 1.00 | 0.75 | 0.60 | 0.50 | 0.43 |
| 4 | 4.00 | 2.00 | 1.33 | 1.00 | 0.80 | 0.67 | 0.57 |
| 5 | 5.00 | 2.50 | 1.67 | 1.25 | 1.00 | 0.83 | 0.71 |
| 6 | 6.00 | 3.00 | 2.00 | 1.50 | 1.20 | 1.00 | 0.86 |
| 7 | 7.00 | 3.50 | 2.33 | 1.75 | 1.40 | 1.17 | 1.00 |

在这个示例中，假设每一行代表一个可能的被除数，每一列代表一个可能的除数。给定的被除数和除数交汇处的值就是相应的商。例如，要找到分数 5/6 的十进制值，可以去第 5 行，再移动到第 6 列，得到值 0.83。为了在 Verilog 或 VHDL 中实现这一点，我们可以将这个二维表格存储在一个二维数组中。（你可以在第八章的状态机项目中看到二维数组是如何工作的。）行输入值提供了一个索引，列输入值提供了第二个索引，商则是这两个索引处的值。我们实际上并没有进行任何数学运算；我们只是索引到正确的结果，这个结果已经预先计算并存储在内存中。

注意

*如果你在想如何在 FPGA 中表示像 0.50 和 0.33 这样的十进制值，问得好！我们很快会探讨这个话题。*

随着可能输入范围的增大，当然，我们将需要一个更大更大的表来存储可能的输出。最终，一个单独的表可能会占用整个块 RAM，通常块 RAM 的大小为 16Kb。使用块 RAM 中的预计算表可以确保单次除法计算只需要一个时钟周期，因为我们只需一个时钟周期来读取内存（就像我们在第六章中讨论 RAM 时所学的那样）。然而，我们不能在同一个时钟周期内从多个位置读取内存，因此如果我们需要在完全相同的时钟周期内同时进行两次除法运算，我们就需要在另一个块 RAM 中实例化预计算表的第二个副本。

块 RAM 通常是宝贵的资源，因此将其用于并行除法运算并不具有良好的可扩展性。如果设计允许我们在连续的时钟周期中运行不同的除法操作，而不是同时进行，我们可以改为使用一个表格并进行时间共享。对单一资源进行时间共享需要对该资源进行仲裁，正如我们在第七章中讨论的那样。我们需要创建一个仲裁器，只允许一个模块在每次时钟周期访问该块 RAM 表。

到目前为止讨论的解决方案假设我们只有一个时钟周期来获得除法运算的结果。然而，如果我们可以等待多个时钟周期来得到除法结果，那么我们就可以使用另一个选项。

#### 使用多个时钟周期

缓解合成工具在执行除法时的负担的另一种方法是创建一个算法，该算法通过使用更简单的数学运算（如加法和减法）在不止一个时钟周期内执行除法。除法的本质是计算一个数能在另一个数中被包含多少次。例如，你可以通过将除数反复加到自身，直到超出被除数的值，同时计数你执行了多少次循环。然后，减去被除数以得到余数。

还有各种其他方法可以通过更简单的数学运算执行除法。（具体实现超出了本书的范围；如果你想了解更多，可以在网上搜索*FPGA 上的除法算法*。）但当然，这些方法只有在你能够等待多个时钟周期得到结果的情况下才有效。在这个背景下，使用多个时钟周期得到结果与我们在第七章中讨论的流水线示例有所不同，在那个例子中，我们将一个复杂的数学运算分解到多个时钟周期以满足时序要求。在那个例子中，我们仍然能够在每个时钟周期获得一个结果，但输出相对于输入延迟了几个时钟周期。

在这种情况下，我们不知道除法算法需要多少时钟周期才能提供结果，因此我们不能依赖每个时钟周期的结果。最终，这是一个在更低资源利用和更多时钟周期之间进行权衡的问题。如果你真的需要在每个时钟周期都获得除法操作的结果，你将不得不使用之前讨论过的除法技术之一。

## FPGA 如何实现数学运算

到目前为止，我们讨论的所有操作只是看到了数学如何运作，并没有真正考虑这些操作是如何在 FPGA 内部实现的。根据执行的具体操作，可能会涉及不同的 FPGA 组件。如果你参加了入门级的数字电子学课程，你可能会学习到*半加法器*和*全加法器*，这些是结合了各种逻辑门（如 XOR 和 AND）来执行加法操作的数字电路。这是一个很有趣的主题，但最终你可能会感到沮丧，因为你不需要知道这些电路是如何工作的，就能在现代 FPGA 代码中进行数学运算。如果你只是在做加法，你永远不需要通过手动编写所有必要的逻辑操作来实例化一个全加法器组件。相反，你只需在 Verilog 或 VHDL 中使用+运算符，就像在任何其他编程语言中一样，并且相信综合工具会处理实现过程。

工具可能会将加法和减法操作放入基本的 LUT 中。对于乘法，工具会使用触发器来实现左移方法，或者使用 LUT 或 DSP 块（如果可用）进行更复杂的计算。如第九章所讨论，DSP 块在加速大规模乘法-累加运算时非常有用，而且不会占用大量 LUT 逻辑。最后，除法操作需要寄存器来实现右移方法，或者使用预计算表的块 RAM，或者是 LUT。

然而，数学不仅仅是加法、减法、乘法和除法。看看你的计算器，考虑一下我们没有讨论的所有其他操作：正弦、余弦、平方根等等。在 FPGA 上运行这些操作当然是可能的，但它会变得复杂，并超出了本书的范围。如果你有兴趣了解更多，实际上有专门的算法可以实例化来执行这些操作，例如坐标旋转数字计算机（CORDIC）。你可以在 GitHub 上搜索*FPGA CORDIC*，会找到许多例子。

除了在 FPGA 上实际实现更复杂的数学运算外，如果有选择，可能值得将输入发送到专用处理器进行计算，然后将结果返回到 FPGA 逻辑中。我们将在下一节讨论浮点运算与定点运算，但处理器执行浮点运算的能力远超 FPGA。这个处理器可以是外部的专用组件，也可以是 FPGA 内部的。如果是内部的，它被称为硬核处理器或软核处理器，具体取决于它是否是专用硅片。

许多现代 FPGA 都具有内部硬件 ARM 核心。这种将 FPGA 逻辑与专用处理器结合的组件通常被称为*系统级芯片（SoC）*。你可以将来自 FPGA 查找表（LUT）/触发器逻辑的操作发送到 ARM 核心进行处理，ARM 核心会执行所需的操作并返回结果。这种解决方案更多是处理数据而不是进行数学运算，因为你可能需要为每个输入和输出设置 FIFO。使用单独的处理器是一个高级话题，但在高端应用中它非常有价值。

## 与小数一起工作

到目前为止，我们一直在处理整数，但在许多应用中，你需要让 FPGA 处理带有小数部分的数字。在本节中，我们将探讨如何使用非整数进行数学运算。首先，我们需要考虑如何使用二进制数字表示分数数字。有两种可能的系统可以选择：浮点数和定点数。

绝大多数电子设备中的数学运算使用*浮点*运算，因为大多数 CPU 设计用来处理浮点数。浮点的关键在于*基数*（小数点）是“浮动”的，取决于需要多少精度。我们不会详细讨论这如何运作，但关键是，使用 32 位可以表示一个巨大的数值范围，且具有不同的精度；你可以用高精度表示非常小的数字，或者用较低精度表示非常大的数字。另一方面，*定点*运算有一个固定的基数，这意味着有固定数量的整数位和固定数量的小数位。

FPGA*可以*执行浮点运算，但通常比定点运算需要更多的资源。因此，大多数 FPGA 数学运算使用定点运算，因此本章剩余部分将聚焦于定点运算。

为了说明定点表示法是如何工作的，我们来看一个例子。假设我们在 FPGA 中为表示一个数字分配了 3 位。到目前为止，我们一直假设每个比特的变化都代表一个整数值。例如，从 001 到 010，表示从 1 到 2。但我们只是随便决定每个比特代表一个整数值。我们也可以决定每个位的值是别的东西，比如 0.5。这样，001 就等于 0.5，010 就是 1.0，011 就是 1.5，以此类推。现在我们有了一个定点系统，其中最右边的比特表示数字的小数部分，另外两位则表示整数部分。我们还可以以其他方式解读这些比特，从而获得不同的定点表示。表 10-4 显示了 3 位无符号数的最常见小数表示方法。

表 10-4： 3 位无符号定点表示的可能性

| 比特 | U3.0 | U2.1 | U1.2 | U0.3 |
| --- | --- | --- | --- | --- |
| 000 | 0 | 0 | 0 | 0 |
| 001 | 1 | 0.5 | 0.25 | 0.125 |
| 010 | 2 | 1.0 | 0.50 | 0.250 |
| 011 | 3 | 1.5 | 0.75 | 0.375 |
| 100 | 4 | 2.0 | 1.00 | 0.500 |
| 101 | 5 | 2.5 | 1.25 | 0.625 |
| 110 | 6 | 3.0 | 1.50 | 0.750 |
| 111 | 7 | 3.5 | 1.75 | 0.875 |

表 10-4 中的标题使用了修改版的 *Q 表示法*，这是一种指定二进制定点数格式参数的方法。例如，在 Q 表示法中，Q1.2 表示 1 位用于数字的整数部分，2 位用于小数部分。标准 Q 表示法假设值是带符号的；然而，在 FPGA 中，使用无符号和带符号值是非常常见的。这就是为什么我更喜欢使用带有前导字符的表示法来指定值是否为带符号（S）或无符号（U）。因此，S3.1 表示一个带符号值，其中 3 个比特用于整数部分，1 个比特用于小数部分，U4.8 表示一个无符号值，其中 4 个比特用于整数部分，8 个比特用于小数部分。

在表 10-4 中，U3.0 列是我们熟悉的；所有 3 个比特分配给数字的整数部分，因此我们只有整数。接下来考虑下一列 U2.1\。它是无符号的，其中 2 个比特用于整数部分，1 个比特用于小数部分。这意味着整数部分的取值范围可以是 00、01、10、11，小数部分的取值范围可以是 0 或 1。为了找出这些值的可能性，只需将原始的 U3.0 值除以 2。例如，111 在 U3.0 中是 7，但在 U2.1 中是 3.5（7 / 2 = 3.5）。一般来说，当有 *N* 个比特分配给数字的小数部分时，你将整数表示除以 2*^N* 来确定定点值。因此，111 在 U0.3 中是 7 / 2³ = 7 / 8 = 0.875。

在表 10-4 中，我们将所有值都视为无符号的。表 10-5 显示了在使用带符号数据类型时解释相同 3 个比特的最常见方式。

表 10-5： 3 位符号定点数可能性

| 位 | S3.0 | S2.1 | S1.2 | S0.3 |
| --- | --- | --- | --- | --- |
| 000 | 0 | 0 | 0 | 0 |
| 001 | 1 | 0.5 | 0.25 | 0.125 |
| 010 | 2 | 1.0 | 0.50 | 0.250 |
| 011 | 3 | 1.5 | 0.75 | 0.375 |
| 100 | –4 | –2.0 | –1.00 | –0.500 |
| 101 | –3 | –1.5 | –0.75 | –0.375 |
| 110 | –2 | –1.0 | –0.50 | –0.250 |
| 111 | –1 | –0.5 | –0.25 | –0.125 |

S3.0 列显示了我们在本章早些时候看到的相同符号的整数值，参见表 10-1。我们可以通过将 S3.0 列中的值分别除以 2 得到 S2.1，除以 4 得到 S1.2，除以 8 得到 S0.3。

这里关于处理定点数的关键点是：当你对二进制数据进行操作时，二进制操作的行为不会因其表示形式而改变。加法、减法、乘法和除法的工作方式与之前将数字视为整数时完全相同。然而，要获得定点值的正确答案，仍然需要建立一些额外的规则。

你会注意到，在本章剩余部分，我尽量跟踪代码示例中的小数位。我发现，在我的 Verilog 或 VHDL 代码中添加注释记录数学操作的小数位宽非常有帮助。例如，当将两个 3 位数相加得到一个 4 位结果时，我会加上类似 // U2.1 + U2.1 = U3.1 的注释，这样我就知道小数位和整数位的宽度。这在进行多个数学操作并且操作过程中宽度可能发生变化时特别有用。

### 定点加法和减法

当执行带有定点小数的加法或减法时，实际过程并不会改变。数据仍然是二进制的。然而，在涉及小数时，我们必须应用另一条规则：

**规则 #5** 在进行加法或减法时，小数位数必须匹配。

小数点右侧的位数决定了每个位的值或*权重*，所以如果你尝试将两个具有不同小数位宽的输入相加或相减——例如，一个是 U3.1 输入，一个是 U4.0 输入——你会得到错误的答案。我们可以在下面的代码中看到这一点：

Verilog

```
 // U3.1 + U4.0 = U4.1 (Rule #5 violation)
   i1_u4 = 4'b0011;
   i2_u4 = 4'b0011;
   o_u5  = i1_u4 + i2_u4;
❶ $display("Ex20: %2.3f + %2.3f = %2.3f", i1_u4/2.0, i2_u4, o_u5/2.0);
```

VHDL

```
 -- U3.1 + U4.0 = U4.1 (Rule #5 violation)
   i1_u4 := "0011";
   i2_u4 := "0011";
   i1_u5 := resize(i1_u4, i1_u5'length);
   i2_u5 := resize(i2_u4, i2_u5'length);
   o_u5  := i1_u5 + i2_u5;
❶ real1 := real(to_integer(i1_u5)) / 2.0;
   real2 := real(to_integer(i2_u5));
   real3 := real(to_integer(o_u5)) / 2.0;
   report "Ex20: " & str(real1) & " + " & str(real2) & " = " & str(real3);
```

这是输出结果：

Verilog

```
# Ex20: 1.500 + 3.000 = 3.000
```

VHDL

```
# ** Note: Ex20: 1.500 + 3.000 = 3.000
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
```

Ex20 显示了不遵守规则 #5 的效果。在这里，我们试图将一个 U3.1 加到一个 U4.0 上。这将导致问题，因为被加在一起的位的权重没有匹配。事实上，打印输出告诉我们 1.5 + 3 = 3，所以显然出了问题。

请注意，我们已经将输入 U3.1 和输出 U5.1 除以 2.0，以正确打印这些定点值❶。对于 Verilog，我们可以简单地对无符号输入进行除法，并使用%f格式化结果为浮点数。在 VHDL 中，转换要复杂一些。首先，我们需要切换到real数据类型，它用于带小数的数字，然后我们就可以除以 2.0 来进行打印。

要修复这个例子，我们需要调整其中一个输入，使其与另一个输入具有相同的小数位数。我们可以将第一个输入从 U3.1 改为 U4.0，以匹配第二个输入，或者将第二个输入从 U4.0 改为 U4.1。以下代码尝试了这两种选项：

Verilog

```
 // Convert U3.1 to U4.0
   // U4.0 + U4.0 = U5.0 (Rule #5 fix, using truncation)
   i1_u4 = 4'b0011;
   i2_u4 = 4'b0011;
❶ i1_u4 = i1_u4 >> 1; // Convert U3.1 to U4.0 by dropping decimal
   o_u5  = i1_u4 + i2_u4;
   $display("Ex21: %2.3f + %2.3f = %2.3f", i1_u4, i2_u4, o_u5);
   // Or Convert U4.0 to U4.1
   // U3.1 + U4.1 = U5.1 (Rule #5 fix, using expansion)
   i1_u4 = 4'b0011;
   i2_u4 = 4'b0011;
❷ i2_u5 = i2_u4 << 1;
   o_u6  = i1_u4 + i2_u5;
   $display("Ex22: %2.3f + %2.3f = %2.3f", i1_u4/2.0, i2_u5/2.0, o_u6/2.0);
```

VHDL

```
 -- Convert U3.1 to U4.0
   -- U4.0 + U4.0 = U5.0 (Rule #5 fix, using truncation)
    i1_u4 := "0011";
   i2_u4 := "0011";
❶ i1_u4 := shift_right(i1_u4, 1); -- Convert U3.1 to U4.0
   i1_u5 := resize(i1_u4, i1_u5'length);
   i2_u5 := resize(i2_u4, i2_u5'length);
   o_u5  := i1_u5 + i2_u5;
   real1 := real(to_integer(i1_u5));
   real2 := real(to_integer(i2_u5));
   real3 := real(to_integer(o_u5));
   report "Ex21: " & str(real1) & " + " & str(real2) & " = " & str(real3);
   -- Or Convert U4.0 to U4.1
   -- U3.1 + U4.1 = U5.1 (Rule #4 fix, using expansion)
   i1_u4 := "0011";
   i2_u4 := "0011";
   i1_u6 := resize(i1_u4, i1_u6'length); -- expand for adding
   i2_u6 := resize(i2_u4, i2_u6'length); -- expand for adding
❷ i2_u6 := shift_left(i2_u6, 1); -- Convert 4.0 to 4.1
   o_u6  := i1_u6 + i2_u6; real1 := real(to_integer(i1_u6)) / 2.0;
   real2 := real(to_integer(i2_u6)) / 2.0;
   real3 := real(to_integer(o_u6)) / 2.0;
   report "Ex22: " & str(real1) & " + " & str(real2) & " = " & str(real3);
```

这是输出：

Verilog

```
# Ex21: 1.000 + 3.000 = 4.000
# Ex22: 1.500 + 3.000 = 4.500
```

VHDL

```
# ** Note: Ex21: 1.000 + 3.000 = 4.000
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
# ** Note: Ex22: 1.500 + 3.000 = 4.500
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
```

在Ex21中，我们将 U3.1 转换为 U4.0，实质上丢弃了小数点。我们通过将位移 1 位到右来实现这一点❶。但是考虑这个操作的影响：我们正在去掉最不重要的位，如果该位是 1，那么我们就丢失了这部分数据。实际上，我们正在执行向下取整的舍入操作。我们可以看到，输入最初是 1.5，但去掉小数点后变为 1.0。数学上是正确的，1.0 + 3.0 = 4.0，但我们已经截断了输入。

Ex22展示了一个更好的解决方案，它保持了所有输入的精度。我们不是将第一个输入向右移，而是将第二个输入向左移❷。这样填充了最不重要的位为 0，将第二个输入从 U4.0 转换为 U4.1。注意，这意味着第二个输入现在占用了总共 5 个位。我们需要确保对其进行调整，否则在向左移位的过程中可能会丢失最重要位的数据。此外，我们的输出现在必须是 6 个位，以确保不违反规则#1。

现在，由于两个输入的小数宽度已经匹配且没有丢失精度，我们可以成功地计算出 1.5 + 3.0 = 4.5。如果你不想舍去任何小数值，扩展输入使其匹配是最好的解决方案。

注意

*减法操作的定点数遵循与加法相同的规则，因此我们在这里不考虑具体示例。遵循本章介绍的规则，你的减法操作将按预期工作。*

### 定点数乘法

使用定点数进行乘法运算不需要进行移位以匹配小数位宽。相反，只要我们跟踪输入宽度并适当调整输出宽度，就可以直接将两个输入相乘。我们已经有了一个关于乘法的规则：

**规则 #4** 进行乘法运算时，输出位宽必须至少是输入位宽的总和（符号扩展前）。

现在，我们需要添加另一个规则来处理定点数：

**规则 #6** 进行定点数乘法时，分别将输入的整数部分位宽和小数部分位宽相加，以确定输出格式。

例如，如果你试图将一个 U3.5 乘以一个 U1.7，结果格式为 U4.12。我们通过将整数部分（3 + 1 = 4）和小数部分（5 + 7 = 12）相加来确定输出宽度格式。对于带符号值，处理方法相同，所以 S3.0 × S2.4 = S5.4。请注意，我们仍然遵循规则 #4，因为输出宽度将是输入宽度的总和。只是整数部分和小数部分会分别处理。

让我们来看一些 Verilog 和 VHDL 的示例：

Verilog

```
 // U2.2 * U3.1 = U5.3
   i1_u4 = 4'b0101;
   i2_u4 = 4'b1011;
   o_u8  = i1_u4 * i2_u4;
   $display("Ex23: %2.3f * %2.3f = %2.3f", i1_u4/4.0, i2_u4/2.0, o_u8/8.0);
   // S2.2 * S4.0 = S6.2
   i1_s4 = 4'b0110;
   i2_s4 = 4'b1010;
   o_s8  = i1_s4 * i2_s4;
   $display("Ex24: %2.3f * %2.3f = %2.3f", i1_s4/4.0, i2_s4, o_s8/4.0);
```

VHDL

```
 -- U2.2 * U3.1 = U5.3
   i1_u4 := "0101";
   i2_u4 := "1011";
   o_u8  := i1_u4 * i2_u4;
   real1 := real(to_integer(i1_u4)) / 4.0;
   real2 := real(to_integer(i2_u4)) / 2.0;
   real3 := real(to_integer(o_u8))  / 8.0;
   report "Ex23: " & str(real1) & " * " & str(real2) & " = " & str(real3);
   -- S2.2 * S4.0 = S6.2
   i1_s4 := "0110";
   i2_s4 := "1010";
   o_s8  := i1_s4 * i2_s4;
   real1 := real(to_integer(i1_s4)) / 4.0;
   real2 := real(to_integer(i2_s4));
   real3 := real(to_integer(o_s8))  / 4.0;
   report "Ex24: " & str(real1) & " * " & str(real2) & " = " & str(real3);
```

这是输出结果：

Verilog

```
# Ex23: 1.250 * 5.500 = 6.875
# Ex24: 1.500 * -6.000 = -9.000
```

VHDL

```
# ** Note: Ex23: 1.250 * 5.500 = 6.875
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
# ** Note: Ex24: 1.500 * -6.000 = -9.000
#    Time: 0 ns  Iteration: 0  Instance: /math_examples
```

在 Ex23 中，我们将一个 U2.2 乘以一个 U3.1，得到一个结果为 U5.3。我们可以从打印输出中看到，答案是正确的：1.25 × 5.5 = 6.875。与加法示例一样，请注意，我们必须先将值进行除法运算才能正确打印它们。我们将 U2.2 除以 4，U3.1 除以 2，U5.3 除以 8。在 Ex24 中，我们使用相同的技术来进行带符号数的乘法运算。我们将 1.5 乘以 -6.0，得到 -9.0，表示为 S2.2 × S4.0 = S6.2。

## 总结

由于 FPGA 以其能够在快速时钟频率和并行处理下执行大量计算而闻名，许多常见的 FPGA 应用都需要进行加法、减法、乘法和除法运算。在你的 FPGA 中，这些操作可能涉及查找表（LUT）、移位寄存器或 DSP 模块。然而，比知道操作是如何实现的更重要的是理解输入和输出是如何存储的，以及在编写 Verilog 或 VHDL 代码时，这些二进制数字代表的含义。它们是带符号的还是无符号的？整数还是定点数？

在本章中，我们已经制定了一套规则，用于成功执行 FPGA 数学运算并解释结果。它们是：

**规则 #1** 在进行加法或减法时，结果的位宽应该比最大的输入宽度大至少 1 位，且在进行符号扩展之前。符号扩展应用后，输入和输出的位宽应该完全匹配。

**规则 #2** 输入和输出之间的类型必须匹配。

**规则 #3** 在进行减法时，使用带符号的输入和输出。

**规则 #4** 在进行乘法运算时，输出的位宽必须至少是输入位宽的总和（在符号扩展之前）。

**规则 #5** 在进行加法或减法时，小数位宽必须匹配。

**规则 #6** 在进行定点数乘法时，分别将输入的整数部分位宽和小数部分位宽相加，得到输出格式。

这些规则并没有涵盖 FPGA 中数学运算的所有细节，但它们涵盖了你需要正确处理的主要细节。如果你遵循这六条规则，你的计算结果更有可能是正确的。每当你进行数学运算时，添加测试将帮助确保一切按预期工作。
