- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">20</samp> <samp class="SANS_Dogma_OT_Bold_B_11">REMOTE
    CONTROL VIA TELEGRAM</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">20</samp> <samp class="SANS_Dogma_OT_Bold_B_11">通过
    TELEGRAM 远程控制</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Controlling your Arduino from a distance greater than your local area network
    often requires paid IoT services, such as Blynk or Microsoft Azure, or some complex
    coding and time. For a simpler and less expensive way to remotely control your
    Arduino and retrieve data, you can use the Telegram instant-messaging service
    and an ESP32-based Arduino-compatible board.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从远程控制 Arduino，超出本地网络的范围，通常需要付费的物联网服务，例如 Blynk 或 Microsoft Azure，或者一些复杂的编码和时间。为了更简单且成本更低的远程控制方式，你可以使用
    Telegram 即时消息服务和基于 ESP32 的 Arduino 兼容板。
- en: Telegram is a free, globally accessible cross-platform encrypted messaging service
    that allows users to chat with each other one on one or in groups on a relatively
    secret basis. Thanks to Telegram’s automation feature, you can get an Arduino
    to control a Telegram user account to send and receive data over the service.
    This allows you to build remote-controlled devices and remotely request data from
    an internet-connected Arduino using Telegram.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Telegram 是一款免费的全球可访问的跨平台加密消息服务，允许用户以相对隐秘的方式进行一对一或群组聊天。得益于 Telegram 的自动化功能，你可以让
    Arduino 控制一个 Telegram 用户账户，通过该服务发送和接收数据。这使你能够构建远程控制的设备，并使用 Telegram 从连接到互联网的 Arduino
    远程请求数据。
- en: 'In this chapter, I’ll introduce you to the Telegram app and web interface.
    You’ll interface Arduino sketches with the Telegram library. You’ll learn to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍 Telegram 应用和网页版界面。你将学习如何将 Arduino 程序与 Telegram 库连接。你将学到：
- en: Create a simple remote to control digital output pins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的遥控器来控制数字输出引脚
- en: Build a project that remotely retrieves data generated by the BMP180 sensor
    board
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个项目，远程检索 BMP180 传感器板生成的数据
- en: Configure an automated data transmitter that you can monitor from the internet
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置一个你可以从互联网监控的自动化数据传输器
- en: <samp class="SANS_Futura_Std_Bold_B_11">Configuring Your Telegram Account</samp>
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">配置你的 Telegram 账户</samp>
- en: You can communicate over Telegram using either an app on your device or a web
    browser on almost any device connected to the internet. However, you’ll need to
    create a Telegram account using a device such as a smartphone or tablet before
    you can use the service on your computer. If you don’t already have an account,
    visit the website [*https://<wbr>telegram<wbr>.org*](https://telegram.org), download
    and install the app for your device, and set up a user account.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 Telegram 应用或者几乎任何连接到互联网的设备上的网页浏览器进行通信。然而，在你可以在电脑上使用该服务之前，你需要先通过智能手机或平板设备创建一个
    Telegram 账户。如果你还没有账户，请访问网站 [*https://<wbr>telegram<wbr>.org*](https://telegram.org)，下载并安装适合你设备的应用，并设置一个用户账户。
- en: To communicate with your Arduino-compatible ESP32 board over Telegram, you’ll
    need to create a Telegram “bot,” your own automated Telegram user that receives
    and sends messages to and from your ESP32\. To do so, open Telegram, log into
    your account on your device, and search for the user *BotFather*, as shown in
    [Figure 20-1](chapter20.xhtml#fig20-1) (Android).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 Telegram 与你的 Arduino 兼容的 ESP32 板进行通信，你需要创建一个 Telegram “机器人”，这是你自己的自动化 Telegram
    用户，用于接收和发送消息到 ESP32。为此，打开 Telegram，登录你的设备账户，搜索用户 *BotFather*，如图 [20-1](chapter20.xhtml#fig20-1)
    所示（Android）。
- en: '![A SCREENSHOT OF SEARCHING FOR THE BOTFATHER USER ON TELEGRAM](../images/fig20-1.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![在 TELEGRAM 中搜索 BotFather 用户的截图](../images/fig20-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-1: Searching for
    the Telegram user</samp> <samp class="SANS_Futura_Std_Book_11">BotFather</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">on Android</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-1：在 Android 上搜索 Telegram
    用户</samp> <samp class="SANS_Futura_Std_Book_11">BotFather</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">的截图</samp>
- en: Select the BotFather account with the blue tick, and you should be presented
    with the start screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 选择带有蓝色勾选标记的 BotFather 账户，你应该会看到开始界面。
- en: Tap **START** to proceed. Telegram should then show you a list of options. Click,
    touch, or just send **/newbot** in the messenger to be prompted for a bot account
    name. Once you enter your preferred bot name, you’ll be prompted for a username
    for your bot. Enter your preferred username. You’ll then be presented with your
    *token*, a unique identifier for your bot that’s required for your Arduino sketches,
    as shown in [Figure 20-2](chapter20.xhtml#fig20-2).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **START** 继续。Telegram 应该会显示一个选项列表。点击、触摸或在消息中发送 **/newbot** 来提示您输入一个机器人帐户名称。输入您喜欢的机器人名称后，系统会提示您为机器人设置用户名。输入您喜欢的用户名后，您将获得一个
    *令牌*，这是机器人独有的标识符，您的 Arduino 草图中需要使用它，如[图 20-2](chapter20.xhtml#fig20-2)所示。
- en: '![A SCREENSHOT OF BOT ACCOUNT CREATION](../images/fig20-2.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![机器人帐户创建的截图](../images/fig20-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-2: Bot account creation
    in Telegram</samp>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-2: 在 Telegram 中创建机器人帐户</samp>'
- en: Write the token down for later reference. You might copy and paste it into a
    file if you’re using Telegram on a computer or into a notes app on your mobile
    device.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将令牌记下来以供以后参考。如果您在计算机上使用 Telegram，可以将其复制并粘贴到文件中，或者在移动设备的笔记应用中保存。
- en: Next, you need to determine your Telegram chat ID, a unique number you’ll use
    to authenticate your Arduino’s messages to Telegram. Search for the Telegram user
    *IDBot* and select the result with the image of a fingerprint for the avatar,
    as shown in [Figure 20-3](chapter20.xhtml#fig20-3).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要确定您的 Telegram 聊天 ID，这是一个唯一的数字，用于验证您 Arduino 向 Telegram 发送的消息。搜索 Telegram
    用户 *IDBot*，并选择带有指纹图标的结果，如[图 20-3](chapter20.xhtml#fig20-3)所示。
- en: '![A SCREENSHOT OF SEARCHING FOR IDBOT](../images/fig20-3.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![查找 IDBOT 的截图](../images/fig20-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-3: Searching for
    the</samp> <samp class="SANS_Futura_Std_Book_11">IDBot</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Telegram
    account</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-3: 查找</samp> <samp class="SANS_Futura_Std_Book_11">IDBot</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">Telegram 帐户</samp>'
- en: Once you have opened its account, send IDBot the message **/start** to initialize
    communication and then **/getid**, as shown in [Figure 20-4](chapter20.xhtml#fig20-4).
    When IDBot replies with your chat ID, write that number down as well, as you’ll
    need it along with the token.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 打开其帐户后，向 IDBot 发送 **/start** 消息以初始化通信，然后发送 **/getid**，如[图 20-4](chapter20.xhtml#fig20-4)所示。当
    IDBot 回复您的聊天 ID 后，请记下该号码，您将需要它和令牌一起使用。
- en: '![A SCREENSHOT OF SEARCHING FOR THE CHAT ID OF THE ACCOUNT](../images/fig20-4.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![查找帐户聊天 ID 的截图](../images/fig20-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-4: Searching for
    the account’s chat ID</samp>'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-4: 查找帐户的聊天 ID</samp>'
- en: Now that you have your Telegram account and bot set up, it’s time to configure
    your Arduino IDE.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经设置好 Telegram 帐户和机器人，是时候配置您的 Arduino IDE 了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Configuring the Arduino IDE</samp>
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">配置 Arduino IDE</samp>
- en: If you haven’t already done so, follow the instructions in “Configuring the
    Arduino IDE for the ESP32” and “Testing the ESP32” in [Chapter 19](chapter19.xhtml).
    Once you’ve set up your ESP32, you need to install two libraries. Search for **UniversalTelegramBot**
    in the Library Manager, and then click **Install**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有完成，请按照[第 19 章](chapter19.xhtml)中“为 ESP32 配置 Arduino IDE”和“测试 ESP32”的说明进行操作。一旦您设置好
    ESP32，您需要安装两个库。在库管理器中搜索 **UniversalTelegramBot**，然后点击 **安装**。
- en: Once UniversalTelegramBot is installed, search for **ArduinoJson** in the Library
    Manager, and then click **Install** at the bottom of the library description (unless
    the library was already installed along with UniversalTelegramBot).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 安装好 UniversalTelegramBot 后，在库管理器中搜索 **ArduinoJson**，然后点击库描述底部的 **安装**（除非该库已经与
    UniversalTelegramBot 一起安装）。
- en: You’re now ready to create your first project remote-controlled by Telegram.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您准备好创建您的第一个由 Telegram 遥控的项目了。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #58: Remote-Controlling Four
    LEDs</samp>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #58: 遥控四个 LED</samp>'
- en: This project demonstrates a fast and simple method of controlling four LEDs
    via four digital output pins on your Arduino-compatible board via Telegram. With
    your existing knowledge of electronics and Arduino, you should be able to easily
    extrapolate from this basic framework how to control other devices that can be
    triggered with a digital output pin.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目演示了一种通过Telegram控制四个LED的快速简便方法，使用的是你的Arduino兼容板上的四个数字输出引脚。凭借你现有的电子学和Arduino知识，你应该能够轻松地从这个基本框架中推导出如何控制其他可以通过数字输出引脚触发的设备。
- en: 'You’ll need the following hardware:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下硬件：
- en: An ESP32 dev board and matching USB cable
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块ESP32开发板和匹配的USB电缆
- en: A solderless breadboard
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块无焊面包板
- en: Assorted jumper wires
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种跳线
- en: Four LEDs
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个LED
- en: One 560 Ω, 0.25 W, 1 percent resistor
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个560 Ω，0.25 W，1%精度的电阻器
- en: Assemble the circuit as shown in [Figure 20-5](chapter20.xhtml#fig20-5).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图20-5](chapter20.xhtml#fig20-5)所示组装电路。
- en: '![THE SCHEMATIC FOR PROJECT #58](../images/fig20-5.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![项目#58的原理图](../images/fig20-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-5: The schematic
    for Project #58</samp>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图20-5：项目#58的原理图</samp>
- en: 'Next, enter and upload the Project #58 sketch, adding your Wi-Fi network credentials
    in the first few lines as appropriate, as originally explained in Project #55
    in [Chapter 19](chapter19.xhtml). Once the sketch has uploaded, the ESP32 should
    attempt to connect to your Wi-Fi network and communicate with the Telegram bot
    you created earlier. After a few moments, open Telegram on your device or web
    browser and search for your bot.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，输入并上传项目#58的草图，适当添加你的Wi-Fi网络凭证到前几行，正如在项目#55的[第19章](chapter19.xhtml)中所解释的那样。上传草图后，ESP32应该会尝试连接到你的Wi-Fi网络并与之前创建的Telegram机器人进行通信。几秒钟后，打开你设备上的Telegram或网页浏览器，搜索你的机器人。
- en: Select your bot. You should be presented with the bot’s chat history page. You
    can control your ESP32 board from this chat history. When a user sends the **/start**
    command, any Telegram bot should send it back to the ESP32, which is programmed
    to reply to that command with a basic set of instructions. Always include such
    instructions in your own projects so the user isn’t left at a loss on how to control
    the system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你的机器人。你应该会看到机器人的聊天历史页面。你可以通过这个聊天历史来控制你的ESP32板。当用户发送**/start**命令时，任何Telegram机器人都应该将其发送回ESP32，ESP32会通过一组基本的指令来回应该命令。始终在你的项目中包含这样的指令，以确保用户不会不知道如何控制系统。
- en: After Telegram displays the start message, you can send the commands included
    in the instruction set and watch the LEDs respond to your commands. [Figure 20-6](chapter20.xhtml#fig20-6)
    shows an example of starting the bot and controlling the LEDs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Telegram显示启动消息后，你可以发送指令集中包含的命令，并观察LED如何响应你的命令。[图20-6](chapter20.xhtml#fig20-6)展示了启动机器人并控制LED的示例。
- en: '![A SCREENSHOT OF THE ESP32 CONTROL VIA TELEGRAM](../images/fig20-6.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![通过Telegram控制ESP32的截图](../images/fig20-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-6: Sending various
    commands to the ESP32 board via Telegram</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图20-6：通过Telegram向ESP32板发送各种命令</samp>
- en: You should receive a response to all the commands being sent; again, it’s good
    practice to write code that replies to the user to make sure actions have taken
    place. The sketch also acknowledges responses in the Arduino IDE’s Serial Monitor,
    as shown in [Figure 20-7](chapter20.xhtml#fig20-7).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会收到所有发送命令的响应；同样，良好的编程习惯是写出回应用户的代码，以确保操作已经发生。草图也会在Arduino IDE的串口监视器中确认回应，如[图20-7](chapter20.xhtml#fig20-7)所示。
- en: '![A SCREENSHOT OF THE EXAMPLE SERIAL MONITOR OUTPUT FOR PROJECT #58](../images/fig20-7.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![项目#58示例串口监视器输出的截图](../images/fig20-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-7: Example Serial
    Monitor output for Project #58</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图20-7：项目#58的示例串口监视器输出</samp>
- en: 'Let’s see how this works:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个是如何工作的：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The sketch first includes the required libraries, followed by fields to enter
    your Wi-Fi network’s ID and password and then fields to enter your Telegram token
    and chat ID. It defines the pin numbers for the LEDs so you can easily refer to
    them in the rest of the sketch ❶ and then starts instances of the secure Wi-Fi
    connection client and the Telegram bot interface. Next, the sketch sets the length
    of the period it will wait before checking if new Telegram messages are available
    to 1,000 milliseconds ❷.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 草图首先包含所需的库文件，接着是输入 Wi-Fi 网络 ID 和密码的字段，然后是输入 Telegram token 和聊天 ID 的字段。它定义了 LED
    的引脚编号，以便在草图的其余部分中方便引用 ❶，然后启动安全 Wi-Fi 连接客户端和 Telegram 机器人接口的实例。接下来，草图设置等待检查是否有新的
    Telegram 消息的周期长度为 1,000 毫秒 ❷。
- en: The sketch uses the custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">processMessages()</samp>
    to retrieve the messages received by the Telegram bot and then takes actions based
    on the contents of the message. The entire process is repeated for the amount
    passed through the parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">numNewMessages</samp>.
    The sketch first performs a security check by comparing your Telegram alphanumeric
    chat ID against the chat ID being sent with the message from Telegram ❸. This
    prevents hackers from attempting to control your Telegram bot. If the two don’t
    match, the sketch jumps out of the loop with a <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    function and ignores the message(s) received. If they do match, the sketch proceeds
    to send the message received to the Serial Monitor for debugging purposes and
    then retrieves the Telegram username attached to your Telegram account ❹. This
    is used to add a friendly level of personalization.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该草图使用自定义函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">processMessages()</samp>
    来检索 Telegram 机器人接收到的消息，然后根据消息的内容采取相应的操作。整个过程会根据传入的参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">numNewMessages</samp>
    重复执行。草图首先通过比较你的 Telegram 字母数字聊天 ID 与 Telegram 发送的消息中的聊天 ID 来进行安全检查 ❸。这可以防止黑客试图控制你的
    Telegram 机器人。如果两者不匹配，草图会使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    函数跳出循环并忽略接收到的消息。如果匹配，草图将继续将接收到的消息发送到串口监视器进行调试，然后检索附加到你的 Telegram 帐户的 Telegram
    用户名 ❹。这用于增加一些个性化的友好设置。
- en: To decide how to act on the message received, the sketch compares the received
    message against various <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    functions, the first of which is <samp class="SANS_TheSansMonoCd_W5Regular_11">/start</samp>
    ❺. When activated, this part of the sketch combines lines of text, including the
    Telegram username, into one string variable, which is then sent to be displayed
    in the Telegram chat using <samp class="SANS_TheSansMonoCd_W5Regular_11">bot.sendMessage()</samp>
    ❻. The sketch is set up to accept various other chat messages from a user, all
    beginning with a forward slash (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>).
    For example, the message to turn on LED number 1 (<samp class="SANS_TheSansMonoCd_W5Regular_11">/1on</samp>)
    is detected at ❼. When a message is received from the user, a <samp class="SANS_TheSansMonoCd_W5Regular_11">bot.sendMessage()</samp>
    function sends an acknowledgment back to the Telegram chat and then turns on the
    LED. The sketch receives and acts upon the rest of the possible messages in a
    similar manner.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定如何处理接收到的消息，草图将接收到的消息与多个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    函数进行比较，第一个是 <samp class="SANS_TheSansMonoCd_W5Regular_11">/start</samp> ❺。当激活时，草图的这一部分会将多行文本，包括
    Telegram 用户名，合并成一个字符串变量，然后使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">bot.sendMessage()</samp>
    ❻ 发送该字符串以在 Telegram 聊天中显示。草图已设置为接受来自用户的各种其他聊天消息，所有消息都以斜杠（<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>）开头。例如，打开
    LED 1 的消息（<samp class="SANS_TheSansMonoCd_W5Regular_11">/1on</samp>）在 ❼ 处被检测到。当收到用户的消息时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">bot.sendMessage()</samp> 函数会向 Telegram
    聊天发送一条确认消息，然后打开 LED。草图以类似的方式接收并执行其他可能的消息。
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch
    configures the digital pins for the LEDs and sets them to <samp class="SANS_TheSansMonoCd_W5Regular_11">LOW</samp>
    by default, initializes the Wi-Fi library, and sets up a secure connection to
    Telegram. Finally, it connects the ESP32 board to your Wi-Fi and sends the IP
    address to the Serial Monitor.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> 中，草图配置了
    LED 的数字引脚，并将其默认设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">LOW</samp>，初始化了
    Wi-Fi 库，并建立了与 Telegram 的安全连接。最后，它将 ESP32 板连接到 Wi-Fi 并将 IP 地址发送到串口监视器。
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>, the sketch
    checks Telegram for any new chat messages every second, using the comparison in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> function. Every time
    a message is received, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">lastRun</samp>
    is updated to the value returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp>.
    If the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp>
    is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">lastRun</samp> plus
    <samp class="SANS_TheSansMonoCd_W5Regular_11">bot_delay</samp> (the amount of
    time to wait between checking for messages), it’s time to check for messages again.
    The number of new messages is then retrieved from Telegram and processed in turn
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">processMessages()</samp>
    function described earlier.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp> 中，示例代码每秒检查一次
    Telegram 是否有新的聊天消息，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    函数中的比较。每当收到一条消息时，<samp class="SANS_TheSansMonoCd_W5Regular_11">lastRun</samp>
    的值会被更新为 <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp> 返回的值。如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp> 的值大于 <samp class="SANS_TheSansMonoCd_W5Regular_11">lastRun</samp>
    加上 <samp class="SANS_TheSansMonoCd_W5Regular_11">bot_delay</samp>（即检查消息之间的延迟时间），那么就该再次检查消息了。然后，从
    Telegram 获取新的消息数量，并通过之前描述的 <samp class="SANS_TheSansMonoCd_W5Regular_11">processMessages()</samp>
    函数逐一处理这些消息。
- en: This sketch provides a simple framework for acting upon messages received from
    Telegram, along with a simple remote control for digital outputs. The next project
    builds on this framework, teaching you to retrieve data from the remote ESP32
    board using Telegram.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例提供了一个简单的框架，用于处理从 Telegram 接收到的消息，并提供了一个简单的数字输出远程控制。下一个项目将在此框架基础上进行拓展，教你如何通过
    Telegram 从远程的 ESP32 板获取数据。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #59: Retrieving Remote Data</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #59：获取远程数据</samp>'
- en: This project enables you to retrieve, on demand, the data generated by the BMP180
    sensor board first used in [Chapter 10](chapter10.xhtml), including temperature,
    air pressure, or height above sea level. You can also use this project as a general
    framework for remotely monitoring parameters over Telegram.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目使你能够按需获取由 BMP180 传感器板（首次在[第10章](chapter10.xhtml)中使用）生成的数据，包括温度、气压或海拔高度。你也可以将此项目作为一个通用框架，通过
    Telegram 远程监控参数。
- en: 'You’ll need the following hardware:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下硬件：
- en: An ESP32 dev board and matching USB cable
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块 ESP32 开发板和匹配的 USB 电缆
- en: A solderless breadboard
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块无焊接面包板
- en: Assorted jumper wires
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种跳线
- en: A BMP180 sensor board
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块 BMP180 传感器板
- en: Assemble the circuit as shown in [Figure 20-8](chapter20.xhtml#fig20-8). The
    BMP180 can work on 3.3 V as well as 5 V, so a level converter board isn’t necessary
    in this case.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图20-8](chapter20.xhtml#fig20-8)中的示意图组装电路。BMP180 可以在 3.3 V 和 5 V 下工作，因此在这种情况下不需要电平转换板。
- en: '![THE SCHEMATIC FOR PROJECT #59](../images/fig20-8.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #59 的电路图](../images/fig20-8.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-8: The schematic
    for Project #59</samp>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图20-8：项目 #59 的电路图</samp>'
- en: Once you have built the circuit and uploaded the sketch, open Telegram and enter
    the chat history for your Telegram bot, as with the previous project. Enter **/start**
    in Telegram. You should receive a message listing the commands you can use to
    retrieve sensor data, as shown in [Figure 20-9](chapter20.xhtml#fig20-9). For
    variety, I’ve used the Telegram Windows application, rather than the Android app,
    to take screenshots for this project.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你搭建好电路并上传了示例代码，打开 Telegram，进入你的 Telegram 机器人聊天历史，就像之前的项目一样。在 Telegram 中输入
    **/start**。你应该会收到一条消息，列出你可以用来获取传感器数据的命令，如[图20-9](chapter20.xhtml#fig20-9)所示。为了增加变化，我使用了
    Telegram Windows 应用程序，而不是 Android 应用，来为这个项目截图。
- en: '![THE EXAMPLE OUTPUT FROM PROJECT #59](../images/fig20-9.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #59 的示例输出](../images/fig20-9.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-9: Example output
    from Project #59</samp>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图20-9：项目 #59 的示例输出</samp>'
- en: 'Let’s see how this works:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个是如何工作的：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This sketch’s framework for using Telegram is the same as in Project #58\.
    The only differences are the changes required for new hardware used—in this case
    the BMP180 sensor—and the communication messages for use with Telegram. The sketch
    includes the required library and initialization for the BMP180 sensor ❶ ❻. It
    modifies the prior Telegram start message to suit this project’s purposes ❷ and
    programs the responses to temperature ❸, air pressure ❹, and altitude message
    requests ❺. You can easily modify the sketch for this project to substitute your
    own required actions to control ESP32 Arduino-compatible boards remotely via Telegram.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '该草图使用 Telegram 的框架与项目 #58 相同。唯一的区别是为了新硬件的使用所做的更改——在此案例中为 BMP180 传感器——以及用于 Telegram
    的通信消息。草图包括 BMP180 传感器的所需库和初始化 ❶ ❻。它修改了之前的 Telegram 启动消息，以适应本项目的目的 ❷，并编写了温度 ❸、气压
    ❹ 和高度 ❺ 消息请求的响应程序。你可以轻松修改本项目的草图，以便替换为你自己的操作，用于通过 Telegram 远程控制 ESP32 兼容的 Arduino
    开发板。'
- en: Keep the hardware for this project connected. You’ll use it in the next project,
    in which you’ll learn to automate data transmission over Telegram.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 保持该项目的硬件连接。你将在下一个项目中使用它，在该项目中你将学习如何通过 Telegram 自动化数据传输。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #60: Automating Data Transmission</samp>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #60：自动化数据传输</samp>'
- en: This project automatically sends data generated by the BMP180 sensor board on
    a recurring basis to your Telegram account. Rather than using messaging to request
    data, you can simply open your Telegram chat to view the latest project updates,
    watching changes in data in (nearly) real time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目会自动定期将 BMP180 传感器板生成的数据发送到你的 Telegram 帐户。与通过消息请求数据不同，你只需打开 Telegram 聊天即可查看最新的项目更新，几乎实时地观看数据的变化。
- en: 'The required hardware is the same as that for Project #59\. Once you’ve set
    it up, enter and upload the Project #60 sketch, adding your Wi-Fi network credentials
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp> fields as
    usual. After a few moments, open the Telegram bot chat window. You should see
    the temperature from the BMP180 displayed around every five seconds, as shown
    in [Figure 20-10](chapter20.xhtml#fig20-10).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '所需硬件与项目 #59 相同。一旦设置完成，输入并上传项目 #60 的草图，像往常一样在 <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp>
    字段中添加你的 Wi-Fi 网络凭证。稍等片刻，打开 Telegram 机器人聊天窗口。你应该能看到来自 BMP180 的温度，每隔五秒钟更新一次，如 [图
    20-10](chapter20.xhtml#fig20-10) 所示。'
- en: '![THE EXAMPLE OUTPUT FROM PROJECT #60](../images/fig20-10.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #60 的示例输出](../images/fig20-10.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-10: Example output
    from Project #60</samp>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 20-10：项目 #60 的示例输出</samp>'
- en: 'Let’s see how this works:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As this project is a one-way form of messaging, the required code is much shorter
    than that of the previous projects. The setup for the BMP180, Wi-Fi and Telegram
    is still required, but the custom functions to deal with receiving and acting
    upon messages from the Telegram chat aren’t required. The sketch simply sends
    one message on a regular basis, using <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>. It declares the string variable <samp class="SANS_TheSansMonoCd_W5Regular_11">messageOut</samp>
    to hold the text to send out, then composes the message with explanation text
    showing that the data is temperature ❶ and the temperature value from the BMP180
    ❷. It then sends the message to the Telegram chat. After a delay of five seconds,
    the process repeats.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该项目是单向消息传递形式，所需的代码比之前的项目要短得多。尽管仍然需要为 BMP180、Wi-Fi 和 Telegram 设置配置，但不需要处理接收和响应
    Telegram 聊天消息的自定义函数。草图仅通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>
    定期发送一条消息。它声明了一个字符串变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">messageOut</samp>
    用于存储要发送的文本，然后通过说明文本构建消息，显示数据是温度 ❶ 以及来自 BMP180 的温度值 ❷。然后，它将消息发送到 Telegram 聊天中。经过五秒钟的延迟后，过程会重复进行。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">继续前进</samp>
- en: In this chapter, you learned to harness the Telegram messaging application for
    remote project control or data retrieval, without any extra costs for a cloud
    service or special smartphone app. You could harness these projects to control
    your own devices with a digital output pin, or you could retrieve data from any
    sensor that can be connected to your Arduino or compatible boards.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何利用 Telegram 消息应用程序进行远程项目控制或数据检索，无需额外的云服务费用或特殊的智能手机应用程序。你可以利用这些项目通过数字输出引脚控制自己的设备，或者从任何可以连接到
    Arduino 或兼容板的传感器中检索数据。
- en: The next chapter introduces you to retrieving the current time from internet
    time servers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍如何从互联网时间服务器获取当前时间。
