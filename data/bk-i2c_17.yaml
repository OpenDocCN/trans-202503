- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: The MCP23017 and MCP23008 GPIO Expanders
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: MCP23017 和 MCP23008 GPIO 扩展器
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Most SBCs and MCUs provide anywhere from three to a couple dozen digital I/O
    pins. Sometimes, you’ll need more digital I/O than the standard complement. Even
    on those MCUs that provide a couple dozen pins or more, most of them are multifunction.
    If you use them for their alternate purposes, you may find that you don’t have
    enough remaining pins for digital I/O. This is where a GPIO expander comes in
    handy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 SBC（单板计算机）和 MCU（微控制单元）提供从三个到数十个的数字 I/O 引脚。有时候，你可能需要比标准配置更多的数字 I/O 引脚。即使是那些提供几十个引脚的
    MCU，其中大部分也是多功能的。如果你将它们用作其它功能，可能会发现剩余的数字 I/O 引脚不够用。这时，GPIO 扩展器就显得非常有用。
- en: While there are many different ICs you can purchase to provide GPIO expansion
    on the I²C bus, the MCP23008 and MCP23017 (collectively MCP230*xx*) are popular;
    they’re available in DIP (through-hole) packages, and there’s considerable library
    code available for them. The MCP23008 supports 8 GPIO pins while the MCP23017
    supports 16, but these 2 ICs are otherwise identical.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管市场上有许多不同的集成电路（IC）可用于通过 I²C 总线扩展 GPIO，MCP23008 和 MCP23017（统称为 MCP230*xx*）是非常受欢迎的；它们有
    DIP（插脚式）封装，并且有大量的库代码可供使用。MCP23008 支持 8 个 GPIO 引脚，而 MCP23017 支持 16 个，但这两个 IC 的其他功能完全相同。
- en: This chapter describes the MCP23017 and MCP23008 devices, their electrical connections,
    and how to program them. It describes the internal device registers (and how to
    use them). It also provides some sample programs to demonstrate the ICs’ operation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了 MCP23017 和 MCP23008 设备，它们的电气连接以及如何编程它们。它还描述了内部设备寄存器（以及如何使用它们），并提供了一些示例程序来演示这些
    IC 的操作。
- en: 13.1 The MCP23017 and MCP23008 Pinouts
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 MCP23017 和 MCP23008 引脚排列
- en: The MCP23017 has the pinout depicted in [Figure 13-1](#figure13-1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: MCP23017 的引脚排列如 [图 13-1](#figure13-1) 所示。
- en: '![](image_fi/502468c13/f13001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c13/f13001.png)'
- en: 'Figure 13-1: MCP23017 pinout'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-1：MCP23017 引脚排列
- en: The MCP23008 has the pinout shown in [Figure 13-2](#figure13-2).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: MCP23008 的引脚排列如 [图 13-2](#figure13-2) 所示。
- en: '![](image_fi/502468c13/f13002.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c13/f13002.png)'
- en: 'Figure 13-2: MCP23008 pinout'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-2：MCP23008 引脚排列
- en: '[Table 13-1](#table13-1) shows what the pins on each device mean.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 13-1](#table13-1) 显示了每个设备的引脚含义。'
- en: 'Table 13-1: MCP230*xx* Pin Functions'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-1：MCP230*xx* 引脚功能
- en: '| **Pin** | **MCP23008** | **MCP23017** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **引脚** | **MCP23008** | **MCP23017** |'
- en: '| --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | SCL (I²C clock) | GPIO 0, port B |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 1 | SCL（I²C 时钟） | GPIO 0，端口 B |'
- en: '| 2 | SDA (I²C data) | GPIO 1, port B |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 2 | SDA（I²C 数据） | GPIO 1，端口 B |'
- en: '| 3 | A2 (address selection) | GPIO 2, port B |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 3 | A2（地址选择） | GPIO 2，端口 B |'
- en: '| 4 | A1 (address selection) | GPIO 3, port B |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 4 | A1（地址选择） | GPIO 3，端口 B |'
- en: '| 5 | A0 (address selection) | GPIO 4, port B |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 5 | A0（地址选择） | GPIO 4，端口 B |'
- en: '| 6 | Reset (active low) | GPIO 5, port B |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 6 | Reset（低电平有效） | GPIO 5，端口 B |'
- en: '| 7 | NC (no connection) | GPIO 6, port B |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 7 | NC（无连接） | GPIO 6，端口 B |'
- en: '| 8 | INT (interrupt on input) | GPIO 7, port B |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 8 | INT（输入中断） | GPIO 7，端口 B |'
- en: '| 9 | Vss (ground) | Vdd (1.8 V, 3.3 V, or 5 V) |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 9 | Vss（地） | Vdd（1.8 V，3.3 V 或 5 V） |'
- en: '| 10 | GPIO 0 | Vss (ground) |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 10 | GPIO 0 | Vss（地） |'
- en: '| 11 | GPIO 1 | NC (no connection) |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 11 | GPIO 1 | NC（无连接） |'
- en: '| 12 | GPIO 2 | SCL (I²C clock) |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 12 | GPIO 2 | SCL（I²C 时钟） |'
- en: '| 13 | GPIO 3 | SDA (I²C data) |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 13 | GPIO 3 | SDA（I²C 数据） |'
- en: '| 14 | GPIO 4 | NC (no connection) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 14 | GPIO 4 | NC（无连接） |'
- en: '| 15 | GPIO 5 | A0 (address selection) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 15 | GPIO 5 | A0（地址选择） |'
- en: '| 16 | GPIO 6 | A1 (address selection) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 16 | GPIO 6 | A1（地址选择） |'
- en: '| 17 | GPIO 7 | A2 (address selection) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 17 | GPIO 7 | A2（地址选择） |'
- en: '| 18 | Vdd (1.8 V, 3.3 V, or 5 V) | Reset (active low) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 18 | Vdd (1.8 V, 3.3 V 或 5 V) | Reset（低电平有效） |'
- en: '| 19 | n/a | INTB (interrupt on port B) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 19 | n/a | INTB（端口 B 中断） |'
- en: '| 20 | n/a | INTA (interrupt on port A) |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 20 | n/a | INTA（端口 A 中断） |'
- en: '| 21 | n/a | GPIO 0, port A |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 21 | n/a | GPIO 0，端口 A |'
- en: '| 22 | n/a | GPIO 1, port A |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 22 | n/a | GPIO 1，端口 A |'
- en: '| 23 | n/a | GPIO 2, port A |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 23 | n/a | GPIO 2，端口 A |'
- en: '| 24 | n/a | GPIO 3, port A |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 24 | n/a | GPIO 3，端口 A |'
- en: '| 25 | n/a | GPIO 4, port A |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 25 | n/a | GPIO 4，端口 A |'
- en: '| 26 | n/a | GPIO 5, port A |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 26 | n/a | GPIO 5，端口 A |'
- en: '| 27 | n/a | GPIO 6, port A |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 27 | n/a | GPIO 6，端口 A |'
- en: '| 28 | n/a | GPIO 7, port A |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 28 | n/a | GPIO 7，端口 A |'
- en: The Vdd pin is the power supply (positive voltage) to the IC. The MCP230*xx*
    can operate at several different logic levels ranging from 1.8 V to 5.5 V (typically
    1.8 V, 3.3 V, or 5.0 V). The Vss pin is the ground connection.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Vdd 引脚是供电（正电压）引脚。MCP230*xx* 可以在多个不同的逻辑电平下工作，范围从 1.8 V 到 5.5 V（通常为 1.8 V、3.3
    V 或 5.0 V）。Vss 引脚是接地引脚。
- en: The SCL and SDA are the I²C bus pins. As usual, these are open-drain pins. The
    bus voltages (held via I²C pullup resistors) should be close to Vdd. Note that
    the MCP230*xx* are capable of operating at 100 kHz, 400 kHz, or as high as 1.7
    MHz.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: SCL和SDA是I²C总线引脚。像往常一样，这些是开漏引脚。总线电压（通过I²C上拉电阻保持）应接近Vdd。请注意，MCP230*xx* IC能够在100
    kHz、400 kHz甚至高达1.7 MHz的速度下工作。
- en: The GPIO*x* pins provide the general-purpose I/O expansion. The MCP23008 has
    8 expansion I/O pins, while the MCP23017 has 16 (named *port A* and *port B* with
    8 pins each). When operating as an input, these pins accept voltages up to Vdd.
    When operating as output pins, they produce Vdd on their outputs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO*x* 引脚提供通用I/O扩展。MCP23008有8个扩展I/O引脚，而MCP23017有16个（分别命名为*端口A*和*端口B*，每个端口有8个引脚）。当作为输入工作时，这些引脚可接受高达Vdd的电压。作为输出引脚工作时，它们在输出端产生Vdd。
- en: The A0, A1, and A2 pins specify the LO 3 bits of the device address. These should
    be wired to Vdd or Vss to set the device address. The MCP230*xx* ICs support up
    to eight different devices (selected by A0, A1, and A2 as the LO address bits)
    on the I²C bus. Note that the HO 4 address bits are always 0b0100, so the full
    device address falls in the range 0x20 to 0x27 (0x40 to 0x4E when shifted into
    the output byte).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: A0、A1和A2引脚指定设备地址的低3位。这些引脚应连接到Vdd或Vss以设置设备地址。MCP230*xx* IC支持在I²C总线上最多连接八个不同的设备（通过A0、A1和A2作为低地址位选择）。请注意，高4位地址总是0b0100，因此完整的设备地址范围在0x20到0x27之间（当移入输出字节时，地址范围为0x40到0x4E）。
- en: The Reset signal is an active low signal that resets the device. This pin, when
    low, will configure all the pins as inputs and configure the device in *safe mode*
    (least likely to cause hardware problems). Note that the MCP230*xx* devices automatically
    reset themselves when power is applied, so unless a circuit absolutely needs to
    be able to reset the MCP230*xx* during operation, you’ll normally find this pin
    connected to Vdd.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重置信号是一个有效低信号，用于复位设备。该引脚在低电平时，将所有引脚配置为输入，并将设备配置为*安全模式*（最不可能导致硬件问题）。请注意，MCP230*xx*设备在施加电源时会自动复位，因此除非电路在操作过程中绝对需要能够复位MCP230*xx*，否则通常会发现该引脚连接到Vdd。
- en: The MCP23008 INT and the MCP23017 INTA and INTB pins signal an interrupt. An
    *interrupt* is an asynchronous signal that alerts the CPU to take some action
    (generally pausing the current execution stream and running a special interrupt
    service routine to handle the event). You can program the INT, INTA, and INTB
    pins to pulse or to be set to some level whenever a change occurs on the MCP230*xx*,
    which is useful for detecting input changes when the system can’t poll the input
    pins on a frequent basis.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: MCP23008的INT引脚以及MCP23017的INTA和INTB引脚用于发出中断信号。*中断*是一个异步信号，提醒CPU采取某些操作（通常是暂停当前执行流并运行一个特殊的中断服务程序来处理事件）。你可以编程使INT、INTA和INTB引脚在MCP230*xx*发生变化时脉冲或设置为某个电平，这对于当系统不能频繁轮询输入引脚时，检测输入变化非常有用。
- en: 13.2 MCP230*xx* Registers
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 MCP230*xx* 寄存器
- en: 'The MCP230*xx* ICs are feature-rich devices. Unfortunately, this feature set
    comes at a cost: programming complexity. To program these ICs, you read and write
    various registers. The MCP23008 has 11 internal registers (see [Table 13-2](#table13-2)).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: MCP230*xx* IC是功能丰富的设备。不幸的是，这些功能的实现带来了成本：编程复杂性。为了编程这些IC，你需要读取和写入各种寄存器。MCP23008有11个内部寄存器（参见[表
    13-2](#table13-2)）。
- en: 'Table 13-2: MCP23008 Registers'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-2：MCP23008 寄存器
- en: '| **Register number** | **Name** | **Function** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **寄存器编号** | **名称** | **功能** |'
- en: '| --- | --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | IODIR | I/O data direction register |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 0 | IODIR | I/O数据方向寄存器 |'
- en: '| 1 | IPOL | Input polarity |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 1 | IPOL | 输入极性 |'
- en: '| 2 | GPINTEN | GPIO interrupt enable register |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 2 | GPINTEN | GPIO中断使能寄存器 |'
- en: '| 3 | DEFVAL | Default comparison value (for interrupts) |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 3 | DEFVAL | 默认比较值（用于中断） |'
- en: '| 4 | INTCON | Interrupt control register |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 4 | INTCON | 中断控制寄存器 |'
- en: '| 5 | IOCON | I/O configuration register |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 5 | IOCON | I/O配置寄存器 |'
- en: '| 6 | GPPU | GPIO pullup register |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 6 | GPPU | GPIO上拉寄存器 |'
- en: '| 7 | INTF | Interrupt flag register |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 7 | INTF | 中断标志寄存器 |'
- en: '| 8 | INTCAP | Interrupt capture register |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 8 | INTCAP | 中断捕捉寄存器 |'
- en: '| 9 | GPIO | GPIO I/O port register |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 9 | GPIO | GPIO I/O端口寄存器 |'
- en: '| 10 (0xA) | OLAT | Output latch register |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 10 (0xA) | OLAT | 输出锁存寄存器 |'
- en: The MCP23017 has 22 internal registers (see [Table 13-3](#table13-3)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: MCP23017有22个内部寄存器（参见[表 13-3](#table13-3)）。
- en: 'Table 13-3: MCP23017 Registers'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-3：MCP23017 寄存器
- en: '| **Register number,** **BANK = 0** | **Alternate register number,** **BANK
    = 1** | **Name** | **Function** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **寄存器编号，** **BANK = 0** | **备用寄存器编号，** **BANK = 1** | **名称** | **功能** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 0 | IODIRA | Port A I/O data direction register |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | IODIRA | Port A I/O 数据方向寄存器 |'
- en: '| 1 | 16 (0x10) | IODIRB | Port B I/O data direction register |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 16 (0x10) | IODIRB | Port B I/O 数据方向寄存器 |'
- en: '| 2 | 1 | IPOLA | Port A input polarity |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | IPOLA | Port A 输入极性 |'
- en: '| 3 | 17 (0x11) | IPOLB | Port B input polarity |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 17 (0x11) | IPOLB | Port B 输入极性 |'
- en: '| 4 | 2 | GPINTENA | Port A GPIO interrupt enable register |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2 | GPINTENA | Port A GPIO 中断使能寄存器 |'
- en: '| 5 | 18 (0x12) | GPINTENB | Port B GPIO interrupt enable register |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 18 (0x12) | GPINTENB | Port B GPIO 中断使能寄存器 |'
- en: '| 6 | 3 | DEFVALA | Port A default comparison value (for interrupts) |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 3 | DEFVALA | Port A 默认比较值（用于中断） |'
- en: '| 7 | 19 (0x13) | DEFVALB | Port B default comparison value (for interrupts)
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 19 (0x13) | DEFVALB | Port B 默认比较值（用于中断） |'
- en: '| 8 | 4 | INTCONA | Port A interrupt control register |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 4 | INTCONA | Port A 中断控制寄存器 |'
- en: '| 9 | 20 (0x14) | INTCONB | Port B interrupt control register |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 20 (0x14) | INTCONB | Port B 中断控制寄存器 |'
- en: '| 10 (0xA) | 5 | IOCON | I/O configuration register (only single IOCON) |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 10 (0xA) | 5 | IOCON | I/O 配置寄存器（只有单一的 IOCON） |'
- en: '| 11 (0xB) | 21 (0x15) | IOCON | I/O configuration register (same as register
    10/5) |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 11 (0xB) | 21 (0x15) | IOCON | I/O 配置寄存器（与寄存器 10/5 相同） |'
- en: '| 12 (0xC) | 6 | GPPUA | Port A GPIO pullup register |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 12 (0xC) | 6 | GPPUA | Port A GPIO 上拉寄存器 |'
- en: '| 13 (0xD) | 22 (0x16) | GPPUB | Port B GPIO pullup register |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 13 (0xD) | 22 (0x16) | GPPUB | Port B GPIO 上拉寄存器 |'
- en: '| 14 (0xE) | 7 | INTFA | Port A interrupt flag register |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 14 (0xE) | 7 | INTFA | Port A 中断标志寄存器 |'
- en: '| 15 (0xF) | 23 (0x17) | INTFB | Port B interrupt flag register |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 15 (0xF) | 23 (0x17) | INTFB | Port B 中断标志寄存器 |'
- en: '| 16 (0x10) | 8 | INTCAPA | Port A interrupt capture register |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 16 (0x10) | 8 | INTCAPA | Port A 中断捕获寄存器 |'
- en: '| 17 (0x11) | 24 (0x18) | INTCAPB | Port B interrupt capture register |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 17 (0x11) | 24 (0x18) | INTCAPB | Port B 中断捕获寄存器 |'
- en: '| 18 (0x12) | 9 | GPIOA | Port A GPIO |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 18 (0x12) | 9 | GPIOA | Port A GPIO |'
- en: '| 19 (0x13) | 25 (0x19) | GPIOB | Port B GPIO |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 19 (0x13) | 25 (0x19) | GPIOB | Port B GPIO |'
- en: '| 20 (0x14) | 10 (0xA) | OLATA | Port A output latch register |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 20 (0x14) | 10 (0xA) | OLATA | Port A 输出锁存寄存器 |'
- en: '| 21 (0x15) | 26 (0x1A) | OLATB | Port B output latch register |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 21 (0x15) | 26 (0x1A) | OLATB | Port B 输出锁存寄存器 |'
- en: The MCP23017 supports two sets of register numbers, standard and alternate (or
    “special”). The register number is selected by bit 7 in the IOCON (control) register.
    If this bit is 0 (the power-up/reset state), then the MCP23017 uses the standard
    register numbering. If bit 7 is 1, then the MCP23017 uses the alternate register
    numbering, which separates the two ports into separate register banks (0 to 0xA
    for port A and 0x10 to 0x1A for port B).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: MCP23017 支持两组寄存器编号，标准和备用（或“特殊”）。寄存器编号由 IOCON（控制）寄存器中的第 7 位选择。如果该位为 0（上电/复位状态），则
    MCP23017 使用标准寄存器编号。如果第 7 位为 1，则 MCP23017 使用备用寄存器编号，这将两个端口分开成两个独立的寄存器库（0 到 0xA
    为端口 A，0x10 到 0x1A 为端口 B）。
- en: 13.2.1 Accessing MCP230*xx* Registers
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.1 访问 MCP230*xx* 寄存器
- en: 'Because the MCP230*xx* devices have multiple registers, writing and reading
    data to and from these devices are a little more complex than with simpler devices
    like the MCP4725\. The (typical) protocol for writing a single byte to a register
    is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MCP230*xx* 设备具有多个寄存器，向这些设备写入和读取数据比像 MCP4725 这样的简单设备更为复杂。写入单个字节到寄存器的（典型）协议如下：
- en: Put a start condition on the I²C bus.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 I²C 总线上发送启动条件。
- en: Transmit the I²C address byte (a value in the range 0x40 to 0x46). This is always
    a write operation, so the LO bit of the address byte will always be 0.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送 I²C 地址字节（值范围为 0x40 到 0x46）。这始终是一个写操作，因此地址字节的 LO 位将始终为 0。
- en: Write the register address to the I²C bus.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将寄存器地址写入 I²C 总线。
- en: Place the register data (to write to the MCP230*xx* register) on the I²C bus.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将寄存器数据（写入 MCP230*xx* 寄存器）放置在 I²C 总线上。
- en: Put a stop condition on the bus to terminate the transfer.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在总线上发送停止条件以终止传输。
- en: 'The (typical) protocol for reading a single byte from a register is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 读取单个字节的寄存器（典型）协议如下：
- en: Put a start condition on the I²C bus.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 I²C 总线上发送启动条件。
- en: Transmit the I²C address byte (a value in the range 0x40 to 0x46). This is always
    a write operation, so the LO bit of the address byte will always be 0.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送 I²C 地址字节（值范围为 0x40 到 0x46）。这始终是一个写操作，因此地址字节的 LO 位将始终为 0。
- en: Write the register address to the I²C bus.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将寄存器地址写入 I²C 总线。
- en: Put a (re)start condition on the I²C bus.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 I²C 总线上发送（重新）启动条件。
- en: Transmit the I²C address byte (a value in the range 0x41 to 0x47). This is a
    read operation, so the LO bit of the address byte will be 1.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送 I²C 地址字节（值范围为 0x41 到 0x47）。这是一个读取操作，因此地址字节的 LO 位将为 1。
- en: Read the register data from the I²C bus.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 I²C 总线读取寄存器数据。
- en: Put a stop condition on the bus to terminate the transfer.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在总线上加上停止条件以终止传输。
- en: This chapter discusses additional forms of this protocol for block reads and
    writes; see section 13.2.6, “Sequential Register Operations,” later in this chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了该协议的其他形式，用于块读写；请参阅本章后面的第 13.2.6 节，“顺序寄存器操作”。
- en: 13.2.2 MCP230*xx* Initialization
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.2 MCP230*xx* 初始化
- en: 'At power-up, the MCP230*xx* devices enter the following state:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上电时，MCP230*xx* 设备进入以下状态：
- en: IOCON bit 7 is set to 0 to select standard register numbers on the MCP23017.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IOCON 位 7 被设置为 0，以选择 MCP23017 的标准寄存器编号。
- en: All GPIO pins are programmed as inputs (see section 13.2.3, “Programming the
    Data Direction”).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 GPIO 引脚都被编程为输入（请参阅第 13.2.3 节，“编程数据方向”）。
- en: All pullup resistors are turned off (see section 13.2.4, “Programming Input
    Pullup Resistors”).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有上拉电阻已关闭（请参阅第 13.2.4 节，“编程输入上拉电阻”）。
- en: All interrupts are disabled (see section 13.5.5, “Enabling Interrupts on the
    MCP230*xx*”).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有中断均已禁用（请参阅第 13.5.5 节，“启用 MCP230*xx* 的中断”）。
- en: On the MCP23017, port A and B interrupts will be handled independently (should
    they be enabled).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 MCP23017 上，端口 A 和 B 的中断将独立处理（如果启用）。
- en: The MCP230*xx* is programmed for sequential register operations (see section
    13.2.6, “Sequential Register Operations”).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MCP230*xx* 被编程为顺序寄存器操作（请参阅第 13.2.6 节，“顺序寄存器操作”）。
- en: SDA slew rate control is enabled (see section 13.2.7, “Slew Rate Control”).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 SDA 跃变速率控制（请参阅第 13.2.7 节，“跃变速率控制”）。
- en: The INTx pin(s) are active outputs (not open drain; see section 13.2.8, “Reading
    General-Purpose Input/Output Pins on the MCP230*xx*”).
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INTx 引脚是活动输出（非开漏；请参阅第 13.2.8 节，“读取 MCP230*xx* 上的通用输入/输出引脚”）。
- en: Interrupt output pins are active-low (low signal when an interrupt occurs; see
    section 13.5.5, “Enabling Interrupts on the MCP230*xx*”).
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断输出引脚为低有效（发生中断时为低电平信号；请参阅第 13.5.5 节，“启用 MCP230*xx* 的中断”）。
- en: The IOCON register (I/O configuration) handles most of this initialization.
    [Table 13-4](#table13-4) lists the bits in IOCON and their functions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: IOCON 寄存器（I/O 配置）处理大部分初始化操作。[表 13-4](#table13-4) 列出了 IOCON 中的位及其功能。
- en: 'Table 13-4: IOCON Register Functions'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-4：IOCON 寄存器功能
- en: '| **Bit** | **Default on power-up or reset** | **Name** | **Function** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **上电或复位时的默认值** | **名称** | **功能** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 7 | 0 | BANK | MCP23017 only. Selects standard register numbering (BANK =
    0) or alternate register numbering (BANK = 1). |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 0 | BANK | 仅限 MCP23017。选择标准寄存器编号（BANK = 0）或备用寄存器编号（BANK = 1）。 |'
- en: '| 6 | 0 | MIRROR | MCP23017 only. INTA/B mirror function. If MIRROR = 0, then
    the INTA and INTB pins operate independently. If MIRROR = 1, then the two pins
    are internally wired together. See “INT*x* Pin Polarity” under section 13.5.2
    for more information. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 0 | MIRROR | 仅限 MCP23017。INTA/B 镜像功能。如果 MIRROR = 0，则 INTA 和 INTB 引脚独立工作。如果
    MIRROR = 1，则这两个引脚内部连接在一起。有关更多信息，请参阅第 13.5.2 节中的“INT*x* 引脚极性”。 |'
- en: '| 5 | 0 | SEQOP | If SEQOP = 1, then successive data read/write operations
    read and write the same register number. If SEQOP = 0, then the register number
    is incremented after each operation (mainly for MCP23017). |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 0 | SEQOP | 如果 SEQOP = 1，则连续的数据读/写操作读取和写入相同的寄存器编号。如果 SEQOP = 0，则每次操作后寄存器编号递增（主要适用于
    MCP23017）。 |'
- en: '| 4 | 0 | DISSLW | Slew rate control for SDA pin. If DISSLW = 0, then slew
    rate control is enabled. If DISSLW = 1, then slew rate control is disabled. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0 | DISSLW | SDA 引脚的跃变速率控制。如果 DISSLW = 0，则启用跃变速率控制。如果 DISSLW = 1，则禁用跃变速率控制。
    |'
- en: '| 3 | 0 | N/A | Used only by SPI version of the MCP23S*xx* GPIO expander. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0 | N/A | 仅供 SPI 版本的 MCP23S*xx* GPIO 扩展器使用。 |'
- en: '| 2 | 0 | ODR | Open drain control. If ODR = 1, then the INT*x* pins are open-drain
    outputs. If ODR = 0, then the INT*x* pins are active logic outputs. See section
    13.5.5, “Enabling Interrupts on the MCP230*xx*” for more information. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0 | ODR | 开漏控制。如果 ODR = 1，则 INT*x* 引脚为开漏输出。如果 ODR = 0，则 INT*x* 引脚为活动逻辑输出。有关更多信息，请参阅第
    13.5.5 节，“启用 MCP230*xx* 的中断”。 |'
- en: '| 1 | 0 | INTPOL | Sets the polarity of the INT pins. If INTPOL = 0, then the
    INT*x* pins are active low. If INTPOL = 1, then the INT*x* pins are active high.
    This bit sets the polarity only if ODR = 0\. See section 13.5.4, “Open-Drain INT*x*
    Output,” for more information. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | INTPOL | 设置 INT 引脚的极性。如果 INTPOL = 0，则 INT*x* 引脚为低电平有效。如果 INTPOL =
    1，则 INT*x* 引脚为高电平有效。仅当 ODR = 0 时，此位设置极性。有关更多信息，请参阅第 13.5.4 节，“开漏 INT*x* 输出”。 |'
- en: '| 0 | 0 | N/A | Not used. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | N/A | 未使用。 |'
- en: If you decide you want to initialize the MCP230*xx* with something other than
    the default value, you will need to write an appropriate value to the IOCON register.
    Do so immediately after your program begins execution. While it is possible to
    change the configuration during execution, this is rare; most of the time you’ll
    configure the MCP230*xx* once and then not touch the register thereafter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定将 MCP230*xx* 初始化为非默认值，你需要将适当的值写入 IOCON 寄存器。此操作应在程序开始执行后立即进行。虽然在执行过程中更改配置是可能的，但这种情况较为少见；大多数情况下，你只需配置一次
    MCP230*xx*，然后就不会再更改该寄存器。
- en: 'To program the IOCON register, you will need to write 3 bytes to the I²C bus
    (see [Figure 13-3](#figure13-3)):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要编程 IOCON 寄存器，你需要向 I²C 总线写入 3 个字节（参见[图 13-3](#figure13-3)）：
- en: Put a start condition on the I²C bus.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 I²C 总线上放置启动条件。
- en: Write the device address (0x40 to 0x46) with the LO bit set to 0 (write operation).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入设备地址（0x40 到 0x46），并将 LO 位设置为 0（写操作）。
- en: Write the IOCON register number 0x0A (or 0x05, if using alternate register numbers)
    to the bus.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 IOCON 寄存器号 0x0A（或者如果使用备用寄存器号则为 0x05）写入总线。
- en: Write the new IOCON register value to the I²C bus.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的 IOCON 寄存器值写入 I²C 总线。
- en: Put a stop condition on the I²C bus.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 I²C 总线上放置停止条件。
- en: '![](image_fi/502468c13/f13003.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c13/f13003.png)'
- en: 'Figure 13-3: Example IOCON initialization sequence'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-3：IOC初始化示例序列
- en: On power-up or after a reset operation, the register addresses default to the
    standard register numbers. If you intend to use the alternate register numbers,
    you must write an IOCON value with bit 7 equal to 1 to address 0x0A, the power-on/reset
    IOCON address. After that, any writes to IOCON must happen at register number
    0x05.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上电或复位操作后，寄存器地址默认采用标准寄存器号。如果你打算使用备用寄存器号，你必须将 IOCON 寄存器的位 7 设置为 1，写入地址 0x0A，这是上电/复位后的
    IOCON 地址。之后，所有对 IOCON 的写操作必须发生在寄存器号 0x05。
- en: Note that if external hardware can reset the MCP230*xx*, then the IOCON register
    will switch back to address 0x0A. This can be a problem if the software isn’t
    aware that the reset operation took place. This is a good argument for leaving
    the MCP230*xx* in standard register number mode.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果外部硬件能够复位 MCP230*xx*，那么 IOCON 寄存器将切换回地址 0x0A。如果软件没有意识到复位操作已发生，可能会造成问题。因此，保持
    MCP230*xx* 在标准寄存器号模式下是一种较好的选择。
- en: 13.2.3 Programming the Data Direction
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.3 编程数据方向
- en: The GPIO pins on the MCP230*xx* are individually programmable as inputs or outputs.
    The *data direction registers (DDRs)* control the input or output state of each
    pin. The MCP23008 has a single (8-bit) IODIR (register 0), and the MCP23017 has
    two (IODIRA is register 0, and IODIRB is register 1 or 16).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: MCP230*xx* 的 GPIO 引脚可以单独编程为输入或输出。*数据方向寄存器（DDRs）* 控制每个引脚的输入或输出状态。MCP23008 具有一个（8
    位）IODIR（寄存器 0），而 MCP23017 有两个（IODIRA 是寄存器 0，IODIRB 是寄存器 1 或 16）。
- en: Each bit position in an IODIR*x* register controls the I/O state of the corresponding
    GPIO pin. That is, bit 0 in IODIRA (IODIR on the MCP23008) controls GPA0, bit
    1 in IODIRA controls GPA1, and so on. Likewise, bit 0 in IODIRB controls GPB0,
    bit 1 controls GPB1, and so on. A 1 in a given bit position programs the corresponding
    GPIO pin as an input; a 0 in the bit position programs the corresponding GPIO
    pin as an output.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: IODIR*x* 寄存器中的每个位位置控制相应 GPIO 引脚的 I/O 状态。也就是说，IODIRA 中的位 0（MCP23008 上的 IODIR）控制
    GPA0，位 1 控制 GPA1，以此类推。同样，IODIRB 中的位 0 控制 GPB0，位 1 控制 GPB1，以此类推。某个位位置上的 1 将该引脚配置为输入；该位位置上的
    0 将该引脚配置为输出。
- en: When the MCP230*xx* powers up or when the reset line is brought low, the IC
    programs all GPIO pins as inputs (that is, it initializes the IODIR*x* registers
    with all 1 bits). This is the safest initial configuration, as it prevents programming
    a GPIO pin as an output, which might produce an electrical conflict if that pin
    is connected to a line with an active signal.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当 MCP230*xx* 上电或复位引脚被拉低时，IC 会将所有 GPIO 引脚配置为输入（即，它会将 IODIR*x* 寄存器初始化为全 1 位）。这是最安全的初始配置，因为它可以防止将
    GPIO 引脚配置为输出，如果该引脚连接到带有活动信号的线路，可能会导致电气冲突。
- en: Because of the MCP230*xx*’s IODIR flexibility, you can program arbitrary bits
    as inputs or outputs. In practice, it’s most convenient (at least on the MCP23017)
    to program each bank of 8 bits as either all inputs or all outputs. Doing so makes
    it more convenient to program the MCP230*xx* ICs. Of course, if your hardware
    design requires that you mix and match I/O directions on a single port, that’s
    perfectly acceptable; the cost is slightly more complex programming requirements.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MCP230*xx* 的 IODIR 灵活性，你可以将任意位编程为输入或输出。实际上，最方便的做法（至少在 MCP23017 上）是将每个 8 位的组配置为所有输入或所有输出。这样可以更方便地编程
    MCP230*xx* 芯片。当然，如果你的硬件设计要求在单一端口上混合使用输入和输出方向，那也是完全可以接受的；代价是稍微复杂一些的编程要求。
- en: To send the data direction value to the MCP230*xx* ICs, transmit the sequence
    shown in [Figure 13-4](#figure13-4).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据方向值发送到 MCP230*xx* 芯片，传输[图 13-4](#figure13-4)中显示的序列。
- en: '![](image_fi/502468c13/f13004.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c13/f13004.png)'
- en: 'Figure 13-4: IODIR*x* initialization sequence'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-4：IODIR*x* 初始化序列
- en: The third byte of the sequence appearing in [Figure 13-4](#figure13-4) is the
    data direction initialization value.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在[图 13-4](#figure13-4)中的序列的第三个字节是数据方向初始化值。
- en: 13.2.4 Programming Input Pullup Resistors
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.4 编程输入上拉电阻
- en: 'Input pins on the MCP230*xx* are often connected to *dry contact inputs*: switches,
    relay contacts, or other devices that connect two different signal lines. A typical
    dry contact might be a push button, DIP switch, or other SPST switch or relay.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: MCP230*xx* 的输入引脚通常连接到*干接点输入*：开关、继电器触点或其他连接两个不同信号线的设备。典型的干接点可能是一个按钮、DIP 开关或其他单极单掷开关（SPST）或继电器。
- en: Usually, a dry contact will connect an input pin on an MCP230*xx* to ground.
    Closing the contact shunts the input to ground so that a 0 input value appears
    on the corresponding bit in the GPIO*x* register. When the contact is open, the
    input signal *floats*, which is never good; the electronics might interpret a
    floating input as either a logic 0 or 1\. To avoid floating inputs, designers
    typically put a pullup resistor on the input pin. This raises the voltage pin
    to the voltage connected to the pullup resistor (typically Vdd) when the dry contact
    is in the open position. When the dry contact is in the closed position, this
    shunts the input to ground, providing a logic 0 input.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，干接点会将 MCP230*xx* 上的输入引脚连接到地。当接点闭合时，输入被短接到地，导致对应的 GPIO*x* 寄存器中的位显示 0 输入值。当接点打开时，输入信号*浮空*，这通常是不好的；电子设备可能将浮空输入解读为逻辑
    0 或 1。为了避免浮空输入，设计人员通常会在输入引脚上加上拉电阻。当干接点处于开路位置时，这会将电压引脚拉至上拉电阻连接的电压（通常是 Vdd）。当干接点闭合时，这会将输入引脚短接到地，从而提供逻辑
    0 输入。
- en: The only problem with pullup resistors is that you’ll need to find space for
    them on a printed circuit or prototype board, as well as time and energy to install
    them. For convenience, the MCP230*xx* parts provide *programmable pullup resistors*
    that allow you to programmatically enable or disable pullup resistors on input
    pins. The GPPU*x* registers provide this capability. Programming a GPPU*x* bit
    with a 1 (and programming that same bit position in IODIR*x* with a 1) will connect
    a 100-kΩ pullup resistor to that pin. Conversely, programming a 0 bit disconnects
    the pullup resistor.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上拉电阻唯一的问题是，你需要在印刷电路板或原型板上为其腾出空间，并花费时间和精力进行安装。为方便起见，MCP230*xx* 部件提供了*可编程上拉电阻*，允许你通过编程启用或禁用输入引脚上的上拉电阻。GPPU*x*
    寄存器提供了这一功能。将 GPPU*x* 位编程为 1（并将相同的位在 IODIR*x* 中编程为 1）会将一个 100-kΩ 上拉电阻连接到该引脚。相反，编程为
    0 会断开上拉电阻。
- en: You should program only pullup resistors on GPIO pins connected to dry contact
    inputs. If a logic-level signal connects to a GPIO pin, programming a pullup resistor
    on that same pin might damage the MCP230*xx* or the logic device at the other
    end of the connection. Even if it doesn’t damage the electronics, it could interfere
    with the input signal.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该只在连接到干接点输入的 GPIO 引脚上编程上拉电阻。如果一个逻辑电平信号连接到一个 GPIO 引脚，编程该引脚的上拉电阻可能会损坏 MCP230*xx*
    或连接另一端的逻辑设备。即使它不损坏电子元件，它也可能干扰输入信号。
- en: To set the pullup value on the MCP230*xx* ICs, transmit the sequence shown in
    [Figure 13-5](#figure13-5).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 MCP230*xx* 芯片上设置上拉值，传输[图 13-5](#figure13-5)中显示的序列。
- en: '![](image_fi/502468c13/f13005.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c13/f13005.png)'
- en: 'Figure 13-5: GPPU*x* pullup initialization'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-5：GPPU*x* 上拉初始化
- en: The last byte in the sequence in [Figure 13-5](#figure13-5) is the bitmap value
    for the pullup initialization.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图13-5](#figure13-5)中出现的序列中的最后一个字节是上拉初始化的位图值。
- en: 13.2.5 Programming the Input Polarity
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.5 编程输入极性
- en: If you’ve been reading closely, you may have noticed that reading a dry contact
    switch with a pullup resistor in the previous section produced a 0 input when
    the switch was closed (pressed) and a 1 input when the switch was open (unpressed).
    This logic, *active low logic*, is opposite of what you might expect in software.
    Intuition suggests you should get a logic 1 when you press (close) the switch
    and a logic 0 when you release (open) it—that is, you expect *active* *high logic*.
    Although it is easy enough to invert the signal once you’ve read it from the GPIO
    pin, the MCP230*xx* devices provide a special *polarity register* that lets you
    select active high or active low logic signals.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细阅读，可能会注意到，在上一节中使用上拉电阻读取干触点开关时，当开关关闭（按下）时输入为0，当开关打开（释放）时输入为1。这种逻辑，*低电平有效逻辑*，与你在软件中可能期望的相反。直觉上，你可能会认为按下（关闭）开关时应获得逻辑1，而释放（打开）开关时应获得逻辑0——也就是，你期望的是*高电平有效逻辑*。虽然从GPIO引脚读取信号后反转它非常简单，但MCP230*xx*设备提供了一个特殊的*极性寄存器*，允许你选择高电平有效或低电平有效逻辑信号。
- en: The MCP23008 IPOL and the MCP23017 IPOLA and IPOLB registers let you control
    the polarity of an input pin. If a bit in IPOL*x* is 0, then the corresponding
    bit in the GPIO*x* register will reflect the current state of the input pin. If
    a bit in IPOL*x* is 1, then the corresponding bit in GPIO*x* will reflect the
    inverted state of the input pin.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: MCP23008的IPOL寄存器以及MCP23017的IPOLA和IPOLB寄存器让你控制输入引脚的极性。如果IPOL*x*中的某个位为0，则GPIO*x*寄存器中的相应位将反映输入引脚的当前状态。如果IPOL*x*中的某个位为1，则GPIO*x*中的相应位将反映输入引脚的反向状态。
- en: If an actual input is active low but you want to read it as though it were active
    high, simply program the corresponding bit in IPOL*x* with a 1 to invert the signal
    when you read it. Inverting dry contacts, for example, makes them active high
    inputs so that their logic matches logic-level input signals.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个实际的输入是低电平有效，但你希望将其读取为高电平有效，只需将IPOL*x*中的相应位编程为1，这样在读取时就会反转信号。例如，反转干触点使其变为高电平有效输入，从而使其逻辑与逻辑电平输入信号匹配。
- en: To set the input pin polarities on the MCP230*xx* ICs, transmit the sequence
    shown in [Figure 13-6](#figure13-6).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置MCP230*xx* ICs上的输入引脚极性，传输[图13-6](#figure13-6)中所示的序列。
- en: '![](image_fi/502468c13/f13006.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c13/f13006.png)'
- en: 'Figure 13-6: IPOL*x* input pin polarity sequence'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-6：IPOL*x*输入引脚极性序列
- en: The third byte in the sequence appearing in [Figure 13-6](#figure13-6) is the
    polarity initialization value.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图13-6](#figure13-6)中出现的序列中的第三个字节是极性初始化值。
- en: 13.2.6 Sequential Register Operations
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.6 顺序寄存器操作
- en: 'Reading or writing a register value on the MCP230*xx* requires a minimum of
    three 1-byte transmissions on the I²C bus: an I²C address byte, a register number,
    and a data transmission to or from the register. Because I²C transmissions are
    relatively slow (especially when operating at 100 kHz), the MCP230*xx* provides
    a special *sequential register access mode* to reduce the number of I²C bus transactions.
    The SEQOP bit in IOCON (bit 5) controls this mode. If SEQOP contains 0, then the
    MCP230*xx* automatically increments the register number after each data transmission
    and reception on the I²C bus. If SEQOP contains 1, then the MCP230*xx* disables
    the autoincrement mode.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在MCP230*xx*上读取或写入寄存器值至少需要三次1字节的I²C总线传输：一个I²C地址字节，一个寄存器号，以及与寄存器的数据传输。由于I²C传输相对较慢（特别是在100
    kHz下操作时），MCP230*xx*提供了一个特殊的*顺序寄存器访问模式*，以减少I²C总线事务的数量。IOCON中的SEQOP位（位5）控制此模式。如果SEQOP为0，则MCP230*xx*会在每次I²C总线的数据传输和接收后自动递增寄存器号。如果SEQOP为1，则MCP230*xx*会禁用自动增量模式。
- en: When the autoincrement mode is active, the controller device can read or write
    multiple data bytes after transmitting a single pair of I²C address and register
    bytes. As long as the controller device does not put a stop condition on the bus,
    successive clock pulses on SCL will continue to read or write successive registers
    on the MCP230*xx*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当自动增量模式处于激活状态时，控制器设备可以在传输一对I²C地址字节和寄存器字节后，读取或写入多个数据字节。只要控制器设备没有在总线上设置停止条件，SCL上的连续时钟脉冲将继续读取或写入MCP230*xx*上的连续寄存器。
- en: 'This autoincrement feature is especially useful on the MCP23017 when the registers
    are in standard (non-banked) mode. In standard mode, the port A and port B registers
    appear in successive locations. This allows you to successively read and write
    registers from both ports as a 16-bit operation. For example, if you want to initialize
    IODIRA and IODIRB at the same time, you would use the following sequence (assuming
    SEQOP is 0, which is the power-on/reset condition):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动递增特性在 MCP23017 的标准模式（非分组模式）下尤其有用。在标准模式下，端口 A 和端口 B 寄存器出现在连续的位置。这使得你能够连续地从两个端口读取和写入寄存器，作为一个
    16 位操作。例如，如果你希望同时初始化 IODIRA 和 IODIRB，你可以使用以下序列（假设 SEQOP 为 0，这是上电/复位条件）：
- en: Place the start condition on the I²C bus.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 I²C 总线上放置启动条件。
- en: Write the address to the I²C bus (0x40 to 0x46) with the LO bit 0 (for write).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 I²C 总线写入地址（0x40 至 0x46），LO 位为 0（用于写入）。
- en: Write 0 to the I²C bus (IODIRA register address).
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 I²C 总线写入 0（IODIRA 寄存器地址）。
- en: Write the data direction bits for IODIRA to the I²C bus.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 I²C 总线写入 IODIRA 的数据方向位。
- en: Write the data direction bits for IODIRB to the I²C bus.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 I²C 总线写入 IODIRB 的数据方向位。
- en: Place the stop condition on the I²C bus.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 I²C 总线上放置停止条件。
- en: Between steps 4 and 5 in this sequence, the MCP23017 automatically incremented
    the register number so that step 5 writes the data direction bits to register
    one (IODIRB), as shown in [Figure 13-7](#figure13-7).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段顺序的第 4 步和第 5 步之间，MCP23017 会自动递增寄存器号，从而使第 5 步将数据方向位写入寄存器 1（IODIRB），如 [图 13-7](#figure13-7)
    所示。
- en: '![](image_fi/502468c13/f13007.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c13/f13007.png)'
- en: 'Figure 13-7: Autoincrementing register numbers'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-7：自动递增寄存器号
- en: This sequence requires writing only 4 bytes to the I²C bus. This is two less
    than the 6 bytes that would have been required to individually write to the IODIRA
    and IODIRB registers using independent transactions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列仅需要向 I²C 总线写入 4 个字节。这比使用独立事务分别写入 IODIRA 和 IODIRB 寄存器所需的 6 个字节少了 2 个字节。
- en: 'You’re not limited to writing just two values using the autoincrement mode.
    You could, for example, write the direction and polarity initialization values
    all at once:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动递增模式时，你并不限于只写入两个值。例如，你可以一次性写入方向和极性初始化值：
- en: Place the start condition on the I²C bus.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 I²C 总线上放置启动条件。
- en: Write the address to the I²C bus (0x40 to 0x46) with the LO bit 0 (for write).
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 I²C 总线写入地址（0x40 至 0x46），LO 位为 0（用于写入）。
- en: Write 0 to the I²C bus (IODIRA register address).
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 I²C 总线写入 0（IODIRA 寄存器地址）。
- en: Write the data direction bits for IODIRA to the I²C bus.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 I²C 总线写入 IODIRA 的数据方向位。
- en: Write the data direction bits for IODIRB to the I²C bus.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 I²C 总线写入 IODIRB 的数据方向位。
- en: Write the polarity bits for IPOLA to the I²C bus.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 I²C 总线写入 IPOLA 的极性位。
- en: Write the polarity bits for IPOLB to the I²C bus.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 I²C 总线写入 IPOLB 的极性位。
- en: Place the stop condition on the I²C bus.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 I²C 总线上放置停止条件。
- en: In theory, you could also write interrupt initialization values in this sequence,
    though it’s uncommon to use all the interrupt initialization features, so sequential
    writing isn’t always possible. Sadly, the pullup registers don’t appear sequentially
    in a common initialization list, so you wind up having to write their address
    and register values independently.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，你也可以在这个序列中写入中断初始化值，尽管很少使用所有的中断初始化特性，所以并非总能顺利进行顺序写入。遗憾的是，拉高寄存器在常见的初始化列表中并不会顺序出现，因此你最终不得不独立地写入它们的地址和寄存器值。
- en: Of course, you’re unlikely to write the initialization bits more often than
    once in a typical application, so the savings for a single initialization won’t
    be that great. However, it is common to read all 16 input bits from the MCP23017
    or to write all 16 output bits. The autoincrement mode is useful for those operations,
    which occur frequently in common applications.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在典型的应用中，你不太可能每次都写初始化的代码，所以单次初始化所带来的节省不会太大。然而，通常会从 MCP23017 读取所有 16 位输入数据，或者写入所有
    16 位输出数据。自动递增模式对这些操作非常有用，因为它们在常见应用中频繁发生。
- en: 'Register autoincrement mode is not always useful, though. Perhaps you want
    to quickly write the GPIO, GPIOA, or GPIOB register to put some waveform onto
    the output pins, and you:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，寄存器自动递增模式并非总是有用的。也许你想快速写入 GPIO、GPIOA 或 GPIOB 寄存器，将某些波形输出到输出引脚，这时你：
- en: Put a start condition on the bus.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在总线上放置启动条件。
- en: Write the I²C address to the bus with the LO (read) bit equal to 1.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向总线写入 I²C 地址，且 LO（读取）位等于 1。
- en: Write the register number to the bus (for example, 12/0xC for GPIOA).
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向总线写入寄存器号（例如，GPIOA 的值为 12/0xC）。
- en: Write a byte to the bus.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向总线写入一个字节。
- en: Repeat step 4 for each different value to be written to the output pins.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个不同的值，重复步骤 4，以便写入输出引脚。
- en: Place a stop condition on the bus.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在总线上放置停止条件。
- en: This code would require SEQOP to be set to 1 to disable autoincrementing the
    register number after step 4.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码需要将 SEQOP 设置为 1，以禁用在步骤 4 后自动递增寄存器编号。
- en: You’ll have to decide whether it’s better to operate with the autoincrement
    feature turned on or off (by default) in your code. If you’re constantly switching
    between the two modes, it may be more efficient just to operate in non-autoincrement
    mode.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要决定在代码中开启还是关闭自动递增功能更为合适。如果你经常在两种模式之间切换，那么在非自动递增模式下操作可能会更高效。
- en: 13.2.7 Slew Rate Control
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.7 跃变率控制
- en: Bit 4 of the IOCON register (DISSLW) controls the I²C SDA slew rate. When enabled
    (0), the slew rate control reduces the speed at which the SDA line rises from
    low to high or falls from high to low (see [Figure 13-8](#figure13-8)). By default,
    this bit is 0, which reduces the signal’s rise and fall time.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: IOCON 寄存器的第 4 位（DISSLW）控制 I²C SDA 跃变率。当启用时（0），跃变率控制减少 SDA 线从低到高或从高到低的上升或下降速度（参见
    [图 13-8](#figure13-8)）。默认情况下，此位为 0，减少信号的上升和下降时间。
- en: '![](image_fi/502468c13/f13008.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c13/f13008.png)'
- en: 'Figure 13-8: Slew rate'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-8：跃变率
- en: Reducing the slew rate can reduce noise (due to *ringing*, noise caused by the
    signal temporarily bouncing up and down after a change) on the SDA line. However,
    at higher speeds, reducing the slew rate can introduce errors on its own. You
    would typically enable slew rate control at 100 kHz and disable it at 1 MHz. At
    400 kHz, you would enable it or disable it as necessary, depending on the signal
    noise, which you would have to verify with an oscilloscope. As the MCP230*xx*
    devices enable slew rate control by default, you should turn it off only if there
    are noise problems in your system.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 降低跃变率可以减少 SDA 线上的噪声（由*振铃*引起，振铃是信号在变化后暂时上下跳动的现象）。然而，在更高的速度下，降低跃变率可能会引入错误。通常，在
    100 kHz 时启用跃变率控制，而在 1 MHz 时禁用。在 400 kHz 时，根据信号噪声的情况决定是否启用或禁用跃变率控制，这需要使用示波器进行验证。由于
    MCP230*xx* 设备默认启用跃变率控制，因此只有在系统存在噪声问题时，才应关闭它。
- en: '*13.2.8* Reading General-Purpose Input/Output Pins on the MCP230*xx*'
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*13.2.8* 读取 MCP230*xx* 上的通用输入/输出引脚'
- en: Reading the GPIO*x* register(s) on the MCP230*xx* is probably the most common
    software activity. Reading these registers returns the current state of the GPA*x*
    and GPB*x* pins. If the pins were programmed as output, then reading the GPIO*x*
    registers returns the last value written (or default reset state) to the output
    pins, which is the current state of those pins.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 读取 MCP230*xx* 的 GPIO*x* 寄存器是最常见的软件操作之一。读取这些寄存器会返回 GPA*x* 和 GPB*x* 引脚的当前状态。如果这些引脚被配置为输出，那么读取
    GPIO*x* 寄存器将返回最后写入的值（或默认重置状态）到输出引脚，也就是这些引脚的当前状态。
- en: 'Reading data from the GPIO*x* registers requires two I²C bus transactions.
    First, write the GPIO*x* register address, and second, read the register value(s):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从 GPIO*x* 寄存器读取数据需要两次 I²C 总线事务。首先，写入 GPIO*x* 寄存器地址；其次，读取寄存器值：
- en: Place a start condition on the I²C bus.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 I²C 总线上放置启动条件。
- en: Write the device address with the LO bit 0 (write operation).
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将设备地址和 LO 位 0（写入操作）写入 I²C 总线。
- en: Write the GPIO, GPIOA, or GPIOB register address (GPIO = 9 on MCP23008, GPIOA
    = 9 or 0x12, and GPIOB = 0x19 or 0x13 on MCP23017).
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入 GPIO、GPIOA 或 GPIOB 寄存器地址（在 MCP23008 上，GPIO = 9；在 MCP23017 上，GPIOA = 9 或 0x12，GPIOB
    = 0x19 或 0x13）。
- en: Place a (repeated) start condition on the I²C bus.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 I²C 总线上放置（重复的）启动条件。
- en: Write the device address with the LO bit 1 (read operation) to the I²C bus.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将设备地址和 LO 位 1（读取操作）写入 I²C 总线。
- en: Read the GPIO bits from the I²C bus.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 I²C 总线读取 GPIO 位。
- en: (optional on MCP23017) Read the second set of GPIO bits (GPIOB) from the I²C
    bus (see [Figure 13-9](#figure13-9)).
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （在 MCP23017 上可选）从 I²C 总线读取第二组 GPIO 位（GPIOB）（参见 [图 13-9](#figure13-9)）。
- en: Place a stop condition on the bus.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在总线上放置停止条件。
- en: Step 7 assumes SEQOP bit in IOCON is 0 and the register address written in step
    3 was GPIOA (address 0x12 in standard mode).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 步假设 IOCON 中的 SEQOP 位为 0，且步骤 3 中写入的寄存器地址为 GPIOA（在标准模式下地址为 0x12）。
- en: '![](image_fi/502468c13/f13009.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c13/f13009.png)'
- en: 'Figure 13-9: GPIO sequential read operation'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-9：GPIO 顺序读取操作
- en: Note that if SEQOP in IOCON has been programmed as a 1 (no autoincrementing
    register address), then you can reread the GPIO*x* bits over and over again.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果 IOCON 中的 SEQOP 已被设置为 1（没有自动递增的寄存器地址），那么你可以反复读取 GPIO*x* 位。
- en: '*13.3* Writing General-Purpose Input/Output Pins on the MCP230*xx*'
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*13.3* 写入 MCP230*xx* 的通用输入/输出引脚'
- en: 'There are two ways to write data to output pins on the MCP230*xx*: write the
    data to the GPIO*x* register(s) or write the data to the OLAT*x* register(s).
    Writing to either set of registers will place the output data on the output pins.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以将数据写入 MCP230*xx* 的输出引脚：将数据写入 GPIO*x* 寄存器或将数据写入 OLAT*x* 寄存器。写入任何一个寄存器集合都会将输出数据放置到输出引脚上。
- en: For output purposes, there is no real difference between writing to the GPIO*x*
    and OLAT*x* registers. Internally, the MCP230*xx* converts a write to GPIO*x*
    into a write to OLAT*x*. The two register sets differ when you read from them.
    Reading from GPIO*x*, of course, reads the current state of the GPA*n* and GPB*n*
    input pins. Reading from OLAT*x* returns the last value written to the OLAT*x*
    (or GPIO*x*) registers. This will produce differing results if any pins were programmed
    as inputs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输出目的，写入 GPIO*x* 和 OLAT*x* 寄存器之间没有实际区别。内部上，MCP230*xx* 将写入 GPIO*x* 转换为写入 OLAT*x*。当你从这些寄存器读取时，它们有所不同。从
    GPIO*x* 读取时，当然是读取 GPA*n* 和 GPB*n* 输入引脚的当前状态。从 OLAT*x* 读取时，会返回最后写入 OLAT*x*（或 GPIO*x*）寄存器的值。如果任何引脚被编程为输入，这将产生不同的结果。
- en: 'Writing to the OLAT*x* (or GPIO*x*) registers is slightly less complex than
    reading from the GPIO*x* registers. Here are the steps:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 写入 OLAT*x*（或 GPIO*x*）寄存器的复杂度略低于从 GPIO*x* 寄存器读取的复杂度。以下是步骤：
- en: Place a start condition on the I²C bus.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 I²C 总线上放置一个起始条件。
- en: Write the device address with the LO bit 0 (write operation).
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入带有 LO 位 0（写入操作）的设备地址。
- en: Write the OLAT, OLATA, or OLATB register address (OLAT = 0xA on MCP23008, OLATA
    = 0xA or 0x14, and OLATB = 0x1A or 0x15 on MCP23017).
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入 OLAT、OLATA 或 OLATB 寄存器地址（MCP23008 上 OLAT = 0xA，OLATA = 0xA 或 0x14，OLATB =
    0x1A 或 0x15 在 MCP23017 上）。
- en: Write the OLAT bits to the I²C bus.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 OLAT 位写入 I²C 总线。
- en: Write the second set of OLAT bits (OLATB) to the I²C bus (see [Figure 13-10](#figure13-10)).
    This is optional on MCP23017 (SEQOP = 0, only).
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第二组 OLAT 位（OLATB）写入 I²C 总线（见[图 13-10](#figure13-10)）。在 MCP23017 上这是可选的（仅当 SEQOP
    = 0 时）。
- en: Place a stop condition on the bus.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在总线上放置一个停止条件。
- en: This sequence is less complex than reading because you don’t have to do a repeated
    start condition and write a second device address to the bus.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程比读取更简单，因为你不需要重复开始条件，也不需要将第二个设备地址写入总线。
- en: '![](image_fi/502468c13/f13010.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c13/f13010.png)'
- en: 'Figure 13-10: GPIO (OLAT) 16-bit sequential write operation'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-10：GPIO（OLAT）16 位顺序写入操作
- en: Note that the output pins on the MCP230*xx* ICs are not capable of driving much
    current. Each pin is capable of sourcing or sinking 25 mA—barely enough to light
    an LED. The entire package is further limited to 150 mA, meaning you cannot connect
    16 LEDs and run them all at 25 mA. To handle more current, you will need to connect
    a transistor or other current amplifier to the output pin. The ULN2308 Darlington
    array—8 Darlington amplifiers in an 18-pin package, each capable of sinking 500
    mA—is a perfect device for this purpose.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，MCP230*xx* IC 上的输出引脚无法驱动太多电流。每个引脚最多可以源或吸收 25 毫安——勉强足够点亮一个 LED。整个封装的最大电流限制为
    150 毫安，这意味着你不能连接 16 个 LED 并以每个 25 毫安的电流运行它们。为了处理更多的电流，你需要将一个晶体管或其他电流放大器连接到输出引脚。ULN2308
    达林顿阵列——在一个 18 引脚封装中的 8 个达林顿放大器，每个能够吸收 500 毫安——是一个非常适合此目的的设备。
- en: 13.4 Demonstrating Input/Output on an MCP23017
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 演示 MCP23017 的输入/输出
- en: By now you’ve learned enough to actually program the MCP230*xx* devices in polled
    (non-interrupt) mode. The sample Arduino program in this section writes some output
    data to port B on an MCP23017 and reads this data from port A on the same device.
    This program is relatively trivial in terms of functionality, but it demonstrates
    most of what you need to program the device.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经学到了足够的知识，能够实际编程 MCP230*xx* 设备以轮询（非中断）模式运行。本节中的示例 Arduino 程序将一些输出数据写入
    MCP23017 的端口 B，并从同一设备的端口 A 读取这些数据。这个程序在功能上相对简单，但它展示了编程该设备所需的大部分内容。
- en: The program uses the circuit shown in [Figure 13-11](#figure13-11). The SDA
    and SCL lines on the MCP23017 are wired to the corresponding pins on an Arduino
    Uno Rev3 (or other Arduino-compatible device). Pins A0, A1, and A2 are wired to
    Gnd, so the 7-bit device address will be 0x20\. The reset pin is wired to +5 V
    or +3.3 V, depending on whether you’re running a 3.3-V or 5.0-V system. The port
    A pins are wired to the reversed port B pins. Finally, if your SBC does not provide
    appropriate pullup resistors on the SDA and SCL lines, you will need to put a
    pair of 4.7-kΩ resistors between these two lines and Vdd (+5 V or +3.3 V).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用了[图 13-11](#figure13-11)中所示的电路。MCP23017 的 SDA 和 SCL 线路接到 Arduino Uno Rev3（或其他兼容
    Arduino 的设备）上的相应引脚。引脚 A0、A1 和 A2 接地，因此 7 位设备地址将是 0x20。复位引脚接到 +5 V 或 +3.3 V，具体取决于你运行的是
    3.3 V 还是 5.0 V 系统。端口 A 引脚接到反向的端口 B 引脚。最后，如果你的 SBC 没有在 SDA 和 SCL 线路上提供适当的上拉电阻，你需要在这两条线路与
    Vdd（+5 V 或 +3.3 V）之间放置一对 4.7-kΩ 电阻。
- en: '![](image_fi/502468c13/f13011.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c13/f13011.png)'
- en: 'Figure 13-11: Simple wiring example for the program in [Listing 13-1](#listing13-1)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-11：程序的简单接线示例，见[列表 13-1](#listing13-1)
- en: Note in [Figure 13-11](#figure13-11) that GPB0 is connected to GPA7, GPB1 is
    connected to GPA6, . . . , and GPB7 is connected to GPA0\. So the output bits
    will be reversed when read as inputs. This was done to simplify wiring; the bit
    reversal can be fixed in software.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在[图 13-11](#figure13-11)中，GPB0 连接到 GPA7，GPB1 连接到 GPA6，依此类推，GPB7 连接到 GPA0。所以，当作为输入读取时，输出位会反转。这是为了简化接线；位反转可以通过软件修正。
- en: The program in does not use interrupts, so you can leave the INTA and INTB pins
    floating. Also, don’t forget to wire the Vdd (pin 9) and Vss (pin 10) pins to
    +5 V (or +3.3 V) and Gnd, respectively.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序未使用中断，因此可以将 INTA 和 INTB 引脚悬空。另外，别忘了将 Vdd（引脚 9）和 Vss（引脚 10）引脚分别连接到 +5 V（或
    +3.3 V）和接地。
- en: '[PRE0]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `setup()` function initializes the MCP23017 device as appropriate for this
    sample program. Most importantly, it initializes port A pins as inputs and port
    B pins as outputs. It also disables the pullup resistors on the port A input pins,
    because port B is connected directly to port A, and port B’s pins provide TTL
    (5-V) signals.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()` 函数根据此示例程序的需要初始化 MCP23017 设备。最重要的是，它将端口 A 引脚初始化为输入，端口 B 引脚初始化为输出。它还禁用了端口
    A 输入引脚的上拉电阻，因为端口 B 直接连接到端口 A，且端口 B 的引脚提供 TTL（5 V）信号。'
- en: The `loop()` function simply writes a sequence of byte values to port B, reads
    a byte value from port A, and verifies that the value read is equal (with bit
    reversal due to wiring) to the value that was written (to port B). This function
    prints an error message to the serial port if the two values do not match.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop()` 函数简单地将一系列字节值写入端口 B，从端口 A 读取一个字节值，并验证读取的值是否与写入的值（由于接线原因，进行位反转）相等。如果两个值不匹配，该函数会向串口输出错误信息。'
- en: 13.5 Interrupts on the MCP230*xx*
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5 MCP230*xx* 上的中断
- en: Most programmers using the MCP230*xx* on an Arduino system don’t bother using
    the interrupt facilities on those devices. It’s often less work to simply poll
    the device to determine if any input bits have changed rather than to create an
    ISR and program the interrupts on the MCP230*xx*. If you’re programming a system
    that can poll the MCP230*xx* at a sufficiently high frequency without impacting
    the performance of other activities on your system, polling is a reasonable approach.
    However, if real-time concerns mean polling is not an option, the interrupt facilities
    on the MCP230*xx* can be a lifesaver.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数使用 MCP230*xx* 的 Arduino 编程人员并不使用这些设备上的中断功能。通常轮询设备，查看是否有输入位发生变化，比创建中断服务例程（ISR）并编程中断要少做些工作。如果你编程的系统能够在不影响其他活动性能的情况下以足够高的频率轮询
    MCP230*xx*，那么轮询是一种合理的方法。然而，如果实时性问题使得轮询不可行，那么 MCP230*xx* 上的中断功能可以是一个救命稻草。
- en: 13.5.1 Interrupt Actions on the MCP230*xx*
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.1 MCP230*xx* 上的中断操作
- en: The program in [Listing 13-1](#listing13-1) continuously wrote and read data.
    Because this program was responsible for both writing the data (to port B) and
    reading the data (at port A), the application always knows when data will be available
    on port A (specifically, data will be available immediately after the `loop()`
    function writes the data to port B). In the majority of real-world systems, the
    incoming data usually comes from some external hardware, and the `loop()` function
    wouldn’t intrinsically know when new data has arrived on port A. One solution
    might be to have the `loop()` function continuously read port A and compare the
    value read against the previous reading. When the two values are different, the
    function can assume that external hardware has transmitted a new value and deal
    with it appropriately. This scheme is known as *polling*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-1](#listing13-1) 中的程序持续进行数据的读写。因为这个程序既负责写入数据（到端口 B），也负责读取数据（从端口 A），所以应用程序始终知道何时端口
    A 上的数据将可用（具体来说，数据会在 `loop()` 函数将数据写入端口 B 后立即可用）。在大多数实际系统中，输入数据通常来自一些外部硬件，`loop()`
    函数本身无法知道端口 A 上何时有新数据到达。一种解决方案是让 `loop()` 函数持续读取端口 A，并将读取的值与之前的读取值进行比较。当两个值不同时，函数可以假设外部硬件已经传输了新值，并适当处理它。这种方案称为
    *轮询*。'
- en: One problem with polling is that it consumes CPU time (to read and compare the
    port B value) even when the external hardware is not transmitting new values.
    During polling, the CPU cannot be used for other operations. A better solution
    would be to have the external hardware notify the CPU that new data is available;
    this notification would interrupt the current CPU’s activities so it can briefly
    deal with the changed data and then resume the interrupted operation after handling
    the new data. The question is, how can the external hardware interrupt the CPU
    whenever it applies new data to port B?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询的一个问题是，即使外部硬件没有传输新值，它仍然会消耗 CPU 时间（用于读取和比较端口 B 的值）。在轮询过程中，CPU 不能用于其他操作。更好的解决方案是让外部硬件通知
    CPU 新数据可用；此通知将中断当前 CPU 的活动，使其能够简短地处理已更改的数据，然后在处理完新数据后恢复中断的操作。问题是，如何让外部硬件在将新数据应用到端口
    B 时中断 CPU？
- en: 'You can program the MCP230*xx* devices to produce a signal on the MCP23008
    INT or the MCP23017 INTA or INTB pins whenever a change in state occurs. A change
    in state, known as an *interrupt-on-change (IOC)*, is noted in one of two programmable
    situations:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编程 MCP230*xx* 设备，在 MCP23008 的 INT 引脚或 MCP23017 的 INTA 或 INTB 引脚上产生信号，表示状态变化发生。当发生状态变化时，称为
    *变化中断（IOC）*，并有两种可编程的情况来表示：
- en: A pin changes state (from low to high or from high to low).
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引脚状态发生变化（从低到高或从高到低）。
- en: A pin changes state when compared against the corresponding bit in the DEFVAL
    register.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当与 DEFVAL 寄存器中的相应位进行比较时，某个引脚会发生状态变化。
- en: The INT*x* pins reflect the current interrupt state. You would normally connect
    the INT*x* pins to an interrupt input on your SBC. Different SBCs support interrupts
    on different pins. Of course, if you are using a different SBC or a different
    RTOS, you will have to check the documentation for the SBC or RTOS to determine
    which pins are suitable for use as interrupt inputs. This section will assume
    you are using the Arduino libraries; see your SBC or RTOS documentation when using
    a different system.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: INT*x* 引脚反映当前的中断状态。通常，你会将 INT*x* 引脚连接到单板计算机（SBC）上的中断输入引脚。不同的 SBC 支持不同引脚上的中断。当然，如果你使用的是不同的
    SBC 或不同的实时操作系统（RTOS），你需要查看 SBC 或 RTOS 的文档，以确定哪些引脚适合用作中断输入。本节假设你使用的是 Arduino 库；如果使用不同的系统，请参阅你所使用的
    SBC 或 RTOS 文档。
- en: 13.5.2 Interrupt Service Routines
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.2 中断服务例程
- en: 'When an interrupt causes the CPU to halt the current program execution, it
    transfers control to a special function: the ISR. The ISR quickly does whatever
    is necessary to handle the hardware event and then returns control to the system,
    which resumes the original, interrupted code. To support ISRs in an application,
    you’ll need to address a few questions. Answers vary by system; the following
    sections give answers for the Arduino.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当中断导致 CPU 停止当前程序执行时，它会将控制权转移到一个特殊的功能：ISR。ISR 会快速处理必要的硬件事件，然后将控制权返回给系统，系统会恢复原来的中断代码。为了支持应用程序中的
    ISR，你需要解决一些问题。答案会根据系统有所不同；以下部分将提供 Arduino 系统的解答。
- en: '**How and where is the electronic signal input to the system?**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**电子信号是如何以及在哪里输入到系统中的？**'
- en: In most systems, Arduino included, interrupts are digital logic signals input
    on specific CPU or system pins. On the Arduino, selected digital I/O pins can
    serve as interrupt inputs. (See “For More Information” for information on Arduino-brand
    pin selections for interrupts.) For example, the Arduino Uno Rev3 supports interrupts
    on digital I/O pins 2 and 3, and the Teensy 3.1 supports interrupts on any digital
    I/O pin. Not all Arduino devices support pin 2 as an interrupt pin; check your
    documentation when using a different device.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在大多数系统中，包括 Arduino 中，中断是输入到特定 CPU 或系统引脚的数字逻辑信号。在 Arduino 上，选定的数字 I/O 引脚可以作为中断输入。（有关
    Arduino 品牌引脚选择的更多信息，请参见“更多信息”。）例如，Arduino Uno Rev3 支持在数字 I/O 引脚 2 和 3 上触发中断，而
    Teensy 3.1 支持在任何数字 I/O 引脚上触发中断。并非所有 Arduino 设备都支持引脚 2 作为中断引脚；使用其他设备时请检查文档。
- en: '**What type of input signals the interrupt?**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**中断输入信号的类型是什么？**'
- en: 'Because digital I/O signals can be low (0) or high (1), you might think that
    interrupts can occur only on these two conditions. In fact, most Arduino systems
    will invoke an interrupt on one of the following conditions:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为数字 I/O 信号可以是低（0）或高（1），你可能会认为中断只会在这两种情况下发生。实际上，大多数 Arduino 系统会在以下情况之一下触发中断：
- en: A low-to-high transition on the interrupt pin
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断引脚上的低电平到高电平的过渡
- en: A high-to-low transition on the interrupt pin
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引脚上的低电平到高电平的过渡
- en: Any change (low-to-high or high-to-low) on the interrupt pin
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断引脚上的任何变化（低电平到高电平或高电平到低电平）
- en: A low signal on the interrupt pin
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断引脚上的低电平信号
- en: Some, but not all, Arduino devices can also invoke an interrupt when the interrupt
    pin is high.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些但不是所有的 Arduino 设备也可以在中断引脚为高电平时触发中断。
- en: '**How do you specify the ISR function?**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何指定 ISR 函数？**'
- en: 'Arduino systems use the `attachInterrupt()` function to associate a particular
    digital I/O pin with an interrupt. The call takes the following form:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Arduino 系统使用 `attachInterrupt()` 函数将特定的数字 I/O 引脚与中断关联。调用的形式如下：
- en: '[PRE1]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this call, `pin` is a digital I/O pin number, `ISR` is the name of a void
    function with no parameters that serves as the interrupt service routine, and
    `mode` is one of the following identifiers:'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此调用中，`pin` 是数字 I/O 引脚编号，`ISR` 是一个没有参数的空函数的名称，用作中断服务程序，`mode` 是以下标识符之一：
- en: '`LOW` Triggers the interrupt whenever the pin is low'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LOW` 每当引脚为低电平时触发中断'
- en: '`CHANGE` Triggers the interrupt whenever the pin changes value'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CHANGE` 每当引脚的值发生变化时触发中断'
- en: '`RISING` Triggers when the pin goes from low to high'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RISING` 当引脚从低电平变为高电平时触发'
- en: '`FALLING` Triggers when the pin goes from high to low'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FALLING` 当引脚从高电平变为低电平时触发'
- en: '`HIGH` Triggers the interrupt whenever the pin is high'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HIGH` 每当引脚为高电平时触发中断'
- en: Only some Arduino-compatible boards allow `HIGH`, so check your board’s documentation
    to see if it supports active high interrupt signaling (for example, the Uno Rev3
    does not support `HIGH`).
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只有一些兼容 Arduino 的板子支持 `HIGH`，因此请查看您板子的文档，确认它是否支持主动高电平中断信号（例如，Uno Rev3 不支持 `HIGH`）。
- en: To use interrupts on other systems, see the documentation for your library,
    OS, or SBC.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 若要在其他系统上使用中断，请参阅您的库、操作系统或单板计算机（SBC）的文档。
- en: '**What are the constraints on the ISR function?**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**ISR 函数的限制是什么？**'
- en: 'Most operating systems place constraints on ISRs. Generally, you should assume
    the following:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数操作系统对 ISR 施加限制。通常，您应该假设以下几点：
- en: Any global variables an ISR modifies should be declared as `volatile`.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISR 修改的任何全局变量应声明为 `volatile`。
- en: ISR functions should be short, and execution time should be as minimal as possible.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISR 函数应该简短，执行时间应尽可能短。
- en: Many systems do not allow interrupts to be nested (that is, they don’t allow
    one interrupt signal to interrupt an executing ISR).
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多系统不允许中断嵌套（即，不允许一个中断信号中断正在执行的 ISR）。
- en: Many systems limit the type of library function calls that you can make in an
    ISR.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多系统限制在 ISR 中可以调用的库函数类型。
- en: Please consult your particular OS’s reference manuals for additional information
    about interrupt service routines.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参考您特定操作系统的参考手册，以获取有关中断服务程序的更多信息。
- en: The Arduino library, for example, places a couple of additional constraints
    on ISRs. In particular, you cannot use the `delay()` or `millis()` functions within
    an ISR. See “For More Information” for links to Arduino interrupt documentation.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，Arduino 库对 ISR 有一些额外的限制。特别是，不能在 ISR 中使用 `delay()` 或 `millis()` 函数。有关更多信息，请参见“更多信息”中的
    Arduino 中断文档链接。
- en: '**INT*x* pin polarity**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**INT*x* 引脚极性**'
- en: When the MCP230*xx* detects a pin change that would cause an interrupt, it will
    set the INT*x* pin high or low. The INTPOL bit (bit 1) in the IOCON register determines
    the interrupt polarity. If INTPOL is 1, then the interrupt signal is active high—that
    is, the INT*x* pin will go high when an interrupt occurs. If INTPOL is 0, then
    the interrupt signal is active low and goes low on an interrupt.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 MCP230*xx* 检测到会引发中断的引脚变化时，它会将 INT*x* 引脚设置为高或低。IOCON 寄存器中的 INTPOL 位（第 1 位）决定中断的极性。如果
    INTPOL 为 1，则中断信号为高电平有效——即中断发生时，INT*x* 引脚会变为高电平。如果 INTPOL 为 0，则中断信号为低电平有效，中断发生时，INT*x*
    引脚会变为低电平。
- en: You can select the appropriate interrupt polarity either by using the Arduino
    `attachInterrupt()` `mode` parameter or by setting the interrupt polarity on the
    MCP230*xx*. However, it is important to ensure that the polarity you specify by
    `mode` matches the polarity you specify with the INTPOL bit. The common convention
    is to use active low interrupts and specify either `LOW` or `FALLING` as the `mode`
    parameter value.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以通过使用 Arduino 的 `attachInterrupt()` `mode` 参数或设置 MCP230*xx* 上的中断极性来选择合适的中断极性。然而，重要的是要确保通过
    `mode` 指定的极性与通过 INTPOL 位指定的极性匹配。常见的约定是使用低电平触发中断，并将 `mode` 参数的值设置为 `LOW` 或 `FALLING`。
- en: 13.5.3 Mirroring INT*x* Pins (MCP23017 Only)
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.3 中断引脚镜像（仅限 MCP23017）
- en: The MCP23017 provides two independent interrupt pins for port A (INTA pin) and
    port B (INTB pin). This allows you to quickly determine the source of an interrupt
    if both ports A and B can generate interrupts, though at the cost of requiring
    two separate interrupt pins on the CPU. If you want to use only a single pin as
    an interrupt line on your CPU and are willing to use some software to differentiate
    port A and port B interrupts, you can program the MCP23017 to wire the INTA and
    INTB pins together so that an interrupt on either port will send a signal to the
    INTA and INTB pins.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: MCP23017 提供两个独立的中断引脚，一个用于端口 A（INTA 引脚），一个用于端口 B（INTB 引脚）。如果端口 A 和端口 B 都能产生中断，这样可以快速确定中断来源，但需要
    CPU 上有两个独立的中断引脚。如果你只想使用一个引脚作为 CPU 的中断线，并愿意使用一些软件来区分端口 A 和端口 B 的中断，你可以将 MCP23017
    编程为将 INTA 和 INTB 引脚连接在一起，这样无论哪个端口发生中断，都会将信号发送到 INTA 和 INTB 引脚。
- en: Programming the MIRROR bit (bit 6) with a 1 in the IOCON register achieves this.
    Conversely, programming the MIRROR bit with a 0 (the default condition) routes
    all port A interrupts to INTA and all port B interrupts to INTB.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 IOCON 寄存器中将 MIRROR 位（第 6 位）编程为 1 来实现这一点。相反，若将 MIRROR 位编程为 0（默认条件），则会将所有端口
    A 的中断路由到 INTA，所有端口 B 的中断路由到 INTB。
- en: 13.5.4 Open-Drain INT*x* Output
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.4 开漏式 INT*x* 输出
- en: Bit 2 of the IOCON register (ODR) controls the INT*x* line open-drain interface.
    If this bit is programmed as a 1, open-drain output is enabled; if it is programmed
    as a 0 (the default), the active logic output in the INT*x* lines is enabled.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: IOCON 寄存器的第 2 位（ODR）控制 INT*x* 引脚的开漏接口。如果此位被编程为 1，则启用开漏输出；如果编程为 0（默认值），则启用 INT*x*
    引脚的活跃逻辑输出。
- en: The open-drain form allows you to connect the INT lines from multiple MCP230*xx*
    devices together. This mode requires a pullup resistor on the output line. In
    open-drain mode, an interrupt signal will pull the INT*x* pin low, which, presumably,
    signals an interrupt on the controller. The controller will have to poll the various
    MCP230*xx* devices to determine the source of the interrupt.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 开漏形式允许你将多个 MCP230*xx* 设备的 INT 引脚连接在一起。此模式需要在输出线上加上上拉电阻。在开漏模式下，中断信号会将 INT*x*
    引脚拉低，这通常表示控制器上发生了中断。控制器必须轮询各个 MCP230*xx* 设备，以确定中断的来源。
- en: The active logic output mode puts a logic signal directly on the INT*x* output
    pin. In this mode, the INT*x* pin must exclusively connect to an interrupt on
    the controller device; you cannot tie the interrupt pins together since that would
    create an electrical fault. This mode is best when you have a single MCP230*xx*
    device or if you need separate interrupts for each MCP230*xx* (so you don’t have
    to poll the devices to determine the source of the interrupt).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃逻辑输出模式将逻辑信号直接输出到 INT*x* 引脚。在此模式下，INT*x* 引脚必须专门连接到控制器设备上的中断；你不能将中断引脚连接在一起，因为那样会产生电气故障。当你只有一个
    MCP230*xx* 设备时，或需要为每个 MCP230*xx* 提供单独的中断（这样你就不必轮询设备来确定中断源）时，这种模式是最佳选择。
- en: 'Active logic mode is the default interrupt mode, a design error in MCP230*xx*
    devices. Tying multiple devices’ INT*x* lines together and forgetting to program
    the ODR bit in open-drain mode could create an electrical conflict that could
    damage the MCP230*xx* parts. Moral of the story: always program the ODR bit in
    IOCON correctly! Many designers stick a transistor (such as a 2N7000 MOSFET) on
    the INT*x* pins to force open-drain (open-collector) mode and program ODR in active
    logic mode to drive the transistor. This avoids the possibility of a programming
    error that would damage the MCP230*xx*.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 活动逻辑模式是默认的中断模式，这是 MCP230*xx* 设备中的设计缺陷。如果将多个设备的 INT*x* 引脚连接在一起，并且忘记将 ODR 位设置为开漏模式，可能会造成电气冲突，从而损坏
    MCP230*xx* 部件。故事的教训是：始终正确编程 IOCON 中的 ODR 位！许多设计师会在 INT*x* 引脚上连接一个晶体管（如 2N7000
    MOSFET），以强制设置为开漏（开集电极）模式，并在活动逻辑模式下编程 ODR 以驱动晶体管。这可以避免由于编程错误导致 MCP230*xx* 损坏的可能性。
- en: 13.5.5 Enabling Interrupts on the MCP230*xx*
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.5 在 MCP230*xx* 上启用中断
- en: By default, the MCP230*xx* parts do not generate any interrupts; you must explicitly
    enable interrupts for the INT*x* pins to become active. You can do so with the
    MCP23008 GPINTEN and MCP23017 GPINTENA and GPINTENB registers.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，MCP230*xx* 部件不会生成任何中断；你必须显式启用中断，才能使 INT*x* 引脚变为活动状态。你可以通过 MCP23008 的 GPINTEN
    和 MCP23017 的 GPINTENA 和 GPINTENB 寄存器来实现这一点。
- en: 'The MCP230*xx* devices allow you to enable or disable interrupts on a pin-by-pin
    basis. Each bit in a GPINTEN*x* register matches one of the GPIO pins: GPINTENA
    matches GPIOA pins, and GPINTENB matches GPIOB pins on the MCP23017\. If a bit
    in GPINTEN*x* contains 0, then interrupts are disabled for that particular I/O
    pin. If the bit contains 1, then interrupts are enabled for that bit, and interrupts
    are generated based on the bit settings in the INTCON and DEFVAL registers.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: MCP230*xx* 设备允许你按引脚逐个启用或禁用中断。每个 GPINTEN*x* 寄存器中的位都对应一个 GPIO 引脚：GPINTENA 对应 GPIOA
    引脚，GPINTENB 对应 MCP23017 的 GPIOB 引脚。如果 GPINTEN*x* 中的某个位为 0，那么该特定 I/O 引脚的中断被禁用。如果该位为
    1，那么启用该位的中断，并根据 INTCON 和 DEFVAL 寄存器中的位设置生成中断。
- en: If interrupts are enabled for a particular I/O pin, then the INTCON and DEFVAL
    registers allow you to program the MCP230*xx* to generate an interrupt on a pin
    change or on a particular level. If a specific INTCON bit is 0, then the MCP230*xx*
    will generate an interrupt any time the input bit changes (that is, it will generate
    an interrupt on a low-to-high or on a high-to-low transition). In this case, the
    MCP230*xx* ignores the corresponding bit in DEFVAL. If a specific INTCON bit is
    1, then the MCP230*xx* will generate an interrupt any time the input bit differs
    from the value of the corresponding bit in DEFVAL. This allows you to create level-sensing
    interrupts. If the corresponding bit in DEFVAL is 0, then the MCP230*xx* generates
    interrupts when the input pin is high; if the bit in DEFVAL is 1, then the MCP230*xx*
    generates interrupts when the input pin is low. Note that if the corresponding
    bit in INTCON is 0, or if that bit in GPINTEN*x* is 0, the system ignores the
    bit in DEFVAL.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为某个特定的 I/O 引脚启用了中断，那么 INTCON 和 DEFVAL 寄存器允许你编程使 MCP230*xx* 在引脚变化或特定电平时生成中断。如果某个特定的
    INTCON 位为 0，那么 MCP230*xx* 会在输入位变化时生成中断（也就是说，它会在从低到高或从高到低的转换时生成中断）。在这种情况下，MCP230*xx*
    会忽略 DEFVAL 中相应的位。如果某个特定的 INTCON 位为 1，那么 MCP230*xx* 会在输入位与 DEFVAL 中相应位的值不同时时生成中断。这使得你可以创建电平感应中断。如果
    DEFVAL 中相应的位为 0，那么 MCP230*xx* 会在输入引脚为高时生成中断；如果 DEFVAL 中的位为 1，那么 MCP230*xx* 会在输入引脚为低时生成中断。请注意，如果
    INTCON 中相应的位为 0，或者 GPINTEN*x* 中该位为 0，系统会忽略 DEFVAL 中的该位。
- en: 'Although it is possible to modify the GPINTEN*x*, INTCON*x*, and DEFVAL*x*
    registers throughout program execution in complex systems, most commonly you initialize
    these registers just once when your program first begins execution. To prevent
    race conditions, you should initialize interrupts in the following order:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在复杂系统中可以在程序执行过程中修改 GPINTEN*x*、INTCON*x* 和 DEFVAL*x* 寄存器，但通常你只在程序开始执行时初始化这些寄存器一次。为了防止竞争条件，应按照以下顺序初始化中断：
- en: Initialize the DEFVAL*x* register(s), if necessary.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 DEFVAL*x* 寄存器（如果需要）。
- en: Initialize the INTCON*x* register(s), if necessary.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 INTCON*x* 寄存器（如果需要）。
- en: Read the GPIO pins to clear any existing interrupts.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取 GPIO 引脚以清除任何现有的中断。
- en: Initialize the GPINTEN*x* register(s), if necessary.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 GPINTEN*x* 寄存器（如果需要）。
- en: Attach an ISR to the particular pin using `attachInterrupt()`.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `attachInterrupt()` 将 ISR 附加到特定引脚。
- en: A sequence like this helps prevent any inadvertent interrupts resulting from
    pre-existing conditions on the input pins or conditions that change during initialization.
    This particular sequence is for an Arduino system, but all other systems have
    a comparable one.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的顺序有助于防止由于输入引脚上的预先存在的条件或初始化过程中发生的条件变化而引起的无意中断。这个特定的顺序适用于 Arduino 系统，但其他系统也有类似的处理方式。
- en: 13.5.6 Testing and Clearing Interrupts
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.6 测试和清除中断
- en: The INT*x* pin(s) on the MCP230*xx* indicate only that an interrupt has occurred
    on one (or both) banks. When the system invokes the ISR, you don’t know which
    pin—or pins, if multiple pins change simultaneously—is responsible for the interrupt.
    To determine the exact source(s) of the interrupt, you will need to read the MCP23008
    INTF or MCP23017 INTFA or INTFB register(s).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: MCP230*xx* 上的 INT*x* 引脚仅表示在一个（或两个）端口上发生了中断。当系统调用 ISR 时，你无法得知是哪个引脚——如果多个引脚同时变化——导致了中断。为了确定中断的确切来源，你需要读取
    MCP23008 的 INTF 或 MCP23017 的 INTFA 或 INTFB 寄存器。
- en: The bits in the INTF*x* register indicate which bits are responsible for an
    interrupt. When the ISR begins execution, it should read the INTF*x* register(s),
    where a 1 bit in a bit position indicates that the interrupt resulted from a change
    in the specified input bit. The ISR can then read the appropriate GPIO pin to
    determine the state of that pin when the interrupt occurred. For example, if interrupts
    are enabled for any change, reading the GPIO pin will tell you whether a rising
    or falling edge on the pin called the interrupt.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: INTF*x* 寄存器中的位表示哪个引脚导致了中断。当 ISR 开始执行时，它应该读取 INTF*x* 寄存器，其中某个位为 1 表示中断是由指定输入位的变化引起的。然后，ISR
    可以读取相应的 GPIO 引脚，以确定中断发生时该引脚的状态。例如，如果启用了对任何变化的中断，读取 GPIO 引脚将告诉你是引脚的上升沿还是下降沿触发了中断。
- en: In theory, the CPU will invoke the ISR almost immediately after the interrupt
    pin changes state. In practice, it is possible for the ISR invocation to be slightly
    delayed after the interrupt condition occurs; for example, some other high-priority
    code (ISR) could be executing with the interrupts disabled. In that case, the
    ISR will be called only when the current high-priority code re-enables interrupts.
    During this time, it is possible for the state of the I/O pin to change. Therefore,
    by the time the ISR reads the signal on the input pin, the input data could have
    changed, and whatever the ISR reads might be wrong (a common race condition).
    To prevent this from happening, the MCP230*xx* *captures* the state of the pins
    when the interrupt occurs. The MCP230*xx* puts this snapshot of the pins in the
    MCP23008 INTCAP or MCP23017 INTCAPA and INTCAPB registers. Therefore, the ISR
    should actually read the contents of the appropriate INTCAP*x* register to determine
    the pin state that produced the interrupt.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，CPU 会在中断引脚状态变化后几乎立即调用 ISR。实际上，ISR 的调用可能会在中断条件发生后略微延迟；例如，某些高优先级的代码（ISR）可能在禁用中断时执行。在这种情况下，ISR
    只有在当前的高优先级代码重新启用中断后才会被调用。在此期间，I/O 引脚的状态可能发生变化。因此，到 ISR 读取输入引脚信号时，输入数据可能已经改变，ISR
    读取到的数据可能是错误的（这是一种常见的竞争条件）。为了防止这种情况发生，MCP230*xx* 在中断发生时会“捕获”引脚的状态。MCP230*xx* 将此引脚快照存储在
    MCP23008 的 INTCAP 或 MCP23017 的 INTCAPA 和 INTCAPB 寄存器中。因此，ISR 实际上应该读取适当的 INTCAP*x*
    寄存器的内容，以确定导致中断的引脚状态。
- en: By reading GPIO data (GPIO*x* or INTCAP*x* port), the ISR unfreezes the INTCAP*x*.
    This prepares it to capture the next interrupt pin set. You should always read
    the INTCAP*x* register(s) first in an ISR, since it’s possible to lose captured
    information if another interrupt is pending and you read the GPIO*x* port first
    instead. Typically, there is no real need to read the GPIO*x* register(s) in an
    ISR—the INTCAP*x* register(s) usually provide all the information you need.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过读取 GPIO 数据（GPIO*x* 或 INTCAP*x* 端口），ISR 解冻了 INTCAP*x*。这为捕获下一个中断引脚设置做好准备。你应该在
    ISR 中首先读取 INTCAP*x* 寄存器，因为如果有另一个中断等待发生且你首先读取 GPIO*x* 端口，可能会丢失捕获的信息。通常，在 ISR 中并不需要读取
    GPIO*x* 寄存器——INTCAP*x* 寄存器通常提供所有所需的信息。
- en: Pins configured for interrupt-on-change (in the INTCON*x* registers) will change
    the state that causes the next interrupt after you read the corresponding INTCAP*x*
    register. For example, if an interrupt occurred because a pin changed from high
    to low, the new interrupt condition (low to high) will not be active until you
    clear the interrupt by reading GPIO*x* or INTCAP*x*. If the pin actually toggles
    from high to low, then low to high and high to low again, the MCP230*xx* will
    signal a single interrupt only if the system has not cleared the interrupts between
    these level changes on the input pin.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 配置为“中断-按变化触发”（在INTCON*x*寄存器中）的引脚，会在读取对应的INTCAP*x*寄存器后，改变导致下一个中断的状态。例如，如果中断是因为引脚从高电平变为低电平发生的，那么新的中断条件（从低电平到高电平）在你通过读取GPIO*x*或INTCAP*x*清除中断之前不会激活。如果引脚实际上从高电平变为低电平，再从低电平变回高电平，然后再变回低电平，那么MCP230*xx*只会在系统没有在这些电平变化之间清除中断时，发出一次中断信号。
- en: Pins configured for interrupt-on-level—that is, pins configured to cause an
    interrupt based on the value appearing in a DEFVAL*x* register—continuously generate
    an interrupt signal as long as that level condition exists on the input pin. Reading
    or writing the GPIO*x* or INTCAP*x* register(s) does not reset that particular
    interrupt state until the interrupt condition ceases to exist.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 配置为“中断-按电平触发”的引脚——即配置为根据DEFVAL*x*寄存器中出现的值触发中断的引脚——只要该电平条件存在于输入引脚上，就会持续生成中断信号。读取或写入GPIO*x*或INTCAP*x*寄存器并不会重置该中断状态，直到中断条件不再存在。
- en: 13.6 A Sample Interrupt-Driven MCP230*xx*
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.6 一个示例的中断驱动MCP230*xx*
- en: Reading rotary shaft encoders is a common way to demonstrate interrupt programming
    on MCP230*xx* devices. As it turns out, twisting a rotary encoded at a high speed
    can easily result in data loss if the CPU is often busy doing other work, like
    displaying the values read from the rotary encoders. Using an ISR to quickly capture
    the encoder data and make it available for some main thread to process can eliminate
    data loss. This section provides some simple library code that demonstrates how
    to read and display the data from a SparkFun rotary encoder with red and green
    LEDs ([https://www.sparkfun.com/products/15140](https://www.sparkfun.com/products/15140)).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 读取旋转编码器是一种常见的方式，用来展示在MCP230*xx*设备上的中断编程。实际上，如果旋转编码器旋转得非常快，而CPU又经常忙于执行其他任务，比如显示读取的编码器值，那么很容易发生数据丢失。使用ISR（中断服务例程）快速捕捉编码器数据并将其提供给主线程处理，可以消除数据丢失。本节提供了一些简单的库代码，演示了如何读取并显示带有红绿LED的SparkFun旋转编码器的数据（[https://www.sparkfun.com/products/15140](https://www.sparkfun.com/products/15140)）。
- en: The SparkFun rotary encoder breakout ([https://www.sparkfun.com/products/11722](https://www.sparkfun.com/products/11722))
    makes it easy to breadboard one of these devices into a circuit, as shown in [Figure
    13-12](#figure13-12).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: SparkFun旋转编码器外接板（[https://www.sparkfun.com/products/11722](https://www.sparkfun.com/products/11722)）使得将该设备轻松地接入电路面包板，如[图13-12](#figure13-12)所示。
- en: '![](image_fi/502468c13/f13012.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c13/f13012.png)'
- en: 'Figure 13-12: SparkFun rotary encoder breakout board'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-12：SparkFun旋转编码器外接板
- en: SparkFun rotary encoders have two digital I/O pins labeled A and B, which specify
    rotational changes (see [Figure 13-13](#figure13-13)). You wire these pins through
    a 10-kΩ resistor to +5 V and wire the pin labeled C to Gnd. (If you connect the
    rotary encoder to an MCP230*xx* device, you can use the built-in programmable
    pullup resistor in place of the 10-kΩ resistor.) As you rotate the shaft on the
    encoder, it selectively connects pins A and B to pin C, that is, to Gnd. The pins
    labeled 1, 2, 3, and 4 in [Figure 13-13](#figure13-13) connect to the red and
    green LEDs, a pushbutton switch, and a common for these pins.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: SparkFun旋转编码器有两个数字I/O引脚，标记为A和B，用于指定旋转变化（见[图13-13](#figure13-13)）。你需要通过一个10kΩ电阻将这些引脚接到+5
    V，并将标记为C的引脚接到地（Gnd）。(如果你将旋转编码器连接到MCP230*xx*设备，你可以使用内置的可编程上拉电阻替代10kΩ电阻。) 当你旋转编码器轴时，它会选择性地将A和B引脚连接到C引脚，即接到地（Gnd）。[图13-13](#figure13-13)中标记为1、2、3和4的引脚分别连接到红色和绿色LED、一个按钮开关和这些引脚的公共端。
- en: Connecting pins A and B to inputs on your SBC allows you to read the state of
    the two pins (high or low). By observing the state of these two pins over time,
    you can tell which direction the shaft is rotating, and at what speed, if you
    are timing the changes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 将A和B引脚连接到单板计算机（SBC）上的输入引脚，允许你读取这两个引脚的状态（高电平或低电平）。通过观察这两个引脚的状态变化，你可以判断旋转轴的旋转方向，以及旋转速度（如果你在计时变化的话）。
- en: '![](image_fi/502468c13/f13013.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c13/f13013.png)'
- en: 'Figure 13-13: SparkFun Red/Green rotary encoder'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-13：SparkFun红/绿旋转编码器
- en: If you turn the shaft clockwise (CW) at a fixed speed, you will get the waveform
    shown in [Figure 13-14](#figure13-14) on pins A and B.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以固定速度顺时针旋转轴（CW），你将会在引脚 A 和 B 上看到[图 13-14](#figure13-14)中的波形。
- en: '![](image_fi/502468c13/f13014.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c13/f13014.png)'
- en: 'Figure 13-14: Rotary encoder output when rotating shaft clockwise'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-14：旋转轴顺时针旋转时的旋转编码器输出
- en: The output in [Figure 13-14](#figure13-14) is known as a *quadrature output*,
    where two out-of-phase signals determine the rotation direction, producing binary
    outputs similar to those shown in [Table 13-5](#table13-5) over time.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-14](#figure13-14)中的输出被称为*正交输出*，其中两个相位相反的信号决定旋转方向，生成类似于[表 13-5](#table13-5)中所示的二进制输出，随着时间的推移变化。'
- en: 'Table 13-5: Clockwise Rotary Encoder Output'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-5：顺时针旋转编码器输出
- en: '| Output A | 0 | 0 | 1 | 1 | 0 | 0 | 1 | And so on |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 输出 A | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 依此类推 |'
- en: '| Output B | 1 | 0 | 0 | 1 | 1 | 0 | 0 | And so on |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 输出 B | 1 | 0 | 0 | 1 | 1 | 0 | 0 | 依此类推 |'
- en: If you treat the input pairs as a 2-bit binary value, turning the encoder clockwise
    produces the repeating binary sequence 01 00 10 11 01 00 10 11 . . . over time.
    This is an example of a 2-bit *gray code*, a binary counting sequence where no
    more than a single bit changes between any two successive values (see “For More
    Information”). Gray codes are useful when working with multibit mechanical inputs
    because they are more immune to noise than regular binary codes are.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将输入对视为一个2位二进制值，顺时针旋转编码器会产生重复的二进制序列 01 00 10 11 01 00 10 11 . . . 随时间变化。这是一个2位*灰码*的示例，一种二进制计数序列，其中任何两个连续值之间不会改变超过一位（详见“更多信息”）。灰码在处理多位机械输入时非常有用，因为它比常规二进制代码更能抗干扰。
- en: If you turn the shaft counterclockwise (CCW) at a fixed speed, you will get
    the waveform in [Figure 13-15](#figure13-15) on pins A and B.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以固定速度逆时针旋转轴（CCW），你将会在引脚 A 和 B 上看到[图 13-15](#figure13-15)中的波形。
- en: '![](image_fi/502468c13/f13015.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c13/f13015.png)'
- en: 'Figure 13-15: Rotary encoder output when rotating shaft counterclockwise'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-15：旋转轴逆时针旋转时的旋转编码器输出
- en: This also produces outputs similar to those shown in [Table 13-6](#table13-6)
    over time.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会产生类似于[表 13-6](#table13-6)中所示的输出，随着时间的推移变化。
- en: 'Table 13-6: Counterclockwise Rotary Encoder Output'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-6：逆时针旋转编码器输出
- en: '| Output A | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | And so on |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 输出 A | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 依此类推 |'
- en: '| Output B | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 0 | And so on |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 输出 B | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 0 | 依此类推 |'
- en: 'The gray code output is the binary sequence: 00 01 11 10 00 01 . . .'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 灰码输出为二进制序列：00 01 11 10 00 01 . . .
- en: 'Another way to interpret the A and B inputs is to use a change in A to indicate
    a rotation of the encoder shaft and then read the B input to determine the direction
    of the rotation:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解读 A 和 B 输入的方法是使用 A 的变化来指示编码器轴的旋转，然后读取 B 输入来确定旋转方向：
- en: A high-to-low transition on A with B low during the transition indicates a CCW
    rotation.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 A 引脚上从高到低的跳变且 B 引脚低时，表示逆时针旋转。
- en: A low-to-high transition on A with B high also indicates a CCW rotation.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 A 引脚上从低到高的跳变且 B 引脚高时，也表示逆时针旋转。
- en: A high-to-low transition on A with B high during the transition indicates a
    CW rotation.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 A 引脚上从高到低的跳变且 B 引脚高时，表示顺时针旋转。
- en: A low-to-high transition on A with B low also indicates a CW rotation.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 A 引脚上从低到高的跳变且 B 引脚低时，也表示顺时针旋转。
- en: An MCP23008 GPIO expander would allow you to connect up to four of the SparkFun
    Illuminated Red/Green rotary encoders to a system. The encoder used in this section,
    however, connects a single rotary encoder to pins GP0 and GP1 on an MCP23008\.
    Specifically, the encoder’s A pin connects to GP1, and the B pin connects to GP0
    through optional debouncing circuitry. If you also want to control the red and
    green LEDs on the encoder from the MCP23008, you can add some resistors between
    pins on MCP23008 to be programmed as outputs, along with the pins 2 and 3 on the
    rotary encoder. You will also need to connect the pin labeled 1 to Gnd. The resistors
    should probably be between 470 Ω and 1 kΩ. You can turn the red and green LEDs
    on or off by programming those output pins with logic 1s or 0s; programming both
    pins produces a yellow output. The example in this section will ignore the LED
    outputs, but you can easily add code to control them if you want.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: MCP23008 GPIO 扩展器允许您将最多四个 SparkFun 发光红/绿旋转编码器连接到系统。然而，本节中使用的编码器只将一个旋转编码器连接到
    MCP23008 的 GP0 和 GP1 引脚。具体来说，编码器的 A 引脚连接到 GP1，B 引脚通过可选的去抖电路连接到 GP0。如果您还想控制编码器上的红绿
    LED，您可以在 MCP23008 的引脚上添加一些电阻，以将其配置为输出，并与旋转编码器上的 2 和 3 引脚连接。您还需要将标有 1 的引脚连接到地。电阻值通常应在
    470 Ω 到 1 kΩ 之间。您可以通过将这些输出引脚编程为逻辑 1 或 0 来打开或关闭红绿 LED；同时编程两个引脚将产生黄色输出。本节中的示例忽略了
    LED 输出，但如果您希望控制 LED，可以轻松添加代码。
- en: The rotary encoder A and B pins are dry contacts. To read logic signals from
    these pins, you would normally add pullup resistors to the circuit (to +5 V or
    +3.3 V, whichever is appropriate). Rather than explicitly adding these resistors,
    the software will enable the GP0 and GP1 pins to use the MCP23008 programmable
    pin pullup resistors.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转编码器的 A 和 B 引脚是干触点。为了从这些引脚读取逻辑信号，通常需要在电路中添加上拉电阻（接 +5 V 或 +3.3 V，根据需要选择）。但不必显式添加这些电阻，软件将启用
    GP0 和 GP1 引脚使用 MCP23008 可编程引脚的上拉电阻。
- en: The program in [Listing 13-2](#listing13-2) uses a change on the A pin to cause
    an interrupt. The ISR will read the A and B pin values on GP1 (A) and GP0 (B)
    and increment or decrement a global counter based on the previous and current
    readings of these pins. The main program (that is, the code outside the ISR) uses
    the value of this global variable to determine how many “clicks” the encoder has
    been turned in the clockwise or counterclockwise direction since the application
    began execution.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-2](#listing13-2) 中的程序使用 A 引脚的变化来触发中断。ISR 将读取 GP1（A）和 GP0（B）上的 A 和 B
    引脚值，并根据这些引脚的前后读取值来递增或递减全局计数器。主程序（即 ISR 之外的代码）使用这个全局变量的值来确定自应用程序开始执行以来，编码器已顺时针或逆时针旋转了多少“点击”。'
- en: For the program in [Listing 13-2](#listing13-2), the MCP23008 SCL and SDA lines
    (pins 1 and 2) connect to the Teensy 3.2 SDA0 and SCL0 pins (pins D18 and D19).
    The INT line (pin 8) connects to the Teensy D2 pin. The RESET (pin 6) and Vdd
    (pin 18) pins connect to +3.3 V. The address lines and Vss (pins 3, 4, 5, and
    9) connect to Gnd. Finally, GP1 connects to the rotary encoder A pin, and GP0
    connects to the rotary encoder B pin (the rotary encoder C pin connects to ground).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 [列表 13-2](#listing13-2) 中的程序，MCP23008 的 SCL 和 SDA 引脚（引脚 1 和 2）连接到 Teensy
    3.2 的 SDA0 和 SCL0 引脚（引脚 D18 和 D19）。INT 引脚（引脚 8）连接到 Teensy 的 D2 引脚。RESET（引脚 6）和
    Vdd（引脚 18）引脚连接到 +3.3 V。地址引脚和 Vss（引脚 3、4、5 和 9）连接到地。最后，GP1 连接到旋转编码器的 A 引脚，GP0 连接到旋转编码器的
    B 引脚（旋转编码器的 C 引脚连接到地）。
- en: '[Listing 13-2](#listing13-2) programs the MCP23008 to generate an interrupt
    (active low) whenever there is a change on the GPA1 pin. When the ISR reads the
    INTCAP register, GP1 will reflect the value of the A pin *after* the rising or
    falling transition. Therefore, if the ISR reads 0 in the LO 2 bits of INTCAP,
    there has been a falling edge (GP1 is 0) and B is 0\. This indicates a counterclockwise
    rotation. Likewise, if the LO 2 bits of INTCAP are 3 (0b11), then there has been
    a rising edge and B is 1, which also indicates a CCW rotation.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-2](#listing13-2) 程序将 MCP23008 配置为每当 GPA1 引脚发生变化时生成一个中断（低电平有效）。当 ISR
    读取 INTCAP 寄存器时，GP1 将反映 A 引脚在上升或下降沿转换后的值。因此，如果 ISR 读取 INTCAP 的 LO 2 位为 0，则表示发生了下降沿（GP1
    为 0），且 B 为 0。这表示逆时针旋转。同样，如果 INTCAP 的 LO 2 位为 3（0b11），则表示发生了上升沿，且 B 为 1，这也表示顺时针旋转。'
- en: On a CW rotation, if the ISR reads a 1 in the LO 2 bits of INTCAP, this indicates
    a falling edge on A while B is 1\. If the ISR reads a 2 (0b10) in the LO 2 bits
    of INTCAP, this indicates a rising edge on A while B is low (also a CW rotation).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在顺时针旋转时，如果ISR在INTCAP的低2位读取到1，这表示A引脚有下降沿，而B引脚为1。如果ISR在INTCAP的低2位读取到2（0b10），这表示A引脚有上升沿而B引脚为低（同样是顺时针旋转）。
- en: The ISR simply increments or decrements a global variable (`rotaryPosn`) on
    a CW or CCW rotation, respectively. The main program checks this global variable
    and displays its value whenever it changes.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 中断服务程序（ISR）只需在顺时针（CW）或逆时针（CCW）旋转时分别增减一个全局变量（`rotaryPosn`）。主程序检查这个全局变量，并在其值发生变化时显示该值。
- en: '[PRE2]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Listing 13-2](#listing13-2) contains two functions, `writeReg()` ❶ and `readReg()`
    ❷, that write data to and read data from an MCP23008 register. These functions
    transmit the appropriate I²C bytes to accomplish this. The `mcpReset()` ❸ function
    initializes the MCP23008 to the power-on reset state, which is useful if the code
    is rerun without powering down the MCP23008\. The code also includes an interrupt
    service routine, `ISRFunc()` ❹, along with the usual Arduino `setup()` 5and `loop()`
    6functions.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-2](#listing13-2)包含了两个函数，`writeReg()` ❶ 和 `readReg()` ❷，用于向MCP23008寄存器写入和读取数据。这些函数通过传输适当的I²C字节来完成此操作。`mcpReset()`
    ❸函数将MCP23008初始化为上电复位状态，这在代码在不关闭MCP23008电源的情况下重新运行时非常有用。代码还包含了一个中断服务例程`ISRFunc()`
    ❹，以及常见的Arduino `setup()` 5和 `loop()` 6函数。'
- en: When a change occurs on the GP1 pin (because the shaft has rotated), this triggers
    an interrupt, causing the system to call the `ISRFunc()` function. This function
    determines if the shaft has rotated clockwise or counterclockwise and adjusts
    the value of the `rotaryPosn` variable accordingly.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当GP1引脚发生变化时（因为轴已旋转），会触发中断，导致系统调用`ISRFunc()`函数。该函数判断轴是顺时针还是逆时针旋转，并相应地调整`rotaryPosn`变量的值。
- en: The following is some sample output from the program in [Listing 13-2](#listing13-2)
    obtained by twisting the encoder knob back and forth.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序在[示例 13-2](#listing13-2)中的一些输出示例，这些输出是通过来回旋转编码器旋钮获得的。
- en: '[PRE3]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can determine from the output, the shaft was rotated counterclockwise
    for a short period, decrementing the output value, and then it was turned clockwise
    for a bit, incrementing the output value.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出结果可以看出，轴在短时间内逆时针旋转，导致输出值减少，随后又顺时针旋转一段时间，导致输出值增加。
- en: 13.7 MCP230**xx* Library Code*
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.7 MCP230**xx*库代码*
- en: '*Because of the complexity, many programmers prefer to use calls to existing
    library code rather than writing directly to the hardware themselves. Arduino
    provides an MCP230*xx* library package to help you out with this. See “For More
    Information” for the links to these libraries.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于复杂性，许多程序员更倾向于调用现有的库代码，而不是直接编写硬件操作代码。Arduino提供了一个MCP230*xx*库包来帮助你完成这项工作。详情请参见“更多信息”中的相关库链接。*'
- en: If you’d prefer to program the MCP230*xx* on a Raspberry Pi, Adafruit has also
    ported its library to the Pi; see “For More Information” for details. Likewise,
    those links describe where to find an MCP23008 library for Mbed. A quick web search
    will turn up several example Mbed libraries for the MCP23017 (mostly adaptations
    of the Adafruit library). You can also easily search for the dozens of examples
    of MCP230*xx* code scattered across the internet for a wide variety of CPUs, operating
    systems, and programming languages.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更倾向于在树莓派上编程MCP230*xx*，Adafruit也已将其库移植到了Pi上；详情请参见“更多信息”。同样，这些链接也描述了如何为Mbed找到MCP23008库。快速的网络搜索会找到多个适用于MCP23017的Mbed库示例（大多是Adafruit库的改编版）。你还可以轻松搜索到遍布互联网的MCP230*xx*代码示例，适用于各种CPU、操作系统和编程语言。
- en: 13.8 I²C Performance
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.8 I²C性能
- en: Although digital I/O functions, like reading a pushbutton, don’t require blazing
    performance, many such activities do require fast processing to properly read
    or write high-frequency digital signals. Unfortunately, high-performance operation
    and I²C bus connections are often mutually exclusive. Because it can sometimes
    take three or four bus transactions to read or write digital data via an MCP230*xx*
    device, it might require 400 μsec to 500 μsec for a single I/O operation at 100
    kHz, yielding a 2-kHz sample rate. This can be too slow for certain operations.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数字 I/O 功能，例如读取按钮，不需要极高的性能，但许多此类活动确实需要快速处理，以正确读取或写入高频数字信号。不幸的是，高性能操作与 I²C 总线连接往往是相互排斥的。由于有时通过
    MCP230*xx* 设备读取或写入数字数据需要进行三到四次总线事务，这可能导致单次 I/O 操作在 100 kHz 时需要 400 微秒到 500 微秒，得到
    2 kHz 的采样率。这对于某些操作来说可能太慢了。
- en: Fortunately, the MCP230*xx* devices can run at 400 kHz and up to 1.7 MHz as
    well as 100 kHz. At 400 kHz, you can achieve (at least) an 8-kHz sample rate,
    and 10 kHz to 20 kHz is not unreasonable with carefully written code. If you’re
    willing to operate the bus at 1 MHz or more, you could even get the sample rate
    up to around 100 kHz, which is suitable for most applications. If you need higher
    performance, you’ll probably want to use something other than the I²C bus, like
    SPI versions of the MCP230*xx*.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，MCP230*xx* 设备可以在 400 kHz、1.7 MHz 以及 100 kHz 下运行。在 400 kHz 时，你可以实现至少 8 kHz
    的采样率，通过仔细编写代码，10 kHz 到 20 kHz 也不是不可能。如果你愿意以 1 MHz 或更高的频率操作总线，你甚至可以将采样率提高到大约 100
    kHz，这对于大多数应用是合适的。如果你需要更高的性能，可能需要使用 I²C 总线以外的其他方式，比如 MCP230*xx* 的 SPI 版本。
- en: 13.9 MCP23S*xx* Parts
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.9 MCP23S*xx* 部件
- en: 'When searching for information about the MCP23008 and MCP23017 parts, you may
    come across references to the MCP23S08 and MCP23S17 devices. These GPIO expanders
    are nearly identical to the MCP230*xx* parts, except that they were designed for
    use on the SPI bus rather than the I²C bus. Most code written for the MCP23S*xx*
    parts will work fine on the MCP230*xx* devices with minimal modifications: essentially,
    you’d change the code to call I²C library functions rather than SPI library functions
    to write and read data to and from the devices.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在查找关于 MCP23008 和 MCP23017 部件的信息时，你可能会遇到对 MCP23S08 和 MCP23S17 设备的引用。这些 GPIO 扩展器与
    MCP230*xx* 部件几乎相同，唯一的区别是它们是为在 SPI 总线上使用而非 I²C 总线上使用设计的。大部分为 MCP23S*xx* 部件编写的代码，在
    MCP230*xx* 设备上也能正常工作，只需要最少的修改：基本上，你只需要将代码中的 SPI 库函数替换为 I²C 库函数，以便读写设备的数据。
- en: Because the SPI bus operates at a higher frequency than the I²C bus, SPI variants
    can read input data at a higher sampling frequency. For more information, see
    the MCP23*xxx* documentation (which covers both the SPI and I²C parts). Links
    appear in “For More Information.”
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SPI 总线的工作频率高于 I²C 总线，SPI 变体可以以更高的采样频率读取输入数据。欲了解更多信息，请参阅 MCP23*xxx* 文档（该文档涵盖了
    SPI 和 I²C 部件）。相关链接见“更多信息”部分。
- en: 13.10 Chapter Summary
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.10 本章总结
- en: This chapter covered the MCP23017 and MCP23008 GPIO expansion ICs. It described
    the on-chip registers, including the data, data direction, pullup, and polarity
    registers. It described how to read and write digital data via the pins on the
    MCP230*xx*. This chapter also discussed interrupt-driven I/O using the MCP230*xx*
    devices; it presented a short sample program to read a SparkFun rotary encoder
    using an ISR to help avoid missing any pulses from the encoder. Finally, this
    chapter ended by discussing the use of open-software libraries available for the
    MCP230*xx*.*
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 MCP23017 和 MCP23008 GPIO 扩展 IC。内容涵盖了芯片上的寄存器，包括数据寄存器、数据方向寄存器、上拉寄存器和极性寄存器。它描述了如何通过
    MCP230*xx* 的引脚读取和写入数字数据。本章还讨论了使用 MCP230*xx* 设备的中断驱动 I/O，提供了一个简短的示例程序，使用 ISR 读取
    SparkFun 旋转编码器，以帮助避免错过编码器的任何脉冲。最后，本章结束时讨论了为 MCP230*xx* 提供的开源软件库的使用。
