- en: Chapter 64. Pseudoterminals
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第64章. 伪终端
- en: A *pseudoterminal* is a virtual device that provides an IPC channel. On one
    end of the channel is a program that expects to be connected to a terminal device.
    On the other end is a program that drives the terminal-oriented program by using
    the channel to send it input and read its output.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*伪终端*是一个提供IPC通道的虚拟设备。在通道的一端是一个期望连接到终端设备的程序。另一端是一个通过使用通道发送输入并读取输出来驱动终端导向程序的程序。'
- en: This chapter describes the use of pseudoterminals, showing how they are employed
    in applications such as terminal emulators, the *script(1)* program, and programs
    such as *ssh*, which provide network login services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了伪终端的使用，展示了它们如何在诸如终端仿真器、*script(1)* 程序以及提供网络登录服务的程序如*ssh*等应用中发挥作用。
- en: Overview
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: '[Figure 64-1](ch64.html#the_problem_colon_how_to_operate_a_termi "Figure 64-1. The
    problem: how to operate a terminal-oriented program over a network?") illustrates
    one of the problems that pseudoterminals help us solve: how can we enable a user
    on one host to operate a terminal-oriented program (e.g., *vi*) on another host
    connected via a network?'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[图64-1](ch64.html#the_problem_colon_how_to_operate_a_termi "图64-1. 问题：如何在网络上操作终端导向程序？")展示了伪终端帮助我们解决的一个问题：如何使一个主机上的用户能够在通过网络连接的另一台主机上操作终端导向程序（例如，*vi*）？'
- en: As shown in the diagram, by permitting communication over a network, sockets
    provide part of the machinery needed to solve this problem. However, we can’t
    connect the standard input, output, and error of a terminal-oriented program directly
    to a socket. This is because a terminal-oriented program expects to be connected
    to a terminal—to be able to perform the terminal-oriented operations described
    in [Chapter 34](ch34.html "Chapter 34. Process Groups, Sessions, and Job Control")
    and [Chapter 62](ch62.html "Chapter 62. Terminals"). Such operations include placing
    the terminal in noncanonical mode, turning echoing on and off, and setting the
    terminal foreground process group. If a program tries to perform these operations
    on a socket, then the relevant system calls will fail.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，通过允许网络上的通信，套接字提供了解决这个问题所需的部分机制。然而，我们不能将终端导向程序的标准输入、输出和错误直接连接到套接字。这是因为终端导向程序期望连接到一个终端——以便执行在[第34章](ch34.html
    "第34章. 进程组、会话和作业控制")和[第62章](ch62.html "第62章. 终端")中描述的终端操作。这些操作包括将终端置于非规范模式、开关回显功能以及设置终端前台进程组。如果程序尝试在套接字上执行这些操作，相关的系统调用将会失败。
- en: Furthermore, a terminal-oriented program expects a terminal driver to perform
    certain kinds of processing of its input and output. For example, in canonical
    mode, when the terminal driver sees the end-of-file character (normally *Control-D*)
    at the start of a line, it causes the next *read()* to return no data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，终端导向程序期望终端驱动程序执行某些输入输出处理。例如，在规范模式下，当终端驱动程序看到行首的文件结束字符（通常是*Control-D*）时，它会使得下一次*read()*调用返回无数据。
- en: Finally, a terminal-oriented program must have a controlling terminal. This
    allows the program to obtain a file descriptor for the controlling terminal by
    opening `/dev/tty`, and also makes it possible to generate job-control and terminal-related
    signals (e.g., `SIGTSTP`, `SIGTTIN`, and `SIGINT`) for the program.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，终端导向程序必须有一个控制终端。这使得程序能够通过打开`/dev/tty`获得控制终端的文件描述符，同时也使得生成与作业控制和终端相关的信号（例如，`SIGTSTP`、`SIGTTIN`和`SIGINT`）成为可能。
- en: From this description, it should be clear that the definition of a terminal-oriented
    program is quite broad. It encompasses a wide range of programs that we would
    normally run in an interactive terminal session.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个描述中，应该可以清楚地看出终端导向程序的定义非常广泛。它涵盖了我们通常会在交互式终端会话中运行的各种程序。
- en: '![The problem: how to operate a terminal-oriented program over a network?](figs/web/64-1_PTY-problem.png.jpg)Figure 64-1. The
    problem: how to operate a terminal-oriented program over a network?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![问题：如何在网络上操作终端导向程序？](figs/web/64-1_PTY-problem.png.jpg)图64-1. 问题：如何在网络上操作终端导向程序？'
- en: The pseudoterminal master and slave devices
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 伪终端主从设备
- en: 'A pseudoterminal provides the missing link for creating a network connection
    to a terminal-oriented program. A pseudoterminal is a pair of connected virtual
    devices: a *pseudoterminal master* and a *pseudoterminal slave*, sometimes jointly
    referred to as a *pseudoterminal pair*. A pseudoterminal pair provides an IPC
    channel somewhat like a bidirectional pipe—two processes can open the master and
    slave and then transfer data in either direction through the pseudoterminal.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 伪终端提供了创建到终端导向程序的网络连接的缺失环节。伪终端是一对连接的虚拟设备：*伪终端主设备*和*伪终端从设备*，有时统称为*伪终端对*。伪终端对提供了一种IPC通道，类似于双向管道——两个进程可以打开主设备和从设备，然后通过伪终端在任一方向上传输数据。
- en: The key point about a pseudoterminal is that the slave device appears just like
    a standard terminal. All of the operations that can be applied to a terminal device
    can also be applied to a pseudoterminal slave device. Some of these operations
    aren’t meaningful for a pseudoterminal (e.g., setting the terminal line speed
    or parity), but that’s okay, because the pseudoterminal slave silently ignores
    them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关于伪终端的关键点是，从设备看起来就像一个标准终端。所有可以应用于终端设备的操作也可以应用于伪终端从设备。有些操作对于伪终端来说没有意义（例如，设置终端线速或校验位），但这没关系，因为伪终端从设备会默默忽略它们。
- en: How programs use pseudoterminals
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 程序如何使用伪终端
- en: '[Figure 64-2](ch64.html#two_programs_communicating_via_a_pseudot "Figure 64-2. Two
    programs communicating via a pseudoterminal") shows how two programs typically
    employ a pseudoterminal. (The abbreviation *pty* in this diagram is a commonly
    used shorthand for *pseudoterminal*, and we employ this abbreviation in various
    diagrams and function names in this chapter.) The standard input, output, and
    error of the terminal-oriented program are connected to the pseudoterminal slave,
    which is also the controlling terminal for the program. On the other side of the
    pseudoterminal, a driver program acts as a proxy for the user, supplying input
    to the terminal-oriented program and reading that program’s output.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[图64-2](ch64.html#two_programs_communicating_via_a_pseudot "图64-2。两个程序通过伪终端进行通信")展示了两个程序如何典型地使用伪终端。（该图中的*pty*是*伪终端*的常用缩写，我们在本章的各种图示和函数名称中也使用此缩写。）终端导向程序的标准输入、输出和错误连接到伪终端从设备，该设备也成为该程序的控制终端。在伪终端的另一侧，驱动程序充当用户的代理，向终端导向程序提供输入并读取该程序的输出。'
- en: '![Two programs communicating via a pseudoterminal](figs/web/64-2_PTY-pty-scale90.png.jpg)Figure 64-2. Two
    programs communicating via a pseudoterminal'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![通过伪终端进行通信的两个程序](figs/web/64-2_PTY-pty-scale90.png.jpg)图64-2。两个程序通过伪终端进行通信'
- en: Typically, the driver program is simultaneously reading from and writing to
    another I/O channel. It is acting as a relay, passing data in both directions
    between the pseudoterminal and another program. In order to do this, the driver
    program must simultaneously monitor input arriving from either direction. Typically,
    this is done using I/O multiplexing (*select()* or *poll()*), or using a pair
    of processes or threads to perform data transfer in each direction.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，驱动程序同时从另一个I/O通道读取和写入数据。它充当中继，双向传输数据，介于伪终端和另一个程序之间。为了实现这一点，驱动程序必须同时监控来自任一方向的输入。通常，使用I/O多路复用（*select()*或*poll()*），或者使用一对进程或线程来执行每个方向的数据传输。
- en: 'An application that uses a pseudoterminal typically does so as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用伪终端的应用程序通常按以下方式进行：
- en: The driver program opens the pseudoterminal master device.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 驱动程序打开伪终端主设备。
- en: 'The driver program calls *fork()* to create a child process. The child performs
    the following steps:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 驱动程序调用*fork()*来创建一个子进程。子进程执行以下步骤：
- en: Call *setsid()* to start a new session, of which the child is the session leader
    (Section 34.3). This step also causes the child to lose its controlling terminal.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用*setsid()*以启动一个新会话，子进程成为该会话的会话领导（参见第34.3节）。此步骤还使子进程失去其控制终端。
- en: Open the pseudoterminal slave device that corresponds to the master device.
    Since the child process is a session leader, and it doesn’t have a controlling
    terminal, the pseudoterminal slave becomes the controlling terminal for the child
    process.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开与主设备对应的伪终端从设备。由于子进程是会话领导，并且没有控制终端，伪终端从设备成为子进程的控制终端。
- en: Use *dup()* (or similar) to duplicate the file descriptor for the slave device
    on standard input, output, and error.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*dup()*（或类似方法）复制从设备的文件描述符到标准输入、输出和错误。
- en: Call *exec()* to start the terminal-oriented program that is to be connected
    to the pseudoterminal slave.
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用*exec()*来启动要连接到伪终端从设备的面向终端的程序。
- en: At this point, the two programs can now communicate via the pseudoterminal.
    Anything that the driver program writes to the master appears as input to the
    terminal-oriented program on the slave, and anything that the terminal-oriented
    program writes to the slave can be read by the driver program on the master. We
    consider further details of pseudoterminal I/O in Section 64.5.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，两个程序现在可以通过伪终端进行通信。驱动程序写入主设备的任何内容都会作为输入出现在从设备上的面向终端程序中，面向终端程序写入从设备的任何内容都会被主设备上的驱动程序读取。我们将在64.5节中进一步讨论伪终端I/O的细节。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pseudoterminals can also be used to connect an arbitrary pair of processes (i.e.,
    not necessarily a parent and child). All that is required is that the process
    that opens the pseudoterminal master informs the other process of the name of
    the corresponding slave device, perhaps by writing that name to a file or by transmitting
    it using some other IPC mechanism. (When we use *fork()* in the manner described
    above, the child automatically inherits sufficient information from the parent
    to enable it to determine the name of the slave.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 伪终端也可以用来连接任意一对进程（即，不一定是父进程和子进程）。所需要的只是打开伪终端主设备的进程通知另一个进程对应从设备的名称，可能是通过写入文件或使用其他IPC机制传输该名称。（当我们像上述那样使用*fork()*时，子进程会自动继承父进程的足够信息，以便确定从设备的名称。）
- en: 'So far, our discussion of the use of pseudoterminals has been abstract. [Figure 64-3](ch64.html#how_ssh_uses_a_pseudoterminal
    "Figure 64-3. How ssh uses a pseudoterminal") shows a specific example: the use
    of a pseudoterminal by *ssh*, an application that allows a user to securely run
    a login session on a remote system connected via a network. (In effect, this diagram
    combines the information from [Figure 64-1](ch64.html#the_problem_colon_how_to_operate_a_termi
    "Figure 64-1. The problem: how to operate a terminal-oriented program over a network?")
    and [Figure 64-2](ch64.html#two_programs_communicating_via_a_pseudot "Figure 64-2. Two
    programs communicating via a pseudoterminal").) On the remote host, the driver
    program for the pseudoterminal master is the *ssh* server (*sshd*), and the terminal-oriented
    program connected to the pseudoterminal slave is the login shell. The *ssh* server
    is the glue that connects the pseudoterminal via a socket to the *ssh* client.
    Once all of the details of logging in have been completed, the primary purpose
    of the *ssh* server and client is to relay characters in either direction between
    the user’s terminal on the local host and the shell on the remote host.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对伪终端使用的讨论还比较抽象。[图64-3](ch64.html#how_ssh_uses_a_pseudoterminal "图64-3.
    ssh如何使用伪终端")展示了一个具体的例子：*ssh*的伪终端使用，*ssh*是一种允许用户在通过网络连接的远程系统上安全运行登录会话的应用程序。（实际上，这个图表结合了[图64-1](ch64.html#the_problem_colon_how_to_operate_a_termi
    "图64-1. 问题：如何通过网络操作面向终端的程序？")和[图64-2](ch64.html#two_programs_communicating_via_a_pseudot
    "图64-2. 两个程序通过伪终端通信")中的信息。）在远程主机上，伪终端主设备的驱动程序是*ssh*服务器（*sshd*），连接到伪终端从设备的面向终端的程序是登录shell。*ssh*服务器是通过套接字将伪终端连接到*ssh*客户端的“粘合剂”。一旦所有登录的细节完成，*ssh*服务器和客户端的主要功能就是在本地主机的用户终端与远程主机的shell之间双向传递字符。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We omit describing many details of the *ssh* client and server. For example,
    these programs encrypt the data transmitted in either direction across the network.
    We show a single *ssh* server process on the remote host, but, in fact, the *ssh*
    server is a concurrent network server. It becomes a daemon and creates a passive
    TCP socket to listen for incoming connections from *ssh* clients. For each connection,
    the master *ssh* server forks a child process that handles all of the details
    for a single client login session. (We refer to this child process as the *ssh*
    server in [Figure 64-3](ch64.html#how_ssh_uses_a_pseudoterminal "Figure 64-3. How
    ssh uses a pseudoterminal").) Aside from the details of pseudoterminal setup described
    above, the *ssh* server child authenticates the user, updates the login accounting
    files on the remote host (as described in [Chapter 40](ch40.html "Chapter 40. Login
    Accounting")), and then execs the login shell.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了对*ssh*客户端和服务器的许多细节描述。例如，这些程序会加密在网络中任何方向上传输的数据。我们展示了一个位于远程主机的单个*ssh*服务器进程，但实际上，*ssh*服务器是一个并发的网络服务器。它变成一个守护进程，并创建一个被动的
    TCP 套接字来监听来自*ssh*客户端的传入连接。对于每个连接，主*ssh*服务器会分叉出一个子进程，处理单个客户端登录会话的所有细节。（我们在[图64-3](ch64.html#how_ssh_uses_a_pseudoterminal
    "图64-3. 如何使用伪终端的ssh")中将这个子进程称为*ssh*服务器。）除了上述伪终端设置的细节外，*ssh*服务器子进程还会进行用户认证，更新远程主机上的登录帐户文件（如[第40章](ch40.html
    "第40章。登录帐户")中所描述），然后执行登录 shell。
- en: '![How ssh uses a pseudoterminal](figs/web/64-3_PTY-ssh-login.png.jpg)Figure 64-3. How
    *ssh* uses a pseudoterminal'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![How ssh uses a pseudoterminal](figs/web/64-3_PTY-ssh-login.png.jpg)图64-3.
    *ssh*如何使用伪终端'
- en: In some cases, multiple processes may be connected to the slave side of the
    pseudoterminal. Our *ssh* example illustrates this point. The session leader for
    the slave is a shell, which creates process groups to execute the commands entered
    by the remote user. All of these processes have the pseudoterminal slave as their
    controlling terminal. As with a conventional terminal, one of these process groups
    can be the foreground process group for the pseudoterminal slave, and only this
    process group is allowed to read from the slave and (if the `TOSTOP` bit has been
    set) write to it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，多个进程可能连接到伪终端的从端。我们的*ssh*示例说明了这一点。对于从端的会话领导者是一个 shell，它创建进程组来执行远程用户输入的命令。所有这些进程都将伪终端从端作为它们的控制终端。与传统终端一样，这些进程组中的一个可以是伪终端从端的前台进程组，只有这个进程组被允许从从端读取（如果已设置`TOSTOP`位），并且（如果设置了`TOSTOP`位）写入到从端。
- en: Applications of pseudoterminals
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 伪终端的应用
- en: 'Pseudoterminals are also used in many applications other than network services.
    Examples include the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 伪终端也用于许多除了网络服务以外的应用程序。以下是一些例子：
- en: The *expect(1)* program uses a pseudoterminal to allow an interactive terminal-oriented
    program to be driven from a script file.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*expect(1)*程序使用伪终端允许一个交互式的终端导向程序通过脚本文件驱动。'
- en: Terminal emulators such as *xterm* employ pseudoterminals to provide the terminal-related
    functionality that goes with a terminal window.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端仿真器，如*xterm*，使用伪终端来提供与终端窗口相关的终端功能。
- en: The *screen(1)* program uses pseudoterminals to multiplex a single physical
    terminal (or terminal window) between multiple processes (e.g., multiple shell
    sessions).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*screen(1)*程序使用伪终端来在多个进程（例如多个 shell 会话）之间复用一个物理终端（或终端窗口）。'
- en: Pseudoterminals are used in the *script(1)* program, which records all of the
    input and output that occurs during a shell session.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪终端用于*script(1)*程序，该程序记录在 shell 会话期间发生的所有输入和输出。
- en: Sometimes a pseudoterminal is useful to circumvent the default block buffering
    performed by the *stdio* functions when writing output to a disk file or pipe,
    as opposed to the line buffering used for terminal output. (We consider this point
    further in Exercise 64-7.)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，伪终端可以绕过*stdio*函数在将输出写入磁盘文件或管道时执行的默认块缓冲区，而使用终端输出所用的行缓冲区。（我们将在习题64-7中进一步讨论这个问题。）
- en: System V (UNIX 98) and BSD pseudoterminals
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: System V (UNIX 98) 和 BSD 伪终端
- en: BSD and System V provided different interfaces for finding and opening the two
    halves of a pseudoterminal pair. The BSD pseudoterminal implementation was historically
    the better known, since it was used with many sockets-based network applications.
    For compatibility reasons, many UNIX implementations eventually came to support
    both styles of pseudoterminals.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: BSD 和 System V 提供了不同的接口来查找和打开伪终端对的两端。BSD 伪终端实现历史上更为人所知，因为它与许多基于套接字的网络应用一起使用。出于兼容性原因，许多
    UNIX 实现最终支持了这两种风格的伪终端。
- en: The System V interface is somewhat simpler to use than the BSD interface, and
    the SUSv3 specification of pseudoterminals is based on the System V interface.
    (A pseudoterminal specification first appeared in SUSv1.) For historical reasons,
    on Linux systems, this type of pseudoterminal is commonly referred to as a *UNIX
    98* pseudoterminal, even though the UNIX 98 standard (i.e., SUSv2) required pseudoterminals
    to be STREAMS-based, and the Linux implementation of pseudoterminals is not. (SUSv3
    doesn’t require a STREAMS-based implementation.)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: System V 接口的使用方式比 BSD 接口更简单，且 SUSv3 伪终端规范基于 System V 接口。（伪终端规范首次出现在 SUSv1 中。）出于历史原因，在
    Linux 系统中，这种类型的伪终端通常被称为 *UNIX 98* 伪终端，尽管 UNIX 98 标准（即 SUSv2）要求伪终端必须基于 STREAMS，而
    Linux 对伪终端的实现并不是基于 STREAMS 的。（SUSv3 不要求基于 STREAMS 的实现。）
- en: Early versions of Linux supported only BSD-style pseudoterminals, but, since
    kernel 2.2, Linux has supported both types of pseudoterminals. In this chapter,
    we focus on UNIX 98 pseudoterminals. We describe the differences for BSD pseudoterminals
    in Section 64.8.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本的 Linux 仅支持 BSD 风格的伪终端，但从内核 2.2 开始，Linux 同时支持这两种类型的伪终端。本章我们主要关注 UNIX 98
    伪终端。有关 BSD 伪终端的差异，请参见第 64.8 节。
- en: UNIX 98 Pseudoterminals
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UNIX 98伪终端
- en: 'Bit by bit, we’ll work toward the development of a function, *ptyFork()*, that
    does most of the work to create the setup shown in [Figure 64-2](ch64.html#two_programs_communicating_via_a_pseudot
    "Figure 64-2. Two programs communicating via a pseudoterminal"). We’ll then use
    this function to implement the *script(1)* program. Before doing this though,
    we look at the various library functions used with UNIX 98 pseudoterminals:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一步一步地，我们将开发一个函数 *ptyFork()*，它完成创建如[图 64-2](ch64.html#two_programs_communicating_via_a_pseudot
    "图 64-2. 两个程序通过伪终端进行通信")所示的设置的大部分工作。然后，我们将使用这个函数来实现 *script(1)* 程序。在此之前，我们先来看一下与
    UNIX 98 伪终端相关的各种库函数：
- en: The *posix_openpt()* function opens an unused pseudoterminal master device,
    returning a file descriptor that is used to refer to the device in later calls.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*posix_openpt()* 函数打开一个未使用的伪终端主设备，返回一个文件描述符，用于后续调用中引用该设备。'
- en: The *grantpt()* function changes the ownership and permissions of the slave
    device corresponding to a pseudoterminal master device.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*grantpt()* 函数更改与伪终端主设备对应的从设备的所有权和权限。'
- en: The *unlockpt()* function unlocks the slave device corresponding to a pseudoterminal
    master device, so that the slave device can be opened.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*unlockpt()* 函数解锁与伪终端主设备对应的从设备，使得从设备可以被打开。'
- en: The *ptsname()* function returns the name of the slave device corresponding
    to a pseudoterminal master device. The slave device can then be opened using *open()*.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ptsname()* 函数返回与伪终端主设备对应的从设备的名称。然后可以使用 *open()* 打开该从设备。'
- en: 'Opening an Unused Master: *posix_openpt()*'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开未使用的主设备：*posix_openpt()*
- en: The *posix_openpt()* function finds and opens an unused pseudoterminal master
    device, and returns a file descriptor that can later be used to refer to this
    device.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*posix_openpt()* 函数查找并打开一个未使用的伪终端主设备，返回一个文件描述符，可以在后续中用来引用该设备。'
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns file descriptor on success, or -1 on error
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回文件描述符，出错时返回 -1
- en: 'The *flags* argument is constructed by ORing zero or more of the following
    constants together:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*flags* 参数是通过按位或操作将以下常量中的零个或多个组合在一起构造的：'
- en: '`O_RDWR`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_RDWR`'
- en: Open the device for both reading and writing. Normally, we would always include
    this constant in *flags*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 打开设备用于读写。通常情况下，我们总是会在 *flags* 中包含这个常量。
- en: '`O_NOCTTY`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_NOCTTY`'
- en: Don’t make this terminal the controlling terminal for the process. On Linux,
    a pseudoterminal master can’t become a controlling terminal for a process, regardless
    of whether the `O_NOCTTY` flag is specified when calling *posix_openpt()*. (This
    makes sense because the pseudoterminal master isn’t really a terminal; it is the
    other side of a terminal to which the slave is connected.) However, on some implementations,
    `O_NOCTTY` is required if we want to prevent a process from acquiring a controlling
    terminal as a consequence of opening a pseudoterminal master device.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让这个终端成为进程的控制终端。在Linux中，伪终端主设备无法成为进程的控制终端，无论在调用*posix_openpt()*时是否指定了`O_NOCTTY`标志。（这是有道理的，因为伪终端主设备并不是真正的终端；它是与从设备连接的终端的另一端。）然而，在一些实现中，如果我们希望防止进程因打开伪终端主设备而获得控制终端，则需要使用`O_NOCTTY`。
- en: Like *open()*, *posix_openpt()* uses the lowest available file descriptor to
    open the pseudoterminal master.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 和*open()*一样，*posix_openpt()*使用最低可用的文件描述符来打开伪终端主设备。
- en: Calling *posix_openpt()* also results in the creation of a corresponding pseudoterminal
    slave device file in the `/dev/pts` directory. We say more about this file when
    we describe the *ptsname()* function below.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 调用*posix_openpt()*还会在`/dev/pts`目录中创建一个对应的伪终端从设备文件。当我们在下面描述*ptsname()*函数时，会进一步介绍该文件。
- en: 'The *posix_openpt()* function is new in SUSv3, and was an invention of the
    POSIX committee. In the original System V pseudoterminal implementation, obtaining
    an available pseudoterminal master was accomplished by opening the *pseudoterminal
    master clone device*, `/dev/ptmx`. Opening this virtual device automatically locates
    and opens the next unused pseudoterminal master, and returns a file descriptor
    for it. This device is provided on Linux, where *posix_openpt()* is implemented
    as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*posix_openpt()*函数是SUSv3中新增加的，由POSIX委员会发明。在原始的System V伪终端实现中，通过打开*伪终端主设备克隆设备*`/dev/ptmx`来获取一个可用的伪终端主设备。打开这个虚拟设备会自动定位并打开下一个未使用的伪终端主设备，并返回其文件描述符。Linux提供了这个设备，其中*posix_openpt()*实现如下：'
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Limits on the number of UNIX 98 pseudoterminals
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: UNIX 98伪终端数量限制
- en: Because each pseudoterminal pair in use consumes a small amount of nonswappable
    kernel memory, the kernel imposes a limit on the number of UNIX 98 pseudoterminal
    pairs on the system. In kernels up to 2.6.3, this limit is controlled by a kernel
    configuration option (`CONFIG_UNIX98_PTYS`). The default value for this option
    is 256, but we can change the limit to any value in the range 0 to 2048.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每对使用中的伪终端都会消耗少量不可交换的内核内存，内核会对系统中的UNIX 98伪终端对数量进行限制。在2.6.3版本之前的内核中，该限制由内核配置选项（`CONFIG_UNIX98_PTYS`）控制。该选项的默认值为256，但我们可以将限制更改为0到2048之间的任何值。
- en: From Linux 2.6.4 onward, the `CONFIG_UNIX98_PTYS` kernel configuration option
    is discarded in favor of a more flexible approach. Instead, the limit on the number
    of pseudoterminals is defined by the value in the Linux-specific `/proc/sys/kernel/pty/max`
    file. The default value for this file is 4096, and it can be set to any value
    up to 1,048,576. A related read-only file, `/proc/sys/kernel/pty/nr`, shows how
    many UNIX 98 pseudoterminals are currently in use.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux 2.6.4版本开始，`CONFIG_UNIX98_PTYS`内核配置选项被弃用，改为采用更灵活的方法。相反，伪终端的数量限制由Linux特定的`/proc/sys/kernel/pty/max`文件中的值定义。该文件的默认值为4096，且可以设置为最大1,048,576。一个相关的只读文件`/proc/sys/kernel/pty/nr`显示当前正在使用的UNIX
    98伪终端数量。
- en: 'Changing Slave Ownership and Permissions: *grantpt()*'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改从设备所有权和权限：*grantpt()*
- en: SUSv3 specifies the use of *grantpt()* to change the ownership and permissions
    of the slave device that corresponds to the pseudoterminal master referred to
    by the file descriptor *mfd*. On Linux, calling *grantpt()* is not actually necessary.
    However, the use of *grantpt()* is required on some implementations, and portable
    applications should call it after calling *posix_openpt()*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3规范要求使用*grantpt()*来更改与文件描述符*mfd*引用的伪终端主设备对应的从设备的所有权和权限。在Linux上，实际上调用*grantpt()*并不是必要的。然而，在某些实现中，必须使用*grantpt()*，因此便携式应用程序在调用*posix_openpt()*之后应当调用它。
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: 'On systems where *grantpt()* is required, this function creates a child process
    that executes a set-user-ID-*root* program. This program, usually called *pt_chown*,
    performs the following operations on the pseudoterminal slave device:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要*grantpt()*的系统中，这个函数会创建一个子进程，该子进程执行一个设置用户 ID 为*root*的程序。这个程序通常叫做*pt_chown*，它对伪终端从设备执行以下操作：
- en: change the ownership of the slave to be the same as the effective user ID of
    the calling process;
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改从设备的所有权，使其与调用进程的有效用户 ID 相同；
- en: change the group of the slave to *tty*; and
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将从设备的组更改为*tty*；并且
- en: change the permissions on the slave so that the owner has read and write permissions,
    and group has write permission.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改从设备的权限，使得所有者具有读写权限，组具有写权限。
- en: The reason for changing the group of the terminal to *tty* and enabling group
    write permission is that the *wall(1)* and *write(1)* programs are set-group-ID
    programs owned by the *tty* group.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 更改终端的组为*tty*并启用组写权限的原因是，*wall(1)*和*write(1)*程序是由*tty*组拥有的设置组 ID 程序。
- en: On Linux, a pseudoterminal slave is automatically configured in the above manner,
    which is why calling *grantpt()* isn’t needed (but still should be done).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，伪终端从设备会自动按上述方式配置，这就是为什么不需要调用*grantpt()*（但仍然应该调用）的原因。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because it may create a child process, SUSv3 says that the behavior of *grantpt()*
    is unspecified if the calling program has installed a handler for `SIGCHLD`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能会创建子进程，SUSv3 规定，如果调用程序已为`SIGCHLD`安装了处理程序，则*grantpt()*的行为未指定。
- en: 'Unlocking the Slave: *unlockpt()*'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解锁从设备：*unlockpt()*
- en: The *unlockpt()* function removes an internal lock on the slave corresponding
    to the pseudoterminal master referred to by the file descriptor *mfd*. The purpose
    of this locking mechanism is to allow the calling process to perform whatever
    initialization is required for the pseudoterminal slave (e.g., calling *grantpt()*)
    before another process is allowed to open it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*unlockpt()*函数会移除与由文件描述符*mfd*引用的伪终端主设备对应的从设备上的内部锁。这个锁机制的目的是允许调用进程在其他进程能够打开它之前，执行伪终端从设备所需的初始化（例如，调用*grantpt()*）。'
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，错误时返回-1
- en: An attempt to open a pseudoterminal slave before it has been unlocked with *unlockpt()*
    fails with the error `EIO`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在伪终端从设备被*unlockpt()*解锁之前尝试打开它会失败，并返回错误`EIO`。
- en: 'Obtaining the Name of the Slave: *ptsname()*'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取从设备的名称：*ptsname()*
- en: The *ptsname()* function returns the name of the pseudoterminal slave corresponding
    to the pseudoterminal master referred to by the file descriptor *mfd*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*ptsname()*函数返回与文件描述符*mfd*引用的伪终端主设备对应的伪终端从设备名称。'
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to (possibly statically allocated) string on success, or NULL
    on error
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指向（可能是静态分配的）字符串的指针，出错时返回NULL。
- en: On Linux (as on most implementations), *ptsname()* returns a name of the form
    /`dev/pts/`*nn*, where *nn* is replaced by a number that uniquely identifies this
    pseudoterminal slave.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统（与大多数实现相同）上，*ptsname()*返回一个形如`/dev/pts/`*nn*的名称，其中*nn*被一个唯一标识此伪终端从设备的数字替换。
- en: The buffer used to return the slave name is normally statically allocated. It
    is thus overwritten by subsequent calls to *ptsname()*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 用于返回从设备名称的缓冲区通常是静态分配的。因此，它会被后续对*ptsname()*的调用覆盖。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The GNU C library provides a reentrant analog of *ptsname()* in the form of
    *ptsname_r(mfd, strbuf, buflen)*. However, this function is nonstandard and is
    available on few other UNIX implementations. The `_GNU_SOURCE` feature test macro
    must be defined in order to obtain the declaration of *ptsname_r()* from `<stdlib.h>`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: GNU C 库提供了一个可重入的*ptsname()*模拟函数，形式为*ptsname_r(mfd, strbuf, buflen)*。然而，这个函数是非标准的，并且仅在少数其他
    UNIX 实现中可用。必须定义`_GNU_SOURCE`功能测试宏，才能从`<stdlib.h>`中获取*ptsname_r()*的声明。
- en: Once we have unlocked the slave device with *unlockpt()*, we can open it using
    the traditional *open()* system call.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用*unlockpt()*解锁了从设备，就可以通过传统的*open()*系统调用来打开它。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On System V derivatives that employ STREAMS, it may be necessary to perform
    some further steps (pushing STREAMS modules onto the slave device after opening
    it). An example of how to perform these steps can be found in [Stevens & Rago,
    2005].
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 STREAMS 的 System V 衍生版本中，可能需要执行一些进一步的步骤（在打开从设备后，将 STREAMS 模块推送到从设备上）。可以在[Stevens
    & Rago, 2005]中找到如何执行这些步骤的示例。
- en: 'Opening a Master: *ptyMasterOpen()*'
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开主设备：*ptyMasterOpen()*
- en: 'We now present a function, *ptyMasterOpen()*, that employs the functions described
    in the previous sections to open a pseudoterminal master and obtain the name of
    the corresponding pseudoterminal slave. Our reasons for providing such a function
    are twofold:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在介绍一个函数，*ptyMasterOpen()*，它利用前面部分中描述的函数来打开一个伪终端主设备并获取相应伪终端从设备的名称。我们提供这个函数的原因有两个：
- en: Most programs perform these steps in exactly the same way, so it is convenient
    to encapsulate them in a single function.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数程序以完全相同的方式执行这些步骤，因此将它们封装在一个函数中是很方便的。
- en: Our *ptyMasterOpen()* function hides all of the details that are specific to
    UNIX 98 pseudoterminals. In Section 64.8, we present a reimplementation of this
    function that uses BSD-style pseudoterminals. All of the code that we present
    in the remainder of this chapter can work with either of these implementations.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 *ptyMasterOpen()* 函数隐藏了所有与UNIX 98伪终端特定的细节。在第64.8节中，我们介绍了一个重新实现的函数，使用BSD风格的伪终端。我们在本章余下部分展示的所有代码都可以与这两种实现配合使用。
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns file descriptor on success, or -1 on error
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回文件描述符，失败时返回 -1。
- en: The *ptyMasterOpen()* function opens an unused pseudoterminal master, calls
    *grantpt()* and *unlockpt()* on it, and copies the name of the corresponding pseudoterminal
    slave into the buffer pointed to by *slaveName*. The caller must specify the amount
    of space available in this buffer in the argument *snLen*. We show the implementation
    of this function in [Example 64-1](ch64.html#implementation_of_ptymasteropen_open_par
    "Example 64-1. Implementation of ptyMasterOpen()").
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*ptyMasterOpen()* 函数打开一个未使用的伪终端主设备，在其上调用 *grantpt()* 和 *unlockpt()*，并将相应伪终端从设备的名称复制到
    *slaveName* 指向的缓冲区中。调用者必须在参数 *snLen* 中指定此缓冲区中可用的空间大小。我们在[示例64-1](ch64.html#implementation_of_ptymasteropen_open_par
    "示例64-1. *ptyMasterOpen()* 的实现")中展示了此函数的实现。'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It would be equally possible to omit the use of the *slaveName* and *snLen*
    arguments, and have the caller of *ptyMasterOpen()* call *ptsname()* directly
    in order to obtain the name of the pseudoterminal slave. However, we employ the
    *slaveName* and *snLen* arguments because BSD pseudoterminals don’t provide an
    equivalent of the *ptsname()* function, and our implementation of the equivalent
    function for BSD-style pseudoterminals ([Example 64-4](ch64.html#implementation_of_ptymasteropen_open
    "Example 64-4. Implementation of ptyMasterOpen() using BSD pseudoterminals"))
    encapsulates the BSD technique for obtaining the name of the slave.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同样也可以省略 *slaveName* 和 *snLen* 参数，让 *ptyMasterOpen()* 的调用者直接调用 *ptsname()* 来获取伪终端从设备的名称。然而，我们使用
    *slaveName* 和 *snLen* 参数，是因为BSD伪终端没有提供 *ptsname()* 函数的等效函数，我们为BSD风格伪终端实现的等效函数（见[示例64-4](ch64.html#implementation_of_ptymasteropen_open
    "示例64-4. 使用BSD伪终端实现 *ptyMasterOpen()*")）封装了获取从设备名称的BSD技术。
- en: Example 64-1. Implementation of *ptyMasterOpen()*
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 示例64-1. *ptyMasterOpen()* 实现
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Connecting Processes with a Pseudoterminal: *ptyFork()*'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用伪终端连接进程：*ptyFork()*
- en: We are now ready to implement a function that does all of the work of setting
    up a connection between two processes using a pseudoterminal pair, as shown in
    [Figure 64-2](ch64.html#two_programs_communicating_via_a_pseudot "Figure 64-2. Two
    programs communicating via a pseudoterminal"). The *ptyFork()* function creates
    a child process that is connected to the parent by a pseudoterminal pair.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备实现一个函数，使用伪终端对建立两个进程之间的连接执行所有工作，如[图64-2](ch64.html#two_programs_communicating_via_a_pseudoterminal
    "图64-2. 两个程序通过伪终端进行通信")所示。*ptyFork()* 函数创建一个子进程，该进程通过伪终端对与父进程连接。
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In parent: returns process ID of child on success, or -1 on error; in successfully
    created child: always returns 0'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在父进程中：成功时返回子进程的进程ID，失败时返回 -1；在成功创建的子进程中：始终返回 0。
- en: 'The implementation of *ptyFork()* is shown in [Example 64-2](ch64.html#implementation_of_ptyfork_open_parenthes
    "Example 64-2. Implementation of ptyFork()"). This function performs the following
    steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*ptyFork()* 的实现见[示例64-2](ch64.html#implementation_of_ptyfork_open_parenthes
    "示例64-2. *ptyFork()* 的实现")。此函数执行以下步骤：'
- en: Open a pseudoterminal master using *ptyMasterOpen()* ([Example 64-1](ch64.html#implementation_of_ptymasteropen_open_par
    "Example 64-1. Implementation of ptyMasterOpen()")) ![](figs/web/U001.png).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *ptyMasterOpen()* 打开伪终端主设备（见[示例64-1](ch64.html#implementation_of_ptymasteropen_open_par
    "示例64-1. *ptyMasterOpen()* 的实现")） ![](figs/web/U001.png)。
- en: If the *slaveName* argument is not `NULL`, copy the name of the pseudoterminal
    slave into this buffer ![](figs/web/U002.png). (If *slaveName* is not `NULL`,
    then it must point to a buffer of at least *snLen* bytes.) The caller can use
    this name to update the login accounting files ([Chapter 40](ch40.html "Chapter 40. Login
    Accounting")), if appropriate. Updating the login accounting files would be appropriate
    for applications that provide login services—for example, *ssh*, *rlogin*, and
    *telnet*. On the other hand, programs such as *script(1)* (Section 64.6) do not
    update the login accounting files, because they don’t provide login services.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*slaveName*参数非`NULL`，则将伪终端从设备的名称复制到此缓冲区！[](figs/web/U002.png)。 （如果*slaveName*不为`NULL`，则它必须指向至少*snLen*字节的缓冲区。）调用者可以使用此名称更新登录帐户文件（[第40章](ch40.html
    "第40章。登录帐户")），如果适用的话。更新登录帐户文件对于提供登录服务的应用程序是合适的——例如，*ssh*、*rlogin*和*telnet*。另一方面，像*script(1)*（第64.6节）这样的程序不更新登录帐户文件，因为它们不提供登录服务。
- en: Call *fork()* to create a child process ![](figs/web/U003.png).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用*fork()*创建子进程！[](figs/web/U003.png)。
- en: All that the parent does after the *fork()* is to ensure that the file descriptor
    for the pseudoterminal master is returned to the caller in the integer pointed
    to by *masterFd* ![](figs/web/U004.png).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*fork()*之后，父进程所做的唯一事情就是确保将伪终端主设备的文件描述符返回给调用者，该文件描述符存储在*masterFd*指向的整数中！[](figs/web/U004.png)。
- en: 'After the *fork()*, the child performs the following steps:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*fork()*之后，子进程执行以下步骤：
- en: Call *setsid()*, to create a new session (Section 34.3) ![](figs/web/U005.png).
    The child is the leader of the new session and loses its controlling terminal
    (if it had one).
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用*setsid()*，创建一个新会话（第34.3节）！[](figs/web/U005.png)。子进程成为新会话的会话领导者，并失去其控制终端（如果它曾有的话）。
- en: Close the file descriptor for the pseudoterminal master, since it is not required
    in the child ![](figs/web/U006.png).
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭伪终端主设备的文件描述符，因为子进程不再需要它！[](figs/web/U006.png)。
- en: Open the pseudoterminal slave ![](figs/web/U007.png). Since the child lost its
    controlling terminal in the previous step, this step causes the pseudoterminal
    slave to become the controlling terminal for the child.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开伪终端从设备！[](figs/web/U007.png)。由于子进程在前一步中失去了控制终端，这一步骤使得伪终端从设备成为子进程的控制终端。
- en: If the `TIOCSCTTY` macro is defined, perform a `TIOCSCTTY` *ioctl()* operation
    on the file descriptor for the pseudoterminal slave ![](figs/web/U008.png). This
    code allows our *ptyFork()* function to work on BSD platforms, where a controlling
    terminal can be acquired only as a consequence of an explicit `TIOCSCTTY` operation
    (refer to Section 34.4).
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果定义了`TIOCSCTTY`宏，则在伪终端从设备的文件描述符上执行`TIOCSCTTY` *ioctl()*操作！[](figs/web/U008.png)。这段代码使我们的*ptyFork()*函数能够在BSD平台上运行，在这些平台上，控制终端只能通过显式的`TIOCSCTTY`操作获得（参见第34.4节）。
- en: If the *slaveTermios* argument is non-`NULL`, call *tcsetattr()* to set the
    terminal attributes of the slave to the values in the *termios* structure pointed
    to by this argument ![](figs/web/U009.png). Use of this argument is a convenience
    for certain interactive programs (e.g., *script(1)*) that use a pseudoterminal
    and need to set the attributes of the slave device to be the same as those of
    the terminal under which the program is run.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*slaveTermios*参数非`NULL`，则调用*tcsetattr()*，将伪终端从设备的终端属性设置为*termios*结构中由此参数指向的值！[](figs/web/U009.png)。该参数的使用便于某些交互式程序（例如，*script(1)*)，这些程序使用伪终端，并需要将从设备的属性设置为与程序运行所在终端的属性相同。
- en: If the *slaveWS* argument is non-`NULL`, perform an *ioctl()* `TIOCSWINSZ` operation
    to set the window size of the pseudoterminal slave to the values in the *winsize*
    structure pointed to by this argument ![](figs/web/U010.png). This step is performed
    for the same reason as the previous step.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*slaveWS*参数非`NULL`，则执行*ioctl()* `TIOCSWINSZ`操作，将伪终端从设备的窗口大小设置为*winsize*结构中由此参数指向的值！[](figs/web/U010.png)。此步骤与前一步执行的原因相同。
- en: Use *dup2()* to duplicate the slave file descriptor to be the standard input,
    output, and error for the child ![](figs/web/U011.png). At this point, the child
    can now exec an arbitrary program, and that program can use the standard file
    descriptors to communicate with the pseudoterminal. The execed program can perform
    all of the usual terminal-oriented operations that can be performed by a program
    running on a conventional terminal.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*dup2()*将从端文件描述符复制为子进程的标准输入、输出和错误输出！[](figs/web/U011.png)。此时，子进程可以执行任何程序，而该程序可以使用标准文件描述符与伪终端进行通信。执行的程序可以执行所有通常由在常规终端上运行的程序执行的终端操作。
- en: As with *fork()*, *ptyFork()* returns the process ID of the child in the parent
    process, 0 in the child process, or -1 on error.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 和*fork()*一样，*ptyFork()*在父进程中返回子进程的进程ID，在子进程中返回0，或者在出错时返回-1。
- en: Eventually, the child process created by *ptyFork()* will terminate. If the
    parent doesn’t terminate at the same time, then it must wait on the child to eliminate
    the resulting zombie. However, this step can often be eliminated, since applications
    that employ pseudoterminals are commonly designed so that the parent does terminate
    at the same time as the child.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，通过*ptyFork()*创建的子进程将会终止。如果父进程没有同时终止，那么它必须等待子进程以消除产生的僵尸进程。然而，这一步通常可以省略，因为使用伪终端的应用程序通常设计为父进程在子进程结束时也会终止。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: BSD derivatives provide two related, nonstandard functions for working with
    pseudoterminals. The first of these is *openpty()*, which opens a pseudoterminal
    pair, returns the file descriptors for the master and slave, optionally returns
    the name of the slave device, and optionally sets the terminal attributes and
    window size from arguments analogous to *slaveTermios* and *slaveWS*. The other
    function, *forkpty()*, is the same as our *ptyFork()*, except that it doesn’t
    provide an analog of the *snLen* argument. On Linux, both of these functions are
    provided by *glibc* and are documented in the *openpty(3)* manual page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: BSD衍生系统提供了两个相关的非标准函数用于与伪终端交互。其中第一个是*openpty()*，它打开一个伪终端对，返回主端和从端的文件描述符，选项上返回从端设备的名称，并可以根据类似于*slaveTermios*和*slaveWS*的参数设置终端属性和窗口大小。另一个函数是*forkpty()*，它与我们的*ptyFork()*相同，只是没有提供*snLen*参数的类似物。在Linux上，这两个函数由*glibc*提供，并在*openpty(3)*手册页中有文档说明。
- en: Example 64-2. Implementation of *ptyFork()*
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 示例64-2. *ptyFork()*的实现
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Pseudoterminal I/O
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪终端输入输出
- en: A pseudoterminal pair is similar to a bidirectional pipe. Anything that is written
    on the master appears as input on the slave, and anything that is written on the
    slave appears as input on the master.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 伪终端对是一种类似于双向管道的结构。写入主端的任何内容会作为输入出现在从端，而写入从端的任何内容会作为输入出现在主端。
- en: The point that distinguishes a pseudoterminal pair from a bidirectional pipe
    is that the slave side operates like a terminal device. The slave interprets input
    in the same way as a normal controlling terminal would interpret keyboard input.
    For example, if we write a *Control-C* character (the usual terminal *interrupt*
    character) to the pseudoterminal master, the slave will generate a `SIGINT` signal
    for its foreground process group. Just as with a conventional terminal, when a
    pseudoterminal slave operates in canonical mode (the default), input is buffered
    line by line. In other words, the program reading from the pseudoterminal slave
    will see (a line of) input only when we write a newline character to the pseudoterminal
    master.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 区分伪终端对和双向管道的关键点在于，从端像终端设备一样操作。从端按与普通控制终端相同的方式解释输入。例如，如果我们将*Control-C*字符（通常终端的*中断*字符）写入伪终端主端，从端将为其前台进程组生成一个`SIGINT`信号。就像常规终端一样，当伪终端从端以规范模式（默认模式）操作时，输入会逐行缓冲。换句话说，程序从伪终端从端读取时，只有在我们向伪终端主端写入换行符时，它才会看到（一行）输入。
- en: Like pipes, pseudoterminals have a limited capacity. If we exhaust this capacity,
    then further writes are blocked until the process on the other side of the pseudoterminal
    has consumed some bytes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 像管道一样，伪终端有一个有限的容量。如果我们耗尽了这个容量，那么进一步的写入操作会被阻塞，直到伪终端另一端的进程消费了一些字节。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, the pseudoterminal capacity is about 4 kB in each direction.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，伪终端的容量大约是每个方向4 KB。
- en: 'If we close all file descriptors referring to the pseudoterminal master, then:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们关闭所有指向伪终端主端的文件描述符，那么：
- en: If the slave device has a controlling process, a `SIGHUP` signal is sent to
    that process (see Section 34.6).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果从设备有控制进程，则会向该进程发送`SIGHUP`信号（见第34.6节）。
- en: A *read()* from the slave device returns end-of-file (0).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从从属设备的*read()*返回文件结束符（0）。
- en: A *write()* to the slave device fails with the error `EIO`. (On some other UNIX
    implementations, *write()* fails with the error `ENXIO` in this case.)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向从设备的*write()*失败，错误为`EIO`。（在某些其他UNIX实现中，这种情况下*write()*会失败并返回错误`ENXIO`。）
- en: 'If we close all file descriptors referring to the pseudoterminal slave, then:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们关闭所有引用伪终端从设备的文件描述符，则：
- en: A *read()* from the master device fails with the error `EIO`. (On some other
    UNIX implementations, a *read()* returns end-of-file in this case.)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主设备的*read()*失败，并返回错误`EIO`。（在某些其他UNIX实现中，这种情况下*read()*会返回文件结束符。）
- en: A *write()* to the master device succeeds, unless the input queue of the slave
    device is full, in which case the *write()* blocks. If the slave device is subsequently
    reopened, these bytes can be read.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向主设备的*write()*成功，除非从设备的输入队列已满，在这种情况下，*write()*会阻塞。如果从设备随后被重新打开，则这些字节可以被读取。
- en: UNIX implementations vary widely in their behavior for the last case. On some
    UNIX implementations, *write()* fails with the error `EIO`. On other implementations,
    *write()* succeeds, but the output bytes are discarded (i.e., they can’t be read
    if the slave is reopened). In general, these variations don’t present a problem.
    Normally, the process on the master side detects that the slave has been closed
    because a *read()* from the master returns end-of-file or fails. At this point,
    the process performs no further writes to the master.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX实现的行为在最后一种情况下差异很大。在某些UNIX实现中，*write()*会因错误`EIO`而失败。在其他实现中，*write()*会成功，但输出字节会被丢弃（即，如果重新打开从设备，则无法读取）。通常，这些差异不会造成问题。通常，主侧的进程会检测到从设备已经关闭，因为主设备的*read()*返回文件结束符或失败。此时，进程不会再向主设备执行写操作。
- en: Packet mode
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据包模式
- en: '*Packet mode* is a mechanism that allows the process running above a pseudoterminal
    master to be informed when the following events related to software flow control
    occur on the pseudoterminal slave:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据包模式*是一种机制，允许在伪终端主设备上运行的进程在以下与软件流控制相关的事件发生时，得到伪终端从设备的通知：'
- en: the input or output queue is flushed;
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入或输出队列被刷新；
- en: terminal output is stopped or started (*Control-S/Control-Q*); or
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端输出被停止或重新启动（*Control-S/Control-Q*）；或
- en: flow control was enabled or disabled.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流控制已启用或禁用。
- en: Packet mode helps with handling software flow control in certain pseudoterminal
    applications that provide network login services (e.g., *telnet* and *rlogin*).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包模式有助于处理某些伪终端应用中的软件流控制，这些应用提供网络登录服务（例如，*telnet*和*login*）。
- en: 'Packet mode is enabled by applying the *ioctl()* `TIOCPKT` operation to the
    file descriptor referring to the pseudoterminal master:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对引用伪终端主设备的文件描述符应用*ioctl()* `TIOCPKT`操作来启用数据包模式：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When packet mode is in operation, reads from the pseudoterminal master return
    either a single nonzero control byte, which is a bit mask indicating the state
    change(s) that occurred on the slave device, or a 0 byte followed by one or more
    bytes of data that were written on the pseudoterminal slave.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据包模式处于运行状态时，从伪终端主设备读取的内容要么是一个非零的控制字节，该字节是一个位掩码，指示从属设备上发生的状态变化，要么是一个0字节，后面跟着一个或多个写入伪终端从设备的数据字节。
- en: When a state change occurs on a pseudoterminal that is operating in packet mode,
    *select()* indicates that an exceptional condition (the *exceptfds* argument)
    has occurred on the master, and *poll()* returns `POLLPRI` in the *revents* field.
    (Refer to [Chapter 63](ch63.html "Chapter 63. Alternative I/O Models") for descriptions
    of *select()* and *poll()*.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当伪终端在数据包模式下发生状态变化时，*select()*会指示主设备发生了异常条件（即*exceptfds*参数），并且*poll()*会在*revents*字段中返回`POLLPRI`。（有关*select()*和*poll()*的描述，请参阅[第63章](ch63.html
    "第63章. 替代I/O模型")。）
- en: Packet mode is not standardized in SUSv3, and some details vary on other UNIX
    implementations. Further details of packet mode on Linux, including the bit-mask
    values used to indicate state changes, can be found in the *tty_ioctl(4)* manual
    page.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包模式在SUSv3中没有标准化，并且在其他UNIX实现中，一些细节有所不同。有关Linux中数据包模式的更多详细信息，包括用于指示状态变化的位掩码值，可以在*tty_ioctl(4)*手册页中找到。
- en: Implementing *script(1)*
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现*script(1)*
- en: We are now ready to implement a simple version of the standard *script(1)* program.
    This program starts a new shell session, and records all input and output from
    the session to a file. Most of the shell sessions shown in this book were recorded
    using *script*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备实现标准*script(1)*程序的简单版本。该程序启动一个新的 shell 会话，并将该会话的所有输入和输出记录到一个文件中。本书中展示的大部分
    shell 会话都是通过*script*记录的。
- en: In a normal login session, the shell is connected directly to the user’s terminal.
    When we run *script*, it places itself between the user’s terminal and the shell,
    and uses a pseudoterminal pair to create a communication channel between itself
    and the shell (see [Figure 64-4](ch64.html#the_script_program "Figure 64-4. The
    script program")). The shell is connected to the pseudoterminal slave. The *script*
    process is connected to the pseudoterminal master. The *script* process acts as
    a proxy for the user, taking input entered at the terminal and writing it to the
    pseudoterminal master, and reading output from the pseudoterminal master and writing
    it to the user’s terminal.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的登录会话中，shell 直接连接到用户的终端。当我们运行*script*时，它将自己置于用户终端和 shell 之间，并使用伪终端对创建一个通信通道，连接自己和
    shell（参见[图 64-4](ch64.html#the_script_program "Figure 64-4. The script program")）。shell
    连接到伪终端从端，*script*进程连接到伪终端主端。*script*进程充当用户的代理，将输入内容写入伪终端主端，并从伪终端主端读取输出并写入用户终端。
- en: In addition, *script* produces an output file (named `typescript` by default)
    that contains a copy of all bytes that are output on the pseudoterminal master.
    This has the effect of recording not only the output produced by the shell session,
    but also the input that is supplied to it. The input is recorded because, just
    as with a conventional terminal device, the kernel echoes input characters by
    copying them to the terminal output queue (see [Figure 62-1](ch62.html#input_and_output_queues_for_a_terminal_d
    "Figure 62-1. Input and output queues for a terminal device"), in [Retrieving
    and Modifying Terminal Attributes](ch62.html#retrieving_and_modifying_terminal_attrib
    "Retrieving and Modifying Terminal Attributes")). However, when terminal echoing
    is disabled, as is done by programs that read passwords, the pseudoterminal slave
    input is not copied to the slave output queue, and thus is not copied to the script
    output file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，*script* 会生成一个输出文件（默认为`typescript`），该文件包含所有在伪终端主端上输出的字节副本。这意味着它不仅记录了 shell
    会话生成的输出，还记录了输入内容。输入被记录是因为，像传统的终端设备一样，内核通过将输入字符复制到终端输出队列来回显输入（参见[图 62-1](ch62.html#input_and_output_queues_for_a_terminal_d
    "Figure 62-1. Input and output queues for a terminal device")，以及在[检索和修改终端属性](ch62.html#retrieving_and_modifying_terminal_attrib
    "Retrieving and Modifying Terminal Attributes")中）。然而，当禁用终端回显时（例如，读取密码的程序会这么做），伪终端从端的输入不会被复制到从端输出队列中，因此不会被复制到
    script 输出文件中。
- en: '![The script program](figs/web/64-4_PTY-script-scale90.png.jpg)Figure 64-4. The
    *script* program'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![脚本程序](figs/web/64-4_PTY-script-scale90.png.jpg)图 64-4. *script* 程序'
- en: 'Our implementation of *script* is shown in [Example 64-3](ch64.html#a_simple_implementation_of_script_open_p
    "Example 64-3. A simple implementation of script(1)"). This program performs the
    following steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的*script*实现如[示例 64-3](ch64.html#a_simple_implementation_of_script_open_p "Example 64-3. A
    simple implementation of script(1)")所示。该程序执行以下步骤：
- en: Retrieve the attributes and window size of the terminal under which the program
    is run ![](figs/web/U001.png). These are passed to the subsequent call to *ptyFork()*,
    which uses them to set the corresponding values for the pseudoterminal slave device.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取程序运行时终端的属性和窗口大小 ![](figs/web/U001.png)。这些信息会传递给后续调用的*ptyFork()*，用于设置伪终端从设备的相应值。
- en: Call our *ptyFork()* function ([Example 64-2](ch64.html#implementation_of_ptyfork_open_parenthes
    "Example 64-2. Implementation of ptyFork()")) to create a child process that is
    connected to the parent via a pseudoterminal pair ![](figs/web/U002.png).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用我们的*ptyFork()*函数（参见[示例 64-2](ch64.html#implementation_of_ptyfork_open_parenthes
    "Example 64-2. Implementation of ptyFork()")），创建一个通过伪终端对连接的子进程 ![](figs/web/U002.png)。
- en: After the *ptyFork()* call, the child execs a shell ![](figs/web/U004.png).
    The choice of shell is determined by the setting of the `SHELL` environment variable
    ![](figs/web/U003.png). If the `SHELL` variable is not set or its value is an
    empty string, then the child execs `/bin/sh`.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*ptyFork()*调用后，子进程执行一个 shell ![](figs/web/U004.png)。选择的 shell 由`SHELL`环境变量的设置决定
    ![](figs/web/U003.png)。如果没有设置`SHELL`变量或其值为空字符串，则子进程执行`/bin/sh`。
- en: 'After the *ptyFork()* call, the parent performs the following steps:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*ptyFork()*调用之后，父进程执行以下步骤：
- en: Open the output script file ![](figs/web/U005.png). If a command-line argument
    is supplied, this is used as the name of the script file. If no command-line argument
    is supplied, the default name `typescript` is used.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开输出脚本文件 ![](figs/web/U005.png)。如果提供了命令行参数，则使用该参数作为脚本文件的名称。如果没有提供命令行参数，则使用默认名称`typescript`。
- en: 'Place the terminal in raw mode (using the *ttySetRaw()* function shown in [Example 62-3](ch62.html#switching_a_terminal_to_cbreak_and_raw_m
    "Example 62-3. Switching a terminal to cbreak and raw modes"), in [Example: setting
    raw and cbreak mode](ch62.html#example_colon_setting_raw_and_cbreak_mod "Example:
    setting raw and cbreak mode")), so that all input characters are passed directly
    to the *script* program without being modified by the terminal driver ![](figs/web/U006.png).
    Characters output by the *script* program are likewise not modified by the terminal
    driver.'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将终端置于原始模式（使用*ttySetRaw()*函数，如[示例62-3](ch62.html#switching_a_terminal_to_cbreak_and_raw_m
    "示例62-3. 将终端切换到cbreak和原始模式")、[示例：设置原始模式和cbreak模式](ch62.html#example_colon_setting_raw_and_cbreak_mod
    "示例：设置原始模式和cbreak模式")所示），这样所有输入字符都会直接传递给*script*程序，而不会被终端驱动程序修改 ![](figs/web/U006.png)。*script*程序输出的字符也同样不会被终端驱动程序修改。
- en: Note
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The fact that the terminal is in raw mode doesn’t mean that raw, uninterpreted
    control characters will be transmitted to the shell, or whatever other process
    group is in the foreground for the pseudoterminal slave device, nor that output
    from that process group is passed raw to the user’s terminal. Instead, interpretation
    of terminal special characters is taking place within the slave device (unless
    the slave was also explicitly placed in raw mode by an application). By placing
    the user’s terminal in raw mode, we prevent a *second* round of interpretation
    of input and output characters from occurring.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 终端处于原始模式并不意味着未解析的原始控制字符会被传送到shell，或者传送到伪终端从设备的前台进程组，或者该进程组的输出会直接传送到用户的终端。实际上，终端特殊字符的解析是在从设备内部进行的（除非从设备也被应用程序显式地设置为原始模式）。通过将用户的终端置于原始模式，我们防止了输入输出字符的*第二*次解析。
- en: Call *atexit()* to install an exit handler that resets the terminal to its original
    mode when the program terminates ![](figs/web/U007.png).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用*atexit()*安装退出处理程序，在程序终止时将终端重置为原始模式 ![](figs/web/U007.png)。
- en: Execute a loop that transfers data in both directions between the terminal and
    the pseudoterminal master ![](figs/web/U008.png). In each loop iteration, the
    program first uses *select()* ([The *select()* System Call](ch63.html#the_select_open_parenthesis_close_parent
    "The select() System Call")) to monitor both the terminal and the pseudoterminal
    master for input ![](figs/web/U009.png). If the terminal has input available,
    then the program reads some of that input and writes it to the pseudoterminal
    master ![](figs/web/U010.png). Similarly, if the pseudoterminal master has input
    available, the program reads some of that input and writes it to the terminal
    and to the script file ![](figs/web/U010.png). The loop executes until end-of-file
    or an error is detected on one of the monitored file descriptors.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个循环，在终端和伪终端主设备之间双向传输数据 ![](figs/web/U008.png)。在每次循环迭代中，程序首先使用*select()*（[*select()*系统调用](ch63.html#the_select_open_parenthesis_close_parent
    "select()系统调用")）监控终端和伪终端主设备的输入 ![](figs/web/U009.png)。如果终端有可用输入，程序读取部分输入并将其写入伪终端主设备
    ![](figs/web/U010.png)。同样地，如果伪终端主设备有可用输入，程序读取部分输入并将其写入终端以及脚本文件 ![](figs/web/U010.png)。该循环会持续执行，直到文件结束或在监视的文件描述符上检测到错误。
- en: Example 64-3. A simple implementation of *script(1)*
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 示例64-3. 简单实现*script(1)*
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the following shell session, we demonstrate the use of the program in [Example 64-3](ch64.html#a_simple_implementation_of_script_open_p
    "Example 64-3. A simple implementation of script(1)"). We begin by displaying
    the name of the pseudoterminal used by the *xterm* on which the login shell is
    running and the process ID of the login shell. This information is useful later
    in the shell session.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下的shell会话中，我们演示了[示例64-3](ch64.html#a_simple_implementation_of_script_open_p
    "示例64-3. 简单实现script(1)")中程序的使用。我们首先显示由*xterm*使用的伪终端的名称以及登录shell的进程ID。这些信息在后续的shell会话中非常有用。
- en: '[PRE11]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then start an instance of our *script* program, which invokes a subshell.
    Once more, we display the name of the terminal on which the shell is running and
    the process ID of the shell:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们启动一个*script*程序实例，它调用一个子shell。再次，我们显示正在运行该shell的终端名称和shell的进程ID：
- en: '[PRE12]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we use *ps(1)* to display information about the two shells and the process
    running *script*, and then terminate the shell started by *script*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用*ps(1)*显示关于两个shell和运行*script*的进程的信息，然后终止*script*启动的shell：
- en: '[PRE13]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The output of *ps(1)* shows the parent-child relationships between the login
    shell, the process running *script*, and the subshell started by *script*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*ps(1)*的输出显示了登录shell、运行*script*的进程以及*script*启动的子shell之间的父子关系。'
- en: 'At this point, we have returned to the login shell. Displaying the contents
    of the file `typescript` shows a record of all input and output that was produced
    while *script* was running:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，我们已返回登录shell。显示`typescript`文件的内容，展示了*script*运行期间生成的所有输入和输出记录：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Terminal Attributes and Window Size
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端属性和窗口大小
- en: The master and slave device share terminal attributes (*termios*) and window
    size (*winsize*) structures. (Both of these structures are described in [Chapter 62](ch62.html
    "Chapter 62. Terminals").) This means that the program running above the pseudoterminal
    master can change these attributes for the pseudoterminal slave by applying *tcsetattr()*
    and *ioctl()* to the file descriptor of the master device.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 主设备和从设备共享终端属性（*termios*）和窗口大小（*winsize*）结构。（这两种结构在[第62章](ch62.html "第62章. 终端")中有描述。）这意味着运行在伪终端主设备上的程序可以通过对主设备文件描述符应用*tcsetattr()*和*ioctl()*来更改伪终端从设备的这些属性。
- en: 'One example of where changing terminal attributes can be useful is in the script
    program. Suppose we are running *script* in a terminal emulator window, and we
    change the size of the window. In this case, the terminal emulator program will
    inform the kernel of the change in the size of the corresponding terminal device,
    but this change is not reflected in the separate kernel record for the pseudoterminal
    slave (see [Figure 64-4](ch64.html#the_script_program "Figure 64-4. The script
    program")). As a consequence, screen-oriented programs (e.g., *vi*) running above
    the pseudoterminal slave will produce confusing output, since their understanding
    of the terminal window size differs from the actual size of the terminal. We can
    solve this problem as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 改变终端属性在*script*程序中可能是有用的一个例子。假设我们在终端仿真器窗口中运行*script*，并改变窗口的大小。在这种情况下，终端仿真器程序将通知内核相应终端设备大小的变化，但此变化不会反映在伪终端从设备的单独内核记录中（见[图64-4](ch64.html#the_script_program
    "图64-4.  Script程序")）。因此，在伪终端从设备上运行的屏幕导向程序（如*vi*）会产生混乱的输出，因为它们对终端窗口大小的理解与终端的实际大小不同。我们可以通过以下方法解决这个问题：
- en: Install a handler for `SIGWINCH` in the *script* parent process, so that it
    is signaled when the size of the terminal window changes.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*script*父进程中安装一个`SIGWINCH`处理程序，以便当终端窗口大小发生变化时，它能够接收到信号。
- en: When the *script* parent receives a `SIGWINCH` signal, it uses an *ioctl()*
    `TIOCGWINSZ` operation to retrieve a *winsize* structure for the terminal window
    associated with its standard input. It then uses this structure in an *ioctl()*
    `TIOCSWINSZ` operation that sets the window size of the pseudoterminal master.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当*script*父进程接收到`SIGWINCH`信号时，它使用*ioctl()* `TIOCGWINSZ`操作来获取与其标准输入关联的终端窗口的*winsize*结构。然后，它使用这个结构在*ioctl()*
    `TIOCSWINSZ`操作中设置伪终端主设备的窗口大小。
- en: If the new pseudoterminal window size is different from the old size, then the
    kernel generates a `SIGWINCH` signal for the foreground process group of the pseudoterminal
    slave. Screen-handling programs such as *vi* are designed to catch this signal
    and perform an *ioctl()* `TIOCGWINSZ` operation to update their understanding
    of the terminal window size.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果新的伪终端窗口大小与旧的大小不同，内核会为伪终端从设备的前台进程组生成一个`SIGWINCH`信号。像*vi*这样的屏幕处理程序被设计成捕捉该信号，并执行一个*ioctl()*
    `TIOCGWINSZ`操作来更新它们对终端窗口大小的理解。
- en: We described the details of terminal window sizes and the *ioctl()* `TIOCGWINSZ`
    and `TIOCSWINSZ` operations in Section 62.9.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第62.9节中描述了终端窗口大小以及*ioctl()* `TIOCGWINSZ`和`TIOCSWINSZ`操作的详细信息。
- en: BSD Pseudoterminals
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BSD伪终端
- en: For most of this chapter, we have focused on UNIX 98 pseudoterminals, since
    this is the style of pseudoterminal that is standardized in SUSv3 and thus should
    be used in all new programs. However, we may sometimes encounter BSD pseudoterminals
    in older applications or when porting programs to Linux from other UNIX implementations.
    Therefore, we now consider the details of BSD pseudoterminals.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本章大部分内容集中在 UNIX 98 伪终端上，因为这是 SUSv3 中标准化的伪终端样式，因此应在所有新程序中使用。然而，在旧版应用程序中或将程序从其他
    UNIX 实现移植到 Linux 时，我们有时会遇到 BSD 伪终端。因此，我们现在考虑 BSD 伪终端的细节。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The use of BSD pseudoterminals is deprecated on Linux. From Linux 2.6.4 onward,
    BSD pseudoterminal support is an optional kernel component that can be configured
    via the `CONFIG_LEGACY_PTYS` option.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，BSD 伪终端的使用已被弃用。从 Linux 2.6.4 开始，BSD 伪终端支持成为一个可选的内核组件，可以通过 `CONFIG_LEGACY_PTYS`
    选项进行配置。
- en: BSD pseudoterminals differ from their UNIX 98 counterparts only in the details
    of how pseudoterminal master and slave devices are found and opened. Once the
    master and slave have been opened, BSD pseudoterminals operate in the same way
    as UNIX 98 pseudoterminals.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: BSD 伪终端与 UNIX 98 伪终端的区别仅在于如何找到并打开伪终端主设备和从设备的细节。一旦主设备和从设备被打开，BSD 伪终端与 UNIX 98
    伪终端的操作方式相同。
- en: With UNIX 98 pseudoterminals, we obtain an unused pseudoterminal master by calling
    *posix_openpt()*, which opens `/dev/ptmx`, the pseudoterminal master clone device.
    We then obtain the name of the corresponding pseudoterminal slave using *ptsname()*.
    By contrast, with BSD pseudoterminals, the master and slave device pairs are precreated
    entries in the `/dev` directory. Each master device has a name of the form `/dev/pty`*xy*,
    where *x* is replaced by a letter in the 16-letter range `[p-za-e]` and *y* is
    replaced by a letter in the 16-letter range `[0-9a-f]`. The slave corresponding
    to a particular pseudoterminal master has a name of the form `/dev/tty`*xy*. Thus,
    for example, the devices `/dev/ptyp0` and `/dev/ttyp0` constitute a BSD pseudoterminal
    pair.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 UNIX 98 伪终端时，我们通过调用 *posix_openpt()* 获取一个未使用的伪终端主设备，该函数打开 `/dev/ptmx`，即伪终端主设备克隆设备。然后，我们使用
    *ptsname()* 获取对应的伪终端从设备的名称。相比之下，使用 BSD 伪终端时，主设备和从设备对是在 `/dev` 目录下预创建的条目。每个主设备的名称形式为
    `/dev/pty`*xy*，其中 *x* 被 `[p-za-e]` 范围内的一个字母替换，*y* 被 `[0-9a-f]` 范围内的一个字母替换。与特定伪终端主设备对应的从设备名称形式为
    `/dev/tty`*xy*。因此，例如，设备 `/dev/ptyp0` 和 `/dev/ttyp0` 构成一对 BSD 伪终端。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: UNIX implementations vary in the number and names of BSD pseudoterminal pairs
    that they supply, with some supplying as few as 32 pairs by default. Most implementations
    provide at least the 32 master devices with names in the range `/dev/pty[pq][0-9a-f]`,
    along with the corresponding slave devices.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX 实现提供的 BSD 伪终端对的数量和名称有所不同，有些实现默认仅提供 32 对。大多数实现至少提供 32 个主设备，其名称在 `/dev/pty[pq][0-9a-f]`
    范围内，并附带相应的从设备。
- en: 'To find an unused pseudoterminal pair, we execute a loop that attempts to open
    each master device in turn, until one of them is opened successfully. While executing
    this loop, there are two errors that we may encounter when calling *open()*:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到一个未使用的伪终端对，我们执行一个循环，逐个尝试打开每个主设备，直到其中一个成功打开。在执行此循环时，我们可能会遇到调用 *open()* 时的两个错误：
- en: If a given master device name doesn’t exist, *open()* fails with the error `ENOENT`.
    Typically, this means we’ve run through the complete set of pseudoterminal master
    names on the system without finding a free device (i.e., there was not the full
    range of devices listed above).
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给定的主设备名称不存在，*open()* 会返回错误 `ENOENT`。通常，这意味着我们已经遍历了系统上所有伪终端主设备名称，而没有找到空闲设备（即，没有列出上述完整的设备范围）。
- en: If the master device is in use, *open()* fails with the error `EIO`. We can
    just ignore this error and try the next device.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果主设备正在使用中，*open()* 会返回错误 `EIO`。我们可以忽略这个错误，并尝试下一个设备。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On HP-UX 11, *open()* fails with the error `EBUSY` on an attempt to open a BSD
    pseudoterminal master that is in use.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HP-UX 11 中，尝试打开一个正在使用中的 BSD 伪终端主设备时，*open()* 会失败并返回错误 `EBUSY`。
- en: Once we have found an available master device, we can obtain the name of the
    corresponding slave by substituting `tty` for `pty` in the name of the master.
    We can then open the slave using *open()*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到一个可用的主设备，我们可以通过将主设备名称中的 `pty` 替换为 `tty` 来获得对应从设备的名称。然后，我们可以使用 *open()* 打开从设备。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With BSD pseudoterminals, there is no equivalent of *grantpt()* to change the
    ownership and permissions of the pseudoterminal slave. If we need to do this,
    then we must make explicit calls to *chown()* (only possible in a privileged program)
    and *chmod()*, or write a set-user-ID program (like *pt_chown*) that performs
    this task for an unprivileged program.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在BSD伪终端中，没有类似*grantpt()*的函数来更改伪终端从设备的所有权和权限。如果需要这样做，必须明确调用*chown()*（只有在特权程序中才能实现）和*chmod()*，或者编写一个设置用户ID的程序（如*pt_chown*），为非特权程序执行此任务。
- en: '[Example 64-4](ch64.html#implementation_of_ptymasteropen_open "Example 64-4. Implementation
    of ptyMasterOpen() using BSD pseudoterminals") shows a reimplementation of the
    *ptyMasterOpen()* function of Section 64.3 using BSD pseudoterminals. Substituting
    this implementation is all that is required to make our *script* program (Section
    64.6) work with BSD pseudoterminals.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 64-4](ch64.html#implementation_of_ptymasteropen_open "示例 64-4. 使用BSD伪终端实现
    ptyMasterOpen()")展示了使用BSD伪终端重新实现第64.3节的*ptyMasterOpen()*函数。替换这个实现即可使我们的*script*程序（第64.6节）在BSD伪终端上工作。'
- en: Example 64-4. Implementation of *ptyMasterOpen()* using BSD pseudoterminals
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 64-4. 使用BSD伪终端实现*ptyMasterOpen()*
- en: '[PRE15]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: A pseudoterminal pair consists of a connected master device and slave device.
    Together, these two devices provide a bidirectional IPC channel. The benefit of
    a pseudoterminal is that, on the slave side of the pair, we can connect a terminal-oriented
    program that is driven by the program that has opened the master device. The pseudoterminal
    slave behaves just like a conventional terminal. All of the operations that can
    be applied to a conventional terminal can be applied to the slave, and input transmitted
    from the master to the slave is interpreted in the same manner as keyboard input
    is interpreted on a conventional terminal.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 伪终端对由一个连接的主设备和从设备组成。两个设备共同提供了一个双向IPC通道。伪终端的好处在于，在从设备端，我们可以连接一个由打开主设备的程序驱动的面向终端的程序。伪终端从设备的行为就像一个常规终端一样。可以应用于常规终端的所有操作也可以应用于从设备，且从主设备传输到从设备的输入与在常规终端上键盘输入的解释方式相同。
- en: One common use of pseudoterminals is in applications that provide network login
    services. However, pseudoterminals are also used in many other programs, such
    as terminal emulators and the *script(1)* program.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 伪终端的一个常见用途是在提供网络登录服务的应用程序中。然而，伪终端也被广泛应用于许多其他程序中，如终端仿真器和*script(1)*程序。
- en: Different pseudoterminals APIs arose on System V and BSD. Linux supports both
    APIs, but the System V API forms the basis for the pseudoterminal API that is
    standardized in SUSv3.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在System V和BSD中出现了不同的伪终端API。Linux同时支持这两种API，但System V API构成了SUSv3标准化的伪终端API的基础。
- en: Exercises
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: In what order do the *script* parent process and the child shell process terminate
    when the user types the end-of-file character (usually *Control-D*) while running
    the program in [Example 64-3](ch64.html#a_simple_implementation_of_script_open_p
    "Example 64-3. A simple implementation of script(1)")? Why?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在运行[示例 64-3](ch64.html#a_simple_implementation_of_script_open_p "示例 64-3.
    一个简单的 script(1) 实现")程序时，输入结束符字符（通常是*Control-D*），*script*父进程和子shell进程是以什么顺序终止的？为什么？
- en: 'Make the following modifications to the program in [Example 64-3](ch64.html#a_simple_implementation_of_script_open_p
    "Example 64-3. A simple implementation of script(1)") (`script.c`):'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对[示例 64-3](ch64.html#a_simple_implementation_of_script_open_p "示例 64-3. 一个简单的
    script(1) 实现")中的程序（`script.c`）做以下修改：
- en: The standard *script(1)* program adds lines to the beginning and the end of
    the output file showing the time the script started and finished. Add this feature.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准*script(1)*程序在输出文件的开始和结束处添加显示脚本开始和结束时间的行。请添加此功能。
- en: Add code to handle changes to the terminal window size as described in Section
    64.7\. You may find the program in [Example 62-5](ch62.html#monitoring_changes_in_the_terminal_windo
    "Example 62-5. Monitoring changes in the terminal window size") (`demo_SIGWINCH.c`)
    useful for testing this feature.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加代码来处理如第64.7节所述的终端窗口大小变化。你可以参考[示例 62-5](ch62.html#monitoring_changes_in_the_terminal_windo
    "示例 62-5. 监控终端窗口大小变化")中的程序（`demo_SIGWINCH.c`）来测试此功能。
- en: 'Modify the program in [Example 64-3](ch64.html#a_simple_implementation_of_script_open_p
    "Example 64-3. A simple implementation of script(1)") (`script.c`) to replace
    the use of *select()* by a pair of processes: one to handle data transfer from
    the terminal to the pseudoterminal master, and the other to handle data transfer
    in the opposite direction.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[示例 64-3](ch64.html#a_simple_implementation_of_script_open_p "示例 64-3. 脚本(1)的简单实现")（`script.c`）中的程序，将*select()*的使用替换为一对进程：一个用于处理从终端到伪终端主设备的数据传输，另一个用于处理反方向的数据传输。
- en: 'Modify the program in [Example 64-3](ch64.html#a_simple_implementation_of_script_open_p
    "Example 64-3. A simple implementation of script(1)") (`script.c`) to add a time-stamped
    recording feature. Each time the program writes a string to the `typescript` file,
    it should also write a time-stamped string to a second file (say, `typescript.timed`).
    Records written to this second file might have the following general form:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[示例 64-3](ch64.html#a_simple_implementation_of_script_open_p "示例 64-3. 脚本(1)的简单实现")（`script.c`）中的程序，添加一个带时间戳的记录功能。每次程序向`typescript`文件写入字符串时，它还应该将带时间戳的字符串写入第二个文件（比如`typescript.timed`）。写入第二个文件的记录可能具有以下通用形式：
- en: '[PRE16]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The *timestamp* should be recorded in text form as the number of milliseconds
    since the start of the script session. Recording the timestamp in text form has
    the advantage that the resulting file is human-readable. Within *string*, real
    newline characters will need to be escaped. One possibility is to record a newline
    as the 2-character sequence `\n` and a backslash as `\\`.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*时间戳*应以文本形式记录，表示自脚本会话开始以来的毫秒数。以文本形式记录时间戳的优点是生成的文件具有可读性。在*string*内，真实的换行符需要转义。一种可能的方式是将换行符记录为2个字符的序列`\n`，将反斜杠记录为`\\`。'
- en: Write a second program, `script_replay.c`, that reads the time-stamped script
    file and displays its contents on standard output at the same rate at which they
    were originally written. Together, these two programs provide a simple recording
    and playback feature for shell session logs.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写第二个程序`script_replay.c`，该程序读取带时间戳的脚本文件，并以最初写入的相同速率将其内容显示到标准输出。结合这两个程序，提供了一个简单的shell会话日志记录和回放功能。
- en: Implement client and server programs to provide a simple *telnet*-style remote
    login facility. Design the server to handle clients concurrently (Section 60.1).
    [Figure 64-3](ch64.html#how_ssh_uses_a_pseudoterminal "Figure 64-3. How ssh uses
    a pseudoterminal") shows the setup that needs to be established for each client
    login. What isn’t shown in that diagram is the parent server process, which handles
    incoming socket connections from clients and creates a server child to handle
    each connection. Note that all of the work of authenticating the user and starting
    a login shell can be dealt with in each server child by having the (grand)child
    created by *ptyFork()* go on to exec *login(1)*.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现客户端和服务器程序，提供一个简单的*telnet*风格的远程登录功能。设计服务器以并发处理客户端（第60.1节）。[图 64-3](ch64.html#how_ssh_uses_a_pseudoterminal
    "图 64-3. SSH如何使用伪终端")显示了为每个客户端登录所需建立的设置。该图未显示的是父服务器进程，它处理来自客户端的传入套接字连接并创建服务器子进程来处理每个连接。请注意，所有身份验证用户和启动登录shell的工作都可以通过让*ptyFork()*创建的（孙）子进程执行*login(1)*来处理。
- en: Add code to the program developed in the previous exercise to update the login
    accounting files at the start and end of the login session ([Chapter 40](ch40.html
    "Chapter 40. Login Accounting")).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一练习中开发的程序中添加代码，以便在登录会话开始和结束时更新登录帐户文件（[第40章](ch40.html "第40章. 登录账户")）。
- en: 'Suppose we execute a long-running program that slowly generates output that
    is redirected to a file or pipe, as in this example:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们执行一个长期运行的程序，该程序缓慢生成的输出被重定向到文件或管道，如以下示例所示：
- en: '[PRE17]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'One problem with the above scenario is that, by default, the *stdio* package
    flushes standard output only when the *stdio* buffer is filled. This means that
    the output from the *longrunner* program will appear in bursts separated by long
    intervals of time. One way to circumvent this problem is to write a program that
    does the following:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述场景的一个问题是，默认情况下，*stdio*包仅在*stdio*缓冲区被填满时才刷新标准输出。这意味着*longrunner*程序的输出将以长时间间隔分隔的突发形式出现。解决此问题的一种方法是编写一个程序，执行以下操作：
- en: Create a pseudoterminal.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个伪终端。
- en: Exec the program named in its command-line arguments with the standard file
    descriptors connected to the pseudoterminal slave.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行命令行参数中指定的程序，并将标准文件描述符连接到伪终端从设备。
- en: Read output from the pseudoterminal master and write it immediately to standard
    output (`STDOUT_FILENO`, file descriptor 1), and, at the same time, read input
    from the terminal and write it to the pseudoterminal master, so that it can be
    read by the execed program.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从伪终端主机读取输出并立即写入标准输出（`STDOUT_FILENO`，文件描述符 1），同时，从终端读取输入并写入伪终端主机，以便 execed 程序可以读取。
- en: 'Such a program, which we’ll call *unbuffer*, would be used as follows:'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样的程序，我们称之为 *unbuffer*，其使用方法如下：
- en: '[PRE18]'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Write the *unbuffer* program. (Much of the code for this program will be similar
    to that of [Example 64-3](ch64.html#a_simple_implementation_of_script_open_p "Example 64-3. A
    simple implementation of script(1)").)
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写 *unbuffer* 程序。（这个程序的大部分代码将与[示例 64-3](ch64.html#a_simple_implementation_of_script_open_p
    "示例 64-3. 脚本(1)的简单实现")的代码类似。）
- en: Write a program that implements a scripting language that can be used to drive
    *vi* in a noninteractive mode. Since *vi* expects to be run from a terminal, the
    program will need to employ a pseudoterminal.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个实现脚本语言的程序，该语言可以用来以非交互模式驱动 *vi*。由于 *vi* 期望从终端运行，该程序将需要使用伪终端。
