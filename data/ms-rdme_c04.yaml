- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Writing Operable Code
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写可操作的代码
- en: Code does weird things when exposed to “the real world.” Users are unpredictable.
    Networks are unreliable. Things go wrong. Production software has to keep working.
    Writing operable code helps you deal with the unforeseen. Operable code has built-in
    protection, diagnostics, and controls. Protect your system by programming defensively
    with safe and resilient coding practices. Safe code prevents many failures, and
    resilient code recovers when failures do occur. You also need to be able to see
    what’s going on so you can diagnose failures. Expose logging, metrics, and call
    trace information for easy diagnostics. Finally, you need to control systems without
    rewriting code. An operable system has configuration parameters and system tools.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码暴露于“真实世界”时，会发生一些奇怪的事情。用户是不可预测的，网络是不可靠的，事情会出错。生产软件必须保持运行。编写可操作的代码可以帮助你应对不可预见的问题。可操作的代码具有内置的保护、诊断和控制功能。通过使用安全且具有韧性的编码实践进行防御性编程来保护你的系统。安全代码可以防止许多失败，而韧性代码在失败发生时能恢复。你还需要能够查看系统状态，以便诊断故障。暴露日志、指标和调用跟踪信息，便于诊断。最后，你需要在不重写代码的情况下控制系统。一个可操作的系统应该有配置参数和系统工具。
- en: This chapter describes some best practices that will make your code easier to
    run in production. There’s a lot of ground to cover, so we kept things dense.
    By the end, you’ll be familiar with key concepts and tools you need to make your
    software operable. Moreover, operability comments are common in code reviews;
    this information will help you give and receive better feedback.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了一些最佳实践，这些实践将使你的代码更容易在生产环境中运行。内容涵盖广泛，因此我们保持内容的密度。到本章结束时，你将熟悉让软件可操作的关键概念和工具。此外，可操作性注释在代码审查中很常见；这些信息将帮助你更好地提供和接收反馈。
- en: Defensive Programming
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防御性编程
- en: Well-defended code is an act of compassion for anyone who runs your code (including
    you!). Defensive code fails less often, and when it does, it is more likely to
    recover. Make your code safe and resilient. *Safe code* takes advantage of compile-time
    validation to avoid runtime failures. Use immutable variables, access modifiers
    to restrict scope, and static type-checkers to prevent bugs. At runtime, validate
    input to avoid surprises. *Resilient code* uses exception-handling best practices
    and handles failures gracefully.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性代码是对任何运行你代码的人（包括你自己！）的一种关怀。防御性代码出错的几率较低，且当出现错误时，更有可能恢复。让你的代码安全且具有韧性。*安全代码*利用编译时验证来避免运行时失败。使用不可变变量、访问修饰符来限制作用域，以及静态类型检查器来防止错误。在运行时，通过验证输入来避免意外情况的发生。*韧性代码*采用异常处理最佳实践，并优雅地处理失败。
- en: Avoid Null Values
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免空值
- en: In many languages, variables without a value default to `null` (or `nil`, `None`,
    or some other variant thereof). Null pointer exceptions are a common occurrence.
    Stack traces prompt head-scratching and a “how could this variable not have been
    set?” investigation. Avoid null pointer exceptions by checking that variables
    aren’t null, by using the null object pattern, and by using option types.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程语言中，未赋值的变量默认值为`null`（或`nil`、`None`，或其他类似的变体）。空指针异常是常见的错误。堆栈跟踪常常让人困惑，并引发“这个变量怎么可能没有被设置？”的调查。通过检查变量是否为null、使用空对象模式以及使用选项类型来避免空指针异常。
- en: Perform null checks at the beginning of methods. Use `NotNull` annotations and
    similar language features when available. Validating up front that variables aren’t
    null means that later code can safely assume that it’s dealing with real values;
    this will keep your code cleaner and more legible.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法开始时执行null检查。使用`NotNull`注解以及类似的语言特性（如果可用）。事先验证变量是否为null，意味着后续代码可以安全地假定正在处理的是实际值，这将使你的代码更加简洁和易读。
- en: The *null object pattern* uses objects in lieu of null values. An example of
    this pattern is a search method that returns an empty list instead of `null` when
    no objects are found. Returning an empty list allows callers to safely iterate
    over the results, without special code to handle empty result sets.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*空对象模式*使用对象代替空值。这个模式的一个例子是，当没有找到对象时，搜索方法返回一个空列表，而不是`null`。返回空列表允许调用者安全地遍历结果，而无需编写特殊的代码来处理空结果集。'
- en: Some languages have built-in *option types*—`Optional` or `Maybe`—that force
    developers to think about how empty responses are handled. Take advantage of option
    types if they’re available.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言内置了*选项类型*——`Optional`或`Maybe`——迫使开发者思考如何处理空响应。如果这些选项类型可用，利用它们。
- en: Make Variables Immutable
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使变量不可变
- en: Immutable variables can’t be changed once they’re set. If your language has
    a way to explicitly declare variables as immutable (`final` in Java, `val` rather
    than `var` in Scala, `let` instead of `let mut` in Rust), do so whenever possible.
    Immutable variables prevent unexpected modifications. Many more variables can
    be made immutable than you might expect at first blush. As a bonus, using immutable
    variables makes parallel programming simpler, and a compiler or runtime that knows
    a variable is not going to change can be more efficient.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了不可变变量，就不能更改它们。如果您的语言有明确声明变量为不可变的方式（例如Java中的`final`，Scala中的`val`而不是`var`，Rust中的`let`而不是`let
    mut`），请尽可能使用。不可变变量防止了意外修改。比您想象的更多的变量可以变得不可变。作为奖励，使用不可变变量使并行编程更简单，编译器或运行时知道一个变量不会改变时，可以更高效。
- en: Use Type Hinting and Static Type Checking
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类型提示和静态类型检查
- en: Constrain the values that variables can take. For example, variables with only
    a few valid string values should be an `Enum` rather than a `String`. Constraining
    variables will ensure that unexpected values will immediately fail (or might not
    even compile) rather than cause bugs. Use the most specific type possible when
    defining variables.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 限制变量可以取的值。例如，只有少数有效字符串值的变量应该是`Enum`类型，而不是`String`类型。限制变量将确保意外值会立即失败（或者可能根本无法编译），而不是引发错误。在定义变量时，使用尽可能具体的类型。
- en: 'Dynamic languages such as Python (starting with Python 3.5), Ruby via Sorbet
    (slated to be part of Ruby 3), and JavaScript (via TypeScript) all now have increasingly
    robust support for *type hinting* and *static type checkers*. Type hinting lets
    you specify a variable’s type in a language that’s normally dynamically typed.
    For example, the following Python 3.5 method uses type hinting to receive and
    return a string:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 像Python（从Python 3.5开始）、Ruby通过Sorbet（计划作为Ruby 3的一部分）以及JavaScript（通过TypeScript）等动态语言现在都支持越来越强大的*类型提示*和*静态类型检查器*。类型提示允许您在通常是动态类型的语言中指定变量的类型。例如，下面的Python
    3.5方法使用类型提示来接收和返回一个字符串：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Best of all, type hinting can be added gradually to existing codebases. When
    combined with a static type checker, which uses type hints to find bugs before
    code is executed, you can prevent runtime failures.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的是，类型提示可以逐步添加到现有代码库中。当与静态类型检查器结合使用时，静态类型检查器使用类型提示在代码执行之前查找错误，您可以防止运行时失败。
- en: Validate Inputs
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证输入
- en: Never trust the input your code receives. Developers, faulty hardware, and human
    error can mangle input data. Protect your code by validating that its input is
    well formed. Use preconditions, checksum and validate data, use security best
    practices, and use tools to find common errors. Reject bad input as early as possible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要相信代码接收到的输入。开发人员、故障硬件和人为错误可能会损坏输入数据。通过验证输入数据是否格式正确来保护代码。使用前置条件、校验和验证数据，使用安全最佳实践，并使用工具来查找常见错误。尽早拒绝不良输入。
- en: 'Validate method input variables using preconditions and postconditions. Use
    libraries and frameworks that validate preconditions when the type you use does
    not fully capture valid variable values. Most languages have libraries with methods
    like `checkNotNull` or annotations like `@Size(min=0, max=100)`. Be as constrained
    as possible. Check that input strings match expected formats, and remember to
    deal with leading or trailing whitespace. Validate that all numbers are in appropriate
    ranges: if a parameter should be greater than zero, ensure that it is; if a parameter
    is an IP address, check that it’s a valid IP.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前置条件和后置条件验证方法输入变量。当您使用的类型无法完全捕获有效的变量值时，请使用库和框架来验证前置条件。大多数语言都有像`checkNotNull`这样的库方法或像`@Size(min=0,
    max=100)`这样的注解。尽量做到尽可能的限制。检查输入字符串是否符合预期格式，并记得处理前导或尾随空格。验证所有数字是否在适当的范围内：如果参数应该大于零，确保它大于零；如果参数是IP地址，检查它是否是有效的IP。
- en: Computer hardware isn’t always trustworthy. Networks and disks can corrupt data.
    If you need strong durability guarantees, use checksums to validate that data
    hasn’t changed unexpectedly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机硬件并不总是可靠的。网络和磁盘可能会损坏数据。如果需要强大的持久性保证，请使用校验和来验证数据是否没有意外变化。
- en: Don’t overlook security, either. External inputs are dangerous. Malicious users
    might try to inject code or SQL into inputs, or overrun buffers to gain control
    of your application. Use mature libraries and frameworks to prevent cross-site
    scripting. Always escape inputs to prevent SQL injection attacks. Explicitly set
    size parameters when manipulating memory with commands like `strcpy` (specifically
    use `strncpy`) to prevent buffer overflows. Use widely adopted security and cryptography
    libraries or protocols instead of writing your own. Familiarize yourself with
    the Open Web Application Security Project (OWASP) Top 10 security report ([https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/))
    to quickly bootstrap your security knowledge.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 也不要忽视安全性。外部输入是危险的。恶意用户可能会尝试向输入中注入代码或 SQL，或者溢出缓冲区以控制你的应用程序。使用成熟的库和框架来防止跨站脚本攻击。始终转义输入以防止
    SQL 注入攻击。在使用 `strcpy` 这类命令操作内存时，明确设置大小参数（特别是使用 `strncpy`）以防止缓冲区溢出。使用广泛采用的安全和加密库或协议，而不是自己编写。熟悉
    Open Web Application Security Project (OWASP) Top 10 安全报告（[https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)）以快速入门安全知识。
- en: Use Exceptions
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用异常
- en: Don’t use special return values (`null`, `0`, `–1`, and so on) to signal an
    error. All modern languages support exceptions or have a standard exception-handling
    pattern (like Go’s `error` type). Special values aren’t obviously visible from
    a method signature. Developers won’t know that error conditions are returned and
    need to be handled. It’s also difficult to remember which return value corresponds
    to which failure state. Exceptions carry more information than a `null` or `–1`;
    they’re named and have stack traces, line numbers, and messages.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用特殊的返回值（`null`、`0`、`–1` 等）来表示错误。所有现代语言都支持异常，或者有一个标准的异常处理模式（比如 Go 的 `error`
    类型）。特殊值在方法签名中并不明显，开发者不会知道返回了错误状态，也就无法处理它们。而且，很难记住哪个返回值对应哪个失败状态。异常比 `null` 或 `–1`
    带有更多的信息；它们是命名的，并且有堆栈追踪、行号和消息。
- en: 'For example, in Python a `ZeroDivisionError` returns a lot more information
    than a `None` return value:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Python 中，`ZeroDivisionError` 比 `None` 返回值提供更多的信息：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In many languages, checked exceptions are visible from method signatures:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多语言中，检查异常可以从方法签名中看到：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: An error declaration in Go and an exception declaration in Java clearly signal
    that the open methods can raise errors that need to be handled.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的错误声明和 Java 中的异常声明清楚地表明，打开的方法可能会抛出需要处理的错误。
- en: Be Precise with Exceptions
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 精确处理异常
- en: Precise exceptions make code easier to use. Use built-in exceptions when possible
    and avoid creating generic exceptions. Use exceptions for failures, not to control
    application logic.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 精确的异常使代码更易使用。尽可能使用内建异常，避免创建通用异常。使用异常来处理失败，而不是控制应用程序逻辑。
- en: Most languages have built-in exception types (`FileNotFoundException`, `AssertionError`,
    `NullPointerException`, and so on). Don’t create custom exceptions if a built-in
    type can describe the problem. Developers have experience with existing exception
    types and will know what they mean.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言都有内建的异常类型（`FileNotFoundException`、`AssertionError`、`NullPointerException`
    等）。如果内建类型可以描述问题，就不要创建自定义异常。开发者对现有的异常类型有经验，知道它们的含义。
- en: When creating your own exceptions, don’t make them too generic. Generic exceptions
    are difficult to handle because developers don’t know what kind of problem they’re
    dealing with. If developers don’t get a precise signal of the error that occurred,
    they’ll be forced to fail the application—a significant action. Be as specific
    as possible about the exception types you raise so developers can react to failures
    appropriately.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自定义异常时，不要让它们太通用。通用异常很难处理，因为开发者不知道他们正在处理什么样的问题。如果开发者没有得到一个明确的错误信号，他们将被迫让应用程序失败——这是一个重要的操作。尽可能具体地定义你抛出的异常类型，以便开发者能适当地处理失败。
- en: Don’t use exceptions for application logic, either. You want your code to be
    unsurprising, not clever. Using exceptions to break out of a method is confusing
    and makes code hard to debug.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 也不要把异常用作应用程序逻辑的一部分。你希望你的代码是可预测的，而不是聪明的。用异常跳出方法会让代码变得混乱，且难以调试。
- en: 'This Python example uses `FoundNodeException` rather than directly returning
    the node that was found:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Python 示例使用了 `FoundNodeException`，而不是直接返回找到的节点：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Don’t do this. Just return the node.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不要这样做。只需返回节点。
- en: Throw Exceptions Early, Catch Exceptions Late
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提前抛出异常，延后捕获异常
- en: Follow the “throw early, catch late” principle. *Throwing early* means raising
    exceptions as close to the error as possible so developers can quickly find the
    relevant code. Waiting to throw an exception makes it harder to find where the
    failure actually happened. When an error occurs but other code is executed before
    the exception is thrown, you risk the possibility of a second error being triggered.
    If an exception is thrown for the second error, you don’t know that the first
    error happened. Tracking down this kind of bug is maddening. You fix a bug only
    to discover that the real problem was something upstream.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循“早抛出，晚捕获”原则。*早抛出*意味着尽可能靠近错误的位置抛出异常，以便开发人员能够快速找到相关代码。等待抛出异常会让你更难找到失败实际发生的位置。当发生错误时，如果其他代码在异常被抛出之前执行，你就有可能触发第二个错误。如果第二个错误抛出了异常，你就无法知道第一个错误发生过。追踪这种错误非常令人抓狂。你修复了一个错误，却发现真正的问题在上游。
- en: '*Catching exceptions late* means propagating exceptions up the call stack until
    you reach the level of the program that is capable of handling the exception.
    Consider an application that tries to write to a full disk. There are many possible
    next steps: blocking and retrying, retrying asynchronously, writing to a different
    disk, alerting a human user, or even crashing. The appropriate reaction depends
    on application specifics. A database write-ahead log must be written, while a
    word processor’s background save can be delayed. The piece of code that can make
    this decision is likely several layers removed from the low-level library that
    encounters a full disk. All the intermediate layers need to propagate the exception
    upward and not attempt premature remediation. The worst of premature remediation
    is “swallowing” an exception you can’t address, usually by ignoring it in a `catch`
    block:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*捕获异常延迟*意味着将异常向上传播直到程序能够处理异常的级别。考虑一个尝试写入满磁盘的应用程序。有很多可能的后续步骤：阻塞并重试、异步重试、写入另一个磁盘、提醒用户，甚至崩溃。适当的反应取决于应用程序的具体情况。数据库写前日志必须写入，而文字处理器的后台保存可以延迟。能够做出此决策的代码很可能离遇到满磁盘的低级库有好几层。所有中间层都需要将异常向上传播，而不是尝试过早修复。过早修复的最糟糕情况是“吞掉”你无法处理的异常，通常是在`catch`块中忽略它：'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This exception will not get logged or rethrown, nor will any other action be
    taken; it’s completely ignored. The failure gets hidden, possibly to disastrous
    effect. When calling code that might throw exceptions, either handle them completely
    or propagate them up the stack.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常既不会被记录，也不会被重新抛出，也不会采取任何其他行动；它被完全忽略。失败被隐藏，可能带来灾难性后果。调用可能抛出异常的代码时，要么完全处理异常，要么将其传播到栈上。
- en: Retry Intelligently
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 智能重试
- en: 'The appropriate reaction to an error is often to simply try again. Plan on
    occasionally having to try multiple times when calling remote systems. Retrying
    an operation sounds easy: catch the exception and retry the operation. In practice,
    when and how often to retry requires some know-how.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对错误的适当反应通常是简单地重试。在调用远程系统时，计划偶尔需要多次尝试。重试操作看起来很简单：捕获异常并重试操作。实际上，何时以及多频繁地重试需要一定的技巧。
- en: The most naïve retry approach is simply to catch an exception and retry the
    operation immediately. But what if the operation fails again? If a disk runs out
    of space, it’s likely to be out of space 10 milliseconds later, and 10 milliseconds
    after that. Banging away over and over slows things down and makes it harder for
    the system to recover.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最天真的重试方法是简单地捕获异常并立即重试操作。但如果操作再次失败怎么办？如果磁盘空间用尽，它很可能在10毫秒后仍然没有空间，10毫秒后也一样。不断地敲击会使事情变得更慢，并且让系统更难恢复。
- en: It’s prudent to use a strategy called *backoff*. Backoff increases sleep time
    nonlinearly (usually using an exponential backoff, such as `(retry number)^2`).
    If you use this approach, make sure to cap the backoff at some maximum so it doesn’t
    get too large. However, if a network server has a blip and all clients experience
    that blip simultaneously, then back off using the same algorithm; they will all
    reissue their requests at the same time. This is called a *thundering herd*; many
    clients issuing retry requests simultaneously can bring a recovering service back
    down. To handle this, add *jitter* to the backoff strategy. With jitter, clients
    add a random, bounded amount of time to the backoff. Introducing randomness spreads
    out the requests, reducing the likelihood of a stampede.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一种叫做*退避*的策略是明智的。退避通过非线性增加睡眠时间（通常使用指数退避，例如`(重试次数)^2`）。如果你使用这种方法，请确保设置一个最大值来限制退避时间，避免过大。然而，如果一个网络服务器出现了闪断，并且所有客户端同时经历了这个闪断，那么如果都使用相同的退避算法进行退避，它们会同时重新发起请求。这叫做*雷霆洪流*；许多客户端同时发起重试请求可能会让正在恢复的服务再次崩溃。为了解决这个问题，可以在退避策略中加入*抖动*。使用抖动时，客户端会在退避时间上加上一个随机的、有界的时间。引入随机性可以将请求分散开，减少踩踏的可能性。
- en: Don’t blindly retry all failed calls, particularly ones that write data or cause
    some business process to execute. It is better to let the application crash when
    it encounters an error it was not designed to handle; this is called *failing
    fast*. If you fail fast, no further damage will be done, and a human can figure
    out the correct course of action. Make sure to fail not only fast but also loudly.
    Relevant information should be visible so that debugging is easy.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不要盲目地重试所有失败的请求，尤其是那些写入数据或导致某些业务流程执行的请求。当应用遇到它未设计来处理的错误时，最好让应用崩溃；这叫做*快速失败*。如果你快速失败，后续不会造成进一步的损害，人类可以找出正确的处理方式。确保不仅要快速失败，而且要大声失败。相关信息应该是可见的，这样调试才容易。
- en: Write Idempotent Systems
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写幂等系统
- en: 'It’s not always obvious what state the system was left in after a failure.
    If the network fails during a remote write request, did the request succeed before
    the failure or not? This leaves you in a pickle: Do you retry and risk double-writing
    the request, or do you give up and risk losing the data? In a billing system,
    a retry might double-charge the customer, while not retrying might mean not charging
    them at all. Sometimes you can read the remote system to check, but not always.
    Local state mutations can suffer from similar problems. Nontransactional in-memory
    data structure mutations can leave your system in an inconsistent state.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 系统在失败后所处的状态并不总是显而易见的。如果在远程写入请求过程中网络失败，请求是否在失败之前成功了呢？这让你陷入困境：你是重试并冒着双重写入请求的风险，还是放弃并冒着丢失数据的风险？在计费系统中，重试可能导致客户被重复收费，而不重试则可能意味着完全不收费。有时候你可以读取远程系统来检查，但并非总能如此。本地状态变更也可能面临类似的问题。非事务性的内存数据结构变更可能让你的系统处于不一致的状态。
- en: The best way to deal with retries is to build idempotent systems. An *idempotent*
    operation is one that can be applied multiple times and still yield the same outcome.
    Adding a value to a set is idempotent. No matter how many times the value is added,
    it exists in the set once. Remote APIs can be made idempotent by allowing clients
    to supply a unique ID for each request. When a client retries, it supplies the
    same unique ID as its failed attempt; the server can then de-duplicate the request
    if it’s already been processed. Making all your operations idempotent greatly
    simplifies system interactions and eliminates a large class of possible errors.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 处理重试的最佳方法是构建幂等系统。*幂等*操作是可以多次应用并且依然得到相同结果的操作。向集合中添加一个值是幂等的。无论这个值被添加多少次，它在集合中只存在一次。通过允许客户端为每个请求提供一个唯一的
    ID，远程 API 可以变得幂等。当客户端重试时，它会提供与其失败尝试相同的唯一 ID；服务器可以在请求已经处理过的情况下去重请求。使所有操作都幂等可以大大简化系统交互并消除大量可能的错误。
- en: Clean Up Resources
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理资源
- en: 'Be sure to clean all resources when a failure occurs. Release memory, data
    structures, network sockets, and file handles that you no longer need. Operating
    systems have a fixed amount of space for file handles and network sockets; once
    exceeded, all new handles and sockets fail to open. Leaking network sockets—failing
    to close them after use—will keep useless connections alive, which will fill connection
    pools. The following code is dangerous:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在发生失败时清理所有资源。释放不再需要的内存、数据结构、网络套接字和文件句柄。操作系统对文件句柄和网络套接字的数量有固定的限制；一旦超过限制，所有新的句柄和套接字都无法打开。泄漏的网络套接字——未能在使用后关闭它们——将使无用的连接持续存在，这会填满连接池。以下代码是危险的：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Any failures that happen before `f.close()` will prevent the file pointer from
    being closed. If your language doesn’t support auto-closing, wrap your code in
    a `try`/`finally` block to safely close file handles even if an exception occurs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `f.close()` 之前发生的任何失败都会阻止文件指针被关闭。如果你的语言不支持自动关闭功能，应该将代码包裹在 `try`/`finally`
    块中，即使发生异常也能安全地关闭文件句柄。
- en: 'Many modern languages have features that automatically close resources. Rust
    will automatically close resources by invoking a destructor method when objects
    leave scope. Python’s `with` statement automatically closes handles when the call
    path leaves the block:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代语言具有自动关闭资源的功能。Rust 会在对象离开作用域时自动通过调用析构方法来关闭资源。Python 的 `with` 语句会在调用路径离开代码块时自动关闭句柄：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Logging
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志记录
- en: The first time you wrote “Hello, world!” to a terminal, you were logging. Printing
    log messages is simple and convenient for understanding code or debugging a small
    program. For complex applications, languages have sophisticated logging libraries
    to give operators more control over what’s logged and when. Operators can modulate
    log volume through logging levels and control log formats. Frameworks also inject
    contextual information—thread names, hostnames, IDs—that you can use when debugging.
    Logging frameworks work well with log management systems, which aggregate log
    messages so operators can filter and search them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次向终端写入“Hello, world!”时，你就已经在进行日志记录了。打印日志消息对于理解代码或调试小程序非常简单方便。对于复杂的应用程序，语言提供了复杂的日志库，使操作员可以更好地控制日志的记录及其时机。操作员可以通过日志级别调节日志量，并控制日志格式。框架还会注入上下文信息——线程名称、主机名、ID——这些信息在调试时非常有用。日志框架与日志管理系统配合良好，后者将日志消息聚合，供操作员过滤和搜索。
- en: Use a logging framework to make your code easier to operate and debug. Set log
    levels so your operators can control your application’s log volume. Keep logs
    atomic, fast, and secure.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志框架可以让你的代码更易于操作和调试。设置日志级别，让操作员能够控制应用程序的日志量。保持日志原子性、快速性和安全性。
- en: Use Log Levels
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用日志级别
- en: Logging frameworks have *log levels*, which let operators filter messages based
    on importance. When an operator sets a log level, all logs at or above the level
    will be emitted, while messages from lower levels will be silenced. Levels are
    usually controlled through both a global setting and package or class-level overrides.
    Log levels let operators adjust log volume as befits a given situation, from extremely
    detailed debugging logs to a steady background hum of normal operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 日志框架有*日志级别*，允许操作员根据重要性筛选消息。当操作员设置了一个日志级别时，所有等于或高于该级别的日志都会被输出，而低于该级别的消息将被静默处理。日志级别通常通过全局设置和包或类级别的覆盖来控制。日志级别允许操作员根据具体情况调整日志量，从极为详细的调试日志到正常操作的稳定背景噪音。
- en: 'For example, here’s a Java `log4j.properties` snippet that defines an ERROR-level
    root verbosity and a package-specific INFO-level verbosity for logs coming from
    the `com.foo.bar` package space:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一个 Java `log4j.properties` 片段，它定义了一个 ERROR 级别的根日志详细度，并为来自 `com.foo.bar`
    包空间的日志设置了特定包的 INFO 级别日志详细度：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You must use the appropriate criticality for each log message for log levels
    to be useful. While log levels are not completely standard, the following levels
    are common:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须为每条日志消息使用适当的严重性级别，这样日志级别才有意义。虽然日志级别并不完全标准化，但以下级别是常见的：
- en: TRACE This is an extremely fine level of detail that only gets turned on for
    specific packages or classes. This is rarely used outside of development. If you
    need line-by-line logs or data structure dumps, this level is for you. If you
    find yourself using TRACE frequently, you should consider using a debugger to
    step through code instead.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TRACE 这是一个极其细致的日志级别，仅针对特定的包或类启用。这个级别在开发之外很少使用。如果你需要逐行日志或数据结构的转储，这个级别适合你。如果你发现自己频繁使用
    TRACE，你应该考虑使用调试器逐步执行代码。
- en: DEBUG This is used when the message will be useful during a production issue
    but not during normal operations. Don’t use debug-level logging so much that the
    output is unusable when debugging; save that for TRACE.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DEBUG 当消息在生产问题期间有用，但在正常操作期间没有用时，使用此级别的日志。不要使用过多的 debug 级别日志，以至于在调试时输出变得无法使用；将这些内容保留给
    TRACE。
- en: INFO This is nice-to-have information about the state of the application but
    not indicative of any problems. Application state messages like “Service started”
    and “Listening on port 5050” go here. INFO is the default log level. Don’t emit
    frivolous logs with INFO—“just in case” logging goes into TRACE or DEBUG. INFO
    logging should tell us something useful during normal operations.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: INFO 这是关于应用程序状态的可选信息，但并不表示任何问题。像“服务已启动”和“监听端口 5050”这样的应用程序状态消息会记录在此。INFO 是默认的日志级别。不要在
    INFO 中记录无意义的日志——“以防万一”的日志应该记录在 TRACE 或 DEBUG 级别。INFO 日志应该在正常操作期间提供有用的信息。
- en: WARN These are messages about potentially problematic situations. A resource
    nearing its capacity merits a warning. Whenever you log a warning, there should
    be a concrete action you want the person seeing the message to take. If the warning
    is not actionable, log it to INFO.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WARN 这些是关于潜在问题情况的消息。接近容量的资源值得警告。每当你记录警告时，应该有一个明确的行动要求，希望看到该消息的人采取。如果警告没有可操作性，则记录为
    INFO。
- en: ERROR These messages indicate that an error that needs attention is occurring.
    An unwritable database usually merits an ERROR log. ERROR logs should be detailed
    enough to diagnose problems. Log explicit details, including relevant stack traces
    and the resulting actions the software is performing.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ERROR 这些消息表明发生了需要关注的错误。无法写入的数据库通常会产生 ERROR 日志。ERROR 日志应该足够详细，以便诊断问题。记录明确的细节，包括相关的堆栈跟踪和软件正在执行的操作。
- en: FATAL These are the “last gasp” log messages. If the program encounters a condition
    so severe that it must exit immediately, a message about the cause of the problem
    can be logged at the FATAL level. Include relevant context about the program’s
    state; locations of recovery or diagnostic-related data should be logged.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FATAL 这些是“最后的求生”日志消息。如果程序遇到严重条件，必须立即退出，可以在 FATAL 级别记录有关问题原因的消息。应包括程序状态的相关上下文；应该记录恢复或诊断相关数据的位置。
- en: 'Here’s an INFO-level log emitted in Rust:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 Rust 中发出的 INFO 级别日志：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The log line includes the error that causes the request to fail. The INFO level
    is used because the application is automatically retrying; no operator action
    is needed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 日志行包括导致请求失败的错误。使用 INFO 级别是因为应用程序正在自动重试；无需操作员采取任何措施。
- en: Keep Logs Atomic
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持日志原子性
- en: 'If information is useful only when coupled with other data, log it all *atomically*
    in one message. Atomic logs, which have all relevant information in one line,
    work better with log aggregators. Don’t assume that logs will be seen in a specific
    order; many operational tools reorder or even drop messages. Don’t rely on system
    clock timestamps for ordering: system clocks can get reset or drift between hosts.
    Avoid newlines in log messages; many log aggregators treat each new line as a
    separate message. Make extra sure that stack traces are logged in a single message,
    as they often include newlines when printed.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某条信息仅在与其他数据配合时才有用，请将其在一条消息中*原子性*地记录下来。原子性日志将所有相关信息记录在一行中，更适合与日志聚合工具配合使用。不要假设日志会按照特定的顺序出现；许多操作工具会重新排序甚至丢弃消息。不要依赖系统时钟时间戳来进行排序：系统时钟可能会重置或在不同主机间漂移。避免在日志消息中使用换行符；许多日志聚合工具将每个新行视为单独的消息。特别确保堆栈跟踪以单条消息记录，因为它们通常在打印时包含换行符。
- en: 'Here’s an example of nonatomic log messages:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个非原子性日志消息的示例：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The WARNING log message has a newline in it, which makes it hard to read. Subsequent
    lines from the WARNING have no timestamp and are intermingled with other INFO
    messages coming from another thread. The WARNING should have been written atomically
    as one line.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: WARNING 日志消息中包含换行符，这使得它很难阅读。WARNING 的后续行没有时间戳，并且与来自另一个线程的其他 INFO 消息交织在一起。WARNING
    应该原子性地作为一行记录。
- en: If log messages can’t be output atomically, include a unique ID in the messages
    so they can be stitched together later.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日志消息不能原子性地输出，请在消息中包含唯一标识符，以便稍后将它们拼接起来。
- en: Keep Logs Fast
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持日志快速
- en: Excessive logging will hurt performance. Logs must be written somewhere—to disk,
    to a console, or to a remote system. Strings must be concatenated and formatted
    before they’re written. Use parameterized logging and asynchronous appenders to
    keep logging fast.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 过度的日志记录会影响性能。日志必须写入某个地方——到磁盘、到控制台或到远程系统。字符串在写入之前必须进行拼接和格式化。使用参数化日志记录和异步附加器可以保持日志记录的快速性。
- en: You’ll find string concatenation is very slow and can be devastating in performance-sensitive
    loops. When a concatenated string is passed into a log method, the concatenation
    happens regardless of the verbosity level because arguments are evaluated before
    they’re passed into a method. Log frameworks provide mechanisms to delay string
    concatenation until it’s actually needed. Some frameworks force log messages into
    closures that aren’t evaluated unless a log line is invoked, while others provide
    support parameterized messages.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现字符串拼接非常慢，在性能敏感的循环中可能会造成灾难性的后果。当一个拼接的字符串传递到日志方法中时，无论日志的详细级别如何，拼接都会发生，因为参数在传递给方法之前就已经被计算。日志框架提供了机制，推迟字符串拼接，直到实际需要时才执行。有些框架将日志消息强制进入闭包，只有在调用日志行时才会执行，而其他框架则支持参数化消息。
- en: 'For example, Java has three ways to concatenate strings in log calls, two of
    which concatenate the string parameter before calling the `trace` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Java 在日志调用中有三种拼接字符串的方式，其中两种在调用`trace`方法之前会拼接字符串参数：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The final call uses a parameterized string that will be evaluated only if the
    log line is actually written.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的调用使用了一个参数化的字符串，只有在实际写入日志行时才会被评估。
- en: 'You can also manage performance impact using *appenders*. Appenders route logs
    to different locations: the console, a file, or a remote log aggregator. Default
    log appenders usually operate in the caller’s thread, the same way a call to `print`
    would. *Asynchronous* appenders write log messages without blocking execution
    threads. This improves performance since application code doesn’t need to wait
    for logs to be written. *Batching* appenders buffer log messages in-memory before
    writing to disk, thus improving write throughput. The operating system’s page
    cache helps log throughput by acting as a buffer as well. While asynchronous and
    batching writes improve performance, they can result in lost log messages if an
    application crashes, since not all logs are guaranteed to be flushed to disk.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用*附加器*来管理性能影响。附加器将日志路由到不同的位置：控制台、文件或远程日志聚合器。默认的日志附加器通常在调用者的线程中操作，就像调用`print`一样。*异步*附加器在不阻塞执行线程的情况下写入日志消息。这提高了性能，因为应用程序代码不需要等待日志写入。*批处理*附加器在写入磁盘之前将日志消息缓存在内存中，从而提高了写入吞吐量。操作系统的页面缓存也通过充当缓冲区来帮助日志吞吐量。虽然异步和批量写入提高了性能，但如果应用程序崩溃，可能会导致日志消息丢失，因为并不是所有日志都能保证写入磁盘。
- en: Beware that changing log verbosity and configuration can eliminate race conditions
    and bugs because it slows down the application. If you enable verbose logging
    to debug an issue and discover a bug disappears, the logging change itself might
    be the reason.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，改变日志的详细程度和配置可以消除竞争条件和漏洞，因为这会减慢应用程序的速度。如果你启用了详细日志记录来调试一个问题，并发现一个漏洞消失了，日志更改本身可能就是原因。
- en: Don’t Log Sensitive Data
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要记录敏感数据
- en: Be careful when dealing with sensitive data. Log messages shouldn’t include
    private data like passwords, security tokens, credit card numbers, or emails.
    This might seem obvious, but it’s easy to get wrong—simply logging a URL or HTTP
    response can expose information that log aggregators are not set up to safeguard.
    Most frameworks support rule-based string replacement and redaction; configure
    them, but do not rely on them as your only defense. Be paranoid; logging sensitive
    data can create security risks and violate privacy regulations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理敏感数据时要小心。日志消息不应包含私密数据，如密码、安全令牌、信用卡号码或电子邮件。这可能看起来很显而易见，但很容易出错——仅仅记录一个 URL
    或 HTTP 响应可能会暴露日志聚合器未能保护的信息。大多数框架支持基于规则的字符串替换和删除；配置它们，但不要将它们作为唯一的防护措施。要保持警觉；记录敏感数据可能带来安全风险，并违反隐私法规。
- en: Metrics
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 度量
- en: Instrument your application with metrics to see what it is doing. Metrics are
    the numerical equivalent of logs; they measure application behavior. How long
    did a query take? How many elements are in a queue? How much data was written
    to disk? Measuring application behavior helps detect problems and is useful for
    debugging.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过度量工具仪表化您的应用程序，以了解其行为。度量是日志的数字等效物；它们测量应用程序行为。查询花费了多长时间？队列中有多少元素？写入磁盘的数据量？测量应用程序行为有助于检测问题，并对调试有用。
- en: 'There are three common metric types: counters, gauges, and histograms. These
    names are similar, but not consistent, across different monitoring systems. *Counters*
    measure the number of times an event happens. Using a cache hit counter and a
    request counter, you can calculate cache hit rates. Counters only increase in
    value or reset to 0 when a process restarts (they are *monotonically increasing*).
    *Gauges* are point-in-time measurements that can go up or down; think of a speedometer
    or a gas volume indicator in a car. Gauges expose statistics such as the size
    of a queue, stack, or map. *Histograms* break events into ranges based on their
    magnitude. Each range has a counter that is incremented whenever an event value
    falls into its range. Histograms commonly measure the amount of time requests
    take, or data payload sizes.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种常见的度量类型：计数器、测量器和直方图。这些名称在不同的监控系统中可能相似，但不一致。*计数器*用于测量事件发生的次数。使用缓存命中计数器和请求计数器，您可以计算缓存命中率。计数器的值仅在进程重新启动时增加或重置为0（它们是*单调递增*的）。*测量器*是时间点测量，可以上下波动；可以将其视为汽车速度表或汽车中的油量指示器。测量器公开统计数据，如队列、堆栈或映射的大小。*直方图*根据事件的大小将事件分成范围。每个范围都有一个计数器，在事件值落入其范围时递增。直方图通常测量请求花费的时间或数据有效负载大小。
- en: System performance is often measured in terms of metric values at threshold
    percentiles—for example, the 99th percentile, referred to as *P99*. A system with
    a 2-millisecond P99 latency takes 2 milliseconds or less to respond to 99 percent
    of the requests it receives. Percentiles are derived from histograms. To cut down
    on the data that needs to be tracked, some systems require you to configure which
    percentiles you care about; if a system tracks P95 by default but you have a P99
    service level objective (SLO*)*, make sure to change settings accordingly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 系统性能通常以阈值百分位数的度量值来衡量，例如第99百分位数，简称为*P99*。具有2毫秒P99延迟的系统在收到的请求中，99%的情况下响应时间为2毫秒或更少。百分位数来自直方图。为了减少需要跟踪的数据量，一些系统要求您配置关注的百分位数；如果系统默认跟踪P95，但您有P99服务水平目标（SLO*），请确保相应更改设置。
- en: Application metrics are aggregated into centralized *observability* *systems*
    like Datadog, LogicMonitor, or Prometheus. Observability is a concept from control
    theory that defines how easy it is to determine the state of a system by looking
    at its outputs. Observability systems try to make it easier to determine a running
    application’s state by providing dashboards and monitoring tools on top of aggregated
    metrics. Dashboards show operators what’s going on in the system, and monitoring
    tools trigger alerts based on metric values.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序度量被聚合到像Datadog、LogicMonitor或Prometheus这样的集中式*可观测性* *系统*中。可观测性是控制理论中的一个概念，定义通过观察其输出来确定系统状态的便捷程度。可观测性系统试图通过提供仪表板和监控工具来更轻松地确定运行中应用程序的状态。仪表板向运营商展示系统中的运行情况，并基于度量值触发警报的监控工具。
- en: Metrics are also used to automatically scale a system up or down. *Autoscaling*
    is common in environments that provide dynamic resource allocation. For example,
    cloud hosts may automatically adjust the number of running instances by monitoring
    load metrics. Autoscaling increases server capacity when it is needed and reduces
    server capacity to save money later.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 指标也用于自动缩放系统。*自动缩放*在提供动态资源分配的环境中很常见。例如，云主机可以通过监视负载指标自动调整运行实例的数量。自动缩放在需要时增加服务器容量，在以后节省费用时减少服务器容量。
- en: To track SLOs, use observability systems, and take advantage of autoscaling
    features, you must measure everything. Metrics are tracked using a standard metrics
    library; most application frameworks provide these. As a developer, it is your
    job to ensure that important metrics are exposed to observability systems.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟踪SLO，使用可观测性系统，并利用自动缩放功能，必须测量所有内容。度量使用标准度量库进行跟踪；大多数应用程序框架都提供这些功能。作为开发者，您的工作是确保重要的度量指标暴露给可观测性系统。
- en: Use Standard Metrics Libraries
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用标准度量库
- en: While counters, gauges, and histograms are pretty easy to calculate, don’t roll
    your own metrics library. Nonstandard libraries are a maintenance nightmare. Standard
    libraries will integrate with everything out of the box. Your company probably
    has a metrics library that they prefer. If they do, use it. If they don’t, start
    a discussion to adopt one.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然计数器、仪表和直方图的计算相对简单，但不要自行编写度量库。非标准库是维护的噩梦。标准库可以开箱即用并与所有内容集成。你的公司可能有他们偏好的度量库。如果有，使用它。如果没有，开始讨论采用一个。
- en: Most observability systems offer metric client libraries in a range of languages.
    We’ll use a StatsD client in a simple Python web application to show what metrics
    look like. Metrics libraries all look pretty similar, so our example should translate
    nearly verbatim to whichever library you use.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数可观察性系统提供多种语言的度量客户端库。我们将在一个简单的 Python Web 应用程序中使用 StatsD 客户端来展示度量的样子。度量库的结构通常很相似，所以我们的示例几乎可以无缝地迁移到你使用的任何库中。
- en: 'The Python web application in [Listing 4-1](#listing4-1) has four methods:
    `set`, `get`, `unset`, and `dump`. The methods `set` and `get` simply set and
    retrieve values in a map stored in the service. The `unset` method deletes key-value
    pairs from the map and `dump` JSON-encodes the map and returns it.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 4-1](#listing4-1)中的 Python Web 应用程序有四个方法：`set`、`get`、`unset` 和 `dump`。`set`
    和 `get` 方法简单地在服务中存储的映射中设置和检索值。`unset` 方法从映射中删除键值对，`dump` 将映射进行 JSON 编码并返回。
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 4-1: An example Python Flask application using the StatsD client metrics
    library'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-1：一个使用 StatsD 客户端度量库的 Python Flask 应用程序示例
- en: This example uses counters `key_hit` and `key_miss` to track hits and misses
    in `get` with `statsd.incr`. A timer (`statsd.timer`) measures how long it takes
    to encode the map into JSON, which will be added to a timing histogram. Serialization
    is a costly, CPU-intensive operation, so it should be measured. A gauge (`statsd.gauge`)
    measures the current size of the map. We could have used increment and decrement
    methods on a counter to track the map size, but using a gauge is less error prone.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用计数器 `key_hit` 和 `key_miss` 来追踪 `get` 操作中的命中和未命中，使用 `statsd.incr`。定时器（`statsd.timer`）用来测量将映射编码为
    JSON 所需的时间，结果将被添加到定时直方图中。序列化是一个昂贵的 CPU 密集型操作，因此应该进行度量。仪表（`statsd.gauge`）用来测量映射的当前大小。我们本可以使用计数器的增量和减量方法来追踪映射大小，但使用仪表更不容易出错。
- en: Web application frameworks like Flask usually do a lot of metric calculations
    for you. Most will count all HTTP status codes for every method invocation in
    the web service and time all HTTP requests. Framework metrics are a great way
    to get a ton of metrics for free; just configure the framework to output to your
    observability system. Plus, your code will be cleaner since measurement happens
    underneath.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Flask 这样的 Web 应用框架通常会为你做很多度量计算。大多数框架会统计每次方法调用的所有 HTTP 状态码，并对所有 HTTP 请求进行计时。框架度量是获取大量度量的绝佳方式，只需配置框架将结果输出到你的可观察性系统中。而且，你的代码会更简洁，因为度量是在框架底层进行的。
- en: Measure Everything
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量一切
- en: 'Measurements are cheap; you should use them extensively. Measure all of the
    following data structures, operations, and behaviors:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 测量是廉价的；你应该广泛使用它们。测量以下所有数据结构、操作和行为：
- en: Resource pools
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源池
- en: Caches
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Data structures
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构
- en: CPU-intensive operations
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 密集型操作
- en: I/O-intensive operations
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O 密集型操作
- en: Data size
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据大小
- en: Exceptions and errors
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常和错误
- en: Remote requests and responses
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程请求和响应
- en: Use gauges to measure the size of resource pools. Pay special attention to thread
    pools and connection pools. Large pools are an indication that the system is stuck
    or unable to keep up.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仪表来测量资源池的大小。特别注意线程池和连接池。大型池通常表示系统卡住或无法跟上。
- en: Count cache hits and misses. Shifts in the hit-to-miss ratio impact application
    performance.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 统计缓存命中和未命中。命中与未命中比率的变化会影响应用性能。
- en: Measure the size of key data structures with gauges. Abnormal data structure
    size is an indication that something strange is going on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仪表测量关键数据结构的大小。异常的数据结构大小表明可能有不正常的情况发生。
- en: Time CPU-intensive operations. Pay special attention to data serialization operations,
    which are surprisingly expensive. A simple JSON-encode of a data structure is
    often the costliest operation in code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对 CPU 密集型操作进行计时。特别注意数据序列化操作，这些操作出奇地昂贵。简单的 JSON 编码数据结构通常是代码中最昂贵的操作。
- en: Disk and network I/O operations are slow and unpredictable. Use timers to measure
    how long they take. Measure the size of the data that your code deals with. Track
    the size of *remote procedure call* *(RPC**)* payloads. Track the size of data
    generated for I/O using histograms (similar to timers) so you can see 99th percentile
    data sizes. Large data has an impact on memory footprint, I/O speed, and disk
    usage.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘和网络I/O操作既慢又不可预测。使用计时器来衡量它们所需的时间。测量你的代码处理的数据大小。跟踪*远程过程调用*（*RPC*）有效载荷的大小。使用直方图（类似于计时器）跟踪用于I/O的生成数据的大小，这样你可以看到99百分位的数据大小。大数据对内存占用、I/O速度和磁盘使用有影响。
- en: Count every exception, error response code, and bad input. Measuring errors
    makes it easy to trigger an alert when things go wrong.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 计算每个异常、错误响应代码和错误输入。测量错误使得在出现问题时容易触发警报。
- en: Measure any requests to your application. An abnormally high or low request
    count is a sign that something is amiss. Users want your systems to respond quickly,
    so you need to measure latency. Time all responses so you know when your system
    is slow.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 测量对应用程序的任何请求。异常高或低的请求数是系统出现问题的信号。用户希望你的系统响应迅速，因此你需要测量延迟。记录所有响应时间，以便知道何时系统变慢。
- en: Take time to understand how your metrics library works. It’s not always obvious
    how a library calculates a metric; many libraries will sample measurements. Sampling
    keeps performance fast and reduces disk and memory usage, but it also makes measurements
    less accurate.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间了解你的度量库是如何工作的。库如何计算度量并不总是显而易见；许多库会进行采样测量。采样可以保持性能快速并减少磁盘和内存使用，但它也使得测量结果不那么精确。
- en: Traces
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪
- en: 'Developers all know about stack traces, but there’s a less familiar kind of
    trace: a *distributed call trace*. A single call to a frontend API might result
    in hundreds of downstream RPC calls to different services. Distributed call traces
    stitch all of these downstream calls together into one graph. Distributed traces
    are useful for debugging errors, measuring performance, understanding dependencies,
    and analyzing system cost (which APIs are the most expensive to serve, which customers
    cost the most, and so on).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员都知道堆栈跟踪，但还有一种较不常见的跟踪方式：*分布式调用跟踪*。一次对前端API的调用可能会导致数百个下游RPC调用到不同的服务。分布式调用跟踪将所有这些下游调用串联成一个图。分布式追踪对于调试错误、衡量性能、理解依赖关系和分析系统成本（哪些API最昂贵，哪些客户最花费等）都非常有用。
- en: RPC clients use a tracing library to attach a call-trace ID to their request.
    Subsequent RPC calls by downstream services attach the same call-trace ID. Services
    then report the invocations that they receive along with the call-trace ID and
    other data, such as metadata tags and processing time. A dedicated system records
    all these reports and stitches call traces back together by call-trace ID. With
    this knowledge, the tracing system can present full distributed call graphs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: RPC客户端使用追踪库将调用追踪ID附加到请求中。后续的RPC调用由下游服务附加相同的调用追踪ID。服务随后报告它们接收到的调用，以及调用追踪ID和其他数据，如元数据标签和处理时间。一个专门的系统记录所有这些报告，并通过调用追踪ID将调用追踪重新拼接在一起。凭借这些信息，追踪系统可以呈现完整的分布式调用图。
- en: Call-trace IDs are usually propagated for you automatically through RPC client
    wrappers and service meshes. Verify that you’re propagating any required state
    as you make calls to other services.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 调用追踪ID通常会通过RPC客户端包装器和服务网格自动传播。确保在调用其他服务时传播任何必需的状态。
- en: Configuration
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: Applications and services should expose settings that allow developers or site
    reliability engineers (SREs) to configure runtime behavior. Applying configuration
    best practices will make your code easier to run. Don’t get too creative; use
    a standard configuration format, provide sensible defaults, validate configuration
    inputs, and avoid dynamic configuration when possible.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序和服务应该暴露设置，允许开发人员或站点可靠性工程师（SREs）配置运行时行为。应用配置最佳实践将使你的代码更易于运行。不要过于创新；使用标准配置格式，提供合理的默认值，验证配置输入，并尽可能避免动态配置。
- en: 'Configuration can be expressed in many ways:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 配置可以通过多种方式表达：
- en: Files in plain, human-readable formats such as INI, JSON, or YAML
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯文本、可读性格式的文件，如INI、JSON或YAML
- en: Environment variables
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量
- en: Command line flags
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行标志
- en: A custom *domain-specific language* *(DSL**)*
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个自定义的*领域特定语言*（*DSL*）
- en: The language the application is written in
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序编写的语言
- en: Human-readable config files, environment variables, and command line flags are
    the most common approaches. Files are used when there are many values to set or
    there’s a desire to version control the configurations. Environment variables
    are easy to set in scripts, and environments can be easily examined and logged.
    Command line flags are easy to set and are visible in process lists like `ps`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 人类可读的配置文件、环境变量和命令行标志是最常见的配置方式。当需要设置多个值或希望对配置进行版本控制时，通常使用文件。环境变量易于在脚本中设置，并且可以轻松检查和记录。命令行标志易于设置，并且在进程列表中可见，比如`ps`命令。
- en: DSLs are helpful when configuration needs programmable logic, like `for` loops
    or `if` statements. DSL-based configuration is commonly used when an application
    is written in a DSL-friendly language (like Scala). Using a DSL rather than a
    full-blown programming language, authors can provide shortcuts for complex operations
    and limit configurations to safe values and types—an important consideration for
    security and startup performance. But DSLs are hard to parse using standard tools,
    which makes interoperability with other tools difficult.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置需要可编程逻辑（如`for`循环或`if`语句）时，DSL（领域特定语言）非常有帮助。基于DSL的配置通常在应用程序使用DSL友好的语言（如Scala）时使用。使用DSL而非完整的编程语言，作者可以为复杂操作提供快捷方式，并限制配置为安全的值和类型——这是考虑安全性和启动性能时的重要因素。但DSL使用标准工具进行解析时比较困难，这使得与其他工具的互操作性变得更加困难。
- en: Expressing configuration in the application’s language usually happens when
    the application is written in a scripting language like Python. Using code to
    generate configuration is powerful but also dangerous. Customizable logic obscures
    the configuration the application is seeing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的语言中表达配置通常发生在应用程序使用像Python这样的脚本语言编写时。使用代码生成配置非常强大，但也很危险。可定制的逻辑会模糊应用程序看到的配置。
- en: Don’t Get Creative with Configuration
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要在配置上过于创新
- en: Configuration systems should be boring. An operator paged at 3 AM shouldn’t
    need to remember Tcl syntax to change a timeout value.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 配置系统应该是简单的。当操作员在凌晨3点被叫醒时，他不应该需要记住Tcl语法来更改超时值。
- en: Innovating on a configuration system is tempting. Configuration is familiar
    to everyone, and simple configuration systems seem to miss useful features—variable
    substitution, `if` statements, and so on. Many creative and well-meaning people
    have spent incredible amounts of time making fancy configuration systems. Sadly,
    the cleverer your configuration scheme is, the more bizarre your bugs will be.
    Do not get creative with configuration—use the simplest possible approach that
    will work. A static configuration file in a single standard format is ideal.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对配置系统进行创新很有诱惑力。配置是每个人都熟悉的，而简单的配置系统似乎缺少有用的功能——如变量替换、`if`语句等。许多富有创意且心地善良的人花费了大量时间来制作精美的配置系统。可悲的是，你的配置方案越聪明，你遇到的错误就会越离奇。不要在配置上过于创新——使用最简单且有效的方法。一个标准格式的静态配置文件是理想的选择。
- en: Most applications are configured through a static configuration file. Changing
    the file while the application is running won’t affect the application; to pick
    up changes, the application needs to be restarted. Dynamic configuration systems
    are used when an application needs to be reconfigured without restarting. Dynamic
    configuration is typically stored in a dedicated configuration service, which
    gets polled or pushed by the application when values change. Alternatively, dynamic
    configuration is refreshed by periodically checking a local config file for updates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序通过静态配置文件进行配置。应用程序运行时更改该文件不会影响应用程序；要应用更改，必须重新启动应用程序。动态配置系统用于在不重新启动应用程序的情况下重新配置应用程序。动态配置通常存储在专用的配置服务中，当值发生变化时，应用程序会轮询或推送更新。或者，动态配置通过定期检查本地配置文件的更新来刷新。
- en: Dynamic configuration is usually not worth the complexity it introduces. You
    need to think through all the implications of various configurations changing
    midflight. It also makes it harder to track when configuration was changed, who
    changed it, and what the value used to be—information that can be critical when
    debugging operational issues. It can also add external dependencies on other distributed
    systems. It sounds rudimentary, but restarting a process to pick up a new configuration
    is usually operationally and architecturally superior.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 动态配置通常不值得引入的复杂性。你需要仔细考虑各种配置在运行过程中改变的所有影响。它还使得追踪配置何时被更改、谁更改了它以及原始值是什么变得更加困难——这些信息在调试操作问题时可能至关重要。它还可能依赖于其他分布式系统。虽然听起来很基础，但重新启动进程以采纳新配置在操作和架构上通常更具优势。
- en: There are some common use cases that do warrant dynamic configuration, though.
    Log verbosity is frequently a dynamic setting. Operators can change the log level
    to a higher verbosity like DEBUG when something strange is going on. Restarting
    a process when odd behavior surfaces might change the behavior that you’re trying
    to observe. Flipping a running process’s log level lets you peek into its behavior
    without restarting.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，确实有一些常见的用例需要动态配置。日志详细级别通常是一个动态设置。当出现异常情况时，运维人员可以将日志级别更改为更高的详细级别，如DEBUG。重新启动进程可能会改变你正在观察的异常行为。通过调整正在运行的进程的日志级别，可以在不重启的情况下窥视其行为。
- en: Log and Validate All Configuration
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录和验证所有配置
- en: Log all (nonsecret) configuration immediately upon startup to show what the
    application is seeing. Developers and operators occasionally misunderstand where
    a configuration file is supposed to be placed or how multiple configuration files
    get merged. Logging config values shows users whether the application is seeing
    the expected configuration.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时立即记录所有（非机密）配置，以显示应用程序正在看到的内容。开发人员和运维人员偶尔会误解配置文件应该放置的位置，或者多个配置文件是如何合并的。记录配置值可以向用户展示应用程序是否看到预期的配置。
- en: 'Always validate configuration values when they’re loaded. Do the validation
    only once, as early as possible (right after the configuration is loaded). Make
    sure that the values are set to the proper types, such as an integer for a port,
    and check that values make logical sense: check boundaries, string length, valid
    enum values, and so on. `–200` is an integer but not a valid port. Take advantage
    of configuration systems that have robust type systems to express acceptable configuration
    values.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载配置时始终验证配置值。验证只需进行一次，并尽可能早（在配置加载后立即）。确保值被设置为正确的类型，比如端口号应为整数，并检查值是否符合逻辑：检查边界、字符串长度、有效的枚举值等。`–200`是一个整数，但不是有效的端口。利用具有强大类型系统的配置系统来表达可接受的配置值。
- en: Provide Defaults
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供默认值
- en: If a user has to set a large number of configuration parameters, your system
    will be hard to run. Set good defaults so your application will work well for
    most users out of the box. Default to network ports greater than 1024 (lower ports
    are restricted) if no port is configured. Use the system’s temporary directory
    or the user’s home directory if directory paths are unspecified.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户必须设置大量配置参数，那么你的系统将变得难以运行。设置良好的默认值，使你的应用程序在大多数用户的机器上能够即插即用。如果没有配置端口，则默认为大于1024的网络端口（较低的端口被限制）。如果未指定目录路径，则使用系统的临时目录或用户的主目录。
- en: Group Related Configuration
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将相关配置分组
- en: It’s easy for application configuration to grow unmanageable, especially key-value
    formats that don’t support nested configuration. Use a standard format like YAML
    that allows for nesting. Grouping related properties makes configuration easier
    to organize and maintain.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序配置很容易变得难以管理，尤其是那些不支持嵌套配置的键值格式。使用像YAML这样的标准格式，它允许嵌套。将相关属性分组，使配置更易于组织和维护。
- en: 'Combine tightly coupled parameters (like timeout duration and unit) in a single
    structure so the relationship is clear, and force the operator to declare the
    values atomically. Rather than defining `timeout_duration=10` and `timeout_units=second`,
    use `timeout=10s` or `timeout: { duration: 10, units = second }`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '将紧密耦合的参数（如超时时间和单位）组合到一个结构中，以便清晰地表示它们之间的关系，并强制运维人员原子地声明这些值。与其定义`timeout_duration=10`和`timeout_units=second`，不如使用`timeout=10s`或`timeout:
    { duration: 10, units = second }`。'
- en: Treat Configuration as Code
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将配置视为代码
- en: The *configuration as code (CAC)* philosophy says that configuration should
    be subjected to the same rigor as code. Configuration mistakes can be disastrous.
    A single incorrect integer or missing parameter can break an application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*配置即代码（CAC）*理念认为，配置应该像代码一样受到严格管理。配置错误可能是灾难性的。一个错误的整数或缺少的参数都可能使应用程序崩溃。'
- en: To keep configuration changes safe, configuration should be version controlled,
    reviewed, tested, built, and published. Keep configuration in a VCS like Git so
    you have a history of changes. Review configuration changes just like code reviews.
    Validate that configuration is properly formatted and conforms to expected types
    and value bounds. Build and publish configuration packages. We cover more on config
    delivery in Chapter 8.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保配置更改的安全性，配置应进行版本控制、审查、测试、构建和发布。将配置保存在像 Git 这样的版本控制系统中，这样你可以追踪更改历史。像代码审查一样审查配置更改。验证配置是否格式正确，并符合预期的类型和值范围。构建并发布配置包。我们将在第8章详细讲解配置交付。
- en: Keep Configuration Files Clean
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持配置文件干净
- en: 'Clean configuration is easier for others to understand and change. Delete unused
    configuration, use standard formatting and spacing, and don’t blindly copy configuration
    from other files (an example of *cargo culting*: copying things without actually
    understanding what they do or how they work). Tidy configuration is hard to maintain
    when you’re iterating quickly, but misconfiguration causes production outages.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 干净的配置更容易被他人理解和更改。删除未使用的配置，使用标准的格式和间距，不要盲目复制其他文件中的配置（*cargo culting*的例子：复制东西却没有真正理解它们的功能或如何工作）。整洁的配置在快速迭代时难以维护，但配置错误会导致生产环境中断。
- en: Don’t Edit Deployed Configuration
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要编辑已部署的配置
- en: Avoid hand-editing configuration on a specific machine. One-off config changes
    are overwritten on subsequent deployments, it’s unclear who made the changes,
    and machines with similar configuration end up diverging.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在特定机器上手动编辑配置。一旦配置发生变动，后续的部署会覆盖这些更改，且很难追踪谁做了更改，具有相似配置的机器最终会出现分歧。
- en: As with keeping configuration files clean, resisting the temptation to hand-edit
    a config file in production is difficult, and in some cases unavoidable. If you
    edit configuration manually during a production incident, make sure changes get
    committed to the source of truth (the VCS) later.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与保持配置文件干净一样，抵制在生产环境中手动编辑配置文件的诱惑是困难的，有时是不可避免的。如果在生产事件中手动编辑了配置，请确保稍后将更改提交到“真相源”（版本控制系统）。
- en: Tools
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具
- en: Operable systems come with tools that help operators run the application. Operators
    might need to bulk-load data, run a recovery, reset database state, trigger a
    leadership election, or shift a partition assignment from one machine to another.
    Systems should come with tools to help operators deal with common operations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 可操作的系统配备了帮助操作员运行应用程序的工具。操作员可能需要批量加载数据、执行恢复、重置数据库状态、触发领导选举或将分区分配从一台机器转移到另一台机器。系统应配备帮助操作员处理常见操作的工具。
- en: Tool writing is collaborative. In some cases, you will be expected to write
    and supply operations tools. Organizations with strong SRE teams might also write
    tools for your systems. Regardless, work with your operations team to understand
    what they need.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 工具编写是一个协作过程。在某些情况下，您将被要求编写并提供操作工具。拥有强大 SRE 团队的组织也可能为您的系统编写工具。不论如何，请与您的运维团队合作，了解他们的需求。
- en: 'SREs will usually prefer CLI-based tools and self-describing APIs since they
    are easily scriptable. Scriptable tools are easy to automate. If you plan on building
    UI-based tools, abstract the logic into a shared library or service that CLI-based
    tools can use as well. And treat your system’s tools as code like any other: follow
    clean coding standards and test rigorously.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: SRE 通常更喜欢基于 CLI 的工具和自描述的 API，因为它们易于脚本化。可脚本化的工具易于自动化。如果你计划构建基于 UI 的工具，请将逻辑抽象为共享的库或服务，CLI
    工具也可以使用这些逻辑。并且像对待代码一样对待系统的工具：遵循清晰的编码标准并严格测试。
- en: Your company might already have an existing toolset; it’s common to have a standard
    internal web tools framework, for example. Integrate your tools with the standard
    frameworks available to you. Look for *single panes of glass* (unified management
    consoles). Companies with unified management consoles will expect all tools to
    be integrated with it. If your company has existing CLI-based tools, ask if it
    makes sense to integrate your tools with them. Everyone is used to the existing
    tool interfaces; integrating with them will make your tools easier to work with.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你的公司可能已经有现成的工具集；例如，通常会有一个标准的内部Web工具框架。将你的工具与现有的标准框架集成。寻找*单一管理控制台*（统一管理控制台）。拥有统一管理控制台的公司将期望所有工具都能与其集成。如果你的公司已有基于CLI的工具，可以询问是否有必要将你的工具与它们集成。每个人都习惯了现有的工具界面；与它们集成将使你的工具更容易使用。
- en: Do’s and Don’ts
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做与不做
- en: '| **Do’s** | **Don’ts** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **做** | **不做** |'
- en: '| --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **DO** prefer compilation errors to runtime errors.  | **DON’T** use exceptions
    for application logic.  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **做** 优先处理编译错误而非运行时错误。 | **不做** 使用异常处理应用逻辑。 |'
- en: '| **DO** make things immutable whenever possible.  | **DON’T** use return codes
    for exception handling.  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **做** 尽可能让事物保持不可变。 | **不做** 使用返回代码进行异常处理。 |'
- en: '| **DO** validate inputs and outputs.  | **DON’T** catch exceptions that you
    can’t handle.  |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| **做** 验证输入和输出。 | **不做** 捕获无法处理的异常。 |'
- en: '| **DO** study the OWASP Top 10.  | **DON’T** write multiline logs.  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| **做** 学习OWASP十大风险。 | **不做** 编写多行日志。 |'
- en: '| **DO** use bug-checking tools and types or type hinting.  | **DON’T** write
    secrets or sensitive data to logs.  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **做** 使用错误检查工具和类型或类型提示。 | **不做** 将秘密或敏感数据写入日志。 |'
- en: '| **DO** clean up resources after exceptions (especially sockets, file pointers,
    and memory).  | **DON’T** manually edit configuration on a machine.  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| **做** 在异常后清理资源（特别是套接字、文件指针和内存）。 | **不做** 手动编辑机器上的配置。 |'
- en: '| **DO** instrument your code with metrics.  | **DON’T** store passwords or
    secrets in configuration files.  |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **做** 在代码中加入度量指标。 | **不做** 在配置文件中存储密码或秘密信息。 |'
- en: '| **DO** make your application configurable.  | **DON’T** write custom configuration
    formats.  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| **做** 使你的应用程序可配置。 | **不做** 编写自定义配置格式。 |'
- en: '| **DO** validate and log all configuration.  | **DON’T** use dynamic configuration
    if you can avoid it.  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| **做** 验证并记录所有配置。 | **不做** 如果可以避免，使用动态配置。 |'
- en: Level Up
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升技能
- en: There aren’t many books dedicated to writing operable code. Instead, these subjects
    appear in chapters throughout many software engineering books. Chapter 8 of Steve
    McConnell’s *Code Complete* (Microsoft Press, 2004) covers defensive programming.
    Chapters 7 and 8 of *Clean Code* by Robert C. Martin (Pearson, 2008) cover error
    handling and boundaries. These are good places to start.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有书籍专门讲解编写可操作的代码。相反，这些主题出现在许多软件工程书籍的各个章节中。例如，Steve McConnell的《代码大全》（微软出版社，2004年）第8章讲述了防御性编程。Robert
    C. Martin的《代码整洁之道》（Pearson，2008年）第7和第8章讨论了错误处理和边界。它们是不错的起点。
- en: The web also has a lot of writing on defensive programming, exceptions, logging,
    configuration, and tooling. The *Amazon Builders’ Library* ([https://aws.amazon.com/builders-library/](https://aws.amazon.com/builders-library/))
    from Amazon is a particularly useful resource.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上也有很多关于防御性编程、异常处理、日志记录、配置和工具的文章。*亚马逊构建者图书馆*（[https://aws.amazon.com/builders-library/](https://aws.amazon.com/builders-library/)）是一个特别有用的资源。
- en: Google SRE group’s *Building Secure & Reliable Systems* (O’Reilly Media, 2020)
    is a treasure trove of sound advice, particularly from a security point of view.
    Google’s *Site Reliability Engineering* (O’Reilly Media, 2016) is the canonical
    book on all things site reliability related. It’s less focused on *writing* operable
    code, but it’s still a must-read. It will give you a glimpse into the complex
    world of running production software. Both are available for free online, as well
    as in print.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Google SRE团队的《构建安全可靠的系统》（O’Reilly Media，2020年）是一本宝贵的建议书，尤其是从安全角度看。Google的《站点可靠性工程》（O’Reilly
    Media，2016年）是关于站点可靠性相关事宜的经典书籍。虽然它更侧重于*写* 可操作的代码，但它仍然是一本必读书籍。它将让你对运行生产软件的复杂世界有所了解。这两本书都可以在网上免费获得，也可以印刷版购买。
