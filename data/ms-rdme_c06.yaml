- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Testing
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试
- en: Writing, running, and fixing tests can feel like busywork. In fact, it’s easy
    for tests to *be* busywork. Bad tests add developer overhead without providing
    value and can increase test suite instability. This chapter will teach you to
    test effectively. We’ll discuss what tests are used for, different test types,
    different test tools, how to test responsibly, and how to deal with nondeterminism
    in tests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 编写、运行和修复测试可能会让人觉得是在做无意义的工作。实际上，测试很容易变成*无意义的工作*。糟糕的测试会增加开发者的负担而没有提供价值，并且可能增加测试套件的不稳定性。本章将教你如何高效地进行测试。我们将讨论测试的用途、不同类型的测试、不同的测试工具、如何负责任地进行测试，以及如何应对测试中的非确定性问题。
- en: The Many Uses of Tests
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试的多种用途
- en: 'Most developers know the fundamental function of tests: tests check that code
    works. But tests serve other purposes as well. They protect the code from future
    changes that unintentionally alter its behavior, encourage clean code, force developers
    to use their own APIs, document how components are to be interacted with, and
    serve as a playground for experimentation.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者知道测试的基本功能：测试检查代码是否正常工作。但测试还有其他用途。它们保护代码免受未来更改的影响，这些更改可能会无意中改变其行为，鼓励编写干净的代码，迫使开发者使用自己的API，记录组件如何交互，并作为实验的平台。
- en: 'Above all, tests verify that software behaves as expected. Unpredictable behavior
    causes problems for users, developers, and operators. Initially, tests show that
    code works as specified. Tests then remain to shield existing behavior from new
    changes. When an old test fails, a decision must be made: Did the developer intend
    to change behavior, or was a bug introduced?'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，测试验证软件是否按预期行为运行。不可预测的行为会给用户、开发者和操作员带来问题。最初，测试显示代码是否按照规格工作。测试随后留下来，保护现有行为不受新更改的影响。当一个旧的测试失败时，必须做出决定：开发者是否有意改变行为，还是引入了一个bug？
- en: Test writing also forces developers to think about the interface and implementation
    of their program. Developers usually first interact with their code in tests.
    New code will have rough edges; testing exposes clumsy interface design early
    so it can be corrected. Tests also expose messy implementation. *Spaghetti code*,
    or code that has too many dependencies, is difficult to test. Writing tests forces
    developers to keep their code well factored by improving separation of concerns
    and reducing tight coupling.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试也迫使开发者思考他们程序的接口和实现。开发者通常首先通过测试与代码进行交互。新代码通常会有一些不完善之处；测试能够及早暴露笨拙的接口设计，以便进行修正。测试还能够暴露混乱的实现。*意大利面条代码*，或者是具有过多依赖的代码，很难进行测试。编写测试迫使开发者保持代码的良好结构，通过改善关注点分离和减少紧密耦合来提升代码质量。
- en: Code cleanliness side effects in tests are so strong that *test-driven development*
    *(TDD**)* has become commonplace. TDD is the practice of writing tests before
    code. The tests fail when written, and then code is written to make them pass.
    TDD forces developers to think about behavior, interface design, and integration
    before cranking out a bunch of code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码的副作用如此强烈，以至于*测试驱动开发*（*TDD*）已成为一种常见做法。TDD是先编写测试，再编写代码的实践。编写测试时，测试会失败，然后编写代码使其通过。TDD迫使开发者在编写大量代码之前思考行为、接口设计和集成。
- en: Tests serve as a form of documentation, illustrating how the code is meant to
    be interacted with. They are the first place an experienced programmer starts
    reading to understand a new codebase. Test suites are a great playground. Developers
    run tests with debuggers attached to step-through code. As bugs are discovered
    or questions about behavior arise, new tests can be added to understand them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 测试作为一种文档形式，说明了代码的交互方式。它们是经验丰富的程序员开始阅读以理解新代码库的第一站。测试套件是一个很好的实验平台。开发者运行测试时，会附加调试器逐步执行代码。当发现bug或行为出现疑问时，可以添加新测试来理解它们。
- en: Types of Tests
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试类型
- en: There are dozens of different test types and testing methodologies. Our goal
    is not to cover the full breadth of this topic but to discuss the most common
    types—unit, integration, system, performance, and acceptance tests—to give you
    a firm foundation to build on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多不同类型的测试和测试方法。我们的目标不是涵盖该主题的所有内容，而是讨论最常见的几种类型——单元测试、集成测试、系统测试、性能测试和验收测试——以为你打下坚实的基础。
- en: '*Unit tests* verify “units” of code—a single method or behavior. Unit tests
    should be fast, small, and focused. Speed is important because these tests run
    frequently—often on developer laptops. Small tests that focus on a single unit
    of code make it easier to understand what has broken when a test fails.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试*验证“单元”代码——一个单独的方法或行为。单元测试应该快速、小巧且聚焦。速度很重要，因为这些测试运行频繁——通常在开发者的笔记本电脑上运行。小型的测试专注于单一的代码单元，当测试失败时，能够更容易理解是什么导致了问题。'
- en: '*Integration tests* verify that multiple components work together. If you find
    yourself instantiating multiple objects that interact with each other in a test,
    you’re probably writing an integration test. Integration tests are often slower
    to execute and require a more elaborate setup than unit tests. Developers run
    integration tests less frequently, so the feedback loop is longer. These tests
    can flush out problems that are difficult to identify by testing standalone units
    individually.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*集成测试*验证多个组件是否协同工作。如果你发现自己在测试中实例化了多个相互作用的对象，那你可能是在编写集成测试。集成测试通常比单元测试执行得更慢，并且需要比单元测试更复杂的设置。开发者运行集成测试的频率较低，因此反馈周期较长。这些测试能发现一些通过单独测试独立单元难以识别的问题。'
- en: '*System tests* verify a whole system. End-to-end (e2e, for short) workflows
    are run to simulate real user interactions in preproduction environments. Approaches
    to system test automation vary. Some organizations require that system tests pass
    before a release, which means all components are tested and released in lockstep.
    Other organizations ship such large systems that synchronizing releases is not
    realistic; these organizations often run extensive integration tests and supplement
    them with continuous synthetic monitoring production tests. *Synthetic monitoring*
    scripts run in production to simulate user registration, browse for and purchase
    an item, and so on. Synthetic monitoring requires instrumentation that allows
    billing, accounting, and other systems to distinguish these production tests from
    real activity.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统测试*验证整个系统。端到端（e2e，简写）工作流程模拟真实用户在预生产环境中的交互。系统测试自动化的方式各不相同。一些组织要求系统测试在发布之前必须通过，这意味着所有组件都会同步测试和发布。其他组织发布的系统非常庞大，无法实现同步发布；这些组织通常进行广泛的集成测试，并通过持续的合成监控生产测试来补充。*合成监控*脚本在生产环境中运行，模拟用户注册、浏览并购买商品等行为。合成监控需要仪表化，使得计费、会计和其他系统能够区分这些生产测试和真实活动。'
- en: '*Performance tests*, such as load and stress tests, measure system performance
    under different configurations. *Load tests* measure performance under various
    levels of load: for example, how a system performs when 10, 100, or 1,000 users
    access it concurrently. *Stress tests* push system load to the point of failure.
    Stress testing exposes how far a system is capable of going and what happens under
    excessive load. These tests are useful for capacity planning and defining SLOs.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*性能测试*，例如负载测试和压力测试，衡量系统在不同配置下的性能。*负载测试*衡量系统在不同负载级别下的性能：例如，当10、100或1000个用户同时访问系统时，系统的表现如何。*压力测试*将系统负载推至故障点。压力测试揭示了系统能承受的极限以及在过载情况下会发生什么。这些测试对于容量规划和定义SLO（服务水平目标）非常有用。'
- en: '*Acceptance tests* are performed by a customer, or their proxy, to validate
    that the delivered software meets acceptance criteria. These tests are fairly
    common in enterprise software, where formal acceptance tests and criteria are
    laid out as part of an expensive contract. The *International Standards Organization
    (ISO)* requires acceptance tests that validate explicit business requirements
    as part of their security standard; certification auditors will ask for evidence
    of documentation for both the requirements and the corresponding tests. Less formal
    acceptance tests, found in less regulated organizations, are variations on the
    theme of “I just changed a thing; can you let me know if everything still looks
    good?”'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*验收测试*由客户或其代理执行，用于验证交付的软件是否符合验收标准。这些测试在企业软件中相当常见，正式的验收测试和标准是昂贵合同的一部分。*国际标准化组织（ISO）*要求验收测试验证明确的业务需求，作为其安全标准的一部分；认证审计员会要求提供需求和相应测试的文档证明。在不太受监管的组织中，较为不正式的验收测试通常变成了“我刚刚修改了一个功能，你能告诉我一切是否正常吗？”'
- en: Test Tools
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试工具
- en: 'Test tools fall into several categories: test-writing tools, test execution
    frameworks, and code quality tools. *Test-writing tools* like mocking libraries
    help you write clean and efficient tests. *Test frameworks* help run tests by
    modeling a test’s lifecycle from setup to teardown. Test frameworks also save
    test results, integrate with build systems, and provide other helpers. *Code quality
    tools* are used to analyze code coverage and code complexity, find bugs through
    static analysis, and check for style errors. Analysis tools are usually set up
    to run as part of a build or compile step.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工具分为几类：测试编写工具、测试执行框架和代码质量工具。*测试编写工具*（如模拟库）帮助你编写简洁高效的测试。*测试框架*帮助通过模拟测试的生命周期（从设置到清理）来运行测试。测试框架还会保存测试结果，集成构建系统并提供其他辅助工具。*代码质量工具*用于分析代码覆盖率和代码复杂性，通过静态分析发现
    bug，并检查样式错误。分析工具通常会在构建或编译步骤中运行。
- en: Every tool added to your setup comes with baggage. Everyone must understand
    the tool, along with all of its idiosyncrasies. The tool might depend on many
    other libraries, which will further increase the complexity of the system. Some
    tools slow tests down. Therefore, avoid outside tools until you can justify the
    complexity trade-offs, and make sure your team is bought in.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个添加到你的设置中的工具都会带来额外负担。每个人必须理解该工具及其所有特殊性。工具可能依赖于许多其他库，这将进一步增加系统的复杂性。有些工具会减慢测试速度。因此，在你能够证明复杂性权衡的合理性之前，避免使用外部工具，并确保你的团队认可这些工具。
- en: Mocking Libraries
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mock 库
- en: Mocking libraries are commonly used in unit tests, particularly in object-oriented
    code. Code often depends on external systems, libraries, or objects. *Mocks* replace
    external dependencies with stubs that mimic the interface provided by the real
    system. Mocks implement functionality required for the test by responding to inputs
    with hard-coded responses.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Mock 库通常在单元测试中使用，特别是在面向对象的代码中。代码通常依赖于外部系统、库或对象。*Mocks* 用存根替代外部依赖，这些存根模拟了真实系统提供的接口。Mocks
    通过用硬编码的响应来回应输入，执行测试所需的功能。
- en: Eliminating external dependencies keeps unit tests fast and focused. Mocking
    remote systems allows tests to bypass network calls, simplifying the setup and
    avoiding slow operations. Mocking methods and objects allows developers to write
    focused unit tests that exercise just one specific behavior.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 消除外部依赖可以保持单元测试快速且专注。模拟远程系统使测试能够绕过网络调用，从而简化了设置并避免了慢操作。模拟方法和对象使开发人员能够编写专注的单元测试，测试单一特定的行为。
- en: Mocks also keep application code from becoming riddled with test-specific methods,
    parameters, or variables. Test-specific changes are difficult to maintain, make
    code hard to read, and cause confusing bugs (don’t add Boolean `isTest` parameters
    to your methods!). Mocks help developers access protected methods and variables
    without modifying regular code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Mocks 还可以防止应用程序代码中充斥着与测试相关的方法、参数或变量。与测试相关的更改很难维护，使代码难以阅读，并可能导致混乱的 bug（不要在方法中添加布尔型的
    `isTest` 参数！）。Mocks 帮助开发人员在不修改常规代码的情况下访问受保护的方法和变量。
- en: While mocking is useful, don’t overdo it. Mocks with complex internal logic
    make your tests brittle and hard to understand. Start with basic inline mocks
    inside a unit test, and don’t write a shared mock class until you begin repeating
    mocking logic between tests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模拟很有用，但不要过度使用。具有复杂内部逻辑的 mocks 会使你的测试变得脆弱且难以理解。从单元测试中的基本内联 mocks 开始，只有在测试之间重复模拟逻辑时，才编写共享的模拟类。
- en: An excessive reliance on mocks is a code smell that suggests tight code coupling.
    Whenever reaching for a mock, consider whether code could be refactored to remove
    the dependency on the mocked system. Separating computation and data transformation
    logic from I/O code helps simplify testing and makes the program less brittle.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 过度依赖 mock 是一种代码异味，表明代码之间紧密耦合。每当使用 mock 时，考虑是否可以重构代码以去除对模拟系统的依赖。将计算和数据转换逻辑与 I/O
    代码分离有助于简化测试，并使程序更加健壮。
- en: Test Frameworks
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试框架
- en: 'Test frameworks help you write and execute tests. You’ll find frameworks that
    help coordinate and execute unit tests, integration tests, performance tests,
    and even UI tests. Frameworks do the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架帮助你编写和执行测试。你会找到帮助协调和执行单元测试、集成测试、性能测试甚至 UI 测试的框架。框架执行以下操作：
- en: Manage test setup and teardown
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理测试的设置和清理
- en: Manage test execution and orchestration
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理测试执行和协调
- en: Generate test result reports
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成测试结果报告
- en: Provide tooling such as extra assertion methods
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供工具，如额外的断言方法
- en: Integrate with code coverage tools
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与代码覆盖工具集成
- en: Setup and teardown methods allow developers to specify steps, such as data structure
    setup or file cleanup, that need to be executed before or after each test or set
    of tests. Many test frameworks give multiple options for setup and teardown execution—before
    each test, before all tests in a file, or before all tests in a build. Read documentation
    before using setup and teardown methods to make sure you’re using them correctly.
    Don’t expect teardown methods to run in all circumstances. For example, teardown
    won’t occur if a test fails catastrophically, causing the whole test process to
    exit.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和拆解方法允许开发人员指定在每个测试或测试集之前或之后需要执行的步骤，例如数据结构设置或文件清理。许多测试框架提供多种设置和拆解执行选项——在每个测试之前、在文件中的所有测试之前，或在构建中的所有测试之前。使用设置和拆解方法之前，请阅读文档以确保正确使用它们。不要指望在所有情况下都能运行拆解方法。例如，如果测试发生灾难性失败，导致整个测试过程退出，则不会执行拆解。
- en: Test frameworks help control the speed and isolation of tests through test orchestration.
    Tests can be executed serially or in parallel. Serial tests are run one after
    the next. Running one test at a time is safer because tests have less chance of
    impacting one another. Parallel execution is faster but more error prone due to
    shared state, resource, or other contamination.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架帮助通过测试编排控制测试的速度和隔离性。测试可以串行或并行执行。串行测试一个接一个地运行。一次运行一个测试更安全，因为测试之间相互影响的可能性较小。并行执行速度更快，但由于共享状态、资源或其他污染，更容易出错。
- en: Frameworks can be configured to start a new process between each test. This
    further isolates tests, since each test will start fresh. Beware that starting
    new processes for each test is an expensive operation. See “Determinism in Tests”
    later in this chapter for more on test isolation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 框架可以配置为在每个测试之间启动一个新进程。这进一步隔离了测试，因为每个测试都会从头开始。注意，为每个测试启动新进程是一个昂贵的操作。有关测试隔离的更多信息，请参见本章后面的“测试中的确定性”部分。
- en: 'Test reports help developers debug failed builds. Reports give a detailed readout
    of which tests passed, failed, or were skipped. When a test fails, reports show
    which assertion failed. Reports also organize logs and stack traces per test so
    developers can quickly debug failures. Beware: it’s not always obvious where test
    results are stored—a summary is printed to the console, while the full report
    is written to disk. Look in test and build directories if you have trouble locating
    a report.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 测试报告帮助开发人员调试构建失败。报告详细列出了哪些测试通过、失败或被跳过。当测试失败时，报告显示哪条断言失败。报告还会根据每个测试整理日志和堆栈跟踪，以便开发人员快速调试失败。注意：测试结果存储位置并不总是显而易见——总结会打印到控制台，而完整的报告会写入磁盘。如果你无法找到报告，可以查看测试和构建目录。
- en: Code Quality Tools
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码质量工具
- en: Take advantage of tools that help you write quality code. Tools that enforce
    code quality rules are called *linters*. Linters run static analysis and perform
    style checks. Code quality monitoring tools report metrics such as complexity
    and test coverage.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 利用帮助你编写高质量代码的工具。强制执行代码质量规则的工具被称为*代码检查器*。代码检查器运行静态分析并执行风格检查。代码质量监控工具报告复杂度、测试覆盖率等度量指标。
- en: '*Static code analyzers* look for common mistakes, like leaving file handles
    open or using unset variables. Static analyzers are particularly important for
    dynamic languages like Python and JavaScript, which do not have a compiler to
    catch syntax errors. Analyzers look for known code smells and highlight questionable
    code but are not immune to false positives, so you should think critically about
    problems reported by static analyzers and override false positives with code annotations
    that tell the analyzer to ignore particular violations.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态代码分析器*寻找常见错误，如未关闭文件句柄或使用未设置的变量。静态分析器对于像Python和JavaScript这样的动态语言尤为重要，因为它们没有编译器来捕获语法错误。分析器会查找已知的代码异味并突出显示可疑代码，但它们并非没有误报，因此你应该批判性地思考静态分析器报告的问题，并通过代码注解覆盖误报，告诉分析器忽略特定的违规行为。'
- en: '*Code style checkers* ensure all source code is formatted the same way: max
    characters per line, camelCasing versus snake_casing, proper indentation, that
    sort of thing. A consistent style helps multiple programmers collaborate on a
    shared codebase. We highly recommend setting up your IDE so that all style rules
    are automatically applied.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码风格检查器*确保所有源代码格式一致：每行的最大字符数、驼峰命名法与蛇形命名法、正确的缩进等等。统一的风格有助于多个程序员在共享代码库中协作。我们强烈建议设置IDE，使所有的风格规则自动应用。'
- en: '*Code complexity* *tools* guard against overly complex logic by calculating
    *cyclomatic complexity*, or, roughly, the number of paths through your code. The
    higher your code’s complexity, the more difficult it is to test, and the more
    defects it is likely to contain. Cyclomatic complexity generally increases with
    the size of the codebase, so a high overall score is not necessarily bad; however,
    a sudden jump in complexity can be cause for concern, as can individual methods
    of high complexity.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码复杂度* *工具* 通过计算*圈复杂度*来防止过于复杂的逻辑，圈复杂度大致是指通过代码的路径数。代码复杂度越高，测试越困难，也越容易包含缺陷。圈复杂度通常随着代码库的大小增加，因此高的总分不一定是坏事；然而，复杂度的突然跃升可能是一个值得关注的问题，单独复杂的函数方法也可能是一个警告。'
- en: '*Code coverage* *tools* measure how many lines of code were exercised by the
    test suite. If your change lowers code coverage, you should write more tests.
    Make sure that tests are exercising any new changes that you’ve made. Aim for
    reasonable coverage (the rule of thumb is between 65 and 85 percent). Remember
    that coverage alone isn’t a good measure of test quality: it can be quite misleading,
    both when it is high and when it is low. Checking automatically generated code
    like scaffolding or serialization classes can create misleadingly low coverage
    metrics. Conversely, obsessively creating unit tests to get to 100 percent coverage
    doesn’t guarantee that your code will integrate safely.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码覆盖率* *工具* 测量测试套件执行了多少行代码。如果你的修改降低了代码覆盖率，你应该编写更多的测试。确保测试涵盖了你所做的任何新修改。目标是合理的覆盖率（经验法则是介于65%到85%之间）。记住，覆盖率本身并不是衡量测试质量的好标准：它可能会产生误导，无论是覆盖率高还是低。自动生成的代码，如框架代码或序列化类，可能会导致误导性低覆盖率指标。相反，过于追求100%的覆盖率并不保证你的代码能够安全地集成。'
- en: Engineers have a tendency to fixate on code quality metrics. Just because a
    tool finds a quality issue doesn’t mean that it’s actually a problem, nor does
    it mean that it’s worth fixing immediately. Be pragmatic with codebases that fail
    quality checks. Don’t let code get worse, but avoid disruptive stop-the-world
    cleanup projects. Use Chapter 3’s “Technical Debt” section as a guide to determine
    when to fix code quality issues.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师们常常过于关注代码质量指标。仅仅因为某个工具发现了质量问题，并不意味着它真的是一个问题，也不代表它值得立刻修复。在处理未通过质量检查的代码库时要务实。不要让代码变得更差，但避免进行破坏性的“停止一切清理”项目。使用第三章中的“技术债务”部分作为指南，决定何时修复代码质量问题。
- en: Writing Your Own Tests
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写你自己的测试
- en: 'You are responsible for making sure your team’s code works as expected. Write
    your own tests; don’t expect others to clean up after you. Many companies have
    formal *quality assurance (QA)* teams with varying responsibilities, including
    the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你有责任确保你团队的代码按预期工作。编写自己的测试；不要指望别人来为你清理。许多公司都有正式的*质量保证（QA）*团队，职责各异，包括以下内容：
- en: Writing black-box or white-box tests
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写黑盒或白盒测试
- en: Writing performance tests
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写性能测试
- en: Performing integration, user acceptance, or system tests
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行集成、用户接受或系统测试
- en: Providing and maintaining test tools
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供和维护测试工具
- en: Maintaining test environments and infrastructure
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护测试环境和基础设施
- en: Defining formal test certification and release processes
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义正式的测试认证和发布流程
- en: QA teams can help you verify your code is stable, but never “throw code over
    the fence” to have them do all of the testing. QA teams don’t write unit tests
    anymore; those days are long gone. If you are in a company with a formal QA team,
    find out what they are responsible for and how to engage with them. If they’re
    embedded within your team, they are likely attending scrum and sprint planning
    meetings (see Chapter 12 for more on Agile development). If they’re a centralized
    organization, getting their help might require opening tickets or submitting some
    formal request.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: QA团队可以帮助你验证代码是否稳定，但永远不要把所有测试都交给他们来做，不能“把代码丢过去”让他们处理所有测试。QA团队现在不再编写单元测试了；那些日子已经过去。如果你所在的公司有正式的QA团队，了解他们的责任以及如何与他们合作是很重要的。如果他们在你的团队中，可能会参与到scrum和冲刺计划会议中（有关敏捷开发的更多信息，请参见第12章）。如果他们是一个集中式的组织，可能需要通过提交工单或正式请求来获得他们的帮助。
- en: Write Clean Tests
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写清晰的测试
- en: Write tests with the same care that you write other code. Tests introduce dependencies,
    require maintenance, and need to be refactored over time. Hacky tests have a high
    maintenance cost, which slows down future development. Hacky tests are also less
    stable and less likely to provide reliable results.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以与编写其他代码相同的细心程度编写测试。测试引入了依赖关系，需要维护，并且随着时间的推移需要重构。粗糙的测试有很高的维护成本，会减慢未来的开发速度。粗糙的测试也更不稳定，不太可能提供可靠的结果。
- en: Use good programming practices on tests. Document how tests work, how they can
    be run, and why they were written. Avoid hard-coded values, and don’t duplicate
    code. Use design best practices to maintain a separation of concerns and to keep
    tests cohesive and decoupled.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中使用良好的编程实践。记录测试的工作原理、如何运行以及为什么编写它们。避免硬编码的值，避免代码重复。使用设计最佳实践来保持关注点分离，并保持测试的凝聚性和解耦性。
- en: Focus on testing fundamental functionality rather than implementation details.
    This helps when the codebase gets refactored, since tests will still run after
    the refactoring. If your test code is too tightly coupled with implementation
    particulars, changes to the main body of code will break tests. These breakages
    stop meaning something broke, and just signal that the code changed. This does
    not provide value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 集中测试基本功能而非实现细节。这有助于代码库重构时，测试依然能正常运行。如果测试代码与实现细节过于紧密耦合，主代码体的更改将破坏测试。这种破坏不再意味着出现了问题，只是表明代码发生了变化。这样做没有任何价值。
- en: Keep test dependencies separate from your regular code dependencies. If a test
    requires a library to run, don’t force the entire codebase to depend on the library.
    Most build and packaging systems will allow you to define dependencies specifically
    for tests; take advantage of this feature.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试依赖与常规代码依赖分开。如果测试需要某个库才能运行，不要强迫整个代码库都依赖这个库。大多数构建和打包系统允许你为测试定义特定的依赖关系；应充分利用这一特性。
- en: Don’t Overdo Testing
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要过度测试
- en: Don’t get swept up writing tests. It’s easy to lose track of which tests are
    worth writing. Write tests that fail meaningfully. Avoid chasing higher code coverage
    just to boost coverage metrics. Testing thin database wrappers, third-party libraries,
    or basic variable assignments is worthless even if it boosts coverage metrics.
    Focus on tests that have the largest effect on code risk.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被编写测试所淹没。很容易失去对哪些测试值得编写的判断。编写有意义的失败测试。避免仅仅为了提高覆盖率指标而追求更高的代码覆盖率。即使提高了覆盖率指标，测试薄数据库包装器、第三方库或基本变量赋值也毫无意义。应专注于对代码风险影响最大的测试。
- en: A failing test should tell the developer that something important has changed
    about the behavior of the program. Tests that fail when trivial changes are made,
    or when one valid implementation is replaced with another valid implementation,
    create busywork and desensitize the programmer. One should not need to fix the
    tests when the code is not broken.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个失败的测试应该告诉开发者，程序的行为发生了重要变化。当做出微小更改，或者将一种有效的实现替换为另一种有效实现时，导致测试失败会增加不必要的工作量，并且使程序员麻木。代码没有坏时，不应该需要修复测试。
- en: Use code coverage as a guide, not a rule. High code coverage does not guarantee
    correctness. Exercising code in a test counts toward coverage, but it doesn’t
    mean that it was exercised usefully. It’s entirely possible for critical errors
    to exist in codebases with 100 percent test coverage. Chasing a specific code
    coverage percentage is myopic.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码覆盖率作为指导，而不是规则。高代码覆盖率并不能保证正确性。在测试中执行代码会计入覆盖率，但这并不意味着它被有效地执行。即便是100%测试覆盖率的代码库，也完全有可能存在严重的错误。追求特定的代码覆盖率百分比是短视的。
- en: Don’t handcraft tests for autogenerated code such as web framework scaffolding
    or OpenAPI clients. If your coverage tools aren’t configured to ignore generated
    code, the tools will report the code as untested. Fix the coverage tool configuration
    in such cases. Code generators are thoroughly tested, so testing generated code
    is a waste of time (unless you manually introduce changes to generated files,
    in which case you should test them). If for some reason you discover a real need
    to test generated code, figure out a way to add tests to the generator.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不要为自动生成的代码（例如 web 框架脚手架或 OpenAPI 客户端）手动编写测试。如果你的覆盖率工具没有配置为忽略生成的代码，这些工具会报告该代码未经过测试。在这种情况下，修复覆盖工具的配置。代码生成器经过充分测试，因此测试生成的代码是浪费时间的（除非你手动对生成的文件进行了更改，在这种情况下应测试这些更改）。如果因某种原因你发现需要测试生成的代码，想办法将测试添加到生成器中。
- en: Focus effort on the highest value tests. Tests take time to write and maintain.
    Focusing on high-value tests yields the most benefit for the cost. Use a risk
    matrix to find areas to focus on. A *risk matrix* defines risk as the likelihood
    and impact of a failure.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将精力集中在高价值的测试上。编写和维护测试需要时间。专注于高价值的测试可以在成本效益比上获得最大的收益。使用风险矩阵来找出需要关注的重点区域。*风险矩阵*定义了失败的可能性和影响。
- en: '[Figure 6-1](#figure6-1) is a sample risk matrix. The likelihood of a failure
    is measured on the y-axis, and the impact of the failure is measured on the x-axis.
    The intersection of the event’s likelihood and impact defines its risk.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-1](#figure6-1)是一个示例风险矩阵。失败的可能性在纵轴上测量，失败的影响在横轴上测量。事件的可能性和影响的交点定义了其风险。'
- en: '![f06001](image_fi/501836c06/f06001.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![f06001](image_fi/501836c06/f06001.png)'
- en: 'Figure 6-1: Risk matrix'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1：风险矩阵
- en: Tests shift code risk down the chart—more testing makes failures less likely.
    Focus on high-likelihood, high-impact areas of the code first. Low-risk or throwaway
    code, like a proof of concept, isn’t worth testing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将代码风险降低到图表的下方——更多的测试使失败变得不太可能。首先，专注于代码中可能性高、影响大的部分。低风险或一次性的代码，比如概念验证代码，不值得进行测试。
- en: Determinism in Tests
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试中的确定性
- en: '*Deterministic code* always produces the same output for the same input. By
    contrast, *nondeterministic code* can return different results for the same inputs.
    A unit test that invokes a call to a remote web service on a network socket is
    nondeterministic; if the network fails, the test will fail. Nondeterministic tests
    are a problem that plague many projects. It’s important to understand why nondeterministic
    tests are bad, how to fix them, and how to avoid writing them.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*确定性代码*对于相同的输入始终产生相同的输出。相比之下，*非确定性代码*对于相同的输入可能返回不同的结果。一个调用网络套接字上的远程Web服务的单元测试是非确定性的；如果网络失败，测试就会失败。非确定性测试是许多项目中的一个问题。了解为什么非确定性测试是有害的，如何修复它们，以及如何避免编写它们，至关重要。'
- en: Nondeterministic tests degrade test value. Intermittent test failures (known
    as *flapping tests*) are hard to reproduce and debug because they don’t happen
    every run, or even every tenth run. You don’t know whether the problem is with
    the test or with your code. Because flapping tests don’t provide meaningful information,
    developers might ignore them and check in broken code as a result.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 非确定性测试会降低测试价值。间歇性的测试失败（称为*波动测试*）难以重现和调试，因为它们并不是每次运行时都会发生，甚至不是每十次运行中都会发生。你无法判断问题是出在测试本身还是代码上。由于波动测试没有提供有意义的信息，开发人员可能会忽略它们，从而提交有问题的代码。
- en: Intermittently failing tests should be disabled or fixed immediately. Run a
    flapping test repeatedly in a loop to reproduce the failure. IDEs have features
    to run tests iteratively, but a loop in a shell also works. Sometimes the nondeterminism
    is caused by interactions between tests or specific machine configurations—you’ll
    have to experiment. Once you’ve reproduced the failure, you can fix it by eliminating
    the nondeterminism or fixing the bug.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 间歇性失败的测试应该立即禁用或修复。在循环中反复运行波动测试以重现失败。集成开发环境（IDE）有功能可以迭代运行测试，但命令行中的循环也能实现。有时候，非确定性是由于测试之间的相互作用或特定机器配置引起的——你需要进行实验。一旦你重现了失败，就可以通过消除非确定性或修复漏洞来解决问题。
- en: Nondeterminism is often introduced by improper handling of sleep, timeouts,
    and random number generation. Tests that leave side effects or interact with remote
    systems also cause nondeterminism. Escape nondeterminism by making time and randomness
    deterministic, cleaning up after tests, and avoiding network calls.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 非确定性通常是由于不当处理睡眠、超时和随机数生成引入的。留下副作用或与远程系统交互的测试也会导致非确定性。通过使时间和随机性变得确定性、清理测试后的环境以及避免网络调用，可以摆脱非确定性。
- en: Seed Random Number Generators
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为随机数生成器提供种子
- en: '*Random number generators* *(RNGs**)* must be seeded with a value that dictates
    the random numbers you get from it. By default, random number generators will
    use the system clock as a seed. System clocks change over time, so two runs of
    a test with a random number generator will yield different results—nondeterminism.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*随机数生成器*（*RNGs*）必须用一个值来进行初始化，该值决定了你从中获得的随机数。默认情况下，随机数生成器会使用系统时钟作为种子。系统时钟会随着时间变化，因此两次运行带有随机数生成器的测试将产生不同的结果——即非确定性。'
- en: Seed random number generators with a constant to force them to deterministically
    generate the same sequence every time they run. Tests with constantly seeded generators
    will always pass or always fail.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为随机数生成器提供一个常量种子，以强制它们每次运行时生成相同的序列。使用常量种子生成器的测试将始终通过或始终失败。
- en: Don’t Call Remote Systems in Unit Tests
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要在单元测试中调用远程系统
- en: Remote system calls require network hops, which are unstable. Network calls
    can time out, which introduces nondeterminism into unit tests. A test might pass
    hundreds of times and then fail once due to network timeout. Remote systems are
    also unreliable; they can be shut off, restarted, or frozen. If a remote system
    is degraded, your test will fail.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 远程系统调用需要网络跳转，这些跳转是不稳定的。网络调用可能会超时，这会给单元测试引入非确定性。一个测试可能通过几百次，然后因为网络超时失败一次。远程系统也不可靠，它们可能被关闭、重启或冻结。如果远程系统出现故障，你的测试将失败。
- en: Avoiding remote calls (which are slow) also keeps unit tests fast and portable.
    Speed and portability are critical for unit tests since developers run them frequently
    and locally on development machines. Unit tests that depend on remote systems
    aren’t portable because a host machine running a test must have access to the
    remote system, and remote test systems are often in internal integration test
    environments that aren’t easily reachable.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 避免远程调用（因为它们很慢）还可以保持单元测试快速且便携。速度和便携性对单元测试至关重要，因为开发人员频繁地在本地开发机器上运行它们。依赖远程系统的单元测试不可移植，因为运行测试的主机必须能够访问远程系统，而远程测试系统通常位于不容易访问的内部集成测试环境中。
- en: You can eliminate remote system calls in unit tests by using mocks or by refactoring
    code so remote systems are only required for integration tests.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用模拟对象，或者通过重构代码使得远程系统仅在集成测试中被使用，你可以消除单元测试中的远程系统调用。
- en: Inject Clocks
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入时钟
- en: Code that depends on specific intervals of time can cause nondeterminism if
    not handled correctly. External factors like network latency and CPU speed affect
    how long operations take, and system clocks progress independently. Code that
    waits 500 ms for something to happen is brittle. A test will pass if the code
    runs in 499 ms but fail when it runs in 501 ms. Static system clock methods like
    `now` or `sleep` signal that your code is time dependent. Use injectable clocks
    rather than static time methods so you can control the timing that your code sees
    in a test.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于特定时间间隔的代码，如果处理不当，会引起非确定性。网络延迟和CPU速度等外部因素会影响操作的持续时间，而系统时钟是独立前进的。等待500毫秒才能发生某事的代码是脆弱的。如果代码在499毫秒内运行，测试通过，但在501毫秒内运行时测试失败。像`now`或`sleep`这样的静态系统时钟方法表明你的代码依赖于时间。应使用可注入的时钟，而不是静态时间方法，这样你就可以控制代码在测试中看到的时间。
- en: 'The following `SimpleThrottler` Ruby class illustrates the problem. `SimpleThrottler`
    invokes a `throttle` method when the operation count exceeds a threshold, but
    the clock is not injectable:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`SimpleThrottler` Ruby 类，展示了这个问题。`SimpleThrottler`在操作计数超过阈值时调用`throttle`方法，但时钟不可注入：
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous example, we can’t guarantee that the `maybe_throttle` condition
    will be triggered in a test. Two consecutive operations can take an unbounded
    amount of time to run if the test machine is degraded or the operating system
    decides to schedule the test process unfairly. Without control of the clock, it’s
    impossible to test the throttling logic properly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们不能保证在测试中触发`maybe_throttle`条件。如果测试机器出现故障，或者操作系统决定不公平地调度测试进程，两个连续操作可能需要无限量的时间才能完成。如果没有时钟的控制，就无法正确测试节流逻辑。
- en: Instead, make system clocks injectable. Injectable clocks will let you use mocks
    to precisely control the passage of time in your tests.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，应该让系统时钟可注入。可注入的时钟将允许你使用模拟对象（mock）精确控制测试中的时间流逝。
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This approach, called *dependency injection*, allows tests to override clock
    behavior by injecting a mock into the clock parameter. The mock can return integers
    that trigger `maybe_throttle`. Regular code can default to the regular system
    clock.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法叫做*依赖注入*，它通过将模拟对象注入时钟参数，允许测试覆盖时钟行为。模拟对象可以返回触发`maybe_throttle`的整数值。常规代码可以默认使用常规的系统时钟。
- en: Avoid Sleeps and Timeouts
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免使用睡眠和超时
- en: Developers often use `sleep()` calls or timeouts when a test requires work in
    a separate thread, process, or machine to complete before the test can validate
    its results. The problem with this technique is that it assumes that the other
    thread of execution will finish in a specific amount of time, which is not something
    you can rely on. If the language virtual machine or interpreter garbage collects,
    or the operating system decides to starve the process executing the test, your
    tests will (sometimes) fail.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试需要在单独的线程、进程或机器上执行工作才能验证结果时，开发人员通常会使用 `sleep()` 调用或超时。这个方法的问题在于，它假设其他执行线程会在特定时间内完成，而这并不是你可以依赖的。如果语言虚拟机或解释器进行了垃圾回收，或者操作系统决定让执行测试的进程“饿死”，你的测试就会（有时）失败。
- en: Sleeping in tests, or setting long timeouts, also slows down your test execution
    and therefore your development and debugging process. If you have a test that
    sleeps for 30 minutes, the fastest your tests will ever execute is 30 minutes.
    If you have a high (or no) timeout, your tests can get stuck.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中使用睡眠，或者设置较长的超时，也会减慢测试执行速度，从而拖慢开发和调试过程。如果你有一个测试需要睡眠 30 分钟，那么测试的最快执行时间也就是
    30 分钟。如果你的超时设置很高（或没有超时），测试可能会卡住。
- en: If you find yourself tempted to sleep or set a timeout in a test, see if you
    can restructure the test so that everything will execute deterministically. If
    not, that’s okay, but make an honest effort. Determinism isn’t always possible
    when testing concurrent or asynchronous code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己在测试中很想使用睡眠或设置超时，看看能否重构测试，使其所有操作都能按确定的顺序执行。如果不行，也没关系，但请尽力而为。在测试并发或异步代码时，确定性并不总是可能的。
- en: Close Network Sockets and File Handles
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭网络套接字和文件句柄
- en: Many tests leak operating system resources because developers assume that tests
    are short lived and that the operating system will clean everything when the test
    terminates. However, test execution frameworks often use the same process for
    multiple tests, which means leaked system resources like network sockets or file
    handles won’t be immediately cleaned.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 很多测试会泄漏操作系统资源，因为开发人员假设测试的生命周期很短，操作系统会在测试结束时清理所有内容。然而，测试执行框架通常会使用相同的进程执行多个测试，这意味着像网络套接字或文件句柄这样的泄漏的系统资源不会被立即清理。
- en: Leaked resources cause nondeterminism. Operating systems have a cap on the number
    of sockets and file handles and will begin rejecting new requests when too many
    resources are leaked. A test that is unable to open new sockets or file handles
    will fail. Leaked network sockets also break tests that use the same port. Even
    if tests are run serially, the second will fail to bind to the port since it was
    opened but not closed previously.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 泄漏的资源会导致非确定性。操作系统对套接字和文件句柄的数量有限制，当资源泄漏过多时，它会开始拒绝新的请求。无法打开新套接字或文件句柄的测试会失败。泄漏的网络套接字也会破坏使用相同端口的测试。即使测试是串行运行的，第二个测试也会因为端口被打开但没有关闭而无法绑定。
- en: Use standard resource management techniques for narrowly scoped resources, like
    try-with-resource or with blocks. Resources that are shared among tests should
    be closed using setup and teardown methods.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于范围较小的资源，使用标准的资源管理技术，如 try-with-resource 或 with 块。对于在多个测试中共享的资源，应通过设置和拆卸方法关闭。
- en: Bind to Port Zero
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定到端口零
- en: 'Tests should not bind to a specific network port. Static port binding causes
    nondeterminism: a test that runs fine on one machine will fail on another if the
    port is already taken. Binding all tests to the same port is a common practice;
    these tests will run fine serially but fail when run in parallel. Test failures
    will be nondeterministic since the ordering of test execution isn’t always the
    same.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不应该绑定到特定的网络端口。静态端口绑定会导致非确定性：一个在某台机器上运行良好的测试，在另一台机器上会失败，如果端口已经被占用。将所有测试绑定到相同端口是一种常见做法；这些测试串行运行时没有问题，但并行运行时会失败。测试失败是非确定性的，因为测试执行的顺序并不总是相同的。
- en: Instead, bind network sockets to port zero, which makes the operating system
    automatically pick an open port. Tests can retrieve the port that was picked and
    use that value through the remainder of the test.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，可以将网络套接字绑定到端口零，这样操作系统会自动选择一个空闲端口。测试可以获取选择的端口并在测试的其余部分使用该端口。
- en: Generate Unique File and Database Paths
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成唯一的文件和数据库路径
- en: Tests should not write to statically defined locations. Data persistence has
    the same problem as network port binding. Constant filepaths and database locations
    cause tests to interfere with each other.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不应写入静态定义的位置。数据持久化和网络端口绑定有相同的问题。常量的文件路径和数据库位置会导致测试相互干扰。
- en: Dynamically generate unique filenames, directory paths, and database or table
    names. Dynamic IDs let tests run in parallel since they will all read and write
    to a separate location. Many languages provide utility libraries to generate temporary
    directories safely (like `tempfile` in Python). Appending UUIDs to file paths
    or database locations also works.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 动态生成唯一的文件名、目录路径和数据库或表名。动态ID使得测试能够并行运行，因为它们会读取和写入不同的位置。许多编程语言提供了生成临时目录的工具库（例如Python中的`tempfile`）。将UUID附加到文件路径或数据库位置也是可行的。
- en: Isolate and Clean Up Leftover Test State
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隔离并清理剩余的测试状态
- en: Tests that don’t clean up state cause nondeterminism. State exists anywhere
    that data persists, usually in memory or on disk. Global variables like counters
    are common in-memory state, while databases and files are common disk state. A
    test that inserts a database record and asserts that one row exists will fail
    if another test has written to the same table. The same test will pass when run
    alone on a clean database. Leftover state also fills disk space, which destabilizes
    the test environment.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 不清理状态的测试会导致非确定性。状态存在于任何数据持久化的地方，通常是在内存或磁盘上。像计数器这样的全局变量是常见的内存状态，而数据库和文件是常见的磁盘状态。如果一个测试插入了一个数据库记录并断言某行存在，而另一个测试也向同一表写入数据，测试将失败。该测试在干净的数据库上单独运行时会通过。剩余的状态还会占用磁盘空间，进而使测试环境不稳定。
- en: Integration test environments are complex to set up, so they are often shared.
    Many tests run in parallel, reading and writing to the same datastores. Be careful
    in such environments, as sharing resources leads to unexpected test behavior.
    Tests can affect each other’s performance and stability. Shared datastores can
    cause tests to interfere with each other’s data. Follow our guidance in the earlier
    “Generate Unique File and Database Paths” section to avoid collisions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试环境复杂且难以设置，因此通常是共享的。许多测试并行运行，读取和写入相同的数据存储。在这种环境中要小心，因为资源共享会导致意外的测试行为。测试可能会影响彼此的性能和稳定性。共享的数据存储可能会导致测试互相干扰数据。请遵循之前“生成唯一文件和数据库路径”部分的指导，避免冲突。
- en: You must reset state whether your tests pass or not; don’t let failed tests
    leave debris behind. Use setup and teardown methods to delete test files, clean
    databases, and reset in-memory test state between each execution. Rebuild environments
    between test suite runs to rid test machines of leftover state. Tools like containers
    or machine virtualization make it easy to throw away entire machines and start
    new ones; however, discarding and starting new virtual machines is slower than
    running setup and teardown methods, so such tools are best used on large groups
    of tests.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 无论测试是否通过，都必须重置状态；不要让失败的测试留下垃圾数据。使用设置和拆卸方法删除测试文件、清理数据库，并在每次执行之间重置内存中的测试状态。在测试套件运行之间重建环境，清除测试机器上的剩余状态。像容器或虚拟化技术这样的工具可以轻松地丢弃整个机器并重新启动；然而，丢弃并启动新的虚拟机比运行设置和拆卸方法要慢，因此这些工具最适用于大量测试。
- en: Don’t Depend on Test Order
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要依赖测试顺序
- en: 'Tests should not depend on a specific order of execution. Ordering dependencies
    usually happen when a test writes data and a subsequent test assumes the data
    is written. This pattern is bad for many reasons:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不应依赖于特定的执行顺序。顺序依赖通常发生在一个测试写入数据，随后的测试假设数据已写入。这种模式有许多问题：
- en: If the first test breaks, the second will break, too.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个测试失败，第二个也会失败。
- en: It’s harder to parallelize the tests, since you can’t run the second test until
    the first is done.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的并行化更困难，因为在第一个测试完成之前无法运行第二个测试。
- en: Changes to the first test might accidentally break the second.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个测试的更改可能会意外地破坏第二个测试。
- en: Changes to the test runner might cause your tests to run in a different order.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对测试运行器的更改可能会导致测试顺序不同。
- en: Use setup and teardown methods to share logic between tests. Provision data
    for each test in the setup method, and clean up the data in the teardown. Resetting
    state between each run will keep tests from breaking each other when they mutate
    the state.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设置（setup）和拆卸（teardown）方法在测试之间共享逻辑。在设置方法中为每个测试提供数据，在拆卸方法中清理数据。每次运行之间重置状态将防止测试互相破坏，尤其是当它们改变状态时。
- en: Do’s and Don’ts
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注意事项
- en: '| **Do’s** | **Don’ts** |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **注意事项** | **禁忌事项** |'
- en: '| --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **DO** use tests to reproduce bugs.  | **DON’T** ignore the cost of adding
    new testing tools.  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **应该**使用测试来重现bug。  | **不应该**忽视增加新测试工具的成本。 |'
- en: '| **DO** use mocking tools to help write unit tests.  | **DON’T** depend on
    others to write tests for you.  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **应该**使用模拟工具来帮助编写单元测试。  | **不应该**依赖他人为你编写测试。 |'
- en: '| **DO** use code quality tools to verify coverage, formatting, and complexity.  |
    **DON’T** write tests just to boost code coverage.  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **应该**使用代码质量工具来验证覆盖率、格式和复杂度。  | **不应该**为了提高代码覆盖率而编写测试。 |'
- en: '| **DO** seed random number generators in tests.  | **DON’T** depend solely
    on code coverage as a measure of quality.  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **应该**在测试中为随机数生成器设置种子。  | **不应该**仅依赖代码覆盖率作为质量的衡量标准。 |'
- en: '| **DO** close network sockets and file handles in tests.  | **DON’T** use
    avoidable sleeps and timeouts in tests.  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **应该**在测试中关闭网络套接字和文件句柄。  | **不应该**在测试中使用可避免的睡眠和超时。 |'
- en: '| **DO** generate unique filepaths and database IDs in tests.  | **DON’T**
    call remote systems in unit tests.  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **应该**在测试中生成唯一的文件路径和数据库ID。  | **不应该**在单元测试中调用远程系统。 |'
- en: '| **DO** clean up leftover test state between test executions.  | **DON’T**
    depend on test execution order.  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **应该**在每次测试执行之间清理剩余的测试状态。  | **不应该**依赖于测试执行顺序。 |'
- en: Level Up
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升技能
- en: Many (long) books have been written on software testing. We suggest targeting
    specific test techniques rather than reading exhaustive test textbooks.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有许多（长篇）书籍讨论了软件测试。我们建议专注于具体的测试技术，而不是阅读冗长的测试教材。
- en: '*Unit Testing* by Vladimir Khorikov (Manning Publications, 2020) is the place
    to go if you want more on testing best practices. It covers the philosophy of
    unit testing and common unit test patterns and anti-patterns. Despite its name,
    the book also touches on integration testing.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于测试最佳实践的内容，可以阅读 Vladimir Khorikov 所著的《*Unit Testing*》（Manning Publications,
    2020）。这本书介绍了单元测试的哲学以及常见的单元测试模式和反模式。尽管书名如此，它也涉及到集成测试。
- en: Kent Beck’s *Test-Driven Development* (Addison-Wesley Professional, 2002) covers
    TDD in detail. TDD is a great skill to have. If you find yourself in an organization
    that practices TDD, this book is a must.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Kent Beck 所著的《*Test-Driven Development*》（Addison-Wesley Professional, 2002）详细介绍了TDD。如果你在一个实践TDD的组织中工作，这本书是必读的。
- en: Look at the section on property-based testing in *The Pragmatic Programmer*
    by Andrew Hunt and David Thomas (Addison-Wesley Professional, 1999). We left property-based
    testing on the cutting-room floor, but if you want to expand your capabilities,
    property-based testing is a great technique to learn.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Andrew Hunt 和 David Thomas 所著的《The Pragmatic Programmer》中的关于基于属性的测试的章节（Addison-Wesley
    Professional, 1999）。我们在书中没有详细讨论基于属性的测试，但如果你想扩展自己的能力，基于属性的测试是一个很好的学习技术。
- en: Elisabeth Hendrickson’s *Explore It!* (Pragmatic Bookshelf, 2013) discusses
    exploratory testing to learn about code. If you are dealing with complex code,
    *Explore It!* is a good read.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Elisabeth Hendrickson 所著的《*Explore It!*》（Pragmatic Bookshelf, 2013）讨论了探索性测试，以帮助了解代码。如果你正在处理复杂的代码，*Explore
    It!* 是一本值得一读的书。
