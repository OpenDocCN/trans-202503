- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**ADVANCED MEMORY FORENSICS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级内存取证**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: Whether you hack games as a hobby or a business, you’ll eventually find yourself
    between a rock and . . . an unintelligible memory dump. Be it a race with a rival
    bot developer to release a highly requested feature, a battle against a game company’s
    constant barrage of updates, or a struggle to locate some complex data structure
    in memory, you’ll need top-notch memory forensics skills to prevail.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是将黑客游戏作为爱好还是事业，你最终都会发现自己陷入困境……一大堆难以理解的内存转储中。无论是与竞争对手机器人开发者竞赛发布高度请求的功能、与游戏公司不断更新的战斗，还是在内存中寻找复杂数据结构的努力，你都需要顶级的内存取证技能才能脱颖而出。
- en: Successful bot development is precariously balanced atop speed and skill, and
    tenacious hackers must rise to the challenge by swiftly releasing ingenious features,
    promptly responding to game updates, and readily searching for even the most elusive
    pieces of data. Doing this, however, requires a comprehensive understanding of
    common memory patterns, advanced data structures, and the purpose of different
    pieces of data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的机器人开发是在速度和技巧之间微妙平衡的，顽强的黑客必须迎接挑战，通过迅速发布巧妙的功能、及时响应游戏更新，并积极寻找即使是最难找到的数据。要做到这一点，需要对常见的内存模式、高级数据结构以及不同数据片段的用途有全面的理解。
- en: Those three aspects of memory forensics are perhaps the most effective weapons
    in your arsenal, and this chapter will teach you how to use them. First, I’ll
    discuss advanced memory-scanning techniques that focus on searching for data by
    understanding its purpose and usage. Next, I’ll teach you how to use memory patterns
    to tackle game updates and tweak your bots without having to relocate all of your
    addresses from scratch. To wrap up, I’ll dissect the four most common complex
    data structures in the C++ standard library (`std::string`, `std::vector`, `std::list`,
    and `std::map`) so you can recognize them in memory and enumerate their contents.
    By the end of the chapter, my hope is that you’ll have a deep understanding of
    memory forensics and be able to take on any challenge related to memory scanning.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种内存取证的技术也许是你武器库中最有效的武器，本章将教你如何使用它们。首先，我将讨论高级内存扫描技术，重点是通过理解数据的目的和使用方式来搜索数据。接下来，我将教你如何使用内存模式应对游戏更新，并在不必重新定位所有地址的情况下调整你的机器人。最后，我将剖析C++标准库中最常见的四种复杂数据结构（`std::string`、`std::vector`、`std::list`和`std::map`），帮助你在内存中识别它们并枚举它们的内容。到本章结束时，我希望你能够深刻理解内存取证，并能够应对任何与内存扫描相关的挑战。
- en: '**Advanced Memory Scanning**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**高级内存扫描**'
- en: Within a game’s source code, each piece of data has a cold, calculated definition.
    When the game is being played, however, all of that data comes together to create
    something new. Players only experience the beautiful scenery, visceral sounds,
    and intense adventures; the data that drives these experiences is irrelevant.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏的源代码中，每一段数据都有一个冷静、计算过的定义。然而，当游戏正在进行时，所有这些数据会汇聚在一起，创造出新的东西。玩家只体验到美丽的景色、真实的声音和紧张的冒险；驱动这些体验的数据是无关紧要的。
- en: 'With that in mind, imagine Hacker A has just started tearing into his favorite
    game, wanting to automate some of the boring bits with a bot. He doesn’t have
    a complete understanding of memory yet, and to him, the data is nothing but assumptions.
    He thinks, “I have 500 health, so I can find the health address by telling Cheat
    Engine to look for a 4-byte integer with a value of 500.” Hacker A has an accurate
    understanding of data: it’s just information (values) stored at particular locations
    (addresses) using defined structures (types).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有鉴于此，假设黑客A刚刚开始入侵他最喜欢的游戏，想用机器人来自动化一些无聊的环节。他还没有完全理解内存，对于他来说，这些数据不过是一些假设。他想：“我有500点生命值，所以我可以让作弊引擎查找一个值为500的4字节整数来找到生命值地址。”黑客A对数据有着准确的理解：它只是在特定位置（地址）存储的以定义结构（类型）表示的信息（值）。
- en: 'Now imagine Hacker B, who already understands the game both inside and out;
    she knows how playing the game alters its state in memory, and the data no longer
    has any secrets. She knows that every defined property of the data can be determined
    given its purpose. Unlike Hacker A, Hacker B has an understanding of data that
    transcends the confines of a single variable declaration: she considers the data’s
    *purpose* and *usage*. In this section, we’ll discuss both.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下黑客B，她已经完全理解了这款游戏；她知道玩游戏如何改变游戏内存中的状态，这些数据不再有什么秘密。她知道数据的每个定义属性都可以根据其目的来确定。与黑客A不同，黑客B对数据的理解超越了单一变量声明的局限：她考虑的是数据的*目的*和*使用*。在本节中，我们将讨论这两者。
- en: Each piece of data in a game has a purpose, and the assembly code of the game
    must, at some point, reference the data to fulfill that purpose. Finding the unique
    code that uses a piece of data means finding a version-agnostic marker that persists
    across game updates until the data is either removed or its purpose is changed.
    Let me show you why this is important.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的每一条数据都有一个目的，游戏的汇编代码在某个时刻必须引用这些数据来实现这个目的。找到使用某条数据的唯一代码意味着找到一个版本无关的标记，这个标记会在游戏更新时持续存在，直到数据被删除或其目的发生变化。让我来告诉你为什么这很重要。
- en: '***Deducing Purpose***'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***推测目的***'
- en: So far, I’ve only shown you how to blindly search memory for a given piece of
    data without considering how it’s being used. This method can be effective, but
    it is not always efficient. In many cases, it’s much quicker to deduce the purpose
    of data, determine what code might use that data, and then locate that code to
    ultimately find the address of the data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我只向你展示了如何盲目地搜索内存中的某条数据，而没有考虑它是如何被使用的。这种方法可能有效，但并不总是高效。在许多情况下，推测数据的目的、确定哪些代码可能使用该数据，然后定位这些代码以最终找到数据的地址，往往更快捷。
- en: This might not sound easy, but neither does “scan the game’s memory for a specific
    value of a specific data type, and then continuously filter the result list based
    on changing criteria,” which is what you’ve learned to do thus far. So let’s look
    at how we might locate the address for health given its purpose. Consider the
    code in [Listing 5-1](ch05.xhtml#ch5exe1).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能不容易，但“扫描游戏内存以查找特定数据类型的特定值，然后根据不断变化的标准持续筛选结果列表”也并不容易，这正是你到目前为止学会做的事。所以让我们来看看如何根据其目的定位健康值的地址。参考[列表
    5-1](ch05.xhtml#ch5exe1)中的代码。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 5-1: A structure containing the player’s vitals, and a function that
    displays them*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-1：一个包含玩家生命体征的结构体，以及一个显示它们的函数*'
- en: 'If you pretend that `printString()` is a fancy function to draw text on an
    in-game interface, then this code is pretty close to what you might find in a
    game. The `PlayerVital` structure has two properties: the `current` value and
    a `maximum` value. The value `health` is a `PlayerVital` structure, so it has
    these properties, too. Based on the name alone, you can deduce that `health` exists
    to display information about the player’s health, and you can see this purpose
    fulfilled when `printString()` uses the data.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你假装`printString()`是一个在游戏界面上绘制文本的高级函数，那么这段代码非常接近你在游戏中可能会找到的内容。`PlayerVital`结构体有两个属性：`current`值和`maximum`值。`health`值是一个`PlayerVital`结构体，所以它也有这些属性。单凭名称，你就可以推测`health`是用来显示玩家健康信息的，当`printString()`使用这些数据时，你可以看到这个目的被实现了。
- en: Even without the code, you can intuitively draw similar conclusions by just
    looking at the health text displayed in the game’s interface; a computer can’t
    do anything without code, after all. Aside from the actual `health` variable,
    there are a few code elements that need to exist to show a player this text. First,
    there needs to be some function to display text. Second, the strings `Health`
    and `of` must be nearby.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有代码，你也可以通过查看游戏界面上显示的健康文本直观地得出类似的结论；毕竟，没有代码，计算机什么也做不了。除了实际的`health`变量外，还有一些代码元素需要存在才能向玩家显示这些文本。首先，需要有一个函数来显示文本。其次，字符串`Health`和`of`必须在附近。
- en: '**NOTE**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Why do I assume the text is split into two separate strings instead of one?
    The game interface shows that the current health value is between these two strings,
    but there are many ways that could happen, including format strings,* `strcat(`)*,
    or text aligned with multiple display text calls. When you’re analyzing data,
    it’s best to keep your assumptions broad to account for all possibilities.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么我假设文本被拆分成两个独立的字符串，而不是一个？游戏界面显示当前的健康值位于这两个字符串之间，但有很多方式可能导致这种情况，包括格式化字符串，*
    `strcat(`)*，或者多个显示文本调用对齐的文本。在分析数据时，最好保持假设的广泛性，以考虑所有可能性。*'
- en: To find `health` without using a memory scanner, we could utilize these two
    distinct strings. We probably wouldn’t have a clue what the function to display
    text looks like, where it is, or how many times it’s called, though. Realistically,
    the strings are all we would know to look for, and that’s enough. Let’s walk through
    it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不使用内存扫描器的情况下查找`health`，我们可以利用这两个独立的字符串。不过，我们可能无法知道显示文本的函数是什么样子、它在哪里或被调用了多少次。实际上，字符串就是我们唯一需要寻找的线索，这就足够了。让我们逐步分析。
- en: '***Finding the Player’s Health with OllyDbg***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用OllyDbg查找玩家的健康状态***'
- en: I’ll walk you through how to track down the `health` structure in this section,
    but I’ve also included the binary I analyze in the book’s resource files. To follow
    along and get some hands-on practice, use the file *Chapter5_AdvancedMemoryForensics_Scanning.exe*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将引导你如何追踪`health`结构，但我也在书籍的资源文件中包含了我分析的二进制文件。为了跟随学习并获得一些实际操作经验，使用文件*Chapter5_AdvancedMemoryForensics_Scanning.exe*。
- en: First, open OllyDbg and attach it to the executable. Then, open OllyDbg’s Executable
    modules window and double-click the main module; in my example, the main module
    is the only *.exe* in the module’s window. The CPU window should pop up. Now,
    right-click in the Disassembler pane and select **Search for** ▸ **All referenced
    text strings**. This should open the References window, shown in [Figure 5-1](ch05.xhtml#ch5fig1).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开OllyDbg并将其附加到可执行文件。然后，打开OllyDbg的可执行模块窗口，并双击主模块；在我的示例中，主模块是模块窗口中唯一的 *.exe*
    文件。CPU窗口应该会弹出。现在，在反汇编窗格中右键单击并选择**搜索** ▸ **所有引用的文本字符串**。这将打开引用窗口，如[图5-1](ch05.xhtml#ch5fig1)所示。
- en: '![image](../images/f05-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-01.jpg)'
- en: '*Figure 5-1: OllyDbg’s References window, showing only a list of strings. There
    would be a lot more than four in a real game.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-1：OllyDbg的引用窗口，显示的仅是字符串列表。实际游戏中会有远远超过四个字符串。*'
- en: From this window, right-click and select **Search for text**. A search dialog
    appears. Enter the string you’re looking for, as shown in [Figure 5-2](ch05.xhtml#ch5fig2),
    and make the search as broad as possible by disabling **Case sensitive** and enabling
    **Entire scope**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个窗口，右键点击并选择**搜索文本**。会出现一个搜索对话框。输入你要查找的字符串，如[图5-2](ch05.xhtml#ch5fig2)所示，并通过禁用**区分大小写**和启用**整个范围**来尽可能扩大搜索范围。
- en: '![image](../images/f05-02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-02.jpg)'
- en: '*Figure 5-2: Searching for strings in OllyDbg*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-2：在OllyDbg中搜索字符串*'
- en: Click **OK** to execute the search. The References window comes back into focus
    with the first match highlighted. Double-click the match to see the assembly code
    that uses the string inside the CPU window. The Disassembler pane focuses on the
    line of code at 0x401030, which pushes the format string parameter to `printString()`.
    You can see this line in [Figure 5-3](ch05.xhtml#ch5fig3), where I’ve highlighted
    the entire function call block.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**执行搜索。引用窗口重新聚焦，首个匹配项被高亮显示。双击匹配项查看在CPU窗口中使用该字符串的汇编代码。反汇编窗格聚焦在0x401030的代码行，这行代码将格式化字符串参数推送到`printString()`。你可以在[图5-3](ch05.xhtml#ch5fig3)中看到这一行，我已经高亮了整个函数调用块。
- en: '![image](../images/f05-03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-03.jpg)'
- en: '*Figure 5-3: Viewing the `printString()` call in the CPU window’s Disassembler
    pane*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-3：在CPU窗口的反汇编窗格中查看`printString()`调用*'
- en: By reading the assembly code, you can get a very accurate understanding of exactly
    what the game is doing. The black bracket on the left shows that the string `Health`
    is inside a function call. Notice the arguments to that function. In order, these
    are EAX ➊, ECX ➋, and the format string at 0x4020D0 ➌. EAX is the value at 0x40301C,
    ECX is the value at 0x403018, and the format string contains `Health`. Since the
    string contains two format placeholders, you can assume that the remaining two
    parameters are the arguments for those placeholders.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读汇编代码，你可以非常准确地理解游戏到底在做什么。左侧的黑色括号显示字符串`Health`位于一个函数调用中。注意该函数的参数。按顺序，这些参数是
    EAX ➊、ECX ➋，以及位于 0x4020D0 的格式化字符串 ➌。EAX 是 0x40301C 处的值，ECX 是 0x403018 处的值，格式化字符串包含
    `Health`。由于字符串中包含两个格式占位符，你可以假设剩下的两个参数是这些占位符的参数。
- en: Knowing what the arguments are and that they are pushed in reverse order, you
    can work backward and conclude that the original code looked something like [Listing
    5-2](ch05.xhtml#ch5exe2).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了这些参数是什么，并且它们是按反向顺序入栈的，你可以倒推并得出原始代码类似于 [Listing 5-2](ch05.xhtml#ch5exe2) 的结论。
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 5-2: How a game hacker might interpret the assembly that [Figure 5-3](ch05.xhtml#ch5fig3)
    compiles to*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-2：游戏黑客可能如何解读汇编代码，该代码编译成 [Figure 5-3](ch05.xhtml#ch5fig3)*'
- en: The values stored in EAX and ECX are adjacent in memory, which means they may
    be part of a structure. To keep it simple, though, this example just shows them
    as variable definitions. Either way, these are the two numbers used to display
    the player’s health. Because both of these important values were displayed in
    the game’s UI, it was easy to make assumptions about the underlying code that
    displays them. When you know the purpose of a piece of data, you can quickly find
    the code responsible for fulfilling it; in this case, that knowledge helped us
    quickly find both addresses.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 EAX 和 ECX 中的值在内存中是相邻的，这意味着它们可能是某个结构的一部分。不过，为了简化起见，本例只是将它们展示为变量定义。无论哪种方式，这两者都是用来显示玩家生命值的数字。由于这两个重要的值都显示在游戏的用户界面中，因此很容易做出关于显示它们的底层代码的假设。当你知道某个数据的用途时，你可以快速找到负责实现它的代码；在这种情况下，这种知识帮助我们迅速找到了这两个地址。
- en: In many cases, finding addresses can be this easy, but some pieces of data have
    such complex purposes that it’s harder to guess what to look for. Figuring out
    how to search for map data or character locations in OllyDbg, for instance, can
    be pretty tricky.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，找到地址可能是如此简单，但有些数据的用途如此复杂，以至于很难猜测该寻找什么。例如，在 OllyDbg 中查找地图数据或角色位置可能相当棘手。
- en: Strings are far from the only markers that you can use to find the data you
    want to change in a game, but they are definitely the easiest to teach without
    giving contrived examples. Moreover, some games have logging or error strings
    embedded in their code, and poking around in the Referenced text strings window
    of OllyDbg can be a quick way to determine whether these strings are present.
    If you become familiar with a game’s logging practices, you’ll be able to find
    values even more easily.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串并不是你用来查找游戏中想要更改的数据的唯一标记，但它们无疑是最容易教授的，且不需要做过于牵强的示例。此外，一些游戏的代码中嵌入了日志或错误字符串，在
    OllyDbg 的引用文本字符串窗口中进行探查可以快速判断这些字符串是否存在。如果你熟悉某个游戏的日志实践，你将能够更轻松地找到这些值。
- en: '***Determining New Addresses After Game Updates***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***游戏更新后如何确定新地址***'
- en: When application code is modified and recompiled, a brand-new binary that reflects
    the changes is produced. This binary might be very similar to the previous one,
    or the binaries might be nothing alike; the difference between the two versions
    has a direct correlation to the complexity of the high-level changes. Small changes,
    like modified strings or updated constants, can leave binaries nearly identical
    and often have no effect on the addresses of code or data. But more complex changes—like
    added features, a new user interface, refactored internals, or new in-game content—often
    cause shifts in the location of crucial memory.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序代码被修改并重新编译时，会生成一个反映这些变化的新二进制文件。这个二进制文件可能与之前的非常相似，或者它们完全不同；两者之间的差异与高层次变更的复杂性直接相关。像修改字符串或更新常量这样的简单变更，往往不会对代码或数据的地址产生影响，二进制文件也可能几乎相同。但更复杂的变更——如新增功能、全新的用户界面、重构的内部结构或新的游戏内容——常常会导致关键内存位置的变化。
- en: '**AUTOMATICALLY FIND CURRENTHEALTH AND MAXHEALTH**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动查找 CURRENTHEALTH 和 MAXHEALTH**'
- en: In “[Searching for Assembly Patterns](ch01.xhtml#ch00lev1sec28)” on [page 19](ch01.xhtml#page_19)
    and “[Searching for Strings](ch01.xhtml#ch00lev1sec29)” on [page 21](ch01.xhtml#page_21),
    I showed a few Cheat Engine Lua scripts and explained how they worked. Using the
    `findString()` function in these examples, you can make Cheat Engine automatically
    locate the address of the format string that we just found manually in OllyDbg.
    Next, you can write a small function to scan for this address following byte 0x68
    (the byte for the `PUSH` command, as you can see beside it at 0x401030 in [Figure
    5-3](ch05.xhtml#ch5fig3)) to locate the address of the code that pushes it to
    the stack. Then, you can read 4 bytes from `pushAddress - 5` and `pushAddress
    - 12` to locate `currentHealth` and `maxHealth`, respectively.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 “[搜索汇编模式](ch01.xhtml#ch00lev1sec28)”（第 19 页）和 “[搜索字符串](ch01.xhtml#ch00lev1sec29)”（第
    21 页）中，我展示了一些作弊引擎 Lua 脚本，并解释了它们的工作原理。在这些示例中使用 `findString()` 函数，你可以让作弊引擎自动定位我们刚刚在
    OllyDbg 中手动找到的格式字符串的地址。接下来，你可以编写一个小函数，扫描位于字节 0x68 后面的地址（这是 `PUSH` 指令的字节，如你在 [图
    5-3](ch05.xhtml#ch5fig3) 中 0x401030 旁边看到的）来定位将其压入堆栈的代码的地址。然后，你可以从 `pushAddress
    - 5` 和 `pushAddress - 12` 读取 4 个字节，分别定位到 `currentHealth` 和 `maxHealth`。
- en: This may not seem useful since we’ve already found the addresses, but if this
    were a real game, these addresses would change when an update is released. Using
    this knowledge to automate finding them can be very helpful. If you’re up to the
    challenge, give it a whirl!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能没有用，因为我们已经找到了这些地址，但如果这是一个真实的游戏，这些地址会在更新发布时发生变化。利用这些知识来自动查找地址会非常有帮助。如果你有挑战精神，试试看吧！
- en: Due to constant bug fixes, content improvements, and feature additions, online
    games are among the most rapidly evolving types of software. Some games release
    updates as often as once a week, and game hackers often spend a majority of their
    time reverse engineering the new binaries in order to accordingly update their
    bots.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不断的错误修复、内容改进和功能添加，网络游戏是软件中发展最快的类型之一。有些游戏每周更新一次，游戏黑客通常将大部分时间花在逆向工程新的二进制文件上，以便相应地更新他们的机器人程序。
- en: If you create advanced bots, they will become increasingly supported by a foundation
    of memory addresses. When an update comes, determining the new addresses for a
    large number of values and functions is the most time-consuming inevitability
    you will face. Relying on the “[Tips for Winning the Update Race](ch05.xhtml#ch05sb01)”
    can be very beneficial, but the tips won’t help you locate the updated addresses.
    You can automatically locate some addresses using Cheat Engine scripts, but that
    won’t always work either. Sometimes you’ll have to do the dirty work by hand.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建的是高级机器人，它们将越来越多地依赖于内存地址的基础。每当更新发布时，确定大量值和函数的新地址将是你面临的最耗时的必然任务。依赖于“[更新竞赛获胜技巧](ch05.xhtml#ch05sb01)”会非常有帮助，但这些技巧并不能帮助你找到更新后的地址。你可以通过作弊引擎脚本自动定位一些地址，但这并不总是有效。有时候，你需要手动做这项“脏活”。
- en: 'If you try to reinvent the wheel and find these addresses the same way you
    did initially, you’ll be wasting your time. You actually have a big advantage,
    though: the old binary and the addresses themselves. Using these two things, it
    is possible to find every single address you need to update in a fraction of the
    time.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图重新发明轮子，并像最初一样找到这些地址，你会浪费时间。然而，你实际上有一个很大的优势：旧的二进制文件和这些地址本身。利用这两者，你可以在极短的时间内找到所有需要更新的地址。
- en: '[Figure 5-4](ch05.xhtml#ch5fig4) shows two different disassemblies: a new game
    binary on the left and the previous version on the right. I have taken this image
    from an actual game (which will remain nameless) in order to give you a realistic
    example.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-4](ch05.xhtml#ch5fig4)展示了两个不同的反汇编：左侧是新版本的游戏二进制文件，右侧是旧版本。我从一款真实的游戏（名字保密）中截取了这张图片，以便为你提供一个真实的例子。'
- en: '![image](../images/f05-04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-04.jpg)'
- en: '*Figure 5-4: Side-by-side disassemblies of two versions of one game*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：两个版本的游戏反汇编并排显示*'
- en: My bot modified the code at 0x047B542 (right), and I needed to find the corresponding
    code in the new version, which I discovered at 0x047B672 (left). This function
    call invokes a packet-parsing function when a packet has been received. In order
    to find this address originally (and by “originally,” I mean about 100 updates
    previous), I figured out how the game’s network protocol worked, set breakpoints
    on many network-related API calls, stepped through execution, and inspected data
    on the stack until I found something that looked similar to what I expected given
    my knowledge of the protocol.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我的机器人修改了0x047B542处的代码（右侧），我需要在新版本中找到相应的代码，最终我在0x047B672处找到了它（左侧）。这个函数调用会在接收到数据包时调用一个数据包解析函数。为了最初找到这个地址（“最初”指的是大约100次更新前），我弄明白了游戏的网络协议是如何工作的，设定了许多与网络相关的API调用的断点，逐步执行并检查栈上的数据，直到找到一个与我预期的协议知识相似的内容。
- en: '**TIPS FOR WINNING THE UPDATE RACE**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**更新竞赛获胜提示**'
- en: 'In saturated markets, being the first bot developer to release a stable update
    is critical to success. The race starts the second the game updates, and hackers
    determined to be the fastest will spend hundreds of hours preparing. These are
    the most common ways to stay on top:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在饱和的市场中，成为第一个发布稳定更新的机器人开发者对于成功至关重要。比赛在游戏更新的那一刻就开始了，决心最快的黑客会花上数百小时准备。这些是保持领先的最常见方法：
- en: '**Create update alarms** By writing software that alerts you as soon as the
    game patches, you can begin working on your updates as soon as possible.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建更新警报** 通过编写软件，在游戏打补丁时立即提醒你，你就可以尽早开始处理更新。'
- en: '**Automate bot installs** Games often schedule expected updates at times when
    the fewest players are online. Botters hate waking up and downloading new software
    before they bot, but they love waking up to find it silently installed while the
    game is patching.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动化机器人安装** 游戏通常在玩家最少的时候安排预期的更新。做机器人行为的玩家讨厌在开始之前起床并下载新软件，但他们喜欢醒来时发现软件已经在游戏打补丁时悄然安装好了。'
- en: '**Use fewer addresses** The less there is to update, the better. Consolidating
    related data into structures and eliminating unnecessary memory address usage
    can save a bunch of time.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用更少的地址** 更新的内容越少越好。将相关数据合并为结构体，并消除不必要的内存地址使用可以节省大量时间。'
- en: '**Have great test cases** Data changes, and hackers make mistakes. Having ways
    to quickly test every feature can be the difference between a stable bot and one
    that randomly crashes, gets users killed, or even leads to their characters being
    banned from the game.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**拥有优秀的测试用例** 数据会发生变化，黑客也会犯错。能够快速测试每个功能的方式可能是稳定机器人与随机崩溃、导致用户死亡甚至让角色被封禁之间的区别。'
- en: Attacking updates with these practices will give you a sizable head start, but
    they might not always be enough to lead you to victory. Above all else, strive
    to understand reverse engineering as much as possible and use that understanding
    to your advantage.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法来攻击更新将为你提供一个可观的起步优势，但它们可能并不总是足够让你获得胜利。最重要的是，尽量理解逆向工程，并利用这种理解为自己争取优势。
- en: I could have followed the same steps for each of the 100+ updates since then,
    but that would have been unnecessary. The code stayed relatively the same throughout
    the years, which let me use patterns from the old code to find that function call’s
    address in the new code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以按照相同的步骤处理此后的每次100多个更新，但那样就没必要了。多年来代码保持相对不变，这让我可以使用旧代码中的模式，在新代码中找到这个函数调用的地址。
- en: 'Now, consider this chunk of assembly code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑这段汇编代码：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Does it look familiar? Compare it to [Figure 5-4](ch05.xhtml#ch5fig4), and you’ll
    see that this exact code exists right above the highlighted function call in both
    versions of the game. Regardless of what it does, the combination of operations
    looks pretty distinctive; because of the number of different offsets the code
    is using relative to EBP, it’s unlikely that an identical chunk of code exists
    in any other part of the binary.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来熟悉吗？将其与[图5-4](ch05.xhtml#ch5fig4)进行比较，你会发现这个确切的代码在游戏的两个版本中都存在于突出显示的函数调用上方。不管它做什么，这一系列操作看起来相当独特；由于代码相对于EBP使用了多个不同的偏移量，其他地方的二进制文件中不太可能存在完全相同的代码块。
- en: Every time I have to update this address, I open the old binary in OllyDbg,
    highlight this chunk of operations, right-click, and select Asm2Clipboard ▸ Copy
    fixed asm to clipboard. Then, I open the new binary in OllyDbg, navigate to the
    CPU Window, press CTRL-S, paste the assembly code, and hit Find. In 9.5 cases
    out of 10, this places me directly above the function call I need to find in the
    new version.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我需要更新这个地址时，我会在 OllyDbg 中打开旧的二进制文件，选中这一段操作，右键点击，选择 Asm2Clipboard ▸ 复制固定汇编到剪贴板。然后，我在
    OllyDbg 中打开新的二进制文件，进入 CPU 窗口，按 CTRL-S，粘贴汇编代码，然后点击查找。在 9.5 次中的 10 次，这样我就能直接定位到新版本中需要找到的函数调用。
- en: 'When an update comes, you can use the same method to find nearly all of your
    known addresses. It should work for every address you can find easily in assembly
    code. There are a few caveats, though:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新到来时，你可以使用相同的方法找到几乎所有已知的地址。这对于你能在汇编代码中轻松找到的每个地址都适用。不过，有几个注意事项：
- en: • OllyDbg limits search to eight operations, so you must find code markers of
    that size or smaller.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: • OllyDbg 将搜索限制为八个操作，因此你必须找到大小为该数或更小的代码标记。
- en: • The operations you use cannot contain any other addresses, as those addresses
    have likely changed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: • 你使用的操作不能包含任何其他地址，因为那些地址很可能已经发生变化。
- en: • If parts of the game have changed that use the address you’re looking for,
    the code might be different.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果游戏的某些部分发生了变化，使用了你正在寻找的地址，那么代码可能会有所不同。
- en: • If the game changes compilers or switches optimization settings, almost all
    code will be entirely different.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果游戏更换了编译器或切换了优化设置，几乎所有的代码都会发生完全的变化。
- en: As discussed in “Automatically Find `currentHealth` and `maxHealth`” on [page
    102](ch05.xhtml#page_102), you can benefit from writing scripts that carry out
    these tasks for you. Serious game hackers work very hard to automatically locate
    as many addresses as possible, and some of the best bots are engineered to automatically
    detect their addresses at runtime, every time. It can be a lot of work initially,
    but the investment can definitely pay off.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第102页](ch05.xhtml#page_102)的《自动找到`currentHealth`和`maxHealth`》中讨论的那样，你可以通过编写脚本来帮助你自动完成这些任务。资深的游戏黑客会非常努力地自动定位尽可能多的地址，而一些最好的机器人则设计成每次在运行时自动检测它们的地址。虽然最初可能需要很多工作，但这项投资绝对值得。
- en: '**Identifying Complex Structures in Game Data**'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**识别游戏数据中的复杂结构**'
- en: '[Chapter 4](ch04.xhtml#ch04) described how a game might store data in static
    structures. This knowledge will suffice when you’re trying to find simple data,
    but it falls short for data that is stored through dynamic structures. This is
    because dynamic structures might be scattered across different memory locations,
    follow long pointer chains, or require complex algorithms to actually extract
    the data from them.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](ch04.xhtml#ch04)描述了游戏如何将数据存储在静态结构中。当你尝试查找简单数据时，这些知识足够使用，但对于通过动态结构存储的数据来说，它就显得不足够了。这是因为动态结构可能会分散在不同的内存位置，遵循长指针链，或者需要复杂的算法才能从中提取数据。'
- en: This section explores common dynamic structures you’ll find in video game code,
    and how to read data from them once they’re found. To begin, I’ll talk about the
    underlying composition of each dynamic structure. Next, I’ll outline the algorithms
    needed to read the data from these structures. (For simplicity, each algorithm
    discussion assumes you have a pointer to an instance of the structure as well
    as some way to read from memory.) Lastly, I’ll cover tips and tricks that can
    help you determine when a value you’re searching for in memory is actually encapsulated
    in one of these structures, so you’ll know when to apply this knowledge. I’ll
    focus on C++, as its object-oriented nature and heavily used standard library
    are typically responsible for such structures.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探讨你在电子游戏代码中常见的动态结构，以及一旦找到这些结构，如何从中读取数据。首先，我将讲解每个动态结构的基本组成。接下来，我会概述读取这些结构数据所需的算法。（为简单起见，每个算法的讨论假设你有指向该结构实例的指针，并且有某种方式从内存中读取数据。）最后，我将介绍一些技巧，帮助你确定在内存中查找的值是否实际上被封装在这些结构之一中，这样你就知道何时应用这些知识。我将重点讨论C++，因为它的面向对象特性和广泛使用的标准库通常负责这种结构。
- en: '**NOTE**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Some of these structures might differ slightly from machine to machine based
    on compilers, optimization settings, or standard library implementations, but
    the basic concepts will remain the same. Also, in the interest of brevity, I will
    be omitting irrelevant parts of these structures, such as custom allocators or
    comparison functions. Working example code can be found at* [https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)
    *in the resource files for [Chapter 5](ch05.xhtml#ch05).*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些结构可能会因编译器、优化设置或标准库实现的不同，在不同机器上略有差异，但基本概念是相同的。此外，为了简洁起见，我将省略这些结构中的无关部分，例如自定义分配器或比较函数。示例代码可以在*
    [https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)
    *的资源文件中找到，位于[第5章](ch05.xhtml#ch05)的内容。*'
- en: '***The std::string Class***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***std::string 类***'
- en: Instances of `std::string` are among the most common culprits of dynamic storage.
    This class from the C++ Standard Template Library (STL) abstracts string operations
    away from the developer while preserving efficiency, making it widely used in
    all types of software. A video game might use `std::string` structure for any
    string data, such as creature names.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`的实例是动态存储最常见的罪魁祸首之一。C++标准模板库（STL）中的这个类将字符串操作从开发者中抽象出来，同时保持效率，因此广泛应用于各种软件中。一个视频游戏可能会使用`std::string`结构来存储任何字符串数据，比如生物的名字。'
- en: '**Examining the Structure of a std::string**'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查std::string的结构**'
- en: 'When you strip away the member functions and other nondata components of the
    `std::string` class, this is the structure that remains:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你去掉`std::string`类中的成员函数和其他非数据组件时，剩下的结构大概是这样的：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The class reserves 16 characters that are presumably used to store the string
    in place. It also, however, declares that the first 4 bytes can be a pointer to
    a character. This might seem odd, but it’s a result of optimization. At some point,
    the developers of this class decided that 15 characters (plus a null terminator)
    was a suitable length for many strings, and they chose to save on memory allocations
    and de-allocations by reserving 16 bytes of memory in advance. To accommodate
    longer strings, they allowed the first 4 bytes of this reserved memory to be used
    as a pointer to the characters of these longer strings.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该类预留了16个字符，用于直接存储字符串。然而，它也声明前4个字节可以是指向字符的指针。看起来这有些奇怪，但这是优化的结果。某个时候，这个类的开发者决定15个字符（加上一个空终止符）对于许多字符串来说是一个合适的长度，因此他们选择通过提前预留16个字节的内存来节省内存分配和回收的开销。为了适应更长的字符串，他们允许这16个字节的前4个字节作为指针指向更长字符串的字符。
- en: '**NOTE**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If the code were compiled to 64 bits, then it would actually be the first
    8 (not 4) bytes that point to a character. Throughout this example, however, you
    can assume 32-bit addresses and that* `int` *is the size of an address.*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果代码是编译为64位的，那么实际上指向字符的是前8个字节（而不是4个字节）。不过，在本例中，你可以假设使用的是32位地址，并且`int`是地址的大小。*'
- en: 'Accessing string data this way takes some overhead. The function to locate
    the right buffer looks something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式访问字符串数据会带来一定的开销。定位正确缓冲区的函数大致如下所示：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The fact that a `std::string` can be either a complete string or a pointer to
    a longer string makes this particular structure quite tricky from a game-hacking
    perspective. Some games may use `std::string` to store strings that only rarely
    exceed 15 characters. When this is the case, you might implement bots that rely
    on these strings, never knowing that the underlying structure is in fact more
    complicated than a simple string.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`可以是一个完整的字符串，也可以是指向更长字符串的指针，这使得从游戏破解的角度来看，这种结构相当棘手。有些游戏可能会使用`std::string`来存储字符串，这些字符串很少超过15个字符。在这种情况下，你可能会编写依赖于这些字符串的机器人，却不知道底层结构其实比一个简单的字符串要复杂得多。'
- en: '**Overlooking a std::string Can Ruin Your Fun**'
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**忽视std::string可能会破坏你的乐趣**'
- en: Not knowing the true nature of the structure containing the data you need can
    lead you to write a bot that works only some of the time and fails when it counts.
    Imagine, for example, that you’re trying to figure out how a game stores creature
    data. In your hypothetical search, you find that all the creatures in the game
    are stored in an array of structures that look something like [Listing 5-3](ch05.xhtml#ch5exe3).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不了解包含所需数据的结构的真实情况，就可能编写出一个只在某些时候有效、而在关键时刻失效的机器人。例如，假设你正在尝试弄清楚一个游戏是如何存储生物数据的。在你的假设性搜索中，你发现游戏中的所有生物都存储在一个结构体数组中，这些结构体看起来类似于[示例
    5-3](ch05.xhtml#ch5exe3)。
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5-3: How you might interpret creature data found in memory*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-3：你可能如何解释内存中找到的生物数据*'
- en: After scanning the creature data in memory, say you notice that the first 4
    bytes of each structure are unique for each creature, so you call those bytes
    the `uniqueID` and assume they form a single `int` property. Looking further in
    the memory, you find that the creature’s `name` is stored right after `uniqueID`,
    and after some deduction, you figure out the name is 16 bytes long. The next value
    you see in memory turns out to be the `nameLength`; it’s a bit strange that a
    null-terminated string has an associated length, but you ignore that oddity and
    continue analyzing the data in memory. After further analysis, you determine what
    the remaining values are for, define the structure shown in [Listing 5-3](ch05.xhtml#ch5exe3),
    and write a bot that automatically attacks creatures with certain names.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描内存中的生物数据后，假设你注意到每个结构的前 4 个字节对于每个生物都是唯一的，因此你将这些字节称为`uniqueID`，并假设它们形成了一个单一的`int`属性。进一步查看内存后，你发现生物的`name`紧接在`uniqueID`之后存储，并通过一些推理，你发现名字的长度为
    16 字节。接下来，你在内存中看到的值原来是`nameLength`；虽然一个以空字符结尾的字符串有一个长度字段有点奇怪，但你忽略了这个怪异现象，继续分析内存中的数据。经过进一步分析，你弄清楚了剩余值的用途，定义了[列表
    5-3](ch05.xhtml#ch5exe3)中展示的结构，并写了一个机器人，自动攻击具有某些名字的生物。
- en: After weeks of testing your bot while hunting creatures with names like *Dragon*,
    *Cyclops*, *Giant*, and *Hound*, you decide it’s time to give your bot to your
    friends. For the inaugural use, you gather everyone together to kill a boss named
    *Super Bossman Supreme*. The entire team sets the bot to attack the boss first
    and target lesser creatures like a *Demon* or *Grim Reaper* when the boss goes
    out of range.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在几周的测试中，你的机器人不断在与像*龙*、*独眼巨人*、*巨人*和*猎犬*之类的生物战斗时表现良好，你决定是时候把机器人交给你的朋友们使用了。为了首次使用，你把大家聚集在一起，去击败一只名为*超级老板至尊*的boss。全体队员设定机器人优先攻击boss，并在boss超出攻击范围时，将目标转向像*恶魔*或*死神*之类的次级生物。
- en: Once your team arrives at the boss’s dungeon . . . you’re all slowly obliterated.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的团队到达了老板的副本……你们都会被慢慢消灭。
- en: What went wrong in this scenario? Your game must be storing creature names with
    `std::string`, not just a simple character array. The `name` and `nameLength`
    fields in `creatureInfo` are, in fact, part of a `std::string` field, and the
    `name` character array is a union of `dataA` and `dataP` members. *Super Bossman
    Supreme* is longer than 15 characters, and because the bot was not aware of the
    `std::string` implementation, it didn’t recognize the boss. Instead, it constantly
    retargeted summoned *Demon* creatures, effectively keeping you from targeting
    the boss while he slowly drained your health and supplies.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景中出了什么问题？你的游戏一定是用`std::string`存储生物名字，而不是简单的字符数组。`creatureInfo`中的`name`和`nameLength`字段，实际上是`std::string`字段的一部分，而`name`字符数组是`dataA`和`dataP`成员的联合体。*超级老板至尊*的名字超过了
    15 个字符，而由于机器人没有意识到`std::string`的实现，它没有识别出boss。相反，机器人不断将目标锁定为召唤出的*恶魔*生物，实际上让你无法锁定boss，同时boss慢慢消耗了你的生命和资源。
- en: '**Determining Whether Data Is Stored in a std::string**'
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**判断数据是否存储在 std::string 中**'
- en: 'Without knowing how the `std::string` class is structured, you’d have trouble
    tracking down bugs like the hypothetical one I just described. But pair what you’ve
    learned here with experience, and you can avoid these kinds of bugs entirely.
    When you find a string like `name` in memory, don’t just assume it’s stored in
    a simple array. To figure out whether a string is in fact a `std::string`, ask
    yourself these questions:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不了解`std::string`类的结构，你就很难定位像我刚才描述的假设性 bug。把你在这里学到的知识与经验结合起来，你就能完全避免这类 bug。当你在内存中发现像`name`这样的字符串时，不要仅仅假设它是存储在一个简单的数组中。为了弄清楚一个字符串是否实际上是一个`std::string`，问自己以下几个问题：
- en: • Why is the string length present for a null-terminated string? If you can’t
    think of a good reason, then you may have a `std::string` on your hands.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: • 为什么一个以空字符结尾的字符串会有字符串长度的记录？如果你想不出一个合理的理由，那么你可能就遇到了`std::string`。
- en: • Do some creatures (or other game elements, depending on what you’re looking
    for) have names longer than 16 letters, but you find room for only 16 characters
    in memory? If so, the data is almost definitely stored in a `std::string`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: • 一些生物（或其他游戏元素，具体取决于你在寻找什么）是否有超过 16 个字母的名字，但在内存中你只能找到 16 个字符的空间？如果是这样，数据几乎可以肯定是存储在`std::string`中。
- en: • Is the name stored in place, requiring the developer to use `strcpy()` to
    modify it? It’s probably a `std::string`, because working with raw C strings in
    this way is considered bad practice.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: • 名称是直接存储在内存中的，需要开发人员使用 `strcpy()` 来修改它吗？它可能是一个 `std::string`，因为这样处理原始 C 字符串被认为是不好的做法。
- en: Finally, keep in mind that there is also a class called `std::wstring` that
    is used to store wide strings. The implementation is very similar, but `wchar_t`
    is used in place of every `char`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，还有一个名为 `std::wstring` 的类，用于存储宽字符字符串。其实现非常相似，只不过在每个 `char` 的地方使用了 `wchar_t`。
- en: '***The std::vector Class***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***std::vector 类***'
- en: Games must keep track of many dynamic arrays of data, but managing dynamically
    sized arrays can be very tricky. For speed and flexibility, game developers often
    store such data using a templated STL class called `std::vector` instead of a
    simple array.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏必须跟踪许多动态数据数组，但管理动态大小的数组可能非常棘手。为了提高速度和灵活性，游戏开发人员通常使用一个模板化的 STL 类 `std::vector`
    来存储这些数据，而不是使用简单的数组。
- en: '**Examining the Structure of a std::vector**'
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查 std::vector 的结构**'
- en: A declaration of this class looks something like [Listing 5-4](ch05.xhtml#ch5exe4).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的声明类似于[清单 5-4](ch05.xhtml#ch5exe4)。
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 5-4: An abstracted `std::vector` object*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-4：一个抽象的 `std::vector` 对象*'
- en: 'This template adds an extra layer of abstraction, so I’ll continue this description
    using a `std::vector` declared with the `DWORD` type. Here’s how a game might
    declare that vector:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板增加了一层额外的抽象，因此我将继续使用一个声明为 `DWORD` 类型的 `std::vector` 来描述。以下是游戏可能如何声明该 vector：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let’s dissect what a `std::vector` of `DWORD` objects would look like in
    memory. If you had the address of `_vec` and shared the same memory space, you
    could re-create the underlying structure of the class and access `_vec` as shown
    in [Listing 5-5](ch05.xhtml#ch5exe5).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们解析一个 `std::vector` 类型的 `DWORD` 对象在内存中的表现。如果你知道 `_vec` 的地址并共享相同的内存空间，你就可以重新构造该类的底层结构，并像在[清单
    5-5](ch05.xhtml#ch5exe5)中一样访问 `_vec`。
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 5-5: A `DWORD std::vector` object*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-5：一个 `DWORD std::vector` 对象*'
- en: 'You can treat the member `begin` like a raw array, as it points to the first
    element in the `std::vector` object. There is no array length member, though,
    so you must calculate the vector’s length based on `begin` and `end`, which is
    an empty object following the final object in the array. The length calculation
    code looks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将成员 `begin` 视为原始数组，因为它指向 `std::vector` 对象中的第一个元素。然而，没有数组长度成员，因此你必须根据 `begin`
    和 `end` 来计算 vector 的长度，`end` 是跟在数组中最后一个对象后面的空对象。长度计算代码如下所示：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function simply subtracts the address stored in `begin` from the address
    stored in `end` to find the number of bytes between them. Then, to calculate the
    number of objects, it divides the number of bytes by the number of bytes per object.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数简单地将 `begin` 中存储的地址与 `end` 中存储的地址相减，以找到它们之间的字节数。然后，为了计算对象的数量，它将字节数除以每个对象的字节数。
- en: 'Using `begin` and this `length()` function, you can safely access elements
    in `_vec`. That code would look something like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `begin` 和 `length()` 函数，你可以安全地访问 `_vec` 中的元素。代码可能如下所示：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Given an index, this code will fetch an item from the vector. But if the index
    is greater than the vector’s length, a `std::out_of_range` exception will be thrown.
    Adding values to a `std::vector` would be very expensive if the class couldn’t
    reserve or reuse memory, though. To remedy this, the class implements a function
    called `reserve()` that tells the vector how many objects to leave room for.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个索引，这段代码将从 vector 中获取一个元素。但如果索引大于 vector 的长度，则会抛出一个 `std::out_of_range` 异常。不过，如果该类无法预留或重用内存，向
    `std::vector` 中添加值将会非常昂贵。为了解决这个问题，该类实现了一个名为 `reserve()` 的函数，告诉 vector 需要为多少个对象预留空间。
- en: 'The absolute size of a `std::vector` (its *capacity*) is determined through
    an additional pointer, which is called `tail` in the vector class we’ve re-created.
    The calculation for the capacity resembles the length calculation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 的绝对大小（即其 *容量*）是通过一个额外的指针来确定的，在我们重新创建的 vector 类中，这个指针被称为 `tail`。容量的计算与长度计算类似：'
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To find the capacity of a `std::vector`, instead of subtracting the `begin`
    address from the `end` address, as you would to calculate length, this function
    subtracts the `begin` address from `tail`. Additionally, you can use this calculation
    a third time to determine the number of free elements in the vector by using `tail`
    and `end` instead:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到 `std::vector` 的容量，而不是像计算长度那样从 `begin` 地址减去 `end` 地址，这个函数是通过将 `begin` 地址减去
    `tail` 来进行计算的。此外，你还可以使用这个计算的第三次来确定向量中自由元素的数量，方法是使用 `tail` 和 `end` 来代替：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Given proper memory reading and writing functions, you can use the declaration
    in [Listing 5-4](ch05.xhtml#ch5exe4) and the calculations that follow to access
    and manipulate vectors in the memory of a game. [Chapter 6](ch06.xhtml#ch06) discusses
    reading memory in detail, but for now, let’s look at ways you can determine whether
    data you’re interested in is stored in a `std::vector`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 给定适当的内存读取和写入函数，你可以使用 [列表 5-4](ch05.xhtml#ch5exe4) 中的声明以及随后的计算来访问和操作游戏内存中的向量。[第六章](ch06.xhtml#ch06)详细讨论了内存读取，但现在让我们看看如何判断你感兴趣的数据是否存储在
    `std::vector` 中。
- en: '**Determining Whether Data Is Stored in a std::vector**'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**判断数据是否存储在 std::vector 中**'
- en: Once you’ve found an array of data in a game’s memory, there are a few steps
    you can follow to determine whether it is stored in a `std::vector`. First, you
    can be sure that the array is not stored in a `std::vector` if it has a static
    address, because `std::vector` objects require pointer paths to access the underlying
    array. If the array *does* require a pointer path, having a final offset of `0`
    would indicate a `std::vector`. To confirm, you can change the final offset to
    `4` and check if it points to the final object in the array instead of the first
    one. If so, you’re almost definitely looking at a vector, as you’ve just confirmed
    the `begin` and `end` pointers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在游戏的内存中找到了一个数据数组，你可以按照以下步骤来判断它是否存储在 `std::vector` 中。首先，如果数组有静态地址，你可以确定它不是存储在
    `std::vector` 中，因为 `std::vector` 对象需要通过指针路径来访问底层数组。如果数组*确实*需要指针路径，最终偏移为 `0` 将表明它是一个
    `std::vector`。为了确认，你可以将最终偏移改为 `4`，并检查它是否指向数组中的最后一个对象，而不是第一个对象。如果是这样，那么你几乎可以确定你正在查看一个向量，因为你已经确认了
    `begin` 和 `end` 指针。
- en: '***The std::list Class***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***std::list 类***'
- en: Similar to `std::vector`, `std::list` is a class that you can use to store a
    collection of items in a linked list. The main differences are that `std::list`
    doesn’t require a contiguous storage space for elements, cannot directly access
    elements by their index, and can grow in size without affecting any previous elements.
    Due to the overhead required to access items, it is rare to see this class used
    in games, but it shows up in some special cases, which I’ll discuss in this section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `std::vector`，`std::list` 是一个可以用来存储链表中项集合的类。主要的区别在于，`std::list` 不需要元素的连续存储空间，不能通过索引直接访问元素，并且可以在不影响任何前面元素的情况下扩展大小。由于访问项所需的开销，游戏中很少使用这个类，但在一些特殊情况下它会出现，我将在本节中讨论。
- en: '**Examining the Structure of a std::list**'
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查 std::list 的结构**'
- en: The `std::list` class looks something like [Listing 5-6](ch05.xhtml#ch5exe6).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::list` 类看起来像是 [列表 5-6](ch05.xhtml#ch5exe6) 中的样子。'
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 5-6: An abstracted `std::list` object*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-6：一个抽象化的 `std::list` 对象*'
- en: 'There are two classes here: `listItem` and `list`. To avoid extra abstraction
    while explaining how `std::list` works, I’ll describe this object as it would
    look when the type is `DWORD`. Here’s how a game would declare a `std::list` of
    the `DWORD` type:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个类：`listItem` 和 `list`。为了避免在解释 `std::list` 工作原理时出现额外的抽象，我将描述这个对象，当类型为 `DWORD`
    时的样子。下面是一个游戏如何声明一个 `DWORD` 类型的 `std::list`：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Given that declaration, the `std::list` is structured like the code in [Listing
    5-7](ch05.xhtml#ch5exe7).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个声明，`std::list` 的结构就像 [列表 5-7](ch05.xhtml#ch5exe7) 中的代码。
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 5-7: A `DWORD std::list` object*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-7：一个 `DWORD std::list` 对象*'
- en: The class `list` represents the list header, while `listItem` represents a value
    stored in the list. Instead of being stored contiguously, the items in the list
    are stored independently. Each item contains a pointer to the item that comes
    after it (`next`) and the one that comes before it (`prev`), and these pointers
    are used to locate items in the list. The `root` item acts as a marker for the
    end of the list; the `next` pointer of the last item points to `root`, as does
    the `prev` pointer of the first item. The `root` item’s `next` and `prev` pointers
    also point to the first item and the last item, respectively. [Figure 5-5](ch05.xhtml#ch5fig5)
    shows what this looks like.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 类`list`表示列表头，而`listItem`表示存储在列表中的值。与连续存储不同，列表中的项是独立存储的。每个项都包含指向后继项（`next`）和前驱项（`prev`）的指针，这些指针用于在列表中定位项。`root`项充当列表末尾的标记；最后一个项的`next`指针指向`root`，第一个项的`prev`指针也指向`root`。`root`项的`next`和`prev`指针分别指向第一个项和最后一个项。[图
    5-5](ch05.xhtml#ch5fig5)展示了这个结构。
- en: 'Given this structure, you can use the following code to iterate over a `std::list`
    object:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 给定此结构，你可以使用以下代码来遍历`std::list`对象：
- en: '![image](../images/f05-05.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-05.jpg)'
- en: '*Figure 5-5: A `std::list` flowchart*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：`std::list`流程图*'
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first loop starts at the first item (`root->next`) and iterates forward
    (`it = it->next`) until it hits the end marker (`root`). The second loop starts
    at the last item (`root->pres`) and iterates backward (`it = it->prev`) until
    it hits the end marker (`root`). This iteration relies on `next` and `prev` because
    unlike objects in an array, objects in a `std::list` are not contiguous. Since
    the memory of each object in a `std::list` is not contiguous, there’s no quick-and-dirty
    way to calculate the size. Instead, the class just defines a size member. Additionally,
    the concept of reserving space for new objects is irrelevant for lists, so there’s
    no variable or calculation to determine a list’s capacity.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个循环从第一个项（`root->next`）开始，向前迭代（`it = it->next`），直到遇到结束标记（`root`）。第二个循环从最后一个项（`root->pres`）开始，向后迭代（`it
    = it->prev`），直到遇到结束标记（`root`）。这个迭代依赖于`next`和`prev`，因为与数组中的对象不同，`std::list`中的对象不是连续的。由于`std::list`中每个对象的内存不是连续的，因此没有快速粗略的方法来计算其大小。相反，类只是定义了一个大小成员。此外，为新对象预留空间的概念对于列表来说是无关紧要的，因此没有变量或计算来确定列表的容量。
- en: '**Determining Whether Game Data Is Stored in a std::list**'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**确定游戏数据是否存储在std::list中**'
- en: Identifying objects stored in the `std::list` class can be tricky, but there
    are a few hints you can watch for. First, items in a `std::list` cannot have static
    addresses, so if the data you seek has a static address, then you’re in the clear.
    Items that are obviously part of a collection may, however, be part of a `std::list`
    if they’re not contiguous in memory.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 确定存储在`std::list`类中的对象可能会很棘手，但你可以注意到一些提示。首先，`std::list`中的项不能具有静态地址，因此，如果你要查找的数据具有静态地址，那么你就可以排除它。显然属于集合的一部分的项，如果它们在内存中不是连续存储的，可能是`std::list`的一部分。
- en: Also consider that objects in a `std::list` can have infinitely long pointer
    chains (think `it->prev->next->prev->next->prev` . . .), and pointer scanning
    for them in Cheat Engine will show many more results when No Looping Pointers
    is turned off.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要考虑的是，`std::list`中的对象可以具有无限长的指针链（例如`it->prev->next->prev->next->prev`...），并且在作弊引擎中进行指针扫描时，关闭“禁用循环指针”选项后，可能会显示更多的结果。
- en: You can also use a script to detect when a value is stored in a linked list.
    [Listing 5-8](ch05.xhtml#ch5exe8) shows a Cheat Engine script that does just this.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用脚本来检测某个值是否存储在链表中。[清单 5-8](ch05.xhtml#ch5exe8)展示了一个执行此操作的作弊引擎脚本。
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 5-8: Determining whether data is in a `std::list` using a Cheat Engine
    Lua script*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-8：使用作弊引擎 Lua 脚本确定数据是否存储在`std::list`中*'
- en: There’s quite a bit of code here, but what it’s doing is actually pretty simple.
    The `isValueInLinkedList()` function takes an address of some value and then looks
    backward for up to 40 bytes (10 integer objects, in case the value is in some
    larger structure), starting 8 bytes above the address (two pointers must be present,
    and they are 4 bytes each). Because of memory alignment, this loop iterates in
    steps of 4 bytes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有相当多的代码，但实际上它做的事情非常简单。`isValueInLinkedList()`函数获取某个值的地址，然后向后查找最多40个字节（10个整数对象，以防值存在于更大的结构中），从地址上方8个字节开始（两个指针必须存在，每个指针4字节）。由于内存对齐问题，这个循环以4字节为步长进行迭代。
- en: 'On each iteration, the address is passed to the `_verifyLinkedList()` function,
    which is where the magic happens. If we look at it in terms of linked list structure
    as defined in this chapter, the function simply does this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，地址会被传递给`_verifyLinkedList()`函数，这就是魔法发生的地方。如果我们根据本章定义的链表结构来看，函数只是做了以下操作：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That is, the function basically assumes the memory address it’s given points
    to a linked list, and it makes sure the supposed node has valid next and previous
    nodes. If the nodes are valid, the assumption was correct and the address is that
    of a linked list node. If the nodes don’t exist or don’t point to the right locations,
    the assumption was wrong and the address is not part of a linked list.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，函数基本假设它获得的内存地址指向一个链表，并且它确保该节点具有有效的前后节点。如果这些节点有效，那么假设是正确的，这个地址就是链表节点的地址。如果节点不存在或没有指向正确的位置，那么假设是错误的，这个地址不属于链表的一部分。
- en: Keep in mind that this script won’t give you the address of the list’s root
    node but simply the address of the node containing the value you’ve given it.
    To properly traverse a linked list, you’ll need to scan for a valid pointer path
    to the root node, so you’ll need its address.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个脚本不会给出列表根节点的地址，而只是给出包含你提供的值的节点的地址。要正确遍历链表，你需要扫描有效的指针路径直到根节点，所以你需要根节点的地址。
- en: Finding that address can require some searching of memory dumps, a lot of trial
    and error, and a ton of head scratching, but it’s definitely possible. The best
    way to start is to follow the chain of `prev` and `next` nodes until you find
    a node with data that is either blank, nonsensical, or filled with the value `0xBAADF00D`
    (some, but not all, standard library implementations use this value to mark root
    nodes).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 查找该地址可能需要搜索内存转储、进行大量的试错和头疼的思考，但这是绝对可能的。最好的开始方式是跟踪`prev`和`next`节点的链，直到你找到一个数据为空、无意义或填充有值`0xBAADF00D`的节点（一些标准库实现使用这个值来标记根节点，但不是所有实现都如此）。
- en: This investigation can also be made easier if you know exactly how many nodes
    are in the list. Even without the list header, you can determine the amount of
    nodes by continuously following the next pointer until you end up back at your
    starting node, as in [Listing 5-9](ch05.xhtml#ch5exe9).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确切知道列表中有多少个节点，这项调查也会变得更加容易。即使没有列表头，你也可以通过不断跟踪下一个指针，直到回到起始节点，从而确定节点的数量，正如在[Listing
    5-9](ch05.xhtml#ch5exe9)中所示。
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 5-9: Determining the size of an arbitrary `std::list` using a Cheat
    Engine Lua script*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-9：使用Cheat Engine Lua脚本确定任意`std::list`的大小*'
- en: First, this function creates a counter to store the number of nodes and a variable
    to store the next node’s address. The `while` loop then iterates over the nodes
    until it ends up back at the initial node. Finally, it returns the counter variable,
    which was incremented on every iteration of the loop.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个函数创建一个计数器来存储节点数量，以及一个变量来存储下一个节点的地址。然后，`while`循环会遍历节点，直到它回到初始节点。最后，它返回计数器变量，该变量在每次循环迭代时都会增加。
- en: '**FIND THE ROOT NODE WITH A SCRIPT**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过脚本查找根节点**'
- en: It’s actually possible to write a script that can find the root node, but I’ll
    leave it as an optional exercise for you. How does it work? Well, the root node
    must be in the chain of nodes, the list header points to the root, and the size
    of the list will immediately follow the root in memory. Given this information,
    you can write a script that will search for any memory containing a pointer to
    one of the list’s nodes, followed by the size of the list. More often than not,
    this piece of memory is the list header, and the node it points to is the root
    node.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可以编写一个脚本来查找根节点，但我将其作为一个可选练习留给你。它是如何工作的呢？根节点必须在节点链中，列表头指向根节点，且列表的大小会紧跟根节点在内存中。基于这些信息，你可以编写一个脚本，搜索任何包含指向某个列表节点的指针的内存，后面紧跟着的是列表的大小。通常情况下，这块内存就是列表头，它指向的节点就是根节点。
- en: '***The std::map Class***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***std::map类***'
- en: 'Like a `std::list`, a `std::map` uses links between elements to form its structure.
    Unique to `std::map`, however, is the fact that each element stores two pieces
    of data (a key and a value), and sorting the elements is an inherent property
    of the underlying data structure: a red-black tree. The following code shows the
    structures that compose a `std::map`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 像`std::list`一样，`std::map`也使用元素之间的链接来形成其结构。然而，`std::map`独特之处在于每个元素存储两部分数据（一个键和值），并且排序元素是底层数据结构（红黑树）的固有属性。下面的代码展示了组成`std::map`的结构。
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A red-black tree is a self-balancing binary search tree, so a `std::map` is,
    too. In the STL’s `std::map` implementation, each element (or node) in the tree
    has three pointers: `left`, `parent`, and `right`. In addition to the pointers,
    each node also has a `key` and a `value`. The nodes are arranged in the tree based
    on a comparison between their keys. The `left` pointer of a node points to a node
    with a smaller key, and the `right` pointer points to a node with a larger key.
    The `parent` points to the upper node. The first node in the tree is called the
    `rootNode`, and nodes that lack children point to it.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树是一种自平衡的二叉搜索树，因此`std::map`也是如此。在STL的`std::map`实现中，树中的每个元素（或节点）都有三个指针：`left`、`parent`和`right`。除了指针外，每个节点还拥有一个`key`和一个`value`。节点在树中的排列是基于它们键的比较。一个节点的`left`指针指向一个具有较小键的节点，`right`指针指向一个具有较大键的节点。`parent`指向上一级节点。树中的第一个节点叫做`rootNode`，没有子节点的节点指向它。
- en: '**Visualizing a std::map**'
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**可视化`std::map`**'
- en: '[Figure 5-6](ch05.xhtml#ch5fig6) shows a `std::map` that has the keys 1, 6,
    8, 11, 13, 15, 17, 22, 25, and 27.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-6](ch05.xhtml#ch5fig6)显示了一个包含键值1、6、8、11、13、15、17、22、25和27的`std::map`。'
- en: '![image](../images/f05-06.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-06.jpg)'
- en: '*Figure 5-6: A red-black tree*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-6：红黑树*'
- en: The top node (holding the value `13`) is pointed to by the `parent` of `rootNode`.
    Everything to the left of it has a smaller `key`, and everything to the right
    has a greater `key`. This is true for any node in the tree, and this truth enables
    efficient key-based search. While not represented in the image, the left pointer
    of the root node will point to the leftmost node (`1`), and the right pointer
    will point to the rightmost node (`27`).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部节点（持有值`13`）由`rootNode`的`parent`指向。它左侧的所有节点有较小的`key`，右侧的所有节点有较大的`key`。这一规则适用于树中的任何节点，正是这种规则使得基于键的搜索非常高效。虽然图中没有表现出来，但根节点的`left`指针将指向最左边的节点（`1`），而`right`指针将指向最右边的节点（`27`）。
- en: '**Accessing Data in a std::map**'
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**访问`std::map`中的数据**'
- en: 'Once again, I’ll use a static `std::map` definition when discussing how to
    extract data from the structure. Since the template takes two types, I’ll also
    use some pseudotypes to keep things obvious. Here’s the declaration for the `std::map`
    object I’ll reference for the rest of the section:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，在讨论如何从结构中提取数据时，我将使用静态的`std::map`定义。由于模板需要两个类型，我也会使用一些伪类型来保持清晰。以下是我将在本节余下部分引用的`std::map`对象的声明：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With this declaration, the structure of `myMap` becomes:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个声明，`myMap`的结构变成了：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There are some important algorithms that you might need to access the data
    in a `std::map` structure in a game. First, blindly iterating over every item
    in the map can be useful if you just want to see all of the data. To do this sequentially,
    you could write an iteration function like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，你可能需要访问`std::map`结构中的一些重要算法。首先，盲目遍历映射中的每一项可能是有用的，尤其是当你只是想查看所有数据时。为了按顺序执行这一操作，你可以像这样编写一个迭代函数：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A function to iterate over an entire map would first read the current node and
    check whether it’s the `rootNode`. If not, it would recurse left, print the node,
    and recurse right.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个遍历整个映射的函数会首先读取当前节点，并检查它是否是`rootNode`。如果不是，它会递归向左，打印节点，然后递归向右。
- en: 'To call this function, you’d have to pass a pointer to the `rootNode` as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个函数时，你需要传入指向`rootNode`的指针，代码如下：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The purpose of a `std::map`, however, is to store keyed data in a quickly searchable
    way. When you need to locate a node given a specific `key`, mimicking the internal
    search algorithm is preferable to scanning the entire tree. The code for searching
    a `std::map` looks something like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`std::map`的目的是以快速可搜索的方式存储带键数据。当你需要根据特定的`key`来定位一个节点时，模仿内部搜索算法比扫描整个树更为可取。搜索`std::map`的代码大概是这样的：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Starting at the top of the tree, you simply recurse left if the current key
    is greater than the search key and recurse right if it is smaller. If the keys
    are equal, you return the current node. If you reach the bottom of the tree and
    don’t find the key, you return `NULL` because the key isn’t stored in the map.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从树的顶部开始，如果当前的键大于搜索键，你就递归向左；如果小于，则递归向右。如果键相等，你就返回当前节点。如果你到达树的底部且没有找到该键，说明该键不在映射中，你应该返回`NULL`。
- en: 'Here’s one way you might use this `findItem()` function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一种你可能会使用`findItem()`函数的方式：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As long as `findItem()` doesn’t return `NULL`, this code should print a node
    from `_map`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`findItem()`不返回`NULL`，这段代码应该会打印出`_map`中的一个节点。
- en: '**Determining Whether Game Data Is Stored in a std::map**'
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**确定游戏数据是否存储在`std::map`中**'
- en: Typically, I don’t even consider whether data could be in a `std::map` until
    I know the collection is not an array, a `std::vector`, or a `std::list`. If you
    rule out all three options, then as with a `std::list`, you can look at the three
    integer values before the value and check if they point to memory that could possibly
    be other map nodes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在我确定集合不是数组、`std::vector`或`std::list`之前，我甚至不会考虑数据是否可能存储在`std::map`中。如果排除了这三种选项，那么就像对待`std::list`一样，你可以查看值前面的三个整数值，并检查它们是否指向可能是其他映射节点的内存。
- en: Once again, this can be done with a Lua script in Cheat Engine. The script is
    similar to the one I showed for lists, looping backward over memory to see if
    a valid node structure is found before the value. Unlike the list code, though,
    the function that verifies a node is much trickier. Take a look at the code in
    [Listing 5-10](ch05.xhtml#ch5exe10), and then I’ll dissect it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，这可以通过Cheat Engine中的Lua脚本完成。这个脚本与我之前展示的列表脚本相似，向后循环遍历内存，以查看在值之前是否找到有效的节点结构。不过，与列表代码不同的是，验证节点的函数要复杂得多。看看[列表5-10](ch05.xhtml#ch5exe10)中的代码，接下来我会详细分析它。
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 5-10: Determining whether data is in a `std::map` using a Cheat Engine
    Lua script*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表5-10：使用Cheat Engine Lua脚本确定数据是否在`std::map`中*'
- en: Given `address`, this function checks if `address` is in a map structure. It
    first checks if there’s a valid parent node and, if so, checks whether that parent
    node points to `address` on either side ➊. But this check isn’t enough. If the
    check passes, the function will also climb up the line of `parent` nodes until
    it reaches a node that is the parent of its own parent ➋, trying 200 times before
    calling it quits. If the climb succeeds in finding a node that is its own grandparent,
    then `address` definitely points to a map node. This works because, as I outlined
    in “[Visualizing a `std::map`](ch05.xhtml#ch00lev1sec116)” on [page 114](ch05.xhtml#page_114),
    at the top of every map is a root node whose parent points to the first node in
    the tree, and that node’s parent points back to the root node.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`address`，这个函数检查`address`是否在一个映射结构中。它首先检查是否有有效的父节点，如果有，检查这个父节点是否指向`address`的任一侧
    ➊。但仅仅这个检查还不够。如果检查通过，函数还会沿着`parent`节点的链向上爬升，直到找到一个节点是其父节点的父节点 ➋，并在尝试200次后才会停止。如果爬升成功，找到了一个其祖父节点的节点，那么`address`一定指向一个映射节点。这是可行的，因为正如我在[《可视化`std::map`》](ch05.xhtml#ch00lev1sec116)中概述的那样，在每个映射的顶部有一个根节点，其父节点指向树中的第一个节点，而该节点的父节点则指回根节点。
- en: '**NOTE**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I bet you didn’t expect to run into the grandfather paradox from time travel
    when reading a game-hacking book!*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*我敢打赌，你没想到在阅读一本游戏黑客书时会遇到时间旅行的祖父悖论！*'
- en: 'Using this function and a slightly modified backtracking loop from [Listing
    5-8](ch05.xhtml#ch5exe8), you can automatically detect when a value is inside
    a map:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数和稍作修改的回溯循环，来自[列表5-8](ch05.xhtml#ch5exe8)，你可以自动检测值是否在一个映射中：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Aside from function names, the only change in this code from [Listing 5-8](ch05.xhtml#ch5exe8)
    is that it starts looping 12 bytes before the value instead of 8, because a map
    has three pointers instead of the two in a list. One good consequence of a map’s
    structure is that it’s easy to obtain the root node. When the `_verifyMap` function
    returns true, the `parentsParent` variable will contain the address of the root
    node. With some simple modifications, you could return this to the main call and
    have everything you need to read the data from a `std::map` in one place.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 除了函数名称外，这段代码与[列表5-8](ch05.xhtml#ch5exe8)中的代码唯一的变化是，它开始从值之前的12个字节循环，而不是8个字节，因为映射有三个指针，而列表只有两个。映射结构的一个好处是，根节点很容易获取。当`_verifyMap`函数返回true时，`parentsParent`变量将包含根节点的地址。通过一些简单的修改，你可以将这个地址返回到主调用中，并在一个地方拥有读取`std::map`数据所需的一切。
- en: '**Closing Thoughts**'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结束语**'
- en: Memory forensics is the most time-consuming part of hacking games, and its obstacles
    can appear in all shapes and sizes. Using purpose, patterns, and a deep understanding
    of complex data structures, however, you can quickly overcome these obstacles.
    If you’re still a bit confused about what’s going on, make sure to download and
    play with the example code provided, as it contains proofs of concept for all
    of the algorithms covered in this chapter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 内存取证是破解游戏中最耗时的部分，它的障碍可能以各种形式和大小出现。然而，利用目标、模式以及对复杂数据结构的深刻理解，你可以迅速克服这些障碍。如果你仍然对发生了什么感到有些困惑，确保下载并尝试提供的示例代码，因为它包含了本章涉及的所有算法的概念证明。
- en: In [Chapter 6](ch06.xhtml#ch06), we’ll start diving in to the code you need
    to read from and write to a game’s memory from your own programs so you can take
    the first step in putting to work all of this information about memory structures,
    addresses, and data.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.xhtml#ch06)中，我们将开始深入了解你需要从自己的程序中读取和写入游戏内存的代码，以便你可以迈出第一步，将所有关于内存结构、地址和数据的信息付诸实践。
