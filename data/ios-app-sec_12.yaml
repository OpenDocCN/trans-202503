- en: '**9**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: '**IOS-TARGETED WEB APPS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向 iOS 的 Web 应用**'
- en: Since the introduction of third-party developer APIs for iOS, the Web has been
    an important component of iOS applications. Originally, the APIs were entirely
    web-based. While this potentially made life easier for people with no Objective-C
    or Cocoa experience, it severely limited what non-Apple applications could do
    and relegated them to a second-class status. They had no access to native capabilities
    of the phone, such as geolocation, and were available only within the browser
    instead of on the home screen.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自从为 iOS 引入第三方开发者 API 以来，Web 已成为 iOS 应用程序的重要组成部分。最初，这些 API 完全是基于 Web 的。虽然这可能让没有
    Objective-C 或 Cocoa 经验的人生活更轻松，但它严重限制了非苹果应用的功能，并将它们 relegated 到了二等公民的地位。它们无法访问手机的本地功能，如地理定位，而且只能在浏览器中使用，而无法放置在主屏幕上。
- en: 'While things have changed drastically since that time, the need to integrate
    with web applications from iOS has not. In this chapter, you’ll take a closer
    look at the connections between native iOS applications and web applications:
    how web applications are interacted with, what native iOS APIs can be exposed
    to web apps, and the risks of various approaches.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从那时起情况发生了剧烈变化，但从 iOS 集成 Web 应用程序的需求并没有改变。在本章中，你将深入了解本地 iOS 应用程序与 Web 应用程序之间的联系：如何与
    Web 应用程序交互，哪些本地 iOS API 可以暴露给 Web 应用程序，以及各种方法的风险。
- en: '**Using (and Abusing) UIWebViews**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 (及滥用) UIWebViews**'
- en: Developers use web views to render and interact with web content in iOS applications
    because they are simple to implement and provide browser-like functionality. Most
    web views are instances of the `UIWebView` class, which uses the WebKit rendering
    engine^([1](footnote.html#fn77)) to display web content. Web views are often used
    either to abstract portions of the application so they can be shared between different
    mobile app platforms or simply to offload more logic to the web application, often
    because of more in-house expertise in web application programming than iOS. They’re
    also frequently used as a way to view links to third-party web content without
    having to leave the application and spawn Safari. For example, when you click
    an article in a Facebook feed, the content is rendered in the Facebook app.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者使用 Web 视图来渲染和与 Web 内容交互，因为它们简单易实现，并提供类似浏览器的功能。大多数 Web 视图是 `UIWebView` 类的实例，使用
    WebKit 渲染引擎^([1](footnote.html#fn77)) 来显示 Web 内容。Web 视图常用于将应用程序的部分逻辑抽象化，以便在不同的移动应用平台之间共享，或者仅仅是将更多的逻辑卸载到
    Web 应用程序，通常是因为 Web 应用编程方面的内部技术比 iOS 更为熟练。它们还经常用来作为查看第三方 Web 内容的方式，而无需离开应用并启动 Safari。例如，当你在
    Facebook 动态中点击一篇文章时，内容会在 Facebook 应用中渲染。
- en: Starting with iOS 8, the `WKWebView` framework was introduced. This framework
    gives developers some additional flexibility as well as access to Apple’s high-performance
    Nitro JavaScript engine, which increases the performance of apps that use web
    views significantly. Since you’ll be seeing `UIWebView` for some time to come,
    you’ll examine both APIs in this chapter, beginning with `UIWebView`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从 iOS 8 开始，引入了 `WKWebView` 框架。这个框架为开发者提供了额外的灵活性，并可以访问苹果的高性能 Nitro JavaScript
    引擎，从而显著提升使用 Web 视图的应用性能。由于你将继续看到 `UIWebView`，本章将首先介绍 `UIWebView`，并探讨两个 API 的使用。
- en: '***Working with UIWebViews***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 UIWebViews***'
- en: Web views shift some portion of the application logic to a remote web API or
    application. As such, developers have less control over the behavior of web views
    than a fully native iOS application would allow, but there are a few controls
    you can put in place to bend web views to your will.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Web 视图将应用程序的一部分逻辑转移到远程 Web API 或应用程序。因此，开发者对 Web 视图的控制程度较本地 iOS 应用程序低，但你可以采取一些控制措施，以让
    Web 视图符合你的需求。
- en: By implementing the `shouldStartLoadWithRequest` method of the protocol `UIWebViewDelegate`,^([2](footnote.html#fn78))
    you can make decisions about all the URLs opened via web views before actually
    allowing them to be opened. For example, to limit the attack surface, you can
    limit all requests so that they go only to HTTPS URLs or only to particular domains.
    If you want to ensure that your application will never load non-HTTPS URLs, you
    can do something like the example shown in [Listing 9-1](ch09.html#ch9ex1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现协议 `UIWebViewDelegate` 的 `shouldStartLoadWithRequest` 方法^([2](footnote.html#fn78))，你可以在允许
    URL 被打开之前，决定是否打开所有通过 Web 视图打开的 URL。例如，为了限制攻击面，你可以限制所有请求，只允许它们访问 HTTPS URL 或某些特定域名。如果你希望确保你的应用永远不会加载非
    HTTPS 的 URL，你可以像 [Listing 9-1](ch09.html#ch9ex1) 示例中那样进行操作。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 9-1: Rejecting non-HTTPS URLs and unknown hostnames*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-1：拒绝非 HTTPS URL 和未知主机名*'
- en: 'This example uses two different attributes of the `NSURL` associated with the
    `NSURLRequest` being loaded. At ➊, the `scheme` property of the URL is checked
    to see whether it matches the specified scheme, `https`. At ➋, the `host` property
    is compared to a single whitelisted domain: *happy.fluffy.bunnies.com*. These
    two restrictions limit the application’s web views access to only your domain—rather
    than anything that might be attacker-controlled—and ensure that requests are always
    transmitted over HTTPS, keeping their contents safe from network attackers.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用了与正在加载的 `NSURLRequest` 关联的 `NSURL` 的两个不同属性。在 ➊，检查 URL 的 `scheme` 属性，看它是否与指定的
    `https` 协议匹配。在 ➋，将 `host` 属性与一个白名单域进行比较：*happy.fluffy.bunnies.com*。这两个限制将应用程序的
    Web 视图访问仅限于您的域名，而不是任何可能被攻击者控制的域，并确保请求始终通过 HTTPS 传输，从而保护其内容免受网络攻击者的侵害。
- en: Web views may seem like the way to go because you can reuse codebases across
    platforms and still have some level of control over the local system. However,
    web views do have some serious security implications. One limitation is the inability
    to upgrade the WebKit binary shipped with `UIWebView`. WebKit is prepackaged with
    new versions of iOS and does not get updated out-of-band from the main OS. This
    means that any WebKit vulnerabilities that are discovered remain exploitable until
    a new version of iOS is released.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Web 视图看起来是个不错的选择，因为它可以跨平台重用代码库，同时对本地系统保持一定的控制。然而，Web 视图确实存在一些严重的安全隐患。一个限制是无法升级随
    `UIWebView` 一起打包的 WebKit 二进制文件。WebKit 是与 iOS 新版本一起打包的，并且不会从主操作系统中单独更新。这意味着，任何发现的
    WebKit 漏洞在发布新版本的 iOS 之前都无法修复。
- en: Another major part of using web views securely involves handling your cached
    data properly, which I’ll discuss in the next section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 安全使用 Web 视图的另一个重要方面是妥善处理缓存数据，我将在下一节讨论这个问题。
- en: '***Executing JavaScript in UIWebViews***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在 UIWebViews 中执行 JavaScript***'
- en: The web view JavaScript engine is known as JavaScriptCore, also marketed as
    Nitro by Apple. While the new `WKWebView` class improves JavaScript support (see
    “[Enter WKWebView](ch09.html#ch09lev1sec03)” on [page 158](ch09.html#page_158)),
    the implementation of JavaScript-Core as used in `UIWebView` has a couple of shortcomings
    when compared with JavaScript engines in modern browsers. The main limitation
    is the lack of just-in-time (JIT) compilation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Web 视图的 JavaScript 引擎称为 JavaScriptCore，也由 Apple 称为 Nitro。虽然新的 `WKWebView` 类改进了
    JavaScript 支持（请参见 “[进入 WKWebView](ch09.html#ch09lev1sec03)” 页[158](ch09.html#page_158)），但与现代浏览器中的
    JavaScript 引擎相比，`UIWebView` 中使用的 JavaScriptCore 实现存在一些不足之处。主要的限制是缺少即时编译（JIT）。
- en: '`UIWebView` JavaScript execution also limits total allocations to 10MB and
    runtime to 10 seconds, at which point execution will be immediately and unequivocally
    halted. Despite these shortcomings, applications can execute a limited amount
    of JavaScript by passing the script to `stringByEvaluatingJavaScriptFromString`,
    as illustrated in [Listing 9-2](ch09.html#ch9ex2).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIWebView` 的 JavaScript 执行还将总分配限制为 10MB，并且运行时间限制为 10 秒，超过该时间点，执行将立即且无条件地停止。尽管有这些限制，应用程序仍然可以通过将脚本传递给
    `stringByEvaluatingJavaScriptFromString` 来执行有限的 JavaScript，如[列表 9-2](ch09.html#ch9ex2)所示。'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 9-2: Injecting JavaScript into the web view*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-2：将 JavaScript 注入到 Web 视图中*'
- en: The `stringByEvaluatingJavaScriptFromString` method takes a single argument,
    which is a blob of JavaScript, to insert into the view. Here, the element `elem`
    is created, a simple function to spawn an alert box is defined, and the function
    is inserted into the web view. Now, the newly defined function can be called with
    subsequent calls to `stringByEvaluatingJavaScriptFromString`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`stringByEvaluatingJavaScriptFromString` 方法接受一个参数，这是一个 JavaScript 代码块，用于插入到视图中。这里，创建了元素
    `elem`，定义了一个简单的函数来生成一个警告框，并将该函数插入到 web 视图中。现在，可以通过后续调用 `stringByEvaluatingJavaScriptFromString`
    来调用新定义的函数。'
- en: Do note, however, that allowing dynamic JavaScript execution within your apps
    exposes your users to the JavaScript injection attacks. As such, this functionality
    should be used judiciously, and developers should never reflect untrusted input
    into dynamically generated scripts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，允许在应用中动态执行 JavaScript 会使用户面临 JavaScript 注入攻击的风险。因此，应谨慎使用此功能，开发者切勿将不可信的输入反射到动态生成的脚本中。
- en: You’ll learn more about JavaScriptCore in the next section, where I discuss
    ways to get around the `UIWebView` shortcomings I’ve described so far.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一节中了解更多关于JavaScriptCore的内容，届时我将讨论如何绕过我之前提到的`UIWebView`的不足。
- en: '**Rewards and Risks of JavaScript-Cocoa Bridges**'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**JavaScript-Cocoa桥接的奖励与风险**'
- en: To overcome the limitations of `UIWebView`, various workarounds have been used
    to expose more native functionality to web-based applications. For example, the
    Cordova development framework uses a clever (or dangerous) web view implementation
    to access Cocoa APIs that allow the use of the camera, accelerometer, geolocation
    capabilities, address book, and more.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服`UIWebView`的限制，开发者使用了各种变通方法，将更多的原生功能暴露给基于网页的应用。例如，Cordova开发框架通过巧妙（或危险）的网页视图实现，访问Cocoa
    API，允许使用相机、加速计、地理定位功能、通讯录等。
- en: In this section, I’ll introduce you to some popular JavaScript-Cocoa bridges,
    provide examples of how you’d see them used in the wild, and discuss some security
    risks they pose.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向你介绍一些流行的JavaScript-Cocoa桥接，提供它们在实际应用中的使用示例，并讨论它们带来的一些安全风险。
- en: '***Interfacing Apps with JavaScriptCore***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***与JavaScriptCore进行接口交互***'
- en: Prior to iOS 7, `[UIWebView stringByEvaluatingJavaScriptFromString:]` was the
    only way to invoke JavaScript from inside an application. However, iOS 7 shipped
    with the JavaScriptCore framework, which has full support for bridging communications
    between native Objective-C and a JavaScript runtime. The bridge is created via
    the new `JSContext` global object, which provides access to a JavaScript virtual
    machine for evaluating code. The Objective-C runtime can also obtain strong references
    to JavaScript values via `JSValue` objects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 7之前，`[UIWebView stringByEvaluatingJavaScriptFromString:]`是应用程序内部调用JavaScript的唯一方法。然而，iOS
    7发布了JavaScriptCore框架，它完全支持原生Objective-C和JavaScript运行时之间的桥接通信。该桥接通过新的`JSContext`全局对象创建，提供了访问JavaScript虚拟机以评估代码的能力。Objective-C运行时还可以通过`JSValue`对象获取对JavaScript值的强引用。
- en: 'You can use JavaScriptCore to interface with the JavaScript runtime in two
    fundamental ways: by using inline blocks or by directly exposing Objective-C objects
    with the `JSExport` protocol. I’ll briefly cover how both methods work and then
    discuss security concerns introduced by this new attack surface.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种基本方式使用JavaScriptCore与JavaScript运行时进行交互：使用内联块或通过`JSExport`协议直接暴露Objective-C对象。我将简要介绍这两种方法的工作原理，然后讨论这种新攻击面带来的安全问题。
- en: '**Directly Exposing Objective-C Blocks**'
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**直接暴露Objective-C块**'
- en: One use of Objective-C blocks is to provide a simple mechanism to expose Objective-C
    code to JavaScript. When you expose an Objective-C block to JavaScript, the framework
    automatically wraps it with a callable JavaScript function, which allows you to
    then call the Objective-C code directly from JavaScript. Let’s look at an example—albeit
    a contrived one—in [Listing 9-3](ch09.html#ch9ex3).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C块的一种用途是提供一个简单的机制，将Objective-C代码暴露给JavaScript。当你将Objective-C块暴露给JavaScript时，框架会自动将其包装为一个可调用的JavaScript函数，这样你就可以直接从JavaScript调用Objective-C代码。让我们来看一个例子——尽管这是一个假设的例子——在[Listing
    9-3](ch09.html#ch9ex3)中。
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 9-3: Exposing an Objective-C block to JavaScript*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-3: 将Objective-C块暴露给JavaScript*'
- en: Here, a block (you can see it defined by the `^` operator at ➊) is exposed that
    accepts a password and a salt from JavaScript and uses the Common-Crypto framework
    to create a hash. This block can then be accessed directly from JavaScript to
    create the user’s password hash, as shown in [Listing 9-4](ch09.html#ch9ex4).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，暴露了一个块（你可以看到它由`^`操作符在➊处定义），该块接收JavaScript中的密码和盐值，并使用Common-Crypto框架创建哈希。然后可以直接从JavaScript访问此块，生成用户的密码哈希，如[Listing
    9-4](ch09.html#ch9ex4)所示。
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 9-4: JavaScript call to exposed Objective-C block*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-4: 调用暴露的Objective-C块的JavaScript*'
- en: This technique lets you utilize the Cocoa Touch APIs and avoid re-implementing
    difficult and easily botched operations such as encryption or hashing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使你能够利用Cocoa Touch API，避免重新实现诸如加密或哈希等复杂且容易出错的操作。
- en: Blocks are the simplest way to expose Objective-C code to JavaScript, but they
    have a few drawbacks. For instance, all the bridged objects are immutable, so
    changing the value of an Objective-C variable won’t affect the JavaScript variable
    that it is mapped to. However, if you do need to share objects between both execution
    contexts, you can also expose custom classes using the `JSExport` protocol.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Blocks是将Objective-C代码暴露给JavaScript的最简单方式，但它们也有一些缺点。例如，所有桥接的对象都是不可变的，因此改变Objective-C变量的值不会影响与之映射的JavaScript变量。然而，如果你确实需要在两个执行上下文之间共享对象，你也可以使用`JSExport`协议暴露自定义类。
- en: '**Connecting Objective-C and JavaScript with JSExport**'
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通过JSExport连接Objective-C和JavaScript**'
- en: The `JSExport` protocol allows applications to expose entire Objective-C classes
    and instances to JavaScript and operate on them as if they were JavaScript objects.
    Additionally, the references to their Objective-C counterparts are strong, meaning
    modifications to an object in one environment are reflected in the other. Defining
    variables and methods within a protocol that inherits `JSExport` signals to JavaScriptCore
    that those elements can be accessed from JavaScript, as illustrated in [Listing
    9-5](ch09.html#ch9ex5).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSExport`协议允许应用程序将整个Objective-C类和实例暴露给JavaScript，并像操作JavaScript对象一样对它们进行操作。此外，它们与Objective-C对应对象的引用是强引用，这意味着在一个环境中对对象的修改会反映到另一个环境中。定义继承了`JSExport`的协议中的变量和方法，向JavaScriptCore表明这些元素可以从JavaScript访问，如[列表9-5](ch09.html#ch9ex5)所示。'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 9-5: Exposing variables and methods using a whitelist approach*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表9-5：使用白名单方法暴露变量和方法*'
- en: 'Thanks to that `JSExport` protocol declaration, JavaScript has access to the
    variables `name` and `address` and the function `updateUser`. Apple has made exposing
    such objects to JavaScriptCore extremely easy, which means it can also be extremely
    easy for developers to inadvertently expose all kinds of unintended functionality.
    Luckily, this bridge follows an entirely opt-in model: only members you actually
    define in the protocol itself are exposed. Unless explicitly whitelisted in the
    protocol definition, any additional declarations made in the class interface are
    hidden, as in [Listing 9-6](ch09.html#ch9ex6).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`JSExport`协议声明，JavaScript可以访问变量`name`和`address`以及函数`updateUser`。苹果使得将这些对象暴露给JavaScriptCore变得非常简单，这也意味着开发者很容易不小心暴露出各种不必要的功能。幸运的是，这座桥接遵循完全可选择加入的模式：只有你在协议中实际定义的成员才会被暴露。除非在协议定义中明确列入白名单，否则在类接口中做的任何额外声明都会被隐藏，就像在[列表9-6](ch09.html#ch9ex6)中`password`属性的情况一样。
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 9-6: Elements declared outside the protocol definition are inacessible
    in JavaScript*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表9-6：在协议定义之外声明的元素在JavaScript中不可访问*'
- en: The `User` interface inherits from `UserExports` at ➊, so it also inherits from
    `JSExport`. But the `password` property and the `resetPassword` method aren’t
    declared inside `UserExports`, so they won’t be exposed to JavaScript.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`接口在➊处继承了`UserExports`，因此它也继承了`JSExport`。但是，`password`属性和`resetPassword`方法并未在`UserExports`中声明，因此它们不会暴露给JavaScript。'
- en: 'Now that JavaScriptCore knows about your `UserExports` protocol, it can create
    an appropriate wrapper object when you add an instance of it to a `JSContext`,
    as in the next listing:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，JavaScriptCore了解了你的`UserExports`协议，它可以在你将其实例添加到`JSContext`时创建一个合适的包装对象，如下一个列表所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, a `JSContext` is set up at ➊, an instance of a `User` class is set up
    at ➋, and some values are assigned to three of the new user’s properties. One
    of those properties, `hiddenName`, was defined only in the `@implementation` instead
    of the protocol—the same thing that happened in [Listing 9-6](ch09.html#ch9ex6)
    with the `password` property. At ➌, the newly created user is bridged to the `JSContext`.
    When the code subsequently tries to access the values of the user object from
    JavaScript, the `value` property is successfully accessed at ➍, while the attempt
    to access `hiddenName` fails ➎.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`JSContext`在➊处被设置，`User`类的一个实例在➋处被创建，并且给新用户的三个属性赋值。其中一个属性`hiddenName`只在`@implementation`中定义，而不是在协议中定义——这与[列表9-6](ch09.html#ch9ex6)中`password`属性的情况相同。在➌处，创建的用户被桥接到`JSContext`。当代码随后尝试从JavaScript访问用户对象的值时，`value`属性在➍处成功访问，而访问`hiddenName`的尝试在➎处失败。
- en: '**NOTE**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Use discretion when exporting objects to JavaScriptCore. An attacker who exploits
    a script injection flaw will be able to run any exported functions, essentially
    turning the script injection into native remote code execution on users’ devices.*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*在将对象导出到JavaScriptCore时要谨慎。如果攻击者利用了脚本注入漏洞，就可以运行任何导出的函数，本质上将脚本注入转变为在用户设备上的本地远程代码执行。*'
- en: 'One additional interesting point is that JavaScriptCore disallows calling exported
    class constructors. (This is a bug in iOS that, as of iOS 8, has yet to be resolved.)
    So even if you add `[User class]` to your context, you won’t be able to create
    new objects using `new`. As I discovered through some testing, however, it’s possible
    to work around that limitation. You can essentially implement an exported Objective-C
    block that accepts a class name and then creates and returns an instance of an
    arbitrary class to JavaScript, as I’ve done here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的点是，JavaScriptCore不允许调用导出的类构造函数。（这是iOS中的一个bug，截至iOS 8，尚未解决。）因此，即使你将`[User
    class]`添加到你的上下文中，也无法使用`new`来创建新对象。然而，正如我通过一些测试发现的那样，实际上是可以绕过这个限制的。你可以实现一个导出的Objective-C块，该块接受一个类名，然后创建并返回一个任意类的实例给JavaScript，正如我在这里所做的：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This technique bypasses the need to explicitly export any classes and allows
    you to instantiate an object of any type and expose it to JavaScript-Core. However,
    no members have been whitelisted to be exported, so there are no strong references
    to any methods or variables of the class object. Clearly, there’s plenty of room
    for more security research into bypassing the restrictions implemented by JavaScriptCore
    because the Objective-C runtime is such a dynamic and powerful beast.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术绕过了显式导出任何类的需求，并允许你实例化任何类型的对象并将其暴露给JavaScript-Core。然而，没有成员被列入白名单以供导出，因此没有对类对象的任何方法或变量的强引用。显然，对于绕过JavaScriptCore实现的限制，仍然有很大的安全研究空间，因为Objective-C运行时是如此动态且强大。
- en: One common complaint about the JavaScriptCore framework is that there is no
    documented way to access the `JSContext` of a `UIWebView`. I’ll discuss some potential
    ways around this next.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JavaScriptCore框架的一个常见抱怨是，没有文档说明如何访问`UIWebView`的`JSContext`。我接下来会讨论一些可能的解决方法。
- en: '**Manipulating JavaScript in Web Views**'
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在Web视图中操作JavaScript**'
- en: Why expose this `JSContext` functionality without a way to access it within
    a web view? It’s not clear what Apple’s intentions were, but the developers did
    only half the job of documenting the JavaScriptCore APIs. As of yet, there’s no
    official Apple way to manipulate a `UIWebView`’s `JSContext`, but several people
    have discovered methods to do so. Most of them involve using the `valueForKeyPath`
    method, as in [Listing 9-7](ch09.html#ch9ex7).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要在没有访问Web视图内`JSContext`的方式下暴露这种`JSContext`功能？苹果的意图尚不明确，但开发者只完成了一半的工作，即文档化JavaScriptCore
    API。到目前为止，苹果并没有提供官方的方式来操作`UIWebView`的`JSContext`，但已有几个人发现了方法来实现这一点。它们大多数都涉及使用`valueForKeyPath`方法，正如在[清单
    9-7](ch09.html#ch9ex7)中所示。
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 9-7: Manipulating a DOM via Objective-C*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-7：通过Objective-C操作DOM*'
- en: Since this isn’t an officially Apple-sanctioned approach, there’s no guarantee
    that this kind of code will make it into the App Store, but it’s worth being aware
    of the ways developers may try to communicate between JavaScript and Objective-C
    and the pitfalls it poses.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这不是苹果官方认可的方法，因此无法保证此类代码能够通过App Store审核，但了解开发者可能会尝试在JavaScript与Objective-C之间进行通信的方式及其可能带来的问题是很有必要的。
- en: Of course, the `JSContext` isn’t the only way to connect JavaScript to Objective-C.
    I describe Cordova, another popular bridge, in the next section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`JSContext`并不是将JavaScript与Objective-C连接的唯一方式。我将在下一节中描述另一种流行的桥接方式——Cordova。
- en: '***Executing JavaScript with Cordova***'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Cordova执行JavaScript***'
- en: Cordova (known as PhoneGap before Adobe acquired the development firm Nitobi)
    is an SDK that provides native mobile APIs to a web view’s JavaScript execution
    environment in a platform-agnostic manner. This allows mobile applications to
    be developed like standard web applications using HTML, CSS, and JavaScript. Those
    applications then work across all platforms Cordova supports. This can significantly
    reduce lead time and do away with the need for development firms to hire platform-specific
    engineers, but Cordova’s implementation increases the application attack surface
    significantly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Cordova（在 Adobe 收购开发公司 Nitobi 之前称为 PhoneGap）是一个 SDK，它以平台无关的方式将原生移动 API 提供给 Web
    视图的 JavaScript 执行环境。这使得可以像标准 Web 应用程序一样使用 HTML、CSS 和 JavaScript 开发移动应用程序。这些应用程序随后可以在
    Cordova 支持的所有平台上运行。这可以显著减少开发时间，并且无需开发公司聘请特定平台的工程师，但 Cordova 的实现显著增加了应用程序的攻击面。
- en: '**How Cordova Works**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Cordova 的工作原理**'
- en: Cordova bridges JavaScript and Objective-C by implementing an `NSURLProtocol`
    to handle any JavaScript-initiated `XmlHttpRequest` to *file://!gap_exec*. If
    the native Cordova library detects a call to this URI, it attempts to pull class,
    method, argument, and callback information out of the request headers, as evidenced
    in [Listing 9-8](ch09.html#ch9ex8).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Cordova 通过实现 `NSURLProtocol` 来桥接 JavaScript 和 Objective-C，以处理任何 JavaScript 发起的
    `XmlHttpRequest` 到 *file://!gap_exec*。如果原生的 Cordova 库检测到对此 URI 的调用，它将尝试从请求头中提取类、方法、参数和回调信息，正如[示例
    9-8](ch09.html#ch9ex8)所证明的那样。
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 9-8: Detecting native library calls in* CDVURLProtocol.m^([3](footnote.html#fn79))'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-8：在* CDVURLProtocol.m^([3](footnote.html#fn79)) *中检测原生库调用*'
- en: At ➊, the request URL is checked for a path component of */!gap_exec*, and at
    ➋, the value of the `cmds` HTTP header is extracted. Cordova then passes these
    commands to the command queue ➌, where they will be executed if possible. When
    these commands are queued, Cordova looks up the information in a map of available
    Cordova plug-ins, which essentially just expose various portions of the native
    functionality and can be extended arbitrarily. If a particular plug-in is enabled
    and the class in the request can be instantiated, then the method is called with
    the supplied arguments using the all-powerful `objc_msgSend`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，请求的 URL 被检查是否包含路径组件*/!gap_exec*，在➋处，提取 `cmds` HTTP 头部的值。然后，Cordova 将这些命令传递到命令队列➌，在那里它们将尽可能地被执行。当这些命令被排队时，Cordova
    会在可用的 Cordova 插件映射中查找相关信息，这些插件本质上只是暴露了原生功能的各个部分，并且可以任意扩展。如果某个特定插件被启用，并且请求中的类可以实例化，那么将使用强大的
    `objc_msgSend` 方法调用该方法，并传入提供的参数。
- en: When the call completes, the native code calls back to the JavaScript runtime
    via `[UIWebView stringByEvaluatingJavaScriptFromString]`, calling the `cordova.require('cordova/exec').nativeCallback`
    method defined in *cordova.js*, and provides the original callback ID as well
    as the return value of the native code execution.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用完成时，原生代码通过 `[UIWebView stringByEvaluatingJavaScriptFromString]` 回调到 JavaScript
    运行时，调用在 *cordova.js* 中定义的 `cordova.require('cordova/exec').nativeCallback` 方法，并提供原始回调
    ID 以及原生代码执行的返回值。
- en: This exports an unprecedented amount of native object control to the JavaScript
    runtime, allowing applications to read and write files, read and write Keychain
    storage, upload local files to a remote server via FTP, and so on. But with this
    increased functionality comes potential pitfalls.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将前所未有地将大量原生对象控制权导出到 JavaScript 运行时，允许应用程序读取和写入文件，读取和写入钥匙串存储，通过 FTP 将本地文件上传到远程服务器等等。但随着功能的增加，也带来了潜在的风险。
- en: '**Risks of Using Cordova**'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 Cordova 的风险**'
- en: If your app contains any script injection vulnerabilities and if your users
    can influence application navigation, an attacker could obtain remote code execution.
    They would just have to inject callback functions combined with a call to initiate
    communication with native code. For instance, an attacker might inject a call
    to access Keychain items, grab a copy of all the user’s contacts, or read out
    a file and feed it into a JavaScript function of their choosing, as demonstrated
    in [Listing 9-9](ch09.html#ch9ex9).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序包含任何脚本注入漏洞，并且用户能够影响应用程序的导航，攻击者就可能获得远程代码执行的机会。他们只需要注入回调函数，并结合调用来启动与原生代码的通信。例如，攻击者可能会注入一个调用来访问钥匙串中的项，获取所有用户联系人信息的副本，或读取文件并将其传递给他们选择的
    JavaScript 函数，如[示例 9-9](ch09.html#ch9ex9)所示。
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 9-9: Using Cordova to make Objective-C calls to read the contents
    of a file*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-9：使用 Cordova 调用 Objective-C 来读取文件内容*'
- en: This attacker-supplied JavaScript reads the device’s *com.apple.MobileSMS.plist*,
    which, in iOS 8, is accessible to all applications on the device.^([4](footnote.html#fn80))
    This gives the attacker the ability to examine the user’s contacts, as well as
    determine the owner of the device in question.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个攻击者提供的 JavaScript 读取了设备的*com.apple.MobileSMS.plist*，在 iOS 8 中，该文件对设备上的所有应用程序都是可访问的。^([4](footnote.html#fn80))
    这使得攻击者能够检查用户的联系人信息，并确定设备的所有者。
- en: One reasonable bit of built-in security that can significantly reduce the risks
    of script injection is *domain whitelisting*.^([5](footnote.html#fn81)) Cordova’s
    default security policy blocks all network access and allows interaction only
    with domains that are whitelisted under the `<access>` element in the app configuration.
    The whitelist does allow access to all domains via a wildcard ([*]) entry, but
    don’t be lazy—ensure that only the domains your app needs to talk to in order
    to function properly are in the whitelist. You can configure this through Xcode
    by adding values to the `ExternalHosts` key in `Cordova.plist`, as shown in [Figure
    9-1](ch09.html#ch9fig1).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一项合理的内建安全措施是*域名白名单*，它可以显著降低脚本注入的风险。^([5](footnote.html#fn81)) Cordova 的默认安全策略阻止所有网络访问，仅允许与应用配置中
    `<access>` 元素下的白名单域进行交互。白名单确实允许通过通配符（[*]）访问所有域，但不要懒惰—确保白名单中只有应用程序正常工作所需的域。您可以通过
    Xcode 配置此项，通过向 `Cordova.plist` 中的 `ExternalHosts` 键添加值，如[图9-1](ch09.html#ch9fig1)所示。
- en: '![image](graphics/f09-01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-01.jpg)'
- en: '*Figure 9-1: Whitelisting domains in Cordova using the* `ExternalHosts` *key*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-1：使用 `ExternalHosts` 键在 Cordova 中进行域名白名单配置*'
- en: Besides exposing native code objects to the web view, there are many other drawbacks
    to implementing mobile applications using a web platform wrapper such as Cordova.
    Mainly, each mobile platform has its own security model predicated on specific
    assumptions, APIs, and functionality to protect users and secure local storage.
    One platform’s security model just won’t make sense on other platforms. Providing
    a one-size-fits-all implementation is, necessarily, going to exclude some of these
    platform-specific security benefits for the sake of usability.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将本地代码对象暴露给网页视图之外，使用像 Cordova 这样的网页平台封装来实现移动应用程序还有许多其他缺点。主要是每个平台都有其特定的安全模型，基于特定的假设、API
    和功能来保护用户并保障本地存储安全。一个平台的安全模型在其他平台上根本行不通。提供一个一刀切的实现，必然会为了易用性而忽视一些平台特有的安全优势。
- en: For example, iOS provides secure storage through the Data Protection APIs (as
    I describe in [Chapter 13](ch13.html#ch13)), which require specific arguments
    that don’t lend themselves to a cross-platform implementation. As such, these
    APIs are not supported by Cordova, preventing fine-grained control over when file
    data is encrypted at rest. To solve this problem, you can enable entitlement-level
    data protection (refer to “[The DataProtectionClass Entitlement](ch13.html#ch13lev2sec08)”
    on [page 223](ch13.html#page_223)), which will apply a default protection level
    ubiquitously for all data written to disk by the application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，iOS 通过数据保护 API 提供安全存储（如我在[第13章](ch13.html#ch13)中描述的），这些 API 需要特定的参数，这些参数不适合跨平台实现。因此，Cordova
    不支持这些 API，从而无法精细控制何时对文件数据进行加密存储。为了解决这个问题，您可以启用权限级别的数据保护（参考[“DataProtectionClass
    Entitlement”](ch13.html#ch13lev2sec08)和[第223页](ch13.html#page_223)），这将为应用程序写入磁盘的所有数据应用一个默认的保护级别。
- en: Another common issue is the lack of a similar secure storage element across
    platforms. This removes direct Keychain access on iOS, although Adobe ultimately
    developed an open source plug-in^([6](footnote.html#fn82)) to address the problem.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见问题是缺乏跨平台的类似安全存储元素。这意味着在 iOS 上无法直接访问 Keychain，尽管 Adobe 最终开发了一个开源插件^([6](footnote.html#fn82))
    来解决这个问题。
- en: That ends the tour of `UIWebView` and JavaScript bridges, but new applications
    (for iOS 8 and newer) will increasingly be using the `WKWebView` API. I’ll cover
    how to wrangle `WKWebView` in the following section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `UIWebView` 和 JavaScript 桥接的全部内容，但新的应用程序（针对 iOS 8 及更新版本）将越来越多地使用 `WKWebView`
    API。我将在接下来的章节中介绍如何处理 `WKWebView`。
- en: '**Enter WKWebView**'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**引入 WKWebView**'
- en: As I mentioned previously, a newer interface to WebKit was introduced with iOS
    8 to supplant `UIWebView`. `WKWebView` addresses several of the shortcomings of
    `UIWebView`, including access to the Nitro JavaScript engine, which greatly increases
    performance on JavaScript-heavy tasks. Let’s look at how apps would create `WKWebView`s
    and how `WKWebView`s can improve your app’s security.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，iOS 8 引入了一个新的 WebKit 接口来替代 `UIWebView`。`WKWebView` 解决了 `UIWebView` 的几个缺点，包括访问
    Nitro JavaScript 引擎，这大大提高了 JavaScript 密集型任务的性能。让我们来看一下应用程序如何创建 `WKWebView`，以及
    `WKWebView` 如何提升应用程序的安全性。
- en: '***Working with WKWebViews***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***与 WKWebView 的互动***'
- en: 'A `WKWebView` is instantiated in essentially the same way as a `UIWebView`,
    as shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`WKWebView` 的实例化方式与 `UIWebView` 基本相同，如下所示：'
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This just allocates a new `WKWebView` instance and then initializes it with
    the `initWithFrame` method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅分配了一个新的 `WKWebView` 实例，然后通过 `initWithFrame` 方法对其进行初始化。
- en: To customize behavior, `WKWebView`s can also be instantiated with user-supplied
    JavaScript, as in [Listing 9-10](ch09.html#ch9ex10). This allows you to load a
    third-party website but with your own custom JavaScript that executes upon page
    load.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要自定义行为，`WKWebView` 还可以通过用户提供的 JavaScript 来实例化，如 [示例 9-10](ch09.html#ch9ex10)
    中所示。这允许你加载一个第三方网站，同时执行你自己自定义的 JavaScript 脚本。
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 9-10: Instantiating a* `WKWebView` *with custom JavaScript*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-10：带自定义 JavaScript 的* `WKWebView` *实例化*'
- en: At ➊, a simple `NSString` that consists of a single JavaScript command is created.
    At ➋, a configuration object is created that will hold the configuration parameters
    for the web view that will be created later. At ➌, a `WKUserScript` object is
    created and initialized with the `src` that contains the JavaScript you want to
    execute. Then a `WKUserContentController` is made at ➍, which is set in the configuration
    object at ➎. Finally, the script is added to the controller with the `addUserScript`
    method at ➏, and the web view is instantiated at ➐.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，创建了一个由单一 JavaScript 命令组成的简单 `NSString`。在 ➋ 处，创建了一个配置对象，用于保存稍后创建的 Web 视图的配置参数。在
    ➌ 处，创建并初始化了一个 `WKUserScript` 对象，该对象的 `src` 包含你希望执行的 JavaScript。然后，在 ➍ 处创建了一个 `WKUserContentController`，并在
    ➎ 处将其设置到配置对象中。最后，在 ➏ 处通过 `addUserScript` 方法将脚本添加到控制器中，并在 ➐ 处实例化 Web 视图。
- en: '**NOTE**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As with other methods of injecting JavaScript, be careful not to interpolate
    content provided by third parties without strict sanitization.*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*与其他注入 JavaScript 的方法一样，务必小心不要在没有严格清理的情况下插入第三方提供的内容。*'
- en: '***Security Benefits of WKWebViews***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***WKWebView 的安全优势***'
- en: Using `WKWebView`s has a couple security advantages. First, you can set preferences
    that disable loading JavaScript with the method `setJavaScriptEnabled` if the
    pages you plan to load don’t require it; if the remote site has malicious script,
    this will prevent that script from executing. You can also leave JavaScript enabled
    but disable the opening of new windows from JavaScript using the `setJavaScriptCanOpenWindowsAutomatically`
    method—this will prevent most pop-ups from opening, which can be quite irritating
    in web views.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `WKWebView` 有几个安全优势。首先，如果你计划加载的页面不需要 JavaScript，可以通过 `setJavaScriptEnabled`
    方法禁用加载 JavaScript；如果远程站点包含恶意脚本，这将防止该脚本执行。你还可以启用 JavaScript，但通过 `setJavaScriptCanOpenWindowsAutomatically`
    方法禁用从 JavaScript 打开新窗口——这样可以防止大多数弹出窗口，这在 Web 视图中非常烦人。
- en: Lastly, and perhaps most importantly, you can actually detect whether the contents
    of the web view were loaded over HTTPS, giving you the ability to ensure that
    no parts of the page were loaded over insecure channels. For `UIWebView`s, there
    is no indication to the user or developer when the web view loads mixed content—the
    `hasOnlySecureContent` method of `WKWebView` resolves this problem. [Listing 9-11](ch09.html#ch9ex11)
    shows a way to implement a somewhat hardened `WKWebView`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可能最重要的一点是，你实际上可以检测 Web 视图的内容是否通过 HTTPS 加载，从而确保页面的任何部分都没有通过不安全的渠道加载。对于 `UIWebView`，当
    Web 视图加载混合内容时，用户或开发者并不会收到任何提示——而 `WKWebView` 的 `hasOnlySecureContent` 方法解决了这个问题。[示例
    9-11](ch09.html#ch9ex11)展示了一种实现相对安全的 `WKWebView` 的方法。
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 9-11: A nice, safe* `WKWebView`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-11：一个安全的* `WKWebView`'
- en: This code uses a couple of extra security mechanisms that `WKWebView` provides.
    At ➊, a `WKPreferences` instance is instantiated, and the `setJavaScriptEnabled`
    and `setJavaScriptCanOpenWindowsAutomatically` properties are set on it. (These
    are redundant, of course, but you can pick whichever property best suits your
    needs.) Then, a `WKWebViewConfiguration` object is instantiated at ➋ and the `WKPreferences`
    already created are passed in. At ➌, a URL to load is defined; in this case, it’s
    simply an example page that includes mixed content. At ➍, the `WKWebView` itself
    is made, using the configuration created previously. The code then requests that
    the web view load a given URL at ➎. Finally, the `didFinishNavigation` delegate
    is implemented at ➏, which in turn calls `hasOnlySecureContent` on the web view.
    If the content is mixed, the user is alerted.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了`WKWebView`提供的几个额外安全机制。在 ➊ 处，实例化了一个 `WKPreferences` 实例，并设置了 `setJavaScriptEnabled`
    和 `setJavaScriptCanOpenWindowsAutomatically` 属性。（当然，这些是多余的，你可以选择最适合你需求的属性。）然后，在
    ➋ 处实例化了一个 `WKWebViewConfiguration` 对象，并传入之前创建的 `WKPreferences`。在 ➌ 处，定义了要加载的 URL；在这个例子中，它只是一个包含混合内容的示例页面。在
    ➍ 处，使用之前创建的配置生成了 `WKWebView` 实例。然后，代码请求在 ➎ 处加载给定的 URL。最后，在 ➏ 处实现了 `didFinishNavigation`
    委托方法，该方法随后调用了网页视图的 `hasOnlySecureContent`。如果内容是混合的，用户会收到警告。
- en: '**Closing Thoughts**'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结思考**'
- en: While modern versions of iOS have made great strides in allowing developers
    control over the interactions between native code and web content, there is a
    legacy of hacks to bridge the two, with their own idiosyncrasies. At this point,
    you should be aware of the main bridging mechanisms, as well as where to look
    for potentially malicious externally supplied data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现代版本的 iOS 在允许开发者控制原生代码和网页内容之间的交互方面取得了很大进展，但仍存在一些遗留的黑客方式来桥接这二者，并且这些方式各有其独特性。此时，你应该了解主要的桥接机制，以及在哪里寻找潜在的恶意外部提供数据。
- en: I also briefly covered some of the caching that takes place when working with
    web content. In [Chapter 10](ch10.html#ch10), you’ll dig in to the many ways that
    data can leak to the local filesystem and be recovered by attackers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我还简要介绍了在处理网页内容时发生的一些缓存。在 [第10章](ch10.html#ch10)中，你将深入探讨数据如何泄露到本地文件系统，并被攻击者恢复的多种方式。
