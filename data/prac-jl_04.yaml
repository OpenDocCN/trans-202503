- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3'
- en: MODULES AND PACKAGES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模块与包**
- en: '*Information about the package is as important as the package itself.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关包的信息和包本身同样重要。*'
- en: '*—*Frederick W. Smith, founder of FedEx'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*—*FedEx创始人弗雷德里克·W·史密斯'
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In the previous chapter, I mentioned that Julia programs are organized around
    collections of functions. The functions are the verbs of your program, meaning
    they describe what it does. You could spend your whole Julia programming life
    working in the REPL or in Pluto while saving programs in files using nothing more
    than function, variable, and data type definitions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我提到过，Julia 程序是围绕一组函数组织的。这些函数是程序的动词，意味着它们描述了程序的功能。你可以在 REPL 或 Pluto 中度过一生，保存程序文件，仅使用函数、变量和数据类型定义。
- en: But when it comes time to develop projects that build on your previous work
    systematically, or to allow other people to use your code in their projects, you
    will want to take advantage of the structures Julia provides to organize and share
    your programs. Even if you never reuse or distribute your own code, you will use
    code from the Julia standard library, from other official Julia packages, and
    perhaps from other researchers. In any case, familiarity with Julia’s module and
    package system is essential.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当你开始系统地开发基于之前工作的项目，或者希望其他人能够在他们的项目中使用你的代码时，你将希望利用 Julia 提供的结构来组织和共享你的程序。即使你从未重用或分发过自己的代码，你仍然会使用
    Julia 标准库中的代码，使用其他官方 Julia 包中的代码，甚至可能使用其他研究者的代码。无论如何，熟悉 Julia 的模块和包系统至关重要。
- en: '**Modules**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**模块**'
- en: Julia programmers make liberal use of modules both in the REPL and in program
    files, and borrowing existing facilities for plotting, solving equations, serving
    websites, and countless other activities is routine. *Creating* modules, however,
    is of little use in the REPL. The modules you create will live in files, ready
    to be used as needed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 程序员在 REPL 和程序文件中广泛使用模块，借用现有的绘图、解方程、提供网站服务以及无数其他活动的功能已经成了常规操作。然而，*创建*模块在
    REPL 中并没有多大用处。你创建的模块将保存在文件中，随时准备根据需要使用。
- en: '***Understanding Namespaces***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***理解命名空间***'
- en: A *namespace* is a grouping for names that distinguishes them from identical
    names existing in other groups. We need namespaces because functions and variables
    may be defined in different places but happen to have identical names, and we
    need a way to make it clear which object we are referring to.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*命名空间*是用于分组名称的方式，它将这些名称与其他组中存在的相同名称区分开来。我们需要命名空间，因为函数和变量可能在不同地方定义，但名称恰好相同，我们需要一种方法来明确我们所引用的是哪个对象。'
- en: 'When we define an object in the REPL we can refer to it later with its name.
    For example, after an assignment such as `a = 1`, the variable `a` will return
    `1`. We say that `a` is defined in the *global namespace*. The terminology varies:
    sometimes it’s *top-level namespace* and sometimes *main namespace*. In any case,
    the *current namespace* is the one in which we’re working.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 REPL 中定义一个对象时，我们可以稍后通过它的名称引用它。例如，在进行像`a = 1`这样的赋值操作后，变量`a`将返回`1`。我们说`a`是在*全局命名空间*中定义的。术语有所不同：有时它被称为*顶级命名空间*，有时称为*主命名空间*。无论如何，*当前命名空间*是我们正在使用的命名空间。
- en: When we need to refer to objects defined elsewhere, we have two options. We
    can call them by their unadorned names, as if they had been defined in the current
    namespace, or we can refer to them with a name such as `SomeModule.a`. In the
    latter case, we say that `a` is in the `SomeModule` namespace, and we have used
    a *qualified name* for it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要引用在其他地方定义的对象时，我们有两种选择。我们可以通过它们的简单名称来调用它们，就好像它们在当前命名空间中定义过一样，或者我们可以通过像`SomeModule.a`这样的名称来引用它们。在后者的情况下，我们说`a`位于`SomeModule`命名空间中，我们使用了*限定名称*来引用它。
- en: The two names `SomeModule.a` and `a` can refer to different objects—perhaps
    even to different types of objects. The identifier `a` might be a variable that
    we’ve defined in the REPL, and `SomeModule.a` might be a function defined in the
    `SomeModule` module. In the next section, we’ll learn how objects from other modules
    sometimes wind up in our current namespace and when we need to use qualified names
    to refer to them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个名称`SomeModule.a`和`a`可以指代不同的对象——甚至可能是不同类型的对象。标识符`a`可能是我们在 REPL 中定义的一个变量，而`SomeModule.a`可能是`SomeModule`模块中定义的一个函数。在接下来的章节中，我们将学习如何从其他模块中引入对象，何时需要使用限定名称来引用它们。
- en: '***Using Installed Modules***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用已安装的模块***'
- en: A Julia installation comes with many modules ready for use. The resources in
    two particular modules, `Base` and `Core`, are always automatically available,
    which is why we can invoke the functions that we used in the previous chapter,
    such as `abs()`, without loading anything explicitly. Most of these essential
    functions are in the `Base` module. `Base` also supplies such basics as the `+`
    operator, which is also a function under the hood. The `Core` module exists at
    an even deeper level and contains such foundation stones as the `Int64` data type.
    Although you can’t do much without `Base`, you can arrange for it to not be loaded.
    The small `Core` module is necessary for Julia to work, however, so it’s not optional.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Julia安装时自带许多模块可供使用。特别是`Base`和`Core`这两个模块中的资源总是自动可用的，这也是为什么我们可以直接调用前一章中使用的函数，如`abs()`，而无需显式加载任何内容。这些基本函数大多位于`Base`模块中。`Base`还提供了一些基础功能，如`+`运算符，实际上也是一个函数。`Core`模块存在于更深层次，包含了一些基础构件，如`Int64`数据类型。虽然没有`Base`你无法做太多事情，但你可以安排不加载它。然而，`Core`模块对Julia的运行是必需的，因此不可省略。
- en: The *standard library* is a collection of modules that’s always installed with
    Julia but that you need to load explicitly to be able to use. The modules in the
    standard library provide functionality that is commonly needed across a variety
    of computations, but that is less fundamental than, for example, the arithmetic
    operators. You will never need everything in the standard library in any particular
    program, but a typical program will make use of several of its modules.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*标准库*是一个总是与Julia一起安装的模块集合，但你需要显式加载它们才能使用。标准库中的模块提供了在各种计算中常用的功能，但这些功能的基础性不如算术运算符等。你在任何特定的程序中都不需要标准库中的所有模块，但一个典型的程序会使用其中几个模块。'
- en: You can load the resources in a module with either the `using` or `import` statements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`using`或`import`语句加载模块中的资源。
- en: '**NOTE**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Most modules have uppercase initials and use “camel case” for their names,
    such as* LinearAlgebra *from the standard library. Although you’re free to ignore
    such naming conventions (including the use of ! explained in [“Functions That
    Mutate Their Arguments](ch02.xhtml#ch02lev1sec17)” on [page 56](ch02.xhtml#ch02lev1sec17))
    in your own projects, following them will make your code easier to read for other
    Julia programmers.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*大多数模块的名称首字母为大写，并采用“驼峰命名法”，例如* LinearAlgebra *模块来自标准库。虽然你可以在自己的项目中忽略这种命名约定（包括在[《改变参数的函数》](ch02.xhtml#ch02lev1sec17)中解释的使用!符号，[第56页](ch02.xhtml#ch02lev1sec17)），但遵循这些约定会让你的代码更容易被其他Julia程序员阅读。*'
- en: The `using` statement provides access to everything in the module. It brings
    all the names that the module creator has marked for export into the current namespace.
    So, for example, after executing `using Plots`, we can use the `plot()` function
    directly, as in `plot(x -> x^2)`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`语句提供对模块中所有内容的访问。它将模块创建者标记为导出的所有名称引入当前命名空间。因此，例如，在执行`using Plots`之后，我们可以直接使用`plot()`函数，如`plot(x
    -> x^2)`。'
- en: We can use any name that we know of, however, even if it’s not exported. Julia
    has no secrets. Prefix the unexported name with the name of the module and a dot.
    For example, `Plots.surface(x, y, f)` will work regardless of whether `surface`
    is exported. In this case, we are invoking `surface` in the `Plots` namespace.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用任何已知的名称，即使它没有被导出。Julia没有秘密。只需将未导出的名称与模块名和点符号组合。例如，`Plots.surface(x,
    y, f)`无论`surface`是否被导出都能正常工作。在这种情况下，我们是在调用`Plots`命名空间中的`surface`。
- en: The other way to use resources from other modules involves the `import` statement.
    The only difference between `import` and `using` has to do with how we use names.
    If we execute `import Plots`, `Plots.surface(x, y, f)` will work, but just using
    `surface(x, y, f)` will not. The `import` statement provides access to everything
    in the module, just as `using` does, but *not in the current namespace*. You must
    use the module’s namespace.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使用其他模块资源的方式是`import`语句。`import`和`using`的唯一区别在于我们如何使用名称。如果执行`import Plots`，则`Plots.surface(x,
    y, f)`将正常工作，但直接使用`surface(x, y, f)`则不行。`import`语句提供对模块中所有内容的访问，和`using`一样，但*不会在当前命名空间中提供*。你必须使用模块的命名空间。
- en: 'You can use either statement with a list of modules separated by commas: `using
    *Module1, Module2, Module3*`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用带有逗号分隔的模块列表的语句：`using *Module1, Module2, Module3*`。
- en: 'To show the difference between the `using` and `import` statements, we’ll use
    two modules from the standard library: the `LinearAlgebra` module, which contains
    functions for solving sets of linear equations, inverting matrices, and other
    linear algebra operations, and `Random`, which provides random number functions.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示`using`和`import`语句的区别，我们将使用两个来自标准库的模块：`LinearAlgebra`模块，它包含用于解线性方程组、求逆矩阵和其他线性代数操作的函数，以及`Random`模块，它提供随机数函数。
- en: '[Listing 3-1](ch03.xhtml#ch3lis1) uses some functions from the standard library.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-1](ch03.xhtml#ch3lis1)使用了一些来自标准库的函数。'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 3-1: Two ways to import a module*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-1：导入模块的两种方式*'
- en: The first two lines make the resources from the two standard library modules
    available in the rest of the program. The difference between the `using` and `import`
    statements is in how we refer to those resources.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行使得来自两个标准库模块的资源在程序的其他部分可用。`using`和`import`语句之间的区别在于我们如何引用这些资源。
- en: The `using LinearAlgebra` statement allows us to use all of the *exported names*
    from this module directly. The exported names are those that appear in an `export`
    statement in the module. We can use the `dot()` function ➋, which computes the
    dot product of two vectors, directly, because it’s exported by `LinearAlgebra`,
    and the `using LinearAlgebra` statement pulled it into the current namespace.
    (The dot product of [*a*, *b*] and [*c*, *d*] is *ac*+*bd*.) We can refer to the
    function using `LinearAlgebra.dot()` as well; the two names refer to the same
    object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`using LinearAlgebra`语句允许我们直接使用该模块中所有的*导出名称*。导出名称是那些出现在模块的`export`语句中的名称。我们可以直接使用`dot()`函数
    ➋，它计算两个向量的点积，因为它是由`LinearAlgebra`导出的，而`using LinearAlgebra`语句将其引入当前命名空间。（[ *a*,
    *b* ]和[ *c*, *d* ]的点积是*ac*+*bd*。）我们也可以通过`LinearAlgebra.dot()`来引用这个函数；这两个名称指向相同的对象。'
- en: '**NOTE**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Sometimes* import *and* using *statements incur significant delays. Julia
    is precompiling some functions in the module to make their use more efficient.*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*有时*，`import`和`using`语句会引起显著的延迟。Julia正在预编译模块中的一些函数，以提高它们的使用效率。'
- en: 'The other way to use resources from other modules involves the `import` statement,
    as we used in the second line: `import Random`. The only difference between `import`
    and `using` has to do with the use of names. Since we *imported* `Random`, to
    use its functions we must prefix them with the name of the module ➌.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使用其他模块资源的方法涉及`import`语句，正如我们在第二行中使用的那样：`import Random`。`import`和`using`之间的唯一区别在于名称的使用。由于我们*导入了*`Random`，为了使用它的函数，我们必须在函数名前加上模块的名称
    ➌。
- en: If we pull in a module with `using` and already have some of its names defined
    in our program, Julia will print a warning. The next section describes other ways
    to handle this problem.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`using`引入一个模块，并且程序中已经定义了该模块的一些名称，Julia会打印一个警告。下一节将描述如何处理这个问题的其他方法。
- en: We use the `import` statement when we have names that happen to be the same
    within more than one module or that are identical in an imported module and in
    our program. The use of module namespaces will remove the ambiguity. For example,
    our program has our own `randexp()` function, which is different from the one
    supplied by the `Random` module. It returns `17`, which I chose at random when
    I wrote the function, hence the name.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在多个模块中存在相同名称，或在导入的模块和程序中存在相同名称时，我们使用`import`语句。模块命名空间的使用将消除歧义。例如，我们的程序有我们自己的`randexp()`函数，它与`Random`模块中的函数不同。它返回`17`，这是我在编写函数时随机选择的，因此命名为`randexp`。
- en: After the definition of `randexp()` ➊, we define two vectors, `a` and `b`. We
    calculate their dot product using the `dot()` function, which is exported by `LinearAlgebra`,
    and pipe its output to `println()` so we can see it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义`randexp()` ➊之后，我们定义了两个向量`a`和`b`。我们使用由`LinearAlgebra`导出的`dot()`函数计算它们的点积，并将其输出传递给`println()`以便我们查看结果。
- en: The next line calls the `randexp()` function from `Random` and prints the result.
    This function returns a number randomly selected from the exponential distribution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行调用了`Random`中的`randexp()`函数并打印结果。这个函数从指数分布中随机选择一个数字。
- en: 'Finally we call `randexp()` ➍ from the program’s global namespace and print
    the result: `17`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从程序的全局命名空间调用`randexp()` ➍并打印结果：`17`。
- en: 'Here is the output from one run of the program:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序运行的一次输出：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you run it, the second number will be different because it’s randomly generated
    (see “Random Numbers in Julia” on [page 307](ch10.xhtml#ch10lev2)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，第二个数字将会不同，因为它是随机生成的（请参阅[第 307 页](ch10.xhtml#ch10lev2)上的“Julia中的随机数”）。
- en: '***Selective Importing and Renaming***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***选择性导入和重命名***'
- en: So far we’ve seen two Julia statements, each of which allows a program to refer
    to objects defined elsewhere. Both statements give access to everything in the
    target module, but differ in how we refer to the module’s objects.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过两条 Julia 语句，每条语句都允许程序引用在其他地方定义的对象。两者都可以访问目标模块中的所有内容，但在引用模块对象的方式上有所不同。
- en: We can supplement either command with specifications that provide more control.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任意一条命令后添加更多控制选项来进行补充。
- en: The `as` keyword lets us pick a name to use for the module within our program.
    If we change the second line in [Listing 3-1](ch03.xhtml#ch3lis1) to `import Random
    as Rnd`, we need to change the line that uses it to `Rnd.randexp() |> println`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`as` 关键字允许我们为程序中的模块选择一个名称。如果我们将[清单 3-1](ch03.xhtml#ch3lis1)中的第二行改为 `import
    Random as Rnd`，我们需要将使用它的那一行改为 `Rnd.randexp() |> println`。'
- en: 'We can append a colon to the module name to limit the import to only specified
    objects. Optionally, we can use the `as` keyword to rename those objects to names
    of our choosing. These methods can serve to avoid conflicts with existing names.
    Here is [Listing 3-1](ch03.xhtml#ch3lis1) with some modifications:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在模块名后加上冒号，以将导入限制为仅指定的对象。可选地，我们可以使用 `as` 关键字将这些对象重命名为我们选择的名称。这些方法可以避免与现有名称发生冲突。以下是经过一些修改的[清单
    3-1](ch03.xhtml#ch3lis1)：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This program has the same results as the previous version, but the `import`
    statement ➊ imports only the `randexp()` function from `Random` and renames it
    as `rrexp()`. When we call it ➋, we have to use its alias because its original
    name, `randexp()`, is unknown in its current environment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的结果与之前的版本相同，但 `import` 语句 ➊ 仅从 `Random` 导入 `randexp()` 函数，并将其重命名为 `rrexp()`。当我们调用它时
    ➋，必须使用其别名，因为原始名称 `randexp()` 在当前环境中无法识别。
- en: '***Creating Modules***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建模块***'
- en: In Julia, there is no relationship between modules and files or between filenames
    and module names. A file can contain any number of modules, and a module may be
    split among many files.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，模块和文件之间没有直接关系，也没有文件名与模块名之间的关系。一个文件可以包含多个模块，而一个模块可以分布在多个文件中。
- en: 'We define a module in a program file using the `module` keyword. This begins
    a structure that resembles a block and is terminated with the `end` keyword, but
    is different from the blocks described in [Chapter 2](ch02.xhtml). Because it’s
    common for entire files to comprise the contents of a module, the conventional
    style does not indent module bodies. Such a practice would lead to uselessly indenting
    most of the file. Another distinction concerns scope: variables defined within
    a module, but outside any of the blocks that define local scopes, are global to
    the module. Each module has its own global scope, so a file with more than one
    module has more than one such scope.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `module` 关键字在程序文件中定义一个模块。它开始一个类似于块结构的内容，并以 `end` 关键字结束，但与[第 2 章](ch02.xhtml)中描述的块不同。因为整个文件通常由一个模块的内容组成，所以惯用的风格是不对模块体进行缩进。这样做会导致大部分文件被无意义地缩进。另一个区别是作用域：在模块内定义的变量，但不在任何定义局部作用域的块内定义，都是模块的全局变量。每个模块都有自己的全局作用域，因此一个包含多个模块的文件会有多个这样的作用域。
- en: 'As an example, let’s begin with a simple case: [Listing 3-2](ch03.xhtml#ch3lis2)
    is a small program containing two modules, with everything contained within a
    single file.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们从一个简单的例子开始：[清单 3-2](ch03.xhtml#ch3lis2) 是一个小程序，包含两个模块，所有内容都在一个文件中。
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 3-2: A program containing two modules*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-2：一个包含两个模块的程序*'
- en: This program defines two modules, `M1` and `M2`. Each module defines one function,
    which it lists in an `export` statement. Usually `export` lines go near the top
    of the module, but they can appear anywhere. Running the program prints `100`
    twice.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序定义了两个模块，`M1` 和 `M2`。每个模块定义一个函数，并在 `export` 语句中列出它。通常，`export` 语句放在模块的顶部，但它们可以出现在任何地方。运行该程序会打印
    `100` 两次。
- en: 'The `using` statement ➊ brings the exported names of the two modules into the
    global namespace of the file. The dots in front of the module names mean that
    we are referring to modules defined *within the current module*. But it doesn’t
    appear as if we’re in a “current module”: the statement is simply at the top level
    of the file.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`语句 ➊ 将两个模块的导出名称引入到文件的全局命名空间中。模块名称前的点表示我们引用的是*当前模块内*定义的模块。但是看起来我们并不在一个“当前模块”中：语句只是出现在文件的顶层。'
- en: We’re always in a module in Julia. The top-level module is automatically called
    `Main` if we don’t name it ourselves, so `M1` and `M2` are modules within the
    `Main` module.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，我们总是在一个模块中。顶级模块如果我们没有自己命名，则默认叫做`Main`，所以`M1`和`M2`是`Main`模块中的模块。
- en: If we had used `import` rather than `using`, we would have been obliged to mention
    the module namespaces when invoking their functions. Although we need to use the
    dot when importing to indicate *where* the module is, its names are still given
    in the `module` statements. For example, the `plusone()` function is `M1.plusone()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是`import`而非`using`，那么在调用函数时就必须提到模块命名空间。虽然在导入时需要使用点来表示*模块的位置*，但是其名称仍然是在`module`语句中给出的。例如，`plusone()`函数是`M1.plusone()`。
- en: Dots in module import statements have a significance similar to their use in
    directory names in Unix-like operating systems. Single dots refer to the current
    “directory,” or module, and a double dot goes up one level to the enclosing module.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 模块导入语句中的点，类似于在类Unix操作系统中目录名称中的使用，有着相似的意义。单个点表示当前的“目录”或模块，而双点则表示向上一级目录查找，即封装模块。
- en: '[Listing 3-3](ch03.xhtml#ch3lis3) shows an example.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 3-3](ch03.xhtml#ch3lis3)展示了一个示例。'
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 3-3: Relative module imports*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 3-3：相对模块导入*'
- en: 'We’ve moved the definition of module `M2` inside `M1` ➊. Within `M2` we import
    `M1` ➋, which is now a *sibling module*: the double dot tells Julia to go up one
    level before looking for `M1`. After this `using` statement, `plusone()` is available
    within `M2`, so we can call it directly within the `println()` statement.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将`M2`模块的定义移到`M1`内 ➊。在`M2`内，我们导入`M1` ➋，现在`M1`是一个*兄弟模块*：双点告诉Julia在查找`M1`之前要向上一级。此`using`语句之后，`plusone()`在`M2`内可用，因此我们可以在`println()`语句中直接调用它。
- en: Back in the top level, which is the `Main` module, we again want to import every
    exported name from `M1` and `M2` into the global namespace, but now we need to
    specify that `M2` is within `M1` ➌.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 回到顶层，也就是`Main`模块，我们再次想要将`M1`和`M2`中导出的每个名称导入到全局命名空间中，但这次我们需要指定`M2`是在`M1`内 ➌。
- en: This program prints `201` followed by the same output as the previous example
    in [Listing 3-2](ch03.xhtml#ch3lis2).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序打印出`201`，随后输出与[Listing 3-2](ch03.xhtml#ch3lis2)中的示例相同的内容。
- en: If we simply want to insert the contents of a file into the current file, we
    use the `include()` statement with a string argument giving the file’s pathname.
    This is equivalent to pasting the file’s contents at the location of the `include()`
    statement. It doesn’t use any of the module namespacing machinery, pulling objects
    in the included file into the module’s namespace. Using file inclusion, we can
    split large modules among different files, helping to keep our code organized.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仅仅想将文件的内容插入到当前文件中，我们使用`include()`语句，并给出文件路径作为字符串参数。这等同于将文件内容粘贴到`include()`语句所在的位置。它不会使用任何模块命名空间机制，而是将包含的文件中的对象引入到模块的命名空间中。使用文件包含功能，我们可以将大型模块拆分到不同的文件中，有助于保持代码的组织性。
- en: '***Documenting Functions with Docstrings***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用文档字符串记录函数***'
- en: The previous chapter described how to use the REPL’s help system to get information
    about functions. We can document our own functions so that the help system can
    provide nicely formatted information about them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章描述了如何使用REPL的帮助系统来获取函数信息。我们可以为自己的函数编写文档，以便帮助系统提供格式化良好的信息。
- en: 'Place a string literal immediately before the beginning of any function definition
    to document it, creating what’s called a *docstring*. The help system, as well
    as any other Julia documentation system, will associate this string with the function,
    and format and display it when the user asks for help. Here is a somewhat silly
    example, where I added some help text to [Listing 3-3](ch03.xhtml#ch3lis3) to
    document the `plusone()` function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何函数定义前面放置一个字符串字面量来进行文档注释，这样就创建了所谓的*文档字符串*。帮助系统以及其他任何Julia文档系统将会把这个字符串与函数关联起来，并在用户请求帮助时格式化并显示它。这里是一个有些傻的例子，我为[Listing
    3-3](ch03.xhtml#ch3lis3)中的`plusone()`函数添加了一些帮助文本来进行文档注释：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example I use the triple-quoted string syntax explained on [page 45](ch02.xhtml#page_45)
    to conveniently embed newlines and other characters without needing to escape
    them. Most help strings are written this way.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我使用了[第 45 页](ch02.xhtml#page_45)上解释的三引号字符串语法，方便地嵌入换行符和其他字符，而不需要转义它们。大多数帮助字符串都是这样写的。
- en: '**MARKDOWN IN DOCSTRINGS**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档字符串中的 MARKDOWN**'
- en: 'The documentation system understands a version of Markdown syntax and will
    format the output appropriately. Markdown is a simplified system of text markup
    where you can specify italics, boldface, and code using underscore, double underscore,
    and backtick delimiters, with asterisks accepted as alternatives to underscores.
    A blank line starts a new paragraph, and indenting text by four spaces sets it
    as code. Lines beginning with hash marks are not comments, as in Julia code, but
    become headings: `# Heading`, `##` `Subheading`, and so on.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 文档系统理解一种版本的 Markdown 语法，并会相应地格式化输出。Markdown 是一种简化的文本标记系统，你可以使用下划线、双下划线和反引号分隔符来指定斜体、粗体和代码，星号也可以作为下划线的替代符。空白行开始新段落，文本前四个空格缩进表示代码块。以井号开头的行不是评论（如同
    Julia 代码中的做法），而是作为标题：`# 标题`、`## 子标题`，依此类推。
- en: The example demonstrates some of the documentation conventions the Julia community
    uses. Begin the help text with the function signature, followed by an imperative
    statement of what the function does. After that can come more explanation and
    examples.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了 Julia 社区使用的一些文档约定。帮助文本从函数签名开始，接着是对函数功能的命令式说明。之后可以添加更多解释和示例。
- en: '[Figure 3-1](ch03.xhtml#ch3fig1) is a screenshot of a REPL session where I
    included the *modutst.jl* file.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](ch03.xhtml#ch3fig1)是一个 REPL 会话的截图，其中我包含了*modutst.jl* 文件。'
- en: '![Image](../images/ch03fig01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch03fig01.jpg)'
- en: '*Figure 3-1: Using the documentation system*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：使用文档系统*'
- en: In the REPL, the `println()` statements are run and produce the output shown
    previously. I pressed `?` to enter help mode and typed the name of the function.
    After showing the results of a fuzzy search on the name, the REPL renders the
    docstring of the most likely choice. The terminal REPL renders code using a contrasting
    color and italics with an underline. Other environments may use different typography.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 中，`println()` 语句被执行并产生先前显示的输出。我按了 `?` 进入帮助模式并输入了函数的名称。在显示名称的模糊搜索结果后，REPL
    会呈现最可能的选择的文档字符串。终端 REPL 使用对比颜色并将代码以斜体和下划线呈现。其他环境可能使用不同的排版。
- en: For more details about Markdown formatting, see “Further Reading” on [page 81](ch03.xhtml#fur3).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Markdown 格式化的更多详细信息，请参见[第 81 页](ch03.xhtml#fur3)的“进一步阅读”部分。
- en: We’ve learned how to reference modules defined in the current file using dots
    and extend the current file using `include()`. Before that, we were loading external
    modules with the same `using` and `import` statements, but with no dots in front
    of the module names. Somehow in those cases, Julia knew where to find the files
    containing the module definitions, and that is the subject of the next section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用点（.）引用当前文件中定义的模块，并通过 `include()` 扩展当前文件。之前，我们通过相同的 `using` 和 `import`
    语句加载外部模块，但模块名前没有点。在那些情况下，Julia 以某种方式知道在哪里找到包含模块定义的文件，这也是下一节的主题。
- en: '**The Package System**'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**包系统**'
- en: The most convenient way to interact with Julia’s package system is with the
    REPL’s package mode. Press `]` to enter and BACKSPACE to exit this mode.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Julia 的包系统交互的最方便方式是使用 REPL 的包模式。按 `]` 进入该模式，按 BACKSPACE 退出该模式。
- en: Enter the package mode and have another look at the prompt. It looks something
    like `(@v1.8) pkg>`, where `v1.8` shows the currently installed Julia version.
    The part within the parentheses informs us of our current *environment*. We are
    always in some environment in the REPL. The environment is the project to which
    the package mode applies its commands.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 进入包模式后，再看看提示符。它看起来像 `(@v1.8) pkg>`，其中 `v1.8` 显示当前安装的 Julia 版本。括号内的部分告诉我们当前的*环境*是什么。我们总是在
    REPL 中的某个环境中。环境是包模式应用其命令的项目。
- en: When we start the REPL we’re in the default project. Everything we do in the
    package manager applies to that environment, unless we change it with the `activate`
    command.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动 REPL 时，我们位于默认项目中。我们在包管理器中的所有操作都适用于该环境，除非我们通过 `activate` 命令更改它。
- en: Enter activate. to change the environment to the current directory, or activate
    path to change it to a specified path. A simple activate changes to the default
    environment for the version of Julia in use.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 输入activate.可以将环境切换到当前目录，或者输入activate path将其切换到指定路径。简单的activate会切换到正在使用的Julia版本的默认环境。
- en: '***How to Add and Remove Packages***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***如何添加和移除包***'
- en: The most important package command is `add`. To use it, enter add packageName
    from within the REPL’s package mode.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的包命令是`add`。要使用它，请在REPL的包模式中输入add packageName。
- en: 'The `add` command does two things: it downloads and precompiles the latest
    compatible version of the requested package, if it’s not already installed, and
    it records the package as a dependency of the current environment. The second
    step ensures that the set of package versions used in the project can always be
    reproduced, either by its author on a different computer or by a colleague.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`命令做两件事：如果请求的包尚未安装，它会下载并预编译最新的兼容版本；然后它会将该包记录为当前环境的依赖项。第二步确保项目中使用的包版本集可以始终被重现，无论是由作者在不同的计算机上执行，还是由同事执行。'
- en: We will have to `add` any packages that are not in the standard library. This
    includes the vast majority of packages in the Julia ecosystem, such as `Plots`,
    for making scientific graphics, or `BenchmarkTools`, for timing and profiling
    programs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须`add`任何不在标准库中的包。这包括Julia生态系统中的绝大多数包，例如用于制作科学图形的`Plots`，或用于计时和性能分析的`BenchmarkTools`。
- en: If any package previously installed with `add` is no longer needed, we can remove
    it with the `rm` PackageName command, also from within package mode.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前使用`add`安装的包不再需要，我们可以通过`rm` PackageName命令将其移除，同样是在包模式下执行。
- en: The `rm` package mode command deletes a package from the list of direct dependencies
    of your project, but it does not immediately erase any files from the disk. An
    automatic garbage collection process runs periodically, reclaiming disk space
    by purging packages that no other installed package depends on and that haven’t
    been used for over 30 days. To reclaim disk space right away, call the garbage
    collector manually. Detailed instructions are in the package system manual (see
    “Further Reading” on [page 81](ch03.xhtml#fur3)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`rm`包模式命令会从项目的直接依赖列表中删除一个包，但不会立即从磁盘中删除任何文件。一个自动垃圾回收进程会定期运行，通过清除那些没有被任何其他已安装包依赖且超过30天未使用的包来回收磁盘空间。要立即回收磁盘空间，可以手动调用垃圾回收器。详细说明请参见包系统手册（见[第81页](ch03.xhtml#fur3)的“进一步阅读”）。'
- en: '***The Load Path***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加载路径***'
- en: The current environment influences where `using` and `import` look for packages
    and defines the default location for package commands. When executing statements
    like `using Plots` or `import Random` that mention package names without dots,
    Julia looks for the packages in a series of places derived from a vector of strings
    named `LOAD_PATH`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当前环境会影响`using`和`import`查找包的位置，并定义包命令的默认位置。当执行像`using Plots`或`import Random`这样的语句时，Julia会在一系列地方查找包，这些地方来源于一个名为`LOAD_PATH`的字符串向量。
- en: 'We can ask the REPL to show us the default initial value of `LOAD_PATH`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以请求REPL显示`LOAD_PATH`的默认初始值：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The contents of `LOAD_PATH` are clearly not filepaths. They’re a notation that
    the package manager translates into the appropriate paths for the system and installation.
    To see the results of the translation and the current values of the paths, we
    can call the `load_path()` function from `Base`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOAD_PATH`的内容显然不是文件路径。它们是包管理器翻译成系统和安装所需路径的符号。要查看翻译结果和路径的当前值，我们可以从`Base`调用`load_path()`函数：'
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’ve already mentioned that `Base` contains the functions we almost always
    need, but they’re not all exported. Ones that are used infrequently, such as `load_path()`,
    need to be accessed in the `Base` namespace.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过，`Base`包含我们几乎总是需要的函数，但并不是所有函数都被导出。像`load_path()`这样不常用的函数，需要通过`Base`命名空间来访问。
- en: My current load path contains two items. The first is a directory that Julia
    set up when I installed it. It corresponds to my default environment. When I execute
    a command like `add Plots` in the REPL, if I haven’t switched environments with
    the `activate` command, the package manager adds the current version of the `Plots`
    package as a *dependency* in the default *project*. It records the fact that this
    project depends on a particular version of `Plots` being available, and `using
    Plots` will import the functions from that version. This path is the translation
    of the second element in `LOAD_PATH`, `"@v#.#"`. The notation simply means “the
    default environment”; notice how its structure resembles the prompt in package
    mode.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我当前的加载路径包含两个项。第一个是Julia在我安装时设置的一个目录，它对应于我的默认环境。当我在REPL中执行像`add Plots`这样的命令时，如果我没有使用`activate`命令切换环境，包管理器会将`Plots`包的当前版本作为*依赖项*添加到默认的*项目*中。它记录了该项目依赖于某个特定版本的`Plots`可用，并且`using
    Plots`将导入该版本的函数。这个路径是`LOAD_PATH`中第二个元素`"@v#.#"`的翻译。这个符号表示“默认环境”；注意它的结构类似于包模式中的提示符。
- en: 'The package manager records these direct dependencies, the ones specified with
    `add` commands, in the *Project.toml* file. This file contains lines such as:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器将这些直接依赖项，即通过`add`命令指定的依赖项，记录在*Project.toml*文件中。这个文件包含如下内容：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This line shows that the particular version of the `Plots` package, made specific
    with a unique identifier called a *UUID*, is a dependency of the project that
    contains this file—in this case, the default project associated with my installation
    of v1.8 of Julia.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行显示了特定版本的`Plots`包，使用一个名为*UUID*的唯一标识符来指定，它是包含此文件的项目的依赖项——在本例中是与我安装的v1.8版本的Julia相关联的默认项目。
- en: The second path returned by `Base.load_path()` comes from the last element of
    `LOAD_PATH`, which refers to the standard library. As mentioned previously, the
    standard library consists of modules that are part of the Julia installation,
    so they don’t need to be installed with `add`. I left my installation in the download
    folder where my web browser put it, so that’s where its standard library lives.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Base.load_path()`返回的第二个路径来自`LOAD_PATH`的最后一个元素，它指向标准库。如前所述，标准库包含的是Julia安装的一部分模块，因此它们不需要通过`add`命令安装。我把我的安装保留在了浏览器下载文件夹中，所以标准库也就位于那里。'
- en: The `LOAD_PATH` has three elements, but we see only two in its current translation
    by `Base.load_path()`. The first element, which is simply `@`, refers to the *current
    environment*. Julia searches for packages in the order in which they appear in
    `LOAD_PATH`, so it searches the current environment first. To change the current
    environment, execute activate path.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOAD_PATH`有三个元素，但在`Base.load_path()`的当前翻译中我们只看到两个。第一个元素，仅仅是`@`，指的是*当前环境*。Julia会按照它们在`LOAD_PATH`中出现的顺序搜索包，因此它首先会搜索当前环境。要更改当前环境，执行`activate
    path`命令。'
- en: 'The current environment has two purposes: it comes first in the load path,
    so imports of packages will load the versions, if any, that have been added as
    dependencies in the environment, and the package system `add` command inserts
    a dependency there.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当前环境有两个用途：它在加载路径中排在最前面，因此包的导入将加载作为环境依赖项添加的版本（如果有的话），而包管理器的`add`命令会在那里插入一个依赖项。
- en: 'An environment is really nothing more than a place in the filesystem with a
    *Project.toml* file and a *Manifest.toml* file. The latter is a list of the entire
    *dependency graph* of the environment: all the packages that need to be loaded
    to satisfy the dependencies of the ones explicitly `add`ed, with their UUIDs,
    the list of dependencies of each of those dependencies, and so on. If we use the
    `activate` command on a path where there is no existing environment and execute
    one or more `add` commands, Julia will create these two files there and fill them
    with the specified package information.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 环境实际上不过是文件系统中的一个地方，里面包含一个*Project.toml*文件和一个*Manifest.toml*文件。后者是环境的*依赖关系图*的列表：所有需要加载的包，以满足显式`add`命令添加的包的依赖关系，包含它们的UUID、每个依赖项的依赖关系列表，依此类推。如果我们在一个没有现有环境的路径上使用`activate`命令，并执行一个或多个`add`命令，Julia将在该路径下创建这两个文件，并用指定的包信息填充它们。
- en: '**NOTE**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If we can’t use the filenames* Project.toml *or* Manifest.toml *because they
    conflict with another tool, we can use* JuliaProject.toml *and* JuliaManifest.toml
    *instead. If Julia sees either of those files, it will use it and ignore the one
    without the* Julia *prefix.*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我们不能使用文件名* Project.toml *或* Manifest.toml *，因为它们与其他工具冲突，我们可以使用*JuliaProject.toml*和*JuliaManifest.toml*代替。如果Julia发现其中一个文件，它将使用该文件，并忽略没有*Julia*前缀的文件。*'
- en: Environments contain no Julia code, only a list of dependencies. They may document
    a set of consistent modules that work for a particular purpose. For example, after
    using Pluto, we’ll discover that Julia has created an environment alongside the
    normal default environment whose *Project.toml* and *Manifest.toml* files contain
    a list of the modules that Pluto needs to work properly.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 环境不包含任何Julia代码，仅仅是一个依赖列表。它们可能记录了一组为特定目的而工作的模块。例如，在使用Pluto之后，我们会发现Julia在默认环境旁边创建了一个环境，其中的*Project.toml*和*Manifest.toml*文件包含了Pluto正常工作所需的模块列表。
- en: '***The Nature of a Package***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***包的本质***'
- en: I’ve mentioned *package* many times, and have used the term more or less interchangeably
    with *module*, a tradition well established in the Julia documentation. Now let’s
    make the relationship between these concepts precise and explore how packages
    are related to environments.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经多次提到*包*，并且在Julia文档中，通常将这个术语与*模块*互换使用。现在，让我们精确定义这些概念之间的关系，并探讨包是如何与环境相关的。
- en: A package is a Julia module associated with a *Project.toml* file containing
    a few critical pieces of information. The file containing the module and the *Project.toml*
    file must be laid out in the filesystem as shown in [Figure 3-2](ch03.xhtml#ch3fig2).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 包是与*Project.toml*文件相关联的Julia模块，该文件包含一些关键的资讯。包含模块的文件和*Project.toml*文件必须按照[图3-2](ch03.xhtml#ch3fig2)所示的方式在文件系统中排列。
- en: '![Image](../images/ch03fig02.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch03fig02.jpg)'
- en: '*Figure 3-2: The filesystem layout of a package*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-2：包的文件系统布局*'
- en: Alongside the *Project.toml* file is a *src* directory, inside which must be
    the Julia program file, named after the package. Inside this file is the definition
    of a module also named after the package, which in this case is `module` `SomePackage`.
    The structure shown in [Figure 3-2](ch03.xhtml#ch3fig2) is usually placed inside
    a directory also named after the module, *SomePackage* in this case, but that
    is not strictly required.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与*Project.toml*文件一同的是*src*目录，其中必须包含一个以包名命名的Julia程序文件。在这个文件中定义了一个与包同名的模块，在这个例子中是`module`
    `SomePackage`。如[图3-2](ch03.xhtml#ch3fig2)所示的结构通常会放置在一个同样以模块命名的目录中，在这个例子里是*SomePackage*，但这不是强制要求。
- en: For this arrangement to qualify as a package, the *Project.toml* file must provide
    the name of the package, its UUID, its authors, and its version number, in the
    format shown in [Listing 3-4](ch03.xhtml#ch3lis4).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个排列符合包的要求，*Project.toml*文件必须提供包的名称、UUID、作者和版本号，格式如[清单3-4](ch03.xhtml#ch3lis4)所示。
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 3-4: A package’s* Project.toml *file*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单3-4：一个包的*Project.toml* *文件*'
- en: The `name` must match the name of the module defined in *src/Some Package.jl*.
    If we have these two files, one within a *src* directory, we have a package. We
    can think of a package as an environment with a module inside and with these four
    pieces of information in *Project.toml*. In practice, as soon as we add dependencies
    to our package with the `add` command executed within the package’s environment,
    we will also have a *Manifest.toml* file alongside the *Project.toml* file that
    contains the complete dependency graph.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`必须与*src/SomePackage.jl*中定义的模块名称匹配。如果我们拥有这两个文件，其中一个位于*src*目录中，那么我们就拥有了一个包。我们可以把包看作是一个包含模块的环境，并且*Project.toml*中包含这四个信息。在实践中，一旦我们通过在包环境中执行`add`命令添加依赖项，我们将会在*Project.toml*文件旁边也看到一个*Manifest.toml*文件，其中包含完整的依赖图。'
- en: We can do all of our Julia development within *.jl* files, possibly using `include()`
    to split the code among several files, and share our work by emailing those files
    to colleagues. Many Julia programmers do no more than this and don’t bother creating
    packages.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*.jl*文件中完成所有Julia开发，可能会使用`include()`将代码拆分为多个文件，并通过电子邮件将这些文件发送给同事分享我们的工作。许多Julia程序员仅仅做到这一点，并且不会去创建包。
- en: '***The Benefits of Packages***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***包的好处***'
- en: After the exploratory REPL phase of your program development is over, and it’s
    time to save your code in the filesystem so you can use it later, possibly as
    a resource in other programs, I would like to encourage you to take advantage
    of Julia’s package system.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序开发的探索性 REPL 阶段结束之后，如果是时候将你的代码保存在文件系统中，以便将来使用，可能是作为其他程序的资源，我建议你利用 Julia 的包系统。
- en: It’s sophisticated, easy to use, and will save you from dependency conflicts
    down the road. Most programs use modules from the standard library and other packages,
    and all are developed with a particular version of Julia itself. As all these
    components evolve, the possibility of conflict arises and, with time, becomes
    inevitable in large programs that use many external resources. The package system
    records the exact versions of all the resources your program uses, so you or anyone
    else can reproduce that environment in the future, and the program will always
    work.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它功能强大、易于使用，并且能够避免未来依赖冲突。大多数程序都使用标准库和其他包中的模块，所有这些都在特定版本的 Julia 上开发。当这些组件不断演化时，冲突的可能性也会出现，并且随着时间推移，使用大量外部资源的大型程序中，冲突是不可避免的。包系统记录了程序使用的所有资源的确切版本，这样你或其他人就可以在未来重现那个环境，并且程序始终可以正常工作。
- en: In the absence of dependency management, a statement like `using Plots` in your
    program imports whatever version of `Plots` is used by the environment in which
    a future user, including yourself, happens to run it. You may have used a feature
    that is later removed from the package, or a future version may introduce a bug
    that breaks your program. Without package management, your program is loading
    unknown code because you’re not being specific about what you mean by `Plots`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有依赖管理的情况下，像 `using Plots` 这样的语句会导入在你运行程序的环境中使用的 `Plots` 的任何版本，包括你自己。你可能使用了一个功能，后来被包移除了，或者未来的版本可能引入一个错误，导致程序崩溃。没有包管理的情况下，你的程序加载的是不确定的代码，因为你并没有明确指定你所指的
    `Plots` 是哪个版本。
- en: 'Packages often depend on other packages. A future user of your program, encountering
    a conflict with `Plots`, may try to resolve it by using a different version. But
    that version will depend on different versions of other packages, and some of
    those will have their own dependencies. Trying to sort out the dependency graph
    of packages manually to find a workable set quickly becomes a maddening task.
    It’s such a common headache in languages without good package management that
    there’s a name for it: *dependency hell*. Julia’s package system manages the dependency
    graph automatically. You can have various versions of Julia and of any number
    of packages installed on your machine at the same time with no issues. If you
    keep your programs in packages, you can upgrade the versions of modules that it
    imports without changing your actual code, and if the new versions create problems,
    you can downgrade as needed.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 包通常依赖于其他包。未来使用你程序的用户，如果遇到与 `Plots` 的冲突，可能会尝试通过使用不同版本来解决。然而那个版本会依赖于其他包的不同版本，其中一些包也会有它们自己的依赖关系。试图手动梳理包的依赖关系图，快速找到一个可行的版本集，最终变成了一项令人抓狂的任务。在没有良好包管理的语言中，这是一个常见的难题，因此有一个专有名词来形容它：*依赖地狱*。Julia
    的包系统会自动管理依赖关系图。你可以在同一台机器上同时安装多个版本的 Julia 和任意数量的包而不会出现问题。如果你将程序保存在包中，你可以在不修改实际代码的情况下，升级它所导入模块的版本；如果新版本出现问题，你也可以根据需要降级。
- en: If you decide to share your programs through the official community channels,
    you must use packages. The official repository, from which you get resources when
    you use the `add` command, is based on packages and the Git version control system,
    which I’ll treat in “Julia and Git” on [page 77](ch03.xhtml#ch03lev1sec11).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定通过官方社区渠道分享你的程序，你必须使用包。官方的资源库是基于包和 Git 版本控制系统的，你可以通过 `add` 命令获取资源，这一点我将在《Julia
    和 Git》的 [第77页](ch03.xhtml#ch03lev1sec11)中详细讲解。
- en: '***How to Create Packages***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***如何创建包***'
- en: It’s easy to create packages. First, we navigate to the directory in the filesystem
    where we want the package to be and start the Julia REPL. We can use any directory,
    and we can always move it later.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 创建包是很容易的。首先，我们导航到文件系统中希望存放包的目录，并启动 Julia REPL。我们可以使用任何目录，之后总是可以移动它。
- en: '**NOTE**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We don’t have to start a new REPL session just to change locations in the
    filesystem. To continue in an existing REPL session, we can move around the filesystem
    while staying in the REPL using two Julia function versions of the familiar Unix
    commands* pwd *and* cd*. The REPL maintains a notion of the current directory,
    which is where we gave the* julia *command that started the REPL, and it stays
    there unless we change it. The* pwd() *function in the REPL returns a string with
    the full pathname of the current directory. To change it, enter* cd(new_directory)*,
    substituting the name of the desired destination. (The name is a string, as returned
    by* pwd()*, so must be enclosed within quotes.)*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们不需要为了更改文件系统中的位置而重新启动一个新的 REPL 会话。为了在现有 REPL 会话中继续操作，我们可以在不退出 REPL 的情况下，使用两个
    Julia 版本的熟悉的 Unix 命令* pwd *和* cd*在文件系统中移动。REPL 会维护当前目录的概念，这就是我们启动 REPL 时所给出的*
    julia *命令的路径，除非我们更改它，否则它将一直保持在那里。REPL 中的*pwd()*函数返回当前目录的完整路径名作为字符串。要更改目录，可以输入*cd(new_directory)*，将所需目标的名称替换进去。（该名称是由*pwd()*返回的字符串，因此必须用引号括起来。）*'
- en: Within the REPL, press `]` to enter package mode, and execute generate Floof.
    That’s all we need to do to create a new package named `Floof`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 中，按`]`进入包模式，然后执行`generate Floof`。这就是我们创建名为`Floof`的新包所需做的全部操作。
- en: Back in the system shell, or using the REPL’s shell mode, we’ll find the new
    directory named *Floof*, and within it, the minimal package files shown in [Figure
    3-2](ch03.xhtml#ch3fig2). Floof’s *Project.toml* file will contain lines similar
    to [Listing 3-4](ch03.xhtml#ch3lis4), but with the name *Floof* and a new, unique
    UUID. The `authors` field is populated from our Git configuration, so it’ll be
    empty if we haven’t installed Git (see “Julia and Git” on [page 77](ch03.xhtml#ch03lev1sec11)).
    The `generate` statement gives our new package a version number of `0.1.0`, which
    we can change.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到系统命令行，或者使用 REPL 的 shell 模式，我们会找到一个名为*Floof*的新目录，在其中可以看到最小的包文件，如[图 3-2](ch03.xhtml#ch3fig2)所示。Floof
    的*Project.toml*文件将包含类似[清单 3-4](ch03.xhtml#ch3lis4)的行，但会有*Floof*的名字和一个新的唯一 UUID。`authors`字段会根据我们的
    Git 配置进行填充，如果我们没有安装 Git，它将为空（参见[第 77 页](ch03.xhtml#ch03lev1sec11)的“Julia 和 Git”部分）。`generate`语句为我们创建的新包分配了版本号`0.1.0`，我们可以修改这个版本号。
- en: 'Descending into the *src* directory, the *Floof.jl* file has the following
    contents:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 进入*src*目录，*Floof.jl*文件包含以下内容：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This defines a tiny module, called `Floof`, with one function, `greet()`, that
    greets the world. Julia sets up a minimal package with everything in place so
    we can begin development of our module. We’ll make one change to this file for
    now: add the statement `export greet` after the first line.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个名为`Floof`的小模块，其中包含一个函数`greet()`，用于向世界问候。Julia 设置了一个最小的包，其中一切都已就绪，以便我们开始开发我们的模块。我们暂时对这个文件做一个更改：在第一行后添加`export
    greet`语句。
- en: 'Let’s experiment with this new mini-package. First, we’ll exercise it without
    using the package system:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来尝试一下这个新的迷你包。首先，我们将不使用包系统来测试它：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We put the `Floof` package in the */tmp* directory. The first action in the
    REPL is to `include` the program file directly. This is equivalent to pasting
    it directly into the REPL. The feedback ➊ from the `include()` statement confirms
    that `Floof` is loaded into `Main`, which is always the name for the top-level
    module.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Floof`包放在了*/tmp*目录中。在 REPL 中的第一个操作是直接`include`程序文件。这相当于将其直接粘贴到 REPL 中。`include()`语句的反馈
    ➊ 确认了`Floof`已加载到`Main`模块中，`Main`总是顶层模块的名称。
- en: Now we can use anything in the `Floof` module by mentioning its namespace. It
    has only one ingredient, the `greet()` function, which does what’s expected when
    we call it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过引用它的命名空间来使用`Floof`模块中的任何内容。它只有一个组成部分，即`greet()`函数，当我们调用它时，它会按预期执行。
- en: We would prefer to call this function without having to type the module name,
    so we need to import its name into the current namespace. We tried to do this
    with the `using` statement, but Julia won’t let us ➋. After remembering that we
    need to prefix local modules with a dot, everything works as expected ➌. (I’ve
    omitted the stacktrace from the error message to save space, as I will do routinely.)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够在不输入模块名称的情况下调用此函数，因此我们需要将它的名称导入到当前的命名空间中。我们尝试通过`using`语句来实现这一点，但 Julia
    不允许我们这样做 ➋。在记得需要在本地模块前加上点后，一切按预期工作 ➌。（我省略了错误消息中的堆栈跟踪，以节省空间，通常我都会这样做。）
- en: Importing a name, whether with `using` or `import`, without a dot prefix tells
    Julia to import a package rather than a local module. This wakes up the package
    system, which consults the `LOAD_PATH` to search for the package. Although `Floof`
    is indeed a package, it’s not on the `LOAD_PATH`, which by default includes the
    activated environment, the default environment, and the standard library, in that
    order. Since we haven’t activated an environment, and the `Floof` package is in
    neither the standard library nor the default environment, Julia can’t find it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 导入一个名称，无论是通过`using`还是`import`，如果没有点前缀，都会告诉Julia导入一个包而不是本地模块。这会唤醒包管理系统，系统会查询`LOAD_PATH`来搜索包。尽管`Floof`确实是一个包，但它不在`LOAD_PATH`中，默认情况下，`LOAD_PATH`包含已激活的环境、默认环境和标准库，顺序是这样的。由于我们没有激活任何环境，并且`Floof`包既不在标准库中也不在默认环境中，Julia无法找到它。
- en: 'If we’re determined to import `greet()` into the global namespace, we can activate
    the environment that contains the `Floof` module. But first, we should quit and
    restart the REPL. Otherwise, this new attempt to import will generate an error
    complaining about a conflict with an existing name. After starting a fresh REPL,
    we can do this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定将`greet()`导入全局命名空间，我们可以激活包含`Floof`模块的环境。但首先，我们应该退出并重启REPL。否则，这次新的导入尝试将生成一个错误，抱怨与现有名称冲突。重新启动一个新的REPL后，我们可以这样做：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After activating the `Floof` environment using its pathname, we exit package
    mode. Back in the REPL’s normal mode, after importing `Floof`’s names into the
    global namespace with `using`, a simple `greet()` invokes the function. This works
    only because we edited *Floof.jl* to `export greet`. Then we re-enter package
    mode—observe the prompt, which now indicates the `Floof` environment. The `add
    Random` command adds this package, which contains utilities related to random
    number generation, to the dependency list for `Floof`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用其路径名激活`Floof`环境后，我们退出包管理模式。回到REPL的普通模式后，使用`using`将`Floof`的名称导入到全局命名空间中，简单地调用`greet()`即可调用该函数。这之所以有效，是因为我们编辑了*Floof.jl*并`export
    greet`。然后我们重新进入包管理模式——请注意提示符，现在它显示的是`Floof`环境。`add Random`命令将此包添加到`Floof`的依赖列表中，该包包含与随机数生成相关的工具。
- en: 'We can add paths manually to `LOAD_PATH`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动将路径添加到`LOAD_PATH`：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We do this, again, in a fresh REPL. The package system found `Floof` in the
    last entry in `*LOAD_PATH*`; it will find it regardless of the current environment.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次在一个新的REPL中执行此操作。包管理系统在`*LOAD_PATH*`的最后一个条目中找到了`Floof`；无论当前环境如何，它都会找到它。
- en: '`Floof`’s *Project.toml* file now contains two additional lines. Here are its
    contents after executing `add Random`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Floof`的*Project.toml*文件现在包含了两行额外的内容。以下是执行`add Random`后其内容：'
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The lines after the `[deps]` label will record every dependency that we manually
    add with an `add` statement.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[deps]`标签之后的行将记录每个我们通过`add`语句手动添加的依赖项。
- en: 'A new *Manifest.toml* file has appeared alongside the *Project.toml* file with
    these contents:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的*Manifest.toml*文件与*Project.toml*文件一起出现，内容如下：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Manifest files are for recording the dependency graph of a package or environment.
    For each dependency added manually, the system looks up its dependencies, and
    the dependencies of all of those dependencies, and so on, until it finds every
    dependency. Each of these dependencies is another package; all of them together,
    with all of their dependency relationships, is the dependency graph. As you can
    imagine, Manifest files can get rather large, but this one is not because `Random`
    apparently has only one dependency, a package called `Serialization`, and `Serialization`
    has no dependencies of its own.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Manifest 文件用于记录包或环境的依赖关系图。对于每个手动添加的依赖项，系统会查找它的依赖项，以及所有这些依赖项的依赖项，依此类推，直到找到所有依赖项。每个依赖项都是另一个包；所有这些包以及它们之间的所有依赖关系构成了依赖关系图。正如你所想象的，Manifest
    文件可能会变得相当大，但这个文件并不大，因为`Random`显然只有一个依赖项，一个名为`Serialization`的包，而`Serialization`没有任何依赖项。
- en: 'Now that we have our very own package, we should be able to add it as a dependency
    to other packages and environments, just as we did with other packages like `Random`
    and `Plots`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了自己的包，我们应该能够像添加`Random`和`Plots`等其他包一样，将其作为依赖项添加到其他包和环境中：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First we use the `activate` statement with no argument to go back to the default
    environment. We try to add `Floof` to that environment, but the package manager
    has a complaint about not finding something called a *git repository*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用不带参数的`activate`语句返回默认环境。我们尝试将`Floof`添加到该环境中，但包管理器报告未找到名为*git repository*的内容。
- en: '***Julia and Git***'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Julia 和 Git***'
- en: 'Git is a *version control system*: a program that helps you keep track of your
    work as it changes over time. Git, in addition, focuses on collaboration, although
    it’s immensely useful to the solo creator as well.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是一个*版本控制系统*：一个帮助你跟踪工作随时间变化的程序。此外，Git 还侧重于协作，尽管它对单独创作者也非常有用。
- en: Git is independent of Julia, but since its creation in 2005 by Linus Torvalds,
    the creator of Linux, its superiority over all other version control systems has
    led to a near monopoly in the free software community. Julia is part of this community,
    and Git is an intimate component of the development of the language and its packages.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Git 独立于 Julia，但自 2005 年由 Linux 的创始人 Linus Torvalds 创建以来，它在所有版本控制系统中的优越性已导致其在自由软件社区几乎形成了垄断。Julia
    是这个社区的一部分，Git 是该语言及其包开发的一个重要组成部分。
- en: If you don’t already have Git installed and would prefer to continue your study
    of Julia without pausing to install Git and learning how to use it, skip this
    section for now. You can always return later. See “Further Reading” on [page 81](ch03.xhtml#fur3)
    for a link to an excellent learning resource. There are also many articles and
    several books about Git.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装 Git，并且希望在不暂停安装 Git 和学习如何使用它的情况下继续学习 Julia，可以暂时跳过本节内容。你随时可以回来。请参阅 [第
    81 页](ch03.xhtml#fur3) 的“进一步阅读”部分，里面有一个很好的学习资源链接。此外，还有许多关于 Git 的文章和几本书。
- en: I recommend installing Git and using it in your projects before your personal
    library of code becomes substantial. The small investment in time and effort to
    become familiar with a few basic operations has a huge payback. You’ll be able
    to travel back in time to past states of your programs, keep a log of changes,
    create alternative versions of your programs where you try out ideas, and merge
    the ideas into the main line of development when they’re ready.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在你的个人代码库变得庞大之前安装 Git 并在项目中使用它。花费一些时间和精力熟悉一些基本操作，回报是巨大的。你将能够回到程序的过去状态，记录更改，创建程序的不同版本来尝试新想法，并在准备好时将这些想法合并到主开发线中。
- en: If you’re already using one of the older version control systems, you can continue
    to do so. However, if you reach the stage where you would like to contribute your
    Julia programs to the community, you will have to use Git. As we’re about to see,
    Git is also required for adding your own packages as dependencies in your own
    projects and environments on your personal machine, which is something you may
    want to do even if you don’t share your programs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在使用旧版的版本控制系统，可以继续使用。然而，如果你想将自己的 Julia 程序贡献给社区，你就必须使用 Git。正如我们接下来要看到的，Git
    也是在个人机器上将自己的包作为依赖项添加到自己的项目和环境中所必需的，即使你不分享程序，这也是你可能会做的事情。
- en: As shown in “How to Create Packages” on [page 73](ch03.xhtml#ch03lev1sec10),
    Julia complained when we tried to `add` my `Floof` package. The package system
    won’t let us add a package until we put it in a Git repository. Dependency management,
    which is the reason for the package system, tracks not simply packages, but versions
    of packages. Julia’s package system works with Git to track these versions. The
    rest of this section assumes Git is installed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 [第 73 页](ch03.xhtml#ch03lev1sec10) 的“如何创建包”中所示，当我们尝试 `add` 我的 `Floof` 包时，Julia
    报错了。包管理系统在我们将包放入 Git 仓库之前，不允许我们添加包。依赖管理，包管理系统的目的，不仅跟踪包本身，还跟踪包的版本。Julia 的包管理系统与
    Git 一起工作来跟踪这些版本。本节其余部分假设 Git 已安装。
- en: To allow the package system to deal with `Floof`, we have to put it in a Git
    repository and make an initial commit. In the */tmp/Floof* directory, we execute
    git init in the system shell to create the repository, then git add. and git commit
    -m "Begin repo" to begin tracking the contents.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让包管理系统处理 `Floof`，我们必须将其放入 Git 仓库并进行初始提交。在 */tmp/Floof* 目录中，我们在系统 shell 中执行
    git init 来创建仓库，然后执行 git add. 和 git commit -m "开始仓库" 来开始跟踪内容。
- en: 'Back in the Julia REPL, we try again:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 Julia 的 REPL，我们再次尝试：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It works this time: the package manager responds that it’s added `Floof` to
    the *Project.toml* and *Manifest.toml* files. The string in square brackets is
    the initial part of the UUID that the package manager has assigned to this version
    of `Floof`. The `#master` string refers to the branch name in Git.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这次成功了：包管理器回应称已将 `Floof` 添加到 *Project.toml* 和 *Manifest.toml* 文件中。方括号中的字符串是包管理器为该版本的
    `Floof` 分配的 UUID 的初始部分。`#master` 字符串表示 Git 中的分支名称。
- en: The `status` package command returns a list of all the dependencies added to
    the current environment (not the entire dependency graph), and we see that `Floof`
    is among them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`status`包命令返回当前环境中所有已添加依赖项的列表（而不是整个依赖关系图），我们可以看到`Floof`在其中。'
- en: 'If we want to remove a dependency—say, `Floof`—we enter rm Floof in package
    mode: note that when removing packages, we use just the package name, not the
    whole path on the filesystem. This does nothing to our files; it simply removes
    `Floof` from the *Project.toml* file. However, it may not remove it from *Manifest.toml*
    because it may be listed there as a dependency of some other package.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要移除一个依赖项——比如`Floof`——我们可以在包模式下输入`rm Floof`：注意，在移除包时，我们只使用包名，而不是文件系统中的完整路径。这不会对我们的文件做任何修改；它只是将`Floof`从*Project.toml*文件中移除。然而，它可能不会从*Manifest.toml*中移除，因为它可能作为其他包的依赖项列在那里。
- en: If you’ve made your program into a Julia package and are tracking it with Git,
    you’ll be prepared to request that it be included in the official repository if
    the day comes when you feel it will be of use to a wider audience. If you complete
    this step, any Julia user anywhere in the world can simply tell their package
    REPL to `add` `*YourPackage*`, and they’ll be able to use and build on your work.
    Sharing and collaboration are embedded in Julia’s DNA. [Chapters 9](ch09.xhtml)
    and [12](ch12.xhtml) demonstrate several interesting examples of how packages
    can be combined to create new capabilities.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经将你的程序做成了一个Julia包并使用Git进行版本控制，那么当有一天你觉得这个包对更广泛的用户群有用时，你可以请求将它纳入官方仓库。如果你完成了这一步，世界上任何地方的Julia用户只需要在他们的包REPL中输入`add`
    `*YourPackage*`，就能使用并在你的工作基础上进行扩展。共享和协作是Julia的DNA的一部分。[第9章](ch09.xhtml)和[第12章](ch12.xhtml)展示了如何将多个包组合起来创建新功能的几个有趣示例。
- en: '***The Relationship Between Package Versions and Git Commits***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***包版本与Git提交之间的关系***'
- en: We’ve seen how to request `status` at the package prompt to see a list of dependencies
    and abbreviations of their UUIDs, and how to see the complete UUID in the *Manifest.toml*
    file. We may be aware that Git identifies commits with a unique hash, but if we
    examine the hash of our project with `git log`, we won’t see anything that looks
    like Julia’s UUID.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何在包提示符下请求`status`来查看依赖项列表和它们UUID的缩写，以及如何在*Manifest.toml*文件中查看完整的UUID。我们可能知道Git使用唯一的哈希值来标识提交，但如果我们使用`git
    log`检查项目的哈希值，我们不会看到类似Julia UUID的内容。
- en: 'Here is the relevant section of the default environment’s *Manifest.toml*,
    which is in *.julia/environments/v1.8/Manifest.toml* within the user’s home directory:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是默认环境中*Manifest.toml*的相关部分，该文件位于用户主目录的*.julia/environments/v1.8/Manifest.toml*中：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`Random` is listed as a dependency because we had `add`ed it to the project
    earlier. In the last two lines, we see the full UUID and the initial version assigned
    by the package system. Before that, we have the path and the branch name from
    Git. Above that, we see something called the `git-tree-sha1`, which is a Git hash,
    but it’s not the commit hash that we see by default when we enter git log. Within
    `Floof`’s directory, if we enter this command with an option, we can see more:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Random`被列为依赖项，因为我们之前已经将它`add`到项目中。在最后两行中，我们可以看到完整的UUID和包管理系统分配的初始版本。在此之前，我们可以看到Git的路径和分支名称。更高处，我们看到了一个叫做`git-tree-sha1`的东西，它是一个Git哈希值，但它不是我们在输入`git
    log`时默认看到的提交哈希值。在`Floof`的目录中，如果我们带上选项输入此命令，我们可以看到更多信息：'
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The hash recorded in *Manifest.toml* is the *tree hash*. Most Git users are
    unaware of this hash because it’s rarely needed for anything. The tree hash encodes
    the actual contents of all the tracked files in the commit. Julia’s package manager
    uses this rather than the commit hash because it’s more reliable. Git provides
    powerful commands, such as `rebase`, that let users rewrite the commit history.
    If a conflict arises and something breaks, ideally we would like to identify the
    actual file contents of the programs involved. In practice, to identify a commit
    from the information recorded in *Manifest.toml*, we need to ask Git for the raw
    commit log and search for the tree hash.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 记录在*Manifest.toml*中的哈希值是*树哈希*。大多数Git用户并不了解这个哈希值，因为它很少用于其他用途。树哈希编码了提交中所有被跟踪文件的实际内容。Julia的包管理器使用树哈希，而不是提交哈希，因为树哈希更可靠。Git提供了强大的命令，如`rebase`，允许用户重写提交历史。如果发生冲突并且某些内容被破坏，理想情况下，我们希望能够识别参与程序的实际文件内容。在实践中，为了从*Manifest.toml*中识别一个提交，我们需要请求Git提供原始提交日志，并搜索树哈希。
- en: '***Version Updating and Pinning***'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***版本更新和固定***'
- en: Another crucial package system command is `update` `*PackageName*`. Execute
    this operation to get the latest version of `*PackageName*` installed in the environment.
    Julia will check the registry for a new version, and download and precompile it
    if there is one. If `*PackageName*` has any dependencies, Julia will check their
    versions against the ones already installed, and download and precompile anything
    that’s changed. It will continue through the entire dependency graph, leaving
    us with a consistent environment, with no further action on our part.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的包系统命令是 `update` `*PackageName*`。执行此操作可以将 `*PackageName*` 的最新版本安装到环境中。Julia
    会检查注册表中是否有新版本，如果有，它会下载并预编译该版本。如果 `*PackageName*` 有任何依赖项，Julia 会检查它们的版本是否与已安装的版本匹配，并下载和预编译发生变化的部分。它会遍历整个依赖图，确保我们拥有一个一致的环境，无需我们采取进一步的操作。
- en: If `*PackageName*` is our own project that we’re developing locally, the `update`
    command will cause the package manager to check its Git repository. If the tree
    hash at the `HEAD` of the tracked branch, as recorded in Git’s log, has changed,
    Julia will install the new version into the environment and precompile it. The
    *Manifest.toml* file will contain the new tree hash. If we’ve edited the source
    file but not yet made a new Git commit, the package manager won’t do anything.
    Even if we change the version number recorded in `*PackageName*`’s *Project.toml*
    file, that will not cause Julia to take any action. The package manager cares
    only about the tree hash. This means, for example, if we soft-reset to an earlier
    commit, then `update` in Julia, the package manager will revert to the version
    that our `HEAD` now points to, pulling the files from the Git repository and *not*
    from our working tree.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `*PackageName*` 是我们本地开发的项目，`update` 命令会使包管理器检查其 Git 仓库。如果 Git 日志中记录的跟踪分支的
    `HEAD` 树哈希发生了变化，Julia 会将新版本安装到环境中并进行预编译。*Manifest.toml* 文件会包含新的树哈希。如果我们编辑了源文件但尚未进行新的
    Git 提交，包管理器将不会采取任何操作。即使我们更改了 `*PackageName*` 的 *Project.toml* 文件中的版本号，也不会导致 Julia
    采取任何措施。包管理器只关注树哈希。这意味着，例如，如果我们将 Git 版本软重置为早期的提交，再在 Julia 中执行 `update`，包管理器将回到
    `HEAD` 当前指向的版本，从 Git 仓库中提取文件，而不是从我们的工作区提取。
- en: It’s possible for an `update` to lead to a conflict, where the current versions
    of two packages cannot work together. Use the `pin` command in the package manager
    to force it to hold particular packages at certain versions. Sometimes that’s
    the only way around a conflict until the bugs are fixed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 更新（`update`）可能会导致冲突，即两个包的当前版本无法兼容。可以使用包管理器中的 `pin` 命令强制将特定包固定在某个版本。有时候，这是解决冲突的唯一方法，直到
    bug 被修复。
- en: The three versions of `pin` are `pin` `*PackageName*`, which holds `*PackageName*`
    at its current version; `pin` `*PackageName*@2.4.2`, which, in this example, holds
    `*PackageName*` at version 2.4.2; and `pin` `*PackageName=UUID*`, which holds
    the package using its UUID rather than the version number to identify the version.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`pin` 的三种用法分别是：`pin` `*PackageName*`，将 `*PackageName*` 固定在当前版本；`pin` `*PackageName*@2.4.2`，在本例中将
    `*PackageName*` 固定在版本 2.4.2；以及 `pin` `*PackageName=UUID*`，使用包的 UUID 来标识版本，而不是使用版本号。'
- en: '***How to Find Public Packages***'
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***如何查找公共包***'
- en: How can we discover if there is a Julia package that might help us write our
    program? The most productive approach is probably a general web search for projects
    or problems similar to ours, using Julia—this will quickly surface the most popular
    relevant packages. Of course, talking to people working in the same area is invaluable,
    if such a community is available. Asking on the Julia Discourse forum will almost
    certainly yield helpful replies, unless our project is quite niche or esoteric.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何发现是否有一个 Julia 包能够帮助我们编写程序呢？最有效的方式可能是通过网络搜索与我们类似的项目或问题，尤其是使用 Julia——这种方法会迅速揭示出最受欢迎的相关包。当然，如果有一个相关的社区，向在同一领域工作的人请教是非常宝贵的。在
    Julia Discourse 论坛上提问几乎肯定会得到有用的回复，除非我们的项目非常小众或深奥。
- en: Since practically all development of public Julia packages takes place on GitHub,
    this is the place to search directly for solutions, especially if the previously
    mentioned approaches did not lead to anything appropriate, or if specific criteria
    are important to our project, such as recency of development.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于几乎所有公共 Julia 包的开发都在 GitHub 上进行，因此这是直接搜索解决方案的地方，特别是如果之前提到的方法没有找到合适的解决方案，或者我们的项目有特定的需求，如开发的时效性。
- en: There are several sites that seem to offer a way to search through packages,
    but provide nothing beyond what GitHub offers directly, aside from incorrect and
    outdated information and an even worse interface. The best strategy for searching
    on GitHub is to use a language qualifier. For example, in the project search box
    we would enter `phylogenetics language:Julia` to look for projects that mention
    phylogenetics in their title or keywords, and that are written in Julia (and possibly
    other languages). This is effective because Julia packages are written in Julia,
    and it’s necessary because Julia packages often do not have a “Julia" keyword,
    so using that as a bare search term misses many projects.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个网站似乎提供了搜索包的方法，但除了错误和过时的信息，以及更糟的界面外，什么也没有提供。搜索GitHub的最佳策略是使用语言限定符。例如，在项目搜索框中输入`phylogenetics
    language:Julia`，这样就能搜索到标题或关键词中提到“phylogenetics”并且用Julia（也可能是其他语言）编写的项目。这是有效的，因为Julia包是用Julia编写的，且这是必要的，因为Julia包通常没有“Julia”关键词，所以如果只使用它作为搜索词，会错过很多项目。
- en: Crucially, we can then sort the resulting list based on several criteria, including
    recency of last update and the number of “stars” the project has. The latter,
    despite its unpleasant associations with internet popularity and gamification,
    is actually a useful proxy to uncover packages that are widely used and therefore
    more likely to be valuable and to have a community around them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，我们可以根据多个标准对结果列表进行排序，包括最后更新时间和项目的“星标”数量。尽管后者与互联网流行度和游戏化有不愉快的联系，但实际上是一个有用的代理，可以帮助我们发现被广泛使用的包，这些包更可能有价值，并且会有一个社区支持它们。
- en: The individual project pages in GitHub will contain a rendering of their README
    files, which range from a few cryptic phrases to a full introduction and tutorial
    with screenshots and animations. The README sometimes contains a link to further
    documentation; if it doesn’t, one can click one of the project’s documentation
    badges, but there is no guarantee that will lead to any actual documentation.
    Lack of documentation is not a good sign, but there may be linguistic or other
    reasons for the lapse. We can always look at the source code, all of which will
    be a click away on GitHub. Julia code is unusually easy to read, and obviously
    is the final source of truth about the operation of any package.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub上的各个项目页面将包含其README文件的渲染，其中的内容从一些晦涩的短语到包含截图和动画的完整介绍和教程不等。README有时会包含指向进一步文档的链接；如果没有链接，可以点击项目的文档徽章之一，但不能保证它会链接到实际的文档。缺乏文档并不是一个好迹象，但可能有语言或其他原因导致文档缺失。我们始终可以查看源代码，所有源代码都可以通过GitHub点击获取。Julia代码异常易读，显然它是任何包操作的最终真相来源。
- en: After we discover a package that we want to try, it’s time to return to the
    REPL and `add` it to our project. We can add packages in the official registry,
    listed in the GitHub project `JuliaRegistries/General`, simply by using its name.
    In the probably unusual circumstance where we want to add a public project that
    is not in the general registry, we can add it using its URL. In package mode,
    we enter
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在发现我们想尝试的包后，是时候回到REPL并将其`add`到我们的项目中了。我们可以通过使用包的名称，轻松地在官方注册表中添加GitHub项目`JuliaRegistries/General`中列出的包。在可能不太常见的情况下，如果我们想添加一个不在通用注册表中的公共项目，我们可以使用它的URL来添加。在包模式下，我们输入
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: for example, to add the project `projectname` by developer `developer`. This
    will only work if we are pointing at a proper Julia project with a *Project.toml*
    or *JuliaProject.toml* file. After adding the project, it will appear in our *Manifest.toml*
    file with the extra field `repo-url`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要添加开发者`developer`的项目`projectname`。这仅在我们指向一个包含*Project.toml*或*JuliaProject.toml*文件的有效Julia项目时有效。添加项目后，它将在我们的*Manifest.toml*文件中显示，并带有额外的`repo-url`字段。
- en: '**Conclusion**'
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: This chapter describes some essential ingredients for using Julia effectively
    and making it possible for others to incorporate our programs into their work.
    Programming is rarely done in isolation. There is no need to reinvent the wheel
    if a solution to a part of your problem is as close as an `import` away. In later
    chapters, we’ll expand on these ideas and look at even more powerful ways to combine
    the resources of several packages. But first, in the next chapter we’ll explore
    an essential package that nearly all scientific Julia programmers use as we delve
    into the plotting system.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了使用Julia有效编程的一些基本要素，并使其他人能够将我们的程序纳入他们的工作中。编程很少是孤立进行的。如果你的问题的某部分解决方案就像`import`一样触手可及，那么就没有必要重新发明轮子。在后续章节中，我们将进一步扩展这些思想，探索结合多个包资源的更强大方法。但首先，在下一章中，我们将探讨一个几乎所有科学Julia程序员都会使用的基础包，并深入研究绘图系统。
- en: '**FURTHER READING**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: More details on what you can do with docstrings, mostly of interest to package
    developers, are available at [*https://docs.julialang.org/en/v1/manual/documentation/*](https://docs.julialang.org/en/v1/manual/documentation/).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于文档字符串的更多细节，主要对包开发者有兴趣，可以在[*https://docs.julialang.org/en/v1/manual/documentation/*](https://docs.julialang.org/en/v1/manual/documentation/)找到。
- en: 'When making those docstrings, you may need to know more about Markdown syntax:
    [*https://www.markdownguide.org/basic-syntax*](https://www.markdownguide.org/basic-syntax).'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写文档字符串时，您可能需要了解更多关于Markdown语法的知识：[*https://www.markdownguide.org/basic-syntax*](https://www.markdownguide.org/basic-syntax)。
- en: 'The *.toml* file extension stands for “Tom’s Obvious, Minimal Language” designed
    by Tom Preston-Werner: [*https://github.com/toml-lang/toml*](https://github.com/toml-lang/toml).'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.toml* 文件扩展名代表“Tom''s Obvious, Minimal Language”，由Tom Preston-Werner设计：[*https://github.com/toml-lang/toml*](https://github.com/toml-lang/toml)。'
- en: A good resource for getting started with Git is [*https://git-scm.com*](https://git-scm.com).
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于如何入门Git的好资源是[*https://git-scm.com*](https://git-scm.com)。
- en: For detailed information about the package system, including instructions on
    how to submit your creations to the official repository, or *registry*, go to
    [*https://pkgdocs.julialang.org/*](https://pkgdocs.julialang.org/).
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于包系统的详细信息，包括如何将你的创作提交到官方仓库或*注册表*的说明，请访问[*https://pkgdocs.julialang.org/*](https://pkgdocs.julialang.org/)。
- en: A package system summary, and my first adventure in contributing to a public
    package, are available at [*https://lwn.net/Articles/871490/*](https://lwn.net/Articles/871490/).
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包系统的总结，以及我第一次为公共包贡献的冒险，可以在[*https://lwn.net/Articles/871490/*](https://lwn.net/Articles/871490/)找到。
- en: For workflow tips, visit [*https://docs.julialang.org/en/v1/manual/workflow-tips/*](https://docs.julialang.org/en/v1/manual/workflow-tips/).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关工作流程的技巧，请访问[*https://docs.julialang.org/en/v1/manual/workflow-tips/*](https://docs.julialang.org/en/v1/manual/workflow-tips/)。
