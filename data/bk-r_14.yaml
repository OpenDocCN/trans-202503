- en: '**12**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12**'
- en: '**EXCEPTIONS, TIMINGS, AND VISIBILITY**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常、计时和可见性**'
- en: '![image](../images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common-01.jpg)'
- en: Now that you’ve seen how to write your own functions in R, let’s examine some
    common function augmentations and behaviors. In this chapter, you’ll learn how
    to make your functions throw an error or warning when they receive unexpected
    input. You’ll also see some simple ways to measure completion time and check progress
    for computationally expensive functions. Finally, you’ll see how R masks functions
    when two have the same name but reside in different packages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到如何在R中编写自己的函数，我们来看看一些常见的函数扩展和行为。在本章中，你将学习如何让你的函数在接收到意外输入时抛出错误或警告。你还将了解一些简单的方式来测量完成时间并检查计算密集型函数的进度。最后，你将看到R如何在两个同名但位于不同包中的函数之间进行遮蔽。
- en: '**12.1 Exception Handling**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**12.1 异常处理**'
- en: When there’s an unexpected problem during execution of a function, R will notify
    you with either a *warning* or an *error*. In this section, I’ll demonstrate how
    to build these constructs into your own functions where appropriate. I’ll also
    show how to *try* a calculation to check whether it’s possible without an error
    (that is, to see whether it’ll even work).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数执行过程中遇到意外问题时，R会通知你，可能是一个*警告*或*错误*。在本节中，我将演示如何在适当的情况下将这些构造体构建到你自己的函数中。我还将展示如何*尝试*一个计算，检查它是否可以在没有错误的情况下执行（即，看看它是否能正常工作）。
- en: '***12.1.1 Formal Notifications: Errors and Warnings***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***12.1.1 正式通知：错误和警告***'
- en: 'In [Chapter 11](ch11.xhtml#ch11), you made your functions print a string (for
    example, `"no valid matrices"`) when they couldn’t perform certain operations.
    Warnings and errors are more formal mechanisms designed to convey these types
    of messages and handle subsequent operations. An error forces the function to
    immediately terminate at the point it occurs. A warning is less severe. It indicates
    that the function is being run in an atypical way but tries to work around the
    issue and continue executing. In R, you can issue warnings with the `warning`
    command, and you can throw errors with the `stop` command. The following two functions
    show an example of each:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](ch11.xhtml#ch11)，当你的函数无法执行某些操作时，你让它们打印出一个字符串（例如，`"无效矩阵"`）。警告和错误是更正式的机制，用于传达这些类型的信息并处理后续操作。错误会强制函数在发生错误的地方立即终止。警告则较为轻微，表示函数以不典型的方式运行，但会尝试绕过问题并继续执行。在R中，你可以使用`warning`命令发出警告，使用`stop`命令抛出错误。以下两个函数展示了各自的例子：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Both `warn_test` and `error_test` divide 5 by the argument `x`. They also both
    expect `x` to be positive. In `warn_test`, if `x` is nonpositive, the function
    issues a warning, and `x` is overwritten to be `1`. In `error_test`, on the other
    hand, if `x` is nonpositive, the function throws an error and terminates immediately.
    The two commands `warning` and `stop` are used with a character string argument,
    which becomes the message printed to the console.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`warn_test`和`error_test`都将5除以参数`x`。它们也都期望`x`是正数。在`warn_test`中，如果`x`是非正数，函数会发出警告，并将`x`的值覆盖为`1`。而在`error_test`中，如果`x`是非正数，函数会抛出一个错误并立即终止。两个命令`warning`和`stop`都使用字符字符串参数，作为打印到控制台的消息。'
- en: 'You can see these notifications by importing and calling the functions as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式导入并调用这些函数来查看通知：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that `warn_test` has continued to execute and returned the value `5`—the
    result of `5/1` after setting `x` to `1`. The call to `error_test` did not return
    anything because R exited the function at the `stop` command.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`warn_test`已继续执行并返回了值`5`—这是将`x`设为`1`后，`5/1`的结果。`error_test`的调用没有返回任何内容，因为R在`stop`命令处退出了该函数。
- en: Warnings are useful when there’s a natural way for a function to try to save
    itself even when it doesn’t get the input it expects. For example, in [Section
    10.1.3](ch10.xhtml#ch10lev2sec89), R issued a warning when you supplied a logical
    vector of elements to the `if` statement. Remember that the `if` statement expects
    a single logical value, but rather than quit when a logical vector is provided
    instead, it continues execution using just the first entry in the supplied vector.
    That said, sometimes it’s more appropriate to actually throw an error and stop
    execution altogether.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 警告在函数即使未得到预期的输入时，仍能以某种自然方式尝试自我修复时非常有用。例如，在[第 10.1.3 节](ch10.xhtml#ch10lev2sec89)中，当你为
    `if` 语句提供了一个逻辑向量时，R 会发出警告。请记住，`if` 语句期望一个单一的逻辑值，但如果提供了一个逻辑向量，它不会退出，而是继续执行，使用提供向量中的第一个条目。也就是说，有时实际上抛出错误并完全停止执行会更为合适。
- en: 'Let’s go back to `myfibrec` from [Section 11.3.3](ch11.xhtml#ch11lev2sec105).
    This function expects a positive integer (the position of the Fibonacci number
    it should return). Suppose you assume that if the user supplies a negative integer,
    the user actually means the positive version of that term. You can add a warning
    to handle this situation. Meanwhile, if the user enters 0, which doesn’t correspond
    to any position in the Fibonacci series, the code will throw an error. Consider
    these modifications:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到[第 11.3.3 节](ch11.xhtml#ch11lev2sec105)中的 `myfibrec` 函数。这个函数期望一个正整数（它应该返回的斐波那契数的位置）。假设你认为如果用户提供了一个负整数，那么用户实际上是想要这个数值的正数版本。你可以添加一个警告来处理这种情况。同时，如果用户输入
    0，这个数值在斐波那契数列中没有对应的位置，代码将抛出错误。考虑以下修改：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In `myfibrec2`, you now check whether `n` is negative or zero. If it’s negative,
    the function issues a warning and continues executing after swapping the argument’s
    sign. If `n` is zero, an error halts execution with a corresponding message. Here
    you can see the responses for a few different arguments:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `myfibrec2` 中，你现在检查 `n` 是否为负数或零。如果是负数，函数会发出警告并在交换参数符号后继续执行。如果 `n` 为零，错误会终止执行并显示相应的消息。你可以看到以下不同参数的响应：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the call to `myfibrec2(-3)` has returned the third Fibonacci number.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，调用 `myfibrec2(-3)` 返回的是第三个斐波那契数。
- en: Broadly speaking, both errors and warnings signal that something has gone wrong.
    If you’re using a certain function or running chunks of code and you encounter
    these kinds of messages, you should look carefully at what has been run and what
    may have occurred to spark them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 广义来说，错误和警告都表明发生了问题。如果你正在使用某个函数或运行代码块，并遇到这些信息，你应该仔细查看已执行的操作以及可能导致这些问题的原因。
- en: '**NOTE**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Identifying and repairing erroneous code is referred to as* debugging*, for
    which there are various strategies. One of the most basic strategies involves
    including* `print` *or* `cat` *commands to inspect various quantities as they
    are calculated during live execution. R does have some more sophisticated debugging
    tools; if you’re interested, check out the excellent discussion of them provided
    in [Chapter 13](ch13.xhtml#ch13) of* The Art of R Programming *by Matloff ([2011](ref.xhtml#ref44)).
    A more general discussion can be found in* The Art of Debugging *by Matloff and
    Salzman ([2008](ref.xhtml#ref45)). As you gain more experience in R, understanding
    error messages or locating potential problems in code before they arise becomes
    easier and easier, a benefit you get partly because of R’s interpretative style.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*识别和修复错误代码被称为* 调试 *，对此有多种策略。最基本的策略之一是使用* `print` *或* `cat` *命令，在实时执行过程中检查计算的各种量。R
    确实有一些更复杂的调试工具；如果你有兴趣，可以查看在《*The Art of R Programming*》一书中由 Matloff 提供的第 13 章的精彩讨论（[2011](ref.xhtml#ref44)）。更多的一般性讨论可以在
    Matloff 和 Salzman 合著的《*The Art of Debugging*》（[2008](ref.xhtml#ref45)）中找到。随着你在
    R 中积累更多经验，理解错误信息或在问题出现之前定位潜在问题变得越来越容易，这是你部分得益于 R 的解释性风格。*'
- en: '***12.1.2 Catching Errors with try Statements***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***12.1.2 使用 try 语句捕获错误***'
- en: When a function terminates from an error, it also terminates any parent functions.
    For example, if function A calls function B and function B halts because of an
    error, this halts execution of A at the same point. To avoid this severe consequence,
    you can use a `try` statement to attempt a function call and check whether it
    produces an error. You can also use an `if` statement to specify alternative operations,
    rather than allowing all processes to cease.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数因错误终止时，它也会终止任何父函数的执行。例如，如果函数 A 调用函数 B，而函数 B 因错误停止执行，这会导致函数 A 在同一位置停止执行。为了避免这种严重后果，你可以使用
    `try` 语句来尝试函数调用并检查是否产生错误。你还可以使用 `if` 语句来指定替代操作，而不是让所有流程停止。
- en: 'For example, if you call the `myfibrec2` function from earlier and pass it
    0, the function throws an error and terminates. But watch what happens when you
    pass that function call as the first argument to `try`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你调用之前的 `myfibrec2` 函数并传入 0，函数会抛出错误并终止。但是，看看当你将该函数调用作为第一个参数传递给 `try` 时会发生什么：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Nothing seems to happen. What’s happened to the error? In fact, the error has
    still occurred, but `try` has suppressed the printing of an error message to the
    console because you passed it the argument `silent` set to `TRUE`. The error information
    is now stored in the object `attempt1`, which is of class `"try-error"`. To see
    the error, simply print `attempt1` to the console:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎什么都没有发生。错误去哪了？实际上，错误仍然发生了，但由于你将 `silent` 设置为 `TRUE`，`try` 抑制了错误信息的打印。错误信息现在被存储在对象
    `attempt1` 中，该对象属于 `"try-error"` 类。要查看错误，只需将 `attempt1` 打印到控制台：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You would have seen this printed to the console if you’d left `silent` set to
    `FALSE`. Catching an error this way can be really handy, especially when a function
    produces the error in the body code of another function. Using `try`, you can
    handle the error without terminating that parent function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 `silent` 设置为 `FALSE`，你会看到这个错误信息打印到控制台。以这种方式捕获错误非常有用，尤其是当一个函数在另一个函数的主体代码中产生错误时。使用
    `try`，你可以在不终止父函数的情况下处理错误。
- en: Meanwhile, if you pass a function to `try` and it doesn’t throw an error, then
    `try` has no effect, and you simply get the normal return value.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，如果你将一个函数传递给 `try`，而该函数没有抛出错误，那么 `try` 就不会产生任何影响，你会得到正常的返回值。
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, you executed `myfibrec2` with a valid argument, `n=6`. Since this call
    doesn’t result in an error, the result passed to `attempt2` is the normal return
    value from `myfibrec2`, in this case `8`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你用一个有效的参数 `n=6` 执行了 `myfibrec2`。由于此调用没有产生错误，传递给 `attempt2` 的结果是 `myfibrec2`
    的正常返回值，在此情况下是 `8`。
- en: '**Using try in the Body of a Function**'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在函数主体中使用 try**'
- en: 'Let’s see a more complete example of how you could use `try` in a larger function.
    The following `myfibvector` function takes a vector of indexes as the argument
    `nvec` and provides the corresponding terms from the Fibonacci sequence:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更完整的例子，展示如何在更大的函数中使用 `try`。以下 `myfibvector` 函数接受一个索引向量作为参数 `nvec`，并提供斐波那契数列中相应的项：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function uses a `for` loop to work through `nvec` element by element,
    computing the corresponding Fibonacci number with the earlier function, `myfibrec2`.
    As long as all the values in `nvec` are nonzero, `myfibvector` works just fine.
    For example, the following call obtains the first, the second, the tenth, and
    the eighth Fibonacci number:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用 `for` 循环逐个处理 `nvec` 中的元素，利用之前的函数 `myfibrec2` 计算相应的斐波那契数。只要 `nvec` 中的所有值非零，`myfibvector`
    就能正常工作。例如，以下调用会得到第一个、第二个、第十个和第八个斐波那契数：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Suppose, however, there’s a mistake and one of the entries in `nvec` ends up
    being zero.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个错误，`nvec` 中的某个条目是零。
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The internal call to `myfibrec2` has thrown an error when it’s called on `n=0`,
    and this has terminated execution of `myfibvector`. Nothing is returned, and the
    entire call has failed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `n=0` 时调用 `myfibrec2` 时，内部调用抛出了一个错误，这导致 `myfibvector` 执行终止。没有返回任何结果，整个调用失败。
- en: You can prevent this outright failure by using `try` within the `for` loop to
    check each call to `myfibrec2` and have it catch any errors. The following function,
    `myfibvectorTRY`, does just that.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 `for` 循环中使用 `try` 来防止这种失败，检查每次调用 `myfibrec2` 并捕获任何错误。以下函数 `myfibvectorTRY`
    就实现了这一点。
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, within the `for` loop, you use `attempt` to store the result of trying
    each call to `myfibrec2`. Then, you inspect `attempt`. If this object’s class
    is `"try-error"`, that means `myfibrec2` produced an error, and you fill the corresponding
    slot in the `result` vector with `NA`. Otherwise, `attempt` will represent a valid
    return value from `myfibrec2`, so you place it in the corresponding slot of the
    `result` vector. Now if you import and call `myfibvectorTRY` on the same `nvec`,
    you see a complete set of results.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中，你使用`attempt`存储每次调用`myfibrec2`的结果。然后，你检查`attempt`。如果该对象的类是`"try-error"`，则表示`myfibrec2`产生了错误，你在`result`向量中相应的位置填充`NA`。否则，`attempt`将代表`myfibrec2`的有效返回值，因此你将其放入`result`向量的相应位置。现在，如果你导入并在相同的`nvec`上调用`myfibvectorTRY`，你会看到完整的结果集。
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The error that would have otherwise terminated everything was silently caught,
    and the alternative response in this situation, `NA`, was inserted into the `result`
    vector.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本来会导致终止的错误被悄无声息地捕获，替代的响应是`NA`，它被插入到`result`向量中。
- en: '**NOTE**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* `try` *command is a simplification of R’s more complex* `tryCatch` *function,
    which is beyond the scope of this book, but it provides more precise control over
    how you test and execute chunks of code. If you’re interested in learning more,
    enter* `?tryCatch` *in the console.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*`try`*命令是R中更复杂的*`tryCatch`*函数的简化版本，后者超出了本书的讨论范围，但它提供了更精确的控制方式，用于测试和执行代码块。如果你有兴趣了解更多，输入*`?tryCatch`*以获得帮助。'
- en: '**Suppressing Warning Messages**'
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**抑制警告消息**'
- en: In all the `try` calls I’ve shown so far, I’ve set the `silent` argument to
    `TRUE`, which stops any error messages from being printed. If you leave `silent`
    set to `FALSE` (the default value), the error message will be printed, but the
    error will still be caught without terminating execution.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我展示的所有`try`调用中，我都将`silent`参数设置为`TRUE`，这样可以停止打印错误消息。如果将`silent`设置为`FALSE`（默认值），则错误消息会被打印出来，但错误仍然会被捕获而不会终止执行。
- en: 'Note that setting `silent=TRUE` only suppresses error messages, not warnings.
    Observe the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，设置`silent=TRUE`仅会抑制错误消息，而不会抑制警告消息。请观察以下内容：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Although `silent` was `TRUE`, the warning (for negative values of `n` in this
    example) is still issued and printed. Warnings are treated separately from errors
    in this type of situation, as they should be—they can highlight other unforeseen
    issues with your code during execution. If you are absolutely sure you don’t want
    to see any warnings, you can use `suppressWarnings`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`silent`设置为`TRUE`，但仍然会发出警告（在这个例子中是针对`n`的负值）。警告在这种情况下与错误被分别处理，因为它们应该被分开处理——警告可以在代码执行过程中高亮显示其他未预见到的问题。如果你完全确定不希望看到任何警告，可以使用`suppressWarnings`。
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `suppressWarnings` function should be used only if you are certain that
    every warning in a given call can be safely ignored and you want to keep the output
    tidy.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`suppressWarnings`函数应仅在你确定可以安全忽略某个调用中的每个警告，并且希望保持输出整洁时使用。'
- en: '**Exercise 12.1**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 12.1**'
- en: 'In [Exercise 11.3](ch11.xhtml#ch11exc3) (b) on [page 238](ch11.xhtml#page_238),
    your task was to write a recursive R function to compute integer factorials, given
    some supplied non-negative integer `x`. Now, modify your function so that it throws
    an error (with an appropriate message) if `x` is negative. Test your new function
    responses by using the following:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[习题 11.3](ch11.xhtml#ch11exc3) (b)中，[第238页](ch11.xhtml#page_238)的任务是编写一个递归的R函数来计算整数阶乘，给定某个非负整数`x`。现在，修改你的函数，使其在`x`为负时抛出错误（并给出适当的消息）。通过以下方法测试你的新函数响应：
- en: '`x` as `5`'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x`为`5`'
- en: '`x` as `8`'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x`为`8`'
- en: '`x` as `-8`'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x`为`-8`'
- en: 'The idea of *matrix inversion*, briefly discussed in [Section 3.3.6](ch03.xhtml#ch03lev2sec34),
    is possible only for certain square matrices (those with an equal number of columns
    as rows). These inversions can be computed using the `solve` function, for example:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*矩阵求逆*的概念在[第3.3.6节](ch03.xhtml#ch03lev2sec34)中简要讨论，仅对某些方阵（列数与行数相等的矩阵）有效。这些逆矩阵可以通过`solve`函数来计算，例如：'
- en: '[PRE14]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that `solve` throws an error if the supplied matrix cannot be inverted.
    With this in mind, write an R function that attempts to invert each matrix in
    a list, according to the following guidelines:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，如果提供的矩阵无法求逆，`solve`会抛出错误。考虑到这一点，编写一个R函数，尝试根据以下指南对列表中的每个矩阵进行求逆：
- en: – The function should take four arguments.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 该函数应接受四个参数。
- en: '* The list `x` whose members are to be tested for matrix inversion'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* 要测试是否能进行矩阵求逆的列表`x`'
- en: '* A value `noninv` to fill in results where a given matrix member of `x` cannot
    be inverted, defaulting to `NA`'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* 一个值`noninv`，如果`x`的给定矩阵成员无法求逆，则填充结果，默认值为`NA`。'
- en: '* A character string `nonmat` to be the result if a given member of `x` is
    not a matrix, defaulting to `"not a matrix"`'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* 一个字符字符串`nonmat`，如果`x`的给定成员不是矩阵，则返回该结果，默认值为`"not a matrix"`。'
- en: '* A logical value `silent`, defaulting to `TRUE`, to be passed to `try` in
    the body code'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* 一个逻辑值`silent`，默认为`TRUE`，传递给`try`函数的主体代码。'
- en: – The function should first check whether `x` is in fact a list. If not, it
    should throw an error with an appropriate message.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 函数应该首先检查`x`是否为列表。如果不是，应该抛出一个带有适当信息的错误。
- en: – Then, the function should ensure that `x` has at least one member. If not,
    it should throw an error with an appropriate message.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 然后，函数应确保`x`至少包含一个成员。如果没有，应该抛出一个带有适当信息的错误。
- en: – Next, the function should check whether `nonmat` is a character string. If
    not, it should try to coerce it to a character string using an appropriate “as-dot”
    function (see [Section 6.2.4](ch06.xhtml#ch06lev2sec62)), and it should issue
    an appropriate warning.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 接下来，函数应检查`nonmat`是否为字符字符串。如果不是，应该尝试使用适当的“as-dot”函数（见[第6.2.4节](ch06.xhtml#ch06lev2sec62)）将其强制转换为字符字符串，并且应发出适当的警告。
- en: – After these checks, a loop should search each member `i` of the list `x`.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 在这些检查之后，循环应该检查列表`x`的每个成员`i`。
- en: '* If member `i` is a matrix, attempt to invert it with `try`. If it’s invertible
    without error, overwrite member `i` of `x` with the result. If an error is caught,
    then member `i` of `x` should be overwritten with the value of `noninv`.'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* 如果成员`i`是矩阵，尝试使用`try`对其进行求逆。如果可以无误地求逆，则用结果覆盖`x`中的成员`i`。如果捕获到错误，则应用`noninv`的值覆盖`x`中的成员`i`。'
- en: '* If member `i` is not a matrix, then member `i` of `x` should be overwritten
    with the value of `nonmat`.'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* 如果成员`i`不是矩阵，则应用`nonmat`的值覆盖`x`中的成员`i`。'
- en: – Finally, the modified list `x` should be returned.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 最后，修改后的列表`x`应被返回。
- en: 'Now, test your function using the following argument values to make sure it
    responds as expected:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，使用以下参数值测试你的函数，以确保其按预期响应：
- en: '`x` as'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x`为'
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: and all other arguments at default.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以及所有其他参数均使用默认值。
- en: '`x` as in (i), `noninv` as `Inf`, `nonmat` as `666`, `silent` at default.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x`如(i)所示，`noninv`为`Inf`，`nonmat`为`666`，`silent`使用默认值。'
- en: Repeat (ii), but now with `silent=FALSE`.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复(ii)，但这次`silent=FALSE`。
- en: '`x` as'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x`为'
- en: '[PRE16]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: and `noninv` as `"unsuitable matrix"`; all other values at default.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以及`noninv`为`"unsuitable matrix"`；所有其他值使用默认值。
- en: 'Finally, test the error messages by attempting calls to your function with
    the following:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，通过以下调用测试错误信息，确保你的函数能按预期响应：
- en: '`x` as `"hello"`'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x`为`"hello"`'
- en: '`x` as `list()`'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x`为`list()`'
- en: '**12.2 Progress and Timing**'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**12.2 进度和计时**'
- en: R is often used for lengthy numeric exercises, such as simulation or random
    variate generation. For these complex, time-consuming operations, it’s often useful
    to keep track of progress or see how long a certain task took to complete. For
    example, you may want to compare the speed of two different programming approaches
    to a given problem. In this section, you’ll look at ways to time code execution
    and show its progress.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: R常用于长时间的数值计算，如模拟或随机变量生成。对于这些复杂、耗时的操作，通常很有用的是跟踪进度或查看某个任务完成所花的时间。例如，你可能想要比较两种不同编程方法在解决同一问题时的速度。在本节中，你将学习如何计时代码执行并显示其进度。
- en: '***12.2.1 Textual Progress Bars: Are We There Yet?***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***12.2.1 文本进度条：我们快到了吗？***'
- en: A *progress bar* shows how far along R is as it executes a set of operations.
    To show how this works, you need to run code that takes a while to execute, which
    you’ll do by making R *sleep*. The `Sys.sleep` command makes R pause for a specified
    amount of time, in seconds, before continuing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*进度条*显示R在执行一组操作时的进展情况。为了演示这一点，你需要运行一些需要一定时间才能执行的代码，你可以通过让R*休眠*来实现。`Sys.sleep`命令使R在继续执行之前暂停指定的秒数。
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you run this code, R will pause for three seconds before you can continue
    using the console. Sleeping will be used in this section as a surrogate for the
    delay caused by computationally expensive operations, which is where progress
    bars are most useful.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，R将在继续使用控制台之前暂停三秒钟。休眠将被用作在这部分中替代由于计算量大而造成的延迟，这正是进度条最有用的地方。
- en: 'To use `Sys.sleep` in a more common fashion, consider the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要更常规地使用`Sys.sleep`，可以考虑以下方式：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `sleep_test` function is basic—it takes a positive integer `n` and adds
    `1` to the `result` value for `n` iterations. At each iteration, you also tell
    the loop to sleep for a half second. Because of that sleep command, executing
    the following code takes about four seconds to return a result:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep_test`函数是基本的——它接受一个正整数`n`，并在`n`次迭代中，每次都将`result`值加`1`。在每次迭代中，你还会告诉循环休眠半秒。由于有这个休眠命令，执行以下代码大约需要四秒钟才能返回结果：'
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, say you want to track the progress of this type of function as it executes.
    You can implement a textual progress bar with three steps: initialize the bar
    object with `txtProgressBar`, update the bar with `setTxtProgressBar`, and terminate
    the bar with `close`. The next function, `prog_test`, modifies `sleep_test` to
    include those three commands.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想要跟踪这种类型的函数执行进度。你可以通过三步来实现文本进度条：使用`txtProgressBar`初始化进度条对象，使用`setTxtProgressBar`更新进度条，使用`close`终止进度条。下一个函数`prog_test`修改了`sleep_test`，加入了这三个命令。
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Before the `for` loop, you create an object named `progbar` by calling `txtProgressBar`
    with four arguments. The `min` and `max` arguments are numeric values that define
    the limits of the bar. In this case, you set `max=n`, which matches the number
    of iterations of the impending `for` loop. The `style` argument (integer, either
    `1`, `2`, or `3`) and the `char` argument (character string, usually a single
    character) govern the appearance of the bar. Setting `style=1` means the bar will
    simply display a line of `char`; with `char="="` it’ll be a series of equal signs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环之前，你通过调用`txtProgressBar`并传入四个参数来创建一个名为`progbar`的对象。`min`和`max`参数是定义进度条范围的数值。在这种情况下，你设置`max=n`，它与即将执行的`for`循环的迭代次数相匹配。`style`参数（整数，可以是`1`、`2`或`3`）和`char`参数（字符字符串，通常是单个字符）决定了进度条的外观。设置`style=1`表示进度条将仅显示一行`char`；如果`char="="`，则会显示一系列等号。
- en: Once this object is created, you have to instruct the bar to actually progress
    during execution with a call to `setTxtProgressBar`. You pass in the bar object
    to update (`progbar`) and the `value` it should update to (in this case, `i`).
    Once complete (after exiting the loop), the progress bar must be terminated with
    a call to `close`, passing in the bar object of interest. Import and execute `prog_test`,
    and you’ll see the line of `"="` drawn in steps as the loop completes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了这个对象，你需要通过调用`setTxtProgressBar`来指示进度条在执行过程中实际前进。你将进度条对象（`progbar`）和需要更新的`value`（在这种情况下是`i`）传递给它。完成后（退出循环之后），进度条必须通过调用`close`来终止，传入相关的进度条对象。导入并执行`prog_test`，你将看到等号`"="`在循环完成时逐步绘制出来。
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The width of the bar is, by default, determined by the width of the R console
    pane upon execution of the `txtProgressBar` command. You can customize the bar
    a bit by changing the `style` and `char` arguments. Choosing `style=3`, for example,
    shows the bar as well as a “percent completed” counter. Some packages offer more
    elaborate options too, such as pop-up widgets, but the textual version is the
    simplest and most universally compatible version across different systems.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 进度条的宽度默认由执行`txtProgressBar`命令时，R控制台窗格的宽度决定。你可以通过改变`style`和`char`参数来稍微定制进度条。例如，选择`style=3`会显示进度条，并且还会有一个“完成百分比”计数器。一些包还提供了更复杂的选项，比如弹出小部件，但文本版本是最简单且在不同系统中兼容性最好的版本。
- en: '***12.2.2 Measuring Completion Time: How Long Did It Take?***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***12.2.2 测量完成时间：需要多长时间？***'
- en: If you want to know how long a computation takes to complete, you can use the
    `Sys.time` command. This command outputs an object that details current date and
    time information based on your system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道一个计算任务需要多长时间才能完成，可以使用`Sys.time`命令。该命令输出一个对象，详细列出基于你系统的当前日期和时间信息。
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can store objects like these before and after some code and then compare
    them to see how much time has passed. Enter this in the editor:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在某些代码执行前后存储这些对象，然后比较它们，以查看经过了多少时间。在编辑器中输入以下内容：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now highlight all four lines and execute them in the console.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在高亮显示这四行并在控制台中执行它们。
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By executing this entire code block together, you get an easy measure of the
    total completion time in a nicely formatted string printed to the console. Note
    that there’s a small time cost for interpreting and invoking any commands, in
    addition to the three seconds you tell R to sleep. This time will vary between
    computers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一起执行整个代码块，你可以轻松地衡量总完成时间，并将格式良好的字符串打印到控制台。请注意，解释和调用任何命令都需要一点时间，除了你告诉R休眠的三秒钟外，这个时间在不同计算机之间会有所不同。
- en: If you need more detailed timing reports, there are more sophisticated tools.
    For example, you can use `proc.time()` to receive not just the total elapsed “wall
    clock” time but also computer-related CPU timings (see the definitions in the
    help file `?proc.time`). To time a single expression, you can also use the `system.time`
    function (which uses the same detail of output as `proc.time`). There are also
    *benchmarking* tools (formal or systematic comparisons of different approaches)
    for timing your code; see, for example, the `rbenchmark` package ([Kusnierczyk,
    2012](ref.xhtml#ref38)). However, for everyday use, the time-object differencing
    approach used here is easy to interpret and provides a good indication of the
    computational expense.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更详细的计时报告，有更复杂的工具可供使用。例如，你可以使用`proc.time()`来获得不仅是总的“墙钟”时间，还包括计算机相关的CPU时间（请参见帮助文件`?proc.time`中的定义）。要计时一个单独的表达式，你还可以使用`system.time`函数（它的输出细节与`proc.time`相同）。还有*基准测试*工具（对不同方法的正式或系统性比较）用于计时你的代码；例如，参见`rbenchmark`包（[Kusnierczyk,
    2012](ref.xhtml#ref38)）。然而，对于日常使用，本文使用的时间对象差分方法易于理解，并提供了关于计算开销的良好指示。
- en: '**Exercise 12.2**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题12.2**'
- en: Modify `prog_test` from [Section 12.2.1](ch12.xhtml#ch12lev2sec108) to include
    an ellipsis in its argument list, intended to take values for the additional arguments
    in `txtProgressBar`; name the new function `prog_test_fancy`. Time how long it
    takes a call to `prog_test_fancy` to execute. Set `50` as `n`, instruct the progress
    bar (through the ellipsis) to use `style=3`, and set the bar character to be `"r"`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[第12.2.1节](ch12.xhtml#ch12lev2sec108)中的`prog_test`，使其参数列表中包含省略号，旨在接收`txtProgressBar`中的附加参数；将新函数命名为`prog_test_fancy`。计时`prog_test_fancy`执行所需的时间。设置`50`为`n`，通过省略号指示进度条使用`style=3`，并将进度条字符设置为`"r"`。
- en: 'In [Section 12.1.2](ch12.xhtml#ch12lev2sec107), you defined a function named
    `myfibvectorTRY` (which itself calls `myfibrec2` from [Section 12.1.1](ch12.xhtml#ch12lev2sec106))
    to return multiple terms from the Fibonacci sequence based on a supplied “term
    vector” `nvec`. Write a new version of `myfibvectorTRY` that includes a progress
    bar of `style=3` and a character of your choosing that increments at each pass
    of the internal `for` loop. Then, do the following:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[第12.1.2节](ch12.xhtml#ch12lev2sec107)中，你定义了一个名为`myfibvectorTRY`的函数（它本身调用了[第12.1.1节](ch12.xhtml#ch12lev2sec106)中的`myfibrec2`），用于根据提供的“项向量”`nvec`返回斐波那契数列的多个项。编写一个新版本的`myfibvectorTRY`，其中包含一个`style=3`的进度条，以及你选择的字符，在每次通过内部`for`循环时递增。然后，执行以下操作：
- en: Use your new function to reproduce the results from the text where `nvec=c(3,2,7,0,9,13)`.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的新函数重新生成文本中`nvec=c(3,2,7,0,9,13)`的结果。
- en: Time how long it takes to use your new function to return the first 35 terms
    of the Fibonacci sequence. What do you notice, and what does this say about your
    recursive Fibonacci functions?
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计时使用你的新函数返回斐波那契数列前35项所需的时间。你注意到了什么？这说明了你的递归斐波那契函数的什么问题？
- en: Remain with the Fibonacci sequence. Write a stand-alone `for` loop that can
    compute, and store in a vector, the same first 35 terms as in (b)(ii). Time it.
    Which approach would you prefer?
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续使用斐波那契数列。编写一个独立的`for`循环，用来计算并存储前35项（与(b)(ii)中的相同）。并进行计时。你更喜欢哪种方法？
- en: '**12.3 Masking**'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**12.3 屏蔽**'
- en: With the plethora of built-in and contributed data and functionality available
    for R, it is virtually inevitable that at some point you will come across objects,
    usually functions, that share the same name in distinctly different loaded packages.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于R中有大量内建和贡献的数据和功能，几乎不可避免地，你会在某些时候遇到那些在不同加载的包中共享相同名称的对象，通常是函数。
- en: So, what happens in those instances? For example, say you define a function
    with the same name as a function in an R package that you have already loaded.
    R responds by *masking* one of the objects—that is, one object or function will
    take precedence over the other and assume the object or function name, while the
    masked function must be called with an additional command. This protects objects
    from overwriting or blocking one another. In this section, you’ll look at the
    two most common masking situations in R.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在那些情况下会发生什么呢？例如，假设你定义了一个与已加载的R包中的函数同名的函数。R会通过*屏蔽*其中一个对象来响应——也就是说，一个对象或函数将优先于另一个，并假定该对象或函数的名称，而被屏蔽的函数必须通过额外的命令进行调用。这可以防止对象互相覆盖或阻塞。在本节中，你将了解R中最常见的两种屏蔽情况。
- en: '***12.3.1 Function and Object Distinction***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***12.3.1 函数与对象的区别***'
- en: When two functions or objects in different environments have the same name,
    the object that comes earlier in the search path will mask the later one. That
    is, when the object is sought, R will use the object or function it finds first,
    and you’ll need extra code to access the other, masked version. Remember, you
    can see the current search path by executing `search()`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当不同环境中的两个函数或对象具有相同的名称时，搜索路径中较早的对象会覆盖较晚的对象。也就是说，当搜索该对象时，R 会使用它首先找到的对象或函数，且你需要额外的代码才能访问另一个被覆盖的版本。记住，你可以通过执行
    `search()` 来查看当前的搜索路径。
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When R searches, the function or object that falls closest to the start of
    the search path (the global environment) is reached first and masks the function
    or object of the same name that occurs somewhere later in the search path. To
    see a simple example of masking, you’ll define a function with the same name as
    a function in the base package: `sum`. Here’s how `sum` works normally, adding
    up all the elements in the vector `foo`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当 R 搜索时，搜索路径中最接近起始位置（全局环境）的函数或对象会首先被找到，并覆盖路径中稍后的同名函数或对象。为了展示遮蔽的简单例子，你将定义一个与基础包中的
    `sum` 函数同名的函数：`sum`。以下是 `sum` 正常工作的方式，它会将向量 `foo` 中的所有元素加起来：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, suppose you were to enter the following function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你输入以下函数：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This version of `sum` takes in a vector `x` and uses a `for` loop to square
    each element before summing them and returning the result. This can be imported
    into the R console without any problem, but clearly, it doesn’t offer the same
    functionality as the (original) built-in version of `sum`. Now, after importing
    the function, if you make a call to `sum`, your version is used.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的 `sum` 接收一个向量 `x`，并使用 `for` 循环将每个元素平方后再求和并返回结果。这可以毫无问题地导入到 R 控制台，但显然，它提供的功能与内建的（原始）版本的
    `sum` 不同。现在，在导入该函数后，如果你调用 `sum`，将使用你自己定义的版本。
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This happens because the user-defined function is stored in the global environment
    (`.GlobalEnv`), which always comes first in the search path. R’s built-in function
    is part of the `base` package, which comes at the end of the search path. In this
    case, the user-defined function is masking the original.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以发生这种情况，是因为用户自定义的函数存储在全局环境（`.GlobalEnv`）中，而全局环境总是位于搜索路径的最前面。R 的内建函数属于 `base`
    包，它位于搜索路径的最后。此时，用户自定义的函数遮蔽了原函数。
- en: Now, if you want R to run the `base` version of `sum`, you have to include the
    name of its package in the call, with a double colon.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你希望 R 运行 `base` 版本的 `sum`，你必须在调用时包括它所属包的名称，并使用双冒号。
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This tells R to use the version in `base`, even though there’s another version
    of the function in the global environment.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这会告诉 R 使用 `base` 中的版本，即使全局环境中有另一个版本的函数。
- en: To avoid any confusion, let’s remove the `sum` function from the global environment.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免任何混淆，让我们从全局环境中移除 `sum` 函数。
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**When Package Objects Clash**'
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**当包对象发生冲突时**'
- en: 'When you load a package, R will notify you if any objects in the package clash
    with other objects that are accessible in the present session. To illustrate this,
    I’ll make use of two contributed packages: the `car` package (you saw this earlier
    in [Exercise 8.1](ch08.xhtml#ch8exc1) (b) on [page 162](ch08.xhtml#page_162))
    and the `spatstat` package (you’ll use this in [Part V](part05.xhtml#part05)).
    After ensuring these two packages are installed, when I load them in the following
    order, I see this message:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你加载一个包时，R 会通知你包中的任何对象是否与当前会话中可以访问的其他对象发生冲突。为了说明这一点，我将使用两个贡献包：`car` 包（你在 [练习
    8.1](ch08.xhtml#ch8exc1) (b) 中见过，位于 [第 162 页](ch08.xhtml#page_162)）和 `spatstat`
    包（你将在 [第 V 部分](part05.xhtml#part05)中使用）。确保这两个包已经安装后，当我按照以下顺序加载它们时，我会看到这个信息：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This indicates that the two packages each have an object with the same name—`ellipse`.
    R has automatically notified you that this object is being masked. Note that the
    functionality of both `car` and `spatstat` remains completely available; it’s
    just that the `ellipse` objects require some distinction should they be needed.
    Using `ellipse` at the prompt will access `car`’s object since that package was
    loaded more recently. To use `spatstat`’s version, you must type `spatstat::ellipse`.
    These rules also apply to accessing the respective help files.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明两个包中各自有一个同名对象——`ellipse`。R 自动通知你该对象正在被遮蔽。注意，`car` 和 `spatstat` 的功能仍然完全可用；只是如果需要使用
    `ellipse` 对象，它们需要加以区分。使用提示符中的 `ellipse` 将访问 `car` 的对象，因为该包加载得更晚。若要使用 `spatstat`
    的版本，必须输入 `spatstat::ellipse`。这些规则同样适用于访问各自的帮助文件。
- en: 'A similar notification occurs when you load a package with an object that’s
    masked by a global environment object (a global environment object will always
    take precedence over a package object). To see an example, you can load the `MASS`
    package ([Venables and Ripley, 2002](ref.xhtml#ref69)), which is included with
    R but isn’t automatically loaded. Continuing in the current R session, create
    the following object:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你加载一个包含被全局环境对象（全局环境对象总是优先于包对象）的对象时，会出现类似的通知。要查看一个例子，你可以加载`MASS`包（[Venables和Ripley，2002](ref.xhtml#ref69)），这个包是R自带的，但不会自动加载。继续在当前的R会话中，创建以下对象：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, suppose you need to load `MASS`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你需要加载`MASS`。
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Upon loading the package, you’re informed that the `cats` object you’ve just
    created is masking an object of the same name in `MASS`. (As you can see with
    `?MASS::cats`, this object is a data frame with weight measurements of household
    felines.) Furthermore, it appears `MASS` also shares an object name with `spatstat`—`area`.
    The same kind of “package masking” message as shown earlier is also displayed
    for that particular item.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 加载包后，你会被通知到，你刚创建的`cats`对象正在遮蔽`MASS`中同名的对象。（如你在`?MASS::cats`中所见，这个对象是一个包含家猫体重测量的
    数据框。）此外，`MASS`似乎也与`spatstat`共享一个对象名称——`area`。对于该特定项，显示了与之前相同的“包遮蔽”消息。
- en: '**Unmounting Packages**'
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**卸载包**'
- en: 'You can unmount loaded packages from the search path. With the packages loaded
    in this discussion, my current search path looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从搜索路径中卸载已加载的包。根据本讨论中加载的包，我当前的搜索路径如下：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, suppose you don’t need `car` anymore. You can remove it with the `detach`
    function as follows.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你不再需要`car`。你可以通过`detach`函数将其移除，方法如下。
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This removes the elected package from the path, unloading its namespace. Now,
    the functionality of `car` is no longer immediately available, and `spatstat`’s
    `ellipsis` function is no longer masked.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从路径中移除选定的包，卸载其命名空间。现在，`car`的功能不再立即可用，`spatstat`的`ellipsis`函数也不再被遮蔽。
- en: '**NOTE**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As contributed packages get updated by their maintainers, they may include
    new objects that spark new maskings or remove or rename objects that previously
    caused maskings (when compared with other contributed packages). The specific
    maskings illustrated here among* `car`, `spatstat`*, and* `MASS` *occur at the
    time of writing with the versions available and may change in the future.*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*随着贡献包被维护者更新，它们可能会包含新的对象，导致新的遮蔽，或者移除或重命名以前引起遮蔽的对象（与其他贡献包相比）。这里所示的`car`、`spatstat`和`MASS`之间的具体遮蔽发生在写作时的版本，并可能在未来发生变化。*'
- en: '***12.3.2 Data Frame Variable Distinction***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***12.3.2 数据框变量区分***'
- en: 'There’s one other common situation in which you’ll be explicitly notified of
    masking: when you add a data frame to the search path. Let’s see how this works.
    Continuing in the current workspace, define the following data frame:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种常见情况，你会明确收到遮蔽通知：当你将一个数据框添加到搜索路径时。让我们看看这如何工作。继续在当前工作区中，定义以下数据框：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The data frame `foo` has three column variables: `person`, `sex`, and `height`.
    To access one of these columns, normally you need to use the `$` operator and
    enter something like `foo$surname`. However, you can *attach* a data frame directly
    to your search path, which makes it easier to access a variable.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框`foo`有三个列变量：`person`、`sex`和`height`。要访问这些列中的一个，通常需要使用`$`运算符，输入类似`foo$surname`的内容。然而，你可以*附加*一个数据框到你的搜索路径，这样更容易访问一个变量。
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now the `surname` variable is directly accessible.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`surname`变量可以直接访问了。
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This saves you from having to enter `foo$` every time you want to access a variable,
    which can be a handy shortcut if your analysis deals exclusively with one static,
    unchanging data frame. However, if you forget about your attached objects, they
    can cause problems later, especially if you continue to mount more objects onto
    the search path in the same session. For example, say you enter another data frame.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以避免每次访问一个变量时都输入`foo$`，如果你的分析完全处理一个静态且不变的数据框，这可以是一个便捷的快捷方式。然而，如果你忘记了附加的对象，它们可能会在之后造成问题，特别是如果你在同一会话中继续将更多对象挂载到搜索路径中。例如，假设你输入了另一个数据框。
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Then add it to the search path too.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后也将其添加到搜索路径中。
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The notification tells you that the `bar` object now precedes `foo` in the search
    path.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通知告诉你，`bar`对象现在在搜索路径中排在`foo`之前。
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As a result, any direct use of either `sex` or `surname` will now access `bar`’s
    contents, not `foo`’s. Meanwhile, the unmasked variable `height` from `foo` is
    still directly accessible.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，任何直接使用`sex`或`surname`的操作现在将访问`bar`的内容，而不是`foo`的内容。同时，未遮蔽的变量`height`来自`foo`，仍然可以直接访问。
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is a pretty simple example, but it highlights the potential for confusion
    when data frames, lists, or other objects are added to the search path. Mounting
    objects this way can quickly become difficult to track, especially for large data
    sets with many different variables. For this reason, it’s best to avoid attaching
    objects this way as a general guideline—unless, as stated earlier, you’re working
    exclusively with one data frame.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的例子，但它突出了在将数据框、列表或其他对象添加到搜索路径时可能出现的混淆。以这种方式挂载对象可能会迅速变得难以追踪，尤其是对于包含许多不同变量的大型数据集。因此，作为一般准则，最好避免以这种方式附加对象——除非如前所述，你仅仅在处理一个数据框。
- en: Note that `detach` can be used to remove objects from the search path, in a
    similar way as you saw with packages. In this case, you can simply enter the object
    name itself.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`detach`可以用于从搜索路径中移除对象，方法与之前看到的移除包的方法类似。在这种情况下，你只需输入对象的名称即可。
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Important Code in This Chapter**'
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**本章重要代码**'
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| **函数/操作符** | **简要描述** | **首次出现** |'
- en: '| --- | --- | --- |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `warning` | Issue warning | [Section 12.1.1](ch12.xhtml#ch12lev2sec106),
    [p. 242](ch12.xhtml#page_242) |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `warning` | 发出警告 | [第12.1.1节](ch12.xhtml#ch12lev2sec106), [第242页](ch12.xhtml#page_242)
    |'
- en: '| `stop` | Throw error | [Section 12.1.1](ch12.xhtml#ch12lev2sec106), [p. 242](ch12.xhtml#page_242)
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `stop` | 抛出错误 | [第12.1.1节](ch12.xhtml#ch12lev2sec106), [第242页](ch12.xhtml#page_242)
    |'
- en: '| `try` | Attempt error catch | [Section 12.1.2](ch12.xhtml#ch12lev2sec107),
    [p. 244](ch12.xhtml#page_244) |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `try` | 尝试捕获错误 | [第12.1.2节](ch12.xhtml#ch12lev2sec107), [第244页](ch12.xhtml#page_244)
    |'
- en: '| `Sys.sleep` | Sleep (pause) execution | [Section 12.2.1](ch12.xhtml#ch12lev2sec108),
    [p. 249](ch12.xhtml#page_249) |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `Sys.sleep` | 睡眠（暂停）执行 | [第12.2.1节](ch12.xhtml#ch12lev2sec108), [第249页](ch12.xhtml#page_249)
    |'
- en: '| `txtProgressBar` | Initialize progress bar | [Section 12.2.1](ch12.xhtml#ch12lev2sec108),
    [p. 249](ch12.xhtml#page_249) |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `txtProgressBar` | 初始化进度条 | [第12.2.1节](ch12.xhtml#ch12lev2sec108), [第249页](ch12.xhtml#page_249)
    |'
- en: '| `setTxtProgressBar` | Increment progress bar | [Section 12.2.1](ch12.xhtml#ch12lev2sec108),
    [p. 249](ch12.xhtml#page_249) |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `setTxtProgressBar` | 增加进度条 | [第12.2.1节](ch12.xhtml#ch12lev2sec108), [第249页](ch12.xhtml#page_249)
    |'
- en: '| `close` | Close progress bar | [Section 12.2.1](ch12.xhtml#ch12lev2sec108),
    [p. 249](ch12.xhtml#page_249) |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `close` | 关闭进度条 | [第12.2.1节](ch12.xhtml#ch12lev2sec108), [第249页](ch12.xhtml#page_249)
    |'
- en: '| `Sys.time` | Get local system time | [Section 12.2.2](ch12.xhtml#ch12lev2sec109),
    [p. 250](ch12.xhtml#page_250) |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `Sys.time` | 获取本地系统时间 | [第12.2.2节](ch12.xhtml#ch12lev2sec109), [第250页](ch12.xhtml#page_250)
    |'
- en: '| `detach` | Remove library/object from path | [Section 12.3.1](ch12.xhtml#ch12lev2sec110),
    [p. 255](ch12.xhtml#page_255) |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `detach` | 从路径中移除库/对象 | [第12.3.1节](ch12.xhtml#ch12lev2sec110), [第255页](ch12.xhtml#page_255)
    |'
- en: '| `attach` | Attach object to search path | [Section 12.3.2](ch12.xhtml#ch12lev2sec111),
    [p. 256](ch12.xhtml#page_256) |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `attach` | 将对象附加到搜索路径 | [第12.3.2节](ch12.xhtml#ch12lev2sec111), [第256页](ch12.xhtml#page_256)
    |'
