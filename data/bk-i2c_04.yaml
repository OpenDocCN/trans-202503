- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: A Software Implementation of the I²C Bus
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: I²C总线的软件实现
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Although the vast majority of widely used I²C functionality comes as part of
    a peripheral IC or a CPU on an SBC, occasionally you may need to develop firmware
    for hardware that does not provide I²C support. In that case, you’ll have to implement
    the I²C protocol in software.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管广泛使用的大多数I²C功能是作为外围集成电路（IC）或SBC上的CPU的一部分提供的，但有时你可能需要为不提供I²C支持的硬件开发固件。在这种情况下，你将需要在软件中实现I²C协议。
- en: This chapter shows how to implement both controller and peripheral devices using
    nothing more than GPIO pins on a standard microcontroller (MCU). I will use the
    Teensy 3.2 as an example, though the same principles apply to almost any device
    with at least two programmable I/O pins. If you want to use this code for some
    other MCU, you’ll probably have to tweak and optimize it a bit, particularly on
    MCUs with lower performance and less memory than the Teensy 3.2\. Chapter 17 (online
    at [https://bookofi2c.randallhyde.com](https://bookofi2c.randallhyde.com)) provides
    an example of just such an optimization.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何仅使用标准微控制器（MCU）上的GPIO引脚实现控制器和外围设备。我将以Teensy 3.2为例，尽管相同的原理适用于几乎任何具有至少两个可编程I/O引脚的设备。如果你想将这段代码用于其他MCU，可能需要稍作调整和优化，特别是在性能较低、内存较少的MCU上，比如Teensy
    3.2。第17章（在线阅读：[https://bookofi2c.randallhyde.com](https://bookofi2c.randallhyde.com)）提供了这样的优化示例。
- en: This chapter does not provide a drop-in, ready-to-use, software-based I²C library.
    Almost any MCU you will use in an environment where you need I²C will provide
    hardware support—the Teensy 3.2 itself provides two independent hardware I²C buses.
    That said, a software implementation makes it clearer exactly what is happening
    in the hardware, so you’ll benefit from studying this code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章并未提供一个即插即用的、现成可用的基于软件的I²C库。几乎任何你将在需要I²C的环境中使用的MCU都提供硬件支持——Teensy 3.2本身提供了两个独立的硬件I²C总线。也就是说，软件实现使硬件发生的具体情况更加清晰，因此你将从学习这段代码中受益。
- en: 3.1 A Software I²C Implementation on the Teensy 3.2
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 在Teensy 3.2上的软件I²C实现
- en: The Teensy 3.2 is a 32-bit ARM (Cortex M4) that runs at 72 MHz, though it is
    often overclocked to 96 MHz. It features 256KB of flash storage for code, 64KB
    of RAM for data, 2,048KB of EEPROM for nonvolatile storage, and a huge amount
    of I/O, including three UARTs, two I²C buses, and one SPI bus, all on a tiny—er,
    *teensy*, approximately 1.4 inch by 0.7 inch—PCB. Teensy has its own 3.3-V regulator
    on board, so the processor runs off 3.3 V, but all the I/O pins are 5-V tolerant.
    Typically, you program the Teensy using the Arduino IDE, and most Arduino code
    runs just fine on the Teensy 3.2.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Teensy 3.2是一款32位ARM（Cortex M4）处理器，运行频率为72 MHz，尽管通常会超频到96 MHz。它具有256KB的闪存用于存储代码，64KB的RAM用于存储数据，2,048KB的EEPROM用于非易失性存储，并且提供大量I/O接口，包括三个UART、两个I²C总线和一个SPI总线，所有这些都集成在一块小型的——呃，*teensy*，大约1.4英寸
    x 0.7英寸——PCB上。Teensy配有自己的3.3V稳压器，因此处理器以3.3V运行，但所有I/O引脚均支持5V容忍。通常，你通过Arduino IDE编程Teensy，大多数Arduino代码都能在Teensy
    3.2上运行。
- en: 'Software implementation of I²C on the Teensy 3.2 is primarily an educational
    exercise: since the Teensy 3.2 supports two hardware I²C interfaces, there are
    few reasons to run a software-based I²C system. The Teensy is very powerful, and
    it’s possible to write the I²C module in C/C++ without often having to drop down
    into hardware-specific code. Most of the code in this chapter is stock Arduino
    code, which should be much more approachable and understandable than I²C optimized
    for lower-powered MCUs.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Teensy 3.2上实现I²C的软件主要是一个教育性练习：由于Teensy 3.2支持两个硬件I²C接口，因此没有太多理由运行基于软件的I²C系统。Teensy非常强大，可以用C/C++编写I²C模块，而无需频繁使用硬件特定的代码。本章中的大部分代码是标准Arduino代码，这比为低功耗MCU优化的I²C代码更容易接近和理解。
- en: 'The following subsections describe two variants of a software-based I²C system
    on the Teensy: a controller implementation and a peripheral implementation. For
    those interested in a hardware-based I²C implementation, see Chapter 6 and section
    11.1, “Teensy 4.*x* Controller Programming,” in Chapter 11.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节描述了Teensy上基于软件的I²C系统的两种变体：控制器实现和外围设备实现。对于那些有兴趣了解基于硬件的I²C实现的读者，请参阅第6章和第11章第11.1节《Teensy
    4.*x*控制器编程》。
- en: 3.1.1 A Software-Based I²C Controller for the Teensy 3.2
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 Teensy 3.2的软件I²C控制器
- en: The code in [Listing 3-1](#listing3-1) implements a software-based I²C controller
    running on a Teensy 3.2 by using Arduino library calls. I discuss each function
    and various code segments in the text between various sections of the listing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-1](#listing3-1) 中的代码实现了一个基于软件的 I²C 控制器，它通过使用 Arduino 库调用，在 Teensy 3.2
    上运行。我将在列出各个代码段之间的文本中讨论每个函数及其代码段。'
- en: This code is just meant to demonstrate how to implement an I²C controller in
    software, so don’t treat it as an I²C library module for production use. It’s
    intended to clarify the I²C protocol in a concrete and formal manner for purely
    educational purposes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码仅用于演示如何在软件中实现 I²C 控制器，因此不要将其视为用于生产的 I²C 库模块。它旨在以具体和正式的方式阐明 I²C 协议，仅用于教育目的。
- en: As a test example, this particular program reads a value from an Adafruit ADS1115
    I²C ADC module from input A0, translates the binary input to the comparable range
    on the MCP4725, and then writes the result to a SparkFun MCP4725 DAC module (see
    [Figure 3-1](#figure3-1) for the wiring diagram).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为测试示例，本程序从 Adafruit ADS1115 I²C ADC 模块的输入 A0 读取一个值，将二进制输入转换为与 MCP4725 对应的范围，然后将结果写入
    SparkFun MCP4725 DAC 模块（请参阅 [图 3-1](#figure3-1) 中的接线图）。
- en: '![](image_fi/502468c03/f03001.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c03/f03001.png)'
- en: 'Figure 3-1: Circuit for the Teensy-based controller example'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：基于 Teensy 控制器的电路示例
- en: Inputting a voltage in the range of 0 V to 4.1 V should produce a similar voltage
    on the DAC output. This example program tests both reading from and writing to
    I²C peripherals using the software-based I²C controller software.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输入电压范围为 0 V 到 4.1 V 时，应在 DAC 输出端产生相似的电压。此示例程序测试了使用基于软件的 I²C 控制器软件对 I²C 外设的读取和写入。
- en: The `MCP4725_ADDR` and `ADS1115_ADDR` symbols specify the addresses of these
    modules. The DAC address should be 0x60 or 0x61, depending on the address jumper
    on the SparkFun board (the schematic in [Figure 3-1](#figure3-1) wires ADDR to
    Gnd, selecting address 0x60). Note that although the code in [Listing 3-1](#listing3-1)
    writes to a SparkFun board, you could also write to an Adafruit MCP4725 breakout
    board. In that case, the DAC address would be 0x62 or 0x63, depending on the on-board
    address setting. The ADS1115 address would be 0x48, 0x49, 0x4A, or 0x4B, depending
    how the address pin is jumpered on the breakout board; the schematic in [Figure
    3-1](#figure3-1) assumes you’ve wired the ADDR pin to Gnd to use address 0x48\.
    See the Adafruit documentation for more details (in “For More Information” at
    the end of this chapter).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`MCP4725_ADDR` 和 `ADS1115_ADDR` 符号指定了这些模块的地址。DAC 地址应为 0x60 或 0x61，具体取决于 SparkFun
    板上的地址跳线（[图 3-1](#figure3-1) 中的原理图将 ADDR 引脚接地，从而选择地址 0x60）。请注意，尽管 [列表 3-1](#listing3-1)
    中的代码写入了 SparkFun 板，你也可以写入 Adafruit MCP4725 扩展板。在这种情况下，DAC 地址为 0x62 或 0x63，具体取决于扩展板上的地址设置。ADS1115
    地址为 0x48、0x49、0x4A 或 0x4B，具体取决于扩展板上的地址引脚跳线设置；[图 3-1](#figure3-1) 中的原理图假设你将 ADDR
    引脚接地使用地址 0x48。有关更多详细信息，请参阅 Adafruit 文档（在本章末尾的“更多信息”部分）。'
- en: The following code fragment begins [Listing 3-1](#listing3-1), which continues
    throughout this section with interspersed comments and annotations. You can find
    the full code file, *Listing3-1.ino*, at [https://bookofi2c.randallhyde.com](https://bookofi2c.randallhyde.com).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段开始于 [列表 3-1](#listing3-1)，在本节中继续，并穿插有注释和说明。你可以在 [https://bookofi2c.randallhyde.com](https://bookofi2c.randallhyde.com)
    找到完整的代码文件 *Listing3-1.ino*。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `SCL` and `SDA` symbols define the Arduino-based pin numbers to use for
    the I²C clock and data lines ❶. Pins 0 and 1 were arbitrary choices. Any available
    digital I/O pins will work fine here.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`SCL` 和 `SDA` 符号定义了用于 I²C 时钟和数据线的 Arduino 基础引脚号 ❶。引脚 0 和 1 是任意选择的。任何可用的数字 I/O
    引脚都可以正常使用。'
- en: The `pinWrite` symbol maps to an Arduino-compatible `digitalWrite()` function
    ❷. Under normal circumstances, this would be the `digitalWrite()` function itself.
    However, the Teensy library has a special function, `digitalWriteFast()`, that
    is call-compatible with the Arduino `digitalWrite()` function but runs about three
    times faster by mapping `pinWrite()` to the Teensy function. If you’re going to
    run this code on a different MCU, change the definition to `digitalWrite()`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`pinWrite` 符号映射到 Arduino 兼容的 `digitalWrite()` 函数 ❷。在正常情况下，这将是 `digitalWrite()`
    函数本身。然而，Teensy 库有一个特殊的函数 `digitalWriteFast()`，它与 Arduino `digitalWrite()` 函数兼容调用，但通过将
    `pinWrite()` 映射到 Teensy 函数，运行速度大约是原来的三倍。如果你打算在不同的 MCU 上运行此代码，请将定义更改为 `digitalWrite()`。'
- en: The I²C SDA and SCL lines are *bidirectional*; that is, the controller must
    be able to read data from these two lines as well as write data to them. As a
    general rule, Arduino GPIO pins are inputs or outputs, but not both at the same
    time. To simulate bidirectional I/O, the Teensy 3.2 software-based I²C module
    takes advantage of the fact that Arduino-compatible GPIO pins can be dynamically
    switched between inputs and outputs. For the most part, the controller always
    knows when the signal line must be input or output so it can switch the pin’s
    mode on the fly to accommodate the I²C bus’s needs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 的 SDA 和 SCL 引脚是 *双向* 的；也就是说，控制器必须能够从这两条引脚读取数据，同时也能向它们写入数据。一般来说，Arduino 的
    GPIO 引脚要么是输入，要么是输出，但不能同时兼具两者功能。为了模拟双向 I/O，Teensy 3.2 基于软件的 I²C 模块利用了 Arduino 兼容
    GPIO 引脚可以在输入和输出之间动态切换的特性。在大多数情况下，控制器总是知道信号线何时需要为输入或输出，因此它可以即时切换引脚模式，以适应 I²C 总线的需求。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `setSCL()` ❶, `clrSCL()` ❷, `setSDA()` ❸, and `clrSDA()` ❹ functions are
    responsible for writing a 0 or a 1 on the SCL and SDA lines. Writing a 1 to either
    line consists of switching the corresponding pin to the input mode. This puts
    the pin in a high-impedance state (open-collector or tri-state) without putting
    an actual signal on the line. The pullup resistor on the line then pulls the line
    high (1). Writing a 0 to either pin consists of changing the pin’s mode to output
    and then writing a 0 to that pin. This pulls the line low, even in the presence
    of the pullup resistor.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`setSCL()` ❶、`clrSCL()` ❷、`setSDA()` ❸ 和 `clrSDA()` ❹ 函数负责在 SCL 和 SDA 引脚上写入
    0 或 1。向任一引脚写入 1 的过程是将相应的引脚切换为输入模式。这会将引脚置于高阻抗状态（开集电极或三态），而不会在引脚上输出实际信号。引脚上的上拉电阻随后将引脚拉高（1）。向任一引脚写入
    0 的过程是将引脚模式更改为输出模式，然后将 0 写入该引脚。这会将引脚拉低，即使在有上拉电阻的情况下也是如此。'
- en: It is important to leave the SCL and SDA lines high when you are not actively
    writing a 0 to these lines. This is a requirement not only of this software but
    also of the I²C bus in general—remember, other devices may be trying to pull the
    lines low.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你没有主动向 SCL 和 SDA 引脚写入 0 时，保持这些引脚的高电平是非常重要的。这不仅是软件的要求，也是 I²C 总线的一般要求——记住，其他设备可能正在试图将这些引脚拉低。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `readSCL()` function ❶ reads the data currently on the SCL line. The `readSDA()`
    function ❷ reads the data currently on the SDA line. The I²C standard requires
    filtering on the inputs to remove any glitches less than or equal to 50 nsec (nanoseconds)
    in duration ❸. Typically, this is done with an active filter (hardware) design.
    Although it is possible to attach such hardware to the pins on your microcontroller,
    this software-only I²C package performs this glitch filtering in software by reading
    all inputs twice and returning only once it has read the same value twice in a
    row. On most microprocessors, this will filter out glitches that are significantly
    greater than 50 nsec in length. However, as this software implementation handles
    only standard-speed I²C operation (100 kHz), anything less than a microsecond
    could easily be considered noise.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`readSCL()` 函数❶读取当前 SCL 引脚上的数据。`readSDA()` 函数❷读取当前 SDA 引脚上的数据。I²C 标准要求对输入进行滤波，以去除持续时间小于或等于
    50 纳秒（ns）的任何毛刺❸。通常，这通过主动滤波器（硬件）设计来实现。虽然可以将这样的硬件附加到微控制器的引脚上，但此软件实现的 I²C 包通过在软件中进行毛刺滤波来实现，方法是将所有输入读取两次，并且仅在连续两次读取相同值时返回。在大多数微处理器上，这将滤除长度明显大于
    50 纳秒的毛刺。然而，由于该软件实现仅处理标准速度 I²C 操作（100 kHz），所以任何小于一微秒的信号都可能被视为噪声。'
- en: These functions do not switch the pin to input mode before reading them. Most
    of the time these functions get called several times in a row, so it’s more efficient
    to have the caller set the pin mode rather than having these functions set the
    mode every time they get called. Beyond that, some code calls these functions
    to verify that the signal lines have actually reached their final state after
    being set to 0 (handling delays due to bus capacitance, and so on).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在读取之前并不会将引脚切换为输入模式。大多数情况下，这些函数会连续被调用几次，因此让调用者设置引脚模式比每次调用时让这些函数设置模式更高效。此外，有些代码调用这些函数来验证信号线在设置为
    0 后是否已实际达到最终状态（处理由于总线电容等造成的延迟）。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `setStartCond()` ❶ function allows the caller to take control of the I²C
    bus. This function handles two primary tasks: it makes sure the bus isn’t currently
    in use, and then if the bus is available, it transmits a start signal on the bus
    to claim the bus for its own use.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`setStartCond()` ❶ 函数允许调用者控制 I²C 总线。该函数处理两个主要任务：确保总线当前未被使用，然后如果总线可用，它会在总线上发送启动信号以占用总线。'
- en: To see if the bus is already in use, the `setStartCond()` ❷ function checks
    the SCL and SDA lines every microsecond for 10 μsec. If either line is (or goes)
    low during these 10 μsec, the bus is in use, and this function returns failure
    (`0`). If both lines remain high for the duration, the bus is free, and the code
    can acquire the bus for its own purposes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查总线是否已被使用，`setStartCond()` ❷ 函数每微秒检查一次 SCL 和 SDA 线，持续 10 微秒。如果在这 10 微秒内，任一线路为低（或变为低），则表示总线正在使用中，此函数返回失败（`0`）。如果两条线在此期间始终为高，说明总线空闲，代码可以占用总线进行使用。
- en: To acquire the bus, the code places the start condition on it ❸. This start
    condition begins with both lines high for 5 μsec (one-half clock cycle). This
    is followed by a transition on the SDA line from high to low and then a half clock
    period with SDA low and SCL high (see [Figure 3-2](#figure3-2)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取总线，代码在总线上设置启动条件 ❸。该启动条件以两条线高电平持续 5 微秒（半个时钟周期）开始，接着 SDA 线从高电平转为低电平，然后 SDA
    为低电平，SCL 为高电平，持续半个时钟周期（见 [图 3-2](#figure3-2)）。
- en: '![](image_fi/502468c03/f03002.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c03/f03002.png)'
- en: 'Figure 3-2: The start condition'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2：启动条件
- en: If the `setStartCond()` function successfully places the start condition on
    the bus, it returns `1` as the function result. When this function returns to
    the caller, the caller tests the return result to determine whether it can begin
    using the I²C bus or whether it must wait and try to obtain the bus another time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `setStartCond()` 函数成功地在总线上设置了启动条件，它会返回 `1` 作为函数结果。当此函数返回给调用者时，调用者会检查返回结果，以确定是否可以开始使用
    I²C 总线，或者是否需要等待并尝试再次获取总线。
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When the software is done transmitting or receiving data and is ready to give
    up the I²C bus, it must put a stop condition on the bus, as shown in the `setStopCond()`
    code ❶.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件完成数据传输或接收，并准备放弃 I²C 总线时，它必须在总线上设置停止条件，如 `setStopCond()` 代码 ❶ 所示。
- en: '[Figure 3-3](#figure3-3) shows the stop condition appearing on the I²C bus.
    The `setStopCode()` function brings the SCL line high (while SDA is low) and then
    pulls SCL high 5 µsec later.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-3](#figure3-3) 显示了在 I²C 总线上出现的停止条件。`setStopCode()` 函数将 SCL 线拉高（同时 SDA
    线为低），然后 5 微秒后再次拉高 SCL 线。'
- en: '![](image_fi/502468c03/f03003.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c03/f03003.png)'
- en: 'Figure 3-3: An I²C stop condition'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-3：I²C 停止条件
- en: The following code demonstrates how to detect and wait for a stop condition.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何检测并等待停止条件。
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If some other controller is already using the I²C bus, this software must wait
    until the other controller is done with the bus. That occurs when the other controller
    places a stop condition on the bus. The `waitForStop()` function watches the bus
    and waits for the stop condition to appear (SCL is high and SDA transitions from
    low to high).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他控制器已经在使用 I²C 总线，软件必须等待直到该控制器完成总线操作。这发生在该控制器在总线上放置停止条件时。`waitForStop()` 函数监视总线，并等待停止条件出现（SCL
    为高，SDA 从低转为高）。
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `sdaOut()` function writes a single bit to the I²C bus. Writing a bit to
    the I²C bus consists of the following sequence:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`sdaOut()` 函数向 I²C 总线写入单个比特。向 I²C 总线写入比特的过程包括以下步骤：'
- en: Set the SCL line low and verify that it is low ❶. Except for the start and stop
    conditions, the SDA line can change only while SCL is low.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 SCL 线设置为低并验证其是否为低 ❶。除了启动和停止条件外，SDA 线只能在 SCL 线为低时发生变化。
- en: Put the bit on the SDA line ❷.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将位设置到 SDA 线 ❷。
- en: Wait about a one-half clock period ❸.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待大约半个时钟周期 ❸。
- en: Verify that the data on the SDA line matches the data just written (that is,
    verify that bus contention is not occurring). Fail (return 0) if the data does
    not match ❹.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 SDA 线上的数据是否与刚刚写入的数据匹配（即验证总线争用没有发生）。如果数据不匹配，则失败（返回 0）❹。
- en: Set the SCL line high ❺.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 SCL 线设置为高 ❺。
- en: Wait for the SCL line to go high (clock stretching and synchronization) ❻.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待 SCL 线变高（时钟延展和同步）❻。
- en: Bus contention occurs if two controllers are trying to access the bus at the
    same time. This code detects bus contention if it writes a 1 to the SDA line and
    reads back a 0, which means the other controller is writing a 0\. The I²C arbitration
    rule is “whoever writes the zero wins.” If this code returns failure to the caller,
    it must cease the transmission and restart it when the next stop condition comes
    along.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 总线争用发生在两个控制器同时尝试访问总线时。如果此代码将 1 写入 SDA 线并读取回 0，表示另一个控制器正在写入 0，从而发生总线争用。I²C 仲裁规则是“谁写
    0，谁赢”。如果此代码返回失败给调用者，必须停止传输，并在下一个停止条件到来时重新启动传输。
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `xmitByte()` function transmits a whole byte across the I²C bus. Obviously,
    this function calls `sdaOut()` eight times to transmit the 8 bits ❶. As per the
    I²C standard, this code ships the bits out from the MSB down to the LSB. If at
    any time a call to `sdaOut()` returns failure, this function also returns failure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`xmitByte()` 函数通过 I²C 总线传输一个完整的字节。显然，此函数调用 `sdaOut()` 八次来传输这 8 位 ❶。根据 I²C 标准，此代码按从
    MSB 到 LSB 的顺序发送比特。如果任何一次调用 `sdaOut()` 返回失败，此函数也将返回失败。'
- en: At the end of the byte transmission, this code sets the SDA line high and issues
    an additional pulse on the SCL line ❷. While SCL is high, this code reads the
    SDA line. This retrieves either the acknowledge bit (0) from the peripheral, or,
    if there is not acknowledgment, a default NAK of 1\. This function returns true
    if the transmission was properly acknowledged, and false otherwise.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 字节传输结束时，代码将 SDA 线设为高电平，并在 SCL 线上发出额外的脉冲 ❷。在 SCL 为高电平时，代码读取 SDA 线。这会获取外设的确认位（0），或者如果没有确认，则为默认的
    NAK（1）。如果传输得到正确确认，函数返回 `true`，否则返回 `false`。
- en: After reading the acknowledgment bit, this code sets SCL low and continuously
    reads the line, waiting for it to actually go low ❸.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取确认位后，代码将 SCL 设为低电平并持续读取该线，等待其实际变为低电平 ❸。
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `xmitBytes()` function handles a complete I²C write transmission. The caller
    passes it the I²C address of the peripheral, an array of bytes (along with a count),
    and a special “stop” flag, and this function sends out the appropriate start condition
    and address byte and writes all the data bytes. If the `addStop` flag is `true`,
    this function also attaches a stop condition to the end of the transmission. If
    `addStop` is `false`, this function transmits the data without the stop condition—presumably
    because you want to hold the I²C bus and issue a repeated start condition shortly
    thereafter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`xmitBytes()` 函数处理完整的 I²C 写入传输。调用者传递给它外设的 I²C 地址、一个字节数组（以及一个计数），以及一个特殊的“停止”标志，函数会发送适当的起始条件和地址字节，并写入所有数据字节。如果
    `addStop` 标志为 `true`，则该函数还会在传输结束时附加一个停止条件。如果 `addStop` 为 `false`，则该函数在没有停止条件的情况下传输数据——可能是因为你希望保持
    I²C 总线并在稍后发出重复的起始条件。'
- en: This function returns `true` or `false` based on success or failure of the transmission.
    If this function returns `false`, either the bus is already in use or there was
    bus contention, and this code lost the arbitration battle. Whatever the reason,
    if this function returns `false`, the caller must retry the transmission later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数根据传输的成功或失败返回 `true` 或 `false`。如果此函数返回 `false`，可能是总线已被占用或发生了总线争用，并且该代码未能赢得仲裁。无论原因是什么，如果此函数返回
    `false`，调用者必须稍后重试传输。
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `sdaIn()` function reads a single bit from the I²C bus. This function is
    similar to `sdaOut()`, except that it reads the data from SDA rather than writing
    data. Also, there is no need to check for arbitration failure when reading, though
    this function still handles clock stretching and synchronization. Although the
    data is coming from the peripheral, it is still the controller’s responsibility
    to drive the clock signal on the SCL line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`sdaIn()` 函数从 I²C 总线读取单个位。此函数类似于 `sdaOut()`，不同之处在于它是从 SDA 读取数据，而不是写入数据。此外，读取时无需检查仲裁失败，尽管该函数仍然处理时钟拉伸和同步。虽然数据来自外设，但仍由控制器负责驱动
    SCL 线上的时钟信号。'
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `rcvByte()` function reads an 8-bit byte from the I²C bus by calling the
    `sdaIn()` function eight times. After the function reads those 8 bits, the controller
    is responsible for putting the ACK signal (a 0) on the SDA line to inform the
    peripheral that everything has gone well. This function returns the byte read
    as the function result.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`rcvByte()` 函数通过调用 `sdaIn()` 函数八次从 I²C 总线读取一个 8 位字节。在函数读取完这 8 位之后，控制器需要在 SDA
    线上放置 ACK 信号（即 0），以告知外设所有操作顺利完成。此函数返回读取的字节作为函数结果。'
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `rcvBytes()` function is the input analog to the `xmitBytes()` function.
    It acquires the I²C bus, transmitting a start condition; transmits the address
    byte with a high R/W bit; and then receives some specified number of bytes from
    the peripheral device. Optionally, this function will transmit a stop condition
    after receiving the bytes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`rcvBytes()` 函数是 `xmitBytes()` 函数的输入模拟。它获取 I²C 总线，传输一个启动条件；发送带有高 R/W 位的地址字节；然后从外围设备接收指定数量的字节。可选地，接收字节后，此函数会传输一个停止条件。'
- en: The code, up to this point, for *Listing3-1.ino* is the complete set of routines
    needed to implement a software-based I²C controller. The remainder of *Listing3-1.ino*
    contains the usual Arduino initialization (`setup`) and main `loop` functions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 直到目前为止，*Listing3-1.ino* 的代码是实现基于软件的 I²C 控制器所需的完整例程。*Listing3-1.ino* 的其余部分包含了常规的
    Arduino 初始化（`setup`）和主 `loop` 函数。
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `setup()` function sets up the SCL and SDA pins as inputs so they are left
    in the high condition to avoid interfering with other controllers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()` 函数将 SCL 和 SDA 引脚设置为输入，以便它们保持在高电平状态，避免与其他控制器产生干扰。'
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The main `loop()` function reads data from an ADS1115 analog-to-digital converter
    (ADC), translates the input, and writes the data to an MCP4725 digital-to-analog
    converter (DAC). Though the conversion isn’t perfect, this effectively copies
    the input voltage present on A0 of the ADC to the analog output on the DAC.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 主 `loop()` 函数从 ADS1115 模拟到数字转换器（ADC）读取数据，翻译输入，并将数据写入 MCP4725 数字到模拟转换器（DAC）。尽管转换不是完美的，但这有效地将
    ADC 上 A0 的输入电压复制到 DAC 上的模拟输出。
- en: As explained earlier, this code is just an example to demonstrate how you would
    implement an I²C controller in software, so it’s not really intended to be used.
    For one thing, it’s written using standard functions rather than classes and methods,
    which makes it easier to understand but harder to use. It also may not port directly
    to other MCUs; although I wrote this code using mostly standard Arduino calls,
    I ran it through a logic analyzer to hand-tune all the delays to produce reasonable
    timing on a 96-MHz Teensy 3.2\. I suspect the timing values might vary a bit too
    much on other faster or slower MCUs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这段代码只是一个示例，用来演示如何在软件中实现 I²C 控制器，因此并不真正打算用于实际应用。一方面，它是使用标准函数编写的，而不是类和方法，这使得它更容易理解，但使用起来更困难。它也可能无法直接移植到其他
    MCU；尽管我主要使用标准 Arduino 调用编写了这段代码，但我通过逻辑分析仪运行了它，并手动调节所有延迟，以在 96 MHz 的 Teensy 3.2
    上产生合理的时序。我怀疑在其他更快或更慢的 MCU 上，时序值可能会有所不同。
- en: The other problem with this code is that it uses a single pair of I/O pins for
    the SDA and SCL lines. Constantly changing the data direction on the pins to make
    them bidirectional is the standard way of doing things in software I²C implementations.
    While this approach probably works just fine in single-controller environments
    and when working with peripherals that don’t implement too many optional features,
    I’m not confident it will work flawlessly in multicontroller environments. Unfortunately,
    the race conditions that might exist—possible errant calculations based on the
    timing of your program’s execution—are difficult to create (for testing).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的另一个问题是，它使用一对 I/O 引脚作为 SDA 和 SCL 线。在引脚上不断改变数据方向以使其双向是软件 I²C 实现中的标准做法。虽然这种方法在单控制器环境中以及与不实现太多可选功能的外围设备配合使用时可能效果很好，但我不确定它在多控制器环境中能否完美工作。不幸的是，可能存在的竞争条件——基于程序执行时序的可能错误计算——很难创建（用于测试）。
- en: 3.1.2 A Software-Based I²C Peripheral for the Teensy 3.2
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 基于软件的 Teensy 3.2 I²C 外围设备
- en: 'The previous section provided a software implementation of an I²C controller
    device. This section provides the companion to that implementation: a software-controlled
    I²C peripheral device. The code in this section turns a Teensy 3.2 into an I²C
    peripheral with the following features:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节提供了 I²C 控制器设备的软实现。本节提供了该实现的配套部分：一个软件控制的 I²C 外围设备。本节中的代码将 Teensy 3.2 转换为具有以下特性的
    I²C 外围设备：
- en: It saves any byte value written to it.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它保存任何写入的数据字节值。
- en: When the controller reads a byte from it, it returns the last value written,
    or 0 if there was no previously written byte.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当控制器从中读取一个字节时，它返回最后写入的值，如果没有先前写入的字节，则返回 0。
- en: Effectively, this code turns the Teensy into a 1-byte I²C memory unit. Although
    this is a lame I²C peripheral, it completely demonstrates everything you need
    in order to develop your own software-based I²C peripheral.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这段代码将 Teensy 转变为一个 1 字节的 I²C 存储单元。虽然这是一个简单的 I²C 外设，但它完全展示了你开发自己基于软件的 I²C
    外设所需的一切。
- en: In many respects, the peripheral software is easier to write. The peripheral
    doesn’t have to worry about bus contention, clock synchronization, and many other
    issues. On the other hand, the peripheral should respond to several optional messages
    that controllers don’t have to worry about.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，外设的软件更容易编写。外设无需担心总线争用、时钟同步等问题。另一方面，外设需要响应几个控制器不必担心的可选消息。
- en: The following code ignores all the reserved address values. For the general
    call address reset function, it might be reasonable to set the stored memory value
    to 0 (though it’s easy enough to write a 0 to this peripheral if you want). You
    could also create a device ID for this peripheral; I will leave that exercise
    to you.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码忽略了所有保留的地址值。对于通用调用地址复位功能，可能合理将存储的内存值设置为 0（尽管如果你想的话，可以轻松地将 0 写入该外设）。你也可以为这个外设创建一个设备
    ID；我将这个任务留给你。
- en: '[Listing 3-2](#listing3-2) provides the source code for this simple peripheral.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-2](#listing3-2) 提供了这个简单外设的源代码。'
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As for the controller code, the two identifiers `SCL` and `SDA` define the pin
    numbers on the Teensy 3.2 that this code will use for the SCL and SDA lines. The
    `PeriphAddress` definition specifies the I²C address to which this peripheral
    will respond. To finish the definitions, `pinRead` and `pinWrite` expand to Teensy-specific
    (fast) versions of the Arduino `digitalRead()` and `digitalWrite()` functions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 至于控制器代码，两个标识符 `SCL` 和 `SDA` 定义了 Teensy 3.2 上将用于 SCL 和 SDA 线的引脚编号。`PeriphAddress`
    定义指定了该外设响应的 I²C 地址。为了完成定义，`pinRead` 和 `pinWrite` 扩展为 Teensy 特定的（快速）版本的 Arduino
    `digitalRead()` 和 `digitalWrite()` 函数。
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `setSCL()` ❶, `clrSCL()` ❷, `setSDA()` ❸, and `clrSDA()` ❹ functions were
    copied straight over from the controller code; they set or clear the SCL and SDA
    lines. Likewise, the `readSCL()` ❺ and `readSDA()` ❻ functions (also copied from
    the controller code) read the current values on the SDA and SCL lines. Refer back
    to the sections of *Listing3-1.ino* that begin with the comments `Pin set functions`
    and `Reading the SCL and SDA pins` for more details.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`setSCL()` ❶、`clrSCL()` ❷、`setSDA()` ❸ 和 `clrSDA()` ❹ 函数直接从控制器代码复制过来；它们设置或清除
    SCL 和 SDA 线。同样，`readSCL()` ❺ 和 `readSDA()` ❻ 函数（同样来自控制器代码）读取 SDA 和 SCL 线上的当前值。更多细节请参考
    *Listing3-1.ino* 中以 `Pin set functions` 和 `Reading the SCL and SDA pins` 注释开头的部分。'
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `sdaOut()` function places a single bit, passed as an argument, on the SDA
    line in response to an SCL clock transition. Unlike the controller code, the peripheral
    code does not control the SCL line. Instead, the controller must pulse the clock
    line.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`sdaOut()` 函数在响应 SCL 时钟过渡时，将一个作为参数传递的单个位放置到 SDA 线上。与控制器代码不同，外设代码不控制 SCL 线。相反，控制器必须脉冲时钟线。'
- en: The `sdaOut()` function must wait until the clock line is low ❶.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sdaOut()` 函数必须等待时钟线变低 ❶。'
- en: Then it can write the data to the SDA line ❷.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它可以将数据写入 SDA 线 ❷。
- en: Finally, it waits for the SCL line to go high and then back low again before
    returning ❸.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它等待 SCL 线变高然后再变低，之后返回 ❸。
- en: Note that this code has a timeout while waiting for the SCL line to go high.
    If for some reason the controller doesn’t bring the SCL line back high, this code
    will break out of the wait loop after about 15 µsec rather than just hang up ❹.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码在等待 SCL 线变高时有一个超时机制。如果由于某种原因，控制器没有将 SCL 线重新拉高，这段代码将在大约 15 微秒后跳出等待循环，而不是一直挂起
    ❹。
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `xmitByte()` function transmits an 8-bit byte on the SDA line by calling
    `sdaOut()` eight times ❶. This code also consumes the clock cycle for the ninth
    bit—the acknowledge bit ❷—though it ignores that bit’s state, since some controllers
    don’t bother putting the ACK bit on the SDA line. This code also has a timeout
    ❸ in case the SCL line never goes high while it is waiting for the acknowledge
    bit.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`xmitByte()` 函数通过调用 `sdaOut()` 八次在 SDA 线上发送一个 8 位字节 ❶。这段代码还会消耗第九位的时钟周期——确认位
    ❷——尽管它忽略了该位的状态，因为一些控制器不会将 ACK 位放到 SDA 线上。这段代码也有一个超时机制 ❸，以防在等待确认位时 SCL 线始终未变高。'
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `sdaIn()` function reads a bit appearing on the SDA line. It begins by waiting
    until the SCL line is low ❶, if it wasn’t already. Then it waits for the SCL line
    to go high (the start of the read cycle) because SDA data is valid only while
    the clock line is high ❷. Once the clock line goes high, this function delays
    for a microsecond to give the data time to settle, and then this function reads
    the data from the SDA line ❸.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`sdaIn()` 函数用于读取 SDA 线路上的一个比特。它首先等待 SCL 线路变为低电平 ❶，如果它已经是低电平则不做处理。然后它等待 SCL
    线路变为高电平（读取周期的开始），因为只有在时钟线为高电平时，SDA 数据才是有效的 ❷。一旦时钟线变为高电平，该函数会延迟一个微秒，以便给数据时间稳定，然后从
    SDA 线路读取数据 ❸。'
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `rcvByte()` function calls `sdaIn()` eight successive times to read a byte
    from the I²C bus ❶. At the end of those 8 bits ❷, this function must pull the
    SDA line low to acknowledge the data: the ACK bit. The function pulls the SDA
    line low while SCL is low and leaves the SDA line while SCL is high, with the
    usual timeout check in case the controller leaves SCL high for too long.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`rcvByte()` 函数调用 `sdaIn()` 函数八次，以从 I²C 总线读取一个字节 ❶。在这 8 位数据 ❷ 结束时，函数必须将 SDA
    线路拉低以确认数据：即 ACK 位。该函数在 SCL 线路为低电平时将 SDA 线路拉低，并在 SCL 线路为高电平时释放 SDA 线路，同时执行常规的超时检查，以防控制器将
    SCL 线路保持高电平过长时间。'
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `waitForStart()` function doesn’t actually wait for a start condition to
    happen. Instead, it is a state machine that traverses between states on each call
    based on the state of the SDA and SCL lines. This function returns 0, 1, or some
    negative number.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForStart()` 函数实际上并不会等待开始条件的发生。相反，它是一个状态机，在每次调用时，根据 SDA 和 SCL 线路的状态在各个状态之间切换。该函数返回
    0、1 或某个负数。'
- en: A 0 return result indicates an address match with a write operation. A return
    value of 1 indicates an address match with a read operation. A negative return
    value indicates that nothing of interest has come along just yet and the caller
    should repeat the call in the near future, fast enough to catch an incoming start
    condition.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 0 表示地址匹配并进行写操作。返回值 1 表示地址匹配并进行读操作。负值返回则表示尚未出现感兴趣的内容，调用者应在不久的将来再次调用此函数，足够快以捕捉到即将到来的开始条件。
- en: The `waitForStart()` function was written this way—rather than not returning
    until a start condition and valid address have come along—because it allows the
    CPU to do other work while waiting for a start condition.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForStart()` 函数被这样编写——而不是直到开始条件和有效地址出现后才返回——是因为这样可以让 CPU 在等待开始条件的同时执行其他工作。'
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The standard Arduino `setup()` function just initializes the SDA and SCL lines
    as inputs, putting a 1 on these lines, so that this peripheral does not interfere
    with any other activity taking place on the bus. This particular code also prints
    a message to the `Serial` output for debugging purposes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Arduino `setup()` 函数仅初始化 SDA 和 SCL 线路为输入，将这两条线路置为 1，以确保此外设不会干扰总线上正在进行的任何其他活动。此特定代码还会将一条调试信息打印到
    `Serial` 输出。
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The Arduino loop function is the main body of the peripheral program. It calls
    the `waitForStart()` function and checks the return value. It handles the following
    three cases:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 的循环函数是外设程序的主体。它调用 `waitForStart()` 函数并检查返回值。它处理以下三种情况：
- en: 0 A write operation (from controller to peripheral) is taking place. In this
    case the code reads the next byte available from the I²C bus and stores this value
    into the memory location ❶.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0：发生写入操作（控制器向外设写数据）。在这种情况下，代码从 I²C 总线读取下一个字节，并将其存储到内存位置 ❶。
- en: 1 A read operation (controller is reading the peripheral) is taking place. In
    this case the code writes the value of the memory variable onto the I²C bus as
    the controller clocks out the next byte ❷.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1：发生读取操作（控制器正在读取外设）。在这种情况下，代码将内存变量的值写入 I²C 总线，作为控制器时钟输出下一个字节 ❷。
- en: A negative value The main loop does nothing in this case; it just returns to
    the caller, which, after some possible internal bookkeeping work, calls the `loop()`
    function again ❸.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 负值：在这种情况下，主循环不做任何事情；它只是返回给调用者，调用者在完成一些内部记录工作后会再次调用 `loop()` 函数 ❸。
- en: '[Listing 3-3](#listing3-3) is a short Teensy 3.2/Arduino program I used to
    test the software-based I²C peripheral code appearing in [Listing 3-2](#listing3-2).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-3](#listing3-3) 是我用来测试出现在[清单 3-2](#listing3-2)中的软件基础 I²C 外设代码的一个简短的 Teensy
    3.2/Arduino 程序。'
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code in [Listing 3-3](#listing3-3) can run on a Teensy 3.2 or just about
    any Arduino-compatible system. It repeatedly writes a value to the peripheral
    and then reads that value back. See Chapter 8 for more details about how this
    sample program works.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 3-3](#listing3-3) 中的代码可以在 Teensy 3.2 或几乎任何 Arduino 兼容系统上运行。它反复写入一个值到外设，然后读取该值。关于该示例程序如何工作的更多细节，请参见第
    8 章。'
- en: 3.1.3 Some Final Comments on the Teensy 3.2 Software I^(*2*)C Code
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 关于 Teensy 3.2 软件 I^(*2*)C 代码的最终评论
- en: The software in the previous two sections was hand-tuned to work on a Teensy
    3.2\. It may not work on different systems, and it likely won’t work on significantly
    faster or slower systems. If you want to use this code for some other MCU, you’ll
    probably have to tweak and optimize it a bit, particularly on MCUs with lower
    performance and less memory than the Teensy 3.2\. To provide an example of just
    such an optimization, Chapter 17 (online at [https://bookofi2c.randallhyde.com](https://bookofi2c.randallhyde.com))
    describes how to implement a controller and peripheral using an ATtiny84 CPU running
    at only 8 MHz.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前两节中的软件是手动调优的，专为 Teensy 3.2 设计。它可能不适用于不同的系统，也很可能不适用于显著更快或更慢的系统。如果你想在其他 MCU 上使用这段代码，你可能需要稍作调整和优化，特别是在性能较低、内存较小的
    MCU 上，像 Teensy 3.2 这样的平台。为了提供一个优化示例，第 17 章（在线阅读：[https://bookofi2c.randallhyde.com](https://bookofi2c.randallhyde.com)）描述了如何使用仅
    8 MHz 运行的 ATtiny84 CPU 实现一个控制器和外设。
- en: There are a couple of issues with the Teensy software implementation of the
    I²C bus. First, this code is relatively fragile with respect to timing. It uses
    software delay loops to measure the I²C clock cycles. Interrupts and other activities
    that can suspend the execution of such delay code may produce incorrect timings,
    resulting in improper operation. Although there are a few timeout checks on various
    loops, a real-world project would require more of these checks to prevent the
    code from hanging up if an errant controller or peripheral is on the bus. While
    this chapter avoids too many timeout checks because they would have cluttered
    up the code and made it harder to understand, if you intend to use this code as
    the basis for a real-world project, you should address that shortcoming.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Teensy 软件实现的 I²C 总线存在一些问题。首先，这段代码在时间上相对较脆弱。它使用软件延迟循环来测量 I²C 时钟周期。中断和其他可能暂停延迟代码执行的活动可能会导致计时不准确，从而导致操作不当。尽管有一些超时检查用于各种循环，但现实项目需要更多这样的检查，以防止代码在总线上有异常控制器或外设时挂起。虽然本章避免了过多的超时检查，因为那样会使代码显得杂乱且更难理解，但如果你打算将这段代码作为实际项目的基础，你应该解决这个缺陷。
- en: 3.2 Basic ATtiny84 and ATtiny85 Hardware
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 基本的 ATtiny84 和 ATtiny85 硬件
- en: The example code given thus far runs on a high-performance Teensy microcontroller.
    While that code is useful as an educational tool, in reality you usually won’t
    have to implement the I²C protocol on such a powerful processor—such processors
    will include built-in I²C hardware. Software-based I²C packages are far more common
    on low-end CPUs, such as the ATtiny84.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止给出的示例代码运行在高性能的 Teensy 微控制器上。虽然这段代码作为教育工具非常有用，但实际上，你通常不需要在如此强大的处理器上实现 I²C
    协议——这些处理器通常会内置 I²C 硬件。基于软件的 I²C 包更多地出现在低端 CPU 上，比如 ATtiny84。
- en: 'The ATtiny84 is a typical 8-bit AVR microcontroller similar to those found
    on low-end Arduino boards. These microcontrollers typically cost less than $3
    (US) from vendors such as SparkFun ([https://www.sparkfun.com/products/11232](https://www.sparkfun.com/products/11232)),
    and you can find them in small quantities (25 or so) for much less on Amazon or
    eBay. They have the following features:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ATtiny84 是典型的 8 位 AVR 微控制器，类似于低端 Arduino 板上使用的那些微控制器。这些微控制器通常从供应商（如 SparkFun：[https://www.sparkfun.com/products/11232](https://www.sparkfun.com/products/11232)）购买，价格不到
    3 美元（美国），你也可以在 Amazon 或 eBay 上以更低价格（大约 25 个一批）找到它们。它们具有以下特性：
- en: 8-KB flash memory
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8KB 闪存
- en: 512-bytes EEPROM
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 512 字节 EEPROM
- en: 512 bytes of RAM
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 512 字节的 RAM
- en: 12-MHz operation using internal clock, 20 MHz using external crystal
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内部时钟运行 12 MHz，使用外部晶振可达 20 MHz
- en: One 8-bit and one 16-bit counter
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 8 位计数器和一个 16 位计数器
- en: 10-bit ADCs
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10 位 ADC
- en: On-chip analog comparator
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置模拟比较器
- en: 12 I/O pins (in 14-pin dual-in-line [DIP] package)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 12 个 I/O 引脚（14 引脚双列直插式 [DIP] 封装）
- en: Nearly 12 MIPS operation at 12 MHz (1 MIPS/MHz)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 12 MHz 下近 12 MIPS 操作（1 MIPS/MHz）
- en: This CPU is great for handling 100-kHz I²C operations, assuming non-I²C activities
    are not especially compute intensive.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这款 CPU 非常适合处理 100 kHz 的 I²C 操作，前提是非 I²C 活动的计算负荷不是特别高。
- en: The ATtiny85 microcontroller IC is a similar device in an 8-pin DIP package
    with six GPIO pins. It has fewer peripheral devices built in (due to packing constraints),
    and the timers are both 8 bits, but otherwise it does the same job as the ATtiny84\.
    Most source codes that don’t use the extra ATtiny84 features will run on both
    MCUs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ATtiny85 微控制器是一个类似的设备，采用 8 引脚 DIP 封装，并具有六个 GPIO 引脚。它内置的外设较少（由于封装限制），定时器是 8 位的，但除此之外，它的功能和
    ATtiny84 相同。大多数不使用额外 ATtiny84 特性的源代码都能在这两款 MCU 上运行。
- en: You can find the complete code for a SparkFun Atto84 device programmed as an
    I²C controller in Chapter 17 online. This code isn’t identical to the Teensy code
    in this chapter, but much of it is similar; the code was placed in the online
    chapter to avoid redundancy in this chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在第 17 章的在线版本中找到完整的 SparkFun Atto84 设备代码，该代码被编程为 I²C 控制器。该代码与本章中的 Teensy 代码不完全相同，但许多部分是相似的；为了避免本章内容重复，代码被放置在在线章节中。
- en: 3.2.1 Atto84 Software-Based I^(*2*)C Peripheral
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 Atto84 基于软件的 I²C 外设
- en: 'Unfortunately, the Atto84 is just slightly too underpowered to support a reliable
    I²C peripheral mode in software. I spent several days attempting this with the
    following compromises:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Atto84 的性能稍显不足，无法在软件中可靠地支持 I²C 外设模式。我花了好几天尝试这个，作出了以下妥协：
- en: Dropping filtering on the SDA and SCL input lines
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除 SDA 和 SCL 输入线路上的滤波器
- en: Removing timeout checks on loops
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除循环中的超时检查
- en: In-lining most of the functions that manipulate I/O port bits (including reading
    bits, waiting for the clock line to go high or low, and many other functions)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将大多数操作 I/O 端口位的函数内联（包括读取位、等待时钟线高电平或低电平，以及许多其他函数）
- en: Dropping down into AVR assembly language for time-critical code
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了处理时间关键的代码，转向 AVR 汇编语言
- en: In the end, the Atto84 managed to support peripheral mode once in a while but
    was not at all consistent. The Atto84 can act as a controller because it controls
    the clock frequency; ifone-half clock periods wind up being stretched to 5.5 μsec,
    6.0 μsec, or even 7.1 μsec, any normal peripheral can handle that just fine. However,
    as a peripheral, the Atto84 must be capable of always keeping up with a 100-kHz
    clock (5-μsec one-half clock periods), and even using straight-line assembly language
    code with all the compromises listed earlier is not quite good enough to do the
    job. The Atto84 still misses putting the ACK bit on the SDA line every now and
    then. Of course, once you remove all the timeouts from the loops, the code gets
    out of sync when it misses a bit, and things go very badly after that point.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，Atto84 偶尔能够支持外设模式，但并不稳定。Atto84 可以作为控制器，因为它控制时钟频率；如果半个时钟周期被拉伸到 5.5 微秒、6.0
    微秒，甚至 7.1 微秒，任何正常的外设都能很好地处理。然而，作为外设，Atto84 必须能够始终跟上 100 kHz 时钟（5 微秒的半个时钟周期），即使使用直线汇编语言代码并做出前面提到的所有妥协，也不足以完成这项工作。Atto84
    有时还是会错过在 SDA 线上发送 ACK 位。当然，一旦你从循环中移除了所有超时检查，代码在错过一个比特后就会失去同步，从那时起事情就会变得非常糟糕。
- en: This is not to say that you cannot use the Atto84 (or generic ATtiny84) as an
    I²C peripheral device. The generic ATtiny84 can run at up to 20 MHz with an external
    crystal, which might be fast enough to work. More importantly, the ATtiny84 has
    built-in hardware (the USI) that provides hardware support for I²C operations.
    I’ll return to this subject in Chapter 16.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说你不能使用 Atto84（或通用的 ATtiny84）作为 I²C 外设。通用 ATtiny84 可以通过外部晶体以最高 20 MHz 运行，这可能足够快来工作。更重要的是，ATtiny84
    内建硬件（USI）提供了 I²C 操作的硬件支持。这个话题将在第 16 章中进一步探讨。
- en: 3.3 Chapter Summary
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 章节总结
- en: This chapter provided a software implementation of the I²C protocol running
    on a Teensy 3.2 microcontroller as an educational tool. It began by describing
    a small hardware setup using a Teensy 3.2, an Adafruit ADS1115 ADC breakout board,
    and a SparkFun MCP4725 DAC breakout board. After the basic hardware introduction,
    it presented a software implementation of an I²C controller and an I²C peripheral.
    Finally, it briefly reviewed issues with software-based I²C protocol implementation
    on an ATtiny84 microcontroller.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了一个在 Teensy 3.2 微控制器上运行的软件实现 I²C 协议，作为一个教育工具。它首先描述了一个小型硬件设置，使用了 Teensy 3.2、Adafruit
    ADS1115 ADC 扩展板和 SparkFun MCP4725 DAC 扩展板。基本硬件介绍后，展示了 I²C 控制器和 I²C 外设的软件实现。最后，简要回顾了在
    ATtiny84 微控制器上实现基于软件的 I²C 协议时遇到的问题。
- en: Carefully studying a software implementation of the I²C protocol will help solidify
    your understanding of its low-level details. That information becomes particularly
    important when you begin debugging I²C signals using logic and protocol analyzers.
    The next chapter will delve into that subject with a discussion of I²C debugging
    tools.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细研究 I²C 协议的软件实现将有助于加深你对其底层细节的理解。当你开始使用逻辑分析仪和协议分析仪调试 I²C 信号时，这些信息尤为重要。下一章将深入探讨这一主题，讨论
    I²C 调试工具。
