- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: EXPLOITING DNS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 DNS
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common.jpg)'
- en: The *Domain Name System* *(DNS)* locates internet domain names and translates
    them to IP addresses. It can be an effective weapon in the hands of an attacker,
    because organizations commonly allow the protocol to egress restricted networks
    and they frequently fail to monitor its use adequately. It takes a little knowledge,
    but savvy attackers can leverage these issues throughout nearly every step of
    an attack chain, including reconnaissance, command and control (C2), and even
    data exfiltration. In this chapter, you’ll learn how to write your own utilities
    by using Go and third-party packages to perform some of these capabilities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*域名系统* *(DNS)* 定位互联网域名并将其转换为 IP 地址。它在攻击者手中可以是一种有效的武器，因为组织通常允许该协议通过受限网络出口，而且它们经常未能充分监控其使用。只需一些知识，聪明的攻击者就能利用这些问题，在攻击链的几乎每个步骤中发挥作用，包括侦察、命令与控制（C2），甚至数据外泄。在本章中，你将学习如何使用
    Go 和第三方包编写自己的工具，执行一些这些功能。'
- en: You’ll start by resolving hostnames and IP addresses to reveal the many types
    of DNS records that can be enumerated. Then you’ll use patterns illustrated in
    earlier chapters to build a massively concurrent subdomain-guessing tool. Finally,
    you’ll learn how to write your own DNS server and proxy, and you’ll use DNS tunneling
    to establish a C2 channel out of a restrictive network!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先解析主机名和 IP 地址，揭示可以枚举的多种类型的 DNS 记录。然后，你将使用前面章节中介绍的模式，构建一个高并发的子域名猜测工具。最后，你将学习如何编写自己的
    DNS 服务器和代理，并使用 DNS 隧道技术在受限网络中建立 C2 通道！
- en: Writing DNS Clients
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 DNS 客户端
- en: Before exploring programs that are more complex, let’s get acquainted with some
    of the options available for client operations. Go’s built-in `net` package offers
    great functionality and supports most, if not all, record types. The upside to
    the built-in package is its straightforward API. For example, `LookupAddr(addr
    string)` returns a list of hostnames for a given IP address. The downside of using
    Go’s built-in package is that you can’t specify the destination server; instead,
    the package will use the resolver configured on your operating system. Another
    downside is that you can’t run deep inspection of the results.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索更复杂的程序之前，让我们先了解一些客户端操作中可用的选项。Go 的内置 `net` 包提供了出色的功能，支持大多数（如果不是全部）记录类型。使用内置包的优点是它简洁明了的
    API。例如，`LookupAddr(addr string)` 返回给定 IP 地址的主机名列表。使用 Go 内置包的缺点是，你无法指定目标服务器；相反，包将使用你操作系统上配置的解析器。另一个缺点是你无法对结果进行深度检查。
- en: 'To get around this, you’ll use an amazing third-party package called the *Go
    DNS package* written by Miek Gieben. This is our preferred DNS package because
    it’s highly modular, well written, and well tested. Use the following to install
    this package:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这个问题，你将使用一个由 Miek Gieben 编写的惊人的第三方包——*Go DNS 包*。这是我们首选的 DNS 包，因为它高度模块化，编写规范，且经过充分测试。使用以下命令安装该包：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once the package is installed, you’re ready to follow along with the upcoming
    code examples. You’ll begin by performing A record lookups in order to resolve
    IP addresses for hostnames.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了该包，你就可以跟随接下来的代码示例。你将首先执行 A 记录查询，以解析主机名的 IP 地址。
- en: Retrieving A Records
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取 A 记录
- en: Let’s start by performing a lookup for a *fully qualified domain name (FQDN)*,
    which specifies a host’s exact location in the DNS hierarchy. Then we’ll attempt
    to resolve that FQDN to an IP address, using a type of DNS record called an *A
    record*. We use A records to point a domain name to an IP address. [Listing 5-1](ch05.xhtml#ch5list1)
    shows an example lookup. (All the code listings at the root location of / exist
    under the provided github repo *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先对一个*完全限定域名 (FQDN)* 进行查询，它指定了主机在 DNS 层级中的确切位置。然后，我们将尝试使用一种称为*A 记录*的 DNS
    记录，将该 FQDN 解析为 IP 地址。我们使用 A 记录将域名指向 IP 地址。[列表 5-1](ch05.xhtml#ch5list1) 显示了一个查询示例。（所有位于根位置的代码清单都存在于提供的
    GitHub 仓库 *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*
    中。）
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 5-1: Retrieving an A record (*[/ch-5/get_a/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-5/get_a/main.go)*)*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-1: 获取 A 记录 (*[/ch-5/get_a/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-5/get_a/main.go)*)*'
- en: Start by creating a new `Msg` ❶ and then call `fqdn(`string`)` to transform
    the domain into a FQDN that can be exchanged with a DNS server ❷. Next, modify
    the internal state of the `Msg` with a call to `SetQuestion(`string`, uint16)`
    by using the `TypeA` value to denote your intent to look up an A record ❸. (This
    is a `const` defined in the package. You can view the other supported values in
    the package documentation.) Finally, place a call to `Exchange(*Msg,` string`)`
    ❹ in order to send the message to the provided server address, which is a DNS
    server operated by Google in this case.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的`Msg` ❶，然后调用`fqdn(string)`将域名转换为可以与DNS服务器交换的FQDN ❷。接下来，使用`TypeA`值通过调用`SetQuestion(string,
    uint16)`来修改`Msg`的内部状态，以表示你想查找A记录 ❸。（这是一个在包中定义的`const`值。你可以在包文档中查看其他支持的值。）最后，调用`Exchange(*Msg,
    string)` ❹，将消息发送到提供的服务器地址，在这个例子中是Google运营的DNS服务器。
- en: As you can probably tell, this code isn’t very useful. Although you’re sending
    a query to a DNS server and asking for the A record, you aren’t processing the
    answer; you aren’t doing anything meaningful with the result. Prior to programmatically
    doing that in Go, let’s first review what the DNS answer looks like so that we
    can gain a deeper understanding of the protocol and the different query types.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这段代码并不是很有用。虽然你正在向DNS服务器发送查询并请求A记录，但你没有处理响应；你没有对结果做任何有意义的操作。在用Go编程进行这项操作之前，我们先回顾一下DNS响应的样子，以便更深入地理解协议及不同的查询类型。
- en: 'Before you execute the program in [Listing 5-1](ch05.xhtml#ch5list1), run a
    packet analyzer, such as Wireshark or tcpdump, to view the traffic. Here’s an
    example of how you might use tcpdump on a Linux host:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行[Listing 5-1](ch05.xhtml#ch5list1)中的程序之前，运行一个数据包分析器，如Wireshark或tcpdump，以查看流量。以下是如何在Linux主机上使用tcpdump的示例：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In a separate terminal window, compile and execute your program like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个独立的终端窗口中，像这样编译并执行程序：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you execute your code, you should see a connection to 8.8.8.8 over UDP
    53 in the output from your packet capture. You should also see details about the
    DNS protocol, as shown here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你执行了代码，你应该在数据包捕获的输出中看到连接到8.8.8.8的UDP 53连接。你还应该看到DNS协议的详细信息，如下所示：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The packet capture output produces a couple of lines that require further explanation.
    First, a query is being placed from 192.168.7.51 to 8.8.8.8 by using UDP 53 ❶
    while requesting a DNS A record ❷. The response ❸ is returned from Google’s 8.8.8.8
    DNS server, which contains the resolved IP address, 104.131.56.170.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包捕获输出产生了几行需要进一步解释的内容。首先，从192.168.7.51通过UDP 53 ❶向8.8.8.8发送查询请求，要求获取DNS A记录
    ❷。响应 ❸由Google的8.8.8.8 DNS服务器返回，包含了解析后的IP地址104.131.56.170。
- en: Using a packet analyzer such as tcpdump, you’re able to resolve the domain name
    `stacktitan.com` to an IP address. Now let’s take a look at how to extract that
    information by using Go.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用tcpdump等数据包分析器，你能够将域名`stacktitan.com`解析为IP地址。现在让我们看看如何使用Go提取这些信息。
- en: Processing Answers from a Msg struct
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理来自Msg结构体的答案
- en: 'The returned values from `Exchange(*Msg,` string`)` are `(*Msg,` error`)`.
    Returning the `error` type makes sense and is common in Go idioms, but why does
    it return `*Msg` if that’s what you passed in? To clarify this, look at how the
    `struct` is defined in the source:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Exchange(*Msg, string)`返回的值是`(*Msg, error)`。返回`error`类型是有道理的，并且在Go的惯用法中很常见，但为什么返回`*Msg`呢？如果那就是你传入的对象，为什么要返回它呢？为了澄清这一点，请看看源代码中是如何定义`struct`的：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the `Msg` `struct` holds both questions and answers. This lets
    you consolidate all your DNS questions and their answers into a single, unified
    structure. The `Msg` type has various methods that make working with the data
    easier. For example, the `Question` slice ❶ is being modified with the convenience
    method `SetQuestion()`. You could modify this slice directly by using `append()`
    and achieve the same outcome. The `Answer` slice ❷ holds the response to the queries
    and is of type `RR`. [Listing 5-2](ch05.xhtml#ch5list2) demonstrates how to process
    the answers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Msg` `struct`同时包含了问题和答案。这使你能够将所有的DNS问题及其答案整合到一个统一的结构中。`Msg`类型有各种方法，使得处理数据更为简便。例如，`Question`切片
    ❶通过便捷方法`SetQuestion()`进行修改。你也可以通过使用`append()`直接修改这个切片，达到相同的效果。`Answer`切片 ❷保存查询的响应，类型为`RR`。[Listing
    5-2](ch05.xhtml#ch5list2)展示了如何处理这些答案。
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 5-2: Processing DNS answers (*[/ch-5/get_all_a/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-5/get_all_a/main.go)*)*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-2: 处理DNS答案 (*[/ch-5/get_all_a/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-5/get_all_a/main.go)*)*'
- en: Our example begins by storing the values returned from `Exchange`, checking
    whether there was an error, and if so, calling `panic()` to stop the program ❶.
    The `panic()` function lets you quickly see the stack trace and identify where
    the error occurred. Next, validate that the length of the `Answer` slice is at
    least 1 ❷, and if it isn’t, indicate that there are no records and immediately
    return—after all, there will be legitimate instances when the domain name cannot
    be resolved.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例从存储 `Exchange` 返回的值开始，检查是否有错误，如果有，则调用 `panic()` 停止程序 ❶。`panic()` 函数让您快速查看堆栈跟踪并确定错误发生的位置。接下来，验证
    `Answer` 切片的长度是否至少为 1 ❷，如果不是，则表示没有记录并立即返回——毕竟，域名无法解析是一个合法的情况。
- en: The type `RR` is an interface with only two defined methods, and neither allows
    access to the IP address stored in the answer. To access those IP addresses, you’ll
    need to perform a type assertion to create an instance of the data as your desired
    type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`RR` 类型是一个接口，只有两个已定义的方法，并且这两个方法都无法访问存储在答案中的 IP 地址。要访问这些 IP 地址，您需要执行类型断言，将数据实例化为您想要的类型。'
- en: 'First, loop over all the answers. Next, perform the type assertion on the answer
    to ensure that you’re dealing with a `*dns.A` type ❸. When performing this action,
    you can receive two values: the data as the asserted type and a `bool` representing
    whether the assertion was successful ❹. After checking whether the assertion was
    successful, print the IP address stored in `a.A` ❺. Although the type is `net.IP`,
    it does implement a `String()` method, so you can easily print it.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，遍历所有答案。接下来，对答案执行类型断言，确保您正在处理的是 `*dns.A` 类型 ❸。执行此操作时，您可以接收两个值：作为断言类型的数据和一个
    `bool`，表示断言是否成功 ❹。在检查断言是否成功后，打印存储在 `a.A` 中的 IP 地址 ❺。尽管类型是 `net.IP`，但它实现了 `String()`
    方法，因此您可以轻松打印它。
- en: Spend time with this code, modifying the DNS query and exchange to search for
    additional records. The type assertion may be unfamiliar, but it’s a similar concept
    to type casting in other languages.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间修改这段代码，修改 DNS 查询和交换，以便搜索其他记录。类型断言可能不太熟悉，但它与其他语言中的类型转换类似。
- en: Enumerating Subdomains
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 枚举子域名
- en: Now that you know how to use Go as a DNS client, you can create useful tools.
    In this section, you’ll create a subdomain-guessing utility. Guessing a target’s
    subdomains and other DNS records is a foundational step in reconnaissance, because
    the more subdomains you know, the more you can attempt to attack. You’ll supply
    our utility a candidate wordlist (a dictionary file) to use for guessing subdomains.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何将 Go 用作 DNS 客户端，您可以创建有用的工具。在本节中，您将创建一个子域名猜测工具。猜测目标的子域名和其他 DNS 记录是侦察过程中的基础步骤，因为您知道的子域名越多，您可以尝试攻击的方式就越多。您将为我们的工具提供一个候选字典文件，用于猜测子域名。
- en: With DNS, you can send requests as fast as your operating system can handle
    the processing of packet data. While the language and runtime aren’t going to
    become a bottleneck, the destination server will. Controlling the concurrency
    of your program will be important here, just as it has been in previous chapters.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DNS 时，您可以发送请求的速度取决于操作系统处理数据包的能力。虽然语言和运行时不会成为瓶颈，但目标服务器可能会。控制程序的并发性在这里将非常重要，就像在前面的章节中一样。
- en: First, create a new directory in your `GOPATH` called *subdomain_guesser*, and
    create a new file *main.go*. Next, when you first start writing a new tool, you
    must decide which arguments the program will take. This subdomain-guessing program
    will take several arguments, including the target domain, the filename containing
    subdomains to guess, the destination DNS server to use, and the number of workers
    to launch. Go provides a useful package for parsing command line options called
    `flag` that you’ll use to handle your command line arguments. Although we don’t
    use the `flag` package across all of our code examples, we’ve opted to use it
    in this case to demonstrate more robust, elegant argument parsing. [Listing 5-3](ch05.xhtml#ch5list3)
    shows our argument-parsing code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在您的 `GOPATH` 中创建一个名为 *subdomain_guesser* 的新目录，并创建一个名为 *main.go* 的新文件。接下来，当您开始编写新工具时，必须决定程序将接受哪些参数。这个子域名猜测程序将接受多个参数，包括目标域名、包含子域名的猜测文件名、要使用的目标
    DNS 服务器以及要启动的工作线程数。Go 提供了一个名为 `flag` 的有用包，用于解析命令行选项，您将使用它来处理命令行参数。尽管我们在所有代码示例中并不使用
    `flag` 包，但在此示例中我们选择使用它，以演示更强大、优雅的参数解析。[示例 5-3](ch05.xhtml#ch5list3) 显示了我们的参数解析代码。
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 5-3: Building a subdomain guesser (*[/ch-5/subdomain_guesser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-5/subdomain_guesser/main.go)*)*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单5-3：构建一个子域名猜测器 (*[/ch-5/subdomain_guesser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-5/subdomain_guesser/main.go)*)*'
- en: First, the code line declaring the `flDomain` variable ❶ takes a `String` argument
    and declares an empty string default value for what will be parsed as the `domain`
    option. The next pertinent line of code is the `flWorkerCount` variable declaration
    ❷. You need to provide an `Integer` value as the `c` command line option. In this
    case, set this to 100 default workers. But this value is probably too conservative,
    so feel free to increase the number when testing. Finally, a call to `flag.Parse()`
    ❸ populates your variables by using the provided input from the user.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明`flDomain`变量的代码行❶接受一个`String`类型的参数，并声明一个空字符串作为默认值，用于解析`domain`选项。接下来的相关代码行是`flWorkerCount`变量声明❷。你需要提供一个`Integer`类型的值作为`c`命令行选项。在这种情况下，将其设置为100个默认工作者。但是这个值可能过于保守，所以在测试时可以增加该值。最后，调用`flag.Parse()`❸会通过用户提供的输入填充你的变量。
- en: '**NOTE**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You may have noticed that the example is going against Unix law in that it
    has defined optional arguments that aren’t optional. Please feel free to use os.Args
    here. We just find it easier and faster to let the flag package do all the work.*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能已经注意到，示例违反了Unix法则，因为它定义了不是真正可选的参数。请随意使用os.Args。我们只是发现让flag包做所有工作更简单、更快捷。*'
- en: 'If you try to build this program, you should receive an error about unused
    variables. Add the following code immediately after your call to `flag.Parse()`.
    This addition prints the variables to stdout along with code, ensuring that the
    user provided `-domain` and `-wordlist`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试构建这个程序，应该会收到一个关于未使用变量的错误。请在调用`flag.Parse()`之后立即添加以下代码。这段代码会将变量打印到stdout，同时显示代码，确保用户提供了`-domain`和`-wordlist`：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To allow your tool to report which names were resolvable along with their respective
    IP addresses, you’ll create a `struct` type to store this information. Define
    it above the `main()` function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的工具报告哪些名称是可解析的，并显示它们各自的IP地址，你将创建一个`struct`类型来存储这些信息。将其定义在`main()`函数之上：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You’ll query two main record types—A and CNAME—for this tool. You’ll perform
    each query in a separate function. It’s a good idea to keep your functions as
    small as possible and to have each perform one thing well. This style of development
    allows you to write smaller tests in the future.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你将查询两个主要的记录类型——A记录和CNAME记录——来为这个工具提供功能。你将在不同的函数中执行每个查询。最好让你的函数尽可能小，并确保每个函数执行一个操作。这种开发风格可以让你在未来编写更小的测试。
- en: Querying A and CNAME Records
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查询A和CNAME记录
- en: 'You’ll create two functions to perform queries: one for A records and the other
    for CNAME records. Both functions accept a FQDN as the first argument and the
    DNS server address as the second. Each should return a slice of strings and an
    error. Add these functions to the code you began defining in [Listing 5-3](ch05.xhtml#ch5list3).
    These functions should be defined outside `main()`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建两个函数来执行查询：一个用于A记录，另一个用于CNAME记录。两个函数都接受FQDN作为第一个参数，DNS服务器地址作为第二个参数。每个函数都应该返回一个字符串切片和一个错误。将这些函数添加到你在[清单5-3](ch05.xhtml#ch5list3)中开始定义的代码中。这些函数应该在`main()`外部定义。
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code should look familiar because it’s nearly identical to the code you
    wrote in the first section of this chapter. The first function, `lookupA`, returns
    a list of IP addresses, and `lookupCNAME` returns a list of hostnames.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该看起来很熟悉，因为它几乎和你在本章第一节中写的代码完全相同。第一个函数`lookupA`返回一个IP地址列表，`lookupCNAME`返回一个主机名列表。
- en: '*CNAME*, or *canonical name*, records point one FQDN to another one that serves
    as an alias for the first. For instance, say the owner of the *example.com* organization
    wants to host a WordPress site by using a WordPress hosting service. That service
    may have hundreds of IP addresses for balancing all of their users’ sites, so
    providing an individual site’s IP address would be infeasible. The WordPress hosting
    service can instead provide a canonical name (a CNAME) that the owner of *example.com*
    can reference. So *www.example.com* might have a CNAME pointing to *[someserver.hostingcompany.org](http://someserver.hostingcompany.org)*,
    which in turn has an A record pointing to an IP address. This allows the owner
    of *example.com* to host their site on a server for which they have no IP information.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*CNAME*（规范名称）记录将一个 FQDN 指向另一个 FQDN，这个 FQDN 作为第一个的别名。例如，假设 *example.com* 组织的所有者希望通过使用
    WordPress 托管服务来托管一个 WordPress 网站。该服务可能有数百个 IP 地址来平衡所有用户的网站流量，因此提供单个站点的 IP 地址将不可行。WordPress
    托管服务可以提供一个规范名称（CNAME），*example.com* 的所有者可以引用该 CNAME。因此，*www.example.com* 可能有一个指向
    *[someserver.hostingcompany.org](http://someserver.hostingcompany.org)* 的 CNAME，而该
    CNAME 进一步指向一个 IP 地址。这使得 *example.com* 的所有者能够将他们的网站托管在一个没有 IP 地址信息的服务器上。'
- en: 'Often this means you’ll need to follow the trail of CNAMES to eventually end
    up at a valid A record. We say *trail* because you can have an endless chain of
    CNAMES. Place the function in the following code outside `main()` to see how you
    can use the trail of CNAMES to track down the valid A record:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这意味着你需要跟踪 CNAMES 链接，最终到达有效的 A 记录。我们之所以称之为*链条*，是因为你可能会有一个无尽的 CNAMES 链条。将以下代码中的函数放到
    `main()` 外部，看看如何使用 CNAMES 链条来追踪有效的 A 记录：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, define a slice to store results ❶. Next, create a copy of the FQDN passed
    in as the first argument ❷, not only so you don’t lose the original FQDN that
    was guessed, but also so you can use it on the first query attempt. After starting
    an infinite loop, try to resolve the CNAMEs for the FQDN ❸. If no errors occur
    and at least one CNAME is returned ❹, set `cfqdn` to the CNAME returned ❺, using
    `continue` to return to the beginning of the loop ❻. This process allows you to
    follow the trail of CNAMES until a failure occurs. If there’s a failure, which
    indicates that you’ve reached the end of the chain, you can then look for A records
    ❼; but if there’s an error, which indicates something went wrong with the record
    lookup, then you leave the loop early. If there are valid A records, append each
    of the IP addresses returned to your `results` slice ❽ and break out of the loop
    ❾. Finally, return the `results` to the caller.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个切片来存储结果 ❶。接下来，创建一个复制的 FQDN（完全限定域名），作为第一个参数传入 ❷，这样不仅不会丢失被猜测的原始 FQDN，而且还可以在第一次查询时使用它。在开始无限循环后，尝试解析
    FQDN 的 CNAME 记录 ❸。如果没有错误发生，并且至少返回了一个 CNAME ❹，将 `cfqdn` 设置为返回的 CNAME ❺，并使用 `continue`
    跳回循环的开始 ❻。这个过程让你能够跟踪 CNAMES 链条，直到发生失败。如果发生失败，说明你已到达链条的末尾，那么你可以开始查找 A 记录 ❼；但如果发生错误，说明记录查询出了问题，那么你就提前退出循环。如果有有效的
    A 记录，将每个返回的 IP 地址追加到 `results` 切片中 ❽，并跳出循环 ❾。最后，将 `results` 返回给调用者。
- en: Our logic associated with the name resolution seems sound. However, you haven’t
    accounted for performance. Let’s make our example goroutine-friendly so you can
    add concurrency.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与名称解析相关的逻辑看起来很合理。然而，你没有考虑到性能。让我们使这个示例更适合 goroutine，这样你就可以添加并发功能。
- en: Passing to a Worker Function
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 传递给工作函数
- en: You’ll create a pool of goroutines that pass work to a *worker function*, which
    performs a unit of work. You’ll do this by using channels to coordinate work distribution
    and the gathering of results. Recall that you did something similar in [Chapter
    2](ch02.xhtml#ch2), when you built a concurrent port scanner.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建一个 goroutine 池，通过传递工作到一个*工作函数*来执行一个工作单元。你将使用通道来协调工作分配和结果收集。回想一下你在[第 2 章](ch02.xhtml#ch2)中做的类似工作，当时你构建了一个并发的端口扫描器。
- en: 'Continue to expand the code from [Listing 5-3](ch05.xhtml#ch5list3). First,
    create the `worker()` function and place it outside `main()`. This function takes
    three channel arguments: a channel for the worker to signal whether it has closed,
    a channel of domains on which to receive work, and a channel on which to send
    results. The function will need a final string argument to specify the DNS server
    to use. The following code shows an example of our `worker()` function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 继续扩展[清单5-3](ch05.xhtml#ch5list3)中的代码。首先，创建`worker()`函数，并将其放置在`main()`外部。这个函数接受三个通道参数：一个用于工作线程发出关闭信号的通道，一个接收工作的域名通道，以及一个用于发送结果的通道。该函数还需要一个最终的字符串参数，用于指定要使用的DNS服务器。以下代码展示了我们的`worker()`函数示例：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Before introducing the `worker()` function, first define the type `empty` to
    track when the worker finishes ❶. This is a `struct` with no fields; you use an
    empty `struct` because it’s 0 bytes in size and will have little impact or overhead
    when used. Then, in the `worker()` function, loop over the domains channel ❷,
    which is used to pass in FQDNs. After getting results from your `lookup()` function
    and checking to ensure there is at least one result, send the results on the `gather`
    channel ❸, which accumulates the results back in `main()`. After the work loop
    exits because the channel has been closed, an `empty` struct is sent on the `tracker`
    channel ❹ to signal the caller that all work has been completed. Sending the empty
    `struct` on the tracker channel is an important last step. If you don’t do this,
    you’ll have a race condition, because the caller may exit before the `gather`
    channel receives results.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍`worker()`函数之前，首先定义类型`empty`，用于跟踪工作线程何时完成❶。这是一个没有字段的`struct`；你使用空的`struct`是因为它的大小为0字节，使用时几乎不会产生任何影响或开销。然后，在`worker()`函数中，遍历域名通道❷，该通道用于传递FQDN（完全限定域名）。在从`lookup()`函数获取结果并确保至少有一个结果后，将结果发送到`gather`通道❸，该通道将在`main()`中汇总结果。当工作循环因通道关闭而退出时，通过`tracker`通道❹发送一个`empty`结构体，向调用者发出所有工作已完成的信号。在tracker通道上发送空的`struct`是一个重要的最后步骤。如果你不这么做，就会产生竞态条件，因为调用者可能在`gather`通道接收到结果之前就退出了。
- en: 'Since all of the prerequisite structure is set up at this point, let’s refocus
    our attention back to `main()` to complete the program we began in [Listing 5-3](ch05.xhtml#ch5list3).
    Define some variables that will hold the results and the channels that will be
    passed to `worker``()`. Then append the following code into `main()`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此时所有前置结构已经设置好，让我们将注意力重新集中到`main()`中，以完成我们在[清单5-3](ch05.xhtml#ch5list3)中开始的程序。定义一些变量，用于存储结果和传递给`worker()`的通道。然后将以下代码添加到`main()`中：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create the `fqdns` channel as a buffered channel by using the number of workers
    provided by the user. This allows the workers to start slightly faster, as the
    channel can hold more than a single message before blocking the sender.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用用户提供的工作线程数量创建一个带缓冲的`fqdns`通道。这样可以让工作线程稍微更快启动，因为通道在阻塞发送者之前可以容纳超过一个消息。
- en: Creating a Scanner with bufio
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用bufio创建一个Scanner
- en: 'Next, open the file provided by the user to consume as a word list. With the
    file open, create a new `scanner` by using the `bufio` package. The scanner allows
    you to read the file one line at a time. Append the following code into `main()`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开用户提供的文件以消耗作为单词列表。文件打开后，使用`bufio`包创建一个新的`scanner`。扫描器允许你一次读取文件的一行。将以下代码添加到`main()`中：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The built-in function `panic()` is used here if the error returned is not `nil`.
    When you’re writing a package or program that others will use, you should consider
    presenting this information in a cleaner format.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回的错误不为`nil`，则在此使用内置函数`panic()`。当你编写他人将使用的包或程序时，应该考虑以更简洁的格式呈现此信息。
- en: You’ll use the new `scanner` to grab a line of text from the supplied word list
    and create a FQDN by combining the text with the domain the user provides. You’ll
    send the result on the `fqdns` channel. But you must start the workers first.
    The order of this is important. If you were to send your work down the `fqdns`
    channel without starting the workers, the buffered channel would eventually become
    full, and your producers would block. You’ll add the following code to your `main()`
    function. Its purpose is to start the worker goroutines, read your input file,
    and send work on your `fqdns` channel.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用新的`scanner`从提供的单词列表中抓取一行文本，并通过将该文本与用户提供的域名组合，创建一个FQDN。你会将结果发送到`fqdns`通道。但是你必须先启动工作者。这个顺序很重要。如果你在没有启动工作者的情况下将工作发送到`fqdns`通道，缓冲通道最终会被填满，生产者将会阻塞。你需要将以下代码添加到`main()`函数中。其目的是启动工作者协程，读取输入文件，并将工作发送到`fqdns`通道。
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Creating the workers ❶ by using this pattern should look similar to what you
    did when building your concurrent port scanner: you used a `for` loop until you
    reached the number provided by the user. To grab each line in the file, `scanner.Scan()`
    is used in a loop ❷. This loop ends when there are no more lines to read in the
    file. To get a string representation of the text from the scanned line, use `scanner.Text()`
    ❸.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种模式创建工作者❶应该类似于你在构建并发端口扫描器时所做的：你使用了`for`循环，直到达到用户提供的数量。为了获取文件中的每一行，在循环❷中使用`scanner.Scan()`。当文件中没有更多行可读取时，循环结束。为了获取扫描行的字符串表示，可以使用`scanner.Text()`❸。
- en: The work has been launched! Take a second to bask in greatness. Before reading
    the next code, think about where you are in the program and what you’ve already
    done in this book. Try to complete this program and then continue to the next
    section, where we’ll walk you through the rest.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 工作已经启动！花点时间享受成功的喜悦。在阅读下一个代码之前，思考一下你在程序中所处的位置，以及你已经完成了哪些内容。尝试完成这个程序，然后继续阅读下一节，我们会引导你完成剩下的部分。
- en: Gathering and Displaying the Results
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 聚合和展示结果
- en: To finish up, first start an anonymous goroutine that will gather the results
    from the workers. Append the following code into `main():`
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，首先启动一个匿名的goroutine来从工作者那里收集结果。将以下代码添加到`main()`中：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By looping over the `gather` channel, you append the received results onto the
    `results` slice ❶. Since you’re appending a slice to another slice, you must use
    the `...` syntax ❷. After you close the `gather` channel and the loop ends, send
    an empty `struct` to the tracker channel as you did earlier ❸. This is done to
    prevent a race condition in case `append()` doesn’t finish by the time you eventually
    present the results to the user.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过循环遍历`gather`通道，你将接收到的结果附加到`results`切片中❶。由于你将一个切片附加到另一个切片，必须使用`...`语法❷。在关闭`gather`通道并且循环结束后，像之前一样向`tracker`通道发送一个空的`struct`❸。这样做是为了防止竞态条件，避免在`append()`操作未完成时，结果就被展示给用户。
- en: 'All that’s left is closing the channels and presenting the results. Include
    the following code at the bottom of `main()` in order to close the channels and
    present the results to the user:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是关闭通道并展示结果。将以下代码添加到`main()`函数的底部，以便关闭通道并将结果展示给用户：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first channel that can be closed is `fqdns` ❶ because you’ve already sent
    all the work on this channel. Next, you need to receive on the `tracker` channel
    one time for each of the workers ❷, allowing the workers to signal that they exited
    completely. With all of the workers accounted for, you can close the `gather`
    channel ❸ because there are no more results to receive. Finally, receive one more
    time on the `tracker` channel to allow the gathering goroutine to finish completely
    ❹.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个可以关闭的通道是`fqdns`❶，因为你已经将所有的工作都发送到这个通道。接下来，你需要从`tracker`通道接收每个工作者一次❷，以便工作者能发出完全退出的信号。在所有工作者都完成之后，你可以关闭`gather`通道❸，因为没有更多的结果需要接收。最后，再次从`tracker`通道接收一次，以允许聚合协程完全结束❹。
- en: 'The results aren’t yet presented to the user. Let’s fix that. If you wanted
    to, you could easily loop over the `results` slice and print the `Hostname` and
    `IPAddress` fields by using `fmt.Printf()`. We prefer, instead, to use one of
    Go’s several great built-in packages for presenting data; `tabwriter` is one of
    our favorites. It allows you to present data in nice, even columns broken up by
    tabs. Add the following code to the end of `main()` to use `tabwriter` to print
    your results:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 结果尚未呈现给用户。让我们来修复这个问题。如果你愿意，可以轻松地遍历`results`切片，并使用`fmt.Printf()`打印`Hostname`和`IPAddress`字段。我们更倾向于使用Go的几个内置优秀包之一来展示数据；`tabwriter`是我们最喜欢的之一。它允许你将数据以整齐的列形式展示，每列之间通过制表符分隔。将以下代码添加到`main()`的末尾，使用`tabwriter`打印你的结果：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Listing 5-4](ch05.xhtml#ch5list4) shows the program in its entirety.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码清单 5-4](ch05.xhtml#ch5list4)展示了完整的程序。'
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 5-4: The complete subdomain-guessing program (*[/ch-5/subdomain_guesser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-5/subdomain_guesser/main.go)*)*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 5-4：完整的子域名猜测程序 (*[/ch-5/subdomain_guesser/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-5/subdomain_guesser/main.go)*)*'
- en: 'Your subdomain-guessing program is complete! You should now be able to build
    and execute your shiny new subdomain-guessing tool. Try it with word lists or
    dictionary files in open source repositories (you can find plenty with a Google
    search). Play around with the number of workers; you may find that if you go too
    fast, you’ll get varying results. Here’s a run from the authors’ system using
    100 workers:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你的子域名猜测程序已经完成！现在你应该能够构建并执行你崭新的子域名猜测工具。尝试使用开源代码库中的词典文件或字典文件（你可以通过Google搜索找到很多）。试试修改工作线程数量；你可能会发现，如果你速度太快，结果可能会有所不同。以下是作者系统使用100个工作线程时的运行结果：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You’ll see that the output shows several FQDNs and their IP addresses. We were
    able to guess the subdomain values for each result based off the word list provided
    as an input file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到输出显示了几个FQDN和它们的IP地址。我们能够根据提供的词典文件猜测每个结果的子域名值。
- en: Now that you’ve built your own subdomain-guessing tool and learned how to resolve
    hostnames and IP addresses to enumerate different DNS records, you’re ready to
    write your own DNS server and proxy.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经构建了自己的子域名猜测工具，并学会了如何解析主机名和IP地址以枚举不同的DNS记录，你已经准备好编写自己的DNS服务器和代理了。
- en: Writing DNS Servers
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写DNS服务器
- en: As Yoda said, “Always two there are, no more, no less.” Of course, he was talking
    about the client-server relationship, and since you’re a master of clients, now
    is the time to become a master of servers. In this section, you’ll use the Go
    DNS package to write a basic server and a proxy. You can use DNS servers for several
    nefarious activities, including but not limited to tunneling out of restrictive
    networks and conducting spoofing attacks by using fake wireless access points.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如尤达所说：“总有两者，非多，非少。”当然，他是在讲客户端与服务器的关系，而既然你已经是客户端的高手，现在是时候成为服务器的高手了。在本节中，你将使用Go的DNS包来编写一个基础的服务器和代理。你可以将DNS服务器用于几种恶意活动，包括但不限于通过伪造无线接入点进行隧道穿越限制网络和进行欺骗攻击。
- en: Before you begin, you’ll need to set up a lab environment. This lab environment
    will allow you to simulate realistic scenarios without having to own legitimate
    domains and use costly infrastructure, but if you’d like to register domains and
    use a real server, please feel free to do so.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，你需要搭建一个实验室环境。这个实验室环境可以让你模拟现实场景，而无需拥有合法的域名或使用昂贵的基础设施。如果你愿意注册域名并使用真实服务器，也可以随时这样做。
- en: Lab Setup and Server Introduction
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验室设置与服务器介绍
- en: 'Your lab consists of two virtual machines (VMs): a Microsoft Windows VM to
    act as client and an Ubuntu VM to act as server. This example uses VMWare Workstation
    along with Bridged network mode for each machine; you can use a private virtual
    network, but make sure that both machines are on the same network. Your server
    will run two Cobalt Strike Docker instances built from the official Java Docker
    image (Java is a prerequisite for Cobalt Strike). [Figure 5-1](ch05.xhtml#ch5fig1)
    shows what your lab will look like.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你的实验室由两台虚拟机（VM）组成：一台微软Windows虚拟机作为客户端，一台Ubuntu虚拟机作为服务器。这个示例使用VMWare Workstation以及桥接网络模式来配置每台机器；你也可以使用私有虚拟网络，但确保两台机器在同一网络下。你的服务器将运行两个从官方Java
    Docker镜像构建的Cobalt Strike Docker实例（Java是Cobalt Strike的先决条件）。[图 5-1](ch05.xhtml#ch5fig1)展示了你的实验室设置。
- en: '![Image](Images/05fig01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/05fig01.jpg)'
- en: '*Figure 5-1: The lab setup for creating your DNS server*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：创建DNS服务器的实验室设置*'
- en: First, create the Ubuntu VM. To do this, we’ll use version 16.04.1 LTS. No special
    considerations need to be made, but you should configure the VM with at least
    4 gigabytes of memory and two CPUs. You can use an existing VM or host if you
    have one. After the operating system has been installed, you’ll want to install
    a Go development environment (see [Chapter 1](ch01.xhtml#ch1)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建 Ubuntu 虚拟机。为此，我们将使用版本 16.04.1 LTS。无需做特别配置，但你应该为虚拟机配置至少 4 GB 内存和两个 CPU。如果你已有虚拟机或主机，也可以使用。操作系统安装完成后，你需要安装
    Go 开发环境（见[第 1 章](ch01.xhtml#ch1)）。
- en: 'Once you’ve created the Ubuntu VM, install a virtualization container utility
    called *Docker*. In the proxy section of this chapter, you’ll use Docker to run
    multiple instances of Cobalt Strike. To install Docker, run the following in your
    terminal window:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了 Ubuntu 虚拟机，安装一个名为 *Docker* 的虚拟化容器工具。在本章的代理部分，你将使用 Docker 来运行多个 Cobalt
    Strike 实例。要安装 Docker，请在终端窗口中运行以下命令：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After installing, log out and log back into your system. Next, verify that
    Docker has been installed by running the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，退出并重新登录到系统。接下来，通过运行以下命令验证 Docker 是否已安装：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With Docker installed, use the following command to download a Java image. This
    command pulls down the base Docker Java image but doesn’t create any containers.
    You’re doing this to prepare for your Cobalt Strike builds shortly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 Docker 后，使用以下命令下载 Java 镜像。该命令会拉取基础的 Docker Java 镜像，但不会创建任何容器。你这么做是为了为即将进行的
    Cobalt Strike 构建做准备。
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, you need to ensure that `dnsmasq` isn’t running, because it listens
    on port 53\. Otherwise, your own DNS servers won’t be able to operate, since they’re
    expected to use the same port. Kill the process by ID if it’s running:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要确保 `dnsmasq` 没有在运行，因为它监听的是 53 端口。否则，你自己的 DNS 服务器将无法运行，因为它们需要使用相同的端口。如果它正在运行，可以通过进程
    ID 杀掉它：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now create a Windows VM. Again, you can use an existing machine if available.
    You don’t need any special settings; minimal settings will do. Once the system
    is functional, set the DNS server to the IP address of the Ubuntu system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个 Windows 虚拟机。同样，如果已有机器可以使用，则不需要特别设置；只需最小配置即可。系统正常运行后，将 DNS 服务器设置为 Ubuntu
    系统的 IP 地址。
- en: To test your lab setup and to introduce you to writing DNS servers, start by
    writing a basic server that returns only A records. In your `GOPATH` on the Ubuntu
    system, create a new directory called *github.com/blackhat-go/bhg/ch-5/a_server*
    and a file to hold your *main.go* code. [Listing 5-5](ch05.xhtml#ch5list5) shows
    the entire code for creating a simple DNS server.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试你的实验室设置并让你了解如何编写 DNS 服务器，首先编写一个返回 A 记录的基本服务器。在 Ubuntu 系统的`GOPATH`中，创建一个名为*github.com/blackhat-go/bhg/ch-5/a_server*的新目录，并创建一个文件来保存你的*main.go*代码。[清单
    5-5](ch05.xhtml#ch5list5)展示了创建一个简单 DNS 服务器的完整代码。
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 5-5: Writing a DNS server (*[/ch-5/a_server/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-5/a_server/main.go)*)*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-5：编写一个 DNS 服务器 (*[/ch-5/a_server/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-5/a_server/main.go)*)*'
- en: The server code starts with a call to `HandleFunc()` ❶; it looks a lot like
    the `net/http` package. The function’s first argument is a query pattern to match.
    You’ll use this pattern to indicate to the DNS servers which requests will be
    handled by the supplied function. By using a period, you’re telling the server
    that the function you supply in the second argument will handle all requests.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器代码以调用`HandleFunc()` ❶开始；它看起来与`net/http`包非常相似。该函数的第一个参数是一个查询模式，用于匹配请求。你将使用此模式告诉
    DNS 服务器哪些请求将由提供的函数处理。通过使用句点，你在告诉服务器你在第二个参数中提供的函数将处理所有请求。
- en: 'The next argument passed to `HandleFunc()` is a function containing the logic
    for the handler. This function receives two arguments: a `ResponseWriter` and
    the request itself. Inside the handler, you start by creating a new message and
    setting the reply ❷. Next, you create an answer for each question, using an A
    record, which implements the `RR` interface. This portion will vary depending
    on the type of answer you’re looking for ❸. The pointer to the A record is appended
    to the response’s `Answer` field by using `append()` ❹. With the response complete,
    you can write this message to the calling client by using `w.WriteMsg()` ❺. Finally,
    to start the server, `ListenAndServe()` is called ❻. This code resolves all requests
    to an IP address of 127.0.0.1.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `HandleFunc()` 的下一个参数是一个包含处理程序逻辑的函数。此函数接收两个参数：`ResponseWriter` 和请求本身。在处理程序内，首先创建一个新消息并设置回复
    ❷。接下来，使用 A 记录为每个问题创建一个答案，这个 A 记录实现了 `RR` 接口。根据你要查找的答案类型，这部分会有所不同 ❸。A 记录的指针通过 `append()`
    ❹ 被附加到响应的 `Answer` 字段中。完成响应后，可以使用 `w.WriteMsg()` ❺ 将此消息写入调用客户端。最后，调用 `ListenAndServe()`
    ❻ 启动服务器。此代码将所有请求解析为 IP 地址 127.0.0.1。
- en: Once the server is compiled and started, you can test it by using `dig`. Confirm
    that the hostname for which you’re querying resolves to 127.0.0.1\. That indicates
    it’s working as designed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器编译并启动，你可以使用 `dig` 来测试它。确认你查询的主机名解析到 127.0.0.1。这表明它按照预期工作。
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the server will need to be started with sudo or a root account, because
    it listens on a privileged port—port 53\. If the server doesn’t start, you may
    need to kill `dnsmasq`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，服务器需要使用 sudo 或 root 账户启动，因为它监听的是特权端口——端口 53。如果服务器无法启动，你可能需要终止 `dnsmasq`。
- en: Creating DNS Server and Proxy
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 DNS 服务器和代理
- en: '*DNS tunneling*, a data exfiltration technique, can be a great way to establish
    a C2 channel out of networks with restrictive egress controls. If using an authoritative
    DNS server, an attacker can route through an organization’s own DNS servers and
    out through the internet without having to make a direct connection to their own
    infrastructure. Although slow, it’s difficult to defend against. Several open
    source and proprietary payloads perform DNS tunneling, one of which is Cobalt
    Strike’s Beacon. In this section, you’ll write your own DNS server and proxy and
    learn how to multiplex DNS tunneling C2 payloads by using Cobalt Strike.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*DNS 隧道*，一种数据外泄技术，可以是从具有严格出口控制的网络中建立 C2 通道的绝佳方式。如果使用授权的 DNS 服务器，攻击者可以通过组织自己的
    DNS 服务器路由并通过互联网出去，而无需直接连接到他们自己的基础设施。尽管速度较慢，但很难防御。许多开源和专有的载荷都能执行 DNS 隧道，其中之一是 Cobalt
    Strike 的 Beacon。在本节中，你将编写自己的 DNS 服务器和代理，并学习如何使用 Cobalt Strike 对 DNS 隧道 C2 载荷进行复用。'
- en: Configuring Cobalt Strike
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 配置 Cobalt Strike
- en: If you’ve ever used Cobalt Strike, you may have noticed that, by default, the
    *teamserver* listens on port 53\. Because of this, and by the recommendation of
    the documentation, only a single server should ever be run on a system, maintaining
    a one-to-one ratio. This can become problematic for medium-to-large teams. For
    example, if you have 20 teams conducting offensive engagements against 20 separate
    organizations, standing up 20 systems capable of running the teamserver could
    be difficult. This problem isn’t unique to Cobalt Strike and DNS; it’s applicable
    to other protocols, including HTTP payloads, such as Metasploit Meterpreter and
    Empire. Although you could establish listeners on a variety of completely unique
    ports, there’s a greater probability of egressing traffic over common ports such
    as TCP 80 and 443\. So the question becomes, how can you and other teams share
    a single port and route to multiple listeners? The answer is with a proxy, of
    course. Back to the lab.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾使用过 Cobalt Strike，你可能会注意到，默认情况下，*teamserver* 监听端口 53。正因如此，根据文档的建议，系统上应该只运行一个服务器，保持一对一的比例。这对于中型到大型团队来说可能会成为问题。例如，如果你有
    20 个团队对 20 个不同的组织进行进攻性渗透，建立 20 台能运行 teamserver 的系统可能会很困难。这个问题不仅限于 Cobalt Strike
    和 DNS，它也适用于其他协议，包括 HTTP 载荷，如 Metasploit Meterpreter 和 Empire。虽然你可以在多个完全独立的端口上建立监听器，但通过常见端口（如
    TCP 80 和 443）传出的流量可能性更大。那么问题就来了，如何让你和其他团队共享一个端口并路由到多个监听器呢？答案当然是使用代理。回到实验室。
- en: '**NOTE**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In real engagements, you’d want to have multiple levels of subterfuge, abstraction,
    and forwarding to disguise the location of your teamserver. This can be done using
    UDP and TCP forwarding through small utility servers using various hosting providers.
    The primary teamserver and proxy can also run on separate systems, having the
    teamserver cluster on a large system with plenty of RAM and CPU power.*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*在实际的攻击行动中，你可能希望通过多层次的欺骗、抽象和转发来掩盖你的 teamserver 位置。这可以通过使用 UDP 和 TCP 转发，通过各种托管服务提供商的辅助小型服务器来实现。主
    teamserver 和代理也可以运行在不同的系统上，将 teamserver 集群部署在一个大系统上，配备大量的内存和 CPU。*'
- en: Let’s run two instances of Cobalt Strike’s teamserver in two Docker containers.
    This allows the server to listen on port 53 and lets each teamserver have what
    will effectively be their own system and, consequently, their own IP stack. You’ll
    use Docker’s built-in networking mechanism to map UDP ports to the host from the
    container. Before you begin, download a trial version of Cobalt Strike at *[https://trial.cobaltstrike.com/](https://trial.cobaltstrike.com/)*.
    After following the trial sign-up instructions, you should have a fresh *tarball*
    in your download directory. You’re now ready to start the teamservers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在两个 Docker 容器中运行两个 Cobalt Strike 的 teamserver 实例。这使得服务器可以监听端口 53，并让每个 teamserver
    拥有他们自己的系统，进而拥有自己的 IP 栈。你将使用 Docker 内建的网络机制，将 UDP 端口从容器映射到主机。在开始之前，下载一个 Cobalt
    Strike 的试用版本，访问 *[https://trial.cobaltstrike.com/](https://trial.cobaltstrike.com/)*。按照试用注册指引操作后，你应该会在下载目录中获得一个新的
    *tarball* 文件。现在，你准备好启动 teamserver 了。
- en: 'Execute the following in a terminal window to start the first container:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口中执行以下命令启动第一个容器：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This command does several things. First, you tell Docker to remove the container
    after it exits ❶, and that you’d like to interact with it after starting ❷. Next,
    you map port 2020 on your host system to port 53 in the container ❸, and port
    50051 to port 50050 ❹. Next, you map the directory containing the Cobalt Strike
    tarball ❺ to the data directory on the container ❻. You can specify any directory
    you want and Docker will happily create it for you. Finally, provide the image
    you want to use (in this case, Java) ❼ and the command ❽ you’d like to execute
    on startup. This should leave you with a bash shell in the running Docker container.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令执行了多个操作。首先，你告诉 Docker 在容器退出后移除它 ❶，并且希望在启动后与其进行交互 ❷。接下来，你将主机系统的端口 2020 映射到容器的端口
    53 ❸，将端口 50051 映射到端口 50050 ❹。接着，你将包含 Cobalt Strike 压缩包的目录 ❺ 映射到容器的 data 目录 ❻。你可以指定任何目录，Docker
    会为你创建它。最后，提供你想使用的镜像（在此例中为 Java） ❼ 以及你希望在启动时执行的命令 ❽。这将让你在运行中的 Docker 容器中获得一个 bash
    shell。
- en: 'Once inside the Docker container, start the teamserver by executing the following
    commands:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 Docker 容器后，通过执行以下命令启动 teamserver：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The IP address provided should be that of your actual VM, not the IP address
    of the container.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的 IP 地址应该是你实际虚拟机的 IP 地址，而不是容器的 IP 地址。
- en: 'Next, open a new terminal window on the Ubuntu host and change into the directory
    containing the Cobalt Strike tarball. Execute the following commands to install
    Java and start the Cobalt Strike client:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 Ubuntu 主机上打开一个新的终端窗口，进入包含 Cobalt Strike 压缩包的目录。执行以下命令安装 Java 并启动 Cobalt
    Strike 客户端：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The GUI for Cobalt Strike should start up. After clearing the trial message,
    change the teamserver port to 50051 and set your username and password accordingly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Cobalt Strike 的图形界面应已启动。在清除试用信息后，将 teamserver 端口改为 50051，并相应设置你的用户名和密码。
- en: 'You’ve successfully started and connected to a server running completely in
    Docker! Now, let’s start a second server by repeating the same process. Follow
    the previous steps to start a new teamserver. This time, you’ll map different
    ports. Incrementing the ports by one should do the trick and is logical. In a
    new terminal window, execute the following command to start a new container and
    listen on ports 2021 and 50052:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功启动并连接到完全在 Docker 中运行的服务器！现在，让我们通过重复相同的过程启动第二个服务器。按照之前的步骤启动一个新的 teamserver。这次，你需要映射不同的端口。将端口递增一个数字应该能解决问题，这也很有逻辑性。在一个新的终端窗口中，执行以下命令来启动一个新的容器，并监听端口
    2021 和 50052：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: From the Cobalt Strike client, create a new connection by selecting **Cobalt
    Strike** ▶ **New Connection**, modifying the port to 50052, and selecting **Connect**.
    Once connected, you should see two tabs at the bottom of the console, which you
    can use to switch between servers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Cobalt Strike 客户端创建一个新连接，通过选择 **Cobalt Strike** ▶ **New Connection**，修改端口为
    50052，并选择 **Connect**。连接后，你应该能在控制台底部看到两个标签页，你可以用它们在服务器之间切换。
- en: 'Now that you’ve successfully connected to the two teamservers, you should start
    two DNS listeners. To create a listener, select **Configure Listeners** from the
    menu; its icon looks like a pair of headphones. Once there, select **Add** from
    the bottom menu to bring up the New Listener window. Enter the following information:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经成功连接到两个团队服务器，应该开始启动两个 DNS 监听器。要创建监听器，从菜单中选择**配置监听器**；其图标看起来像一副耳机。进入后，选择底部菜单中的**添加**，以打开新监听器窗口。输入以下信息：
- en: 'Name: DNS 1'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：DNS 1
- en: 'Payload: windows/beacon_dns/reverse_dns_txt'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载：windows/beacon_dns/reverse_dns_txt
- en: 'Host: <IP address of host>'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机：<主机的 IP 地址>
- en: 'Port: 0'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口：0
- en: In this example, the port is set to 80, but your DNS payload still uses port
    53, so don’t worry. Port 80 is specifically used for hybrid payloads. [Figure
    5-2](ch05.xhtml#ch5fig2) shows the New Listener window and the information you
    should be entering.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，端口设置为 80，但您的 DNS 负载仍然使用端口 53，因此不用担心。端口 80 专门用于混合负载。[图 5-2](ch05.xhtml#ch5fig2)显示了新监听器窗口以及您应该输入的信息。
- en: '![Image](Images/05fig02.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/05fig02.jpg)'
- en: '*Figure 5-2: Adding a new listener*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：添加新监听器*'
- en: Next, you’ll be prompted to enter the domains to use for beaconing, as shown
    in [Figure 5-3](ch05.xhtml#ch5fig3).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，系统会提示您输入用于信标的域名，如[图 5-3](ch05.xhtml#ch5fig3)所示。
- en: Enter the domain *attacker1.com* as the DNS beacon, which should be the domain
    name to which your payload beacons. You should see a message indicating that a
    new listener has started. Repeat the process within the other teamserver, using
    DNS 2 and *attacker2.com*. Before you start using these two listeners, you’ll
    need to write an intermediary server that inspects the DNS messages and routes
    them appropriately. This, essentially, is your proxy.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输入域名*attacker1.com*作为 DNS 信标，这应是您的负载信标的目标域名。您应该看到一条消息，表示新监听器已启动。在另一个团队服务器中重复此过程，使用
    DNS 2 和*attacker2.com*。在开始使用这两个监听器之前，您需要编写一个中介服务器来检查 DNS 消息并将其正确路由。基本上，这就是您的代理。
- en: '![Image](Images/05fig03.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/05fig03.jpg)'
- en: '*Figure 5-3: Adding the DNS beacon’s domain*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：添加 DNS 信标的域名*'
- en: Creating a DNS Proxy
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建 DNS 代理
- en: 'The DNS package you’ve been using throughout this chapter makes writing an
    intermediary function easy, and you’ve already used some of these functions in
    previous sections. Your proxy needs to be able to do the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本章中使用的 DNS 包使得编写中介功能变得容易，您在之前的部分中已经使用了其中的一些函数。您的代理需要能够执行以下操作：
- en: Create a handler function to ingest an incoming query
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个处理程序函数来接收传入的查询
- en: Inspect the question in the query and extract the domain name
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查查询中的问题并提取域名
- en: Identify the upstream DNS server correlating to the domain name
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定与域名相关联的上游 DNS 服务器
- en: Exchange the question with the upstream DNS server and write the response to
    the client
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与上游 DNS 服务器交换问题并将响应写入客户端
- en: Your handler function could be written to handle *attacker1.com* and *attacker2.com*
    as static values, but that’s not maintainable. Instead, you should look up records
    from a resource external to the program, such as a database or a configuration
    file. The following code does this by using the format of `domain,server`, which
    lists the incoming domain and upstream server separated by a comma. To start your
    program, create a function that parses a file containing records in this format.
    The code in [Listing 5-6](ch05.xhtml#ch5list6) should be written into a new file
    called *main.go*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您的处理程序函数可以写成处理*attacker1.com*和*attacker2.com*作为静态值，但这样不具备可维护性。相反，您应该从程序外部的资源（如数据库或配置文件）查找记录。以下代码通过使用`domain,server`的格式来实现这一点，其中列出了传入的域名和用逗号分隔的上游服务器。要启动您的程序，创建一个函数来解析包含此格式记录的文件。[清单
    5-6](ch05.xhtml#ch5list6)中的代码应写入一个名为*main.go*的新文件。
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 5-6: Writing a DNS proxy (*[/ch-5/dns_proxy/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-5/dns_proxy/main.go)*)*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-6：编写 DNS 代理 (*[/ch-5/dns_proxy/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-5/dns_proxy/main.go)*)*'
- en: With this code, you first define a function ❶ that parses a file containing
    the configuration information and returns a `map[string]string` ❷. You’ll use
    that map to look up the incoming domain and retrieve the upstream server.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，您首先定义一个函数❶，该函数解析包含配置信息的文件，并返回一个`map[string]string`❷。您将使用这个映射来查找传入的域名并获取上游服务器。
- en: Enter the first command in the following code into your terminal window, which
    will write the string after `echo` into a file called *proxy.config*. Next, you
    should compile and execute *dns_proxy.go*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口中输入以下代码的第一个命令，它会将`echo`后面的字符串写入名为*proxy.config*的文件中。接下来，你应该编译并执行*dns_proxy.go*。
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What are you looking at here? The output is the mapping between teamserver domain
    names and the port on which the Cobalt Strike DNS server is listening. Recall
    that you mapped ports 2020 and 2021 to port 53 on your two separate Docker containers.
    This is a quick and dirty way for you to create basic configuration for your tool
    so you don’t have to store it in a database or other persistent storage mechanism.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到的是什么？输出是teamserver域名与Cobalt Strike DNS服务器监听端口之间的映射。回顾一下，你将端口2020和2021映射到了你两个不同Docker容器中的端口53。这是一种快速简便的方法，帮助你为你的工具创建基础配置，以便你不必将其存储在数据库或其他持久存储机制中。
- en: With a map of records defined, you can now write the handler function. Let’s
    refine your code, adding the following to your `main()` function. It should follow
    the parsing of your config file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了记录映射之后，你现在可以编写处理函数了。让我们优化一下你的代码，将以下内容添加到你的`main()`函数中。它应该在解析配置文件之后执行。
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To begin, call `HandleFunc()` with a period to handle all incoming requests
    ❶, and define an *anonymous function* ❷, which is a function that you don’t intend
    to reuse (it has no name). This is good design when you have no intention to reuse
    a block of code. If you intend to reuse it, you should declare and call it as
    a *named function*. Next, inspect the incoming questions slice to ensure that
    at least one question is provided ❸, and if not, call `HandleFailed()` and return
    to exit the function early. This is a pattern used throughout the handler. If
    at least a single question does exist, you can safely pull the requested name
    from the first question ❹. Splitting the name by a period is necessary to extract
    the domain name. Splitting the name should never result in a value less than 1,
    but you should check it to be safe. You can grab the *tail* of the slice—the elements
    at the end of the slice—by using the slice operator on the slice ❺. Now, you need
    to retrieve the upstream server from the records map.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，调用`HandleFunc()`并传入一个句点，处理所有传入的请求❶，并定义一个*匿名函数*❷，即一个你不打算重用的函数（它没有名称）。当你不打算重用一段代码时，这是一种良好的设计。如果你打算重用它，你应该将其声明为并调用一个*命名函数*。接下来，检查传入的问答切片，确保至少提供了一个问题❸，如果没有，调用`HandleFailed()`并提前返回退出函数。这是处理程序中使用的一个模式。如果至少有一个问题存在，你可以安全地从第一个问题中提取请求的名称❹。通过句点拆分名称是必须的，以提取域名。拆分名称时结果不应小于1，但你仍然应该检查它以确保安全。你可以通过使用切片操作符从切片❺中获取切片的*尾部*——即切片的最后几个元素。现在，你需要从记录映射中检索上游服务器。
- en: 'Retrieving a value from a map ❻ can return one or two variables. If the key
    (in our case, a domain name) is present on the map, it will return the corresponding
    value. If the domain isn’t present, it will return an empty string. You could
    check if the returned value is an empty string, but that would be inefficient
    when you start working with types that are more complex. Instead, assign two variables:
    the first is the value for the key, and the second is a Boolean that returns `true`
    if the key is found. After ensuring a match, you can exchange the request with
    the upstream server ❼. You’re simply making sure that the domain name for which
    you’ve received the request is configured in your persistent storage. Next, write
    the response from the upstream server to the client ❽. With the handler function
    defined, you can start the server ❾. Finally, you can now build and start the
    proxy.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从映射中检索值❻可以返回一个或两个变量。如果键（在我们的例子中是域名）存在于映射中，它会返回相应的值。如果域名不存在，它会返回一个空字符串。你可以检查返回的值是否为空字符串，但当你开始处理更复杂的类型时，这种方法效率低下。相反，声明两个变量：第一个是键对应的值，第二个是一个布尔值，若找到该键则返回`true`。在确保匹配后，你可以与上游服务器交换请求❼。你只需确保你收到请求的域名已经在你的持久存储中配置好。接下来，将来自上游服务器的响应写入客户端❽。定义好处理函数后，你可以启动服务器❾。最后，你现在可以构建并启动代理。
- en: With the proxy running, you can test it by using the two Cobalt Strike listeners.
    To do this, first create two stageless executables. From Cobalt Strike’s top menu,
    click the icon that looks like a gear, and then change the output to **Windows
    Exe**. Repeat this process from each teamserver. Copy each of these executables
    to your Windows VM and execute them. The DNS server of your Windows VM should
    be the IP address of your Linux host. Otherwise, the test won’t work.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 启动代理后，你可以使用两个 Cobalt Strike 监听器来进行测试。首先，创建两个无阶段的可执行文件。从 Cobalt Strike 的顶部菜单中，点击看起来像齿轮的图标，然后将输出更改为**Windows
    Exe**。对每个团队服务器重复此过程。将这些可执行文件复制到你的 Windows 虚拟机，并执行它们。你的 Windows 虚拟机的 DNS 服务器应为你的
    Linux 主机的 IP 地址，否则测试将无法正常工作。
- en: It may take a moment or two, but eventually you should see a new beacon on each
    teamserver. Mission accomplished!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要一两分钟，但最终你应该会在每个团队服务器上看到一个新的信标。任务完成！
- en: Finishing Touches
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最后润色
- en: 'This is great, but when you have to change the IP address of your teamserver
    or redirector, or if you have to add a record, you’ll have to restart the server
    as well. Your beacons would likely survive such an action, but why take the risk
    when there’s a much better option? You can use process signals to tell your running
    program that it needs to reload the configuration file. This is a trick that I
    first learned from Matt Holt, who implemented it in the great Caddy Server. [Listing
    5-7](ch05.xhtml#ch5list7) shows the program in its entirety, complete with process
    signaling logic:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但当你需要更改你的团队服务器或重定向器的 IP 地址，或者你需要添加一个记录时，你也需要重新启动服务器。你的信标可能会在这种操作中幸存下来，但为什么要冒这个险呢，毕竟有一个更好的选项？你可以使用进程信号告诉正在运行的程序需要重新加载配置文件。这是我从
    Matt Holt 那里学到的一个技巧，他在优秀的 Caddy Server 中实现了这一点。[列表 5-7](ch05.xhtml#ch5list7) 显示了完整的程序，其中包含进程信号逻辑：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 5-7: Your completed proxy (*[/ch-5/dns_proxy/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-5/dns_proxy/main.go)*)*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-7: 你完成的代理 (*[/ch-5/dns_proxy/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-5/dns_proxy/main.go)*)*'
- en: There are a few additions. Since the program is going to be modifying a map
    that could be in use by concurrent goroutines, you’ll need to use a mutex to control
    access.^([1](footnote.xhtml#ch5fn1)) A *mutex* prevents concurrent execution of
    sensitive code blocks, allowing you to lock and unlock access. In this case, you
    can use `RWMutex` ❶, which allows any goroutine to read without locking the others
    out, but will lock the others out when a write is occurring. Alternatively, implementing
    goroutines without a mutex on your resource will introduce interleaving, which
    could result in race conditions or worse.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些补充内容。由于程序将修改一个可能正在被并发 goroutines 使用的映射，因此你需要使用互斥锁来控制访问。^([1](footnote.xhtml#ch5fn1))
    一个*互斥锁*可以防止敏感代码块的并发执行，允许你锁定和解锁访问。在这种情况下，你可以使用`RWMutex` ❶，它允许任何 goroutine 在不锁住其他
    goroutine 的情况下读取，但在写入发生时会锁住其他 goroutine。或者，如果你在资源上没有使用互斥锁来实现 goroutines，那么就会引入交错执行，这可能导致竞争条件，甚至更糟。
- en: Before accessing the map in your handler, call `RLock` ❷ to read a value to
    `match`; after the read is complete, `RUnlock` ❸ is called to release the map
    for the next goroutine. In an anonymous function that’s running within a new goroutine
    ❹, you begin the process of listening for a signal. This is done using a channel
    of type `os.Signal` ❺, which is provided in the call to `signal.Notify()` ❻ along
    with the literal signal to be consumed by the `SIGUSR1` channel, which is a signal
    set aside for arbitrary purposes. In a loop over the signals, use a `switch` statement
    ❼ to identify the type of signal that has been received. You’re configuring only
    a single signal to be monitored, but in the future you might change this, so this
    is an appropriate design pattern. Finally, `Lock()` ❽ is used prior to reloading
    the running configuration to block any goroutines that may be trying to read from
    the record map. Use `Unlock()` ❾ to continue execution.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问处理器中的映射之前，调用`RLock` ❷来读取一个值到`match`；读取完成后，调用`RUnlock` ❸释放映射，允许下一个 goroutine
    继续操作。在一个匿名函数中，它运行在一个新的 goroutine ❹ 中，你开始了监听信号的过程。这个过程是通过 `os.Signal` 类型的通道 ❺ 来完成的，该通道通过调用
    `signal.Notify()` ❻ 来提供，并与实际的信号一起传递给 `SIGUSR1` 通道，`SIGUSR1` 是一个预留用于任意用途的信号。在信号的循环中，使用
    `switch` 语句 ❼ 来识别接收到的信号类型。你只配置了一个信号来监控，但未来你可能会改变这一点，所以这是一个合适的设计模式。最后，在重新加载运行配置之前，使用
    `Lock()` ❽ 来阻塞任何可能尝试从记录映射中读取的 goroutine。使用 `Unlock()` ❾ 来继续执行。
- en: Let’s test this program by starting the proxy and creating a new listener within
    an existing teamserver. Use the domain *attacker3.com*. With the proxy running,
    modify the *proxy.config* file and add a new line pointing the domain to your
    listener. You can signal the process to reload its configuration by using `kill`,
    but first use `ps` and `grep` to identify the process ID.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启动代理并在现有的团队服务器中创建一个新的监听器来测试此程序。使用域名*attacker3.com*。代理运行时，修改*proxy.config*文件，并添加一行将该域指向你的监听器。你可以通过使用`kill`命令来让进程重新加载其配置，但首先使用`ps`和`grep`来识别进程ID。
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The proxy should reload. Test it by creating and executing a new stageless executable.
    The proxy should now be functional and production ready.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代理应该会重新加载。通过创建并执行一个新的无阶段可执行文件来进行测试。现在代理应该已经功能完备并准备投入生产环境。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Although this concludes the chapter, you still have a world of possibilities
    for your code. For example, Cobalt Strike can operate in a hybrid fashion, using
    HTTP and DNS for different operations. To do this, you’ll have to modify your
    proxy to respond with the listener’s IP for A records; you’ll also need to forward
    additional ports to your containers. In the next chapter, you’ll delve into the
    convoluted craziness that is SMB and NTLM. Now, go forth and conquer!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这一章已经结束，但你仍然有无穷的可能性可以探索你的代码。例如，Cobalt Strike可以以混合方式运行，使用HTTP和DNS进行不同的操作。为了做到这一点，你需要修改你的代理，使其对A记录返回监听器的IP；你还需要将额外的端口转发到你的容器。在下一章中，你将深入探讨复杂的SMB和NTLM的内容。现在，去征服吧！
