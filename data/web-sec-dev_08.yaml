- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**INJECTION ATTACKS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**注入攻击**'
- en: '![image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common01.jpg)'
- en: Now that you have a solid grasp of how the internet works, let’s focus on specific
    vulnerabilities and the methods hackers use to exploit them. This chapter covers
    *injection attacks*, which occur when the attacker injects external code into
    an application in an effort to take control of the application or read sensitive
    data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了互联网的基本工作原理，接下来我们将重点讨论特定的漏洞和黑客利用这些漏洞的方式。本章介绍的是*注入攻击*，即攻击者将外部代码注入应用程序，试图控制应用程序或读取敏感数据。
- en: Recall that the internet is an example of a *client-server architecture*, meaning
    that a web server handles connections from many clients at once. Most clients
    are web browsers, responsible for generating HTTP requests to the web server as
    a user navigates the website. The web server returns HTTP responses containing
    the HTML that makes up the content of the website’s pages.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，互联网是一个*客户端-服务器架构*的例子，这意味着一个网页服务器同时处理来自多个客户端的连接。大多数客户端是网页浏览器，负责在用户浏览网站时生成HTTP请求并发送给网页服务器。网页服务器则返回包含HTML的HTTP响应，这些HTML构成了网站页面的内容。
- en: Because the web server controls the website’s content, server-side code naturally
    expects specific types of user interactions to occur, and therefore expects the
    browser to generate specific types of HTTP requests. For instance, the server
    expects to see a `GET` request to a new URL each time the user clicks a link,
    or a `POST` request if they enter their login credentials and click Submit.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网页服务器控制着网站的内容，服务器端代码自然期望发生特定类型的用户交互，因此期望浏览器生成特定类型的HTTP请求。例如，服务器期望每次用户点击链接时看到一个`GET`请求指向一个新URL，或者在用户输入登录凭证并点击提交时看到一个`POST`请求。
- en: However, it’s perfectly possible for a browser to generate unexpected HTTP requests
    to a server. In addition, web servers happily accept HTTP requests from any type
    of client, not just browsers. A programmer equipped with an HTTP client library
    can write scripts that send requests to arbitrary URLs on the internet. The hacking
    tools we reviewed in [Chapter 1](ch01.xhtml#ch01) do exactly that.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，浏览器完全有可能生成意外的HTTP请求发送给服务器。此外，网页服务器也乐于接受来自任何类型客户端的HTTP请求，而不仅仅是浏览器。配备HTTP客户端库的程序员可以编写脚本，向互联网上的任意URL发送请求。我们在[第一章](ch01.xhtml#ch01)中回顾的黑客工具就是这样做的。
- en: Server-side code has no reliable way of telling whether a script or a browser
    generated an HTTP request, because the contents of the HTTP request are indistinguishable
    regardless of the client. The best a server can do is to check the `User-Agent`
    header, which is *supposed* to describe the type of *agent* that generated the
    request, but scripts and hacking tools typically *spoof* the contents of this
    header, so it matches what a browser would send.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端代码无法可靠地判断是脚本还是浏览器生成了HTTP请求，因为无论客户端如何，HTTP请求的内容都是无法区分的。服务器能做的最好的事情就是检查`User-Agent`头部，它*应该*描述生成请求的*代理*类型，但脚本和黑客工具通常会*伪造*这个头部的内容，使其与浏览器发送的请求相匹配。
- en: Knowing all of this, hackers attacking a website frequently pass malicious code
    in an HTTP request so that it tricks the server into executing the code. This
    is the basis of an injection attack on a website.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了这些，黑客攻击网站时通常会在HTTP请求中传递恶意代码，以欺骗服务器执行这些代码。这就是对网站进行注入攻击的基础。
- en: 'Injection attacks are astonishingly common on the internet and, if successful,
    can be devastating in their impact. As a web developer, you’ll need to know all
    the ways they can occur and how to defend against them. When writing website code,
    it’s important to consider what *could* come through in the HTTP requests being
    handled by the site, not just what you expect to come through. In this chapter,
    you’ll look at four types of injection attacks: SQL injection attacks, command
    injection attacks, remote code execution attacks, and attacks that exploit file
    upload vulnerabilities.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注入攻击在互联网上极为常见，如果成功，可能会造成毁灭性的影响。作为一名网页开发者，你需要了解它们可能发生的所有方式以及如何防范它们。在编写网站代码时，考虑HTTP请求中可能会出现的内容，而不仅仅是你期望出现的内容非常重要。本章将探讨四种类型的注入攻击：SQL注入攻击、命令注入攻击、远程代码执行攻击和利用文件上传漏洞的攻击。
- en: '**SQL Injection**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**SQL注入**'
- en: '*SQL injection* attacks target websites that use an underlying SQL database
    and construct data queries to the database in an insecure fashion. SQL injection
    attacks pose one of the greatest risks to websites because SQL databases are so
    common. This was evident in 2008, when hackers stole 130 million credit card numbers
    from Heartland Payment Systems, a payment processor that stores credit card details
    and handles payments for merchants. The hackers used a SQL injection attack to
    access the web servers that handled payment data, which was a disaster for a company
    that relies on the assurance of their information’s security to do business.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*SQL 注入* 攻击针对使用底层 SQL 数据库的网站，这些网站以不安全的方式构建数据查询。SQL 注入攻击对网站构成了最大的风险之一，因为 SQL
    数据库非常普遍。这一点在 2008 年得到了证明，当时黑客从 Heartland Payment Systems 偷取了 1.3 亿张信用卡号码。Heartland
    Payment Systems 是一家存储信用卡信息并为商户处理支付的支付处理公司。黑客通过 SQL 注入攻击访问了处理支付数据的 Web 服务器，这对依赖信息安全保障进行业务的公司来说是一次灾难。'
- en: Let’s begin by reviewing how SQL databases work, so that we can get to the heart
    of how SQL injection works and how we can stop it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先回顾一下 SQL 数据库是如何工作的，这样我们就能深入理解 SQL 注入是如何发生的，以及如何阻止它。
- en: '***What Is SQL?***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***什么是 SQL？***'
- en: '*Structured Query Language*, or *SQL*, extracts data and data structures in
    relational databases. Relational databases store data in tables; each row in a
    table is a data item (for example, a user, or a product being sold). SQL syntax
    allows applications such as web servers to add rows to the database by using `INSERT`
    statements, read rows by using `SELECT` statements, update rows by using `UPDATE`
    statements, and remove rows by using `DELETE` statements.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构化查询语言*，或称*SQL*，用于从关系型数据库中提取数据和数据结构。关系型数据库将数据存储在表格中；表中的每一行是一个数据项（例如，用户或正在销售的产品）。SQL
    语法允许像 Web 服务器这样的应用程序通过 `INSERT` 语句将行添加到数据库中，通过 `SELECT` 语句读取行，通过 `UPDATE` 语句更新行，通过
    `DELETE` 语句删除行。'
- en: Consider the SQL statements that a web server might run behind the scenes when
    you sign up on a website, as shown in [Listing 6-1](ch06.xhtml#ch6list1).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下当你在网站上注册时，Web 服务器在后台可能执行的 SQL 语句，如[清单 6-1](ch06.xhtml#ch6list1)所示。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 6-1: Typical SQL statements that a web server might run when a user
    interacts with a website*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-1：用户与网站交互时 Web 服务器可能执行的典型 SQL 语句*'
- en: SQL databases typically store information about the website’s users in a `users`
    table. When a user first signs up and chooses a username and password, the web
    server runs an `INSERT` statement on the database to create a new row in the `users`
    table ❶. The next time a user logs in to the website, the web server runs a `SELECT`
    statement to attempt to find the corresponding row in the `users` table ❷. If
    the user changes their password, the web server runs an `UPDATE` statement to
    update the corresponding row in the `users` table ❸. Finally, if the user closes
    their account, the website might run a `DELETE` statement to remove their row
    from the `users` table ❹.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 数据库通常在 `users` 表中存储关于网站用户的信息。当用户首次注册并选择用户名和密码时，Web 服务器会在数据库上执行 `INSERT`
    语句，以在 `users` 表中创建一行 ❶。下次用户登录网站时，Web 服务器会执行 `SELECT` 语句，尝试在 `users` 表中查找对应的行 ❷。如果用户更改密码，Web
    服务器会执行 `UPDATE` 语句，更新 `users` 表中相应的行 ❸。最后，如果用户关闭账户，网站可能会执行 `DELETE` 语句，将其行从 `users`
    表中删除 ❹。
- en: For each interaction, the web server is responsible for taking parts of the
    HTTP request (for example, the username and password entered into a login form)
    and constructing a SQL statement to run against the database. The actual execution
    of the statement happens through the *database driver*, a dedicated code library
    used to communicate with the database.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一次交互，Web 服务器负责提取 HTTP 请求中的一部分（例如，登录表单中输入的用户名和密码），并构建一个 SQL 语句来对数据库执行操作。该语句的实际执行通过*数据库驱动程序*完成，这是一个专门用于与数据库通信的代码库。
- en: '***Anatomy of a SQL Injection Attack***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SQL 注入攻击的结构***'
- en: SQL injection attacks occur when the web server insecurely constructs the SQL
    statement it passes to the database driver. This allows the attacker to pass arguments
    via the HTTP request that cause the driver to perform actions other than those
    the developer intends.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入攻击发生在 Web 服务器以不安全的方式构建它传递给数据库驱动程序的 SQL 语句时。这允许攻击者通过 HTTP 请求传递参数，从而导致驱动程序执行开发者未打算进行的操作。
- en: Let’s look at an insecurely constructed SQL statement that reads user data from
    the database when a user attempts to log in to a website, as shown in the Java
    code in [Listing 6-2](ch06.xhtml#ch6list2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个不安全构造的 SQL 语句，它会在用户尝试登录网站时从数据库读取用户数据，如 [列表 6-2](ch06.xhtml#ch6list2)
    中的 Java 代码所示。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 6-2: An insecure method of reading user data from the database during
    a login attempt*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-2：在登录尝试期间从数据库读取用户数据的不安全方法*'
- en: The construction of this SQL statement isn’t secure! This snippet uses the `email`
    and `password` parameters taken from the HTTP request, and inserts them directly
    into the SQL statement. Because the parameters aren’t checked for SQL control
    characters (such as `'`) that change the meaning of the SQL statement, a hacker
    can craft input that bypasses the website’s authentication system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 SQL 语句的构造不安全！这个片段使用从 HTTP 请求中获取的 `email` 和 `password` 参数，并将它们直接插入到 SQL 语句中。因为这些参数没有检查
    SQL 控制字符（例如 `'`），这些字符会改变 SQL 语句的含义，黑客可以构造输入绕过网站的身份验证系统。
- en: 'An example of this is shown in [Listing 6-3](ch06.xhtml#ch6list3). In this
    example, the attacker passes the user `email` parameter as `billy@gmail.com''--`,
    which terminates the SQL statement early and causes the password-checking logic
    to not execute:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-3](ch06.xhtml#ch6list3) 显示了一个示例。在这个示例中，攻击者将用户 `email` 参数传递为 `billy@gmail.com''--`，这会提前终止
    SQL 语句，并导致密码检查逻辑不被执行：'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 6-3: Using SQL injection to bypass authentication*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-3：使用 SQL 注入绕过身份验证*'
- en: The database driver executes only the SQL statement ❶, and ignores everything
    that comes after it ❷. In this type of SQL injection attack, the single quote
    character (`'`) closes the email argument early, and the SQL comment syntax (`--`)
    tricks the database driver into ignoring the end of the statement that does password
    checking. This SQL statement allows the attacker to log in as *any* user without
    having to know their password! All the attacker has to do is add the `'` and `--`
    characters to the user’s email address in the login form.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库驱动程序只执行 SQL 语句❶，并忽略之后的所有内容❷。在这种 SQL 注入攻击中，单引号字符 (`'`) 提前关闭了电子邮件参数，而 SQL 注释语法
    (`--`) 让数据库驱动程序忽略执行密码检查的语句的结尾。这个 SQL 语句允许攻击者以 *任何* 用户的身份登录，而无需知道他们的密码！攻击者只需要在登录表单中的用户电子邮件地址添加
    `'` 和 `--` 字符。
- en: This is a relatively simple example of a SQL injection attack. A more advanced
    attack might cause the database driver to run additional commands on the database.
    [Listing 6-4](ch06.xhtml#ch6list4) shows a SQL injection attack that runs a `DROP`
    command to remove the `users` table entirely, in order to corrupt the database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对简单的 SQL 注入攻击示例。更高级的攻击可能会导致数据库驱动程序在数据库上执行额外的命令。[列表 6-4](ch06.xhtml#ch6list4)
    显示了一个 SQL 注入攻击，它执行 `DROP` 命令，完全删除 `users` 表，从而破坏数据库。
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 6-4: A SQL injection attack in progress*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-4：SQL 注入攻击正在进行中*'
- en: In this scenario, the attacker passes the email parameter as `billy@gmail.com';
    DROP TABLE users;--`. The semicolon character (`;`) terminates the first SQL statement
    ❶, after which the attacker inserts an additional, destructive statement ❷. The
    database driver will run both statements, leaving your database in a corrupt state!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，攻击者将电子邮件参数传递为 `billy@gmail.com'; DROP TABLE users;--`。分号字符（`;`）终止了第一个
    SQL 语句❶，然后攻击者插入了一个附加的破坏性语句❷。数据库驱动程序会执行这两个语句，导致你的数据库处于损坏状态！
- en: If your website is vulnerable to SQL injection, an attacker can often run arbitrary
    SQL statements against your database, allowing them to bypass authentication;
    read, download, and delete data at will; or even inject malicious JavaScript into
    the pages rendered to your users. To scan websites for SQL injection vulnerabilities,
    hacking tools like Metasploit can be used to crawl websites and test HTTP parameters
    with potential exploits. If your site is vulnerable to SQL injection attacks,
    you can be sure that somebody will eventually take advantage of it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的网站容易受到 SQL 注入攻击，攻击者通常可以对你的数据库执行任意的 SQL 语句，从而绕过身份验证；随意读取、下载和删除数据；甚至将恶意的 JavaScript
    注入到呈现给用户的页面中。为了扫描网站的 SQL 注入漏洞，可以使用像 Metasploit 这样的黑客工具来爬取网站并测试 HTTP 参数中的潜在漏洞。如果你的网站易受
    SQL 注入攻击，可以确定最终会有人利用这一漏洞。
- en: '***Mitigation 1: Use Parameterized Statements***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***缓解措施 1：使用参数化语句***'
- en: To protect against SQL injection attacks, your code needs to construct SQL strings
    using bind parameters. *Bind parameters* are placeholder characters that the database
    driver will safely replace with some supplied inputs—like the email or password
    values shown in [Listing 6-1](ch06.xhtml#ch6list1). A SQL statement containing
    bind parameters is called a *parameterized statement*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止 SQL 注入攻击，你的代码需要使用绑定参数构建 SQL 字符串。*绑定参数* 是占位符字符，数据库驱动程序将安全地将其替换为一些提供的输入——如
    [列表 6-1](ch06.xhtml#ch6list1) 中显示的电子邮件或密码值。包含绑定参数的 SQL 语句称为 *参数化语句*。
- en: SQL injection attacks use “control characters” that have special meaning in
    SQL statements to “jump out” of the context and change the whole semantics of
    the SQL statement. When you use bind parameters, these control characters are
    prefixed with “escape characters” that tell the database not to treat the following
    character as a control character. This escaping of control characters defuses
    potential injection attacks.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入攻击利用在 SQL 语句中具有特殊意义的“控制字符”来“跳出”上下文并改变 SQL 语句的整体语义。当你使用绑定参数时，这些控制字符会被“转义字符”前缀标记，告诉数据库不要将后续字符视为控制字符。这种转义控制字符的方式有效地化解了潜在的注入攻击。
- en: A securely constructed SQL statement using bind parameters should look like
    [Listing 6-5](ch06.xhtml#ch6list5).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绑定参数安全构造的 SQL 语句应该像 [列表 6-5](ch06.xhtml#ch6list5) 中所示。
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 6-5: Using bind parameters to protect against SQL injection*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-5：使用绑定参数防止 SQL 注入*'
- en: This code constructs the SQL query in parameterized form using `?` as the bind
    parameter ❶. The code then *binds* the input values for each parameter to the
    statement ❷, asking the database driver to insert the parameter values into the
    SQL statement while securely handling any control characters. If an attacker attempts
    to hack this code using the method outlined in [Listing 6-4](ch06.xhtml#ch6list4)
    by passing in a username of `billy@email.com'--`, your securely constructed SQL
    statement will defuse the attack, as shown in [Listing 6-6](ch06.xhtml#ch6list6).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用 `?` 作为绑定参数 ❶ 以参数化形式构造 SQL 查询。然后，代码 *绑定* 每个参数的输入值到语句 ❷，请求数据库驱动程序将参数值插入
    SQL 语句，同时安全地处理任何控制字符。如果攻击者尝试使用 [列表 6-4](ch06.xhtml#ch6list4) 中概述的方法，通过传入用户名 `billy@email.com'--`
    来攻击这段代码，你安全构造的 SQL 语句将化解攻击，如 [列表 6-6](ch06.xhtml#ch6list6) 所示。
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 6-6: The SQL injection attack is defused.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-6：SQL 注入攻击已被化解。*'
- en: Because the database driver makes sure not to terminate the SQL statement early,
    this `SELECT` statement will safely return *no* users, and the attack should fail.
    Parameterized statements ensure that the database driver treats all control characters
    (such as `'`, `--`, and `;`) as an *input* to the SQL statement, rather than as
    part of the SQL statement. If you’re not sure whether your website is using parameterized
    statements, go check immediately! SQL injection is probably the biggest risk your
    website will face.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数据库驱动程序确保不会过早终止 SQL 语句，所以这个 `SELECT` 语句将安全地返回 *没有* 用户，攻击应该会失败。参数化语句确保数据库驱动程序将所有控制字符（如
    `'`、`--` 和 `;`）当作 SQL 语句的 *输入*，而不是 SQL 语句的一部分。如果你不确定你的网站是否使用了参数化语句，赶紧去检查一下！SQL
    注入可能是你的网站面临的最大风险。
- en: Similar types of injection attacks may be possible whenever a web server communicates
    with a separate backend by constructing a statement in the backend’s native language.
    This includes NoSQL databases like MongoDB and Apache Cassandra, distributed caches
    like Redis and Memcached, and directories that implement the Lightweight Directory
    Access Protocol (LDAP). Libraries that communicate with these platforms have their
    own implementation of bind parameters, so be sure to understand how they work
    and to use them in your code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的注入攻击可能发生在每当 Web 服务器通过在后台的本地语言中构建语句与独立后台通信时。这包括像 MongoDB 和 Apache Cassandra
    这样的 NoSQL 数据库，像 Redis 和 Memcached 这样的分布式缓存，以及实现轻量级目录访问协议（LDAP）的目录。与这些平台通信的库有自己实现的绑定参数，因此要确保理解它们的工作原理，并在代码中使用它们。
- en: '***Mitigation 2: Use Object-Relational Mapping***'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***缓解措施 2：使用对象关系映射***'
- en: Many web server libraries and frameworks abstract away the explicit construction
    of SQL statements in code and allow you to access data objects by using object-relational
    mapping. *Object-relational mapping (ORM)* libraries map rows in database tables
    to code objects in memory, meaning the developer generally doesn’t have to write
    their own SQL statements in order to read from and update the database. This architecture
    protects against SQL injection attacks under most circumstances, but can still
    be vulnerable if custom SQL statements are used—so it’s important to understand
    how your ORM works behind the scenes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Web 服务器库和框架将 SQL 语句的显式构建封装起来，并允许你通过使用对象关系映射来访问数据对象。*对象关系映射（ORM）* 库将数据库表中的行映射到内存中的代码对象，这意味着开发者通常不需要编写自己的
    SQL 语句来读取和更新数据库。这种架构在大多数情况下能防止 SQL 注入攻击，但如果使用自定义 SQL 语句，它仍然可能会受到攻击，因此了解 ORM 如何在后台工作非常重要。
- en: The ORM that people are probably most familiar with is the Ruby on Rails ActiveRecord
    framework. [Listing 6-7](ch06.xhtml#ch6list7) shows a simple line of Rails code
    that finds a user in a secure fashion.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 人们最熟悉的 ORM 可能是 Ruby on Rails 的 ActiveRecord 框架。[列表 6-7](ch06.xhtml#ch6list7)
    显示了一行简单的 Rails 代码，它以安全的方式查找用户。
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 6-7: Ruby on Rails code that looks up a user by email in a way that
    is protected against injection attacks*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-7：使用受保护的方式通过电子邮件查找用户的 Ruby on Rails 代码*'
- en: Because ORMs use bind parameters under the hood, they protect against injection
    attacks in most cases. However, most ORMs also have backdoors that allow the developer
    to write raw SQL if needed. If you use these types of functions, you need to be
    careful about how you construct the SQL statements. For instance, [Listing 6-8](ch06.xhtml#ch6list8)
    shows Rails code that *is* vulnerable to injection.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 ORM 在后台使用绑定参数，它们在大多数情况下能防止注入攻击。然而，大多数 ORM 也有后门，允许开发者在需要时编写原始 SQL。如果你使用这些类型的功能，需要小心构造
    SQL 语句。例如，[列表 6-8](ch06.xhtml#ch6list8) 显示了易受注入攻击的 Rails 代码。
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 6-8: Ruby on Rails code that is vulnerable to injection*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-8：易受注入攻击的 Ruby on Rails 代码*'
- en: Because this code passes part of the SQL statements as a raw string, an attacker
    can pass in special characters to manipulate the SQL statement that Rails generates.
    If the attacker can set the `password` variable to `' OR 1=1`, they can run a
    SQL statement that disables the password check, as shown in [Listing 6-9](ch06.xhtml#ch6list9).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段代码将部分 SQL 语句作为原始字符串传递，攻击者可以传递特殊字符来操控 Rails 生成的 SQL 语句。如果攻击者能将 `password`
    变量设置为 `' OR 1=1`，他们就可以运行一条 SQL 语句，禁用密码检查，如 [列表 6-9](ch06.xhtml#ch6list9) 所示。
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 6-9: The 1=1 statement, which is trivially true, disables the password
    check.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-9：1=1 语句，显然为真，禁用密码检查。*'
- en: The final clause of this SQL statement disables the password check, allowing
    the attacker to log in as that user. You can securely call the `where` function
    in Rails by using bind parameters, as shown in [Listing 6-10](ch06.xhtml#ch6list10).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这条 SQL 语句的最后一部分禁用了密码检查，允许攻击者以该用户身份登录。你可以通过使用绑定参数，安全地调用 Rails 中的 `where` 函数，如
    [列表 6-10](ch06.xhtml#ch6list10) 所示。
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 6-10: Secure use of the where function*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-10：安全使用 where 函数*'
- en: In this scenario, the ActiveRecord framework will securely handle any SQL control
    characters an attacker adds to the `email` or `password` parameter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，ActiveRecord 框架会安全地处理攻击者在 `email` 或 `password` 参数中添加的任何 SQL 控制字符。
- en: '***Bonus Mitigation: Use Defense in Depth***'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***奖励缓解：使用深度防御***'
- en: As a rule of thumb, you should always secure your website with redundancies.
    It’s not enough to check your code line by line for vulnerabilities. You need
    to consider and enforce security at every level of the stack, allowing failures
    at one level to be mitigated by other strategies. This is an approach called *defense
    in depth*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你应该始终通过冗余机制来保护你的网站。逐行检查代码中的漏洞并不足够，你需要在每个层级上考虑并执行安全性，使得某一层级的失败可以通过其他策略得到缓解。这种方法被称为
    *深度防御*。
- en: Consider how you secure your home. The most important defense is installing
    locks on all doors and windows, but it also helps to have a burglar alarm, security
    cameras, household insurance, and maybe a large bad-tempered dog, in order to
    cover all eventualities.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想你如何保护你的家。最重要的防御措施是给所有门窗安装锁，但拥有入侵警报、监控摄像头、家庭保险，也许还有一只脾气暴躁的大狗，可以帮助你应对各种可能的情况。
- en: When it comes to preventing SQL injection, defense in depth means using bind
    parameters, but also taking additional steps to minimize the harm in case an attacker
    *still* finds a way to successfully execute injection attacks. Let’s look at a
    couple of other ways to mitigate the risk of injection attacks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在防止 SQL 注入方面，深度防御意味着使用绑定参数，但同时也采取额外措施，以减少攻击者*仍然*能够成功执行注入攻击的风险。接下来，我们来看一些缓解注入攻击风险的其他方法。
- en: '**Principle of Least Privilege**'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**最小权限原则**'
- en: An additional way to mitigate injection attacks is to follow the *principle
    of least privilege*, which demands that every process and application run only
    with the permissions it needs to perform its permitted functions, and no more.
    This means that if an attacker injects code into your web server and compromises
    a particular software component, the damage they can do is limited to the actions
    permissible by that particular software component.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解注入攻击的另一种方法是遵循*最小权限原则*，要求每个进程和应用程序只能在执行其允许的功能时拥有必要的权限，不能更多。这意味着，如果攻击者将代码注入到你的
    Web 服务器并攻击特定的软件组件，他们所能造成的危害仅限于该组件所允许的操作。
- en: If your web server talks to a database, make sure the account it uses to log
    into the database has limited permissions on the data. Most websites need to run
    only SQL statements that fall under the subset of SQL called the *data manipulation
    language (DML)*, which includes the `SELECT`, `INSERT`, `UPDATE`, and `DELETE`
    statements we discussed earlier.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Web 服务器与数据库交互，请确保它用来登录数据库的帐户对数据的权限是有限的。大多数网站只需要运行属于 SQL 子集的 SQL 语句，即*数据操作语言（DML）*，这包括我们之前讨论过的
    `SELECT`、`INSERT`、`UPDATE` 和 `DELETE` 语句。
- en: A subset of the SQL language called *data definition language (DDL)* uses `CREATE`,
    `DROP`, and `MODIFY` statements to create, drop, and modify the table structures
    in the database itself. Web servers generally don’t require permissions to execute
    DDL statements, so don’t grant them the DDL set of permissions at runtime! Narrowing
    the web server privileges to the minimal DML set reduces the harm an attacker
    can do if they discover a code vulnerability.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 语言的一个子集称为*数据定义语言（DDL）*，它使用`CREATE`、`DROP`和`MODIFY`语句来创建、删除和修改数据库中的表结构。Web
    服务器通常不需要权限来执行 DDL 语句，因此在运行时不要授予它们 DDL 权限集！将 Web 服务器的权限缩小到最小的 DML 权限集，可以减少攻击者在发现代码漏洞时所能造成的危害。
- en: '**Blind and Nonblind SQL Injection**'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**盲注与非盲注 SQL 注入**'
- en: 'Hackers distinguish between blind and nonblind SQL injection attacks. If your
    website’s error message leaks sensitive information to the client, like the message
    `Unique constraint violated: this email address already exists in users table`,
    this is a *nonblind* SQL attack. In this scenario, the attacker gets immediate
    feedback on their attempts to compromise your system.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客区分盲注和非盲注 SQL 注入攻击。如果你的网站错误信息泄露了敏感信息给客户端，例如`唯一约束被违反：此电子邮件地址在用户表中已存在`，这就是一种*非盲注*
    SQL 攻击。在这种情况下，攻击者会立刻收到反馈，知道他们在尝试攻击时的结果。
- en: If you keep your error messages to the client more generic, like the messages
    `Could not find this username and password` or `An unexpected error occurred`,
    this is a *blind* SQL attack. This scenario means the attacker is effectively
    operating in the dark and has less to work with. Websites vulnerable to nonblind
    injection attacks are much easier to compromise, so avoid leaking information
    in error messages.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将错误信息发送给客户端时更加通用，比如`无法找到此用户名和密码`或`发生了意外错误`，这就是一种*盲注* SQL 攻击。此场景意味着攻击者实际上是在“黑暗”中操作，信息较少，难以攻击。易受非盲注攻击的站点更容易被入侵，因此要避免在错误信息中泄露信息。
- en: '**Command Injection**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**命令注入**'
- en: Another type of injection attack is *command injection*, which attackers can
    use to exploit a website that makes insecure command line calls to the underlying
    operating system. If your web application makes command line calls, make sure
    to construct your command strings securely. Otherwise, attackers can craft HTTP
    requests that execute arbitrary operating system commands, and seize control of
    your application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种注入攻击类型是*命令注入*，攻击者可以利用它来攻击那些向底层操作系统发出不安全命令行调用的网站。如果你的 Web 应用程序进行命令行调用，确保构造命令字符串时采取安全措施。否则，攻击者可以构造
    HTTP 请求，执行任意的操作系统命令，并接管你的应用程序。
- en: For many programming languages, constructing command strings to invoke operating
    systems is actually pretty unusual. Java, for example, runs in a virtual machine,
    so although you *could* call out to the operating system by using the `java.lang.Runtime`
    class, Java applications are generally designed to be portable between different
    operating systems, so relying on the availability of specific operating systems
    functions would go against its philosophy.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多编程语言来说，构建命令字符串以调用操作系统实际上是相当不寻常的。例如，Java在虚拟机中运行，因此，尽管你*可以*通过使用`java.lang.Runtime`类调用操作系统，Java应用程序通常设计为可在不同操作系统之间移植，因此依赖特定操作系统功能的可用性会违背其哲学。
- en: Command line calls are more common for interpreted languages. PHP is designed
    to follow the Unix philosophy—programs should do one thing and communicate with
    each other via text streams—so it’s common for PHP applications to call other
    programs via the command line. Similarly, Python and Ruby are popular for scripting
    tasks, so they make it easy to execute commands at the operating system level.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行调用在解释型语言中更为常见。PHP的设计遵循Unix哲学——程序应该专注于做一件事，并通过文本流相互通信——因此，PHP应用程序通常通过命令行调用其他程序。同样，Python和Ruby因其在脚本任务中的流行，简化了在操作系统级别执行命令的过程。
- en: '***Anatomy of a Command Injection Attack***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***命令注入攻击的结构***'
- en: If your website makes use of command line calls, make sure an attacker can’t
    trick the web server into injecting extra commands into the execution call. Imagine,
    for instance, that you have a simple website that does `nslookup` to resolve domains
    and IP addresses. The PHP code takes the domain or IP address from the HTTP request
    and constructs an operating system call as shown in [Listing 6-11](ch06.xhtml#ch6list11).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的网站使用命令行调用，请确保攻击者无法通过诱使Web服务器注入额外命令到执行调用中。例如，假设你有一个简单的网站，它执行`nslookup`来解析域名和IP地址。PHP代码从HTTP请求中获取域名或IP地址，并构建如[清单6-11](ch06.xhtml#ch6list11)所示的操作系统调用。
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 6-11: PHP code receiving an HTTP request and constructing an operating
    system call*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-11：接收HTTP请求并构建操作系统调用的PHP代码*'
- en: The `domain` parameter is extracted from the HTTP request at ❶. Because the
    code does not escape the `domain` argument when constructing the command string
    ❷, an attacker can craft a malicious URL and tag an extra command on the end,
    as shown in [Figure 6-1](ch06.xhtml#ch6fig1).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`domain`参数在❶处从HTTP请求中提取。因为代码在构建命令字符串时没有转义`domain`参数❷，攻击者可以构造一个恶意URL，并在末尾附加额外的命令，如[图6-1](ch06.xhtml#ch6fig1)所示。'
- en: '![image](Images/06fig01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/06fig01.jpg)'
- en: '*Figure 6-1: Using the URL to inject a malicious command*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：使用URL注入恶意命令*'
- en: 'Here the attacker sends a domain parameter with the value `google.com && echo
    "HAXXED"`, and the browser URL-encodes the whitespace and nonalphanumeric characters.
    The `&&` syntax in Unix concatenates separate commands. Because our PHP code doesn’t
    strip such control characters, the attacker carefully constructs the HTTP request
    to append an extra command. Two separate commands will get executed in this scenario:
    the expected `nslookup` command that looks up *google.com*, followed by the *injected*
    command `echo "HAXXED"`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，攻击者发送一个值为`google.com && echo "HAXXED"`的domain参数，浏览器会对空格和非字母数字字符进行URL编码。Unix中的`&&`语法用于连接多个命令。由于我们的PHP代码没有去除这样的控制字符，攻击者精心构造HTTP请求以附加额外的命令。在这种情况下，将执行两个独立的命令：预期的`nslookup`命令查询*google.com*，然后是*注入的*命令`echo
    "HAXXED"`。
- en: In this case, the injected command is a harmless `echo` command, which simply
    prints out `"HAXXED"` in the HTTP response. However, an attacker can use this
    vulnerability to inject and execute any command they choose on your server. With
    a bit of effort, they can explore the filesystem, read sensitive information,
    and compromise the entire application. Command line access on a web server gives
    the attacker complete freedom to take control of the system unless you take deliberate
    steps to lessen the impact.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，注入的命令是一个无害的`echo`命令，它仅仅在HTTP响应中打印出`"HAXXED"`。然而，攻击者可以利用这个漏洞在你的服务器上注入并执行他们选择的任何命令。只需稍加努力，他们就可以浏览文件系统、读取敏感信息，并危及整个应用程序。如果你的Web服务器允许命令行访问，攻击者将完全掌握系统的控制权，除非你采取有意的步骤来减少这种影响。
- en: '***Mitigation: Escape Control Characters***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***缓解措施：转义控制字符***'
- en: As with SQL injection, you can defend against command injection by properly
    escaping inputs from the HTTP request. This means replacing sensitive control
    characters (like the `&` character in our example) with a safe alternative. How
    you do this depends on the operating system and programing language you’re using.
    To make the PHP code in [Listing 6-11](ch06.xhtml#ch6list11) more secure, we simply
    need to use a call to `escapeshellarg`, as shown in [Listing 6-12](ch06.xhtml#ch6list12).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与SQL注入类似，通过适当转义来自HTTP请求的输入可以防御命令注入。这意味着用安全的替代方案替换敏感的控制字符（例如我们示例中的`&`字符）。如何实现这取决于您使用的操作系统和编程语言。为了使[列表6-11](ch06.xhtml#ch6list11)中的PHP代码更安全，我们只需使用`escapeshellarg`，如[列表6-12](ch06.xhtml#ch6list12)所示。
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 6-12: PHP code escaping inputs from the HTTP request*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-12：PHP代码转义HTTP请求中的输入*'
- en: The call to `escapeshellarg` ❶ ensures that attackers can’t inject extra commands
    via the `domain` parameter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`escapeshellarg`❶确保攻击者无法通过`domain`参数注入额外的命令。
- en: Python and Ruby can prevent potential command injection attacks too.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Python和Ruby也可以防止潜在的命令注入攻击。
- en: In Python, the `call()` function should be invoked with an array, rather than
    a string, to prevent attackers from tagging extra commands onto the end, as shown
    in [Listing 6-13](ch06.xhtml#ch6list13).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，应使用数组而不是字符串调用`call()`函数，以防止攻击者在末尾附加额外的命令，如[列表6-13](ch06.xhtml#ch6list13)所示。
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 6-13: The call function in Python’s subprocess module*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-13：Python subprocess模块中的call函数*'
- en: In Ruby, the `system()` function makes a command line call. Supply it with an
    array of arguments, rather than a string, to ensure that attackers can’t sneak
    in extra commands, as shown in [Listing 6-14](ch06.xhtml#ch6list14).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby中，`system()`函数执行命令行调用。请提供一个参数数组而不是字符串，以确保攻击者无法偷偷添加额外的命令，如[列表6-14](ch06.xhtml#ch6list14)所示。
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 6-14: The system() function in Ruby*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-14：Ruby中system()函数*'
- en: As with SQL injection, following the principle of least privilege also helps
    limit the impact of successful command injection attacks. Your web server process
    should run with only the permissions it requires. For instance, you should limit
    the directories the web server process can read from and write to. On Linux, you
    can use the `chroot` command to prevent the process from exploring outside a designated
    root directory. You should try to limit the network access your web server has,
    too, by configuring firewalls and access control lists on the network. These steps
    will make it much harder for a hacker to exploit a command injection vulnerability,
    because even if they can execute commands, they can’t do anything besides read
    files in the web server’s running directory.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与SQL注入类似，遵循最小权限原则也有助于限制成功命令注入攻击的影响。您的Web服务器进程应仅以所需的权限运行。例如，您应限制Web服务器进程可以读取和写入的目录。在Linux上，您可以使用`chroot`命令防止进程探索指定的根目录之外的内容。您还应通过配置防火墙和网络访问控制列表来限制Web服务器的网络访问。这些步骤将大大增加黑客利用命令注入漏洞的难度，因为即使他们可以执行命令，他们除了读取Web服务器运行目录中的文件外，什么都做不了。
- en: '**Remote Code Execution**'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**远程代码执行**'
- en: So far, you’ve seen how vulnerabilities can creep in when web code constructs
    a call to databases, as with SQL injection, or to the operating system it’s running
    on, as with command injection. In other circumstances, attackers can inject malicious
    code to be executed in the language of the web server itself, a tactic called
    *remote code execution*. Remote code execution attacks on websites are rarer than
    the injection attacks we discussed earlier, but every bit as dangerous.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到在Web代码构建对数据库的调用（如SQL注入）或运行在操作系统上的调用（如命令注入）时可能存在的漏洞。在其他情况下，攻击者可能会注入恶意代码，以在Web服务器本身的语言中执行，这种策略称为*远程代码执行*。与我们之前讨论过的注入攻击相比，网站上的远程代码执行攻击虽然较少见，但同样危险。
- en: '***Anatomy of a Remote Code Execution Attack***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***远程代码执行攻击的解剖***'
- en: An attacker can achieve remote code execution by discovering a vulnerability
    in a particular type of web server, and then creating *exploit scripts* to target
    websites running on that web server technology. The exploit script incorporates
    malicious code in the body of the HTTP request, encoded in such a way that the
    server will read and execute that code when the request is handled. The techniques
    used to perform remote execution attacks vary significantly. Security researchers
    will analyze codebases for common web servers, looking for vulnerabilities that
    permit malicious code to be injected.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过发现特定类型Web服务器中的漏洞，进而创建*利用脚本*，以针对运行该Web服务器技术的网站。利用脚本会在HTTP请求的主体中加入恶意代码，并以某种方式对其进行编码，以便服务器在处理请求时读取并执行该代码。执行远程代码的攻击技巧差异很大。安全研究人员会分析常见Web服务器的代码库，寻找允许恶意代码注入的漏洞。
- en: In early 2013, researchers discovered a vulnerability in Ruby on Rails that
    permitted attackers to inject their own Ruby code into the server process. Because
    the Rails framework automatically parses requests according to their `Content-Type`
    header, security researchers noticed that if they created an XML request with
    an embedded YAML object (a markup language commonly used in the Rails community
    for storing configuration data), they could trick the parsing process into executing
    arbitrary code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年初，研究人员发现了Ruby on Rails中的一个漏洞，允许攻击者将自己的Ruby代码注入到服务器进程中。由于Rails框架会根据请求的`Content-Type`头自动解析请求，安全研究人员注意到，如果他们创建一个包含嵌入式YAML对象的XML请求（YAML是一种常用于Rails社区存储配置数据的标记语言），他们可以欺骗解析过程执行任意代码。
- en: '***Mitigation: Disable Code Execution During Deserialization***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***缓解措施：禁用反序列化期间的代码执行***'
- en: Remote code execution vulnerabilities usually occur when web server software
    uses insecure serialization. *Serialization* is the process of converting an in-memory
    data structure into a stream of binary data, usually for the purpose of passing
    the data structure across a network. *Deserialization* refers to the reverse process
    that occurs at the other end, when the binary data is converted back into a data
    structure.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 远程代码执行漏洞通常发生在Web服务器软件使用不安全的序列化时。*序列化*是将内存中的数据结构转换为二进制数据流的过程，通常用于将数据结构通过网络传递。*反序列化*是指在另一端发生的相反过程，即将二进制数据转换回数据结构。
- en: Serialization libraries exist in every major programming language and are widely
    used. Some serialization libraries, such as the YAML parser used by Rails, allow
    data structures to execute code as they reinitialize themselves in memory. This
    is a useful feature if you trust the source of the serialized data, but can be
    *very* dangerous if you don’t, because it can permit arbitrary code execution.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化库存在于每个主要的编程语言中，并且被广泛使用。一些序列化库，例如Rails使用的YAML解析器，允许数据结构在重新初始化到内存时执行代码。如果你信任序列化数据的来源，这是一个有用的功能，但如果不信任，这可能会*非常*危险，因为它可能允许任意代码执行。
- en: If a web server uses deserialization to handle data coming in from HTTP requests,
    it needs to defuse any serialization libraries it uses by disabling any code-execution
    capabilities; otherwise, an attacker may be able to find a way to inject code
    directly into the web server process. We can typically disable code execution
    via a relevant configuration setting that will allow your web server software
    to deserialize data without executing code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Web服务器使用反序列化来处理来自HTTP请求的数据，则需要通过禁用任何代码执行功能来解除任何序列化库的影响；否则，攻击者可能能够找到一种方法，将代码直接注入到Web服务器进程中。我们通常可以通过相关的配置设置禁用代码执行，从而让Web服务器软件在反序列化数据时不执行代码。
- en: As a developer who uses a web server to build sites, rather than one who writes
    the web server code itself, protecting against remote code execution in your web
    stack usually amounts to staying aware of security advisories. You’re unlikely
    to be writing your own serialization libraries, so be aware of where your codebase
    uses third-party serialization libraries. Make sure to turn off active code execution
    features in your own code, and keep an eye out for vulnerability announcements
    issued by your web server vendor.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用Web服务器构建网站的开发人员，而非编写Web服务器代码的开发人员，防止远程代码执行的关键通常是保持对安全公告的关注。你不太可能自己编写序列化库，因此要注意你的代码库中使用了哪些第三方序列化库。确保关闭代码中的主动代码执行功能，并密切关注Web服务器供应商发布的漏洞公告。
- en: '**File Upload Vulnerabilities**'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文件上传漏洞**'
- en: 'The final type of injection attack we’ll look at in this chapter takes advantage
    of vulnerabilities in file upload functions. Websites use *file upload functions*
    for a variety of purposes: letting users add images to their profile or posts,
    adding attachments to messages, submitting paperwork, sharing documents with other
    users, and so on. Browsers make it easy to upload files via built-in file-upload
    widgets and JavaScript APIs that allow you to drag files onto a web page and send
    them asynchronously to the server.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论的最后一种注入攻击，利用的是文件上传功能中的漏洞。网站使用*文件上传功能*有多种目的：允许用户为他们的个人资料或帖子添加图片、为消息添加附件、提交文件、与其他用户共享文档等等。浏览器通过内置的文件上传控件和
    JavaScript API，使上传文件变得非常容易，用户可以将文件拖到网页上，并异步发送到服务器。
- en: However, browsers aren’t exactly careful about checking the contents of a file.
    Attackers can easily abuse file upload functions by injecting malicious code into
    an uploaded file. Web servers typically treat uploaded files like large blobs
    of binary data, so it’s pretty easy for an attacker to upload a malicious payload
    without the web server detecting it. Even if your site has JavaScript code that
    checks a file’s content before uploading it, an attacker can write scripts to
    post file data to the server-side endpoint directly, circumventing any security
    measures you put in place on the client side.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，浏览器在检查文件内容时并不特别谨慎。攻击者可以轻松地通过将恶意代码注入到上传的文件中，滥用文件上传功能。Web 服务器通常将上传的文件视为大型二进制数据块，因此攻击者可以非常轻松地上传恶意载荷，而不被
    Web 服务器检测到。即使你的网站有 JavaScript 代码在上传之前检查文件内容，攻击者仍然可以编写脚本，直接将文件数据发送到服务器端的端点，绕过你在客户端设置的任何安全措施。
- en: Let’s see how attackers typically exploit file upload functions so that we identify
    the various security weaknesses that we need to plug.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看攻击者通常是如何利用文件上传功能的，以便识别我们需要修补的各种安全漏洞。
- en: '***Anatomy of a File Upload Attack***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件上传攻击的结构***'
- en: As an example of a file upload vulnerability, let’s look at how an attacker
    could potentially abuse the profile image upload function of your site. The attacker
    first writes a small *web shell*, a simple executable script that will take an
    argument from an HTTP request, execute it on the command line, and output the
    result. Web shells are a common tool used by hackers attempting to compromise
    a web server. [Listing 6-15](ch06.xhtml#ch6list15) shows an example of a web shell
    written in PHP.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 作为文件上传漏洞的一个示例，让我们看看攻击者如何可能滥用你网站的个人头像上传功能。攻击者首先编写一个小型*web shell*，这是一个简单的可执行脚本，它会从
    HTTP 请求中获取一个参数，在命令行中执行，并输出结果。Web shell 是黑客用来尝试攻破 Web 服务器的常见工具。[清单 6-15](ch06.xhtml#ch6list15)展示了一个用
    PHP 编写的 web shell 示例。
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 6-15: A web shell written in the PHP language*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-15：用 PHP 语言编写的 web shell*'
- en: The attacker saves this script as *hack.php* on their computer and uploads it
    as their profile “image” on your site. PHP files are typically treated by operating
    systems as *executable* files, which is key to making this attack work. Clearly
    a file ending with *.php* isn’t a valid image file, but the attacker can fairly
    easily disable any JavaScript file-type checking done during the upload process.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者将这个脚本保存为 *hack.php* 并作为他们的个人资料“图片”上传到你的网站。操作系统通常将 PHP 文件视为*可执行*文件，这对于让此攻击得以成功至关重要。显然，一个以
    *.php* 结尾的文件并不是一个有效的图片文件，但攻击者可以相当轻松地禁用上传过程中任何 JavaScript 文件类型检查。
- en: 'Once the attacker has uploaded their “image” file, their website profile page
    will show a missing image icon, because their profile image is corrupted and not
    actually an image. However, at this point they have achieved their real aim: smuggling
    the web shell file onto your server, which means their malicious code is now deployed
    to your site, waiting to be executed in some fashion.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦攻击者上传了他们的“图片”文件，他们的个人主页将显示一个缺失的图片图标，因为他们的个人头像已经损坏，实际上并不是一张图片。然而，此时他们已经达到了真正的目的：将
    web shell 文件偷偷上传到你的服务器上，这意味着他们的恶意代码已经部署到你的网站，等待以某种方式执行。
- en: Because the web shell is available on a public URL, the attacker has potentially
    created a backdoor for executing the malicious code. If your server’s operating
    system has a PHP runtime installed, and the file was written to disk with executable
    privileges during the upload process, the attacker can pass commands to run the
    web shell simply by invoking the URL that corresponds to their profile image.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Web Shell 可通过公共 URL 访问，攻击者可能已创建了一个用于执行恶意代码的后门。如果你的服务器操作系统安装了 PHP 运行时，并且文件在上传过程中以可执行权限写入磁盘，攻击者可以通过调用与其个人资料图片对应的
    URL，简单地传递命令来运行 Web Shell。
- en: To perform a command injection attack, the hacker can pass a `cmd` argument
    to the web shell to execute arbitrary operating system commands on your server,
    as shown in [Figure 6-2](ch06.xhtml#ch6fig2).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行命令注入攻击，黑客可以将一个 `cmd` 参数传递给 Web Shell，以在你的服务器上执行任意操作系统命令，如[图 6-2](ch06.xhtml#ch6fig2)所示。
- en: '![image](Images/06fig02.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/06fig02.jpg)'
- en: '*Figure 6-2: If your file upload function is vulnerable, a hacker could use
    a web shell to access your database credentials.*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：如果你的文件上传功能存在漏洞，黑客可能利用 Web Shell 访问你的数据库凭据。*'
- en: In this scenario, the attacker can explore your filesystem. The attacker has
    taken advantage of your file upload function to gain the same access to your operating
    system as they would with a command injection attack.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，攻击者可以探索你的文件系统。攻击者利用你的文件上传功能，获得与命令注入攻击相同的操作系统访问权限。
- en: '***Mitigations***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***缓解措施***'
- en: You can use several mitigations to protect yourself against vulnerabilities
    in file upload code. The most important mitigations ensure that any uploaded files
    can’t be executed as code. Following the principle of defense in depth, you should
    also analyze uploaded files and reject any that appear to be corrupt or malicious.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用几种缓解措施来保护自己免受文件上传代码漏洞的影响。最重要的缓解措施是确保任何上传的文件无法作为代码执行。遵循深度防御原则，你还应该分析上传的文件，拒绝任何看起来有损坏或恶意的文件。
- en: '**Mitigation 1: Host Files on a Secure System**'
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**缓解措施 1：将文件托管在安全的系统上**'
- en: The first, most important approach to securing file upload functions is to ensure
    that your web server treats uploaded files as inert rather than executable objects.
    You can do this by hosting your uploaded files in a content delivery network (CDN)
    such as Cloudflare or Akamai, as described in [Chapter 4](ch04.xhtml#ch04), which
    offloads the security burden to a third party who stores your files securely.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 确保文件上传功能安全的首要方法是确保你的 Web 服务器将上传的文件视为惰性对象，而不是可执行对象。你可以通过将上传的文件托管在内容分发网络（CDN）中，如
    Cloudflare 或 Akamai，来实现这一点，正如[第 4 章](ch04.xhtml#ch04)中所描述的，这样可以将安全负担转移给第三方，由他们安全地存储你的文件。
- en: CDNs have other nonsecurity-related benefits too. CDNs serve files extremely
    fast to the browser, and can put them through processing pipelines as you upload
    them. Many CDNs offer sophisticated JavaScript upload widgets that you can add
    with a few lines of code, and that provide bonus features like image cropping.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: CDN 也有其他与安全无关的好处。CDN 可以将文件极其快速地传送到浏览器，并且可以在上传时将其通过处理管道处理。许多 CDN 提供复杂的 JavaScript
    上传小工具，你只需添加几行代码，就能提供像图片裁剪这样的额外功能。
- en: If for some reason a CDN isn’t an option, you can get many of the same benefits
    by storing uploaded files in cloud-based storage (for example, Amazon Simple Storage
    Service, or S3) or a dedicated content management system. Both approaches provide
    secure storage that defuses all web shells as they’re uploaded. (Although, if
    you’re hosting your own content management system, you’ll have to make sure to
    configure it correctly.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果因为某些原因 CDN 不是一个选项，你可以通过将上传的文件存储在云存储（例如 Amazon 简单存储服务或 S3）或专用的内容管理系统中来获得许多相同的好处。这两种方法都提供了安全存储，能够在文件上传时消除所有
    Web Shell。（尽管，如果你托管自己的内容管理系统，你必须确保正确配置它。）
- en: '**Mitigation 2: Ensure Uploaded Files Cannot Be Executed**'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**缓解措施 2：确保上传的文件无法执行**'
- en: If using a CDN or content management system isn’t an option, you need to take
    the same steps to secure your files that a CDN or content management does behind
    the scenes. This means ensuring that all files are written to disk without executable
    permissions, separating uploaded files into a particular directory or partition
    (so they aren’t intermingled with code), and *hardening* your servers so that
    only the minimally required software is installed. (Uninstall the PHP engine if
    you aren’t using it!) It’s a good idea to rename files as you upload them too,
    so you don’t write files with dangerous file extensions to disk.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法使用 CDN 或内容管理系统，你需要采取与 CDN 或内容管理系统在后台执行相同的步骤来保护你的文件。这意味着确保所有文件都写入磁盘时没有可执行权限，将上传的文件分隔到特定的目录或分区（这样它们就不会与代码混合），并且*加固*你的服务器，只安装最基本的必需软件。（如果你不使用
    PHP 引擎，请卸载它！）在上传文件时重命名文件也是个好主意，这样你就不会将带有危险扩展名的文件写入磁盘。
- en: The ways to achieve these ends vary depending on your hosting technology, operating
    system, and the programming language you use. If you’re running a Python web server
    on Linux, for instance, you can set file permissions when creating a file by using
    the `os` module, as shown in [Listing 6-16](ch06.xhtml#ch6list16).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些目标的方法取决于你所使用的托管技术、操作系统以及编程语言。例如，如果你在 Linux 上运行一个 Python Web 服务器，你可以通过使用
    `os` 模块，在创建文件时设置文件权限，如 [列表 6-16](ch06.xhtml#ch6list16) 所示。
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 6-16: Writing a file with read-write (but not execute) permissions
    in Python on Linux*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-16：在 Linux 上使用 Python 写入具有读写（但不可执行）权限的文件*'
- en: Removing unneeded software from your operating system is always a good idea,
    because it gives a hacker fewer tools to play with. The Center for Internet Security
    (CIS) provides prehardened operating system images that make a good starting point.
    They’re available as Docker images or as Amazon Machine Images (AMIs) in the Amazon
    Web Services Marketplace.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作系统中移除不需要的软件总是个好主意，因为这会减少黑客使用的工具。互联网安全中心（CIS）提供了预加固的操作系统镜像，作为良好的起点。这些镜像可以作为
    Docker 镜像或在 Amazon Web Services Marketplace 中提供的 Amazon 机器镜像（AMI）使用。
- en: '**Mitigation 3: Validate the Content of Uploaded Files**'
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**缓解措施 3：验证上传文件的内容**'
- en: If you’re uploading files with a known file type, consider adding some file-type
    checking in your code. Make sure the `Content-Type` header in the HTTP request
    of the upload matches the expected file type, but be aware that an attacker can
    easily spoof the header.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你上传的是已知文件类型，考虑在代码中添加一些文件类型检查。确保上传的 HTTP 请求中的 `Content-Type` 头与预期的文件类型相符，但要注意攻击者很容易伪造该头部。
- en: It’s possible to validate the file type after the file has been uploaded, particularly
    with image files, so it’s a good idea to implement this feature in your server-side
    code, as shown in [Listing 6-17](ch06.xhtml#ch6list17). Your mileage should vary,
    though; clever hackers in the past have infiltrated various systems by designing
    payloads that are valid for more than one type of file format.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件上传后验证文件类型是可能的，特别是对于图像文件，因此在服务器端代码中实现此功能是个好主意，如 [列表 6-17](ch06.xhtml#ch6list17)
    所示。不过，你的实际效果可能会有所不同；过去，一些聪明的黑客通过设计有效的有效载荷来渗透各种系统，这些有效载荷对多种文件格式都是有效的。
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 6-17: Reading the file headers to validate a file format in Python*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-17：在 Python 中读取文件头部以验证文件格式*'
- en: '**Mitigation 4: Run Antivirus Software**'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**缓解措施 4：运行防病毒软件**'
- en: Finally, if you’re running on a server platform that’s prone to viruses (hello,
    Microsoft Windows!) make sure you’re running up-to-date antivirus software. File
    upload functions are an open door to virus payloads.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你在容易感染病毒的服务器平台上运行（你好，Microsoft Windows！），确保你正在运行最新的防病毒软件。文件上传功能是病毒有效载荷的一个敞开的大门。
- en: '**Summary**'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned about various injection attacks, whereby an attacker
    crafts malicious HTTP requests to take control of backend systems.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了各种注入攻击，其中攻击者构造恶意 HTTP 请求以控制后端系统。
- en: SQL injection attacks take advantage of web code that doesn’t securely construct
    SQL strings when communicating with a SQL database. You can mitigate SQL injection
    by using bind parameters when communicating with the database driver.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入攻击利用了 Web 代码在与 SQL 数据库通信时没有安全构建 SQL 字符串的漏洞。你可以通过在与数据库驱动程序通信时使用绑定参数来减轻
    SQL 注入攻击。
- en: Command injection attacks take advantage of code that makes insecure calls to
    operating system functions. You can similarly defuse command injection through
    correct use of binding.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 命令注入攻击利用了那些不安全地调用操作系统函数的代码。你可以通过正确使用绑定来同样防止命令注入。
- en: Remote code execution vulnerabilities allow hackers to run exploits inside the
    web server process itself, and typically stem from insecure serialization libraries.
    Make sure to stay on top of any security advisories for the serialization libraries
    you use, and for your web server software.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 远程代码执行漏洞允许黑客在网页服务器进程内执行漏洞利用代码，通常源自不安全的序列化库。确保密切关注你所使用的序列化库和网页服务器软件的任何安全公告。
- en: File upload functions often enable command injection attacks if your file upload
    functionality writes uploaded files to disk with executable privileges. Make sure
    to write uploads to a third-party system or to disk with appropriate permissions,
    and do whatever you can to validate the file type as you upload them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 文件上传功能如果在上传文件时赋予文件可执行权限，往往会导致命令注入攻击。确保将上传的文件写入第三方系统或具有适当权限的磁盘，并尽可能在上传时验证文件类型。
- en: 'You can mitigate the risks around all types of injection attacks by following
    the principle of least privilege: processes and software components should run
    with only the permissions they require to perform their assigned tasks, and no
    more. This approach reduces the harm an attack can do if they inject harmful code.
    Examples of following the principle of least privilege include limiting file and
    network access for your web server process, and connecting to your database under
    an account with limited permissions.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循最小权限原则，你可以降低所有类型的注入攻击的风险：进程和软件组件应当仅使用执行其分配任务所需的权限，而不是更多。这种方法能够减少攻击者注入有害代码时造成的损害。遵循最小权限原则的例子包括限制网页服务器进程的文件和网络访问权限，以及在有限权限的账户下连接到数据库。
- en: In the next chapter, you’ll look at how hackers can use JavaScript vulnerabilities
    to attack your website.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解黑客如何利用JavaScript漏洞攻击你的网页。
