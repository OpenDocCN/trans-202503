- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2'
- en: COMBINATORIAL LOGIC**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 组合逻辑**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: In the 1967 *Star Trek* episode “The City on the Edge of Forever,” Mr. Spock
    says, “I am endeavoring, ma’am, to construct a mnemonic memory circuit using stone
    knives and bearskins.” Like Mr. Spock, people have come up with all sorts of ingenious
    ways to build computing devices using the resources available to them. Few fundamental
    technologies were invented explicitly for computing; most were invented for other
    purposes and then *adapted* for computing. This chapter covers some of this evolution,
    leading up to the convenient but fairly recent innovation of electricity.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在1967年《星际迷航》剧集《永恒之边》的“城市边缘”一集中，斯波克先生说：“女士，我正在努力用石刀和熊皮构建一个记忆电路。”像斯波克先生一样，人们也想出了各种巧妙的方式，利用现有资源构建计算设备。很少有基础技术是专门为计算而发明的；大多数技术是为其他目的发明的，然后被*改编*为计算用途。本章将介绍这一演变过程，直到电力这一方便但相对较新的创新出现。
- en: In [Chapter 1](ch01.xhtml#ch01), you learned that modern computers use binary
    containers called *bits* for their internal language. You may wonder why computers
    use bits when decimal numbers work fine for people. In this chapter, we’ll start
    by looking at some early computing devices that *didn’t* use bits to learn why
    bits are the right choice for the technology available today. Bits aren’t found
    naturally in a useful form for computing, so we’ll talk about what’s needed to
    make them. We’ll work through some older, simpler technologies like relays and
    vacuum tubes, then compare them to the modern implementation of bits in hardware
    using electricity and integrated circuits.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml#ch01)中，你了解到现代计算机使用二进制容器，称为*位*，作为其内部语言。你可能会想，既然十进制对人类来说很有效，为什么计算机要使用位呢？本章开始时，我们将通过研究一些早期不使用位的计算设备，来了解为什么位是今天技术的正确选择。位在自然界中并不以对计算有用的形式存在，因此我们将讨论制造位所需的条件。我们将研究一些较旧、更简单的技术，比如继电器和真空管，然后将它们与使用电力和集成电路的现代硬件实现位进行比较。
- en: The discussion of bits in [Chapter 1](ch01.xhtml#ch01) was pretty abstract.
    Here we’ll be getting down to the nitty-gritty. Physical devices, including those
    that operate on bits, are called *hardware*. We’ll talk about hardware that implements
    *combinatorial logic*, another name for the Boolean algebra discussed in [Chapter
    1](ch01.xhtml#ch01). And just as you did in that chapter, here you’ll learn about
    the simple building blocks first and then we’ll combine them to yield more complex
    functionality.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.xhtml#ch01)中关于位（bits）的讨论比较抽象。在这里，我们将进入更具体的内容。物理设备，包括那些基于位操作的设备，通常被称为*硬件*。我们将讨论实现*组合逻辑*的硬件，组合逻辑是[第1章](ch01.xhtml#ch01)中讨论的布尔代数的另一种说法。正如你在该章节中所做的那样，这里你将首先学习简单的构建模块，然后我们将把它们组合起来，以实现更复杂的功能。'
- en: '**The Case for Digital Computers**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数字计算机的论据**'
- en: Let’s begin by looking at some gear-based mechanical computing devices that
    predate the modern era. When two gears are meshed together, the ratio of the number
    of teeth on each gear determines their relative speed, making them useful for
    multiplication, division, and other calculations. One gear-based mechanical device
    is the Antikythera mechanism, the oldest known example of a computer, found off
    a Greek island and dating back to around 100 BCE. It performed astronomical calculations
    whereby the user entered a date by turning a dial and then turned a crank to get
    the positions of the sun and the moon on that date. Another example is World War
    II–era artillery fire control computers, which performed trigonometry and calculus
    using lots of strangely shaped gears with a complex design that made them works
    of art as well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些基于齿轮的机械计算设备开始，这些设备比现代计算机早。两颗齿轮相互啮合时，每个齿轮的齿数比决定了它们的相对速度，使其适用于乘法、除法和其他计算。一种基于齿轮的机械设备是安提凯希拉机械装置，这是已知最古老的计算机实例，出土于希腊的一个岛屿，追溯到公元前100年左右。它执行天文计算，用户通过旋转旋钮输入日期，然后转动曲柄，得到当天太阳和月亮的位置。另一个例子是二战时期的火炮射击控制计算机，它们通过许多形状奇特的齿轮和复杂的设计来执行三角学和微积分运算，这些齿轮设计得如此精美，也成了艺术品。
- en: An example of a mechanical computer that doesn’t use gears is the *slide rule*,
    invented by English minister and mathematician William Oughtred (1574–1660). It’s
    a clever application of logarithms that were discovered by Scottish physicist,
    astronomer, and mathematician John Napier (1550–1617). The basic function of a
    slide rule is to perform multiplication by exploiting the fact that log(*x* ×
    *y*) = log(*x*) + log(*y*).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不使用齿轮的机械计算机例子是*滑尺*，由英国牧师和数学家威廉·奥特雷德（William Oughtred，1574–1660）发明。它是对由苏格兰物理学家、天文学家和数学家约翰·纳皮尔（John
    Napier，1550–1617）发现的对数的巧妙应用。滑尺的基本功能是通过利用对数的性质 log(*x* × *y*) = log(*x*) + log(*y*)
    来进行乘法运算。
- en: A slide rule has fixed and moving scales marked in logarithms. It computes the
    product of two numbers by lining up the fixed *x* scale with the moving *y* scale,
    as shown in [Figure 2-1](ch02.xhtml#ch02fig01).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 滑尺有固定和移动的刻度，这些刻度标记着对数。它通过将固定的*x*刻度与移动的*y*刻度对齐来计算两个数字的乘积，如[图2-1](ch02.xhtml#ch02fig01)所示。
- en: '![Image](../images/02fig01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig01.jpg)'
- en: '*Figure 2-1: Slide rule addition*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-1：滑尺加法*'
- en: Considered by many to be the first mass-produced computing device, the slide
    rule is a great example of how people solved a problem using the technology available
    to them at the time. Today, airplane pilots still use a circular version of the
    slide rule called a *flight computer* that performs navigation-related calculations
    as a backup device.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 被许多人认为是第一个大规模生产的计算设备，滑尺是一个很好的例子，展示了人们如何利用当时可用的技术解决问题。今天，飞机飞行员仍然使用一种圆形版本的滑尺，称为*飞行计算机*，作为备份设备进行与导航相关的计算。
- en: Counting is a historically important application of computing devices. Because
    of our limited supply of fingers—and the fact that we need them for other things—notched
    bones and sticks called *tally sticks* were used as computing aids as early as
    18,000 BCE. There is even a theory that the Egyptian Eye of Horus was used to
    represent binary fractions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 计数是计算设备一个历史上重要的应用。由于我们手指的数量有限——而且我们还需要它们做其他事情——刻痕骨头和棒子被称为*计数棒*，早在公元前18,000年就被用作计算辅助工具。甚至有一种理论认为埃及的荷鲁斯之眼被用来表示二进制分数。
- en: English polymath Charles Babbage (1791–1871) convinced the British government
    to fund the construction of a complex decimal mechanical calculator called a *difference
    engine*, which was originally conceived by Hessian army engineer Johann Helfrich
    von Müller (1746–1830). Popularized by the William Gibson and Bruce Sterling novel
    named after it, the difference engine was ahead of its time because the metalworking
    technologies of the period were not up to the task of making parts with the required
    precision.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 英国博学家查尔斯·巴贝奇（Charles Babbage，1791–1871）说服英国政府资助建造一台复杂的十进制机械计算器，称为*差分机*，该机最初由黑森军队工程师约翰·赫尔弗里希·冯·穆勒（Johann
    Helfrich von Müller，1746–1830）构思。差分机因威廉·吉布森和布鲁斯·斯特林的小说而广为人知，该小说以其命名，差分机超越了其时代，因为当时的金属加工技术无法精确制造所需的零部件。
- en: Simple decimal mechanical calculators could be built, however, as they didn’t
    require the same level of metalworking sophistication. For example, adding machines
    that could add decimal numbers were created in the mid-1600s for bookkeeping and
    accounting. Many different models were mass-produced, and later versions of adding
    machines replaced hand-operated levers with electric motors that made them easier
    to operate. In fact, the iconic old-fashioned cash register was an adding machine
    combined with a money drawer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，简单的十进制机械计算器是可以制造的，因为它们不需要同等水平的金属加工技术。例如，用于记账和会计的加法机在17世纪中期就已被发明出来，可以进行十进制数字的加法。许多不同型号的加法机都已大规模生产，后来的加法机版本用电动机取代了手动杠杆，使操作更加简便。事实上，经典的老式收银机就是一台加法机，配有一个钱箱。
- en: All of these historical examples fall into two distinct categories, as we’ll
    discuss next.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些历史例子可以分为两种截然不同的类别，正如我们接下来要讨论的。
- en: '***The Difference Between Analog and Digital***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模拟与数字的区别***'
- en: There’s an important difference between devices such as the slide rule versus
    tally sticks or adding machines. [Figure 2-2](ch02.xhtml#ch02fig02) illustrates
    one of the slide rule scales from [Figure 2-1](ch02.xhtml#ch02fig01) compared
    to a set of numbered fingers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备之间，如滑尺与计数棒或加法机之间，有一个重要的区别。[图2-2](ch02.xhtml#ch02fig02)展示了与一组标记手指对比的滑尺刻度之一，来源于[图2-1](ch02.xhtml#ch02fig01)。
- en: '![Image](../images/02fig02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig02.jpg)'
- en: '*Figure 2-2: Continuous and discrete measures*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-2：连续与离散度量*'
- en: Both the slide rule scale and the fingers go from 1 to 10\. We can represent
    values such as 1.1 on the scale, which is pretty handy, but we can’t do that using
    fingers without some fancy prestidigitation (sleight of hand or maybe doing the
    hand jive). That’s because the scale is what mathematicians call *continuous*,
    meaning that it can represent real numbers. The fingers, on the other hand, are
    what mathematicians call *discrete* and can only represent integers. There are
    no values between integers. They jump from one whole number value to another,
    like our fingers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 滑尺刻度和手指的范围都从1到10。我们可以在刻度上表示1.1这样的值，这非常方便，但如果用手指表示就不行了，除非使用一些巧妙的魔术（如快速变换手势）。这是因为刻度是数学家所称的*连续*的，意味着它可以表示实数。而手指则是数学家所称的*离散*的，只能表示整数。在整数之间没有其他值，它们像手指一样，从一个整数跳到另一个整数。
- en: When we’re talking about electronics, we use the word *analog* to mean continuous
    and *digital* to mean discrete (it’s easy to remember that fingers are digital
    because the Latin word for finger is *digitus*). You’ve probably heard the terms
    analog and digital before. You’ve been learning to program using digital computers,
    of course, but you may not have been aware that analog computers such as slide
    rules also exist.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论电子学时，我们使用*模拟*这个词来表示连续的，而*数字*则表示离散的（记住手指是数字的，源于拉丁词*digitus*）。你可能听说过模拟和数字这两个术语。你当然一直在使用数字计算机进行编程，但你可能没有意识到，模拟计算机，比如滑尺，实际上也存在。
- en: On one hand, analog appears to be the better choice for computing because it
    can represent real numbers. But there are problems with precision. For example,
    we can pick out the number 1.1 on the slide rule scale in [Figure 2-2](ch02.xhtml#ch02fig02)
    because that part of the scale is spacious and there’s a mark for it. But it’s
    much harder to find 9.1 because that part of the scale is more crowded and the
    number is somewhere between the tick marks for 9.0 and 9.2\. The difference between
    9.1 and 9.105 would be difficult to discern even with a microscope.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，模拟看起来是计算的更好选择，因为它可以表示实数。但存在精度问题。例如，我们可以在[图2-2](ch02.xhtml#ch02fig02)的滑尺刻度上找出数字1.1，因为这一部分的刻度较为空旷，并且有标记。但找到9.1就难多了，因为这一部分的刻度更加拥挤，数字位于9.0和9.2的刻度之间。即使用显微镜，也很难分辨9.1和9.105之间的差异。
- en: Of course, we could make the scales larger. For example, we could get a lot
    more accurate if the scale were the length of a football field. But it would be
    hard to make a portable computer with 120-yard-long scales, not to mention the
    huge amount of energy it would take to manipulate such large objects. We want
    computers that are small, fast, and low in power consumption. We’ll learn another
    reason why size is important in the next section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以把刻度做得更大。例如，如果刻度是足球场那么长，我们的精度会更高。但如果刻度长达120码，做成便携计算机将非常困难，更别提操控这么大的物体需要大量的能源了。我们希望计算机既小巧，又快速，并且功耗低。接下来我们会了解另一个尺寸重要的原因。
- en: '***Why Size Matters in Hardware***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***硬件中为何尺寸很重要***'
- en: Imagine you have to drive your kids to and from school, which is 10 miles away,
    at an average speed of 40 miles per hour. The combination of distance and speed
    means that only two round trips per hour are possible. You can’t complete the
    trip more quickly without either driving faster or moving closer to school.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你必须开车送孩子们上下学，学校距离10英里，平均速度是40英里每小时。距离和速度的组合意味着每小时只能来回两次。你不能更快地完成这趟行程，除非你开得更快或离学校更近。
- en: Modern computers drive electrons around instead of kids. Electricity travels
    at the speed of light, which is about 300 million meters per second (except in
    the US, where it goes about a billion feet per second). Because we haven’t yet
    discovered a way around this physical limitation, the only way we can minimize
    travel time in computers is to have the parts close together.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机驱动电子流动，而不是孩子们。电流的传播速度是光速，大约每秒3亿米（除了在美国，电流的速度大约是每秒十亿英尺）。由于我们尚未发现绕过这一物理限制的方法，我们能在计算机中最小化旅行时间的唯一方法就是将各个部件放得更近一些。
- en: Computers today can have clock speeds around 4 GHz, which means they can do
    four billion things per second. Electricity only travels about 75 millimeters
    in a four-billionth of a second.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的计算机时钟速度大约为4 GHz，这意味着它们每秒可以做四十亿件事情。电流在四十亿分之一秒内大约只能传播75毫米。
- en: '[Figure 2-3](ch02.xhtml#ch02fig03) shows a typical CPU that measures about
    18 millimeters on each side. There’s just enough time to make two complete round
    trips across this CPU in four-billionths of a second. It follows that making things
    small permits higher performance.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](ch02.xhtml#ch02fig03)显示了一款典型的CPU，边长约为18毫米。在四十亿分之一秒的时间里，刚好足够完成两次完整的往返穿越这款CPU。因此，事物做得更小可以实现更高的性能。'
- en: '![Image](../images/02fig03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig03.jpg)'
- en: '*Figure 2-3: CPU photomicrograph (Courtesy of Intel Corporation)*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：CPU 光学显微照片（感谢英特尔公司提供）*'
- en: Also, just like driving kids to and from school, it takes energy to travel,
    and coffee alone is insufficient. Making things small reduces the amount of travel
    needed, which reduces the amount of energy needed. That translates into lower
    power consumption and less heat generation, which keeps your phone from burning
    a hole in your pocket. This is one of the reasons why the history of computing
    devices has been characterized by efforts to make hardware smaller. But making
    things very small introduces other problems.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，就像接送孩子上下学一样，旅行需要能量，而仅仅喝咖啡是不够的。将事物做得更小可以减少所需的旅行距离，从而减少所需的能量。这意味着更低的功耗和更少的热量产生，从而防止手机把你的口袋烤穿。这也是计算设备历史上一直致力于使硬件更小的原因之一。但把事物做得非常小也会带来其他问题。
- en: '***Digital Makes for More Stable Devices***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数字化使设备更稳定***'
- en: Although making things small allows for speed and efficiency, it’s pretty easy
    to interfere with things that are very small. German physicist Werner Heisenberg
    (1901–1976) was absolutely certain about that.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管把东西做得更小可以提高速度和效率，但它也很容易干扰到非常小的事物。德国物理学家沃纳·海森堡（1901-1976）对此非常确定。
- en: Picture a glass measuring cup with lines marked for 1 through 10 ounces. If
    you put some water in the cup and hold it up, it may be hard to tell how many
    ounces are in the cup because your hand shakes a little. Now imagine that the
    measuring cup was a billion times smaller. Nobody would be able to hold it still
    enough to get an accurate reading. In fact, even if you put that tiny cup on a
    table, it still wouldn’t work because at that size, atomic motion would keep it
    from holding still. At very small scales, the universe is a noisy place.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个玻璃量杯，杯身上标有从1到10盎司的刻度线。如果你往杯子里加水并举起来，可能很难确定杯子里有多少盎司，因为你的手会稍微颤抖。现在想象一下，如果量杯小一亿倍。没有人能将它保持静止到足以获得准确的读数。事实上，即使你把这个微小的杯子放在桌子上，它仍然无法正常工作，因为在那个尺度下，原子运动会使它无法静止。在极小的尺度下，宇宙是一个充满噪声的地方。
- en: Both the measuring cup and the slide rule are analog (continuous) devices that
    don’t take much jiggling to produce incorrect readings. Disturbances like stray
    cosmic radiation are enough to make waves in microscopic measuring cups, but they’re
    less likely to affect discrete devices such as fingers, tally sticks, or mechanical
    calculators. That’s because discrete devices employ *decision criteria*. There
    are no “between” values when you’re counting on your fingers. We could modify
    a slide rule to include decision criteria by adding *detents* (some sort of mechanical
    sticky spots) at the integer positions. But as soon as we do that, we’ve made
    it a discrete device and eliminated its ability to represent real numbers. In
    effect, decision criteria prevent certain ranges of values from being represented.
    Mathematically, this is similar to rounding numbers to the nearest integer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 量杯和计算尺都是模拟（连续）设备，稍微晃动一下就可能产生不准确的读数。像宇宙辐射这样的干扰足以在微观量杯中产生波动，但它们不太可能影响像手指、计数棒或机械计算器这样的离散设备。因为离散设备采用了*决策标准*。当你用手指计数时，没有“中间”的数值。如果我们在计算尺的整数位置加上*定位点*（某种机械的卡位），我们就可以将其改造为包含决策标准的设备。但一旦我们这样做，它就变成了一个离散设备，失去了表示实数的能力。实际上，决策标准会阻止某些范围的数值被表示出来。从数学上讲，这类似于将数字四舍五入到最接近的整数。
- en: So far, we’ve talked about interference as if it comes from outside, so you
    might think we could minimize it by using some sort of shielding. After all, lead
    protected Superman from kryptonite. But there is another, more insidious source
    of interference. Electricity affects things at a distance, just like gravity—which
    is good, or we wouldn’t have radio. But that also means that a signal traveling
    down a wire on a chip can affect signals on other wires, especially when they’re
    so close together. The wires on a modern computer chip are a few nanometers (10^(–9)
    meters) apart. For comparison, a human hair is about 100,000 nanometers in diameter.
    This interference is a bit like the wind you feel when two cars pass each other
    on the road. Because there’s no simple way to protect against this *crosstalk*
    effect, using digital circuitry that has higher *noise immunity* from the decision
    criteria is essential. We could, of course, decrease the impact of interference
    by making things bigger so that wires are farther apart, but that would run counter
    to our other goals. The extra energy it takes to jump over the hurdle of a decision
    criterion gives us a degree of immunity from the noise that we don’t get by using
    continuous devices.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的干扰仿佛来自外部，所以你可能认为我们可以通过某种屏蔽来最小化它。毕竟，铅保护超人免受氪石的影响。但还有另一个更隐蔽的干扰来源。电力像引力一样远距离影响物体——这很好，否则我们就不会有无线电了。但这也意味着信号沿着芯片上的导线传播时，可能会影响到其他导线上的信号，特别是当它们非常靠近时。现代计算机芯片上的导线相距几纳米（10^(-9)米）。相比之下，一根人类头发的直径大约是100,000纳米。这种干扰有点像两辆车在路上擦身而过时你感受到的风。由于没有简单的方法可以防止这种*串扰*效应，因此使用决策标准具有更高*噪声免疫力*的数字电路至关重要。当然，我们可以通过让物体变得更大，以使导线之间的距离更远，从而减少干扰的影响，但这与我们的其他目标相悖。跨越决策标准的额外能量使我们获得了一定程度的免疫力，能够抵抗我们使用连续设备时无法获得的噪声干扰。
- en: In fact, the stability that comes from using decision criteria is the primary
    reason we build digital (discrete) computers. But, as you may have noticed, the
    world is an analog (continuous) place, as long as we stay away from things that
    are so small that quantum physics applies. In the next section, you’ll learn how
    we manipulate the analog world to get the digital behavior necessary for building
    stable computing devices.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，使用决策标准所带来的稳定性是我们构建数字（离散）计算机的主要原因。但正如你可能注意到的，世界是一个模拟（连续）的地方，只要我们远离那些微小到量子物理适用的事物。在接下来的部分，你将学习如何操作模拟世界，以获得构建稳定计算设备所需的数字行为。
- en: '***Digital in an Analog World***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数字化的模拟世界***'
- en: A lot of engineering involves clever applications of naturally occurring *transfer
    functions* discovered by scientists. These are just like the functions you learn
    about in math class, except they represent phenomena in the real world. For example,
    [Figure 2-4](ch02.xhtml#ch02fig04) shows a graph of the transfer function for
    a digital camera sensor (or the film in an old-style analog camera, for that matter).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 很多工程涉及到科学家发现的自然发生的*传输函数*的巧妙应用。这些函数就像你在数学课上学到的函数，只不过它们表示的是现实世界中的现象。例如，[图 2-4](ch02.xhtml#ch02fig04)展示了数字相机传感器（或老式模拟相机中的胶片）的传输函数图。
- en: '![Image](../images/02fig04.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig04.jpg)'
- en: '*Figure 2-4: Camera sensor or film transfer function*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：相机传感器或胶片传输函数*'
- en: The x-axis shows the amount of light coming in (input), and the y-axis represents
    the amount of recorded brightness, or the light registered by the sensor (output).
    The curve represents the relationship between them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: x 轴表示进入的光线量（输入），y 轴表示记录的亮度或传感器注册的光线量（输出）。曲线表示它们之间的关系。
- en: Let’s play transfer function pool by bouncing an input ball off of the curve
    to get an output. You can see that the transfer function produces different values
    of recorded brightness for different values of light. Notice that the curve isn’t
    a straight line. If too much of the light hits the *shoulder* of the curve, then
    the image will be overexposed, since the recorded brightness values will be closer
    together than in the actual scene. Likewise, if we hit the *toe* of the curve,
    the shot is going to be underexposed. The goal (unless you’re trying for a special
    effect) is to adjust your exposure to hit the *linear region*, which will yield
    the most faithful representation of reality.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将输入球弹到曲线上来玩传递函数池，从而得到输出。你可以看到，传递函数对于不同的光照值产生不同的记录亮度值。请注意，曲线并不是一条直线。如果光线过多地打到曲线的*肩部*，图像将会曝光过度，因为记录的亮度值将比实际场景中的亮度值更接近。类似地，如果光线打到曲线的*脚部*，则图像会曝光不足。目标是（除非你在追求特殊效果）调整曝光量，使其落在*线性区域*，这将提供最忠实的现实表现。
- en: Engineers have developed all manner of tricks to take advantage of transfer
    functions, such as adjusting the shutter speed and aperture on a camera so that
    the light hits the linear region. Amplifier circuits, such as those that drive
    the speakers or earbuds in your music player, are another example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师们已经开发出各种技巧来利用传递函数，例如调整相机的快门速度和光圈，使光线落入线性区域。放大器电路，比如驱动你音乐播放器中的扬声器或耳机的电路，就是另一个例子。
- en: '[Figure 2-5](ch02.xhtml#ch02fig05) shows the effect that changing the volume
    has on an amplifier transfer function.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-5](ch02.xhtml#ch02fig05)展示了改变音量对放大器传递函数的影响。'
- en: '![Image](../images/02fig05.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig05.jpg)'
- en: '*Figure 2-5: Effect of gain on amplifier transfer function*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：增益对放大器传递函数的影响*'
- en: The volume control adjusts the *gain*, or steepness of the curve. As you can
    see, the higher the gain, the steeper the curve and the louder the output. But
    what if we have one of those special amplifiers from the 1984 movie *This Is Spinal
    Tap* on which the gain can be cranked up to 11? Then the signal is no longer confined
    to the linear region. This results in *distortion* because the output is no longer
    a faithful reproduction of the input, which makes it sound bad. You can see in
    [Figure 2-6](ch02.xhtml#ch02fig06) that the output doesn’t look like the input
    because the input extends outside the linear region of the transfer function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 音量控制调整*增益*，即曲线的陡峭程度。如你所见，增益越高，曲线越陡，输出也越大声。但如果我们有一个1984年电影《This Is Spinal Tap》中的特殊放大器，增益可以调到11呢？那样信号就不再局限于线性区域了。这就会导致*失真*，因为输出不再是输入的忠实再现，听起来会很糟糕。你可以在[图
    2-6](ch02.xhtml#ch02fig06)中看到，输出看起来不像输入，因为输入已经超出了传递函数的线性区域。
- en: '![Image](../images/02fig06.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig06.jpg)'
- en: '*Figure 2-6: Amplifier clipping*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：放大器削波*'
- en: A small change in the input causes a jump in the output at the steep part of
    the curve. It’s like jumping from one finger to another—the sought-after decision
    criterion, called a *threshold*. This distortion is a useful phenomenon because
    the output values fall on one side of the threshold or the other; it’s difficult
    to hit those in between. This partitions the continuous space into discrete regions,
    which is what we want for stability and noise immunity—the ability to function
    in the presence of interference. You can think of analog as aiming for a big linear
    region and digital as wanting a small one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的一个小变化会在曲线的陡峭部分导致输出的跳跃。这就像从一个手指跳到另一个手指——这就是我们所追求的决策标准，称为*阈值*。这种失真是一个有用的现象，因为输出值要么落在阈值的一侧，要么落在另一侧；很难落在两者之间。这将连续空间划分为离散区域，这对于稳定性和抗噪声性很重要——即在干扰存在的情况下仍能正常工作。你可以将模拟信号看作是瞄准一个大的线性区域，而数字信号则希望拥有一个小的线性区域。
- en: You may have intuitively discovered this phenomenon while playing on a seesaw
    as a child (if you had the good fortune to grow up in an era before educational
    playground equipment was deemed dangerous, that is). It’s much more stable to
    be in the toe region (all the way down) or the shoulder region (all the way up)
    than it is to try to balance somewhere in between.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在小时候玩跷跷板时（如果你幸运地成长在一个教育游乐设施尚未被认为危险的时代）直觉地发现了这个现象。处于脚部区域（完全下沉）或肩部区域（完全上升）要比试图在两者之间平衡要稳定得多。
- en: '***Why Bits Are Used Instead of Digits***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***为什么使用比特而不是数字***'
- en: We’ve talked about why digital technology is a better choice for computers than
    analog. But why do computers use bits instead of digits? After all, people use
    digits, and we’re really good at counting to 10 because we have 10 fingers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过为什么数字技术比模拟技术更适合计算机。但为什么计算机使用位而不是数字呢？毕竟，人类使用数字，我们非常擅长数到10，因为我们有10根手指。
- en: The obvious reason is that computers don’t have fingers. That would be creepy.
    On one hand, counting on your fingers may be intuitive, but it’s not a very efficient
    use of your fingers because you use one finger per digit. On the other hand, if
    you use each finger to represent a value as you did with bits, you can count to
    more than 1,000\. This is not a new idea; in fact, the Chinese used 6-bit numbers
    to reference hexagrams in the *I Ching* as early as 9 BCE. Using bits instead
    of fingers improves efficiency by a factor of more than 100\. Even using groups
    of four fingers to represent decimal numbers using the binary-coded decimal (BCD)
    representation we saw in [Chapter 1](ch01.xhtml#ch01) beats our normal counting
    method in the efficiency department.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的原因是计算机没有手指。如果有手指，那会很吓人。一方面，依靠手指来计数可能是直观的，但这不是一种高效的使用手指的方法，因为每个数字都用一个手指。另一方面，如果你用每根手指来表示一个值，就像处理位一样，你可以数到超过1,000。这并不是一个新想法；实际上，中国人早在公元前9年就使用6位数字来表示《易经》中的卦象。使用位代替手指提高了效率，效率提高了100倍以上。即使使用四根手指来表示十进制数，采用我们在[第1章](ch01.xhtml#ch01)中看到的二进制编码十进制（BCD）表示法，效率也要比我们正常的计数方法高。
- en: Another reason why bits are better than digits for hardware is that with digits,
    there’s no simple way to tweak a transfer function to get 10 distinct thresholds.
    We could build hardware that implements the left side of [Figure 2-7](ch02.xhtml#ch02fig07),
    but it would be much more complicated and expensive than 10 copies of the one
    that implements the right side of the figure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个位比数字更适合硬件的原因是，使用数字时，没有简单的方法来调整传输函数，以获得10个不同的阈值。我们可以构建实现[图2-7](ch02.xhtml#ch02fig07)左侧的硬件，但它比10个实现图右侧的硬件要复杂和昂贵得多。
- en: '![Image](../images/02fig07.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig07.jpg)'
- en: '*Figure 2-7: Decimal versus binary thresholds*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-7：十进制与二进制阈值*'
- en: Of course, if we *could* build 10 thresholds in the same space as one, we’d
    do that. But, as we’ve seen, we’d be better off with 10 bits instead of one digit.
    This is how modern hardware works. We take advantage of the transfer function’s
    toe and shoulder regions, called *cutoff* and *saturation*, respectively, in electrical
    engineering language. There’s plenty of wiggle room; getting the wrong output
    would take a lot of interference. The transfer function curve is so steep that
    the output snaps from one value to another.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们*能够*在与一个阈值相同的空间中构建10个阈值，我们会这么做。但是，正如我们所看到的，使用10个位比使用一个数字更好。这就是现代硬件的工作方式。我们利用传输函数的脚部和肩部区域，在电气工程语言中称之为*截止*和*饱和*。这里有足够的自由空间；要获得错误的输出需要很多干扰。传输函数曲线非常陡峭，输出会迅速从一个值跳跃到另一个值。
- en: '**A Short Primer on Electricity**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**电力简明入门**'
- en: Modern computers function by manipulating electricity. Electricity makes computers
    faster and easier to build than other current technologies would. This section
    will help you learn enough about electricity that you can understand how it’s
    used in computer hardware.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机通过操控电力来运作。电力使得计算机比其他当前技术更快速、更容易构建。本节将帮助你了解足够的电力知识，以便你能够理解它是如何在计算机硬件中被使用的。
- en: '***Using Plumbing to Understand Electricity***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过水管来理解电力***'
- en: Electricity is invisible, which makes it hard to visualize, so let’s imagine
    that it’s water. Electricity comes from an energy source such as a battery just
    like water comes from a tank. Batteries run out of energy and need recharging,
    just like water tanks go dry and need refilling. The sun is the only major source
    of energy we have; in the case of water, heat from the sun causes evaporation,
    which turns into rain that refills the tank.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 电力是不可见的，这使得它很难被直观地理解，所以让我们假设它是水。电力来自像电池这样的能源，就像水来自水箱一样。电池会耗尽能量，需要充电，就像水箱会空掉，需要重新加水一样。太阳是我们唯一的主要能源；对于水来说，太阳的热量会导致蒸发，形成雨水，重新填满水箱。
- en: Let’s start with a simple water valve, something like [Figure 2-8](ch02.xhtml#ch02fig08).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的水阀开始，就像[图2-8](ch02.xhtml#ch02fig08)所示那样。
- en: '![Image](../images/02fig08.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig08.jpg)'
- en: '*Figure 2-8: A water valve*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-8：一个水阀*'
- en: As you can see, there’s a handle that opens and closes the valve. [Figure 2-9](ch02.xhtml#ch02fig09)
    shows a real-life gate valve, which gets its name after the gate that is opened
    and closed by the handle. Water can get through when the valve is open. We’ll
    make believe that 0 means closed and 1 means open.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，阀门上有一个手柄用来打开和关闭阀门。[图 2-9](ch02.xhtml#ch02fig09)展示了一个现实生活中的门阀，它得名于通过手柄开启和关闭的门。阀门打开时，水可以流过。我们假设
    0 代表关闭，1 代表打开。
- en: '![Image](../images/02fig09.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig09.jpg)'
- en: '*Figure 2-9: Closed and open gate valve*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-9：闭合和打开的门阀*'
- en: We can use two valves and some pipe to illustrate the AND operation, as shown
    in [Figure 2-10](ch02.xhtml#ch02fig10).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用两个阀门和一些管道来说明 AND 操作，如[图 2-10](ch02.xhtml#ch02fig10)所示。
- en: '![Image](../images/02fig10.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig10.jpg)'
- en: '*Figure 2-10: Plumbing for the AND operation*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-10：与 AND 操作相关的管道布置*'
- en: As you can see, water flows only when both valves are open, or equal to 1, which
    as you learned in [Chapter 1](ch01.xhtml#ch01) is the definition of the AND operation.
    When the output of one valve is hooked to the input of another, as in [Figure
    2-10](ch02.xhtml#ch02fig10), it’s called a *series connection*, which implements
    the AND operation. A *parallel connection*, as shown in [Figure 2-11](ch02.xhtml#ch02fig11),
    results from connecting the inputs of valves and the outputs of valves together,
    which implements the OR operation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，水只有在两个阀门都打开，或者说等于 1 时才会流动，这就是你在[第一章](ch01.xhtml#ch01)中学到的 AND 操作的定义。当一个阀门的输出连接到另一个阀门的输入时，如[图
    2-10](ch02.xhtml#ch02fig10)所示，这叫做*串联连接*，它实现了 AND 操作。*并联连接*，如[图 2-11](ch02.xhtml#ch02fig11)所示，是通过将阀门的输入和输出连接在一起实现的，它实现了
    OR 操作。
- en: '![Image](../images/02fig11.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig11.jpg)'
- en: '*Figure 2-11: Plumbing for the OR operation*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-11：与 OR 操作相关的管道布置*'
- en: Just as it takes time for electricity to make its way across a computer chip,
    it takes time for water to flow or propagate through a pipe. You’ve probably experienced
    this when waiting for the water temperature to change in the shower after you’ve
    turned the knobs. This effect is called *propagation delay*, and we’ll talk more
    about it soon. The delay is not a constant; with water, the temperature causes
    the pipes to expand or contract, which changes the flow rate and thus the delay
    time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就像电流需要时间通过计算机芯片一样，水流通过管道也需要时间。你可能在洗澡时经历过这种现象，当你调节水龙头后，需要等待水温发生变化。这种现象被称为*传播延迟*，我们稍后会详细讨论。这个延迟不是恒定的；在水流中，温度会导致管道膨胀或收缩，从而改变流速，进而影响延迟时间。
- en: 'Electricity travels through a wire like water travels through a pipe. It’s
    a flow of electrons. There are two parts to a piece of wire: the metal inside,
    like the space inside a pipe, is the *conductor*, and the covering on the outside,
    like the water pipe itself, is the *insulator*. The flow can be turned on and
    off with valves. In the world of electricity, valves are called *switches*. They’re
    so similar that a mostly obsolete device called a vacuum tube was also known as
    a thermionic valve.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 电流通过电线的方式就像水流过管道一样。它是电子的流动。电线有两个部分：内部的金属，像管道内部的空间一样，是*导体*；外部的覆盖层，像水管本身一样，是*绝缘体*。通过阀门可以控制电流的开启和关闭。在电力世界中，阀门被称为*开关*。它们非常相似，甚至一个几乎过时的设备——真空管，也曾被称为热电子阀。
- en: Water doesn’t just trickle passively through plumbing pipes; it’s pushed by
    *pressure*, which can vary in strength. The electrical equivalent of water pressure
    is *voltage*, measured in *volts (V)*, named after Italian physicist Alessandro
    Volta (1745–1827). The amount of flow is called the *current (I)*, and that’s
    measured in *amperes*, named after French mathematician André-Marie Ampère (1775–1836).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 水流并非只是被动地通过管道，它是由*压力*推动的，压力的强度可以变化。水压的电学对应物是*电压*，其单位是*伏特 (V)*，以意大利物理学家亚历山德罗·伏打（Alessandro
    Volta，1745–1827）的名字命名。流量的大小称为*电流 (I)*，其单位是*安培*，以法国数学家安德烈-玛丽·安培（André-Marie Ampère，1775–1836）的名字命名。
- en: Water can course through wide pipes or narrow ones, but the narrower the pipe,
    the more that resistance limits the amount of water that can flow through. Even
    if you have a lot of voltage (water pressure), you can’t get very much current
    (flow) if there’s a lot of resistance from using too narrow a conductor (pipe).
    *Resistance (R)* is measured in *ohms (Ω)*, named after German mathematician and
    physicist Georg Simon Ohm (1789–1854).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 水可以通过宽管道或窄管道流动，但管道越窄，阻力就越大，从而限制了水流的量。即使你有很高的电压（水压），如果使用的导体（管道）太窄，电流（流量）也无法很大。*电阻（R）*的单位是*欧姆（Ω）*，以德国数学家和物理学家
    Georg Simon Ohm（1789–1854）的名字命名。
- en: These three variables—voltage, current, and resistance—are all related by *Ohm’s
    law*, which says *I* = *V*/*R*, read as “current equals voltage divided by resistance
    (ohms).” So, as with water pipes, more resistance means less current. Resistance
    also turns electricity into heat, which is how everything from toasters to electric
    blankets works. [Figure 2-12](ch02.xhtml#ch02fig12) illustrates how resistance
    makes it harder for voltage to push current.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种变量——电压、电流和电阻——都通过*欧姆定律*相关联，该定律表示为*I* = *V*/*R*，可以解读为“电流等于电压除以电阻（欧姆）”。因此，像水管一样，更多的电阻意味着更小的电流。电阻还会将电能转化为热能，这就是烤面包机和电热毯等设备的工作原理。[图2-12](ch02.xhtml#ch02fig12)展示了电阻如何使电压更难推动电流。
- en: '![Image](../images/02fig12.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig12.jpg)'
- en: '*Figure 2-12: Ohm’s law*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-12：欧姆定律*'
- en: An easy way to understand Ohm’s law is to suck a milkshake through a straw.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 理解欧姆定律的一个简单方法是通过吸管吸奶昔。
- en: '***Electrical Switches***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***电气开关***'
- en: Making a switch (valve) for electricity is just a matter of inserting or removing
    an insulator from between conductors. Think of manually operated light switches.
    They contain two pieces of metal that either touch or are pushed apart by the
    handle that operates the switch. It turns out that air is a pretty good insulator;
    electricity can’t flow if the two pieces of metal aren’t touching. (Notice I said
    air is a “pretty good” insulator; at a high enough voltage, air ionizes and turns
    into a conductor. Think lightning.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 制造一个电气开关（阀门）实际上只是将一个绝缘体插入或移除在导体之间的过程。可以想象手动操作的电灯开关。它们包含两块金属片，通过操作开关的把手使两块金属片接触或分开。事实证明，空气是一个相当好的绝缘体；如果两块金属片不接触，电流就无法流动。（注意，我说空气是“相当好的”绝缘体；在足够高的电压下，空气会电离并变成导体。想想闪电。）
- en: The plumbing system in a building can be shown on a blueprint. Electrical systems
    called *circuits* are documented using *schematic diagrams*, which use symbols
    for each of the components. [Figure 2-13](ch02.xhtml#ch02fig13) shows the symbol
    for a simple switch.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑物中的水管系统可以通过蓝图展示。电气系统被称为*电路*，它们通过*示意图*记录，示意图使用符号表示每个组件。[图2-13](ch02.xhtml#ch02fig13)显示了一个简单开关的符号。
- en: '![Image](../images/02fig13.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig13.jpg)'
- en: '*Figure 2-13: Single-pole, single-throw switch schematic*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-13：单极单刀开关示意图*'
- en: 'This kind of switch is like a drawbridge: electricity (cars) can’t get from
    one side to the other when the arrow on the diagram (the bridge) is up. This is
    easy to see on the old-fashioned *knife switches*, shown in [Figure 2-14](ch02.xhtml#ch02fig14)
    and often featured in cheesy science fiction movies. Knife switches are still
    used for things like electrical disconnect boxes, but these days they’re usually
    hidden inside protective containers to make it harder for you to fry yourself.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种开关就像是吊桥：当图示中的箭头（桥）抬起时，电流（汽车）无法从一侧流向另一侧。这个原理在老式的*刀刀开关*中很容易看到，如[图2-14](ch02.xhtml#ch02fig14)所示，它们常出现在一些低成本的科幻电影中。刀刀开关现在仍用于一些像电力切断箱这样的设备，但如今它们通常被隐藏在保护容器内，以防止你不小心触电。
- en: '![Image](../images/02fig14.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig14.jpg)'
- en: '*Figure 2-14: Single-pole, single-throw knife switch*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-14：单极单刀刀开关*'
- en: '[Figures 2-13](ch02.xhtml#ch02fig13) and [2-14](ch02.xhtml#ch02fig14) both
    show *single-pole, single-throw (SPST)* switches. A *pole* is the number of switches
    connected together that move together. Our water valves in the preceding section
    were single pole; we could make a *double-pole* valve by welding a bar between
    the handles on a pair of valves so that they both move together when you move
    the bar. Switches and valves can have any number of poles. *Single-throw* means
    that there’s only one point of contact: something can be either turned on or off,
    but not one thing off and another on at the same time. To do that, we’d need a
    *single-pole, double-throw (SPDT)* device. [Figure 2-15](ch02.xhtml#ch02fig15)
    shows the symbol for such a beast.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-13](ch02.xhtml#ch02fig13)和[2-14](ch02.xhtml#ch02fig14)都展示了*单极单投（SPST）*开关。*极*是指连接在一起的开关数量，这些开关一起移动。在前一部分的水阀中，我们使用的是单极阀；我们可以通过在一对阀门的手柄之间焊接一根杠杆来制作一个*双极*阀，这样当你移动杠杆时，它们会一起移动。开关和阀门可以有任意数量的极。*单投*意味着只有一个接触点：某个设备要么开，要么关，但不能同时开和关。要做到这一点，我们需要一个*单极双投（SPDT）*设备。[图
    2-15](ch02.xhtml#ch02fig15)展示了这种设备的符号。'
- en: '![Image](../images/02fig15.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig15.jpg)'
- en: '*Figure 2-15: SPDT switch schematic*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-15: SPDT 开关原理图*'
- en: This is like a railroad switch that directs a train onto one track or another,
    or a pipe that splits into two pipes, as shown in [Figure 2-16](ch02.xhtml#ch02fig16).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像是一个铁路道岔，把火车引到一条轨道上，或者像[图 2-16](ch02.xhtml#ch02fig16)所示的管道，分成两条管道。
- en: '![Image](../images/02fig16.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig16.jpg)'
- en: '*Figure 2-16: SPDT water valve*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-16: SPDT 水阀*'
- en: As you can see, when the handle is pushed down, water flows through the top
    valve. Water would flow through the bottom valve if the handle were pushed up.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当手柄被按下时，水会通过上方的阀门流动。如果手柄被推上去，水则会通过下方的阀门流动。
- en: Switch terminology can be extended to describe any number of poles and throws.
    For example, a *double-pole, double-throw (DPDT)* switch would be drawn as shown
    in [Figure 2-17](ch02.xhtml#ch02fig17), with the dashed line indicating that the
    poles are *ganged*, meaning they move together.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 开关术语可以扩展到描述任何数量的极和投掷。例如，*双极双投（DPDT）*开关将在[图 2-17](ch02.xhtml#ch02fig17)中绘制，虚线表示极是*联动*的，意味着它们一起移动。
- en: '![Image](../images/02fig17.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig17.jpg)'
- en: '*Figure 2-17: DPDT switch schematic*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-17: DPDT 开关原理图*'
- en: '[Figure 2-18](ch02.xhtml#ch02fig18) shows what a DPDT knife switch looks like
    in real life.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-18](ch02.xhtml#ch02fig18)显示了现实中DPDT刀开关的样子。'
- en: '![Image](../images/02fig18.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig18.jpg)'
- en: '*Figure 2-18: DPDT knife switch*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-18: DPDT 刀开关*'
- en: 'I left out a few details about our waterworks earlier: the system won’t work
    unless the water has somewhere to go. Water can’t go in if the drain is clogged.
    And there has to be some way to get the water from the drain back to the water
    tank, or the system will run dry.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我在之前的水务部分略去了几个细节：系统无法正常工作，除非水有去处。如果排水口堵塞，水就进不去。而且必须有某种方式将水从排水口引回水箱，否则系统将会干涸。
- en: 'Electrical systems are similar. Electricity from the energy source passes through
    the components and returns to the source. That’s why it’s called an electrical
    *circuit*. Or think about it like this: a person running track has to make it
    back to the starting line in order to do another lap.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 电气系统类似。电力从能源源通过各个组件流动并返回源头。这就是为什么它被称为电气*电路*。或者你可以这么想：一个人跑步时必须回到起跑线才能进行下一圈。
- en: Look at the simple electrical circuit in [Figure 2-19](ch02.xhtml#ch02fig19).
    It introduces two new symbols, one for a voltage source (on the left) and one
    for a light bulb (on the right). If you built such a circuit, you could turn the
    light on and off using the switch.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下[图 2-19](ch02.xhtml#ch02fig19)中的简单电路。它引入了两个新符号，一个表示电压源（在左侧），另一个表示灯泡（在右侧）。如果你构建了这样的电路，你就可以通过开关打开和关闭灯光。
- en: '![Image](../images/02fig19.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig19.jpg)'
- en: '*Figure 2-19: A simple electrical circuit*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-19: 简单电路*'
- en: Electricity can’t flow when the switch is open. When the switch is closed, current
    flows from the voltage source through the switch, through the light bulb, and
    back to the voltage source. Series and parallel switch arrangements work just
    like their water valve counterparts.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当开关打开时，电流无法流动。当开关闭合时，电流从电压源流过开关，经过灯泡，然后回到电压源。串联和并联开关的安排就像它们的水阀对应物一样工作。
- en: Now you’ve learned a little about electricity and some basic circuit elements.
    Although they can be used to implement some simple logic functionality, they’re
    not powerful enough by themselves to do much else. In the next section, you’ll
    learn about an additional device that made early electrically powered computers
    possible.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了一些关于电力和基本电路元件的知识。虽然它们可以用于实现一些简单的逻辑功能，但它们本身的能力不足以做更多的事情。在下一节中，你将了解一个额外的设备，它使早期的电力驱动计算机成为可能。
- en: '**Building Hardware for Bits**'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为比特构建硬件**'
- en: Now that you’ve seen why we use bits for hardware, you’re ready to learn how
    they’re built. Diving straight into modern-day electronic implementation technologies
    can be daunting, so instead I’ll build up the discussion from other historical
    technologies that are easier to understand. Although some of these examples aren’t
    used in today’s computers, you may still encounter them in systems that work alongside
    computers, so they’re worth knowing about.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了为什么我们在硬件中使用比特，你可以开始学习它们是如何构建的。直接进入现代电子实现技术可能会让人觉得有些难以理解，因此我会从其他历史技术开始，逐步展开讨论，这些技术更容易理解。虽然这些例子在今天的计算机中没有被使用，但你可能会在与计算机配套工作的系统中遇到它们，因此了解它们还是很有价值的。
- en: '***Relays***'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***继电器***'
- en: Electricity was used to power computers long before the invention of electronics.
    There’s a convenient relationship between electricity and magnetism, discovered
    by Danish physicist Hans Christian Ørsted (1777–1851) in 1820\. If you coil up
    a bunch of wire and run some electricity through it, it becomes an *electromagnet*.
    Electromagnets can be turned on and off and can be used to move things. They can
    also be used to control water valves, which is how most automatic sprinkler systems
    work. There are clever ways to make motors using electromagnetism. And waving
    a magnet around a coil of wire produces electricity, which is how a generator
    works; that’s how we get most of our electricity, in fact. Just in case you’re
    inclined to play with these things, turning off the electricity to an electromagnet
    is equivalent to waving a magnet near the coil very fast. It can be a very shocking
    experience, but this effect, called *back-EMF*, is handy; it’s how a car ignition
    coil makes the spark for the spark plugs. It’s also how electric fences work.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 早在电子学发明之前，电力就已经被用来为计算机提供动力。丹麦物理学家汉斯·克里斯蒂安·厄尔斯特（Hans Christian Ørsted，1777–1851）在1820年发现了电与磁之间的关系。只要将一捆电线缠绕起来并通电，就能形成一个*电磁铁*。电磁铁可以开启和关闭，并且可以用来移动物体。它们还可以用来控制水阀，这也是大多数自动喷灌系统的工作原理。利用电磁学的原理可以巧妙地制造电动机。用磁铁围绕电线线圈旋转会产生电流，这就是发电机的工作原理；事实上，这就是我们获得大多数电力的方式。如果你有兴趣尝试这些东西，切断电磁铁的电流相当于快速地将磁铁在电线圈附近挥动。这可能会带来非常强烈的电击感，但这种效应被称为*反电动势（back-EMF）*，非常有用；这就是汽车点火线圈制造火花塞火花的方式。它也是电围栏工作的原理。
- en: A *relay* is a device that uses an electromagnet to move a switch. [Figure 2-20](ch02.xhtml#ch02fig20)
    shows the symbol for a single-pole, double-throw relay, which you can see looks
    a lot like the symbol for a switch grafted to a coil.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*继电器*是一种利用电磁铁来移动开关的装置。[图 2-20](ch02.xhtml#ch02fig20)展示了一个单刀双掷继电器的符号，你可以看到它看起来像是一个开关符号与电线圈结合的样子。'
- en: '![Image](../images/02fig20.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig20.jpg)'
- en: '*Figure 2-20: SPDT relay schematic*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-20：SPDT 继电器原理图*'
- en: '[Figure 2-21](ch02.xhtml#ch02fig21) shows a real-life example of a single-pole,
    single-throw relay. The switch part is open when there is no power on the coil,
    so it’s called a *normally open* relay. It would be a *normally closed* relay
    if the switch were closed without power.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-21](ch02.xhtml#ch02fig21)展示了一个实际的单刀单掷继电器的例子。当线圈没有电时，开关部分是断开的，所以它被称为*常开*继电器。如果没有电时开关是闭合的，那它就是*常闭*继电器。'
- en: '![Image](../images/02fig21.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig21.jpg)'
- en: '*Figure 2-21: Normally open SPST relay*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-21：常开 SPST 继电器*'
- en: The connections on the bottom go to the coil of wire; the rest looks pretty
    much like a variation on a switch. The contact in the middle moves depending on
    whether or not the coil is energized. We can implement logic functions using relays,
    as shown in [Figure 2-22](ch02.xhtml#ch02fig22).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的连接线连接到电线线圈；其余部分看起来很像是开关的变体。中间的触点会根据线圈是否通电而移动。我们可以使用继电器实现逻辑功能，如[图 2-22](ch02.xhtml#ch02fig22)所示。
- en: '![Image](../images/02fig22.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig22.jpg)'
- en: '*Figure 2-22: Relay circuits for AND and OR functions*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-22：用于 AND 和 OR 功能的继电器电路*'
- en: On the top of [Figure 2-22](ch02.xhtml#ch02fig22), you can see that the two
    output wires are connected together only if *both* relays are activated, which
    is our definition of the AND function. Likewise, on the bottom, the wires are
    connected together if *either* relay is activated, which is the OR function. Notice
    the small black dots in this figure. These indicate connections between wires
    in schematics; wires that cross without a dot aren’t connected.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图2-22](ch02.xhtml#ch02fig22)的顶部，你可以看到，只有*当两个*继电器都被激活时，两根输出线才会连接在一起，这就是我们对“与”功能的定义。同样地，在底部，如果*任意一个*继电器被激活，线才会连接在一起，这就是“或”功能。请注意图中的小黑点。这些点表示电路图中线与线之间的连接；没有小黑点的交叉线是没有连接的。
- en: Relays allow us to do things that are impossible with switches. For example,
    we can build *inverters*, which implement the NOT function, without which our
    Boolean algebra options are very limited. We could use the output from the AND
    circuit on the top to drive one of the inputs on the OR circuit on the bottom.
    It’s this ability to make switches control other switches that lets us build the
    complex logic needed for computers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 继电器让我们能够做一些开关无法完成的事情。例如，我们可以构建*逆变器*，实现“非”功能，没有它，我们的布尔代数选项将非常有限。我们可以使用顶部“与”电路的输出驱动底部“或”电路的输入。正是这种使开关控制其他开关的能力，让我们能够构建计算机所需的复杂逻辑。
- en: People have done amazing things with relays. For example, there is a single-pole,
    10-throw *stepper relay* that has two coils. One coil moves the contact to the
    next position every time it’s energized, and the other resets the relay by moving
    the contact back to the first position. Huge buildings full of stepper relays
    used to count out the digits of telephone numbers as they were dialed to connect
    calls. Telephone exchanges were very noisy places. Stepper relays are also what
    give old pinball machines their charm.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 人们使用继电器做出了令人惊叹的事情。例如，有一种单极10档*步进继电器*，它有两个线圈。一个线圈在每次通电时将触点移到下一个位置，另一个线圈则通过将触点复位到第一个位置来重置继电器。曾经有很多装满步进继电器的大楼，它们在拨打电话时根据拨号的数字来计数，连接电话。电话交换机曾经是非常嘈杂的地方。步进继电器也是老式弹球机所具有的魅力之一。
- en: Another interesting fact about relays is that the transfer function threshold
    is vertical; no matter how slowly you increase the voltage on the coil, the switch
    always snaps from one position to the other. This mystified me as a kid; it was
    only when studying Lagrange-Hamilton equations as a junior in college that I learned
    that the value of the transfer function is undefined at the threshold, which causes
    the snap.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关于继电器的有趣事实是，传输函数的阈值是垂直的；无论你多慢地增加线圈上的电压，开关总是会从一个位置快速切换到另一个位置。这让我小时候感到困惑；直到大学三年级学习拉格朗日-哈密顿方程时，我才明白，传输函数在阈值处的值是未定义的，这就导致了“咔嚓”声的发生。
- en: The big problems with relays are that they’re slow, take a lot of electricity,
    and stop working if dirt (or bugs) get onto the switch contacts. In fact, the
    term *bug* was popularized by American computer scientist Grace Hopper in 1947
    when an error in the Harvard Mark II computer was traced to a moth trapped in
    a relay. Another interesting problem comes from using the switch contacts to control
    other relays. Remember that suddenly turning off the power to a coil generates
    very high voltage for an instant and that air becomes conductive at high voltages.
    This phenomenon often results in sparks across the switch contacts, which makes
    them wear out. Because of these drawbacks, people began looking for something
    that would do the same work as relays but without moving parts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 继电器的主要问题在于它们速度慢、耗电量大，而且如果开关接触点上有脏物（或昆虫），它们就无法工作。事实上，*bug*这一术语是由美国计算机科学家格雷斯·霍普于1947年普及的，当时哈佛Mark
    II计算机的一个故障被追溯到继电器里困住的一只飞蛾。另一个有趣的问题是，当使用开关接触点来控制其他继电器时，记住突然断开线圈的电源会瞬间产生非常高的电压，而且在高电压下空气会变得导电。这个现象常常导致开关接触点之间产生火花，从而使它们磨损。由于这些缺点，人们开始寻找一些没有移动部件的装置，以代替继电器执行相同的工作。
- en: '***Vacuum Tubes***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***真空管***'
- en: British physicist and electrical engineer Sir John Ambrose Fleming (1849–1945)
    invented the vacuum tube. He based it on a principle called *thermionic emission*,
    which says that if you heat something up enough, the electrons want to jump off.
    Vacuum tubes have a *heater* that heats a *cathode*, which acts like a pitcher
    in baseball. In a vacuum, electrons (baseballs) flow from the cathode to the *anode*
    (catcher). Some examples of vacuum tubes are shown in [Figure 2-23](ch02.xhtml#ch02fig23).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 英国物理学家和电气工程师约翰·安布罗斯·弗莱明爵士（1849–1945）发明了真空管。他基于一种叫做*热电子发射*的原理，解释了如果你将某物加热到足够的程度，电子会跳出来。真空管有一个*加热器*，用来加热*阴极*，阴极就像棒球中的投手。在真空中，电子（棒球）从阴极流向*阳极*（捕手）。一些真空管的例子显示在[图2-23](ch02.xhtml#ch02fig23)中。
- en: '![Image](../images/02fig23.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig23.jpg)'
- en: '*Figure 2-23: Vacuum tubes*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-23：真空管*'
- en: Electrons have some properties in common with magnets, including the one where
    opposite charges attract and like charges repel. A vacuum tube can contain an
    additional “batter” element, called a *grid*, that can repel the electrons coming
    from the cathode to prevent them from getting to the anode. A vacuum tube that
    contains three elements (cathode, grid, and anode) is called a *triode*. [Figure
    2-24](ch02.xhtml#ch02fig24) shows the schematic symbol for a triode.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 电子具有与磁铁相似的某些特性，包括相反的电荷相互吸引，类似的电荷相互排斥。真空管可以包含一个额外的“电池”元件，叫做*栅极*，它可以排斥来自阴极的电子，防止它们到达阳极。包含三个元件（阴极、栅极和阳极）的真空管叫做*三极管*。[图2-24](ch02.xhtml#ch02fig24)显示了三极管的示意符号。
- en: '![Image](../images/02fig24.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig24.jpg)'
- en: '*Figure 2-24: Triode schematic*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-24：三极管示意图*'
- en: Here, the heater heats up the cathode, making electrons jump off. They land
    on the anode unless the grid swats them back. You can think of the grid, then,
    as the handle on a switch.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，加热器加热阴极，使得电子跳出来。除非栅极将它们弹回，否则它们会落到阳极上。因此，你可以将栅极看作开关的把手。
- en: The advantage of vacuum tubes is that they have no moving parts and are therefore
    much faster than relays. Disadvantages are that they get very hot and are fragile,
    just like light bulbs. The heaters burn out like the filaments in light bulbs.
    But vacuum tubes were still an improvement over relays and allowed the construction
    of faster and more reliable computers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 真空管的优点是它们没有活动部件，因此比继电器快得多。缺点是它们会变得非常热，而且像灯泡一样脆弱。加热器像灯泡的灯丝一样会烧坏。但真空管仍然比继电器有很大改进，能够构建更快速、更可靠的计算机。
- en: '***Transistors***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***晶体管***'
- en: These days transistors rule. A contraction of *transfer resistor*, a *transistor*
    is similar to a vacuum tube but uses a special type of material, called a *semiconductor,*
    that can change between being a conductor and being an insulator. In fact, this
    property is just what’s needed to make valves for electricity that require no
    heater and have no moving parts. But, of course, transistors aren’t perfect. We
    can make them really, really small, which is good, but skinny conductors have
    more resistance, which generates heat. Getting rid of the heat in a transistor
    is a real problem, because semiconductors melt easily.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现如今，晶体管占主导地位。*晶体管*是“转移电阻”（*transfer resistor*）的缩写，类似于真空管，但使用了一种特殊类型的材料，叫做*半导体*，它能够在导体和绝缘体之间变化。事实上，这一特性正是制造无需加热器且没有活动部件的电流阀所需的。然而，晶体管当然并不完美。我们可以将它们做得非常非常小，这是好事，但细小的导体会有更多的电阻，这会产生热量。如何消除晶体管中的热量是一个真正的问题，因为半导体很容易熔化。
- en: You don’t need to know everything about the guts of transistors. The important
    thing to know is that a transistor is made on a *substrate*, or slab, of some
    semiconducting material, usually silicon. Unlike other technologies such as gears,
    valves, relays, and vacuum tubes, transistors aren’t individually manufactured
    objects. They’re made through a process called *photolithography*, which involves
    projecting a picture of a transistor onto a silicon wafer and developing it. This
    process is suitable for mass production because large numbers of transistors can
    be projected onto a single silicon wafer substrate, developed, and then sliced
    up into individual components.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要了解晶体管内部的所有细节。重要的是要知道，晶体管是由某种半导体材料（通常是硅）制成的，它是在一个*基板*或平板上制造的。与齿轮、阀门、继电器和真空管等其他技术不同，晶体管不是单独制造的物体。它们是通过一种叫做*光刻*的工艺制造的，该工艺将晶体管的图像投射到硅片上并进行显影。这个过程适合大规模生产，因为大量晶体管可以被投射到一块硅片基板上，然后显影，再切割成独立的组件。
- en: There are many different types of transistors, but the two main types are the
    *bipolar junction transistor (BJT)* and the *field effect transistor (FET)*. The
    manufacturing process involves *doping*, which infuses the substrate material
    with nasty chemicals like arsenic to change its characteristics. Doping creates
    regions of *p* and *n* type material. Transistor construction involves making
    *p* and *n* sandwiches. [Figure 2-25](ch02.xhtml#ch02fig25) shows the schematic
    symbols that are used for some transistor types.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同类型的晶体管，但主要有两种类型：*双极型接面晶体管（BJT）*和*场效应晶体管（FET）*。制造过程中涉及到*掺杂*，即通过将砷等有害化学物质注入基材，改变其特性。掺杂过程创造了*p*型和*n*型材料的区域。晶体管的构造包括制作*p*型和*n*型的三明治。[图2-25](ch02.xhtml#ch02fig25)展示了某些晶体管类型的原理图符号。
- en: '![Image](../images/02fig25.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig25.jpg)'
- en: '*Figure 2-25: Transistor schematic symbols*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-25：晶体管原理图符号*'
- en: The terms *NPN*, *PNP*, *N*-channel, and *P*-channel refer to the sandwich construction.
    You can think of the transistor as a valve or switch; the *gate* (or *base*) is
    the handle, and electricity flows from the top to the bottom when the handle is
    raised, similar to how the coil in a relay moves the contacts. But unlike the
    switches and valves we’ve seen so far, electricity can flow only in one direction
    with bipolar transistors.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*NPN*、*PNP*、*N*型通道和*P*型通道这些术语指的是晶体管的三明治结构。你可以将晶体管想象成一个阀门或开关；*栅极*（或*基极*）是手柄，当手柄被抬起时，电流从上到下流动，类似于继电器中的线圈移动接触点。但与我们之前见过的开关和阀门不同，双极型晶体管只能允许电流单向流动。'
- en: You can see that there’s a gap between the gate and the rest of the transistor
    in the symbols for the FETs. This gap symbolizes that FETs work using static electricity;
    it’s like using static cling to move a switch.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从场效应晶体管的符号中可以看到，栅极与晶体管的其他部分之间有一个间隙。这个间隙象征着场效应晶体管通过静电原理工作；它就像用静电吸附来移动开关。
- en: The *metal-oxide semiconductor field effect transistor*, or *MOSFET*, is a variation
    on the FET that’s very commonly used in modern computer chips because of its low
    power consumption. The *N*-channel and *P*-channel variants are often used in
    complementary pairs, which is where the term *CMOS* (complementary metal oxide
    semiconductor) originates.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*金属氧化物半导体场效应晶体管*，或称*MOSFET*，是场效应晶体管（FET）的一种变体，由于其低功耗，广泛应用于现代计算机芯片中。*N*型通道和*P*型通道变体通常成对使用，这就是术语*CMOS*（互补金属氧化物半导体）的来源。'
- en: '***Integrated Circuits***'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***集成电路***'
- en: Transistors enabled smaller, faster, and more reliable logic circuitry that
    took less power. But building even a simple circuit, such as the one that implemented
    the AND function, still took a lot of components.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 晶体管使得更小、更快速、更可靠的逻辑电路得以实现，而且功耗更低。但即使是构建一个简单的电路，比如实现与门功能的电路，仍然需要许多组件。
- en: This changed in 1958, when Jack Kilby (1923–2005), an American electrical engineer,
    and Robert Noyce (1927–1990), an American mathematician, physicist, and cofounder
    of both Fairchild Semiconductor and Intel, invented the *integrated circuit*.
    With integrated circuits, complicated systems could be built for about the same
    cost as building a single transistor. Integrated circuits came to be called *chips*
    because of how they look.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切在1958年发生了变化，当时美国电气工程师杰克·基尔比（1923–2005）和美国数学家、物理学家以及费尔柴尔德半导体和英特尔共同创始人罗伯特·诺伊斯（1927–1990）发明了*集成电路*。有了集成电路，复杂的系统可以以大致相同的成本构建，而不是仅仅构建一个单独的晶体管。由于集成电路的外观，后来它们被称为*芯片*。
- en: As you’ve seen, many of the same types of circuits can be built using relays,
    vacuum tubes, transistors, or integrated circuits. And with each new technology,
    these circuits became smaller, cheaper, and more power-efficient. The next section
    talks about integrated circuits designed for combinatorial logic.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，许多相同类型的电路可以使用继电器、真空管、晶体管或集成电路来构建。随着每项新技术的出现，这些电路变得更小、更便宜、且更节能。下一节将讨论为组合逻辑设计的集成电路。
- en: '**Logic Gates**'
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**逻辑门**'
- en: In the mid-1960s, Jack Kilby’s employer, Texas Instruments, introduced the 5400
    and 7400 families of integrated circuits. These chips contained ready-made circuits
    that performed logic operations. These particular circuits, called *logic gates*,
    or simply *gates*, are hardware implementations of Boolean functions we call combinatorial
    logic. Texas Instruments sold gazillions of these. They’re still available today.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在1960年代中期，Jack Kilby所在的公司德州仪器（Texas Instruments）推出了5400和7400系列集成电路。这些芯片包含了已经做好逻辑运算的电路。这些电路被称为*逻辑门*，简称*门电路*，是我们所说的组合逻辑的布尔函数的硬件实现。德州仪器销售了成千上万的这些芯片，它们今天仍然可以买到。
- en: 'Logic gates were a huge boon for hardware designers: they no longer had to
    design everything from scratch and could build complicated logic circuits with
    the same ease as complicated plumbing. Just like plumbers can find bins of pipe
    tees, elbows, and unions in a hardware store, logic designers could find “bins”
    of AND gates, OR gates, XOR gates, and *inverters* (things that do the NOT operation).
    [Figure 2-26](ch02.xhtml#ch02fig26) shows the symbols for these gates.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑门电路对硬件设计师来说是一个巨大的福音：他们不再需要从零开始设计一切，可以像安装复杂管道一样轻松地构建复杂的逻辑电路。就像水管工可以在五金店找到管件、弯头和接头一样，逻辑设计师可以找到“门电路盒”，其中有与门、或门、异或门和*反相器*（执行非操作的电路）。[图2-26](ch02.xhtml#ch02fig26)展示了这些门电路的符号。
- en: '![Image](../images/02fig26.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig26.jpg)'
- en: '*Figure 2-26: Gate schematics*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-26：门电路原理图*'
- en: As you would expect, the *Y* output of the AND gate is true if both the *A*
    and *B* inputs are true. (You can get the operation of the other gates from the
    truth tables shown back in [Figure 1-1](ch01.xhtml#ch01fig01).)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预料的那样，*Y*输出的与门（AND gate）只有在*A*和*B*两个输入都为真时才为真。（你可以从[图1-1](ch01.xhtml#ch01fig01)中展示的真值表得到其他门电路的操作方式。）
- en: The key part of the symbol for an inverter in [Figure 2-26](ch02.xhtml#ch02fig26)
    is the ○ (circle), not the triangle it’s attached to. A triangle without the circle
    is called a *buffer*, and it just passes its input to the output. The inverter
    symbol is pretty much used only where an inverter isn’t being used in combination
    with anything else.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图2-26](ch02.xhtml#ch02fig26)中，反相器符号的关键部分是○（圆圈），而不是它所连接的三角形。没有圆圈的三角形被称为*缓冲器*（buffer），它仅仅将输入传递到输出。反相器符号几乎只在反相器未与其他元件组合使用的地方使用。
- en: It’s not efficient to build AND and OR gates using the *transistor-transistor
    logic (TTL)* technology of the 5400 and 7400 series parts, because the output
    from a simple gate circuit is naturally inverted, so it takes an inverter to make
    it come out right side up. This would make them more expensive, slower, and more
    power-hungry. So, the basic gates were *NAND* (not and) and *NOR* (not or), which
    use the inverting circle and look like [Figure 2-27](ch02.xhtml#ch02fig27).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用5400和7400系列的*晶体管-晶体管逻辑（TTL）*技术来构建与门和或门并不高效，因为简单门电路的输出天然是反向的，因此需要一个反相器来将输出恢复为正确的方向。这样会使得电路变得更加昂贵、速度变慢且功耗更大。因此，基本的门电路使用了*NAND*（非与）和*NOR*（非或）门，它们使用了反相圆圈，样式如[图2-27](ch02.xhtml#ch02fig27)所示。
- en: '![Image](../images/02fig27.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig27.jpg)'
- en: '*Figure 2-27: NAND and NOR gates*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-27：NAND门和NOR门*'
- en: Fortunately, this extra inversion doesn’t affect our ability to design logic
    circuits because we have De Morgan’s law. [Figure 2-28](ch02.xhtml#ch02fig28)
    applies De Morgan’s law to show that a NAND gate is equivalent to an OR gate with
    inverted inputs.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种额外的反转不会影响我们设计逻辑电路的能力，因为我们有德摩根定律。[图2-28](ch02.xhtml#ch02fig28)应用了德摩根定律，显示NAND门等同于带有反相输入的或门（OR
    gate）。
- en: '![Image](../images/02fig28.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig28.jpg)'
- en: '*Figure 2-28: Redrawing a NAND gate using De Morgan’s law*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-28：使用德摩根定律重绘NAND门*'
- en: All the gates we’ve seen so far have had two inputs, not counting the inverter,
    but in fact gates can have more than two inputs. For example, a three-input AND
    gate would have an output of true if each of the three inputs was true. Now that
    you know how gates work, let’s look at some of the complications that arise when
    using them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的所有门电路都只有两个输入，排除反相器之外，实际上门电路可以有多个输入。例如，一个三输入与门（AND gate）如果每个输入都为真，那么输出为真。现在你已经知道了门电路的工作原理，让我们来看一些使用门电路时可能出现的复杂问题。
- en: '***Improving Noise Immunity with Hysteresis***'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过滞后提高噪声免疫性***'
- en: You saw earlier that we get better noise immunity using digital (discrete) devices
    because of the decision criteria. But there are situations where that’s not enough.
    It’s easy to assume that logic signals transition instantaneously from 0 to 1
    and vice versa. That’s a good assumption most of the time, especially when we’re
    connecting gates to each other. But many real-world signals change more slowly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前看到过，使用数字（离散）设备时，由于决策标准，我们能获得更好的抗噪声能力。但也有一些情况，单凭这个标准是不够的。我们很容易假设逻辑信号从 0 到
    1 或从 1 到 0 会瞬间变化。大多数情况下，这是一个不错的假设，特别是当我们将门电路相互连接时。但许多实际世界中的信号变化得更慢。
- en: Let’s see what happens when we have a slowly changing signal. [Figure 2-29](ch02.xhtml#ch02fig29)
    shows two signals that ramp slowly from 0 to 1.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当信号缓慢变化时会发生什么。[图 2-29](ch02.xhtml#ch02fig29)显示了两个信号，它们从 0 慢慢上升到 1。
- en: '![Image](../images/02fig29.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig29.jpg)'
- en: '*Figure 2-29: Noise glitch*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-29：噪声毛刺*'
- en: The input on the left is quiet and has no noise, but there’s some noise on the
    signal on the right. You can see that the noisy signal causes a *glitch* in the
    output because the noise makes the signal cross the threshold more than once.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的输入安静且没有噪声，但右边的信号有一些噪声。你可以看到，噪声信号导致输出出现*毛刺*，因为噪声使得信号多次越过阈值。
- en: We can get around this using *hysteresis*, in which the decision criterion is
    affected by history. As you can see in [Figure 2-30](ch02.xhtml#ch02fig30), the
    transfer function is not symmetrical; in effect, there are different transfer
    functions for rising signals (those going from 0 to 1) and falling signals (those
    going from 1 to 0) as indicated by the arrows. When the output is 0, the curve
    on the right is applied, and vice versa.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用*滞回*来解决这个问题，在这种情况下，决策标准受到历史的影响。正如你在[图 2-30](ch02.xhtml#ch02fig30)中看到的，传递函数是不对称的；实际上，上升信号（从
    0 到 1 的信号）和下降信号（从 1 到 0 的信号）有不同的传递函数，正如箭头所示。当输出为 0 时，应用右侧的曲线，反之亦然。
- en: '![Image](../images/02fig30.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig30.jpg)'
- en: '*Figure 2-30: Hysteresis transfer function*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-30：滞回传递函数*'
- en: 'This gives us two different thresholds: one for rising signals and one for
    falling signals. This means that when a signal crosses one of the thresholds,
    it has a lot farther to go before crossing the other, and that translates into
    higher noise immunity.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了两个不同的阈值：一个用于上升信号，一个用于下降信号。这意味着，当一个信号跨越其中一个阈值时，它在跨越另一个阈值之前需要经过更长的距离，这就转化为更强的抗噪声能力。
- en: Gates that include hysteresis are available. They’re called *Schmitt triggers*
    after the American scientist Otto H. Schmitt (1913–1998), who invented the circuit.
    Because they’re more complicated and expensive than normal gates, they’re used
    only where they’re really needed. Their schematic symbol depicts the addition
    of hysteresis, as shown for the inverter in [Figure 2-31](ch02.xhtml#ch02fig31).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 包含滞回的门电路是有的。它们被称为*施密特触发器*，以美国科学家奥托·H·施密特（1913–1998）的名字命名，他发明了这种电路。由于它们比普通门电路更复杂且昂贵，因此只在真正需要的地方使用。它们的原理图符号表示了滞回的加入，正如[图
    2-31](ch02.xhtml#ch02fig31)中反相器的所示。
- en: '![Image](../images/02fig31.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig31.jpg)'
- en: '*Figure 2-31: Schmitt trigger gate schematic symbol*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-31：施密特触发器门电路原理图符号*'
- en: '***Differential Signaling***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***差分信号传输***'
- en: Sometimes there’s so much noise that even hysteresis isn’t enough. Think about
    walking down a sidewalk. Let’s call the right edge of the sidewalk the *positive-going
    threshold* and the left edge the *negative-going threshold*. You might be minding
    your own business when someone pushing a double-wide stroller knocks you off the
    right-hand edge of the sidewalk and then a pack of joggers forces you back off
    the left side. We need protection in this case, too.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有时噪声非常强大，即使是滞回也不足以应对。想象一下你在走人行道。假设人行道的右边缘是*正向阈值*，左边缘是*负向阈值*。你可能正在专心走路，这时一个推着双人推车的人把你撞到人行道的右边缘，然后一群慢跑者又把你推回到左边。我们在这种情况下也需要保护。
- en: So far, we’ve measured our signal against an absolute threshold, or pair of
    thresholds in the case of a Schmitt trigger. But there are situations in which
    there is so much noise that both Schmitt trigger thresholds are crossed, making
    them ineffective.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们是根据绝对阈值，或在施密特触发器情况下的两个阈值来测量信号。但也有一些情况，噪声非常强大，以至于两个施密特触发器阈值都会被跨越，从而使它们失效。
- en: Let’s try the buddy system instead. Now imagine you’re walking down that sidewalk
    with a friend. If your friend is on your left, we’ll call it a 0; if your friend
    is on your right, we’ll call it a 1\. Now when that stroller and those joggers
    come by, both you and your friend get pushed off to the side. But you haven’t
    changed positions, so if that’s what we’re measuring, then the noise had no effect.
    Of course, if the two of you are just wandering around near each other, one of
    you could get pushed around without the other. That’s why holding hands is better,
    or having your arms around each other’s waists. Yes, snuggling yields greater
    noise immunity! This is called *differential signaling*, because what we’re measuring
    is the *difference* between a pair of *complementary* signals. [Figure 2-32](ch02.xhtml#ch02fig32)
    shows a differential signaling circuit.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试伙伴系统。现在想象你正和一个朋友一起走在人行道上。如果你的朋友在你左边，我们叫它0；如果你的朋友在你右边，我们叫它1。当婴儿车和那些慢跑者经过时，你和你的朋友都会被推到一旁。但你们并没有改变位置，所以如果我们测量的是这个，那么噪音没有影响。当然，如果你们只是彼此靠近随便走动，其中一个人可能会被推走，而另一个人没有。这就是为什么牵手更好，或者把手臂绕在对方腰间。是的，拥抱能带来更强的噪声免疫力！这叫做*差分信号*，因为我们测量的是一对*互补*信号之间的*差异*。[图2-32](ch02.xhtml#ch02fig32)展示了一个差分信号电路。
- en: '![Image](../images/02fig32.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig32.jpg)'
- en: '*Figure 2-32: Differential signaling*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-32：差分信号*'
- en: You can see that there’s a *driver* that converts the input signal into *complementary
    outputs*, and a *receiver* that converts complementary inputs back into a *single-ended*
    output. It’s common for the receiver to include a Schmitt trigger for additional
    noise immunity.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到有一个*驱动器*将输入信号转换为*互补输出*，而一个*接收器*将互补输入转换回*单端*输出。接收器通常包括一个施密特触发器，以提供额外的噪声免疫力。
- en: Of course, there are limitations. Too much noise can push electronic components
    out of their specified operating range—imagine there’s a building next to the
    sidewalk and you and your friend both get pushed into the wall. A *common-mode
    rejection ratio (CMRR)* is part of a component specification and indicates the
    amount of noise that can be handled. It’s called “common-mode” because it refers
    specifically to noise that is common to both signals in a pair.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也有局限性。过多的噪声可能会将电子组件推到其指定的工作范围之外——想象一下，旁边有一座建筑，你和你的朋友都被推到了墙上。*共模抑制比（CMRR）*是组件规格的一部分，表示能够处理的噪声量。之所以叫“共模”，是因为它特指对一对信号中都共有的噪声。
- en: Differential signaling is used in many places, such as telephone lines. This
    application became necessary in the 1880s when electric streetcars made their
    debut, because they generated a lot of electrical noise that interfered with telephone
    signals. Scottish inventor Alexander Graham Bell (1847–1922) invented *twisted-pair*
    cabling, in which pairs of wires were twisted together for the electrical equivalent
    of snuggling (see [Figure 2-33](ch02.xhtml#ch02fig33)). He also patented the telephone.
    Today, twisted pair is ubiquitous; you’ll find it in USB, SATA (disk drive), and
    Ethernet cables.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 差分信号在许多地方都有应用，比如电话线路。这一应用在1880年代变得尤为必要，当时电动有轨电车首次亮相，因为它们产生了大量的电噪声，干扰了电话信号。苏格兰发明家亚历山大·格雷厄姆·贝尔（1847–1922）发明了*双绞线*电缆，将一对导线扭在一起，提供了电气上类似于拥抱的效果（见[图2-33](ch02.xhtml#ch02fig33)）。他还获得了电话的专利。今天，双绞线无处不在；你会在USB、SATA（磁盘驱动器）和以太网电缆中看到它。
- en: '![Image](../images/02fig33.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig33.jpg)'
- en: '*Figure 2-33: Twisted-pair Ethernet cable*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-33：双绞线以太网电缆*'
- en: An interesting application of differential signaling can be found in the Wall
    of Sound concert audio system used by the American band The Grateful Dead (1965–1995).
    It addressed the problem of vocal microphone feedback by using microphones in
    pairs wired so that the output from one microphone was subtracted from the output
    of the other. That way, any sound hitting both mics was common-mode and canceled
    out. Vocalists would sing into one of the mics in the pair so their voice would
    come through. An artifact of this system, which can be heard in the band’s live
    recordings, is that audience noise sounds tinny. That’s because lower-frequency
    sounds have longer wavelengths than higher-frequency sounds; lower-frequency noise
    is more likely to be common-mode than higher-frequency noise.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 差分信号的一种有趣应用可以在美国乐队“感恩的死”（The Grateful Dead，1965–1995）使用的“声音墙”演唱会音响系统中找到。它通过使用一对麦克风，将一个麦克风的输出信号从另一个麦克风的输出信号中减去，从而解决了人声麦克风反馈问题。这样，任何同时打到两个麦克风的声音就变成了共模信号并被取消掉。歌手会对着其中一个麦克风唱歌，这样他们的声音就能通过该麦克风传输。该系统的一个副作用，在乐队的现场录音中可以听到，就是观众噪音听起来会显得刺耳。原因是低频声音的波长比高频声音更长，低频噪音更容易成为共模噪音。
- en: '***Propagation Delay***'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***传播延迟***'
- en: I touched on propagation delay back in “[Using Plumbing to Understand Electricity](ch02.xhtml#ch02lev2sec6)”
    on [page 41](ch02.xhtml#page_41). *Propagation delay* is the amount of time it
    takes for a change in input to be reflected in the output. It is a statistical
    measure due to variances in manufacturing processes and temperature, plus the
    number and type of components connected to the output of a gate. Gates have both
    a minimum and maximum delay; the actual delay is somewhere in between. Propagation
    delay is one of the factors that limits the maximum speed that can be achieved
    in logic circuits. Designers have to use the *worst-case* values if they want
    their circuits to work. That means they have to design assuming the shortest and
    longest possible delays.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我在《[用管道来理解电流](ch02.xhtml#ch02lev2sec6)》一文中曾提到过传播延迟，见[第41页](ch02.xhtml#page_41)。*传播延迟*是输入变化反映到输出所需的时间。由于制造工艺和温度的差异，加上连接到门输出的元件数量和类型，传播延迟是一个统计量度。门有最小和最大延迟；实际延迟在这两者之间。传播延迟是限制逻辑电路能达到的最大速度的因素之一。设计师必须使用*最坏情况*的值来确保电路的正常工作。这意味着他们必须假设最短和最长的延迟时间。
- en: In [Figure 2-34](ch02.xhtml#ch02fig34), gray areas indicate where we can’t rely
    on the outputs because of propagation delay.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图2-34](ch02.xhtml#ch02fig34)中，灰色区域表示我们不能依赖输出的地方，因为传播延迟的存在。
- en: '![Image](../images/02fig34.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig34.jpg)'
- en: '*Figure 2-34: Propagation delay example*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-34：传播延迟示例*'
- en: The outputs could change as early as the left edge of the gray regions, but
    they’re not guaranteed to change until the right edge. And the length of the gray
    areas increases as more gates are strung together.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能在灰色区域的左边缘就发生变化，但直到右边缘才有可能确保输出变化。而且随着更多的门被串联在一起，灰色区域的长度会增加。
- en: There is a huge range of propagation delay times that depends on process technology.
    Individual components, such as 7400 series parts, can have delays in the 10-nanosecond
    range (that is, 10 billionths of a second). The gate delays inside modern large
    components, such as microprocessors, can be in picoseconds (trillionths of a second).
    If you’re reading the specifications for a component, the propagation delays are
    usually specified as t[PLH] and t[PHL] for the propagation time from low to high
    and high to low, respectively.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 传播延迟时间的范围非常广泛，取决于工艺技术。个别元件，例如7400系列部件，延迟可以在10纳秒范围内（即十亿分之一秒）。现代大型元件内部的门延迟，例如微处理器，可能在皮秒（万亿分之一秒）级别。如果你正在阅读一个元件的规格说明，传播延迟通常会指定为t[PLH]和t[PHL]，分别表示从低电平到高电平和从高电平到低电平的传播时间。
- en: Now that we’ve discussed the inputs and what happens on the way to the outputs,
    it’s time to look at the outputs.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了输入和到达输出的过程，是时候看看输出了。
- en: '***Output Variations***'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***输出变化***'
- en: We’ve talked some about gate inputs, but we haven’t said much about outputs.
    There are a few different types of outputs designed for different applications.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了一些关于门输入的内容，但我们还没有详细说输出部分。有几种不同类型的输出设计用于不同的应用。
- en: '**Totem-Pole Output**'
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**托特姆极性输出**'
- en: A normal gate output is called a *totem pole* because the way in which one transistor
    is stacked on top of another resembles a totem pole. We can model this type of
    output using switches, as shown in [Figure 2-35](ch02.xhtml#ch02fig35).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的门输出被称为*托特姆极*，因为一种晶体管堆叠在另一种晶体管之上，类似于托特姆极的结构。我们可以使用开关模型来表示这种类型的输出，如[图 2-35](ch02.xhtml#ch02fig35)所示。
- en: '![Image](../images/02fig35.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig35.jpg)'
- en: '*Figure 2-35: Totem-pole output*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-35：托特姆极输出*'
- en: The schematic on the left illustrates how totem-pole outputs get their name.
    The top switch in the figure is called an *active pull-up* because it connects
    the output to the high logic level to get a 1 on the output. Totem-pole outputs
    can’t be connected together. As you can see in [Figure 2-35](ch02.xhtml#ch02fig35),
    if you connected one with a 0 output to one with a 1 output, you would have connected
    the positive and negative power supplies together—which would be as bad as crossing
    the streams from the 1984 movie *Ghostbusters* and could melt the components.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的原理图说明了什么是“托特姆极”输出。图中的上方开关被称为*主动拉升*，因为它将输出连接到高逻辑电平，从而在输出端得到1。托特姆极输出不能相互连接。正如在[图
    2-35](ch02.xhtml#ch02fig35)中所示，如果你将一个0输出连接到一个1输出，那么你就将正负电源连接在了一起——这就像是1984年电影*捉鬼敢死队*中的电流交叉场景一样，可能会烧毁组件。
- en: '**Open-Collector Output**'
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**开集电极输出**'
- en: Another type of output is called *open-collector* or *open-drain*, depending
    on the type of transistor used. The schematic and switch model for this output
    are shown in [Figure 2-36](ch02.xhtml#ch02fig36).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的输出称为*开集电极*或*开漏*，具体取决于所使用的晶体管类型。该输出的原理图和开关模型如[图 2-36](ch02.xhtml#ch02fig36)所示。
- en: '![Image](../images/02fig36.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig36.jpg)'
- en: '*Figure 2-36: Open-collector/open-drain output*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-36：开集电极/开漏输出*'
- en: This seems odd at first glance. It’s fine if we want a 0 output, but when it’s
    not, 0 the output just *floats*, so we don’t know what its value is.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎有些奇怪。如果我们需要0输出，没问题，但当输出不为0时，输出会*浮空*，因此我们不知道它的值。
- en: Because the open-collector and open-drain versions don’t have active pull-ups,
    we can connect their outputs together without harm. We can use a *passive pull-up*,
    which is just a *pull-up resistor* connecting the output to the supply voltage,
    which is the source of 1s. This is called V[CC] for bipolar transistors and V[DD]
    for MOS (metal-oxide-semiconductor) transistors. A passive pull-up has the effect
    of creating a *wired-AND*, shown in [Figure 2-37](ch02.xhtml#ch02fig37).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于开集电极和开漏版本没有主动拉升，我们可以将它们的输出连接在一起而不会造成损害。我们可以使用*被动拉升*，这只是一个*拉升电阻*，它将输出连接到电源电压，这是1的源。这种电压在双极晶体管中称为V[CC]，在金属氧化物半导体（MOS）晶体管中称为V[DD]。被动拉升的效果就是创建一个*线性与*，如[图
    2-37](ch02.xhtml#ch02fig37)所示。
- en: '![Image](../images/02fig37.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig37.jpg)'
- en: '*Figure 2-37: Wired-AND*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-37：线性与*'
- en: What’s happening here is that when neither open-collector output is low, the
    resistor pulls the signal up to a 1\. The resistor limits the current so that
    things don’t catch fire. The output is 0 when any of the open-collector outputs
    is low. You can wire a large number of things together this way, eliminating the
    need for an AND gate with lots of inputs.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，当没有任何开集电极输出为低时，电阻将信号拉升至1。电阻限制了电流，以防电路过热。只要有任何一个开集电极输出为低，输出就是0。通过这种方式，你可以将多个设备连接在一起，消除了需要多个输入的与门。
- en: Another use of open-collector and open-drain outputs is to drive devices like
    LEDs (light-emitting diodes). Open-collector and open-drain devices are often
    designed to support this use and can handle higher current than totem-pole devices.
    Some versions allow the output to be pulled up to a voltage level that is higher
    than the logic 1 level, which allows us to interface to other types of circuitry.
    This is important because although the threshold is consistent within a family
    of gates such as the 7400 series, other families have different thresholds.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 开集电极和开漏输出的另一个用途是驱动像LED（发光二极管）这样的设备。开集电极和开漏设备通常设计为支持这种用途，并且能够处理比托特姆极设备更高的电流。一些版本允许输出拉升到比逻辑1更高的电压水平，从而使我们能够与其他类型的电路接口。这一点非常重要，因为尽管在7400系列等门电路的同一系列内，阈值是一致的，但其他系列的阈值可能不同。
- en: '**Tri-State Output**'
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**三态输出**'
- en: Although open-collector circuits allow outputs to be connected together, they’re
    just not as fast as active pull-ups. So let’s move away from the two-state solution
    and introduce *tri-state* outputs. The third state is off. There is an extra *enable*
    input that turns the output on and off, as shown in [Figure 2-38](ch02.xhtml#ch02fig38).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然开路集电极电路允许输出连接在一起，但它们的速度不如主动上拉电路。因此，让我们摆脱两态解决方案，引入*三态*输出。第三种状态是关闭。还有一个额外的*使能*输入，用于打开和关闭输出，如[图
    2-38](ch02.xhtml#ch02fig38)所示。
- en: '![Image](../images/02fig38.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig38.jpg)'
- en: '*Figure 2-38: Tri-state output*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-38：三态输出*'
- en: 'Off is known as the *hi-Z*, or high-impedance, state. *Z* is the symbol for
    *impedance*, the mathematically complex version of resistance. You can imagine
    a tri-state output as the circuit from [Figure 2-35](ch02.xhtml#ch02fig35). Controlling
    the bases separately gives us four combinations: 0, 1, hi-Z, and meltdown. Obviously,
    circuit designers must make sure that the meltdown combination cannot be selected.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭状态被称为*高阻抗（hi-Z）*状态，*Z* 是*阻抗*的符号，它是电阻的数学复杂版本。你可以将三态输出想象成[图 2-35](ch02.xhtml#ch02fig35)中的电路。分别控制基极可以得到四种组合：0，1，高阻抗（hi-Z）和熔断。显然，电路设计师必须确保熔断组合不能被选择。
- en: Tri-state outputs allow a large number of devices to be hooked together. The
    caveat is that only one device can be enabled at a time.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 三态输出允许将大量设备连接在一起。需要注意的是，每次只能启用一个设备。
- en: '**Building More Complicated Circuits**'
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建更复杂的电路**'
- en: The introduction of gates greatly simplified the hardware design process. People
    no longer had to design everything from discrete components. For example, where
    it took around 10 components to build a two-input NAND gate, the 7400 included
    four of them in a single package, called a *small-scale integration (SSI)* part,
    so that one package could replace 40.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 门电路的引入极大简化了硬件设计过程。人们不再需要从离散元件开始设计一切。例如，构建一个两输入的 NAND 门需要约 10 个元件，而 7400 芯片则将四个这样的门集成在一个封装中，称为*小规模集成（SSI）*部件，从而使一个封装可以替代
    40 个部件。
- en: Hardware designers could build anything from SSI gates just as they could using
    discrete components, which made things cheaper and more compact. And because certain
    combinations of gates are used a lot, *medium-scale integration (MSI)* parts were
    introduced that contained these combinations, further reducing the number of parts
    needed. Later came *large-scale integration (LSI)*, *very large-scale integration
    (VLSI)*, and so on.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件设计师可以像使用离散元件一样，通过 SSI 门电路构建任何东西，这使得设计更加便宜和紧凑。由于某些门电路组合被频繁使用，引入了*中规模集成（MSI）*部件，这些部件包含了这些组合，进一步减少了所需的元件数量。后来出现了*大规模集成（LSI）*、*超大规模集成（VLSI）*等。
- en: You’ll learn about some of the gate combinations in the following sections,
    but this isn’t the end of the line. We use these higher-level functional building
    blocks themselves to make even higher-level components, similar to the way in
    which complex computer programs are constructed from smaller programs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将学习一些门电路组合，但这不是终点。我们使用这些更高级的功能性构件来构建更高阶的组件，就像复杂的计算机程序是由更小的程序构建而成一样。
- en: '***Building an Adder***'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构建加法器***'
- en: Let’s build a two’s-complement adder. You may never need to design one of these,
    but this example will demonstrate how clever manipulation of logic can improve
    performance—which is true for both hardware and software.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个二的补码加法器。你可能永远不需要设计这样的加法器，但这个例子将演示如何通过巧妙地操作逻辑来提高性能——这对硬件和软件都适用。
- en: We saw back in [Chapter 1](ch01.xhtml#ch01) that the sum of 2 bits is the XOR
    of those bits and the carry is the AND of those bits. [Figure 2-39](ch02.xhtml#ch02fig39)
    shows the gate implementation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 1 章](ch01.xhtml#ch01)中看到，两个比特的和是这两个比特的异或（XOR），而进位是这两个比特的与（AND）。[图 2-39](ch02.xhtml#ch02fig39)展示了门电路的实现。
- en: '![Image](../images/02fig39.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig39.jpg)'
- en: '*Figure 2-39: Half adder*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-39：半加器*'
- en: You can see that the XOR gate provides the sum and the AND gate provides the
    carry. [Figure 2-39](ch02.xhtml#ch02fig39) is called a *half adder* because something
    is missing. It’s fine for adding two bits, but there needs to be a third input
    so that we can carry. This means that two adders are needed to get the sum for
    each bit. We carry when at least two of the inputs are 1\. [Table 2-1](ch02.xhtml#ch02tab01)
    shows the truth table for this *full adder*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，XOR 门提供了和，而 AND 门提供了进位。[图 2-39](ch02.xhtml#ch02fig39)被称为*半加器*，因为它缺少了一些东西。它适用于两个二进制位相加，但需要第三个输入来实现进位。这意味着每一位的和需要两个加法器。当至少有两个输入为
    1 时，我们就会发生进位。[表 2-1](ch02.xhtml#ch02tab01)显示了这个*全加器*的真值表。
- en: '**Table 2-1:** Truth Table for Full Adder'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 全加器的真值表'
- en: '| **A** | **B** | **C** | **Sum** | **Carry** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **C** | **和** | **进位** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | 0 | 0 | 0 | 0 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 0 |'
- en: '| 0 | 0 | 1 | 1 | 0 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 1 | 0 |'
- en: '| 0 | 1 | 0 | 1 | 0 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1 | 0 |'
- en: '| 0 | 1 | 1 | 0 | 1 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0 | 1 |'
- en: '| 1 | 0 | 0 | 1 | 0 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 1 | 0 |'
- en: '| 1 | 0 | 1 | 0 | 1 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 | 1 |'
- en: '| 1 | 1 | 0 | 0 | 1 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 0 | 1 |'
- en: '| 1 | 1 | 1 | 1 | 1 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 |'
- en: A full adder is a bit more complicated to build and looks like [Figure 2-40](ch02.xhtml#ch02fig40).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 全加器的构建稍微复杂一些，形状如[图 2-40](ch02.xhtml#ch02fig40)所示。
- en: '![Image](../images/02fig40.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig40.jpg)'
- en: '*Figure 2-40: Full adder*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-40：全加器*'
- en: As you can see, this takes many more gates. But now that we have the full adder,
    we can use it to build an adder for more than one bit. [Figure 2-41](ch02.xhtml#ch02fig41)
    shows a configuration called a *ripple-carry adder*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这需要更多的门。但现在我们有了全加器，我们可以用它来构建多位加法器。[图 2-41](ch02.xhtml#ch02fig41)展示了一种称为*波纹进位加法器*的配置。
- en: '![Image](../images/02fig41.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig41.jpg)'
- en: '*Figure 2-41: Ripple-carry adder*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-41：波纹进位加法器*'
- en: This *ripple-carry adder* gets its name from the way that the carry ripples
    from one bit to the next. It’s like doing the wave. This works fine, but you can
    see that there are two gate delays per bit, which adds up fast if we’re building
    a 32- or 64-bit adder. We can eliminate these delays with a *carry look-ahead
    adder*, which we can figure out how to make work using some basic arithmetic.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*波纹进位加法器*得名于进位从一个位传递到下一个位的方式，就像做波浪动作一样。这种方式工作良好，但可以看到每一位都有两个门延迟，如果我们要构建一个
    32 位或 64 位加法器，延迟会迅速累积。我们可以使用*进位预先加法器*来消除这些延迟，利用一些基本的算术方法就能弄明白如何工作。
- en: 'We can see in [Figure 2-40](ch02.xhtml#ch02fig40) that the full-adder carry-out
    for bit *i* that is fed into the carry-in for bit *i* + 1:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在[图 2-40](ch02.xhtml#ch02fig40)中看到，位*i*的全加器进位输出被送入位*i* + 1的进位输入：
- en: '*C*[*i*+1] = (*A[i]* AND *B[i]*) OR (*A[i]* AND *C[i]*) OR (*B[i]* AND *C[i]*)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*C*[*i*+1] = (*A[i]* AND *B[i]*) OR (*A[i]* AND *C[i]*) OR (*B[i]* AND *C[i]*)'
- en: 'The big sticking point here is that we need *C[i]* in order to get *C[i]*[+1],
    which causes the ripple. You can see this in the following equation for *C[i]*[+2]:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键问题是我们需要*C[i]*才能得到*C[i]*[+1]，这导致了波纹现象。你可以在下面的*C[i]*[+2]方程中看到这一点：
- en: '*C*[*i*+2] = (*A*[*i*+1] AND *B*[*i*+1]) OR (*A*[*i*+1] AND *C*[*i*+1]) OR
    (*B*[*i*+1] AND *C*[*i*+1])'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*C*[*i*+2] = (*A*[*i*+1] AND *B*[*i*+1]) OR (*A*[*i*+1] AND *C*[*i*+1]) OR
    (*B*[*i*+1] AND *C*[*i*+1])'
- en: 'We can eliminate this dependency by substituting the first equation into the
    second, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将第一个方程代入第二个方程来消除这种依赖关系，具体如下：
- en: '*C*[*i*+2] = (*A*[*i*+1] AND *B*[*i*+1])'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*C*[*i*+2] = (*A*[*i*+1] AND *B*[*i*+1])'
- en: OR(*A*[*i*+1] AND ((*A[i]* AND *B[i]*) OR (*A[i]* AND *C[i]*) OR (*B[i]* AND
    *C[i]*)))
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: OR(*A*[*i*+1] AND ((*A[i]* AND *B[i]*) OR (*A[i]* AND *C[i]*) OR (*B[i]* AND
    *C[i]*)))
- en: OR(*B*[*i*+1] AND ((*A[i]* AND *B[i]*) OR (*A[i]* AND *C[i]*) OR (*B[i]* AND
    *C[i]*)))
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: OR(*B*[*i*+1] AND ((*A[i]* AND *B[i]*) OR (*A[i]* AND *C[i]*) OR (*B[i]* AND
    *C[i]*)))
- en: Note that although there are a lot more ANDs and ORs, there’s still only two
    gates’ worth of propagation delay. *C[n]* is dependent only on the *A* and *B*
    inputs, so the carry time, and hence the addition time, doesn’t depend on the
    number of bits. *C[n]* can always be generated from *C[n]*[–1], which uses an
    increasingly large number of gates as *n* increases. Although gates are cheap,
    they do consume power, so there is a trade-off between speed and power consumption.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管有更多的 AND 和 OR 操作，但传播延迟仍然只有两个门的延迟。*C[n]*仅依赖于*A*和*B*输入，因此进位时间，从而加法时间，并不依赖于位数。*C[n]*总是可以从*C[n]*[–1]生成，随着*n*的增加，所需的门数量也越来越多。尽管门便宜，但它们会消耗电力，因此在速度和功耗之间存在权衡。
- en: '***Building Decoders***'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构建解码器***'
- en: In “[Representing Integers Using Bits](ch01.xhtml#ch01lev1sec5)” on [page 6](ch01.xhtml#page_6),
    we built or *encoded* numbers from bits. A *decoder* does the opposite by turning
    an encoded number back into a set of individual bits. One application of decoders
    is to drive displays. You may have seen *nixie tubes* (shown in [Figure 2-42](ch02.xhtml#ch02fig42))
    in old science fiction movies; they’re a really cool retro display for numbers.
    They’re essentially a set of neon signs, one for each digit. Each glowing wire
    has its own connection, requiring us to turn a 4-bit number into 10 separate outputs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在“[使用比特表示整数](ch01.xhtml#ch01lev1sec5)”的[第6页](ch01.xhtml#page_6)中，我们从比特中构建或*编码*数字。译码器则执行相反的操作，将编码的数字转换回一组单独的比特。译码器的一种应用是驱动显示器。你可能在老式科幻电影中看到过*霓虹管*（如[图2-42](ch02.xhtml#ch02fig42)所示）；它们是一种非常酷的复古数字显示方式。它们本质上是一组霓虹灯标志，每个数字都有一个独立的显示器。每根发光的电线都有自己的连接，这要求我们将一个4位的数字转换成10个独立的输出。
- en: '![Image](../images/02fig42.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig42.jpg)'
- en: '*Figure 2-42: A nixie tube*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-42：一个真空管数字显示器*'
- en: Recall that octal representation takes eight distinct values and encodes them
    into 3 bits. [Figure 2-43](ch02.xhtml#ch02fig43) shows a 3:8 decoder that converts
    an octal value back into a set of single bits.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请回想一下，八进制表示法包含八个不同的值，并将它们编码为3位。[图2-43](ch02.xhtml#ch02fig43)展示了一个3:8译码器，将八进制值转换回一组单独的比特。
- en: '![Image](../images/02fig43.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig43.jpg)'
- en: '*Figure 2-43: A 3:8 decoder*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-43：一个3:8译码器*'
- en: When the input is 000, the *Y*[0] input is true; when the input is 001, *Y*[1]
    is true; and so on. Decoders are principally named by the number of inputs and
    outputs. The example in [Figure 2-43](ch02.xhtml#ch02fig43) has three inputs and
    eight outputs, so it’s a 3:8 decoder. This decoder would commonly be drawn as
    shown in [Figure 2-44](ch02.xhtml#ch02fig44).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入为000时，*Y*[0]输入为真；当输入为001时，*Y*[1]为真；依此类推。译码器的名称通常由输入和输出的数量命名。[图2-43](ch02.xhtml#ch02fig43)中的例子有三个输入和八个输出，因此它是一个3:8译码器。这个译码器通常会像[图2-44](ch02.xhtml#ch02fig44)中那样绘制。
- en: '![Image](../images/02fig44.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig44.jpg)'
- en: '*Figure 2-44: The 3:8 decoder schematic symbol*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-44：3:8译码器电路符号*'
- en: '***Building Demultiplexers***'
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构建解复用器***'
- en: You can use a decoder to build a *demultiplexer*, commonly abbreviated as *dmux*,
    which allows an input to be directed to one of several outputs, as you would do
    if sorting Hogwarts students into houses. A demultiplexer combines a decoder with
    some additional gates, as shown in [Figure 2-45](ch02.xhtml#ch02fig45).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用译码器构建一个*解复用器*，通常缩写为*dmux*，它允许将输入信号引导到多个输出之一，就像你在分配霍格沃茨学生到各个学院时所做的那样。解复用器将译码器与一些附加的门电路结合起来，如[图2-45](ch02.xhtml#ch02fig45)所示。
- en: '![Image](../images/02fig45.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig45.jpg)'
- en: '*Figure 2-45: A 1:4 demultiplexer*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-45：一个1:4解复用器*'
- en: The demultiplexer directs the input signal *D* to one of the four outputs *Y*[0–3]
    based on the decoder inputs *S*[0–1]. The symbol in [Figure 2-46](ch02.xhtml#ch02fig46)
    is used in schematics for demultiplexers.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 解复用器根据译码器输入*S*[0–1]将输入信号*D*定向到四个输出之一*Y*[0–3]。[图2-46](ch02.xhtml#ch02fig46)中的符号用于解复用器的电路图。
- en: '![Image](../images/02fig46.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig46.jpg)'
- en: '*Figure 2-46: The demultiplexer schematic symbol*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-46：解复用器电路符号*'
- en: '***Building Selectors***'
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构建选择器***'
- en: Choosing one input from a number of inputs is another commonly performed function.
    For example, we might have several operand sources for an adder and need to choose
    one. Using gates, we can create another functional block called a *selector* or
    *multiplexer (mux)*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从多个输入中选择一个输入是另一个常见的操作。例如，我们可能有多个加法器的操作数源，并需要选择其中一个。通过使用门电路，我们可以创建另一个功能模块，称为*选择器*或*多路复用器（mux）*。
- en: A selector combines a decoder with some additional gates, as shown in [Figure
    2-47](ch02.xhtml#ch02fig47).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择器将译码器与一些附加的门电路结合起来，如[图2-47](ch02.xhtml#ch02fig47)所示。
- en: '![Image](../images/02fig47.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig47.jpg)'
- en: '*Figure 2-47: A 4:1 selector*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-47：一个4:1选择器*'
- en: Selectors are also used a lot and have their own schematic symbol. [Figure 2-48](ch02.xhtml#ch02fig48)
    shows the symbol for a 4:1 selector, which is pretty much the reverse of the symbol
    for a decoder.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器也使用得很频繁，并且有自己的电路符号。[图2-48](ch02.xhtml#ch02fig48)展示了一个4:1选择器的符号，这几乎是译码器符号的反转。
- en: '![Image](../images/02fig48.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig48.jpg)'
- en: '*Figure 2-48: The 4:1 selector schematic symbol*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-48：4:1选择器电路符号*'
- en: You’re probably familiar with selectors but don’t know it. You might have a
    toaster oven that has a dial with positions labeled Off, Toast, Bake, and Broil.
    That’s a *selector switch* with four positions. A toaster oven has two heating
    elements, one on top and another on the bottom. Toaster oven logic works as shown
    in [Table 2-2](ch02.xhtml#ch02tab02).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对选择器很熟悉，但可能没有意识到。你可能有一台烤面包炉，它的旋钮上标有“关”、“烤面包”、“烘烤”和“烤焙”位置。这就是一个具有四个位置的*选择开关*。烤面包炉有两个加热元件，一个在顶部，一个在底部。烤面包炉的逻辑如[表2-2](ch02.xhtml#ch02tab02)所示。
- en: '**Table 2-2:** Toaster Oven Logic'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-2：** 烤面包炉逻辑'
- en: '| **Setting** | **Top element** | **Bottom element** |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| **设置** | **顶部元件** | **底部元件** |'
- en: '| --- | --- | --- |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Off | Off | Off |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 关 | 关 | 关 |'
- en: '| Bake | Off | On |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 烘烤 | 关 | 开 |'
- en: '| Toast | On | On |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 烤面包 | 开 | 开 |'
- en: '| Broil | On | Off |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 烤焙 | 开 | 关 |'
- en: We can implement this logic using a pair of 4:1 selectors ganged together, as
    shown in [Figure 2-49](ch02.xhtml#ch02fig49).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一对4:1选择器组合来实现这个逻辑，如[图2-49](ch02.xhtml#ch02fig49)所示。
- en: '![Image](../images/02fig49.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig49.jpg)'
- en: '*Figure 2-49: Toaster oven selector switch*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-49：烤面包炉选择开关*'
- en: '**Summary**'
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned why we use bits instead of digits to build hardware.
    You also saw some of the developments in technology that have allowed us to implement
    bits and combinatorial digital logic. You learned about modern logic design symbols
    and how simple logic elements can be combined to make more complex devices. We
    looked at how the outputs of combinatorial devices are a function of their inputs,
    but because the outputs change in response to the inputs, there’s no way to remember
    anything. Remembering requires the ability to “freeze” an output so that it doesn’t
    change in response to inputs. [Chapter 3](ch03.xhtml#ch03) discusses sequential
    logic, which enables us to remember things over time.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了为什么我们使用位而不是数字来构建硬件。你还了解了技术的某些发展，这些发展使我们能够实现位和组合逻辑电路。你学习了现代逻辑设计符号，以及如何将简单的逻辑元件组合成更复杂的设备。我们探讨了组合设备的输出如何是其输入的函数，但由于输出会根据输入的变化而变化，因此无法记住任何东西。记忆需要能够“冻结”输出，以使其在响应输入时不发生变化。[第3章](ch03.xhtml#ch03)讨论了时序逻辑，这使我们能够随着时间的推移记住事情。
