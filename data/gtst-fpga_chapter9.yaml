- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">USEFUL
    FPGA PRIMITIVES</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">有用的
    FPGA 原语</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: 'So far, you’ve learned about the two most fundamental FPGA components: the
    LUT and the flip-flop. These general-purpose components are the main workhorses
    in your FPGA, but there are also other dedicated components that are commonly
    used in FPGA designs for more specialized tasks. These components are usually
    called *primitives*, but they’re also sometimes referred to as *hard IP* or *cores*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学习了两个最基本的 FPGA 组件：LUT 和触发器。这些通用组件是 FPGA 中的主要工作单元，但也有其他专用组件，常用于 FPGA
    设计中执行更为专业的任务。这些组件通常被称为*原语*，但有时也称为*硬 IP* 或 *核心*。
- en: 'Working with primitives helps you get the most out of your FPGA. In fact, a
    lot of modern FPGA development revolves around linking together these pre-existing
    primitives, with custom code added as needed for application-specific logic. In
    this chapter, we’ll explore three important primitives: the block RAM (BRAM),
    the digital signal processor (DSP) block, and the phase-locked loop (PLL). You’ll
    learn what role each one plays within an FPGA and see how to create them through
    your Verilog or VHDL code, or with assistance from your build tools.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原语可以帮助您最大限度地发挥 FPGA 的性能。事实上，许多现代 FPGA 开发都围绕着将这些预先存在的原语链接在一起，必要时添加自定义代码以实现特定应用的逻辑。在本章中，我们将探讨三个重要的原语：块
    RAM（BRAM）、数字信号处理器（DSP）块和锁相环（PLL）。您将了解它们在 FPGA 中的作用，并学习如何通过 Verilog 或 VHDL 代码创建它们，或者借助构建工具的帮助来创建它们。
- en: The primitives we’ll discuss are especially important on higher-end FPGAs, more
    advanced than the iCE40 FPGAs we’ve focused on so far. With these feature-rich
    FPGAs, the companion GUI software has become a critical piece of the build process.
    These GUIs are more complicated than the iCEcube2 tool we’ve been working with,
    and a large part of the complexity stems from the creation and wiring up of these
    primitives. Once you have an understanding of how the primitives work, however,
    you’ll be better equipped to start working with these more advanced tools and
    to take full advantage of the common built-in features of professional-grade FPGAs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的原语在高端 FPGA 上尤其重要，这些 FPGA 比我们之前关注的 iCE40 FPGA 更加先进。在这些功能丰富的 FPGA 中，配套的
    GUI 软件已经成为构建过程中的关键部分。这些 GUI 比我们一直使用的 iCEcube2 工具更加复杂，其复杂性的一大部分来自于这些原语的创建和连接。一旦您理解了原语的工作原理，您将更有准备开始使用这些更先进的工具，并充分利用专业级
    FPGA 的常见内置功能。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How to Create Primitives</samp>
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">如何创建原语</samp>
- en: There are a few different ways to create an FPGA primitive. Up to this point,
    we’ve been writing Verilog or VHDL and letting the synthesis tools decide for
    us how to translate that code into primitives. We trust the tools to understand
    when we want to create a flip-flop or a LUT. This is called *inference*, since
    we’re letting the tools infer (or make an educated guess about) what we want based
    on our code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 FPGA 原语有几种不同的方法。到目前为止，我们一直在编写 Verilog 或 VHDL 代码，并让综合工具为我们决定如何将这些代码转化为原语。我们信任这些工具能理解我们何时需要创建触发器或查找表（LUT）。这被称为*推断*，因为我们让工具根据我们的代码推断（或做出合理的猜测）我们想要什么。
- en: 'In general, the tools are able to understand our intentions quite well. However,
    there are some primitives that the synthesis tools won’t be able to infer. To
    create those, you need to use another method: you can either explicitly instantiate
    the primitive in your code or use the GUI built into most synthesis tools to automate
    the creation process.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，工具能够很好地理解我们的意图。然而，某些原语是综合工具无法推断的。要创建这些原语，您需要使用另一种方法：您可以在代码中显式实例化原语，或者使用大多数综合工具内置的
    GUI 来自动化创建过程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instantiation</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">实例化</samp>
- en: '*Instantiation* is the creation of a primitive from a code template written
    by the FPGA manufacturer. When you instantiate a primitive component, it looks
    like you’re instantiating a Verilog or VHDL module—but in this case, the module
    you’re instantiating isn’t one you’ve created. Rather, it’s built into the tools
    for your specific FPGA. The actual module code behind these primitives is often
    unavailable to view; it’s part of the secret sauce that the FPGA vendors like
    to keep to themselves.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*实例化*是通过 FPGA 厂商编写的代码模板来创建一个原始组件。当你实例化一个原始组件时，看起来就像在实例化一个 Verilog 或 VHDL 模块——但在这种情况下，你实例化的模块并不是你自己创建的。相反，它是为你特定
    FPGA 构建的工具的一部分。这些原始组件背后的实际模块代码通常无法查看；它是 FPGA 厂商喜欢保密的“秘方”之一。'
- en: 'Let’s look at an example of how to instantiate a block RAM (we’ll talk more
    about these primitives later in the chapter):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如何实例化块 RAM 的示例（我们将在本章稍后讨论这些原始组件）：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code is an example of instantiation of a RAMB18E1 component (a type of
    block RAM) from an AMD FPGA. The code makes the block RAM available for use by
    wiring its internal signals to signals external to the block RAM: for example,
    it wires the block RAM’s internal <samp class="SANS_TheSansMonoCd_W5Regular_11">DOADO</samp>
    signal, a 16-bit output, to an external signal of the same name ❶. I’ve omitted
    many more lines of code that make similar connections. It’s not important that
    you understand the details of this code; it’s just to demonstrate what instantiation
    looks like. Clearly a block RAM is a complicated component, with many bells and
    whistles available to you. Instantiation specifies every single input and output
    of the primitive and allows you to set them exactly as you want. However, it also
    requires that you have a deep knowledge of the primitive being instantiated. If
    you connect it improperly, it won’t work as intended.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是一个实例化 AMD FPGA 中的 RAMB18E1 组件（块 RAM 一种类型）的示例。该代码通过将块 RAM 内部信号连接到块 RAM 外部的信号，使块
    RAM 可供使用：例如，它将块 RAM 的内部 <samp class="SANS_TheSansMonoCd_W5Regular_11">DOADO</samp>
    信号（16 位输出）连接到同名的外部信号 ❶。我省略了许多其他行的代码，这些代码完成类似的连接。理解这些代码的细节并不重要；这只是用来展示实例化是什么样子的。显然，块
    RAM 是一个复杂的组件，具有许多功能可供你使用。实例化指定了原始组件的每个输入和输出，并允许你根据需要精确地设置它们。然而，它也要求你对正在实例化的原始组件有深入的了解。如果连接不当，它就无法按预期工作。
- en: 'If you wanted to, it would be possible to instantiate, rather than infer, even
    a simple component like a flip-flop. Here’s what AMD’s Verilog template looks
    like for instantiating a single flip-flop (which AMD calls an FDSE):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，实际上是可以实例化，而不是推断，甚至是像触发器这样的简单组件。以下是 AMD 的 Verilog 模板，用于实例化一个单一的触发器（AMD
    称之为 FDSE）：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that this primitive has the normal connections we’d expect from a flip-flop,
    including the data output (<samp class="SANS_TheSansMonoCd_W5Regular_11">Q</samp>),
    the clock input (<samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>), the
    clock enable (<samp class="SANS_TheSansMonoCd_W5Regular_11">CE</samp>), and the
    data input (<samp class="SANS_TheSansMonoCd_W5Regular_11">D</samp>). After instantiating
    this flip-flop, you could then make use of these connections in your code. If
    you had to instantiate every single flip-flop in your entire FPGA, however, it
    would take quite a lot of code!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个原始组件具有我们期望从触发器中看到的正常连接，包括数据输出（<samp class="SANS_TheSansMonoCd_W5Regular_11">Q</samp>）、时钟输入（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">C</samp>）、时钟使能（<samp class="SANS_TheSansMonoCd_W5Regular_11">CE</samp>）和数据输入（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">D</samp>）。在实例化这个触发器之后，你就可以在代码中使用这些连接了。然而，如果你必须实例化整个
    FPGA 中的每一个触发器，那将需要写非常多的代码！
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*I found the templates for the RAM18E1 block RAM and the FDSE flip-flop in
    AMD’s online Libraries Guide, which contains the templates for all primitives
    throughout AMD FPGAs. Every FPGA manufacturer has a similar resource where you’ll
    find the instantiation templates for its primitives.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在 AMD 的在线库指南中找到了 RAM18E1 块 RAM 和 FDSE 触发器的模板，该指南包含了 AMD FPGA 所有原始组件的模板。每个
    FPGA 厂商都有类似的资源，你可以在其中找到它的原始组件的实例化模板。*'
- en: 'The benefit of instantiating a primitive is that it gives you exactly what
    you want. You don’t need to trust the synthesis tools to guess at what you’re
    trying to do. However, there are clearly some downsides. As you’ve just seen,
    instantiation takes more code than inference. It also requires you to wire up
    every connection correctly, or the design won’t function as intended. This means
    you need to understand the primitive at a deep level. Finally, each primitive
    needs to be instantiated using a dedicated template specific to your FPGA vendor,
    or sometimes specific to just a subset of devices within a family of FPGAs. For
    example, the RAMB18E1 block RAM component we instantiated earlier only exists
    on AMD FPGAs; Intel and Lattice FPGAs have their own block RAMs. Therefore, instantiation
    makes your code less portable than writing more generic Verilog or VHDL where
    the tools can just infer the primitive based on which FPGA you’re targeting. Next,
    we’ll look at the alternative: using the GUI.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化原语的好处在于它能精确地给你你想要的功能。你不需要依赖综合工具来猜测你想要做什么。然而，显然也有一些缺点。正如你刚才看到的，实例化比推断需要更多的代码。它还要求你正确连接每个连接点，否则设计将无法按预期运行。这意味着你需要深入理解原语。最后，每个原语都需要使用特定于你的FPGA供应商的专用模板来实例化，有时甚至仅针对FPGA系列中的某些设备。例如，我们之前实例化的RAMB18E1块RAM组件只存在于AMD
    FPGA中；Intel和Lattice FPGA有自己的块RAM。因此，实例化使得你的代码不如编写更通用的Verilog或VHDL便于移植，在这些语言中，工具可以根据你所针对的FPGA来推断原语。接下来，我们将看看另一种选择：使用GUI。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The GUI Approach</samp>
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">图形用户界面方法</samp>
- en: Every FPGA vendor has its own GUI or IDE for FPGA development, and that GUI
    will have a section allowing you to view the library of available primitives for
    your FPGA. You can select a primitive that you want to add to your project, and
    the tool will walk you through the process. Additionally, the GUI explains how
    the primitive works and what each setting controls. [Figure 9-1](#fig9-1) shows
    an example of creating a block RAM using the Lattice Diamond GUI. As mentioned
    in [Chapter 2](chapter2.xhtml), this is Lattice’s IDE for working with higher-end
    FPGAs with features like the primitives discussed in this chapter. (The iCEcube2
    IDE doesn’t have a GUI for creating primitives, since it’s designed to work primarily
    with simpler FPGAs.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个FPGA供应商都有自己的GUI或IDE用于FPGA开发，且该GUI将有一个部分让你查看可用原语库。你可以选择一个要添加到项目中的原语，工具会引导你完成整个过程。此外，GUI还会解释原语是如何工作的以及每个设置控制的内容。[图9-1](#fig9-1)展示了使用Lattice
    Diamond GUI创建块RAM的示例。如[第2章](chapter2.xhtml)中提到的，这就是Lattice的IDE，用于处理具有本章讨论的原语等功能的高端FPGA。（iCEcube2
    IDE没有用于创建原语的GUI，因为它主要用于处理简单的FPGA。）
- en: '![](../images/Figure9-1.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: Instantiating a
    block RAM with a GUI</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-1：使用GUI实例化块RAM</samp>
- en: The block diagram on the left side of the window visually demonstrates the block
    RAM’s inputs and outputs. In the configuration section on the right, it’s clear
    which selections for the primitive are mutually exclusive. These are represented
    with radio buttons, like Initialize to All 0’s or Initialize to All 1’s. We can
    also tell which options can be enabled or disabled. These are represented by checkboxes,
    like Enable Output Register or Enable Output ClockEn. In addition, there’s a convenient
    Help button in the bottom-right corner that can guide you through some of these
    decisions if you’re unsure what to pick.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口左侧的框图直观地展示了块RAM的输入和输出。在右侧的配置部分，可以清楚地看到哪些原语的选择是互斥的。这些通过单选按钮表示，例如初始化为全0或初始化为全1。我们还可以看出哪些选项可以启用或禁用。这些通过复选框表示，例如启用输出寄存器或启用输出时钟使能。此外，右下角还有一个方便的帮助按钮，如果你不确定该选择什么，它可以帮助你做出决策。
- en: Once you’ve configured a primitive with a GUI, you’ll get an instantiation template
    that you can drop into your Verilog or VHDL code, much like the one we looked
    at in the previous section. The template will be customized to the exact settings
    that you picked in the GUI so you can wire up your primitive without having to
    make any guesses about how to configure it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用GUI配置了原语，你将获得一个实例化模板，可以将其放入你的Verilog或VHDL代码中，就像我们在上一节中看到的那样。该模板将根据你在GUI中选择的具体设置进行定制，这样你就可以连接你的原语，而不需要猜测如何配置它。
- en: Compared to direct instantiation, the GUI method is more approachable for beginners.
    You’re much less likely to make a mistake using the GUI, since you have the menus
    to guide you, but you can still control exactly what you get, just like with instantiation.
    There is an important downside to this approach, however. If you need to change
    a setting in your primitive, then you need to open the GUI and run through the
    whole process again. This might not sound like a big deal, but if your design
    features many primitives created using a GUI, making adjustments can become quite
    tedious and time-consuming.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接实例化相比，GUI方法对于初学者来说更容易上手。使用GUI时，由于菜单的引导，你更不容易出错，但你仍然可以像实例化时一样精确控制所得到的内容。然而，这种方法也有一个重要的缺点。如果你需要更改原语中的某个设置，就需要打开GUI并重新执行整个过程。这听起来可能不算什么大事，但如果你的设计中有许多使用GUI创建的原语，进行调整可能会变得非常繁琐且耗时。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Block RAM</samp>
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">块RAM</samp>
- en: A *block RAM (BRAM)* is a dedicated memory storage component built into your
    FPGA. Next to LUTs and flip-flops, block RAMs are the third most common FPGA primitive.
    We touched briefly on block RAMs in [Chapter 6](chapter6.xhtml), when we discussed
    common memory modules like RAMs and FIFOs. As I mentioned in that chapter, when
    you need a memory over a certain size, it will be created using a block RAM instead
    of flip-flops.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*块RAM (BRAM)* 是内建于FPGA中的专用存储组件。仅次于查找表（LUTs）和触发器，块RAM是第三种最常见的FPGA原语。在[第6章](chapter6.xhtml)中，我们简要提到过块RAM，当时我们讨论了常见的内存模块，如RAM和FIFO。如同我在那一章中提到的，当你需要一个超过某个大小的内存时，它将使用块RAM而非触发器来创建。'
- en: Creating memory for storing data is an incredibly common task in FPGAs. You
    might use a block RAM for storing read-only data, like calibration values, or
    you might regularly write data to a block RAM from an off-chip device like an
    analog-to-digital converter (ADC) and then read from it later. Block RAMs are
    also commonly used to buffer data between a producer and a consumer, including
    when sending data between clock domains. In this case, the block RAM can be configured
    as a FIFO, with features specially designed to handle the metastability issues
    that arise when crossing between domains (we discussed how you can transmit data
    across cross clock domains back in [Chapter 7](chapter7.xhtml)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为存储数据创建内存是FPGA中非常常见的任务。你可能会使用块RAM来存储只读数据，如校准值，或者你可能会定期将数据从外部设备（如模数转换器（ADC））写入块RAM，然后稍后再从中读取。块RAM也常用于在生产者和消费者之间缓冲数据，包括在时钟域之间传输数据的情况。在这种情况下，块RAM可以配置为FIFO，具有专门设计的功能来处理跨越时钟域时出现的亚稳态问题（我们在[第7章](chapter7.xhtml)中讨论过如何跨时钟域传输数据）。
- en: The number of block RAMs available, and the specific features of each block
    RAM, will vary from FPGA to FPGA and vendor to vendor. You should always consult
    your FPGA’s datasheet and memory guide for details particular to your model. As
    an example, [Figure 9-2](#fig9-2) shows a datasheet highlighting the block RAMs
    on Intel’s Cyclone V line of FPGAs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的块RAM数量以及每个块RAM的具体特性在不同FPGA和不同供应商之间会有所不同。你应该始终查阅你FPGA的datasheet和内存指南，以获取与你的型号相关的详细信息。例如，[图9-2](#fig9-2)展示了Intel
    Cyclone V系列FPGA上的块RAM的datasheet。
- en: '![](../images/Figure9-2.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: Block RAMs on the
    Cyclone V product line</samp>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-2：Cyclone V产品系列上的块RAM</samp>
- en: 'Intel refers to block RAMs as *memory blocks*. The first of the highlighted
    lines in the datasheet is telling us how many of these memory blocks are available
    on each of three FPGA models: 176 on the 5CEA2 FPGA, 308 on the 5CEA4, and 446
    on the 5CEA5 part. The next line on the datasheet shows the total number of kilobits
    (Kb) of block RAM storage available. Each memory block holds 10Kb (hence the *M10K*
    in the name), so there are 1,760Kb of BRAM storage on the 5CEA2 FPGA, 3,080Kb
    on the 5CEA4, and 4,460Kb on the 5CEA5.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Intel将块RAM称为*内存块*。datasheet中标出的一行首先告诉我们每三种FPGA型号中有多少个内存块：5CEA2 FPGA有176个，5CEA4有308个，5CEA5有446个。datasheet中的下一行显示了可用块RAM存储的总千比特数（Kb）。每个内存块可容纳10Kb（因此名称中的*M10K*），所以5CEA2
    FPGA上有1,760Kb的BRAM存储，5CEA4上有3,080Kb，5CEA5上有4,460Kb。
- en: You might be surprised by how little storage that really is. Even the largest
    amount, 4,460Kb, is less than a megabyte! Consider the fact that you can get a
    32-gigabyte MicroSD card, which has thousands of times more storage space, for
    around $10, and you’ll start to appreciate that FPGAs aren’t designed for storing
    data in any significant quantity. Rather, block RAMs are there to buffer data
    on the FPGA for temporary usage. If you need to store large amounts of data, you’ll
    have to use an external chip to do that. MicroSD cards, DDR memory, SRAM, and
    flash memory are common examples of chips that an FPGA might interface to in order
    to expand its memory storage and retrieval capabilities.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对其实际存储容量感到惊讶。即便是最大的 4,460Kb，也不到 1MB！考虑到你可以以大约 10 美元的价格购买一个 32GB 的 MicroSD
    卡，它的存储空间比这个大成千上万倍，你就会开始理解 FPGA 并不是为了存储大量数据而设计的。相反，块 RAM 用于在 FPGA 上缓冲数据，以供临时使用。如果你需要存储大量数据，你将需要使用外部芯片来实现这一点。MicroSD
    卡、DDR 内存、SRAM 和闪存是 FPGA 可能连接的常见芯片类型，以扩展其内存存储和检索能力。
- en: You should also notice in [Figure 9-2](#fig9-2) that block RAMs are the fourth
    item in the Cyclone V datasheet’s list of FPGA resources, after LEs, ALMs, and
    registers. Those are the terms that Intel uses to describe LUTs and flip-flops
    (LE stands for logic element and ALM for Adaptive Logic Module). While you may
    not always need many block RAMs for your application, this prime position in the
    datasheet highlights that block RAMs are often one of the most significant primitive
    components to take into consideration when choosing an FPGA.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该注意，在 [图 9-2](#fig9-2) 中，块 RAM 是 Cyclone V 数据表中 FPGA 资源列表中的第四项，位于 LEs、ALMs
    和寄存器之后。这些是 Intel 用来描述 LUT 和触发器的术语（LE 代表逻辑单元，ALM 代表自适应逻辑模块）。虽然你可能并不总是需要很多块 RAM
    来满足应用需求，但在数据表中的这一重要位置突出显示了块 RAM 通常是选择 FPGA 时必须考虑的最重要原始组件之一。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Features and Limitations</samp>
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">特性与限制</samp>
- en: There are some common features and some limitations that are helpful to keep
    in mind when working with block RAMs. First, block RAMs usually come in only one
    size on an FPGA; 16Kb per block RAM is common. This one-size-fits-all approach
    means that if you only need to use 4Kb out of the 16Kb, you’ll still use up an
    entire block RAM primitive. There’s no way to divide a single block RAM component
    into multiple memories, and in that way, block RAMs can be limiting.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用块 RAM 时，有一些常见的特性和一些限制需要记住。首先，块 RAM 通常在 FPGA 上只有一种尺寸；每个块 RAM 16Kb 是常见的。这种“一刀切”的方法意味着，如果你只需要使用
    16Kb 中的 4Kb，你仍然需要使用整个块 RAM 元件。无法将单个块 RAM 组件划分成多个内存，因此块 RAM 在这方面具有一定的限制。
- en: 'In other ways, however, block RAMs can be quite flexible. You can store data
    in whatever width you like: for example, with a 16Kb block RAM you can store data
    that’s 1 bit wide and 16,384 bits (2^(14)) deep, or 8 bits wide and 2,048 deep,
    or 32 bits wide and 512 deep, among other possibilities. It’s also possible to
    create memories that are larger than a single block RAM. For example, if you needed
    to store 16 kilobytes (KB) of data, that would use up eight individual block RAMs
    (16Kb × 8 = 16KB). The tools are smart enough to cascade the block RAMs and make
    them look like one large memory, rather than eight individual components that
    you need to index into individually.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从其他角度来看，块 RAM 还是相当灵活的。你可以按照自己需要的宽度存储数据：例如，使用 16Kb 的块 RAM，你可以存储宽度为 1 位、深度为
    16,384 位（2^(14)）的数据，或者宽度为 8 位、深度为 2,048 位，或者宽度为 32 位、深度为 512 位等。还可以创建比单个块 RAM
    更大的存储器。例如，如果你需要存储 16KB 的数据，就需要使用八个单独的块 RAM（16Kb × 8 = 16KB）。工具足够智能，能够级联这些块 RAM，使它们看起来像一个大存储器，而不是八个需要单独索引的组件。
- en: Other common features include error detection and correction, where the block
    RAM has some extra bits reserved to detect and correct any errors that might occur
    within the memory itself (that is, when a 1 changes to a 0, or vice versa). If
    that happens in your memory, a value could be completely corrupted and produce
    very strange behavior when the FPGA tries to analyze it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见的功能包括错误检测和修正，其中块 RAM 预留了一些额外的位来检测和修正内存本身可能发生的任何错误（即，当 1 变为 0，或反之）。如果内存发生这种情况，某个值可能会被完全破坏，并且当
    FPGA 尝试分析它时会产生非常奇怪的行为。
- en: 'Error detection and correction are two separate but related processes: the
    FPGA can *detect* some number of bit errors and notify you about their presence,
    and, separately, it can automatically *correct* some number of bit errors. The
    number of bit errors that can be corrected is usually less than the number of
    bit errors that can be detected. The important thing here is that error detection
    and correction within a block RAM are performed automatically, without you having
    to do anything.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 错误检测和纠正是两个独立但相关的过程：FPGA可以*检测*一些位错误并通知你它们的存在，另外，它也可以自动*纠正*一些位错误。通常，能够纠正的位错误数量小于能够检测的位错误数量。这里重要的一点是，块RAM中的错误检测和纠正是自动执行的，你无需做任何操作。
- en: Many block RAMs can also be initialized to default values. This can be a useful
    feature if you need to store a large number of initial values or if you want to
    create read-only memory (ROM). Pushing those values to a block RAM rather than
    taking up flip-flops for data storage can be a valuable way to save resources.
    We touched on this idea back in [Chapter 7](chapter7.xhtml), when we were looking
    at parts of Verilog and VHDL that are synthesizable and not synthesizable. Even
    though reading from a file is normally not synthesizable—remember that there’s
    no filesystem on an FPGA unless you create it yourself—we can read data from files
    as part of the synthesis process to preload a block RAM with default values. Again,
    I recommend consulting the memory guide for your particular FPGA to find out which
    features it supports.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 许多块RAM还可以初始化为默认值。如果你需要存储大量初始值，或者如果你想创建只读内存（ROM），这可能是一个有用的功能。将这些值推送到块RAM，而不是占用触发器进行数据存储，是节省资源的一种有价值的方法。我们在[第七章](chapter7.xhtml)中提到过这个想法，当时我们在看可综合和不可综合的Verilog和VHDL部分时，虽然从文件读取通常是不可综合的——记住，FPGA上没有文件系统，除非你自己创建——但是我们可以作为综合过程的一部分，从文件读取数据，以便将默认值预加载到块RAM中。同样，我建议你查阅特定FPGA的内存指南，以了解它支持哪些功能。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creation</samp>
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建</samp>
- en: 'When using a block RAM in your design, I generally recommend inferring it.
    As you saw in [Chapter 6](chapter6.xhtml), when we create a two-dimensional memory
    element, the tools will easily recognize it. Whether or not this memory gets pushed
    to a block RAM depends on its size. Again, the synthesis tool is smart about this:
    it knows how many bits of memory you’re creating, and if it’s above some threshold,
    then it will be pushed to a block RAM. Otherwise, the tool will just use flip-flops.
    For example, if you’re creating a memory that holds 16 bytes, it will likely be
    pushed to flip-flops. You only need 16 × 8 = 128 bits of memory, so it doesn’t
    make much sense to use an entire 16Kb block RAM for this small quantity of data.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的设计中使用块RAM时，我通常建议推导出它。正如你在[第六章](chapter6.xhtml)中看到的，当我们创建一个二维内存元素时，工具会轻松识别它。这个内存是否会被推送到块RAM取决于其大小。再说一次，综合工具在这方面很聪明：它知道你创建了多少位内存，如果超过某个阈值，它就会将其推送到块RAM，否则，工具只会使用触发器。例如，如果你创建了一个存储16字节的内存，它很可能会被推送到触发器。你只需要16
    × 8 = 128位内存，因此，使用整个16Kb的块RAM来存储这点数据就不太有意义。
- en: 'At which point the tools will start pushing memory to block RAMs instead of
    using flip-flops is highly dependent on the situation. To find out what your tool
    decided for a particular design, consult your utilization report after synthesis.
    Here’s an example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 工具开始将内存推送到块RAM而不是使用触发器的时机，通常取决于具体情况。要了解你的工具为特定设计做出的决定，请在综合后查阅你的利用率报告。以下是一个示例：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The utilization report lists the number of block RAMs required ❶, just as it
    lists the number of flip-flops (registers) and LUTs (LUT4s, or four-input LUTs
    in this case). If you see that no block RAMs are being used, then your memory
    was inferred as flip-flops instead. As a reminder, I always recommend double-checking
    your utilization report to make sure the tools are inferring what you expect.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 利用率报告列出了所需的块RAM数量❶，就像它列出了触发器（寄存器）和LUT（LUT4，或者在此情况下是四输入LUT）的数量一样。如果你看到没有使用块RAM，那么你的内存可能被推导为触发器了。作为提醒，我总是建议你仔细检查利用率报告，确保工具推导出了你预期的结果。
- en: If you’re wary of trying to infer large memory elements, or you’re confused
    about which features you may or may not want to take advantage of in your block
    RAM, then creating it with a GUI is your best option. The GUI will guide you through
    the process, so for beginners it’s very helpful. Using the GUI is also the best
    way to ensure that you’re using a FIFO correctly when crossing clock domains,
    as it can help you handle the complexities involved.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对推断大容量内存元素感到担忧，或者不确定在块 RAM 中应该利用哪些特性，使用图形用户界面（GUI）创建它是你最好的选择。GUI会引导你完成整个过程，因此对于初学者来说非常有帮助。使用GUI也是确保在跨时钟域时正确使用FIFO的最佳方式，因为它可以帮助你处理其中的复杂性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Digital Signal Processing Block</samp>
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">数字信号处理模块</samp>
- en: '*Digital signal processing (DSP)* is a catch-all term for performing math-based
    operations on signals within a digital system. Often these math operations need
    to happen very fast and in parallel, which makes FPGAs an excellent tool for the
    job. Since DSP is such a common FPGA application, another kind of FPGA primitive,
    the *DSP block*, exists for this purpose. DSP blocks (also known as *DSP tiles*)
    specialize in performing mathematical operations, in particular *multiply–accumulate
    (MAC)*, which is an operation where a multiplication is followed by an addition.
    Before we look more closely at these primitives, however, it’s worth taking a
    step back to discuss the difference between analog and digital signals.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*数字信号处理（DSP）* 是对数字系统中的信号执行基于数学的操作的统称。这些数学操作通常需要非常快速地并行执行，这使得 FPGA 成为执行此任务的极好工具。由于
    DSP 是 FPGA 中一个非常常见的应用，另一种 FPGA 原语，*DSP 块*，也为此目的存在。DSP 块（也称为 *DSP 瓦片*）专门用于执行数学操作，特别是
    *乘法–累加（MAC）* 操作，这是一个先进行乘法操作再进行加法操作的过程。然而，在我们更深入地研究这些原语之前，值得先回顾一下模拟信号和数字信号之间的区别。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Analog vs. Digital
    Signals</samp>
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">模拟信号与数字信号</samp>
- en: An *analog signal* is a continuous signal representing some physical measurement.
    A common example is the audio signal stored on a vinyl record (a big black shiny
    thing that has music on it, sometimes seen in old movies or new hipster bars).
    The record is etched with a continuous groove that mirrors the continuous waveform
    of the audio. Then a record player reads that waveform with a needle and amplifies
    the resulting signal to play back the sound. The information is always analog;
    no conversion is needed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*模拟信号*是一个连续的信号，表示某种物理量的测量。一个常见的例子是储存在黑胶唱片上的音频信号（这是一种大而黑的光亮物体，上面有音乐，有时可以在老电影或新潮的酒吧里看到）。唱片上刻有一条连续的凹槽，反映了音频的连续波形。然后，唱片播放机用针头读取这个波形，并放大得到的信号来回放声音。信息始终是模拟的，无需转换。'
- en: '*Digital signals*, on the other hand, aren’t continuous. Rather, they consist
    of discrete measurements at individual points in time, with gaps in between. A
    common example is the audio signal stored on a CD, where the sound is represented
    as a series of 1s and 0s. If you have enough discrete measurements, you can fill
    in the gaps to create a reasonably accurate approximation of an analog signal
    from those digital values. A CD player reads those digital values and rebuilds
    an analog waveform from them. The result is always an approximation of the original
    analog signal, however, which is why some audiophiles prefer the true analog signal
    of a record to digital media like CDs and MP3s.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*数字信号*则不同，它们不是连续的，而是在各个时间点上由离散的测量值组成，中间有间隔。一个常见的例子是储存在 CD 上的音频信号，其中声音以一系列的
    1 和 0 来表示。如果你有足够的离散测量值，你可以填补这些间隔，从这些数字值中创建出一个 reasonably accurate 逼真的模拟信号近似值。CD
    播放器读取这些数字值，并从中重建出模拟波形。结果总是原始模拟信号的近似，因此一些音响爱好者更喜欢唱片的真实模拟信号，而不是 CD 或 MP3 等数字媒体。'
- en: 'Within your common FPGA fabric, like LUTs and flip-flops, data is represented
    digitally. So what do you do if you have some analog signal that you need to bring
    into your FPGA? This is the purpose of an ADC: it converts an analog signal into
    a digital one by *sampling* it, or recording its value, at discrete points in
    time. [Figure 9-3](#fig9-3) shows how this works.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在你常见的 FPGA 结构中，例如查找表（LUT）和触发器，数据是以数字形式表示的。那么，如果你有一个需要输入到 FPGA 中的模拟信号该怎么办呢？这就是
    ADC 的作用：它通过 *采样*，即在离散的时间点记录其值，将模拟信号转换为数字信号。[图 9-3](#fig9-3) 显示了这一过程是如何工作的。
- en: '![](../images/Figure9-3.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: Digital sampling
    of an analog signal</samp>'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-3：模拟信号的数字采样</samp>
- en: 'The undulating line moving from left to right in the figure represents a continuous
    analog signal, and the dark points along that line represent the individual samples
    taken of that signal to convert it into a digital form. Notice that the samples
    are taken at regular time intervals. The frequency at which the analog signal
    is sampled is called the *sampling frequency* or *sampling rate*. The higher the
    sampling rate, the more accurately we can represent an analog signal, because
    it’s easier to connect the discrete dots into something that looks like the original
    waveform. However, a higher sampling rate also means that we have more data that
    we have to process: each dot represents some number of bits of digital data, so
    the more dots you have, the more bits you’re working with.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图中从左到右移动的波动线表示一个连续的模拟信号，而沿着这条线的黑点则表示对该信号进行采样并将其转换为数字形式。注意，采样是按规律的时间间隔进行的。模拟信号的采样频率被称为*采样频率*或*采样率*。采样率越高，我们就能越准确地表示模拟信号，因为将离散的点连接成类似于原始波形的形状会更加容易。然而，较高的采样率也意味着我们需要处理更多的数据：每个点代表一定数量的数字数据，所以点越多，我们处理的位数就越多。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Common DSP Tasks</samp>
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">常见的 DSP 任务</samp>
- en: 'FPGAs commonly take an analog signal as input, digitize it, and then do some
    math to process that digital data. As an example, let’s say we have an audio signal
    that we’ve sampled within our FPGA. Let’s furthermore assume that the recorded
    data was too quiet, so when it’s played back it’s hard to hear. How can we manipulate
    the digital signal such that the output volume is louder? One simple thing we
    can do is multiply every digital value by some constant, say 1.6\. This is called
    applying *gain* to a signal. How would we accomplish this within an FPGA? It’s
    quite simple:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA 通常将模拟信号作为输入，将其数字化，然后进行一些数学运算来处理这些数字数据。例如，假设我们有一个音频信号，我们已经在 FPGA 中对其进行了采样。进一步假设录制的数据太小，播放时很难听清。我们如何操作数字信号，使输出音量更大呢？我们可以做的一件简单的事是将每个数字值乘以一个常数，例如
    1.6。这就是对信号应用*增益*。那么我们如何在 FPGA 中实现这一点呢？其实非常简单：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We take the <samp class="SANS_TheSansMonoCd_W5Regular_11">input_signal</samp>,
    multiply every discrete digital value in that signal by <samp class="SANS_TheSansMonoCd_W5Regular_11">1.6</samp>,
    and store the result in the <samp class="SANS_TheSansMonoCd_W5Regular_11">gain_adjusted</samp>
    output. Here is where the DSP primitive comes into play. When we write code like
    this, the synthesis tools will see that we’re performing a multiplication operation
    and infer a DSP block for us automatically.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">input_signal</samp>，将信号中每个离散的数字值乘以
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1.6</samp>，然后将结果存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">gain_adjusted</samp>
    输出中。这时，DSP 原语就派上用场了。当我们编写这样的代码时，综合工具会看到我们在执行乘法操作，并自动推断出一个 DSP 块来处理这一操作。
- en: Applying gain to an input signal doesn’t require parallel processing. There’s
    only one multiplication operation per data sample, and the data samples can be
    processed one after the other. Often, however, you’ll need to perform many mathematical
    operations in parallel by running several DSP blocks simultaneously. A common
    example is creating a *filter*, a system that performs mathematical operations
    on a signal to reduce or enhance certain features of the input signal. A *low-pass
    filter (LPF)*, for instance, keeps the frequency components of a signal that are
    below some cutoff while reducing the frequencies that are above that cutoff, which
    can be useful for removing high-frequency noise from an input signal. Lowering
    the treble slider on your audio system is a real-world example of applying a low-pass
    filter, since it will reduce high frequencies within the audio. The details of
    implementing a digital LPF are beyond the scope of this book, but since it requires
    many multiplication and addition operations all occurring at the same time, FPGAs
    are well suited for the task.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对输入信号应用增益不需要并行处理。每个数据样本只有一次乘法运算，数据样本可以一个接一个地处理。然而，通常你需要通过同时运行多个 DSP 块来执行多个数学运算。一个常见的例子是创建一个*滤波器*，它对信号执行数学运算，以减少或增强输入信号的某些特征。例如，*低通滤波器
    (LPF)* 会保留信号中低于某个截止频率的频率成分，同时减少高于该截止频率的频率，这对于去除输入信号中的高频噪声非常有用。降低音响系统中高音的滑块是应用低通滤波器的一个现实世界例子，因为它会减少音频中的高频部分。数字低通滤波器的实现细节超出了本书的范围，但由于它需要同时进行许多乘法和加法运算，因此
    FPGA 非常适合完成这一任务。
- en: Another example of parallel math that might be performed in an FPGA is processing
    video data to create a blur effect. Blurring video involves replacing individual
    pixel values with the average value of a group of neighboring pixels. This requires
    performing math on the many pixels in an image at the same time, and this must
    happen quickly since the video data consists of many images per second. An FPGA
    is very capable of performing these parallel mathematical operations using DSP
    blocks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能在 FPGA 中执行的并行数学运算的例子是处理视频数据以创建模糊效果。视频模糊涉及用一组邻近像素的平均值替换单个像素值。这需要同时对图像中的许多像素进行数学运算，并且由于视频数据每秒包含许多图像，这必须迅速完成。FPGA
    能够使用 DSP 块高效地执行这些并行数学运算。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Features</samp>
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">功能</samp>
- en: DSP blocks are versatile primitives, providing many features that facilitate
    different math operations. You won’t always need every feature for your application—most
    often, you’ll just be performing a multiplication or addition operation—but for
    more complicated scenarios, the DSP block can be set up to solve a wide range
    of problems. [Figure 9-4](#fig9-4) provides a detailed look at a DSP block in
    an FPGA from AMD. Each manufacturer’s DSP primitive is a bit different, but this
    example is representative of the typical features available.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: DSP 块是多功能的原语，提供许多有助于执行不同数学运算的功能。你并不总是需要为你的应用程序使用所有功能——通常，你只需要进行乘法或加法运算——但对于更复杂的场景，DSP
    块可以配置来解决广泛的问题。[图 9-4](#fig9-4)详细展示了 AMD FPGA 中的 DSP 块。每个制造商的 DSP 原语有所不同，但这个示例代表了典型的可用功能。
- en: '![](../images/Figure9-4.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4: Block diagram of
    a DSP primitive</samp>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-4：DSP 原语的框图</samp>
- en: 'This diagram actually shows a simplified version of the DSP block. It’s not
    critical to understand the complete anatomy of the primitive, but it’s worth pointing
    out a few things. First, notice that this DSP block can take up to four inputs
    and has two outputs. This allows for more applications than simply multiplying
    two numbers together: for example, MAC, where the result of a multiplication is
    fed back into the input at the next clock cycle for an addition operation.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图实际上展示了 DSP 块的简化版本。理解原语的完整结构并非至关重要，但值得指出几点。首先，注意到这个 DSP 块最多可以接受四个输入并有两个输出。这使得它比仅仅进行两个数字相乘的应用更具扩展性：例如，MAC，其中乘法结果在下一个时钟周期反馈到输入以进行加法运算。
- en: Toward the left-hand side of the block diagram, you can see a *pre-adder* block.
    This can be enabled if an addition operation is requested prior to another mathematical
    operation. To the right of this, near the middle of the diagram, is a circle with
    an X in it. This is the *multiplier*, which is the heart of the DSP block. It
    performs multiplication operations at very high speeds. To its right is a circle
    labeled ALU, short for *arithmetic logic unit*, which can perform more operations,
    like addition and subtraction. Finally, there are built-in output registers that
    can be enabled to sample the outputs and help meet timing at fast data rates.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在框图的左侧，你可以看到一个*预加法器*块。如果请求在执行其他数学操作之前进行加法操作，可以启用该块。在它的右侧，接近图的中间位置，是一个带有 X 的圆圈。这就是*乘法器*，它是
    DSP 块的核心，执行高速的乘法操作。在它的右侧是一个标有 ALU 的圆圈，ALU 代表*算术逻辑单元*，可以执行更多操作，如加法和减法。最后，还有内建的输出寄存器，可以启用以采样输出并帮助在快速数据速率下满足时序要求。
- en: Like the number of block RAMs, the number of DSP blocks available to you will
    vary from FPGA to FPGA. Some higher-end FPGAs have thousands of DSP blocks inside
    them; again, you should consult your FPGA’s datasheet for details specific to
    your model. As an example, [Figure 9-5](#fig9-5) highlights the information on
    DSP blocks in the datasheet for Intel’s Cyclone V product line.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与块 RAM 数量一样，可用的 DSP 块数量因 FPGA 而异。一些高端 FPGA 内部有成千上万个 DSP 块；同样，你应该查阅你 FPGA 的数据手册，以获取与你型号相关的具体细节。举个例子，[图
    9-5](#fig9-5) 显示了 Intel Cyclone V 产品线数据手册中关于 DSP 块的信息。
- en: '![](../images/Figure9-5.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-5: DSP blocks on Cyclone
    V FPGAs</samp>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-5：Cyclone V FPGA 上的 DSP
    块</samp>
- en: Notice that the DSP block information comes just below the block RAM information,
    again pointing to the importance of these primitives in FPGA development. The
    5CEA2 FPGA has 25 DSP blocks, but that increases to 66 for the 5CEA4 and 150 for
    the 5CEA5\. Each DSP block has two multipliers, so on the second highlighted line
    we can see that there are twice as many 18 × 18 multipliers (where 18 is the width
    of the inputs) as there are DSP blocks.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，DSP 块的信息紧跟在块 RAM 信息之后，这再次强调了这些原语在 FPGA 开发中的重要性。5CEA2 FPGA 有 25 个 DSP 块，但
    5CEA4 为 66 个，5CEA5 为 150 个。每个 DSP 块有两个乘法器，因此在第二行高亮显示的地方，我们可以看到 18×18 乘法器的数量是 DSP
    块的两倍（其中 18 是输入的位宽）。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*If there aren’t any DSP blocks available on your FPGA, that doesn’t mean you
    can’t perform these types of operations. Multiplication and addition operations
    will just be implemented with LUTs, rather than with dedicated DSP blocks. We’ll
    discuss this further in [Chapter 10](chapter10.xhtml).*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你的 FPGA 上没有可用的 DSP 块，这并不意味着你不能执行这些类型的操作。乘法和加法操作将仅使用 LUT 实现，而不是使用专用的 DSP
    块。我们将在[第10章](chapter10.xhtml)进一步讨论这个问题。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creation</samp>
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建</samp>
- en: As with block RAMs, I generally recommend using inference to create DSP blocks.
    Most of the multiplication operations you’ll need to do will require two inputs
    and one output, as you saw earlier when we applied gain to a signal. It’s simple
    enough to write the relevant code in Verilog or VHDL and let the tools handle
    the rest. Remember to check your synthesis report to ensure that you’re getting
    what you expect, but I’ve had good luck with the synthesis tools understanding
    my intent with addition and multiplication and pushing those operations to DSPs
    where relevant. The user guides for your particular FPGA will also provide you
    with suggestions on how to write your Verilog or VHDL code to help ensure the
    tools understand your intentions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与块 RAM 一样，我通常建议使用推理来创建 DSP 块。你需要执行的大多数乘法操作将需要两个输入和一个输出，就像我们之前对信号应用增益时看到的那样。用
    Verilog 或 VHDL 编写相关代码并让工具处理其余部分非常简单。记得检查你的综合报告，以确保你得到了预期的结果，但我在使用综合工具理解我的加法和乘法意图时运气不错，它们会将这些操作推送到相关的
    DSP 中。你所使用的 FPGA 的用户指南还将提供如何编写 Verilog 或 VHDL 代码的建议，帮助确保工具理解你的意图。
- en: If you have more complicated needs for your DSP blocks, or if you want to explore
    all of the features and capabilities internal to them, then you should probably
    create them using a GUI to ensure you get what you want. [Figure 9-6](#fig9-6)
    shows an example of creating a multiplier within the Lattice Diamond GUI.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 DSP 块有更复杂的需求，或者你想深入探索它们的所有特性和功能，那么你可能应该通过 GUI 来创建它们，以确保能够得到你想要的功能。[图 9-6](#fig9-6)展示了在
    Lattice Diamond GUI 中创建乘法器的示例。
- en: '![](../images/Figure9-6.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-6: Creating a DSP
    block with a GUI</samp>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-6：通过 GUI 创建 DSP 块</samp>
- en: One thing to highlight here is the Block Implementation drop-down menu. You
    can change this from DSP to LUT to use look-up tables rather than a DSP block
    to perform this multiplication operation. As mentioned previously, LUTs and DSPs
    are both capable of performing math operations, including multiplication. With
    the DSP block, however, you’ll save LUT resources, and you’ll be able to run the
    math operation at much faster clock rates, since you’ll be using a dedicated primitive
    highly optimized for math.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要特别强调的是“块实现”下拉菜单。你可以将其从 DSP 改为 LUT，以使用查找表而非 DSP 块来执行乘法运算。如前所述，LUT 和 DSP 都可以执行数学运算，包括乘法。然而，使用
    DSP 块，你可以节省 LUT 资源，并且能够以更高的时钟频率运行数学运算，因为你将使用一个专门为数学运算高度优化的原语。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Phase-Locked Loop</samp>
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">锁相环（PLL）</samp>
- en: The *phase-locked loop (PLL)* is a primitive commonly used as the main clock
    generator for your entire FPGA. Very often, you’ll have an external clock chip
    that runs at some frequency. On some FPGAs, you can simply use that input clock
    to feed all of your synchronous logic directly, as we’ve done in this book’s projects.
    In this case, your logic frequency will be fixed at the frequency of whatever
    external clock you picked. But what happens if you need to change that frequency?
    Without a PLL, you would need to physically remove the external clock chip and
    replace it with a different component that generates the clock frequency you want
    to switch to. With a PLL, however, you can generate a different clock frequency
    inside your FPGA by changing a few lines of code, without requiring a new external
    component.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*锁相环（PLL）* 是一种常用于作为整个 FPGA 主时钟生成器的原语。通常情况下，你会有一个外部时钟芯片，它运行在某个频率上。在某些 FPGA 上，你可以直接使用这个输入时钟来驱动所有同步逻辑，就像我们在本书的项目中做的那样。在这种情况下，你的逻辑频率将固定为你选择的外部时钟频率。但是，如果你需要更改频率会怎样呢？没有
    PLL 的话，你需要物理地移除外部时钟芯片，并将其替换为一个生成你想要切换到的时钟频率的不同组件。然而，使用 PLL 后，你可以通过改变几行代码，在 FPGA
    内部生成不同的时钟频率，而无需新的外部组件。'
- en: PLLs also make it easy to have multiple clock domains in your FPGA design. Say
    you have some external memory that runs at 100 MHz, but you want your main logic
    to run at 25 MHz. You *could* purchase a second external clock and feed that into
    your FPGA, but a better solution is to use a PLL, since this primitive can generate
    multiple clock frequencies simultaneously.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: PLL 还使得在 FPGA 设计中使用多个时钟域变得更加容易。假设你有一些外部内存，它的运行频率是 100 MHz，但你希望主逻辑运行在 25 MHz。如果你想要实现这一点，你*可以*购买第二个外部时钟并将其输入到
    FPGA 中，但更好的解决方案是使用 PLL，因为这个原语可以同时生成多个时钟频率。
- en: Not all FPGAs have a PLL, but many have at least one, and some have several.
    The datasheet will tell you what’s available. As an example, [Figure 9-7](#fig9-7)
    highlights the PLLs available on Intel’s Cyclone V product line.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的 FPGA 都有 PLL，但许多 FPGA 至少有一个，而有些 FPGA 则有多个。数据手册会告诉你有哪些可用的 PLL。例如，[图 9-7](#fig9-7)展示了英特尔
    Cyclone V 产品线上的 PLL。
- en: '![](../images/Figure9-7.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-7: PLLs on the Cyclone
    V product line</samp>'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-7：Cyclone V 产品线上的 PLL</samp>
- en: The 5CEA2 and 5CEA4 FPGAs both have four PLLs, while the 5CEA5 has six. Given
    that each PLL can generate multiple clocks, that should be more than enough for
    all your clocking needs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 5CEA2 和 5CEA4 FPGA 都有四个 PLL，而 5CEA5 则有六个。鉴于每个 PLL 都可以生成多个时钟频率，这应该足以满足你所有的时钟需求。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How It Works</samp>
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">工作原理</samp>
- en: A PLL serves as the source of your clock distribution throughout your FPGA by
    taking a single clock input, often called the *reference clock*, and generating
    one or more clock outputs from it. The input clock comes from a dedicated external
    component, and the outputs can run at completely different frequencies from the
    input clock and from one another. The block diagram in [Figure 9-8](#fig9-8) shows
    the most common signals on a PLL.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: PLL 作为你在 FPGA 中时钟分发的源头，通过接收一个单一的时钟输入，通常称为*参考时钟*，并从中生成一个或多个时钟输出。输入时钟来自一个专用的外部组件，输出时钟可以与输入时钟以及彼此的频率完全不同。[图
    9-8](#fig9-8)中的框图展示了 PLL 上最常见的信号。
- en: '![](../images/Figure9-8.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-8.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-8: Common PLL signals</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-8：常见的 PLL 信号</samp>
- en: 'The PLL typically takes two inputs: a clock signal and a reset. The reset input
    will stop the PLL from running when it’s asserted.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: PLL 通常有两个输入：一个时钟信号和一个复位信号。当复位信号被激活时，PLL 将停止运行。
- en: On the output side, the PLL has some number of output clocks in the range 1
    to *N*, with the maximum number depending on the FPGA. The output clocks can be
    of different frequencies, depending on what you need for your design. These frequencies
    are achieved by taking the input reference clock and multiplying and/or dividing
    it to get the desired value. For example, say you have a 10 MHz input reference
    clock, and you want a 15 MHz output clock. The PLL would multiply the reference
    clock by 3 (giving you 30 MHz), then divide it by 2 to get down to 15 MHz. The
    multiplication and division terms must be integers, so it’s important to realize
    that you can’t get any arbitrary frequency out of the PLL. It isn’t possible to
    get a π MHz clock output from a 10 MHz clock input, for example, since π is an
    irrational number that can’t be expressed as the ratio of two integers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出端，PLL 有一定数量的输出时钟，范围从 1 到*N*，最大值取决于 FPGA。输出时钟的频率可以不同，具体取决于设计的需求。这些频率通过对输入参考时钟进行乘法和/或除法运算来实现，从而得到所需的值。例如，假设你有一个
    10 MHz 的输入参考时钟，并且你需要一个 15 MHz 的输出时钟。PLL 会将参考时钟乘以 3（得到 30 MHz），然后再除以 2 得到 15 MHz。乘法和除法的因子必须是整数，因此必须注意你不能从
    PLL 获得任何任意的频率。例如，无法从 10 MHz 的时钟输入获得 π MHz 的时钟输出，因为 π 是一个无法表示为两个整数比值的无理数。
- en: Besides varying the frequency of the output clock(s), a PLL can also vary their
    phase. A signal’s *phase* is its current position along the repeating waveform
    of the signal, measured as an angle from 0 to 360 degrees. It’s easiest to picture
    what this means by comparing two signals that share a frequency but aren’t aligned
    in time. [Figure 9-9](#fig9-9) demonstrates some common phase shifts of a clock
    signal.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以改变输出时钟的频率外，PLL 还可以改变它们的相位。信号的*相位*是信号在其重复波形中的当前位置，以 0 到 360 度的角度来测量。通过比较两个共享相同频率但时间上不同步的信号，可以更容易地理解这一点。[图
    9-9](#fig9-9)演示了一些常见的时钟信号相位偏移。
- en: '![](../images/Figure9-9.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-9.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-9: Common phase shifts</samp>'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-9：常见的相位偏移</samp>
- en: As this figure shows, shifting the phase of a clock signal results in moving
    the location of its rising edges. Compare the first rising edge of <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp>
    (which has no phase shift) with the first rising edge of <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">90°</samp>
    (which is phase-shifted by 90 degrees). The rising edge of <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">90°</samp>
    is delayed by one-quarter of a clock period relative to <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp>.
    Each increment of 90 degrees shifts the signal by another quarter period. Continuing
    the example in the figure, we have <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">180°</samp>,
    which is delayed by 90 degrees from <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">90°</samp>
    and 180 degrees from <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp>.
    Notice that <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">180°</samp> is actually the same waveform
    that you would get if you took the <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp>
    signal and inverted it by swapping the highs and lows. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">270°</samp>
    is delayed by three-quarters of a clock period relative to the original <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp> signal. If you went a full
    360 degrees, you’d be back to your original signal. This example has demonstrated
    positive phase shifts, but phase can also be negative, meaning the signal is shifted
    backward in time compared to the other. Of course, you can shift the phase by
    any arbitrary angle, not just in 90-degree steps.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: "如图所示，时钟信号的相位偏移会导致其上升沿的位置发生变化。将没有相位偏移的<\tsamp class=\"SANS_TheSansMonoCd_W5Regular_11\"\
    >Clk</samp>的第一个上升沿与相位偏移90度的<\tsamp class=\"SANS_TheSansMonoCd_W5Regular_11\">Clk</samp><samp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">+</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\"\
    >90°</samp>的第一个上升沿进行比较。<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Clk</samp><samp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">+</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\"\
    >90°</samp>的上升沿比<\tsamp class=\"SANS_TheSansMonoCd_W5Regular_11\">Clk</samp>延迟了一个时钟周期的四分之一。每增加90度，相位偏移都会使信号再延迟一个四分之一周期。继续图中的示例，得到<\t\
    samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Clk</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\"\
    >+</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">180°</samp>，该信号比<\tsamp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">Clk</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\"\
    >+</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">90°</samp>延迟了90度，相比<\t\
    samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Clk</samp>延迟了180度。请注意，<samp class=\"\
    SANS_TheSansMonoCd_W5Regular_11\">Clk</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\"\
    >+</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">180°</samp>实际上与如果你将<\t\
    samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Clk</samp>信号反转（交换高低电平）得到的波形是相同的。最后，<samp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">Clk</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\"\
    >+</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">270°</samp>比原始<\tsamp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">Clk</samp>信号延迟了三个四分之一时钟周期。如果你将相位偏移到360度，你将恢复到原始信号。这个例子演示了正相位偏移，但相位也可以是负的，意味着信号相对于另一个信号在时间上被向后偏移。当然，你可以以任何任意角度来调整相位，而不仅限于90度的步长。"
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Creating clocks with phase shifts isn’t very common in simple designs, but
    it can be useful in some applications. For example, it might be important for
    interfacing to external components, like some off-FPGA memory.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*在简单设计中，使用相位偏移来创建时钟并不常见，但在某些应用中可能会很有用。例如，这对于与外部组件的接口可能很重要，比如一些非FPGA内存。*'
- en: Returning to the block diagram in [Figure 9-8](#fig9-8), a PLL also typically
    has a *locked* output signal, which tells any module downstream that the PLL is
    operating and you can “trust” the clocks. It’s a common design practice to use
    this locked signal as a reset to other modules relying on the PLL’s clocks. When
    the PLL isn’t locked, the modules downstream of the PLL are held in a reset state
    until the PLL is locked and ready, meaning the output clocks can be used by other
    modules in your FPGA design. When the PLL’s reset input is driven high its locked
    output will go low, putting the downstream modules back into a reset condition.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[图 9-8](#fig9-8)中的框图，PLL 通常还有一个*锁定*输出信号，告诉下游的任何模块 PLL 正在工作，你可以“信任”这些时钟。使用这个锁定信号作为依赖于
    PLL 时钟的其他模块的复位信号是一种常见的设计实践。当 PLL 没有锁定时，PLL 下游的模块将保持复位状态，直到 PLL 锁定并准备好为止，这意味着输出时钟可以被你
    FPGA 设计中的其他模块使用。当 PLL 的复位输入被驱动为高电平时，其锁定输出将变为低电平，将下游模块恢复到复位状态。
- en: If you’re going to use a PLL in your design, it’s a good idea to use *only*
    the PLL’s outputs for all your clocking needs. Even if part of your design runs
    at the same clock frequency as the external reference clock, you shouldn’t use
    the external clock directly to drive that part of the design. Instead, have the
    PLL output a clock signal at the same frequency as the external reference. By
    only using the PLL’s outputs, you can tightly control the relationships between
    the output clocks. Additionally, you can confidently use the locked output of
    the PLL for your reset circuitry, knowing it reflects the state that *all* clocks
    in your design are operational.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在设计中使用 PLL（相位锁定环），建议*仅*使用 PLL 的输出端来满足所有时钟需求。即使你设计中的一部分与外部参考时钟的频率相同，也不应直接使用外部时钟来驱动该部分设计。相反，应该让
    PLL 输出与外部参考时钟相同频率的时钟信号。通过只使用 PLL 的输出，你可以精确控制输出时钟之间的关系。此外，你可以放心地使用 PLL 锁定的输出作为复位电路，知道它反映了你设计中*所有*时钟的工作状态。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creation</samp>
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建</samp>
- en: The PLL is one primitive that I recommend using a GUI to create, since the synthesis
    tools won’t be able to infer a PLL. Instantiation is also possible, but it’s prone
    to errors. You need to choose PLL settings that are compatible with one another
    for the PLL to work successfully, and during instantiation it’s easy to pick settings
    that won’t work. If you had a 10 MHz reference clock and you wanted to generate
    one 15 MHz output and a separate 89 MHz output, for example, that simply might
    not be possible, but you might miss that fact during instantiation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐使用 GUI 来创建 PLL，因为综合工具无法推断 PLL。虽然也可以通过实例化来创建 PLL，但这容易出错。你需要选择兼容的 PLL 设置才能成功工作，在实例化时很容易选择不兼容的设置。例如，如果你有一个
    10 MHz 的参考时钟，并且想生成一个 15 MHz 的输出和一个独立的 89 MHz 输出，这可能根本行不通，但你可能会在实例化过程中忽略这个事实。
- en: When you create a PLL using the GUI, you tell it your input reference clock
    and desired output clock frequencies, and the tool will tell you if it can find
    a solution that works. Continuing the 10/15/89 MHz example, the GUI might tell
    you that the closest value to 89 MHz that it can give you is 90 MHz (since 90
    MHz is a multiple of both 10 MHz and 15 MHz, this is likely to work). Then it’s
    up to you to decide whether 90 MHz will work for your design or if you really
    need 89 MHz, in which case you might need to use a separate PLL or change your
    reference clock. [Figure 9-10](#fig9-10) shows an example of the PLL GUI within
    Lattice Diamond.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过 GUI 创建 PLL 时，你需要提供输入参考时钟和期望的输出时钟频率，工具会告诉你是否能找到一个可行的解决方案。以 10/15/89 MHz
    为例，GUI 可能告诉你它能够提供的最接近 89 MHz 的频率是 90 MHz（因为 90 MHz 是 10 MHz 和 15 MHz 的倍数，这应该是可行的）。然后，你需要决定
    90 MHz 是否适合你的设计，或者你是否真的需要 89 MHz，如果是这样，可能需要使用一个单独的 PLL 或者更改你的参考时钟。[图 9-10](#fig9-10)
    显示了 Lattice Diamond 中 PLL GUI 的示例。
- en: '![](../images/Figure9-10.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-10.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-10: Creating a PLL
    with a GUI</samp>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-10：使用 GUI 创建 PLL</samp>
- en: As you can see, the GUI helps guide us through the PLL creation process. In
    this case, we have a 30 MHz reference on <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKI</samp>,
    and we’re setting the desired output frequencies to 30 MHz on <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOP</samp>,
    60 MHz on <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOS</samp>, 15 MHz on
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOS2</samp>, and 89 MHz on <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CLKOS3</samp>. Notice that for each clock
    except <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOS3</samp>, the actual
    frequency on the far right matches the desired frequency. For <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOS3</samp>,
    when I first tried to create an 89 MHz clock with 0.0 percent tolerance, I got
    the error message shown in [Figure 9-11](#fig9-11).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，GUI帮助我们引导PLL创建过程。在这个例子中，我们在<samp class="SANS_TheSansMonoCd_W5Regular_11">CLKI</samp>上有一个30
    MHz的参考频率，我们将期望的输出频率设置为：在<samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOP</samp>上为30
    MHz，<samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOS</samp>上为60 MHz，<samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOS2</samp>上为15
    MHz，以及<samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOS3</samp>上为89 MHz。请注意，除了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CLKOS3</samp>之外，每个时钟的实际频率（最右侧）都与期望频率相匹配。对于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CLKOS3</samp>，当我第一次尝试以0.0%的容差创建一个89 MHz的时钟时，我得到了[图9-11](#fig9-11)中显示的错误信息。
- en: '![](../images/Figure9-11.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-11.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-11: Actionable feedback
    from invalid PLL settings</samp>'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-11：无效PLL设置的可操作反馈</samp>
- en: Not until I changed the tolerance to 2.0 percent did the error message go away;
    the tool had selected an actual frequency of 90 MHz, which is within 2.0 percent
    of the requested frequency. This type of guidance isn’t provided if you try to
    instantiate your PLL directly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 直到我将容差改为2.0%时，错误信息才消失；工具选择了90 MHz的实际频率，这在请求频率的2.0%范围内。如果你尝试直接实例化PLL，工具不会提供这种类型的指导。
- en: Another helpful feature of the GUI is the PLL block diagram, shown in the left
    half of [Figure 9-10](#fig9-10). This diagram will be updated if you modify the
    inputs or outputs. For example, if we disabled <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOS3</samp>,
    that output would disappear from the block diagram to reflect that we only want
    to output three clock signals. This is useful to ensure you’re creating what you
    expect. Notice that there’s also a separate Phase tab near the top of the window,
    which allows us to specify phase shifts on our output clocks.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: GUI的另一个有用功能是PLL框图，显示在[图9-10](#fig9-10)的左半部分。如果你修改了输入或输出，这个图示会更新。例如，如果我们禁用了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CLKOS3</samp>，该输出将在框图中消失，表示我们只希望输出三个时钟信号。这个功能对于确保你正在创建预期的内容非常有用。请注意，窗口顶部还有一个单独的“Phase”标签，允许我们为输出时钟指定相位偏移。
- en: 'After designing a PLL in the GUI, you can run your design through the normal
    synthesis process. The utilization report will confirm you’re getting a PLL, as
    it’s one of the main primitives highlighted in the report. Here’s an example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI中设计PLL之后，你可以通过正常的综合过程运行你的设计。利用率报告将确认你确实得到了PLL，因为它是报告中突出的主要原语之一。以下是一个示例：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This indicates one PLL is being used out of four available on this particular
    FPGA.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示在这个特定FPGA中，正在使用四个PLL中的一个。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: The majority of your Verilog and VHDL code will be dedicated to creating LUTs
    and flip-flops, which are the two most fundamental FPGA components. However, as
    you’ve seen in this chapter, FPGAs also contain other primitive components, such
    as block RAMs, DSP blocks, and PLLs, that add specialized functionality. Block
    RAMs add dedicated memory, DSP blocks enable high-speed parallel math operations,
    and PLLs allow you to generate different internal clock frequencies. With a combination
    of these FPGA building blocks, you’ll be able to solve a wide range of problems
    efficiently.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你大部分的Verilog和VHDL代码将用于创建LUTs和触发器，这两者是FPGA中最基本的组件。然而，正如你在本章中所看到的，FPGA还包含其他原语组件，如块RAM、DSP块和PLL，它们增加了专用的功能。块RAM提供了专用内存，DSP块启用了高速并行数学运算，而PLL则允许你生成不同的内部时钟频率。通过这些FPGA构建模块的组合，你将能够高效地解决广泛的问题。
