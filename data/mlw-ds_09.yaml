- en: '**9**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: '**VISUALIZING MALWARE TRENDS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**恶意软件趋势的可视化**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Sometimes the best way to analyze malware collections is to visualize them.
    Visualizing security data allows us to quickly recognize trends in malware and
    within the threat landscape at large. These visualizations are often far more
    intuitive than nonvisual statistics, and they can help communicate insights to
    diverse audiences. For example, in this chapter, you see how visualization can
    help us identify the types of malware prevalent in a dataset, the trends within
    malware datasets (the emergence of ransomware as a trend in 2016, for example),
    and the relative efficacy of commercial antivirus systems at detecting malware.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，分析恶意软件集合的最佳方式就是可视化。可视化安全数据可以帮助我们快速识别恶意软件及整个威胁环境中的趋势。这些可视化图通常比非可视化统计数据更直观，并且可以帮助向不同的受众传达见解。例如，在本章中，你将看到如何通过可视化帮助我们识别数据集中流行的恶意软件类型、恶意软件数据集中的趋势（例如2016年勒索软件的出现）以及商业杀毒系统在检测恶意软件方面的相对有效性。
- en: Working through these examples, you come away understanding how to create your
    own visualizations that can lead to valuable insights by using the Python data
    analysis package `pandas`, as well as the Python data visualization packages `seaborn`
    and `matplotlib`. The `pandas` package is used mostly for loading and manipulating
    data and doesn’t have much to do with data visualization itself, but it’s very
    useful for preparing data for visualization.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些例子的讲解，你将明白如何使用Python数据分析包`pandas`，以及Python数据可视化包`seaborn`和`matplotlib`，创建你自己的可视化图表，这些图表能够通过数据分析提供有价值的见解。`pandas`包主要用于加载和处理数据，与数据可视化本身关系不大，但它对于为可视化准备数据非常有用。
- en: '**Why Visualizing Malware Data Is Important**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为什么可视化恶意软件数据很重要**'
- en: 'To see how visualizing malware data can be helpful, let’s go through two examples.
    The first visualization addresses the following question: is the antivirus industry’s
    ability to detect ransomware improving? The second visualization asks which malware
    types have trended over the period of a year. Let’s look at the first example
    shown in [Figure 9-1](ch09.xhtml#ch09fig1).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示可视化恶意软件数据如何有助于分析，让我们通过两个例子进行探讨。第一个可视化图解答了以下问题：杀毒行业检测勒索软件的能力是否在提升？第二个可视化图展示了在一年内哪些类型的恶意软件有所增加。我们来看第一个例子，如[图9-1](ch09.xhtml#ch09fig1)所示。
- en: '![image](../images/f0156-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0156-01.jpg)'
- en: '*Figure 9-1: Visualization of ransomware detections over time*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-1：勒索软件检测的时间可视化*'
- en: I created this ransomware visualization using data collected from thousands
    of ransomware malware samples. This data contains the results of running 57 separate
    antivirus engines against each file. Each circle represents a malware sample.
    The y-axis represents how many detections, or positives, each malware sample received
    from the antivirus engines when it was scanned. Keep in mind that while this y-axis
    stops at 60, the maximum count for a given scan is 57, the total number of scanners.
    The x-axis represents when each malware sample was first seen on the malware analysis
    site *[VirusTotal.com](http://VirusTotal.com)* and scanned.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用从成千上万的勒索软件样本收集的数据创建了这个勒索软件可视化图。这些数据包含了57个独立杀毒引擎对每个文件进行扫描的结果。每个圆圈代表一个恶意软件样本。纵轴表示每个恶意软件样本在扫描时从杀毒引擎接收到的检测次数，或者说是阳性结果。请记住，虽然纵轴的最大值为60，但给定扫描的最大检测次数是57，即扫描引擎的总数。横轴表示每个恶意软件样本首次出现在恶意软件分析网站*[VirusTotal.com](http://VirusTotal.com)*并被扫描的时间。
- en: In this plot, we can see the antivirus community’s ability to detect these malicious
    files started off relatively strong in June 2016, dipped around July 2016, and
    then steadily rose over the rest of the year. By the end of 2016, ransomware files
    were still missed by an average of about 25 percent of antivirus engines, so we
    can conclude that the security community remained somewhat weak at detecting these
    files during this time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，我们可以看到杀毒社区在2016年6月时对这些恶意文件的检测能力相对较强，但在2016年7月左右有所下降，随后在全年内逐步回升。到2016年底，勒索软件文件仍然有大约25%的概率未被杀毒引擎检测到，因此我们可以得出结论，安全社区在这一时期内对这些文件的检测能力仍然较弱。
- en: To extend this investigation, you could create a visualization that shows *which*
    antivirus engines are detecting ransomware and at what rate, and how they are
    improving over time. Or you could look at some other category of malware (for
    example, Trojan horses). Such plots are useful in deciding which antivirus engines
    to purchase, or deciding which kinds of malware you might want to design custom
    detection solutions for—perhaps to supplement a commercial antivirus detection
    system (for more on building custom detection systems, see [Chapter 8](ch08.xhtml#ch08)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展这项调查，你可以创建一个可视化，显示 *哪些* 杀毒引擎正在检测勒索软件及其检测率，以及它们随着时间的推移如何改进。或者你可以查看其他类别的恶意软件（例如木马）。这样的图表在决定购买哪些杀毒引擎，或者决定哪些类型的恶意软件可能需要设计定制的检测解决方案时非常有用——或许是为了补充商业杀毒检测系统（有关构建定制检测系统的更多信息，请参见
    [第 8 章](ch08.xhtml#ch08)）。
- en: Now let’s look at [Figure 9-2](ch09.xhtml#ch09fig2), which is another sample
    visualization, created using the same dataset used for [Figure 9-1](ch09.xhtml#ch09fig1).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 [图 9-2](ch09.xhtml#ch09fig2)，这是另一个样本可视化图，使用与 [图 9-1](ch09.xhtml#ch09fig1)
    相同的数据集生成。
- en: '![image](../images/f0157-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0157-01.jpg)'
- en: '*Figure 9-2: Visualization of per-family malware detections over time*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：按家族恶意软件检测的时间可视化*'
- en: '[Figure 9-2](ch09.xhtml#ch09fig2) shows the top 20 most common malware families
    and how frequently they occurred relative to one another over a 150-day period.
    The plot reveals some key insights: whereas the most popular malware family, Allaple.A,
    occurred consistently over the 150-day span, other malware families, like Nemucod.FG,
    were prevalent for shorter spans of time and then went silent. A plot like this,
    generated using malware detected on your own workplace’s network, can reveal helpful
    trends showing what types of malware are involved in attacks against your organization
    over time. Without the creation of a comparison figure such as this one, understanding
    and comparing the relative peaks and volumes of these malware types over time
    would be difficult and time consuming.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-2](ch09.xhtml#ch09fig2) 显示了在 150 天时间段内最常见的前 20 个恶意软件家族及其出现频率的相对关系。该图揭示了一些关键见解：虽然最流行的恶意软件家族
    Allaple.A 在 150 天内持续出现，其他恶意软件家族，如 Nemucod.FG，则在较短时间内盛行，随后沉寂。这类图表，可以使用在自己工作网络中检测到的恶意软件生成，能够揭示有助于了解随着时间推移，哪些类型的恶意软件在攻击组织时较为频繁。没有类似的对比图，理解并比较这些恶意软件类型在时间上的相对峰值和数量将会变得困难且耗时。'
- en: These two examples show how useful malware visualization can be. The rest of
    this chapter shows how to create your own visualizations. We start by discussing
    the sample dataset used in this chapter and then we use the `pandas` package to
    analyze the data. Finally, we use the `matplotlib` and `seaborn` packages to visualize
    the data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例展示了恶意软件可视化的实用性。本章的其余部分将展示如何创建你自己的可视化图。我们从讨论本章使用的示例数据集开始，然后使用 `pandas` 包来分析数据。最后，我们使用
    `matplotlib` 和 `seaborn` 包来可视化数据。
- en: '**Understanding Our Malware Dataset**'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**理解我们的恶意软件数据集**'
- en: 'The dataset we use contains data describing 37,000 unique malware binaries
    collected by VirusTotal, a malware detection aggregation service. Each binary
    is labeled with four fields: the number of antivirus engines (out of 57) that
    flagged the binary as malicious (I call this the number of *positives* associated
    with each sample), the size of each binary, the binary’s *type* (bitcoin miner,
    keylogger, ransomware, trojan, or worm), and the date on which the binary was
    first seen. We’ll see that even with this fairly limited amount of metadata for
    each binary, we can analyze and visualize the data in ways that reveal important
    insights into the dataset.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的数据集包含了由病毒检测聚合服务 VirusTotal 收集的 37,000 个独特恶意软件二进制文件的数据。每个二进制文件都标注了四个字段：标记该二进制文件为恶意的杀毒引擎数量（从
    57 个引擎中筛选）（我将其称为每个样本的 *阳性* 数量）、每个二进制文件的大小、二进制文件的 *类型*（比特币矿工、键盘记录器、勒索软件、木马或蠕虫）、以及该二进制文件首次出现的日期。我们将看到，即使每个二进制文件的元数据相对有限，我们仍然可以以一种揭示数据集重要见解的方式分析和可视化数据。
- en: '***Loading Data into pandas***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将数据加载到 pandas 中***'
- en: The popular Python data analysis library `pandas` makes it easy to load data
    into analysis objects called `DataFrame`s, and then provides methods to slice,
    transform, and analyze that repackaged data. We use `pandas` to load and analyze
    our data and prep it for easy visualization. Let’s use [Listing 9-1](ch09.xhtml#ch09list1)
    to define and load some sample data into the Python interpreter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的Python数据分析库`pandas`使得将数据加载到名为`DataFrame`的分析对象中变得容易，然后提供方法来切片、转换和分析这些重新包装的数据。我们使用`pandas`来加载和分析数据，并为轻松可视化做准备。我们可以使用[示例
    9-1](ch09.xhtml#ch09list1)来定义并将一些示例数据加载到Python解释器中。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 9-1: Loading data into* pandas *directly*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-1：直接将数据加载到* pandas*'
- en: Here we define some data, which we call `example_data`, as a list of Python
    dictionaries ➊. Once we have created this list of `dicts`, we pass it to the `DataFrame`
    constructor ➋ to get the corresponding `pandas` `DataFrame`. Each of these `dicts`
    becomes a row in the resulting `DataFrame`. The keys in the `dicts` (`column1`
    and `column2`) become columns. This is one way to load data into `pandas` directly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义一些数据，称之为`example_data`，它是一个Python字典的列表 ➊。创建了这个`dicts`列表后，我们将它传递给`DataFrame`构造函数
    ➋，从而得到相应的`pandas` `DataFrame`。这些`dicts`中的每一个都成为生成的`DataFrame`中的一行。字典中的键（`column1`和`column2`）变成列。这是将数据直接加载到`pandas`的一种方式。
- en: You can also load data from external CSV files. Let’s use the code in [Listing
    9-2](ch09.xhtml#ch09list2) to load this chapter’s dataset (available on the virtual
    machine or in the data and code archive that accompany this book).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从外部CSV文件加载数据。我们使用[示例 9-2](ch09.xhtml#ch09list2)中的代码来加载本章的数据集（可在虚拟机上或本书随附的数据和代码归档中找到）。
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 9-2: Loading data into* pandas *from an external CSV file*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-2：从外部CSV文件加载数据到* pandas*'
- en: 'When you import *malware_data.csv*, the resulting `malware` object should look
    something like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入*malware_data.csv*时，生成的`malware`对象应类似于下方所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We now have a `pandas` `DataFrame` composed of our malware dataset. It has
    four columns: `positives` (the number of antivirus detections out of 57 antivirus
    engines for that sample), `size` (the number of bytes that malware binary takes
    up on disk), `type` (the type of malware, such as Trojan horse, worm, and so on),
    and `fs_bucket` (the date on which this malware was first seen).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个由我们的恶意软件数据集组成的`pandas` `DataFrame`。它有四列：`positives`（该样本在57个杀毒引擎中检测到的病毒数），`size`（恶意软件二进制文件在磁盘上占用的字节数），`type`（恶意软件的类型，如木马、蠕虫等），以及`fs_bucket`（首次出现该恶意软件的日期）。
- en: '***Working with a pandas DataFrame***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***与pandas DataFrame一起工作***'
- en: Now that we have our data in a `pandas` `DataFrame`, let’s look at how to access
    and manipulate it by calling the `describe()` method, as shown in [Listing 9-3](ch09.xhtml#ch09list3).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了`pandas` `DataFrame`中的数据，让我们看看如何通过调用`describe()`方法来访问和操作这些数据，如[示例 9-3](ch09.xhtml#ch09list3)所示。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 9-3: Calling the* describe() *method*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-3：调用* describe() *方法*'
- en: As shown in [Listing 9-3](ch09.xhtml#ch09list3), calling the `describe()` method
    shows some useful statistics about our `DataFrame`. The first line, `count`, counts
    the total number of non-null `positives` rows, and the total number of non-null
    rows. The second line gives the `mean`, or average number of positives per sample,
    and the mean size of the malware samples. Next comes the standard deviation for
    both `positives` and `size`, and the minimum value of each column in all the samples
    in the dataset. Finally, we see percentile values for each of the columns and
    the maximum value for the columns.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 9-3](ch09.xhtml#ch09list3)所示，调用`describe()`方法可以显示关于我们的`DataFrame`的一些有用统计信息。第一行，`count`，统计非空`positives`行的总数，以及非空行的总数。第二行给出了`mean`，即每个样本的平均正检测数，以及恶意软件样本的平均大小。接下来是`positives`和`size`的标准差，以及数据集中每一列的最小值。最后，我们可以看到每一列的百分位值和每一列的最大值。
- en: Suppose we’d like to retrieve the data for one of the columns in the malware
    `DataFrame`, such as the `positives` column (to view the average number of detections
    each file has, for example, or plot a histogram showing the distribution of positives
    over the dataset). To do this, we simply write `malware['positives']`, which returns
    the `positives` column as a list of numbers, as shown in [Listing 9-4](ch09.xhtml#ch09list4).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要检索恶意软件`DataFrame`中的某一列数据，例如`positives`列（例如，查看每个文件的平均检测数，或绘制展示数据集中`positives`分布的直方图）。为此，我们只需要写`malware['positives']`，它将返回`positives`列的数字列表，如[示例
    9-4](ch09.xhtml#ch09list4)所示。
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 9-4: Returning the* positives *column*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-4：返回* positives *列*'
- en: After retrieving a column, we can compute statistics on it directly. For example,
    `malware['positives'].mean()` computes the mean of the column, `malware['positives'].max()`
    computes the maximum value, `malware['positives'].min()` computes the minimum
    value, and `malware['positives'].std()` computes the standard deviation. [Listing
    9-5](ch09.xhtml#ch09list5) shows examples of each.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索到一列数据后，我们可以直接对其进行统计计算。例如，`malware['positives'].mean()`计算该列的均值，`malware['positives'].max()`计算最大值，`malware['positives'].min()`计算最小值，`malware['positives'].std()`计算标准差。[清单
    9-5](ch09.xhtml#ch09list5)展示了每个操作的示例。
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 9-5: Calculating the mean, maximum, and minimum values and the standard
    deviation*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-5：计算均值、最大值、最小值和标准差*'
- en: We can also slice and dice the data to do more detailed analysis. For example,
    [Listing 9-6](ch09.xhtml#ch09list6) computes the mean positives for the trojan,
    bitcoin, and worm types of malware.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对数据进行切片处理，进行更详细的分析。例如，[清单 9-6](ch09.xhtml#ch09list6)计算了特洛伊木马、比特币和蠕虫类型恶意软件的均值检测率。
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 9-6: Calculating the average detection rates of different malwares*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-6：计算不同恶意软件的平均检测率*'
- en: 'We first select the rows of the `DataFrame` where `type` is set to `trojan`
    using the following notation: `malware[malware[''type''] == ''trojan'']`. To select
    the `positives` column of the resulting data and compute the mean, we extend this
    expression as follows: `malware[malware[''type''] == ''trojan''][''positives''].mean()`.
    [Listing 9-6](ch09.xhtml#ch09list6) yields an interesting result, which is that
    worms get detected more frequently than bitcoin mining and Trojan horse malware.
    Because 49.9 > 35.8 and 33.4, on average, malicious `worm` samples (49.9) are
    detected by more vendors than malicious `bitcoin` and `trojan` samples (35.8,
    33.4).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过以下表示法选择`DataFrame`中`type`为`trojan`的行：`malware[malware['type'] == 'trojan']`。为了选择结果数据的`positives`列并计算均值，我们将该表达式扩展为：`malware[malware['type']
    == 'trojan']['positives'].mean()`。[清单 9-6](ch09.xhtml#ch09list6)得出了一个有趣的结果，即蠕虫（worm）比比特币挖矿和特洛伊木马恶意软件的检测频率更高。因为49.9
    > 35.8和33.4，平均而言，恶意的`worm`样本（49.9）比恶意的`bitcoin`和`trojan`样本（35.8，33.4）更频繁地被多个厂商检测到。
- en: '***Filtering Data Using Conditions***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用条件筛选数据***'
- en: We can select a subset of the data using other conditions as well. For example,
    we can use “greater than” and “less than” style conditions on numerical data like
    malware file size to filter the data, and then compute statistics on the resulting
    subsets. This can be useful if we’re interested in finding out whether the effectiveness
    of the antivirus engines is related to file size. We can check this using the
    code in [Listing 9-7](ch09.xhtml#ch09list7).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用其他条件选择数据的子集。例如，我们可以对数字数据（如恶意软件文件大小）使用“大于”和“小于”样式的条件来筛选数据，然后对结果子集进行统计计算。如果我们有兴趣了解杀毒引擎的有效性是否与文件大小相关，这将非常有用。我们可以使用[清单
    9-7](ch09.xhtml#ch09list7)中的代码来检查这一点。
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 9-7: Filtering the results by malware file size*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-7：按恶意软件文件大小筛选结果*'
- en: 'Take the first line in the preceding code: first, we subset our `DataFrame`
    by only samples that have a size over one million (`malware[malware[''size'']
    > 1000000]`). Then we grab the `positives` column and calculate the mean (`[''positives''].mean()`),
    which is about 33.5\. As we do this for higher and higher file sizes, we see that
    the average number of detections for each group goes down. This means we’ve discovered
    that there is indeed a relationship between malware file size and the average
    number of antivirus engines that detect those malware samples, which is interesting
    and merits further investigation. We explore this visually next by using `matplotlib`
    and `seaborn`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以前面的代码中的第一行为例：首先，我们通过仅选择文件大小超过一百万的样本来对子集进行筛选（`malware[malware['size'] > 1000000]`）。然后，我们抓取`positives`列并计算均值（`['positives'].mean()`），结果大约是33.5。随着文件大小逐渐增大，我们看到每组的平均检测次数下降。这意味着我们发现了恶意软件文件大小和检测这些恶意软件样本的杀毒引擎平均数量之间确实存在关系，这一点很有趣，值得进一步研究。接下来，我们通过使用`matplotlib`和`seaborn`进行可视化分析。
- en: '**Using matplotlib to Visualize Data**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用matplotlib可视化数据**'
- en: 'The go-to library for Python data visualization is `matplotlib`; in fact, most
    other Python visualization libraries are essentially convenience wrappers around
    `matplotlib`. It’s easy to use `matplotlib` with `pandas`: we use `pandas` to
    get, slice, and dice the data we want to plot, and we use `matplotlib` to plot
    it. The most useful `matplotlib` function for our purposes is the `plot` function.
    [Figure 9-3](ch09.xhtml#ch09fig3) shows what the `plot` function can do.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python数据可视化的首选库是`matplotlib`；事实上，大多数其他Python可视化库本质上都是`matplotlib`的便捷封装。使用`pandas`与`matplotlib`非常方便：我们使用`pandas`来获取、切片和处理我们想要绘制的数据，然后使用`matplotlib`来绘制它。对我们而言，最有用的`matplotlib`函数是`plot`函数。[图
    9-3](ch09.xhtml#ch09fig3)展示了`plot`函数可以做什么。
- en: '![image](../images/f0162-01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0162-01.jpg)'
- en: '*Figure 9-3: A plot of malware samples’ sizes and the number of antivirus detections*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：恶意软件样本的大小与防病毒检测次数的图表*'
- en: Here, I plot the `positives` and `size` attributes of our malware dataset. An
    interesting result emerges, as foreshadowed by our discussion of `pandas` in the
    previous section. It shows that small files and very large files are rarely detected
    by most of the 57 antivirus engines that scanned these files. Files of middling
    size (around 10^(4.5)–10⁷) are detected by most engines, however. This may be
    because small files don’t contain enough information to allow engines to determine
    they are malicious, and big files are too slow to scan, causing many antivirus
    systems to punt on scanning them at all.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我绘制了我们的恶意软件数据集中的`positives`和`size`属性。一个有趣的结果出现了，正如我们在上一节中讨论`pandas`时所预示的那样。它显示小文件和非常大的文件很少被这57个扫描这些文件的防病毒引擎检测到。然而，中等大小的文件（大约在10^(4.5)–10⁷之间）却被大多数引擎检测到了。这可能是因为小文件不包含足够的信息，使得引擎无法判断它们是恶意的，而大文件扫描速度太慢，导致许多防病毒系统干脆放弃扫描它们。
- en: '***Plotting the Relationship Between Malware Size and Vendor Detections***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制恶意软件大小与供应商检测之间的关系***'
- en: Let’s walk through how to make the plot shown in [Figure 9-3](ch09.xhtml#ch09fig3)
    by using the code in [Listing 9-8](ch09.xhtml#ch09list8).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用[清单 9-8](ch09.xhtml#ch09list8)中的代码，演示如何生成[图 9-3](ch09.xhtml#ch09fig3)中所示的图表。
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 9-8: Visualizing data using the* plot() *function*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-8：使用* plot() *函数可视化数据*'
- en: As you can see, it doesn’t take much code to render this plot. Let’s walk through
    what each line does. First, we import ➊ the necessary libraries, including `pandas`
    and the `matplotlib` library’s `pyplot` module. Then we call the `read_csv` function
    ➋, which, as you learned earlier, loads our malware dataset into a `pandas DataFrame`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，渲染这个图表并不需要太多代码。让我们逐行分析每一行的功能。首先，我们导入 ➊ 所需的库，包括`pandas`和`matplotlib`库中的`pyplot`模块。然后我们调用`read_csv`函数
    ➋，正如你之前学到的，它将我们的恶意软件数据集加载到一个`pandas DataFrame`中。
- en: Next we call the `plot()` function. The first argument to the function is the
    malware `size` data ➌, and the next argument is the malware `positives` data ➍,
    or the number of positive detections for each malware sample. These arguments
    define the data that `matplotlib` will plot, with the first argument representing
    the data to be shown on the x-axis and the second representing the data to be
    shown on the y-axis. The next argument, `'bo'` ➎, tells `matplotlib` what color
    and shape to use to represent the data. Finally, we set `alpha`, or the transparency
    of the circles, to `0.1` ➏, so we can see how dense the data is within different
    regions of the plot, even when the circles completely overlap each other.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`plot()`函数。该函数的第一个参数是恶意软件的`size`数据 ➌，第二个参数是恶意软件的`positives`数据 ➍，即每个恶意软件样本的正检测次数。这些参数定义了`matplotlib`将要绘制的数据，第一个参数代表将在x轴上显示的数据，第二个参数代表将在y轴上显示的数据。下一个参数`'bo'`
    ➎，告诉`matplotlib`使用何种颜色和形状来表示数据。最后，我们将`alpha`（即圆圈的透明度）设置为`0.1` ➏，这样即使圆圈完全重叠，我们也能看到数据在图表不同区域的密度。
- en: '**NOTE**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* b *in* `bo` *stands for* blue*, and the* o *stands for* circle*, meaning
    that we’re telling* matplotlib *to plot blue circles to represent our data. Other
    colors you can try are green (*g*), red (*r*), cyan (*c*), magenta (*m*), yellow
    (*y*), black (*k*), and white (*w*). Other shapes you can try are a point (*.*),
    a single pixel per data point (*,*), a square (*s*), and a pentagon (*p*). For
    complete details, see the* matplotlib *documentation at* [http://matplotlib.org](http://matplotlib.org).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*`bo`中的* b *代表蓝色*，* o *代表圆形*，这意味着我们告诉* matplotlib *绘制蓝色圆圈来表示我们的数据。你还可以尝试其他颜色，例如绿色（*g*）、红色（*r*）、青色（*c*）、品红色（*m*）、黄色（*y*）、黑色（*k*）和白色（*w*）。你可以尝试的其他形状有点（*.*）、每个数据点一个像素（*
    ,*）、方形（*s*）和五边形（*p*）。有关完整细节，请参阅* matplotlib *文档：[http://matplotlib.org](http://matplotlib.org)。'
- en: After we call the `plot()` function, we set the scale of the x-axis to be logarithmic
    ➐. This means that we’ll be viewing the malware size data in terms of powers of
    10, making it easier to see the relationships between very small and very large
    files.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`plot()`函数后，我们将x轴的尺度设置为对数尺度 ➐。这意味着我们将以10的幂次方来查看恶意软件文件的大小数据，从而使得我们能够更容易地看到非常小的文件与非常大文件之间的关系。
- en: Now that we’ve plotted our data, we label our axes and title our plot. The x-axis
    represents the size of the malware file `("File size in bytes (log` `base-10)``")`,
    and the y-axis represents the number of detections `("Number of detections")`.
    Because there are 57 antivirus engines we’re analyzing, we set the y-axis scale
    to the range 0 to 57 at ➑. Finally, we call the `show()` function ➒ to display
    the plot. We could replace this call with `pyplot.savefig("myplot.png")` if we
    wanted to save the plot as an image instead.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经绘制了数据，接下来我们对坐标轴进行标注，并为图表命名。x轴代表恶意软件文件的大小`("文件大小（字节，log10 底数）")`，y轴代表检测次数`("检测次数")`。由于我们分析了57个杀毒引擎，因此我们将y轴的尺度设置为0到57的范围
    ➑。最后，我们调用`show()`函数 ➒来显示图表。如果我们想将图表保存为图像文件，可以将此调用替换为`pyplot.savefig("myplot.png")`。
- en: Now that we’ve gone through an initial example, let’s do another.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了一个初步示例，让我们再做一个。
- en: '***Plotting Ransomware Detection Rates***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制勒索病毒检测率***'
- en: This time, let’s try reproducing [Figure 9-1](ch09.xhtml#ch09fig1), the ransomware
    detection plot I showed at the beginning of this chapter. [Listing 9-9](ch09.xhtml#ch09list9)
    presents the entire code that plots our ransomware detections over time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，让我们尝试再现[图 9-1](ch09.xhtml#ch09fig1)，我在本章开头展示的勒索病毒检测图。[清单 9-9](ch09.xhtml#ch09list9)展示了绘制勒索病毒检测随时间变化的完整代码。
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 9-9: Plotting ransomware detection rates over time*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-9：绘制勒索病毒检测率随时间变化的图表*'
- en: 'Some of the code in [Listing 9-9](ch09.xhtml#ch09list9) should be familiar
    from what I’ve explained thus far, and some won’t be. Let’s walk through the code,
    line by line:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-9](ch09.xhtml#ch09list9)中的部分代码应该是我们到目前为止已经讲解过的内容，有些则不是。让我们逐行分析代码：'
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The helpful Python package `dateutil` enables you to easily parse dates from
    many different formats. We import `dateutil` because we’ll be parsing dates so
    we can visualize them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的Python包`dateutil`可以帮助你轻松地解析多种不同格式的日期。我们导入`dateutil`是因为我们需要解析日期，以便进行可视化展示。
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We also import the `matplotlib` library’s `pyplot` module as well as `pandas`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还导入了`matplotlib`库的`pyplot`模块以及`pandas`。
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These lines read in our dataset and create a filtered dataset called `ransomware`
    that contains only ransomware samples, because that’s the type of data we’re interested
    in plotting here.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码行读取我们的数据集，并创建一个名为`ransomware`的过滤数据集，里面仅包含勒索病毒样本，因为这正是我们这里要绘制的数据类型。
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These five lines of code mirror the code in [Listing 9-8](ch09.xhtml#ch09list8):
    they plot the data, title the plot, label its x- and y-axes, and then render everything
    to the screen (see [Figure 9-4](ch09.xhtml#ch09fig4)). Again, if we wanted to
    save this plot to disk, we could replace the `pyplot.show()` call with `pyplot.savefig("myplot.png")`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这五行代码与[清单 9-8](ch09.xhtml#ch09list8)中的代码相对应：它们绘制数据，给图表命名，标注x轴和y轴，然后将所有内容渲染到屏幕上（参见[图
    9-4](ch09.xhtml#ch09fig4)）。同样，如果我们想将图表保存到磁盘上，可以将`pyplot.show()`调用替换为`pyplot.savefig("myplot.png")`。
- en: '![image](../images/f0165-01.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0165-01.jpg)'
- en: '*Figure 9-4: Visualization of ransomware detections over time*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：勒索病毒检测随时间变化的可视化*'
- en: Let’s try one more plot using the `plot()` function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再使用`plot()`函数尝试绘制一个图表。
- en: '***Plotting Ransomware and Worm Detection Rates***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制勒索病毒和蠕虫病毒检测率***'
- en: This time, instead of just plotting ransomware detections over time, let’s also
    plot worm detections in the same graph. What becomes clear in [Figure 9-5](ch09.xhtml#ch09fig5)
    is that the antivirus industry is better at detecting worms (an older malware
    trend) than ransomware (a newer malware trend).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不仅绘制勒索病毒随时间变化的检测情况，还将在同一图表中绘制蠕虫检测情况。[图 9-5](ch09.xhtml#ch09fig5)清楚地显示出，抗病毒行业在检测蠕虫（较旧的恶意软件趋势）方面优于勒索病毒（较新的恶意软件趋势）。
- en: In this plot, we see how many antivirus engines detected malware samples (y-axis)
    over time (x-axis). Each red dot represents a `type="ransomware"` malware sample,
    whereas each blue dot represents a `type="worm"` sample. We can see that on average,
    more engines detect worm samples than ransomware samples. However, the number
    of engines detecting both samples has been trending slowly up over time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，我们看到的是每个时间点有多少个抗病毒引擎检测到恶意软件样本（纵轴），以及随时间变化的趋势（横轴）。每个红点代表一个`type="ransomware"`的恶意软件样本，而每个蓝点代表一个`type="worm"`的样本。我们可以看到，平均而言，更多的引擎检测到蠕虫样本，而非勒索病毒样本。然而，检测到这两种样本的引擎数量随时间缓慢上升。
- en: '![image](../images/f0166-01.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0166-01.jpg)'
- en: '*Figure 9-5: Visualization of ransomware and worm malware detections over time*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-5：勒索病毒和蠕虫恶意软件检测的可视化随时间变化*'
- en: '[Listing 9-10](ch09.xhtml#ch09list10) shows the code for making this plot.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-10](ch09.xhtml#ch09list10)显示了绘制此图表的代码。'
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 9-10: Plotting ransomware and worm detection rates over time*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-10：随时间变化绘制勒索病毒和蠕虫检测率*'
- en: 'Let’s walk through the code by looking at the first part of [Listing 9-10](ch09.xhtml#ch09list10):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看[列表 9-10](ch09.xhtml#ch09list10)的第一部分来逐步解析代码：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The code is similar to the previous example. The difference thus far is that
    we create the `worm` filtered version of our data ➊ using the same method with
    which we create the `ransomware` filtered data. Now let’s take a look at the rest
    of the code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的示例类似。到目前为止，唯一的区别是我们使用相同的方法创建了`worm`（蠕虫）过滤后的数据 ➊，与创建`ransomware`（勒索病毒）过滤后的数据的方式相同。现在，让我们来看看其余的代码：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The main difference between this code and [Listing 9-9](ch09.xhtml#ch09list9)
    is that we call the `plot()` function twice: once for the ransomware data using
    the `ro` selector ➊ to create red circles, and once more on the worm data using
    the `bo` selector ➋ to create blue circles for the worm data. Note that if we
    wanted to plot a third dataset, we could do this too. Also, unlike [Listing 9-9](ch09.xhtml#ch09list9),
    here, at ➌, we create a legend for our figure showing that the blue marks stand
    for worm malware and the red marks stand for ransomware. The parameter `framealpha`
    determines how translucent the background of the legend is (by setting it to 1,
    we make it completely opaque), and the parameter `markerscale` scales the size
    of the markers in the legend (in this case, by a factor of three).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与[列表 9-9](ch09.xhtml#ch09list9)的主要区别在于，我们调用了`plot()`函数两次：一次使用`ro`选择器 ➊ 为勒索病毒数据创建红色圆点，另一次使用`bo`选择器
    ➋ 为蠕虫数据创建蓝色圆点。请注意，如果我们想绘制第三个数据集，也可以这么做。另外，与[列表 9-9](ch09.xhtml#ch09list9)不同，在这里，➌我们为图例创建了一个标签，显示蓝色标记代表蠕虫恶意软件，红色标记代表勒索病毒。参数`framealpha`决定了图例背景的透明度（将其设置为1时，背景完全不透明），而参数`markerscale`则调整图例中标记的大小（在此例中，放大三倍）。
- en: In this section, you’ve learned how to make some simple plots in `matplotlib`.
    However, let’s be honest—they’re not gorgeous. In the next section, we’re going
    to use another plotting library that should allow us to give our plots a more
    professional look, and help us implement more complex visualizations quickly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你学会了如何在`matplotlib`中制作一些简单的图表。然而，说实话——它们并不美观。在下一节中，我们将使用另一个绘图库，它应该能帮助我们让图表看起来更专业，并且帮助我们更快地实现更复杂的可视化。
- en: '**Using seaborn to Visualize Data**'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 seaborn 可视化数据**'
- en: Now that we’ve discussed `pandas` and `matplotlib`, let’s move on to `seaborn`,
    which is a visualization library actually built on top of `matplotlib` but wrapped
    up in a slicker container. It includes built-in themes to style our graphics as
    well as premade higher-level functions that save time in performing more complicated
    analyses. These features make it simple and easy to produce sophisticated, beautiful
    plots.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了`pandas`和`matplotlib`，接下来让我们介绍`seaborn`，这是一个建立在`matplotlib`之上的可视化库，但它提供了更为简洁的封装。它包括内置的主题来美化我们的图形，以及预设的更高级函数，这些都能节省在进行复杂分析时的时间。这些特点使得生成复杂且美观的图表变得简单易行。
- en: To explore `seaborn`, let’s start by making a bar chart showing how many examples
    of each malware type we have in our dataset (see [Figure 9-6](ch09.xhtml#ch09fig6)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索`seaborn`，我们首先制作一个条形图，显示数据集中每种恶意软件类型的样本数量（见[图 9-6](ch09.xhtml#ch09fig6)）。
- en: '![image](../images/f0168-01.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0168-01.jpg)'
- en: '*Figure 9-6: Bar chart plot of the different kinds of malware in this chapter’s
    dataset*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-6：本章数据集中不同类型恶意软件的条形图*'
- en: '[Listing 9-11](ch09.xhtml#ch09list11) shows the code to make this plot.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-11](ch09.xhtml#ch09list11)展示了绘制该图的代码。'
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 9-11: Creating a bar chart of malware counts by type*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-11：根据恶意软件类型绘制恶意软件数量的条形图*'
- en: In this code, we first read in our data via `pandas.read_csv` ➊ and then use
    `seaborn`’s `countplot` function to create a barplot of the `type` column in our
    `DataFrame` ➋. Finally, we make the plot appear by calling `pyplot`’s `show()`
    method at ➌. Recall that `seaborn` wraps `matplotlib`, which means we need to
    ask `matplotlib` to display our `seaborn` figures. Now let’s move on to a more
    complex sample plot.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先通过`pandas.read_csv` ➊读取数据，然后使用`seaborn`的`countplot`函数创建一个显示`DataFrame`中`type`列的条形图
    ➋。最后，通过调用`pyplot`的`show()`方法在 ➌ 使图表显示出来。请记住，`seaborn`封装了`matplotlib`，这意味着我们需要请求`matplotlib`来显示我们的`seaborn`图形。接下来我们来看一个更复杂的示例图表。
- en: '***Plotting the Distribution of Antivirus Detections***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制杀毒软件检测分布图***'
- en: 'The premise for the following plot is as follows: suppose we want to understand
    the distribution (frequency) of antivirus detections across malware samples in
    our dataset to understand what percentage of malware is missed by most antivirus
    engines, and what percentage is detected by most engines. This information gives
    us a view of the efficacy of the commercial antivirus industry. We can do this
    by plotting a bar chart (a histogram) showing, for each number of detections,
    the proportion of malware samples that had that number of detections, as shown
    in [Figure 9-7](ch09.xhtml#ch09fig7).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表的前提是：假设我们想了解数据集中恶意软件样本的杀毒软件检测分布（频率），以便了解大多数杀毒引擎漏掉了多少恶意软件，哪些恶意软件被大多数引擎检测到。这些信息能帮助我们了解商业杀毒软件行业的有效性。我们可以通过绘制一个条形图（直方图）来实现，显示每个检测次数下，具有该检测次数的恶意软件样本所占的比例，如[图
    9-7](ch09.xhtml#ch09fig7)所示。
- en: '![image](../images/f0169-01.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0169-01.jpg)'
- en: '*Figure 9-7: Visualization of distribution of antivirus detections (positives)*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-7：杀毒软件检测（阳性）分布的可视化*'
- en: The x-axis of this figure represents categories of malware samples, sorted by
    how many out of 57 total antivirus engines detected them. If a sample was detected
    as malicious by 50 of 57 engines, it is placed at 50, if it was only detected
    by 10 engines out of 57, it goes in the 10 category. The height of each bar is
    proportional to how many total samples ended up in that category.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该图的x轴代表恶意软件样本的分类，按57个总杀毒引擎检测到的数量排序。如果一个样本被57个引擎中的50个检测为恶意，它就被放置在50的位置；如果它仅被57个引擎中的10个检测到，则放在10的位置。每个条形的高度与该类别中样本的总数成正比。
- en: 'The plot makes it clear that many malware samples are detected by most of our
    57 antivirus engines (shown by the big bump in frequencies in the upper-rightmost
    region of the plot) but also that a substantial minority of samples are detected
    by a small number of engines (shown in the leftmost region of the plot). We don’t
    show samples that were detected by fewer than five engines because of the methodology
    I used to construct this dataset: I define malware as samples that five or more
    antivirus engines detect. This plotted result, with substantial numbers of samples
    receiving just 5–30 detections, indicates that there is still significant disagreement
    between engines in malware detection. A sample that was detected as malware by
    10 out of 57 engines either indicates that 47 engines failed to detect it, or
    that 10 made a mistake and issued a false positive on a benign file. The latter
    possibility is very unlikely, because antivirus vendors’ products have very low
    false-positive rates: it’s much more likely that most engines missed these samples.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该图清楚地表明，许多恶意软件样本被我们57个防病毒引擎中的大多数检测到（在图表的右上方区域频率的大幅峰值所示），但也表明，少数样本只被少数几个引擎检测到（图表最左侧区域所示）。我们没有显示被少于五个引擎检测到的样本，这是因为我在构建该数据集时使用的方法：我将恶意软件定义为被五个或更多防病毒引擎检测到的样本。这个绘制结果表明，仍然存在防病毒引擎之间的显著分歧，许多样本仅被5-30个引擎检测到。这些样本中，有的在57个引擎中只被10个引擎检测到，这意味着要么47个引擎没有检测到它，要么10个引擎犯了错误，对一个无害文件发出了误报。后一种可能性非常小，因为防病毒厂商的产品具有非常低的误报率：更可能的是，大多数引擎没有检测到这些样本。
- en: Making this plot requires just a few lines of plotting code, as shown in [Listing
    9-12](ch09.xhtml#ch09list12).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个图只需要几行绘图代码，如[清单 9-12](ch09.xhtml#ch09list12)所示。
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 9-12: Plotting distribution of positives*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-12：绘制阳性检测结果的分布图*'
- en: The `seaborn` package has a built-in function to create distribution plots (histograms),
    and so all we’ve done is pass the `distplot` function the data we wanted to display,
    which is `malware['positives']` ➊. Then we use the axis object returned by `seaborn`
    to configure the plot title, x-axis label, and y-axis label to describe our plot
    ➋.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`seaborn`包内置了一个函数，用于创建分布图（直方图），因此我们所做的只是将我们想要显示的数据`malware[''positives'']`传递给`distplot`函数➊。然后，我们使用`seaborn`返回的轴对象来配置图表标题、x轴标签和y轴标签，以描述我们的图表➋。'
- en: 'Now let’s try a `seaborn` plot with two variables: the number of positive detections
    for malware (files with five or more detections) and their file sizes. We created
    this plot before with `matplotlib` in [Figure 9-3](ch09.xhtml#ch09fig3), but we
    can achieve a more attractive and informative result using `seaborn`’s `jointplot`
    function. The resulting plot, shown in [Figure 9-8](ch09.xhtml#ch09fig8), is richly
    informative but takes a bit of effort to understand at first, so let’s walk through
    it.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试一个包含两个变量的`seaborn`图：恶意软件的阳性检测次数（被五个或更多检测到的文件）及其文件大小。我们之前已经在[图9-3](ch09.xhtml#ch09fig3)中用`matplotlib`创建了这个图，但我们可以通过使用`seaborn`的`jointplot`函数，获得一个更具吸引力和信息量的结果。得到的图，如[图9-8](ch09.xhtml#ch09fig8)所示，信息丰富，但一开始可能有些难以理解，因此我们一步步来分析。
- en: This plot is similar to the histogram we made in [Figure 9-7](ch09.xhtml#ch09fig7),
    but instead of displaying the distribution of a single variable via bar heights,
    this plot shows the distributions of *two* variables (the size of a malware file,
    on the x-axis, and the number of detections, on the y-axis) via color intensity.
    The darker the region, the more data is in that region. For example, we can see
    that files most commonly have a size of about 10^(5.5) and a positives value of
    about 53\. The subplots on the top and right of the main plots show a smoothed
    version of the frequencies of the size and detections data, which reveal the distribution
    of detections (as we saw in the previous plot) and file sizes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图与我们在[图9-7](ch09.xhtml#ch09fig7)中制作的直方图类似，但它不是通过条形高度显示单一变量的分布，而是通过颜色强度显示*两个*变量的分布（恶意软件文件的大小在x轴上，检测数量在y轴上）。区域越暗，数据在该区域中的数量越多。例如，我们可以看到，文件最常见的大小约为10^(5.5)，阳性值约为53。主图上方和右侧的子图显示了大小和检测数据的平滑版本，揭示了检测（如我们在前一个图中看到的）和文件大小的分布。
- en: '![image](../images/f0171-01.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0171-01.jpg)'
- en: '*Figure 9-8: Visualization of the distribution of malware file sizes versus
    positive detections*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-8：恶意软件文件大小与阳性检测结果的分布可视化*'
- en: The center plot is the most interesting, because it shows the relationship between
    size and positives. Instead of showing individual data points, like in [Figure
    9-3](ch09.xhtml#ch09fig3) with `matplotlib`, it shows the overall trend in a way
    that’s much clearer. This shows that very large malware files (size 10⁶ and greater)
    are less commonly detected by antivirus engines, which tells us we might want
    to custom-build a solution that specializes in detecting such malware.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 中间的图最为有趣，因为它展示了文件大小与正面检测之间的关系。与[图 9-3](ch09.xhtml#ch09fig3)中使用`matplotlib`展示单个数据点不同，它以更清晰的方式显示了整体趋势。这表明，文件非常大的恶意软件（大小为10⁶及以上）较少被杀毒引擎检测到，这告诉我们可能需要定制一个专门检测这类恶意软件的解决方案。
- en: Creating this plot just requires one plotting call to `seaborn`, as shown in
    [Listing 9-13](ch09.xhtml#ch09list13).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个图只需要一次`seaborn`绘图调用，如[清单 9-13](ch09.xhtml#ch09list13)所示。
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 9-13: Plotting the distribution of malware file sizes vs. positive
    detections*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-13：绘制恶意软件文件大小与正面检测的分布图*'
- en: 'Here, we use `seaborn`’s `jointplot` function to create a joint distribution
    plot of the `positives` and `size` columns in our `DataFrame` ➊. Also, somewhat
    confusingly, for `seaborn`’s `jointplot` function, we have to call a different
    function than in [Listing 9-11](ch09.xhtml#ch09list11) to label our axes: the
    `set_axis_labels()` function ➋, whose first argument is the x-axis label and whose
    second argument is the y-axis label.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`seaborn`的`jointplot`函数来创建`positives`和`size`列的联合分布图 ➊。另外，有些令人困惑的是，对于`seaborn`的`jointplot`函数，我们必须调用与[清单
    9-11](ch09.xhtml#ch09list11)中不同的函数来标记坐标轴：`set_axis_labels()`函数 ➋，该函数的第一个参数是x轴标签，第二个参数是y轴标签。
- en: '***Creating a Violin Plot***'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建小提琴图***'
- en: The last plot type we explore in this chapter is the `seaborn` violin plot.
    This plot allows us to elegantly explore the distribution of a given variable
    across several malware types. For example, suppose we’re interested in seeing
    the distribution of file sizes per malware type in our dataset. In this case,
    we can create a plot like [Figure 9-9](ch09.xhtml#ch09fig9).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们探讨的最后一种图表类型是`seaborn`的小提琴图。该图可以帮助我们优雅地探索给定变量在多种恶意软件类型之间的分布。例如，假设我们对查看数据集中每种恶意软件类型的文件大小分布感兴趣。那么我们可以创建类似[图
    9-9](ch09.xhtml#ch09fig9)的图。
- en: '![image](../images/f0172-01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0172-01.jpg)'
- en: '*Figure 9-9: Visualization of file sizes by malware type*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-9：按恶意软件类型可视化文件大小*'
- en: On the y-axis of this plot are file sizes, represented as powers of 10\. On
    the x-axis we enumerate each malware type. As you can see, the thickness of the
    bars representing each file type varies at different size levels, which show how
    much of the data for that malware type is of that size. For example, you can see
    that there’s a substantial number of very large ransomware files, and that worms
    tend to have smaller file sizes—probably because worms aim to spread rapidly across
    a network, and worm authors thus tend to minimize their file sizes. Knowing these
    patterns could potentially help us to classify unknown files better (a larger
    file being more likely to be ransomware and less likely to be a worm), or teach
    us what file sizes we should focus on in a defensive tool targeted at a specific
    type of malware.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图的y轴上是文件大小，以10的幂表示。x轴上列出了每种恶意软件类型。如你所见，表示每种文件类型的条形宽度在不同大小级别上有所不同，显示了该恶意软件类型的数据中有多少是该大小。例如，你可以看到有大量非常大的勒索软件文件，而蠕虫的文件大小往往较小——这可能是因为蠕虫旨在快速传播到网络中，因此蠕虫的作者通常会将文件大小最小化。了解这些模式可能有助于我们更好地分类未知文件（较大的文件更可能是勒索软件，较小的文件则更可能是蠕虫），或者帮助我们了解在针对特定类型恶意软件的防御工具中，应该关注哪些文件大小。
- en: Making the violin plot takes one plotting call, as shown in [Listing 9-14](ch09.xhtml#ch09list14).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建小提琴图只需要一次绘图调用，如[清单 9-14](ch09.xhtml#ch09list14)所示。
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 9-14: Creating a violin plot*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-14：创建小提琴图*'
- en: In [Listing 9-14](ch09.xhtml#ch09list14), first we create the violin plot ➊.
    Next we tell `seaborn` to set the axis labels and title and to set the y-axis
    to log-scale ➋. Finally, we make the plot appear ➌. We can also make an analogous
    plot showing the number of positives for each malware type, as shown in [Figure
    9-10](ch09.xhtml#ch09fig10).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 9-14](ch09.xhtml#ch09list14)中，首先我们创建小提琴图 ➊。接着我们告诉`seaborn`设置坐标轴标签和标题，并将y轴设置为对数尺度
    ➋。最后，我们使图表显示出来 ➌。我们还可以绘制一个类似的图，显示每种恶意软件类型的正面检测数量，如[图 9-10](ch09.xhtml#ch09fig10)所示。
- en: '![image](../images/f0173-01.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0173-01.jpg)'
- en: '*Figure 9-10: Visualization of the number of antivirus positives (detections)
    per malware type*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-10：按恶意软件类型可视化杀毒软件检测到的数量（阳性结果）*'
- en: The only difference between [Figure 9-9](ch09.xhtml#ch09fig9) and [Figure 9-10](ch09.xhtml#ch09fig10)
    is that instead of looking at file size on the y-axis, we’re looking at the number
    of positives each file received. The results show some interesting trends. For
    example, ransomware is almost always detected by more than 30 scanners. The bitcoin,
    trojan, and keylogger malware types, in contrast, are detected by less than 30
    scanners a substantial portion of the time, meaning more of these types are slipping
    past the security industry’s defenses (folks who don’t have the scanners that
    detect these files installed are likely getting infected by these samples). [Listing
    9-15](ch09.xhtml#ch09list15) shows how to create the plot shown in [Figure 9-10](ch09.xhtml#ch09fig10).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-9](ch09.xhtml#ch09fig9)和[图 9-10](ch09.xhtml#ch09fig10)的唯一区别在于，我们不再查看y轴上的文件大小，而是查看每个文件收到的阳性结果数量。结果显示了一些有趣的趋势。例如，勒索软件几乎总是被30个以上的扫描器检测到。相比之下，比特币、木马和键盘记录器类型的恶意软件，常常在不到30个扫描器的情况下被检测到，这意味着这些恶意软件类型中的更多部分正悄悄突破安全行业的防线（没有安装能够检测这些文件的扫描器的用户，很可能会被这些样本感染）。[列表
    9-15](ch09.xhtml#ch09list15)展示了如何创建[图 9-10](ch09.xhtml#ch09fig10)中所示的图表。'
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 9-15: Visualizing antivirus detections per malware type*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-15：按恶意软件类型可视化杀毒软件检测*'
- en: The only differences in this code and the previous are that we pass the `violinplot`
    function different data (`malware['positives``']` instead of `malware['size']`),
    we label the axes differently, we set the title differently, and we omit setting
    the y-axis scale to log-10.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的唯一不同之处在于，我们传递给`violinplot`函数的数据不同（使用`malware['positives']`而不是`malware['size']`），我们对坐标轴的标签进行了不同的设置，标题也有所不同，并且我们省略了将y轴刻度设置为对数10的操作。
- en: '**Summary**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned how visualization of malware data allows you to
    get macroscopic insights into trending threats and the efficacy of security tools.
    You used `pandas`, `matplotlib`, and `seaborn` to create your own visualizations
    and gain insight into sample datasets.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何通过可视化恶意软件数据，帮助你获得关于趋势性威胁和安全工具效果的宏观洞察。你使用了`pandas`、`matplotlib`和`seaborn`来创建自己的可视化图表，并从样本数据集中获得洞察。
- en: You also learned how to use methods like `describe()` in `pandas` to show useful
    statistics and how to extract subsets of your dataset. You then used these subsets
    of data to create your own visualizations to assess improvements in antivirus
    detections, analyze trending malware types, and answer other broader questions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了如何使用`pandas`中的`describe()`方法来显示有用的统计信息，以及如何提取数据集的子集。接着，你利用这些数据子集创建了自己的可视化图表，以评估杀毒软件检测的改进情况，分析趋势性恶意软件类型，并回答其他更广泛的问题。
- en: These are powerful tools that transform the security data you have into actionable
    intelligence that can inform the development of new tools and techniques. I hope
    you’ll learn more about data visualizations and incorporate them into your malware
    and security analysis workflow.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是强大的工具，可以将你手头的安全数据转化为可操作的情报，帮助指导新工具和技术的开发。我希望你能更多地了解数据可视化，并将其融入到你的恶意软件和安全分析工作流程中。
