- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Bit Manipulation
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 比特操作
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Manipulating bits in memory is, perhaps, the feature for which assembly language
    is most famous. Even the C programming language, known for bit manipulation, doesn’t
    provide as complete a set of bit-manipulation operations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 操作内存中的比特，或许是汇编语言最著名的特性。即使是以比特操作著称的 C 语言，也没有提供如此完整的比特操作集。
- en: This chapter discusses how to manipulate strings of bits in memory and registers
    by using x86-64 assembly language. It begins with a review of the bit-manipulation
    instructions covered thus far, introduces a few new instructions, then reviews
    information on packing and unpacking bit strings in memory, which is the basis
    for many bit-manipulation operations. Finally, this chapter discusses several
    bit-centric algorithms and their implementation in assembly language.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论如何使用 x86-64 汇编语言在内存和寄存器中操作比特串。首先回顾至今为止涉及的比特操作指令，介绍一些新的指令，然后回顾内存中比特串的打包和解包信息，这是许多比特操作的基础。最后，本章讨论了几种以比特为核心的算法及其在汇编语言中的实现。
- en: 12.1 What Is Bit Data, Anyway?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 什么是比特数据？
- en: '*Bit manipulation* refers to working with *bit data*: data types that consist
    of strings of bits that are noncontiguous or not a multiple of 8 bits long. Generally,
    such bit objects will not represent numeric integers, although we will not place
    this restriction on our bit strings.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*比特操作* 是指处理 *比特数据*：由非连续或不是 8 比特倍数长度的比特串构成的数据类型。通常，这些比特对象不代表数值整数，尽管我们不会对我们的比特串施加这一限制。'
- en: A *bit string* is a contiguous sequence of 1 or more bits. It does not have
    to start or end at any special point. For example, a bit string could start in
    bit 7 of a byte in memory and continue through to bit 6 of the next byte in memory.
    Likewise, a bit string could begin in bit 30 of EAX, consume the upper 2 bits
    of EAX, and then continue from bit 0 through bit 17 of EBX. In memory, the bits
    must be physically contiguous (that is, the bit numbers are always increasing
    except when crossing a byte boundary, and at byte boundaries the memory address
    increases by 1 byte). In registers, if a bit string crosses a register boundary,
    the application defines the continuation register, but the bit string always continues
    in bit 0 of that second register.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*比特串* 是由一个或多个比特组成的连续序列。它不需要从任何特定的位置开始或结束。例如，一个比特串可以从内存中一个字节的第 7 个比特开始，并继续到下一个字节的第
    6 个比特。同样，比特串也可以从 EAX 的第 30 个比特开始，消耗 EAX 的上 2 个比特，然后从 EBX 的第 0 个比特继续，直到第 17 个比特。在内存中，比特必须是物理上连续的（即比特编号总是递增，除非跨越字节边界，而在字节边界，内存地址增加
    1 字节）。在寄存器中，如果比特串跨越寄存器边界，应用程序定义延续的寄存器，但比特串总是从第二个寄存器的第 0 个比特继续。'
- en: A *bit run* is a sequence of bits with all the same value. A *run of zeros*
    is a bit string that contains all 0s, and a *run of ones* is a bit string containing
    all 1s. The *first set bit* in a bit string is the bit position of the first bit
    containing a 1 in a bit string; that is, the first 1 bit following a possible
    run of zeros. A similar definition exists for the *first clear bit*. The *last
    set bit* is the last bit position in a bit string that contains 1s; the remainder
    of the string forms an uninterrupted run of zeros. A similar definition exists
    for the *last clear bit*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*比特串* 是由所有相同值的比特组成的序列。*零串* 是一个只包含0的比特串，而 *一串* 是一个只包含1的比特串。*首个设置的比特* 是比特串中第一个包含1的比特的位置；也就是说，紧随可能的零串后的第一个1比特。*首个清除的比特*
    也有类似的定义。*最后一个设置的比特* 是比特串中最后一个包含1的比特位置；其后的比特形成一个连续的零串。*最后一个清除的比特* 也有类似的定义。'
- en: A *bit set* is a collection of bits, not necessarily contiguous, within a larger
    data structure. For example, bits 0 to 3, 7, 12, 24, and 31 from a double word
    form a set of bits. Normally, we will deal with bit sets that are part of a *container
    object* (the data structure that encapsulates the bit set) no more than about
    32 or 64 bits in size, though this limit is completely artificial. Bit strings
    are special cases of bit sets.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*比特集* 是一个比特集合，未必是连续的，位于更大的数据结构中。例如，从双字中提取的比特 0 到 3、7、12、24 和 31 形成一个比特集。通常，我们将处理的比特集是
    *容器对象*（封装比特集的数据结构）的一部分，其大小通常不超过大约 32 或 64 比特，尽管这个限制是完全人为的。比特串是比特集的特例。'
- en: A *bit offset* is the number of bits from a boundary position (usually a byte
    boundary) to the specified bit. As noted in Chapter 2, we number the bits starting
    from 0 at the boundary location.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*位偏移*是从边界位置（通常是字节边界）到指定位的位数。如第二章所述，我们从边界位置的0开始编号位。
- en: A *mask* is a sequence of bits that we’ll use to manipulate certain bits in
    another value. For example, the bit string 0000_1111_0000b, when it’s used with
    the `and` instruction, masks away (clears) all the bits except bits 4 through
    7\. Likewise, if you use the same value with the `or` instruction, it can set
    bits 4 through 7 in the destination operand. The term *mask* comes from the use
    of these bit strings with the `and` instruction. In those situations, the 1 and
    0 bits behave like masking tape when you’re painting something; they pass through
    certain bits unchanged while masking out (clearing) the other bits.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*掩码*是一个位序列，我们用它来操作另一个值中的某些位。例如，位字符串0000_1111_0000b在与`and`指令配合使用时，会清除除了位4到7以外的所有位。同样，如果你将相同的值与`or`指令配合使用，它可以将目标操作数中的位4到7设置为1。*掩码*这个术语来源于这些位字符串与`and`指令的结合使用。在这些情况下，1和0位的作用就像你在涂漆时使用的遮蔽胶带；它们可以通过某些位而不改变它们，同时遮蔽（清除）其他位。
- en: Armed with these definitions, we’re ready to start manipulating some bits!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些定义后，我们已经准备好开始操作一些位了！
- en: 12.2 Instructions That Manipulate Bits
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 操作位的指令
- en: 'Bit manipulation generally consists of six activities: setting bits, clearing
    bits, inverting bits, testing and comparing bits, extracting bits from a bit string,
    and inserting bits into a bit string. The most basic bit-manipulation instructions
    are the `and`, `or`, `xor`, `not`, `test`, and shift and rotate instructions.
    The following paragraphs review these instructions, concentrating on how you could
    use them to manipulate bits in memory or registers.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 位操作通常包括六项活动：设置位、清除位、反转位、测试和比较位、从位字符串中提取位以及将位插入位字符串。最基本的位操作指令是`and`、`or`、`xor`、`not`、`test`以及移位和旋转指令。以下段落回顾了这些指令，重点讨论了如何使用它们来操作内存或寄存器中的位。
- en: 12.2.1 The and Instruction
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 `and`指令
- en: 'The `and` instruction provides the ability to replace unwanted bits in a bit
    sequence with 0s. This instruction is especially useful for isolating a bit string
    or a bit set that is merged with other, unrelated data (or, at least, data that
    is not part of the bit string or bit set). For example, suppose that a bit string
    consumes bit positions 12 through 24 of the EAX register; we can isolate this
    bit string by setting all other bits in EAX to 0 by using the following instruction
    (see [Figure 12-1](#figure12-1)):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`and`指令提供了用0替换位序列中不需要的位的功能。这条指令对于隔离与其他无关数据（或者至少是与位字符串或位集无关的数据）合并的位字符串或位集特别有用。例如，假设一个位字符串占用了EAX寄存器的12到24位；我们可以通过使用以下指令（见[图12-1](#figure12-1)）将EAX中的所有其他位清零，从而隔离这个位字符串：'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In theory, you could use the `or` instruction to mask all unwanted bits to 1s
    rather than 0s, but later comparisons and operations are often easier if the unneeded
    bit positions contain 0.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，你可以使用`or`指令将所有不需要的位掩码为1，而不是0，但如果不需要的位位置包含0，那么后续的比较和操作通常会更容易。
- en: '![f12001](image_fi/501089c12/f12001.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![f12001](image_fi/501089c12/f12001.png)'
- en: 'Figure 12-1: Isolating a bit string by using the `and` instruction'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-1：使用`and`指令隔离位字符串
- en: 'Once you’ve cleared the unneeded bits in a set of bits, you can often operate
    on the bit set in place. For example, to see if the string of bits in positions
    12 through 24 of EAX contains 12F3h, you could use the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你清除了位集中的不需要的位，你通常可以直接对位集进行操作。例如，要检查EAX中12到24位的位字符串是否包含12F3h，你可以使用以下代码：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s another solution, using constant expressions, that’s a little easier
    to digest:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用常量表达式的解决方案，它稍微容易理解一些：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To make the constants and other values you use in conjunction with this value
    easier to deal with, you can use the `shr` instruction to align the bit string
    with bit 0 after you’ve masked it, like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你在处理这个值时使用的常量和其他值更容易操作，你可以使用`shr`指令在掩码操作后，将位字符串与位0对齐，如下所示：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 12.2.2 The or Instruction
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 `or`指令
- en: 'The `or` instruction is especially useful for inserting a bit set into another
    bit string, using the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`or`指令特别有用，可以将一个位集插入到另一个位字符串中，使用以下步骤：'
- en: Clear all the bits surrounding your bit set in the source operand.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除源操作数中围绕位集的所有位。
- en: Clear all the bits in the destination operand where you wish to insert the bit
    set.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除目标操作数中你希望插入位集的所有位。
- en: OR the bit set and destination operand together.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将位集和目标操作数进行 `OR` 操作。
- en: 'For example, suppose you have a value in bits 0 to 12 of EAX that you wish
    to insert into bits 12 to 24 of EBX without affecting any of the other bits in
    EBX. You would begin by stripping out bits 13 and above from EAX; then you would
    strip out bits 12 to 24 in EBX. Next, you would shift the bits in EAX so the bit
    string occupies bits 12 to 24 of EAX. Finally, you would OR the value in EAX into
    EBX (see [Figure 12-2](#figure12-2)), as shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个值，它位于 EAX 的位 0 到 12 中，你希望将其插入到 EBX 的位 12 到 24 中，而不影响 EBX 中的其他位。你应该首先从
    EAX 中去掉位 13 及以上的位；然后从 EBX 中去掉位 12 到 24。接下来，你需要将 EAX 中的位进行移位，使得位串占据 EAX 中的位 12
    到 24。最后，你将 EAX 中的值通过 `OR` 操作插入到 EBX 中（见 [图 12-2](#figure12-2)），如图所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In [Figure 12-2](#figure12-2), the desired bits (AAAAAAAAAAAAA) form a bit string.
    However, this algorithm still works fine even if you’re manipulating a noncontiguous
    set of bits. All you have to do is to create a bit mask that has 1s in the appropriate
    places.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 12-2](#figure12-2) 中，所需的位（AAAAAAAAAAAAA）形成一个位串。然而，即使你在操作一个不连续的位集，这个算法依然能正常工作。你所需要做的就是创建一个在适当位置上有
    1 的位掩码。
- en: 'When you work with bit masks, it is incredibly poor programming style to use
    literal numeric constants as in the past few examples. You should always create
    symbolic constants in MASM. By combining these with some constant expressions,
    you can produce code that is much easier to read and maintain. The current example
    code is more properly written as the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用位掩码时，像前面几个例子那样使用字面数字常量是非常糟糕的编程风格。你应该始终在 MASM 中创建符号常量。通过将这些常量与一些常量表达式结合，你可以生成更易于阅读和维护的代码。当前的示例代码更合适的写法如下：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![f12002a](image_fi/501089c12/f12002a.png)![f12002b](image_fi/501089c12/f12002b.png)![f12002f](image_fi/501089c12/f12002f.png)![f12002d](image_fi/501089c12/f12002d.png)![f12002e](image_fi/501089c12/f12002e.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![f12002a](image_fi/501089c12/f12002a.png)![f12002b](image_fi/501089c12/f12002b.png)![f12002f](image_fi/501089c12/f12002f.png)![f12002d](image_fi/501089c12/f12002d.png)![f12002e](image_fi/501089c12/f12002e.png)'
- en: 'Figure 12-2: Inserting bits 0 to 12 of EAX into bits 12 to 24 of EBX'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-2：将 EAX 中的位 0 到 12 插入到 EBX 的位 12 到 24 中
- en: The use of the compile time `not` operator to invert the bit mask saves having
    to create another constant in the program that has to be changed anytime you modify
    the `BitMask` constant. Having to maintain two separate symbols whose values are
    dependent on one another is not a good thing in a program.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编译时 `not` 操作符来反转位掩码，可以避免每次修改 `BitMask` 常量时需要创建另一个常量。如果需要维护两个相互依赖的符号，这在程序中并不是一个好的做法。
- en: Of course, in addition to merging one bit set with another, the `or` instruction
    is also useful for forcing bits to 1 in a bit string. By setting various bits
    in a source operand to 1, you can force the corresponding bits in the destination
    operand to 1 by using the `or` instruction.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了将一个位集与另一个合并，`or` 指令还可以用于将位强制设置为 1。在源操作数中将某些位设置为 1，你可以通过使用 `or` 指令将目标操作数中的对应位强制设置为
    1。
- en: 12.2.3 The xor Instruction
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.3 `xor` 指令
- en: The `xor` instruction allows you to invert selected bits in a bit set. Of course,
    if you want to invert all the bits in a destination operand, the `not` instruction
    is more appropriate; however, if you want to invert selected bits while not affecting
    others, `xor` is the way to go.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`xor` 指令允许你反转位集中的选定位。当然，如果你想反转目标操作数中的所有位，`not` 指令更合适；但是，如果你只想反转选定的位而不影响其他位，`xor`
    是更好的选择。'
- en: One interesting fact about `xor`’s operation is that it lets you manipulate
    known data in just about any way imaginable. For example, if you know that a field
    contains 1010b, you can force that field to 0 by XORing it with 1010b. Similarly,
    you can force it to 1111b by XORing it with 0101b. Although this might seem like
    a waste, because you can easily force this 4-bit string to 0 or all 1s by using
    `and`/`or`, the `xor` instruction has two advantages. First, you are not limited
    to forcing the field to all 0s or all 1s; you can actually set these bits to any
    of the 16 valid combinations via `xor`. Second, if you need to manipulate other
    bits in the destination operand at the same time, `and`/`or` may not be able to
    do the job.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`xor`操作的一个有趣事实是，它让你可以以几乎任何想象得到的方式操作已知数据。例如，如果你知道某个字段包含1010b，你可以通过与1010b进行异或操作将该字段强制为0。类似地，你可以通过与0101b进行异或操作将其强制为1111b。虽然这看起来像是浪费，因为你可以很容易地使用`and`/`or`将这个4位字符串强制为0或全1，但`xor`指令有两个优点。首先，你不只限于将字段强制为全0或全1；你实际上可以通过`xor`将这些位设置为16种有效组合中的任何一种。其次，如果你需要同时操作目标操作数中的其他位，`and`/`or`可能无法完成这个任务。'
- en: For example, suppose you know that one field contains 1010b that you want to
    force to 0, and another field in the same operand contains 1000b and you wish
    to increment that field by 1 (that is, set the field to 1001b). You cannot accomplish
    both operations with a single `and` or `or` instruction, but you can with a single
    `xor` instruction; just XOR the first field with 1010b and the second field with
    `0001b`. Remember, however, that this trick works only if you know the current
    value of a bit set within the destination operand.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你知道某个字段包含1010b，你想将其强制为0，另一个字段在同一操作数中包含1000b，并且你希望将该字段加1（即将该字段设置为1001b）。你无法通过单个`and`或`or`指令完成这两个操作，但你可以通过单个`xor`指令来实现；只需将第一个字段与1010b进行异或操作，将第二个字段与`0001b`进行异或操作。然而，记住，这个技巧只有在你知道目标操作数中某个已设置的位的当前值时才有效。
- en: 12.2.4 Flag Modification by Logical Instructions
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.4 逻辑指令对标志的修改
- en: 'In addition to setting, clearing, and inverting bits in a destination operand,
    the `and`, `or`, and `xor` instructions also affect various condition codes in
    the FLAGS register. These instructions do the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在目标操作数中设置、清除和取反位外，`and`、`or`和`xor`指令还会影响FLAGS寄存器中的各种条件码。这些指令执行以下操作：
- en: Always clear the carry and overflow flags.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终清除进位标志和溢出标志。
- en: Set the sign flag if the result has a 1 in the HO bit. They clear it otherwise;
    that is, these instructions copy the HO bit of the result into the sign flag.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果结果的HO位为1，则设置符号标志；否则清除它；也就是说，这些指令将结果的HO位复制到符号标志中。
- en: Set or clear the zero flag if the result is zero or not zero, respectively.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果结果为零，则设置零标志；如果结果不为零，则清除零标志。
- en: Set the parity flag if there is an even number of set bits in the LO byte of
    the destination operand, and clear the parity flag if there is an odd number of
    set bits.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标操作数的LO字节中设置的位数是偶数，则设置奇偶校验标志；如果设置的位数是奇数，则清除奇偶校验标志。
- en: Because these instructions always clear the carry and overflow flags, you cannot
    expect the system to preserve the state of these two flags across the execution
    of these instructions. A common mistake in many assembly language programs is
    the assumption that these instructions do not affect the carry flag. Many people
    will execute an instruction that sets or clears the carry flag; execute an `and`,
    `or`, or `xor` instruction; and then attempt to test the state of the carry from
    the previous instruction. This simply will not work.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些指令总是清除进位标志和溢出标志，所以你不能期望系统在执行这些指令时保留这两个标志的状态。许多汇编语言程序中常见的错误是假设这些指令不会影响进位标志。许多人会执行一个设置或清除进位标志的指令；执行一个`and`、`or`或`xor`指令；然后尝试测试上一个指令中进位标志的状态。这是行不通的。
- en: One of the more interesting aspects to these instructions is that they copy
    the HO bit of their result into the sign flag. Therefore, you can easily test
    the HO bit by testing the sign flag (using `cmovs` and `cmovns`, `sets` and `setns`,
    or `js` and `jns` instructions). For this reason, many assembly language programmers
    will place an important Boolean variable in the HO bit of an operand so they can
    easily test the state of that variable by using the sign flag after a logical
    operation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的一个有趣方面是它们会将结果的高字节位（HO bit）复制到符号标志位中。因此，您可以通过测试符号标志来轻松测试高字节位（使用 `cmovs`
    和 `cmovns`、`sets` 和 `setns`，或 `js` 和 `jns` 指令）。因此，许多汇编语言程序员会将一个重要的布尔变量放在操作数的高字节位中，以便在逻辑操作后通过使用符号标志轻松测试该变量的状态。
- en: 12.2.4.1 The Parity Flag
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.4.1 奇偶标志
- en: '*Parity* is a simple error-detection scheme originally employed by telegraphs
    and other serial communication protocols. The idea was to count the number of
    set bits in a character and include an extra bit in the transmission to indicate
    whether that character contained an even or odd number of set bits. The receiving
    end of the transmission would also count the bits and verify that the extra *parity*
    bit indicated a successful transmission. The purpose of the parity flag is to
    help compute the value of this extra bit, though parity-checking has been taken
    over by hardware.^([1](#c12-footnote-1))'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*奇偶校验*是一种最初由电报和其他串行通信协议使用的简单错误检测方案。其思路是计算字符中已设置的位数，并在传输中包含一个额外的位来指示该字符包含偶数或奇数个已设置的位。接收端也会计算这些位并验证额外的*奇偶*位是否指示了传输成功。奇偶标志的目的是帮助计算这个额外的位，尽管奇偶校验已由硬件接管。^([1](#c12-footnote-1))'
- en: 'The x86-64 `and`, `or`, and `xor` instructions set the parity bit if the LO
    byte of their operand contains an even number of set bits. An important fact bears
    repeating here: the parity flag reflects only the number of set bits in the *LO
    byte* of the destination operand; it does not include the HO bytes in a word,
    double-word, or other-sized operand. The instruction set uses the LO byte only
    to compute the parity because communication programs that use parity are typically
    character-oriented transmission systems (better error-checking schemes could be
    used if you transmit more than 8 bits at a time).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 `and`、`or` 和 `xor` 指令会在其操作数的低字节（LO byte）包含偶数个已设置位时设置奇偶标志位。有一个重要的事实需要重申：奇偶标志位仅反映目标操作数的*低字节*中已设置位的数量；它不包括字、双字或其他大小操作数中的高字节（HO
    byte）。指令集仅使用低字节来计算奇偶性，因为使用奇偶校验的通信程序通常是面向字符的传输系统（如果一次传输超过8位，可以使用更好的错误检查方案）。
- en: 12.2.4.2 The Zero Flag
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.4.2 零标志
- en: The zero flag setting is one of the more important results produced by the `and`,
    `or`, and `xor` instructions. Indeed, programs reference this flag so often after
    the `and` instruction that Intel added a separate instruction, `test`, whose main
    purpose is to logically AND two results and set the flags without otherwise affecting
    either instruction operand.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 零标志的设置是 `and`、`or` 和 `xor` 指令产生的更重要的结果之一。实际上，程序在执行 `and` 指令后如此频繁地引用此标志，以至于 Intel
    添加了一个单独的指令 `test`，其主要目的是将两个结果进行逻辑与运算并设置标志，而不会对任何指令操作数产生其他影响。
- en: 'The zero flag has three main uses after the execution of an `and` or a `test`
    instruction: (1) checking to see if a particular bit in an operand is set, (2)
    checking to see if at least one of several bits in a bit set is 1, and (3) checking
    to see if an operand is 0\. Using (1) is actually a special case of (2), in which
    the bit set contains only a single bit. We’ll explore each of these uses in the
    following paragraphs.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 零标志在执行 `and` 或 `test` 指令后有三个主要用途：（1）检查操作数中某一特定位是否被设置，（2）检查多个位集中是否至少有一个位为 1，（3）检查操作数是否为
    0。使用（1）实际上是（2）的特例，其中位集仅包含一个位。我们将在接下来的段落中探讨这些用途。
- en: 'To test whether a particular bit is set in a given operand, use the `and` and
    `test` instructions for an operand with a constant value containing a single set
    bit you wish to test. This clears all the other bits in the operand, leaving a
    0 in the bit position under test if the operand contained a 0 in that bit position
    and a 1 if it contained a 1\. Because all of the other bits in the result are
    0, the entire result will be 0 if that particular bit is 0; the entire result
    will be nonzero if that bit position contains a 1\. The x86-64 reflects this status
    in the zero flag (Z = 1 indicates a 0 bit; Z = 0 indicates a 1 bit). The following
    instruction sequence demonstrates how to test if bit 4 is set in EAX:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试给定操作数中的特定位是否被设置，可以使用`and`和`test`指令与包含单一设置位的常量值进行操作。这会清除操作数中的所有其他位，如果操作数在该位位置包含0，则在该位置留下0，如果包含1，则留下1。因为结果中的其他所有位都是0，所以如果该特定位为0，则整个结果为0；如果该位为1，则整个结果为非零。x86-64反映了这一状态在零标志中（Z
    = 1表示该位为0；Z = 0表示该位为1）。以下指令序列演示了如何测试EAX中第4位是否被设置：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also use the `and` and `test` instructions to see if any one of several
    bits is set. Simply supply a constant that has a 1 in all the positions you want
    to test (and 0s everywhere else). ANDing an operand with such a constant will
    produce a nonzero value if one or more of the bits in the operand under test contain
    a 1\. The following example tests whether the value in EAX contains a 1 in bit
    positions 1, 2, 4, and 7:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`and`和`test`指令来查看是否有多个位中的任何一位被设置。只需提供一个常量，该常量在你想要测试的所有位置上是1（其他地方为0）。将操作数与这样的常量进行与运算，如果操作数中的任何位被设置为1，则会产生非零值。以下示例测试EAX中的值在第1、2、4和7位位置是否包含1：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You cannot use a single `and` or `test` instruction to see if all the corresponding
    bits in the bit set are equal to 1\. To accomplish this, you must first mask out
    the bits that are not in the set and then compare the result against the mask
    itself. If the result is equal to the mask, all the bits in the bit set contain
    1s. You must use the `and` instruction for this operation because the `test` instruction
    does not modify the result. The following example checks whether all the bits
    in a bit set (`bitMask`) are equal to 1:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能仅使用单一的`and`或`test`指令来检查位集中所有对应的位是否等于1。要实现这一点，你必须先屏蔽掉不在位集中的位，然后将结果与掩码本身进行比较。如果结果等于掩码，则位集中所有的位都包含1。你必须使用`and`指令来执行此操作，因为`test`指令不会修改结果。以下示例检查位集（`bitMask`）中的所有位是否等于1：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course, once we stick the `cmp` instruction in there, we don’t really have
    to check whether all the bits in the bit set contain 1s. We can check for any
    combination of values by specifying the appropriate value as the operand to the
    `cmp` instruction.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦我们加入`cmp`指令，就不需要真正检查位集中所有的位是否都是1了。我们可以通过将适当的值作为操作数传递给`cmp`指令，来检查任意组合的值。
- en: 'Note that the `test` and `and` instructions will set the zero flag in the preceding
    code sequences only if all the bits in EAX (or other destination operand) have
    0s in the positions where 1s appear in the constant operand. This suggests another
    way to check for all 1s in the bit set: invert the value in EAX prior to using
    the `and` or `test` instruction. Then if the zero flag is set, you know that there
    were all 1s in the (original) bit set. For example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`test`和`and`指令只有在EAX（或其他目标操作数）中的所有位在常量操作数中1出现的相应位置上都是0时，才会设置零标志。这提示了另一种检查位集中的所有1的方法：在使用`and`或`test`指令之前，将EAX中的值取反。然后，如果零标志被设置，则说明在（原始）位集中所有的位都是1。例如：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The previous paragraphs all suggest that the `bitMask` (the source operand)
    is a constant, but you can use a variable or other register too. Simply load that
    variable or register with the appropriate bit mask before you execute the `test`,
    `and`, or `cmp` instructions in the preceding examples.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的段落都暗示`bitMask`（源操作数）是一个常量，但你也可以使用变量或其他寄存器。只需在执行前面的`test`、`and`或`cmp`指令之前，先将该变量或寄存器加载适当的位掩码即可。
- en: 12.2.5 The Bit Test Instructions
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.5 位测试指令
- en: 'Another set of instructions we’ve already seen that we can use to manipulate
    bits is the *bit test instructions*. These instructions include `bt` (*bit test*),
    `bts` (*bit test and set*), `btc` (*bit test and complement*), and `btr` (*bit
    test and reset*). The `bt``x` instructions use the following syntax:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到的另一组可以用来操作位的指令是 *位测试指令*。这些指令包括 `bt`（*位测试*）、`bts`（*位测试并置位*）、`btc`（*位测试并补码*）和
    `btr`（*位测试并重置*）。`bt``x` 指令使用以下语法：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: where `x` is nothing, `c`, `s`, or `r`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `x` 代表无内容、`c`、`s` 或 `r`。
- en: The `bt``x` instructions’ second operand is a bit number that specifies which
    bit to check in the first operand. If the first operand is a register, the second
    operand must contain a value between 0 and the size of the register (in bits)
    minus 1; because the x86-64’s largest (general-purpose) registers are 64 bits,
    this value has the maximum value of 63 (for 64-bit registers). If the first operand
    is a memory location, the bit count is not limited to values in the range 0 to
    63\. If the second operand is a constant, it can be any 8-bit value in the range
    0 to 255\. If the second operand is a register, it has no (practical) limitation
    and, in fact, it allows negative bit offsets.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`bt``x` 指令的第二个操作数是一个位号，指定要检查的第一个操作数中的位。如果第一个操作数是寄存器，则第二个操作数必须包含一个值，该值在 0 到寄存器大小（以位为单位）减
    1 之间；因为 x86-64 的最大（通用）寄存器为 64 位，所以该值的最大值为 63（对于 64 位寄存器）。如果第一个操作数是内存位置，则位数不限制在
    0 到 63 的范围内。如果第二个操作数是常量，它可以是 0 到 255 之间的任何 8 位值。如果第二个操作数是寄存器，它没有（实际的）限制，实际上，它允许负的位偏移。'
- en: The `bt` instruction copies the specified bit from the second operand into the
    carry flag. For example, the `bt eax, 8` instruction copies bit 8 of the EAX register
    into the carry flag. You can test the carry flag after this instruction to determine
    whether bit 8 was set or clear in EAX.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`bt` 指令将指定的位从第二个操作数复制到进位标志中。例如，`bt eax, 8` 指令将 EAX 寄存器的第 8 位复制到进位标志中。你可以在该指令执行后测试进位标志，以确定
    EAX 中的第 8 位是被置位还是清零。'
- en: The `bts`, `btc`, and `btr` instructions manipulate the bit they test while
    they are testing it. These instructions may be slow (depending on the processor
    you’re using), and you should avoid them if performance is your primary concern,
    particularly if you’re using an older CPU. If performance (versus convenience)
    is an issue, you should always try two different algorithms—one that uses these
    instructions, and one that uses `and` and `or` instructions—and measure the performance
    difference; then choose the best of the two approaches.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`bts`、`btc` 和 `btr` 指令在测试位的同时也会操作该位。这些指令可能会比较慢（取决于你使用的处理器），如果性能是你的主要关注点，应该避免使用它们，尤其是当你使用旧的
    CPU 时。如果性能（与方便性相比）是一个问题，你应该始终尝试两种不同的算法——一种使用这些指令，另一种使用 `and` 和 `or` 指令——并测量性能差异；然后选择两者中最优的一种方法。'
- en: 12.2.6 Manipulating Bits with Shift and Rotate Instructions
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.6 使用移位和旋转指令操作位
- en: 'The *shift and rotate instructions* are another group of instructions you can
    use to manipulate and test bits. These instructions move the HO (left shift and
    rotate) or LO (right shift and rotate) bits into the carry flag. Therefore, you
    can test the carry flag after you execute one of these instructions to determine
    the original setting of the operand’s HO or LO bit; for example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*移位和旋转指令*是另一组可以用来操作和测试位的指令。这些指令将高位（左移和旋转）或低位（右移和旋转）移入进位标志中。因此，在执行这些指令后，你可以测试进位标志以确定操作数的高位或低位的原始设置；例如：'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The nice thing about the shift and rotate instructions is that they automatically
    move bits up or down in their operand so the next bit to test is in place; this
    is especially useful when operating within a loop.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 移位和旋转指令的一个优点是它们会自动将操作数中的位向上或向下移动，这样下一个要测试的位就位于正确的位置；这在循环中操作时尤其有用。
- en: The shift and rotate instructions are invaluable for aligning bit strings and
    packing and unpacking data. Chapter 2 has several examples of this, and some earlier
    examples in this chapter also use the shift instructions for this purpose.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 移位和旋转指令对于对齐位串以及打包和解包数据非常有用。第二章中有一些这方面的示例，本章的早些示例也使用了移位指令来实现此目的。
- en: 12.3 The Carry Flag as a Bit Accumulator
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 进位标志作为位累加器
- en: The `bt``x`, shift, and rotate instructions set or clear the carry flag depending
    on the operation and selected bit. Because these instructions place their “bit
    result” in the carry flag, it is often convenient to think of the carry flag as
    a 1-bit register or accumulator for bit operations. In this section, we will explore
    some of the operations possible with this bit result in the carry flag.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`bt``x`、移位和旋转指令根据操作和选定的位设置或清除进位标志。由于这些指令将“位结果”放入进位标志中，因此通常方便将进位标志视为位操作的1位寄存器或累加器。在本节中，我们将探索一些可能的操作，这些操作可以在进位标志中进行。'
- en: 'Instructions that use the carry flag as some sort of input value are useful
    for manipulating bit results in the carry flag. For example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用进位标志作为某种输入值的指令，对于操作进位标志中的位结果非常有用。例如：
- en: '`adc`, `sbb`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adc`, `sbb`'
- en: '`rcl`, `rcr`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rcl`, `rcr`'
- en: '`cmc`, `clc`, and `stc`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmc`, `clc`, 和 `stc`'
- en: '`cmovc`, `cmovnc`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmovc`, `cmovnc`'
- en: '`jc`, `jnc`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jc`, `jnc`'
- en: '`setc`, `setnc`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setc`, `setnc`'
- en: The `adc` and `sbb` instructions add or subtract their operands along with the
    carry flag, so if you’ve computed a bit result into the carry flag, you can figure
    that result into an addition or a subtraction by using these instructions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`adc`和`sbb`指令在加法或减法操作中加上或减去进位标志，因此，如果你已经将一个位结果计算到进位标志中，你可以通过使用这些指令将该结果计入加法或减法中。'
- en: To save a carry flag result, you can use the rotate-through-carry instructions
    (`rcl` and `rcr`), which move the carry flag into the LO or HO bits of their destination
    operand. These instructions are useful for packing a set of bit results into a
    byte, word, or double-word value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存进位标志结果，你可以使用旋转通过进位指令（`rcl`和`rcr`），将进位标志移入目标操作数的低位或高位。这些指令对于将一组位结果打包到字节、字或双字值中非常有用。
- en: The `cmc` (*complement carry*) instruction lets you easily invert the result
    of a bit operation. You can also use the `clc` and `stc` instructions to initialize
    the carry flag prior to a string of bit operations involving the carry flag.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmc`（*反向进位*）指令使你能够轻松地反转位操作的结果。你还可以使用`clc`和`stc`指令在涉及进位标志的一串位操作之前初始化进位标志。'
- en: Instructions that test the carry flag, like `jc`, `jnc`, `cmovc`, `cmovnc`,
    `setc`, and `setnc`, are useful after a calculation that leaves a bit result in
    the carry flag.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 测试进位标志的指令，如`jc`、`jnc`、`cmovc`、`cmovnc`、`setc`和`setnc`，在计算之后很有用，尤其是当结果保存在进位标志中时。
- en: If you have a sequence of bit calculations and would like to test whether those
    calculations produce a specific set of 1-bit results, you can clear a register
    or memory location and use the `rcl` or `rcr` instruction to shift each result
    into that location. Once the bit operations are complete, compare the register
    or memory location, holding the result against a constant value. If you want to
    test a sequence of results involving ANDs and ORs, you could use the `setc` and
    `setnc` instruction to set a register to 0 or 1 and then use the `and` and `or`
    instructions to merge the results.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一系列位运算，并且想要测试这些运算是否产生特定的一组1位结果，你可以清空一个寄存器或内存位置，然后使用`rcl`或`rcr`指令将每个结果移入该位置。一旦位操作完成，比较寄存器或内存位置中的结果与常数值。如果你想测试涉及与（AND）和或（OR）的结果序列，可以使用`setc`和`setnc`指令将寄存器设置为0或1，然后使用`and`和`or`指令合并结果。
- en: 12.4 Packing and Unpacking Bit Strings
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 打包和解包位串
- en: A common bit operation is inserting a bit string into an operand or extracting
    a bit string from an operand. Chapter 2 provided simple examples of packing and
    unpacking such data; now it is time to formally describe how to do this.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的位操作是将位串插入操作数中，或者从操作数中提取位串。第二章提供了打包和解包此类数据的简单示例；现在是时候正式描述如何执行这些操作了。
- en: For our purposes, I will assume that we’re dealing with bit strings that fit
    within a byte, word, double-word, or quad-word operand. Large bit strings that
    cross object boundaries require additional processing; we’ll discuss bit strings
    that cross quad-word boundaries later in this section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们而言，我将假设我们正在处理适合一个字节、字、双字或四字操作数的位串。跨越对象边界的大位串需要额外的处理；我们将在本节稍后讨论跨越四字边界的位串。
- en: When packing and unpacking a bit string, we must consider its starting bit position
    and length. The *starting bit position* is the bit number of the LO bit of the
    string in the larger operand. The *length* is the number of bits in the operand.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在打包和解包位串时，我们必须考虑其起始位位置和长度。*起始位位置*是该位串中最低有效位（LO位）在更大操作数中的位号。*长度*是操作数中的位数。
- en: To insert (pack) data into a destination operand, you start with a bit string
    of the appropriate length that is right-justified (starts in bit position 0) and
    zero-extended to 8, 16, 32, or 64 bits; then insert this data at the appropriate
    starting position in another operand that is 8, 16, 32, or 64 bits wide. There
    is no guarantee that the destination bit positions contain any particular value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据插入（打包）到目标操作数中，你首先需要一个右对齐的位串（即，从位位置 0 开始），并且该位串被零扩展到 8、16、32 或 64 位；然后将这些数据插入到另一个宽度为
    8、16、32 或 64 位的操作数的适当起始位置中。不能保证目标位位置包含任何特定的值。
- en: The first two steps (which can occur in any order) are to clear out the corresponding
    bits in the destination operand and to shift (a copy of) the bit string so that
    the LO bit begins at the appropriate bit position. The third step is to OR the
    shifted result with the destination operand. This inserts the bit string into
    the destination operand (see [Figure 12-3](#figure12-3)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前两步（可以按任意顺序执行）是清除目标操作数中的相应位，并将位串（的副本）进行移位，使得低位（LO位）从适当的位位置开始。第三步是将移位后的结果与目标操作数进行按位或（OR）运算。这将位串插入到目标操作数中（见[图
    12-3](#figure12-3)）。
- en: '![f12003a](image_fi/501089c12/f12003a.png)![f12003b](image_fi/501089c12/f12003b.png)![f12003f](image_fi/501089c12/f12003f.png)![f12003d](image_fi/501089c12/f12003d.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![f12003a](image_fi/501089c12/f12003a.png)![f12003b](image_fi/501089c12/f12003b.png)![f12003f](image_fi/501089c12/f12003f.png)![f12003d](image_fi/501089c12/f12003d.png)'
- en: 'Figure 12-3: Inserting a bit string into a destination operand'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-3：将位串插入到目标操作数中
- en: 'The following three instructions insert a bit string of known length into a
    destination operand, as shown in [Figure 12-3](#figure12-3). These instructions
    assume that the source operand is in BX and the destination operand is in AX:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三条指令将已知长度的位串插入到目标操作数中，如[图 12-3](#figure12-3)所示。这些指令假定源操作数在BX寄存器中，目标操作数在AX寄存器中：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the length and the starting position aren’t known when you’re writing the
    program (that is, you have to calculate them at runtime), then you can use a lookup
    table to insert a bit string. Let’s assume that we have two 8-bit values: a starting
    bit position for the field we’re inserting and a nonzero 8-bit length value. Also
    assume that the source operand is in EBX and the destination operand is in EAX.
    The `mergeBits` procedure in [Listing 12-1](#listing12-1) demonstrates how to
    do this.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在编写程序时无法知道长度和起始位置（即，必须在运行时计算它们），则可以使用查找表插入位串。假设我们有两个 8 位值：一个表示我们插入字段的起始位位置，另一个表示非零的
    8 位长度值。还假设源操作数在EBX寄存器中，目标操作数在EAX寄存器中。[列表 12-1](#listing12-1)中的`mergeBits`过程演示了如何做到这一点。
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 12-1: Inserting bits where the bit string length and starting position
    are variables'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-1：插入位串，其中位串长度和起始位置是变量
- en: 'Here’s the build command and output for the program in [Listing 12-1](#listing12-1).
    Because this program accesses arrays directly (rather than loading their addresses
    into registers, which obfuscates the code), this program must be built with the
    `LARGEADDRESSAWARE:NO` flag, hence the use of the *sbuild.bat* batch file (see
    the description of *sbuild.bat* in “Large Address Unaware Applications” in Chapter
    3):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[列表 12-1](#listing12-1)中程序的构建命令和输出。因为这个程序直接访问数组（而不是将数组的地址加载到寄存器中，这会使代码变得晦涩），所以这个程序必须使用`LARGEADDRESSAWARE:NO`标志进行构建，因此使用了*sbuild.bat*批处理文件（有关*sbuild.bat*的描述，请参见第3章中的“Large
    Address Unaware Applications”）。
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each entry in the `MaskByLen` table (in [Listing 12-1](#listing12-1)) contains
    the number of 1 bits specified by the index into the table. Using the `mergeBits`
    `Length` parameter value as an index into this table fetches a value that has
    as many 1 bits as the `Length` value. The `mergeBits` function fetches an appropriate
    mask, shifts it to the left so that the LO bit of this run of 1s matches the starting
    position of the field into which we want to insert the data, and then inverts
    the mask and uses the inverted value to clear the appropriate bits in the destination
    operand.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`MaskByLen`表中的每个条目（见[列表 12-1](#listing12-1)）包含由表索引指定的 1 位数值。通过使用`mergeBits`中的`Length`参数值作为索引，可以从此表中获取一个具有与`Length`值相同数量的
    1 位的值。`mergeBits`函数获取适当的掩码，将其向左移位，使得这一串 1 的低位（LO位）与我们要插入数据的字段的起始位置对齐，然后反转该掩码，并使用反转后的值清除目标操作数中的相应位。'
- en: 'To extract a bit string from a larger operand, all you have to do is mask out
    the unwanted bits and then shift the result until the LO bit of the bit string
    is in bit 0 of the destination operand. For example, to extract the 4-bit field
    starting at bit position 5 in EBX and leave the result in EAX, you could use the
    following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要从较大的操作数中提取比特串，你需要做的就是屏蔽掉不需要的位，然后将结果移动，直到比特串的最低位（LO位）位于目标操作数的第0位。例如，要从EBX中提取从第5位开始的4位字段，并将结果保存在EAX中，你可以使用以下代码：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you do not know the bit string’s length and starting position when you’re
    writing the program, you can still extract the desired bit string. The code is
    similar to insertion (though a little simpler). Assuming you have the `Length`
    and `Start` values we used when inserting a bit string, you can extract the corresponding
    bit string by using the following code (assuming source = EBX and dest = EAX):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在编写程序时不知道比特串的长度和起始位置，你仍然可以提取所需的比特串。代码类似于插入（虽然稍微简单一些）。假设你有我们在插入比特串时使用的`Length`和`Start`值，你可以通过以下代码提取相应的比特串（假设源操作数为EBX，目标操作数为EAX）：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The examples up to this point all assume that the bit string appears completely
    within a quad-word (or smaller) object. This will always be the case if the bit
    string is less than or equal to 64 bits in length. However, if the length of the
    bit string plus its starting position (modulo 8) within an object is greater than
    64, the bit string will cross a quad-word boundary within the object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的所有示例都假设比特串完全出现在一个四字（或更小）对象中。如果比特串的长度小于或等于64位，这种情况总是成立。然而，如果比特串的长度加上它在对象中起始位置的偏移量（模8）大于64，那么比特串将在对象内跨越一个四字边界。
- en: 'Extracting such bit strings requires up to three operations: one operation
    to extract the start of the bit string (up to the first quad-word boundary), an
    operation that copies whole quad words (assuming the bit string is so long that
    it consumes several quad words), and a final operation that copies leftover bits
    in the last quad word at the end of the bit string. The actual implementation
    of this operation is left as an exercise for you.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 提取这样的比特串需要最多三步操作：第一步操作提取比特串的起始位置（直到第一个四字边界），第二步操作复制整个四字（假设比特串的长度足够大，需要多个四字），最后一步操作复制位于比特串末尾的最后一个四字中的剩余位。该操作的实际实现留给你作为练习。
- en: 12.5 BMI1 Instructions to Extract Bits and Create Bit Masks
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 BMI1 指令用于提取位并创建位掩码
- en: 'If your CPU supports the BMI1 (*bit manipulation instructions, set 1*) instruction
    set extensions,^([2](#c12-footnote-2)) you can use the `bextr` (*bit extraction*)
    instruction to extract bits from a 32- or 64-bit general-purpose register. This
    instruction has the following syntax:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的CPU支持BMI1（*位操作指令集，第一集*）指令集扩展，^([2](#c12-footnote-2))你可以使用`bextr`（*位提取*）指令从32位或64位通用寄存器中提取比特。该指令的语法如下：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The operands must all be the same size and must be 32- or 64-bit registers (or
    memory locations).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数必须具有相同的大小，并且必须是32位或64位寄存器（或内存位置）。
- en: 'The `bextr` instruction encodes two parameters into `reg`ctrl:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`bextr`指令将两个参数编码到`reg`ctrl中：'
- en: Bits 0 to 7 of `reg`ctrl specify a starting bit position in the source operand
    (this must be a value in the range 0 to 31 for 32-bit operands and 0 to 63 for
    64-bit operands).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg`ctrl的第0到7位指定源操作数中的起始位位置（对于32位操作数，这必须是0到31之间的值，对于64位操作数，这必须是0到63之间的值）。'
- en: Bits 8 to 15 of `reg`ctrl specify the number of bits to extract from the source
    operand.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg`ctrl的第8到15位指定了要从源操作数中提取的位数。'
- en: The `bextr` instruction will extract the specified bits from `reg`src or `mem`src
    and store those bits (shifted down to bit 0) in `reg`dest. As a general rule,
    you should attempt to use RAX and EAX, RBX and EBX, RCX and ECX, or RDX and EDX
    as the `ctrl` register because you can easily manipulate the starting and length
    values by using the AH and AL, BH and BL, CH and CL, and DH and DL 8-bit registers.
    [Listing 12-2](#listing12-2) provides a quick demonstration of the `bextr` instruction.^([3](#c12-footnote-3))
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`bextr`指令将从`reg`src或`mem`src中提取指定的比特并将这些比特（移至第0位）存储在`reg`dest中。一般来说，你应该尽量使用RAX和EAX、RBX和EBX、RCX和ECX，或RDX和EDX作为`ctrl`寄存器，因为你可以通过使用AH和AL、BH和BL、CH和CL、DH和DL这四对8位寄存器来轻松操作起始值和长度值。[示例
    12-2](#listing12-2)提供了`bextr`指令的快速演示。^([3](#c12-footnote-3))'
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 12-2: `bextr` instruction example'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-2：`bextr`指令示例
- en: '[Listing 12-2](#listing12-2) produces the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-2](#listing12-2) 会产生以下输出：'
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The BMI1 instruction set extension also includes an instruction that extracts
    the lowest-numbered set bit in a register: `blsi` (*extract lowest set isolated
    bit*). The syntax for this instruction is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: BMI1 指令集扩展还包括一条提取寄存器中最低编号已设置位的指令：`blsi`（*提取最低已设置的孤立位*）。该指令的语法如下：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The operands must be the same size and can be either 32 or 64 bits. This instruction
    locates the lowest set bit in the source operand (register or memory). It copies
    that bit to the destination register and zeroes out all other bits in the destination.
    If the source value is 0, `blsi` copies 0 to the destination register and sets
    the zero and carry flags. [Listing 12-3](#listing12-3) is a simple demonstration
    of this instruction (note that I’ve eliminated the common code from [Listing 12-2](#listing12-2)).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作数必须大小相同，并且可以是 32 位或 64 位。此指令定位源操作数（寄存器或内存）中的最低已设置位。它将该位复制到目标寄存器，并将目标寄存器中的所有其他位清零。如果源值为
    0，`blsi` 会将 0 复制到目标寄存器，并设置零标志和进位标志。 [清单 12-3](#listing12-3) 是对该指令的简单演示（请注意，我已从
    [清单 12-2](#listing12-2) 中省略了公共代码）。
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 12-3: Simple demonstration of the `blsi` instruction'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-3：`blsi` 指令的简单演示
- en: 'Inserting this into a shell sample program and running it produces the following
    output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将其插入到一个示例程序壳中并运行，会产生以下输出：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The BMI1 `andn` instruction is useful in conjunction with `blsi`. The `andn`
    (*and not*) instruction has the following generic syntax:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: BMI1 `andn` 指令在与 `blsi` 配合使用时非常有用。`andn`（*与非*）指令具有以下通用语法：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The operands must all be the same size and must be 32 or 64 bits. This instruction
    logically ANDs an inverted copy of the value in `reg`src1 with the third operand
    (the `src2` operand) and stores the result into the `reg`dest operand.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作数必须大小相同，并且必须是 32 位或 64 位。此指令对 `reg`src1 中值的倒数副本与第三个操作数（`src2` 操作数）进行逻辑与运算，并将结果存储到
    `reg`dest 操作数中。
- en: You can use the `andn` instruction immediately after a `blsi` instruction to
    remove the lowest-numbered bit from `blsi`’s source operand after extracting it.
    [Listing 12-4](#listing12-4) demonstrates this operation (as usual, omitting the
    common code).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在执行 `blsi` 指令后立即使用 `andn` 指令，从 `blsi` 的源操作数中移除最低编号的位。 [清单 12-4](#listing12-4)
    演示了此操作（和往常一样，省略了公共代码）。
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 12-4: Extracting and removing the lowest set bit in an operand'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-4：提取并移除操作数中最低位的已设置位
- en: 'Running this code produces the following output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生以下输出：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Extracting the LO bit and keeping the remaining bits (as was done with the
    `blsi` and `andn` instructions in [Listing 12-4](#listing12-4)) are such a common
    operation that Intel created an instruction to specifically handle this task:
    `blsr` (*reset lowest set bit*). Here’s its generic syntax:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 提取 LO 位并保留其余位（如在 [清单 12-4](#listing12-4) 中使用 `blsi` 和 `andn` 指令所做的）是如此常见的操作，以至于英特尔创建了一条专门处理此任务的指令：`blsr`（*重置最低已设置位*）。以下是其通用语法：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Both operands must be the same size and must be either 32 or 64 bits. This instruction
    gets the data from the source operand, sets the lowest-numbered set bit to 0,
    and copies the result to the destination register. If the source operand contains
    0, this instruction copies 0 to the destination and sets the carry flag.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 两个操作数必须大小相同，并且必须是 32 位或 64 位。此指令从源操作数中获取数据，将最低编号的已设置位清零，并将结果复制到目标寄存器。如果源操作数包含
    0，此指令会将 0 复制到目标寄存器，并设置进位标志。
- en: '[Listing 12-5](#listing12-5) demonstrates the usage of this instruction.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-5](#listing12-5) 演示了此指令的使用方法。'
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 12-5: `blsr` instruction example'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-5：`blsr` 指令示例
- en: 'Here’s the output from this code fragment (after inserting it into a test program
    shell):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该代码片段的输出（插入到测试程序壳后）：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Another useful BMI1 instruction is `blsmsk`. This instruction creates a bit
    mask by searching for the lowest-numbered set bit. Then it creates a bit mask
    consisting of all 1 bits up to and including the lowest set bit. The `blsmsk`
    instruction sets the remaining bits to 0\. If the original value was 0, `blsmsk`
    sets all the bits in the destination register to 1 and sets the carry flag. Here’s
    the generic syntax for `blsmsk`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的 BMI1 指令是 `blsmsk`。此指令通过查找最低编号的已设置位来创建一个位掩码。然后，它创建一个包含所有 1 位直到并包括最低已设置位的位掩码。`blsmsk`
    指令将剩余位设置为 0。如果原始值为 0，`blsmsk` 会将目标寄存器中的所有位设置为 1，并设置进位标志。以下是 `blsmsk` 的通用语法：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Listing 12-6](#listing12-6) is a sample code fragment and the output it will
    produce.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-6](#listing12-6) 是一个示例代码片段及其将产生的输出。'
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 12-6: `blsmsk` example'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-6：`blsmsk` 示例
- en: 'Here is the sample output:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例输出：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Especially note that the mask the `blsmsk` instruction produces includes a 1
    bit in the bit position holding the lowest-numbered set bit in the source file.
    Often, you will actually want a bit mask containing 1 bits up to, but not including,
    the lowest-numbered set bit. This is easy to achieve using the `blsi` and `dec`
    instructions, as shown in [Listing 12-7](#listing12-7).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，`blsmsk` 指令生成的掩码在源文件中最低编号的已设置位所处的位置上包含一个 1 位。通常，你实际上会希望得到一个位掩码，其中 1 位位于最低编号的已设置位之前的所有位置。使用
    `blsi` 和 `dec` 指令可以轻松实现这一点，如[列表 12-7](#listing12-7)所示。
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 12-7: Creating a bit mask that doesn’t include the lowest-numbered
    set bit'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-7：创建一个不包含最低编号的已设置位的位掩码
- en: 'Here’s the output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The last of the BMI1 instructions is `tzcnt` (*trailing zero count*). This
    instruction has the following generic syntax:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: BMI1 指令集中的最后一条指令是 `tzcnt`（*尾随零计数*）。该指令具有以下通用语法：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As usual, the operands must both be the same size. The `tzcnt` instruction is
    unique among the BMI1 instructions insofar as it allows 16-, 32-, and 64-bit operands.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，操作数必须具有相同的大小。`tzcnt` 指令在 BMI1 指令中是独一无二的，因为它支持 16 位、32 位和 64 位操作数。
- en: The `tzcnt` instruction counts the number of LO 0 bits in the source (starting
    at the LO bit and working up toward the HO bit). It stores the 0 bit count into
    the destination register. Conveniently, the count of 0 bits is also the bit index
    of the first set bit in the source operand. This instruction sets the carry flag
    if the source operand is 0 (in which case it also sets the destination register
    to the size of the operands).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`tzcnt` 指令计算源操作数中从最低有效位开始向上数的零位数，并将零位计数存储到目标寄存器中。方便的是，零位的计数值也就是源操作数中第一个已设置位的位索引。如果源操作数为
    0，该指令将设置进位标志（此时它还会将目标寄存器设置为操作数的大小）。'
- en: To search for and extract 0 bits with `bextr`, `blsi`, `blsr`, and `blsmsk`,
    invert the source operand before executing these instructions. Likewise, to count
    the number of trailing set bits with `tzcnt`, first invert the source operand.^([4](#c12-footnote-4))
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `bextr`、`blsi`、`blsr` 和 `blsmsk` 查找并提取零位，在执行这些指令之前反转源操作数。同样，为了使用 `tzcnt`
    计算尾随已设置位的数量，首先要反转源操作数。^([4](#c12-footnote-4))
- en: If you use `bextr`, `blsi`, `blsr`, `blsmsk`, `tzcnt`, or `andn` in your program,
    don’t forget to test for the presence of the BMI1 instruction set extensions.
    Not all x86-64 CPUs support these instructions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在程序中使用了 `bextr`、`blsi`、`blsr`、`blsmsk`、`tzcnt` 或 `andn`，别忘了检查是否存在 BMI1 指令集扩展。并非所有
    x86-64 CPU 都支持这些指令。
- en: 12.6 Coalescing Bit Sets and Distributing Bit Strings
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.6 合并位集和分配位串
- en: Inserting and extracting bit sets are only a little different from inserting
    and extracting bit strings if the shape of the bit set you’re inserting (or resulting
    bit set you’re extracting) is the same as the shape of the bit set in the main
    object. The *shape* of a bit set is the distribution of the bits in the set, ignoring
    the starting bit position of the set. A bit set that includes bits 0, 4, 5, 6,
    and 7 has the same shape as that of a bit set that includes bits 12, 16, 17, 18,
    and 19 because the distribution of the bits is the same.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 插入和提取位集与插入和提取位串的区别不大，前提是你插入的位集（或提取的位集）的形状与主对象中位集的形状相同。位集的*形状*指的是位集中文本的分布，而不考虑位集的起始位置。例如，一个包含位
    0、4、5、6 和 7 的位集，其形状与包含位 12、16、17、18 和 19 的位集相同，因为这两个位集的分布是相同的。
- en: 'The code to insert or extract this bit set is nearly identical to that of the
    previous section; the only difference is the mask value you use. For example,
    to insert this bit set starting at bit 0 in EAX into the corresponding bit set
    starting at position 12 in EBX, you could use the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 插入或提取该位集的代码与上一节的代码几乎相同；唯一的不同是你使用的掩码值。例如，要将这个位集从 EAX 中的 0 位开始插入到 EBX 中从第 12 位开始的相应位集中，你可以使用以下代码：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, suppose you have 5 bits in bit positions 0 through 4 in EAX and want
    to merge them into bits 12, 16, 17, 18, and 19 in EBX. Somehow you have to distribute
    the bits in EAX prior to logically ORing the values into EBX. Given that this
    particular bit set is made of two runs of 1 bits, the process is somewhat simplified.
    The following code distributes the bits in a sneaky fashion:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设你在 EAX 中的 0 到 4 位上有 5 个已设置的位，并且你希望将它们合并到 EBX 中的第 12、16、17、18 和 19 位上。你必须以某种方式在对
    EBX 执行逻辑或运算之前，先分配这些位。考虑到这个特定的位集由两段 1 位组成，过程变得相对简化。以下代码以巧妙的方式分配这些位：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This trick with the `btr` (*bit test and reset*) instruction worked well because
    we had only 1 bit out of place in the original source operand. Alas, had the bits
    all been in the wrong location relative to one another, this scheme wouldn’t be
    an efficient solution. We’ll see a more general solution in just a moment.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`btr`（*位测试和重置*）指令的这个技巧效果很好，因为我们在原始源操作数中只有1个位的位置不对。可惜的是，如果这些位相对于彼此都处于错误的位置，那么这个方案就不是一个高效的解决方案。稍后我们会看到一个更通用的解决方案。
- en: 'Extracting this bit set and collecting (*coalescing*) the bits into a bit string
    is not quite as easy. However, we still have some sneaky tricks we can pull. Consider
    the following code that extracts the bit set from EBX and places the result into
    bits 0 to 4 of EAX:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 提取这个位集并将位合并到位串中并不像看起来那么容易。然而，我们仍然有一些巧妙的技巧可以使用。考虑以下代码，它从EBX中提取位集，并将结果放入EAX中的位0到4：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This code moves (original) bit 12 into bit position 7, the HO bit of AL. At
    the same time, it moves bits 16 to 19 down to bits 11 to 14 (bits 3 to 6 of AH).
    Then the code shifts bits 3 to 6 in AH down to bit 0\. This positions the HO bits
    of the bit set so that they are adjacent to the bit remaining in AL. Finally,
    the code shifts all the bits down to bit 0\. Again, this is not a general solution,
    but it shows a clever way to attack this problem if you think about it carefully.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将（原始）位12移到位位置7，即AL的HO位。同时，它将位16到19移到位11到14（即AH的位3到6）。然后，代码将AH中的位3到6移到位0。这会将位集的HO位定位，使其与AL中剩下的位相邻。最后，代码将所有位移到位0。再次强调，这并不是一个通用的解决方案，但它展示了如果仔细思考，这个问题的一个巧妙处理方式。
- en: 'The preceding coalescence and distribution algorithms apply only to their specific
    bit sets. A generalized solution (perhaps one that lets you specify a mask, then
    distributes or coalesces the bits accordingly) is going to be a bit more difficult.
    The following code demonstrates how to distribute the bits in a bit string according
    to the values in a bit mask:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的合并和分配算法仅适用于它们特定的位集。一个更通用的解决方案（可能是允许你指定一个掩码，然后根据该掩码分配或合并位的方案）会更为复杂。以下代码演示了如何根据位掩码中的值来分配位于位串中的位：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If we load EDX with 11001001b, this code will copy bits 0 to 3 to bits 0, 3,
    6, and 7 in EAX. Notice the short-circuit test that checks whether we’ve exhausted
    the values in EDX (by checking for a 0 in EDX). The rotate instructions do not
    affect the zero flag, but the shift instructions do. Hence, the preceding `shr`
    instruction will set the zero flag when there are no more bits to distribute (when
    EDX becomes 0).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将EDX加载为11001001b，代码将把位0到3的值复制到EAX中的位0、3、6和7中。注意短路测试，它检查是否已耗尽EDX中的值（通过检查EDX中的0）。旋转指令不影响零标志，但移位指令会。因此，之前的`shr`指令会在没有更多位可以分配时设置零标志（当EDX变为0时）。
- en: 'The general algorithm for coalescing bits is a tad more efficient than general
    distribution. Here’s the code that will extract bits from EBX via the bit mask
    in EDX and leave the result in EAX:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 合并位的通用算法比一般的分配算法稍微高效一些。以下是将位从EBX中提取出来，并通过EDX中的位掩码将结果保留在EAX中的代码：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This sequence also takes advantage of a sneaky trait of the shift and rotate
    instructions: the shift instructions affect the zero flag, whereas the rotate
    instructions do not. Therefore, the `shl edx, 1` instruction sets the zero flag
    when EDX becomes 0 (after the shift). If the carry flag was also set, the code
    will make one additional pass through the loop in order to shift a bit into EAX,
    but the next time the code shifts EDX 1 bit to the left, EDX is still 0 and so
    the carry will be clear. On this iteration, the code falls out of the loop.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程还利用了移位和旋转指令的一个巧妙特性：移位指令会影响零标志，而旋转指令则不会。因此，`shl edx, 1`指令在EDX变为0时会设置零标志（经过移位后）。如果进位标志也被设置，代码将再次遍历循环，直到将一个位移入EAX，但下一次代码将EDX左移1位时，EDX仍然为0，因此进位标志将被清除。在这一迭代中，代码将跳出循环。
- en: Another way to coalesce bits is via table lookup. By grabbing a byte of data
    at a time (so your tables don’t get too large), you can use that byte’s value
    as an index into a lookup table that coalesces all the bits down to bit 0\. Finally,
    you can merge the bits at the low end of each byte together. This might produce
    a more efficient coalescing algorithm in certain cases. The implementation is
    left to you.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种合并位的方法是通过查找表。通过一次获取一个字节的数据（这样你的表不会太大），你可以使用该字节的值作为查找表的索引，合并所有位直到位 0。最后，你可以将每个字节低位的位合并在一起。在某些情况下，这可能会产生一个更高效的合并算法。具体实现由你来决定。
- en: 12.7 Coalescing and Distributing Bit Strings Using BMI2 Instructions
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.7 使用 BMI2 指令合并和分配位字符串
- en: 'Intel’s BMI2 (*bit manipulation instructions, set 2*)^([5](#c12-footnote-5))
    instruction set extensions include a handy set of instructions you can use to
    insert or extract arbitrary bit sets: `pdep` (*parallel bits deposit*) and `pext`
    (*parallel bits extract*). If these instructions are available on your CPU, they
    can handle many of the tasks presented with non-BMI instructions in this chapter.
    They are powerful instructions indeed.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔的 BMI2（*位操作指令集，第二集*）^([5](#c12-footnote-5)) 指令集扩展包括一组便捷的指令，可以用来插入或提取任意的位集：`pdep`（*并行位存储*）和
    `pext`（*并行位提取*）。如果你的 CPU 支持这些指令，它们可以处理本章中许多使用非-BMI 指令的任务。它们确实是非常强大的指令。
- en: 'These instructions have the following syntax:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令具有以下语法：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: All operands must be the same size and must be 32 or 64 bits.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作数必须大小相同，并且必须为 32 位或 64 位。
- en: The `pext` instruction extracts an arbitrary bit string from the source (second)
    register and coalesces those bits to contiguous bit locations starting at bit
    0 in the destination register. The third operand, the mask, controls which bits
    `pext` extracts from the source.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`pext` 指令从源寄存器（第二个寄存器）提取任意的位字符串，并将这些位合并到目标寄存器中，从位 0 开始按连续的位位置排列。第三个操作数——掩码，控制着
    `pext` 从源寄存器提取哪些位。'
- en: The mask operand contains 1 bits in the bit positions that `pext` will extract
    from the source register. [Figure 12-4](#figure12-4) shows how this bit mask works.
    For each 1 bit in the mask operand, the `pext` instruction copies the corresponding
    bit in the source register to the next available bit position (starting from bit
    0) in the destination register.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 掩码操作数包含 `pext` 将从源寄存器提取的位位置上的 1 位。[图 12-4](#figure12-4) 显示了这个位掩码的工作原理。对于掩码操作数中的每一个
    1 位，`pext` 指令将源寄存器中对应的位复制到目标寄存器中下一个可用的位位置（从位 0 开始）。
- en: '![f12004](image_fi/501089c12/f12004.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![f12004](image_fi/501089c12/f12004.png)'
- en: 'Figure 12-4: Bit mask for `pext` instruction'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-4：`pext` 指令的位掩码
- en: '[Listing 12-8](#listing12-8) is a sample program fragment and the output it
    produces demonstrating the `pext` instruction (as usual, this listing eliminates
    the common code).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-8](#listing12-8) 是一个示例程序片段及其输出，展示了 `pext` 指令（与往常一样，此清单省略了常见代码）。'
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 12-8: `pext` instruction example'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-8：`pext` 指令示例
- en: The `pdep` instruction does the converse of `pext`. It takes the contiguous
    set of bits starting with the LO bit of the source register operand and distributes
    those bits throughout the destination register by using the 1 bits in the mask
    operand to determine placement, as shown in [Figure 12-5](#figure12-5). The `pdep`
    instruction sets all other bits in the destination register to 0.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdep` 指令执行与 `pext` 相反的操作。它从源寄存器操作数的低位（LO 位）开始，获取连续的位集，并通过使用掩码操作数中的 1 位来决定这些位在目标寄存器中的分布，如
    [图 12-5](#figure12-5) 所示。`pdep` 指令将目标寄存器中的所有其他位设置为 0。'
- en: '![f12005](image_fi/501089c12/f12005.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![f12005](image_fi/501089c12/f12005.png)'
- en: 'Figure 12-5: `pdep` instruction operation'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-5：`pdep` 指令操作
- en: '[Listing 12-9](#listing12-9) is an example of the `pdep` instruction and the
    output it produces.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-9](#listing12-9) 是 `pdep` 指令及其输出的示例。'
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 12-9: `pdep` instruction example'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-9：`pdep` 指令示例
- en: If you use the `pdep` or `pext` instructions in your program, don’t forget to
    test for the presence of the BMI2 instruction set extensions. Not all x86-64 CPUs
    support these instructions. See [Listing 11-2](c11.xhtml#listing11-2) in Chapter
    11 to see how to check for the presence of the BMI2 instruction set extensions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在程序中使用了 `pdep` 或 `pext` 指令，别忘了测试是否支持 BMI2 指令集扩展。并非所有 x86-64 CPU 都支持这些指令。请参见第
    11 章的 [清单 11-2](c11.xhtml#listing11-2)，查看如何检查是否支持 BMI2 指令集扩展。
- en: 12.8 Packed Arrays of Bit Strings
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.8 位字符串的打包数组
- en: Though far less efficient, it is quite possible to create arrays of elements
    whose size is not a multiple of 8 bits. The drawback is that calculating the “address”
    of an array element and manipulating that array element involves a lot of extra
    work. In this section, we’ll take a look at a few examples of packing and unpacking
    array elements in an array whose elements are an arbitrary number of bits long.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管效率低得多，但完全可以创建大小不是8位倍数的元素数组。缺点是，计算数组元素的“地址”并操作该数组元素需要额外的工作。在本节中，我们将通过一些示例来看一看如何打包和解包数组元素，这些元素是任意位数长度的。
- en: 'Why would you want arrays of bit objects? The answer is simple: space. If an
    object consumes only 3 bits, you can get 2.67 times as many elements into the
    same space if you pack the data rather than allocating a whole byte for each object.
    For very large arrays, this can be a substantial savings. Of course, the cost
    of this space savings is speed: you have to execute extra instructions to pack
    and unpack the data, thus slowing down access to the data.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你需要位对象数组？答案很简单：节省空间。如果一个对象只占3位，你可以通过打包数据，而不是为每个对象分配一个字节，将同样的空间装入2.67倍的元素。对于非常大的数组，这可以节省大量空间。当然，这种节省空间的代价是速度：你必须执行额外的指令来打包和解包数据，从而减慢对数据的访问速度。
- en: 'The calculation for locating the bit offset of an array element in a large
    block of bits is almost identical to the standard array access:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大块位中定位数组元素的位偏移量的计算几乎与标准数组访问相同：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once you calculate the element’s address in bits, you need to convert it to
    a byte address (because we have to use byte addresses when accessing memory) and
    extract the specified element. Because the base address of an array element (almost)
    always starts on a byte boundary, we can use the following equations to simplify
    this task:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你计算出元素的位地址，你需要将其转换为字节地址（因为我们在访问内存时必须使用字节地址），并提取指定的元素。由于数组元素的基地址（几乎）总是从字节边界开始，我们可以使用以下公式来简化这一任务：
- en: b
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: b
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For example, suppose we have an array of 200 three-bit objects that we declare
    as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个包含200个三位对象的数组，我们可以按如下方式声明：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The constant expression in the preceding dimension reserves space for enough
    bytes to hold 600 bits (200 elements, each 3 bits long). As the comment notes,
    the expression adds 2 extra bytes at the end to ensure we don’t lose any odd bits^([6](#c12-footnote-6))
    as well as to allow us to access 1 byte beyond the end of the array (when storing
    data to the array).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 前面维度中的常量表达式为足够的字节预留空间来存储600位（200个元素，每个元素3位）。正如注释所指出的，这个表达式在末尾添加了2个额外的字节，以确保我们不会丢失任何奇数位^([6](#c12-footnote-6))，并且允许我们访问数组末尾之后的1个字节（当向数组存储数据时）。
- en: 'Now suppose you want to access the *i*th 3-bit element of this array. You can
    extract these bits by using the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想访问这个数组的第*i*个三位元素。你可以通过以下代码提取这些位：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Inserting an element into the array is a bit more difficult. In addition to
    computing the base address and bit offset of the array element, you also have
    to create a mask to clear out the bits in the destination where you’re going to
    insert the new data. [Listing 12-10](#listing12-10) inserts the LO 3 bits of EAX
    into the *i*th element of the `AO3Bobjects` array.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个元素插入到数组中要稍微复杂一点。除了计算数组元素的基地址和位偏移量外，你还需要创建一个掩码来清除目标位置中你要插入新数据的位。[Listing 12-10](#listing12-10)将EAX的低3位插入到`AO3Bobjects`数组的第*i*个元素中。
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Listing 12-10: Storing the value 7 (111b) into an array of 3-bit elements'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-10：将值7（111b）存储到一个3位元素的数组中
- en: 'Inserting the code in [Listing 12-10](#listing12-10) into a shell assembly
    file produces the following output:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 将[Listing 12-10](#listing12-10)中的代码插入到Shell汇编文件中，产生以下输出：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `print` statement prints the first 32 bits of `AO3Bobjects`. Because each
    element is 3 bits, the array looks like
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`语句打印`AO3Bobjects`的前32位。由于每个元素是3位，所以数组看起来像这样：'
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: where bit 0 is the leftmost bit. Flipping the 32 bits around to make them more
    readable, and grouping them in blocks of 4 bits (to make it easy to convert to
    hexadecimal), we get
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 其中第0位是最左边的位。为了让它们更易读，我们将32位翻转过来，并按4位分组（方便转换为十六进制），得到：
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: which is 38000h.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是38000h。
- en: '[Listing 12-10](#listing12-10) uses a lookup table to generate the masks needed
    to clear out the appropriate position in the array. Each element of this array
    contains all 1s except for three 0s in the position we need to clear for a given
    bit offset (note the use of the `not` operator to invert the constants in the
    table).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 12-10](#listing12-10) 使用查找表生成清除数组中适当位置所需的掩码。该数组的每个元素包含所有 1，除了需要为给定位偏移清除的三个
    0（注意使用 `not` 运算符来反转表中的常量）。'
- en: 12.9 Searching for a Bit
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.9 搜索位
- en: A common bit operation is to locate the end of a run of bits. A special case
    of this operation is to locate the first (or last) set or clear the bit in a 16-,
    32-, or 64-bit value. In this section, we’ll explore ways to handle this special
    case.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的位操作是定位位序列的结束。这个操作的一个特例是定位 16 位、32 位或 64 位值中第一个（或最后一个）设置或清除的位。在本节中，我们将探讨处理这种特例的方法。
- en: The term *first set bit* means the first bit in a value, scanning from bit 0
    toward the high-order bit, which contains a 1\. A similar definition exists for
    the *first clear bit*. The *last set bit* is the first bit in a value, scanning
    from the high-order bit toward bit 0, which contains a 1\. A similar definition
    exists for the *last clear bit*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*第一个设置位* 指的是在一个值中，从位 0 向高位扫描时，第一个包含 1 的位。对于 *第一个清除位*，也有类似的定义。*最后一个设置位* 是在一个值中，从高位向位
    0 扫描时，第一个包含 1 的位。对于 *最后一个清除位*，也有类似的定义。'
- en: 'One obvious way to scan for the first or last bit is to use a shift instruction
    in a loop and count the number of iterations before you shift out a 1 (or 0) into
    the carry flag. The number of iterations specifies the position. Here’s some sample
    code that checks for the first set bit in EAX and returns that bit position in
    ECX:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索第一个或最后一个位的一种明显方法是使用循环中的移位指令，并计算在移出 1（或 0）到进位标志之前的迭代次数。迭代次数指定了该位置。以下是一些示例代码，用于检查
    EAX 中的第一个设置位，并将该位位置返回到 ECX：
- en: '[PRE51]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The only thing tricky about this code is that it runs the loop counter from
    –32 up to 0 rather than 32 down to 0\. This makes it slightly easier to calculate
    the bit position after the loop terminates.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码唯一复杂的地方是，它运行的循环计数器是从 -32 到 0，而不是从 32 到 0。这样，在循环结束后计算位位置就稍微容易一些。
- en: The drawback to this particular loop is that it’s expensive. This loop repeats
    as many as 32 times, depending on the original value in EAX. If the values you’re
    checking often have lots of 0s in the LO bits of EAX, this code runs rather slowly.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定循环的缺点是它的开销很大。根据 EAX 中的原始值，这个循环可能会重复最多 32 次。如果你检查的值在 EAX 的低位经常有很多 0，这段代码就会运行得比较慢。
- en: 'Searching for the first (or last) set bit is such a common operation that Intel
    added a couple of instructions specifically to accelerate this process. These
    instructions are `bsf` (*bit scan forward*) and `bsr` (*bit scan reverse*). Their
    syntax is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索第一个（或最后一个）设置位是一个非常常见的操作，因此 Intel 特意增加了几条指令来加速这一过程。这些指令是 `bsf` (*位扫描前进*) 和
    `bsr` (*位扫描反向*)。它们的语法如下：
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The source and destination operands must be the same size (16, 32, or 64 bits).
    The destination operand has to be a register. The source operand can be a register
    or a memory location.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 源操作数和目标操作数必须具有相同的大小（16 位、32 位或 64 位）。目标操作数必须是寄存器。源操作数可以是寄存器或内存位置。
- en: 'The `bsf` instruction scans for the first set bit (starting from bit position
    0) in the source operand. The `bsr` instruction scans for the last set bit in
    the source operand by scanning from the HO bit toward the LO bit. If these instructions
    find a bit that is set in the source operand, they clear the zero flag and put
    the bit position into the destination register. If the source register contains
    0 (that is, there are no set bits), then these instructions set the zero flag
    and leave an indeterminate value in the destination register. You should test
    the zero flag immediately after the execution of these instructions to validate
    the destination register’s value. Here’s an example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`bsf` 指令扫描源操作数中第一个被设置的位（从位位置 0 开始）。`bsr` 指令通过从高位向低位扫描，查找源操作数中的最后一个被设置的位。如果这些指令在源操作数中找到一个已设置的位，它们会清除零标志并将该位位置放入目标寄存器中。如果源寄存器包含
    0（即没有被设置的位），则这些指令会设置零标志，并在目标寄存器中留下一个不确定的值。你应该在这些指令执行后立即测试零标志，以验证目标寄存器的值。以下是一个示例：'
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You use the `bsr` instruction in an identical fashion except that it computes
    the bit position of the last set bit in an operand (the first set bit it finds
    when scanning from the HO bit toward the LO bit).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你以相同的方式使用 `bsr` 指令，唯一的区别是它计算操作数中最后一个设置位的位置（即从高位向低位扫描时找到的第一个设置位）。
- en: The x86-64 CPUs do not provide instructions to locate the first bit containing
    a 0\. However, you can easily scan for a 0 bit by first inverting the source operand
    (or a copy of the source operand if you must preserve the source operand’s value)
    and then searching for the first 1 bit; this corresponds to the first 0 bit in
    the original operand value.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 CPU 不提供定位第一个包含 0 的位的指令。然而，你可以通过先取反源操作数（如果必须保留源操作数的值，则取反其副本），然后搜索第一个 1
    位，来轻松扫描 0 位；这对应于原始操作数值中的第一个 0 位。
- en: The `bsf` and `bsr` instructions are complex x86-64 instructions and may be
    slower than others. In some circumstances, it may be faster to locate the first
    set bit by using discrete instructions. However, because the execution time of
    these instructions varies widely from CPU to CPU, you should test the performance
    of these instructions prior to using them in time-critical code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`bsf` 和 `bsr` 指令是复杂的 x86-64 指令，可能比其他指令更慢。在某些情况下，通过使用离散指令定位第一个设置的位可能会更快。但是，由于这些指令的执行时间因
    CPU 而异，因此你应该在将它们用于时间关键代码之前测试它们的性能。'
- en: 'Note that the `bsf` and `bsr` instructions do not affect the source operand.
    A common operation is to extract (and clear) the first or last set bit you find
    in an operand. If the source operand is in a register, you can use the `btr` (or
    `btc`) instruction to clear the bit after you’ve found it. Here’s some code that
    achieves this result:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`bsf` 和 `bsr` 指令不会影响源操作数。一种常见的操作是提取（并清除）操作数中找到的第一个或最后一个设置的位。如果源操作数在寄存器中，你可以在找到该位后使用
    `btr`（或 `btc`）指令清除该位。下面是实现这一结果的一些代码：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: At the end of this sequence, the zero flag indicates whether we found a bit
    (note that `btr` doesn’t affect the zero flag).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一序列的末尾，零标志指示我们是否找到了一位（注意，`btr` 不会影响零标志）。
- en: Because the `bsf` and `bsr` instructions support only 16-, 32-, and 64-bit operands,
    you will have to compute the first bit position of an 8-bit operand a little differently.
    There are a couple of reasonable approaches. First, you can zero-extend an 8-bit
    operand to 16 or 32 bits and then use the `bsf` or `bsr` instruction. Another
    alternative is to create a lookup table in which each entry contains the number
    of bits in the value you use as an index into the table; then you can use the
    `xlat` instruction to “compute” the first bit position in the value (you will
    have to handle the value 0 as a special case). Another solution is to use the
    shift algorithm appearing at the beginning of this section; for an 8-bit operand,
    this is not an entirely inefficient solution.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `bsf` 和 `bsr` 指令只支持 16 位、32 位和 64 位操作数，所以你需要稍微不同的方式来计算 8 位操作数的第一个位位置。有几种合理的做法。首先，你可以将
    8 位操作数零扩展到 16 位或 32 位，然后使用 `bsf` 或 `bsr` 指令。另一种选择是创建一个查找表，其中每个条目包含你用作索引的值的位数；然后，你可以使用
    `xlat` 指令来“计算”值中的第一个位位置（你需要将值 0 作为特殊情况处理）。另一种解决方案是使用本节开头出现的移位算法；对于 8 位操作数来说，这并非完全低效的解决方案。
- en: You can use `bsf` and `bsr` to determine the size of a run of bits, assuming
    that you have a single run of bits in your operand. Simply locate the first and
    last bits in the run (as in the previous example) and then compute the difference
    (plus 1) of the two values. Of course, this scheme is valid only if there are
    no intervening 0s between the first and last set bits in the value.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `bsf` 和 `bsr` 来确定一段位的大小，前提是操作数中只有一段连续的位。只需定位这一段中的第一个和最后一个位（如前面的例子所示），然后计算这两个值之间的差（加
    1）。当然，这种方案仅在第一个和最后一个设置位之间没有中断的 0 时有效。
- en: 12.10 Counting Bits
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.10 计数位
- en: 'The last example in the previous section demonstrates a specific case of a
    very general problem: counting bits. Unfortunately, that example has a severe
    limitation: it counts only a single run of 1 bits appearing in the source operand.
    This section discusses a more general solution to this problem.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中的最后一个例子展示了一个非常通用问题的特定案例：计数位。遗憾的是，这个例子有一个严重的限制：它只计算源操作数中出现的单一连续的 1 位。本节讨论了这个问题的更通用解决方案。
- en: 'Hardly a week goes by that someone doesn’t ask on one of the internet newsgroups
    how to count the number of bits in a register operand. This is a common request,
    undoubtedly because many assembly language course instructors assign this task
    as a project to their students as a way to teach them about the shift and rotate
    instructions, as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每周，总有人在互联网上的新闻组中询问如何计算寄存器操作数中的位数。这是一个常见的请求，毫无疑问，许多汇编语言课程的教师布置了这个任务，作为教学手段，目的是让学生了解移位和旋转指令，具体如下：
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The “trick” is that this code uses the `adc` instruction to add the value of
    the carry flag into the BL register. Because the count is going to be less than
    32, the result will fit comfortably into BL.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“技巧”是，这段代码使用`adc`指令将进位标志的值加到BL寄存器中。由于计数将小于32，结果会舒适地适应BL寄存器。
- en: Tricky code or not, this instruction sequence is not particularly fast. The
    preceding loop always executes 32 times, so this code sequence executes 130 instructions
    (four instructions per iteration plus two extra instructions).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 不管代码是否复杂，这条指令序列的执行速度都不算特别快。前面的循环总是执行32次，因此这段代码序列会执行130条指令（每次迭代4条指令，加上2条额外指令）。
- en: 'For a more efficient solution, use the `popcnt` instruction (*population count*,
    introduced in the SSE 4.1 instruction set), which counts the number of 1 bits
    in the source operand and stores the value into the destination operand:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率，可以使用`popcnt`指令（*人口计数*，在SSE 4.1指令集中引入），它计算源操作数中1位的数量，并将结果存储到目标操作数中：
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The operands must be the same size and must be 16, 32, or 64 bits.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数必须大小相同，并且必须是16位、32位或64位。
- en: 12.11 Reversing a Bit String
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.11 反转位串
- en: 'Another common programming project instructors assign, and a useful function
    in its own right, is a program that reverses the bits in an operand. This program
    swaps the LO bit with the HO bit, bit 1 with the next-to-HO bit, and so on. The
    typical solution an instructor expects is the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的编程项目是反转操作数中的位。这是一个独立有用的功能，也常被教学人员布置。这段程序将LO位与HO位交换，位1与次高位交换，依此类推。教学人员通常期待的解决方案如下：
- en: '[PRE57]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As with the previous examples, this code suffers from repeating the loop 32
    times, for a grand total of 129 instructions (for 32-bit operands, so double that
    for 64-bit operands). By unrolling the loop, you can get it down to 64 instructions,
    but this is still somewhat expensive.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 和前面的例子一样，这段代码存在重复执行32次循环的问题，总共执行了129条指令（对于32位操作数，64位操作数则需要翻倍）。通过展开循环，你可以将指令数减少到64条，但这依然有些昂贵。
- en: The best solution to an optimization problem is often using a better algorithm
    rather than attempting to tweak your code by trying to choose faster instructions
    to speed it up. In the preceding section, for example, we were able to speed up
    counting the bits in a string by substituting a more complex algorithm for the
    simplistic “shift and count” algorithm. In the preceding example, the trick is
    to do as much work as possible in parallel.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 优化问题的最佳解决方案通常是使用更好的算法，而不是试图通过选择更快的指令来调整代码。在前面的部分中，例如，我们通过替换更复杂的算法来加速位串计数，而不是使用简单的“移位计数”算法。在前面的示例中，关键是尽可能并行地进行大量工作。
- en: 'Suppose that all we wanted to do was swap the even and odd bits in a 32-bit
    value. We can easily swap the even and odd bits in EAX by using the following
    code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只需要交换32位值中偶数位和奇数位。我们可以通过以下代码轻松地在EAX中交换偶数位和奇数位：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Swapping the even and odd bits takes us part of the way to reversing all the
    bits in the number. After executing the preceding code sequence, you can swap
    adjacent pairs of bits to swap the bits in all the nibbles in the 32-bit value
    by using the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 交换偶数位和奇数位使我们能够部分地实现数字位的反转。在执行前面的代码序列后，你可以通过以下代码交换相邻的位对，来交换32位值中所有字节的位：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After completing the preceding sequence, you swap the adjacent nibbles in the
    32-bit register. Again, the only difference is the bit mask and the length of
    the shifts. Here’s the code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 完成前面的序列后，你会交换32位寄存器中的相邻字节。同样，唯一的区别是位掩码和移位的长度。以下是代码：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can probably see the pattern developing and can figure out that in the
    next two steps you have to swap the bytes and then the words in this object. You
    can use code like the preceding example, but there is a better way: use `bswap`.
    The `bswap` (*byte swap*) instruction uses the following syntax:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看出其中的模式，并且能推测出在接下来的两步中，你需要交换字节和字。你可以像前面的例子一样编写代码，但有一种更好的方法：使用`bswap`。`bswap`（*字节交换*）指令使用以下语法：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `bswap` instruction swaps bytes 0 and 3 and bytes 1 and 2 in the specified
    32-bit register, exactly what you want when reversing bits (and when converting
    data between little-endian and big-endian data formats, the principal use of this
    instruction). Rather than sticking in another 12 instructions to swap the bytes
    and then the words, you can simply use a `bswap eax` instruction to complete the
    job after the preceding instructions. The final code sequence is shown here:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`bswap`指令交换指定32位寄存器中字节0和字节3，以及字节1和字节2，这正是反转比特时所需要的操作（以及在将数据在小端和大端数据格式之间转换时，这条指令的主要用途）。你可以直接使用`bswap
    eax`指令来完成工作，而无需再插入12条指令交换字节和字。在以下代码序列中展示了最终结果：'
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This algorithm requires only 19 instructions and executes much faster than does
    the bit-shifting loop appearing earlier. Of course, this sequence does consume
    a little more memory. If you’re trying to save memory rather than clock cycles,
    the loop is probably a better solution.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法只需要19条指令，并且比之前的比特移位循环执行得更快。当然，这个序列的内存消耗略高。如果你更倾向于节省内存而非时钟周期，那么循环可能是一个更好的解决方案。
- en: 12.12 Merging Bit Strings
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.12 合并比特串
- en: 'Another common bit string operation is producing a single bit string by merging,
    or interleaving, bits from two different sources. The following example code sequence
    creates a 32-bit string by merging alternate bits from two 16-bit strings:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的比特串操作是通过合并或交错来自两个不同源的比特，生成一个单一的比特串。以下示例代码序列通过合并两个16位比特串中的交替比特，创建了一个32位比特串：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This particular example merges two 16-bit values together, alternating their
    bits in the result value. For a faster implementation of this code, unroll the
    loop to eliminate half the instructions.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的例子将两个16位值合并在一起，交替地将它们的比特插入到结果值中。为了更快地实现此代码，可以展开循环以减少一半指令的使用。
- en: 'With a few slight modifications, we can merge four 8-bit values together, or
    merge other bit sets from the source strings. For example, the following code
    copies bits 0 to 5 from EAX, then bits 0 to 4 from EBX, then bits 6 to 11 from
    EAX, then bits 5 to 15 from EBX, and finally bits 12 to 15 from EAX:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些小的修改，我们可以将四个8位值合并在一起，或从源字符串中合并其他比特集合。例如，以下代码从EAX复制比特0到5，从EBX复制比特0到4，从EAX复制比特6到11，从EBX复制比特5到15，最后从EAX复制比特12到15：
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Of course, if you have BMI2 instructions available, you can also use the `pextr`
    instruction to extract various bits for insertion into another register.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你有BMI2指令集可用，你也可以使用`pextr`指令提取各种比特并将其插入到另一个寄存器中。
- en: 12.13 Extracting Bit Strings
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.13 提取比特串
- en: 'We can also extract and distribute bits in a bit string among multiple destinations.
    The following code takes the 32-bit value in EAX and distributes alternate bits
    among the BX and DX registers:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在多个目的地之间提取并分配比特串中的比特。以下代码将EAX中的32位值并将交替的比特分配给BX和DX寄存器：
- en: '[PRE65]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This sequence executes 99 instructions (six inside the loop repeated 16 times
    plus three outside the loop). You can unroll the loop and pull other tricks, but
    it’s probably not worth the added complexity when it’s all said and done.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列执行99条指令（循环内部6条，循环重复16次，加上循环外部3条）。你可以展开循环并使用其他技巧，但当一切完成后，可能不值得增加复杂性。
- en: 'If you have the BMI2 instruction set extensions available, you can also use
    the `pext` instruction to do this job efficiently:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有BMI2指令集扩展可用，你也可以使用`pext`指令高效地完成这项工作：
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 12.14 Searching for a Bit Pattern
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.14 搜索比特模式
- en: Another bit-related operation you may need is the ability to search for a particular
    bit pattern in a string of bits. For example, you might want to locate the bit
    index of the first occurrence of `1011b` starting at some particular position
    in a bit string. In this section, we’ll explore some simple algorithms to accomplish
    this task.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与比特相关的操作是搜索比特串中是否包含特定的比特模式。例如，你可能希望从比特串的某个特定位置开始，找到`1011b`第一次出现的比特索引。在本节中，我们将探讨一些简单的算法来完成这个任务。
- en: 'To search for a particular bit pattern, we need to know four things:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索特定的位模式，我们需要知道四件事：
- en: The pattern to search for (the *pattern*)
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要搜索的模式（*模式*）
- en: The length of the pattern we’re searching for
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们要搜索的模式的长度
- en: The bit string that we’re going to search through (the *source*)
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将要搜索的位串（*源*）
- en: The length of the bit string to search through
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要搜索的位串的长度
- en: 'The basic idea behind the search is to create a mask based on the length of
    the pattern and mask a copy of the source with this value. Then we can directly
    compare the pattern with the masked source for equality. If they are equal, you’re
    finished; if they’re not equal, increment a bit position counter, shift the source
    one position to the right, and try again. You repeat this operation `length``(``source``)
    -` `length``(``pattern``)` times. The algorithm fails if it does not detect the
    bit pattern after this many attempts (because we will have exhausted all the bits
    in the source operand that could match the pattern’s length). Here’s a simple
    algorithm that searches for a 4-bit pattern throughout the EBX register:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索的基本思路是根据模式的长度创建一个掩码，并使用该掩码对源的副本进行掩码处理。然后我们可以直接将模式与掩码后的源进行比较，检查它们是否相等。如果相等，搜索完成；如果不相等，则增加位位置计数器，将源右移一个位置，并重试。你需要重复这个操作
    `length``(``source``) -` `length``(``pattern``)` 次。如果在这些尝试之后仍未检测到位模式，算法就失败了（因为我们已经耗尽了源操作数中可能与模式长度匹配的所有位）。这里有一个简单的算法，搜索
    EBX 寄存器中的 4 位模式：
- en: '[PRE67]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Bit-string scanning is a special case of string matching. *String matching*
    is a well-studied problem in computer science, and many of the algorithms you
    can use for string matching are applicable to bit-string matching as well. Such
    algorithms are beyond the scope of this chapter, but to give you a preview of
    how this works, you compute a function (like `xor` or `sub`) between the pattern
    and the current source bits and use the result as an index into a lookup table
    to determine how many bits you can skip. Such algorithms let you skip several
    bits rather than shifting only once for each iteration of the scanning loop (as
    is done by the previous algorithm).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 位串扫描是字符串匹配的一个特殊情况。*字符串匹配*是计算机科学中研究得非常透彻的问题，你可以用于字符串匹配的许多算法同样适用于位串匹配。这些算法超出了本章的范围，但为了让你对其工作原理有所了解，你可以通过计算一个函数（如
    `xor` 或 `sub`）在模式与当前源位之间的值，并将结果用作查找表的索引来决定可以跳过多少位。这些算法允许你跳过多个位，而不是在每次扫描循环迭代时只偏移一次（正如之前的算法所做的那样）。
- en: 12.15 For More Information
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.15 获取更多信息
- en: The AMD Athlon optimization guide contains useful algorithms for bit-based computations.
    To learn more about bit-searching algorithms, pick up a textbook on data structures
    and algorithms and study the section on string-matching algorithms.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: AMD Athlon 优化指南包含了用于基于位的计算的有用算法。要了解更多关于位查找算法的内容，请阅读一本关于数据结构和算法的教科书，并学习其中的字符串匹配算法章节。
- en: Probably the ultimate book on bit twiddling is *Hacker’s Delight*, Second Edition,
    by Henry S. Warren (Addison-Wesley, 2012). While this book uses the C programming
    language for examples, almost all the concepts apply to assembly language programs
    as well.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 关于位操作的终极书籍可能是 *Hacker’s Delight*（黑客的愉悦），第二版，作者是 Henry S. Warren（Addison-Wesley，2012）。虽然本书使用
    C 编程语言举例，但几乎所有概念也适用于汇编语言程序。
- en: 12.16 Test Yourself
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.16 自测
- en: What general instruction(s) would you use to clear bits in a register?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用什么通用指令来清除寄存器中的位？
- en: What instruction could you use to clear a bit, specified by bit number, in a
    register?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用什么指令清除寄存器中由位号指定的某一位？
- en: What general instruction would you use to set bits in a register?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用什么通用指令来设置寄存器中的位？
- en: What instruction could you use to set a bit, specified by bit number, in a register?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用什么指令设置寄存器中由位号指定的某一位？
- en: What general instruction would you use to invert bits in a register?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用什么通用指令来反转寄存器中的位？
- en: What instruction could you use to invert a bit, specified by bit number, in
    a register?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用什么指令反转寄存器中由位号指定的某一位？
- en: What general instruction would you use to test a bit (or group of bits) for
    0 and 1 in a register?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用什么通用指令来测试寄存器中某一位（或一组位）是否为 0 或 1？
- en: What instruction could you use to test a single bit, specified by bit number,
    in a register?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用什么指令测试寄存器中由位号指定的单个位？
- en: What single instruction could you use to extract and coalesce a set of bits?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用什么单一指令提取并合并一组位？
- en: What single instruction could you use to position and insert a set of bits in
    a register?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用什么单一指令在寄存器中定位并插入一组位？
- en: What single instruction could you use to extract a bit substring from a larger
    bit string?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用什么单一指令从较大的位串中提取一个位子串？
- en: What instruction allows you to search for the first set bit in a register?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么指令允许你搜索寄存器中第一个已设置的位？
- en: What instruction allows you to search for the last set bit in a register?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么指令允许你搜索寄存器中最后一个已设置的位？
- en: How would you search for the first clear bit in a register?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何搜索寄存器中第一个未设置的位？
- en: How would you search for the last clear bit in a register?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何搜索寄存器中最后一个未设置的位？
- en: What instruction can you use to count the number of bits in a register?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用什么指令来计算寄存器中位的数量？
