- en: '12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '12'
- en: CODE OPTIMIZATION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 代码优化
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: '*Code optimization* is the process by which a program is improved by reducing
    its code size, complexity, memory use, or runtime (or some combination thereof)
    without changing the program’s inherent function. Many compilation systems include
    a code optimizer as an intermediate step. Specifically, an *optimizing compiler*
    applies code-improving transformations as part of the compilation process. Virtually
    all modern compilers (including GCC) are optimizing compilers. The GCC C compiler
    implements a wide variety of *optimization flags* that give programmers direct
    access to a subset of the implemented optimizations. Compiler optimization flags
    optimize code at the expense of compile time and ease of debugging. For simplicity,
    GCC wraps up a subset of these optimization flags into different *optimization
    levels* that the programmer can directly invoke. For example, the following command
    compiles a sample program with level 1 optimizations:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码优化*是通过减少程序的代码大小、复杂度、内存使用或运行时间（或这些的某些组合）来改进程序的过程，而不改变程序的固有功能。许多编译系统将代码优化器作为中间步骤。具体来说，*优化编译器*在编译过程中应用改善代码的转换。几乎所有现代编译器（包括GCC）都是优化编译器。GCC
    C编译器实现了多种*优化标志*，为程序员提供了对已实现优化子集的直接访问。编译器优化标志会以牺牲编译时间和调试便利为代价来优化代码。为了简化，GCC将这些优化标志的子集包装成不同的*优化等级*，供程序员直接调用。例如，以下命令使用等级1优化编译一个示例程序：'
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The level 1 (`-O1` or `-O`) optimizations in GCC perform basic optimizations
    to reduce code size and execution time while attempting to keep compile time to
    a minimum. Level 2 (`-O2`) optimizations include most of GCC’s implemented optimizations
    that do not involve a space–performance trade-off. Lastly, level 3 (`-O3`) performs
    additional optimizations (such as function inlining, discussed later in this chapter),
    and may cause the program to take significantly longer to compile. The GCC documentation^([1](ch12.xhtml#fn12_1))
    describes the implemented optimization flags in detail.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: GCC中的等级1（`-O1` 或 `-O`）优化执行基本的优化，以减少代码大小和执行时间，同时尽量保持编译时间最小化。等级2（`-O2`）优化包括GCC实现的大多数优化，这些优化不涉及空间与性能之间的权衡。最后，等级3（`-O3`）执行额外的优化（如函数内联，稍后本章会讨论），并可能导致程序编译时间显著增加。GCC文档^([1](ch12.xhtml#fn12_1))详细描述了已实现的优化标志。
- en: 'A detailed discussion of optimizing compilers and their construction and operation
    is beyond the scope of this textbook; we encourage interested readers to check
    out the seminal text, *Compilers: Principles, Techniques, and Tools*, by Aho,
    Sethi, and Ulman. Rather, the purpose of the chapter is to highlight some things
    that most compilers can (and cannot) do, and how programmers can partner with
    their compilers and profiling tools to help improve their code.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 关于优化编译器及其构建和操作的详细讨论超出了本教材的范围；我们鼓励有兴趣的读者查阅Aho、Sethi和Ulman的经典著作《编译原理、技术与工具》。本章的目的是突出大多数编译器可以（以及不能）做的一些事情，以及程序员如何与编译器和性能分析工具合作来帮助改进他们的代码。
- en: What Compilers Already Do
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编译器已完成的工作
- en: Several of the common optimizations performed by virtually every compiler are
    described briefly in the upcoming sections. Students should *never* manually implement
    these optimizations, because they are already implemented by the compiler.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有编译器执行的一些常见优化将在接下来的部分中简要描述。学生*永远不要*手动实现这些优化，因为它们已经由编译器实现。
- en: Constant Folding
  id: totrans-9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 常量折叠
- en: Constants in the code are evaluated at compile time to reduce the number of
    resulting instructions. For example, in the code snippet that follows, *macro
    expansion* replaces the statement `int debug = N-5` with `int debug = 5-5`. *Constant
    folding* then updates this statement to `int debug = 0`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的常量在编译时进行计算，以减少生成的指令数量。例如，在下面的代码片段中，*宏展开*将语句`int debug = N-5`替换为`int debug
    = 5-5`。*常量折叠*随后将该语句更新为`int debug = 0`。
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Constant Propagation
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 常量传播
- en: '*Constant propagation* replaces variables with a constant value if such a value
    is known at compile time. Consider the following code segment:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*常量传播*在编译时已知某个值的情况下，用常量值替换变量。考虑以下代码段：'
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A compiler employing constant propagation will change `if (debug)` to `if (0)`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个采用常量传播的编译器会将`if (debug)`改为`if (0)`。
- en: Dead Code Elimination
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 死代码消除
- en: 'It is not uncommon for a program to be littered with unused variables, assignments,
    or statements. Even though these unneeded statements are rarely introduced intentionally,
    they are often a natural by-product of the constant iteration and refinement of
    the software development cycle. If left undetected, these so-called *dead code*
    sequences can cause compilers to output unnecessary assembly instructions that
    in turn waste processing time. Most compilers employ techniques such as dataflow
    analysis to identify unreachable code segments and thereby remove them. *Dead
    code elimination* often makes a program faster by shrinking code size and the
    associated set of instructions. As an example, let’s revisit the `doubleSum` function
    in which the compiler employed constant propagation to replace `debug` with `0`
    in the `if` statement:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中出现未使用的变量、赋值或语句并不罕见。尽管这些不需要的语句通常不是有意引入的，但它们往往是软件开发周期中不断迭代和优化的自然副产品。如果没有被发现，这些所谓的*死代码*序列可能会导致编译器输出不必要的汇编指令，从而浪费处理时间。大多数编译器采用数据流分析等技术来识别无法到达的代码段，并将其删除。*死代码消除*通常通过缩减代码大小和相关指令集来使程序运行得更快。例如，回到`doubleSum`函数，编译器利用常量传播将`debug`替换为`0`，从而简化了`if`语句：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A compiler employing dataflow analysis recognizes that the `if` statement always
    evaluates to false and that the `printf` statement never executes. The compiler
    therefore eliminates the `if` statement and the call to `printf` in the compiled
    executable. Another pass also eliminates the statement `debug = 0`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据流分析的编译器能够识别出`if`语句总是评估为`false`，并且`printf`语句永远不会执行。因此，编译器会在编译后的可执行文件中去除`if`语句和对`printf`的调用。另一个步骤还会去除语句`debug
    = 0`。
- en: Simplifying expressions
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简化表达式
- en: 'Some instructions are more expensive than others. For example, the `imul` and
    `idiv` arithmetic instructions in assembly take a long time to execute. Compilers
    commonly attempt to reduce the number of expensive instructions by simplifying
    mathematical operations whenever possible. For example, in the `doubleSum` function,
    the compiler may replace the expression `2 * total` with `total + total` because
    the addition instruction is less expensive than multiplication:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些指令的执行成本高于其他指令。例如，汇编中的`imul`和`idiv`算术指令执行时需要较长时间。编译器通常会通过简化数学运算来减少高成本指令的数量。例如，在`doubleSum`函数中，编译器可能会将表达式`2
    * total`替换为`total + total`，因为加法指令比乘法指令便宜：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Likewise, the compiler will transform code sequences with bit-shifting and other
    bitwise operators to simplify expressions. For example, the compiler may replace
    the expression `total * 8` with `total << 3`, or the expression `total % 8` with
    `total & 7` given that bitwise operations are performed with a single fast instruction.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，编译器会通过位移和其他按位运算符来转换代码序列，以简化表达式。例如，编译器可能会将表达式`total * 8`替换为`total << 3`，或将表达式`total
    % 8`替换为`total & 7`，因为按位运算可以通过一个快速指令执行。
- en: 'What Compilers Cannot Always Do: Benefits of Learning Code Optimization'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编译器无法始终做到的事情：学习代码优化的好处
- en: Given the benefits of optimizing compilers, it may not be immediately obvious
    why learning code optimization is useful. It may be tempting to think of the compiler
    as a magical black box that is “smart.” At the end of the day, the compiler is
    a piece of software that performs a series of code transformations in an effort
    to speed up code. Compilers are also limited in the types of optimizations they
    can perform.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管优化编译器有很多好处，但学习代码优化为何有用可能并不显而易见。可能会产生这样一种想法：编译器是一个“智能”的神奇黑盒。归根结底，编译器是一个执行一系列代码转换的软件，其目的是加速代码的执行。然而，编译器在其能够执行的优化类型上也存在限制。
- en: Algorithmic Strength Reduction Is Impossible
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 算法强度降低是不可能的
- en: The top reason for poor code performance is bad choices of data structures and
    algorithms. Compilers cannot magically fix these bad decisions. For example, a
    compiler will never optimize a program implementing bubble sort into one that
    implements quick sort. While the sophistication of compilers and their optimizations
    continues to improve, the *quality* of any individual compiler’s optimizations
    varies between platforms. The onus is therefore on the programmer to ensure that
    their code leverages the best algorithms and data structures.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码性能差的主要原因是选择了不合适的数据结构和算法。编译器无法神奇地修复这些糟糕的决策。例如，编译器永远不会将一个实现冒泡排序的程序优化成实现快速排序的程序。虽然编译器及其优化的复杂度不断提高，但任何单一编译器的优化*质量*在不同平台之间是不同的。因此，责任在于程序员，确保其代码利用了最佳的算法和数据结构。
- en: Compiler Optimization Flags Are Not Guaranteed to Make Code “Optimal” (or Consistent)
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编译器优化标志不能保证使代码“最优”（或一致）
- en: Increasing the level of compiler optimizations (e.g., from `-O2` to `-O3`) may
    not always decrease the runtime of a program. Sometimes, the programmer may discover
    that updating the optimization flags from `-O2` to `-O3` *slows down* a program
    or yields no performance increase at all. In other cases, a programmer may discover
    that a program compiled without the optimization flags seemingly yields no errors,
    whereas compiling it with `-O2` or `-O3` results in segmentation faults or other
    errors. These types of programming errors are especially difficult to debug, because
    gcc’s debug (`-g`) flag is incompatible with its optimization (`-O`) flags, as
    the transformations performed by compiler optimizations at the `-O` levels interfere
    with the debugger’s ability to analyze the underlying code. The `-g` flag is required
    by many common profiling tools, such as GDB and Valgrind.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 提高编译器优化级别（例如，从`-O2`到`-O3`）并不总是能减少程序的运行时间。有时，程序员可能会发现将优化标志从`-O2`更新到`-O3`反而*降低了*程序的速度，或者根本没有任何性能提升。在其他情况下，程序员可能会发现一个没有优化标志编译的程序似乎没有任何错误，而使用`-O2`或`-O3`编译时却会导致段错误或其他错误。这类编程错误尤其难以调试，因为gcc的调试（`-g`）标志与其优化（`-O`）标志不兼容，因为编译器优化在`-O`级别上进行的转换会干扰调试器分析底层代码的能力。许多常见的性能分析工具（如GDB和Valgrind）都要求使用`-g`标志。
- en: One large reason for inconsistent behavior is that the C/C++ standard does not
    provide clear guidance for resolving undefined behavior. As a result, it is often
    up to the compiler to decide how to resolve ambiguity. Inconsistencies on how
    different optimization levels handle undefined behavior can cause answers to *change*.
    Consider the following example from John Regehr:^([2](ch12.xhtml#fn12_2))
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 行为不一致的一个重要原因是，C/C++标准并未提供明确的指南来解决未定义行为。因此，通常由编译器决定如何解决歧义。不同优化级别如何处理未定义行为的不一致可能导致结果发生*变化*。考虑以下John
    Regehr的例子：^([2](ch12.xhtml#fn12_2))
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Suppose that `silly` was run with `a = INT_MAX`. In this case, the computation
    `a + 1` results in integer overflow. However, the C/C++ standard does not define
    *how* integer overflow should be handled by the compiler. In fact, compiling the
    program with no optimizations causes the function to return 0, while compiling
    it with `-O3` optimizations results in the function returning 1.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设` silly `是用` a = INT_MAX `运行的。在这种情况下，计算` a + 1 `会导致整数溢出。然而，C/C++标准并没有定义*编译器应该如何处理*整数溢出。事实上，在没有优化的情况下编译程序会使得函数返回0，而使用`-O3`优化编译时，函数则返回1。
- en: In short, optimization flags should be used with caution, thoughtfully, and
    when necessary. Learning which optimization flags to employ can also help the
    programmer work with their compiler instead of against it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，优化标志应该谨慎使用，经过深思熟虑，并在必要时使用。学习使用哪些优化标志也可以帮助程序员与编译器合作，而不是与编译器对抗。
- en: '**Note THE COMPILER IS NOT REQUIRED TO HANDLE UNDEFINED BEHAVIOR**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意 编译器不要求处理未定义行为**'
- en: The `silly` function when run with `a = INT_MAX` is an example of undefined
    behavior. Note that the inconsistent output produced by the compiler is not a
    flaw in the compiler’s design or a consequence of using optimization flags. Compilers
    are specifically designed to follow a language’s specification. The C Language
    standard does not specify what a compiler should do when it encounters undefined
    behavior; the program may crash, fail to compile, or generate inconsistent or
    incorrect results. Ultimately, the programmer is responsible for identifying and
    eliminating undefined behavior in code. Whether `silly` should return 0, 1, or
    some other value is ultimately a decision the programmer must make. To learn more
    about undefined behavior and related issues in C programs, visit the C FAQ^([3](ch12.xhtml#fn12_3))
    or John Regehr’s Guide to Undefined Behavior.^([4](ch12.xhtml#fn12_4))
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当`a = INT_MAX`时运行的`silly`函数是未定义行为的一个例子。请注意，编译器生成的不一致输出并不是编译器设计上的缺陷，也不是使用优化标志的结果。编译器专门设计来遵循语言规范。C语言标准并没有规定当编译器遇到未定义行为时应该做什么；程序可能崩溃、无法编译，或生成不一致或错误的结果。最终，程序员负责识别并消除代码中的未定义行为。`silly`应该返回0、1还是其他值，最终是程序员必须做出的决定。欲了解更多关于未定义行为和C程序相关问题的信息，请访问C语言FAQ^([3](ch12.xhtml#fn12_3))或John
    Regehr的《未定义行为指南》^([4](ch12.xhtml#fn12_4))。
- en: Pointers Can Prove Problematic
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 指针可能会引发问题
- en: Recall that the compiler makes transformations that leave the fundamental behavior
    of the source program unchanged. If a transformation risks changing the behavior
    of the program, the compiler will not make the transformation. This is especially
    true in the case of *memory aliasing* where two different pointers point to the
    same address in memory. As an example, consider the function `shiftAdd`, which
    takes two integer pointers as its two parameters. The function multiplies the
    first number by 10 and adds the second number to it. So, if the `shiftAdd` function
    were passed the integers 5 and 6, the result will be 56.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，编译器进行的转换会保持源程序的基本行为不变。如果某个转换可能改变程序的行为，编译器将不会进行该转换。特别是在*内存别名*的情况下，即两个不同的指针指向内存中的相同地址，编译器尤其会遵守这一规则。举个例子，考虑函数`shiftAdd`，它的两个参数是两个整数指针。该函数将第一个数字乘以10，并将第二个数字加到其中。所以，如果`shiftAdd`函数传入整数5和6，结果将是56。
- en: Unoptimized version
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 未优化版本
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Optimized version
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 优化版本
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `shiftAddOpt` function optimizes the `shiftAdd` function by removing an
    additional memory reference to `a`, resulting in a smaller set of instructions
    in the compiled assembly. However, the compiler will never make this optimization
    due to the risk of memory aliasing. To understand why, consider the following
    `main` function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`shiftAddOpt`函数通过去除对`a`的额外内存引用来优化`shiftAdd`函数，从而在编译的汇编代码中生成较小的指令集。然而，由于内存别名的风险，编译器永远不会做这种优化。为了理解原因，请考虑以下的`main`函数：'
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Compiling and running this program gives the expected output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行此程序会得到预期输出：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Suppose, instead, that the program were modified so that `shiftAdd` now takes
    a pointer to `x` as its two parameters:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设程序被修改为使得`shiftAdd`现在接收指向`x`的指针作为它的两个参数：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The expected output is 55\. However, recompiling and rerunning the updated
    code gives two different outputs:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出是55。 然而，重新编译并重新运行更新后的代码会得到两个不同的输出：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Retracing through the `shiftAdd` functions with the assumption that `a` and
    `b` are pointing to the same memory location reveals the issue. The multiplication
    of `a` by 10 in `shiftAdd` updates `x` to 50\. Next, adding `a` to `b` in `shiftAdd`
    results in `x` doubling to 100\. The risk of memory aliasing reveals that `shiftAdd`
    and `shiftAddOpt` are not in fact equivalent, though the programmer may have intended
    them to be. To fix this issue, recognize that the second parameter of `shiftAdd`
    does not need to be passed in as a pointer. Replacing the second parameter with
    an integer eliminates the risk of aliasing and allows the compiler to optimize
    one function into the other:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯通过假设`a`和`b`指向相同的内存位置的`shiftAdd`函数可以揭示问题。在`shiftAdd`中将`a`乘以10会将`x`更新为50。接下来，在`shiftAdd`中将`a`加到`b`中，会使得`x`翻倍变为100。内存别名的风险表明，尽管程序员可能希望它们是等效的，但`shiftAdd`和`shiftAddOpt`实际上并不相同。为了解决这个问题，应该认识到`shiftAdd`的第二个参数不需要作为指针传递。用整数替换第二个参数可以消除别名风险，并允许编译器将一个函数优化为另一个函数：
- en: Unoptimized version (fixed)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 未优化版本（已修复）
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Optimized version (fixed)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 优化版本（已修复）
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Removing the unneeded memory reference allows the programmer to maintain the
    readability of the original `shiftAdd` function while enabling the compiler to
    optimize the function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 移除不必要的内存引用使得程序员能够保持原始`shiftAdd`函数的可读性，同时使编译器能够优化该函数。
- en: 'Partnering with Your Compiler: A Sample Program'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与编译器的合作：一个示例程序
- en: In the following sections, we concentrate on learning more about popular types
    of optimizations and discuss programming and profiling strategies to help make
    it easier for compilers to optimize our code. To illustrate our discussion, we
    will work to optimize the following (suboptimally written) program that attempts
    to find all the prime numbers between 2 and *n*:^([5](ch12.xhtml#fn12_5))
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将重点学习更多常见的优化类型，并讨论编程和性能分析策略，以帮助编译器更容易地优化我们的代码。为了说明我们的讨论，我们将致力于优化以下（编写不够优化的）程序，该程序尝试查找2到*n*之间的所有质数：^([5](ch12.xhtml#fn12_5))
- en: optExample.c
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: optExample.c
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Table 12-1](ch12.xhtml#ch12tab1) shows the timing results for producing the
    primes between 2 and 5,000,000 with the different optimization level flags using
    the following basic compilation command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[表12-1](ch12.xhtml#ch12tab1)展示了使用以下基本编译命令，在不同优化级别标志下生成2到5,000,000之间质数的时间结果：'
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Table 12-1:** Time in Seconds to Produce Prime Numbers Between 2 and 5,000,000'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**表12-1：** 生成2到5,000,000之间质数的时间（单位：秒）'
- en: '| **Unoptimized** | -O1 | -O2 | -O3 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **未优化** | -O1 | -O2 | -O3 |'
- en: '| 3.86 | 2.32 | 2.14 | 2.15 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 3.86 | 2.32 | 2.14 | 2.15 |'
- en: The fastest observed time with optimization flags is approximately 2.14 seconds.
    Although using optimization flags does shave off more than a second from the runtime
    of this program, upping the optimization flags provides minimal improvement. In
    the next sections, we will discuss how we can modify our program to make it easier
    for the compiler to optimize.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用优化标志观察到的最快时间约为2.14秒。虽然使用优化标志可以将程序运行时间缩短超过一秒，但提高优化标志的级别所带来的改进几乎可以忽略不计。在接下来的章节中，我们将讨论如何修改程序，使编译器更容易进行优化。
- en: '12.1 Code Optimization First Steps: Code Profiling'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1 代码优化第一步：代码性能分析
- en: '*The real problem is that programmers have spent far too much time worrying
    about efficiency in the wrong places and at the wrong times; premature optimization
    is the root of all evil (or at least most of it) in programming.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*真正的问题是程序员在错误的地方和错误的时间花费了太多时间去担心效率；过早优化是编程中所有问题的根源（至少是大多数问题的根源）。*'
- en: —Don Knuth, *The Art of Computer Programming*
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: —唐纳德·克努斯，*计算机程序设计的艺术*
- en: One of the biggest dangers in code optimization is the concept of *premature
    optimization*. Premature optimization occurs when a programmer attempts to optimize
    based on “gut feelings” of where performance inefficiencies occur, and not on
    data. Whenever possible, it is important to measure the runtime of different portions
    of code on different inputs *prior* to starting optimization to identify *hot
    spots* or areas in the program in which the most instructions occur.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 代码优化中最大的危险之一是*过早优化*的概念。过早优化指的是程序员基于“直觉”而非数据来优化，试图在性能低效的地方进行优化。尽可能地，在开始优化之前，通过测量不同代码部分在不同输入下的运行时间，识别出*热点*或者程序中执行最多指令的区域。
- en: 'To figure out how to optimize `optExample.c`, let’s start by taking a closer
    look at the `main` function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出如何优化`optExample.c`，我们首先来仔细看看`main`函数：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `main` function contains calls to two functions: `allocateArray`, which
    initializes an array of a user-specified length (or limit), and `genPrimeSequence`,
    which generates a sequence of primes within the specified limit (note that for
    any sequence between 2 and *n*, there cannot be more than *n* primes, and frequently
    there are significantly less). The `main` function contains code that times each
    of the two functions in the preceding example. Compiling and running the code
    with `limit` set to 5,000,000 reveals the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数包含对两个函数的调用：`allocateArray`，它初始化一个用户指定长度（或限制）的数组；`genPrimeSequence`，它生成在指定限制内的质数序列（请注意，在2和*n*之间的任何序列中，质数的数量不能超过*n*，并且通常质数的数量要少得多）。`main`函数还包含计时每个函数运行时间的代码。将代码编译并运行，`limit`设置为5,000,000时，结果如下：'
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `optExample` program takes approximately 3.86 seconds to complete, with
    nearly all of the time in the `genPrimeSequence` function. There is no point in
    spending time optimizing `allocateArray`, because any improvements will be negligible
    to the runtime of the overall program. In the examples that follow, we focus more
    closely on the `genPrimeSequence` function and its associated functions. The functions
    are reproduced here for convenience:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`optExample` 程序大约需要 3.86 秒才能完成，几乎所有时间都花费在 `genPrimeSequence` 函数中。没有必要花时间优化
    `allocateArray`，因为对整个程序运行时间的改进微乎其微。在接下来的示例中，我们将更加关注 `genPrimeSequence` 函数及其相关函数。为了方便起见，以下是这些函数的代码：'
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To find hot spots in a program, focus on the areas with the most loops. Manual
    inspection of code can assist in locating hot spots, though it should always be
    verified with benchmarking tools prior to attempting optimization. A manual inspection
    of the `optExample` program yields the following observations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出程序中的热点，可以关注包含最多循环的区域。代码的手动检查有助于定位热点，但在尝试优化之前，始终应通过基准测试工具进行验证。对 `optExample`
    程序的手动检查得出以下观察结果。
- en: The `genPrimeSequence` function attempts to generate all the prime numbers between
    2 and some integer *n*. Since the number of primes between 2 and *n* cannot exceed
    *n*, the `for` loop in `genPrimeSequence` runs no more than *n* times. Every iteration
    of the `for` loop calls the `getNextPrime` function once. Thus, `getNextPrime`
    runs no more than *n* times.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`genPrimeSequence` 函数尝试生成从 2 到某个整数 *n* 之间的所有素数。由于 2 和 *n* 之间的素数个数不能超过 *n*，因此
    `genPrimeSequence` 中的 `for` 循环最多执行 *n* 次。每次 `for` 循环迭代都会调用一次 `getNextPrime` 函数。因此，`getNextPrime`
    函数最多执行 *n* 次。'
- en: The `while` loop in the `getNextPrime` function will continue running until
    a prime is discovered. Although it is difficult to determine the number of times
    the `while` loop in the `getNextPrime` function will execute ahead of time as
    a function of *n* (the gap between consecutive prime numbers can be arbitrarily
    large), it is certain that `isPrime` executes on every iteration of the `while`
    loop.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNextPrime` 函数中的 `while` 循环将持续运行，直到发现一个素数。虽然很难事先根据 *n*（连续素数之间的差距可能非常大）来确定
    `while` 循环将执行多少次，但可以确定的是，`isPrime` 会在每次 `while` 循环迭代时执行。'
- en: The `isPrime` function contains exactly one `for` loop. Suppose that the loop
    runs for a total of *k* iterations. Then, the code in the loop body runs *k* times
    in total. Recall from “Loops in C” on [page 33](ch01.xhtml#lev2_7) that the structure
    of a `for` loop consists of an *initialization statement* (which initializes the
    loop variable to a particular value), a *Boolean expression* (that determines
    when to terminate the loop), and a *step expression* (that updates the loop variable
    every iteration). [Table 12-2](ch12.xhtml#ch12tab2) depicts the number of times
    each loop component executes in a `for` loop that runs for *k* iterations. In
    every `for` loop, initialization happens exactly once. The Boolean expression
    executes *k* + 1 times for *k* iterations, since it must perform one final check
    to terminate the loop. The loop body and the step expression execute *k* times
    each.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`isPrime` 函数包含一个 `for` 循环。假设该循环总共执行 *k* 次迭代。那么，循环体中的代码将执行 *k* 次。回顾在《C语言中的循环》一章中的内容，[第33页](ch01.xhtml#lev2_7)提到，`for`
    循环的结构包括一个 *初始化语句*（用于将循环变量初始化为特定值），一个 *布尔表达式*（用于确定何时终止循环），以及一个 *步进表达式*（用于在每次迭代时更新循环变量）。[表12-2](ch12.xhtml#ch12tab2)显示了在执行
    *k* 次迭代的 `for` 循环中，各个循环组件执行的次数。在每个 `for` 循环中，初始化只会执行一次。布尔表达式会执行 *k* + 1 次，因为它必须进行一次最终检查以终止循环。循环体和步进表达式各执行
    *k* 次。'
- en: '**Table 12-2:** Loop Execution Components (Assuming k Iterations)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**表12-2：** 循环执行组件（假设执行 k 次迭代）'
- en: '| **Initialization statement** | **Boolean expression** | **Step expression**
    | **Loop body** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **初始化语句** | **布尔表达式** | **步进表达式** | **循环体** |'
- en: '| 1 | *k* + 1 | *k* | *k* |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *k* + 1 | *k* | *k* |'
- en: Our manual inspection of the code suggests that the program spends most of its
    time in the `isPrime` function, and that the `sqrt` function executes the most
    often. Let’s next use code profiling to verify this hypothesis.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对代码的手动检查表明，程序大部分时间都花费在 `isPrime` 函数中，且 `sqrt` 函数执行的次数最多。接下来，让我们使用代码分析工具来验证这个假设。
- en: 12.1.1 Using Callgrind to Profile
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.1 使用 Callgrind 进行性能分析
- en: In our small program, it was relatively straightforward to use manual inspection
    to form the hypothesis that the `sqrt` function occurs in a “hot spot” in the
    code. However, identifying hot spots can become more complex in larger programs.
    Regardless, it is a good idea to use profiling to verify our hypothesis. Code
    profiling tools like Valgrind^([6](ch12.xhtml#fn12_6)) provide a lot of information
    about program execution. In this section, we use the `callgrind` tool to inspect
    the `OptExample` program’s call graph.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的小程序中，通过手动检查相对简单地形成假设，认为`sqrt`函数出现在代码的“热点”中。然而，在较大的程序中，识别热点可能变得更加复杂。无论如何，使用性能分析工具来验证我们的假设是个好主意。像Valgrind^([6](ch12.xhtml#fn12_6))这样的代码性能分析工具提供了大量关于程序执行的信息。在这一节中，我们使用`callgrind`工具来检查`OptExample`程序的调用图。
- en: To use `callgrind`, let’s start by recompiling the `optExample` program with
    the `-g` flag and running `callgrind` on a smaller range (2 to 100,000). Like
    other Valgrind applications, `callgrind` runs as a wrapper around a program, adding
    annotations such as the number of times functions execute and the total number
    of instructions that are executed as a result. Consequently, the `optExample`
    program will take longer to execute when run in conjunction with `callgrind`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`callgrind`，我们先通过`-g`标志重新编译`optExample`程序，并在较小的范围（2到100,000）内运行`callgrind`。像其他Valgrind应用程序一样，`callgrind`作为一个包装器运行在程序周围，添加注释信息，例如函数执行的次数和执行的总指令数。因此，当与`callgrind`一起运行时，`optExample`程序的执行时间会更长。
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Typing `ls` at the terminal reveals a new file called `callgrind.out.xxxxx`,
    where `xxxxx` is a unique id. In this case, the file is `callgrind.out.32590`
    (i.e., the number shown along the left-hand column in the preceding output). Running
    `callgrind_annotate` on this file yields additional information on the three functions
    of interest:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端输入`ls`会显示一个新文件，名为`callgrind.out.xxxxx`，其中`xxxxx`是唯一的标识符。在这种情况下，文件名为`callgrind.out.32590`（即前面输出中左侧列显示的数字）。对这个文件运行`callgrind_annotate`会生成更多关于三个感兴趣函数的信息：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The numbers along the left-hand column represent the number of total executed
    instructions associated with each line. The numbers in parentheses indicate the
    number of times a particular function was run. Using the numbers along the left-hand
    column, we are able to verify the results of our manual inspection. In the `genPrimeSequence`
    function, the `getNextPrime` function resulted in the most number of executed
    instructions at 67.8 million instructions, corresponding to 9,592 function calls
    (to generate the primes between 2 and 100,000). Inspecting `getNextPrime` reveals
    that the majority of those instructions (67.1 million, or 99%) result from the
    call to `isPrime`, which is called a total of 100,001 times. Lastly, inspecting
    `isPrime` reveals that 13 million of the total instructions (20.5%) result from
    the `sqrt` function, which executes a total of 2.7 million times.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧列的数字表示与每一行相关联的总执行指令数。括号中的数字表示某个特定函数运行的次数。通过左侧列的数字，我们能够验证手动检查的结果。在`genPrimeSequence`函数中，`getNextPrime`函数执行的指令最多，总计6,780万条指令，对应9,592次函数调用（用于生成2到100,000之间的素数）。检查`getNextPrime`时发现，大部分指令（6,710万条，占99%）是来自对`isPrime`的调用，而`isPrime`总共被调用了100,001次。最后，检查`isPrime`时发现，总指令数中有1,300万条（占20.5%）来自`sqrt`函数，`sqrt`函数总共执行了270万次。
- en: These results verify our original hypothesis that the program spends most of
    its time in the `isPrime` function, with the `sqrt` function executing the most
    frequently of all the functions. Reducing the total number of executed instructions
    results in a faster program; the above analysis suggests that our initial efforts
    should concentrate on improving the `isPrime` function, and potentially reducing
    the number of times `sqrt` executes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果验证了我们最初的假设：程序大部分时间都花费在`isPrime`函数中，并且`sqrt`函数是所有函数中执行最频繁的。减少执行的总指令数会使程序更快；上述分析表明，我们的初步努力应集中在改进`isPrime`函数，并可能减少`sqrt`执行的次数。
- en: 12.1.2 Loop-Invariant Code Motion
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.2 循环不变代码移动
- en: Loop-invariant code motion is an optimization technique that moves static computations
    that occur inside a loop to outside the loop without affecting the loop’s behavior.
    Optimizing compilers are capable of making most loop-invariant code optimizations
    automatically. Specifically, the `-fmove-loop -invariants` compiler flag in GCC
    (enabled at level `-O1`) attempts to identify examples of loop-invariant code
    motion and move them outside their respective loops.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 循环不变代码移动是一种优化技术，它将发生在循环内部的静态计算移到循环外部，同时不影响循环的行为。优化编译器能够自动执行大多数循环不变代码优化。具体来说，GCC中的`-fmove-loop-invariants`编译器标志（在`-O1`级别启用）尝试识别循环不变代码移动的例子，并将它们移到各自的循环外部。
- en: However, the compiler cannot always identify cases of loop-invariant code motion,
    especially in the case of function calls. Since function calls can inadvertently
    cause *side effects* (unintended behavior), most compilers will avoid trying to
    determine whether a function call consistently returns the same result. Thus,
    even though the programmer knows that `sqrt(x)` always returns the square root
    of some input `x`, GCC will not always make that assumption. Consider the case
    where the `sqrt` function updates a secret global variable, `g`. In that case,
    calling `sqrt` once outside of the function (*one* update to `g`) is not the same
    as calling it every iteration of the loop (*n* updates to `g`). If a compiler
    cannot determine that a function always returns the same result, it will not automatically
    move the `sqrt` function outside the loop.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编译器并不能总是识别循环不变代码移动的情况，尤其是在函数调用的情况下。由于函数调用可能会不小心引起*副作用*（意外的行为），大多数编译器会避免尝试判断一个函数调用是否始终返回相同的结果。因此，即使程序员知道`sqrt(x)`始终返回某个输入`x`的平方根，GCC也不会总是做出这个假设。考虑到`sqrt`函数更新了一个秘密的全局变量`g`，在这种情况下，在函数外调用一次`sqrt`（*对g进行一次*更新）与在循环的每次迭代中调用它（*对g进行n次*更新）是不同的。如果编译器无法确定一个函数始终返回相同的结果，它就不会自动将`sqrt`函数移到循环外部。
- en: However, the programmer knows that moving the computation `sqrt(x) + 1` outside
    the `for` loop does not effect the loop’s behavior. The updated function is shown
    here and is available online:^([7](ch12.xhtml#fn12_7))
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，程序员知道将计算`sqrt(x) + 1`移到`for`循环外部不会影响循环的行为。更新后的函数在这里展示，并且可以在线查看：^([7](ch12.xhtml#fn12_7))
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Table 12-3](ch12.xhtml#ch12tab3) shows that this simple change shaves off
    a full two seconds (47%) of the runtime of `optExample2`, even before using compiler
    flags. Furthermore, the compiler seems to have a slightly easier time optimizing
    `optExample2`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-3](ch12.xhtml#ch12tab3)显示，这一简单的更改使得`optExample2`的运行时间减少了整整两秒（47%），即使在没有使用编译器标志的情况下。此外，编译器似乎更容易优化`optExample2`。'
- en: '**Table 12-3:** Time in Seconds to Produce the Prime Numbers Between 2 and
    5,000,000'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-3：** 计算2到5,000,000之间素数所需的时间（单位：秒）'
- en: '| **Version** | **Unoptimized** | -O1 | -O2 | -O3 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **版本** | **未优化** | -O1 | -O2 | -O3 |'
- en: '| Original | 3.86 | 2.32 | 2.14 | 2.15 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 原始 | 3.86 | 2.32 | 2.14 | 2.15 |'
- en: '| With loop-invariant code motion | 1.83 | 1.63 | 1.71 | 1.63 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 使用循环不变代码移动 | 1.83 | 1.63 | 1.71 | 1.63 |'
- en: 'Rerunning `callgrind` on the `optExample2` executable reveals why such a large
    improvement in runtime was observed. The following code snippet assumes that the
    file `callgrind.out.30086` contains the annotations of running `callgrind` on
    the `optExample2` executable:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行`callgrind`在`optExample2`可执行文件上的分析可以揭示为什么观察到了如此大的运行时改进。以下代码片段假设文件`callgrind.out.30086`包含了运行`callgrind`在`optExample2`可执行文件上的注释：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Moving the call to `sqrt` outside of the `for` loop reduces the number of times
    the `sqrt` function is called in the program from 2.7 million to 100,000 (96%
    reduction). This number corresponds to the number of times the `isPrime` function
    is called, confirming that the `sqrt` function executes only once with every invocation
    of the `isPrime` function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将对`sqrt`的调用移到`for`循环外部，将程序中`sqrt`函数的调用次数从270万次减少到10万次（减少96%）。这个数字对应于`isPrime`函数的调用次数，确认了每次调用`isPrime`函数时，`sqrt`函数只执行一次。
- en: Note that the compiler was able to perform significant levels of optimization
    when optimization flags were specified, even if the programmer does not manually
    perform code motion. In this case, the reason is due to a special instruction
    called `fsqrt` that is specified by the x86 ISA. When optimization flags are turned
    on, the compiler replaces all instances of the `sqrt` function with the `fsqrt`
    instruction. This process is known as *inlining*, and we cover it greater detail
    in the following section. Since `fsqrt` is no longer a function, it is easier
    for the compiler to identify its loop-invariant nature and move it outside the
    body of the loop.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使程序员没有手动执行代码运动，编译器在指定优化标志时也能够执行显著的优化。在这种情况下，原因是 x86 指令集架构（ISA）中有一个特殊的指令
    `fsqrt`。当启用优化标志时，编译器会将所有 `sqrt` 函数的调用替换为 `fsqrt` 指令。这一过程被称为 *内联*，我们将在接下来的章节中详细介绍。由于
    `fsqrt` 不再是一个函数，它更容易被编译器识别为循环不变的代码，从而将其移出循环体外。
- en: '12.2 Other Compiler Optimizations: Loop Unrolling and Function Inlining'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2 其他编译器优化：循环展开与函数内联
- en: The loop-invariant code motion optimization described in the previous section
    was a simple change that resulted in a massive reduction in execution time. However,
    such optimizations are situationally dependent, and may not always result in improvements
    to performance. In most cases, loop-invariant code motion is taken care of by
    the compiler.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中描述的循环不变代码运动优化是一个简单的改动，导致了执行时间的显著减少。然而，这种优化是依赖于特定情况的，并不总是能带来性能提升。在大多数情况下，循环不变代码运动由编译器自动处理。
- en: Code today is more often read than it is written. In most cases, fractional
    performance gains are not worth the hit to code readability. In general, a programmer
    should let the compiler optimize whenever possible. In this section, we cover
    some optimization techniques that were previously manually implemented by programmers
    but are today commonly implemented by compilers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，代码更多的是被阅读而不是编写。在大多数情况下，微小的性能提升并不值得为了提高性能而牺牲代码的可读性。一般来说，程序员应该尽可能让编译器进行优化。在本节中，我们将介绍一些过去由程序员手动实现的优化技术，但如今这些技术通常由编译器实现。
- en: There are several sources online that advocate for the manual implementation
    of the techniques we describe in the following sections. However, we encourage
    readers to check whether their compilers support the following optimizations before
    attempting to manually implement them in their code. All the optimizations described
    in this section are implemented in GCC, but may not be available in older compilers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 网上有一些资源提倡手动实现我们在以下章节中描述的技术。然而，我们建议读者在尝试手动实现这些优化之前，先检查他们的编译器是否支持这些优化。本文所述的所有优化在
    GCC 中都有实现，但在旧版编译器中可能不可用。
- en: 12.2.1 Function Inlining
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.1 函数内联
- en: 'One optimization step that compilers attempt to perform is *function inlining*,
    which replaces calls to a function with the body of the function. For example,
    in the `main` function, a compiler inlining the `allocateArray` function will
    replace the call to `allocateArray` with a direct call to `malloc`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器尝试执行的一个优化步骤是 *函数内联*，它将对函数的调用替换为函数体的内容。例如，在 `main` 函数中，如果编译器内联 `allocateArray`
    函数，它将把对 `allocateArray` 的调用替换为直接调用 `malloc`：
- en: Original version
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 原始版本
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: allocateArray inlined
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `allocateArray` 内联
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Inlining functions can result in some runtime savings for a program. Recall
    that every time a program calls a function, many instructions associated with
    function creation and destruction are necessarily generated. Inlining functions
    enables the compiler to eliminate these excessive calls, and makes it easier for
    the compiler to identify other potential improvements, including constant propagation,
    constant folding, and dead code elimination. In the case of the `optExample` program,
    inlining likely allows the compiler to replace the call to `sqrt` with the `fsqrt`
    instruction and subsequently move it outside the loop.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内联可以为程序带来一定的运行时节省。回想一下，每当程序调用一个函数时，都会生成与函数创建和销毁相关的许多指令。函数内联使编译器能够消除这些多余的调用，并且使编译器更容易识别其他潜在的优化，包括常量传播、常量折叠和死代码消除。在
    `optExample` 程序中，函数内联可能使编译器将对 `sqrt` 的调用替换为 `fsqrt` 指令，并将其移出循环。
- en: The `-finline-functions` flag suggests to GCC that functions should be inlined.
    This optimization is turned on at level 3\. Even though `-finline-functions` can
    be used independently of the `-O3` flag, it is a *suggestion* to the compiler
    to look for functions to inline. Likewise, the `static inline` keyword can be
    used to suggest to the compiler that a particular function should be inlined.
    Keep in mind that the compiler will not inline all functions, and that function
    inlining is not guaranteed to make code faster.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`-finline-functions`标志向GCC建议应该进行函数内联。这项优化在级别3时启用。即使`-finline-functions`可以独立于`-O3`标志使用，它仍然是向编译器提出的
    *建议*，让编译器寻找可以内联的函数。同样，`static inline`关键字也可以用于向编译器建议某个特定函数应该被内联。请记住，编译器并不会内联所有函数，而且函数内联并不一定会使代码变得更快。'
- en: Programmers should generally avoid inlining functions manually. Inlining functions
    carries a high risk of significantly reducing the readability of code, increasing
    the likelihood of errors, and making it harder to update and maintain functions.
    For example, trying to inline the `isPrime` function in the `getNextPrime` function
    will greatly reduce the readability of `getNextPrime`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员通常应避免手动内联函数。内联函数的风险较高，可能会显著降低代码的可读性，增加出错的可能性，并使得更新和维护函数变得更加困难。例如，尝试将`isPrime`函数内联到`getNextPrime`函数中，将大大降低`getNextPrime`的可读性。
- en: 12.2.2 Loop Unrolling
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.2 循环展开
- en: 'The last compiler optimization strategy we discuss in this section is loop
    unrolling. Let’s revisit the `isPrime` function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节讨论的最后一个编译器优化策略是循环展开。让我们重新审视一下`isPrime`函数：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `for` loop executes a total of `max` times, where `max` is one more than
    the square root of integer `x`. At the assembly level, every execution of the
    loop checks to see whether `i` is less than `max`. If so, the instruction pointer
    jumps to the body of the loop, which computes the modulo operation. If the modulo
    operation results in 0, the program immediately exits the loop and returns 0\.
    Otherwise, the loop continues execution. While branch predictors are fairly good
    at predicting what a conditional expression evaluates to (especially inside loops),
    wrong guesses can result in a hit to performance, due to disruptions in the instruction
    pipeline.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环总共执行`max`次，其中`max`是整数`x`的平方根加一。在汇编级别，每次执行循环时都会检查`i`是否小于`max`。如果是，指令指针跳转到循环体，计算模运算。如果模运算结果为0，程序立即退出循环并返回0。否则，循环继续执行。虽然分支预测器在预测条件表达式的结果时表现得相当不错（尤其是在循环内），但错误的猜测可能会导致性能下降，因为指令流水线可能会中断。'
- en: '*Loop unrolling* is an optimization that compilers perform to reduce the impact
    of wrong guesses. In loop unrolling, the goal is to reduce the number of iterations
    of a loop by a factor of *n* by increasing the workload that each iteration performs
    by a factor of *n*. When a loop is unrolled by a factor of 2, the number of iterations
    in the loop is cut by *half* , whereas the amount work performed per iteration
    is *doubled*.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*循环展开*是一种编译器执行的优化，用来减少错误猜测的影响。在循环展开中，目标是通过增加每次迭代的工作量来减少循环的迭代次数，通常按 *n* 的倍数来进行。当一个循环按2的倍数展开时，循环中的迭代次数将减少
    *一半*，而每次迭代所执行的工作量将 *翻倍*。'
- en: Let’s manually apply 2-factor loop unrolling to our `isPrime` function:^([8](ch12.xhtml#fn12_8))
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们手动将2倍循环展开应用到`isPrime`函数中：^([8](ch12.xhtml#fn12_8))
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that even though we have halved the number of iterations that the `for`
    loop takes, each iteration of the loop now performs two modulo checks, doubling
    the amount of work per iteration. Recompiling and rerunning the program results
    in marginally improved times (see [Table 12-4](ch12.xhtml#ch12tab4)).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们已经将`for`循环的迭代次数减少了一半，但每次迭代现在执行了两个模运算，导致每次迭代的工作量 *翻倍*。重新编译并重新运行程序后，结果是时间略有改进（参见[表12-4](ch12.xhtml#ch12tab4)）。
- en: The readability of the code is also reduced. A better way to utilize loop unrolling
    is to invoke the `-funroll-loops` compiler optimization flag, which tells the
    compiler to unroll loops whose iterations can be determined at compile time. The
    `-funroll-all-loops` compiler flag is a more aggressive option that unrolls all
    loops regardless of whether the compiler is certain of the number of iterations.
    [Table 12-4](ch12.xhtml#ch12tab4) shows the runtimes of the manual 2-factor loop
    unrolling^([9](ch12.xhtml#fn12_9)) compared to adding the `-funroll-loops` and
    `-funroll -all-loops` compiler optimization flags to the previous program.⁷
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的可读性也因此降低。更好的使用循环展开的方法是调用`-funroll-loops`编译器优化标志，这个标志告诉编译器展开那些可以在编译时确定迭代次数的循环。`-funroll-all-loops`编译器标志是一个更激进的选项，它会展开所有循环，无论编译器是否确定迭代次数。[表12-4](ch12.xhtml#ch12tab4)展示了手动2因子循环展开^([9](ch12.xhtml#fn12_9))与将`-funroll-loops`和`-funroll-all-loops`编译器优化标志添加到之前程序中的运行时对比。
- en: '**Table 12-4:** Time in Seconds to Produce 5,000,000 Prime Numbers'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**表12-4：** 生成5,000,000个质数所需的时间（秒）'
- en: '| **Version** | **File** | **Unoptimized** | -O1 | -O2 | -O3 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **版本** | **文件** | **未优化** | -O1 | -O2 | -O3 |'
- en: '| Original | `optExample.c` | 3.86 | 2.32 | 2.14 | 2.15 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 原始版本 | `optExample.c` | 3.86 | 2.32 | 2.14 | 2.15 |'
- en: '| Loop-invariant code motion | `optExample2.c` | 1.83 | 1.63 | 1.71 | 1.63
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 循环不变代码移动 | `optExample2.c` | 1.83 | 1.63 | 1.71 | 1.63 |'
- en: '| Manual factor-of-two loop | `optExample3.c` | 1.65 | 1.53 | 1.45 | 1.45 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 手动二分循环 | `optExample3.c` | 1.65 | 1.53 | 1.45 | 1.45 |'
- en: '| unrolling |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 循环展开 |'
- en: '| `-funroll-loops` | `optExample2.c` | 1.82 | 1.48 | 1.46 | 1.46 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `-funroll-loops` | `optExample2.c` | 1.82 | 1.48 | 1.46 | 1.46 |'
- en: '| `-funroll-all-loops` | `optExample2.c` | 1.81 | 1.47 | 1.47 | 1.46 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `-funroll-all-loops` | `optExample2.c` | 1.81 | 1.47 | 1.47 | 1.46 |'
- en: Manual loop unrolling does result in some performance improvement; however the
    compiler’s built-in loop unrolling flags when combined with the other optimization
    flags yield comparable performance. If a programmer wants to incorporate loop
    unrolling optimizations into their code, they should default to using the appropriate
    compiler flags, and *not* manually unroll loops themselves.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 手动循环展开确实能带来一些性能提升；然而，当编译器的内建循环展开标志与其他优化标志结合使用时，能够实现相当的性能表现。如果程序员希望将循环展开优化融入到他们的代码中，应该默认使用适当的编译器标志，而*不*手动展开循环。
- en: 12.3 Memory Considerations
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3 内存考虑
- en: Programmers should pay special attention to memory use, especially when employing
    memory-intensive data structures such as matrices and arrays. Although compilers
    offer powerful optimization features, the compiler cannot always make optimizations
    that improve a program’s memory use. In this section, we use an implementation
    of a matrix-vector program `matrixVector.c`^([10](ch12.xhtml#fn12_10)) to guide
    discussion of techniques and tools for improving memory use.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员应特别注意内存使用，特别是在使用像矩阵和数组这样的内存密集型数据结构时。尽管编译器提供了强大的优化功能，但编译器并非总是能做出改善程序内存使用的优化。在本节中，我们使用一个矩阵-向量程序`matrixVector.c`的实现^([10](ch12.xhtml#fn12_10))来引导讨论提高内存使用的技术和工具。
- en: 'The `main` function of the program performs two steps. First, it allocates
    and initializes the input matrix, the input vector, and the output matrix. Next,
    it performs matrix-vector multiplication. Running the code on matrix-vector dimensions
    of 10,000 × 10,000 reveals that the `matrixVectorMultiply` function takes up the
    majority of the time:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的`main`函数执行两个步骤。首先，它分配并初始化输入矩阵、输入向量和输出矩阵。接下来，它执行矩阵-向量乘法。在矩阵-向量维度为10,000 ×
    10,000时运行代码，结果表明`matrixVectorMultiply`函数占用了大部分时间：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our discussion will thus focus on the `matrixVectorMultiply` function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的讨论将集中在`matrixVectorMultiply`函数上。
- en: 12.3.1 Loop Interchange
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.1 循环交换
- en: 'Loop interchange optimizations switch the order of inner and outer loops in
    nested loops in order to maximize cache locality. Automatically performing this
    task is difficult for compilers to do. In GCC, the `-floop-interchange` compiler
    flag exists but is currently not available by default. Therefore, it is a good
    idea for programmers to pay attention to how their code is accessing memory-composite
    data structures like arrays and matrices. As an example, let’s take a closer look
    at the `matrixVectorMultiply` function in `matrixVector.c`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 循环交换优化通过交换嵌套循环中的内外循环顺序，以最大化缓存局部性。自动执行这个任务对编译器来说是比较困难的。在GCC中，存在`-floop-interchange`编译器标志，但目前默认情况下不可用。因此，程序员应该特别注意代码如何访问内存组合数据结构，如数组和矩阵。作为示例，让我们仔细看看`matrixVector.c`中的`matrixVectorMultiply`函数：
- en: Original version
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 原始版本
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Loop interchange version
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 循环交换版本
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The input and output matrices are dynamically allocated (see “Method 2: The
    Programmer-Friendly Way” on [page 90](ch02.xhtml#lev3_17)). As a result, the rows
    in the matrices are not contiguous to one another, whereas the elements in each
    row are contiguous. The current ordering of the loops causes the program to cycle
    through each column instead of every row. Recall that data is loaded into cache
    in blocks, not elements (see “Direct-Mapped Caches” on [page 558](ch11.xhtml#lev2_193)).
    As a result, when an element *x* in an array in either `res` or `m` is accessed,
    the *elements adjacent to* x are also loaded into cache. Cycling through every
    “column” of the matrix causes more cache misses, as the cache is forced to load
    new blocks with every access. [Table 12-5](ch12.xhtml#ch12tab5) shows that adding
    optimization flags does not decrease the runtime of the function. However, simply
    switching the order of the loops (as shown in the previous code examples) makes
    the function nearly eight times faster and allows the compiler to perform additional
    optimizations.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输入和输出矩阵是动态分配的（参见“方法 2：程序员友好方式”，[第 90 页](ch02.xhtml#lev3_17)）。因此，矩阵中的行并不彼此连续，而每行中的元素是连续的。当前的循环顺序导致程序遍历每一列，而不是每一行。请记住，数据是以块而非元素的形式加载到缓存中的（参见“直接映射缓存”，[第
    558 页](ch11.xhtml#lev2_193)）。因此，当访问`res`或`m`数组中的元素*x*时，*与* x 相邻的元素也会被加载到缓存中。遍历矩阵的每一“列”会导致更多的缓存未命中，因为每次访问时缓存都需要加载新的数据块。[表
    12-5](ch12.xhtml#ch12tab5)显示，添加优化标志并不会减少函数的运行时间。然而，仅仅交换循环的顺序（如前面的代码示例所示）使得函数速度几乎提高了八倍，并且允许编译器执行额外的优化。
- en: '**Table 12-5:** Time in Seconds to Perform Matrix Multiplication on 10,000
    × 10,000 Elements'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-5：** 在 10,000 × 10,000 元素上执行矩阵乘法的秒数'
- en: '| **Version** | **Program** | **Unoptimized** | -O1 | -O2 | -O3 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **版本** | **程序** | **未优化** | -O1 | -O2 | -O3 |'
- en: '| Original | `matrixVector` | 2.01 | 2.05 | 2.07 | 2.08 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 原始 | `matrixVector` | 2.01 | 2.05 | 2.07 | 2.08 |'
- en: '| Loop interchange | `matrixVector2` | 0.27 | 0.08 | 0.06 | 0.06 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 循环交换 | `matrixVector2` | 0.27 | 0.08 | 0.06 | 0.06 |'
- en: The Valgrind tool `cachegrind` (discussed in “Cache Analysis and Valgrind” on
    [page 575](ch11.xhtml#lev1_90)) is a great way to identify data locality issues,
    and reveals the cache access differences in the two versions of the `matrixVectorMultiply`
    function shown in the previous example.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind 工具 `cachegrind`（在“缓存分析与 Valgrind”中讨论，参见 [第 575 页](ch11.xhtml#lev1_90)）是识别数据局部性问题的一个很好的工具，并揭示了在前面示例中展示的两种
    `matrixVectorMultiply` 函数版本之间的缓存访问差异。
- en: '12.3.2 Some Other Compiler Optimizations for Improving Locality: Fission and
    Fusion'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.2 改善局部性的一些其他编译器优化：分裂与融合
- en: 'Rerunning the improved program on 10,000 × 10,000 elements yields the following
    runtime numbers:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行改进后的程序，使用 10,000 × 10,000 个元素，得到以下运行时间数据：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, matrix allocation and filling takes the most time. Additional timing reveals
    that it is the filling of the matrices that in fact takes the most time. Let’s
    take a closer look at that code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，矩阵的分配和填充占用了最多的时间。进一步的计时显示，实际上是矩阵的填充过程花费了最多时间。我们来仔细看看这段代码：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To fill the input and output matrices, a `for` loop cycles through all the
    rows, and calls the `fillArrayRandom` and `fillArrayZeros` functions on each matrix.
    In some scenarios, it may be advantageous for the compiler to split the single
    loop into two separate loops (known as *loop fission*), as shown here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充输入和输出矩阵，一个`for`循环遍历所有的行，并在每个矩阵上调用`fillArrayRandom`和`fillArrayZeros`函数。在某些情况下，编译器将单个循环拆分成两个独立的循环（称为*循环分裂*）可能是有利的，如下所示：
- en: Original version
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 原始版本
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With loop fission
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环分裂
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The process of taking two loops that operate over the same range and combining
    their contents into a single loop (i.e., the opposite of loop fission) is called
    *loop fusion*. Loop fission and fusion are examples of optimizations a compiler
    might perform to try to improve data locality. Compilers for multicore processors
    may also use loop fission or fusion to enable loops to execute efficiently on
    multiple cores. For example, a compiler may use loop fission to assign two loops
    to different cores. Likewise, a compiler may use loop fusion to combine together
    dependent operations into the body of the loop and distribute to each core a subset
    of the loop iterations (assuming data between iterations are independent).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个对相同范围操作的循环合并成一个循环的过程（即循环裂解的反过程）被称为*循环融合*。循环裂解和融合是编译器可能进行的优化示例，目的是提高数据局部性。多核处理器的编译器还可能使用循环裂解或融合，使得循环能够在多个核心上高效执行。例如，编译器可能使用循环裂解将两个循环分配给不同的核心。同样，编译器可能使用循环融合将相关操作合并到循环体内，并将循环迭代的子集分配到每个核心（假设各次迭代之间的数据是独立的）。
- en: 'In our case, applying loop fission manually does not directly improve program
    performance; there is virtually no change in the amount of time required to fill
    the array. However, it may reveal a more subtle optimization: the loop containing
    `fillArrayZeros` is not necessary. The `matrixVectorMultiply` function assigns
    values to each element in the `result` array; a prior initialization to all zeros
    is unnecessary.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，手动应用循环裂解并不会直接改善程序性能；填充数组所需的时间几乎没有变化。然而，这可能揭示一个更微妙的优化：包含`fillArrayZeros`的循环是多余的。`matrixVectorMultiply`函数已将值分配给`result`数组中的每个元素，因此事先将其初始化为零是不必要的。
- en: Previous version matrixVector2.c
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本matrixVector2.c
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Updated version matrixVector3.c
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的版本matrixVector3.c
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 12.3.3 Memory Profiling with Massif
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.3 使用Massif进行内存分析
- en: 'Making the previous change results in only a slight decrease in runtime. Although
    it eliminates the step of filling in all elements in the result matrix with zeros,
    a significant amount of time is still required to fill the input matrix with random
    numbers:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 做出前述更改后，运行时间仅略微下降。尽管它消除了用零填充结果矩阵中所有元素的步骤，但仍需要相当多的时间来用随机数填充输入矩阵：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Even though each array is stored noncontiguously in memory, each one takes up
    10,000 × `sizeof(int)` bytes, or 40,000 bytes. Since there is a total of 20,000
    (10,000 each for the initial matrix and the result matrix) arrays allocated, this
    corresponds to 800 million bytes, or roughly 762 MB of space. Filling 762 MB with
    random numbers understandably takes a lot of time. With matrices, memory use increases
    quadratically with the input size, and can play a large role in performance.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个数组在内存中是非连续存储的，但每个数组占用10,000 × `sizeof(int)`字节，即40,000字节。由于一共分配了20,000个数组（初始矩阵和结果矩阵各10,000个），这对应于8亿字节，约合762
    MB的空间。用随机数填充762 MB显然需要大量时间。对于矩阵而言，内存使用量随着输入规模的增大呈平方增长，因此在性能中可能起到重要作用。
- en: 'Valgrind’s `massif` tool can help you profile memory use. Like the other Valgrind
    tools we covered in this book (see “Debugging Memory with Valgrind” on [page 168](ch03.xhtml#lev1_22),
    “Cache Analysis and Valgrind” on [page 575](ch11.xhtml#lev1_90), and “Using Callgrind
    to Profile” on [page 600](ch12.xhtml#lev2_205)), `massif` runs as a wrapper around
    a program’s executable. Specifically, `massif` takes snapshots of program memory
    use throughout the program, and profiles how memory usage fluctuates. Programmers
    may find the `massif` tool useful for tracking how their programs use heap memory,
    and for identifying opportunities to improve memory use. Let’s run the `massif`
    tool on the `matrixVector3` executable:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind的`massif`工具可以帮助你分析内存使用情况。与本书中我们介绍的其他Valgrind工具（请参见[第168页](ch03.xhtml#lev1_22)的“使用Valgrind调试内存”、[第575页](ch11.xhtml#lev1_90)的“缓存分析与Valgrind”以及[第600页](ch12.xhtml#lev2_205)的“使用Callgrind进行性能分析”）类似，`massif`作为程序可执行文件的包装器运行。具体而言，`massif`会在程序运行过程中拍摄程序内存使用情况的快照，并分析内存使用的波动。程序员可能会发现`massif`工具对于跟踪程序如何使用堆内存，以及识别改善内存使用的机会非常有用。让我们在`matrixVector3`可执行文件上运行`massif`工具：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Running `massif` produces a `massif.out.xxxx` file, where `xxxx` is a unique
    id number. If you are typing along, type ls to reveal your corresponding massif
    file. In the example that follows, the corresponding file is `massif.out.7030`.
    Use the ms_print command to view the `massif` output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`massif`后会生成一个`massif.out.xxxx`文件，其中`xxxx`是唯一的ID编号。如果你正在跟随输入，可以输入ls命令查看对应的massif文件。在以下示例中，相关文件为`massif.out.7030`。使用ms_print命令查看`massif`输出：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At the top of the output is the memory use graph. The *x*-axis shows the number
    of instructions executed. The *y*-axis shows memory use. The graph above indicates
    that a total of 9.778 billion (Gi) instructions executed during our run of `matrixVector3`.
    During execution, `massif` took a total of 80 snapshots to measure use on the
    heap. Memory use peaked in the last snapshot (79). Peak memory use for the program
    was 763.3 MB, and stayed relatively constant throughout the program.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的顶部是内存使用图。*x* 轴表示执行的指令数量，*y* 轴表示内存使用量。上面的图表表明，在我们运行 `matrixVector3` 时，总共执行了
    97.78 亿 (Gi) 条指令。在执行过程中，`massif` 总共拍摄了 80 张快照来衡量堆内存的使用情况。内存使用在最后一张快照（79）时达到了峰值。程序的峰值内存使用为
    763.3 MB，并且在整个程序执行过程中保持相对稳定。
- en: 'Summaries of all the snapshots occur after the graph. For example, the following
    table corresponds to the snapshots around snapshot 79:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所有快照的摘要会出现在图表之后。例如，以下表格对应的是第 79 张快照前后的数据：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Each row corresponds to a particular snapshot, the time it was taken, the total
    heap memory consumption (in bytes) at that point, the number of bytes requested
    by the program ("useful-heap") at that point, the number of bytes allocated in
    excess of what the program asked for, and the size of the stack. By default, stack
    profiling is off (it slows `massif` down significantly). To enable stack profiling,
    use the `--stacks=yes` option when running `massif`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行对应一个特定的快照，包括快照的时间点、此时的总堆内存消耗（以字节为单位）、程序请求的字节数（"useful-heap"）、程序请求字节数的超额分配部分，以及堆栈的大小。默认情况下，堆栈分析是关闭的（这会显著减慢
    `massif` 的速度）。要启用堆栈分析，可以在运行 `massif` 时使用 `--stacks=yes` 选项。
- en: The `massif` tool reveals that 99.96% of the program’s heap memory use occurred
    in the `allocateArray` function and that a total of 800 million bytes were allocated,
    consistent with the back-of-the-envelope calculation we performed earlier. Readers
    will likely find `massif` a useful tool for identifying areas of high heap memory
    use in their programs, which often slows a program down. For example, *memory
    leaks* can occur in programs when programmers frequently call `malloc` without
    calling `free` at the first correct opportunity. The `massif` tool is incredibly
    useful for detecting such leaks.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`massif` 工具显示，99.96% 的程序堆内存使用发生在 `allocateArray` 函数中，总共分配了 8 亿字节内存，这与我们之前做的粗略计算一致。读者可能会发现
    `massif` 是一个有用的工具，可以帮助识别程序中堆内存使用高的地方，而这些地方通常会导致程序变慢。例如，*内存泄漏* 在程序中可能会发生，当程序员频繁调用
    `malloc` 而没有在首次正确的机会调用 `free` 时。`massif` 工具对于检测此类内存泄漏非常有用。'
- en: 12.4 Key Takeaways and Summary
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4 关键要点与总结
- en: 'Our short (and perhaps frustrating) journey into code optimization should convey
    one very important message to the reader: if you are thinking about manually optimizing
    your code, think carefully about what is worth spending your time on and what
    should be left to the compiler. Next are some important tips to consider when
    looking to improve code performance.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们短暂的（也许是令人沮丧的）代码优化之旅应该向读者传达一个非常重要的信息：如果你打算手动优化代码，请仔细考虑什么值得花时间去做，什么应该留给编译器去处理。接下来是一些在提升代码性能时需要考虑的重要建议。
- en: Choose Good Data Structures and Algorithms
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择良好的数据结构和算法
- en: 'There is no substitute for using proper algorithms and data structures; failure
    to do so is often the top reason for poor performance in code. For example, the
    famous Sieve of Eratosthenes algorithm is a much more efficient way to generate
    prime numbers than our custom algorithm in `optExample`, and yields a significant
    improvement in performance. The following listing shows the time needed to generate
    all prime numbers between 2 and 5 million using an implementation of the sieve:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用合适的算法和数据结构是无法替代的；不这样做通常是代码性能差的主要原因。例如，著名的埃拉托斯特尼筛法（Sieve of Eratosthenes）算法比我们在
    `optExample` 中的自定义算法生成素数的效率要高得多，且显著提高了性能。以下列出了使用筛法实现生成 2 到 500 万之间所有素数所需的时间：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The sieve algorithm requires only 0.12 seconds to find all the prime numbers
    between 2 and 5 million, compared to the 1.46 seconds it takes `optExample2` to
    generate the same set of primes with the `-O3` optimization flags turned on (12×
    improvement). The implementation of the sieve algorithm is left as an exercise
    for the reader; however, it should be clear that choosing a better algorithm up
    front would have saved hours of tedious optimization effort. Our example demonstrates
    why a knowledge of data structures and algorithms is foundational for computer
    scientists.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 筛选算法只需 0.12 秒即可找出 2 到 500 万之间的所有质数，而 `optExample2` 在开启 `-O3` 优化标志时，生成相同的质数集需要
    1.46 秒（提高了 12 倍）。筛选算法的实现留作读者练习；然而，应该清楚的是，提前选择更好的算法可以节省数小时的繁琐优化工作。我们的示例展示了为什么了解数据结构和算法对计算机科学家来说至关重要。
- en: Use Standard Library Functions Whenever Possible
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 尽可能使用标准库函数
- en: Don’t reinvent the wheel. If in the course of programming you need a function
    that should do something very standard (e.g., find the absolute value, or find
    the maximum or minimum of a list of numbers), stop and check to see whether the
    function already exists as part of the higher-level language’s standard library.
    Functions in the standard libraries are well tested and tend to be optimized for
    performance. For example, if a reader manually implements their own version of
    the `sqrt` function, the compiler may not know to automatically replace the function
    call with the `fsqrt` instruction.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不要重复造轮子。如果在编程过程中，你需要一个应该做某件非常标准化的事情的函数（例如，求绝对值，或者求一组数字的最大值或最小值），停下来检查一下，看看该函数是否已经作为更高层语言的标准库的一部分存在。标准库中的函数经过充分测试，通常经过性能优化。例如，如果读者手动实现了自己的
    `sqrt` 函数，编译器可能不知道自动用 `fsqrt` 指令替换该函数调用。
- en: Optimize Based on Data and Not on Feelings
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于数据进行优化，而非凭感觉
- en: If after choosing the best data structures and algorithms *and* employing standard
    library functions, additional improvements in performance are required, enlist
    the help of a good code profiler like Valgrind. Optimization should *never* be
    based on gut feelings. Concentrating too much on what one *feels* should be optimized
    (without the data to back up the thought) often leads to wasted time.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在选择了最佳数据结构和算法 *并且* 使用了标准库函数后，仍然需要进一步提高性能，请借助像 Valgrind 这样的优秀代码分析工具。优化*绝不*应该基于直觉。过于关注自己“感觉”应该优化的部分（而没有数据支持这一想法）通常会导致时间浪费。
- en: Split Complex Code into Multiple Functions
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将复杂的代码拆分为多个函数
- en: Manually inlining code usually does not result in a sizable performance gain
    over what modern compilers can achieve. Instead, make it easier for your compiler
    to help optimize for you. Compilers have an easier time optimizing shorter code
    segments. Splitting complex operations into multiple functions simultaneously
    increases code readability and makes it easier for a compiler to optimize. Check
    to see whether your compiler attempts inlining by default or has a separate flag
    to attempt inlining code. It is better to let your compiler perform inlining rather
    than manually doing it yourself.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 手动内联代码通常不会比现代编译器能实现的性能提升更大。相反，应该让编译器更容易地帮助你进行优化。编译器更容易优化较短的代码段。将复杂操作拆分为多个函数，不仅提高了代码的可读性，还让编译器更容易进行优化。检查一下你的编译器是否默认尝试内联，或者是否有独立的标志来尝试内联代码。让编译器来执行内联操作通常比手动内联更好。
- en: Prioritize Code Readability
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优先考虑代码可读性
- en: In many applications today, readability is king. The truth is that code is read
    more often than it is written. Many companies spend considerable time training
    their software engineers to write code in a very particular way to maximize readability.
    If optimizing your code results in a noticeable hit to code readability, it is
    important to check if the performance improvement obtained is worth the hit. For
    example, many compilers today have optimization flags that enable loop unrolling.
    Programmers should always use available optimization flags for loop unrolling
    instead of trying to manually unroll loops, which can lead to a significant hit
    in code readability. Reducing code readability often increases the likelihood
    that bugs are inadvertently introduced into code, which can lead to security vulnerabilities.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今许多应用程序中，可读性至关重要。事实上，代码被阅读的次数远远超过被编写的次数。许多公司花费大量时间培训他们的软件工程师，以特定的方式编写代码，以最大化可读性。如果优化代码导致可读性显著降低，请检查所获得的性能改进是否值得。例如，许多编译器今天都有启用循环展开的优化标志。程序员应始终使用可用的循环展开优化标志，而不是尝试手动展开循环，这可能会显著降低代码的可读性。降低代码的可读性通常会增加无意中引入代码中的错误的可能性，这可能导致安全漏洞。
- en: Pay Attention to Memory Use
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意内存使用
- en: A program’s memory usage often has a bigger impact on the program’s execution
    time than the number of instructions that it executes. The loop interchange example
    exemplifies this point. In both cases, the loop executes the same number of instructions.
    However, the ordering of the loops has a significant impact on memory access and
    locality. Remember to also explore memory profiling tools like `massif` and `cachegrind`
    when attempting to optimize a program.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的内存使用对程序的执行时间影响更大，而不是它执行的指令数量。循环置换示例就是一个例子。在两种情况下，循环执行相同数量的指令。然而，循环的顺序对内存访问和局部性有显著影响。在尝试优化程序时，还要探索像`massif`和`cachegrind`这样的内存分析工具。
- en: Compilers Are Constantly Improving
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编译器不断改进
- en: Compiler writers continually update compilers to perform more sophisticated
    optimizations safely. For example, GCC switched to the static single assignment
    (SSA) form^([11](ch12.xhtml#fn12_11)) starting in version 4.0, which significantly
    improved the effects of some of its optimizations. The `GRAPHITE` branch of the
    GCC code base implements the polyhedral model,^([12](ch12.xhtml#fn12_12)) which
    allows the compiler to perform more complex types of loop transformations. As
    compilers become more sophisticated, the benefits of manual optimization significantly
    decrease.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器编写者持续更新编译器，以安全地执行更复杂的优化。例如，GCC从4.0版本开始切换到静态单赋值（SSA）形式^([11](ch12.xhtml#fn12_11))，显著改进了部分优化效果。GCC代码库的`GRAPHITE`分支实现了多面体模型^([12](ch12.xhtml#fn12_12))，使编译器能够执行更复杂的循环转换类型。随着编译器变得更加复杂，手动优化的好处显著减少。
- en: Notes
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: '[1.](ch12.xhtml#rfn12_1) *[https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html)*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[1.](ch12.xhtml#rfn12_1) *[https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html)*'
- en: '[2.](ch12.xhtml#rfn12_2) John Regehr, “A Guide to Undefined Behavior in C and
    C++, Part 1,” *[https://blog.regehr.org/archives/213](https://blog.regehr.org/archives/213)*,
    2010.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[2.](ch12.xhtml#rfn12_2) John Regehr，“C和C++中未定义行为指南，第1部分”，*[https://blog.regehr.org/archives/213](https://blog.regehr.org/archives/213)*，2010年。'
- en: '[3.](ch12.xhtml#rfn12_3) C FAQ, “comp.lang.c FAQ list: Question 11.33,” *[http://c-faq.com/ansi/undef.html](http://c-faq.com/ansi/undef.html)*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[3.](ch12.xhtml#rfn12_3) C FAQ，“comp.lang.c FAQ list: Question 11.33”，*[http://c-faq.com/ansi/undef.html](http://c-faq.com/ansi/undef.html)*'
- en: '[4.](ch12.xhtml#rfn12_4) John Regehr, “A Guide to Undefined Behavior in C and
    C++, Part 1,” *[https://blog.regehr.org/archives/213](https://blog.regehr.org/archives/213)*,
    2010.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[4.](ch12.xhtml#rfn12_4) John Regehr，“C和C++中未定义行为指南，第1部分”，*[https://blog.regehr.org/archives/213](https://blog.regehr.org/archives/213)*，2010年。'
- en: '[5.](ch12.xhtml#rfn12_5) Source code available at *[https://diveintosystems.org/book/C12-CodeOpt/_attachments/optExample.c](https://diveintosystems.org/book/C12-CodeOpt/_attachments/optExample.c)*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[5.](ch12.xhtml#rfn12_5) 源代码可在*[https://diveintosystems.org/book/C12-CodeOpt/_attachments/optExample.c](https://diveintosystems.org/book/C12-CodeOpt/_attachments/optExample.c)*找到'
- en: '[6.](ch12.xhtml#rfn12_6) *[http://valgrind.org/](http://valgrind.org/)*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.](ch12.xhtml#rfn12_6) *[http://valgrind.org/](http://valgrind.org/)*'
- en: '[7.](ch12.xhtml#rfn12_7) *[https://diveintosystems.org/book/C12-CodeOpt/_attachments/optExample2.c](https://diveintosystems.org/book/C12-CodeOpt/_attachments/optExample2.c)*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[7.](ch12.xhtml#rfn12_7) *[https://diveintosystems.org/book/C12-CodeOpt/_attachments/optExample2.c](https://diveintosystems.org/book/C12-CodeOpt/_attachments/optExample2.c)*'
- en: '[8.](ch12.xhtml#rfn12_8) *[https://diveintosystems.org/book/C12-CodeOpt/_attachments/optExample3.c](https://diveintosystems.org/book/C12-CodeOpt/_attachments/optExample3.c)*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[8.](ch12.xhtml#rfn12_8) *[https://diveintosystems.org/book/C12-CodeOpt/_attachments/optExample3.c](https://diveintosystems.org/book/C12-CodeOpt/_attachments/optExample3.c)*'
- en: '[9.](ch12.xhtml#rfn12_9) *[https://diveintosystems.org/book/C12-CodeOpt/_attachments/optExample3.c](https://diveintosystems.org/book/C12-CodeOpt/_attachments/optExample3.c)*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.](ch12.xhtml#rfn12_9) *[https://diveintosystems.org/book/C12-CodeOpt/_attachments/optExample3.c](https://diveintosystems.org/book/C12-CodeOpt/_attachments/optExample3.c)*'
- en: '[10.](ch12.xhtml#rfn12_10) *[https://diveintosystems.org/book/C12-CodeOpt/_attachments/matrixVector.c](https://diveintosystems.org/book/C12-CodeOpt/_attachments/matrixVector.c)*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[10.](ch12.xhtml#rfn12_10) *[https://diveintosystems.org/book/C12-CodeOpt/_attachments/matrixVector.c](https://diveintosystems.org/book/C12-CodeOpt/_attachments/matrixVector.c)*'
- en: '[11.](ch12.xhtml#rfn12_11) *[https://gcc.gnu.org/onlinedocs/gccint/SSA.html](https://gcc.gnu.org/onlinedocs/gccint/SSA.html)*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[11.](ch12.xhtml#rfn12_11) *[https://gcc.gnu.org/onlinedocs/gccint/SSA.html](https://gcc.gnu.org/onlinedocs/gccint/SSA.html)*'
- en: '[12.](ch12.xhtml#rfn12_12) *[https://polyhedral.info/](https://polyhedral.info/)*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[12.](ch12.xhtml#rfn12_12) *[https://polyhedral.info/](https://polyhedral.info/)*'
