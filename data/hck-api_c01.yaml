- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: How Web Applications Work
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用程序如何工作
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Before you can hack APIs, you must understand the technologies that support
    them. In this chapter, I will cover everything you need to know about web applications,
    including the fundamental aspects of HyperText Transfer Protocol (HTTP), authentication
    and authorization, and common web server databases. Because web APIs are powered
    by these technologies, understanding these basics will prepare you for using and
    hacking APIs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够破解 API 之前，必须了解支持它们的技术。在本章中，我将涵盖你需要了解的关于 Web 应用程序的所有内容，包括超文本传输协议（HTTP）的基本方面、身份验证与授权以及常见的
    Web 服务器数据库。因为 Web API 是由这些技术驱动的，所以理解这些基础知识将为你使用和破解 API 做好准备。
- en: Web App Basics
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web 应用程序基础
- en: 'Web applications function based on the client/server model: your web browser,
    the client, generates requests for resources and sends these to computers called
    web servers. In turn, these web servers send resources to the clients over a network.
    The term *web application* refers to software that is running on a web server,
    such as Wikipedia, LinkedIn, Twitter, Gmail, GitHub, and Reddit.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用程序基于客户端/服务器模型运行：你的 Web 浏览器，作为客户端，生成对资源的请求并将其发送到称为 Web 服务器的计算机。这些 Web 服务器再通过网络将资源发送回客户端。*Web
    应用程序*一词指的是运行在 Web 服务器上的软件，如 Wikipedia、LinkedIn、Twitter、Gmail、GitHub 和 Reddit。
- en: In particular, web applications are designed for end-user interactivity. Whereas
    websites are typically read-only and provide one-way communication from the web
    server to the client, web applications allow communications to flow in both directions,
    from server to client and from client to server. Reddit, for example, is a web
    app that acts as a newsfeed of information flowing around the internet. If it
    were merely a website, visitors would be spoon-fed whatever content the organization
    behind the site provided. Instead, Reddit allows users to interact with the information
    on the site by posting, upvoting, downvoting, commenting, sharing, reporting bad
    posts, and customizing their newsfeeds with subreddits they want to see. These
    features differentiate Reddit from a static website.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是，Web 应用程序是为最终用户交互而设计的。而网站通常是只读的，仅提供从 Web 服务器到客户端的单向通信，Web 应用程序则允许通信双向流动，从服务器到客户端以及从客户端到服务器。例如，Reddit
    是一个作为信息流动的新闻源的 Web 应用程序。如果它仅仅是一个网站，访客只能接收网站背后组织提供的内容。而 Reddit 允许用户通过发布、点赞、点踩、评论、分享、举报不良帖子以及通过订阅自己想看的子版块来自定义他们的新闻源，从而与站点上的信息进行交互。这些功能将
    Reddit 与静态网站区分开来。
- en: For an end user to begin using a web application, a conversation must take place
    between the web browser and a web server. The end user initiates this conversation
    by entering a URL into their browser address bar. In this section, we’ll discuss
    what happens next.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让最终用户开始使用 Web 应用程序，必须在 Web 浏览器和 Web 服务器之间进行一次对话。最终用户通过在浏览器地址栏中输入 URL 来启动这次对话。在本节中，我们将讨论接下来会发生什么。
- en: The URL
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: URL
- en: 'You probably already know that the *uniform resource locator (URL)* is the
    address used to locate unique resources on the internet. This URL consists of
    several components that you’ll find helpful to understand when crafting API requests
    in later chapters. All URLs include the protocol used, the hostname, the port,
    the path, and any query parameters:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经知道，*统一资源定位符 (URL)* 是用于定位互联网上唯一资源的地址。这个 URL 由几个组件组成，在后面的章节中，你会发现了解它们对编写
    API 请求非常有帮助。所有的 URL 都包含使用的协议、主机名、端口、路径以及任何查询参数：
- en: Protocol://hostname[:port number]/[path]/[?query][parameters]
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 协议://主机名[:端口号]/[路径]/[?查询][参数]
- en: '*Protocols* are the sets of rules computers use to communicate. The primary
    protocols used within the URL are HTTP/HTTPS for web pages and FTP for file transfers.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*协议*是计算机用来通信的一组规则。URL 中使用的主要协议是 HTTP/HTTPS 用于网页，FTP 用于文件传输。'
- en: 'The *port*, a number that specifies a communication channel, is only included
    if the host does not automatically resolve the request to the proper port. Typically,
    HTTP communications take place over port 80\. HTTPS, the encrypted version of
    HTTP, uses port 443, and FTP uses port 21\. To access a web app that is hosted
    on a nonstandard port, you can include the port number in the URL, like so: *https://www.example.com:8443*.
    (Ports 8080 and 8443 are common alternatives for HTTP and HTTPS, respectively.)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*端口*是指定通信通道的数字，只有在主机无法自动将请求解析到正确端口时才会包含。通常，HTTP通信使用80端口。HTTP的加密版本HTTPS使用443端口，而FTP使用21端口。要访问托管在非标准端口上的Web应用程序，可以在URL中包含端口号，如：*https://www.example.com:8443*。（端口8080和8443分别是HTTP和HTTPS的常见替代端口。）'
- en: The file directory *path* on the web server points to the location of the web
    pages and files specified in the URL. The path used in a URL is the same as a
    filepath used to locate files on a computer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器上的文件目录*路径*指向URL中指定的网页和文件的位置。URL中使用的路径与计算机中定位文件的文件路径相同。
- en: The *query* is an optional part of the URL used to perform functionality such
    as searching, filtering, and translating the language of the requested information.
    The web application provider may also use the query strings to track certain information
    such as the URL that referred you to the web page, your session ID, or your email.
    It starts with a question mark and contains a string that the server is programmed
    to process. Finally, the *query parameters* are the values that describe what
    should be done with the given query. For example, the query parameter `lang=en`
    following the query `page?` might indicate to the web server that it should provide
    the requested page in English. These parameters consist of another string to be
    processed by the web server. A query can contain multiple parameters separated
    by an ampersand (`&`).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询*是URL中的可选部分，用于执行如搜索、过滤和翻译请求信息语言等功能。网络应用提供商还可能使用查询字符串来跟踪某些信息，如指向该网页的URL、您的会话ID或您的电子邮件。查询部分以问号开始，包含服务器被编程处理的字符串。最后，*查询参数*是描述如何处理给定查询的值。例如，查询`page?`后的查询参数`lang=en`可能表明网络服务器应提供英文版的请求页面。这些参数由另一个字符串组成，供服务器处理。查询可以包含多个用符号&（`&`）分隔的参数。'
- en: To make this information more concrete, consider the URL [https://twitter.com/search?q=hacking&src=typed_query](https://twitter.com/search?q=hacking&src=typed_query).
    In this example, the protocol is *https*, the hostname is *twitter.com*, the path
    is *search*, the query is *?q* (which stands for query), the query parameter is
    *hacking*, and *src=typed_query* is a tracking parameter. This URL is automatically
    built whenever you click the search bar in the Twitter web app, type in the search
    term “hacking,” and press enter. The browser is programmed to form the URL in
    a way that will be understood by the Twitter web server, and it collects some
    tracking information in the form of the `src` parameter. The web server will receive
    the request for hacking content and respond with hacking-related information.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些信息更具具体性，考虑以下URL：[https://twitter.com/search?q=hacking&src=typed_query](https://twitter.com/search?q=hacking&src=typed_query)。在这个例子中，协议是*https*，主机名是*twitter.com*，路径是*search*，查询是*q*（表示查询），查询参数是*hacking*，*src=typed_query*是一个跟踪参数。每当你在Twitter
    Web应用程序中点击搜索框，输入“hacking”并按下回车时，这个URL就会自动生成。浏览器被编程为以Twitter Web服务器能够理解的方式形成URL，并收集一些以`src`参数形式的跟踪信息。Web服务器将接收到关于黑客内容的请求，并返回与黑客相关的信息。
- en: HTTP Requests
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP请求
- en: When an end user navigates to a URL using a web browser, the browser automatically
    generates an HTTP *request* for a resource. This resource is the information being
    requested—typically the files that make up a web page. The request is routed across
    the internet or network to the web server, where it is initially processed. If
    the request is properly formed, the web server passes the request to the web application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当最终用户通过Web浏览器访问URL时，浏览器会自动生成一个HTTP*请求*来获取资源。这个资源就是被请求的信息——通常是构成网页的文件。请求通过互联网或网络路由到Web服务器，在那里进行初步处理。如果请求格式正确，Web服务器将请求传递给Web应用程序。
- en: '[Listing 1-1](#listing1-1) shows the components of an HTTP request sent when
    authenticating to *twitter.com*.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表1-1](#listing1-1)显示了在向*twitter.com*进行认证时发送的HTTP请求的组成部分。'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 1-1: An HTTP request to authenticate with *twitter**.com*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1-1：一个用于与*twitter.com*认证的HTTP请求
- en: HTTP requests start with the method ❶, the path of the requested resource ❷,
    and the protocol version ❸. The method, described in the “HTTP Methods” section
    later in this chapter, tells the server what you want to do. In this case, you
    use the POST method to send your login credentials to the server. The path may
    contain either the entire URL, the absolute path, or the relative path of a resource.
    In this request, the path, */sessions*, specifies the page that handles Twitter
    authentication requests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求以方法 ❶、请求资源的路径 ❷ 和协议版本 ❸ 开始。方法在本章后面的“HTTP 方法”部分中进行描述，告诉服务器你想做什么。在这种情况下，你使用
    POST 方法将登录凭证发送到服务器。路径可以包含完整的 URL、绝对路径或资源的相对路径。在这个请求中，路径 */sessions* 指定了处理 Twitter
    身份验证请求的页面。
- en: Requests include several *headers*, which are key-value pairs that communicate
    specific information between the client and the web server. Headers begin with
    the header’s name, followed by a colon (`:`) and then the value of the header.
    The `Host` header ❹ designates the domain host, *twitter.com*. The `User-Agent`
    header describes the client’s browser and operating system. The `Accept` headers
    describe which types of content the browser can accept from the web application
    in a response. Not all headers are required, and the client and server may include
    others not shown here, depending on the request. For example, this request includes
    a `Cookie` header, which is used between the client and server to establish a
    stateful connection (more on this later in the chapter). If you’d like to learn
    more about all the different headers, check out Mozilla’s developer page on headers
    ([https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请求包含若干 *头部*，它们是键值对，用于在客户端和 Web 服务器之间传递特定信息。头部以头部的名称开头，后跟冒号（`:`），然后是头部的值。`Host`
    头部 ❹ 指定了域名主机，*twitter.com*。`User-Agent` 头部描述了客户端的浏览器和操作系统。`Accept` 头部描述了浏览器可以接受
    Web 应用程序在响应中返回的内容类型。并非所有头部都是必需的，客户端和服务器可能会包括未在此处显示的其他头部，具体取决于请求。例如，这个请求包括一个 `Cookie`
    头部，它用于客户端和服务器之间建立有状态连接（稍后在本章中会讨论）。如果你想了解更多关于所有不同头部的内容，可以查看 Mozilla 开发者页面上的头部文档（[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)）。
- en: Anything below the headers is the *message body*, which is the information that
    the requestor is attempting to have processed by the web application. In this
    case, the body consists of the username ❺ and password ❻ used to authenticate
    to a Twitter account. Certain characters in the body are automatically encoded.
    For example, exclamation marks (`!`) are encoded as `%21` ❼. Encoding characters
    is one way that a web application may securely handle characters that could cause
    problems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在头部以下的部分是 *消息体*，它是请求方试图让 Web 应用程序处理的信息。在这种情况下，消息体包含了用于身份验证 Twitter 帐号的用户名
    ❺ 和密码 ❻。消息体中的某些字符会自动进行编码。例如，感叹号（`!`）会被编码为 `%21` ❼。编码字符是 Web 应用程序安全处理可能引起问题的字符的一种方式。
- en: HTTP Responses
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 响应
- en: After a web server receives an HTTP request, it will process and respond to
    the request. The type of response depends on the availability of the resource,
    the user’s authorization to access the resource, the health of the web server,
    and other factors. For example, [Listing 1-2](#listing1-2) shows the response
    to the request in [Listing 1-1](#listing1-1).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 服务器收到 HTTP 请求后，它会处理并响应该请求。响应的类型取决于资源的可用性、用户是否有权限访问该资源、Web 服务器的健康状况以及其他因素。例如，[清单
    1-2](#listing1-2) 显示了对 [清单 1-1](#listing1-1) 中请求的响应。
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 1-2: An example of an HTTP response when authenticating to *twitter**.com*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-2：身份验证到 *twitter.com* 的 HTTP 响应示例
- en: The web server first responds with the protocol version in use (in this case,
    HTTP/1.1 ❶). HTTP 1.1 is currently the standard version of HTTP used. The status
    code and status message ❷, discussed in more detail in the next section, are 302
    Found. The 302 response code indicates that the client successfully authenticated
    and will be redirected to a landing page the client is authorized to access.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务器首先以使用的协议版本作出响应（在这种情况下是 HTTP/1.1 ❶）。HTTP 1.1 目前是使用的标准 HTTP 版本。状态码和状态消息
    ❷，在下一部分中会更详细地讨论，是 302 Found。302 响应码表示客户端已成功身份验证，并将被重定向到客户端被授权访问的登陆页面。
- en: Notice that, like HTTP request headers, there are HTTP response headers. HTTP
    response headers often provide the browser with instructions for handling the
    response and security requirements. The `set-cookie` header is another indication
    that the authentication request was successful, because the web server has issued
    a cookie that includes an `auth_token`, which the client can use to access certain
    resources. The response message body will follow the empty line after the response
    headers. In this case, the web server has sent an HTML message indicating that
    the client is being redirected to a new web page.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，像 HTTP 请求头一样，也有 HTTP 响应头。HTTP 响应头通常为浏览器提供处理响应和安全要求的指令。`set-cookie`头是另一个指示身份验证请求成功的标志，因为
    Web 服务器已经发出了包含`auth_token`的 Cookie，客户端可以使用该 Cookie 访问某些资源。响应消息正文将紧随响应头后的空行之后。在这个案例中，Web
    服务器发送了一条 HTML 消息，表示客户端正在被重定向到一个新网页。
- en: The request and response I’ve shown here illustrates a common way in which a
    web application restricts access to its resources through the use of authentication
    and authorization. Web *authentication* is the process of proving your identity
    to a web server. Common forms of authentication include providing a password,
    token, or biometric information (such as a fingerprint). If a web server approves
    an authentication request, it will respond by providing the authenticated user
    *authorization* to access certain resources. In [Listing 1-1](#listing1-1), we
    saw an authentication request to a Twitter web server that sent a username and
    password using a POST request. The Twitter web server responded to the successful
    authentication request with 302 Found (in [Listing 1-2](#listing1-2)). The session
    `auth_token` in the `set-cookie` header authorized access to the resources associated
    with the hAPI_hacker Twitter account.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里展示的请求和响应展示了 Web 应用程序通过使用身份验证和授权来限制对其资源的访问的常见方式。Web *身份验证*是向 Web 服务器证明你身份的过程。常见的身份验证方式包括提供密码、令牌或生物特征信息（例如指纹）。如果
    Web 服务器批准身份验证请求，它将通过提供已认证用户的*授权*来允许访问特定资源。在[清单 1-1](#listing1-1)中，我们看到向 Twitter
    Web 服务器发出的身份验证请求，它通过 POST 请求发送了用户名和密码。Twitter Web 服务器通过 302 Found 响应成功的身份验证请求（见[清单
    1-2](#listing1-2)）。`set-cookie`头中的会话`auth_token`授权访问与 hAPI_hacker Twitter 账户相关的资源。
- en: HTTP Status Codes
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 状态码
- en: When a web server responds to a request, it issues a response status code, along
    with a response message. The response code signals how the web server has handled
    the request. At a high level, the response code determines if the client will
    be allowed or denied access to a resource. It can also indicate that a resource
    does not exist, there is a problem with the web server, or requesting the given
    resource has resulted in being redirected to another location.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Web 服务器响应请求时，它会发出响应状态码以及响应消息。响应代码表示 Web 服务器如何处理请求。高层次来看，响应代码决定了客户端是否被允许或拒绝访问资源。它还可以指示资源不存在，Web
    服务器出现问题，或者请求的资源已经被重定向到其他位置。
- en: Listings 1-3 and 1-4 illustrate the difference between a 200 response and a
    404 response, respectively.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-3 和 1-4 分别展示了 200 响应和 404 响应之间的区别。
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 1-3: An example of a 200 response'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-3：200 响应的示例
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 1-4: An example of a 404 response'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-4：404 响应的示例
- en: The 200 OK response will provide the client with access to the requested resource,
    whereas the 404 Not Found response will either provide the client with some sort
    of error page or a blank page, because the requested resource was not found.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 200 OK 响应将为客户端提供请求的资源访问权限，而 404 Not Found 响应则会提供某种错误页面或空白页面，因为请求的资源未找到。
- en: Since web APIs primarily function using HTTP, it is important to understand
    the sorts of response codes you should expect to receive from a web server, as
    detailed in [Table 1-1](#table1-1). For more information about individual response
    codes or about web technologies in general, check out Mozilla’s Web Docs ([https://developer.mozilla.org/en-US/docs/Web/HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)).
    Mozilla has provided a ton of useful information about the anatomy of web applications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Web API 主要通过 HTTP 进行通信，所以了解你应该从 Web 服务器接收到的响应代码类型非常重要，具体内容见[表格 1-1](#table1-1)。如果你想了解更多关于各个响应代码的信息或
    Web 技术的一般知识，可以查阅 Mozilla 的 Web 文档（[https://developer.mozilla.org/en-US/docs/Web/HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)）。Mozilla
    提供了大量关于 Web 应用程序结构的有用信息。
- en: 'Table 1-1: HTTP Response Code Ranges'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 1-1：HTTP 响应代码范围
- en: '| **Response code** | **Response type** | **Description** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **响应代码** | **响应类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 100s | Information-based responses | Responses in the 100s are typically
    related to some sort of processing status update regarding the request. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 100s | 信息类响应 | 100s 范围内的响应通常与请求的某种处理状态更新有关。 |'
- en: '| 200s | Successful responses | Responses in the 200s indicate a successful
    and accepted request. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 200s | 成功的响应 | 200s 范围内的响应表示请求成功并已被接受。 |'
- en: '| 300s | Redirects | Responses in the 300s are notifications of redirection.
    This is common to see for a request that automatically redirects you to the index/home
    page or when you request a page from port 80 HTTP to port 443 for HTTPS. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 300s | 重定向 | 300s 范围内的响应是重定向通知。通常会在自动将你重定向到索引/主页时看到，或者当你请求从端口 80 的 HTTP 页面重定向到端口
    443 的 HTTPS 页面时。 |'
- en: '| 400s | Client errors | Responses in the 400s indicate that something has
    gone wrong from the client perspective. This is often the type of response you
    will receive if you have requested a page that does not exist, if there is a timeout
    in the response, or when you are forbidden from viewing the page. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 400s | 客户端错误 | 400s 范围内的响应表示客户端出现了问题。如果你请求一个不存在的页面，或者响应超时，或者你被禁止查看某个页面时，通常会收到此类响应。
    |'
- en: '| 500s | Server errors | Responses in the 500s are indications that something
    has gone wrong with the server. These include internal server errors, unavailable
    services, and unrecognized request methods. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 500s | 服务器错误 | 500s 范围内的响应表示服务器出现了问题。这些包括内部服务器错误、服务不可用和无法识别的请求方法。 |'
- en: HTTP Methods
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 方法
- en: HTTP *methods* request information from a web server. Also known as HTTP verbs,
    the HTTP methods include GET, PUT, POST, HEAD, PATCH, OPTIONS, TRACE, and DELETE.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP *方法* 用于从 web 服务器请求信息。也称为 HTTP 动词，HTTP 方法包括 GET、PUT、POST、HEAD、PATCH、OPTIONS、TRACE
    和 DELETE。
- en: GET and POST are the two most commonly used request methods. The GET request
    is used to obtain resources from a web server, and the POST request is used to
    submit data to a web server. [Table 1-2](#table1-2) provides more in-depth information
    about each of the HTTP request methods.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: GET 和 POST 是最常用的请求方法。GET 请求用于从 web 服务器获取资源，POST 请求用于将数据提交到 web 服务器。[表 1-2](#table1-2)
    提供了每个 HTTP 请求方法的更深入信息。
- en: 'Table 1-2: HTTP Methods'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-2：HTTP 方法
- en: '| **Method** | **Purpose** |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **目的** |'
- en: '| --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GET | GET requests attempt to gather resources from the web server. This
    could be any resource, including a web page, user data, a video, an address, and
    so on. If the request is successful, the server will provide the resource; otherwise,
    the server will provide a response explaining why it was unable to get the requested
    resource. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| GET | GET 请求尝试从 web 服务器获取资源。这可以是任何资源，包括网页、用户数据、视频、地址等等。如果请求成功，服务器将提供该资源；否则，服务器将提供响应，解释为什么无法获取请求的资源。
    |'
- en: '| POST | POST requests submit data contained in the body of the request to
    a web server. This could include client records, requests to transfer money from
    one account to another, and status updates, for example. If a client submits the
    same POST request multiple times, the server will create multiple results. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| POST | POST 请求将请求体中的数据提交到 web 服务器。这可能包括客户端记录、请求从一个账户向另一个账户转账、状态更新等。例如，如果客户端多次提交相同的
    POST 请求，服务器将创建多个结果。 |'
- en: '| PUT | PUT requests instruct the web server to store submitted data under
    the requested URL. PUT is primarily used to send a resource to a web server. If
    a server accepts a PUT request, it will add the resource or completely replace
    the existing resource. If a PUT request is successful, a new URL should be created.
    If the same PUT request is submitted again, the results should remain the same.
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| PUT | PUT 请求指示 web 服务器将提交的数据存储在请求的 URL 下。PUT 主要用于向 web 服务器发送资源。如果服务器接受 PUT
    请求，它将添加资源或完全替换现有资源。如果 PUT 请求成功，应该创建一个新的 URL。如果相同的 PUT 请求再次提交，结果应该保持一致。 |'
- en: '| HEAD | HEAD requests are similar to GET requests, except they request the
    HTTP headers only, excluding the message body. This request is a quick way to
    obtain information about server status and to see if a given URL works. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| HEAD | HEAD 请求与 GET 请求类似，不同之处在于它仅请求 HTTP 头信息，不包括消息体。此请求是获取服务器状态信息并检查给定 URL
    是否有效的快速方式。 |'
- en: '| PATCH | PATCH requests are used to partially update resources with the submitted
    data. PATCH requests are likely only available if an HTTP response includes the
    `Accept-Patch` header. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| PATCH | PATCH 请求用于使用提交的数据部分更新资源。如果 HTTP 响应包含 `Accept-Patch` 头，PATCH 请求才可能可用。
    |'
- en: '| OPTIONS | OPTIONS requests are a way for the client to identify all the request
    methods allowed from a given web server. If the web server responds to an OPTIONS
    request, it should respond with all allowed request options. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| OPTIONS | OPTIONS 请求是一种客户端识别从给定 Web 服务器允许的所有请求方法的方式。如果 Web 服务器响应了 OPTIONS
    请求，它应该返回所有允许的请求选项。 |'
- en: '| TRACE | TRACE requests are primarily used for debugging input sent from the
    client to the server. TRACE asks the server to echo back the client’s original
    request, which could reveal that a mechanism is altering the client’s request
    before it is processed by the server. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| TRACE | TRACE 请求主要用于调试从客户端发送到服务器的输入。TRACE 请求让服务器回显客户端的原始请求，这可以揭示是否有机制在服务器处理请求之前更改了客户端的请求。
    |'
- en: '| CONNECT | CONNECT requests initiate a two-way network connection. When allowed,
    this request would create a proxy tunnel between the browser and web server. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| CONNECT | CONNECT 请求启动一个双向网络连接。在允许的情况下，此请求会在浏览器和 Web 服务器之间创建一个代理隧道。 |'
- en: '| DELETE | DELETE requests ask that the server remove a given resource. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| DELETE | DELETE 请求要求服务器删除给定的资源。 |'
- en: Some methods are *idempotent*, which means they can be used to send the same
    request multiple times without changing the state of a resource on a web server.
    For example, if you perform the operation of turning on a light, then the light
    turns on. When the switch is already on and you try to flip the switch on again,
    it remains on—nothing changes. GET, HEAD, PUT, OPTIONS, and DELETE are idempotent.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方法是*幂等*的，这意味着它们可以多次发送相同的请求，而不会改变服务器上资源的状态。例如，如果你执行开灯操作，那么灯会亮起来。当开关已经打开时，再次尝试打开开关，灯仍然亮着——没有任何变化。GET、HEAD、PUT、OPTIONS
    和 DELETE 方法是幂等的。
- en: On the other hand, *non-idempotent* methods can dynamically change the results
    of a resource on a server. Non-idempotent methods include POST, PATCH, and CONNECT.
    POST is the most commonly used method for changing web server resources. POST
    is used to create new resources on a web server, so if a POST request is submitted
    10 times, there will be 10 new resources on the web server. By contrast, if an
    idempotent method like PUT, typically used to update a resource, is requested
    10 times, a single resource will be overwritten 10 times.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*非幂等*方法会动态地改变服务器上资源的结果。非幂等方法包括 POST、PATCH 和 CONNECT。POST 是最常用的改变 Web 服务器资源的方法。POST
    用于在 Web 服务器上创建新资源，因此，如果提交了 10 次 POST 请求，服务器上将会有 10 个新的资源。相比之下，如果请求了一个像 PUT 这样的幂等方法，通常用于更新资源，那么即使请求了
    10 次，只有一个资源会被覆盖 10 次。
- en: DELETE is also idempotent, because if the request to delete a resource was sent
    10 times, the resource would be deleted only once. The subsequent times, nothing
    would happen. Web APIs will typically only use POST, GET, PUT, DELETE, with POST
    as non-idempotent methods.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: DELETE 也是幂等的，因为如果删除资源的请求发送了 10 次，资源只会被删除一次。其后的请求将不会有任何变化。Web API 通常只会使用 POST、GET、PUT、DELETE，其中
    POST 为非幂等方法。
- en: Stateful and Stateless HTTP
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有状态与无状态 HTTP
- en: HTTP is a *stateless* protocol, meaning the server doesn’t keep track of information
    between requests. However, for users to have a persistent and consistent experience
    with a web application, the web server needs to remember something about the HTTP
    session with that client. For example, if a user is logged in to their account
    and adds several items to the shopping cart, the web application needs to keep
    track of the state of the end user’s cart. Otherwise, every time the user navigated
    to a different web page, the cart would empty again.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 是一种*无状态*协议，这意味着服务器不会跟踪请求之间的信息。然而，为了让用户在使用 Web 应用时有一致的体验，Web 服务器需要记住一些关于该客户端的
    HTTP 会话信息。例如，如果用户登录到其账户并将多个物品添加到购物车中，Web 应用需要跟踪该用户购物车的状态。否则，每次用户导航到不同的网页时，购物车都会清空。
- en: A *stateful connection* allows the server to track the client’s actions, profile,
    images, preferences, and so on. Stateful connections use small text files, called
    *cookies*, to store information on the client side. Cookies may store site-specific
    settings, security settings, and authentication-related information. Meanwhile,
    the server often stores information on itself, in a cache, or on backend databases.
    To continue their sessions, browsers include the stored cookies in requests to
    the server, and when hacking web applications, an attacker can impersonate an
    end user by stealing or forging their cookies.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*有状态连接*允许服务器跟踪客户端的行为、个人资料、图片、偏好设置等。有状态连接使用称为*cookies*的小文本文件在客户端存储信息。Cookies
    可能存储与网站相关的设置、安全设置以及身份验证相关的信息。同时，服务器通常在其自身、缓存或后台数据库中存储信息。为了继续会话，浏览器会将存储的 cookies
    包含在请求中，黑客在攻击 web 应用时，可以通过窃取或伪造 cookies 来冒充最终用户。'
- en: Maintaining a stateful connection with a server has scaling limitations. When
    a state is maintained between a client and a server, that relationship exists
    only between the specific browser and the server used when the state was created.
    If a user switches from, say, using a browser on one computer to using the browser
    on their mobile device, the client would need to reauthenticate and create a new
    state with the server. Also, stateful connections require the client to continuously
    send requests to the server. Challenges start to arise when many clients are maintaining
    state with the same server. The server can only handle as many stateful connections
    as allowed by its computing resources. This is much more readily solved by stateless
    applications.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器保持有状态连接有扩展性限制。当客户端和服务器之间保持状态时，这种关系仅存在于创建状态时所使用的特定浏览器和服务器之间。如果用户从例如在一台计算机上使用浏览器切换到在移动设备上使用浏览器，客户端需要重新认证并与服务器创建一个新状态。此外，有状态连接要求客户端持续向服务器发送请求。当许多客户端与同一服务器保持状态时，问题开始出现。服务器只能处理其计算资源允许的有状态连接数量。而这可以通过无状态应用程序更容易地解决。
- en: '*Stateless communications* eliminate the need for the server resources required
    to manage sessions. In stateless communications, the server doesn’t store session
    information, and every stateless request sent must contain all the information
    necessary for the web server to recognize that the requestor is authorized to
    access the given resources. These stateless requests can include a key or some
    form of authorization header to maintain an experience similar to that of a stateful
    connection. The connections do not store session data on the web app server; instead,
    they leverage backend databases.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*无状态通信*消除了管理会话所需的服务器资源。在无状态通信中，服务器不会存储会话信息，每一个无状态请求都必须包含所有必要的信息，以便 web 服务器识别请求者是否有权访问特定资源。这些无状态请求可以包括密钥或某种形式的授权头，以维持类似有状态连接的体验。这些连接不会在
    web 应用服务器上存储会话数据，而是利用后台数据库。'
- en: In our shopping cart example, a stateless application could track the contents
    of a user’s cart by updating the database or cache based on requests that contain
    a certain token. The end-user experience would appear the same, but how the web
    server handles the request is quite a bit different. Since their appearance of
    state is maintained and the client issues everything needed in a given request,
    stateless apps can scale without the concern of losing information within a stateful
    connection. Instead, any number of servers can be used to handle requests as long
    as all the necessary information is included within the request and that information
    is accessible on the backend databases.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的购物车示例中，无状态应用程序可以通过根据包含特定令牌的请求更新数据库或缓存来跟踪用户购物车的内容。最终用户的体验看起来相同，但 web 服务器处理请求的方式则大不相同。由于它们的状态表现得到维持，且客户端在每个请求中提供所有所需信息，无状态应用程序可以在不担心丢失有状态连接中的信息的情况下进行扩展。相反，只要请求中包含所有必要信息且这些信息在后台数据库中可访问，任何数量的服务器都可以用来处理请求。
- en: When hacking APIs, an attacker can impersonate an end user by stealing or forging
    their token. API communications are stateless—a topic I will explore in further
    detail in the next chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在黑客攻击 API 时，攻击者可以通过窃取或伪造用户的令牌来冒充最终用户。API 通信是无状态的——这是我将在下一章详细探讨的话题。
- en: Web Server Databases
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web 服务器数据库
- en: Databases allow servers to store and quickly provide resources to clients. For
    example, any social media platform that allows you to upload status updates, photos,
    and videos is definitely using databases to save all that content. The social
    media platform could be maintaining those databases on its own; alternatively,
    the databases could be provided to the platform as a service.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库允许服务器存储并快速向客户端提供资源。例如，任何允许你上传状态更新、照片和视频的社交媒体平台，肯定使用数据库来保存所有这些内容。该社交媒体平台可能会自行维护这些数据库；或者，这些数据库也可以作为服务提供给平台。
- en: Typically, a web application will store user resources by passing the resources
    from frontend code to backend databases. The frontend of a web application, which
    is the part of a web application that a user interacts with, determines its look
    and feel and includes its buttons, links, videos, and fonts. Frontend code usually
    includes HTML, CSS, and JavaScript. In addition, the frontend could include web
    application frameworks like AngularJS, ReactJS, and Bootstrap, to name a few.
    The *backend* consists of the technologies that the frontend needs to function.
    It includes the server, the application, and any databases. Backend programming
    languages include JavaScript, Python, Ruby, Golang, PHP, Java, C#, and Perl, to
    name a handful.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，网页应用程序会通过将资源从前端代码传递到后端数据库来存储用户资源。网页应用程序的前端是用户交互的部分，决定了它的外观和感觉，并包括按钮、链接、视频和字体。前端代码通常包括
    HTML、CSS 和 JavaScript。此外，前端还可能包括如 AngularJS、ReactJS 和 Bootstrap 等网页应用框架。*后端*则由前端所需的技术组成，包括服务器、应用程序和任何数据库。后端编程语言包括
    JavaScript、Python、Ruby、Golang、PHP、Java、C# 和 Perl 等。
- en: In a secure web application, there should be no direct interaction between a
    user and the backend database. Direct access to a database would remove a layer
    of defense and open up the database to additional attacks. When exposing technologies
    to end users, a web application provider expands their potential for attack, a
    metric known as the *attack surface*. Limiting direct access to a database shrinks
    the size of the attack surface.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个安全的网页应用程序中，用户和后端数据库之间不应该有直接的互动。直接访问数据库会移除一层防护，并使数据库容易受到额外的攻击。当向最终用户暴露技术时，网页应用程序提供者会增加其潜在攻击面，这个度量称为*攻击面*。限制对数据库的直接访问可以缩小攻击面的大小。
- en: Modern web applications use either SQL (relational) databases or NoSQL (nonrelational)
    databases. Knowing the differences between SQL and NoSQL databases will help you
    later tailor your API injection attacks.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网页应用程序使用 SQL（关系型）数据库或 NoSQL（非关系型）数据库。了解 SQL 和 NoSQL 数据库之间的区别，将有助于你日后定制 API
    注入攻击。
- en: SQL
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL
- en: '*Structured Query Language (SQL)* databases are *relational databases* in which
    the data is organized in tables. The table’s rows, called *records*, identify
    the data type, such as username, email address, or privilege level. Its columns
    are the data’s *attributes* and could include all of the different usernames,
    email addresses, and privilege levels. In Tables 1-3 through 1-5, UserID, Username,
    Email, and Privilege are the data types. The rows are the data for the given table.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构化查询语言（SQL）*数据库是*关系型数据库*，其中数据按表格组织。表格的行，称为*记录*，标识数据类型，如用户名、电子邮件地址或权限级别。其列是数据的*属性*，可能包括所有不同的用户名、电子邮件地址和权限级别。在表
    1-3 到 1-5 中，UserID、Username、Email 和 Privilege 是数据类型。行则是给定表格的数据。'
- en: 'Table 1-3: A Relational User Table'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-3：关系型用户表
- en: '| **UserID** | **Username** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **用户ID** | **用户名** |'
- en: '| --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 111 | hAPI_hacker |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 111 | hAPI_hacker |'
- en: '| 112 | Scuttleph1sh |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 112 | Scuttleph1sh |'
- en: '| 113 | mysterioushadow |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 113 | mysterioushadow |'
- en: 'Table 1-4: A Relational Email Table'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-4：关系型电子邮件表
- en: '| **UserID** | **Email** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **用户ID** | **电子邮件** |'
- en: '| --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 111 | *hapi_hacker@email.com* |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 111 | *hapi_hacker@email.com* |'
- en: '| 112 | *scuttleph1sh@email.com* |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 112 | *scuttleph1sh@email.com* |'
- en: '| 113 | *mysterioushadow@email.com* |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 113 | *mysterioushadow@email.com* |'
- en: 'Table 1-5: A Relational Privilege Table'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-5：关系型权限表
- en: '| **UserID** | **Privilege** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **用户ID** | **权限** |'
- en: '| --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 111 | admin |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 111 | 管理员 |'
- en: '| 112 | partner |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 112 | partner |'
- en: '| 113 | user |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 113 | 用户 |'
- en: 'To retrieve data from a SQL database, an application must craft a SQL query.
    A typical SQL query to find the customer with the identification of 111 would
    look like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 SQL 数据库中检索数据，应用程序必须构造一个 SQL 查询。一个典型的查询，以查找 ID 为 111 的客户为例，可能是这样的：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This query requests all records from the Email table that have the value 111
    in the UserID column. `SELECT` is a statement used to obtain information from
    the database, the asterisk is a wildcard character that will select all of the
    columns in a table, `FROM` is used to determine which table to use, and `WHERE`
    is a clause that is used to filter specific results.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询请求从 Email 表中获取所有 UserID 列值为 111 的记录。`SELECT` 是用于从数据库中获取信息的语句，星号是通配符字符，表示选择表中的所有列，`FROM`
    用于指定查询的表，`WHERE` 是用于筛选特定结果的子句。
- en: There are several varieties of SQL databases, but they are queried similarly.
    SQL databases include MySQL, Microsoft SQL Server, PostgreSQL, Oracle, and MariaDB,
    among others.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 数据库有多种类型，但它们的查询方式类似。SQL 数据库包括 MySQL、Microsoft SQL Server、PostgreSQL、Oracle
    和 MariaDB 等。
- en: In later chapters, I’ll cover how to send API requests to detect injection vulnerabilities,
    such as SQL injection. SQL injection is a classic web application attack that
    has been plaguing web apps for over two decades yet remains a possible attack
    method in APIs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中，我将讲解如何发送 API 请求来检测注入漏洞，例如 SQL 注入。SQL 注入是一种经典的 web 应用攻击，已经困扰了 web 应用超过二十年，但它仍然是
    API 中可能存在的攻击方法。
- en: NoSQL
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NoSQL
- en: '*NoSQL databases*, also known as distributed databases, are *nonrelational*,
    meaning they don’t follow the structures of relational databases. NoSQL databases
    are typically open-source tools that handle unstructured data and store data as
    documents. Instead of relationships, NoSQL databases store information as keys
    and values. Unlike SQL databases, each type of NoSQL database will have its own
    unique structures, modes of querying, vulnerabilities, and exploits. Here’s a
    sample query using MongoDB, the current market share leader for NoSQL databases:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*NoSQL 数据库*，也称为分布式数据库，是*非关系型*的，意味着它们不遵循关系型数据库的结构。NoSQL 数据库通常是开源工具，用于处理非结构化数据并将数据存储为文档。与关系型数据库不同，NoSQL
    数据库通过键值对来存储信息，而不是通过关系存储。与 SQL 数据库不同，每种类型的 NoSQL 数据库都有其独特的结构、查询模式、漏洞和利用方式。以下是使用
    MongoDB 进行查询的示例，MongoDB 是当前市场份额领先的 NoSQL 数据库：'
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, `db.collection.find()` is a method used to search through
    a document for information about the UserID with 111 as the value. MongoDB uses
    several operators that might be useful to know:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`db.collection.find()` 是用于在文档中查找 UserID 值为 111 的信息的方法。MongoDB 使用多个可能有用的操作符：
- en: '`$eq` Matches values that are equal to a specified value'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$eq` 匹配等于指定值的值'
- en: '`$gt` Matches values that are greater than a specified value'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$gt` 匹配大于指定值的值'
- en: '`$lt` Matches values that are less than a specified value'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$lt` 匹配小于指定值的值'
- en: '`$ne` Matches all values that are not equal to a specified value'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$ne` 匹配所有不等于指定值的值'
- en: 'These operators can be used within NoSQL queries to select and filter certain
    information in a query. For example, we could use the previous command without
    knowing the exact UserID, like so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作符可以在 NoSQL 查询中使用，用于选择和过滤查询中的特定信息。例如，我们可以使用之前的命令而无需知道确切的 UserID，像这样：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This statement would find all UserIDs greater than 110\. Understanding these
    operators will be useful when conducting NoSQL injection attacks later in this
    book.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句将找到所有 UserID 大于 110 的记录。理解这些操作符在本书后续讲解 NoSQL 注入攻击时会非常有用。
- en: NoSQL databases include MongoDB, Couchbase, Cassandra, IBM Domino, Oracle NoSQL
    Database, Redis, and Elasticsearch, among others.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL 数据库包括 MongoDB、Couchbase、Cassandra、IBM Domino、Oracle NoSQL 数据库、Redis 和
    Elasticsearch 等。
- en: How APIs Fit into the Picture
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 在整个框架中的作用
- en: A web application can be made more powerful if it can use the power of other
    applications. *Application programming interfaces (APIs)* comprise a technology
    that facilitates communications between separate applications. In particular,
    *web* APIs allow for machine-to-machine communications based on HTTP, providing
    a common method of connecting different applications together.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 web 应用能够利用其他应用的功能，它将变得更强大。*应用程序编程接口（APIs）* 是一种促进不同应用程序之间通信的技术。特别是，*web*
    API 允许基于 HTTP 的机器对机器通信，提供了一个将不同应用程序连接在一起的通用方法。
- en: This ability has opened up a world of opportunities for application providers,
    as developers no longer have to be experts in every facet of the functionality
    they want to provide to their end users. For example, let’s consider a ridesharing
    app. The app needs a map to help its drivers navigate cities, a method for processing
    payments, and a way for drivers and customers to communicate. Instead of specializing
    in each of these different functions, a developer can leverage the Google Maps
    API for the mapping function, the Stripe API for payment processing, and the Twilio
    API to access SMS messaging. The developer can combine these APIs to create a
    whole new application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种能力为应用提供商开辟了广阔的机会，因为开发者不再需要在他们想要提供给最终用户的每个功能方面都成为专家。例如，假设我们考虑一个共享乘车应用。该应用需要一个地图来帮助司机导航城市，需要一个处理支付的方法，以及一个供司机和客户沟通的方式。开发者可以利用Google
    Maps API来实现地图功能，利用Stripe API来处理支付，利用Twilio API来访问短信功能。开发者可以将这些API结合起来，创建一个全新的应用。
- en: The immediate impact of this technology is twofold. First, it streamlines the
    exchange of information. By using HTTP, web APIs can take advantage of the protocol’s
    standardized methods, status codes, and client/server relationship, allowing developers
    to write code that can automatically handle the data. Second, APIs allow web application
    providers to specialize, as they no longer need to create every aspect of their
    web application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的直接影响是双重的。首先，它简化了信息的交换。通过使用HTTP，Web API可以利用协议的标准化方法、状态码和客户端/服务器关系，使开发者能够编写可以自动处理数据的代码。其次，API使得Web应用提供商能够专注于自己的专业领域，因为他们不再需要创建每个Web应用的各个方面。
- en: APIs are an incredible technology with a global impact. Yet, as you’ll see in
    the following chapters, they have greatly expanded the attack surface of every
    application using them on the internet.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: API是一项具有全球影响的令人难以置信的技术。然而，正如你将在接下来的章节中看到的，它们大大增加了每个使用它们的应用在互联网上的攻击面。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we covered the fundamental aspects of web applications. If you
    understand the general functions of HTTP requests and responses, authentication/authorization,
    and databases, you will easily be able to understand web APIs, because the underlying
    technology of web applications is the underlying technology of web APIs. In the
    next chapter we will examine the anatomy of APIs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Web应用的基本方面。如果你理解了HTTP请求和响应、身份验证/授权以及数据库的一般功能，你将能够轻松理解Web API，因为Web应用的底层技术正是Web
    API的底层技术。在下一章中，我们将分析API的构成。
- en: This chapter is meant to equip you with just enough information to be dangerous
    as an API hacker, not as a developer or application architect. If you would like
    additional resources about web applications, I highly suggest *The Web Application
    Hackers Handbook* (Wiley, 2011), *Web Application Security* (O’Reilly, 2020),
    *Web Security for Developers* (No Starch Press, 2020), and *The Tangled Web* (No
    Starch Press, 2011).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在为你提供足够的信息，以便作为一个API黑客而不是开发者或应用架构师。若你希望了解更多关于Web应用的资源，我强烈推荐*《Web应用黑客手册》*（Wiley，2011），*《Web应用安全》*（O’Reilly，2020），*《Web开发者的Web安全》*（No
    Starch Press，2020）和*《错综复杂的Web》*（No Starch Press，2011）。
