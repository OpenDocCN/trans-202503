- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Mining Text to Find Meaningful Data
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 挖掘文本以找到有意义的数据
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: 'Next, you’ll learn how to use SQL to transform, search, and analyze text. You’ll
    start with simple text wrangling using string formatting and pattern matching
    before moving on to more advanced analysis. We’ll use two data-sets: a small collection
    of crime reports from a sheriff’s department near Washington, DC, and a set of
    speeches delivered by US presidents.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习如何使用SQL来转换、搜索和分析文本。您将从简单的文本整理，包括字符串格式化和模式匹配开始，然后转向更高级的分析。我们将使用两个数据集：华盛顿DC附近一个警长部门的少量犯罪报告和美国总统发表的演讲集。
- en: Text offers plenty of possibilities for analysis. You can extract meaning from
    *unstructured* *data*—paragraphs of text in speeches, reports, press releases,
    and other documents—by transforming it into *structured data*, in rows and columns
    in a table. Or you can use advanced text analysis features, such as PostgreSQL’s
    full-text search. With these techniques, ordinary text can reveal facts or trends
    that might otherwise remain hidden.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 文本提供了丰富的分析可能性。您可以从 *非结构化* *数据* —— 演讲、报告、新闻稿和其他文档中的段落 —— 中提取意义，通过将其转换为 *结构化数据*
    —— 在表格中的行和列中。或者，您可以使用高级文本分析功能，例如PostgreSQL的全文搜索。借助这些技术，普通文本可以揭示否则可能隐藏的事实或趋势。
- en: Formatting Text Using String Functions
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字符串函数格式化文本
- en: PostgreSQL has more than 50 built-in string functions that handle routine but
    necessary tasks, such as capitalizing letters, combining strings, and removing
    unwanted spaces. Some are part of the ANSI SQL standard, and others are specific
    to PostgreSQL. You’ll find a complete list of string functions at [https://www.postgresql.org/docs/current/functions-string.html](https://www.postgresql.org/docs/current/functions-string.html),
    but in this section we’ll examine several you might use often.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL具有超过50个内置的字符串函数，用于处理常规但必要的任务，例如大写字母、组合字符串和删除不需要的空格。其中一些是ANSI SQL标准的一部分，而其他一些是特定于PostgreSQL的。您可以在
    [https://www.postgresql.org/docs/current/functions-string.html](https://www.postgresql.org/docs/current/functions-string.html)
    找到完整的字符串函数列表，但在本节中，我们将介绍您可能经常使用的几个函数。
- en: 'You can try each of these in a simple query that places a function after `SELECT`,
    like this: `SELECT upper(''hello'');`. Examples of each function plus code for
    all the listings in this chapter are available at [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在简单查询中尝试每个函数，将函数放在 `SELECT` 后面，就像这样： `SELECT upper('hello');`。本章节中所有列表的示例和代码均可在
    [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/)
    查看。
- en: Case Formatting
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大小写格式化
- en: The capitalization functions format the text’s case. The `upper(``string``)`
    function capitalizes all alphabetical characters of a string passed to it. Nonalphabetic
    characters, such as numbers, remain unchanged. For example, `upper('Neal7')` returns
    `NEAL7`. The `lower(``string``)` function lowercases all alphabetical characters
    while keeping nonalphabetic characters unchanged. For example, `lower('Randy')`
    returns `randy`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大写函数会格式化文本的大小写。 `upper(``string``)` 函数将传递给它的字符串的所有字母字符大写。非字母字符（如数字）保持不变。例如，
    `upper('Neal7')` 返回 `NEAL7`。 `lower(``string``)` 函数将所有字母字符转换为小写，同时保持非字母字符不变。例如，
    `lower('Randy')` 返回 `randy`。
- en: The `initcap(``string``)` function capitalizes the first letter of each word.
    For example, `initcap('at the end of the day')` returns `At The End Of The Day`.
    This function can be handy for formatting titles of books or movies, but because
    it doesn’t recognize acronyms, it’s not always the perfect solution. For example,
    `initcap('Practical SQL')` returns `Practical Sql`, because it doesn’t recognize
    SQL as an acronym.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`initcap(``string``)` 函数会将每个单词的首字母大写。例如， `initcap(''at the end of the day'')`
    返回 `At The End Of The Day`。此函数在格式化书籍或电影标题时很有用，但由于不识别缩写，因此并非始终完美。例如， `initcap(''Practical
    SQL'')` 返回 `Practical Sql`，因为它无法识别SQL作为缩写。'
- en: The `upper()` and `lower()` functions are ANSI SQL standard commands, but `initcap()`
    is PostgreSQL-specific. These three functions give you enough options to rework
    a column of text into the case you prefer. Note that capitalization does not work
    with all locales or languages.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`upper()` 和 `lower()` 函数是ANSI SQL标准命令，但 `initcap()` 是特定于PostgreSQL的。这三个函数为您提供了足够的选项，可以将文本列重新格式化为您喜欢的大小写。请注意，大小写格式化不适用于所有语言或区域设置。'
- en: Character Information
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符信息
- en: Several functions return data about the string and are helpful on their own
    or combined with other functions. The `char_length(``string``)` function returns
    the number of characters in a string, including any spaces. For example, `char_length('
    Pat ')` returns a value of `5`, because the three letters in `Pat` and the spaces
    on either end total five characters. You can also use the non-ANSI SQL function
    `length(``string``)` to count strings, which has a variant that lets you count
    the length of binary strings.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 几个函数返回关于字符串的数据，它们单独使用或与其他函数结合使用都很有帮助。`char_length(``string``)`函数返回字符串中字符的数量，包括任何空格。例如，`char_length('
    Pat ')`返回值为`5`，因为`Pat`中的三个字母加上两边的空格总共是五个字符。你还可以使用非ANSI SQL函数`length(``string``)`来计算字符串的长度，这个函数有一个变体可以计算二进制字符串的长度。
- en: The `position(``substring` `in` `string``)` function returns the location of
    the substring characters in the string. For example, `position(', ' in 'Tan, Bella')`
    returns `4`, because the comma and space characters (`,` ) specified in the substring
    passed as the first parameter starting at the fourth index position in the main
    string `Tan, Bella`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`position(``substring` `in` `string``)`函数返回字符串中子字符串的位置。例如，`position('', ''
    in ''Tan, Bella'')`返回`4`，因为逗号和空格字符（`,` ）作为第一个参数传递的子字符串从主字符串`Tan, Bella`的第四个索引位置开始。'
- en: Both `char_length()` and `position()` are in the ANSI SQL standard.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`char_length()`和`position()`都是ANSI SQL标准中的函数。'
- en: Removing Characters
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除字符
- en: The `trim(``characters` `from` `string``)` function removes characters from
    the beginning and end of a string. To declare one or more characters to remove,
    add them to the function followed by the keyword `from` and the string you want
    to change. Options to remove `leading` characters (at the front of the string),
    `trailing` characters (at the end of the string), or `both` make this function
    super flexible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`trim(``characters` `from` `string``)`函数从字符串的开头和结尾移除字符。要指定要移除的一个或多个字符，请将它们添加到函数中，并在之后添加关键字`from`和要更改的字符串。移除`leading`字符（在字符串前端）、`trailing`字符（在字符串末端）或`both`使得该函数非常灵活。'
- en: 'For example, `trim(''s'' from ''socks'')` removes `s` characters at the beginning
    and end, returning `ock`. To remove only the `s` at the end of the string, add
    the `trailing` keyword before the character to trim: `trim(trailing ''s'' from
    ''socks'')` returns `sock`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`trim('s' from 'socks')`移除开头和结尾的`s`字符，返回`ock`。要仅移除字符串结尾的`s`，请在要修剪的字符前添加`trailing`关键字：`trim(trailing
    's' from 'socks')`返回`sock`。
- en: 'If you don’t specify any characters to remove, `trim()` removes spaces at either
    end of the string by default. For example, `trim('' Pat '')` returns `Pat` without
    the leading or trailing spaces. To confirm the length of the trimmed string, we
    can nest `trim()` inside `char_length()` like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定要移除的字符，`trim()`默认移除字符串两端的空格。例如，`trim(' Pat ')`返回`Pat`，去除了前后的空格。为了确认修剪后字符串的长度，我们可以像这样将`trim()`嵌套在`char_length()`内部使用：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This query should return `3`, the number of letters in `Pat`, which is the result
    of `trim(' Pat ')`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询应该返回`3`，即`Pat`中字母的数量，这是`trim(' Pat ')`的结果。
- en: The `ltrim(``string``,` `characters``)` and `rtrim(``string``,` `characters``)`
    functions are PostgreSQL-specific variations of the `trim()` function. They remove
    characters from the left or right ends of a string. For example, `rtrim('socks',
    's')` returns `sock` by removing only the `s` on the right end of the string.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`ltrim(``string``,` `characters``)`和`rtrim(``string``,` `characters``)`函数是PostgreSQL特定的`trim()`函数变体。它们从字符串的左端或右端移除字符。例如，`rtrim(''socks'',
    ''s'')`通过只移除字符串右端的`s`返回`sock`。'
- en: Extracting and Replacing Characters
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取和替换字符
- en: 'The `left(``string``,` `number``)` and `right(``string``,` `number``)` functions,
    both ANSI SQL standard, extract and return selected characters from a string.
    For example, to get just the `703` area code from the phone number `703-555-1212`,
    use `left(''703-555-1212'', 3)` to specify that you want the first three characters
    of the string starting from the left. Likewise, `right(''703-555-1212'', 8)` returns
    eight characters from the right: `555-1212`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`left(``string``,` `number``)`和`right(``string``,` `number``)`函数，都是ANSI SQL标准中的，从字符串中提取并返回选定的字符。例如，从电话号码`703-555-1212`中提取`703`区号，可以使用`left(''703-555-1212'',
    3)`指定从左边起第一个字符开始的前三个字符。同样，`right(''703-555-1212'', 8)`返回从右边起的八个字符：`555-1212`。'
- en: To substitute characters in a string, use the `replace(``string``,` `from``,`
    `to``)` function. To change `bat` to `cat`, for example, you would use `replace('bat',
    'b', 'c')` to specify that you want to replace the `b` in `bat` with a `c`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要在字符串中替换字符，可以使用 `replace(``string``,` `from``,` `to``)` 函数。例如，要将 `bat` 改为 `cat`，可以使用
    `replace('bat', 'b', 'c')` 来指定将 `bat` 中的 `b` 替换为 `c`。
- en: Now that you know basic functions for manipulating strings, let’s look at how
    to match more complex patterns in text and turn those patterns into data we can
    analyze.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了字符串操作的基本函数，接下来我们来看看如何在文本中匹配更复杂的模式，并将这些模式转化为可以分析的数据。
- en: Matching Text Patterns with Regular Expressions
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配文本模式与正则表达式
- en: '*Regular expressions* (or *regex*) are a type of notational language that describes
    text patterns. If you have a string with a noticeable pattern (say, four digits
    followed by a hyphen and then two more digits), you can write a regular expression
    that matches the pattern. You can then use the notation in a `WHERE` clause to
    filter rows by the pattern or use regular expression functions to extract and
    wrangle text that contains the same pattern.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*正则表达式*（或 *regex*）是一种描述文本模式的符号语言。如果你有一个明显的字符串模式（例如，四个数字后跟一个连字符，再后面是两个数字），你可以编写一个正则表达式来匹配这个模式。然后，你可以在
    `WHERE` 子句中使用该表示法来按模式筛选行，或者使用正则表达式函数提取和处理包含相同模式的文本。'
- en: Regular expressions can seem inscrutable to beginning programmers; they take
    practice to comprehend because they use single-character symbols that aren’t intuitive.
    Getting an expression to match a pattern can involve trial and error, and each
    programming language has subtle differences in the way it handles regular expressions.
    Still, learning regular expressions is a good investment because you gain superpower-like
    abilities to search text using many programming languages, text editors, and other
    applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式对于初学者来说可能显得难以理解；它们需要练习才能掌握，因为它们使用的单字符符号并不直观。让表达式匹配一个模式可能需要反复尝试，而且每种编程语言在处理正则表达式时都有细微的差别。尽管如此，学习正则表达式仍然是一个值得的投资，因为你将获得类似超能力的能力，可以在许多编程语言、文本编辑器和其他应用程序中搜索文本。
- en: In this section, I’ll provide enough regular expression basics to work through
    the exercises. To learn more, I recommend interactive online code testers, such
    as [https://regexr.com/](https://regexr.com/) or [https://www.regexpal.com/](https://www.regexpal.com/),
    which have notation references.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我将提供足够的正则表达式基础，帮助你完成练习。如果想了解更多内容，推荐使用交互式在线代码测试工具，如 [https://regexr.com/](https://regexr.com/)
    或 [https://www.regexpal.com/](https://www.regexpal.com/)，它们提供了表示法参考。
- en: Regular Expression Notation
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正则表达式表示法
- en: Matching letters and numbers using regular expression notation is straightforward
    because letters and numbers (and certain symbols) are literals that indicate the
    same characters. For example, `Al` matches the first two characters in `Alicia`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式表示法匹配字母和数字是直接的，因为字母、数字（和某些符号）是文字，它们表示相同的字符。例如，`Al` 匹配 `Alicia` 中的前两个字符。
- en: For more complex patterns, you’ll use combinations of the regular expression
    elements in [Table 14-1](#table14-1).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的模式，你将使用正则表达式元素的组合，如[表格14-1](#table14-1)中所示。
- en: 'Table 14-1: Regular Expression Notation Basics'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表格14-1：正则表达式表示法基础
- en: '| **Expression** | **Description** |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **描述** |'
- en: '| --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `.` | A dot is a wildcard that finds any character except a newline. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 点号是一个通配符，匹配除了换行符以外的任何字符。 |'
- en: '| `[FGz]` | Any character in the square brackets. Here, *F*, *G*, or *z*. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `[FGz]` | 方括号中的任何字符。这里是 *F*、*G* 或 *z*。 |'
- en: '| `[a-z]` | A range of characters. Here, lowercase *a* to *z*. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `[a-z]` | 字符范围。这里是小写的 *a* 到 *z*。 |'
- en: '| `[^a-z]` | The caret negates the match. Here, not lowercase *a* to *z*. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `[^a-z]` | 插入符号（^）表示匹配的否定。这里，表示不匹配小写的 *a* 到 *z*。 |'
- en: '| `\w` | Any word character or underscore. Same as `[A-Za-z0-9_]`. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 任何单词字符或下划线。等同于 `[A-Za-z0-9_]`。 |'
- en: '| `\d` | Any digit. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 任何数字。 |'
- en: '| `\s` | A space. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 空格字符。 |'
- en: '| `\t` | Tab character. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 制表符字符。 |'
- en: '| `\n` | Newline character. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行字符。 |'
- en: '| `\r` | Carriage return character. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | 回车字符。 |'
- en: '| `^` | Match at the start of a string. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 匹配字符串的开头。 |'
- en: '| `$` | Match at the end of a string. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 匹配字符串的结尾。 |'
- en: '| `?` | Get the preceding match zero or one time. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 获取前一个匹配项零次或一次。 |'
- en: '| `*` | Get the preceding match zero or more times. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 获取前一个匹配项零次或多次。 |'
- en: '| `+` | Get the preceding match one or more times. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 获取前一个匹配项一到多次。 |'
- en: '| `{``m``}` | Get the preceding match exactly `m` times. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `{``m``}` | 获取前一个匹配项恰好 `m` 次。 |'
- en: '| `{``m``,``n``}` | Get the preceding match between `m` and `n` times. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `{``m``,``n``}` | 获取前一个匹配项，匹配次数介于 `m` 和 `n` 之间。 |'
- en: '| `a``&#124;``b` | The pipe denotes alternation. Find either `a` or `b`. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `a``&#124;``b` | 管道符表示交替。找到 `a` 或 `b`。 |'
- en: '| `( )` | Create and report a capture group or set precedence. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `( )` | 创建并报告捕获组或设置优先级。 |'
- en: '| `(?: )` | Negate the reporting of a capture group. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `(?: )` | 否定捕获组的报告。 |'
- en: Using these regular expressions, you can match various characters and indicate
    how many times and where to match them. For example, placing characters inside
    square brackets (`[]`) lets you match any single character or a range. So, `[FGz]`
    matches a single `F`, `G`, or `z`, whereas `[A-Za-z]` will match any uppercase
    or lowercase letter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些正则表达式，你可以匹配各种字符，并指定匹配的次数和位置。例如，将字符放入方括号（`[]`）中，可以匹配任何单一字符或字符范围。因此，`[FGz]`
    可以匹配单个 `F`、`G` 或 `z`，而 `[A-Za-z]` 会匹配任何大写或小写字母。
- en: The backslash (`\`) precedes a designator for special characters, such as a
    tab (`\t`), digit (`\d`), or newline (`\n`), which is a line ending character
    in text files.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠（`\`）用于表示特殊字符的设计符号，例如制表符（`\t`）、数字（`\d`）或换行符（`\n`），后者是文本文件中的行结束字符。
- en: There are several ways to indicate how many times to match a character. Placing
    a number inside curly brackets indicates you want to match it that many times.
    For example, `\d{4}` matches four digits in a row, and `\d{1,4}` matches one to
    four digits.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以指定字符匹配的次数。将数字放入花括号中表示你希望匹配该次数。例如，`\d{4}` 匹配四个连续的数字，`\d{1,4}` 匹配一到四个数字。
- en: The `?`, `*`, and `+` characters provide a useful shorthand notation for the
    number of matches you want. The plus sign (`+`) after a character indicates to
    match it one or more times, for example. So, the expression `a+` would find the
    `aa` characters in the string `aardvark`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`?`、`*` 和 `+` 字符为你提供了一个便捷的匹配次数表示法。例如，字符后面的加号（`+`）表示匹配一次或多次。因此，表达式 `a+` 会在字符串
    `aardvark` 中找到 `aa` 字符。'
- en: Additionally, parentheses indicate a *capture group*, which you can use to identify
    a portion of the entire matched expression. For example, if you were hunting for
    an `HH``:``MM``:``SS` time format in text and wanted to report only the hour,
    you could use an expression such as `(\d{2}):\d{2}:\d{2}`. This looks for two
    digits (`\d{2}`) of the hour followed by a colon, another two digits for the minutes
    and a colon, and then the two-digit seconds. By placing the first `\d{2}` inside
    parentheses, you can extract only those two digits, even though the entire expression
    matches the full time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，圆括号表示 *捕获组*，你可以使用它来标识整个匹配表达式中的一部分。例如，如果你在文本中寻找 `HH``:``MM``:``SS` 的时间格式，并且只想报告小时部分，可以使用诸如
    `(\d{2}):\d{2}:\d{2}` 的表达式。它会寻找两个数字（`\d{2}`）表示小时，后跟冒号，再是两个数字表示分钟和冒号，最后是两位数字表示秒。通过将第一个
    `\d{2}` 放入圆括号中，你可以仅提取这两个数字，尽管整个表达式匹配的是完整的时间。
- en: '[Table 14-2](#table14-2) shows examples of combining regular expressions to
    capture different portions of the sentence “The game starts at 7 p.m. on May 2,
    2024.”'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 14-2](#table14-2) 显示了结合正则表达式以捕获句子 “The game starts at 7 p.m. on May 2,
    2024.” 中不同部分的示例。'
- en: 'Table 14-2: Regular Expression Matching Examples'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 14-2：正则表达式匹配示例
- en: '| **Expression** | **What it matches** | **Result** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **匹配内容** | **结果** |'
- en: '| --- | --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `.+` | Any character one or more times | `The game starts at 7 p.m. on May
    2, 2024.` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `.+` | 匹配任意字符一次或多次 | `The game starts at 7 p.m. on May 2, 2024.` |'
- en: '| `\d{1,2} (?:a.m.&#124;p.m.)` | One or two digits followed by a space and
    *a.m.* or *p.m.* in a noncapture group | `7 p.m.` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `\d{1,2} (?:a.m.&#124;p.m.)` | 一个或两个数字后跟空格和非捕获组中的 *a.m.* 或 *p.m.* | `7 p.m.`
    |'
- en: '| `^\w+` | One or more word characters at the start | `The` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `^\w+` | 以一个或多个单词字符开始 | `The` |'
- en: '| `\w+.$` | One or more word characters followed by any character at the end
    | `2024.` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `\w+.$` | 以一个或多个单词字符后跟任意字符结尾 | `2024.` |'
- en: '| `May&#124;June` | Either of the words *May* or *June* | `May` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `May&#124;June` | 匹配 *May* 或 *June* 中的任意一个 | `May` |'
- en: '| `\d{4}` | Four digits | `2024` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `\d{4}` | 四个数字 | `2024` |'
- en: '| `May \d, \d{4}` | *May* followed by a space, digit, comma, space, and four
    digits | `May 2, 2024` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `May \d, \d{4}` | *May* 后跟一个空格、数字、逗号、空格和四个数字 | `May 2, 2024` |'
- en: These results show the usefulness of regular expressions for matching the parts
    of the string that interest us. For example, to find the time, we use the expression
    `\d{1,2} (?:a.m.|p.m.)` to look for either one or two digits because the time
    could be a single or double digit followed by a space. Then we look for either
    `a.m.` or `p.m.`; the pipe symbol separating the terms indicates the either-or
    condition, and placing them in parentheses separates the logic from the rest of
    the expression. We need the `?:` symbol to indicate that we don’t want to treat
    the terms inside the parentheses as a capture group, which would report `a.m.`
    or `p.m.` only. The `?:` ensures that the full match will be returned.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果展示了正则表达式在匹配我们感兴趣的字符串部分时的实用性。例如，为了查找时间，我们使用表达式 `\d{1,2} (?:a.m.|p.m.)` 来查找一个或两个数字，因为时间可能是一个或两个数字，后面跟着一个空格。然后我们查找
    `a.m.` 或 `p.m.`；管道符号分隔这两个术语表示“或者”的条件，括号将它们与表达式的其余部分分开。我们需要 `?:` 符号来表示我们不希望将括号中的术语作为捕获组处理，这样只会返回
    `a.m.` 或 `p.m.`。`?:` 确保返回完整的匹配项。
- en: 'You can use any of these regular expressions by placing the text and regular
    expression inside the `substring(``string` `from` `pattern``)` function to return
    the matched text. For example, to find the four-digit year, use the following
    query:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将文本和正则表达式放入 `substring(``string` `from` `pattern``)` 函数中来使用这些正则表达式，以返回匹配的文本。例如，要查找四位数的年份，可以使用以下查询：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This query should return `2024`, because we specified that the pattern should
    look for four digits in a row, and 2024 is the only portion of this string that
    matches these criteria. You can check out sample `substring()` queries for all
    the examples in [Table 14-2](#table14-2) in the book’s code resources at [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询应该返回 `2024`，因为我们指定了模式应查找连续的四个数字，而 `2024` 是该字符串中唯一符合这些条件的部分。你可以查看本书代码资源中[表格
    14-2](#table14-2)的所有示例 `substring()` 查询，网址为 [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/)。
- en: Using Regular Expressions with WHERE
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 WHERE 中使用正则表达式
- en: You’ve filtered queries using `LIKE` and `ILIKE` in `WHERE` clauses. In this
    section, you’ll learn to use regular expressions in `WHERE` clauses so you can
    perform more complex matches.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 `WHERE` 子句中使用过 `LIKE` 和 `ILIKE` 进行查询过滤。在本节中，你将学习如何在 `WHERE` 子句中使用正则表达式，从而进行更复杂的匹配。
- en: We use a tilde (`~`) to make a case-sensitive match on a regular expression
    and a tilde-asterisk (`~*`) to perform a case-insensitive match. You can negate
    either expression by adding an exclamation point in front. For example, `!~*`
    indicates to *not* match a regular expression that is case-insensitive. [Listing
    14-1](#listing14-1) shows how this works using the 2019 US Census estimates `us_counties_pop_est_2019`
    table from previous exercises.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用波浪号（`~`）对正则表达式进行区分大小写的匹配，使用波浪号星号（`~*`）进行不区分大小写的匹配。你可以通过在前面加上感叹号来取反这两种表达式。例如，`!~*`
    表示 *不* 匹配不区分大小写的正则表达式。[清单 14-1](#listing14-1) 显示了如何使用之前练习中的2019年美国人口普查估算数据表 `us_counties_pop_est_2019`
    来演示这个过程。
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 14-1: Using regular expressions in a `WHERE` clause'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-1：在 `WHERE` 子句中使用正则表达式
- en: 'The first `WHERE` clause 1 uses the tilde-asterisk (`~*`) to perform a case-insensitive
    match on the regular expression `(lade|lare)` to find any county names that contain
    either the letters `lade` or `lare`. The results should show eight rows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `WHERE` 子句 1 使用波浪号星号（`~*`）对正则表达式 `(lade|lare)` 进行不区分大小写的匹配，以查找包含 `lade`
    或 `lare` 的县名。结果应该显示八行：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, each county name includes the letters `lade` or `lare`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个县名都包含字母 `lade` 或 `lare`。
- en: 'The second `WHERE` clause 2 uses the tilde-asterisk (`~*`) as well as a negated
    tilde (`!~`) to find county names containing the letters `ash` but excluding those
    that include `Wash`. This query should return the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `WHERE` 子句 2 使用波浪号星号（`~*`）以及取反的波浪号（`!~`）来查找包含字母 `ash` 但不包含 `Wash` 的县名。这个查询应该返回以下结果：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All nine counties in this output have names that contain the letters `ash`,
    but none have `Wash`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出中的九个县名都包含字母 `ash`，但没有一个包含 `Wash`。
- en: These are fairly simple examples, but you can do more complex matches using
    regular expressions that you wouldn’t be able to perform with the wildcards available
    with just `LIKE` and `ILIKE`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是相对简单的示例，但你可以使用正则表达式进行更复杂的匹配，这是仅使用 `LIKE` 和 `ILIKE` 的通配符无法完成的。
- en: Regular Expression Functions to Replace or Split Text
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正则表达式函数用于替换或拆分文本
- en: '[Listing 14-2](#listing14-2) shows three regular expression functions that
    replace and split text.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例14-2](#listing14-2)展示了三个替换和拆分文本的正则表达式函数。'
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 14-2: Regular expression functions to replace and split text'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 示例14-2：用于替换和拆分文本的正则表达式函数
- en: The `regexp_replace(``string``,` `pattern``,` `replacement text``)` function
    lets you substitute a matched pattern with replacement text. In the example at
    1, we’re searching the date string `05/12/2024` for any set of four digits in
    a row using `\d{4}`. When found, we replace them with the replacement text `2023`.
    The result of that query is `05/12/2023` returned as text.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`regexp_replace(``string``,` `pattern``,` `replacement text``)` 函数允许你用替代文本替换匹配的模式。在示例1中，我们使用
    `\d{4}` 在日期字符串 `05/12/2024` 中查找任何连续的四个数字。找到后，我们将它们替换为替代文本 `2023`。该查询的结果是返回文本 `05/12/2023`。'
- en: 'The `regexp_split_to_table(``string``,` `pattern``)` function splits delimited
    text into rows. [Listing 14-2](#listing14-2) uses this function to split the string
    `''Four,score,and,seven,years,ago''` on commas 2, resulting in a set of rows that
    has one word in each row:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`regexp_split_to_table(``string``,` `pattern``)` 函数将分隔的文本拆分成行。[示例14-2](#listing14-2)使用此函数按逗号拆分字符串
    `''Four,score,and,seven,years,ago''`，结果是生成一个行集，每行包含一个单词：'
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Keep this function in mind as you tackle the “Try It Yourself” exercises at
    the end of the chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章末尾的“自己动手试试”练习时，记得牢记这个函数。
- en: 'The `regexp_split_to_array(``string``,` `pattern``)` function splits delimited
    text into an array. The example splits the string `Phil Mike Tony Steve` on spaces
    3, returning a text array that should look like this in pgAdmin:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`regexp_split_to_array(``string``,` `pattern``)` 函数将分隔的文本拆分成一个数组。示例将字符串 `Phil
    Mike Tony Steve` 按照空格拆分成3部分，返回的文本数组在pgAdmin中应如下所示：'
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `text[]` notation in pgAdmin’s column header along with curly brackets around
    the results confirms that this is indeed an array type, which provides another
    means of analysis. For example, you could then use a function such as `array_length()`
    to count the number of words, as shown in [Listing 14-3](#listing14-3).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: pgAdmin的列标题中的 `text[]` 符号和结果周围的花括号确认这确实是一个数组类型，这为进一步分析提供了另一种方式。例如，你可以使用 `array_length()`
    函数来计算单词的数量，如[示例14-3](#listing14-3)所示。
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 14-3: Finding an array length'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 示例14-3：查找数组长度
- en: The array that `regexp_split_to_array()` produces is one-dimensional; that is,
    the result contains one list of names. Arrays can have additional dimensions—for
    example, a two-dimensional array can represent a matrix with rows and columns.
    Thus, here we pass `1` as a second argument 1 to `array_length()`, indicating
    we want the length of the first (and only) dimension of the array. The query should
    return `4` because the array has four elements. You can read more about `array_length()`
    and other array functions at [https://www.postgresql.org/docs/current/functions-array.html](https://www.postgresql.org/docs/current/functions-array.html).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`regexp_split_to_array()` 生成的数组是一维的；也就是说，结果包含一个名称列表。数组可以有更多的维度——例如，二维数组可以表示一个包含行和列的矩阵。因此，我们将
    `1` 作为第二个参数传递给 `array_length()`，表示我们希望获得数组第一维（也是唯一维度）的长度。查询应返回 `4`，因为该数组有四个元素。你可以在
    [https://www.postgresql.org/docs/current/functions-array.html](https://www.postgresql.org/docs/current/functions-array.html)
    中阅读更多关于 `array_length()` 和其他数组函数的信息。'
- en: If you can identify a pattern in the text, you can use a combination of regular
    expression symbols to locate it. This technique is particularly useful when you
    have repeating patterns in text that you want to turn into a set of data to analyze.
    Let’s practice how to use regular expression functions using a real-world example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能在文本中识别出模式，可以使用正则表达式符号的组合来定位它。当文本中存在重复模式时，这种技术特别有用，特别是当你想将其转换为一组数据进行分析时。让我们通过一个实际例子来练习如何使用正则表达式函数。
- en: Turning Text to Data with Regular Expression Functions
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用正则表达式函数将文本转换为数据
- en: A sheriff’s department in one of the Washington, DC, suburbs publishes daily
    reports that detail the date, time, location, and description of incidents the
    department investigates. These reports would be great to analyze, except they
    post the information in Microsoft Word documents saved as PDF files, which is
    not the friendliest format for importing into a database.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 华盛顿特区某郊区的一个警长部门发布每日报告，详细说明该部门调查的事件的日期、时间、地点和描述。这些报告本可以很好地进行分析，但它们将信息发布在保存为PDF文件的Microsoft
    Word文档中，这种格式并不适合导入到数据库中。
- en: If I copy and paste incidents from the PDF into a text editor, the result is
    blocks of text that look something like [Listing 14-4](#listing14-4).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将PDF中的事件复制并粘贴到文本编辑器中，结果将是类似[清单14-4](#listing14-4)的文本块。
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 14-4: Crime reports text'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 清单14-4：犯罪报告文本
- en: Each block of text includes dates 1, times 2, a street address 3, city or town
    4, the type of crime 5, and a description of the incident 6. The last piece of
    information is a code 7 that might be a unique ID for the incident, although we’d
    have to check with the sheriff’s department to be sure. There are slight inconsistencies.
    For example, the first block of text has two dates (`4/16/17-4/17/17`) and two
    times (`2100-0900 hrs.`), meaning the exact time of the incident is unknown and
    likely occurred within that time span. The second block has one date and time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每段文本包括日期1、时间2、街道地址3、城市或城镇4、犯罪类型5和事件描述6。最后一项信息是一个代码7，可能是事件的唯一标识符，尽管我们需要向警长办公室确认才能确保。存在一些小的不一致。例如，第一段文本有两个日期（`4/16/17-4/17/17`）和两个时间段（`2100-0900
    hrs.`），这意味着事件的具体时间不确定，很可能发生在这个时间段内。第二段则只有一个日期和时间。
- en: 'If you compile these reports regularly, you can expect to find some good insights
    that could answer important questions: Where do crimes tend to occur? Which crime
    types occur most frequently? Do they happen more often on weekends or weekdays?
    Before you can start answering these questions, you’ll need to extract the text
    into table columns using regular expressions.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您定期汇编这些报告，您可以期望找到一些有价值的见解，帮助回答一些重要问题：犯罪通常发生在哪里？哪些犯罪类型最常发生？它们是更多发生在周末还是工作日？在您开始回答这些问题之前，您需要使用正则表达式将文本提取到表格列中。
- en: Creating a Table for Crime Reports
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建犯罪报告表
- en: I’ve collected five of the crime incidents into a file named *crime_reports.csv*
    that you can download via the link to the book’s resources at [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/).
    Download the file and save it on your computer. Then use the code in [Listing
    14-5](#listing14-5) to build a table that has a column for each data element you
    can parse from the text using a regular expression.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将五个犯罪事件收集到一个名为*crime_reports.csv*的文件中，您可以通过本书资源链接[https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/)下载该文件并保存在您的计算机上。下载文件后，使用[清单14-5](#listing14-5)中的代码构建一个表格，其中每一列用于解析文本中的数据元素，使用正则表达式进行解析。
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 14-5: Creating and loading the `crime_reports` table'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 清单14-5：创建并加载`crime_reports`表
- en: Run the `CREATE TABLE` statement in [Listing 14-5](#listing14-5) and then use
    `COPY` to load the text into the column `original_text`. The rest of the columns
    will be `NULL` until we fill them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 运行[清单14-5](#listing14-5)中的`CREATE TABLE`语句，然后使用`COPY`将文本加载到`original_text`列中。其余的列将为`NULL`，直到我们填写它们。
- en: When you run `SELECT original_text FROM crime_reports;` in pgAdmin, the results
    grid should display five rows and the first several words of each report. When
    you double-click any cell, pgAdmin shows all the text in that row, as shown in
    [Figure 14-1](#figure14-1).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在pgAdmin中运行`SELECT original_text FROM crime_reports;`时，结果网格应显示五行数据，并展示每份报告的前几个单词。当您双击任何单元格时，pgAdmin会显示该行的所有文本，如[图14-1](#figure14-1)所示。
- en: '![f14001](Images/f14001.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![f14001](Images/f14001.png)'
- en: 'Figure 14-1: Displaying additional text in the pgAdmin results grid'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-1：在pgAdmin结果网格中显示额外文本
- en: Now that you’ve loaded the text you’ll be parsing, let’s explore this data using
    PostgreSQL regular expression functions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经加载了要解析的文本，让我们使用PostgreSQL的正则表达式函数来探索这些数据。
- en: Matching Crime Report Date Patterns
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 匹配犯罪报告日期模式
- en: The first piece of data we want to extract from `original_text` is the date
    or dates of the crime. Most reports have one date, although one has two. The reports
    also have associated times, and we’ll combine the extracted date and time into
    a timestamp. We’ll fill `date_1` with each report’s first (or only) date and time.
    If a second date or second time exists, we’ll add it to `date_2`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想从`original_text`中提取的第一项数据是犯罪的日期或日期。大多数报告只有一个日期，尽管有一个报告有两个日期。这些报告还包括相关的时间，我们将把提取的日期和时间组合成一个时间戳。我们将把`date_1`填充为每份报告的第一个（或唯一）日期和时间。如果存在第二个日期或第二个时间，我们将把它添加到`date_2`中。
- en: We’ll use the `regexp_match(``string``,` `pattern``)` function, which is similar
    to `substring()` with a few exceptions. One is that it returns each match as text
    in an array. Also, if there are no matches, it returns `NULL`. As you might recall
    from Chapter 6, you use an array to pass a list of values into the `percentile_cont()`
    function to calculate quartiles. I’ll show you how to work with results that come
    back as an array when we parse the crime reports.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`regexp_match(``string``,` `pattern``)`函数，它与`substring()`类似，但有几个例外。其中一个例外是它将每个匹配项作为数组中的文本返回。此外，如果没有匹配项，它将返回`NULL`。正如您可能从第6章中回忆的那样，您可以使用数组将值列表传递给`percentile_cont()`函数来计算四分位数。在我们解析犯罪报告时，我将向您展示如何处理返回为数组的结果。
- en: 'To start, let’s use `regexp_match()` to find dates in each of the five incidents.
    The general pattern to match is `MM``/``DD``/``YY`, although there may be one
    or two digits for both the month and date. Here’s a regular expression that matches
    the pattern:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请使用`regexp_match()`在每个五起事件中查找日期。用于匹配的一般模式是`MM``/``DD``/``YY`，尽管月份和日期都可能有一到两位数字。下面是匹配此模式的正则表达式：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this expression, the first `\d{1,2}` indicates the month. The numbers inside
    the curly brackets specify that you want at least one digit and at most two digits.
    Next, you want to look for a forward slash (`/`), but because a forward slash
    can have special meaning in regular expressions, you must *escape* that character
    by placing a backslash (`\`) in front of it, like this `\/`. Escaping a character
    in this context simply means we want to treat it as a literal rather than letting
    it take on special meaning. So, the combination of the backslash and forward slash
    (`\/`) indicates you want a forward slash.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在此表达式中，第一个`\d{1,2}`表示月份。花括号中的数字指定您希望至少有一个数字，最多有两个数字。接下来，您要查找一个正斜杠(`/`)，但由于正斜杠在正则表达式中具有特殊含义，您必须*转义*该字符，方法是在其前面加上反斜杠(`\`)，如`\/`所示。在这种上下文中转义字符的意思是我们希望将其视为字面值，而不是让其具有特殊含义。因此，反斜杠和正斜杠的组合(`\/`)表示您希望一个正斜杠。
- en: Another `\d{1,2}` follows for a single- or double-digit day of the month. The
    expression ends with a second escaped forward slash and `\d{2}` to indicate the
    two-digit year. Let’s pass the expression `\d{1,2}\/\d{1,2}\/\d{2}` to `regexp_match()`,
    as shown in [Listing 14-6](#listing14-6).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个`\d{1,2}`后跟一个单或双位数的月份。表达式以第二个转义的正斜杠和`\d{2}`结尾，表示两位数年份。让我们将表达式`\d{1,2}\/\d{1,2}\/\d{2}`传递给`regexp_match()`，如[图示14-6](#listing14-6)所示。
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 14-6: Using `regexp_match()` to find the first date'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图示14-6：使用`regexp_match()`查找第一个日期
- en: 'Run that code in pgAdmin, and the results should look like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在pgAdmin中运行该代码，结果应如下所示：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that each row shows the first date listed for the incident, because `regexp_match()`
    returns the first match it finds by default. Also note that each date is enclosed
    in curly brackets. That’s PostgreSQL indicating that `regexp_match()` returns
    each result as an array type, or list of elements. Later, in the “Extracting Text
    from the regexp_match() Result” section, I’ll show you how to access elements
    in the array. You also can read more about arrays in PostgreSQL at [https://www.postgresql.org/docs/current/arrays.html](https://www.postgresql.org/docs/current/arrays.html).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每行显示了事件的第一个列出日期，因为`regexp_match()`默认返回它找到的第一个匹配项。还请注意，每个日期都用花括号括起来。这是PostgreSQL指示`regexp_match()`将每个结果返回为数组类型或元素列表。稍后在“从`regexp_match()`结果中提取文本”部分，我将向您展示如何访问数组中的元素。您还可以在[https://www.postgresql.org/docs/current/arrays.html](https://www.postgresql.org/docs/current/arrays.html)上阅读有关PostgreSQL数组的更多信息。
- en: Matching the Second Date When Present
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 当存在第二个日期时进行匹配
- en: We’ve successfully matched the first date from each report. But recall that
    one of the five incidents has a second date. To find and display all the dates
    in the text, you must use the related `regexp_matches()` function and pass in
    an option in the form of the flag `g`, as shown in [Listing 14-7](#listing14-7).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功匹配了每份报告中的第一个日期。但请记住，五起事件中有一起还有第二个日期。要查找并显示文本中的所有日期，您必须使用相关的`regexp_matches()`函数，并传递一个选项，形式为标志`g`，如[图示14-7](#listing14-7)所示。
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 14-7: Using the `regexp_matches()` function with the `g` flag'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图示14-7：使用带`g`标志的`regexp_matches()`函数
- en: The `regexp_matches()` function, when supplied the `g` flag 1, differs from
    `regexp_match()` by returning each match the expression finds as a row in the
    results rather than returning just the first match.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`regexp_matches()`函数在提供`g`标志1时，与`regexp_match()`不同，它会将表达式找到的每个匹配项作为结果的行返回，而不仅仅是第一个匹配项。'
- en: 'Run the code again with this revision; you should now see two dates for the
    incident that has a `crime_id` of `1`, like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行代码并进行此修订；现在你应该能看到犯罪编号为`1`的事件有两个日期，像这样：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Any time a crime report has a second date, we want to load it and the associated
    time into the `date_2` column. Although adding the `g` flag shows us all the dates,
    to extract just the second date in a report, we can use the pattern we always
    see when two dates exist. In [Listing 14-4](#listing14-4), the first block of
    text showed the two dates separated by a hyphen, like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每当犯罪报告中有第二个日期时，我们希望将其及相关的时间加载到`date_2`列中。尽管添加`g`标志可以显示所有日期，但为了提取报告中的第二个日期，我们可以使用两日期存在时常见的模式。在[列表14-4](#listing14-4)中，第一段文本显示了两个通过连字符分隔的日期，像这样：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This means you can switch back to `regexp_match()` and write a regular expression
    to look for a hyphen followed by a date, as shown in [Listing 14-8](#listing14-8).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以切换回`regexp_match()`，编写一个正则表达式来查找一个连字符后跟日期，如[列表14-8](#listing14-8)所示。
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 14-8: Using `regexp_match()` to find the second date'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-8：使用`regexp_match()`查找第二个日期
- en: 'Although this query finds the second date in the first item (and returns a
    `NULL` for the rest), there’s an unintended consequence: it displays the hyphen
    along with it.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此查询找到第一个项中的第二个日期（并对其余项返回`NULL`），但它也有一个意外的后果：它会显示连字符。
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You don’t want to include the hyphen, because it’s an invalid format for the
    `timestamp` data type. Fortunately, you can specify the exact part of the regular
    expression you want to return by placing parentheses around it to create a capture
    group, like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你不想包括连字符，因为它是`timestamp`数据类型的无效格式。幸运的是，你可以通过在正则表达式的目标部分周围加上括号来指定确切的返回部分，从而创建一个捕获组，像这样：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This notation returns only the part of the regular expression you want. Run
    the modified query in [Listing 14-9](#listing14-9) to report only the data in
    parentheses.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个符号仅返回正则表达式中你想要的部分。运行修改后的查询，在[列表14-9](#listing14-9)中仅报告括号内的数据。
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 14-9: Using a capture group to return only the date'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-9：使用捕获组仅返回日期
- en: 'The query in [Listing 14-9](#listing14-9) should return just the second date
    without the leading hyphen, as shown here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表14-9](#listing14-9)中的查询应该仅返回第二个日期，而不带前导的连字符，如下所示：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The process you’ve just completed is typical. You start with text to analyze
    and then write and refine the regular expression until it finds the data you want.
    So far, we’ve created regular expressions to match the first date and a second
    date, if it exists. Now, let’s use regular expressions to extract additional data
    elements.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚完成的过程是典型的。你从要分析的文本开始，然后编写和优化正则表达式，直到它找到你想要的数据。到目前为止，我们已经创建了正则表达式，用于匹配第一个日期和第二个日期（如果存在）。现在，让我们使用正则表达式提取更多的数据元素。
- en: Matching Additional Crime Report Elements
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 匹配附加的犯罪报告元素
- en: 'In this section, we’ll capture times, addresses, crime type, description, and
    case number from the crime reports. Here are the expressions for capturing this
    information:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将从犯罪报告中提取时间、地址、犯罪类型、描述和案件编号。以下是用于捕获这些信息的表达式：
- en: '**First hour `\/\d{2}\n(\d{4})`**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一个小时 `\/\d{2}\n(\d{4})`**'
- en: 'The first hour, which is the hour the crime was committed or the start of the
    time range, always follows the date in each crime report, like this:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个小时，即犯罪发生的时间或时间范围的开始，始终跟在每个犯罪报告中的日期后面，像这样：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To find the first hour, we start with an escaped forward slash and `\d{2}`,
    which represents the two-digit year preceding the first date (`17`). The `\n`
    character indicates the newline because the hour always starts on a new line,
    and `\d{4}` represents the four-digit hour (`2100`). Because we just want to return
    the four digits, we put `\d{4}` inside parentheses as a capture group.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了找到第一个小时，我们从一个转义的正斜杠和`\d{2}`开始，`\d{2}`代表第一个日期前的两位数年份（`17`）。`\n`字符表示换行符，因为小时总是从新的一行开始，`\d{4}`表示四位数字的小时（`2100`）。由于我们只想返回四个数字，我们将`\d{4}`放入括号中作为捕获组。
- en: '**Second hour `\/\d{2}\n\d{4}-(\d{4})`**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二小时 `\/\d{2}\n\d{4}-(\d{4})`**'
- en: If the second hour exists, it will follow a hyphen, so we add a hyphen and another
    `\d{4}` to the expression we just created for the first hour. Again, the second
    `\d{4}` goes inside a capture group, because `0900` is the only hour we want to
    return.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第二小时存在，它将跟在连字符后面，因此我们在刚刚为第一个小时创建的表达式中添加了一个连字符和另一个`\d{4}`。再次强调，第二个`\d{4}`放入捕获组中，因为我们只希望返回`0900`这个小时。
- en: '**Street `hrs.\n(\d+ .+(?:Sq.|Plz.|Dr.|Ter.|Rd.))`**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**街道 `hrs.\n(\d+ .+(?:Sq.|Plz.|Dr.|Ter.|Rd.))`**'
- en: 'In this data, the street always follows the time’s `hrs.` designation and a
    newline (`\n`), like this:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些数据中，街道总是跟随时间的`hrs.`标识符，并在换行符（`\n`）之后，如下所示：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The street address always starts with some number that varies in length and
    ends with an abbreviated suffix of some kind. To describe this pattern, we use
    `\d+` to match any digit that appears one or more times. Then we specify a space
    and look for any character one or more times using the dot wildcard and plus sign
    (`.+`) notation. The expression ends with a series of terms separated by the alternation
    pipe symbol that looks like this: `(?:Sq.|Plz.|Dr.|Ter.|Rd.)`. The terms are inside
    parentheses, so the expression will match one or another of those terms. When
    we group terms like this, if we don’t want the parentheses to act as a capture
    group, we need to add `?:` to negate that effect.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 街道地址总是以某个长度不等的数字开头，并以某种缩写后缀结尾。为了描述这个模式，我们使用`\d+`来匹配出现一次或多次的任何数字。然后我们指定一个空格，使用点通配符和加号（`.+`）符号来查找任何字符，出现一次或多次。表达式以一系列由交替管道符号分隔的术语结尾，格式如下：`(?:Sq.|Plz.|Dr.|Ter.|Rd.)`。这些术语被括号括起来，因此表达式会匹配这些术语中的任何一个。当我们像这样分组术语时，如果我们不希望括号作为捕获组，我们需要在括号前加上`?:`来消除这一效果。
- en: '**City `(?:Sq.|Plz.|Dr.|Ter.|Rd.)\n(\w+ \w+|\w+)\n`**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**城市 `(?:Sq.|Plz.|Dr.|Ter.|Rd.)\n(\w+ \w+|\w+)\n`**'
- en: Because the city always follows the street suffix, we reuse the terms separated
    by the alternation symbol we just created for the street. We follow that with
    a newline (`\n`) and then use a capture group to look for two words or one word
    `(\w+ \w+|\w+)` before a final newline, because a town or city name can be more
    than a single word.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为城市总是跟随街道后缀，我们会重用之前为街道创建的由交替符号分隔的术语。接着，我们添加一个换行符（`\n`），然后使用捕获组查找两个单词或一个单词`(\w+
    \w+|\w+)`，之后是一个最终的换行符，因为一个城镇或城市名称可能不止一个单词。
- en: '**Crime type `\n(?:\w+ \w+|\w+)\n(.*):`**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**犯罪类型 `\n(?:\w+ \w+|\w+)\n(.*):`**'
- en: 'The type of crime always precedes a colon (the only time a colon is used in
    each report) and might consist of one or more words, like this:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 犯罪类型总是位于冒号前（每个报告中唯一使用冒号的地方），并可能由一个或多个单词组成，如下所示：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To create an expression that matches this pattern, we follow a newline with
    a nonreporting capture group that looks for the one- or two-word city. Then we
    add another newline and match any character that occurs zero or more times before
    a colon using `(.*):`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个匹配此模式的表达式，我们在换行符后添加一个非报告捕获组，查找一个或两个单词的城市名称。然后我们再添加一个换行符，并匹配冒号前的任何字符，使用`(.*):`。
- en: '**Description `:\s(.+)(?:C0|SO)`**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**描述 `:\s(.+)(?:C0|SO)`**'
- en: The crime description always comes between the colon after the crime type and
    the case number. The expression starts with the colon, a space character (`\s`),
    and then a capture group to find any character that appears one or more times
    using the `.+` notation. The nonreporting capture group `(?:C0|SO)` tells the
    program to stop looking when it encounters either `C0` or `SO`, the two character
    pairs that start each case number (a *C* followed by a zero, and an *S* followed
    by a capital *O*). We have to do this because the description might have one or
    more line breaks.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 犯罪描述总是位于犯罪类型和案件编号之间的冒号后面。该表达式从冒号开始，接着是一个空格字符（`\s`），然后是一个捕获组，用于查找出现一次或多次的任何字符，使用`.+`符号。非报告捕获组`(?:C0|SO)`告诉程序当遇到`C0`或`SO`时停止查找，这两个字符对是每个案件编号的开头（*C*后跟零，*S*后跟大写字母*O*）。我们必须这样做，因为描述中可能有一个或多个换行符。
- en: '**Case number `(?:C0|SO)[0-9]+`**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**案件编号 `(?:C0|SO)[0-9]+`**'
- en: The case number starts with either `C0` or `SO`, followed by a set of digits.
    To match this pattern, the expression looks for either `C0` or `SO` in a nonreporting
    capture group followed by any digit from 0 to 9 that occurs one or more times
    using the `[0-9]` range notation.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 案件编号以`C0`或`SO`开头，后跟一组数字。为了匹配这个模式，表达式首先在一个非报告捕获组中查找`C0`或`SO`，然后查找任意数字（0到9之间）出现一次或多次，使用`[0-9]`范围符号。
- en: Now let’s pass some of these regular expressions to `regexp_match()` to see
    them in action. [Listing 14-10](#listing14-10) shows a sample `regexp_match()`
    query that retrieves the case number, first date, crime type, and city.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将这些正则表达式传递给`regexp_match()`，看看它们的实际效果。[Listing 14-10](#listing14-10)展示了一个示例`regexp_match()`查询，用于检索案件编号、日期、犯罪类型和城市。
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 14-10: Matching case number, date, crime type, and city'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 14-10：匹配案件编号、日期、犯罪类型和城市
- en: 'Run the code, and the results should look like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，结果应如下所示：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After all that wrangling, we’ve transformed the text into a structure that is
    more suitable for analysis. Of course, you would have to include many more incidents
    to count the frequency of crime type by city or by the number of crimes per month
    to identify any trends.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些处理后，我们已将文本转化为更适合分析的结构。当然，您需要包含更多的事件，以便按城市计算犯罪类型的频率，或按月计算犯罪数量，以识别任何趋势。
- en: To load each parsed element into the table’s columns, we’ll create an `UPDATE`
    query. But before you can insert the text into a column, you’ll need to learn
    how to extract the text from the array that `regexp_match()` returns.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将每个解析的元素加载到表的列中，我们将创建一个 `UPDATE` 查询。但是，在您能够将文本插入列之前，您需要学习如何从 `regexp_match()`
    返回的数组中提取文本。
- en: Extracting Text from the regexp_match() Result
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从 `regexp_match()` 结果中提取文本
- en: In “Matching Crime Report Date Patterns,” I mentioned that `regexp_match()`
    returns data in an array type containing text. Two clues reveal that these are
    array types. The first is that the data type designation in the column header
    shows `text[]` instead of `text`. The second is that each result is surrounded
    by curly brackets. [Figure 14-2](#figure14-2) shows how pgAdmin displays the results
    of the query in [Listing 14-10](#listing14-10).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在“匹配犯罪报告日期模式”中，我提到过 `regexp_match()` 返回的数据是一个包含文本的数组类型。两个线索表明这些是数组类型。第一个线索是列头的数据类型标识显示为
    `text[]` 而不是 `text`。第二个线索是每个结果都被大括号括起来。[图 14-2](#figure14-2) 显示了 pgAdmin 如何展示[列表
    14-10](#listing14-10)中的查询结果。
- en: '![f14002](Images/f14002.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![f14002](Images/f14002.png)'
- en: 'Figure 14-2: Array values in the pgAdmin results grid'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-2：pgAdmin 结果网格中的数组值
- en: The `crime_reports` columns we want to update are not array types, so rather
    than passing in the array values returned by `regexp_match()`, we need to extract
    the values from the array first. We do this by using array notation, as shown
    in [Listing 14-11](#listing14-11).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要更新的 `crime_reports` 列不是数组类型，因此我们需要先从数组中提取值，而不是直接传递 `regexp_match()` 返回的数组值。我们通过使用数组表示法来做到这一点，如[列表
    14-11](#listing14-11)所示。
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 14-11: Retrieving a value from within an array'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-11：从数组中检索值
- en: 'First, we wrap the `regexp_match()` function 1 in parentheses. Then, at the
    end, we provide a value of `1`, which represents the first element in the array,
    enclosed in square brackets 2. The query should produce the following results:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 `regexp_match()` 函数 1 用括号括起来。然后，在最后，我们提供一个值 `1`，表示数组中的第一个元素，并用方括号 2 括起来。查询应产生以下结果：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now the data type designation in the pgAdmin column header should show `text`
    instead of `text[]`, and the values are no longer enclosed in curly brackets.
    We can now insert these values into `crime_reports` using an `UPDATE` query.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，pgAdmin 列头中的数据类型标识应该显示为 `text`，而不是 `text[]`，并且这些值不再被大括号括起来。我们现在可以使用 `UPDATE`
    查询将这些值插入到 `crime_reports` 中。
- en: Updating the crime_reports Table with Extracted Data
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新 `crime_reports` 表中的提取数据
- en: To start updating columns in `crime_reports`, [Listing 14-12](#listing14-12)
    combines the extracted first date and time into a single `timestamp` value for
    the column `date_1`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始更新 `crime_reports` 中的列，[列表 14-12](#listing14-12) 将提取的第一个日期和时间合并成一个单一的 `timestamp`
    值，用于 `date_1` 列。
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 14-12: Updating the `crime_reports` `date_1` column'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-12：更新 `crime_reports` 中的 `date_1` 列
- en: Because the `date_1` column is of type `timestamp`, we must provide an input
    in that data type. To do that, we’ll use the PostgreSQL double-pipe (`||`) concatenation
    operator to combine the extracted date and time in a format that’s acceptable
    for `timestamp with time zone` input. In the `SET` clause 1, we start with the
    regex pattern that matches the first date 2. Next, we concatenate the date with
    a space using two single quotes 3 and repeat the concatenation operator. This
    step combines the date with a space before connecting it to the regex pattern
    that matches the time 4. Then we include the time zone for the Washington, DC,
    area by concatenating that at the end of the string 5 using the `US/Eastern` designation.
    Concatenating these elements creates a string in the pattern of `MM``/``DD``/``YY``HH:MM``TIMEZONE`,
    which is acceptable as a `timestamp` input. We cast the string to a `timestamp
    with time zone` data type 6 using the PostgreSQL double-colon shorthand and the
    `timestamptz` abbreviation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`date_1`列是`timestamp`类型，我们必须提供该数据类型的输入。为此，我们将使用PostgreSQL的双管道符号（`||`）连接操作符，将提取的日期和时间组合成`timestamp
    with time zone`类型输入可接受的格式。在`SET`子句1中，我们从匹配第一个日期的正则表达式模式开始2。接下来，我们使用两个单引号3将日期与空格连接，并重复连接操作符。这一步将日期与空格结合，然后再将其与匹配时间的正则表达式模式连接4。然后，我们通过在字符串末尾使用`US/Eastern`时区标识符来包含华盛顿特区的时区5。连接这些元素后，我们得到一个格式为`MM``/``DD``/``YY``HH:MM``TIMEZONE`的字符串，这是一个可接受的`timestamp`输入格式。我们使用PostgreSQL的双冒号简写和`timestamptz`缩写将该字符串转换为`timestamp
    with time zone`数据类型6。
- en: 'When you run the `UPDATE`, the `RETURNING` clause will display the columns
    we specify from the updated rows, including the now-filled `date_1` column alongside
    a portion of the `original_text` column, like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`UPDATE`语句时，`RETURNING`子句将显示我们指定的已更新行中的列，包括现在已填充的`date_1`列，以及`original_text`列的一部分，类似这样：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At a glance, you can see that `date_1` accurately captures the first date and
    time that appears in the original text and puts it into a format that we can analyze—quantifying,
    for example, which times of day crimes most often occur. Note that if you’re not
    in the Eastern time zone, the timestamps will instead reflect your pgAdmin client’s
    time zone. Also, in pgAdmin, you may need to double-click a cell in the `original_text`
    column to see the full text.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一眼看去，你可以看到`date_1`准确地捕捉到原始文本中出现的第一个日期和时间，并将其转换为我们可以分析的格式——例如，量化一天中犯罪最常发生的时间。请注意，如果你不在东部时区，时间戳将反映你pgAdmin客户端的时区。另外，在pgAdmin中，你可能需要双击`original_text`列中的单元格才能查看完整的文本。
- en: Using CASE to Handle Special Instances
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用CASE处理特殊情况
- en: You could write an `UPDATE` statement for each remaining data element, but combining
    those statements into one would be more efficient. [Listing 14-13](#listing14-13)
    updates all the `crime_reports` columns using a single statement while handling
    inconsistent values in the data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为每个剩余的数据元素写一个`UPDATE`语句，但将这些语句合并成一个会更高效。[清单 14-13](#listing14-13)使用单个语句更新所有`crime_reports`列，同时处理数据中的不一致值。
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 14-13: Updating all `crime_reports` columns'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-13：更新所有`crime_reports`列
- en: 'This `UPDATE` statement might look intimidating, but it’s not if we break it
    down by column. First, we use the same code from [Listing 14-9](#listing14-9)
    to update the `date_1` column 1. But to update `date_2` 2, we need to account
    for the inconsistent presence of a second date and time. In our limited dataset,
    there are three possibilities:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`UPDATE`语句看起来可能令人畏惧，但如果我们按列分解，它并不会那么复杂。首先，我们使用[清单 14-9](#listing14-9)中的相同代码来更新`date_1`列1。但要更新`date_2`列2，我们需要考虑第二个日期和时间的不一致性。在我们有限的数据集中，存在三种可能性：
- en: A second hour exists but not a second date. This occurs when a report covers
    a range of hours on one date.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在第二个小时，但没有第二个日期。当报告涵盖同一日期的多个小时范围时，就会发生这种情况。
- en: A second date and second hour exist. This occurs when a report covers more than
    one date.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在第二个日期和第二个小时。当报告涵盖多个日期时，会发生这种情况。
- en: Neither a second date nor a second hour exists.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既没有第二个日期，也没有第二个小时。
- en: To insert the correct value in `date_2` for each scenario, we use a `CASE` statement
    to test for each possibility. After the `CASE` keyword 3, we use a series of `WHEN
    ... THEN` statements to check for the first two conditions and provide the value
    to insert; if neither condition exists, the `CASE` statement will by default return
    a `NULL`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在每种情况下插入正确的`date_2`值，我们使用`CASE`语句来测试每一种可能性。在`CASE`关键字3后，我们使用一系列`WHEN ... THEN`语句来检查前两个条件并提供插入的值；如果没有符合条件的情况，`CASE`语句默认返回`NULL`。
- en: The first `WHEN` statement 4 checks whether `regexp_match()` returns a `NULL`
    5 for the second date and a value for the second hour (using `IS NOT NULL` 6).
    If that condition evaluates as `true`, the `THEN` statement 7 concatenates the
    first date with the second hour to create a timestamp for the update.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `WHEN` 语句 4 检查 `regexp_match()` 是否返回第二个日期的 `NULL` 5，以及第二个小时的值（使用 `IS NOT
    NULL` 6）。如果该条件为 `true`，则 `THEN` 语句 7 会将第一个日期与第二个小时拼接，创建更新时间戳。
- en: The second `WHEN` statement 8 checks that `regexp_match()` returns a value for
    the second hour and second date. If `true`, the `THEN` statement concatenates
    the second date with the second hour to create a timestamp.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `WHEN` 语句 8 检查 `regexp_match()` 是否返回第二个小时和第二个日期的值。如果为 `true`，那么 `THEN` 语句会将第二个日期与第二个小时拼接，生成时间戳。
- en: If neither of the two `WHEN` statements returns `true`, the `CASE` statement
    will return a `NULL` because there is only a first date and first time.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个 `WHEN` 语句都没有返回 `true`，那么 `CASE` 语句将返回 `NULL`，因为只有第一个日期和第一个时间。
- en: When we run the full query in [Listing 14-13](#listing14-13), PostgreSQL should
    report `UPDATE 5`. Success! Now that we’ve updated all the columns with the appropriate
    data while accounting for elements that have additional data, we can examine all
    the columns of the table and find the parsed elements from `original_text`. [Listing
    14-14](#listing14-14) queries four of the columns.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[清单14-13](#listing14-13)中运行完整查询时，PostgreSQL 应该会报告 `UPDATE 5`。成功！现在，我们已经更新了所有列，并且在考虑到有附加数据的元素时，我们可以检查表的所有列，找到从
    `original_text` 中解析出的元素。[清单14-14](#listing14-14) 查询了其中的四列。
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 14-14: Viewing selected crime data'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 清单14-14：查看选定的犯罪数据
- en: 'The results of the query should show a nicely organized set of data that looks
    something like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果应该显示一个组织良好的数据集，类似于以下内容：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You’ve successfully transformed raw text into a table that can answer questions
    and reveal storylines about crime in this area.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功地将原始文本转化为一个可以回答问题并揭示该地区犯罪故事的表。
- en: The Value of the Process
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过程的价值
- en: Writing regular expressions and coding a query to update a table can take time,
    but there is value to identifying and collecting data this way. In fact, some
    of the best datasets you’ll encounter are those you build yourself. Everyone can
    download the same datasets, but the ones you build are yours alone. You get to
    be first person to find and tell the story behind the data.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 编写正则表达式和编写更新表的查询可能需要时间，但通过这种方式识别和收集数据是有价值的。事实上，您遇到的一些最好的数据集正是您自己构建的。每个人都可以下载相同的数据集，但您构建的数据集是您独有的。您可以成为第一个发现并讲述数据背后故事的人。
- en: Also, after you set up your database and queries, you can use them again and
    again. In this example, you could collect crime reports every day (either by hand
    or by automating downloads using a programming language such as Python) for an
    ongoing dataset that you can mine continually for trends.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在设置好数据库和查询后，您可以反复使用它们。在这个示例中，您可以每天收集犯罪报告（无论是手动收集还是通过使用如 Python 等编程语言自动下载），以便获取一个可以不断挖掘趋势的持续数据集。
- en: In the next section, we’ll continue our exploration of text by implementing
    a search engine using PostgreSQL.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将继续探索文本，通过使用 PostgreSQL 实现一个搜索引擎。
- en: Full-Text Search in PostgreSQL
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PostgreSQL中的全文搜索
- en: PostgreSQL comes with a powerful full-text search engine that adds capabilities
    for searching large amounts of text, similar to online search tools and technology
    that powers search on research databases, such as Factiva. Let’s walk through
    a simple example of setting up a table for text search and associated search functions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 提供了一个强大的全文搜索引擎，能够处理大量文本的搜索，类似于在线搜索工具和技术，支持像 Factiva 这样的研究数据库的搜索。让我们通过一个简单的示例来演示如何设置一个用于文本搜索的表和相关的搜索功能。
- en: For this example, I assembled 79 speeches by US presidents since World War II.
    Consisting mostly of State of the Union addresses, these public texts are available
    through the Internet Archive at [https://archive.org/](https://archive.org/) and
    the University of California’s American Presidency Project at [https://www.presidency.ucsb.edu/](https://www.presidency.ucsb.edu/).
    You can find the data in the *president_speeches.csv* file along with the book’s
    resources at [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我收集了自二战以来的79篇美国总统演讲。这些演讲大多数来自国情咨文，这些公开的文本可以通过互联网档案馆（[https://archive.org/](https://archive.org/)）和加利福尼亚大学的美国总统项目（[https://www.presidency.ucsb.edu/](https://www.presidency.ucsb.edu/)）访问。你可以在*president_speeches.csv*文件中找到数据，以及本书的相关资源，地址为[https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/)。
- en: Let’s start with the data types unique to full-text search.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从全文搜索特有的数据类型开始。
- en: Text Search Data Types
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本搜索数据类型
- en: PostgreSQL’s implementation of text search includes two data types. The `tsvector`
    data type represents the text to be searched and to be stored in a normalized
    form. The `tsquery` data type represents the search query terms and operators.
    Let’s look at the details of both.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL的全文搜索实现包含两种数据类型。`tsvector`数据类型表示要搜索的文本，并将其存储为标准化的形式。`tsquery`数据类型表示搜索查询词和操作符。我们来详细看看这两种类型。
- en: Storing Text as Lexemes with tsvector
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用tsvector存储文本为词元
- en: The `tsvector` data type reduces text to a sorted list of *lexemes*, which are
    linguistic units in a given language. It’s helpful to think of lexemes as word
    roots without the variations created by suffixes. For example, a `tsvector` type
    column would store the words *washes*, *washed*, and *washing* as the lexeme *wash*
    while noting each word’s position in the original text. Converting text to `tsvector`
    also removes small *stop words* that usually don’t play a role in search, such
    as *the* or *it*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsvector`数据类型将文本简化为一个排序的*词元*列表，词元是某种语言中的语言单位。将词元看作是没有后缀变化的词根是很有帮助的。例如，`tsvector`类型的列会将*洗涤*、*已洗*和*正在洗*存储为词元*wash*，同时标注每个单词在原始文本中的位置。将文本转换为`tsvector`还会去除那些通常在搜索中不起作用的小*停用词*，如*the*或*it*。'
- en: To see how this data type works, let’s convert a string to `tsvector` format.
    [Listing 14-15](#listing14-15) uses the PostgreSQL search function `to_tsvector()`,
    which normalizes the text “I am walking across the sitting room to sit with you”
    to lexemes using the `english` language search configuration.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这种数据类型的工作方式，让我们将一个字符串转换为`tsvector`格式。[示例 14-15](#listing14-15)使用了PostgreSQL搜索功能`to_tsvector()`，该函数将文本“I
    am walking across the sitting room to sit with you”使用`english`语言搜索配置标准化为词元（lexemes）。
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 14-15: Converting text to `tsvector` data'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 14-15：将文本转换为`tsvector`数据
- en: 'Execute the code, and it should return the following output in the `tsvector`
    data type:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码后，它应该返回以下`tsvector`数据类型的输出：
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `to_tsvector()` function reduces the number of words from eleven to four,
    eliminating words such as *I*, *am*, and *the*, which are not helpful search terms.
    The function removes suffixes, changing *walking* to *walk* and *sitting* to *sit*.
    It orders the words alphabetically, and the number following each colon indicates
    its position in the original string, taking stop words into account. Note that
    *sit* is recognized as being in two positions, one for *sitting* and one for *sit*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_tsvector()`函数将单词数量从十一减少到四，去除了诸如*I*、*am*和*the*等无助于搜索的词。该函数还去除了词尾变化，将*walking*转为*walk*，将*sitting*转为*sit*。它按字母顺序排列单词，冒号后面的数字表示它在原始字符串中的位置，并考虑了停用词。请注意，*sit*被识别为出现在两个位置，一个对应*sitting*，一个对应*sit*。'
- en: Creating the Search Terms with tsquery
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用tsquery创建搜索词
- en: The `tsquery` data type represents the full-text search query, again optimized
    as lexemes. It also provides operators for controlling the search. Examples of
    operators include the ampersand (`&`) for AND, the pipe symbol (`|`) for OR, and
    the exclamation point (`!`) for NOT. The `<->` followed by operator lets you search
    for adjacent words or words a certain distance apart.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsquery`数据类型表示全文搜索查询，同样优化为词元。它还提供用于控制搜索的操作符。操作符示例包括用于AND的与号（`&`）、用于OR的管道符号（`|`）和用于NOT的感叹号（`!`）。`<->`后跟操作符可以让你搜索相邻的单词或一定距离内的单词。'
- en: '[Listing 14-16](#listing14-16) shows how the `to_tsquery()` function converts
    search terms to the `tsquery` data type.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14-16](#listing14-16)展示了`to_tsquery()`函数如何将搜索词转换为`tsquery`数据类型。'
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 14-16: Converting search terms to `tsquery` data'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 14-16：将搜索词转换为`tsquery`数据
- en: 'After running the code, you should see that the resulting `tsquery` data type
    has normalized the terms into lexemes, which match the format of the data to search:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码后，您应该会看到生成的`tsquery`数据类型已将术语标准化为词元，这与要搜索的数据格式相匹配：
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now you can use terms stored as `tsquery` to search text optimized as `tsvector`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用作为`tsquery`存储的术语来搜索已优化为`tsvector`的文本。
- en: Using the @@ Match Operator for Searching
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用@@匹配操作符进行搜索
- en: With the text and search terms converted to the full-text search data types,
    you can use the double at sign (`@@`) match operator to check whether a query
    matches text. The first query in [Listing 14-17](#listing14-17) uses `to_tsquery()`
    to evaluate whether the text contains both *walking* and *sitting*, which we combine
    with the `&` operator. It returns a Boolean value of `true` because the lexemes
    of both *walking* and *sitting* are present in the text converted by `to_tsvector()`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本和搜索词转换为全文搜索数据类型后，您可以使用双@符号（`@@`）匹配操作符来检查查询是否与文本匹配。[清单14-17](#listing14-17)中的第一个查询使用`to_tsquery()`来评估文本是否同时包含*walking*和*sitting*，我们通过`&`操作符将它们结合起来。由于`to_tsvector()`转换的文本中包含*walking*和*sitting*的词元，因此返回布尔值`true`。
- en: '[PRE38]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 14-17: Querying a `tsvector` type with a `tsquery`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 清单14-17：使用`tsquery`查询`tsvector`类型
- en: However, the second query returns `false` because both *walking* and *running*
    are not present in the text. Now let’s build a table for searching the speeches.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二个查询返回`false`，因为*walking*和*running*都不在文本中。现在让我们为搜索演讲创建一个表。
- en: Creating a Table for Full-Text Search
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建全文搜索的表
- en: The code in [Listing 14-18](#listing14-18) creates and fills `president_speeches`
    with a column for the original text as well as a column of type `tsvector`. After
    the import, we’ll convert the speech text to the `tsvector` data type. Note that
    to accommodate how I set up the CSV file, the `WITH` clause in `COPY` has a different
    set of parameters than what we’ve generally used. It’s pipe-delimited and uses
    an ampersand for quoting.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-18](#listing14-18)中的代码创建并填充`president_speeches`，该表包含一个原始文本列和一个`tsvector`类型的列。导入后，我们将把演讲文本转换为`tsvector`数据类型。请注意，为了适应我设置CSV文件的方式，`COPY`中的`WITH`子句有一组与我们通常使用的参数不同的参数。它是管道分隔的，并且使用&符号进行引用。'
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 14-18: Creating and filling the `president_speeches` table'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 清单14-18：创建并填充`president_speeches`表
- en: After executing the query, run `SELECT * FROM president_speeches;` to see the
    data. In pgAdmin, double-click any cell to see extra words not visible in the
    results grid. You should see a sizable amount of text in each row of the `speech_text`
    column.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 执行查询后，运行`SELECT * FROM president_speeches;`以查看数据。在pgAdmin中，双击任何单元格以查看结果网格中不可见的额外单词。您应该会看到`speech_text`列中的每一行都有大量文本。
- en: 'Next, we use the `UPDATE` query in [Listing 14-19](#listing14-19) to copy the
    contents of `speech_text` to the `tsvector` column `search_speech_text` and transform
    it to that data type at the same time:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用[清单14-19](#listing14-19)中的`UPDATE`查询，将`speech_text`的内容复制到`tsvector`列`search_speech_text`中，并同时将其转换为该数据类型：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 14-19: Converting speeches to `tsvector` in the `search_speech_text`
    column'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 清单14-19：将演讲转换为`tsvector`并存储在`search_speech_text`列中
- en: The `SET` clause 1 fills `search_speech_text` with the output of `to_tsvector()`.
    The first argument in the function specifies the language for parsing the lexemes.
    We’re using `english` here, but you can substitute `spanish`, `german`, `french`,
    and other languages (some languages may require you to find and install additional
    dictionaries). Using `simple` for the language will remove stop words but not
    reduce words to lexemes. The second argument is the name of the input column.
    Run the code to fill the column.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`SET`子句1使用`to_tsvector()`的输出填充`search_speech_text`。该函数的第一个参数指定了用于解析词元的语言。我们在这里使用`english`，但您也可以替换为`spanish`、`german`、`french`等其他语言（某些语言可能需要您查找并安装额外的词典）。将语言设置为`simple`将删除停用词，但不会将单词还原为词元。第二个参数是输入列的名称。运行代码以填充该列。'
- en: Finally, we want to index the `search_speech_text` column to speed up searches.
    You learned about indexing in Chapter 8, which focused on PostgreSQL’s default
    index type, B-tree. For full-text search, the PostgreSQL documentation recommends
    using the *generalized inverted index* (*GIN*). A GIN index, according to the
    documentation, contains “an index entry for each word (lexeme), with a compressed
    list of matching locations.” See [https://www.postgresql.org/docs/current/textsearch-indexes.html](https://www.postgresql.org/docs/current/textsearch-indexes.html)
    for details.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要对`search_speech_text`列进行索引，以加速搜索。你在第8章学习了索引，内容集中在PostgreSQL的默认索引类型——B树。对于全文搜索，PostgreSQL文档推荐使用*广义倒排索引*（*GIN*）。根据文档，GIN索引包含“每个单词（词素）的索引条目，以及匹配位置的压缩列表”。有关详细信息，请参见[https://www.postgresql.org/docs/current/textsearch-indexes.html](https://www.postgresql.org/docs/current/textsearch-indexes.html)。
- en: You can add a GIN index using `CREATE INDEX` in [Listing 14-20](#listing14-20).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[列表14-20](#listing14-20)中使用`CREATE INDEX`添加GIN索引。
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 14-20: Creating a GIN index for text search'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-20：为文本搜索创建GIN索引
- en: Now you’re ready to use search functions.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好使用搜索功能了。
- en: Searching Speech Text
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索演讲文本
- en: Nearly 80 years’ worth of presidential speeches is fertile ground for exploring
    history. For example, the query in [Listing 14-21](#listing14-21) lists the speeches
    in which the president discussed Vietnam.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 近80年的总统演讲是探索历史的沃土。例如，[列表14-21](#listing14-21)中的查询列出了总统讨论越南问题的演讲。
- en: '[PRE42]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 14-21: Finding speeches containing the word *Vietnam*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-21：查找包含*Vietnam*（越南）一词的演讲
- en: In the `WHERE` clause, the query uses the double at sign (`@@`) match operator
    1 between the `search_speech_text` column (of data type `tsvector`) and the query
    term *Vietnam*, which `to_tsquery()` transforms into `tsquery` data. The results
    should list 19 speeches, showing that the first mention of Vietnam came up in
    a 1961 special message to Congress by John F. Kennedy and became a recurring topic
    starting in 1966 as America’s involvement in the Vietnam War escalated.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WHERE`子句中，查询使用双@符号（`@@`）匹配运算符，将`search_speech_text`列（数据类型为`tsvector`）和查询词*Vietnam*进行匹配，`to_tsquery()`函数将其转换为`tsquery`数据。结果应该列出19个演讲，显示越南首次出现在1961年约翰·F·肯尼迪的国会特别报告中，并且从1966年起成为美国越南战争升级后反复提及的话题。
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Before we try more searches, let’s add a method for showing the location of
    our search term in the text.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试更多搜索之前，让我们添加一个方法来显示搜索词在文本中的位置。
- en: Showing Search Result Locations
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示搜索结果位置
- en: To see where our search terms appear in text, we can use the `ts_headline()`
    function. It displays one or more highlighted search terms surrounded by adjacent
    words with options to format the display, the number of words to show around the
    matched search term, and how many matched results to show from each row of text.
    [Listing 14-22](#listing14-22) highlights how to display a search for a specific
    instance of the word *tax* using `ts_headline()`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们的搜索词在文本中出现的位置，可以使用`ts_headline()`函数。该函数显示一个或多个高亮的搜索词，并用相邻的单词围绕，提供格式化显示选项、显示匹配搜索词周围的单词数以及每行文本显示多少个匹配结果。[列表14-22](#listing14-22)展示了如何使用`ts_headline()`显示特定实例的*tax*（税收）一词的搜索结果。
- en: '[PRE44]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Listing 14-22: Displaying search results with `ts_headline()`'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-22：使用`ts_headline()`显示搜索结果
- en: To declare `ts_headline()` 1, we pass the original `speech_text` column rather
    than the `tsvector` column we used in the search function as the first argument.
    Then, as the second argument, we pass a `to_tsquery()` function that specifies
    the word to highlight. We follow this with a third argument that lists optional
    formatting parameters 2 separated by commas. Here, we specify characters that
    will identify the start and end of the matched search term or terms (`StartSel`
    and `StopSel`). We also set the minimum and maximum number of total words to display,
    including the matched terms (`MinWords` and `MaxWords`), plus the maximum number
    of fragments (or instances of a match) to show using `MaxFragments`. These settings
    are optional, and you can adjust them according to your needs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了声明`ts_headline()`，我们将原始的`speech_text`列传递给它，而不是我们在搜索函数中使用的`tsvector`列作为第一个参数。然后，作为第二个参数，我们传递一个`to_tsquery()`函数，用来指定要高亮的单词。接着，我们传递第三个参数，列出由逗号分隔的可选格式化参数。这里，我们指定了标识匹配搜索词的开始和结束字符（`StartSel`和`StopSel`）。我们还设置了显示的最小和最大总单词数（包括匹配的单词）（`MinWords`和`MaxWords`），以及使用`MaxFragments`显示的最大匹配片段数（或匹配实例）。这些设置是可选的，你可以根据需要调整它们。
- en: 'The results of this query should show at most seven words per speech, highlighting
    words in which *tax* is the root:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询的结果应该显示每篇演讲中最多七个单词，突出显示以*tax*为词根的单词：
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, we can quickly see the context of the term we searched. You might also
    use this function to provide flexible display options for a search feature on
    a web application. And notice that we didn’t just find exact matches. The search
    engine identified `tax` along with `taxes`, `Tax`, and `Taxes`—words with *tax*
    as the root and regardless of case.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以快速看到我们搜索的术语的上下文。你也可以使用此功能为网页应用程序提供灵活的搜索展示选项。还要注意，我们不仅仅找到了精确匹配。搜索引擎识别了`tax`以及`taxes`、`Tax`和`Taxes`——这些词都是以*tax*为词根，不管大小写。
- en: Let’s continue trying forms of searches.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续尝试不同的搜索形式。
- en: Using Multiple Search Terms
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用多个搜索条件
- en: As another example, we could look for speeches in which a president mentioned
    the word *transportation* but didn’t discuss *roads*. We might want to do this
    to find speeches that focused on broader policy rather than a specific roads program.
    To do this, we use the syntax in [Listing 14-23](#listing14-23).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，我们可以查找总统提到*transportation*但没有讨论*roads*的演讲。我们可能希望这样做，是为了找到关注更广泛政策而非具体道路项目的演讲。为此，我们可以使用[列表
    14-23](#listing14-23)中的语法。
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Listing 14-23: Finding speeches with the word *transportation* but not *roads*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-23：查找包含*transportation*但不包含*roads*的演讲
- en: 'Again, we use `ts_headline()` 1 to highlight the terms our search finds. In
    the `to_tsquery()` function in the `WHERE` clause 2, we pass `transportation`
    and `roads`, combining them with the ampersand (`&`) operator. We use the exclamation
    point (`!`) in front of `roads` to indicate that we want speeches that do not
    contain this word. This query should find 15 speeches that fit the criteria. Here
    are the first four rows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`ts_headline()`1来突出显示我们搜索到的术语。在`WHERE`子句2中的`to_tsquery()`函数里，我们传递了`transportation`和`roads`，并用`&`运算符将它们组合在一起。我们在`roads`前面使用了感叹号（`!`），表示我们希望查找不包含这个词的演讲。这个查询应该能找到15篇符合条件的演讲。以下是前四行：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Notice that the highlighted words in the `ts_headline` column include `transportation`
    and `transport`. Again, `to_tsquery()` converted `transportation` to the lexeme
    `transport` for the search term. This database behavior is extremely useful in
    helping to find relevant related words.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ts_headline`列中突出显示的单词包括`transportation`和`transport`。同样，`to_tsquery()`将`transportation`转换为词形`transport`作为搜索条件。这种数据库行为对于帮助查找相关的相关词非常有用。
- en: Searching for Adjacent Words
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找相邻单词
- en: Finally, we’ll use the distance (`<->`) operator, which consists of a hyphen
    between the less-than and greater-than signs, to find adjacent words. Alternatively,
    you can place a number between the signs to find terms that many words apart.
    For example, [Listing 14-24](#listing14-24) searches for any speeches that include
    the word *military* immediately followed by *defense*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用距离（`<->`）运算符，它由小于号和大于号之间的连字符组成，用来查找相邻的单词。或者，你可以在符号之间放置一个数字，来查找相隔多个单词的术语。例如，[列表
    14-24](#listing14-24)搜索任何包含*military*紧接着*defense*的演讲。
- en: '[PRE48]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Listing 14-24: Finding speeches where *defense* follows *military*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-24：查找*defense*紧跟在*military*后面的演讲
- en: 'This query should find five speeches, and because `to_tsquery()` converts the
    search terms to lexemes, the words identified in the speeches should include plurals,
    such as *military defenses*. The following shows the speeches that have the adjacent
    terms:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询应该能找到五篇演讲，因为`to_tsquery()`将搜索条件转换为词形，演讲中识别的单词应该包括复数形式，例如*military defenses*。以下显示了包含相邻术语的演讲：
- en: '[PRE49]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If you changed the query terms to `military <2> defense`, the database would
    return matches where the terms are exactly two words apart, as in the phrase “our
    military and defense commitments.”
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将查询条件更改为`military <2> defense`，数据库将返回两个词之间正好相隔两个单词的匹配项，例如短语“我们的军事和防务承诺”。
- en: Ranking Query Matches by Relevance
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按相关性排名查询结果
- en: You can also rank search results by relevance using two of PostgreSQL’s full-text
    search functions. These functions are helpful when you’re trying to understand
    which piece of text, or speech in this case, is most relevant to your particular
    search terms.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用PostgreSQL的两种全文搜索功能来按相关性对搜索结果进行排名。当你想了解哪段文字或演讲与你的搜索条件最相关时，这些功能会非常有帮助。
- en: One function, `ts_rank()`, generates a rank value (returned as a variable-precision
    `real` data type) based on how often the lexemes you’re searching for appear in
    the text. The other function, `ts_rank_cd()`, considers how close the lexemes
    searched are to each other. Both functions can take optional arguments to consider
    document length and other factors. The rank value they generate is an arbitrary
    decimal that’s useful for sorting but doesn’t have any inherent meaning. For example,
    a value of `0.375` generated during one query isn’t directly comparable to the
    same value generated during a different query.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数`ts_rank()`根据你所搜索的词汇在文本中出现的频率生成一个排名值（以可变精度的`real`数据类型返回）。另一个函数`ts_rank_cd()`则考虑了搜索词汇彼此之间的接近度。两个函数都可以接受可选参数来考虑文档长度和其他因素。它们生成的排名值是一个任意的小数，虽然有助于排序，但没有内在的意义。例如，在一次查询中生成的`0.375`的值，不能直接与在另一查询中生成的相同值进行比较。
- en: As an example, [Listing 14-25](#listing14-25) uses `ts_rank()` to rank speeches
    containing all the words *war*, *security*, *threat*, and *enemy*.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[示例14-25](#listing14-25)使用`ts_rank()`对包含所有词汇*战争*、*安全*、*威胁*和*敌人*的演讲进行排名。
- en: '[PRE50]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Listing 14-25: Scoring relevance with `ts_rank()`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 示例14-25：使用`ts_rank()`进行相关性评分
- en: 'In this query, the `ts_rank()` function 1 takes two arguments: the `search_speech_text`
    column and the output of a `to_tsquery()` function containing the search terms.
    The output of the function receives the alias `score`. In the `WHERE` clause 2
    we filter the results to only those speeches that contain the search terms specified.
    Then we order the results in `score` in descending order and return just five
    of the highest-ranking speeches. The results should be as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在此查询中，`ts_rank()`函数1接收两个参数：`search_speech_text`列和一个包含搜索词的`to_tsquery()`函数的输出。该函数的输出被赋予别名`score`。在`WHERE`子句2中，我们筛选出仅包含指定搜索词的演讲。然后，我们按`score`的降序排列结果，并仅返回排名前五的演讲。结果应该如下所示：
- en: '[PRE51]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Bill Clinton’s 1997 State of the Union message contains the words *war*, *security*,
    *threat*, and *enemy* more often than the other speeches, as he discussed the
    Cold War and other topics. However, it also happens to be one of the longer speeches
    in the table (which you can determine by using `char_length()`, as you learned
    earlier in the chapter). The lengths of speeches influences these rankings because
    `ts_rank()` factors in the number of matching terms in a given text. Two speeches
    by George W. Bush, delivered in the years before and after the start of the Iraq
    War, rank next.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 比尔·克林顿1997年的国情咨文中，*战争*、*安全*、*威胁*和*敌人*这些词出现的频率比其他演讲更高，因为他讨论了冷战和其他话题。然而，这也是表中较长的演讲之一（你可以通过使用`char_length()`来确定这一点，如本章前面所述）。演讲的长度会影响这些排名，因为`ts_rank()`会考虑给定文本中匹配词汇的数量。乔治·W·布什的两场演讲，分别发生在伊拉克战争前后，排名紧随其后。
- en: It would be ideal to compare frequencies between speeches of identical lengths
    to get a more accurate ranking, but this isn’t always possible. However, we can
    factor in the length of each speech by adding a normalization code as a third
    parameter of the `ts_rank()` function, as shown in [Listing 14-26](#listing14-26).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们可以比较相同长度演讲中的词频，以获得更准确的排名，但这并不总是可行的。然而，我们可以通过将标准化代码作为`ts_rank()`函数的第三个参数来考虑每个演讲的长度，如[示例14-26](#listing14-26)所示。
- en: '[PRE52]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Listing 14-26: Normalizing `ts_rank()` by speech length'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 示例14-26：按演讲长度标准化`ts_rank()`
- en: Adding the optional code `2` 1 instructs the function to divide the `score`
    by the length of the data in the `search_speech_text` column. This quotient then
    represents a score normalized by the document length, giving an apples-to-apples
    comparison among the speeches. The PostgreSQL documentation at [https://www.postgresql.org/docs/current/textsearch-controls.html](https://www.postgresql.org/docs/current/textsearch-controls.html)
    lists all the options available for text search, including using the document
    length and dividing by the number of unique words.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 添加可选代码`2` 1指示该函数将`score`除以`search_speech_text`列中数据的长度。这个商值随后代表一个按文档长度标准化的分数，使得各个演讲之间可以进行公平比较。[PostgreSQL
    文档](https://www.postgresql.org/docs/current/textsearch-controls.html)列出了所有可用于文本搜索的选项，包括使用文档长度和除以唯一词汇的数量。
- en: 'After running the code in [Listing 14-26](#listing14-26), the rankings should
    change:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行[示例14-26](#listing14-26)中的代码后，排名应该发生变化：
- en: '[PRE53]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In contrast to the ranking results in [Listing 14-25](#listing14-25), George
    W. Bush’s 2004 speech now tops the rankings, and Truman’s 1946 message falls out
    of the top five. This might be a more meaningful ranking than the first sample
    output, because we normalized it by length. But three of the five top-ranked speeches
    are the same between the two sets, and you can be reasonably certain that each
    of these three is worthy of closer examination to understand more about presidential
    speeches that include wartime terminology.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 与[清单14-25](#listing14-25)中的排名结果相比，乔治·W·布什2004年的演讲现在位居榜首，而杜鲁门1946年的演讲则不再进入前五名。这可能是一个比第一个示例输出更有意义的排名，因为我们通过长度对其进行了标准化。但在两个排名结果中，五个排名最高的演讲中有三个是相同的，你可以合理地确信，这三篇演讲都值得更深入的研究，以便更好地理解包含战争术语的总统演讲。
- en: Wrapping Up
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Far from being boring, text offers abundant opportunities for data analysis.
    In this chapter, you’ve learned techniques for turning ordinary text into data
    you can extract, quantify, search, and rank. In your work or studies, keep an
    eye out for routine reports that have facts buried inside chunks of text. You
    can use regular expressions to dig them out, turn them into structured data, and
    analyze them to find trends. You can also use search functions to analyze the
    text.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 文本不仅不乏味，反而为数据分析提供了丰富的机会。在本章中，你已经学到了将普通文本转化为可以提取、量化、搜索和排序的数据的技术。在你的工作或学习中，要留意那些将事实埋藏在文本块中的日常报告。你可以使用正则表达式将它们挖掘出来，转化为结构化数据，并进行分析以发现趋势。你还可以使用搜索功能来分析文本。
- en: In the next chapter, you’ll learn how PostgreSQL can help you analyze geographic
    information.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习如何使用PostgreSQL来分析地理信息。
