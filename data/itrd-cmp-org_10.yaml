- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10'
- en: PROGRAMMING IN ASSEMBLY LANGUAGE**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**汇编语言编程**'
- en: '![Image](../images/pg213_Image_246.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg213_Image_246.jpg)'
- en: In previous chapters, you learned how computers can be programmed using `1`s
    and `0`s to represent operations and data. Those `1`s and `0`s are the *machine
    language*. Now, we’ll move on to programming at the machine level. Instead of
    using machine language, we’ll use *assembly language*, which uses a short mnemonic
    for each machine language instruction. We’ll use an *assembler* program to translate
    the assembly language into the machine language instructions that control the
    computer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了计算机如何使用`1`和`0`表示操作和数据。这些`1`和`0`就是*机器语言*。现在，我们将转向机器级编程。我们不再使用机器语言，而是使用*汇编语言*，它为每条机器语言指令提供一个简短的助记符。我们将使用*汇编器*程序将汇编语言翻译成控制计算机的机器语言指令。
- en: Creating a program in assembly language is similar to creating one in a higher-level
    compiled language such as C, C++, Java, or FORTRAN. I’ll use C as the programming
    model to explore the primary programming constructs and data structures that are
    common to essentially all higher-level programming languages. The compiler we’re
    using, `gcc`, allows us to look at the assembly language it generates. From there,
    I’ll show you how I would implement the programming constructs and data structures
    directly in assembly language.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 创建汇编语言程序类似于在高级编译语言中创建程序，如C、C++、Java或FORTRAN。我将使用C作为编程模型，探索所有高级编程语言中常见的主要编程构造和数据结构。我们使用的编译器`gcc`允许我们查看它生成的汇编语言。从这里开始，我将向你展示如何直接在汇编语言中实现编程构造和数据结构。
- en: We’ll start by looking at the steps the compiler takes to create an executable
    program from C source code. Next, I’ll discuss which of these steps apply to assembly
    language programming and walk you through creating a program directly in assembly
    language that will run in the C hosted environment. You’ll also learn about a
    `gdb` mode that’s useful for learning assembly language.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看编译器将C源代码转换为可执行程序的步骤。接下来，我将讨论这些步骤中哪些适用于汇编语言编程，并带你完成直接在汇编语言中创建一个可以在C托管环境中运行的程序的过程。你还将学习到一个对学习汇编语言很有用的`gdb`模式。
- en: While reading this chapter, you should also consult the man pages and `info`
    documentation resources available in Raspberry Pi OS for the programs discussed
    here. You’ll probably need to install some of them on your Raspberry Pi, as described
    in “The Programming Environment” on [page 4](ch01.xhtml#ch01lev1sec3).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章时，你还应该参考Raspberry Pi OS中与本文讨论的程序相关的man页面和`info`文档资源。你可能需要在你的Raspberry Pi上安装其中的一些程序，具体请参考《编程环境》中的[第4页](ch01.xhtml#ch01lev1sec3)。
- en: I’ll be using the GNU assembler program, `as`, quite a bit through the rest
    of the book. Some call this assembler `gas`, short for *GNU assembler*. I’ll explain
    what you need to know about using the `as` program, but I recommend getting a
    copy of the *Using as* manual so you can learn the details as we go. It’s available
    in the Software Development section at *[https://www.gnu.org/manual/manual.html](https://www.gnu.org/manual/manual.html)*,
    as part of the GNU Binutils collection.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我将经常使用GNU汇编程序`as`。有些人称这个汇编器为`gas`，是*GNU汇编器*的简称。我会解释你需要了解如何使用`as`程序，但我建议你获取一份*Using
    as*手册，以便在我们继续时学习详细信息。它可以在*https://www.gnu.org/manual/manual.html*的GNU Binutils集合中的软件开发部分找到。
- en: '**Starting in C**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从C开始**'
- en: 'The `gcc` compiler creates an executable program from one or more source files
    by performing several distinct steps. Each step results in an intermediate file
    that serves as the input to the next step. The description of each step here assumes
    a single C source file, *filename.c*:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcc`编译器通过执行几个不同的步骤，从一个或多个源文件创建可执行程序。每个步骤生成一个中间文件，作为下一个步骤的输入。这里对每个步骤的描述假设只有一个C源文件，*filename.c*：'
- en: '**Preprocessing**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**预处理**'
- en: Preprocessing is the first step. This step resolves *preprocessor directives*
    such as `#include` (file inclusion), `#define` (macro definition), and `#if` (conditional
    compilation) by invoking the program `cpp`. Each preprocessor directive begins
    with the `#` character, which may be pronounced or not—for example, you may hear
    the `#include` directive referred to as *include*, *pound-include*, *hash-include*,
    or *hashtag-include*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理是第一步。此步骤通过调用程序`cpp`来解析*预处理指令*，如`#include`（文件包含）、`#define`（宏定义）和`#if`（条件编译）。每个预处理指令都以`#`字符开头，可能会被发音或不发音——例如，你可能会听到`#include`指令被称为*include*、*pound-include*、*hash-include*或*hashtag-include*。
- en: 'The compilation process can be stopped at the end of the preprocessing phase
    using the `-E` option, which writes the resulting C source code to *standard output*.
    Standard output is the plaintext output from a command line program in Linux.
    It is usually connected to the terminal window. You can redirect the output to
    a file with the `>` operator, like so:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程可以在预处理阶段结束时使用`-E`选项停止，该选项会将结果 C 源代码写入*标准输出*。标准输出是来自 Linux 命令行程序的纯文本输出，通常连接到终端窗口。你可以使用`>`操作符将输出重定向到文件，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The *.i* file extension denotes a file that does not require preprocessing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*.i*文件扩展名表示一个不需要预处理的文件。'
- en: '**Compilation**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译**'
- en: Next, the compiler translates the source code that results from preprocessing
    into assembly language. The compilation process can be stopped at the end of the
    compilation phase with the `-S` option (an uppercase S), which writes the assembly
    language source code to *<filename>.s*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编译器将预处理后得到的源代码翻译成汇编语言。编译过程可以在编译阶段结束时使用`-S`选项（大写字母S）停止，该选项会将汇编语言源代码写入*<filename>.s*文件。
- en: '**Assembly**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**汇编**'
- en: After the compiler generates the assembly language that implements the C source
    code, the assembler program, `as`, translates the assembly language into machine
    code (instructions and data). The process can be stopped at the end of the assembly
    phase using the `-c` option, which writes the machine code to an *object file*
    named *<filename>.o*. In addition to the machine code, the object file includes
    metadata about the code used by the linker to resolve cross-references between
    different modules, determine where to locate the different parts of the program,
    and so forth. It also includes metadata about the module, for use by the debugger.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译器生成实现 C 源代码的汇编语言后，汇编程序`as`将汇编语言翻译成机器代码（指令和数据）。可以在汇编阶段结束时使用`-c`选项停止此过程，该选项会将机器代码写入名为*<filename>.o*的*目标文件*。除了机器代码外，目标文件还包括关于代码的元数据，链接器使用这些元数据来解析不同模块之间的交叉引用，确定如何定位程序的不同部分等。它还包括关于模块的元数据，供调试器使用。
- en: '**Linking**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**链接**'
- en: The `ld` program determines where each function and data item will be located
    in memory when the program is executed. It replaces the programmer’s labels, where
    each is referenced with the memory address of the label. If a called function
    is in an external library, this is noted where the function is called, and the
    address of the external library function is determined during program execution.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`ld`程序确定每个函数和数据项在程序执行时将位于内存中的位置。它将程序员的标签替换为该标签的内存地址。如果调用的函数在外部库中，则在调用该函数的位置会注明，并且外部库函数的地址会在程序执行时确定。'
- en: The compiler directs the `ld` program to add the computer code to the executable
    file that sets up the C hosted environment. This includes operations such as opening
    paths to standard output (the screen) and standard input (the keyboard) for use
    by the program.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器指示`ld`程序将计算机代码添加到设置 C 托管环境的可执行文件中。这包括打开路径到标准输出（屏幕）和标准输入（键盘）等操作，以供程序使用。
- en: The result of this linking is written to an executable file. The default name
    of the executable file is *a.out*, but you can specify another name with the `-o`
    option.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个链接的结果会写入一个可执行文件。可执行文件的默认名称是*a.out*，但你可以使用`-o`选项指定其他名称。
- en: If you don’t use any of the `gcc` options to stop the process at the end of
    one of these steps (`-E`, `-S`, `-c`), the compiler will perform all four steps
    and automatically delete the intermediate files, leaving only the executable program
    as the final result. You can direct `gcc` to keep all the intermediate files with
    the `-save-temps` option.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用任何 `gcc` 选项来在这些步骤的末尾停止进程（`-E`、`-S`、`-c`），编译器会执行所有四个步骤并自动删除中间文件，最终只留下可执行程序。如果你希望
    `gcc` 保留所有中间文件，可以使用 `-save-temps` 选项。
- en: The complement of being able to stop `gcc` along the way is that we can supply
    files that have effectively gone through the earlier steps, and `gcc` will incorporate
    those files into the remaining steps. For example, if we write a file in assembly
    language (*.s*), `gcc` will skip the preprocessing and compilation steps and perform
    only the assembly and linking steps for that file. If we supply only object files
    (*.o*), `gcc` will go directly to the linking step. An implicit benefit of this
    is that we can write programs in assembly language that call functions in the
    C standard library (which are already in object file format), and `gcc` will automatically
    link our assembly language with those library functions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在中途停止 `gcc` 的补充功能是，我们可以提供已经有效通过早期步骤的文件，`gcc` 会将这些文件融入到剩下的步骤中。例如，如果我们写了一个汇编语言文件（*.s*），`gcc`
    会跳过预处理和编译步骤，只对该文件执行汇编和链接步骤。如果我们只提供目标文件（*.o*），`gcc` 会直接进入链接步骤。这的一个隐性好处是，我们可以编写调用
    C 标准库函数的汇编程序（这些库函数已经是目标文件格式），并且 `gcc` 会自动将我们的汇编程序与这些库函数链接。
- en: Be sure to use the filename extensions specified in the GNU programming environment
    when naming a file. The default action of the compiler at each step depends upon
    the filename extension appropriate to that step. To see these naming conventions,
    enter info gcc into the command line, select **Invoking GCC**, and then select
    **Overall Options**. If you don’t use the specified filename extension, the compiler
    might not do what you want or might even overwrite a required file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名文件时，务必使用 GNU 编程环境中指定的文件扩展名。编译器在每个步骤的默认操作取决于该步骤所适用的文件扩展名。要查看这些命名约定，请在命令行输入
    `info gcc`，选择 **调用 GCC**，然后选择 **整体选项**。如果你没有使用指定的文件扩展名，编译器可能不会按你想要的方式操作，甚至可能会覆盖一个必需的文件。
- en: '***From C to Assembly Language***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从 C 到汇编语言***'
- en: Programs written in C are organized into functions. Each function has a name
    that is unique within the program. After the C hosted environment is set up, the
    `main` function is called, so our programs will start with a `main` function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 用 C 语言编写的程序是按函数组织的。每个函数在程序中都有一个唯一的名称。在 C 环境设置好后，会调用 `main` 函数，因此我们的程序将从 `main`
    函数开始。
- en: Let’s start by looking at the assembly language that `gcc` generates for the
    minimum C program in [Listing 10-1](ch10.xhtml#ch10list1).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 `gcc` 为清单 10-1 中的最小 C 程序生成的汇编语言代码，[清单 10-1](ch10.xhtml#ch10list1) 中可以找到。
- en: '*do_nothing.c*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*do_nothing.c*'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 10-1: The minimum C program*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1：最小的 C 程序*'
- en: This program does nothing except return 0 to the operating system. A program
    can return various numerical error codes; 0 indicates that the program did not
    detect any errors.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序除了向操作系统返回 0 外什么也不做。程序可以返回各种数值错误代码；0 表示程序没有检测到任何错误。
- en: 'Even though this program accomplishes very little, some instructions need to
    be executed just to return 0\. To see what takes place, we’ll first translate
    this program from C to assembly language with the following Linux command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个程序几乎不做任何事，但仍需要执行一些指令才能返回 0。为了看到发生了什么，我们将首先使用以下 Linux 命令将这个程序从 C 语言翻译成汇编语言：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**NOTE**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re not familiar with the GNU* make *program, it’s worth learning how
    to use it to build your programs. It may seem like overkill at this point, but
    it’s much easier to learn with simple programs. The manual is available in several
    formats at* [https://www.gnu.org/software/make/manual/](https://www.gnu.org/software/make/manual/),
    *and I have some comments about using it on my website at* [https://rgplantz.github.io](https://rgplantz.github.io).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你不熟悉 GNU* make *程序，值得学习如何使用它来构建程序。现在看起来可能有点过于复杂，但在简单的程序中学习要容易得多。手册可以在* [https://www.gnu.org/software/make/manual/](https://www.gnu.org/software/make/manual/)
    *获取，另外我在我的网站上也有一些使用它的评论，网址是* [https://rgplantz.github.io](https://rgplantz.github.io)。'
- en: Before showing the result of this command, I’ll explain the options I’ve used.
    The `-O0` (uppercase O and zero) option tells the compiler not to use any optimization.
    This is in keeping with the goal of this book, which is to show what’s taking
    place at the machine level; asking the compiler to optimize the code may obscure
    some important details.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示该命令的结果之前，我将解释我使用的选项。`-O0`（大写字母O和数字零）选项告诉编译器不要使用任何优化。这与本书的目标一致，目的是展示机器层面上发生的事情；要求编译器优化代码可能会掩盖一些重要的细节。
- en: You’ve already learned that the `-Wall` option asks the compiler to warn you
    about questionable constructions in your code. That’s not likely to be an issue
    in this simple program, but it’s a good habit to get into.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学过，`-Wall`选项会让编译器在代码中遇到可疑的结构时发出警告。对于这个简单的程序来说，这不太可能成为问题，但养成这个好习惯是很有帮助的。
- en: The `-S` option directs the compiler to stop after the compilation phase and
    write the assembly language resulting from the compilation to a file with the
    same name as the C source code file, but with the *.s* extension instead of *.c*.
    The previous compiler command generates the assembly language shown in [Listing
    10-2](ch10.xhtml#ch10list2), which is saved in the file *do_nothing.s*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`-S`选项指示编译器在编译阶段后停止，并将编译结果写入一个文件，该文件的名称与C源代码文件相同，但扩展名为*.s*，而不是*.c*。之前的编译器命令生成了[列表
    10-2](ch10.xhtml#ch10list2)中显示的汇编语言，并将其保存在文件*do_nothing.s*中。'
- en: '*do_nothing.s*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*do_nothing.s*'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 10-2: The minimum C program in assembly language generated by the
    compiler*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-2：编译器生成的最小C程序汇编语言*'
- en: The first thing to notice in [Listing 10-2](ch10.xhtml#ch10list2) is that assembly
    language is organized by lines. Only one assembly language statement is on each
    line, and none of the statements spans more than one line. This differs from the
    free-form nature of many high-level languages, where the line structure is irrelevant.
    In fact, good programmers use the ability to write program statements across multiple
    lines and indentation to emphasize the structure of their code. Good assembly
    language programmers use blank lines to help separate parts of an algorithm, and
    they comment almost every line.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 10-2](ch10.xhtml#ch10list2)中，首先需要注意的是汇编语言是按行组织的。每行只包含一个汇编语言语句，且没有语句跨越多行。这与许多高级语言的自由格式结构不同，后者行结构无关紧要。实际上，好的程序员会利用编写多行语句和缩进来强调代码结构。优秀的汇编语言程序员使用空行来帮助分隔算法的不同部分，并且几乎在每行代码上都加上注释。
- en: 'The lines are organized roughly into columns. They probably do not make much
    sense to you at this point because they’re written in assembly language, but if
    you look carefully, each of the lines is organized into four possible fields:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行大致上被组织成列。此时它们可能对你没有多大意义，因为它们是用汇编语言编写的，但如果你仔细观察，每一行都会组织成四个可能的字段：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Not all the lines will have entries in all the fields. The assembler requires
    at least one space or tab character to separate the fields. When writing assembly
    language, your program will be much easier to read if you use the TAB key to move
    from one field to the next so the columns line up.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是所有的行都会在所有字段中都有条目。汇编程序要求至少有一个空格或制表符字符来分隔字段。当编写汇编语言时，如果你使用TAB键从一个字段跳到下一个字段，使列对齐，那么你的程序会更容易阅读。
- en: 'Let’s look at each field in a bit more detail:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下每个字段：
- en: label This field allows us to give a symbolic name to a memory address in the
    program. Other parts of the program can then refer to the memory address by name.
    A label consists of an identifier immediately followed by the `:` character. I’ll
    cover the rules for creating an identifier soon. Only the lines that need to be
    referred to are labeled.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 标签 该字段允许我们为程序中的内存地址指定一个符号名称。程序的其他部分可以通过名称引用该内存地址。标签由一个标识符组成，后面紧跟一个`:`字符。稍后我会讲解创建标识符的规则。只有需要引用的行才会被标记。
- en: operation This field contains either an *instruction operation code (opcode)*
    or an *assembler directive* (sometimes called a *pseudo-op*). The assembler translates
    an opcode and its operands into machine instructions, which are copied into memory
    when the program is to be executed. Assembler directives are instructions to the
    assembler program that guide the assembly process.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 操作 该字段包含一个*指令操作码（opcode）*或一个*汇编指令*（有时称为*伪操作*）。汇编程序将操作码及其操作数转换为机器指令，当程序执行时，这些指令会被复制到内存中。汇编指令是给汇编程序的指令，用来指导汇编过程。
- en: operand(s) This field specifies the arguments to be used in the operation. The
    arguments can be explicit values, names of registers, or programmer-created names.
    There may be zero to several operands, depending on the operation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数 该字段指定用于操作的参数。参数可以是明确的值、寄存器的名称或程序员创建的名称。根据操作的不同，操作数的数量可以是零到多个。
- en: comment Everything on a line following two `/` characters (`//`) is ignored
    by the assembler, thus providing a way for the programmer to provide human-readable
    comments. Since assembly language is not as easy to read as higher-level languages,
    good programmers will place a comment on almost every line. Of course, the compiler
    has not commented the code in [Listing 10-2](ch10.xhtml#ch10list2) because it
    has no way of knowing the programmer’s intent.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注释 在`//`字符后面的行内容（`//`后面的部分）会被汇编器忽略，从而为程序员提供了写可读注释的方式。由于汇编语言不像高级语言那么容易阅读，因此优秀的程序员会在几乎每一行代码上加上注释。当然，编译器没有为[清单
    10-2](ch10.xhtml#ch10list2)中的代码添加注释，因为它无法知道程序员的意图。
- en: You probably noticed that most of the operators in [Listing 10-2](ch10.xhtml#ch10list2)
    begin with a `.` character. These are assembler directives. Each assembler directive
    begins with the `.` character, which may be pronounced or not—for example, you
    might hear `.text` referred to as *text* or *dot-text*. These are instructions
    to the assembler program itself, not computer instructions. The compiler generates
    some assembler directives that we won’t need for the assembly language we write
    in this book; we’ll take a quick look at those next, then look at the required
    directives.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，[清单 10-2](ch10.xhtml#ch10list2)中的大多数操作符都以`.`字符开头。这些是汇编指令。每个汇编指令都以`.`字符开头，这个字符可能会发音或不发音——例如，你可能听到`.text`被称为*text*或*dot-text*。这些是对汇编程序本身的指令，而不是计算机指令。编译器生成了一些我们在本书中编写的汇编语言中不需要的汇编指令；接下来我们将快速看一下这些指令，然后再看必需的指令。
- en: '***Unused Assembler Directives***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***未使用的汇编指令***'
- en: 'The assembler directives in [Listing 10-2](ch10.xhtml#ch10list2) that begin
    with `.cfi` tell the assembler to generate information that can be used for debugging
    and certain error situations. The labels beginning with `.LF` mark places in the
    code used to generate this information. A discussion of this is beyond the scope
    of this book, but their appearance in the listing can be confusing, so we’ll tell
    the compiler not to include them in the assembly language file using the `-fno-asynchronous-unwind-tables`
    and `-fno-unwind-tables` options:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-2](ch10.xhtml#ch10list2)中以`.cfi`开头的汇编指令告诉汇编器生成可用于调试和某些错误情况的信息。以`.LF`开头的标签标记了在代码中用于生成这些信息的位置。对此的讨论超出了本书的范围，但它们出现在清单中可能会造成混淆，因此我们将告诉编译器不要在汇编语言文件中包含它们，方法是使用`-fno-asynchronous-unwind-tables`和`-fno-unwind-tables`选项：'
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This produces the file *do_nothing.s*, shown in [Listing 10-3](ch10.xhtml#ch10list3).
    I’ve used boldface to show the directives that we will use and left the ones we
    won’t use unbolded. The compiler did not comment the assembly language code in
    this listing, but I’ve added my own comment using `///` to help you see the relationship
    with the C source code. I’ll add my own comments to many of the compiler-generated
    assembly language listings I show in this book.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成文件*do_nothing.s*，如[清单 10-3](ch10.xhtml#ch10list3)所示。我用了粗体来显示我们将使用的指令，未使用的指令则未加粗。编译器没有对这个清单中的汇编语言代码添加注释，但我使用`///`添加了我自己的注释，帮助你看到与C源代码的关系。我将在本书中展示的许多编译器生成的汇编语言清单中加入自己的注释。
- en: '*do_nothing.s*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*do_nothing.s*'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 10-3: The minimum C program in assembly language generated by the
    compiler, without* .cfi *directives*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-3：编译器生成的没有.cfi指令的最小C程序汇编语言*'
- en: 'We’ve stripped away the `.cfi` directives, but we still have several assembler
    directives that we won’t need when we write our own functions in assembly language.
    These include:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经去除了`.cfi`指令，但在编写自己的汇编语言函数时，仍然有一些汇编指令是我们不需要的。这些包括：
- en: .file This is used by `gcc` to specify the name of the C source file that this
    assembly language came from. This directive isn’t used when writing directly in
    assembly language.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: .file `gcc`用它来指定这个汇编语言来自哪个C源文件。当直接编写汇编语言时，这个指令不会被使用。
- en: .size This computes the size of the machine code, in bytes, that results from
    assembling this file. The `.` symbol refers to the current address in the code,
    so the arithmetic expression `.-main` subtracts the address of `main` from the
    current address. The `.size` directive associates this value with the `main` label
    as part of the metadata in the object file, thus giving the number of bytes in
    this function. This can be useful information in systems with limited memory,
    but it’s of no concern in our programs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: .size 此指令计算由汇编该文件所生成的机器代码的大小（以字节为单位）。` .` 符号表示代码中的当前地址，因此算术表达式 `.-main` 从当前地址减去
    `main` 的地址。`.size` 指令将此值与 `main` 标签相关联，作为目标文件中的元数据的一部分，从而给出该函数的字节数。这对于内存有限的系统可能是有用的信息，但在我们的程序中并不关心。
- en: .ident This provides information in the object file about the compiler that
    was used. This might be useful in large projects that have evolved over several
    years, but we won’t need it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: .ident 该指令提供有关所使用的编译器的信息，这些信息会包含在目标文件中。这在经历多年的发展过程中的大型项目中可能会有用，但我们不需要它。
- en: .section This provides guidance to the linker about how the stack should be
    treated for this function. We won’t include it and will just accept the default
    settings of the linker.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: .section 该指令为链接器提供关于如何处理该函数栈的信息。我们不会包含它，而是接受链接器的默认设置。
- en: Next, we’ll look at the directives that will be required when we write in assembly
    language.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看编写汇编语言时需要的指令。
- en: '***Required Assembler Directives***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***必需的汇编指令***'
- en: The required assembler directives are shown in boldface in [Listing 10-3](ch10.xhtml#ch10list3).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 必需的汇编指令在 [清单 10-3](ch10.xhtml#ch10list3) 中以粗体显示。
- en: There are several variations of the ARM instruction set architecture, and it
    continues to evolve. The `.arch` assembler directive tells the assembler which
    ARM architecture we’re using. It causes the assembler to warn us if we use an
    instruction that is not available in our specific architecture. The `.arch` directive
    is arguably not required for the simple programs we’re writing in this book, but
    we’ll use it to be on the safe side.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 指令集架构有多个变种，并且它还在不断发展。`.arch` 汇编指令告诉汇编器我们正在使用哪种 ARM 架构。如果我们使用了在特定架构中不可用的指令，它会提醒我们。对于本书中编写的简单程序来说，`.arch`
    指令可以说并非必须，但我们将使用它以确保安全。
- en: The `.text` assembler directive tells the assembler to place whatever follows
    in the text section. What does *text section* mean? In Linux, the object files
    produced by the assembler are in the *Executable and Linkable Format (ELF)*. The
    ELF standard specifies many types of sections, each specifying the type of information
    stored in it. We use assembler directives to tell the assembler in which section
    to place the code. The text section is where the program’s executable instructions
    go.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`.text` 汇编指令告诉汇编器将后续内容放置在文本区。*文本区*是什么意思？在 Linux 中，汇编器生成的目标文件采用 *可执行与可链接格式（ELF）*。ELF
    标准规定了许多类型的段，每个段指定了存储在其中的信息类型。我们使用汇编指令告诉汇编器将代码放置在哪个段中。文本段是存放程序可执行指令的地方。'
- en: 'The Linux operating system also divides memory into *segments* for specific
    purposes when a program is loaded from the disk. The linker gathers together all
    the sections that belong in each segment and outputs an executable ELF file that’s
    organized by segment to make it easier for the operating system to load the program
    into memory. The four general types of segments are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 操作系统在将程序从磁盘加载时，还将内存分为多个*段*以供特定用途。链接器将属于每个段的所有部分汇总在一起，输出一个按段组织的可执行 ELF
    文件，这样可以更容易地让操作系统将程序加载到内存中。四种常见的段类型如下：
- en: '**Text (also called code)** The *text segment* is where program instructions
    and constant data are stored. The operating system prevents a program from changing
    anything stored in the text segment, making it read-only.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本（也叫代码）** *文本段*是存放程序指令和常量数据的地方。操作系统防止程序修改存储在文本段中的内容，使其变为只读。'
- en: '**Data** Global variables and static local variables are stored in the *data
    segment*. Global variables can be accessed by any of the functions in a program.
    A static local variable can be accessed only by the function it’s defined in,
    but its value remains the same between calls to its function. Programs can both
    read from and write to variables in the data segment. These variables remain in
    place for the duration of the program.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据** 全局变量和静态局部变量存储在*数据段*中。全局变量可以被程序中的任何函数访问。静态局部变量只能被其所在的函数访问，但其值在多次调用该函数之间保持不变。程序可以同时读取和写入数据段中的变量。这些变量在程序运行期间保持不变。'
- en: '**Stack** Automatic local variables and the information that links functions
    are stored on the *call stack*. Automatic local variables are created when a function
    is called and deleted when the function returns to its calling function. A program
    can both read from and write to memory on the stack; it’s allocated and deallocated
    dynamically as the program executes.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆栈** 自动局部变量和链接函数的信息存储在*调用堆栈*中。自动局部变量在调用函数时创建，在函数返回调用函数时删除。程序可以同时读取和写入堆栈上的内存；它在程序执行过程中动态分配和释放。'
- en: '**Heap** The *heap* is a pool of memory that’s available for a program to use
    when running. A C program calls the `malloc` function (C++ programs call `new`)
    to get a chunk of memory from the heap. Programs can both read from and write
    to heap memory; it’s used to store data and is explicitly deallocated by calling
    `free` (`delete` in C++) in the program.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆** *堆*是一个程序运行时可以使用的内存池。C 程序通过调用 `malloc` 函数（C++ 程序调用 `new`）从堆中获取一块内存。程序可以同时读取和写入堆内存；它用于存储数据，并通过在程序中调用
    `free`（在 C++ 中是 `delete`）显式释放。'
- en: '**NOTE**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This is a simplistic overview of ELF sections and segments. For more details,
    read the man page for ELF and sources such as “ELF-64 Object File Format,” which
    you can download at* [https://uclibc.org/docs/elf-64-gen.pdf](https://uclibc.org/docs/elf-64-gen.pdf),
    *and John R. Levine’s* Linkers & Loaders *(Morgan Kaufmann, 1999). The* readelf
    *program is also useful for learning about ELF files.*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是 ELF 节和段的简化概述。更多细节，请阅读 ELF 的 man 页面以及像《ELF-64 Object File Format》这样的资源，你可以在*
    [https://uclibc.org/docs/elf-64-gen.pdf](https://uclibc.org/docs/elf-64-gen.pdf)
    *下载，* 以及 John R. Levine 的《Linkers & Loaders》（Morgan Kaufmann，1999）。* readelf *程序也对于了解
    ELF 文件非常有用。*'
- en: The `.align` directive is used to align the code following it on an address
    boundary. The argument used in [Listing 10-3](ch10.xhtml#ch10list3), `2`, has
    different meanings depending on the platform you’re using. On the ARM platform,
    it specifies the number of low-order bits that should be `0` in the program counter.
    If the bits are not `0`, the assembler increments the address until they are.
    Thus, the code that follows this `.align 2` directive will start at a full word
    address.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`.align` 指令用于将其后面的代码对齐到一个地址边界。在[清单 10-3](ch10.xhtml#ch10list3)中使用的参数 `2`，根据你使用的平台有不同的含义。在
    ARM 平台上，它指定程序计数器中应为 `0` 的低位数。如果这些位不是 `0`，汇编器将增加地址，直到它们为 `0`。因此，跟随 `.align 2` 指令的代码将从一个完整字对齐的地址开始。'
- en: The `.global` directive has one argument, the identifier `main`. The `.global`
    directive makes the name globally known, so functions that are defined in other
    files can refer to this name. The code that sets up the C hosted environment was
    written to call the function named `main`, so the name must be global in scope.
    All C/C++ programs start with a `main` function. In this book, I’ll also start
    the assembly language programs with a `main` function and execute them within
    the C hosted environment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`.global` 指令有一个参数，即标识符 `main`。`.global` 指令使得该名称在全局范围内可见，这样在其他文件中定义的函数就可以引用该名称。设置
    C 托管环境的代码是为了调用名为 `main` 的函数，因此该名称必须是全局作用域。在所有 C/C++ 程序中，程序都从 `main` 函数开始。在本书中，我也将从
    `main` 函数开始汇编语言程序，并在 C 托管环境中执行它们。'
- en: You can write stand-alone assembly language programs that don’t depend on the
    C hosted environment, in which case you can create your own name for the first
    function in the program. You need to stop the compilation process at the end of
    the assembly step with the `-c` option. You then link the object (*.o*) files
    using the `ld` command by itself, not as part of `gcc`. I’ll describe this in
    more detail in [Chapter 21](ch21.xhtml).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写不依赖于 C 托管环境的独立汇编语言程序，在这种情况下，你可以为程序中的第一个函数创建自己的名称。你需要在汇编步骤结束时使用 `-c` 选项停止编译过程。然后，你可以单独使用
    `ld` 命令链接目标 (*.o*) 文件，而不是作为 `gcc` 的一部分。我将在[第21章](ch21.xhtml)中详细描述这一点。
- en: 'The `.type` directive has two arguments: `main` and `@function`. This causes
    the identifier `main` to be recorded in the object file as the name of a function.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`.type` 指令有两个参数：`main` 和 `@function`。这使得标识符 `main` 被记录在目标文件中，作为函数的名称。'
- en: These last three directives are not translated into actual machine instructions.
    Rather, they’re used to describe the characteristics of the statements that follow.
    In the next chapter, we’ll start seeing assembler directives that store constant
    data in memory for the program to use.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后三个指令并没有被翻译成实际的机器指令。相反，它们用于描述随后的语句的特性。在下一章中，我们将开始看到汇编指令，它们将常量数据存储到内存中供程序使用。
- en: Now that you’ve seen how the compiler translates C code into assembly language,
    let’s look at how to write a program directly in assembly language. In the Introduction,
    I said you should avoid writing programs in assembly language. But the goal of
    this book is to help you learn how computers work at the machine level. Writing
    programs directly in assembly language is a better learning technique than just
    reading what the compiler does.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到编译器是如何将 C 代码翻译成汇编语言的，接下来我们来看看如何直接用汇编语言编写程序。在导言中，我曾说过你应该避免用汇编语言编写程序。但本书的目标是帮助你了解计算机在机器级别的工作原理。直接用汇编语言编写程序比仅仅阅读编译器的工作要更好地帮助学习。
- en: '**Starting in Assembly Language**'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从汇编语言开始**'
- en: '[Listing 10-4](ch10.xhtml#ch10list4) was written in assembly language by a
    programmer (me), rather than by a compiler. Naturally, I’ve added comments to
    explain what my code accomplishes.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-4](ch10.xhtml#ch10list4)是由一位程序员（我）用汇编语言编写的，而不是由编译器编写的。自然，我添加了注释来解释我的代码完成了什么。'
- en: '*do_nothing.s*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*do_nothing.s*'
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 10-4: The minimum C-style program written in assembly language*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-4：用汇编语言编写的最简化 C 风格程序*'
- en: The first line begins with two slashes, `//`. Everything after those two characters,
    up to the end of the line, is a comment and does not generate any action by the
    assembler. Comments can be started with two slashes at any place on a line. As
    in a high-level language, they are intended solely for human readers and have
    no effect on the program.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行以两个斜杠 `//` 开始。紧随这两个字符之后的所有内容，直到行尾，都是注释，不会引发汇编程序的任何操作。注释可以在一行的任何地方以两个斜杠开始。与高级语言一样，它们仅供人类读者参考，对程序没有任何影响。
- en: This comment line is followed by a blank line, also causing no action by the
    assembler, but very helpful for human readability.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行注释后面跟着一个空行，也不会引发汇编程序的任何操作，但对于人类可读性非常有帮助。
- en: A word about program comments here. Beginners often comment on what the programming
    statement does, not its purpose relative to solving the problem. Your comments
    should describe what *you* are doing, not what the computer is doing. For example,
    a comment like
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关于程序注释的一点说明。初学者常常注释编程语句做了什么，而不是它相对于解决问题的目的。你的注释应该描述你*做了什么*，而不是计算机做了什么。例如，像这样的注释
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: in C is not very useful. But a comment like
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中并不是很有用。但像这样的注释
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: could be very helpful.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能非常有用。
- en: After the five assembler directives that we’re using in our assembly language
    programs (described in the previous section), we see the label `main` on the first
    memory address in this function ❶. It’s common to place a label on its own line,
    in which case it applies to the address of the next assembly language statement
    that takes up memory ❷. This allows you to create longer, more meaningful labels
    while maintaining the column organization of your code, to improve readability.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在汇编语言程序中使用的五个汇编指令（在前一节中已描述）之后，我们看到了标签 `main`，它位于此函数的第一个内存地址❶。通常将标签放在单独的一行，这样它适用于占用内存的下一个汇编语言语句❷。这种做法可以让你创建更长、更有意义的标签，同时保持代码的列组织，以提高可读性。
- en: '***Symbolic Names in Assembly Language***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***汇编语言中的符号名称***'
- en: Since this is the top-level function in this program, the label `main` is required,
    but we’ll soon be writing programs that require us to create our own names. The
    rules for creating a symbolic name are similar to those for C/C++. Each name starts
    with either a letter or the character `.` or `_` followed by a string of letters,
    numerals, and/or `$` and `_` characters. The first character must not be a numeral,
    except for local labels, as described shortly. A name may be any length, and all
    characters are significant. Although the letter case of keywords (operators, register
    names, directives) is not significant, it is significant for labels. For example,
    `my_label` and `My_label` are different. Compiler-generated labels begin with
    the `.` character, and many system-related names begin with the `_` character;
    it’s a good idea to avoid beginning your own labels with these characters so you
    don’t inadvertently create one that’s already being used by the system.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是程序中的顶级函数，因此需要使用标签`main`，但我们很快就会编写需要创建自己名称的程序。创建符号名称的规则与C/C++类似。每个名称必须以字母或字符`.`或`_`开头，后面跟随字母、数字和/或`$`和`_`字符。第一个字符不能是数字，除了本地标签，稍后会描述。一个名称的长度没有限制，所有字符都具有意义。虽然关键字（操作符、寄存器名称、指令）的字母大小写不重要，但标签的大小写是有区别的。例如，`my_label`和`My_label`是不同的。编译器生成的标签以`.`字符开头，许多与系统相关的名称以`_`字符开头；最好避免以这些字符开头，以免无意中创建与系统中已有标签重复的标签。
- en: Our assembler also allows us to use an unsigned integer, N, to create a *local
    label*. Your assembly language code can refer to these labels as N`b` for the
    most recently used (N *backward*) and N`f` for the next used (N *forward*). This
    means you can have more than one local label with the same number. While it might
    seem to simplify your code writing, using local labels is usually not a good programming
    technique because the names don’t show the purpose of the labels.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的汇编器还允许我们使用无符号整数N来创建*本地标签*。你的汇编语言代码可以将这些标签作为N`b`（最近使用的N *向后*）和N`f`（下一个使用的N
    *向前*）来引用。这意味着你可以有多个本地标签使用相同的数字。虽然看起来这会简化你的代码编写，但使用本地标签通常不是一种好的编程技巧，因为标签的名称没有显示其目的。
- en: '***Basic Format of Assembly Language Instructions***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***汇编语言指令的基本格式***'
- en: 'ARM instructions fall into three categories: load and store, data processing,
    and program flow control. We’ll start by looking at the general format of the
    assembly language instruction. Rather than list all the A64 instructions, I will
    introduce a few at a time—the ones that will be needed to illustrate the programming
    concept at hand. I will also give only the commonly used variants of those instructions.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ARM指令分为三类：加载与存储、数据处理和程序流控制。我们将首先查看汇编语言指令的一般格式。我不会列出所有A64指令，而是一次介绍几个—那些能说明当前编程概念的指令。我还将只提供这些指令的常用变体。
- en: For a detailed description of the instructions and all their variants, download
    a copy of the *Arm Architecture Reference Manual for A-Profile Architecture* from
    *[https://developer.arm.com/documentation/ddi0487/latest](https://developer.arm.com/documentation/ddi0487/latest)*.
    This manual can be a little difficult to read, but going back and forth between
    my descriptions of the instructions in this book and the descriptions in the manual
    should help you learn how to read the manual.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解指令及其所有变体，可以从*【https://developer.arm.com/documentation/ddi0487/latest](https://developer.arm.com/documentation/ddi0487/latest)*下载*Arm架构参考手册（A-Profile架构）*。这本手册可能有些难读，但通过在本书中对指令的描述与手册中的描述之间来回查阅，应该能帮助你学会如何阅读这本手册。
- en: Assembly language provides a set of mnemonics that correspond directly to the
    machine language instructions. A *mnemonic* is a short, English-like group of
    characters that suggests the action of the instruction. Even if you’ve never seen
    assembly language before, the `mov w0, wzr` instruction in [Listing 10-4](ch10.xhtml#ch10list4)
    ❷ probably makes much more sense to you than the machine code it represents, `0x2a1f03e0`.
    You can probably figure out that it moves the contents of the 32-bit zero register
    `wzr` to the `w0` register. You’ll see what that means in the next few paragraphs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言提供了一组助记符，这些助记符与机器语言指令直接对应。*助记符*是一个简短、类似英语的字符组合，用来表示指令的操作。即使你之前从未接触过汇编语言，[清单10-4](ch10.xhtml#ch10list4)
    ❷中的`mov w0, wzr`指令可能比它代表的机器码`0x2a1f03e0`更容易理解。你大概可以推断出它是将32位零寄存器`wzr`的内容移动到`w0`寄存器中。接下来的几段内容将解释这是什么意思。
- en: Strictly speaking, the mnemonics are completely arbitrary, as long as you have
    an assembler program that will translate them into the desired machine instructions.
    However, most assembler programs follow the mnemonics used in the manuals provided
    by CPU vendors.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，助记符是完全任意的，只要你有一个汇编程序能将它们转换为期望的机器指令。然而，大多数汇编程序遵循CPU厂商提供的手册中使用的助记符。
- en: ARM uses a *load and store architecture*, which means data items must be loaded
    into registers or be part of the instruction itself before they can be used in
    an arithmetic or logic operation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 使用*加载与存储架构*，这意味着数据项必须先加载到寄存器中，或者是指令的一部分，才能在算术或逻辑操作中使用。
- en: 'The general format of a load or store instruction is:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 加载或存储指令的通用格式是：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The memory_address is either a label on a memory address or the name of a register
    that contains the address. Load instructions copy the data item from the memory_address
    to the register. Store instructions copy the data item from the register to the
    memory_address. In most cases, you will be dealing with only one data item for
    each load or store instruction, but the A64 architecture includes load and store
    instructions that allow you to work with two data items in separate registers
    with one instruction. You’ll see how this works in [Chapter 11](ch11.xhtml).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: memory_address 是内存地址的标签，或者是包含地址的寄存器的名称。加载指令将数据项从 memory_address 复制到寄存器。存储指令将数据项从寄存器复制到
    memory_address。在大多数情况下，你将仅处理每个加载或存储指令的一个数据项，但A64架构包括允许你在一条指令中处理两个数据项的加载与存储指令，你将在[第11章](ch11.xhtml)中看到它是如何工作的。
- en: 'Data processing instructions—arithmetic and logic operations—have the general
    format:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 数据处理指令——算术和逻辑操作——具有以下通用格式：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first operand is where the result of the operation is placed. Some instructions
    use two registers for the results. There can be from one to three source(s), which
    are registers or an *immediate value*. An immediate value is an explicit constant.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个操作数是操作结果存放的地方。有些指令使用两个寄存器存放结果。源操作数可以有一个到三个，可以是寄存器或*立即数值*。立即数值是一个明确的常量。
- en: Instructions that control program flow have the general format
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 控制程序流程的指令具有以下通用格式：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'or:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The memory_address is either a label on a memory address or the name of a register
    that contains the address. The data must be in a register or an immediate value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: memory_address 是内存地址的标签，或者是包含地址的寄存器的名称。数据必须存储在寄存器中或作为立即数值。
- en: '***Symbols Used for Instruction Descriptions***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***指令描述中使用的符号***'
- en: 'Here is a list of symbols I’ll use for describing instructions in this book,
    which are a little different from those used in the Arm manual:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我将在本书中描述指令时使用的符号列表，这些符号与Arm手册中使用的符号略有不同：
- en: wd A 32-bit destination register for the result of an operation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: wd 用于操作结果的32位目标寄存器。
- en: xd A 64-bit destination register for the result of an operation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: xd 一个64位目标寄存器，用于存放操作结果。
- en: ws**,** wn A 32-bit source register for an operation. If there’s more than one
    source register, they are numbered.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ws**,** wn 用于操作的32位源寄存器。如果有多个源寄存器，它们将按编号排列。
- en: xs**,** xn A 64-bit source register for an operation. If there’s more than one
    source register, they are numbered.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: xs**,** xn 用于操作的64位源寄存器。如果有多个源寄存器，它们将按编号排列。
- en: xb**,** xn A 64-bit register that holds a base address.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: xb**,** xn 保存基地址的64位寄存器。
- en: offset A constant number that is added to a base address.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: offset 加到基地址上的常量数值。
- en: imm A constant number whose size depends on the instruction.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: imm 一个常量数值，其大小取决于指令。
- en: amnt The number of bits to shift a source operand.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: amnt 用于移位源操作数的位数。
- en: addr An address, typically a label.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: addr 一个地址，通常是标签。
- en: cond A logical combination of the bits in the `nzcv` register.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: cond `nzcv`寄存器中位的逻辑组合。
- en: xtnd Specifies a wider version of an operand to use in an operation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: xtnd 指定在操作中使用的操作数的扩展版本。
- en: '{} Indicates one or more operands that are optional.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '{} 表示一个或多个操作数是可选的。'
- en: '| Indicates that either the operand on the left or the operand on the right
    can be used.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '| 表示可以使用左侧或右侧的操作数。'
- en: The registers can be any of the 31 general-purpose registers described in [Chapter
    9](ch09.xhtml). Most instructions also allow us to use the `wzr`, `xzr`, `wsp`,
    and `sp` registers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器可以是[第9章](ch09.xhtml)中描述的31个通用寄存器中的任何一个。大多数指令也允许我们使用`wzr`、`xzr`、`wsp`和`sp`寄存器。
- en: '***First Instructions***'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***第一类指令***'
- en: Again, I won’t describe all the instructions, nor will I describe all the variants
    of the instructions that I do describe. My aim is to equip you with the information
    you need to understand the programming concepts I introduce in this book and to
    be comfortable using other sources as needed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我不会描述所有的指令，也不会描述所有我所描述的指令的变体。我的目的是为你提供理解本书中介绍的编程概念所需的信息，并让你能够在需要时舒适地使用其他资源。
- en: 'Let’s start with the most commonly used assembly language instruction, `mov`.
    Some of the variations of this instruction follow; you can find more in the Arm
    manual:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最常用的汇编语言指令 `mov` 开始。以下是该指令的一些变体；更多内容可以在 Arm 手册中找到：
- en: mov**—Move register**
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: mov**—移动寄存器**
- en: '`mov w`d, `w`s `|wzr` copies the 32-bit value in `w`s or `wzr` to `w`d and
    zeros bits 63 to 32 of `x`d.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov w`d, `w`s `|wzr` 将 `w`s 或 `wzr` 中的 32 位值复制到 `w`d，并将 `x`d 的第 63 到 32 位置为
    0。'
- en: '`mov x`d, `x`s `|xzr` copies the 64-bit value in `x`s or `xzr` to `x`d.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov x`d, `x`s `|xzr` 将 `x`s 或 `xzr` 中的 64 位值复制到 `x`d。'
- en: mov**—Move to or from** sp
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: mov**—移动到或从** sp
- en: '`mov x`d `|sp, x`s `|sp` copies the 64-bit value in `x`s or `sp` to `x`d or
    `sp`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov x`d `|sp, x`s `|sp` 将 `x`s 或 `sp` 中的 64 位值复制到 `x`d 或 `sp`。'
- en: mov**—Move immediate**
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: mov**—移动立即数**
- en: '`mov w`d`,` imm copies the 16-bit value imm to the low-order part of `w`d and
    zeros bits 63 to 16 of `x`d.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov w`d, `imm` 将 16 位的值 imm 复制到 `w`d 的低位部分，并将 `x`d 的第 63 到 16 位置为 0。'
- en: '`mov x`d`,` imm copies the 16-bit value imm to the low-order part of `x`d and
    zeros bits 63 to 16 of `x`d.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov x`d, `imm` 将 16 位的值 imm 复制到 `x`d 的低位部分，并将 `x`d 的第 63 到 16 位置为 0。'
- en: movz**—Move immediate and zero**
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: movz**—移动立即数并清零**
- en: '`movz w`d`,` imm`{, lsl` amnt`}` copies the 16-bit value imm to `w`d, optionally
    shifted amnt bits to the left. The other 48 bits of `x`d are set to `0`. amnt
    can be `0` (the default) or `16`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`movz w`d, `imm`{, lsl` amnt`} 将 16 位的值 imm 复制到 `w`d，并可选择将该值左移 amnt 位。`x`d
    的其他 48 位被设置为 `0`。amnt 可以是 `0`（默认）或 `16`。'
- en: '`movz x`d`,` imm`{, lsl` amnt`}` copies the 16-bit value imm to `x`d, optionally
    shifted amnt bits to the left. The other 48 bits of `x`d are set to `0`. amnt
    can be `0` (the default), `16`, `32`, or `48`.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`movz x`d, `imm`{, lsl` amnt`} 将 16 位的值 imm 复制到 `x`d，并可选择将该值左移 amnt 位。`x`d
    的其他 48 位被设置为 `0`。amnt 可以是 `0`（默认）、`16`、`32` 或 `48`。'
- en: movk**—Move immediate and keep**
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: movk**—移动立即数并保留**
- en: '`movk w`d`,` imm`{, lsl` amnt`}` copies the 16-bit value imm to `w`d, optionally
    shifted amnt bits to the left. The other 48 bits of `x`d are not changed. amnt
    can be `0` (the default) or `16`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`movk w`d, `imm`{, lsl` amnt`} 将 16 位的值 imm 复制到 `w`d，并可选择将该值左移 amnt 位。`x`d
    的其他 48 位不变。amnt 可以是 `0`（默认）或 `16`。'
- en: '`movk x`d`,` imm`{, lsl` amnt`}` copies the 16-bit value imm to `x`d, optionally
    shifted amnt bits to the left. The other 48 bits of `x`d are not changed. amnt
    can be `0` (the default), `16`, `32`, or `48`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`movk x`d, `imm`{, lsl` amnt`} 将 16 位的值 imm 复制到 `x`d，并可选择将该值左移 amnt 位。`x`d
    的其他 48 位不变。amnt 可以是 `0`（默认）、`16`、`32` 或 `48`。'
- en: movn**—Move immediate and NOT**
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: movn**—移动立即数并取反**
- en: '`movn w`d`,` imm`{, lsl` amnt`}` copies the inverse of the 16-bit value imm
    to `w`d, optionally shifted amnt bits to the left. The other 48 bits of `x`d are
    set to `1`. amnt can be `0` (the default) or `16`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`movn w`d, `imm`{, lsl` amnt`} 将 16 位的值 imm 取反后复制到 `w`d，并可选择将该值左移 amnt 位。`x`d
    的其他 48 位被设置为 `1`。amnt 可以是 `0`（默认）或 `16`。'
- en: '`movn x`d`,` imm`{, lsl` amnt`}` copies the inverse of the 16-bit value in
    imm to `x`d, optionally shifted amnt bits to the left. The other 48 bits of `x`d
    are set to `1`. amnt can be `0` (the default), `16`, `32`, or `48`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`movn x`d, `imm`{, lsl` amnt`} 将 16 位的值 imm 取反后复制到 `x`d，并可选择将该值左移 amnt 位。`x`d
    的其他 48 位被设置为 `1`。amnt 可以是 `0`（默认）、`16`、`32` 或 `48`。'
- en: 'The only other instruction in [Listing 10-4](ch10.xhtml#ch10list4) is a `ret`,
    which causes a return to the calling function, assuming the return address is
    in `x30`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 10-4](ch10.xhtml#ch10list4)中，唯一的其他指令是 `ret`，它会导致返回到调用函数，假设返回地址在 `x30` 中：
- en: ret**—Return from a function**
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ret**—从函数返回**
- en: '`ret` moves the address in `x30` to the program counter, `pc`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`ret` 将 `x30` 中的地址移动到程序计数器 `pc`。'
- en: 'Now you see why I said in [Chapter 9](ch09.xhtml) that `x30` is commonly used
    as the link register: when a function is called, the return address is placed
    in `x30`. We’ll see how this works when we look at function calls in [Chapter
    11](ch11.xhtml).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你明白我为什么在[第 9 章](ch09.xhtml)中说 `x30` 通常用作链接寄存器了：当函数被调用时，返回地址会被放入 `x30`。我们将在[第
    11 章](ch11.xhtml)中看到函数调用时它是如何工作的。
- en: One of the most valuable uses of `gdb` is as a learning tool. It has a mode
    that is especially helpful in learning what each assembly language instruction
    does. I’ll show you how to do this in the next section, using the program in [Listing
    10-4](ch10.xhtml#ch10list4). This will also help you to become more familiar with
    using `gdb`, which is an important skill to have when debugging your programs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`gdb`最有价值的用途之一就是作为学习工具。它有一种模式，特别有助于学习每条汇编语言指令的作用。我将在下一节中向你展示如何使用[示例10-4](ch10.xhtml#ch10list4)中的程序来做到这一点。这也将帮助你更熟悉使用`gdb`，这是调试程序时必须掌握的一项重要技能。'
- en: '**Using gdb to Learn Assembly Language**'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用gdb学习汇编语言**'
- en: 'This would be a good place for you to run the program in [Listing 10-4](ch10.xhtml#ch10list4)
    so you can follow along with the discussion. You can assemble, link, and execute
    it with the following commands:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以运行[示例10-4](ch10.xhtml#ch10list4)中的程序，跟随讨论的步骤进行。你可以使用以下命令来汇编、链接和执行它：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `--gstabs` option (note the two dashes here) tells the assembler to include
    debugging information with the object file. The `gcc` program recognizes that
    the only input file is already an object file, so it goes directly to the linking
    stage. There is no need to tell `gcc` to include the debugging information, because
    the assembler already included it in the object file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`--gstabs`选项（注意这里有两个短横线）告诉汇编器在目标文件中包含调试信息。`gcc`程序识别到唯一的输入文件已经是一个目标文件，所以它直接进入链接阶段。无需告诉`gcc`包含调试信息，因为汇编器已经将其包含在目标文件中。'
- en: As you might guess from the name, you won’t see anything on the screen when
    you run this program. We’ll use `gdb` to walk through the execution of the program,
    which will allow us to see that this program actually does do something.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从名字中猜到的，运行这个程序时，屏幕上不会显示任何内容。我们将使用`gdb`来逐步执行程序，这样我们就可以看到这个程序实际上是做了什么的。
- en: The `gdb` debugger has a mode that’s useful for seeing the effects of each assembly
    language instruction as it’s executed. The *text user interface (TUI)* mode splits
    the terminal window into a display pane at the top and the usual command pane
    at the bottom. The display pane can be further split into two display panes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`gdb`调试器有一种模式，可以在执行每条汇编语言指令时查看其效果。*文本用户界面（TUI）*模式将终端窗口分为上部的显示窗格和下部的常规命令窗格。显示窗格还可以进一步分成两个显示窗格。'
- en: Each display pane can show either the source code (`src`), the registers (`regs`),
    or the disassembled machine code (`asm`). *Disassembly* is the process of translating
    the machine code (`1`s and `0`s) into the corresponding assembly language. The
    disassembly process does not know the programmer-defined names, so you will see
    only the numerical values that were generated by the assembly and linking processes.
    The `asm` display will probably be more useful when we look at the details of
    instructions in [Chapter 12](ch12.xhtml).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每个显示窗格可以显示源代码（`src`）、寄存器（`regs`）或反汇编的机器代码（`asm`）。*反汇编*是将机器代码（`1`和`0`）转换为相应的汇编语言的过程。反汇编过程无法识别程序员定义的名称，因此你只能看到由汇编和链接过程生成的数值。我们在[第12章](ch12.xhtml)中查看指令细节时，`asm`显示可能更有用。
- en: The documentation for using the TUI mode is in `info` for `gdb`. I’ll give a
    simple introduction to using the TUI mode here, using our assembly language version
    of `do_nothing` from [Listing 10-4](ch10.xhtml#ch10list4). I’ll step through each
    of the instructions. You’ll get a chance to single-step through each of them in
    “Your Turn” [exercise 10.1](ch10.xhtml#ch10exe1) on [page 205](ch10.xhtml#commonL1).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TUI模式的文档可以在`gdb`的`info`中找到。我将在这里简单介绍如何使用TUI模式，使用我们从[示例10-4](ch10.xhtml#ch10list4)中的汇编语言版本的`do_nothing`。我将逐步讲解每一条指令。你将在“轮到你了”部分的[练习10.1](ch10.xhtml#ch10exe1)中有机会逐条执行这些指令，详见[第205页](ch10.xhtml#commonL1)。
- en: '**NOTE**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*My example here shows* gdb *being run from the command line. I’ve been told
    that this doesn’t work well if you try to run* gdb *within Emacs.*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*我的示例展示了* gdb *从命令行运行的情况。我被告知，如果尝试在Emacs中运行* gdb *，可能效果不佳。*'
- en: 'As we did in [Chapter 2](ch02.xhtml), we’ll run `do_nothing` under `gdb`, but
    this time we’ll use the TUI mode:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](ch02.xhtml)中所做的，我们将通过`gdb`运行`do_nothing`，但这次我们将使用TUI模式：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This should bring up a screen like the one in [Figure 10-1](ch10.xhtml#ch10fig1).
    Note that [Figures 10-1](ch10.xhtml#ch10fig1) through [10-7](ch10.xhtml#ch10fig7)
    are zoomed in for readability; your screen view may look different, depending
    on your terminal window settings.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会显示类似于[图 10-1](ch10.xhtml#ch10fig1)中的屏幕。请注意，[图 10-1](ch10.xhtml#ch10fig1)
    到 [图 10-7](ch10.xhtml#ch10fig7)已放大以便阅读；根据你的终端窗口设置，屏幕显示可能有所不同。
- en: '![Image](../images/pg227_Image_247.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg227_Image_247.jpg)'
- en: '*Figure 10-1: Starting* gdb *in TUI mode gives the* src *display.*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：在 TUI 模式下启动* gdb *会显示* src *视图。*'
- en: Enter c to continue through the preliminary message shown in this screenshot.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 c 以继续显示此截图中的初步消息。
- en: Next, set a breakpoint at the first instruction of the program and set a display
    layout. There are several display layouts available in TUI mode. We’ll use the
    `regs` layout, shown in [Figure 10-2](ch10.xhtml#ch10fig2).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在程序的第一条指令处设置断点，并设置显示布局。在 TUI 模式中有几种显示布局可供选择。我们将使用[图 10-2](ch10.xhtml#ch10fig2)中显示的
    `regs` 布局。
- en: '![image](../images/pg228_Image_248.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg228_Image_248.jpg)'
- en: '*Figure 10-2: Adding the* regs *display pane to the TUI window*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-2：将* regs *显示面板添加到 TUI 窗口中*'
- en: The `layout regs` command divides the display pane into a `regs` pane and an
    `src` pane. I’ve moved the focus to the `regs` pane before telling `gdb` to run
    the program. The program starts with a `0x1` in the `x0` register (your value
    may differ). The instruction in the program that is about to be executed is highlighted.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`layout regs` 命令将显示面板分为 `regs` 面板和 `src` 面板。我在告诉 `gdb` 运行程序之前，将焦点移至 `regs`
    面板。程序开始时，`x0` 寄存器的值为 `0x1`（你的值可能不同）。即将执行的程序指令已被高亮显示。'
- en: The display isn’t large enough to show all the A64 registers. With the focus
    on the `regs` pane, use the up and down arrow keys and the page up and page down
    keys to scroll through the register display. I pressed the page down key three
    times to get [Figure 10-3](ch10.xhtml#ch10fig3).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 显示面板的大小不足以显示所有的 A64 寄存器。聚焦在 `regs` 面板上，使用上下箭头键以及 page up 和 page down 键滚动浏览寄存器显示。我按下了三次
    page down 键，以便查看[图 10-3](ch10.xhtml#ch10fig3)。
- en: '![image](../images/pg229_Image_249.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg229_Image_249.jpg)'
- en: '*Figure 10-3: Viewing other registers*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：查看其他寄存器*'
- en: The value in `x30` shows the location the program will return to in the C hosted
    environment when it completes execution. You’ll see how this works in [Figure
    10-6](ch10.xhtml#ch10fig6). The value in `pc` is the address of the first instruction
    in our `main` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`x30` 寄存器中的值显示了程序执行完毕后将返回到 C 托管环境的地址。你将在[图 10-6](ch10.xhtml#ch10fig6)中看到这个过程。`pc`
    中的值是我们 `main` 函数中的第一条指令的地址。'
- en: Let’s tell `gdb` to execute a single instruction, as shown in [Figure 10-4](ch10.xhtml#ch10fig4).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们告诉 `gdb` 执行一条指令，如[图 10-4](ch10.xhtml#ch10fig4)所示。
- en: '![image](../images/pg230_Image_250.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg230_Image_250.jpg)'
- en: '*Figure 10-4: Changes in the registers are highlighted.*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：寄存器的变化已被高亮显示。*'
- en: In [Figure 10-4](ch10.xhtml#ch10fig4), `gdb` highlights the next instruction
    to be executed as well as the registers that were changed. We knew `pc` would
    change, since we executed one instruction.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 10-4](ch10.xhtml#ch10fig4)中，`gdb` 高亮显示了即将执行的下一条指令以及已更改的寄存器。我们知道 `pc` 会发生变化，因为我们执行了一个指令。
- en: The instruction that was executed changed `x0`, but that doesn’t show in our
    `regs` display pane in [Figure 10-4](ch10.xhtml#ch10fig4). I used the page up
    key to give the view of `x0` in [Figure 10-5](ch10.xhtml#ch10fig5).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 已执行的指令更改了 `x0`，但这在[图 10-4](ch10.xhtml#ch10fig4)中的 `regs` 显示面板中没有显示。我使用了 page
    up 键来查看[图 10-5](ch10.xhtml#ch10fig5)中的 `x0`。
- en: '![image](../images/pg231_Image_251.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg231_Image_251.jpg)'
- en: '*Figure 10-5: Viewing the register changed by the instruction that was just
    executed*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：查看刚执行的指令更改的寄存器*'
- en: The `x0` register is highlighted in [Figure 10-5](ch10.xhtml#ch10fig5) to show
    that it changed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`x0` 寄存器在[图 10-5](ch10.xhtml#ch10fig5)中被高亮显示，以显示它已发生变化。'
- en: Next, we’ll tell `gdb` to execute the `ret` instruction, which should take us
    back to the C hosted environment, as shown in [Figure 10-6](ch10.xhtml#ch10fig6).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将告诉 `gdb` 执行 `ret` 指令，这应该会把我们带回 C 托管环境，如[图 10-6](ch10.xhtml#ch10fig6)所示。
- en: '![image](../images/pg232_Image_252.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg232_Image_252.jpg)'
- en: '*Figure 10-6: Back in the C hosted environment*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-6：回到 C 托管环境*'
- en: The `ret` instruction has copied the address from the link register, `x30`,
    to `pc`, thus implementing the return from the `main` function.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`ret` 指令将链接寄存器 `x30` 中的地址复制到 `pc`，从而实现了从 `main` 函数的返回。'
- en: Finally, we continue execution of the program in [Figure 10-7](ch10.xhtml#ch10fig7).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们继续执行[图 10-7](ch10.xhtml#ch10fig7)中的程序。
- en: '![image](../images/pg233_Image_253.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg233_Image_253.jpg)'
- en: '*Figure 10-7: The program has completed.*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-7：程序已完成。*'
- en: All that remains is to quit `gdb`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是退出`gdb`。
- en: '**YOUR TURN**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的回合**'
- en: 10.1     Enter the program in [Listing 10-4](ch10.xhtml#ch10list4) and use `gdb`
    to single-step through the code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 10.1     在[清单 10-4](ch10.xhtml#ch10list4)中输入程序，并使用`gdb`单步执行代码。
- en: '10.2     Write the following C function in assembly language:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 10.2     用汇编语言编写以下C函数：
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Make sure it assembles with no errors. Use the `-S` option to compile *f.c*
    and compare `gcc`’s assembly language with yours. Write a `main` function in C
    that tests your assembly language function, `f`, and prints out the function’s
    return value.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 确保没有错误地汇编。使用`-S`选项编译*f.c*并将`gcc`的汇编语言与您的汇编语言进行比较。编写一个C语言的`main`函数来测试您的汇编语言函数`f`，并打印出该函数的返回值。
- en: 10.3     Write three assembly language functions that do nothing but return
    an integer. They should each return a different nonzero integer. Write a `main`
    function in C that tests your assembly language functions and prints out the functions’
    return values using `printf`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 10.3     编写三个只返回整数的汇编语言函数。它们每个应该返回一个不同的非零整数。编写一个C语言的`main`函数来测试您的汇编语言函数，并使用`printf`打印出这些函数的返回值。
- en: 10.4     Write three assembly language functions that do nothing but return
    a character. Each should return a different character. Write a `main` function
    in C that tests your assembly language functions and prints out the functions’
    return values using `printf`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 10.4     编写三个只返回字符的汇编语言函数。每个函数应返回一个不同的字符。编写一个C语言的`main`函数来测试您的汇编语言函数，并使用`printf`打印出这些函数的返回值。
- en: '**What You’ve Learned**'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: '**Editor** A program used to write the source code for a program in the chosen
    programming language.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**编辑器** 用于编写选定编程语言程序源代码的程序。'
- en: '**Preprocessing** The first stage of compilation. It brings other files into
    the source, interprets directives, and so forth, in preparation for actual compilation.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**预处理** 编译的第一阶段。它将其他文件引入源代码，解释指令等，为实际编译做准备。'
- en: '**Compilation** Translates from the chosen programming language into assembly
    language.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译** 将选定的编程语言翻译成汇编语言。'
- en: '**Assembly** Translates assembly language into machine language.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**汇编** 将汇编语言翻译成机器语言。'
- en: '**Linking** Links separate object code modules and libraries together to produce
    the final executable program.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**链接** 将单独的目标代码模块和库链接在一起，生成最终的可执行程序。'
- en: '**Assembler directives** Guide the assembler program during the assembly process.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**汇编指令** 在汇编过程中指导汇编程序。'
- en: mov **instruction** Moves values within the CPU.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: mov **指令** 在 CPU 内部移动值。
- en: ret **instruction** Returns program flow to the calling function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ret **指令** 将程序流返回到调用函数。
- en: gdb **TUI mode** Displays changes in registers in real time as you step through
    a program. It’s an excellent learning tool.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: gdb **TUI 模式** 当你逐步执行程序时，实时显示寄存器的变化。这是一个非常好的学习工具。
- en: You might be wondering what happens to the return address in `x30` if we call
    another function from `main`. To use `x30` as the link register to call the other
    function, we need to save the return address somewhere while the other function
    is being executed. You’ll learn how to do this in the next chapter, where we look
    at the details of how to pass arguments to functions, how to use the call stack,
    and how to create local variables in functions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，如果我们从`main`调用另一个函数，那么`x30`中的返回地址会发生什么。为了使用`x30`作为链接寄存器调用另一个函数，我们需要在执行另一个函数时将返回地址保存到某个地方。你将在下一章学习如何做到这一点，我们将详细讨论如何向函数传递参数，如何使用调用栈，以及如何在函数中创建局部变量。
