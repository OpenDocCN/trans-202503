- en: '3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '3'
- en: FUNCTION FUNDAMENTALS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数基础
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common01.jpg)'
- en: In the last chapter, we introduced you to Racket’s basic numerical operations.
    In this chapter, we’ll explore the core ideas that form the subject of functional
    programming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了 Racket 的基本数值运算。在本章中，我们将探讨构成函数式编程主题的核心思想。
- en: What Is a Function?
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是函数？
- en: 'A *function* can be thought of as a box with the following characteristics:
    if you push an object in one side, an object (possibly the same, or not) comes
    out the other side; and for any given input item, the same output item comes out.
    This last characteristic means that if you put a triangle in one side and a star
    comes out the other, the next time you put a triangle in, you will also get a
    star out (see [Figure 3-1](ch03.xhtml#ch3fig1)). Unfortunately, Racket doesn’t
    have any built-in functions that take geometric shapes as input, so we’ll need
    to settle for more-mundane objects like numbers or strings.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*函数*可以被看作是一个盒子，具有以下特点：如果你把一个对象放入一侧，另一个对象（可能相同，也可能不同）会从另一侧出来；对于任何给定的输入项，都会输出相同的结果。这最后一个特点意味着，如果你把一个三角形放进一侧，另一侧出来的是一个星星，那么下次你再放入一个三角形时，出来的也会是一个星星（参见[图
    3-1](ch03.xhtml#ch3fig1)）。不幸的是，Racket 没有任何内置函数可以接受几何形状作为输入，所以我们只能使用更普通的对象，比如数字或字符串。
- en: '![Image](../images/03fig01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/03fig01.jpg)'
- en: '*Figure 3-1: How a function works*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：函数如何工作*'
- en: '***Lambda Functions***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Lambda 函数***'
- en: 'In its most basic form, a function in Racket is something produced by a *lambda
    expression*, designated by the Greek letter *λ*. This comes from a mathematical
    discipline called lambda calculus, an arcane world we won’t explore here. Instead,
    we’ll focus on practical applications of lambda expressions. Lambda functions
    are intended for short simple functions that are immediately applied, and hence,
    don’t need a name (they’re anonymous). For example, Racket has a built-in function
    called `add1` that simply adds 1 to its argument. A Racket lambda expression that
    does the same thing looks like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Racket 中，函数最基本的形式是由 *lambda 表达式* 产生的，通常用希腊字母 *λ* 表示。这来源于一种名为 λ 演算的数学学科，这个领域比较晦涩，我们在这里不作探讨。相反，我们将重点关注
    lambda 表达式的实际应用。Lambda 函数用于简短的简单函数，它们会立即被应用，因此不需要一个名字（它们是匿名的）。例如，Racket 有一个内置函数
    `add1`，它简单地将 1 加到它的参数上。一个等价的 Racket lambda 表达式如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Racket lets you abbreviate `lambda` with the Greek symbol *λ*, and we’ll frequently
    designate it this way. You can enter *λ* in DrRacket by selecting it from the
    Insert menu or using the keyboard shortcut CTRL-\. We could rewrite the code above
    to look like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Racket 允许你用希腊字母*λ*来简写 `lambda`，我们将频繁使用这种方式表示它。你可以通过在 DrRacket 中从插入菜单中选择它，或使用快捷键
    CTRL-\ 来输入 *λ*。我们可以将上面的代码重写为如下：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To see a lambda expression in action, enter the following in the interactions
    pane:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看 lambda 表达式的实际效果，在交互面板中输入以下内容：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that instead of a function name as the first element of the list, we
    have the actual function. Here 4 and 5 get passed to the lambda function for evaluation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在列表的第一个元素位置，我们并没有使用函数名，而是使用了实际的函数。在这里，4 和 5 会被传递给 lambda 函数进行求值。
- en: An equivalent way of performing the above computation is with a `let` form.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述计算的另一种等效方式是使用 `let` 形式。
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This form makes the assignment to variables `x` and `y` more obvious.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式使得对变量 `x` 和 `y` 的赋值更加直观。
- en: We can use lambda expressions in a more conventional way by assigning them to
    an identifier (a named function).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 lambda 表达式赋值给标识符（一个命名函数）来以更常规的方式使用它们。
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Racket also allows you to define functions using this shortcut:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Racket 还允许你使用这个快捷方式来定义函数：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These two forms of function definition are entirely equivalent.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种函数定义形式是完全等价的。
- en: '***Higher-Order Functions***'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***高阶函数***'
- en: Racket is a functional programming language. *Functional programming* is a programming
    paradigm that emphasizes a declarative style of programming without side effects.
    A *side effect* is something that changes the state of the programming environment,
    like assigning a value to a global variable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Racket 是一种函数式编程语言。*函数式编程*是一种编程范式，强调一种声明式的编程风格，没有副作用。*副作用*是指改变编程环境状态的事情，比如给全局变量赋值。
- en: Lambda values are especially powerful because they can be passed as values to
    other functions. Functions that take other functions as values (or return a function
    as a value) are known as *higher-order functions*. In this section, we’ll explore
    some of the most commonly used higher-order functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 值特别强大，因为它们可以作为值传递给其他函数。接受其他函数作为值（或返回一个函数作为值）的函数被称为 *高阶函数*。在本节中，我们将探讨一些最常用的高阶函数。
- en: '**The map Function**'
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**map 函数**'
- en: 'One of the most straightforward higher-order functions is the `map` function,
    which takes a function as its first argument and a list as its second argument,
    and then applies the function to each element of the list. Here’s an example of
    the `map` function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 函数是最直接的高阶函数之一，它将一个函数作为第一个参数，一个列表作为第二个参数，然后将该函数应用于列表中的每个元素。下面是一个 `map`
    函数的示例：'
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also pass a named function into `map`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将一个命名函数传递给 `map`：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the first example above, we take our increment function and pass it into
    `map` as a value. The `map` function then applies it to each element in the list
    ’`(1 2 3)`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的第一个示例中，我们将增量函数传递给 `map` 作为一个值。然后 `map` 函数将它应用于列表中的每个元素`(1 2 3)`。
- en: 'It turns out that `map` is quite versatile. It can take as many lists as the
    function will accept as arguments. The effect is sort of like a zipper, where
    the list arguments are fed to the function in parallel, and the resulting values
    is a single list, formed by applying the function to the elements from each list.
    The example below shows `map` being used to add the corresponding elements of
    two equally sized lists together:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，`map` 非常灵活。它可以接受函数能够接受的任意多个列表作为参数。效果有点像拉链，其中列表参数并行传递给函数，得到的结果是一个单一的列表，该列表通过将每个列表中的元素应用到函数上形成。下面的示例展示了如何使用
    `map` 将两个等大小列表的相应元素相加：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the two lists were combined by adding the corresponding elements
    together.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，两个列表通过将相应元素加在一起进行了合并。
- en: '**The apply Function**'
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**apply 函数**'
- en: 'The `map` function lets you apply a function to each item in a list individually.
    But sometimes, we want to apply all the elements of a list as arguments in a single
    function call. For example, Racket arithmetical operators can take multiple numeric
    arguments:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 函数让你可以将一个函数应用于列表中的每一项。但有时候，我们希望将列表的所有元素作为参数应用到单个函数调用中。例如，Racket 的算术运算符可以接受多个数值参数：'
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'But if we try to pass in a list as an argument, we’ll get an error:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们尝试将一个列表作为参数传递进去，我们会得到一个错误：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `+` operator is only expecting numeric arguments. But not to worry. There’s
    a simple solution: the `apply` function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`+` 运算符只接受数值类型的参数。但别担心，有一个简单的解决方案：`apply` 函数：'
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `apply` function takes a function and a list as its arguments. It then *applies*
    the function to values in the list as if they were arguments to the function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 函数接受一个函数和一个列表作为参数。然后它 *应用* 该函数到列表中的值，就像这些值是函数的参数一样。'
- en: '**The foldr and foldl Functions**'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**foldr 和 foldl 函数**'
- en: 'Yet another way to add the elements of a list together is with the `foldr`
    function. The `foldr` function takes a function, an initial argument, and a list:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将列表元素加在一起的方式是使用 `foldr` 函数。`foldr` 函数接受一个函数、一个初始参数和一个列表：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Even though `foldr` produced the same result as `apply` here, behind the scenes
    it worked very differently. This is how `foldr` added the list together: 1 + (2
    + (3 + (4 + 0))). The function “folds” the list together by performing its operation
    in a right-associative fashion (hence the `r` in `foldr`).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `foldr` 在这里产生了与 `apply` 相同的结果，但它在幕后是以非常不同的方式工作的。这就是 `foldr` 如何将列表加在一起的方式：1
    + (2 + (3 + (4 + 0)))。该函数通过以右关联的方式执行操作（因此 `foldr` 中的 `r`）将列表“折叠”在一起。
- en: 'Closely associated with `foldr` is `foldl`. The action of `foldl` is slightly
    different from what you might expect. Observe the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `foldr` 紧密相关的是 `foldl`。`foldl` 的作用与你的预期略有不同。请观察以下内容：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: One might have expected `foldl` to produce ’`(1 2 3 4)`, but actually `foldl`
    performs the computation `(cons 4 (cons 3 (cons 2 (cons 1` ’`()))))`. The list
    arguments are processed from left to right, but the two arguments fed to `cons`
    are reversed—for example, we have `(cons 1` ’`())` and not `(cons` ’`() 1)`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会预期 `foldl` 会生成`(1 2 3 4)`，但实际上 `foldl` 执行的计算是`(cons 4 (cons 3 (cons 2 (cons
    1 ())))))`。列表参数是从左到右处理的，但传递给 `cons` 的两个参数是反转的——例如，我们有 `(cons 1 ())` 而不是 `(cons
    () 1)`。
- en: '**The compose Function**'
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**compose 函数**'
- en: 'Functions can be combined together, or *composed*, by passing the output of
    one function to the input of another. In math, if we have *f* (*x*) and *g*(*x*),
    they can be composed to make *h*(*x*) = *f* (*g*(*x*)) (in mathematics text this
    is sometimes designated with a special composition operator as *h*(*x*) = (*f*
    ∘ *g*)(*x*). We can do this in Racket using the `compose` function, which takes
    two or more functions and returns a new composed function. This new function works
    a bit like a pipeline. For example, if we want to increment a number by 1 and
    square the result (that is, for any *n* compute (*n* + 1)²), we could use following
    function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '函数可以通过将一个函数的输出作为另一个函数的输入来组合在一起，或称为*组合*。在数学中，如果我们有 *f* (*x*) 和 *g*(*x*)，它们可以组合成
    *h*(*x*) = *f* (*g*(*x*))（在数学文本中，有时使用一个特殊的组合运算符表示为 *h*(*x*) = (*f* ∘ *g*)(*x*)）。我们可以在
    Racket 中使用 `compose` 函数来实现这一点，它接受两个或更多的函数并返回一个新的组合函数。这个新函数有点像管道。例如，如果我们想将一个数字加
    1 并平方结果（即，对于任何 *n* 计算 (*n* + 1)²），我们可以使用以下函数：  '
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'But `compose` allows this to be expressed a bit more succinctly:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '但是 `compose` 使得这个表达式更加简洁：  '
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Even simpler . . .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '更简单一些. . .  '
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Please note that `add1` is performed first and then `sqr`. Functions are composed
    from right to left—that is, the rightmost function is applied first.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，`add1` 会首先执行，然后是 `sqr`。函数是从右到左组合的——即最右边的函数先执行。  '
- en: '**The filter Function**'
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**filter 函数**  '
- en: 'Our final example is `filter`. This function takes a predicate (a function
    that returns a Boolean value) and a list. The returned value is a list such that
    only elements of the original list that satisfy the predicate are included. Here’s
    how we’d use `filter` to return the even elements of a list:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的最后一个例子是 `filter`。这个函数接受一个谓词（返回布尔值的函数）和一个列表。返回值是一个列表，其中仅包含原始列表中满足谓词的元素。下面是我们如何使用
    `filter` 来返回列表中的偶数元素：  '
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `filter` function allows you to filter out items in the original list that
    won’t be needed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 函数允许你过滤掉原始列表中不需要的项目。  '
- en: As you’ve seen throughout this section, our description of a function as a box
    is apt since it is in reality a value that can be passed to other functions just
    like a number, a string, or a list.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本节中所看到的，我们将函数描述为盒子的方式是恰当的，因为它实际上是一个值，可以像数字、字符串或列表一样传递给其他函数。
- en: '***Lexical Scoping***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***词法作用域***  '
- en: 'Racket is a lexically scoped language. The Racket Documentation provides the
    following definition for *lexical scoping*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 'Racket 是一种词法作用域语言。Racket 文档为 *词法作用域* 提供了以下定义：  '
- en: Racket is a lexically scoped language, which means that whenever an identifier
    is used as an expression, something in the textual environment of the expression
    determines the identifier’s binding.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'Racket 是一种词法作用域语言，这意味着每当一个标识符被用作表达式时，表达式的文本环境中的某些内容决定了该标识符的绑定。  '
- en: 'What’s important about this definition is the term *textual environment*. A
    textual environment is one of two things: the *global environment*, or forms where
    identifiers are bound. As we’ve already seen, identifiers are bound in the global
    environment (sometimes referred to as the top level) with `define`. For example'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '这个定义中重要的概念是 *文本环境*。文本环境有两种类型：*全局环境* 或者标识符绑定的地方。如我们所见，标识符通常在全局环境（有时称为顶层）中用 `define`
    绑定。例如：  '
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The values of identifiers bound in the global environment are available everywhere.
    For this reason, they should be used sparingly. Global definitions should normally
    be reserved for function definitions and constant values. This, however, is not
    an edict, as there are other legitimate uses for global variables.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '在全局环境中绑定的标识符的值是可以在任何地方使用的。因此，它们应该谨慎使用。全局定义通常应保留给函数定义和常量值。然而，这并不是一个命令，因为全局变量还有其他合法的用途。  '
- en: Identifiers bound within a form will *normally* not be defined outside of the
    form environment (but see [“Time for Some Closure” on page 58](ch03.xhtml#ch00lev1sec_21)
    for an intriguing exception to this rule).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '在一个形式中绑定的标识符*通常*不会在形式外部被定义（但请参阅第 58 页的 [“一些闭包的时刻”](ch03.xhtml#ch00lev1sec_21)，这条规则有个有趣的例外）。  '
- en: Let’s look at a few examples.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们来看几个例子。  '
- en: Previously we explored the lambda expression `((`λ `(x y) (+ (* 2 x) y)) 4 5)`.
    Within this expression, the identifiers `x` and `y` are bound to 4 and 5\. Once
    the lambda expression has returned a value, the identifiers are no longer defined.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '之前我们探讨了 lambda 表达式 `((λ (x y) (+ (* 2 x) y)) 4 5)`。在这个表达式中，标识符 `x` 和 `y` 被绑定为
    4 和 5。一旦 lambda 表达式返回了一个值，标识符将不再被定义。  '
- en: Here again is the equivalent `let` expression.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里再次是等价的 `let` 表达式。
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You might imagine that the following would work as well:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想象，以下代码也会有效：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: But this fails to work. From a syntactic standpoint there’s no way to convert
    this back to an equivalent lambda expression. And although the identifier `x`
    is bound in the list of binding expressions, the value of `x` is only available
    inside the body of the `let` expression.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这无法正常工作。从语法角度来看，无法将其转换回等效的 lambda 表达式。尽管标识符 `x` 已在绑定表达式列表中绑定，但 `x` 的值仅在 `let`
    表达式的主体内可用。
- en: There is, however, an alternative definition of `let` called `let*`. In this
    case the following would work.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`let` 还有一种替代定义，叫做 `let*`。在这种情况下，以下代码将有效。
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The difference is that with `let*` the value of an identifier is available immediately
    after it’s bound, whereas with `let` the identifier values are only available
    after *all* the identifiers are bound.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于，使用 `let*` 时，标识符的值在它被绑定后立即可用，而使用 `let` 时，标识符的值只有在*所有*标识符被绑定后才能使用。
- en: Here’s another slight variation where `let` *does* work.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个稍微不同的变体，其中 `let` *确实*有效。
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this case the second `let` is within the lexical environment of the first
    `let` (but as we’ve seen, `let*` more efficiently encodes this type of nested
    construct). Hence `x` is available for use in the expression `(* 2 x)`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，第二个 `let` 位于第一个 `let` 的词法环境中（但正如我们所见，`let*` 更高效地编码了这种类型的嵌套结构）。因此，`x`
    可以在表达式 `(* 2 x)` 中使用。
- en: 'Conditional Expressions: It’s All About Choices'
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件表达式：一切都与选择有关
- en: The ability of a computer to alter its execution path based on an input is an
    essential component of its architecture. Without this a computer cannot compute.
    In most programming languages this capability takes the form of something called
    a *conditional expression*, and in Racket it’s expressed (in its most general
    form) as a `cond` expression.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机根据输入改变执行路径的能力是其架构中的一个重要组成部分。没有这一点，计算机无法进行计算。在大多数编程语言中，这种能力表现为一种叫做 *条件表达式*
    的东西，而在 Racket 中，它被表达为（以最通用的形式）`cond` 表达式。
- en: Suppose you’re given the task to write a function that returns a value that
    indicates whether a number is divisible by 3 only, divisible by 5 only, or divisible
    by both. One way to accomplish this is with the following code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被要求编写一个函数，该函数返回一个值，指示一个数字是否只能被 3 整除、只能被 5 整除，或者同时被两者整除。一种实现方式是使用以下代码。
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `cond` form contains a list of expressions. For each of these expressions,
    the first element contains some type of test, which if it evaluates to true, evaluates
    the second element and returns its value. Note that in this example the test for
    divisibility by 3 and 5 must come first. Here are trial runs:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`cond` 表达式包含一系列表达式。对于这些表达式中的每一个，第一个元素包含某种类型的测试，如果该测试为真，则计算第二个元素并返回其值。请注意，在这个例子中，判断是否能被
    3 和 5 整除的测试必须放在最前面。以下是试运行：'
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A simplified version of `cond` is the `if` form. This form consists of a single
    test (the first subexpression) that returns its second argument (after it’s evaluated)
    if the test evaluates to true; otherwise it evaluates and returns the third argument.
    This example simply tests whether a number is even or odd.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`cond` 的简化版是 `if` 表达式。该表达式由一个单一的测试（第一个子表达式）组成，如果测试为真，则返回其第二个参数（在其被计算之后）；否则返回并计算第三个参数。这个例子简单地测试一个数字是偶数还是奇数。'
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we run some tests:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行一些测试：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Both `cond` and `if` are expressions that return values. There are occasions
    where one simply wants to conditionally execute some sequence of steps if a condition
    is true or false. This usually involves cases where some side effect like printing
    a value is desired and returning a result is not required. For this purpose, Racket
    provides `when` and `unless`. If the conditional expression evaluates to true,
    `when` evaluates all the expressions in its body; otherwise it does nothing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`cond` 和 `if` 都是返回值的表达式。在某些情况下，人们只是希望在条件为真或为假时有条件地执行一些步骤。这通常涉及到某些副作用，比如打印一个值，而不需要返回结果。为了这个目的，Racket
    提供了 `when` 和 `unless`。如果条件表达式为真，`when` 会计算其主体中的所有表达式；否则它什么也不做。'
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `unless` form behaves in exactly the same way as `when`; the difference
    is that `unless` evaluates its body if the conditional expression is not true.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`unless` 表达式的行为与 `when` 完全相同；区别在于，如果条件表达式不为真，`unless` 将会计算其主体。'
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I’m Feeling a Bit Loopy!
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我感觉有点循环！
- en: Loops (or iteration) are the bread and butter of any programming language. With
    the discussion of loops, invariably the topic of *mutability* comes up. Mutability
    of course implies change. Examples of mutability are assigning values to variables
    (or worse, changing a value embedded in a data structure such as a vector). A
    function is said to be *pure* if no mutations (or side effects, like printing
    out a value or writing to a file—also forms of mutation) occur within the body
    of a function. Mutations are generally to be avoided if possible. Some languages,
    such as Haskell, go out of their way to avoid this type of mischief. A Haskell
    programmer would rather walk barefoot through a bed of glowing, hot coals than
    write an impure function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 循环（或迭代）是任何编程语言的基础。在讨论循环时，不可避免地会涉及到*可变性*的话题。可变性当然意味着变化。可变性的例子包括给变量赋值（或者更糟的情况，改变嵌入在数据结构中的值，例如向量）。如果一个函数在函数体内没有发生变异（或副作用，如打印出一个值或写入文件——这些也属于变异形式），则该函数被称为*纯粹*函数。如果可能的话，通常应避免变异。一些语言，如
    Haskell，会特别避免这种不良做法。一个 Haskell 程序员宁愿赤脚走过一床炙热的煤炭，也不愿写一个不纯粹的函数。
- en: There are many good reasons to prefer pure functions, such as something called
    referential transparency (this mouthful simply means the ability to reason about
    the behavior of your program). We won’t be quite so persnickety and will make
    judicious use of mutation and impure functions where necessary.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 偏好纯粹函数有很多充分的理由，比如所谓的引用透明性（这个术语的意思是能够推理程序的行为）。我们不会那么挑剔，并将在必要时谨慎使用变异和不纯粹的函数。
- en: Suppose you’re given the task of defining a function to add the first *n* positive
    integers. If you’re familiar with a language like Python (an excellent language
    in its own right), you might implement it as follows.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被要求定义一个函数来加上前 *n* 个正整数。如果你熟悉像 Python 这样的语言（它本身是一个优秀的语言），你可能会这样实现它。
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is a perfectly good function (and a fairly benign example of using mutable
    variables) to generate the desired sum, but notice both the variables `s` and
    `n` are modified ➊ ➋. While there’s nothing inherently wrong with this, these
    assignments make the implementation of the function `sum` impure.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全有效的函数（并且是使用可变变量的一个相当温和的例子）来生成所需的和，但请注意，变量 `s` 和 `n` 都被修改了 ➊ ➋。虽然这本身没有什么问题，但这些赋值操作使得
    `sum` 函数的实现变得不纯粹。
- en: '***Purity***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***纯粹性***'
- en: Before we get down and dirty, let’s begin by seeing how we can implement looping
    using only pure functions. *Recursion* is the custom when it comes to looping
    or iteration in Racket (and all functional programming languages). A recursive
    function is just a function defined in terms of itself. Here’s a pure (and simple)
    recursive program to return the sum of the first *n* positive integers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始深入讨论之前，让我们先看看如何仅使用纯函数来实现循环。*递归* 是 Racket（以及所有函数式编程语言）中循环或迭代的常见做法。递归函数就是通过自身来定义的函数。以下是一个纯粹的（且简单的）递归程序，用于返回前
    *n* 个正整数的和。
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, we first test whether `n` has reached 0 ➊, and if so we simply
    return the value 0\. Otherwise, we take the current value of `n` and *recursively*
    add to it the `sum` of all the numbers less than `n` ➋. For the mathematically
    inclined, this is somewhat reminiscent of how a proof by mathematical induction
    works where we have a base case ➊ and the inductive part of the proof ➋.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们首先测试 `n` 是否已达到 0 ➊，如果是，则直接返回 0。否则，我们取当前的 `n` 值，并*递归*地将其加上所有小于 `n`
    的数字的 `sum` ➋。对于数学爱好者来说，这有点像数学归纳法的证明方式，其中我们有一个基例 ➊ 和归纳部分 ➋。
- en: Let’s test it out.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下。
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There’s a potential problem with the example we have just seen. The problem
    is that every time a recursive call is made, Racket must keep track of where it
    is in the code so that it can return to the proper place. Let’s take a deeper
    look at this function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的例子存在一个潜在的问题。问题在于每次进行递归调用时，Racket 必须跟踪当前代码的位置，以便它可以返回到正确的位置。让我们更深入地看一下这个函数。
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When the recursive call to `sum` is made ➊, there’s still an addition remaining
    to be done after the recursive call returns. The system must then remember where
    it was when the recursive call was made so that it can pick up where it left off
    when the recursive call returns. This isn’t a problem for functions that don’t
    have to nest very deeply, but for large depths of recursion, the computer can
    run out of space and fail in a dramatic fashion.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当递归调用 `sum` 被执行 ➊ 时，递归调用返回后仍然需要做加法操作。此时，系统必须记住递归调用发生时的位置，以便在递归调用返回后能够从中断的地方继续执行。这对于不需要深度嵌套的函数来说不成问题，但对于深度递归较大的情况，计算机可能会耗尽空间并以戏剧性的方式失败。
- en: Racket (and virtually all Scheme variants) implement something called *tail
    call optimization* (the Racket community says this is simply the proper way to
    handle tail calls rather than an optimization, but *tail call optimization* is
    generally used elsewhere). What this means is that if a recursive call is the
    very last call being made, there’s no need to remember where to return to since
    there are no further computations to be made within the function. Such functions
    in effect behave as a simple iterative loop. This is a basic paradigm for performing
    looping computations in the Lisp family of languages. You do, however, have to
    construct your functions in such a way as to take advantage of this feature. We
    can rewrite the summing function as follows.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Racket（以及几乎所有的 Scheme 变种）实现了一种叫做 *尾调用优化* 的技术（Racket 社区称这只是处理尾调用的正确方式，而不是一种优化，但在其他地方一般称为
    *尾调用优化*）。这意味着，如果递归调用是函数中最后一个执行的调用，那么就不需要记住返回的地方，因为在该函数中没有更多需要计算的内容。此类函数实际上表现为一个简单的迭代循环。这是
    Lisp 系列语言中进行循环计算的基本范式。然而，你必须以特定的方式构造函数，才能利用这一特性。我们可以按如下方式重写求和函数。
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that `sum` now has a local function called `s` that takes an additional
    argument called `acc`. Also notice that `s` calls itself recursively ➋, but it’s
    the last call in the local function; hence tail call optimization takes place.
    This all works because `acc` accumulates the sum and passes it along as it goes.
    When it reaches the final nested call ➊, the accumulated value is returned.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`sum` 现在有一个名为 `s` 的局部函数，它接受一个额外的参数 `acc`。还要注意，`s` 会递归调用自己 ➋，但它是局部函数中的最后一个调用，因此会进行尾调用优化。之所以能够这样工作，是因为
    `acc` 累积了和并在递归过程中不断传递。当它达到最终的嵌套调用 ➊ 时，累积的值会被返回。
- en: Another way to do this is with a named `let` form as shown here.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现方法是使用命名 `let` 形式，如下所示。
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The named `let` form, similar to the normal `let`, has a section where local
    variables are initialized. The expression `[n n]` may at first appear puzzling,
    but what it means is that the first `n`, which is local to the `let`, is initialized
    with the `n` that the `sum` function is called with. Unlike `define`, which simply
    binds an identifier with a function body, the named `let` binds the identifier
    (in this case `loop`), evaluates the body, and returns the value resulting from
    calling the function with the initialized parameter list. In this example the
    function is called recursively (which is the normal use case for a named `let`)
    as indicated by the last line in the code. This is a simple illustration of a
    side-effect-free looping construct favored by the Lisp community.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 命名的 `let` 形式与普通的 `let` 类似，它有一个初始化局部变量的部分。表达式 `[n n]` 起初可能让人感到困惑，但它的意思是，`let`
    中的第一个 `n` 被初始化为 `sum` 函数调用时传入的 `n`。与 `define` 不同，`define` 只是将标识符与函数体绑定，而命名的 `let`
    则绑定标识符（在这个例子中是 `loop`），计算函数体并返回通过初始化参数列表调用函数所得到的值。在这个例子中，函数是递归调用的（这是命名 `let` 的正常使用情况），如代码中的最后一行所示。这是一个无副作用的循环构造的简单示例，受
    Lisp 社区推崇。
- en: '***The Power of the Dark Side***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***黑暗面的力量***'
- en: Purity is good, as far as it goes. The problem is that staying pure takes a
    lot of work (especially in real life). It’s time to take a closer look at the
    dreaded `set!` form. Note that an exclamation point at the end of any built-in
    Racket identifier is likely there as a warning that it’s going to do something
    impure, like modify the program state in some fashion. A programming style that
    uses statements to change a program’s state is said to use *imperative programming*.
    In any case, `set!` reassigns a value to a previously bound identifier. Let’s
    revisit the Python `sum` function we saw a bit earlier. The equivalent Racket
    version is given below.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹性是好的，就它所达到的程度而言。问题在于，保持纯粹需要很多工作（特别是在现实生活中）。是时候仔细看看让人头痛的 `set!` 形式了。请注意，任何内建的
    Racket 标识符末尾加上感叹号，可能是在警告它会做一些不纯的事情，比如以某种方式修改程序状态。使用语句改变程序状态的编程风格被称为*命令式编程*。无论如何，`set!`
    会重新为先前绑定的标识符分配一个值。让我们重新审视一下之前提到的 Python 的 `sum` 函数。下面给出了等效的 Racket 版本。
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Racket doesn’t actually have a `while` statement (this has to do with the expectation
    within the Lisp community that recursion *should* be the go-to method for recursion).
    The Racket `do` form functions as a `do-until`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Racket 实际上没有 `while` 语句（这是因为 Lisp 社区的预期是递归*应该*成为主要的递归方式）。Racket 的 `do` 形式起到了
    `do-until` 的作用。
- en: 'If you’re familiar with the C family of programming languages, then you will
    see that the full form of the `do` statement actually functions much like the
    C `for` statement. One way to sum the first *n* integers in C would be as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 C 系列编程语言，那么你会看到 `do` 语句的完整形式实际上类似于 C 语言中的 `for` 语句。用 C 语言求前 *n* 个整数之和的一种方式如下：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here’s the Racket equivalent:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Racket 的等效形式：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the above code we first initialize the local variable `s` (which holds our
    sum) to 0 ➊. The first argument to `do` ➋ initializes `i` (`i` is local to the
    `do` form) to 1 and specifies that `i` is to be incremented by 1 at each iteration
    of the loop. The second argument ➌ tests whether `i` has reached the target value
    and if so returns the current value of `s`. The last line ➍ is where the sum is
    actually computed by increasing the value of `s` with the current value of `i`
    via the `set!` statement.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们首先将局部变量 `s`（它存储我们的总和）初始化为 0 ➊。`do` 的第一个参数 ➋ 初始化 `i`（`i` 对于 `do` 形式是局部的）为
    1，并指定每次迭代时 `i` 增加 1。第二个参数 ➌ 测试 `i` 是否达到了目标值，如果是，则返回当前 `s` 的值。最后一行 ➍ 实际计算总和的地方，通过
    `set!` 语句将当前 `i` 的值加到 `s` 上。
- en: The value of forms such as `do` with the `set!` statement is that many algorithms
    are naturally stated in a step-by-step fashion with variables mutated by equivalents
    to the `set!` statement. This helps to avoid the mental gymnastics needed to convert
    such constructs to pure recursive functions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如带有 `set!` 语句的 `do` 形式的值，其优点在于许多算法自然地以逐步的方式陈述，而变量则通过类似于 `set!` 语句的操作被改变。这有助于避免将这些结构转换为纯递归函数时需要的复杂思维。
- en: In the next section, we examine the `for` family of looping variants. Here we
    will see that Racket’s `for` form provides a great deal of flexibility in how
    to manage loops.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将研究 `for` 家族的循环变体。在这里，我们将看到 Racket 的 `for` 形式在管理循环方面提供了很大的灵活性。
- en: '***The for Family***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***for 家族***'
- en: Racket provides the `for` form along with a large family of `for` variants that
    should satisfy most of your iteration needs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Racket 提供了 `for` 形式，并且有一个庞大的 `for` 变体家族，足以满足大部分的迭代需求。
- en: '**A Stream of Values**'
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**一系列的值**'
- en: 'Before we dive into `for`, let’s take a look at a couple of Racket forms that
    are often used in conjunction with `for`: `in-range` and `in-naturals`. These
    functions return something we haven’t seen before called a *stream*. A stream
    is an object that’s sort of like a list, but whereas a list returns all its values
    at once, a stream only returns a value when requested. This is basically a form
    of *lazy evaluation*, where a value is not provided until asked for. For example,
    `(in-range 10)` will return a stream of 10 values starting with 0 and ending with
    9\. Here are some examples of `in-range` in action.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究 `for` 之前，让我们先看一下几个常常与 `for` 一起使用的 Racket 形式：`in-range` 和 `in-naturals`。这些函数返回一些我们之前没有见过的东西，叫做*流*。流是类似于列表的对象，但与列表一次性返回所有值不同，流只有在请求时才返回一个值。这基本上是一种*惰性求值*的形式，值在请求之前不会提供。例如，`(in-range
    10)` 会返回一个包含 10 个值的流，起始值为 0，结束值为 9。下面是 `in-range` 实际应用的一些例子。
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the code above, `(in-range 10)` defines a sequence of values 0, 1, . . .
    , 9, but `digits` doesn’t actually contain these digits. It basically just contains
    a specification that will allow it to return the numbers at some later time. When
    `(stream-first digits)` is executed, `digits` gives the first available value,
    which in this case is the number 0\. Then `(stream-rest digits)` returns the stream
    containing the digits after the first, so that `(stream-first (stream-rest digits))`
    returns the number 1\. Finally, `stream-ref` returns the *i*-th value in the stream,
    which in this case is 5.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码中，`(in-range 10)`定义了一个值的序列0，1，...，9，但`digits`实际上并不包含这些数字。它基本上只是包含了一个规范，允许它在稍后的某个时间返回这些数字。当执行`(stream-first
    digits)`时，`digits`返回第一个可用值，这个值是数字0。然后，`(stream-rest digits)`返回包含第一个数字之后所有数字的流，因此`(stream-first
    (stream-rest digits))`返回数字1。最后，`stream-ref`返回流中的第*i*个值，在这个例子中是5。
- en: The function `in-naturals` works like `in-range`, but instead of returning a
    specific number of values, `in-naturals` returns an infinite number of values.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`in-naturals`的工作方式与`in-range`类似，但它返回的是无限数量的值，而不是特定数量的值。
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How the stream concept is useful will become clearer as we see it used within
    some `for` examples. We’ll also met some useful additional arguments for `in-range`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在一些`for`例子中的使用，流的概念如何有用将变得更加清晰。我们还将介绍一些有用的额外参数，用于`in-range`。
- en: '**for in the Flesh**'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**for 的具体实现**'
- en: Here’s an example of `for` in its most basic form. The goal is to print each
    character of the string “Hello” on a separate line.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`for`最基本形式的一个例子。目标是将字符串“Hello”的每个字符单独打印在一行上。
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We capture the `string-length` ➊ and use this length with the `in-range` function
    ➋. `for` then uses the resulting stream of values to populate the identifier `i`,
    which is used in the body of the `for` form to extract and display the characters
    ➌. In the prior section it was pointed out that `in-range` produces a sequence
    of values, but it turns out that in the context of a `for` statement, a positive
    integer can also produce a stream as the following example illustrates.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们捕获了`string-length` ➊，并使用该长度与`in-range`函数 ➋。然后，`for`使用生成的值流来填充标识符`i`，该标识符在`for`表达式体中用于提取和显示字符
    ➌。在前一部分中提到，`in-range`会生成一个值的序列，但事实证明，在`for`语句的上下文中，一个正整数也可以生成一个流，下面的例子将说明这一点。
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `for` form is quite forgiving when it comes to the type of arguments that
    it accepts. It turns out that there’s a much simpler way to achieve our goal.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`表达式对于接受的参数类型非常宽容。事实证明，有一种更简单的方法可以实现我们的目标。'
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Instead of a stream of indexes, we have simply provided the string itself. As
    we’ll see, `for` will accept many built-in data types that consist of multiple
    values, like lists, vectors, and sets. These data types can also be converted
    to streams (for example, by `in-list`, `in-vector`, and so on), which in some
    cases can provide better performance when used with `for`. All expressions that
    provide values to the identifier that `for` uses to iterate over are called *sequence
    expressions*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用索引流，而是直接提供了字符串本身。正如我们将看到的，`for`可以接受许多内建数据类型，这些数据类型包含多个值，如列表、向量和集合。这些数据类型也可以转换为流（例如，通过`in-list`，`in-vector`等），在某些情况下与`for`一起使用时可以提供更好的性能。所有提供值给`for`用来迭代的标识符的表达式被称为*序列表达式*。
- en: It’s time to see how we can make use of the mysterious `in-naturals` form introduced
    above.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看我们如何利用上面介绍的神秘`in-naturals`表达式了。
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `for` form inside the `list-chars` function now has *two* sequence expressions.
    Such sequence expressions are evaluated in parallel until one of the expressions
    runs out of values. That is why the `for` expression eventually terminates, even
    though `in-naturals` provides an infinite number of values.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`list-chars`函数中的`for`表达式现在有*两个*序列表达式。这些序列表达式并行评估，直到其中一个表达式没有值为止。这就是为什么即使`in-naturals`提供了无限数量的值，`for`表达式最终仍然会终止的原因。'
- en: 'There is, in fact, a version of `for` that *does not* evaluate its sequence
    expressions in parallel: it’s called `for*`. This version of `for` evaluates its
    sequence expressions in a nested fashion as the following example illustrates.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，确实有一种版本的`for`，它*不*并行评估其序列表达式：它被称为`for*`。这个版本的`for`会像下面的例子所示，以嵌套的方式评估其序列表达式。
- en: '[PRE44]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this example we also illustrate the additional optional arguments that `in-range`
    can take. The sequence expression `(in-range 2 7 4)` will result in a stream that
    starts with the number 2, and increment that value by 4 with each iteration. The
    iteration will stop once the streamed value reaches one less than 7\. So in this
    expression, `i` is bound to 2 and 6\. The expression `(in-range 1 4)` does not
    specify a step value, so the default step size of 1 is used. This results in `j`
    being bound to 1, 2, and 3.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还展示了`in-range`可以接受的额外可选参数。序列表达式`(in-range 2 7 4)`将产生一个从数字2开始的流，每次迭代时将该值增加4。当流中的值达到小于7的数值时，迭代会停止。所以在这个表达式中，`i`绑定为2和6。表达式`(in-range
    1 4)`没有指定步长值，因此使用默认的步长1。这会导致`j`绑定为1、2和3。
- en: Ultimately, `for*` takes every possible combination of `i` values and `j` values
    to form the output shown.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，`for*`会将每一个可能的`i`值和`j`值的组合形成输出。
- en: Can You *Comprehend* This?
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你能*理解*这个吗？
- en: There is a type of notation in mathematics called set-builder notation. An example
    of set-builder notation is the expression {*x*² ∣ *x* ∈ ℕ, *x* ≤ 10}. This is
    just the set of squares of all the natural numbers between 0 and 10\. Racket provides
    a natural (pun intended) extension of this idea in the form of something called
    a *list comprehension*. A direct translation of that mathematical expression in
    Racket would appear as follows.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 数学中有一种符号叫做集合表示法。集合表示法的一个例子是表达式 {*x*² ∣ *x* ∈ ℕ, *x* ≤ 10}。这只是0到10之间所有自然数的平方集合。Racket提供了一个自然的（字面意思上的）扩展形式，称为*列表推导式*。这个数学表达式在Racket中的直接翻译如下：
- en: '[PRE45]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `#:break` keyword is used to terminate the stream generated by `in-naturals`
    once all the desired values have been produced. Another way to do this, without
    having to resort to using `#:break`, would be with `in-range`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`#:break`关键字用于在`in-naturals`生成的流中，一旦所有期望的值都已生成，就终止该流。另一种方法是在不使用`#:break`的情况下使用`in-range`来实现这一点。'
- en: '[PRE46]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you only wanted the squares of even numbers, you could do it this way:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想要偶数的平方，可以这样做：
- en: '[PRE47]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This time the `#:when` keyword was brought into play to provide a condition
    to filter the values used to generate the list.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这次引入了`#:when`关键字，以提供一个条件，用于过滤生成列表时所用的值。
- en: An important difference of `for/list` over `for` is that `for/list` does not
    produce any side effects and is therefore a pure form, whereas `for` is expressly
    for the purpose of producing side effects.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`for/list`与`for`的一个重要区别是，`for/list`不会产生任何副作用，因此它是一种纯粹的形式，而`for`明确用于产生副作用。'
- en: '**More Fun with for**'
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**更多有趣的`for`用法**'
- en: Both `for` and `for/list` share the same keyword parameters. Suppose we wanted
    to print a list of squares, but don’t particularly like the number 5\. Here’s
    how it could be done.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`和`for/list`共享相同的关键字参数。假设我们想打印一个平方数的列表，但不太喜欢数字5。以下是如何实现它的方法。'
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: By using `#:unless` we’ve produced an output for all values, 1 ≤ *n* < 10, unless
    *n* = 5.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`#:unless`，我们为所有值生成了输出，1 ≤ *n* < 10，除非*n* = 5。
- en: Sometimes it’s desirable to test a list of values to see if they all meet some
    particular criteria. Mathematicians use a fancy notation to designate this called
    the universal quantifier, which looks like this ∀ and means “for all.” An example
    is the expression ∀x ∈ {2, 4, 6}, *x* mod 2 = 0, which is literally interpreted
    as “for all *x* in the set {2, 4, 6}, the remainder of *x* after dividing by 2
    is 0." This just says that the numbers 2, 4, and 6 are even. The Racket version
    of “for all” is `for/and`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要测试一组值是否都满足某些特定条件。数学家们使用一种叫做全称量词的符号来表示这一点，符号是 ∀，表示“对于所有”。例如，表达式 ∀x ∈ {2,
    4, 6}, *x* mod 2 = 0，字面意思是“对于集合{2, 4, 6}中的所有*x*，*x*除以2的余数为0。”这就意味着数字2、4和6是偶数。在Racket中，表示“对于所有”的方式是`for/and`。
- en: Feed the `for/and` form a list of values and a Boolean expression to evaluate
    the values. If each value evaluates to true, the entire `for/and` expression returns
    true; otherwise it returns false. Let’s have a go at it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 给`for/and`形式提供一个值的列表和一个布尔表达式来评估这些值。如果每个值的评估结果为真，则整个`for/and`表达式返回真；否则，它返回假。让我们来试试看。
- en: '[PRE49]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Like `for`, `for/and` can handle multiple sequence expressions. In this case,
    the values in each sequence are compared in parallel.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与`for`类似，`for/and`可以处理多个序列表达式。在这种情况下，每个序列中的值会并行比较。
- en: '[PRE50]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Closely related to `for/and` is `for/or`. Not to be outdone, mathematicians
    have a notation for this as well: it’s called the existential quantifier, ∃. For
    example, they express the fact that there *exists* a number in the set {2, 7,
    4, 6} greater than 5 with the expression ∃*x* ∈ {2, 7, 4, 6}, *x* > 5.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `for/and` 密切相关的是 `for/or`。数学家们也为此有一种符号：称为存在量词，∃。例如，他们用表达式 ∃*x* ∈ {2, 7, 4,
    6}, *x* > 5 来表示在集合 {2, 7, 4, 6} 中 *存在* 一个大于 5 的数。
- en: '[PRE51]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Suppose now that you not only want to know whether a list contains a value
    that meets a certain criterion, but you want to extract the first value that meets
    the criterion. This is a job for `for/first`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在你不仅仅想知道列表中是否包含符合某个标准的值，还想提取第一个符合标准的值。这是 `for/first` 的工作：
- en: '[PRE52]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The last example demonstrates that if there is no value that meets the criterion,
    `for/first` returns false.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的例子表明，如果没有任何值符合标准，`for/first` 会返回 false。
- en: 'Correspondingly, if you want the last value, you can use `for/last`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，如果你想要最后一个值，可以使用 `for/last`：
- en: '[PRE53]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `for` family of functions is fertile ground for exploring parallels between
    mathematical notation and Racket forms. Here is yet another example. To indicate
    the sum of the squares of the integers from 1 to 10, the following notation would
    be employed:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 家族的函数是探索数学符号与 Racket 形式之间类比的沃土。这里是另一个例子。为了表示从 1 到 10 的整数平方和，可以使用以下符号：'
- en: '![Image](../images/p0057-01.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0057-01.jpg)'
- en: 'The equivalent Racket expression is:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的 Racket 表达式是：
- en: '[PRE54]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The equivalent mathematical expression for products is
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于乘积，等价的数学表达式是
- en: '![Image](../images/p0057-02.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0057-02.jpg)'
- en: which in Racket becomes
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Racket 中变为
- en: '[PRE55]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Most of the `for` forms discussed above come in a starred version (for example
    `for*/list`, `for*/and`, `for*/or`, and so on). Each of these works by evaluating
    their sequence expressions in a nested fashion as described for `for*`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 上面讨论的大多数 `for` 形式都有一个带星版本（例如 `for*/list`、`for*/and`、`for*/or` 等）。每个版本通过以嵌套方式评估其序列表达式，正如
    `for*` 所描述的那样。
- en: Time for Some Closure
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 该是时候使用闭包了
- en: 'Suppose you had $100 in the bank and wanted to explore the effects of compounding
    with various interest rates. If you’re not familiar with how compound interest
    works (and you very well should be), it works as follows: if you have *n*[0] in
    a bank account that pays *i* periodic interest, at the end of the period you would
    have this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在银行有 $100，并且想要探讨不同利率下复利的影响。如果你不熟悉复利是如何运作的（而你应该了解它），它的工作原理如下：如果你在一个支付 *i*
    周期性利息的银行账户中存有 *n*[0]，那么在期末你将得到：
- en: '*n*[1] = *n*[0] + *n*[0]*i* = *n*[0](1 + *i*)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*[1] = *n*[0] + *n*[0]*i* = *n*[0](1 + *i*)'
- en: 'Using your $100 deposit as an example, if your bank pays 4 percent (*i* = 0*.*04)
    interest per period (good luck getting that rate at a bank nowadays), you would
    have the following at the end of the period:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以你的 $100 存款为例，如果银行每期支付 4 百分之 (*i* = 0*.*04) 的利息（现在想在银行得到这个利率真的很难），那么在期末你将得到以下金额：
- en: 100 + 100 · 4% = 100(1 + 0.04) = 104
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 100 + 100 · 4% = 100(1 + 0.04) = 104
- en: 'One way to do this is to create a function that automatically updates the balance
    after applying the interest rate. A clever way to compute this in Racket is with
    something called a *closure*, which we use in the following function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是创建一个函数，在应用利率后自动更新余额。一个聪明的方式是使用 Racket 中的 *闭包*，我们将在以下函数中使用它：
- en: '[PRE56]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Notice that this function actually returns another function—the lambda expression
    (λ . . . ) ➊—and that the lambda expression contains variables from the defining
    scope. We shall explain how this works shortly.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个函数实际上返回了另一个函数——lambda 表达式（λ . . . ）➊——并且这个 lambda 表达式包含了来自定义作用域的变量。我们稍后将解释这如何工作。
- en: 'In the code above, we’ve defined a function called `make-comp` which takes
    two arguments: the starting balance and the interest rate percentage. The `rate`
    variable is initialized to (1 + *i*). Rather than return a number, this function
    actually returns another function. The returned function is designed in such a
    way that every time it’s called (without arguments) it updates the balance by
    applying the interest and returns the new balance. You might think that once `make-comp`
    returns the lambda expression, the variables `bal` and `rate` would be undefined,
    but not so with closures. The lambda expression is said to *capture* the variables
    `bal` and `rate`, which are available within the lexical environment where the
    lambda expression is defined. The fact that the returned function contains the
    variables `bal` and `rate` (which are defined outside of the function) is what
    makes it a closure.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们定义了一个名为 `make-comp` 的函数，它接受两个参数：初始余额和利率百分比。`rate` 变量初始化为 (1 + *i*)。这个函数并不直接返回一个数字，而是返回另一个函数。返回的函数设计成每次调用时（不带参数）通过应用利率更新余额并返回新余额。你可能会认为，一旦
    `make-comp` 返回了 lambda 表达式，`bal` 和 `rate` 变量就会被定义为未定义，但在闭包中并非如此。该 lambda 表达式被称为
    *捕获* 了 `bal` 和 `rate` 变量，这些变量在 lambda 表达式定义的词法环境中是可用的。返回的函数包含了 `bal` 和 `rate`
    变量（它们是在函数外部定义的），这就是它成为闭包的原因。
- en: Let’s try this out and see what happens.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下，看看会发生什么。
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, the balance is updated appropriately.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，平衡值已被适当更新。
- en: Another use for closures is in a technique called *memoization*. What this means
    is that we store prior computed values and if a value has already been computed,
    return the remembered value; otherwise go ahead and compute the value and save
    it for when it’s needed again. This is valuable in scenarios where a function
    may be called repeatedly with arguments that have already been computed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包的另一个用途是在一种叫做 *记忆化* 的技术中。其含义是我们存储先前计算的值，如果某个值已经计算过了，就返回已记住的值；否则，继续计算该值并保存，以便下次需要时使用。这在函数可能会多次调用且参数已经计算过的场景中非常有用。
- en: To facilitate this capability, something called a *hash table* or dictionary
    is typically used. A hash table is a mutable set of key-value pairs. A hash table
    is constructed with the function `make-hash`. Items can be stored to the hash
    table via `hash-set!` and retrieved from the table with `hash-ref`. We test whether
    the table already contains a key with `hash-has-key?`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个功能，通常会使用一种叫做 *哈希表* 或字典的结构。哈希表是一个可变的键值对集合。哈希表可以通过 `make-hash` 函数构造。项可以通过
    `hash-set!` 存储到哈希表中，通过 `hash-ref` 从哈希表中检索。我们可以通过 `hash-has-key?` 来测试表中是否已包含某个键。
- en: The standard definition for the factorial function is *n*! = *n*(*n -* 1)!.
    The obvious way to implement this in Racket is with the following.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘函数的标准定义是 *n*! = *n*(*n - 1)!。在 Racket 中实现这一点的显而易见方法如下。
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This works, but every time you call `(fact 100)`, Racket has to perform 100
    computations. With memoization, executing `(fact 100)` still requires 100 computations
    *the first time*. But the next time you call `(fact 100)` (or call `fact` for
    any value less than 100), Racket only has to look up the value in the hash table,
    which happens in a single step. Here’s the implementation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以正常工作，但每次你调用 `(fact 100)` 时，Racket 都必须执行 100 次计算。使用记忆化时，第一次执行 `(fact 100)`
    仍然需要 100 次计算。但下次你调用 `(fact 100)`（或者调用 `fact` 处理任何小于 100 的值）时，Racket 只需在哈希表中查找该值，这只需要一步操作。以下是实现代码。
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It’s important to note that the outer `fact` function actually returns the inner
    `fact` function ➊. This is ultimately what gets executed when we call `fact 100`.
    It’s this inner `fact` function, which captures the hash table, that constitutes
    the closure. First, it checks to see whether the argument to `fact` is one that
    is already computed ➋ and if so, returns the saved value. We still have to compute
    the value if it hasn’t been computed yet ➌, but then we save it in case it’s needed
    later ➍. The local `fact` function is returned as the value of the global `fact`
    function (sorry about using the same name twice).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，外部的 `fact` 函数实际上返回了内部的 `fact` 函数 ➊。这最终就是我们调用 `fact 100` 时执行的部分。正是这个捕获了哈希表的内部
    `fact` 函数，构成了闭包。首先，它检查传递给 `fact` 的参数是否是已计算的值 ➋，如果是，返回保存的值。如果值尚未计算，则必须进行计算 ➌，但计算后会将其保存，以便以后需要时使用
    ➍。局部的 `fact` 函数作为全局 `fact` 函数的返回值被返回（抱歉用了相同的名称两次）。
- en: Applications
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用
- en: Having introduced the basic programming constructs available in Racket, let’s
    take a look at some applications spanning computer science, mathematics, and recreational
    puzzles.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了Racket的基本编程构造后，让我们看一下跨越计算机科学、数学和娱乐谜题的一些应用。
- en: '***I Don’t Have a Queue***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***我没有队列***'
- en: In this section we touch on Racket’s *object-oriented programming* capability.
    Objects are like a deluxe version of the structures we met in [Chapter 1](ch01.xhtml).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将涉及Racket的*面向对象编程*功能。对象就像我们在[第1章](ch01.xhtml)中遇到的结构的豪华版。
- en: 'Imagine early morning at a small-town bank with a single teller. The bank has
    just opened, and the teller is still trying to get set up, but a customer, Tom,
    has already arrived and is waiting at the window. Shortly, two other customers
    show up: Dick and Harry. The teller finally waits on Tom, then Dick and Harry
    in that order. This situation is a classic example of a *queue*. Formally, a queue
    is a first-in, first-out (FIFO) data structure. Racket comes with a built-in queue
    (several, in fact), but let’s explore building one from scratch.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下清晨，一个小镇银行只有一个出纳员。银行刚刚开门，出纳员还在试图准备好工作，但客户Tom已经到达并在窗口等候。不久，另外两个客户出现了：Dick和Harry。出纳员最终依次服务Tom，然后是Dick和Harry。这种情况是一个典型的*队列*示例。严格来说，队列是一种先进先出（FIFO）数据结构。Racket自带有内置队列（事实上有好几个），但让我们尝试从头开始构建一个队列。
- en: 'We can model a queue with a list. For example the line of folks waiting to
    see the teller can be represented by a single list: `(define q (list` ’`tom` ’`dick`
    ’`harry))`. But there’s a problem. It’s clearly easy to remove Tom from the head
    of the list and get the remainder of the list by using `car` (or `first`) and
    `cdr` (or `rest`):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个列表来模拟队列。例如，排队等待看出纳员的人群可以通过一个单一列表表示：`(define q (list 'tom 'dick 'harry))`。但这里有一个问题。显然，通过使用`car`（或`first`）和`cdr`（或`rest`），很容易将Tom从列表头部移除并获得列表的其余部分：
- en: '[PRE60]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'But what happens when Sue comes along? We could do the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当Sue出现时会发生什么？我们可以做如下操作：
- en: '[PRE61]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: But consider what happens if the list is very long, say 10,000 elements. The
    `append` function will create an entire new list containing all the elements from
    q and the one additional value ’`sue`. One way to do this efficiently is to maintain
    a pointer to the last element in the list and instead of creating a new list change
    the `cdr` of the last node of the list to point to the list `(list` ’`sue)` (see
    [Figure 3-2](ch03.xhtml#ch3fig2)). About now alarm bells should be going off in
    your head. You should have an uneasy feeling that modifying a list structure is
    somehow wrong. And you’d be right. It’s not even possible to do this with the
    normal Racket list structure since the `car` and `cdr` cells in a list pair are
    immutable and cannot be changed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 但是想一想，如果列表非常长，比如有10,000个元素，会发生什么。`append`函数将会创建一个包含q中所有元素以及一个附加值`'sue`的新列表。实现这一点的高效方法之一是保持一个指向列表最后一个元素的指针，并且在不创建新列表的情况下，将列表最后一个节点的`cdr`指向列表`(list
    'sue)`（参见[图3-2](ch03.xhtml#ch3fig2)）。此时，警报铃声应该在你脑中响起。你应该会觉得修改列表结构某种程度上是错误的。你是对的。使用正常的Racket列表结构实际上无法做到这一点，因为列表对中的`car`和`cdr`单元是不可变的，不能被更改。
- en: '![Image](../images/03fig02.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig02.jpg)'
- en: '*Figure 3-2: Mutable list*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-2：可变列表*'
- en: The traditional version of Scheme allow the elements of a cons node to be modified
    via `set-car!` and `set-cdr!` methods. Since these aren’t defined in Racket, Racket
    guarantees that any identifier bound to a Racket list will have the same value
    for the life of the program.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme的传统版本允许通过`set-car!`和`set-cdr!`方法修改一个cons节点的元素。由于这些方法在Racket中没有定义，Racket保证任何绑定到Racket列表的标识符，在程序的生命周期内都会保持相同的值。
- en: There are still valid reasons why this capability may be needed. As we’ve seen,
    this functionality is needed for queues to ensure efficient operation. To accommodate
    this need, Racket provides a mutable cons cell that can be created with the `mcons`
    function. Each component of the mutable cons cell can be modified with `set-mcar!`
    and `set-mcdr!`. The functions `mcar` and `mcdr` are the corresponding accessor
    functions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有合理的理由需要这种功能。正如我们所见，这种功能对于队列的高效操作是必需的。为了满足这一需求，Racket提供了一个可变的cons单元，可以通过`mcons`函数创建。可变cons单元的每个组件都可以通过`set-mcar!`和`set-mcdr!`修改。`mcar`和`mcdr`是相应的访问器函数。
- en: The reason modifying a list structure is bad is because if some other identifier
    is bound to the list, it will now have the modified list as its value, and maybe
    that’s not what was intended. Observe the following.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 修改列表结构之所以不好，是因为如果某个其他标识符绑定到该列表，它现在会将修改后的列表作为值，可能这并不是预期的行为。请观察以下示例。
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Although we only *seemed* to be changing the value of `a`, we also changed the
    value of `b`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们看似只改变了 `a` 的值，但我们实际上也改变了 `b` 的值。
- en: 'To avoid this potentially disastrous situation, we’ll *encapsulate* the list
    in such a way that the list itself is not accessible, but we’ll still be able
    to remove elements from the front of the list and add elements to the end of the
    list to implement our queue. Encapsulation is a fundamental component of object-oriented
    programming. We’ll dive right in by creating a class that contains all the functionality
    we need to implement our queue:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种潜在的灾难性情况，我们将 *封装* 列表，使得列表本身不可访问，但我们仍然能够从列表的前端移除元素并向列表的末端添加元素，以实现队列的功能。封装是面向对象编程的基本组成部分。我们将通过创建一个包含实现队列所需所有功能的类来直接深入：
- en: '[PRE63]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Our class name is `queue%` (note that, by convention, Racket class names end
    with `%`). We begin with the class definition ➊. All classes must inherit from
    some parent class. In this case we’re using the built-in class `object%` ➋. Once
    we’ve specified the class name and parent class, we specify the initialization
    parameters for the class ➌. This class takes a single, optional list argument.
    If supplied, this list is used to initialize the queue ➒. Our class uses `head`
    and `tail` pointer identifiers, which we have to define ➍. Within the body of
    a class, `define` statements are not accessible from outside the class. This means
    that there is no way for the values of `head` or `tail` to be bound to an identifier
    outside of the class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类名是 `queue%`（注意，按照约定，Racket 类名以 `%` 结尾）。我们从类定义 ➊ 开始。所有类都必须继承自某个父类。在这个例子中，我们使用内置类
    `object%` ➋。一旦我们指定了类名和父类，我们就指定了类的初始化参数 ➌。这个类接受一个单一的可选列表参数。如果提供了该列表，则使用它来初始化队列
    ➒。我们的类使用 `head` 和 `tail` 指针标识符，我们必须定义它们 ➍。在类的主体内部，`define` 语句对类外部不可访问。这意味着 `head`
    或 `tail` 的值不能绑定到类外部的标识符上。
- en: 'After a required call to the super class (in this case `object%`) ➎, we get
    into the real meat of this class: its methods. First we define a *public* class
    method called `enqueue` ➏. Public methods are accessible from outside the class.
    This method takes a single value, which is added to the end of the queue in a
    manner similar to our apple and banana example. If the queue is empty, then it
    initializes the `head` and `tail` identifiers with the mutable cons cell `t`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在必须调用父类（在此情况下是 `object%`） ➎ 之后，我们进入了这个类的核心部分：它的方法。首先我们定义了一个 *public* 类方法，叫做
    `enqueue` ➏。公共方法可以从类外部访问。此方法接受一个单一值，并将其以类似我们苹果和香蕉示例的方式添加到队列的末尾。如果队列为空，则初始化 `head`
    和 `tail` 标识符为可变的 cons 单元 `t`。
- en: The `dequeue` method ➐ returns the value at the head of the queue, but generates
    an error if the queue is empty. The `head` pointer is updated to point to the
    next value in the queue ➑.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`dequeue` 方法 ➐ 返回队列头部的值，但如果队列为空则会生成错误。`head` 指针会更新为指向队列中的下一个值 ➑。'
- en: To see all the values in the queue, we’ve also defined the method `print-queue`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看队列中的所有值，我们还定义了方法 `print-queue`。
- en: Let’s see it in action.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的实际操作。
- en: '[PRE64]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Class objects are created with the `new` form. This form includes the class
    name and any parameters defined by the `init` form in the class definition (see
    the class definition code ➌).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 类对象是通过 `new` 形式创建的。此形式包括类名和类定义中的 `init` 形式所定义的任何参数（参见类定义代码 ➌）。
- en: Unlike normal Racket functions and methods, an object method must be invoked
    with a `send` form. The `send` identifier is followed by the object name (`queue`),
    the method name, and any arguments for the method.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通的 Racket 函数和方法不同，对象方法必须通过 `send` 形式调用。`send` 标识符后跟对象名称（`queue`）、方法名称以及方法的任何参数。
- en: This example was just meant to expose the basics of Racket’s object-oriented
    capabilities, but we’ll be seeing much more of Racket’s object prowess in the
    remainder of the text.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 本例旨在展示 Racket 面向对象功能的基础，但在接下来的内容中，我们将看到 Racket 在面向对象方面的更多强大功能。
- en: '***The Tower of Hanoi***'
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***汉诺塔***'
- en: The Tower of Hanoi is a puzzle that consists of three pegs embedded in a board,
    along with eight circular discs, each with a hole in the center. No two discs
    are the same size, and they are arranged on one of the pegs so that the largest
    is on the bottom and the rest are arranged such that a smaller disc is always
    immediately above a larger disc (See [Figure 3-3](ch03.xhtml#ch3fig3)).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 汉诺塔是一个包含三根钉子的难题，钉子插在一块板上，板上还有八个圆形的圆盘，每个圆盘中央有一个孔。没有两个圆盘的大小相同，它们排列在其中一根钉子上，最大的圆盘在底部，其他圆盘按照从大到小的顺序排列，确保较小的圆盘总是位于较大的圆盘之上（见[图
    3-3](ch03.xhtml#ch3fig3)）。
- en: '![Image](../images/03fig03.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig03.jpg)'
- en: '*Figure 3-3: The Tower of Hanoi*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-3：汉诺塔*'
- en: W. W. Rouse Ball tells the following entertaining story about how this puzzle
    came about (see [**3**] and [**8**]).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: W. W. Rouse Ball 讲述了一个有趣的故事，说明了这个难题是如何产生的（见[**3**]和[**8**]）。
- en: In the great temple at Benares beneath the dome which marks the center of the
    world, rests a brass plate in which are fixed three diamond needles, each a cubit
    high and as thick as the body of a bee. On one of these needles, at the creation,
    God placed sixty-four disks of pure gold, the largest disc resting on the brass
    plate and the others getting smaller and smaller up to the top one. This is the
    tower of Brahma. Day and night unceasingly, the priest on duty transfers the disks
    from one diamond needle to another, according to the fixed and immutable laws
    of Brahmah, which require that the priest must move only one disk at a time, and
    he must place these discs on needles so that there never is a smaller disc below
    a larger one. When all the sixty-four discs shall have been thus transferred from
    the needle on which, at the creation, God placed them, to one of the other needles,
    tower, temple, and Brahmans alike will crumble into dust, and with a thunderclap
    the world will vanish.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在贝拿勒斯的大庙中，在标志着世界中心的圆顶下，安放着一块铜板，上面固定着三根钻石针，每根针高一肘，粗如蜜蜂的身体。在其中一根针上，神在创造之初放置了 64
    个纯金圆盘，最大的圆盘放在铜板上，其他圆盘逐渐变小，直到顶部的圆盘。这就是梵天之塔。日夜不停，值班的祭司根据梵天的不变法则，将圆盘从一根钻石针移动到另一根上，按照要求，祭司每次只能移动一个圆盘，并且必须把这些圆盘放置在针上，确保没有较小的圆盘在较大的圆盘下面。当这
    64 个圆盘都从神在创造时所放置的那根针上转移到其他任一根针上时，塔、庙和祭司们都会化为尘土，世界将伴随着一声雷鸣消失。
- en: This would take 2^(64) *-* 1 moves. Let’s see how much time we have left until
    the world comes to an end. We assume one move can be made each second.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要 2^(64) *-* 1 步。让我们看看在世界末日来临之前我们还有多少时间。我们假设每秒可以完成一次移动。
- en: '[PRE65]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This last number is about 5*.*84 × 10^(11) years. The universe is currently
    estimated to be a shade under 14 × 10⁹ years old. If the priests started moving
    disks at the beginning of the universe, there would be about 570 billion years
    left, so you probably have at least enough time to finish reading this book.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的数字大约是 5*.*84 × 10^(11) 年。当前宇宙的年龄估计略低于 14 × 10⁹ 年。如果祭司们从宇宙起始时就开始移动圆盘，那么还剩大约
    570 亿年，因此你应该至少有足够的时间读完这本书。
- en: 'As interesting as this is, our main objective is to use Racket to show how
    to actually perform the moves. We’ll of course begin with a more modest number
    of disks, so let’s start with just one disk. We’ll number the pegs 0, 1, and 2\.
    Suppose our goal is to move the disks from peg 0 to peg 2\. With only one disk,
    we just move the disk from peg 0 to peg 2\. If we have *n* > 1 disks, we designate
    the peg we’re moving all the disks from as *f*, the peg we are moving to as *t*
    and the remaining peg we designate as *u*. The steps to solve the puzzle can be
    stated thusly:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个过程很有趣，我们的主要目标是使用 Racket 来展示如何实际执行这些移动。当然，我们会先从较少的圆盘开始，所以让我们从一个圆盘开始。我们将钉子编号为
    0、1 和 2。假设我们的目标是将圆盘从钉子 0 移动到钉子 2。只有一个圆盘时，我们只需将圆盘从钉子 0 移动到钉子 2。如果我们有 *n* > 1 个圆盘，我们将我们要移动所有圆盘的钉子指定为
    *f*，将我们要移动到的钉子指定为 *t*，剩下的钉子我们指定为 *u*。解决这个难题的步骤可以这样表述：
- en: Move *n -* 1 disks from *f* to *u*.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *n -* 1 个圆盘从 *f* 移动到 *u*。
- en: Move a single disk from *f* to *t*.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个圆盘从 *f* 移动到 *t*。
- en: Move *n -* 1 disks from *u* to *t*.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *n -* 1 个圆盘从 *u* 移动到 *t*。
- en: While simple, this process is sufficient to solve the puzzle. Steps 1 and 3
    imply the use of recursion. Here is the Racket code that implements these steps.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个过程简单，但足以解决这个难题。步骤 1 和 3 暗示了递归的使用。以下是实现这些步骤的 Racket 代码。
- en: '[PRE66]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We pass `hanoi` the number of disks, the peg to move them from, and the peg
    to move to. Then we compute the moves required to implement steps one ➌, two ➍,
    and three ➎. Can you see why the `let` expression ➌ determines the unused peg?
    (Hint: think of the possible combinations. For example if *f* = 1 and *t* = 2,
    the `let` expression ➌ would give *u* = 3 *-* (1 + 2) = 0, the unused peg number.)
    The `hanoi` function returns a list of moves ➏. Each element of the list is a
    list of two elements that designate the peg to move from and the peg to move to.
    Here’s an example of the output for three disks:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`hanoi`函数磁盘的数量、起始的柱子和目标柱子。然后，我们计算实现步骤一 ➌、二 ➍ 和三 ➎ 所需的移动。你能理解为什么`let`表达式
    ➌ 决定了未使用的柱子吗？（提示：考虑所有可能的组合。例如，如果 *f* = 1 且 *t* = 2，`let`表达式 ➌ 将得到 *u* = 3 *-*
    (1 + 2) = 0，即未使用的柱子编号。）`hanoi`函数返回一个移动列表 ➏。列表中的每个元素是由两个元素组成的列表，指定了从哪个柱子移动到哪个柱子。以下是三个磁盘的输出示例：
- en: '[PRE67]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note that we have 2³ *-* 1 = 7 moves.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有 2³ *-* 1 = 7 次移动。
- en: As can be seen from the comments in the code, the `hanoi` function is essentially
    a direct translation of the three-step solution process given earlier. Further,
    it provides a practical application of recursion where the function calls itself
    with a simpler version of the problem.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码中的注释所示，`hanoi`函数本质上是前面给出的三步解决过程的直接翻译。此外，它提供了递归的实际应用，其中函数通过传递问题的简化版本来调用自身。
- en: '***Fibonacci and Friends***'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***斐波那契与朋友们***'
- en: The *Fibonacci sequence* of numbers is defined as
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*斐波那契序列*的定义如下：'
- en: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, . . .
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, . . .
- en: where the next term in the sequence is always the sum of the two preceding terms.
    In some cases the initial zero is not considered part of the sequence. This sequence
    has a ton of interesting properties. We will only touch on a few of them here.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个序列中，下一个项总是前两个项的和。在某些情况下，初始的零不被认为是序列的一部分。这个序列有许多有趣的属性。我们这里只会简要介绍其中的一些。
- en: '**Some Interesting Properties**'
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**一些有趣的属性**'
- en: One interesting property of the Fibonacci sequence is that it’s always possible
    to create a rectangle tiled with squares whose sides have lengths generated by
    the sequence, as seen in [Figure 3-4](ch03.xhtml#ch3fig4). We’ll see how to generate
    this tiling in [Chapter 4](ch04.xhtml).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契序列的一个有趣属性是，总是可以创建一个由斐波那契序列中生成的边长的正方形拼接而成的矩形，如[图3-4](ch03.xhtml#ch3fig4)所示。我们将在[第4章](ch04.xhtml)中看到如何生成这种平铺。
- en: '![Image](../images/03fig04.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig04.jpg)'
- en: '*Figure 3-4: Fibonacci tiling*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-4：斐波那契平铺*'
- en: 'Johannes Kepler pointed out that the ratio of consecutive Fibonacci numbers
    approaches a particular number, designated by *ϕ*, which is known as the *golden
    ratio*:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰内斯·开普勒指出，连续斐波那契数的比值接近一个特定的数字，称为 *ϕ*，也被称为*黄金比例*：
- en: '![Image](../images/p067.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p067.jpg)'
- en: If you’re not familiar with that lim *n* →*∞* business, it just means this is
    what you get when *n* gets bigger and bigger.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉 *lim n* →*∞* 这种写法，它只是意味着当 *n* 越来越大时，结果就是这个。
- en: 'The number *ϕ* has many interesting properties as well. One example is the
    *golden spiral*. A golden spiral is a logarithmic spiral whose growth factor is
    *ϕ*, which means that it gets wider (or further from its origin) by a factor of
    *ϕ* for every quarter-turn. A golden spiral with initial radius 1 has the following
    polar equation:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 *ϕ* 也有许多有趣的属性。一个例子是*黄金螺旋*。黄金螺旋是一个对数螺旋，其增长因子为 *ϕ*，这意味着每转一个四分之一圈，螺旋就会以 *ϕ*
    的倍数变宽（或远离原点）。初始半径为1的黄金螺旋具有以下极坐标方程：
- en: '![Image](../images/p067_1.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p067_1.jpg)'
- en: A plot of the golden spiral is shown in [Figure 3-5](ch03.xhtml#ch3fig5). We’ll
    show how this plot was produced in [Chapter 4](ch04.xhtml).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 黄金螺旋的图示见[图3-5](ch03.xhtml#ch3fig5)。我们将在[第4章](ch04.xhtml)中展示如何生成这个图。
- en: '![Image](../images/03fig05.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig05.jpg)'
- en: '*Figure 3-5: The golden spiral*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-5：黄金螺旋*'
- en: '[Figure 3-6](ch03.xhtml#ch3fig6) illustrates an approximation of the golden
    spiral created by drawing circular arcs connecting the opposite corners of squares
    in the Fibonacci tiling (in [Chapter 4](ch04.xhtml) we’ll see how to superimpose
    this spiral onto a Fibonacci tiling).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-6](ch03.xhtml#ch3fig6)展示了通过绘制连接斐波那契平铺中正方形对角线的圆弧来近似黄金螺旋（在[第4章](ch04.xhtml)中，我们将看到如何将这个螺旋叠加到斐波那契平铺上）。'
- en: '![Image](../images/03fig06.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig06.jpg)'
- en: '*Figure 3-6: A golden spiral approximation*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-6：黄金螺旋近似*'
- en: While these two versions of the golden spiral appear quite similar, mathematically
    they’re quite different. This has to do with a concept called *curvature*. This
    has a precise mathematical definition, but for now, just think of it as the curviness
    of the path. The tighter the curve, the larger the curviness. The path described
    by Equation (3.1) has continuous curvature, while the Fibonacci spiral has discontinuous
    curvature. [Figure 3-7](ch03.xhtml#ch3fig7) demonstrates the distinct difference
    in curvature these two paths possess.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个黄金螺旋的版本看起来非常相似，但从数学上讲，它们是非常不同的。这与一个叫做*曲率*的概念有关。这个概念有一个精确的数学定义，但现在你只需将其理解为路径的弯曲程度。曲线越紧，曲率越大。方程（3.1）描述的路径具有连续的曲率，而斐波那契螺旋则具有不连续的曲率。[图
    3-7](ch03.xhtml#ch3fig7)展示了这两条路径在曲率上的明显差异。
- en: We will make use of these properties in the following sections and in [Chapter
    4](ch04.xhtml).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中以及[第4章](ch04.xhtml)中使用这些性质。
- en: '![Image](../images/03fig07.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/03fig07.jpg)'
- en: '*Figure 3-7: Curvature: golden vs. Fibonacci*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-7：曲率：黄金与斐波那契*'
- en: '**Computing the Sequence**'
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计算数列**'
- en: 'Mathematically the sequence *F*[*n*] of Fibonacci numbers is defined by the
    recurrence relation:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 数学上，斐波那契数列*F*[*n*]由以下递推关系定义：
- en: '*F*[n] = *F*[n-1] + *F*[n-2]'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*F*[n] = *F*[n-1] + *F*[n-2]'
- en: In this section we’ll explore three different methods of computing this sequence.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨三种不同的计算该数列的方法。
- en: '**1\. The No-brainer Approach.** With the recurrence relation definition for
    the Fibonacci sequence, our first version practically writes itself. It’s literally
    an exact translation from the definition to a Racket function.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**1. 傻瓜式方法。** 根据斐波那契数列的递推关系定义，我们的第一个版本几乎是现成的。它实际上是从定义到Racket函数的精确翻译。'
- en: '[PRE68]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This code has the virtue of being extremely clear and simple. The only problem
    with this code is that it’s terribly inefficient. The two nested calls cause the
    same value to be computed over and over. The end result is that the amount of
    computation grows exponentially with the size of *n*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的优点是非常清晰简洁。唯一的问题是，它效率极低。两个嵌套调用导致相同的值被反复计算。最终结果是计算量随着*n*的增加而呈指数增长。
- en: '**2\. Efficiency Is King.** Here we explore an ingenious method presented in
    the computer science classic *Structure and Interpretation of Computer Programs*
    [**2**]. The idea is to use a pair of integers initialized such that *a* = *F*[1]
    = 1 and *b* = *F*[0] = 0, and repeatedly apply the transformations:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**2. 效率至上。** 在这里，我们探讨了计算机科学经典著作《计算机程序的构造与解释》中提出的一种巧妙方法[**2**]。这个方法的思路是使用一对整数初始化，使得*a*
    = *F*[1] = 1 和 *b* = *F*[0] = 0，并反复应用以下变换：'
- en: '*a ← a + b*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*a ← a + b*'
- en: '*b ← a*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*b ← a*'
- en: 'It can be shown that after applying these transformations *n* times, we’ll
    have *a* = *F*[*n*+1] and *b* = *F*[*n*]. The proof is not difficult, and I’ve
    left it as an exercise for you. Here’s the code to implement this solution:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 可以证明，在应用这些变换*n*次之后，我们将得到*a* = *F*[*n*+1] 和 *b* = *F*[*n*]。这个证明并不难，我已将其留作习题给你。下面是实现这一解决方案的代码：
- en: '[PRE69]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Due to tail call optimization, `f` recursively calls itself without the need
    to keep track of a continuation point. This works as an iterative process and
    only grows linearly with the size of *n*.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于尾递归优化，`f`递归调用自身时无需保持继续点。它作为一个迭代过程工作，并且随着*n*的增大，增长是线性的。
- en: '**3\. Memory Serves.** In this version we use the memoization technique introduced
    in [“Time for Some Closure” on page 58](ch03.xhtml#ch00lev1sec_21). To facilitate
    this, the code below uses a *hash table*. Recall that a hash table is a mutable
    set of key-value pairs, and it’s constructed with the function `make-hash`. Items
    can be stored to the hash table via `hash-set!` and retrieved from the table with
    `hash-ref`. We test whether the table already contains a key with `hash-has-key?`.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**3. 内存的作用。** 在这个版本中，我们使用了在[《一些闭包的时机》](ch03.xhtml#ch00lev1sec_21)第58页中介绍的记忆化技术。为此，下面的代码使用了*哈希表*。回忆一下，哈希表是一个可变的键值对集合，它是通过函数`make-hash`构建的。可以通过`hash-set!`将项目存储到哈希表中，使用`hash-ref`从表中检索项。我们通过`hash-has-key?`测试表中是否已包含某个键。'
- en: '[PRE70]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This code should be fairly easy to decipher. It’s a straightforward application
    of memoization as seen in the `fact` example presented earlier.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该相当容易理解。它是前面提到的`fact`示例中记忆化（memoization）方法的直接应用。
- en: '**And the Winner Is?** It depends. You should definitely never use the first
    approach. Here’s something to consider when comparing the second and the third:
    the second approach *always* requires *n* computations every time `F` is called
    for *n*. The third approach also requires *n* computations *the first time* `F`
    is called for *n*. If you call it a second (or subsequent) time for *n* (or for
    any number less than *n*), it returns almost instantly since it simply has to
    look up the value in the hash table. There’s a small space penalty for the third
    approach, but it’s likely to be insignificant in most cases.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**获胜者是谁？** 这取决于情况。你绝对不应该使用第一个方法。比较第二个和第三个方法时，考虑以下内容：第二个方法*总是*在每次调用`F`时需要进行*n*次计算。第三个方法在第一次调用`F`时也需要进行*n*次计算。若第二次（或之后）调用`F`时，针对*n*（或任何小于*n*的数值），它几乎瞬间返回结果，因为它只需查找哈希表中的值。第三种方法会有轻微的空间开销，但在大多数情况下，这个开销是微不足道的。'
- en: '**Binet’s Formula.** Before we leave the fascinating world of Fibonacci numbers
    and how to compute them, let’s take a look at *Binet’s Formula*:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**比内公式。** 在我们离开斐波那契数列及其计算方式的迷人世界之前，让我们来看看*比内公式*：'
- en: '![Image](../images/p0071-01.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0071-01.jpg)'
- en: 'In this formula, the following is true:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，以下是正确的：
- en: '![Image](../images/p0071-02.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0071-02.jpg)'
- en: 'This formula provides us with yet another way of computing *F*[*n*]. The following
    applies to all *n*:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式为我们提供了另一种计算*F*[*n*]的方法。以下对所有*n*都适用：
- en: '![Image](../images/p0071-03.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0071-03.jpg)'
- en: 'So the number *F*[*n*] is the closest integer to ![Image](../images/p071.jpg)
    Therefore, if we round to the nearest integer, *F*[*n*] can be computed by the
    following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 所以数字*F*[*n*]是最接近![Image](../images/p071.jpg)的整数。因此，如果我们四舍五入到最接近的整数，*F*[*n*]可以通过以下方式计算：
- en: '![Image](../images/p0071-05.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0071-05.jpg)'
- en: 'The square brackets are used to designate the rounding function. In Racket,
    this becomes:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号用于指定四舍五入函数。在Racket中，这变成：
- en: '[PRE71]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: While Binet’s formula is quite fast (since it does not require looping or recursion),
    the downside is that it only gives an approximate answer, where the other versions
    give an exact value.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然比内公式非常快速（因为它不需要循环或递归），但缺点是它只给出一个近似值，而其他版本则提供精确值。
- en: '**Continued Fractions.** The expression below is an example of a *continued
    fraction*. In this case, the fractional portion is repeated indefinitely. As we
    shall see, continued fractions have a surprising relationship to the Fibonacci
    sequence.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**连分数。** 下面的表达式是一个*连分数*的例子。在这种情况下，分数部分是无限重复的。正如我们将看到的，连分数与斐波那契数列有着惊人的联系。'
- en: '![Image](../images/p0071-06.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0071-06.jpg)'
- en: Since the fraction does repeat infinitely, we may make the following substitution.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个分数是无限重复的，我们可以进行如下替换。
- en: '![Image](../images/p0072-01.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0072-01.jpg)'
- en: 'This substitution simplifies to the quadratic equation:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这个替换简化为二次方程：
- en: '*f² - f* - 1 = 0'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*f² - f* - 1 = 0'
- en: 'That equation has a couple of solutions. This is true:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程有几个解。下面是正确的：
- en: '![Image](../images/p0072-02.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0072-02.jpg)'
- en: 'Or, these are true:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，这些是正确的：
- en: '![Image](../images/p0072-03.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0072-03.jpg)'
- en: 'The question remains: which of these is the right value for *f*? Since *ψ*
    is negative, the answer must be *ϕ*. Thus . . .'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 问题依然存在：哪个值才是*f*的正确值？由于*ψ*是负的，答案必须是*ϕ*。因此……
- en: '![Image](../images/p0072-04.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0072-04.jpg)'
- en: Bet you didn’t see that coming.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌你没想到这个。
- en: '***The Insurance Salesman Problem***'
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***保险销售员问题***'
- en: This problem is adapted from Flannery’s *In Code* [**7**]. It’s an example of
    a problem that could be solved by hand, but we can take advantage of Racket to
    do some of the tedious calculations. The problem is stated as follows.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题改编自Flannery的*《编码》* [**7**]。这是一个可以手工解决的问题，但我们可以利用Racket来完成一些繁琐的计算。问题描述如下。
- en: 'A door-to-door insurance salesman stops at a woman’s house and the following
    dialog ensues:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 一名上门的保险推销员停在一位女士家门口，接下来发生了以下对话：
- en: 'Salesman: How many children do you have?'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 销售员：你有几个孩子？
- en: 'Woman: Three.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 女人：三。
- en: 'Salesman: And what are their ages?'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 销售员：那么他们的年龄是多少？
- en: 'Woman: Take a guess.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 女人：猜猜看。
- en: 'Salesman: How about a hint?'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 销售员：那给个提示怎么样？
- en: 'Woman: Okay, the product of their ages is 36 and all the ages are whole numbers.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 女人：好的，他们年龄的乘积是36，且所有年龄都是整数。
- en: 'Salesman: That’s not much to go on. Can you give me another hint?'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 销售员：这也太少了，能再给我一个提示吗？
- en: 'Woman: The sum of their ages is equal to the number on the house next door.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 女人：他们年龄的总和等于隔壁房子的门牌号。
- en: The salesman immediately runs off, jumps over the fence, looks at the number
    on the house next door, scratches his head, and goes back to the woman.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 推销员立即跑开，跳过栅栏，看了看隔壁房子的号码，挠了挠头，然后回到女人身边。
- en: 'Salesman: Could you give me just one more hint?'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 推销员：你能再给我一个提示吗？
- en: 'Woman: The oldest one plays the piano.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 女人：最年长的那个弹钢琴。
- en: The salesman thinks for a bit, does some calculations, and figures out the children’s
    ages. What are they?
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 推销员想了一会儿，做了一些计算，弄清楚了孩子们的年龄。他们分别是多大？
- en: At first blush, the hints seem a bit incongruous. Let’s take them one at a time.
    First, we know that the product of the three ages is 36\. Here is a program that
    generates all the unique combinations of three positive integers that have a product
    of 36.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，提示看起来有些不一致。让我们逐个分析。首先，我们知道三个年龄的乘积是36。以下是一个程序，它生成所有乘积为36的唯一三正整数组合。
- en: '[PRE72]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'While this code will not win any awards for efficiency, it is relatively simple
    and it gets the job done. We first define the variable `triples` which will contain
    the list of generated triples ➊. The processing actually begins when we call `gen-triples`
    ➐ for each divisor of 36 (provided by the `divisors` function defined in the *math/number-theory*
    library). This function then defines the quotient `q` ➋ of the divisor `d1` into
    36\. Following this we generate a list of divisors of `q` (`divs`, which of course
    also divide 36). We now come to the function `try-div` ➌, which does the bulk
    of the work. Then we get the first divisor (`d2`) of `q` ➍ and generate the third
    divisor (`d3`) by dividing `q` by `d2`. These divisors (`d1`, `d2`, and `d3`)
    are tested to see whether a satisfactory triple is formed (that is to ensure uniqueness,
    we make sure that they form an ordered sequence ➎) . If so, it’s added to the
    list of triples ➏. Testing other divisors resumes on the following line. Running
    this program produces the following sets of triples: {1, 1, 36}, {1, 2, 18}, {1,
    3, 12}, {1, 4, 9}, {2, 2, 9}, {1, 6, 6}, {2, 3, 6}, {3, 3, 4}.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码在效率上不会赢得任何奖项，但它相对简单，且能够完成任务。我们首先定义了变量`triples`，它将包含生成的三元组列表➊。处理实际上在我们为36的每个除数调用`gen-triples`
    ➐时开始（除数由*math/number-theory*库中的`divisors`函数提供）。这个函数接着定义了除数`d1`与36的商`q` ➋。之后，我们生成`q`的除数列表（`divs`，这些除数当然也能整除36）。接下来是`try-div`
    ➌函数，它完成了大部分工作。然后我们得到`q`的第一个除数（`d2`） ➍，并通过将`q`除以`d2`来生成第三个除数（`d3`）。这些除数（`d1`、`d2`和`d3`）被测试以确定是否形成一个合适的三元组（为了确保唯一性，我们确保它们形成一个有序的序列
    ➎）。如果满足条件，它将被添加到三元组列表中➏。测试其他除数将继续进行。运行此程序将生成以下三元组集合：{1, 1, 36}、{1, 2, 18}、{1,
    3, 12}、{1, 4, 9}、{2, 2, 9}、{1, 6, 6}、{2, 3, 6}、{3, 3, 4}。
- en: This alone, of course, does not allow the salesman to determine the ages of
    the children. The second hint is that the sum of the ages equals the number on
    the house next door. Again we make use of Racket to generate the required sums.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭这一点，当然无法让推销员确定孩子们的年龄。第二个提示是，年龄之和等于隔壁房子的号码。我们再次使用Racket生成所需的和。
- en: '[PRE73]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: From this, we have the following.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们得出以下结论。
- en: '![Image](../images/p0074.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/p0074.jpg)'
- en: After looking at the number of the house next door, the salesman still does
    not know the ages. This means the ages must have been one of the two sets of numbers
    that sum to 13 (otherwise he would have known which set to select). Since the
    woman said “The oldest *one* plays the piano,” the only possibility is the set
    of ages *{*2, 2, 9*}*, since the set *{*1, 6, 6*}* would imply *two* oldest.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在看过隔壁房子的号码之后，推销员仍然不知道孩子们的年龄。这意味着年龄一定是那两个和为13的数字集合之一（否则他会知道该选择哪个集合）。由于女人说“最年长的*那个*弹钢琴”，唯一的可能性是年龄集合*{*2,
    2, 9*}*，因为集合*{*1, 6, 6*}*会意味着有*两个*最年长的。
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced Racket’s basic programming constructs and applied
    them to a variety of problem domains. So far our explorations have been confined
    to getting output in a textual form. Next, we will see how to add some bling to
    our applications by generating some graphical output.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们介绍了Racket的基本编程构造，并将其应用于各种问题领域。到目前为止，我们的探索仅限于以文本形式获取输出。接下来，我们将展示如何通过生成图形输出为我们的应用程序添加一些亮点。
