- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: SECURING YOUR SYSTEM**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**保护您的系统**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Securing your system means ensuring that your computer’s resources are used
    only by authorized people for authorized purposes. Even if you have no important
    data on your system, you still have valuable CPU time, memory, and bandwidth.
    Many folks who thought that their systems were too unimportant for anyone to bother
    breaking into found themselves an unwitting relay for an attack that disabled
    a major corporation. You don’t want to wake up one morning to the delightful sound
    of law enforcement agents kicking in your door because your insecure computer
    broke into a bank.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 保护您的系统意味着确保计算机的资源仅供授权人员用于授权的目的。即使您的系统上没有重要数据，您仍然拥有宝贵的CPU时间、内存和带宽。许多曾认为自己的系统不重要，不会有人去破解的人，最终发现自己成了一个无意中的中继站，成为了攻击的工具，导致某个大型公司瘫痪。你不希望有一天早上醒来，听到执法人员破门而入的声音，因为您的不安全计算机被用来破解了某个银行。
- en: Sure, there are things worse than having some punk kid take over your servers—say,
    having the neighborhood loan shark break both your legs. Discovering that your
    organization’s web page now says, “Ha ha, you’ve been r00ted!” is a decent competitor
    for second place. Even more comprehensible intrusions cause huge headaches. Most
    of the actual intrusions I’ve been involved with (not as an attacker, but as a
    consultant to the victim) have originated from countries with government censorship,
    and traffic analysis showed that the intruders were actually just looking for
    unrestricted access to news sites. While I fully sympathize with these people,
    when I’m depending upon the stable operation of my servers to run my business,
    their intrusion is unacceptable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有比某个小屁孩接管您的服务器更糟糕的事情——比如邻里的高利贷者把你的两条腿打断。发现您组织的网页上现在写着“哈哈，你被r00t了！”是个相当强劲的竞争者，可能排得上第二。即便是更容易理解的入侵也会带来巨大的麻烦。我曾参与过的多数实际入侵事件（我不是攻击者，而是作为受害者的顾问）都来自那些有政府审查制度的国家，流量分析显示攻击者其实只是想获取不受限制的新闻网站访问权限。虽然我完全同情这些人，但当我依赖服务器的稳定运行来经营我的业务时，他们的入侵是不可接受的。
- en: Over the last few years, taking over remote computers has become much easier.
    Point-and-click programs for subverting computers can be found through search
    engines. When one bright attacker writes an exploit, several thousand bored teenagers
    with nothing better to do can download it and make life difficult for the rest
    of us. Even if the data on your system is worthless, you must secure the system’s
    resources.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年里，接管远程计算机变得容易多了。可以通过搜索引擎找到一些点选即用的程序，用来颠覆计算机。当一个聪明的攻击者编写了一个漏洞时，数千个无聊的青少年可以下载它，并让我们其他人生活得更困难。即使系统上的数据毫无价值，您仍然必须保护系统的资源。
- en: Generally speaking, operating systems are not broken into; the programs running
    on operating systems are. Even the most paranoiac, secure-by-default operating
    system in the world can’t protect badly written programs from themselves. Occasionally,
    one of those programs can interact with the operating system in such a way as
    to actually compromise the operating system. The most well-known of these are
    *buffer overflows*, where an intruder’s program is dumped straight into the CPU’s
    execution space and the operating system runs it. FreeBSD has undergone extensive
    auditing to eliminate buffer overflows as well as myriad other well-understood
    security issues, but that’s no guarantee that they’ve been eradicated. New functions
    and programs appear continuously, and they can interact with older functions and
    each other in unexpected ways.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，操作系统本身并不会被攻破；而是运行在操作系统上的程序会被攻破。即便是世界上最为偏执、默认安全的操作系统，也无法保护写得不好的程序免受其自身问题的影响。偶尔，某个程序可能与操作系统以某种方式交互，从而实际上危及操作系统的安全。其中最著名的就是*缓冲区溢出*，在这种情况下，攻击者的程序会直接被转储到CPU的执行空间，操作系统随后执行它。FreeBSD进行了广泛的审计，消除了缓冲区溢出以及其他众多众所周知的安全问题，但这并不意味着它们已经被彻底根除。新功能和程序不断出现，它们可能以意想不到的方式与旧功能或彼此之间发生交互。
- en: FreeBSD provides many tools to help you secure your system against attackers,
    both internal and external. While no one of these tools is sufficient, all are
    desirable. Treat everything you learn about system security as a tool in a kit,
    not as the answer to all your problems. For example, while simply raising a system’s
    securelevel will not make your system secure, it can help when combined with reasonable
    permissions, file flags, regular patching, password control, and all the other
    things that make up a good security policy. We’ll cover more advanced security
    tools in [Chapter 19](ch19.xhtml#ch19), but without the basic protections discussed
    here, those tools won’t help secure your system.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 提供了许多工具来帮助你保护系统免受内外部攻击者的侵害。虽然这些工具中的任何一个单独使用都不足够，但它们都是可取的。将你关于系统安全的所有知识视为工具箱中的工具，而不是解决所有问题的答案。例如，虽然仅仅提高系统的安全级别不会让你的系统变得安全，但结合合理的权限、文件标志、定期修补、密码控制以及所有构成良好安全策略的其他措施时，它会起到作用。我们将在[第19章](ch19.xhtml#ch19)中介绍更多的高级安全工具，但如果没有在这里讨论的基本保护措施，这些工具无法帮助你保护系统。
- en: '**Who Is the Enemy?**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**敌人是谁？**'
- en: 'We’ll arbitrarily lump potential attackers into four groups: script kiddies,
    disaffected users, botnets, and skilled attackers. You’ll find a more detailed
    classification in books dedicated to security, but that’s not what you’re here
    for. These categories are easily explained, easily understood, and include 99
    percent of all the attackers you’re likely to encounter.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将潜在的攻击者随便分为四组：脚本小子、不满的用户、僵尸网络和有技术的攻击者。你会在专门讨论安全的书籍中找到更详细的分类，但这不是你要关注的内容。这些类别容易解释，容易理解，并涵盖了你可能遇到的99%的攻击者。
- en: '***Script Kiddies***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***脚本小子***'
- en: 'The most numerous human attackers, *script kiddies*, are not sysadmins. They’re
    not skilled. They download attack programs that work on a point-and-click basis
    and go looking for vulnerable systems. They’re the equivalent of purse snatchers,
    preying upon old ladies holding their bags just a little bit too loosely. Fortunately,
    script kiddies are easy to defend against: just keep your software up-to-date
    and follow good computing practices. Like locusts, script kiddies are easy to
    squash, but there are just so darned *many* of them!'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最多的人类攻击者，*脚本小子*，并不是系统管理员。他们没有技能。他们下载基于点击操作的攻击程序，寻找易受攻击的系统。他们相当于抢包的小偷，专门欺负那些手提包稍微松懈的老太太。幸运的是，脚本小子很容易防范：只需保持软件更新，并遵循良好的计算机操作规范。像蝗虫一样，脚本小子容易被打败，但他们实在是*太多*了！
- en: '***Disaffected Users***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***不满的用户***'
- en: The second group, your own users, causes the majority of security problems.
    Your organization’s employees are the people most likely to know where the security
    gaps are, to feel that the rules don’t apply to them, and to have the time to
    spend breaking your security. If you tell an employee that company policy forbids
    him access to a computer resource, and if the employee feels that he should have
    access to it, he’s likely to search for a way around the restriction. Anyone who
    feels that he’s so fabulously special that the rules don’t apply to him is a security
    risk. Worse, when an employee who knows all the dirty laundry gets angry, bad
    things can happen. You might have all your servers patched and a downright misanthropic
    firewall installed, but if anyone who knows the password is *Current93* can dial
    the back room modem, you’re in trouble.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第二类群体，你的用户，是导致大多数安全问题的根源。你组织的员工最有可能知道安全漏洞的位置，认为规则不适用于他们，并且有时间去破坏你的安全。如果你告诉某个员工公司政策禁止他访问某个计算机资源，而该员工认为他应该有权访问，那么他很可能会寻找绕过限制的方法。任何认为自己特别到规则不适用的人都是安全风险。更糟糕的是，当一个知道所有丑事的员工生气时，坏事可能会发生。你可能已经修补了所有服务器，并安装了极为反人类的防火墙，但如果任何知道密码的人是*Current93*，能够拨打后端调制解调器，你就麻烦了。
- en: The best way to stop people like these is simply not to be sloppy. Don’t leave
    projects insecurely half-finished or half-documented. When someone leaves the
    company, disable his account, change all administrative passwords, inform all
    employees of that person’s departure, and remind them not to share confidential
    knowledge with that person. Have a computer security policy with real violation
    penalties and have HR enforce it. And get rid of the unsecured modem, the undocumented
    telnet server running on an odd port, or whatever hurried hack you put into place
    thinking that nobody would ever find it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止这些人的最佳方式就是简单地不要疏忽大意。不要把项目半途而废或文档不全地留着。当有人离开公司时，禁用他的账户，修改所有的管理员密码，通知所有员工该人的离职，并提醒他们不要与该人分享机密信息。制定一套具有实际违规惩罚的计算机安全政策，并由人力资源部门执行。并且，清除那些不安全的调制解调器、运行在奇怪端口上的未记录的
    telnet 服务器，或者你当初匆忙设置的、以为没人会发现的黑客后门。
- en: '***Botnets***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***僵尸网络***'
- en: Botnets are more numerous than either of the above, but they’re not human. They’re
    machines compromised by malware and controlled from a central point. Botnets can
    include millions of machines. The malware authors control the botnets and use
    them for anything from searching for more vulnerable hosts to sending spam or
    breaking into secure sites. Most botnets are composed of Windows and Linux machines,
    but there’s no reason why FreeBSD operating systems can’t be assimilated into
    botnets.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 僵尸网络的数量超过了上述任何一类，但它们不是人类。它们是被恶意软件感染并从一个中心点控制的机器。僵尸网络可以包括数百万台机器。恶意软件的作者控制着这些僵尸网络，并利用它们做任何事情，从寻找更多易受攻击的主机到发送垃圾邮件或突破安全网站。大多数僵尸网络由
    Windows 和 Linux 机器组成，但并不排除 FreeBSD 操作系统也可能被纳入僵尸网络中。
- en: Fortunately, botnet defense is much like script kiddie defense; keeping your
    software patched and following good computing practices goes a long way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，僵尸网络防御和脚本小子防御非常相似；保持软件更新并遵循良好的计算实践会带来很大帮助。
- en: '***Motivated Skilled Attackers***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***有动机的熟练攻击者***'
- en: The most dangerous group—skilled attackers—are competent system administrators,
    security researchers, penetration specialists, and criminals who want access to
    your specific resources. Computer penetration is a lucrative criminal field these
    days, especially if the victim has resources that can be used for distributed
    denial-of-service (DDos) attacks or mass spam transmission. Compromising a web
    farm and turning it to evil is profitable. If you have valuable company secrets,
    you might be targeted by one of these intruders. If one of these people *really*
    wants to break into your network, he’ll probably get there.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最危险的群体——熟练攻击者——是那些有能力的系统管理员、安全研究员、渗透专家和犯罪分子，他们想要访问你的特定资源。如今，计算机渗透是一个有利可图的犯罪领域，尤其是当受害者拥有可以用于分布式拒绝服务（DDoS）攻击或大规模垃圾邮件传输的资源时。妥协一个网站农场并将其转化为恶意用途是有利可图的。如果你有有价值的公司机密，可能会成为这些入侵者的目标。如果这些人*真的*想要突破你的网络，他很可能会成功。
- en: Still, security measures that stop the first three groups of people change the
    tactics of the skilled attacker. Instead of breaking into your computers over
    the network, he’ll have to show up at your door dressed as a telco repairman lugging
    a packet sniffer, or dumpster-dive searching for old sticky notes with scribbled
    passwords. This dramatically increases his risk, possibly making an intrusion
    more trouble than it’s worth. If you can make the intruder’s break-in plan resemble
    a Hollywood script *no matter how much he knows about your network*, your security
    is probably pretty good.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，能够阻止前三类人群的安全措施会改变熟练攻击者的战术。他将不再通过网络突破你的计算机，而是得以伪装成一名电信维修工，背着一个数据包嗅探器出现在你家门口，或是翻垃圾桶找寻写满密码的旧便签。这大大增加了他的风险，可能会使得入侵变得不值得冒险。如果你能让入侵者的突破计划看起来像一部好莱坞剧本，*不管他对你的网络了解多少*，那么你的安全措施可能已经相当不错了。
- en: '**Hackers, Intruders, and Related Scum**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑客、入侵者及相关渣滓**'
- en: You’ll frequently hear the word *hacker* used to describe people who break into
    computers. This word has different meanings depending on the speaker. In the technical
    world, a hacker is someone who’s interested in the inner workings of technology.
    Some hackers are interested in everything; others have a narrow area of specialization.
    In the open source community, *hacker* is a title of respect. The main FreeBSD
    technical list is *[FreeBSD-hackers@FreeBSD.org](mailto:FreeBSD-hackers@FreeBSD.org)*.
    In the popular media, however, a hacker is someone who breaks into computer systems,
    end of story.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常听到“*黑客*”这个词用来描述那些闯入计算机的人。这个词根据说话者的不同有不同的含义。在技术领域，黑客是指那些对技术内部运作感兴趣的人。有些黑客对所有内容都有兴趣，而其他人则专注于某一特定领域。在开源社区中，*黑客*是一个尊重的称呼。FreeBSD的主要技术邮件列表是*
    [FreeBSD-hackers@FreeBSD.org](mailto:FreeBSD-hackers@FreeBSD.org)*。然而，在大众媒体中，黑客通常是指那些闯入计算机系统的人，故事就到此为止。
- en: To reduce confusion, I recommend completely avoiding the word *hacker*. In this
    book, I call people who break into computers *intruders*.[*](ch09.xhtml#ch09fn1aa)
    Technical wizards can be called by a variety of names, but they rarely object
    to “Oh Great and Powerful One.”
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少混淆，我建议完全避免使用“*黑客*”这个词。在本书中，我称那些闯入计算机的人为*入侵者*。[*](ch09.xhtml#ch09fn1aa) 技术高手可以被称为各种名字，但他们通常不会反对“哦，伟大而强大的存在”。
- en: '[*](ch09.xhtml#ch09fn1b) Two editions later, and my editor *still* won’t let
    me print what I call them in person.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[*](ch09.xhtml#ch09fn1b) 两个版本之后，我的编辑*仍然*不允许我当面说出我对他们的看法。'
- en: '**FreeBSD Security Announcements**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**FreeBSD安全公告**'
- en: The best defense against any attackers is to keep your system up to date. This
    means you must know when to patch your system, what to patch, and how. An outdated
    system is a script kiddie’s best friend.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 防范任何攻击者的最佳方法是保持系统的最新状态。这意味着你必须知道何时为系统打补丁，打什么补丁，以及如何打。一个过时的系统是脚本小子的最佳伙伴。
- en: The FreeBSD Project includes volunteers who specialize in auditing source code
    and watching for security issues with both the base operating system and add-on
    software. These developers maintain a very low-volume mailing list, *[FreeBSD-security-notifications@FreeBSD.org](mailto:FreeBSD-security-notifications@FreeBSD.org)*,
    and subscribing is a good idea. While you can monitor other mailing lists for
    general announcements, the security notifications list is a single source for
    FreeBSD-specific information. To subscribe to the security notifications mailing
    list, see the instructions on *[http://lists.freebsd.org/](http://lists.freebsd.org/)*.
    The FreeBSD security team releases advisories on that mailing list as soon as
    they’re available.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD项目包含一些志愿者，他们专门负责审计源代码，并监控基础操作系统及附加软件的安全问题。这些开发人员维护着一个非常低流量的邮件列表，* [FreeBSD-security-notifications@FreeBSD.org](mailto:FreeBSD-security-notifications@FreeBSD.org)
    *，订阅该列表是一个好主意。虽然你可以通过其他邮件列表来获取一般公告，但安全通知列表是获取FreeBSD特定信息的唯一来源。要订阅安全通知邮件列表，请参见*
    [http://lists.freebsd.org/](http://lists.freebsd.org/)*。FreeBSD安全团队会在该邮件列表中一有新的安全公告就发布。
- en: Read advisories carefully and quickly act on those that affect you, as you can
    be certain that script kiddies are searching for vulnerable machines. FreeBSD
    makes applying security patches pretty easy, as [Chapter 18](ch18.xhtml#ch18)
    discusses.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细阅读安全公告，并迅速采取措施应对影响到你的那些问题，因为你可以确定脚本小子正在寻找易受攻击的机器。正如[第18章](ch18.xhtml#ch18)所讨论的，FreeBSD使得应用安全补丁变得非常简单。
- en: '**User Security**'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用户安全**'
- en: Remember when I said that your own users are your greatest security risk? Here’s
    where you learn to keep the little buggers in line. FreeBSD has a variety of ways
    to allow users to do their work without giving them free rein on the system. We’ll
    look at the most important tools here, starting with adding users in the first
    place.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我说过，你自己的用户是你最大的安全隐患吗？现在你将学习如何管好这些“小家伙”。FreeBSD提供了多种方式，让用户能够完成工作，而不需要让他们在系统上为所欲为。我们将在这里讨论一些最重要的工具，从添加用户开始。
- en: '***Creating User Accounts***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建用户账户***'
- en: FreeBSD uses the standard Unix user management programs such as passwd(1), pw(8),
    and vipw(8). FreeBSD also includes a friendly interactive user-adding program,
    adduser(8). Only *root* may add users, of course. Just type `adduser` on the command
    line to enter an interactive shell.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD使用标准的Unix用户管理程序，如passwd(1)、pw(8)和vipw(8)。FreeBSD还包含了一个友好的交互式用户添加程序adduser(8)。当然，只有*root*用户可以添加其他用户。只需在命令行中输入`adduser`即可进入交互式命令行。
- en: The first time you run adduser(8), it prompts you to set appropriate defaults
    for all new user settings. Use the following example session to help you determine
    appropriate defaults for your system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次运行 adduser(8) 时，它会提示你为所有新用户设置适当的默认值。使用以下示例会话来帮助你为系统确定合适的默认值。
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The username ➊ is the name of the account. Users on my systems get a username
    of their first initial, middle initial, and last name. You can assign usernames
    by whatever scheme you dream up. Here, I let the user pick their own username,
    an indulgence I always later regret. The full name ➋ is the user’s real name.
    FreeBSD then lets you choose a numerical user ID (UID) ➌. FreeBSD starts numbering
    UIDs at 1,000; while you can change this, all UIDs below 1,000 are reserved for
    system use. I recommend just pressing ENTER to take the next available UID.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名 ➊ 是账户的名称。我系统上的用户会获得一个由他们的名字首字母、中间名首字母和姓氏组成的用户名。你可以根据自己想出的方案来分配用户名。在这里，我让用户自己选择用户名，这种宽容通常会让我后悔。全名
    ➋ 是用户的真实姓名。FreeBSD 接着让你选择一个数字化的用户 ID (UID) ➌。FreeBSD 从 1000 开始编号 UID；虽然你可以更改此设置，但所有低于
    1000 的 UID 都保留给系统使用。我建议直接按 ENTER 键选择下一个可用的 UID。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The user’s default group ➊ is important—remember, Unix permissions are set by
    owner and group. The FreeBSD default of having each user in their own group is
    usually the most sensible way for most setups. Any of the big thick books on system
    administration offers several grouping schemes—feel free to use whatever matches
    your needs. You can add this user to other groups ➋ in addition to the primary
    group at this time, if appropriate.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的默认组 ➊ 非常重要——记住，Unix 权限是根据所有者和组设置的。FreeBSD 默认将每个用户分配到自己的组，通常是大多数设置中最合理的方式。关于系统管理的大部头书籍提供了几种分组方案——随时使用任何符合你需求的方案。如果适当，你现在可以将该用户添加到其他组
    ➋，除了主组之外。
- en: A login class ➌ specifies what level of resources the user has access to. We’ll
    talk about login classes later in this section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 登录类 ➌ 指定了用户可以访问的资源级别。我们稍后会在本节中讨论登录类。
- en: The shell ➍ is the command line environment. While the system default is */bin/sh*,
    I prefer tcsh.^([1](footnote.xhtml#ch09fn1)) If you’re deeply attached to another
    shell, feel free to use it instead. Knowledgeable users can change their own shells.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Shell ➍ 是命令行环境。虽然系统默认是 */bin/sh*，我更喜欢 tcsh。^([1](footnote.xhtml#ch09fn1)) 如果你对其他
    shell 深有依赖，随时可以使用它。精通的用户可以更改自己的 shell。
- en: The home directory ➎ is where the user’s files reside on disk. The user and
    that user’s primary group own this directory. You can set custom permissions ➏
    on the directory if you want, probably so that other users can’t view this user’s
    directory.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 家目录 ➎ 是用户文件在磁盘上的存放位置。该用户及其主组拥有此目录。如果需要，你可以在目录上设置自定义权限 ➏，通常是为了防止其他用户查看该用户的目录。
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The password options give you a certain degree of flexibility. If all of your
    users are comfortable with key-based SSH authentication, perhaps you can get away
    without using passwords. In the meantime, the rest of us are stuck with passwords
    ➊.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 密码选项提供了一定程度的灵活性。如果所有用户都熟悉基于密钥的 SSH 身份验证，也许你可以不用密码。与此同时，其余的人都得依赖密码 ➊。
- en: Use an empty password ➋ if you want the user to set his or her own password
    via the console. Whoever connects to that account first gets to set the password.
    This makes an empty password a good idea right up there with smoking inside a
    hydrogen dirigible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望用户通过控制台设置自己的密码，可以使用空密码 ➋。第一次连接到该账户的人将设定密码。将空密码作为一种设置，与在氢气飞艇内吸烟一样不太明智。
- en: A random password ➌, on the other hand, is a good idea for a new account. The
    random password generator FreeBSD provides is good enough for day-to-day use.
    Random passwords are usually hard to remember, which encourages the user to change
    his password as soon as possible.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，随机密码 ➌ 对于新账户来说是一个好主意。FreeBSD 提供的随机密码生成器足够日常使用。随机密码通常很难记住，这会促使用户尽快更改密码。
- en: When an account is locked ➍, nobody can use it to log in. This is generally
    counterproductive.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当账户被锁定 ➍ 时，没人可以用它登录。这通常是适得其反的。
- en: After entering all this information, adduser spits everything back at you for
    review and confirmation or rejection. Once you confirm, adduser verifies the account
    setup and provides you with the randomly generated password. It then creates the
    user’s home directory, copies the shell configuration files from */etc/skel*,
    and asks whether you want to set up another user.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输入所有信息后，adduser会将所有内容反馈给您进行审查和确认或拒绝。一旦您确认，adduser会验证账户设置并为您提供随机生成的密码。然后，它会创建用户的主目录，从*/etc/skel*复制shell配置文件，并询问您是否要设置另一个用户。
- en: '***Configuring Adduser: /etc/adduser.conf***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置Adduser: /etc/adduser.conf***'
- en: Creating new users on some Unix systems requires you to manually edit */etc/passwd*,
    rebuild the password database, edit */etc/group*, create a home directory, set
    permissions on that home directory, install dotfiles, and so on. This makes handling
    your local customizations routine—if you set everything by hand, you can manage
    your local account setup easily. The adduser(8) program provides a set of sensible
    defaults. For sites with different requirements, */etc/adduser.conf* lets you
    set those requirements as defaults while retaining the high degree of automation.
    To create *adduser.conf file*, run `adduser -C` and answer the questions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些Unix系统上创建新用户需要手动编辑*/etc/passwd*，重建密码数据库，编辑*/etc/group*，创建主目录，设置该主目录的权限，安装dotfiles，等等。这使得处理本地自定义变得例行化——如果您手动设置所有内容，就可以轻松管理本地账户设置。adduser(8)程序提供了一组合理的默认值。对于有不同需求的网站，*/etc/adduser.conf*允许您将这些需求设置为默认值，同时保持高度的自动化。要创建*adduser.conf文件*，请运行`adduser
    -C`并回答相关问题。
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You might want to start numbering UIDs somewhere other than 1,000\. If you want
    higher initial UIDs, enter it in the `Uid` space ➊. Don’t start below 1,000.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望从1,000以外的地方开始编号UID。如果您想要更高的初始UID，请在`Uid`字段中输入 ➊。不要从1,000以下开始。
- en: The login group ➋ is the default user group. An empty login group means the
    user account defaults to having its own unique user group (the FreeBSD default).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 登录组 ➋ 是默认的用户组。空的登录组意味着用户账户默认会有一个独立的唯一用户组（FreeBSD默认设置）。
- en: You can specify any additional user groups ➌ that new accounts belong to by
    default, as well as the login class ➍. I set both of these to `staff` so that
    all new users get added to that group and assigned that class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指定新账户默认属于的任何其他用户组 ➌，以及登录类 ➍。我将这两个设置为`staff`，这样所有新用户都会被添加到该组并分配该类。
- en: Choose a default shell ➎ for your users.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的用户选择一个默认的shell ➎。
- en: Your home directory location ➏ might vary from the standalone FreeBSD standard.
    In this example, I’ve specified a typical style of NFS-mounted home directories
    used when many users have accounts on many machines.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您的主目录位置 ➏ 可能与独立的FreeBSD标准有所不同。在这个例子中，我指定了当多个用户在多台机器上有账户时，常用的NFS挂载的主目录样式。
- en: Choose the default password behavior for new users. You can specify whether
    users should use passwords at all ➐ and whether the initial password should be
    empty ➑ or random ➒.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 选择新用户的默认密码行为。您可以指定用户是否应该使用密码 ➐，以及初始密码是应该为空 ➑ 还是随机生成 ➒。
- en: Finally, dictate whether new accounts should default to being locked or not
    ➓.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，决定新账户是否默认锁定 ➓。
- en: You’ll find more configuration settings in adduser.conf(5). While you can set
    account characteristics here, the format of this file is considered internal to
    adduser(8). The setting names can change with any FreeBSD release. To change *adduser.conf*,
    re-run `adduser -C`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在adduser.conf(5)中找到更多配置设置。虽然您可以在这里设置账户特征，但该文件的格式被认为是adduser(8)的内部格式。设置名称可能会随着任何FreeBSD版本的发布而变化。要更改*adduser.conf*，请重新运行`adduser
    -C`。
- en: '***Editing Users***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编辑用户***'
- en: Managing users isn’t just about creating and deleting accounts. You’ll need
    to change those accounts from time to time. While FreeBSD includes several tools
    for editing accounts, the simplest are passwd(1), chpass(1), vipw(8), and pw(8).
    These work on the tightly interrelated files */etc/master.passwd*, */etc/passwd*,
    */etc/spwd.db*, and */etc/pwd.db*. We’ll start with the files and then review
    the common tools for editing those files.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 管理用户不仅仅是创建和删除账户。您需要不时地更改这些账户。虽然FreeBSD提供了多个工具用于编辑账户，但最简单的工具是passwd(1)、chpass(1)、vipw(8)和pw(8)。这些工具作用于紧密关联的文件*/etc/master.passwd*、*/etc/passwd*、*/etc/spwd.db*和*/etc/pwd.db*。我们将从这些文件开始，然后回顾编辑这些文件的常用工具。
- en: The files */etc/master.passwd*, */etc/passwd*, */etc/spwd.db*, and */etc/pwd.db*
    hold user account information. Each file has a slightly different format and purpose.
    The file */etc/master.passwd* is the authoritative source of user account information
    and includes user passwords in encrypted form. Normal users don’t have permission
    to view the contents of */etc/master.passwd*. Regular users need access to basic
    account information, however; how else can unprivileged system programs identify
    users? The file */etc/passwd* lists user accounts with all privileged information
    (such as the encrypted password) removed. Anyone can view the contents of */etc/passwd*
    to get basic account information.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 */etc/master.passwd*、*/etc/passwd*、*/etc/spwd.db* 和 */etc/pwd.db* 都包含用户账户信息。每个文件的格式和用途略有不同。文件
    */etc/master.passwd* 是权威的用户账户信息来源，并包含加密形式的用户密码。普通用户没有权限查看 */etc/master.passwd*
    的内容。然而，普通用户需要访问基本的账户信息；否则，未经授权的系统程序怎么识别用户呢？文件 */etc/passwd* 列出了用户账户，移除了所有特权信息（如加密密码）。任何人都可以查看
    */etc/passwd* 的内容以获取基本的账户信息。
- en: Many programs need account information, and parsing a text file is notoriously
    slow. In this day of laptop supercomputers, the word *slow* isn’t very meaningful,
    but this was a very real problem back when disco freely roamed the earth. For
    that reason, BSD-derived systems build a database file out of */etc/master.passwd*
    and */etc/passwd*. (Other Unix-like systems have similar functionality in different
    files.) The file */etc/spwd.db* is taken directly from */etc/master.passwd* and
    contains sensitive user information, but it can be read only by root. The file
    */etc/pwd.db* can be read by anyone, but it contains the limited subset of information
    contained in */etc/passwd*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序需要账户信息，而解析文本文件非常缓慢。在如今笔记本超级计算机的时代，*缓慢* 这个词不再那么有意义，但在迪斯科风靡一时的年代，这确实是一个非常实际的问题。正因如此，BSD
    衍生的系统将 */etc/master.passwd* 和 */etc/passwd* 构建为一个数据库文件。（其他类 Unix 系统在不同的文件中有类似的功能。）文件
    */etc/spwd.db* 直接来自 */etc/master.passwd*，并包含敏感的用户信息，但只有 root 可以读取。文件 */etc/pwd.db*
    则可以被任何人读取，但它只包含 */etc/passwd* 中的有限信息。
- en: Any time any standard user management program changes the account information
    in */etc/master.passwd*, FreeBSD runs pwd_mkdb(8) to update the other three files.
    For example, the three programs passwd(1), chpass(1), and vipw(8) all allow you
    to make changes to the master password file, and all three programs trigger pwd_mkdb
    to update the related files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每当任何标准的用户管理程序更改 */etc/master.passwd* 中的账户信息时，FreeBSD 会运行 pwd_mkdb(8) 来更新其他三个文件。例如，三个程序
    passwd(1)、chpass(1) 和 vipw(8) 都允许你修改主密码文件，并且这三个程序都会触发 pwd_mkdb 来更新相关文件。
- en: '**Changing a Password**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**更改密码**'
- en: Use passwd(1) to change passwords. A user can change his own password, and root
    can change anyone’s password. To change your own password, just enter `passwd`
    at the command prompt.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 passwd(1) 来更改密码。用户可以更改自己的密码，而 root 用户可以更改任何人的密码。要更改自己的密码，只需在命令提示符下输入 `passwd`。
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When changing your own password, passwd(1) first asks for your current password.
    This is to ensure that nobody else can change your password without your knowledge.
    It’s always good to log out when you walk away from your terminal, but when you
    don’t, this simple check in passwd(1) prevents practical jokers from really annoying
    you. Then enter your new password twice, and it’s done. When you’re the superuser
    and want to change another user’s password, just give the username as an argument
    to passwd.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改自己的密码时，passwd(1) 会首先要求输入当前密码。这是为了确保没有其他人可以在你不知情的情况下更改你的密码。虽然走开时注销总是个好习惯，但当你没有注销时，passwd(1)
    中的这个简单检查可以防止恶作剧者真正让你烦恼。然后输入两次新密码，操作就完成了。当你是超级用户并且想更改其他用户的密码时，只需在 passwd 后给出用户名作为参数。
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that root doesn’t need to know the user’s old password; the root user can
    change any user account on the system in any manner desired.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，root 用户不需要知道用户的旧密码；root 用户可以以任何方式更改系统中的任何用户账户。
- en: '**USER MANAGEMENT AND $EDITOR**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户管理与 $EDITOR**'
- en: User management tools such as chpass and vipw (as well as many other system
    management tools) bring up a text editor window where you make your changes. These
    tools generally check the environment variable `$EDITOR` to see which text editor
    you prefer. `$EDITOR` lets you default to vi, Emacs, or any other editor installed.
    I recommend Vigor, a vi(1) clone with an animated-paperclip help system that might
    make users of older Microsoft Office versions feel more comfortable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 像chpass和vipw这样的用户管理工具（以及许多其他系统管理工具）会弹出一个文本编辑器窗口，让你进行修改。这些工具通常会检查环境变量`$EDITOR`，以查看你偏好的文本编辑器。`$EDITOR`允许你默认使用vi、Emacs或其他已安装的编辑器。我推荐Vigor，它是vi(1)的一个克隆，具有动画回形针帮助系统，这可能会让习惯使用老版Microsoft
    Office的用户感到更舒适。
- en: '**Changing Accounts with chpass(1)**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用chpass(1)更改账户**'
- en: 'The account has more information associated with it than just the password.
    The chpass(1) utility lets users edit everything they can reach in their account.
    For example, if I run chpass(1) as a regular user, I get an editor with the following
    text:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 账户除了密码外，还有更多关联的信息。chpass(1)工具允许用户编辑他们能接触到的账户信息。例如，如果我以普通用户身份运行chpass(1)，我会看到一个编辑器，里面包含以下内容：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I’m allowed to edit six informational fields in my account. The first, my shell,
    can be set to any shell listed in */etc/shells* (see “[Shells and */etc/shells*](ch09.xhtml#lev282)”
    on [page 178](ch09.xhtml#page_178)). I can change my full name; perhaps I want
    my full middle name listed, or maybe I wish to be known to other system users
    as *Mr. Scabies*. I can update my office location and office phone so my coworkers
    can find me easily. This is another feature that was very useful on the university
    campuses where BSD grew up and where system users rarely had an idea of anyone’s
    physical location. Now that we have extensive online directories and many more
    computers, it’s less useful. I generally set my home phone number to 911 (999
    in the UK), and I put a little bit of personal information in the `Other` space.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以编辑账户中的六个信息字段。第一个是我的shell，可以设置为*/etc/shells*中列出的任何shell（参见 “[Shells 和 */etc/shells*](ch09.xhtml#lev282)”
    [第178页](ch09.xhtml#page_178)）。我可以更改我的全名；也许我想列出我的全名中的中间名，或者可能我希望其他系统用户称我为*斯卡比斯先生*。我还可以更新我的办公位置和办公电话，以便同事们能轻松找到我。这是BSD在大学校园中发展时非常有用的功能，那时系统用户很少知道彼此的物理位置。现在我们有了广泛的在线目录和更多的计算机，这个功能就不那么有用了。我通常将我的家庭电话号码设置为911（在英国为999），并在`其他`字段中填写一些个人信息。
- en: Also note what I *can’t* change as a regular user. The sysadmin sets my home
    directory, and I may not change it even if the system has a new hard drive with
    lots of empty space for my MP3 collection. My UID and GID numbers, similarly,
    are assigned by the system or the sysadmin.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，作为普通用户，我*无法*更改的内容。系统管理员设置了我的主目录，即使系统有一块新硬盘，空间足够存放我的MP3收藏，我也不能更改它。我的UID和GID号也类似，是由系统或系统管理员分配的。
- en: On the other hand, if I run `chpass xistence`, its heightened privileges give
    me a very different view.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我运行`chpass xistence`，其提升的权限给了我一个完全不同的视角。
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As root, you can do anything you like to the poor user. Changing his login to
    *megaloser* is only the start of the havoc you can wreak. You even get access
    to the user’s hashed password ➊. Don’t alter this field, unless you’re comfortable
    computing password hashes. Use passwd(1) to more safely and reliably change the
    user’s password. You can also change the user’s home directory, although chpass(1)
    doesn’t move the user’s files; you must copy them by hand.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为root，你可以对那个可怜的用户做任何你想做的事情。将他的登录名改为*megaloser*只是你能制造的混乱的开始。你甚至可以访问该用户的哈希密码
    ➊。除非你擅长计算密码哈希，否则不要修改这个字段。使用passwd(1)来更安全、更可靠地更改用户的密码。你也可以更改用户的主目录，尽管chpass(1)不会移动用户的文件；你必须手动复制它们。
- en: You can also set a date for password changes and account expiration. Password
    expiration is useful if you’ve just changed a user’s password and you want him
    to change it upon his first login. Account expiration is useful when someone asks
    for an account but insists it’s needed only for a limited time. You can forget
    to go back to delete that account, but FreeBSD never forgets. Both of these fields
    take a date in the form *month day year*, but you need only the first three letters
    of the month. For example, to make a user’s password expire on June 8, 2028, I
    would enter `Jun 8 2028` in the `Change` space. Once the user changes his password,
    the password expiration field is blanked out again, but only the system administrator
    can extend an account expiration date.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置密码更改和账户过期的日期。如果你刚刚更改了一个用户的密码，并希望他在第一次登录时更改密码，密码过期功能就非常有用。账户过期功能在某人请求账户时尤其有用，尤其是当他们坚持只需要账户使用有限时间时。你可能会忘记删除该账户，但
    FreeBSD 永远不会忘记。这两个字段都采用 *月 日 年* 的日期格式，但只需要输入月份的前三个字母。例如，要让一个用户的密码在 2028 年 6 月
    8 日到期，我会在 `Change` 空间输入 `Jun 8 2028`。一旦用户更改了密码，密码过期字段会被清空，但只有系统管理员才能延长账户的过期日期。
- en: '**The Big Hammer: vipw(8)**'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**大锤：vipw(8)**'
- en: While chpass(1) is fine for editing individual accounts, what happens when you
    must edit many accounts? Suppose your system has hundreds of users and a brand
    new hard disk for the home partition. Do you really want to run chpass(1) hundreds
    of times? That’s where vipw(8) comes in.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 chpass(1) 适用于编辑单个账户，但当你必须编辑多个账户时该怎么办？假设你的系统有数百个用户，并且有一个全新的硬盘用于主目录分区。你真想执行
    chpass(1) 数百次吗？这时，vipw(8) 就派上用场了。
- en: Directly edit */etc/master.passwd* with vipw(8). When you finish your edits,
    vipw(8) checks the password file’s syntax to be sure you haven’t ruined anything.
    Then, it saves the new password file and runs pwd_mkdb(8). Although vipw(8) can
    protect your password file from many basic mistakes, if you’re clever, you can
    still muck things up. You must understand the format of the password file to use
    vipw(8) properly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用 vipw(8) 编辑 */etc/master.passwd*。编辑完成后，vipw(8) 会检查密码文件的语法，确保你没有破坏任何内容。然后，它会保存新的密码文件并运行
    pwd_mkdb(8)。尽管 vipw(8) 可以保护你的密码文件免受许多基本错误，但如果你足够聪明，仍然可能会弄糟。你必须了解密码文件的格式，才能正确使用
    vipw(8)。
- en: If the information in */etc/master.passwd* conflicts with information in other
    files, */etc/master.passwd* wins. For example, the primary group that appears
    in */etc/master.passwd* is correct, even if */etc/group* doesn’t show the user
    as a member. This “*master.passwd* is always correct” logic is deeply ingrained
    throughout user management.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 */etc/master.passwd* 中的信息与其他文件中的信息冲突，则以 */etc/master.passwd* 中的信息为准。例如，*/etc/master.passwd*
    中显示的主要组是正确的，即使 */etc/group* 中没有将该用户列为成员。这种“*master.passwd* 永远是正确的”逻辑深深植根于用户管理中。
- en: 'Each line in */etc/master.passwd* is a single account record, containing 10
    colon-separated fields. These fields are the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/master.passwd* 中的每一行都是一个账户记录，包含 10 个由冒号分隔的字段。这些字段如下：'
- en: '**Username**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户名**'
- en: This field is either an account name created by the sysadmin or a username created
    at install time to provide some system service. FreeBSD includes users for system
    administration, such as root, daemon, games, and so on. Each of these users owns
    a part of the base system. FreeBSD also provides accounts for common services,
    such as the *www* user reserved for use by web servers. Add-on software might
    add its own system accounts as well.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段是系统管理员创建的账户名，或者是安装时为提供某些系统服务而创建的用户名。FreeBSD 包括用于系统管理的用户，如 root、daemon、games
    等。每个用户拥有基础系统的一部分。FreeBSD 还提供了用于常见服务的账户，如为 web 服务器保留的 *www* 用户。附加软件可能还会添加自己的系统账户。
- en: '**Encrypted Password**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密密码**'
- en: The second field is the encrypted password. System users don’t have a password,
    so you can’t log in as one of them. User accounts have a string of random-looking
    characters here.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字段是加密密码。系统用户没有密码，因此你不能以他们的身份登录。用户账户在此处有一串看起来随机的字符。
- en: '**User ID**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户 ID**'
- en: The third field is the *user ID number*, or *UID*. Every user has a unique UID.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个字段是*用户 ID 数字*，或*UID*。每个用户都有一个唯一的 UID。
- en: '**Group ID**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**组 ID**'
- en: Similarly, the fourth field is the *group ID number*, or *GID*. This is the
    user’s primary group. Usually this is identical to the UID, and the group has
    the same name as the username.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，第四个字段是*组 ID 数字*，或*GID*。这是用户的主要组。通常，这与 UID 相同，且该组的名称与用户名相同。
- en: '**User’s Class**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户类别**'
- en: The next field is the user’s class as defined in */etc/login.conf* (see “[Restricting
    System Usage](ch09.xhtml#lev300)” on [page 188](ch09.xhtml#page_188)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个字段是用户在 */etc/login.conf* 中定义的用户类别（参见 “[限制系统使用](ch09.xhtml#lev300)” 第188页([page
    188](ch09.xhtml#page_188))）。
- en: '**Password Expiration**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**密码过期**'
- en: This field is the same as the password expiration date set via chpass(1), but
    here the time gets stored as seconds from the epoch. Use `date -j` and the `+%s`
    output format to generate epochal seconds from a real date. To convert midnight,
    June 1, 2018, to epochal seconds, run `date -j 201806010000 '+%s'`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字段与通过 chpass(1) 设置的密码过期日期相同，不过这里的时间以自纪元以来的秒数存储。使用 `date -j` 和 `+%s` 输出格式可以将真实日期转换为纪元秒数。要将
    2018 年 6 月 1 日午夜转换为纪元秒数，可以运行 `date -j 201806010000 '+%s'`。
- en: '**Account Expiration**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**账户过期**'
- en: This field enables you to make the account shut itself off on a certain day.
    Just set the account expiration date as you would for password expiration.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字段允许你在某一天使账户自动关闭。只需像设置密码过期一样设置账户过期日期。
- en: '**Personal Data**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**个人数据**'
- en: This field is also known as the *gecos* field for obscure historical reasons.
    It contains the user’s real name, office number, work phone number, and home phone
    number, all separated by commas. Do not use colons in this field; */etc/master.passwd*
    reserves colons as a field delimiter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字段也被称为 *gecos* 字段，原因有些历史上的晦涩。它包含用户的真实姓名、办公室号码、工作电话和家庭电话，所有内容以逗号分隔。不要在此字段中使用冒号；*/etc/master.passwd*
    保留冒号作为字段分隔符。
- en: '**User’s Home Directory**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户的主目录**'
- en: The ninth field is the user’s home directory. While this defaults to */home/<username>*,
    you can move this anywhere appropriate. You’ll also need to move the actual home
    directory and its files when you change this field. Users with a nonexistent home
    directory can’t log in by default, although the `requirehome` setting in *login.conf*
    can change this.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第九个字段是用户的主目录。默认情况下为 */home/<username>*，但你可以将其移动到任何适当的位置。更改此字段时，你还需要移动实际的主目录及其文件。没有主目录的用户默认无法登录，不过可以通过
    *login.conf* 中的 `requirehome` 设置进行更改。
- en: '**User’s Shell**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户的 Shell**'
- en: The final field is the user’s shell. If this field is empty, the system assigns
    the user the boring old */bin/sh*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的字段是用户的 shell。如果这个字段为空，系统会分配给用户老式的 */bin/sh*。
- en: While chpass(1) lets you muck up individual user accounts, vipw(8) unleashes
    you on the entire userbase. Be careful with it!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 chpass(1) 让你可以修改单个用户账户，但 vipw(8) 让你可以操作整个用户库。使用时要小心！
- en: '**Removing a User**'
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**删除用户**'
- en: The rmuser(8) program deletes user accounts. You’ll be prompted for the username
    you want to delete and asked whether you want to remove that user’s home directory.
    That’s really all you have to do; destruction is much easier than creation, after
    all.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: rmuser(8) 程序用于删除用户账户。你会被提示输入要删除的用户名，并询问是否删除该用户的主目录。其实你只需要做这些，毕竟销毁比创建要简单得多。
- en: '**Scripting with pw(8)**'
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 pw(8) 脚本**'
- en: The pw(8) command provides a powerful command line interface to user accounts.
    While useradd(8) walks you through setting up an account in a friendly manner,
    pw(8) lets you specify everything on a single command line. I find pw(8) cumbersome
    for day-to-day use, but if you manage many user accounts, it’s invaluable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: pw(8) 命令提供了一个强大的命令行界面来管理用户账户。虽然 useradd(8) 会以友好的方式引导你设置账户，但 pw(8) 让你可以在一行命令中指定所有内容。我发现
    pw(8) 对日常使用来说有些笨重，但如果你管理很多用户账户，它是无价的。
- en: One thing I do use pw(8) for is locking accounts. While a locked account is
    active, nobody can log in to it. I’ve used this to great effect when a client
    was behind on a bill; users call quite quickly when they can’t log in, and yet
    their websites continue to come up and their email continues to accumulate.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实使用 pw(8) 来锁定账户。虽然被锁定的账户仍然存在，但没人能登录。我曾在客户拖欠账单时有效使用这个方法；当用户无法登录时，他们通常会很快联系，但他们的网站依然在线，邮件也继续积累。
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When Bert apologizes, I’ll unlock his account.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Bert 道歉时，我将解锁他的账户。
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you need scripts to manage your users, definitely read the pw(8) man page.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要脚本来管理用户，强烈建议阅读 pw(8) 的手册页。
- en: '**Shells and /etc/shells**'
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Shell 和 /etc/shells**'
- en: The *shell* is the program that provides the user’s command prompt. Different
    shells behave differently and offer different shortcuts and features. Many people
    are very attached to particular shells and complain bitterly if their shell isn’t
    available on a system. The packages collection contains many shells.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shell* 是提供用户命令提示符的程序。不同的 shell 行为各异，提供不同的快捷方式和功能。许多人对特定的 shell 非常依赖，如果他们的
    shell 在某个系统上不可用，常常会抱怨。软件包集合中包含了许多不同的 shell。'
- en: The file */etc/shells* contains a list of all legitimate user shells. When you
    install a shell from a port or a package, it adds an appropriate entry in */etc/shells*.
    If you compile your own shell from source, without using a FreeBSD port, you must
    list the shell by its complete path in */etc/shells*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 */etc/shells* 包含所有合法用户 shell 的列表。当你从端口或软件包安装一个 shell 时，它会在 */etc/shells*
    中添加一个相应的条目。如果你从源代码编译自己的 shell，而没有使用 FreeBSD 端口，你必须在 */etc/shells* 中列出该 shell 的完整路径。
- en: The FTP daemon won’t allow a user to log in via FTP if his shell isn’t listed
    in */etc/shells*. If you use */sbin/nologin* as an FTP-only user shell, you must
    add it to this file, although a better way to handle such users is with login
    classes, as discussed later in this chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户的 shell 没有列在 */etc/shells* 中，FTP 守护进程将不允许用户通过 FTP 登录。如果你使用 */sbin/nologin*
    作为仅限 FTP 使用的用户 shell，你必须将其添加到该文件中，尽管处理此类用户的更好方法是使用登录类，正如本章后面讨论的那样。
- en: '**root, Groups, and Management**'
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**root、用户组与管理**'
- en: Unix security has been considered somewhat coarse because one superuser, *root*,
    can do anything. Other users are lowly peons who endure the shackles root places
    upon them. The problem is, root doesn’t have a wide variety of shackles on hand
    and can’t individualize them very well. While there’s some truth to this, a decent
    administrator can combine groups and permissions to handle almost any problem
    securely.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 安全性被认为有些粗糙，因为一个超级用户，*root*，可以做任何事。其他用户只是低级的仆人，忍受着 root 对他们的束缚。问题在于，root
    并没有很多不同种类的束缚，且无法很好地个性化这些束缚。虽然这话有一定道理，但一位称职的管理员可以通过组合用户组和权限，安全地解决几乎任何问题。
- en: '***The root Password***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***根密码***'
- en: Certain actions require absolute control of the system, including manipulating
    core system files such as the kernel, device drivers, and authentication systems.
    Such activities are designed to be performed by root.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 某些操作需要对系统的绝对控制，包括操作核心系统文件，如内核、设备驱动程序和身份验证系统。这些活动是为 root 用户设计的。
- en: 'To use the root password, you can either log in as root at a console login
    prompt or, if you’re a member of the group wheel, log in as yourself and use the
    switch user command su(1). (We’ll discuss groups later in this section.) I recommend
    su; it logs who uses it and can be used on a remote system. The command is very
    simple to use:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用根密码，你可以在控制台登录提示符下以 root 身份登录，或者，如果你是 *wheel* 组的成员，可以以自己的身份登录并使用切换用户命令 su(1)。（我们稍后会在本节中讨论用户组。）我建议使用
    su；它会记录谁使用了它，并且可以在远程系统上使用。这个命令非常简单：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, check your current user ID with the id(1) command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 id(1) 命令检查你当前的用户 ID：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You now own the system—and I do mean *own* it. Consider every keystroke; carelessness
    can return your hard drive to the primordial state of unformatted empty wasteland.
    And share the root password sparingly, if at all, because anyone who has the root
    password can inflict unlimited damage on the system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你拥有了系统——我确实是指*拥有*它。考虑每一个按键；粗心大意可能会让你的硬盘恢复到未经格式化的原始状态，变成空旷的废土。而且，根密码要谨慎共享，如果需要分享，尽量少分享，因为任何拥有根密码的人都可以对系统造成无限的损害。
- en: Remember, only the users in the group *wheel* can use the root password to become
    root through su(1). Anyone can use the root password at the system console, which
    is why physical protection of your system is vital. If you give the root password
    to a regular user who doesn’t have physical access to the console, they can type
    `su` and enter the root password as many times as they want, and it still won’t
    work.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，只有在 *wheel* 组中的用户才能通过 su(1) 命令使用根密码成为 root。任何人都可以在系统控制台使用根密码，这也是为什么系统的物理保护至关重要。如果你把根密码交给一个没有物理访问控制台权限的普通用户，他们可以输入
    `su` 命令，并多次输入根密码，但仍然无法成功。
- en: This naturally leads to the question, “Who needs root access?” Much of the configuration
    discussed in this book requires use of the root password. Once you have the system
    running properly, you can greatly decrease or discontinue use of the root password.
    For those remaining tasks that absolutely require root privileges, I recommend
    the sudo package, and probably my book *Sudo Mastery* (Tilted Windmill Press,
    2013). One of the simplest ways to reduce the need for root access is through
    the proper use of groups.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这自然引出了一个问题：“谁需要 root 访问权限？”本书中讨论的许多配置都需要使用根密码。一旦系统正常运行，你可以大大减少或停止使用根密码。对于那些绝对需要
    root 权限的任务，我推荐使用 sudo 包，可能还需要我的书《Sudo Mastery》（Tilted Windmill Press, 2013）。减少对
    root 访问权限需求的最简单方法之一是通过正确使用用户组。
- en: '***Groups of Users***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用户组***'
- en: Unix-like operating systems classify users into *groups*, each group consisting
    of people who perform similar administrative functions. A sysadmin can define
    a group called *webmasters*, add the accounts of the people editing web pages
    to that group, and set the privileges on the web-related files so that the members
    of that group can edit those files. She can also create a group called *email*,
    add the email administrators to that group, and set the permissions of mail-related
    files accordingly. Using groups in this manner is a powerful and oft-neglected
    tool for system management.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 类 Unix 操作系统将用户分类为 *组*，每个组由执行相似管理职能的人员组成。系统管理员可以定义一个名为 *webmasters* 的组，将编辑网页的人员账户添加到该组，并设置与网页相关文件的权限，以便该组的成员可以编辑这些文件。她还可以创建一个名为
    *email* 的组，将电子邮件管理员添加到该组，并相应地设置邮件相关文件的权限。以这种方式使用组是系统管理中一个强大且常被忽视的工具。
- en: 'Any user can identify the groups she belongs to with id(1). The preceding example
    showed that the user root is in the groups wheel and operator. Root is a special
    user, however, and can do anything she pleases. Here’s my account, which is a
    little more realistic for an average user:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 任何用户都可以通过 id(1) 查明自己所属的组。前面的示例显示了用户 root 属于 *wheel* 和 *operator* 组。然而，root 是一个特殊用户，几乎可以做任何事。这是我的账户，更加贴近普通用户的实际情况：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'My UID is 1001, and my username is *mwlucas*. My GID, primary group ID, is
    1001, and my primary group is named *mwlucas* as well. This is all pretty standard
    for the first user on a system, and even in later users, the only thing that changes
    is the numbers assigned to the account and primary group. More interesting is
    what other groups I’m assigned to: in addition to my primary group, I’m in the
    groups wheel, dialer, and webmaster. Wheel members may use the root password to
    become root, dialer members may use tip(1) without becoming root, and webmaster
    members can edit the web files on the local system. Each of these groups has special
    privileges on my system, and as a member of those groups, I inherit those privileges.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 UID 是 1001，用户名是 *mwlucas*。我的 GID，即主组 ID，也是 1001，且我的主组名为 *mwlucas*。这是系统中第一个用户的标准配置，即使是在后续的用户中，唯一变化的是分配给账户和主组的数字。更有趣的是我被分配到的其他组：除了我的主组，我还属于
    *wheel*、*dialer* 和 *webmaster* 组。*wheel* 组的成员可以使用 root 密码成为 root，*dialer* 组的成员可以使用
    tip(1) 而无需成为 root，*webmaster* 组的成员可以编辑本地系统上的网页文件。这些组在我的系统上具有特殊权限，作为这些组的成员，我继承了这些权限。
- en: Group information is defined in */etc/group*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 组信息在 */etc/group* 中定义。
- en: '**/etc/group**'
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/etc/group**'
- en: 'The file */etc/group* contains all group information except for the user’s
    primary group (which is defined with the user account in */etc/master.passwd*).
    Each line in */etc/group* contains four colon-delimited fields: the group name,
    the group password, the group ID number, and a list of members.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 */etc/group* 包含所有组信息，除了用户的主组（该主组在 */etc/master.passwd* 中与用户账户一起定义）。*/etc/group*
    中的每一行包含四个由冒号分隔的字段：组名、组密码、组 ID 号码和成员列表。
- en: 'Here’s a sample entry:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例条目：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The group name is a human-friendly name for the group. This group is named *wheel*.
    Group names are arbitrary; you can call a group of users *lackeys* if you wish.
    Choose group names that give you an idea of what the groups are for; while you
    might remember that your lackeys may edit the company web page, will your coworkers
    understand that?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 组名是一个对人类友好的名称。这个组名为 *wheel*。组名是任意的；如果你愿意，可以把一组用户称为 *lackeys*。选择能够让你了解组别用途的组名；尽管你可能会记得你的
    *lackeys* 可能会编辑公司网页，但你的同事能理解这一点吗？
- en: The second field, the group password, was a great idea that turned out to be
    a security nightmare. Modern Unix-like systems don’t do anything with the group
    password, but the field remains because old programs expect to find something
    in this space. The asterisk is a placeholder to placate such software.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字段，组密码，是一个好主意，但结果变成了安全噩梦。现代类 Unix 系统不再对组密码做任何事情，但该字段仍然保留，因为旧程序期望在这个位置找到内容。星号是一个占位符，用来应付这些程序。
- en: The third field gives the group’s unique numeric group ID (GID). Many programs
    use the GID rather than name to identify a group. The wheel group has a GID of
    0, and the maximum GID is 65535.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个字段给出了组的唯一数字组 ID（GID）。许多程序使用 GID 而不是名称来识别组。*wheel* 组的 GID 为 0，最大 GID 为 65535。
- en: Last is a comma-delimited list of all users in the group. The users *root*,
    *mwlucas*, and *xistence* are members of the group wheel.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是一个由逗号分隔的所有组内用户的列表。用户 *root*、*mwlucas* 和 *xistence* 是 *wheel* 组的成员。
- en: '**Changing Group Memberships**'
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**更改组成员资格**'
- en: 'If you want to add a user to a group, add his username to the end of the line
    for that group. For example, the wheel group is the list of users that may use
    the root password. Here, I add *rwatson* to the wheel group:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将一个用户添加到某个组，只需要将该用户的用户名添加到该组的行末。例如，wheel 组是允许使用 root 密码的用户列表。这里，我将 *rwatson*
    添加到 wheel 组：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Mind you, the odds of me convincing rwatson (leading security researcher and
    ex–FreeBSD Foundation President) to assume sysadmin duties on any of my systems
    range from negligible to nonexistent, but it’s worth a try.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，我说服 rwatson（领先的安全研究员和前 FreeBSD 基金会主席）承担我任何系统的 sysadmin 职责的可能性几乎为零，但试试看还是值得的。
- en: '**Creating Groups**'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建组**'
- en: To create a new group, you need only a name for the group and a group ID number.
    Technically, you don’t even need a member for the group; some programs run as
    members of a group, and FreeBSD uses the group permissions to control those programs
    just as the users are controlled.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新组时，只需要一个组名和一个组 ID 号码。从技术上讲，你甚至不需要为该组指定成员；某些程序以组成员身份运行，FreeBSD 使用组权限来控制这些程序，就像控制用户一样。
- en: Traditionally, GIDs are assigned the next number up the list. GID is an arbitrary
    number between 0 and 65535\. Generally speaking, GIDs below 1000 are reserved
    for operating system usage. Programs that need a dedicated group ID usually use
    one in this range. User accounts start numbering their GIDs at 1001 and go up.
    Some special groups might start numbering at 65535 and go down.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，GID 是按列表顺序分配的下一个数字。GID 是一个介于 0 和 65535 之间的任意数字。一般来说，低于 1000 的 GID 保留给操作系统使用。需要专用组
    ID 的程序通常会使用这个范围内的号码。用户账户从 1001 开始分配 GID，并逐渐递增。一些特殊组可能从 65535 开始编号，并逐渐递减。
- en: '***Using Groups to Avoid Root***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用组来避免 root 权限***'
- en: In addition to being a security concern, the root password distribution policy
    can cause dissension in any organization. Many sysadmins refuse to share the root
    password with people who’re responsible for maintaining part of the system but
    don’t offer an alternative and thereby prevent people from doing their job. Other
    sysadmins hand out root to dang near anyone who wants it and then complain when
    the system becomes unstable. Both attitudes are untenable in the long run. Personally,
    I don’t want root on your system. While having root privileges can be convenient,
    a lack of responsibility when the system breaks is more convenient.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安全隐患外，root 密码的分发政策还可能导致组织内部的分歧。许多 sysadmins 拒绝与负责维护系统一部分的人共享 root 密码，但他们又不提供替代方案，从而阻止这些人完成工作。其他
    sysadmins 则几乎把 root 密码分发给任何想要的人，然后当系统变得不稳定时抱怨。两种态度从长远来看都是无法维持的。就我个人而言，我不希望你在我的系统上拥有
    root 权限。虽然拥有 root 权限很方便，但当系统崩溃时缺乏责任感更方便。
- en: One common situation is where a junior sysadmin is responsible for a particular
    portion of the system. I’ve had many DNS administrators work under me;^([2](footnote.xhtml#ch09fn2))
    these people don’t ever install software, recompile the kernel, or perform other
    sysadmin tasks. They only answer emails, update zone files, and reload the named
    daemon. New sysadmins often believe they need root access to do this sort of work.
    Nope. You can use groups.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的情况是，初级 sysadmin 负责系统的某一部分。我曾有很多 DNS 管理员在我下面工作；^([2](footnote.xhtml#ch09fn2))
    这些人从不安装软件、重新编译内核或执行其他 sysadmin 任务。他们只处理邮件、更新区域文件并重新加载 named 守护进程。新手 sysadmins
    通常认为他们需要 root 访问权限来做这些工作。其实不需要，你可以使用组权限。
- en: Establishing your own groups, consisting of people who perform similar administrative
    functions, lets you avoid distributing the root password and still allow people
    to do their work. In this section, we’ll implement group-level access control
    over nameserver files. The same principles apply to any files you choose to protect.
    Mail and web configuration files are other popular choices for group-based management.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你自己的组，由执行相似管理职能的人组成，可以避免分发 root 密码，同时仍然允许人们完成他们的工作。在本节中，我们将实现基于组的名称服务器文件访问控制。相同的原则也适用于你选择保护的任何文件。邮件和
    Web 配置文件是其他常见的组管理对象。
- en: '**System Accounts**'
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**系统账户**'
- en: FreeBSD reserves some user account names for integrated programs. We discuss
    these unprivileged accounts in [Chapter 19](ch19.xhtml#ch19). For example, the
    nameserver runs under the user account bind and the group bind. If an intruder
    compromises the nameserver, she can access the system only with the privileges
    of the user bind.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD为集成程序保留了一些用户账户名。我们将在[第19章](ch19.xhtml#ch19)讨论这些无特权账户。例如，nameserver在用户账户bind和组bind下运行。如果入侵者攻破了nameserver，她只能以bind用户的权限访问系统。
- en: Don’t have users log in as these users. They’re not set up as interactive accounts
    by design. What’s more, do not allow the group of the system account user to own
    the files created for that function. Create a separate user and group to own program
    files. That way, our hypothetical intruder can’t even edit the files used by the
    DNS server, further minimizing potential damage. If the program regularly updates
    the files (e.g., a database’s backend storage), you must give the program access
    rights, but chances are that a human being doesn’t ever need to edit that file.
    Similarly, there’s no reason a database should be able to edit its own configuration
    file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让用户以这些用户身份登录。它们设计上并不是作为交互账户的。而且，不要允许系统账户用户的组拥有为该功能创建的文件。创建一个单独的用户和组来拥有程序文件。这样，我们假设的入侵者甚至无法编辑DNS服务器使用的文件，从而进一步减少潜在的损害。如果程序定期更新这些文件（例如，数据库的后端存储），你必须给予程序访问权限，但人类通常不需要编辑这些文件。类似地，数据库也不应该能够编辑其自己的配置文件。
- en: '**Administrative Group Creation**'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**管理员组创建**'
- en: The simplest way to create a group that owns files is to employ adduser(8) to
    make a user that owns them and then to utilize that user’s primary group as the
    group for the files. Because we already have a user called *bind*, we’ll create
    an administrative user *dns*. The username isn’t important, but you should choose
    a name that everyone will recognize.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 创建拥有文件的组的最简单方法是使用adduser(8)创建一个拥有文件的用户，然后将该用户的主组作为文件的组。因为我们已经有了一个叫*bind*的用户，所以我们将创建一个名为*dns*的管理员用户。用户名并不重要，但你应该选择一个大家都能识别的名字。
- en: Give your administrative user a shell of *nologin*, which sets a shell of */sbin/nologin*.
    This prevents anyone from actually logging in as the administrative user.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 给你的管理员用户设置一个*nologin*的shell，这会将shell设置为*/sbin/nologin*。这样可以防止任何人实际以管理员用户身份登录。
- en: If you want, you could specify a particular UID and GID for these sorts of users.
    I’ve been known to choose UID and GID numbers that resemble those used by their
    related service accounts. For example, the user bind has a UID and GID of 53\.
    I could give the user dns a UID of 10053 to make it easily recognizable. At other
    times, I start numbering my administrative groups at 65535 and work my way down.
    It doesn’t matter as long as I’m completely consistent within an organization.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以为这些类型的用户指定特定的UID和GID。我有时会选择类似于其关联服务账户所使用的UID和GID号码。例如，用户bind的UID和GID都是53。我可以为用户dns指定UID为10053，这样就容易辨识了。其他时候，我会从65535开始为我的管理员组编号，然后逐渐向下。这并不重要，只要在一个组织内保持完全一致。
- en: Do not add this administrative user to any other groups. Under no circumstances
    add this user to a privileged group, such as wheel!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将这个管理员用户添加到任何其他组中。在任何情况下，都不要将这个用户添加到特权组中，例如wheel！
- en: Every user needs a home directory. For an administrative user, a home directory
    of */nonexistent* works well. This user’s files are elsewhere in the system, after
    all.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户都需要一个主目录。对于管理员用户，*/nonexistent* 的主目录非常合适。毕竟，这个用户的文件存储在系统的其他地方。
- en: Lastly, let adduser(8) disable the account. While the shell prevents logins,
    an extra layer of defense won’t hurt.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让adduser(8)禁用该账户。虽然shell已经阻止了登录，但额外的防御层总是有益的。
- en: Now that you have an administrative user and a group, you can assign ownership
    of files to that user. A user and a group own every file. You can see existing
    file ownership and permissions with `ls -l`. (If you’ve forgotten how Unix permissions
    work, read ls(1) and chmod(1).) Many sysadmins pay close attention to file owners,
    somewhat less attention to worldwide permissions, and only glance at the group
    permissions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个管理员用户和一个组，你可以将文件的所有权分配给该用户。每个文件都有一个用户和一个组。你可以使用`ls -l`查看现有的文件所有权和权限。（如果你忘记了Unix权限如何工作，可以阅读ls(1)和chmod(1)。）许多系统管理员非常关注文件所有者，对全局权限关注较少，只是匆匆看一下组权限。
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, I’ve created two files. The first file, *rndc.key*, can be read and written
    by the user *mwlucas*. It can be read by anyone in the group *mwlucas*, but no
    one else can do anything with it. The file *mwl.io.db* can be read or written
    by the user *mwlucas* or anyone in the group *mwlucas*, but others can only read
    the file. If you’re in the group *mwlucas*, you can edit the file *mwl.io.db*
    without becoming root.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我创建了两个文件。第一个文件，*rndc.key*，可以由用户*mwlucas*读取和写入。任何在*mwlucas*组中的人都可以读取它，但其他人无法操作它。文件*mwl.io.db*可以由用户*mwlucas*或任何在*mwlucas*组中的人读取或写入，但其他人只能读取该文件。如果你在*mwlucas*组中，你可以编辑文件*mwl.io.db*而不需要成为root用户。
- en: Change a file’s owner and group with chown(1). You must know the name of the
    user and group whose ownership you want to change. In this case, we want to change
    both files to be owned by the user dns and the group dns.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用chown(1)更改文件的所有者和组。你必须知道你想更改所有权的用户和组的名称。在这种情况下，我们要将两个文件的所有权都更改为用户dns和组dns。
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These files are now owned by the user dns and the group dns. Anyone who is in
    the group dns can edit *mwl.io.db* without using the root password. Finally, this
    file can be read by the user bind, who runs the nameserver. Add your DNS administrators
    to the dns group in */etc/group*, and abruptly they can do their jobs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件现在由用户dns和组dns拥有。任何在dns组中的人都可以编辑*mwl.io.db*而不需要使用root密码。最后，这个文件可以被运行nameserver的用户bind读取。将你的DNS管理员添加到*/etc/group*中的dns组，然后他们就可以执行他们的工作了。
- en: The DNS administrators might think they need the root password for restarting
    the nameserver program itself. However, this is easily managed with rndc(8). Other
    tasks can be managed with cron jobs or with the add-on program sudo(8).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: DNS管理员可能认为他们需要root密码来重新启动nameserver程序。然而，这可以通过rndc(8)轻松管理。其他任务可以通过cron作业或附加程序sudo(8)来管理。
- en: If you don’t want an administrative user but only a group, use vigr(8) to edit
    */etc/group*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要一个组而不是一个管理员用户，可以使用vigr(8)编辑*/etc/group*。
- en: '**Interesting Default Groups**'
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**有趣的默认组**'
- en: FreeBSD ships with several default groups. Most are used by the system and aren’t
    of huge concern to a sysadmin—you should know that they’re there, but that’s different
    than working with them on a day-to-day basis. In [Table 9-1](ch09.xhtml#ch09tab1),
    I present for your amusement and edification the most useful, interesting, and
    curious of the default groups. Adding your own groups simplifies system administration,
    but the groups listed here are available on every FreeBSD system.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD随附了几个默认组。大多数由系统使用，对系统管理员来说并不是特别重要——你应该知道它们的存在，但这与每天与它们打交道是两回事。在[表 9-1](ch09.xhtml#ch09tab1)中，我为你的娱乐和启发展示了最有用、有趣和令人好奇的默认组。添加你自己的组可以简化系统管理，但这里列出的组在每个FreeBSD系统上都可用。
- en: '**Table 9-1:** FreeBSD System Groups'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1：** FreeBSD系统组'
- en: '| **Group name** | **Purpose** |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| **组名** | **用途** |'
- en: '| --- | --- |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| audit | Users who can access audit(8) information |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| audit | 可以访问audit(8)信息的用户 |'
- en: '| authpf | Users who can authenticate to the PF packet filter |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| authpf | 可以通过PF数据包过滤器进行身份验证的用户 |'
- en: '| bin | Group owner of general system programs |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| bin | 一般系统程序的组所有者 |'
- en: '| bind | Group for the BIND DNS server software |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| bind | BIND DNS服务器软件的组 |'
- en: '| daemon | Used by various system services, such as the printing system |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| daemon | 用于各种系统服务，如打印系统 |'
- en: '| _dhcp | DHCP client operations |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| _dhcp | DHCP客户端操作 |'
- en: '| dialer | Users who can access serial ports; useful for modems and tip(1)
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| dialer | 可以访问串口的用户；对于调制解调器和tip(1)非常有用 |'
- en: '| games | Owner of game files |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| games | 游戏文件的所有者 |'
- en: '| guest | System guests (almost never used) |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| guest | 系统访客（几乎不使用） |'
- en: '| hast | Files used by hastd(8) |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| hast | 被hastd(8)使用的文件 |'
- en: '| kmem | Programs that can access kernel memory, such as fstat(1), netstat(1),
    and so on |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| kmem | 可以访问内核内存的程序，如fstat(1)、netstat(1)等 |'
- en: '| mail | Owner of the mail system |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| mail | 邮件系统的所有者 |'
- en: '| mailnull | Default group for sendmail(8) or other mail server |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| mailnull | sendmail(8)或其他邮件服务器的默认组 |'
- en: '| man | Owner of uncompressed man pages |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| man | 拥有未压缩man页面的用户 |'
- en: '| network | Owner of network programs like ppp(8) |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| network | 拥有像ppp(8)这样的网络程序的用户 |'
- en: '| news | Owner of the Usenet News software (probably not installed) |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| news | 拥有Usenet新闻软件的用户（可能未安装） |'
- en: '| nobody | Primary group for unprivileged user nobody, intended for use by
    NFS |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| nobody | 为无特权用户nobody设置的主组，供NFS使用 |'
- en: '| nogroup | Group with no privileges, intended for use by NFS |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| nogroup | 没有特权的组，供NFS使用 |'
- en: '| operator | Users that can access drives, generally for backup purposes |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| operator | 可以访问驱动器的用户，通常用于备份目的 |'
- en: '| _pflogd | Group for PF logging |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| _pflogd | PF 日志记录组 |'
- en: '| proxy | Group for FTP proxy in PF packet filter |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| proxy | FTP 代理组，位于 PF 数据包过滤器中 |'
- en: '| smmsp | Group for Sendmail submissions |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| smmsp | Sendmail 提交的组 |'
- en: '| sshd | Owner of the SSH server (see [Chapter 20](ch20.xhtml#ch20)) |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| sshd | SSH 服务器的所有者（参见 [第 20 章](ch20.xhtml#ch20)） |'
- en: '| staff | System administrators (from BSD’s college roots, when users were
    staff, faculty, or students) |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| staff | 系统管理员（来自 BSD 的大学根源，当时用户是职员、教职工或学生） |'
- en: '| sys | Another system group |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| sys | 另一个系统组 |'
- en: '| tty | Programs that can write to terminals, like wall(1) |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| tty | 可以写入终端的程序，如 wall(1) |'
- en: '| unbound | Files and programs related to the unbound(8) DNS server |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| unbound | 与 unbound(8) DNS 服务器相关的文件和程序 |'
- en: '| uucp | Group for programs related to the Unix-to-Unix Copy Protocol |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| uucp | 与 Unix 到 Unix 复制协议相关的程序组 |'
- en: '| video | Group that can access DRM and DRI video devices |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| video | 可以访问 DRM 和 DRI 视频设备的组 |'
- en: '| wheel | Users who may use the root password |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| wheel | 可以使用 root 密码的用户 |'
- en: '| www | Web server programs (not files) |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| www | 网站服务器程序（不是文件） |'
- en: '| _ypldap | Files needed by the LDAP-backed YP server ypldap(8) |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| _ypldap | LDAP 支持的 YP 服务器 ypldap(8) 所需的文件 |'
- en: I know very few people using either internet news or UUCP, and you might think
    you could reuse those groups for other purposes. You’re really better off creating
    a new group than risking confusion later, however. Group ID numbers are not in
    short supply.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道很少有人使用互联网新闻或 UUCP，你可能认为可以将这些组重用于其他目的。然而，实际上创建一个新的组会比以后引起混淆更好。组 ID 号码并不短缺。
- en: '**Tweaking User Security**'
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**调整用户安全性**'
- en: You prevent any single user from utilizing too much memory, processor time,
    or other system resources by setting limits on the account. Now that even small
    computers have very fast processors and lots of memory, these limits aren’t as
    important, but it’s still very useful in systems with dozens or hundreds of users.
    You can also control where users may log in from.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置账户的限制，你可以防止任何单个用户使用过多的内存、处理器时间或其他系统资源。现在即使是小型计算机也有非常快的处理器和大量的内存，这些限制不再那么重要，但在有数十或数百个用户的系统中，这仍然非常有用。你还可以控制用户可以从哪里登录。
- en: '***Restricting Login Ability***'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***限制登录能力***'
- en: FreeBSD checks */etc/login.access* every time a user tries to log in. If *login.access*
    contains rules that forbid logins from that user, the login attempt fails immediately.
    This file has no rules by default, meaning that anyone who provides a valid username
    and password has no restrictions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 每次用户尝试登录时都会检查 */etc/login.access*。如果 *login.access* 中包含禁止该用户登录的规则，登录尝试会立即失败。默认情况下，该文件没有规则，这意味着提供有效用户名和密码的任何人都没有任何限制。
- en: The */etc/login.access* file has three colon-delimited fields. The first either
    grants (`+`) or denies (`-`) the right to log in; the second is a list of users
    or groups; and the third is a list of connection sources. You can use an `ALL`
    or `ALL EXCEPT` syntax, which allows you to make simple but expressive rules.
    Rules are checked on a first-fit basis. When login(1) finds a rule where the user
    and the connection source match, the connection is immediately accepted or rejected,
    making rule order vital. The default is to allow logins.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/login.access* 文件有三个由冒号分隔的字段。第一个字段表示授予（`+`）或拒绝（`-`）登录权限；第二个字段是用户或用户组的列表；第三个字段是连接源的列表。你可以使用
    `ALL` 或 `ALL EXCEPT` 语法，这让你可以创建简单但表达力强的规则。规则按先到先得的方式检查。当 login(1) 找到一个用户和连接源匹配的规则时，连接会立即被接受或拒绝，因此规则的顺序非常重要。默认情况下允许登录。'
- en: 'For example, to allow only members of the wheel group to log in from the system
    console, you might try this rule:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要仅允许 wheel 组的成员从系统控制台登录，你可以尝试以下规则：
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The problem with this rule, however, is that it doesn’t actually deny users
    login privileges. Since the default is to accept logins, and since all this rule
    does is explicitly grant login privileges to the users in the wheel group, nothing
    changes. Bert certainly isn’t in the wheel group, but if he tries to log in, no
    rule denies him access.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这条规则的问题在于它实际上并没有拒绝用户的登录权限。由于默认情况下接受登录，而这条规则只是明确地授予 wheel 组中的用户登录权限，所以没有任何变化。Bert
    肯定不在 wheel 组中，但如果他尝试登录，没有规则会拒绝他访问。
- en: 'You could try two rules like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试两个像这样的规则：
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This set of rules would achieve the desired effect but is longer than you need.
    Use `ALL EXCEPT` instead.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这组规则可以实现预期的效果，但比你需要的要长。改用 `ALL EXCEPT` 会更简洁。
- en: '[PRE19]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This rule rejects unwanted logins most quickly and runs less risk of administrator
    error. As a rule, it’s best to build *login.access* lists by rejecting logins,
    rather than permitting them. FreeBSD immediately rejects nonwheel users at the
    console upon hitting this rule.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则可以最快地拒绝不需要的登录，并且管理员出错的风险较小。作为一种规则，最好通过拒绝登录而不是允许它们来构建 *login.access* 列表。FreeBSD
    在遇到此规则时会立即拒绝非 wheel 用户在控制台上的登录。
- en: Change the default from “allow access” to “deny access” by adding a final rule.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加最后一条规则，将默认设置从“允许访问”更改为“拒绝访问”。
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Any login request that doesn’t match an earlier permit rule gets denied.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不匹配之前允许规则的登录请求都会被拒绝。
- en: The last field in *login.access*, the connection source, can use hostnames,
    host addresses, network numbers, domain names, or the special values `LOCAL` and
    `ALL`. Let’s see how they work.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*login.access* 中的最后一个字段——连接源，可以使用主机名、主机地址、网络号、域名或特殊值 `LOCAL` 和 `ALL`。让我们来看看它们是如何工作的。'
- en: '**Hostnames**'
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**主机名**'
- en: 'Hostnames rely upon DNS or the hosts file. If you suspect that your nameserver
    might suffer an intrusion or attack, avoid hostnames; intruders can give a hostname
    any IP address that they like and fool your system into accepting the connection,
    and a nameserver failure could lock you out completely. Still, it’s possible to
    use a rule like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 主机名依赖于 DNS 或 hosts 文件。如果你怀疑你的域名服务器可能遭受入侵或攻击，避免使用主机名；入侵者可以将任何 IP 地址绑定到主机名，从而欺骗你的系统接受连接，且域名服务器故障可能会完全锁定你。尽管如此，仍然可以使用像这样的规则：
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Users in the wheel group can log in from the fileserver, but nobody else can.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 属于 wheel 组的用户可以从文件服务器登录，但其他人不能。
- en: '**Host Addresses and Networks**'
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**主机地址和网络**'
- en: Host addresses work like hostnames, but they’re immune to DNS failures or spoofing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 主机地址的工作方式与主机名类似，但它们不受 DNS 故障或欺骗的影响。
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A network number is a truncated IP address, like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 网络号是一个截断的 IP 地址，像这样：
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This network number allows anyone in the wheel group to log in from a machine
    whose IP address begins with 203.0.113 and denies everyone else access from those
    IP addresses.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网络号允许任何在 wheel 组中的用户从 IP 地址以 203.0.113 开头的机器上登录，并拒绝其他所有来自这些 IP 地址的访问。
- en: '**LOCAL**'
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**LOCAL**'
- en: The most complicated location is `LOCAL`, which matches any hostname without
    a dot in it (generally, only hosts in the local domain). For example, *[www.mwl.io](http://www.mwl.io)*
    thinks that any machine in the domain *mwl.io* matches `LOCAL`. DNS spoofing can
    easily evade this filter. Although my desktop claims that it has a hostname of
    *storm.mwl.io*, its IP address has reverse DNS that claims it’s somewhere in my
    cable modem provider’s network. The host *[www.mwl.io](http://www.mwl.io)* thinks
    that my desktop isn’t in the same domain and hence isn’t local. As such, I can’t
    use the `LOCAL` verification method.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最复杂的匹配是 `LOCAL`，它匹配任何没有点号的主机名（通常只有本地域的主机）。例如，* [www.mwl.io](http://www.mwl.io)
    * 认为任何位于 *mwl.io* 域中的机器都匹配 `LOCAL`。DNS 欺骗很容易绕过这个过滤器。尽管我的桌面声称它的主机名是 *storm.mwl.io*，但它的
    IP 地址有反向 DNS 记录，声称它位于我的有线调制解调器提供商的网络中。主机 *[www.mwl.io](http://www.mwl.io)* 认为我的桌面不在同一个域，因此不是本地的。因此，我不能使用
    `LOCAL` 验证方法。
- en: Similarly, anyone who owns a block of IP addresses can give their addresses
    any desired reverse DNS. The `LOCAL` restriction is best avoided.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，任何拥有 IP 地址块的人都可以给他们的地址设置任意所需的反向 DNS。最好避免使用 `LOCAL` 限制。
- en: '**ALL and ALL EXCEPT**'
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**ALL 和 ALL EXCEPT**'
- en: '`ALL` matches everything, and `ALL EXCEPT` matches everything but what you
    specify. These are the most useful connection sources, in my opinion. For example,
    if you had a highly secure machine only accessible from a couple of management
    workstations, you could have a rule like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALL` 匹配所有内容，`ALL EXCEPT` 匹配除了你指定的内容以外的所有内容。根据我的观点，这些是最有用的连接源。例如，如果你有一台仅可从几个管理工作站访问的高安全性机器，你可以有这样一条规则：'
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Tie It All Together**'
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将一切联系在一起**'
- en: 'The point of these rules is to build a login policy that matches your real-world
    policies. If you provide generic services but only allow your system administrators
    to log on remotely, a one-line *login.access* prevents any other users from logging
    in:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则的目的是构建一个符合你现实世界策略的登录政策。如果你提供通用服务，但只允许系统管理员远程登录，那么一行 *login.access* 就可以防止其他任何用户登录：
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is great if you can live with a restriction this tight. On the other hand,
    I’ve worked at several internet service providers that used FreeBSD to provide
    client services. Lowly customers weren’t allowed to log onto the servers unless
    they had a shell account. System administrators could log in remotely, as could
    the DNS and web teams (members of the dns and webmasters groups). Only sysadmins
    could log onto the console, however.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能忍受这样严格的限制，这很好。另一方面，我曾在几家使用FreeBSD提供客户端服务的互联网服务提供商工作。普通客户如果没有Shell账户，就不能登录到服务器。系统管理员可以远程登录，DNS和Web团队成员（属于dns和webmasters组）也可以。只有系统管理员才能登录到控制台。
- en: '[PRE26]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Set this up in *login.access* once, and let group membership control all of
    your remote logins forever after.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在*login.access*中设置一次，然后让组成员身份控制所有远程登录。
- en: '***Restricting System Usage***'
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***限制系统使用***'
- en: You can provide more specific controls with login classes. Login classes, managed
    through */etc/login.conf*, define the resources and information provided for users.
    Each user is assigned a class, and each class has limits on the system resources
    available. When you change the limits on a class, all users get the new limits
    when they next log in. Set a user’s class when creating the user account, or change
    it later with chpass(1).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过登录类提供更具体的控制。通过*/etc/login.conf*管理的登录类，定义了为用户提供的资源和信息。每个用户都会被分配一个类，每个类对可用的系统资源有限制。当你更改类的限制时，所有用户在下次登录时都会获得新的限制。在创建用户账户时设置用户的类，或者通过chpass(1)稍后更改。
- en: '**Class Definitions**'
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**类定义**'
- en: The default *login.conf* starts with the default class, the class used by accounts
    without any other class. This class gives the user basically unlimited access
    to system resources and is suitable for application servers with a limited number
    of users. If this meets your needs, don’t adjust the file at all.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的*login.conf*从默认类开始，这是没有其他类的账户所使用的类。这个类基本上给用户提供了对系统资源的无限访问权限，适用于用户数量有限的应用服务器。如果这符合你的需求，则无需调整文件。
- en: 'Each class definition consists of a series of variable assignments that define
    the user’s resource limits, accounting, and environment. Each variable assignment
    in the class definition begins and ends with a colon. The backslash character
    is a continuation character to indicate that the class continues on the next line,
    which makes the file more readable. Here’s a sample of the beginning of one class:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类定义由一系列变量赋值组成，定义用户的资源限制、计费和环境。类定义中的每个变量赋值以冒号开始和结束。反斜杠字符是一个续行字符，用来表示类在下一行继续，从而使文件更易读。以下是一个类开头的示例：
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This class is called `default` ➊. I’ve shown three of the dozens of variables
    in this class. The variable `passwd_format` ➋, for example, is set to `sha512`
    ➌. These variable assignments and the class name describe the class, and you can
    change the user’s experience on the system by assigning the user to another class.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类被称为`default` ➊。这里展示了这个类中的几个变量中的三个。例如，变量`passwd_format` ➋被设置为`sha512` ➌。通过这些变量赋值和类名，描述了该类，你可以通过将用户分配到另一个类来改变用户在系统上的体验。
- en: Some of *login.conf* ’s variables don’t have a value and instead change account
    behavior just by being present. For example, the `requirehome` variable takes
    effect just by being included in the class. If this value is present, the user
    must have a valid home directory.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*login.conf*中的某些变量没有值，而是通过存在来改变账户行为。例如，`requirehome`变量仅通过在类中出现就生效。如果该值存在，用户必须有一个有效的主目录。'
- en: '[PRE28]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After editing *login.conf*, you must update the login database to make the changes
    take effect.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑*login.conf*后，必须更新登录数据库以使更改生效。
- en: '[PRE29]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This rebuilds the database file */etc/login.conf.db* that’s used for fast lookups,
    much like */etc/spwd.db*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这会重建用于快速查找的数据库文件*/etc/login.conf.db*，类似于*/etc/spwd.db*。
- en: The default */etc/login.conf* includes several example classes of users. If
    you want an idea of what sort of restrictions to put on users for various situations,
    check those examples. The following section offers ideas about what can be set
    in a login class. For a complete listing of supported settings in your version
    of FreeBSD, read man login.conf(5).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的*/etc/login.conf*包括几个用户的示例类。如果你想知道在各种情况下应该对用户施加什么样的限制，可以查看这些示例。接下来的部分提供了关于可以在登录类中设置内容的想法。要查看你使用的FreeBSD版本中支持的完整设置列表，请阅读man
    login.conf(5)。
- en: '**Resource Limits**'
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**资源限制**'
- en: Resource limits allow you to control how much of the system any one user can
    monopolize at any one time. If you have several hundred users logged in to one
    machine and one of those users decides to compile LibreOffice, that person will
    consume far more than his fair share of processor time, memory, and I/O. By limiting
    the resources one user can monopolize, you can make the system more responsive
    for all users.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 资源限制允许你控制任何一个用户在任何时刻可以独占系统的多少资源。如果你有几百个用户登录到一台机器，而其中一个用户决定编译 LibreOffice，那么这个用户将占用远超过他应得的处理器时间、内存和
    I/O 资源。通过限制一个用户可以独占的资源，你可以让系统对所有用户更具响应性。
- en: Table 9-2 defines the resource-limiting *login.conf* variables.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-2 定义了资源限制的 *login.conf* 变量。
- en: '**Table 9-2:** Some *login.conf* Variables for Limiting Resource Use'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-2：** 一些 *login.conf* 变量用于限制资源使用'
- en: '| **Variable** | **Description** |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **变量** | **描述** |'
- en: '| --- | --- |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `cputime` | The maximum CPU time any one process may use |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `cputime` | 单个进程可以使用的最大 CPU 时间 |'
- en: '| `filesize` | The maximum size of any one file |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `filesize` | 任意一个文件的最大大小 |'
- en: '| `datasize` | The maximum memory size of data that can be consumed by one
    process |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `datasize` | 一个进程可以消耗的最大数据内存大小 |'
- en: '| `stacksize` | The maximum amount of stack memory usable by a process |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `stacksize` | 进程可使用的最大栈内存量 |'
- en: '| `coredumpsize` | The maximum size of a core dump |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `coredumpsize` | 核心转储的最大大小 |'
- en: '| `memoryuse` | The maximum amount of memory a process can lock |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `memoryuse` | 一个进程可以锁定的最大内存量 |'
- en: '| `maxproc` | The maximum number of processes the user can have running |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `maxproc` | 用户可以运行的最大进程数 |'
- en: '| `openfiles` | The maximum number of open files per process |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `openfiles` | 每个进程可以打开的最大文件数 |'
- en: '| `Sbsize` | The maximum socket buffer size a user’s application can set |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `Sbsize` | 用户应用程序可以设置的最大套接字缓冲区大小 |'
- en: Note that resource limits are frequently set per process. If you permit each
    process 200MB of RAM and allow each user 40 processes, you’ve just allowed each
    user about 8GB of memory. Perhaps your system has a lot of memory, but does it
    really have that much?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，资源限制通常是按进程设置的。如果你为每个进程允许 200MB 的内存，并允许每个用户有 40 个进程，那么你实际上给每个用户提供了大约 8GB
    的内存。也许你的系统有很多内存，但它真的有这么多吗？
- en: '**Current and Maximum Resource Limits**'
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**当前和最大资源限制**'
- en: In addition to the limits listed previously, you can specify current and maximum
    resource limits. *Current* limits are advisory, and the user can override them
    at will. This works well on a cooperative system, where multiple users willingly
    share resources but you want to notify those users who exceed the standard resource
    allocation. Many users want to be good citizens, and readily cooperate when they’re
    told they’re pushing their limits.^([3](footnote.xhtml#ch09fn3)) Users cannot
    exceed *maximum* limits.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面列出的限制外，你还可以指定当前和最大资源限制。*当前*限制是建议性的，用户可以根据需要覆盖它们。这在一个合作系统中效果良好，在这个系统中，多个用户自愿共享资源，但你希望通知那些超过标准资源分配的用户。许多用户希望做一个好公民，当被告知他们接近资源限制时，他们会愿意配合。^([3](footnote.xhtml#ch09fn3))
    用户不能超过*最大*限制。
- en: If you don’t specify a limit as current or maximum, FreeBSD treats it as a maximum
    limit.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定资源限制为当前或最大值，FreeBSD 将其视为最大限制。
- en: 'To specify a current limit, add `-cur` to the variable name. To make a maximum
    limit, add `-max`. For example, to set a current and a maximum limit on the number
    of processes the user can have, use this input:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定当前限制，可以在变量名后加上 `-cur`。要设置最大限制，可以加上 `-max`。例如，要设置用户可以拥有的进程数量的当前和最大限制，使用以下输入：
- en: '[PRE30]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: One counterpart to resource limits is resource accounting. These days, accounting
    isn’t as important as it was when today’s inexpensive computers would cost millions
    of dollars, so we won’t discuss it in this book. It’s more important to restrict
    a single user from consuming your system than to bill for every CPU cycle someone
    uses. You should know that the capability exists, however.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 资源限制的一个对应概念是资源核算。如今，核算的重要性已经不如过去，当时今天这种便宜的计算机价格可能高达几百万美元，因此我们在本书中不会讨论它。现在，限制单个用户占用系统资源比为每个
    CPU 周期计费更为重要。然而，你应该知道这种功能是存在的。
- en: If you need more complicated resource restrictions, investigate rctl(8).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更复杂的资源限制，调查 rctl(8)。
- en: '**Class Environment**'
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**类别环境**'
- en: You can also define environment settings in */etc/login.conf*. This can work
    better than setting them in the default *.cshrc* or *.profile* because *login.conf*
    settings affect all user accounts immediately upon their next login. Some shells,
    such as zsh(1), don’t read either of these configuration files, so using a class
    environment sets the proper environment variables for those users.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 */etc/login.conf* 中定义环境设置。与在默认的 *.cshrc* 或 *.profile* 中设置它们相比，这种方法通常更有效，因为
    *login.conf* 设置会立即影响所有用户账户，下次登录时生效。某些 shell，如 zsh(1)，不会读取这些配置文件，因此使用类环境可以为这些用户设置正确的环境变量。
- en: 'All of the environment fields recognize two special characters. A tilde (`~`)
    represents the user’s home directory, while a cash symbol (`$`) represents the
    username. Here are a few examples from the default class that illustrate this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 所有环境字段都识别两个特殊字符。波浪线（`~`）表示用户的主目录，而美元符号（`$`）表示用户名。以下是一些来自默认类的示例，说明了这一点：
- en: '[PRE31]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: By using the `$` character, the environment variable `MAIL` is set to */var/mail/<username>*
    ➊. Similarly, the last directory in the `PATH` variable is the *bin* subdirectory
    in the user’s home directory ➋.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `$` 字符，环境变量 `MAIL` 被设置为 */var/mail/<username>* ➊。类似地，`PATH` 变量中的最后一个目录是用户主目录中的
    *bin* 子目录 ➋。
- en: Table 9-3 lists some common *login.conf* environment settings.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-3 列出了常见的 *login.conf* 环境设置。
- en: '**Table 9-3:** Common *login.conf* Environment Settings'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-3：** 常见的 *login.conf* 环境设置'
- en: '| **Variable** | **Description** |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| **变量** | **描述** |'
- en: '| --- | --- |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `hushlogin` | If present, no system information is given out during login.
    |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `hushlogin` | 如果存在，则在登录时不会显示系统信息。 |'
- en: '| `ignorenologin` | If present, these users can log in even when */var/run/nologin*
    exists. |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `ignorenologin` | 如果存在，即使 */var/run/nologin* 存在，用户仍然可以登录。 |'
- en: '| `manpath` | A list of directories for the `$MANPATH` environment variable.
    |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `manpath` | `$MANPATH` 环境变量的目录列表。 |'
- en: '| `nologin` | If present, the user cannot log in. |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `nologin` | 如果存在，用户无法登录。 |'
- en: '| `path` | A list of directories for the `$PATH` environment variable. |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `path` | `$PATH` 环境变量的目录列表。 |'
- en: '| `priority` | Priority (nice) for the user’s processes (see [Chapter 21](ch21.xhtml#ch21)).
    |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `priority` | 用户进程的优先级（nice）（参见[第 21 章](ch21.xhtml#ch21)）。 |'
- en: '| `requirehome` | User must have a valid home directory to log in. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `requirehome` | 用户必须拥有有效的主目录才能登录。 |'
- en: '| `setenv` | A comma-separated list of environment variables and their values.
    |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `setenv` | 用逗号分隔的环境变量及其值列表。 |'
- en: '| `shell` | The full path of a shell to be executed upon login. This overrides
    the shell in */etc/master.passwd*. The user’s `$SHELL`, however, contains the
    shell from the password file, resulting in an inconsistent environment. Playing
    games with this is an excellent way to annoy your users. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `shell` | 登录时要执行的 shell 的完整路径。此设置会覆盖 */etc/master.passwd* 中的 shell。用户的 `$SHELL`
    包含密码文件中的 shell，从而导致环境不一致。对这个设置进行操作是惹恼用户的好方法。 |'
- en: '| `term` | The default terminal type. Just about anything that tries to set
    a terminal type overrides this. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `term` | 默认的终端类型。几乎任何试图设置终端类型的操作都会覆盖此设置。 |'
- en: '| `timezone` | The default value of the `$TZ` environment variable. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `timezone` | `$TZ` 环境变量的默认值。 |'
- en: '| `umask` | Initial umask setting; should always start with 0, see builtin(1).
    |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `umask` | 初始的 umask 设置；应该始终以 0 开头，参见 builtin(1)。 |'
- en: '| `welcome` | Path to the login welcome message, usually */etc/motd*. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `welcome` | 登录欢迎信息的路径，通常是 */etc/motd*。 |'
- en: Remember, changes to a class affect all users in that class. If a user needs
    a change from the class settings, you’ll need to change their class.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，类的更改会影响该类中的所有用户。如果用户需要不同于类设置的更改，则需要更改其所属的类。
- en: '**Password and Login Control**'
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**密码和登录控制**'
- en: 'Unlike the environment settings, many of which can be set in places other than
    the login class, most login and authentication options can be controlled only
    from the login class. Here are some common authentication options:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 与环境设置不同，很多设置可以在登录类以外的地方配置，大多数登录和认证选项只能在登录类中控制。以下是一些常见的认证选项：
- en: passwd_format
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: passwd_format
- en: This option sets the cryptographic hash used to store passwords in */etc/master.passwd*.
    The default is `sha512`, for SHA512 hashing. Other permissible options are `des`
    (DES), `blf` (Blowfish), `md5`, and `sha256` (SHA256). DES and Blowfish are most
    useful when you want to share password files between different Unix-like operating
    systems, but are very weak. SHA256 is for compatibility with older password files,
    from before SHA512 was the default.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项设置用于存储密码的加密哈希算法，存储在*/etc/master.passwd*中。默认值是`sha512`，用于SHA512哈希。其他允许的选项有`des`（DES）、`blf`（Blowfish）、`md5`和`sha256`（SHA256）。DES和Blowfish在需要在不同的类Unix操作系统之间共享密码文件时非常有用，但它们的安全性较弱。SHA256则是为了与较旧的密码文件兼容，这些文件在SHA512成为默认值之前使用。
- en: mixpasswordcase
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: mixpasswordcase
- en: If present, FreeBSD complains if the user changes his password to an all-lowercase
    word. Despite the name, all-uppercase passwords satisfy this option.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了此选项，FreeBSD会警告用户如果他将密码更改为全小写的单词。尽管名称如此，但全大写的密码也符合此选项的要求。
- en: host.allow, host.deny
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: host.allow, host.deny
- en: These values let users in this class use rlogin and rsh. Avoid them like the
    fuzzy green meat your creepy roommate tried to feed you that one time.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值允许该类用户使用rlogin和rsh。像你那次被怪异的室友强行喂的模糊绿色肉一样，尽量避免使用它们。
- en: times.allow
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: times.allow
- en: 'This option allows you to schedule when users may log in with a comma-delimited
    list of days and times. Days are given as the first two letters of the day’s name
    (Su, Mo, Tu, We, Th, Fr, and Sa). Time is in standard 24-hour format. For example,
    if a user can log in only on Wednesdays between 8 AM and 5 PM, you’d use this
    entry:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项允许您安排用户何时可以登录，使用逗号分隔的日期和时间列表。日期使用星期几的前两个字母表示（Su、Mo、Tu、We、Th、Fr和Sa）。时间采用标准24小时制。例如，如果用户只能在周三的上午8点到下午5点之间登录，则使用以下条目：
- en: '[PRE32]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: times.deny
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: times.deny
- en: This option allows you to specify a time window when the user can’t log in.
    Note that this does not kick off users who are already logged in. The format is
    the same as for `times.allow`. If `times.allow` and `times.deny` overlap, `times.deny`
    takes precedence.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项允许您指定用户无法登录的时间窗口。请注意，这不会强制已登录的用户退出。格式与`times.allow`相同。如果`times.allow`和`times.deny`时间重叠，则`times.deny`优先。
- en: You can’t make that overworking developer go home, but you can keep him from
    opening another terminal window.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法让那个过度工作的开发者回家，但你可以防止他再打开一个终端窗口。
- en: '**File Flags**'
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文件标志**'
- en: All Unix-like operating systems have the same filesystem permissions, assigning
    read, write, and execute privileges for a file to the file’s owner, its group,
    and all others. FreeBSD extends the permissions scheme with *file flags*, which
    work with permissions to enhance your system’s security.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类Unix操作系统都具有相同的文件系统权限，为文件的所有者、其所属组以及所有其他用户分配读取、写入和执行权限。FreeBSD通过*文件标志*扩展了权限机制，这些标志与权限一起工作，以增强系统的安全性。
- en: Many flags have different effects depending on the system securelevel, which
    we’ll cover in the next section. Understanding securelevels requires an understanding
    of file flags, while file flags rely on securelevels. For the moment, just nod
    and smile when you encounter a mention of securelevels; all becomes clear in the
    next few pages.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 许多标志的效果会根据系统的securelevel级别不同而有所不同，我们将在下一节中讨论。理解securelevel需要对文件标志的了解，而文件标志又依赖于securelevel。现在，只需在遇到securelevel时点点头微笑，接下来的几页将让一切变得清晰。
- en: A few file flags are useful only in specialized cases. We’ll look only at the
    most commonly useful flags. See chflags(1) for the complete list.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文件标志仅在特殊情况下有用。我们将只讨论最常用的标志。请参阅chflags(1)获取完整列表。
- en: Many flags have multiple names; while only one name appears in ls(1) output,
    you can use any name at the command line. These alternate names exist because
    people got tired of getting an error when they typed `sapp`e`nd` instead of `sappnd`.
    Here, I show the flag’s primary name first and then the user-friendly aliases.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 许多标志有多个名称；虽然在ls(1)的输出中只会显示一个名称，但你可以在命令行中使用任何名称。出现这些替代名称是因为人们在键入`sapp`e`nd`时，不希望出现错误，而他们本来是想键入`sappnd`。在这里，我首先展示标志的主要名称，然后是更易于理解的别名。
- en: sappnd, sappend
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: sappnd, sappend
- en: This system-level, append-only flag can be set only by root. Files with this
    flag can be added to but can’t be removed or otherwise edited. This flag is particularly
    useful for log files. Setting `sappnd` on a user’s *.history* file can be interesting
    if the account is compromised. Since a common intruder tactic is to remove *.history*
    or symlink it to */dev/null* so that the admin can’t see what happened, `sappnd`
    ensures that script kiddies cannot cover their tracks in this manner. It’s almost
    funny to review the record of someone trying to remove a `sappnd` file; you can
    almost see the attacker’s frustration grow as he tries various methods.^([4](footnote.xhtml#ch09fn4))
    This flag can’t be removed when the system is running at securelevel 1 or higher.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统级的追加-only 标志只能由 root 设置。带有此标志的文件可以被追加，但不能被删除或以其他方式编辑。这个标志对于日志文件尤其有用。如果一个用户的
    *.history* 文件设置了 `sappnd`，并且该帐户被入侵，情况会变得很有趣。由于一个常见的入侵者策略是删除 *.history* 文件或将其符号链接到
    */dev/null*，以便管理员无法看到发生了什么，`sappnd` 确保了脚本小子无法通过这种方式抹去痕迹。回顾一个尝试删除 `sappnd` 文件的记录几乎是有趣的；你几乎可以看到攻击者的挫败感，随着他尝试各种方法而增加。^([4](footnote.xhtml#ch09fn4))
    当系统运行在安全级别 1 或更高时，这个标志不能被移除。
- en: schg
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: schg
- en: Only root can set the system-level immutable flag. Files with this flag set
    can’t be changed in any way. They can’t be edited, moved, replaced, or overwritten.
    Basically, the filesystem itself prevents all attempts to alter this file. The
    flag can’t be removed when the system is running at securelevel 1 or greater.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 root 可以设置系统级不可变标志。带有此标志的文件无法以任何方式更改。它们不能被编辑、移动、替换或覆盖。基本上，文件系统本身会阻止所有更改文件的尝试。当系统运行在安全级别
    1 或更高时，这个标志不能被移除。
- en: sunlnk
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: sunlnk
- en: Only root can set the system-level undeletable flag on a file. The file can
    be edited or altered, but it can’t be deleted. This isn’t as secure as the previous
    two flags because if a file can be edited, it can be emptied. It’s still useful
    for certain circumstances, however. I’ve used it when a program insisted on deleting
    its own log files upon a crash. It’s not generally useful to set on any standard
    system files, however. This flag can’t be removed when the system is running at
    securelevel 1 or higher.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 root 可以在文件上设置系统级不可删除标志。文件可以被编辑或修改，但不能被删除。这不如前两个标志安全，因为如果文件可以编辑，就可以被清空。然而，它在某些情况下还是有用的。我曾在程序崩溃时，程序坚持删除自己的日志文件时使用过这个标志。然而，通常不建议在任何标准系统文件上设置这个标志。当系统运行在安全级别
    1 或更高时，这个标志不能被移除。
- en: uappnd
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: uappnd
- en: This user-level, append-only flag can be set only by the file owner or root.
    Like the system-level append-only flag `sappnd`, a file with this flag set can
    be added to but not otherwise edited or removed. This flag is most useful for
    logs from personal programs and the like; it’s primarily a means to let users
    prevent accidental removal of their own files. The owner or root can remove this
    flag.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户级的追加-only 标志只能由文件所有者或 root 设置。像系统级的追加-only 标志 `sappnd` 一样，设置了此标志的文件可以被追加，但不能以其他方式编辑或删除。这个标志最适用于个人程序等的日志；它主要是一种防止用户意外删除自己文件的手段。所有者或
    root 可以移除此标志。
- en: uchg
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: uchg
- en: This user-level, immutable flag can be set only by the owner or root. Like the
    `schg` flag, this immutable flag prevents anyone from changing the file. Again,
    root can override this, and it can be disabled by the user at any securelevel.
    This flag helps prevent mistakes, but it’s not a way to secure your system.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户级的不可变标志只能由所有者或 root 设置。像 `schg` 标志一样，这个不可变标志可以防止任何人更改文件。再次强调，root 可以覆盖这个设置，并且用户可以在任何安全级别下禁用它。这个标志有助于防止错误，但并不是一种保护系统的方式。
- en: uunlnk
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: uunlnk
- en: This user-level, undeletable flag can be set only by the owner or root. A file
    with this flag set can’t be deleted by the owner. Root can override that, and
    the user can turn this flag off at any time, making this mostly useless.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户级的不可删除标志只能由所有者或 root 设置。设置了此标志的文件无法被所有者删除。Root 可以覆盖这一点，用户也可以随时关闭此标志，这使得这个标志大多没什么用处。
- en: '***Setting and Viewing File Flags***'
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置和查看文件标志***'
- en: 'Set flags with chflags(1). For example, to be sure that nothing replaces a
    server’s kernel, you could do this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 chflags(1) 设置标志。例如，为了确保没有人替换服务器的内核，你可以这样做：
- en: '[PRE33]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You’d need to remove this flag to perform system updates.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要移除此标志才能执行系统更新。
- en: 'You can recursively change the flags on an entire directory tree with the `-R`
    flag. For example, to make all of */bin* directory immutable, run this command:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `-R` 标志递归地更改整个目录树的标志。例如，要使 */bin* 目录不可变，可以运行以下命令：
- en: '[PRE34]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And boom! Your basic system binaries can’t be changed.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，砰！你的基本系统二进制文件无法更改。
- en: To see what flags are set on a file, use `ls -lo`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看文件上设置了哪些标志，请使用 `ls -lo`。
- en: '[PRE35]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `sappnd` entry tells us that the system append-only flag is set on this
    log. For comparison, if a file has no flags set, it looks like this:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`sappnd` 条目告诉我们，该日志文件设置了系统的追加-only 标志。做个对比，如果一个文件没有设置标志，它看起来会是这样的：'
- en: '[PRE36]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The hyphen in place of the flag name tells us that no flag has been set.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 标志名的短横线告诉我们，该文件没有设置任何标志。
- en: An out-of-the-box FreeBSD install doesn’t have many files marked with flags,
    but you can flag anything you want. On one system that I fully expected to be
    hacked, I went berserk with `chflags -R schg` in various system directories to
    prevent anyone from replacing system binaries with trojaned versions. It might
    not stop an attacker from getting in, but imagining their frustration improved
    my mood.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 一台全新安装的 FreeBSD 系统，默认情况下没有很多文件被标记为带有标志，但你可以标记任何你想要的文件。在一台我完全预期会被黑客攻击的系统上，我通过在各种系统目录中使用
    `chflags -R schg` 来阻止任何人用木马版本替换系统二进制文件。虽然这可能无法阻止攻击者进入，但想象他们的挫败感让我心情好多了。
- en: 'To remove a file flag, use `chflags` and a `no` in front of the flag name.
    For example, to unset the `schg` flag on your kernel, enter this command:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除文件标志，请使用 `chflags` 并在标志名前加上 `no`。例如，要取消设置内核上的 `schg` 标志，输入以下命令：
- en: '[PRE37]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: That said, you must be running at securelevel –1 to unset many flags. So, without
    further ado, let’s discuss securelevels and what they mean to you.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，你必须运行在 securelevel –1 时才能取消设置许多标志。那么，废话不多说，让我们讨论一下 securelevel 及其对你的意义。
- en: '**Securelevels**'
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Securelevels**'
- en: Securelevels are kernel settings that change basic system behavior to disallow
    certain actions. The kernel behaves slightly differently as you raise the securelevel.
    For example, at low securelevels, file flags can be removed. A file might be flagged
    immutable—but you can remove the flag, edit the file, and reflag it. When you
    increase the securelevel, the file flag can’t be removed. Similar changes take
    place in other parts of the system. Taken as a whole, the behavior changes that
    result from increased securelevels either frustrate or stop an intruder. Enable
    securelevels at boot with the *rc.conf* option `kern_securelevel_enable="YES"`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Securelevel 是内核设置，它通过改变系统的基本行为来禁止某些操作。随着 securelevel 的提高，内核的行为会发生些许不同。例如，在低
    securelevel 下，文件标志可以被移除。一个文件可能被标记为不可更改（immutable）——但你可以移除这个标志，编辑文件，然后重新设置该标志。当你提高
    securelevel 时，文件标志无法再被移除。系统的其他部分也会发生类似的变化。总体而言，增加 securelevel 所带来的行为变化要么会让入侵者感到沮丧，要么会完全阻止他们。你可以在启动时通过
    *rc.conf* 选项 `kern_securelevel_enable="YES"` 启用 securelevel。
- en: Securelevels complicate system maintenance by imposing restrictions on your
    behavior. After all, many system administration tasks are also things intruders
    might do to cover their tracks. For example, at certain securelevels, you can’t
    format or mount new hard drives while the system is running. On the other hand,
    securelevels hamper intruders even more than they hamper you.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Securelevel 通过对你的行为施加限制，增加了系统维护的复杂性。毕竟，许多系统管理任务也是入侵者可能用来掩盖痕迹的行为。例如，在某些 securelevel
    下，你无法在系统运行时格式化或挂载新的硬盘。另一方面，securelevel 对入侵者的阻碍要远远大于对你的影响。
- en: '***Securelevel Definitions***'
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Securelevel 定义***'
- en: 'Securelevels come in 5 degrees: –1, 0, 1, 2, and 3, with –1 being the lowest
    and 3 the highest. Once you enable securelevels with the `kern_securelevel_enable`
    *rc.conf* option, you can set the securelevel at boot with the `kern_securelevel`
    *rc.conf* variable. You can raise the securelevel at any time, not just at boot,
    but you can’t lower it without rebooting into single-user mode. After all, if
    you could lower the securelevel at any time, so could your intruder!'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Securelevel 有 5 个等级：–1、0、1、2 和 3，其中 –1 为最低级别，3 为最高级别。启用 securelevels 后，你可以通过
    *rc.conf* 选项 `kern_securelevel_enable` 在启动时设置 securelevel。你可以随时提高 securelevel，而不仅仅是在启动时，但你不能在不重启并进入单用户模式的情况下降低
    securelevel。毕竟，如果你可以随时降低 securelevel，入侵者也可以！
- en: The effects of each securelevel vary depending on your FreeBSD release. To get
    the latest information, read security(7).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 securelevel 的效果根据你的 FreeBSD 版本而有所不同。要获取最新的信息，请阅读 security(7)。
- en: '**Securelevel –1**'
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Securelevel –1**'
- en: The default provides no additional kernel security whatsoever. If you’re learning
    FreeBSD and are frequently changing your configuration, remain at securelevel
    –1 and use the built-in file permissions and other Unix safeguards for security.
    Flags like `sappnd` and `schg` will work, but chflags(1) can easily remove the
    flags.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 默认设置下，内核并没有提供额外的安全保护。如果你正在学习 FreeBSD，并且频繁更改配置，保持在 securelevel –1，并使用内建的文件权限和其他
    Unix 安全机制来保护系统。像 `sappnd` 和 `schg` 这样的标志会生效，但 chflags(1) 可以轻松移除这些标志。
- en: '**Securelevel 0**'
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Securelevel 0**'
- en: Securelevel 0 is used only during booting and offers no special features over
    securelevel –1\. When the system reaches multiuser mode, however, the securelevel
    is automatically raised to 1\. Setting `kern_securelevel=0` in */etc/rc.conf*
    is effectively the same as setting `kern_securelevel=1`. Securelevel 0 is helpful
    if you have startup scripts that perform actions prohibited by securelevel 1.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Securelevel 0 仅在启动时使用，除了 securelevel –1 外没有特殊功能。然而，当系统进入多用户模式时，securelevel 会自动提高到
    1。将 `kern_securelevel=0` 设置在 */etc/rc.conf* 中，实际上与将 `kern_securelevel=1` 设置是一样的。如果你有启动脚本执行
    securelevel 1 禁止的操作，securelevel 0 会非常有用。
- en: '**Securelevel 1**'
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Securelevel 1**'
- en: 'At securelevel 1, the basic secure mode, things become interesting:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在 securelevel 1，即基本安全模式下，事情变得有趣：
- en: System-level file flags may not be turned off.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统级文件标志不能被关闭。
- en: You can’t load or unload kernel modules (see [Chapter 6](ch06.xhtml#ch06)).
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能加载或卸载内核模块（参见 [第六章](ch06.xhtml#ch06)）。
- en: Programs can’t write directly to system memory via either */dev/mem* or */dev/kmem*.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序不能通过 */dev/mem* 或 */dev/kmem* 直接写入系统内存。
- en: Nothing can access */dev/io*.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法访问 */dev/io*。
- en: You can’t enter the kernel debugger with the `debug.kdb.enter` sysctl.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能通过 `debug.kdb.enter` sysctl 进入内核调试器。
- en: You can’t panic the system with the `debug.kdb.panic` sysctl.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能通过 `debug.kdb.panic` sysctl 让系统崩溃。
- en: Mounted disks can’t be written to directly. (You can write files to disk; you
    just can’t address the raw disk devices.)
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载的磁盘无法直接写入。（你可以将文件写入磁盘；你只是不能直接访问原始磁盘设备。）
- en: The most obvious effect of securelevel 1 for ordinary users is that the BSD-specific
    filesystem flags can’t be altered. If a file is marked system-level immutable,
    and you want to replace it, too bad.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通用户来说，securelevel 1 最明显的效果是无法修改 BSD 特定的文件系统标志。如果一个文件被标记为系统级不可变，并且你想替换它，那就太糟糕了。
- en: '**Securelevel 2**'
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Securelevel 2**'
- en: 'Securelevel 2 has all the behaviors of securelevel 1, with two additions:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Securelevel 2 具有 securelevel 1 的所有行为，并有两个附加功能：
- en: Disks can’t be opened for writing, whether mounted or not.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘无法进行写入操作，无论是否已挂载。
- en: You can’t alter system time by more than one second.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能将系统时间改动超过一秒。
- en: Both of these seem irrelevant to new sysadmins, but they provide important security
    protections. Although Unix provides handy tools, like text editors to write files,
    it’s also possible to bypass both those tools and the actual filesystem to access
    the underlying ones and zeros on the hard drive. Poking at the hard drive lets
    you change any file regardless of the file permissions. The only time this commonly
    happens is when you install a new hard drive and must create a filesystem on it.
    Normally, only the root user can write directly to the disk in this manner. At
    securelevel 2, even root can’t use newfs(8), zpool(8), and so on.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这两项看起来对新手系统管理员无关紧要，但它们提供了重要的安全保护。尽管 Unix 提供了方便的工具，如文本编辑器来写文件，但也可以绕过这些工具和实际的文件系统，直接访问硬盘上的底层数据。直接操作硬盘使你可以更改任何文件，而不考虑文件权限。通常这种情况发生在你安装新硬盘并必须在其上创建文件系统时。通常，只有
    root 用户可以以这种方式直接写入磁盘。在 securelevel 2 下，即使是 root 也无法使用 newfs(8)、zpool(8) 等命令。
- en: Similarly, another old hacker trick is to change the system time, edit a file,
    and change the time back. That way, when the administrator looks for files that
    might be causing trouble, the tampered file appears to have been untouched for
    months or years and hence doesn’t seem an obvious source of concern.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，另一个老黑客技巧是改变系统时间，编辑文件，再将时间改回。这样，当管理员查找可能导致问题的文件时，被篡改的文件看起来似乎已经几个月或几年没有更改，因此看起来不太可能是一个显而易见的关注点。
- en: '**Securelevel 3**'
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Securelevel 3**'
- en: Securelevel 3 is the *network secure mode*. In addition to the settings of securelevels
    1 and 2, you can’t adjust packet filter rules. The firewall on your host is immutable.
    If you have a system with packet filtering or bandwidth management enabled and
    those rules are well tuned and unlikely to change, you can use securelevel 3.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Securelevel 3 是 *网络安全模式*。除了 securelevel 1 和 2 的设置外，你无法调整数据包过滤规则。你主机上的防火墙是不可变的。如果你有一个启用了数据包过滤或带宽管理的系统，且这些规则已经经过良好的调优且不太可能改变，那么你可以使用
    securelevel 3。
- en: '***Which Securelevel Do You Need?***'
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***你需要哪种 Securelevel？***'
- en: The securelevel appropriate for your environment depends entirely upon your
    situation. If you’ve just put a FreeBSD machine into production and are still
    fine-tuning it, leave the securelevel at –1\. Once your system is tuned, however,
    you can raise the securelevel. Most production systems run just fine at securelevel
    2.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 适合你环境的 securelevel 完全取决于你的具体情况。如果你刚刚将 FreeBSD 机器投入生产并且还在微调它，那么保持 securelevel
    为 -1。系统调整完毕后，你可以提高 securelevel。大多数生产系统在 securelevel 2 下运行良好。
- en: If you use one of FreeBSD’s packet filtering or firewall packages, securelevel
    3 might look tempting. Be very sure of your firewall rules before you enable this,
    however! Securelevel 3 makes it impossible to change your firewall without disrupting
    your connection. Are you 100 percent certain that none of your customers will
    ever call in to say, “Here’s a check. Now give me more servers!”?
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 FreeBSD 的数据包过滤或防火墙软件，securelevel 3 可能看起来很诱人。不过，在启用这个选项之前，一定要非常确认你的防火墙规则！securelevel
    3 会使你无法更改防火墙，而不影响连接。你百分百确信你的客户永远不会打电话来说：“这是支票，快给我更多服务器！”吗？
- en: '***What Won’t Securelevels and File Flags Accomplish?***'
  id: totrans-387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安全级别和文件标志无法实现什么？***'
- en: Consider a case where someone compromises a CGI script on your web server, uses
    that to bootstrap into a shell, and then uses the shell to bootstrap himself into
    root access.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一种情况，假设某人侵入了你的网站服务器上的 CGI 脚本，利用它启动一个 shell，再通过 shell 获得 root 权限。
- en: If you’ve set the securelevel accordingly, perhaps this attacker will become
    frustrated because not only can’t she replace your kernel with her specially compiled
    one, she also can’t even load a kernel module. No problem—she can still replace
    assorted system programs with trojaned versions so that the next time you log
    in, your new version of login(1) sends your password to an anonymous web-based
    mailbox or to an internet newsgroup.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经相应地设置了 securelevel，也许攻击者会感到沮丧，因为她不仅无法将你的内核替换为她特别编译的版本，还无法加载内核模块。没问题——她仍然可以用木马版本替换各种系统程序，这样下次你登录时，你的新版本的
    login(1) 就会将你的密码发送到一个匿名的基于网页的邮箱或互联网新闻组。
- en: So, to protect your key files, you run around doing `chflags schg -R /bin/*`,
    `chflags schg -R /usr/lib`, and so on. Fine. If you forget one file—say, something
    obscure like */etc/rc.bsdextended* —your intruder can edit that file to include
    `chflags -R noschg /`. She can then reboot your system late at night when you
    might not notice. How often do you sit down and exhaustively audit your */etc/rc*
    files?
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，为了保护关键文件，你四处执行 `chflags schg -R /bin/*`、`chflags schg -R /usr/lib` 等命令。好吧。如果你忘记了某个文件——比如像
    */etc/rc.bsdextended* 这样不常见的文件——入侵者可以编辑该文件，加入 `chflags -R noschg /`。她可以在深夜时重启系统，可能你并没有注意到。你有多频繁坐下来彻底审计你的
    */etc/rc* 文件？
- en: You think that your system is safe, with every file completely protected. But
    what about */usr/local/etc/rc.d*, the local program startup directory? The system
    boot process tries to execute any executable file in this directory that contains
    a line starting with `#PROVIDE:` (see [Chapter 17](ch17.xhtml#ch17) for why).
    Your intruder could therefore do a lot of damage by placing a simple shell script
    there. After all, */etc/rc* raises the securelevel at the end of the boot process.
    What if she were to create a shell script that kills the running */etc/rc* before
    it could raise the securelevel and then she turned around and ran his own */var/.hidden/rc.rootkit*
    to finish bringing the system up?
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为系统是安全的，所有文件都得到完全保护。但如何看待 */usr/local/etc/rc.d*，即本地程序启动目录呢？系统启动过程会尝试执行该目录下包含
    `#PROVIDE:` 行的任何可执行文件（关于这一点，详见[第17章](ch17.xhtml#ch17)）。因此，入侵者可以通过将一个简单的 shell
    脚本放置在此目录中，造成很大的损害。毕竟，*/etc/rc* 在启动过程的最后会提升 securelevel。假设她创建一个 shell 脚本，在 securelevel
    提升之前杀死正在运行的 */etc/rc*，然后又运行自己放在 */var/.hidden/rc.rootkit* 中的脚本继续启动系统，情况会如何？
- en: Of course, these are only a couple of possibilities. There are others, limited
    only by your intruder’s creativity. Remember that system security is a thorny
    problem with no easy solution. Once intruders have a command prompt, it’s you
    against them. And if they’re any good, you won’t even notice the penetration until
    it’s too late. By following good computing practices and keeping your system up
    to date, you can stop them from intruding in the first place. Do not allow securelevels
    to make you lazy!
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些只是几种可能性。还有其他的，唯一的限制是入侵者的创造力。记住，系统安全是一个棘手的问题，没有简单的解决方案。一旦入侵者获得了命令提示符，剩下的就是你和他们的较量。如果他们足够厉害，你甚至在入侵发生时都不会察觉。通过遵循良好的计算机实践并保持系统更新，你可以防止他们第一次入侵就成功。不要让
    securelevel 使你变得懒惰！
- en: '***Living with Securelevels***'
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***与安全级别共存***'
- en: If you’ve been liberal with the `schg` flag, you’ll soon find that you can’t
    upgrade or patch your system conveniently. The fact is, the same conditions that
    make intruders’ lives difficult can make yours a living hell if you don’t know
    how to work with them.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 `schg` 标志使用得很宽松，你很快就会发现，自己无法方便地升级或修补系统。事实上，使入侵者生活困难的条件，如果你不知道如何与之合作，也可能使你的生活变得一团糟。
- en: If you’ve frozen */etc/rc.conf* with `schg`, you must lower the securelevel
    to change the programs running on your system. Of course, the securelevel setting
    is in that file, so in order to edit it, you must take control of the system before
    */etc/rc* runs. That means you must boot into single-user mode (as discussed in
    [Chapter 4](ch04.xhtml#ch04)), mount your filesystems, run `chflags noschg` on
    the files in question, and continue booting. You can even entirely disable securelevels
    in */etc/rc.conf* and work normally while the system runs or add commands to */etc/rc.local*
    so they take effect before the securelevel is set. You’ll restore service more
    quickly that way but lose the protections of the file flags.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已使用 `schg` 锁定了 */etc/rc.conf*，你必须降低安全级别才能更改系统上运行的程序。当然，安全级别设置就在该文件中，因此为了编辑它，你必须在
    */etc/rc* 运行之前控制系统。这意味着你必须启动单用户模式（如 [第4章](ch04.xhtml#ch04) 中讨论的那样），挂载你的文件系统，对相关文件运行
    `chflags noschg`，然后继续启动。你甚至可以完全禁用 */etc/rc.conf* 中的安全级别设置，在系统运行时正常工作，或者在 */etc/rc.local*
    中添加命令，使其在设置安全级别之前生效。这样你可以更快地恢复服务，但会失去文件标志的保护。
- en: After you’ve finished maintenance, you can raise (but not lower) the securelevel
    by changing the `kern.securelevel` sysctl to your desired securelevel.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 完成维护后，你可以通过将 `kern.securelevel` sysctl 设置为你期望的安全级别来提高（但不能降低）安全级别。
- en: '[PRE38]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now that you can control file changes, let’s consider controlling access to
    your system from the network.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以控制文件更改了，让我们考虑控制网络访问到你的系统。
- en: '**Network Targets**'
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络目标**'
- en: Intruders normally break into applications that listen to the network, not the
    operating system itself. An operating system may or may not help defend a piece
    of software against network attacks, but the intrusion itself starts with the
    application. One way to reduce the number of attacks that can be carried out against
    your server is to identify all of the programs that are listening to the network
    and disable any that aren’t strictly necessary. FreeBSD provides sockstat(1) as
    an easy way to identify programs that are listening to the network.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 入侵者通常是通过破坏监听网络的应用程序而非操作系统本身来入侵的。一个操作系统可能会或可能不会帮助防御软件免受网络攻击，但入侵本身通常是从应用程序开始的。减少可以对你的服务器发起的攻击数量的一种方法是，识别所有监听网络的程序，并禁用任何不严格必要的程序。FreeBSD
    提供了 sockstat(1) 工具，作为一种简单的方法来识别监听网络的程序。
- en: We cover sockstat in detail in [Chapter 8](ch08.xhtml#ch08); running `sockstat
    -4` shows all open IPv4 TCP/IP ports. Every network port you have open is a potential
    weakness and a potential target. Shut down unnecessary network services and secure
    those you must offer.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第8章](ch08.xhtml#ch08) 中详细介绍了 sockstat；运行 `sockstat -4` 可以显示所有打开的 IPv4 TCP/IP
    端口。每个你打开的网络端口都是一个潜在的弱点和潜在的攻击目标。关闭不必要的网络服务并保护那些必须提供的服务。
- en: It’s a good idea to regularly review which ports are open on your systems because
    you might learn something that surprises you. You might find that some piece of
    software you’ve installed has a network component that you weren’t aware of and
    that it’s been quietly listening to the network.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 定期审查你系统上开放的端口是一个好主意，因为你可能会发现一些令人惊讶的东西。你可能会发现某个你安装的软件有一个你没有意识到的网络组件，而且它一直在安静地监听网络。
- en: 'Once you know what’s running, how do you turn off what you don’t need? The
    best way to close these ports is to not start the programs that run them. Network
    daemons generally start in one of two places: */etc/rc.conf* or a startup script
    in */etc/rc.d*. Programs that are integrated with the main FreeBSD system, such
    as sendmail(8), sshd(8), and rpcbind(8), have flags in *rc.conf* to enable or
    disable them, as do many add-on programs. See [Chapter 4](ch04.xhtml#ch04) for
    details on enabling and disabling programs at startup.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道了正在运行的程序，如何关闭不需要的程序呢？关闭这些端口的最佳方法是不启动运行它们的程序。网络守护进程通常会在两个地方启动：*/etc/rc.conf*
    或 */etc/rc.d* 下的启动脚本。与主 FreeBSD 系统集成的程序，如 sendmail(8)、sshd(8) 和 rpcbind(8)，在 *rc.conf*
    中有标志位用来启用或禁用它们，许多附加程序也如此。有关在启动时启用和禁用程序的详细信息，请参见 [第4章](ch04.xhtml#ch04)。
- en: '**WORKSTATION VS. SERVER SECURITY**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**工作站与服务器安全**'
- en: Many companies I’ve seen have tightly secured servers but pay little attention
    to workstation security. A prospective intruder doesn’t care whether a system
    is a server or a workstation, however. Many servers and firewalls have special
    rules for the sysadmin’s workstation. An intruder will happily penetrate a workstation
    and try to leverage that into server access. While server security is key, don’t
    neglect workstations—especially *your* workstation!
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过的许多公司都有严格安全的服务器，但很少关注工作站的安全。然而，潜在的入侵者并不关心一个系统是服务器还是工作站。许多服务器和防火墙都有针对系统管理员工作站的特殊规则。入侵者会乐意渗透一个工作站，并试图利用这一点访问服务器。虽然服务器安全至关重要，但不要忽视工作站——尤其是*你*的工作站！
- en: Network probes are strange in that you really don’t know when someone pokes
    at your hosts. To see how much of this goes on, set `log_in_vain` to 1 in */etc/rc.conf*
    on one of your public servers. This tells the kernel to log all connection attempts
    to closed ports. When someone checks your host for a nonexistent telnet, Squid,
    or database listener, the kernel logs the attempt to */var/log/messages*. Watch
    that log only long enough to realize clear down to your marrow that the whole
    internet really is out to get you—and then disable `log_in_vain`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 网络探测非常奇怪，因为你真的不知道什么时候有人在试探你的主机。为了了解这种情况有多严重，可以在你的一个公共服务器上的 */etc/rc.conf* 文件中将
    `log_in_vain` 设置为 1。这会告诉内核记录所有连接尝试到已关闭的端口。当有人检查你的主机是否存在不存在的 Telnet、Squid 或数据库监听器时，内核会将该尝试记录到
    */var/log/messages* 文件中。仅需观看日志，足够让你深刻意识到，整个互联网真的想要攻破你——然后关闭 `log_in_vain`。
- en: '**Putting It All Together**'
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**汇总**'
- en: Once you have only the necessary network ports open and you know which programs
    are using those ports, you know which programs you must be most concerned about
    securing. If the FreeBSD security team sends out an announcement of a problem
    with a service you don’t run, you can safely delay implementing a fix until your
    next maintenance window. If, however, the security team announces a hole in programs
    you’re using, you know you have to implement a fix as soon as possible. If they
    announce a serious security problem with a piece of network software you’re using,
    you know you must act quickly. Simply being able to respond intelligently and
    quickly to real risks helps protect you against most intruders. Tools such as
    file flags and securelevels minimize the damage successful intruders can do. Finally,
    using groups to restrict your own system administrators to particular sections
    of the system can protect your computers from both accidental and deliberate damage.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你只开放了必要的网络端口，并且知道哪些程序正在使用这些端口，你就知道哪些程序是你最需要关注安全性的。假如 FreeBSD 安全团队发布了一个关于你没有运行的服务的问题公告，你可以安全地推迟修复，直到下一个维护窗口。如果安全团队发布了你正在使用的程序存在漏洞的公告，你就知道必须尽快实施修复。如果他们宣布你正在使用的网络软件存在严重的安全问题，你就知道必须迅速采取行动。能够智能、快速地应对实际风险有助于保护你免受大多数入侵者的攻击。像文件标志和安全级别这样的工具可以最大程度地减少成功入侵者造成的损害。最后，使用组来限制你的系统管理员访问特定的系统部分，可以保护你的计算机免受意外和故意的损害。
- en: Let’s shift gears now and talk storage.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们换个话题，谈谈存储。
