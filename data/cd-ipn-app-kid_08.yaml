- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: FUNCTIONS ARE A PARTY, AND YOU’RE INVITED
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数就是一场派对，你被邀请了
- en: '![Image](Image00001.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00001.jpg)'
- en: One of the most useful tools found in every programming language is the function.
    A *function* is a block of code that you can use again and again to perform a
    specific task. You can write your own custom functions, but Swift comes with lots
    of built-in functions. You’ve already used a few, like the print(_:) function,
    which displays a string in the console.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种编程语言中，函数都是最有用的工具之一。*函数* 是一段可以反复使用的代码，用于执行特定任务。你可以编写自己的自定义函数，但Swift已经提供了许多内置函数。你已经使用过一些，比如`print(_:)`函数，它可以在控制台显示一个字符串。
- en: '**IN WITH THE INPUT, OUT WITH THE OUTPUT**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**输入进，输出出**'
- en: Functions can take *input* and return *output* , although they don’t always
    have to. Input is information that you give to the function to perform its task,
    and output is something the function returns when it’s finished performing that
    task.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受*输入*并返回*输出*，尽管它们不一定总是如此。输入是你给函数的信息，用来执行其任务，而输出是函数在完成任务后返回的内容。
- en: The type of input that a function can take is defined in its *input parameters*
    . The values you pass in for those parameters are called *arguments* . For example,
    the string that you put between the parentheses of the print(_:) function is an
    argument. Sometimes an argument will have an *argument label* that describes it.
    The print(_:) function doesn’t have an argument label, but we’ll learn more about
    labels later in the chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受的输入类型由它的*输入参数*定义。你传递给这些参数的值叫做*参数*。例如，你放在`print(_:)`函数括号中的字符串就是一个参数。有时，一个参数会有一个*参数标签*来描述它。`print(_:)`函数没有参数标签，但我们会在本章稍后学习更多关于标签的内容。
- en: '**NOTE**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this book, when we refer to a function with one unlabeled input parameter,
    we put a (_:) after the function name. You’ll see where that colon (: ) comes
    into play soon!*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本书中，当我们提到具有一个未标记输入参数的函数时，我们会在函数名后加上(_:)。很快你就会看到这个冒号(:)的作用！*'
- en: 'Let’s look at an example in the playground:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在Playground中的例子：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试区域（按⌘ -SHIFT -Y），你会看到：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(_:)`函数接受一个输入值，但没有返回值。在这个例子中，输入值是字符串"Swift is awesome!"。`print(_:)`函数会在调试控制台显示它接收到的字符串，然后结束，不返回任何东西。没有返回值的函数有时称为*void函数*。我们将在《[返回值](text00017.html#ch07lev1sec5)》章节的[第91页](text00017.html#page_91)中看到一个有输入参数和返回值的函数示例。'
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写处理输入并返回输出的函数，你可以创建各种各样的应用程序！
- en: '**WRITING A CUSTOM FUNCTION**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写自定义函数**'
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的函数，打印一个*haiku*，这是一种传统的日本诗歌，由三行组成，第一行和第三行各有五个音节，中间的行有七个音节。将以下内容输入到你的Playground中：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你写下`func`关键字 ➊ ，然后是你函数的名称。当你创建一个函数时，必须为其命名，这样你才能在需要时调用它执行任务。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 函数命名的规则与变量命名相同：你从小写字母开始，并使用驼峰命名法（camel case）对每个新单词进行大写。你还应该给函数起一个能描述其功能的名字。你不觉得`printAHaiku()`是一个非常合适的名字，适合用来打印一个简单的Swift
    haiku吗？
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名后面是一个括号对➋。如果你的函数有输入参数，应该将它们放在这些括号里。在这个例子中，你没有输入参数，所以括号保持为空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被大括号包围。在这里你将编写函数的代码。你应将左花括号（{）放在与函数名同一行，而右花括号（}）则放在函数末尾的独立一行。在这个例子中，函数的主体包含所有打印输出haiku的打印语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数时，只需写上函数名，后跟括号并传入任何参数。这就是*函数调用*。在这个例子中，由于printAHaiku()没有输入参数，你无需传入任何参数——只需将括号留空即可。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用printAHaiku()，在函数的右花括号后，向你的游乐场添加以下代码：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The console output is:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出为：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，可以随时调用它，函数内部的代码会运行。确保你已打开调试区域（⌘ -SHIFT -Y），如[图 7-1](text00017.html#ch07fig1)所示，这样你就能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用printAHaiku()函数吧！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数做得更多**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一个例子中，你看到了函数如何为你节省时间和精力。当你编写一个函数时，你可以在任何地方调用它，而无需在多个地方重复相同的代码。这当然很酷，但函数的真正强大之处在于，当你传入一个或多个输入值时，可以产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为invite(guest:)的函数，它接受一个人的名字作为输入，并生成一张生日派对的个性化邀请函。在你的游乐场（playground）中输入以下内容：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将其放在函数名后的括号内➊。你应该按照以下格式编写输入参数：首先是参数名（在此例中为guest），然后是一个冒号（:），最后是它的数据类型（在这个例子中为String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也作为参数标签使用，因此当你调用这个函数时，guest将作为参数标签。（你将在“[参数标签](text00017.html#ch07lev1sec4)”章节的[第89页](text00017.html#page_89)中学习如何定义不同的参数名和参数标签。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你在输入参数后面加上冒号，写上数据类型，就像声明变量一样。然而，与变量声明不同，在定义函数参数时，你*必须*始终声明函数预期的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需使用它的参数名，就像使用任何其他常量一样➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅定义一个函数是不够的。既然函数已经定义了，让我们在playground中调用它，看看会发生什么。你可以通过输入函数名，后跟圆括号中的参数标签、冒号以及参数，来调用一个带有输入参数的函数，像这样：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过输入函数名来调用一个函数时，Xcode的自动补全会给你一个提示，告诉你应该传递什么参数给函数。在这种情况下，当你开始输入`invite`时，你会看到一个下拉菜单，像[图
    7-2](text00017.html#ch07fig2)那样。
- en: '![Image](Image00155.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode的自动补全会显示一个函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 按下ENTER键来自动补全函数。光标会跳到函数的圆括号内（见[图 7-3](text00017.html#ch07fig3)），此时Xcode已经自动添加了一些占位符文本，告诉你函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode正在等待你填写`guest`参数。*'
- en: '**NOTE**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递的不是字符串给`invite(guest:)`，比如`invite(guest: 45)`，你会收到一个错误，因为这个函数期望的是字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将`String`替换为"Cathy"或其他朋友的名字，然后按TAB键完成函数调用的填写。它应该像[图 7-4](text00017.html#ch07fig4)那样。
- en: '![Image](Image00157.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个`invite(guest:)`函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用`invite(guest:)`三次，使用你自己朋友的名字：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output looks like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下所示：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的`invite(guest:)`函数，你可以快速打印出三张派对邀请函，每张都发给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有的朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，通过传递一个字符串数组作为参数，而不是单个字符串，一次性邀请所有的朋友。在你写了`invite(guest:)`的同一个playground中，编写以下的`invite(allGuests:)`函数来进行测试。注意，参数名称现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到`[String]`是用方括号括起来的➊。方括号表示数据类型是一个数组，而`String`则表示数组中值的类型是字符串。通过使用`[String]`，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`invite(allGuests:)`函数内部，我们需要使用一个for-in循环遍历我们的`guests`数组，并为每个客人打印一张邀请函。记得我们之前创建了一个打印邀请函的函数吗？我们在这里也使用它！将以下代码添加到你的`invite(allGuests:)`函数中（灰色文本表示现有的代码行）：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们在 String 数组 `allGuests` 中的每个客人上调用单一的 `invite(guest:)` 函数，邀请每个人参加生日派对。您可能会想，`invite(guest:)`
    和 `invite(allGuests:)` 是不是同一个函数。毕竟，它们的名字都是 `invite`。然而，尽管它们有相同的名称，但它们是两个不同的函数，因为它们接受不同的输入参数。这是您将在
    Swift 中经常看到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `invite(allGuests:)` 函数，我们首先创建一个名为 `friends` 的数组，然后在函数调用中使用该数组。
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后，我们将新的数组作为函数的输入来调用该函数 ➋ 。这是您将在调试控制台中看到的输出（-- snip --
    显示的是我们为了节省空间而省略的行）：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不得不为每个朋友写邀请函，这将会非常繁琐。但是通过函数的强大功能，您可以用很少的代码行完成这一任务。尝试创建您自己的朋友数组，长度可以随您所愿！然后使用新的数组作为输入，调用
    `invite(allGuests:)` 函数。真是小菜一碟！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向您的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您的派对日期即将到来，而一些客人还没有回复是否参加。您希望确认最终的出席人数，并让客人们知道要带泳衣，因为这将是一个水滑梯派对。您可以编写一个函数，根据客人的
    RSVP 状态向每个客人发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新函数将接受两个输入参数：一个 String 类型的 guest 参数，用于存储客人的名字；一个 Bool 类型的 rsvped 参数，用于存储RSVP状态，值为
    true 或 false。请在您的 Playground 中输入以下代码：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数需要多个输入参数时，您需要在每个参数之间添加逗号 ➊ 。每个参数都需要有一个参数名，后面跟着冒号和该参数的数据类型。您可以创建一个函数，接收任意数量的输入参数，而且这些参数类型可以不同。在
    `sendMessage(guest:rsvped:)` 函数中，我们传递了一个 String 类型的 guest 参数和一个 Bool 类型的 rsvped
    参数。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 的值，看看它是否为 true ➋ ，然后使用 if-else 语句打印相应的消息。还要注意，函数定义中的最后打印语句无论
    rsvped 的值是 true 还是 false 都会执行，因为它们在 if-else 语句的花括号之外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的客人已确认参加，他们将收到以下信息：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提示，请他们回复：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用函数看看它是如何工作的。尝试将一位客人的 rsvped 值设置为 true，另一位客人的 rsvped 值设置为 false，这样您就可以看到两个消息的效果。
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，调用一个具有多个输入参数的函数类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会帮助你填写输入值，并为你提供参数标签。你只需传入你想使用的值。填写完宾客名字后，按`TAB`，Xcode 会将光标移到你需要的下一个输入框中。（见[图
    7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入宾客姓名后按`TAB`将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你`rsvped`的数据类型。将占位符文本`Bool`替换为`true`或`false`。如果你尝试传入其他内容，如姓名或数字，将会出现错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用`print(_:)`时，输入值前面没有参数标签？你写的是：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加标签，你会得到一个错误：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而一些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且它将与参数名称相同。然而，如果你编写一个函数，觉得参数标签并不必要以使代码更清晰，那么你可以在函数定义中显式省略它。例如，在`print(_:)`函数中，很明显你传入的是一个将被打印的字符串。如果每次调用`print(_:)`时都必须包含一个像`inputString`这样的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，然后是参数的数据类型来实现。在你第一次声明函数参数时，所有这些操作都在`func`关键字后的函数括号内完成。这通常在
    Swift 函数中使用，使得函数调用看起来更像一句话。[图 7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：`sayHello()`函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)`函数的输入参数是`friend`，参数标签是`to`，函数调用中传入的参数是"Colin"。如果没有单独的参数标签，调用该函数时会像`sayHello(friend:)`，这听起来就不那么像一句完整的句子了。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们将了解如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，看看如何通过添加自定义参数标签来使代码更具可读性。生日派对后，你会想给所有的宾客写感谢信。在你的 Playground 中编写以下函数：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 位置，我们为传递给函数的 `guest` 参数添加了自定义的参数标签 `to`。类似地，在 ➋ 位置，我们为 `gift` 参数添加了参数标签
    `for`。参数名称 `guest` ➌ 和 `gift` ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 `to` 和 `for` 用来标记函数调用时的参数，像这样：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到在函数调用中，第一个输入值前写了 `to:`，第二个输入值前写了 `for:`。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。如果尝试使用参数名称，系统会报错：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填充参数标签，所以你不必担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于将感谢信 *发送给* 客人 *以感谢* 礼物。代码
    `sendThankYou(to: "Meghan", for: "puzzle books")` 比 `sendThankYou(guest: "Meghan",
    gift: "puzzle books")` 更像一句完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**去除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加上下划线和空格来去除它们。在下面的例子中，我们编写了一个计算体积的函数，它以盒子的三条边作为输入。因为函数名已经明确表示你需要传入三条边，所以你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 位置将下划线放在 `side1` 前面，在 ➋ 位置将下划线放在 `side2` 前面，以及在 ➌ 位置将下划线放在 `side3` 前面，去除了边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，无需任何标签。
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。”如果你不仅仅是打印出盒子的体积，而是希望将结果存储在变量或常量中以供后续使用，这不是更有用吗？让我们通过返回值来了解如何做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多东西。首先，编写一个返回盒子体积的 `volumeOfBox(_:_:_:)` 函数，返回一个整数类型的值：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数提供返回值，请在函数的输入参数后面使用一个破折号和一个大于号来形成箭头（->），然后输入返回值的数据类型 ➊。请注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，你使用`return`关键字返回你想要返回的值
    ➋。如果你写一个返回值的函数，那么你*必须*在函数内返回该值，否则会出现错误。函数在返回值后结束。如果在`return`语句后写了任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它的效果：
- en: '![](Image00165.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)`函数计算一个长宽高分别为6、5和3的盒子的体积，返回值90被存储在一个名为`volumeOfBox1`的常量中。在
    ➋ 处，`volumeOfBox2`，长宽高分别为8、4和2，返回值为64。现在让我们打印出哪个盒子更大：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串“Box 1 is the bigger box.”输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们写一个函数，接收一个测试成绩数组并返回平均成绩。为了计算平均值，你需要将所有分数加在一起，然后除以总的分数数量。在你的游乐场中输入以下代码：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为`sum`的`Int`类型变量，并将其初始化为0。 ➋ 处的`for-in`循环遍历`score`数组中的每个值，并将其加到`sum`变量中。循环完成后，变量`sum`保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，分数总数就是`score.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能除以零——在数学课上也不行，在Swift中也是如此。尝试除以零会给你一个除零错误，并导致程序崩溃。因此，在进行除法时，始终确保你要除的数不为零，这就是我们通过检查`score.count
    > 0`来处理的 ➌。在 ➍ 处，我们通过将总分除以数组中的分数数量来返回平均值，使用`return sum / score.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回`sum
    / score.count`，因为它的计算结果是一个`Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在`score.count`不大于零时返回某个值，否则我们会得到一个缺少返回值的错误。我们通过在`if`语句后添加`else`来处理这个问题，返回`0`
    ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整个测试成绩数组传递给 averageOf() 函数时，如我们在 ➊ 中所做的，函数返回的是成绩的平均值，并显示在结果窗格中。如果你传递一个空数组，如我们在
    ➋ 中所做的，那么返回值就是 0。
- en: '**NOTE**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句其实并不必要。这是因为如果 scores.count > 0，那么函数已经会通过 return
    sum / scores.count 提前结束。所以，如果计算机已经跳过了那个 if 语句，我们就知道 scores.count > 0 一定不成立，那么我们可以直接写一个
    return 0，而不需要放在 else 语句中。然而，如果我们保留 else 语句，代码会更加清晰，容易理解。有时候，为了让别人更容易理解，写一些额外的代码比用复杂的技巧更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱增加了一个重要工具——创建和调用你自己的函数！函数在编程中广泛使用，用来做各种令人惊奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建除 Swift 已包含类型之外的常量和变量，这在创建应用程序时非常有用！
- en: FUNCTIONS ARE A PARTY, AND YOU’RE INVITED
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数是一个派对，你被邀请了
- en: '![Image](Image00001.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00001.jpg)'
- en: One of the most useful tools found in every programming language is the function.
    A *function* is a block of code that you can use again and again to perform a
    specific task. You can write your own custom functions, but Swift comes with lots
    of built-in functions. You’ve already used a few, like the print(_:) function,
    which displays a string in the console.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言中都有一个非常有用的工具——函数。*函数*是你可以一次又一次使用的代码块，来执行特定的任务。你可以编写自己的自定义函数，但 Swift 提供了许多内置函数。你已经使用过一些，比如
    print(_:) 函数，它在控制台中显示字符串。
- en: '**IN WITH THE INPUT, OUT WITH THE OUTPUT**'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**输入与输出**'
- en: Functions can take *input* and return *output* , although they don’t always
    have to. Input is information that you give to the function to perform its task,
    and output is something the function returns when it’s finished performing that
    task.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接收*输入*并返回*输出*，虽然它们并不总是需要这样做。输入是你提供给函数以完成任务的信息，而输出是函数完成任务后返回的内容。
- en: The type of input that a function can take is defined in its *input parameters*
    . The values you pass in for those parameters are called *arguments* . For example,
    the string that you put between the parentheses of the print(_:) function is an
    argument. Sometimes an argument will have an *argument label* that describes it.
    The print(_:) function doesn’t have an argument label, but we’ll learn more about
    labels later in the chapter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接收的输入类型由它的*输入参数*定义。你传入这些参数的值被称为*实参*。例如，print(_:) 函数中圆括号里的字符串就是一个实参。有时，实参会有一个*参数标签*来描述它。print(_:)
    函数没有参数标签，但我们会在本章稍后学习标签的相关内容。
- en: '**NOTE**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this book, when we refer to a function with one unlabeled input parameter,
    we put a (_:) after the function name. You’ll see where that colon (: ) comes
    into play soon!*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本书中，当我们提到一个具有一个未标记输入参数的函数时，我们会在函数名后加上 (_:)。你很快就会看到那个冒号（:）的作用！*'
- en: 'Let’s look at an example in the playground:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个在 Playground 中的例子：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试区域（按 ⌘ -SHIFT -Y），你会看到：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: print(_:) 函数接受一个输入值，但没有返回值。在这种情况下，输入值是字符串"Swift is awesome!"。print(_:) 函数将它所接收的字符串显示在调试控制台中，然后结束，不返回任何内容。没有返回值的函数有时被称为*void函数*。我们将在“[返回值](text00017.html#ch07lev1sec5)”的[第91页](text00017.html#page_91)中看到一个既有输入参数又有返回值的函数示例。
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写接受输入并返回输出的函数，你可以创建各种各样的应用程序！
- en: '**WRITING A CUSTOM FUNCTION**'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写自定义函数**'
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的函数，它打印一个*俳句*，这是一种传统的日本诗歌，由三行组成，第一行和最后一行有五个音节，中间一行有七个音节。将此输入到你的游乐场：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，写下 func 关键字 ➊，后跟函数的名称。当你创建一个函数时，你必须给它起个名字，这样你才可以在需要它执行任务时调用它。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数的规则与命名变量相同：你从小写字母开始，并使用驼峰命名法将每个新单词的大写字母连接起来。你还应当为你的函数起一个能够描述其作用的名字。你不觉得
    printAHaiku() 是一个非常适合打印简单 Swift 俳句的函数名吗？
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名称后面，有一对括号 ➋。如果你的函数有输入参数，你会将它们放在这些括号内。在这个例子中，你没有任何输入参数，所以只需将括号留空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被大括号括起来。这是你写函数代码的地方。你将开括号（{）放在与函数名相同的行上，闭括号（}）则放在函数末尾的独立一行上。在这个例子中，函数的主体包含了所有打印俳句的
    print 语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，你只需写下它的名称，后面跟上带有参数的括号。这是一个*函数调用*。在这个例子中，由于 printAHaiku() 没有输入参数，你无需传入任何参数——只需将括号留空即可。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 printAHaiku()，在函数的闭括号后，在你的游乐场中添加以下一行：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The console output is:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出是：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数内部的代码就会执行。确保你打开了调试区域（⌘ -SHIFT -Y），如[图 7-1](text00017.html#ch07fig1)所示，这样你就可以看到结果了。
- en: '![Image](Image00153.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用 printAHaiku() 函数吧！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数做更多事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，你看到了函数如何帮助你节省时间和精力。当你编写一个函数时，你可以在任何地方调用它，而不必在许多地方重复代码块。这当然很酷，但函数的真正威力在于，当你传入一个或多个输入值时，可以产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 invite(guest:) 的函数，它接受一个人的名字作为输入，并创建一张个性化的生日派对邀请函。请在你的 Playground
    中输入以下内容：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将其包含在函数名称后面的括号中 ➊。你将输入参数的格式化方式是：先写参数名（在此示例中为 guest），然后是冒号（:），最后是其数据类型（在这个例子中是
    String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当了参数标签，因此当你调用该函数时，guest 将是参数标签。（你将在“[参数标签](text00017.html#ch07lev1sec4)”章节中学习如何定义独立的参数名和参数标签，具体见
    [第 89 页](text00017.html#page_89)）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后面写输入参数的数据类型，就像声明一个变量时一样。但是，与变量声明不同，当定义函数参数时，你*必须*始终声明函数应期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需使用其参数名，就像使用其他常量一样 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅定义函数还不够。现在函数已经定义了，让我们在 Playground 中调用它看看会发生什么。你可以通过输入函数名称，后跟括号内的参数标签、冒号和参数，来调用一个带有输入参数的函数，如下所示：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过编写函数名称调用一个函数时，Xcode 的自动完成功能会给你一个提示，告诉你应该传递什么类型的参数。在这种情况下，当你开始编写 invite 时，你会看到一个下拉菜单，如
    [图 7-2](text00017.html#ch07fig2) 所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成将显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键以自动完成函数。你的光标将移动到函数的括号内（参见 [图 7-3](text00017.html#ch07fig3)），此时 Xcode
    已自动添加了一些占位符文本，告诉你函数期望什么类型的输入。
- en: '![Image](Image00156.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递了一个不是字符串的值给 invite(guest:)，例如 invite(guest: 45)，你会遇到错误，因为该函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 位置输入 “Cathy” 或其他朋友的名字，然后按 TAB 键完成函数调用的填写。它应该看起来像 [图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用，尝试使用你自己朋友的名字，调用三次invite(guest:)函数：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output looks like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来是这样的：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你可以快速打印三份派对邀请函，每份邀请函都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以写一个函数，通过传入一个字符串数组作为参数，而不是单个字符串，一次性邀请所有朋友。在你编写invite(guest:)函数的同一个Playground中，写出以下invite(allGuests:)函数来进行测试。注意，参数名称现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当你声明函数的参数时，你会注意到[String]是用方括号括起来的 ➊ 。方括号声明数据类型为数组，String表示数组中值的数据类型。通过使用[String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们希望使用for-in循环遍历我们的guest数组，并为每个guest打印邀请函。记得我们刚才创建了一个打印邀请函的函数吗？我们将在这里使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本表示现有的行）：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个guest调用单个invite(guest:)函数，邀请每个人参加生日派对。你可能会想知道invite(guest:)和invite(allGuests:)是否是相同的函数。毕竟，它们的名字都是invite。尽管名字相同，但它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常会看到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个由六个朋友组成的数组 ➊ 。然后，我们用新数组作为函数的输入，调用该函数 ➋ 。这是你在调试控制台中看到的输出（-- snip --表示我们省略了部分行以节省空间）：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友写一份邀请函，那会花费很多时间。但是，借助函数的力量，你只用了很少的代码就完成了这项工作。试着创建你自己的朋友数组；可以长一点！然后用你的新数组作为输入，调用invite(allGuests:)函数。简单极了！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期即将到来，而一些客人还没有回复。你想要确认最终的参加人数，并通知客人带上泳衣，因为这将是一个滑水派对。你可以写一个函数，根据客人的RSVP状态发送自定义信息。
- en: '![Image](Image00159.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个 `String` 类型的参数表示客人姓名，一个 `Bool` 类型的参数表示 RSVP 状态，其值为 `true`
    或 `false`。在你的 Playground 中输入以下代码：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数都需要有一个参数名，后面跟上冒号和参数的数据类型。你可以创建一个接受任意多个输入参数的函数，并且它们不必是相同类型。在
    `sendMessage(guest:rsvped:)` 函数中，我们传入了一个 `String` 类型的 `guest` 和一个 `Bool` 类型的 `rsvped`。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 `rsvped` 值是否为 `true` ➋，然后使用 `if-else` 语句打印相应的消息。还要注意，函数定义中的最后 `print`
    语句无论 `rsvped` 值是 `true` 还是 `false` 都会执行，因为它们在 `if-else` 语句的括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复了，他们将收到以下消息：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提示，要求他们做出回应：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一个客人的 `rsvped` 值设置为 `true`，另一个客人的设置为 `false`，这样你就能看到两个消息的实际效果。
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调用一个有多个输入参数的函数类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会通过为你提供参数标签来帮助你填写输入值。你所需要做的就是传入你想使用的值。输入完客人姓名后，按 TAB 键，Xcode 会将光标移动到你需要填写下一个输入值的位置。（见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入完客人姓名后按 TAB 键，将会将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 `Bool` 替换为 `true` 或 `false`。如果你尝试传入其他内容，比如名字或数字，你将会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到当你调用 `print(_:)` 时，并没有在输入值前加上参数标签？你只需要写：
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，你将会遇到错误：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而有些没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且该标签与参数名相同。然而，如果你编写的函数中，你认为参数标签并不必要以使代码更清晰，那么你可以在函数定义中明确省略它。例如，在
    `print(_:)` 函数中，很明显你传入的是一个字符串，它将被打印出来。如果每次调用 `print(_:)` 时都必须包括像 `inputString`
    这样的参数标签，会显得很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现这一点。所有这些都在函数体内的func关键字后声明参数时进行。这在Swift函数中很常见，目的是让函数调用看起来更像一句话。[图7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6: sayHello()函数具有自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是friend，参数标签是to，函数调用中传入的参数是"Colin"。如果没有单独的参数标签，调用函数时会像
    sayHello(friend:) 这样，这听起来不像是完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写带有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，看看如何通过添加自定义的参数标签使代码更具可读性。在你的生日派对结束后，你可能想要给所有的客人发送感谢卡。你可以在你的 playground
    中写下以下函数：
- en: '[PRE46]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传入的guest参数添加了自定义的参数标签to。同样，在➋处，我们为gift参数添加了参数标签for。参数名称guest ➌和gift ➍用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for用于在函数调用时标记参数，如下所示：
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里你可以看到，to: 被写在第一个输入值之前，而for: 被写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名称而不是标签会导致错误：'
- en: '[PRE48]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能会始终为你填充参数标签，所以你不必担心错误地调用函数（见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7: Xcode自动完成带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用来向客人*发送*感谢卡*以感谢*礼物。代码 sendThankYou(to:
    "Meghan", for: "puzzle books") 比 sendThankYou(guest: "Meghan", gift: "puzzle books")
    看起来更像一句话。'
- en: '![Image](Image00163.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前加下划线和空格来移除它们。在以下示例中，我们编写一个计算体积的函数，它接受盒子的三条边作为输入。由于函数名已经清楚地说明了需要传入三条边，你实际上并不需要参数标签来提高代码的可读性。
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处在 side1 前面加下划线，在 ➋ 处在 side2 前面加下划线，在 ➌ 处在 side3 前面加下划线，移除了侧面参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用该函数时，只需要输入参数值，而不需要任何标签。
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。"。如果你可以将结果存储在一个变量或常量中以便稍后使用，而不仅仅是打印出盒子的体积，岂不是更有用吗？让我们通过返回值来了解如何做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的盒子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多东西。首先，写一个 volumeOfBox(_:_:_:) 函数，它返回盒子的体积（Int 类型）：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数提供返回值，在函数的输入参数后面使用一个破折号和一个大于号形成箭头（->），然后输入返回值的数据类型 ➊ 。请注意，你不需要为返回值提供名称，只需要数据类型即可。在函数体内，你可以通过使用
    return 关键字并跟随你想返回的值来返回该值 ➋ 。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值之后结束。如果你在返回语句后编写了任何代码，它将被忽略，因为
    return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ ，volumeOfBox(_:_:_:) 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在 ➋ ，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在，让我们打印出关于哪个盒子更大的消息：
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，它接受一个测试分数数组，并返回平均分数。为了得到平均值，你将所有分数加起来，然后除以分数的总数。请在你的
    Playground 中输入以下代码：
- en: '[PRE53]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在➊，我们定义了一个名为sum的Int类型变量，并将其初始化为0。➋处的for-in循环遍历`scores`数组中的每个值，并将其累加到sum变量中。当循环完成时，sum变量中保存了所有分数的总和。计算出总和后，剩下的就是用总和除以分数的数量，简单来说就是`scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能用零来除——无论是在数学课上还是在Swift中。在Swift中，尝试用零除会导致“除以零”错误，并使你的程序崩溃。因此，在进行除法运算时，一定要确保你要除的数不是零，这就是我们在➌处通过检查`scores.count
    > 0`来避免的情况。在➍处，我们通过将分数总和除以数组中的分数数量来返回平均值，使用的是`return sum / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回`sum
    / scores.count`，因为它的结果是一个Int类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`scores.count`不大于零时，我们也需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在if语句中添加一个else来处理这个问题，返回0，见➎。你可以通过调用函数来测试代码，分别传入一个分数组和一个空数组：
- en: '![](Image00166.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整套测试分数传递给`averageOf()`函数时，正如我们在➊所做的那样，函数会返回分数的平均值，并显示在结果面板中。如果你传入一个空数组，正如我们在➋所做的那样，返回值将是0。
- en: '**NOTE**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0周围的else语句其实并不是必须的。这是因为如果`scores.count > 0`，那么函数已经通过`return
    sum / scores.count`结束了。所以如果程序已经通过了那个if语句，那么我们知道`scores.count > 0`一定不为真，这时我们可以直接使用`return
    0`，而不需要将其包裹在else语句中。然而，如果我们保留else语句，代码会更清晰、更容易理解。有时候，写一些额外的代码让其他人更容易理解，比使用一些巧妙的快捷方式要更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要的工具——创建并调用你自己的函数！函数在编程中被广泛使用，用来做各种各样的惊人事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让你可以创建除Swift中已有类型以外的常量和变量，这对于你在开发应用时将非常有用！
- en: '![Image](Image00001.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00001.jpg)'
- en: One of the most useful tools found in every programming language is the function.
    A *function* is a block of code that you can use again and again to perform a
    specific task. You can write your own custom functions, but Swift comes with lots
    of built-in functions. You’ve already used a few, like the print(_:) function,
    which displays a string in the console.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种编程语言中，最有用的工具之一就是函数。*函数*是一个代码块，你可以反复使用它来执行特定任务。你可以编写自己的自定义函数，但Swift也提供了许多内置函数。你已经使用过一些，比如`print(_:)`函数，它在控制台显示一个字符串。
- en: '**IN WITH THE INPUT, OUT WITH THE OUTPUT**'
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**输入与输出**'
- en: Functions can take *input* and return *output* , although they don’t always
    have to. Input is information that you give to the function to perform its task,
    and output is something the function returns when it’s finished performing that
    task.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受*输入*并返回*输出*，尽管它们并不总是必须有返回值。输入是你给函数的，用于执行任务的信息，而输出是函数在完成任务后返回的内容。
- en: The type of input that a function can take is defined in its *input parameters*
    . The values you pass in for those parameters are called *arguments* . For example,
    the string that you put between the parentheses of the print(_:) function is an
    argument. Sometimes an argument will have an *argument label* that describes it.
    The print(_:) function doesn’t have an argument label, but we’ll learn more about
    labels later in the chapter.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以接受的输入类型在其*输入参数*中定义。你传递给这些参数的值被称为*参数*。例如，你在print(_:)函数的括号中输入的字符串就是一个参数。有时，参数会有一个*参数标签*来描述它。print(_:)函数没有参数标签，但我们将在本章后面学习更多关于标签的内容。
- en: '**NOTE**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this book, when we refer to a function with one unlabeled input parameter,
    we put a (_:) after the function name. You’ll see where that colon (: ) comes
    into play soon!*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本书中，当我们提到一个只有一个未标记输入参数的函数时，我们会在函数名后加上(_:)。你很快就会看到冒号(:)的作用！*'
- en: 'Let’s look at an example in the playground:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Playground 中看一个例子：
- en: '[PRE54]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试区（按⌘-SHIFT-Y），你会看到：
- en: '[PRE55]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(_:)`函数接受一个输入值，但没有返回值。在这个例子中，输入值是字符串"Swift is awesome!"。`print(_:)`函数在调试控制台显示它收到的字符串，然后结束而不返回任何内容。没有返回值的函数有时被称为*无返回值函数*。我们将在“[返回值](text00017.html#ch07lev1sec5)”一节中，在[第91页](text00017.html#page_91)看到一个既有输入参数又有返回值的函数示例。'
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写接受输入并返回输出的函数，你可以创建各种各样的应用程序！
- en: '**WRITING A CUSTOM FUNCTION**'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写自定义函数**'
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的函数，打印一个*俳句*，它是由三行组成的传统日本诗歌，第一行和第三行各有五个音节，中间一行有七个音节。将以下内容输入到你的Playground中：
- en: '[PRE56]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，写下`func`关键字 ➊ ，后面跟上你的函数名称。当你创建一个函数时，必须给它命名，这样你才能在需要它执行任务时调用它。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数的规则与命名变量相同：你从小写字母开始，每个新词的首字母大写，采用驼峰命名法。你还应该给你的函数起一个能描述它功能的名字。你不觉得`printAHaiku()`是一个非常适合打印简单Swift俳句的函数名吗？
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名后面，有一对括号 ➋ 。如果你的函数有输入参数，你应将它们放在括号内。在这个例子中，你没有任何输入参数，所以括号就保持空着。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被大括号包围。你将在这里编写函数的代码。你将开括号（{）和函数名称放在同一行，闭括号（}）则放在函数末尾的单独一行。在这个例子中，函数的主体包含所有打印俳句的print语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，你只需写出它的名称，后面跟着圆括号，括号内是任何参数。这就是一个*函数调用*。在这个例子中，因为printAHaiku()没有输入参数，所以你无需传入任何参数——只需将圆括号留空。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用printAHaiku()，请在函数的闭括号后，在你的 playground 中添加以下代码行：
- en: '[PRE57]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The console output is:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出为：
- en: '[PRE58]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数内部的代码将会执行。确保调试区域是打开的（⌘ -SHIFT -Y），如[图 7-1](text00017.html#ch07fig1)所示，这样你才能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用printAHaiku()函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数能做更多的事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，你看到了函数如何节省时间和精力。当你编写一个函数时，你可以在任何地方调用它，而不必在多个地方重复代码块。这肯定很酷，但函数的真正强大之处在于当你传入一个或多个输入值时，可以产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为invite(guest:)的函数，它接受一个人的名字作为输入，并生成一个个性化的生日派对邀请函。在你的playground中输入以下内容：
- en: '[PRE59]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数有输入参数，你需要将其放入函数名称后面的圆括号中 ➊。你将输入参数的名称首先写出（在这个例子中是guest），然后是冒号（:），最后是它的数据类型（在这个例子中是String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名称也充当了参数标签，因此在调用此函数时，guest将成为参数标签。（你将会在“[参数标签](text00017.html#ch07lev1sec4)”中学习如何定义单独的参数名称和参数标签，详见[第89页](text00017.html#page_89)。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后面写出输入参数的数据类型，就像声明变量时一样。然而，不同于变量声明，在定义函数参数时，你*必须*始终声明函数应期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需像使用其他常量一样使用其参数名称 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数还不够。既然函数已经定义了，接下来我们可以在playground中调用它，看看会发生什么。你可以通过输入函数名称后跟括号中的参数标签、冒号和参数来调用带有输入参数的函数，如下所示：
- en: '[PRE60]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过编写函数名称来调用一个函数时，Xcode 的自动完成功能会给你一些提示，告诉你应该传递什么参数给函数。在这种情况下，当你开始编写invite时，你会看到一个下拉菜单，类似于[图
    7-2](text00017.html#ch07fig2)。
- en: '![Image](Image00155.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成功能会显示一个函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 按ENTER键来自动完成函数。你的光标将会移动到函数的括号内（见[图 7-3](text00017.html#ch07fig3)），Xcode已自动添加了一些占位符文本，告诉你函数期望输入的类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传入一个不是字符串的参数给invite(guest:)，例如invite(guest: 45)，你会得到一个错误，因为这个函数期望传入一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 只需输入“Cathy”或其他朋友的名字代替String，然后按TAB键完成函数调用的填写。它应该看起来像[图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用invite(guest:)三次，使用你自己朋友的名字：
- en: '[PRE61]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output looks like this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE62]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你能够快速打印出三张派对邀请函，每张都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以写一个一次性邀请所有朋友的函数，通过传入一个字符串数组作为参数，而不是一个单独的字符串。在你编写invite(guest:)函数的同一个playground中，编写下面的invite(allGuests:)函数来测试这个功能。注意，参数名称现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE63]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被放在方括号中 ➊。方括号声明数据类型为数组，String表示数组中值的数据类型。通过使用[String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们需要使用一个for-in循环来遍历我们的 guests 数组，并为每个客人打印邀请函。还记得我们刚才创建的那个打印邀请函的函数吗？我们可以在这里使用它！将以下代码添加到你的invite(allGuests:)函数中（灰色文本表示现有行）：
- en: '[PRE64]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们在`String`数组`allGuests`中的每个来宾上调用单一的`invite(guest:)`函数，邀请每个人参加生日派对。你可能会想，`invite(guest:)`和`invite(allGuests:)`是同一个函数吗？毕竟，它们的名字都是`invite`。然而，尽管名字相同，它们是两个不同的函数，因为它们接受的输入参数不同。这是Swift中常见的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`invite(allGuests:)`函数，我们首先创建一个名为`friends`的数组，然后在函数调用中使用这个数组。
- en: '[PRE65]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个包含六个朋友的数组➊。然后，我们用这个新数组作为函数的输入调用函数➋。这是你在调试控制台中看到的输出（-- snip --表示我们为了节省空间省略的行）：
- en: '[PRE66]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每一个朋友写邀请函，那将需要很多工作。但借助函数的强大功能，你只用了很少的代码行就完成了。试着创建你自己的朋友数组，长度可以任意！然后用你的新数组作为输入调用`invite(allGuests:)`函数，真是轻松愉快！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-364
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向你的来宾发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，派对日期临近，而一些来宾还没有RSVP。你想要确认最终的人数，并告知来宾带上泳衣，因为这是一个滑水派对。你可以编写一个函数，根据RSVP状态向每个来宾发送定制的信息。
- en: '![Image](Image00159.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个`String`类型的参数表示来宾的名字，另一个`Bool`类型的参数表示RSVP状态，可以是true或false。请在你的playground中输入以下代码：
- en: '[PRE67]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间添加逗号➊。每个参数都需要有一个参数名，后面跟上冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，这些参数可以是不同类型的。在`sendMessage(guest:rsvped:)`函数中，我们传入了一个`String`类型的guest和一个`Bool`类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为true➋，然后使用if-else语句打印出相应的信息。还要注意，函数定义中的最终print语句无论rsvped值是true还是false都会执行，因为它们在if-else语句的括号外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的来宾已经RSVP，他们将收到这条信息：
- en: '[PRE68]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有RSVP，他们将收到一条礼貌的提醒，要求他们做出回应：
- en: '[PRE69]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用函数看看它是如何工作的。试着将一个来宾的rsvped值设置为true，另一个设置为false，这样你就可以看到两条信息的实际效果。
- en: '[PRE70]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能将通过为你提供参数标签来帮助你填写输入值。你只需要传入你想使用的值。在填写完客人姓名后，按 TAB 键，Xcode 会将光标自动移动到下一个输入值的位置。（见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入客人姓名后按 TAB 键将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，如名字或数字，系统会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，输入值前面没有参数标签？你只需写：
- en: '[PRE71]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图添加标签，你会遇到错误：
- en: '[PRE72]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，且该标签与参数名相同。然而，如果你编写一个函数，觉得参数标签并非必须要有，以使代码更清晰，那么你可以在函数定义中显式地省略它。例如，在
    print(_:) 函数中，很明显你传入的输入是一个将被打印的字符串。如果每次调用 print(_:) 都必须包含像 inputString 这样的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为每个参数创建一个与参数名不同的参数标签。你通过在函数括号内声明参数时输入参数标签、参数名、冒号，最后是参数的数据类型来做到这一点。这通常在 Swift
    函数中使用，以使函数调用更像一个句子。[图 7-6](text00017.html#ch07fig6) 演示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，而在函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，当你调用该函数时，它会显示为
    sayHello(friend:)，这听起来不像是一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究如何编写带有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，了解如何通过添加自定义参数标签来使代码更具可读性。生日派对结束后，你会想给所有客人写感谢信。在你的 Playground 中写下以下函数：
- en: '[PRE73]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传入函数的guest参数添加了自定义参数标签to。同样，在➋处，我们为gift参数添加了参数标签for。参数名称guest ➌和gift
    ➍用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for用于在函数调用时标记参数，像这样：
- en: '[PRE74]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到to:写在函数调用的第一个输入值之前，for:写在第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名称代替会导致错误：
- en: '[PRE75]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能会始终为你填充参数标签，所以你不必担心错误地调用函数（参见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动补全了具有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常使用介词*to*、*from*或*with*作为参数标签。在这个例子中，函数用于向客人*发送*感谢信*以感谢*礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")更像是一个句子，而不是sendThankYou(guest: "Meghan", gift: "puzzle
    books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加下划线和空格来移除它们。在以下示例中，我们编写了一个计算体积的函数，它接受盒子的三个边长作为输入。因为函数名称已经清楚地说明了你需要传入三个边长，你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE76]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处将下划线放置在side1前面，在➋处放置在side2前面，以及在➌处放置在side3前面，来移除参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE77]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“The volume of this box is 72.”。如果你可以将结果存储在变量或常量中以便稍后使用，而不仅仅是打印出盒子的体积，岂不是很有用吗？让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-415
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的盒子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个可以装更多东西。首先，编写一个volumeOfBox(_:_:_:)函数，该函数返回一个Int作为盒子的体积：
- en: '[PRE78]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 要为一个函数指定返回值，在函数的输入参数后面➊使用破折号和大于符号形成一个箭头（->），然后输入返回值的数据类型。请注意，返回值不需要命名，只需指定数据类型。在函数体内，通过使用`return`关键字后跟要返回的值来返回结果➋。如果你写了一个返回值的函数，那么你*必须*在函数内部返回这个值，否则会报错。函数在返回值后结束。如果在`return`语句后面写了其他代码，它会被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数，测试两个不同的盒子，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`volumeOfBox(_:_:_:)`函数计算一个长宽高分别为6、5和3的盒子的体积，返回值90被存储在一个名为`volumeOfBox1`的常量中。在➋处，长宽高分别为8、4和2的`volumeOfBox2`被赋值为64。现在让我们打印出哪一个盒子更大：
- en: '[PRE79]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们写一个函数，它接受一个测试分数的数组并返回平均分数。为了计算平均值，你需要将所有分数加在一起，然后除以总的分数个数。请在你的Playground中输入以下代码：
- en: '[PRE80]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在➊处，我们定义了一个`Int`类型的变量`sum`并将其初始化为0。在➋处的`for-in`循环会遍历`score`数组中的每一个值并将其加到`sum`变量中。当循环完成时，变量`sum`就保存了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总个数，也就是`score.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空怎么办？你不能除以零——无论是在数学课上，还是在Swift中。在Swift中，尝试除以零会导致除零错误并崩溃你的程序。因此，在做除法时，一定要确保你将要除的数不为零，这就是我们在➌处通过检查`scores.count
    > 0`来避免的错误。在➍处，我们通过`return sum / scores.count`来返回平均值，它是通过将分数的总和除以数组中的分数数量得出的。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算得到的平均值赋给一个新变量的步骤，直接返回`sum
    / scores.count`，因为它的结果是一个`Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在`scores.count`不大于零时返回一些内容，否则会报错提示缺少返回值。我们通过在`if`语句中添加`else`来处理这个问题，返回0➎。你可以通过调用该函数来测试传入一个分数数组和一个空数组的情况：
- en: '![](Image00166.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 当你把一个完整的测试分数数组传递给`averageOf()`函数时，就像我们在➊处做的那样，返回的是分数的平均值，并显示在结果面板中。如果你传递一个空数组，就像我们在➋处做的那样，返回值是0。
- en: '**NOTE**'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这个例子中，包围`return 0`的else语句实际上并不是必要的。这是因为如果`scores.count > 0`，那么函数会在`return
    sum / scores.count`处结束。所以，如果程序已经跳过了那个if语句，我们就知道`scores.count > 0`一定不成立，此时可以直接使用`return
    0`而不需要包裹在else中。然而，如果我们保留else语句，代码会更加清晰，易于理解。有时候，为了让别人更容易理解，写一些额外的代码比使用复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚向你的Swift工具库中添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，能完成各种令人惊叹的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你能够创建具有不同于Swift内建类型的常量和变量，当你开发应用时，这会非常有用！
- en: One of the most useful tools found in every programming language is the function.
    A *function* is a block of code that you can use again and again to perform a
    specific task. You can write your own custom functions, but Swift comes with lots
    of built-in functions. You’ve already used a few, like the print(_:) function,
    which displays a string in the console.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言中最有用的工具之一就是函数。*函数*是一个代码块，你可以反复使用它来执行特定的任务。你可以编写自己的自定义函数，但Swift也提供了许多内建函数。你已经使用过一些，比如`print(_:)`函数，它会在控制台中显示一个字符串。
- en: '**IN WITH THE INPUT, OUT WITH THE OUTPUT**'
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**输入与输出**'
- en: Functions can take *input* and return *output* , although they don’t always
    have to. Input is information that you give to the function to perform its task,
    and output is something the function returns when it’s finished performing that
    task.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受*输入*并返回*输出*，尽管它们不一定总是这样。输入是你提供给函数执行任务的信息，而输出是函数在完成任务后返回的结果。
- en: The type of input that a function can take is defined in its *input parameters*
    . The values you pass in for those parameters are called *arguments* . For example,
    the string that you put between the parentheses of the print(_:) function is an
    argument. Sometimes an argument will have an *argument label* that describes it.
    The print(_:) function doesn’t have an argument label, but we’ll learn more about
    labels later in the chapter.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受的输入类型定义在其*输入参数*中。你传入这些参数的值称为*参数*。例如，你在`print(_:)`函数的括号内放入的字符串就是一个参数。有时候，参数会有一个*参数标签*来描述它。`print(_:)`函数没有参数标签，但我们将在本章稍后学习标签的相关内容。
- en: '**NOTE**'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this book, when we refer to a function with one unlabeled input parameter,
    we put a (_:) after the function name. You’ll see where that colon (: ) comes
    into play soon!*'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本书中，当我们提到一个没有标签的输入参数的函数时，我们会在函数名后加上(_:)。你很快就会明白这个冒号（:）的作用！*'
- en: 'Let’s look at an example in the playground:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在Playground中的例子：
- en: '[PRE81]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试区域（按⌘-SHIFT-Y），你将看到：
- en: '[PRE82]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: print(_:)函数接受一个输入值，但没有返回值。在这个例子中，输入值是字符串"Swift is awesome!"。print(_:)函数将在调试控制台中显示它接收到的字符串，然后结束，而不返回任何内容。没有返回值的函数有时被称为*无返回值函数*。我们将在[“返回值”](text00017.html#ch07lev1sec5)中看到一个同时具有输入参数和返回值的函数示例，详见[第91页](text00017.html#page_91)。
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写与输入和输出相关的函数，你可以创建各种各样的应用程序！
- en: '**WRITING A CUSTOM FUNCTION**'
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写自定义函数**'
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的函数，打印一个*俳句*，它是由三行组成的传统日本诗歌，第一行和最后一行有五个音节，中间一行有七个音节。将以下内容输入到你的游乐场：
- en: '[PRE83]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编写关键字func ➊ ，然后是你的函数名。当你创建一个函数时，必须给它一个名字，这样你才能在需要时调用它执行任务。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数的规则与命名变量相同：你从小写字母开始，并使用驼峰式命名法将每个新单词的首字母大写。你还应该给函数起一个能够描述其功能的名字。你不觉得printAHaiku()是一个非常合适的名字吗，它能清晰地表示一个打印简单Swift俳句的函数？
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名后面有一对圆括号 ➋ 。如果你的函数有输入参数，你会将它们放在这对括号内。在这个例子中，你没有输入参数，所以括号保持为空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被大括号括起来。这是你编写函数代码的地方。你将左大括号（{）放在与函数名同一行，右大括号（}）则单独占一行，位于函数的末尾。在这个例子中，函数的主体包含了所有打印俳句的打印语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，你只需写下它的名字，后面跟着括号和其中的参数。这就是一个*函数调用*。在这个例子中，由于printAHaiku()没有输入参数，你不需要传递任何参数——只需将括号保持为空即可。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用printAHaiku()，在函数的右大括号后，向游乐场添加以下一行：
- en: '[PRE84]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The console output is:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出为：
- en: '[PRE85]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数内部的代码会运行。确保你打开了调试区域（⌘ -SHIFT -Y），如[图7-1](text00017.html#ch07fig1)所示，这样你可以看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用printAHaiku()函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数在处理输入参数时能做更多事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，你看到了如何使用函数来节省时间和精力。当你编写一个函数时，可以在任何需要的地方调用它，而不必在多个地方重复编写相同的代码块。这当然很酷，但函数的真正强大之处在于，当你传入一个或多个输入值时，它可以产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 invite(guest:) 的函数，它接受一个人的名字作为输入，并生成一张个性化的生日派对邀请函。在你的 playground 中输入以下内容：
- en: '[PRE86]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将其包含在函数名称后的括号内 ➊。你按照参数名、冒号（:）和数据类型（在本例中为 String）来格式化输入参数。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，所以当你调用这个函数时，guest 就是参数标签。（你将在 “[参数标签](text00017.html#ch07lev1sec4)”一节中学习如何定义单独的参数名和参数标签，详见
    [第 89 页](text00017.html#page_89)。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 你在输入参数类型后面加上冒号，就像声明变量一样。然而，与声明变量不同的是，在定义函数参数时，你必须*始终*声明函数应该期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内使用输入参数，只需像使用其他常量一样使用其参数名 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数是不够的。现在函数已经定义，让我们在 playground 中调用它看看会发生什么。你可以通过输入函数名称后跟一对括号，括号内是参数标签、冒号和参数来调用带有输入参数的函数，像这样：
- en: '[PRE87]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过输入函数的名称来调用函数时，Xcode 的自动完成功能会给你提示，告诉你应该传入什么类型的值。在这种情况下，当你开始输入 invite 时，你会看到一个下拉菜单，像
    [图 7-2](text00017.html#ch07fig2) 中那样。
- en: '![Image](Image00155.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成功能会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 按 ENTER 键自动完成函数。你的光标会移动到函数的括号内（见 [图 7-3](text00017.html#ch07fig3)），此时 Xcode
    会自动添加一些占位符文本，告诉你该函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传入的不是字符串，例如调用 invite(guest: 45)，你会收到错误，因为该函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 位置输入“Cathy”或另一个朋友的名字，然后按 TAB 键完成函数调用。它应该看起来像 [图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，试着调用 invite(guest:) 三次，使用你自己朋友的名字：
- en: '[PRE88]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output looks like this:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE89]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你可以快速打印出三张派对邀请函，每张都送给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-495
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，通过传入一个字符串数组而不是单个字符串，来一次性邀请所有的朋友。在你编写 invite(guest:) 的同一个 Playground
    中，写出以下的 invite(allGuests:) 函数来进行测试。注意，参数名称现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE90]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当你声明函数的参数时，你会注意到 [String] 被放在方括号中 ➊。方括号声明数据类型为数组，而 String 表示数组中值的数据类型。通过使用
    [String]，我们声明了该函数的输入为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们希望使用一个 for-in 循环遍历我们的客人数组，并为每个客人打印一张邀请函。记得我们刚才创建了一个打印邀请函的函数吗？我们在这里也可以使用它！将以下内容添加到你的
    invite(allGuests:) 函数中（灰色文本表示现有行）：
- en: '[PRE91]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们在 String 数组 allGuests 中的每个 guest 上调用单个 invite(guest:) 函数，以邀请每个人参加生日派对。你可能会想知道
    invite(guest:) 和 invite(allGuests:) 是否是相同的函数。毕竟，它们的名称都叫做 invite。尽管它们共享一个名称，但它们是两个不同的函数，因为它们接受不同的输入参数。这是
    Swift 中经常出现的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 invite(allGuests:) 函数，我们首先创建一个名为 friends 的数组，然后在函数调用中使用它。
- en: '[PRE92]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后，我们使用这个新数组作为函数的输入来调用函数 ➋。这是你在调试控制台中看到的输出（-- snip -- 表示我们为了节省空间而省略了某些行）：
- en: '[PRE93]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友单独写出邀请函，这将是非常繁琐的工作。但是，借助函数的力量，你用非常少的代码行就完成了这个任务。尝试创建你自己的朋友数组；可以做得很长！然后，使用新的数组作为输入调用
    invite(allGuests:) 函数。轻松搞定！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-508
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期临近，而一些客人还没有回复是否参加。你想要获取最终的到场人数，并通知客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据客人的
    RSVP 状态向每个客人发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个 `String` 类型的参数用于客人姓名，和一个 `Bool` 类型的参数表示 RSVP 状态，值为 true 或
    false。请在你的 playground 中输入以下代码：
- en: '[PRE94]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数都需要有一个参数名，后面跟着冒号和数据类型。你可以创建一个接受任意数量输入参数的函数，这些参数类型不必相同。在
    `sendMessage(guest:rsvped:)` 函数中，我们传入一个 `String` 类型的 `guest` 和一个 `Bool` 类型的 `rsvped`。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 `rsvped` 的值，看看它是否为 true ➋，然后使用 if-else 语句打印相应的消息。还要注意的是，函数定义中的最终
    `print` 语句无论 `rsvped` 的值是 true 还是 false 都会执行，因为它们位于 if-else 语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已 RSVP，他们将收到这个消息：
- en: '[PRE95]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的通知，要求他们回复：
- en: '[PRE96]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。试着将一个客人的 `rsvped` 值设置为 true，将另一个客人的设置为 false，这样你就能看到两个消息的实际效果。
- en: '[PRE97]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会帮助你填充输入值，它会为你提供参数标签。你所需要做的就是传入你想要使用的值。填写完客人姓名后，按 TAB 键，Xcode 会把光标放到你需要填写下一个输入值的位置。（参见
    [图7-5](text00017.html#ch07fig5)）。
- en: '![Image](Image00160.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：在输入客人名字后按 TAB 键，光标会自动跳到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 `Bool` 替换为 true 或 false。如果你尝试传入其他类型的数据，如名字或数字，程序会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 `print(_:)` 时，你并没有在输入值前加上参数标签？你只需要写：
- en: '[PRE98]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试加入一个标签，你将会遇到错误：
- en: '[PRE99]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，且标签与参数名称相同。然而，如果你编写的函数中，认为参数标签对于代码的清晰度不是必要的，你可以在函数定义中显式省略它。例如，在
    `print(_:)` 函数中，很明显你传入的输入是一个会被打印出来的字符串。如果每次调用 `print(_:)` 都需要加上像 `inputString`
    这样的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个不同于参数名的自定义参数标签。你可以通过输入参数标签、参数名、冒号，最后是参数的数据类型来完成这一操作。所有这些操作都在你第一次声明函数括号中的参数时进行。这通常在
    Swift 函数中使用，以使函数调用更像一个句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，当你调用这个函数时，它会看起来像
    sayHello(friend:)，这听起来就不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将探讨如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-537
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，了解如何通过添加自定义参数标签来使你的代码更具可读性。在你的生日派对结束后，你会想给所有客人发送感谢信。在你的 playground
    中写下以下函数：
- en: '[PRE100]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了自定义参数标签 to。类似地，在 ➋ 处，我们为 gift 参数添加了参数标签 for。参数名 guest
    ➌ 和 gift ➍ 用于函数内部引用参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 在函数调用时用于标记参数，如下所示：
- en: '[PRE101]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 在函数调用中位于第一个输入值之前，for: 位于第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用中使用它。否则，使用参数名会导致错误：'
- en: '[PRE102]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成会始终为你填充参数标签，因此你不必担心错误地调用函数（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成具有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用来给客人发送感谢信 *to* 表示目标，*for*
    表示目的。代码 sendThankYou(to: "Meghan", for: "puzzle books") 比 sendThankYou(guest:
    "Meghan", gift: "puzzle books") 更像一个完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-550
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前加上下划线和一个空格来去除它们。在以下示例中，我们编写了一个计算体积的函数，输入为盒子的三条边。由于函数名已经明确表示需要传入三条边，因此你不需要参数标签来提高代码的可读性。
- en: '[PRE103]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处为 side1、在 ➋ 处为 side2 和在 ➌ 处为 side3 前面加上下划线，来去除这些参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用该函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE104]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。"。如果你能够将结果存储到一个变量或常量中，而不是仅仅打印出盒子的体积，岂不是更有用吗？让我们来看看如何使用返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-559
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个盒子能装更多的东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，该函数返回一个整数表示盒子的体积：
- en: '[PRE105]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数提供返回值，请在函数的输入参数后面使用一个破折号和一个大于号组成箭头 (->)，然后输入返回值的数据类型 ➊。请注意，你不需要为返回值提供名称，只需要数据类型。在函数体内，通过使用
    return 关键字后跟你想要返回的值来返回值 ➋。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在你返回值后结束。如果在
    return 语句后写任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-563
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用函数，看看它是如何运行的：
- en: '![](Image00165.jpg)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算了一个边长分别为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 volumeOfBox1
    的常量中。在 ➋ 处，边长分别为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条消息，告诉我们哪个盒子更大：
- en: '[PRE106]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-569
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，该函数接受一个测试分数的数组，并返回平均分数。为了计算平均分，你需要将所有分数加在一起，然后除以总的分数数目。请在你的
    playground 中输入以下代码：
- en: '[PRE107]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始化为 0。➋ 处的 for-in 循环遍历 scores
    数组中的每个值，并将其添加到 sum 变量中。当循环完成时，sum 变量保存了所有分数的总和。在计算完总和后，剩下的就是将其除以分数的总数，这就是 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能把什么东西除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误，并使程序崩溃。因此，在进行除法操作时，始终确保你要除的数不是零，这就是我们在
    ➌ 处通过检查 scores.count > 0 所做的事情。在 ➍ 处，我们通过将分数总和除以数组中分数的数量来返回平均值，使用 return sum /
    scores.count。没错！你可以返回任何能计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 sum / scores.count，因为它会计算出一个
    Int 类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们也需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加 else 来处理这个问题，返回
    0 ➎。你可以通过传递一个包含分数的数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-575
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 averageOf() 函数时，如我们在 ➊ 处所做，分数的平均值会被返回并显示在结果面板中。如果你传递的是一个空数组，如我们在
    ➋ 处所做，返回值则是 0。
- en: '**NOTE**'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句实际上并不是必需的。这是因为如果 scores.count > 0，那么函数已经通过 return
    sum / scores.count 结束了。所以如果程序已经通过了那个 if 语句，我们就知道 scores.count > 0 可能不成立，我们可以直接返回
    0，而不需要将其包含在 else 语句中。然而，如果我们保留 else 语句，代码会更清晰，别人也更容易理解。有时候，写一些额外的代码来让其他人更容易理解，比使用一些巧妙的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种神奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第8章](text00018.html#ch08) 中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建具有不同于 Swift 中已包含类型的常量和变量，这在你创建应用时会非常有用！
- en: '**IN WITH THE INPUT, OUT WITH THE OUTPUT**'
  id: totrans-582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**输入进，输出出**'
- en: Functions can take *input* and return *output* , although they don’t always
    have to. Input is information that you give to the function to perform its task,
    and output is something the function returns when it’s finished performing that
    task.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受*输入*并返回*输出*，尽管它们不总是需要。输入是你提供给函数的信息，以便函数执行其任务，而输出是函数在完成任务后返回的内容。
- en: The type of input that a function can take is defined in its *input parameters*
    . The values you pass in for those parameters are called *arguments* . For example,
    the string that you put between the parentheses of the print(_:) function is an
    argument. Sometimes an argument will have an *argument label* that describes it.
    The print(_:) function doesn’t have an argument label, but we’ll learn more about
    labels later in the chapter.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受的输入类型在其*输入参数*中定义。你传递给这些参数的值被称为*参数*。例如，你放在 print(_:) 函数的括号中的字符串就是一个参数。有时，一个参数会有一个*参数标签*来描述它。print(_:)
    函数没有参数标签，但我们稍后会在本章中学习更多关于标签的内容。
- en: '**NOTE**'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this book, when we refer to a function with one unlabeled input parameter,
    we put a (_:) after the function name. You’ll see where that colon (: ) comes
    into play soon!*'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本书中，当我们提到一个没有标签的输入参数的函数时，我们会在函数名后面加上 (_:)。你很快就会看到这个冒号（:）的作用！*'
- en: 'Let’s look at an example in the playground:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在游乐场中看一个示例：
- en: '[PRE108]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试区域（按 ⌘ -SHIFT -Y），你会看到：
- en: '[PRE109]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: print(_:) 函数接受一个输入值，但没有返回值。在这个例子中，输入值是字符串 "Swift is awesome!"。print(_:) 函数将它显示在调试控制台中，然后结束而不返回任何内容。没有返回值的函数有时称为*空函数*。我们将在
    “[返回值](text00017.html#ch07lev1sec5)” 中，页面 [91](text00017.html#page_91) 看到一个既有输入参数又有返回值的函数示例。
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写与输入一起工作的函数并返回输出，你可以创建各种应用程序！
- en: '**WRITING A CUSTOM FUNCTION**'
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写自定义函数**'
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的函数，打印一个*俳句*，这是一种传统的日本诗歌，由三行组成，第一行和最后一行各有五个音节，中间一行有七个音节。将以下内容输入到你的游乐场中：
- en: '[PRE110]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你编写关键字 func ➊，然后是函数的名称。当你创建一个函数时，必须给它起个名字，以便在需要时调用它来执行任务。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 函数命名的规则与变量命名相同：你以小写字母开头，并使用驼峰式命名法将每个新单词的首字母大写。你还应该给你的函数起一个描述其功能的名字。你不觉得 printAHaiku()
    是一个打印简单 Swift 俳句的好函数名吗？
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名后面，有一对圆括号 ➋。如果你的函数有输入参数，你会将它们包含在这些括号内。在这个例子中，你没有输入参数，因此你可以将括号留空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*用大括号括起来。这是你编写函数代码的地方。你把左大括号（{）放在与函数名同一行，右大括号（}）放在函数末尾的单独一行。在这个例子中，函数的主体包含所有打印俳句的
    print 语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-600
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用函数，你只需写出它的名字，后面跟着括号和其中的任何参数。这就是*函数调用*。在这个例子中，由于printAHaiku()没有输入参数，你不需要传递任何参数——只需保持括号为空。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用printAHaiku()，在函数的闭括号后，向playground中添加以下行：
- en: '[PRE111]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The console output is:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出为：
- en: '[PRE112]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数内部的代码将会运行。确保你已经打开调试区域（⌘ -SHIFT -Y），就像在[图 7-1](text00017.html#ch07fig1)中所示，这样你就能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-607
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用printAHaiku()函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数可以做更多事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，你看到函数如何节省时间和精力。当你编写一个函数时，你可以在任何地方调用它，而不是在多个地方重复代码块。这无疑很酷，但函数的真正威力在于，当你传入一个或多个输入值时，可以产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-612
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为invite(guest:)的函数，它接受一个人的名字作为输入，并为生日派对创建一个个性化的邀请函。将以下内容输入到你的playground中：
- en: '[PRE113]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将它放在函数名后面的括号中 ➊。你格式化输入参数时，首先写出它的名字（在这个例子中是guest），然后是冒号（:），最后是它的数据类型（在这个例子中是String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当了参数标签，所以当你调用这个函数时，guest将作为参数标签。（你将在 “[参数标签](text00017.html#ch07lev1sec4)”一节中学习如何定义单独的参数名和参数标签，参考[第89页](text00017.html#page_89)）。
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 你在输入参数后面写上数据类型，就像声明变量一样。然而，与变量声明不同，在定义函数参数时，你*必须*始终声明函数应该期望的数据类型；这里不会进行类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-618
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数中使用输入参数，你只需像使用其他常量一样使用它的参数名➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数并不够。现在函数已经定义，让我们在playground中调用它，看看会发生什么。你可以通过输入函数名，后跟括号，括号内是参数标签、冒号和参数，来调用带有输入参数的函数，像这样：
- en: '[PRE114]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写出函数名来调用函数时，Xcode的自动补全功能会给你提示，告诉你应该传递什么参数到函数中。在这种情况下，当你开始输入invite时，你将看到一个下拉菜单，像[图
    7-2](text00017.html#ch07fig2)中所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-623
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：Xcode的自动完成功能会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 按ENTER键以自动完成函数。你的光标将移动到函数的括号内（见[图7-3](text00017.html#ch07fig3)），在这里Xcode已经自动添加了一些占位文本，告诉你函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：Xcode等待你填写guest参数。*'
- en: '**NOTE**'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递一个非字符串的参数给invite(guest:)，比如invite(guest: 45)，你会得到一个错误，因为该函数期望接收一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在String的位置输入"Cathy"或其他朋友的名字，然后按TAB键完成函数调用的填写。它应该像[图7-4](text00017.html#ch07fig4)那样显示。
- en: '![Image](Image00157.jpg)'
  id: totrans-631
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：invite(guest:)函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，请调用invite(guest:)函数三次，使用你朋友的名字：
- en: '[PRE115]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The output looks like this:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE116]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你可以快速打印出三张派对邀请函，每张都邀请不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-638
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个一次性邀请所有朋友的函数，通过传递一个字符串数组作为参数，而不是传递单个字符串。在你编写了invite(guest:)函数的同一个playground中，编写以下invite(allGuests:)函数来进行测试。注意，现在参数名是复数形式的，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE117]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]用方括号括起来了➊。方括号声明数据类型为数组，String表示数组中值的数据类型。通过使用[String]，我们声明这个函数的输入为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们需要使用一个for-in循环遍历我们的guest数组，并为每个客人打印一张邀请函。还记得我们刚才创建的打印邀请函的函数吗？让我们在这里使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本表示现有的行）：
- en: '[PRE118]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个guest调用单数形式的invite(guest:)函数，邀请每个参与者参加生日派对。你可能会问，invite(guest:)和invite(allGuests:)是否是相同的函数。毕竟，它们的名称都是invite。然而，尽管它们的名称相同，它们实际上是两个不同的函数，因为它们接收不同的输入参数。这是你在Swift中经常会看到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE119]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组➊。然后我们使用这个新数组作为函数的输入来调用该函数➋。这是你在调试控制台中看到的输出（-- snip --表示我们为节省空间而省略的部分）：
- en: '[PRE120]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您必须为每个朋友写邀请函，那将是一项繁重的工作。但借助函数的强大功能，您只需要几行代码就完成了这项工作。尝试创建您自己的朋友数组；可以根据需要设定数组的长度！然后，使用您的新数组作为输入，调用
    invite(allGuests:) 函数。简直轻松如意！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-651
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给您的嘉宾发送信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您的派对日期临近，但有些嘉宾尚未 RSVP。您想要最终确定人数，并让嘉宾们知道带上泳衣，因为这将是一个滑水派对。您可以编写一个函数，根据每个嘉宾的
    RSVP 状态发送定制信息。
- en: '![Image](Image00159.jpg)'
  id: totrans-653
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新函数将接受两个输入参数：一个用于嘉宾姓名的 String 类型参数，以及一个表示 RSVP 状态的 Bool 类型参数，它的值可以是 true 或
    false。在您的 Playground 中输入以下代码：
- en: '[PRE121]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数有多个输入参数时，您需要在每个参数之间加上逗号 ➊。每个参数都需要有一个参数名，后跟冒号和数据类型。您可以创建一个接受任意数量输入参数的函数，且这些参数不必是相同类型。在
    sendMessage(guest:rsvped:) 函数中，我们传入了一个 String 类型的 guest 和一个 Bool 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 值是否为 true ➋，然后使用 if-else 语句打印相应的消息。请注意，函数定义中的最后一条打印语句无论 rsvped
    值是 true 还是 false 都会运行，因为它们位于 if-else 语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的嘉宾已 RSVP，他们将收到以下信息：
- en: '[PRE122]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的通知，要求他们做出回应：
- en: '[PRE123]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。试着将一位嘉宾的 RSVPed 值设置为 true，另一位嘉宾的设置为 false，这样您就能看到两种信息的实际效果。
- en: '[PRE124]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，调用一个具有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全将帮助您填写输入值，提供参数标签。您只需要传入您想使用的值。输入完嘉宾名字后，按下 TAB 键，Xcode 会将光标移到下一个输入字段，方便您填写下一个输入值。（参见[图
    7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-666
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入完嘉宾名字后按 TAB 键会将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉您 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果您尝试传入其他任何内容，例如名字或数字，您将会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-669
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到，当调用 print(_:) 时，您没有在输入值前加上参数标签？您应该写成：
- en: '[PRE125]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试包含一个标签，您将会遇到错误：
- en: '[PRE126]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且该标签与参数名称相同。然而，如果你编写一个函数，并且觉得参数标签对代码的清晰度没有帮助，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，传入的显然是一个将被打印的字符串。如果每次调用 print(_:) 都需要添加像 inputString 这样的参数标签，那会非常麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号以及最后的参数数据类型来做到这一点。所有这些操作都在你第一次声明函数括号中的参数时进行。这在
    Swift 函数中经常使用，使得函数调用更像一个完整的句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-676
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用时传入的参数是 "Colin"。如果没有单独的参数标签，调用该函数时将变成
    sayHello(friend:)，这听起来不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将学习如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-680
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，展示如何通过添加自定义参数标签使代码更易读。生日派对后，你会想给所有客人写感谢信。在你的 Playground 中编写以下函数：
- en: '[PRE127]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们给传入函数的 guest 参数添加了自定义参数标签 to。同样，在 ➋ 处，我们给 gift 参数添加了参数标签 for。参数名称 guest
    ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，像这样：
- en: '[PRE128]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 被写在第一个输入值前，而 for: 被写在第二个输入值前。如果一个参数有自定义的参数标签，那么在函数调用时必须使用它。试图使用参数名称而不是标签将导致错误：'
- en: '[PRE129]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会为你填充参数标签，所以你无需担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-689
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于发送感谢信 *to* 客人 *for* 礼物。代码
    sendThankYou(to: "Meghan", for: "puzzle books") 读起来更像一句话，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-692
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-693
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前添加一个下划线和空格来移除它们。在以下示例中，我们编写了一个用于计算体积的函数，该函数接受一个箱子的三个边长作为输入。由于函数名已经清晰地表明你需要传入三个边长，因此你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE130]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处在 side1 前加下划线，在 ➋ 处在 side2 前加下划线，在 ➌ 处在 side3 前加下划线来移除边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，你只需要输入参数值，而不需要任何标签。
- en: '[PRE131]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "The volume of this box is 72."。如果你能够把结果存储到一个变量或常量中，以便稍后使用，而不仅仅是打印箱子的体积，这不是更有用吗？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-700
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，改为返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-702
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的箱子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的箱子，想知道哪个能装更多的东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，返回一个表示箱子体积的 Int：
- en: '[PRE132]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数添加返回值，可以在函数的输入参数之后使用破折号和大于号组合成箭头 (->)，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，使用
    return 关键字后跟你想要返回的值来返回该值 ➋。如果你编写一个返回值的函数，那么你*必须*在函数内返回该值，否则会发生错误。函数在返回值后结束。如果你在
    return 语句之后在函数内编写任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-706
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的箱子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-708
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算了边长为 6、5 和 3 的箱子的体积，返回值 90 被存储在名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条关于哪个箱子更大的消息：
- en: '[PRE133]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台中看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-712
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，接受一个测试分数数组，并返回平均分。为了得到平均分，你需要将分数加起来，然后除以总的分数数量。在你的
    Playground 中输入以下代码：
- en: '[PRE134]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始化为 0。位于 ➋ 处的 `for-in`
    循环遍历 `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成后，`sum` 变量保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数量，这就是简单的
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空怎么办？你不能将数字除以零——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并使程序崩溃。因此，在进行除法运算时，始终确保你要除的数字不为零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来实现的。在 ➍ 处，我们通过将总分除以数组中分数的个数来返回平均值，使用 `return sum /
    scores.count`。没错！你可以返回任何评估为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 `sum /
    scores.count`，因为它评估为 `Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们还需要返回某个值，否则会报错提示函数缺少返回值。我们通过在 `if` 语句中添加 `else`
    来处理这个问题，在 `else` 中返回 0 ➎。你可以通过调用这个函数，分别传入一个分数数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-718
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传入 `averageOf()` 函数时，正如我们在 ➊ 所做的那样，函数会返回并显示分数的平均值。如果你传入一个空数组，正如我们在
    ➋ 所做的那样，返回值将是 0。
- en: '**NOTE**'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，`return 0` 周围的 `else` 语句实际上并不是必需的。这是因为如果 `scores.count > 0`，那么函数已经通过
    `return sum / scores.count` 结束了。所以如果计算机已经跳过了那个 `if` 语句，我们就知道 `scores.count > 0`
    肯定不成立，我们可以直接写 `return 0`，而不需要将它放在 `else` 语句中。不过，如果我们保留 `else` 语句，代码会更清晰、更容易理解。有时候，为了让别人更容易理解代码，写一些多余的代码比使用复杂的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-722
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让您创建除 Swift 中已包含的类型之外的常量和变量，这在创建应用时非常有用！
- en: Functions can take *input* and return *output* , although they don’t always
    have to. Input is information that you give to the function to perform its task,
    and output is something the function returns when it’s finished performing that
    task.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受*输入*并返回*输出*，尽管它们不一定总是如此。输入是您提供给函数以执行任务的信息，输出是函数完成任务后返回的内容。
- en: The type of input that a function can take is defined in its *input parameters*
    . The values you pass in for those parameters are called *arguments* . For example,
    the string that you put between the parentheses of the print(_:) function is an
    argument. Sometimes an argument will have an *argument label* that describes it.
    The print(_:) function doesn’t have an argument label, but we’ll learn more about
    labels later in the chapter.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受的输入类型由其*输入参数*定义。您传递给这些参数的值称为*实参*。例如，您在 `print(_:)` 函数的圆括号中放入的字符串就是一个实参。有时，实参会有一个*实参标签*来描述它。`print(_:)`
    函数没有实参标签，但我们将在本章稍后了解更多有关标签的内容。
- en: '**NOTE**'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this book, when we refer to a function with one unlabeled input parameter,
    we put a (_:) after the function name. You’ll see where that colon (: ) comes
    into play soon!*'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本书中，当我们提到一个带有一个无标签输入参数的函数时，我们会在函数名称后加上 (_:)，您将很快看到这个冒号(:)的作用！*'
- en: 'Let’s look at an example in the playground:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Playground 中看一个示例：
- en: '[PRE135]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试区域（按⌘ -SHIFT -Y）中，您会看到：
- en: '[PRE136]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(_:)` 函数接受一个输入值，但没有返回值。在这个例子中，输入值是字符串 "Swift is awesome!"。`print(_:)`
    函数将它接收到的字符串显示在调试控制台中，然后结束，不返回任何内容。没有返回值的函数有时称为*无返回值函数*。我们将在[《返回值》](text00017.html#ch07lev1sec5)一节中看到一个既有输入参数又有返回值的函数示例，见[第91页](text00017.html#page_91)。'
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写可以处理输入并返回输出的函数，您可以创建各种应用程序！
- en: '**WRITING A CUSTOM FUNCTION**'
  id: totrans-735
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写自定义函数**'
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的函数，打印一个*俳句*，它是一种传统的日本诗歌，由三行组成，第一行和最后一行各有五个音节，中间一行有七个音节。请将其输入到您的 Playground
    中：
- en: '[PRE137]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您写下 `func` 关键字 ➊，然后是您函数的名称。创建函数时，必须为它指定一个名称，以便在需要它执行任务时调用它。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数的规则与命名变量的规则相同：以小写字母开头，并使用驼峰命名法将名称中的每个新单词首字母大写。您还应该为您的函数命名，以便描述它的功能。您不觉得
    `printAHaiku()` 是一个很好的函数名称吗，它表示一个打印简单 Swift 俳句的函数？
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名称后面，有一对圆括号 ➋。如果您的函数有输入参数，您应将它们包含在这些圆括号内。在此示例中，您没有任何输入参数，所以只需将圆括号留空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被括号包围。这是你编写函数代码的地方。你将左括号({)与函数名写在同一行，右括号（}）则独立写在函数结尾的下一行。在此示例中，函数主体包含了所有打印haiku的print语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-742
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，你只需写出它的名称，后面跟上括号并传入任何参数。这就是*函数调用*。在这种情况下，由于printAHaiku()没有输入参数，你不需要传递任何参数——只需保持括号为空即可。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用printAHaiku()，在函数的右括号后添加以下一行代码：
- en: '[PRE138]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The console output is:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出为：
- en: '[PRE139]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数内部的代码将会执行。确保打开调试区域（⌘ -SHIFT -Y），如[图7-1](text00017.html#ch07fig1)所示，这样你就可以看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-749
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用printAHaiku()函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-752
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数对输入参数的使用更加丰富**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，你看到了函数如何帮助你节省时间和精力。当你编写一个函数时，你可以在任何需要的地方调用它，而不必在多个地方重复写相同的代码块。这当然很酷，但函数的真正威力体现在你传入一个或多个输入值时，能够产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-754
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个名为invite(guest:)的函数，它接收一个人的名字作为输入，并创建一个个性化的生日派对邀请。请在你的游乐场中输入以下内容：
- en: '[PRE140]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将它包含在函数名称后的括号中 ➊。你格式化输入参数时，首先写出它的名称（在此示例中为guest），然后是冒号（:），最后是它的数据类型（此处为String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名称还充当参数标签，因此当你调用这个函数时，guest将作为参数标签。（你将在“[参数标签](text00017.html#ch07lev1sec4)”中了解如何定义单独的参数名称和参数标签，参见[第89页](text00017.html#page_89)。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 你在输入参数后的冒号后写出其数据类型，就像声明一个变量时一样。但是，与变量声明不同，在定义函数参数时，你*必须*始终声明函数应该期待的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-760
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需使用它的参数名称，就像使用任何常量一样 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数是不够的。既然函数已经定义好了，让我们在playground中调用它，看看会发生什么。你可以通过输入函数名，后跟括号内的参数标签、冒号和参数，来调用一个带有输入参数的函数，像这样：
- en: '[PRE141]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写出函数名来调用一个函数时，Xcode的自动补全会给出提示，告诉你应该传递什么内容给函数。在这个例子中，当你开始写invite时，你会看到像[图
    7-2](text00017.html#ch07fig2)中那样的下拉菜单。
- en: '![Image](Image00155.jpg)'
  id: totrans-765
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode的自动补全会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 按下ENTER键自动完成函数。光标将移动到函数的括号内（见[图 7-3](text00017.html#ch07fig3)），此时Xcode已自动添加了一些占位文本，告诉你该函数期待的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-768
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode正在等待你填写来宾参数。*'
- en: '**NOTE**'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递给invite(guest:)的参数不是字符串，比如invite(guest: 45)，你会得到一个错误，因为该函数期待的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 只需输入“Cathy”或其他朋友的名字来替换String，然后按TAB键完成函数调用的填写。它应该像[图 7-4](text00017.html#ch07fig4)那样显示。
- en: '![Image](Image00157.jpg)'
  id: totrans-773
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个invite(guest:)函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用invite(guest:)三次，使用你自己朋友的名字：
- en: '[PRE142]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The output looks like this:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE143]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你可以快速打印三张聚会邀请函，每张邀请函都发送给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-780
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次邀请所有你的朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写一个一次性邀请所有朋友的函数，通过传递一个字符串数组作为参数，而不是单个字符串。在你编写invite(guest:)函数的同一个playground中，编写以下invite(allGuests:)函数来进行测试。注意，参数名现在是复数形式，因为我们将一次邀请多个来宾。
- en: '![Image](Image00158.jpg)'
  id: totrans-782
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00158.jpg)'
- en: '[PRE144]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]是用方括号括起来的➊。方括号声明数据类型为数组，而String表示数组中元素的类型。通过使用[String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内，我们希望使用for-in循环遍历我们的来宾数组，并为每个来宾打印邀请函。记得我们刚刚创建了一个打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本显示的是已有行）：
- en: '[PRE145]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个客人调用单一的invite(guest:)函数，邀请每个客人参加生日派对。你可能会想知道invite(guest:)和invite(allGuests:)是不是同一个函数。毕竟它们的名称都叫invite。尽管名字相同，它们实际上是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常会看到的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用这个数组。
- en: '[PRE146]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后我们用这个新数组作为函数的输入，调用该函数 ➋。这是你在调试控制台中看到的输出（-- snip --表示我们为节省空间省略的行）：
- en: '[PRE147]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为每个朋友单独写邀请函，那会花费很多工作量。但借助函数的强大功能，你只需要写很少几行代码就能完成这个任务。尝试创建你自己的朋友数组，长度随你所愿！然后使用新的数组作为输入调用invite(allGuests:)函数。简直轻松！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-793
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你派对的日期临近，一些客人还没有回复是否参加。你想要得到最终的参加人数，并告诉客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据每个客人的RSVP状态，向他们发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-795
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将需要两个输入参数：一个String类型的参数代表客人的名字，一个Bool类型的参数代表RSVP状态，值为true或false。请在你的playground中输入以下代码：
- en: '[PRE148]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数需要多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数需要有一个参数名，后面跟着冒号和参数的数据类型。你可以创建一个包含任意多个输入参数的函数，它们不需要是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传递了一个String类型的guest和一个Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为true ➋，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最后打印语句无论rsvped值是true还是false都会执行，因为它们位于if-else语句的花括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客人已经RSVP，他们将收到以下消息：
- en: '[PRE149]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的通知，要求他们回复：
- en: '[PRE150]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一位客人的rsvped值设置为true，另一位客人的rsvped值设置为false，这样你就能看到两条消息的实际效果。
- en: '[PRE151]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能将通过提供参数标签来帮助你填写输入值。你只需要传入你想使用的值。填写完宾客姓名后，按下 TAB 键，Xcode 会将光标定位到你需要的地方，以便填写下一个输入值。（参见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-808
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入宾客姓名后按 TAB 键会将光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你试图传入其他内容，比如名字或数字，你将得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-811
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到在调用 `print(_:)` 时，输入值前面没有参数标签吗？你只需要写：
- en: '[PRE152]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你将得到一个错误：
- en: '[PRE153]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数调用中有参数标签，有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，且其值与参数名称相同。然而，如果你编写的函数中，认为不需要参数标签来清晰地表达代码，那么你可以在函数定义中显式省略它。例如，在
    `print(_:)` 函数中，很明显你传入的输入值是一个要打印的字符串。如果每次调用 `print(_:)` 都必须包括类似 `inputString`
    这样的参数标签，那会非常麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。在你第一次声明函数内的参数时，在
    `func` 关键字后面的圆括号内完成这一切。Swift 函数中经常这样做，以使函数调用更像一个完整的句子。[图 7-6](text00017.html#ch07fig6)展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-818
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 `friend`，参数标签是 `to`，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，在调用该函数时看起来会像是
    `sayHello(friend:)`，这就不像一个完整的句子了。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将介绍如何编写带有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-822
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例，看看如何通过添加自定义参数标签使代码更加易读。生日派对结束后，你会想给所有宾客寄送感谢卡片。你可以在 Playground 中编写以下函数：
- en: '[PRE154]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将自定义参数标签 `to` 添加到传递给函数的 guest 参数中。类似地，在 ➋ 处，我们将参数标签 `for` 添加到 gift 参数中。参数名称
    `guest` ➌ 和 `gift` ➍ 用于函数内部引用参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 `to` 和 `for` 用于在函数调用时标记参数，如下所示：
- en: '[PRE155]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到，`to:` 在函数调用时写在第一个输入值之前，`for:` 写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。否则，尝试使用参数名称会导致错误：
- en: '[PRE156]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填充正确的参数标签，因此你不必担心函数调用不正确（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-831
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信，*to* 表示“给”，*for*
    表示“为”。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 读起来更像是一个句子，而不是 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-834
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-835
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线和一个空格来移除它们。在下面的示例中，我们编写了一个计算体积的函数，它接受三个盒子的边长作为输入。因为函数名已经明确说明需要传入三个边长，因此实际上不需要参数标签来提高代码的可读性。
- en: '[PRE157]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处将下划线添加到 `side1`，在 ➋ 处添加到 `side2`，在 ➌ 处添加到 `side3`，来移除这些参数的标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，而无需任何标签。
- en: '[PRE158]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。" 如果你可以将结果存储到一个变量或常量中以便稍后使用，而不仅仅是打印盒子的体积，那不是很有用吗？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-842
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-844
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的盒子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并想知道哪个能装更多的东西。首先，编写一个 `volumeOfBox(_:_:_:)` 函数，返回盒子的体积（类型为 Int）：
- en: '[PRE159]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数返回一个值，可以在函数的输入参数后使用一个破折号和一个大于号（->）来表示箭头（➊），然后输入返回值的数据类型。请注意，返回值不需要提供名称，只需要提供数据类型。在函数体内，使用return关键字后跟要返回的值来返回结果（➋）。如果你编写的函数需要返回一个值，那么你*必须*在函数内返回该值，否则会报错。函数在返回值后结束。如果在return语句后再写任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-848
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-850
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算了一个边长分别为6、5和3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋处，边长分别为8、4和2的盒子被赋值为64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE160]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台中看到字符串"Box 1 is the bigger box."的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-854
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接受一个测试分数的数组并返回平均分。为了得到平均分，你需要将所有分数相加，然后除以总的分数数目。在你的Playground中输入以下代码：
- en: '[PRE161]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要求出所有值的总和。在➊处，我们定义了一个名为sum的Int变量，并将其初始值设为0。➋处的for-in循环遍历scores数组中的每个值，并将其加到sum变量中。当循环完成时，sum变量就保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，简单来说就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 可是如果数组为空呢？你不能用零去除任何东西——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除零错误，并使程序崩溃。因此，在进行除法时，始终确保你将要除的数字不是零，这就是我们在➌处通过检查scores.count
    > 0来确保的。在➍处，我们通过将分数总和除以数组中的分数数量来返回平均值，代码是return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回sum
    / scores.count，因为它计算出的结果是一个Int类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们也需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在if语句中添加else来处理这个问题，返回0（➎）。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-860
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传入 averageOf() 函数时，就像我们在 ➊ 处所做的，函数将返回并显示分数的平均值。如果传入一个空数组，如我们在
    ➋ 处所做的，返回值将是 0。
- en: '**NOTE**'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句其实并不是必须的。这是因为如果 scores.count > 0，那么函数已经通过 return
    sum / scores.count 结束了。所以，如果计算机已经执行到那条 if 语句之后，我们可以知道 scores.count > 0 一定不为真，这时我们只需返回
    0，而无需将其放在 else 语句中。然而，如果我们保留 else 语句，代码会更清晰，更容易理解。有时候，为了让代码更易懂，写一些额外的代码比使用一些巧妙的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-864
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中广泛使用，可以做各种各样的精彩事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建除 Swift 内建类型之外的常量和变量，这对开发应用程序时非常有用！
- en: The type of input that a function can take is defined in its *input parameters*
    . The values you pass in for those parameters are called *arguments* . For example,
    the string that you put between the parentheses of the print(_:) function is an
    argument. Sometimes an argument will have an *argument label* that describes it.
    The print(_:) function doesn’t have an argument label, but we’ll learn more about
    labels later in the chapter.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受的输入类型在其*输入参数*中定义。你为这些参数传入的值称为*参数*。例如，你放在 print(_:) 函数括号中的字符串就是一个参数。有时，参数会有一个*参数标签*来描述它。print(_:)
    函数没有参数标签，但我们将在本章稍后学习更多关于标签的内容。
- en: '**NOTE**'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this book, when we refer to a function with one unlabeled input parameter,
    we put a (_:) after the function name. You’ll see where that colon (: ) comes
    into play soon!*'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本书中，当我们提到一个只有一个未标记输入参数的函数时，我们会在函数名后加上 (_:)。你很快就会看到这个冒号 (:) 的作用！*'
- en: 'Let’s look at an example in the playground:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在 Playground 中的例子：
- en: '[PRE162]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试区域（按 ⌘ -SHIFT -Y）中，你将看到：
- en: '[PRE163]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: print(_:) 函数接受一个输入值，但没有返回值。在这个例子中，输入值是字符串 "Swift is awesome!"。print(_:) 函数将在调试控制台中显示这个字符串，然后结束并不返回任何值。没有返回值的函数有时被称为*空函数*。我们将在“[返回值](text00017.html#ch07lev1sec5)”中看到一个既有输入参数又有返回值的函数实例，参见[第
    91 页](text00017.html#page_91)。
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写处理输入并返回输出的函数，你可以创建各种各样的应用程序！
- en: '**WRITING A CUSTOM FUNCTION**'
  id: totrans-876
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写自定义函数**'
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的函数，打印一个*俳句*，它是一个传统的日本诗歌，通常由三行组成，第一行和第三行有五个音节，中间一行有七个音节。将以下代码输入到 Playground
    中：
- en: '[PRE164]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，写出func关键字 ➊，然后是你的函数名称。当你创建一个函数时，你必须给它取个名字，这样你才可以在需要它执行任务时调用它。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数的规则与命名变量相同：函数名以小写字母开头，后续每个新单词的首字母大写，采用驼峰命名法。你还应当为你的函数取一个描述其功能的名字。你不觉得printAHaiku()是一个很适合用来打印简单Swift俳句的函数名吗？
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名称后面，会有一对括号 ➋。如果你的函数有输入参数，你需要将它们放在这些括号内。在这个例子中，你没有输入参数，所以只需将括号留空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被括号包围。这是你编写函数代码的地方。你将左括号（{）放在与函数名同一行，右括号（}）则放在函数末尾的单独一行。在这个例子中，函数主体包含了所有打印俳句的print语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-883
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，你只需写出它的名称，后面跟上括号，并在括号内传入任何参数。这是一个*函数调用*。在这个例子中，因为printAHaiku()没有输入参数，你不需要传入任何参数——只需将括号留空即可。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用printAHaiku()，请在函数的右括号后，在Playground中添加以下代码：
- en: '[PRE165]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'The console output is:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出为：
- en: '[PRE166]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以在任何时候调用它，函数中的代码就会执行。确保你已经打开了调试区域（⌘ -SHIFT -Y），如[图 7-1](text00017.html#ch07fig1)所示，这样你就可以看到结果了。
- en: '![Image](Image00153.jpg)'
  id: totrans-890
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用printAHaiku()函数吧！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-893
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数能做更多事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，你看到了函数如何为你节省时间和精力。当你写一个函数时，你可以在任何地方调用它，而不需要在多个地方重复代码块。这当然很酷，但函数的真正威力在于你传入一个或多个输入值来生成不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-895
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个名为invite(guest:)的函数，它接受一个人的名字作为输入，并生成一个个性化的生日派对邀请函。请将以下内容输入到你的Playground中：
- en: '[PRE167]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将其包含在函数名后面的括号内 ➊。你需要先写出输入参数的名称（在这个例子中是guest），然后是冒号（:），最后是它的数据类型（在这个例子中是String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名称也充当了参数标签，因此当你调用这个函数时，`guest`将作为参数标签。（你将在“[参数标签](text00017.html#ch07lev1sec4)”一节的[第89页](text00017.html#page_89)学习如何定义单独的参数名称和参数标签。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后面写出输入参数的数据类型，就像声明变量时一样。然而，与变量声明不同，在定义函数参数时，你必须*始终*声明函数应该期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-901
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数中使用输入参数，你只需要使用其参数名称，就像使用任何其他常量一样 ➋ 。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数还不够。现在函数已经定义好，让我们在 playground 中调用它，看看会发生什么。你可以通过输入函数名，后跟括号中的参数标签、冒号以及参数值，来调用带有输入参数的函数，像这样：
- en: '[PRE168]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名来调用函数时，Xcode 的自动补全会给你提供提示，告诉你应该传入什么类型的参数。在这种情况下，当你开始输入`invite`时，你会看到一个下拉菜单，像[图
    7-2](text00017.html#ch07fig2)那样。
- en: '![Image](Image00155.jpg)'
  id: totrans-906
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动补全会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键来自动补全函数。你的光标将进入函数的括号中（参见[图 7-3](text00017.html#ch07fig3)），在这里，Xcode
    已经自动添加了一些占位符文本，告诉你函数期望什么类型的输入。
- en: '![Image](Image00156.jpg)'
  id: totrans-909
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递了一个非字符串类型给`invite(guest:)`，比如`invite(guest: 45)`，你将得到一个错误，因为该函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 位置输入 "Cathy" 或其他朋友的名字，然后按 TAB 键完成函数调用的填写。它应该看起来像[图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-914
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个`invite(guest:)`函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，尝试三次调用`invite(guest:)`，并使用你自己朋友的名字：
- en: '[PRE169]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The output looks like this:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来是这样的：
- en: '[PRE170]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的`invite(guest:)`函数，你能够快速打印出三张派对邀请函，每一张都发给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-921
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过传入一个包含多个字符串的数组作为参数，而不是单个字符串，来编写一个可以一次邀请所有朋友的函数。在你编写了`invite(guest:)`的同一个
    playground 中，编写以下的`invite(allGuests:)`函数来进行测试。注意，现在参数名称是复数形式，因为我们将一次邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-923
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE171]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到 [String] 被放在方括号中➊。方括号声明了数据类型是一个数组，String 表示数组中每个元素的数据类型。通过使用
    [String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们希望使用 for-in 循环来遍历我们的客人数组，并为每个客人打印邀请函。记得我们刚刚创建了一个打印邀请函的函数吗？我们就在这里使用它！将以下内容添加到
    invite(allGuests:) 函数中（灰色文本显示的是现有的行）：
- en: '[PRE172]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们对字符串数组 allGuests 中的每个 guest 调用单一的 invite(guest:) 函数，邀请每个人参加生日派对。你可能会想，invite(guest:)
    和 invite(allGuests:) 是不是同一个函数。毕竟，它们的名字都是 invite。然而，尽管名字相同，它们是两个不同的函数，因为它们接受不同的输入参数。这是你在
    Swift 中经常会看到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 invite(allGuests:) 函数，我们首先创建一个名为 friends 的数组，然后将其用作函数调用中的输入。
- en: '[PRE173]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个包含六个朋友的数组➊。然后我们用新的数组作为函数的输入来调用这个函数➋。这是你在调试控制台中看到的输出（-- snip -- 显示了我们为节省空间而省略的行）：
- en: '[PRE174]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友写出邀请函，那会非常麻烦。但凭借函数的强大功能，你可以用非常少的代码行完成这一切。试着创建你自己的朋友数组，长度可以随便定！然后用你的新数组作为输入调用
    invite(allGuests:) 函数。简直轻松愉快！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-934
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，派对的日期快到了，而一些客人还没有回复是否参加。你希望得到最终的客人名单，并告诉客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据每个客人的
    RSVP 状态发送个性化的消息给他们。
- en: '![Image](Image00159.jpg)'
  id: totrans-936
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个字符串类型的参数，用于表示客人的名字，另一个布尔类型的参数，用于表示 RSVP 状态，它的值可以是 true 或 false。请在你的
    playground 中输入以下代码：
- en: '[PRE175]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号➊。每个参数都需要有一个参数名，后跟冒号和该参数的数据类型。你可以创建一个接受任意数量输入参数的函数，并且这些参数的类型不必相同。在
    sendMessage(guest:rsvped:) 函数中，我们传入一个字符串作为 guest 和一个布尔值作为 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 的值，看它是否为 true ➋，然后使用 if-else 语句打印相应的消息。还要注意，函数定义中的最后一条打印语句无论
    rsvped 的值是 true 还是 false 都会执行，因为它们在 if-else 语句的括号外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复了邀请，他们将收到以下信息：
- en: '[PRE176]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提示，要求他们回复：
- en: '[PRE177]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一个客人的 rsvped 值设置为 true，另一个客人的设置为 false，这样你就能看到两条消息的实际效果。
- en: '[PRE178]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调用一个有多个输入参数的函数和调用一个只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会帮助你通过提供参数标签来填充输入值。你所需要做的就是传入你想使用的值。在填写完客人姓名后，按下 TAB 键，Xcode 会将光标移动到你需要填充下一个输入值的位置。（见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-949
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入完客人姓名后按 TAB 键将光标移动到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，如姓名或数字，你将得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-952
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用 print(_:) 时，前面没有加参数标签吗？你只需要写：
- en: '[PRE179]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你将会得到一个错误：
- en: '[PRE180]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用时有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它将与参数名相同。然而，如果你编写的函数中，参数标签对代码的清晰度没有太大帮助，那么你可以在函数定义时显式地省略它。例如，在
    print(_:) 函数中，很明显你传入的输入是一个将要打印的字符串。每次调用 print(_:) 时都必须包括像 inputString 这样的参数标签会显得很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为每个参数创建一个与参数名称不同的参数标签。你可以通过在参数名后面输入参数标签、冒号和参数数据类型来做到这一点。你在函数定义时，第一次声明参数时就在函数括号内完成这些操作。这通常在
    Swift 函数中使用，以使函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-959
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:)函数的输入参数是friend，参数标签是to，而在函数调用中传入的参数是“Colin”。如果没有单独的参数标签，当你调用函数时，它将是sayHello(friend:)，这听起来不太像完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-963
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例，展示如何通过添加自定义参数标签使代码更加可读。在你的生日派对之后，你会想给所有的宾客写感谢信。请在你的游乐场中编写以下函数：
- en: '[PRE181]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传入函数的guest参数添加了一个自定义参数标签to。同样，在➋处，我们为gift参数添加了一个参数标签for。参数名guest ➌和gift
    ➍用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for用于在函数调用时标记参数，像这样：
- en: '[PRE182]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到，to:写在第一个输入值之前，for:写在第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用中使用它。如果试图使用参数名代替，会导致错误：
- en: '[PRE183]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能会始终为你填充参数标签，因此你不必担心错误地调用函数（见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-972
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动完成带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像*to*、*from*或*with*这样的介词作为参数标签。在这个示例中，函数用于向宾客发送感谢信*to*某个宾客*for*某个礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")比sendThankYou(guest: "Meghan", gift: "puzzle books")更像一句完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-975
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-976
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，你可以通过在参数名之前添加下划线和空格来去除它们。在以下示例中，我们编写了一个计算体积的函数，该函数接受一个盒子的三个边长作为输入。由于函数名已经清楚地说明了需要传入三个边长，因此你并不需要参数标签来使代码更具可读性。
- en: '[PRE184]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在side1前加下划线（➊），side2前加下划线（➋），side3前加下划线（➌）来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用该函数时，你只需输入参数值而不需要任何标签。
- en: '[PRE185]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出“这个盒子的体积是72。”。如果你不仅仅是打印盒子的体积，而是能够将结果存储到变量或常量中以便稍后使用，这不是更有用吗？让我们来看看如何使用返回值做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-983
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-985
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个箱子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的箱子，想知道哪个能装下更多东西。首先，写一个`volumeOfBox(_:_:_:)`函数，返回一个表示箱子体积的`Int`：
- en: '[PRE186]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数添加返回值，在函数的输入参数➊后使用一个破折号和大于号形成箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需给出数据类型。在函数体内，你通过使用`return`关键字后跟要返回的值➋来返回该值。如果你写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果在`return`语句后写了任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-989
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数，传入两个不同的箱子，查看其效果：
- en: '![](Image00165.jpg)'
  id: totrans-991
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，`volumeOfBox(_:_:_:)`函数计算了一个长为6，宽为5，高为3的箱子的体积，返回值90被存储在一个名为`volumeOfBox1`的常量中。在➋，边长分别为8、4和2的`volumeOfBox2`被赋值为64。现在让我们打印一个关于哪个箱子更大的信息：
- en: '[PRE187]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串"Box 1 is the bigger box."（箱子1是更大的箱子）输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-995
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据条件返回不同的值。让我们写一个函数，它接受一个测试分数数组，并返回平均分。为了得到平均分，你需要将分数加在一起，然后除以分数的总数。请输入以下代码到你的游乐场：
- en: '[PRE188]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有数值的总和。在➊，我们定义了一个名为`sum`的`Int`类型变量，并将其初始值设置为0。在➋的`for-in`循环中，遍历`score`数组中的每个值，并将其加到`sum`变量中。当循环完成后，变量`sum`存储了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数，简单来说，就是`score.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能用零去除任何东西——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除以零错误，并使程序崩溃。因此，在做除法时，务必确保你要除的数不为零，这就是我们通过在
    ➌ 中检查 scores.count > 0 来实现的。在 ➍ 中，我们通过将分数的总和除以数组中分数的数量来返回平均值，使用 return sum / scores.count。没错！你可以返回任何计算结果等于正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回
    sum / scores.count，因为它会计算出一个 Int 类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 scores.count 不大于零时返回一个值，否则我们会收到一个错误，提示函数缺少返回值。我们通过在 if 语句中添加一个
    else 来处理这个问题，返回 0 ➎。你可以通过调用函数，传入一个包含分数的数组和一个空数组来测试这段代码：
- en: '![](Image00166.jpg)'
  id: totrans-1001
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整套测试分数传入 averageOf() 函数时，就像我们在 ➊ 中做的那样，返回的结果是分数的平均值，并显示在结果窗格中。如果你传入一个空数组，就像我们在
    ➋ 中做的那样，返回值是 0。
- en: '**NOTE**'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不是必需的。因为如果 scores.count > 0，那么函数会在 return sum
    / scores.count 时已经结束。所以如果程序已经通过了那个 if 语句，那么我们可以确定 scores.count > 0 之前肯定是假的，这时我们可以直接返回
    0，而不需要将其放在 else 语句中。然而，如果我们保留 else 语句，代码会更加清晰，容易理解。有时候，写一点额外的代码让别人更容易理解，比使用一个复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-1005
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来完成各种神奇的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建具有不同于 Swift 中现有类型的常量和变量，在你开发应用时非常有用！
- en: '**NOTE**'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this book, when we refer to a function with one unlabeled input parameter,
    we put a (_:) after the function name. You’ll see where that colon (: ) comes
    into play soon!*'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本书中，当我们提到一个没有标签输入参数的函数时，我们会在函数名后加上 (_:)。很快你就会明白那个冒号 (:) 的用法！*'
- en: 'Let’s look at an example in the playground:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Playground 中看一个例子：
- en: '[PRE189]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试区域（按 ⌘ -SHIFT -Y），你将看到：
- en: '[PRE190]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: print(_:)函数接受一个输入值，但没有返回值。在这个例子中，输入值是字符串"Swift is awesome!"。print(_:)函数会在调试控制台显示它收到的字符串，然后结束并不返回任何内容。没有返回值的函数有时被称为*空函数*。我们将在[《返回值》](text00017.html#ch07lev1sec5)一节中看到一个既有输入参数又有返回值的函数，见[第91页](text00017.html#page_91)。
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写处理输入并返回输出的函数，你可以创建各种各样的应用程序！
- en: '**WRITING A CUSTOM FUNCTION**'
  id: totrans-1016
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写自定义函数**'
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的函数，打印一个*俳句*，俳句是一种传统的日本诗歌，通常由三行组成，第一行和第三行各有五个音节，中间一行有七个音节。在你的游乐场中输入这个：
- en: '[PRE191]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你编写关键字func ➊ ，后面跟上函数的名称。当你创建一个函数时，必须给它一个名称，这样你才能在需要时调用它执行任务。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数的规则与命名变量相同：你从小写字母开始，每个新单词都使用驼峰命名法大写。你还应该为函数起一个描述其功能的名字。你不觉得printAHaiku()是一个很适合打印简单Swift俳句的函数名吗？
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名后面是成对的圆括号 ➋ 。如果你的函数有输入参数，你应将它们放在这些括号内。在这个例子中，你没有输入参数，所以你只需要保持括号为空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被括号包围。这是你编写函数代码的地方。你将左括号（{）与函数名放在同一行，并将右括号（}）放在函数末尾的单独一行。在这个例子中，函数的主体包含了所有打印俳句的打印语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-1023
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，你只需写出它的名称，后跟圆括号，并将任何参数放入其中。这就是*函数调用*。在这个例子中，因为printAHaiku()没有输入参数，所以你不需要传入任何参数——只需将括号留空。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用printAHaiku()，在函数的右括号后添加以下代码行到你的游乐场中：
- en: '[PRE192]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'The console output is:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出为：
- en: '[PRE193]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数中的代码就会运行。确保你打开了调试区域（⌘ -SHIFT -Y），就像在[图7-1](text00017.html#ch07fig1)中那样，这样你就能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-1030
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用printAHaiku()函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-1033
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数做得更多**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，你看到函数可以为你节省时间和精力。当你编写一个函数时，你可以在任何需要的地方调用它，而不必在多个地方重复相同的代码块。这当然很酷，但函数的真正威力在于当你传入一个或多个输入值时，它能产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-1035
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 invite(guest:) 的函数，它接受一个人的名字作为输入，并生成一个个性化的生日派对邀请。请在你的 Playground 中输入以下内容：
- en: '[PRE194]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要在函数名后面的括号中包含它 ➊。你格式化输入参数时，首先写出它的参数名（在此例中为 guest），然后是一个冒号（:），最后是它的数据类型（此处为
    String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当了参数标签，因此当你调用这个函数时，guest 将作为参数标签。（你将在 “[参数标签](text00017.html#ch07lev1sec4)”一节中学到如何定义单独的参数名和参数标签，详见[第
    89 页](text00017.html#page_89)）。
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后写出输入参数的数据类型，就像声明变量时一样。然而，与变量声明不同，在定义函数参数时，你必须*始终*声明函数应该期望的数据类型；在这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-1041
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需使用它的参数名，就像使用任何其他常量一样 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义函数并不够。现在函数已定义，我们在 Playground 中调用它，看看会发生什么。你可以通过输入函数名，然后在括号中输入参数标签、冒号和参数来调用一个带有输入参数的函数，格式如下：
- en: '[PRE195]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写出函数名来调用一个函数时，Xcode 的自动完成功能会为你提供提示，告诉你应该传递什么参数给这个函数。在这种情况下，当你开始输入 invite
    时，你会看到一个下拉菜单，如[图 7-2](text00017.html#ch07fig2)所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-1046
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成功能将显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键自动完成函数。光标将移动到函数的括号内（见[图 7-3](text00017.html#ch07fig3)），此时 Xcode 会自动添加一些占位文本，告诉你该函数期望什么类型的输入。
- en: '![Image](Image00156.jpg)'
  id: totrans-1049
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递一个不是字符串的东西给 invite(guest:)，比如 invite(guest: 45)，你会得到一个错误，因为该函数期望一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 只需输入 "Cathy" 或其他朋友的名字替代 String，然后按下 TAB 键完成函数调用的填写。它应该如下所示：[图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-1054
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何填写函数调用，调用invite(guest:)三次，并使用你自己朋友的名字：
- en: '[PRE196]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'The output looks like this:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下所示：
- en: '[PRE197]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你可以快速打印出三张派对邀请函，每一张都送给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-1061
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以写一个函数，通过传入一个字符串数组作为参数，而不是单个字符串，来一次性邀请所有的朋友。在你编写invite(guest:)函数的同一个playground中，编写以下invite(allGuests:)函数来进行测试。注意，参数名称现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-1063
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE198]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当你声明函数的参数时，你会注意到[String]被括在方括号中 ➊。方括号声明数据类型为数组，而String表示数组中值的数据类型。通过使用[String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们将使用for-in循环遍历我们的guest数组，并为每个客人打印一张邀请函。还记得我们刚才创建的打印邀请函的函数吗？我们将在这里用到它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本表示现有代码行）：
- en: '[PRE199]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对字符串数组allGuests中的每个客人调用单一的invite(guest:)函数，以邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是不是同一个函数。毕竟，它们的名字都叫invite。尽管它们共享一个名称，但它们是两个不同的函数，因为它们接受不同的输入参数。这是Swift中常见的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE200]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后，我们用这个新数组作为函数的输入，调用该函数 ➋。这是你将在调试控制台中看到的输出（-- snip --表示我们为了节省空间省略的部分行）：
- en: '[PRE201]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友写邀请函，那将是一项巨大的工作。但凭借函数的强大功能，你已经用非常少的代码行完成了这一任务。试着创建你自己的朋友数组；可以随意设定它的长度！然后使用新的数组作为输入，调用invite(allGuests:)函数。简直是小菜一碟！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-1074
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近，部分客人还没有回复。你想要确认最终的出席人数，并通知客人带上泳衣，因为这将是一个滑水道派对。你可以编写一个函数，根据客人的RSVP状态给每位客人发送个性化消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-1076
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个 String 类型的参数表示来宾的名字，一个 Bool 类型的参数表示 RSVP 状态，值为 true 或 false。请在你的
    Playground 中输入以下代码：
- en: '[PRE202]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间添加逗号 ➊。每个参数都需要有一个参数名，后面跟着冒号和参数的数据类型。你可以创建一个接受任意多个输入参数的函数，它们不需要是相同类型的。在
    sendMessage(guest:rsvped:) 函数中，我们传入的是一个 String 类型的 guest 和一个 Bool 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 值是否为 true ➋，然后使用 if-else 语句打印相应的消息。请注意，函数定义中的最后打印语句会在 rsvped
    值为 true 或 false 时都执行，因为它们在 if-else 语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的来宾已经回复了，他们将收到这条消息：
- en: '[PRE203]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有回复，他们将收到一条礼貌的提醒，请他们回复：
- en: '[PRE204]'
  id: totrans-1084
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数来看看它是如何工作的。试着将一个来宾的 rsvped 值设置为 true，另一个来宾的设置为 false，这样你就可以看到两个消息的实际效果。
- en: '[PRE205]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个带有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会帮助你填写输入值，并为你提供参数标签。你只需传入你想使用的值。输入完来宾的名字后，按 TAB 键，Xcode 会将光标移到你需要填写下一个输入值的地方。（参见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-1089
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入来宾名字后按 TAB 键，会将光标移动到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，如名字或数字，你会得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-1092
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，输入值前面没有参数标签？你写的是：
- en: '[PRE206]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，你会得到一个错误：
- en: '[PRE207]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用时有参数标签，而有些没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，而且标签名与参数名相同。然而，如果你编写函数时认为参数标签对于代码的清晰度并不必要，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，很明显你传入的输入是一个将被打印的字符串。每次调用 print(_:) 都必须包含像 inputString 这样的参数标签是令人烦恼的。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号和最后的参数数据类型来实现。所有这些操作都在你首次声明函数括号内的参数时进行，在
    func 关键字之后。Swift 函数中通常会这样做，使得函数调用看起来更像一句句子。[图 7-6](text00017.html#ch07fig6) 说明了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-1099
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用该函数时会是
    sayHello(friend:)，这听起来不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何编写具有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-1103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，看看如何通过添加自定义参数标签使代码更具可读性。生日派对后，你会想给所有来宾发送感谢信。你可以在 Playground 中编写以下函数：
- en: '[PRE208]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了一个自定义的参数标签，命名为 to。类似地，在 ➋ 处，我们为 gift 参数添加了一个参数标签，命名为
    for。参数名称 guest ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，像这样：
- en: '[PRE209]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 在函数调用中写在第一个输入值之前，for: 写在第二个输入值之前。如果一个参数有自定义参数标签，你在函数调用中必须使用它。尝试使用参数名称代替将会导致错误：'
- en: '[PRE210]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成会始终为你填写参数标签，所以你不必担心调用函数时出错（见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-1112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用介词，如 *to*、*from* 或 *with* 作为参数标签。在这个例子中，函数用于向某个来宾 *发送* 感谢信 *以表彰* 他们赠送的礼物。代码
    sendThankYou(to: "Meghan", for: "puzzle books") 更像一句完整的句子，而 sendThankYou(guest:
    "Meghan", gift: "puzzle books") 听起来则不那么像。'
- en: '![Image](Image00163.jpg)'
  id: totrans-1115
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-1116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线和一个空格来移除它们。在下面的示例中，我们写了一个计算体积的函数，它接受一个盒子的三条边作为输入。因为函数名已经清楚地表明你需要传入三条边，所以你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE211]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处的 side1、➋ 处的 side2 和 ➌ 处的 side3 前面加上下划线来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你调用这个函数时，你只需输入参数值，而不需要任何标签。
- en: '[PRE212]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "The volume of this box is 72."。如果你能将体积的结果存储在一个变量或常量中，而不是仅仅打印出来，岂不是很有用？让我们看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-1123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使它返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-1125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，写一个 volumeOfBox(_:_:_:) 函数，它返回一个 Int 类型的盒子体积：
- en: '[PRE213]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数一个返回值，在函数的输入参数后使用一个短横线和一个大于号组成箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要数据类型。在函数体内，你通过使用
    return 关键字加上你想要返回的值来返回该值 ➋。如果你写一个返回值的函数，那么你*必须*在函数内返回该值，否则会出现错误。函数在返回值后结束。如果你在
    return 语句后面写任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-1129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-1131
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算了一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE214]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台中看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-1135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。我们来写一个函数，它接受一个测试分数的数组并返回平均分。为了计算平均分，你需要将所有分数相加，然后除以总的分数数量。在你的游乐场中输入以下代码：
- en: '[PRE215]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始化为 0。位于 ➋ 处的 `for-in`
    循环遍历 `scores` 数组中的每个值并将其加到 `sum` 变量中。当循环完成时，`sum` 变量保存了所有分数的总和。计算总和之后，剩下的就是将其除以分数的总数，这就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会给你一个除零错误并崩溃你的程序。因此，在进行除法运算时，始终确保你要除的数不是零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来做到的。在 ➍ 处，我们通过将分数的总和除以数组中分数的数量来返回平均值，使用 `return sum
    / scores.count`。没错！你可以返回任何求值为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值分配给新变量的步骤，直接返回 `sum
    / scores.count`，因为它会被求值为一个 `Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们还需要返回一些内容，否则我们会得到一个函数缺少返回值的错误。我们通过在 `if` 语句中添加一个
    `else` 来处理这个问题，返回 0 ➎。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-1141
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 `averageOf()` 函数时，就像我们在 ➊ 处所做的那样，分数的平均值将被返回并显示在结果面板中。如果你传入一个空数组，就像我们在
    ➋ 处所做的那样，返回值是 0。
- en: '**NOTE**'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 `else` 语句其实并不是必要的。这是因为如果 `scores.count > 0`，函数会在 `return
    sum / scores.count` 处结束。所以如果计算机已经通过了那条 `if` 语句，我们就知道 `scores.count > 0` 一定不成立，实际上可以直接写一个
    `return 0`，而不需要将它包裹在 `else` 语句中。然而，如果我们保留 `else` 语句，代码会更清晰，更容易理解。有时写一些额外的代码，让其他人更容易理解，比使用一个巧妙的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-1145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，能够做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第8章](text00018.html#ch08) 中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建具有除 Swift 中已包含类型之外的类型的常量和变量，这在你创建应用程序时会非常有用！
- en: 'Let’s look at an example in the playground:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个在游乐场中的例子：
- en: '[PRE216]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试区域（按 ⌘ -SHIFT -Y）中，你会看到：
- en: '[PRE217]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: print(_:)函数接受一个输入值，但没有返回值。在这个例子中，输入值是字符串"Swift is awesome!"。print(_:)函数将传入的字符串显示在调试控制台中，然后结束而不返回任何内容。没有返回值的函数有时被称为*void函数*。我们将在“[返回值](text00017.html#ch07lev1sec5)”一节中看到一个既有输入参数又有返回值的函数，参见[第91页](text00017.html#page_91)。
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写处理输入并返回输出的函数，你可以创建各种各样的应用程序！
- en: '**WRITING A CUSTOM FUNCTION**'
  id: totrans-1154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写自定义函数**'
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的函数，打印一个*俳句*，俳句是一种传统的日本诗歌，由三行组成，第一行和最后一行各有五个音节，中间一行有七个音节。将以下代码输入到你的游乐场中：
- en: '[PRE218]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你写出func关键字 ➊ ，然后是函数的名称。创建函数时，你必须给它起个名字，这样你才能在需要时调用它来执行任务。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 函数命名的规则与变量命名相同：你以小写字母开始，并使用驼峰命名法（camel case）将每个新单词的首字母大写。你还应该给函数起一个能够描述它功能的名字。你不觉得printAHaiku()是一个非常合适的名字吗？它正好描述了一个打印简单Swift俳句的函数。
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名后面，有一对括号 ➋ 。如果你的函数有输入参数，你应该把它们放在括号里面。在这个例子中，你没有任何输入参数，所以括号就留空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被大括号括起来。这里是你编写函数代码的地方。你将左大括号（{）与函数名写在同一行，右大括号（}）则单独写在函数的最后一行。在这个例子中，函数的主体包含了所有打印俳句的print语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-1161
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，你只需写出它的名字，后面跟上括号，并在括号中传入任何参数。这就是*函数调用*。在这个例子中，由于printAHaiku()没有输入参数，你不需要传入任何参数——只需要将括号留空。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用printAHaiku()，在函数的右大括号后，向游乐场添加以下一行：
- en: '[PRE219]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'The console output is:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出为：
- en: '[PRE220]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经定义了这个函数，你可以随时调用它，函数内部的代码就会运行。确保你打开了调试区域（⌘ -SHIFT -Y），如同在[图 7-1](text00017.html#ch07fig1)中所示，这样你就可以看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-1168
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 试着多次调用printAHaiku()函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-1171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数做更多的事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，你看到函数如何节省你的时间和精力。当你编写一个函数时，你可以在任何地方调用它，而无需在多个地方重复代码块。这当然很酷，但函数的真正强大之处在于你传入一个或多个输入值来生成不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-1173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 `invite(guest:)` 的函数，它接受一个人的名字作为输入，并生成一个个性化的生日派对邀请函。在你的 playground
    中输入以下内容：
- en: '[PRE221]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将其放在函数名后的括号内 ➊。你按照先写参数名（在这个例子中是 `guest`），然后是冒号（:），最后是数据类型（在此例中是
    `String`）的格式来定义输入参数。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，因此当你调用此函数时，`guest` 将作为参数标签。（你将在“[参数标签](text00017.html#ch07lev1sec4)”中学习如何定义单独的参数名和参数标签，[第
    89 页](text00017.html#page_89)会有详细介绍。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后面写输入参数的数据类型，就像声明一个变量一样。然而，与变量声明不同，在定义函数参数时，你必须*始终*声明函数应期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-1179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内使用输入参数，只需像使用其他常量一样使用它的参数名 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数还不够。现在函数已经定义，让我们在 playground 中调用它，看看会发生什么。你可以通过输入函数名，后跟括号内的参数标签、冒号和参数来调用一个带有输入参数的函数，像这样：
- en: '[PRE222]'
  id: totrans-1182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名来调用函数时，Xcode 的自动完成功能会提示你应该传入什么参数。在这种情况下，当你开始写 `invite` 时，你会看到一个下拉菜单，如[图
    7-2](text00017.html#ch07fig2)所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-1184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成功能将显示一个函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 按 ENTER 键以自动完成函数。光标会移动到函数的括号内（见[图 7-3](text00017.html#ch07fig3)），在这里，Xcode 自动添加了一些占位符文本，告诉你函数期望什么类型的输入。
- en: '![Image](Image00156.jpg)'
  id: totrans-1187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递一个非字符串类型的参数给 `invite(guest:)`，例如 `invite(guest: 45)`，你将收到错误，因为该函数期望的是字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将 "Cathy" 或其他朋友的名字替换为 `String`，然后按 TAB 键完成函数调用的填写。它应该像[图 7-4](text00017.html#ch07fig4)所示。
- en: '![Image](Image00157.jpg)'
  id: totrans-1192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，试着用你朋友的名字调用 invite(guest:) 函数三次：
- en: '[PRE223]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'The output looks like this:'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE224]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你可以快速打印三份派对邀请函，每一份都发给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-1199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过传入一个字符串数组作为参数，而不是单个字符串，来编写一个一次性邀请所有朋友的函数。在你编写 invite(guest:) 的同一个 playground
    中，编写以下 invite(allGuests:) 函数来进行测试。注意，参数名称现在是复数形式，因为我们将一次邀请多个宾客。
- en: '![Image](Image00158.jpg)'
  id: totrans-1201
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE225]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到 [String] 被方括号包围 ➊ 。方括号声明数据类型为数组，而 String 表示数组中值的数据类型。通过使用
    [String] ，我们将这个函数的输入声明为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们需要使用一个 for-in 循环来遍历宾客数组，为每个宾客打印邀请函。还记得我们刚刚创建了一个打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到你的
    invite(allGuests:) 函数中（灰色文本显示的是现有的代码行）：
- en: '[PRE226]'
  id: totrans-1205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们对 String 数组 allGuests 中的每个宾客调用单一的 invite(guest:) 函数，邀请每个人参加生日派对。你可能会想，invite(guest:)
    和 invite(allGuests:) 是不是同一个函数。毕竟，它们的名字都是 invite 。然而，尽管名字相同，它们实际上是两个不同的函数，因为它们接受的输入参数不同。这是你在
    Swift 中经常会见到的一个模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 invite(allGuests:) 函数，我们首先创建一个名为 friends 的数组，然后将其用作函数调用的输入。
- en: '[PRE227]'
  id: totrans-1208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后，我们使用新数组作为函数的输入，调用函数 ➋ 。这是你在调试控制台看到的输出（-- snip -- 显示了我们为节省空间省略的行）：
- en: '[PRE228]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为这些朋友写出邀请函，那会非常麻烦。但借助函数的力量，你只需几行代码就能完成。试着创建你自己的朋友数组，长度可以任意！然后使用你的新数组作为输入，调用
    invite(allGuests:) 函数。简直是小菜一碟！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-1212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向您的宾客发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期临近，而一些宾客还没有回复邀请。你想要确认最终的宾客人数，并告知宾客们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据宾客的回复状态向每个宾客发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-1214
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个用于客人名字的 String 参数和一个用于 RSVP 状态的 Bool 参数，该状态为 true 或 false。将以下代码输入到你的
    playground 中：
- en: '[PRE229]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间添加一个逗号 ➊。每个参数都需要有一个参数名称，后面跟着冒号和数据类型。你可以创建一个接受任意数量输入参数的函数，而且这些参数不必是相同类型的。在
    sendMessage(guest:rsvped:) 函数中，我们传入了一个 String 类型的 guest 和一个 Bool 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 值是否为 true ➋，然后使用 if-else 语句打印相应的消息。还要注意的是，无论 rsvped 值是 true
    还是 false，函数定义中的最后几行打印语句都会运行，因为它们在 if-else 语句的括号外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经 RSVP，他们会收到这条消息：
- en: '[PRE230]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的通知，要求他们回复：
- en: '[PRE231]'
  id: totrans-1222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一个客人的 rsvped 值设置为 true，将另一个客人的设置为 false，这样你就能看到两个消息的实际效果。
- en: '[PRE232]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个具有多个输入参数的函数与调用一个只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能将帮助你填写输入值，提供参数标签。你所要做的就是传入你想要使用的值。填写完客人名字后，按下 TAB 键，Xcode 会将光标定位到下一个输入值的位置。（见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-1227
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人名字后按 TAB 键会将光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，你会收到错误提示。
- en: '**ARGUMENT LABELS**'
  id: totrans-1230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用 print(_:) 时，你并没有在输入值前加上参数标签吗？你只需写：
- en: '[PRE233]'
  id: totrans-1232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试加入一个标签，你会遇到错误：
- en: '[PRE234]'
  id: totrans-1234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且这个标签与参数名称相同。然而，如果你编写的函数中，认为参数标签对于代码的清晰度并不是必须的，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，显然你传入的是一个将要打印的字符串。如果每次调用 print(_:) 时都必须包括像 inputString 这样的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号，最后是参数的数据类型来做到这一点。所有这些操作都是在你第一次声明函数括号内的参数时进行的，紧跟在
    func 关键字之后。这通常在 Swift 函数中使用，以使函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6) 说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-1237
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，那么调用该函数时看起来会像
    sayHello(friend:)，这样听起来就不像完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写具有自定义参数标签的函数。我们还将展示如何编写一个函数，在其中完全省略参数标签。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-1241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，看看如何通过添加自定义参数标签使你的代码更具可读性。在你举办生日派对后，你可能想要给所有宾客发送感谢信。请在你的 Playground
    中编写以下函数：
- en: '[PRE235]'
  id: totrans-1243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递到函数中的 guest 参数添加了自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了参数标签 for。参数名 guest
    ➌ 和 gift ➍ 用于函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，像这样：
- en: '[PRE236]'
  id: totrans-1246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: '这里你可以看到，to: 写在函数调用的第一个输入值之前，for: 写在第二个输入值之前。如果参数有自定义参数标签，你必须在函数调用中使用它。试图使用参数名而不是参数标签会导致错误：'
- en: '[PRE237]'
  id: totrans-1248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填写正确的参数标签，因此你不必担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-1250
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用介词如 *to*、*from* 或 *with* 作为参数标签。在这个例子中，函数用于向宾客发送感谢信 *to* 表达感谢 *for*
    礼物。代码 sendThankYou(to: "Meghan", for: "puzzle books") 读起来更像一个句子，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-1253
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-1254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，你可以通过在参数名之前加上下划线和一个空格来移除它们。在下面的示例中，我们编写了一个计算体积的函数，该函数以箱子的三个边长作为输入。因为函数名已经明确表示需要传入三个边长，所以你实际上不需要参数标签来使代码更具可读性。
- en: '[PRE238]'
  id: totrans-1256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处的 side1、➋ 处的 side2 和 ➌ 处的 side3 前面加上下划线，来移除边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而无需任何标签。
- en: '[PRE239]'
  id: totrans-1259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "The volume of this box is 72."。如果你不仅仅打印箱子的体积，而是能够将结果存储在一个变量或常量中以便后续使用，这不是更有用吗？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-1261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-1263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个箱子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的箱子，想知道哪个箱子能容纳更多的东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，返回一个整数类型的箱子体积：
- en: '[PRE240]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数一个返回值，在函数的输入参数后面使用一个短横线和大于号（->）来表示箭头 ➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你通过使用
    return 关键字后跟你想返回的值来返回该值 ➋。如果你编写一个返回值的函数，那么你*必须*在函数内返回该值，否则会出现错误。函数在返回值后结束。如果你在
    return 语句之后写了任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-1267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的箱子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-1269
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算了一个边长为 6、5 和 3 的箱子的体积，返回值 90 被存储在名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在我们来打印一条关于哪个箱子更大的信息：
- en: '[PRE241]'
  id: totrans-1271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台中看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-1273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。我们来编写一个函数，它接受一个测试成绩的数组并返回平均分。为了计算平均分，你将成绩加起来，然后除以成绩的总数。在你的
    Playground 中输入以下代码：
- en: '[PRE242]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 变量，并将其初始值设为 0。➋ 处的 for-in 循环会遍历 scores
    数组中的每个值，并将其加到 sum 变量中。当循环完成后，变量 sum 保存了所有成绩的总和。计算出总和后，剩下的就是将它除以总成绩的数量，这个数量就是 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能把一个数除以零——无论是在数学课上，还是在 Swift 中。在 Swift 中，试图除以零会导致除零错误，并崩溃程序。因此，在进行除法运算时，始终确保除数不为零，这就是我们在
    ➌ 处通过检查 scores.count > 0 来保证的。在 ➍ 处，我们通过将成绩总和除以数组中成绩的数量来返回平均值，使用 return sum /
    scores.count。没错！你可以返回任何计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 sum / scores.count，因为它的计算结果是一个
    Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 小于等于零时，我们也需要返回一个值，否则会出现缺少 return 的错误。我们通过在 if 语句后面添加 else
    来处理这个问题，它会返回 0 ➎。你可以通过传入一个包含成绩的数组和一个空数组来测试这段代码：
- en: '![](Image00166.jpg)'
  id: totrans-1279
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传入 averageOf() 函数时，就像我们在 ➊ 处做的那样，成绩的平均值会被返回并显示在结果面板中。如果传入的是空数组，正如我们在
    ➋ 处所做的那样，返回值将是 0。
- en: '**NOTE**'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句实际上并不是必需的。这是因为如果 scores.count > 0 ，那么函数已经通过 return
    sum / scores.count 提前结束了。所以，如果计算机执行到了那个 if 语句之后，我们知道 scores.count > 0 一定不成立，那我们完全可以直接返回
    0，而不必放在 else 语句中。然而，如果我们保留 else 语句，代码会更加清晰易懂。有时候，为了让代码对他人更直观，写一些额外的代码比使用复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-1283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，能够做各种各样令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建除 Swift 已包含类型之外的常量和变量，在你创建应用时非常有用！
- en: '[PRE243]'
  id: totrans-1286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试区域（按 ⌘ -SHIFT -Y），你将看到：
- en: '[PRE244]'
  id: totrans-1288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(_:)`函数接受一个输入值，但没有返回值。在这个例子中，输入值是字符串"Swift is awesome!"。`print(_:)`函数会在调试控制台中显示它所接收到的字符串，然后结束而不返回任何值。没有返回值的函数有时被称为*无返回值函数*。我们将在“[返回值](text00017.html#ch07lev1sec5)”中看到一个包含输入参数和返回值的函数示例，参见[第91页](text00017.html#page_91)。'
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写处理输入并返回输出的函数，你可以创建各种各样的应用！
- en: '**WRITING A CUSTOM FUNCTION**'
  id: totrans-1291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写自定义函数**'
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的函数，打印一个*俳句*，这是一种传统的日本诗歌，由三行组成，第一行和最后一行有五个音节，中间一行有七个音节。在你的playground中输入以下内容：
- en: '[PRE245]'
  id: totrans-1293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你写下`func`关键字➊，然后是函数的名字。创建函数时，必须为它命名，以便在需要时调用它执行任务。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数的规则与命名变量相同：从小写字母开始，并使用驼峰命名法大写每个新单词。你还应该为你的函数命名，确保它能描述函数的作用。你不觉得`printAHaiku()`是一个很适合打印简单Swift俳句的函数名吗？
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名后面有一对括号➋。如果你的函数有输入参数，你会将它们放在这些括号内。在这个例子中，函数没有输入参数，所以你只需将括号留空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被花括号括起来。这是你编写函数代码的地方。你需要将开括号（{）放在与函数名相同的一行，并且将闭括号（}）放在函数最后一行的单独一行。在这个示例中，函数的主体包含了所有打印俳句的打印语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-1298
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数时，你只需要写下函数名，后跟括号，并在括号中传入任何参数。这就是*函数调用*。在这个例子中，由于`printAHaiku()`没有输入参数，你无需传入任何参数——只需将括号留空。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用`printAHaiku()`，在函数的闭括号之后，将以下代码行添加到你的playground中：
- en: '[PRE246]'
  id: totrans-1301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'The console output is:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出为：
- en: '[PRE247]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数内部的代码就会执行。确保打开调试区域（⌘ -SHIFT -Y），如[图7-1](text00017.html#ch07fig1)所示，这样你就能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-1305
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用`printAHaiku()`函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-1308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数与输入参数的更多应用**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，你看到函数如何节省你的时间和精力。当你编写一个函数时，你可以在任何地方调用它，而不必在许多地方重复代码块。这当然很酷，但函数的真正强大之处在于，当你传入一个或多个输入值时，它能产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-1310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 invite(guest:) 的函数，它接受一个人的名字作为输入，并创建一个个性化的生日派对邀请函。在你的 Playground 中输入以下内容：
- en: '[PRE248]'
  id: totrans-1312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数有输入参数，你需要在函数名后面的括号中包含它 ➊。你按照首先写参数名（在这个例子中是 guest），然后是冒号（:），最后是它的数据类型（在本例中是
    String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，因此 guest 将是调用此函数时的参数标签。（你将在“[参数标签](text00017.html#ch07lev1sec4)”章节了解如何定义独立的参数名和参数标签，详见[第
    89 页](text00017.html#page_89)。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后写输入参数的数据类型，就像声明变量时一样。但是，不同于变量声明，在定义函数参数时，你必须*始终*声明函数应该期待的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-1316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需使用它的参数名，就像使用任何其他常量一样 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数还不够。既然函数已经定义好了，现在让我们在 Playground 中调用它看看会发生什么。你可以通过输入函数名后跟括号内的参数标签、冒号和参数来调用一个具有输入参数的函数，像这样：
- en: '[PRE249]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写出函数名来调用一个函数时，Xcode 的自动补全会给你一个提示，告诉你应该传递什么给函数。在这个例子中，当你开始写 invite 时，你会看到像[图
    7-2](text00017.html#ch07fig2)一样的下拉菜单。
- en: '![Image](Image00155.jpg)'
  id: totrans-1321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动补全将显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键来自动完成函数。你的光标将移动到函数的括号内（见[图 7-3](text00017.html#ch07fig3)），此时 Xcode
    会自动添加一些占位符文本，告诉你该函数期望什么类型的输入。
- en: '![Image](Image00156.jpg)'
  id: totrans-1324
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递给 invite(guest:) 的不是字符串，比如 invite(guest: 45)，你会收到一个错误，因为该函数期望一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 位置输入 "Cathy" 或其他朋友的名字，然后按 TAB 键完成函数调用的填写。它应该看起来像[图 7-4](text00017.html#ch07fig4)那样。
- en: '![Image](Image00157.jpg)'
  id: totrans-1329
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用invite(guest:)三次，使用你自己朋友的名字：
- en: '[PRE250]'
  id: totrans-1332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'The output looks like this:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE251]'
  id: totrans-1334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你能够快速打印出三张派对邀请函，每张都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-1336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个一次性邀请所有朋友的函数，通过传入一个字符串数组作为参数，而不是单个字符串。在你写了invite(guest:)的同一个playground中，编写以下invite(allGuests:)函数进行测试。注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-1338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00158.jpg)'
- en: '[PRE252]'
  id: totrans-1339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被放在方括号中 ➊。方括号声明数据类型为数组，而String表示数组中值的数据类型。通过使用[String]，我们将该函数的输入声明为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们希望使用for-in循环遍历我们的客人数组，并为每个客人打印一张邀请函。记得我们刚才创建了一个打印邀请函的函数吗？让我们在这里使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本显示的是现有代码行）：
- en: '[PRE253]'
  id: totrans-1342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个客人调用单独的invite(guest:)函数，邀请每个客人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟，它们的名字都是invite。然而，尽管它们共享相同的名字，但它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常会遇到的一个模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE254]'
  id: totrans-1345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后，我们使用这个新数组作为函数的输入来调用函数 ➋。这是你在调试控制台中看到的输出（-- snip --表示我们为节省空间省略的行）：
- en: '[PRE255]'
  id: totrans-1347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友写邀请函，那将需要很多工作。但是通过函数的力量，你只用了非常少的代码行就完成了这一任务。试着创建你自己的朋友数组；让它尽可能长！然后使用你的新数组作为输入调用invite(allGuests:)函数。轻松搞定！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-1349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期即将来临，而一些客人还没有回复是否参加。你希望获取最终的参与人数，并告诉客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据客人的RSVP状态向每个客人发送自定义消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-1351
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个 String 类型的参数用于客人的姓名，一个 Bool 类型的参数用于 RSVP 状态，即 true 或 false。在你的
    playground 中输入以下代码：
- en: '[PRE256]'
  id: totrans-1353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数有多个输入参数时，在每个参数之间加上逗号 ➊ 。每个参数都需要一个参数名，后跟一个冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，它们不必是相同类型。在
    sendMessage(guest:rsvped:) 函数中，我们传递一个 String 类型的 guest 参数和一个 Bool 类型的 rsvped 参数。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体中，我们检查 rsvped 的值是否为 true ➋ ，然后使用 if-else 语句打印相应的消息。注意，函数定义中最后的打印语句将始终运行，无论
    rsvped 的值是 true 还是 false，因为它们位于 if-else 语句的大括号外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经确认参加，他们会收到这条消息：
- en: '[PRE257]'
  id: totrans-1357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有确认，他们会收到一封礼貌的通知，请他们回复：
- en: '[PRE258]'
  id: totrans-1359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它的运行方式。尝试将一个客人的 rsvped 值设置为 true，另一个客人的值设置为 false，这样你就可以看到两条消息的效果。
- en: '[PRE259]'
  id: totrans-1361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，调用具有多个输入参数的函数类似于调用只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能将帮助你填写输入值，提供参数标签。你只需传递你想使用的值。在填写完客人姓名后，按 TAB 键，Xcode 将把光标放在你需要填写下一个输入值的位置。（参见
    [图 7-5](text00017.html#ch07fig5) 。）
- en: '![Image](Image00160.jpg)'
  id: totrans-1364
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按 TAB 键将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。用 true 或 false 替换占位符文本 Bool。如果你尝试传递其他任何内容，如名称或数字，你会得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-1367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到在调用 print(_:) 时，你不需要在输入值前面放置一个参数标签？你只需写：
- en: '[PRE260]'
  id: totrans-1369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图包含一个标签，你会得到一个错误：
- en: '[PRE261]'
  id: totrans-1371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用中，有些参数具有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都将有一个参数标签，并且它将与参数名相同。然而，如果你编写一个函数，觉得参数标签不必要以使代码清晰，那么你可以在函数定义中显式省略它。例如，在
    print(_:) 函数中，显然传入的是一个将被打印的字符串。每次调用 print(_:) 时都必须包含像 inputString 这样的参数标签会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，然后是参数的数据类型来做到这一点。所有这些操作都在函数关键字后面的函数括号内声明参数时进行。Swift
    函数中经常这样做，以使函数调用看起来更像一句话。[图 7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-1374
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，传递给函数调用的参数是 "Colin"。如果没有单独的参数标签，当你调用该函数时，它看起来会像
    sayHello(friend:)，这听起来不如一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-1378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，看看如何添加自定义参数标签可以使你的代码更易读。在你举办完生日派对后，你会想要给所有的客人发送感谢卡。请在你的 playground
    中编写以下函数：
- en: '[PRE262]'
  id: totrans-1380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了参数标签 for。参数名称 guest
    ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用来在函数调用时标记参数，如下所示：
- en: '[PRE263]'
  id: totrans-1383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里你可以看到，to: 在第一个输入值之前书写，for: 在第二个输入值之前书写。如果一个参数有自定义参数标签，你必须在函数调用中使用它。尝试使用参数名称代替将会导致错误：'
- en: '[PRE264]'
  id: totrans-1385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填充参数标签，因此你不必担心错误地调用函数（请参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-1387
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全函数并使用正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用来向客人发送感谢卡，*to* 一位客人 *for*
    一份礼物。代码 sendThankYou(to: "Meghan", for: "puzzle books") 读起来更像一句话，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-1390
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-1391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加下划线和一个空格来去掉它们。在下面的例子中，我们写了一个计算体积的函数，它接受盒子的三条边作为输入。因为函数名已经清楚地表明你需要传入三条边，所以实际上不需要参数标签来提高代码的可读性。
- en: '[PRE265]'
  id: totrans-1393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊位置在side1前面加上下划线，➋位置在side2前面加上下划线，➌位置在side3前面加上下划线，去掉了边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需要输入参数值，而不需要任何标签。
- en: '[PRE266]'
  id: totrans-1396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“The volume of this box is 72.”。如果你不仅仅是打印出盒子的体积，而是可以将结果存储在一个变量或常量中，以便稍后使用，那岂不是更有用吗？让我们来看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-1398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，将体积作为返回值而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-1400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能容纳更多的物品。首先，写一个返回盒子体积的volumeOfBox(_:_:_:)函数：
- en: '[PRE267]'
  id: totrans-1402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数添加返回值，可以在函数输入参数后面使用一个破折号和大于号（->）来表示箭头➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你通过使用return关键字并跟上你想返回的值来返回值➋。如果你写了一个返回值的函数，那么你*必须*在函数内部返回这个值，否则会报错。函数在返回值之后结束。如果你在返回语句之后写任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-1404
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个函数对两个不同的盒子进行操作，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-1406
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊位置，volumeOfBox(_:_:_:)函数计算一个边长为6、5和3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋位置，边长为8、4和2的volumeOfBox2被赋值为64。现在，让我们打印出哪个盒子更大：
- en: '[PRE268]'
  id: totrans-1408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-1410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，接收一个测试分数的数组并返回平均分。为了计算平均值，你需要将所有分数加起来，然后除以分数的总数。在你的playground中输入以下代码：
- en: '[PRE269]'
  id: totrans-1412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在➊处，我们定义了一个名为`sum`的`Int`变量，并将其初始值设置为0。在➋处的`for-in`循环遍历`score`数组中的每个值，并将其加到`sum`变量中。当循环完成时，`sum`变量中保存了所有成绩的总和。计算总和后，剩下的就是将总和除以成绩的总数，这就是简单的`score.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果数组为空呢？你不能用零来做除法——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除零错误并使程序崩溃。因此，在进行除法运算时，务必确保除数不为零，这就是我们在➌处通过检查`scores.count
    > 0`来做到的。在➍处，我们通过将成绩总和除以数组中成绩的数量来返回平均值，使用`return sum / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算得到的平均值赋值给新变量的步骤，直接返回`sum
    / scores.count`，因为它的结果是`Int`类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`scores.count`不大于零时，我们还需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在`if`语句中添加一个`else`来处理这一点，返回0
    ➎。你可以通过在一个成绩数组和一个空数组上调用函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-1416
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一组完整的测试成绩数组传入`averageOf()`函数时，如在➊所示，函数会返回成绩的平均值，并显示在结果面板中。如果你传入一个空数组，如在➋所示，返回值为0。
- en: '**NOTE**'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕`return 0`的`else`语句实际上并非必要。这是因为如果`scores.count > 0`，那么函数已经在`return
    sum / scores.count`处结束。所以如果程序已经越过了那个`if`语句，我们就知道`scores.count > 0`一定为假，我们完全可以直接使用`return
    0`，而不需要将其放在`else`中。然而，如果我们保留`else`语句，代码会更清晰，更易于理解。有时候，为了让其他人更容易理解代码，写一点额外的代码比使用巧妙的捷径更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-1420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包增加了一个重要的工具——创建和调用自己的函数！函数在编程中广泛使用，可以完成各种各样令人惊叹的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你创建类型不同于Swift内置类型的常量和变量，这在你开发应用程序时会非常有用！
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试区域（按`⌘ -SHIFT -Y`）中，你将看到：
- en: '[PRE270]'
  id: totrans-1424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: print(_:)函数接受一个输入值，但没有返回值。在这个例子中，输入值是字符串"Swift is awesome!"。print(_:)函数将该字符串显示在调试控制台中，然后结束，不返回任何内容。没有返回值的函数有时被称为*void函数*。我们将在“[返回值](text00017.html#ch07lev1sec5)”一节中看到一个具有输入参数和返回值的函数示例，详见[第91页](text00017.html#page_91)。
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写能够处理输入并返回输出的函数，你可以创建各种应用程序！
- en: '**WRITING A CUSTOM FUNCTION**'
  id: totrans-1427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写自定义函数**'
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的函数，打印一个*俳句*，这是一种传统的日本诗歌，由三行组成，第一行和最后一行有五个音节，中间一行有七个音节。将以下代码输入到你的 playground
    中：
- en: '[PRE271]'
  id: totrans-1429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你写上func关键字➊，后跟你的函数名。当你创建一个函数时，必须为它命名，以便你可以在需要时调用它来执行任务。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数的规则与命名变量的规则相同：你应该从小写字母开始，并且使用驼峰式命名法将每个新词的首字母大写。你还应该为你的函数命名，确保它能描述函数的作用。你不觉得printAHaiku()是一个很好的名字，适合打印一个简单的
    Swift 俳句吗？
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名后面，有一对圆括号➋。如果你的函数有输入参数，你需要将它们放在圆括号内。在这个例子中，你没有输入参数，所以括号是空的。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被花括号括起来。这是你写函数代码的地方。你需要将左花括号（{）与函数名写在同一行，并将右花括号（}）放在函数末尾的单独一行。在这个例子中，函数的主体包含了所有打印俳句的print语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-1434
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，你只需写出它的名字，后面跟上圆括号和任何传入的参数。这就是*函数调用*。在这个例子中，因为printAHaiku()没有输入参数，所以你不需要传入任何参数——只需保持括号为空即可。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用printAHaiku()，在函数的闭括号后面添加以下代码行：
- en: '[PRE272]'
  id: totrans-1437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: 'The console output is:'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出为：
- en: '[PRE273]'
  id: totrans-1439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数中的代码将会执行。确保你已经打开了调试区域（⌘ -SHIFT -Y），如[图 7-1](text00017.html#ch07fig1)所示，这样你就能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-1441
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出会显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用printAHaiku()函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-1444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数做得更多**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，你看到函数如何节省时间和精力。当你编写一个函数时，你可以在任何地方调用它，而无需在多个地方重复代码块。这当然很酷，但函数的真正强大之处在于你可以传入一个或多个输入值，产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-1446
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个名为 invite(guest:) 的函数，它接受一个人的名字作为输入，并生成一份个性化的生日派对邀请函。请输入以下内容到你的 playground
    中：
- en: '[PRE274]'
  id: totrans-1448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将其放在函数名称后的括号内 ➊。你可以按顺序格式化输入参数，先是参数名（在本例中为 guest），然后是冒号（:），最后是数据类型（在本例中是
    String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，因此当你调用这个函数时，guest 就是参数标签。（你将会在“[参数标签](text00017.html#ch07lev1sec4)”中了解如何定义单独的参数名和参数标签，详见[第
    89 页](text00017.html#page_89)。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 你在输入参数后面用冒号来写数据类型，就像声明变量时一样。然而，与变量声明不同，在定义函数参数时，你必须*始终*声明该函数期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-1452
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需使用它的参数名，就像使用任何其他常量一样 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数是不够的。现在函数已经定义好了，让我们在 playground 中调用它，看看会发生什么。你可以通过输入函数名称后加上括号中的参数标签、冒号和参数来调用带有输入参数的函数，如下所示：
- en: '[PRE275]'
  id: totrans-1455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名称来调用函数时，Xcode 的自动补全会提示你应该传递什么内容给函数。在这种情况下，当你开始写 invite 时，你会看到一个下拉菜单，如[图
    7-2](text00017.html#ch07fig2)所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-1457
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动补全会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键自动完成函数。光标会移动到函数的括号内（参见[图 7-3](text00017.html#ch07fig3)），此时 Xcode 已自动添加了一些占位符文本，告诉你该函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-1460
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递给 invite(guest:) 的不是字符串，例如 invite(guest: 45)，你会遇到错误，因为该函数期望的是字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将 "Cathy" 或另一个朋友的名字替换为 String，然后按 TAB 键完成函数调用。它应该看起来像[图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-1465
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用 invite(guest:) 函数三次，使用你自己朋友的名字：
- en: '[PRE276]'
  id: totrans-1468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'The output looks like this:'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来是这样的：
- en: '[PRE277]'
  id: totrans-1470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你能够快速打印三张派对邀请函，每张都发给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-1472
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写一个函数，通过传递一个字符串数组作为参数，而不是单一字符串，一次性邀请所有朋友。在你写 invite(guest:) 函数的同一个 playground
    中，编写以下 invite(allGuests:) 函数来进行测试。注意，现在参数名是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-1474
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE278]'
  id: totrans-1475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到 [String] 被放在方括号中 ➊ 。方括号声明了数据类型为数组，而 String 则表示数组中值的数据类型。通过使用
    [String]，我们将此函数的输入声明为字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们将使用一个 for-in 循环遍历我们的客人数组，并为每位客人打印邀请函。还记得我们刚刚创建了一个打印邀请函的函数吗？让我们在这里也用上它！将以下内容添加到你的
    invite(allGuests:) 函数中（灰色文本表示现有的代码行）：
- en: '[PRE279]'
  id: totrans-1478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们对字符串数组 allGuests 中的每个 guest 调用单独的 invite(guest:) 函数，以邀请每个人参加生日派对。你可能会想，invite(guest:)
    和 invite(allGuests:) 是不是同一个函数。毕竟，它们都叫做 invite。尽管它们的名字相同，然而它们是两个不同的函数，因为它们接受的输入参数不同。这是
    Swift 中经常出现的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 invite(allGuests:) 函数，我们首先创建一个名为 friends 的数组，然后将其用作函数调用中的输入。
- en: '[PRE280]'
  id: totrans-1481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后，我们用这个新数组作为函数的输入来调用该函数 ➋ 。这是你将在调试控制台看到的输出（-- snip --
    显示了我们为节省空间省略的行）：
- en: '[PRE281]'
  id: totrans-1483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友写出邀请函，那将会非常麻烦。但凭借函数的强大功能，你只用极少的代码行就完成了这件事。试着创建你自己的朋友数组；你可以根据需要扩展数组的长度！然后用这个新数组作为输入调用
    invite(allGuests:) 函数。简直轻松搞定！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-1485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向你的客人发送信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期即将临近，一些客人还没有回复确认。你想要确认最终的参与人数，并告诉客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据每个客人的
    RSVP 状态，发送自定义信息。
- en: '![Image](Image00159.jpg)'
  id: totrans-1487
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个String类型的参数表示宾客的姓名，另一个Bool类型的参数表示RSVP状态，它的值可以是true或false。请输入以下代码到你的playground中：
- en: '[PRE282]'
  id: totrans-1489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间添加逗号➊。每个参数都需要有一个参数名，后跟冒号和数据类型。你可以创建一个接受任意数量输入参数的函数，它们不必是相同类型的。在`sendMessage(guest:rsvped:)`函数中，我们传入一个String类型的guest和一个Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped的值，看看它是否为true➋，然后使用if-else语句打印相应的消息。另请注意，函数定义中的最后几个打印语句无论rsvped的值是true还是false都会执行，因为它们位于if-else语句的大括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的宾客已RSVP，他们将收到以下消息：
- en: '[PRE283]'
  id: totrans-1493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提示，要求他们回复：
- en: '[PRE284]'
  id: totrans-1495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一位宾客的rsvped值设置为true，将另一位宾客的rsvped值设置为false，这样你就能看到两个消息的实际效果。
- en: '[PRE285]'
  id: totrans-1497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个包含多个输入参数的函数，类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能将帮助你填写输入值，为你提供参数标签。你只需要传入你想要使用的值。填写完宾客姓名后，按下TAB键，Xcode会把光标放到你需要的位置，以便你填写下一个输入值。（参见[图7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-1500
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：输入宾客姓名后按TAB键将光标移动到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你rsvped的数据类型。将占位符文本Bool替换为true或false。如果你尝试传入其他内容，比如名字或数字，你将会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-1503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用`print(_:)`时，你没有在输入值前面添加参数标签？你只需要写：
- en: '[PRE286]'
  id: totrans-1505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加一个标签，你将会遇到错误：
- en: '[PRE287]'
  id: totrans-1507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，而且这个标签与参数名相同。然而，如果你编写一个函数，并且觉得在函数定义中省略参数标签不会影响代码的清晰度，那么你可以明确地省略它。例如，在`print(_:)`函数中，很明显你传入的输入是一个将被打印的字符串。如果每次调用`print(_:)`时都必须包括像`inputString`这样的参数标签，那会让人感到很烦恼。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号以及最后的参数数据类型来实现。所有这些操作都在你首次声明函数括号中的参数时进行，这通常是在
    func 关键字之后。在 Swift 函数中，这样做可以使函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-1510
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6: sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 friend，参数标签是 to，而在函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用该函数时看起来会像
    `sayHello(friend:)`，这听起来不太像一个完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何编写带有自定义参数标签的函数。我们还会向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-1514
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，看看添加自定义参数标签如何使代码更具可读性。在你的生日派对结束后，你会想给所有客人发送感谢信。请在你的 playground 中编写以下函数：
- en: '[PRE288]'
  id: totrans-1516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了自定义参数标签 to。类似地，在 ➋ 处，我们为 gift 参数添加了参数标签 for。参数名 guest
    ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，如下所示：
- en: '[PRE289]'
  id: totrans-1519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 被写在函数调用中的第一个输入值之前，for: 被写在第二个输入值之前。如果一个参数有自定义的参数标签，那么在函数调用中必须使用该标签。试图使用参数名代替将会导致错误：'
- en: '[PRE290]'
  id: totrans-1521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填写参数标签，因此你不必担心函数调用不正确（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-1523
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7: Xcode 自动完成带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用来向客人发送感谢信 *to* 一份礼物。代码
    `sendThankYou(to: "Meghan", for: "puzzle books")` 看起来更像一个句子，而不像 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-1526
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-1527
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前添加一个下划线和空格来去除它们。在下面的示例中，我们编写了一个用于计算体积的函数，它接受一个盒子的三条边作为输入。因为函数名已经明确指出需要传入三条边，所以实际上你并不需要参数标签来使代码更易读。
- en: '[PRE291]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处的 side1、➋ 处的 side2 和 ➌ 处的 side3 前面放置下划线来去除边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你调用这个函数时，只需输入参数值而不需要任何标签。
- en: '[PRE292]'
  id: totrans-1532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。" 如果你能将结果存储在一个变量或常量中，以便稍后使用，而不是仅仅打印出盒子的体积，岂不是很有用吗？让我们来看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-1534
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-1536
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能装更多的东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，它返回一个盒子体积的 Int 值：
- en: '[PRE293]'
  id: totrans-1538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数设置返回值，在函数的输入参数之后 ➊ 使用一个破折号和一个大于号形成一个箭头 (->)，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你可以使用
    return 关键字返回你希望返回的值 ➋。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值之后结束。如果你在返回语句后再写任何代码，它将被忽略，因为
    return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-1540
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-1542
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算了一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条消息，说明哪个盒子更大：
- en: '[PRE294]'
  id: totrans-1544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台看到 "盒子 1 是更大的盒子。" 的字符串输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-1546
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，它接受一个测试分数数组并返回平均分数。为了计算平均分，你需要将所有分数加起来，然后除以分数的总数。在你的
    playground 中输入以下代码：
- en: '[PRE295]'
  id: totrans-1548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始值设为 0。➋ 处的 `for-in` 循环遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量就保存了所有分数的总和。在我们计算出总和后，剩下的就是将其除以分数的总数量，简单地就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果数组为空怎么办？你不能将某个数除以零——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试除以零会导致“除零错误”，并使程序崩溃。因此，在进行除法操作时，务必确保你要除的数不是零，这就是我们通过检查
    `scores.count > 0` 来做到的。然后在 ➍ 处，我们通过 `return sum / scores.count` 将分数总和除以分数的数量，返回平均值。没错！你可以返回任何求值为正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋给新变量的步骤，直接返回
    `sum / scores.count`，因为它会求值为 `Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 `scores.count` 不大于零时返回某些内容，否则会出现函数缺少返回值的错误。我们通过在 `if` 语句中添加 `else`
    来处理这个问题，返回 0 ➎ 。你可以通过在一个包含分数的数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-1552
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 `averageOf()` 函数时，就像我们在 ➊ 处所做的那样，分数的平均值将会被返回并显示在结果面板中。如果你传递的是一个空数组，就像我们在
    ➋ 处所做的那样，返回值是 0。
- en: '**NOTE**'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 `else` 语句其实并不是必需的。这是因为如果 `scores.count > 0`，那么函数已经通过
    `return sum / scores.count` 提前结束了。所以如果计算机已经跳过了那个 `if` 语句，我们就知道 `scores.count >
    0` 肯定不成立，我们可以直接返回 0，而不需要将它包含在 `else` 中。然而，如果我们保留 `else` 语句，代码会更加清晰易懂。有时候，写一些额外的代码来让别人更容易理解，比起使用巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-1556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以完成各种神奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建具有其他类型的常量和变量，而不是仅限于
    Swift 中已包含的那些类型，这在你创建应用时会非常有用！
- en: '[PRE296]'
  id: totrans-1559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: print(_:) 函数接受一个输入值，但没有返回值。在这个例子中，输入值是字符串 "Swift is awesome!"。print(_:) 函数将在调试控制台中显示它所接收到的字符串，然后结束而不返回任何东西。没有返回值的函数有时被称为
    *void 函数*。我们将在 “[返回值](text00017.html#ch07lev1sec5)” 中，位于 [第 91 页](text00017.html#page_91)，看到一个有输入参数和返回值的函数示例。
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写可以处理输入并返回输出的函数，你可以创建各种各样的应用程序！
- en: '**WRITING A CUSTOM FUNCTION**'
  id: totrans-1562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写自定义函数**'
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的函数来打印一个 *haiku*，它是一种传统的日本诗歌，包含三行，其中第一行和第三行有五个音节，中间一行有七个音节。将以下代码输入到你的
    playground 中：
- en: '[PRE297]'
  id: totrans-1564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，写下 func 关键字 ➊，然后是函数的名称。当你创建一个函数时，必须为它命名，这样你就可以在需要时调用它来执行任务。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数的规则与命名变量相同：从小写字母开始，并使用驼峰命名法将每个新词的首字母大写。你还应该给函数起一个能够描述其功能的名字。你不觉得 printAHaiku()
    是一个很好的名字吗？它能够准确地描述一个打印简单 Swift haiku 的函数。
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名后面有一对圆括号 ➋。如果你的函数有输入参数，你应该把它们放在这对圆括号内。在这个例子中，你没有任何输入参数，所以可以把圆括号留空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的 *主体* 被大括号包围。这里是你编写函数代码的地方。你应该在与函数名称同一行放置左大括号（{），然后在函数的末尾单独一行放置右大括号（}）。在这个例子中，函数主体包含了所有打印
    haiku 的 print 语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-1569
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数时，只需写下它的名称，后跟圆括号并在其中传入任何参数。这就是 *函数调用*。在这个例子中，因为 printAHaiku() 没有输入参数，所以你不需要传入任何参数——只需保持圆括号为空。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 printAHaiku()，在函数的闭括号后面添加以下代码行：
- en: '[PRE298]'
  id: totrans-1572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'The console output is:'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出为：
- en: '[PRE299]'
  id: totrans-1574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，可以随时调用它，函数内部的代码就会执行。确保你打开了调试区域（⌘ -SHIFT -Y），就像在[图 7-1](text00017.html#ch07fig1)中那样，这样你就能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-1576
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用 printAHaiku() 函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-1579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数使用输入参数能做更多的事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，你看到函数如何帮助你节省时间和精力。当你编写一个函数时，你可以在任何地方调用它，而不是在多个地方重复一段代码。这当然很酷，但函数的真正威力是在你传入一个或多个输入值以生成不同的结果时展现出来的。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-1581
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 invite(guest:) 的函数，它接受一个人的名字作为输入，并生成一个个性化的生日派对邀请函。在 Playground 中输入以下内容：
- en: '[PRE300]'
  id: totrans-1583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将其包含在函数名后的括号内 ➊。你需要首先写入输入参数的名称（在这个例子中是 guest），然后是冒号（:），最后是数据类型（在本例中是
    String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，所以当你调用这个函数时，guest 将作为参数标签。（你将在 “[参数标签](text00017.html#ch07lev1sec4)”
    章节的 [第 89 页](text00017.html#page_89) 学到如何定义独立的参数名和参数标签。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后写入输入参数的数据类型，就像声明变量时一样。然而，与变量声明不同的是，在定义函数参数时，你*必须*始终声明函数应该期待的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-1587
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需像使用其他常量一样使用其参数名 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅定义一个函数还不够。现在函数已经定义好了，我们来在 Playground 中调用它看看会发生什么。你可以通过输入函数名，后跟括号内的参数标签、冒号和参数来调用一个有输入参数的函数，像这样：
- en: '[PRE301]'
  id: totrans-1590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写出函数名来调用一个函数时，Xcode 的自动完成功能会给你提示，告诉你应该传入什么值。在这种情况下，当你开始写 invite 时，你会看到一个下拉菜单，如
    [图 7-2](text00017.html#ch07fig2) 所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-1592
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成将展示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 按 ENTER 键自动完成函数。你的光标将跳入函数的括号内（见 [图 7-3](text00017.html#ch07fig3)），Xcode 会自动添加一些占位符文本，告诉你该函数预期的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-1595
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递一个不是字符串的值给 invite(guest:)，比如 invite(guest: 45)，你将得到一个错误，因为该函数期待的是字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 位置输入 "Cathy" 或其他朋友的名字，然后按 TAB 键完成函数调用的填写。它应该像 [图 7-4](text00017.html#ch07fig4)
    一样。
- en: '![Image](Image00157.jpg)'
  id: totrans-1600
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，接下来用你自己的朋友的名字调用三次`invite(guest:)`函数：
- en: '[PRE302]'
  id: totrans-1603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'The output looks like this:'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来是这样的：
- en: '[PRE303]'
  id: totrans-1605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的`invite(guest:)`函数，你可以快速打印出三张派对邀请函，每一张都发给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-1607
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以写一个函数，通过传入一个字符串数组作为参数，而不是单一的字符串，一次性邀请所有朋友。在你写了`invite(guest:)`函数的同一个playground中，写下以下`invite(allGuests:)`函数进行测试。注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-1609
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE304]'
  id: totrans-1610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当你声明函数的参数时，你会注意到[String]被放在方括号中➊。方括号声明数据类型为数组，String表示数组中值的数据类型。通过使用[String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 在`invite(allGuests:)`函数内部，我们需要使用一个for-in循环遍历我们的客人数组，并为每个客人打印一张邀请函。还记得我们刚才创建了一个打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到你的`invite(allGuests:)`函数中（灰色文本显示的是现有的代码行）：
- en: '[PRE305]'
  id: totrans-1613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对字符串数组allGuests中的每个guest调用`invite(guest:)`函数，邀请每个人参加生日派对。你可能会想，`invite(guest:)`和`invite(allGuests:)`是同一个函数吗？毕竟，它们都叫做invite。不过，尽管它们名字相同，它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常会看到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`invite(allGuests:)`函数，我们首先创建一个名为friends的数组，然后将在函数调用中使用该数组。
- en: '[PRE306]'
  id: totrans-1616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组➊。然后我们用这个新数组作为函数的输入来调用函数➋。这是你在调试控制台中看到的输出（`-- snip --`表示我们为了节省空间而省略的部分行）：
- en: '[PRE307]'
  id: totrans-1618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友单独写邀请函，那会花费很多时间。但通过函数的强大功能，你用极少的代码行就完成了这项工作。试着创建你自己的朋友数组，长度可以任意！然后用你的新数组作为输入调用`invite(allGuests:)`函数。简直轻而易举！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-1620
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近，一些客人还没有回复。你想要最终确认人数，并告诉客人们带上泳衣，因为这将是一个滑水派对。你可以写一个函数，根据他们的RSVP状态向每个客人发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-1622
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 你新的函数将接受两个输入参数：一个String类型的参数，用来表示客人的名字；一个Bool类型的参数，用来表示RSVP状态，值可以是true或false。在你的playground中输入以下代码：
- en: '[PRE308]'
  id: totrans-1624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加一个逗号 ➊。每个参数都需要有一个参数名称，后面跟着冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，这些参数可以是不同类型的。在sendMessage(guest:rsvped:)函数中，我们传入了一个String类型的guest参数和一个Bool类型的rsvped参数。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped的值，看看它是否为真 ➋，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最后打印语句无论rsvped的值为真还是假都会执行，因为它们在if-else语句的花括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经RSVP（确认出席），他们会看到以下消息：
- en: '[PRE309]'
  id: totrans-1628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提醒，要求他们回复：
- en: '[PRE310]'
  id: totrans-1630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数来看看它是如何工作的。尝试将一个客人的rsvped值设置为真，另一个客人的rsvped值设置为假，这样你就可以看到两个消息的实际效果。
- en: '[PRE311]'
  id: totrans-1632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会帮助你填写输入值，并为你提供参数标签。你只需传入你想使用的值。填写完客人名字后，按TAB键，Xcode会将光标放到你需要填写下一个输入值的位置。（参见[图7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-1635
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：在输入客人的名字后按TAB键，光标会自动跳到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你rsvped的数据类型。将占位符文本Bool替换为true或false。如果你尝试传入其他类型的值，比如名字或数字，你会得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-1638
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，在调用print(_:)时，你并没有在输入值前面加上参数标签？你写的是：
- en: '[PRE312]'
  id: totrans-1640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，你会得到一个错误：
- en: '[PRE313]'
  id: totrans-1642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且该标签与参数名相同。然而，如果你编写一个函数，觉得参数标签并不必要来使代码更加清晰，那么你可以在函数定义中显式省略它。例如，在print(_:)函数中，很明显你传入的输入是一个将被打印的字符串。每次调用print(_:)时都必须包含像inputString这样的参数标签会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号，最后是参数的数据类型来实现。在你第一次声明函数括号中的参数时就可以完成这一操作，这通常用于
    Swift 函数，以使函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6) 演示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-1645
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend ，参数标签是 to ，函数调用中的传入参数是 "Colin" 。如果没有单独的参数标签，当你调用函数时，它可能会变成
    sayHello(friend:) ，这听起来不像是一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何编写带有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-1649
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例，看看如何通过添加自定义参数标签使你的代码更具可读性。在你庆祝完生日派对后，你可能想要给所有的客人发送感谢卡片。在你的 playground
    中写下以下函数：
- en: '[PRE314]'
  id: totrans-1651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了一个自定义参数标签 to 。同样，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for 。参数名
    guest ➌ 和 gift ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于标记函数调用时的参数，如下所示：
- en: '[PRE315]'
  id: totrans-1654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 被写在第一个输入值之前，for: 被写在第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用中使用它。如果你尝试使用参数名，编译器会报错：'
- en: '[PRE316]'
  id: totrans-1656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填充参数标签，因此你不必担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-1658
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成具有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于给客人发送感谢卡片 *to* （给）某位客人
    *for* （感谢）某个礼物。代码 sendThankYou(to: "Meghan", for: "puzzle books") 比 sendThankYou(guest:
    "Meghan", gift: "puzzle books") 更像一句完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-1661
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-1662
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前加下划线和空格来去掉它们。在以下示例中，我们编写了一个计算体积的函数，该函数接受盒子的三个边作为输入。因为函数名已经明确表示需要传入三个边，所以实际上不需要参数标签来增加代码的可读性。
- en: '[PRE317]'
  id: totrans-1664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处为side1、➋处为side2、➌处为side3前加下划线来移除参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需要输入参数值，不需要任何标签。
- en: '[PRE318]'
  id: totrans-1667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“该盒子的体积是72。”如果你可以将体积存储在变量或常量中，以便稍后使用，而不是仅仅打印出来，那是不是会更有用呢？让我们看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-1669
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-1671
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个能装更多东西。首先，编写一个名为volumeOfBox(_:_:_:)的函数，返回盒子的体积（Int）：
- en: '[PRE319]'
  id: totrans-1673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数提供返回值，使用短横线和大于号（->）在函数输入参数后面形成一个箭头 ➊ ，然后输入返回值的数据类型。注意，返回值不需要提供名称，只需提供数据类型。在函数体内，使用return关键字后跟你想返回的值来返回该值
    ➋ 。如果你编写的函数有返回值，那么你*必须*在函数内返回该值，否则会报错。函数在返回值后结束。如果你在return语句后面写了任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-1675
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的盒子调用该函数，看看它的效果：
- en: '![](Image00165.jpg)'
  id: totrans-1677
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算一个边长为6、5、3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋处，边长为8、4、2的volumeOfBox2被赋值为64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE320]'
  id: totrans-1679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到输出字符串“Box 1 is the bigger box.”。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-1681
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，它接受一个测试成绩的数组并返回平均分数。为了计算平均值，你将所有成绩相加，然后除以成绩的总数。在你的playground中输入以下代码：
- en: '[PRE321]'
  id: totrans-1683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在➊处，我们定义了一个名为`sum`的Int类型变量，并将其初始值设为0。➋处的`for-in`循环遍历`score`数组中的每个值，并将其加到`sum`变量中。当循环完成后，`sum`变量将保存所有成绩的总和。计算完总和后，剩下的就是将它除以总的成绩数，即`score.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空怎么办？你不能用零去做除法——无论是在数学课上还是在Swift中。在Swift中，尝试进行零除法会导致“除零错误”，并使程序崩溃。因此，在进行除法时，务必确保你要除的数字不是零，这就是我们通过在➌处检查`scores.count
    > 0`来做到的。在➍处，我们通过将成绩总和除以数组中成绩的数量来返回平均值，使用的是`return sum / scores.count`。没错！你可以返回任何计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回`sum
    / scores.count`，因为它计算出的结果是一个Int类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`score.count`不大于零时，我们还需要返回一个值，否则会出现“函数缺少返回值”的错误。我们通过在`if`语句中添加`else`来处理这个问题，返回0，位置在➎。你可以通过在一个成绩数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-1687
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给`averageOf()`函数时，就像我们在➊处所做的那样，函数返回的平均值将会显示在结果窗格中。如果你传入一个空数组，就像我们在➋处所做的那样，返回值为0。
- en: '**NOTE**'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，`else`语句包裹`return 0`其实并不是必要的。这是因为如果`scores.count > 0`，那么函数已经会通过`return
    sum / scores.count`提前结束了。所以如果计算机执行到`if`语句之后，就说明`scores.count > 0`并不为真，我们可以直接使用`return
    0`，而不需要将它放在`else`语句里。然而，如果我们保留`else`语句，代码会更加清晰，更易于理解。有时，写一些额外的代码来让别人更容易理解，比起使用一个巧妙的快捷方式会更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-1691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要工具——创建并调用你自己的函数！函数在编程中被广泛使用，用来做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让你可以创建除了Swift中已包含的类型之外的常量和变量，这在你开发应用时会非常有用！
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(_:)`函数接受一个输入值，但没有返回值。在这种情况下，输入值是字符串"Swift is awesome!"。`print(_:)`函数会在调试控制台显示它收到的字符串，然后结束而不返回任何内容。没有返回值的函数有时称为*空函数*。我们将在[第91页](text00017.html#page_91)的“[返回值](text00017.html#ch07lev1sec5)”部分看到一个包含输入参数和返回值的函数示例。'
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写能够处理输入并返回输出的函数，您可以创建各种应用程序！
- en: '**WRITING A CUSTOM FUNCTION**'
  id: totrans-1696
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写自定义函数**'
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的函数来打印*俳句*，这是一种传统的日本诗歌，包含三行，其中第一行和第三行有五个音节，第二行有七个音节。在您的Playground中输入以下内容：
- en: '[PRE322]'
  id: totrans-1698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要写出`func`关键字 ➊，然后是函数的名称。当您创建一个函数时，必须给它起个名字，以便在需要执行任务时可以调用它。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数的规则与命名变量的规则相同：您从小写字母开始，并使用驼峰命名法将每个新词的首字母大写。您还应该给函数起一个描述其功能的名字。您不觉得`printAHaiku()`是一个很适合打印简单Swift俳句的函数名吗？
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名称后面有一对圆括号 ➋。如果您的函数有输入参数，您将把它们包含在这些圆括号内。在这个示例中，您没有任何输入参数，因此只需将圆括号留空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被大括号包围。这里是您编写函数代码的地方。您将开括号（{）放在函数名称的同一行，并将闭括号（}）放在函数末尾的单独一行。在这个示例中，函数的主体包含了所有打印俳句的`print`语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-1703
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，您只需写出它的名称，后跟圆括号，括号中可以包含任何参数。这是一个*函数调用*。在这种情况下，由于`printAHaiku()`没有输入参数，您无需传入任何参数——只需保持括号为空即可。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用`printAHaiku()`，在函数的闭括号之后向您的Playground中添加以下行：
- en: '[PRE323]'
  id: totrans-1706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: 'The console output is:'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出为：
- en: '[PRE324]'
  id: totrans-1708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经定义了这个函数，您可以随时调用它，函数中的代码将会运行。确保您已打开调试区域（⌘ -SHIFT -Y），如[图7-1](text00017.html#ch07fig1)所示，这样您就能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-1710
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用`printAHaiku()`函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-1713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数在输入参数方面还能做更多事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一个例子中，你看到了函数如何帮助节省时间和精力。当你编写一个函数时，可以在任何地方调用它，而无需在多个地方重复代码块。这当然很酷，但函数的真正强大之处在于当你传入一个或多个输入值时，它可以产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-1715
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**创建聚会邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 invite(guest:) 的函数，它接受一个人的名字作为输入，并创建一份个性化的生日派对邀请函。在你的 playground 中输入以下内容：
- en: '[PRE325]'
  id: totrans-1717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将其包含在函数名后的圆括号中 ➊。你按照先写参数名（在这个例子中是 guest），然后是冒号（:），最后是数据类型（在本例中是
    String）来格式化输入参数。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，因此 guest 在你调用该函数时将成为参数标签。（你将在“[参数标签](text00017.html#ch07lev1sec4)”一节中学习如何定义单独的参数名和参数标签，详见[第
    89 页](text00017.html#page_89)。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: 你在输入参数后面用冒号来指定数据类型，就像声明变量时一样。然而，与变量声明不同，在定义函数参数时，你*总是*必须声明函数期望的输入数据类型；这里不会进行类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-1721
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内使用输入参数，你只需使用其参数名，就像使用任何其他常量一样 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数还不够。现在函数已经定义好，让我们在 playground 中调用它看看会发生什么。你可以通过输入函数名，后面加上圆括号、参数标签、冒号和参数值来调用一个带有输入参数的函数，格式如下：
- en: '[PRE326]'
  id: totrans-1724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写出函数名来调用一个函数时，Xcode 的自动补全会提示你应该传递什么参数给函数。在这种情况下，当你开始写 invite 时，你会看到一个下拉菜单，如[图
    7-2](text00017.html#ch07fig2)所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-1726
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动补全会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键来自动补全函数。你的光标会跳到函数的圆括号中（参见[图 7-3](text00017.html#ch07fig3)），此时 Xcode
    已自动添加了一些占位文本，告诉你函数期望什么类型的输入。
- en: '![Image](Image00156.jpg)'
  id: totrans-1729
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递给invite(guest:)的不是字符串类型的参数，比如invite(guest: 45)，你会得到一个错误，因为该函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 位置输入“Cathy”或其他朋友的名字，然后按下 TAB 键完成函数调用的填写。它应该看起来像[图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-1734
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用。*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用invite(guest:)三次，使用你自己朋友的名字：
- en: '[PRE327]'
  id: totrans-1737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'The output looks like this:'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE328]'
  id: totrans-1739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你可以快速打印出三张聚会邀请函，每张邀请函都发送给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-1741
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，通过传入一个字符串数组作为参数，而不是单个字符串，一次性邀请所有朋友。在你编写invite(guest:)的同一个playground中，编写以下invite(allGuests:)函数来进行测试。请注意，参数名现在是复数形式，因为我们要一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-1743
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE329]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被方括号括起来 ➊ 。方括号声明数据类型为数组，而String表示数组中值的数据类型。通过使用[String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们需要使用for-in循环遍历我们的客人数组，并为每个客人打印一张邀请函。还记得我们刚才创建的打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本显示的是现有的代码行）：
- en: '[PRE330]'
  id: totrans-1747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对字符串数组allGuests中的每个guest调用单一的invite(guest:)函数，邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟，它们的名字都叫invite。然而，尽管名字相同，它们是两个不同的函数，因为它们接受的输入参数不同。这是你在Swift中经常会看到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后将其用作函数调用的参数。
- en: '[PRE331]'
  id: totrans-1750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后我们使用新数组作为函数输入调用该函数 ➋ 。这是你在调试控制台中看到的输出（-- snip --表示我们为节省空间而省略的代码行）：
- en: '[PRE332]'
  id: totrans-1752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友单独写邀请函，那会非常繁琐。但通过函数的强大功能，你只用了很少的代码行就完成了这一任务。试着创建你自己的朋友数组，长度随你想！然后，使用你新创建的数组作为输入，调用invite(allGuests:)函数。轻松搞定！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-1754
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期临近，有些客人还没有回复是否参加。你想要最终确认人数，并告诉客人带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据每位客人的RSVP状态发送自定义消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-1756
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新函数将接受两个输入参数：一个 String 类型的客人姓名参数和一个 Bool 类型的 RSVP 状态参数，其值为 true 或 false。请在您的
    playground 中输入以下代码：
- en: '[PRE333]'
  id: totrans-1758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数需要多个输入参数时，您需要在每个参数之间添加逗号 ➊。每个参数都需要有一个参数名，后面跟一个冒号和参数的数据类型。您可以创建一个接受任意数量输入参数的函数，这些参数不必是相同类型的。在
    `sendMessage(guest:rsvped:)` 函数中，我们传入了一个 String 类型的 guest 和一个 Bool 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 `rsvped` 的值是否为 true ➋，然后使用 if-else 语句打印相应的消息。还要注意，函数定义中的最后一条 `print`
    语句会在 `rsvped` 的值为 true 或 false 时都运行，因为它们位于 if-else 语句的外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的客人已经回复，将收到以下消息：
- en: '[PRE334]'
  id: totrans-1762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提醒，要求他们做出回复：
- en: '[PRE335]'
  id: totrans-1764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一个客人的 `rsvped` 值设置为 true，另一个设置为 false，这样您就可以看到两条消息的实际效果。
- en: '[PRE336]'
  id: totrans-1766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能将帮助您填写输入值，并为您提供参数标签。您只需传入您想使用的值即可。填写完客人姓名后，按 TAB 键，Xcode 会将光标放置到您需要填写下一个输入值的位置。（请参见[图
    7-5](text00017.html#ch07fig5)）。
- en: '![Image](Image00160.jpg)'
  id: totrans-1769
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按 TAB 键，光标会跳到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉您 `rsvped` 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果您尝试传入其他内容，比如名字或数字，您将收到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-1772
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 您有没有注意到，当您调用 `print(_:)` 时，您没有在输入值前加上参数标签？您写的是：
- en: '[PRE337]'
  id: totrans-1774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试包含标签，您会收到一个错误：
- en: '[PRE338]'
  id: totrans-1776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而另一些没有。默认情况下，当您编写函数时，每个参数都会有一个参数标签，且参数标签与参数名相同。然而，如果您编写一个函数时认为参数标签并不必要以使代码更清晰，那么您可以在函数定义中显式省略它。例如，在
    `print(_:)` 函数中，很明显您传入的是一个字符串，将会被打印。如果每次调用 `print(_:)` 都必须包含 `inputString` 这样的参数标签，肯定会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现这一点。这一切都在你第一次声明函数括号内的参数时完成，在
    `func` 关键字之后。Swift 函数中通常这样做，使得函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)
    说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-1779
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 `friend`，参数标签是 `to`，而函数调用中传递的参数是 "Colin"。如果没有单独的参数标签，调用该函数时看起来会像
    `sayHello(friend:)`，这听起来不太像一句完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-1783
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，展示如何通过添加自定义参数标签使代码更易读。在你的生日派对后，你会想要给所有的宾客发送感谢信。请在你的 Playground 中编写以下函数：
- en: '[PRE339]'
  id: totrans-1785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 `guest` 参数添加了自定义参数标签 `to`。同样，在 ➋ 处，我们为 `gift` 参数添加了参数标签 `for`。参数名称
    `guest` ➌ 和 `gift` ➍ 用于函数内部引用参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，参数标签 `to` 和 `for` 用于标识参数，如下所示：
- en: '[PRE340]'
  id: totrans-1788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `to:` 被写在函数调用中第一个输入值之前，而 `for:` 被写在第二个输入值之前。如果参数有自定义参数标签，你必须在函数调用中使用它。试图使用参数名称会导致错误：
- en: '[PRE341]'
  id: totrans-1790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填充参数标签，因此你不需要担心错误地调用函数（参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-1792
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动为函数填写正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于给宾客发送感谢信 *to* 一个宾客 *for*
    一份礼物。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 读起来更像一句句子，而不是 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-1795
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-1796
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加上一个下划线和一个空格来去除它们。在下面的示例中，我们写了一个计算体积的函数，它以盒子的三个边长为输入。由于函数名称已经清楚地表明需要传入三个边长，因此你不需要参数标签来让代码更具可读性。
- en: '[PRE342]'
  id: totrans-1798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处将下划线放在 side1 前，➋ 处将下划线放在 side2 前，➌ 处将下划线放在 side3 前，移除了边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值而不带任何标签。
- en: '[PRE343]'
  id: totrans-1801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将输出 "The volume of this box is 72."。如果你可以将结果存储在变量或常量中，以便以后使用，而不仅仅是简单地打印盒子的体积，难道不是很有用吗？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-1803
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，让它返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-1805
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个能装更多东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，用于返回盒子的体积（Int 类型）：
- en: '[PRE344]'
  id: totrans-1807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数返回值，在输入参数之后使用破折号和大于符号（->）组成箭头，然后输入返回值的数据类型 ➊。请注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，通过使用
    return 关键字后跟你想要返回的值来返回该值 ➋。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在你返回值后结束。如果你在
    return 语句后再写任何代码，它将被忽略，因为 return 会使函数退出。
- en: '![Image](Image00164.jpg)'
  id: totrans-1809
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，观察其运行效果：
- en: '![](Image00165.jpg)'
  id: totrans-1811
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE345]'
  id: totrans-1813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-1815
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，它接受一个测试成绩数组，并返回平均分。为了得到平均分，你需要将所有成绩加起来，然后除以成绩的总数。在你的
    Playground 中输入以下代码：
- en: '[PRE346]'
  id: totrans-1817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始值设置为 0。➋ 处的 for-in 循环会遍历
    scores 数组中的每个值，并将其加到 sum 变量中。当循环完成时，sum 变量将保存所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，这个值就是
    scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办？你不能将一个数除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误，并使程序崩溃。因此，在进行除法时，始终确保你要除的数不是零，这就是我们在
    ➌ 处通过检查 scores.count > 0 所做的。到 ➍ 处，我们通过将分数的总和除以数组中分数的数量来返回平均值，代码是 return sum /
    scores.count。没错！你可以返回任何求值后得到正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 sum / scores.count，因为它求值后是一个
    Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 scores.count 不大于零时返回一些内容，否则我们会收到函数缺少返回值的错误。我们通过在 if 语句中添加 else
    来处理这个问题，返回 0 ➎。你可以通过调用函数来测试这段代码，传入一个分数数组和一个空数组：
- en: '![](Image00166.jpg)'
  id: totrans-1821
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传入 averageOf() 函数时，如我们在 ➊ 处所做的那样，返回的就是分数的平均值，并显示在结果窗格中。如果你传入一个空数组，如我们在
    ➋ 处所做的那样，返回值则是 0。
- en: '**NOTE**'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不是必要的。因为如果 scores.count > 0，那么函数已经通过 return
    sum / scores.count 结束了。所以，如果程序已经通过了那个 if 语句，我们知道 scores.count > 0 一定不成立，我们完全可以直接写
    return 0，而不需要将其放在 else 中。然而，如果保留 else 语句，代码会更加清晰，易于理解。有时候，写一些额外的代码比用复杂的捷径更能让别人理解。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-1825
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛应用，可以做各种了不起的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建类型与 Swift 中已包含的类型不同的常量和变量，这在你创建应用时非常有用！
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写处理输入并返回输出的函数，你可以创建各种各样的应用程序！
- en: '**WRITING A CUSTOM FUNCTION**'
  id: totrans-1829
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写自定义函数**'
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的函数，打印一个*俳句*，它是由三行组成的传统日本诗歌，第一行和第三行有五个音节，第二行有七个音节。将这个代码输入到你的Playground中：
- en: '[PRE347]'
  id: totrans-1831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你写出func关键字 ➊，然后是你的函数名。当你创建一个函数时，必须给它一个名字，以便你想调用它时能够执行其任务。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: 函数命名规则与变量命名规则相同：以小写字母开头，之后使用驼峰命名法将每个新词的首字母大写。你还应该给函数起一个能描述其功能的名字。你不觉得printAHaiku()是一个很棒的名字吗？它正好描述了一个打印简单Swift俳句的函数。
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名后面是成对的括号 ➋。如果你的函数有输入参数，应该将它们放在这些括号中。在这个例子中，函数没有输入参数，所以括号是空的。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被花括号包围。这是你编写函数代码的地方。你应该将起始花括号（{）放在与函数名同一行，结束花括号（}）则单独放在函数的最后一行。在这个例子中，函数的主体包含了所有打印俳句的打印语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-1836
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，你只需要写出它的名字，后面跟上括号，并在括号内传入任何参数。这就是一个*函数调用*。在这个例子中，由于printAHaiku()没有输入参数，你不需要传递任何参数——只需将括号留空即可。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用printAHaiku()，在函数的闭合花括号后添加以下一行到你的Playground中：
- en: '[PRE348]'
  id: totrans-1839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: 'The console output is:'
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出是：
- en: '[PRE349]'
  id: totrans-1841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数内的代码将会执行。确保调试区域已打开（⌘ -SHIFT -Y），如[图 7-1](text00017.html#ch07fig1)所示，这样你就能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-1843
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用printAHaiku()函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-1846
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数实现更多功能**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一个例子中，你看到了函数如何节省时间和精力。当你编写一个函数时，可以在任何地方调用它，而不必在多个地方重复写相同的代码。这确实很酷，但函数的真正威力体现在当你传入一个或多个输入值来产生不同结果时。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-1848
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个名为invite(guest:)的函数，它接收一个人的名字作为输入，并创建一份个性化的生日派对邀请函。将以下代码输入到你的Playground中：
- en: '[PRE350]'
  id: totrans-1850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数有输入参数，你需要在函数名后面的括号内包含它 ➊。你需要首先写出输入参数的名字（在这个例子中是guest），然后是冒号（:），最后是它的数据类型（在本例中是String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，因此当你调用这个函数时，guest 将是参数标签。（你将在 “[参数标签](text00017.html#ch07lev1sec4)”
    一节的[第 89 页](text00017.html#page_89) 学到如何定义单独的参数名和参数标签。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后面写输入参数的数据类型，就像声明一个变量时一样。然而，不同于变量声明的是，在定义函数参数时，你必须*始终*声明函数应期待的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-1854
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需像使用任何其他常量一样使用它的参数名 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数还不够。现在函数已经定义，我们在 playground 中调用它，看看会发生什么。你可以通过输入函数名，后面跟上括号内的参数标签、冒号和参数来调用带有输入参数的函数，像这样：
- en: '[PRE351]'
  id: totrans-1857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过输入函数名来调用函数时，Xcode 的自动完成功能会给出你应该传递给函数的提示。在这种情况下，当你开始输入 `invite` 时，你会看到一个下拉菜单，如[图
    7-2](text00017.html#ch07fig2)所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-1859
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成功能将展示一个函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 按 ENTER 键自动完成函数。你的光标将移动到函数的括号内（见[图 7-3](text00017.html#ch07fig3)），Xcode 会自动添加一些占位符文本，告诉你函数期望什么类型的输入。
- en: '![Image](Image00156.jpg)'
  id: totrans-1862
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递的不是字符串给 invite(guest:)，例如 invite(guest: 45)，你会遇到错误，因为这个函数期待一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 的位置输入 "Cathy" 或其他朋友的名字，然后按 TAB 键完成函数调用。它应该像[图 7-4](text00017.html#ch07fig4)所示。
- en: '![Image](Image00157.jpg)'
  id: totrans-1867
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何填写函数调用，调用 invite(guest:) 三次，使用你自己朋友的名字：
- en: '[PRE352]'
  id: totrans-1870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: 'The output looks like this:'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE353]'
  id: totrans-1872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你可以快速打印三份派对邀请函，每一份都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-1874
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有的朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，一次性邀请所有的朋友，通过传递一个字符串数组作为参数，而不是单个字符串。在你编写了 invite(guest:) 的同一个 playground
    中，编写以下 invite(allGuests:) 函数来进行测试。请注意，参数名称现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-1876
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE354]'
  id: totrans-1877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]是用方括号括起来的 ➊ 。方括号表示数据类型是一个数组，而String表示数组中元素的数据类型。通过使用[String]，我们声明该函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数中，我们需要使用一个for-in循环遍历我们的客人数组，并为每个客人打印邀请函。记得我们之前创建过一个打印邀请函的函数吗？现在就用它！在你的invite(allGuests:)函数中添加以下内容（灰色文本是现有的代码行）：
- en: '[PRE355]'
  id: totrans-1880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对字符串数组allGuests中的每个客人调用invite(guest:)函数，邀请他们参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟，它们都叫invite。尽管它们有相同的名称，但它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常会看到的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后将其作为输入传递给函数。
- en: '[PRE356]'
  id: totrans-1883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后，我们使用新的数组作为函数的输入调用函数 ➋ 。这是你将在调试控制台看到的输出（-- snip -- 表示我们为节省空间省略的部分）：
- en: '[PRE357]'
  id: totrans-1885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为每一个朋友写邀请函，那将会是一项非常繁重的工作。但借助函数的强大功能，你只需要很少的代码行数就能完成这项任务。试着创建你自己的朋友数组；想让它有多长就多长！然后使用新的数组作为输入，调用invite(allGuests:)函数。简直轻而易举！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-1887
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你派对的日期临近，一些客人还没有回复是否参加。你想要确认最终的到场人数，并提醒客人带上泳衣，因为这将是一个滑水派对。你可以写一个函数，根据每个客人的RSVP状态发送个性化的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-1889
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个字符串类型的参数表示客人的名字，一个布尔值类型的参数表示RSVP状态，值可以是true或false。请输入以下代码到你的playground中：
- en: '[PRE358]'
  id: totrans-1891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，参数之间需要用逗号隔开 ➊ 。每个参数都需要有一个参数名，后面跟上冒号和该参数的数据类型。你可以创建一个接受任意数量输入参数的函数，这些参数的数据类型不必相同。在sendMessage(guest:rsvped:)函数中，我们传入了一个字符串类型的guest和一个布尔类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 的值是否为 true ➋，然后使用 if-else 语句打印相应的消息。注意，函数定义中的最后一条 print 语句会在
    rsvped 的值为 true 或 false 时执行，因为它们位于 if-else 语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的来宾已经回复，他们将看到这个消息：
- en: '[PRE359]'
  id: totrans-1895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将看到一条礼貌的提示，请他们回复：
- en: '[PRE360]'
  id: totrans-1897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用函数看看它是如何工作的。试着将一位来宾的 rsvped 值设置为 true，另一位设置为 false，这样你就能看到两条消息的效果。
- en: '[PRE361]'
  id: totrans-1899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用具有多个输入参数的函数与调用只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全会通过为你提供参数标签来帮助你填写输入值。你只需要传入你想使用的值。在填写来宾姓名后，按 TAB 键，Xcode 会将光标放到你需要的位置，以便填写下一个输入值。（见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-1902
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入来宾姓名后按 TAB 键，光标将移至下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，如姓名或数字，将会出现错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-1905
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用 print(_:) 时，输入值前没有参数标签吗？你只需要写：
- en: '[PRE362]'
  id: totrans-1907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加标签，将会出现错误：
- en: '[PRE363]'
  id: totrans-1909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: 某些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且该标签与参数名相同。然而，如果你编写函数时觉得参数标签对于代码的清晰性没有必要，你可以在函数定义中显式省略它。例如，在
    print(_:) 函数中，显而易见你传入的输入是一个将被打印的字符串。每次调用 print(_:) 时都必须包括像 inputString 这样的参数标签会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号，最后是参数的数据类型来完成此操作。所有这些都在你首次声明函数中的参数时，在
    func 关键字后的括号内完成。这通常在 Swift 函数中使用，使函数调用看起来更像一句话。[图 7-6](text00017.html#ch07fig6)
    展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-1912
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 *friend*，参数标签是 *to*，在函数调用中传入的参数是 “Colin”。如果没有单独的参数标签，当你调用函数时，它看起来就像
    `sayHello(friend:)`，这听起来不太像完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-1916
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，看看添加自定义参数标签如何让你的代码更具可读性。生日派对结束后，你会想给所有客人发送感谢信。在你的 Playground 中编写以下函数：
- en: '[PRE364]'
  id: totrans-1918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了自定义参数标签 *to*。类似地，在 ➋ 处，我们为 gift 参数添加了参数标签 *for*。参数名
    guest ➌ 和 gift ➍ 用于在函数内部引用参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 *to* 和 *for* 用于在调用函数时标记参数，像这样：
- en: '[PRE365]'
  id: totrans-1921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到，*to:* 在函数调用中出现在第一个输入值之前，*for:* 出现在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名代替会导致错误：
- en: '[PRE366]'
  id: totrans-1923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会自动为你填充参数标签，因此你无需担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-1925
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成具有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于将感谢信 *to* 客人 *for* 礼物发送给对方。代码
    `sendThankYou(to: "Meghan", for: "puzzle books")` 读起来更像一个句子，而不是 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-1928
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-1929
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前添加一个下划线和一个空格来移除它们。在以下示例中，我们写了一个计算体积的函数，它以盒子的三条边作为输入。因为函数名已经明确指出你需要传入三条边，所以你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE367]'
  id: totrans-1931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处将下划线放在 side1 前面，在 ➋ 处将下划线放在 side2 前面，在 ➌ 处将下划线放在 side3 前面，移除了边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值而不带任何标签。
- en: '[PRE368]'
  id: totrans-1934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-1935
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 “这个盒子的体积是 72。” 如果你能将结果存储到一个变量或常量中，以便以后使用，而不是仅仅打印盒子的体积，这不是更有用吗？让我们来看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-1936
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-1937
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-1938
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并想知道哪个能装更多的东西。首先，编写一个名为volumeOfBox(_:_:_:)的函数，它返回一个Int值，表示盒子的体积：
- en: '[PRE369]'
  id: totrans-1940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数一个返回值，在函数的输入参数后➊使用一个破折号和一个大于号来形成箭头(->)，然后输入返回值的数据类型。注意，你不需要为返回值提供名字，只需要提供数据类型。在函数体内，你通过使用return关键字后跟你想要返回的值➋来返回该值。如果你写了一个返回值的函数，那么你*必须*在函数内部返回这个值，否则会报错。函数在返回值后结束。如果你在return语句之后在函数内写任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-1942
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数来测试两个不同的盒子，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-1944
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算了一个边长为6、5和3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋处，边长为8、4和2的volumeOfBox2被赋值为64。现在让我们打印一条消息，说明哪个盒子更大：
- en: '[PRE370]'
  id: totrans-1946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台中看到字符串"Box 1 is the bigger box."的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-1948
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据某个条件返回不同的值。我们来写一个函数，它接收一个测试分数的数组，并返回平均分数。为了计算平均分，你将分数加起来，然后除以分数的总数。请在你的playground中输入以下代码：
- en: '[PRE371]'
  id: totrans-1950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在➊处，我们定义了一个名为sum的Int变量，并将其初始值设为0。➋处的for-in循环遍历scores数组中的每个值，并将其加到sum变量中。当循环完成时，sum变量保存了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数，即scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组是空的呢？你不能用零去除某个数——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并崩溃程序。因此，在进行除法操作时，始终确保你要除的数不是零，这就是我们在
    ➌ 通过检查 scores.count > 0 所做的。然后在 ➍ 处，我们通过将分数总和除以数组中分数的数量来返回平均值，使用 return sum /
    scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出来的平均值赋给新变量的步骤，直接返回 sum /
    scores.count，因为它的计算结果是一个 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们还需要返回某个值，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加 else 来处理这个问题，从而返回
    0 ➎ 。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-1954
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 averageOf() 函数时，就像我们在 ➊ 所做的那样，函数会返回分数的平均值，并显示在结果面板中。如果你传递一个空数组，就像我们在
    ➋ 所做的那样，返回值将是 0。
- en: '**NOTE**'
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不必要。这是因为如果 scores.count > 0 ，那么函数已经会通过 return
    sum / scores.count 提前结束。所以如果计算机已经跳过了那个 if 语句，我们就知道 scores.count > 0 一定不成立，这时候我们只需要写
    return 0，而不需要将它放在 else 语句中。不过，如果我们保留 else 语句，代码会更加清晰易懂。有时候，为了让其他人更容易理解，写一点多余的代码比使用一个复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-1958
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种各样令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第8章](text00018.html#ch08) 中，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你可以创建具有不同类型的常量和变量，而不是只使用
    Swift 中已有的类型，这在你开发应用时会派上用场！
- en: '**WRITING A CUSTOM FUNCTION**'
  id: totrans-1961
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写自定义函数**'
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的函数，打印一个 *俳句*，它是一个由三行组成的传统日本诗歌，第一行和最后一行各有五个音节，中间一行有七个音节。将以下内容输入到你的 Playground
    中：
- en: '[PRE372]'
  id: totrans-1963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你写上 func 关键字 ➊ ，然后是你函数的名称。当你创建一个函数时，必须给它起个名字，以便在需要时调用它来执行任务。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数的规则与命名变量的规则相同：你从小写字母开始，使用驼峰命名法（camel case）将每个新单词的首字母大写。你还应该给你的函数起一个能描述其功能的名字。你不觉得
    `printAHaiku()` 是一个非常适合打印简单 Swift 俳句的函数名吗？
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名后面有一对圆括号 ➋ 。如果你的函数有输入参数，你需要将它们放在这对括号内。在这个例子中，你没有任何输入参数，所以你只需将括号留空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的 *主体* 被大括号包围。这就是你编写函数代码的地方。你把开括号（{）放在与函数名同一行，闭括号（}）放在函数末尾的单独一行。在这个例子中，函数主体包含所有打印俳句的
    `print` 语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-1968
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，你只需要写出函数名，后面跟着圆括号，并在其中传入任何参数。这就是 *函数调用*。在这个例子中，由于 `printAHaiku()` 没有输入参数，你不需要传入任何参数——只需将括号留空。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 `printAHaiku()`，请在函数的闭括号后将以下代码添加到你的 playground 中：
- en: '[PRE373]'
  id: totrans-1971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: 'The console output is:'
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出是：
- en: '[PRE374]'
  id: totrans-1973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数中的代码就会执行。确保调试区域已打开（⌘ -SHIFT -Y），如 [图 7-1](text00017.html#ch07fig1)
    所示，这样你就可以看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-1975
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用 `printAHaiku()` 函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-1978
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数能做更多的事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，你看到了函数如何节省时间和精力。当你编写一个函数时，你可以在任何地方调用它，而不需要在多个地方重复代码块。这无疑很酷，但函数的真正力量在于当你传入一个或多个输入值时，能够产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-1980
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个名为 `invite(guest:)` 的函数，它接受一个人的名字作为输入，并创建一个个性化的生日派对邀请函。将以下内容输入到你的 playground
    中：
- en: '[PRE375]'
  id: totrans-1982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将其包含在函数名后的圆括号内 ➊ 。你先写上输入参数的名称（在本例中是 guest ），然后是一个冒号（:），最后是数据类型（在本例中是
    String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名称也充当参数标签，所以 guest 将是你调用该函数时的参数标签。（你将在“[参数标签](text00017.html#ch07lev1sec4)”中学习如何定义单独的参数名称和参数标签，详见
    [第89页](text00017.html#page_89)。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
  zh: 你在输入参数后写数据类型，就像声明变量时一样。然而，与变量声明不同，在定义函数参数时，你*必须*始终声明函数期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-1986
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需要使用它的参数名，就像使用任何其他常量一样 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅定义一个函数是不够的。现在函数已经定义好，让我们在 playground 中调用它，看看会发生什么。你可以通过输入函数名，后跟括号内的参数标签、冒号和参数来调用具有输入参数的函数，像这样：
- en: '[PRE376]'
  id: totrans-1989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过输入函数名调用函数时，Xcode 的自动补全会提示你应该传递什么内容给函数。在这种情况下，当你开始输入 invite 时，你会看到类似于[图 7-2](text00017.html#ch07fig2)中的下拉菜单。
- en: '![Image](Image00155.jpg)'
  id: totrans-1991
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动补全会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键以自动完成函数。光标将移动到函数的括号内（参见[图 7-3](text00017.html#ch07fig3)），Xcode 会自动添加一些占位符文本，告诉你函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-1994
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递的不是字符串给 invite(guest:)，例如 invite(guest: 45)，你会得到一个错误，因为函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 位置输入 "Cathy" 或其他朋友的名字，然后按 TAB 键完成填写函数调用。它应该像[图 7-4](text00017.html#ch07fig4)那样。
- en: '![Image](Image00157.jpg)'
  id: totrans-1999
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，尝试调用 invite(guest:) 三次，使用你自己朋友的名字：
- en: '[PRE377]'
  id: totrans-2002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: 'The output looks like this:'
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE378]'
  id: totrans-2004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你可以快速打印三张派对邀请函，每张邀请函都发给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-2006
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个一次性邀请所有朋友的函数，通过传递一个字符串数组作为参数，而不是单个字符串。在你编写 invite(guest:) 的同一个 playground
    中，编写以下 invite(allGuests:) 函数进行测试。请注意，参数名现在是复数形式，因为我们将一次邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-2008
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00158.jpg)'
- en: '[PRE379]'
  id: totrans-2009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到 [String] 是用方括号括起来的 ➊。方括号声明数据类型为数组，而 String 表示数组中值的数据类型。通过使用
    [String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: 在`invite(allGuests:)`函数内部，我们将使用一个for-in循环遍历我们的宾客数组，并为每位宾客打印邀请函。记得我们刚才创建了一个打印邀请函的函数吗？我们就在这里使用它！将以下内容添加到你的`invite(allGuests:)`函数中（灰色文字显示的是现有代码行）：
- en: '[PRE380]'
  id: totrans-2012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-2013
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们调用`invite(guest:)`函数，邀请数组`allGuests`中的每位宾客参加生日派对。你可能会问，`invite(guest:)`和`invite(allGuests:)`是同一个函数吗？毕竟，它们的名字都是`invite`。然而，尽管它们有相同的名字，它们实际上是两个不同的函数，因为它们的输入参数不同。这是你在Swift中经常会见到的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`invite(allGuests:)`函数，我们首先创建一个名为`friends`的数组，然后将该数组用于函数调用。
- en: '[PRE381]'
  id: totrans-2015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后我们使用新的数组作为函数的输入，调用该函数 ➋ 。这是你在调试控制台中看到的输出（-- snip --表示我们省略了某些行以节省空间）：
- en: '[PRE382]'
  id: totrans-2017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为每位朋友单独写出邀请函，那会很麻烦。但是借助函数的力量，你仅用很少的代码就完成了这个工作。试着创建你自己的朋友数组，长度可以随意！然后使用你新创建的数组作为输入，调用`invite(allGuests:)`函数。多么简单！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-2019
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向宾客发送信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-2020
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近了，而一些宾客还没有回复是否参加。你需要确认最终人数，并提醒宾客带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据宾客的RSVP状态，向每位宾客发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-2021
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个String类型的宾客姓名参数和一个Bool类型的RSVP状态参数，值为true或false。在你的playground中输入以下代码：
- en: '[PRE383]'
  id: totrans-2023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊ 。每个参数需要有一个参数名，后面跟上冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，这些参数不必是相同类型的。在`sendMessage(guest:rsvped:)`函数中，我们传入了一个String类型的`guest`和一个Bool类型的`rsvped`。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查`rsvped`的值，看它是否为true ➋ ，然后使用if-else语句打印相应的信息。请注意，函数定义中的最后几条打印语句无论`rsvped`值为true还是false都会执行，因为它们位于if-else语句的外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的宾客已经回复了RSVP，他们将收到如下信息：
- en: '[PRE384]'
  id: totrans-2027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有回复，他们将收到一条礼貌的提醒，要求他们回复：
- en: '[PRE385]'
  id: totrans-2029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。试着将一个来宾的 rsvped 值设置为 true，另一个设置为 false，这样你就能看到两个消息的效果。
- en: '[PRE386]'
  id: totrans-2031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个具有多个输入参数的函数与调用一个只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会帮助你填写输入值，自动提供参数标签。你需要做的只是传入你想要使用的值。填写完来宾姓名后，按 TAB 键，Xcode 会将光标放置到你需要填写下一个输入值的位置。（参见
    [图 7-5](text00017.html#ch07fig5)）。
- en: '![Image](Image00160.jpg)'
  id: totrans-2034
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入来宾姓名后按 TAB 键，将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，如姓名或数字，将会出现错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-2037
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，在调用 print(_:) 时，你没有在输入值前添加参数标签？你是这样写的：
- en: '[PRE387]'
  id: totrans-2039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，你将会遇到一个错误：
- en: '[PRE388]'
  id: totrans-2041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
  zh: 某些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它与参数名相同。然而，如果你编写一个函数，觉得参数标签对于代码的清晰度不是必须的，那么你可以在函数定义中显式省略它。例如，在
    print(_:) 函数中，显然你传入的输入是一个将被打印的字符串。每次调用 print(_:) 时都必须包含像 inputString 这样的参数标签会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-2043
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号，最后是参数的数据类型来实现。在你第一次声明函数参数时，这一切都会发生，在
    func 关键字后的函数括号内完成。Swift 函数中经常这样做，以使函数调用看起来更像一个完整的句子。[图 7-6](text00017.html#ch07fig6)
    展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-2044
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-2046
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，当你调用这个函数时，它将看起来像
    sayHello(friend:)，这听起来不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何编写带有自定义参数标签的函数。我们还将展示如何编写一个函数，在其中完全省略参数标签。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-2048
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示如何添加自定义参数标签可以使你的代码更具可读性。生日派对后，你可能会想给所有客人发送感谢信。在你的playground中编写以下函数：
- en: '[PRE389]'
  id: totrans-2050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-2051
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传入函数的 guest 参数添加了一个自定义参数标签 *to*。类似地，在➋处，我们为 gift 参数添加了参数标签 *for*。函数内部使用参数名称
    guest ➌ 和 gift ➍ 来引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-2052
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用时，参数标签“to”和“for”用于标记参数，像这样：
- en: '[PRE390]'
  id: totrans-2053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到“to:”被写在第一个输入值前，而“for:”被写在第二个输入值前。如果参数有自定义的参数标签，你必须在函数调用中使用它。否则，使用参数名称会导致错误：
- en: '[PRE391]'
  id: totrans-2055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填写参数标签，因此你不必担心错误地调用函数（参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-2057
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成函数并添加正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于给客人发送感谢信，*to* 表示发送对象，*for*
    表示礼物。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 比 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")` 更像一句完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-2060
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-2061
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加上下划线和空格来移除它们。在下面的示例中，我们编写了一个计算体积的函数，该函数接受一个盒子的三个边作为输入。由于函数名已经明确指出你需要传入三个边，因此实际上并不需要参数标签来提高代码的可读性。
- en: '[PRE392]'
  id: totrans-2063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处给side1前加上下划线，在➋处给side2前加上下划线，在➌处给side3前加上下划线，来移除边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，而无需添加标签。
- en: '[PRE393]'
  id: totrans-2066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-2067
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "The volume of this box is 72."。如果你不仅仅打印出盒子的体积，而是将结果存储在一个变量或常量中，以便后续使用，这不是更有用吗？让我们看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-2068
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-2070
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能装更多的东西。首先，编写一个返回盒子体积的 `volumeOfBox(_:_:_:)` 函数：
- en: '[PRE394]'
  id: totrans-2072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数返回值，在函数的输入参数后面使用短横线和大于号形成一个箭头 (->)，然后输入返回值的数据类型 ➊。注意，你不需要为返回值提供名称，只需要数据类型即可。在函数体内，你通过使用
    `return` 关键字后跟要返回的值来返回该值 ➋ 。如果你写了一个返回值的函数，那么你*必须*在函数内返回该值，否则会出现错误。函数在返回值后结束。如果在
    `return` 语句之后写入任何代码，它将被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-2074
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它的实际效果：
- en: '![](Image00165.jpg)'
  id: totrans-2076
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在，让我们打印出一条消息，说明哪个盒子更大：
- en: '[PRE395]'
  id: totrans-2078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台中看到字符串 "Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-2080
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，它接受一个测试成绩的数组并返回平均成绩。为了得到平均成绩，你将所有分数加起来，然后除以总分数。请在你的
    Playground 中输入以下代码：
- en: '[PRE396]'
  id: totrans-2082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的整数变量，并将其初始化为 0。位于 ➋ 的 `for-in` 循环遍历 `scores`
    数组中的每个值，并将其加到 `sum` 变量中。循环完成后，`sum` 变量存储了所有分数的总和。在我们计算出总和后，剩下的就是用总和除以分数的总数，这个总数就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果数组为空怎么办？你不能把一个数除以零——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试除以零会给你一个除零错误，并使程序崩溃。因此，在进行除法时，务必确保除数不为零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来做的事情。在 ➍ 处，我们通过 `return sum / scores.count` 返回平均值。没错！你可以返回任何计算出正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋给新变量的步骤，直接返回
    `sum / scores.count`，因为它的计算结果是一个整数。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-2085
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一些内容，否则会出现函数缺少返回值的错误。我们通过在 `if` 语句中添加 `else`
    来处理这个问题，返回 0 ➎ 。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-2086
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给averageOf()函数时，正如我们在➊处所做的，成绩的平均值会被返回并显示在结果面板中。如果你传入一个空数组，正如我们在➋处所做的，返回值将是0。
- en: '**NOTE**'
  id: totrans-2088
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句其实并不是必须的。这是因为如果scores.count > 0，函数将已经通过return sum
    / scores.count结束。所以如果计算机已经越过了那个if语句，那么我们知道scores.count > 0肯定不成立，我们本来可以直接用return
    0而不需要把它放在else语句中。然而，如果我们保留else语句，代码会更加清晰易懂。 有时候写一点额外的代码使其他人更容易理解，比使用一个巧妙的捷径更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-2090
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-2091
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种各样的惊人事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建具有除Swift内置类型之外的常量和变量，在你创建应用程序时非常实用！
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的函数，打印一个*俳句*，这是一种传统的日本诗歌，由三行组成，第一行和最后一行有五个音节，中间一行有七个音节。将这个代码输入到你的playground中：
- en: '[PRE397]'
  id: totrans-2094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你写出func关键字 ➊，然后是函数的名称。当你创建一个函数时，必须为它起个名字，这样你才可以在需要它执行任务时调用它。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数的规则与命名变量的规则相同：你从小写字母开始，每个新单词首字母大写，采用驼峰命名法。你还应该给函数起一个描述其功能的名字。你不觉得printAHaiku()是一个很好的函数名称，用来打印一个简单的Swift俳句吗？
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-2097
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名称后面是成对的括号 ➋。如果你的函数有输入参数，你应该将它们放入这些括号内。在这个例子中，你没有输入参数，所以只需将括号留空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被大括号包围。这是你将编写函数代码的地方。你将开括号({)放在与函数名同一行，闭括号(})放在函数的最后一行。在这个例子中，函数主体包含了所有打印俳句的print语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-2099
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数时，只需写出其名称，后跟括号并将任何参数放在括号内。这就是*函数调用*。在这种情况下，由于printAHaiku()没有输入参数，你无需传入任何参数——只需将括号留空。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 printAHaiku()，在函数的闭合括号后面向 Playground 添加以下行：
- en: '[PRE398]'
  id: totrans-2102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: 'The console output is:'
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出是：
- en: '[PRE399]'
  id: totrans-2104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，可以随时调用它，函数内部的代码会执行。确保你打开了调试区域（⌘ -SHIFT -Y），就像在[图 7-1](text00017.html#ch07fig1)中那样，这样你就能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-2106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用 printAHaiku() 函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-2109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数对输入参数做得更多**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，你看到函数如何帮助你节省时间和精力。当你编写函数时，你可以在任何你想要的地方调用它，而无需在多个地方重复相同的代码块。这当然很酷，但函数的真正威力在于你传入一个或多个输入值来生成不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-2111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作聚会邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-2112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 invite(guest:) 的函数，它接受一个人的名字作为输入，并创建一个个性化的生日派对邀请函。将以下内容输入到你的 Playground
    中：
- en: '[PRE400]'
  id: totrans-2113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-2114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你将它包含在函数名后面的括号中 ➊。你首先写上输入参数的名称（在此示例中为 guest），然后是冒号（:），最后是它的数据类型（此例为
    String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名称也充当参数标签，因此在调用该函数时，guest 将作为参数标签。（你将在 “[Argument Labels](text00017.html#ch07lev1sec4)”（第
    89 页）中学到如何定义单独的参数名称和参数标签。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入参数后面写上数据类型，就像声明变量时一样。然而，与变量声明不同，在定义函数参数时，你*必须*始终声明函数期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-2117
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-2118
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部使用输入参数时，你只需使用其参数名称，就像使用任何其他常量一样 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数还不够。现在函数已经定义，我们来在 Playground 中调用它，看看会发生什么。你可以通过输入函数名，后跟括号中的参数标签、冒号和参数来调用带有输入参数的函数，像这样：
- en: '[PRE401]'
  id: totrans-2120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-2121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名来调用一个函数时，Xcode 的自动完成功能会给你一个提示，告诉你应该传入什么。在这种情况下，当你开始输入 invite 时，你会看到一个下拉菜单，如[图
    7-2](text00017.html#ch07fig2)所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-2122
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成功能会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
  zh: 按 ENTER 键自动完成函数。您的光标将移动到函数的括号内（见 [图 7-3](text00017.html#ch07fig3)），此时 Xcode
    已自动添加了一些占位符文本，告诉您该函数期望什么类型的输入。
- en: '![Image](Image00156.jpg)'
  id: totrans-2125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待您填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您传递给 invite(guest:) 的不是字符串，例如 invite(guest: 45)，您会遇到错误，因为该函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: 只需键入 "Cathy" 或其他朋友的名字，替换 String 后按 TAB 键完成函数调用。它应该看起来像 [图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-2130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-2131
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您知道如何填写函数调用，使用您朋友的名字三次调用 invite(guest:)：
- en: '[PRE402]'
  id: totrans-2133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: 'The output looks like this:'
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE403]'
  id: totrans-2135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的 invite(guest:) 函数，您可以快速打印三张派对邀请函，每张都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-2137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以编写一个函数，通过传入一个字符串数组作为参数，而不是单个字符串，一次性邀请所有朋友。在您编写 invite(guest:) 函数的同一个 playground
    中，编写以下 invite(allGuests:) 函数进行测试。注意，参数名称现在是复数形式，因为我们要一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-2139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00158.jpg)'
- en: '[PRE404]'
  id: totrans-2140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当您声明函数的参数时，您会注意到 [String] 被放在方括号中 ➊。方括号声明数据类型为数组，String 表示数组中值的数据类型。通过使用
    [String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们希望使用 for-in 循环遍历我们的 guests 数组，并为每个客人打印邀请函。记得我们刚刚创建了一个打印邀请函的函数吗？我们在这里也可以使用它！将以下内容添加到您的
    invite(allGuests:) 函数中（灰色文本显示的是现有行）：
- en: '[PRE405]'
  id: totrans-2143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们对 String 数组 allGuests 中的每个客人调用单一的 invite(guest:) 函数，邀请每个人参加生日派对。你可能会想，invite(guest:)
    和 invite(allGuests:) 是不是同一个函数？毕竟它们的名字都叫 invite。尽管它们共享同一个名字，但它们是两个不同的函数，因为它们接受不同的输入参数。这是您在
    Swift 中常见的一个模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-2145
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 invite(allGuests:) 函数，我们首先创建一个名为 friends 的数组，然后在函数调用中使用它。
- en: '[PRE406]'
  id: totrans-2146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后我们用新的数组作为函数的输入调用函数 ➋。这是在调试控制台中您会看到的输出（-- snip -- 表示我们为节省空间省略了某些行）：
- en: '[PRE407]'
  id: totrans-2148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-2149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要为每个朋友写出邀请函，那会需要花费很多工作。但借助函数的强大功能，您只用了很少的代码就完成了。试着创建自己的朋友数组，尽量做得长一些！然后用新的数组作为输入，调用
    invite(allGuests:) 函数。真是轻松搞定！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-2150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向您的客人发送信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的派对日期临近，有些客人还没有回复 RSVP。您想要确认最终的参加人数，并通知客人们带上泳衣，因为这是一个滑水派对。您可以编写一个函数，根据客人的
    RSVP 状态向每个客人发送定制的信息。
- en: '![Image](Image00159.jpg)'
  id: totrans-2152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新函数将接受两个输入参数：一个 String 类型的参数用于客人姓名，一个 Bool 类型的参数用于 RSVP 状态，值为 true 或 false。在您的
    playground 中输入以下代码：
- en: '[PRE408]'
  id: totrans-2154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，您需要在每个参数之间添加逗号 ➊ 。每个参数需要有参数名，后面跟着冒号和参数的数据类型。您可以创建一个接受任意数量输入参数的函数，而且这些参数不必是相同的类型。在
    sendMessage(guest:rsvped:) 函数中，我们传入了一个 String 类型的 guest 和一个 Bool 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 的值是否为 true ➋ ，然后使用 if-else 语句打印相应的信息。请注意，函数定义中的最终打印语句无论 rsvped
    值是 true 还是 false 都会执行，因为它们位于 if-else 语句的外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的客人已经回复 RSVP，他们会收到这条信息：
- en: '[PRE409]'
  id: totrans-2158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提示，要求他们回复：
- en: '[PRE410]'
  id: totrans-2160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一个客人的 rsvped 值设置为 true，另一个客人的设置为 false，这样您就能看到两个信息的实际效果。
- en: '[PRE411]'
  id: totrans-2162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，调用具有多个输入参数的函数与调用仅有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能将帮助您填写输入值，提供参数标签。您只需传入您想要使用的值即可。填写完客人姓名后，按 TAB 键，Xcode 会将光标移到下一个需要填写输入值的位置。（参见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-2165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入完客人姓名后按 TAB 键会将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉您 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果您尝试传入其他内容，比如名字或数字，您将收到错误提示。
- en: '**ARGUMENT LABELS**'
  id: totrans-2168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-2169
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到，在调用 print(_:) 时，您没有在输入值前添加参数标签？您应该这样写：
- en: '[PRE412]'
  id: totrans-2170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试包含一个标签，您将收到错误提示：
- en: '[PRE413]'
  id: totrans-2172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它将与参数名称相同。然而，如果你编写一个函数并且觉得不需要参数标签来使代码更清晰，你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，传入的参数显然是一个将要打印的字符串。每次调用 print(_:) 时都包含像 inputString 这样的参数标签会让人觉得很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。在函数的括号内声明参数时，这一切都会在函数的定义阶段完成。这通常在
    Swift 函数中使用，以使函数调用看起来更像一句话。[图 7-6](text00017.html#ch07fig6) 说明了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-2175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用函数时看起来会像
    sayHello(friend:)，这听起来不像完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何编写具有自定义参数标签的函数。我们还会展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-2179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示如何通过添加自定义参数标签使代码更具可读性。在你举办完生日派对后，你可能会想给所有客人写感谢信。在你的 playground 中编写以下函数：
- en: '[PRE414]'
  id: totrans-2181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了一个自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名称
    guest ➌ 和 gift ➍ 用于函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，如下所示：
- en: '[PRE415]'
  id: totrans-2184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-2185
  prefs: []
  type: TYPE_NORMAL
  zh: '这里你可以看到，to: 写在第一个输入值之前，for: 写在第二个输入值之前。如果某个参数有自定义的参数标签，你必须在函数调用中使用它。否则，尝试使用参数名称会导致错误：'
- en: '[PRE416]'
  id: totrans-2186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会自动填充参数标签，因此你无需担心调用函数时出现错误（参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-2188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-2189
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全函数并添加正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常使用像*to*、*from* 或 *with*这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信*to*表示送给客人*for*表示赠送礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")读起来更像一个句子，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-2191
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-2192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前添加一个下划线和一个空格来移除它们。在以下示例中，我们编写了一个用于计算体积的函数，该函数接受盒子的三条边作为输入。因为函数名已经明确说明你需要传入三条边，所以实际上并不需要参数标签来使代码更具可读性。
- en: '[PRE417]'
  id: totrans-2194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊、➋和➌的位置，在side1、side2和side3前添加下划线来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-2196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而无需任何标签。
- en: '[PRE418]'
  id: totrans-2197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。”如果你希望，不仅仅是打印出盒子的体积，而是可以将结果存储在一个变量或常量中以供以后使用，那该有多好呢？让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-2199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-2200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-2201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个不同形状的盒子，并且想知道哪个盒子能装更多的东西。首先，编写一个返回盒子体积的Int类型的volumeOfBox(_:_:_:)函数：
- en: '[PRE419]'
  id: totrans-2203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数添加返回值，可以在函数的输入参数之后使用短横线和大于号组成箭头(->)，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，你通过使用return关键字加上要返回的值来返回该值。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果你在return语句之后在函数内部写任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-2205
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-2206
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-2207
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，volumeOfBox(_:_:_:)函数计算了一个边长为6、5和3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋，边长为8、4和2的volumeOfBox2被赋值为64。现在让我们打印一条消息，看看哪个盒子更大：
- en: '[PRE420]'
  id: totrans-2209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串“Box 1 is the bigger box.”
- en: '**CONDITIONAL RETURNS**'
  id: totrans-2211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，接受一个测试成绩数组，并返回平均分。为了得到平均分，你需要将分数加起来，然后除以分数的总数。在你的 Playground
    中输入以下代码：
- en: '[PRE421]'
  id: totrans-2213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ ，我们定义了一个名为 `sum` 的 Int 变量，并将其初始化为 0 。在 ➋ 处的 for-in 循环会遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量将保存所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，即
    `scores.count` 。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空怎么办？你不能把数字除以零——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试除以零会导致除以零的错误，并使程序崩溃。因此，在做除法时，一定要确保你要除的数不是零，这也是我们在
    ➌ 处通过检查 `scores.count > 0` 来做到的。在 ➍ 处，我们通过将分数总和除以数组中的分数数量来返回平均值，使用 `return sum
    / scores.count` 。没错！你可以返回任何一个评估为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 `sum
    / scores.count` ，因为它的结果是一个 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一个值，否则会报错提示函数缺少返回值。我们通过在 if 语句中添加 else
    来处理这个问题，返回 0 ➎ 。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-2217
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给 `averageOf()` 函数时，如我们在 ➊ 所做的那样，函数会返回分数的平均值，并在结果面板中显示。如果你传入一个空数组，如我们在
    ➋ 所做的那样，返回值将是 0 。
- en: '**NOTE**'
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，包围 `return 0` 的 else 语句其实并不必要。这是因为如果 `scores.count > 0` ，那么函数已经通过 `return
    sum / scores.count` 提前结束了。所以如果计算机已经执行到那个 if 语句之外，我们就知道 `scores.count > 0` 肯定不成立，直接返回
    0 就行，而无需放在 else 中。然而，如果我们保留 else 语句，代码会更加清晰易懂。有时候，为了让别人更容易理解，写一些额外的代码比使用复杂的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-2221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，能做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建具有其他类型的常量和变量，而不仅仅是
    Swift 中已有的类型，在你创建应用程序时非常有用！
- en: '[PRE422]'
  id: totrans-2224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你写出关键字func➊，然后是函数名。创建函数时，必须给它起个名字，这样你才可以在需要时调用它来执行任务。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数的规则与命名变量的规则相同：以小写字母开头，使用驼峰命名法将每个新词的首字母大写。你还应该给函数起一个能够描述其功能的名字。你不觉得 printAHaiku()
    是一个很适合打印简单 Swift haiku 的函数名吗？
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名后面跟着一对括号➋。如果你的函数有输入参数，应该将它们放在括号内。在这个例子中，你没有任何输入参数，所以你可以把括号留空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被括号括起来。这是你编写函数代码的地方。你应该将开括号（{）写在函数名所在行，闭括号（}）单独写在函数的最后一行。在这个例子中，函数的主体包含了所有打印
    haiku 的 print 语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-2229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，你只需写出函数名，后跟括号，并在括号内传入参数。这就是*函数调用*。在这个例子中，因为 printAHaiku() 没有输入参数，所以你不需要传入任何参数——只需将括号留空即可。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用printAHaiku()，在函数的闭括号后，向你的代码 playground 中添加以下一行：
- en: '[PRE423]'
  id: totrans-2232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: 'The console output is:'
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出为：
- en: '[PRE424]'
  id: totrans-2234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数内部的代码将会执行。确保你已经打开了调试区域（⌘ -SHIFT -Y），如[图7-1](text00017.html#ch07fig1)所示，这样你就可以看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-2236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-2237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用printAHaiku()函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-2239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数做得更多**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，你已经看到函数如何帮助你节省时间和精力。当你写一个函数时，你可以在任何地方调用它，而不用在多个地方重复代码块。这无疑很酷，但函数的真正强大之处在于当你传入一个或多个输入值时，它能够产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-2241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**创建派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 invite(guest:) 的函数，它接收一个人的名字作为输入，并创建一张个性化的生日派对邀请函。将以下内容输入到你的 playground
    中：
- en: '[PRE425]'
  id: totrans-2243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
  zh: '如果一个函数有输入参数，你需要将其放在函数名后面的括号中 ➊ 。你首先写输入参数的名字（本例中为 guest ），然后是冒号（: ），最后是数据类型（此例中为
    String）。'
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也作为参数标签使用，因此 guest 会作为你调用此函数时的参数标签。（你将在 “[Argument Labels](text00017.html#ch07lev1sec4)”
    中了解如何定义单独的参数名和参数标签，参见[第 89 页](text00017.html#page_89)。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后写输入参数的数据类型，就像声明变量时一样。但是，与变量声明不同，当定义函数参数时，你必须*始终*声明函数应该期待的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-2247
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需像使用其他常量一样使用它的参数名 ➋ 。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-2249
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅定义函数是不够的。现在函数已经定义，让我们在 playground 中调用它看看会发生什么。你可以通过输入函数名，后面加上括号中的参数标签、冒号和参数，来调用带有输入参数的函数，像这样：
- en: '[PRE426]'
  id: totrans-2250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写出函数名来调用一个函数时，Xcode 的自动补全会给你一个提示，告诉你该传递什么给这个函数。在这种情况下，当你开始写 invite 时，你会看到一个下拉菜单，像[图
    7-2](text00017.html#ch07fig2)一样。
- en: '![Image](Image00155.jpg)'
  id: totrans-2252
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-2253
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动补全会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
  zh: 按 ENTER 键来自动补全函数。光标会移到函数的括号内（见[图 7-3](text00017.html#ch07fig3)），此时 Xcode 会自动添加一些占位符文本，告诉你函数期望输入什么类型的参数。
- en: '![Image](Image00156.jpg)'
  id: totrans-2255
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递的不是字符串给 invite(guest:) ，比如 invite(guest: 45) ，你会收到错误，因为该函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将“Cathy”或其他朋友的名字替换掉 String，然后按 TAB 完成函数调用的填写。它应该像[图 7-4](text00017.html#ch07fig4)一样。
- en: '![Image](Image00157.jpg)'
  id: totrans-2260
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个邀请（guest:）函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用 invite(guest:) 三次，使用你朋友的名字：
- en: '[PRE427]'
  id: totrans-2263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: 'The output looks like this:'
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE428]'
  id: totrans-2265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-2266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你能够快速打印三份派对邀请函，每份都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-2267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写一个函数，通过传入一个字符串数组作为参数，而不是单个字符串，来一次性邀请所有的朋友。在你编写 invite(guest:) 函数的同一个 playground
    中，写下以下 invite(allGuests:) 函数来进行测试。请注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-2269
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE429]'
  id: totrans-2270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到 [String] 被放在方括号中 ➊。方括号声明数据类型为数组，而 String 表示数组中值的数据类型。通过使用
    [String]，我们将此函数的输入声明为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们希望使用 for-in 循环来遍历我们的客人数组，并为每个客人打印邀请函。还记得我们之前创建了一个打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到
    invite(allGuests:) 函数中（灰色文本表示现有的代码行）：
- en: '[PRE430]'
  id: totrans-2273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们对字符串数组 allGuests 中的每个客人调用单独的 invite(guest:) 函数，邀请每个人参加生日派对。你可能会想，invite(guest:)
    和 invite(allGuests:) 是不是同一个函数。毕竟，它们的名字都叫 invite。尽管它们名字相同，但它们是两个不同的函数，因为它们接受不同的输入参数。这是你在
    Swift 中经常会看到的一个模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 invite(allGuests:) 函数，我们首先创建一个名为 friends 的数组，然后在函数调用中使用它。
- en: '[PRE431]'
  id: totrans-2276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后我们用新的数组作为函数的输入来调用该函数 ➋。这是你在调试控制台中看到的输出（-- snip -- 表示我们省略的部分代码行）：
- en: '[PRE432]'
  id: totrans-2278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为这些朋友写出每一份邀请函，那将会非常繁琐。但借助函数的强大功能，你仅用几行代码就完成了这项任务。试着创建你自己的朋友数组；长度可以随你喜好！然后用你的新数组作为输入调用
    invite(allGuests:) 函数。简直是小菜一碟！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-2280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近，但一些客人还没有RSVP。你希望获得最终的参与人数，并让客人知道带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据RSVP状态向每个客人发送定制消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-2282
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个字符串参数，用于表示客人的姓名，以及一个布尔参数，用于表示RSVP状态，值可以是true或false。请在你的 playground
    中输入以下代码：
- en: '[PRE433]'
  id: totrans-2284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊ 。每个参数需要有一个参数名称，后面跟一个冒号和该参数的数据类型。你可以创建一个接受任意数量输入参数的函数，这些参数不必是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传入一个String类型的guest和一个Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为true ➋，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最后几条print语句无论rsvped值为true还是false都会执行，因为它们在if-else语句的括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复了RSVP，他们将收到这条信息：
- en: '[PRE434]'
  id: totrans-2288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提醒，要求他们回应：
- en: '[PRE435]'
  id: totrans-2290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数来看看它是如何工作的。试着将一个客人的rsvped值设为true，另一个设为false，这样你就能看到两条信息的实际效果。
- en: '[PRE436]'
  id: totrans-2292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能将帮助你填写输入值，提供所需的参数标签。你只需要传入你想要使用的值。在填写完客人姓名后，按下TAB键，Xcode会将光标定位到你需要填写下一个输入值的地方。（参见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-2295
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按下TAB键将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你rsvped的数据类型。将占位符文本Bool替换为true或false。如果你尝试传入其他内容，比如名字或数字，你会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-2298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到在调用print(_:)时，你没有在输入值前加上参数标签吗？你写的是：
- en: '[PRE437]'
  id: totrans-2300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，你会遇到一个错误：
- en: '[PRE438]'
  id: totrans-2302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，而且它将与参数名称相同。然而，如果你编写了一个函数，觉得参数标签在使代码清晰方面不是必要的，那么你可以在函数定义中明确省略它。例如，在print(_:)函数中，很明显你传入的输入是一个将被打印的字符串。如果每次调用print(_:)都需要包括像inputString这样的参数标签，那会让人感到烦恼。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个不同于参数名称的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。所有这些操作都在你首次声明函数参数时，在
    func 关键字后的括号内进行。这通常在 Swift 函数中使用，以使函数调用看起来更像一句话。[图 7-6](text00017.html#ch07fig6)
    说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-2305
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用函数时将会是
    sayHello(friend:)，这样听起来不太像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何编写具有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-2309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，看看添加自定义参数标签如何使代码更具可读性。在你的生日派对之后，你会想给所有的客人写感谢信。在你的 Playground 中写下以下函数：
- en: '[PRE439]'
  id: totrans-2311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了一个自定义的参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名称
    guest ➌ 和 gift ➍ 用来引用函数内部的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用来在调用函数时标记参数，像这样：
- en: '[PRE440]'
  id: totrans-2314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-2315
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 在函数调用中写在第一个输入值之前，for: 则写在第二个输入值之前。如果一个参数有自定义参数标签，你必须在函数调用中使用它。试图使用参数名称而不是标签会导致错误：'
- en: '[PRE441]'
  id: totrans-2316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填写参数标签，因此你不必担心函数调用时的错误（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-2318
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-2320
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信 *to* 向客人 *for*
    礼物。代码 sendThankYou(to: "Meghan", for: "puzzle books") 比 sendThankYou(guest: "Meghan",
    gift: "puzzle books") 更像一句话。'
- en: '![Image](Image00163.jpg)'
  id: totrans-2321
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-2322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-2323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前加上一个下划线并在后面加上一个空格来移除它们。在以下示例中，我们编写了一个计算体积的函数，该函数接收一个盒子的三条边作为输入。由于函数名已经明确表明你需要传入三条边，因此你实际上不需要参数标签来使代码更具可读性。
- en: '[PRE442]'
  id: totrans-2324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-2325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处将 side1、在 ➋ 处将 side2 和在 ➌ 处将 side3 前加上下划线，来移除边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，你只需要输入参数值，而不需要任何标签。
- en: '[PRE443]'
  id: totrans-2327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "The volume of this box is 72."。如果你可以将盒子的体积结果存储到变量或常量中，以便稍后使用，而不仅仅是打印体积，这不是会更有用吗？让我们来看看如何使用返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-2329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-2331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-2332
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并想知道哪个能装更多的东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，它返回一个 Int 类型的盒子体积：
- en: '[PRE444]'
  id: totrans-2333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数一个返回值，在函数的输入参数后面添加一个短横线和一个大于号，形成一个箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，通过使用
    return 关键字后跟你想要返回的值来返回该值。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在你返回值后结束。如果你在
    return 语句之后编写任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-2335
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的盒子调用该函数，看看它的运行效果：
- en: '![](Image00165.jpg)'
  id: totrans-2337
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算了一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在，让我们打印出哪个盒子更大的信息：
- en: '[PRE445]'
  id: totrans-2339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到字符串 "Box 1 is the bigger box." 输出到调试控制台。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-2341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据条件返回不同的值。让我们编写一个函数，它接受一个成绩数组，并返回平均成绩。为了计算平均成绩，你需要将所有分数相加，然后除以总分数的数量。请在你的
    Playground 中输入以下代码：
- en: '[PRE446]'
  id: totrans-2343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-2344
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为`sum`的`Int`类型变量，并将其初始化为0。位于 ➋ 的`for-in`循环遍历`score`数组中的每个值，并将其加到`sum`变量中。当循环完成后，变量`sum`存储了所有成绩的总和。计算出总和后，剩下的就是将它除以成绩的总数，简单来说就是`score.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空怎么办？你不能将数字除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除零错误，并崩溃程序。因此，在做除法时，务必确保你将要除的数字不是零，这就是我们在
    ➌ 处检查`score.count > 0`的原因。在 ➍ 处，我们通过将`score`的总和除以数组中成绩的数量来返回平均值，使用`return sum
    / score.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回`sum
    / score.count`，因为它计算出的结果是`Int`类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-2346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`score.count`不大于零时，我们还需要返回一些内容，否则会报错提示函数缺少返回值。我们通过在`if`语句中添加`else`来处理这个问题，返回0
    ➎。你可以通过在一组成绩数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-2347
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-2348
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整组测试成绩数组传入`averageOf()`函数时，就像我们在 ➊ 处所做的那样，函数将返回成绩的平均值，并在结果面板中显示。如果传入一个空数组，就像我们在
    ➋ 处所做的那样，返回值为0。
- en: '**NOTE**'
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-2350
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕`return 0`的`else`语句其实并非绝对必要。因为如果`score.count > 0`，那么函数会在`return sum
    / score.count`时已经结束。所以如果计算机已经跳过了`if`语句，那么我们知道`score.count > 0`一定不成立，此时我们可以直接返回0，而不需要包裹在`else`中。然而，如果我们保留`else`语句，代码会更清晰，更易于理解。有时候，为了让其他人更清楚地理解代码，写多一点代码比使用复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-2351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建其他类型的常量和变量，而不仅仅是Swift中已有的类型，这在你开发应用时会非常有用！
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你写下`func`关键字 ➊，后面是函数的名称。在创建函数时，必须给它一个名称，这样你才能在需要它执行任务时调用它。
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-2355
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数的规则与命名变量的规则相同：你从小写字母开始，使用驼峰命名法大写每个新单词。你还应该给你的函数起一个描述它所做工作的名字。你不认为printAHaiku()是一个非常适合打印简单Swift俳句的函数名吗？
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名后面，有一对括号 ➋ 。如果你的函数有输入参数，你会把它们放在这些括号中。在这个例子中，你没有输入参数，所以你只需将括号留空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被括号包围。这是你编写函数代码的地方。你将左括号（{）放在与函数名相同的一行，右括号（}）放在函数末尾的单独一行。在这个例子中，函数的主体包含所有打印俳句的print语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-2358
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，你只需写出它的名字，后跟括号，其中包含任何参数。这就是*函数调用*。在这个例子中，由于printAHaiku()没有输入参数，你无需传递任何参数——只需将括号留空即可。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-2360
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用printAHaiku()，在函数的闭括号后，向你的工作区添加以下一行：
- en: '[PRE447]'
  id: totrans-2361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: 'The console output is:'
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出是：
- en: '[PRE448]'
  id: totrans-2363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数中的代码将会执行。确保你已打开调试区域（⌘ -SHIFT -Y），如[图7-1](text00017.html#ch07fig1)所示，这样你就能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-2365
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用printAHaiku()函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-2368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数在处理输入参数时还能做更多事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-2369
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，你看到了函数如何节省时间和精力。当你编写一个函数时，你可以在任何地方调用它，而不需要在许多地方重复代码块。这确实很酷，但函数的真正力量在于你传递一个或多个输入值来产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-2370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-2371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为invite(guest:)的函数，它接受一个人的名字作为输入，并创建一个个性化的生日派对邀请函。请输入以下内容到你的工作区：
- en: '[PRE449]'
  id: totrans-2372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你会将其包含在函数名后的括号中 ➊ 。你按顺序格式化输入参数，首先是它的名字（在这个例子中是guest），然后是冒号（:），最后是它的数据类型（在这个例子中是String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，所以guest在你调用这个函数时会作为参数标签。（你将会在《[Argument Labels](text00017.html#ch07lev1sec4)》中学习如何定义单独的参数名和参数标签，参见[第89页](text00017.html#page_89)
    。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后声明输入参数的数据类型，就像声明变量时一样。然而，与变量声明不同，在定义函数参数时，你必须*始终*声明函数应该期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-2376
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-2377
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，只需使用其参数名，就像使用其他常量➋一样。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数并不够。现在函数已经定义好，让我们在playground中调用它，看看会发生什么。你可以通过输入函数名，后跟括号内的参数标签、冒号和参数，来调用一个有输入参数的函数，像这样：
- en: '[PRE450]'
  id: totrans-2379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-2380
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名来调用函数时，Xcode的自动完成功能会提供有关你应该传递给函数什么内容的提示。在这种情况下，当你开始写invite时，你会看到一个下拉菜单，像[图7-2](text00017.html#ch07fig2)中那样。
- en: '![Image](Image00155.jpg)'
  id: totrans-2381
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：Xcode的自动完成功能会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
  zh: 按下ENTER键自动完成函数的输入。光标将移动到函数的括号内（参见[图7-3](text00017.html#ch07fig3)），此时Xcode已经自动添加了一些占位符文本，告诉你函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-2384
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-2385
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：Xcode正在等待你填写guest参数。*'
- en: '**NOTE**'
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递给invite(guest:)的不是字符串，例如invite(guest: 45)，会出现错误，因为函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在String的位置输入"Cathy"或另一个朋友的名字，然后按下TAB键完成函数调用。它应该像[图7-4](text00017.html#ch07fig4)一样。
- en: '![Image](Image00157.jpg)'
  id: totrans-2389
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：一个invite(guest:)函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，尝试三次调用invite(guest:)，并使用你自己朋友的名字：
- en: '[PRE451]'
  id: totrans-2392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: 'The output looks like this:'
  id: totrans-2393
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下所示：
- en: '[PRE452]'
  id: totrans-2394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-2395
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你可以快速打印三张派对邀请函，每一张都发给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-2396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过传递一个字符串数组作为参数，而不是单个字符串，编写一个一次邀请所有朋友的函数。在你写了invite(guest:)的同一个playground中，写下以下invite(allGuests:)函数来进行测试。注意，参数名现在是复数形式，因为我们要一次邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-2398
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE453]'
  id: totrans-2399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被括在方括号中➊。方括号声明数据类型为数组，而String表示数组中值的数据类型。通过使用[String]，我们将这个函数的输入声明为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `invite(allGuests:)` 函数内部，我们希望使用 `for-in` 循环遍历我们的客人数组，并为每个客人打印邀请函。还记得我们刚才创建的打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到你的
    `invite(allGuests:)` 函数中（灰色文本显示了现有的行）：
- en: '[PRE454]'
  id: totrans-2402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `for-in` 循环中，我们对 `String` 数组 `allGuests` 中的每个客人调用单独的 `invite(guest:)` 函数，邀请每个人参加生日派对。你可能会想知道
    `invite(guest:)` 和 `invite(allGuests:)` 是不是同一个函数。毕竟，它们的名字都是 `invite`。然而，尽管名字相同，它们是两个不同的函数，因为它们接受不同的输入参数。这是你在
    Swift 中经常会看到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-2404
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `invite(allGuests:)` 函数，我们首先创建一个名为 `friends` 的数组，然后将这个数组作为函数的输入来调用。
- en: '[PRE455]'
  id: totrans-2405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-2406
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后我们将我们的新数组作为函数的输入来调用函数 ➋。这是你将在调试控制台看到的输出（`-- snip --`
    表示我们省略了一些行以节省空间）：
- en: '[PRE456]'
  id: totrans-2407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友单独写邀请函，那会非常麻烦。但有了函数的强大功能，你只需要极少的代码行就能完成这项工作。试着创建你自己的朋友数组，长度可以随你喜欢！然后用你新的数组作为输入，调用
    `invite(allGuests:)` 函数。简直轻而易举！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-2409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-2410
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期快到了，但一些客人还没有回复是否参加。你想要获取最终的参与人数，并提醒客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据客人的回复状态发送自定义消息给每个客人。
- en: '![Image](Image00159.jpg)'
  id: totrans-2411
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-2412
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个 `String` 类型的参数用于表示客人的名字，另一个 `Bool` 类型的参数用于表示RSVP状态，它的值可以是
    true 或 false。将以下代码输入到你的 playground 中：
- en: '[PRE457]'
  id: totrans-2413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-2414
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数需要有一个参数名，后跟冒号和该参数的数据类型。你可以创建一个接受任意数量输入参数的函数，而且它们不需要是相同的类型。在
    `sendMessage(guest:rsvped:)` 函数中，我们传入了一个 `String` 类型的 `guest` 和一个 `Bool` 类型的 `rsvped`。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查`rsvped`值是否为真 ➋，然后使用 if-else 语句打印相应的消息。请注意，函数定义中的最终 print 语句无论 `rsvped`
    值为真还是假都会执行，因为它们在 if-else 语句的大括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-2416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复了，他们会收到以下消息：
- en: '[PRE458]'
  id: totrans-2417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-2418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有回复，他们会收到一封礼貌的提示，要求他们回应：
- en: '[PRE459]'
  id: totrans-2419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。试着将一位客人的 rsvped 值设置为 true，另一位客人的设置为 false，这样你就可以看到两个消息的效果。
- en: '[PRE460]'
  id: totrans-2421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-2422
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-2423
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会通过为你提供参数标签来帮助你填写输入值。你只需要传入你想要使用的值即可。在填写完客人姓名后，按下 TAB 键，Xcode 会将光标移到下一个需要填写输入值的位置。（参见
    [图 7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-2424
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-2425
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按 TAB 键将把光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他任何东西，比如姓名或数字，你将得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-2427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-2428
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，当你调用 `print(_:)` 时，你没有在输入值前面加上参数标签？你写的是：
- en: '[PRE461]'
  id: totrans-2429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你将得到一个错误：
- en: '[PRE462]'
  id: totrans-2431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-2432
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，且标签与参数名称相同。然而，如果你编写了一个函数，觉得参数标签对代码的清晰度没有必要，那么你可以在函数定义中明确地省略它。例如，在
    `print(_:)` 函数中，显然你传入的是一个将被打印的字符串。如果每次调用 `print(_:)` 时都要加上像 `inputString` 这样的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-2433
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现这一点。这一切都在你第一次声明函数参数时完成，位于
    `func` 关键字后面的函数括号内。这在 Swift 函数中经常使用，目的是让函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6)
    说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-2434
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-2435
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：`sayHello()` 函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-2436
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 `friend`，参数标签是 `to`，并且函数调用中传入的参数是 "Colin"。如果你没有单独的参数标签，那么调用该函数时，它将看起来像
    `sayHello(friend:)`，这听起来不像一个完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-2437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写带有自定义参数标签的函数。我们还会展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-2438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-2439
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，说明添加自定义参数标签如何使你的代码更具可读性。你的生日派对后，你可能会想给所有客人发送感谢信。在你的 playground 中写下以下函数：
- en: '[PRE463]'
  id: totrans-2440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了一个自定义参数标签 *to*。类似地，在 ➋ 处，我们为 gift 参数添加了一个参数标签 *for*。参数名称
    guest ➌ 和 gift ➍ 用于引用函数内部的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-2442
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 *to* 和 *for* 被用来标注函数调用时的参数，如下所示：
- en: '[PRE464]'
  id: totrans-2443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-2444
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 被写在函数调用的第一个输入值之前，for: 被写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。如果尝试使用参数名称代替它，会引发错误：'
- en: '[PRE465]'
  id: totrans-2445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-2446
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会自动为你填写参数标签，所以你不必担心错误地调用函数（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-2447
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-2448
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成函数并正确填写参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-2449
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用来向客人发送感谢信 *to* 表示给谁 *for*
    表示因为什么礼物。代码 sendThankYou(to: "Meghan", for: "puzzle books") 读起来更像一句话，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-2450
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-2451
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线和一个空格来移除它们。在以下示例中，我们编写了一个计算体积的函数，该函数接受一个盒子的三条边作为输入。因为函数名已经清楚地表明你需要传入三条边，所以你实际上不需要参数标签来增加代码的可读性。
- en: '[PRE466]'
  id: totrans-2453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处的 side1 前加下划线，在 ➋ 处的 side2 前加下划线，以及在 ➌ 处的 side3 前加下划线，来移除 sides 的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需要输入参数值而无需任何标签。
- en: '[PRE467]'
  id: totrans-2456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是 72。”如果你能把体积存储到变量或常量中，而不是简单地打印出来，而后可以在其他地方使用，这不是更有用吗？让我们来看看如何通过返回值来实现！
- en: '**RETURN VALUES**'
  id: totrans-2458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-2460
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-2461
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个可以装更多的东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，返回一个 Int 类型的盒子体积：
- en: '[PRE468]'
  id: totrans-2462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-2463
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数返回值，在函数输入参数后使用一个短横线和大于号（->）来形成箭头 ➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，使用
    return 关键字后跟要返回的值来返回该值 ➋。如果你编写了一个返回值的函数，那么你*必须*在函数内返回该值，否则会出现错误。函数在你返回值后结束。如果在
    return 语句后再写任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-2464
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-2466
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算了一个边长分别为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条消息，说明哪个盒子更大：
- en: '[PRE469]'
  id: totrans-2468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-2470
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们写一个函数，它接收一个测试成绩数组并返回平均分。为了得到平均分，你需要将所有成绩加在一起，然后除以成绩的总数。请输入以下代码到你的
    playground 中：
- en: '[PRE470]'
  id: totrans-2472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-2473
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始化为 0。位于 ➋ 的 for-in 循环会遍历成绩数组中的每个值，并将其添加到
    sum 变量中。当循环完成时，变量 sum 保存了所有成绩的总和。在我们计算出总和后，剩下的就是将其除以成绩的总数，这个数量就是 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
  zh: 可是如果数组为空呢？你不能将某个数除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并使程序崩溃。因此，在做除法时，一定要确保你要除的数不是零，这就是我们通过检查
    scores.count > 0 在 ➌ 做的事情。在 ➍ 处，我们通过将成绩的总和除以数组中成绩的数量来返回平均值，使用 return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回
    sum / scores.count 因为它会被计算为一个 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们也需要返回某个值，否则会出现函数缺少返回值的错误。我们通过在 if 语句后添加 else 来处理这个问题，返回
    0 ➎。你可以通过对一个成绩数组和一个空数组调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-2476
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像在➊处那样，将一个完整的测试成绩数组传递给averageOf()函数时，返回的将是成绩的平均值，并显示在结果面板中。如果你传入一个空数组，如➋所示，返回值就是0。
- en: '**NOTE**'
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这个例子中，围绕return 0的else语句其实并不是必需的。因为如果scores.count > 0，那么函数会已经通过return sum
    / scores.count结束了。所以如果计算机已经跳过了那个if语句，那么我们可以知道scores.count > 0一定不为真，我们可以直接使用return
    0，而不需要把它包裹在else语句中。然而，如果我们保留else语句，代码会更加清晰，易于理解。有时候，写一点额外的代码比使用一个复杂的快捷方式更能让别人理解代码。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-2480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚给你的Swift工具包添加了一个重要工具——创建并调用你自己的函数！函数在编程中被广泛使用，用来做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-2482
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建具有除Swift中已有类型之外的其他类型的常量和变量，这在你创建应用时会非常有用！
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  id: totrans-2483
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数的规则与命名变量相同：以小写字母开头，每个新单词使用驼峰命名法进行大写。你还应该给函数起一个描述其功能的名字。你不觉得printAHaiku()是一个非常适合打印简单Swift俳句的函数名吗？
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名后面有一对括号➋。如果你的函数有输入参数，你需要将它们放在这些括号内。在这个例子中，你没有输入参数，所以只需保持括号为空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被括号包围。这是你编写函数代码的地方。你将开括号（{）和函数名放在同一行，闭括号（}）放在函数的最后一行。在这个例子中，函数的主体包含了所有打印俳句的print语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-2486
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，你只需要写出它的名称，后跟括号，括号内包含任何参数。这就是*函数调用*。在这个例子中，因为printAHaiku()没有输入参数，所以你不需要传入任何参数——只需保持括号为空即可。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用printAHaiku()，在函数的闭括号后面，在你的playground中添加以下这一行代码：
- en: '[PRE471]'
  id: totrans-2489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: 'The console output is:'
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出是：
- en: '[PRE472]'
  id: totrans-2491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数内部的代码将会运行。确保你打开了调试区域（⌘ -SHIFT -Y），就像在[图7-1](text00017.html#ch07fig1)中一样，这样你就能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-2493
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-2494
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用printAHaiku()函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-2496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数做更多的事**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-2497
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，你看到了函数如何为你节省时间和精力。当你编写一个函数时，你可以在任何你想要的地方调用它，而不必在许多地方重复代码块。这肯定很酷，但函数的真正威力在于你传入一个或多个输入值，以产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-2498
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为invite(guest:)的函数，该函数接受一个人的名字作为输入，并创建一个个性化的生日派对邀请函。将以下内容输入到你的游乐场中：
- en: '[PRE473]'
  id: totrans-2500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将其包含在函数名后的括号内 ➊。你格式化一个输入参数时，首先写它的名字（在这个例子中是guest），然后是冒号（:），最后是它的数据类型（此例为String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-2502
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，因此在调用此函数时，guest将作为参数标签。（你将在“[参数标签](text00017.html#ch07lev1sec4)”中学习如何定义单独的参数名和参数标签，见[第
    89 页](text00017.html#page_89)。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-2503
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后写输入参数的数据类型，就像声明变量时一样。不过，与变量声明不同，在定义函数参数时，你必须*始终*声明函数期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-2504
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需像使用任何其他常量一样使用它的参数名 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数并不够。现在函数已经定义好，让我们在游乐场中调用它，看看会发生什么。你可以通过输入函数名，后跟括号中的参数标签、冒号和参数，来调用带有输入参数的函数，像这样：
- en: '[PRE474]'
  id: totrans-2507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-2508
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过编写函数名来调用一个函数时，Xcode的自动完成会给你一些提示，告诉你应该传递什么类型的输入给函数。在这种情况下，当你开始写invite时，你会看到一个下拉菜单，如[图
    7-2](text00017.html#ch07fig2)所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-2509
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成将显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-2511
  prefs: []
  type: TYPE_NORMAL
  zh: 按ENTER键自动完成函数。你的光标将移到函数的括号内（见[图 7-3](text00017.html#ch07fig3)），此时Xcode已经自动添加了一些占位符文本，告诉你函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-2512
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-2513
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-2514
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-2515
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递一个不是字符串的东西给invite(guest:)，例如invite(guest: 45)，你会得到一个错误，因为该函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-2516
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将"Cathy"或另一个朋友的名字替换掉String，然后按TAB键完成函数调用。它应该像[图 7-4](text00017.html#ch07fig4)那样显示。
- en: '![Image](Image00157.jpg)'
  id: totrans-2517
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-2518
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4: 一个`invite(guest:)`函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-2519
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用`invite(guest:)`函数三次，使用你自己朋友的名字：
- en: '[PRE475]'
  id: totrans-2520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: 'The output looks like this:'
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE476]'
  id: totrans-2522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-2523
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`invite(guest:)`函数，你可以快速打印出三份不同的派对邀请函，每一份都写给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-2524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以写一个一次性邀请所有朋友的函数，方法是传入一个字符串数组作为参数，而不是单个字符串。在你写了`invite(guest:)`函数的同一个 playground
    中，写下以下`invite(allGuests:)`函数进行测试。注意，参数名称现在是复数形式，因为我们将一次邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-2526
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE477]'
  id: totrans-2527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-2528
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到`[String]`在方括号中 ➊ 。方括号表示数据类型是一个数组，而`String`则表示数组中值的数据类型。通过使用`[String]`，我们声明了这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
  zh: 在`invite(allGuests:)`函数内部，我们需要使用`for-in`循环遍历我们的客人数组，并为每个客人打印一份邀请函。还记得我们刚刚创建了一个打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到你的`invite(allGuests:)`函数中（灰色文本显示的是现有的代码行）：
- en: '[PRE478]'
  id: totrans-2530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-2531
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`for-in`循环中，我们对`String`数组`allGuests`中的每个客人调用单一的`invite(guest:)`函数，邀请每个人参加生日派对。你可能会想，`invite(guest:)`和`invite(allGuests:)`是同一个函数吗？毕竟，它们的名称都是`invite`。然而，尽管名字相同，它们是两个不同的函数，因为它们接受不同的输入参数。这是你在
    Swift 中常见的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-2532
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`invite(allGuests:)`函数，我们首先创建一个名为`friends`的数组，然后在函数调用中使用它。
- en: '[PRE479]'
  id: totrans-2533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-2534
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个包含六个朋友的数组 ➊ 。然后，我们用新的数组作为函数的输入来调用函数 ➋ 。这是你将在调试控制台中看到的输出（`-- snip --`表示我们为了节省空间省略的代码行）：
- en: '[PRE480]'
  id: totrans-2535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-2536
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不得不为每个朋友写出邀请函，那将会非常麻烦。但借助函数的力量，你仅用少量的代码行就完成了这一任务。尝试创建你自己的朋友数组，长度随你意！然后用新的数组作为输入调用`invite(allGuests:)`函数，简直是小菜一碟！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-2537
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-2538
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期即将到来，但有些客人还没有回复是否参加。你想要确定最终的人数，并告诉客人们带上泳衣，因为这将是一个滑水道派对。你可以写一个函数，根据客人的RSVP状态给每位客人发送自定义信息。
- en: '![Image](Image00159.jpg)'
  id: totrans-2539
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个String类型的参数表示客人的名字和一个Bool类型的参数表示RSVP状态，其值为true或false。在你的playground中输入以下代码：
- en: '[PRE481]'
  id: totrans-2541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-2542
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，在每个参数之间加上逗号 ➊。每个参数需要有一个参数名称，后跟冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，且这些参数不必是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传入一个String类型的guest和一个Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-2543
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为真 ➋，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最终打印语句无论rsvped值为真或为假都会执行，因为它们在if-else语句的括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-2544
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经RSVP，他们将收到此消息：
- en: '[PRE482]'
  id: totrans-2545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-2546
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提示，要求他们进行回应：
- en: '[PRE483]'
  id: totrans-2547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-2548
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一个客人的rsvped值设置为true，另一个设置为false，这样你就可以看到两个消息的效果。
- en: '[PRE484]'
  id: totrans-2549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-2550
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-2551
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能将帮助你填写输入值，并为你提供参数标签。你所需要做的就是传入你想使用的值。填写完客人姓名后，按TAB键，Xcode会将光标定位到你需要填写下一个输入值的位置。（参见[图7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-2552
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-2553
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：在输入客人姓名后按TAB键会将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-2554
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你rsvped的数据类型。将占位符文本Bool替换为true或false。如果你试图传入其他任何内容，如名字或数字，你将收到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-2555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-2556
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，当你调用print(_:)时，输入值前面没有参数标签？你写的是：
- en: '[PRE485]'
  id: totrans-2557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-2558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图包括一个标签，你将收到错误：
- en: '[PRE486]'
  id: totrans-2559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-2560
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而一些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，且标签名与参数名相同。然而，如果你编写函数时，觉得参数标签对于使代码更清晰并非必要，你可以在函数定义中明确省略它。例如，在print(_:)函数中，很明显你传入的输入是一个将被打印的字符串。每次调用print(_:)时都必须包括像inputString这样的参数标签会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，然后是参数的数据类型来做到这一点。这一切都会在你第一次声明函数括号内的参数时完成，这通常是在
    func 关键字后面。在 Swift 函数中，这样做是为了让函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-2562
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-2564
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，当你调用函数时，它将看起来像
    sayHello(friend:)，这听起来不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-2565
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何编写具有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-2566
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示如何通过添加自定义参数标签来使你的代码更具可读性。在你的生日派对后，你可能想要给所有的客人发送感谢信。请在你的 playground
    中编写以下函数：
- en: '[PRE487]'
  id: totrans-2568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-2569
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们给传入函数的 guest 参数添加了一个自定义的参数标签 to。同样，在 ➋ 处，我们给 gift 参数添加了一个参数标签 for。参数名称
    guest ➌ 和 gift ➍ 用来引用函数内部的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，像这样：
- en: '[PRE488]'
  id: totrans-2571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 被写在第一个输入值之前，for: 被写在第二个输入值之前。如果一个参数有自定义的参数标签，那么在函数调用时你必须使用它。尝试使用参数名称代替会导致错误：'
- en: '[PRE489]'
  id: totrans-2573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-2574
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会为你自动填充参数标签，所以你无需担心函数调用出错（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-2575
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成一个带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于发送感谢信 *给* 客人 *因* 收到礼物。代码
    sendThankYou(to: "Meghan", for: "puzzle books") 比 sendThankYou(guest: "Meghan",
    gift: "puzzle books") 更像一个句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-2578
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-2579
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-2580
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加下划线和空格来移除它们。在以下示例中，我们编写了一个计算体积的函数，接受盒子的三条边作为输入。因为函数名称已经明确表示需要传入三条边，因此实际上不需要参数标签来提高代码的可读性。
- en: '[PRE490]'
  id: totrans-2581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-2582
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在第➊位将`side1`前加下划线，在第➋位将`side2`前加下划线，在第➌位将`side3`前加下划线，从而移除了这些边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-2583
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而无需标签。
- en: '[PRE491]'
  id: totrans-2584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-2585
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出 "这个盒子的体积是72。" 如果你能将结果存储到变量或常量中，以便稍后使用，而不仅仅是打印体积，这不是更有用吗？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-2586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-2587
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着改写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-2588
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-2589
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想要知道哪个能装更多的东西。首先，编写一个返回盒子体积的`volumeOfBox(_:_:_:)`函数，返回值为整数（Int）：
- en: '[PRE492]'
  id: totrans-2590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
  zh: 要为一个函数添加返回值，请在函数的输入参数后面使用破折号和大于号（->）形成箭头，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，使用`return`关键字后跟要返回的值来返回结果。请注意，如果你编写一个返回值的函数，那么你*必须*在函数内返回该值，否则会报错。函数在你返回值后结束。如果在`return`语句后写入任何代码，它将被忽略，因为`return`会使函数退出。
- en: '![Image](Image00164.jpg)'
  id: totrans-2592
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它如何工作：
- en: '![](Image00165.jpg)'
  id: totrans-2594
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-2595
  prefs: []
  type: TYPE_NORMAL
  zh: 在第➊位，`volumeOfBox(_:_:_:)`函数计算一个边长分别为6、5和3的盒子的体积，返回值90被存储在一个名为`volumeOfBox1`的常量中。在第➋位，边长为8、4和2的`volumeOfBox2`被赋值为64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE493]'
  id: totrans-2596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-2597
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-2598
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据条件返回不同的值。让我们编写一个函数，接受一个测试分数的数组并返回平均分。为了计算平均分，你需要将分数相加，然后除以分数的总数。请在你的 playground
    中输入以下代码：
- en: '[PRE494]'
  id: totrans-2600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-2601
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始化为 0。➋ 处的 `for-in` 循环遍历成绩数组中的每个值，并将其加到
    `sum` 变量中。当循环完成时，`sum` 变量就包含了所有成绩的总和。计算出总和后，剩下的就是将它除以成绩的总数，即 `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-2602
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能把东西除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误，并且崩溃你的程序。因此，在进行除法运算时，一定要确保你要除的数字不是零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来做的。然后，在 ➍ 处，我们通过用 `return sum / scores.count` 将总成绩除以数组中的成绩数量来返回平均值。没错！你可以返回任何能计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回
    `sum / scores.count`，因为它会计算出一个 `Int` 类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-2603
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回某个值，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加一个 else
    来处理这一点，它返回 0 ➎。你可以通过对一个成绩数组和一个空数组调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-2604
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-2605
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像在 ➊ 处那样将一个完整的测试成绩数组传递给 `averageOf()` 函数时，返回的是成绩的平均值，并显示在结果面板中。如果你传入一个空数组，如
    ➋ 处所示，返回值将是 0。
- en: '**NOTE**'
  id: totrans-2606
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-2607
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕返回 0 的 else 语句实际上不是必需的。这是因为如果 `scores.count > 0`，函数已经通过 `return sum
    / scores.count` 结束了。所以如果程序已经通过了那个 if 语句，我们知道 `scores.count > 0` 必定不为真，我们可以直接写一个
    `return 0`，而不需要将它包含在 else 中。然而，如果我们保留 else 语句，代码会更清晰、更容易理解。有时候，为了让别人更容易理解，写一些额外的代码比使用复杂的捷径更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-2608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-2609
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以完成各种惊人的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-2610
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建类型不同于 Swift
    中已有类型的常量和变量，这在你创建应用时非常有用！
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  id: totrans-2611
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名称后面，有一对括号 ➋。如果你的函数有输入参数，你应该将它们放在这些括号内。在这个例子中，你没有输入参数，因此只需将括号留空。
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-2612
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被大括号括起来。这是你编写函数代码的地方。你将左大括号（{）放在与函数名称同一行，右大括号（}）则放在函数结束时的单独一行。在这个例子中，函数的主体包含所有打印出俳句的
    print 语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-2613
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-2614
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，你只需要写下它的名称，后面跟上括号，括号内可以传入任何参数。这就是一个*函数调用*。在这个例子中，由于 printAHaiku() 没有输入参数，你不需要传入任何参数——只需要将括号留空。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-2615
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 printAHaiku()，请在函数的右大括号后面添加以下行：
- en: '[PRE495]'
  id: totrans-2616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: 'The console output is:'
  id: totrans-2617
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出是：
- en: '[PRE496]'
  id: totrans-2618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-2619
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数内的代码将运行。确保你打开了调试区域（⌘ -SHIFT -Y），如 [图 7-1](text00017.html#ch07fig1)
    所示，这样你就能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-2620
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-2621
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
  zh: 试着多次调用 printAHaiku() 函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-2623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数做得更多**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，你看到了函数如何节省时间和精力。当你编写一个函数时，你可以在任何地方调用它，而不必在多个地方重复一段代码。这当然很酷，但函数的真正强大之处在于你可以传入一个或多个输入值，从而产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-2625
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-2626
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 invite(guest:) 的函数，它接受一个人的名字作为输入，并创建一张个性化的生日派对邀请函。请在你的 playground
    中输入以下内容：
- en: '[PRE497]'
  id: totrans-2627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-2628
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将它放在函数名后面的括号中 ➊。你格式化输入参数时，先写上它的名称（在这个例子中是 guest），然后是一个冒号（:），最后是它的数据类型（在本例中是
    String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-2629
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名称也充当参数标签，因此在调用此函数时，guest 将是参数标签。（你将在 “[参数标签](text00017.html#ch07lev1sec4)”
    的 [第 89 页](text00017.html#page_89) 学到如何定义独立的参数名称和参数标签。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-2630
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后面写下输入参数的数据类型，就像声明变量时一样。然而，与变量声明不同，定义函数参数时，你必须*始终*声明该函数应该预期的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-2631
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-2632
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需要像使用其他常量一样使用它的参数名称 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-2633
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅定义一个函数是不够的。现在函数已经定义好了，让我们在 playground 中调用它，看看会发生什么。你可以通过输入函数名，后面跟上括号中的参数标签、冒号和参数来调用一个带有输入参数的函数，像这样：
- en: '[PRE498]'
  id: totrans-2634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-2635
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过输入函数名来调用函数时，Xcode 的自动补全会给你提示，告诉你应该传递什么参数给函数。在这种情况下，当你开始输入`invite`时，你会看到一个下拉菜单，如[图
    7-2](text00017.html#ch07fig2)所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-2636
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-2637
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动补全会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-2638
  prefs: []
  type: TYPE_NORMAL
  zh: 按 ENTER 键自动补全函数。你的光标将移动到函数的括号内（参见[图 7-3](text00017.html#ch07fig3)），此时 Xcode
    已经自动添加了一些占位符文本，告诉你函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-2639
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-2640
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-2641
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-2642
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递了一个非字符串的参数给`invite(guest:)`函数，例如`invite(guest: 45)`，你会收到一个错误，因为该函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-2643
  prefs: []
  type: TYPE_NORMAL
  zh: 只需输入“Cathy”或其他朋友的名字来替换`String`，然后按 TAB 键完成函数调用的填写。它应该像[图 7-4](text00017.html#ch07fig4)所示。
- en: '![Image](Image00157.jpg)'
  id: totrans-2644
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：`invite(guest:)`函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-2646
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用`invite(guest:)`三次，使用你自己朋友的名字：
- en: '[PRE499]'
  id: totrans-2647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: 'The output looks like this:'
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下所示：
- en: '[PRE500]'
  id: totrans-2649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的`invite(guest:)`函数，你可以快速打印出三张派对邀请函，每一张邀请函都发给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-2651
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-2652
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写一个函数，通过传入一个字符串数组作为参数，而不是单一字符串，来一次性邀请所有朋友。在你编写了`invite(guest:)`函数的同一个 playground
    中，编写以下的`invite(allGuests:)`函数来进行测试。注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-2653
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE501]'
  id: totrans-2654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-2655
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到`[String]`被放在方括号中 ➊。方括号声明了数据类型是一个数组，而`String`表示数组中值的数据类型。通过使用`[String]`，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-2656
  prefs: []
  type: TYPE_NORMAL
  zh: 在`invite(allGuests:)`函数内部，我们需要使用一个`for-in`循环来遍历我们的客人数组，并为每个客人打印一张邀请函。还记得我们刚才创建的那个打印邀请函的函数吗？我们可以在这里使用它！在你的`invite(allGuests:)`函数中添加以下内容（灰色文本表示已有的代码）：
- en: '[PRE502]'
  id: totrans-2657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个guest调用单一的invite(guest:)函数，邀请每个朋友参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是不是同一个函数。毕竟，它们都叫做invite。不过，尽管它们有相同的名字，但它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中会经常看到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-2659
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE503]'
  id: totrans-2660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-2661
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后，我们用新的数组作为函数的输入调用函数 ➋ 。这是你在调试控制台中看到的输出（-- snip --表示我们省略的部分，以节省空间）：
- en: '[PRE504]'
  id: totrans-2662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为每位朋友写邀请函，那将是非常繁琐的工作。但通过函数的强大功能，你只用了很少几行代码就完成了。试着创建你自己的朋友数组；可以根据需要扩展它的长度！然后，使用新的数组作为输入调用invite(allGuests:)函数。简直轻松至极！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-2664
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-2665
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期越来越近，而一些客人还没有RSVP。你想要最终确认人数，并通知客人们带上泳衣，因为这将是一个滑水派对。你可以写一个函数，根据每个客人的RSVP状态发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-2666
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个String类型的参数表示客人的名字，另一个Bool类型的参数表示RSVP状态，它的值可以是true或者false。请输入以下代码到你的Playground中：
- en: '[PRE505]'
  id: totrans-2668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-2669
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加一个逗号 ➊ 。每个参数都需要有一个参数名，后面跟上冒号和该参数的数据类型。你可以创建一个接受任意数量输入参数的函数，且这些参数类型可以不同。在sendMessage(guest:rsvped:)函数中，我们传入了一个String类型的guest和一个Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-2670
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为真 ➋ ，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最后打印语句无论rsvped值是true还是false都会执行，因为它们位于if-else语句的大括号外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-2671
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经RSVP，他们会收到以下消息：
- en: '[PRE506]'
  id: totrans-2672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-2673
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一张礼貌的便条，提醒他们需要回应：
- en: '[PRE507]'
  id: totrans-2674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-2675
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一个客人的rsvped值设置为true，另一个客人的rsvped值设置为false，这样你就能看到两个消息的实际效果。
- en: '[PRE508]'
  id: totrans-2676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-2677
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调用一个有多个输入参数的函数，和调用一个只有一个输入参数的函数非常相似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-2678
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会通过为你提供参数标签来帮助你填写输入值。你只需传入你想使用的值即可。填写完宾客姓名后，按 TAB 键，Xcode 会将光标移到下一个输入值的填写位置。（见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-2679
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-2680
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入完宾客姓名后按 TAB 键将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-2681
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他类型的值，比如姓名或数字，会出现错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-2682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-2683
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，在调用 print(_:) 时，你没有在输入值前面加上参数标签？你只需要写：
- en: '[PRE509]'
  id: totrans-2684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-2685
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加标签，会遇到错误：
- en: '[PRE510]'
  id: totrans-2686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-2687
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中需要参数标签，而有些则不需要。默认情况下，当你编写函数时，每个参数都会有一个参数标签，且该标签与参数名称相同。然而，如果你编写的函数觉得参数标签并不是必需的来使代码更清晰，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，传入的输入值显然是一个将被打印的字符串。如果每次调用 print(_:) 时都必须包含像 inputString 这样的参数标签，那会非常烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-2688
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号以及参数的数据类型来实现。所有这些操作都在你首次声明函数参数时完成，位于
    func 关键字后面的函数圆括号内。这在 Swift 函数中很常见，目的是让函数调用看起来更像一个完整的句子。[图 7-6](text00017.html#ch07fig6)
    展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-2689
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-2691
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用该函数时看起来会像
    sayHello(friend:)，听起来不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写带有自定义参数标签的函数。我们还将展示如何编写一个省略所有参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-2693
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-2694
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，展示如何通过添加自定义参数标签使你的代码更具可读性。生日派对结束后，你会想给所有宾客发送感谢信。在你的 Playground 中编写以下函数：
- en: '[PRE511]'
  id: totrans-2695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-2696
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了一个自定义参数标签 `to`。类似地，在 ➋ 处，我们为 gift 参数添加了一个参数标签 `for`。参数名
    guest ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 `to` 和 `for` 用于在调用函数时标记这些参数，像这样：
- en: '[PRE512]'
  id: totrans-2698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-2699
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `to:` 写在函数调用中的第一个输入值前，`for:` 写在第二个输入值前。如果某个参数有自定义的参数标签，你在调用函数时必须使用它。如果你尝试使用参数名而不是标签，会导致错误：
- en: '[PRE513]'
  id: totrans-2700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-2701
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填写参数标签，因此你无需担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-2702
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-2703
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7: Xcode 自动完成函数并带有正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向来宾发送感谢信 *to* 来宾 *for*
    礼物。代码 sendThankYou(to: "Meghan", for: "puzzle books") 读起来更像一个句子，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-2705
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-2706
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-2707
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前加上下划线和空格来移除它们。在下面的示例中，我们编写了一个计算体积的函数，接收箱子的三个边作为输入。因为函数名已经明确表示你需要传入三个边，所以实际上并不需要参数标签来增加代码的可读性。
- en: '[PRE514]'
  id: totrans-2708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处为 side1、在 ➋ 处为 side2、在 ➌ 处为 side3 前面加上下划线，来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-2710
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需要输入参数值，而不需要任何标签。
- en: '[PRE515]'
  id: totrans-2711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-2712
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将输出 "The volume of this box is 72."。如果你不仅仅是打印箱子的体积，而是将结果存储在变量或常量中以后使用，这不是更有用吗？让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-2713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-2714
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，将其改为返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-2715
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的箱子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的箱子，想知道哪个能装更多的东西。首先，写一个 volumeOfBox(_:_:_:) 函数，该函数返回一个 Int 类型的箱子体积：
- en: '[PRE516]'
  id: totrans-2717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-2718
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数一个返回值，在函数的输入参数后使用一个破折号和一个大于号来形成箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值提供名字，只需要数据类型即可。在函数体内，使用return关键字返回你想返回的值➋。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值后结束。如果你在return语句后写了任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-2719
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-2720
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它如何工作：
- en: '![](Image00165.jpg)'
  id: totrans-2721
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-2722
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算一个长宽高分别为6、5和3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋处，边长分别为8、4和2的volumeOfBox2被赋值为64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE517]'
  id: totrans-2723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-2724
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串“Box 1 is the bigger box.”。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-2725
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-2726
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接受一个测试分数数组，并返回平均分数。为了获得平均分，你将分数相加，然后除以分数的总数。请在你的Playground中输入以下代码：
- en: '[PRE518]'
  id: totrans-2727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-2728
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在➊处，我们定义了一个名为sum的Int类型变量，并将其初始值设为0。➋处的for-in循环遍历scores数组中的每个值，并将其加到sum变量中。当循环完成时，变量sum保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数量，简单来说就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-2729
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空呢？你不能除以零——在数学课上或是在Swift中都不行。在Swift中，试图除以零会导致除以零的错误，并且会崩溃程序。因此，在进行除法运算时，务必确保除数不为零，这正是我们在➌处通过检查scores.count
    > 0来实现的。到达➍时，我们通过将所有分数的总和除以数组中分数的数量来返回平均值，使用的是return sum / scores.count。没错！你可以返回任何能计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回sum
    / scores.count，因为它的结果是Int类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们也需要返回一个值，否则会报错提示函数缺少返回值。我们通过在if语句后添加一个else来处理这个问题，返回值为0➎。你可以通过在一个包含分数的数组和一个空数组上调用该函数来测试这段代码：
- en: '![](Image00166.jpg)'
  id: totrans-2731
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给 averageOf() 函数时，正如我们在 ➊ 处所做的，返回的是成绩的平均值，并显示在结果面板中。如果你传递一个空数组，如我们在
    ➋ 处所做的，那么返回值就是 0。
- en: '**NOTE**'
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不必要。因为如果 scores.count > 0 ，那么函数已经通过 return
    sum / scores.count 结束了。所以，如果计算机已经跳过了那个 if 语句，我们就知道 scores.count > 0 一定不为真，我们完全可以直接写一个
    return 0，而不需要放在 else 里。然而，如果我们保留 else 语句，代码会更加清晰和易于理解。有时候，写一些额外的代码让其他人更容易理解，比起使用巧妙的捷径要更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-2735
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-2737
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建除 Swift 已包含类型之外的常量和变量，这在你开发应用时会派上用场！
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  id: totrans-2738
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*被大括号包围。这是你编写函数代码的地方。你将左大括号 ({ ) 与函数名放在同一行，右大括号 (} ) 放在函数的最后一行。这个例子中，函数的主体包含了所有打印
    haiku 的 print 语句。
- en: '![Image](Image00152.jpg)'
  id: totrans-2739
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-2740
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数时，只需写出函数的名称，后跟括号，括号内可以包含任何参数。这就是*函数调用*。在这种情况下，由于 printAHaiku() 没有输入参数，所以你不需要传入任何参数——只需留空括号。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-2741
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 printAHaiku()，在函数的右大括号后，在你的 playground 中添加以下一行：
- en: '[PRE519]'
  id: totrans-2742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: 'The console output is:'
  id: totrans-2743
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出是：
- en: '[PRE520]'
  id: totrans-2744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-2745
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数中的代码就会执行。确保你打开了调试区域（⌘ -SHIFT -Y），就像在[图 7-1](text00017.html#ch07fig1)中一样，这样你就能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-2746
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-2747
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-2748
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用 printAHaiku() 函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-2749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数做得更多**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-2750
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，你看到了函数如何帮助你节省时间和精力。当你编写一个函数时，你可以在任何地方调用它，而无需在多个地方重复代码块。这肯定很酷，但函数的真正威力在于你传入一个或多个输入值以产生不同的结果时。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-2751
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-2752
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为invite(guest:)的函数，它接受一个人的名字作为输入，并生成一个个性化的生日派对邀请函。在你的Playground中输入以下内容：
- en: '[PRE521]'
  id: totrans-2753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-2754
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要在函数名称后面的括号内包含它➊。你按格式写输入参数，首先是它的名称（在这个例子中是guest），然后是冒号(:)，最后是它的数据类型（在这个例子中是String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名称也充当参数标签，因此在调用此函数时，guest将作为参数标签。（你将在“[参数标签](text00017.html#ch07lev1sec4)”的[第89页](text00017.html#page_89)学习如何定义独立的参数名称和参数标签。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-2756
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后面写输入参数的数据类型，就像声明变量时一样。然而，与变量声明不同，在定义函数参数时，你*必须*始终声明函数期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-2757
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，只需像使用其他常量一样使用它的参数名称➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-2759
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义函数还不够。现在函数已定义，让我们在Playground中调用它，看看会发生什么。你可以通过输入函数名称，后跟括号内的参数标签、冒号和参数来调用带有输入参数的函数，如下所示：
- en: '[PRE522]'
  id: totrans-2760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过编写函数名称来调用一个函数时，Xcode的自动完成功能会提示你应该传递什么给函数。在这种情况下，当你开始写invite时，你会看到一个像[图7-2](text00017.html#ch07fig2)中的下拉菜单。
- en: '![Image](Image00155.jpg)'
  id: totrans-2762
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：Xcode的自动完成功能将向你展示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-2764
  prefs: []
  type: TYPE_NORMAL
  zh: 按ENTER键自动完成函数。你的光标将移动到函数的括号内（参见[图7-3](text00017.html#ch07fig3)），Xcode会自动添加一些占位符文本，告诉你函数期望什么类型的输入。
- en: '![Image](Image00156.jpg)'
  id: totrans-2765
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：Xcode正在等待你填写guest参数。*'
- en: '**NOTE**'
  id: totrans-2767
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递了一个不是字符串的东西给invite(guest:)，例如invite(guest: 45)，你将会得到一个错误，因为函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-2769
  prefs: []
  type: TYPE_NORMAL
  zh: 只需输入"Cathy"或其他朋友的名字替代String，然后按TAB键完成函数调用。它应该如下所示：[图7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-2770
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：一个invite(guest:)函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-2772
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用invite(guest:)三次，使用你自己朋友的名字：
- en: '[PRE523]'
  id: totrans-2773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: 'The output looks like this:'
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE524]'
  id: totrans-2775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-2776
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你可以快速打印出三份派对邀请函，每份邀请函都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-2777
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写一个函数，通过传递一个字符串数组作为参数，一次性邀请所有朋友，而不是传递单个字符串。在你写了 invite(guest:) 的同一个 playground
    中，编写以下 invite(allGuests:) 函数进行测试。注意，参数名称现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-2779
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE525]'
  id: totrans-2780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当你声明函数的参数时，你会注意到 [String] 被放在方括号中 ➊。方括号声明数据类型为数组，而 String 表示数组中值的数据类型。通过使用
    [String]，我们声明该函数的输入为字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-2782
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们需要使用一个 for-in 循环遍历我们的 guests 数组，并为每位客人打印邀请函。记得我们刚刚创建了一个打印邀请函的函数吗？让我们在这里使用它！将以下内容添加到你的
    invite(allGuests:) 函数中（灰色文本显示了现有的代码）：
- en: '[PRE526]'
  id: totrans-2783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-2784
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们会对每个 guests 数组中的客人调用 invite(guest:) 函数，邀请每个人参加生日派对。你可能会想，invite(guest:)
    和 invite(allGuests:) 是不是同一个函数。毕竟，它们的名字都叫做 invite。尽管它们共享一个名字，但它们是两个不同的函数，因为它们接受不同的输入参数。这种模式在
    Swift 中非常常见。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 invite(allGuests:) 函数，我们首先创建一个名为 friends 的数组，然后在函数调用中使用它。
- en: '[PRE527]'
  id: totrans-2786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-2787
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后我们使用新的数组作为函数输入，调用该函数 ➋。这是你将在调试控制台中看到的输出（-- snip -- 显示了我们为节省空间省略的行）：
- en: '[PRE528]'
  id: totrans-2788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-2789
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友写邀请函，那将是一项繁重的工作。但借助函数的强大功能，你仅用了很少的代码行就完成了这一任务。尝试创建你自己的朋友数组，随意设置它的长度！然后使用你的新数组作为输入，调用
    invite(allGuests:) 函数。简直是小菜一碟！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-2790
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给您的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-2791
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你派对的日期即将到来，但有些客人还没有回复是否参加。你想要确认最终的到场人数，并告诉客人们带上泳衣，因为这是一个滑水派对。你可以写一个函数，根据客人是否回复，向每个客人发送定制的信息。
- en: '![Image](Image00159.jpg)'
  id: totrans-2792
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-2793
  prefs: []
  type: TYPE_NORMAL
  zh: 你新创建的函数将有两个输入参数：一个 String 类型的参数表示客人的名字，另一个 Bool 类型的参数表示是否回复（true 或 false）。在你的
    playground 中输入以下代码：
- en: '[PRE529]'
  id: totrans-2794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-2795
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数有多个输入参数时，你需要在每个参数之间加一个逗号 ➊。每个参数需要有一个参数名，后面跟一个冒号和该参数的数据类型。你可以创建一个接受任意多个输入参数的函数，它们不必是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传入了一个String类型的guest和一个Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-2796
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为true ➋，然后使用if-else语句打印相应的消息。请注意，函数定义中的最终print语句无论rsvped值是true还是false都会执行，因为它们位于if-else语句的括号外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经RSVP，他们将看到这个消息：
- en: '[PRE530]'
  id: totrans-2798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-2799
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提示，要求他们回复：
- en: '[PRE531]'
  id: totrans-2800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-2801
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来调用这个函数，看看它是如何工作的。试着将一位客人的rsvped值设置为true，将另一位客人的rsvped值设置为false，这样你就能看到两个消息的效果。
- en: '[PRE532]'
  id: totrans-2802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-2803
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-2804
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能将帮助你填写输入值，并为你提供参数标签。你只需传入你想要使用的值。填写完客人姓名后，按TAB键，Xcode会将光标移到你需要的位置，以便填写下一个输入值。（请参见[图7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-2805
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-2806
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：在输入完客人姓名后按TAB键，光标会自动跳到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你rsvped的数据类型。将占位符文本Bool替换为true或false。如果你尝试传入其他内容，比如名字或数字，你将得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-2808
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-2809
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用print(_:)时，输入值前面没有参数标签？你只需要写：
- en: '[PRE533]'
  id: totrans-2810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-2811
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，你会得到一个错误：
- en: '[PRE534]'
  id: totrans-2812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-2813
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且这个标签与参数名相同。然而，如果你写的函数认为参数标签对于代码清晰度并不是必要的，你可以在函数定义中明确省略它。例如，在print(_:)函数中，传入的值显然是一个将要打印的字符串。每次调用print(_:)时都包含一个像inputString这样的参数标签会显得很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你通过在函数声明的括号内，首先输入参数标签、参数名、冒号，然后是参数的数据类型来实现这一点。这通常是在
    Swift 函数中进行的，目的是让函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6) 说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-2815
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-2816
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用函数时会像
    sayHello(friend:)，这听起来不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-2818
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将讨论如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-2819
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-2820
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示如何添加自定义参数标签能使代码更具可读性。在你的生日派对之后，你可能想给所有的客人发送感谢卡。在你的 Playground 中写下以下函数：
- en: '[PRE535]'
  id: totrans-2821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-2822
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了自定义参数标签 to。类似地，在 ➋ 处，我们为 gift 参数添加了参数标签 for。参数名 guest
    ➌ 和 gift ➍ 用于引用函数内部的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-2823
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于标记函数调用时的参数，像这样：
- en: '[PRE536]'
  id: totrans-2824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-2825
  prefs: []
  type: TYPE_NORMAL
  zh: '这里你可以看到，to: 在第一个输入值之前写入，for: 在第二个输入值之前写入。如果参数有自定义的参数标签，你必须在函数调用中使用它。如果尝试使用参数名代替，程序会报错：'
- en: '[PRE537]'
  id: totrans-2826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-2827
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会自动为你填充参数标签，因此你不必担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-2828
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-2829
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全函数并添加正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人 *发送* 感谢卡，*感谢* 礼物。代码
    sendThankYou(to: "Meghan", for: "puzzle books") 比 sendThankYou(guest: "Meghan",
    gift: "puzzle books") 更像一句完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-2831
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-2832
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-2833
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前加一个下划线和一个空格来去除它们。在下面的例子中，我们编写了一个计算体积的函数，它接受盒子的三条边作为输入。因为函数名已经清楚地表明需要传入三条边，所以你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE538]'
  id: totrans-2834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-2835
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处、➋处和➌处的`side1`、`side2`和`side3`前面加下划线来去除边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-2836
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需要输入参数值，而无需任何标签。
- en: '[PRE539]'
  id: totrans-2837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-2838
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。”如果你不仅仅是打印盒子的体积，而是将结果存储到一个变量或常量中以便稍后使用，这岂不是更有用吗？让我们来看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-2839
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-2840
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-2841
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-2842
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，编写一个返回盒子体积的`volumeOfBox(_:_:_:)`函数，它返回一个`Int`类型的体积：
- en: '[PRE540]'
  id: totrans-2843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-2844
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给函数一个返回值，在函数的输入参数之后用一个破折号和大于号组成一个箭头（->）➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你使用`return`关键字返回你想返回的值➋。如果你编写一个返回值的函数，那么你*必须*在函数内返回该值，否则会出现错误。函数在返回值后结束。如果你在返回语句后写任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-2845
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-2846
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数以查看其效果：
- en: '![](Image00165.jpg)'
  id: totrans-2847
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-2848
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`volumeOfBox(_:_:_:)`函数计算了一个边长为6、5和3的盒子的体积，返回值90被存储在一个名为`volumeOfBox1`的常量中。在➋处，边长为8、4和2的`volumeOfBox2`被赋值为64。现在，让我们打印一条消息，说明哪个盒子更大：
- en: '[PRE541]'
  id: totrans-2849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-2850
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串“Box 1 is the bigger box.”（盒子1更大）的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-2851
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-2852
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，它接受一个成绩数组并返回平均成绩。为了获得平均值，你需要将所有成绩加起来，然后除以成绩的总数。在你的playground中输入以下代码：
- en: '[PRE542]'
  id: totrans-2853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-2854
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为`sum`的`Int`类型变量，并将其初始化为`0`。在 ➋ 处，`for-in`循环遍历`scores`数组中的每个值，并将其加到`sum`变量中。当循环完成后，`sum`变量就保存了所有分数的总和。在计算出总和之后，剩下的工作就是将总和除以分数的总数量，这个数量就是`scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-2855
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能把某个值除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除零错误并崩溃程序。因此，在进行除法运算时，始终确保除数不是零，这就是我们通过检查`scores.count
    > 0`来实现的 ➌。在 ➍ 处，我们通过将分数总和除以分数数量来返回平均值，使用`return sum / scores.count`。没错！你可以返回任何计算结果符合正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回`sum
    / scores.count`，因为它的结果是`Int`类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-2856
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`scores.count`不大于零时，我们也需要返回某些内容，否则会出现错误，提示函数缺少返回值。我们通过在`if`语句中添加`else`来处理这个问题，返回`0`
    ➎。你可以通过在包含分数的数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-2857
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-2858
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像 ➊ 处一样将一个完整的测试分数数组传递给`averageOf()`函数时，它会返回并显示分数的平均值。如果你传入一个空数组，像 ➋ 处那样，返回值则是`0`。
- en: '**NOTE**'
  id: totrans-2859
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-2860
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕`return 0`的`else`语句实际上并不是必须的。这是因为如果`scores.count > 0`，那么函数已经通过`return
    sum / scores.count`结束了。因此，如果程序已经执行到`if`语句之后，我们就知道`scores.count > 0`一定不成立，这时我们完全可以直接使用`return
    0`，而不必把它放在`else`语句中。然而，如果我们保留`else`语句，代码会更加清晰，易于理解。有时候，写一些额外的代码使他人更容易理解比使用复杂的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-2861
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-2862
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为自己的Swift工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以完成各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-2863
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建类型不同于Swift中已包含的类型的常量和变量，在你创建应用时会派上用场！
- en: '![Image](Image00152.jpg)'
  id: totrans-2864
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00152.jpg)'
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-2865
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数时，你只需要写出它的名称，后跟括号和其中的任何参数。这就是*函数调用*。在这个例子中，因为 printAHaiku() 没有输入参数，你不需要传递任何参数——只需保持括号为空。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-2866
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 printAHaiku()，在函数的右大括号后面添加以下代码：
- en: '[PRE543]'
  id: totrans-2867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: 'The console output is:'
  id: totrans-2868
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出为：
- en: '[PRE544]'
  id: totrans-2869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-2870
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数内部的代码将会执行。确保你已经打开了调试区域（⌘ -SHIFT -Y），就像在[图 7-1](text00017.html#ch07fig1)中那样，这样你就可以看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-2871
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-2872
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-2873
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用 printAHaiku() 函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-2874
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数还能通过输入参数做更多的事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-2875
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，你看到函数如何节省时间和精力。当你编写一个函数时，你可以在任何地方调用它，而无需在许多地方重复代码块。这当然很酷，但函数的真正威力在于你传入一个或多个输入值以生成不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-2876
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-2877
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个名为 invite(guest:) 的函数，它接受一个人的名字作为输入，并生成一个个性化的生日派对邀请函。将以下内容输入到你的 playground
    中：
- en: '[PRE545]'
  id: totrans-2878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-2879
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要在函数名后面的括号中包含它➊。你格式化输入参数时，首先写上它的名称（在这个例子中是 guest ），然后是冒号（:），最后是它的数据类型（这里是
    String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-2880
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名称也充当参数标签，所以当你调用这个函数时，guest 将是参数标签。（你将在“[参数标签](text00017.html#ch07lev1sec4)”一节中学习如何定义单独的参数名称和参数标签，见[第
    89 页](text00017.html#page_89)。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-2881
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后写上输入参数的数据类型，就像声明变量时一样。然而，与变量声明不同的是，在定义函数参数时，你必须*始终*声明函数应当接受的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-2882
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-2883
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需要像使用任何其他常量一样使用它的参数名称➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-2884
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义函数并不够。现在函数已经定义好了，让我们在 playground 中调用它，看看会发生什么。你可以通过输入函数名称后跟括号，括号内是参数标签、冒号和参数，来调用带有输入参数的函数，像这样：
- en: '[PRE546]'
  id: totrans-2885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-2886
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名称调用一个函数时，Xcode 的自动完成功能会给你一个提示，告诉你应该传入什么参数。在这种情况下，当你开始写 invite 时，你会看到一个下拉菜单，就像在[图
    7-2](text00017.html#ch07fig2)中那样。
- en: '![Image](Image00155.jpg)'
  id: totrans-2887
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-2888
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成功能会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-2889
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键自动完成函数。光标将移动到函数的括号内（见[图 7-3](text00017.html#ch07fig3)），此时 Xcode 会自动添加一些占位符文本，告诉你函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-2890
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-2891
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-2892
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-2893
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递给 invite(guest:) 的参数不是字符串，比如 invite(guest: 45)，你会得到一个错误，因为该函数期望的是字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-2894
  prefs: []
  type: TYPE_NORMAL
  zh: 只需输入 "Cathy" 或其他朋友的名字，替换掉 String，然后按 TAB 键完成函数调用的填写。它应该像[图 7-4](text00017.html#ch07fig4)那样。
- en: '![Image](Image00157.jpg)'
  id: totrans-2895
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-2896
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个邀请（guest:）函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-2897
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用，使用你自己朋友的名字调用三次 invite(guest:)：
- en: '[PRE547]'
  id: totrans-2898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: 'The output looks like this:'
  id: totrans-2899
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE548]'
  id: totrans-2900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-2901
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你能够快速打印三张派对邀请函，每张都写给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-2902
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-2903
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，通过传入一个字符串数组作为参数，而不是单个字符串，来一次性邀请所有朋友。在你写了 invite(guest:) 的同一个 playground
    中，编写以下 invite(allGuests:) 函数来进行测试。请注意，参数名称现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-2904
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00158.jpg)'
- en: '[PRE549]'
  id: totrans-2905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-2906
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到 [String] 被括在方括号中 ➊。方括号声明了数据类型为数组，而 String 则表示数组中元素的数据类型。通过使用
    [String]，我们声明了这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-2907
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们将使用一个 for-in 循环来遍历我们的 guests 数组，并为每位客人打印一张邀请函。记得我们刚刚创建了一个打印邀请函的函数吗？我们可以在这里使用它！在你的
    invite(allGuests:) 函数中添加以下内容（灰色文本表示现有的代码行）：
- en: '[PRE550]'
  id: totrans-2908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-2909
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们在 String 数组 allGuests 的每位客人上调用单一的 invite(guest:) 函数，以邀请每个人参加生日派对。你可能会问，invite(guest:)
    和 invite(allGuests:) 是不是同一个函数。毕竟，它们的名称都是 invite。尽管它们名字相同，但它们是两个不同的函数，因为它们接受不同的输入参数。这是
    Swift 中常见的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-2910
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 invite(allGuests:) 函数，首先我们创建一个名为 friends 的数组，随后我们将在函数调用中使用它。
- en: '[PRE551]'
  id: totrans-2911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-2912
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后，我们用这个新数组作为函数的输入来调用函数 ➋。这是你在调试控制台中看到的输出（-- snip -- 表示我们为节省空间而省略的部分）：
- en: '[PRE552]'
  id: totrans-2913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-2914
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为每一个朋友写邀请函，那将会是件非常繁琐的事情。但凭借函数的强大功能，你用非常少的代码就完成了这项任务。试着创建你自己的朋友数组吧；可以尽情扩展它的长度！然后使用新的数组作为输入，调用`invite(allGuests:)`函数。简直轻而易举！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-2915
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-2916
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近，而一些客人还没有回复RSVP。你希望确认最终的参与人数，并告诉客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据每个客人的RSVP状态发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-2917
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-2918
  prefs: []
  type: TYPE_NORMAL
  zh: 你新的函数将需要两个输入参数：一个`String`类型的参数用于存放客人姓名，一个`Bool`类型的参数用于存放RSVP状态，它的值可以是`true`或`false`。在你的playground中输入以下代码：
- en: '[PRE553]'
  id: totrans-2919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-2920
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数需要多个输入参数时，你需要在每个参数之间加上逗号 ➊ 。每个参数都需要有一个参数名称，后面跟上冒号和参数的数据类型。你可以创建一个接受任意多个输入参数的函数，且这些参数不必是相同类型。在`sendMessage(guest:rsvped:)`函数中，我们传入了一个`String`类型的guest和一个`Bool`类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-2921
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped的值，看看它是否为`true` ➋ ，然后通过`if-else`语句打印出相应的消息。也注意到，函数定义中的最后几行`print`语句无论rsvped值是`true`还是`false`都会执行，因为它们在`if-else`语句的括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-2922
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复了RSVP，他们将收到以下消息：
- en: '[PRE554]'
  id: totrans-2923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-2924
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提醒，请他们回复：
- en: '[PRE555]'
  id: totrans-2925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-2926
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数来看看它是如何工作的。试着将一个客人的rsvped值设置为`true`，另一个客人的rsvped值设置为`false`，这样你就能看到两个不同消息的实际效果。
- en: '[PRE556]'
  id: totrans-2927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-2928
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数和调用一个只有单个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-2929
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会帮助你填写输入值，并为你提供参数标签。你只需传入你想使用的值。填写完客人姓名后，按`TAB`键，Xcode会将光标移到下一个输入字段的位置，方便你填写下一个输入值。（见[图7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-2930
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-2931
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：输入完客人姓名后按TAB键，光标会自动跳到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-2932
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你rsvped的类型。将占位符文本`Bool`替换为`true`或`false`。如果你尝试传入其他内容，如姓名或数字，将会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-2933
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-2934
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用`print(_:)`时，并没有在输入值前面加上参数标签吗？你只需要写：
- en: '[PRE557]'
  id: totrans-2935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-2936
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试加上一个标签，你将会遇到错误：
- en: '[PRE558]'
  id: totrans-2937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-2938
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且它将与参数名相同。然而，如果你编写函数时认为参数标签对代码的清晰性没有必要，你可以在函数定义中显式地省略它。例如，在
    `print(_:)` 函数中，传入的输入显然是一个将被打印的字符串。如果每次调用 `print(_:)` 都必须包含像 inputString 这样的参数标签，那会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-2939
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号，最后是参数的数据类型来实现这一点。当你在`func`关键字后第一次声明函数参数时，你就会这么做。Swift
    函数中常常使用这种方式，使函数调用看起来更像一句话。[图 7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-2940
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-2941
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-2942
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 friend，参数标签是 to，函数调用中传递的参数是 "Colin"。如果没有单独的参数标签，当你调用这个函数时，它会像这样写：`sayHello(friend:)`，这听起来不像一句完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-2943
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何编写带有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-2944
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-2945
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例，展示添加自定义参数标签如何使你的代码更具可读性。在你的生日派对后，你可能会想给所有的客人发送感谢信。你可以在 Playground
    中编写以下函数：
- en: '[PRE559]'
  id: totrans-2946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-2947
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递到函数中的 guest 参数添加了一个自定义参数标签 to。类似地，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名
    guest ➌ 和 gift ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-2948
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被调用时，参数标签 to 和 for 被用来标记参数，如下所示：
- en: '[PRE560]'
  id: totrans-2949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-2950
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `to:` 被写在函数调用中的第一个输入值之前，`for:` 被写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名代替它会导致错误：
- en: '[PRE561]'
  id: totrans-2951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-2952
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填充参数标签，因此你不必担心错误地调用函数（参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-2953
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-2954
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-2955
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于将感谢信发送*给*客人*以*表示对礼物的感谢。代码sendThankYou(to:
    "Meghan", for: "puzzle books")读起来更像一句话，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-2956
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-2957
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-2958
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加下划线和一个空格来去除它们。在下面的例子中，我们写了一个计算体积的函数，该函数以盒子的三个边长作为输入。因为函数名已经明确表示你需要传入三个边长，所以你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE562]'
  id: totrans-2959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-2960
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处的side1、➋处的side2和➌处的side3前面加上下划线来移除边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-2961
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用该函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE563]'
  id: totrans-2962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-2963
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"这个盒子的体积是72。"如果你能将盒子的体积存储在一个变量或常量中，稍后再使用，而不是仅仅打印它，岂不是更有用吗？让我们了解如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-2964
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-2965
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-2966
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-2967
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，编写一个volumeOfBox(_:_:_:)函数，该函数返回一个Int类型的盒子体积：
- en: '[PRE564]'
  id: totrans-2968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-2969
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数提供返回值，在函数的输入参数后➊，使用一个破折号和一个大于号来组成一个箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，你通过使用return关键字后跟要返回的值来返回该值➋。如果你写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果你在return语句之后在函数内写任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-2970
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-2971
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-2972
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-2973
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算了边长分别为6、5和3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋处，边长为8、4和2的volumeOfBox2被赋值为64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE565]'
  id: totrans-2974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-2975
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台中看到字符串"Box 1 is the bigger box."
- en: '**CONDITIONAL RETURNS**'
  id: totrans-2976
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-2977
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会希望根据某个条件返回不同的值。让我们写一个函数，它接收一个测试分数数组并返回平均分。为了获得平均分，你需要将分数加在一起，然后除以分数的总数。将以下代码输入到你的
    playground 中：
- en: '[PRE566]'
  id: totrans-2978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-2979
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 类型变量，并将其初始值设为 0。位于 ➋ 处的 `for-in`
    循环遍历 `scores` 数组中的每个值，并将其加到 `sum` 变量上。当循环完成时，`sum` 变量保存了所有分数的总和。在计算出总和之后，剩下的就是将其除以分数的总数，这个值就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-2980
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空怎么办呢？你不能将任何东西除以零——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并崩溃程序。因此，在进行除法时，始终确保你要除的数不是零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来做到的。在 ➍ 处，我们通过将分数总和除以数组中分数的数量来返回平均值，使用的是 `return sum
    / scores.count`。没错！你可以返回任何计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 `sum /
    scores.count`，因为它的计算结果是一个 `Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-2981
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们还需要返回一个值，否则会报错提示函数缺少返回值。我们通过在 if 语句中添加一个 else
    来处理这一情况，返回 0 ➎ 。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-2982
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-2983
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传入 `averageOf()` 函数时，如我们在 ➊ 处所做的，分数的平均值将被返回并显示在结果窗格中。如果你传入一个空数组，如我们在
    ➋ 处所做的，返回值则为 0。
- en: '**NOTE**'
  id: totrans-2984
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-2985
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 else 语句其实不是非常必要的。因为如果 `scores.count > 0`，那么函数已经通过 `return
    sum / scores.count` 提前结束了。所以如果程序已经越过了那个 if 语句，我们就知道 `scores.count > 0` 一定是不成立的，我们可以直接写
    `return 0`，而不必把它放在 else 语句中。然而，如果我们保留 else 语句，代码会更清晰，也更容易理解。有时候，为了让别人更容易理解，写多一点代码比使用复杂的简写要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-2986
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-2987
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建并调用你自己的函数！函数在编程中被广泛使用，用于做各种令人惊奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-2988
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)，我们将展示如何通过编写类定义来创建自定义对象。这样你可以创建除 Swift 已经包含的类型之外的常量和变量，这在你创建应用程序时会很有用！
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  id: totrans-2989
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个函数，你只需写出它的名称，然后是圆括号，里面放置任何参数。这就是 *函数调用*。在这种情况下，由于 `printAHaiku()` 没有输入参数，你不需要传递任何参数——只需保持圆括号为空。
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-2990
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 `printAHaiku()`，请在函数的右大括号后将以下代码行添加到你的 playground 中：
- en: '[PRE567]'
  id: totrans-2991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: 'The console output is:'
  id: totrans-2992
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出是：
- en: '[PRE568]'
  id: totrans-2993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-2994
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数内部的代码将会执行。确保打开调试区域（⌘ -SHIFT -Y），如[图 7-1](text00017.html#ch07fig1)所示，以便查看结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-2995
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-2996
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-2997
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用 `printAHaiku()` 函数吧！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-2998
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数实现更多功能**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-2999
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，你看到了函数如何为你节省时间和精力。当你编写一个函数时，你可以在任何地方调用它，而不必在多个地方重复代码块。这确实很酷，但函数的真正强大之处在于你传入一个或多个输入值，以产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-3000
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-3001
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 `invite(guest:)` 的函数，它接受一个人的名字作为输入，并创建一个个性化的生日派对邀请函。将以下代码输入到你的 playground
    中：
- en: '[PRE569]'
  id: totrans-3002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-3003
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将它包含在函数名称后面的圆括号中 ➊。你首先写出输入参数的名称（在这个例子中是 guest），然后是冒号（:），最后是数据类型（在这个例子中是
    String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-3004
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名称也作为参数标签，因此当你调用此函数时，guest 将是参数标签。（你将在 “[Argument Labels](text00017.html#ch07lev1sec4)”
    第89页了解如何定义单独的参数名称和参数标签。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-3005
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后写出输入参数的数据类型，就像声明变量时一样。然而，与变量声明不同，当定义函数参数时，你必须 *始终* 声明函数应该期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-3006
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-3007
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需使用它的参数名称，就像使用其他常量一样 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-3008
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数并不够。既然函数已经定义，我们就来 playground 中调用它看看会发生什么。你可以通过输入函数名称，后面跟着圆括号、参数标签、冒号和参数来调用一个有输入参数的函数，像这样：
- en: '[PRE570]'
  id: totrans-3009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-3010
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写出函数名来调用一个函数时，Xcode 的自动完成功能会给你提示，告诉你应该传入什么参数。在这种情况下，当你开始输入 invite 时，你会看到一个下拉菜单，像
    [图 7-2](text00017.html#ch07fig2) 中的那样。
- en: '![Image](Image00155.jpg)'
  id: totrans-3011
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-3012
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成功能会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-3013
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键自动完成函数。你的光标会进入函数的括号内（见 [图 7-3](text00017.html#ch07fig3)），此时 Xcode
    自动添加了一些占位文本，告诉你该函数期望什么类型的输入。
- en: '![Image](Image00156.jpg)'
  id: totrans-3014
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-3015
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-3016
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-3017
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递一个非字符串类型的值给 invite(guest:)，比如 invite(guest: 45)，你会得到一个错误，因为该函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-3018
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 位置输入 "Cathy" 或其他朋友的名字，然后按 TAB 键完成函数调用。它应该看起来像 [图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-3019
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-3020
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-3021
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，使用你自己朋友的名字调用 invite(guest:) 函数三次：
- en: '[PRE571]'
  id: totrans-3022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: 'The output looks like this:'
  id: totrans-3023
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下所示：
- en: '[PRE572]'
  id: totrans-3024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-3025
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你可以快速打印出三张派对邀请函，每一张都发给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-3026
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有你的朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-3027
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以写一个一次性邀请所有朋友的函数，通过传递一个字符串数组作为参数，而不是单个字符串。在你编写 invite(guest:) 函数的同一个 playground
    中，编写以下 invite(allGuests:) 函数进行测试。注意，参数名称现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-3028
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE573]'
  id: totrans-3029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-3030
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到 [String] 被放在方括号中 ➊。方括号声明数据类型为数组，String 表示数组中值的数据类型。通过使用
    [String]，我们声明这个函数的输入为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-3031
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们需要使用一个 for-in 循环来遍历我们的 guests 数组，并为每个客人打印一张邀请函。记得我们刚才创建了一个打印邀请函的函数吗？让我们在这里使用它！将以下内容添加到你的
    invite(allGuests:) 函数中（灰色文本表示现有行）：
- en: '[PRE574]'
  id: totrans-3032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-3033
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们对 String 数组 allGuests 中的每个客人调用单数形式的 invite(guest:) 函数，以邀请每个人参加生日派对。你可能会想，invite(guest:)
    和 invite(allGuests:) 是不是同一个函数。毕竟，它们的名字都叫 invite。然而，尽管它们共享相同的名字，但它们是两个不同的函数，因为它们接受不同的输入参数。这是
    Swift 中常见的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-3034
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 invite(allGuests:) 函数，首先我们创建一个名为 friends 的数组，然后在函数调用中使用它。
- en: '[PRE575]'
  id: totrans-3035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-3036
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后，我们用这个新数组作为函数的输入调用函数 ➋ 。这是你将在调试控制台看到的输出（-- snip -- 显示了我们为了节省空间省略的部分）：
- en: '[PRE576]'
  id: totrans-3037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-3038
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为这些朋友写出邀请函，那将是一项繁重的工作。但借助函数的强大功能，你只需几行代码就能完成。试着创建你自己的朋友数组；可以根据需要任意长！然后用你新创建的数组作为输入调用
    invite(allGuests:) 函数。简直轻松极了！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-3039
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-3040
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近，而一些客人还没有回复是否参加。你想得到最终的确认人数，并提醒客人带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据客人的
    RSVP 状态向每位客人发送个性化消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-3041
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-3042
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个用于客人姓名的 String 参数和一个用于 RSVP 状态的 Bool 参数，值为 true 或 false。请在你的
    playground 中输入以下代码：
- en: '[PRE577]'
  id: totrans-3043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-3044
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间添加逗号 ➊ 。每个参数都需要有一个参数名，后跟冒号和参数的数据类型。你可以创建一个函数，接受任意数量的输入参数，它们不必是相同类型的。在
    sendMessage(guest:rsvped:) 函数中，我们传入的是一个 String 类型的 guest 和一个 Bool 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-3045
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 值是否为 true ➋ ，然后使用 if-else 语句打印相应的消息。还要注意，函数定义中的最终 print 语句无论
    rsvped 值为 true 还是 false 都会执行，因为它们在 if-else 语句的括号外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-3046
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已确认出席，他们将收到此消息：
- en: '[PRE578]'
  id: totrans-3047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-3048
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的通知，要求他们回复：
- en: '[PRE579]'
  id: totrans-3049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-3050
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。试着将一个客人的 rsvped 值设置为 true，另一个设置为 false，这样你就能看到两种消息的实际效果。
- en: '[PRE580]'
  id: totrans-3051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-3052
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-3053
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能将帮助你填写输入值，通过提供参数标签。你只需要传入你想使用的值即可。填写完客人名字后，按 TAB 键，Xcode 会将光标定位到你需要填写下一个输入值的位置。（见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-3054
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-3055
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按 TAB 键，会将光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-3056
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他东西，比如名字或数字，你会得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-3057
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-3058
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用 print(_:) 时，输入值前面没有参数标签吗？你写的是：
- en: '[PRE581]'
  id: totrans-3059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-3060
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你会得到一个错误：
- en: '[PRE582]'
  id: totrans-3061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-3062
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，而且它将与参数名相同。然而，如果你编写函数时觉得参数标签对代码的清晰度没有帮助，你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，输入的内容显然是一个将被打印的字符串。如果每次调用 print(_:) 都必须包含像 inputString 这样的参数标签，那将会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-3063
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个不同于参数名的参数标签。你通过输入参数标签、参数名、冒号，最后是参数的数据类型来做到这一点。这一切都在你首次声明函数括号内的参数时完成，位于
    func 关键字后面。这种做法在 Swift 函数中常见，目的是让函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6)
    展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-3064
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-3065
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-3066
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，当你调用函数时，它会像
    sayHello(friend:) 这样，这听起来不像是一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-3067
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-3068
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-3069
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，看看添加自定义参数标签如何使代码更具可读性。假设在你的生日派对后，你想给所有来宾发送感谢信。请在你的 Playground 中编写以下函数：
- en: '[PRE583]'
  id: totrans-3070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-3071
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们为传递给函数的 guest 参数添加了一个自定义参数标签 *to*。类似地，在 ➋，我们为 gift 参数添加了一个参数标签 *for*。参数名
    guest ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-3072
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 *to* 和 *for* 用于在调用函数时标记参数，像这样：
- en: '[PRE584]'
  id: totrans-3073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-3074
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到，在第一个输入值前面写了to:，在第二个输入值前面写了for:。如果一个参数有自定义的参数标签，那么你必须在函数调用中使用它。如果你尝试使用参数名称而不是标签，则会出现错误：
- en: '[PRE585]'
  id: totrans-3075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-3076
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会始终为你填写参数标签，所以你不必担心错误地调用函数（参见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-3077
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-3078
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动完成了具有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-3079
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于向客人*发送*感谢信，以感谢他们送的礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")读起来更像一句话，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-3080
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-3081
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-3082
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线和空格来去除它们。在下面的示例中，我们编写了一个用于计算体积的函数，该函数以盒子的三条边长作为输入。因为函数名称已经清楚表明你需要传入三条边，所以实际上你并不需要参数标签来提高代码的可读性。
- en: '[PRE586]'
  id: totrans-3083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-3084
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在side1的前面放置一个下划线➊，在side2的前面放置一个下划线➋，以及在side3的前面放置一个下划线➌，来移除参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-3085
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用该函数时，只需输入参数值，不需要任何标签。
- en: '[PRE587]'
  id: totrans-3086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-3087
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将输出“The volume of this box is 72.”。如果你可以将结果存储到变量或常量中，以便稍后使用，而不仅仅是打印出盒子的体积，那是不是更有用呢？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-3088
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-3089
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-3090
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-3091
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想要知道哪个可以装更多的东西。首先，编写一个返回盒子体积的Int类型的volumeOfBox(_:_:_:)函数：
- en: '[PRE588]'
  id: totrans-3092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-3093
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数返回一个值，使用一个连字符和大于号组成的箭头(-> )，紧接着输入参数后面➊，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，通过使用return关键字后跟你想返回的值来返回该值➋。如果你编写了一个返回值的函数，那么你*必须*在函数内返回该值，否则会出现错误。函数在你返回值后结束。如果你在return语句后写任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-3094
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-3095
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它如何工作：
- en: '![](Image00165.jpg)'
  id: totrans-3096
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-3097
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算了一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE589]'
  id: totrans-3098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-3099
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-3100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-3101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，它接受一个测试成绩数组并返回平均分数。要获得平均值，你需要将所有分数加在一起，然后除以分数的总数。将以下代码输入到你的
    playground 中：
- en: '[PRE590]'
  id: totrans-3102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-3103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有数值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 变量，并将其初始化为 0。➋ 处的 for-in 循环遍历 scores
    数组中的每个值，并将其加到 sum 变量中。当循环完成时，变量 sum 保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，分数的总数就是 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-3104
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空呢？你不能把一个数除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并使程序崩溃。因此，在进行除法时，务必确保你将要除的数不是零，这就是我们在
    ➌ 处通过检查 scores.count > 0 来做到的。在 ➍ 处，我们通过将总分除以数组中分数的数量来返回平均值，使用 return sum / scores.count。没错！你可以返回任何计算后得到正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋给新变量的步骤，直接返回
    sum / scores.count，因为它会被计算为一个 Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-3105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们也需要返回一些内容，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加 else
    来处理这个问题，返回 0 ➎。你可以通过调用该函数来测试代码，分别传入一个有分数的数组和一个空数组：
- en: '![](Image00166.jpg)'
  id: totrans-3106
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-3107
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给 averageOf() 函数时，正如我们在 ➊ 处所做的，返回值将是分数的平均值，并显示在结果窗格中。如果你传入一个空数组，正如我们在
    ➋ 处所做的，返回值将是 0。
- en: '**NOTE**'
  id: totrans-3108
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-3109
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这个例子中，包围return 0的else语句其实并不是必需的。因为如果scores.count > 0，函数已经会通过return sum /
    scores.count 结束。所以如果程序执行到那个if语句之后，我们就知道scores.count > 0 一定不成立，实际上我们可以直接写return
    0，而不需要放在else语句中。然而，如果保留else语句，代码会更清晰，容易理解。有时，写一点额外的代码，比使用巧妙的捷径让别人更容易理解要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-3110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-3111
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建并调用你自己的函数！函数在编程中被广泛使用，用来完成各种令人惊叹的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-3112
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这样，你可以创建除 Swift 中已有类型之外的常量和变量，这在创建应用程序时非常有用！
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  id: totrans-3113
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用printAHaiku()，在函数的右括号后将以下代码添加到你的 playground 中：
- en: '[PRE591]'
  id: totrans-3114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: 'The console output is:'
  id: totrans-3115
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出为：
- en: '[PRE592]'
  id: totrans-3116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-3117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数中的代码将会执行。确保打开调试区域（⌘ -SHIFT -Y），就像在[图7-1](text00017.html#ch07fig1)中一样，这样你就可以看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-3118
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-3119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-3120
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用 printAHaiku() 函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-3121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数与输入参数的更多应用**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-3122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，你看到了函数如何帮你节省时间和精力。当你编写一个函数时，你可以随时调用它，而无需在多个地方重复代码块。这确实很酷，但函数的真正威力在于你可以传递一个或多个输入值，从而产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-3123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-3124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为invite(guest:)的函数，它接受一个人的名字作为输入，生成一张个性化的生日派对邀请函。在你的 playground 中输入以下内容：
- en: '[PRE593]'
  id: totrans-3125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-3126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将它包含在函数名后的圆括号中 ➊ 。你先写下参数名（例如 guest），然后是一个冒号（:），最后是数据类型（在这个例子中是
    String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-3127
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，因此在调用此函数时，guest 将作为参数标签。（你将会在“[参数标签](text00017.html#ch07lev1sec4)”中学习如何定义单独的参数名和参数标签，见
    [第89页](text00017.html#page_89) 。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-3128
  prefs: []
  type: TYPE_NORMAL
  zh: 你写下输入参数的数据类型时，它的位置就在冒号后面，就像声明变量时一样。不过，不同于声明变量，当定义函数参数时，你*必须*始终声明该函数应期待的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-3129
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-3130
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需使用其参数名，就像使用其他常量一样➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-3131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数是不够的。现在函数已经定义好了，让我们在 playground 中调用它，看看会发生什么。你可以通过输入函数名称，后面跟着括号中的参数标签、冒号和参数值来调用带有输入参数的函数，如下所示：
- en: '[PRE594]'
  id: totrans-3132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-3133
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名来调用一个函数时，Xcode 的自动完成功能会为你提供一个提示，告诉你应该传入什么类型的参数。在这个例子中，当你开始写 invite 时，你会看到一个下拉菜单，就像在[图
    7-2](text00017.html#ch07fig2)中看到的那样。
- en: '![Image](Image00155.jpg)'
  id: totrans-3134
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-3135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成功能会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-3136
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键来自动完成函数。光标将移动到函数的括号内（见[图 7-3](text00017.html#ch07fig3)），此时 Xcode 已经自动添加了一些占位符文本，告诉你函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-3137
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-3138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-3139
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-3140
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递的不是字符串，例如 invite(guest: 45)，你会遇到错误，因为该函数期望一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-3141
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 处输入 "Cathy" 或其他朋友的名字，然后按 TAB 键完成函数调用的填写。它应该像[图 7-4](text00017.html#ch07fig4)那样。
- en: '![Image](Image00157.jpg)'
  id: totrans-3142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-3143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-3144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用 invite(guest:) 三次，使用你自己朋友的名字：
- en: '[PRE595]'
  id: totrans-3145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: 'The output looks like this:'
  id: totrans-3146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE596]'
  id: totrans-3147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-3148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你可以快速打印出三张派对邀请函，每张都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-3149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-3150
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，一次邀请所有朋友，通过传递一个字符串数组作为参数，而不是单个字符串。在你编写 invite(guest:) 的同一个 playground
    中，编写以下 invite(allGuests:) 函数来进行测试。注意，现在参数名称是复数的，因为我们将一次邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-3151
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE597]'
  id: totrans-3152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-3153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被放在方括号中➊。方括号声明数据类型为数组，而String表示数组中值的数据类型。通过使用[String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-3154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们需要使用一个 for-in 循环来遍历我们的 guest 数组，并为每个客人打印一张邀请函。记得我们刚才创建了一个打印邀请函的函数吗？我们在这里也用这个！将以下代码添加到你的
    invite(allGuests:) 函数中（灰色文本显示的是现有的代码行）：
- en: '[PRE598]'
  id: totrans-3155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-3156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个guest调用单一的invite(guest:)函数，邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟，它们的名字都是invite。然而，尽管它们共享同一个名字，它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常会看到的一个模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-3157
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，首先我们创建一个名为friends的数组，然后在函数调用中使用这个数组。
- en: '[PRE599]'
  id: totrans-3158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-3159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组➊。然后，我们使用这个新数组作为函数的输入来调用函数➋。这是你在调试控制台中看到的输出（-- snip --表示我们为了节省空间省略的行）：
- en: '[PRE600]'
  id: totrans-3160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-3161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友单独写邀请函，那将非常繁琐。但凭借函数的强大功能，你可以通过非常少的代码行完成这一任务。试着创建你自己的朋友数组，尽情增加它的长度！然后使用你新创建的数组作为输入，调用invite(allGuests:)函数。简直轻松愉快！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-3162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-3163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期临近，一些客人还没有RSVP。你想要确认最终的来宾人数，并提醒客人带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据客人的RSVP状态向每位客人发送定制的信息。
- en: '![Image](Image00159.jpg)'
  id: totrans-3164
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-3165
  prefs: []
  type: TYPE_NORMAL
  zh: 你新的函数将接受两个输入参数：一个String类型的参数用于客人的名字，一个Bool类型的参数用于RSVP状态，值为true或false。在你的playground中输入以下代码：
- en: '[PRE601]'
  id: totrans-3166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-3167
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加一个逗号➊。每个参数都需要有一个参数名，后面跟着冒号和该参数的数据类型。你可以创建一个接受任意数量输入参数的函数，并且这些参数的类型不必相同。在sendMessage(guest:rsvped:)函数中，我们传入一个字符串类型的guest和一个布尔类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-3168
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为true➋，然后使用if-else语句打印相应的信息。还要注意，函数定义中的最后几条print语句会在rsvped值为true或false时都执行，因为它们位于if-else语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-3169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经RSVP，他们将收到以下信息：
- en: '[PRE602]'
  id: totrans-3170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-3171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有回复，他们会收到一封礼貌的提醒，要求他们做出回应：
- en: '[PRE603]'
  id: totrans-3172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-3173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一个客人的rsvped值设置为true，将另一个客人的rsvped值设置为false，这样你就能看到两条信息的效果。
- en: '[PRE604]'
  id: totrans-3174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-3175
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-3176
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会帮助你填写输入值，为你提供参数标签。你只需传入你想要使用的值。填写完客人名字后，按下 TAB 键，Xcode 会把光标放到你需要填写下一个输入值的位置。（见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-3177
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-3178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入完客人姓名后按 TAB 键，会将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-3179
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 `Bool` 替换为 `true` 或 `false`。如果你尝试传入其他内容，比如名字或数字，你将会得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-3180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-3181
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，在调用 `print(_:)` 时，你并没有在输入值前加上参数标签？你写的是：
- en: '[PRE605]'
  id: totrans-3182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-3183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试加上标签，你会得到一个错误：
- en: '[PRE606]'
  id: totrans-3184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-3185
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它会与参数名相同。然而，如果你编写一个函数时觉得参数标签对于代码的清晰性并非必要，你可以在函数定义中明确省略它。例如，在
    `print(_:)` 函数中，很明显你传入的输入是一个要打印的字符串。如果每次调用 `print(_:)` 都要包含像 `inputString` 这样的参数标签会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-3186
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号，最后是参数的数据类型来实现。当你第一次在函数的圆括号内声明参数时，所有这些操作都会在`func`关键字后进行。在
    Swift 函数中，通常会这么做，以使函数调用看起来更像一句话。[图 7-6](text00017.html#ch07fig6)说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-3187
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-3188
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-3189
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 `friend`，参数标签是 `to`，在函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，当你调用该函数时，它看起来会像
    `sayHello(friend:)`，这听起来不像一句完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-3190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写具有自定义参数标签的函数。我们还会展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-3191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-3192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，看看添加自定义参数标签如何使你的代码更具可读性。在你的生日派对之后，你会想给所有的客人送感谢信。请在你的 Playground 中编写以下函数：
- en: '[PRE607]'
  id: totrans-3193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-3194
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊位置，我们为传递给函数的guest参数添加了自定义参数标签to。类似地，在➋位置，我们为gift参数添加了参数标签for。参数名guest ➌和gift
    ➍在函数内部用于引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-3195
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for用于在调用函数时标识参数，像这样：
- en: '[PRE608]'
  id: totrans-3196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-3197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到to:写在函数调用的第一个输入值之前，for:写在第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用中使用它。如果尝试使用参数名而不是标签，代码将报错：
- en: '[PRE609]'
  id: totrans-3198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-3199
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会始终为你填充参数标签，因此你不必担心错误地调用函数（参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-3200
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-3201
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7: Xcode自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-3202
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于将感谢信*发送给*客人*以感谢*礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")更像是一个句子，而不是sendThankYou(guest: "Meghan", gift: "puzzle
    books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-3203
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-3204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-3205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加一个下划线和空格来移除它们。在以下例子中，我们编写了一个计算体积的函数，该函数以一个盒子的三面为输入。因为函数名已经清楚地表明你需要传入三面，所以你不需要使用参数标签来提高代码的可读性。
- en: '[PRE610]'
  id: totrans-3206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-3207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊位置为side1添加下划线，在➋位置为side2添加下划线，在➌位置为side3添加下划线，去除了这些侧面的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-3208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE611]'
  id: totrans-3209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-3210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出"The volume of this box is 72."。如果你不仅仅是打印出盒子的体积，而是将结果存储到一个变量或常量中以便以后使用，那不是很有用吗？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-3211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-3212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-3213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-3214
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个可以装更多的东西。首先，编写一个volumeOfBox(_:_:_:)函数，该函数返回一个Int值，表示盒子的体积：
- en: '[PRE612]'
  id: totrans-3215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-3216
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数返回值，使用一个破折号和一个大于号来组成箭头(->)，紧接在函数输入参数后面 ➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，你通过使用return关键字并跟随你想返回的值来返回该值
    ➋。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值之后结束。如果你在return语句后编写任何代码，它将被忽略，因为return会使函数退出。
- en: '![Image](Image00164.jpg)'
  id: totrans-3217
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-3218
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-3219
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-3220
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算了一个边长分别为6、5和3的盒子的体积，返回值90被存储在名为volumeOfBox1的常量中。在➋处，边长分别为8、4和2的volumeOfBox2被赋值为64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE613]'
  id: totrans-3221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-3222
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-3223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-3224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，它接受一个测试分数的数组并返回平均分数。为了计算平均分，你需要将所有分数加起来，然后除以分数的总数。在你的playground中输入以下代码：
- en: '[PRE614]'
  id: totrans-3225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-3226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在➊处，我们定义了一个名为sum的Int类型变量，并将其初始值设置为0。➋处的for-in循环遍历scores数组中的每个值，并将其加到sum变量中。循环结束后，变量sum保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，也就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-3227
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办？你不能把某个东西除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除零错误并崩溃程序。因此，在进行除法时，始终确保你将要除以的数字不为零，这就是我们在➌处通过检查scores.count
    > 0来做到的。在➍处，我们通过使用return sum / scores.count来返回平均值，即将所有分数的总和除以数组中分数的数量。没错！你可以返回任何评估为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回sum
    / scores.count，因为它会评估为一个Int类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-3228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们还需要返回某个值，否则会出现缺少返回值的错误。我们通过在if语句中添加一个else来处理这个问题，返回值为0
    ➎。你可以通过传入一个分数组和一个空数组来测试这个代码：
- en: '![](Image00166.jpg)'
  id: totrans-3229
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-3230
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 `averageOf()` 函数时，就像我们在 ➊ 中所做的那样，返回的是分数的平均值，并显示在结果面板中。如果你传递一个空数组，就像我们在
    ➋ 中所做的那样，返回值是 0。
- en: '**NOTE**'
  id: totrans-3231
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-3232
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 `else` 语句其实不是必须的。这是因为如果 `scores.count > 0`，那么函数已经通过
    `return sum / scores.count` 结束了。所以如果程序已经执行到 `if` 语句之外，我们就知道 `scores.count > 0`
    这个条件没有成立，我们可以直接使用 `return 0`，而不需要把它包含在 `else` 语句中。不过，如果我们保留 `else` 语句，代码会更清晰、更易于理解。有时候，为了让别人更容易理解，写一点额外的代码比使用巧妙的简写更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-3233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-3234
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包增加了一个重要工具——创建并调用你自己的函数！函数在编程中被广泛使用，可以做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-3235
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建除了 Swift 内置类型之外的常量和变量，当你创建应用时，这将非常有用！
- en: '[PRE615]'
  id: totrans-3236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: 'The console output is:'
  id: totrans-3237
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出是：
- en: '[PRE616]'
  id: totrans-3238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-3239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，可以随时调用它，函数内部的代码就会执行。确保打开调试区域（⌘ -SHIFT -Y），如[图 7-1](text00017.html#ch07fig1)所示，这样你就能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-3240
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-3241
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-3242
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用 `printAHaiku()` 函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-3243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数可以做更多事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-3244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，你看到了函数如何节省时间和精力。当你编写一个函数时，可以在任何你想要的地方调用它，而无需在多个地方重复代码块。这肯定很酷，但函数的真正威力在于你传入一个或多个输入值来产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-3245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-3246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 `invite(guest:)` 的函数，它接受一个人的名字作为输入，并生成一个个性化的生日派对邀请函。将以下内容输入到你的 playground
    中：
- en: '[PRE617]'
  id: totrans-3247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-3248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数有输入参数，你需要将它包含在函数名后的括号中 ➊。你首先列出输入参数的名称（在本例中为 `guest`），然后是一个冒号（`:`），最后是它的数据类型（此处为
    `String`）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-3249
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，因此当你调用此函数时，`guest` 将作为参数标签。（你将在“[参数标签](text00017.html#ch07lev1sec4)”一节中学习如何定义单独的参数名和参数标签，[第
    89 页](text00017.html#page_89)）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-3250
  prefs: []
  type: TYPE_NORMAL
  zh: 在冒号后面写下输入参数的数据类型，就像声明变量时一样。然而，与变量声明不同，在定义函数参数时，你必须*始终*声明函数应该期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-3251
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-3252
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需像使用其他常量一样使用它的参数名 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-3253
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义函数并不够。现在函数已经定义好了，让我们在 playground 中调用它，看看会发生什么。你可以通过输入函数名，后跟括号内的参数标签、冒号和参数来调用一个带有输入参数的函数，如下所示：
- en: '[PRE618]'
  id: totrans-3254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-3255
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名来调用一个函数时，Xcode 的自动补全会提示你应该传递给函数的参数。在这个例子中，当你开始写 invite 时，你会看到一个下拉菜单，如[图7-2](text00017.html#ch07fig2)所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-3256
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-3257
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：Xcode 的自动补全会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-3258
  prefs: []
  type: TYPE_NORMAL
  zh: 按 ENTER 键自动完成函数。光标将移动到函数的括号内（见[图7-3](text00017.html#ch07fig3)），此时 Xcode 已自动添加了一些占位符文本，告诉你函数期望什么类型的输入。
- en: '![Image](Image00156.jpg)'
  id: totrans-3259
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-3260
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：Xcode 等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-3261
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-3262
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递给 invite(guest:) 的参数不是字符串类型，比如 invite(guest: 45)，你会遇到错误，因为这个函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-3263
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将 "Cathy" 或其他朋友的名字替换字符串部分，然后按 TAB 键完成函数调用的填写。它应该如下所示：[图7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-3264
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-3265
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-3266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，就调用 invite(guest:) 三次，使用你自己朋友的名字：
- en: '[PRE619]'
  id: totrans-3267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: 'The output looks like this:'
  id: totrans-3268
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE620]'
  id: totrans-3269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-3270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你可以迅速打印三张派对邀请函，每张都发送给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-3271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有你的朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-3272
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个一次性邀请所有朋友的函数，通过传入一个字符串数组作为参数，而不是单个字符串。在你编写了 invite(guest:) 的同一个 playground
    中，写下以下 invite(allGuests:) 函数来进行测试。请注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-3273
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE621]'
  id: totrans-3274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-3275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]位于方括号中 ➊。方括号声明数据类型为数组，而 String 则表示数组中元素的数据类型。通过使用[String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-3276
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们需要使用for-in循环遍历我们的客人数组，并为每个客人打印邀请函。记得我们刚才创建的那个打印邀请函的函数吗？我们在这里也可以使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本表示现有的行）：
- en: '[PRE622]'
  id: totrans-3277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-3278
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对字符串数组allGuests中的每个guest调用单数形式的invite(guest:)函数，邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟，它们的名字都是invite。然而，尽管名字相同，它们实际上是两个不同的函数，因为它们接受不同的输入参数。这是Swift中你将经常看到的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-3279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后我们将在函数调用中使用这个数组。
- en: '[PRE623]'
  id: totrans-3280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-3281
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组➊。然后我们用这个新数组作为函数的输入调用函数➋。这是你在调试控制台中看到的输出（-- snip --表示我们为了节省空间省略的行）：
- en: '[PRE624]'
  id: totrans-3282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-3283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友写出邀请函，那将是非常费力的。但借助函数的强大功能，你只需几行代码就完成了这一任务。试着创建你自己的朋友数组，长度可以任意！然后使用你的新数组作为输入，调用invite(allGuests:)函数。简直是小菜一碟！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-3284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-3285
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期快到了，但有些客人还没有回复RSVP。你希望得到最终的到场人数，并让客人们知道带上泳衣，因为这是一个滑水派对。你可以写一个函数，根据客人的RSVP状态给每个客人发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-3286
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-3287
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个字符串类型的参数表示客人的名字，另一个布尔类型的参数表示RSVP状态，值为true或false。请在你的playground中输入以下代码：
- en: '[PRE625]'
  id: totrans-3288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-3289
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号➊。每个参数都需要有一个参数名，后跟冒号和参数的数据类型。你可以创建一个接受任意多个输入参数的函数，且它们不必是相同的类型。在sendMessage(guest:rsvped:)函数中，我们传入一个字符串类型的guest和一个布尔类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-3290
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值，看看它是否为true➋，然后使用if-else语句打印相应的消息。请注意，函数定义中的最后打印语句无论rsvped值是true还是false都会执行，因为它们在if-else语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-3291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复了RSVP，他们将收到这条消息：
- en: '[PRE626]'
  id: totrans-3292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-3293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的通知，要求他们回复：
- en: '[PRE627]'
  id: totrans-3294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-3295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用该函数看看它是如何工作的。试着将一位客人的rsvped值设置为true，另一位客人的设置为false，这样你就能看到两个消息的实际效果。
- en: '[PRE628]'
  id: totrans-3296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-3297
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用具有多个输入参数的函数与调用只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-3298
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能会通过为你提供参数标签来帮助你填写输入值。你只需传入想要使用的值。填写完客人姓名后，按TAB键，Xcode会将光标移到你需要填写下一个输入值的位置。（参见[图7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-3299
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-3300
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：输入完客人姓名后按TAB键，光标会跳到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-3301
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你rsvped的数据类型。将占位符文本Bool替换为true或false。如果你尝试传入其他内容，如名称或数字，会出现错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-3302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-3303
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用print(_:)时，你并没有在输入值前加上参数标签？你写的是：
- en: '[PRE629]'
  id: totrans-3304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-3305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加一个标签，你会遇到错误：
- en: '[PRE630]'
  id: totrans-3306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-3307
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而一些没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且这个标签与参数名相同。然而，如果你编写函数时觉得参数标签对清晰代码没有帮助，那么你可以在函数定义中明确省略它。例如，在print(_:)函数中，很明显你传入的是一个将被打印的字符串。如果每次调用print(_:)时都需要加上像inputString这样的参数标签，显然会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-3308
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你可以通过在参数名称前输入参数标签、加上冒号、最后再写上参数的数据类型来实现。当你第一次在函数的括号内声明参数时，就可以进行这些操作。这样做通常在Swift函数中出现，使函数调用看起来更像一个完整的句子。[图7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-3309
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-3310
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：sayHello()函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-3311
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:)函数的输入参数是friend，参数标签是to，函数调用中传入的参数是"Colin"。如果没有单独的参数标签，调用该函数时就会像sayHello(friend:)，听起来就不太像一个完整的句子了。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-3312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-3313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-3314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，展示如何通过添加自定义的参数标签来使代码更易读。生日派对后，你会想向所有客人发送感谢信。在你的playground中编写以下函数：
- en: '[PRE631]'
  id: totrans-3315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-3316
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们为传入函数的guest参数添加了自定义的参数标签to。同样，在➋，我们为gift参数添加了参数标签for。参数名称guest ➌ 和gift
    ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-3317
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for在函数调用时用来标记参数，像这样：
- en: '[PRE632]'
  id: totrans-3318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-3319
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，to:写在函数调用中的第一个输入值之前，for:写在第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用中使用它。否则，尝试使用参数名称会导致错误：
- en: '[PRE633]'
  id: totrans-3320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-3321
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全会为你填充参数标签，因此你不必担心错误地调用函数（参见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-3322
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-3323
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动完成函数并正确添加参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-3324
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于向客人*发送*感谢信*以表谢意*。代码sendThankYou(to:
    "Meghan", for: "puzzle books")更像一个句子，而不是sendThankYou(guest: "Meghan", gift: "puzzle
    books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-3325
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-3326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-3327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线和一个空格来移除它们。在下面的例子中，我们编写了一个计算体积的函数，它以盒子的三个边长为输入。由于函数名称已经清楚地说明了需要传入三个边长，因此你实际上不需要参数标签来使代码更易读。
- en: '[PRE634]'
  id: totrans-3328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-3329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在side1前面加上下划线（➊），在side2前面加上下划线（➋），以及在side3前面加上下划线（➌）来移除侧面的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-3330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需要输入参数值，而不需要任何标签。
- en: '[PRE635]'
  id: totrans-3331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-3332
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。” 如果你能够将结果存储到一个变量或常量中，稍后再使用，而不仅仅是将盒子体积打印出来，那岂不是很有用？让我们来看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-3333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-3334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-3335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-3336
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能装更多的东西。首先，编写一个volumeOfBox(_:_:_:)函数，返回一个整数，表示盒子的体积：
- en: '[PRE636]'
  id: totrans-3337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-3338
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数返回一个值，使用一个破折号和一个大于符号来形成箭头 (`->`) ，并紧接着输入返回值的数据类型，位于输入参数之后 ➊。请注意，你不需要为返回值提供名称，只需要指定数据类型。在函数体内，你通过使用
    `return` 关键字并紧跟着你要返回的值来返回该值 ➋。如果你写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值后结束。如果你在
    `return` 语句后写了任何代码，它将被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-3339
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-3340
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个函数并用两个不同的盒子来查看它的效果：
- en: '![](Image00165.jpg)'
  id: totrans-3341
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-3342
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算一个长宽高分别为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 `volumeOfBox1`
    的常量中。在 ➋ 处，长宽高为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在，让我们打印一条消息，说明哪个盒子更大：
- en: '[PRE637]'
  id: totrans-3343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-3344
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-3345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-3346
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。我们来写一个函数，它接受一个成绩数组并返回平均成绩。为了获得平均值，你将所有成绩加起来，然后除以成绩的总数。将以下代码输入到你的
    playground 中：
- en: '[PRE638]'
  id: totrans-3347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-3348
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有数值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 类型变量，并将其初始值设为 0。位于 ➋ 处的 for-in
    循环遍历 `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量保存了所有成绩的总和。在计算完总和后，剩下的就是将其除以成绩的总数，简单来说就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-3349
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空呢？你不能用零来除——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并使程序崩溃。因此，在进行除法运算时，始终确保你要除的数不为零，这就是我们通过检查
    `scores.count > 0` 在 ➌ 处所做的。当在 ➍ 处，我们通过将成绩总和除以数组中成绩的数量来返回平均值，使用 `return sum /
    scores.count`。没错！你可以返回任何计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 `sum /
    scores.count`，因为它会计算出一个 `Int` 类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-3350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一些东西，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加一个 else
    来处理这一点，返回值为 0 ➎。你可以通过在一个包含成绩的数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-3351
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-3352
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给averageOf()函数时，如➊所示，成绩的平均值会被返回并显示在结果面板中。如果你传递一个空数组，如➋所示，返回值为0。
- en: '**NOTE**'
  id: totrans-3353
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-3354
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的else语句其实并不必要。这是因为如果scores.count > 0，那么函数已经通过return sum
    / scores.count提前结束了。所以如果计算机已经跳过了那个if语句，那么我们就知道scores.count > 0一定不成立，我们可以直接写return
    0而不需要把它放在else语句中。然而，如果我们保留else语句，代码会更清晰，更容易理解。有时候，为了让别人更容易理解，写一些额外的代码比使用巧妙的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-3355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-3356
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种了不起的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-3357
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让你使用除了Swift中已包含的类型之外的常量和变量类型，这在你创建应用程序时会非常有用！
- en: 'The console output is:'
  id: totrans-3358
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出为：
- en: '[PRE639]'
  id: totrans-3359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-3360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数中的代码将会执行。确保你已经打开调试区域（⌘ -SHIFT -Y），如[图 7-1](text00017.html#ch07fig1)所示，这样你就能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-3361
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-3362
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-3363
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用printAHaiku()函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-3364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数实现更多功能**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-3365
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，你看到了函数如何为你节省时间和精力。当你编写一个函数时，你可以在任何地方调用它，而不必在多个地方重复代码块。这当然很酷，但函数的真正强大之处在于，当你传递一个或多个输入值时，能够产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-3366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-3367
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为invite(guest:)的函数，它接受一个人的名字作为输入，并创建一个个性化的生日派对邀请函。请在你的playground中输入以下内容：
- en: '[PRE640]'
  id: totrans-3368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-3369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将其包含在函数名后面的括号内➊。你首先写上输入参数的名称（在这个例子中是guest），然后是冒号（:），最后是它的数据类型（在此例中是String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-3370
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，因此当你调用这个函数时，guest将是参数标签。（你将学习如何在“[参数标签](text00017.html#ch07lev1sec4)”中定义单独的参数名和参数标签，见[第89页](text00017.html#page_89)
    。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-3371
  prefs: []
  type: TYPE_NORMAL
  zh: 你在输入参数后面使用冒号写下数据类型，就像声明变量一样。然而，与变量声明不同，在定义函数参数时，你必须*始终*声明函数应该期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-3372
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-3373
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内使用输入参数，你只需要使用它的参数名，就像使用任何其他常量一样 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-3374
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数还不够。现在函数已经定义了，我们来调用它，看看会发生什么。你可以通过输入函数名称，后面跟上括号中的参数标签、冒号和参数来调用一个有输入参数的函数，像这样：
- en: '[PRE641]'
  id: totrans-3375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-3376
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名称来调用函数时，Xcode的自动完成会给你提示，告诉你应该传递什么内容给函数。在这个例子中，当你开始写`invite`时，你会看到像[图7-2](text00017.html#ch07fig2)中的下拉菜单。
- en: '![Image](Image00155.jpg)'
  id: totrans-3377
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-3378
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：Xcode的自动完成会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-3379
  prefs: []
  type: TYPE_NORMAL
  zh: 按下ENTER键以自动完成函数。你的光标将移到函数的括号内（见[图7-3](text00017.html#ch07fig3)），此时Xcode已经自动添加了一些占位符文本，告诉你函数期望输入什么类型的内容。
- en: '![Image](Image00156.jpg)'
  id: totrans-3380
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-3381
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：Xcode正在等待你填写guest参数。*'
- en: '**NOTE**'
  id: totrans-3382
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-3383
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递一个不是字符串的东西给`invite(guest:)`，比如`invite(guest: 45)`，你会得到一个错误，因为这个函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-3384
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在String的位置输入“Cathy”或另一个朋友的名字，然后按TAB键完成函数调用。它应该像[图7-4](text00017.html#ch07fig4)那样。
- en: '![Image](Image00157.jpg)'
  id: totrans-3385
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-3386
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：一个`invite(guest:)`函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-3387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用，接下来使用你自己朋友的名字，调用`invite(guest:)`三次：
- en: '[PRE642]'
  id: totrans-3388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: 'The output looks like this:'
  id: totrans-3389
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE643]'
  id: totrans-3390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-3391
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的`invite(guest:)`函数，你能够快速打印三张派对邀请函，每一张都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-3392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-3393
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过传递一个字符串数组作为参数来一次性邀请所有朋友，而不是传递单个字符串。在你写了`invite(guest:)`的同一个playground中，写下以下`invite(allGuests:)`函数来进行测试。注意，参数名称现在是复数形式，因为我们将一次邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-3394
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE644]'
  id: totrans-3395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-3396
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到`[String]`在方括号中 ➊。方括号声明数据类型为数组，而`String`表示数组中值的数据类型。通过使用`[String]`，我们声明该函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-3397
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `invite(allGuests:)` 函数内部，我们需要使用一个 for-in 循环遍历我们的 guest 数组，并为每个客人打印一份邀请函。还记得我们刚刚创建了一个打印邀请函的函数吗？我们在这里就可以使用它！将以下代码添加到你的
    `invite(allGuests:)` 函数中（灰色文本表示已有的代码）：
- en: '[PRE645]'
  id: totrans-3398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-3399
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们对 `String` 数组 `allGuests` 中的每个 guest 调用单一的 `invite(guest:)`
    函数，以邀请每位客人参加生日派对。你可能会想，`invite(guest:)` 和 `invite(allGuests:)` 是不是同一个函数。毕竟，它们的名字都是
    `invite`。然而，尽管名字相同，它们是两个不同的函数，因为它们接受不同的输入参数。这是 Swift 中常见的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-3400
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `invite(allGuests:)` 函数，我们首先创建一个名为 `friends` 的数组，然后在函数调用中使用这个数组。
- en: '[PRE646]'
  id: totrans-3401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-3402
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个包含六个朋友的数组 ➊。然后我们使用这个新数组作为输入，调用函数 ➋。这是你在调试控制台中看到的输出（-- snip -- 表示我们为了节省空间省略的代码行）：
- en: '[PRE647]'
  id: totrans-3403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-3404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友单独写邀请函，那将是一个庞大的工作量。但借助函数的强大功能，你只需要写几行代码就能完成。试着创建你自己的朋友数组；让它尽可能长！然后用你的新数组作为输入，调用
    `invite(allGuests:)` 函数。简直轻而易举！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-3405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-3406
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，派对的日期越来越近，而一些客人还没有 RSVP。你希望得到最终的出席人数，并提醒客人们带上泳衣，因为这是一个滑水派对。你可以编写一个函数，根据他们的
    RSVP 状态向每个客人发送个性化的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-3407
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-3408
  prefs: []
  type: TYPE_NORMAL
  zh: 你新创建的函数将接受两个输入参数：一个 `String` 类型的参数表示客人的名字，另一个 `Bool` 类型的参数表示 RSVP 状态，它的值可以是
    true 或 false。在你的 Playground 中输入以下代码：
- en: '[PRE648]'
  id: totrans-3409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-3410
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数都需要有一个参数名，后面跟上冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，且这些参数不必是相同类型的。在
    `sendMessage(guest:rsvped:)` 函数中，我们传入一个 `String` 类型的 guest 和一个 `Bool` 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-3411
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 `rsvped` 的值是否为 true ➋，然后使用 if-else 语句打印相应的消息。还要注意，函数定义中的最终 `print`
    语句无论 `rsvped` 值是 true 还是 false 都会执行，因为它们在 if-else 语句的括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-3412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经 RSVP，他们会收到这个消息：
- en: '[PRE649]'
  id: totrans-3413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-3414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一封礼貌的提醒，请他们回复：
- en: '[PRE650]'
  id: totrans-3415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-3416
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一位客人的 RSVPed 值设置为 true，另一位客人的设置为 false，这样你就能看到两个消息的效果。
- en: '[PRE651]'
  id: totrans-3417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-3418
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个具有多个输入参数的函数，与调用一个只有一个输入参数的函数非常相似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-3419
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会帮助你填写输入值，并为你提供参数标签。你需要做的就是传入你想要使用的值。填写完客人姓名后，按 TAB 键，Xcode 会将光标移到下一个输入值的位置。（见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-3420
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-3421
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按 TAB 键，光标会跳到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-3422
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他任何东西，比如名字或数字，你会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-3423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-3424
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到没有，当你调用 print(_:) 时，你没有在输入值前加上参数标签吗？你只是写：
- en: '[PRE652]'
  id: totrans-3425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-3426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你会遇到错误：
- en: '[PRE653]'
  id: totrans-3427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-3428
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中会有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，而且该标签与参数名相同。然而，如果你编写一个函数，并且觉得参数标签对于代码的清晰性不是必需的，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，传入的内容显然是一个字符串，并且该字符串会被打印。如果每次调用 print(_:) 时都必须包含像 inputString 这样的参数标签，那将会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-3429
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个不同于参数名的参数标签。你可以通过输入参数标签、参数名、冒号，然后是参数的数据类型来实现。所有这些操作都在你首次声明函数括号中的参数时完成，这时会跟随在`func`关键字之后。这通常在Swift函数中进行，以使函数调用看起来更像一句完整的句子。[图
    7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-3430
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-3431
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello()函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-3432
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果你没有单独的参数标签，那么函数调用看起来会是
    sayHello(friend:)，这听起来不像一句完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-3433
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将探讨如何使用自定义参数标签来编写函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-3434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-3435
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，说明如何通过添加自定义参数标签让你的代码更具可读性。比如，在你举办完生日派对后，你会想给所有的客人发送感谢信。请在你的 Playground
    中编写以下函数：
- en: '[PRE654]'
  id: totrans-3436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-3437
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了自定义参数标签“to”。类似地，在 ➋ 处，我们为 gift 参数添加了“for”标签。参数名称
    guest ➌ 和 gift ➍ 用于函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-3438
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签“to”和“for”用于在调用函数时标记参数，像这样：
- en: '[PRE655]'
  id: totrans-3439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-3440
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到“to:”出现在第一个输入值之前，而“for:”则出现在第二个输入值之前。如果参数有自定义的标签，你必须在函数调用时使用它。尝试使用参数名称代替会导致错误：
- en: '[PRE656]'
  id: totrans-3441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-3442
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填充参数标签，所以你无需担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-3443
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-3444
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成函数并使用正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-3445
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信 *to* 一个客人 *for*
    一份礼物。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 看起来更像一句话，而不是 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-3446
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-3447
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-3448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加上下划线和一个空格来移除它们。在以下示例中，我们编写了一个计算体积的函数，该函数接受一个盒子的三个边长作为输入。由于函数名称已经明确表示需要传入三个边长，所以你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE657]'
  id: totrans-3449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-3450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处的 side1、➋ 处的 side2 和 ➌ 处的 side3 前面加上下划线来移除这些参数的标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-3451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值而无需标签。
- en: '[PRE658]'
  id: totrans-3452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-3453
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。” 但如果你能够将结果存储在变量或常量中，供以后使用，而不是仅仅打印盒子的体积，那该多好？让我们来看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-3454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-3455
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使它返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-3456
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-3457
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多东西。首先，编写一个返回盒子体积的 `volumeOfBox(_:_:_:)` 函数：
- en: '[PRE659]'
  id: totrans-3458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-3459
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数指定返回值，在函数的输入参数后使用一个箭头符号（-> ）并指定返回值的数据类型。注意，你不需要为返回值指定名称，只需给出数据类型即可。在函数体内，你通过使用
    `return` 关键字并跟上你要返回的值来返回结果 ➋ 。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在你返回值后结束。如果在返回语句之后写任何代码，它将会被忽略，因为
    `return` 会使函数退出。
- en: '![Image](Image00164.jpg)'
  id: totrans-3460
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-3461
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个函数在两个不同的盒子上查看其效果：
- en: '![](Image00165.jpg)'
  id: totrans-3462
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-3463
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个边长为 6 、 5 和 3 的盒子的体积，并将返回值 90 存储在常量 `volumeOfBox1`
    中。在 ➋ 处，边长为 8 、 4 和 2 的 `volumeOfBox2` 被赋值为 64 。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE660]'
  id: totrans-3464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-3465
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-3466
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-3467
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，该函数接受一个成绩数组并返回平均成绩。为了计算平均值，你需要将所有成绩相加，然后除以总的成绩数。请在你的代码实验区中输入以下代码：
- en: '[PRE661]'
  id: totrans-3468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-3469
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的整数变量，并将其初始化为 0 。在 ➋ 处的 `for-in` 循环遍历
    `scores` 数组中的每个值，并将其添加到 `sum` 变量中。当循环完成时，`sum` 变量保存了所有成绩的总和。计算出总和后，剩下的就是将其除以总成绩数，即
    `scores.count` 。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-3470
  prefs: []
  type: TYPE_NORMAL
  zh: 可是，如果数组为空呢？你不能用零去除以任何数字——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致一个除零错误并崩溃你的程序。因此，在进行除法时，务必确保你要除的数字不是零，这也是我们通过在
    ➌ 处检查 `scores.count > 0` 来做到的。然后，在 ➍ 处，我们通过将成绩的总和除以数组中成绩的数量来返回平均值，使用 `return sum
    / scores.count` 。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 `sum
    / scores.count` ，因为它的计算结果是一个整数（Int）。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-3471
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 `scores.count` 不大于零时返回某个值，否则我们会遇到函数缺少返回值的错误。我们通过在 `if` 语句后添加 `else`
    来处理这个问题，使其返回 0 ➎ 。你可以通过将函数应用于一个包含成绩的数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-3472
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-3473
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试成绩数组传递给averageOf()函数时，如我们在➊所做的，函数会返回并显示这些成绩的平均值。如果你传递一个空数组，如我们在➋所做的，返回值是0。
- en: '**NOTE**'
  id: totrans-3474
  prefs: []
  type: TYPE_NORMAL
  zh: '**备注**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-3475
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0周围的else语句其实并不是必须的。因为如果scores.count > 0，那么函数已经通过return sum /
    scores.count结束了。所以如果计算机已经通过了那个if语句，我们就知道scores.count > 0肯定不成立，我们可以直接写return 0，而不需要放在else语句中。然而，如果我们保留else语句，代码会更清晰，更容易理解。有时候写一些多余的代码，能让别人更容易理解，而不是用一个复杂的捷径。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-3476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-3477
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要的工具——创建并调用你自己的函数！函数在编程中被广泛使用，能做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-3478
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建具有Swift中未包含的类型的常量和变量，在你创建应用程序时将非常有用！
- en: '[PRE662]'
  id: totrans-3479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-3480
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以随时调用它，函数中的代码就会运行。确保调试区域是打开的（⌘ -SHIFT -Y），如[图7-1](text00017.html#ch07fig1)所示，这样你才能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-3481
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-3482
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-3483
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用printAHaiku()函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-3484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数做更多事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-3485
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，你看到函数如何节省你的时间和精力。当你编写一个函数时，你可以在任何地方调用它，而不需要在多个地方重复代码块。这当然很酷，但函数的真正强大之处在于你传递一个或多个输入值，以产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-3486
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-3487
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为invite(guest:)的函数，它接受一个人的名字作为输入，并创建一个个性化的生日派对邀请函。在你的游乐场中输入以下内容：
- en: '[PRE663]'
  id: totrans-3488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-3489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要把它放在函数名后的括号中 ➊ 。你先写输入参数的名称（在这个例子中是guest），然后是冒号（:），最后是数据类型（在这个例子中是String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-3490
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，因此guest将在你调用此函数时作为参数标签。（你将在“[参数标签](text00017.html#ch07lev1sec4)”中学习如何定义单独的参数名和参数标签，详见[第89页](text00017.html#page_89)。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-3491
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后面写输入参数的数据类型，就像声明一个变量时一样。然而，与变量声明不同的是，在定义函数参数时，你必须*始终*声明函数应该接受的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-3492
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-3493
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需使用其参数名称，就像使用任何其他常量一样 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-3494
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅定义一个函数是不够的。现在函数已经定义好，让我们在 playground 中调用它，看看会发生什么。你可以通过输入函数名，后跟括号内的参数标签、冒号和参数，来调用带有输入参数的函数，像这样：
- en: '[PRE664]'
  id: totrans-3495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-3496
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名来调用一个函数时，Xcode 的自动补全会给你提示，告诉你应该传入什么参数。在这种情况下，当你开始写 invite 时，你会看到一个下拉菜单，就像
    [图 7-2](text00017.html#ch07fig2) 中的那样。
- en: '![Image](Image00155.jpg)'
  id: totrans-3497
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-3498
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动补全会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-3499
  prefs: []
  type: TYPE_NORMAL
  zh: 按 ENTER 键自动完成函数。你的光标将移动到函数的括号内（参见 [图 7-3](text00017.html#ch07fig3)），此时 Xcode
    已自动添加了一些占位符文本，告诉你函数期待的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-3500
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-3501
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-3502
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-3503
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传入不是字符串的东西，比如 invite(guest: 45)，你会得到一个错误，因为函数期待一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-3504
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 位置输入 "Cathy" 或其他朋友的名字，然后按 TAB 键完成函数调用的填写。它应该看起来像 [图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-3505
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-3506
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-3507
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了如何填写函数调用，调用 invite(guest:) 三次，使用你自己朋友的名字：
- en: '[PRE665]'
  id: totrans-3508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: 'The output looks like this:'
  id: totrans-3509
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来是这样的：
- en: '[PRE666]'
  id: totrans-3510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-3511
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你能够快速打印出三份聚会邀请函，每份都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-3512
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次邀请所有你的朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-3513
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过传入一个字符串数组作为参数，而不是单个字符串，来写一个一次邀请所有朋友的函数。在你写 invite(guest:) 的同一个 playground
    中，写下以下 invite(allGuests:) 函数来进行测试。注意，现在参数名称是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-3514
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE667]'
  id: totrans-3515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-3516
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到 [String] 被放在方括号中 ➊。方括号声明数据类型为数组，而 String 表示数组中值的数据类型。通过使用
    [String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-3517
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们将使用for-in循环遍历我们的guest数组，并为每个客人打印一张邀请函。记得我们刚刚创建了一个打印邀请函的函数吗？让我们在这里使用它！将以下代码添加到你的invite(allGuests:)函数中（灰色文本显示现有的行）：
- en: '[PRE668]'
  id: totrans-3518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-3519
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个guest调用单独的invite(guest:)函数，邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟，它们的名字都是invite。尽管名字相同，但它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中常见的一个模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-3520
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE669]'
  id: totrans-3521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-3522
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后，我们使用这个新数组作为函数的输入调用函数 ➋ 。这是你在调试控制台中看到的输出（-- snip --表示我们为了节省空间省略的行）：
- en: '[PRE670]'
  id: totrans-3523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-3524
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每一个朋友写邀请函，那将需要大量工作。但凭借函数的强大功能，你只需用很少的代码行就完成了这项任务。试着创建你自己的朋友数组；你可以让它尽可能长！然后使用你的新数组作为输入，调用invite(allGuests:)函数。简直不费吹灰之力！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-3525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发送信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-3526
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，派对的日期临近，但有些客人还没有回复RSVP。你想要得到最终的客人数量，并提醒客人带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据每个客人的RSVP状态向他们发送定制消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-3527
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-3528
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个String类型的参数用于表示客人的名字，一个Bool类型的参数表示RSVP状态，值为true或false。请在你的playground中输入以下代码：
- en: '[PRE671]'
  id: totrans-3529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-3530
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊ 。每个参数都需要有一个参数名，后跟冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，它们不必是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传入了一个String类型的guest参数和一个Bool类型的rsvped参数。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-3531
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped的值，看看它是否为true ➋，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最终打印语句无论rsvped值为true还是false都会执行，因为它们在if-else语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-3532
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复RSVP，他们将收到此信息：
- en: '[PRE672]'
  id: totrans-3533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-3534
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有回复，他们会收到一封礼貌的通知，要求他们做出回应：
- en: '[PRE673]'
  id: totrans-3535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-3536
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一个来宾的 rsvped 值设置为 true，另一个来宾的设置为 false，这样你就可以看到两条消息的实际效果。
- en: '[PRE674]'
  id: totrans-3537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-3538
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个具有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-3539
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会帮助你填写输入值，并为你提供参数标签。你只需传入你想使用的值。填写完来宾姓名后，按 TAB 键，Xcode 会将光标放到你需要填写下一个输入值的位置。（见[图
    7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-3540
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-3541
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入来宾姓名后按 TAB 键会将光标移动到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-3542
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，你将会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-3543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-3544
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，你并不会在输入值前加上参数标签？你写的是：
- en: '[PRE675]'
  id: totrans-3545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-3546
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你将会遇到错误：
- en: '[PRE676]'
  id: totrans-3547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-3548
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它与参数名称相同。然而，如果你编写一个函数时，认为参数标签对于使代码更加清晰不是必须的，那么你可以在函数定义中显式省略它。例如，在
    print(_:) 函数中，显而易见你传入的输入是一个要打印的字符串。如果每次调用 print(_:) 都要包括像 inputString 这样的参数标签，那将会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-3549
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你通过输入参数标签、参数名称、冒号以及最后的参数数据类型来实现这一点。你在声明函数参数时就要做这些操作，即在
    func 关键字后面的函数括号内首次声明参数时。这通常在 Swift 函数中完成，使得函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6)
    展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-3550
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-3551
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-3552
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，那么你调用函数时会是
    sayHello(friend:)，这听起来就不太像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-3553
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何编写带有自定义参数标签的函数。我们还会向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-3554
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-3555
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，说明添加自定义参数标签如何使代码更具可读性。在你的生日派对之后，你会想给所有的客人发送感谢信。在你的 playground 中编写以下函数：
- en: '[PRE677]'
  id: totrans-3556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-3557
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了一个自定义的参数标签 `to`。类似地，在 ➋ 处，我们为 gift 参数添加了一个参数标签 `for`。参数名称
    guest ➌ 和 gift ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-3558
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 `to` 和 `for` 用于标记函数调用时的参数，如下所示：
- en: '[PRE678]'
  id: totrans-3559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-3560
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `to:` 在函数调用中位于第一个输入值之前，而 `for:` 则位于第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名称代替会导致错误：
- en: '[PRE679]'
  id: totrans-3561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-3562
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会自动为你填写参数标签，因此你无需担心错误地调用函数（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-3563
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-3564
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全函数并为其添加正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-3565
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于将感谢信 *送给* 客人 *以感谢* 礼物。代码
    `sendThankYou(to: "Meghan", for: "puzzle books")` 更像一句话，而不是 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-3566
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-3567
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-3568
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线并跟一个空格来移除它们。在下面的例子中，我们编写了一个计算体积的函数，接受盒子的三个边长作为输入。由于函数名称已经清楚表明需要传入三个边长，因此不需要参数标签来提高代码可读性。
- en: '[PRE680]'
  id: totrans-3569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-3570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处在 `side1` 前添加下划线，在 ➋ 处在 `side2` 前添加下划线，在 ➌ 处在 `side3` 前添加下划线来移除这些边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-3571
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你调用函数时，你只需输入参数值，而无需任何标签。
- en: '[PRE681]'
  id: totrans-3572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-3573
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出 “这个盒子的体积是 72。” 如果你不仅仅是想打印盒子的体积，而是想将结果存储在变量或常量中以供以后使用，岂不是更有用吗？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-3574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-3575
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-3576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-3577
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个能装下更多的东西。首先，编写一个 `volumeOfBox(_:_:_:)` 函数，返回一个整数表示盒子的体积：
- en: '[PRE682]'
  id: totrans-3578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-3579
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数一个返回值，使用一个短横线和一个大于号组成箭头 (->)，紧跟在函数的输入参数后面 ➊，然后输入返回值的数据类型。请注意，你不需要为返回值提供一个名称，只需要一个数据类型。在函数体内，你通过使用
    `return` 关键字后跟要返回的值来返回结果 ➋。如果你写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在你返回值后结束。如果你在
    `return` 语句后面写任何代码，它将被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-3580
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-3581
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的箱子上调用函数，查看它的实际效果：
- en: '![](Image00165.jpg)'
  id: totrans-3582
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-3583
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个边长分别为 6、5 和 3 的箱子的体积，返回值 90 被存储在一个常量 `volumeOfBox1`
    中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在，让我们打印一条消息，说明哪个箱子更大：
- en: '[PRE683]'
  id: totrans-3584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-3585
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-3586
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-3587
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据条件返回不同的值。让我们写一个函数，接受一个考试成绩数组并返回平均分数。要获得平均分，首先将所有分数相加，再除以总的分数数目。在你的 Playground
    中输入以下代码：
- en: '[PRE684]'
  id: totrans-3588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-3589
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始值设置为 0。第 ➋ 处的 for-in 循环遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量中。循环完成后，`sum` 变量就保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总个数，简单地就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-3590
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能用零去除以什么——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试用零除数会给你一个“除以零”错误，并导致程序崩溃。因此，在进行除法时，一定要确保你要除的数字不是零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来做的。在 ➍ 处，我们通过用 `return sum / scores.count` 将分数总和除以数组中的分数个数来返回平均值。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算得到的平均值赋给新变量的步骤，直接返回
    `sum / scores.count`，因为它会计算出一个 `Int` 类型的结果。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-3591
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一些内容，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加一个 else
    来处理这个问题，返回 0 ➎。你可以通过在一个分数数组和一个空数组上调用函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-3592
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-3593
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 averageOf() 函数时，正如我们在 ➊ 处所做的，返回的是分数的平均值，并显示在结果面板中。如果你传递一个空数组，如我们在
    ➋ 处所做的，返回值将是 0。
- en: '**NOTE**'
  id: totrans-3594
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-3595
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句实际上并不是必须的。因为如果 scores.count > 0，那么函数会已经通过 return
    sum / scores.count 结束。如果计算机已经通过了那个 if 语句，那么我们就知道 scores.count > 0 肯定不成立，我们完全可以直接返回
    0，而无需将其放在 else 中。然而，如果我们保留 else 语句，代码会更清晰，也更容易理解。有时候，写一点额外的代码使其对其他人更清晰，比使用一个巧妙的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-3596
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-3597
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为自己的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种各样神奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-3598
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让你使用除 Swift 已有类型外的其他类型来创建常量和变量，这在你创建应用程序时会非常有用！
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  id: totrans-3599
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了这个函数，你可以在任何时候调用它，函数内部的代码将会执行。确保你打开了调试区域（⌘ -SHIFT -Y），如[图7-1](text00017.html#ch07fig1)所示，这样你就能看到结果。
- en: '![Image](Image00153.jpg)'
  id: totrans-3600
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-3601
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-3602
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用 printAHaiku() 函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-3603
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数在处理输入参数时还能做更多的事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-3604
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，你看到了函数如何节省你的时间和精力。当你编写一个函数时，你可以在任何地方调用它，而不必在多个地方重复代码块。这无疑很酷，但函数的真正威力在于你可以传入一个或多个输入值，生成不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-3605
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-3606
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个名为 invite(guest:) 的函数，该函数以一个人的名字作为输入，并创建一个个性化的生日派对邀请函。将以下代码输入到你的 Playground
    中：
- en: '[PRE685]'
  id: totrans-3607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-3608
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你会将其放在函数名后的括号内 ➊。你在括号内格式化输入参数，首先是它的名称（在这个例子中是 guest），然后是一个冒号（:），最后是它的数据类型（在此例中是
    String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-3609
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名称也充当参数标签，因此在调用此函数时，guest 将作为参数标签。（你将在《[参数标签](text00017.html#ch07lev1sec4)》一章的[第89页](text00017.html#page_89)中学到如何定义独立的参数名称和参数标签。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-3610
  prefs: []
  type: TYPE_NORMAL
  zh: 你在输入参数后面写数据类型，就像声明变量时一样。然而，与变量声明不同，定义函数参数时，必须*始终*声明函数应该接收的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-3611
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-3612
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，只需像使用任何其他常量一样使用它的参数名称 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-3613
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数并不足够。现在函数已经定义好了，我们来在playground中调用它，看看会发生什么。你可以通过输入函数名，然后在括号中输入参数标签、冒号和参数来调用一个带有输入参数的函数，就像这样：
- en: '[PRE686]'
  id: totrans-3614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-3615
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写出函数名来调用函数时，Xcode的自动完成功能会给你一个提示，告诉你应该传入什么内容。在这种情况下，当你开始写invite时，你会看到一个下拉菜单，就像在[图
    7-2](text00017.html#ch07fig2)中那样。
- en: '![Image](Image00155.jpg)'
  id: totrans-3616
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-3617
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成功能将展示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-3618
  prefs: []
  type: TYPE_NORMAL
  zh: 按下ENTER键以自动完成函数。光标会移动到函数的括号内（见[图 7-3](text00017.html#ch07fig3)），此时Xcode会自动添加一些占位符文本，告诉你函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-3619
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-3620
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-3621
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-3622
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传入的不是字符串，比如传入invite(guest: 45)，你会收到错误提示，因为这个函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-3623
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在String的位置输入“Cathy”或另一个朋友的名字，然后按TAB键完成函数调用。它应该看起来像[图 7-4](text00017.html#ch07fig4)那样。
- en: '![Image](Image00157.jpg)'
  id: totrans-3624
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-3625
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一次性邀请所有客人（guest:）的函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-3626
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，就使用你自己朋友的名字调用invite(guest:)三次：
- en: '[PRE687]'
  id: totrans-3627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: 'The output looks like this:'
  id: totrans-3628
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下所示：
- en: '[PRE688]'
  id: totrans-3629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-3630
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你能够快速打印出三张派对邀请函，每张都发给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-3631
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-3632
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过传入一个字符串数组作为参数，而不是单个字符串，来编写一个一次性邀请所有朋友的函数。在你编写了invite(guest:)函数的同一个playground中，编写以下invite(allGuests:)函数进行测试。请注意，参数名称现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-3633
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE689]'
  id: totrans-3634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-3635
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当你声明函数的参数时，你会注意到[String]被放在方括号中 ➊。方括号声明数据类型为数组，而String表示数组中值的数据类型。通过使用[String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-3636
  prefs: []
  type: TYPE_NORMAL
  zh: 在`invite(allGuests:)`函数内部，我们将使用一个for-in循环遍历我们的客人数组，并为每位客人打印邀请函。还记得我们刚刚创建的打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到`invite(allGuests:)`函数中（灰色文本显示了现有行）：
- en: '[PRE690]'
  id: totrans-3637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-3638
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对`String`数组`allGuests`中的每个客人调用单一的`invite(guest:)`函数，以邀请每个人参加生日派对。你可能会想知道`invite(guest:)`和`invite(allGuests:)`是不是同一个函数。毕竟，它们的名称都是`invite`。然而，尽管它们共享一个名字，它们实际上是两个不同的函数，因为它们接收不同的输入参数。这是你在Swift中经常会看到的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-3639
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`invite(allGuests:)`函数，我们首先创建一个名为`friends`的数组，然后在函数调用中使用它。
- en: '[PRE691]'
  id: totrans-3640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-3641
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组➊。然后我们将新数组作为函数的输入调用该函数➋。这是你将在调试控制台中看到的输出（-- snip --显示了我们为节省空间而省略的行）：
- en: '[PRE692]'
  id: totrans-3642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-3643
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为每个朋友写出邀请函，那将需要花费大量的工作。但通过函数的强大功能，你只需少量的代码就能完成这一切。试着创建你自己的朋友数组；长度随你所愿！然后调用`invite(allGuests:)`函数，输入你新创建的数组。真是轻而易举！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-3644
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-3645
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期即将来临，而一些客人还没有RSVP。你需要最终确认人数，并提醒客人带上泳衣，因为派对将会有滑水道活动。你可以编写一个函数，根据客人的RSVP状态向每个客人发送自定义消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-3646
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-3647
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个`String`类型的参数表示客人的名字，另一个是`Bool`类型的参数表示RSVP状态，值为`true`或`false`。在你的playground中输入以下代码：
- en: '[PRE693]'
  id: totrans-3648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-3649
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号➊。每个参数需要有一个参数名，后跟冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，这些参数类型可以不相同。在`sendMessage(guest:rsvped:)`函数中，我们传递了一个`String`类型的`guest`和一个`Bool`类型的`rsvped`。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-3650
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查`rsvped`值是否为真➋，然后使用if-else语句打印相应的消息。请注意，函数定义中的最后几行打印语句会在`rsvped`值为真或假的情况下都执行，因为它们位于if-else语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-3651
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已确认参加，他们将收到这个消息：
- en: '[PRE694]'
  id: totrans-3652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-3653
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提示，要求他们做出回应：
- en: '[PRE695]'
  id: totrans-3654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-3655
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一个客人的rsvped值设为true，另一个客人的设为false，这样你就可以看到两个消息的实际效果。
- en: '[PRE696]'
  id: totrans-3656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-3657
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数，类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-3658
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能将帮助你填写输入值，并为你提供参数标签。你只需要传入你想要的值即可。在填写完客人姓名后，按TAB键，Xcode会将光标移到你需要填写下一个输入值的位置。（参见[图7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-3659
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-3660
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：输入客人姓名后按TAB键，光标将跳到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-3661
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你rsvped的数据类型。将占位符文本Bool替换为true或false。如果你尝试传入其他内容，比如名字或数字，将会出现错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-3662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-3663
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用print(_:)时，输入值前面没有参数标签吗？你是这样写的：
- en: '[PRE697]'
  id: totrans-3664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-3665
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，将会出现错误：
- en: '[PRE698]'
  id: totrans-3666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-3667
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，且该标签与参数名称相同。然而，如果你编写函数时觉得参数标签不必要，无法使代码更清晰，你可以在函数定义中显式省略它。例如，在print(_:)函数中，很明显你传入的是一个将要打印的字符串。如果每次调用print(_:)都要包含像inputString这样的参数标签，那就显得很麻烦了。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-3668
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。所有这些操作都在你第一次声明函数参数时，位于func关键字后面的函数括号内完成。这通常在Swift函数中使用，以使函数调用看起来更像一句话。[图7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-3669
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-3670
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：sayHello()函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-3671
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:)函数的输入参数是friend，参数标签是to，函数调用中传入的参数是“Colin”。如果没有单独的参数标签，调用函数时会像sayHello(friend:)那样，这样听起来就不像是一个完整的句子了。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-3672
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何编写带有自定义参数标签的函数。我们还会向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-3673
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-3674
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，看看如何通过添加自定义参数标签让你的代码更具可读性。在你的生日派对之后，你会想向所有的客人发送感谢信。在你的playground中编写以下函数：
- en: '[PRE699]'
  id: totrans-3675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-3676
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传入函数的guest参数添加了自定义参数标签to。同样，在➋处，我们为gift参数添加了参数标签for。参数名称guest ➌和gift
    ➍用于引用函数内部的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-3677
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for用于在函数调用时标记参数，像这样：
- en: '[PRE700]'
  id: totrans-3678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-3679
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到to:被写在第一个输入值前，for:被写在第二个输入值前。如果某个参数有自定义的参数标签，你必须在函数调用中使用它。试图使用参数名称代替将会导致错误：
- en: '[PRE701]'
  id: totrans-3680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-3681
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能会始终为你填写参数标签，因此你不必担心错误地调用函数（见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-3682
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-3683
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动补全函数并填入正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-3684
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个示例中，函数用于向客人发送感谢信，*to*是发送对象，*for*是感谢的原因。代码sendThankYou(to:
    "Meghan", for: "puzzle books")读起来更像一句话，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-3685
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-3686
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-3687
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线和空格来移除它们。在以下示例中，我们编写了一个用于计算体积的函数，该函数接受盒子的三个边长作为输入。由于函数名称已经清楚地表明你需要传入三个边长，因此你不需要参数标签来提高代码的可读性。
- en: '[PRE702]'
  id: totrans-3688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-3689
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处为side1、➋处为side2、➌处为side3前面加下划线来去除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-3690
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，不需要任何标签。
- en: '[PRE703]'
  id: totrans-3691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-3692
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出"这个盒子的体积是72。" 如果你希望不仅仅是打印盒子的体积，而是能将结果存储在变量或常量中以便稍后使用，难道不是很有用吗？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-3693
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-3694
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-3695
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的盒子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-3696
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并想知道哪个可以装更多的东西。首先，编写一个返回盒子体积的volumeOfBox(_:_:_:)函数，该函数返回一个Int类型的盒子体积：
- en: '[PRE704]'
  id: totrans-3697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-3698
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数指定返回值，使用一个破折号和一个大于符号组成箭头（->），紧跟着函数的输入参数➊，然后输入返回值的数据类型。注意，您不需要为返回值提供名称，只需要数据类型。在函数体内，您使用
    `return` 关键字返回值，后面跟着您想要返回的值➋。如果您编写一个返回值的函数，那么您*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果您在返回语句之后再写任何代码，它会被忽略，因为
    `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-3699
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-3700
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数，分别传入两个不同的盒子，以查看其效果：
- en: '![](Image00165.jpg)'
  id: totrans-3701
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-3702
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`volumeOfBox(_:_:_:)` 函数计算一个边长为6、5和3的盒子的体积，返回值90被存储在名为 `volumeOfBox1` 的常量中。在➋处，边长为8、4和2的
    `volumeOfBox2` 被赋值为64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE705]'
  id: totrans-3703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-3704
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在调试控制台中看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-3705
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-3706
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望根据条件返回不同的值。让我们编写一个函数，它接受一个测试分数的数组并返回平均分数。为了得到平均分，您将所有分数相加，然后除以分数的总数。请在您的
    playground 中输入以下代码：
- en: '[PRE706]'
  id: totrans-3707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-3708
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在➊处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始值设置为0。➋处的 `for-in` 循环遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量保存了所有分数的总和。在我们计算总和之后，剩下的就是将其除以分数的总数，这个总数就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-3709
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？您不能用零来除——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除以零的错误，并崩溃您的程序。因此，在进行除法时，始终确保您要除的数不是零，这正是我们在➌处通过检查
    `scores.count > 0` 来实现的。在➍处，我们通过将分数总和除以数组中的分数数量来返回平均值，代码是 `return sum / scores.count`。没错！您可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回
    `sum / scores.count`，因为它会计算出一个 `Int` 类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-3710
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一些内容，否则会出现函数缺少返回值的错误。我们通过在 `if` 语句中添加 `else`
    来处理这个问题，在 `else` 中返回0➎。您可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-3711
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-3712
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给 averageOf() 函数时，如我们在 ➊ 中所做的，函数将返回这些成绩的平均值，并显示在结果窗格中。如果你传递一个空数组，如我们在
    ➋ 中所做的，返回值将是 0 。
- en: '**NOTE**'
  id: totrans-3713
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-3714
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句其实并不必要。这是因为如果 scores.count > 0 ，函数会在 return sum
    / scores.count 时已经结束。如果程序已经跳过了那个 if 语句，我们知道 scores.count > 0 一定不成立，这时我们可以直接使用
    return 0，而无需用 else 将其包裹。不过，如果我们保留 else 语句，代码会更清晰，也更容易理解。有时候，写多一点代码让别人更容易理解，比使用一些巧妙的捷径更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-3715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-3716
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建并调用你自己的函数！函数在编程中被广泛应用，用来执行各种神奇的操作！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-3717
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08) 中，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你能够创建具有除 Swift
    内建类型以外的其他类型的常量和变量，这在你创建应用程序时非常有用！
- en: '![Image](Image00153.jpg)'
  id: totrans-3718
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00153.jpg)'
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-3719
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-3720
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用 printAHaiku() 函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-3721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数如何利用输入参数做更多事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-3722
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，你看到了函数如何节省时间和精力。当你编写一个函数时，你可以在任何需要的地方调用它，而不必在许多地方重复相同的代码块。这当然很酷，但函数的真正威力在于，当你传递一个或多个输入值时，函数能够产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-3723
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-3724
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 invite(guest:) 的函数，它接受一个人的名字作为输入，并创建一份个性化的生日派对邀请函。将以下代码输入到你的 Playground
    中：
- en: '[PRE707]'
  id: totrans-3725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-3726
  prefs: []
  type: TYPE_NORMAL
  zh: '如果一个函数有输入参数，你需要将其放入函数名后的括号中 ➊ 。你应该按顺序格式化输入参数，先是参数名（例如这里的 guest ），然后是冒号（: ），最后是数据类型（这里是
    String）。'
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-3727
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，因此当你调用这个函数时，guest 将作为参数标签。（你将在 “[参数标签](text00017.html#ch07lev1sec4)”
    第 [89 页](text00017.html#page_89) 中学习如何定义不同的参数名和参数标签。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-3728
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后写输入参数的数据类型，跟声明变量时一样。不过，与变量声明不同的是，在定义函数参数时，你必须*始终*声明函数应期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-3729
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-3730
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数中使用输入参数，只需像使用其他常量一样，使用其参数名称 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-3731
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义函数并不够。既然函数已经定义，让我们在 playground 中调用它，看看会发生什么。你可以通过输入函数名称，后跟括号中的参数标签、冒号和参数，来调用一个有输入参数的函数，如下所示：
- en: '[PRE708]'
  id: totrans-3732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-3733
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名称调用函数时，Xcode 的自动完成功能会给你一些提示，告诉你应该传递什么给函数。在这种情况下，当你开始写 invite 时，会看到一个下拉菜单，如
    [图 7-2](text00017.html#ch07fig2) 所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-3734
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-3735
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成功能将显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-3736
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键以自动完成函数。光标会移动到函数的括号内（见 [图 7-3](text00017.html#ch07fig3)），此时 Xcode
    已自动添加一些占位符文本，告诉你该函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-3737
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-3738
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 等待你填写来宾参数。*'
- en: '**NOTE**'
  id: totrans-3739
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-3740
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递给 invite(guest:) 的不是字符串，比如 invite(guest: 45)，你会收到一个错误，因为函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-3741
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 位置输入 "Cathy" 或其他朋友的名字，然后按 TAB 完成函数调用的填写。它应该看起来像 [图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-3742
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-3743
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-3744
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用 invite(guest:) 三次，使用你朋友们的名字：
- en: '[PRE709]'
  id: totrans-3745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: 'The output looks like this:'
  id: totrans-3746
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE710]'
  id: totrans-3747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-3748
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你可以快速打印出三份派对邀请函，每一份都发给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-3749
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-3750
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过传入一个字符串数组作为参数，而不是单个字符串，来编写一个一次邀请所有朋友的函数。在你编写了 invite(guest:) 的同一个 playground
    中，编写以下 invite(allGuests:) 函数来进行测试。注意，参数名称现在是复数形式，因为我们将一次邀请多个来宾。
- en: '![Image](Image00158.jpg)'
  id: totrans-3751
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE711]'
  id: totrans-3752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-3753
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当你声明函数的参数时，你会注意到 [String] 被方括号包围 ➊。方括号声明数据类型为数组，String 表示数组中值的数据类型。通过使用
    [String]，我们声明这个函数的输入为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-3754
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内，我们将使用一个 for-in 循环遍历来宾数组，并为每位来宾打印邀请函。还记得我们刚刚创建了一个打印邀请函的函数吗？我们在这里也用它！将以下代码添加到
    invite(allGuests:) 函数中（灰色文本表示现有行）：
- en: '[PRE712]'
  id: totrans-3755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-3756
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个客人调用单一的invite(guest:)函数，邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是不是同一个函数。毕竟，它们都叫做invite。然而，尽管它们共享一个名字，但它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常会看到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-3757
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，首先我们创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE713]'
  id: totrans-3758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-3759
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个包含六个朋友的数组➊。然后，我们将新数组作为函数的输入来调用该函数➋。这是你在调试控制台中看到的输出（-- snip --表示我们为了节省空间省略的部分行）：
- en: '[PRE714]'
  id: totrans-3760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-3761
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友写邀请函，那将是一个繁琐的工作。但凭借函数的强大功能，你仅用几行代码就完成了这个任务。试着创建你自己的朋友数组，尽情扩展它的长度！然后，使用你的新数组作为输入，调用invite(allGuests:)函数。简直轻松无比！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-3762
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-3763
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近了，而有些客人还没有回复。你想要最终确认一下参加人数，并通知客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据客人的RSVP状态，向他们发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-3764
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-3765
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个String类型的参数表示客人的名字，以及一个Bool类型的参数表示RSVP状态，它的值可以是true或false。将以下代码输入到你的游乐场中：
- en: '[PRE715]'
  id: totrans-3766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-3767
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号➊。每个参数都需要有一个参数名，后面跟一个冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，并且这些参数不必是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传入了一个String类型的guest和一个Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-3768
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为true➋，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最终print语句无论rsvped值是true还是false都会执行，因为它们在if-else语句的花括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-3769
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复了，他们将收到此消息：
- en: '[PRE716]'
  id: totrans-3770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-3771
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有回复，他们将收到一条礼貌的提醒，要求他们回应：
- en: '[PRE717]'
  id: totrans-3772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-3773
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一个客人的rsvped值设置为true，另一个客人的设置为false，这样你就能看到两个消息的实际效果。
- en: '[PRE718]'
  id: totrans-3774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-3775
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-3776
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能将帮助你填写输入值，并为你提供参数标签。你所需要做的就是传入你想要使用的值。填写完来宾姓名后，按 TAB 键，Xcode 将光标定位到下一个输入值的位置。（请参见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-3777
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-3778
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入来宾姓名后按下 TAB 键，将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-3779
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，如名字或数字，你将得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-3780
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-3781
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用 print(_:) 时，并没有在输入值前面添加参数标签吗？你写的是：
- en: '[PRE719]'
  id: totrans-3782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-3783
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加标签，你将遇到错误：
- en: '[PRE720]'
  id: totrans-3784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-3785
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你写一个函数时，每个参数都会有一个参数标签，且标签与参数名相同。然而，如果你写一个函数时觉得不需要参数标签来让代码更清晰，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，很明显你传入的输入是一个字符串，它将被打印出来。如果每次调用 print(_:) 都需要包含类似 inputString 的参数标签，肯定会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-3786
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号以及参数的数据类型来实现这一点。你在函数声明的括号内首次声明参数时就会做这些。这个做法在
    Swift 函数中很常见，可以让函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-3787
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-3788
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-3789
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用函数时会是
    sayHello(friend:)，这听起来不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-3790
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将了解如何编写具有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-3791
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-3792
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示如何通过添加自定义参数标签让你的代码更具可读性。在你的生日派对之后，你会想要向所有来宾发送感谢信。请在你的 playground
    中写下以下函数：
- en: '[PRE721]'
  id: totrans-3793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-3794
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了自定义的参数标签 to 。类似地，在 ➋ 处，我们为 gift 参数添加了参数标签 for 。参数名称
    guest ➌ 和 gift ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-3795
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数时，to 和 for 作为参数标签来标记参数，像这样：
- en: '[PRE722]'
  id: totrans-3796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-3797
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里你可以看到，to: 写在函数调用的第一个输入值之前，而for: 写在第二个输入值之前。如果一个参数有自定义的标签，你必须在函数调用中使用它。否则，使用参数名称会导致错误：'
- en: '[PRE723]'
  id: totrans-3798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-3799
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会自动为你填写参数标签，所以你不必担心错误地调用函数（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-3800
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-3801
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-3802
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用来向客人发送感谢信 *to* 一个客人 *for*
    一个礼物。代码 sendThankYou(to: "Meghan", for: "puzzle books") 读起来更像一句话，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-3803
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-3804
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-3805
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线和一个空格来移除它们。在下面的例子中，我们编写了一个用于计算体积的函数，它接受一个盒子的三个边长作为输入。因为函数名称已经清楚地表明你需要传入三个边长，所以你不需要参数标签来提高代码的可读性。
- en: '[PRE724]'
  id: totrans-3806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-3807
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处的 side1、➋ 处的 side2 和 ➌ 处的 side3 前面添加下划线，来移除这些参数的标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-3808
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而无需任何标签。
- en: '[PRE725]'
  id: totrans-3809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-3810
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72"。如果你可以将结果存储在一个变量或常量中，以便以后使用，而不仅仅是将体积打印出来，这样不是更有用吗？让我们来看看如何使用返回值做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-3811
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-3812
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，让它返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-3813
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-3814
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子可以装更多的东西。首先，编写一个返回盒子体积的 volumeOfBox(_:_:_:) 函数，它返回一个 Int
    类型的值：
- en: '[PRE726]'
  id: totrans-3815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-3816
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给一个函数返回值，在函数的输入参数之后使用短横线和大于号（`->`）形成箭头 ➊ ，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要一个数据类型。在函数体内，你通过使用`return`关键字后跟你想返回的值来返回该值
    ➋。如果你写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值之后结束。如果在`return`语句之后写任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-3817
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-3818
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它的实际效果：
- en: '![](Image00165.jpg)'
  id: totrans-3819
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-3820
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)`函数计算一个边长为6、5和3的盒子的体积，返回值90被存储在名为`volumeOfBox1`的常量中。在
    ➋ 处，边长为8、4和2的`volumeOfBox2`被赋值为64。现在，让我们打印一个关于哪个盒子更大的消息：
- en: '[PRE727]'
  id: totrans-3821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-3822
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串“Box 1 is the bigger box.”
- en: '**CONDITIONAL RETURNS**'
  id: totrans-3823
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-3824
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据某个条件返回不同的值。让我们写一个函数，它接受一个考试成绩数组，并返回平均成绩。为了得到平均值，你将所有分数加起来，然后除以分数的总数。在你的playground中输入以下代码：
- en: '[PRE728]'
  id: totrans-3825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-3826
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为`sum`的`Int`变量，并将其初始化为0。位于 ➋ 的`for-in`循环遍历`score`数组中的每个值并将其加到`sum`变量中。当循环完成时，`sum`变量保存了所有分数的总和。在计算出总和后，剩下的就是将其除以分数的总数，这就是简单的`score.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-3827
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果数组为空怎么办呢？你不能把一个数除以零——无论是在数学课上，还是在Swift中。在Swift中，尝试除以零会导致除零错误并崩溃程序。因此，在进行除法时，务必确保你要除的数不是零，这就是我们在
    ➌ 处通过检查`score.count > 0`来做到的。在 ➍ 处，我们通过将分数之和除以数组中的分数个数来返回平均值，使用`return sum / score.count`。没错！你可以返回任何计算结果符合正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋给新变量的步骤，直接返回`sum
    / score.count`，因为它会评估为`Int`类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-3828
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`score.count`不大于零时，我们也需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在`if`语句中添加一个`else`分支来处理这个问题，返回0
    ➎。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-3829
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-3830
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 averageOf() 函数时，如我们在 ➊ 中所做，返回的是分数的平均值，并显示在结果面板中。如果你传递一个空数组，如我们在
    ➋ 中所做，返回值为 0。
- en: '**NOTE**'
  id: totrans-3831
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-3832
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，包围 return 0 的 else 语句其实并不必要。这是因为如果 scores.count > 0 ，函数已经通过 return
    sum / scores.count 结束了。所以，如果计算机已经越过了 if 语句，那么我们知道 scores.count > 0 一定不成立，我们本可以直接使用
    return 0，而不需要把它包裹在 else 语句中。然而，如果我们保留 else 语句，代码会更清晰、更容易理解。有时候，写多一点代码来让别人更容易理解，比使用技巧性的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-3833
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的知识**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-3834
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚向你的 Swift 工具包中添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种各样了不起的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-3835
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建除了 Swift 中已包含的类型之外的常量和变量，这在你开发应用时会非常有用！
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  id: totrans-3836
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：函数的输出显示在调试控制台中。*'
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-3837
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用 printAHaiku() 函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-3838
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数在处理输入参数时能做更多事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-3839
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一个例子中，你看到函数如何节省时间和精力。当你写一个函数时，你可以在任何需要的地方调用它，而无需在多个地方重复代码块。这本身就很酷，但函数的真正威力在于当你传递一个或多个输入值以产生不同的结果时。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-3840
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-3841
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个名为 invite(guest:) 的函数，它接受一个人的名字作为输入，并创建一个个性化的生日派对邀请。请输入以下内容到你的 playground
    中：
- en: '[PRE729]'
  id: totrans-3842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-3843
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将它包含在函数名后的圆括号中 ➊ 。你将输入参数按名称顺序写出（在本例中是 guest），接着是冒号（:），最后是它的数据类型（在此为
    String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-3844
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也作为参数标签使用，因此当你调用这个函数时，guest 将是参数标签。（你将在“[参数标签](text00017.html#ch07lev1sec4)”中学习如何定义独立的参数名和参数标签，见[第89页](text00017.html#page_89)）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-3845
  prefs: []
  type: TYPE_NORMAL
  zh: 你在输入参数后面写出数据类型，就像声明变量时那样。不过，与变量声明不同，在定义函数参数时，你必须*始终*声明函数应该期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-3846
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-3847
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数中使用输入参数，你只需像使用其他常量一样使用它的参数名 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-3848
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数并不够。现在函数已经定义好了，让我们在 playground 中调用它，看看会发生什么。你可以通过输入函数名，后面跟上括号内的参数标签、冒号和参数来调用一个具有输入参数的函数，格式如下：
- en: '[PRE730]'
  id: totrans-3849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-3850
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过输入函数名调用一个函数时，Xcode 的自动完成功能会提示你应该传入函数的参数。在这种情况下，当你开始输入 `invite` 时，你会看到一个下拉菜单，如[图
    7-2](text00017.html#ch07fig2)所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-3851
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-3852
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成功能会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-3853
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键来自动完成函数。光标将移动到函数的括号内（见[图 7-3](text00017.html#ch07fig3)），此时 Xcode 已经自动添加了占位符文本，告诉你该函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-3854
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-3855
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-3856
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-3857
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传入一个非字符串的参数给 invite(guest:)，例如 invite(guest: 45)，你将会遇到错误，因为该函数期望的是字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-3858
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将 `"Cathy"` 或其他朋友的名字输入到 String 的位置，然后按 TAB 键完成函数调用的填写。它应该如[图 7-4](text00017.html#ch07fig4)所示。
- en: '![Image](Image00157.jpg)'
  id: totrans-3859
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-3860
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-3861
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何填写函数调用，尝试三次调用 invite(guest:)，并使用你自己朋友的名字：
- en: '[PRE731]'
  id: totrans-3862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: 'The output looks like this:'
  id: totrans-3863
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE732]'
  id: totrans-3864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-3865
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你能够快速打印出三张派对邀请函，每一张都写给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-3866
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-3867
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，通过传入一个字符串数组作为参数，而不是一个单独的字符串，从而一次性邀请所有朋友。在你编写了 invite(guest:) 函数的同一个
    playground 中，编写以下 invite(allGuests:) 函数来进行测试。请注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-3868
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE733]'
  id: totrans-3869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-3870
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当你声明函数的参数时，你会注意到 [String] 被方括号包围 ➊。方括号声明数据类型为数组，而 String 表示数组中元素的数据类型。通过使用
    [String]，我们声明该函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-3871
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们需要使用一个 for-in 循环遍历我们的 guests 数组，为每个客人打印一张邀请函。还记得我们刚刚创建的打印邀请函的函数吗？我们可以在这里使用它！将以下代码添加到你的
    invite(allGuests:) 函数中（灰色文本表示现有的代码行）：
- en: '[PRE734]'
  id: totrans-3872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-3873
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对字符串数组allGuests中的每个guest调用单一的invite(guest:)函数，邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是不是同一个函数。毕竟，它们都有一个相同的名字invite。然而，尽管它们的名字相同，它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常会看到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-3874
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用这个数组。
- en: '[PRE735]'
  id: totrans-3875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE735]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-3876
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后我们使用这个新的数组作为函数的输入来调用函数 ➋。这是你在调试控制台中看到的输出（-- snip --显示了我们省略的行，以节省空间）：
- en: '[PRE736]'
  id: totrans-3877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-3878
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为这些朋友逐一写邀请函，那将会很麻烦。但借助函数的强大功能，你已经用极少的代码行完成了这项工作。试着创建你自己的朋友数组，长度随你意！然后用你新的数组作为输入调用invite(allGuests:)函数。简直轻松！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-3879
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-3880
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期快到了，但一些客人还没有回复RSVP。你想要获得最终的到场人数，并让客人们知道带上泳衣，因为这将是一个滑水派对。你可以写一个函数，根据每个客人的RSVP状态，给他们发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-3881
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-3882
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个用于客人姓名的字符串参数和一个用于RSVP状态的布尔参数，RSVP状态的值可以是true或false。请输入以下代码到你的playground中：
- en: '[PRE737]'
  id: totrans-3883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-3884
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加一个逗号 ➊。每个参数都需要有一个参数名，后面跟着冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，并且这些参数不必是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传入了一个字符串类型的guest和一个布尔类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-3885
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped的值，看它是否为true ➋，然后使用if-else语句打印相应的消息。请注意，函数定义中的最终打印语句无论rsvped值是true还是false都会执行，因为它们在if-else语句的大括号之外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-3886
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复RSVP，他们将收到这条消息：
- en: '[PRE738]'
  id: totrans-3887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-3888
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的通知，要求他们做出回应：
- en: '[PRE739]'
  id: totrans-3889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-3890
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一个客人的rsvped值设置为true，将另一个客人的值设置为false，这样你就能看到两个消息的实际效果。
- en: '[PRE740]'
  id: totrans-3891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE740]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-3892
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-3893
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会通过提供参数标签帮助你填写输入值。你只需传入你想使用的值即可。输入完嘉宾姓名后，按 TAB 键，Xcode 会将光标定位到需要的地方，以便填写下一个输入值。（参见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-3894
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-3895
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入嘉宾姓名后按 TAB 键会将光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-3896
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名称或数字，就会出现错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-3897
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-3898
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用 print(_:) 时，输入值前没有参数标签吗？你只需写：
- en: '[PRE741]'
  id: totrans-3899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE741]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-3900
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，也会报错：
- en: '[PRE742]'
  id: totrans-3901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE742]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-3902
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，且它与参数名称相同。然而，如果你编写一个函数，觉得参数标签不必要来使代码更清晰，那么你可以在函数定义中显式省略它。例如，在
    print(_:) 函数中，很明显你传入的是一个字符串，且会被打印出来。如果每次调用 print(_:) 时都必须包含类似 inputString 的参数标签，那会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-3903
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。在函数体内的 func 关键字后声明参数时，通常会这样做。这样做的目的是让函数调用看起来更像一个完整的句子。[图
    7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-3904
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-3905
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-3906
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，而在函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用该函数时会像
    sayHello(friend:) 这样，看起来不像是一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-3907
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-3908
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-3909
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，看看添加自定义参数标签如何使你的代码更具可读性。生日派对后，你可能想给所有嘉宾写感谢信。请在你的 Playground 中写下以下函数：
- en: '[PRE743]'
  id: totrans-3910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE743]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-3911
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递到函数中的 guest 参数添加了一个自定义的参数标签 `to`。类似地，在 ➋ 处，我们为 gift 参数添加了一个参数标签 `for`。参数名称
    `guest` ➌ 和 `gift` ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-3912
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 `to` 和 `for` 用于在函数调用时标记参数，就像这样：
- en: '[PRE744]'
  id: totrans-3913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE744]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-3914
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到，`to:` 被写在函数调用中的第一个输入值之前，而 `for:` 被写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用时使用它。否则，使用参数名称会导致错误：
- en: '[PRE745]'
  id: totrans-3915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE745]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-3916
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会自动填写参数标签，因此你不必担心错误地调用函数（参见 [图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-3917
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-3918
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode 自动补全函数并正确添加参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-3919
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用介词如 *to*、*from* 或 *with* 作为参数标签。在这个例子中，函数用于向客人发送感谢信 *to* （给）一个客人 *for*
    （因）某个礼物。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 读起来更像一句句子，而不像 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-3920
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-3921
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-3922
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加上下划线和空格来移除它们。在下面的例子中，我们写了一个计算体积的函数，输入的是盒子的三个边长。因为函数名称已经清楚地表明你需要传入三个边长，所以实际上不需要参数标签来提高代码的可读性。
- en: '[PRE746]'
  id: totrans-3923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE746]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-3924
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处为 `side1`、在 ➋ 处为 `side2`、在 ➌ 处为 `side3` 前加上下划线来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-3925
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值而不需要任何标签。
- en: '[PRE747]'
  id: totrans-3926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE747]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-3927
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出“这个盒子的体积是72。” 如果你希望不仅仅是打印盒子的体积，而是将结果存储在变量或常量中以供后续使用，那该怎么办呢？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-3928
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-3929
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-3930
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-3931
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个能装更多的东西。首先，写一个 `volumeOfBox(_:_:_:)` 函数，返回一个 `Int` 类型的盒子体积：
- en: '[PRE748]'
  id: totrans-3932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE748]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-3933
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数一个返回值，在函数的输入参数后面使用一个短横线和大于号（->）来形成一个箭头 ➊ ，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你通过使用
    `return` 关键字并跟上你想返回的值 ➋ 来返回值。如果你写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在你返回值后结束。如果你在
    `return` 语句之后写了任何代码，它将被忽略，因为 `return` 会使函数退出。
- en: '![Image](Image00164.jpg)'
  id: totrans-3934
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-3935
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数来观察它的实际效果：
- en: '![](Image00165.jpg)'
  id: totrans-3936
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-3937
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个边长分别为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 的值为 64。现在让我们打印一条关于哪个盒子更大的信息：
- en: '[PRE749]'
  id: totrans-3938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE749]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-3939
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到输出字符串 "Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-3940
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-3941
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据某个条件返回不同的值。让我们写一个函数，它接收一个测试分数的数组并返回平均分。要获得平均分，你需要将所有分数相加，然后除以总的分数个数。在你的
    playground 中输入以下代码：
- en: '[PRE750]'
  id: totrans-3942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE750]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-3943
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始值设为 0。在 ➋ 处，for-in 循环遍历
    scores 数组中的每个值，并将其添加到 sum 变量中。当循环完成时，变量 sum 保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，这就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-3944
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空呢？你不能将一个数除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并崩溃你的程序。因此，在进行除法时，始终确保你要除的数字不是零，这就是我们在
    ➌ 处通过检查 scores.count > 0 所做的。在 ➍ 处，我们通过将分数的总和除以数组中分数的数量来返回平均值，使用 `return sum /
    scores.count`。没错！你可以返回任何评估为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 `sum /
    scores.count`，因为它会评估为 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-3945
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 `scores.count` 不大于零时返回某个值，否则我们会得到一个函数缺少返回值的错误。我们通过在 `if` 语句中添加一个
    `else` 来处理这个问题，返回 0 ➎。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-3946
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-3947
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试分数数组传递给 `averageOf()` 函数时，就像我们在 ➊ 所做的那样，函数返回并显示分数的平均值。如果你传入一个空数组，就像我们在
    ➋ 所做的那样，返回值为 0。
- en: '**NOTE**'
  id: totrans-3948
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-3949
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 else 语句其实并不必要。这是因为如果 `scores.count > 0`，函数会在 `return
    sum / scores.count` 时已经结束。因此，如果计算机已经通过了那个 if 语句，那么我们知道 `scores.count > 0` 一定不成立，我们可以直接使用
    `return 0`，而不需要将其包含在 else 语句中。然而，如果我们保留 else 语句，代码会更清晰、更易于理解。有时，写一些额外的代码来使别人更容易理解，比使用复杂的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-3950
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-3951
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱增加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-3952
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08) 中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建具有不同于 Swift
    中已包含类型的常量和变量，这在你创建应用程序时会非常有用！
- en: Try calling the printAHaiku() function a bunch of times!
  id: totrans-3953
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次调用 `printAHaiku()` 函数！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-3954
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数与输入参数的更多用途**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-3955
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一个示例中，你看到函数如何节省时间和精力。当你编写一个函数时，你可以在任何地方调用它，而不必在许多地方重复代码块。这当然很酷，但函数的真正威力在于你传入一个或多个输入值来产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-3956
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-3957
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 `invite(guest:)` 的函数，它接受一个人的名字作为输入，并创建一个个性化的生日派对邀请函。请输入以下内容到你的 Playground
    中：
- en: '[PRE751]'
  id: totrans-3958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE751]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-3959
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要在函数名后面的括号中包含它➊。你以参数名为首（在这个例子中是 guest），然后是一个冒号（:），最后是它的数据类型（在此例中为
    String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-3960
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，所以在调用此函数时，guest 将作为参数标签。（你将在 “[参数标签](text00017.html#ch07lev1sec4)”
    第 89 页学到如何定义独立的参数名和参数标签。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-3961
  prefs: []
  type: TYPE_NORMAL
  zh: 你在输入参数后面写上数据类型，就像声明变量时一样。然而，与变量声明不同的是，在定义函数参数时，你必须*始终*声明函数应该预期的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-3962
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-3963
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内使用输入参数，你只需像使用其他常量一样使用它的参数名➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-3964
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数还不够。现在函数已经定义好了，让我们在playground中调用它看看会发生什么。你可以通过输入函数名后跟括号中的参数标签、冒号和参数来调用一个带有输入参数的函数，像这样：
- en: '[PRE752]'
  id: totrans-3965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE752]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-3966
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过编写函数名来调用函数时，Xcode的自动补全会给你一个提示，告诉你应该传递什么内容到函数中。在这种情况下，当你开始写invite时，你会看到像[图
    7-2](text00017.html#ch07fig2)中那样的下拉菜单。
- en: '![Image](Image00155.jpg)'
  id: totrans-3967
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-3968
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2: Xcode的自动补全会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-3969
  prefs: []
  type: TYPE_NORMAL
  zh: 按ENTER键自动完成函数。你的光标会移到函数的括号内（参见[图 7-3](text00017.html#ch07fig3)），此时Xcode会自动添加一些占位符文本，告诉你函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-3970
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-3971
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3: Xcode正在等待你填写guest参数。*'
- en: '**NOTE**'
  id: totrans-3972
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-3973
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传入不是字符串的内容到invite(guest:)函数，例如invite(guest: 45)，你会遇到错误，因为这个函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-3974
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在String的位置输入“Cathy”或其他朋友的名字，然后按TAB键即可完成函数调用的填写。它应该像[图 7-4](text00017.html#ch07fig4)一样。
- en: '![Image](Image00157.jpg)'
  id: totrans-3975
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-3976
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4: 一个invite(guest:)函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-3977
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用invite(guest:)三次，使用你自己朋友的名字：
- en: '[PRE753]'
  id: totrans-3978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE753]'
- en: 'The output looks like this:'
  id: totrans-3979
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来是这样的：
- en: '[PRE754]'
  id: totrans-3980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE754]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-3981
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你能够快速打印三张派对邀请函，每张都写给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-3982
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-3983
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，通过传递一个字符串数组作为参数来一次性邀请所有朋友，而不是单个字符串。在你编写invite(guest:)函数的同一个playground中，编写以下invite(allGuests:)函数来进行测试。请注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-3984
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE755]'
  id: totrans-3985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE755]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-3986
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被方括号包围➊。方括号表示数据类型为数组，而String表示数组中值的数据类型。通过使用[String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-3987
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们需要使用for-in循环来遍历我们的客人数组，并为每个客人打印一张邀请函。记得我们刚才创建了一个打印邀请函的函数吗？我们在这里也可以使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本显示的是现有的行）：
- en: '[PRE756]'
  id: totrans-3988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE756]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-3989
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们在字符串数组allGuests中的每个客人上调用了单数形式的invite(guest:)函数，以邀请每个人参加生日派对。您可能会想知道，invite(guest:)和invite(allGuests:)是不是同一个函数。毕竟，它们都叫做invite。尽管它们名字相同，但它们是两个不同的函数，因为它们接受不同的输入参数。这是您在Swift中经常会看到的一个模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-3990
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE757]'
  id: totrans-3991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE757]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-3992
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个包含六个朋友的数组 ➊。然后，我们调用函数，并将新数组作为函数的输入 ➋。这是您在调试控制台中看到的输出（-- snip --表示我们为节省空间省略的部分行）：
- en: '[PRE758]'
  id: totrans-3993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE758]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-3994
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要为这些朋友逐一写邀请函，那将是一项繁重的工作。但是凭借函数的力量，您仅用几行代码就完成了这一任务。尝试创建您自己的朋友数组，长度随意！然后使用您的新数组作为输入，调用invite(allGuests:)函数。真是轻松愉快！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-3995
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给您的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-3996
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您的派对日期临近，但一些客人还没有RSVP。您想要确认最终的人数，并让客人们知道带上泳衣，因为这将是一个滑水派对。您可以编写一个函数，根据客人的RSVP状态发送定制的信息给每个客人。
- en: '![Image](Image00159.jpg)'
  id: totrans-3997
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-3998
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新函数将接受两个输入参数：一个字符串参数表示客人的姓名，另一个布尔参数表示RSVP状态，值为true或false。请输入以下代码到您的Playground中：
- en: '[PRE759]'
  id: totrans-3999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE759]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-4000
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，您需要在每个参数之间加上逗号 ➊。每个参数需要有一个参数名，后面跟着冒号和参数的数据类型。您可以创建一个接受任意数量输入参数的函数，这些参数不必是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传入的是一个表示客人姓名的字符串和一个表示RSVP状态的布尔值。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-4001
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为true ➋，然后使用if-else语句打印相应的信息。还要注意，函数定义中的最终打印语句无论rsvped值是true还是false都会执行，因为它们位于if-else语句的括号外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-4002
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的客人已经回复了邀请，他们将收到以下信息：
- en: '[PRE760]'
  id: totrans-4003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE760]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-4004
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提示，要求他们尽快回复：
- en: '[PRE761]'
  id: totrans-4005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE761]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-4006
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一位客人的rsvped值设置为true，另一位客人的rsvped值设置为false，这样您就能看到两条信息的实际效果。
- en: '[PRE762]'
  id: totrans-4007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE762]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-4008
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-4009
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会帮助你填写输入值，通过为你提供参数标签。你只需要传入你想使用的值。填写完访客姓名后，按下 TAB 键，Xcode 会将光标放置到下一个需要填写输入值的位置。（参见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-4010
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-4011
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入访客姓名后按 TAB 键会将光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-4012
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 `Bool` 替换为 `true` 或 `false`。如果你尝试传入其他内容，比如姓名或数字，就会出现错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-4013
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-4014
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到当你调用 `print(_:)` 时，并没有在输入值前加上参数标签？你只需要写：
- en: '[PRE763]'
  id: totrans-4015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE763]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-4016
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，会出现错误：
- en: '[PRE764]'
  id: totrans-4017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE764]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-4018
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它将与参数名称相同。然而，如果你编写一个函数，并且认为参数标签在让代码更清晰方面没有必要，那么你可以在函数定义中显式省略它。例如，在
    `print(_:)` 函数中，很明显你传入的是一个将被打印的字符串。如果每次调用 `print(_:)` 都必须包含像 `inputString` 这样的参数标签，那会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-4019
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来完成这项操作。这一切都在你首次声明函数括号内的参数时进行，位于
    `func` 关键字之后。Swift 中通常会这么做，以使函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6) 说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-4020
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-4021
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：`sayHello()` 函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-4022
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 `friend`，参数标签是 `to`，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用该函数时会像
    `sayHello(friend:)`，这听起来就不像一个完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-4023
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何编写带有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-4024
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-4025
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示如何通过添加自定义参数标签使代码更具可读性。生日派对结束后，你可能想要向所有来宾发送感谢信。在你的 playground 中写下以下函数：
- en: '[PRE765]'
  id: totrans-4026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE765]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-4027
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了一个自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名
    guest ➌ 和 gift ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-4028
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签，to 和 for，用于在调用函数时标记参数，如下所示：
- en: '[PRE766]'
  id: totrans-4029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE766]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-4030
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 被写在第一个输入值之前，而 for: 被写在第二个输入值之前。如果参数有自定义的标签，你必须在函数调用中使用它。如果试图使用参数名而不是标签，会导致错误：'
- en: '[PRE767]'
  id: totrans-4031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE767]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-4032
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成总是会为你填充参数标签，因此你不必担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-4033
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-4034
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-4035
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信 *to* ，感谢 *for*
    礼物。代码 sendThankYou(to: "Meghan", for: "puzzle books") 看起来更像一句句子，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-4036
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-4037
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-4038
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加下划线和空格来移除它们。在下面的例子中，我们编写了一个计算体积的函数，输入盒子的三个边长。因为函数名已经明确表示需要传入三个边长，所以你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE768]'
  id: totrans-4039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE768]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-4040
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处的 side1、➋ 处的 side2 和 ➌ 处的 side3 前添加下划线，来移除这些参数的标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-4041
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需要输入参数值而不需要任何标签。
- en: '[PRE769]'
  id: totrans-4042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE769]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-4043
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。" 如果你不仅仅是打印盒子的体积，而是将结果存储到变量或常量中以后使用，难道不是很有用吗？让我们了解如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-4044
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-4045
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将结果打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-4046
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的盒子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-4047
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，编写一个返回盒子体积的 volumeOfBox(_:_:_:) 函数，返回一个 Int 值：
- en: '[PRE770]'
  id: totrans-4048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE770]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-4049
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给一个函数设置返回值，在函数的输入参数后使用箭头（->）符号 ➊，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需指定数据类型。在函数体内，你通过使用
    `return` 关键字后跟你想要返回的值来返回该值 ➋。如果你写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值后结束。如果在
    `return` 语句后再写任何代码，它将被忽略，因为 `return` 会导致函数结束。
- en: '![Image](Image00164.jpg)'
  id: totrans-4050
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-4051
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的箱子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-4052
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-4053
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个边长为 6、5 和 3 的箱子的体积，返回值 90 被存储在一个名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 的值被设置为 64。现在，让我们打印出关于哪个箱子更大的消息：
- en: '[PRE771]'
  id: totrans-4054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE771]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-4055
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-4056
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-4057
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们写一个函数，它接收一个测试成绩的数组并返回平均成绩。为了得到平均值，你需要将所有成绩加起来，然后除以成绩的总数。在你的
    Playground 中输入以下代码：
- en: '[PRE772]'
  id: totrans-4058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE772]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-4059
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 Int 变量，并将其初始值设为 0。在 ➋ 处的 for-in 循环会遍历成绩数组中的每个值，并将其加到
    `sum` 变量中。当循环完成后，`sum` 变量将保存所有成绩的总和。计算完总和后，剩下的工作就是将总和除以成绩的总数，即 `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-4060
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空呢？你不能将一个数除以零——在数学课上或者在 Swift 中都是如此。在 Swift 中，尝试除以零会导致除以零错误并崩溃程序。因此，在进行除法运算时，始终确保除数不为零，这也是我们在
    ➌ 处通过检查 `scores.count > 0` 来做的。在 ➍ 处，我们通过将成绩总和除以数组中成绩的数量来返回平均值，使用 `return sum
    / scores.count`。没错！你可以返回任何求值为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 `sum
    / scores.count`，因为它的值会被求解为一个 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-4061
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一个值，否则会报错，提示函数缺少返回值。我们通过在 if 语句中添加一个 else
    分支来处理这个问题，返回 0 ➎。你可以通过在一个成绩数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-4062
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-4063
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给 averageOf() 函数时，如我们在 ➊ 所示，函数会返回成绩的平均值并显示在结果面板中。如果传入一个空数组，如我们在
    ➋ 所示，返回值将是 0。
- en: '**NOTE**'
  id: totrans-4064
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-4065
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不必要。这是因为如果 scores.count > 0，那么函数已经通过 return
    sum / scores.count 结束了。所以，如果计算机已经越过了那个 if 语句，我们知道 scores.count > 0 一定不为真，我们可以直接写
    return 0，而不需要将其包裹在 else 语句中。然而，如果我们保留 else 语句，代码会更清晰、更容易理解。有时候，写多一点代码使其他人更容易理解，比用一个巧妙的捷径更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-4066
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-4067
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中广泛使用，可以做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-4068
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你创建具有不同于 Swift 内置类型的常量和变量，这在你创建应用程序时会非常有用！
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  id: totrans-4069
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数通过输入参数做更多的事情**'
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-4070
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，你看到了函数如何节省你的时间和精力。当你编写一个函数时，可以在任何需要的地方调用它，而无需在多个地方重复相同的代码块。这当然很酷，但函数真正的威力在于当你传入一个或多个输入值来产生不同的结果时。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-4071
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-4072
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 invite(guest:) 的函数，它接受一个人的名字作为输入，并生成一个个性化的生日派对邀请函。请输入以下内容到你的 playground
    中：
- en: '[PRE773]'
  id: totrans-4073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE773]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-4074
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将它包含在函数名后面的括号内 ➊。你将输入参数格式化为先写名称（在此示例中为 guest），然后是冒号（:），最后是数据类型（此处为
    String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-4075
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名称也充当参数标签，因此在调用此函数时，guest 将作为参数标签。（你将在[第 89 页](text00017.html#page_89)的“[参数标签](text00017.html#ch07lev1sec4)”中学习如何定义单独的参数名称和参数标签。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-4076
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后写输入参数的数据类型，就像声明一个变量时一样。然而，与变量声明不同，当定义函数参数时，你*必须*始终声明函数期望的类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-4077
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-4078
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需使用其参数名称，就像使用任何其他常量一样 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-4079
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数是不够的。现在函数已定义，让我们在playground中调用它，看看会发生什么。你可以通过输入函数名，后面加上括号中的参数标签、冒号和参数来调用带有输入参数的函数，像这样：
- en: '[PRE774]'
  id: totrans-4080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE774]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-4081
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名来调用一个函数时，Xcode的自动补全会提示你应该传入什么内容。在这种情况下，当你开始写`invite`时，你会看到一个下拉菜单，如[图7-2](text00017.html#ch07fig2)所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-4082
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-4083
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：Xcode的自动补全会向你显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-4084
  prefs: []
  type: TYPE_NORMAL
  zh: 按下ENTER键以自动完成函数。光标将移动到函数的括号内（参见[图7-3](text00017.html#ch07fig3)），此时Xcode已自动添加了一些占位符文本，告诉你该函数期望输入的类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-4085
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-4086
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：Xcode正在等待你填写guest参数。*'
- en: '**NOTE**'
  id: totrans-4087
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-4088
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递一个不是字符串的内容给`invite(guest:)`，比如`invite(guest: 45)`，你会得到一个错误，因为该函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-4089
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将" Cathy"或另一个朋友的名字替换掉String，然后按TAB键完成函数调用的填写。它应该看起来像[图7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-4090
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-4091
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：一个`invite(guest:)`函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-4092
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用`invite(guest:)`三次，使用你自己朋友的名字：
- en: '[PRE775]'
  id: totrans-4093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE775]'
- en: 'The output looks like this:'
  id: totrans-4094
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下所示：
- en: '[PRE776]'
  id: totrans-4095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE776]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-4096
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`invite(guest:)`函数，你可以迅速打印出三份派对邀请函，每一份都发送给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-4097
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-4098
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过传递一个字符串数组作为参数来编写一个一次性邀请所有朋友的函数，而不是传递一个单独的字符串。在你编写了`invite(guest:)`函数的同一个playground中，编写以下`invite(allGuests:)`函数来进行测试。请注意，参数名现在是复数形式，因为我们将一次性邀请多个来宾。
- en: '![Image](Image00158.jpg)'
  id: totrans-4099
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE777]'
  id: totrans-4100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE777]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-4101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被放在了方括号内 ➊。方括号声明数据类型为数组，而String表示数组中值的数据类型。通过使用[String]，我们声明了这个函数的输入为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-4102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`invite(allGuests:)`函数内部，我们需要使用一个for-in循环遍历我们的来宾数组，并为每位来宾打印邀请函。还记得我们刚刚创建的打印邀请函的函数吗？让我们在这里使用它！将以下代码添加到`invite(allGuests:)`函数中（灰色文本显示的是现有的代码行）：
- en: '[PRE778]'
  id: totrans-4103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE778]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-4104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们对字符串数组 allGuests 中的每个 guest 调用单一的 invite(guest:) 函数，邀请每个客人参加生日派对。你可能会疑惑
    invite(guest:) 和 invite(allGuests:) 是不是同一个函数。毕竟，它们的名称都是 invite。然而，尽管名字相同，它们是两个不同的函数，因为它们接受不同的输入参数。这是
    Swift 中常见的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-4105
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 invite(allGuests:) 函数，我们首先创建一个名为 friends 的数组，然后在函数调用中使用它。
- en: '[PRE779]'
  id: totrans-4106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE779]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-4107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后我们将新的数组作为函数的输入调用该函数 ➋。这是你将在调试控制台中看到的输出（-- snip -- 显示的是我们为了节省空间省略的行）：
- en: '[PRE780]'
  id: totrans-4108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE780]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-4109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每一位朋友写出邀请函，那将是很繁琐的工作。但借助函数的力量，你只需少量代码就完成了这项任务。试着创建你自己的朋友数组，想让它有多长都可以！然后将新的数组作为输入调用
    invite(allGuests:) 函数。简直不费吹灰之力！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-4110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-4111
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近，但一些客人还没有回复 RSVP。你想要得到最终的出席人数，并通知客人们带上泳衣，因为这是一个滑水派对。你可以写一个函数，根据每个客人的
    RSVP 状态，向他们发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-4112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-4113
  prefs: []
  type: TYPE_NORMAL
  zh: 你新建的函数将接受两个输入参数：一个字符串类型的参数表示客人的名字，另一个布尔类型的参数表示 RSVP 状态，值为 true 或 false。请输入以下代码到你的
    Playground 中：
- en: '[PRE781]'
  id: totrans-4114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE781]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-4115
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数都需要有一个参数名，后面跟上冒号和参数的数据类型。你可以创建一个接受任意多个输入参数的函数，而且这些参数不一定要是相同类型。在
    sendMessage(guest:rsvped:) 函数中，我们传入一个字符串类型的 guest 和一个布尔类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-4116
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 的值，看看它是否为 true ➋，然后使用 if-else 语句打印相应的消息。还要注意，函数定义中的最后一条 print
    语句会无论 rsvped 值是 true 还是 false 都会执行，因为它们位于 if-else 语句的外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-4117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经 RSVP，他们会收到这条消息：
- en: '[PRE782]'
  id: totrans-4118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE782]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-4119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提醒，要求他们回复：
- en: '[PRE783]'
  id: totrans-4120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE783]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-4121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数来看看它是如何工作的。尝试将一位客人的 rsvped 值设置为 true，另一位客人的设置为 false，这样你就能看到两个消息的实际效果。
- en: '[PRE784]'
  id: totrans-4122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE784]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-4123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-4124
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能将帮助你填写输入值，通过为你提供参数标签。你只需传入你想使用的值。填写完客人名字后，按下 TAB 键，Xcode 会将光标定位到下一个需要填写输入值的位置。（参见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-4125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-4126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入完客人名字后按 TAB 键，光标会跳到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-4127
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 `Bool` 替换为 `true` 或 `false`。如果你尝试传入其他内容，比如名字或数字，你会收到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-4128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-4129
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用 `print(_:)` 时，输入值前没有参数标签吗？你只需写：
- en: '[PRE785]'
  id: totrans-4130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE785]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-4131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你会收到一个错误：
- en: '[PRE786]'
  id: totrans-4132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE786]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-4133
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而有些没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，而且它将与参数名相同。然而，如果你编写函数时，觉得参数标签对代码的清晰性没有帮助，那么你可以在函数定义中明确省略它。例如，在
    `print(_:)` 函数中，很明显你传入的输入是一个将被打印的字符串。如果每次调用 `print(_:)` 都必须包含类似 `inputString`
    的参数标签，那会非常烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-4134
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号，最后是参数的数据类型来实现这一点。你在第一次声明函数内的参数时，就需要这样做，位置是在
    `func` 关键字后面的小括号内。这种做法在 Swift 函数中常常使用，以使函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)
    展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-4135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-4136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：`sayHello()` 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-4137
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 `friend`，参数标签是 `to`，而在函数调用中传递的参数是 `"Colin"`。如果没有单独的参数标签，那么当你调用该函数时，它的写法将是
    `sayHello(friend:)`，这听起来不像是一个完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-4138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-4139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-4140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，说明添加自定义参数标签如何让你的代码更具可读性。假设你的生日派对结束后，你会想给所有的客人寄送感谢卡。请在你的 Playground
    中写出以下函数：
- en: '[PRE787]'
  id: totrans-4141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE787]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-4142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了自定义参数标签 `to`。类似地，在 ➋ 处，我们为 gift 参数添加了参数标签 `for`。参数名
    guest ➌ 和 gift ➍ 用于引用函数内部的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-4143
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 `to` 和 `for` 用于在函数调用时标记参数，像这样：
- en: '[PRE788]'
  id: totrans-4144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE788]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-4145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到，`to:` 被写在第一个输入值前面，`for:` 被写在第二个输入值前面。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名代替会导致错误：
- en: '[PRE789]'
  id: totrans-4146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE789]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-4147
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填写正确的参数标签，因此你不必担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-4148
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-4149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成函数，并附上正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-4150
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信 *to*，感谢其 *for*
    礼物。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 读起来更像一句句子，而不是 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-4151
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-4152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-4153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前添加一个下划线和一个空格来移除它们。在下面的例子中，我们编写了一个用于计算体积的函数，它以盒子的三条边为输入。由于函数名已经清楚表明你需要传入三条边，因此你其实不需要额外的参数标签来使代码更易读。
- en: '[PRE790]'
  id: totrans-4154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE790]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-4155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处的 side1、➋ 处的 side2 和 ➌ 处的 side3 前面加上下划线来移除这些参数的标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-4156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需要输入参数值，而无需任何标签。
- en: '[PRE791]'
  id: totrans-4157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE791]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-4158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出 "这个盒子的体积是 72。"。如果你不仅仅是打印盒子的体积，而是将结果存储在变量或常量中以后再使用，这会不会更有用呢？让我们来看看如何通过返回值来做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-4159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-4160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-4161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-4162
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想要知道哪个可以装更多的东西。首先，编写一个 `volumeOfBox(_:_:_:)` 函数，返回盒子的体积（Int）：
- en: '[PRE792]'
  id: totrans-4163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE792]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-4164
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数返回值，可以在函数的输入参数后面使用一个箭头（->）和大于符号，然后输入返回值的数据类型 ➊。注意，你不需要为返回值提供名称，只需要数据类型。在函数体内，使用
    return 关键字并跟上你要返回的值 ➋ 来返回该值。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会发生错误。函数在返回值后结束。如果在
    return 语句后还写任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-4165
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-4166
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-4167
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-4168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算了一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条消息，说明哪个盒子更大：
- en: '[PRE793]'
  id: totrans-4169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE793]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-4170
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-4171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-4172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，该函数接收一个测试分数的数组，并返回平均分数。要得到平均值，你需要将所有分数相加，然后除以总的分数数量。在你的
    Playground 中输入以下代码：
- en: '[PRE794]'
  id: totrans-4173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE794]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-4174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始值设为 0。➋ 处的 for-in 循环遍历 scores
    数组中的每个值，并将其加到 sum 变量中。循环完成后，sum 变量保存了所有分数的总和。在计算总和后，剩下的就是将其除以分数的总数量，这就是 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-4175
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办？你不能除以零——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试除以零会导致“除零错误”，并使程序崩溃。因此，在进行除法运算时，始终确保你要除的数字不为零，这就是我们在
    ➌ 处通过检查 scores.count > 0 来避免的。在 ➍ 处，我们通过将分数总和除以数组中分数的数量来返回平均值，使用 return sum /
    scores.count。没错！你可以返回任何计算结果符合正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋值给新变量的步骤，直接返回 sum /
    scores.count，因为它会评估为一个 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-4176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 scores.count 不大于零时返回某些值，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加 else 来处理这一问题，返回
    0 ➎。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-4177
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-4178
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像在 ➊ 中一样将一个完整的测试分数数组传入 averageOf() 函数时，返回的结果是分数的平均值，并显示在结果面板中。如果你传入一个空数组，如在
    ➋ 中所示，返回值将是 0 。
- en: '**NOTE**'
  id: totrans-4179
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-4180
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句并不是必需的。这是因为如果 scores.count > 0 ，那么函数已经在 return
    sum / scores.count 时结束了。所以，如果程序已经越过了那个 if 语句，我们就知道 scores.count > 0 肯定不为真，那我们只需要写
    return 0，而不必放在 else 语句中。然而，如果我们保留 else 语句，代码会更加清晰且易于理解。有时候，写一点额外的代码让别人更容易理解，比使用巧妙的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-4181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-4182
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱增加了一个重要工具——创建并调用你自己的函数！函数在编程中被广泛应用，用来做各种各样令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-4183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第8章](text00018.html#ch08) 中，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建具有不同于 Swift 内置类型的常量和变量，这在你创建应用时会非常有用！
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  id: totrans-4184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，你看到了函数如何帮助你节省时间和精力。当你编写一个函数时，可以在任何需要的地方调用它，而不必在多个地方重复代码块。这当然很酷，但函数的真正强大之处在于当你传入一个或多个输入值时，可以产生不同的结果。
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-4185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作聚会邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-4186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 invite(guest:) 的函数，它接受一个人的名字作为输入，并创建一个个性化的生日派对邀请函。请输入以下内容到你的 Playground
    中：
- en: '[PRE795]'
  id: totrans-4187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE795]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-4188
  prefs: []
  type: TYPE_NORMAL
  zh: '如果一个函数有输入参数，你需要在函数名后面的括号中包含它 ➊ 。你首先写输入参数的名称（在这个例子中是 guest ），然后是冒号（: ），最后是它的数据类型（在此为
    String）。'
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-4189
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名称也充当了参数标签，因此 guest 会成为调用该函数时的参数标签。（你将在 “[参数标签](text00017.html#ch07lev1sec4)”
    中学习如何定义独立的参数名称和参数标签，在 [第89页](text00017.html#page_89) 中会详细讲解。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-4190
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后面写输入参数的数据类型，就像声明变量时一样。然而，与变量声明不同，在定义函数参数时，你*必须*始终声明函数应当接收的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-4191
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-4192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在函数内部使用输入参数，你只需要使用它的参数名称，就像使用任何其他常量一样 ➋ 。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-4193
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数并不够。现在函数已定义，让我们在 playground 中调用它，看看会发生什么。你可以通过输入函数名称，后跟括号内的参数标签、冒号和参数来调用一个有输入参数的函数，如下所示：
- en: '[PRE796]'
  id: totrans-4194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE796]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-4195
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名来调用一个函数时，Xcode 的自动完成功能会给你一个提示，告诉你应该传递什么类型的输入。在这种情况下，当你开始写 invite 时，你会看到一个下拉菜单，像[图
    7-2](text00017.html#ch07fig2)一样。
- en: '![Image](Image00155.jpg)'
  id: totrans-4196
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-4197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成将显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-4198
  prefs: []
  type: TYPE_NORMAL
  zh: 按 ENTER 键完成函数的自动补全。光标将移到函数的括号内（参见[图 7-3](text00017.html#ch07fig3)），此时 Xcode
    已自动添加了一些占位符文本，告诉你函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-4199
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-4200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-4201
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-4202
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递的不是字符串给 invite(guest:)，例如 invite(guest: 45)，你会得到一个错误，因为该函数期望一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-4203
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将“Cathy”或其他朋友的名字替换为 String，然后按 TAB 键完成函数调用。它应该看起来像[图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-4204
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-4205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个邀请（guest:）函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-4206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用，调用 invite(guest:) 三次，使用你自己朋友的名字：
- en: '[PRE797]'
  id: totrans-4207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE797]'
- en: 'The output looks like this:'
  id: totrans-4208
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE798]'
  id: totrans-4209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE798]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-4210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你可以快速打印三张派对邀请函，每张都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-4211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-4212
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，通过传入一个字符串数组作为参数，而不是单个字符串，一次性邀请所有朋友。在你编写了 invite(guest:) 函数的同一个 playground
    中，编写以下 invite(allGuests:) 函数来进行测试。注意，参数名称现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-4213
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE799]'
  id: totrans-4214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE799]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-4215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被放在方括号中 ➊。方括号声明数据类型为数组，而 String 表示数组中值的数据类型。通过使用[String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-4216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们需要使用 for-in 循环遍历我们的 guests 数组，并为每个客人打印一张邀请函。记得我们刚刚创建了一个打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到你的
    invite(allGuests:) 函数中（灰色文本显示的是现有代码行）：
- en: '[PRE800]'
  id: totrans-4217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE800]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-4218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对`allGuests`字符串数组中的每个宾客调用单一的`invite(guest:)`函数，以邀请每个人参加生日派对。你可能会想知道`invite(guest:)`和`invite(allGuests:)`是不是同一个函数。毕竟，它们的名字都是`invite`。然而，尽管名字相同，它们实际上是两个不同的函数，因为它们接受不同的输入参数。这是Swift中常见的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-4219
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`invite(allGuests:)`函数，我们首先创建一个名为`friends`的数组，然后将其作为函数调用的输入。
- en: '[PRE801]'
  id: totrans-4220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE801]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-4221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后，我们将新数组作为函数的输入，调用该函数 ➋ 。这是你在调试控制台中看到的输出（`-- snip --`表示我们省略了部分行以节省空间）：
- en: '[PRE802]'
  id: totrans-4222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE802]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-4223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友写出邀请函，那将需要大量的工作。但是，借助函数的力量，你只用了很少的代码行就完成了这个任务。试着创建你自己的朋友数组，长度随意！然后，使用你新创建的数组作为输入调用`invite(allGuests:)`函数。简直轻松至极！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-4224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的宾客发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-4225
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期即将来临，但有些宾客还没有RSVP。你想要确认最终的出席人数，并告知宾客们带上泳衣，因为将会有滑水派对。你可以编写一个函数，根据宾客的RSVP状态向每个宾客发送自定义消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-4226
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-4227
  prefs: []
  type: TYPE_NORMAL
  zh: 你新的函数将接受两个输入参数：一个字符串类型的宾客姓名和一个布尔类型的RSVP状态（可以是`true`或`false`）。在你的Playground中输入以下代码：
- en: '[PRE803]'
  id: totrans-4228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE803]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-4229
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊ 。每个参数需要有一个参数名，后跟冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，这些参数类型也不必相同。在`sendMessage(guest:rsvped:)`函数中，我们传入了一个字符串类型的`guest`和一个布尔类型的`rsvped`。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-4230
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查`rsvped`值是否为真 ➋，然后使用if-else语句打印相应的消息。请注意，函数定义中的最终打印语句无论`rsvped`值是`true`还是`false`都会执行，因为它们在if-else语句的大括号之外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-4231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的宾客已经RSVP，他们将收到以下消息：
- en: '[PRE804]'
  id: totrans-4232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE804]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-4233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有回应，他们将收到一条礼貌的提醒，要求他们做出回应：
- en: '[PRE805]'
  id: totrans-4234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE805]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-4235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一位宾客的`rsvped`值设置为`true`，而另一位宾客的设置为`false`，以便你可以看到两条消息的效果。
- en: '[PRE806]'
  id: totrans-4236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE806]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-4237
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数是相似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-4238
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会帮助你填写输入值，自动为你提供参数标签。你只需传入你想要使用的值。填写完客人名字后，按 TAB 键，Xcode 会将光标移到你需要的位置，以便填写下一个输入值。（参见
    [图 7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-4239
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-4240
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入完客人名字后按 TAB 键会将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-4241
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false 。如果你尝试传入其他内容，比如名字或数字，你会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-4242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-4243
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用 print(_:) 时，并没有在输入值前加上参数标签吗？你只需要写：
- en: '[PRE807]'
  id: totrans-4244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE807]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-4245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你会遇到错误：
- en: '[PRE808]'
  id: totrans-4246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE808]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-4247
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，且它与参数名称相同。然而，如果你编写的函数觉得参数标签在代码中不必要，你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，很明显你传入的是一个将被打印的字符串。每次调用 print(_:) 都需要包括类似 inputString 的参数标签会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-4248
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。你在函数声明中首先声明参数时，所有这些都需要做。这通常在
    Swift 函数中完成，使得函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-4249
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-4250
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-4251
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend ，参数标签是 to ，而在函数调用中传递的参数是 "Colin" 。如果没有单独的参数标签，调用函数时会像
    sayHello(friend:) ，这听起来就不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-4252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-4253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-4254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示添加自定义参数标签如何使你的代码更具可读性。在生日派对结束后，你可能需要给所有的客人发送感谢信。在你的 Playground 中编写以下函数：
- en: '[PRE809]'
  id: totrans-4255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE809]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-4256
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传递给函数的guest参数添加了自定义的参数标签to。类似地，在➋处，我们为gift参数添加了参数标签for。参数名称guest➌和gift➍用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-4257
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for用于标记函数调用时的参数，就像这样：
- en: '[PRE810]'
  id: totrans-4258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE810]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-4259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到to:在第一个输入值前写入，而for:在第二个输入值前写入。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。试图使用参数名称代替会导致错误：
- en: '[PRE811]'
  id: totrans-4260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE811]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-4261
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会始终为你填写参数标签，所以你不必担心函数调用是否正确（见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-4262
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-4263
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动完成函数并使用正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-4264
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于发送感谢信*to*一个客人*for*一份礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")看起来更像是一个句子，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-4265
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-4266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-4267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加上下划线和一个空格来去除它们。在下面的例子中，我们编写了一个计算体积的函数，它接受一个盒子的三个边作为输入。由于函数名已经明确表明你需要传入三个边，因此你实际上并不需要参数标签来使代码更具可读性。
- en: '[PRE812]'
  id: totrans-4268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE812]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-4269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在side1前加上下划线➊，在side2前加上下划线➋，在side3前加上下划线➌来移除这三个边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-4270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值而不需要任何标签。
- en: '[PRE813]'
  id: totrans-4271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE813]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-4272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"The volume of this box is 72."。如果，除了简单地打印出盒子的体积外，你还可以将结果存储到一个变量或常量中以便稍后使用，岂不是很有用吗？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-4273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-4274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重新编写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-4275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-4276
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个能装更多的东西。首先，编写一个volumeOfBox(_:_:_:)函数，返回一个整数表示盒子的体积：
- en: '[PRE814]'
  id: totrans-4277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE814]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-4278
  prefs: []
  type: TYPE_NORMAL
  zh: 要让函数有返回值，在函数的输入参数后面使用一个箭头（->）符号 ➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要数据类型。在函数体内，你使用return关键字后跟你想返回的值来返回该值
    ➋。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在你返回值之后结束。如果你在return语句后编写任何代码，它将被忽略，因为return语句会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-4279
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-4280
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-4281
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-4282
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算一个边长为6、5、3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋处，边长为8、4、2的volumeOfBox2被赋值为64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE815]'
  id: totrans-4283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE815]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-4284
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-4285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-4286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，接受一个测试成绩的数组并返回平均分。为了得到平均分，你需要将所有分数加在一起，然后除以总的分数个数。在你的Playground中输入以下代码：
- en: '[PRE816]'
  id: totrans-4287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE816]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-4288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有数值的总和。在➊处，我们定义了一个名为sum的Int类型变量，并将其初始化为0。在➋处的for-in循环遍历scores数组中的每个值，并将其加到sum变量中。当循环完成后，变量sum保存了所有分数的总和。在计算完总和后，剩下的就是将其除以分数的总数，这个总数就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-4289
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办呢？你不能把一个数除以零——在数学课上或者在Swift中都不行。在Swift中，尝试除以零会导致除以零的错误，并使程序崩溃。因此，在做除法时，一定要确保除数不为零，这就是我们在➌处通过检查scores.count
    > 0来避免的。在➍处，我们通过将所有分数的总和除以数组中的分数个数来返回平均值，使用return sum / scores.count。没错！你可以返回任何计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回sum
    / scores.count，因为它的计算结果是Int类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-4290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们也需要返回某个值，否则会出现函数缺少返回值的错误。我们通过在if语句后添加else来处理这个问题，返回0
    ➎。你可以通过在一个包含分数的数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-4291
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-4292
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的成绩数组传递给 averageOf() 函数时，正如我们在 ➊ 处所做的那样，返回的将是成绩的平均值，并显示在结果窗格中。如果你传入一个空数组，就像我们在
    ➋ 处所做的那样，返回值将是 0。
- en: '**NOTE**'
  id: totrans-4293
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-4294
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句实际上不是必须的。这是因为如果 scores.count > 0 ，那么函数已经通过 return
    sum / scores.count 结束了。所以，如果计算机已经执行了那个 if 语句，那么我们知道 scores.count > 0 一定不成立，我们完全可以直接写
    return 0 而不需要将其放在 else 中。不过，如果我们保留 else 语句，代码会更加清晰易懂。 有时候，写一些额外的代码让别人更容易理解，比使用复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-4295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-4296
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做各种神奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-4297
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第8章](text00018.html#ch08) 中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建其他类型的常量和变量，这在你开发应用时会非常有用！
- en: '**MAKING PARTY INVITATIONS**'
  id: totrans-4298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**制作派对邀请函**'
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-4299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个名为 invite(guest:) 的函数，它接受一个人的名字作为输入，并创建一个个性化的生日派对邀请函。请在你的 playground 中输入以下内容：
- en: '[PRE817]'
  id: totrans-4300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE817]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-4301
  prefs: []
  type: TYPE_NORMAL
  zh: '如果一个函数有输入参数，你需要将它放在函数名后面的括号中 ➊ 。你将输入参数的格式化方式是先写它的名字（在这个例子中是 guest ），然后是冒号（:
    ），最后是它的数据类型（在此例中是 String）。'
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-4302
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，因此当你调用这个函数时，guest 将作为参数标签。（你将在 “[参数标签](text00017.html#ch07lev1sec4)”
    中学到如何定义单独的参数名和参数标签，见 [第89页](text00017.html#page_89)）。
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-4303
  prefs: []
  type: TYPE_NORMAL
  zh: 你写输入参数的数据类型时，要放在冒号后面，就像声明变量时一样。然而，与变量声明不同的是，在定义函数参数时，你必须*始终*声明函数应当接受的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-4304
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-4305
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内使用输入参数，你只需使用它的参数名，就像使用其他常量一样 ➋ 。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-4306
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数还不够。现在函数已经定义好了，让我们在 playground 中调用它，看看会发生什么。你可以通过输入函数名，后面跟着括号内的参数标签、冒号以及参数来调用一个有输入参数的函数，如下所示：
- en: '[PRE818]'
  id: totrans-4307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE818]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-4308
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名来调用一个函数时，Xcode的自动完成功能会给你一个提示，告诉你应该传递什么参数。在这种情况下，当你开始写invite时，你会看到一个下拉菜单，类似于[图
    7-2](text00017.html#ch07fig2)。
- en: '![Image](Image00155.jpg)'
  id: totrans-4309
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-4310
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2: Xcode的自动完成功能会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-4311
  prefs: []
  type: TYPE_NORMAL
  zh: 按ENTER键自动完成函数。你的光标将移动到函数的括号内（见[图 7-3](text00017.html#ch07fig3)），此时Xcode已经自动添加了一些占位符文本，告诉你该函数期望什么类型的输入。
- en: '![Image](Image00156.jpg)'
  id: totrans-4312
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-4313
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3: Xcode等待你填写guest参数。*'
- en: '**NOTE**'
  id: totrans-4314
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-4315
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递了一个不是字符串的东西给invite(guest:)函数，比如invite(guest: 45)，你会得到一个错误，因为该函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-4316
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在String的位置输入“Cathy”或其他朋友的名字，然后按TAB键即可完成函数调用的填写。它应该看起来像[图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-4317
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-4318
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4: 一个invite(guest:)函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-4319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用invite(guest:)三次，使用你朋友们的名字：
- en: '[PRE819]'
  id: totrans-4320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE819]'
- en: 'The output looks like this:'
  id: totrans-4321
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE820]'
  id: totrans-4322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE820]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-4323
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你可以快速打印出三张派对邀请函，每张都送给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-4324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-4325
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，通过传入一个字符串数组作为参数来一次性邀请所有朋友，而不是传入单个字符串。在你编写了invite(guest:)的同一个playground中，编写以下invite(allGuests:)函数来进行测试。注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-4326
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE821]'
  id: totrans-4327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE821]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-4328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被放在方括号中 ➊。方括号声明数据类型为数组，而String表示数组中元素的数据类型。通过使用[String]，我们声明该函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-4329
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们将使用一个for-in循环来遍历我们的guest数组，并为每个客人打印邀请函。记得我们之前创建了一个打印邀请函的函数吗？让我们在这里使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本显示的是现有的行）：
- en: '[PRE822]'
  id: totrans-4330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE822]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-4331
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们在String数组allGuests中的每个guest上调用单一的invite(guest:)函数，以邀请每个人参加生日派对。你可能会想知道invite(guest:)和invite(allGuests:)是否是相同的函数。毕竟，它们都叫做invite。然而，尽管它们共享相同的名称，但它们是两个不同的函数，因为它们接受不同的输入参数。这种模式在Swift中很常见。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-4332
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`invite(allGuests:)`函数，我们首先创建一个名为`friends`的数组，然后在函数调用中使用它。
- en: '[PRE823]'
  id: totrans-4333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE823]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-4334
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后，我们用这个新的数组作为函数的输入调用该函数 ➋。这是你在调试控制台中看到的输出（-- snip --表示我们为了节省空间省略的部分）：
- en: '[PRE824]'
  id: totrans-4335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE824]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-4336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不得不为每个朋友分别写邀请函，那将是非常繁琐的。但利用函数的力量，你可以用非常少的代码行完成这一工作。试着创建你自己的朋友数组；数组的长度随你而定！然后用你新的数组作为输入，调用`invite(allGuests:)`函数。真是轻而易举！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-4337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-4338
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期临近，有些客人还没有RSVP。你想要最终确认人数，并提醒客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据客人的RSVP状态发送定制的消息给每位客人。
- en: '![Image](Image00159.jpg)'
  id: totrans-4339
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-4340
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个`String`类型的客人姓名参数和一个`Bool`类型的RSVP状态参数，后者的值可以是true或false。将以下代码输入到你的playground中：
- en: '[PRE825]'
  id: totrans-4341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE825]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-4342
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间添加逗号 ➊。每个参数都需要有一个参数名，后跟冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，且这些参数不必是相同的类型。在`sendMessage(guest:rsvped:)`函数中，我们传入一个`String`类型的guest和一个`Bool`类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-4343
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped的值，看看它是否为true ➋，然后使用if-else语句打印相应的消息。需要注意的是，函数定义中的最后一条打印语句无论rsvped值为true还是false都会执行，因为它们在if-else语句的括号外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-4344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经RSVP，他们将收到这样的消息：
- en: '[PRE826]'
  id: totrans-4345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE826]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-4346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有RSVP，他们将收到一条礼貌的提示，要求他们回复：
- en: '[PRE827]'
  id: totrans-4347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE827]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-4348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一个客人的rsvped值设置为true，另一个设置为false，这样你就能看到两个消息的效果。
- en: '[PRE828]'
  id: totrans-4349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE828]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-4350
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-4351
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会帮助你填写输入值，提供所需的参数标签。你只需要传入你想使用的值。在填写完客人姓名后，按TAB键，Xcode会将光标移到正确的位置，以便你填写下一个输入值。（参见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-4352
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-4353
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入完客人姓名后按TAB键，会将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-4354
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，如名称或数字，你会得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-4355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-4356
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，你没有在输入值前加上参数标签？你直接写：
- en: '[PRE829]'
  id: totrans-4357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE829]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-4358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图包含一个标签，会出现错误：
- en: '[PRE830]'
  id: totrans-4359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE830]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-4360
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而有些没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它与参数名称相同。然而，如果你编写的函数认为参数标签并不是使代码更加清晰所必需的，那么你可以在函数定义中显式省略它。例如，在
    print(_:) 函数中，很明显你传入的输入是一个字符串，并将其打印出来。如果每次调用 print(_:) 都必须包括一个像 inputString 这样的参数标签，实在是太麻烦了。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-4361
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现这一点。这些操作都在你首次声明函数内的参数时完成，也就是在
    func 关键字后的函数括号内。这通常在 Swift 函数中使用，以使函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6)
    展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-4362
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-4363
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-4364
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，而在函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，那么在调用函数时，它会看起来像是
    sayHello(friend:)，这就不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-4365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何编写带有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-4366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-4367
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，了解添加自定义参数标签如何使你的代码更具可读性。在你的生日派对之后，你会想给所有来宾发送感谢卡。在你的 playground 中编写以下函数：
- en: '[PRE831]'
  id: totrans-4368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE831]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-4369
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了自定义参数标签 to。类似地，在 ➋ 处，我们为 gift 参数添加了参数标签 for。参数名称
    guest ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-4370
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记这些参数，如下所示：
- en: '[PRE832]'
  id: totrans-4371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE832]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-4372
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到：在第一个输入值前写了to:，在第二个输入值前写了for:。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。试图使用参数名称代替将会导致错误：
- en: '[PRE833]'
  id: totrans-4373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE833]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-4374
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能会自动为你填充参数标签，因此你不需要担心函数调用不正确（参见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-4375
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-4376
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动补全函数并填入正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-4377
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信*to*感谢他们的礼物*for*。代码sendThankYou(to:
    "Meghan", for: "puzzle books")读起来更像一句话，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-4378
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-4379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-4380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，你可以通过在参数名称前加上一个下划线和一个空格来去除它们。在下面的示例中，我们编写了一个计算体积的函数，该函数将盒子的三条边作为输入。由于函数名称已经清楚地表明你需要传入三条边，因此实际上你不需要参数标签来使代码更具可读性。
- en: '[PRE834]'
  id: totrans-4381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE834]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-4382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在side1前面放置一个下划线（➊），side2前放置一个下划线（➋），side3前放置一个下划线（➌）来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-4383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用该函数时，只需输入参数值，而无需任何标签。
- en: '[PRE835]'
  id: totrans-4384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE835]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-4385
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。”。如果你可以将结果存储在变量或常量中，以便以后使用，而不仅仅是打印出盒子的体积，岂不是很有用吗？让我们看看如何通过返回值来做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-4386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-4387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-4388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的盒子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-4389
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，编写一个返回盒子体积的volumeOfBox(_:_:_:)函数，该函数返回一个Int类型的体积：
- en: '[PRE836]'
  id: totrans-4390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE836]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-4391
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数提供返回值，在函数的输入参数后面使用破折号和大于符号形成箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你通过使用return关键字后跟你想要返回的值来返回该值。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在你返回值后结束。如果你在return语句后再写任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-4392
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-4393
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-4394
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-4395
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE837]'
  id: totrans-4396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE837]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-4397
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-4398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-4399
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，接收一个测试分数数组并返回平均分数。为了得到平均分，你需要将分数加在一起，然后除以总的分数数量。请在你的
    playground 中输入以下代码：
- en: '[PRE838]'
  id: totrans-4400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE838]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-4401
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 变量，并将其初始化为 0。➋ 处的 for-in 循环遍历 scores
    数组中的每个值，并将其加到 sum 变量中。当循环完成后，变量 sum 将保存所有分数的总和。计算完总和后，剩下的就是将它除以分数的总数，即 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-4402
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空呢？你不能把一个数除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除以零的错误并使程序崩溃。因此，在进行除法时，务必确保你要除的数不为零，这也是我们在
    ➌ 处通过检查 scores.count > 0 来做的。在 ➍ 处，我们通过将总分除以数组中分数的数量来返回平均值，使用的是 return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回
    sum / scores.count，因为它会计算出一个 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-4403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 scores.count 不大于零时返回某个值，否则我们会得到一个函数缺少返回值的错误。我们通过在 if 语句中添加 else
    来处理这个问题，返回 0 ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-4404
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-4405
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像在 ➊ 处那样将一个完整的测试分数数组传递给 averageOf() 函数时，分数的平均值将被返回并显示在结果窗格中。如果你传递一个空数组，像在
    ➋ 处那样，返回值将是 0。
- en: '**NOTE**'
  id: totrans-4406
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-4407
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句其实并不必要。这是因为如果 scores.count > 0 ，那么函数已经通过 return
    sum / scores.count 结束了。所以如果程序已经越过了那个 if 语句，我们就知道 scores.count > 0 肯定不为真，这时我们可以直接返回
    0，而不需要将其包裹在 else 语句中。然而，如果我们保留 else 语句，代码会更加清晰，易于理解。有时候，为了让别人更容易理解，我们写多一点代码比使用一个巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-4408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-4409
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-4410
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)，我们将展示如何通过编写类定义来创建自定义对象。这将让你可以创建除 Swift 中已包含的类型之外的常量和变量，这对你开发应用程序非常有用！
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  id: totrans-4411
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个名为 invite(guest:) 的函数，它接收一个人的名字作为输入，并创建一个个性化的生日派对邀请函。将以下内容输入到你的 playground
    中：
- en: '[PRE839]'
  id: totrans-4412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE839]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-4413
  prefs: []
  type: TYPE_NORMAL
  zh: '如果一个函数有输入参数，你需要将它放在函数名后的括号内 ➊ 。你先写输入参数的名称（在这个例子中是 guest ），然后是冒号（: ），最后是它的数据类型（在这里是
    String）。'
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-4414
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也作为参数标签，因此 guest 会成为你调用该函数时的参数标签。（你将在 “[参数标签](text00017.html#ch07lev1sec4)”
    中学习如何定义单独的参数名和参数标签，详见[第 89 页](text00017.html#page_89)。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-4415
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后写输入参数的数据类型，就像声明一个变量时一样。然而，与变量声明不同的是，当定义函数参数时，你*总是*需要声明函数应该期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-4416
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-4417
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需像使用其他常量一样使用它的参数名 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-4418
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义函数本身还不够。现在函数已经定义了，让我们在 playground 中调用它，看看会发生什么。你可以通过输入函数名后跟括号、参数标签、冒号和参数值来调用一个带有输入参数的函数，像这样：
- en: '[PRE840]'
  id: totrans-4419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE840]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-4420
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写出函数名来调用一个函数时，Xcode 的自动完成功能会给你一个关于应该传入什么参数的提示。在这种情况下，当你开始输入 invite 时，你会看到一个下拉菜单，如[图
    7-2](text00017.html#ch07fig2)所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-4421
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-4422
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成功能会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-4423
  prefs: []
  type: TYPE_NORMAL
  zh: 按ENTER键自动完成函数。光标会移动到函数的括号内（参见[图7-3](text00017.html#ch07fig3)），Xcode已经自动添加了一些占位符文本，告诉你该函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-4424
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-4425
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：Xcode正在等待你填写guest参数。*'
- en: '**NOTE**'
  id: totrans-4426
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-4427
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递给invite(guest:)的不是字符串，比如invite(guest: 45)，你会得到一个错误，因为函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-4428
  prefs: []
  type: TYPE_NORMAL
  zh: 只需输入"Cathy"或其他朋友的名字来代替String，然后按TAB键完成函数调用的填写。它应该看起来像[图7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-4429
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-4430
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：邀请（guest:）函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-4431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用invite(guest:)三次，使用你自己朋友的名字：
- en: '[PRE841]'
  id: totrans-4432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE841]'
- en: 'The output looks like this:'
  id: totrans-4433
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE842]'
  id: totrans-4434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE842]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-4435
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你可以快速打印三份派对邀请函，每份都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-4436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-4437
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个一次性邀请所有朋友的函数，通过传递一个包含多个字符串的数组作为参数，而不是单个字符串。在你编写invite(guest:)函数的同一个playground中，编写以下invite(allGuests:)函数来进行测试。请注意，参数名称现在是复数形式，因为我们一次会邀请多个嘉宾。
- en: '![Image](Image00158.jpg)'
  id: totrans-4438
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE843]'
  id: totrans-4439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE843]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-4440
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被放在方括号中➊。方括号声明数据类型为数组，而String表示数组中值的数据类型。通过使用[String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-4441
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数中，我们希望使用for-in循环遍历我们的guest数组，并为每个嘉宾打印一份邀请函。记得我们之前创建了一个打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本显示的是现有的代码行）：
- en: '[PRE844]'
  id: totrans-4442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE844]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-4443
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个嘉宾调用单数形式的invite(guest:)函数，邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟，它们都叫invite。尽管它们有相同的名字，但它们是两个不同的函数，因为它们接受的输入参数不同。这是你在Swift中经常会遇到的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-4444
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE845]'
  id: totrans-4445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE845]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-4446
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组➊。然后，我们使用新数组作为函数的输入来调用该函数➋。这是你将在调试控制台中看到的输出（-- snip --表示我们为了节省空间省略的部分行）：
- en: '[PRE846]'
  id: totrans-4447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE846]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-4448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为每个朋友写邀请函，那将是非常繁琐的工作。但凭借函数的强大功能，你只需要几行代码就完成了。试着创建自己的朋友数组，随便多加几个！然后用你新创建的数组作为输入调用invite(allGuests:)函数。真是轻而易举！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-4449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-4450
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期临近，有些客人还没有回复RSVP。你想要最终确认人数，并告知客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据每个客人的RSVP状态，向他们发送定制消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-4451
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-4452
  prefs: []
  type: TYPE_NORMAL
  zh: 你新创建的函数将接受两个输入参数：一个用于客人姓名的String参数和一个用于RSVP状态的Bool参数，RSVP状态可以是true或false。在你的playground中输入以下代码：
- en: '[PRE847]'
  id: totrans-4453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE847]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-4454
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加逗号➊。每个参数都需要有一个参数名，后面跟着冒号和该参数的数据类型。你可以创建一个接受任意数量输入参数的函数，而且这些参数不一定需要是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传入一个String类型的guest和一个Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-4455
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped的值，看看它是否为true ➋，然后通过if-else语句打印出相应的消息。注意，函数定义中的最后一条print语句会在rsvped值为true或false时都执行，因为它们位于if-else语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-4456
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复RSVP，他们将收到以下消息：
- en: '[PRE848]'
  id: totrans-4457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE848]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-4458
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有回复，他们将收到一封礼貌的通知，请求他们尽快回复：
- en: '[PRE849]'
  id: totrans-4459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE849]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-4460
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。试着将一个客人的rsvped值设置为true，另一个设置为false，这样你就可以看到两种消息的效果了。
- en: '[PRE850]'
  id: totrans-4461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE850]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-4462
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-4463
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全会帮助你填写输入值，为你提供参数标签。你只需要传入你想使用的值。填写完客人姓名后，按TAB键，Xcode会自动将光标移到下一个输入值的位置。（参见[图7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-4464
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-4465
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：输入客人姓名后按TAB键，光标将跳转到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-4466
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你rsvped的数据类型。将占位符文本Bool替换为true或false。如果你试图传入其他内容，如名字或数字，系统会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-4467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-4468
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到调用print(_:)时，输入值前没有参数标签吗？你应该写成：
- en: '[PRE851]'
  id: totrans-4469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE851]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-4470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加标签，也会报错：
- en: '[PRE852]'
  id: totrans-4471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE852]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-4472
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它将与参数名称相同。然而，如果你写一个函数，并且认为参数标签对于使代码更清晰不是必需的，那么你可以在函数定义中显式省略它。例如，在`print(_:)`函数中，显然你传入的输入是一个将要打印的字符串。如果每次调用`print(_:)`都必须包含像`inputString`这样的参数标签，那将非常麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-4473
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为每个参数创建一个与参数名称不同的参数标签。你通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现这一点。所有这些操作都在你首次声明函数括号内的参数时进行，这些参数位于`func`关键字后面。在
    Swift 函数中，通常这样做是为了让函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-4474
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-4475
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：`sayHello()`函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-4476
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)`函数的输入参数是`friend`，参数标签是`to`，在函数调用中传入的参数是"Colin"。如果没有单独的参数标签，当你调用函数时，它看起来会像`sayHello(friend:)`，这听起来不像完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-4477
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将看看如何编写带有自定义参数标签的函数。我们还会向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-4478
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-4479
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例，看看如何添加自定义参数标签可以使你的代码更具可读性。生日派对结束后，你会想要给所有的客人写感谢信。在你的 Playground 中写下以下函数：
- en: '[PRE853]'
  id: totrans-4480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE853]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-4481
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的`guest`参数添加了自定义参数标签`to`。同样，在 ➋ 处，我们为`gift`参数添加了参数标签`for`。函数内部用`guest`
    ➌ 和`gift` ➍ 来引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-4482
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用时，参数标签`to`和`for`用于标记参数，像这样：
- en: '[PRE854]'
  id: totrans-4483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE854]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-4484
  prefs: []
  type: TYPE_NORMAL
  zh: '这里你可以看到，to: 被写在函数调用中第一个输入值之前，而for: 被写在第二个输入值之前。如果一个参数有自定义的参数标签，那么在函数调用中必须使用它。试图使用参数名称代替会导致错误：'
- en: '[PRE855]'
  id: totrans-4485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE855]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-4486
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填充参数标签，所以你不需要担心错误地调用函数（见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-4487
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-4488
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成功能填充了正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-4489
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个示例中，函数用于向客人发送感谢信，感谢礼物。代码`sendThankYou(to:
    "Meghan", for: "puzzle books")`看起来更像一句话，而不是`sendThankYou(guest: "Meghan", gift:
    "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-4490
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-4491
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-4492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加下划线和空格来移除它们。在以下示例中，我们编写了一个计算体积的函数，该函数以盒子的三条边作为输入。因为函数名称已经清楚地表明需要传入三条边，所以实际上不需要参数标签来提高代码的可读性。
- en: '[PRE856]'
  id: totrans-4493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE856]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-4494
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处将`side1`、在 ➋ 处将`side2`、在 ➌ 处将`side3`前面添加下划线，来移除这些参数的标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-4495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE857]'
  id: totrans-4496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE857]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-4497
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。”如果你能够将盒子的体积结果存储在变量或常量中，以便后续使用，而不仅仅是打印它，这不是更有用吗？让我们了解如何使用返回值来做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-4498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-4499
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-4500
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-4501
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个盒子能装更多的东西。首先，编写一个`volumeOfBox(_:_:_:)`函数，返回盒子体积的整数（Int）：
- en: '[PRE858]'
  id: totrans-4502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE858]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-4503
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数提供返回值，可以在函数的输入参数之后使用破折号和大于号来形成一个箭头（->），然后输入返回值的数据类型 ➊。注意，返回值不需要提供名称，只需提供数据类型即可。在函数体内，通过使用`return`关键字后跟要返回的值来返回该值
    ➋。如果编写的函数有返回值，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果在`return`语句之后再写任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-4504
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-4505
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的盒子调用函数以查看其效果：
- en: '![](Image00165.jpg)'
  id: totrans-4506
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-4507
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)`函数计算了边长为6、5和3的盒子的体积，返回值90被存储在一个名为`volumeOfBox1`的常量中。在
    ➋ 处，边长为8、4和2的`volumeOfBox2`被赋值为64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE859]'
  id: totrans-4508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE859]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-4509
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串“Box 1 is the bigger box.”。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-4510
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-4511
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据某个条件返回不同的值。让我们写一个函数，它接受一个测试成绩数组并返回平均分。为了得到平均值，你需要将所有分数加起来，然后除以总的分数数目。在你的
    Playground 中输入以下代码：
- en: '[PRE860]'
  id: totrans-4512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE860]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-4513
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 Int 变量，并将其初始值设为 0。在 ➋ 处的 `for-in` 循环会遍历
    `scores` 数组中的每一个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量将包含所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数量，这只是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-4514
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空呢？你不能将一个数除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并使程序崩溃。因此，在进行除法时，一定要确保除数不为零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来做到的。在 ➍ 处，我们通过将总分除以数组中分数的数量来返回平均值，使用 `return sum /
    scores.count`。没错！你可以返回任何会评估为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 `sum /
    scores.count`，因为它会评估为一个 Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-4515
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们还需要返回一个值，否则会出现缺少返回值的错误。我们通过在 `if` 语句中添加 `else`
    来处理这个问题，返回 0 ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-4516
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-4517
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传入一个完整的测试成绩数组时，正如我们在 ➊ 处所做的，函数会返回成绩的平均值并显示在结果面板中。如果你传入一个空数组，正如我们在 ➋ 处所做的，返回值将是
    0。
- en: '**NOTE**'
  id: totrans-4518
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-4519
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，`else` 语句包裹 `return 0` 并不是必须的。因为如果 `scores.count > 0`，函数已经通过 `return
    sum / scores.count` 结束了。所以如果程序已经通过了那个 `if` 语句，我们就知道 `scores.count > 0` 一定不成立，我们可以直接写
    `return 0`，而不需要将其包裹在 `else` 语句中。然而，如果我们保留 `else` 语句，代码会更加清晰易懂。有时候，写一些额外的代码以便让其他人更容易理解，比使用复杂的快捷方式要更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-4520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-4521
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建并调用你自己的函数！函数在编程中被广泛使用，用来做各种神奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-4522
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08)，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建具有 Swift 中未包含类型的常量和变量，这在你创建应用时会非常有用！
- en: '[PRE861]'
  id: totrans-4523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE861]'
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-4524
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要在函数名后的括号中包含它 ➊。你格式化输入参数时，首先写出它的名字（在这个例子中是 guest），然后是一个冒号（:），最后是它的数据类型（在这个例子中是
    String）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-4525
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也作为参数标签，因此 guest 会在你调用这个函数时作为参数标签。（你将在 “[参数标签](text00017.html#ch07lev1sec4)”
    中学习如何定义不同的参数名和参数标签，见 [第 89 页](text00017.html#page_89)。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-4526
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后面写出输入参数的数据类型，就像声明变量时一样。然而，不同于变量声明，定义函数参数时，你必须*始终*声明函数应该期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-4527
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-4528
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需像使用其他常量一样使用它的参数名 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-4529
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数仅仅是不够的。既然函数已经定义好了，让我们在 playground 中调用它，看看会发生什么。你可以通过输入函数名，后跟括号中的参数标签、冒号和参数，来调用一个带有输入参数的函数，像这样：
- en: '[PRE862]'
  id: totrans-4530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE862]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-4531
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写出函数名来调用一个函数时，Xcode 的自动完成功能会给你一些关于应该传递什么参数的提示。在这种情况下，当你开始写 invite 时，你会看到一个下拉菜单，像
    [图 7-2](text00017.html#ch07fig2) 中那样。
- en: '![Image](Image00155.jpg)'
  id: totrans-4532
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-4533
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成会展示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-4534
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键来自动完成函数。光标会移到函数的括号中（见 [图 7-3](text00017.html#ch07fig3)），在这里 Xcode
    会自动添加一些占位文本，告诉你函数期望什么类型的输入。
- en: '![Image](Image00156.jpg)'
  id: totrans-4535
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-4536
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-4537
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-4538
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递一个不是字符串的参数给 invite(guest:)，比如 invite(guest: 45)，你会得到一个错误，因为这个函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-4539
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 位置输入 "Cathy" 或其他朋友的名字，然后按 TAB 键完成函数调用。它应该像 [图 7-4](text00017.html#ch07fig4)
    那样。
- en: '![Image](Image00157.jpg)'
  id: totrans-4540
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-4541
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个邀请（guest:）函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-4542
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何填写函数调用，调用 invite(guest:) 三次，使用你自己朋友的名字：
- en: '[PRE863]'
  id: totrans-4543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE863]'
- en: 'The output looks like this:'
  id: totrans-4544
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果看起来像这样：
- en: '[PRE864]'
  id: totrans-4545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE864]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-4546
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你可以快速打印出三张派对邀请函，每张都送给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-4547
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次邀请所有的朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-4548
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写一个一次性邀请所有朋友的函数，方法是传入一个字符串数组作为参数，而不是一个单独的字符串。在你编写invite(guest:)函数的同一个playground中，编写以下invite(allGuests:)函数来进行测试。注意，参数名现在是复数形式，因为我们将一次邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-4549
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE865]'
  id: totrans-4550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE865]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-4551
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被方括号括起来 ➊。方括号声明数据类型为数组，而String表示数组中值的数据类型。通过使用[String]，我们声明这个函数的输入为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-4552
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数中，我们需要使用for-in循环遍历我们的客人数组，并为每个客人打印一份邀请函。记得我们刚刚创建了一个打印邀请函的函数吗？我们在这里就可以使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本表示现有的行）：
- en: '[PRE866]'
  id: totrans-4553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE866]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-4554
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对字符串数组allGuests中的每个客人调用单个invite(guest:)函数，邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟，它们的名字都叫invite。然而，尽管它们的名字相同，但它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常看到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-4555
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后我们将在函数调用中使用它。
- en: '[PRE867]'
  id: totrans-4556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE867]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-4557
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个由六个朋友组成的数组 ➊。然后，我们用这个新的数组作为函数的输入调用函数 ➋。这是你在调试控制台中看到的输出（-- snip -- 显示了我们为了节省空间省略的行）：
- en: '[PRE868]'
  id: totrans-4558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE868]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-4559
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为这些朋友逐个写邀请函，那会非常麻烦。但是借助函数的力量，你已经用很少的代码行完成了这项工作。试着创建你自己的朋友数组，尽量让它长一点！然后用你的新数组作为输入调用invite(allGuests:)函数。真是轻松简单！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-4560
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-4561
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近，而一些客人还没有回复是否参加。你想要确定最终的出席人数，并让客人们知道带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据客人的RSVP状态向每位客人发送定制信息。
- en: '![Image](Image00159.jpg)'
  id: totrans-4562
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-4563
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个字符串类型的参数，用于客人的名字，以及一个布尔值类型的参数，用于RSVP状态，可以是true或false。在你的playground中输入以下代码：
- en: '[PRE869]'
  id: totrans-4564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE869]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-4565
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数需要多个输入参数时，你需要在每个参数之间加上逗号 ➊ 。每个参数都需要有一个参数名称，后跟冒号和数据类型。你可以创建一个包含任意数量输入参数的函数，且这些参数不必是相同类型的。在
    sendMessage(guest:rsvped:) 函数中，我们传递了一个 String 类型的 guest 和一个 Bool 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-4566
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 的值，看它是否为 true ➋ ，然后使用 if-else 语句打印相应的信息。请注意，函数定义中的最终打印语句会在
    rsvped 值为 true 或 false 时都执行，因为它们位于 if-else 语句的外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-4567
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的宾客已经回复，他们会收到这条消息：
- en: '[PRE870]'
  id: totrans-4568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE870]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-4569
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提示，要求他们回复：
- en: '[PRE871]'
  id: totrans-4570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE871]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-4571
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。试着将一个宾客的 rsvped 值设为 true，另一个宾客的设为 false，这样你就可以看到两个消息的效果。
- en: '[PRE872]'
  id: totrans-4572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE872]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-4573
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调用一个有多个输入参数的函数和调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-4574
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能将帮助你填写输入值，提供相应的参数标签。你只需传入你想使用的值。填写完宾客姓名后，按下 TAB 键，Xcode 会将光标移动到你需要填写下一个输入值的位置。（见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-4575
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-4576
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入完宾客姓名后按下 TAB 键，将把光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-4577
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他类型的内容，比如姓名或数字，将会出现错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-4578
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-4579
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到在调用 print(_:) 时，没有在输入值前面加上参数标签？你写的是：
- en: '[PRE873]'
  id: totrans-4580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE873]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-4581
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包括一个标签，也会出现错误：
- en: '[PRE874]'
  id: totrans-4582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE874]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-4583
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，且该标签与参数名称相同。然而，如果你编写函数时觉得参数标签对于代码清晰性并不必要，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，传入的输入显然是一个将要被打印的字符串。如果每次调用 print(_:) 都必须包含类似 inputString 这样的参数标签，岂不是很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-4584
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号，最后是参数的数据类型来实现。在你首次声明函数参数时，所有这些操作都会在
    func 关键字后的函数括号内完成。在 Swift 函数中，这种做法通常会使函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)
    展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-4585
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-4586
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-4587
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，而函数调用时传入的参数是 "Colin"。如果没有单独的参数标签，当你调用函数时，它会像
    sayHello(friend:) 那样，这听起来不像完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-4588
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将介绍如何编写带有自定义参数标签的函数。我们还将展示如何编写一个函数，其中完全省略参数标签。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-4589
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-4590
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例，看看添加自定义参数标签如何使你的代码更具可读性。生日派对后，你会想给所有的客人发送感谢信。在你的 playground 中编写以下函数：
- en: '[PRE875]'
  id: totrans-4591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE875]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-4592
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了一个自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名
    guest ➌ 和 gift ➍ 用于函数内部引用参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-4593
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于标记函数调用时的参数，像这样：
- en: '[PRE876]'
  id: totrans-4594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE876]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-4595
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 写在函数调用的第一个输入值之前，for: 写在第二个输入值之前。如果一个参数有自定义参数标签，你必须在函数调用时使用它。尝试使用参数名代替会导致错误：'
- en: '[PRE877]'
  id: totrans-4596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE877]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-4597
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成会始终为你填充参数标签，因此你不必担心函数调用错误（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-4598
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-4599
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成函数并提供正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-4600
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信 *to*，以感谢他们的礼物
    *for*。代码 sendThankYou(to: "Meghan", for: "puzzle books") 比起 sendThankYou(guest:
    "Meghan", gift: "puzzle books") 更像一句完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-4601
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-4602
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-4603
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加上下划线和一个空格来去除它们。在下面的示例中，我们编写了一个计算体积的函数，接收盒子的三个边长作为输入。因为函数名称已经明确表明你需要传入三个边长，所以其实不需要参数标签来提高代码可读性。
- en: '[PRE878]'
  id: totrans-4604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE878]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-4605
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处给`side1`、➋处给`side2`、➌处给`side3`加上下划线，去除了这些参数的标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-4606
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用该函数时，只需输入参数值而不需要标签。
- en: '[PRE879]'
  id: totrans-4607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE879]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-4608
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"这个盒子的体积是72。"。如果你能将体积值存储到一个变量或常量中，以便稍后使用，而不仅仅是打印出来，那该多好呢？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-4609
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-4610
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-4611
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-4612
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想要知道哪个盒子能装更多的东西。首先，编写一个`volumeOfBox(_:_:_:)`函数，返回盒子的体积（Int类型）：
- en: '[PRE880]'
  id: totrans-4613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE880]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-4614
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数添加返回值，在函数的输入参数后➊使用破折号和大于符号（->）表示箭头，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，使用`return`关键字后跟你想返回的值➋来返回该值。如果你编写了一个返回值的函数，那么你*必须*在函数内返回该值，否则会报错。函数在返回值后结束。如果你在`return`语句之后再写任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-4615
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-4616
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数并传入两个不同的盒子，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-4617
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-4618
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`volumeOfBox(_:_:_:)`函数计算了一个长宽高分别为6、5和3的盒子的体积，返回值90被存储在一个名为`volumeOfBox1`的常量中。在➋处，长宽高分别为8、4和2的`volumeOfBox2`的值被赋为64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE881]'
  id: totrans-4619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE881]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-4620
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台中看到字符串"Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-4621
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-4622
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据某些条件返回不同的值。让我们编写一个函数，接受一个测试分数的数组并返回平均分。要计算平均分，首先将所有分数加起来，然后除以分数的总数。请在你的Playground中输入以下代码：
- en: '[PRE882]'
  id: totrans-4623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE882]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-4624
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始值设置为 0。在 ➋ 处的 for-in 循环会遍历
    scores 数组中的每个值，并将其加到 sum 变量中。当循环完成时，sum 变量保存了所有分数的总和。在计算出总和后，剩下的工作就是将其除以分数的总数，这就是
    scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-4625
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办？你不能把东西除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，试图除以零会导致除零错误并使程序崩溃。因此，在进行除法运算时，始终确保你要除的数不是零，这就是我们在
    ➌ 处通过检查 scores.count > 0 来做到的。在 ➍ 处，我们通过将分数总和除以数组中分数的数量来返回平均值，使用 return sum /
    scores.count 。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 sum /
    scores.count ，因为它计算出的结果是 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-4626
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们也需要返回一个值，否则会出现函数缺少 return 的错误。我们通过在 if 语句中添加 else
    来处理这个问题，返回 0 ➎ 。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-4627
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-4628
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 averageOf() 函数时，正如我们在 ➊ 处所做的，函数会返回分数的平均值，并显示在结果面板中。如果你传递的是一个空数组，就像我们在
    ➋ 处所做的，返回值就是 0。
- en: '**NOTE**'
  id: totrans-4629
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-4630
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句其实并不是必须的。这是因为如果 scores.count > 0 ，那么函数已经会通过 return
    sum / scores.count 结束。因此，如果计算机已经通过了那个 if 语句，我们就知道 scores.count > 0 一定不为真，我们可以直接写一个
    return 0，而不需要将其包含在 else 中。然而，如果我们保留 else 语句，代码会更清晰、更容易理解。有时候，写一点额外的代码，让别人更容易理解，比使用巧妙的捷径更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-4631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-4632
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚给你的 Swift 工具包增加了一个重要工具——创建并调用你自己的函数！函数在编程中被广泛使用，可以做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-4633
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将允许你创建类型不同于 Swift 中已有类型的常量和变量，这对于创建应用程序非常有用！
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  id: totrans-4634
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数有输入参数，你需要将它包含在函数名后的括号中 ➊。你需要先写输入参数的名称（在这个例子中是 `guest`），然后是冒号（`:`），最后是它的数据类型（在这个例子中是
    `String`）。
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-4635
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也作为参数标签，所以当你调用这个函数时，`guest` 将作为参数标签。（你将在“[参数标签](text00017.html#ch07lev1sec4)”中学习如何定义独立的参数名和参数标签，见[第
    89 页](text00017.html#page_89)。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-4636
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后写输入参数的数据类型，就像声明变量时一样。然而，与变量声明不同的是，在定义函数参数时，你*必须*始终声明函数应期望的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-4637
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-4638
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需使用它的参数名，就像使用任何其他常量一样 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-4639
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数仅仅是不够的。现在函数已经定义，我们来在 Playground 中调用它看看会发生什么。你可以通过输入函数名后跟括号内的参数标签、冒号以及参数，来调用一个有输入参数的函数，像这样：
- en: '[PRE883]'
  id: totrans-4640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE883]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-4641
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名来调用一个函数时，Xcode 的自动补全会给你提供关于你应该传入函数的提示。在这个例子中，当你开始写 `invite` 时，你会看到一个下拉菜单，如同在[图
    7-2](text00017.html#ch07fig2)中所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-4642
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-4643
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动补全会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-4644
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键来自动补全函数。你的光标将移到函数的括号内（参见[图 7-3](text00017.html#ch07fig3)），Xcode 会自动添加一些占位符文本，告诉你该函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-4645
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-4646
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 `guest` 参数。*'
- en: '**NOTE**'
  id: totrans-4647
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-4648
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传入的不是字符串类型的参数给 `invite(guest:)`，例如 `invite(guest: 45)`，你会得到一个错误，因为这个函数期望一个字符串类型的参数。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-4649
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 `String` 位置输入 "Cathy" 或其他朋友的名字，然后按下 TAB 键完成函数调用的填写。它应该像[图 7-4](text00017.html#ch07fig4)所示。
- en: '![Image](Image00157.jpg)'
  id: totrans-4650
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-4651
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 `invite(guest:)` 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-4652
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用，调用 `invite(guest:)` 三次，使用你自己朋友的名字：
- en: '[PRE884]'
  id: totrans-4653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE884]'
- en: 'The output looks like this:'
  id: totrans-4654
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE885]'
  id: totrans-4655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE885]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-4656
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 `invite(guest:)` 函数，你能够快速打印三张派对邀请函，每张都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-4657
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-4658
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，通过传入一个字符串数组作为参数一次性邀请所有朋友，而不是传递一个单独的字符串。在你写了invite(guest:)函数的同一个游乐场中，编写以下invite(allGuests:)函数来测试它。注意，现在参数名是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-4659
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE886]'
  id: totrans-4660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE886]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-4661
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被方括号包围➊。方括号表示数据类型是数组，而String表示数组中元素的数据类型是字符串。通过使用[String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-4662
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们希望使用for-in循环遍历我们的客人数组，并为每个客人打印邀请函。还记得我们刚才创建的打印邀请函的函数吗？我们在这里也可以使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本表示现有的代码行）：
- en: '[PRE887]'
  id: totrans-4663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE887]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-4664
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对字符串数组allGuests中的每个客人调用单数形式的invite(guest:)函数，以邀请每个人参加生日派对。你可能会问，invite(guest:)和invite(allGuests:)是不是同一个函数。毕竟它们都有“invite”这个名字。然而，尽管它们有相同的名字，它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常会看到的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-4665
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后将其作为输入传递给函数调用。
- en: '[PRE888]'
  id: totrans-4666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE888]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-4667
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组➊。然后我们用新的数组作为函数的输入来调用这个函数➋。这是你在调试控制台中看到的输出（-- snip -- 表示我们为节省空间而省略的行）：
- en: '[PRE889]'
  id: totrans-4668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE889]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-4669
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不得不为每个朋友写邀请函，那将会花费很多时间。但借助函数的力量，你可以用非常少的代码行完成这一任务。试着创建你自己的朋友数组，想做多长就做多长！然后使用新的数组作为输入，调用invite(allGuests:)函数。真是轻松愉快！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-4670
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-4671
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你的聚会日期临近，但有些客人还没有回复邀请。你想要获得最终的参加人数，并通知客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据每个客人的RSVP状态向他们发送自定义消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-4672
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-4673
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个字符串类型的参数表示客人的名字，另一个布尔类型的参数表示是否回复邀请（RSVP），值为true或false。请在你的游乐场中输入以下代码：
- en: '[PRE890]'
  id: totrans-4674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE890]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-4675
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数有多个输入参数时，你需要在每个参数之间加上逗号➊。每个参数都需要有一个参数名，后面跟着冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，而且这些参数不一定是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传入了一个String类型的guest和一个Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-4676
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped的值，看它是否为true ➋，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最后打印语句无论rsvped的值是true还是false都会执行，因为它们位于if-else语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-4677
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复RSVP，他们会收到这条消息：
- en: '[PRE891]'
  id: totrans-4678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE891]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-4679
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提示，要求他们回应：
- en: '[PRE892]'
  id: totrans-4680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE892]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-4681
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一个客人的rsvped值设置为true，另一个客人的设置为false，这样你就能看到两个消息的实际效果。
- en: '[PRE893]'
  id: totrans-4682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE893]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-4683
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个具有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-4684
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会帮助你填写输入值，为你提供参数标签。你只需要传入你想要使用的值。填写完客人姓名后，按TAB键，Xcode会将光标移动到你需要填写下一个输入值的位置。（参见[图7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-4685
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-4686
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：输入完客人姓名后按TAB键，光标会自动跳到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-4687
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你rsvped的数据类型。将占位符文本Bool替换为true或false。如果你尝试传入其他值，比如名字或数字，系统会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-4688
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-4689
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，当你调用print(_:)时，你没有在输入值前加上参数标签？你写的是：
- en: '[PRE894]'
  id: totrans-4690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE894]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-4691
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，系统会报错：
- en: '[PRE895]'
  id: totrans-4692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE895]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-4693
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用时有参数标签，有些没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且标签名称与参数名相同。然而，如果你编写的函数中，参数标签不影响代码的清晰度，那么你可以在函数定义中显式省略它。例如，在print(_:)函数中，很明显你传入的是一个将被打印的字符串。如果每次调用print(_:)都要包括像inputString这样的参数标签，那会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-4694
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现这一点。你在第一次声明函数括号内的参数时就需要完成这一过程。这通常在Swift函数中使用，以使函数调用看起来更像一个句子。[图7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-4695
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-4696
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：sayHello()函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-4697
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:)函数的输入参数是friend，参数标签是*to*，函数调用中传入的参数是"Colin"。如果没有单独的参数标签，当你调用函数时，它看起来像sayHello(friend:)，这听起来就不那么像一个完整的句子了。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-4698
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何编写带有自定义参数标签的函数。我们还会向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-4699
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-4700
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，展示如何通过添加自定义参数标签让你的代码更具可读性。在你的生日派对后，你可能想向所有客人发送感谢信。在你的playground中写下以下函数：
- en: '[PRE896]'
  id: totrans-4701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE896]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-4702
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊位置，我们为传递给函数的guest参数添加了一个自定义参数标签*to*。类似地，在➋位置，我们为gift参数添加了一个参数标签*for*。参数名称guest
    ➌ 和gift ➍用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-4703
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 *to* 和 *for* 用于在调用函数时标记参数，像这样：
- en: '[PRE897]'
  id: totrans-4704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE897]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-4705
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到，*to:*写在第一个输入值前面，*for:*写在第二个输入值前面。如果一个参数有自定义的参数标签，你在调用函数时必须使用它。试图用参数名称代替它会导致错误：
- en: '[PRE898]'
  id: totrans-4706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE898]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-4707
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能会自动为你填充参数标签，所以你不必担心函数调用是否正确（请参见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-4708
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-4709
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-4710
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信*to*（感谢）一份礼物*for*（送出）礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")看起来更像一个完整的句子，而不像sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-4711
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-4712
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-4713
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前添加一个下划线和一个空格来去除它们。在以下示例中，我们编写了一个用于计算体积的函数，该函数接收盒子的三条边作为输入。因为函数名已经很明确地表明了你需要传入三条边，所以实际上你并不需要参数标签来提高代码的可读性。
- en: '[PRE899]'
  id: totrans-4714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE899]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-4715
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 side1 前面加上下划线（_）来去掉侧面参数的标签，side2 在 ➋，side3 在 ➌ 也同样如此。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-4716
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需要输入参数值，而无需任何标签。
- en: '[PRE900]'
  id: totrans-4717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE900]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-4718
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。”如果你不仅仅打印出盒子的体积，而是将结果存储到一个变量或常量中以便稍后使用，那岂不是很有用吗？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-4719
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-4720
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-4721
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的盒子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-4722
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，该函数返回一个表示盒子体积的整数：
- en: '[PRE901]'
  id: totrans-4723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE901]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-4724
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数一个返回值，使用一个破折号和大于号组成箭头（->），紧跟在函数输入参数后面 ➊，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要数据类型。在函数体内，通过使用
    return 关键字后跟你希望返回的值来返回这个值 ➋。如果你写了一个返回值的函数，那么你*必须*在函数内部返回这个值，否则会报错。函数在返回值后结束。如果在
    return 语句后写了任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-4725
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-4726
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数，使用两个不同的盒子来查看它的实际效果：
- en: '![](Image00165.jpg)'
  id: totrans-4727
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-4728
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，volumeOfBox(_:_:_:) 函数计算了一个盒子的体积，边长分别为 6、5 和 3，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在 ➋，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在，让我们打印出哪个盒子更大的信息：
- en: '[PRE902]'
  id: totrans-4729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE902]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-4730
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串“Box 1 是更大的盒子”输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-4731
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-4732
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接收一个测试分数的数组并返回平均分数。为了计算平均值，你需要将分数相加，然后除以总的分数数量。在你的
    playground 中输入以下代码：
- en: '[PRE903]'
  id: totrans-4733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE903]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-4734
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在➊，我们定义了一个名为 sum 的 Int 类型变量，并将其初始化为 0。在➋的 for-in 循环中，遍历 scores
    数组中的每个值，并将其添加到 sum 变量中。当循环完成时，sum 变量保存了所有成绩的总和。在我们计算总和之后，剩下的就是将其除以成绩的总数，即 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-4735
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组是空的呢？你不能将数字除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会引发除以零的错误并使程序崩溃。因此，在进行除法时，始终确保你要除的数不是零，这就是我们在
    ➌ 处通过检查 scores.count > 0 来做的。在 ➍ 处，我们通过将总和除以成绩数组中的成绩数量来返回平均值，即 return sum / scores.count。没错！你可以返回任何计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回
    sum / scores.count，因为它的结果是一个 Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-4736
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 scores.count 不大于零时返回一个值，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加一个 else
    来处理这个问题，返回 0 ➎。你可以通过调用函数来测试代码，传入一个包含成绩的数组和一个空数组：
- en: '![](Image00166.jpg)'
  id: totrans-4737
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-4738
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的成绩数组传递给 averageOf() 函数时，正如我们在➊所做的，函数会返回成绩的平均值并显示在结果面板中。如果你传入一个空数组，正如我们在➋所做的，返回值是
    0。
- en: '**NOTE**'
  id: totrans-4739
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-4740
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不是必要的。这是因为如果 scores.count > 0，那么函数会在 return
    sum / scores.count 时提前结束。所以如果计算机已经通过了那个 if 语句，我们就知道 scores.count > 0 一定不成立，我们可以直接用
    return 0，而不需要放在 else 中。然而，如果我们保留 else 语句，代码会更加清晰易懂。有时候，写一点额外的代码让其他人更容易理解，比使用巧妙的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-4741
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-4742
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种了不起的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-4743
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这样，你就可以创建除 Swift 中已包含的类型之外的常量和变量，这在创建应用程序时会非常有用！
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  id: totrans-4744
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数名也充当参数标签，因此在调用该函数时，guest 将是参数标签。（你将在 “[参数标签](text00017.html#ch07lev1sec4)”
    章节学习如何定义不同的参数名和参数标签，见 [第 89 页](text00017.html#page_89)。）
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-4745
  prefs: []
  type: TYPE_NORMAL
  zh: 你在输入参数后面加上冒号声明数据类型，就像声明变量时一样。然而，与变量声明不同的是，在定义函数参数时，你必须*始终*声明函数应当接受的数据类型；这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-4746
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-4747
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需像使用其他常量一样使用它的参数名 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-4748
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义函数还不够。现在函数已定义，让我们在 playground 中调用它看看会发生什么。你可以通过输入函数名，后跟括号中的参数标签、冒号和参数来调用一个具有输入参数的函数，像这样：
- en: '[PRE904]'
  id: totrans-4749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE904]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-4750
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过编写函数名来调用函数时，Xcode 的自动补全会给你一个关于应该传递什么给函数的提示。在这种情况下，当你开始写 invite 时，你会看到像 [图
    7-2](text00017.html#ch07fig2) 中那样的下拉菜单。
- en: '![Image](Image00155.jpg)'
  id: totrans-4751
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-4752
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动补全将向你展示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-4753
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键来自动完成函数的编写。你的光标将移动到函数的括号内（见 [图 7-3](text00017.html#ch07fig3)），此时 Xcode
    已自动添加了一些占位符文本，告诉你该函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-4754
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-4755
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-4756
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-4757
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传入不是字符串的东西给 invite(guest:)（例如 invite(guest: 45)），你将得到一个错误，因为该函数期望一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-4758
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 位置输入 “Cathy” 或其他朋友的名字，然后按 TAB 键完成函数调用的填写。它应该看起来像 [图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-4759
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-4760
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-4761
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，使用你自己的朋友的名字调用 invite(guest:) 三次：
- en: '[PRE905]'
  id: totrans-4762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE905]'
- en: 'The output looks like this:'
  id: totrans-4763
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE906]'
  id: totrans-4764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE906]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-4765
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你能够快速打印三张派对邀请函，每张都发送给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-4766
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-4767
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过传入一个字符串数组作为参数，而不是单个字符串，来编写一个一次性邀请所有朋友的函数。在你编写了 invite(guest:) 的同一个 playground
    中，编写以下 invite(allGuests:) 函数来进行测试。请注意，参数名称现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-4768
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00158.jpg)'
- en: '[PRE907]'
  id: totrans-4769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE907]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-4770
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到`[String]`被放在方括号中 ➊ 。方括号声明数据类型为数组，而`String`表示数组中值的类型。通过使用`[String]`，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-4771
  prefs: []
  type: TYPE_NORMAL
  zh: 在`invite(allGuests:)`函数内部，我们需要使用`for-in`循环遍历我们的宾客数组，并为每个宾客打印一份邀请函。还记得我们刚才创建了一个打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到`invite(allGuests:)`函数中（灰色文本表示现有的代码行）：
- en: '[PRE908]'
  id: totrans-4772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE908]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-4773
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`for-in`循环中，我们会对`String`数组`allGuests`中的每个宾客调用单独的`invite(guest:)`函数，邀请每个人参加生日派对。你可能会想，`invite(guest:)`和`invite(allGuests:)`是同一个函数吗？毕竟，它们都是叫做`invite`。然而，尽管名称相同，它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常看到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-4774
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`invite(allGuests:)`函数，我们首先创建一个名为`friends`的数组，然后在函数调用中使用它。
- en: '[PRE909]'
  id: totrans-4775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE909]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-4776
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后，我们将这个新数组作为函数的输入调用函数 ➋ 。这是你将在调试控制台中看到的输出（-- snip --
    显示了我们为节省空间省略的行）：
- en: '[PRE910]'
  id: totrans-4777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE910]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-4778
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为这些朋友逐个写邀请函，那将会非常繁琐。但通过函数的力量，你可以用非常少的代码行完成这项任务。试着创建你自己的朋友数组，尽量多加一些朋友！然后将你的新数组作为输入调用`invite(allGuests:)`函数。简直轻而易举！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-4779
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向你的宾客发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-4780
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期越来越近，而一些宾客还没有回复。你想要最终确认人数，并让宾客们知道要带上泳衣，因为这将是一个滑水道派对。你可以编写一个函数，根据每个宾客的RSVP状态发送定制的信息。
- en: '![Image](Image00159.jpg)'
  id: totrans-4781
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-4782
  prefs: []
  type: TYPE_NORMAL
  zh: 你新的函数将接受两个输入参数：一个`String`类型的参数表示宾客的名字，一个`Bool`类型的参数表示RSVP状态，值为`true`或`false`。在你的playground中输入以下代码：
- en: '[PRE911]'
  id: totrans-4783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE911]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-4784
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加一个逗号 ➊ 。每个参数都需要有一个参数名，后面跟一个冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，而且这些参数不必是相同类型。在`sendMessage(guest:rsvped:)`函数中，我们传入了一个`String`类型的`guest`和一个`Bool`类型的`rsvped`。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-4785
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 `rsvped` 的值是否为 `true` ➋，然后使用 if-else 语句打印相应的消息。还要注意，函数定义中的最后几行 `print`
    语句无论 `rsvped` 值是 `true` 还是 `false` 都会执行，因为它们位于 if-else 语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-4786
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的嘉宾已确认出席，他们会收到以下消息：
- en: '[PRE912]'
  id: totrans-4787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE912]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-4788
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有确认出席，他们会收到一条礼貌的提示，要求他们回复：
- en: '[PRE913]'
  id: totrans-4789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE913]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-4790
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。试着将一个嘉宾的 `rsvped` 值设置为 `true`，另一个嘉宾的设置为 `false`，这样你就可以看到两个消息的实际效果。
- en: '[PRE914]'
  id: totrans-4791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE914]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-4792
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个具有多个输入参数的函数，与调用只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-4793
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能将帮助你填写输入值，并为你提供参数标签。你所需要做的就是传入你想要使用的值。在填写嘉宾名字后，按 TAB 键，Xcode 会将光标移到下一个输入框，方便你继续填写下一个输入值。（参见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-4794
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-4795
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入嘉宾名字后按 TAB 键，会将光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-4796
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 `Bool` 替换为 `true` 或 `false`。如果你尝试传入其他内容，如名字或数字，你会得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-4797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-4798
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，当你调用 `print(_:)` 时，并没有在输入值前加上参数标签？你写的是：
- en: '[PRE915]'
  id: totrans-4799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE915]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-4800
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你会得到一个错误：
- en: '[PRE916]'
  id: totrans-4801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE916]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-4802
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用时会有参数标签，而一些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，且标签与参数名相同。然而，如果你编写函数时觉得某个参数标签不必要来使代码更清晰，那么你可以在函数定义中显式省略它。例如，在
    `print(_:)` 函数中，很明显你传入的是一个字符串，将会被打印出来。如果每次调用 `print(_:)` 都需要包括像 `inputString`
    这样的参数标签，那就很烦人了。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-4803
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号，然后是参数的数据类型来实现。在你首次声明函数参数时，这些都要写在
    `func` 关键字后面的小括号内。在 Swift 函数中，通常会这么做，以使函数调用看起来更像一句话。[图 7-6](text00017.html#ch07fig6)
    说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-4804
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-4805
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：`sayHello()` 函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-4806
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，函数调用时会显示为
    sayHello(friend:)，听起来就不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-4807
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-4808
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-4809
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示添加自定义参数标签如何使你的代码更具可读性。在你的生日派对之后，你会想给所有客人发送感谢信。在你的 Playground 中编写以下函数：
- en: '[PRE917]'
  id: totrans-4810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE917]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-4811
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了一个自定义的参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名称
    guest ➌ 和 gift ➍ 用来引用函数内部的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-4812
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 被用来标记函数调用时的参数，如下所示：
- en: '[PRE918]'
  id: totrans-4813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE918]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-4814
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 写在函数调用中的第一个输入值前面，for: 写在第二个输入值前面。如果一个参数有自定义的参数标签，在函数调用时必须使用它。如果试图使用参数名称代替，会导致错误：'
- en: '[PRE919]'
  id: totrans-4815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE919]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-4816
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会自动为你填写参数标签，所以你不必担心错误地调用函数（请参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-4817
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-4818
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成函数并填写正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-4819
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用介词，如 *to*、*from* 或 *with*，作为参数标签。在这个例子中，函数用于向客人发送感谢信 *to* 一位客人 *for*
    一份礼物。代码 sendThankYou(to: "Meghan", for: "puzzle books") 读起来比 sendThankYou(guest:
    "Meghan", gift: "puzzle books") 更像一个完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-4820
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-4821
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-4822
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加下划线和空格来移除它们。在以下示例中，我们编写了一个计算体积的函数，它接受一个盒子的三个边长作为输入。因为函数名已经清楚地表明你需要传入三个边长，所以不需要额外的参数标签来使代码更具可读性。
- en: '[PRE920]'
  id: totrans-4823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE920]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-4824
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 side1 前面加下划线 ➊、side2 前面加下划线 ➋、side3 前面加下划线 ➌ 来移除边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-4825
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而无需任何标签。
- en: '[PRE921]'
  id: totrans-4826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE921]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-4827
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出 "这个盒子的体积是 72。"。如果你能将结果存储在变量或常量中，以便后续使用，而不仅仅是打印盒子的体积，这不是更有用吗？让我们看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-4828
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-4829
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-4830
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-4831
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并想知道哪个可以装更多的东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，它返回一个表示盒子体积的 Int：
- en: '[PRE922]'
  id: totrans-4832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE922]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-4833
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给一个函数提供返回值，在函数的输入参数后面使用一个短横线和大于号来组成一个箭头 (->)，然后输入返回值的数据类型。注意，你不需要为返回值提供名字，只需要提供数据类型。在函数体内，使用
    return 关键字并跟上你要返回的值来返回结果 ➋。如果你写了一个返回值的函数，那么你*必须*在函数内返回该值，否则会报错。函数在返回值后结束。如果在 return
    语句之后写任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-4834
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-4835
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的盒子调用该函数，查看其效果：
- en: '![](Image00165.jpg)'
  id: totrans-4836
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-4837
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算了边长分别为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 volumeOfBox1
    的常量中。在 ➋ 处，边长分别为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条消息，说明哪个盒子更大：
- en: '[PRE923]'
  id: totrans-4838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE923]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-4839
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台中看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-4840
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-4841
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，接受一个成绩数组并返回平均成绩。为了得到平均值，你将所有成绩加起来，然后除以成绩的总数。请输入以下代码到你的
    Playground：
- en: '[PRE924]'
  id: totrans-4842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE924]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-4843
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 变量，并将其初始化为 0。在 ➋ 处，for-in 循环遍历了 scores
    数组中的每个值，并将其加到 sum 变量中。当循环完成时，变量 sum 存储了所有成绩的总和。计算出总和后，剩下的就是将总和除以成绩的数量，这个数量就是 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-4844
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能将某个数除以零——无论是在数学课上，还是在Swift中。在Swift中，试图除以零会导致除零错误，并使程序崩溃。因此，在进行除法操作时，务必确保你要除的数不是零，这就是我们在➌处通过检查`score.count
    > 0`来避免的情况。在➍处，我们通过将成绩总和除以数组中的成绩数量来返回平均值，使用`return sum / score.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给一个新变量的步骤，直接返回`sum
    / score.count`，因为它会计算为`Int`类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-4845
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`score.count`不大于零时，我们还需要返回某个值，否则会出现缺少返回值的错误。我们通过在`if`语句中添加`else`来处理这一点，返回0
    ➎。你可以通过调用这个函数，传入一个包含成绩的数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-4846
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-4847
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传入`averageOf()`函数时，就像我们在➊所做的那样，返回值是成绩的平均值，并显示在结果面板中。如果你传入一个空数组，就像我们在➋所做的那样，返回值将是0。
- en: '**NOTE**'
  id: totrans-4848
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-4849
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕`return 0`的`else`语句其实并非必要。这是因为，如果`score.count > 0`，那么函数已经通过`return
    sum / score.count`结束了。所以，如果计算机已经执行过`if`语句，那么我们知道`score.count > 0`一定不为真，我们可以直接使用`return
    0`，而不需要将其放在`else`语句中。然而，如果我们保留`else`语句，代码会更清晰易懂。有时候，为了让别人更容易理解，写一些额外的代码比使用一个巧妙的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-4850
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-4851
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以完成各种令人惊奇的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-4852
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建常量和变量，使用除Swift中已有类型以外的类型，在你开发应用时非常有用！
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  id: totrans-4853
  prefs: []
  type: TYPE_NORMAL
  zh: 你在冒号后面写输入参数的数据类型，就像声明变量时一样。然而，与变量声明不同，定义函数参数时，你必须*始终*声明函数应当期望的数据类型；在这里没有类型推断。
- en: '![Image](Image00154.jpg)'
  id: totrans-4854
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-4855
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，只需像使用其他常量一样使用它的参数名 ➋。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-4856
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数是不够的。现在函数已经定义好了，让我们在playground里调用它，看看会发生什么。你可以通过输入函数名，后面跟上括号内的参数标签、冒号和参数来调用带有输入参数的函数，如下所示：
- en: '[PRE925]'
  id: totrans-4857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE925]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-4858
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写出函数名来调用一个函数时，Xcode的自动补全会提示你应该传递给函数什么内容。在这个例子中，当你开始写`invite`时，你会看到一个下拉菜单，如[图
    7-2](text00017.html#ch07fig2)所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-4859
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-4860
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode的自动补全将向你展示一个函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-4861
  prefs: []
  type: TYPE_NORMAL
  zh: 按下ENTER键来自动完成函数。你的光标将移动到函数的括号中（见[图 7-3](text00017.html#ch07fig3)），此时Xcode会自动添加一些占位符文本，告诉你该函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-4862
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-4863
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode在等待你填写guest参数。*'
- en: '**NOTE**'
  id: totrans-4864
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-4865
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传入不是字符串的东西到`invite(guest:)`，比如`invite(guest: 45)`，你将得到一个错误，因为该函数期望传入的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-4866
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在`String`的位置输入"Cathy"或另一个朋友的名字，然后按TAB键完成函数调用的填写。它应该像[图 7-4](text00017.html#ch07fig4)一样。
- en: '![Image](Image00157.jpg)'
  id: totrans-4867
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-4868
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个`invite(guest:)`函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-4869
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用`invite(guest:)`三次，使用你自己朋友的名字：
- en: '[PRE926]'
  id: totrans-4870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE926]'
- en: 'The output looks like this:'
  id: totrans-4871
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE927]'
  id: totrans-4872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE927]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-4873
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的`invite(guest:)`函数，你能够快速打印出三份派对邀请函，每一份都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-4874
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-4875
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过传入一个字符串数组作为参数，而不是单个字符串，来编写一个一次性邀请所有朋友的函数。在你编写了`invite(guest:)`的同一个playground里，编写以下的`invite(allGuests:)`函数来进行测试。注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-4876
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE928]'
  id: totrans-4877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE928]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-4878
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到`[String]`在方括号中 ➊。方括号声明数据类型为数组，而`String`表示数组中值的数据类型。通过使用`[String]`，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-4879
  prefs: []
  type: TYPE_NORMAL
  zh: 在`invite(allGuests:)`函数内部，我们将使用`for-in`循环来遍历我们的客人数组，并为每个客人打印一份邀请函。还记得我们刚刚创建的那个打印邀请函的函数吗？让我们在这里使用它！将以下内容添加到你的`invite(allGuests:)`函数中（灰色文本显示的是现有的行）：
- en: '[PRE929]'
  id: totrans-4880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE929]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-4881
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对每个`allGuests`字符串数组中的客人调用单一的`invite(guest:)`函数，邀请每位客人参加生日派对。你可能会想，`invite(guest:)`和`invite(allGuests:)`是相同的函数吗？毕竟它们都叫`invite`。然而，尽管它们共享同一个名称，但它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常会看到的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-4882
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`invite(allGuests:)`函数，我们首先创建一个名为`friends`的数组，然后将其作为函数调用的输入。
- en: '[PRE930]'
  id: totrans-4883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE930]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-4884
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组➊。然后我们用这个新数组作为函数的输入来调用函数➋。这是你将在调试控制台中看到的输出（-- snip --表示我们为了节省空间而省略的行）：
- en: '[PRE931]'
  id: totrans-4885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE931]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-4886
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每位朋友写出邀请函，那将需要很多工作。但借助函数的力量，你只用了很少的代码行就完成了这个任务。试着创建你自己的朋友数组，长度随你喜欢！然后用你的新数组作为输入调用`invite(allGuests:)`函数。简直是小菜一碟！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-4887
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向你的客人发送信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-4888
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你派对的日期即将临近，而一些客人还没有回复RSVP。你想要得到最终的客人数量，并告诉他们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据客人的RSVP状态向每个客人发送自定义消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-4889
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-4890
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个用于客人姓名的字符串参数和一个用于RSVP状态的布尔值参数，RSVP状态可以是true或false。请输入以下代码到你的Playground中：
- en: '[PRE932]'
  id: totrans-4891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE932]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-4892
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号➊。每个参数需要有一个参数名称，后跟冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，而且这些参数不需要是相同类型的。在`sendMessage(guest:rsvped:)`函数中，我们传入了一个字符串作为`guest`参数，一个布尔值作为`rsvped`参数。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-4893
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查`rsvped`值是否为true➋，然后使用if-else语句打印相应的消息。请注意，函数定义中的最终`print`语句无论`rsvped`值为true还是false都会执行，因为它们位于if-else语句的外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-4894
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已回复RSVP，他们会收到以下消息：
- en: '[PRE933]'
  id: totrans-4895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE933]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-4896
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一封礼貌的提示，要求他们回复：
- en: '[PRE934]'
  id: totrans-4897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE934]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-4898
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一位客人的RSVP状态设置为true，另一位客人的RSVP状态设置为false，这样你就能看到两个消息的实际效果。
- en: '[PRE935]'
  id: totrans-4899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE935]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-4900
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个具有多个输入参数的函数与调用只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-4901
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全会通过为你提供参数标签来帮助你填写输入值。你只需要传入你想要使用的值。填写完客人姓名后，按下TAB键，Xcode会将光标放在你需要的位置，以便填写下一个输入值。（参见[图7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-4902
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-4903
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：在输入客人姓名后按下TAB键会将光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-4904
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你rsvped的数据类型。将占位符文本Bool替换为true或false。如果你尝试传入其他内容，如名字或数字，会出现错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-4905
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-4906
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，当你调用print(_:)时，输入值前面没有参数标签？你写的是：
- en: '[PRE936]'
  id: totrans-4907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE936]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-4908
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加标签，你会遇到错误：
- en: '[PRE937]'
  id: totrans-4909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE937]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-4910
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它将与参数名称相同。然而，如果你编写一个函数并且觉得参数标签并不必要以使代码更清晰，那么你可以在函数定义中明确省略它。例如，在print(_:)函数中，很明显你传入的输入是一个将被打印的字符串。每次调用print(_:)时都需要包含像inputString这样的参数标签会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-4911
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。所有这些都在你第一次声明函数括号内的参数时完成，这通常是在func关键字后。Swift函数中经常这样做，以使函数调用看起来更像一句完整的句子。[图7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-4912
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-4913
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：sayHello()函数具有自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-4914
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:)函数的输入参数是friend，参数标签是to，函数调用时传入的参数是"Colin"。如果没有单独的参数标签，调用该函数时看起来会像sayHello(friend:)，听起来就不太像一句完整的句子了。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-4915
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-4916
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-4917
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看添加自定义参数标签如何使你的代码更具可读性。生日派对后，你可能想给所有客人发送感谢信。在你的playground中编写以下函数：
- en: '[PRE938]'
  id: totrans-4918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE938]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-4919
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了一个自定义的参数标签 to。类似地，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名称
    guest ➌ 和 gift ➍ 用于函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-4920
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，像这样：
- en: '[PRE939]'
  id: totrans-4921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE939]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-4922
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 在第一个输入值前写出，for: 在第二个输入值前写出。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。试图使用参数名称会导致错误：'
- en: '[PRE940]'
  id: totrans-4923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE940]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-4924
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填写参数标签，因此你不必担心错误地调用函数（请参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-4925
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-4926
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-4927
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用介词如 *to*、*from* 或 *with* 作为参数标签。在这个例子中，函数用于将感谢信 *to* 一位客人 *for* 一份礼物。代码
    sendThankYou(to: "Meghan", for: "puzzle books") 更像一句句子，而不像 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-4928
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-4929
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-4930
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线和空格来移除它们。在下面的示例中，我们编写了一个用于计算体积的函数，该函数以盒子的三个边长为输入。因为函数名已经明确表示需要传入三个边长，所以实际上你并不需要参数标签来使代码更具可读性。
- en: '[PRE941]'
  id: totrans-4931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE941]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-4932
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 side1 前面加上下划线 ➊、在 side2 前面加上下划线 ➋、在 side3 前面加上下划线 ➌，去除了边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-4933
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，不需要任何标签。
- en: '[PRE942]'
  id: totrans-4934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE942]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-4935
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。" 如果你不仅仅是打印盒子的体积，而是希望将结果存储在一个变量或常量中以供以后使用，这不是更有用吗？让我们了解如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-4936
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-4937
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-4938
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-4939
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个盒子能装更多的东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，该函数返回盒子的体积（Int）：
- en: '[PRE943]'
  id: totrans-4940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE943]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-4941
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数设置返回值，可以在函数输入参数➊之后，使用短横线和大于号形成箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值命名，只需指定数据类型。在函数体内，你通过使用
    `return` 关键字后跟你想要返回的值来返回该值➋。如果你编写了一个返回值的函数，那么你*必须*在函数内返回该值，否则会出现错误。函数在你返回值之后结束。如果你在
    `return` 语句之后编写任何代码，它会被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-4942
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-4943
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，以查看它的运行效果：
- en: '![](Image00165.jpg)'
  id: totrans-4944
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-4945
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，`volumeOfBox(_:_:_:)` 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 `volumeOfBox1`
    的常量中。在➋，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE944]'
  id: totrans-4946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE944]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-4947
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-4948
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-4949
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，该函数接受一个测试分数数组并返回平均分。为了得到平均分，你将所有分数加起来，然后除以总分数。请在你的
    Playground 中输入以下代码：
- en: '[PRE945]'
  id: totrans-4950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE945]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-4951
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在➊，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始值设置为 0。➋处的 `for-in` 循环遍历
    `scores` 数组中的每个值，并将其添加到 `sum` 变量中。循环完成后，`sum` 变量将保存所有分数的总和。计算出总和后，剩下的就是将其除以总分数，即
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-4952
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办？你不能除以零——在数学课上或者在 Swift 中也是如此。在 Swift 中，尝试除以零将会引发除以零的错误并崩溃你的程序。因此，在进行除法时，一定要确保你要除的数不为零，这就是我们在
    ➌ 处检查 `scores.count > 0` 的原因。在 ➍ 处，我们通过将所有分数的总和除以数组中分数的个数来返回平均分，使用 `return sum
    / scores.count`。没错！你可以返回任何评估为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 `sum
    / scores.count`，因为它评估为 `Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-4953
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一个值，否则会出现缺少返回值的错误。我们通过在 `if` 语句中添加一个 `else`
    来处理这一点，该 `else` 返回 0➎。你可以通过对一个分数数组和一个空数组调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-4954
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-4955
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 averageOf() 函数时，就像我们在 ➊ 中所做的那样，函数会返回分数的平均值，并显示在结果面板中。如果你传递一个空数组，就像我们在
    ➋ 中所做的那样，返回值会是 0 。
- en: '**NOTE**'
  id: totrans-4956
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-4957
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不是必需的。因为如果 scores.count > 0 ，那么函数已经通过 return
    sum / scores.count 结束了。所以，如果程序已经跳过了那个 if 语句，那么我们知道 scores.count > 0 肯定不成立，这时我们可以直接使用
    return 0，而无需将其放在 else 语句中。然而，如果我们保留 else 语句，代码会更加清晰，更容易理解。有时候，写多一点代码来让别人更清楚地理解比使用巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-4958
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-4959
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-4960
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第8章](text00018.html#ch08) 中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建其他类型的常量和变量，而不仅仅是
    Swift 中已经包含的类型，这在你创建应用时会非常有用！
- en: '![Image](Image00154.jpg)'
  id: totrans-4961
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00154.jpg)'
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-4962
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需像使用其他常量一样使用它的参数名 ➋ 。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-4963
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义函数还不够。现在函数已经定义，我们来在 Playground 中调用它，看看会发生什么。你可以通过输入函数名称，后跟括号内的参数标签、冒号和参数，来调用带有输入参数的函数，如下所示：
- en: '[PRE946]'
  id: totrans-4964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE946]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-4965
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过输入函数名称来调用函数时，Xcode 的自动补全会给你一个提示，告诉你应该传递什么参数给函数。在这种情况下，当你开始输入 invite 时，你会看到一个下拉菜单，像
    [图 7-2](text00017.html#ch07fig2) 中显示的那样。
- en: '![Image](Image00155.jpg)'
  id: totrans-4966
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-4967
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动补全会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-4968
  prefs: []
  type: TYPE_NORMAL
  zh: 按 ENTER 键来自动完成函数。光标会移动到函数的括号内（参见 [图 7-3](text00017.html#ch07fig3)），此时 Xcode
    已自动添加了一些占位符文本，告诉你函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-4969
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-4970
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-4971
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-4972
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递一个不是字符串的参数给 invite(guest:) 函数，例如 invite(guest: 45)，你会遇到错误，因为该函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-4973
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 位置输入 "Cathy" 或其他朋友的名字，然后按 TAB 键完成函数调用。它应该看起来像 [图 7-4](text00017.html#ch07fig4)
    中那样。
- en: '![Image](Image00157.jpg)'
  id: totrans-4974
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-4975
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-4976
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，接下来调用`invite(guest:)`三次，使用你朋友们的名字：
- en: '[PRE947]'
  id: totrans-4977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE947]'
- en: 'The output looks like this:'
  id: totrans-4978
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE948]'
  id: totrans-4979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE948]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-4980
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的`invite(guest:)`函数，你能够快速打印三张派对邀请函，每张都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-4981
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-4982
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，通过传入一个字符串数组作为参数，而不是单个字符串，一次性邀请所有的朋友。在你编写了`invite(guest:)`的同一个游乐场中，编写以下`invite(allGuests:)`函数进行测试。注意，参数名称现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-4983
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE949]'
  id: totrans-4984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE949]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-4985
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到`[String]`被放在方括号中 ➊。方括号声明了数据类型为数组，而`String`表示数组中值的数据类型。通过使用`[String]`，我们声明了这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-4986
  prefs: []
  type: TYPE_NORMAL
  zh: 在`invite(allGuests:)`函数内部，我们需要使用一个`for-in`循环来遍历我们的客人数组，并为每个客人打印一张邀请函。记得我们刚才创建了一个打印邀请函的函数吗？我们可以在这里使用它！将以下代码添加到你的`invite(allGuests:)`函数中（灰色文本表示现有的代码）：
- en: '[PRE950]'
  id: totrans-4987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE950]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-4988
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`for-in`循环中，我们对`String`数组`allGuests`中的每个客人调用单一的`invite(guest:)`函数，邀请每个人参加生日派对。你可能会想，`invite(guest:)`和`invite(allGuests:)`是不是同一个函数？毕竟，它们的名字都是`invite`。然而，尽管它们有相同的名字，但它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常会看到的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-4989
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`invite(allGuests:)`函数，我们首先创建一个名为`friends`的数组，然后在函数调用中使用它。
- en: '[PRE951]'
  id: totrans-4990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE951]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-4991
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个包含六个朋友的数组 ➊。然后，我们将这个新数组作为函数的输入，调用该函数 ➋。你在调试控制台中看到的输出是这样的（`-- snip
    --`表示我们为了节省空间省略的部分）：
- en: '[PRE952]'
  id: totrans-4992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE952]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-4993
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友写一封邀请函，那将是非常繁琐的工作。但借助函数的力量，你只用了很少的代码行就完成了这个任务。试着创建你自己的朋友数组，长度随你决定！然后用这个新的数组作为输入，调用`invite(allGuests:)`函数。简直轻松得很！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-4994
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-4995
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近，而一些客人还没有回复是否参加。你想确认最终的客人名单，并告诉他们带上泳衣，因为这是一个滑水派对。你可以编写一个函数，根据他们的RSVP状态给每个客人发送自定义消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-4996
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-4997
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个 String 类型的参数用于客人姓名，另一个 Bool 类型的参数用于 RSVP 状态，可以是 true 或 false。请在你的
    Playground 中输入以下代码：
- en: '[PRE953]'
  id: totrans-4998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE953]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-4999
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数接受多个输入参数时，参数之间用逗号分隔 ➊。每个参数需要有一个参数名，后面跟一个冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，并且这些参数的类型可以不同。在
    sendMessage(guest:rsvped:) 函数中，我们传入一个 String 类型的 guest 和一个 Bool 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-5000
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 的值是否为 true ➋，然后使用 if-else 语句打印相应的消息。还要注意，函数定义中的最后一条 print
    语句无论 rsvped 值是 true 还是 false 都会执行，因为它们在 if-else 语句的花括号之外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-5001
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复 RSVP，他们将收到这条消息：
- en: '[PRE954]'
  id: totrans-5002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE954]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-5003
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提示，请他们回复：
- en: '[PRE955]'
  id: totrans-5004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE955]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-5005
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一位客人的 rsvped 值设置为 true，另一位客人的设置为 false，这样你就可以看到两个消息的实际效果。
- en: '[PRE956]'
  id: totrans-5006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE956]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-5007
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用带有多个输入参数的函数与调用只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-5008
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会帮助你填写输入值，为你提供参数标签。你需要做的只是传入你想使用的值。在填写完客人姓名后，按 TAB 键，Xcode 会把光标放到你需要的位置，以便填写下一个输入值。（参见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-5009
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-5010
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入完客人姓名后按 TAB 键将光标移至下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-5011
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他类型的值，比如姓名或数字，你会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-5012
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-5013
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，你并没有在输入值前面加上参数标签？你写的是：
- en: '[PRE957]'
  id: totrans-5014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE957]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-5015
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加标签，你会遇到错误：
- en: '[PRE958]'
  id: totrans-5016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE958]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-5017
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中带有参数标签，有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，且该标签与参数名相同。然而，如果你编写的函数认为不需要参数标签来让代码更加清晰，你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，很明显你传入的是一个字符串，将被打印出来。如果每次调用 print(_:) 都必须包含像 inputString 这样的参数标签，那会让人觉得很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-5018
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现这一点。你在第一次声明函数括号内的参数时就完成这一切。Swift
    函数中经常这样做，以使函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-5019
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-5020
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-5021
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，而在函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，当你调用函数时，它会像
    sayHello(friend:) 这样，这样听起来不太像完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-5022
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将看看如何编写具有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-5023
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-5024
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，看看如何添加自定义参数标签可以使你的代码更具可读性。生日派对结束后，你会想要给所有的客人发送感谢信。在你的 Playground 中写下以下函数：
- en: '[PRE959]'
  id: totrans-5025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE959]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-5026
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了参数标签 for。参数名称 guest
    ➌ 和 gift ➍ 用于引用函数内部的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-5027
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，像这样：
- en: '[PRE960]'
  id: totrans-5028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE960]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-5029
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里你可以看到，to: 被写在函数调用中的第一个输入值之前，而 for: 被写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。试图使用参数名称代替会导致错误：'
- en: '[PRE961]'
  id: totrans-5030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE961]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-5031
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全会始终为你填充参数标签，因此你不必担心错误地调用函数（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-5032
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-5033
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成函数并使用正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-5034
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人 *发送* 感谢信 *因为* 礼物。代码
    sendThankYou(to: "Meghan", for: "puzzle books") 看起来更像一句话，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-5035
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-5036
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-5037
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线和空格来去掉它们。在下面的示例中，我们编写了一个用于计算体积的函数，该函数接收盒子的三个边作为输入。因为函数名称已经明确说明需要传入三个边，所以你其实不需要参数标签来提高代码的可读性。
- en: '[PRE962]'
  id: totrans-5038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE962]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-5039
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 的 side1、➋ 的 side2 和 ➌ 的 side3 前面加下划线来去除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-5040
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，不需要任何标签。
- en: '[PRE963]'
  id: totrans-5041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE963]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-5042
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "The volume of this box is 72."。如果你不仅仅是打印盒子的体积，而是能够将结果存储在一个变量或常量中以便以后使用，这是不是很有用呢？让我们来了解一下如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-5043
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-5044
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-5045
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-5046
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个盒子能装更多的东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，该函数返回一个整数类型的盒子体积：
- en: '[PRE964]'
  id: totrans-5047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE964]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-5048
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数返回值，使用一个破折号和大于号组成箭头（->）紧接在函数的输入参数之后 ➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你通过使用
    return 关键字后跟你想要返回的值来返回该值 ➋。如果你编写一个返回值的函数，那么你*必须*在函数内返回该值，否则会出现错误。函数在返回值后结束。如果你在
    return 语句后在函数内写任何代码，它将被忽略，因为 return 会使函数退出。
- en: '![Image](Image00164.jpg)'
  id: totrans-5049
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-5050
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的盒子调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-5051
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-5052
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，volumeOfBox(_:_:_:) 函数计算一个边长分别为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在 ➋，边长分别为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE965]'
  id: totrans-5053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE965]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-5054
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-5055
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-5056
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接受一个测试成绩数组，并返回平均成绩。为了计算平均值，你需要将所有成绩加起来，然后除以成绩的总数。请输入以下代码到你的
    playground 中：
- en: '[PRE966]'
  id: totrans-5057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE966]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-5058
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个 Int 类型的变量 sum，并将其初始化为 0。➋ 处的 for-in 循环遍历 scores
    数组中的每个值，并将其加到 sum 变量中。当循环完成时，变量 sum 就存储了所有分数的总和。计算出总和后，剩下的就是将它除以分数的总数，这就是 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-5059
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组是空的呢？你不能除以零——在数学课上不行，在 Swift 中也不行。在 Swift 中，尝试除以零会导致除零错误并崩溃你的程序。因此，在进行除法运算时，始终确保你要除的数不是零，这就是我们在
    ➌ 处通过检查 scores.count > 0 来做的。然后在 ➍ 处，我们通过将总分除以数组中的分数数量，使用 return sum / scores.count
    返回平均值。没错！你可以返回任何求值为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 sum / scores.count，因为它求值为
    Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-5060
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们也需要返回一些值，否则会出现缺少返回值的错误。我们通过在 if 语句中添加 else 来处理这个问题，返回
    0 ➎ 。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-5061
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-5062
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传入一个完整的测试成绩数组到 averageOf() 函数中，正如我们在 ➊ 处所做的，返回的将是成绩的平均值，并显示在结果窗格中。如果你传入一个空数组，如我们在
    ➋ 处所做的，返回值将是 0。
- en: '**NOTE**'
  id: totrans-5063
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-5064
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实不是必须的。因为如果 scores.count > 0 ，那么函数已经通过 return
    sum / scores.count 结束了。所以如果程序已经越过了那个 if 语句，我们知道 scores.count > 0 可能不成立，我们完全可以直接
    return 0，而不需要把它放在 else 里。然而，如果我们保留 else 语句，代码会更清晰、更易于理解。有时候，写一些额外的代码，比使用一个巧妙的捷径更能让其他人明白。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-5065
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-5066
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-5067
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你创建除 Swift 已经包含的类型以外的常量和变量，当你创建应用程序时，这将非常有用！
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  id: totrans-5068
  prefs: []
  type: TYPE_NORMAL
  zh: 要在函数内部使用输入参数，你只需使用它的参数名称，就像使用其他常量一样 ➋ 。
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-5069
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数还不够。现在函数已经定义，让我们在 Playground 中调用它，看看会发生什么。你可以通过输入函数名，后跟括号中的参数标签、冒号和参数，来调用带有输入参数的函数，如下所示：
- en: '[PRE967]'
  id: totrans-5070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE967]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-5071
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名来调用一个函数时，Xcode 的自动补全功能会给出关于你应该传递给函数的提示。在这种情况下，当你开始写 invite 时，你会看到一个下拉菜单，如
    [图 7-2](text00017.html#ch07fig2) 所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-5072
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-5073
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2: Xcode 的自动补全会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-5074
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键以自动完成函数调用。光标会移到函数的括号内（见 [图 7-3](text00017.html#ch07fig3)），此时 Xcode
    已自动添加了一些占位符文本，告诉你该函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-5075
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-5076
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3: Xcode 等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-5077
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-5078
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递给 invite(guest:) 的参数不是字符串，例如 invite(guest: 45)，你会得到一个错误，因为该函数期望传递的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-5079
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将 "Cathy" 或另一个朋友的名字输入到 String 的位置，然后按 TAB 键完成函数调用。它应该看起来像 [图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-5080
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-5081
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4: 一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-5082
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用，调用 invite(guest:) 三次，使用你自己朋友的名字：
- en: '[PRE968]'
  id: totrans-5083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE968]'
- en: 'The output looks like this:'
  id: totrans-5084
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下所示：
- en: '[PRE969]'
  id: totrans-5085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE969]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-5086
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你可以快速打印三张派对邀请函，每张邀请函都发送给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-5087
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-5088
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以写一个一次性邀请所有朋友的函数，通过传递一个字符串数组作为参数，而不是一个单一的字符串。在你写了 invite(guest:) 的同一个 Playground
    中，写下以下 invite(allGuests:) 函数来进行测试。注意，参数名现在是复数形式，因为我们将一次邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-5089
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE970]'
  id: totrans-5090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE970]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-5091
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到 [String] 被方括号括起来 ➊。方括号声明数据类型为数组，而 String 表示数组中值的数据类型。通过使用
    [String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-5092
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们需要使用 for-in 循环遍历我们的 guest 数组，并为每个客人打印一张邀请函。记得我们刚刚创建了一个打印邀请函的函数吗？让我们在这里使用它！将以下内容添加到你的
    invite(allGuests:) 函数中（灰色文本显示的是现有的代码行）：
- en: '[PRE971]'
  id: totrans-5093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE971]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-5094
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个guest调用单一的invite(guest:)函数，邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟它们的名字都是invite。尽管它们共享同一个名字，但它们是两个不同的函数，因为它们接受不同的输入参数。这是Swift中常见的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-5095
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE972]'
  id: totrans-5096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE972]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-5097
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后，我们将这个新数组作为函数的输入，调用该函数 ➋ 。这是你在调试控制台中看到的输出（-- snip --
    表示我们为了节省空间而省略的行）：
- en: '[PRE973]'
  id: totrans-5098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE973]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-5099
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不得不为每一个朋友写出邀请函，那会很麻烦。但是凭借函数的强大功能，你只需几行代码就完成了这个任务。试着创建你自己的朋友数组，长度随你所愿！然后用你新创建的数组作为输入，调用invite(allGuests:)函数。轻松搞定！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-5100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-5101
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近，但有些客人还没有RSVP。你希望统计最终的参与人数，并通知客人带上泳衣，因为这将是一个滑水派对。你可以写一个函数，根据每个客人的RSVP状态发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-5102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-5103
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个String类型的参数用于表示客人姓名，另一个Bool类型的参数用于表示RSVP状态，值为true或false。将以下代码输入到你的playground中：
- en: '[PRE974]'
  id: totrans-5104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE974]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-5105
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊ 。每个参数需要有一个参数名称，后跟冒号和参数的数据类型。你可以创建一个接受任意多个输入参数的函数，而且它们不必是相同的类型。在sendMessage(guest:rsvped:)函数中，我们传递了一个String类型的guest参数和一个Bool类型的rsvped参数。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-5106
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值以判断它是否为true ➋ ，然后使用if-else语句打印相应的消息。请注意，函数定义中的最后打印语句无论rsvped值是true还是false都会执行，因为它们在if-else语句的外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-5107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经RSVP，他们会收到以下消息：
- en: '[PRE975]'
  id: totrans-5108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE975]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-5109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的通知，要求他们回复：
- en: '[PRE976]'
  id: totrans-5110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE976]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-5111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用函数，看看它是如何工作的。尝试将一个客人的rsvped值设置为true，将另一个客人的rsvped值设置为false，这样你就可以看到两个消息的实际效果。
- en: '[PRE977]'
  id: totrans-5112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE977]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-5113
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个接受多个输入参数的函数和调用一个只接受一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-5114
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会帮助你填写输入值，并为你提供参数标签。你只需要传入你想使用的值。填写完客人姓名后，按 TAB 键，Xcode 会将光标放到你需要的地方，帮助你填写下一个输入值。（参见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-5115
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-5116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入客人姓名后按 TAB 键会将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-5117
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，如姓名或数字，你将会收到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-5118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-5119
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，当你调用 `print(_:)` 时，你并没有在输入值前面加上参数标签？你写的是：
- en: '[PRE978]'
  id: totrans-5120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE978]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-5121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，你将会收到错误：
- en: '[PRE979]'
  id: totrans-5122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE979]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-5123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而一些没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它与参数名称相同。然而，如果你编写函数时觉得参数标签并不必要以使代码更清晰，那么你可以在函数定义中显式省略它。例如，在
    `print(_:)` 函数中，很明显你传入的是一个字符串并且会被打印。每次调用 `print(_:)` 时都要包含像 `inputString` 这样的参数标签会显得很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-5124
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号以及参数的数据类型来做到这一点。所有这些操作都在你第一次声明函数括号内的参数时完成，这通常发生在
    `func` 关键字后面。在 Swift 函数中，这通常是为了让函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)
    展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-5125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-5126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-5127
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 `friend`，参数标签是 `to`，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，当你调用这个函数时，它会像
    `sayHello(friend:)`，这听起来就不像一句完整的句子了。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-5128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何编写带有自定义参数标签的函数。我们还将展示如何编写一个省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-5129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-5130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示如何添加自定义参数标签能使代码更具可读性。在你的生日派对结束后，你会想要给所有的客人写感谢信。在你的 playground 中编写以下函数：
- en: '[PRE980]'
  id: totrans-5131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE980]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-5132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 `guest` 参数添加了一个自定义的参数标签 `to`。类似地，在 ➋ 处，我们为 `gift` 参数添加了一个参数标签
    `for`。参数名称 `guest` ➌ 和 `gift` ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-5133
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 `to` 和 `for` 用来标记函数调用时的参数，如下所示：
- en: '[PRE981]'
  id: totrans-5134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE981]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-5135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `to:` 被写在函数调用的第一个输入值前面，`for:` 被写在第二个输入值前面。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。如果试图使用参数名称而不是标签，就会报错：
- en: '[PRE982]'
  id: totrans-5136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE982]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-5137
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填充参数标签，因此你无需担心错误地调用函数（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-5138
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-5139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-5140
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信 *to* ，感谢他送的礼物
    *for* 。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 看起来更像一句话，而不是 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-5141
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-5142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-5143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线并跟一个空格来移除它们。在下面的例子中，我们编写了一个计算体积的函数，接受盒子的三条边作为输入。由于函数名已经清楚地表明需要传入三条边，因此你实际上不需要参数标签来增加代码的可读性。
- en: '[PRE983]'
  id: totrans-5144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE983]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-5145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处为 `side1`、在 ➋ 处为 `side2`、在 ➌ 处为 `side3` 添加下划线来移除这些参数的标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-5146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，你只需输入参数值，而无需任何标签。
- en: '[PRE984]'
  id: totrans-5147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE984]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-5148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出“The volume of this box is 72.”。如果你能够将结果存储到一个变量或常量中，而不仅仅是打印盒子的体积，岂不是更有用吗？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-5149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-5150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-5151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-5152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多东西。首先，编写一个返回盒子体积的 `volumeOfBox(_:_:_:)` 函数，该函数返回一个 Int
    类型的值：
- en: '[PRE985]'
  id: totrans-5153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE985]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-5154
  prefs: []
  type: TYPE_NORMAL
  zh: 要为一个函数提供返回值，使用一个箭头符号 `->` 紧跟在函数的输入参数后面 ➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你通过使用
    `return` 关键字后跟要返回的值来返回该值 ➋。如果你编写一个返回值的函数，那么你*必须*在函数内返回该值，否则会出错。函数在返回值之后结束。如果你在
    `return` 语句后面编写任何代码，它将被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-5155
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-5156
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的箱子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-5157
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-5158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算一个边长为 6、5 和 3 的箱子的体积，返回值 90 被存储在名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在让我们打印一条信息，说明哪个箱子更大：
- en: '[PRE986]'
  id: totrans-5159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE986]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-5160
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到输出的字符串 "Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-5161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-5162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据条件返回不同的值。让我们写一个函数，它接受一个测试成绩的数组并返回平均成绩。要计算平均值，你需要将所有成绩相加，然后除以成绩的总数。在你的
    Playground 中输入以下代码：
- en: '[PRE987]'
  id: totrans-5163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE987]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-5164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义一个名为 `sum` 的 `Int` 类型变量，并将其初始值设为 0。在 ➋ 处的 `for-in`
    循环遍历 `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量保存了所有成绩的总和。计算总和后，剩下的就是将总和除以成绩的总数，即
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-5165
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组是空的呢？你不能将数字除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致“除零错误”，并且程序会崩溃。因此，在进行除法运算时，始终确保你要除的数不是零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来避免的情况。在 ➍ 处，我们通过用 `return sum / scores.count` 将所有成绩的总和除以数组中成绩的数量来返回平均值。没错！你可以返回任何计算结果是正确数据类型的表达式，这意味着我们可以跳过将计算得到的平均值赋值给新变量的步骤，直接返回
    `sum / scores.count`，因为它的结果是一个 `Int` 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-5166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一些值，否则会出现一个错误，提示函数缺少返回值。我们通过在 `if` 语句中添加
    `else` 来处理这个问题，返回 0 ➎。你可以通过在一个成绩数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-5167
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-5168
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给averageOf()函数时，就像我们在➊所做的那样，返回的是这些分数的平均值，并显示在结果面板中。如果你传入一个空数组，就像我们在➋所做的那样，返回值是0。
- en: '**NOTE**'
  id: totrans-5169
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-5170
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句实际上并不是必需的。因为如果scores.count > 0，那么函数已经会在return sum
    / scores.count处结束。所以如果程序已经跳过了那个if语句，我们就知道scores.count > 0一定不成立，这时我们可以直接写return
    0，而不需要放在else语句中。然而，如果我们保留else语句，代码会更加清晰，更容易理解。有时候，为了让别人更容易理解，写一点额外的代码比使用复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-5171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-5172
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，能够做各种神奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-5173
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你创建除了Swift内置类型之外的常量和变量，这在你创建应用时会非常有用！
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  id: totrans-5174
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义一个函数还不够。现在函数已经定义了，让我们在playground中调用它，看看会发生什么。你可以通过输入函数名称，后跟括号内的参数标签、冒号和参数，来调用带有输入参数的函数，像这样：
- en: '[PRE988]'
  id: totrans-5175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE988]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-5176
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过输入函数名称来调用一个函数时，Xcode的自动完成功能会给你一个提示，告诉你应该传入什么样的参数。在这种情况下，当你开始写invite时，你会看到一个下拉菜单，就像在[图7-2](text00017.html#ch07fig2)中看到的那样。
- en: '![Image](Image00155.jpg)'
  id: totrans-5177
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-5178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：Xcode的自动完成功能会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-5179
  prefs: []
  type: TYPE_NORMAL
  zh: 按下ENTER键来自动完成函数调用。光标会移动到函数的括号内（参见[图7-3](text00017.html#ch07fig3)），在这里Xcode已经自动添加了一些占位文本，告诉你该函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-5180
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-5181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：Xcode正在等待你填写guest参数。*'
- en: '**NOTE**'
  id: totrans-5182
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-5183
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递给invite(guest:)的参数不是字符串，例如invite(guest: 45)，你会遇到错误，因为这个函数期待的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-5184
  prefs: []
  type: TYPE_NORMAL
  zh: 只需输入"Cathy"或另一个朋友的名字替代String，然后按TAB键完成函数调用。它应该像[图7-4](text00017.html#ch07fig4)那样。
- en: '![Image](Image00157.jpg)'
  id: totrans-5185
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-5186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：一个invite(guest:)函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-5187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，试着调用invite(guest:)三次，使用你自己朋友的名字：
- en: '[PRE989]'
  id: totrans-5188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE989]'
- en: 'The output looks like this:'
  id: totrans-5189
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来是这样的：
- en: '[PRE990]'
  id: totrans-5190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE990]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-5191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你能够快速打印出三张派对邀请函，每张邀请函都写给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-5192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-5193
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以写一个函数，通过传入一个字符串数组作为参数，一次性邀请所有朋友，而不是传入单个字符串。在你编写了invite(guest:)函数的同一个playground中，编写以下invite(allGuests:)函数进行测试。请注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-5194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00158.jpg)'
- en: '[PRE991]'
  id: totrans-5195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE991]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-5196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当你声明函数的参数时，你会注意到[String]被括在方括号中➊。方括号表示数据类型是一个数组，而String表示数组中值的数据类型。通过使用[String]，我们将这个函数的输入声明为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-5197
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们需要使用一个for-in循环遍历我们的宾客数组，并为每位客人打印一张邀请函。还记得我们刚才创建的打印邀请函的函数吗？我们可以在这里使用它！将以下代码添加到你的invite(allGuests:)函数中（灰色文本表示现有代码行）：
- en: '[PRE992]'
  id: totrans-5198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE992]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-5199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个客人调用单一的invite(guest:)函数，邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟，它们的名字都是invite。然而，尽管名字相同，它们是两个不同的函数，因为它们接受不同的输入参数。这是Swift中常见的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-5200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE993]'
  id: totrans-5201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE993]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-5202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组➊。然后，我们将新数组作为函数的输入来调用该函数➋。这是你在调试控制台中看到的输出（-- snip --表示我们省略了一些行以节省空间）：
- en: '[PRE994]'
  id: totrans-5203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE994]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-5204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为每个朋友写邀请函，那会非常费力。但借助函数的强大功能，你只需要用几行代码就完成了这项任务。试着创建你自己的朋友数组，长度可以随意！然后用你新的数组作为输入，调用invite(allGuests:)函数。简直是小菜一碟！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-5205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-5206
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，派对的日期临近了，而有些客人还没有回复是否参加。你想得到一个最终的宾客人数，并通知客人们带上泳衣，因为这将是一个滑水派对。你可以写一个函数，根据客人的RSVP状态发送个性化的信息给每位客人。
- en: '![Image](Image00159.jpg)'
  id: totrans-5207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-5208
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个字符串类型的参数用于表示客人的名字，一个布尔类型的参数用于表示RSVP状态，它的值可以是true或false。将以下代码输入到你的playground中：
- en: '[PRE995]'
  id: totrans-5209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE995]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-5210
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数有多个输入参数时，你需要在每个参数之间添加逗号 ➊。每个参数需要有一个参数名称，后面跟着冒号和数据类型。在 sendMessage(guest:rsvped:)
    函数中，我们传入一个 String 类型的 guest 和一个 Bool 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-5211
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 值是否为 true ➋，然后使用 if-else 语句打印相应的消息。注意，函数定义中的最后几条 print 语句无论
    rsvped 值是 true 还是 false 都会执行，因为它们在 if-else 语句的大括号之外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-5212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已确认参加，他们会收到以下消息：
- en: '[PRE996]'
  id: totrans-5213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE996]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-5214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有确认，他们会收到一条礼貌的提醒，要求他们做出回应：
- en: '[PRE997]'
  id: totrans-5215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE997]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-5216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一位客人的 rsvped 值设置为 true，另一位客人的设置为 false，这样你就可以看到两个消息的实际效果。
- en: '[PRE998]'
  id: totrans-5217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE998]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-5218
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-5219
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能将帮助你填写输入值，提供参数标签。你需要做的就是传入你想使用的值。填写完客人姓名后，按下 TAB 键，Xcode 会将光标移动到你需要填写下一个输入值的地方。（参见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-5220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-5221
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入完客人姓名后按 TAB 键将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-5222
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，你会收到一个错误提示。
- en: '**ARGUMENT LABELS**'
  id: totrans-5223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-5224
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用 print(_:) 时，输入值前面没有参数标签吗？你写的是：
- en: '[PRE999]'
  id: totrans-5225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE999]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-5226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，你会得到一个错误：
- en: '[PRE1000]'
  id: totrans-5227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1000]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-5228
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用时有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，而且它会和参数名称相同。然而，如果你编写一个函数，觉得参数标签对于代码的清晰性并不是必需的，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，很明显你传入的是一个字符串并将其打印。如果每次调用 print(_:) 时都必须包括类似 inputString 的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-5229
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号和最后的参数数据类型来做到这一点。所有这些操作都在你首次声明函数括号内的参数时完成，这通常在
    Swift 函数中进行，以使函数调用看起来更像一句句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-5230
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-5231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-5232
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，在调用函数时它将显示为
    sayHello(friend:)，这听起来不像一句完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-5233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何编写具有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-5234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-5235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例，了解添加自定义参数标签如何使代码更具可读性。在你的生日派对后，你会想给所有客人发送感谢信。请在你的 playground 中编写以下函数：
- en: '[PRE1001]'
  id: totrans-5236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1001]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-5237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们向传递给函数的 guest 参数添加了一个自定义参数标签“to”。类似地，在 ➋ 处，我们向 gift 参数添加了一个参数标签“for”。参数名
    guest ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-5238
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签“to”和“for”用于在调用函数时标记参数，像这样：
- en: '[PRE1002]'
  id: totrans-5239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1002]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-5240
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里你可以看到，to: 被写在函数调用中的第一个输入值前面，而 for: 被写在第二个输入值前面。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名代替会导致错误：'
- en: '[PRE1003]'
  id: totrans-5241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1003]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-5242
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填写参数标签，因此你无需担心错误地调用函数（参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-5243
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-5244
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成函数，并添加了正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-5245
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向某位客人发送感谢信，感谢他们赠送的礼物。代码
    sendThankYou(to: "Meghan", for: "puzzle books") 读起来更像一句完整的句子，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-5246
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-5247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-5248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加一个下划线和一个空格来移除它们。在下面的例子中，我们编写了一个计算体积的函数，接收盒子的三个边作为输入。因为函数名称已经清楚地表明了你需要传入三个边，所以你实际上不需要参数标签来使代码更具可读性。
- en: '[PRE1004]'
  id: totrans-5249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1004]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-5250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处的`side1`、➋处的`side2`和➌处的`side3`前面加上下划线，来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-5251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，而无需任何标签。
- en: '[PRE1005]'
  id: totrans-5252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1005]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-5253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"这个盒子的体积是72。" 如果你不只是打印盒子的体积，而是将结果存储在一个变量或常量中以供以后使用，这样不是更有用吗？让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-5254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-5255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，以返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-5256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-5257
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多东西。首先，编写一个`volumeOfBox(_:_:_:)`函数，该函数返回一个表示盒子体积的`Int`：
- en: '[PRE1006]'
  id: totrans-5258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1006]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-5259
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数添加返回值，在函数的输入参数后➊使用一个短横线和大于号（->）组成箭头，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你通过使用`return`关键字后跟你想返回的值➋来返回该值。如果你编写一个返回值的函数，那么你*必须*在函数内返回该值，否则会出现错误。函数在返回值后结束。如果你在`return`语句后面写了任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-5260
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-5261
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的盒子调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-5262
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-5263
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`volumeOfBox(_:_:_:)`函数计算了一个边长分别为6、5和3的盒子的体积，返回值90被存储在名为`volumeOfBox1`的常量中。在➋处，边长为8、4和2的`volumeOfBox2`的值为64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1007]'
  id: totrans-5264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1007]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-5265
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台中看到字符串"盒子1更大"的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-5266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-5267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接受一个测试分数的数组并返回平均分数。为了得到平均分数，你将分数加在一起，然后除以总的分数数目。请在你的游乐场中输入以下代码：
- en: '[PRE1008]'
  id: totrans-5268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1008]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-5269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有数值的总和。在➊处，我们定义了一个名为sum的Int类型变量，并将其初始化为0。➋处的for-in循环遍历成绩数组中的每个值，并将其加到sum变量中。当循环完成后，变量sum将保存所有成绩的总和。计算出总和后，剩下的就是将其除以成绩的总数，这就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-5270
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能用零去除任何东西——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除零错误，并使程序崩溃。因此，在进行除法操作时，务必确保你要除的数不是零，这也是我们通过检查scores.count
    > 0在➌处完成的操作。在➍处，我们通过返回总成绩除以成绩数组中的数量来返回平均值，使用return sum / scores.count。没错！你可以返回任何计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回sum
    / scores.count，因为它会计算出一个Int类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-5271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在scores.count不大于零时返回某个值，否则会出现函数缺少返回值的错误。我们通过在if语句中添加else来处理这个问题，返回0
    ➎。你可以通过在一个成绩数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-5272
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-5273
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试成绩数组传递给averageOf()函数时，如我们在➊处所做的，函数将返回并显示成绩的平均值。如果你传递一个空数组，如我们在➋处所做的，返回值将是0。
- en: '**NOTE**'
  id: totrans-5274
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-5275
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕返回0的else语句其实并不是必须的。这是因为如果scores.count > 0，那么函数将已经通过return sum / scores.count结束。所以，如果计算机已经跳过了那个if语句，那么我们就知道scores.count
    > 0一定不成立，我们完全可以直接写return 0，而不需要放在else中。然而，如果我们保留else语句，代码会更清晰、更容易理解。有时候，写一点额外的代码让其他人更容易理解，比使用一些巧妙的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-5276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-5277
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要的工具——创建并调用你自己的函数！函数在编程中广泛使用，用于做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-5278
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建除 Swift 中已包含的类型之外的常量和变量，在创建应用程序时非常有用！
- en: '[PRE1009]'
  id: totrans-5279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1009]'
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-5280
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写函数名来调用函数时，Xcode 的自动完成功能会提示你应该传递什么内容给该函数。在这种情况下，当你开始输入 invite 时，你会看到一个下拉菜单，如[图
    7-2](text00017.html#ch07fig2)所示。
- en: '![Image](Image00155.jpg)'
  id: totrans-5281
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-5282
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成功能会展示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-5283
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键以自动完成函数。光标将移动到函数的括号内（参见[图 7-3](text00017.html#ch07fig3)），Xcode 会自动添加一些占位符文本，告诉你函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-5284
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-5285
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-5286
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-5287
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递一个不是字符串的参数给 invite(guest:) 函数，比如 invite(guest: 45)，你会遇到错误，因为该函数期望的是字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-5288
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将“Cathy”或其他朋友的名字替换掉 String，然后按 TAB 键完成函数调用。它应该看起来像[图 7-4](text00017.html#ch07fig4)所示。
- en: '![Image](Image00157.jpg)'
  id: totrans-5289
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-5290
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-5291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用 invite(guest:) 三次，使用你自己朋友的名字：
- en: '[PRE1010]'
  id: totrans-5292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1010]'
- en: 'The output looks like this:'
  id: totrans-5293
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE1011]'
  id: totrans-5294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1011]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-5295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你可以快速打印出三张派对邀请函，每一张都写给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-5296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-5297
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，通过传入一个字符串数组作为参数，而不是单个字符串，来一次性邀请所有的朋友。在你编写了 invite(guest:) 函数的同一个
    playground 中，编写以下 invite(allGuests:) 函数来进行测试。注意，参数名称现在是复数形式，因为我们将一次性邀请多个朋友。
- en: '![Image](Image00158.jpg)'
  id: totrans-5298
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE1012]'
  id: totrans-5299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1012]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-5300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到 [String] 这个类型放在方括号内 ➊。方括号表示数据类型为数组，而 String 则表示数组中元素的数据类型。通过使用
    [String]，我们声明这个函数的输入为字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-5301
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们希望使用一个 for-in 循环遍历我们的 guest 数组，并为每个客人打印一张邀请函。记得我们刚刚创建的那个打印邀请函的函数吗？我们在这里也可以用它！将以下代码添加到
    invite(allGuests:) 函数中（灰色文本表示现有行）：
- en: '[PRE1013]'
  id: totrans-5302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1013]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-5303
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们对字符串数组 allGuests 中的每个 guest 调用了单一的 invite(guest:) 函数，以邀请每个人参加生日派对。你可能会想，invite(guest:)
    和 invite(allGuests:) 是同一个函数吗？毕竟，它们的名称都是 invite。不过，尽管它们有相同的名字，它们是两个不同的函数，因为它们接受不同的输入参数。这种模式在
    Swift 中非常常见。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-5304
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用该数组。
- en: '[PRE1014]'
  id: totrans-5305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1014]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-5306
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组➊。然后，我们使用这个新的数组作为函数的输入来调用该函数➋。这是您将在调试控制台中看到的输出（-- snip --
    表示我们为节省空间省略的部分）：
- en: '[PRE1015]'
  id: totrans-5307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1015]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-5308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您必须为每位朋友单独编写邀请函，那会非常繁琐。但借助函数的强大功能，您可以用非常少的代码行完成这项任务。试着创建您自己的朋友数组，想要多少就创建多少！然后用新的数组作为输入，调用invite(allGuests:)函数。简直轻松搞定！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-5309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向您的来宾发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-5310
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的派对日期临近，一些来宾还没有RSVP。您想要获取最终的来宾人数，并让他们知道需要带上泳衣，因为这将是一个滑水派对。您可以编写一个函数，根据来宾的RSVP状态向每位来宾发送自定义消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-5311
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-5312
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新函数将接受两个输入参数：一个用于来宾姓名的字符串参数和一个用于RSVP状态的布尔参数，RSVP状态可以是true或false。请输入以下代码到您的Playground中：
- en: '[PRE1016]'
  id: totrans-5313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1016]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-5314
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，您需要在每个参数之间加上逗号➊。每个参数都需要有一个参数名称，后面跟着冒号和参数的数据类型。您可以创建一个接受任意数量输入参数的函数，这些参数类型不必相同。在sendMessage(guest:rsvped:)函数中，我们传入了一个字符串作为guest，传入了一个布尔值作为rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-5315
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为true➋，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最后一条打印语句无论rsvped值是true还是false都会执行，因为它们位于if-else语句的外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-5316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的来宾已经RSVP，他们将收到这条消息：
- en: '[PRE1017]'
  id: totrans-5317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1017]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-5318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提示，要求他们回复：
- en: '[PRE1018]'
  id: totrans-5319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1018]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-5320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一位来宾的rsvped值设置为true，将另一位来宾的rsvped值设置为false，这样您就可以看到两条消息的效果。
- en: '[PRE1019]'
  id: totrans-5321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1019]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-5322
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，调用一个具有多个输入参数的函数与调用一个只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-5323
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能将帮助您填写输入值，通过为您提供参数标签。您只需传入想要使用的值即可。填写完来宾姓名后，按TAB键，Xcode会自动将光标放置在正确的位置，以便您填写下一个输入值。（参见[图7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-5324
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-5325
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：在输入来宾姓名后按TAB键，将光标移至下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-5326
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他东西，比如名字或数字，系统会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-5327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-5328
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，并没有在输入值前面加上参数标签？你写的是：
- en: '[PRE1020]'
  id: totrans-5329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1020]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-5330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，系统也会报错：
- en: '[PRE1021]'
  id: totrans-5331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1021]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-5332
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且它与参数名相同。然而，如果你编写的函数觉得不需要参数标签来使代码更清晰，你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，很明显你传入的是一个字符串，并将其打印出来。如果每次调用 print(_:) 都必须包括像 inputString 这样的参数标签，实在是太麻烦了。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-5333
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号，最后是参数的数据类型来实现。所有这些操作都是在 func 关键字后首次声明函数参数时进行的。这通常在
    Swift 函数中完成，以使函数调用看起来更像一个完整的句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-5334
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-5335
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-5336
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，而在函数调用中传递的参数是 "Colin"。如果没有单独的参数标签，调用函数时将看起来像
    sayHello(friend:)，这听起来不像完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-5337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-5338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-5339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，了解如何通过添加自定义参数标签使代码更具可读性。在你的生日派对后，你会想给所有客人发送感谢信。在你的 playground 中编写以下函数：
- en: '[PRE1022]'
  id: totrans-5340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1022]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-5341
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了一个自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名
    guest ➌ 和 gift ➍ 用来引用函数内部的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-5342
  prefs: []
  type: TYPE_NORMAL
  zh: '`to` 和 `for` 这两个参数标签用于标记调用函数时的参数，像这样：'
- en: '[PRE1023]'
  id: totrans-5343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1023]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-5344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到to:在第一个输入值前被写出，for:在第二个输入值前被写出。如果一个参数有自定义的参数标签，你在调用函数时必须使用它。如果你尝试使用参数名而不是标签，程序会报错：
- en: '[PRE1024]'
  id: totrans-5345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1024]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-5346
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全会自动填充参数标签，因此你不必担心错误地调用函数（参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-5347
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-5348
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-5349
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于发送一封感谢信给某位客人，以感谢她的礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")看起来更像一句句子，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-5350
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-5351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-5352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，你可以通过在参数名前添加下划线和空格来移除它们。在下面的示例中，我们编写了一个用于计算体积的函数，该函数接受一个盒子的三个边长作为输入。由于函数名已经明确表示需要传入三个边长，因此你不需要额外的参数标签来提高代码的可读性。
- en: '[PRE1025]'
  id: totrans-5353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1025]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-5354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在side1前面加上下划线（➊），在side2前面加上下划线（➋），以及在side3前面加上下划线（➌）来移除这些边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-5355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调用这个函数时，你只需要输入参数值，而无需使用任何标签。
- en: '[PRE1026]'
  id: totrans-5356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1026]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-5357
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出"The volume of this box is 72."。如果你不仅仅打印出盒子的体积，而是将结果存储到变量或常量中以供后续使用，这样不是更有用吗？让我们看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-5358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-5359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是将结果打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-5360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-5361
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个能装更多的东西。首先，编写一个volumeOfBox(_:_:_:)函数，返回盒子的体积（Int 类型）：
- en: '[PRE1027]'
  id: totrans-5362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1027]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-5363
  prefs: []
  type: TYPE_NORMAL
  zh: 要为一个函数提供返回值，在函数输入参数之后使用破折号和大于符号（->）来形成箭头，并输入返回值的数据类型。注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，你可以通过使用return关键字来返回你想要的值（➋）。如果你编写的函数需要返回一个值，那么你*必须*在函数内返回该值，否则会出现错误。函数在返回值后结束。如果你在return语句之后编写任何代码，它将被忽略，因为return语句会让函数退出。
- en: '![Image](Image00164.jpg)'
  id: totrans-5364
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-5365
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数处理两个不同的盒子，看看它的实际效果：
- en: '![](Image00165.jpg)'
  id: totrans-5366
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-5367
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算了一个边长为6、5和3的箱子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋处，边长为8、4和2的volumeOfBox2被赋值为64。现在，让我们打印一条关于哪个箱子更大的消息：
- en: '[PRE1028]'
  id: totrans-5368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1028]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-5369
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-5370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-5371
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，该函数接受一个测试分数的数组并返回平均分。要计算平均分，你需要将所有分数加起来，然后除以总的分数数量。在你的playground中输入以下代码：
- en: '[PRE1029]'
  id: totrans-5372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1029]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-5373
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有数值的总和。在➊处，我们定义了一个名为sum的Int类型变量，并将其初始值设为0。在➋处的for-in循环遍历scores数组中的每个值，并将其加到sum变量中。当循环完成时，变量sum保存了所有分数的总和。计算出总和后，剩下的就是将其除以总分数，即scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-5374
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能将一个数除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除零错误，并使程序崩溃。因此，在进行除法操作时，始终确保除数不是零，这就是我们在➌处通过检查scores.count
    > 0来确保的。在➍处，我们通过将分数总和除以数组中的分数数量来返回平均分，使用return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回sum
    / scores.count，因为它计算出来的值是一个Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-5375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们也需要返回某些内容，否则会出现函数缺少返回值的错误。我们通过在if语句中添加一个else来处理这一点，在else中返回0，见➎。你可以通过调用该函数，分别传入一个分数数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-5376
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-5377
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试分数数组传递给averageOf()函数时，就像在➊处那样，返回的是分数的平均值，并显示在结果面板中。如果你传入一个空数组，就像在➋处那样，返回值是0。
- en: '**NOTE**'
  id: totrans-5378
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-5379
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这个例子中，return 0 周围的 else 语句实际上并不是必须的。这是因为，如果 scores.count > 0，那么函数会在 return
    sum / scores.count 之前结束。因此，如果程序已经通过了那个 if 语句，我们知道 scores.count > 0 肯定不为真，我们完全可以直接使用
    return 0，而不需要把它放在 else 语句中。不过，如果我们保留 else 语句，代码会更清晰，也更容易理解。有时候，写一些额外的代码来让别人更容易理解，比使用复杂的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-5380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-5381
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚给你的 Swift 工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种了不起的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-5382
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08) 中，我们将向你展示如何通过编写类定义来创建自定义对象。这样，你就可以创建类型不同于 Swift
    中已包含的类型的常量和变量，这在你创建应用程序时非常有用！
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  id: totrans-5383
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过写出函数名来调用一个函数时，Xcode 的自动完成功能会给你提示，告诉你应该传入什么参数。在这个例子中，当你开始写 invite 时，你会看到一个下拉菜单，像
    [图 7-2](text00017.html#ch07fig2) 中所示的那样。
- en: '![Image](Image00155.jpg)'
  id: totrans-5384
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-5385
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Xcode 的自动完成功能会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-5386
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键以自动完成函数。你的光标会跳到函数的括号内（见 [图 7-3](text00017.html#ch07fig3)），Xcode 已经自动添加了一些占位符文本，告诉你函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-5387
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-5388
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：Xcode 正在等待你填写 guest 参数。*'
- en: '**NOTE**'
  id: totrans-5389
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-5390
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传入一个不是字符串的东西给 invite(guest:)，例如 invite(guest: 45)，你会得到一个错误，因为函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-5391
  prefs: []
  type: TYPE_NORMAL
  zh: 只需输入 "Cathy" 或另一个朋友的名字代替 String，然后按 TAB 键完成函数调用的填写。它应该看起来像 [图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-5392
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-5393
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-5394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，尝试调用 invite(guest:) 三次，使用你朋友的名字：
- en: '[PRE1030]'
  id: totrans-5395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1030]'
- en: 'The output looks like this:'
  id: totrans-5396
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE1031]'
  id: totrans-5397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1031]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-5398
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你可以快速打印三份聚会邀请，每一份都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-5399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-5400
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，通过传入一个字符串数组作为参数来一次性邀请所有朋友，而不是传入一个单独的字符串。在你写 invite(guest:) 的同一个 playground
    中，编写以下 invite(allGuests:) 函数来测试这个功能。注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-5401
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE1032]'
  id: totrans-5402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1032]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-5403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被放在方括号中 ➊ 。方括号声明了数据类型为数组，而String表示数组中元素的数据类型。通过使用[String]，我们将这个函数的输入声明为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-5404
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们需要使用for-in循环遍历我们的客人数组，并为每个客人打印邀请函。记得我们刚才创建了一个打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本显示的是现有代码）：
- en: '[PRE1033]'
  id: totrans-5405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1033]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-5406
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个客人调用单独的invite(guest:)函数，以邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是不是同一个函数？毕竟，它们的名字都叫invite。尽管它们有相同的名字，但它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中常见的一个模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-5407
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，首先我们创建一个名为friends的数组，然后将其作为输入传递给函数调用。
- en: '[PRE1034]'
  id: totrans-5408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1034]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-5409
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后，我们使用这个新数组作为函数的输入来调用该函数 ➋ 。这是你在调试控制台中看到的输出（-- snip --表示我们省略了部分行以节省空间）：
- en: '[PRE1035]'
  id: totrans-5410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1035]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-5411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友手动写邀请函，那将非常麻烦。但得益于函数的强大，你只需几行代码就完成了这项任务。尝试创建你自己的朋友数组；你可以根据需要让它变得更长！然后，使用你的新数组作为输入，调用invite(allGuests:)函数。真是轻松简单！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-5412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-5413
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期即将到来，但有些客人还没有回复邀请。你希望获取最终的参加人数，并通知客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据每个客人的回复状态发送定制消息给他们。
- en: '![Image](Image00159.jpg)'
  id: totrans-5414
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-5415
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个String类型的参数表示客人的名字，一个Bool类型的参数表示RSVP状态，值为true或false。将以下代码输入到你的playground中：
- en: '[PRE1036]'
  id: totrans-5416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1036]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-5417
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊ 。每个参数都需要有一个参数名，后面跟上冒号和参数的数据类型。你可以创建一个函数，接受任意数量的输入参数，并且这些参数可以是不同的数据类型。在sendMessage(guest:rsvped:)函数中，我们传入了一个String类型的guest和一个Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-5418
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查`rsvped`值，看看它是否为`true`➋，然后使用`if-else`语句打印相应的消息。还要注意，函数定义中的最后几条`print`语句无论`rsvped`值是`true`还是`false`都会执行，因为它们位于`if-else`语句的大括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-5419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已RSVP，他们将收到此消息：
- en: '[PRE1037]'
  id: totrans-5420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1037]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-5421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提示，要求他们做出回应：
- en: '[PRE1038]'
  id: totrans-5422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1038]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-5423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用函数，看看它是如何工作的。尝试将一个客人的`rsvped`值设置为`true`，另一个客人的值设置为`false`，这样你就能看到两个消息的实际效果。
- en: '[PRE1039]'
  id: totrans-5424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1039]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-5425
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用具有多个输入参数的函数与调用只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-5426
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全将帮助你填写输入值，为你提供参数标签。你需要做的就是传入你想使用的值。在填写完客人姓名后，按TAB键，Xcode会把光标放到你需要填写下一个输入值的位置。（见[图
    7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-5427
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-5428
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入客人姓名后按TAB键将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-5429
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你`rsvped`的数据类型。将占位符文本`Bool`替换为`true`或`false`。如果你尝试传入其他任何东西，比如名字或数字，你将会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-5430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-5431
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，在调用`print(_:)`时，你没有在输入值前加上参数标签？你写的是：
- en: '[PRE1040]'
  id: totrans-5432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1040]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-5433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，你会遇到错误：
- en: '[PRE1041]'
  id: totrans-5434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1041]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-5435
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且该标签与参数名称相同。然而，如果你编写的函数认为参数标签对于代码清晰度不是必需的，那么你可以在函数定义中明确省略它。例如，在`print(_:)`函数中，很明显你传入的输入是一个字符串，它会被打印出来。如果每次调用`print(_:)`都必须包括像`inputString`这样的参数标签，那将会非常麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-5436
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来做到这一点。这一切都是在你首次声明函数括号内的参数时完成的。这种做法在Swift函数中很常见，可以使函数调用看起来更像一句话。[图
    7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-5437
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-5438
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello()函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-5439
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中的传入参数是 "Colin"。如果没有单独的参数标签，当你调用函数时，它会像
    sayHello(friend:) 那样，看起来不太像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-5440
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将了解如何编写带有自定义参数标签的函数。我们还将展示如何编写一个函数，在该函数中完全省略参数标签。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-5441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-5442
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例，看看添加自定义参数标签如何使你的代码更具可读性。生日派对后，你会想给所有的客人发送感谢信。请在你的 Playground 中编写以下函数：
- en: '[PRE1042]'
  id: totrans-5443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1042]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-5444
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了参数标签 for。参数名称 guest
    ➌ 和 gift ➍ 用于函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-5445
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，如下所示：
- en: '[PRE1043]'
  id: totrans-5446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1043]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-5447
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里你可以看到，to: 在第一个输入值之前书写，for: 则在第二个输入值之前书写。如果参数有自定义的参数标签，那么你必须在函数调用中使用它。试图使用参数名称会导致错误：'
- en: '[PRE1044]'
  id: totrans-5448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1044]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-5449
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会自动为你填写参数标签，因此你无需担心错误地调用函数（参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-5450
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-5451
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-5452
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信 *to* 表示接收者，*for*
    表示礼物。代码 sendThankYou(to: "Meghan", for: "puzzle books") 读起来更像一个句子，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-5453
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-5454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-5455
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加下划线和空格来移除它们。在下面的例子中，我们编写了一个用于计算体积的函数，该函数接受盒子的三条边作为输入。因为函数名称已明确表示你需要传入三条边，所以实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1045]'
  id: totrans-5456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1045]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-5457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处将下划线放在 side1 前，➋ 处将下划线放在 side2 前，➌ 处将下划线放在 side3 前来移除三条边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-5458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，而无需任何标签。
- en: '[PRE1046]'
  id: totrans-5459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1046]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-5460
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出 "这个盒子的体积是 72。" 如果你不仅仅是打印盒子的体积，而是将结果存储到一个变量或常量中以便以后使用，难道不会很有用吗？让我们了解如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-5461
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-5462
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重新编写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-5463
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-5464
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，编写一个 `volumeOfBox(_:_:_:)` 函数，返回一个表示盒子体积的 `Int`：
- en: '[PRE1047]'
  id: totrans-5465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1047]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-5466
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数指定返回值，使用破折号和大于符号（->）在函数的输入参数之后 ➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要指定数据类型。在函数体内，你可以使用
    `return` 关键字返回你想返回的值 ➋。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值后结束。如果在 `return`
    语句后再写任何代码，它会被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-5467
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-5468
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-5469
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-5470
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 `volumeOfBox1`
    的常量中。接着，在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1048]'
  id: totrans-5471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1048]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-5472
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-5473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-5474
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接受一个测试分数数组，并返回平均分。为了计算平均分，你将所有分数加在一起，然后除以总分数的数量。在你的游乐场中输入以下代码：
- en: '[PRE1049]'
  id: totrans-5475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1049]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-5476
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始值设为 0。接着，➋ 处的 `for-in`
    循环会遍历 `scores` 数组中的每个值，并将其加到 `sum` 变量中。循环结束后，`sum` 变量保存了所有分数的总和。计算出总和后，我们只需要将它除以分数的总数，即
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-5477
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空怎么办呢？你不能用零除以任何东西——无论是在数学课上，还是在Swift中。在Swift中，尝试除以零会给你一个除以零错误，并且程序会崩溃。因此，在进行除法运算时，一定要确保除数不为零，这就是我们在➌处通过检查`scores.count
    > 0`来做到的。在➍处，我们通过将分数的总和除以数组中分数的数量来返回平均值，使用`return sum / scores.count`。没错！你可以返回任何会计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回`sum
    / scores.count`，因为它会计算出一个`Int`类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-5478
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`scores.count`不大于零时，我们也需要返回某个值，否则会出现函数缺少返回值的错误。我们通过在`if`语句中添加`else`来处理这个问题，返回`0`➎。你可以通过对一个分数数组和一个空数组调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-5479
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-5480
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给`averageOf()`函数时，正如我们在➊处所做的，分数的平均值会被返回并显示在结果面板中。如果你传递一个空数组，如我们在➋处所做的，返回值将是0。
- en: '**NOTE**'
  id: totrans-5481
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-5482
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，`else`语句包裹`return 0`实际上并不是必需的。这是因为如果`scores.count > 0`，函数已经通过`return
    sum / scores.count`结束了。所以如果计算机已经通过了那个`if`语句，那么我们知道`scores.count > 0`肯定不成立，我们本来可以直接写`return
    0`，而不需要包裹在`else`中。然而，如果我们保留`else`语句，代码会更清晰，更容易理解。有时候，为了让别人更容易理解，写一些额外的代码比用巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-5483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-5484
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做各种各样了不起的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-5485
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建类型与Swift中已有类型不同的常量和变量，这在你开发应用时非常有用！
- en: '![Image](Image00155.jpg)'
  id: totrans-5486
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00155.jpg)'
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-5487
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：Xcode的自动完成功能会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-5488
  prefs: []
  type: TYPE_NORMAL
  zh: 按下ENTER键以自动完成函数。光标会移入函数的圆括号中（参见[图7-3](text00017.html#ch07fig3)），Xcode已经自动添加了一些占位符文本，告诉你该函数期望的输入类型是什么。
- en: '![Image](Image00156.jpg)'
  id: totrans-5489
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-5490
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：Xcode正在等待你填写guest参数。*'
- en: '**NOTE**'
  id: totrans-5491
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-5492
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递一个不是字符串的东西给`invite(guest:)`，比如`invite(guest: 45)`，你会得到一个错误，因为该函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-5493
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 的位置输入 "Cathy" 或其他朋友的名字，然后按 TAB 键完成函数调用的填写。它应该像 [图 7-4](text00017.html#ch07fig4)
    一样。
- en: '![Image](Image00157.jpg)'
  id: totrans-5494
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-5495
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-5496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用 invite(guest:) 函数三次，使用你自己朋友的名字：
- en: '[PRE1050]'
  id: totrans-5497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1050]'
- en: 'The output looks like this:'
  id: totrans-5498
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来是这样的：
- en: '[PRE1051]'
  id: totrans-5499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1051]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-5500
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你可以快速打印出三份派对邀请函，每份邀请函都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-5501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-5502
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写一个一次性邀请所有朋友的函数，通过传入一个字符串数组作为参数，而不是单个字符串。在你编写 invite(guest:) 的同一个 playground
    中，编写以下 invite(allGuests:) 函数来进行测试。注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-5503
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE1052]'
  id: totrans-5504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1052]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-5505
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到 [String] 是放在方括号中的 ➊ 。方括号表示数据类型是数组，而 String 表示数组中值的类型。通过使用
    [String]，我们声明了该函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-5506
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们将使用一个 for-in 循环遍历我们的客人数组，并为每个客人打印一份邀请函。还记得我们刚才创建了一个打印邀请函的函数吗？我们就用这个！将以下代码添加到你的
    invite(allGuests:) 函数中（灰色文本表示已有的行）：
- en: '[PRE1053]'
  id: totrans-5507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1053]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-5508
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们对 String 数组 allGuests 中的每个客人调用单一的 invite(guest:) 函数，邀请每个人参加生日派对。你可能会想知道
    invite(guest:) 和 invite(allGuests:) 是不是同一个函数。毕竟，它们的名字都是 invite。尽管它们名字相同，但它们是两个不同的函数，因为它们接受的输入参数不同。这是你在
    Swift 中经常会见到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-5509
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 invite(allGuests:) 函数，我们首先创建一个名为 friends 的数组，然后在函数调用中使用它。
- en: '[PRE1054]'
  id: totrans-5510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1054]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-5511
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后，我们将新数组作为函数的输入调用该函数 ➋ 。这是你将在调试控制台看到的输出（-- snip -- 表示我们为了节省空间省略的部分）：
- en: '[PRE1055]'
  id: totrans-5512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1055]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-5513
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为这些朋友写出每一份邀请函，那会非常繁琐。但凭借函数的强大功能，你已经用极少的代码行实现了这一点。试着创建你自己的朋友数组；你可以根据需要让它变长！然后将你的新数组作为输入调用
    invite(allGuests:) 函数。真是小菜一碟！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-5514
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-5515
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期即将到来，而一些客人还没有回复是否参加。你希望确定最终人数，并让客人们知道要带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据客人的RSVP状态发送定制消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-5516
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-5517
  prefs: []
  type: TYPE_NORMAL
  zh: 你新的函数将接受两个输入参数：一个String类型的参数用于客人的名字，另一个是Bool类型的参数用于RSVP状态，它的值为true或false。请在你的playground中输入以下代码：
- en: '[PRE1056]'
  id: totrans-5518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1056]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-5519
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号➊。每个参数需要有一个参数名称，后面跟着一个冒号和该参数的数据类型。你可以创建一个接受任意多个输入参数的函数，这些参数不必是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传入的是String类型的guest和Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-5520
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped的值，看它是否为true➋，然后使用if-else语句打印相应的消息。请注意，函数定义中的最后打印语句无论rsvped的值是true还是false都会执行，因为它们位于if-else语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-5521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经RSVP，他们将收到这条消息：
- en: '[PRE1057]'
  id: totrans-5522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1057]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-5523
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有回应，他们将收到一封礼貌的提醒信，要求他们回复：
- en: '[PRE1058]'
  id: totrans-5524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1058]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-5525
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一个客人的rsvped值设置为true，另一个客人的值设置为false，这样你可以看到两条消息的效果。
- en: '[PRE1059]'
  id: totrans-5526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1059]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-5527
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-5528
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能将帮助你填写输入值，并为你提供参数标签。你只需要传入你想使用的值。填写完客人名字后，按TAB键，Xcode会将光标自动定位到你需要的地方，方便你填写下一个输入值。（见[图7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-5529
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-5530
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：在输入客人名字后按TAB键，将会把光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-5531
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你rsvped的数据类型。将占位符文本Bool替换为true或false。如果你尝试传入其他内容，如名字或数字，你将会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-5532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-5533
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，当你调用print(_:)时，并没有在输入值前加上参数标签？你写的是：
- en: '[PRE1060]'
  id: totrans-5534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1060]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-5535
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图包含标签，你会遇到错误：
- en: '[PRE1061]'
  id: totrans-5536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1061]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-5537
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且它与参数名称相同。然而，如果你编写了一个函数，并且觉得参数标签对代码的清晰性没有必要，那么你可以在函数定义中显式地省略它。例如，在
    print(_:) 函数中，很明显你传入的是一个字符串，将被打印出来。如果每次调用 print(_:) 都必须包含像 inputString 这样的参数标签，显然会让人感到烦恼。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-5538
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。在你首次声明函数括号内的参数时（在
    func 关键字之后），就可以完成这一步。Swift 函数中常常这样做，以使函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-5539
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-5540
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-5541
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用该函数时会像
    sayHello(friend:) 这样，听起来就不像一句完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-5542
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写带有自定义参数标签的函数。我们还会向你展示如何编写一个函数，完全省略参数标签。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-5543
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-5544
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，了解添加自定义参数标签如何使你的代码更具可读性。在你举办完生日派对后，你可能想给所有的客人写感谢信。在你的 Playground 中编写以下函数：
- en: '[PRE1062]'
  id: totrans-5545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1062]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-5546
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了参数标签 for。参数名称 guest
    ➌ 和 gift ➍ 用于函数内部引用参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-5547
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于函数调用时标记参数，像这样：
- en: '[PRE1063]'
  id: totrans-5548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1063]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-5549
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里你可以看到，to: 被写在函数调用中的第一个输入值前，for: 被写在第二个输入值前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。如果你试图使用参数名称代替，会导致错误：'
- en: '[PRE1064]'
  id: totrans-5550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1064]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-5551
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会自动填充函数的参数标签，因此你无需担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-5552
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-5553
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-5554
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用来向客人发送感谢信 *to* 表示给谁 *for*
    表示什么原因。代码 sendThankYou(to: "Meghan", for: "puzzle books") 读起来更像一句句子，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-5555
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-5556
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**去除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-5557
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前加上一个下划线和一个空格来去掉它们。在以下示例中，我们编写了一个计算体积的函数，它接受盒子的三个边作为输入。因为函数名已经明确说明需要传入三个边，所以其实不需要参数标签来提高代码的可读性。
- en: '[PRE1065]'
  id: totrans-5558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1065]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-5559
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊ 的 side1 前、➋ 的 side2 前和➌ 的 side3 前加上下划线，来去除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-5560
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE1066]'
  id: totrans-5561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1066]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-5562
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "The volume of this box is 72."。如果你能够将结果存储到一个变量或常量中，而不是仅仅打印盒子的体积，那不是更有用吗？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-5563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-5564
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-5565
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-5566
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并想知道哪个盒子能装更多的东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，它返回一个 Int 类型的盒子体积：
- en: '[PRE1067]'
  id: totrans-5567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1067]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-5568
  prefs: []
  type: TYPE_NORMAL
  zh: 要为一个函数设置返回值，可以在函数的输入参数后面使用一个破折号和大于符号来形成箭头 (->)，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需指定数据类型。在函数体内，通过使用
    return 关键字后跟你要返回的值来返回该值➋。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值后结束。如果你在返回语句之后编写任何代码，它将被忽略，因为
    return 会使函数退出。
- en: '![Image](Image00164.jpg)'
  id: totrans-5569
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-5570
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-5571
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-5572
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，volumeOfBox(_:_:_:) 函数计算了边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 volumeOfBox1 的常量中。在➋，边长为
    8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1068]'
  id: totrans-5573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1068]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-5574
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-5575
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-5576
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，该函数接受一个测试分数的数组并返回平均分。为了得到平均分，你需要将所有分数加在一起，然后除以分数的总数。在你的playground中输入以下代码：
- en: '[PRE1069]'
  id: totrans-5577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1069]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-5578
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要求出所有数值的总和。在➊处，我们定义了一个名为sum的Int类型变量，并将其初始化为0。➋处的for-in循环会遍历scores数组中的每个值，并将其加到sum变量中。当循环完成时，变量sum保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，这就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-5579
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果数组为空呢？你不能将某个数除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致“除以零”错误并使程序崩溃。因此，在进行除法时，务必确保你要除的数不是零，这正是我们在➌处通过检查scores.count
    > 0来确保的。在➍处，我们通过将分数的总和除以数组中分数的个数来返回平均值，使用return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋给新变量的步骤，直接返回sum
    / scores.count，因为它的结果是Int类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-5580
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在scores.count不大于零时返回一个值，否则会报错提示函数缺少返回值。我们通过在if语句中添加else来处理这个问题，返回0
    ➎。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-5581
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-5582
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给averageOf()函数时，就像在➊处那样，返回值是分数的平均值，并显示在结果面板中。如果你传入一个空数组，就像在➋处那样，返回值是0。
- en: '**NOTE**'
  id: totrans-5583
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-5584
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句实际上并不是必须的。因为如果scores.count > 0，那么函数会在return sum /
    scores.count时提前结束。所以如果程序已经通过了那个if语句，就说明scores.count > 0不成立，我们完全可以直接用return 0，而不需要将其放在else语句中。然而，如果我们保留else语句，代码会更加清晰易懂。有时候，写一些额外的代码来让其他人更容易理解，比起使用一些巧妙的简写要更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-5585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的知识**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-5586
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为自己的Swift工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做各种各样的惊人事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-5587
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建类型不同于Swift默认类型的常量和变量，这在你创建应用时非常有用！
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  id: totrans-5588
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：Xcode的自动补全功能会显示函数的输入参数。*'
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-5589
  prefs: []
  type: TYPE_NORMAL
  zh: 按ENTER键自动完成函数。光标会移动到函数的括号内（参见[图7-3](text00017.html#ch07fig3)），此时Xcode已自动添加了占位符文本，告诉你函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-5590
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-5591
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：Xcode等待你填写guest参数。*'
- en: '**NOTE**'
  id: totrans-5592
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-5593
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递一个不是字符串的内容给invite(guest:)函数，例如invite(guest: 45)，你会得到一个错误，因为这个函数期望一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-5594
  prefs: []
  type: TYPE_NORMAL
  zh: 只需输入"Cathy"或其他朋友的名字代替String，然后按TAB键完成函数调用。它应该像[图7-4](text00017.html#ch07fig4)所示。
- en: '![Image](Image00157.jpg)'
  id: totrans-5595
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-5596
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：一个invite(guest:)函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-5597
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，使用你朋友的名字调用三次invite(guest:)函数：
- en: '[PRE1070]'
  id: totrans-5598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1070]'
- en: 'The output looks like this:'
  id: totrans-5599
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来是这样的：
- en: '[PRE1071]'
  id: totrans-5600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1071]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-5601
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你可以快速打印三份派对邀请函，每一份都发给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-5602
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-5603
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过传入一个字符串数组作为参数，而不是单个字符串，编写一个函数一次性邀请所有朋友。在你编写了invite(guest:)函数的同一个游乐场中，编写以下invite(allGuests:)函数来测试此功能。注意，参数名现在是复数形式，因为我们将一次邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-5604
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE1072]'
  id: totrans-5605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1072]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-5606
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]是用方括号表示的➊。方括号声明了数据类型为数组，String表示数组中元素的类型是字符串。通过使用[String]，我们声明了这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-5607
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们希望使用一个for-in循环遍历我们的客人数组，并为每个客人打印邀请函。还记得我们刚才创建的打印邀请函的函数吗？让我们在这里使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本显示的是现有的行）：
- en: '[PRE1073]'
  id: totrans-5608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1073]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-5609
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对字符串数组allGuests中的每个客人调用单数的invite(guest:)函数，以邀请每个朋友参加生日派对。你可能会想知道invite(guest:)和invite(allGuests:)是否是相同的函数。毕竟，它们的名称都叫invite。尽管名字相同，它们实际上是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常会看到的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-5610
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用这个数组。
- en: '[PRE1074]'
  id: totrans-5611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1074]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-5612
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后，我们用这个新的数组作为函数输入，调用函数 ➋。这是你将在调试控制台中看到的输出（-- snip --表示我们为节省空间省略的部分）：
- en: '[PRE1075]'
  id: totrans-5613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1075]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-5614
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每位朋友写出邀请函，那将是非常繁琐的工作。但凭借函数的强大功能，你只用了几行代码就完成了这一任务。试着创建你自己的朋友数组，想多长就多长！然后使用你新的数组作为输入调用invite(allGuests:)函数。真是轻松搞定！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-5615
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向宾客发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-5616
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期临近，而一些宾客尚未回复是否出席。你想要最终确认宾客人数，并告诉他们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据宾客的RSVP状态向每个宾客发送定制消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-5617
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-5618
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个字符串参数用于表示宾客的姓名，另一个布尔值参数用于表示是否回复出席（RSVP）状态，值可以是true或false。请输入以下代码到你的playground中：
- en: '[PRE1076]'
  id: totrans-5619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1076]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-5620
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间添加逗号 ➊。每个参数都需要有一个参数名，后面跟上冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，这些参数的类型可以不同。在sendMessage(guest:rsvped:)函数中，我们传入一个字符串类型的guest和一个布尔类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-5621
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为true ➋，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最终print语句无论rsvped值是true还是false都会执行，因为它们位于if-else语句的外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-5622
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的宾客已经回复出席，他们将收到以下消息：
- en: '[PRE1077]'
  id: totrans-5623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1077]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-5624
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有回复，他们将收到一条礼貌的通知，请求他们做出回应：
- en: '[PRE1078]'
  id: totrans-5625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1078]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-5626
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一位宾客的rsvped值设置为true，另一位设置为false，这样你就能看到两种消息的效果。
- en: '[PRE1079]'
  id: totrans-5627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1079]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-5628
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个具有多个输入参数的函数与调用一个仅有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-5629
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能将帮助你填写输入值，通过为你提供参数标签。你只需要传入你想要使用的值。填写宾客姓名后，按下TAB键，Xcode会将光标自动定位到下一个输入框。（参见[图
    7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-5630
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-5631
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入宾客姓名后按TAB键将光标移动到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-5632
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，如姓名或数字，你将会得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-5633
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-5634
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，当你调用 print(_:) 时，并没有在输入值前添加参数标签？你只需写：
- en: '[PRE1080]'
  id: totrans-5635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1080]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-5636
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包括一个标签，你将会得到一个错误：
- en: '[PRE1081]'
  id: totrans-5637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1081]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-5638
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且它将与参数名称相同。然而，如果你编写的函数中不认为需要参数标签来让代码更加清晰，你可以在函数定义中显式地省略它。例如，在
    print(_:) 函数中，很明显你传入的是一个字符串，它将被打印出来。如果每次调用 print(_:) 都必须包括一个类似 inputString 的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-5639
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号和最后的参数数据类型来实现这一点。在函数声明时，也就是在 func
    关键字后面的函数括号内声明参数时，你需要完成所有这些操作。这通常在 Swift 函数中使用，目的是使函数调用看起来更像一个完整的句子。[图 7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-5640
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-5641
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-5642
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用时传入的参数是 "Colin"。如果没有单独的参数标签，当你调用该函数时，它将是
    sayHello(friend:)，这听起来不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-5643
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-5644
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-5645
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，看看如何添加自定义参数标签使你的代码更加可读。在生日聚会之后，你可能想给所有来宾发送感谢卡。请在你的 Playground 中编写以下函数：
- en: '[PRE1082]'
  id: totrans-5646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1082]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-5647
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了一个自定义参数标签 to。类似地，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名称
    guest ➌ 和 gift ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-5648
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，如下所示：
- en: '[PRE1083]'
  id: totrans-5649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1083]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-5650
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到to:在第一个输入值之前写在函数调用中，而for:则写在第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用中使用它。如果尝试使用参数名称，系统会报错：
- en: '[PRE1084]'
  id: totrans-5651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1084]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-5652
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能会始终为你填充参数标签，所以你无需担心函数调用不正确（见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-5653
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-5654
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-5655
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于向一位宾客发送感谢信，*to*表示收信人，*for*表示礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")读起来更像一句完整的句子，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-5656
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-5657
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-5658
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加上下划线和空格来去除它们。在下面的例子中，我们编写了一个计算体积的函数，输入的是盒子的三个边。因为函数名称已经很清楚地表明你需要传入三个边，所以你不需要参数标签来使代码更具可读性。
- en: '[PRE1085]'
  id: totrans-5659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1085]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-5660
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在side1前面加上下划线➊，在side2前面加上下划线➋，以及在side3前面加上下划线➌来去除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-5661
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而无需任何标签。
- en: '[PRE1086]'
  id: totrans-5662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1086]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-5663
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"The volume of this box is 72."。如果你不仅仅是打印盒子的体积，而是将结果存储在一个变量或常量中以便后续使用，这不是更有用吗？让我们看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-5664
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-5665
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着重写volumeOfBoxWithSides(_:_:_:)函数，将体积返回，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-5666
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-5667
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个可以装更多东西。首先，写一个volumeOfBox(_:_:_:)函数，它返回一个Int类型的盒子体积：
- en: '[PRE1087]'
  id: totrans-5668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1087]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-5669
  prefs: []
  type: TYPE_NORMAL
  zh: 要让一个函数有返回值，可以在输入参数后面加上一个破折号和一个大于号（->），然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你通过使用return关键字后跟想要返回的值来返回该值➋。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值后结束。如果在return语句之后再写任何代码，它将被忽略，因为return语句会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-5670
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-5671
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-5672
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-5673
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:) 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在➋处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1088]'
  id: totrans-5674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1088]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-5675
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-5676
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-5677
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，它接受一个测试分数数组并返回平均分。为了获得平均分，你需要将分数相加，然后除以总分数。将以下代码输入到你的
    playground 中：
- en: '[PRE1089]'
  id: totrans-5678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1089]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-5679
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在➊处，我们定义了一个名为 sum 的整数变量，并将其初始值设置为 0。➋处的 for-in 循环遍历 scores 数组中的每个值，并将其加到
    sum 变量中。当循环完成时，sum 变量保存了所有分数的总和。计算完总和后，剩下的就是将其除以总分数，即 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-5680
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空呢？你不能将任何东西除以零——在数学课上，或者在 Swift 中也是如此。在 Swift 中，尝试除以零会导致除零错误，并且程序会崩溃。因此，在进行除法时，始终确保你要除的数不是零，这就是我们通过在➌处检查
    scores.count > 0 来确保的。在➍处，我们通过将分数总和除以数组中的分数数量来返回平均值，使用 return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算得出的平均值赋值给新变量的步骤，直接返回
    sum / scores.count，因为它的结果是一个 Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-5681
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们还需要返回某些内容，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加一个 else
    来处理这个问题，返回 0 ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-5682
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-5683
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 averageOf() 函数时，如我们在➊处所做的那样，分数的平均值将被返回并显示在结果面板中。如果你传入一个空数组，如我们在➋处所做的那样，返回值为
    0。
- en: '**NOTE**'
  id: totrans-5684
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-5685
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0的else语句实际上并不是必需的。这是因为如果scores.count > 0，那么函数已经通过return sum
    / scores.count结束了。所以如果程序已经跳过了if语句，那么我们知道scores.count > 0一定不成立，我们可以直接写一个return
    0，而不需要放在else语句中。然而，如果我们保留else语句，代码会更清晰，更容易理解。有时候，写一些额外的代码让别人更容易理解，比使用一个复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-5686
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-5687
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要的工具——创建并调用你自己的函数！函数在编程中被广泛使用，用来做各种各样的神奇事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-5688
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你创建除Swift中已有类型以外的常量和变量，这在你创建应用程序时非常有用！
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  id: totrans-5689
  prefs: []
  type: TYPE_NORMAL
  zh: 按下ENTER键自动完成函数。光标将移动到函数的括号中（见[图7-3](text00017.html#ch07fig3)），Xcode已自动添加了一些占位符文本，告诉你函数期望的输入类型。
- en: '![Image](Image00156.jpg)'
  id: totrans-5690
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-5691
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：Xcode正在等待你填写guest参数。*'
- en: '**NOTE**'
  id: totrans-5692
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-5693
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递了一个不是字符串的参数给invite(guest:)函数，比如invite(guest: 45)，你会收到错误，因为这个函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-5694
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在String的位置输入"Cathy"或另一个朋友的名字，然后按TAB键完成函数调用。它应该看起来像[图7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-5695
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-5696
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：一个invite(guest:)函数调用示例*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-5697
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用，调用invite(guest:)函数三次，使用你自己朋友的名字：
- en: '[PRE1090]'
  id: totrans-5698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1090]'
- en: 'The output looks like this:'
  id: totrans-5699
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来是这样的：
- en: '[PRE1091]'
  id: totrans-5700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1091]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-5701
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你能够快速打印三张派对邀请函，每张邀请函都写给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-5702
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-5703
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，通过传递一个字符串数组作为参数一次性邀请所有朋友，而不是只传递一个字符串。在你写了invite(guest:)函数的同一个playground中，编写以下invite(allGuests:)函数来测试这个功能。请注意，参数名现在是复数形式，因为我们要一次性邀请多个朋友。
- en: '![Image](Image00158.jpg)'
  id: totrans-5704
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE1092]'
  id: totrans-5705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1092]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-5706
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]位于方括号中 ➊。方括号声明数据类型为数组，String表示数组中值的数据类型。通过使用[String]，我们声明这个函数的输入为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-5707
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们需要使用for-in循环遍历我们的客人数组，并为每个客人打印邀请函。记得我们刚才创建的那个打印邀请函的函数吗？我们可以在这里使用它！将以下代码添加到你的invite(allGuests:)函数中（灰色文本表示现有代码行）：
- en: '[PRE1093]'
  id: totrans-5708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1093]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-5709
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个客人调用单独的invite(guest:)函数，邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟，它们的名字都是invite。不过，尽管名字相同，它们是两个不同的函数，因为它们接受不同的输入参数。这是Swift中你将经常看到的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-5710
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，随后将在函数调用中使用这个数组。
- en: '[PRE1094]'
  id: totrans-5711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1094]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-5712
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后，我们用新的数组作为函数的输入来调用该函数 ➋。这是你将在调试控制台中看到的输出（-- snip --表示我们为节省空间省略的行）：
- en: '[PRE1095]'
  id: totrans-5713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1095]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-5714
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不得不为每个朋友写出邀请函，那将是很大的工作量。但通过函数的强大功能，你只用了非常少的代码行就完成了。试着创建你自己的朋友数组；让它尽可能长！然后用你的新数组作为输入调用invite(allGuests:)函数。真是轻松愉快！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-5715
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**发送消息给你的客人**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-5716
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你的聚会日期即将到来，而一些客人还没有RSVP。你希望最终确认人数，并让客人知道带泳衣，因为这是一个滑水派对。你可以编写一个函数，根据每个客人的RSVP状态，向他们发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-5717
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-5718
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个用于客人姓名的字符串参数和一个用于RSVP状态的布尔参数，RSVP状态的值为true或false。请在你的Playground中输入以下代码：
- en: '[PRE1096]'
  id: totrans-5719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1096]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-5720
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间添加逗号 ➊。每个参数都需要有一个参数名称，后面跟着冒号和该参数的数据类型。你可以创建一个接受任意多个输入参数的函数，这些参数不必是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传入的是一个字符串类型的guest和一个布尔类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-5721
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为true ➋，然后使用if-else语句打印相应的消息。请注意，函数定义中的最终print语句无论rsvped值为true还是false都会执行，因为它们在if-else语句的括号外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-5722
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已RSVP，他们将收到此消息：
- en: '[PRE1097]'
  id: totrans-5723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1097]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-5724
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有RSVP，他们将收到一条礼貌的提示，要求他们回复：
- en: '[PRE1098]'
  id: totrans-5725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1098]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-5726
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一位客人的 `rsvped` 值设为 `true`，另一位设为 `false`，这样你就能看到两条消息的实际效果。
- en: '[PRE1099]'
  id: totrans-5727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1099]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-5728
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-5729
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会帮助你填写输入值，提供参数标签。你只需传入你想要使用的值。填写完客人姓名后，按 TAB 键，Xcode 会将光标移到你需要的位置，以便填写下一个输入值。（参见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-5730
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-5731
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入完客人姓名后，按 TAB 键会将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-5732
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 Bool 替换为 `true` 或 `false`。如果你尝试传入其他内容，如姓名或数字，将会出现错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-5733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-5734
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，当你调用 `print(_:)` 时，输入值前没有参数标签？你只需写：
- en: '[PRE1100]'
  id: totrans-5735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1100]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-5736
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，将会出现错误：
- en: '[PRE1101]'
  id: totrans-5737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1101]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-5738
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而一些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且它与参数名相同。然而，如果你编写一个函数，觉得参数标签并不是必须的，可以在函数定义中显式地省略它。例如，在
    `print(_:)` 函数中，传入的输入显然是一个将要打印的字符串。如果每次调用 `print(_:)` 都要包含一个像 `inputString` 这样的参数标签，那就很麻烦了。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-5739
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号，最后是参数的数据类型来实现。当你在函数声明中首次声明参数时，这些操作会在`func`关键字后的函数括号内进行。Swift
    中经常会这样做，以便让函数调用看起来更像一句话。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-5740
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-5741
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-5742
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 `friend`，参数标签是 `to`，函数调用时传入的参数是 `"Colin"`。如果没有单独的参数标签，调用该函数时将看起来像
    `sayHello(friend:)`，这就不像一句完整的句子了。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-5743
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-5744
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-5745
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，展示添加自定义参数标签如何使代码更具可读性。在你的生日派对后，你会想给所有的客人发送感谢信。请在 Playground 中编写以下函数：
- en: '[PRE1102]'
  id: totrans-5746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1102]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-5747
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 `guest` 参数添加了自定义的参数标签 `to`。类似地，在 ➋ 处，我们为 `gift` 参数添加了参数标签 `for`。参数名称
    `guest` ➌ 和 `gift` ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-5748
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签，`to` 和 `for`，用于标记函数调用时的参数，像这样：
- en: '[PRE1103]'
  id: totrans-5749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1103]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-5750
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `to:` 被写在函数调用的第一个输入值前，`for:` 被写在第二个输入值前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。试图使用参数名称来代替将会导致错误：
- en: '[PRE1104]'
  id: totrans-5751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1104]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-5752
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填写正确的参数标签，因此你不必担心错误地调用函数（见 [图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-5753
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-5754
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-5755
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用来向客人发送感谢信，*to* 表示向谁，*for*
    表示感谢的原因。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 读起来更像一句话，而不是 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-5756
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-5757
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-5758
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加一个下划线和空格来去掉它们。在以下示例中，我们编写了一个用于计算体积的函数，它接受一个盒子的三个边长作为输入。因为函数名已经清楚地表明需要传入三个边长，所以实际上并不需要参数标签来提高代码的可读性。
- en: '[PRE1105]'
  id: totrans-5759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1105]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-5760
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在侧边1（➊）、侧边2（➋）和侧边3（➌）前面放置下划线，来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-5761
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需要输入参数值，而无需任何标签。
- en: '[PRE1106]'
  id: totrans-5762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1106]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-5763
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是72"。如果你不仅仅是打印出盒子的体积，而是将结果存储在变量或常量中以便后续使用，这不是更有用吗？让我们看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-5764
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-5765
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使它返回体积，而不是直接打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-5766
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-5767
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个盒子的容积更大。首先，编写一个 `volumeOfBox(_:_:_:)` 函数，返回盒子的体积（类型为 Int）：
- en: '[PRE1107]'
  id: totrans-5768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1107]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-5769
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数返回值，在函数的输入参数之后使用一个破折号和一个大于号组成箭头 (`->`) ➊ ，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你通过使用
    `return` 关键字后跟你想返回的值来返回该值 ➋ 。如果你写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值之后结束。如果你在返回语句后写任何代码，它将被忽略，因为
    `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-5770
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-5771
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的箱子上调用这个函数，看看它的实际效果：
- en: '![](Image00165.jpg)'
  id: totrans-5772
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-5773
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个边长为 6、5 和 3 的箱子的体积，返回值 90 被存储在一个名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在，让我们打印一条关于哪个箱子更大的消息：
- en: '[PRE1108]'
  id: totrans-5774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1108]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-5775
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台中看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-5776
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-5777
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。我们来写一个函数，它接受一个测试分数数组并返回平均分数。为了得到平均值，你需要将所有分数加起来，然后除以分数的总数。在你的
    playground 中输入以下代码：
- en: '[PRE1109]'
  id: totrans-5778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1109]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-5779
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始值设为 0。位于 ➋ 处的 `for-in`
    循环遍历 `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量保存了所有分数的总和。在我们计算完总和之后，剩下的就是将其除以分数的总数量，即
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-5780
  prefs: []
  type: TYPE_NORMAL
  zh: 可是如果数组为空呢？你不能把任何东西除以零——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试除以零会导致“除以零”错误，并崩溃你的程序。因此，在进行除法运算时，始终确保你将要除的数不是零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来做的。在 ➍ 处，我们通过将分数的总和除以数组中的分数数量来返回平均值，使用 `return sum
    / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋值给新变量的步骤，直接返回 `sum
    / scores.count`，因为它计算结果为 `Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-5781
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一个值，否则会报错提示函数缺少返回值。我们通过在 if 语句中添加 else
    来处理这个问题，返回 0 ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-5782
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-5783
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试成绩数组传递给averageOf()函数时，就像我们在➊所做的那样，函数会返回成绩的平均值并显示在结果窗格中。如果你传入一个空数组，就像我们在➋所做的那样，返回值将是0。
- en: '**NOTE**'
  id: totrans-5784
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-5785
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句其实并不是必须的。这是因为如果scores.count > 0，那么函数会在执行return sum
    / scores.count时已经结束。所以如果程序已经通过了if语句，那么我们知道scores.count > 0一定不成立，因此我们可以直接写return
    0，而不需要将其包裹在else语句中。然而，如果我们保留else语句，代码会更清晰、更容易理解。有时候，写一些额外的代码来让别人更容易理解，比使用一些巧妙的快捷方式要更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-5786
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-5787
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做各种神奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-5788
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这样，你就可以创建具有不同于Swift中内置类型的常量和变量，这在你开发应用程序时会非常有用！
- en: '![Image](Image00156.jpg)'
  id: totrans-5789
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00156.jpg)'
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-5790
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：Xcode正在等待你填写guest参数。*'
- en: '**NOTE**'
  id: totrans-5791
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-5792
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递给invite(guest:)的不是一个字符串，比如invite(guest: 45)，你会得到一个错误，因为该函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-5793
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在String位置输入"Cathy"或其他朋友的名字，然后按TAB键完成函数调用的填写。它应该看起来像[图7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-5794
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-5795
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：一次invite(guest:)函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-5796
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何填写函数调用，三次调用invite(guest:)，使用你自己朋友的名字：
- en: '[PRE1110]'
  id: totrans-5797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1110]'
- en: 'The output looks like this:'
  id: totrans-5798
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1111]'
  id: totrans-5799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1111]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-5800
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你可以快速打印出三张派对邀请函，每张邀请函都送给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-5801
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-5802
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写一个函数，通过传入一个字符串数组作为参数，而不是单个字符串，来一次性邀请所有朋友。在你编写invite(guest:)函数的同一个playground中，编写如下invite(allGuests:)函数来进行测试。注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-5803
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE1112]'
  id: totrans-5804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1112]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-5805
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被放在方括号中➊。方括号声明数据类型为数组，而String表示数组中值的类型。通过使用[String]，我们声明了该函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-5806
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `invite(allGuests:)` 函数内部，我们希望使用 `for-in` 循环遍历我们的 `guests` 数组，为每个客人打印邀请函。还记得我们刚才创建的打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到你的
    `invite(allGuests:)` 函数中（灰色文本表示已有的行）：
- en: '[PRE1113]'
  id: totrans-5807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1113]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-5808
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `for-in` 循环中，我们对 `String` 数组 `allGuests` 中的每个 guest 调用单一的 `invite(guest:)`
    函数，邀请每个客人参加生日派对。你可能会想，`invite(guest:)` 和 `invite(allGuests:)` 是不是同一个函数。毕竟，它们的名称都是
    `invite`。然而，尽管它们共享一个名称，它们是两个不同的函数，因为它们接受不同的输入参数。这是你在 Swift 中经常会遇到的一个模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-5809
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `invite(allGuests:)` 函数，我们首先创建一个名为 friends 的数组，然后在函数调用中使用它。
- en: '[PRE1114]'
  id: totrans-5810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1114]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-5811
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组➊。然后我们用这个新数组作为函数的输入，调用该函数➋。这是你在调试控制台中看到的输出（-- snip -- 显示了我们为节省空间而省略的部分）：
- en: '[PRE1115]'
  id: totrans-5812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1115]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-5813
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不得不为每个朋友写出邀请函，那将需要很多工作。但借助函数的强大功能，你可以用非常少的代码行来完成这个任务。试着创建你自己的朋友数组，长度可以根据需要调整！然后使用你的新数组作为输入，调用
    `invite(allGuests:)` 函数。真是轻松简单！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-5814
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-5815
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的聚会日期临近，但有些客人还没有回复 RSVP。你想要统计最终人数，并告知客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据他们的
    RSVP 状态向每个客人发送自定义消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-5816
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-5817
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个 `String` 类型的参数用于客人的名字，一个 `Bool` 类型的参数用于 RSVP 状态，值为 `true`
    或 `false`。在你的 Playground 中输入以下代码：
- en: '[PRE1116]'
  id: totrans-5818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1116]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-5819
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数需要多个输入参数时，你需要在每个参数之间添加一个逗号➊。每个参数需要有一个参数名称，后面跟着冒号和该参数的数据类型。你可以创建一个接受任意数量输入参数的函数，而且这些参数的类型不必相同。在
    `sendMessage(guest:rsvped:)` 函数中，我们传递了一个 `String` 类型的 guest 和一个 `Bool` 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-5820
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 `rsvped` 值是否为 `true` ➋，然后使用 if-else 语句打印相应的消息。还要注意，函数定义中的最后 print
    语句无论 `rsvped` 的值是 `true` 还是 `false` 都会执行，因为它们在 if-else 语句的括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-5821
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复了 RSVP，他们会收到这个消息：
- en: '[PRE1117]'
  id: totrans-5822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1117]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-5823
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，他们会收到一封礼貌的通知，请求他们做出回应：
- en: '[PRE1118]'
  id: totrans-5824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1118]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-5825
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数来看看它是如何工作的。尝试将一个客人的 rsvped 值设置为 true，另一个客人的设置为 false，这样你就能看到两个消息的效果。
- en: '[PRE1119]'
  id: totrans-5826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1119]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-5827
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调用一个有多个输入参数的函数，和调用一个只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-5828
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会帮助你填写输入值，并为你提供参数标签。你所需要做的就是传入你想使用的值。在填写完客人姓名后，按下 TAB 键，Xcode 会将光标放到你需要的位置，以便填写下一个输入值。（参见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-5829
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-5830
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入完客人姓名后按 TAB 键，光标会跳到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-5831
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，系统会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-5832
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-5833
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，并没有在输入值前加上参数标签？你只是写：
- en: '[PRE1120]'
  id: totrans-5834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1120]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-5835
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图包含一个标签，你将会遇到错误：
- en: '[PRE1121]'
  id: totrans-5836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1121]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-5837
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而一些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且这个标签与参数名称相同。然而，如果你编写的函数中你认为参数标签并不必要，且可以使代码更加简洁清晰，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，传入的参数显然是一个会被打印的字符串。如果每次调用 print(_:) 时都必须包含像 inputString 这样的参数标签，那会显得很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-5838
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，然后是参数的数据类型来实现这一点。所有这些操作都是在你第一次声明函数括号内的参数时完成的，这通常是在
    func 关键字之后。这种做法在 Swift 函数中很常见，它使得函数调用看起来更像一个完整的句子。[图 7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-5839
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-5840
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-5841
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用时传入的参数是 "Colin"。如果没有单独的参数标签，当你调用这个函数时，它会像
    sayHello(friend:) 这样，看起来不太像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-5842
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-5843
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-5844
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，看看如何通过添加自定义参数标签使代码更具可读性。生日派对后，你会想给所有客人发送感谢信。请在你的Playground中编写以下函数：
- en: '[PRE1122]'
  id: totrans-5845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1122]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-5846
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传入函数的`guest`参数添加了一个自定义的参数标签`to`。同样，在➋处，我们为`gift`参数添加了一个参数标签`for`。参数名称`guest`
    ➌ 和 `gift` ➍ 用于表示函数内部的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-5847
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签`to`和`for`用于标记函数调用时的参数，如下所示：
- en: '[PRE1123]'
  id: totrans-5848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1123]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-5849
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到`to:`出现在第一个输入值之前，而`for:`则出现在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用时使用它。否则，使用参数名称会导致错误：
- en: '[PRE1124]'
  id: totrans-5850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1124]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-5851
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能会为你填充参数标签，因此你不必担心错误地调用函数（请参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-5852
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-5853
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全函数，带有正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-5854
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信*to*，感谢他们的礼物*for*。代码`sendThankYou(to:
    "Meghan", for: "puzzle books")`比`sendThankYou(guest: "Meghan", gift: "puzzle books")`更像一句完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-5855
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-5856
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-5857
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加下划线后跟一个空格来移除它们。在以下示例中，我们编写一个用于计算体积的函数，该函数接收盒子的三个边长作为输入。由于函数名已经明确表示需要传入三个边长，因此代码的可读性不需要额外的参数标签。
- en: '[PRE1125]'
  id: totrans-5858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1125]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-5859
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处为side1前添加下划线、在➋处为side2前添加下划线，以及在➌处为side3前添加下划线，移除了边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-5860
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而无需任何标签。
- en: '[PRE1126]'
  id: totrans-5861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1126]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-5862
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"The volume of this box is 72."。如果你不仅仅是打印盒子的体积，而是能将结果存储在一个变量或常量中，以便稍后使用，这不是更方便吗？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-5863
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-5864
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-5865
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-5866
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能装更多的东西。首先，编写一个`volumeOfBox(_:_:_:)`函数，返回盒子的体积（单位：Int）：
- en: '[PRE1127]'
  id: totrans-5867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1127]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-5868
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数指定返回值，使用一个短横线和大于号（`->`）在函数的输入参数后面，并输入返回值的数据类型。请注意，你不需要为返回值指定名称，只需要指定数据类型。在函数体内，使用
    `return` 关键字跟上你要返回的值 ➋。如果你写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数会在你返回值后结束。如果你在返回语句后再写任何代码，它将被忽略，因为
    `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-5869
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-5870
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的箱子上调用函数，观察其效果：
- en: '![](Image00165.jpg)'
  id: totrans-5871
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-5872
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个边长为 6、5 和 3 的箱子的体积，返回值 90 被存储在名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的箱子的体积计算值为 64。现在我们来打印一条关于哪个箱子更大的消息：
- en: '[PRE1128]'
  id: totrans-5873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1128]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-5874
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串 "Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-5875
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-5876
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。我们来写一个函数，它接受一个测试分数的数组并返回平均分。要计算平均分，你需要将所有分数加在一起，然后除以总分数的个数。在你的
    Playground 中输入以下代码：
- en: '[PRE1129]'
  id: totrans-5877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1129]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-5878
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有数值的总和。在 ➊ 处，我们定义一个 `Int` 类型的变量 `sum`，并将其初始值设置为 0。位于 ➋ 的 `for-in`
    循环遍历 `scores` 数组中的每一个值，并将它加到 `sum` 变量中。当循环结束时，变量 `sum` 就包含了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，直接使用
    `scores.count` 就可以了。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-5879
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能用零来除——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试除以零会给你一个除零错误，并导致程序崩溃。因此，在进行除法运算时，一定要确保除数不为零，这也是我们在
    ➌ 处检查 `scores.count > 0` 的原因。接下来在 ➍ 处，我们通过将所有分数的总和除以数组中分数的个数来返回平均值，使用 `return
    sum / scores.count`。没错！你可以返回任何求值后得到正确数据类型的表达式，这意味着我们可以跳过将计算得到的平均值赋值给新变量的步骤，直接返回
    `sum / scores.count`，因为它会求值为一个 `Int` 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-5880
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 `scores.count` 不大于零时返回某个值，否则会出现“函数缺少返回值”的错误。我们通过在 `if` 语句中添加 `else`
    来处理这个问题，返回 0 ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-5881
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-5882
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传入averageOf()函数时，正如我们在➊所做的，函数会返回成绩的平均值并显示在结果面板中。如果你传入一个空数组，正如我们在➋所做的，返回值将是0。
- en: '**NOTE**'
  id: totrans-5883
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-5884
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0周围的else语句其实并不必要。这是因为如果scores.count > 0，函数已经通过return sum / scores.count结束了。所以如果计算机已经通过了那个if语句，我们就知道scores.count
    > 0一定不成立，我们本可以直接写一个return 0，而不需要放在else语句中。然而，如果我们保留else语句，代码会更清晰、更容易理解。有时候，写一些额外的代码来让别人更容易理解，比使用一些巧妙的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-5885
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-5886
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做各种各样的精彩事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-5887
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建除了Swift中已有类型之外的常量和变量，这在你创建应用时会派上大用场！
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  id: totrans-5888
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：Xcode正在等待你填写guest参数。*'
- en: '**NOTE**'
  id: totrans-5889
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-5890
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递给invite(guest:)的不是字符串类型的参数，比如invite(guest: 45)，你会得到一个错误，因为这个函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-5891
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将"Cathy"或其他朋友的名字输入到String的位置，然后按TAB键完成函数调用。它应该看起来像[图7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-5892
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-5893
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：一个invite(guest:)函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-5894
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用，使用你自己朋友的名字调用invite(guest:)三次：
- en: '[PRE1130]'
  id: totrans-5895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1130]'
- en: 'The output looks like this:'
  id: totrans-5896
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE1131]'
  id: totrans-5897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1131]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-5898
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你可以快速打印三份派对邀请函，每份邀请函都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-5899
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-5900
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，通过传递一个字符串数组作为参数，而不是单个字符串，来一次性邀请所有朋友。在你写了invite(guest:)函数的同一个游乐场中，编写以下invite(allGuests:)函数来进行测试。注意，现在参数名是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-5901
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE1132]'
  id: totrans-5902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1132]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-5903
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]是用方括号括起来的➊。方括号声明了数据类型是一个数组，而String表示数组中值的数据类型。通过使用[String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-5904
  prefs: []
  type: TYPE_NORMAL
  zh: 在`invite(allGuests:)`函数中，我们将使用一个`for-in`循环遍历我们的`guests`数组，并为每位客人打印邀请函。还记得我们刚才创建了一个打印邀请函的函数吗？我们将在这里使用它！将以下内容添加到`invite(allGuests:)`函数中（灰色文本显示现有的代码行）：
- en: '[PRE1133]'
  id: totrans-5905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1133]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-5906
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`for-in`循环中，我们对`String`数组`allGuests`中的每个客人调用单一的`invite(guest:)`函数，邀请每个人参加生日派对。你可能会想，`invite(guest:)`和`invite(allGuests:)`是同一个函数吗？毕竟，它们的名字都是`invite`。然而，尽管名字相同，它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常会看到的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-5907
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`invite(allGuests:)`函数，我们首先创建一个名为`friends`的数组，然后在函数调用中使用它。
- en: '[PRE1134]'
  id: totrans-5908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1134]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-5909
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后，我们将这个新数组作为函数的输入，调用该函数 ➋ 。这是你在调试控制台中看到的输出（-- snip --
    显示了我们为节省空间省略的代码行）：
- en: '[PRE1135]'
  id: totrans-5910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1135]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-5911
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不得不为每个朋友写出邀请函，那将是一项艰巨的工作。但借助函数的强大功能，你只需很少的代码行就能完成这项工作。尝试创建你自己的朋友数组；让它尽可能长！然后用这个新数组作为输入调用`invite(allGuests:)`函数。真是轻而易举！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-5912
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发送信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-5913
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近，而一些客人还没有回复RSVP。你想要确认最终的客人名单，并让客人们知道带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据客人的RSVP状态向每位客人发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-5914
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-5915
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个`String`类型的参数用于表示客人姓名，另一个`Bool`类型的参数用于表示RSVP状态，它的值可以是`true`或`false`。在你的playground中输入以下代码：
- en: '[PRE1136]'
  id: totrans-5916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1136]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-5917
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数需要多个输入参数时，你在每个参数之间添加逗号 ➊ 。每个参数需要有一个参数名，后跟一个冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，这些参数不必是相同类型的。在`sendMessage(guest:rsvped:)`函数中，我们传入一个`String`类型的`guest`和一个`Bool`类型的`rsvped`。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-5918
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查`rsvped`的值，看它是否为`true` ➋ ，然后使用`if-else`语句打印相应的消息。注意，函数定义中的最终`print`语句无论`rsvped`的值是`true`还是`false`，都会执行，因为它们在`if-else`语句的花括号外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-5919
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复了RSVP，他们将收到以下消息：
- en: '[PRE1137]'
  id: totrans-5920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1137]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-5921
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提醒，要求他们回复：
- en: '[PRE1138]'
  id: totrans-5922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1138]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-5923
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用函数，看看它是如何工作的。尝试将一个客人的 rsvped 值设置为 true，另一个客人的设置为 false，这样你就可以看到两个消息的实际效果。
- en: '[PRE1139]'
  id: totrans-5924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1139]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-5925
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个具有多个输入参数的函数类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-5926
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全将帮助你填写输入值，自动为你提供参数标签。你只需传入你想要使用的值。填写完客人姓名后，按 TAB 键，Xcode 会将光标移到你需要的位置，以便填写下一个输入值。（参见[图
    7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-5927
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-5928
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按 TAB 键将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-5929
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如姓名或数字，将会出现错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-5930
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-5931
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，在调用 print(_:) 时，你没有在输入值前面加上参数标签？你写的是：
- en: '[PRE1140]'
  id: totrans-5932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1140]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-5933
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，会出现错误：
- en: '[PRE1141]'
  id: totrans-5934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1141]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-5935
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且它与参数名称相同。然而，如果你编写一个函数，认为参数标签对代码的清晰度没有帮助，你可以在函数定义中显式省略它。例如，在
    print(_:) 函数中，传入的输入显然是一个将要打印的字符串。每次调用 print(_:) 时都必须包括像 inputString 这样的参数标签会非常麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-5936
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来做到这一点。这一切都在你第一次在`func`关键字后的函数括号内声明参数时完成。在Swift函数中，这种做法通常是为了让函数调用看起来更像一句完整的句子。[图
    7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-5937
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-5938
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-5939
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，而函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，当你调用该函数时，它会像
    sayHello(friend:) 那样，这听起来不像一句完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-5940
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-5941
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-5942
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，说明如何通过添加自定义参数标签来使你的代码更具可读性。在你生日聚会后，你想向所有的客人发送感谢信。请在你的 playground 中写下以下函数：
- en: '[PRE1142]'
  id: totrans-5943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1142]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-5944
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们给传入函数的 `guest` 参数添加了一个自定义参数标签 `to`。同样地，在 ➋ 处，我们给 `gift` 参数添加了一个参数标签
    `for`。参数名称 `guest` ➌ 和 `gift` ➍ 用来引用函数内部的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-5945
  prefs: []
  type: TYPE_NORMAL
  zh: '`to` 和 `for` 这些参数标签用于在调用函数时标记参数，如下所示：'
- en: '[PRE1143]'
  id: totrans-5946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1143]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-5947
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到，`to:` 被写在第一个输入值之前，`for:` 被写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。否则，使用参数名称会导致错误：
- en: '[PRE1144]'
  id: totrans-5948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1144]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-5949
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填写正确的参数标签，因此你不必担心函数调用错误（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-5950
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-5951
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-5952
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用来向客人发送感谢信，*感谢* 礼物。代码 `sendThankYou(to:
    "Meghan", for: "puzzle books")` 比 `sendThankYou(guest: "Meghan", gift: "puzzle
    books")` 更像一句完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-5953
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-5954
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-5955
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加上一个下划线和空格来移除它们。在以下示例中，我们写了一个计算体积的函数，输入为盒子的三个边长。由于函数名称已经清楚地表明需要传入三个边长，因此代码中其实不需要参数标签来提高可读性。
- en: '[PRE1145]'
  id: totrans-5956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1145]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-5957
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处的 `side1`，➋ 处的 `side2` 和 ➌ 处的 `side3` 前面加下划线来移除它们的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-5958
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE1146]'
  id: totrans-5959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1146]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-5960
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。" 如果你希望不只是打印盒子的体积，而是将结果存储在变量或常量中以便后续使用，这样做会不会更有用呢？让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-5961
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-5962
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，将其修改为返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-5963
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-5964
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能装更多的东西。首先，写一个 `volumeOfBox(_:_:_:)` 函数，返回盒子的体积（Int）：
- en: '[PRE1147]'
  id: totrans-5965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1147]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-5966
  prefs: []
  type: TYPE_NORMAL
  zh: 要为一个函数设置返回值，在函数的输入参数➊后面使用破折号和大于号形成箭头（->），然后输入返回值的数据类型。请注意，你不需要为返回值提供名字，只需提供数据类型。在函数体内，使用
    return 关键字加上你要返回的值 ➋ 来返回该值。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值之后结束。如果你在
    return 语句之后编写任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-5967
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-5968
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数，分别在两个不同的盒子上测试，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-5969
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-5970
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条消息，告诉我们哪个盒子更大：
- en: '[PRE1148]'
  id: totrans-5971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1148]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-5972
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台中看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-5973
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-5974
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，接受一个测试成绩数组并返回平均成绩。为了得到平均值，你需要将所有成绩相加，然后除以成绩的总数。在你的
    playground 中输入以下代码：
- en: '[PRE1149]'
  id: totrans-5975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1149]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-5976
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 变量，并将其初始值设为 0。在 ➋ 处的 for-in 循环遍历 scores
    数组中的每个值，并将它加到 sum 变量中。当循环完成时，sum 变量保存了所有成绩的总和。计算总和之后，剩下的就是将其除以成绩的总数，这就是 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-5977
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能用零去除数——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试用零去除会导致除零错误，并使程序崩溃。因此，在进行除法时，务必确保你要除的数不是零，这就是我们在
    ➌ 处通过检查 scores.count > 0 来实现的。在 ➍ 处，我们通过将分数总和除以数组中分数的数量来返回平均值，使用 return sum /
    scores.count。没错！你可以返回任何计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值分配给新变量的步骤，直接返回 sum / scores.count，因为它会计算出一个
    Int 类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-5978
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们也需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加一个 else
    来处理这一点，它会返回 0 ➎。你可以通过在一个包含分数的数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-5979
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-5980
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给averageOf()函数时，如我们在➊所做的，函数会返回分数的平均值，并显示在结果面板中。如果你传递一个空数组，如我们在➋所做的，返回值将是0。
- en: '**NOTE**'
  id: totrans-5981
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-5982
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句其实并不必要。这是因为如果scores.count > 0，那么函数已经通过return sum /
    scores.count结束了。所以如果计算机已经越过了那个if语句，那么我们知道scores.count > 0一定不为真，这时我们可以直接用return
    0，而不需要放在else语句里。然而，如果我们保留else语句，代码会更加清晰易懂。有时候，写多一点代码以便让其他人更容易理解，比使用巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-5983
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-5984
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，能完成各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-5985
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建不同于Swift中已有类型的常量和变量，这在创建应用程序时非常有用！
- en: '**NOTE**'
  id: totrans-5986
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  id: totrans-5987
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你传递一个不是字符串的东西给invite(guest:)，例如invite(guest: 45)，你会得到一个错误，因为函数期望的是一个字符串。*'
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-5988
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在"String"的位置输入"Cathy"或其他朋友的名字，然后按TAB键完成函数调用。它应该像[图7-4](text00017.html#ch07fig4)一样。
- en: '![Image](Image00157.jpg)'
  id: totrans-5989
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-5990
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：一个invite(guest:)函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-5991
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用invite(guest:)三次，使用你自己朋友的名字：
- en: '[PRE1150]'
  id: totrans-5992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1150]'
- en: 'The output looks like this:'
  id: totrans-5993
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来是这样的：
- en: '[PRE1151]'
  id: totrans-5994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1151]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-5995
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你能够快速打印出三张派对邀请函，每张都写给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-5996
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-5997
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个函数，通过传递一个字符串数组作为参数来一次性邀请所有的朋友，而不是传递单个字符串。在你编写invite(guest:)的同一个Playground中，编写以下invite(allGuests:)函数来进行测试。注意，参数名称现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-5998
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00158.jpg)'
- en: '[PRE1152]'
  id: totrans-5999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1152]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-6000
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]是放在方括号里的➊。方括号声明数据类型为数组，而String表示数组中值的数据类型。通过使用[String]，我们声明了这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-6001
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们需要使用for-in循环遍历我们的客人数组，并为每位客人打印一份邀请函。还记得我们刚才创建的打印邀请函的函数吗？我们可以在这里使用它！将以下代码添加到你的invite(allGuests:)函数中（灰色文本显示的是现有代码行）：
- en: '[PRE1153]'
  id: totrans-6002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1153]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-6003
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对字符串数组allGuests中的每个guest调用单一的invite(guest:)函数，邀请每个人参加生日派对。你可能会想知道invite(guest:)和invite(allGuests:)是不是同一个函数。毕竟，它们都是叫做invite的函数。然而，尽管名字相同，它们实际上是两个不同的函数，因为它们接受不同的输入参数。这是Swift中常见的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-6004
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用这个数组。
- en: '[PRE1154]'
  id: totrans-6005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1154]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-6006
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组➊。然后，我们将新数组作为函数的输入，调用该函数➋。这是你在调试控制台中看到的输出（-- snip --显示了为了节省空间我们省略的行）：
- en: '[PRE1155]'
  id: totrans-6007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1155]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-6008
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为每位朋友写出邀请函，那将是非常繁琐的。但借助函数的强大功能，你只用了很少的代码行就完成了。试着创建你自己的朋友数组；你可以根据需要让它变得更长！然后，使用新的数组作为输入，调用invite(allGuests:)函数。真是轻松搞定！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-6009
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-6010
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期临近，而一些客人还没有RSVP。你想要得到最终的到场人数，并告诉客人带上泳衣，因为这将是一个滑水派对。你可以写一个函数，根据RSVP状态向每个客人发送定制消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-6011
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-6012
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个用于客人姓名的字符串参数和一个用于RSVP状态的布尔参数，状态值可以是true或false。在你的playground中输入以下代码：
- en: '[PRE1156]'
  id: totrans-6013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1156]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-6014
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加一个逗号➊。每个参数都需要有一个参数名，后跟冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，并且这些参数不必是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传递了一个字符串类型的guest参数和一个布尔类型的rsvped参数。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-6015
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为true➋，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最终print语句无论rsvped值为true还是false都会执行，因为它们在if-else语句的外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-6016
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经RSVP，他们将收到以下消息：
- en: '[PRE1157]'
  id: totrans-6017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1157]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-6018
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提示，要求他们回复：
- en: '[PRE1158]'
  id: totrans-6019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1158]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-6020
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一位客人的 rsvped 值设置为 true，另一位客人的设置为 false，这样你就能看到两条消息的实际效果。
- en: '[PRE1159]'
  id: totrans-6021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1159]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-6022
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数和调用一个只有一个输入参数的函数是相似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-6023
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会帮助你填写输入值，通过为你提供参数标签。你只需要传入你想要使用的值。填写完客人姓名后，按 TAB 键，Xcode 会将光标放在你需要的位置，以便你填写下一个输入值。（见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-6024
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-6025
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入客人姓名后，按 TAB 键会将光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-6026
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如姓名或数字，你将得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-6027
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-6028
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用 print(_:) 时，你没有在输入值前加上参数标签吗？你应该写：
- en: '[PRE1160]'
  id: totrans-6029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1160]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-6030
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试加上标签，你会得到一个错误：
- en: '[PRE1161]'
  id: totrans-6031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1161]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-6032
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数调用中的参数有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它与参数名称相同。然而，如果你编写的函数中，认为参数标签对于清晰表达代码并非必要，你可以在函数定义中显式地省略它。例如，在
    print(_:) 函数中，很明显你传入的是一个字符串，这个字符串会被打印出来。如果每次调用 print(_:) 时都要包含类似 inputString 的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-6033
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。当你在 func 关键字后第一次声明参数时，你就完成了这些操作。在
    Swift 函数中，通常会这么做，以使函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-6034
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-6035
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-6036
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，当你调用函数时，它看起来像是
    sayHello(friend:)，这就不太像一句完整的句子了。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-6037
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将了解如何编写带有自定义参数标签的函数。我们还会向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-6038
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-6039
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，展示添加自定义参数标签如何让你的代码更加易读。在生日派对之后，你可能会想给所有的客人写感谢信。请在你的playground中写下如下函数：
- en: '[PRE1162]'
  id: totrans-6040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1162]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-6041
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们给传入函数的guest参数添加了一个自定义的参数标签to。同样，在➋处，我们给gift参数添加了一个参数标签for。参数名称guest ➌
    和gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-6042
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for用于标记函数调用时的参数，如下所示：
- en: '[PRE1163]'
  id: totrans-6043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1163]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-6044
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到，to:被写在函数调用中的第一个输入值之前，for:则写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名称代替会导致错误：
- en: '[PRE1164]'
  id: totrans-6045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1164]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-6046
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会始终为你填写参数标签，因此你不需要担心调用函数时出错（见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-6047
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-6048
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7: Xcode自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-6049
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于向客人*发送*感谢信，*感谢*他们的礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")读起来更像一句话，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-6050
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-6051
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-6052
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，你可以通过在参数名称前加上下划线和空格来移除它们。在下面的例子中，我们写了一个计算体积的函数，输入是盒子的三条边。因为函数名已经很清楚地表明你需要传入三条边，所以你不需要参数标签来提高代码的可读性。
- en: '[PRE1165]'
  id: totrans-6053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1165]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-6054
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处的side1、➋处的side2和➌处的side3前面加上下划线，移除了边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-6055
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需要输入参数值，而不需要任何标签。
- en: '[PRE1166]'
  id: totrans-6056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1166]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-6057
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。”如果你能将结果存储到一个变量或常量中，以便后续使用，而不仅仅是打印盒子的体积，岂不是更有用吗？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-6058
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-6059
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-6060
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-6061
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪一个可以装更多的东西。首先，写一个volumeOfBox(_:_:_:)函数，它返回一个Int类型的盒子体积：
- en: '[PRE1167]'
  id: totrans-6062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1167]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-6063
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数提供返回值，使用一个短横线和一个大于符号形成箭头（`->`），紧跟在函数的输入参数后面，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要数据类型。在函数体内，你通过使用
    `return` 关键字和你要返回的值来返回该值 ➋。如果你编写了一个返回值的函数，那么你*必须*在函数内返回该值，否则你会遇到错误。函数在返回值后结束。如果你在返回语句之后写任何代码，它将被忽略，因为
    `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-6064
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-6065
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-6066
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-6067
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 存储在名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1168]'
  id: totrans-6068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1168]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-6069
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-6070
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-6071
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接收一个测试成绩的数组并返回平均成绩。为了得到平均值，你需要将分数加在一起，然后除以总分数的数量。在你的
    playground 中输入以下代码：
- en: '[PRE1169]'
  id: totrans-6072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1169]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-6073
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始值设置为 0。在 ➋ 处的 `for-in`
    循环遍历 `scores` 数组中的每个值，并将其加到 `sum` 变量中。循环结束后，`sum` 变量保存了所有分数的总和。计算完总和后，剩下的就是将它除以总分数，即
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-6074
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能把一个数除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误，并且程序崩溃。因此，在进行除法时，始终确保你将要除的数字不是零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来做到的。在 ➍ 处，我们通过将总分除以数组中的元素数量来返回平均值，使用 `return sum /
    scores.count`。没错！你可以返回任何求值为正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋给新变量的步骤，直接返回 `sum / scores.count`，因为它会求值为一个
    Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-6075
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一些东西，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加一个 `else`，并返回
    0 来处理这个问题 ➎。你可以通过在一个分数数组和一个空数组上调用函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-6076
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-6077
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传入 averageOf() 函数时，如 ➊ 所示，成绩的平均值会被返回并显示在结果面板中。如果你传入一个空数组，如 ➋ 所示，返回值将是
    0。
- en: '**NOTE**'
  id: totrans-6078
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-6079
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句其实并不必要。因为如果 scores.count > 0 ，那么函数已经会通过 return
    sum / scores.count 结束。所以如果计算机已经执行了那个 if 语句，我们就知道 scores.count > 0 一定不成立，这时候我们完全可以直接写
    return 0，而不需要把它放在 else 语句中。然而，如果我们保留 else 语句，代码会更加清晰、易懂。有时候，写一点额外的代码来让别人更容易理解，比起使用复杂的捷径要更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-6080
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-6081
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来完成各种了不起的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-6082
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08) 中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建除 Swift 中已包含的类型之外的常量和变量，这在你创建应用程序时会非常有用！
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  id: totrans-6083
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 String 位置输入 "Cathy" 或其他朋友的名字，然后按 TAB 键完成函数调用。它应该看起来像 [图 7-4](text00017.html#ch07fig4)。
- en: '![Image](Image00157.jpg)'
  id: totrans-6084
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-6085
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：一个 invite(guest:) 函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-6086
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用 invite(guest:) 三次，使用你自己朋友的名字：
- en: '[PRE1170]'
  id: totrans-6087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1170]'
- en: 'The output looks like this:'
  id: totrans-6088
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下所示：
- en: '[PRE1171]'
  id: totrans-6089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1171]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-6090
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你可以迅速打印出三张派对邀请函，每张都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-6091
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-6092
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写一个一次性邀请所有朋友的函数，方法是传入一个字符串数组作为参数，而不是单个字符串。在你编写了 invite(guest:) 函数的同一个 playground
    中，编写以下 invite(allGuests:) 函数来进行测试。注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-6093
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE1172]'
  id: totrans-6094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1172]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-6095
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到 [String] 被放在方括号中 ➊ 。方括号声明了数据类型是一个数组，而 String 则表示数组中值的数据类型。通过使用
    [String] ，我们声明了这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-6096
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们希望使用一个 for-in 循环遍历我们的 guests 数组，并为每个客人打印一张邀请函。记得我们刚刚创建了一个打印邀请函的函数吗？我们可以在这里使用它！在你的
    invite(allGuests:) 函数中添加以下内容（灰色文本表示现有行）：
- en: '[PRE1173]'
  id: totrans-6097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1173]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-6098
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们调用了单一的invite(guest:)函数，对每个字符串数组allGuests中的客人进行邀请。你可能会想，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟它们的名称都是invite。尽管它们名字相同，但实际上是两个不同的函数，因为它们接受不同的输入参数。这是Swift中常见的一个模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-6099
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用这个数组。
- en: '[PRE1174]'
  id: totrans-6100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1174]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-6101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个包含六个朋友的数组➊。然后，我们使用这个新的数组作为函数的输入调用函数➋。在调试控制台中，你将看到如下输出（-- snip -- 表示我们为节省空间省略了部分行）：
- en: '[PRE1175]'
  id: totrans-6102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1175]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-6103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每位朋友写出邀请函，那将会是一项繁重的工作。但借助函数的力量，你可以用极少的代码行数完成这一任务。试着创建你自己的朋友数组，随便多长都行！然后用你的新数组作为输入调用invite(allGuests:)函数。简直轻松得不行！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-6104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-6105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期临近，而一些客人还没有回复是否参加。你想要确认最终的到场人数，并通知客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据客人的RSVP状态发送定制消息给每一位客人。
- en: '![Image](Image00159.jpg)'
  id: totrans-6106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-6107
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个字符串参数表示客人的姓名，一个布尔型参数表示RSVP状态，值为true或false。请在你的Playground中输入以下代码：
- en: '[PRE1176]'
  id: totrans-6108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1176]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-6109
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号➊。每个参数需要有一个参数名，后跟冒号和该参数的数据类型。你可以创建一个接受任意数量输入参数的函数，这些参数可以是不同类型的。在sendMessage(guest:rsvped:)函数中，我们传递了一个字符串类型的guest和一个布尔类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-6110
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped的值是否为true➋，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最后一条print语句无论rsvped值是true还是false都会执行，因为它们在if-else语句的括号外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-6111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已回复，他们将收到以下消息：
- en: '[PRE1177]'
  id: totrans-6112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1177]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-6113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有回复，他们将收到一条礼貌的通知，要求他们回复：
- en: '[PRE1178]'
  id: totrans-6114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1178]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-6115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用该函数看看它是如何工作的。尝试将一个客人的rsvped值设置为true，另一个客人的rsvped值设置为false，这样你就能看到两个不同的消息。
- en: '[PRE1179]'
  id: totrans-6116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1179]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-6117
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个接受多个输入参数的函数，和调用一个只有一个输入参数的函数非常相似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-6118
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会通过为你提供参数标签来帮助你填写输入值。你只需传入你想使用的值。填写完宾客名字后，按 TAB 键，Xcode 会将光标移动到下一个输入框。（参见[图
    7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-6119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-6120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入完宾客名字后，按 TAB 键会将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-6121
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，你将会得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-6122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-6123
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，当你调用 `print(_:)` 时，并没有在输入值前添加参数标签？你只需写：
- en: '[PRE1180]'
  id: totrans-6124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1180]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-6125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加一个标签，你会得到一个错误：
- en: '[PRE1181]'
  id: totrans-6126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1181]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-6127
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而有些没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它将与参数名称相同。然而，如果你编写一个函数，并且觉得参数标签并不是必须的以使代码更清晰，那么你可以在函数定义中显式地省略它。例如，在
    `print(_:)` 函数中，很明显你传入的输入是一个将要被打印的字符串。如果每次调用 `print(_:)` 都要加上像 `inputString` 这样的参数标签，那会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-6128
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。在你第一次声明函数括号中的参数时，就可以做到这一点。这通常在
    Swift 函数中使用，使得函数调用看起来更像一个完整的句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-6129
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-6130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-6131
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 `friend`，参数标签是 `to`，在函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，当你调用该函数时，它会像
    `sayHello(friend:)` 那样，看起来不像一个完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-6132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将介绍如何编写带有自定义参数标签的函数。我们还会展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-6133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-6134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，说明如何通过添加自定义参数标签来使你的代码更具可读性。生日派对后，你会想要给所有的宾客写感谢信。在你的 Playground 中写下以下函数：
- en: '[PRE1182]'
  id: totrans-6135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1182]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-6136
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传递给函数的guest参数添加了自定义的参数标签to。类似地，在➋处，我们为gift参数添加了参数标签for。参数名称guest ➌ 和gift
    ➍用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-6137
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for在函数调用时用于标记参数，如下所示：
- en: '[PRE1183]'
  id: totrans-6138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1183]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-6139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到to:写在第一个输入值之前，而for:写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。如果尝试使用参数名称而不是标签，将会产生错误：
- en: '[PRE1184]'
  id: totrans-6140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1184]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-6141
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能会始终为你填充参数标签，所以你不必担心错误地调用函数（参见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-6142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-6143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动补全函数并使用正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-6144
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于向某个客人*发送*感谢信*为*一个礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")读起来更像一句话，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-6145
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-6146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-6147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加下划线并加一个空格来移除它们。在以下示例中，我们编写了一个计算体积的函数，该函数接受盒子的三个边作为输入。因为函数名称已经明确表示需要传入三个边，所以你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1185]'
  id: totrans-6148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1185]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-6149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处的side1、➋处的side2和➌处的side3前加下划线来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-6150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，你只需输入参数值，而不需要任何标签。
- en: '[PRE1186]'
  id: totrans-6151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1186]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-6152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "The volume of this box is 72."（这个盒子的体积是72）。如果你不仅仅是将盒子的体积打印出来，而是能够将结果存储到变量或常量中以供以后使用，这不是会更有用吗？让我们看看如何通过返回值来做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-6153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-6154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，让它返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-6155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-6156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个可以装更多的东西。首先，编写一个volumeOfBox(_:_:_:)函数，该函数返回一个Int类型的盒子体积：
- en: '[PRE1187]'
  id: totrans-6157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1187]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-6158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给一个函数提供返回值，你需要在函数的输入参数后面使用一个破折号和一个大于号（->），然后输入返回值的数据类型 ➊。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你使用
    return 关键字加上你想返回的值 ➋ 来返回该值。如果你编写的函数返回一个值，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果你在
    return 语句后写任何代码，它会被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-6159
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-6160
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数对两个不同的盒子进行测试，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-6161
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-6162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算了一个边长分别为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在 ➋ 处，边长分别为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1188]'
  id: totrans-6163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1188]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-6164
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-6165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-6166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们写一个函数，接受一个测试成绩数组，并返回平均分。为了计算平均分，你需要将成绩加起来，然后除以总的成绩数量。在你的
    Playground 中输入以下代码：
- en: '[PRE1189]'
  id: totrans-6167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1189]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-6168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始值设为 0。➋ 处的 for-in 循环遍历 scores
    数组中的每个值并将其加到 sum 变量中。当循环完成时，sum 变量将保存所有分数的总和。计算总和后，剩下的就是将其除以总分数的数量，这个数量就是 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-6169
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办？你不能将任何东西除以零——在数学课上，或者在 Swift 中都不行。在 Swift 中，尝试除以零会导致除零错误并使程序崩溃。因此，在进行除法时，始终确保你要除的数字不是零，这就是我们在
    ➌ 处通过检查 scores.count > 0 来做到的。在 ➍ 处，我们通过将所有分数的总和除以数组中的分数数量来返回平均分，使用 return sum
    / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋值给新变量的步骤，直接返回 sum /
    scores.count，因为它计算出的结果是 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-6170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们还需要返回某些内容，否则会出现缺少返回值的错误。我们通过在 if 语句后添加 else 来处理这个问题，返回
    0 ➎。你可以通过调用该函数，传入一个成绩数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-6171
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-6172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整数组的测试分数传递给`averageOf()`函数时，如我们在➊所做的，分数的平均值会被返回并显示在结果窗格中。如果你传入一个空数组，如我们在➋所做的，返回值为0。
- en: '**NOTE**'
  id: totrans-6173
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-6174
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕`return 0`的else语句实际上并不是必要的。因为如果`scores.count > 0`，那么函数已经通过`return
    sum / scores.count`结束了。所以，如果计算机已经通过了那个if语句，我们就知道`scores.count > 0`肯定不为真，我们本可以直接写一个`return
    0`，而不需要将其包裹在else语句中。然而，如果我们保留else语句，代码会更清晰，也更容易理解。有时候，写一点额外的代码让别人更容易理解，比使用复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-6175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-6176
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做各种各样的精彩事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-6177
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建与Swift中已有类型不同的常量和变量，在你创建应用程序时，这会非常有用！
- en: '![Image](Image00157.jpg)'
  id: totrans-6178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00157.jpg)'
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-6179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：`invite(guest:)`函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-6180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用`invite(guest:)`三次，使用你自己朋友的名字：
- en: '[PRE1190]'
  id: totrans-6181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1190]'
- en: 'The output looks like this:'
  id: totrans-6182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下所示：
- en: '[PRE1191]'
  id: totrans-6183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1191]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-6184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的`invite(guest:)`函数，你可以快速打印出三张派对邀请函，每张都发给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-6185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-6186
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写一个函数，通过传入一个字符串数组作为参数，而不是单个字符串，来一次性邀请所有的朋友。在你写了`invite(guest:)`的同一个playground中，编写以下`invite(allGuests:)`函数来进行测试。注意，参数名称现在是复数形式，因为我们将一次邀请多个来宾。
- en: '![Image](Image00158.jpg)'
  id: totrans-6187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00158.jpg)'
- en: '[PRE1192]'
  id: totrans-6188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1192]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-6189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]是方括号包裹的➊。方括号声明了数据类型为数组，而String表示数组中元素的数据类型。通过使用[String]，我们声明了该函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-6190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`invite(allGuests:)`函数中，我们需要使用一个for-in循环遍历我们的来宾数组，并为每位来宾打印邀请函。记得我们刚才创建了一个打印邀请函的函数吗？我们在这里就可以使用它！将以下内容添加到你的`invite(allGuests:)`函数中（灰色文本显示现有的行）：
- en: '[PRE1193]'
  id: totrans-6191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1193]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-6192
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个guest调用单一的invite(guest:)函数，以邀请每个人参加生日派对。你可能会想知道invite(guest:)和invite(allGuests:)是不是同一个函数。毕竟，它们的名称都叫invite。然而，尽管名称相同，它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常会看到的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-6193
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE1194]'
  id: totrans-6194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1194]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-6195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后我们用新数组作为函数的输入调用该函数 ➋。这是你将在调试控制台中看到的输出（-- snip --表示我们为节省空间省略的代码行）：
- en: '[PRE1195]'
  id: totrans-6196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1195]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-6197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为这些朋友中的每一个人写出邀请函，那将会花费很多时间。但凭借函数的力量，你可以用非常少的代码行来完成这项工作。试着创建你自己的朋友数组，想让它多长就多长！然后用这个新数组作为输入调用invite(allGuests:)函数。简直轻松搞定！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-6198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-6199
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近了，而一些客人还没有RSVP。你想最终确认人数，并告知客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个根据客人的RSVP状态向他们发送自定义消息的函数。
- en: '![Image](Image00159.jpg)'
  id: totrans-6200
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-6201
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个String类型的参数表示客人的名字，和一个Bool类型的参数表示RSVP状态，它的值可以是true或false。请在你的游乐场中输入以下代码：
- en: '[PRE1196]'
  id: totrans-6202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1196]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-6203
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数需要多个输入参数时，参数之间需要用逗号分隔 ➊。每个参数需要有一个参数名称，后跟冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，并且这些参数不必是相同的类型。在sendMessage(guest:rsvped:)函数中，我们传递了一个String类型的guest和一个Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-6204
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值，看看它是否为true ➋，然后使用if-else语句打印相应的消息。请注意，函数定义中的最终打印语句无论rsvped值是true还是false都会执行，因为它们位于if-else语句的大括号外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-6205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已回复RSVP，他们将收到以下消息：
- en: '[PRE1197]'
  id: totrans-6206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1197]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-6207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一封礼貌的通知，要求他们做出回应：
- en: '[PRE1198]'
  id: totrans-6208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1198]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-6209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一个客人的rsvped值设置为true，另一个客人的设置为false，这样你就可以看到两个消息的实际效果。
- en: '[PRE1199]'
  id: totrans-6210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1199]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-6211
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个具有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-6212
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会帮助你填写输入值，自动为你提供参数标签。你只需传入你想要使用的值。填写完来宾姓名后，按 TAB 键，Xcode 会将光标放到你需要的位置，以填写下一个输入值。（见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-6213
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-6214
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入来宾姓名后按 TAB 键，会将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-6215
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如姓名或数字，你会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-6216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-6217
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到调用 `print(_:)` 时，输入值前面没有参数标签吗？你只需写：
- en: '[PRE1200]'
  id: totrans-6218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1200]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-6219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包括标签，你会得到一个错误：
- en: '[PRE1201]'
  id: totrans-6220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1201]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-6221
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而一些没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，而且它将与参数名称相同。然而，如果你编写函数时觉得参数标签对清晰代码没有帮助，那么你可以在函数定义中显式省略它。例如，在`print(_:)`函数中，传入的输入显然是一个将被打印的字符串。每次调用`print(_:)`时都包含像`inputString`这样的参数标签会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-6222
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建不同于参数名称的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现这一点。你在声明函数括号内的参数时就可以完成这一切。这通常在
    Swift 函数中使用，以使函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-6223
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-6224
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-6225
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 `friend`，参数标签是 `to`，在函数调用中传入的参数是 `"Colin"`。如果没有单独的参数标签，当你调用函数时，它看起来会像
    `sayHello(friend:)`，这听起来不像一个完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-6226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何编写带有自定义参数标签的函数。我们还将向你展示如何编写一个函数，在其中完全省略参数标签。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-6227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-6228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，说明添加自定义参数标签如何使代码更具可读性。在你的生日派对之后，你会想给所有来宾发送感谢信。请在 Playground 中编写以下函数：
- en: '[PRE1202]'
  id: totrans-6229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1202]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-6230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 `guest` 参数添加了自定义参数标签 `to`。同样，在 ➋ 处，我们为 `gift` 参数添加了标签 `for`。参数名
    `guest` ➌ 和 `gift` ➍ 用于引用函数内部的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-6231
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 `to` 和 `for` 用于在调用函数时标记参数，如下所示：
- en: '[PRE1203]'
  id: totrans-6232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1203]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-6233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `to:` 被写在函数调用的第一个输入值前，而 `for:` 被写在第二个输入值前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。如果试图使用参数名而不是标签，将会报错：
- en: '[PRE1204]'
  id: totrans-6234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1204]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-6235
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填充参数标签，所以你不需要担心错误地调用函数（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-6236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-6237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-6238
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信，*to* 用于表示送给谁，*for*
    用于表示原因。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 看起来更像一句完整的句子，而不是 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-6239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-6240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-6241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前添加一个下划线并加上空格来移除它们。在以下示例中，我们编写了一个用于计算体积的函数，它接受三个盒子的边长作为输入。由于函数名称已经清楚地说明你需要传入三个边长，因此实际上你不需要参数标签来提高代码的可读性。
- en: '[PRE1205]'
  id: totrans-6242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1205]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-6243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 `side1` 前添加下划线（➊），在 `side2` 前添加下划线（➋），以及在 `side3` 前添加下划线（➌），来移除这些边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-6244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你调用这个函数时，只需要输入参数值，而无需任何标签。
- en: '[PRE1206]'
  id: totrans-6245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1206]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-6246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。"。如果你不仅仅是打印盒子的体积，而是将结果存储到一个变量或常量中以便以后使用，那岂不是更有用吗？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-6247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-6248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-6249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-6250
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能装更多东西。首先，编写一个 `volumeOfBox(_:_:_:)` 函数，返回盒子的体积（`Int` 类型）：
- en: '[PRE1207]'
  id: totrans-6251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1207]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-6252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给函数一个返回值，在函数的输入参数后面使用一个破折号和大于号组成一个箭头（-> ），然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，使用
    `return` 关键字后跟你要返回的值来返回该值 ➋ 。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果你在
    `return` 语句后写任何代码，它将被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-6253
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-6254
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-6255
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-6256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ ，volumeOfBox(_:_:_:) 函数计算一个边长分别为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在 ➋ ，边长分别为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条关于哪个盒子更大的信息：
- en: '[PRE1208]'
  id: totrans-6257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1208]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-6258
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-6259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-6260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据某个条件返回不同的值。让我们编写一个函数，它接受一个测试分数数组，并返回平均分。要计算平均分，你将分数加在一起，然后除以分数的总数。在你的
    playground 中输入以下代码：
- en: '[PRE1209]'
  id: totrans-6261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1209]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-6262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ ，我们定义一个名为 sum 的 Int 变量，并将其初始值设置为 0。位于 ➋ 的 for-in 循环遍历 `scores`
    数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量保存了所有分数的总和。在我们计算出总和后，剩下的就是将其除以总分数，即 `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-6263
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空呢？你不能用零去做除法——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并崩溃程序。因此，在进行除法时，始终确保你要除的数不是零，这就是我们在
    ➌ 通过检查 `scores.count > 0` 来实现的。在 ➍ ，我们通过用 `return sum / scores.count` 来返回平均值。没错！你可以返回任何评估为正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋给新变量的步骤，直接返回
    `sum / scores.count`，因为它会评估为一个 Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-6264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 `scores.count` 不大于零时返回一些东西，否则会出现函数缺少返回值的错误。我们通过在 if 语句后添加一个 else
    来处理这个问题，返回 0 ➎ 。你可以通过在一个包含分数的数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-6265
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-6266
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给`averageOf()`函数时，正如我们在➊处所做的，函数会返回成绩的平均值，并显示在结果面板中。如果你传入一个空数组，如➋所示，返回值将是0。
- en: '**NOTE**'
  id: totrans-6267
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-6268
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这个例子中，`return 0`周围的`else`语句其实不是必须的。这是因为如果`scores.count > 0`，那么函数已经会以`return
    sum / scores.count`结束。所以，如果程序已经通过了那个`if`语句，我们知道`scores.count > 0`一定不成立，我们本可以直接使用`return
    0`而不需要加上`else`。然而，如果我们保留`else`语句，代码会更清晰易懂。有时候，写一些多余的代码让别人更容易理解，比使用复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-6269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-6270
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以完成各种令人惊叹的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-6271
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建除了Swift中已有类型之外的常量和变量，这在创建应用程序时非常有用！
- en: '*Figure 7-4: An invite(guest:) function call*'
  id: totrans-6272
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：一个`invite(guest:)`函数调用*'
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-6273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，调用`invite(guest:)`三次，使用你自己朋友的名字：
- en: '[PRE1210]'
  id: totrans-6274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1210]'
- en: 'The output looks like this:'
  id: totrans-6275
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE1211]'
  id: totrans-6276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1211]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-6277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的`invite(guest:)`函数，你可以迅速打印三张派对邀请函，每张都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-6278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-6279
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过传入一个字符串数组作为参数，而不是单个字符串，编写一个函数一次邀请所有朋友。在你编写了`invite(guest:)`的同一个游乐场中，编写以下`invite(allGuests:)`函数来进行测试。请注意，参数名称现在是复数形式，因为我们将一次邀请多个宾客。
- en: '![Image](Image00158.jpg)'
  id: totrans-6280
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE1212]'
  id: totrans-6281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1212]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-6282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到`[String]`被方括号包围 ➊。方括号声明数据类型为数组，而`String`表示数组中值的数据类型。通过使用`[String]`，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-6283
  prefs: []
  type: TYPE_NORMAL
  zh: 在`invite(allGuests:)`函数中，我们将使用`for-in`循环遍历我们的宾客数组，并为每个宾客打印一张邀请函。记得我们之前创建了一个打印邀请函的函数吗？我们可以在这里使用它！在`invite(allGuests:)`函数中添加以下内容（灰色文本表示现有代码行）：
- en: '[PRE1213]'
  id: totrans-6284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1213]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-6285
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `for-in` 循环中，我们对 `allGuests` 字符串数组中的每个客人调用单个的 `invite(guest:)` 函数，邀请每个人参加生日派对。你可能会想，`invite(guest:)`
    和 `invite(allGuests:)` 是不是同一个函数。毕竟，它们的名字都叫 `invite`。然而，尽管名字相同，它们是两个不同的函数，因为它们接受不同的输入参数。这种模式在
    Swift 中经常出现。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-6286
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `invite(allGuests:)` 函数，我们首先创建一个名为 `friends` 的数组，接着在函数调用中使用它。
- en: '[PRE1214]'
  id: totrans-6287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1214]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-6288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个包含六个朋友的数组➊。然后我们用这个新数组作为函数的输入，调用函数➋。这是你将在调试控制台中看到的输出（-- snip -- 表示我们为了节省空间省略的部分行）：
- en: '[PRE1215]'
  id: totrans-6289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1215]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-6290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为每个朋友写邀请函，那将会非常繁琐。但是借助函数的力量，你只用了很少的代码行就完成了这一任务。试着创建一个自己的朋友数组，长度可以任意！然后用你的新数组作为输入，调用
    `invite(allGuests:)` 函数。简直轻松愉快！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-6291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给客人发送信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-6292
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期临近，而有些客人还没有 RSVP。你希望确认最终的人数，并告诉客人们带上泳衣，因为派对将会是一个滑水活动。你可以编写一个函数，根据客人的
    RSVP 状态，向每个客人发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-6293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-6294
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个 String 类型的参数表示客人的名字，另一个 Bool 类型的参数表示 RSVP 状态，值为 true 或 false。请在你的
    Playground 中输入以下代码：
- en: '[PRE1216]'
  id: totrans-6295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1216]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-6296
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号➊。每个参数都需要有一个参数名称，后面跟着冒号和参数的数据类型。你可以创建一个接受任意多个输入参数的函数，而且这些参数不必是相同类型。在
    `sendMessage(guest:rsvped:)` 函数中，我们传入一个 String 类型的 guest 和一个 Bool 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-6297
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 `rsvped` 的值是否为 true➋，然后使用 if-else 语句打印出相应的信息。注意，函数定义中的最后几个 `print`
    语句无论 `rsvped` 的值是 true 还是 false 都会运行，因为它们在 if-else 语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-6298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经 RSVP，他们将收到这条消息：
- en: '[PRE1217]'
  id: totrans-6299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1217]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-6300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一张礼貌的提示，要求他们做出回应：
- en: '[PRE1218]'
  id: totrans-6301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1218]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-6302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一个客人的 `rsvped` 值设置为 true，另一个客人的值设置为 false，这样你就可以看到两个不同的信息效果。
- en: '[PRE1219]'
  id: totrans-6303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1219]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-6304
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个接受多个输入参数的函数，与调用一个只接受一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-6305
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能将帮助你通过提供参数标签来填写输入值。你只需传入你想使用的值。填写完客人姓名后，按 TAB 键，Xcode 会将光标定位到你需要的位置，方便你填写下一个输入值。（见[图
    7-5](text00017.html#ch07fig5)）。
- en: '![Image](Image00160.jpg)'
  id: totrans-6306
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-6307
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按 TAB 键将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-6308
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你`rsvped`的类型。将占位符文本`Bool`替换为`true`或`false`。如果你尝试传入其他内容，比如名字或数字，就会出现错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-6309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-6310
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，当你调用`print(_:)`时，你并没有在输入值前加上参数标签？你是这样写的：
- en: '[PRE1220]'
  id: totrans-6311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1220]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-6312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试加上标签，你会得到一个错误：
- en: '[PRE1221]'
  id: totrans-6313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1221]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-6314
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用中，一些参数有参数标签，而一些没有。默认情况下，当你写一个函数时，每个参数都会有一个参数标签，并且它将与参数名称相同。然而，如果你写一个函数，觉得参数标签在使代码更清晰方面并非必要，那么你可以在函数定义中显式省略它。例如，在`print(_:)`函数中，传入的输入显然是一个将被打印的字符串。每次调用`print(_:)`时都必须包含像`inputString`这样的参数标签会让人觉得很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-6315
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个不同于参数名称的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。当你第一次在`func`关键字后声明函数中的参数时，就会做这些事情。这通常在Swift函数中使用，以使函数调用看起来更像一句完整的句子。[图
    7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-6316
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-6317
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello()函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-6318
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)`函数的输入参数是`friend`，参数标签是`to`，而函数调用中传入的参数是"Colin"。如果没有单独的参数标签，当你调用该函数时，它看起来会像`sayHello(friend:)`，这听起来就不像一句完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-6319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-6320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-6321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，看看添加自定义参数标签如何使代码更具可读性。在你的生日派对之后，你会想给所有客人写感谢信。在你的 Playground 中编写以下函数：
- en: '[PRE1222]'
  id: totrans-6322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1222]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-6323
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递到函数中的 guest 参数添加了一个自定义的参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名
    guest ➌ 和 gift ➍ 用于函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-6324
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 在调用函数时用于标注参数，如下所示：
- en: '[PRE1223]'
  id: totrans-6325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1223]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-6326
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到在函数调用中，to: 写在第一个输入值前，for: 写在第二个输入值前。如果参数有自定义的参数标签，你必须在函数调用中使用它。如果尝试使用参数名而不是标签，会导致错误：'
- en: '[PRE1224]'
  id: totrans-6327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1224]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-6328
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填充参数标签，因此你无需担心函数调用不正确（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-6329
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-6330
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了具有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-6331
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信，*to* 表示发送对象，*for*
    表示感谢的原因。代码 sendThankYou(to: "Meghan", for: "puzzle books") 读起来更像一句话，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-6332
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-6333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-6334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前添加下划线并加一个空格来移除它们。在下面的例子中，我们编写了一个计算体积的函数，接受盒子的三个边长作为输入。因为函数名已经清楚地说明了需要传入三个边长，所以你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1225]'
  id: totrans-6335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1225]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-6336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 side1 ➊、side2 ➋ 和 side3 ➌ 前面加下划线，来移除这些边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-6337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需要输入参数值，而无需标签。
- en: '[PRE1226]'
  id: totrans-6338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1226]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-6339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出 "The volume of this box is 72."。如果不仅仅是打印出盒子的体积，而是能够将结果存储到一个变量或常量中，方便以后使用，那是不是更有用呢？让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-6340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-6341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，让它返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-6342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-6343
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪一个可以装更多的东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，返回盒子的体积（Int 类型）：
- en: '[PRE1227]'
  id: totrans-6344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1227]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-6345
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数添加返回值，在函数的输入参数后面使用破折号和大于号来构成箭头（-> ），然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你通过使用`return`关键字并跟上你想返回的值来返回该值
    ➋。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出错。函数在返回值之后结束。如果你在`return`语句后编写任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-6346
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-6347
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数以查看其执行效果：
- en: '![](Image00165.jpg)'
  id: totrans-6348
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-6349
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)`函数计算了一个边长为6、5和3的盒子的体积，返回值90被存储在一个名为`volumeOfBox1`的常量中。在
    ➋ 处，边长为8、4和2的`volumeOfBox2`被赋值为64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1228]'
  id: totrans-6350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1228]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-6351
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串“Box 1 is the bigger box.”。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-6352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-6353
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，接受一个测试分数的数组并返回平均分数。为了获得平均值，你需要将所有分数加起来，然后除以总的分数数目。在你的Playground中输入以下代码：
- en: '[PRE1229]'
  id: totrans-6354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1229]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-6355
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为`sum`的`Int`变量，并将其初始值设为0。 ➋ 处的`for-in`循环遍历`score`数组中的每个值，并将其加到`sum`变量中。当循环完成时，`sum`变量保存了所有分数的总和。计算完总和后，我们剩下的工作就是将其除以分数的总数，这就是简单的`score.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-6356
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空呢？你不能除以零——无论是在数学课上还是在Swift中。在Swift中，试图除以零会引发除以零错误并导致程序崩溃。因此，在进行除法运算时，始终确保你要除的数字不为零，这也是我们在
    ➌ 处通过检查`score.count > 0`来做到的。在 ➍ 处，我们通过`return sum / scores.count`返回平均值。没错！你可以返回任何评估为正确数据类型的表达式，这意味着我们可以跳过将计算得出的平均值赋给新变量的步骤，直接返回`sum
    / scores.count`，因为它会评估为`Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-6357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`scores.count`不大于零时，我们也需要返回某些内容，否则会报错提示函数缺少返回值。我们通过在`if`语句后添加`else`来处理这个问题，返回值为0
    ➎。你可以通过在包含分数的数组和空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-6358
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-6359
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给averageOf()函数时，正如我们在➊所做的，函数会返回平均成绩并在结果面板中显示。如果你传递一个空数组，正如我们在➋所做的，返回值将是0。
- en: '**NOTE**'
  id: totrans-6360
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-6361
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句实际上并不是必需的。这是因为如果scores.count > 0，函数将已经通过return sum
    / scores.count结束。因此，如果计算机已经通过了if语句，那么我们知道scores.count > 0一定不成立，我们完全可以直接返回0而不需要将其包裹在else语句中。然而，如果我们保留else语句，代码会更加清晰易懂。有时候，写一些额外的代码来让别人更容易理解，比使用一个巧妙的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-6362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-6363
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以完成各种令人惊叹的工作！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-6364
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你创建除Swift中已有类型之外的常量和变量，在创建应用程序时会非常有用！
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  id: totrans-6365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何填写函数调用了，尝试用你朋友的名字三次调用invite(guest:)：
- en: '[PRE1230]'
  id: totrans-6366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1230]'
- en: 'The output looks like this:'
  id: totrans-6367
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来是这样的：
- en: '[PRE1231]'
  id: totrans-6368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1231]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-6369
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你可以快速打印出三份邀请函，每份都写给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-6370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-6371
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过将字符串数组作为参数传递，而不是单个字符串，来编写一个一次性邀请所有朋友的函数。在你编写invite(guest:)的同一个Playground中，编写以下invite(allGuests:)函数进行测试。注意，参数名称现在是复数形式，因为我们将一次邀请多个宾客。
- en: '![Image](Image00158.jpg)'
  id: totrans-6372
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE1232]'
  id: totrans-6373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1232]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-6374
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被括在方括号中➊。方括号声明数据类型为数组，String表示数组中值的数据类型。通过使用[String]，我们将这个函数的输入声明为字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-6375
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们需要使用for-in循环来遍历我们的宾客数组，并为每个宾客打印邀请函。还记得我们刚刚创建了一个打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本显示现有的行）：
- en: '[PRE1233]'
  id: totrans-6376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1233]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-6377
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`for-in`循环中，我们对`String`数组`allGuests`中的每个宾客调用单独的`invite(guest:)`函数，邀请每个人参加生日派对。你可能会想知道`invite(guest:)`和`invite(allGuests:)`是不是同一个函数。毕竟，它们的名字都是`invite`。然而，尽管它们共享相同的名字，但它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常会遇到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-6378
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`invite(allGuests:)`函数，我们首先创建一个名为`friends`的数组，然后在函数调用中使用它。
- en: '[PRE1234]'
  id: totrans-6379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1234]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-6380
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组➊。然后我们用新数组作为函数的输入来调用该函数➋。这是你将在调试控制台中看到的输出（`-- snip --`表示我们省略了某些行以节省空间）：
- en: '[PRE1235]'
  id: totrans-6381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1235]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-6382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友写出邀请函，那将需要很多工作。但凭借函数的强大功能，你只需用几行代码就完成了这项任务。试着创建你自己的朋友数组；你可以让它变得足够长！然后使用你的新数组作为输入来调用`invite(allGuests:)`函数。这简直是轻而易举的事！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-6383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的宾客发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-6384
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期即将到来，而一些宾客还没有确认是否出席。你想要确认最终的宾客人数，并告诉他们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据每个宾客的RSVP状态向他们发送定制消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-6385
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-6386
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个用于宾客姓名的字符串参数和一个用于RSVP状态的布尔值参数，RSVP状态可以是true或false。请在你的游乐场中输入以下代码：
- en: '[PRE1236]'
  id: totrans-6387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1236]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-6388
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，您需要在每个参数之间添加逗号➊。每个参数需要有一个参数名，后面跟着冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，而且这些参数不必是相同类型的。在`sendMessage(guest:rsvped:)`函数中，我们传入一个字符串作为宾客的姓名，并传入一个布尔值作为RSVP状态。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-6389
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查`rsvped`值是否为true➋，然后使用if-else语句打印相应的消息。请注意，函数定义中的最后一条`print`语句无论`rsvped`值是true还是false都会运行，因为它们位于if-else语句的外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-6390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的宾客已确认出席，他们将收到以下消息：
- en: '[PRE1237]'
  id: totrans-6391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1237]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-6392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一封礼貌的通知，要求他们回复：
- en: '[PRE1238]'
  id: totrans-6393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1238]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-6394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数来看看它是如何工作的。尝试将一位宾客的`rsvped`值设置为true，将另一位宾客的值设置为false，这样你就可以看到两条消息的实际效果。
- en: '[PRE1239]'
  id: totrans-6395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1239]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-6396
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数和调用一个只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-6397
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会帮助你填写输入值，自动为你提供参数标签。你只需要传入你想要使用的值。填写完客人名字后，按 TAB 键，Xcode 会把光标放在需要填写下一个输入值的位置。（见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-6398
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-6399
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入客人名字后按 TAB 键，会将光标移动到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-6400
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。把占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他东西，比如名字或数字，会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-6401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-6402
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，你没有在输入值前加上参数标签？你直接写：
- en: '[PRE1240]'
  id: totrans-6403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1240]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-6404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图包含一个标签，你会得到一个错误：
- en: '[PRE1241]'
  id: totrans-6405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1241]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-6406
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用时有参数标签，有些则没有。默认情况下，当你写一个函数时，每个参数都会有一个参数标签，并且标签会与参数名相同。但是，如果你写了一个函数，觉得参数标签对于代码的清晰度并不必要，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，很明显你传入的是一个要打印的字符串。如果每次调用 print(_:) 时都必须包含像 inputString 这样的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-6407
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为每个参数创建一个不同于参数名的参数标签。你通过输入参数标签、参数名、冒号，最后是参数的数据类型来实现。你在函数体内第一次声明参数时，在 func
    关键字后面的括号中做这件事。这通常在 Swift 函数中完成，以使函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)
    展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-6408
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-6409
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-6410
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，而在函数调用中传递的参数是 "Colin"。如果没有单独的参数标签，调用函数时看起来会像是
    sayHello(friend:)，这样听起来不像完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-6411
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何编写带有自定义参数标签的函数。我们还会向你展示如何编写一个省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-6412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-6413
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例，展示如何添加自定义参数标签来使你的代码更具可读性。在你的生日派对后，你会想给所有的客人写感谢信。在你的 Playground 中编写以下函数：
- en: '[PRE1242]'
  id: totrans-6414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1242]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-6415
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传递给函数的guest参数添加了自定义参数标签to。类似地，在➋处，我们为gift参数添加了参数标签for。参数名guest ➌和gift
    ➍用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-6416
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for在函数调用时用于标记参数，像这样：
- en: '[PRE1243]'
  id: totrans-6417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1243]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-6418
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到to:在第一个输入值之前写入，而for:在第二个输入值之前写入。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名将会导致错误：
- en: '[PRE1244]'
  id: totrans-6419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1244]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-6420
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会为你自动填充参数标签，因此你无需担心错误地调用函数（参见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-6421
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-6422
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动完成带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-6423
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常使用介词如*to*、*from*或*with*作为参数标签。在这个示例中，函数用于将感谢信发送*给*客人*感谢*礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")看起来更像一句话，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-6424
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-6425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-6426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前添加一个下划线和一个空格来移除它们。在下面的示例中，我们编写了一个计算体积的函数，它接受盒子的三个边长作为输入。由于函数名已经清楚地表明了需要传入三个边长，因此你不再需要参数标签来使代码更具可读性。
- en: '[PRE1245]'
  id: totrans-6427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1245]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-6428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处将下划线添加到side1前，➋处将下划线添加到side2前，和➌处将下划线添加到side3前来移除两边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-6429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，不再需要任何标签。
- en: '[PRE1246]'
  id: totrans-6430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1246]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-6431
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。”如果你希望能够将结果存储在一个变量或常量中，以便以后使用，而不仅仅是打印盒子的体积，那将会非常有用。让我们看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-6432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-6433
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，让它返回体积而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-6434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-6435
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能装更多东西。首先，编写一个volumeOfBox(_:_:_:)函数，它返回盒子的体积（Int类型）：
- en: '[PRE1247]'
  id: totrans-6436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1247]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-6437
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数返回值，使用破折号和大于号组合成箭头 (-> )，紧跟在函数的输入参数 ➊ 之后，然后输入返回值的数据类型。注意，返回值不需要提供名称，只需要提供数据类型。在函数体内，使用
    return 关键字后跟上你要返回的值 ➋ 来返回该值。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果在
    return 语句之后编写任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-6438
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-6439
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-6440
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-6441
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算边长为 6、5 和 3 的盒子的体积，并将返回值 90 存储在一个名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在，让我们打印出哪个盒子更大：
- en: '[PRE1248]'
  id: totrans-6442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1248]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-6443
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-6444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-6445
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，它接受一个测试分数数组并返回平均分数。要得到平均分数，你将分数加在一起，然后除以总的分数数量。在你的
    playground 中输入以下代码：
- en: '[PRE1249]'
  id: totrans-6446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1249]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-6447
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义一个名为 sum 的 Int 变量，并将其初始化为 0。位于 ➋ 处的 for-in 循环遍历 scores
    数组中的每个值，并将其添加到 sum 变量中。当循环完成时，sum 变量将包含所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数，即 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-6448
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空怎么办？你不能用零除——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并使程序崩溃。因此，在进行除法时，始终确保你将要除的数字不为零，这就是我们在
    ➌ 处通过检查 scores.count > 0 来做的。接着在 ➍ 处，我们通过用 return sum / scores.count 来返回平均值。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回
    sum / scores.count，因为它的结果是一个 Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-6449
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们也需要返回某个值，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加 else 来处理这个问题，返回值为
    0 ➎ 。你可以通过调用该函数来测试一个分数数组和一个空数组：
- en: '![](Image00166.jpg)'
  id: totrans-6450
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-6451
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给averageOf()函数时，如➊所示，函数会返回并显示成绩的平均值。如果你传递一个空数组，如➋所示，返回值将是0。
- en: '**NOTE**'
  id: totrans-6452
  prefs: []
  type: TYPE_NORMAL
  zh: '**备注**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-6453
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句实际上并不是必要的。这是因为如果scores.count > 0，函数已经通过return sum
    / scores.count结束了。所以如果程序已经执行到了if语句之后，我们就知道scores.count > 0一定不为真，我们可以直接使用return
    0，而不需要将其包裹在else语句中。然而，如果我们保留else语句，代码会更加清晰和易于理解。有时候，写一些额外的代码使他人更容易理解，比使用复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-6454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-6455
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，能够完成各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-6456
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建具有不同于Swift中已有类型的常量和变量，这在你创建应用程序时会非常有用！
- en: '[PRE1250]'
  id: totrans-6457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1250]'
- en: 'The output looks like this:'
  id: totrans-6458
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来是这样的：
- en: '[PRE1251]'
  id: totrans-6459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1251]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-6460
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你能够快速打印三张派对邀请函，每一张都寄给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-6461
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有的朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-6462
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写一个函数，通过传递一个字符串数组作为参数，而不是单个字符串，来一次性邀请所有的朋友。在你编写invite(guest:)函数的同一个playground中，写下以下invite(allGuests:)函数来进行测试。注意，参数名称现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-6463
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE1252]'
  id: totrans-6464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1252]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-6465
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]位于方括号中➊。方括号声明了数据类型为数组，而String表示数组中值的数据类型。通过使用[String]，我们将这个函数的输入声明为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-6466
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们将需要使用for-in循环遍历我们的guest数组，并为每个客人打印一个邀请函。还记得我们刚才创建的打印邀请函的函数吗？让我们在这里使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本表示现有的代码行）：
- en: '[PRE1253]'
  id: totrans-6467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1253]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-6468
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个客人调用单一的invite(guest:)函数，邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟，它们的名字都是invite。尽管它们共享相同的名称，但它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中常常会看到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-6469
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后将在函数调用中使用它。
- en: '[PRE1254]'
  id: totrans-6470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1254]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-6471
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组➊。然后，我们使用这个新的数组作为函数的输入来调用函数➋。这是你在调试控制台中看到的输出（-- snip --表示我们省略的行，以节省空间）：
- en: '[PRE1255]'
  id: totrans-6472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1255]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-6473
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不得不为每个朋友写出邀请函，这将是件繁琐的事情。但借助函数的强大功能，你已经通过非常少的代码行完成了这一工作。试着创建你自己的朋友数组，长度随你心意！然后使用新的数组作为输入调用invite(allGuests:)函数。这简直太轻松了！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-6474
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向你的客人发送信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-6475
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近，一些客人还没有RSVP。你想获得最终的客人数量，并通知客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据每个客人的RSVP状态向他们发送个性化信息。
- en: '![Image](Image00159.jpg)'
  id: totrans-6476
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-6477
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个字符串参数表示客人的姓名，另一个布尔值参数表示RSVP状态，其值为true或false。请在你的游乐场中输入以下代码：
- en: '[PRE1256]'
  id: totrans-6478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1256]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-6479
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号➊。每个参数都需要有一个参数名称，后面跟着一个冒号和该参数的数据类型。你可以创建一个接受任意数量输入参数的函数，并且它们不必是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传入了一个String类型的guest和一个Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-6480
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为true➋，然后使用if-else语句打印相应的信息。还要注意，函数定义中的最后打印语句无论rsvped值是true还是false都会执行，因为它们在if-else语句的括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-6481
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经RSVP，他们将收到以下信息：
- en: '[PRE1257]'
  id: totrans-6482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1257]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-6483
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提醒，要求他们回复：
- en: '[PRE1258]'
  id: totrans-6484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1258]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-6485
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一个客人的rsvped值设置为true，将另一个客人的设置为false，这样你就可以看到两种信息的实际效果。
- en: '[PRE1259]'
  id: totrans-6486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1259]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-6487
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-6488
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能将帮助你填写输入值，为你提供参数标签。你只需要传入你想要使用的值。填写完客人姓名后，按TAB键，Xcode将把光标移到下一个需要填写输入值的位置。（参见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-6489
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-6490
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按TAB键，将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-6491
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还告诉你 `rsvped` 的数据类型。将占位符文本 `Bool` 替换为 `true` 或 `false`。如果你尝试传入其他内容，比如名字或数字，系统会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-6492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-6493
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 `print(_:)` 时，你并没有在输入值前加上参数标签？你写的是：
- en: '[PRE1260]'
  id: totrans-6494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1260]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-6495
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，将会报错：
- en: '[PRE1261]'
  id: totrans-6496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1261]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-6497
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用中，有些参数带有参数标签，有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且标签的名称与参数名相同。然而，如果你编写一个函数，并且觉得参数标签并不必要以使代码更清晰，那么你可以在函数定义中明确省略它。例如，在
    `print(_:)` 函数中，很明显你传入的输入是一个字符串，将被打印出来。每次调用 `print(_:)` 时都必须包含类似 `inputString`
    这样的参数标签会让人觉得烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-6498
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号，然后是参数的数据类型来实现。在你第一次声明函数内的参数时，这些操作会在
    `func` 关键字后面的括号内进行。这样做通常是为了让函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-6499
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-6500
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：`sayHello()` 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-6501
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 `friend`，参数标签是 `to`，在函数调用中传入的参数是 `"Colin"`。如果没有单独的参数标签，当你调用该函数时，它会像
    `sayHello(friend:)` 这样，看起来就不像一句完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-6502
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将学习如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-6503
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-6504
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示添加自定义参数标签如何使代码更加易读。在你的生日派对之后，你可能想要给所有的宾客发送感谢信。请在你的 playground 中编写以下函数：
- en: '[PRE1262]'
  id: totrans-6505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1262]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-6506
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 `guest` 参数添加了一个自定义的参数标签 `to`。类似地，在 ➋ 处，我们为 `gift` 参数添加了一个参数标签
    `for`。函数内部的参数名 `guest` ➌ 和 `gift` ➍ 用来引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-6507
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 `to` 和 `for` 用于在函数调用时标记参数，像这样：
- en: '[PRE1263]'
  id: totrans-6508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1263]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-6509
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到，`to:`写在函数调用的第一个输入值前，而`for:`写在第二个输入值前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。试图使用参数名称而不是参数标签会导致错误：
- en: '[PRE1264]'
  id: totrans-6510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1264]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-6511
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会始终为你填充参数标签，因此你无需担心调用函数时出错（见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-6512
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-6513
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动补全函数并添加正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-6514
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常使用像*to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信*to*（给）客人*for*（感谢）礼物。`sendThankYou(to:
    "Meghan", for: "puzzle books")`的代码更像一句话，而不是`sendThankYou(guest: "Meghan", gift:
    "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-6515
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-6516
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-6517
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，你可以通过在参数名称前添加下划线并留一个空格来去除它们。在下面的例子中，我们编写了一个计算体积的函数，该函数接收盒子的三条边作为输入。由于函数名称已经明确表示你需要传入三条边，因此你实际上不需要参数标签来让代码更具可读性。
- en: '[PRE1265]'
  id: totrans-6518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1265]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-6519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`side1`前添加下划线（➊），在`side2`前添加下划线（➋），在`side3`前添加下划线（➌）来移除这些边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-6520
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用该函数时，你只需输入参数值，而无需任何标签。
- en: '[PRE1266]'
  id: totrans-6521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1266]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-6522
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"这个盒子的体积是72。" 如果你不只是简单地打印盒子的体积，而是希望将结果存储在一个变量或常量中以便稍后使用，那该多好呢？让我们来看看如何使用返回值做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-6523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-6524
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着重写`volumeOfBoxWithSides(_:_:_:)`函数，使它返回体积，而不是将体积打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-6525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-6526
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想要知道哪个能装更多的东西。首先，编写一个名为`volumeOfBox(_:_:_:)`的函数，它返回盒子的体积（Int类型）：
- en: '[PRE1267]'
  id: totrans-6527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1267]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-6528
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数提供返回值，在函数输入参数后面使用破折号和大于符号（->）构成箭头➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，使用`return`关键字返回你想要返回的值➋。如果你编写的函数需要返回一个值，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果在`return`语句之后写任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-6529
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-6530
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数来比较两个不同的盒子，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-6531
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-6532
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)`函数计算了一个边长为6、5和3的盒子的体积，返回值90存储在一个名为`volumeOfBox1`的常量中。在
    ➋ 处，边长为8、4和2的`volumeOfBox2`被赋值为64。现在让我们打印一条消息，说明哪个盒子更大：
- en: '[PRE1268]'
  id: totrans-6533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1268]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-6534
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-6535
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-6536
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，它接受一个测试成绩的数组并返回平均分。为了计算平均分，你需要将分数加在一起，然后除以分数的总数。在你的游乐场中输入以下代码：
- en: '[PRE1269]'
  id: totrans-6537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1269]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-6538
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为`sum`的`Int`变量，并将其初始值设为0。在 ➋ 处的`for-in`循环遍历`score`数组中的每个值，并将它们加到`sum`变量中。当循环完成时，`sum`变量保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，简单来说就是`score.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-6539
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能把某个数除以零——在数学课上或者在Swift中都是如此。在Swift中，试图除以零会导致除零错误并使程序崩溃。因此，在进行除法时，始终确保你将要除的数不是零，这就是我们通过检查`score.count
    > 0`在 ➌ 时做的。然后在 ➍ 时，我们通过将分数总和除以数组中的分数数量来返回平均值，使用`return sum / scores.count`。没错！你可以返回任何计算后得到正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回`sum
    / scores.count`，因为它会被计算为一个`Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-6540
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`score.count`不大于零时，我们也需要返回一些值，否则会出现函数缺少返回值的错误。我们通过在`if`语句后添加`else`来处理这一点，返回0
    ➎。你可以通过在一个分数数组和一个空数组上调用函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-6541
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-6542
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给`averageOf()`函数时，就像我们在 ➊ 处做的那样，分数的平均值将被返回并显示在结果面板中。如果你传入一个空数组，就像我们在
    ➋ 处做的那样，返回值是0。
- en: '**NOTE**'
  id: totrans-6543
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-6544
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句其实不是很必要。因为如果 scores.count > 0，那么函数已经会在 return sum
    / scores.count 处结束了。所以如果计算机已经通过了那个 if 语句，那我们知道 scores.count > 0 一定不成立，因此我们可以直接写
    return 0，而不需要把它放在 else 中。然而，如果我们保留 else 语句，代码会更清晰，便于理解。有时候，写一些多余的代码使它对别人更清楚，比用一些巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-6545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的知识**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-6546
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建并调用你自己的函数！函数在编程中被广泛使用，用来做各种神奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-6547
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建类型不同于 Swift 中已包含类型的常量和变量，这在你创建应用时非常有用！
- en: 'The output looks like this:'
  id: totrans-6548
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下所示：
- en: '[PRE1270]'
  id: totrans-6549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1270]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-6550
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 invite(guest:) 函数，你可以快速打印出三份派对邀请函，每份都发给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-6551
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-6552
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写一个一次性邀请所有朋友的函数，通过传入一个字符串数组作为参数，而不是单个字符串。在你编写 invite(guest:) 函数的同一个 Playground
    中，编写以下 invite(allGuests:) 函数进行测试。注意，参数名称现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-6553
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE1271]'
  id: totrans-6554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1271]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-6555
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到 [String] 被放在方括号中 ➊。方括号声明数据类型为数组，String 表示数组中值的数据类型。通过使用
    [String]，我们将这个函数的输入声明为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-6556
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们将使用一个 for-in 循环遍历我们的 guests 数组，并为每个客人打印一份邀请函。还记得我们刚才创建的打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到
    invite(allGuests:) 函数中（灰色文本显示的是已有的代码）：
- en: '[PRE1272]'
  id: totrans-6557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1272]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-6558
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们对字符串数组 allGuests 中的每个 guest 调用单独的 invite(guest:) 函数，将每个人邀请到生日派对上。你可能会想，invite(guest:)
    和 invite(allGuests:) 是不是同一个函数。毕竟，它们的名字都是 invite。尽管它们共享一个名字，但它们是两个不同的函数，因为它们接收不同的输入参数。这是你在
    Swift 中经常会看到的一个模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-6559
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 invite(allGuests:) 函数，我们首先创建一个名为 friends 的数组，然后在函数调用中使用它。
- en: '[PRE1273]'
  id: totrans-6560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1273]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-6561
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后，我们用这个新数组作为函数的输入来调用该函数 ➋。这是你将在调试控制台看到的输出（-- snip -- 表示我们为了节省空间省略的部分）：
- en: '[PRE1274]'
  id: totrans-6562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1274]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-6563
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友写出邀请函，那将是一个非常繁琐的工作。但借助函数的强大功能，你只用了极少的代码就完成了这一任务。试着创建一个你自己的朋友数组；长度可以根据你需要自定义！然后用你新的数组作为输入，调用
    `invite(allGuests:)` 函数。简直轻松极了！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-6564
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-6565
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期即将临近，有些客人还没有RSVP。你希望得到一个最终的名单，并让客人知道需要带上泳衣，因为派对将会有滑水道。你可以写一个函数，根据客人的
    RSVP 状态，向他们发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-6566
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-6567
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个 `String` 类型的参数表示客人名字，一个 `Bool` 类型的参数表示是否RSVP，值为 `true` 或 `false`。在你的
    playground 中输入以下代码：
- en: '[PRE1275]'
  id: totrans-6568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1275]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-6569
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数需要多个输入参数时，你需要在每个参数之间加一个逗号 ➊。每个参数都需要有一个参数名，后面跟着冒号和该参数的数据类型。你可以创建一个接受任意多个输入参数的函数，这些参数不必是相同类型的。在
    `sendMessage(guest:rsvped:)` 函数中，我们传入了一个 `String` 类型的 guest 和一个 `Bool` 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-6570
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 `rsvped` 的值，看它是否为 `true` ➋，然后使用 if-else 语句打印出相应的消息。请注意，函数定义中的最后几行
    print 语句无论 `rsvped` 的值是 `true` 还是 `false` 都会执行，因为它们位于 if-else 语句的括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-6571
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经RSVP，他们会收到如下消息：
- en: '[PRE1276]'
  id: totrans-6572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1276]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-6573
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有RSVP，他们将收到一条礼貌的通知，要求他们回复：
- en: '[PRE1277]'
  id: totrans-6574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1277]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-6575
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一个客人的 `rsvped` 值设置为 `true`，另一个设置为 `false`，这样你就能看到两个消息的实际效果。
- en: '[PRE1278]'
  id: totrans-6576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1278]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-6577
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-6578
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会帮助你填写输入值，为你提供参数标签。你只需要传入你想使用的值。在填写完 guest 名字后，按下 TAB 键，Xcode 会自动把光标移动到下一个输入值的位置。（见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-6579
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-6580
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入客人名字后按 TAB 键会将光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-6581
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 `Bool` 替换为 `true` 或 `false`。如果你尝试传入其他值，比如名字或数字，你会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-6582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-6583
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，在调用 `print(_:)` 时，你没有在输入值前放置参数标签？你是这样写的：
- en: '[PRE1279]'
  id: totrans-6584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1279]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-6585
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，系统会报错：
- en: '[PRE1280]'
  id: totrans-6586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1280]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-6587
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它将与参数名相同。然而，如果你编写了一个函数并认为参数标签不必要，且代码依然清晰，那么你可以在函数定义中明确省略它。例如，在
    `print(_:)` 函数中，输入的内容显然是一个将被打印的字符串。如果每次调用 `print(_:)` 都需要包含像 `inputString` 这样的参数标签，那会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-6588
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的自定义参数标签。你通过输入参数标签、参数名、冒号，最后是参数的数据类型来实现这一点。这一切都在你首次声明函数括号中的参数时完成，紧跟着
    `func` 关键字。这在 Swift 函数中很常见，目的是让函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)
    展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-6589
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-6590
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6: `sayHello()` 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-6591
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 `friend`，参数标签是 `to`，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用函数时会变成
    `sayHello(friend:)`，这听起来就不太像一句完整的句子了。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-6592
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将探讨如何编写带有自定义参数标签的函数。我们还将展示如何编写一个省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-6593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-6594
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，展示添加自定义参数标签如何让你的代码更具可读性。生日派对后，你会想给所有的客人写感谢信。在你的 Playground 中写下以下函数：
- en: '[PRE1281]'
  id: totrans-6595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1281]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-6596
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入的 `guest` 参数添加了一个自定义的参数标签 `to`。类似地，在 ➋ 处，我们为 `gift` 参数添加了一个参数标签 `for`。参数名
    `guest` ➌ 和 `gift` ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-6597
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 `to` 和 `for` 用于在调用函数时标记参数，像这样：
- en: '[PRE1282]'
  id: totrans-6598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1282]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-6599
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到，`to:` 被写在第一个输入值前，而 `for:` 被写在第二个输入值前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名代替会导致错误：
- en: '[PRE1283]'
  id: totrans-6600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1283]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-6601
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填充参数标签，因此你不必担心函数调用不正确（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-6602
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-6603
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全函数并给出正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-6604
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用来向一个客人发送感谢信，*to* 是表示收件人的，*for*
    是表示礼物的。在代码中，sendThankYou(to: "Meghan", for: "puzzle books") 看起来更像一个句子，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-6605
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-6606
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-6607
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加下划线和空格来移除它们。在下面的例子中，我们编写一个计算体积的函数，接受三个盒子的边长作为输入。由于函数名已经明确指出需要传入三个边长，因此你不需要参数标签来提高代码的可读性。
- en: '[PRE1284]'
  id: totrans-6608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1284]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-6609
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 side1 前面加下划线 ➊、side2 前面加下划线 ➋ 和 side3 前面加下划线 ➌ 来移除这些边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-6610
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值而无需任何标签。
- en: '[PRE1285]'
  id: totrans-6611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1285]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-6612
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出 "The volume of this box is 72."。如果你不仅仅是打印盒子的体积，而是能将结果存储在变量或常量中，以便稍后使用，那不是更有用吗？让我们来看看如何通过返回值来做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-6613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-6614
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-6615
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-6616
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，返回盒子的体积（以 Int 形式）：
- en: '[PRE1286]'
  id: totrans-6617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1286]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-6618
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数设置返回值，在函数的输入参数后面使用破折号和大于符号形成箭头 (->)，然后输入返回值的数据类型 ➊。请注意，你不需要为返回值提供名称，只需要数据类型。在函数体内，通过使用
    return 关键字后跟你想要返回的值 ➋ 来返回该值。如果你编写一个返回值的函数，那么你 *必须* 在函数内返回该值，否则会出现错误。函数在返回值后结束。如果你在
    return 语句后写任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-6619
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-6620
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-6621
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-6622
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，volumeOfBox(_:_:_:) 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 volumeOfBox1
    的常量中。在 ➋，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条消息，表示哪个盒子更大：
- en: '[PRE1287]'
  id: totrans-6623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1287]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-6624
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-6625
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-6626
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，它接受一个测试分数的数组并返回平均分数。为了计算平均值，你需要将分数相加，然后除以总的分数数量。在你的
    playground 中输入以下代码：
- en: '[PRE1288]'
  id: totrans-6627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1288]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-6628
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 Int 类型变量，并将其初始值设置为 0。➋ 处的 `for-in` 循环遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环结束时，`sum` 变量保存了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数，这就是简单的
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-6629
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办？你不能用零去除——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误，并使程序崩溃。因此，在进行除法运算时，务必确保你要除的数字不为零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来做的。在 ➍ 处，我们通过将分数的总和除以数组中分数的数量来返回平均值，使用的是 `return sum
    / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算得出的平均值赋给新变量的步骤，直接返回 `sum
    / scores.count`，因为它会计算出一个 Int 类型的结果。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-6630
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 `scores.count` 不大于零时返回某个值，否则会出现缺少返回值的错误。我们通过在 `if` 语句中添加 `else`
    来处理这个问题，返回 0 ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-6631
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-6632
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 `averageOf()` 函数时，就像我们在 ➊ 处做的那样，返回的将是分数的平均值，并显示在结果面板中。如果你传递一个空数组，就像我们在
    ➋ 处做的那样，返回值就是 0。
- en: '**NOTE**'
  id: totrans-6633
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-6634
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 `else` 语句其实并不必要。这是因为如果 `scores.count > 0`，那么函数已经通过
    `return sum / scores.count` 提前结束了。因此，如果计算机已经通过了那个 `if` 语句，那么我们知道 `scores.count
    > 0` 一定是不成立的，我们可以直接使用 `return 0`，而不需要把它包裹在 `else` 语句中。然而，如果我们保留 `else` 语句，代码会更加清晰易懂。有时候，写一点额外的代码，让别人更容易理解，比起使用复杂的快捷方式要更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-6635
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-6636
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要工具——创建并调用你自己的函数！函数在编程中被广泛使用，用来完成各种令人惊叹的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-6637
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建除Swift中已有类型外的常量和变量，这在你开发应用时将大有帮助！
- en: '[PRE1289]'
  id: totrans-6638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1289]'
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-6639
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的invite(guest:)函数，你能够迅速打印出三张派对邀请函，每一张都发给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-6640
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-6641
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过传入一个字符串数组作为参数来编写一个一次性邀请所有朋友的函数，而不是传入单个字符串。在你编写invite(guest:)函数的同一个playground中，编写以下invite(allGuests:)函数来进行测试。注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-6642
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00158.jpg)'
- en: '[PRE1290]'
  id: totrans-6643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1290]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-6644
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被放在方括号中➊。方括号声明数据类型为数组，而String表示数组中值的类型。通过使用[String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-6645
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们需要使用for-in循环遍历我们的guest数组，并为每个客人打印一张邀请函。还记得我们刚才创建的那个打印邀请函的函数吗？让我们在这里用上它！在你的invite(allGuests:)函数中添加以下内容（灰色文字表示现有的行）：
- en: '[PRE1291]'
  id: totrans-6646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1291]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-6647
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个客人调用单个的invite(guest:)函数，邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是相同的函数吗？毕竟，它们的名字都是invite。尽管它们名字相同，但它们是两个不同的函数，因为它们接受不同的输入参数。这是Swift中常见的一种模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-6648
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE1292]'
  id: totrans-6649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1292]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-6650
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组➊。然后，我们将新数组作为函数的输入调用该函数➋。这是你在调试控制台中看到的输出（-- snip -- 表示我们省略了一些行以节省空间）：
- en: '[PRE1293]'
  id: totrans-6651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1293]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-6652
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友单独编写邀请函，那将是一项繁重的工作。但借助函数的强大功能，你用非常少的代码行就完成了这个任务。试着创建你自己的朋友数组，长度可以随意！然后，使用你的新数组作为输入调用invite(allGuests:)函数。简直是小菜一碟！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-6653
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-6654
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近，而一些客人还没有回复邀请。你想要确认最终的到场人数，并让客人知道要带泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据每个客人的RSVP状态向他们发送定制的信息。
- en: '![Image](Image00159.jpg)'
  id: totrans-6655
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-6656
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个 `String` 类型的宾客姓名参数和一个 `Bool` 类型的 RSVP 状态参数，值为 true 或 false。请在你的
    Playground 中输入以下代码：
- en: '[PRE1294]'
  id: totrans-6657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1294]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-6658
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数需要多个输入参数时，你在每个参数之间加上逗号 ➊。每个参数都需要有参数名，后跟冒号和该参数的数据类型。你可以创建一个包含任意数量输入参数的函数，而且这些参数不必是相同类型。在
    `sendMessage(guest:rsvped:)` 函数中，我们传入的是一个 `String` 类型的宾客名称和一个 `Bool` 类型的 RSVP
    状态。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-6659
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 `rsvped` 值是否为 true ➋，然后使用 if-else 语句打印相应的消息。请注意，函数定义中的最后几个 `print`
    语句无论 `rsvped` 值是 true 还是 false 都会执行，因为它们位于 if-else 语句的外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-6660
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的宾客已经确认出席，他们会收到以下消息：
- en: '[PRE1295]'
  id: totrans-6661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1295]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-6662
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提醒，请他们做出回应：
- en: '[PRE1296]'
  id: totrans-6663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1296]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-6664
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一位宾客的 `rsvped` 值设置为 true，另一位宾客设置为 false，这样你就能看到两个消息的效果了。
- en: '[PRE1297]'
  id: totrans-6665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1297]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-6666
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-6667
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会通过提供参数标签帮助你填写输入值。你只需要传入你想使用的值。在填写完宾客名字后，按 TAB 键，Xcode 会将光标移到下一个输入位置，方便你填写下一个输入值。（见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-6668
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-6669
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入宾客姓名后按 TAB 键会将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-6670
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，系统会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-6671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-6672
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 `print(_:)` 时，你并没有在输入值前加上参数标签？你写的是：
- en: '[PRE1298]'
  id: totrans-6673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1298]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-6674
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，系统会报错：
- en: '[PRE1299]'
  id: totrans-6675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1299]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-6676
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数参数有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，且该标签与参数名相同。然而，如果你编写一个函数，觉得参数标签对使代码更清晰并非必要，那么你可以在函数定义中显式省略它。例如，在
    `print(_:)` 函数中，输入的内容显然是一个将被打印的字符串。每次调用 `print(_:)` 时都加上像 `inputString` 这样的参数标签会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-6677
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现这一点。你在第一次声明函数括号中的参数时，就可以做到这一点。Swift
    函数中经常使用这种方式，以使函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-6678
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-6679
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-6680
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，传入的参数值是 "Colin"。如果没有单独的参数标签，当你调用函数时，应该写作
    sayHello(friend:)，这听起来不像是一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-6681
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何编写具有自定义参数标签的函数。我们还将展示如何编写一个省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-6682
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-6683
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过添加自定义参数标签使代码更具可读性。在你的生日派对之后，你会想要给所有客人发送感谢信。请在你的 Playground 中写下以下函数：
- en: '[PRE1300]'
  id: totrans-6684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1300]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-6685
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了一个自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名称
    guest ➌ 和 gift ➍ 用于函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-6686
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于标记函数调用时的参数，如下所示：
- en: '[PRE1301]'
  id: totrans-6687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1301]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-6688
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 写在函数调用中第一个输入值之前，而 for: 写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名称会导致错误：'
- en: '[PRE1302]'
  id: totrans-6689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1302]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-6690
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填充参数标签，因此你不需要担心错误地调用函数（参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-6691
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-6692
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成函数并正确填充参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-6693
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于发送感谢信 *给* 客人 *以感谢* 礼物。代码
    sendThankYou(to: "Meghan", for: "puzzle books") 比 sendThankYou(guest: "Meghan",
    gift: "puzzle books") 更像一个句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-6694
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-6695
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-6696
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加下划线和空格来移除它们。在下面的例子中，我们编写了一个计算体积的函数，接受盒子的三条边作为输入。因为函数名已经清楚地表明你需要传入三条边，所以你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1303]'
  id: totrans-6697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1303]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-6698
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处将`side1`、在 ➋ 处将`side2`、在 ➌ 处将`side3`前面加上下划线来移除边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-6699
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，你只需要输入参数值，而不需要任何标签。
- en: '[PRE1304]'
  id: totrans-6700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1304]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-6701
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“The volume of this box is 72.”。如果你能将盒子的体积结果存储到变量或常量中，以便以后使用，而不仅仅是打印它，岂不是很有用？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-6702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-6703
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-6704
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-6705
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能装更多的东西。首先，编写一个`volumeOfBox(_:_:_:)`函数，该函数返回一个整数作为盒子的体积：
- en: '[PRE1305]'
  id: totrans-6706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1305]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-6707
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数添加返回值，可以在函数的输入参数后面使用一个短横线和大于符号来形成一个箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，你通过使用`return`关键字后跟你想返回的值来返回该值
    ➋ 。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在你返回值后结束。如果在`return`语句后再写任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-6708
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-6709
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-6710
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-6711
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ ，`volumeOfBox(_:_:_:)`函数计算了一个边长分别为6、5和3的盒子的体积，返回值90被存储在一个名为`volumeOfBox1`的常量中。在
    ➋ ，具有边长8、4和2的`volumeOfBox2`被赋值为64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1306]'
  id: totrans-6712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1306]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-6713
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到字符串“Box 1 is the bigger box.”输出到你的调试控制台。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-6714
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-6715
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个接受测试分数数组并返回平均分数的函数。为了得到平均分数，你需要将所有分数加在一起，然后除以总分数的数量。在你的游乐场中输入以下代码：
- en: '[PRE1307]'
  id: totrans-6716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1307]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-6717
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 Int 类型变量，并将它初始化为 0。位于 ➋ 处的 for-in 循环遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量上。当循环完成时，变量 `sum` 保存了所有分数的总和。计算完总和后，剩下的就是将它除以分数的总个数，也就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-6718
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空呢？你不能用零去除以某个数——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会引发除零错误并导致程序崩溃。因此，在进行除法时，始终确保你将要除以的数字不为零，这就是我们在➌
    处通过检查 `scores.count > 0` 来实现的。在 ➍ 处，我们通过将分数的总和除以数组中分数的个数来返回平均值，使用的是 `return sum
    / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算得出的平均值赋值给新变量的步骤，直接返回 `sum
    / scores.count`，因为它计算结果是一个 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-6719
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 `scores.count` 不大于零时返回某个值，否则我们会得到函数缺少返回值的错误。我们通过在 if 语句中添加一个 else
    来处理这个问题，返回 0 ➎。你可以通过在一个分数数组和一个空数组上调用函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-6720
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-6721
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像 ➊ 处那样将一整个测试成绩数组传递给 `averageOf()` 函数时，函数将返回分数的平均值，并在结果面板中显示。如果你传递一个空数组，如
    ➋ 处那样，返回值将是 0。
- en: '**NOTE**'
  id: totrans-6722
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-6723
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 else 语句其实不是必须的。这是因为如果 `scores.count > 0`，那么函数已经通过 `return
    sum / scores.count` 提前结束了。因此，如果计算机已经通过了那个 if 语句，我们就知道 `scores.count > 0` 一定不成立，这时我们可以直接使用
    `return 0`，而不需要将它包裹在 else 语句中。然而，如果我们保留 else 语句，代码会更清晰，更容易理解。有时，多写一点额外的代码来让别人更清楚地理解，比使用一个巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-6724
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-6725
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来完成各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-6726
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08) 中，我们将向你展示如何通过编写类定义来创建自定义对象。这样你就可以创建不同于 Swift
    中已包含类型的常量和变量，这在你开发应用程序时会非常有用！
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  id: totrans-6727
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 `invite(guest:)` 函数，你可以迅速打印出三张派对邀请函，每张都发送给不同的朋友！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-6728
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次性邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-6729
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写一个函数，通过传入一个字符串数组作为参数，而不是传入单个字符串，来一次性邀请所有的朋友。在你编写了invite(guest:)函数的同一个游乐场中，编写以下invite(allGuests:)函数来测试这个。注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-6730
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE1308]'
  id: totrans-6731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1308]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-6732
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]是用方括号括起来的 ➊。方括号声明数据类型为数组，而String表示数组中值的数据类型。通过使用[String]，我们将此函数的输入声明为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-6733
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们希望使用for-in循环遍历我们的客人数组，并为每个客人打印邀请函。记得我们刚刚创建了一个打印邀请函的函数吗？让我们在这里使用它！将以下代码添加到你的invite(allGuests:)函数中（灰色文字显示的是已有的代码行）：
- en: '[PRE1309]'
  id: totrans-6734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1309]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-6735
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对字符串数组allGuests中的每个客人调用单数形式的invite(guest:)函数，以邀请每个人参加生日派对。你可能会想知道invite(guest:)和invite(allGuests:)是不是同一个函数。毕竟，它们都叫做invite。然而，尽管名字相同，它们实际上是两个不同的函数，因为它们接受不同的输入参数。这种模式在Swift中非常常见。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-6736
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE1310]'
  id: totrans-6737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1310]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-6738
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后，我们使用新的数组作为函数的输入，调用这个函数 ➋。这是你在调试控制台中看到的输出（-- snip --表示我们为节省空间省略的部分）：
- en: '[PRE1311]'
  id: totrans-6739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1311]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-6740
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友写邀请函，那将是一项艰巨的工作。但凭借函数的强大功能，你只用了很少的代码行就完成了这一任务。试着创建你自己的朋友数组；可以随便加长它！然后使用你新的数组作为输入，调用invite(allGuests:)函数。多么轻松！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-6741
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-6742
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期临近，部分客人还没有回复是否参加。你想要最终统计人数，并通知客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据客人的RSVP状态，向每位客人发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-6743
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-6744
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将有两个输入参数：一个字符串类型的参数表示客人的名字，另一个布尔类型的参数表示RSVP状态，值为true或false。在你的游乐场中输入以下代码：
- en: '[PRE1312]'
  id: totrans-6745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1312]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-6746
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数需要多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数都需要有一个参数名，后面跟上冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，而且这些参数不需要是相同的类型。在
    `sendMessage(guest:rsvped:)` 函数中，我们传入了一个 String 类型的 guest 和一个 Bool 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-6747
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 `rsvped` 的值是否为 true ➋，然后使用 if-else 语句打印相应的消息。注意，函数定义中的最后一条 print
    语句无论 `rsvped` 值为 true 还是 false 都会执行，因为它们位于 if-else 语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-6748
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经 RSVPed，他们会收到以下消息：
- en: '[PRE1313]'
  id: totrans-6749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1313]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-6750
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提醒，请他们回应：
- en: '[PRE1314]'
  id: totrans-6751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1314]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-6752
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数来看看它是如何工作的。尝试将一个客人的 `rsvped` 值设为 true，另一个客人的设为 false，这样你就可以看到两条消息的效果了。
- en: '[PRE1315]'
  id: totrans-6753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1315]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-6754
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调用一个有多个输入参数的函数与调用一个只有单个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-6755
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全会帮助你填充输入值，并为你提供参数标签。你需要做的就是传入你想要的值。在填写完客人姓名后，按 TAB 键，Xcode 会将光标自动移动到你需要填写下一个输入值的位置。（参见
    [图 7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-6756
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-6757
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按 TAB 键，会将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-6758
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他值，比如姓名或数字，你会收到错误提示。
- en: '**ARGUMENT LABELS**'
  id: totrans-6759
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-6760
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，当你调用 `print(_:)` 时，你没有在输入值前加上参数标签？你只需写：
- en: '[PRE1316]'
  id: totrans-6761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1316]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-6762
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试加入标签，你会收到错误提示：
- en: '[PRE1317]'
  id: totrans-6763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1317]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-6764
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中带有参数标签，而有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且它会与参数名相同。然而，如果你编写一个函数，并且觉得某个参数标签对于清晰代码并非必需，你可以在函数定义中显式地省略它。例如，在
    `print(_:)` 函数中，显然你传入的输入是一个将被打印的字符串。如果每次调用 `print(_:)` 都要加上像 `inputString` 这样的参数标签，那会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-6765
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建不同于参数名称的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。所有这些操作都在你首次声明函数括号内的参数时完成。Swift
    函数中通常会这样做，以使函数调用看起来更像一个完整的句子。[图 7-6](text00017.html#ch07fig6) 说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-6766
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-6767
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-6768
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传递的参数是 "Colin"。如果没有单独的参数标签，调用函数时会像这样
    sayHello(friend:)，这听起来不像是一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-6769
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-6770
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-6771
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，了解如何通过添加自定义参数标签使代码更具可读性。生日聚会后，你可能想给所有的客人发送感谢信。在你的 Playground 中写出以下函数：
- en: '[PRE1318]'
  id: totrans-6772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1318]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-6773
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了参数标签 for。参数名称 guest
    ➌ 和 gift ➍ 用于引用函数内的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-6774
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用来标记函数调用时的参数，像这样：
- en: '[PRE1319]'
  id: totrans-6775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1319]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-6776
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 在第一个输入值之前写出，for: 在第二个输入值之前写出。如果某个参数有自定义的参数标签，那么你必须在函数调用中使用它。尝试使用参数名称而不是标签会导致错误：'
- en: '[PRE1320]'
  id: totrans-6777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1320]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-6778
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会自动为你填充参数标签，因此你不需要担心错误地调用函数（请参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-6779
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-6780
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全函数时使用了正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-6781
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向一位客人发送感谢信 *to* 表示发送对象，*for*
    表示感谢的原因。代码 sendThankYou(to: "Meghan", for: "puzzle books") 看起来更像一句完整的句子，而 sendThankYou(guest:
    "Meghan", gift: "puzzle books") 则不像。'
- en: '![Image](Image00163.jpg)'
  id: totrans-6782
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-6783
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**删除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-6784
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线和空格来去除它们。在下面的示例中，我们编写了一个计算体积的函数，它接受一个盒子的三条边作为输入。因为函数名称已经明确指出需要传入三条边，所以你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1321]'
  id: totrans-6785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1321]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-6786
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处为 `side1`、在 ➋ 处为 `side2` 和在 ➌ 处为 `side3` 前添加下划线，去除了边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-6787
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而无需任何标签。
- en: '[PRE1322]'
  id: totrans-6788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1322]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-6789
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "The volume of this box is 72."。如果你不仅仅是打印盒子的体积，而是能将结果存储在变量或常量中以后再使用，那不是更有用吗？让我们了解一下如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-6790
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-6791
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-6792
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-6793
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想要知道哪个盒子能装更多的东西。首先，编写一个 `volumeOfBox(_:_:_:)` 函数，返回盒子的体积（Int 类型）：
- en: '[PRE1323]'
  id: totrans-6794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1323]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-6795
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数提供返回值，在函数的输入参数后面使用一个破折号和大于号组成一个箭头（->），然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，你可以使用
    `return` 关键字后跟要返回的值来返回该值。如果你编写了一个返回值的函数，那么你*必须*在函数内返回该值，否则会出现错误。函数在返回值之后结束。如果在返回语句之后编写任何代码，它将被忽略，因为
    `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-6796
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-6797
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的盒子调用函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-6798
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-6799
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在让我们打印出关于哪个盒子更大的信息：
- en: '[PRE1324]'
  id: totrans-6800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1324]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-6801
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-6802
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-6803
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，接受一个测试分数的数组并返回平均分数。为了得到平均分数，你需要将所有分数加在一起，然后除以分数的总数。请在你的
    playground 中输入以下代码：
- en: '[PRE1325]'
  id: totrans-6804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1325]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-6805
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 变量，并将其初始化为 0。➋ 处的 for-in 循环会遍历 scores
    数组中的每个值，并将其加到 sum 变量中。当循环完成时，sum 变量保存了所有分数的总和。在计算总和之后，剩下的就是将其除以总分数，即 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-6806
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办？你不能用零来除——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会引发除零错误并导致程序崩溃。因此，在进行除法运算时，一定要确保你要除的数字不是零，这就是我们在
    ➌ 处检查 scores.count > 0 所做的。然后在 ➍ 处，我们通过将分数总和除以数组中分数的数量来返回平均值，使用 return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回
    sum / scores.count，因为它的结果是一个 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-6807
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们还需要返回某个值，否则我们会收到一个函数缺少返回值的错误。我们通过在 if 语句中添加 else
    来处理这个问题，返回 0 ➎。你可以通过传入一个分数数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-6808
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-6809
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 averageOf() 函数时，如我们在 ➊ 处所做的，返回的平均值会显示在结果窗格中。如果你传入一个空数组，如我们在
    ➋ 处所做的，返回值是 0。
- en: '**NOTE**'
  id: totrans-6810
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-6811
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句实际上不是必须的。因为如果 scores.count > 0，那么函数已经会通过 return
    sum / scores.count 提前结束。所以如果计算机已经跳过了那条 if 语句，那么我们就知道 scores.count > 0 一定不成立，我们可以直接返回
    0，而无需将它包含在 else 中。然而，如果我们保留 else 语句，代码会更加清晰，便于理解。有时候，写一些额外的代码来让其他人更容易理解，比使用一些难懂的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-6812
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-6813
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛应用，可以做很多令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-6814
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08) 中，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建除了 Swift 中已有类型之外的常量和变量，这在你创建应用程序时会非常有用！
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  id: totrans-6815
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**一次邀请所有朋友**'
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-6816
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写一个函数，通过传入一个字符串数组作为参数，而不是单个字符串，一次性邀请所有朋友。在你编写invite(guest:)函数的同一个游乐场中，编写以下invite(allGuests:)函数进行测试。注意，参数名现在是复数形式，因为我们将一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-6817
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE1326]'
  id: totrans-6818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1326]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-6819
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当你声明函数的参数时，你会注意到[String]被放在方括号中 ➊ 。方括号声明了数据类型为数组，而String则表示数组中值的数据类型。通过使用[String]，我们声明该函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-6820
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们将使用for-in循环来遍历我们的客人数组，并为每位客人打印一张邀请函。记得我们刚刚创建了一个打印邀请函的函数吗？让我们在这里使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本表示现有的行）：
- en: '[PRE1327]'
  id: totrans-6821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1327]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-6822
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对字符串数组allGuests中的每一位客人调用单一的invite(guest:)函数，邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟，它们都叫invite。然而，尽管名字相同，它们是两个不同的函数，因为它们接受不同的输入参数。这是Swift中你将经常看到的一个模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-6823
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，首先我们创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE1328]'
  id: totrans-6824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1328]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-6825
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后，我们调用该函数，并将新创建的数组作为函数的输入 ➋ 。这是你将在调试控制台看到的输出（-- snip
    -- 表示我们为了节省空间省略了某些行）：
- en: '[PRE1329]'
  id: totrans-6826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1329]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-6827
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友写出邀请函，那将会非常费力。但借助函数的力量，你可以用极少的代码行完成这个任务。试着创建你自己的朋友数组；让它长一些吧！然后将你的新数组作为输入，调用invite(allGuests:)函数。真是轻松愉快！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-6828
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-6829
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的聚会日期临近，而一些客人还没有RSVP。你想要最终确认人数，并提醒客人带泳衣，因为这是一个滑水派对。你可以编写一个函数，根据客人的RSVP状态发送定制的消息给每一位客人。
- en: '![Image](Image00159.jpg)'
  id: totrans-6830
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-6831
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个用于客人姓名的字符串参数和一个用于RSVP状态的布尔值参数，状态为真或假。请在你的游乐场中输入以下代码：
- en: '[PRE1330]'
  id: totrans-6832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1330]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-6833
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数需要多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数需要有一个参数名，后面跟着冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，这些参数不必是相同类型的。在
    sendMessage(guest:rsvped:) 函数中，我们传入了一个 String 类型的 guest 和一个 Bool 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-6834
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 的值是否为 true ➋，然后使用 if-else 语句打印相应的消息。还要注意，函数定义中的最后几个 print
    语句会在 rsvped 值为 true 或 false 时都执行，因为它们在 if-else 语句的括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-6835
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已 RSVP，他们将收到以下信息：
- en: '[PRE1331]'
  id: totrans-6836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1331]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-6837
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提示，请他们回复：
- en: '[PRE1332]'
  id: totrans-6838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1332]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-6839
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数来看看它是如何工作的。试着将一个客人的 rsvped 值设置为 true，另一个客人的设置为 false，这样你就可以看到两个消息的实际效果。
- en: '[PRE1333]'
  id: totrans-6840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1333]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-6841
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-6842
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能将帮助你填充输入值，并为你提供参数标签。你只需要传入你想要使用的值。填写完客人姓名后，按下 TAB 键，Xcode 会自动将光标移到下一个输入字段。（参见
    [图 7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-6843
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-6844
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入完客人姓名后按 TAB 键，将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-6845
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他的值，比如名字或数字，你将会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-6846
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-6847
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，你并没有在输入值前加上参数标签？你写的是：
- en: '[PRE1334]'
  id: totrans-6848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1334]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-6849
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你将会遇到错误：
- en: '[PRE1335]'
  id: totrans-6850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1335]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-6851
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，且标签名称与参数名相同。然而，如果你编写一个函数，并且觉得参数标签并不必要来使代码更加清晰，那么你可以在函数定义中显式省略它。例如，在
    print(_:) 函数中，很明显你传入的输入是一个将被打印的字符串。如果每次调用 print(_:) 都必须包括一个像 inputString 这样的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-6852
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你通过在函数声明时输入参数标签、参数名称、冒号，最后是参数的数据类型来实现这一点。所有这些操作都在函数体内的参数声明时完成，即在
    func 关键字后的圆括号内。这在 Swift 函数中很常见，目的是让函数调用看起来更像一句句子。[图 7-6](text00017.html#ch07fig6)
    展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-6853
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-6854
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-6855
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用函数时会像
    sayHello(friend:)，这听起来不太像完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-6856
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看看如何编写带有自定义参数标签的函数。我们还会展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-6857
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-6858
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，看看添加自定义参数标签如何使你的代码更具可读性。你的生日派对结束后，你会想给所有的客人写感谢信。在你的 playground 中编写以下函数：
- en: '[PRE1336]'
  id: totrans-6859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1336]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-6860
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了参数标签 for。参数名称 guest
    ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-6861
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 *to* 和 *for* 用于在调用函数时标记参数，像这样：
- en: '[PRE1337]'
  id: totrans-6862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1337]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-6863
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，to: 被写在第一个输入值前面，for: 被写在第二个输入值前面。如果一个参数有自定义参数标签，你必须在函数调用中使用它。尝试使用参数名称会导致错误：'
- en: '[PRE1338]'
  id: totrans-6864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1338]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-6865
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会自动为你填写参数标签，因此你不必担心调用函数时出错（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-6866
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-6867
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-6868
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to* 、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向一位客人发送感谢信 *to* 表示“给”，*for*
    表示“为”。代码 sendThankYou(to: "Meghan", for: "puzzle books") 比 sendThankYou(guest:
    "Meghan", gift: "puzzle books") 更像一句完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-6869
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-6870
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-6871
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加一个下划线和一个空格来移除它们。在下面的示例中，我们编写了一个用于计算体积的函数，该函数以盒子的三个边作为输入。因为函数名已经清楚地表明你需要传入三个边，所以实际上不需要参数标签来使代码更具可读性。
- en: '[PRE1339]'
  id: totrans-6872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1339]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-6873
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处的 side1、➋ 处的 side2 和 ➌ 处的 side3 前面放置下划线，来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-6874
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用该函数时，只需要输入参数值，而无需任何标签。
- en: '[PRE1340]'
  id: totrans-6875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1340]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-6876
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "The volume of this box is 72."。如果你不仅仅是打印盒子的体积，而是能够将结果存储到一个变量或常量中，以便稍后使用，那不是会很有用吗？让我们来看看如何通过返回值做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-6877
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-6878
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-6879
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-6880
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个可以装更多的东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，返回一个整数类型的盒子体积：
- en: '[PRE1341]'
  id: totrans-6881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1341]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-6882
  prefs: []
  type: TYPE_NORMAL
  zh: 要为一个函数提供返回值，使用一个破折号和一个大于符号来形成箭头（->），紧跟在函数的输入参数之后 ➊ ，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要数据类型。在函数体内，你通过使用
    return 关键字并跟上你想返回的值来返回该值 ➋ 。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则你将遇到错误。函数在返回值后结束。如果你在返回语句后编写任何代码，它将被忽略，因为
    return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-6883
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-6884
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的盒子调用该函数，查看其效果：
- en: '![](Image00165.jpg)'
  id: totrans-6885
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-6886
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算了一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1342]'
  id: totrans-6887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1342]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-6888
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-6889
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-6890
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接受一个测试成绩数组并返回平均成绩。为了计算平均值，你将所有成绩加起来，然后除以成绩的总数。在你的
    Playground 中输入以下代码：
- en: '[PRE1343]'
  id: totrans-6891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1343]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-6892
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有数值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始化为 0 。在 ➋ 处的 for-in 循环会遍历
    scores 数组中的每个值，并将其加到 sum 变量中。当循环完成时，变量 sum 就保存了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数，简单来说，就是
    scores.count 。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-6893
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空怎么办？你不能对零进行除法——无论是在数学课上还是在 Swift 中。在 Swift 中，试图除以零会导致除以零错误，并崩溃你的程序。因此，在进行除法时，务必确保除数不为零，这就是我们在
    ➌ 处通过检查 scores.count > 0 来做到的。在 ➍ 处，我们通过将总分除以数组中分数的个数来返回平均值，使用 return sum / scores.count
    。没错！你可以返回任何评估为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 sum / scores.count ，因为它的结果是一个
    Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-6894
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 scores.count 不大于零时返回某些东西，否则我们会得到一个函数缺少返回值的错误。我们通过在 if 语句中添加 else
    来处理这个问题，从而返回 0 ➎ 。你可以通过在分数数组和空数组上调用函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-6895
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-6896
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试分数数组传递给 averageOf() 函数时，正如我们在 ➊ 处所做的，分数的平均值会被返回并显示在结果面板中。如果你传入一个空数组，正如我们在
    ➋ 处所做的，返回值将是 0 。
- en: '**NOTE**'
  id: totrans-6897
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-6898
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句其实并不是必需的。这是因为如果 scores.count > 0 ，那么函数已经通过 return
    sum / scores.count 结束了。所以，如果程序已经跳过了那个 if 语句，那么我们知道 scores.count > 0 一定不成立，我们只需使用
    return 0 而不需要将其包含在 else 中。然而，如果保留 else 语句，代码会更清晰，也更容易理解。有时候，写一些额外的代码让其他人更容易理解，比使用一个复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-6899
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-6900
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建并调用你自己的函数！函数在编程中广泛应用，用于执行各种令人惊叹的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-6901
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建除了 Swift 内置类型以外的常量和变量，这在你创建应用程序时会非常有用！
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  id: totrans-6902
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以写一个一次性邀请所有朋友的函数，通过传入一个字符串数组作为参数，而不是单个字符串。在你写了invite(guest:)函数的同一个playground中，写下下面的invite(allGuests:)函数来进行测试。注意，参数名称现在是复数形式，因为我们要一次性邀请多个客人。
- en: '![Image](Image00158.jpg)'
  id: totrans-6903
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE1344]'
  id: totrans-6904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1344]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-6905
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]被包含在方括号中➊。方括号声明了数据类型为数组，而String表示数组中元素的数据类型。通过使用[String]，我们声明该函数的输入为一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-6906
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们需要使用for-in循环来遍历我们的guest数组，并为每个guest打印一个邀请函。记得我们刚才创建了一个打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本显示了现有的代码行）：
- en: '[PRE1345]'
  id: totrans-6907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1345]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-6908
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个guest调用invite(guest:)函数，以邀请每个朋友参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟，它们的名字都是invite。然而，尽管名字相同，它们其实是两个不同的函数，因为它们接受不同的输入参数。这种模式在Swift中经常出现。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-6909
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE1346]'
  id: totrans-6910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1346]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-6911
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个包含六个朋友的数组➊。然后，我们将新数组作为函数的输入，调用这个函数➋。这是你在调试控制台中看到的输出（-- snip --表示我们为了节省空间而省略的代码行）：
- en: '[PRE1347]'
  id: totrans-6912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1347]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-6913
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为每一个朋友写邀请函，那将会花费大量的时间。但凭借函数的强大功能，你可以用非常少的代码行就完成这项工作。试着创建你自己的朋友数组，随意设置它的长度！然后用你的新数组作为输入，调用invite(allGuests:)函数。简直是轻而易举！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-6914
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-6915
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，当你的派对日期即将临近时，某些客人还没有回复确认。你希望得到一个最终的客人名单，并通知他们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据客人的RSVP状态发送自定义消息给每个客人。
- en: '![Image](Image00159.jpg)'
  id: totrans-6916
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-6917
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将有两个输入参数：一个String类型的参数，用于表示客人的名字；一个Bool类型的参数，用于表示RSVP状态，它的值可以是true或false。将以下代码输入到你的playground中：
- en: '[PRE1348]'
  id: totrans-6918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1348]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-6919
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数都需要有一个参数名，后面跟着冒号和数据类型。你可以创建一个函数，接受任意数量的输入参数，并且它们不必是相同类型的。在
    `sendMessage(guest:rsvped:)` 函数中，我们传递了一个 `String` 类型的 guest 和一个 `Bool` 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-6920
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 值是否为 `true` ➋，然后使用 if-else 语句打印相应的消息。还要注意，函数定义中的最终 `print`
    语句会在 rsvped 值为 `true` 或 `false` 时都执行，因为它们在 if-else 语句的外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-6921
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复了，他们会收到以下消息：
- en: '[PRE1349]'
  id: totrans-6922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1349]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-6923
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有参数标签，系统会给出一个礼貌的提示，要求你回复：
- en: '[PRE1350]'
  id: totrans-6924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1350]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-6925
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一个客人的 rsvped 值设置为 `true`，另一个客人的设置为 `false`，这样你就能看到两个消息的效果。
- en: '[PRE1351]'
  id: totrans-6926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1351]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-6927
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调用一个包含多个输入参数的函数类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-6928
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能将帮助你填写输入值，自动提供参数标签。你只需要传入你想使用的值。填写完客人名字后，按 TAB 键，Xcode 会将光标定位到下一个输入框，方便你填写下一个输入值。（见[图
    7-5](text00017.html#ch07fig5)。)
- en: '![Image](Image00160.jpg)'
  id: totrans-6929
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-6930
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入完客人名字后按下 TAB 键，会将光标移至下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-6931
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 `Bool` 替换为 `true` 或 `false`。如果你尝试传递其他内容，比如名字或数字，你将收到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-6932
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-6933
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，当你调用 `print(_:)` 时，输入值前面没有参数标签？你应该写：
- en: '[PRE1352]'
  id: totrans-6934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1352]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-6935
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包括标签，你会收到一个错误：
- en: '[PRE1353]'
  id: totrans-6936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1353]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-6937
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用时有参数标签，而有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，且它与参数名相同。然而，如果你编写一个函数，觉得参数标签不必要，能够使代码更清晰，那么你可以在函数定义中显式省略它。例如，在
    `print(_:)` 函数中，传入的输入显然是一个将被打印的字符串。如果每次调用 `print(_:)` 都必须包括像 `inputString` 这样的参数标签，那会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-6938
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为每个参数创建一个不同于参数名称的参数标签。你可以通过输入参数标签、参数名称、冒号和参数的数据类型来实现这一点。所有这些操作都在你第一次声明函数括号内的参数时完成，位于
    `func` 关键字之后。这种方式在 Swift 函数中很常见，可以使函数调用更像一条完整的句子。[图 7-6](text00017.html#ch07fig6)
    说明了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-6939
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-6940
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-6941
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 `friend`，参数标签是 `to`，而函数调用时传入的参数是 "Colin"。如果没有单独的参数标签，调用函数时会写成
    sayHello(friend:)，这样听起来不像完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-6942
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-6943
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-6944
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，展示如何通过添加自定义参数标签来提高代码的可读性。在你举办完生日派对后，你会想给所有客人发送感谢信。在你的 playground 中编写如下函数：
- en: '[PRE1354]'
  id: totrans-6945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1354]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-6946
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 `guest` 参数添加了自定义的参数标签 `to`。类似地，在 ➋ 处，我们为 `gift` 参数添加了参数标签 `for`。参数名称
    `guest` ➌ 和 `gift` ➍ 用于函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-6947
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用时使用的参数标签 `to` 和 `for` 用于标记参数，像这样：
- en: '[PRE1355]'
  id: totrans-6948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1355]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-6949
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以看到，在函数调用中，`to:` 写在第一个输入值之前，`for:` 写在第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用中使用它。如果尝试使用参数名称代替，会导致错误：
- en: '[PRE1356]'
  id: totrans-6950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1356]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-6951
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全会自动为你填写参数标签，因此你不必担心调用函数时出错（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-6952
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-6953
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成函数并填入正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-6954
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用介词如 *to*、*from* 或 *with* 作为参数标签。在这个例子中，函数用于向客人发送感谢信，*to* 表示向谁，*for*
    表示感谢的内容。代码 sendThankYou(to: "Meghan", for: "puzzle books") 比 sendThankYou(guest:
    "Meghan", gift: "puzzle books") 更像一句完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-6955
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-6956
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-6957
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前添加一个下划线和一个空格来去除它们。在以下示例中，我们编写了一个计算体积的函数，它接受盒子的三个边作为输入。由于函数名已经明确表明需要传入三个边，因此其实并不需要参数标签来提高代码的可读性。
- en: '[PRE1357]'
  id: totrans-6958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1357]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-6959
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在side1前加上下划线（➊），在side2前加上下划线（➋），在side3前加上下划线（➌）来去除参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-6960
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，而无需任何标签。
- en: '[PRE1358]'
  id: totrans-6961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1358]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-6962
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“The volume of this box is 72.”。如果你能将体积的结果存储起来，稍后在变量或常量中使用，而不仅仅是打印出来，那不是更有用吗？让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-6963
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-6964
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-6965
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-6966
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并想知道哪个可以装更多的东西。首先，编写一个volumeOfBox(_:_:_:)函数，返回盒子的体积（Int类型）：
- en: '[PRE1359]'
  id: totrans-6967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1359]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-6968
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数提供返回值，在函数的输入参数之后，使用一个破折号和大于符号（->）来表示箭头 ➊，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要数据类型。在函数体内，通过使用return关键字，后面跟上你想要返回的值，来返回该值
    ➋。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果在返回语句之后编写任何代码，它将被忽略，因为return语句会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-6969
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-6970
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数，查看两个不同盒子的实际效果：
- en: '![](Image00165.jpg)'
  id: totrans-6971
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-6972
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，volumeOfBox(_:_:_:)函数计算了一个边长为6、5和3的盒子的体积，返回值90被存储在名为volumeOfBox1的常量中。在➋，边长为8、4和2的volumeOfBox2被赋值为64。现在，让我们打印出哪个盒子更大：
- en: '[PRE1360]'
  id: totrans-6973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1360]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-6974
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台中看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-6975
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-6976
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接受一个测试分数数组，并返回平均分数。要获得平均值，你需要将分数相加，然后除以分数的总数。在你的 playground
    中输入以下代码：
- en: '[PRE1361]'
  id: totrans-6977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1361]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-6978
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始化为 0。 ➋ 处的 `for-in` 循环会遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成后，`sum` 变量保存了所有分数的总和。在计算出总和后，剩下的就是将其除以分数的总数，即
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-6979
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空呢？你不能用零去做除法——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试用零进行除法会导致除以零的错误，并使程序崩溃。因此，在进行除法时，务必确保你要除的数不是零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 所做的事情。在 ➍ 处，我们通过将分数的总和除以数组中分数的数量来返回平均值，使用 `return sum
    / scores.count`。没错！你可以返回任何能计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 `sum
    / scores.count`，因为它的结果是一个 `Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-6980
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们还需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在 `if` 语句中添加 `else`
    来处理这个问题，它返回 0 ➎。你可以通过在一个分数数组和一个空数组上调用函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-6981
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-6982
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 `averageOf()` 函数时，如我们在 ➊ 处所做的，函数会返回分数的平均值并在结果面板中显示。如果你传入一个空数组，如我们在
    ➋ 处所做的，返回值将是 0。
- en: '**NOTE**'
  id: totrans-6983
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-6984
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 `else` 语句其实并不是必需的。这是因为如果 `scores.count > 0`，那么函数已经通过
    `return sum / scores.count` 结束了。所以如果计算机已经跳过了那个 `if` 语句，那么我们知道 `scores.count >
    0` 一定不成立，我们完全可以直接写一个 `return 0`，而不需要把它放在 `else` 语句里。然而，如果我们保留 `else` 语句，代码会更清晰、更容易理解。有时候，为了让代码对别人更直观清晰，写一点额外的代码比使用巧妙的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-6985
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-6986
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做各种令人惊奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-6987
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08)，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你能够创建除 Swift 中已经包含的类型之外的常量和变量，这在你开发应用时会非常有用！
- en: '![Image](Image00158.jpg)'
  id: totrans-6988
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00158.jpg)'
- en: '[PRE1362]'
  id: totrans-6989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1362]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-6990
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当你声明函数的参数时，你会注意到 `[String]` 被放在方括号中 ➊ 。方括号声明数据类型为数组，而 `String` 表示数组中值的数据类型。通过使用
    `[String]`，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-6991
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `invite(allGuests:)` 函数内部，我们希望使用 `for-in` 循环遍历我们的 guest 数组，并为每个 guest 打印邀请函。记得我们之前创建了一个打印邀请函的函数吗？我们就在这里用它！将以下代码添加到你的
    `invite(allGuests:)` 函数中（灰色文本显示的是已有的代码行）：
- en: '[PRE1363]'
  id: totrans-6992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1363]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-6993
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `for-in` 循环中，我们会对 `String` 数组 `allGuests` 中的每个 guest 调用单一的 `invite(guest:)`
    函数，邀请每个人参加生日派对。你可能会想知道 `invite(guest:)` 和 `invite(allGuests:)` 是不是同一个函数。毕竟，它们的名字都叫
    `invite`。然而，尽管名称相同，它们是两个不同的函数，因为它们接受不同的输入参数。这是你在 Swift 中经常会遇到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-6994
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `invite(allGuests:)` 函数，首先我们创建一个名为 `friends` 的数组，然后在函数调用中使用它。
- en: '[PRE1364]'
  id: totrans-6995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1364]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-6996
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后我们用这个新的数组作为函数的输入来调用该函数 ➋ 。这是你在调试控制台中看到的输出（`-- snip --`
    显示我们为节省空间省略的部分行）：
- en: '[PRE1365]'
  id: totrans-6997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1365]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-6998
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不得不为每个朋友写出邀请函，那会非常繁琐。但借助函数的强大功能，你只需要很少的代码就完成了。试着创建你自己的朋友数组，随便长一点也没关系！然后用这个新的数组作为输入，调用
    `invite(allGuests:)` 函数。简直是小菜一碟！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-6999
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-7000
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期快到了，而一些客人还没有 RSVP。你想得到一个最终的客人名单，并告诉大家带上泳衣，因为这是一个滑水派对。你可以写一个函数，根据客人的
    RSVP 状态发送个性化的消息给每个客人。
- en: '![Image](Image00159.jpg)'
  id: totrans-7001
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-7002
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个 `String` 类型的参数表示 guest 的名字，以及一个 `Bool` 类型的参数表示 RSVP 状态，它的值可以是
    `true` 或 `false`。在你的 playground 中输入以下代码：
- en: '[PRE1366]'
  id: totrans-7003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1366]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-7004
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊ 。每个参数需要有一个参数名称，后面跟着冒号和该参数的数据类型。你可以创建一个接受任意数量输入参数的函数，而且它们不一定需要是相同类型。在
    `sendMessage(guest:rsvped:)` 函数中，我们传入了一个 `String` 类型的 guest 和一个 `Bool` 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-7005
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 值是否为 true ➋，然后使用 if-else 语句打印相应的消息。请注意，函数定义中的最终 print 语句会在
    rsvped 值为 true 或 false 时都运行，因为它们位于 if-else 语句的括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-7006
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的宾客已经回复了，他们会收到以下消息：
- en: '[PRE1367]'
  id: totrans-7007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1367]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-7008
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提示，要求他们回复：
- en: '[PRE1368]'
  id: totrans-7009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1368]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-7010
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用函数看看它是如何工作的。尝试将一位宾客的 rsvped 值设置为 true，将另一位宾客的值设置为 false，这样你就可以看到两个消息的效果。
- en: '[PRE1369]'
  id: totrans-7011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1369]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-7012
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用具有多个输入参数的函数类似于调用仅具有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-7013
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能将帮助你通过提供参数标签来填写输入值。你只需要传入你想使用的值即可。在填写完宾客姓名后，按下 TAB 键，Xcode 会将光标自动移动到你需要填写下一个输入值的位置。（请参见[图
    7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-7014
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-7015
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入宾客姓名后按 TAB 键，将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-7016
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他任何内容，比如名字或数字，你将会得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-7017
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-7018
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，输入值前没有参数标签？你只需要写：
- en: '[PRE1370]'
  id: totrans-7019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1370]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-7020
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，你将会得到一个错误：
- en: '[PRE1371]'
  id: totrans-7021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1371]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-7022
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它将与参数名称相同。然而，如果你编写一个函数并且觉得参数标签对于代码的清晰度不是必要的，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，很明显你传入的是一个将被打印的字符串。如果每次调用 print(_:) 时都必须包含像 inputString 这样的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-7023
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号以及参数的数据类型来实现。所有这些操作都在你首次声明函数括号内的参数时完成。Swift
    函数中经常这样做，以使函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6) 说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-7024
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-7025
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-7026
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，而在函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用函数时看起来会像
    sayHello(friend:)，这就不像一个完整的句子了。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-7027
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何编写带有自定义参数标签的函数。我们还会展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-7028
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-7029
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，如何通过添加自定义的参数标签来提高代码的可读性。假设你举办了一个生日派对，之后你想给所有的客人写感谢信。在你的 playground
    中写下以下函数：
- en: '[PRE1372]'
  id: totrans-7030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1372]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-7031
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了一个自定义的参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名称
    guest ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-7032
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于标记函数调用时的参数，如下所示：
- en: '[PRE1373]'
  id: totrans-7033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1373]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-7034
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 在第一个输入值之前，for: 在第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用中使用它。如果你尝试使用参数名称代替，就会出现错误：'
- en: '[PRE1374]'
  id: totrans-7035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1374]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-7036
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填充参数标签，因此你不必担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-7037
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-7038
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-7039
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于给客人发送感谢信，感谢他们的礼物。代码 sendThankYou(to:
    "Meghan", for: "puzzle books") 更像一个完整的句子，而不像 sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-7040
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-7041
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**去除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-7042
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加下划线和空格来移除它们。在下面的例子中，我们编写了一个计算体积的函数，它接受盒子的三个边长作为输入。由于函数名已经明确表示你需要传入三个边长，因此你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1375]'
  id: totrans-7043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1375]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-7044
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处、➋ 处和 ➌ 处，在 side1、side2 和 side3 前面加上下划线，来去除这些参数的标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-7045
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而无需任何标签。
- en: '[PRE1376]'
  id: totrans-7046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1376]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-7047
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。" 如果你可以将结果存储到一个变量或常量中，以便稍后使用，而不仅仅是打印盒子的体积，那该多好呢？让我们来看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-7048
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-7049
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-7050
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个箱子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-7051
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的箱子，并想知道哪个可以装更多的东西。首先，编写一个`volumeOfBox(_:_:_:)`函数，该函数返回一个整数表示箱子的体积：
- en: '[PRE1377]'
  id: totrans-7052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1377]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-7053
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数指定返回值，在函数的输入参数后面使用一个破折号和大于号（->），然后输入返回值的数据类型。请注意，你不需要为返回值指定名称，只需要指定数据类型。在函数体内，你使用`return`关键字后跟你要返回的值来返回该值➋。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值之后结束。如果你在`return`语句之后再写任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-7054
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-7055
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的箱子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-7056
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-7057
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`volumeOfBox(_:_:_:)`函数计算了边长为6、5和3的箱子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋处，边长为8、4和2的`volumeOfBox2`被赋值为64。现在让我们打印一条关于哪个箱子更大的消息：
- en: '[PRE1378]'
  id: totrans-7058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1378]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-7059
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-7060
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-7061
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。我们来写一个函数，它接受一个测试分数的数组并返回平均分数。为了得到平均分数，你需要将所有分数加在一起，然后除以分数的总数。请在你的
    Playground 中输入以下代码：
- en: '[PRE1379]'
  id: totrans-7062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1379]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-7063
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在➊，我们定义了一个名为sum的整数变量，并将其初始值设为0。➋处的for-in循环遍历scores数组中的每个值，并将其加到sum变量中。当循环完成后，sum变量存储了所有分数的总和。计算总和后，剩下的就是将它除以分数的总数，也就是`scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-7064
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空怎么办呢？你不能将一个数除以零——无论是在数学课上，还是在Swift中。在Swift中，尝试除以零会导致“除零错误”，并使程序崩溃。因此，在进行除法运算时，始终确保你要除的数不为零，这就是我们在➌处通过检查`scores.count
    > 0`来做到的。然后在➍处，我们通过将分数的总和除以数组中分数的个数来返回平均值，使用`return sum / scores.count`。没错！你可以返回任何计算后得到正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回`sum
    / scores.count`，因为它的结果是一个Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-7065
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`scores.count`不大于零时，我们还需要返回一个值，否则会出现缺少返回值的错误。我们通过在`if`语句后添加一个`else`来处理这个问题，这样就返回了0
    ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-7066
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-7067
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给`averageOf()`函数时，如我们在➊处所做的，分数的平均值会被返回并显示在结果面板中。如果你传入一个空数组，如我们在➋处所做的，返回值就是0。
- en: '**NOTE**'
  id: totrans-7068
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-7069
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕`return 0`的`else`语句其实并不是特别必要。这是因为如果`scores.count > 0`，函数就已经通过`return
    sum / scores.count`结束了。所以如果计算机已经跳过了那条`if`语句，那么我们知道`scores.count > 0`一定不成立，这时我们可以直接写一个`return
    0`而不需要放在`else`里。然而，如果我们保留`else`语句，代码会更加清晰易懂。有时候，写一些额外的代码来让别人更容易理解，比使用一个复杂的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-7070
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-7071
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱增加了一个重要的工具——创建并调用你自己的函数！函数在编程中被广泛使用，可以实现各种令人惊叹的功能！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-7072
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将允许你创建类型不同于Swift内置类型的常量和变量，这对于开发应用程序时非常有用！
- en: '[PRE1380]'
  id: totrans-7073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1380]'
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-7074
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到`[String]`被括在方括号中 ➊。方括号声明数据类型为数组，而`String`表示数组中值的数据类型。通过使用`[String]`，我们声明了这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-7075
  prefs: []
  type: TYPE_NORMAL
  zh: 在`invite(allGuests:)`函数内部，我们需要使用`for-in`循环遍历我们的宾客数组，并为每位宾客打印邀请函。还记得我们刚才创建了一个打印邀请函的函数吗？让我们在这里使用它！将以下内容添加到你的`invite(allGuests:)`函数中（灰色文本表示现有的代码行）：
- en: '[PRE1381]'
  id: totrans-7076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1381]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-7077
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每位客人调用单个invite(guest:)函数，邀请每个人参加生日派对。你可能会好奇，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟，它们的名字都叫invite。尽管它们共享一个名字，但它们是两个不同的函数，因为它们接受不同的输入参数。这是你在Swift中经常会遇到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-7078
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，之后将在函数调用中使用这个数组。
- en: '[PRE1382]'
  id: totrans-7079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1382]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-7080
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后，我们使用这个新数组作为函数的输入 ➋，调用函数。这是你在调试控制台中看到的输出（-- snip --表示我们为节省空间省略了某些行）：
- en: '[PRE1383]'
  id: totrans-7081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1383]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-7082
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为这些朋友分别写出邀请函，那将是非常繁琐的工作。但借助函数的力量，你只用了极少的代码就完成了这项任务。试着创建你自己的朋友数组；可以随意设置长度！然后用你新创建的数组作为输入，调用invite(allGuests:)函数。真是轻而易举！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-7083
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-7084
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的聚会日期即将到来，但有些客人还没有回复RSVP。你希望得到最终的客人数量，并告诉他们带上泳衣，因为这是一个滑水派对。你可以编写一个函数，根据每个客人的RSVP状态发送个性化消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-7085
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-7086
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个String类型的参数用于客人的名字，另一个Bool类型的参数用于RSVP状态，值可以是true或false。将以下代码输入到你的playground中：
- en: '[PRE1384]'
  id: totrans-7087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1384]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-7088
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数都需要有一个参数名，后面跟着冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，这些参数不必都是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传入一个String类型的guest和一个Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-7089
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为true ➋，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最后几个打印语句无论rsvped值是true还是false都会执行，因为它们在if-else语句的大括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-7090
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经RSVP，他们会收到这样的消息：
- en: '[PRE1385]'
  id: totrans-7091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1385]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-7092
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提醒，请他们回复：
- en: '[PRE1386]'
  id: totrans-7093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1386]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-7094
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一位客人的rsvped值设置为true，另一位客人的rsvped值设置为false，这样你就可以看到两条消息的效果。
- en: '[PRE1387]'
  id: totrans-7095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1387]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-7096
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-7097
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能将帮助你填写输入值，自动为你提供参数标签。你只需传入你想要使用的值。填写完客人名字后，按TAB键，Xcode会将光标放置在需要填写下一个输入值的位置。（参见[图
    7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-7098
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-7099
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入客人名字后按TAB键将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-7100
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你rsvped的数据类型。将占位符文本Bool替换为true或false。如果你尝试传入其他内容，如名字或数字，你将遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-7101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-7102
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用print(_:)时，你并没有在输入值前面加上参数标签？你写的是：
- en: '[PRE1388]'
  id: totrans-7103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1388]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-7104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，你会遇到错误：
- en: '[PRE1389]'
  id: totrans-7105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1389]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-7106
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，且标签与参数名称相同。然而，如果你编写一个函数并且觉得参数标签对于代码的清晰性并不是必要的，那么你可以在函数定义中显式地省略它。例如，在print(_:)函数中，很明显你传入的是一个将被打印的字符串。如果每次调用print(_:)时都必须包括像inputString这样的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-7107
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现这一点。这一切都在你第一次声明函数括号内的参数时完成，通常是在func关键字之后。这样做可以使函数调用看起来更像一个完整的句子。[图
    7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-7108
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-7109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello()函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-7110
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:)函数的输入参数是friend，参数标签是to，函数调用中传入的参数是"Colin"。如果没有单独的参数标签，当你调用这个函数时，它看起来会像sayHello(friend:)，这听起来不像是一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-7111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写具有自定义参数标签的函数。我们还将向您展示如何编写一个函数，其中完全省略参数标签。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-7112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-7113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例，说明添加自定义参数标签如何使你的代码更具可读性。生日派对后，你会想给所有客人寄送感谢卡。请在你的playground中编写以下函数：
- en: '[PRE1390]'
  id: totrans-7114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1390]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-7115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 `guest` 参数添加了一个自定义参数标签 `to`。类似地，在 ➋ 处，我们为 `gift` 参数添加了一个参数标签
    `for`。参数名 `guest` ➌ 和 `gift` ➍ 用来引用函数内部的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-7116
  prefs: []
  type: TYPE_NORMAL
  zh: '`to` 和 `for` 作为参数标签，用于标记函数调用时的参数，像这样：'
- en: '[PRE1391]'
  id: totrans-7117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1391]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-7118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `to:` 在第一个输入值之前被写入函数调用中，而 `for:` 在第二个输入值之前被写入。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名代替会导致错误：
- en: '[PRE1392]'
  id: totrans-7119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1392]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-7120
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填写参数标签，所以你不必担心错误地调用函数（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-7121
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-7122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-7123
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信，*to* 表示向谁发送，*for*
    表示感谢的原因（赠送的礼物）。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 读起来更像一句话，而不是
    `sendThankYou(guest: "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-7124
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-7125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-7126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前加上下划线和空格来移除它们。在下面的例子中，我们编写了一个计算体积的函数，它接受盒子的三个边作为输入。因为函数名已经明确说明你需要传入三个边，所以实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1393]'
  id: totrans-7127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1393]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-7128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处、➋ 处和 ➌ 处分别在 `side1`、`side2` 和 `side3` 前添加下划线，移除了侧面的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-7129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，而无需任何标签。
- en: '[PRE1394]'
  id: totrans-7130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1394]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-7131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。"。如果你能够将结果存储在变量或常量中，以便稍后使用，而不仅仅是打印体积，岂不是更有用吗？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-7132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-7133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，让它返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-7134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-7135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多东西。首先，写一个 `volumeOfBox(_:_:_:)` 函数来返回盒子的体积（Int 类型）：
- en: '[PRE1395]'
  id: totrans-7136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1395]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-7137
  prefs: []
  type: TYPE_NORMAL
  zh: 要为一个函数提供返回值，请在函数的输入参数后面使用一个破折号和一个大于号来形成箭头（->），然后输入返回值的数据类型➊。请注意，返回值不需要命名，只需指定数据类型。在函数体内，使用return关键字并跟随要返回的值➋来返回该值。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会发生错误。函数在返回值之后结束。如果你在return语句之后编写任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-7138
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-7139
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，以查看其效果：
- en: '![](Image00165.jpg)'
  id: totrans-7140
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-7141
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，volumeOfBox(_:_:_:)函数计算一个边长为6、5和3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋，边长为8、4和2的volumeOfBox2被赋值为64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1396]'
  id: totrans-7142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1396]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-7143
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串“Box 1 is the bigger box.”输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-7144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-7145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，它接受一个测试分数的数组并返回平均分。为了计算平均值，你需要将分数相加，然后除以总的分数数目。将以下代码输入到你的Playground中：
- en: '[PRE1397]'
  id: totrans-7146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1397]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-7147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在➊，我们定义了一个名为sum的Int类型变量，并将其初始化为0。在➋的for-in循环中，我们遍历scores数组中的每个值并将其加到sum变量中。当循环完成时，sum变量存储了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，也就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-7148
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空怎么办？你不能将某个数除以零——在数学课上或在Swift中都是不行的。在Swift中，尝试除以零会导致除零错误并使程序崩溃。因此，在进行除法时，始终确保你要除的数不是零，这就是我们在➌检查scores.count
    > 0时所做的。在➍，我们通过将分数的总和除以数组中分数的数量来返回平均值，代码为return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回sum
    / scores.count，因为它的计算结果是Int类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-7149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们也需要返回某个值，否则会出现函数缺少返回值的错误。我们通过在if语句中添加else来处理这个问题，在else中返回0➎。你可以通过在一个分数数组和一个空数组上调用函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-7150
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-7151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试分数数组传递给averageOf()函数时，如在➊所示，分数的平均值会被返回并显示在结果面板中。如果你传递一个空数组，如在➋所示，返回值将是0。
- en: '**NOTE**'
  id: totrans-7152
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-7153
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0周围的else语句其实并不是必需的。这是因为如果scores.count > 0，那么函数已经通过return sum
    / scores.count结束了。所以如果程序已经越过了那个if语句，那么我们知道scores.count > 0一定不成立，我们可以直接用return
    0而不需要把它包裹在else语句中。然而，如果我们保留else语句，代码会更清晰，更容易理解。有时候，写一些额外的代码来让别人更容易理解比使用复杂的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-7154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-7155
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱增加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，能做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-7156
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建具有不同于Swift内置类型的常量和变量，这在你创建应用程序时会非常有用！
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  id: totrans-7157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你声明函数的参数时，你会注意到[String]在方括号中➊。方括号声明数据类型为数组，String表示数组中元素的数据类型。通过使用[String]，我们声明这个函数的输入是一个字符串数组。
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-7158
  prefs: []
  type: TYPE_NORMAL
  zh: 在invite(allGuests:)函数内部，我们将使用for-in循环遍历我们的guest数组，并为每个客人打印一份邀请函。还记得我们刚刚创建的打印邀请函的函数吗？我们在这里可以用到它！将以下内容添加到你的invite(allGuests:)函数中（灰色文本显示的是现有的行）：
- en: '[PRE1398]'
  id: totrans-7159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1398]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-7160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对[String]数组allGuests中的每个guest调用单数形式的invite(guest:)函数，邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是不是同一个函数。毕竟，它们的名字都是invite。然而，尽管它们有相同的名称，但它们是两个不同的函数，因为它们接受不同的输入参数。这是Swift中常见的一个模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-7161
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后在函数调用中使用它。
- en: '[PRE1399]'
  id: totrans-7162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1399]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-7163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个包含六个朋友的数组➊。然后我们将新数组作为函数的输入来调用函数➋。这是你将在调试控制台中看到的输出（-- snip --表示我们省略了部分行以节省空间）：
- en: '[PRE1400]'
  id: totrans-7164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1400]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-7165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每一个朋友写邀请函，那将需要大量工作。但通过函数的强大功能，你可以用非常少的代码行数完成这项工作。试着创建你自己的朋友数组，长度可以随意！然后用你新创建的数组作为输入，调用
    `invite(allGuests:)` 函数。简直轻松愉快！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-7166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-7167
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，派对的日期临近，一些客人还没有回复是否参加。你想要得到最终的到场人数，并且告诉客人们带上泳衣，因为将举办一场滑水派对。你可以写一个函数，根据每个客人的
    RSVP 状态向他们发送定制的信息。
- en: '![Image](Image00159.jpg)'
  id: totrans-7168
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-7169
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个 String 类型的参数用于表示客人的名字，一个 Bool 类型的参数表示 RSVP 状态，值可以是 true 或
    false。在你的 playground 中输入以下代码：
- en: '[PRE1401]'
  id: totrans-7170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1401]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-7171
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数有多个输入参数时，你需要在每个参数之间添加逗号 ➊。每个参数都需要有一个参数名称，后面跟着冒号和该参数的数据类型。你可以创建一个接受任意数量输入参数的函数，而且这些参数不必是相同类型的。在
    `sendMessage(guest:rsvped:)` 函数中，我们传入了一个 String 类型的 `guest` 和一个 Bool 类型的 `rsvped`。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-7172
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 `rsvped` 的值是否为 `true` ➋，然后使用 if-else 语句打印出相应的信息。请注意，函数定义中的最后一条打印语句无论
    `rsvped` 值为 true 还是 false 都会执行，因为它们位于 if-else 语句的括号之外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-7173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复了，他们将收到这条信息：
- en: '[PRE1402]'
  id: totrans-7174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1402]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-7175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有回复，他们将收到一条礼貌的提示信息，要求他们回复：
- en: '[PRE1403]'
  id: totrans-7176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1403]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-7177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数来看看它是如何工作的。尝试将一个客人的 `rsvped` 值设置为 true，另一个客人的值设置为 false，这样你就可以看到两条信息的实际效果。
- en: '[PRE1404]'
  id: totrans-7178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1404]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-7179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-7180
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会帮你填充输入值，提供参数标签。你只需要传入你想使用的值。填写完客人名字后，按 TAB 键，Xcode 会把光标移到你需要的地方，方便你填写下一个输入值。（参见
    [图 7-5](text00017.html#ch07fig5)）。
- en: '![Image](Image00160.jpg)'
  id: totrans-7181
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-7182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人名字后按 TAB 键，光标将跳到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-7183
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，你将得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-7184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-7185
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 `print(_:)` 时，输入值前面没有参数标签？你只需要写：
- en: '[PRE1405]'
  id: totrans-7186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1405]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-7187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加标签，你将得到一个错误：
- en: '[PRE1406]'
  id: totrans-7188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1406]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-7189
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，且它与参数名相同。然而，如果你编写一个函数并且觉得参数标签在代码中没有必要以使代码更清晰，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，传入的输入显然是一个将要打印的字符串。如果每次调用 print(_:) 都必须包含像 inputString 这样的参数标签，那就会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-7190
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个不同于参数名的参数标签。你通过输入参数标签、参数名、冒号，最后是参数的数据类型来做到这一点。你在首次声明函数内的参数时，就完成了这一操作，这通常是在
    func 关键字后面的括号内完成的。这在 Swift 函数中常常被使用，以便函数调用看起来更像一个完整的句子。[图 7-6](text00017.html#ch07fig6)
    展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-7191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-7192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-7193
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，当你调用这个函数时，它看起来会像
    sayHello(friend:)，这听起来就不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-7194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将介绍如何编写带有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-7195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-7196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，展示如何通过添加自定义参数标签来使代码更具可读性。在你生日聚会后，你会想给所有的客人发送感谢信。请在你的 Playground 中编写以下函数：
- en: '[PRE1407]'
  id: totrans-7197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1407]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-7198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们向传递给函数的 guest 参数添加了一个自定义的参数标签 to。同样，在 ➋ 处，我们向 gift 参数添加了一个参数标签 for。参数名
    guest ➌ 和 gift ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-7199
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用来在函数调用时标记参数，就像这样：
- en: '[PRE1408]'
  id: totrans-7200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1408]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-7201
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 被写在第一个输入值之前，而 for: 被写在第二个输入值之前。如果参数有一个自定义的参数标签，你必须在函数调用中使用它。试图使用参数名代替它会导致错误：'
- en: '[PRE1409]'
  id: totrans-7202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1409]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-7203
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填写参数标签，因此你不必担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-7204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-7205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-7206
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像*to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于将感谢信送给客人*to* 感谢他们的礼物 *for*。代码
    sendThankYou(to: "Meghan", for: "puzzle books") 更像一句话，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-7207
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-7208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-7209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，你可以通过在参数名称前添加一个下划线和一个空格来移除它们。在以下示例中，我们编写了一个计算体积的函数，该函数以盒子的三个边长作为输入。因为函数名已经明确表示需要传入三个边长，所以实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1410]'
  id: totrans-7210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1410]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-7211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在侧面1前加上下划线（➊）、侧面2前加上下划线（➋）、侧面3前加上下划线（➌）来移除参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-7212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用该函数时，只需输入参数值而不需要任何标签。
- en: '[PRE1411]'
  id: totrans-7213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1411]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-7214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是72。"。如果你不仅仅是打印盒子的体积，而是将结果存储在变量或常量中以便稍后使用，这不是会更有用吗？让我们来看看如何使用返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-7215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-7216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-7217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-7218
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个能装更多的东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，该函数返回一个整数值表示盒子的体积：
- en: '[PRE1412]'
  id: totrans-7219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1412]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-7220
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数添加返回值，使用一个连字符和大于号形成一个箭头（->），紧跟在函数的输入参数后面➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要指定数据类型。在函数体内，你通过使用
    return 关键字并跟随你想返回的值来返回该值➋。如果你编写一个返回值的函数，你*必须*在函数内返回该值，否则会报错。函数在你返回值后结束。如果你在 return
    语句之后编写任何代码，它会被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-7221
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-7222
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-7223
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-7224
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:) 函数计算一个边长分别为6、5和3的盒子的体积，并将返回值90存储在名为 volumeOfBox1 的常量中。在➋处，边长为8、4、2的
    volumeOfBox2 被赋值为64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1413]'
  id: totrans-7225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1413]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-7226
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到字符串 "Box 1 is the bigger box." 输出到调试控制台。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-7227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-7228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们写一个函数，接受一个测试分数数组并返回平均分数。要计算平均值，你需要将分数相加，然后除以总的分数数量。请在你的
    Playground 中输入以下代码：
- en: '[PRE1414]'
  id: totrans-7229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1414]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-7230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 类型变量，并将其初始化为 0。位于 ➋ 处的 `for-in`
    循环遍历 `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量保存了所有分数的总和。计算完总和后，剩下的就是将它除以分数的总数，这就是简单的
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-7231
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果数组为空怎么办呢？你不能用零去除某个数——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试用零除数会导致除零错误并使程序崩溃。因此，在进行除法运算时，一定要确保你要除的数不是零，这就是我们通过在
    ➌ 处检查 `scores.count > 0` 来确保的。在 ➍ 处，我们通过使用 `return sum / scores.count` 将分数的总和除以数组中分数的数量来返回平均值。没错！你可以返回任何能计算出正确数据类型的表达式，这意味着我们可以跳过将计算出来的平均值赋给新变量的步骤，直接返回
    `sum / scores.count`，因为它会计算出一个 `Int` 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-7232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在 `if` 语句中添加一个
    `else` 来处理这一点，返回 `0` ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-7233
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-7234
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整组测试分数传递给 `averageOf()` 函数时，就像我们在 ➊ 所做的那样，函数会返回分数的平均值并在结果面板中显示。如果你传入一个空数组，就像我们在
    ➋ 所做的那样，返回值将是 0。
- en: '**NOTE**'
  id: totrans-7235
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-7236
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 `else` 语句其实并不必要。这是因为如果 `scores.count > 0`，那么函数会在 `return
    sum / scores.count` 处已经结束。所以，如果计算机已经执行到了那个 `if` 语句之后，我们知道 `scores.count > 0` 肯定不成立，我们完全可以省略
    `else`，直接返回 `0`。不过，如果我们保留 `else` 语句，代码会更加清晰易懂。有时候，写一些额外的代码使他人更容易理解比使用复杂的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-7237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-7238
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包增加了一个重要的工具——创建并调用你自己的函数！函数在编程中被广泛使用，可以做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-7239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第八章](text00018.html#ch08) 中，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建具有不同类型的常量和变量，而不仅限于
    Swift 中已经包含的类型，这在你创建应用程序时会非常有用！
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  id: totrans-7240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 invite(allGuests:) 函数内部，我们需要使用一个 for-in 循环遍历我们的 guests 数组，并为每个客人打印一张邀请函。记得我们刚刚创建的那个打印邀请函的函数吗？我们可以在这里使用它！将以下内容添加到你的
    invite(allGuests:) 函数中（灰色文本表示现有的行）：
- en: '[PRE1415]'
  id: totrans-7241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1415]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-7242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们对字符串数组 allGuests 中的每个客人调用单一的 invite(guest:) 函数，邀请每个人参加生日派对。你可能会想，invite(guest:)
    和 invite(allGuests:) 是不是同一个函数。毕竟，它们的名字都是 invite。然而，尽管名字相同，它们实际上是两个不同的函数，因为它们接受不同的输入参数。这是你在
    Swift 中经常会看到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-7243
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 invite(allGuests:) 函数，首先我们创建一个名为 friends 的数组，然后在函数调用中使用它。
- en: '[PRE1416]'
  id: totrans-7244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1416]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-7245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后，我们将新数组作为函数的输入，调用该函数 ➋ 。这是你在调试控制台中看到的输出（-- snip -- 表示我们为节省空间省略的行）：
- en: '[PRE1417]'
  id: totrans-7246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1417]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-7247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为每个朋友写出邀请函，那将是非常繁琐的工作。但借助函数的强大功能，你已经用非常少的代码行完成了这项任务。试着自己创建一个朋友数组；你可以让它的长度任意！然后将新的数组作为输入，调用
    invite(allGuests:) 函数。简直轻而易举！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-7248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-7249
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期即将临近，而一些客人还没有回复是否参加。你想要确认最终的人数，并让客人们知道要带上泳衣，因为这将是一个滑水道派对。你可以编写一个函数，根据客人的RSVP状态向每个客人发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-7250
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-7251
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个字符串类型的参数表示客人的名字，一个布尔类型的参数表示RSVP状态，值为 true 或 false 。在你的 playground
    中输入以下代码：
- en: '[PRE1418]'
  id: totrans-7252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1418]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-7253
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数需要多个输入参数时，你在每个参数之间加上逗号 ➊ 。每个参数需要有一个参数名，后面跟上冒号和该参数的数据类型。你可以创建一个函数，接受任意数量的输入参数，而且这些参数不需要是相同的类型。在
    sendMessage(guest:rsvped:) 函数中，我们传入的是一个字符串类型的 guest 和一个布尔类型的 rsvped 。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-7254
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 值是否为 true ➋，然后使用 if-else 语句打印相应的消息。还要注意，函数定义中的最后一条 print 语句无论
    rsvped 值是 true 还是 false 都会执行，因为它们位于 if-else 语句的大括号之外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-7255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复了，他们会收到这条信息：
- en: '[PRE1419]'
  id: totrans-7256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1419]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-7257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提示，要求他们进行回复：
- en: '[PRE1420]'
  id: totrans-7258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1420]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-7259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一个客人的 rsvped 值设置为 true，另一个设置为 false，这样你就能看到两条消息的效果。
- en: '[PRE1421]'
  id: totrans-7260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1421]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-7261
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-7262
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会通过为你提供参数标签来帮助你填写输入值。你只需传入你想使用的值。填写完客人姓名后，按 TAB 键，Xcode 会将光标定位到你需要填写下一个输入值的地方。（参见
    [图 7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-7263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-7264
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按 TAB 键，将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-7265
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，系统会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-7266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-7267
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用 print(_:) 时，你没有在输入值前加上参数标签吗？你写的是：
- en: '[PRE1422]'
  id: totrans-7268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1422]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-7269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，你将会遇到错误：
- en: '[PRE1423]'
  id: totrans-7270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1423]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-7271
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，而且它将与参数名相同。然而，如果你编写函数时觉得参数标签对代码的清晰度没有帮助，那么你可以在函数定义中显式地省略它。例如，在
    print(_:) 函数中，显然你传入的输入是一个将被打印的字符串。每次调用 print(_:) 都需要包含像 inputString 这样的参数标签会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-7272
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号，最后是参数的数据类型来实现这一点。你在首次声明函数括号内的参数时就可以这样做，这通常出现在
    Swift 函数中，使得函数调用看起来更像一句话。[图 7-6](text00017.html#ch07fig6) 演示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-7273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-7274
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-7275
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，当你调用函数时，它看起来会像
    sayHello(friend:)，这听起来不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-7276
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们将介绍如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-7277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-7278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示如何通过添加自定义参数标签来提高代码的可读性。在你的生日派对后，你会想给所有的宾客发送感谢信。你可以在 playground 中编写以下函数：
- en: '[PRE1424]'
  id: totrans-7279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1424]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-7280
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了一个自定义参数标签 to。类似地，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名
    guest ➌ 和 gift ➍ 用于指代函数内部的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-7281
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在函数调用时标记参数，如下所示：
- en: '[PRE1425]'
  id: totrans-7282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1425]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-7283
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里你可以看到，to: 在函数调用中写在第一个输入值前面，for: 写在第二个输入值前面。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名代替会导致错误：'
- en: '[PRE1426]'
  id: totrans-7284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1426]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-7285
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填写正确的参数标签，因此你不需要担心错误地调用函数（请参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-7286
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-7287
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-7288
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向宾客 *发送* 感谢信 *为* 礼物。代码
    sendThankYou(to: "Meghan", for: "puzzle books") 读起来更像一句话，而不像 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-7289
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-7290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-7291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前添加下划线和空格来移除它们。在以下示例中，我们编写了一个用于计算体积的函数，该函数以一个盒子的三个边作为输入。因为函数名已经清楚地表明需要传入三个边，所以实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1427]'
  id: totrans-7292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1427]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-7293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处给 side1 前面加上下划线，在 ➋ 处给 side2 前面加上下划线，在 ➌ 处给 side3 前面加上下划线，移除了边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-7294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，不需要任何标签。
- en: '[PRE1428]'
  id: totrans-7295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1428]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-7296
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。"。如果你不仅仅打印盒子的体积，而是能把结果存储到变量或常量中以便稍后使用，那不是很有用吗？让我们看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-7297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-7298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-7299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的盒子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-7300
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个可以装更多东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，返回一个盒子的体积（Int 类型）：
- en: '[PRE1429]'
  id: totrans-7301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1429]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-7302
  prefs: []
  type: TYPE_NORMAL
  zh: 要让一个函数有返回值，在函数的输入参数之后 ➊ 使用一个短横线和大于符号（->）来表示箭头，然后输入返回值的数据类型。注意，你不需要为返回值提供名字，只需要指定数据类型。在函数体内，使用
    return 关键字后跟你想要返回的值来返回该值 ➋。如果你写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值后结束。如果你在返回语句后再写任何代码，它将被忽略，因为
    return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-7303
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-7304
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数来测试两个不同的盒子，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-7305
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-7306
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算了边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条消息，说明哪个盒子更大：
- en: '[PRE1430]'
  id: totrans-7307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1430]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-7308
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-7309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-7310
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接受一个测试分数的数组并返回平均分数。为了计算平均分数，你需要将所有分数加在一起，然后除以总分数的数量。在你的
    Playground 中输入以下代码：
- en: '[PRE1431]'
  id: totrans-7311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1431]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-7312
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始值设置为 0。➋ 处的 for-in 循环遍历
    scores 数组中的每个值，并将其加到 sum 变量中。当循环完成时，变量 sum 保存了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数，后者就是
    scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-7313
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果数组为空呢？你不能除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误，并使程序崩溃。因此，在进行除法运算时，一定要确保你要除的数不是零，这就是我们通过检查
    scores.count > 0 来避免的情况，如 ➌ 所示。在 ➍ 处，我们通过将成绩的总和除以数组中成绩的数量来返回平均值，使用 return sum
    / scores.count。没错！你可以返回任何计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给一个新变量的步骤，直接返回 sum
    / scores.count，因为它的结果是一个 Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-7314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们也需要返回一个值，否则会报错，提示函数缺少返回值。我们通过在 if 语句中添加 else 来处理这个问题，返回
    0 ➎。你可以通过在一个包含成绩的数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-7315
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-7316
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给 averageOf() 函数时，如我们在 ➊ 所做的那样，函数会返回成绩的平均值并显示在结果面板中。如果你传入一个空数组，如我们在
    ➋ 所做的那样，返回值将是 0。
- en: '**NOTE**'
  id: totrans-7317
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-7318
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句其实并不必要。这是因为如果 scores.count > 0 ，那么函数会在 return sum
    / scores.count 处结束。所以如果程序已经通过了那个 if 语句，我们就知道 scores.count > 0 一定不成立，那么我们可以直接写一个
    return 0 而不需要将其放入 else 语句中。然而，如果我们保留 else 语句，代码会更清晰，也更容易理解。有时候，为了让别人更容易理解，写一些额外的代码总比使用一些难懂的简写方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-7319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-7320
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚向你的 Swift 工具包中添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，能做很多令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-7321
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建其他类型的常量和变量，而不仅限于 Swift
    中已包含的类型，这在你开发应用时会非常有用！
- en: '[PRE1432]'
  id: totrans-7322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1432]'
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-7323
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 for-in 循环中，我们对 String 数组 allGuests 中的每个 guest 调用单一的 invite(guest:) 函数，邀请每个人参加生日派对。你可能会想，invite(guest:)
    和 invite(allGuests:) 是不是同一个函数。毕竟，它们的名字都叫 invite。然而，尽管名字相同，它们是两个不同的函数，因为它们接受不同的输入参数。这是你在
    Swift 中经常会看到的模式。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-7324
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 invite(allGuests:) 函数，我们首先创建一个名为 friends 的数组，然后在函数调用中使用这个数组。
- en: '[PRE1433]'
  id: totrans-7325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1433]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-7326
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后，我们将这个新的数组作为函数的输入调用函数 ➋。这是你将在调试控制台看到的输出（-- snip -- 表示我们为了节省空间省略的行）：
- en: '[PRE1434]'
  id: totrans-7327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1434]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-7328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不得不为每个朋友写邀请函，那将会非常繁琐。但借助函数的力量，你用非常少的代码行就完成了这一任务。试着创建你自己的朋友数组，长度随你决定！然后将这个新数组作为输入调用invite(allGuests:)函数。真是轻而易举！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-7329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向宾客发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-7330
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期临近，而一些宾客还没有回复RSVP。你希望得到最终的宾客人数，并告知宾客们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据每个宾客的RSVP状态发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-7331
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-7332
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个用于宾客姓名的String类型参数和一个用于RSVP状态的Bool类型参数，其值为true或false。请在你的playground中输入以下代码：
- en: '[PRE1435]'
  id: totrans-7333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1435]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-7334
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数有多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数都需要有一个参数名，后跟冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，它们不必是相同类型。在sendMessage(guest:rsvped:)函数中，我们传入的是String类型的guest和Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-7335
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped的值是否为true ➋，然后使用if-else语句打印相应的消息。注意，函数定义中的最终打印语句无论rsvped值是true还是false都会运行，因为它们在if-else语句的括号外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-7336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的宾客已RSVP，他们将收到如下消息：
- en: '[PRE1436]'
  id: totrans-7337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1436]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-7338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提醒，要求他们回应：
- en: '[PRE1437]'
  id: totrans-7339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1437]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-7340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数来看看它是如何工作的。尝试将一个宾客的rsvped值设置为true，另一个宾客的设置为false，这样你就能看到两个消息的实际效果。
- en: '[PRE1438]'
  id: totrans-7341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1438]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-7342
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-7343
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会帮助你填写输入值，为你提供参数标签。你只需要传入你想要使用的值。填写完宾客名字后，按TAB键，Xcode会将光标移到你需要填写下一个输入值的位置。（参见[图7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-7344
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-7345
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：在输入宾客名字后按TAB键将光标移动到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-7346
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你rsvped的数据类型。将占位符文本Bool替换为true或false。如果你尝试传入其他内容，比如名字或数字，系统会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-7347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-7348
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用print(_:)时，输入值前面没有参数标签？你只是写：
- en: '[PRE1439]'
  id: totrans-7349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1439]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-7350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，将会出现错误：
- en: '[PRE1440]'
  id: totrans-7351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1440]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-7352
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而一些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且它将与参数名相同。然而，如果你编写的函数中觉得参数标签并不是必需的，且不会影响代码清晰度，你可以在函数定义中显式省略它。例如，在print(_:)函数中，传入的值显然是一个将被打印的字符串。如果每次调用print(_:)时都必须包括像inputString这样的参数标签，那会非常麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-7353
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个不同于参数名的参数标签。你通过在参数名之前输入参数标签、参数名、冒号，然后是参数的数据类型来做到这一点。你在函数声明的括号内，func关键字之后第一次声明参数时就可以这样做。在Swift函数中，通常使用这种方式来使函数调用更像一个完整的句子。[图7-6](text00017.html#ch07fig6)说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-7354
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-7355
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：sayHello()函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-7356
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:)函数的输入参数是friend，参数标签是to，函数调用中传入的参数是"Colin"。如果没有单独的参数标签，调用该函数时将看起来像sayHello(friend:)，这就不像是完整的句子了。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-7357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写带有自定义参数标签的函数。我们还将展示如何编写一个函数，其中完全省略参数标签。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-7358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-7359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，展示如何通过添加自定义参数标签使你的代码更加易读。生日派对之后，你可能想要给所有的客人发送感谢信。你可以在你的游乐场中编写以下函数：
- en: '[PRE1441]'
  id: totrans-7360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1441]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-7361
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传递给函数的guest参数添加了自定义参数标签to。同样，在➋处，我们为gift参数添加了参数标签for。参数名guest ➌和gift
    ➍用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-7362
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for用于在函数调用时标记参数，像这样：
- en: '[PRE1442]'
  id: totrans-7363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1442]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-7364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到，在函数调用中，to:写在第一个输入值之前，for:写在第二个输入值之前。如果一个参数有自定义参数标签，你必须在函数调用中使用它。试图使用参数名代替将会导致错误：
- en: '[PRE1443]'
  id: totrans-7365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1443]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-7366
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会自动为你填写参数标签，因此你不必担心错误地调用函数（请参见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-7367
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-7368
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全函数，添加正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-7369
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信 *to*，感谢 *for*
    送来的礼物。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 比 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")` 更像一句完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-7370
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-7371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-7372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加下划线和一个空格来移除它们。在下面的例子中，我们编写了一个计算体积的函数，它接受一个盒子的三个边长作为输入。由于函数名称已经明确说明需要传入三个边长，因此你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1444]'
  id: totrans-7373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1444]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-7374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 `side1` 前加下划线（➊），在 `side2` 前加下划线（➋），以及在 `side3` 前加下划线（➌）来移除边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-7375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，不需要任何标签。
- en: '[PRE1445]'
  id: totrans-7376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1445]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-7377
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "The volume of this box is 72."。如果你希望不仅仅打印盒子的体积，而是能够将结果存储在变量或常量中以供以后使用，那岂不是很有用？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-7378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-7379
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-7380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-7381
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想要知道哪个可以装更多的东西。首先，编写一个 `volumeOfBox(_:_:_:)` 函数，它返回一个整数值作为盒子的体积：
- en: '[PRE1446]'
  id: totrans-7382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1446]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-7383
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数添加返回值，使用破折号和大于号组成箭头（->），并紧接在函数的输入参数后面 ➊，然后输入返回值的数据类型。请注意，返回值不需要命名，只需指定数据类型。在函数体内，使用
    `return` 关键字后跟要返回的值来返回该值 ➋。如果你编写一个返回值的函数，则*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果你在
    `return` 语句后写了任何代码，它将被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-7384
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-7385
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数，分别对两个不同的盒子进行测试，看看它的效果：
- en: '![](Image00165.jpg)'
  id: totrans-7386
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-7387
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，`volumeOfBox(_:_:_:)` 函数计算了一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 `volumeOfBox1`
    的常量中。在 ➋，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在，让我们打印一条关于哪个盒子更大的信息：
- en: '[PRE1447]'
  id: totrans-7388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1447]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-7389
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-7390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-7391
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，它接受一个测试分数数组并返回平均分数。为了得到平均值，你需要将所有分数加起来，然后除以总的分数数量。在你的
    playground 中输入以下代码：
- en: '[PRE1448]'
  id: totrans-7392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1448]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-7393
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始值设为 0。在 ➋ 处的 for-in 循环会遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成后，`sum` 变量保存了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数，这就是简单的
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-7394
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空怎么办？你不能把一个数除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除以零错误并崩溃你的程序。因此，在进行除法运算时，始终确保除数不是零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来做到的。在 ➍ 处，我们通过将分数的总和除以数组中分数的个数来返回平均值，使用 `return sum
    / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 `sum
    / scores.count`，因为它的结果是 `Int` 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-7395
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 `scores.count` 不大于零时返回某个值，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加一个 else
    来处理这一点，返回 `0` ➎。你可以通过在一个分数数组和一个空数组上调用函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-7396
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-7397
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 `averageOf()` 函数时，如 ➊ 所示，分数的平均值会被返回并显示在结果面板中。如果你传递的是一个空数组，如
    ➋ 所示，返回值将是 0。
- en: '**NOTE**'
  id: totrans-7398
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-7399
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，包围 `return 0` 的 else 语句其实并不必要。这是因为，如果 `scores.count > 0`，函数会在 `return
    sum / scores.count` 处提前结束。所以，如果程序已经通过了那个 if 语句，那么我们知道 `scores.count > 0` 必然不成立，我们可以直接使用
    `return 0`，而不需要把它放在 else 语句中。然而，如果我们保留 else 语句，代码会更加清晰，易于理解。有时候，为了让代码对别人更清晰，写多一点代码总比使用复杂的技巧更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-7400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-7401
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-7402
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建其他类型的常量和变量，而不仅仅是Swift中已有的类型，这在你创建应用时会非常有用！
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  id: totrans-7403
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的for-in循环中，我们对String数组allGuests中的每个guest调用单独的invite(guest:)函数，邀请每个人参加生日派对。你可能会想，invite(guest:)和invite(allGuests:)是同一个函数吗？毕竟，它们的名字都是invite。然而，尽管它们有相同的名字，它们是两个不同的函数，因为它们接受不同的输入参数。这种模式在Swift中非常常见。
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-7404
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用invite(allGuests:)函数，我们首先创建一个名为friends的数组，然后将其用作函数调用中的输入。
- en: '[PRE1449]'
  id: totrans-7405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1449]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-7406
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊ 。然后，我们使用新的数组作为输入，调用函数 ➋ 。这是你在调试控制台中看到的输出（-- snip -- 表示我们为了节省空间而省略的行）：
- en: '[PRE1450]'
  id: totrans-7407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1450]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-7408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为每个朋友写邀请函，那将会非常耗费时间。但是，通过函数的强大功能，你只需要非常少的代码行就能完成这项工作。试着创建你自己的朋友数组；让它尽可能长！然后用你的新数组作为输入，调用invite(allGuests:)函数。真是轻而易举！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-7409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发送信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-7410
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近，但有些客人还没有回复RSVP。你想做一次最终的统计，并提醒客人带上泳衣，因为这是一个滑水派对。你可以编写一个函数，根据每个客人的RSVP状态发送定制的信息。
- en: '![Image](Image00159.jpg)'
  id: totrans-7411
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-7412
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个字符串类型的参数表示客人的名字，另一个布尔类型的参数表示RSVP状态，值为true或false。在你的playground中输入以下代码：
- en: '[PRE1451]'
  id: totrans-7413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1451]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-7414
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加一个逗号 ➊ 。每个参数都需要有一个参数名，后面跟着冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，这些参数的类型不必相同。在sendMessage(guest:rsvped:)函数中，我们传递了一个字符串类型的guest和一个布尔类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-7415
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为真 ➋ ，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最后几行打印语句无论rsvped值为真或假都会执行，因为它们位于if-else语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-7416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复RSVP，他们将收到以下信息：
- en: '[PRE1452]'
  id: totrans-7417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1452]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-7418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有回复，客人会收到一封礼貌的提醒，要求他们回应：
- en: '[PRE1453]'
  id: totrans-7419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1453]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-7420
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。试着将一个客人的rsvped值设置为true，另一个客人的rsvped值设置为false，这样你就能看到两条信息的实际效果。
- en: '[PRE1454]'
  id: totrans-7421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1454]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-7422
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用具有多个输入参数的函数与调用只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-7423
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能将帮助你填写输入值，并为你提供参数标签。你只需要传递你想使用的值即可。填写完客人姓名后，按下 TAB 键，Xcode 会将光标移动到下一个输入位置，方便你填写下一个输入值。（见
    [图 7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-7424
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-7425
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入完客人姓名后按 TAB 键，会将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-7426
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 Bool 替换为 true 或 false 。如果你尝试传递其他内容，如姓名或数字，将会出现错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-7427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-7428
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，在调用 `print(_:)` 时，前面并没有参数标签？你写的是：
- en: '[PRE1455]'
  id: totrans-7429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1455]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-7430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加标签，将会出现错误：
- en: '[PRE1456]'
  id: totrans-7431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1456]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-7432
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中带有参数标签，有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，且标签名称与参数名称相同。然而，如果你编写的函数不需要参数标签来让代码更加清晰，那么你可以在函数定义中显式地省略它。例如，在
    `print(_:)` 函数中，传入的内容显然是一个字符串，将被打印出来。如果每次调用 `print(_:)` 都必须包含像 `inputString` 这样的参数标签，那会让人觉得很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-7433
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过在函数声明时输入参数标签、参数名称、冒号和参数的数据类型来实现。所有这些操作都在 `func`
    关键字后面的函数括号内声明参数时完成。在 Swift 函数中，通常使用这种方式，使得函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)
    说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-7434
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-7435
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-7436
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 friend ，参数标签是 to ，而在函数调用中传递的实参是 "Colin" 。如果没有单独的参数标签，调用该函数时会像
    `sayHello(friend:)` 这样，听起来不像一个完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-7437
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将讨论如何编写具有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-7438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-7439
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，看看如何通过添加自定义参数标签使你的代码更具可读性。生日派对结束后，你可能会想给所有客人发送感谢信。在你的 Playground 中编写以下函数：
- en: '[PRE1457]'
  id: totrans-7440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1457]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-7441
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的来宾参数添加了一个自定义参数标签`to`。同样，在 ➋ 处，我们为礼物参数添加了一个参数标签`for`。参数名称`guest`
    ➌ 和`gift` ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-7442
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签`to`和`for`用于在调用函数时标记参数，像这样：
- en: '[PRE1458]'
  id: totrans-7443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1458]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-7444
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到`to:`写在函数调用的第一个输入值前，`for:`写在第二个输入值前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。如果尝试使用参数名称而不是标签，会导致错误：
- en: '[PRE1459]'
  id: totrans-7445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1459]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-7446
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全会始终为你填充参数标签，因此你不必担心错误地调用函数（见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-7447
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-7448
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7: Xcode自动补全函数并使用正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-7449
  prefs: []
  type: TYPE_NORMAL
  zh: '对于程序员来说，使用像*to*、*from* 或 *with* 这样的介词作为参数标签是很常见的。在这个例子中，函数用于向来宾发送感谢信*to*（收件人）*for*（感谢的事情）。代码`sendThankYou(to:
    "Meghan", for: "puzzle books")`比`sendThankYou(guest: "Meghan", gift: "puzzle books")`更像一句话。'
- en: '![Image](Image00163.jpg)'
  id: totrans-7450
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-7451
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-7452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，你可以通过在参数名前添加一个下划线和空格来移除它们。在以下示例中，我们编写一个计算体积的函数，接受盒子的三条边作为输入。因为函数名称已经清楚地说明需要传入三条边，所以你不需要参数标签来使代码更具可读性。
- en: '[PRE1460]'
  id: totrans-7453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1460]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-7454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处将下划线放在`side1`前，在➋处将下划线放在`side2`前，在➌处将下划线放在`side3`前，来移除边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-7455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，无需标签。
- en: '[PRE1461]'
  id: totrans-7456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1461]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-7457
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"The volume of this box is 72."。如果你能将体积存储到变量或常量中，而不是简单地打印出来，以便后续使用，这不是更有用吗？让我们看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-7458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-7459
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-7460
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-7461
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个可以装更多的东西。首先，编写一个`volumeOfBox(_:_:_:)`函数，返回盒子的体积（Int类型）：
- en: '[PRE1462]'
  id: totrans-7462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1462]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-7463
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数添加返回值，在函数的输入参数后面使用短横线和大于号组成箭头`->` ➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你通过使用`return`关键字并跟随要返回的值来返回值
    ➋ 。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值后结束。如果你在`return`语句之后再写任何代码，它会被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-7464
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-7465
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的箱子上调用该函数，看看它的实际效果：
- en: '![](Image00165.jpg)'
  id: totrans-7466
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-7467
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`volumeOfBox(_:_:_:)`函数计算了一个边长分别为6、5和3的盒子的体积，返回值90存储在一个名为`volumeOfBox1`的常量中。在➋处，边长为8、4和2的`volumeOfBox2`被赋值为64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1463]'
  id: totrans-7468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1463]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-7469
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-7470
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-7471
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，它接受一个测试分数的数组，并返回平均分。为了得到平均分，你需要将分数相加，然后除以分数的总数。在你的游乐场中输入以下代码：
- en: '[PRE1464]'
  id: totrans-7472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1464]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-7473
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有数值的总和。在➊处，我们定义了一个名为`sum`的`Int`类型变量，并将其初始值设为0。在➋处的`for-in`循环遍历`score`数组中的每个值，并将其加到`sum`变量中。循环完成后，`sum`变量保存了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数，即`score.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-7474
  prefs: []
  type: TYPE_NORMAL
  zh: 可是如果数组为空怎么办？你不能将任何东西除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除以零的错误并崩溃程序。因此，在进行除法时，一定要确保除数不为零，这也是我们在➌处通过检查`score.count
    > 0`来确保的。在➍处，我们通过将分数的总和除以数组中的分数数量来返回平均值，使用`return sum / scores.count`。没错！你可以返回任何计算出正确数据类型的表达式，这意味着我们可以跳过将计算得出的平均值赋值给新变量的步骤，直接返回`sum
    / scores.count`，因为它会计算出一个`Int`类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-7475
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`score.count`不大于零时，我们还需要返回一些东西，否则会报错提示函数缺少返回值。我们通过在`if`语句中添加一个`else`来处理这个问题，它会返回`0`
    ➎ 。你可以通过调用这个函数，传入一个分数数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-7476
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-7477
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 averageOf() 函数时，就像我们在➊处做的那样，返回并显示的是分数的平均值。如果你传递一个空数组，就像我们在➋处做的那样，返回值将是
    0。
- en: '**NOTE**'
  id: totrans-7478
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-7479
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不必要。这是因为如果 scores.count > 0，那么函数已经通过 return
    sum / scores.count 结束了。所以，如果计算机已经通过了那个 if 语句，我们知道 scores.count > 0 必定不为真，完全可以只写
    return 0，而不需要包裹在 else 语句中。不过，如果我们保留 else 语句，代码会更清晰，易于理解。有时候，为了让代码更清楚易懂，写一些额外的代码比用技巧性的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-7480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-7481
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-7482
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你创建其他类型的常量和变量，而不仅仅是
    Swift 中已有的类型，这在你创建应用时将非常有用！
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  id: totrans-7483
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 invite(allGuests:) 函数，我们首先创建一个名为 friends 的数组，然后在函数调用中使用它。
- en: '[PRE1465]'
  id: totrans-7484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1465]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-7485
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组➊。然后，我们使用这个新数组作为函数的输入来调用函数➋。你将在调试控制台看到这个输出（-- snip --表示我们省略了一些行以节省空间）：
- en: '[PRE1466]'
  id: totrans-7486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1466]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-7487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友写出邀请函，那将会非常费劲。但有了函数的强大功能，你只需几行代码就能完成它。试着创建你自己的朋友数组，长度随你想！然后用这个新数组作为输入来调用
    invite(allGuests:) 函数。简直轻松极了！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-7488
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-7489
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期临近，而一些客人还没有回复是否参加。你想要确认最终的参与人数，并通知客人带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据每个客人的
    RSVP 状态，向他们发送定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-7490
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-7491
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将有两个输入参数：一个 String 类型的参数表示客人的名字，另一个 Bool 类型的参数表示 RSVP 状态，值为 true 或 false。请输入以下代码到你的
    playground 中：
- en: '[PRE1467]'
  id: totrans-7492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1467]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-7493
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数都需要有一个参数名称，后面跟着冒号和该参数的数据类型。你可以创建一个接受任意数量输入参数的函数，而且这些参数不一定是相同类型的。在
    `sendMessage(guest:rsvped:)` 函数中，我们传入的是一个 `String` 类型的 `guest` 和一个 `Bool` 类型的
    `rsvped`。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-7494
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 `rsvped` 的值是否为 `true` ➋，然后使用 if-else 语句打印相应的消息。还要注意，函数定义中的最终 `print`
    语句会在 `rsvped` 的值为 `true` 或 `false` 时都执行，因为它们在 if-else 语句的花括号外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-7495
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已确认出席，他们将收到这条消息：
- en: '[PRE1468]'
  id: totrans-7496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1468]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-7497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提醒，要求他们回复：
- en: '[PRE1469]'
  id: totrans-7498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1469]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-7499
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一位客人的 `rsvped` 值设置为 `true`，另一位客人的 `rsvped` 值设置为 `false`，这样你就可以看到两个消息的实际效果。
- en: '[PRE1470]'
  id: totrans-7500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1470]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-7501
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个包含多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-7502
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能将帮助你通过提供参数标签来填写输入值。你需要做的只是传入你想要使用的值。在填写完客人姓名后，按下 TAB 键，Xcode 会将光标移到下一个输入值的位置。（见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-7503
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-7504
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按 TAB 键将把光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-7505
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 `Bool` 替换为 `true` 或 `false`。如果你尝试传入其他类型的值，比如名字或数字，会出现错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-7506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-7507
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 `print(_:)` 时，你并没有在输入值前加上参数标签？你只需写：
- en: '[PRE1471]'
  id: totrans-7508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1471]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-7509
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加标签，将会收到一个错误：
- en: '[PRE1472]'
  id: totrans-7510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1472]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-7511
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数调用中的参数需要参数标签，而有些则不需要。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且它会与参数名称相同。然而，如果你编写一个函数时，觉得参数标签对代码的清晰度没有帮助，那么你可以在函数定义中显式省略它。例如，在
    `print(_:)` 函数中，传入的输入显然是一个字符串，它将被打印出来。每次调用 `print(_:)` 时都需要包含像 `inputString` 这样的参数标签会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-7512
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为每个参数创建一个不同于参数名称的参数标签。你通过输入参数标签、参数名称、冒号，最后是参数的数据类型来完成这一操作。所有这些都是在函数的 func
    关键字后面的圆括号内首次声明参数时完成的。这种做法在 Swift 函数中很常见，它使函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)
    展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-7513
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-7514
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-7515
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，而函数调用时传递的参数是 "Colin"。如果没有单独的参数标签，调用函数时将像
    sayHello(friend:) 这样，这样的表达更不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-7516
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何编写带有自定义参数标签的函数。我们还会展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-7517
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-7518
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，看看如何添加自定义参数标签能够让你的代码更易读。生日派对后，你可能会想给所有客人发送感谢信。在你的 playground 中写出以下函数：
- en: '[PRE1473]'
  id: totrans-7519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1473]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-7520
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了一个自定义参数标签，to。类似地，在 ➋ 处，我们为 gift 参数添加了一个参数标签，for。参数名称
    guest ➌ 和 gift ➍ 用于函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-7521
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，像这样：
- en: '[PRE1474]'
  id: totrans-7522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1474]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-7523
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 被写在函数调用的第一个输入值之前，而 for: 被写在第二个输入值之前。如果一个参数有自定义参数标签，你在函数调用时必须使用该标签。否则，尝试使用参数名称会导致错误：'
- en: '[PRE1475]'
  id: totrans-7524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1475]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-7525
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填写参数标签，因此你无需担心函数调用时参数标签使用不当（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-7526
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-7527
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全函数并填入正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-7528
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用介词，如 *to*、*from* 或 *with*，作为参数标签。在这个例子中，函数用来向客人发送感谢信 *to* 表达感谢 *for*
    礼物。代码 sendThankYou(to: "Meghan", for: "puzzle books") 比 sendThankYou(guest: "Meghan",
    gift: "puzzle books") 更像一句完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-7529
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-7530
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-7531
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加下划线和空格来去除它们。在以下示例中，我们编写了一个用于计算体积的函数，该函数接受一个箱子的三个边作为输入。因为函数名称已经清楚地表明你需要传入三个边，所以实际上你并不需要参数标签来使代码更具可读性。
- en: '[PRE1476]'
  id: totrans-7532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1476]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-7533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 位置的 side1、➋ 位置的 side2 和 ➌ 位置的 side3 前面加上下划线来去除边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-7534
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE1477]'
  id: totrans-7535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1477]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-7536
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个箱子的体积是 72。”如果你不仅仅是打印箱子的体积，而是将结果存储在变量或常量中，以便以后使用，那不是很有用吗？让我们通过返回值来看看如何做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-7537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-7538
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-7539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个箱子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-7540
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的箱子，并且想知道哪个箱子能装更多东西。首先，编写一个名为 volumeOfBox(_:_:_:) 的函数，它返回一个表示箱子体积的
    Int：
- en: '[PRE1478]'
  id: totrans-7541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1478]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-7542
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数添加返回值，在函数的输入参数之后使用一个短横线和大于号形成一个箭头（->），然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你通过使用
    return 关键字后跟你想要返回的值来返回该值。如果你编写的函数有返回值，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值之后结束。如果在 return
    语句后面写任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-7543
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-7544
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的箱子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-7545
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-7546
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 位置，volumeOfBox(_:_:_:) 函数计算了一个边长分别为 6、5 和 3 的箱子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在 ➋ 位置，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条消息，告诉我们哪个箱子更大：
- en: '[PRE1479]'
  id: totrans-7547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1479]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-7548
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串“箱子 1 是更大的箱子。”
- en: '**CONDITIONAL RETURNS**'
  id: totrans-7549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-7550
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，它接受一个测试分数数组并返回平均分。为了得到平均分，你需要将所有分数相加，然后除以分数的总数。请在你的
    playground 中输入以下代码：
- en: '[PRE1480]'
  id: totrans-7551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1480]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-7552
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 变量，并将其初始化为 0。位于 ➋ 处的 for-in 循环会遍历
    scores 数组中的每个值，并将它加到 sum 变量中。当循环完成时，sum 变量保存了所有分数的总和。在我们计算出总和后，剩下的就是将它除以总分数数量，这个数量就是
    scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-7553
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并崩溃你的程序。因此，在进行除法时，始终确保你要除的数不是零，这就是我们在
    ➌ 处通过检查 scores.count > 0 所做的事情。在 ➍ 处，我们通过将分数总和除以数组中分数的数量来返回平均值，使用 return sum /
    scores.count。没错！你可以返回任何求值为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 sum / scores.count，因为它的求值结果是一个
    Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-7554
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们还需要返回某些值，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加 else 来处理这个问题，它返回
    0 ➎。你可以通过将函数应用于一个包含分数的数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-7555
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-7556
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试分数数组传递给 averageOf() 函数时，正如我们在 ➊ 处所做的，分数的平均值会被返回并显示在结果面板中。如果你传入一个空数组，就像我们在
    ➋ 处所做的那样，返回值是 0。
- en: '**NOTE**'
  id: totrans-7557
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-7558
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句实际上并不是必需的。因为如果 scores.count > 0 ，那么函数已经通过 return
    sum / scores.count 结束了。所以如果程序已经执行到那个 if 语句之后，我们就知道 scores.count > 0 一定不成立，我们可以直接返回
    0，而不需要将它放在 else 语句中。然而，如果我们保留 else 语句，代码会更加清晰易懂。有时候，为了让别人更容易理解，写一些额外的代码比使用复杂的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-7559
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-7560
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以完成各种令人惊叹的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-7561
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建其他类型的常量和变量，而不仅限于
    Swift 中已经包含的类型，这在你开发应用时会非常有用！
- en: '[PRE1481]'
  id: totrans-7562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1481]'
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-7563
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后，我们用这个新数组作为函数的输入调用函数 ➋。这是你在调试控制台中看到的输出（-- snip --显示了为了节省空间而省略的行）：
- en: '[PRE1482]'
  id: totrans-7564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1482]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-7565
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友单独写邀请函，那将需要很多工作。但是借助函数的强大功能，你已经用很少的代码行完成了这一任务。试着创建你自己的朋友数组；尽情发挥，做得越长越好！然后调用invite(allGuests:)函数，将你的新数组作为输入传递进去。真是轻松简单！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-7566
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-7567
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期临近，一些客人还没有回复RSVP。你想要最终确认人数，并通知客人们带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据每个客人的RSVP状态，向他们发送定制消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-7568
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-7569
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个String类型的参数表示客人的姓名，一个Bool类型的参数表示RSVP状态，值为true或false。请在你的playground中输入以下代码：
- en: '[PRE1483]'
  id: totrans-7570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1483]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-7571
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数需要有一个参数名称，后面跟着冒号和数据类型。你可以创建一个接受任意数量输入参数的函数，这些参数不必是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传入一个字符串作为guest和一个布尔值作为rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-7572
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值，看看它是否为true ➋，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最终打印语句无论rsvped值是true还是false都会运行，因为它们位于if-else语句的大括号外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-7573
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复RSVP，他们将收到以下消息：
- en: '[PRE1484]'
  id: totrans-7574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1484]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-7575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提醒，请求他们回复：
- en: '[PRE1485]'
  id: totrans-7576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1485]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-7577
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一个客人的rsvped值设置为true，另一个客人的rsvped值设置为false，这样你就能看到两个消息的实际效果。
- en: '[PRE1486]'
  id: totrans-7578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1486]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-7579
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调用一个接受多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-7580
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能会帮助你填写输入值，提供参数标签。你只需要传入你想要使用的值。填写完客人姓名后，按TAB键，Xcode会自动将光标移到下一个输入字段，方便你继续填写下一个输入值。（见[图7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-7581
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-7582
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：在输入完客人姓名后，按TAB键会将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-7583
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你rsvped的类型。将占位符文本Bool替换为true或false。如果你尝试传入其他内容，比如名字或数字，你会收到错误提示。
- en: '**ARGUMENT LABELS**'
  id: totrans-7584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-7585
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用`print(_:)`时，你并没有在输入值前加上参数标签？你写的是：
- en: '[PRE1487]'
  id: totrans-7586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1487]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-7587
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你会遇到错误：
- en: '[PRE1488]'
  id: totrans-7588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1488]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-7589
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，且该标签与参数名称相同。然而，如果你编写一个函数，并且觉得没有必要使用参数标签来让代码更清晰，那么你可以在函数定义中明确省略它。例如，在`print(_:)`函数中，很明显你传入的是一个字符串，这个字符串会被打印出来。每次调用`print(_:)`时都要加上像`inputString`这样的参数标签会让人觉得很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-7590
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个不同于参数名称的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来做到这一点。这些都在你用`func`关键字声明函数参数时完成。这在Swift函数中很常见，目的是让函数调用看起来更像一个句子。[图
    7-6](text00017.html#ch07fig6)展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-7591
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-7592
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：`sayHello()`函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-7593
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)`函数的输入参数是`friend`，参数标签是`to`，函数调用中传递的参数是"Colin"。如果没有单独的参数标签，调用函数时就会变成`sayHello(friend:)`，这听起来不太像一个完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-7594
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将学习如何编写带有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-7595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-7596
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，看看添加自定义参数标签如何让你的代码更具可读性。你生日派对后，你会想给所有的客人写感谢信。在你的Playground中编写以下函数：
- en: '[PRE1489]'
  id: totrans-7597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1489]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-7598
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传递给函数的`guest`参数添加了一个自定义参数标签`to`。类似地，在➋处，我们为`gift`参数添加了一个参数标签`for`。参数名称`guest`
    ➌ 和`gift` ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-7599
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签`to`和`for`用于在函数调用时标记参数，像这样：
- en: '[PRE1490]'
  id: totrans-7600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1490]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-7601
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到，`to:`被写在第一个输入值之前，`for:`被写在第二个输入值之前。如果某个参数有自定义的参数标签，那么你在函数调用时必须使用它。试图使用参数名称而不是标签会导致错误：
- en: '[PRE1491]'
  id: totrans-7602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1491]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-7603
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能会始终为你填充参数标签，所以你无需担心错误地调用函数（见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-7604
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-7605
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-7606
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用来发送感谢信 *给* 客人 *感谢* 礼物。代码
    sendThankYou(to: "Meghan", for: "puzzle books") 读起来更像一句话，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-7607
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-7608
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-7609
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，你可以通过在参数名称前加上下划线和空格来移除它们。在下面的例子中，我们写了一个计算体积的函数，该函数接受盒子的三个边作为输入。因为函数名已经清楚地说明了你需要传入三个边，所以你其实不需要参数标签来提高代码的可读性。
- en: '[PRE1492]'
  id: totrans-7610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1492]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-7611
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处的 side1、➋ 处的 side2 和 ➌ 处的 side3 前面加上下划线，来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-7612
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你调用这个函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE1493]'
  id: totrans-7613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1493]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-7614
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72."。如果你能将结果存储在变量或常量中，以便稍后使用，而不仅仅是打印盒子的体积，那岂不是很有用吗？让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-7615
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-7616
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-7617
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-7618
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，写一个 volumeOfBox(_:_:_:) 函数，返回盒子的体积（Int）：
- en: '[PRE1494]'
  id: totrans-7619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1494]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-7620
  prefs: []
  type: TYPE_NORMAL
  zh: 要让一个函数有返回值，在输入参数之后，用一个破折号和大于号形成一个箭头（->），然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你通过使用
    return 关键字后跟你想返回的值来返回这个值 ➋ 。如果你写一个返回值的函数，那么你 *必须* 在函数内部返回该值，否则你会遇到错误。函数在你返回值之后结束。如果你在
    return 语句后写了任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-7621
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-7622
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-7623
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-7624
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1495]'
  id: totrans-7625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1495]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-7626
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-7627
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-7628
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据某个条件返回不同的值。让我们写一个函数，接受一个测试分数的数组并返回平均分。要计算平均分，你需要将所有分数加在一起，然后除以分数的总数量。请在你的playground中输入以下代码：
- en: '[PRE1496]'
  id: totrans-7629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1496]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-7630
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在➊处，我们定义了一个名为sum的Int类型变量，并将其初始值设置为0。➋处的for-in循环遍历scores数组中的每个值，并将其加到sum变量上。当循环完成时，sum变量存储了所有分数的总和。计算出总和后，剩下的就是将其除以总的分数数量，这个数量就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-7631
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办呢？你不能把一个数除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会引发除零错误并导致程序崩溃。因此，在做除法时，一定要确保你要除的数不是零，这就是我们在➌处通过检查scores.count
    > 0来确保的。在➍处，我们通过将分数总和除以数组中分数的数量来返回平均值，使用的是return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回sum
    / scores.count，因为它的结果是一个Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-7632
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们还需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在if语句中添加一个else来处理这个问题，返回0
    ➎。你可以通过将函数应用于一个包含分数的数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-7633
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-7634
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试分数数组传递给averageOf()函数时，就像我们在➊处做的那样，返回的是分数的平均值，并显示在结果面板中。如果你传入一个空数组，就像我们在➋处做的那样，返回值是0。
- en: '**NOTE**'
  id: totrans-7635
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-7636
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句实际上并不必要。这是因为如果scores.count > 0，函数已经通过return sum /
    scores.count结束了。所以，如果程序已经执行到那个if语句后面，我们就知道scores.count > 0一定不成立，那时我们可以直接使用return
    0，而不必放在else语句中。然而，如果我们保留else语句，代码会更加清晰，易于理解。有时候，写一些额外的代码比用巧妙的快捷方式更有助于别人理解代码。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-7637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-7638
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要工具——创建并调用你自己的函数！函数在编程中被广泛使用，用来做各种神奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-7639
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建类型不同于Swift中已有类型的常量和变量，这在你开发应用时将非常有用！
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  id: totrans-7640
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含六个朋友的数组 ➊。然后，我们使用新的数组作为函数的输入来调用该函数 ➋。这是你在调试控制台中看到的输出（-- snip -- 表示我们省略了部分内容以节省空间）：
- en: '[PRE1497]'
  id: totrans-7641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1497]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-7642
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友单独写出邀请函，那将是非常费力的工作。但借助函数的强大功能，你只需要几行代码就能完成这项任务。试着创建你自己的朋友数组；可以根据需要调整长度！然后使用你新的数组作为输入调用invite(allGuests:)函数。简直轻松无比！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-7643
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的宾客发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-7644
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期即将临近，但有些宾客还没有回复RSVP。你想要获得最终的参加人数，并通知宾客带上泳衣，因为这将是一个滑水派对。你可以编写一个函数，根据宾客的RSVP状态向他们发送自定义消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-7645
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-7646
  prefs: []
  type: TYPE_NORMAL
  zh: 你新创建的函数将接受两个输入参数：一个String类型的参数用于宾客的姓名，以及一个Bool类型的参数用于RSVP状态，值为true或false。在你的playground中输入以下代码：
- en: '[PRE1498]'
  id: totrans-7647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1498]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-7648
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数需要有一个参数名称，后面跟着冒号和该参数的数据类型。你可以创建一个接受任意数量输入参数的函数，并且它们不必是相同类型。在sendMessage(guest:rsvped:)函数中，我们传入了一个String类型的guest和一个Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-7649
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值，查看它是否为true ➋，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最后打印语句无论rsvped值是true还是false都会执行，因为它们在if-else语句的花括号外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-7650
  prefs: []
  type: TYPE_NORMAL
  zh: 如果宾客已经RSVP，他们将收到如下消息：
- en: '[PRE1499]'
  id: totrans-7651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1499]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-7652
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提示，要求他们回应：
- en: '[PRE1500]'
  id: totrans-7653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1500]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-7654
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数来看看它是如何工作的。试着将一位宾客的rsvped值设置为true，另一位设置为false，这样你就能看到两个消息的效果。
- en: '[PRE1501]'
  id: totrans-7655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1501]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-7656
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个接受多个输入参数的函数与调用一个只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-7657
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能将帮助你填写输入值，为你提供参数标签。你所要做的就是传入你想要使用的值。在填写完宾客姓名后，按TAB键，Xcode会将光标放置到下一个输入值的位置。（参见[图7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-7658
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-7659
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入完客人姓名后按下 TAB 键将会将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-7660
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他任何东西，比如名字或数字，你会得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-7661
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-7662
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，在调用 print(_:) 时，你并没有在输入值前添加参数标签？你写的是：
- en: '[PRE1502]'
  id: totrans-7663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1502]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-7664
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加一个标签，你将会得到一个错误：
- en: '[PRE1503]'
  id: totrans-7665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1503]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-7666
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，而且这个标签与参数名称相同。然而，如果你写了一个函数，觉得参数标签对于使代码更加清晰并不是必须的，那么你可以在函数定义中显式地省略它。例如，在
    print(_:) 函数中，显然你传入的输入是一个将要打印的字符串。如果每次调用 print(_:) 时都必须包含像 inputString 这样的参数标签，会显得很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-7667
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。在你第一次声明函数括号内的参数时，这一切都要做。这通常在
    Swift 函数中完成，目的是使函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-7668
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-7669
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-7670
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用函数时就会像
    sayHello(friend:)，听起来就不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-7671
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-7672
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-7673
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，了解如何通过添加自定义参数标签来使代码更具可读性。生日派对之后，你会想要给所有的客人发送感谢信。在你的 Playground 中写下以下函数：
- en: '[PRE1504]'
  id: totrans-7674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1504]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-7675
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了自定义的参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了参数标签 for。参数名称 guest
    ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-7676
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，像这样：
- en: '[PRE1505]'
  id: totrans-7677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1505]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-7678
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到，`to:` 被写在第一个输入值前面，`for:` 被写在第二个输入值前面。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名代替会导致错误：
- en: '[PRE1506]'
  id: totrans-7679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1506]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-7680
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填充参数标签，所以你不需要担心错误地调用函数（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-7681
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-7682
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-7683
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于将感谢信 *发送给* 一位客人 *以感谢*
    礼物。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 读起来更像一句完整的句子，而不是 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-7684
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-7685
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-7686
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，你可以通过在参数名前加上一个下划线后面跟一个空格来去掉它们。在以下示例中，我们编写了一个计算体积的函数，该函数以一个盒子的三个边长为输入。因为函数名已经明确表示需要传入三个边长，你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1507]'
  id: totrans-7687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1507]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-7688
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 `side1` 处加上一个下划线 ➊、在 `side2` 处加上一个下划线 ➋ 和在 `side3` 处加上一个下划线 ➌ 来移除边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-7689
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用该函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE1508]'
  id: totrans-7690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1508]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-7691
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。”如果你可以将结果存储到一个变量或常量中以便稍后使用，而不是仅仅打印盒子的体积，这样岂不是更有用吗？让我们通过返回值来看看如何做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-7692
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-7693
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-7694
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-7695
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，编写一个返回盒子体积的 `volumeOfBox(_:_:_:)` 函数，该函数返回一个 Int
    类型的体积：
- en: '[PRE1509]'
  id: totrans-7696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1509]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-7697
  prefs: []
  type: TYPE_NORMAL
  zh: 要让一个函数有返回值，在函数的输入参数后面使用短横线和大于号（->）来形成箭头 ➊，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要数据类型。在函数体内，你通过使用
    `return` 关键字后跟你想要返回的值来返回该值 ➋。如果你编写了一个返回值的函数，那么你 *必须* 在函数内部返回该值，否则会出现错误。函数在返回值之后结束。如果你在返回语句后编写任何代码，它将被忽略，因为
    `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-7698
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-7699
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数对两个不同的盒子进行操作，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-7700
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-7701
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1510]'
  id: totrans-7702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1510]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-7703
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-7704
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-7705
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，该函数接受一个测试分数数组并返回平均分数。为了计算平均值，你需要将所有分数相加，然后除以总的分数数量。请在
    Playground 中输入以下代码：
- en: '[PRE1511]'
  id: totrans-7706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1511]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-7707
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的整数变量，并将其初始值设为 0。 ➋ 处的 for-in 循环会遍历 scores
    数组中的每个值，并将其加到 sum 变量中。当循环完成时，sum 变量保存了所有分数的总和。计算完总和后，剩下的就是将其除以总的分数数量，这就是 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-7708
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能将一个数除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会给你一个除零错误，并使程序崩溃。因此，在进行除法操作时，始终确保你要除的数不是零，这就是我们通过检查
    scores.count > 0 在 ➌ 处做的。当在 ➍ 处，我们通过将分数的总和除以数组中分数的数量来返回平均值，使用 return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回
    sum / scores.count，因为它会计算为一个整数。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-7709
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们还需要返回某些内容，否则会出现缺少返回值的错误。我们通过在 if 语句中添加 else 来处理这个问题，返回
    0 ➎。你可以通过传递一个分数数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-7710
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-7711
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 averageOf() 函数时，如 ➊ 所示，返回的就是分数的平均值，并显示在结果面板中。如果你传递一个空数组，如
    ➋ 所示，则返回值是 0。
- en: '**NOTE**'
  id: totrans-7712
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-7713
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0周围的else语句其实并不必要。因为如果scores.count > 0，那么函数已经通过return sum / scores.count结束了。所以如果计算机已经执行到那个if语句之后，我们知道scores.count
    > 0一定不为真，这时我们可以直接写return 0，而不必将它包裹在else语句中。然而，如果我们保留else语句，代码会更清晰，也更容易理解。有时候，写一点额外的代码来让别人更容易理解比使用巧妙的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-7714
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-7715
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要工具——创建并调用你自己的函数！函数在编程中被广泛使用，可以做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-7716
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建其他类型的常量和变量，而不仅仅是Swift中已有的类型，这在你创建应用程序时将非常有用！
- en: '[PRE1512]'
  id: totrans-7717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1512]'
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-7718
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为这些朋友写出每一封邀请函，那将会非常麻烦。但借助函数的强大功能，你已经用很少的代码行数完成了这一任务。试着创建你自己的朋友数组，长度可以随意！然后用你新的数组作为输入，调用invite(allGuests:)函数。简直是小菜一碟！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-7719
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-7720
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期临近，某些客人还没有回复RSVP。你想确定最终的参加人数，并告诉客人们带上泳衣，因为这将是一个滑水派对。你可以写一个函数，根据他们的RSVP状态给每个客人发送一条定制的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-7721
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-7722
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个String类型的参数用于表示客人的名字，另一个Bool类型的参数用于表示RSVP状态，它的值可以是true或false。在你的playground中输入以下代码：
- en: '[PRE1513]'
  id: totrans-7723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1513]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-7724
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数都需要有一个参数名，后面跟着冒号和参数的数据类型。你可以创建一个接受任意多个输入参数的函数，它们不一定要是相同类型的。在sendMessage(guest:rsvped:)函数中，我们传入一个String类型的guest和一个Bool类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-7725
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查rsvped值是否为true ➋，然后使用if-else语句打印相应的消息。还要注意，函数定义中的最终print语句无论rsvped值是true还是false都会执行，因为它们在if-else语句的大括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-7726
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经RSVP，他们将收到以下消息：
- en: '[PRE1514]'
  id: totrans-7727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1514]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-7728
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一封礼貌的通知，提醒他们尽快回应：
- en: '[PRE1515]'
  id: totrans-7729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1515]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-7730
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一个客人的rsvped值设置为true，另一个客人的设置为false，这样你就能看到两个消息的实际效果。
- en: '[PRE1516]'
  id: totrans-7731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1516]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-7732
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-7733
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会通过提供参数标签来帮助你填写输入值。你所要做的就是传入你想使用的值。填写完嘉宾姓名后，按 TAB 键，Xcode 会将光标移动到你需要填写下一个输入值的位置。（参见
    [图 7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-7734
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-7735
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入完嘉宾姓名后按 TAB 键会将光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-7736
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，你将会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-7737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-7738
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，并没有在输入值前添加参数标签？你只需要写：
- en: '[PRE1517]'
  id: totrans-7739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1517]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-7740
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你将会遇到错误：
- en: '[PRE1518]'
  id: totrans-7741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1518]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-7742
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，而且它将与参数名称相同。然而，如果你编写了一个函数，并且觉得参数标签对于代码的清晰度并非必需，那么你可以在函数定义中明确地省略它。例如，在
    print(_:) 函数中，很明显你传入的输入是一个字符串，并且该字符串将被打印。每次调用 print(_:) 时都需要包括像 inputString 这样的参数标签会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-7743
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。在使用 func 关键字声明函数参数时，你会做这些事情。这种做法在
    Swift 函数中很常见，用来使函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-7744
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-7745
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-7746
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用该函数时将看起来像
    sayHello(friend:)，这听起来不太像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-7747
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究如何编写具有自定义参数标签的函数。我们还会展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-7748
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-7749
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示如何通过添加自定义参数标签来使代码更具可读性。在你生日派对之后，你可能想给所有的嘉宾写感谢信。请在你的 playground 中写下以下函数：
- en: '[PRE1519]'
  id: totrans-7750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1519]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-7751
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们为传递给函数的guest参数添加了自定义参数标签to。同样，在➋，我们为gift参数添加了参数标签for。参数名称guest ➌和gift ➍用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-7752
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for用于在调用函数时标注参数，像这样：
- en: '[PRE1520]'
  id: totrans-7753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1520]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-7754
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到to:在第一个输入值之前写出，而for:则在第二个输入值之前写出。如果参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名称代替会导致错误：
- en: '[PRE1521]'
  id: totrans-7755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1521]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-7756
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会自动为你填写参数标签，因此你不必担心错误地调用函数（参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-7757
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-7758
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-7759
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于向客人*表示感谢*并为其赠送礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")读起来更像是一个句子，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-7760
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-7761
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-7762
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前加上下划线和空格来移除它们。在下面的例子中，我们写了一个用于计算体积的函数，它接受三个盒子的边作为输入。因为函数名称已经清楚地表明需要传入三条边，你其实不需要参数标签来使代码更具可读性。
- en: '[PRE1522]'
  id: totrans-7763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1522]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-7764
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在side1前面加下划线➊、side2前面加下划线➋、side3前面加下划线➌来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-7765
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值而不加任何标签。
- en: '[PRE1523]'
  id: totrans-7766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1523]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-7767
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出“The volume of this box is 72.”。如果你不仅仅是打印出盒子的体积，而是能够将结果存储到一个变量或常量中以供稍后使用，这不是更有用吗？让我们来看一下如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-7768
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-7769
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，将体积返回，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-7770
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-7771
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，编写一个volumeOfBox(_:_:_:)函数，它返回盒子的体积（Int类型）：
- en: '[PRE1524]'
  id: totrans-7772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1524]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-7773
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数设置返回值，需在函数输入参数后面使用箭头（->）并输入返回值的数据类型 ➊ 。注意，你不需要为返回值命名，只需要提供数据类型。在函数体内，你通过使用
    `return` 关键字并跟上你想返回的值来返回该值 ➋ 。如果你写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值后结束。如果你在
    `return` 语句之后写任何代码，它将被忽略，因为 `return` 会使函数退出。
- en: '![Image](Image00164.jpg)'
  id: totrans-7774
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-7775
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数并对两个不同的盒子进行测试，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-7776
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-7777
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在让我们打印一条消息，看看哪个盒子更大：
- en: '[PRE1525]'
  id: totrans-7778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1525]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-7779
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-7780
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-7781
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接受一个测试成绩数组并返回平均分数。为了计算平均分数，你需要将所有分数相加，然后除以总成绩数。将以下代码输入到你的
    Playground 中：
- en: '[PRE1526]'
  id: totrans-7782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1526]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-7783
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始值设为 0。位于 ➋ 处的 `for-in`
    循环遍历 `scores` 数组中的每个值，并将其添加到 `sum` 变量中。当循环完成后，`sum` 变量中存储了所有成绩的总和。计算出总和后，剩下的就是将其除以总成绩数，这个数就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-7784
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空呢？你不能将某个数除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除以零的错误，并崩溃你的程序。因此，在进行除法运算时，始终确保你将要除的数不是零，这正是我们通过在
    ➌ 处检查 `scores.count > 0` 来做的。在 ➍ 处，我们通过将成绩总和除以数组中成绩的数量来返回平均值，使用 `return sum /
    scores.count` 。没错！你可以返回任何求值为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 `sum /
    scores.count`，因为它会求值为一个 `Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-7785
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们还需要返回一些内容，否则会出现函数缺少返回值的错误。我们通过在 `if` 语句中添加 `else`
    来处理这一点，返回值为 0 ➎ 。你可以通过在一个包含成绩的数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-7786
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-7787
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给 `averageOf()` 函数时，如我们在 ➊ 处所做的，返回的将是成绩的平均值，并显示在结果面板中。如果传递的是一个空数组，如我们在
    ➋ 处所做的，返回值将是 0。
- en: '**NOTE**'
  id: totrans-7788
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-7789
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 else 语句实际上并不是必须的。这是因为如果 `scores.count > 0`，那么函数会已经通过
    `return sum / scores.count` 结束。所以如果计算机已经执行过那个 if 语句，那么我们知道 `scores.count > 0`
    一定是不成立的，我们完全可以直接 `return 0`，而不需要包裹在 else 中。然而，如果我们保留 else 语句，代码会更清晰、更易于理解。有时候，写一些额外的代码使其他人更容易理解，比使用复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-7790
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-7791
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种各样的神奇事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-7792
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第8章](text00018.html#ch08)，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建类型不同于 Swift 中已有的常量和变量，这对你开发应用程序时非常有用！
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  id: totrans-7793
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须为每个朋友写邀请函，那将需要很多工作。但是借助函数的力量，你已经用很少的代码完成了这项任务。试着创建你自己的朋友数组；长度可以根据需要调整！然后使用你的新数组作为输入，调用
    `invite(allGuests:)` 函数。真是小菜一碟！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-7794
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**给你的客人发信息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-7795
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的派对日期即将到来，而一些客人还没有回复 RSVP。你想要获得最终的参与人数，并让客人知道带泳衣，因为将举办滑水派对。你可以编写一个函数，根据每个客人的
    RSVP 状态，发送定制的信息。
- en: '![Image](Image00159.jpg)'
  id: totrans-7796
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-7797
  prefs: []
  type: TYPE_NORMAL
  zh: 你新创建的函数将接受两个输入参数：一个 `String` 类型的参数表示客人的名字，一个 `Bool` 类型的参数表示 RSVP 状态，值为 true
    或 false。请在你的 Playground 中输入以下代码：
- en: '[PRE1527]'
  id: totrans-7798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1527]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-7799
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数需要多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数都需要有一个参数名，后面跟着冒号和参数的数据类型。你可以创建一个接受任意多个输入参数的函数，并且这些参数可以是不同类型的。在
    `sendMessage(guest:rsvped:)` 函数中，我们传入了一个 `String` 类型的 `guest` 和一个 `Bool` 类型的 `rsvped`。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-7800
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 `rsvped` 值以查看它是否为真 ➋，然后使用 if-else 语句打印相应的消息。注意，函数定义中的最后一条打印语句无论 `rsvped`
    值是 true 还是 false 都会运行，因为它们在 if-else 语句的花括号外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-7801
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已确认出席，他们会收到这个消息：
- en: '[PRE1528]'
  id: totrans-7802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1528]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-7803
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提示，要求他们回应：
- en: '[PRE1529]'
  id: totrans-7804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1529]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-7805
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一位客人的 rsvped 值设置为 true，另一位客人的值设置为 false，这样你就能看到两个消息的实际效果。
- en: '[PRE1530]'
  id: totrans-7806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1530]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-7807
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-7808
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全会通过提供参数标签来帮助你填写输入值。你只需要传入你想要使用的值。在填写完客人姓名后，按下 TAB 键，Xcode 会将光标定位到你需要填写下一个输入值的位置。（见[图
    7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-7809
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-7810
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按 TAB 键会将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-7811
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，如姓名或数字，你将会得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-7812
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-7813
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，你并没有在输入值前加上参数标签？你写的是：
- en: '[PRE1531]'
  id: totrans-7814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1531]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-7815
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你将会得到一个错误：
- en: '[PRE1532]'
  id: totrans-7816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1532]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-7817
  prefs: []
  type: TYPE_NORMAL
  zh: 某些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且标签与参数名相同。然而，如果你编写一个函数，并且觉得参数标签对于代码的清晰性并不是必需的，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，传入的内容显然是一个将要打印的字符串。如果每次调用 print(_:) 都必须包括像 inputString 这样的参数标签，那将会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-7818
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为每个参数创建与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号，最后是参数的数据类型来做到这一点。所有这些都在你第一次声明函数括号内的参数时完成。这在
    Swift 函数中经常使用，以使函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-7819
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-7820
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-7821
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，那么调用这个函数时会像
    sayHello(friend:)，这样听起来不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-7822
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将学习如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-7823
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-7824
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过添加自定义参数标签使你的代码更具可读性。在你的生日派对后，你会想要向所有客人发送感谢信。请在你的 Playground 中编写以下函数：
- en: '[PRE1533]'
  id: totrans-7825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1533]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-7826
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了一个自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名称
    guest ➌ 和 gift ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-7827
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，如下所示：
- en: '[PRE1534]'
  id: totrans-7828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1534]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-7829
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 写在函数调用的第一个输入值之前，而 for: 写在第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用中使用它。如果尝试使用参数名称代替，会导致错误：'
- en: '[PRE1535]'
  id: totrans-7830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1535]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-7831
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全会始终为你填充参数标签，因此你不需要担心函数调用错误（请参见 [图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-7832
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-7833
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode 自动完成一个函数，并使用正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-7834
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像 *to* 、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信 *to*，以感谢他们的礼物
    *for*。代码 sendThankYou(to: "Meghan", for: "puzzle books") 比起 sendThankYou(guest:
    "Meghan", gift: "puzzle books") 更像一句完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-7835
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-7836
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-7837
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加上下划线和空格来移除它们。在下面的例子中，我们编写了一个计算体积的函数，它接受盒子的三条边作为输入。因为函数名称已经清楚地表明你需要传入三条边，所以你实际上不需要参数标签来让代码更具可读性。
- en: '[PRE1536]'
  id: totrans-7838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1536]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-7839
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处为 side1，➋ 处为 side2，➌ 处为 side3 前加上下划线，移除了这些参数的标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-7840
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，你只需要输入参数值，而不需要任何标签。
- en: '[PRE1537]'
  id: totrans-7841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1537]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-7842
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。"。如果你希望不仅仅是打印盒子的体积，而是将结果存储到一个变量或常量中以供后续使用，岂不是很有用吗？让我们看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-7843
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-7844
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重新编写 volumeOfBoxWithSides(_:_:_:) 函数，以返回体积而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-7845
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的盒子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-7846
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，编写一个名为 volumeOfBox(_:_:_:) 的函数，返回一个整数作为盒子的体积：
- en: '[PRE1538]'
  id: totrans-7847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1538]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-7848
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数返回值，使用一个破折号和一个大于号来组成箭头（->），紧接着输入返回值的数据类型➊，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，你通过使用return关键字并跟上你想返回的值来返回该值➋。
    如果你写一个返回值的函数，那么你*必须*在函数内部返回这个值，否则会报错。函数在你返回值之后结束。如果你在return语句之后在函数内部写任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-7849
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-7850
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-7851
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-7852
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算一个边长分别为6、5和3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋处，边长分别为8、4和2的volumeOfBox2被赋值为64。现在让我们打印一条消息，告诉我们哪个盒子更大：
- en: '[PRE1539]'
  id: totrans-7853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1539]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-7854
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-7855
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-7856
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据某个条件返回不同的值。让我们写一个函数，接受一个测试成绩的数组并返回平均分。为了计算平均值，你需要将成绩相加，然后除以成绩的总数。在你的Playground中输入以下代码：
- en: '[PRE1540]'
  id: totrans-7857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1540]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-7858
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在➊处，我们定义了一个名为sum的Int变量，并将其初始值设置为0。在➋处的for-in循环遍历scores数组中的每个值，并将其加到sum变量中。当循环完成时，变量sum保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，这个总数就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-7859
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组是空的呢？你不能把一个数除以零——在数学课上或者在Swift中都不行。在Swift中，尝试除以零会导致除零错误，并且会崩溃程序。因此，在做除法时，必须确保除数不为零，这就是我们在➌处通过检查scores.count
    > 0来做到的。在➍处，我们通过用return sum / scores.count来返回平均值。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋给一个新变量的步骤，直接返回sum
    / scores.count，因为它会被计算为一个Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-7860
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们还需要返回一个值，否则会出现缺少返回值的错误。我们通过在if语句中添加一个else来处理这个问题，返回0
    ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-7861
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-7862
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试分数数组传递给 averageOf() 函数时，如 ➊ 所示，函数会返回分数的平均值并显示在结果窗格中。如果你传递的是一个空数组，如 ➋
    所示，返回值将是 0。
- en: '**NOTE**'
  id: totrans-7863
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-7864
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句实际上并不必要。这是因为如果 scores.count > 0，那么函数已经会通过 return
    sum / scores.count 结束。如果程序已经跳过了那条 if 语句，那么我们可以知道 scores.count > 0 一定不成立，此时我们可以直接使用
    return 0，而不需要将其包裹在 else 语句中。然而，如果我们保留 else 语句，代码会更清晰，理解起来也更容易。有时候，写一些额外的代码来让其他人更容易理解比使用巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-7865
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-7866
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要工具——创建和调用自己的函数！函数在编程中被广泛使用，能够完成各种各样的惊人任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-7867
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你能够创建与 Swift 中已经包含的类型不同的常量和变量，这在你开发应用时会非常有用！
- en: '**MESSAGING YOUR GUESTS**'
  id: totrans-7868
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向你的客人发送消息**'
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-7869
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的聚会日期快到了，而有些客人还没有回复。你想知道最终的到场人数，并让客人知道要带上泳衣，因为这是一个滑水派对。你可以编写一个函数，根据每个客人的
    RSVP 状态向他们发送定制消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-7870
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-7871
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个字符串类型的 guest 参数表示客人姓名，和一个布尔类型的 rsvped 参数，表示是否回复了到场情况，值为 true
    或 false。请输入以下代码到你的 playground 中：
- en: '[PRE1541]'
  id: totrans-7872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1541]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-7873
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加一个逗号 ➊。每个参数需要有一个参数名称，后面跟上冒号和参数的数据类型。你可以创建一个接受任意数量输入参数的函数，且它们不必是相同的类型。在
    sendMessage(guest:rsvped:) 函数中，我们传递了一个字符串类型的 guest 和一个布尔类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-7874
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 值是否为 true ➋，然后使用 if-else 语句打印相应的消息。请注意，函数定义中的最终打印语句无论 rsvped
    值为 true 还是 false 都会执行，因为它们在 if-else 语句的括号外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-7875
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经回复了他们的到场情况，他们会收到如下信息：
- en: '[PRE1542]'
  id: totrans-7876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1542]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-7877
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提醒信息，要求他们回复：
- en: '[PRE1543]'
  id: totrans-7878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1543]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-7879
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一位客人的 rsvped 值设置为 true，另一位设置为 false，这样你就能看到两条消息的实际效果。
- en: '[PRE1544]'
  id: totrans-7880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1544]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-7881
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-7882
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能将帮助你填写输入值，通过为你提供参数标签。你只需传入你想使用的值。填写完客人姓名后，按 TAB 键，Xcode 会把光标移到你需要填写下一个输入值的位置。（参见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-7883
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-7884
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入完客人姓名后按 TAB 键会将光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-7885
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，你会得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-7886
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-7887
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用 print(_:) 时，并没有在输入值前加上参数标签吗？你写的是：
- en: '[PRE1545]'
  id: totrans-7888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1545]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-7889
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你会得到一个错误：
- en: '[PRE1546]'
  id: totrans-7890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1546]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-7891
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，而且它与参数名称相同。然而，如果你编写的函数中不认为参数标签对于代码的清晰度是必要的，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，很明显你传入的输入是一个将要被打印的字符串。如果每次调用 print(_:) 时都需要加上像 inputString 这样的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-7892
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号和最后的参数数据类型来实现这一点。你在第一次声明函数括号中的参数时就可以做到这一点。这通常在
    Swift 函数中进行，以使函数调用看起来更像一个完整的句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-7893
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-7894
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-7895
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传递的参数是 "Colin"。如果没有单独的参数标签，当你调用这个函数时，它会看起来像
    sayHello(friend:)，听起来不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-7896
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将研究如何编写具有自定义参数标签的函数。我们还将向你展示如何编写一个函数，完全省略参数标签。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-7897
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-7898
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，看看添加自定义参数标签如何让你的代码更易读。在你的生日聚会后，你会想给所有的客人发送感谢信。你可以在 Playground 中编写以下函数：
- en: '[PRE1547]'
  id: totrans-7899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1547]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-7900
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了一个自定义参数标签，to。类似地，在 ➋ 处，我们为 gift 参数添加了一个参数标签，for。参数名称
    guest ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-7901
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用来标记函数调用时的参数，如下所示：
- en: '[PRE1548]'
  id: totrans-7902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1548]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-7903
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里你可以看到，to: 被写在函数调用的第一个输入值前，for: 被写在第二个输入值前。如果一个参数有自定义参数标签，你必须在函数调用中使用它。如果你试图使用参数名称而不是标签，将会报错：'
- en: '[PRE1549]'
  id: totrans-7904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1549]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-7905
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填充参数标签，因此你不必担心错误地调用函数（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-7906
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-7907
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-7908
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数被用来向客人发送感谢信 *to*（给）客人 *for*（感谢）礼物。代码
    sendThankYou(to: "Meghan", for: "puzzle books") 看起来更像一句话，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-7909
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-7910
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-7911
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，你可以通过在参数名称前加上下划线和一个空格来移除它们。在以下示例中，我们编写了一个计算体积的函数，它接受盒子的三个侧面作为输入。因为函数名已经清楚地表明需要传入三个侧面，所以你实际上不需要参数标签来使代码更具可读性。
- en: '[PRE1550]'
  id: totrans-7912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1550]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-7913
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在侧面参数前加下划线来移除参数标签，侧面1 在 ➊ 处，侧面2 在 ➋ 处，侧面3 在 ➌ 处。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-7914
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，你只需输入参数值，而无需任何标签。
- en: '[PRE1551]'
  id: totrans-7915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1551]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-7916
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72"。如果你不仅仅是打印盒子的体积，而是能将结果存储到一个变量或常量中以供以后使用，那不是更有用吗？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-7917
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-7918
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-7919
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-7920
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个能装更多东西。首先，编写一个返回盒子体积的 volumeOfBox(_:_:_:) 函数：
- en: '[PRE1552]'
  id: totrans-7921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1552]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-7922
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数设置返回值，在函数的输入参数➊后面使用一个破折号和大于号来形成一个箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，使用`return`关键字后跟你想要返回的值➋来返回值。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值之后结束。如果在`return`语句后编写任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-7923
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-7924
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个函数并传递两个不同的箱子来查看它的实际效果：
- en: '![](Image00165.jpg)'
  id: totrans-7925
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-7926
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`volumeOfBox(_:_:_:)`函数计算了一个边长为6、5和3的箱子的体积，返回值90存储在一个名为`volumeOfBox1`的常量中。在➋处，边长为8、4和2的`volumeOfBox2`被赋值为64。现在让我们打印出关于哪个箱子更大的信息：
- en: '[PRE1553]'
  id: totrans-7927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1553]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-7928
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-7929
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-7930
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，接受一个测试成绩数组并返回平均成绩。要计算平均值，你需要将成绩相加，然后除以总的成绩数。在你的游乐场中输入以下代码：
- en: '[PRE1554]'
  id: totrans-7931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1554]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-7932
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在➊处，我们定义了一个名为`sum`的`Int`变量，并将其初始值设置为0。➋处的`for-in`循环遍历`scores`数组中的每个值，并将其添加到`sum`变量中。当循环完成时，`sum`变量保存了所有成绩的总和。计算总和后，剩下的就是将其除以成绩的总数，这就是`scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-7933
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空呢？你不能除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除以零错误，并使程序崩溃。因此，在进行除法运算时，始终确保你要除的数不是零，这就是我们在➌处检查`scores.count
    > 0`的原因。在➍处，我们通过将所有成绩的总和除以数组中成绩的数量来返回平均值，使用`return sum / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回`sum
    / scores.count`，因为它会得到一个`Int`值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-7934
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`scores.count`不大于零时，我们也需要返回某个值，否则会报错提示函数缺少返回值。我们通过在`if`语句中添加`else`来处理这一问题，`else`返回0➎。你可以通过将函数应用于一个成绩数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-7935
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-7936
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传入 averageOf() 函数时，如我们在 ➊ 所示，函数将返回分数的平均值，并显示在结果面板中。如果传入的是空数组，如我们在
    ➋ 所示，返回值将是 0。
- en: '**NOTE**'
  id: totrans-7937
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-7938
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句其实并不是必需的。因为如果 scores.count > 0 ，函数已经通过 return sum
    / scores.count 结束了。所以，如果计算机已经跳过了那个 if 语句，我们就知道 scores.count > 0 一定不成立，这时我们可以直接使用
    return 0，而不需要将其包含在 else 语句中。不过，如果我们保留 else 语句，代码会更清晰，更容易理解。有时候，写一些额外的代码以便让别人更容易理解，比使用一些巧妙的快捷方式要更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-7939
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-7940
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛应用，用于做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-7941
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第8章](text00018.html#ch08) 中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建除了 Swift 中已有类型之外的常量和变量，这在你创建应用时将非常有用！
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  id: totrans-7942
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的派对日期临近，而有些客人还没有回应 RSVP。你希望得到一个最终的客人名单，并告知客人们带上泳衣，因为这是一个滑水派对。你可以写一个函数，根据客人的
    RSVP 状态发送个性化的消息。
- en: '![Image](Image00159.jpg)'
  id: totrans-7943
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-7944
  prefs: []
  type: TYPE_NORMAL
  zh: 你新的函数将接受两个输入参数：一个字符串参数，用于表示客人的名字，另一个布尔参数用于表示 RSVP 状态，值为 true 或 false。请在你的 Playground
    中输入以下代码：
- en: '[PRE1555]'
  id: totrans-7945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1555]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-7946
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数需要有一个参数名称，后面跟着冒号和参数的数据类型。你可以创建一个接受任意多个输入参数的函数，而且这些参数不一定是同一类型的。在
    sendMessage(guest:rsvped:) 函数中，我们传入了一个 String 类型的 guest 和一个 Bool 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-7947
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 值是否为 true ➋，然后使用 if-else 语句打印相应的消息。还要注意，函数定义中的最后 print 语句无论
    rsvped 值是 true 还是 false 都会执行，因为它们在 if-else 语句的花括号外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-7948
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经 RSVP，他们将收到以下消息：
- en: '[PRE1556]'
  id: totrans-7949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1556]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-7950
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一封礼貌的通知，要求他们回复：
- en: '[PRE1557]'
  id: totrans-7951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1557]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-7952
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数来看看它是如何工作的。尝试将一个客人的 rsvped 值设置为 true，另一个客人的设置为 false，这样你就能看到两个消息的实际效果。
- en: '[PRE1558]'
  id: totrans-7953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1558]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-7954
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个具有多个输入参数的函数，类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-7955
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全将帮助你填写输入值，并为你提供参数标签。你只需传入你想要使用的值。填写完客人姓名后，按 TAB 键，Xcode 会将光标放到正确的位置，帮助你填写下一个输入值。（见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-7956
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-7957
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入客人姓名后按 TAB 键将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-7958
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 `Bool` 替换为 `true` 或 `false`。如果你尝试传入其他任何值，比如名字或数字，你会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-7959
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-7960
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 `print(_:)` 时，输入值前没有参数标签？你写的是：
- en: '[PRE1559]'
  id: totrans-7961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1559]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-7962
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，你会遇到错误：
- en: '[PRE1560]'
  id: totrans-7963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1560]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-7964
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，而且该标签会与参数名称相同。然而，如果你编写一个函数，觉得参数标签并不必要来使代码更清晰，那么你可以在函数定义中显式地省略它。例如，在
    `print(_:)` 函数中，很明显你传入的输入是一个将被打印的字符串。如果每次调用 `print(_:)` 都必须包括像 `inputString` 这样的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-7965
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来做到这一点。所有这些操作都在你第一次在函数括号内声明参数时进行。这通常在
    Swift 函数中完成，使函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-7966
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-7967
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-7968
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 `friend`，参数标签是 `to`，在函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用该函数时将是
    `sayHello(friend:)`，这听起来不像一个完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-7969
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-7970
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-7971
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过添加自定义参数标签来使你的代码更具可读性。假设你在生日派对后想给所有客人发送感谢信。请在你的 Playground 中编写以下函数：
- en: '[PRE1561]'
  id: totrans-7972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1561]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-7973
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了一个自定义参数标签 to。同样地，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名
    guest ➌ 和 gift ➍ 用于函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-7974
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于标记函数调用时的参数，如下所示：
- en: '[PRE1562]'
  id: totrans-7975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1562]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-7976
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 写在函数调用中的第一个输入值之前，for: 写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。如果试图使用参数名而不是标签，将会出现错误：'
- en: '[PRE1563]'
  id: totrans-7977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1563]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-7978
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会自动为你填充参数标签，因此你不必担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-7979
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-7980
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-7981
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用介词如 *to* 、*from* 或 *with* 作为参数标签。在这个例子中，函数用来给客人发送感谢信 *to* 一个客人 *for*
    一份礼物。代码 sendThankYou(to: "Meghan", for: "puzzle books") 读起来更像一句话，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-7982
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-7983
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-7984
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前加上下划线和一个空格来移除它们。在下面的示例中，我们写了一个计算体积的函数，它需要传入盒子的三个边长作为输入。因为函数名已经明确了你需要传入三个边长，所以你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1564]'
  id: totrans-7985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1564]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-7986
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处为 side1 添加下划线，在 ➋ 处为 side2 添加下划线，以及在 ➌ 处为 side3 添加下划线，来移除参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-7987
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE1565]'
  id: totrans-7988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1565]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-7989
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "The volume of this box is 72."。如果你不仅仅是打印出盒子的体积，而是能将结果存储到一个变量或常量中以后使用，那该多有用啊！让我们来看看如何通过返回值来实现这一点吧！
- en: '**RETURN VALUES**'
  id: totrans-7990
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-7991
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-7992
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-7993
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪一个可以装更多东西。首先，写一个 volumeOfBox(_:_:_:) 函数，返回一个 Int 类型的盒子体积：
- en: '[PRE1566]'
  id: totrans-7994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1566]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-7995
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数一个返回值，在函数的输入参数之后使用短横线和大于号组成箭头（->），然后输入返回值的数据类型 ➊。请注意，你不需要为返回值提供名称，只需要指定数据类型。在函数体内，你可以使用
    `return` 关键字返回你想返回的值 ➋。如果你编写了一个返回值的函数，那么你*必须*在函数内返回该值，否则会出现错误。函数在你返回值后结束。如果你在
    `return` 语句后编写任何代码，它将被忽略，因为 `return` 会使函数退出。
- en: '![Image](Image00164.jpg)'
  id: totrans-7996
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-7997
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，查看它的实际效果：
- en: '![](Image00165.jpg)'
  id: totrans-7998
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-7999
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个边长为 6、5 和 3 的盒子的体积，并将返回值 90 存储在名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1567]'
  id: totrans-8000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1567]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-8001
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-8002
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-8003
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，它接收一个测试得分的数组并返回平均分。为了计算平均分，你需要将所有得分加起来，然后除以得分的总数。在你的
    playground 中输入以下代码：
- en: '[PRE1568]'
  id: totrans-8004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1568]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-8005
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 Int 类型变量，并将其初始化为 0。位于 ➋ 的 `for-in` 循环遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量中。循环完成后，变量 `sum` 将保存所有得分的总和。在计算完总和后，剩下的就是将其除以得分的总数，这个数就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-8006
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空怎么办呢？你不能除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并使程序崩溃。因此，在进行除法操作时，始终确保你要除的数不为零，这就是我们通过在
    ➌ 检查 `scores.count > 0` 来实现的。到 ➍ 时，我们通过将总分除以数组中得分的数量来返回平均值，使用的是 `return sum /
    scores.count`。没错！你可以返回任何计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 `sum / scores.count`，因为它会被计算为一个
    Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-8007
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一些内容，否则会出现函数缺少返回值的错误。我们通过在 `if` 语句中添加一个
    `else` 分支来处理这个问题，该分支返回 0 ➎。你可以通过在一个得分数组和一个空数组上调用该函数来测试这段代码：
- en: '![](Image00166.jpg)'
  id: totrans-8008
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-8009
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传入`averageOf()`函数时，如我们在 ➊ 所做的，函数将返回成绩的平均值并显示在结果窗格中。如果传入的是一个空数组，如我们在
    ➋ 所做的，返回值将是0。
- en: '**NOTE**'
  id: totrans-8010
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-8011
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕`return 0`的else语句实际上并不必要。这是因为如果`scores.count > 0`，函数会在`return sum
    / scores.count`时已经结束。因此，如果程序已经通过了这个if语句，那么我们就知道`scores.count > 0`不成立，我们完全可以直接使用`return
    0`，而不需要把它放在else语句中。然而，如果我们保留else语句，代码会更加清晰，易于理解。有时候，写一些额外的代码以便让别人更容易理解比使用一些巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-8012
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-8013
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种各样的令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-8014
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建除Swift中已包含类型之外的常量和变量，在创建应用时会非常有用！
- en: '![Image](Image00159.jpg)'
  id: totrans-8015
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00159.jpg)'
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-8016
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个用于表示客人姓名的`String`类型参数和一个表示RSVP状态的`Bool`类型参数，值为true或false。请在你的playground中输入以下代码：
- en: '[PRE1569]'
  id: totrans-8017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1569]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-8018
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加上逗号 ➊。每个参数都需要有一个参数名，后面跟着冒号和参数的数据类型。你可以创建一个接受任意多个输入参数的函数，而且它们不必是相同类型。在`sendMessage(guest:rsvped:)`函数中，我们传入的是一个`String`类型的guest和一个`Bool`类型的rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-8019
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查`rsvped`值是否为true ➋，然后使用if-else语句打印相应的消息。注意，函数定义中的最终打印语句无论`rsvped`值是true还是false都会执行，因为它们位于if-else语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-8020
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已RSVP，他们将收到这条消息：
- en: '[PRE1570]'
  id: totrans-8021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1570]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-8022
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的通知，要求他们回复：
- en: '[PRE1571]'
  id: totrans-8023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1571]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-8024
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一个客人的`rsvped`值设置为true，另一个客人的`rsvped`值设置为false，这样你就可以看到两条消息的实际效果。
- en: '[PRE1572]'
  id: totrans-8025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1572]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-8026
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-8027
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能会通过为你提供参数标签来帮助你填写输入值。你只需要传入你想使用的值。在填写完来宾姓名后，按TAB键，Xcode会将光标定位到需要填写下一个输入值的位置。（见[图7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-8028
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-8029
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：在输入来宾姓名后按TAB键，会将光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-8030
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你`rsvped`的数据类型。将占位符文本`Bool`替换为`true`或`false`。如果你尝试传入其他内容，比如名字或数字，系统会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-8031
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-8032
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，在调用`print(_:)`时，你没有在输入值前面加上参数标签？你写的是：
- en: '[PRE1573]'
  id: totrans-8033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1573]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-8034
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，会出现错误：
- en: '[PRE1574]'
  id: totrans-8035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1574]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-8036
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它将与参数名相同。然而，如果你编写一个函数时，觉得参数标签对代码清晰没有帮助，那么你可以在函数定义中明确省略它。例如，在`print(_:)`函数中，传入的输入显然是一个将要打印的字符串。如果每次调用`print(_:)`时都要包括像`inputString`这样的参数标签，那会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-8037
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号，最后是参数的数据类型来完成这一操作。所有这些操作都在你用`func`关键字声明函数参数时进行。这在Swift函数中很常见，可以让函数调用看起来更像一句话。[图7-6](text00017.html#ch07fig6)展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-8038
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-8039
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：`sayHello()`函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-8040
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)`函数的输入参数是`friend`，参数标签是`to`，函数调用中传入的参数是"Colin"。如果没有单独的参数标签，调用函数时会是`sayHello(friend:)`，这听起来不那么像一个完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-8041
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写具有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-8042
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-8043
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，说明如何通过添加自定义参数标签使代码更具可读性。在你的生日派对结束后，你会想给所有的来宾发送感谢信。请在你的Playground中编写以下函数：
- en: '[PRE1575]'
  id: totrans-8044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1575]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-8045
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了参数标签 for。参数名称 guest
    ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-8046
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数时，参数标签 to 和 for 用来标注传入的参数，如下所示：
- en: '[PRE1576]'
  id: totrans-8047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1576]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-8048
  prefs: []
  type: TYPE_NORMAL
  zh: '这里你可以看到，to: 被写在第一个输入值之前，而 for: 被写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。试图使用参数名称而不是标签将会导致错误：'
- en: '[PRE1577]'
  id: totrans-8049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1577]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-8050
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填写参数标签，因此你不必担心错误地调用函数（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-8051
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-8052
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了具有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-8053
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信 *to*（给）客人 *for*（因为）赠送的礼物。代码
    sendThankYou(to: "Meghan", for: "puzzle books") 看起来更像一句句子，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-8054
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-8055
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-8056
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线和空格来删除它们。在以下示例中，我们编写了一个计算体积的函数，该函数接受一个盒子的三个边作为输入。由于函数名称已经明确说明你需要传入三个边，因此你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1578]'
  id: totrans-8057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1578]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-8058
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处为 side1、➋ 处为 side2 和 ➌ 处为 side3 前面加上下划线，来去掉边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-8059
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需要输入参数值，而不需要任何标签。
- en: '[PRE1579]'
  id: totrans-8060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1579]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-8061
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72."。如果不是仅仅打印出盒子的体积，而是将结果存储到一个变量或常量中以供后续使用，那该多好呢？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-8062
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-8063
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-8064
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-8065
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能装更多的东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，返回一个 Int 类型的盒子体积：
- en: '[PRE1580]'
  id: totrans-8066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1580]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-8067
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数设置返回值，在函数的输入参数后➊使用一个破折号和大于号形成箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你通过使用
    return 关键字加上你要返回的值➋来返回值。如果你写一个返回值的函数，*你必须*在函数内部返回该值，否则会报错。函数在你返回值后结束。如果在 return
    语句后再写任何代码，它会被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-8068
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-8069
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-8070
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-8071
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，volumeOfBox(_:_:_:) 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在➋，边长为 8、4 和 2 的 volumeOfBox2 的值被设置为 64。现在，让我们打印一条消息，显示哪个盒子更大：
- en: '[PRE1581]'
  id: totrans-8072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1581]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-8073
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-8074
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-8075
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，它接受一个测试成绩的数组并返回平均成绩。为了计算平均值，你需要将所有成绩相加，然后除以成绩的总数。在你的
    Playground 中输入以下代码：
- en: '[PRE1582]'
  id: totrans-8076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1582]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-8077
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在➊，我们定义了一个名为 sum 的 Int 变量，并将其初始化为 0。➋中的 for-in 循环遍历 scores 数组中的每个值，并将其加到
    sum 变量中。当循环完成后，sum 变量保存了所有分数的总和。计算完总和后，剩下的就是将其除以总分数，简单地就是 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-8078
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会给你一个除以零的错误，并且导致程序崩溃。因此，在进行除法时，始终确保你要除的数不是零，这就是我们在➌通过检查
    scores.count > 0 来确保的。然后在➍，我们通过将所有分数的和除以分数的总数来返回平均值，使用 return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回
    sum / scores.count，因为它会计算为一个 Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-8079
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们还需要返回一个值，否则我们会收到函数缺少返回值的错误。我们通过在 if 语句后添加 else
    来处理这个问题，返回 0➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-8080
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-8081
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给 averageOf() 函数时，如我们在 ➊ 所做的，成绩的平均值将被返回并显示在结果面板中。如果你传入一个空数组，如我们在
    ➋ 所做的，返回值将是 0。
- en: '**NOTE**'
  id: totrans-8082
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-8083
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句实际上并不是必需的。这是因为如果 scores.count > 0，那么函数已经通过 return
    sum / scores.count 结束了。所以，如果计算机已经通过了那个 if 语句，我们就知道 scores.count > 0 一定不成立，我们完全可以直接写
    return 0，而不需要包裹在 else 语句中。然而，如果我们保留 else 语句，代码会更清晰，更容易理解。有时候，写一些额外的代码让别人更容易理解比使用简短的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-8084
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-8085
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛应用，用来做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-8086
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你创建具有不同于 Swift 中已包含类型的常量和变量，在你开发应用时会非常有用！
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  id: totrans-8087
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新函数将接受两个输入参数：一个 String 类型的参数表示客人的名字，一个 Bool 类型的参数表示 RSVP 状态，它的值可以是 true 或
    false。请在你的 playground 中输入以下代码：
- en: '[PRE1583]'
  id: totrans-8088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1583]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-8089
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数需要多个输入参数时，你需要在每个参数之间添加逗号 ➊ 。每个参数需要有一个参数名称，后面跟一个冒号和该参数的数据类型。你可以创建一个接受任意数量输入参数的函数，而且它们不必是相同类型。在
    sendMessage(guest:rsvped:) 函数中，我们传入一个 String 类型的 guest 和一个 Bool 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-8090
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 的值，看看它是否为 true ➋ ，然后使用 if-else 语句打印相应的消息。注意，函数定义中的最后打印语句无论
    rsvped 值是 true 还是 false 都会执行，因为它们在 if-else 语句的花括号之外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-8091
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已确认参加，他们会收到这条消息：
- en: '[PRE1584]'
  id: totrans-8092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1584]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-8093
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提示，要求他们做出回应：
- en: '[PRE1585]'
  id: totrans-8094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1585]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-8095
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一个客人的 rsvped 值设置为 true，另一个设置为 false，这样你就可以看到两个消息的效果了。
- en: '[PRE1586]'
  id: totrans-8096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1586]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-8097
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个具有多个输入参数的函数类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-8098
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会通过为你提供参数标签来帮助你填写输入值。你需要做的就是传入你想使用的值。在填写完客人名字后，按下 TAB 键，Xcode 会将光标定位到你需要填写下一个输入值的位置。（见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-8099
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-8100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入完客人姓名后按 TAB 键，会将光标移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-8101
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，程序会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-8102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-8103
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到当你调用 print(_:) 时，并没有在输入值前放置参数标签？你写的是：
- en: '[PRE1587]'
  id: totrans-8104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1587]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-8105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，将会报错：
- en: '[PRE1588]'
  id: totrans-8106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1588]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-8107
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些则没有。默认情况下，当你写一个函数时，每个参数都会有一个参数标签，并且这个标签与参数名称相同。然而，如果你写的函数中觉得参数标签对于清晰的代码没有必要，那么你可以在函数定义中显式地省略它。例如，在
    print(_:) 函数中，很明显你传入的是一个字符串并且它会被打印出来。每次调用 print(_:) 时都包含一个像 inputString 这样的参数标签会显得很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-8108
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。当你在 func 关键字后面第一次声明函数的参数时，所有这些都应该完成。通常在
    Swift 函数中，使用这种方式使得函数调用更像一句完整的句子。[图 7-6](text00017.html#ch07fig6) 说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-8109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-8110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-8111
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，而在函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，那么当你调用该函数时，代码会像
    sayHello(friend:) 这样，看起来就不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-8112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何编写带有自定义参数标签的函数。我们还会展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-8113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-8114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示如何通过添加自定义参数标签使你的代码更具可读性。在你的生日派对结束后，你会想给所有的客人发送感谢信。在你的 playground
    中写下以下函数：
- en: '[PRE1589]'
  id: totrans-8115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1589]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-8116
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们为传入函数的guest参数添加了自定义参数标签to。同样，在➋，我们为gift参数添加了参数标签for。参数名称guest ➌ 和gift ➍
    用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-8117
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for用于在调用函数时标记参数，如下所示：
- en: '[PRE1590]'
  id: totrans-8118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1590]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-8119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到to:在第一个输入值前写出，for:则在第二个输入值前写出。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名称代替将会报错：
- en: '[PRE1591]'
  id: totrans-8120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1591]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-8121
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会自动为你填充参数标签，因此你不必担心错误地调用函数（参见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-8122
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-8123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动完成函数并填入正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-8124
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常使用像*to*、*from* 或 *with*这样的介词作为参数标签。在这个例子中，函数用于向客人*致谢*，因为收到了一份礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")看起来更像一句话，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-8125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-8126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**去除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-8127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线和一个空格来去除它们。在以下示例中，我们编写了一个计算体积的函数，该函数接受盒子的三条边作为输入。因为函数名已经清晰地表明了需要传入三条边，所以实际上不需要参数标签来使代码更具可读性。
- en: '[PRE1592]'
  id: totrans-8128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1592]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-8129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在side1前加上下划线（➊）、在side2前加上下划线（➋）、在side3前加上下划线（➌）来去除三条边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-8130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，而无需任何标签。
- en: '[PRE1593]'
  id: totrans-8131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1593]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-8132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出“这个盒子的体积是72。” 如果你不仅仅想打印出盒子的体积，而是希望把结果存储在变量或常量中，以便后续使用，那不是很有用吗？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-8133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-8134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着重写volumeOfBoxWithSides(_:_:_:)函数，使它返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-8135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-8136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并想知道哪个可以装更多的东西。首先，编写一个volumeOfBox(_:_:_:)函数，该函数返回盒子的体积（Int）：
- en: '[PRE1594]'
  id: totrans-8137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1594]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-8138
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数返回值，可以在函数的输入参数➊后面使用短横线和大于号（->）构成一个箭头，然后输入返回值的数据类型。注意，返回值不需要命名，只需指定数据类型。在函数体内，通过使用`return`关键字并跟上你要返回的值来返回该值➋。如果你编写一个返回值的函数，那么你*必须*在函数内返回该值，否则会出现错误。函数在返回值后结束。如果在返回语句之后写了任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-8139
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-8140
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-8141
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-8142
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`volumeOfBox(_:_:_:)`函数计算了一个边长为6、5和3的盒子的体积，并将返回值90存储在名为`volumeOfBox1`的常量中。在➋处，边长为8、4和2的`volumeOfBox2`被赋值为64。现在让我们打印一条关于哪个盒子更大的信息：
- en: '[PRE1595]'
  id: totrans-8143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1595]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-8144
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串"Box 1 is the bigger box."的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-8145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-8146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，它接受一个测试分数的数组并返回平均分。为了得到平均分，你需要将所有分数加在一起，然后除以分数的总数。在你的playground中输入以下代码：
- en: '[PRE1596]'
  id: totrans-8147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1596]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-8148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在➊处，我们定义了一个名为`sum`的`Int`变量，并将其初始值设为0。➋处的`for-in`循环会遍历`score`数组中的每个值，并将其加到`sum`变量中。当循环完成时，`sum`变量存储了所有得分的总和。计算完总和后，剩下的就是将其除以总的得分数量，这个数量就是`scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-8149
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能用零除——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除零错误并使程序崩溃。因此，在进行除法时，务必确保除数不是零，这就是我们在➌处通过检查`scores.count
    > 0`来实现的。在➍处，我们通过将得分总和除以数组中得分的数量来返回平均值，使用`return sum / scores.count`。没错！你可以返回任何计算结果是正确数据类型的表达式，这意味着我们可以跳过将计算得到的平均值赋给新变量的步骤，直接返回`sum
    / scores.count`，因为它会计算出一个`Int`类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-8150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在`score.count`不大于零时返回一个值，否则我们会得到一个缺少返回值的错误。我们通过在`if`语句中添加`else`来处理这个问题，并返回0➎。你可以通过在一个包含分数的数组和一个空数组上调用函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-8151
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-8152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试成绩数组传递给 averageOf() 函数时，就像我们在 ➊ 所做的那样，函数会返回并显示成绩的平均值。如果传入一个空数组，如我们在
    ➋ 所做的那样，返回值则是 0。
- en: '**NOTE**'
  id: totrans-8153
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-8154
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不必要。这是因为如果 scores.count > 0 ，那么函数已经通过 return
    sum / scores.count 结束了。所以，如果计算机已经跳过了那个 if 语句，那么我们可以知道 scores.count > 0 肯定不成立，直接写
    return 0 就可以了，而无需将其放在 else 语句中。然而，如果我们保留 else 语句，代码会更清晰、更容易理解。有时，写一点额外的代码让其他人更容易理解，比使用巧妙的捷径更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-8155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-8156
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中广泛使用，可以实现各种令人惊叹的功能！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-8157
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建具有其他类型的常量和变量，而这些类型在
    Swift 中并没有预先包含，当你创建应用程序时这会非常有用！
- en: '[PRE1597]'
  id: totrans-8158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1597]'
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-8159
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数有多个输入参数时，你需要在每个参数之间加一个逗号 ➊。每个参数都需要有一个参数名称，后面跟着冒号和该参数的数据类型。你可以创建一个包含任意数量输入参数的函数，这些参数不一定是相同的类型。在
    sendMessage(guest:rsvped:) 函数中，我们传入了一个 String 类型的 guest 和一个 Bool 类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-8160
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 的值是否为 true ➋，然后使用 if-else 语句打印相应的消息。注意，函数定义中的最后几条 print 语句无论
    rsvped 的值是 true 还是 false 都会执行，因为它们位于 if-else 语句的外面。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-8161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经 RSVP 了，他们会收到这条消息：
- en: '[PRE1598]'
  id: totrans-8162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1598]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-8163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的通知，要求他们回复：
- en: '[PRE1599]'
  id: totrans-8164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1599]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-8165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一个客人的 rsvped 值设置为 true，另一个设置为 false，这样你就可以看到两条消息的效果。
- en: '[PRE1600]'
  id: totrans-8166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1600]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-8167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-8168
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会帮助你填写输入值，提供参数标签。你需要做的就是传入你想要使用的值。填写完客人姓名后，按 TAB 键，Xcode 会把光标移到下一个需要填写的输入框位置。（参见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-8169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-8170
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按 TAB 键，光标会移动到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-8171
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，程序会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-8172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-8173
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到在调用 print(_:) 时，你没有在输入值前添加参数标签？你写的是：
- en: '[PRE1601]'
  id: totrans-8174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1601]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-8175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，会报错：
- en: '[PRE1602]'
  id: totrans-8176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1602]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-8177
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且标签名与参数名相同。然而，如果你编写的函数中觉得参数标签对代码的清晰度没有帮助，那么你可以在函数定义时明确省略它。例如，在
    print(_:) 函数中，很明显传入的输入是一个将被打印的字符串。如果每次调用 print(_:) 时都要包含像 inputString 这样的参数标签，实在会让人觉得很烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-8178
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号和参数的数据类型来实现这一点。在你第一次声明函数参数时，就会在 func
    关键字后面的括号内完成这些操作。这样做通常是在 Swift 函数中，使得函数调用看起来更像是一个完整的句子。[图 7-6](text00017.html#ch07fig6)
    说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-8179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-8180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-8181
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，而函数调用中传入的参数是 "Colin"。如果你没有单独的参数标签，当你调用这个函数时，它看起来会像是
    sayHello(friend:)，这听起来不太像完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-8182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将探讨如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-8183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-8184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，看看添加自定义参数标签是如何让代码更具可读性的。生日聚会后，你可能想给所有的客人写感谢信。在你的 playground 中写下以下函数：
- en: '[PRE1603]'
  id: totrans-8185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1603]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-8186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们给传入函数的 guest 参数添加了一个自定义参数标签 to。类似地，在 ➋ 处，我们给 gift 参数添加了一个参数标签 for。参数名
    guest ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-8187
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在函数调用时标记参数，如下所示：
- en: '[PRE1604]'
  id: totrans-8188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1604]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-8189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `to:` 被写在第一个输入值前，而 `for:` 被写在第二个输入值前。如果一个参数有自定义的参数标签，那么你必须在函数调用中使用它。试图使用参数名代替会导致错误：
- en: '[PRE1605]'
  id: totrans-8190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1605]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-8191
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会自动为你填写参数标签，因此你不必担心调用函数时出错（见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-8192
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-8193
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-8194
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个示例中，函数用于向来宾发送感谢信 *to* 来宾 *for*
    礼物。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 比 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")` 更像一句话。'
- en: '![Image](Image00163.jpg)'
  id: totrans-8195
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-8196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-8197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加下划线并加一个空格来移除它们。在以下示例中，我们编写了一个用于计算体积的函数，接受盒子的三个边长作为输入。由于函数名已经明确说明需要传入三个边长，因此实际上不需要使用参数标签来提高代码的可读性。
- en: '[PRE1606]'
  id: totrans-8198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1606]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-8199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 `side1` 前面加上下划线（➊）、在 `side2` 前面加上下划线（➋）、在 `side3` 前面加上下划线（➌）来移除边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-8200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需要输入参数值而无需标签。
- en: '[PRE1607]'
  id: totrans-8201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1607]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-8202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出 "这个盒子的体积是 72。"。如果你能够将体积存储到一个变量或常量中，而不仅仅是将其打印出来，那该多好呢？让我们来看看如何使用返回值来做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-8203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-8204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，让它返回体积而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-8205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-8206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想要知道哪个盒子能装更多的东西。首先，写一个 `volumeOfBox(_:_:_:)` 函数来返回盒子的体积（以整数表示）：
- en: '[PRE1608]'
  id: totrans-8207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1608]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-8208
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数添加返回值，可以在函数输入参数之后使用一个破折号和大于符号（->）形成箭头 ➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，你通过使用
    `return` 关键字后跟你想要返回的值来返回该值 ➋。如果你编写一个返回值的函数，那么你 *必须* 在函数内部返回该值，否则会导致错误。函数在你返回值后结束。如果你在
    `return` 语句之后写任何代码，它会被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-8209
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-8210
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个函数来对比两个不同的盒子，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-8211
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-8212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 时，`volumeOfBox(_:_:_:)` 函数计算了一个边长分别为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 `volumeOfBox1`
    的常量中。在 ➋ 时，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在让我们打印一条消息，说明哪个盒子更大：
- en: '[PRE1609]'
  id: totrans-8213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1609]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-8214
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-8215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-8216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们写一个函数，接受一个测试分数数组并返回平均分。为了获得平均值，你需要将所有分数加起来，然后除以总的分数数量。在你的
    Playground 中输入以下代码：
- en: '[PRE1610]'
  id: totrans-8217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1610]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-8218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有数值的总和。在 ➊ 时，我们定义了一个名为 `sum` 的 Int 类型变量，并将其初始值设为 0。位于 ➋ 的 for-in 循环遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量存储了所有分数的总和。计算完总和后，剩下的就是将其除以总的分数数量，简单来说就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-8219
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空怎么办？你不能把某个数除以零——在数学课上或者在 Swift 中也是如此。在 Swift 中，尝试除以零会导致除以零的错误并崩溃程序。因此，在进行除法运算时，始终确保除数不为零，这也是我们在
    ➌ 通过检查 `scores.count > 0` 来做到的。到 ➍ 时，我们通过用 `return sum / scores.count` 将分数总和除以分数数量来返回平均值。没错！你可以返回任何求值为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回
    `sum / scores.count`，因为它求值为一个 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-8220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 `scores.count` 不大于零时返回某个值，否则我们会收到函数缺少返回值的错误。我们通过在 if 语句中添加一个 else
    来处理这个问题，返回值为 0 ➎。你可以通过对一个分数数组和一个空数组调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-8221
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-8222
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整个测试分数数组传递给 `averageOf()` 函数时，就像我们在 ➊ 所做的那样，分数的平均值会被返回并显示在结果窗格中。如果你传递的是一个空数组，就像我们在
    ➋ 所做的那样，返回值是 0。
- en: '**NOTE**'
  id: totrans-8223
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-8224
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句其实并不是必需的。这是因为如果 scores.count > 0 ，那么函数已经通过 return
    sum / scores.count 结束了。所以如果程序已经跳过了那个 if 语句，那么我们知道 scores.count > 0 一定不为真，那我们就可以直接使用
    return 0，而不需要将其放入 else 中。不过，如果我们保留 else 语句，代码会更清晰、更易于理解。有时候，写一点额外的代码来让代码更易懂比使用巧妙的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-8225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-8226
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，能够完成各种各样的精彩任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-8227
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建除 Swift 中已经包含的类型之外的常量和变量，这在你创建应用程序时非常有用！
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  id: totrans-8228
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受多个输入参数时，你需要在每个参数之间加一个逗号 ➊。每个参数都需要有一个参数名，后面跟着冒号和数据类型。你可以创建一个接收任意数量输入参数的函数，这些参数的类型也不必相同。在
    sendMessage(guest:rsvped:) 函数中，我们传入了一个字符串类型的 guest 和一个布尔类型的 rsvped。
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-8229
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 值是否为 true ➋，然后使用 if-else 语句打印相应的信息。还要注意，函数定义中的最后几个 print 语句无论
    rsvped 值是否为 true 都会执行，因为它们在 if-else 语句的大括号之外。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-8230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客人已经确认出席，他们将收到这条信息：
- en: '[PRE1611]'
  id: totrans-8231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1611]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-8232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提示，要求他们回复：
- en: '[PRE1612]'
  id: totrans-8233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1612]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-8234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数，看看它是如何工作的。尝试将一个客人的 rsvped 值设置为 true，另一个设置为 false，这样你就可以看到两个信息的实际效果。
- en: '[PRE1613]'
  id: totrans-8235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1613]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-8236
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-8237
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能将通过提供参数标签来帮助你填写输入值。你所需要做的就是传入你想要使用的值。在填写客人姓名后，按 TAB 键，Xcode 会将光标移到需要的位置，方便你填写下一个输入值。（见[图
    7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-8238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-8239
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按 TAB 键，将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-8240
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，程序会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-8241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-8242
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，输入值前面没有参数标签？你应该这样写：
- en: '[PRE1614]'
  id: totrans-8243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1614]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-8244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，系统会给出错误：
- en: '[PRE1615]'
  id: totrans-8245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1615]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-8246
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而一些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它与参数名称相同。然而，如果你编写一个函数，觉得参数标签并不是让代码更清晰所必需的，那么你可以在函数定义中显式地省略它。例如，在
    print(_:) 函数中，显而易见你传入的是一个字符串，它将被打印出来。每次调用 print(_:) 时都必须包含像 inputString 这样的参数标签会让人觉得麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-8247
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号以及最后的参数数据类型来做到这一点。这些操作是在函数声明时，在
    func 关键字后面的函数括号内进行的。Swift 函数中通常会这样做，以使函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6)
    说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-8248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-8249
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-8250
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，而函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用该函数时会像
    sayHello(friend:) 这样，听起来不像是一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-8251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将学习如何编写带有自定义参数标签的函数。我们还会展示如何编写一个省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-8252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-8253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例，展示如何添加自定义参数标签可以使你的代码更易读。生日派对结束后，你可能想给所有的客人发送感谢信。请在你的 Playground 中编写以下函数：
- en: '[PRE1616]'
  id: totrans-8254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1616]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-8255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了一个自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名称
    guest ➌ 和 gift ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-8256
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于标记函数调用时的参数，像这样：
- en: '[PRE1617]'
  id: totrans-8257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1617]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-8258
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里你可以看到，to: 在函数调用中位于第一个输入值之前，而 for: 位于第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用中使用它。如果试图使用参数名称替代，系统会给出错误：'
- en: '[PRE1618]'
  id: totrans-8259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1618]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-8260
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全会始终为你填充参数标签，因此你不必担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-8261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-8262
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-8263
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用来向客人发送感谢信，*to*是指向客人，*for*是指为了感谢某个礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")的表达方式更像一句话，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-8264
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-8265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-8266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前加下划线和空格来去除它们。在以下示例中，我们编写了一个计算体积的函数，接受盒子的三个边作为输入。因为函数名已经明确表示需要传入三个边，所以实际上你不需要参数标签来使代码更易读。
- en: '[PRE1619]'
  id: totrans-8267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1619]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-8268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处、➋处和➌处的side1、side2、side3前面放置下划线来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-8269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，你只需输入参数值，不需要任何标签。
- en: '[PRE1620]'
  id: totrans-8270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1620]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-8271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"这个盒子的体积是72。"。如果你能将盒子的体积存储到变量或常量中，以便稍后使用，而不仅仅是打印出来，这不是更有用吗？让我们来看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-8272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-8273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-8274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-8275
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能装更多东西。首先，编写一个volumeOfBox(_:_:_:)函数，返回一个Int类型的盒子体积：
- en: '[PRE1621]'
  id: totrans-8276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1621]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-8277
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数返回一个值，在函数的输入参数后面用一个短横线和大于号（->）构成箭头，➊处，然后输入返回值的数据类型。注意，你不需要为返回值命名，只需提供数据类型。在函数体内，使用return关键字后跟你想返回的值来返回这个值➋。如果你写了一个返回值的函数，那么你*必须*在函数内部返回这个值，否则会报错。函数在你返回值后结束。如果在return语句后还写了其他代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-8278
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-8279
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-8280
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-8281
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算一个边长为6、5和3的盒子的体积，返回值90存储在名为volumeOfBox1的常量中。在➋处，边长为8、4和2的volumeOfBox2赋值为64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1622]'
  id: totrans-8282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1622]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-8283
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串"Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-8284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-8285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们写一个函数，它接受一个测试分数数组并返回平均分数。为了计算平均分，你需要将所有分数相加，然后除以分数的总数。在你的
    playground 中输入以下代码：
- en: '[PRE1623]'
  id: totrans-8286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1623]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-8287
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始值设为 0。➋ 处的 for-in 循环遍历 `scores`
    数组中的每个值，并将其加到 sum 变量中。当循环完成时，sum 变量存储了所有分数的总和。计算总和后，剩下的就是将其除以分数的总数，即 `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-8288
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组是空的呢？你不能除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，试图除以零会导致除零错误，并使程序崩溃。因此，在进行除法时，务必确保你要除的数字不为零，这也是我们在
    ➌ 处通过检查 `scores.count > 0` 来确保的。在 ➍ 处，我们通过将分数总和除以分数数组中的元素数量来返回平均值，使用 `return sum
    / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算得到的平均值赋给新变量的步骤，直接返回 `sum
    / scores.count`，因为它计算出来的就是一个 `Int` 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-8289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们还需要返回一些内容，否则会出现函数缺少返回值的错误。我们通过在 if 语句后添加一个 else
    来处理这一问题，返回值为 0 ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-8290
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-8291
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 `averageOf()` 函数时，如同我们在 ➊ 处所做的，函数会返回并在结果面板中显示分数的平均值。如果你传递一个空数组，如我们在
    ➋ 处所做的，返回值则是 0。
- en: '**NOTE**'
  id: totrans-8292
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-8293
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不是必需的。因为如果 `scores.count > 0`，那么函数会在执行 `return
    sum / scores.count` 后结束。因此，如果计算机已经执行完了那条 if 语句，我们就知道 `scores.count > 0` 可能不成立，这时可以直接写一个
    `return 0`，而不需要把它放在 else 中。然而，如果我们保留 else 语句，代码会更清晰，更容易理解。有时候，为了让其他人更容易理解代码，写一点额外的代码比使用巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-8294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-8295
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚向你的 Swift 工具箱中添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种神奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-8296
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建除 Swift 中已经包含的类型之外的常量和变量，这在你创建应用程序时非常有用！
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  id: totrans-8297
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们检查 rsvped 的值，看看它是否为 true ➋，然后使用 if-else 语句打印相应的消息。注意，函数定义中的最终 print
    语句无论 rsvped 的值是 true 还是 false 都会执行，因为它们位于 if-else 语句的外部。
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-8298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的宾客已经回复了 RSVP，他们将收到这条消息：
- en: '[PRE1624]'
  id: totrans-8299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1624]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-8300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们将收到一条礼貌的提醒，要求他们回复：
- en: '[PRE1625]'
  id: totrans-8301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1625]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-8302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一个宾客的 rsvped 值设置为 true，将另一个宾客的 rsvped 值设置为 false，这样你就可以看到两个消息的实际效果。
- en: '[PRE1626]'
  id: totrans-8303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1626]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-8304
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-8305
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能将通过为你提供参数标签来帮助你填写输入值。你只需传入你想使用的值即可。在填写完宾客姓名后，按下 TAB 键，Xcode 将把光标移到你需要的位置，以填写下一个输入值。（见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-8306
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-8307
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入宾客姓名后按 TAB 键将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-8308
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，如姓名或数字，你将得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-8309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-8310
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到当你调用 print(_:) 时，你并没有在输入值前加上参数标签？你写的是：
- en: '[PRE1627]'
  id: totrans-8311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1627]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-8312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，你将得到一个错误：
- en: '[PRE1628]'
  id: totrans-8313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1628]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-8314
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且该标签与参数名相同。然而，如果你编写一个函数并且觉得参数标签对于代码的清晰性并不是必需的，那么你可以在函数定义中显式地省略它。例如，在
    print(_:) 函数中，很明显你传入的输入是一个将被打印的字符串。每次调用 print(_:) 时都必须包含一个像 inputString 这样的参数标签会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-8315
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现这一点。这一切都在你第一次声明函数括号内的参数时进行，位于
    func 关键字之后。在 Swift 函数中，这通常是为了使函数调用看起来更像一句话。[图 7-6](text00017.html#ch07fig6) 演示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-8316
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-8317
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：sayHello()函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-8318
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:)函数的输入参数是friend，参数标签是to，函数调用中传入的参数是"Colin"。如果没有单独的参数标签，调用该函数时就会变成sayHello(friend:)，这听起来不太像完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-8319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何编写带有自定义参数标签的函数。我们还会向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-8320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-8321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示如何添加自定义参数标签来提高代码的可读性。生日派对后，你可能想要向所有宾客发送感谢信。请在你的Playground中写下以下函数：
- en: '[PRE1629]'
  id: totrans-8322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1629]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-8323
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们给传入函数的guest参数添加了自定义参数标签to。同样，在➋处，我们给gift参数添加了参数标签for。参数名称guest ➌和gift
    ➍用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-8324
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for在函数调用时用于标记参数，如下所示：
- en: '[PRE1630]'
  id: totrans-8325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1630]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-8326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到，to:写在函数调用中的第一个输入值之前，for:写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名称代替会导致错误：
- en: '[PRE1631]'
  id: totrans-8327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1631]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-8328
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会始终为你填充参数标签，所以你不必担心错误地调用函数（见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-8329
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-8330
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-8331
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于向宾客发送感谢信*to*感谢他们的礼物*for*。代码sendThankYou(to:
    "Meghan", for: "puzzle books")更像一句完整的句子，而sendThankYou(guest: "Meghan", gift: "puzzle
    books")则不太像。'
- en: '![Image](Image00163.jpg)'
  id: totrans-8332
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-8333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**删除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-8334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加下划线和空格来移除它们。在下面的示例中，我们编写了一个计算体积的函数，该函数接受一个盒子的三个边作为输入。因为函数名称已经明确表示你需要传入三条边，所以实际上你不需要参数标签来提高代码的可读性。
- en: '[PRE1632]'
  id: totrans-8335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1632]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-8336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在侧面参数前添加下划线来去除参数标签：在➊处是side1，➋处是side2，➌处是side3。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-8337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，不需要任何标签。
- en: '[PRE1633]'
  id: totrans-8338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1633]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-8339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "The volume of this box is 72."。如果你能把盒子的体积存储到一个变量或常量中，以便以后使用，而不仅仅是打印出来，岂不是更有用？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-8340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-8341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，将其返回体积，而不是将体积打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-8342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-8343
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个能装更多的东西。首先，编写一个`volumeOfBox(_:_:_:)`函数，它返回一个`Int`类型的盒子体积：
- en: '[PRE1634]'
  id: totrans-8344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1634]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-8345
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数设置返回值，在函数的输入参数➊之后，使用短横线和大于号形成箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，你使用`return`关键字并跟随你想返回的值来返回该值➋。如果你编写了一个返回值的函数，那么你*必须*在函数内返回该值，否则会报错。函数在返回值后结束。如果你在`return`语句之后写了任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-8346
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-8347
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-8348
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-8349
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`volumeOfBox(_:_:_:)`函数计算一个边长为6、5和3的盒子的体积，返回值90被存储在一个名为`volumeOfBox1`的常量中。在➋处，边长为8、4和2的`volumeOfBox2`被赋值为64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1635]'
  id: totrans-8350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1635]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-8351
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-8352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-8353
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。我们来编写一个函数，它接收一个测试成绩的数组并返回平均分。为了计算平均分，你需要将所有成绩加起来，然后除以成绩的总数。请在你的playground中输入以下代码：
- en: '[PRE1636]'
  id: totrans-8354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1636]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-8355
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在➊处，我们定义了一个名为`sum`的Int类型变量，并将其初始化为0。➋处的`for-in`循环遍历`scores`数组中的每个值，并将其加到`sum`变量中。当循环完成时，`sum`变量就存储了所有成绩的总和。计算完总和后，剩下的就是将其除以成绩的总数，即`scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-8356
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空怎么办？你不能将任何东西除以零——无论是在数学课上，还是在Swift中。在Swift中，尝试除以零会导致除零错误并使程序崩溃。因此，在进行除法时，务必确保除数不是零，这正是我们通过检查`score.count
    > 0`在➌处完成的。然后在➍处，我们通过将分数总和除以数组中的分数数量来返回平均值，使用`return sum / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回`sum
    / scores.count`，因为它会计算为`Int`类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-8357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`score.count`不大于零时，我们也需要返回一个值，否则会报错提示函数缺少返回值。我们通过在`if`语句中添加一个`else`，返回0
    ➎ 来处理这个问题。你可以通过调用函数，传入一个分数数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-8358
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-8359
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像在➊所做的那样，将一整个测试成绩数组传入`averageOf()`函数时，返回的是分数的平均值，并且结果会显示在结果面板中。如果你传入一个空数组，如在➋所做的，返回值就是0。
- en: '**NOTE**'
  id: totrans-8360
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-8361
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，`else`语句包裹`return 0`其实并不是必要的。这是因为如果`scores.count > 0`，函数会在`return sum
    / scores.count`处提前结束。所以，如果计算机已经通过了那个`if`语句，我们就知道`scores.count > 0`一定不成立，我们本可以直接写`return
    0`，而不需要将其包裹在`else`中。然而，如果我们保留`else`语句，代码会更加清晰，容易理解。有时，写一些额外的代码以使别人更容易理解，往往比使用复杂的捷径更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-8362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-8363
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以实现各种神奇的功能！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-8364
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建类型不同于Swift中已有类型的常量和变量，这在你创建应用程序时非常有用！
- en: 'If your guest has RSVPed, they’ll get this message:'
  id: totrans-8365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的嘉宾已经回复了，他们会收到这个消息：
- en: '[PRE1637]'
  id: totrans-8366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1637]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-8367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提示，要求他们回复：
- en: '[PRE1638]'
  id: totrans-8368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1638]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-8369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数来看看它是如何工作的。试着将一个嘉宾的`rsvped`值设置为`true`，将另一个嘉宾的设置为`false`，这样你就能看到两个消息的实际效果。
- en: '[PRE1639]'
  id: totrans-8370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1639]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-8371
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-8372
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会帮助你填写输入值，为你提供参数标签。你只需要传入你想使用的值。输入完客人名字后，按 TAB 键，Xcode 会把光标自动放到你需要的位置，继续填写下一个输入值。（见
    [图 7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-8373
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-8374
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入完客人的名字后按 TAB 键，光标将自动跳到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-8375
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，你会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-8376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-8377
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到调用 print(_:) 时，输入值前面没有参数标签吗？你只需要写：
- en: '[PRE1640]'
  id: totrans-8378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1640]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-8379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加标签，系统会提示你错误：
- en: '[PRE1641]'
  id: totrans-8380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1641]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-8381
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它与参数名相同。但是，如果你编写的函数中，觉得不需要参数标签来使代码更清晰，那么你可以在函数定义中显式省略它。例如，在
    print(_:) 函数中，传入的内容显然是一个字符串，将会被打印出来。如果每次调用 print(_:) 时都需要加上像 inputString 这样的参数标签，显得就很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-8382
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你通过输入参数标签、参数名、冒号，最后是参数的数据类型来实现这一点。你在函数声明的参数部分，紧跟在 `func`
    关键字后进行这些操作。这在 Swift 函数中很常见，用来使函数调用更像一句完整的句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-8383
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-8384
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-8385
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用该函数时会像
    sayHello(friend:)，听起来不像一句完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-8386
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写带有自定义参数标签的函数。我们还会展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-8387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-8388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例，看看如何通过添加自定义参数标签来提高代码的可读性。在你的生日派对结束后，你会想要给所有的客人发送感谢信。请在 Playground
    中编写以下函数：
- en: '[PRE1642]'
  id: totrans-8389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1642]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-8390
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了一个自定义的参数标签 `to`。同样，在 ➋ 处，我们为 gift 参数添加了一个参数标签 `for`。参数名
    guest ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-8391
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 `to` 和 `for` 用于在调用函数时标记参数，像这样：
- en: '[PRE1643]'
  id: totrans-8392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1643]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-8393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `to:` 写在第一个输入值之前，`for:` 写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。如果尝试使用参数名代替，将会出现错误：
- en: '[PRE1644]'
  id: totrans-8394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1644]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-8395
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填写正确的参数标签，因此你无需担心错误地调用函数（请参见 [图 7-7](text00017.html#ch07fig7)
    ）。
- en: '![Image](Image00162.jpg)'
  id: totrans-8396
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-8397
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-8398
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信，感谢他们赠送的礼物 *to*
    一个客人 *for* 一个礼物。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 看起来更像一句话，而不是
    `sendThankYou(guest: "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-8399
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-8400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-8401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前添加下划线并留一个空格来移除它们。在以下示例中，我们编写了一个计算体积的函数，该函数接受盒子的三条边作为输入。因为函数名已经清楚地表明你需要传入三条边，所以你不需要使用参数标签来提高代码的可读性。
- en: '[PRE1645]'
  id: totrans-8402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1645]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-8403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处为 `side1`、➋ 处为 `side2` 和 ➌ 处为 `side3` 前加下划线来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-8404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，无需任何标签。
- en: '[PRE1646]'
  id: totrans-8405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1646]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-8406
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。" 如果你能够把盒子的体积结果存储到一个变量或常量中，而不是仅仅打印它，那不是更有用吗？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-8407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-8408
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-8409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-8410
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个可以装更多的东西。首先，编写一个 `volumeOfBox(_:_:_:)` 函数，该函数返回盒子的体积，单位为
    Int：
- en: '[PRE1647]'
  id: totrans-8411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1647]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-8412
  prefs: []
  type: TYPE_NORMAL
  zh: 为函数提供返回值时，使用一个短横线和大于号形成箭头（->）紧跟在函数的输入参数之后 ➊，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，你通过使用
    `return` 关键字加上你要返回的值来返回结果 ➋。如果你编写的函数有返回值，那么你*必须*在函数内部返回该值，否则你会遇到错误。函数在返回值之后结束。如果在
    `return` 语句之后再写任何代码，它将被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-8413
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-8414
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数并对两个不同的盒子进行测试，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-8415
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-8416
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 的值为 64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1648]'
  id: totrans-8417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1648]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-8418
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-8419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-8420
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，它接受一个测试分数数组并返回平均分。为了得到平均值，你需要将分数相加，然后除以分数的总数量。在你的
    Playground 中输入以下代码：
- en: '[PRE1649]'
  id: totrans-8421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1649]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-8422
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 Int 类型变量，并将其初始值设置为 0。位于 ➋ 处的 `for-in`
    循环会遍历 `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量保存了所有分数的总和。在我们计算出总和后，剩下的就是将其除以分数的总数量，即
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-8423
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能用零去除一个数——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并使程序崩溃。因此，在进行除法时，始终确保你要除的数不是零，这就是我们通过检查
    `scores.count > 0` 在 ➌ 处实现的。在 ➍ 处，我们通过将分数总和除以数组中分数的数量来返回平均值，使用 `return sum / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回
    `sum / scores.count`，因为它的结果是一个 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-8424
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一些值，否则会报错提示函数缺少返回值。我们通过在 `if` 语句中添加 `else`
    来处理这种情况，返回 0 ➎。你可以通过在分数数组和空数组上调用函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-8425
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-8426
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整个测试分数数组传入 `averageOf()` 函数时，就像我们在 ➊ 所做的那样，函数会返回分数的平均值，并显示在结果面板中。如果你传入一个空数组，就像我们在
    ➋ 所做的那样，返回值将是 0。
- en: '**NOTE**'
  id: totrans-8427
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-8428
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句其实并不是必须的。这是因为如果 `scores.count > 0`，那么函数会已经结束，并返回
    `sum / scores.count`。所以，如果计算机已经通过了那个 if 语句，我们知道 `scores.count > 0` 一定不为真，我们可以直接写
    `return 0`，而不需要将它放在 else 语句中。不过，如果我们保留 else 语句，代码会更加清晰，易于理解。有时候，为了让代码对别人更清晰，写一些额外的代码比使用巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-8429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-8430
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚给你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-8431
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你能够创建除 Swift 中已有类型以外的常量和变量，这在你开发应用时非常有用！
- en: '[PRE1650]'
  id: totrans-8432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1650]'
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-8433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，他们会收到一条礼貌的提示，要求他们回应：
- en: '[PRE1651]'
  id: totrans-8434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1651]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-8435
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。试着将一个客人的 rsvped 值设置为 true，另一个客人的值设置为 false，这样你就能看到两个消息的效果。
- en: '[PRE1652]'
  id: totrans-8436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1652]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-8437
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-8438
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会通过提供参数标签来帮助你填写输入值。你只需要传入你想使用的值。在填写完客人姓名后，按 TAB 键，Xcode 会将光标放置在需要填写下一个输入值的位置。（参见[图
    7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-8439
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-8440
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按 TAB 键将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-8441
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 `rsvped` 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他值，比如名字或数字，你将收到错误提示。
- en: '**ARGUMENT LABELS**'
  id: totrans-8442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-8443
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 `print(_:)` 时，你并没有在输入值前加上参数标签？你写的是：
- en: '[PRE1653]'
  id: totrans-8444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1653]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-8445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你将会遇到错误：
- en: '[PRE1654]'
  id: totrans-8446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1654]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-8447
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而有些没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且该标签与参数名称相同。然而，如果你编写一个函数时觉得参数标签对代码的清晰度没有帮助，你可以在函数定义中显式地省略它。例如，在`print(_:)`函数中，很明显你传入的是一个字符串，它将被打印出来。如果每次调用`print(_:)`时都必须包含像`inputString`这样的参数标签，那就会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-8448
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你通过输入参数标签、参数名称、冒号，然后是参数的数据类型来实现这一点。在首次声明参数时，你需要在`func`关键字后的函数括号内完成这一操作。这通常在
    Swift 函数中使用，目的是让函数调用看起来更像一个完整的句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-8449
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-8450
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：`sayHello()`函数具有自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-8451
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)`函数的输入参数是`friend`，参数标签是`to`，在函数调用中传入的参数是“Colin”。如果没有单独的参数标签，那么在调用函数时，它将看起来像`sayHello(friend:)`，这听起来不像一个完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-8452
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何编写具有自定义参数标签的函数。我们还将向你展示如何编写一个函数，在该函数中完全省略参数标签。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-8453
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-8454
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过添加自定义参数标签来使你的代码更具可读性。假设你举办了一个生日派对，之后你想给所有的宾客发送感谢信。请在你的 Playground 中编写以下函数：
- en: '[PRE1655]'
  id: totrans-8455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1655]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-8456
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入的`guest`参数添加了自定义参数标签`to`。类似地，在 ➋ 处，我们为`gift`参数添加了参数标签`for`。参数名称`guest`
    ➌ 和`gift` ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-8457
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签“to”和“for”用于在调用函数时标记参数，像这样：
- en: '[PRE1656]'
  id: totrans-8458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1656]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-8459
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到，`to:`在函数调用中出现在第一个输入值之前，`for:`则出现在第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用中使用它。如果尝试使用参数名称而不是标签，会导致错误：
- en: '[PRE1657]'
  id: totrans-8460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1657]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-8461
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填写参数标签，因此你不必担心错误地调用函数（请参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-8462
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-8463
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成函数并正确填写参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-8464
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信，*to*表示给谁，*for*表示感谢什么礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")更像一句话，而不是sendThankYou(guest: "Meghan", gift: "puzzle
    books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-8465
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-8466
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除一个参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-8467
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加下划线和空格来移除它们。在下面的例子中，我们写了一个计算体积的函数，它接受盒子的三个边作为输入。因为函数名已经明确表示你需要传入三个边，所以实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1658]'
  id: totrans-8468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1658]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-8469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处给side1、➋处给side2、➌处给side3前面加下划线，移除这些边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-8470
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你调用函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE1659]'
  id: totrans-8471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1659]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-8472
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出"The volume of this box is 72."。如果你能够将结果存储到变量或常量中以便以后使用，而不是仅仅打印出盒子的体积，这不是更有用吗？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-8473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-8474
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-8475
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-8476
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多东西。首先，编写一个volumeOfBox(_:_:_:)函数，它返回一个Int类型的盒子体积：
- en: '[PRE1660]'
  id: totrans-8477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1660]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-8478
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数提供返回值，可以在函数的输入参数后面使用破折号和大于号形成箭头（->），然后输入返回值的数据类型。注意，返回值没有名字，只有数据类型。在函数体内，你通过使用return关键字后跟你想返回的值来返回该值➋。如果你写一个返回值的函数，那么你*必须*在函数内部返回这个值，否则会出现错误。函数在返回值之后结束。如果你在return语句后写任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-8479
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-8480
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-8481
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-8482
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算了一个边长为6、5和3的盒子的体积，返回值90存储在一个叫volumeOfBox1的常量中。在➋处，边长为8、4和2的volumeOfBox2被赋值为64。现在，让我们打印一条消息，说明哪个盒子更大：
- en: '[PRE1661]'
  id: totrans-8483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1661]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-8484
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到输出字符串"Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-8485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-8486
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，它接受一个测试分数的数组并返回平均分数。为了计算平均值，你将分数相加，然后除以分数的总数。请输入以下代码到你的playground中：
- en: '[PRE1662]'
  id: totrans-8487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1662]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-8488
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在➊，我们定义了一个名为sum的Int变量，并将其初始值设置为0。在➋的for-in循环中，遍历分数数组中的每个值，并将其加到sum变量中。当循环完成时，变量sum保存了所有分数的总和。在计算出总和之后，剩下的就是将其除以分数的总数，即scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-8489
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组是空的怎么办？你不能将某个数除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除零错误并崩溃你的程序。因此，在进行除法运算时，始终确保你将要除以的数字不是零，这也是我们通过在➌处检查scores.count
    > 0来完成的。在➍处，我们通过将分数的总和除以数组中分数的数量来返回平均值，使用的是return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回sum
    / scores.count，因为它计算的结果是一个Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-8490
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们还需要返回某些内容，否则会出现函数缺少返回值的错误。我们通过在if语句中添加else来处理这个问题，从而返回0
    ➎。你可以通过调用函数并传入一个分数数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-8491
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-8492
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一组完整的测试分数传入averageOf()函数时，如我们在➊所做的，函数返回分数的平均值并显示在结果面板中。如果传入一个空数组，如我们在➋所做的，返回值为0。
- en: '**NOTE**'
  id: totrans-8493
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-8494
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句其实并不是必须的。因为如果scores.count > 0，那么函数会在return sum / scores.count时结束。所以如果计算机已经通过了那条if语句，我们就知道scores.count
    > 0一定不为真，我们可以直接使用return 0而不需要将其包裹在else中。然而，如果我们保留else语句，代码会更加清晰易懂。有时候，写一点额外的代码使其他人更容易理解，比使用复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-8495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-8496
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要工具——创建并调用你自己的函数！函数在编程中被广泛使用，可以完成各种惊人的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-8497
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08) 中，我们将展示如何通过编写类定义来创建自定义对象。这样，你就可以创建不同于 Swift 中已有类型的常量和变量，这对于你开发应用时会非常有用！
- en: 'If not, they’ll get a polite note asking them to respond:'
  id: totrans-8498
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，它们会收到一条礼貌的提示，要求他们回复：
- en: '[PRE1663]'
  id: totrans-8499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1663]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-8500
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。试着将一个宾客的 rsvped 值设置为 true，另一个宾客的设置为 false，这样你就可以看到两个消息的效果。
- en: '[PRE1664]'
  id: totrans-8501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1664]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-8502
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-8503
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会通过为你提供参数标签来帮助你填写输入值。你只需传入你想使用的值即可。填写完宾客姓名后，按下 TAB 键，Xcode 会将光标移至你需要的位置，以填写下一个输入值。（见
    [图 7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-8504
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-8505
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入宾客姓名后按 TAB 键，光标将跳到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-8506
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他任何值，比如姓名或数字，你会遇到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-8507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-8508
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，输入值前面没有参数标签？你只需要写：
- en: '[PRE1665]'
  id: totrans-8509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1665]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-8510
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，会遇到一个错误：
- en: '[PRE1666]'
  id: totrans-8511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1666]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-8512
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且它会与参数名称相同。然而，如果你编写一个函数，并且觉得参数标签在让代码更加清晰上并不必要，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，传入的值显然是一个字符串，将被打印出来。如果每次调用 print(_:) 时都必须包含像 inputString 这样的参数标签，那就太麻烦了。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-8513
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，然后是参数的数据类型来做到这一点。所有这些都在你首先声明函数括号中的参数时进行。这通常在
    Swift 函数中使用，以使函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-8514
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-8515
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-8516
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，函数调用时看起来会是
    sayHello(friend:)，这听起来就不像是一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-8517
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-8518
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-8519
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示如何通过添加自定义参数标签来提高代码的可读性。生日派对结束后，你会想要给所有的客人发送感谢信。请在你的 Playground 中写下以下函数：
- en: '[PRE1667]'
  id: totrans-8520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1667]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-8521
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们给传递给函数的 guest 参数添加了一个自定义的参数标签 `to`。类似地，在 ➋ 处，我们给 gift 参数添加了一个参数标签 `for`。参数名
    guest ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-8522
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 `to` 和 `for` 用于在调用函数时标注参数，像这样：
- en: '[PRE1668]'
  id: totrans-8523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1668]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-8524
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到 `to:` 写在函数调用中第一个输入值前，而 `for:` 写在第二个输入值前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名代替会导致错误：
- en: '[PRE1669]'
  id: totrans-8525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1669]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-8526
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会自动为你填写参数标签，因此你无需担心函数调用错误（请参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-8527
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-8528
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-8529
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用介词，如 *to*、*from* 或 *with* 作为参数标签。在这个例子中，函数用于向客人发送感谢信，*to* 表示感谢的对象，*for*
    表示礼物。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 更像一句完整的句子，而不像 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-8530
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-8531
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-8532
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，你可以通过在参数名前添加一个下划线和空格来移除它们。在下面的例子中，我们编写了一个计算体积的函数，它接受一个盒子的三个边长作为输入。因为函数名已经明确表明你需要传入三个边长，所以你其实不需要参数标签来提高代码的可读性。
- en: '[PRE1670]'
  id: totrans-8533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1670]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-8534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 side1 前加下划线 ➊、在 side2 前加下划线 ➋、在 side3 前加下划线 ➌ 来移除这些侧面的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-8535
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE1671]'
  id: totrans-8536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1671]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-8537
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 “The volume of this box is 72.”。如果你不仅仅是将箱子的体积打印出来，而是将结果存储到一个变量或常量中以便以后使用，那是不是更有用？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-8538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-8539
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-8540
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-8541
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个可以装下更多的东西。首先，编写一个volumeOfBox(_:_:_:)函数，返回一个表示盒子体积的Int：
- en: '[PRE1672]'
  id: totrans-8542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1672]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-8543
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数设置返回值，使用破折号和大于符号来形成箭头（->）紧跟在函数的输入参数之后 ➊，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，使用return关键字并跟上你要返回的值
    ➋ 来返回该值。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果你在return语句之后再写任何代码，它们会被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-8544
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-8545
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-8546
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-8547
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:)函数计算了一个边长为6、5和3的盒子的体积，返回值90存储在一个名为volumeOfBox1的常量中。在
    ➋ 处，边长为8、4和2的volumeOfBox2的值为64。现在让我们打印一条关于哪个盒子更大的信息：
- en: '[PRE1673]'
  id: totrans-8548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1673]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-8549
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串“Box 1 is the bigger box.”。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-8550
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-8551
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据某个条件返回不同的值。让我们编写一个函数，它接受一个测试分数数组，并返回平均分。为了得到平均分，你需要将所有分数加在一起，然后除以分数的总数。将以下代码输入到你的playground中：
- en: '[PRE1674]'
  id: totrans-8552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1674]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-8553
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义一个名为sum的Int变量，并将其初始值设置为0。 ➋ 处的for-in循环遍历scores数组中的每个值，并将其加到sum变量中。当循环完成时，变量sum保存了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数，分数总数就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-8554
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空呢？你不能除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除以零错误并崩溃你的程序。因此，在进行除法运算时，始终确保你要除的数不是零，这就是我们在
    ➌ 处通过检查scores.count > 0来确保的。在 ➍ 处，我们通过将分数的总和除以数组中分数的数量来返回平均值，使用return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回sum
    / scores.count，因为它会计算出一个Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-8555
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们也需要返回一些内容，否则会出现错误，提示函数缺少返回值。我们通过在 if 语句中添加 else
    来处理这个问题，返回 0 ➎。你可以通过在一个包含分数的数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-8556
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-8557
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试分数数组传入 averageOf() 函数时，如我们在 ➊ 所示，返回的是分数的平均值，并显示在结果面板中。如果传入一个空数组，如我们在
    ➋ 所示，返回值是 0。
- en: '**NOTE**'
  id: totrans-8558
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-8559
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，else 语句围绕 return 0 实际上并不是必需的。这是因为如果 scores.count > 0，那么函数已经通过 return
    sum / scores.count 提前结束了。所以如果计算机已经越过了那个 if 语句，我们就知道 scores.count > 0 肯定不成立，我们完全可以直接写
    return 0，而不必放在 else 语句中。然而，如果我们保留 else 语句，代码会更清晰，也更容易理解。有时候，写一些额外的代码让别人更容易理解，比使用一个复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-8560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-8561
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来完成各种令人惊叹的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-8562
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08) 中，我们将展示如何通过编写类定义来创建自定义对象。这将让你能够创建除 Swift 已经包含的类型之外的常量和变量，这在你创建应用时非常有用！
- en: '[PRE1675]'
  id: totrans-8563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1675]'
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-8564
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。试着将一个来宾的 rsvped 值设置为 true，另一个设置为 false，这样你就可以看到两个消息的效果。
- en: '[PRE1676]'
  id: totrans-8565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1676]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-8566
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用只有一个输入参数的函数是类似的。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-8567
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能将帮助你填写输入值，通过为你提供参数标签。你只需要传入你想使用的值即可。在填写完来宾姓名后，按下 TAB 键，Xcode 会将光标移动到你需要填写下一个输入值的位置。（见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-8568
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-8569
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入完来宾姓名后按 TAB 键会将光标移到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-8570
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，你会收到错误提示。
- en: '**ARGUMENT LABELS**'
  id: totrans-8571
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-8572
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用 print(_:) 时，输入值前没有添加参数标签吗？你直接写：
- en: '[PRE1677]'
  id: totrans-8573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1677]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-8574
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，你会收到错误提示：
- en: '[PRE1678]'
  id: totrans-8575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1678]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-8576
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用时有参数标签，而一些没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，且参数标签与参数名相同。然而，如果你编写的函数中觉得参数标签对于代码的清晰度不是必须的，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，很明显传入的输入是一个将被打印的字符串。如果每次调用 print(_:) 都需要包含像 inputString 这样的参数标签，那将会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-8577
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你需要在第一次声明参数时输入参数标签、参数名、冒号，然后是参数的数据类型。这些操作是在函数定义中的括号内完成的，通常出现在
    func 关键字后。这种方式在 Swift 函数中经常使用，以使函数调用更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-8578
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-8579
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-8580
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传递的参数是 "Colin"。如果没有单独的参数标签，调用该函数时看起来会像
    sayHello(friend:)，这听起来不像一句完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-8581
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何编写带有自定义参数标签的函数。我们还会展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-8582
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-8583
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，展示如何通过添加自定义参数标签使代码更具可读性。假设在你的生日派对结束后，你需要给所有的客人写感谢信。你可以在 playground
    中写出以下函数：
- en: '[PRE1679]'
  id: totrans-8584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1679]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-8585
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了一个自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名
    guest ➌ 和 gift ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-8586
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在函数调用时标记参数，如下所示：
- en: '[PRE1680]'
  id: totrans-8587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1680]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-8588
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里你可以看到，to: 被写在函数调用中的第一个输入值之前，for: 被写在第二个输入值之前。如果一个参数有自定义的参数标签，你在调用函数时必须使用它。如果试图使用参数名，函数会报错：'
- en: '[PRE1681]'
  id: totrans-8589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1681]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-8590
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会自动为你填充参数标签，因此你无需担心错误地调用函数（见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-8591
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-8592
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全函数并添加正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-8593
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于发送感谢信*to*某位客人*for*一份礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")的结构更像一句完整的句子，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-8594
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-8595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-8596
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前添加下划线和空格来移除它们。在下面的例子中，我们编写了一个计算体积的函数，接受盒子的三条边作为输入。由于函数名称已经清楚地表明需要传入三条边，因此其实不需要参数标签，这样代码更简洁。
- en: '[PRE1682]'
  id: totrans-8597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1682]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-8598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处为side1、➋处为side2、➌处为side3添加下划线来移除边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-8599
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，而无需任何标签。
- en: '[PRE1683]'
  id: totrans-8600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1683]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-8601
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。”如果你不仅仅想打印盒子的体积，而是希望将结果存储在一个变量或常量中以便以后使用，那岂不是很有用？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-8602
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-8603
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-8604
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-8605
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能装更多的东西。首先，编写一个返回盒子体积的Int类型的volumeOfBox(_:_:_:)函数：
- en: '[PRE1684]'
  id: totrans-8606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1684]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-8607
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数一个返回值，可以在函数的输入参数后使用短横线和大于号（->）来形成箭头➊，然后输入返回值的数据类型。请注意，你不需要为返回值提供名字，只需要指定数据类型。在函数体内，你可以使用return关键字返回你想要的值➋。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果你在return语句之后编写任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-8608
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-8609
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的盒子调用函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-8610
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-8611
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，volumeOfBox(_:_:_:)函数计算一个边长为6、5和3的盒子的体积，返回值90被存储在名为volumeOfBox1的常量中。在➋，边长为8、4和2的volumeOfBox2的值为64。现在，让我们打印一条消息，说明哪个盒子更大：
- en: '[PRE1685]'
  id: totrans-8612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1685]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-8613
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台中看到字符串“Box 1 is the bigger box.”。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-8614
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-8615
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，接收一个测试成绩数组，并返回平均成绩。为了得到平均值，你需要将所有成绩相加，然后除以成绩的总数。请在你的playground中输入以下代码：
- en: '[PRE1686]'
  id: totrans-8616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1686]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-8617
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在➊处，我们定义了一个名为sum的Int变量，并将其初始值设置为0。在➋处的for-in循环遍历成绩数组中的每个值，并将其加到sum变量中。当循环完成时，变量sum保存了所有成绩的总和。计算完总和后，剩下的就是将其除以成绩的总数，简单来说就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-8618
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空怎么办？你不能将数字除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除以零错误并崩溃程序。因此，在做除法时，始终确保你要除的数不是零，这就是我们在➌处通过检查scores.count
    > 0来处理的。然后在➍处，我们通过将成绩的总和除以数组中成绩的个数来返回平均值，使用return sum / scores.count。没错！你可以返回任何计算出正确数据类型的表达式，这意味着我们可以跳过将计算出来的平均值赋值给新变量的步骤，直接返回sum
    / scores.count，因为它的结果是一个Int类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-8619
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们也需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在if语句中添加一个else来处理这种情况，这样它就会返回0
    ➎。你可以通过在一个成绩数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-8620
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-8621
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给averageOf()函数时，正如我们在➊处所做的，函数会返回成绩的平均值，并在结果面板中显示。如果你传入一个空数组，正如我们在➋处所做的，返回值将是0。
- en: '**NOTE**'
  id: totrans-8622
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-8623
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句其实并不是必需的。因为如果scores.count > 0，函数已经在return sum / scores.count处结束了。所以如果计算机已经通过了那个if语句，我们知道scores.count
    > 0一定不为真，实际上我们可以直接返回0，而不必把它放在else语句中。然而，如果我们保留else语句，代码会更清晰，更容易理解。有时候，为了让其他人更容易理解，写一些额外的代码比使用巧妙的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-8624
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-8625
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-8626
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你可以创建类型与 Swift 中已包含的类型不同的常量和变量，这在你创建应用时非常有用！
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  id: totrans-8627
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用这个函数看看它是如何工作的。尝试将一个客人的 rsvped 值设置为 true，另一个客人的设置为 false，这样你就能看到两个消息的效果。
- en: '[PRE1687]'
  id: totrans-8628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1687]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-8629
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-8630
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全会通过为你提供参数标签来帮助你填写输入值。你只需传入你想使用的值。输入完客人姓名后，按 TAB 键，Xcode 会将光标移动到你需要填写下一个输入值的位置。（参见[图
    7-5](text00017.html#ch07fig5)。）
- en: '![Image](Image00160.jpg)'
  id: totrans-8631
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-8632
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入客人姓名后按 TAB 键会将光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-8633
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-8634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-8635
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，你并没有在输入值前加上参数标签？你写的是：
- en: '[PRE1688]'
  id: totrans-8636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1688]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-8637
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你将得到一个错误：
- en: '[PRE1689]'
  id: totrans-8638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1689]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-8639
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你写一个函数时，每个参数都会有一个参数标签，并且标签名会与参数名相同。然而，如果你写了一个函数，并且觉得参数标签对于使代码更清晰并不是必需的，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，显而易见你传入的是一个将要被打印的字符串。如果每次调用 print(_:) 都必须包含像 inputString 这样的参数标签，那会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-8640
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为每个参数创建一个不同于参数名的参数标签。你可以通过输入参数标签、参数名、冒号，最后是参数的数据类型来实现。当你在 func 关键字后首次声明参数时，你会这样做。这通常在
    Swift 函数中完成，以使函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-8641
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-8642
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-8643
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用函数时会变成
    sayHello(friend:)，这听起来不太像一句完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-8644
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写带有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-8645
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-8646
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，展示如何添加自定义参数标签可以使你的代码更具可读性。在你的生日派对后，你会想要向所有的客人发送感谢信。请在你的 Playground
    中编写以下函数：
- en: '[PRE1690]'
  id: totrans-8647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1690]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-8648
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传入函数的`guest`参数添加了自定义参数标签`to`。同样，在➋处，我们为`gift`参数添加了参数标签`for`。参数名称`guest`
    ➌ 和 `gift` ➍ 用于函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-8649
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签`to`和`for`用于在函数调用时标记参数，像这样：
- en: '[PRE1691]'
  id: totrans-8650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1691]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-8651
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，在函数调用中，to: 写在第一个输入值前，for: 写在第二个输入值前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。如果尝试使用参数名称，编译器会报错：'
- en: '[PRE1692]'
  id: totrans-8652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1692]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-8653
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填充参数标签，所以你不必担心函数调用出错（见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-8654
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-8655
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动完成带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-8656
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常用介词如 *to*、*from* 或 *with* 作为参数标签。在这个例子中，函数用来向一个客人发送感谢信，*to* 是“发送给”，*for*
    是“因……”。代码`sendThankYou(to: "Meghan", for: "puzzle books")`读起来更像一句话，而不是`sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-8657
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-8658
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**去除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-8659
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加下划线和空格来去除它们。在下面的示例中，我们写了一个计算体积的函数，输入的是盒子的三个边。由于函数名已经明确表示需要传入三个边，所以实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1693]'
  id: totrans-8660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1693]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-8661
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`side1`前面加上下划线（➊）、`side2`前面加上下划线（➋）、`side3`前面加上下划线（➌）来去除边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-8662
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE1694]'
  id: totrans-8663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1694]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-8664
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。”如果你能将结果存储在变量或常量中，而不仅仅是打印盒子的体积，这不是更有用吗？让我们看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-8665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-8666
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-8667
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-8668
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，返回一个表示盒子体积的 Int：
- en: '[PRE1695]'
  id: totrans-8669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1695]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-8670
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数指定返回值，在函数的输入参数后使用一个短横线和一个大于符号来形成一个箭头(->)，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，使用return关键字后跟你想返回的值来返回该值➋。如果你编写一个返回值的函数，那么你*必须*在函数内返回该值，否则会发生错误。函数在返回值后结束。如果你在return语句之后写任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-8671
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-8672
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-8673
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-8674
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，volumeOfBox(_:_:_:) 函数计算了一个边长为6、5和3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋，边长为8、4和2的盒子被赋值为64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1696]'
  id: totrans-8675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1696]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-8676
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串"Box 1 is the bigger box."的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-8677
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-8678
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据条件返回不同的值。让我们编写一个函数，它接受一个测试分数的数组并返回平均分数。为了获得平均值，你需要将分数加在一起，然后除以分数的总数。在你的playground中输入以下代码：
- en: '[PRE1697]'
  id: totrans-8679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1697]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-8680
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在➊，我们定义了一个名为sum的Int变量，并将其初始化为0。在➋的for-in循环中，它遍历了scores数组中的每个值，并将其添加到sum变量中。当循环完成后，sum变量保存了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数，简单来说，就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-8681
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空呢？你不能除以零——无论是在数学课上，还是在Swift中。在Swift中，尝试除以零会给出一个除零错误并导致程序崩溃。因此，在进行除法时，一定要确保你要除的数不是零，这就是我们在➌通过检查scores.count
    > 0来确保的。在➍，我们通过将总分除以数组中的分数数量来返回平均值，使用return sum / scores.count。没错！你可以返回任何求值为正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋给新变量的步骤，直接返回sum
    / scores.count，因为它求值为一个Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-8682
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 scores.count 不大于零时返回一个值，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加一个 else
    来处理这个问题，返回 0 ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-8683
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-8684
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整个测试分数数组传入 averageOf() 函数时，就像我们在 ➊ 所做的那样，返回的是分数的平均值，并显示在结果面板中。如果你传入一个空数组，就像我们在
    ➋ 所做的那样，返回值是 0。
- en: '**NOTE**'
  id: totrans-8685
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-8686
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句实际上不是必须的。这是因为如果 scores.count > 0，函数会在 return sum
    / scores.count 时已经结束。所以如果计算机已经执行到这个 if 语句之后，我们可以知道 scores.count > 0 一定不成立，那时我们完全可以简单写一个
    return 0，而无需再放在 else 语句中。然而，如果我们保留 else 语句，代码会更加清晰，易于理解。有时候，写一点额外的代码，让代码更清晰易懂，比使用复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-8687
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-8688
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-8689
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第8章](text00018.html#ch08) 中，我们将展示如何通过编写类定义来创建自定义对象。这样，你就可以创建类型不同于 Swift 中已有类型的常量和变量，这在你创建应用时会非常有用！
- en: '[PRE1698]'
  id: totrans-8690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1698]'
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-8691
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个有多个输入参数的函数，类似于调用一个只有一个输入参数的函数。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-8692
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能将帮助你填写输入值，提供参数标签。你只需要传入你想使用的值。填写完嘉宾姓名后，按下 TAB 键，Xcode 会将光标移至下一个输入框，方便你继续填写下一个输入值。（参见
    [图 7-5](text00017.html#ch07fig5) 。）
- en: '![Image](Image00160.jpg)'
  id: totrans-8693
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-8694
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入嘉宾姓名后按 TAB 键将把光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-8695
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，如姓名或数字，将会报错。
- en: '**ARGUMENT LABELS**'
  id: totrans-8696
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-8697
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到当你调用 print(_:) 时，你并没有在输入值前加上参数标签？你写的是：
- en: '[PRE1699]'
  id: totrans-8698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1699]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-8699
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，将会报错：
- en: '[PRE1700]'
  id: totrans-8700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1700]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-8701
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且该标签与参数名称相同。然而，如果你编写函数时觉得没有必要为参数添加标签来使代码更清晰，那么你可以在函数定义中显式省略它。例如，在
    print(_:) 函数中，显然你传入的输入是一个将被打印的字符串。如果每次调用 print(_:) 时都必须包含像 inputString 这样的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-8702
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个不同于参数名称的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。所有这些都在你首次声明函数括号中的参数时完成，位于
    func 关键字后面。这通常在 Swift 函数中使用，以使函数调用看起来更像一个完整的句子。[图 7-6](text00017.html#ch07fig6)
    说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-8703
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-8704
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-8705
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是“Colin”。如果没有单独的参数标签，当你调用该函数时，它将变成
    sayHello(friend:)，这听起来不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-8706
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何编写带有自定义参数标签的函数。我们还会向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-8707
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-8708
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例，了解如何通过添加自定义参数标签来使代码更具可读性。假设在你举办完生日派对后，你想给所有客人写感谢信。在你的 playground 中编写以下函数：
- en: '[PRE1701]'
  id: totrans-8709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1701]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-8710
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了一个自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名称
    guest ➌ 和 gift ➍ 被用来引用函数内的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-8711
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用来在调用函数时标记参数，像这样：
- en: '[PRE1702]'
  id: totrans-8712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1702]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-8713
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 在函数调用中写在第一个输入值之前，for: 则写在第二个输入值之前。如果某个参数有自定义的参数标签，在函数调用时你必须使用它。试图使用参数名称代替会导致错误：'
- en: '[PRE1703]'
  id: totrans-8714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1703]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-8715
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能将始终为你填充参数标签，因此你不必担心错误地调用函数（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-8716
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-8717
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全函数并显示正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-8718
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用来向一位客人发送感谢信*to*（给）客人*for*（因）一个礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")看起来更像一个句子，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-8719
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-8720
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-8721
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线和一个空格来删除它们。在下面的例子中，我们编写了一个计算体积的函数，该函数以盒子的三个边作为输入。由于函数名已经明确说明需要传入三个边，因此不需要参数标签来提高代码的可读性。
- en: '[PRE1704]'
  id: totrans-8722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1704]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-8723
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊位置的side1、➋位置的side2和➌位置的side3前面放置下划线，移除了这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-8724
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值而不带任何标签。
- en: '[PRE1705]'
  id: totrans-8725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1705]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-8726
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“The volume of this box is 72.”（这个盒子的体积是72）。如果你能够将结果存储在变量或常量中以便稍后使用，而不仅仅是打印出盒子的体积，这岂不是更有用吗？让我们来看看如何通过返回值做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-8727
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-8728
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-8729
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的盒子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-8730
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪一个能装更多的东西。首先，编写一个volumeOfBox(_:_:_:)函数，它返回一个Int类型的盒子体积：
- en: '[PRE1706]'
  id: totrans-8731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1706]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-8732
  prefs: []
  type: TYPE_NORMAL
  zh: 要为一个函数设置返回值，可以在函数的输入参数后使用短横线和大于号形成箭头（->），然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，你通过使用return关键字返回你想返回的值➋。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果你在return语句之后编写任何代码，它将被忽略，因为return语句会导致函数退出。
- en: '![Image](Image00164.jpg)'
  id: totrans-8733
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-8734
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数来处理两个不同的盒子，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-8735
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-8736
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，volumeOfBox(_:_:_:)函数计算了一个长、宽和高分别为6、5、3的盒子的体积，返回值90被存储在名为volumeOfBox1的常量中。在➋，边长为8、4、2的volumeOfBox2的值为64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1707]'
  id: totrans-8737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1707]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-8738
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台中看到字符串“Box 1 is the bigger box.”（盒子1是更大的盒子）。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-8739
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-8740
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，接受一个测试成绩的数组并返回平均成绩。为了得到平均值，你需要将成绩加起来，然后除以成绩的总数。请在你的
    playground 中输入以下代码：
- en: '[PRE1708]'
  id: totrans-8741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1708]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-8742
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 变量，并将其初始化为 0 。在 ➋ 处的 for-in 循环遍历 scores
    数组中的每个值，并将其加到 sum 变量中。当循环完成后，变量 sum 保存了所有成绩的总和。计算完总和后，剩下的就是将其除以成绩的总数，这就是 scores.count
    。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-8743
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空怎么办？你不能将数字除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致“除零错误”并崩溃你的程序。因此，在进行除法时，务必确保你要除的数字不是零，这就是我们通过检查
    scores.count > 0 来做到的，见 ➌ 。在 ➍ 处，我们通过将成绩总和除以数组中成绩的数量来返回平均值，即 return sum / scores.count
    。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 sum / scores.count
    ，因为它的结果是 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-8744
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们也需要返回一些东西，否则会出现缺少返回值的错误。我们通过在 if 语句中添加 else 来处理这一点，返回
    0 ➎ 。你可以通过调用函数来测试代码，传入一个成绩数组和一个空数组：
- en: '![](Image00166.jpg)'
  id: totrans-8745
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-8746
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传入 averageOf() 函数时，正如我们在 ➊ 处所做的，成绩的平均值会被返回并显示在结果面板中。如果你传入一个空数组，正如我们在
    ➋ 处所做的，返回值是 0 。
- en: '**NOTE**'
  id: totrans-8747
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-8748
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实不是必需的。因为如果 scores.count > 0 ，那么函数会在 return sum
    / scores.count 时已经结束。所以如果计算机已经越过了那个 if 语句，我们就知道 scores.count > 0 一定不为真，我们可以直接返回
    0 而不需要将其包含在 else 中。然而，如果我们保留 else 语句，代码会更清晰、更容易理解。有时候，为了让其他人更容易理解，写一些额外的代码比使用巧妙的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-8749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-8750
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做各种令人惊奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-8751
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建除 Swift 中已包含的类型以外的常量和变量，这在创建应用时会非常有用！
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  id: totrans-8752
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用一个具有多个输入参数的函数与调用一个只有一个输入参数的函数类似。
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-8753
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会帮助你填写输入值，为你提供参数标签。你只需传入你想使用的值。填写完客人姓名后，按 TAB 键，Xcode 会将光标移到你需要的位置，方便你填写下一个输入值。（参见[图
    7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-8754
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-8755
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：在输入完客人姓名后按 TAB 键会将光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-8756
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如姓名或数字，你将会得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-8757
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-8758
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，并没有在输入值前加上参数标签？你写的是：
- en: '[PRE1709]'
  id: totrans-8759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1709]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-8760
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你会得到一个错误：
- en: '[PRE1710]'
  id: totrans-8761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1710]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-8762
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数参数在调用时有参数标签，有些没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，且标签与参数名相同。然而，如果你编写一个函数并认为参数标签并不必要来使代码更清晰，那么你可以在函数定义中显式地省略它。例如，在
    print(_:) 函数中，很明显你传入的输入是一个字符串，并且会被打印出来。每次调用 print(_:) 都要包含像 inputString 这样的参数标签会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-8763
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你通过输入参数标签、参数名、冒号，最后是参数的数据类型来实现这一点。所有这些都是在你第一次声明函数括号中的参数时进行的。这通常是在
    Swift 函数中进行的，以使函数调用看起来更像一个完整的句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-8764
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-8765
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-8766
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用该函数时会变成
    sayHello(friend:)，这听起来就不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-8767
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将探讨如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-8768
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-8769
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，如何通过添加自定义的参数标签来让代码更具可读性。在你的生日派对结束后，你会想给所有的客人发送感谢信。在 Playground 中编写如下函数：
- en: '[PRE1711]'
  id: totrans-8770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1711]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-8771
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊ 处，我们为传递给函数的 guest 参数添加了自定义的参数标签 to；同样在➋ 处，我们为 gift 参数添加了参数标签 for。参数名 guest
    ➌ 和 gift ➍ 用于函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-8772
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，如下所示：
- en: '[PRE1712]'
  id: totrans-8773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1712]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-8774
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到，to: 写在函数调用的第一个输入值前，for: 写在第二个输入值前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。如果尝试使用参数名，系统会报错：'
- en: '[PRE1713]'
  id: totrans-8775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1713]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-8776
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填写参数标签，因此你不需要担心函数调用不正确（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-8777
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-8778
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-8779
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人 *发送* 感谢信，*感谢* 礼物。代码
    sendThankYou(to: "Meghan", for: "puzzle books") 更像一句话，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-8780
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-8781
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**去除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-8782
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前添加下划线和一个空格来去除它们。在以下例子中，我们编写了一个计算体积的函数，接受盒子的三个边作为输入。由于函数名已经明确表示需要传入三个边，因此你不需要参数标签来提高代码的可读性。
- en: '[PRE1714]'
  id: totrans-8783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1714]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-8784
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊ 处为 side1、➋ 处为 side2、➌ 处为 side3 添加下划线，去掉了这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-8785
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，你只需输入参数值而无需任何标签。
- en: '[PRE1715]'
  id: totrans-8786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1715]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-8787
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出 "这个盒子的体积是 72"。如果你能将结果存储在变量或常量中以便后续使用，而不仅仅是打印盒子的体积，那会很有用吧？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-8788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-8789
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-8790
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-8791
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装下更多的东西。首先，编写一个名为 volumeOfBox(_:_:_:) 的函数，返回盒子的体积（Int 类型）：
- en: '[PRE1716]'
  id: totrans-8792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1716]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-8793
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数一个返回值，可以在函数的输入参数之后使用一个破折号和一个大于号（->）来表示箭头，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需指定数据类型。在函数体内，你通过使用return关键字并跟上要返回的值来返回该值➋。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值之后结束。如果你在return语句后编写任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-8794
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-8795
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数在两个不同的盒子上查看其效果：
- en: '![](Image00165.jpg)'
  id: totrans-8796
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-8797
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算了边长为6、5和3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋处，边长为8、4和2的volumeOfBox2的值被设置为64。现在让我们打印出哪个盒子更大的消息：
- en: '[PRE1717]'
  id: totrans-8798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1717]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-8799
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台中看到输出字符串"Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-8800
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-8801
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接受一个考试成绩数组，并返回平均分。为了得到平均分，你将成绩加在一起，然后除以总成绩的数量。在你的playground中输入以下代码：
- en: '[PRE1718]'
  id: totrans-8802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1718]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-8803
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在➊处，我们定义了一个名为sum的Int类型变量，并将其初始值设置为0。➋处的for-in循环遍历scores数组中的每个值，并将其加到sum变量中。当循环完成时，变量sum保存了所有分数的总和。计算总和之后，剩下的就是将其除以分数的总数，即scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-8804
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空怎么办？你不能除以零——在数学课上不行，在Swift中也不行。在Swift中，尝试除以零会导致“除以零”错误并崩溃程序。因此，在做除法时，一定要确保你要除的数字不是零，这正是我们在➌处通过检查scores.count
    > 0来实现的。在➍处，我们通过将所有分数的总和除以数组中分数的数量来返回平均值，使用return sum / scores.count。没错！你可以返回任何评估为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值分配给新变量的步骤，直接返回sum
    / scores.count，因为它会被评估为一个Int类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-8805
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们也需要返回某些内容，否则会报错，提示函数缺少返回值。我们通过在if语句中添加一个else来处理这个问题，返回0➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-8806
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-8807
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整个测试成绩数组传入 averageOf() 函数时，如我们在 ➊ 所示，函数会返回成绩的平均值并显示在结果面板中。如果你传入一个空数组，如我们在
    ➋ 所示，返回值将是 0。
- en: '**NOTE**'
  id: totrans-8808
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-8809
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不是必须的。这是因为如果 scores.count > 0 ，那么函数已经会通过 return
    sum / scores.count 结束了。所以如果计算机已经执行到那个 if 语句之后，我们知道 scores.count > 0 一定不为真，直接返回
    0 就行了，不需要再加上 else。不过，如果保留 else 语句，代码会更清晰、更易懂。有时候，为了让别人更容易理解，写一些额外的代码比用复杂的捷径更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-8810
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-8811
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做各种了不起的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-8812
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08) 中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建类型不同于 Swift
    中已包含的常量和变量，这在你创建应用程序时会非常有用！
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  id: totrans-8813
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会帮助你填写输入值，并为你提供参数标签。你只需要传入你想使用的值。输入完宾客姓名后，按 TAB 键，Xcode 会把光标移到你需要的位置，方便你填写下一个输入值。（见
    [图 7-5](text00017.html#ch07fig5)）
- en: '![Image](Image00160.jpg)'
  id: totrans-8814
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-8815
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入宾客姓名后按 TAB 键将光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-8816
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，你将会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-8817
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-8818
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，你没有在输入值前加上参数标签？你写的是：
- en: '[PRE1719]'
  id: totrans-8819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1719]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-8820
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试加上标签，你将会遇到错误：
- en: '[PRE1720]'
  id: totrans-8821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1720]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-8822
  prefs: []
  type: TYPE_NORMAL
  zh: 某些参数在函数调用中有参数标签，而有些没有。默认情况下，当你写一个函数时，每个参数都会有一个参数标签，并且它将与参数名称相同。然而，如果你写一个函数，认为参数标签对代码的清晰度并不必要，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，传入的输入显然是一个要打印的字符串。如果每次调用 print(_:) 时都必须加上像 inputString 这样的参数标签，那就很麻烦了。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-8823
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建与参数名不同的参数标签。你可以通过输入参数标签、参数名、冒号以及参数的数据类型来做到这一点。所有这些操作都在函数声明中的圆括号内进行，在
    `func` 关键字之后。这在 Swift 函数中很常见，目的是让函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-8824
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-8825
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：`sayHello()` 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-8826
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 friend，参数标签是 `to`，而函数调用中的传入参数是 "Colin"。如果没有单独的参数标签，调用该函数时将会变成
    `sayHello(friend:)`，这听起来不如一个完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-8827
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何编写带有自定义参数标签的函数。我们还会展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-8828
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-8829
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，了解如何通过添加自定义参数标签来提高代码的可读性。假设在你的生日派对后，你需要给所有的宾客发送感谢信。在你的 Playground
    中写下以下函数：
- en: '[PRE1721]'
  id: totrans-8830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1721]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-8831
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传入函数的 guest 参数添加了一个自定义参数标签 `to`。类似地，在➋处，我们为 gift 参数添加了一个参数标签 `for`。参数名
    guest ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-8832
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 `to` 和 `for` 用于在函数调用时标记参数，如下所示：
- en: '[PRE1722]'
  id: totrans-8833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1722]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-8834
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到，`to:` 被写在函数调用的第一个输入值之前，而 `for:` 则写在第二个输入值之前。如果一个参数有自定义的参数标签，在函数调用时必须使用该标签。尝试使用参数名而不是标签将导致错误：
- en: '[PRE1723]'
  id: totrans-8835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1723]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-8836
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填写参数标签，因此你无需担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-8837
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-8838
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-8839
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用介词如 *to*、*from* 或 *with* 作为参数标签。在这个例子中，函数用来给某个宾客发送感谢信 *to* 一位宾客 *for*
    一份礼物。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 比 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")` 更像一句完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-8840
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-8841
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-8842
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加上下划线和空格来移除它们。在下面的示例中，我们编写了一个计算体积的函数，接受盒子的三条边作为输入。由于函数名已经清楚表明你需要传入三条边，因此你实际上不需要参数标签来使代码更具可读性。
- en: '[PRE1724]'
  id: totrans-8843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1724]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-8844
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在侧面1的位置➊、侧面2的位置➋ 和侧面3的位置➌ 前面加上下划线来移除参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-8845
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需要输入参数值，而不需要任何标签。
- en: '[PRE1725]'
  id: totrans-8846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1725]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-8847
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。"。如果你不仅仅打印盒子的体积，而是将结果存储到一个变量或常量中以便以后使用，这样会不会更有用呢？让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-8848
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-8849
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将 volumeOfBoxWithSides(_:_:_:) 函数重写为返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-8850
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-8851
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个可以装更多的东西。首先，写一个 volumeOfBox(_:_:_:) 函数，返回盒子的体积（整数）：
- en: '[PRE1726]'
  id: totrans-8852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1726]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-8853
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数添加返回值，在函数的输入参数后面使用一个短横线和一个大于号形成箭头（->），然后输入返回值的数据类型 ➊。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你可以使用
    return 关键字并跟上你想返回的值 ➋。如果你写了一个返回值的函数，那么你*必须*在函数内返回这个值，否则会报错。函数在返回值后结束。如果在 return
    语句后面再写任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-8854
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-8855
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它的效果：
- en: '![](Image00165.jpg)'
  id: totrans-8856
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-8857
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，volumeOfBox(_:_:_:) 函数计算了一个边长分别为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在➋，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1727]'
  id: totrans-8858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1727]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-8859
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台中看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-8860
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-8861
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，接受一个测试成绩数组并返回平均成绩。为了得到平均值，你需要将所有成绩相加，然后除以总的成绩数。请在你的
    playground 中输入以下代码：
- en: '[PRE1728]'
  id: totrans-8862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1728]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-8863
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在➊处，我们定义了一个名为sum的Int变量，并将其初始化为0。➋处的for-in循环遍历scores数组中的每个值，并将其加到sum变量中。当循环完成时，变量sum保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，简单来说就是`scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-8864
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果数组为空呢？你不能除以零——无论是在数学课上，还是在Swift中。在Swift中，尝试除以零会导致除零错误，并使程序崩溃。因此，在进行除法时，始终确保你要除的数不为零，这就是我们在➌处通过检查`score.count
    > 0`来实现的。在➍处，我们通过将分数总和除以数组中的分数数量来返回平均值，使用`return sum / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回`sum
    / scores.count`，因为它计算出的结果是一个Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-8865
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`score.count`不大于零时，我们还需要返回一些东西，否则会出现函数缺少返回值的错误。我们通过在if语句中添加else来处理这个问题，返回0
    ➎。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-8866
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-8867
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给`averageOf()`函数时，正如我们在➊处所做的，返回值是分数的平均值，并显示在结果面板中。如果你传入一个空数组，如我们在➋处所做的，返回值是0。
- en: '**NOTE**'
  id: totrans-8868
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-8869
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕`return 0`的else语句实际上并不是必需的。因为如果`score.count > 0`，函数已经通过`return sum
    / scores.count`结束了。所以，如果计算机已经越过了那个if语句，那么我们知道`score.count > 0`一定不成立，我们本可以直接返回`0`而不需要放在else中。然而，如果我们保留else语句，代码会更清晰、更易于理解。有时，写一些额外的代码来使其他人更容易理解比使用巧妙的捷径更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-8870
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-8871
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种了不起的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-8872
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建类型不同于Swift默认类型的常量和变量，这在你创建应用程序时会非常有用！
- en: '![Image](Image00160.jpg)'
  id: totrans-8873
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00160.jpg)'
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-8874
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：在输入完访客名字后按TAB键，会将光标移到下一个输入框。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-8875
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他内容，比如名字或数字，你将会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-8876
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-8877
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用 print(_:) 时，前面没有加上参数标签吗？你写的是：
- en: '[PRE1729]'
  id: totrans-8878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1729]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-8879
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加标签，你会遇到一个错误：
- en: '[PRE1730]'
  id: totrans-8880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1730]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-8881
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且这个标签与参数名称相同。然而，如果你编写了一个函数，认为没有必要使用参数标签来使代码更清晰，那么你可以在函数定义中显式地省略它。例如，在
    print(_:) 函数中，很明显你传入的是一个将要打印的字符串。如果每次调用 print(_:) 时都必须包括像 inputString 这样的参数标签，那会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-8882
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来做到这一点。所有这些都在函数声明时，在 func
    关键字后面的参数圆括号内完成。这通常在 Swift 函数中使用，使得函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-8883
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-8884
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-8885
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，传递给函数调用的参数是 "Colin"。如果没有单独的参数标签，当你调用该函数时，它看起来会像
    sayHello(friend:)，这听起来不像是一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-8886
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何编写带有自定义参数标签的函数。我们还将展示如何编写一个函数，在其中完全省略参数标签。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-8887
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-8888
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，说明如何通过添加自定义参数标签使代码更具可读性。在你的生日派对之后，你会想要给所有的客人写感谢信。在你的 playground 中写以下函数：
- en: '[PRE1731]'
  id: totrans-8889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1731]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-8890
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了一个自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名称
    guest ➌ 和 gift ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-8891
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，如下所示：
- en: '[PRE1732]'
  id: totrans-8892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1732]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-8893
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到，在第一个输入值之前写了to:，在第二个输入值之前写了for:。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名代替它将导致错误：
- en: '[PRE1733]'
  id: totrans-8894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1733]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-8895
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全会始终为你填写参数标签，因此你不必担心错误地调用函数（见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-8896
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-8897
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动完成函数并使用正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-8898
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信，*to*表示收件人，*for*表示感谢的原因。代码sendThankYou(to:
    "Meghan", for: "puzzle books")读起来更像一句话，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-8899
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-8900
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-8901
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加一个下划线和一个空格来去除它们。在下面的示例中，我们写了一个计算体积的函数，该函数接受一个盒子的三条边作为输入。由于函数名已经明确表明你需要传入三条边，因此实际上你不需要使用参数标签来增加代码的可读性。
- en: '[PRE1734]'
  id: totrans-8902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1734]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-8903
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在side1前面添加一个下划线在➊、在side2前面添加一个下划线在➋、在side3前面添加一个下划线在➌来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-8904
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，你只需输入参数值，而无需任何标签。
- en: '[PRE1735]'
  id: totrans-8905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1735]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-8906
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。”。如果你可以将结果存储在一个变量或常量中以便以后使用，而不是仅仅打印盒子的体积，那会不会更有用呢？让我们来看看如何使用返回值做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-8907
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-8908
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，改为返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-8909
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-8910
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个能容纳更多的东西。首先，编写一个返回盒子体积的Int类型的volumeOfBox(_:_:_:)函数：
- en: '[PRE1736]'
  id: totrans-8911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1736]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-8912
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数提供返回值，在函数的输入参数之后➊使用一个破折号和大于号（->）形成箭头，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要一个数据类型。在函数体内，你可以使用return关键字并跟上你要返回的值来返回该值➋。如果你写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在你返回值后结束。如果在返回语句之后在函数内部写了任何代码，它将被忽略，因为return语句会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-8913
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-8914
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-8915
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-8916
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个边长分别为 6、5 和 3 的箱体体积，返回值 90 被存储在一个名为 `volumeOfBox1`
    的常量中。➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在让我们打印一条关于哪个箱体更大的消息：
- en: '[PRE1737]'
  id: totrans-8917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1737]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-8918
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-8919
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-8920
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接受一个测试成绩的数组，并返回平均成绩。为了计算平均值，你需要将所有分数加起来，然后除以总分数的数量。在你的
    playground 中输入以下代码：
- en: '[PRE1738]'
  id: totrans-8921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1738]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-8922
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 Int 类型变量，并将其初始值设为 0。➋ 处的 `for-in` 循环会遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量保存了所有成绩的总和。计算出总和后，剩下的就是将总和除以总成绩数量，简单来说就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-8923
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组是空的呢？你不能用零去除一个数——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致“除零错误”，并使程序崩溃。因此，在进行除法操作时，一定要确保你要除的数不是零，这就是我们在
    ➌ 处检查 `scores.count > 0` 的原因。在 ➍ 处，我们通过将分数的总和除以数组中分数的数量来返回平均值，使用 `return sum /
    scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 `sum /
    scores.count`，因为它会计算为一个 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-8924
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 `scores.count` 不大于零时返回某个值，否则会出现函数缺少返回值的错误。我们通过在 `if` 语句后添加 `else`
    来处理这个问题，返回 0 ➎ 。你可以通过在一个包含成绩的数组和一个空数组上调用函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-8925
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-8926
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试成绩数组传入 `averageOf()` 函数时，正如我们在 ➊ 处所做的，返回的将是成绩的平均值，并显示在结果窗格中。如果传入一个空数组，正如我们在
    ➋ 处所做的，返回值将是 0。
- en: '**NOTE**'
  id: totrans-8927
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-8928
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不是必需的。因为如果 scores.count > 0 ，那么函数会已经通过 return
    sum / scores.count 结束。所以如果程序执行到了那个 if 语句后，我们就知道 scores.count > 0 一定不成立，那么我们完全可以直接使用
    return 0，而不需要把它包裹在 else 语句中。不过，如果我们保留 else 语句，代码会更清晰，容易理解。有时候，写一些额外的代码让其他人更容易理解，比使用复杂的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-8929
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-8930
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-8931
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08) 中，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你能够创建除 Swift 中已经包含的类型之外的常量和变量，在你创建应用时非常有用！
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  id: totrans-8932
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：输入客人姓名后按 TAB 键，光标将跳到下一个输入字段。*'
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-8933
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还会告诉你 rsvped 的数据类型。将占位符文本 Bool 替换为 true 或 false。如果你尝试传入其他任何东西，比如名字或数字，你会得到一个错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-8934
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-8935
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，当你调用 print(_:) 时，你并没有在输入值前面加上参数标签？你只写：
- en: '[PRE1739]'
  id: totrans-8936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1739]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-8937
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试加上标签，你会得到一个错误：
- en: '[PRE1740]'
  id: totrans-8938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1740]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-8939
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用中，有些参数有参数标签，而有些则没有。默认情况下，当你写一个函数时，每个参数都会有一个参数标签，并且它会与参数名相同。然而，如果你写一个函数，并且觉得参数标签对于代码的清晰性没有必要，那么你可以在函数定义中显式地省略它。例如，在
    print(_:) 函数中，传入的输入显然是一个将要打印的字符串。如果每次调用 print(_:) 时都必须包含像 inputString 这样的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-8940
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名不同的参数标签。你通过在函数的括号内的参数声明中输入参数标签、参数名、冒号，然后是参数的数据类型来做到这一点。这通常是在
    Swift 函数中进行的，目的是让函数调用看起来更像一句话。[图 7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-8941
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-8942
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-8943
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传递的参数是 "Colin"。如果没有单独的参数标签，函数调用就会变成
    sayHello(friend:)，听起来不像是一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-8944
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-8945
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-8946
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，说明如何通过添加自定义参数标签来提高代码的可读性。假设在你的生日派对之后，你想给所有的客人写感谢信。在你的 playground 中写下以下函数：
- en: '[PRE1741]'
  id: totrans-8947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1741]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-8948
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传递给函数的 guest 参数添加了一个自定义的参数标签，命名为 to。同样，在➋处，我们为 gift 参数添加了一个参数标签，命名为 for。参数名称
    guest ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-8949
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在函数调用时标记参数，像这样：
- en: '[PRE1742]'
  id: totrans-8950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1742]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-8951
  prefs: []
  type: TYPE_NORMAL
  zh: '这里你可以看到，to: 被写在函数调用中第一个输入值之前，而 for: 被写在第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用中使用它。否则，使用参数名称会导致错误：'
- en: '[PRE1743]'
  id: totrans-8952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1743]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-8953
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填充参数标签，因此你无需担心调用函数时出错（参见 [图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-8954
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-8955
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode 自动完成了具有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-8956
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信 *to* 表示感谢的对象，*for*
    表示感谢的原因。代码 sendThankYou(to: "Meghan", for: "拼图书") 比 sendThankYou(guest: "Meghan",
    gift: "拼图书") 更像一个完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-8957
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-8958
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-8959
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加一个下划线和空格来移除它们。在以下示例中，我们编写了一个计算体积的函数，输入为盒子的三个边。因为函数名已经明确说明需要传入三个边，所以实际上不需要参数标签来使代码更具可读性。
- en: '[PRE1744]'
  id: totrans-8960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1744]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-8961
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处为 side1，➋处为 side2，和 ➌处为 side3 前面加下划线，来移除侧边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-8962
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值而不加标签。
- en: '[PRE1745]'
  id: totrans-8963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1745]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-8964
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是72。" 如果你不只是打印盒子的体积，而是希望将结果存储在一个变量或常量中以便以后使用，那会不会更有用呢？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-8965
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-8966
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-8967
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-8968
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能装更多的东西。首先，编写一个 `volumeOfBox(_:_:_:)` 函数，它返回盒子的体积（Int 类型）：
- en: '[PRE1746]'
  id: totrans-8969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1746]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-8970
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数添加返回值，在函数的输入参数后面使用一个破折号和一个大于号来形成箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值命名，只需指定数据类型。在函数体内，你可以使用
    `return` 关键字返回你想返回的值 ➋。如果你写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值后结束。如果你在 `return`
    语句后面写了任何代码，它将被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-8971
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-8972
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的盒子调用该函数，查看它的实际效果：
- en: '![](Image00165.jpg)'
  id: totrans-8973
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-8974
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个边长分别为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 `volumeOfBox1`
    的常量中。➋ 处，边长分别为 8、4 和 2 的 `volumeOfBox2` 盒子的值为 64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1747]'
  id: totrans-8975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1747]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-8976
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-8977
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-8978
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，它接收一个测试分数的数组，并返回平均分。为了计算平均分，你需要将所有分数加在一起，然后除以分数的总数量。在你的游乐场中输入以下代码：
- en: '[PRE1748]'
  id: totrans-8979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1748]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-8980
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 Int 类型变量，并将其初始值设置为 0。➋ 处的 `for-in` 循环会遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量保存了所有分数的总和。计算完总和后，剩下的就是将其除以总分数数量，即
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-8981
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空怎么办呢？你不能用零来做除法——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会给你一个除以零的错误并导致程序崩溃。因此，在做除法时，务必确保你要除的数字不是零，这也是我们在➌检查scores.count
    > 0时所做的。在➍，我们通过将总分除以数组中成绩的数量来返回平均值，使用return sum / scores.count。没错！你可以返回任何评估为正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋给新变量的步骤，直接返回sum
    / scores.count，因为它会被评估为Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-8982
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们还需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在if语句中添加else来处理这个问题，这样就能返回0
    ➎。你可以通过调用函数，传入一个成绩数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-8983
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-8984
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的成绩数组传入averageOf()函数时，正如我们在➊所做的，返回的就是这些成绩的平均值，并会显示在结果面板中。如果你传入一个空数组，正如我们在➋所做的，返回值则是0。
- en: '**NOTE**'
  id: totrans-8985
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-8986
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0周围的else语句其实并不是必需的。这是因为如果scores.count > 0，那么函数已经通过return sum
    / scores.count结束了。所以如果计算机已经跳过了那个if语句，那么我们就知道scores.count > 0一定不为真，我们完全可以直接使用return
    0，而不需要将其放在else语句中。然而，如果我们保留else语句，代码会更清晰、更易于理解。有时为了让别人更容易理解代码，写一点多余的代码比用巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-8987
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的知识**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-8988
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，能够做很多令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-8989
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建具有不同于Swift中已有类型的常量和变量，在你开发应用时非常实用！
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  id: totrans-8990
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会告诉你rsvped的数据类型。将占位符文本Bool替换为true或false。如果你尝试传入其他内容，比如名字或数字，你会遇到错误。
- en: '**ARGUMENT LABELS**'
  id: totrans-8991
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-8992
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用print(_:)时，输入值前面没有参数标签？你只需要写：
- en: '[PRE1749]'
  id: totrans-8993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1749]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-8994
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含一个标签，你会遇到一个错误：
- en: '[PRE1750]'
  id: totrans-8995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1750]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-8996
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而一些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且该标签与参数名称相同。然而，如果你编写的函数认为参数标签对于代码的清晰度不是必需的，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，传入的内容显然是一个将被打印的字符串。每次调用 print(_:) 都包含像 inputString 这样的参数标签会很烦人。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-8997
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你通过输入参数标签、参数名称、冒号，然后是参数的数据类型来实现这一点。你会在使用 func 关键字声明函数的参数时做这些操作。这通常在
    Swift 函数中完成，以使函数调用看起来更像一个完整的句子。[图 7-6](text00017.html#ch07fig6) 说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-8998
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-8999
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-9000
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，当你调用该函数时，它看起来像
    sayHello(friend:)，这听起来不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-9001
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何编写带有自定义参数标签的函数。我们还会展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-9002
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-9003
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示添加自定义参数标签如何使你的代码更具可读性。在你的生日聚会后，你会想要给所有的客人写感谢信。在你的 Playground 中编写以下函数：
- en: '[PRE1751]'
  id: totrans-9004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1751]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-9005
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了一个自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了参数标签 for。参数名称
    guest ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9006
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在函数调用时标记参数，像这样：
- en: '[PRE1752]'
  id: totrans-9007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1752]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9008
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里你可以看到 to: 写在函数调用中的第一个输入值之前，而 for: 写在第二个输入值之前。如果一个参数有自定义参数标签，你必须在函数调用中使用它。尝试使用参数名称代替将会导致错误：'
- en: '[PRE1753]'
  id: totrans-9009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1753]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9010
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填充参数标签，因此你不必担心错误地调用函数（参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9011
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9012
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9013
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于向一位客人发送感谢信*to*，感谢她赠送的礼物*for*。代码sendThankYou(to:
    "Meghan", for: "puzzle books")看起来更像一句话，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9014
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9015
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9016
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前添加一个下划线和一个空格来移除它们。在下面的示例中，我们编写了一个用于计算体积的函数，该函数接受盒子的三个边作为输入。因为函数名已经明确表示需要传入三个边，所以你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1754]'
  id: totrans-9017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1754]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9018
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处、➋处和➌处为side1、side2和side3前面加上下划线，来移除盒子边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9019
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值而无需任何标签。
- en: '[PRE1755]'
  id: totrans-9020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1755]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9021
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"The volume of this box is 72."。如果你可以将结果存储在一个变量或常量中以便稍后使用，而不仅仅是打印盒子的体积，那岂不是更有用吗？让我们来看看如何通过返回值做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-9022
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9023
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9024
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9025
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能装更多的东西。首先，写一个volumeOfBox(_:_:_:)函数，返回一个Int类型的盒子体积：
- en: '[PRE1756]'
  id: totrans-9026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1756]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9027
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数返回值，在函数的输入参数后面使用一个短横线和大于号（->）来表示箭头➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需指定数据类型。在函数体内，使用return关键字并跟上你要返回的值来返回这个值➋。如果你写了一个返回值的函数，那么你*必须*在函数内部返回这个值，否则会报错。函数在返回值之后结束。如果你在return语句后写了任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9028
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9029
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-9030
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9031
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算一个边长为6、5和3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋处，边长为8、4和2的volumeOfBox2被赋值为64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1757]'
  id: totrans-9032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1757]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9033
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台看到字符串"Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9034
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9035
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们写一个函数，接受一个测试成绩的数组并返回平均成绩。为了获得平均值，你需要将所有成绩相加，然后除以成绩的总数。在你的
    playground 中输入以下代码：
- en: '[PRE1758]'
  id: totrans-9036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1758]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9037
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始值设为 0。在 ➋ 处的 for-in 循环遍历了
    `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环结束时，变量 sum 存储了所有成绩的总和。计算出总和后，剩下的工作就是将其除以成绩的总数，简单来说就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9038
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办？你不能用零去除某个数——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致“除以零”错误并崩溃你的程序。因此，在进行除法运算时，务必确保你要除的数不是零，这就是我们在➌
    处通过检查 scores.count > 0 所做的操作。在 ➍ 处，我们通过将总分除以数组中成绩的个数来返回平均值，使用的是 `return sum /
    scores.count`。没错！你可以返回任何能计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 `sum /
    scores.count`，因为它计算的结果是一个 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9039
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加一个 else
    来处理这个问题，返回 `0` ➎ 。你可以通过将一个包含成绩的数组和一个空数组传入该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9040
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9041
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的成绩数组传入 `averageOf()` 函数时，正如我们在 ➊ 处所做的，函数会返回并显示成绩的平均值。如果传入一个空数组，如我们在
    ➋ 处所做的，返回值就是 0。
- en: '**NOTE**'
  id: totrans-9042
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9043
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 else 语句其实并不是必需的。这是因为如果 `scores.count > 0`，函数会在 `return
    sum / scores.count` 处结束。所以，如果计算机已经通过了那个 if 语句，我们就知道 `scores.count > 0` 肯定不成立，那么我们可以直接写
    `return 0`，而不需要把它放在 else 语句中。然而，如果我们保留 else 语句，代码会更清晰、更容易理解。有时候，写一些额外的代码，使其他人更容易理解，可能比使用一个巧妙的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9044
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9045
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，能够完成各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9046
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将允许你创建类型不同于 Swift 中已包含的类型的常量和变量，这在你创建应用程序时非常有用！
- en: '**ARGUMENT LABELS**'
  id: totrans-9047
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**参数标签**'
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-9048
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调用 `print(_:)` 时，不会在输入值前添加参数标签吗？你会写：
- en: '[PRE1759]'
  id: totrans-9049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1759]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-9050
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加标签，就会出现错误：
- en: '[PRE1760]'
  id: totrans-9051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1760]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-9052
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用时带有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它与参数名称相同。然而，如果你编写函数时觉得参数标签对代码的清晰性没有必要，那么你可以在函数定义中显式地省略它。例如，在
    `print(_:)` 函数中，传入的参数显然是一个字符串，将会被打印出来。每次调用 `print(_:)` 都包含像 `inputString` 这样的参数标签会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-9053
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个不同于参数名称的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来做到这一点。这一切都在你第一次声明函数括号内的参数时完成，即在
    `func` 关键字之后。Swift 函数中通常会这样做，使函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)
    展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-9054
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-9055
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-9056
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 `friend`，参数标签是 `to`，函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，当你调用函数时，它会像
    `sayHello(friend:)`，听起来就不像一句完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-9057
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写带有自定义参数标签的函数。我们还会展示如何编写一个函数，其中完全省略参数标签。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-9058
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-9059
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例，说明如何通过添加自定义的参数标签使代码更具可读性。在你的生日聚会之后，你可能想给所有的宾客发送感谢卡。在你的 playground 中编写以下函数：
- en: '[PRE1761]'
  id: totrans-9060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1761]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-9061
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入的 `guest` 参数添加了一个自定义参数标签 `to`。类似地，在 ➋ 处，我们为 `gift` 参数添加了一个参数标签 `for`。参数名称
    `guest` ➌ 和 `gift` ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9062
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 `to` 和 `for` 用于标记函数调用时的参数，如下所示：
- en: '[PRE1762]'
  id: totrans-9063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1762]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9064
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `to:` 写在第一个输入值前，`for:` 写在第二个输入值前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。否则，尝试使用参数名称会导致错误：
- en: '[PRE1763]'
  id: totrans-9065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1763]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9066
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能将始终为你填写参数标签，所以你不必担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9067
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9068
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9069
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个示例中，函数用于向一个客人发送感谢信 *to*（感谢）*for*（礼物）一个礼物。代码
    `sendThankYou(to: "Meghan", for: "puzzle books")` 比 `sendThankYou(guest: "Meghan",
    gift: "puzzle books")` 更像一个句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9070
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9071
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9072
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线和空格来移除它们。在下面的示例中，我们编写一个用于计算体积的函数，它接受一个盒子的三个边作为输入。因为函数名已经明确表示你需要传入三个边，所以你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1764]'
  id: totrans-9073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1764]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9074
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 side1 前 ➊、side2 前 ➋ 和 side3 前 ➌ 添加下划线来移除边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9075
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，你只需要输入参数值，而不需要任何标签。
- en: '[PRE1765]'
  id: totrans-9076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1765]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9077
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 “这个盒子的体积是 72。”。如果你能把体积的结果存储到一个变量或常量中，以便稍后使用，而不仅仅是打印它，会不是更有用吗？让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9078
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9079
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，改为返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9080
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9081
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能装更多东西。首先，编写一个返回盒子体积的 `volumeOfBox(_:_:_:)` 函数，该函数返回一个整数值：
- en: '[PRE1766]'
  id: totrans-9082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1766]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9083
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数添加返回值，使用破折号和大于号组成一个箭头（->），紧跟在函数的输入参数之后 ➊，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需提供数据类型即可。在函数体内，你通过使用
    `return` 关键字并跟上你想返回的值 ➋ 来返回该值。如果你编写一个返回值的函数，那么你*必须*在函数内返回该值，否则会出现错误。函数在返回值后结束。如果你在返回语句后编写任何代码，它将被忽略，因为
    `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9084
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9085
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数处理两个不同的盒子，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-9086
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9087
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，volumeOfBox(_:_:_:)函数计算一个边长为6、5和3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋，边长为8、4和2的volumeOfBox2被赋值为64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1767]'
  id: totrans-9088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1767]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9089
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串"Box 1 is the bigger box."的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9090
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9091
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，它接受一个测试成绩的数组并返回平均分。为了得到平均值，你需要将所有成绩加在一起，然后除以成绩的总数。在你的Playground中输入以下代码：
- en: '[PRE1768]'
  id: totrans-9092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1768]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9093
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在➊，我们定义了一个名为sum的Int类型变量，并将其初始值设为0。➋处的for-in循环遍历scores数组中的每个值，并将其加到sum变量中。当循环完成时，sum变量保存了所有成绩的总和。计算完总和后，剩下的就是将其除以成绩的总数，这就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9094
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能用零去除——无论是在数学课上，还是在Swift中。在Swift中，试图除以零会给你一个除以零的错误并使程序崩溃。因此，在进行除法运算时，务必确保你要除的数不是零，这就是我们在➌通过检查scores.count
    > 0来做到的。在➍时，我们通过用return sum / scores.count来返回平均值，这是通过将所有成绩的总和除以数组中成绩的个数来实现的。没错！你可以返回任何能够计算出正确数据类型的表达式，这意味着我们可以跳过将计算出来的平均值赋值给新变量的步骤，直接返回sum
    / scores.count，因为它计算出的结果是一个Int类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9095
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们还需要返回一个值，否则会报错提示函数缺少返回值。我们通过在if语句中添加else来处理这一点，返回0
    ➎。你可以通过在一个包含成绩的数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9096
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9097
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试成绩数组传递给averageOf()函数时，如我们在➊所做的那样，返回值为成绩的平均值并显示在结果面板中。如果你传入一个空数组，如我们在➋所做的那样，返回值为0。
- en: '**NOTE**'
  id: totrans-9098
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9099
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句实际上并不是必须的。这是因为如果 scores.count > 0，那么函数已经通过 return
    sum / scores.count 结束了。所以如果程序已经通过了那个 if 语句，那么我们知道 scores.count > 0 一定不成立，直接使用
    return 0 而不需要包裹在 else 中也可以。然而，如果保留 else 语句，代码会更清晰、更容易理解。有时候，写一些额外的代码让其他人更容易理解，比使用复杂的捷径更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9101
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做很多令人惊奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9102
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建不同于 Swift 中已有类型的常量和变量，当你开发应用时非常有用！
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  id: totrans-9103
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当你调用 print(_:) 时，输入值前面没有参数标签？你写的是：
- en: '[PRE1769]'
  id: totrans-9104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1769]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-9105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加一个标签，你将得到一个错误：
- en: '[PRE1770]'
  id: totrans-9106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1770]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-9107
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，且标签与参数名称相同。然而，如果你编写的函数中，参数标签并不是必需的以便使代码更清晰，那么你可以在函数定义中显式省略它。例如，在
    print(_:) 函数中，传入的输入显然是一个将被打印的字符串。如果每次调用 print(_:) 都必须包含类似 inputString 的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-9108
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号和参数的数据类型来实现。所有这些都在你第一次声明函数参数时，在
    func 关键字后的括号内进行。这在 Swift 函数中很常见，以使函数调用看起来更像一个句子。[图 7-6](text00017.html#ch07fig6)
    说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-9109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-9110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-9111
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，而在函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用函数时看起来会像
    sayHello(friend:)，这听起来不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-9112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将介绍如何编写带有自定义参数标签的函数。我们还将展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-9113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-9114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示如何通过添加自定义参数标签来提高代码的可读性。在你的生日派对之后，你会想给所有的客人写感谢信。请在你的playground中编写如下函数：
- en: '[PRE1771]'
  id: totrans-9115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1771]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-9116
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传入函数的guest参数添加了一个自定义的参数标签to。同样，在➋处，我们为gift参数添加了一个参数标签for。参数名称guest ➌和gift
    ➍用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9117
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for用于在调用函数时标记参数，如下所示：
- en: '[PRE1772]'
  id: totrans-9118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1772]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到，to:被写在函数调用中第一个输入值之前，for:则写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。如果你试图使用参数名称来代替它，会出现错误：
- en: '[PRE1773]'
  id: totrans-9120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1773]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9121
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能会为你填充参数标签，因此你不必担心错误地调用函数（请参见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9122
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动补全了正确的参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9124
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用介词如*to*、*from*或*with*作为参数标签。在这个例子中，函数用于向客人发送感谢信*to*，感谢他们的礼物*for*。代码sendThankYou(to:
    "Meghan", for: "puzzle books")比sendThankYou(guest: "Meghan", gift: "puzzle books")更像一句话。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加下划线和空格来删除它们。在以下示例中，我们编写了一个计算体积的函数，该函数接受盒子的三条边作为输入。由于函数名称已经明确表明需要传入三条边，所以你不需要参数标签来提高代码的可读性。
- en: '[PRE1774]'
  id: totrans-9128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1774]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处、➋处和➌处分别在side1、side2和side3前面加下划线，去掉了这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需要输入参数值而无需任何标签。
- en: '[PRE1775]'
  id: totrans-9131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1775]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“The volume of this box is 72.”。如果你不仅仅打印出盒子的体积，而是能够将结果存储在变量或常量中以便后续使用，那岂不是很有用吗？让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多东西。首先，编写一个volumeOfBox(_:_:_:)函数，返回盒子的体积（Int）：
- en: '[PRE1776]'
  id: totrans-9137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1776]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9138
  prefs: []
  type: TYPE_NORMAL
  zh: 要为一个函数指定返回值，在函数输入参数后面用一个破折号和大于号（->）组成箭头，然后写出返回值的数据类型 ➊。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你可以使用
    return 关键字返回你想要返回的值 ➋。如果你写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果在 return
    语句之后再写任何代码，它都会被忽略，因为 return 会导致函数结束。
- en: '![Image](Image00164.jpg)'
  id: totrans-9139
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9140
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个函数并传入两个不同的盒子，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-9141
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算一个边长分别为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 的值为 64。现在让我们打印一条消息，说明哪个盒子更大：
- en: '[PRE1777]'
  id: totrans-9143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1777]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9144
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。我们来写一个函数，接受一个测试分数的数组并返回平均分。要得到平均值，你需要将所有分数加在一起，然后除以分数的总数。在你的
    playground 中输入以下代码：
- en: '[PRE1778]'
  id: totrans-9147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1778]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始值设置为 0。 ➋ 处的 for-in 循环会遍历
    scores 数组中的每个值，并将它加到 sum 变量中。当循环结束时，sum 变量保存了所有分数的总和。计算出总和后，剩下的工作就是将它除以分数的总数，这个值就是
    scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9149
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空怎么办呢？你不能将一个数除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并使程序崩溃。因此，在进行除法时，一定要确保你要除的数不是零，这就是我们在
    ➌ 处通过检查 scores.count > 0 来做到的。在 ➍ 处，我们通过将分数的总和除以数组中分数的个数来返回平均值，使用的是 return sum
    / scores.count。没错！你可以返回任何计算结果符合正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 sum
    / scores.count，因为它会计算出一个 Int 类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们也需要返回一个值，否则会出现缺少返回值的错误。我们通过在 if 语句中添加 else 来处理这个问题，返回
    0 ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9151
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给averageOf()函数时，如➊所示，返回的平均值将显示在结果面板中。如果你传入一个空数组，如➋所示，返回值将是0。
- en: '**NOTE**'
  id: totrans-9153
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9154
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，包围return 0的else语句其实并非必需。这是因为如果scores.count > 0，那么函数会在return sum / scores.count时已经结束。所以，如果计算机已经通过了那个if语句，我们就知道scores.count
    > 0一定不为真，这时我们只需使用return 0，而不必放在else语句里。然而，如果我们保留else语句，代码会更清晰、更容易理解。有时，为了让别人更容易理解代码，写一点额外的代码比使用一些巧妙的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9156
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以实现各种令人惊叹的功能！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9157
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建与Swift中已包含类型不同的常量和变量，这在你创建应用程序时会非常有用！
- en: '[PRE1779]'
  id: totrans-9158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1779]'
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-9159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，会出现错误：
- en: '[PRE1780]'
  id: totrans-9160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1780]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-9161
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，有些则没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，而且它与参数名称相同。然而，如果你编写了一个函数，并且觉得参数标签对代码的清晰度没有必要，你可以在函数定义中显式省略它。例如，在print(_:)函数中，传入的输入显然是一个将要打印的字符串。如果每次调用print(_:)时都必须包含像inputString这样的参数标签，那将很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-9162
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来完成这一操作。当你在`func`关键字后首次声明函数参数时，就会进行这些操作。Swift函数中通常会这样做，以使函数调用看起来更像一句完整的句子。[图7-6](text00017.html#ch07fig6)展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-9163
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-9164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：sayHello()函数具有自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-9165
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:)函数的输入参数是friend，参数标签是to，函数调用时传入的参数是"Colin"。如果没有单独的参数标签，调用该函数时就会像sayHello(friend:)，听起来不像完整的一句话。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-9166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何编写具有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-9167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-9168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，展示添加自定义参数标签如何使你的代码更具可读性。在你举办完生日派对后，你肯定想给所有客人送感谢卡。请在你的 Playground 中编写以下函数：
- en: '[PRE1781]'
  id: totrans-9169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1781]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-9170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了参数标签 for。参数名 guest
    ➌ 和 gift ➍ 被用来引用函数内部的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9171
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于标记函数调用时的参数，像这样：
- en: '[PRE1782]'
  id: totrans-9172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1782]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9173
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 被写在第一个输入值之前，for: 被写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。否则，使用参数名会导致错误：'
- en: '[PRE1783]'
  id: totrans-9174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1783]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9175
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会自动为你填充参数标签，因此你不必担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9176
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9177
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全函数并正确添加参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9178
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向一位客人 *发送* 感谢信，感谢他/她的
    *礼物*。代码 sendThankYou(to: "Meghan", for: "puzzle books") 读起来更像一个句子，而不是 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9179
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前加上一个下划线和空格来去除它们。在下面的示例中，我们编写了一个用于计算体积的函数，该函数接受一个盒子的三条边作为输入。由于函数名称已经清楚地表明你需要传入三条边，因此实际上不需要参数标签来增加代码的可读性。
- en: '[PRE1784]'
  id: totrans-9182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1784]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处为 side1 前加下划线，在 ➋ 处为 side2 前加下划线，以及在 ➌ 处为 side3 前加下划线，从而移除了对边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需要输入参数值，而不需要任何标签。
- en: '[PRE1785]'
  id: totrans-9185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1785]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。" 如果你能把结果存储到变量或常量中以便稍后使用，而不仅仅是打印盒子的体积，那该多好呢？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个可以装更多的东西。首先，编写一个`volumeOfBox(_:_:_:)`函数，返回盒子的体积（Int类型）：
- en: '[PRE1786]'
  id: totrans-9191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1786]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9192
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数指定返回值，在函数的输入参数之后使用一个短横线和一个大于号（->）来构成箭头，并接着写返回值的数据类型。在此需要注意的是，返回值不需要名字，只需指定数据类型。在函数体内，你通过使用`return`关键字加上你想返回的值来返回该值➋。如果你写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值之后结束。如果你在返回语句之后写了任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9193
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9194
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的盒子调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-9195
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9196
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，`volumeOfBox(_:_:_:)`函数计算了一个长、宽和高分别为6、5、3的盒子的体积，返回值90被保存在一个名为volumeOfBox1的常量中。在➋，具有长、宽和高分别为8、4、2的`volumeOfBox2`被赋值为64。现在，让我们打印一个关于哪个盒子更大的消息：
- en: '[PRE1787]'
  id: totrans-9197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1787]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9198
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串“Box 1 is the bigger box.”输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据某个条件返回不同的值。让我们编写一个函数，它接受一个测试分数的数组并返回平均分。为了得到平均分，你需要将所有分数相加，然后除以总分数。请在你的Playground中输入以下代码：
- en: '[PRE1788]'
  id: totrans-9201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1788]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在➊，我们定义了一个名为sum的Int类型变量，并将其初始值设为0。➋处的for-in循环会遍历scores数组中的每个值，并将其加到sum变量中。当循环完成后，变量sum就保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数量，这就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9203
  prefs: []
  type: TYPE_NORMAL
  zh: 可是，如果数组为空呢？你不能将某个数除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除零错误，并使程序崩溃。因此，在进行除法运算时，一定要确保你要除的数不是零，这就是我们在➌处通过检查scores.count
    > 0来做的。到达➍时，我们通过将分数的总和除以数组中的分数数量来返回平均值，使用的是`return sum / scores.count`。没错！你可以返回任何能够计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回`sum
    / scores.count`，因为它会计算出一个Int类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们也需要返回某些内容，否则会报错，提示函数缺少返回值。我们通过在if语句中添加else来处理这个问题，返回0
    ➎。你可以通过在一个包含分数的数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9205
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9206
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试分数数组传递给averageOf()函数时，正如我们在➊处所做的那样，分数的平均值会被返回并显示在结果窗格中。如果你传入一个空数组，正如我们在➋处所做的那样，返回值是0。
- en: '**NOTE**'
  id: totrans-9207
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9208
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕返回0的else语句实际上并不必要。这是因为如果scores.count > 0，函数将已经通过return sum / scores.count结束。所以，如果计算机已经通过了那个if语句，那么我们就知道scores.count
    > 0一定不成立，我们可以直接返回0，而不需要将它放在else语句中。然而，如果我们保留else语句，代码会更清晰，更容易理解。有时候，写一点额外的代码让其他人更容易理解，比使用巧妙的捷径更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9210
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用于完成各种了不起的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9211
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建除Swift中已包含的类型之外的常量和变量，这在你创建应用程序时会非常有用！
- en: 'And if you try to include a label, you’ll get an error:'
  id: totrans-9212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试包含标签，系统会报错：
- en: '[PRE1789]'
  id: totrans-9213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1789]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-9214
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用中有参数标签，而有些没有。默认情况下，当你编写函数时，每个参数都会有一个参数标签，并且这个标签与参数名称相同。然而，如果你编写一个函数，觉得参数标签不必要以使代码更清晰，那么你可以在函数定义中明确省略它。例如，在print(_:)函数中，很明显你传入的输入是一个字符串，它将被打印。每次调用print(_:)时都要包含像inputString这样的参数标签会显得很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-9215
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来做到这一点。你在首次声明函数括号内的参数时，就需要完成所有这些操作。这在Swift函数中很常见，目的是让函数调用看起来更像一句完整的句子。[图7-6](text00017.html#ch07fig6)说明了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-9216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-9217
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：sayHello()函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-9218
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:)函数的输入参数是friend，参数标签是to，函数调用中传入的参数是“Colin”。如果没有单独的参数标签，调用这个函数时将是sayHello(friend:)，这听起来不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-9219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何编写带有自定义参数标签的函数。我们还会展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-9220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-9221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，展示添加自定义参数标签如何使代码更具可读性。在你的生日派对后，你会想要给所有的来宾发送感谢信。请在你的playground中编写以下函数：
- en: '[PRE1790]'
  id: totrans-9222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1790]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-9223
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传递给函数的guest参数添加了自定义的参数标签to。类似地，在➋处，我们为gift参数添加了参数标签for。参数名称guest ➌和gift
    ➍在函数内部用来引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9224
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for用于在函数调用时标记参数，像这样：
- en: '[PRE1791]'
  id: totrans-9225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1791]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到to:被写在函数调用的第一个输入值前，for:被写在第二个输入值前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试用参数名称代替会导致错误：
- en: '[PRE1792]'
  id: totrans-9227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1792]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9228
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会始终为你填充参数标签，所以你不必担心错误地调用函数（参见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9229
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9230
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9231
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于向来宾*发送*感谢信*以感谢*他们的礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")比起sendThankYou(guest: "Meghan", gift: "puzzle books")更像一个完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9232
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加下划线和空格来移除它们。在下面的例子中，我们编写了一个计算体积的函数，它接受一个盒子的三个边作为输入。因为函数名已经清楚地表明需要传入三个边，你实际上不需要参数标签来使代码更具可读性。
- en: '[PRE1793]'
  id: totrans-9235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1793]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在side1前添加下划线➊，在side2前添加下划线➋，在side3前添加下划线➌，来移除参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，你只需要输入参数值，而不需要任何标签。
- en: '[PRE1794]'
  id: totrans-9238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1794]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。”如果你能够将结果存储在变量或常量中，以便以后使用，而不仅仅是打印盒子的体积，那岂不是很有用？让我们来看看如何通过返回值做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-9240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9243
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，编写一个`volumeOfBox(_:_:_:)`函数，返回盒子的体积（Int类型）：
- en: '[PRE1795]'
  id: totrans-9244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1795]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让一个函数有返回值，在函数的输入参数之后使用一个箭头（->）符号 ➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，使用`return`关键字后跟你想返回的值
    ➋ 。如果你编写的函数有返回值，那么你*必须*在函数内部返回该值，否则会报错。函数在你返回值后结束。如果你在`return`语句之后编写任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9246
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9247
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用函数，查看其运行效果：
- en: '![](Image00165.jpg)'
  id: totrans-9248
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)`函数计算了一个边长为6、5和3的盒子的体积，返回值90被存储在名为`volumeOfBox1`的常量中。在
    ➋ 处，边长为8、4和2的`volumeOfBox2`被赋值为64。现在让我们打印出哪个盒子更大的信息：
- en: '[PRE1796]'
  id: totrans-9250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1796]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9251
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，它接收一个测试分数的数组，并返回平均分数。要计算平均分数，你需要将所有分数加起来，然后除以分数的总数量。在你的Playground中输入以下代码：
- en: '[PRE1797]'
  id: totrans-9254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1797]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为`sum`的Int变量，并将其初始化为0。➋ 处的for-in循环遍历`score`数组中的每个值，并将其加到`sum`变量中。当循环完成时，`sum`变量存储了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数量，也就是`scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9256
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办？你不能把一个数除以零——在数学课上或是在 Swift 中都是如此。在 Swift 中，尝试除以零会导致除以零的错误并且崩溃你的程序。因此，在进行除法时，始终确保你要除的数字不为零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来实现的。在 ➍ 处，我们通过用 `return sum / scores.count` 将分数总和除以数组中的分数个数来返回平均值。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算得到的平均值赋给新变量的步骤，直接返回
    `sum / scores.count`，因为它会计算出一个 `Int` 类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们还需要返回某些东西，否则会出现函数缺少返回值的错误。我们通过在 `if` 语句中添加 `else`
    来处理这个问题，返回 `0` ➎。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9258
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9259
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 `averageOf()` 函数时，就像我们在 ➊ 处所做的那样，分数的平均值会被返回并显示在结果面板中。如果你传入一个空数组，就像我们在
    ➋ 处所做的那样，返回值将是 `0`。
- en: '**NOTE**'
  id: totrans-9260
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9261
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 `else` 语句其实不是必需的。这是因为，如果 `scores.count > 0` 为真，函数已经会在
    `return sum / scores.count` 处结束。所以，如果程序已经越过了那个 `if` 语句，那么我们知道 `scores.count >
    0` 一定不为真，我们可以直接用 `return 0`，而不需要将其放入 `else` 语句中。然而，如果我们保留 `else` 语句，代码会更清晰，更容易理解。有时候，写一些额外的代码来让别人更容易理解比使用一些巧妙的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9263
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中广泛应用，用于完成各种令人惊叹的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9264
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将允许你创建类型不同于 Swift 已包含的类型的常量和变量，这在你创建应用时会非常有用！
- en: '[PRE1798]'
  id: totrans-9265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1798]'
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-9266
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数在函数调用中有参数标签，而有些则没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，并且它与参数名相同。然而，如果你编写一个函数并且觉得参数标签对代码的清晰度没有帮助，那么你可以在函数定义中明确省略它。例如，在
    `print(_:)` 函数中，传入的输入显然是一个将要打印的字符串。每次调用 `print(_:)` 时都要求你包括像 `inputString` 这样的参数标签会让人觉得很烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-9267
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号以及参数的数据类型来实现这一点。这一切都是在你首次声明函数中的参数时，在func关键字后面进行的。在Swift函数中，这通常是为了让函数调用看起来更像一句完整的句子。[图7-6](text00017.html#ch07fig6)展示了参数标签和参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-9268
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-9269
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：sayHello()函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-9270
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:)函数的输入参数是friend，参数标签是to，函数调用中传递的参数是"Colin"。如果没有单独的参数标签，函数调用会像这样：sayHello(friend:)，这听起来不像是完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-9271
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们将学习如何编写带有自定义参数标签的函数。我们还将展示如何编写一个省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-9272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-9273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，看看如何通过添加自定义参数标签来使代码更加易读。在你的生日派对之后，你肯定想要给所有宾客发送感谢信。在你的Playground中写下以下函数：
- en: '[PRE1799]'
  id: totrans-9274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1799]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-9275
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传递给函数的guest参数添加了一个自定义参数标签to。类似地，在➋处，我们为gift参数添加了一个参数标签for。参数名称guest ➌和gift
    ➍用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9276
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被调用时，参数标签to和for用于标记传入的参数，像这样：
- en: '[PRE1800]'
  id: totrans-9277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1800]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到to:写在第一个输入值前面，for:写在第二个输入值前面。如果一个参数有自定义参数标签，你必须在函数调用中使用它。如果试图使用参数名称代替，将会出现错误：
- en: '[PRE1801]'
  id: totrans-9279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1801]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9280
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会始终为你填写参数标签，因此你不必担心错误地调用函数（参见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9281
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9282
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode 自动完成函数并附加正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9283
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于发送一张感谢信*给*一位宾客*为了*感谢礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")的结构更像一句完整的句子，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9284
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前添加一个下划线和一个空格来移除它们。在以下示例中，我们编写了一个计算体积的函数，该函数将一个盒子的三个边长作为输入。因为函数名称已经清楚地表明你需要传入三个边长，所以你实际上不需要参数标签来使代码更具可读性。
- en: '[PRE1802]'
  id: totrans-9287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1802]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处将side1前面加上下划线，在➋处将side2前面加上下划线，在➌处将side3前面加上下划线，来移除参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需要输入参数值，不需要任何标签。
- en: '[PRE1803]'
  id: totrans-9290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1803]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "The volume of this box is 72."。如果你能将盒子的体积存储在一个变量或常量中以便以后使用，而不仅仅是打印它，岂不是更有用吗？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9295
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，编写一个返回盒子体积的`volumeOfBox(_:_:_:)`函数：
- en: '[PRE1804]'
  id: totrans-9296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1804]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9297
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数添加返回值，在函数的输入参数后面使用一个破折号和一个大于号（->）来形成箭头，然后输入返回值的数据类型➊。请注意，返回值不需要提供名称，只需提供数据类型。在函数体内，通过使用`return`关键字，后跟要返回的值来返回该值➋。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果在返回语句之后写任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9298
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9299
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它的实际效果：
- en: '![](Image00165.jpg)'
  id: totrans-9300
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9301
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`volumeOfBox(_:_:_:)`函数计算了一个边长为6、5和3的盒子的体积，返回值90被存储在一个名为`volumeOfBox1`的常量中。在➋处，边长为8、4和2的`volumeOfBox2`的值为64。现在让我们打印一个关于哪个盒子更大的消息：
- en: '[PRE1805]'
  id: totrans-9302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1805]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9303
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串 "Box 1 is the bigger box." 被输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9305
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个接受测试分数数组并返回平均分的函数。为了计算平均分，你需要将所有分数相加，然后除以分数的总数。在你的Playground中输入以下代码：
- en: '[PRE1806]'
  id: totrans-9306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1806]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9307
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有数值的总和。在➊处，我们定义了一个名为sum的Int变量，并将其初始值设为0。➋处的for-in循环遍历成绩数组中的每个值，并将其加到sum变量中。当循环完成时，变量sum保存了所有成绩的总和。在计算出总和后，我们只需将其除以成绩的总数，这个总数就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9308
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组是空的呢？你不能将某个数除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除零错误并使程序崩溃。因此，在进行除法运算时，务必要确保你要除的数不是零，这也是我们在➌处通过检查scores.count
    > 0来做到的。在➍处，我们通过将成绩总和除以成绩数组中的元素数量来返回平均值，使用的是return sum / scores.count。没错！你可以返回任何能够评估为正确数据类型的表达式，这意味着我们可以跳过将计算出来的平均值赋给新变量的步骤，直接返回sum
    / scores.count，因为它评估为Int类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们还需要返回某个值，否则会出现函数缺少返回值的错误。我们通过在if语句中添加else来处理这一点，在➎处返回0。你可以通过在一个包含成绩的数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9310
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9311
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像在➊处那样将一个完整的测试成绩数组传递给averageOf()函数时，它会返回成绩的平均值并显示在结果面板中。如果你传入一个空数组，就像在➋处那样，返回值是0。
- en: '**NOTE**'
  id: totrans-9312
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9313
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句其实并不是必需的。这是因为如果scores.count > 0，函数会在return sum / scores.count时已经结束。所以，如果计算机已经通过了那个if语句，我们就知道scores.count
    > 0一定为假，这时我们可以直接使用return 0，而不需要将其放在else中。然而，如果我们保留else语句，代码会更加清晰，容易理解。有时候，为了让别人更容易理解，写一些额外的代码比使用一个巧妙的简写更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9315
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9316
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这样，你就可以创建类型不同于Swift内置类型的常量和变量，这在你创建应用程序时非常有用！
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  id: totrans-9317
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数在函数调用时有参数标签，有些没有。默认情况下，当你编写一个函数时，每个参数都会有一个参数标签，且该标签与参数名称相同。然而，如果你编写函数时，觉得参数标签并不必要来使代码更清晰，那么你可以在函数定义中明确省略它。例如，在
    print(_:) 函数中，传入的内容显然是一个字符串，会被打印出来。如果每次调用 print(_:) 时都必须包含一个像 inputString 这样的参数标签，那会很麻烦。
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-9318
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现。所有这些操作都在你首次声明函数括号内的参数时完成。这通常在
    Swift 函数中使用，以使函数调用看起来更像一个完整的句子。[图 7-6](text00017.html#ch07fig6) 展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-9319
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-9320
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-9321
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，函数调用时传入的参数是 "Colin"。如果没有单独的参数标签，当你调用这个函数时，它将是
    sayHello(friend:)，这听起来不像一个完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-9322
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们将探讨如何编写带有自定义参数标签的函数。我们还将展示如何编写一个函数，省略参数标签。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-9323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-9324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个如何添加自定义参数标签的示例，这可以让你的代码更具可读性。在你的生日派对后，你可能想要向所有的客人发送感谢信。请在 Playground
    中编写以下函数：
- en: '[PRE1807]'
  id: totrans-9325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1807]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-9326
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了自定义参数标签 to。同样，在 ➋ 处，我们为 gift 参数添加了参数标签 for。参数名称 guest
    ➌ 和 gift ➍ 用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9327
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，像这样：
- en: '[PRE1808]'
  id: totrans-9328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1808]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9329
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里你可以看到，to: 被写在函数调用的第一个输入值之前，for: 被写在第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名称代替会导致错误：'
- en: '[PRE1809]'
  id: totrans-9330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1809]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9331
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填写参数标签，因此你不必担心错误地调用函数（请参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9332
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9333
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成一个具有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9334
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于向客人*表示感谢*，感谢他们赠送的*礼物*。代码sendThankYou(to:
    "Meghan", for: "puzzle books")的表达更像一个句子，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9335
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前加上下划线和一个空格来移除它们。在以下示例中，我们写了一个计算体积的函数，接受箱子的三个边长作为输入。因为函数名已经明确指出你需要传入三个边长，所以实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1810]'
  id: totrans-9338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1810]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处将side1前面加上下划线，➋处将side2前面加上下划线，➌处将side3前面加上下划线来移除侧面参数的标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而不带标签。
- en: '[PRE1811]'
  id: totrans-9341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1811]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9342
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"The volume of this box is 72."。如果你能将计算出的体积存储在一个变量或常量中，以便以后使用，而不是仅仅打印出来，这不是更有用吗？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个箱子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9346
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的箱子，并想知道哪个箱子能装更多的东西。首先，写一个返回箱子体积的volumeOfBox(_:_:_:)函数，返回一个Int类型的值：
- en: '[PRE1812]'
  id: totrans-9347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1812]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9348
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数添加返回值，在函数的输入参数后面使用一个破折号和大于号（->）来形成一个箭头➊，然后输入返回值的数据类型。注意，你不需要为返回值指定名称，只需指定数据类型。在函数体内，使用return关键字后跟你想要返回的值来返回该值➋。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在你返回值后结束。如果你在返回语句后编写任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9349
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9350
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个函数并传入两个不同的箱子，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-9351
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9352
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算了边长为6、5和3的箱子的体积，返回值90被存储在名为volumeOfBox1的常量中。在➋处，边长为8、4和2的volumeOfBox2被赋值为64。现在，让我们打印一条关于哪个箱子更大的消息：
- en: '[PRE1813]'
  id: totrans-9353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1813]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9354
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串"Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9356
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会希望根据条件返回不同的值。让我们编写一个函数，它接收一个测试成绩数组并返回平均成绩。为了获得平均值，你需要将所有成绩加在一起，然后除以成绩的总数。在你的playground中输入以下代码：
- en: '[PRE1814]'
  id: totrans-9357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1814]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9358
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在➊处，我们定义了一个名为sum的Int类型变量，并将其初始值设为0。在➋处的for-in循环会遍历scores数组中的每一个值，并将其加到sum变量上。当循环完成时，sum变量就保存了所有成绩的总和。计算出总和后，剩下的就是将其除以成绩的总数，也就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9359
  prefs: []
  type: TYPE_NORMAL
  zh: 可是如果数组是空的呢？你不能对零进行除法运算——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致“除零错误”并崩溃程序。因此，在进行除法运算时，始终确保你要除的数不是零，这就是我们通过在➌处检查scores.count
    > 0来做的。然后在➍处，我们通过将成绩的总和除以数组中成绩的数量来返回平均值，使用return sum / scores.count。没错！你可以返回任何计算出正确数据类型的表达式，这意味着我们可以跳过将计算出来的平均值赋给一个新变量的步骤，直接返回sum
    / scores.count，因为它会计算出一个Int类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们也需要返回某个值，否则会报错提示函数缺少返回值。我们通过在if语句中添加else来处理这个问题，返回0➎。你可以通过在一个成绩数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9361
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9362
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试成绩数组传递给averageOf()函数时，正如我们在➊处所做的那样，函数会返回这些成绩的平均值并显示在结果窗格中。如果传入一个空数组，正如我们在➋处所做的那样，返回值将是0。
- en: '**NOTE**'
  id: totrans-9363
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9364
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句其实并非绝对必要。这是因为如果scores.count > 0，那么函数已经会通过return sum
    / scores.count提前结束。所以如果程序已经跳过了if语句，那我们就知道scores.count > 0一定为假，我们完全可以直接写return
    0，而不需要将它放在else语句里。然而，如果我们保留else语句，代码会更加清晰和易于理解。有时候，写多一点代码来使别人更容易理解比使用巧妙的快捷方式要更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9366
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中广泛应用，用来完成各种令人惊叹的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9367
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你创建具有除 Swift 中已有类型之外的类型的常量和变量，这在你创建应用时非常有用！
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  id: totrans-9368
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为每个参数创建一个与参数名称不同的参数标签。你可以通过输入参数标签、参数名称、冒号，最后是参数的数据类型来实现这一点。所有这些都在你首次声明函数参数时进行，即在
    func 关键字后面的函数括号内完成。在 Swift 函数中，通常会这样做，以使函数调用看起来更像一句完整的句子。[图 7-6](text00017.html#ch07fig6)
    展示了参数标签与参数之间的区别。
- en: '![Image](Image00161.jpg)'
  id: totrans-9369
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-9370
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：sayHello() 函数有一个自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-9371
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，而在函数调用中传入的参数是 "Colin"。如果没有单独的参数标签，调用函数时看起来会像
    sayHello(friend:)，这听起来不像一句完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-9372
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写带有自定义参数标签的函数。我们还会展示如何编写一个省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-9373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-9374
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，看看如何添加自定义参数标签可以让你的代码更具可读性。在你举办完生日派对后，你会想给所有的客人发送感谢信。在你的 playground
    中编写以下函数：
- en: '[PRE1815]'
  id: totrans-9375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1815]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-9376
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递到函数中的 guest 参数添加了一个自定义参数标签 to。类似地，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名称
    guest ➌ 和 gift ➍ 用于引用函数内部的参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9377
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于标记函数调用时的参数，如下所示：
- en: '[PRE1816]'
  id: totrans-9378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1816]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9379
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里你可以看到，to: 被写在第一个输入值之前，而 for: 被写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名称代替将会报错：'
- en: '[PRE1817]'
  id: totrans-9380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1817]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9381
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能将始终为你填写正确的参数标签，因此你不必担心错误地调用函数（请参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9382
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9383
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成函数并添加正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9384
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信 *to* 礼物 *for*。代码
    sendThankYou(to: "Meghan", for: "puzzle books") 比 sendThankYou(guest: "Meghan",
    gift: "puzzle books") 更像一句完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9385
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前加下划线并后跟一个空格来去除它们。在以下示例中，我们编写了一个用于计算体积的函数，它接受箱子的三个边作为输入。由于函数名称已经明确指出你需要传入三个边，因此你实际上不需要参数标签来使代码更具可读性。
- en: '[PRE1818]'
  id: totrans-9388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1818]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处的side1前面加下划线，在➋处的side2前面加下划线，在➌处的side3前面加下划线，去掉了各边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用该函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE1819]'
  id: totrans-9391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1819]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9392
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个箱子的体积是72。”如果你不仅仅是打印箱子的体积，而是可以将结果存储在变量或常量中以供后续使用，那不是更有用吗？让我们来看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重新编写volumeOfBoxWithSides(_:_:_:)函数，让它返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个箱子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9396
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的箱子，想知道哪个能装更多东西。首先，编写一个volumeOfBox(_:_:_:)函数，它返回箱子的体积（Int类型）：
- en: '[PRE1820]'
  id: totrans-9397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1820]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9398
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数返回值，在函数的输入参数后面添加一个短横线和一个大于号形成箭头（->），然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，你通过使用return关键字后跟你想返回的值来返回该值➋。如果你编写的函数有返回值，那么你*必须*在函数内部返回该值，否则会出现错误。函数在你返回值之后结束。如果在返回语句后面再写任何代码，它将被忽略，因为return语句会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9399
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9400
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的箱子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-9401
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9402
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算了一个边长为6、5、3的箱子的体积，返回值90被存储在名为volumeOfBox1的常量中。在➋处，边长为8、4、2的箱子volumeOfBox2被赋值为64。现在让我们打印一个消息，告诉我们哪个箱子更大：
- en: '[PRE1821]'
  id: totrans-9403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1821]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9404
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串“箱子1是更大的箱子”输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9406
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，它接受一个测试分数数组，并返回平均分数。为了计算平均分数，你将所有分数加起来，然后除以总分数的数量。请在你的
    playground 中输入以下代码：
- en: '[PRE1822]'
  id: totrans-9407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1822]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9408
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要求出所有数值的总和。在➊，我们定义了一个名为sum的Int类型变量，并将其初始值设为0。在➋的for-in循环中，它会遍历scores数组中的每个值，并将其加到sum变量中。当循环完成时，sum变量保存了所有分数的总和。计算出总和后，剩下的就是将它除以分数的总数，这个值就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9409
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能将某个数除以零——无论是在数学课上，还是在Swift中。在Swift中，尝试除以零会导致除零错误，并使程序崩溃。因此，在进行除法运算时，始终要确保你要除的数不是零，这就是我们通过在➌检查scores.count
    > 0来确保的。在➍，我们通过用return sum / scores.count将总分除以分数的数量来返回平均值。没错！你可以返回任何能够计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回sum
    / scores.count，因为它会计算出一个Int类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们还需要返回一些内容，否则会出现函数缺少返回值的错误。我们通过在if语句后添加一个else来处理这个问题，返回0
    ➎。你可以通过调用该函数来测试代码，传入一个包含分数的数组和一个空数组：
- en: '![](Image00166.jpg)'
  id: totrans-9411
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9412
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给averageOf()函数时，就像我们在➊所做的那样，返回值是分数的平均值，并显示在结果面板中。如果传入一个空数组，就像我们在➋所做的那样，返回值是0。
- en: '**NOTE**'
  id: totrans-9413
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9414
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句其实并不是必须的。因为如果scores.count > 0，那么函数已经在return sum /
    scores.count时结束了。所以，如果计算机已经通过了那个if语句，我们就知道scores.count > 0一定不成立，我们可以直接写return
    0，而不必放在else中。然而，如果我们保留else语句，代码会更清晰、更易理解。有时候，写一些额外的代码以使别人更容易理解，比使用复杂的捷径更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9416
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以实现各种惊人的功能！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9417
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让你可以创建除Swift中已有类型以外的常量和变量，这在你创建应用时会非常有用！
- en: '![Image](Image00161.jpg)'
  id: totrans-9418
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00161.jpg)'
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-9419
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：sayHello()函数有一个自定义的参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-9420
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:)函数的输入参数是friend，参数标签是to，函数调用中传入的参数是“Colin”。如果没有单独的参数标签，当你调用该函数时，它将看起来像sayHello(friend:)，这不像一句完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-9421
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写带有自定义参数标签的函数。我们还会向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-9422
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-9423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示如何通过添加自定义参数标签来提高代码的可读性。生日派对结束后，你会想给所有的客人发送感谢信。在你的playground中编写以下函数：
- en: '[PRE1823]'
  id: totrans-9424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1823]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-9425
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传入函数的guest参数添加了一个自定义参数标签to。同样，在➋处，我们为gift参数添加了一个参数标签for。参数名称guest ➌和gift
    ➍用于在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9426
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for用于在调用函数时为参数命名，例如：
- en: '[PRE1824]'
  id: totrans-9427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1824]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9428
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到to:写在函数调用的第一个输入值之前，for:写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。尝试使用参数名称会导致错误：
- en: '[PRE1825]'
  id: totrans-9429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1825]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9430
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全将始终为你填写参数标签，所以你不必担心错误地调用函数（见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9431
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9432
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动补全了一个带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9433
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于将感谢信发送*给*一位客人*以感谢*他们的礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")读起来更像一句完整的句子，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9434
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**删除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线和一个空格来删除它们。在下面的示例中，我们编写了一个用于计算体积的函数，它需要三个盒子的侧面作为输入。因为函数名称已经明确指出需要传入三个侧面，所以其实不需要参数标签来提高代码的可读性。
- en: '[PRE1826]'
  id: totrans-9437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1826]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在侧面1的前面加上一个下划线（➊），侧面2（➋）和侧面3（➌），来去除这些参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值而不需要任何标签。
- en: '[PRE1827]'
  id: totrans-9440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1827]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9441
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“The volume of this box is 72.”。如果你不仅仅打印出盒子的体积，而是能将结果存储在一个变量或常量中以便稍后使用，那岂不是更有用吗？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9443
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，让它返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9445
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个可以装更多的东西。首先，编写一个返回盒子体积的 volumeOfBox(_:_:_:) 函数，返回值类型为 Int：
- en: '[PRE1828]'
  id: totrans-9446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1828]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9447
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数添加返回值，在函数的输入参数后面使用破折号和大于号组成箭头（-> ），然后输入返回值的数据类型 ➊。请注意，你不需要为返回值提供名称，只需指定数据类型即可。在函数体内，通过使用
    return 关键字并跟上你要返回的值来返回该值 ➋。如果你编写了一个返回值的函数，那么你*必须*在函数内返回该值，否则会报错。函数在返回值后结束。如果你在
    return 语句之后写了任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9448
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9449
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-9450
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9451
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1829]'
  id: totrans-9452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1829]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9453
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到字符串 "Box 1 is the bigger box." 输出到你的调试控制台。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9455
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据条件返回不同的值。让我们编写一个函数，接受一个测试分数的数组，并返回平均分。要计算平均分，你需要将所有分数相加，然后除以分数的总数。在你的
    playground 中输入以下代码：
- en: '[PRE1830]'
  id: totrans-9456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1830]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9457
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始值设置为 0。➋ 处的 for-in 循环遍历
    scores 数组中的每个值，并将其加到 sum 变量中。当循环完成后，sum 变量将保存所有分数的总和。计算完总和后，我们只需要将其除以分数的总数，也就是
    scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9458
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能用零去除以某物——在数学课上，或者在 Swift 中也是一样。在 Swift 中，尝试除以零会导致除零错误并崩溃程序。因此，在进行除法时，务必确保你要除的数不是零，这就是我们通过在
    ➌ 处检查 `scores.count > 0` 来做到的。在 ➍ 处，我们通过将分数总和除以数组中分数的数量来返回平均值，使用的是 `return sum
    / scores.count`。没错！你可以返回任何评估为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 `sum
    / scores.count`，因为它会评估为一个 `Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9459
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们还需要返回一个值，否则会报错，提示函数缺少返回值。我们通过在 `if` 语句中添加 `else`
    来处理这一点，返回 0 ➎。你可以通过在一个成绩数组和一个空数组上调用函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9460
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9461
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整个测试成绩数组传递给 `averageOf()` 函数时，就像我们在 ➊ 处所做的那样，函数会返回并显示成绩的平均值。如果你传入一个空数组，像我们在
    ➋ 处做的那样，返回值则是 0。
- en: '**NOTE**'
  id: totrans-9462
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9463
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 `else` 语句其实并不必要。这是因为如果 `scores.count > 0`，那么函数会在 `return
    sum / scores.count` 处已经结束。因此，如果计算机已经通过了那个 `if` 语句，那么我们知道 `scores.count > 0` 一定不为真，我们本可以直接写一个
    `return 0`，而不必将其包含在 `else` 语句中。然而，如果我们保留 `else` 语句，代码会更清晰、更容易理解。有时候，写一点额外的代码让别人更容易理解，比使用一个巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9465
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为自己的 Swift 工具箱添加了一个重要工具——创建和调用自己的函数！函数在编程中被广泛使用，能够完成各种惊人的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9466
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08) 中，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建具有 Swift 中没有的类型的常量和变量，这在你开发应用时会非常有用！
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  id: totrans-9467
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：`sayHello()` 函数具有自定义参数标签。*'
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-9468
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayHello(to:)` 函数的输入参数是 `friend`，参数标签是 `to`，而函数调用中传递的参数是 `"Colin"`。如果没有单独的参数标签，当你调用该函数时，它会看起来像
    `sayHello(friend:)`，这听起来不如一个完整的句子。'
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-9469
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将介绍如何编写具有自定义参数标签的函数。我们还会展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-9470
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-9471
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，展示如何通过添加自定义参数标签使代码更具可读性。假设在你生日聚会后，你想要向所有的客人发送感谢信。请在你的 playground 中编写如下函数：
- en: '[PRE1831]'
  id: totrans-9472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1831]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-9473
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 位置，我们为传递给函数的 guest 参数添加了一个自定义的参数标签 `to`。类似地，在 ➋ 位置，我们为 gift 参数添加了一个参数标签
    `for`。参数名 `guest` ➌ 和 `gift` ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9474
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 `to` 和 `for` 用来在调用函数时标记参数，示例如下：
- en: '[PRE1832]'
  id: totrans-9475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1832]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9476
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `to:` 被写在第一个输入值之前，`for:` 被写在第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用时使用它。如果你试图使用参数名而不是标签，编译器会报错：
- en: '[PRE1833]'
  id: totrans-9477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1833]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9478
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会自动填写参数标签，所以你不需要担心调用函数时出错（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9479
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9480
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9481
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向某位客人发送感谢信 *to* 客人 *for*
    礼物。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 读起来更像一句话，而不是 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9482
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加一个下划线和空格来移除它们。在下面的例子中，我们编写了一个用于计算体积的函数，该函数以盒子的三个边长为输入。由于函数名已经清楚地表明需要传入三个边长，因此你实际上不需要参数标签来使代码更具可读性。
- en: '[PRE1834]'
  id: totrans-9485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1834]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 位置、➋ 位置和 ➌ 位置前添加下划线来移除 sides 的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你调用这个函数时，你只需要输入参数值，而不需要任何标签。
- en: '[PRE1835]'
  id: totrans-9488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1835]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9489
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72."。如果你能将结果存储到变量或常量中，方便以后使用，而不仅仅是打印盒子的体积，这不是更有用吗？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9491
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将 `volumeOfBoxWithSides(_:_:_:)` 函数重写为返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9493
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个能装更多的东西。首先，编写一个返回盒子体积的 `volumeOfBox(_:_:_:)` 函数，该函数返回一个
    Int 类型的体积值：
- en: '[PRE1836]'
  id: totrans-9494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1836]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9495
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数返回值，在函数的输入参数之后使用一个箭头（`->`）并输入返回值的数据类型 ➊。请注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，使用
    `return` 关键字返回你想要返回的值 ➋。如果你写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在你返回值之后结束。如果你在
    `return` 语句之后编写任何代码，它将被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9496
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9497
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-9498
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9499
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在，让我们打印一条关于哪个盒子更大的信息：
- en: '[PRE1837]'
  id: totrans-9500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1837]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9501
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9502
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9503
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据条件返回不同的值。让我们编写一个函数，接受一个测试分数数组并返回平均分数。为了得到平均分数，你需要将所有分数加起来然后除以分数的总数。请在你的
    playground 中输入以下代码：
- en: '[PRE1838]'
  id: totrans-9504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1838]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9505
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 类型变量，并将其初始化为 0。在 ➋ 处的 `for-in`
    循环遍历 `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量保存了所有分数的总和。计算完总和后，剩下的就是将它除以分数的总数，简单来说就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9506
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能用零去除——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误，并且程序会崩溃。因此，在进行除法时，始终确保你要除的数不是零，这就是我们通过在➌处检查
    `scores.count > 0` 来做的。在 ➍ 处，我们通过将分数的总和除以数组中分数的个数来返回平均值，使用 `return sum / scores.count`。没错！你可以返回任何能够求值为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回
    `sum / scores.count`，因为它的求值结果是一个 `Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9507
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回某个值，否则会报错说函数缺少返回值。我们通过在 `if` 语句中添加一个 `else`
    来处理这种情况，返回值为 0 ➎。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9508
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9509
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将完整的测试成绩数组传递给 averageOf() 函数时，就像我们在 ➊ 处所做的那样，返回的是成绩的平均值，并显示在结果面板中。如果您传递的是一个空数组，如我们在
    ➋ 处所做的那样，返回值将是 0。
- en: '**NOTE**'
  id: totrans-9510
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9511
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句实际上不是必需的。这是因为如果 scores.count > 0 ，那么函数已经通过 return
    sum / scores.count 结束了。所以如果计算机已经执行到那条 if 语句之后，我们知道 scores.count > 0 肯定不为真，这时候我们可以直接返回
    0，而无需将其放在 else 语句中。然而，如果我们保留 else 语句，代码会更加清晰易懂。有时候，为了让别人更容易理解，写一些额外的代码比使用复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9513
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚为您的 Swift 工具包添加了一个重要工具——创建和调用您自己的函数！函数在编程中被广泛使用，可以做各种令人惊奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9514
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将向您展示如何通过编写类定义来创建自定义对象。这将使您能够创建除 Swift 中已包含的类型之外的常量和变量，这在您创建应用时会非常有用！
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  id: totrans-9515
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(to:) 函数的输入参数是 friend，参数标签是 to，传入的参数是 "Colin"。如果没有单独的参数标签，在调用函数时，它会像
    sayHello(friend:) 这样，这听起来就不像一句完整的句子。
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-9516
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写具有自定义参数标签的函数。我们还将向您展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-9517
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-9518
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例，说明如何通过添加自定义参数标签来使您的代码更具可读性。在您的生日派对后，您可能需要给所有的客人发送感谢信。请在您的 Playground
    中编写以下函数：
- en: '[PRE1839]'
  id: totrans-9519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1839]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-9520
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传递给函数的 guest 参数添加了一个自定义参数标签 to。类似地，在 ➋ 处，我们为 gift 参数添加了一个参数标签 for。参数名称
    guest ➌ 和 gift ➍ 用来在函数内部引用参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9521
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标记参数，如下所示：
- en: '[PRE1840]'
  id: totrans-9522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1840]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9523
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，您可以看到 to: 写在函数调用中的第一个输入值前，for: 写在第二个输入值前。如果一个参数有自定义的参数标签，您在函数调用时必须使用它。尝试使用参数名称将会导致错误：'
- en: '[PRE1841]'
  id: totrans-9524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1841]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9525
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为您填写参数标签，因此您无需担心错误地调用函数（请参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9526
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9527
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动补全函数并使用正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9528
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像*to*、*from*、或*with*这样的介词作为参数标签。在这个例子中，函数用来向客人*感谢*赠送的礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")读起来更像一句句子，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9529
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9530
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**去除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9531
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前加下划线和空格来去掉它们。在下面的例子中，我们编写了一个计算体积的函数，输入是盒子的三条边。由于函数名已经明确表明需要传入三条边，所以其实不需要参数标签来增加代码的可读性。
- en: '[PRE1842]'
  id: totrans-9532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1842]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处为side1、➋处为side2、➌处为side3前面加下划线，来去掉边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9534
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你调用这个函数时，只需要输入参数值，而不需要任何标签。
- en: '[PRE1843]'
  id: totrans-9535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1843]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9536
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出“The volume of this box is 72.”。如果你不仅仅是打印出盒子的体积，而是能够将结果存储到变量或常量中以后使用，这样不是更有用吗？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9538
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的盒子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9540
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个能装更多东西。首先，写一个返回盒子体积的volumeOfBox(_:_:_:)函数：
- en: '[PRE1844]'
  id: totrans-9541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1844]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9542
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给一个函数添加返回值，在函数的输入参数后使用一个破折号和一个大于号来形成箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要一个数据类型。在函数体内，你通过使用return关键字和你想返回的值来返回该值。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值后结束。如果在return语句后写了任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9543
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9544
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用函数来查看它的实际效果：
- en: '![](Image00165.jpg)'
  id: totrans-9545
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9546
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算了一个边长为6、5和3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋处，边长为8、4和2的volumeOfBox2被赋值为64。现在让我们打印一条关于哪个盒子更大的信息：
- en: '[PRE1845]'
  id: totrans-9547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1845]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9548
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9550
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接收一个测试分数数组并返回平均分。为了得到平均分，你需要将所有分数加在一起，然后除以分数的总数。在你的工作区输入以下代码：
- en: '[PRE1846]'
  id: totrans-9551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1846]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9552
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 中，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始值设为 0。在 ➋ 中的 `for-in`
    循环会遍历 `scores` 数组中的每个值，并将其加到 `sum` 变量上。当循环完成时，`sum` 变量保存了所有分数的总和。计算完总和后，剩下的就是将它除以分数的总数，`scores.count`
    即为总数。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9553
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空呢？你不能把一个数除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并崩溃程序。因此，在进行除法运算时，务必确保你要除的数不是零，这就是我们在
    ➌ 中通过检查 `scores.count > 0` 来做到的。在 ➍ 中，我们通过将分数的总和除以数组中分数的数量来返回平均分，使用 `return sum
    / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 `sum
    / scores.count`，因为它会计算为一个 `Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9554
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回某些内容，否则我们会得到一个错误，提示函数缺少返回值。我们通过在 `if` 语句中添加一个
    `else` 来处理这个问题，返回 0 ➎ 。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9555
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9556
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 `averageOf()` 函数时，就像我们在 ➊ 中所做的，返回的将是分数的平均值，并显示在结果面板中。如果你传入一个空数组，就像我们在
    ➋ 中所做的，返回值将是 0。
- en: '**NOTE**'
  id: totrans-9557
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9558
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，`else` 语句包围 `return 0` 实际上并不是必需的。因为如果 `scores.count > 0`，函数已经会通过 `return
    sum / scores.count` 结束。所以如果计算机已经跳过了那个 `if` 语句，我们就知道 `scores.count > 0` 肯定不成立，我们完全可以直接
    `return 0`，而不需要将其放入 `else` 中。不过，如果我们保留 `else` 语句，代码会更清晰、更容易理解。有时候，写一些额外的代码让别人更容易理解，比使用巧妙的简写更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9559
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的知识**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9560
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种了不起的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9561
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建除Swift内置类型外的常量和变量，在开发应用时非常有用！
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  id: totrans-9562
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写带有自定义参数标签的函数。我们还将向你展示如何编写一个完全省略参数标签的函数。
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-9563
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-9564
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看添加自定义参数标签如何让你的代码更具可读性。在你的生日派对之后，你会想要给所有的客人发送感谢信。请在你的 Playground 中编写以下函数：
- en: '[PRE1847]'
  id: totrans-9565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1847]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-9566
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传入函数的guest参数添加了一个自定义的参数标签，to。类似地，在➋处，我们为gift参数添加了一个参数标签，for。参数名guest
    ➌和gift ➍在函数内部用于引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9567
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for在函数调用时用于标识参数，像这样：
- en: '[PRE1848]'
  id: totrans-9568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1848]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9569
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到to:在第一个输入值前面写入，for:在第二个输入值前面写入。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。如果试图使用参数名而不是标签，将会报错：
- en: '[PRE1849]'
  id: totrans-9570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1849]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9571
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动补全功能会始终为你填充参数标签，所以你不必担心错误地调用函数（见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9572
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9573
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全函数并添加正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9574
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信，感谢他们赠送的礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")读起来更像一句句子，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9575
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9577
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加下划线和空格来移除它们。在下面的示例中，我们编写了一个计算体积的函数，接受一个盒子的三个边长作为输入。因为函数名已经明确说明了需要传入三个边长，所以不需要额外的参数标签来提高代码的可读性。
- en: '[PRE1850]'
  id: totrans-9578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1850]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9579
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处给side1添加下划线，在➋处给side2添加下划线，以及在➌处给side3添加下划线，从而移除了这些边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9580
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，而无需使用标签。
- en: '[PRE1851]'
  id: totrans-9581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1851]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9582
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"这个盒子的体积是72。"。如果你可以将结果存储在变量或常量中，以便以后使用，而不仅仅是打印盒子的体积，岂不是更方便吗？让我们一起看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9584
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9585
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9586
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个能装更多的东西。首先，编写一个名为 volumeOfBox(_:_:_:) 的函数，用于返回盒子的体积（Int类型）：
- en: '[PRE1852]'
  id: totrans-9587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1852]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9588
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数添加返回值，可以在函数输入参数后面使用短横线和大于符号（->）来构成箭头 ➊，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，通过使用
    return 关键字并跟上你要返回的值 ➋ 来返回值。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果你在
    return 语句后编写任何代码，它会被忽略，因为 return 会使函数退出。
- en: '![Image](Image00164.jpg)'
  id: totrans-9589
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9590
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-9591
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9592
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印出关于哪个盒子更大的消息：
- en: '[PRE1853]'
  id: totrans-9593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1853]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9594
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到输出字符串 "Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9596
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，接受一个测试分数数组并返回平均分数。要计算平均分，你将分数加在一起，然后除以总分数的个数。请在你的
    playground 中输入以下代码：
- en: '[PRE1854]'
  id: totrans-9597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1854]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9598
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 变量，并将其初始化为 0。在 ➋ 处的 for-in 循环会遍历 scores
    数组中的每个值，并将它加到 sum 变量中。循环完成后，变量 sum 就存储了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总个数，简单来说就是 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9599
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会给你一个除以零的错误并导致程序崩溃。因此，在进行除法时，始终确保你要除的数不为零，这就是我们在
    ➌ 处通过检查 scores.count > 0 来做的。在 ➍ 处，我们通过将分数总和除以数组中的分数个数来返回平均值，使用 return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋给新变量的步骤，直接返回
    sum / scores.count，因为它会计算出一个 Int 类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9600
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 scores.count 不大于零时返回某个值，否则会报错提示函数缺少返回值。我们通过在 if 语句中添加一个 else 来处理这个问题，返回
    0 ➎。你可以通过在一个成绩数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9601
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9602
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传入 averageOf() 函数时，正如我们在 ➊ 处所做的那样，函数会返回成绩的平均值并显示在结果面板中。如果你传入一个空数组，如我们在
    ➋ 处所做的那样，返回值则为 0。
- en: '**NOTE**'
  id: totrans-9603
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9604
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句其实并不必要。因为如果 scores.count > 0 ，那么函数会已经通过 return
    sum / scores.count 提前结束。所以如果计算机已经越过那个 if 语句，我们就知道 scores.count > 0 这一条件并不成立，因此可以直接使用
    return 0，而不必放在 else 语句中。然而，如果我们保留 else 语句，代码会更加清晰易懂。有时候，为了让其他人更容易理解，写一些额外的代码比使用复杂的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9606
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚给你的 Swift 工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来实现各种令人惊叹的功能！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9607
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这样，你就可以创建除 Swift 内置类型之外的常量和变量，在你开发应用时，这将非常有用！
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  id: totrans-9608
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加自定义参数标签**'
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-9609
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，展示如何通过添加自定义参数标签让代码更加易读。在你的生日派对之后，你会想给所有的客人发送感谢信。请在你的 Playground 中编写以下函数：
- en: '[PRE1855]'
  id: totrans-9610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1855]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-9611
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们为传入函数的 guest 参数添加了一个自定义参数标签，to。类似地，在 ➋ 处，我们为 gift 参数添加了一个参数标签，for。参数名
    guest ➌ 和 gift ➍ 用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9612
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 to 和 for 用于在调用函数时标注参数，如下所示：
- en: '[PRE1856]'
  id: totrans-9613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1856]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9614
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 写在第一个输入值之前，for: 写在第二个输入值之前。如果某个参数有自定义参数标签，你在调用函数时必须使用它。如果尝试使用参数名代替，程序会报错：'
- en: '[PRE1857]'
  id: totrans-9615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1857]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9616
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能将始终为你填充参数标签，因此你不必担心调用函数时出现错误（见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9617
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9618
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9619
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用来给一位客人发送感谢信*to*客人*for*礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")读起来更像一句句子，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9620
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9621
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9622
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加一个下划线和一个空格来移除它们。在下面的例子中，我们写了一个计算体积的函数，接受一个盒子的三个边作为输入。因为函数名已经明确表示你需要传入三个边，所以实际上你不需要参数标签来让代码更具可读性。
- en: '[PRE1858]'
  id: totrans-9623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1858]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9624
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在侧面参数前添加下划线，移除了边长的标签：侧面1在➊处，侧面2在➋处，侧面3在➌处。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9625
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，不需要任何标签。
- en: '[PRE1859]'
  id: totrans-9626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1859]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9627
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"The volume of this box is 72."。如果不是直接打印出盒子的体积，而是将结果存储在一个变量或常量中以便稍后使用，岂不是很有用？让我们来看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9629
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，以返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9630
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9631
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能容纳更多的东西。首先，写一个volumeOfBox(_:_:_:)函数，返回一个Int类型的盒子体积：
- en: '[PRE1860]'
  id: totrans-9632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1860]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9633
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数返回值，使用一个短横线和大于号形成箭头(->)，紧接着输入参数后面，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你可以使用return关键字，后跟你要返回的值来返回结果➋。如果你写一个返回值的函数，你*必须*在函数内部返回该值，否则会报错。函数在返回值后结束。如果在返回语句之后再写任何代码，它将被忽略，因为return会使函数退出。
- en: '![Image](Image00164.jpg)'
  id: totrans-9634
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9635
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的盒子调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-9636
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9637
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算一个边长为6、5和3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋处，给定边长为8、4和2的volumeOfBox2的值为64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1861]'
  id: totrans-9638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1861]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9639
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台中看到字符串"Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9640
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9641
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，它接受一个测试成绩数组并返回平均分。为了得到平均值，你需要将成绩相加，然后除以总分数。请在你的playground中输入以下代码：
- en: '[PRE1862]'
  id: totrans-9642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1862]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9643
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在➊处，我们定义了一个名为sum的Int变量，并将其初始值设为0。➋处的for-in循环遍历scores数组中的每个值，并将其加到sum变量中。当循环完成时，变量sum保存了所有分数的总和。在计算完总和后，剩下的就是将其除以分数的总数，这个值就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9644
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能把一个数除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会给你一个“除以零错误”，并使程序崩溃。因此，在进行除法时，务必确保你要除的数字不是零，这就是我们通过在➌处检查scores.count
    > 0来做到的。在➍处，我们通过将分数的总和除以数组中分数的数量来返回平均值，使用的是return sum / scores.count。没错！你可以返回任何评估为正确数据类型的表达式，这意味着我们可以跳过将计算得出的平均值分配给新变量的步骤，直接返回sum
    / scores.count，因为它评估为Int类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9645
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在scores.count不大于零时返回一个值，否则会出现“函数缺少返回值”的错误。我们通过在if语句中添加else来处理这个问题，返回0➎。你可以通过调用函数来测试这段代码，传入一个分数数组和一个空数组：
- en: '![](Image00166.jpg)'
  id: totrans-9646
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9647
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给averageOf()函数时，如我们在➊处所做的，函数返回分数的平均值并显示在结果面板中。如果你传递一个空数组，如我们在➋处所做的，返回值则为0。
- en: '**NOTE**'
  id: totrans-9648
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9649
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0周围的else语句其实并不是必要的。这是因为如果scores.count > 0，那么函数已经在return sum
    / scores.count处结束了。所以如果计算机已经跳过了那个if语句，那么我们知道scores.count > 0一定不成立，直接返回0即可，而不需要放在else语句中。然而，如果我们保留else语句，代码会更加清晰和易于理解。有时，写一些额外的代码让别人更容易理解，比使用一些巧妙的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9650
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9651
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以完成各种神奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9652
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)，我们将展示如何通过编写类定义来创建自定义对象。这将允许你创建类型与Swift中已有的类型不同的常量和变量，在你开发应用时会非常有用！
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  id: totrans-9653
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过添加自定义参数标签使代码更具可读性。假设在生日派对后，你想给所有的客人发送感谢信。请在你的 Playground 中编写以下函数：
- en: '[PRE1863]'
  id: totrans-9654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1863]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-9655
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们为传递给函数的guest参数添加了一个自定义的`to`标签。类似地，在➋，我们为gift参数添加了`for`标签。函数内部使用`guest`
    ➌和`gift` ➍作为参数名称来引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9656
  prefs: []
  type: TYPE_NORMAL
  zh: '`to`和`for`这两个参数标签在调用函数时用于标记参数，像这样：'
- en: '[PRE1864]'
  id: totrans-9657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1864]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9658
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到，`to:`在第一个输入值之前写出，`for:`在第二个输入值之前写出。如果参数有自定义的参数标签，你必须在函数调用时使用它。否则，尝试使用参数名称会导致错误：
- en: '[PRE1865]'
  id: totrans-9659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1865]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9660
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填写参数标签，因此你无需担心错误地调用函数（见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9661
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9662
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9663
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员通常会使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于发送感谢信*给*客人*以感谢*礼物。`sendThankYou(to:
    "Meghan", for: "puzzle books")`读起来更像一句话，而不是`sendThankYou(guest: "Meghan", gift:
    "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9664
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9665
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**去除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9666
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加上一个下划线和空格来去除它们。在下面的例子中，我们编写了一个用于计算体积的函数，该函数需要传入一个盒子的三个边。因为函数名已经明确表示需要传入三个边，所以实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1866]'
  id: totrans-9667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1866]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9668
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在侧面参数前加上下划线来去除侧面的参数标签，侧面1在➊，侧面2在➋，侧面3在➌。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9669
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用该函数时，只需要输入参数值，而不需要任何标签。
- en: '[PRE1867]'
  id: totrans-9670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1867]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9671
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。”如果你不只是打印盒子的体积，而是将结果存储到一个变量或常量中以便稍后使用，那该有多有用呢？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9672
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9673
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将`volumeOfBoxWithSides(_:_:_:)`函数重写为返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9674
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的盒子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9675
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多东西。首先，编写一个 `volumeOfBox(_:_:_:)` 函数，它返回一个 `Int` 类型的盒子体积：
- en: '[PRE1868]'
  id: totrans-9676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1868]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9677
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数一个返回值，在函数的输入参数后面使用一个破折号和大于号（`->`）来组成箭头（➊），然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要数据类型。在函数体内，使用
    `return` 关键字返回你想返回的值（➋）。如果你写一个返回值的函数，你*必须*在函数内部返回这个值，否则会出错。函数在返回值之后结束。如果在返回语句后写任何代码，它将被忽略，因为
    `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9678
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9679
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的盒子调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-9680
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9681
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个边长分别为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在让我们打印一条关于哪个盒子更大的信息：
- en: '[PRE1869]'
  id: totrans-9682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1869]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9683
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9684
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9685
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，它接受一个测试分数数组并返回平均分数。为了获得平均分数，你需要将分数加在一起，然后除以总的分数数量。在你的
    Playground 中输入以下代码：
- en: '[PRE1870]'
  id: totrans-9686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1870]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9687
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始值设为 0。➋ 处的 `for-in` 循环遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量保存了所有分数的总和。在我们计算出总和后，剩下的就是将它除以分数的总数量，这就是简单的
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9688
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能用零去除任何东西——在数学课上或者在 Swift 中都是如此。在 Swift 中，尝试用零除会导致除零错误，并使程序崩溃。因此，在进行除法运算时，始终确保你要除的数不是零，这就是我们在➌处通过检查
    `scores.count > 0` 所做的。在 ➍ 处，我们通过将分数的总和除以数组中分数的数量来返回平均值，使用 `return sum / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回
    `sum / scores.count`，因为它的值是一个 `Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9689
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们还需要返回一个值，否则会报错提示函数缺少返回值。我们通过在if语句中添加else来处理这个问题，返回0
    ➎。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9690
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9691
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给averageOf()函数时，就像在➊处所做的那样，返回的将是成绩的平均值，并显示在结果面板中。如果你传递一个空数组，如➋所示，返回值将是0。
- en: '**NOTE**'
  id: totrans-9692
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9693
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句实际上并不是必需的。这是因为，如果scores.count > 0，那么函数已经通过return sum
    / scores.count结束了。所以，如果计算机已经通过了那个if语句，那么我们知道scores.count > 0一定不成立，我们可以直接返回0，而不必将其放入else语句中。然而，如果我们保留else语句，代码会更清晰，更容易理解。有时为了让别人更容易理解，写一些额外的代码比使用复杂的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9694
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9695
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，能够完成各种令人惊奇的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9696
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建类型不同于Swift中已包含的类型的常量和变量，当你创建应用程序时，这将派上用场！
- en: '[PRE1871]'
  id: totrans-9697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1871]'
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-9698
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们给传入函数的guest参数添加了一个自定义的参数标签to。同样，在➋处，我们给gift参数添加了一个参数标签for。参数名称guest ➌和gift
    ➍用于函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9699
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签to和for用于在调用函数时标记参数，像这样：
- en: '[PRE1872]'
  id: totrans-9700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1872]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9701
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到to:写在函数调用中的第一个输入值前，for:写在第二个输入值前。如果一个参数有自定义的参数标签，那么在函数调用时必须使用它。如果你试图使用参数名称而不是标签，程序会报错：
- en: '[PRE1873]'
  id: totrans-9702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1873]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9703
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode的自动完成功能会自动为你填写参数标签，所以你不必担心错误地调用函数（见[图7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9704
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9705
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动完成函数并添加正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9706
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用介词如*to*、*from*或*with*作为参数标签。在这个例子中，函数用于发送感谢信*给*某位客人*为了*感谢他们的礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")更像一句完整的句子，而不是sendThankYou(guest: "Meghan", gift:
    "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9707
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9708
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9709
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前加上一个下划线和一个空格来移除它们。在以下示例中，我们编写了一个计算体积的函数，它接受一个盒子的三个边长作为输入。因为函数名已经明确表示需要传入三个边长，所以你实际上不需要参数标签来使代码更具可读性。
- en: '[PRE1874]'
  id: totrans-9710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1874]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9711
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`side1`处放置一个下划线➊，在`side2`处放置一个下划线➋，以及在`side3`处放置一个下划线➌，来移除边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9712
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值而不带标签。
- en: '[PRE1875]'
  id: totrans-9713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1875]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9714
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。”如果你能把结果存储在一个变量或常量中，而不仅仅是打印盒子的体积，岂不是很有用吗？让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9716
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9717
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9718
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，编写一个`volumeOfBox(_:_:_:)`函数，返回盒子的体积（Int类型）：
- en: '[PRE1876]'
  id: totrans-9719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1876]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9720
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数添加返回值，可以在输入参数后面使用一个短横线和大于号（->）来形成箭头➊，然后输入返回值的数据类型。注意，你不需要为返回值命名，只需要指定数据类型。在函数体内，使用`return`关键字后跟你想返回的值来返回该值➋。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在你返回值后结束。如果你在`return`语句之后写了任何代码，它会被忽略，因为`return`会使函数结束。
- en: '![Image](Image00164.jpg)'
  id: totrans-9721
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9722
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-9723
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9724
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`volumeOfBox(_:_:_:)`函数计算了一个边长分别为6、5和3的盒子的体积，返回值90被存储在一个名为`volumeOfBox1`的常量中。在➋处，边长为8、4和2的`volumeOfBox2`的值为64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1877]'
  id: totrans-9725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1877]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9726
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9727
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9728
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接受一个测试成绩数组并返回平均成绩。为了得到平均值，你需要将所有成绩加在一起，然后除以成绩的总数。请在你的playground中输入以下代码：
- en: '[PRE1878]'
  id: totrans-9729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1878]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9730
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始值设置为 0。位于 ➋ 处的 for-in 循环遍历
    scores 数组中的每个值，并将其加到 sum 变量中。当循环结束时，变量 sum 保存了所有分数的总和。在计算完总和后，剩下的就是将其除以总的分数数量，这个数量就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9731
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组是空的呢？你不能用零除——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会引发除以零错误，并使程序崩溃。因此，在做除法时，确保除数不为零是非常重要的，这就是我们通过在
    ➌ 处检查 `scores.count > 0` 来做的。然后在 ➍ 处，我们通过将分数总和除以数组中的分数数量来返回平均值，使用 `return sum
    / scores.count`。没错！你可以返回任何求值为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 `sum
    / scores.count`，因为它的结果是一个 Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9732
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 `scores.count` 不大于零时返回一些内容，否则我们会遇到一个错误，提示函数缺少返回值。我们通过在 if 语句中添加一个
    else 来处理这一点，从而返回 0 ➎。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9733
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9734
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给 `averageOf()` 函数时，正如我们在 ➊ 处所做的，返回的成绩平均值会在结果面板中显示。如果你传入一个空数组，正如我们在
    ➋ 处所做的，返回值则为 0。
- en: '**NOTE**'
  id: totrans-9735
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9736
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句并不是特别必要。这是因为，如果 `scores.count > 0`，函数已经通过 return
    sum / scores.count 结束了。所以，如果程序已经跳过了 if 语句，我们知道 `scores.count > 0` 一定不成立，此时我们可以直接使用
    `return 0`，而不必放在 else 中。然而，如果我们保留 else 语句，代码会更清晰，别人更容易理解。有时候，写一些额外的代码来让别人更容易理解，比使用一些巧妙的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9738
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，能够完成各种各样的惊人任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9739
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08) 中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建类型不同于 Swift
    已有类型的常量和变量，这在你开发应用程序时非常有用！
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  id: totrans-9740
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们为传递到函数中的`guest`参数添加了一个自定义参数标签*to*。类似地，在➋处，我们为`gift`参数添加了参数标签*for*。参数名`guest`（➌）和`gift`（➍）用来在函数内部引用这些参数。
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9741
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签*to*和*for*用于标记函数调用时的参数，例如：
- en: '[PRE1879]'
  id: totrans-9742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1879]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9743
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到，*to*在函数调用中出现在第一个输入值之前，*for*在第二个输入值之前。如果参数有自定义的参数标签，你必须在函数调用中使用它。如果尝试使用参数名代替，将会出现错误：
- en: '[PRE1880]'
  id: totrans-9744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1880]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9745
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填充参数标签，因此你不必担心函数调用错误（见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9746
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9747
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9748
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于向一位客人发送感谢信，*to*表示发送给客人，*for*表示感谢礼物。代码`sendThankYou(to:
    "Meghan", for: "puzzle books")`读起来更像一句句子，而不是`sendThankYou(guest: "Meghan", gift:
    "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9749
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9750
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9751
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前添加下划线和一个空格来移除它们。在下面的例子中，我们写一个计算体积的函数，输入的是盒子的三条边。因为函数名已经清楚表明需要传入三条边，所以你不需要额外的参数标签来使代码更具可读性。
- en: '[PRE1881]'
  id: totrans-9752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1881]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9753
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`side1`前加下划线（➊），`side2`前加下划线（➋），以及`side3`前加下划线（➌）来移除这些参数的标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9754
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，你只需要输入参数值，而不需要任何标签。
- en: '[PRE1882]'
  id: totrans-9755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1882]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9756
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出"这个盒子的体积是72"。如果你可以将体积存储在变量或常量中以便以后使用，而不是仅仅打印出来，那该多好！让我们来看一下如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9757
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9758
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9759
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9760
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，写一个`volumeOfBox(_:_:_:)`函数，返回盒子的体积（Int类型）：
- en: '[PRE1883]'
  id: totrans-9761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1883]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9762
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数添加返回值，在函数的输入参数之后使用一个破折号和大于号（->）来组成箭头 ➊，然后输入返回值的数据类型。请注意，你不需要为返回值提供名字，只需要提供数据类型。在函数体内，通过使用
    `return` 关键字，后跟你想要返回的值来返回该值 ➋。如果你写的函数有返回值，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值之后结束。如果你在
    `return` 语句之后再写任何代码，它将被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9763
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9764
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数来查看其运行效果：
- en: '![](Image00165.jpg)'
  id: totrans-9765
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9766
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在让我们打印一条消息，告诉我们哪个盒子更大：
- en: '[PRE1884]'
  id: totrans-9767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1884]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9768
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台中看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9769
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9770
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，它接受一个测试分数的数组并返回平均分。为了得到平均值，你需要将分数相加，然后除以分数的总数。在你的 Playground
    中输入以下代码：
- en: '[PRE1885]'
  id: totrans-9771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1885]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9772
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 类型变量，并将其初始值设为 0。 ➋ 处的 `for-in`
    循环遍历 `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，变量 `sum` 保存了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数量，简单来说，就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9773
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办？你不能用零除——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误，并且程序会崩溃。因此，在进行除法时，一定要确保除数不是零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 所做的。到 ➍ 时，我们通过将分数的总和除以数组中分数的数量来返回平均值，使用 `return sum
    / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋值给新变量的步骤，直接返回 `sum
    / scores.count`，因为它会计算出一个 `Int` 类型的结果。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9774
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 `scores.count` 不大于零时返回某个值，否则我们会遇到函数缺少返回值的错误。我们通过在 `if` 语句中添加 `else`
    来处理这个问题，返回值为 0 ➎。你可以通过在一个包含分数的数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9775
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9776
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像 ➊ 这样将一组完整的测试成绩数组传递给 `averageOf()` 函数时，返回的平均成绩值会显示在结果窗格中。如果你传递一个空数组，如 ➋ 所示，返回值将是
    0。
- en: '**NOTE**'
  id: totrans-9777
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9778
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 `else` 语句其实并不是必要的。这是因为如果 `scores.count > 0`，函数已经会在
    `return sum / scores.count` 处结束。所以如果计算机已经通过了那个 `if` 语句，我们知道 `scores.count > 0`
    可能不成立，我们可以直接写 `return 0`，而不需要将它包裹在 `else` 语句中。然而，如果我们保留 `else` 语句，代码会更清晰，易于理解。有时候，写一点额外的代码以便让别人更清楚地理解比使用复杂的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9779
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9780
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9781
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08) 中，我们将展示如何通过编写类定义来创建自定义对象。这将允许你创建除 Swift 中已有类型之外的常量和变量，这在你创建应用时非常有用！
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  id: totrans-9782
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签 `to` 和 `for` 用于在函数调用时标记参数，例如这样：
- en: '[PRE1886]'
  id: totrans-9783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1886]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9784
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`to:` 会在函数调用时写在第一个输入值前，`for:` 会写在第二个输入值前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。试图使用参数名代替会导致错误：
- en: '[PRE1887]'
  id: totrans-9785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1887]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9786
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填写正确的参数标签，所以你不必担心错误地调用函数（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9787
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9788
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9789
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向客人发送感谢信 *to*，感谢他 *for*
    赠送的礼物。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 更像一句完整的句子，而不是 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9790
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9791
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9792
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前加下划线并跟上一个空格来移除它们。在下面的示例中，我们编写了一个计算体积的函数，输入的是盒子的三个边长。因为函数名已经清楚地说明了需要传入三个边长，所以你实际上不需要参数标签来使代码更具可读性。
- en: '[PRE1888]'
  id: totrans-9793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1888]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9794
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处为 `side1`、在 ➋ 处为 `side2` 和 ➌ 处为 `side3` 前面加下划线，来移除这些参数的标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9795
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你调用这个函数时，只需要输入参数值，而不需要任何标签。
- en: '[PRE1889]'
  id: totrans-9796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1889]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9797
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。" 如果你不仅仅是打印出盒子的体积，而是将结果存储到一个变量或常量中，以便后续使用，岂不是很有用？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9798
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9799
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9800
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的盒子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9801
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个可以装更多的东西。首先，编写一个返回盒子体积的 `volumeOfBox(_:_:_:)` 函数，返回一个 `Int`
    类型的体积值：
- en: '[PRE1890]'
  id: totrans-9802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1890]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9803
  prefs: []
  type: TYPE_NORMAL
  zh: 要为一个函数指定返回值，在函数输入参数后面使用一个破折号和大于号来形成箭头 (->)，然后输入返回值的数据类型 ➊。请注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你通过使用
    `return` 关键字加上你想返回的值来返回该值 ➋。如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会发生错误。函数在返回值之后结束。如果你在
    `return` 语句后编写任何代码，它将被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9804
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9805
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-9806
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9807
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在让我们打印出哪个盒子更大的信息：
- en: '[PRE1891]'
  id: totrans-9808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1891]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9809
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9810
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9811
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，接收一组测试分数并返回平均分。为了计算平均分，你需要将分数相加，然后除以总的分数数量。请在你的
    Playground 中输入以下代码：
- en: '[PRE1892]'
  id: totrans-9812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1892]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9813
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 `Int` 变量，并将其初始值设为 0。➋ 处的 `for-in` 循环遍历
    `scores` 数组中的每个值，并将其加到 sum 变量中。当循环完成时，sum 变量保存了所有分数的总和。计算完总和后，剩下的就是将总和除以总分数的数量，后者就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9814
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办？你不能用零来做除法——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并使程序崩溃。因此，在进行除法运算时，务必确保除数不为零，这就是我们通过在
    ➌ 处检查 scores.count > 0 来实现的。在 ➍ 处，我们通过用 return sum / scores.count 将分数总和除以数组中分数的数量来返回平均值。没错！你可以返回任何能够评估为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回
    sum / scores.count ，因为它会评估为一个 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9815
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 scores.count 不大于零时返回一个值，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加 else 来处理这个问题，返回
    0 ➎。你可以通过对一个包含分数的数组和一个空数组调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9816
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9817
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整套测试分数传入 averageOf() 函数时，就像我们在 ➊ 处做的那样，分数的平均值会被返回并显示在结果面板中。如果你传入一个空数组，就像我们在
    ➋ 处做的那样，返回值是 0。
- en: '**NOTE**'
  id: totrans-9818
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9819
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不必要。这是因为如果 scores.count > 0 ，函数已经通过 return
    sum / scores.count 提前结束了。所以，如果计算机已经通过了那个 if 语句，我们就知道 scores.count > 0 一定不成立，我们可以直接使用
    return 0 而不必将其包含在 else 语句中。然而，如果保留 else 语句，代码会更加清晰易懂。有时候，为了让代码对别人更清晰，比起使用一些巧妙的快捷方式，写多一点代码是更好的选择。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9820
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9821
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9822
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建除 Swift 已经包含的类型之外的常量和变量，这在你创建应用时非常有用！
- en: '[PRE1893]'
  id: totrans-9823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1893]'
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9824
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 被写在函数调用的第一个输入值之前，而 for: 被写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。试图使用参数名而不是标签，会导致错误：'
- en: '[PRE1894]'
  id: totrans-9825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1894]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9826
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会自动填充参数标签，所以你不必担心错误地调用函数（见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9827
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9828
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成功能为函数填充了正确的参数标签。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9829
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用介词如 *to* 、 *from* 或 *with* 作为参数标签。在这个例子中，函数用于向来宾发送感谢信 *to* 感谢其 *for*
    赠送的礼物。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 比 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")` 更像一个完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9830
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9831
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**去除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9832
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前加上下划线和空格来去除它们。在下面的例子中，我们写了一个计算体积的函数，它接受一个盒子的三条边长作为输入。由于函数名已经清楚地表明你需要传入三条边，因此其实不需要参数标签来提高代码的可读性。
- en: '[PRE1895]'
  id: totrans-9833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1895]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9834
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处为 `side1`、在 ➋ 处为 `side2`、在 ➌ 处为 `side3` 前面加上下划线来去除这些参数的标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9835
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而无需任何标签。
- en: '[PRE1896]'
  id: totrans-9836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1896]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9837
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "The volume of this box is 72."。如果你能够把体积存储起来，以便之后在变量或常量中使用，而不是仅仅打印出来，这不是更有用吗？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9838
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9839
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9840
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9841
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能容纳更多东西。首先，编写一个 `volumeOfBox(_:_:_:)` 函数，返回盒子的体积（Int 类型）：
- en: '[PRE1897]'
  id: totrans-9842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1897]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9843
  prefs: []
  type: TYPE_NORMAL
  zh: 要让函数返回一个值，在函数的输入参数后面加上破折号和大于号，形成一个箭头（->） ➊ ，然后输入返回值的数据类型。注意，你不需要为返回值命名，只需指定数据类型。在函数体内，通过使用
    `return` 关键字后接你要返回的值 ➋ 来返回该值。如果你编写了一个返回值的函数，那么你 *必须* 在函数内部返回该值，否则会报错。函数在返回值之后结束。如果你在
    `return` 语句之后再写任何代码，它将被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9844
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9845
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-9846
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9847
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个边长分别为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长分别为 8、4 和 2 的盒子的 `volumeOfBox2` 被赋值为 64。现在让我们打印出哪个盒子更大：
- en: '[PRE1898]'
  id: totrans-9848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1898]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9849
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9850
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9851
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据条件返回不同的值。让我们写一个函数，它接受一个测试分数数组并返回平均分。要计算平均值，你需要将所有分数加起来，然后除以总分数的数量。在你的playground中输入以下代码：
- en: '[PRE1899]'
  id: totrans-9852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1899]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9853
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在➊处，我们定义了一个名为sum的Int变量，并将其初始值设置为0。在➋处的for-in循环会遍历scores数组中的每个值，并将其加到sum变量中。当循环完成时，变量sum保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，这个值就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9854
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空怎么办？你不能把一个数除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除零错误并崩溃你的程序。因此，在进行除法时，始终确保你将要除的数不是零，这就是我们在➌处通过检查scores.count
    > 0来确保的。在➍处，我们通过返回sum / scores.count来计算并返回平均值。没错！你可以返回任何评估为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回sum
    / scores.count，因为它评估为Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9855
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们还需要返回一些东西，否则会出现函数缺少返回值的错误。我们通过在if语句中添加一个else来处理这个问题，在else中返回0➎。你可以通过在一个分数数组和一个空数组上调用函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9856
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9857
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像在➊处那样将一整个测试分数数组传入averageOf()函数时，分数的平均值将被返回并显示在结果窗格中。如果你传入一个空数组，如在➋处那样，返回值将是0。
- en: '**NOTE**'
  id: totrans-9858
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9859
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0的else语句其实并不是必需的。这是因为如果scores.count > 0，那么函数已经会以return sum /
    scores.count结束了。所以如果计算机已经跳过了那个if语句，那么我们就知道scores.count > 0一定不成立，这时我们可以直接return
    0，而不需要将其包含在else语句中。然而，如果我们保留else语句，代码会更清晰、更易于理解。有时候写一些额外的代码，来让别人更容易理解，比起使用巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9860
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9861
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用于完成各种令人惊叹的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9862
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08) 中，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建具有 Swift 中未包含的类型的常量和变量，这在你创建应用程序时会派上用场！
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  id: totrans-9863
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，你可以看到 to: 写在函数调用中的第一个输入值之前，for: 写在第二个输入值之前。如果一个参数有自定义的参数标签，你必须在函数调用中使用它。如果尝试使用参数名称而不是参数标签，将会导致错误：'
- en: '[PRE1900]'
  id: totrans-9864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1900]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9865
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全会始终为你填写参数标签，因此你无需担心错误地调用函数（参见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9866
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9867
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成了具有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9868
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于将感谢信 *发送给* 一位客人 *以感谢*
    礼物。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 更像一句完整的句子，而不是 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9869
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9870
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**删除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9871
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加一个下划线和一个空格来删除它们。在以下示例中，我们编写了一个计算体积的函数，该函数以一个盒子的三条边作为输入。由于函数名称已经清楚地说明了需要传入三条边，因此你实际上并不需要参数标签来使代码更具可读性。
- en: '[PRE1901]'
  id: totrans-9872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1901]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9873
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 side1 前面加上下划线 ➊，在 side2 前面加上下划线 ➋，以及在 side3 前面加上下划线 ➌ 来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9874
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用该函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE1902]'
  id: totrans-9875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1902]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9876
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是 72。”如果你想要的不仅仅是打印盒子的体积，而是将结果存储在变量或常量中以便后续使用，那会很有用。让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9877
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9878
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，让它返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9879
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9880
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，编写一个返回盒子体积的 `volumeOfBox(_:_:_:)` 函数，该函数返回一个整数值：
- en: '[PRE1903]'
  id: totrans-9881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1903]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9882
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数返回值，请在函数输入参数后面使用一个破折号和大于号组合成箭头（->），然后输入返回值的数据类型 ➊。请注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你使用
    `return` 关键字后跟你想返回的值 ➋。如果你编写一个返回值的函数，那么你*必须*在函数内返回该值，否则会报错。函数在返回值后结束。如果你在 `return`
    语句之后写了任何代码，它将被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9883
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9884
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-9885
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9886
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在我们来打印出关于哪个盒子更大的消息：
- en: '[PRE1904]'
  id: totrans-9887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1904]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9888
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9889
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9890
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。我们来写一个函数，接受一个测试成绩数组并返回平均分。要计算平均分，你需要将所有分数加在一起，然后除以分数的总数。请在你的
    playground 中输入以下代码：
- en: '[PRE1905]'
  id: totrans-9891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1905]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9892
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 类型变量，并将其初始化为 0。`for-in` 循环在 ➋
    处遍历 `scores` 数组中的每个值并将其加到 `sum` 变量中。当循环完成时，`sum` 变量中保存了所有分数的总和。计算完总和后，我们所要做的就是将其除以分数的总数，也就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9893
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组是空的呢？你不能将任何东西除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并崩溃你的程序。因此，在进行除法时，一定要确保你要除的数不是零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来确保的。在 ➍ 处，我们通过用 `return sum / scores.count` 返回分数总和除以数组中分数的数量来得到平均值。没错！你可以返回任何计算结果符合正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回
    `sum / scores.count`，因为它计算出来的就是一个 `Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9894
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回某个值，否则会出现缺少返回值的错误。我们通过在 `if` 语句中添加 `else`
    来处理这个问题，返回 0 ➎。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9895
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9896
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 averageOf() 函数时，就像我们在 ➊ 处所做的那样，函数会返回分数的平均值并显示在结果窗格中。如果你传递一个空数组，如我们在
    ➋ 处所做的那样，返回值将是 0。
- en: '**NOTE**'
  id: totrans-9897
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9898
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不是必须的。这是因为如果 scores.count > 0，那么函数已经通过 return
    sum / scores.count 结束了。所以，如果计算机已经执行到那个 if 语句之后，我们就知道 scores.count > 0 必定为假，这时我们可以直接使用
    return 0，而不需要将其包含在 else 语句中。然而，如果我们保留 else 语句，代码会更加清晰和易于理解。有时候，为了让代码更易于他人理解，写一些额外的代码比使用技巧性的简写更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9899
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9900
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种各样的惊人事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9901
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建具有 Swift 中其他类型的常量和变量，这在你创建应用程序时将非常有用！
- en: '[PRE1906]'
  id: totrans-9902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1906]'
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9903
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动补全功能会始终为你填写参数标签，因此你无需担心调用函数时参数错误（请参见[图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9904
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9905
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了具有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9906
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于将感谢信 *送给* 客人 *以感谢* 礼物。代码
    sendThankYou(to: "Meghan", for: "puzzle books") 比起 sendThankYou(guest: "Meghan",
    gift: "puzzle books") 更像一句句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9907
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9908
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9909
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前加下划线和空格来移除它们。在以下示例中，我们编写了一个计算体积的函数，它接受一个盒子的三个边作为输入。因为函数名已经清楚地表明了需要传递三个边，所以实际上你并不需要参数标签来提高代码的可读性。
- en: '[PRE1907]'
  id: totrans-9910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1907]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9911
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处为 side1、➋ 处为 side2 和 ➌ 处为 side3 前面加下划线，来移除这些边的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9912
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE1908]'
  id: totrans-9913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1908]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9914
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "这个盒子的体积是 72。"。如果你能将结果存储在一个变量或常量中以便稍后使用，而不仅仅是打印出盒子的体积，难道不会很有用吗？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9915
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9916
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9917
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9918
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并想知道哪个能装更多的东西。首先，编写一个返回盒子体积的`volumeOfBox(_:_:_:)`函数：
- en: '[PRE1909]'
  id: totrans-9919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1909]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9920
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数指定返回值，使用一个破折号和一个大于号来形成箭头（`->`），紧跟在函数输入参数之后➊，然后输入返回值的数据类型。注意，你不需要为返回值指定名称，只需要指定数据类型。在函数体内，你使用`return`关键字后跟要返回的值来返回该值➋。如果你编写的函数返回一个值，那么你*必须*在函数内部返回该值，否则会出现错误。函数在你返回值后结束。如果你在返回语句之后写了任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9921
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9922
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用函数，看看它的效果：
- en: '![](Image00165.jpg)'
  id: totrans-9923
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9924
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，`volumeOfBox(_:_:_:)`函数计算了一个边长为6、5和3的盒子的体积，返回值90被存储在一个名为`volumeOfBox1`的常量中。在➋，边长为8、4和2的`volumeOfBox2`被赋值为64。现在让我们打印一条关于哪个盒子更大的信息：
- en: '[PRE1910]'
  id: totrans-9925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1910]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9926
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串"Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9927
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9928
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接收一个测试分数数组并返回平均分数。为了得到平均分数，你需要将所有分数加起来，然后除以分数的总数。将以下代码输入到你的Playground中：
- en: '[PRE1911]'
  id: totrans-9929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1911]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9930
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在➊，我们定义了一个名为`sum`的`Int`变量，并将其初始值设置为0。➋的`for-in`循环遍历`score`数组中的每个值并将其加到`sum`变量中。当循环完成后，变量`sum`保存了所有分数的总和。计算完总和后，剩下的就是将其除以总分数，即`score.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9931
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能用零除——无论是在数学课上，还是在Swift中。在Swift中，尝试用零除会导致“除零错误”并使程序崩溃。因此，在进行除法时，始终确保你将要除的数字不是零，这就是我们在➌时通过检查`score.count
    > 0`来做的。在➍时，我们通过将所有分数的总和除以数组中的分数数量来返回平均值，使用`return sum / score.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回`sum
    / score.count`，因为它会计算出一个`Int`类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9932
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们也需要返回某个值，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加一个 else
    来处理这个问题，返回 0 ➎。你可以通过调用一个包含分数的数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9933
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9934
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 averageOf() 函数时，正如我们在 ➊ 所做的，返回的平均值会显示在结果面板中。如果传入的是一个空数组，正如我们在
    ➋ 所做的，返回值是 0。
- en: '**NOTE**'
  id: totrans-9935
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9936
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实不是必需的。这是因为如果 scores.count > 0 ，那么函数会在 return
    sum / scores.count 时已经结束。所以如果计算机已经执行到那个 if 语句之后，我们知道 scores.count > 0 一定不成立，实际上可以直接写
    return 0 而不需要放在 else 语句中。然而，如果我们保留 else 语句，代码会更加清晰且易于理解。有时，写一些额外的代码以便让其他人更容易理解比使用巧妙的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9937
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9938
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以完成各种令人惊叹的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9939
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](text00018.html#ch08) 中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建不同于 Swift
    中已有类型的常量和变量，这对你创建应用程序非常有帮助！
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  id: totrans-9940
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 的自动完成功能会始终为你填充参数标签，因此你不必担心函数调用错误（见 [图 7-7](text00017.html#ch07fig7)）。
- en: '![Image](Image00162.jpg)'
  id: totrans-9941
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9942
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动完成带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9943
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向来宾发送感谢信 *to* 来宾 *for*
    礼物。代码 sendThankYou(to: "Meghan", for: "puzzle books") 读起来更像一句话，而不像 sendThankYou(guest:
    "Meghan", gift: "puzzle books")。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9944
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9945
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9946
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名之前加上一个下划线并后跟一个空格来移除它们。在以下示例中，我们编写了一个用于计算体积的函数，输入为盒子的三条边。因为函数名已经清楚地表明了你需要传入三条边，所以实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1912]'
  id: totrans-9947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1912]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9948
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处为 side1、➋ 处为 side2 和 ➌ 处为 side3 前面加上下划线来移除参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9949
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值而无需标签。
- en: '[PRE1913]'
  id: totrans-9950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1913]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9951
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“The volume of this box is 72.”。如果你能够将盒子的体积存储到一个变量或常量中，而不是仅仅打印到控制台，这不是更有用吗？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9952
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9953
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9954
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的盒子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9955
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子可以装更多东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，它返回盒子的体积（Int类型）：
- en: '[PRE1914]'
  id: totrans-9956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1914]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9957
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数返回一个值，可以在函数的输入参数➊后面使用一个短横线和一个大于符号来形成箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需指定数据类型。在函数体内，你使用
    return 关键字并跟上你想要返回的值➋来返回该值。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值后结束。如果你在
    return 语句后面编写任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9958
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9959
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-9960
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9961
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:) 函数计算了一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在➋处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在，让我们打印一条关于哪个盒子更大的信息：
- en: '[PRE1915]'
  id: totrans-9962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1915]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9963
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-9964
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-9965
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接收一个测试分数数组并返回平均分数。为了得到平均值，你将分数加在一起，然后除以分数的总数。在你的 Playground
    中输入以下代码：
- en: '[PRE1916]'
  id: totrans-9966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1916]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-9967
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在➊处，我们定义一个名为 sum 的 Int 变量，并将其初始值设为 0。➋处的 for-in 循环遍历分数数组中的每个值，并将其加到
    sum 变量中。当循环完成时，sum 变量存储了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数，简单来说就是 scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-9968
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空呢？你不能把什么东西除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除零错误并崩溃你的程序。因此，在进行除法运算时，务必确保你要除的数不是零，这也是我们通过在➌处检查scores.count
    > 0来完成的。然后在➍处，我们通过将成绩的总和除以数组中成绩的数量来返回平均值，使用return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出来的平均值赋给新变量的步骤，直接返回sum
    / scores.count，因为它会计算出一个Int类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-9969
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在scores.count不大于零时返回某个值，否则我们会遇到一个错误，提示函数缺少返回值。我们通过在if语句中添加else来处理这个问题，返回0➎。你可以通过在一个成绩数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-9970
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-9971
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给averageOf()函数时，正如我们在➊处所做的，函数会返回成绩的平均值并显示在结果面板中。如果你传入一个空数组，正如我们在➋处所做的，返回值将是0。
- en: '**NOTE**'
  id: totrans-9972
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-9973
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，包裹return 0的else语句其实并不是必需的。这是因为如果scores.count > 0，那么函数已经通过return sum
    / scores.count结束了。因此，如果计算机已经通过了那个if语句，我们知道scores.count > 0一定不成立，我们本可以直接返回0而不需要把它放在else中。然而，如果我们保留else语句，代码会更清晰、更容易理解。有时候，为了让其他人更容易理解，写一些额外的代码比使用复杂的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-9974
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-9975
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要的工具——创建并调用你自己的函数！函数在编程中被广泛使用，用来做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-9976
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建类型不同于Swift中已有类型的常量和变量，当你开发应用程序时，这将非常有用！
- en: '![Image](Image00162.jpg)'
  id: totrans-9977
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00162.jpg)'
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-9978
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：Xcode自动完成了带有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-9979
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于将感谢信*发送给*一位客人*为了*感谢礼物。代码sendThankYou(to:
    "Meghan", for: "puzzle books")比起sendThankYou(guest: "Meghan", gift: "puzzle books")，更像一句完整的句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-9980
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-9981
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-9982
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加上一个下划线和空格来去除它们。在下面的示例中，我们编写了一个计算体积的函数，该函数接受一个盒子的三个边长作为输入。因为函数名称已经明确表明需要传入三个边长，所以实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1917]'
  id: totrans-9983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1917]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-9984
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处的side1、➋处的side2和➌处的side3前加上下划线来移除边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-9985
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用该函数时，你只需输入参数值，而不需要标签。
- en: '[PRE1918]'
  id: totrans-9986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1918]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-9987
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将输出"这个盒子的体积是72。"。如果你能将盒子的体积存储在一个变量或常量中，以便以后使用，而不仅仅是打印它，这不是更有用吗？让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-9988
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-9989
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-9990
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-9991
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能装更多的东西。首先，编写一个返回盒子体积的volumeOfBox(_:_:_:)函数，返回类型为Int：
- en: '[PRE1919]'
  id: totrans-9992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1919]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-9993
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数指定返回值，使用一个破折号和一个大于号形成箭头(->)，紧接在函数的输入参数后面➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要一个数据类型。在函数体内，使用return关键字返回你想返回的值➋。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果你在return语句后写了任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-9994
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-9995
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它的实际效果：
- en: '![](Image00165.jpg)'
  id: totrans-9996
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-9997
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算一个边长分别为6、5和3的盒子的体积，返回值90被存储在名为volumeOfBox1的常量中。在➋处，边长分别为8、4和2的volumeOfBox2的值为64。现在让我们打印出关于哪个盒子更大的消息：
- en: '[PRE1920]'
  id: totrans-9998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1920]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-9999
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台看到字符串"盒子1是更大的盒子。"的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10000
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10001
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据某个条件返回不同的值。让我们编写一个接受测试分数数组并返回平均分数的函数。为了得到平均分，你需要将所有分数相加，然后除以分数的总数。在你的playground中输入以下代码：
- en: '[PRE1921]'
  id: totrans-10002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1921]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10003
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始值设置为 0。➋ 处的 for-in 循环遍历
    scores 数组中的每个值，并将其加到 sum 变量中。当循环完成时，sum 变量保存了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数，这个总数就是
    scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10004
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果数组为空呢？你不能将某个数除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并崩溃程序。因此，在进行除法运算时，始终确保你要除的数不是零，这就是我们在
    ➌ 处通过检查 scores.count > 0 来确保的。到 ➍ 处，我们通过将分数总和除以数组中的分数数量来返回平均值，使用 return sum /
    scores.count。没错！你可以返回任何计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 sum / scores.count，因为它的结果是一个
    Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10005
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 scores.count 不大于零时返回一个值，否则我们会得到一个缺少返回值的错误。我们通过在 if 语句中添加 else
    来处理这个问题，返回 0 ➎。你可以通过调用函数，传递一个分数数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10006
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10007
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试分数数组传递给 averageOf() 函数时，如 ➊ 处所示，函数会返回分数的平均值并显示在结果面板中。如果你传递的是一个空数组，如
    ➋ 处所示，返回值将是 0。
- en: '**NOTE**'
  id: totrans-10008
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10009
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不是必需的。因为如果 scores.count > 0，那么函数已经通过 return
    sum / scores.count 提前结束了。所以如果计算机已经通过了那个 if 语句，那么我们知道 scores.count > 0 肯定不成立，此时我们可以直接返回
    0，而不必把它包含在 else 语句中。然而，如果我们保留 else 语句，代码会更加清晰易懂。有时候，为了让别人更容易理解，写一些额外的代码比使用复杂的捷径要更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10010
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10011
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中广泛使用，用于完成各种令人惊叹的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10012
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建除 Swift 已包含类型之外的常量和变量，当你开发应用时，这会非常有用！
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  id: totrans-10013
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：Xcode 自动补全了具有正确参数标签的函数。*'
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-10014
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像*to*、*from*或*with*这样的介词作为参数标签。在这个例子中，函数用于发送感谢信*给*来宾*为*礼物。代码`sendThankYou(to:
    "Meghan", for: "puzzle books")`看起来更像一句句子，而不是`sendThankYou(guest: "Meghan", gift:
    "puzzle books")`。'
- en: '![Image](Image00163.jpg)'
  id: totrans-10015
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-10016
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-10017
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前添加下划线和空格来删除它们。在以下示例中，我们编写了一个用于计算体积的函数，它接受盒子的三个边长作为输入。因为函数名已经明确指出你需要传入三个边长，所以实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1922]'
  id: totrans-10018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1922]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-10019
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`side1`前面加上下划线（➊）、`side2`前面加上下划线（➋）和`side3`前面加上下划线（➌）来移除边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-10020
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你调用这个函数时，只需输入参数值而不需要标签。
- en: '[PRE1923]'
  id: totrans-10021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1923]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-10022
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"这个盒子的体积是72。"如果你不仅仅是打印盒子的体积，而是将结果存储到一个变量或常量中，以便稍后使用，不会更有用吗？让我们了解如何使用返回值来做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-10023
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-10024
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-10025
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-10026
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，编写一个返回盒子体积的`volumeOfBox(_:_:_:)`函数，返回值为一个整数（Int）：
- en: '[PRE1924]'
  id: totrans-10027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1924]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-10028
  prefs: []
  type: TYPE_NORMAL
  zh: 为函数提供返回值时，在函数的输入参数后面使用破折号和大于号形成箭头（->），然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你通过使用`return`关键字后跟要返回的值来返回该值。➋
    如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值后结束。如果你在`return`语句后写任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-10029
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10030
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的盒子调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-10031
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10032
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`volumeOfBox(_:_:_:)`函数计算了一个盒子的体积，边长为6、5和3，返回值90被存储在名为`volumeOfBox1`的常量中。在➋处，边长为8、4和2的`volumeOfBox2`被赋值为64。现在让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1925]'
  id: totrans-10033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1925]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10034
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串"Box 1 is the bigger box."的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10035
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10036
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，它接受一个测试分数数组并返回平均分。为了获得平均值，你需要将分数加在一起，然后除以总的分数数量。将以下代码输入到你的
    Playground 中：
- en: '[PRE1926]'
  id: totrans-10037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1926]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10038
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有数值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始值设为 0 。在 ➋ 处的 for-in 循环会遍历
    scores 数组中的每个值，并将其加到 sum 变量中。当循环完成后，sum 变量就包含了所有分数的总和。计算完总和后，剩下的就是将其除以总的分数个数，这个值就是
    scores.count 。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10039
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组是空的呢？你不能将一个数除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会引发除零错误，并导致程序崩溃。因此，在进行除法时，必须确保你要除的数不是零，这就是我们通过在
    ➌ 处检查 scores.count > 0 来实现的。在 ➍ 处，我们通过将分数总和除以数组中的分数数量来返回平均值，使用 return sum / scores.count
    。没错！你可以返回任何评估为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 sum / scores.count ，因为它的结果是一个
    Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10040
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们还需要返回一个值，否则会报错说函数缺少返回值。我们通过在 if 语句中添加 else 来处理这个问题，返回
    0 ➎ 。你可以通过调用这个函数，并传入一个分数数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10041
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10042
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传入 averageOf() 函数时，如我们在 ➊ 处所做的，返回的将是分数的平均值，并显示在结果面板中。如果你传入一个空数组，如我们在
    ➋ 处所做的，返回值则是 0 。
- en: '**NOTE**'
  id: totrans-10043
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10044
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句其实并不是必须的。这是因为，如果 scores.count > 0 ，那么函数已经通过 return
    sum / scores.count 提前结束了。所以如果程序已经通过了那个 if 语句，那么我们知道 scores.count > 0 肯定不成立，我们本来可以直接写一个
    return 0，而不需要把它包含在 else 语句中。然而，如果我们保留 else 语句，代码会更清晰、更容易理解。有时候，写一些额外的代码让别人更容易理解比使用一个复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10045
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10046
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱增加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种各样的惊人事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10047
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建除 Swift 中已包含的类型之外的常量和变量，在你创建应用时会派上用场！
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  id: totrans-10048
  prefs: []
  type: TYPE_NORMAL
  zh: '程序员常常使用像 *to*、*from* 或 *with* 这样的介词作为参数标签。在这个例子中，函数用于向宾客发送感谢信 *to* 一个宾客 *for*
    一份礼物。代码 `sendThankYou(to: "Meghan", for: "puzzle books")` 比 `sendThankYou(guest:
    "Meghan", gift: "puzzle books")` 更像一个句子。'
- en: '![Image](Image00163.jpg)'
  id: totrans-10049
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-10050
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除一个参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-10051
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名称前加上下划线和一个空格来去掉它们。在以下示例中，我们编写了一个计算体积的函数，它接受箱子的三个边长作为输入。由于函数名已经清楚地表明你需要传入三个边长，因此实际上不需要参数标签来使代码更具可读性。
- en: '[PRE1927]'
  id: totrans-10052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1927]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-10053
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处为 side1、在 ➋ 处为 side2、在 ➌ 处为 side3 添加下划线来移除这些边长的参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-10054
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，而无需任何标签。
- en: '[PRE1928]'
  id: totrans-10055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1928]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-10056
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会输出 "The volume of this box is 72."。如果你能够存储结果以便稍后在变量或常量中使用，而不是简单地打印箱子的体积，这不是更有用吗？让我们来看一下如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-10057
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-10058
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-10059
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个箱子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-10060
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的箱子，想知道哪个能装更多的东西。首先，编写一个 `volumeOfBox(_:_:_:)` 函数，返回箱子的体积（Int 类型）：
- en: '[PRE1929]'
  id: totrans-10061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1929]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-10062
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数一个返回值，可以在输入参数之后用破折号和大于符号（->）组成一个箭头，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，通过使用
    `return` 关键字并跟上你想返回的值来返回该值。请记住，如果你编写了一个返回值的函数，**你必须**在函数内部返回该值，否则会出现错误。函数在你返回值后结束。如果你在
    `return` 语句之后再写任何代码，它将被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-10063
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10064
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的箱子调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-10065
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10066
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个边长为 6、5 和 3 的箱子的体积，返回值 90 被存储在一个名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在让我们打印一个关于哪个箱子更大的消息：
- en: '[PRE1930]'
  id: totrans-10067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1930]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10068
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10069
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10070
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，它接受一个测试分数数组并返回平均分。为了得到平均分，你需要将所有分数加起来，然后除以分数的总数。在你的playground中输入以下代码：
- en: '[PRE1931]'
  id: totrans-10071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1931]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10072
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在➊处，我们定义了一个名为`sum`的`Int`变量，并将其初始值设置为0。➋处的`for-in`循环遍历`score`数组中的每个值，并将其添加到`sum`变量中。当循环完成时，`sum`变量保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，这个值就是`score.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10073
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果数组为空怎么办呢？你不能除以零——无论是在数学课上，还是在Swift中。在Swift中，尝试除以零会导致除零错误，并且程序会崩溃。因此，在进行除法时，务必确保你要除的数不是零，这就是我们在➌处通过检查`score.count
    > 0`来确保的。在➍处，我们通过将分数的总和除以数组中分数的个数来返回平均值，使用`return sum / score.count`。没错！你可以返回任何计算结果的表达式，它会被评估为正确的数据类型，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回`sum
    / score.count`，因为它会被评估为`Int`类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10074
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`score.count`不大于零时，我们还需要返回一些内容，否则会出现错误，提示函数缺少返回值。我们通过在`if`语句中添加一个`else`来处理这个问题，返回0
    ➎。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10075
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10076
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给`averageOf()`函数时，如我们在➊处所做的那样，返回的是分数的平均值，并显示在结果面板中。如果你传入一个空数组，如我们在➋处所做的那样，返回值是0。
- en: '**NOTE**'
  id: totrans-10077
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10078
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕`return 0`的`else`语句其实不是必须的。这是因为如果`score.count > 0`，那么函数已经在`return
    sum / score.count`处结束了。因此，如果计算机已经跳过了那个`if`语句，那么我们知道`score.count > 0`一定不成立，我们本可以直接写`return
    0`而不需要将其放在`else`语句中。然而，如果我们保留`else`语句，代码会更清晰，别人也更容易理解。有时，写一点额外的代码，让别人更容易理解，往往比使用一个复杂的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10079
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10080
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10081
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这样，你就可以创建除 Swift 中已包含的类型之外的常量和变量，这在你开发应用时会非常有用！
- en: '![Image](Image00163.jpg)'
  id: totrans-10082
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00163.jpg)'
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-10083
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-10084
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，你可以通过在参数名称前添加下划线和空格来移除它们。在以下示例中，我们编写了一个计算体积的函数，接受盒子的三个边长作为输入。因为函数名称已经清楚地表明需要传入三个边长，所以你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1932]'
  id: totrans-10085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1932]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-10086
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 处在 side1 前面放置下划线， 在 ➋ 处在 side2 前面放置下划线， 以及在 ➌ 处在 side3 前面放置下划线，来移除参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-10087
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需要输入参数值，而无需标签。
- en: '[PRE1933]'
  id: totrans-10088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1933]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-10089
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出 "The volume of this box is 72."。如果你可以将结果存储在变量或常量中，以便稍后使用，而不是简单地打印盒子的体积，岂不是很有用吗？让我们看看如何使用返回值做到这一点！
- en: '**RETURN VALUES**'
  id: totrans-10090
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-10091
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-10092
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的盒子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-10093
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，编写一个 `volumeOfBox(_:_:_:)` 函数，该函数返回一个整数表示盒子的体积：
- en: '[PRE1934]'
  id: totrans-10094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1934]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-10095
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数设置返回值，可以在函数的输入参数 ➊ 后面使用短横线和大于号来形成箭头（->），然后写上返回值的数据类型。注意，你不需要为返回值提供名称，只需要数据类型即可。在函数体内，你可以通过使用
    `return` 关键字后跟你想要返回的值 ➋ 来返回该值。如果你写了一个返回值的函数，那么你*必须*在函数内部返回这个值，否则会报错。函数在返回值后结束。如果你在
    `return` 语句后写了任何代码，它将被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-10096
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10097
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的盒子调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-10098
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10099
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在，让我们打印一条消息，说明哪个盒子更大：
- en: '[PRE1935]'
  id: totrans-10100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1935]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10101
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接收一个测试成绩的数组并返回平均分。为了得到平均分，你需要将所有成绩加在一起，然后除以成绩的总数。在你的
    Playground 中输入以下代码：
- en: '[PRE1936]'
  id: totrans-10104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1936]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有数值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始值设为 0。接下来的 `for-in` 循环（在
    ➋ 处）会遍历 `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环结束时，变量 `sum` 保存了所有成绩的总和。计算出总和后，剩下的就是将其除以成绩的总数，这就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10106
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空怎么办？你不能用零来除——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试用零除会导致“除零错误”，并使程序崩溃。因此，在进行除法时，始终确保你要除的数字不是零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 所做的。然后在 ➍ 处，我们通过将成绩的总和除以数组中成绩的个数来返回平均分，使用 `return sum
    / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给一个新变量的步骤，直接返回 `sum
    / scores.count`，因为它会得到一个 `Int` 类型的结果。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们还需要返回某个值，否则我们会得到一个错误，提示函数缺少返回值。我们通过在 `if` 语句中添加一个
    `else` 来处理这个问题，从而返回 0 ➎ 。你可以通过将函数应用于一个成绩数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10108
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给 `averageOf()` 函数时，正如我们在 ➊ 处所做的，返回的将是成绩的平均值，并显示在结果窗格中。如果你传递一个空数组，正如我们在
    ➋ 处所做的，返回值将是 0。
- en: '**NOTE**'
  id: totrans-10110
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10111
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 `else` 语句其实不是非常必要的。因为如果 `scores.count > 0`，那么函数早就会通过
    `return sum / scores.count` 结束了。所以如果计算机已经通过了那个 `if` 语句，那么我们知道 `scores.count >
    0` 肯定不成立，我们完全可以只写 `return 0`，而不需要放在 `else` 中。然而，如果我们保留 `else` 语句，代码会更清晰，易于理解。有时候，写一点额外的代码来让别人更清楚地理解比使用巧妙的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10113
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种各样令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10114
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)，我们将展示如何通过编写类定义来创建自定义对象。这将让你可以创建具有其他类型的常量和变量，而不是
    Swift 中已有的类型，这在你开发应用时会非常有用！
- en: '**REMOVING AN ARGUMENT LABEL**'
  id: totrans-10115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除参数标签**'
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-10116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前加上一个下划线和空格来移除它们。在下面的例子中，我们编写了一个计算体积的函数，接受箱子的三个边长作为输入。由于函数名已经明确表示需要传入三个边长，所以你实际上不需要参数标签来提高代码的可读性。
- en: '[PRE1937]'
  id: totrans-10117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1937]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-10118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在边长参数前加下划线来移除边长的参数标签，分别在➊位置的side1、➋位置的side2和➌位置的side3。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-10119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，不需要任何标签。
- en: '[PRE1938]'
  id: totrans-10120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1938]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-10121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“The volume of this box is 72.”。如果你能够将箱子的体积存储在一个变量或常量中，而不是仅仅打印出来，这不是更有用吗？让我们来看看如何使用返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-10122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-10123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-10124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个箱子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-10125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的箱子，并且想知道哪个箱子能装下更多东西。首先，编写一个`volumeOfBox(_:_:_:)`函数，返回箱子的体积（Int类型）：
- en: '[PRE1939]'
  id: totrans-10126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1939]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-10127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给函数添加返回值，你需要在函数的输入参数后面用破折号和大于符号（->）组成一个箭头，然后写上返回值的数据类型。注意，你不需要为返回值命名，只需提供数据类型。在函数体内，你使用`return`关键字返回你想要返回的值➋。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值后结束。如果你在`return`语句之后写了任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-10128
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10129
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的箱子上调用函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-10130
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10131
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊位置，`volumeOfBox(_:_:_:)`函数计算了一个边长为6、5、3的箱子的体积，返回值90被存储在名为`volumeOfBox1`的常量中。在➋位置，边长为8、4、2的`volumeOfBox2`被赋值为64。现在我们来打印一条关于哪个箱子更大的消息：
- en: '[PRE1940]'
  id: totrans-10132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1940]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10133
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接受一个成绩数组并返回平均成绩。为了得到平均值，你将成绩相加，然后除以成绩的总数。在你的 Playground
    中输入以下代码：
- en: '[PRE1941]'
  id: totrans-10136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1941]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 Int 类型变量，并将其初始值设为 0。➋ 处的 `for-in` 循环遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量上。当循环完成时，`sum` 变量保存着所有成绩的总和。计算出总和后，剩下的就是将其除以成绩的总数量，简单地说，就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10138
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能用零除数——无论是在数学课上还是在 Swift 中。在 Swift 中，试图用零除数会导致“除以零”错误并使程序崩溃。因此，在进行除法时，始终确保你要除的数不是零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来做到的。在 ➍ 处，我们通过将成绩总和除以数组中成绩的数量来返回平均值，使用的是 `return sum
    / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 `sum
    / scores.count`，因为它会评估为一个 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们还需要返回一些值，否则会出现函数缺少返回值的错误。我们通过在 `if` 语句中添加 `else`
    来处理这个问题，返回 `0` ➎。你可以通过调用该函数来测试，传入一个成绩数组和一个空数组：
- en: '![](Image00166.jpg)'
  id: totrans-10140
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整个测试成绩数组传递给 `averageOf()` 函数时，如我们在 ➊ 处所做的那样，函数会返回成绩的平均值，并在结果面板中显示。如果你传递的是一个空数组，如我们在
    ➋ 处所做的那样，返回值将是 `0`。
- en: '**NOTE**'
  id: totrans-10142
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10143
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 `else` 语句其实并不是必须的。这是因为如果 `scores.count > 0`，那么函数会在
    `return sum / scores.count` 时已经结束。所以，如果计算机执行到这个 `if` 语句之后，我们就知道 `scores.count
    > 0` 肯定不为真，实际上我们可以直接写 `return 0`，而不需要放在 `else` 中。然而，如果我们保留 `else` 语句，代码会更清晰、更易于理解。有时候，写多一点代码让别人更容易理解，比用一个复杂的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10145
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包增加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，能够做各种各样的神奇事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10146
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建具有不同于Swift中已包含类型的常量和变量，在你开发应用时非常有用！
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  id: totrans-10147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在函数调用中使用任何参数标签，可以通过在参数名前加上一个下划线和一个空格来移除它们。在以下示例中，我们编写了一个用于计算体积的函数，输入为盒子的三个边。由于函数名称已经明确说明你需要传入三个边，因此实际上你不需要参数标签来提高代码的可读性。
- en: '[PRE1942]'
  id: totrans-10148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1942]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-10149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊的side1、➋的side2和➌的side3前面加上下划线来移除参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-10150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你调用这个函数时，只需输入参数值而无需任何标签。
- en: '[PRE1943]'
  id: totrans-10151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1943]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-10152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"该盒子的体积是72。"。如果你不仅仅是打印盒子的体积，而是希望将结果存储起来以便稍后在变量或常量中使用，这不是更有用吗？让我们来看看如何通过返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-10153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-10154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-10155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-10156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个盒子能装更多东西。首先，编写一个volumeOfBox(_:_:_:)函数，返回一个表示盒子体积的Int值：
- en: '[PRE1944]'
  id: totrans-10157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1944]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-10158
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数提供返回值，请在函数的输入参数后面使用一个短横线和一个大于符号，形成箭头（->），然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，使用return关键字后跟你要返回的值来返回该值。➋
    如果你编写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在你返回值后结束。如果你在return语句后写了任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-10159
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10160
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用这个函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-10161
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10162
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，volumeOfBox(_:_:_:)函数计算了一个边长为6、5、3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋，边长为8、4、2的volumeOfBox2被赋值为64。现在让我们打印出哪个盒子更大的信息：
- en: '[PRE1945]'
  id: totrans-10163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1945]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10164
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串"Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接收一个测试分数数组并返回平均分。为了得到平均值，你需要将所有分数相加，然后除以分数的总数。在你的
    Playground 中输入以下代码：
- en: '[PRE1946]'
  id: totrans-10167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1946]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个 Int 类型的变量 `sum`，并将它初始化为 0。 ➋ 处的 `for-in` 循环会遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量上。当循环完成时，变量 `sum` 就保存了所有分数的总和。计算完总和后，剩下的就是将它除以分数的总数，简单来说就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10169
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误，并崩溃你的程序。因此，在进行除法时，务必确保你要除的数字不是零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来做到的。在 ➍ 处，我们通过将总分除以数组中分数的个数来返回平均值，使用 `return sum /
    scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 `sum
    / scores.count`，因为它的计算结果是一个 Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回某个值，否则我们会得到函数缺少返回值的错误。我们通过在 `if` 语句中添加一个
    `else` 来处理这个问题，它返回 0 ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10171
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传入 `averageOf()` 函数时，就像我们在 ➊ 处所做的那样，分数的平均值会被返回并显示在结果窗格中。如果你传入一个空数组，正如我们在
    ➋ 处所做的那样，返回值将是 0。
- en: '**NOTE**'
  id: totrans-10173
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10174
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，`else` 语句围绕着 `return 0` 其实并不是必需的。因为如果 `scores.count > 0`，那么函数已经通过 `return
    sum / scores.count` 结束了。所以如果程序已经通过了那个 `if` 语句，我们就知道 `scores.count > 0` 可能不为真，直接使用
    `return 0` 而不需要把它包含在 `else` 中。然而，如果我们保留 `else` 语句，代码会更清晰、更易于理解。有时，为了让其他人更容易理解，写一点多余的代码比使用复杂的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10176
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10177
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建具有不同类型的常量和变量，而不仅限于Swift中已经包含的类型，这在你开发应用时会非常有用！
- en: '[PRE1947]'
  id: totrans-10178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1947]'
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-10179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在➊处的`side1`、➋处的`side2`和➌处的`side3`前面加下划线来移除参数标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-10180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需输入参数值，而不需要标签。
- en: '[PRE1948]'
  id: totrans-10181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1948]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-10182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"The volume of this box is 72."。如果不仅仅是打印盒子的体积，而是将结果存储到变量或常量中以便后续使用，不是更有用吗？让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-10183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-10184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将`volumeOfBoxWithSides(_:_:_:)`函数重写为返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-10185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-10186
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，编写一个`volumeOfBox(_:_:_:)`函数，返回盒子体积的`Int`类型：
- en: '[PRE1949]'
  id: totrans-10187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1949]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-10188
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数返回值，在函数的输入参数后➊使用一个破折号和大于号组成箭头（->），然后输入返回值的数据类型。注意，返回值不需要命名，只需要数据类型。在函数体内，使用`return`关键字加上你想返回的值来返回该值➋。如果你编写的函数需要返回一个值，那么你*必须*在函数内部返回该值，否则会报错。函数在返回值之后结束。如果在`return`语句之后编写任何代码，这些代码将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-10189
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10190
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数对两个不同的盒子进行测试，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-10191
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10192
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`volumeOfBox(_:_:_:)`函数计算一个边长为6、5和3的盒子的体积，返回值90被存储在一个名为`volumeOfBox1`的常量中。在➋处，边长为8、4和2的`volumeOfBox2`被赋值为64。现在我们来打印一条关于哪个盒子更大的消息：
- en: '[PRE1950]'
  id: totrans-10193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1950]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10194
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在调试控制台看到输出的字符串："Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接收一个测试成绩数组并返回平均成绩。要计算平均值，你需要将所有成绩相加，然后除以成绩的总数。在你的playground中输入以下代码：
- en: '[PRE1951]'
  id: totrans-10197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1951]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 中，我们定义了一个名为 sum 的 Int 类型变量，并将其初始值设为 0。在 ➋ 中的 for-in 循环遍历
    scores 数组中的每个值，并将其添加到 sum 变量中。当循环完成时，变量 sum 保存了所有成绩的总和。计算完总和后，我们只需要将其除以成绩的总数，也就是
    scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10199
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办？你不能将一个数除以零——在数学课上是这样，在 Swift 中也是如此。在 Swift 中，尝试除以零会给你一个除零错误，并使程序崩溃。因此，在进行除法时，一定要确保除数不为零，这就是我们在
    ➌ 中通过检查 scores.count > 0 来确保的。在 ➍ 中，我们通过将成绩总和除以数组中的成绩数量来返回平均值，使用 return sum /
    scores.count。没错！你可以返回任何求值为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给一个新变量的步骤，直接返回 sum / scores.count，因为它会求值为
    Int 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们还需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加 else 来处理这个问题，返回
    0 ➎。你可以通过调用函数传入一个成绩数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10201
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10202
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像在 ➊ 中那样将完整的成绩数组传递给 averageOf() 函数时，返回的是成绩的平均值，并在结果窗格中显示。如果你传入一个空数组，就像在 ➋
    中那样，返回值为 0。
- en: '**NOTE**'
  id: totrans-10203
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10204
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0 周围的 else 语句其实并不是必须的。这是因为如果 scores.count > 0 ，那么函数已经通过 return
    sum / scores.count 结束了。所以，如果计算机已经跳过了那个 if 语句，那么我们知道 scores.count > 0 一定不成立，我们可以直接使用
    return 0 而无需将其包裹在 else 中。然而，如果我们保留 else 语句，代码会更清晰，更容易理解。有时候，写一些额外的代码使别人更容易理解比使用巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10206
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中广泛应用，用来完成各种神奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第8章](text00018.html#ch08) 中，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建除 Swift 中已有类型外的常量和变量，这在创建应用程序时非常有用！
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  id: totrans-10208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 ➊ 中、➋ 中、➌ 中为 side1、side2、side3 前面加上下划线，去除了这些参数的标签。
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-10209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用函数时，只需要输入参数值，而不需要任何标签。
- en: '[PRE1952]'
  id: totrans-10210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1952]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-10211
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将输出 "The volume of this box is 72."。如果你不仅仅是打印箱子的体积，而是能够将结果存储在一个变量或常量中以供后续使用，那该多有用呢？让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-10212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-10213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 volumeOfBoxWithSides(_:_:_:) 函数，让它返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-10214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个是更大的箱子？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-10215
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的箱子，想知道哪个箱子能装更多的东西。首先，写一个返回 Int 类型箱子体积的 volumeOfBox(_:_:_:) 函数：
- en: '[PRE1953]'
  id: totrans-10216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1953]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-10217
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数一个返回值，在函数的输入参数后面使用一个箭头符号（->），然后输入返回值的数据类型 ➊。注意，返回值不需要命名，只需指定数据类型。在函数体内，你通过使用
    return 关键字后跟你想返回的值来返回该值 ➋。如果你写一个返回值的函数，那么你*必须*在函数内返回该值，否则会报错。函数在返回值后结束。如果你在 return
    语句后再写任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-10218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10219
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的箱子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-10220
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10221
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算了一个长、宽、高分别为 6、5、3 的箱子的体积，返回值 90 被存储在名为 volumeOfBox1
    的常量中。在 ➋ 处，给定长、宽、高分别为 8、4、2 的 box2 的体积为 64。现在让我们打印一条关于哪个箱子更大的消息：
- en: '[PRE1954]'
  id: totrans-10222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1954]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10223
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10225
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，它接受一个测试成绩的数组，并返回平均分。为了计算平均分，你需要将所有成绩加在一起，然后除以总成绩数。在你的
    playground 中输入以下代码：
- en: '[PRE1955]'
  id: totrans-10226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1955]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有数值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 类型变量，并将其初始值设置为 0。➋ 处的 for-in 循环会遍历
    scores 数组中的每个值，并将其加到 sum 变量中。当循环完成时，sum 变量存储了所有分数的总和。在计算完总和后，剩下的就是将其除以分数的总数，即
    scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10228
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空怎么办？你不能除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除零错误并崩溃你的程序。因此，在进行除法运算时，始终确保你将要除的数字不为零，这就是我们在➌处通过检查`scores.count
    > 0`来做到的。在➍处，我们通过将分数的总和除以数组中分数的数量来返回平均值，使用`return sum / scores.count`。没错！你可以返回任何计算后得到正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值分配给新变量的步骤，直接返回`sum
    / scores.count`，因为它计算的结果是一个`Int`类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`scores.count`不大于零时，我们也需要返回一些内容，否则会出现函数缺少返回值的错误。我们通过在`if`语句中添加`else`来处理这个问题，`else`返回0
    ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10230
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10231
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整套测试分数传入`averageOf()`函数时，就像我们在➊处所做的那样，返回的平均值会显示在结果面板中。如果传入一个空数组，就像我们在➋处所做的那样，返回值是0。
- en: '**NOTE**'
  id: totrans-10232
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10233
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕`return 0`的`else`语句其实并不是必需的。这是因为如果`scores.count > 0`，函数就会通过`return
    sum / scores.count`结束。所以如果计算机已经通过了那个`if`语句，那么我们就知道`scores.count > 0`一定不成立，直接用`return
    0`就行，而不需要用`else`来包裹。然而，如果我们保留`else`语句，代码会更清晰、更易于理解。有时，写一些额外的代码使别人更容易理解，比用一个巧妙的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10235
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包增加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，能够做各种各样的奇妙事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10236
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建除Swift中已包含的类型之外的常量和变量，这在创建应用程序时会非常有用！
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  id: totrans-10237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你调用这个函数时，只需输入参数值，而不需要任何标签。
- en: '[PRE1956]'
  id: totrans-10238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1956]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-10239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"The volume of this box is 72."。如果你不仅仅是打印盒子的体积，而是能将结果存储在变量或常量中，供以后使用，这不是更有用吗？让我们来看看如何使用返回值实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-10240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-10241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-10242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-10243
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并想知道哪个可以装更多的东西。首先，编写一个`volumeOfBox(_:_:_:)`函数，返回一个表示盒子体积的`Int`值：
- en: '[PRE1957]'
  id: totrans-10244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1957]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-10245
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数添加返回值，在函数的输入参数之后➊使用一个破折号和大于号形成箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，使用`return`关键字后跟要返回的值➋来返回该值。如果你编写一个返回值的函数，*你必须*在函数内部返回该值，否则会出现错误。函数在返回值之后结束。如果在`return`语句之后编写任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-10246
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10247
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数以查看其效果：
- en: '![](Image00165.jpg)'
  id: totrans-10248
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10249
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，`volumeOfBox(_:_:_:)`函数计算了一个长宽高分别为6、5、3的盒子的体积，并将返回值90存储在一个名为`volumeOfBox1`的常量中。在➋，边长为8、4、2的`volumeOfBox2`被赋值为64。现在，让我们打印一条消息，说明哪个盒子更大：
- en: '[PRE1958]'
  id: totrans-10250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1958]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10251
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台中看到字符串“Box 1 is the bigger box.”（盒子1更大）。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，接受一个包含考试成绩的数组，并返回平均分。为了计算平均分，你需要将所有成绩相加，然后除以成绩的总数。在你的Playground中输入以下代码：
- en: '[PRE1959]'
  id: totrans-10254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1959]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在➊，我们定义了一个名为`sum`的`Int`变量，并将其初始值设置为0。➋处的`for-in`循环遍历`score`数组中的每个值，并将其加到`sum`变量中。当循环完成后，`sum`变量将保存所有成绩的总和。计算总和之后，剩下的就是将其除以成绩的总数，成绩总数就是`score.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10256
  prefs: []
  type: TYPE_NORMAL
  zh: 可是如果数组为空怎么办？你不能除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致“除以零”错误并崩溃程序。因此，在进行除法操作时，始终确保你要除的数不是零，这就是我们通过在➌检查`score.count
    > 0`来确保的。在➍，我们通过将所有成绩的总和除以数组中的成绩个数来返回平均分，使用`return sum / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋给新变量的步骤，直接返回`sum
    / scores.count`，因为它会计算出一个`Int`值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们也需要返回一些值，否则会出现函数缺少返回值的错误。我们通过在if语句中添加else来处理这个问题，返回0➎。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10258
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10259
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整个测试分数数组传递给averageOf()函数时，就像我们在➊处所做的那样，返回的是分数的平均值，并显示在结果面板中。如果你传入一个空数组，就像我们在➋处所做的那样，返回值为0。
- en: '**NOTE**'
  id: totrans-10260
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10261
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0周围的else语句其实并不是必须的。这是因为如果scores.count > 0，那么函数会在return sum /
    scores.count时已经结束。所以，如果计算机已经通过了那个if语句，我们就知道scores.count > 0一定不成立，那时我们可以直接返回0，而不需要将它放在else语句中。然而，如果我们保留else语句，代码会更清晰，更容易理解。有时候，写一些额外的代码让其他人更容易理解，比起使用复杂的快捷方式来得更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10263
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚给你的Swift工具包添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，能够做各种令人惊奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10264
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你创建类型不同于Swift已有类型的常量和变量，在你创建应用程序时非常有用！
- en: '[PRE1960]'
  id: totrans-10265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1960]'
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-10266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出“这个盒子的体积是72。”如果你能够将结果存储到变量或常量中，以便后续使用，而不仅仅是打印盒子的体积，那该多好！让我们看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-10267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-10268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重新编写volumeOfBoxWithSides(_:_:_:)函数，改为返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-10269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-10270
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并且想知道哪个能装更多东西。首先，编写一个volumeOfBox(_:_:_:)函数，返回盒子的体积（Int类型）：
- en: '[PRE1961]'
  id: totrans-10271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1961]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-10272
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数添加返回值，使用一个破折号和一个大于号组成一个箭头(->)，紧跟在函数的输入参数之后➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名字，只需指定数据类型即可。在函数体内，你通过使用return关键字后跟你想返回的值来返回该值➋。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在你返回值后结束。如果你在return语句后写了任何代码，它将被忽略，因为return语句会导致函数退出。
- en: '![Image](Image00164.jpg)'
  id: totrans-10273
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10274
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-10275
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10276
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算了边长分别为6、5和3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋处，边长分别为8、4和2的volumeOfBox2的值为64。现在让我们打印一条消息，说明哪个盒子更大：
- en: '[PRE1962]'
  id: totrans-10277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1962]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10278
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台中看到字符串“Box 1 is the bigger box.”
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10280
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，接收一个测试分数数组并返回平均分。为了获得平均分，你需要将分数相加，然后除以总分数。请在你的playground中输入以下代码：
- en: '[PRE1963]'
  id: totrans-10281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1963]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10282
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在➊处，我们定义了一个名为sum的Int类型变量，并将其初始值设为0。在➋处的for-in循环遍历scores数组中的每个值，并将其加到sum变量中。当循环完成时，变量sum保存了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数，这个值就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10283
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能将一个数除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除以零的错误，并使程序崩溃。因此，在做除法时，一定要确保你将要除的数不是零，这就是我们通过在➌处检查scores.count
    > 0来确保的。在➍处，我们通过将分数总和除以数组中分数的数量来返回平均值，使用的是`return sum / scores.count`。没错！你可以返回任何能够计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回`sum
    / scores.count`，因为它会计算出一个Int类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们也需要返回某个值，否则会出现缺少返回值的错误。我们通过在if语句中添加else分支来处理这个问题，返回0
    ➎。你可以通过传入一个分数数组和一个空数组来测试这个代码：
- en: '![](Image00166.jpg)'
  id: totrans-10285
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10286
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传入averageOf()函数时，正如我们在➊处所做的那样，返回的是分数的平均值，并在结果面板中显示。如果传入一个空数组，正如我们在➋处所做的那样，返回值是0。
- en: '**NOTE**'
  id: totrans-10287
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10288
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0周围的else语句其实并不是必须的。这是因为如果scores.count > 0，函数将已经通过return sum
    / scores.count结束。所以，如果计算机已经通过了那个if语句，我们就知道scores.count > 0肯定不成立，我们可以直接返回0，而不需要将其放在else中。然而，如果我们保留else语句，代码会更清晰易懂。有时候，写多一点代码来让别人更容易理解，比使用巧妙的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10290
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为自己的Swift工具箱增加了一个重要工具——创建并调用你自己的函数！函数在编程中被广泛使用，用来做各种了不起的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10291
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建类型不同于Swift中已有类型的常量和变量，这在你开发应用时非常有用！
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  id: totrans-10292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将输出"The volume of this box is 72."。如果你可以将结果存储到变量或常量中，而不是简单地打印盒子的体积，这样是不是更有用呢？让我们来看看如何通过返回值来实现这一点！
- en: '**RETURN VALUES**'
  id: totrans-10293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-10294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写volumeOfBoxWithSides(_:_:_:)函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-10295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-10296
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并想知道哪个能装更多的东西。首先，编写一个名为volumeOfBox(_:_:_:)的函数，返回盒子的体积（Int类型）：
- en: '[PRE1964]'
  id: totrans-10297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1964]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-10298
  prefs: []
  type: TYPE_NORMAL
  zh: 要为一个函数设置返回值，使用一个短横线和一个大于号形成箭头（->），紧跟在函数的输入参数之后➊，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，你使用return关键字，后跟你想返回的值➋。如果你编写了一个返回值的函数，那么你*必须*在函数内返回这个值，否则会出现错误。函数在返回值后结束。如果你在return语句后写任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-10299
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10300
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个不同的盒子调用这个函数，看看它的效果：
- en: '![](Image00165.jpg)'
  id: totrans-10301
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10302
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算一个边长为6、5和3的盒子的体积，返回值90被存储在名为volumeOfBox1的常量中。在➋处，边长为8、4和2的volumeOfBox2被赋值为64。现在，让我们打印一条关于哪个盒子更大的信息：
- en: '[PRE1965]'
  id: totrans-10303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1965]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10304
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串"Box 1 is the bigger box."。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，接受一个测试分数数组并返回平均分。为了得到平均分，你需要将所有分数加在一起，然后除以总的分数数量。请在你的playground中输入以下代码：
- en: '[PRE1966]'
  id: totrans-10307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1966]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10308
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为`sum`的`Int`变量，并将它初始化为0。 ➋ 处的`for-in`循环遍历分数数组中的每个值，并将其加到`sum`变量中。当循环完成时，`sum`变量保存了所有分数的总和。计算总和之后，剩下的就是将其除以总的分数数量，这就是`scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10309
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组是空的呢？你不能将一个数除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除以零错误，并且程序崩溃。因此，在进行除法时，始终确保你要除的数不是零，这就是我们通过检查`score.count
    > 0`在 ➌ 处做的。然后，在 ➍ 处，我们通过将所有分数的总和除以数组中分数的数量来返回平均值，使用`return sum / scores.count`。没错！你可以返回任何能够计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回`sum
    / scores.count`，因为它的计算结果是一个`Int`类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`score.count`不大于零时，我们也需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在`if`语句中添加`else`来处理这一点，返回0
    ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10311
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10312
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像在 ➊ 中那样将完整的测试分数数组传递给`averageOf()`函数时，函数会返回分数的平均值并显示在结果面板中。如果你传递的是空数组，就像在
    ➋ 中那样，返回值将是0。
- en: '**NOTE**'
  id: totrans-10313
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10314
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，`else`语句中的`return 0`其实并不是必需的。这是因为如果`score.count > 0`，那么函数已经通过`return
    sum / scores.count`提前结束了。所以，如果计算机已经通过了这个`if`语句，我们就知道`score.count > 0`一定不为真，我们完全可以只写`return
    0`而不需要将它包含在`else`中。然而，如果我们保留`else`语句，代码会更清晰、更易于理解。有时候，写一些额外的代码以使代码更容易被他人理解，比使用一个巧妙的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10316
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用于做各种各样的神奇事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10317
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第8章](text00018.html#ch08)，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建类型不同于 Swift 中已有类型的常量和变量，这在你开发应用时非常有用！
- en: '**RETURN VALUES**'
  id: totrans-10318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-10319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写 `volumeOfBoxWithSides(_:_:_:)` 函数，使其返回体积，而不是将其打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-10320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-10321
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个可以装更多的东西。首先，写一个 `volumeOfBox(_:_:_:)` 函数来返回盒子的体积，返回值为 Int：
- en: '[PRE1967]'
  id: totrans-10322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1967]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-10323
  prefs: []
  type: TYPE_NORMAL
  zh: 要为一个函数提供返回值，可以在函数的输入参数后面使用一个破折号和一个大于号组成箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值命名，只需要提供数据类型。在函数体内，你可以使用
    `return` 关键字返回你想返回的值 ➋。如果你写一个返回值的函数，那么你*必须*在函数内部返回该值，否则会出现错误。函数在返回值后结束。如果你在 `return`
    语句后写任何代码，它将被忽略，因为 `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-10324
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10325
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数，使用两个不同的盒子来查看它的运行效果：
- en: '![](Image00165.jpg)'
  id: totrans-10326
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10327
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1968]'
  id: totrans-10328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1968]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10329
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10331
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，它接受一个测试分数的数组，并返回平均分数。为了得到平均分数，你需要将所有分数加在一起，然后除以分数的总数。请在你的
    playground 中输入以下代码：
- en: '[PRE1969]'
  id: totrans-10332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1969]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10333
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义一个名为 sum 的 Int 类型变量，并将其初始值设为 0。 ➋ 处的 for-in 循环会遍历分数数组中的每个值，并将其加到
    sum 变量中。循环完成后，变量 sum 存储了所有分数的总和。在我们计算出总和后，剩下的就是将其除以分数的总数，分数总数就是 `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10334
  prefs: []
  type: TYPE_NORMAL
  zh: 可是如果数组为空呢？你不能除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致“除以零”错误并使程序崩溃。因此，在进行除法时，始终确保你要除的数不为零，这就是我们在
    ➌ 中通过检查`scores.count > 0`来做的。在 ➍ 中，我们通过将分数的总和除以数组中分数的数量来返回平均值，即`return sum / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出来的平均值赋给一个新变量的步骤，直接返回`sum
    / scores.count`，因为它会被计算为一个`Int`类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`scores.count`不大于零时，我们还需要返回一些内容，否则我们会遇到函数缺少返回值的错误。我们通过在`if`语句中添加`else`来处理这个问题，它返回0
    ➎。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10336
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10337
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整个测试分数数组传递给`averageOf()`函数时，如我们在 ➊ 中所做的，分数的平均值会被返回并显示在结果窗格中。如果你传递一个空数组，如我们在
    ➋ 中所做的，返回值为0。
- en: '**NOTE**'
  id: totrans-10338
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10339
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，`else`语句围绕`return 0`并不是必需的。因为如果`scores.count > 0`，那么函数已经通过`return sum
    / scores.count`提前结束。所以，如果计算机已经越过了这个`if`语句，我们就知道`scores.count > 0`一定不为真，我们本来可以直接用`return
    0`而不需要将其包含在`else`语句中。然而，如果我们保留`else`语句，代码会更清晰、更易懂。有时候，为了让其他人更容易理解，写多一点代码比使用一些复杂的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10341
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具包添加了一个重要工具——创建并调用自己的函数！函数在编程中被广泛使用，用来做各种各样的惊人事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10342
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将允许你使用除Swift中已包含的类型之外的常量和变量，这在创建应用程序时会非常有用！
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  id: totrans-10343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重写`volumeOfBoxWithSides(_:_:_:)`函数，使其返回体积，而不是打印到控制台。
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-10344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-10345
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个可以装更多东西。首先，编写一个`volumeOfBox(_:_:_:)`函数，返回一个盒子的体积（Int类型）：
- en: '[PRE1970]'
  id: totrans-10346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1970]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-10347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给一个函数提供返回值，使用一个短横线和大于号形成一个箭头（->）紧接着函数的输入参数 ➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，你使用
    return 关键字返回值，后面跟着你想要返回的值 ➋ 。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则你会得到错误。函数在返回值后结束。如果你在
    return 语句之后编写了任何代码，它将被忽略，因为 return 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-10348
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10349
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数，传入两个不同的盒子，看看它的效果：
- en: '![](Image00165.jpg)'
  id: totrans-10350
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10351
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条关于哪个盒子更大的信息：
- en: '[PRE1971]'
  id: totrans-10352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1971]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10353
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10355
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，接受一个测试分数的数组并返回平均分数。为了获得平均值，你需要将分数加在一起，然后除以分数的总数。在你的
    playground 中输入以下代码：
- en: '[PRE1972]'
  id: totrans-10356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1972]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10357
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义一个名为 sum 的整型变量，并将其初始值设为 0。在 ➋ 处的 for-in 循环遍历 scores
    数组中的每个值，并将其加到 sum 变量中。当循环完成时，变量 sum 存储了所有分数的总和。计算完总和后，剩下的就是将总和除以分数的总个数，这个总数就是
    scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10358
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组是空的呢？你不能将某个数除以零——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并崩溃你的程序。因此，在做除法时，始终确保你要除的数字不为零，这就是我们在
    ➌ 处通过检查 scores.count > 0 来确保的。在 ➍ 处，我们通过将分数的总和除以数组中分数的数量来返回平均值，使用 return sum /
    scores.count 。没错！你可以返回任何评估为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 sum / scores.count，因为它评估为一个
    Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们也需要返回某些值，否则我们会遇到缺少返回值的错误。我们通过在 if 语句中添加 else 来处理这个问题，返回
    0 ➎ 。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10360
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10361
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给 averageOf() 函数时，如我们在➊处所做的，成绩的平均值将被返回并显示在结果窗格中。如果你传递一个空数组，如我们在➋处所做的，返回值将是
    0。
- en: '**NOTE**'
  id: totrans-10362
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10363
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 else 语句其实并不必要。因为如果 `scores.count > 0`，那么函数已经会通过 `return
    sum / scores.count` 提前结束。所以如果程序执行到了那条 if 语句之后，我们可以知道 `scores.count > 0` 肯定不成立，我们完全可以只写
    `return 0`，而不需要将它包裹在 else 语句中。然而，如果我们保留 else 语句，代码会更清晰，更容易理解。有时候，写一些额外的代码，确保别人能更容易理解，可能比使用复杂的简写更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10365
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包增加了一个重要工具——创建并调用你自己的函数！函数在编程中被广泛使用，用来做各种神奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10366
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)，我们将展示如何通过编写类定义来创建自定义对象。这将让你创建具有不同类型的常量和变量，而不仅仅是
    Swift 中已包含的类型，这在你创建应用时会非常有用！
- en: '**WHICH IS THE BIGGER BOX?**'
  id: totrans-10367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**哪个盒子更大？**'
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-10368
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，想知道哪个能装更多的东西。首先，编写一个 volumeOfBox(_:_:_:) 函数，返回一个 Int 类型的盒子体积：
- en: '[PRE1973]'
  id: totrans-10369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1973]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-10370
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给函数添加返回值，在函数的输入参数➊后面使用一个破折号和大于符号组成箭头（->），然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，使用
    `return` 关键字后跟你想返回的值来返回该值➋。如果你编写了一个返回值的函数，那么你*必须*在函数内部返回该值，否则会报错。函数在你返回值之后结束。如果你在
    `return` 语句之后再写任何代码，它将被忽略，因为 `return` 会使函数退出。
- en: '![Image](Image00164.jpg)'
  id: totrans-10371
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10372
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个函数来对比两个不同的盒子，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-10373
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10374
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，volumeOfBox(_:_:_:) 函数计算了一个边长分别为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在➋，边长分别为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在我们来打印一条消息，看看哪个盒子更大：
- en: '[PRE1974]'
  id: totrans-10375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1974]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10376
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10378
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们写一个函数，它接受一个测试分数数组并返回平均分数。为了得到平均值，你需要将分数加在一起，然后除以总分数的数量。在你的Playground中输入以下代码：
- en: '[PRE1975]'
  id: totrans-10379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1975]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10380
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在➊处，我们定义了一个名为sum的Int变量，并将其初始值设为0。➋处的for-in循环遍历scores数组中的每个值，并将其加到sum变量中。当循环完成时，变量sum保存了所有分数的总和。计算完总和后，剩下的就是将其除以总分数的数量，即scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10381
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果数组为空呢？你不能用零来除——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除以零错误并使程序崩溃。因此，在进行除法时，必须确保你要除的数不是零，这正是我们通过在➌处检查scores.count
    > 0来做到的。在➍处，我们通过将分数总和除以数组中分数的数量来返回平均值，使用return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回sum
    / scores.count，因为它的值是一个Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10382
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们也需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在if语句中添加一个else来处理这一点，它会返回0
    ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10383
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10384
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传入averageOf()函数时，正如我们在➊所做的，返回的平均值会显示在结果面板中。如果你传入一个空数组，正如我们在➋所做的，返回值将是0。
- en: '**NOTE**'
  id: totrans-10385
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10386
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句实际上不是必须的。因为如果scores.count > 0，那么函数已经通过return sum /
    scores.count结束了。所以，如果程序已经执行到了那个if语句后，我们知道scores.count > 0肯定不为真，我们本可以直接用return
    0，而不需要将它包裹在else语句中。然而，如果我们保留else语句，代码会更清晰易懂。有时候，为了让别人更容易理解，写一些额外的代码比使用复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10388
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要的工具——创建并调用你自己的函数！函数在编程中被广泛使用，用来做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10389
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第8章](text00018.html#ch08) 中，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你创建具有与 Swift 中已包含类型不同的常量和变量，当你创建应用程序时这将非常有用！
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  id: totrans-10390
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个形状不同的盒子，并想知道哪个能装更多的东西。首先，编写一个返回盒子体积的 `volumeOfBox(_:_:_:)` 函数，返回值为一个 `Int`
    类型：
- en: '[PRE1976]'
  id: totrans-10391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1976]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-10392
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数设置返回值，使用破折号和大于符号形成箭头（->），并紧跟在函数的输入参数之后 ➊，然后输入返回值的数据类型。请注意，你不需要为返回值提供名称，只需要提供数据类型。在函数体内，使用
    `return` 关键字后跟你想要返回的值来返回该值 ➋。如果你编写一个返回值的函数，那么你*必须*在函数内返回该值，否则会报错。函数在你返回值后结束。如果在返回语句之后编写任何代码，它将被忽略，因为
    `return` 会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-10393
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10394
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它的效果：
- en: '![](Image00165.jpg)'
  id: totrans-10395
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10396
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 `volumeOfBox1`
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 `volumeOfBox2` 被赋值为 64。现在让我们打印一条关于哪个盒子更大的信息：
- en: '[PRE1977]'
  id: totrans-10397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1977]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10398
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台中看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10400
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接受一个测试成绩的数组并返回平均成绩。为了获得平均值，你需要将所有成绩相加，然后除以成绩的总数。在你的
    playground 中输入以下代码：
- en: '[PRE1978]'
  id: totrans-10401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1978]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10402
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义一个名为 `sum` 的 `Int` 变量并将其初始值设置为 0。在 ➋ 处的 `for-in` 循环遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成后，`sum` 变量存储了所有成绩的总和。计算出总和后，剩下的就是将其除以成绩的总数，这个值就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10403
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致“除以零”错误并崩溃程序。因此，在进行除法时，始终确保你要除的数不是零，这就是我们在
    ➌ 通过检查 scores.count > 0 来做到的。在 ➍ ，我们通过用 return sum / scores.count 将成绩的总和除以成绩数组中的元素个数来返回平均值。没错！你可以返回任何能求得正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回
    sum / scores.count，因为它会求出一个 Int 类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 scores.count 不大于零时，我们也需要返回一个值，否则会出现缺少 return 的错误。我们通过在 if 语句中添加 else
    来处理这个问题，返回 0 ➎。你可以通过在一个成绩数组和一个空数组上调用函数来测试这段代码：
- en: '![](Image00166.jpg)'
  id: totrans-10405
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10406
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像在 ➊ 所做的那样将完整的测试成绩数组传递给 averageOf() 函数时，返回的是成绩的平均值，并显示在结果面板中。如果你像在 ➋ 所做的那样传递一个空数组，返回值将是
    0。
- en: '**NOTE**'
  id: totrans-10407
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10408
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不必要。这是因为如果 scores.count > 0，那么函数已经通过 return
    sum / scores.count 结束了。所以如果计算机已经跳过了那个 if 语句，我们就知道 scores.count > 0 一定不成立，我们可以直接写一个
    return 0，而不需要放在 else 语句中。然而，如果我们保留 else 语句，代码会更清晰，容易理解。有时候，写一点额外的代码来让其他人更容易理解比使用一个复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10410
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要的工具——创建并调用你自己的函数！函数在编程中被广泛使用，可以做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10411
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建类型不同于 Swift 中已有类型的常量和变量，这在你开发应用时会非常有用！
- en: '[PRE1979]'
  id: totrans-10412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1979]'
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-10413
  prefs: []
  type: TYPE_NORMAL
  zh: 要给函数返回一个值，在函数的输入参数后面使用破折号和大于号形成箭头（->），然后输入返回值的数据类型➊。注意，返回值不需要命名，只需要提供数据类型。在函数体内，使用return关键字后跟要返回的值➋来返回该值。如果你写了一个返回值的函数，那么你*必须*在函数内返回该值，否则会报错。函数在返回值后结束。如果在return语句后编写任何代码，它将被忽略，因为return会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-10414
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10415
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个函数在两个不同的盒子上看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-10416
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10417
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算一个边长为6、5、3的盒子的体积，返回值90存储在常量volumeOfBox1中。在➋处，边长为8、4、2的volumeOfBox2的值为64。现在让我们打印出一个消息，告诉我们哪个盒子更大：
- en: '[PRE1980]'
  id: totrans-10418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1980]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10419
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10421
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据某个条件返回不同的值。让我们写一个函数，它接受一个测试分数数组并返回平均分。为了得到平均值，你需要将分数加起来，然后除以分数的总数。在你的playground中输入以下代码：
- en: '[PRE1981]'
  id: totrans-10422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1981]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10423
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有数值的总和。在➊处，我们定义了一个名为sum的Int变量，并将其初始值设置为0。在➋处，for-in循环遍历scores数组中的每个值，并将其加到sum变量中。当循环完成后，变量sum保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，这就是scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10424
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果数组为空呢？你不能用零去除任何东西——无论是在数学课上还是在Swift中。在Swift中，尝试用零除会导致除零错误并崩溃程序。因此，在进行除法时，务必确保你要除的数不是零，这就是我们在➌处通过检查scores.count
    > 0来保证的。在➍处，我们通过用return sum / scores.count来返回平均值，即用总分除以数组中的分数数量。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋值给新变量的步骤，直接返回sum
    / scores.count，因为它的结果是Int类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10425
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们也需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在if语句中添加else来处理这种情况，返回0➎。你可以通过调用该函数并传入一个包含分数的数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10426
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10427
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给`averageOf()`函数时，正如我们在➊处所做的，返回的平均值会显示在结果面板中。如果你传递一个空数组，如我们在➋处所做的，返回值将是0。
- en: '**NOTE**'
  id: totrans-10428
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10429
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕`return 0`的`else`语句其实并不必要。因为如果`scores.count > 0`，函数将已经通过`return sum
    / scores.count`结束。所以，如果计算机已经通过了这个`if`语句，那么我们知道`score.count > 0`一定不成立，我们可以直接写`return
    0`而不需要将其包裹在`else`中。然而，保留`else`语句让代码更清晰、更易懂。有时为了让其他人更容易理解，写一点额外的代码比使用一个巧妙的捷径要更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10431
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要工具——创建并调用你自己的函数！函数在编程中被广泛使用，用来完成各种令人惊叹的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10432
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将允许你创建除Swift已包含的类型以外的常量和变量，这在创建应用程序时会非常有用！
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  id: totrans-10433
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个函数设置返回值，在函数的输入参数之后使用一个短横线和一个大于号（->）来形成箭头➊，然后输入返回值的数据类型。注意，你不需要为返回值提供名称，只需提供数据类型。在函数体内，你通过使用`return`关键字并跟随你希望返回的值来返回该值➋。如果你编写一个返回值的函数，那么你*必须*在函数内返回该值，否则会发生错误。函数在返回值之后结束。如果你在返回语句之后写任何代码，它将被忽略，因为`return`会退出函数。
- en: '![Image](Image00164.jpg)'
  id: totrans-10434
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10435
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数来处理两个不同的盒子，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-10436
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10437
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，`volumeOfBox(_:_:_:)`函数计算了边长为6、5和3的盒子的体积，返回值90被存储在一个名为`volumeOfBox1`的常量中。在➋处，边长为8、4和2的`volumeOfBox2`被赋值为64。现在，让我们打印一条关于哪个盒子更大的消息：
- en: '[PRE1982]'
  id: totrans-10438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1982]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10439
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台中看到字符串“Box 1 is the bigger box.”。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10441
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，该函数接受一个测试分数数组，并返回平均分。为了计算平均分，你需要将所有分数加起来，然后除以分数的总数。请在你的playground中输入以下代码：
- en: '[PRE1983]'
  id: totrans-10442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1983]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10443
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有数值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始值设为 0。位于 ➋ 的 `for-in`
    循环遍历 `scores` 数组中的每个值，并将它加到 `sum` 变量中。当循环完成后，`sum` 变量就保存了所有分数的总和。计算完总和后，剩下的就是将其除以分数的总数，这个总数就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10444
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能用零去除某个数——无论是在数学课上，还是在 Swift 中。在 Swift 中，试图除以零会导致除零错误并崩溃程序。因此，在进行除法运算时，务必确保除数不为零，这就是我们通过在
    ➌ 处检查 `scores.count > 0` 来做的。到了 ➍ ，我们通过将总分除以数组中的分数个数来返回平均值，使用的是 `return sum /
    scores.count`。没错！你可以返回任何求值为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 `sum /
    scores.count`，因为它的结果是一个 `Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10445
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在 `if` 语句中添加 `else`
    来处理这个问题，返回 `0` ➎。你可以通过对一个包含分数的数组和一个空数组调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10446
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10447
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传入 `averageOf()` 函数时，正如我们在 ➊ 处所做的，函数将返回分数的平均值，并显示在结果面板中。如果你传入一个空数组，就像我们在
    ➋ 处所做的那样，返回值就是 `0`。
- en: '**NOTE**'
  id: totrans-10448
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10449
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 `else` 语句其实并不必要。这是因为如果 `scores.count > 0`，那么函数已经通过
    `return sum / scores.count` 结束了。所以如果计算机已经通过了那个 `if` 语句，那我们就知道 `scores.count >
    0` 肯定不成立，这时我们可以直接返回 `0`，而不必将其放入 `else` 中。然而，如果我们保留 `else` 语句，代码会更加清晰易懂。为了让别人更容易理解，有时候写一点多余的代码比使用巧妙的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10451
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10452
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将允许你创建类型不同于 Swift 内置类型的常量和变量，这在你开发应用时会非常有用！
- en: '![Image](Image00164.jpg)'
  id: totrans-10453
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00164.jpg)'
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10454
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-10455
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10456
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，`volumeOfBox(_:_:_:)` 函数计算了一个长宽高分别为 6、5 和 3 的盒子的体积，返回值 90 被存储在名为 `volumeOfBox1`
    的常量中。在 ➋ 处，长宽高分别为 8、4 和 2 的盒子的体积被赋值为 64。现在让我们打印一条消息，告诉我们哪个盒子更大：
- en: '[PRE1984]'
  id: totrans-10457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1984]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10458
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10459
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10460
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，它接收一个测试成绩数组，并返回平均分数。为了得到平均值，你需要将所有分数相加，然后除以成绩的总数。请在你的
    playground 中输入以下代码：
- en: '[PRE1985]'
  id: totrans-10461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1985]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10462
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 类型变量，并将其初始值设为 0。位于 ➋ 处的 `for-in`
    循环遍历 `scores` 数组中的每一个值，并将其加到 `sum` 变量中。当循环结束时，`sum` 变量就保存了所有成绩的总和。在计算完总和后，剩下的就是将其除以成绩的总数，这个总数就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10463
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空怎么办呢？你不能用零来做除法——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试进行除以零的操作会导致除零错误，并且程序会崩溃。因此，在进行除法操作时，始终确保除数不是零，这也是我们在
    ➌ 处通过检查 `scores.count > 0` 来避免除零错误的原因。在 ➍ 处，我们通过将成绩的总和除以数组中的成绩数量来返回平均值，使用的是 `return
    sum / scores.count`。没错！你可以返回任何能够求值为正确数据类型的表达式，这意味着我们可以省略将计算得到的平均值赋给新变量的步骤，直接返回
    `sum / scores.count`，因为它会被求值为 `Int` 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10464
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一个值，否则会出现缺少返回值的错误。我们通过在 `if` 语句中添加 `else`
    来处理这个问题，在 ➎ 处返回 0。你可以通过对一个分数数组和一个空数组调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10465
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10466
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给 `averageOf()` 函数时，正如我们在 ➊ 处所做的，返回的是分数的平均值，并显示在结果窗格中。如果你传入一个空数组，正如我们在
    ➋ 处所做的，返回值将是 0。
- en: '**NOTE**'
  id: totrans-10467
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10468
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，return 0周围的else语句其实并不必要。这是因为如果scores.count > 0，那么函数已经通过return sum /
    scores.count提前结束了。所以，如果程序执行到这个if语句后，我们就知道scores.count > 0一定不成立，我们可以直接写return 0而不需要包裹在else语句中。然而，如果我们保留else语句，代码会更清晰、更容易理解。有时候，写一点额外的代码来让其他人更容易理解，比使用复杂的捷径更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10470
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，能够做各种了不起的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10471
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建除Swift中已包含的类型之外的常量和变量，在你开发应用时会非常有用！
- en: 'Call the function on two different boxes to see it in action:'
  id: totrans-10472
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的盒子上调用该函数，看看它是如何工作的：
- en: '![](Image00165.jpg)'
  id: totrans-10473
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10474
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算了一个边长为6、5、3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋处，边长为8、4、2的volumeOfBox2被赋值为64。现在让我们打印一条消息，看看哪个盒子更大：
- en: '[PRE1986]'
  id: totrans-10475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1986]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10476
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10477
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10478
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。我们来写一个函数，它接收一个测试分数的数组并返回平均分。要计算平均分，你需要将所有分数相加，然后除以总分数。请在你的游乐场中输入以下代码：
- en: '[PRE1987]'
  id: totrans-10479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1987]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10480
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要求出所有数值的总和。在➊处，我们定义了一个名为sum的Int变量，并将其初始值设置为0。在➋处的for-in循环遍历scores数组中的每个值，并将其加到sum变量中。循环结束后，变量sum保存了所有分数的总和。在计算出总和后，剩下的就是将其除以总分数，即scores.count。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10481
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能将数字除以零——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误，并使程序崩溃。因此，在进行除法运算时，一定要确保你将要除的数字不为零，这就是我们通过在
    ➌ 处检查 scores.count > 0 所做的事情。在 ➍ 处，我们通过将分数总和除以数组中的分数数量来返回平均值，使用 return sum / scores.count
    。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算的平均值赋给新变量的步骤，直接返回 sum / scores.count ，因为它会计算出一个
    Int 类型的值。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10482
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在 scores.count 不大于零时返回某个值，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加 else 来处理这个问题，返回
    0 ➎ 。你可以通过对一个分数数组和一个空数组调用函数来测试这段代码：
- en: '![](Image00166.jpg)'
  id: totrans-10483
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10484
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 averageOf() 函数时，就像我们在 ➊ 所做的那样，返回的是分数的平均值，并在结果面板中显示。如果你传递一个空数组，就像我们在
    ➋ 所做的那样，返回值为 0。
- en: '**NOTE**'
  id: totrans-10485
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10486
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句实际上不是必需的。这是因为，如果 scores.count > 0 ，那么函数已经通过 return
    sum / scores.count 结束了。所以，如果计算机已经跳过了那个 if 语句，那么我们就知道 scores.count > 0 一定不成立，这时我们完全可以直接
    return 0，而不需要将其包裹在 else 中。然而，如果我们保留 else 语句，代码会更清晰，理解起来也更容易。有时候，写一些额外的代码来使别人更容易理解，比使用巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10488
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，能够完成各种惊人的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10489
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建其他类型的常量和变量，这在你创建应用程序时会非常有用！
- en: '![](Image00165.jpg)'
  id: totrans-10490
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00165.jpg)'
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10491
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，volumeOfBox(_:_:_:) 函数计算了一个边长为 6、5 和 3 的盒子的体积，返回值 90 被存储在一个名为 volumeOfBox1
    的常量中。在 ➋ 处，边长为 8、4 和 2 的 volumeOfBox2 被赋值为 64。现在让我们打印一条消息，看看哪个盒子更大：
- en: '[PRE1988]'
  id: totrans-10492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1988]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10493
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台中看到字符串 "Box 1 is the bigger box." 的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10495
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们编写一个函数，接受一个测试成绩的数组并返回平均分。为了得到平均分，你需要将所有分数加在一起，然后除以分数的总数。在你的
    playground 中输入以下代码：
- en: '[PRE1989]'
  id: totrans-10496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1989]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10497
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有数值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 类型变量，并将其初始化为 0。在 ➋ 处的 `for-in`
    循环遍历 `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量保存了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数，这就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10498
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能用零去除任何东西——无论是在数学课上，还是在 Swift 中。在 Swift 中，试图除以零会导致除零错误并使程序崩溃。因此，在进行除法运算时，一定要确保你要除的数不是零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 来做到的。在 ➍ 处，我们通过将总分除以数组中分数的数量来返回平均值，使用的是 `return sum
    / scores.count`。没错！你可以返回任何能够计算出正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋值给新变量的步骤，直接返回 `sum
    / scores.count`，因为它的计算结果是一个 `Int` 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10499
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们还需要返回某个值，否则会报错，提示函数缺少返回值。我们通过在 `if` 语句中添加 `else`
    来处理这个问题，返回 0 ➎。你可以通过将一个分数数组和一个空数组传递给函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10500
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10501
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传入一个完整的测试成绩数组给 `averageOf()` 函数时，就像我们在 ➊ 处所做的，分数的平均值会被返回并显示在结果面板中。如果你传入一个空数组，就像我们在
    ➋ 处所做的，返回值是 0。
- en: '**NOTE**'
  id: totrans-10502
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10503
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，`else` 语句包裹 `return 0` 其实并不是必需的。因为如果 `scores.count > 0`，那么函数会在 `return
    sum / scores.count` 时已经结束。所以，如果程序已经通过了那个 `if` 语句，我们就知道 `scores.count > 0` 必然不成立，此时可以直接写
    `return 0`，而不需要将其包裹在 `else` 中。然而，若保留 `else` 语句，代码会更加清晰易懂。写一些额外的代码让其他人更容易理解，有时候比使用简化的技巧更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10505
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包增加了一个重要的工具——创建和调用你自己的函数！函数在编程中广泛应用，可以做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10506
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将使你能够创建除Swift内置类型以外的常量和变量，这在你开发应用时会非常有用！
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  id: totrans-10507
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，volumeOfBox(_:_:_:)函数计算了一个边长为6、5和3的盒子的体积，返回值90被存储在一个名为volumeOfBox1的常量中。在➋处，边长为8、4和2的volumeOfBox2被赋值为64。现在让我们打印出哪个盒子更大的信息：
- en: '[PRE1990]'
  id: totrans-10508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1990]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10509
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10510
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10511
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们写一个函数，接收一个测试分数的数组，并返回平均分。要计算平均分，你需要将分数加在一起，然后除以分数的总数。请在你的
    playground 中输入以下代码：
- en: '[PRE1991]'
  id: totrans-10512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1991]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10513
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在➊处，我们定义了一个名为`sum`的`Int`类型变量，并将其初始值设为0。在➋处的for-in循环会遍历`scores`数组中的每个值，并将它加到`sum`变量中。当循环结束时，`sum`变量保存了所有分数的总和。计算出总和后，剩下的就是将它除以分数的总数，简单来说就是`score.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10514
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空怎么办？你不能将数字除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零将会给出除以零的错误并使程序崩溃。因此，在进行除法时，始终确保你要除的数字不是零，这就是我们在➌处通过检查`scores.count
    > 0`来做的。在➍处，我们通过将分数的总和除以数组中的分数个数来返回平均值，使用`return sum / scores.count`。没错！你可以返回任何计算结果符合正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回`sum
    / scores.count`，因为它的结果是一个`Int`类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10515
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`scores.count`不大于零时，我们也需要返回一些东西，否则会出现“函数缺少返回值”的错误。我们通过在if语句中添加else来处理这个问题，返回0
    ➎。你可以通过在分数数组和空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10516
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10517
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传入averageOf()函数时，如同在➊处所做的，返回并显示的将是分数的平均值。如果你传入一个空数组，如同在➋处所做的，返回值将是0。
- en: '**NOTE**'
  id: totrans-10518
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10519
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕`return 0`的`else`语句其实并不是必需的。这是因为如果`scores.count > 0`，函数已经通过`return
    sum / scores.count`结束了。所以如果计算机已经通过了那个`if`语句，那么我们知道`scores.count > 0`一定不成立，我们可以直接写`return
    0`，而不必把它包裹在`else`语句里。然而，如果我们保留`else`语句，代码会更加清晰和易于理解。有时候，写一点额外的代码来让其他人更容易理解，比使用巧妙的快捷方式要更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的知识**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10521
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚向你的Swift工具包中添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10522
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你创建类型不同于Swift中已有类型的常量和变量，这在你开发应用时会非常有用！
- en: '[PRE1992]'
  id: totrans-10523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1992]'
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10524
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试控制台看到字符串“Box 1 is the bigger box.”的输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10526
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据条件返回不同的值。让我们编写一个函数，它接受一个测试分数的数组并返回平均分。要计算平均值，你将所有分数加在一起，然后除以分数的总数。将以下代码输入到你的Playground中：
- en: '[PRE1993]'
  id: totrans-10527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1993]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10528
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在➊处，我们定义了一个名为`sum`的`Int`变量，并将其初始值设为0。在➋处，`for-in`循环遍历`scores`数组中的每个值并将其加到`sum`变量中。当循环完成时，`sum`变量保存了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总个数，这个值就是`scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10529
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办？你不能用零去除——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会引发除零错误并崩溃你的程序。因此，在进行除法时，务必确保你要除的数不是零，这就是我们通过在➌处检查`scores.count
    > 0`来实现的。在➍处，我们通过将分数的总和除以数组中分数的个数来返回平均值，使用`return sum / scores.count`。没错！你可以返回任何求值为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回`sum
    / scores.count`，因为它会求值为一个`Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10530
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们还需要在`scores.count`不大于零时返回某个值，否则我们会得到一个错误，提示函数缺少返回值。我们通过在`if`语句中添加`else`来处理这个问题，返回`0`
    ➎。你可以通过调用函数并传入一个分数数组和一个空数组来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10531
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10532
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传入 `averageOf()` 函数时，就像我们在 ➊ 处所做的那样，返回的将是分数的平均值，并显示在结果面板中。如果你传入一个空数组，就像我们在
    ➋ 处所做的那样，返回值将是 0。
- en: '**NOTE**'
  id: totrans-10533
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10534
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，`return 0` 周围的 `else` 语句其实并不是必须的。因为如果 `scores.count > 0`，那么函数已经通过 `return
    sum / scores.count` 提前结束了。所以如果程序已经通过了那个 `if` 语句，我们就知道 `scores.count > 0` 一定不为真，此时我们可以直接使用
    `return 0`，而不需要将它包裹在 `else` 中。然而，如果我们保留 `else` 语句，代码会更清晰，容易理解。有时候，为了让别人更容易理解，写一些额外的代码比使用复杂的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10536
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，可以做各种各样的惊人事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10537
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将使你能够创建类型不同于 Swift 中已有类型的常量和变量，这在你开发应用时会非常有用！
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  id: totrans-10538
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会在调试控制台中看到字符串 "Box 1 is the bigger box." 输出。
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10540
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据某个条件返回不同的值。让我们编写一个函数，它接受一个测试分数数组，并返回平均分数。为了计算平均值，你需要将分数相加，然后除以分数的总数。在你的
    Playground 中输入以下代码：
- en: '[PRE1994]'
  id: totrans-10541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1994]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10542
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 类型变量，并将其初始值设为 0。在 ➋ 处的 `for-in`
    循环会遍历 `scores` 数组中的每个值，并将其添加到 `sum` 变量中。当循环结束时，变量 `sum` 将保存所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数，简单来说就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10543
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能用零除数——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并崩溃程序。因此，在进行除法运算时，始终确保你要除的数不是零，这就是我们通过在
    ➌ 处检查 `scores.count > 0` 来实现的。在 ➍ 处，我们通过用 `return sum / scores.count` 将所有分数的总和除以数组中的分数数量来返回平均值。没错！你可以返回任何求值为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回
    `sum / scores.count`，因为它会求值为一个 `Int` 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10544
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一些东西，否则会出现函数缺少返回值的错误。我们通过在 if 语句中添加一个 else
    来处理这个问题，该 else 返回 0 ➎。你可以通过在一个分数数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10545
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10546
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 `averageOf()` 函数时，就像我们在 ➊ 处所做的那样，函数将返回分数的平均值，并显示在结果面板中。如果传入一个空数组，就像我们在
    ➋ 处所做的那样，返回值将是 0。
- en: '**NOTE**'
  id: totrans-10547
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10548
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 else 语句其实并不是必需的。因为如果 `scores.count > 0`，那么函数已经通过 `return
    sum / scores.count` 提前结束了。所以如果计算机已经跳过了那个 if 语句，我们就知道 `scores.count > 0` 一定不成立，我们可以直接返回
    0，而不需要将其包裹在 else 语句中。然而，如果我们保留 else 语句，代码会更清晰，更容易理解。有时候，为了让别人更容易理解，写一点额外的代码比使用复杂的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10549
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10550
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱增加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种各样令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10551
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你创建除 Swift 已包含的类型以外的常量和变量，这在你创建应用程序时会非常有用！
- en: '**CONDITIONAL RETURNS**'
  id: totrans-10552
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**条件返回值**'
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10553
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想根据某个条件返回不同的值。让我们写一个函数，它接受一个测试分数的数组并返回平均分。要得到平均分，你需要将分数相加，然后除以总的分数个数。请在你的
    Playground 中输入以下代码：
- en: '[PRE1995]'
  id: totrans-10554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1995]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10555
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为 sum 的 Int 变量，并将其初始值设置为 0。位于 ➋ 的 for-in 循环遍历
    `scores` 数组中的每个值，并将其加到 sum 变量中。当循环完成时，变量 sum 存储了所有分数的总和。在计算出总和后，剩下的工作就是将其除以分数的总数，这个总数就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10556
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果数组为空呢？你不能将一个数除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致“除零错误”并崩溃程序。因此，在进行除法运算时，务必确保除数不为零，这就是我们在➌处通过检查`scores.count
    > 0`来确保的。在➍处，我们通过将所有成绩的总和除以数组中成绩的数量来返回平均值，使用`return sum / scores.count`。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回`sum
    / scores.count`，因为它的结果是一个`Int`类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10557
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当`scores.count`不大于零时，我们也需要返回一些内容，否则会出现缺少返回值的错误。我们通过在`if`语句中添加`else`来处理这个问题，返回`0`
    ➎。你可以通过在一个成绩数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10558
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10559
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的测试成绩数组传递给`averageOf()`函数时，就像我们在➊处所做的那样，返回的将是成绩的平均值，并显示在结果面板中。如果你传入一个空数组，就像我们在➋处所做的那样，返回值是`0`。
- en: '**NOTE**'
  id: totrans-10560
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10561
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕返回`0`的`else`语句其实并不是必需的。因为如果`scores.count > 0`，那么函数已经会通过`return sum
    / scores.count`提前结束。所以如果程序已经跳过了这个`if`语句，我们就知道`scores.count > 0`一定不为真，这时我们可以直接返回`0`而不必把它放在`else`语句中。然而，如果我们保留`else`语句，代码会更加清晰，易于理解。有时，写一些额外的代码，让其他人更容易理解，比使用复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10563
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚向你的Swift工具包中添加了一个重要工具——创建并调用你自己的函数！函数在编程中被广泛使用，能做各种令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10564
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建其他类型的常量和变量，这在你开发应用时会非常有用！
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  id: totrans-10565
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据条件返回不同的值。让我们写一个函数，它接受一个测试成绩的数组，并返回平均分。要计算平均分，你需要将所有成绩加起来，然后除以成绩的总数。在你的Playground中输入以下代码：
- en: '[PRE1996]'
  id: totrans-10566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1996]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10567
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始值设置为 `0`。在 ➋ 处的 for-in
    循环中，程序遍历 `scores` 数组中的每个值，并将其加到 `sum` 变量中。当循环完成时，`sum` 变量中保存了所有分数的总和。计算出总和后，剩下的就是将其除以分数的总数，简单来说就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10568
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果数组为空怎么办呢？你不能用零去除以任何数字——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试除以零会导致“除以零”错误，并崩溃你的程序。因此，在进行除法操作时，必须确保你要除的数字不为零，这就是我们在
    ➌ 通过检查 `scores.count > 0` 来做到的。在 ➍ 处，我们通过将分数的总和除以数组中分数的数量，使用 `return sum / scores.count`
    来返回平均值。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给新变量的步骤，直接返回 `sum / scores.count`，因为它的结果是一个
    `Int` 类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10569
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一个值，否则会出现缺少返回值的错误。我们通过在 if 语句中添加 else 来处理这个问题，返回
    `0` ➎。你可以通过在包含分数的数组和空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10570
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10571
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 `averageOf()` 函数时，像我们在 ➊ 所做的那样，函数会返回分数的平均值，并显示在结果面板中。如果你传递一个空数组，像我们在
    ➋ 所做的那样，返回值会是 0。
- en: '**NOTE**'
  id: totrans-10572
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10573
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 else 语句其实并不是必须的。这是因为，如果 `scores.count > 0`，那么函数已经通过
    `return sum / scores.count` 结束了。所以，如果程序已经执行到那条 if 语句之后，我们就知道 `scores.count > 0`
    一定不成立，那么我们完全可以直接返回 `0`，而不需要将其放在 else 语句中。然而，如果我们保留 else 语句，代码会更加清晰，容易理解。有时候，写一些额外的代码来让别人更容易理解，比使用复杂的捷径要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10575
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚向你的 Swift 工具包中添加了一个重要工具——创建和调用你自己的函数！函数在编程中广泛应用，可以完成各种神奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10576
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你创建其他类型的常量和变量，这些类型并不在
    Swift 中预设，当你创建应用程序时，这会非常有用！
- en: '[PRE1997]'
  id: totrans-10577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1997]'
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10578
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有数值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 Int 变量，并将其初始值设置为 0。位于 ➋ 的 `for-in`
    循环遍历 `scores` 数组中的每个值，并将其添加到 `sum` 变量中。循环完成后，`sum` 变量保存了所有分数的总和。计算总和后，剩下的就是将其除以分数的总数，这个数就是
    `scores.count`。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10579
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果数组为空呢？你不能将某个数除以零——无论是在数学课上，还是在 Swift 中。在 Swift 中，尝试除以零会导致除零错误并崩溃程序。因此，在进行除法运算时，始终确保你要除的数不是零，这就是我们通过检查
    `scores.count > 0` 来做到的，如 ➌ 所示。在 ➍ 中，我们通过将分数的总和除以数组中的分数数量来返回平均值，使用 `return sum
    / scores.count`。没错！你可以返回任何评估为正确数据类型的表达式，这意味着我们可以跳过将计算得到的平均值赋给新变量的步骤，直接返回 `sum
    / scores.count`，因为它会被评估为一个 Int。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10580
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们也需要返回一些内容，否则会出现错误，提示函数缺少返回值。我们通过在 `if` 语句中添加一个
    `else` 来处理这个问题，返回 0 ➎ 。你可以通过在一个分数数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10581
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10582
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试分数数组传递给 `averageOf()` 函数时，如 ➊ 所示，返回并显示的是分数的平均值。如果你传入一个空数组，如 ➋ 所示，返回值将是
    0。
- en: '**NOTE**'
  id: totrans-10583
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10584
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 `else` 语句其实并不是必要的。因为如果 `scores.count > 0`，那么函数已经通过
    `return sum / scores.count` 结束了。所以，如果计算机已经通过了那个 `if` 语句，我们知道 `scores.count > 0`
    一定不为真，我们可以直接写 `return 0`，而不需要将其包裹在 `else` 中。然而，如果我们保留 `else` 语句，代码会更加清晰易懂。有时候，写多一点代码让别人更容易理解，比使用复杂的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10586
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包增加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种惊人的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10587
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)，我们将展示如何通过编写类定义来创建自定义对象。这将让你能够创建除 Swift 中已包含类型之外的常量和变量，这在你创建应用程序时会非常有用！
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  id: totrans-10588
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出所有值的总和。在 ➊ 处，我们定义了一个名为 `sum` 的 `Int` 变量，并将其初始化为 0。位于 ➋ 的 `for-in` 循环会遍历
    `scores` 数组中的每个值，并将其加到 `sum` 变量上。当循环完成时，`sum` 变量中保存了所有成绩的总和。计算完总和后，剩下的就是将其除以成绩的总数，`scores.count`
    就是总数。
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10589
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组为空怎么办？你不能用零去除法——无论是在数学课上还是在 Swift 中。在 Swift 中，尝试除以零会导致“除零错误”，并使程序崩溃。因此，在进行除法运算时，一定要确保你将要除的数字不为零，这就是我们在
    ➌ 处通过检查 `scores.count > 0` 所做的事情。在 ➍ 处，我们通过将成绩总和除以数组中成绩的数量来返回平均值，使用 `return sum
    / scores.count`。没错！你可以返回任何求值为正确数据类型的表达式，这意味着我们可以跳过将计算出来的平均值赋给新变量的步骤，直接返回 `sum
    / scores.count`，因为它会求值为 `Int`。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10590
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当 `scores.count` 不大于零时，我们还需要返回一些内容，否则会出现缺少返回值的错误。我们通过在 `if` 语句中添加一个 `else`
    来处理这个问题，该 `else` 返回 0 ➎。你可以通过在一个成绩数组和一个空数组上调用该函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10591
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10592
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像在 ➊ 处那样将一个完整的测试成绩数组传递给 `averageOf()` 函数时，函数会返回并显示成绩的平均值。如果你传入一个空数组，如 ➋ 处所示，返回值将是
    0。
- en: '**NOTE**'
  id: totrans-10593
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10594
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 `return 0` 的 `else` 语句其实并不必要。因为如果 `scores.count > 0`，那么函数已经会在 `return
    sum / scores.count` 处结束。如果计算机已经通过了那个 `if` 语句，那么我们知道 `scores.count > 0` 一定不成立，因此我们只需要
    `return 0`，而无需将其放在 `else` 中。然而，如果我们保留 `else` 语句，代码会更加清晰易懂。有时，写多一点代码来让其他人更容易理解比用一个复杂的快捷方式更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10596
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具包添加了一个重要的工具——创建和调用你自己的函数！函数在编程中被广泛使用，能做很多令人惊叹的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10597
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)，我们将向你展示如何通过编写类定义来创建自定义对象。这将让你创建具有 Swift 中未包含的其他类型的常量和变量，当你创建应用时这将非常有用！
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  id: totrans-10598
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果数组为空呢？你不能把一个数除以零——无论是在数学课上还是在Swift中。在Swift中，尝试除以零会导致除零错误并崩溃你的程序。因此，在进行除法时，一定要确保你要除的数不是零，这也是我们在
    ➌ 处通过检查scores.count > 0来做的。在 ➍ 处，我们通过将成绩的总和除以数组中成绩的数量来返回平均值，使用的是return sum / scores.count。没错！你可以返回任何计算结果为正确数据类型的表达式，这意味着我们可以跳过将计算出的平均值赋给一个新变量的步骤，直接返回sum
    / scores.count，因为它计算结果为Int类型。
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10599
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们也需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在if语句中添加else来处理这个问题，返回0
    ➎。你可以通过在一个成绩数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10600
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10601
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给averageOf()函数时，如我们在 ➊ 所做的，函数将返回成绩的平均值并显示在结果窗格中。如果你传递一个空数组，如我们在
    ➋ 所做的，返回值将是0。
- en: '**NOTE**'
  id: totrans-10602
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10603
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句其实并不是必须的。因为如果scores.count > 0，函数会在return sum / scores.count处已经结束。所以如果计算机已经跳过了那个if语句，我们就知道scores.count
    > 0一定不为真，这时我们只需要return 0而不必将其包裹在else语句中。然而，如果我们保留else语句，代码会更清晰，容易理解。有时候，写一些额外的代码让别人更容易理解，比起使用复杂的捷径，反而会更好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10604
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10605
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要的工具——创建和调用你自己的函数！函数在编程中广泛应用，可以做各种各样的了不起的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10606
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)，我们将展示如何通过编写类定义来创建自定义对象。这将让你能够创建具有Swift中未包含类型的常量和变量，这对于创建应用程序时会非常有用！
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  id: totrans-10607
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，当scores.count不大于零时，我们也需要返回一个值，否则会出现函数缺少返回值的错误。我们通过在if语句中添加else来处理这个问题，返回0
    ➎。你可以通过在一个成绩数组和一个空数组上调用这个函数来测试代码：
- en: '![](Image00166.jpg)'
  id: totrans-10608
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10609
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个完整的测试成绩数组传递给averageOf()函数时，如我们在 ➊ 所做的，函数将返回成绩的平均值并显示在结果窗格中。如果你传递一个空数组，如我们在
    ➋ 所做的，返回值将是0。
- en: '**NOTE**'
  id: totrans-10610
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10611
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句实际上并不是必需的。因为如果scores.count > 0，那么函数已经通过return sum
    / scores.count结束了。所以，如果计算机已经跳过了那个if语句，那么我们知道scores.count > 0一定不成立，我们完全可以直接使用return
    0，而不需要将它包含在else语句中。然而，如果我们保留else语句，代码会更加清晰且易于理解。有时候，写一些额外的代码来让其他人更容易理解，比使用巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10613
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种神奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10614
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这样，你就可以创建不同于Swift中已经包含的类型的常量和变量，这在你创建应用时会非常有用！
- en: '![](Image00166.jpg)'
  id: totrans-10615
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00166.jpg)'
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10616
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整个测试分数数组传递给averageOf()函数时，正如我们在➊所做的，分数的平均值会被返回并显示在结果面板中。如果你传入一个空数组，正如我们在➋所做的，返回值是0。
- en: '**NOTE**'
  id: totrans-10617
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10618
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕return 0的else语句实际上并不是必需的。因为如果scores.count > 0，那么函数已经通过return sum
    / scores.count结束了。所以，如果计算机已经跳过了那个if语句，那么我们知道scores.count > 0一定不成立，我们完全可以直接使用return
    0，而不需要将它包含在else语句中。然而，如果我们保留else语句，代码会更加清晰且易于理解。有时候，写一些额外的代码来让其他人更容易理解，比使用巧妙的快捷方式要好。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10620
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的Swift工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中被广泛使用，用来做各种神奇的事情！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10621
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这样，你就可以创建不同于Swift中已经包含的类型的常量和变量，这在你创建应用时会非常有用！
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  id: totrans-10622
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一整个测试分数数组传递给averageOf()函数时，正如我们在➊所做的，分数的平均值会被返回并显示在结果面板中。如果你传入一个空数组，正如我们在➋所做的，返回值是0。
- en: '**NOTE**'
  id: totrans-10623
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10624
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不是必须的。因为如果 scores.count > 0，那么函数已经通过 return
    sum / scores.count 结束了。所以，如果计算机已经跳过了那个 if 语句，我们知道 scores.count > 0 必然不成立，我们可以直接写一个
    return 0，而不需要将它包裹在 else 中。不过，如果我们保留 else 语句，代码会更清晰，更容易理解。有时候，写一些额外的代码，比使用巧妙的捷径更能让别人理解。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10626
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中广泛应用，用于完成各种惊人的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10627
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让你能够创建类型不同于 Swift 中已包含的常量和变量，在你开发应用时会非常有用！
- en: '**NOTE**'
  id: totrans-10628
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  id: totrans-10629
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种情况下，围绕 return 0 的 else 语句其实并不是必须的。因为如果 scores.count > 0，那么函数已经通过 return
    sum / scores.count 结束了。所以，如果计算机已经跳过了那个 if 语句，我们知道 scores.count > 0 必然不成立，我们可以直接写一个
    return 0，而不需要将它包裹在 else 中。不过，如果我们保留 else 语句，代码会更清晰，更容易理解。有时候，写一些额外的代码，比使用巧妙的捷径更能让别人理解。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-10630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10631
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中广泛应用，用于完成各种惊人的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10632
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让你能够创建类型不同于 Swift 中已包含的常量和变量，在你开发应用时会非常有用！
- en: '**WHAT YOU LEARNED**'
  id: totrans-10633
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10634
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中广泛应用，用于完成各种惊人的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10635
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](text00018.html#ch08)中，我们将展示如何通过编写类定义来创建自定义对象。这将让你能够创建类型不同于 Swift 中已包含的常量和变量，在你开发应用时会非常有用！
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  id: totrans-10636
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的 Swift 工具箱添加了一个重要工具——创建和调用你自己的函数！函数在编程中广泛应用，用于完成各种惊人的任务！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10637
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建与Swift中已包含的类型不同的常量和变量，这在你创建应用时非常有用！
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  id: totrans-10638
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](text00018.html#ch08)中，我们将向你展示如何通过编写类定义来创建自定义对象。这将允许你创建与Swift中已包含的类型不同的常量和变量，这在你创建应用时非常有用！
