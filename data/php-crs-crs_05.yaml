- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 4 CONDITIONALS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4 条件语句
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, you’ll learn about *conditional* elements of the PHP language,
    including if...else statements, switch statements, and match statements. These
    structures, along with language features such as the ternary operator, the null-coalescing
    operator, and logical operators, make it possible to write dynamic code that decides
    what to do based on a set of conditions. The conditions might depend on certain
    inputs (for example, from a user or from a software system such as a database
    or API) or on other varying data (such as the current date or time, or whether
    a file exists).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习PHP语言中的*条件*元素，包括if...else语句、switch语句和match语句。这些结构，以及三元运算符、空合并运算符和逻辑运算符等语言特性，使得编写动态代码成为可能，代码根据一组条件来决定执行什么操作。这些条件可能依赖于特定的输入（例如来自用户或软件系统如数据库或API的输入），也可能依赖于其他变化的数据（例如当前日期或时间，或者文件是否存在）。
- en: '### Conditions Are True or False'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### 条件为真或为假'
- en: 'At the core of any decision-making logic is a *Boolean expression*, or code
    that is either true or false. The simplest Boolean expression is a literal value
    of true or false. In almost all cases, though, we instead write an expression
    containing some kind of test. The test might examine the values of variables,
    or perhaps call a function and check the value it returns. Either way, the test
    ultimately evaluates to true or false. Examples of tests include the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何决策逻辑的核心都是*布尔表达式*，即返回真或假的代码。最简单的布尔表达式就是true或false的字面值。然而，在几乎所有情况下，我们都会编写包含某种测试的表达式。这个测试可能会检查变量的值，或者调用一个函数并检查它返回的值。无论哪种方式，测试最终都会评估为真或假。测试的示例包括以下内容：
- en: Does a variable contain a particular value?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个变量是否包含特定的值？
- en: Does a variable have any value assigned at all?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量是否有任何值被赋值？
- en: Does a file or folder exist?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件或文件夹是否存在？
- en: Is the value in one variable greater or less than another value?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个变量的值是否大于或小于另一个值？
- en: Does a function return true or false based on the arguments provided?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数是否根据提供的参数返回真或假？
- en: Is the length of a string greater than a certain minimum?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的长度是否大于某个最小值？
- en: Does a variable contain a value of a particular data type?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个变量是否包含特定数据类型的值？
- en: Are two expressions both true, or just one, or neither?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个表达式是否都为真，还是只有一个为真，或者都不为真？
- en: Tests such as these all evaluate to true or false. They form the conditions
    of the choice statements you can use in your code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试都会评估为真或假。它们构成了你可以在代码中使用的选择语句的条件。
- en: if Statements
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if 语句
- en: 'Perhaps the most common conditional statement in any programming language is
    the if statement. It allows you to execute a statement only if a certain condition
    is true. Otherwise, that statement is simply skipped. In PHP, if statements are
    written in the following format:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可能任何编程语言中最常见的条件语句是if语句。它允许你仅在某个条件为真时执行语句。否则，该语句会被跳过。在PHP中，if语句的写法如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Start with the if keyword, followed in parentheses by the condition you want
    to check. This condition is the Boolean expression that evaluates to true or false.
    It’s common practice to add a space after the if keyword, before the opening parenthesis.
    Next comes the statement that should be executed if the condition is true.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从if关键字开始，后面跟着括号中的条件，条件就是评估为真或假的布尔表达式。通常做法是在if关键字后、左括号前添加一个空格。接下来是当条件为真时应该执行的语句。
- en: '[Listing 4-1](#lis4-1) shows an example of an if statement. It prints the message
    Good morning if the hour of the day is before 12 (assuming a 24-hour clock).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-1](#lis4-1)展示了一个if语句的示例。如果一天的小时数小于12（假设使用24小时制时钟），它会打印“早上好”。'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 4-1: An if statement'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-1：一个 if 语句示例
- en: 'First, we set the $hourNumber variable to 10. Then we use an if statement to
    test our condition: whether the value in $hourNumber is less than 12. Since 10
    is less than 12, the condition is true, so the statement after the condition is
    executed, printing out the message Good morning.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将变量$hourNumber设置为10。然后我们使用if语句来测试条件：$hourNumber的值是否小于12。由于10小于12，条件为真，因此条件后的语句会被执行，打印出“早上好”。
- en: In this example, we had only one statement that we wanted to execute if the
    condition was true. But what if we want to execute multiple statements? We need
    a way to group the statements so it’s clear that they’re all part of the if statement.
    For this, enclose the sequence of statements in curly brackets (braces) immediately
    after the condition. The curly brackets delineate a *statement group*, a PHP construction
    that can contain zero, one, or many statements, and that PHP treats as a single
    statement. [Listing 4-2](#lis4-2) shows an example of a conditional with a statement
    group.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只想在条件为真时执行一条语句。但如果我们想执行多条语句呢？我们需要一种方法将这些语句分组，以便明确它们都是 if 语句的一部分。为此，我们可以在条件之后立即将这些语句用大括号括起来。大括号划定了一个*语句组*，这是
    PHP 的一个结构，可以包含零个、一个或多个语句，并且 PHP 会将其视为一个单一的语句。[列表 4-2](#lis4-2) 展示了一个带语句组的条件语句示例。
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 4-2: A refactored if statement featuring a statement group'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-2：一个重构过的 if 语句，包含语句组
- en: This if statement produces the same result as [Listing 4-1](#lis4-1), but we’ve
    rewritten it to consist of multiple print statements, one for each word in the
    message. The statements are enclosed in curly brackets to group them together.
    It’s customary to write the opening bracket on the same line as the condition,
    followed on separate lines by each statement in the group, followed by the closing
    bracket, also on a separate line. By convention, each statement in the statement
    group is indented.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if 语句产生与[列表 4-1](#lis4-1)相同的结果，但我们已将其重写为包含多个打印语句，每个语句对应消息中的一个单词。这些语句被大括号括起来，以便将它们分组。通常写法是将开括号写在条件的同一行，然后在后续行中写出语句组中的每个语句，最后在另起一行写出闭括号。根据约定，语句组中的每个语句都会缩进。
- en: NOTE
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Even if you have only a single conditional statement to be executed, enclosing
    that statement in curly brackets to form a statement group is common practice.
    This way, all* if *statements follow the same style, no matter how many statements
    are involved.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*即使你只有一个条件语句要执行，通常也会将该语句用大括号括起来，形成语句组。这样，所有的* if *语句都会遵循相同的风格，不管涉及多少语句。*'
- en: if...else Statements
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: if...else 语句
- en: Many situations require a program to perform one set of actions if a condition
    is true or another set of actions if the condition is false. For these situations,
    use an if...else statement. [Listing 4-3](#lis4-3) shows an example where we choose
    between printing Good morning and Good day.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 许多情况下需要程序在条件为真时执行一组操作，在条件为假时执行另一组操作。对于这些情况，使用 if...else 语句。[列表 4-3](#lis4-3)
    展示了一个例子，其中我们选择打印“Good morning”或“Good day”。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 4-3: An if...else statement'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-3：一个 if...else 语句
- en: This code once again checks whether the value of $hourNumber is less than 12.
    If it is, the condition is true, so we execute the if branch of the statement,
    printing Good morning as before. If the condition is false, however, and $hourNumber
    isn’t less than 12, we execute the else branch of the statement instead, printing
    the message Good day. Notice that the else keyword appears after the closing curly
    bracket of the if branch’s statement group. Then the else branch is given its
    own statement group enclosed in curly brackets.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码再次检查 $hourNumber 的值是否小于 12。如果是，条件为真，执行 if 分支的语句，打印出“Good morning”，如同之前一样。然而，如果条件为假，并且
    $hourNumber 不小于 12，我们将执行 else 分支的语句，打印出“Good day”。请注意，else 关键字出现在 if 分支的语句组的右大括号之后。然后，else
    分支会有一个独立的语句组，用大括号括起来。
- en: In this case, $hourNumber is 14 (2 PM), so the condition evaluates to false
    and the else branch’s statement is executed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，$hourNumber 是 14（下午 2 点），因此条件判断为假，执行了 else 分支的语句。
- en: Nested if...else Statements
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌套 if...else 语句
- en: An if...else statement chooses between two courses of action. If you have more
    than two courses of action to choose from, you have a few options. One is to nest
    further if...else statements inside the original else branch. [Listing 4-4](#lis4-4)
    shows an example. This script encodes the logic that if the hour is before 12,
    we print Good morning; if the hour is between 12 and 17 (5 PM), we print Good
    afternoon; or otherwise, we print Good day.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: if...else 语句在两个行动之间做出选择。如果你有多个行动可以选择，你有几个选项。一个方法是将更多的 if...else 语句嵌套在原有的 else
    分支中。[列表 4-4](#lis4-4) 展示了一个例子。这个脚本编码了以下逻辑：如果小时数小于 12，打印“Good morning”；如果小时数在 12
    到 17（下午 5 点）之间，打印“Good afternoon”；否则，打印“Good day”。
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 4-4: Nested if...else statements'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-4：嵌套的 if...else 语句
- en: First, we have an if statement testing whether the hour is less than 12 ❶. If
    this condition isn’t true, the else statement will be executed. The statement
    group for the else statement is a second (nested) if...else statement. The condition
    for this second if...else statement is whether the hour is less than 17 ❷. (If
    we’re at this point, we’ve already determined that the hour isn’t less than 12,
    so in effect we’re testing whether the hour is between 12 and 17.) If this new
    test passes, Good afternoon will be printed. Otherwise, we get to the else portion
    of the nested if...else statement, where Good day is printed. Try playing with
    different values of $hourNumber to see how it affects the output of the script.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个if语句测试小时数是否小于12 ❶。如果这个条件不成立，else语句将会被执行。else语句的语句组是一个第二个（嵌套的）if...else语句。这个第二个if...else语句的条件是小时数是否小于17
    ❷。（如果我们已经执行到这个步骤，就表示小时数不小于12，因此实际上我们是在测试小时数是否介于12和17之间。）如果这个新的测试通过，系统会打印“下午好”。否则，我们进入嵌套if...else语句的else部分，打印“日安”。尝试使用不同的$hourNumber值来观察它如何影响脚本的输出。
- en: if...elseif...else Statements
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: if...elseif...else语句
- en: 'Choosing between three or more actions is such a common pattern in programming
    that PHP provides a simpler syntax for it that avoids the need for nesting: between
    an if statement and its else statement, place one or more elseif statements. The
    PHP engine will first test the condition for the if statement. If the statement
    is false, the engine will then test the condition for the first elseif statement,
    then the next elseif statement, and so on. When PHP finds a true condition, that
    branch’s statements are executed, and the remaining condition checks are skipped.
    If none of the if or elseif conditions are true, the else statement at the end
    will be executed, if there is one.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，选择三种或更多行为是一个非常常见的模式，因此PHP提供了一种更简洁的语法，避免了嵌套的需要：在if语句和else语句之间，放置一个或多个elseif语句。PHP引擎会首先测试if语句的条件。如果该语句为假，PHP引擎会继续测试第一个elseif语句的条件，然后是下一个elseif语句，以此类推。当PHP找到一个成立的条件时，会执行该分支的语句，并跳过其余的条件检查。如果没有任何if或elseif条件成立，那么最后的else语句（如果有）将会被执行。
- en: '[Listing 4-5](#lis4-5) shows the same logic from [Listing 4-4](#lis4-4), but
    it’s rewritten using if...elseif...else.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单4-5](#lis4-5)展示了与[清单4-4](#lis4-4)相同的逻辑，但它是使用if...elseif...else重写的。'
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 4-5: Simplifying the nested if...else statements with if...elseif...else'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4-5：用if...elseif...else简化嵌套的if...else语句
- en: Our second condition now appears in sequence as an elseif statement ❶ after
    the if statement, rather than having to be nested inside the else statement. You
    can add as many elseif statements as you want between the if and the else.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个条件现在以elseif语句的形式出现在if语句之后 ❶，而不再需要嵌套在else语句中。你可以在if和else之间添加任意数量的elseif语句。
- en: Alternative Syntax
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 替代语法
- en: PHP offers an alternative syntax for if, if...else, and if...elseif...else statements
    that uses colons rather than curly brackets to set off the various parts of the
    code. This syntax is illustrated in [Listing 4-6](#lis4-6), which reproduces the
    if...else statement from [Listing 4-3](#lis4-3).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: PHP为if、if...else和if...elseif...else语句提供了一种替代语法，使用冒号而不是大括号来区分代码的各个部分。这种语法在[清单4-6](#lis4-6)中得到了展示，复现了[清单4-3](#lis4-3)中的if...else语句。
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 4-6: The alternative syntax for conditional statements'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4-6：条件语句的替代语法
- en: In this alternative syntax, the condition for the if statement is followed by
    a colon (:). This line acts like an opening curly bracket, so any statements between
    it and the else (or elseif) keyword are considered part of the statement group
    to be executed if the condition is true. The else keyword is similarly followed
    by a colon rather than an opening curly bracket. The statement group for the else
    branch ends with the endif keyword signaling that the whole if...else structure
    is over.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种替代语法中，if语句的条件后面跟一个冒号(:)。这一行就像是一个大括号的开始，因此它与else（或elseif）关键字之间的所有语句都被认为是条件成立时需要执行的语句组。else关键字同样后面跟一个冒号，而不是一个大括号。else分支的语句组以endif关键字结束，标志着整个if...else结构的结束。
- en: This alternative syntax is particularly useful for web applications, where HTML
    template text could appear between the if statement and the else statement, and
    the use of indented curly brackets could be hard to follow in the code. Likewise,
    the endif keyword clearly indicates that the overall conditional is ending.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替代语法在 Web 应用程序中特别有用，因为 HTML 模板文本可能出现在 if 语句和 else 语句之间，而使用缩进的花括号在代码中可能会让人难以跟踪。同样，endif
    关键字清楚地表示整体条件语句的结束。
- en: Logical Operators
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: PHP’s *logical operators* manipulate or combine Boolean expressions, producing
    a single true or false value. This way, you can write more sophisticated tests
    for conditional statements than simply comparing two values, as we’ve done so
    far (for example, testing whether two conditions are true). These logical operators
    perform operations such as AND, OR, and NOT. The operators are summarized in [Table
    4-1](#tab4-1).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的 *逻辑运算符* 用于操作或组合布尔表达式，产生一个单一的真或假值。通过这种方式，你可以编写比单纯比较两个值更复杂的条件判断语句，就像我们迄今为止所做的那样（例如，测试两个条件是否为真）。这些逻辑运算符执行如
    AND、OR 和 NOT 等操作。运算符的总结见 [表 4-1](#tab4-1)。
- en: 'Table 4-1: PHP Logical Operators'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1：PHP 逻辑运算符
- en: '| Name | Operator | Example | Description |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 运算符 | 示例 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| NOT | ! | !$a | true if $a is false |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| NOT | ! | !$a | 如果 $a 为假，则为真 |'
- en: '| AND | and&& | $a and $b$a && $b | true if both $a and $b are true |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| AND | and&& | $a and $b$a && $b | 如果 $a 和 $b 都为真，则为真 |'
- en: '| OR | or&#124;&#124; | $a or $b$a &#124;&#124; $b | true if either $a or $b
    is true, or if both are true |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| OR | 或&#124;&#124; | $a 或 $b$a &#124;&#124; $b | 如果 $a 或 $b 为真，或两者都为真，则为真
    |'
- en: '| XOR | xor | $a xor $b | true if either $a or $b, but not both, is true |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| XOR | xor | $a xor $b | 如果 $a 或 $b 为真，但不能两者都为真，则为真 |'
- en: 'Notice that AND and OR operations can be written two ways: with words (and
    or or) or with symbols (&& or ||). The two versions perform the same function,
    but the symbol versions have a higher precedence than the word versions when an
    expression is evaluated. (We discussed operator order of precedence in [Chapter
    1](chapter1.xhtml), in the context of arithmetic operators.)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，AND 和 OR 操作可以有两种写法：使用单词（and 或 or）或使用符号（&& 或 ||）。这两种写法执行相同的功能，但符号版本在表达式求值时优先级高于单词版本。（我们在
    [第 1 章](chapter1.xhtml) 中讨论了运算符优先级的顺序，主要是在算术运算符的上下文中。）
- en: NOT
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: NOT
- en: An exclamation mark (!) represents the NOT operator. This operator negates a
    Boolean expression or tests whether the expression is not true. For example, [Listing
    4-7](#lis4-7) uses the NOT operator to test a driver’s age. In Ireland, you have
    to be at least 17 years old to drive a car.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 感叹号（!）表示“NOT”操作符。该操作符用于否定一个布尔表达式或测试该表达式是否不为真。例如，[清单 4-7](#lis4-7) 使用 NOT 操作符测试驾驶员的年龄。在爱尔兰，开车必须年满
    17 岁。
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 4-7: An if statement using the NOT (!) operator'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-7：使用 NOT (!) 操作符的 if 语句
- en: 'The if statement checks whether it is *not* true that the value of $age is
    greater than or equal to 17. Since 15 is not 17 or more, you should see the following
    message printed out when you run the script:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: if 语句检查 $age 是否 *不* 为真，即是否小于 17。由于 15 小于 17，因此运行脚本时应该看到以下消息被打印出来：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that we’ve placed $age >= 17 in parentheses to separate it from the NOT
    operator. This is because the NOT operator normally takes higher precedence than
    the >= operator, but we want to check whether $age is greater than or equal to
    17 before using ! to negate that result. If we had written if (!$age >= 17) instead,
    without the inner parentheses, PHP would try to evaluate !$age first. The NOT
    operator requires a Boolean operand, so the value of 15 inside $age would be juggled
    to true (as would any other nonzero value). Then, since !true is false, we would
    have the expression false >= 17.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将 $age >= 17 放在括号中，以将其与 NOT 操作符分开。这是因为 NOT 操作符通常优先级高于 >= 操作符，但我们希望在使用
    ! 否定结果之前，先检查 $age 是否大于或等于 17。如果我们写成 if (!$age >= 17) 而没有内括号，PHP 会首先尝试计算 !$age。NOT
    操作符要求布尔操作数，因此 $age 中的值 15 会被转换为 true（任何非零值都一样）。然后，由于 !true 为 false，表达式变成 false
    >= 17。
- en: Next, PHP would try to evaluate the >= comparison, and since one of the operands
    is a Boolean, it would try to make the second operand a Boolean too. The integer
    17 would thus be juggled to true (since it’s nonzero), giving us the expression
    false >= true, which evaluates to false. Ultimately, without those extra parentheses,
    !$age >= 17 would evaluate to false for any nonzero integer value of $age.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，PHP会尝试评估>=比较操作，因为其中一个操作数是布尔值，它也会尝试将第二个操作数转换为布尔值。因此，整数17会被转换为true（因为它是非零的），从而得到表达式false
    >= true，这个结果为false。最终，在没有额外括号的情况下，!$age >= 17会对任何非零整数值的$age评估为false。
- en: To avoid all this type juggling and potential for error due to missing parentheses,
    I often create a temporary Boolean variable for use in an if statement before
    introducing the NOT operator. For example, [Listing 4-8](#lis4-8) shows an alternate
    version of the code from [Listing 4-7](#lis4-7), with an extra variable to avoid
    any chance of mixing integers and Booleans.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免所有这些类型转换和因缺少括号而可能导致的错误，我通常会在引入NOT运算符之前，为if语句创建一个临时布尔变量。例如，[清单 4-8](#lis4-8)展示了[清单
    4-7](#lis4-7)的另一版本，增加了一个额外的变量来避免混合整数和布尔值的任何可能性。
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 4-8: A cleaner version of [Listing 4-7](#lis4-7), with an extra Boolean
    variable'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-8：[清单 4-7](#lis4-7)的简洁版本，增加了一个布尔变量
- en: We use the $seventeenAndOlder variable to store the true or false value of the
    $age >= 17 test. Then the if statement uses the NOT operator to test whether $seventeenAndOlder
    is not true. While this adds an extra line of code compared to [Listing 4-7](#lis4-7),
    it’s much clearer to understand since we’ve separated the age test Boolean expression
    from the if statement condition.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用$seventeenAndOlder变量来存储$age >= 17测试的布尔值。然后，if语句使用NOT运算符测试$seventeenAndOlder是否为假。虽然与[清单
    4-7](#lis4-7)相比，这增加了一行代码，但由于我们将年龄测试的布尔表达式与if语句的条件分开，它更容易理解。
- en: NOTE
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Placing expressions like* $age >= 17 *inside parentheses isn’t necessary when
    assigning their value to a variable. [Listing 4-8](#lis4-8) uses parentheses to
    help make the code clearer to read.*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*将像* $age >= 17 *这样的表达式放在括号内，在将其值赋给变量时并非必要。[清单 4-8](#lis4-8)使用括号来帮助使代码更易于阅读。*'
- en: AND
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 和
- en: An expression with the AND operator is true when both operands are true. You
    can use either the keyword and or a double ampersand (&&) to create an AND operation.
    For example, the if...else statement in [Listing 4-9](#lis4-9) uses the AND operator
    to determine whether a driver meets both conditions to be allowed to take a driving
    test. In Ireland, you have to pass a theory test and hold a learner’s license
    for at least six months before you’re allowed to apply for a driving test.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AND运算符的表达式在两个操作数都为真时为真。你可以使用关键字and或双重与符号（&&）来创建AND操作。例如，[清单 4-9](#lis4-9)中的if...else语句使用AND运算符来判断一个驾驶员是否满足两个条件才能申请驾照考试。在爱尔兰，必须通过理论考试并持有至少六个月的学习驾驶执照，才能申请驾照考试。
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 4-9: An if...else statement using the AND operator'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-9：使用AND运算符的if...else语句
- en: We declare the $passedTheoryTest variable as true, and $monthsHeldLearnersLicense
    with value 10. Then we test whether $monthsHeldLearnersLicense is greater than
    or equal to 6 and store the resulting Boolean (true, in this case) in the $heldLearnersLicenseEnough
    variable. Next, we declare an if...else statement with the condition $passedTheoryTest
    and $heldLearnersLicenseEnough. Since both values are true, the AND operation
    is true as well, so the message You may apply for a driving test will be printed
    out.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将$passedTheoryTest变量声明为true，并将$monthsHeldLearnersLicense的值设置为10。然后，我们测试$monthsHeldLearnersLicense是否大于或等于6，并将结果布尔值（此例为true）存储在$heldLearnersLicenseEnough变量中。接下来，我们声明一个if...else语句，条件为$passedTheoryTest和$heldLearnersLicenseEnough。由于两个值都为真，AND操作也为真，因此消息“你可以申请驾照考试”将被输出。
- en: Try changing $passedTheoryTest to false or setting $monthsHeldLearnersLicense
    to a value less than 6. The AND operation should then evaluate as false, and the
    message in the else branch of the statement should print out.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将$passedTheoryTest更改为false或将$monthsHeldLearnersLicense设置为小于6的值。此时，AND操作应评估为false，并且语句的else分支中的消息应该输出。
- en: OR
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 或
- en: An OR operation is true when either or both operands are true. You can use either
    the keyword or or a double vertical pipe (||) to write an OR operation. [Listing
    4-10](#lis4-10) illustrates an if statement that uses the OR operator to determine
    whether a password fails basic security rules (by including the string 'password'
    or being less than six characters long).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: OR 运算在任一操作数或两个操作数都为真时返回 true。你可以使用关键字 or 或双竖线（||）来编写 OR 运算。[清单 4-10](#lis4-10)
    展示了一个使用 OR 运算符的 if 语句，判断密码是否未通过基本安全规则（通过包含字符串 'password' 或长度小于六个字符）。
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 4-10: An if statement using the OR operator'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-10：一个使用 OR 运算符的 if 语句
- en: We declare the $password variable storing the string '1234'. Then we declare
    two Boolean variables to help with our test. First, $passwordContainsPassword
    is assigned the result of passing variable $password and string 'password' to
    the built-in str_contains() function. This function returns true if the second
    string argument (the “needle”) is found anywhere inside the first string argument
    (the “haystack”), or false otherwise. Since in this case the $password variable
    doesn’t contain the string 'password', $passwordContainsPassword will contain
    false. The other Boolean variable, $passwordTooShort, will be true if the length
    of $password is less than 6, tested with the built-in strlen() function. Since
    the string '1234' in $password is less than six characters long, this variable
    will be assigned the value true.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个 $password 变量，存储字符串 '1234'。然后我们声明了两个布尔变量来帮助测试。首先，$passwordContainsPassword
    被赋值为将变量 $password 和字符串 'password' 传递给内置的 str_contains() 函数的结果。如果第二个字符串参数（“needle”）在第一个字符串参数（“haystack”）中找到，函数返回
    true，否则返回 false。由于此例中 $password 变量不包含字符串 'password'，$passwordContainsPassword
    的值为 false。另一个布尔变量 $passwordTooShort，如果 $password 的长度小于 6，则为 true，通过内置的 strlen()
    函数进行测试。由于 $password 中的字符串 '1234' 长度小于六个字符，因此该变量将被赋值为 true。
- en: 'Finally, we declare an if statement, using the OR operator (||) to create the
    condition based on the two Boolean variables ❶. Since at least one of the variables
    is true, the if statement condition passes, and a message prints indicating the
    password is insecure:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们声明一个 if 语句，使用 OR 运算符（||）根据两个布尔变量 ❶ 创建条件。由于至少有一个变量为真，if 语句条件通过，并打印出一条消息，指示密码不安全：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Try changing the value of $password to be a string six characters or longer
    (other than 'password')—for example, "red$99poppy". Then neither $passwordContainsPassword
    nor $passwordTooShort will be true, so the logical OR test in the if statement
    will be false and no message will be printed out.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 $password 的值更改为六个字符或更长的字符串（不是 'password'），例如 "red$99poppy"。此时，$passwordContainsPassword
    和 $passwordTooShort 都不会为 true，因此 if 语句中的逻辑 OR 测试将为假，且不会打印任何消息。
- en: XOR
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 异或
- en: An XOR operation (short for *exclusive OR*) is true when only one of the operands
    is true but not both. We use keyword xor to create an XOR expression. [Listing
    4-11](#lis4-11) illustrates an if...else statement using an XOR operation. The
    code determines whether a dessert is creamy but not too creamy. (Custard *and*
    ice cream would be too much!)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 异或运算（XOR，*exclusive OR*）仅在两个操作数中只有一个为真时返回 true，而两个都不为真时返回 false。我们使用关键字 xor
    来创建一个 XOR 表达式。[清单 4-11](#lis4-11) 展示了一个使用 XOR 运算符的 if...else 语句。该代码判断一个甜点是否奶油丰富，但不至于过于奶油。
    （卡仕达 *和* 冰淇淋就太多了！）
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 4-11: An if...else statement with the xor operator'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-11：一个带有异或运算符的 if...else 语句
- en: We declare two Boolean variables, $containsIceCream and $containsCustard, setting
    one to true and the other to false. Then we declare an if...else statement with
    the condition $containsIceCream xor $containsCustard. Thanks to the XOR operator,
    if one but not both of these variables is true, the condition will evaluate to
    true, and a nice creamy dessert will be printed out. If neither variable is true,
    or if both variables are true, then the XOR expression will be false, and either
    too creamy or not creamy enough! will be printed instead.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了两个布尔变量 $containsIceCream 和 $containsCustard，将其中一个设置为 true，另一个设置为 false。然后我们声明了一个
    if...else 语句，条件为 $containsIceCream xor $containsCustard。由于 XOR 运算符的缘故，若这两个变量中只有一个为真，条件将评估为真，并打印出一条美味的奶油甜点消息。如果两个变量都不为真，或者两个都为真，则
    XOR 表达式为假，相应地会打印出“奶油过多”或“奶油不足”的消息。
- en: In this example, since only one variable is true, we should get the nice creamy
    dessert message. Try playing with the values of the two Boolean variables and
    see how the result of the XOR expression is affected.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，由于只有一个变量为 true，我们应该会得到一条漂亮的奶油甜点消息。尝试更改两个布尔变量的值，看看 XOR 表达式的结果如何受到影响。
- en: switch Statements
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: switch 语句
- en: A switch statement is a conditional structure that tests a variable against
    several possible values, or *cases*. Each case has one or more statements to be
    executed if its value matches the variable’s (after type juggling, so it performs
    equality tests like ==). You can also provide a default case if none of the values
    match. If you need to choose from three or more possible paths, a switch statement
    is a convenient alternative to an if...elseif...else statement, as long as the
    decision hinges on the value of a single variable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: switch 语句是一种条件结构，用于将一个变量与多个可能的值进行比较，或称为 *case*。每个 case 有一个或多个语句，如果其值与变量匹配（通过类型转换，因此它执行类似
    == 的相等性测试），则这些语句会被执行。你还可以提供一个默认的 case，如果没有任何值匹配。如果你需要从三个或更多可能的路径中选择，switch 语句是
    if...elseif...else 语句的一个方便替代方案，只要决策依据是单一变量的值。
- en: '[Listing 4-12](#lis4-12) shows a switch statement that prints an appropriate
    message about the local currency based on the value of the $country variable.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-12](#lis4-12) 显示了一个 switch 语句，该语句根据 $country 变量的值打印相应的货币信息。'
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 4-12: Using a switch statement to print the currency based on the value
    of $country'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-12：使用 switch 语句根据 $country 的值打印货币
- en: First, we assign $country the value 'Ireland'. Then we begin a switch statement
    with the keyword switch followed by the variable to be tested in parentheses ($country)
    ❶. The remainder of the switch statement is enclosed in a set of curly brackets.
    Within the switch statement, we declare the values of $country to check, each
    in its own indented case clause. Each case clause is defined using the keyword
    case, followed by the value to be tested, followed by a colon (:). Then come the
    statements to execute if that case is a match on new, further indented lines.
    For example, if the value of $country is 'UK' ❷, the message The pound is the
    currency of UK will print.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 $country 赋值为 'Ireland'。然后，我们开始一个 switch 语句，使用 switch 关键字并将要测试的变量放在括号中（$country）❶。switch
    语句的其余部分被一对花括号括起来。在 switch 语句内部，我们声明需要检查的 $country 的值，每个值都在各自的缩进的 case 子句中定义。每个
    case 子句使用 case 关键字定义，后跟要测试的值，再后跟一个冒号（:）。然后，如果该 case 匹配，就在新的、更深的缩进行中写出要执行的语句。例如，如果
    $country 的值是 'UK' ❷，则会打印出信息：The pound is the currency of UK（英镑是英国的货币）。
- en: If you want the same set of actions to apply to multiple cases, list those cases
    one after the other, followed just once by the statement(s) to execute. For example,
    Ireland, France, and Spain all use the euro, so we’ve listed those cases in sequence
    ❸. The print statement after those cases ❹ will apply to any of them; you don’t
    need to repeat it for each case.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望相同的操作适用于多个 case，可以将这些 case 按顺序列出，只需在最后列出一次要执行的语句。例如，爱尔兰、法国和西班牙都使用欧元，因此我们按顺序列出了这些
    case ❸。这些 case 后面的 print 语句 ❹ 将适用于它们中的任何一个；你不需要为每个 case 重复该语句。
- en: Our script features an additional case for when $country has the value 'USA'.
    Then the final part of the switch statement declares a default case using the
    default keyword rather than case ❺. This default will be executed if none of the
    other cases match the variable being tested. Given that we set $country to 'Ireland',
    the script should output the message The euro is the currency of Ireland.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本为当 $country 的值为 'USA' 时增加了一个额外的 case。然后，switch 语句的最后部分使用 default 关键字声明一个默认的
    case，而不是使用 case ❺。如果没有任何其他 case 与正在测试的变量匹配，默认的 case 会被执行。考虑到我们将 $country 设置为 'Ireland'，脚本应该输出信息：The
    euro is the currency of Ireland（欧元是爱尔兰的货币）。
- en: 'Notice that we’ve included the break keyword in each case’s statement group,
    after each print statement. This interrupts, or *breaks out of*, the switch statement,
    preventing any further code in that statement from being executed. The role of
    break statements is essential to understand. Once a matching case has been found,
    all remaining statements in the body of the switch statement are executed, even
    statements from other, nonmatching cases, unless a break statement is encountered
    to interrupt the execution. If we removed all the break statements from [Listing
    4-12](#lis4-12), for example, we’d end up with the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在每个 case 的语句组中都包含了 break 关键字，在每个 print 语句后面。这会中断，或*跳出* switch 语句，防止执行该语句中的任何后续代码。理解
    break 语句的作用非常重要。一旦找到匹配的 case，switch 语句主体中的所有剩余语句都会被执行，即使是其他不匹配的 case 的语句，除非遇到
    break 语句中断执行。例如，如果我们从 [清单 4-12](#lis4-12) 中删除所有的 break 语句，最终输出将是：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The value of $country is 'Ireland', not 'UK', so the first case isn’t a match,
    and the first print statement is skipped. Once we encounter the 'Ireland' case,
    however, the remaining three print statements execute, since there aren’t any
    break statements to interrupt the switch statement. This is rarely the behavior
    you’ll want from a switch statement, so in almost every situation, you’ll need
    to add a break statement to the end of each case (or set of cases), as we’ve done
    in [Listing 4-12](#lis4-12).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`$country` 的值是 ''Ireland''，而不是 ''UK''，因此第一个 case 不匹配，第一个打印语句被跳过。然而，一旦我们遇到 ''Ireland''
    的 case，接下来的三个打印语句就会执行，因为没有 `break` 语句来中断 `switch` 语句。这通常不是你希望从 `switch` 语句中得到的行为，因此几乎在每种情况下，你都需要在每个
    case（或一组 cases）的末尾添加 `break` 语句，就像我们在 [示例 4-12](#lis4-12) 中所做的那样。'
- en: match Statements
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`match` 语句'
- en: A match statement chooses a value for a variable based on the value of another
    variable. You could accomplish the same task with a switch statement, but match
    statements are written much more compactly. Also, match statements rely on strict
    comparisons (the equivalent to testing for identity with ===), whereas switch
    statements make comparisons after any relevant type juggling (the equivalent to
    testing for equality with ==). Therefore, the time to use a match statement over
    a switch statement is when a variable needs to be tested against multiple values
    of the same type, and when the action to perform based on that test is to assign
    a value to a variable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`match` 语句根据另一个变量的值为一个变量选择一个值。你可以使用 `switch` 语句来完成相同的任务，但 `match` 语句更加简洁。此外，`match`
    语句依赖于严格比较（相当于使用 `===` 测试身份），而 `switch` 语句在进行任何类型转换后才进行比较（相当于使用 `==` 测试相等）。因此，当一个变量需要与多个相同类型的值进行比较，并且根据该测试执行的操作是为变量赋值时，使用
    `match` 语句会更合适。'
- en: '[Listing 4-13](#lis4-13) shows the same logic as [Listing 4-12](#lis4-12)’s
    switch statement, implemented with a match statement instead.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-13](#lis4-13) 展示了与 [示例 4-12](#lis4-12) 中的 `switch` 语句相同的逻辑，但采用了 `match`
    语句来实现。'
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 4-13: Using a match statement to set $currency based on the value of
    $country'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-13：使用 `match` 语句根据 `$country` 的值设置 `$currency`
- en: We write the match statement as part of the assignment of the $currency variable
    ❶. It consists of the match keyword, followed by the variable to check in parentheses,
    followed by a comma-separated sequence of *arms* enclosed in curly brackets. Each
    arm is written in the form x => y, where y is the value to assign to $currency
    if the value of $country matches x. As with the switch statement, we provide a
    default arm in case none of the values match ❷. After the match statement, we
    print out a message including the values of $country and $currency.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `match` 语句写成 `$currency` 变量赋值的一部分 ❶。它由 `match` 关键字组成，后面跟着要检查的变量（括号内），接着是由逗号分隔的、用大括号包围的
    *arms* 序列。每个 arm 的形式是 `x => y`，其中 y 是当 `$country` 的值与 x 匹配时赋值给 `$currency` 的值。与
    `switch` 语句一样，我们还提供了一个默认的 arm，以防没有值匹配 ❷。在 `match` 语句之后，我们打印一条消息，包含 `$country`
    和 `$currency` 的值。
- en: Compared to the switch statement in [Listing 4-12](#lis4-12), this match statement
    is more concise. After assigning a value to $currency, we have to write only a
    single print statement, as opposed to including a separate print statement for
    each case of the switch statement. We also no longer need all the break statements;
    with a match statement, once a match has been found, the rest of the statement
    is ignored.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [示例 4-12](#lis4-12) 中的 `switch` 语句相比，这个 `match` 语句更简洁。赋值给 `$currency` 后，我们只需要写一个打印语句，而不需要为
    `switch` 语句中的每个 case 写一个单独的打印语句。我们也不再需要所有的 `break` 语句；使用 `match` 语句后，一旦找到匹配，余下的语句会被忽略。
- en: The match statement is a relative newcomer to the PHP language. Many experienced
    programmers still use switch where match would be more efficient. (I’m guilty
    of this myself sometimes.) In general, if you’re testing a variable against multiple
    values, I recommend trying a match statement first. Only if that solution is found
    inadequate should you change to a switch statement.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`match` 语句是 PHP 语言中新出现的一种语法。许多经验丰富的程序员仍然使用 `switch`，而在某些情况下，`match` 更加高效。（我有时也会犯这个错误。）一般来说，如果你需要测试一个变量的多个值，我建议你首先尝试使用
    `match` 语句。只有在该方案不适用时，才应切换到 `switch` 语句。'
- en: The Ternary Operator
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'PHP’s *ternary operator* (or *three-part operator*) selects one of two values,
    depending on whether a test is true or false. The operator consists of two separate
    symbols, a question mark (?) and a colon (:), and is written in the following
    form:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的*三元运算符*（或*三部分运算符*）根据测试条件是否为真来选择两个值之一。这个运算符由两个独立的符号组成，一个问号（?）和一个冒号（:），并且按以下形式书写：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To the left of the question mark, you write a Boolean expression that evaluates
    to true or false (for example, comparing two values). To the right of the question
    mark, you write two values separated by a colon. If the Boolean expression is
    true, the value to the left of the colon is chosen (valueIfTrue). If the Boolean
    expression is false, the value to the right of the colon is chosen (valueIfFalse).
    Usually, the result is assigned to a variable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 问号左侧写一个布尔表达式，它的值为真或假（例如，比较两个值）。问号右侧写两个由冒号分隔的值。如果布尔表达式为真，则选择冒号左侧的值（valueIfTrue）。如果布尔表达式为假，则选择冒号右侧的值（valueIfFalse）。通常，结果会赋值给一个变量。
- en: 'Essentially, the ternary operator provides a more succinct way to write an
    if...else statement, as long as the purpose of the if...else statement is to assign
    a value to a variable (as opposed to performing another sequence of actions).
    To illustrate, [Listing 4-14](#lis4-14) shows two ways to choose between two values
    for $currency based on the value of $region: first using an if...else statement
    and then using the ternary operator.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，三元运算符提供了一种更简洁的方式来编写if...else语句，只要if...else语句的目的是给变量赋值（而不是执行其他操作）。为了说明，[列表4-14](#lis4-14)展示了根据$region的值选择$currency的两种方法：首先使用if...else语句，然后使用三元运算符。
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 4-14: Comparing if...else and ternary operator statements'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-14：比较if...else和三元运算符语句
- en: 'We assign $region the value ''Europe''. Then we declare an if...else statement
    that sets the value of $currency to ''euro'' if the region is ''Europe'' or to
    ''dollar'' otherwise ❶. We print out a message to verify the result. Next, we
    change $region to ''USA'' and reassign $currency by using the ternary operator
    ❷. The ternary operator expression follows the same logic as the if...else statement:
    if $region equals ''Europe'', the code sets $currency to ''euro'', and if not,
    the code sets $currency to ''dollar''. Again, we print a message to check the
    result. Here’s the output of running the script:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将$region赋值为'欧洲'。然后声明一个if...else语句，如果地区是'欧洲'，则将$currency的值设置为'euro'，否则设置为'dollar'
    ❶。我们打印一条消息以验证结果。接下来，我们将$region更改为'美国'，并使用三元运算符重新赋值$currency ❷。三元运算符表达式遵循与if...else语句相同的逻辑：如果$region等于'欧洲'，代码将$currency设置为'euro'，否则将$currency设置为'dollar'。再次，我们打印消息以检查结果。以下是运行脚本后的输出：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The second line shows that the ternary operator has worked as expected, assigning
    'dollar' as the value of $currency because the value in $region wasn’t 'Europe'.
    As you can see, in a case like this that requires a straightforward decision between
    two possible values, the ternary operator is concise, using just one line of code
    compared to the four lines of the if...else statement.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行显示三元运算符已按预期工作，因为$region的值不是'欧洲'，因此$currency的值被赋为'dollar'。正如你所见，在这种需要在两个可能的值之间做出简单选择的情况下，三元运算符非常简洁，只有一行代码，而if...else语句则有四行代码。
- en: The Null-Coalescing Operator
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空合并运算符
- en: 'Another operator that chooses between two values is the *null-coalescing operator*,
    indicated with a double question mark (??). This operator makes its choice depending
    on whether a variable is NULL. The general form of an expression using the null-coalescing
    operator is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在两个值之间进行选择的运算符是*空合并运算符*，使用两个问号（??）表示。这个运算符根据变量是否为NULL来做出选择。使用空合并运算符的表达式的一般形式如下：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, the null-coalescing operator checks value, the expression on the left
    of the ?? operator. This could be a variable, or perhaps a function that returns
    a value. If this expression isn’t NULL, then value is assigned to $variable. Otherwise,
    the value to the right of the null-coalescing operator (valueIfNull) is assigned
    to the variable instead. This provides a fallback in case a variable hasn’t been
    defined (or contains NULL), without raising a warning or error. This mechanism
    is especially useful when you’re expecting a value from a user but none has been
    provided, or when you’re looking for a record in a database and the record doesn’t
    exist.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，空合并运算符检查左侧的值，即 ?? 运算符左侧的表达式。这可以是一个变量，或者是一个返回值的函数。如果该表达式不是 NULL，则将值赋给 $variable。否则，空合并运算符右侧的值（valueIfNull）将被赋给该变量。这提供了一种后备机制，防止在变量未定义（或为
    NULL）时抛出警告或错误。当你期望从用户那里获得一个值但没有提供，或者当你在数据库中查找记录而该记录不存在时，这种机制特别有用。
- en: '[Listing 4-15](#lis4-15) shows the null-coalescing operator in action. We use
    it to test the $lastname_from_user variable twice, first before it’s been assigned
    any value (and therefore is NULL), then a second time after it’s been given a
    value.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-15](#lis4-15) 显示了空合并运算符的使用示例。我们使用它来测试 $lastname_from_user 变量两次，第一次是在它还未被赋值时（因此是
    NULL），第二次是在它被赋值之后。'
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 4-15: Testing for NULL with the null-coalescing operator'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-15：使用空合并运算符测试 NULL
- en: 'First, we use the null-coalescing operator to set the value of $lastname ❶.
    The operator tests the $lastname_from_user variable, which hasn’t been assigned
    a value yet, and so is NULL. Therefore, $lastname should be assigned the value
    to the right of the ?? operator (the string ''Anonymous''). We print out a message
    to check the result. Then, after assigning a value to $lastname_from_user, we
    use the same null-coalescing operator expression to again set the value of $lastname
    ❷. This time, since $lastname_from_user contains a non-NULL value, that value
    should be passed along to $lastname. Here’s the result:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用空合并运算符来设置 $lastname ❶ 的值。该运算符测试 $lastname_from_user 变量，由于该变量尚未被赋值，因此为
    NULL。因此，$lastname 应该被赋予 ?? 运算符右侧的值（字符串 'Anonymous'）。我们打印出一条消息以检查结果。接着，在给 $lastname_from_user
    赋值后，我们使用相同的空合并运算符表达式再次设置 $lastname 的值 ❷。这次，由于 $lastname_from_user 包含非 NULL 值，该值应该被传递给
    $lastname。以下是结果：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first line shows that, since variable $lastname_from_user is NULL, $lastname
    is assigned the string 'Anonymous'. The second time around, however, the string
    'Smith' inside $lastname_from_user is successfully stored in the $lastname variable
    and printed out.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行显示，由于变量 $lastname_from_user 为 NULL，$lastname 被赋值为字符串 'Anonymous'。然而，第二次，$lastname_from_user
    中的字符串 'Smith' 成功地存储在 $lastname 变量中并被打印出来。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小结
- en: In this chapter, you’ve learned about the keywords and operators for writing
    code that makes decisions. Much of the power of computers and programming languages
    is built upon the kinds of operators and choice statements we’ve discussed. You
    saw how if and if...else statements make a choice based on a single test, although
    that test may itself combine Boolean expressions with logical operators such as
    AND or OR. You also saw how to incorporate multiple tests by adding elseif branches
    between the if and the else. Then you learned about other conditional structures,
    including switch and match statements, that test a variable for different possible
    values. These structures let you define one or more statements to be executed
    when a particular value is found. Closely related to these are the ternary and
    null-coalescing operators, which both choose between two possible values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了用于编写做出决策的代码的关键字和运算符。计算机和编程语言的许多强大功能都建立在我们讨论的各种运算符和选择语句上。你看到 if 和 if...else
    语句如何基于单一测试做出选择，尽管该测试本身可能会结合布尔表达式与逻辑运算符，如 AND 或 OR。你还看到了如何通过在 if 和 else 之间添加 elseif
    分支来结合多个测试。然后你学习了其他条件结构，包括 switch 和 match 语句，它们会测试变量是否具有不同的可能值。这些结构允许你定义一个或多个在找到特定值时执行的语句。与这些结构紧密相关的是三元运算符和空合并运算符，它们都在两个可能的值之间做选择。
- en: '### Exercises'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '### 练习'
- en: 1.   Write a script that assigns a name to the $name variable and then prints
    the message That is a short name if the length of the string is less than four
    characters.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   编写一个脚本，将一个名字赋值给 $name 变量，然后如果字符串的长度小于四个字符，则打印消息 "That is a short name"。
- en: 2.   Write a script that determines the size of the machine you need for your
    laundry. The script should check the value of the $laundryWeightKg variable and
    print Fits in standard machine if the value is less than 9, or print Needs medium
    to large machine otherwise.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   编写一个脚本，用于确定洗衣机的大小。该脚本应检查变量$laundryWeightKg的值，如果值小于9，则打印“适合标准洗衣机”，否则打印“需要中型到大型洗衣机”。
- en: '3.   Use a switch statement or a match statement to test the value of the $vehicle
    variable and print an appropriate message based on that value. Use the following
    value/message combinations:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   使用switch语句或match语句测试$vehicle变量的值，并根据该值打印相应的消息。使用以下值/消息组合：
- en: bus   "Beep beep"
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: bus   "滴滴声"
- en: train   "Runs on tracks"
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: train   "在轨道上行驶"
- en: car   "Has at least three wheels"
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: car   "至少有三个轮子"
- en: helicopter   "Can fly"
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: helicopter   "可以飞行"
- en: bicycle   "You never forget once you've learned"
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: bicycle   "学会了就永远不会忘记"
- en: '**(None of the above)**   "You''ve chosen the road less traveled"'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**(上述内容无)**   "你选择了人迹罕至的道路"'
- en: 4.   Write a script that prints the message You are now logged in if both $userNameCorrect
    and $passwordCorrect are true. Otherwise, print Invalid credentials, please try
    again.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   编写一个脚本，如果$用户名字正确且$密码正确，打印消息“您现在已登录”。否则，打印“凭证无效，请重试”。
