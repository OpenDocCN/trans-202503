- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">QUANTUM
    AND POST-QUANTUM</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">量子与后量子</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, we’ll examine the future of cryptography over a time horizon
    of, say, a century or more—one in which quantum computers may exist. Quantum computers
    leverage phenomena from quantum physics to run different kinds of algorithms than
    we’re used to. While large quantum computers don’t exist yet, they have the potential
    to break RSA, Diffie–Hellman, and elliptic curve cryptography—all the public-key
    crypto deployed or standardized as of this writing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨加密学的未来，假设一个百年或更长的时间跨度——届时量子计算机可能已经存在。量子计算机利用量子物理中的现象来运行我们不常见的不同类型的算法。虽然目前还没有大型量子计算机，但它们有潜力破解RSA、Diffie–Hellman协议和椭圆曲线加密——这些是截至目前部署或标准化的所有公钥加密算法。
- en: To ensure against the quantum computing risk, cryptography researchers have
    developed alternative public-key *post-quantum* algorithms. In 2015, the NSA called
    for a transition to quantum-resistant algorithms, and in 2017 NIST began a process
    to standardize post-quantum algorithms, which they announced as part of new standards
    in 2022.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对量子计算的风险，密码学研究人员已开发出替代性的公钥*后量子*算法。2015年，美国国家安全局（NSA）呼吁转向量子抗性算法，而在2017年，美国国家标准与技术研究院（NIST）开始了一项标准化后量子算法的过程，并在2022年发布了相关的新标准。
- en: This chapter provides a nontechnical overview of the principles behind quantum
    computers as well as a glimpse of post-quantum algorithms. There’s some math involved,
    but only basic arithmetic and linear algebra, so don’t fret about the unusual
    notations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了关于量子计算机原理的非技术性概述，并简要介绍了后量子算法。虽然其中涉及一些数学内容，但只是基础的算术和线性代数，所以不用担心那些不常见的符号。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Quantum Computers Work</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">量子计算机如何工作</samp>
- en: Quantum computing uses quantum physics to compute differently and perform tasks
    that classical computers can’t, such as breaking RSA and elliptic curve cryptography
    efficiently. A quantum computer is not a superfast normal computer. In fact, quantum
    computers can’t efficiently solve any problem that’s too hard for a classical
    computer, such as brute-force search or **NP**-hard problems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算利用量子物理以不同的方式进行计算，执行传统计算机无法完成的任务，比如高效地破解RSA和椭圆曲线加密。量子计算机并不是一种超快的普通计算机。事实上，量子计算机无法高效地解决那些传统计算机也无法解决的复杂问题，比如暴力搜索或**NP**-难题。
- en: 'Quantum mechanics—the branch of physics that studies the behavior of subatomic
    particles, which behave truly randomly—is the basis of quantum computers. Unlike
    classical computers, which operate on bits that are either 0 or 1, quantum computers
    operate on *quantum bits* (or *qubits*), which can be “both 0 and 1 simultaneously.”
    This is a state of ambiguity called *superposition*, where my quotation marks
    indicate an oversimplification. In this microscopic world, physicists discovered
    that particles such as electrons and photons behave in a highly counterintuitive
    way: before you observe an electron, it isn’t at a definite location in space
    but in several locations at the same time (that is, in a state of superposition).
    Once you observe it—an operation called *measurement* —it stops at a fixed, random
    location and is no longer in superposition; the quantum state *collapsed*. This
    enables the creation of qubits in a quantum computer, along with the phenomena
    of entanglement and interference.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 量子力学——研究亚原子粒子行为的物理学分支，这些粒子的行为是真正随机的——是量子计算机的基础。与传统计算机不同，传统计算机通过位（bit）来工作，而这些位只能是0或1，量子计算机则通过*量子位*（或*量子比特*）来工作，量子比特可以“同时是0和1”。这是一种模糊的状态，称为*叠加*，我的引号表示这是一种过于简化的说法。在这个微观世界中，物理学家发现，像电子和光子这样的粒子以一种高度反直觉的方式表现：在你观察电子之前，它并不在空间的一个确定位置，而是在多个位置同时存在（也就是处于叠加状态）。一旦你观察它——这个操作叫做*测量*——它会停在一个固定的、随机的位置，且不再处于叠加状态；量子态*坍缩*了。这使得在量子计算机中创造量子比特成为可能，并且伴随着量子纠缠和干涉现象的出现。
- en: Quantum computers work because of *entanglement*, wherein two particles are
    connected (entangled) in a way that observing the value of one gives the value
    of the other, even if the two particles are widely separated (kilometers or even
    light-years away from each other). The *Einstein–Podolsky–Rosen (EPR) paradox*
    illustrates this behavior, which caused Albert Einstein to initially dismiss quantum
    mechanics. (See *[https://<wbr>plato<wbr>.stanford<wbr>.edu<wbr>/entries<wbr>/qt<wbr>-epr<wbr>/](https://plato.stanford.edu/entries/qt-epr/)*
    for an in-depth explanation.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算机的工作原理依赖于*纠缠*，即两个粒子以一种方式相互连接（纠缠），使得观察其中一个的值能够得到另一个的值，即使这两个粒子相隔甚远（可能是几公里，甚至是光年）。*爱因斯坦-波多尔斯基-罗森（EPR）悖论*阐述了这一现象，正是这一现象让阿尔伯特·爱因斯坦最初否定了量子力学。（详见*[https://<wbr>plato<wbr>.stanford<wbr>.edu<wbr>/entries<wbr>/qt<wbr>-epr<wbr>/](https://plato.stanford.edu/entries/qt-epr/)*了解更深入的解释。）
- en: '*Interference* is also crucial to the operation of quantum computers. With
    this property, particles can combine or cancel out each other’s effects due to
    their wave-like nature, as the double-slit experiment famously illustrates. Quantum
    computing exploits interference so that the “waves” of valid solutions reinforce
    each other and invalid solutions cancel each other out.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*干涉*对于量子计算机的运作也至关重要。利用这一特性，粒子可以因其波动性而相互结合或相互抵消正如著名的双缝实验所示。量子计算利用干涉作用，使得有效解的“波”相互增强，而无效解的波则相互抵消。'
- en: To explain how a quantum computer works, I’ll distinguish the actual quantum
    computer (the hardware, including its quantum bits) from quantum algorithms (the
    software that runs on it, composed of *quantum gates*).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释量子计算机的工作原理，我将区分实际的量子计算机（硬件，包括其量子比特）与量子算法（运行在其上的软件，由*量子门*组成）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Quantum Bits</samp>
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">量子比特</samp>
- en: You can characterize qubits, or groups thereof, with *amplitudes*, which are
    numbers akin to probabilities that aren’t *exactly* probabilities. Whereas a probability
    is a number between 0 and 1, an amplitude is a complex number of the form *a*
    + *bi* (that is, *a* + *b* × *i*), where *a* and *b* are real numbers and *i*
    is an *imaginary unit*. You use the number *i* to form *imaginary numbers* of
    the form *bi*, with *b* a real number. When you multiply *i* by a real number,
    you get another imaginary number, and multiplying it by itself it results in –1
    (that is, *i*² = –1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用*振幅*来表征量子比特或其组合，振幅是类似于概率的数字，但并不是*完全*的概率。概率是介于0和1之间的数字，而振幅是形式为*a* + *bi*（即*a*
    + *b* × *i*）的复数，其中*a*和*b*是实数，*i*是*虚数单位*。你使用数字*i*来形成形式为*bi*的*虚数*，其中*b*是实数。当你将*i*与实数相乘时，得到另一个虚数，再将其自身相乘会得到-1（即*i*²
    = -1）。
- en: Unlike real numbers, which you see as belonging to a line (see [Figure 14-1](chapter14.xhtml#fig14-1)),
    *complex numbers* belong to a plane (a space with two dimensions), as [Figure
    14-2](chapter14.xhtml#fig14-2) demonstrates.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与实数不同，实数你可以看作属于一条直线（见[图14-1](chapter14.xhtml#fig14-1)），*复数*属于一个平面（一个二维空间），正如[图14-2](chapter14.xhtml#fig14-2)所展示的那样。
- en: '![](../images/fig14-1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: A view of real
    numbers as points on an infinite straight line</samp>'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-1：实数作为无限直线上的点的示意图</samp>
- en: In [Figure 14-2](chapter14.xhtml#fig14-2), the x-axis corresponds to the *a*
    in *a* + *bi*, the y-axis corresponds to the *b*, and the dotted lines correspond
    to the real and imaginary parts of each number. For example, the vertical dotted
    line going from the point 3 + 2*i* down to 3 is two units long (the 2 in the imaginary
    part 2*i*).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-2](chapter14.xhtml#fig14-2)中，x轴对应于*a* + *bi*中的*a*，y轴对应于*b*，而虚线对应于每个数字的实部和虚部。例如，从点3
    + 2*i*到3的垂直虚线长2个单位（即虚部2*i*中的2）。
- en: '![](../images/fig14-2.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: A view of complex
    numbers as points in a two-dimensional space</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-2：复数作为二维空间中的点的示意图</samp>
- en: You can use the Pythagorean theorem to compute the length of the line segment
    going from the origin (0) to the point *a* + *bi* by viewing this line as the
    hypotenuse of a triangle. The hypotenuse’s length is equal to the square root
    of the sum of the squared coordinates of the point, or √(*a*² + *b*²), which is
    called the *modulus* of the complex number *a* + *bi*. You denote the modulus
    as |*a* + *bi*| and can use it as the length of a complex number.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用勾股定理来计算从原点（0）到点*a* + *bi*的线段长度，将这条线视为三角形的斜边。斜边的长度等于点坐标的平方和的平方根，或者√(*a*²
    + *b*²)，这叫做复数*a* + *bi*的*模*。你可以将模表示为|*a* + *bi*|，并将其作为复数的长度来使用。
- en: In a quantum computer, registers consist of one or more qubits in a state of
    superposition, which can be characterized by a set of such complex numbers, or
    amplitudes. But as you’ll see, these amplitudes can’t be just any numbers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在量子计算机中，寄存器由一个或多个量子比特组成，这些量子比特处于叠加态，可以通过一组这样的复数或振幅来表征。但是，正如你将看到的，这些振幅不能是任意的数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Amplitudes of a Single Qubit</samp>
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">单量子比特的振幅</samp>
- en: You can characterize a single qubit by two amplitudes that we’ll denote as α
    (alpha) and β (beta). You can then express a qubit’s state as α|0⟩ + ® |1⟩, where
    the | ⟩ notation denotes vectors in a quantum state. This notation means that
    when you observe this qubit, it appears as 0 with a probability |α|² and 1 with
    a probability |β|². For these to be actual probabilities, |α|² and |β|² must be
    numbers between 0 and 1, and |α|² + |β|² must be equal to 1.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两个振幅来描述单一量子比特，我们将其表示为α（alpha）和β（beta）。然后，你可以将量子比特的状态表示为α|0⟩ + β|1⟩，其中|
    ⟩表示量子态中的向量。这种表示意味着，当你观察这个量子比特时，出现0的概率是|α|²，出现1的概率是|β|²。为了使这些成为实际的概率，|α|²和|β|²必须是0和1之间的数，且|α|²
    + |β|²必须等于1。
- en: 'For example, say you have the qubit Ψ (psi) with amplitudes α = 1/√2 and β
    = 1/√2\. You express this as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有量子比特Ψ（psi），其振幅α = 1/√2和β = 1/√2。你可以按如下方式表示：
- en: '![](../images/pg276-1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg276-1.jpg)'
- en: 'In the qubit Ψ, the value 0 has an amplitude of 1/√2, and the value 1 has the
    same amplitude, 1/√2\. To get the actual probability from the amplitudes, compute
    the modulus of 1/√2 (which is equal to 1/√2 because it has no imaginary part)
    and then square it: (1/√2)² = 1/2\. This means that if you observe the qubit Ψ,
    you’ll have a 1/2 chance of seeing a 0 and the same chance of seeing a 1.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在量子比特Ψ中，值0的振幅是1/√2，值1的振幅也相同，都是1/√2。为了从振幅中得到实际的概率，计算1/√2的模（因为它没有虚部，所以模是1/√2），然后将其平方：(1/√2)²
    = 1/2。这意味着，如果你观察量子比特Ψ，你有1/2的机会看到0，看到1的机会也相同。
- en: 'Now consider the qubit Φ (phi), where:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑量子比特Φ（phi），其中：
- en: '![](../images/pg276-2.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg276-2.jpg)'
- en: 'The qubit Φ is fundamentally distinct from Ψ because unlike Ψ, where amplitudes
    have equal values, the qubit Φ has distinct amplitudes of α = *i*/√2 (a positive
    imaginary number) and β = –1/√2 (a negative real number). If, however, you observe
    Φ, the chance of seeing a 0 or 1 is 1/2, the same as it is with Ψ. Compute the
    probability of seeing a 0 as follows, based on the preceding rules:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 量子比特Φ与Ψ在本质上是不同的，因为与Ψ中振幅具有相同值不同，量子比特Φ具有不同的振幅，α = *i*/√2（一个正的虚数）和β = –1/√2（一个负的实数）。然而，如果你观察Φ，看到0或1的机会是1/2，和Ψ是一样的。根据之前的规则，计算看到0的概率如下：
- en: '![](../images/pg276-3.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg276-3.jpg)'
- en: Note that because α = *i*/√2, you can write α as *a* + *bi* with *a* = 0 and
    *b* = 1/√2, and computing |α| = √(*a*² + *b*²) yields 1/√2.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为α = *i*/√2，你可以将α写为*a* + *bi*，其中*a* = 0，*b* = 1/√2，计算|α| = √(*a*² + *b*²)得到1/√2。
- en: 'Different qubits can behave similarly to an observer (with the same probability
    of seeing a 0 for both qubits) but have different amplitudes. This says that the
    actual probabilities of seeing a 0 or a 1 characterize a qubit only partially;
    this is similar to observing the shadow of an object on a wall, which provides
    an idea of the object’s width and height but not of its depth. In the case of
    qubits, this hidden dimension is the value of its amplitude: Is it positive or
    negative? Is it a real or an imaginary number?'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的量子比特可能表现得很相似（对于两个量子比特，看到0的概率相同），但它们的振幅不同。这说明，看到0或1的实际概率只能部分地表征一个量子比特；这类似于观察物体在墙上的影子，它能提供物体的宽度和高度的提示，但无法得知其深度。在量子比特的情况下，这个隐藏的维度就是其振幅的值：它是正数还是负数？它是实数还是虚数？
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*To simplify notations, we often write a qubit as its pair of amplitudes (*α*,*
    β*). We can thus write the previous example as |*Ψ⟩ *= (1/√2, 1/√2).*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了简化符号，我们通常将一个量子比特写作它的一对振幅（*α*, *β*）。因此，我们可以将前面的例子写作|*Ψ⟩* = (1/√2, 1/√2)。*'
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Amplitudes of Groups
    of Qubits</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">量子比特组的振幅</samp>'
- en: 'How do we understand multiple qubits? For example, eight qubits can form a
    *quantum byte* when the quantum states of these eight qubits are connected via
    entanglement. You can describe such a quantum byte as follows, where the αs are
    the amplitudes associated with each of the 256 possible values of the group of
    eight qubits:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何理解多个量子比特呢？例如，当这八个量子比特的量子态通过纠缠连接时，它们可以形成一个*量子字节*。你可以如下描述这个量子字节，其中α是与这八个量子比特的256种可能值相关联的振幅：
- en: '![](../images/pg277-1.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg277-1.jpg)'
- en: Note that you must have |α[0]|² + |〈α[1]|² + . . . + |α[255]|² = 1 so that all
    probabilities sum to 1.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你必须满足|α[0]|² + |〈α[1]|² + . . . + |α[255]|² = 1，以使所有概率的总和为1。
- en: You can view this group of eight qubits as a set of 2⁸ = 256 amplitudes because
    it has 256 possible configurations, each with its own amplitude. In physical reality,
    however, you’d have eight physical objects, not 256\. The 256 amplitudes are an
    implicit characteristic of the group of eight qubits; each of these 256 numbers
    can take any of infinitely many different values. Generalizing, you can characterize
    a group of *n* qubits by a set of 2*^n* complex numbers, a number that grows exponentially
    with the numbers of qubits.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这八个量子比特视为一组2⁸ = 256个振幅，因为它有256种可能的配置，每种配置都有其独特的振幅。然而，在物理现实中，你将拥有八个物理对象，而不是256个。256个振幅是这组八个量子比特的隐性特征；这些256个数字中的每一个都可以取无穷多种不同的值。一般来说，你可以通过一组2*^n*个复数来描述*n*个量子比特的组，这个数量随着量子比特数目的增加而指数级增长。
- en: 'If you want to simulate the evolution of a quantum state using a classical
    computer, you need to store this exponential number of amplitudes and perform
    calculations to modify them. This requirement is one of the main reasons why a
    classical computer can’t efficiently simulate a quantum computer: doing so requires
    a gigantic amount of memory (of the order of 2*^n*) to store the same amount of
    information contained in just *n* qubits using a quantum system. In practice,
    you can simulate a maximum of 50 or 60 qubits, depending on the type of calculation.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用经典计算机模拟量子态的演化，你需要存储这个指数级别的振幅数量并进行计算来修改它们。这一要求是经典计算机无法高效模拟量子计算机的主要原因之一：因为这样做需要巨大的内存（大约是2*^n*的数量级），以存储一个量子系统中*
    n *个量子比特所包含的信息。实际上，你最多可以模拟50到60个量子比特，具体取决于计算的类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Quantum Gates</samp>
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">量子门</samp>
- en: The concepts of amplitude and *quantum gates* are unique to quantum computing.
    A quantum gate is essentially a transformation of one or more qubits, and it’s
    the counterpart of electronic gates in the quantum computing realm. Whereas a
    classical computer uses registers, memory, and a microprocessor to perform a sequence
    of instructions on data, a quantum computer transforms a group of qubits reversibly
    by applying a series of quantum gates and then measures the value of one or more
    qubits. Quantum computers promise more computing power because with only *n* qubits
    they can affect the values of 2*^n* amplitudes. This property has profound implications.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 振幅和*量子门*的概念是量子计算的独特特性。量子门本质上是对一个或多个量子比特的变换，它是量子计算领域中电子门的对应物。经典计算机使用寄存器、内存和微处理器对数据执行一系列指令，而量子计算机通过应用一系列量子门对一组量子比特进行可逆变换，然后测量一个或多个量子比特的值。量子计算机具有更强大的计算能力，因为仅凭*
    n *个量子比特，它们就能影响2*^n*个振幅的值。这一特性具有深远的影响。
- en: From a mathematical standpoint, quantum algorithms are essentially a circuit
    of quantum gates that transforms a set of complex numbers (the amplitudes) before
    a final measurement, where the value of 1 or more qubits is observed (see [Figure
    14-3](chapter14.xhtml#fig14-3)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学角度来看，量子算法本质上是一个量子门电路，它在最终测量之前会对一组复数（振幅）进行变换，在测量时观察一个或多个量子比特的值（见[图14-3](chapter14.xhtml#fig14-3)）。
- en: '![](../images/fig14-3.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: Principle of a
    quantum algorithm</samp>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-3：量子算法的原理</samp>
- en: We also refer to quantum algorithms as *quantum gate arrays* or *quantum circuits*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也将量子算法称为*量子门阵列*或*量子电路*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Quantum Gates as Matrix Multiplications</samp>
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">量子门作为矩阵乘法</samp>
- en: 'Unlike the Boolean gates of a classical computer (AND, XOR, and so on), a quantum
    gate acts on a group of amplitudes just as a matrix acts when multiplied with
    a vector. For example, to apply the simplest quantum gate, the *identity* gate,
    to the qubit Φ, we see *I* as a 2×2 identity matrix and multiply it with the column
    vector consisting of the two amplitudes of Φ:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与经典计算机的布尔门（与门、异或门等）不同，量子门作用于一组幅度，就像矩阵在与向量相乘时的作用一样。例如，要对量子比特Φ应用最简单的量子门——*恒等*门，我们将*I*视为一个2×2的恒等矩阵，并与由Φ的两个幅度组成的列向量相乘：
- en: '![](../images/pg278-1.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg278-1.jpg)'
- en: The result of this matrix–vector multiplication is another column vector with
    two elements, where the top value is equal to the dot product of the *I* matrix’s
    first line with the input vector (the result of adding the product of the first
    elements 1 and *i*/√2 to the product of the second elements 0 and –1/√2) and likewise
    for the bottom value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩阵-向量乘法的结果是另一个列向量，包含两个元素，其中上面的值等于*I*矩阵的第一行与输入向量的点积（即将第一元素1与*i*/√2的乘积与第二元素0与–1/√2的乘积相加的结果），底部值也类似。
- en: The identity gate *I* is pretty useless because it doesn’t do anything and leaves
    a qubit unchanged.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 恒等门*I*几乎没什么用，因为它不做任何事情，保持量子比特不变。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*In practice, a quantum computer wouldn’t explicitly compute matrix–vector
    multiplications because the matrices would be way too large. (That’s why a classical
    computer can’t simulate quantum computing.) Instead, a quantum computer would
    transform qubits as physical particles through physical transformations that are
    equivalent to a matrix multiplication. Confused? Here’s what Richard Feynman had
    to say: “If you are not completely confused by quantum mechanics, you do not understand
    it.”*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际上，量子计算机不会显式地计算矩阵-向量乘法，因为矩阵会大得太不可处理。（这也是为什么经典计算机无法模拟量子计算的原因。）相反，量子计算机会通过物理变换将量子比特转化为物理粒子，这些物理变换等效于矩阵乘法。困惑了吗？理查德·费曼曾说过：“如果你没有完全困惑于量子力学，那你就不理解它。”*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Hadamard Quantum Gate</samp>
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Hadamard量子门</samp>
- en: 'One of the most useful quantum gates is the *Hadamard gate*, usually denoted
    as *H*. You can define the Hadamard gate as follows (note the negative value in
    the bottom-right position):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最有用的量子门之一是*Hadamard门*，通常表示为*H*。你可以按如下方式定义Hadamard门（注意右下位置的负值）：
- en: '![](../images/pg279-1.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg279-1.jpg)'
- en: 'Applying this gate to the qubit |Ψ⟩ = (1/√2, 1/√2) results in the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个门作用于量子比特|Ψ⟩ = (1/√2, 1/√2)会得到以下结果：
- en: '![](../images/pg279-2.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg279-2.jpg)'
- en: 'By applying the Hadamard gate *H* to |Ψ⟩, you obtain the qubit |0⟩ for which
    the value |0⟩ has amplitude 1, and |1⟩ has amplitude 0\. This tells you that the
    qubit behaves deterministically: if you observe this qubit, you’ll always see
    a 0 and never a 1\. In other words, you’ve lost the randomness of the initial
    qubit |Ψ⟩.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将Hadamard门*H*作用于|Ψ⟩，你得到一个量子比特|0⟩，其中值|0⟩的幅度为1，|1⟩的幅度为0。这告诉你量子比特是确定性行为的：如果你观察这个量子比特，你总是会看到0，永远看不到1。换句话说，你失去了初始量子比特|Ψ⟩的随机性。
- en: 'Applying the Hadamard gate again to the qubit |0⟩ results in the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 再次将Hadamard门作用于量子比特|0⟩会得到以下结果：
- en: '![](../images/pg279-3.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg279-3.jpg)'
- en: This brings you back to the qubit |Ψ⟩ and a randomized state. We often use the
    Hadamard gate in quantum algorithms to go from a deterministic state to a uniformly
    random one.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使你回到量子比特|Ψ⟩并恢复随机状态。我们常在量子算法中使用Hadamard门，将确定性状态转变为均匀随机状态。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Not All Matrices Are Quantum
    Gates</samp>
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">并非所有矩阵都是量子门</samp>
- en: Although you can see the application of quantum gates as matrix multiplications,
    not all matrices correspond to quantum gates. Recall that a qubit consists of
    the complex numbers α and β, the amplitudes of the qubit, that satisfy the condition
    |α|² + |β|² = 1\. If you get two amplitudes that don’t match this condition after
    multiplying a qubit by a matrix, the result can’t be a qubit. Quantum gates correspond
    only to *unitary matrices*, which preserve the property |α|² + |β|² = 1.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以将量子门的应用视为矩阵乘法，但并不是所有的矩阵都对应量子门。回想一下，量子比特由复数 α 和 β 组成，分别是量子比特的幅度，满足条件 |α|²
    + |β|² = 1。如果你通过矩阵乘法对量子比特进行操作后得到的两个幅度不满足这个条件，那么结果就不能是一个量子比特。量子门仅对应 *单位矩阵*，它们保持
    |α|² + |β|² = 1 的特性。
- en: Unitary matrices (and quantum gates by definition) are *invertible*, meaning
    that given the result of an operation, you can compute back the original qubit
    by applying the *inverse* matrix. This is why quantum computing is a kind of *reversible
    computing*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵（以及量子门的定义）是 *可逆的*，这意味着给定一个操作的结果，你可以通过应用 *逆* 矩阵来计算回原始的量子比特。这就是为什么量子计算是一种
    *可逆计算* 的原因。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Quantum Speedup</samp>
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">量子加速</samp>
- en: A *quantum speedup* occurs when a quantum computer can solve a problem fundamentally
    faster than a classical one. For example, to search for an item among *n* items
    of an unordered list on a classical computer, you need on average *n*/2 operations
    because you need to look at each item in the list before finding the one you’re
    looking for. (On average, you’ll find that item after searching half of the list.)
    No classical algorithm can do better than *n*/2\. However, a quantum algorithm
    exists to search for an item in only *O*(√*n*) operations, which is orders of
    magnitude smaller than *n*/2\. For example, if *n* is equal to 1,000,000, then
    *n*/2 is 500,000, whereas √*n* is 1,000.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*量子加速*发生在量子计算机能够比经典计算机更快地解决问题时。例如，在经典计算机上查找一个无序列表中的 *n* 个项目时，平均需要进行 *n*/2 次操作，因为你需要查看列表中的每一项，直到找到你想要的那个。（平均来说，你将在查找列表的一半后找到该项。）没有任何经典算法能够比
    *n*/2 更快。然而，存在一种量子算法可以仅用 *O*(√*n*) 次操作来查找某个项，这比 *n*/2 少了几个数量级。例如，如果 *n* 等于 1,000,000，则
    *n*/2 为 500,000，而 √*n* 为 1,000。'
- en: We quantify the difference between quantum and classical algorithms in terms
    of *time complexity*, which we represent with the *O*() notation. In the previous
    example, the quantum algorithm runs in time *O*(√*n*), but the classical algorithm
    can’t be faster than *O*(*n*). Because this difference in time complexity is due
    to the square exponent, we call this *quadratic speedup*. While such a speedup
    likely makes a difference, there are much more powerful ones.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 *时间复杂度* 来量化量子算法与经典算法之间的差异，我们用 *O*() 表示法来表示时间复杂度。在前面的例子中，量子算法的运行时间是 *O*(√*n*)，而经典算法的运行时间不可能比
    *O*(*n*) 更快。由于这种时间复杂度的差异是由于平方指数的关系，我们称之为 *二次加速*。虽然这样的加速可能带来不同，但实际上还有更强大的加速。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exponential Speedup
    and Simon’s Problem</samp>
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">指数加速与西蒙问题</samp>
- en: '*Exponential speedups* are the holy grail of quantum computing. They occur
    when a task that takes an exponential amount of time on a classical computer,
    such as *O*(2*^n*), can be performed on a quantum computer with polynomial complexity—namely,
    *O*(*n**^k*) for some fixed number *k*. This exponential speedup can turn a practically
    impossible task into a possible one. (Recall from [Chapter 9](chapter9.xhtml)
    that cryptographers and complexity theorists associate exponential time with the
    impossible and polynomial time with the practical.)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*指数加速*是量子计算的圣杯。当一个在经典计算机上需要指数级时间（例如 *O*(2*^n*)）来完成的任务，能够在量子计算机上以多项式复杂度执行时——即
    *O*(*n**^k*)，其中 *k* 为某个固定数字时，就会出现指数加速。这种指数加速能够将一个几乎不可能完成的任务变为可能。（回想一下在[第9章](chapter9.xhtml)中，密码学家和复杂性理论家将指数级时间与不可能任务联系在一起，将多项式时间与实际任务联系在一起。）'
- en: 'The poster child of exponential speedups is *Simon’s problem*. In this computational
    problem, a function, **f**(), transforms *n*-bit strings to *n*-bit strings, such
    that the output of **f**() looks like a random *n*-bit string, but with one constraint:
    there’s a secret value, *m*, such that for any two values *x*, *y*, we have **f**(*x*)
    = **f**(*y*) if and only if *y* = *x* ⊕ *m*. Simon’s problem consists in finding
    *m* given black-box access to **f**().'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 指数加速的典型例子是*Simon问题*。在这个计算问题中，一个函数**f**()将*n*位字符串转换为*n*位字符串，使得**f**()的输出看起来像一个随机的*n*位字符串，但有一个限制：存在一个秘密值*m*，使得对于任意两个值*x*、*y*，我们有**f**(*x*)
    = **f**(*y*)当且仅当*y* = *x* ⊕ *m*。Simon问题的任务是，在给定黑箱访问**f**()的情况下找到*m*。
- en: Solving Simon’s problem with a classical algorithm boils down to finding a collision,
    or values *x* and *y* such that **f**(*x*) = **f**(*y*). This takes approximately
    2*^n*^(/2) queries to **f**(). However, [Figure 14-4](chapter14.xhtml#fig14-4)
    shows that a quantum algorithm can solve Simon’s problem in only approximately
    *n* queries, with the extremely efficient time complexity of *O*(*n*).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 用经典算法解决Simon问题归结为找到碰撞，或者找到值*x*和*y*，使得**f**(*x*) = **f**(*y*)。这大约需要2*^n*^(/2)次查询**f**()。然而，[图14-4](chapter14.xhtml#fig14-4)显示，量子算法仅需大约*n*次查询即可解决Simon问题，且具有极高的时间效率，时间复杂度为*O*(*n*)。
- en: '![](../images/fig14-4.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: The circuit of
    the quantum algorithm that solves Simon’s problem efficiently</samp>'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-4：解决Simon问题的量子算法电路</samp>
- en: In the quantum circuit solving Simon’s problem, you initialize 2*n* qubits to
    |0⟩, apply Hadamard gates (*H*) to the first *n* qubits, and then apply the gate
    *Q***[f]** to the two groups of all *n* qubits. Given two *n*-qubit groups *x*
    and *y*, the gate *Q*f transforms the quantum state |*x*⟩|*y*⟩ to the state |*x*⟩|**f**(*x*)
    ⊕ *y*⟩. That is, it computes the function **f**() on the quantum state reversibly
    because you can go from the new state to the old one by computing **f**(*x*) and
    XORing it to **f**(*x*) ⊕ *y*. (Explaining why this works is beyond this book’s
    scope.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决Simon问题的量子电路中，你初始化2*n*个量子比特为|0⟩，对前*n*个量子比特应用Hadamard门(*H*)，然后对两个*n*量子比特组应用门*Q***[f]**。给定两个*n*量子比特组*x*和*y*，门*Q*f将量子态|*x*⟩|*y*⟩转换为态|*x*⟩|**f**(*x*)
    ⊕ *y*⟩。也就是说，它可逆地计算函数**f**()，因为你可以通过计算**f**(*x*)并对**f**(*x*) ⊕ *y*进行异或操作，从新态恢复到旧态。（解释为什么这样有效超出了本书的范围。）
- en: You can use the exponential speedup for Simon’s problem against symmetric ciphers
    only in very specific cases, but the next section will discuss some real crypto-killer
    applications of quantum computing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能在非常特定的情况下利用对称加密算法的指数加速来解决Simon问题，但下一节将讨论量子计算在一些真实的加密杀手级应用中的作用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Threat of Shor’s
    Algorithm</samp>
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Shor算法的威胁</samp>
- en: In 1995, AT&T researcher Peter Shor published an eye-opening article titled
    “Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on
    a Quantum Computer.” *Shor’s algorithm* is a quantum algorithm that causes an
    exponential speedup when solving the factoring, discrete logarithm (DLP), and
    elliptic curve discrete logarithm (ECDLP) problems. You can’t efficiently solve
    these problems with a classical computer, but you could with a quantum computer.
    This means that a quantum computer could solve any cryptographic algorithm that
    relies on those problems, including RSA, Diffie–Hellman, elliptic curve cryptography,
    and most currently deployed public-key cryptography mechanisms (except for those
    that transitioned to post-quantum cryptography). In other words, you could reduce
    the security of RSA or elliptic curve cryptography to that of Caesar’s cipher.
    (Shor might as well have titled his article “Breaking All Public-Key Crypto on
    a Quantum Computer.”) Renowned complexity theorist Scott Aaronson called Shor’s
    algorithm “one of the major scientific achievements of the late 20th century.”
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 1995年，AT&T的研究员彼得·肖尔（Peter Shor）发表了一篇开创性的文章，标题为《量子计算机上的素因子分解和离散对数的多项式时间算法》。*肖尔算法*是一种量子算法，当解决因式分解、离散对数（DLP）和椭圆曲线离散对数（ECDLP）问题时，能带来指数级的加速。用经典计算机无法高效地解决这些问题，但使用量子计算机可以。这意味着量子计算机能够破解任何依赖这些问题的加密算法，包括RSA、Diffie–Hellman、椭圆曲线加密以及目前大多数已部署的公钥加密机制（除了那些已经转向后量子加密的算法）。换句话说，你可以将RSA或椭圆曲线加密的安全性降低到凯撒密码的级别。（肖尔本可以将他的文章命名为“在量子计算机上破解所有公钥加密”）著名的复杂性理论专家斯科特·阿伦森（Scott
    Aaronson）称肖尔算法为“20世纪末期的重大科学成就之一”。
- en: Shor’s algorithm actually solves a more general class of problems than factoring
    and discrete logarithms. Specifically, if a function **f**() is *periodic*—that
    is, if there’s an ω (the period) such that **f**(*x* + ω) = **f**(*x*) for any
    *x*—then Shor’s algorithm will efficiently find ω. (This looks very similar to
    Simon’s problem, as it was a major inspiration for Shor’s algorithm.)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，肖尔算法解决的比因式分解和离散对数问题更广泛的一个问题类别。具体来说，如果一个函数**f**()是*周期性的*——即，如果存在一个ω（周期），使得**f**(*x*
    + ω) = **f**(*x*) 对于任何 *x* 都成立——那么肖尔算法将高效地找到ω。（这看起来与西蒙问题非常相似，西蒙问题是肖尔算法的一个重要灵感来源。）
- en: Discussing the details of how Shor’s algorithm achieves its speedup is far too
    technical for this book, but the next section shows how to use Shor’s algorithm
    to solve the factoring and discrete logarithm problems (see [Chapter 9](chapter9.xhtml)),
    the hard problems behind RSA and Diffie–Hellman.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论肖尔算法如何实现加速的具体细节过于技术化，不适合本书讨论，但下一节将展示如何使用肖尔算法解决因式分解和离散对数问题（详见[第9章](chapter9.xhtml)），这正是RSA和Diffie–Hellman背后的难题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Factoring Problem</samp>
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">因式分解问题</samp>
- en: Say you want to factor a large number, *N* = *pq*. It’s easy to factor *N* if
    you can compute the period of *a**^x* mod *N*, for some constant *a*. This task
    is hard to do with a classical computer but easy with a quantum one. First pick
    a random number *a* less than *N*, and ask Shor’s algorithm to find the period
    ω of the function **f**(*x*) = *a**^x* mod *N*. Once you’ve found the period,
    you’ll have *a**^x* mod *N* = *a**^(x +)* ^ω mod *N* (that is, *a**^x* mod *N*
    = *a**^x**a*^ω mod *N*), which means that *a*^ω mod *N* = 1, or equivalently *a*^ω
    – 1 mod *N* = 0\. In other words, *a*^ω – 1 is a multiple of *N*, meaning that
    *a*^ω – 1 = *kN* for some unknown number *k*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你要因式分解一个大数*N* = *pq*。如果你能计算出*a**^x* mod *N*的周期ω，对于某个常数*a*，那么因式分解*N*就变得容易了。这个任务对于经典计算机来说非常困难，但对于量子计算机来说却很容易。首先选择一个小于*N*的随机数*a*，然后使用肖尔算法求解函数**f**(*x*)
    = *a**^x* mod *N*的周期ω。找到周期后，你会得到*a**^x* mod *N* = *a**^(x + ω)* mod *N*（也就是说，*a**^x*
    mod *N* = *a**^x**a*^ω mod *N*），这意味着*a*^ω mod *N* = 1，或等价地，*a*^ω – 1 mod *N* =
    0。换句话说，*a*^ω – 1是*N*的倍数，意味着*a*^ω – 1 = *kN*，其中*k*是一个未知数。
- en: When ω is even, it’s easy to factor *a*^ω – 1 as (*a*^ω*^/*² – 1)(*a*^ω*^/*²
    + 1), where the value *a*^ω*^/*² is a *root of unity*, as (*a*^ω*^/*²)² mod *N*
    = 1\. When the period ω is odd, rerun Shor with another value of *a* until you
    get an even number.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当ω是偶数时，因式分解*a*^ω – 1很容易，形式为(*a*^ω*^/*² – 1)(*a*^ω*^/*² + 1)，其中*a*^ω*^/*²是*单位根*，因为(*a*^ω*^/*²)²
    mod *N* = 1。若周期ω是奇数，则需要用另一个值的*a*重新运行肖尔算法，直到得到偶数。
- en: As the factors of *a*^ω – 1 contain the prime factors of *k* and *N*, you can
    find these factors distributed among those of *a*^ω*^/*² – 1 and *a*^ω*^/*² +
    1\. You can then calculate the greatest common divisor (GCD) between *a*^ω*^(/2)*
    – 1 and *N*, and between *a*^ω*^(/2)* + 1 and *N*, to obtain a nontrivial factor
    of *N*—that is, a value other than 1 or *N*. If this isn’t the case—for example,
    when *a*^ω*^/*² – 1 or *a*^ω*^/*² + 1 is a multiple of *N*—restart the attack
    with another *a*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*a*^ω – 1的因子包含*k*和*N*的素因子，你可以找到这些因子，并将它们分布在*a*^ω*^/*² – 1和*a*^ω*^/*² + 1的因子之间。然后，你可以计算*a*^ω*^(/2)*
    – 1和*N*之间的最大公约数（GCD），以及*a*^ω*^(/2)* + 1和*N*之间的最大公约数，从而得到*N*的一个非平凡因子——即一个不等于1或*N*的值。如果不是这种情况——例如，当*a*^ω*^/*²
    – 1或*a*^ω*^/*² + 1是*N*的倍数时——就重新开始攻击，选择另一个*a*。
- en: Having obtained the factors of *N*, you’ve now recovered the RSA private key
    from its public key, enabling you to decrypt encrypted messages or forge signatures.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 得到*N*的因子后，你现在可以从RSA公钥中恢复出私钥，从而解密加密信息或伪造签名。
- en: Note that the best classical algorithm to use to factor a number *N* runs in
    time exponential in *n*, the bit length of *N* (that is, *n* = log[2] *N*). However,
    Shor’s algorithm runs in time *polynomial* in *n*—namely, *O*(*n*²(log *n*)(log
    log *n*)). This means that if you had a quantum computer, you could run Shor’s
    algorithm and see the result within a more reasonable amount of time than thousands
    of years.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，用于因式分解一个数字*N*的最佳经典算法的运行时间是指数级的，取决于*N*的位长*n*（即*n* = log[2] *N*）。然而，Shor算法的运行时间是*n*的*多项式*级别——即*O*(*n*²(log
    *n*)(log log *n*)）。这意味着，如果你有一个量子计算机，你可以运行Shor算法，并在比数千年更合理的时间内看到结果。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Discrete Logarithm Problem</samp>
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">离散对数问题</samp>
- en: The challenge in the discrete logarithm problem is to find *x*, given *y* =
    *g**^x* mod *p*, for some known numbers *g* and *p*. Solving this problem takes
    a (sub)exponential amount of time on a classical computer, but you can find *x*
    easily with Shor’s algorithm thanks to its efficient period-finding technique.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 离散对数问题的挑战在于给定*y* = *g**^x* mod *p*，对于一些已知的数字*g*和*p*，求解*x*。在经典计算机上解决这个问题需要(sub)指数级的时间，但通过Shor算法，你可以轻松地找到*x*，因为它有一个高效的周期查找技术。
- en: For example, consider the function **f**(*a*, *b*) = *g**^a**y**^b*. Say you
    want to find the period of this function, the numbers ω and ω′*,* such that **f**(*a*
    + ω, *b* + ω′) = **f**(*a*, *b*) for any *a* and *b*. The solution you seek is
    then *x* = –ω/ω′ modulo *q*, the order of *g*, which is a known parameter. The
    equality **f**(*a* + ω, *b* + ω′) = **f**(*a*, *b*) implies *g*^ω*y*^ω ′ mod *p*
    = 1\. By substituting *y* with *g**^x*, you have *g*^ω *^(+ x)*^ω′ mod *p* = 1,
    which is equivalent to ω + *x*ω′ mod *q* = 0, from which you derive *x* = – ω/ω′.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑函数**f**(*a*, *b*) = *g**^a**y**^b*。假设你想找到该函数的周期，数字ω和ω′，使得**f**(*a* + ω,
    *b* + ω′) = **f**(*a*, *b*)对任意的*a*和*b*成立。那么你要找的解就是*x* = –ω/ω′模*q*，其中*q*是*g*的阶，是一个已知参数。等式**f**(*a*
    + ω, *b* + ω′) = **f**(*a*, *b*)意味着*g*^ω*y*^ω′ mod *p* = 1。通过将*y*替换为*g**^x*，你得到*g*^ω
    *^(+ x)*^ω′ mod *p* = 1，这相当于ω + *x*ω′ mod *q* = 0，从而推导出*x* = –ω/ω′。
- en: Again, the overall complexity is *O*(*n*²(log *n*)(log log *n*)), with *n* the
    bit length of *p*. This algorithm generalizes to find discrete logarithms in any
    finite commutative group, not just the group of numbers modulo a prime number.
    You can thus apply it to solve ECDLP as well, the elliptic curve version of the
    discrete logarithm problem.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，整体复杂度是*O*(*n*²(log *n*)(log log *n*))，其中*n*是*p*的位长。该算法可以推广，用于在任何有限的交换群中找到离散对数，而不仅仅是模素数的数字群。因此，你也可以将其应用于解决ECDLP问题，这是离散对数问题在椭圆曲线上的版本。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Grover’s Algorithm</samp>
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Grover算法</samp>
- en: Another important form of quantum speedup is the ability to search among *n*
    items in time proportional to the square root of *n*, whereas any classical algorithm
    would take time proportional to *n*. This quadratic speedup is possible thanks
    to *Grover’s algorithm*, a quantum algorithm discovered in 1996\. I won’t cover
    the internals of Grover’s algorithm because they’re essentially a bunch of Hadamard
    gates, but I’ll explain what kind of problem Grover solves and its potential impact
    on cryptographic security. I’ll also show why you can salvage a symmetric crypto
    algorithm from quantum computers by doubling the key or hash value size, whereas
    asymmetric algorithms are destroyed for good.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 量子加速的另一个重要形式是能够在*n*个项中进行搜索，时间复杂度为*n*的平方根，而任何经典算法的时间复杂度都是*n*。这种二次加速得益于*Grover算法*，这是一种1996年发现的量子算法。我不会详细介绍Grover算法的内部原理，因为它们本质上是一些Hadamard门，但我会解释Grover解决了什么样的问题及其对加密安全的潜在影响。我还将解释为什么通过加倍密钥或哈希值大小，可以让对称加密算法免受量子计算机的破坏，而非对称算法则彻底被破坏。
- en: Think of Grover’s algorithm as a way to find the value *x* among *n* possible
    values, such that **f**(*x*) = 1, and where **f**(*x*) = 0 for most other values.
    If *m* values of *x* satisfy **f**(*x*) = 1, Grover will find a solution in time
    *O*(√(*n*/*m*)); that is, in time proportional to the square root of *n* divided
    by *m*. In comparison, a classical algorithm can’t do better than *O*(*n*/*m*).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将Grover算法视为一种在*n*个可能的值中找到值*x*的方法，使得**f**(*x*) = 1，而对于其他大多数值，**f**(*x*) = 0。如果*m*个值的*x*满足**f**(*x*)
    = 1，Grover将在时间*O*(√(*n*/*m*))内找到解决方案；也就是说，所需时间与*n*除以*m*的平方根成正比。相比之下，经典算法的最优复杂度是*O*(*n*/*m*)。
- en: 'Now consider the fact that **f**() can be any function. It could be, for example,
    “**f**(*x*) = 1 if and only if *x* is equal to the unknown secret key *K* such
    that **E**(*K*, *P*) = *C*” for some known plaintext *P* and ciphertext *C*, and
    where **E**() is some encryption function. In practice, this means that if you’re
    looking for a 128-bit AES key with a quantum computer, you’ll find the key in
    time proportional to 2^(64), rather than 2^(128) if you had only classical computers.
    You’d need a large enough plaintext to ensure the uniqueness of the key. (If the
    plaintext and ciphertext are, say, 32 bits, many candidate keys would map that
    plaintext to that ciphertext.) The complexity 2^(64) is much smaller than 2^(128),
    meaning that a secret key would be much easier to recover. But there’s an easy
    solution: to restore 128-bit security, just use 256-bit keys! Grover’s algorithm
    will then reduce the complexity of searching a key to 2^(256 / 2) = 2^(128) operations.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑**f**()可以是任何函数。举个例子，它可以是“**f**(*x*) = 1，当且仅当 *x* 等于未知的密钥 *K*，使得 **E**(*K*,
    *P*) = *C*”对于某个已知的明文 *P* 和密文 *C*，其中 **E**() 是某个加密函数。实际上，这意味着如果你使用量子计算机寻找一个128位的AES密钥，你将在时间复杂度为2^(64)的情况下找到密钥，而如果只使用经典计算机，则需要2^(128)的时间。你需要一个足够大的明文以确保密钥的唯一性。（如果明文和密文是32位，比如会有很多候选密钥将该明文映射为该密文。）复杂度2^(64)比2^(128)小得多，这意味着恢复一个秘密密钥会更容易。但有一个简单的解决方案：为了恢复128位的安全性，只需使用256位密钥！Grover算法将把搜索密钥的复杂度降到2^(256
    / 2) = 2^(128)次操作。
- en: Grover’s algorithm can also find preimages of hash functions (see [Chapter 6](chapter6.xhtml)).
    To find a preimage of some value *h*, we define the **f**() function as “**f**(*x*)
    = 1 if and only if **Hash**(*x*) = *h*, otherwise **f**(*x*) = 0.” Grover thus
    gets you preimages of *n*-bit hashes at the cost of the order of 2*^n*^(/2) operations.
    As with encryption, to ensure 2*^n* post-quantum security, use hash values twice
    as large, since Grover’s algorithm finds a preimage of a 2*n*-bit value in at
    least 2*^n* operations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Grover算法也可以找到哈希函数的原像（参见[第6章](chapter6.xhtml)）。为了找到某个值*h*的原像，我们将**f**()函数定义为“**f**(*x*)
    = 1，当且仅当 **Hash**(*x*) = *h*，否则 **f**(*x*) = 0。”因此，Grover可以让你以2*^n*^(/2)次操作的代价找到*n*位哈希的原像。与加密一样，为了确保2*^n*后量子安全性，使用比原来大两倍的哈希值，因为Grover算法至少需要2*^n*次操作才能找到一个2*n*位值的原像。
- en: The bottom line is that you can salvage symmetric crypto algorithms from quantum
    computers by doubling the key or hash value size.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，你可以通过加倍密钥或哈希值的大小来拯救对称加密算法，使其免受量子计算机的破坏。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*There’s a famous quantum algorithm that finds hash function collisions in
    time* O*(2*^n*^(/3)**), instead of* O*(2*^n*^(/2)**), as with the classic birthday
    attack. This suggests that quantum computers can outperform classical computers
    for finding hash function collisions, except that the* O*(2*^n*^(/3)**)-time quantum
    algorithm also requires* O*(2*^n*^(/3)**) space, or memory, to run. Give* O*(2*^n*^(/3)**)’s
    worth of computer space to a classic algorithm, and it can run a parallel collision
    search algorithm with a collision time of only* O*(2*^n*^(/6)**), which is much
    faster than the* O*(2*^n*^(/3)**) quantum algorithm. (For details of this attack,
    see “Cost Analysis of Hash Collisions” by Daniel J. Bernstein at* [https://<wbr>cr<wbr>.yp<wbr>.to<wbr>/papers<wbr>.html#collisioncost](https://cr.yp.to/papers.html#collisioncost)*.)
    In 2017, however, cryptographers proposed a quantum algorithm finding collisions
    in time* O*(2**²*^n*^(/5)**), requiring* O*(*n*) quantum memory and* O*(2*^n*^(/5)**)
    classical memory. This may outperform classical search (see* [https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2017<wbr>/847](https://eprint.iacr.org/2017/847)*).*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*有一个著名的量子算法，能在时间* O*(2*^n*^(/3)**)*内找到哈希函数碰撞，而不是经典生日攻击中的* O*(2*^n*^(/2)**)*。这表明量子计算机在寻找哈希函数碰撞方面可以超越经典计算机，尽管*
    O*(2*^n*^(/3)**)-时间的量子算法也需要* O*(2*^n*^(/3)**)的空间或内存来运行。将* O*(2*^n*^(/3)**)的计算机空间给经典算法，它可以运行一个并行碰撞搜索算法，碰撞时间只有*
    O*(2*^n*^(/6)**)*，比* O*(2*^n*^(/3)**)量子算法要快得多。（有关此攻击的详细信息，请参见Daniel J. Bernstein的《哈希碰撞成本分析》，链接为*[https://<wbr>cr<wbr>.yp<wbr>.to<wbr>/papers<wbr>.html#collisioncost](https://cr.yp.to/papers.html#collisioncost)*。）然而，2017年，密码学家提出了一个量子算法，可以在时间*
    O*(2**²*^n*^(/5)**)*内找到碰撞，要求* O*(*n*)的量子内存和* O*(2*^n*^(/5)**)的经典内存。这可能超越经典搜索（见*
    [https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2017<wbr>/847](https://eprint.iacr.org/2017/847)*）。*'
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Why Is It So Hard to Build a Quantum
    Computer?</samp>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">为什么构建量子计算机如此困难？</samp>'
- en: Although quantum computers can in principle be built, we don’t know how hard
    it will be or when that might happen, if at all. As of mid-2024, the record holder
    is a machine with 1,121 qubits (IBM’s “Condor”), whereas we’d need to keep millions
    of qubits stable for weeks to break any crypto. The point is, we’re not there
    yet.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从理论上讲可以构建量子计算机，但我们并不知道这有多难，或者什么时候能够实现，甚至是否能够实现。截至2024年中，纪录保持者是一台拥有1,121个量子比特的机器（IBM的“Condor”），而要破解任何加密，我们需要保持数百万个量子比特稳定运行数周。关键是，我们还没有达到这个阶段。
- en: The difficulty of building a quantum computer stems from needing extremely small
    things to play the role of qubits—smaller than atoms, such as photons. Because
    qubits must be so small, they’re also extremely fragile.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 构建量子计算机的难点在于需要非常微小的物体来充当量子比特——比原子还要小，比如光子。由于量子比特必须非常小，它们也非常脆弱。
- en: Also, qubits must be kept at extremely low temperatures (close to absolute zero)
    to remain stable. Even at freezing temperatures, the state of qubits decays, and
    they eventually become useless. As of this writing, we don’t yet know how to make
    qubits that last for more than a couple of seconds (their coherence time).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，量子比特必须保持在极低的温度下（接近绝对零度）才能保持稳定。即使在冰点温度下，量子比特的状态也会衰减，最终变得无用。到目前为止，我们尚未找到制造能够持续几秒钟以上（其相干时间）的量子比特的方法。
- en: Another challenge is that the environment, such as heat and magnetic fields,
    can affect the qubits’ states and lead to computation errors. In theory, it’s
    possible to correct these errors, but it’s difficult to do so. Correcting qubits’
    errors requires quantum error-correcting codes, which in turn require many additional
    qubits and a low enough rate of error.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个挑战是环境因素，比如热量和磁场，可能会影响量子比特的状态并导致计算错误。从理论上讲，纠正这些错误是可能的，但实际上非常困难。纠正量子比特的错误需要量子纠错码，而这又需要额外的量子比特和足够低的错误率。
- en: 'At the moment, there are two main approaches to forming qubits: superconducting
    circuits and ion traps. Labs at Google and IBM champion using *superconducting
    circuits*, which is based on forming qubits as tiny electrical circuits that rely
    on quantum phenomena from superconductor materials, where charge carriers are
    pairs of electrons. Qubits made of superconducting circuits have a very short
    lifetime.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，形成量子比特的主要方法有两种：超导电路和离子阱。谷歌和IBM的实验室支持使用*超导电路*，这是基于将量子比特形成为微小的电路，这些电路依赖于超导材料中的量子现象，在这些材料中，电荷载体是电子对。由超导电路构成的量子比特有非常短的寿命。
- en: '*Ion traps*, or trapped ions, consist of ions (charged atoms) and are manipulated
    using lasers to prepare the qubits in specific initial states. Ion traps tend
    to be more stable than superconducting circuits, but they’re slower to operate
    and seem harder to scale.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*离子阱*，或称捕获离子，包含离子（带电原子），通过激光操控将量子比特准备在特定的初始状态。离子阱比超导电路通常更稳定，但其操作较慢，并且似乎更难扩展。'
- en: Building a quantum computer is really a moon shot effort. The challenge comes
    down to 1) building a system with a handful of qubits that’s stable, fault tolerant,
    and capable of applying basic quantum gates, and 2) scaling such a system to thousands
    or millions of qubits to make it useful. From a purely physical standpoint and
    to the best of our knowledge, there’s nothing to prevent the creation of large
    fault-tolerant quantum computers. But many things are possible in theory and prove
    hard or too costly to realize in practice (like secure computers). The future
    will tell who is right—the quantum optimists (who predict a large quantum computer
    within the decade) or the quantum skeptics (who argue that the human race will
    never see a quantum computer).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 构建量子计算机实际上是一项登月计划般的努力。挑战在于：1）建立一个具有少量量子比特的系统，该系统稳定、容错，并能够应用基本的量子门操作；2）将这样一个系统扩展到数千或数百万个量子比特，从而使其具有实用价值。从纯物理的角度来看，据我们所知，没有什么能阻止大规模容错量子计算机的创造。但理论上许多事情是可能的，而实践中却很难实现或成本过高（比如安全计算机）。未来将证明谁是对的——量子乐观主义者（预测十年内会有大型量子计算机）还是量子怀疑论者（认为人类永远不会见到量子计算机）。
- en: 'As mentioned earlier, as of January 2024, one of the most advanced achievements
    is IBM’s quantum computing chip Condor that includes 1,121 qubits, a technology
    based on superconducting circuits. But the number of qubits shouldn’t be the only
    metric when comparing quantum computing systems. Other important factors include
    the stability time, the number of qubits entangled together, and the ability to
    reliably correct errors.  ### <samp class="SANS_Futura_Std_Bold_B_11">Post-Quantum
    Cryptographic Algorithms</samp>'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，截至2024年1月，最先进的成就之一是IBM的量子计算芯片Condor，该芯片包含1,121个量子比特，采用基于超导电路的技术。但在比较量子计算系统时，量子比特的数量不应是唯一的衡量标准。其他重要因素包括稳定时间、纠缠在一起的量子比特数目，以及可靠地纠正错误的能力。###
    <samp class="SANS_Futura_Std_Bold_B_11">后量子密码算法</samp>
- en: The field of *post-quantum cryptography* focuses on designing public-key algorithms
    that a quantum computer can’t break; that is, they’re quantum safe and can replace
    RSA and elliptic curve–based algorithms in a future where off-the-shelf quantum
    computers could break 4,096-bit RSA moduli in a snap.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*后量子密码学*领域致力于设计量子计算机无法破解的公钥算法；也就是说，它们是量子安全的，并且可以替代RSA和基于椭圆曲线的算法，尤其是在未来，当现成的量子计算机能够轻松破解4,096位的RSA模数时。'
- en: Such algorithms shouldn’t rely on a hard problem known to be efficiently solvable
    by Shor’s algorithm, which kills the hardness in factoring and discrete logarithm
    problems. Symmetric algorithms such as block ciphers and hash functions would
    lose only half their theoretical security in the face of a quantum computer but
    wouldn’t be as badly broken as RSA. They might constitute the basis for a post-quantum
    scheme.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的算法不应依赖于Shor算法已知能高效求解的难题，因为Shor算法消除了因数分解和离散对数问题的计算难度。对称算法，如分组密码和哈希函数，在面对量子计算机时理论安全性只会丧失一半，但不会像RSA那样被完全破解。它们可能构成后量子方案的基础。
- en: 'In the following sections, we’ll review the four main types of post-quantum
    algorithms: code based, lattice based, multivariate, and hash based.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将回顾四种主要的后量子算法类型：基于编码的、基于格的、多变量的和基于哈希的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Code-Based Cryptography</samp>
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">基于编码的密码学</samp>
- en: Code-based post-quantum cryptographic algorithms are based on *error-correcting
    codes*, which are techniques designed to transmit bits over a noisy channel. The
    basic theory of error-correcting codes dates back to the 1950s. The first code-based
    encryption scheme (the *McEliece* cryptosystem) was developed in 1978 and is still
    unbroken. You can use code-based crypto schemes for both encryption and signatures.
    Their main limitation is the size of their public key, which is typically on the
    order of a hundred kilobytes. But is that really a problem when the average size
    of a web page is around 2MB?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 基于码的后量子密码算法基于*纠错码*，这些技术旨在通过噪声信道传输位。纠错码的基本理论可以追溯到1950年代。第一个基于码的加密方案（*McEliece*密码系统）于1978年开发，至今尚未被破解。你可以使用基于码的加密方案进行加密和签名。它们的主要限制是公钥的大小，通常在几十兆字节左右。但当网页的平均大小大约是2MB时，这真的是个问题吗？
- en: 'Let me first explain what error-correcting codes are. Say you want to transmit
    a sequence of bits as a sequence of 3-bit words, but the transmission’s unreliable
    and you’re concerned about incorrectly transmitting one or more bits: you send
    010, but the receiver gets 011\. One might address this by using a basic error-correction
    *repetition code*: instead of transmitting 010, you transmit 000111000 (repeating
    each bit three times), and the receiver decodes the received word by taking the
    majority value for each of the 3 bits.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我首先解释一下什么是纠错码。假设你想将一串比特传输为一串3位的单词，但传输不可靠，你担心其中一个或多个比特可能会被错误地传输：你发送的是010，但接收器接收到的是011。你可以通过使用一个基本的纠错*重复码*来解决这个问题：不是传输010，而是传输000111000（每个比特重复三次），接收器通过对每三位比特取多数值来解码接收到的字。
- en: For example, a receiver would decode the repetition codeword 100110111 to 011
    because 100 contains two 0s, then 110 contains two 1s, and 111 contains three
    1s. This particular error-correcting code allows a receiver to correct only up
    to one error per 3-bit chunk, because if two errors occur in the same 3-bit chunk,
    the majority value would be the wrong one.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个接收器将解码重复码字100110111为011，因为100包含两个0，接着110包含两个1，111包含三个1。这个特定的纠错码允许接收器每3位块最多纠正一个错误，因为如果在同一个3位块中发生两个错误，多数值将是错误的。
- en: '*Linear codes* are a less trivial example of error-correcting codes. In the
    case of linear codes, a word to encode is seen as an *n*-bit vector *v*, and encoding
    consists of multiplying *v* with an *m*×*n* matrix *G* to compute the code word
    *w* = *vG*. (In this example, *m* is greater than *n*, meaning the code word is
    longer than the original word.) One can structure the matrix *G* such that for
    a given number *t*, any *t*-bit error in *w* allows the recipient to recover the
    correct *v*. In other words, *t* is the maximum number of errors that one can
    correct.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*线性码*是纠错码的一个不太简单的例子。在线性码的情况下，编码的单词被视为一个*n*位的向量*v*，编码过程是将*v*与一个*m*×*n*矩阵*G*相乘，计算得到码字*w*
    = *vG*。（在这个例子中，*m*大于*n*，意味着码字比原始单词长。）可以构造矩阵*G*，使得对于给定的数字*t*，*w*中的任何*t*位错误都能让接收方恢复正确的*v*。换句话说，*t*是可以纠正的最大错误数量。'
- en: To encrypt data using linear codes, the McEliece cryptosystem constructs *G*
    as a secret combination of three matrices and encrypts by computing *w* = *vG*
    added with some random value, *e*, which has a fixed number of bits set to 1\.
    Here, *G* is the public key, and the private key is composed of the matrices *A*,
    *B*, and *C* such that *G* = *ABC.* Knowing *A*, *B*, and *C* allows one to decode
    a message reliably and retrieve *w*. But without these matrices, it should be
    impossible to decode the word and thus to decrypt.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用线性码加密数据，McEliece密码系统构造了*G*，作为三个矩阵的秘密组合，并通过计算*w* = *vG*加上一些随机值*e*（其中有固定数量的位设置为1）来进行加密。在这里，*G*是公钥，私钥由矩阵*A*、*B*和*C*组成，使得*G*
    = *ABC*。知道*A*、*B*和*C*的人可以可靠地解码消息并恢复*w*。但是，如果没有这些矩阵，应该不可能解码该字，并因此解密。
- en: The security of the McEliece encryption scheme relies on the hardness of decoding
    a linear code with insufficient information, a problem we know to be **NP**-hard
    and therefore out of reach of quantum computers. Bear in mind, however, that just
    because a problem is **NP**-hard doesn’t mean that all its instances will be impossible
    to solve in practice. It’s therefore necessary to evaluate which instances of
    the difficult problem are presented by a cryptosystem and whether these instances
    will always be difficult. McEliece’s cipher satisfies this criterion after years
    of analysis by cryptographers and coding theory experts.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: McEliece 加密方案的安全性依赖于解码线性码时信息不足的难度，这是一个我们知道是**NP**-难的问题，因此超出了量子计算机的能力范围。然而，请记住，**NP**-难的问题并不意味着所有实例在实际中都无法解决。因此，有必要评估加密系统所呈现的困难问题的实例，以及这些实例是否总是很难解决。经过密码学家和编码理论专家多年的分析，McEliece
    加密方案满足这一标准。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Lattice-Based Cryptography</samp>
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">基于格的密码学</samp>
- en: '*Lattices* are mathematical structures that essentially consist of a set of
    points in an *n*-dimensional space, with some periodic structure. For example,
    [Figure 14-5](chapter14.xhtml#fig14-5) shows how you can view a lattice in dimension
    two (*n* = 2) as the set of points.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*格*是数学结构，本质上由一个在*n*维空间中的点集组成，并具有某种周期性结构。例如，[图 14-5](chapter14.xhtml#fig14-5)展示了如何将二维格（*n*
    = 2）视为点集。'
- en: '![](../images/fig14-5.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig14-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: Points of a two-dimensional
    lattice, where</samp> <samp class="SANS_Futura_Std_Book_11">v</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp>
    <samp class="SANS_Futura_Std_Book_11">w</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">are
    basis vectors of the lattice and</samp> <samp class="SANS_Futura_Std_Book_11">s</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">is the closest vector to the star-shaped
    point</samp>'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-5：二维格点上的点，其中</samp> <samp
    class="SANS_Futura_Std_Book_11">v</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp>
    <samp class="SANS_Futura_Std_Book_11">w</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">是格的基向量，</samp>
    <samp class="SANS_Futura_Std_Book_11">s</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">是距离星形点最近的向量</samp>
- en: Lattice theory has led to deceptively simple cryptography schemes. I’ll give
    you the gist of it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 格理论催生了看似简单的加密方案。我将简要介绍一下它的要点。
- en: '*Short integer solution (SIS)* is a hard problem in lattice-based crypto that
    consists of finding the secret vector *s* of *n* numbers given (*A*, *b*) such
    that *b* = *As* mod *q*, where *A* is a random *m*×*n* matrix and *q* is a prime
    number.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*短整型解（SIS）* 是基于格的加密中的一个难题，要求给定（*A*，*b*）来找到秘密向量*s*，使得*b* = *As* mod *q*，其中 *A*
    是一个随机的 *m*×*n* 矩阵，*q* 是一个素数。'
- en: Another hard problem in lattice-based cryptography, *learning with errors (LWE)*,
    consists of finding the secret vector *s* of *n* numbers given (*A*, *b*), where
    *b* = *As* + *e* mod *q*, with *A* being a random *m*×*n* matrix, *e* a random
    vector of noise, and *q* a prime number. This problem looks a lot like noisy decoding
    in code-based cryptography.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个基于格的加密难题，*带错误学习（LWE）*，包括给定（*A*，*b*）来寻找秘密向量*s*，其中*b* = *As* + *e* mod *q*，*A*
    是一个随机的 *m*×*n* 矩阵，*e* 是一个随机噪声向量，*q* 是一个素数。这个问题看起来很像基于码的密码学中的有噪解码。
- en: SIS and LWE are somewhat equivalent, and we can restate them as instances of
    the *closest vector problem (CVP)* on a lattice, or the problem of finding the
    vector in a lattice closest to a given point, by combining a set of basis vectors.
    The dotted vector *s* in [Figure 14-5](chapter14.xhtml#fig14-5) shows how to find
    the closest vector to the star-shaped point by combining the basis vectors *v*
    and *w*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: SIS 和 LWE 在某种程度上是等价的，我们可以将它们重新表述为*最近向量问题（CVP）*，即通过组合一组基向量来找到与给定点最近的格向量。虚线向量*s*在[图
    14-5](chapter14.xhtml#fig14-5)中显示了如何通过组合基向量*v*和*w*来找到距离星形点最近的向量。
- en: CVP and other lattice problems are believed to be hard both for classical and
    quantum computers. But this doesn’t directly transfer to secure cryptosystems,
    because some problems are hard only in the worst case (that is, for their hardest
    instance) rather than the average case (which is what we need for crypto). Furthermore,
    while finding the exact solution to CVP is hard, finding an approximation of the
    solution can be considerably easier.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: CVP 和其他格问题被认为对于经典计算机和量子计算机都很难解决。但这并不直接转化为安全的密码系统，因为一些问题只有在最坏情况下（即对于它们的最难实例）才是困难的，而不是在平均情况下（我们需要的是加密所需的）。此外，虽然找到
    CVP 的精确解是困难的，但找到其近似解则可能容易得多。
- en: That said, post-quantum cryptosystems based on lattices have proven to offer
    the best combination of security and performance. The standards chosen by NIST
    in 2022 are mainly from this family, as you’ll see later.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，基于格的后量子密码系统已经证明提供了最佳的安全性和性能组合。NIST 在2022年选择的标准主要来自这个家族，稍后你会看到。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multivariate Cryptography</samp>
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">多变量密码学</samp>
- en: '*Multivariate cryptography* focuses on building cryptographic schemes that
    are as hard to break as it is to solve systems of multivariate equations, or equations
    involving multiple unknowns that are multiplied together in the equations. Consider,
    for example, the following system of equations involving four unknowns *x*[1],
    *x*[2], *x*[3], *x*[4]:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*多变量密码学* 专注于构建密码方案，这些方案的破解难度与解多变量方程组的难度相当，方程组中涉及多个未知数，并且这些未知数在方程中被相乘。例如，考虑以下包含四个未知数
    *x*[1]、*x*[2]、*x*[3]、*x*[4] 的方程组：'
- en: '![](../images/pg287-1.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg287-1.jpg)'
- en: These equations consist of the sum of terms that are either a single unknown,
    such as *x*[4] (or terms of degree one), or the product of two unknown values,
    such as *x*[2]*x*[3] (terms of degree two or *quadratic* terms). To solve this
    system, you need to find the values of *x*[1], *x*[2], *x*[3], *x*[4] that satisfy
    all four equations. Equations may be over all real numbers, integers only, or
    over finite sets of numbers. In cryptography, however, equations are typically
    over numbers modulo some prime numbers or over binary values (0 and 1).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程由一些项的和组成，这些项要么是单一未知数，例如 *x*[4]（或一次项），要么是两个未知数的乘积，例如 *x*[2]*x*[3]（二次项或 *二次*
    项）。要解这个系统，你需要找到满足所有四个方程的 *x*[1]、*x*[2]、*x*[3]、*x*[4] 的值。方程的定义可以是实数范围内的，整数范围内的，或者是有限数集的。然而，在密码学中，方程通常是基于某些素数模数的，或者是基于二进制值（0和1）的。
- en: The hard problem here is finding a solution to a random quadratic system, which
    is known as *multivariate quadratics (MQ)*. This problem is **NP**-hard and is
    therefore a potential basis for post-quantum systems because quantum computers
    won’t solve **NP**-hard problems efficiently.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的难题是解决一个随机的二次方程组，这被称为 *多变量二次方程 (MQ)*。这个问题是 **NP**-困难的，因此它是后量子系统的潜在基础，因为量子计算机无法高效地解决
    **NP**-困难问题。
- en: 'Unfortunately, building a cryptosystem on top of MQ isn’t so straightforward.
    For example, if you were to use MQ for signatures, the private key might consist
    of three systems of equations: *L*[1], *N*, and *L*[2]. Combining them in this
    order results in another system of equations called *P*, the public key. Applying
    the transformations *L*[1], *N*, and *L*[2] consecutively (that is, transforming
    a group of values as per the system of equations) is then equivalent to applying
    *P* by transforming *x*[1], *x*[2], *x*[3], *x*[4] to *y*[1], *y*[2], *y*[3],
    *y*[4], for example, defined as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在 MQ 上构建加密系统并不那么简单。例如，如果你使用 MQ 来进行签名，私钥可能由三组方程组成：*L*[1]、*N* 和 *L*[2]。按照这个顺序将它们结合起来，会得到一个叫做
    *P* 的方程组，即公钥。依次应用 *L*[1]、*N* 和 *L*[2]（即按方程组的方式变换一组值）等价于应用 *P*，通过将 *x*[1]、*x*[2]、*x*[3]、*x*[4]
    转换为 *y*[1]、*y*[2]、*y*[3]、*y*[4]，例如，按以下方式定义：
- en: '![](../images/pg288-1.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg288-1.jpg)'
- en: In such a cryptosystem, *L*[1], *N*, and *L*[2] are chosen such that *L*[1]
    and *L*[2] are linear transformations (that is, having equations where terms are
    only added, not multiplied) that are invertible, and where *N* is a quadratic
    system of equations that is also invertible. This makes the combination of the
    three an invertible quadratic system, but its inverse is hard to determine without
    knowing the inverses of *L*[1], *N*, and *L*[2].
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的加密系统中，*L*[1]、*N* 和 *L*[2] 的选择方式是，*L*[1] 和 *L*[2] 是线性变换（即只有加法项，没有乘法项），并且是可逆的，而
    *N* 是一个二次方程组，也是可逆的。这使得三者的组合成为一个可逆的二次方程组，但在不知道 *L*[1]、*N* 和 *L*[2] 的逆运算的情况下，逆运算很难确定。
- en: 'Computing a signature then consists of computing the inverses of *L*[1], *N*,
    and *L*[2] applied to some message, *M*, which we see as a sequence of variables,
    *x*[1], *x*[2], . . .:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 计算签名的过程是计算 *L*[1]、*N* 和 *L*[2] 的逆运算，这些运算应用于某个消息 *M*，我们将其视为一系列变量，*x*[1]、*x*[2]、...：
- en: '![](../images/pg288-2.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg288-2.jpg)'
- en: Verifying a signature then consists of verifying that *P*(*S*) = *M*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，验证签名的过程就是验证 *P*(*S*) = *M*。
- en: Attackers could break such a cryptosystem if they manage to compute the inverse
    of *P* or to determine *L*[1], *N*, and *L*[2] from *P*. The actual hardness of
    solving such problems depends on the parameters of the scheme, such as the number
    of equations used and the size and type of the numbers. But choosing secure parameters
    is hard, and more than one “safe” multivariate scheme has been broken.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者如果能够计算出 *P* 的逆运算或从 *P* 中确定 *L*[1]、*N* 和 *L*[2]，就能够破解这样的加密系统。解决这些问题的实际难度取决于方案的参数，如使用的方程数量和数字的大小与类型。但是，选择安全的参数非常困难，而且不止一个“安全”的多变量方案已经被破解。
- en: Multivariate cryptography isn’t used in major applications due to the challenge
    of achieving a reliable trade-off between security and performance. A practical
    benefit of multivariate signature schemes, however, is that they produce short
    signatures.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 多变量密码学由于难以在安全性和性能之间取得可靠的平衡，因此在主要应用中尚未普及。然而，多变量签名方案的一个实际好处是它们产生的签名较短。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hash-Based Cryptography</samp>
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">基于哈希的密码学</samp>
- en: Unlike the previous schemes, hash-based cryptography is based on the well-established
    security of cryptographic hash functions rather than on the hardness of mathematical
    problems. Because quantum computers can’t break hash functions, they can’t break
    anything that relies on the difficulty of finding collisions or preimages, which
    is the key idea of hash function–based signature schemes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的方案不同，基于哈希的密码学依赖于加密哈希函数的安全性，而不是数学问题的难度。因为量子计算机无法破解哈希函数，所以它们无法破解任何依赖于查找碰撞或预像难度的内容，而这正是基于哈希函数的签名方案的关键思想。
- en: 'Hash-based cryptographic schemes are pretty complex, so we’ll take a look at
    their simplest building block: the *Winternitz one-time signature (WOTS)*, a trick
    discovered around 1979\. Here *one-time* means that you can use a private key
    to sign only one message; otherwise, the signature scheme becomes insecure. (You
    can combine WOTS with other methods to sign multiple messages, as you’ll see shortly.)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 基于哈希的密码学方案相当复杂，因此我们将看看它们最简单的构建模块：*Winternitz 单次签名（WOTS）*，这是大约 1979 年发现的一个技巧。这里的
    *单次* 意味着你只能用私钥签署一条消息；否则，签名方案会变得不安全。（你可以将 WOTS 与其他方法结合，签署多条消息，正如你很快会看到的那样。）
- en: Say you want to sign a message viewed as a number between 0 and *w* – 1, where
    *w* is some parameter of the scheme. The private key is a random string, *K*.
    To sign a message, *M*, with 0 ≤ *M* < *w*, compute **Hash**(**Hash**(. . .(**Hash**(*K*))),
    where the hash function **Hash** repeats *M* times. You denote this value as **Hash***^M*(*K*).
    The public key is **Hash***^w*(*K*), or the result of *w* nested iterations of
    **Hash**, starting from *K*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想签署一条消息，该消息被视为一个介于 0 和 *w* – 1 之间的数字，其中 *w* 是该方案的某个参数。私钥是一个随机字符串，*K*。要签署消息
    *M*，其中 0 ≤ *M* < *w*，计算 **Hash**(**Hash**(...(**Hash**(*K*)))，其中哈希函数 **Hash**
    重复 *M* 次。你将此值表示为 **Hash***^M*(*K*)。公钥是 **Hash***^w*(*K*)，或者是 *w* 次嵌套 **Hash**
    运算的结果，从 *K* 开始。
- en: A WOTS signature is verified, *S*, by checking that **Hash***^(w – M)*(*S*)
    is equal to the public key **Hash***^w*(*K*). Note that *S* is *K* after *M* applications
    of **Hash**, so if you do another *w* – *M* applications of **Hash**, you’ll get
    a value equal to *K* hashed *M* + (*w* – *M*) = *w* times, which is the public
    key.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: WOTS签名通过检查**Hash***^(w – M)*(*S*)是否等于公钥**Hash***^w*(*K*)来验证*S*。注意，*S*是在对**Hash**应用了*M*次后得到的*K*，因此，如果你再进行*w*
    – *M*次**Hash**运算，你将得到一个等于*K*经过*M* + (*w* – *M*) = *w*次哈希运算后的值，这就是公钥。
- en: 'This scheme has significant limitations:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该方案有显著的局限性：
- en: '**Attackers can forge signatures **From **Hash***^M*(*K*), the signature of
    *M*, you can compute **Hash**(**Hash***^M*(*K*)) = **Hash***^M* ^(+ 1)(*K*), which
    is a valid signature of the message *M* + 1\. You can fix this problem by signing
    not only *M* but also *w* – *M*, using a second key.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**攻击者可以伪造签名**从**Hash***^M*(*K*)，即*M*的签名，你可以计算出**Hash**(**Hash***^M*(*K*)) =
    **Hash***^M* ^(+ 1)(*K*)，这就是消息*M* + 1的有效签名。你可以通过不仅对*M*进行签名，还对*w* – *M*进行签名，并使用第二个密钥来修复这个问题。'
- en: '**It works for only short messages **If messages are 8 bits long, there are
    up to 2⁸ – 1 = 255 possible messages, so you have to compute **Hash** up to 255
    times to create a signature. That might work for short messages, but not for longer
    ones—for example, with 128-bit messages, signing the message 2^(128) – 1 takes
    forever. A workaround is to split longer messages into shorter ones and sign each
    chunk independently.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅适用于短消息**如果消息长度为8位，则最多有2⁸ – 1 = 255种可能的消息，因此你需要计算**Hash**最多255次才能创建签名。这对于短消息有效，但对于较长的消息则无效——例如，对于128位的消息，签名消息2^(128)
    – 1将需要无限长的时间。一个解决方法是将较长的消息拆分为较短的消息，并分别对每个部分进行签名。'
- en: '**It works only once **If you use a private key to sign more than one message,
    an attacker can recover enough information to forge a signature. For example,
    if *w* = 8 and you sign the numbers 1 and 7 using the preceding trick to avoid
    trivial forgeries, the attacker gets **Hash**¹(*K*) and **Hash**⁷(*K* ′) as a
    signature of 1, and **Hash**⁷(*K*) and **Hash**¹(*K* ′) as a signature of 7\.
    From these values, the attacker can compute **Hash***^x*(*K*) and **Hash***^x*(*K*
    ′) for any *x* in [1;7] and thus forge a signature on behalf of the owner of *K*
    and *K* ′. There’s no simple way to fix this.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅适用于一次**如果你使用私钥签署多个消息，攻击者可以恢复足够的信息来伪造签名。例如，如果*w* = 8，并且你使用前述技巧签署数字1和7，以避免简单的伪造，攻击者会得到**Hash**¹(*K*)和**Hash**⁷(*K*
    ′)作为数字1的签名，并且得到**Hash**⁷(*K*)和**Hash**¹(*K* ′)作为数字7的签名。从这些值，攻击者可以计算**Hash***^x*(*K*)和**Hash***^x*(*K*
    ′)，其中*x*是[1;7]范围内的任意值，从而伪造代表*K*和*K* ′所有者的签名。没有简单的方法可以修复这个问题。'
- en: State-of-the-art hash-based schemes rely on more complex versions of WOTS, combined
    with tree data structures and sophisticated techniques designed to sign different
    messages with different keys. Unfortunately, the resulting schemes produce large
    signatures (on the order of dozens of kilobytes, as with SPHINCS+, one of the
    signature algorithms chosen for standardization by NIST in 2022).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最先进的基于哈希的方案依赖于WOTS的更复杂版本，结合了树形数据结构和旨在使用不同密钥签署不同消息的精密技术。不幸的是，最终得到的方案会生成大型签名（例如，SPHINCS+就是NIST在2022年标准化的一种签名算法，签名大小达到数十千字节）。
- en: You should also note the difference between *stateful* and *stateless* signature
    schemes. SPHINCS+ is stateless, whereas XMSS is stateful, as it needs to maintain
    a counter. Statefulness greatly simplifies algorithm design but forces users to
    maintain a state such as a counter while using the algorithm.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该注意*有状态*和*无状态*签名方案之间的区别。SPHINCS+是无状态的，而XMSS是有状态的，因为它需要维护一个计数器。有状态性大大简化了算法设计，但要求用户在使用算法时必须维护诸如计数器之类的状态。
- en: Finally, note that public-key constructions relying on only hash functions can
    offer signature schemes but not encryption.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，仅依赖哈希函数的公钥构造只能提供签名方案，而不能提供加密方案。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The NIST Standards</samp>
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">NIST标准</samp>
- en: In 2017, NIST organized an open competition to identify suitable post-quantum
    algorithm standards for encryption and signature. Like the previous competitions
    that gave us AES (Rijndael) and SHA-3 (Keccak), NIST’s Post-Quantum Cryptography
    Standardization project invited cryptographers to submit algorithms and cryptanalyze
    other submitters’ algorithms to eliminate them from the competition.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年，NIST组织了一场公开竞赛，以识别适用于加密和签名的后量子算法标准。像之前的竞赛一样，AES（Rijndael）和SHA-3（Keccak）就是在此类竞赛中诞生的，NIST的后量子密码学标准化项目邀请了密码学家提交算法，并对其他提交者的算法进行密码分析，以将其排除出竞赛。
- en: 'NIST received 69 submissions, most of which were lattice based. Of these submissions,
    26 made it to the second round. In July 2020, NIST selected seven finalist and
    eight alternate algorithms. In July 2022, NIST announced the first four standards:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: NIST收到了69份提交，其中大多数是基于格的。在这些提交中，26个进入了第二轮。2020年7月，NIST选择了七个最终算法和八个备选算法。2022年7月，NIST宣布了前四个标准：
- en: '**CRYSTALS-Kyber **A lattice-based *key encapsulation mechanism (KEM)*, which
    is a primitive that can be seen as an encryption scheme for secret keys. It can
    be used to encrypt data (within a hybrid scheme, where a symmetric cipher actually
    encrypts the data using a key encrypted by the KEM) and used for key agreement,
    in a similar way as Diffie–Hellman protocols.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**CRYSTALS-Kyber** 一种基于格的*密钥封装机制（KEM）*，它是一种可以视为秘密密钥加密方案的原语。它可以用于加密数据（在混合方案中，使用由KEM加密的密钥实际加密数据）并用于密钥协商，类似于Diffie–Hellman协议。'
- en: '**CRYSTAL-Dilithium **A lattice-based signature scheme designed by the same
    team as CRYSTALS-Kyber.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**CRYSTAL-Dilithium** 一种基于格的签名方案，由与CRYSTALS-Kyber相同的团队设计。'
- en: '**Falcon **A lattice-based signature scheme based on slightly different techniques
    and assumptions than Dilithium.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**Falcon** 一种基于格的签名方案，采用与Dilithium略有不同的技术和假设。'
- en: '**SPHINCS+ **A hash-based signature scheme, thus the only algorithm not based
    on lattices.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**SPHINCS+** 一种基于哈希的签名方案，因此是唯一不基于格的算法。'
- en: 'NIST stated the following regarding having two lattice-based signature schemes:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: NIST在关于使用两个基于格的签名方案时声明了以下内容：
- en: '[Both] were selected for their strong security and excellent performance, and
    NIST expects them to work well in most applications. Falcon will also be standardized
    by NIST since there may be use cases for which CRYSTALS-Dilithium signatures are
    too large.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[两者]都因其强大的安全性和卓越的性能而被选中，NIST预计它们将在大多数应用中表现良好。由于CRYSTALS-Dilithium签名可能过大，Falcon也将被NIST标准化。'
- en: The shortest Dilithium signatures are approximately 2KB long, whereas Falcon’s
    are half as long. NIST also stated that it will standardize SPHINCS+ “to avoid
    relying only on the security of lattices for signatures.”
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最短的Dilithium签名大约为2KB，而Falcon的签名长度是其一半。NIST还声明将标准化SPHINCS+，“以避免仅依赖格的安全性来保证签名安全。”
- en: At the time of writing, draft standards have been published under the FIPS series
    for Kyber, Dilithium, and SPHINCS+ as FIPS 203 (Module-Lattice-Based Key-Encapsulation
    Mechanism Standard), FIPS 204 (Module-Lattice-Based Digital Signature Standard),
    and FIPS 205 (Stateless Hash-Based Digital Signature Standard), respectively,
    while Falcon’s standard is expected a bit later.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写本文时，草案标准已在FIPS系列下发布，分别为FIPS 203（模块-基于格的密钥封装机制标准）、FIPS 204（模块-基于格的数字签名标准）和FIPS
    205（无状态哈希基础数字签名标准），而Falcon的标准预计会稍晚发布。
- en: These post-quantum algorithms are expected to first be used in hybrid modes,
    in combination with a classical, non-quantum-resilient algorithm to hedge the
    risk of weaknesses. For example, Kyber is generally used in combination with X25519,
    the Diffie–Hellman scheme relying on Curve25519, to protect TLS connections.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些后量子算法预计将首先以混合模式使用，与经典的、非量子抗性算法结合使用，以规避弱点风险。例如，Kyber通常与X25519结合使用，X25519是基于Curve25519的Diffie–Hellman方案，用于保护TLS连接。
- en: NIST also announced four algorithms advancing to the “fourth round.” These include
    the three code-based encryption schemes BIKE, Classic McEliece, and HQC. The isogeny-based
    SIKE was found to be completely broken shortly after the announcement and thus
    withdrew from the competition.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: NIST还宣布了四个进入“第四轮”的算法。这些包括三个基于编码的加密方案：BIKE、Classic McEliece和HQC。基于同态的SIKE在宣布后不久就被发现完全被攻破，因此退出了比赛。
- en: NIST started a new project in summer 2022 to identify more post-quantum signature
    schemes, stating that “signature schemes that are not based on structured lattices
    are of greatest interest” and expecting submissions with “short signatures and
    fast verification.” In June 2023, NIST received 50 submissions, including 11 multivariate,
    7 lattice-based, 6 code-based, 2 hash-based, and 7 that use *MPC-in-the-head*.
    This emerging technique turns a multiparty-computation (MPC) protocol into a zero-knowledge
    proof of knowledge—that is, a single piece of data whose verification corresponds
    to the verification of a signature. The proposed number and variety of schemes
    will lead to new attacks and new attack techniques, and hopefully to reliable
    standards.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: NIST于2022年夏季启动了一个新项目，旨在识别更多的后量子签名方案，并表示“非基于结构化格的签名方案最为关注”，并期待收到“短签名和快速验证”的提交。2023年6月，NIST收到50个提交，包括11个多变量方案、7个基于格的方案、6个基于码的方案、2个基于哈希的方案，以及7个使用*MPC-in-the-head*的方案。这一新兴技术将多方计算（MPC）协议转化为零知识证明，即通过验证一条数据来验证签名的有效性。这些方案的数量和种类将导致新的攻击和攻击技术，期待能够形成可靠的标准。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">事情可能出错的方式</samp>
- en: Post-quantum cryptography may be fundamentally stronger than RSA or elliptic
    curve cryptography, but it’s not infallible or omnipotent. Our understanding of
    the security of post-quantum schemes and their implementations is more limited
    than otherwise, which brings with it increased risk.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 后量子密码学可能比RSA或椭圆曲线密码学更强大，但它并非万无一失或无所不能。我们对后量子方案及其实现的安全性理解比其他情况下更为有限，这也带来了更大的风险。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unclear Security
    Level</samp>
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">不明确的安全级别</samp>
- en: Post-quantum schemes can appear deceptively strong yet prove insecure against
    both quantum and classical attacks. Lattice-based algorithms, such as the ring-LWE
    family of computational problems (versions of the LWE problem that work with polynomials),
    are sometimes problematic. Ring-LWE is attractive for cryptographers because we
    can leverage it to build cryptosystems that are in principle as hard to break
    as it is to solve the hardest instances of ring-LWE problems, which can be **NP**-hard.
    But when security looks too good to be true, it often is.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 后量子方案可能看起来异常强大，但在面对量子和经典攻击时却可能不安全。基于格的算法，如环-LWE家族的计算问题（LWE问题的变体，使用多项式进行运算），有时存在问题。环-LWE对于密码学家具有吸引力，因为我们可以利用它构建加密系统，其破解难度原则上与解决环-LWE问题中最难实例的难度相当，而这些问题通常是**NP**-难的。但当安全性看起来过于完美时，它往往并不是真的如此。
- en: Security proofs are often asymptotic, meaning they’re true only for large parameter
    values such as the dimension of the underlying lattice. However, in practice much
    smaller parameters are used. Even when a lattice-based scheme looks to be as hard
    to break as some **NP**-hard problem, its security remains hard to quantify. In
    the case of lattice-based algorithms, we rarely have a clear picture of the best
    attacks against them and the cost of such an attack in terms of computation or
    hardware, due to a lack of understanding of these recent constructions. This uncertainty
    makes lattice-based schemes harder to compare against better-understood constructions
    such as RSA. However, researchers have been making progress on this front and,
    ideally in a few years, lattice problems will be as well understood as RSA. (For
    more technical details on the ring-LWE problem, read Peikert’s excellent survey
    at *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2016<wbr>/351](https://eprint.iacr.org/2016/351)*.)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性证明通常是渐近性的，意味着它们仅对大参数值成立，比如底层格的维度。然而，实际中使用的参数要小得多。即使基于格的方案看起来和某些**NP**-难问题一样难以破解，其安全性仍然很难量化。在基于格的算法中，我们很少能清楚地了解针对它们的最佳攻击以及攻击的计算或硬件成本，因为我们对这些新构造的理解不足。这种不确定性使得基于格的方案更难与理解较为透彻的构造（如RSA）进行比较。然而，研究人员在这方面已取得了一些进展，理想情况下，在几年内，基于格的问题将像RSA一样被充分理解。（有关环-LWE问题的更多技术细节，请阅读Peikert的精彩综述，链接见*
    [https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2016<wbr>/351](https://eprint.iacr.org/2016/351)*。）
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Eventual Existence
    of Large Quantum Computers</samp>
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">大型量子计算机的最终存在</samp>
- en: 'Imagine this CNN headline circa April 2, 2048: “ACME, Inc. reveals its secretly
    built quantum computer, launches break-crypto-as-a-service platform.” OK, RSA
    and elliptic curve crypto are screwed. Now what?'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下2048年4月2日的CNN头条：“ACME公司揭露其秘密建造的量子计算机，推出破解加密即服务平台。” 好吧，RSA和椭圆曲线加密完蛋了。那么接下来呢？
- en: The bottom line is that post-quantum encryption is way more critical than post-quantum
    signatures. Let’s look at the case of signatures first. If you were still using
    RSA-PSS or ECDSA as a signature scheme, you could issue new signatures using a
    post-quantum signature scheme to restore your signatures’ trust. You’d revoke
    your older, quantum-unsafe public keys and compute fresh signatures for every
    message you’d signed. After a bit of work, you’d be fine.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于，后量子加密比后量子签名更为重要。首先，我们来看签名的情况。如果你仍在使用RSA-PSS或ECDSA作为签名方案，你可以使用后量子签名方案颁发新的签名，以恢复签名的可信度。你需要撤销之前的量子不安全公钥，并为你签署的每条消息计算新的签名。经过一些工作后，你就可以恢复正常。
- en: You’d have a reason to panic only if you were encrypting data using quantum-unsafe
    schemes, such as RSA-OAEP. In this case, all transmitted ciphertext could be compromised,
    so it would be pointless to reencrypt that plaintext with a post-quantum algorithm
    since your data’s confidentiality is already gone.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在使用量子不安全的加密方案（如RSA-OAEP）加密数据时，你才有理由感到恐慌。在这种情况下，所有传输的密文都有可能被破解，因此使用后量子算法重新加密这些明文没有意义，因为你的数据的机密性已经丧失。
- en: 'But what about key agreement, with Diffie–Hellman (DH) and its elliptic curve
    counterpart (ECDH)? At first glance, the situation looks to be as bad as with
    encryption: attackers who’ve collected public keys *g**^a* and *g**^b* could use
    their shiny new quantum computer to compute the secret exponent *a* or *b* and
    compute the shared secret *g**^(ab)*, and then derive from it the keys that encrypted
    your traffic. But in practice, Diffie–Hellman isn’t always used in such a simplistic
    fashion. The actual session keys that encrypt your data may be derived from both
    the Diffie–Hellman shared secret and some internal state of your system. That’s
    how state-of-the-art mobile messaging systems work, thanks to a protocol pioneered
    with the Signal application. When you send a new message to a peer with Signal,
    it computes a new Diffie–Hellman shared secret and combines it with internal secrets
    that depend on the previous messages sent within that session (which can span
    long periods of time). Such advanced use of Diffie–Hellman makes the work of an
    attacker much harder, even with a quantum computer.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 那么密钥协议呢，像Diffie–Hellman (DH)和它的椭圆曲线变种(ECDH)呢？乍一看，情况看起来和加密一样糟糕：攻击者如果已经收集了公钥 *g**^a*
    和 *g**^b*，他们可以利用他们的新量子计算机计算出秘密指数 *a* 或 *b*，然后计算出共享的秘密 *g**^(ab)*，进而推导出加密你流量的密钥。但实际上，Diffie–Hellman并不总是如此简单地使用。加密你的数据的实际会话密钥可能是由Diffie–Hellman共享秘密和你系统的某些内部状态共同推导出来的。这就是现代移动消息系统的工作原理，得益于Signal应用程序开创的协议。当你通过Signal发送新消息给对方时，它会计算一个新的Diffie–Hellman共享秘密，并将其与依赖于该会话中先前消息的内部秘密相结合（该会话可能会持续较长时间）。这种Diffie–Hellman的高级使用方式，使得即使是量子计算机的攻击者也更难破解。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementation Issues</samp>
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">实现问题</samp>
- en: In practice, post-quantum schemes consist of code—software running on some physical
    processor—not just abstract algorithms. However strong the algorithms may be on
    paper, they won’t be immune to implementation errors, software bugs, or side-channel
    attacks. An algorithm may be completely post-quantum in theory but may still be
    broken once implemented—for example, by a classical computer program because a
    programmer forgot to enter a semicolon.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，后量子方案是由代码构成的——即在某些物理处理器上运行的软件——而不仅仅是抽象的算法。无论算法在理论上多么强大，它们也无法避免实现错误、软件漏洞或侧信道攻击。一个算法在理论上可能完全是后量子的，但一旦实现，可能会被攻破——例如，由于程序员忘记输入分号，导致经典计算机程序出现漏洞。
- en: Furthermore, schemes such as code-based and lattice-based algorithms rely heavily
    on mathematical operations, the implementation of which uses a variety of tricks
    to make those operations as fast as possible. By the same token, the complexity
    of the code in these algorithms makes implementation more vulnerable to side-channel
    attacks, such as timing attacks, which infer information about secret values based
    on measurement of execution times. In fact, we’ve already applied such attacks
    to code-based encryption (see *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2010<wbr>/479](https://eprint.iacr.org/2010/479)*)
    and to lattice-based signature schemes (see *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2016<wbr>/300](https://eprint.iacr.org/2016/300)*).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，像基于编码和基于格的算法等方案在很大程度上依赖于数学运算，其实现使用了各种技巧，使这些运算尽可能快速。同样，这些算法中代码的复杂性使得实现更容易受到旁道攻击的威胁，例如定时攻击，这类攻击通过测量执行时间推断关于秘密值的信息。事实上，我们已经将此类攻击应用于基于编码的加密（参见
    *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2010<wbr>/479](https://eprint.iacr.org/2010/479)*）和基于格的签名方案（参见
    *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2016<wbr>/300](https://eprint.iacr.org/2016/300)*）。
- en: Ironically, using post-quantum schemes may be less secure in practice at first
    than non-post-quantum ones due to potential vulnerabilities in their implementations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 具有讽刺意味的是，由于实现中的潜在漏洞，使用后量子方案在实践中的安全性可能比非后量子方案更低。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">进一步阅读</samp>'
- en: To learn the basics of quantum computation, read the classic *Quantum Computation
    and Quantum Information (Anniversary Edition)* by Michael Nielsen and Isaac Chuang
    (Cambridge, 2011). Scott Aaronson’s *Quantum Computing Since Democritus* (Cambridge,
    2013), a less technical and more entertaining read, covers more than quantum computing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习量子计算的基础知识，可以阅读迈克尔·尼尔森（Michael Nielsen）和艾萨克·春光（Isaac Chuang）合著的经典书籍《量子计算与量子信息（纪念版）》(剑桥，2011)。斯科特·艾伦森（Scott
    Aaronson）的《自德谟克里特以来的量子计算》（剑桥，2013）是一本更具娱乐性的读物，涉及的不仅仅是量子计算。
- en: Several software simulators allow you to experiment with quantum computing,
    such as The Quantum Computing Playground at *[https://<wbr>www<wbr>.quantumplayground<wbr>.net](https://www.quantumplayground.net)*
    or IBM’s platform at *[https://<wbr>quantum<wbr>.ibm<wbr>.com](https://quantum.ibm.com)*.
    These sites are relatively easy to use, thanks to intuitive visualizations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个软件模拟器允许你进行量子计算实验，例如 *[https://<wbr>www<wbr>.quantumplayground<wbr>.net](https://www.quantumplayground.net)*
    上的量子计算游乐场，或IBM的 *[https://<wbr>quantum<wbr>.ibm<wbr>.com](https://quantum.ibm.com)*
    平台。这些网站相对易于使用，得益于直观的可视化。
- en: For the latest research in post-quantum cryptography, see *[https://<wbr>pqcrypto<wbr>.org](https://pqcrypto.org)*
    and the associated conference PQCrypto.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有关后量子密码学的最新研究，参见 *[https://<wbr>pqcrypto<wbr>.org](https://pqcrypto.org)* 以及相关会议PQCrypto。
- en: The coming years promise to be particularly exciting for post-quantum crypto,
    thanks to the continuation of NIST’s Post-Quantum Cryptography Standardization
    project and the deployment at scale of post-quantum solutions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 未来几年，后量子密码学有望特别令人兴奋，这得益于NIST后量子密码学标准化项目的持续推进以及后量子解决方案的大规模部署。
