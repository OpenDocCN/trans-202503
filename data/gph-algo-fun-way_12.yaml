- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TOPOLOGICAL
    SORT</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">拓扑排序</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In addition to their physical corollaries, such as one-way streets, we can use
    directed edges in a graph to specify a *dependency* or *ordering* between nodes.
    Incoming edges to a node represent links from actions that must be completed before
    reaching the current node. Meanwhile, outgoing edges point to actions enabled
    by the completion of the current node.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它们的物理对应物（如单行道）外，我们还可以在图中使用有向边来指定节点之间的*依赖关系*或*排序顺序*。指向节点的入边表示必须在到达当前节点之前完成的动作。而出边指向的是通过完成当前节点后能够启用的动作。
- en: Consider the example of a recipe for chocolate chip cookies. Each node represents
    a step in the recipe, including instructions such as “Add the flour” and “Stir
    the mixture.” Some of the steps have a clear and non-negotiable ordering. We wouldn’t
    want to stir the mixture before adding anything to the bowl or add ingredients
    before we measure them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个制作巧克力曲奇饼干的食谱示例。每个节点代表食谱中的一个步骤，包括诸如“添加面粉”和“搅拌混合物”等指令。某些步骤有明确且不可更改的顺序。我们不希望在往碗里加入任何东西之前就搅拌混合物，也不希望在没有测量之前就加入配料。
- en: This chapter introduces algorithms for *topological sort*, which orders a graph’s
    nodes in the order specified by directed edges. After discussing the concepts
    behind topological ordering and presenting several real-world use cases and algorithms
    for sorting, we’ll explore the importance of graphs without loops for topological
    sort and consider why instruction manuals are not drawn as graphs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了*拓扑排序*算法，它按照有向边指定的顺序对图的节点进行排序。在讨论了拓扑排序背后的概念，并展示了几个实际应用案例和排序算法后，我们将探讨无环图对拓扑排序的重要性，并考虑为什么说明书不是以图的形式呈现的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Topological Sort Algorithms Work</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">拓扑排序算法是如何工作的</samp>
- en: A topological sort algorithm finds an ordering of nodes such that if there exists
    a directed edge from node *u* to node *v*, then node *u* must precede node *v*
    in the ordering. In other words, each directed edge represents a *dependency*.
    Some graphs have multiple valid orderings. For example, [Figure 9-1](#fig9-1)
    shows a graph with valid topological orderings [0, 1, 2, 4, 3] and [0, 2, 1, 4,
    3].
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个拓扑排序算法会找到一个节点的排序，使得如果从节点*u*到节点*v*有一条有向边，则节点*u*必须排在节点*v*之前。换句话说，每条有向边代表一个*依赖关系*。有些图有多个有效的排序。例如，[图
    9-1](#fig9-1)展示了一个具有有效拓扑排序[0, 1, 2, 4, 3]和[0, 2, 1, 4, 3]的图。
- en: '![A graph with five nodes and directed edges (0, 1), (0, 2), (1, 3), (1, 4),
    (2, 4), and (4, 3).](../images/f09001.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含五个节点和有向边（0, 1）、（0, 2）、（1, 3）、（1, 4）、（2, 4）和（4, 3）的图。](../images/f09001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: A directed graph
    with two valid topological orderings</samp>'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-1：具有两个有效拓扑排序的有向图</samp>
- en: A key constraint for topological sort is that the graph must be *acyclic*, meaning
    it does not contain any *cycles*. A directed graph has a cycle if it is possible
    to define a path from a node such that the path returns to that same node, as
    shown in [Figure 9-2](#fig9-2) (a slight modification of the graph in [Figure
    9-1](#fig9-1)). Starting from node 1, we can travel back to node 1 through nodes
    4 and 3 via the path [1, 4, 3, 1].
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑排序的一个关键约束是图必须是*无环*的，意味着图中不能包含任何*循环*。如果一个有向图中存在一条从某节点出发并最终回到该节点的路径，那么该图就包含了一个循环，如[图
    9-2](#fig9-2)所示（这是[图 9-1](#fig9-1)的稍微修改版）。从节点 1 出发，我们可以通过节点 4 和 3 回到节点 1，路径为[1,
    4, 3, 1]。
- en: '![A graph with five nodes and directed edges (0, 1), (0, 2), (1, 4), (2, 4),
    (3, 1), and (4, 3).](../images/f09002.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含五个节点和有向边（0, 1）、（0, 2）、（1, 4）、（2, 4）、（3, 1）和（4, 3）的图。](../images/f09002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: A directed graph
    with a cycle</samp>'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-2：带有循环的有向图</samp>
- en: A graph with cycles will not have a valid topological ordering because it contains
    at least one node with a path that leads back to itself. That means this node
    must precede itself in the sorted list, which is obviously impossible. No matter
    how we order nodes 1, 3, and 4 in [Figure 9-2](#fig9-2), we’ll always have an
    edge pointing from a later to an earlier node. We call a directed graph with no
    cycles a *directed acyclic graph* or *DAG*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 含有环的图将无法进行有效的拓扑排序，因为它包含至少一个节点，其路径指向自身。这意味着该节点必须排在排序列表中的前面，但这是显然不可能的。不论我们如何在[图
    9-2](#fig9-2)中排序节点1、3和4，始终会有一条边从后来的节点指向较早的节点。我们称没有环的有向图为*有向无环图*，简称*DAG*。
- en: 'We can test whether a topological ordering is valid by checking the relative
    ordering of each pair of nodes with a directed edge:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查每对节点之间的相对顺序来测试拓扑排序是否有效：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code starts by checking that the ordering contains the same number of nodes
    as the graph ❶. If not, the ordering cannot be valid, and the function returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Next, a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop builds an inverted index mapping each node to its location in the sorted
    array ❷. This will allow it to easily look up the relative ordering of any two
    nodes given their indices. During this loop, the code also checks for duplicate
    nodes in the ordering by testing if <samp class="SANS_TheSansMonoCd_W5Regular_11">index_to_pos</samp>
    is already set. If it finds a node listed twice, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    to indicate an invalid ordering.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查排序中是否包含与图相同数量的节点❶。如果不相等，排序无效，函数返回<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。接着，一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环构建一个反向索引，将每个节点映射到它在排序数组中的位置❷。这使得它能够轻松查找任意两个节点的相对顺序。在此循环中，代码还通过测试<samp
    class="SANS_TheSansMonoCd_W5Regular_11">index_to_pos</samp>是否已被设置，来检查排序中是否存在重复节点。如果发现某个节点出现两次，函数将返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，表示排序无效。
- en: The code then iterates through each node and each of its outgoing edges using
    a nested pair of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops
    ❸. For each of these directed edges, the code checks that the nodes are ordered
    correctly by comparing their positions in <samp class="SANS_TheSansMonoCd_W5Regular_11">ordering</samp>
    (using <samp class="SANS_TheSansMonoCd_W5Regular_11">index_to_pos</samp>). The
    function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> as
    soon as it finds a single pairing out of order. Finally, if the code has made
    it through this gauntlet of checks, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过一对嵌套的<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环❸遍历每个节点及其所有出边。对于这些有向边中的每一条，代码通过比较节点在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ordering</samp>中的位置（使用<samp class="SANS_TheSansMonoCd_W5Regular_11">index_to_pos</samp>）来检查节点是否按正确顺序排列。一旦发现有任何一对节点顺序错误，函数立即返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。最后，如果代码顺利通过所有检查，它将返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用案例</samp>
- en: Topological sort has a variety of real-world use cases. This section describes
    how to represent several of these cases as graphs to which we could apply the
    topological sort.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑排序在现实世界中有多种应用场景。本节描述了如何将其中几个应用场景表示为图，并对其应用拓扑排序。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Code Dependencies</samp>
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码依赖</samp>
- en: 'Programmers often break large programs into a series of modules or libraries
    to facilitate understandability, maintainability, and extensibility. Instead of
    a single file with a million lines of code, a programmer might create three modules:
    one for representing and processing graphs, another for handling the user interface,
    and a third for reading and writing files. Ideally, they would design the modules
    to build off one other, allowing them to reuse core library functions throughout
    the code. For example, the graph library and user interface code might rely on
    the file module to read and write configuration files.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员通常将大型程序拆分成一系列模块或库，以促进可理解性、可维护性和可扩展性。与其编写一个包含百万行代码的单一文件，程序员可能会创建三个模块：一个用于表示和处理图，另一个用于处理用户界面，第三个用于读取和写入文件。理想情况下，他们会设计这些模块相互依赖，以便能够在整个代码中重用核心库函数。例如，图形库和用户界面代码可能依赖文件模块来读取和写入配置文件。
- en: Such code dependencies mean that the code is processed in a particular order.
    We can represent these dependencies as a directed graph where each module is a
    node in the graph and each <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">include</samp> statement represents
    an incoming edge to that node. The topological sort of this graph tells the computer
    the order in which it needs to process the files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码依赖关系意味着代码需要按照特定的顺序处理。我们可以将这些依赖关系表示为一个有向图，其中每个模块是图中的一个节点，每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">include</samp> 语句表示指向该节点的输入边。该图的拓扑排序告诉计算机处理文件的顺序。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Task Lists</samp>
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">任务列表</samp>
- en: We can extend the importance of following a recipe in a particular order to
    a wide range of tasks, from writing to cleaning to assembling furniture. In each
    of these cases, nodes represent steps on our task list and edges represent dependencies
    between them. For example, we need to get out the mop and bucket before we can
    wash the floor. As another example, [Figure 9-3](#fig9-3) shows a graph representing
    the steps for making a peanut-butter-and-jelly sandwich.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将按照特定顺序遵循食谱的重要性扩展到广泛的任务中，从写作到清洁到组装家具。在这些情况下，节点代表任务列表中的步骤，边表示它们之间的依赖关系。例如，我们需要先拿出拖把和水桶，然后才能洗地板。另一个例子是，[图
    9-3](#fig9-3) 显示了一个图表，表示制作花生酱果冻三明治的步骤。
- en: '![Seven boxes represent steps of making a sandwich. On the left are boxes for
    “Get two pieces of bread,” “Get jar of peanut butter,” and “Get jar of jelly or
    jam.” The box for “Get two pieces of bread” has an arrow to the box for “Place
    bread on plate.” The box for “Spread peanut butter onto one piece of bread” has
    arrows from the boxes “Place bread on plate” and “Get jar of peanut butter.” The
    box for “Spread jelly onto the other piece of bread” has arrows from the boxes
    “Spread peanut butter onto one piece of bread” and “Get jar of jelly or jam.”
    The box for “Place the bread with the peanut butter on top of the bread with jelly
    to make a sandwich” has an arrow from the box “Spread jelly onto the other piece
    of bread.”](../images/f09003.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![七个框表示制作三明治的步骤。左边是“取两片面包”、“取花生酱瓶”和“取果冻或果酱瓶”的框。“取两片面包”的框指向“将面包放在盘子上”的框。“将花生酱涂抹到一片面包上”的框从“将面包放在盘子上”和“取花生酱瓶”这两个框中各有一条箭头。“将果冻涂抹到另一片面包上”的框从“将花生酱涂抹到一片面包上”和“取果冻或果酱瓶”这两个框中各有一条箭头。“将涂有花生酱的面包放在涂有果冻的面包上，做成三明治”的框从“将果冻涂抹到另一片面包上”的框指向。](../images/f09003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: The task graph
    for making a peanut-butter-and-jelly sandwich</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-3：制作花生酱果冻三明治的任务图</samp>
- en: Although most instruction manuals are written as a linear series of instructions,
    there is often some flexibility in the order, meaning the graph is not necessarily
    a straight line of nodes. For example, consider the process of assembling a prefabricated
    chair. It might not matter whether you attach the left or right arm first. However,
    it could be vital that you finish the body of the chair before attaching the seat
    cushion.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数说明手册是按线性顺序编写的，但顺序上通常是有一定灵活性的，这意味着图形不一定是节点的直线。例如，考虑组装一把预制椅子的过程。你先安装左臂还是右臂可能并不重要。然而，完成椅子的主体再安装座垫可能是至关重要的。
- en: Representing instructions as a graph clearly offers opportunities for parallelism.
    Two people working on a single recipe could theoretically complete it more quickly
    than one alone; one baker can measure out the flour while another measures out
    the sugar, and so on. Unfortunately, this parallel representation would likely
    cause more rather than fewer problems. I personally struggle to remember which
    step I’m on when using linear instructions, spending minutes trying to remember
    whether I’ve added the salt to the bowl. Tracking which steps have been completed
    through a branching graph of tasks is almost guaranteed to result in me missing
    steps.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将指令表示为图形显然为并行性提供了机会。理论上，两个人一起做一个食谱可以比一个人更快完成；一个烘焙师可以量取面粉，而另一个量取糖，等等。不幸的是，这种并行表示可能会引发更多问题而不是更少。我个人在使用线性指令时常常忘记自己在哪一步，花费几分钟回想我是否已经把盐加入了碗中。通过任务的分支图跟踪已完成的步骤几乎可以保证我会漏掉某些步骤。
- en: Fortunately, while humans struggle to track this type of state, computers excel
    at it, using graph structures to find opportunities for parallelism. In fact,
    there are entire systems that structure workflows as graphs. Distributed workflow
    systems are often built around the concept of task graphs, where multiple tasks
    are executed in an order determined by their dependency. The design and optimization
    of such workflows is an active area of development, and the topic could fill its
    own book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，虽然人类很难追踪这种状态，但计算机在这方面表现得非常出色，它们使用图结构来寻找并行性机会。事实上，整个系统就是围绕图的概念构建工作流程的。分布式工作流系统通常是基于任务图的概念构建的，其中多个任务按其依赖关系的顺序执行。此类工作流的设计与优化是一个活跃的研究领域，且这一话题足以单独成书。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Teaching and
    Learning</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">教学与学习</samp>'
- en: Many academic subjects consist of a large set of interrelated concepts, some
    of which must be understood before moving on to the next. A math teacher would
    find it difficult to explain the concept of exponents before their students have
    learned how to multiply. Other concepts can be covered in parallel, however. When
    learning a foreign language, the student might be able to learn vocabulary related
    to coffee shops regardless of whether they know computer science terminology.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 许多学科由大量相互关联的概念组成，其中一些必须在继续学习下一个概念之前先理解。例如，数学老师很难在学生还没有学会乘法之前解释指数的概念。然而，其他一些概念可以并行学习。学习外语时，学生可能能够学习与咖啡店相关的词汇，而不必先掌握计算机科学术语。
- en: We can specify the recommended order for teaching or learning concepts as a
    graph. Nodes represent concepts, such as the French word for coffee or the idea
    of recursion, while edges represent dependencies between the concepts. In the
    case of computer science, we might put an edge from the concept of functions to
    that of recursion to indicate that a student should learn about functions before
    venturing into the world of recursion.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将教学或学习概念的推荐顺序指定为一个图。节点表示概念，例如法语中的“咖啡”一词或递归的概念，而边则表示这些概念之间的依赖关系。在计算机科学的情况下，我们可能会将“函数”这一概念与“递归”概念之间加一条边，以表明学生应在学习递归之前了解函数。
- en: Relying on this graph representation, we can use topological sort to determine
    which courses in a college curriculum we need to take first. Consider the graph
    in [Figure 9-4](#fig9-4) built from hypothetical course prerequisites.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种图形表示法，我们可以使用拓扑排序来确定在大学课程中需要先修的课程。请参见[图 9-4](#fig9-4)，该图展示了一个假设的课程先修关系图。
- en: '![Seven boxes represent different computer science classes. The box for CS300:
    Advanced Algorithms lists prerequisites CS200 and CS201 and has incoming arrows
    from both of those boxes.](../images/f09004.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![七个框代表不同的计算机科学课程。CS300：高级算法的框列出了先修课程CS200和CS201，并且这两个框都有指向该框的箭头。](../images/f09004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4: A graph representing
    the prerequisites of computer science courses</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-4：表示计算机科学课程先修关系的图</samp>
- en: 'To take CS450: Advanced AI, a student would need to complete the chain of prerequisites
    for this course, all the way back to CS100: Introduction to Programming.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修完CS450：高级人工智能，学生需要完成这门课程的先修链，直到CS100：编程入门。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Kahn’s Algorithm</samp>
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">卡恩算法</samp>
- en: Computer scientist Arthur B. Kahn developed one approach, now called *Kahn’s
    algorithm*, for performing topological sort on a directed acyclic graph. This
    algorithm operates by finding nodes with no incoming edges, removing them from
    the list of pending nodes, adding them to a sorted list, and then removing the
    outbound edges from that node. The algorithm repeats until it has added every
    node to the sorted list.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家Arthur B. Kahn提出了一种方法，现在称为*Kahn算法*，用于在有向无环图上执行拓扑排序。该算法通过找到没有入边的节点，将其从待处理节点列表中移除，添加到已排序列表中，然后删除该节点的出边。算法会重复此过程，直到将所有节点都添加到已排序列表中。
- en: Intuitively, the Kahn’s algorithm sort mirrors how we might perform a complex
    task in the real world. We perform a subtask that we can accomplish without completing
    any other steps first, then move on to another subtask. Any action that requires
    us to have performed an as-yet-uncompleted task must wait until we have finished
    all its dependencies.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 直观上，Kahn算法的排序方式类似于我们在现实世界中执行复杂任务的方式。我们首先执行一个可以不需要完成其他任何步骤的子任务，然后继续进行另一个子任务。任何需要我们先完成某个任务的行动，必须等到我们完成所有依赖任务后才能进行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: When implementing Kahn’s algorithm, we don’t need to modify the graph we’re
    working with by removing nodes or edges. Instead, we can use an additional array
    <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> to track the number
    of incoming edges to each node and decrease those counts whenever we “remove”
    a node. Since we don’t have to modify the graph data structure, we can avoid making
    an initial copy, re-adding the removed edges, or leaving the structure altered.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现Kahn算法时，我们不需要通过删除节点或边来修改正在处理的图。相反，我们可以使用额外的数组<samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>来跟踪每个节点的入边数量，并在我们“删除”一个节点时减少这些计数。由于我们不需要修改图的数据结构，因此可以避免进行初始复制、重新添加删除的边或使结构发生变化。
- en: The code for Kahn’s algorithm uses a stack and multiple loops, as shown in [Listing
    9-1](#list9-1).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Kahn算法的代码使用了栈和多个循环，如在[列表 9-1](#list9-1)所示。
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-1: Kahn’s algorithm
    for topological sorting</samp>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 9-1：Kahn算法的拓扑排序</samp>
- en: The code starts by creating the helper data structures used by the algorithm.
    The array <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> stores the
    count of *incoming* nodes for each edge and will be used to check for nodes without
    any incoming edges. The stack <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    (implemented as a list) stores the indices of unprocessed nodes without incoming
    edges. These will be the nodes that the code can remove from the graph. Finally,
    the list <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> will hold
    the topologically sorted list of node indices.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先创建了算法所需的辅助数据结构。数组<samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>存储每个边的*入节点*计数，并将用于检查没有任何入边的节点。栈<samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp>（实现为列表）存储没有入边的未处理节点的索引。这些节点就是代码可以从图中删除的节点。最后，列表<samp
    class="SANS_TheSansMonoCd_W5Regular_11">result</samp>将保存拓扑排序后的节点索引列表。
- en: The code uses a pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops to count the number of incoming edges for each node ❶. In the first loop,
    since the algorithm is working on a directed graph, the code must iterate over
    all nodes (outer loop) and their outgoing edges (inner loop) and increment the
    count of incoming edges for the edge’s destination (<samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>).
    The next <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop iterates
    over the <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> array, finds
    nodes that have no incoming edges (<samp class="SANS_TheSansMonoCd_W5Regular_11">count[current.index]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>),
    and inserts their index into the stack <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>.
    The function has now set up all the initial information it needs to perform the
    topological sort.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码使用了一对嵌套的<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环来计算每个节点的入边数量❶。在第一个循环中，由于算法在处理有向图，代码必须遍历所有节点（外层循环）及其出边（内层循环），并增加入边目标节点的计数（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>）。接下来的<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环遍历<samp
    class="SANS_TheSansMonoCd_W5Regular_11">count</samp>数组，查找没有入边的节点（<samp class="SANS_TheSansMonoCd_W5Regular_11">count[current.index]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>），并将它们的索引插入到栈<samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp>中。此时，函数已经设置了所有需要的初始信息，可以执行拓扑排序了。
- en: The main body of the code is a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop that processes each item in the stack ❷. At each iteration, the code pops
    a node index from <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>. It retrieves
    the corresponding node and adds this index to the end of the <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    array. The function then virtually removes the node and its outgoing edges by
    iterating over each outgoing edge and decreasing the count of edges going to the
    destination ❸. In the process, it checks whether any node falls to zero incoming
    edges and, if so, adds that node’s index to the stack. The code completes by returning
    the array of sorted node indices with <samp class="SANS_TheSansMonoCd_W5Regular_11">return
    result</samp>.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的主体是一个<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环，处理堆栈中的每个项目
    ❷。在每次迭代中，代码从<samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>中弹出一个节点索引。它检索相应的节点，并将该索引添加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">result</samp>数组的末尾。然后，函数通过遍历每条出边并减少指向目标的边的计数，虚拟地移除该节点及其出边
    ❸。在此过程中，它检查是否有任何节点的传入边数降至零，如果是，则将该节点的索引添加到堆栈中。代码通过使用<samp class="SANS_TheSansMonoCd_W5Regular_11">return
    result</samp>返回排序后的节点索引数组来完成。
- en: Each iteration focuses on a single node and its outgoing edges, meaning the
    running time of the algorithm scales linearly with the number of nodes plus the
    number of outgoing edges.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代都集中于单个节点及其出边，这意味着算法的运行时间与节点数加上出边数成线性关系。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">示例</samp>
- en: '[Figure 9-5](#fig9-5) shows how to run Kahn’s algorithm on an example graph,
    where each subfigure represents a step in the algorithm’s progression. The figure
    displays the count of the incoming edges (the values in <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>)
    above each node and grays out removed nodes and edges.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-5](#fig9-5)展示了如何在示例图上运行 Kahn 算法，其中每个子图表示算法进展的一个步骤。图中显示了每个节点上方传入边的计数（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">count</samp>中的值），并且移除的节点和边被灰显。'
- en: The algorithm initializes the counts of incoming edges based on the input graph
    and stores the two nodes without any incoming edges (nodes 0 and 1) in the stack,
    as shown in [Figure 9-5(a)](#fig9-5). During the first step of the sort in [Figure
    9-5(b)](#fig9-5), the algorithm takes the top element (node 1) off the next stack
    and “removes” it and its outgoing edges from the graph, resulting in decreased
    counts for nodes 3 and 4\. Since neither destination node’s count decreases to
    zero, the code adds neither to the stack.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 算法基于输入图初始化传入边的计数，并将没有任何传入边的两个节点（节点 0 和 1）存入堆栈，如[图 9-5(a)](#fig9-5)所示。在[图 9-5(b)](#fig9-5)中的排序的第一步，算法从堆栈中取出顶部元素（节点
    1），并将其及其出边“移除”出图，从而减少节点 3 和 4 的计数。由于没有目标节点的计数减少到零，代码因此不会将它们添加到堆栈中。
- en: In [Figure 9-5(c)](#fig9-5), the sort continues by popping node 0 from the stack
    and removing its edges to nodes 2 and 3\. This reduces the count in incoming edges
    to both nodes 2 and 3 down to zero, allowing the sort to add them to the stack.
    The process continues, node by node, until every node in the stack has been exhausted.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 9-5(c)](#fig9-5)中，排序继续，通过从堆栈中弹出节点 0 并移除其到节点 2 和 3 的边。这样，节点 2 和 3 的传入边计数都降至零，允许将它们添加到堆栈中。该过程逐个节点地继续，直到堆栈中的每个节点都被处理完毕。
- en: '![The seven steps of Kahn’s algorithm. (A) shows a directed graph with edges
    (0, 2), (0, 3), (1, 3), (1, 4), (2, 4), (3, 4), and (4, 5). In (B), node 1 is
    grayed out along with its edges to nodes 3 and 4\. The count to above node 3 is
    1.](../images/f09005.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Kahn 算法的七个步骤。(A) 显示了一个有向图，其中包含边 (0, 2)，(0, 3)，(1, 3)，(1, 4)，(2, 4)，(3, 4)
    和 (4, 5)。在 (B) 中，节点 1 及其到节点 3 和 4 的边被灰显。到节点 3 的计数为 1。](../images/f09005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-5: Running Kahn’s
    algorithm on an example graph</samp>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-5：在示例图上运行 Kahn 算法</samp>
- en: We can picture Kahn’s algorithm in the context of a careful baker following
    a complex recipe. Before they start, the baker writes down all the tasks and which
    ones are the necessary prerequisites. Task 5a, “Add two cups of flour,” must come
    after Task 4, “Mix the wet ingredients in a large bowl,” and Task 1a, “Measure
    two cups of flour.” However, the baker can complete Task 5a either before or after
    Task 5b, “Add a tablespoon of baking soda,” because the order in which the flour
    and baking soda are added does not matter. The baker counts the number of prerequisites
    for each task and writes those numbers next to their respective tasks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将卡恩算法想象成一个小心翼翼的烘焙师按照复杂食谱的过程。开始之前，烘焙师把所有任务及其必要的前提任务写下来。任务5a，“添加两杯面粉”必须在任务4，“在大碗中混合湿性原料”和任务1a，“量取两杯面粉”之后完成。然而，烘焙师可以在任务5a之前或之后完成任务5b，“加入一汤匙小苏打”，因为面粉和小苏打的添加顺序无关紧要。烘焙师会计算每个任务的前提任务数量，并将这些数字写在各自任务旁边。
- en: The baker begins by choosing one task with no outstanding prerequisites, performing
    that task, and checking it off the list. They then go through the list of tasks
    and update the count of unsatisfied prerequisites for all future tasks that depended
    on the one they just completed. After measuring out two cups of flour, for example,
    they can update the dependency count of Task 5a, “Add two cups of flour,” from
    2 to 1—they’ve measured the flour but still need to mix the wet ingredients before
    proceeding. Once they’ve completed Task 4, “Mix the wet ingredients in a large
    bowl,” they can put Task 5a on their list of next steps.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 烘焙师首先选择一个没有未完成前提任务的任务，执行该任务并在列表中勾选。然后，他们会遍历任务列表，并更新所有依赖于刚完成的任务的未来任务的未满足前提任务数量。例如，在量取了两杯面粉之后，他们可以将任务5a，“添加两杯面粉”的依赖计数从2更新为1——他们已经量取了面粉，但仍需要混合湿性原料才能继续。完成任务4，“在大碗中混合湿性原料”后，他们可以将任务5a添加到下一步的任务列表中。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Depth-First Search</samp>
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">深度优先搜索</samp>
- en: Beyond Kahn’s algorithm, an alternative approach to sorting the nodes in a directed
    acyclic graph is to use the trusty multipurpose tool of depth-first search. Depth-first
    search starts at a given node *u*, then explores the nodes after *u* in topological
    order. We can modify depth-first search to track the order in which we complete
    processing of each node. By saving the order in which the search finishes exploring
    each node, depth-first search can reconstruct the *inverse* ordering of nodes.
    The last nodes in topological ordering will be the first to finish in a depth-first
    search and thus will appear at the start of the list.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了卡恩算法，另一种对有向无环图（DAG）中的节点进行排序的方法是使用深度优先搜索这一多功能工具。深度优先搜索从给定的节点*u*开始，然后按拓扑顺序探索*u*之后的节点。我们可以修改深度优先搜索，跟踪每个节点处理完成的顺序。通过保存搜索完成每个节点探索的顺序，深度优先搜索可以重建节点的*逆*排序。拓扑排序中的最后节点将在深度优先搜索中最先完成，因此会出现在列表的开头。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: 'The code for topological sort based on depth-first search largely mirrors the
    other depth-first search implementations that we have used throughout the book,
    as shown in [Listing 9-2](#list9-2). However, we maintain one additional piece
    of information: a list <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    to track the order in which the search completes its visits to each node.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 基于深度优先搜索的拓扑排序代码在很大程度上与我们在本书中使用的其他深度优先搜索实现相似，如[Listing 9-2](#list9-2)所示。然而，我们维护了一项额外的信息：一个列表<samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp>来跟踪搜索完成访问每个节点的顺序。
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-2: The depth-first
    search algorithm for topological sorting</samp>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-2：用于拓扑排序的深度优先搜索算法</samp>
- en: The code in [Listing 9-2](#list9-2) consists of two functions. The outer <samp
    class="SANS_TheSansMonoCd_W5Regular_11">topological _dfs()</samp> function sets
    up the data structures, calls depth-first search on different starting nodes,
    and processes the results. It starts by creating an empty list <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    and a list <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> with all
    entries set to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. The
    function then loops through each node. If it finds a node that has not yet been
    visited, the function starts a depth-first search from that node ❶. Finally, the
    function takes the list of node indices and outputs them to the result list in
    reverse order ❷.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-2](#list9-2) 中的代码由两个函数组成。外部的 <samp class="SANS_TheSansMonoCd_W5Regular_11">topological
    _dfs()</samp> 函数设置数据结构，调用深度优先搜索来从不同的起始节点开始，并处理结果。它首先创建一个空列表 <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    和一个包含所有元素初始值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> 的列表 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>。然后，函数遍历每个节点。如果发现一个尚未访问的节点，函数从该节点开始进行深度优先搜索
    ❶。最后，函数将节点索引列表按相反的顺序输出到结果列表中 ❷。'
- en: 'The inner <samp class="SANS_TheSansMonoCd_W5Regular_11">topological_dfs_recursive()</samp>
    function that follows is a recursive implementation of depth-first search with
    one modification: it appends each completed node onto a list. This function starts
    by marking the current node as seen, then iterates through the neighbors via the
    list of edges and recursively explores any unseen neighbors. Finally, it inserts
    the current node index at the end of the list <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    to track the order in which it finished visiting the nodes ❸.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的内部 <samp class="SANS_TheSansMonoCd_W5Regular_11">topological_dfs_recursive()</samp>
    函数是一个递归实现的深度优先搜索，唯一的修改是：它将每个已完成的节点附加到一个列表中。此函数首先将当前节点标记为已访问，然后通过边列表迭代邻居，并递归地探索任何未访问的邻居。最后，它将当前节点的索引插入到列表
    <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> 的末尾，以跟踪其完成访问节点的顺序 ❸。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">示例</samp>
- en: '[Figure 9-6](#fig9-6) shows an example topological sort by depth-first search,
    where the current node being visited is circled by a dashed line and the seen
    nodes are shaded.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-6](#fig9-6) 展示了一个通过深度优先搜索进行拓扑排序的示例，其中当前正在访问的节点由虚线圈出，已访问的节点被着色。'
- en: The search begins in [Figure 9-6(a)](#fig9-6) on node 0 and explores down the
    path of node 2 in [Figure 9-6(b)](#fig9-6), node 4 in [Figure 9-6(c)](#fig9-6),
    and node 5 in [Figure 9-6(d)](#fig9-6). At each node, the algorithm marks the
    node as seen and recursively explores its unseen neighbors. It isn’t until the
    search finishes processing a node and backtracks to its predecessor that it inserts
    the node into the sorted list, as shown in [Figure 9-6(d)](#fig9-6), where the
    search hits a dead end at node 5 and is forced to backtrack. Inserting a node
    into the inversely sorted list means that node must come after all nodes that
    preceded it in the search.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索从 [图9-6(a)](#fig9-6) 中的节点0开始，并在 [图9-6(b)](#fig9-6) 中探索节点2，[图9-6(c)](#fig9-6)
    中的节点4，以及 [图9-6(d)](#fig9-6) 中的节点5。在每个节点上，算法将节点标记为已访问，并递归地探索其未访问的邻居。直到搜索完成一个节点的处理并回溯到其前驱节点时，才将该节点插入到排序后的列表中，正如在
    [图9-6(d)](#fig9-6) 所示，搜索在节点5处遇到死胡同，并被迫回溯。将一个节点插入反向排序的列表意味着该节点必须位于所有先前被搜索的节点之后。
- en: '![Twelve steps of the depth-first search algorithm on a graph with directed
    edges (0, 2), (0, 3), (1, 3), (1, 4), (2, 4), (3, 4), and (4, 5). In (D), nodes
    0, 2, 4, and 5 are grayed out with node 5 circled. In (E), node 4 is circled and
    the list s now includes 5.](../images/f09006.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![带有有向边（0, 2），（0, 3），（1, 3），（1, 4），（2, 4），（3, 4）和（4, 5）的图的深度优先搜索算法的十二个步骤。在(D)中，节点0、2、4和5被灰色标出，节点5被圈出。在(E)中，节点4被圈出，列表s现在包含了5。](../images/f09006.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-6: Running a depth-first
    search for topological sort on an example graph</samp>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-6：在示例图上运行深度优先搜索以进行拓扑排序</samp>
- en: As the search backtracks through node 4 in [Figure 9-6(e)](#fig9-6) and node
    2 in [Figure 9-6(f)](#fig9-6), it checks for other outgoing edges. Finding none,
    it adds the current node to the list and backtracks. When it returns to node 0
    in [Figure 9-6(g)](#fig9-6), the depth-first search can continue before backtracking
    once more. It recursively explores node 3 in [Figure 9-6(h)](#fig9-6).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当搜索回溯到[图9-6(e)](#fig9-6)中的节点4和[图9-6(f)](#fig9-6)中的节点2时，它会检查是否有其他的出边。若没有，它将当前节点添加到列表中并回溯。当它返回到[图9-6(g)](#fig9-6)中的节点0时，深度优先搜索可以继续进行，然后再次回溯。它递归地探索[图9-6(h)](#fig9-6)中的节点3。
- en: As shown in [Figure 9-6(j)](#fig9-6), we might not be done after our initial
    depth-first search completes. Node 1 did not lie on any paths out of node 0 and
    thus has not been explored. The search continues by checking whether all the nodes
    have been seen and, if not, starting a depth-first search from that unseen node.
    At the end of the algorithm, the search has visited all nodes and assembled a
    list of nodes in inverse topological order, as shown in [Figure 9-6(l)](#fig9-6).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图9-6(j)](#fig9-6)所示，在初始深度优先搜索完成后，我们可能还没有结束。节点1不在从节点0出去的任何路径上，因此尚未被探索。搜索继续进行，通过检查所有节点是否都已被访问，如果没有，则从那个未被访问的节点开始深度优先搜索。在算法结束时，搜索已访问所有节点，并按照逆拓扑顺序列出了节点，如[图9-6(l)](#fig9-6)所示。
- en: We can picture this search in the context of a college student planning out
    a series of courses to take. They list the courses they want to take as nodes
    in a graph and use directed edges to represent the prerequisites. The depth-first
    search starts at a node with the question, “What courses will this course allow
    me to take?” When the search reaches a dead end, the student knows they have found
    a course that is not a prerequisite for anything else in their curriculum
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个搜索过程想象成一个大学生规划要修的系列课程。他们将要修的课程列为图中的节点，并使用有向边表示课程的先修关系。深度优先搜索从一个节点开始，询问：“这门课程会让我修哪些课程？”当搜索到死胡同时，学生就知道他们找到了一个没有任何课程作为先修的课程。
- en: Returning to the course list in [Figure 9-4](#fig9-4), consider what happens
    when the student starts with CS200 and follows the path through CS350 to CS450\.
    CS450 is fully explored, so they turn to their list of unexplored courses. The
    student returns to CS350, which is not a prerequisite for any other classes, and
    adds it to the list. Ultimately, they build up the list [CS450, CS350, CS300,
    CS201, CS200]. They continue to the next unvisited course (perhaps CS100 in this
    case) and continue building out their study plan.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到[图9-4](#fig9-4)中的课程列表，考虑一下当学生从CS200开始并沿着路径通过CS350到CS450时会发生什么。CS450已经完全探索过，因此他们转向未探索的课程列表。学生返回到CS350，它不是任何其他课程的先修课程，并将其添加到列表中。最终，他们建立了[CS450,
    CS350, CS300, CS201, CS200]的列表。然后他们继续访问下一个未访问的课程（可能是CS100），并继续完善他们的学习计划。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Order of Starting
    Nodes</samp>
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">起始节点的顺序</samp>
- en: One counterintuitive aspect of the depth-first search approach to topological
    sort is that the <samp class="SANS_TheSansMonoCd_W5Regular_11">topological_dfs()</samp>
    base function in [Listing 9-2](#list9-2) starts the recursive searches on each
    node according to that node’s index in the graph. It does not bother to sort the
    nodes according to number of incoming edges or any other aspect of its location.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索方法在拓扑排序中的一个反直觉之处在于，<samp class="SANS_TheSansMonoCd_W5Regular_11">topological_dfs()</samp>基函数在[清单9-2](#list9-2)中根据图中每个节点的索引开始递归搜索。它不会根据节点的入边数或其他任何位置特征对节点进行排序。
- en: This leads to cases where the search might begin at a node that has incoming
    edges, as with the graph in [Figure 9-7](#fig9-7). After all, we naturally think
    of depth-first search as starting at the beginning of a chain of nodes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就导致了搜索可能从一个有入边的节点开始的情况，就像[图9-7](#fig9-7)中的图一样。毕竟，我们自然地认为深度优先搜索是从节点链的起点开始的。
- en: '![A graph with four nodes and three edges: (1, 0), (0,2), and (3, 2)](../images/f09007.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含四个节点和三条边的图：（1，0），（0，2）和（3，2）](../images/f09007.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-7: A graph where node
    0 has an incoming connection</samp>'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-7：一个图，其中节点0有一个入边连接</samp>
- en: Fortunately, depth-first search works perfectly well in situations where node
    0 is not the start of the topological ordering. In [Figure 9-7](#fig9-7), the
    depth-first search algorithm will start at node 0 and find nodes 0 and 2 in the
    initial recursive depth-first search. At the end of the first recursive depth-first
    search, the list containing the reversed ordering is <samp class="SANS_TheSansMonoCd_W5Regular_11">[2,
    0]</samp>. While it may seem like we are making an error in skipping node 1, we
    will add it to the correct location during the next search.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，深度优先搜索在节点0不是拓扑排序起点的情况下仍然能够完美工作。在[图9-7](#fig9-7)中，深度优先搜索算法将从节点0开始，并在初始递归深度优先搜索中找到节点0和节点2。在第一次递归深度优先搜索结束时，包含反向排序的列表为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[2, 0]</samp>。虽然看起来我们在跳过节点1时犯了一个错误，但我们将在下一次搜索中将其添加到正确的位置。
- en: The algorithm next starts a search at node 1 and adds that to the end of the
    list. Since the list is in *reverse* topological ordering, node 1 is in the correct
    location *after* node 0\. After the search starts at node 1, the list is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">[2, 0, 1]</samp>. After starting at node
    3, the list becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">[2, 0, 1, 3]</samp>.
    When the function concludes, it reverses the list using Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">reverse()</samp>
    function and returns the correct ordering <samp class="SANS_TheSansMonoCd_W5Regular_11">[3,
    1, 0, 2]</samp>.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，算法从节点1开始搜索，并将其添加到列表的末尾。由于列表是*反向*拓扑排序的，节点1在节点0之后的位置是正确的。在从节点1开始搜索后，列表变为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[2, 0, 1]</samp>。当从节点3开始搜索时，列表变为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[2, 0, 1, 3]</samp>。当函数结束时，它使用Python的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">reverse()</samp>函数反转列表，并返回正确的排序<samp class="SANS_TheSansMonoCd_W5Regular_11">[3,
    1, 0, 2]</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Detecting Cycles</samp>
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">检测环路</samp>
- en: 'As noted earlier, a key constraint of topological sort is that the graph must
    be acyclic. Consider the hypothetical course sequence shown in [Figure 9-8](#fig9-8).
    All students must begin by taking CS100: Introduction to Programming, which has
    no prerequisites. However, things get more complex in the next semester. In an
    attempt to cover more material, the instructor of CS200: Introduction to Algorithms
    wants their students to know both programming and the basics of graphs. They require
    both CS100 and CS202: Introduction to Graphs as prerequisites. At the same time,
    the instructor for CS202 wants their students to know data structures, so they
    require CS201: Introduction to Data Structures as a prerequisite. Unfortunately,
    the instructor for CS201 wants their students to already know basic algorithms,
    so they require CS200 as a prerequisite.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，拓扑排序的一个关键限制是图必须是无环的。考虑[图9-8](#fig9-8)所示的假设课程顺序。所有学生必须首先选修CS100：编程导论，该课程没有先决条件。然而，下一学期情况变得更加复杂。为了覆盖更多的内容，CS200：算法导论的讲师希望学生掌握编程和图的基础知识。因此，他们要求CS100和CS202：图论导论作为先修课程。同时，CS202的讲师要求学生掌握数据结构，因此要求CS201：数据结构导论作为先修课程。不幸的是，CS201的讲师希望学生已经掌握基本算法，因此他们要求CS200作为先修课程。
- en: '![Five boxes represent different computer science classes. The box for “CS200:
    Introduction to algorithms” lists prerequisites CS100 and CS202 and has incoming
    arrows from both of those boxes.](../images/f09008.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![五个框代表不同的计算机科学课程。“CS200：算法导论”的框列出了先修课程CS100和CS202，并从这两个框有指向的箭头。](../images/f09008.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-8: A set of course
    prerequisites with a cycle</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-8：带有环路的课程先修关系</samp>
- en: When a student completes CS100, they look at the courses they can now take and
    run into a problem. Each of the 200 level courses requires a different 200 level
    course as a prerequisite. There are no 200 level courses the student can take
    without missing a prerequisite.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当学生完成CS100后，他们查看自己现在可以修的课程，并遇到一个问题。每一门200级课程都要求另一门不同的200级课程作为先修课程。学生没有可以修的200级课程，而不需要先修其他课程。
- en: We can adapt the algorithms presented in this chapter to detect whether a graph
    has cycles, providing a useful tool for vetting school requirements, instruction
    manuals, recipes, or any other graph representation of a sequence of events. One
    easy approach to doing this is to look at what happens when we run Kahn’s algorithm
    from [Listing 9-1](#list9-1) on a graph with cycles. This algorithm relies on
    incoming connections dropping to zero when it has removed all the preceding nodes.
    To remove a node that is part of a cycle, the algorithm would first need to remove
    its predecessors, including the node itself. Thus, the count for a node in a cycle
    will never drop to zero, and the node will never be added to the sorted list.
    We therefore know that if the algorithm’s returned list does not contain all the
    nodes from the graph, at least one node must be part of a cycle and thus be unremovable.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调整本章中介绍的算法来检测图中是否存在循环，这为审核学校要求、使用手册、食谱或任何其他表示事件序列的图形提供了有用的工具。一种简单的方法是观察当我们在有循环的图上运行[列表
    9-1](#list9-1)的Kahn算法时会发生什么。该算法依赖于当它移除所有前置节点后，输入连接数降至零。为了移除一个属于循环的节点，该算法首先需要移除它的前驱节点，包括该节点本身。因此，循环中的节点的计数永远不会降至零，该节点也永远不会被加入到排序列表中。因此，我们知道，如果算法返回的列表不包含图中的所有节点，至少有一个节点必须是循环的一部分，因此无法移除。
- en: 'We wrap Kahn’s algorithm in a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">check_cycle_kahns()</samp>:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将Kahn算法封装在一个名为<samp class="SANS_TheSansMonoCd_W5Regular_11">check_cycle_kahns()</samp>的函数中：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code for this check requires one additional <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement to test the length of the returned list. If the list is the same size
    as the graph, the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    to indicate no cycles. Otherwise, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此检查的代码需要一个额外的<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句来测试返回列表的长度。如果列表的大小与图相同，则代码返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>表示没有循环。否则，返回<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reordering Lists</samp>
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">重新排序列表</samp>
- en: 'Let’s consider a task that uses *topological sort*: reordering a list of items
    with forward dependencies. As an example, we’ll use topological sort to carry
    out the practical task of sorting the pages of a choose-your-own-adventure book
    so that you never need to flip backward.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个使用*拓扑排序*的任务：重新排序一个具有前向依赖关系的项目列表。作为示例，我们将使用拓扑排序来完成一个实际任务：对选择你自己冒险书的页面进行排序，以便你永远不需要翻回去。
- en: 'As shown in [Figure 9-9](#fig9-9), we can visualize a choose-your-own-adventure
    book with *N* pages as a graph with *N* nodes. Because the reader must turn most
    pages consecutively to follow individual storylines, the corresponding nodes for
    most pages have one incoming edge from the previous page and one outgoing edge
    to the next page. However, what makes these books exciting are the decision points.
    [Figure 9-9](#fig9-9) shows transitions around page *k*. The reader has two options:
    they can either turn to page *i* to explore the haunted house or turn to page
    *j* to climb the rain-soaked cliffs.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 9-9](#fig9-9)所示，我们可以将一个包含*N*页的选择你自己冒险书籍可视化为一个具有*N*节点的图。由于读者必须大部分连续翻页才能跟随各个故事情节，因此大多数页面的对应节点都有一个来自上一页的输入边和一个指向下一页的输出边。然而，使这些书籍充满趣味的是决策点。[图
    9-9](#fig9-9)展示了围绕页面*k*的过渡。读者有两个选择：他们可以翻到页面*i*去探索鬼屋，或者翻到页面*j*去攀爬被雨水浸湿的悬崖。
- en: '![A linear graph. Node k has an incoming edge from node K-1 and outgoing edges
    to nodes i and j.](../images/f09009.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![一个线性图。节点k有来自节点K-1的输入边和指向节点i和j的输出边。](../images/f09009.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-9: A graph representing
    a choose-your-own-adventure book in page order</samp>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-9：表示选择你自己冒险书籍的页面顺序的图表</samp>
- en: Topological sort allows us to rearrange the pages into story order, as shown
    in [Figure 9-10](#fig9-10). The story starts on page 1\. The narrative paths progress
    from left to right. They branch off at decision points, with some decisions leading
    to an unfortunate early end (represented by shaded nodes).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑排序使我们能够将页面重新排列为故事顺序，如[图 9-10](#fig9-10)所示。故事从第 1 页开始。叙事路径从左到右延伸。在决策点处，它们会分支开来，其中一些决定导致了不幸的早期结局（由阴影节点表示）。
- en: '![A graph with all edges moving to the node on the right, with decision points
    branching to higher or lower lines of nodes.](../images/f09010.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![一个所有边都指向右侧节点的图，决策点分支到更高或更低的节点行。](../images/f09010.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-10: Reorganizing the
    book into story order</samp>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-10：将书籍重新组织为故事顺序</samp>
- en: We can use the two algorithms in this chapter to do the sorting for us. As input,
    we take a list of lists that maps each page to its corresponding options. The
    list <samp class="SANS_TheSansMonoCd_W5Regular_11">[[1], [3, 4], [-1], [-1], [2]]</samp>
    represents a five-page story with the index in the list corresponding to the current
    page. Page 0 leads deterministically to page 1\. Page 1 has an option to proceed
    to page 3 or 4\. Both pages 2 and 3 represent the end of the story (as represented
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>). Finally, page 4 leads
    deterministically back to page 2.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用本章中的两种算法来为我们排序。作为输入，我们获取一个列表的列表，该列表将每一页映射到其对应的选项。列表 <samp class="SANS_TheSansMonoCd_W5Regular_11">[[1],
    [3, 4], [-1], [-1], [2]]</samp> 表示一个五页的故事，列表中的索引对应当前页面。页面 0 确定性地指向页面 1。页面 1 有一个选项可以继续到页面
    3 或 4。页面 2 和 3 都表示故事的结束（由 <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    表示）。最后，页面 4 确定性地返回页面 2。
- en: '[Listing 9-3](#list9-3) shows the code to sort the story by transforming the
    list into a graph and, for the purposes of this example, calling Kahn’s algorithm.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 9-3](#list9-3) 显示了通过将列表转换为图形来排序故事的代码，并且为了本示例的目的，调用了 Kahn 算法。'
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-3: Sorting forward
    pointers</samp>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-3：排序前向指针</samp>
- en: The code creates a graph with one node for each page. It then uses one <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to iterate through each
    page and a second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    to iterate through the outgoing options for that page. It checks whether the page
    represents a terminal state (<samp class="SANS_TheSansMonoCd_W5Regular_11">next_index</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>);
    if not, the code adds an edge to the following page in story order. Finally, the
    code calls Kahn’s algorithm to perform the topological sort and returns the result
    ❶. (Alternatively, the code could use <samp class="SANS_TheSansMonoCd_W5Regular_11">topological_dfs()</samp>
    from [Listing 9-2](#list9-2).)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 代码为每一页创建一个节点。然后，使用一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环迭代每一页，第二个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环迭代该页的所有外部选项。它检查该页是否表示终结状态（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">next_index</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>）；如果不是，代码会向故事顺序中的下一页添加一条边。最后，代码调用
    Kahn 算法来执行拓扑排序并返回结果 ❶。（或者，代码可以使用 [Listing 9-2](#list9-2) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">topological_dfs()</samp>。）
- en: As an example implementation of this code, let’s apply it to the 10-page adventure
    shown in [Figure 9-11](#fig9-11).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 作为该代码的示例实现，我们将其应用于 [图 9-11](#fig9-11) 中显示的 10 页冒险故事。
- en: '![A graph with 10 nodes and edges (0,1), (1, 2), (2, 4), (2, 6), (6, 7), (4,
    5), (5, 3), (5, 8), (8, 9). Nodes 3, 7, and 9 are shaded.](../images/f09011.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含 10 个节点和边 (0,1)，(1, 2)，(2, 4)，(2, 6)，(6, 7)，(4, 5)，(5, 3)，(5, 8)，(8,
    9) 的图。节点 3、7 和 9 被阴影标记。](../images/f09011.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-11: A story graph
    with 10 pages</samp>'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-11：一个包含 10 页的故事图</samp>
- en: 'We represent the options as a list of lists, with option <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    indicating the end of a narrative line, whether it’s a positive or negative conclusion:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选项表示为列表的列表，选项 <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> 表示叙事线的结束，无论它是积极还是消极的结局：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[[1], [2], [4, 6], [-1], [5],
    [3, 8], [7], [-1], [9], [-1]]</samp>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">[[1], [2], [4, 6], [-1], [5],
    [3, 8], [7], [-1], [9], [-1]]</samp>
- en: 'When we run the input through the <samp class="SANS_TheSansMonoCd_W5Regular_11">sort_forward_pointers()</samp>
    function from [Listing 9-2](#list9-2), the code returns the following ordering:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过 [Listing 9-2](#list9-2) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">sort_forward_pointers()</samp>
    函数运行输入时，代码返回以下排序：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[0, 1, 2, 6, 7, 4, 5, 8, 9, 3]</samp>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">[0, 1, 2, 6, 7, 4, 5, 8, 9, 3]</samp>
- en: Comparing this result to [Figure 9-11](#fig9-11), we can see that if we were
    to reorder the pages to begin with page 0, then turn to pages 1, 2, 6, and so
    on, we would never need to flip backward while following a narrative line.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个结果与[图9-11](#fig9-11)进行比较，我们可以看到，如果我们将页面顺序重新排列，从第0页开始，接着翻到第1、2、6页，以此类推，那么在跟随叙事线的过程中，我们就不需要向后翻页。
- en: While sorting choose-your-own-adventure books might not be a typical problem
    you need to handle in your everyday workflow, it’s easy to extrapolate from this
    example and apply the same techniques to other use cases. You can simply construct
    dependency graphs from either forward pointers (for choose-your-own-adventure
    books or recipes) or backward pointers (course prerequisites or code dependencies).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然排序选择自己冒险故事书可能不是你在日常工作流程中需要处理的典型问题，但很容易从这个例子中推断，并将相同的技巧应用于其他使用场景。你可以简单地从正向指针（例如选择自己冒险故事书或食谱）或反向指针（如课程先修条件或代码依赖关系）构建依赖图。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为什么这很重要</samp>
- en: Topological sort demonstrates how to use directed edges in graphs to enforce
    more abstract constraints like the ordering of items. We can transform a range
    of dependency and ordering problems into graphs by modeling the items as nodes
    and the dependency between them as directed edges.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑排序展示了如何使用图中的有向边来强制执行更抽象的约束条件，比如物品的顺序。我们可以通过将物品建模为节点，将它们之间的依赖关系建模为有向边，将一系列依赖和排序问题转化为图。
- en: As shown throughout the chapter, topological sort has a range of real-world
    use cases. We often perform topological sort in our day-to-day lives without even
    realizing it. Before we brew coffee, we fill the kettle with water. We know the
    correct series of steps for this particular operation without needing to represent
    it as a graph, of course. However, transforming topological sort into a graph
    problem greatly scales up the types of problems we can solve using this algorithm.
    Compilers can use topological sort to determine the order in which to compile
    thousands of source files in a project, for example. Cloud-based workflow systems
    can likewise use it to determine which computation to perform next. Once you start
    looking for it, topological sort arises throughout both the computational and
    everyday domains. Knowing how to model such problems and sort the tasks is the
    first step in implementing efficient solutions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章所示，拓扑排序在现实世界中有一系列的应用场景。我们在日常生活中常常不自觉地执行拓扑排序。在我们煮咖啡之前，我们会先往水壶里加水。我们知道这一系列操作的正确顺序，当然也无需将其表示为图。然而，将拓扑排序转化为图问题，可以大大扩展我们能够使用该算法解决的问题类型。例如，编译器可以使用拓扑排序来确定在一个项目中编译数千个源文件的顺序。基于云的工作流系统也可以使用拓扑排序来确定下一步执行的计算。一旦你开始注意它，拓扑排序就在计算领域和日常生活中随处可见。知道如何建模这些问题并排序任务，是实施高效解决方案的第一步。
- en: The next chapter considers connectivity within graphs and how to choose a subset
    of edges that makes the graph fully connected. Specifically, we examine the problem
    of finding the minimum cost set of edges that connect all of the nodes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论图中的连通性，以及如何选择一组边使得图完全连通。具体来说，我们将研究如何找到一组最小成本的边，使得所有节点都能连接。
