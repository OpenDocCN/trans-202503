- en: Chapter 48. System V Shared Memory
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 48 章. System V 共享内存
- en: This chapter describes System V shared memory. Shared memory allows two or more
    processes to share the same region (usually referred to as a *segment*) of physical
    memory. Since a shared memory segment becomes part of a process’s user-space memory,
    no kernel intervention is required for IPC. All that is required is that one process
    copies data into the shared memory; that data is immediately available to all
    other processes sharing the same segment. This provides fast IPC by comparison
    with techniques such as pipes or message queues, where the sending process copies
    data from a buffer in user space into kernel memory and the receiving process
    copies in the reverse direction. (Each process also incurs the overhead of a system
    call to perform the copy operation.)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了 System V 共享内存。共享内存允许两个或更多进程共享相同的物理内存区域（通常称为*段*）。由于共享内存段成为进程用户空间内存的一部分，因此不需要内核干预进行进程间通信。所需的唯一操作是一个进程将数据复制到共享内存中；这些数据会立即对所有共享相同段的其他进程可用。与管道或消息队列等技术相比，这种方法提供了快速的进程间通信，因为在管道或消息队列中，发送进程需要将数据从用户空间的缓冲区复制到内核内存中，而接收进程则需要执行反向复制。（每个进程还需要执行系统调用来执行复制操作。）
- en: On the other hand, the fact that IPC using shared memory is not mediated by
    the kernel means that, typically, some method of synchronization is required so
    that processes don’t simultaneously access the shared memory (e.g., two processes
    performing simultaneous updates, or one process fetching data from the shared
    memory while another process is in the middle of updating it). System V semaphores
    are a natural method for such synchronization. Other methods, such as POSIX semaphores
    ([Chapter 53](ch53.html "Chapter 53. POSIX Semaphores")) and file locks ([Chapter 55](ch55.html
    "Chapter 55. File Locking")), are also possible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用共享内存的进程间通信（IPC）不经过内核调度，这意味着通常需要某种同步方法，以防止进程同时访问共享内存（例如，两个进程同时进行更新，或一个进程在另一个进程更新共享内存时从中读取数据）。System
    V 信号量是进行此类同步的自然方法。其他方法，如 POSIX 信号量（[第 53 章](ch53.html "第 53 章. POSIX 信号量)") 和文件锁（[第
    55 章](ch55.html "第 55 章. 文件锁)")，也是可行的。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: In *mmap()* terminology, a memory region is *mapped* at an address, while in
    System V terminology, a shared memory segment is *attached* at an address. These
    terms are equivalent; the terminology differences are a consequence of the separate
    origins of these two APIs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在*mmap()*术语中，内存区域是在某个地址上*映射*的，而在 System V 术语中，共享内存段是在某个地址上*附加*的。这些术语是等效的，术语差异源于这两个
    API 的不同起源。
- en: Overview
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'In order to use a shared memory segment, we typically perform the following
    steps:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用共享内存段，通常需要执行以下步骤：
- en: Call *shmget()* to create a new shared memory segment or obtain the identifier
    of an existing segment (i.e., one created by another process). This call returns
    a shared memory identifier for use in later calls.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用*shmget()*来创建一个新的共享内存段，或获取现有段的标识符（即，其他进程创建的段）。此调用返回一个共享内存标识符，以供后续调用使用。
- en: Use *shmat()* to *attach* the shared memory segment; that is, make the segment
    part of the virtual memory of the calling process.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*shmat()*来*附加*共享内存段；即使该段成为调用进程虚拟内存的一部分。
- en: At this point, the shared memory segment can be treated just like any other
    memory available to the program. In order to refer to the shared memory, the program
    uses the *addr* value returned by the *shmat()* call, which is a pointer to the
    start of the shared memory segment in the process’s virtual address space.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此时，共享内存段可以像程序中的任何其他内存一样进行处理。为了引用共享内存，程序使用*shmat()*调用返回的*addr*值，该值是进程虚拟地址空间中指向共享内存段开始处的指针。
- en: Call *shmdt()* to detach the shared memory segment. After this call, the process
    can no longer refer to the shared memory. This step is optional, and happens automatically
    on process termination.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用*shmdt()*来分离共享内存段。调用此函数后，进程将无法再引用共享内存。此步骤是可选的，并且在进程终止时会自动执行。
- en: Call *shmctl()* to delete the shared memory segment. The segment will be destroyed
    only after all currently attached processes have detached it. Only one process
    needs to perform this step.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用*shmctl()*来删除共享内存段。该段只有在所有当前附加的进程都已分离它之后才会被销毁。只有一个进程需要执行此步骤。
- en: Creating or Opening a Shared Memory Segment
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建或打开共享内存段
- en: The *shmget()* system call creates a new shared memory segment or obtains the
    identifier of an existing segment. The contents of a newly created shared memory
    segment are initialized to 0.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*shmget()*系统调用创建一个新的共享内存段或获取现有段的标识符。新创建的共享内存段的内容会初始化为0。'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns shared memory segment identifier on success, or -1 on error
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回共享内存段标识符，出错时返回-1。
- en: The *key* argument is a key generated using one of the methods described in
    [IPC Keys](ch45.html#ipc_keys "IPC Keys") (i.e., usually the value `IPC_PRIVATE`
    or a key returned by *ftok()*).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*key* 参数是使用[IPC Keys](ch45.html#ipc_keys "IPC Keys")中描述的某种方法生成的密钥（即，通常是`IPC_PRIVATE`值或*ftok()*返回的密钥）。'
- en: When we use *shmget()* to create a new shared memory segment, *size* specifies
    a positive integer that indicates the desired size of the segment, in bytes. The
    kernel allocates shared memory in multiples of the system page size, so *size*
    is effectively rounded up to the next multiple of the system page size. If we
    are using *shmget()* to obtain the identifier of an existing segment, then *size*
    has no effect on the segment, but it must be less than or equal to the size of
    the segment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用*shmget()*创建一个新的共享内存段时，*size*指定一个正整数，表示段的期望大小，以字节为单位。内核以系统页面大小的倍数分配共享内存，因此*size*实际上会向上舍入为系统页面大小的下一个倍数。如果我们使用*shmget()*获取一个现有段的标识符，则*size*对段没有影响，但它必须小于或等于该段的大小。
- en: 'The *shmflg* argument performs the same task as for the other IPC *get* calls,
    specifying the permissions ([Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"), in [Permissions on Regular
    Files](ch15.html#permissions_on_regular_files "Permissions on Regular Files"))
    to be placed on a new shared memory segment or checked against an existing segment.
    In addition, zero or more of the following flags can be ORed (|) in *shmflg* to
    control the operation of *shmget()*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*shmflg*参数执行与其他IPC *get*调用相同的任务，指定新共享内存段的权限（[表 15-4](ch15.html#constants_for_file_permission_bits
    "表 15-4. 文件权限常量")，见[常规文件的权限](ch15.html#permissions_on_regular_files "常规文件的权限")），或者检查现有段的权限。此外，零个或多个以下标志可以与*shmflg*通过OR（|）运算结合，以控制*shmget()*的操作：'
- en: '`IPC_CREAT`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_CREAT`'
- en: If no segment with the specified *key* exists, create a new segment.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的*key*没有对应的共享内存段，则创建一个新的共享内存段。
- en: '`IPC_EXCL`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_EXCL`'
- en: If `IPC_CREAT` was also specified, and a segment with the specified *key* already
    exists, fail with the error `EEXIST`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果也指定了`IPC_CREAT`，且指定的*key*已经存在，则返回错误`EEXIST`。
- en: 'The above flags are described in more detail in Section 45.1\. In addition,
    Linux permits the following nonstandard flags:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述标志在45.1节中有更详细的描述。此外，Linux还允许以下非标准标志：
- en: '`SHM_HUGETLB` (since Linux 2.6)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHM_HUGETLB`（自Linux 2.6起）'
- en: A privileged (`CAP_IPC_LOCK`) process can use this flag to create a shared memory
    segment that uses *huge pages*. Huge pages are a feature provided by many modern
    hardware architectures to manage memory using very large page sizes. (For example,
    x86-32 allows 4-MB pages as an alternative to 4-kB pages.) On systems that have
    large amounts of memory, and where applications require large blocks of memory,
    using huge pages reduces the number of entries required in the hardware memory
    management unit’s translation look-aside buffer (TLB). This is beneficial because
    entries in the TLB are usually a scarce resource. See the kernel source file `Documentation/vm/hugetlbpage.txt`
    for further information.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特权 (`CAP_IPC_LOCK`) 进程可以使用此标志来创建一个使用*大页*的共享内存段。大页是许多现代硬件架构提供的一项功能，旨在通过使用非常大的页面大小来管理内存。（例如，x86-32允许使用4-MB页面作为4-kB页面的替代。）在具有大量内存的系统上，且应用程序需要大块内存时，使用大页可以减少硬件内存管理单元的转换后备缓冲区（TLB）中所需的条目数。这是有益的，因为TLB中的条目通常是稀缺资源。有关更多信息，请参见内核源文件`Documentation/vm/hugetlbpage.txt`。
- en: '`SHM_NORESERVE` (since Linux 2.6.15)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHM_NORESERVE`（自Linux 2.6.15起）'
- en: This flag serves the same purpose for *shmget()* as the `MAP_NORESERVE` flag
    serves for *mmap()*. See Section 49.9.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志在*shmget()*中与`MAP_NORESERVE`标志在*mmap()*中的作用相同。参见49.9节。
- en: On success, *shmget()* returns the identifier for the new or existing shared
    memory segment.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，*shmget()*返回新创建或现有共享内存段的标识符。
- en: Using Shared Memory
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用共享内存
- en: The *shmat()* system call attaches the shared memory segment identified by *shmid*
    to the calling process’s virtual address space.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*shmat()*系统调用将由*shmid*标识的共享内存段附加到调用进程的虚拟地址空间。'
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns address at which shared memory is attached on success, or *(void *)*
    -1 on error
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回附加的共享内存地址，出错时返回 *(void *)* -1。
- en: 'The *shmaddr* argument and the setting of the `SHM_RND` bit in the *shmflg*
    bit-mask argument control how the segment is attached:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*shmaddr* 参数和 `SHM_RND` 位在 *shmflg* 位掩码参数中的设置控制着段如何附加：'
- en: If *shmaddr* is `NULL`, then the segment is attached at a suitable address selected
    by the kernel. This is the preferred method of attaching a segment.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *shmaddr* 是 `NULL`，则段会附加在内核选择的合适地址处。这是附加段的首选方法。
- en: If *shmaddr* is not `NULL`, and `SHM_RND` is not set, then the segment is attached
    at the address specified by *shmaddr*, which must be a multiple of the system
    page size (or the error `EINVAL` results).
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *shmaddr* 不是 `NULL`，并且没有设置 `SHM_RND`，则段将在 *shmaddr* 指定的地址附加，该地址必须是系统页面大小的倍数（否则会返回
    `EINVAL` 错误）。
- en: If *shmaddr* is not `NULL`, and `SHM_RND` is set, then the segment is mapped
    at the address provided in *shmaddr*, rounded down to the nearest multiple of
    the constant `SHMLBA` (*shared memory low boundary address*). This constant is
    equal to some multiple of the system page size. Attaching a segment at an address
    that is a multiple of `SHMLBA` is necessary on some architectures in order to
    improve CPU cache performance and to prevent the possibility that different attaches
    of the same segment have inconsistent views within the CPU cache.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *shmaddr* 不是 `NULL`，并且设置了 `SHM_RND`，那么段将在 *shmaddr* 提供的地址处附加，并向下舍入到常量 `SHMLBA`
    (*共享内存低边界地址*) 的最接近倍数。该常量等于系统页面大小的某个倍数。在某些架构上，为了提高CPU缓存性能并防止同一段的不同附加在CPU缓存中具有不一致的视图，必须在
    `SHMLBA` 的倍数地址上附加段。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On the x86 architectures, `SHMLBA` is the same as the system page size, reflecting
    the fact that such caching inconsistencies can’t arise on those architectures.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86架构上，`SHMLBA`与系统页面大小相同，反映出在这些架构上不会出现这种缓存不一致的情况。
- en: 'Specifying a non-`NULL` value for *shmaddr* (i.e., either the second or third
    option listed above) is not recommended, for the following reasons:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为 *shmaddr* 指定一个非`NULL`值（即上面列出的第二或第三个选项）并不推荐，原因如下：
- en: It reduces the portability of an application. An address valid on one UNIX implementation
    may be invalid on another.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它降低了应用程序的可移植性。在一种UNIX实现上有效的地址可能在另一种实现上无效。
- en: An attempt to attach a shared memory segment at a particular address will fail
    if that address is already in use. This could happen if, for example, the application
    (perhaps inside a library function) had already attached another segment or created
    a memory mapping at that address.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果尝试在某个特定地址附加共享内存段，而该地址已被占用，则附加会失败。例如，如果应用程序（可能在库函数内部）已经在该地址附加了另一个段或创建了内存映射，则可能会发生这种情况。
- en: As its function result, *shmat()* returns the address at which the shared memory
    segment is attached. This value can be treated like a normal C pointer; the segment
    looks just like any other part of the process’s virtual memory. Typically, we
    assign the return value from *shmat()* to a pointer to some programmer-defined
    structure, in order to impose that structure on the segment (see, for example,
    [Example 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a "Example 48-2. Transfer
    blocks of data from stdin to a System V shared memory segment")).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其函数结果，*shmat()* 返回共享内存段附加的地址。这个值可以像普通的C指针一样处理；该段看起来就像进程虚拟内存中的任何其他部分。通常，我们将
    *shmat()* 的返回值赋给一个指向程序员定义的结构体的指针，以便将该结构体施加到该段上（例如，参见 [示例 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a
    "示例 48-2. 从 stdin 传输数据块到 System V 共享内存段")）。
- en: To attach a shared memory segment for read-only access, we specify the flag
    `SHM_RDONLY` in *shmflg*. Attempts to update the contents of a read-only segment
    result in a segmentation fault (the `SIGSEGV` signal). If `SHM_RDONLY` is not
    specified, the memory can be both read and modified.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要附加一个只读访问的共享内存段，我们在 *shmflg* 中指定标志 `SHM_RDONLY`。尝试更新只读段的内容会导致段错误（`SIGSEGV`信号）。如果没有指定`SHM_RDONLY`，则内存既可以读取也可以修改。
- en: To attach a shared memory segment, a process requires read and write permissions
    on the segment, unless `SHM_RDONLY` is specified, in which case only read permission
    is required.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要附加共享内存段，进程需要对该段具有读写权限，除非指定了`SHM_RDONLY`，在这种情况下，只需要读权限。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to attach the same shared memory segment multiple times within
    a process, and even to make one attach read-only while another is read-write.
    The contents of the memory at each attachment point are the same, since the different
    entries of the process virtual memory page tables are referring to the same physical
    pages of memory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个进程中，可以多次附加同一个共享内存段，甚至可以让一个附加为只读，另一个附加为读写。每个附加点的内存内容都是相同的，因为进程虚拟内存页表中的不同条目指向相同的物理内存页。
- en: One final value that may be specified in *shmflg* is `SHM_REMAP`. In this case,
    *shmaddr* must be non-`NULL`. This flag requests that the *shmat()* call replace
    any existing shared memory attachment or memory mapping in the range starting
    at *shmaddr* and continuing for the length of the shared memory segment. Normally,
    if we try to attach a shared memory segment at an address range that is already
    in use, the error `EINVAL` results. `SHM_REMAP` is a nonstandard Linux extension.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以在*shmflg*中指定的值是`SHM_REMAP`。在这种情况下，*shmaddr*必须是非`NULL`。该标志请求*shmat()*调用替换从*shmaddr*开始并持续共享内存段长度范围内的任何现有共享内存附加或内存映射。通常，如果我们尝试在已经使用的地址范围附加共享内存段，会导致`EINVAL`错误。`SHM_REMAP`是一个非标准的
    Linux 扩展。
- en: '[Table 48-1](ch48.html#shmflg_bit-mask_values_for_shmat_open_pa "Table 48-1. shmflg
    bit-mask values for shmat()") summarizes the constants that can be ORed in the
    *shmflg* argument of *shmat()*.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 48-1](ch48.html#shmflg_bit-mask_values_for_shmat_open_pa "表 48-1. shmflg
    位掩码值")总结了可以在*shmat()*的*shmflg*参数中使用的常量。'
- en: When a process no longer needs to access a shared memory segment, it can call
    *shmdt()* to detach the segment from its virtual address space. The *shmaddr*
    argument identifies the segment to be detached. It should be a value returned
    by a previous call to *shmat()*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程不再需要访问共享内存段时，它可以调用*shmdt()*将该段从其虚拟地址空间中分离。*shmaddr*参数用于标识要分离的内存段。它应该是先前调用*shmat()*时返回的值。
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: Detaching a shared memory segment is not the same as deleting it. Deletion is
    performed using the *shmctl()* `IPC_RMID` operation, as described in Section 48.7.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 分离共享内存段与删除它不同。删除操作是通过*shmctl()*的`IPC_RMID`操作执行的，具体描述见第48.7节。
- en: A child created by *fork()* inherits its parent’s attached shared memory segments.
    Thus, shared memory provides an easy method of IPC between parent and child.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由*fork()*创建的子进程会继承父进程附加的共享内存段。因此，共享内存提供了一种父子进程之间进行 IPC 的简便方法。
- en: During an *exec()*, all attached shared memory segments are detached. Shared
    memory segments are also automatically detached on process termination.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在*exec()*过程中，所有附加的共享内存段都将被分离。进程终止时，共享内存段也会自动分离。
- en: Table 48-1. *shmflg* bit-mask values for *shmat()*
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表 48-1. *shmflg* 位掩码值（适用于*shmat()*)
- en: '| Value | Description |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SHM_RDONLY` | Attach segment read-only |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `SHM_RDONLY` | 以只读方式附加段 |'
- en: '| `SHM_REMAP` | Replace any existing mapping at *shmaddr* |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `SHM_REMAP` | 替换*shmaddr*处的任何现有映射 |'
- en: '| `SHM_RND` | Round *shmaddr* down to multiple of `SHMLBA` bytes |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `SHM_RND` | 将*shmaddr*向下舍入为`SHMLBA`字节的倍数 |'
- en: 'Example: Transferring Data via Shared Memory'
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：通过共享内存传输数据
- en: 'We now look at an example application that uses System V shared memory and
    semaphores. The application consists of two programs: the *writer* and the *reader*.
    The writer reads blocks of data from standard input and copies (“writes”) them
    into a shared memory segment. The reader copies (“reads”) blocks of data from
    the shared memory segment to standard output. In effect, the programs treat the
    shared memory somewhat like a pipe.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个使用 System V 共享内存和信号量的示例应用程序。该应用程序由两个程序组成：*writer*和*reader*。writer从标准输入读取数据块，并将其复制（“写入”）到共享内存段中。reader将共享内存段中的数据块复制（“读取”）到标准输出中。实际上，程序将共享内存当作管道使用。
- en: 'The two programs employ a pair of System V semaphores in a binary semaphore
    protocol (the *initSemAvailable()*, *initSemInUse()*, *reserveSem()*, and *releaseSem()*
    functions defined in [Implementing a Binary Semaphores Protocol](ch47.html#implementing_a_binary_semaphores_protoco
    "Implementing a Binary Semaphores Protocol")) to ensure that:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个程序使用一对 System V 信号量，在二进制信号量协议中（[实现二进制信号量协议](ch47.html#implementing_a_binary_semaphores_protoco
    "实现二进制信号量协议")中定义的*initSemAvailable()*, *initSemInUse()*, *reserveSem()*和*releaseSem()*函数）确保：
- en: only one process accesses the shared memory segment at a time; and
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个进程在任何时候访问共享内存段；并且
- en: the processes alternate in accessing the segment (i.e., the writer writes some
    data, then the reader reads the data, then the writer writes again, and so on).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程交替访问共享内存段（即，写入程序写入一些数据，然后读取程序读取这些数据，接着写入程序再次写入，以此类推）。
- en: '[Figure 48-1](ch48.html#using_semaphores_to_ensure_exclusive_com "Figure 48-1. Using
    semaphores to ensure exclusive, alternating access to shared memory") provides
    an overview of the use of these two semaphores. Note that the writer initializes
    the two semaphores so that it is the first of the two programs to be able to access
    the shared memory segment; that is, the writer’s semaphore is initially available,
    and the reader’s semaphore is initially in use.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 48-1](ch48.html#using_semaphores_to_ensure_exclusive_com "图 48-1. 使用信号量确保对共享内存的独占、交替访问")提供了这两个信号量使用的概览。请注意，写入程序初始化了这两个信号量，使得它可以是两个程序中第一个能够访问共享内存段的程序；也就是说，写入程序的信号量最初是可用的，而读取程序的信号量最初是正在使用中的。'
- en: The source code for the application consists of three files. The first of these,
    [Example 48-1](ch48.html#header_file_for_svshm_underscore_xfr_und "Example 48-1. Header
    file for svshm_xfr_writer.c and svshm_xfr_reader.c"), is a header file shared
    by the reader and writer programs. This header defines the *shmseg* structure
    that we use to declare pointers to the shared memory segment. Doing this allows
    us to impose a structure on the bytes of the shared memory segment.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的源代码由三个文件组成。其中第一个，[示例 48-1](ch48.html#header_file_for_svshm_underscore_xfr_und
    "示例 48-1. svshm_xfr_writer.c 和 svshm_xfr_reader.c 的头文件")，是一个被读取程序和写入程序共享的头文件。此头文件定义了我们用来声明指向共享内存段的指针的*shmseg*结构体。这样做使我们可以对共享内存段的字节施加结构。
- en: '![Using semaphores to ensure exclusive, alternating access to shared memory](figs/web/48-1_SVSHM-shm_xfr.png.jpg)Figure 48-1. Using
    semaphores to ensure exclusive, alternating access to shared memoryExample 48-1. Header
    file for `svshm_xfr_writer.c` and `svshm_xfr_reader.c`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用信号量确保对共享内存的独占、交替访问](figs/web/48-1_SVSHM-shm_xfr.png.jpg)图 48-1. 使用信号量确保对共享内存的独占、交替访问示例
    48-1. `svshm_xfr_writer.c` 和 `svshm_xfr_reader.c` 的头文件'
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Example 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a "Example 48-2. Transfer
    blocks of data from stdin to a System V shared memory segment") is the writer
    program. This program performs the following steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a "示例 48-2. 从标准输入传输数据块到
    System V 共享内存段")是写入程序。此程序执行以下步骤：'
- en: Create a set containing the two semaphores that are used by the writer and reader
    program to ensure that they alternate in accessing the shared memory segment ![](figs/web/U001.png).
    The semaphores are initialized so that the writer has first access to the shared
    memory segment. Since the writer creates the semaphore set, it must be started
    before the reader.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含写入程序和读取程序使用的两个信号量的集合，以确保它们交替访问共享内存段 ![](figs/web/U001.png)。这些信号量被初始化，使得写入程序可以首先访问共享内存段。由于写入程序创建了信号量集合，它必须在读取程序之前启动。
- en: Create the shared memory segment and attach it to the writer’s virtual address
    space at an address chosen by the system ![](figs/web/U002.png).
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建共享内存段并将其附加到写入程序的虚拟地址空间，地址由系统选择 ![](figs/web/U002.png)。
- en: 'Enter a loop that transfers data from standard input to the shared memory segment
    ![](figs/web/U003.png). The following steps are performed in each loop iteration:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入一个循环，将数据从标准输入传输到共享内存段 ![](figs/web/U003.png)。在每次循环迭代中执行以下步骤：
- en: Reserve (decrement) the writer semaphore ![](figs/web/U004.png).
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留（递减）写入程序的信号量 ![](figs/web/U004.png)。
- en: Read data from standard input into the shared memory segment ![](figs/web/U005.png).
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从标准输入读取数据到共享内存段 ![](figs/web/U005.png)。
- en: Release (increment) the reader semaphore ![](figs/web/U006.png).
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放（递增）读取程序的信号量 ![](figs/web/U006.png)。
- en: The loop terminates when no further data is available from standard input ![](figs/web/U007.png).
    On the last pass through the loop, the writer indicates to the reader that there
    is no more data by passing a block of data of length 0 (*shmp -> cnt* is 0).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当标准输入没有更多数据时，循环终止 ![](figs/web/U007.png)。在循环的最后一次迭代中，写入程序通过传递一个长度为 0 的数据块（*shmp
    -> cnt* 为 0）通知读取程序没有更多数据。
- en: Upon exiting the loop, the writer once more reserves its semaphore, so that
    it knows that the reader has completed the final access to the shared memory ![](figs/web/U008.png).
    The writer then removes the shared memory segment and semaphore set ![](figs/web/U009.png).
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在退出循环时，写入程序再次保留其信号量，以便知道读取程序已经完成了对共享内存的最终访问 ![](figs/web/U008.png)。然后，写入程序移除共享内存段和信号量集合
    ![](figs/web/U009.png)。
- en: '[Example 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v "Example 48-3. Transfer
    blocks of data from a System V shared memory segment to stdout") is the reader
    program. It transfers blocks of data from the shared memory segment to standard
    output. The reader performs the following steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v "示例 48-3. 从 System
    V 共享内存段向 stdout 传输数据块")是读取程序。它将共享内存段中的数据块传输到标准输出。读取程序执行以下步骤：'
- en: Obtain the IDs of the semaphore set and shared memory segment that were created
    by the writer program ![](figs/web/U001.png).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取由写入程序创建的信号量集和共享内存段的 ID ![](figs/web/U001.png)。
- en: Attach the shared memory segment for read-only access ![](figs/web/U002.png).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为只读访问附加共享内存段 ![](figs/web/U002.png)。
- en: 'Enter a loop that transfers data from the shared memory segment ![](figs/web/U003.png).
    The following steps are performed in each loop iteration:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入一个循环，传输共享内存段中的数据 ![](figs/web/U003.png)。在每次循环迭代中执行以下步骤：
- en: Reserve (decrement) the reader semaphore ![](figs/web/U004.png).
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留（减少）读取信号量 ![](figs/web/U004.png)。
- en: Check whether *shmp -> cnt* is 0; if so, exit this loop ![](figs/web/U005.png).
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 *shmp -> cnt* 是否为 0；如果是，则退出此循环 ![](figs/web/U005.png)。
- en: Write the block of data in the shared memory segment to standard output ![](figs/web/U006.png).
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将共享内存段中的数据块写入标准输出 ![](figs/web/U006.png)。
- en: Release (increment) the writer semaphore ![](figs/web/U007.png).
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放（增加）写入信号量 ![](figs/web/U007.png)。
- en: After exiting the loop, detach the shared memory segment ![](figs/web/U008.png)
    and releases the writer semaphore ![](figs/web/U009.png), so that the writer program
    can remove the IPC objects.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在退出循环后，分离共享内存段 ![](figs/web/U008.png) 并释放写入信号量 ![](figs/web/U009.png)，这样写入程序就可以移除
    IPC 对象。
- en: Example 48-2. Transfer blocks of data from *stdin* to a System V shared memory
    segment
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 48-2. 从 *stdin* 向 System V 共享内存段传输数据块
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Example 48-3. Transfer blocks of data from a System V shared memory segment
    to *stdout*
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 48-3. 从 System V 共享内存段向 *stdout* 传输数据块
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following shell session demonstrates the use of the programs in [Example 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a
    "Example 48-2. Transfer blocks of data from stdin to a System V shared memory
    segment") and [Example 46-9](ch46.html#client_for_file_server_using_system_v_me
    "Example 46-9. Client for file server using System V message queues"). We invoke
    the writer, using the file `/etc/services` as input, and then invoke the reader,
    directing its output to another file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shell 会话演示了在[示例 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a "示例
    48-2. 从 stdin 向 System V 共享内存段传输数据块")和[示例 46-9](ch46.html#client_for_file_server_using_system_v_me
    "示例 46-9. 使用 System V 消息队列的文件服务器客户端")中使用程序的方法。我们调用写入程序，使用文件`/etc/services`作为输入，然后调用读取程序，将其输出重定向到另一个文件：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The *diff* command produced no output, indicating that the output file produced
    by the reader has the same content as the input file used by the writer.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*diff* 命令没有产生输出，表示读取程序生成的输出文件与写入程序使用的输入文件内容相同。'
- en: Location of Shared Memory in Virtual Memory
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享内存在虚拟内存中的位置
- en: In [Memory Layout of a Process](ch06.html#memory_layout_of_a_process "Memory
    Layout of a Process"), we considered the layout of the various parts of a process
    in virtual memory. It is useful to revisit this topic in the context of attaching
    System V shared memory segments. If we follow the recommended approach of allowing
    the kernel to choose where to attach a shared memory segment, then (on the x86-32
    architecture) the memory layout appears as shown in [Figure 48-2](ch48.html#locations_of_shared_memory_comma_memory
    "Figure 48-2. Locations of shared memory, memory mappings, and shared libraries
    (x86-32)"), with the segment being attached in the unallocated space between the
    upwardly growing heap and the downwardly growing stack. To allow space for heap
    and stack growth, shared memory segments are attached starting at the virtual
    address `0x40000000`. Mapped mappings ([Chapter 49](ch49.html "Chapter 49. Memory
    Mappings")) and shared libraries ([Chapter 41](ch41.html "Chapter 41. Fundamentals
    of Shared Libraries") and [Chapter 42](ch42.html "Chapter 42. Advanced Features
    of Shared Libraries")) are also placed in this area. (There is some variation
    in the default location at which shared memory mappings and memory segments are
    placed, depending on the kernel versions and the setting of the process’s `RLIMIT_STACK`
    resource limit.)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在[进程的内存布局](ch06.html#memory_layout_of_a_process "进程的内存布局")中，我们考虑了进程在虚拟内存中的各个部分的布局。重新审视这个话题对于附加
    System V 共享内存段是非常有用的。如果我们遵循推荐的方法，允许内核选择共享内存段附加的位置，那么（在 x86-32 架构上）内存布局将如[图 48-2](ch48.html#locations_of_shared_memory_comma_memory
    "图 48-2. 共享内存、内存映射和共享库的位置（x86-32）")所示，内存段将被附加在向上增长的堆和向下增长的栈之间的未分配空间中。为了给堆和栈增长留出空间，共享内存段从虚拟地址`0x40000000`开始附加。映射映射（[第49章](ch49.html
    "第49章. 内存映射")）和共享库（[第41章](ch41.html "第41章. 共享库基础")和[第42章](ch42.html "第42章. 共享库的高级特性")）也会被放置在这个区域。（共享内存映射和内存段放置的默认位置会有所不同，具体取决于内核版本以及进程的`RLIMIT_STACK`资源限制设置。）
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The address `0x40000000` is defined as the kernel constant `TASK_UNMAPPED_BASE`.
    It is possible to change this address by defining this constant with a different
    value and rebuilding the kernel.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 地址`0x40000000`被定义为内核常量`TASK_UNMAPPED_BASE`。通过定义这个常量为不同的值并重建内核，可以改变这个地址。
- en: A shared memory segment (or memory mapping) can be placed at an address below
    `TASK_UNMAPPED_BASE`, if we employ the unrecommended approach of explicitly specifying
    an address when calling *shmat()* (or *mmap()*).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们采用不推荐的方法，在调用*shmat()*（或*mmap()*）时显式指定一个地址，则共享内存段（或内存映射）可以被放置在`TASK_UNMAPPED_BASE`以下的地址。
- en: Using the Linux-specific `/proc/`*PID*`/maps` file, we can see the location
    of the shared memory segments and shared libraries mapped by a program, as we
    demonstrate in the shell session below.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Linux 特有的`/proc/`*PID*`/maps`文件，我们可以看到程序映射的共享内存段和共享库的位置，如下面的 shell 会话所示。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with kernel 2.6.14, Linux also provides the `/proc/`*PID*`/smaps` file,
    which exposes more information about the memory consumption of each of a process’s
    mappings. For further details, see the *proc(5)* manual page.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核 2.6.14 开始，Linux 还提供了`/proc/`*PID*`/smaps`文件，它展示了关于每个进程映射的内存消耗的更多信息。详细信息，请参阅*proc(5)*手册页。
- en: '![Locations of shared memory, memory mappings, and shared libraries (x86-32)](figs/web/48-2_SVSHM-shm-layout.png.jpg)Figure 48-2. Locations
    of shared memory, memory mappings, and shared libraries (x86-32)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![共享内存、内存映射和共享库的位置（x86-32）](figs/web/48-2_SVSHM-shm-layout.png.jpg)图 48-2.
    共享内存、内存映射和共享库的位置（x86-32）'
- en: 'In the shell session below, we employ three programs that are not shown in
    this chapter, but are provided in the `svshm` subdirectory in the source code
    distribution for this book. These programs perform the following tasks:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 shell 会话中，我们使用了三种在本章中未展示的程序，但它们已在本书源代码分发的`svshm`子目录中提供。这些程序执行以下任务：
- en: The `svshm_create.c` program creates a shared memory segment. This program takes
    the same command-line options as the corresponding programs that we provide for
    message queues ([Example 46-1](ch46.html#using_msgget_open_parenthesis_close_pare
    "Example 46-1. Using msgget()"), in [Creating or Opening a Message Queue](ch46.html#creating_or_opening_a_message_queue
    "Creating or Opening a Message Queue")) and semaphores, but includes an additional
    argument that specifies the size of the segment.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`svshm_create.c`程序创建一个共享内存段。这个程序接受与我们为消息队列（[示例 46-1](ch46.html#using_msgget_open_parenthesis_close_pare
    "Example 46-1. Using msgget()"), 在[创建或打开消息队列](ch46.html#creating_or_opening_a_message_queue
    "Creating or Opening a Message Queue")）和信号量提供的相同的命令行选项，但增加了一个额外的参数，用于指定段的大小。'
- en: The `svshm_attach.c` program attaches the shared memory segments identified
    by its command-line arguments. Each of these arguments is a colon-separated pair
    of numbers consisting of a shared memory identifier and an attach address. Specifying
    0 for the attach address means that the system should choose the address. The
    program displays the address at which the memory is actually attached. For informational
    purposes, the program also displays the value of the SHMLBA constant and the process
    ID of the process running the program.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`svshm_attach.c`程序根据其命令行参数附加由共享内存标识符指定的共享内存段。每个参数都是由共享内存标识符和附加地址组成的冒号分隔的数字对。为附加地址指定0意味着系统应选择地址。程序显示内存实际附加的地址。为了提供信息，程序还显示了SHMLBA常量的值以及运行程序的进程ID。'
- en: The `svshm_rm.c` program deletes the shared memory segments identified by its
    command-line arguments.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`svshm_rm.c`程序删除由其命令行参数指定的共享内存段。'
- en: 'We begin the shell session by creating two shared memory segments (100 kB and
    3200 kB in size):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建两个共享内存段（分别为100 kB和3200 kB大小）开始shell会话：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then start a program that attaches these two segments at addresses chosen
    by the kernel:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们启动一个程序，将这两个段附加到内核选择的地址：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output above shows the addresses at which the segments were attached. Before
    the program completes sleeping, we suspend it, and then examine the contents of
    the corresponding `/proc/`*PID*`/maps` file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的输出显示了段附加的地址。在程序完成休眠之前，我们暂停它，然后检查对应的`/proc/`*PID*`/maps`文件的内容：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The output produced by the *cat* command is shown in [Example 48-4](ch48.html#example_of_contents_of_solidus_proc_soli
    "Example 48-4. Example of contents of /proc/PID/maps").
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令产生的输出如[示例 48-4](ch48.html#example_of_contents_of_solidus_proc_soli "Example 48-4. Example
    of contents of /proc/PID/maps")所示。'
- en: Example 48-4. Example of contents of `/proc/`*PID*`/maps`
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 48-4. `/proc/`*PID*`/maps`的内容示例
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the output from `/proc/`*PID*`/maps` shown in [Example 48-4](ch48.html#example_of_contents_of_solidus_proc_soli
    "Example 48-4. Example of contents of /proc/PID/maps"), we can see the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 48-4](ch48.html#example_of_contents_of_solidus_proc_soli "Example 48-4. Example
    of contents of /proc/PID/maps")中显示的`/proc/`*PID*`/maps`输出中，我们可以看到以下内容：
- en: Three lines for the main program, *shm_attach*. These correspond to the text
    and data segments of the program ![](figs/web/U001.png). The second of these lines
    is for a read-only page holding the string constants used by the program.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三行对应主程序`shm_attach`。这些行对应于程序的文本段和数据段！[](figs/web/U001.png)。其中第二行是一个只读页面，包含程序使用的字符串常量。
- en: Two lines for the attached System V shared memory segments ![](figs/web/U002.png).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附带的 System V 共享内存段有两行！[](figs/web/U002.png)。
- en: Lines corresponding to the segments for two shared libraries. One of these is
    the standard C library (`libc`-*version*.`so`) ![](figs/web/U003.png). The other
    is the dynamic linker (`ld`-*version*.`so`), which we describe in [Using a Shared
    Library](ch41.html#using_a_shared_library "Using a Shared Library") ![](figs/web/U004.png).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对应于两个共享库段的行。其中一个是标准C库（`libc`-*版本*.`so`）！[](figs/web/U003.png)。另一个是动态链接器（`ld`-*版本*.`so`），我们在[使用共享库](ch41.html#using_a_shared_library
    "Using a Shared Library")中描述过！[](figs/web/U004.png)。
- en: A line labeled `[stack]`. This corresponds to the process stack ![](figs/web/U005.png).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行标记为`[stack]`。这对应于进程栈！[](figs/web/U005.png)。
- en: A line containing the tag `[vdso]` ![](figs/web/U006.png). This is an entry
    for the *linux-gate* virtual dynamic shared object (DSO). This entry appears only
    in kernels since 2.6.12\. See [http://www.trilithium.com/johan/2005/08/linux-gate/](http://www.trilithium.com/johan/2005/08/linux-gate/)
    for further information about this entry.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含标签`[vdso]`的行 ![](figs/web/U006.png)。这是*linux-gate*虚拟动态共享对象（DSO）的条目。该条目仅在2.6.12及以后的内核中出现。有关此条目的更多信息，请参见[http://www.trilithium.com/johan/2005/08/linux-gate/](http://www.trilithium.com/johan/2005/08/linux-gate/)。
- en: 'The following columns are shown in each line of `/proc/`*PID*`/maps`, in order
    from left to right:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/`*PID*`/maps`中每行显示的以下列，从左到右：'
- en: A pair of hyphen-separated numbers indicating the virtual address range (in
    hexadecimal) at which the memory segment is mapped. The second of these numbers
    is the address of the next byte *after* the end of the segment.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一对由连字符分隔的数字，表示内存段映射的虚拟地址范围（以十六进制表示）。这两个数字中的第二个表示内存段末尾*之后*的下一个字节的地址。
- en: 'Protection and flags for this memory segment. The first three letters indicate
    the protection of the segment: read (`r`), write (`w`), and execute (`x`). A hyphen
    (`-`) in place of any of these letters indicates that the corresponding protection
    is disabled. The final letter indicates the mapping flag for the memory segment;
    it is either private (`p`) or shared (`s`). For an explanation of these flags,
    see the description of the `MAP_PRIVATE` and `MAP_SHARED` flags in Section 49.2\.
    (A System V shared memory segment is always marked shared.)'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该内存段的保护和标志。前三个字母表示该段的保护方式：读取（`r`）、写入（`w`）和执行（`x`）。如果这些字母中的任何一个被一个连字符（`-`）替代，则表示相应的保护已被禁用。最后一个字母表示该内存段的映射标志；它可以是私有（`p`）的，也可以是共享（`s`）的。有关这些标志的解释，请参见第49.2节中对`MAP_PRIVATE`和`MAP_SHARED`标志的描述。（System
    V共享内存段始终标记为共享。）
- en: The hexadecimal offset (in bytes) of the segment within the corresponding mapped
    file. The meanings of this and the following two columns will become clearer when
    we describe the *mmap()* system call in [Chapter 49](ch49.html "Chapter 49. Memory
    Mappings"). For a System V shared memory segment, the offset is always 0.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对应映射文件中内存段的十六进制偏移量（以字节为单位）。当我们描述*mmap()*系统调用时，当前列和接下来的两列的含义会变得更加清晰，请参见[第49章](ch49.html
    "第49章。内存映射")。对于System V共享内存段，偏移量始终为0。
- en: The device number (major and minor IDs) of the device on which the corresponding
    mapped file is located.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对应映射文件所在设备的设备编号（主设备号和次设备号）。
- en: The i-node number of the mapped file, or, for System V shared memory segments,
    the identifier for the segment.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 映射文件的i-node号，或者对于System V共享内存段，这是该段的标识符。
- en: 'The filename or other identifying tag associated with this memory segment.
    For a System V shared memory segment, this consists of the string `SYSV` concatenated
    with the *shmget() key* of the segment (expressed in hexadecimal). In this example,
    `SYSV` is followed by zeros because we created the segments using the key `IPC_PRIVATE`
    (which has the value 0). The string `(deleted)` that appears after the `SYSV`
    field for a System V shared memory segment is an artifact of the implementation
    of shared memory segments. Such segments are created as mapped files in an invisible
    *tmpfs* file system ([A Virtual Memory File System: *tmpfs*](ch14.html#a_virtual_memory_file_system_colon_tmpfs
    "A Virtual Memory File System: tmpfs")), and then later unlinked. Shared anonymous
    memory mappings are implemented in the same manner. (We describe mapped files
    and shared anonymous memory mappings in [Chapter 49](ch49.html "Chapter 49. Memory
    Mappings").)'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与该内存段相关的文件名或其他标识标签。对于System V共享内存段，这个标签由字符串`SYSV`与该段的*shmget()键*（以十六进制表示）连接而成。在此示例中，`SYSV`后跟零，因为我们使用键`IPC_PRIVATE`（其值为0）创建了这些段。`SYSV`字段后面的字符串`(deleted)`是System
    V共享内存段实现中的副产品。这些段作为映射文件在一个隐形的*tmpfs*文件系统中创建（参见[虚拟内存文件系统：*tmpfs*](ch14.html#a_virtual_memory_file_system_colon_tmpfs
    "虚拟内存文件系统：tmpfs")），然后被取消链接。共享匿名内存映射的实现方式相同。（我们在[第49章](ch49.html "第49章。内存映射")中描述了映射文件和共享匿名内存映射。）
- en: Storing Pointers in Shared Memory
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在共享内存中存储指针
- en: Each process may employ different shared libraries and memory mappings, and
    may attach different sets of shared memory segments. Therefore, if we follow the
    recommended practice of letting the kernel choose where to attach a shared memory
    segment, the segment may be attached at a different address in each process. For
    this reason, when storing references inside a shared memory segment that point
    to other addresses within the segment, we should use (relative) offsets, rather
    than (absolute) pointers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程可能使用不同的共享库和内存映射，并且可能附加不同的共享内存段。因此，如果我们遵循推荐的做法，让内核选择共享内存段附加的位置，则该段可能会在每个进程中附加到不同的地址。因此，当我们在共享内存段中存储指向该段内其他地址的引用时，应该使用（相对的）偏移量，而不是（绝对的）指针。
- en: 'For example, suppose we have a shared memory segment whose starting address
    is pointed to by *baseaddr* (i.e., *baseaddr* is the value returned by *shmat()*).
    Furthermore, at the location pointed to by *p*, we want to store a pointer to
    the same location as is pointed to by *target*, as shown in [Figure 48-3](ch48.html#using_pointers_in_a_shared_memory_segmen
    "Figure 48-3. Using pointers in a shared memory segment"). This sort of operation
    would be typical if we were building a linked list or a binary tree within the
    segment. The usual C idiom for setting **p* would be the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个共享内存段，其起始地址由 *baseaddr* 指向（即，*baseaddr* 是 *shmat()* 返回的值）。此外，在 *p*
    指向的位置，我们想要存储一个指向与 *target* 指向的相同位置的指针，如[图 48-3](ch48.html#using_pointers_in_a_shared_memory_segmen
    "图 48-3. 在共享内存段中使用指针")所示。如果我们要在该段内构建一个链表或二叉树，这种操作就是典型的。设置 **p** 的常见 C 习惯用法如下：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Using pointers in a shared memory segment](figs/web/48-3_SVSHM-pointers-scale90.png.jpg)Figure 48-3. Using
    pointers in a shared memory segment'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![在共享内存段中使用指针](figs/web/48-3_SVSHM-pointers-scale90.png.jpg)图 48-3. 在共享内存段中使用指针'
- en: 'The problem with this code is that the location pointed to by *target* may
    reside at a different virtual address when the shared memory segment is attached
    in another process, which means that the value stored at **p* is meaningless in
    that process. The correct approach is to store an offset at **p*, as in the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题在于，当共享内存段在另一个进程中附加时，*target* 指向的位置可能位于不同的虚拟地址，这意味着在该进程中存储在 **p** 处的值是没有意义的。正确的方法是在
    **p** 处存储一个偏移量，如下所示：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When dereferencing such pointers, we reverse the above step:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当解引用这些指针时，我们需要反转上述步骤：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we assume that in each process, *baseaddr* points to the start of the
    shared memory segment (i.e., it is the value returned by *shmat()* in each process).
    Given this assumption, an offset value is correctly interpreted, no matter where
    the shared memory segment is attached in a process’s virtual address space.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设在每个进程中，*baseaddr* 指向共享内存段的起始位置（即，它是每个进程中 *shmat()* 返回的值）。在此假设下，偏移量值将被正确解释，无论共享内存段在进程的虚拟地址空间中附加到哪里。
- en: Alternatively, if we are linking together a set of fixed-size structures, we
    can cast the shared memory segment (or a part thereof) as an array, and then use
    index numbers as the “pointers” referring from one structure to another.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们将一组固定大小的结构链接在一起，我们可以将共享内存段（或其一部分）转换为数组，然后使用索引号作为从一个结构到另一个结构的“指针”。
- en: Shared Memory Control Operations
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享内存控制操作
- en: The *shmctl()* system call performs a range of control operations on the shared
    memory segment identified by *shmid*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*shmctl()* 系统调用对由 *shmid* 标识的共享内存段执行一系列控制操作。'
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1。
- en: The *cmd* argument specifies the control operation to be performed. The *buf*
    argument is required by the `IPC_STAT` and `IPC_SET` operations (described below),
    and should be specified as `NULL` for the remaining operations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*cmd* 参数指定要执行的控制操作。`IPC_STAT` 和 `IPC_SET` 操作（见下文）需要 *buf* 参数，对于其他操作，则应将其指定为
    `NULL`。'
- en: In the remainder of this section, we describe the various operations that can
    be specified for *cmd*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将描述可以为 *cmd* 指定的各种操作。
- en: Generic control operations
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通用控制操作
- en: The following operations are the same as for other types of System V IPC objects.
    Further details about these operations, including the privileges and permissions
    required by the calling process, are described in Section 45.3.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作与其他类型的 System V IPC 对象相同。有关这些操作的详细信息，包括调用进程所需的权限和特权，请参见第 45.3 节。
- en: '`IPC_RMID`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_RMID`'
- en: Mark the shared memory segment and its associated *shmid_ds* data structure
    for deletion. If no processes currently have the segment attached, deletion is
    immediate; otherwise, the segment is removed after all processes have detached
    from it (i.e., when the value of the *shm_nattch* field in the *shmid_ds* data
    structure falls to 0). In some applications, we can make sure that a shared memory
    segment is tidily cleared away on application termination by marking it for deletion
    immediately after all processes have attached it to their virtual address space
    with *shmat()*. This is analogous to unlinking a file once we’ve opened it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 标记共享内存段及其关联的 *shmid_ds* 数据结构以进行删除。如果当前没有进程附加到该段，删除将立即执行；否则，该段将在所有进程都已从其分离后被移除（即，当
    *shmid_ds* 数据结构中的 *shm_nattch* 字段值降为 0 时）。在某些应用中，我们可以确保通过在所有进程使用 *shmat()* 将其附加到虚拟地址空间后立即标记为删除，从而确保共享内存段在应用程序终止时被整洁地清除。这类似于在打开文件后立即取消链接。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'On Linux, if a shared segment has been marked for deletion using `IPC_RMID`,
    but has not yet been removed because some process still has it attached, then
    it is possible for another process to attach that segment. However, this behavior
    is not portable: most UNIX implementations prevent new attaches to a segment marked
    for deletion. (SUSv3 is silent on what behavior should occur in this scenario.)
    A few Linux applications have come to depend on this behavior, which is why Linux
    has not been changed to match other UNIX implementations.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，如果共享内存段已通过 `IPC_RMID` 标记为删除，但由于某些进程仍然附加着它，因此尚未被移除，那么另一个进程仍然可以附加该段。然而，这种行为并不具备可移植性：大多数
    UNIX 实现会阻止新的进程附加到已标记为删除的内存段。（SUSv3 对此场景下应该发生的行为没有说明。）一些 Linux 应用程序已经依赖于这种行为，这就是
    Linux 没有进行修改以匹配其他 UNIX 实现的原因。
- en: '`IPC_STAT`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_STAT`'
- en: Place a copy of the *shmid_ds* data structure associated with this shared memory
    segment in the buffer pointed to by *buf*. (We describe this data structure in
    Section 48.8.)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将与此共享内存段关联的 *shmid_ds* 数据结构的副本放置在 *buf* 指向的缓冲区中。（我们在第48.8节中描述了这个数据结构。）
- en: '`IPC_SET`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC_SET`'
- en: Update selected fields of the *shmid_ds* data structure associated with this
    shared memory segment using values in the buffer pointed to by *buf*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *buf* 指向的缓冲区中的值更新与此共享内存段关联的 *shmid_ds* 数据结构中的选定字段。
- en: Locking and unlocking shared memory
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 锁定和解锁共享内存
- en: 'A shared memory segment can be locked into RAM, so that it is never swapped
    out. This provides a performance benefit, since, once each page of the segment
    is memory-resident, an application is guaranteed never to be delayed by a page
    fault when it accesses the page. There are two *shmctl()* locking operations:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存段可以被锁定在 RAM 中，这样它就永远不会被交换出去。这样可以提高性能，因为一旦每一页内存段被载入内存，应用程序就能保证在访问该页时不会因为页面错误而被延迟。有两个
    *shmctl()* 锁定操作：
- en: The `SHM_LOCK` operation locks a shared memory segment into memory.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHM_LOCK` 操作将共享内存段锁定到内存中。'
- en: The `SHM_UNLOCK` operation unlocks the shared memory segment, allowing it to
    be swapped out.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHM_UNLOCK` 操作解锁共享内存段，允许它被交换出去。'
- en: These operations are not specified by SUSv3, and they are not provided on all
    UNIX implementations.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作没有在 SUSv3 中规定，并且并非所有 UNIX 实现都提供这些功能。
- en: 'In versions of Linux before 2.6.10, only privileged (`CAP_IPC_LOCK`) processes
    can lock a shared memory segment into memory. Since Linux 2.6.10, an unprivileged
    process can lock and unlock a shared memory segment if its effective user ID matches
    either the owner or the creator user ID of the segment and (in the case of `SHM_LOCK`)
    the process has a sufficiently high `RLIMIT_MEMLOCK` resource limit. See [Memory
    Locking: *mlock()* and *mlockall()*](ch50.html#memory_locking_colon_mlock_open_parenthe
    "Memory Locking: mlock() and mlockall()") for details.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.6.10 版本之前的 Linux 中，只有具有特权的（`CAP_IPC_LOCK`）进程才能将共享内存段锁定到内存中。从 Linux 2.6.10
    起，如果进程的有效用户 ID 与段的所有者或创建者的用户 ID 匹配，并且（在 `SHM_LOCK` 的情况下）进程的 `RLIMIT_MEMLOCK` 资源限制足够高，则非特权进程也可以锁定和解锁共享内存段。有关详细信息，请参见
    [内存锁定：*mlock()* 和 *mlockall()*](ch50.html#memory_locking_colon_mlock_open_parenthe
    "内存锁定：mlock() 和 mlockall()")。
- en: Locking a shared memory segment does not guarantee that all of the pages of
    the segment are memory-resident at the completion of the *shmctl()* call. Rather,
    nonresident pages are individually locked in only as they are faulted into memory
    by subsequent references by processes that have attached the shared memory segment.
    Once faulted in, the pages stay resident until subsequently unlocked, even if
    all processes detach the segment. (In other words, the `SHM_LOCK` operation sets
    a property of the shared memory segment, rather than a property of the calling
    process.)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定共享内存段并不保证在*shmctl()*调用完成时，内存段的所有页面都会驻留在内存中。实际上，非驻留页面仅在通过附加共享内存段的进程随后引用时，才会逐一被锁定到内存中。一旦页面被加载到内存中，它们会保持驻留状态，直到随后被解锁，即使所有进程都已从地址空间中分离该段。（换句话说，`SHM_LOCK`操作设置的是共享内存段的属性，而不是调用进程的属性。）
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By *faulted into memory*, we mean that when the process references the nonresident
    page, a page fault occurs. At this point, if the page is in the swap area, then
    it is reloaded into memory. If the page is being referenced for the first time,
    no corresponding page exists in the swap file. Therefore, the kernel allocates
    a new page of physical memory and adjusts the process’s page tables and the bookkeeping
    data structures for the shared memory segment.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓的*加载到内存*是指当进程引用非驻留页面时，会发生页面错误。在此时，如果该页面在交换区中，则会重新加载到内存中。如果该页面是第一次被引用，则在交换文件中不存在相应的页面。因此，内核会分配一个新的物理内存页面，并调整进程的页面表和共享内存段的记账数据结构。
- en: An alternative method of locking memory, with slightly different semantics,
    is the use of *mlock()*, which we describe in Section 50.2.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种内存锁定方法，语义略有不同，是使用*mlock()*，我们将在第50.2节中描述。
- en: Shared Memory Associated Data Structure
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享内存相关数据结构
- en: 'Each shared memory segment has an associated *shmid_ds* data structure of the
    following form:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 每个共享内存段都有一个关联的*shmid_ds*数据结构，格式如下：
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: SUSv3 requires all of the fields shown here. Some other UNIX implementations
    include additional nonstandard fields in the *shmid_ds* structure.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3要求显示所有这些字段。其他一些UNIX实现则在*shmid_ds*结构中包含额外的非标准字段。
- en: 'The fields of the *shmid_ds* structure are implicitly updated by various shared
    memory system calls, and certain subfields of the *shm_perm* field can be explicitly
    updated using the *shmctl()* `IPC_SET` operation. The details are as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*shmid_ds*结构的字段会被各种共享内存系统调用隐式更新，并且*shm_perm*字段的某些子字段可以通过*shmctl()* `IPC_SET`操作显式更新。详细信息如下：'
- en: '*shm_perm*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*shm_perm*'
- en: When the shared memory segment is created, the fields of this substructure are
    initialized as described in Section 45.3\. The *uid*, *gid*, and (the lower 9
    bits of the) *mode* subfields can be updated via `IPC_SET`. As well as the usual
    permission bits, the *shm_perm.mode* field holds two read-only bit-mask flags.
    The first of these, `SHM_DEST` (destroy), indicates whether the segment is marked
    for deletion (via the *shmctl()* `IPC_RMID` operation) when all processes have
    detached it from their address space. The other flag, `SHM_LOCKED`, indicates
    whether the segment is locked into physical memory (via the *shmctl()* `SHM_LOCK`
    operation). Neither of these flags is standardized in SUSv3, and equivalents appear
    on only a few other UNIX implementations, in some cases with different names.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建共享内存段时，该子结构的字段会按照第45.3节所述进行初始化。*uid*、*gid*以及（*mode*字段的低9位）可以通过`IPC_SET`进行更新。除了常见的权限位外，*shm_perm.mode*字段还包含两个只读位掩码标志。第一个标志，`SHM_DEST`（销毁），指示该段是否在所有进程从其地址空间分离后标记为删除（通过*shmctl()*
    `IPC_RMID`操作）。另一个标志，`SHM_LOCKED`，指示该段是否已被锁定到物理内存中（通过*shmctl()* `SHM_LOCK`操作）。这两个标志在SUSv3中没有标准化，且仅在少数其他UNIX实现中出现，在某些情况下名称不同。
- en: '*shm_segsz*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*shm_segsz*'
- en: On creation of the shared memory segment, this field is set to the requested
    size of the segment in bytes (i.e., to the value of the *size* argument specified
    in the call to *shmget()*). As noted in [Creating or Opening a Shared Memory Segment](ch48.html#creating_or_opening_a_shared_memory_segm
    "Creating or Opening a Shared Memory Segment"), shared memory is allocated in
    units of pages, so the actual size of the segment may be larger than this value.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建共享内存段时，此字段被设置为请求的段大小（以字节为单位，即*shmget()*调用中指定的*size*参数的值）。正如在[创建或打开共享内存段](ch48.html#creating_or_opening_a_shared_memory_segm
    "Creating or Opening a Shared Memory Segment")中所述，共享内存是以页面为单位分配的，因此段的实际大小可能大于此值。
- en: '*shm_atime*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*shm_atime*'
- en: This field is set to 0 when the shared memory segment is created, and set to
    the current time whenever a process attaches the segment (*shmat()*). This field
    and the other timestamp fields in the *shmid_ds* structure are typed as *time_t*,
    and store time in seconds since the Epoch.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段在共享内存段创建时设置为0，每当进程附加该内存段时（*shmat()*），它会设置为当前时间。该字段以及 *shmid_ds* 结构中的其他时间戳字段被定义为
    *time_t* 类型，并以自纪元以来的秒数表示时间。
- en: '*shm_dtime*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*shm_dtime*'
- en: This field is set to 0 when the shared memory segment is created, and set to
    the current time whenever a process detaches the segment (*shmdt()*).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段在共享内存段创建时设置为0，每当一个进程分离该内存段时（*shmdt()*），它会设置为当前时间。
- en: '*shm_ctime*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*shm_ctime*'
- en: This field is set to the current time when the segment is created, and on each
    successful `IPC_SET` operation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段在段创建时设置为当前时间，并在每次成功的 `IPC_SET` 操作时更新。
- en: '*shm_cpid*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*shm_cpid*'
- en: This field is set to the process ID of the process that created the segment
    using *shmget()*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段设置为创建该段的进程的进程ID，该进程通过 *shmget()* 创建内存段。
- en: '*shm_lpid*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*shm_lpid*'
- en: This field is set to 0 when the shared memory segment is created, and then set
    to the process ID of the calling process on each successful *shmat()* or *shmdt()*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段在共享内存段创建时设置为0，然后在每次成功调用 *shmat()* 或 *shmdt()* 时，设置为调用进程的进程ID。
- en: '*shm_nattch*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*shm_nattch*'
- en: This field counts the number of processes that currently have the segment attached.
    It is initialized to 0 when the segment is created, and then incremented by each
    successful *shmat()* and decremented by each successful *shmdt()*. The *shmatt_t*
    data type used to define this field is an unsigned integer type that SUSv3 requires
    to be at least the size of *unsigned short*. (On Linux, this type is defined as
    *unsigned long*.)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段记录当前有多少进程附加了该内存段。当段创建时初始化为0，每当成功调用 *shmat()* 时增加，每当成功调用 *shmdt()* 时减少。用于定义此字段的
    *shmatt_t* 数据类型是一个无符号整数类型，SUSv3 要求其至少与 *unsigned short* 类型一样大。（在 Linux 上，这个类型被定义为
    *unsigned long*。）
- en: Shared Memory Limits
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享内存限制
- en: Most UNIX implementations impose various limits on System V shared memory. Below
    is a list of the Linux shared memory limits. The system call affected by the limit
    and the error that results if the limit is reached are noted in parentheses.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 UNIX 实现对 System V 共享内存施加了各种限制。以下是 Linux 共享内存限制的列表。限制所涉及的系统调用和达到限制时产生的错误会在括号中注明。
- en: '`SHMMNI`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHMMNI`'
- en: This is a system-wide limit on the number of shared memory identifiers (in other
    words, shared memory segments) that can be created. (*shmget()*, `ENOSPC`)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个系统范围的限制，用于限制可以创建的共享内存标识符的数量（换句话说，就是共享内存段的数量）。(*shmget()*, `ENOSPC`)
- en: '`SHMMIN`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHMMIN`'
- en: This is the minimum size (in bytes) of a shared memory segment. This limit is
    defined with the value 1 (this can’t be changed). However, the effective limit
    is the system page size. (*shmget()*, `EINVAL`)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是共享内存段的最小大小（以字节为单位）。此限制的定义值为1（不可更改）。然而，实际的有效限制是系统页面大小。(*shmget()*, `EINVAL`)
- en: '`SHMMAX`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHMMAX`'
- en: This is the maximum size (in bytes) of a shared memory segment. The practical
    upper limit for `SHMMAX` depends on available RAM and swap space. (*shmget()*,
    `EINVAL`)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是共享内存段的最大大小（以字节为单位）。`SHMMAX` 的实际上限取决于可用的内存和交换空间。(*shmget()*, `EINVAL`)
- en: '`SHMALL`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHMALL`'
- en: This is a system-wide limit on the total number of pages of shared memory. Most
    other UNIX implementations don’t provide this limit. The practical upper limit
    for `SHMALL` depends on available RAM and swap space. (*shmget()*, `ENOSPC`)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个系统范围的限制，用于限制共享内存的总页面数。大多数其他 UNIX 实现不提供这个限制。`SHMALL` 的实际上限取决于可用的内存和交换空间。(*shmget()*,
    `ENOSPC`)
- en: 'Some other UNIX implementations also impose the following limit (which is not
    implemented on Linux):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些 UNIX 实现也施加了以下限制（在 Linux 上未实现）：
- en: '`SHMSEG`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHMSEG`'
- en: This is a per-process limit on the number of attached shared memory segments.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每个进程的限制，用于限制每个进程可以附加的共享内存段的数量。
- en: 'At system startup, the shared memory limits are set to default values. (These
    defaults may vary across kernel versions, and some distributors’ kernels set different
    defaults from those provided by vanilla kernels.) On Linux, some of the limits
    can be viewed or changed via files in the `/proc` file system. [Table 48-2](ch48.html#system_v_shared_memory_limits
    "Table 48-2. System V shared memory limits") lists the `/proc` file corresponding
    to each limit. As an example, here are the default limits that we see for Linux
    2.6.31 on one x86-32 system:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统启动时，共享内存的限制设置为默认值。（这些默认值可能会随内核版本的不同而有所变化，一些发行版的内核可能设置了与标准内核不同的默认值。）在Linux中，某些限制可以通过`/proc`文件系统中的文件查看或更改。[表
    48-2](ch48.html#system_v_shared_memory_limits "表 48-2. 系统V共享内存限制")列出了与每个限制对应的`/proc`文件。以下是我们在一台x86-32系统上使用Linux
    2.6.31时看到的默认限制：
- en: '[PRE16]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The Linux-specific *shmctl()* `IPC_INFO` operation retrieves a structure of
    type *shminfo*, which contains the values of the various shared memory limits:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Linux特有的*shmctl()* `IPC_INFO`操作检索一个类型为*shminfo*的结构，包含各个共享内存限制的值：
- en: '[PRE17]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A related Linux-specific operation, `SHM_INFO`, retrieves a structure of type
    *shm_info* that contains information about actual resources used for shared memory
    objects. An example of the use of `SHM_INFO` is provided in the file `svshm/svshm_info.c`
    in the source code distribution for this book.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与Linux特定相关的操作，`SHM_INFO`，检索一个类型为*shm_info*的结构，包含关于共享内存对象实际使用资源的信息。`SHM_INFO`的使用示例如在本书的源代码分发包中的`svshm/svshm_info.c`文件中提供。
- en: Details about `IPC_INFO`, `SHM_INFO`, and the *shminfo* and *shm_info* structures
    can be found in the *shmctl(2)* manual page.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`IPC_INFO`、`SHM_INFO`、以及*shminfo*和*shm_info*结构的详细信息，可以在*shmctl(2)*手册页中找到。
- en: Table 48-2. System V shared memory limits
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 表 48-2. 系统V共享内存限制
- en: '| Limit | Ceiling value (x86-32) | Corresponding file in `/proc/sys/kernel`
    |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 限制 | 上限值（x86-32） | `/proc/sys/kernel`中的对应文件 |'
- en: '| --- | --- | --- |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `SHMMNI` | `32768` (`IPCMNI`) | `shmmni` |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `SHMMNI` | `32768` (`IPCMNI`) | `shmmni` |'
- en: '| `SHMMAX` | Depends on available memory | `shmmax` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `SHMMAX` | 取决于可用内存 | `shmmax` |'
- en: '| `SHMALL` | Depends on available memory | `shmall` |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `SHMALL` | 取决于可用内存 | `shmall` |'
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Shared memory allows two or more processes to share the same pages of memory.
    No kernel intervention is required to exchange data via shared memory. Once a
    process has copied data into a shared memory segment, that data is immediately
    visible to other processes. Shared memory provides fast IPC, although this speed
    advantage is somewhat offset by the fact that normally we must use some type of
    synchronization technique, such as a System V semaphore, to synchronize access
    to the shared memory.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存允许两个或多个进程共享相同的内存页面。在通过共享内存交换数据时，不需要内核的干预。一旦一个进程将数据复制到共享内存段中，其他进程可以立即看到这些数据。共享内存提供了快速的进程间通信（IPC），尽管这种速度优势在某种程度上被必须使用某种同步技术（例如System
    V信号量）来同步对共享内存访问的需求所抵消。
- en: The recommended approach when attaching a shared memory segment is to allow
    the kernel to choose the address at which the segment is attached in the process’s
    virtual address space. This means that the segment may reside at different virtual
    addresses in different processes. For this reason, any references to addresses
    within the segment should be maintained as relative offsets, rather than as absolute
    pointers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 附加共享内存段时，推荐的方法是允许内核选择该段在进程虚拟地址空间中附加的地址。这意味着该段可能在不同的进程中位于不同的虚拟地址。因此，任何对该段内地址的引用都应保持为相对偏移量，而不是绝对指针。
- en: Further information
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步的信息
- en: The Linux memory-management scheme and some details of the implementation of
    shared memory are described in [Bovet & Cesati, 2005].
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的内存管理方案以及共享内存实现的一些细节描述可以参考[Bovet & Cesati, 2005]。
- en: Exercises
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Replace the use of binary semaphores in [Example 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a
    "Example 48-2. Transfer blocks of data from stdin to a System V shared memory
    segment") (`svshm_xfr_writer.c`) and [Example 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v
    "Example 48-3. Transfer blocks of data from a System V shared memory segment to
    stdout") (`svshm_xfr_reader.c`) with the use of event flags (Exercise 47-5).
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用事件标志替换[示例 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a "示例 48-2.
    从stdin向System V共享内存段传输数据")（`svshm_xfr_writer.c`）和[示例 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v
    "示例 48-3. 从System V共享内存段传输数据到stdout")（`svshm_xfr_reader.c`）中的二进制信号量使用（练习 47-5）。
- en: 'Explain why the program in [Example 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v
    "Example 48-3. Transfer blocks of data from a System V shared memory segment to
    stdout") incorrectly reports the number of bytes transferred if the `for` loop
    is modified as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释为什么如果将`for`循环修改如下，[示例 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v
    "示例 48-3. 从System V共享内存段传输数据到stdout")中的程序会错误地报告传输的字节数：
- en: '[PRE18]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Try compiling the programs in [Example 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a
    "Example 48-2. Transfer blocks of data from stdin to a System V shared memory
    segment") (`svshm_xfr_writer.c`) and [Example 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v
    "Example 48-3. Transfer blocks of data from a System V shared memory segment to
    stdout") (`svshm_xfr_reader.c`) with a range of different sizes (defined by the
    constant `BUF_SIZE`) for the buffer used to exchange data between the two programs.
    Time the execution of `svshm_xfr_reader.c` for each buffer size.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试编译[示例 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a "示例 48-2. 从stdin到System
    V共享内存段传输数据")（`svshm_xfr_writer.c`）和[示例 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v
    "示例 48-3. 从System V共享内存段传输数据到stdout")（`svshm_xfr_reader.c`）中的程序，并使用不同的缓冲区大小（由常量`BUF_SIZE`定义）来交换数据。对每个缓冲区大小进行`svshm_xfr_reader.c`的执行时间测量。
- en: Write a program that displays the contents of the *shmid_ds* data structure
    ([Shared Memory Associated Data Structure](ch48.html#shared_memory_associated_data_structure
    "Shared Memory Associated Data Structure")) associated with a shared memory segment.
    The identifier of the segment should be specified as a command-line argument.
    (See the program in [Example 47-3](ch47.html#a_semaphore_monitoring_program "Example 47-3. A
    semaphore monitoring program"), in [Monitoring a semaphore set](ch47.html#monitoring_a_semaphore_set-id1
    "Monitoring a semaphore set"), which performs the analogous task for System V
    semaphores.)
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，显示与共享内存段关联的*shmid_ds*数据结构（[共享内存关联数据结构](ch48.html#shared_memory_associated_data_structure
    "共享内存关联数据结构")）。该段的标识符应作为命令行参数指定。（参见[示例 47-3](ch47.html#a_semaphore_monitoring_program
    "示例 47-3. 信号量监视程序")，在[监视信号量集](ch47.html#monitoring_a_semaphore_set-id1 "监视信号量集")中，它执行类似的任务用于System
    V信号量。）
- en: Write a directory service that uses a shared memory segment to publish name-value
    pairs. You will need to provide an API that allows callers to create a new name,
    modify an existing name, delete an existing name, and retrieve the value associated
    with a name. Use semaphores to ensure that a process performing an update to the
    shared memory segment has exclusive access to the segment.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个目录服务，使用共享内存段发布名称-值对。你需要提供一个API，允许调用者创建新名称、修改现有名称、删除现有名称以及检索与名称关联的值。使用信号量确保执行更新共享内存段的进程对该段有独占访问权限。
- en: Write a program (analogous to program in [Example 46-6](ch46.html#displaying_all_system_v_message_queues_o
    "Example 46-6. Displaying all System V message queues on the system"), in [Client-Server
    Programming with Message Queues](ch46.html#client-server_programming_with_message_q
    "Client-Server Programming with Message Queues")) that uses the *shmctl()* `SHM_INFO`
    and `SHM_STAT` operations to obtain and display a list of all shared memory segments
    on the system.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序（类似于[示例 46-6](ch46.html#displaying_all_system_v_message_queues_o "示例 46-6.
    显示系统中的所有System V消息队列")，参见[使用消息队列的客户端-服务器编程](ch46.html#client-server_programming_with_message_q
    "使用消息队列的客户端-服务器编程")），该程序使用*shmctl()* `SHM_INFO`和`SHM_STAT`操作来获取并显示系统中所有共享内存段的列表。
