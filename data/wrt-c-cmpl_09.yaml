- en: '![](../images/pg142.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg142.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-16.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-16.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">LOOPS</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">循环</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: In this chapter, you’ll add all things loop-related. That includes <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp>
    loops, plus <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements to skip over
    parts of a loop. These are the last statements you’ll implement in this book.
    Once you finish this chapter, if you’ve implemented all the extra credit features,
    your compiler will be able to handle *every* kind of C statement.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将添加所有与循环相关的内容。这包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp>
    循环，另外还有 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    语句，用来跳过循环的某些部分。这些是本书中你将实现的最后几个语句。一旦你完成本章的内容，并且实现了所有额外的加分特性，你的编译器就能处理*每*一种 C 语句。
- en: But you have work to do first! You’ll update the lexer and parser to support
    all five new statements. Then, you’ll add a new semantic analysis pass, which
    we’ll call *loop labeling*. This new pass, which is bolded in the diagram at the
    start of the chapter, will annotate the AST to associate every <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement with
    the loop that contains it. Finally, you’ll translate every new statement into
    a sequence of TACKY instructions. You can implement all the new statements using
    the TACKY instructions you’ve already defined, so you won’t change any stages
    after TACKY generation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但你首先有工作要做！你将更新词法分析器和语法分析器，以支持所有五个新语句。然后，你将增加一个新的语义分析步骤，我们称之为*循环标注*。这个新步骤，如本章开头的图表中加粗的部分所示，将注释
    AST，将每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    语句与包含它的循环关联起来。最后，你将把每个新语句翻译成一系列 TACKY 指令。你可以使用已经定义的 TACKY 指令来实现所有新语句，因此在 TACKY
    生成之后你不会再更改任何阶段。
- en: The new statements in this chapter introduce a few edge cases and errors we’ll
    need to handle. We’ll briefly discuss each of these statements before we start
    on the lexer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中新引入的语句会带来一些边界情况和错误，我们需要处理这些情况。在我们开始讲解词法分析器之前，我们将简要讨论每个语句。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Loops and How to Escape Them</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">循环及如何跳出它们</samp>
- en: Let’s first look at the three kinds of loop statements, then consider the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statements. [Listing 8-1](chapter8.xhtml#list8-1) shows an example of a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看三种循环语句，然后考虑 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句。[Listing 8-1](chapter8.xhtml#list8-1)
    展示了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环的示例。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">while</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: 一个</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">while</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">循环</samp>'
- en: First, we evaluate the statement’s *controlling expression* ❶. If it’s 0 (that
    is, false), the loop ends and we move on to the next statement. If it’s nonzero,
    we execute the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop
    body, then go back to the controlling expression, rinse, and repeat.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们评估语句的*控制表达式* ❶。如果它是 0（即假），循环结束，我们进入下一个语句。如果它是非零的，我们执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    循环体，然后返回控制表达式，清空并重复执行。
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> loop, like the one
    in [Listing 8-2](chapter8.xhtml#list8-2), is almost exactly the same.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> 循环，像在 [Listing 8-2](chapter8.xhtml#list8-2)
    中的那个，几乎是完全相同的。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">do</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-2：一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">do</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">循环</samp>
- en: The only difference is that we execute the loop body first, *then* check the
    controlling expression. That means the loop body will be executed at least once.
    Like an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement body,
    a loop body is a single statement, which can be a compound statement that contains
    declarations. Any variables you declare in the loop body will not be in scope
    in the controlling expression. For example, [Listing 8-3](chapter8.xhtml#list8-3)
    is invalid.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是我们先执行循环体，*然后*检查控制表达式。这意味着循环体至少会执行一次。像<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句体一样，循环体是一个单一的语句，可以是包含声明的复合语句。你在循环体内声明的任何变量，在控制表达式中将无法访问。例如，[列表
    8-3](chapter8.xhtml#list8-3)是无效的。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-3: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">do</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop
    where the controlling expression uses an out-of-scope variable</samp>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-3：一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">do</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">循环，其中控制表达式使用了一个超出作用域的变量</samp>
- en: Things start to get more complicated with <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops. These come in two different flavors. In the first, shown in [Listing 8-4](chapter8.xhtml#list8-4),
    the loop header consists of three expressions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环出现时，事情开始变得更加复杂。它们有两种不同的形式。在第一种形式中，如[列表
    8-4](chapter8.xhtml#list8-4)所示，循环头由三个表达式组成。
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-4: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop
    where the initial clause is an expression</samp>'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-4：一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">循环，其中初始语句是一个表达式</samp>
- en: 'The initial expression ❶ is evaluated once before the first loop iteration.
    Then, on each iteration, we:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 初始表达式❶在第一次循环迭代之前评估一次。然后，在每次迭代时，我们：
- en: Evaluate the controlling expression ❷. If it’s false, the loop terminates. Otherwise,
    we …
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估控制表达式❷。如果它为假，循环终止。否则，我们…
- en: Execute the statement body.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行语句体。
- en: Evaluate the final expression ❸.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估最终表达式❸。
- en: You can omit any or all of the expressions in the loop header. If you omit the
    initial expression or the final expression, nothing happens when that clause would
    normally be evaluated. If you omit the controlling expression, the loop behaves
    as though its controlling expression is always true (that is, nonzero). That means
    it will never terminate, unless it contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement that transfers control out of the loop body.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以省略循环头中的任何或所有表达式。如果省略初始表达式或最终表达式，当该语句通常会被评估时，什么也不会发生。如果省略控制表达式，循环将表现得好像其控制表达式始终为真（即非零）。这意味着它永远不会终止，除非它包含一个可以跳出循环体的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp>语句。
- en: '[Listing 8-5](chapter8.xhtml#list8-5) shows the second kind of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, in which the initial clause is a declaration rather than an expression.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-5](chapter8.xhtml#list8-5)展示了第二种类型的<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环，其中初始语句是一个声明，而不是表达式。'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-5: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop
    with a declaration in the initial clause</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-5：一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">循环，其中初始语句是一个声明</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop header introduces
    a new scope, so you can write code like [Listing 8-6](chapter8.xhtml#list8-6).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环头引入了一个新的作用域，因此你可以像[列表
    8-6](chapter8.xhtml#list8-6)那样编写代码。
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-6: Declaring two
    variables with the same name before a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop and in the loop header</samp>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-6：在</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">循环前和循环头部声明两个同名变量</samp>
- en: In this listing, the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    declared in the header hides the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    declared on the previous line. And since a compound statement always introduces
    a new scope, including when it appears as a loop body, [Listing 8-7](chapter8.xhtml#list8-7)
    is also valid.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个清单中，头部声明的变量<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>隐藏了上一行声明的变量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>。由于复合语句总是引入一个新的作用域，包括当它作为循环体出现时，[清单
    8-7](chapter8.xhtml#list8-7)也是有效的。
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-7: Declaring three
    variables with the same name before a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop, in the loop header, and
    in the loop body</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-7：在</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">循环前，循环头部和循环体中声明三个同名变量</samp>
- en: 'In [Listing 8-7](chapter8.xhtml#list8-7), there are three distinct variables
    named <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>: one declared before
    the start of the loop ❶, one declared in the loop header ❷, and one declared in
    the loop body ❸.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 8-7](chapter8.xhtml#list8-7)中，有三个不同的变量名为<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>：一个在循环开始前声明
    ❶，一个在循环头部声明 ❷，另一个在循环体内声明 ❸。
- en: Although the expressions in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop header are optional, the loop body is required. (It’s required for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">do</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loops too.) A loop body can, however, be a null statement, like in [Listing 8-8](chapter8.xhtml#list8-8).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环头部的表达式是可选的，但循环体是必须的。（这对于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">do</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环也是如此。）然而，循环体可以是一个空语句，就像在[清单
    8-8](chapter8.xhtml#list8-8)中一样。
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-8: Using a null statement
    as a loop body</samp>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-8：将空语句用作循环体</samp>
- en: The lone <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> here is a null
    statement. Even though this statement doesn’t do anything, we need to include
    it so the parser can figure out where the loop ends. As we saw when we implemented
    them in [Chapter 5](chapter5.xhtml), null statements aren’t a loop-specific construct;
    you can use them anywhere you can use any other kind of statement. In practice,
    though, they mostly appear in loop bodies because they’re rarely useful anywhere
    else.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里单独的<samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>是一个空语句。尽管这个语句什么也不做，但我们需要包含它，以便解析器能够识别循环的结束位置。正如我们在[第五章](chapter5.xhtml)中实现它们时所看到的，空语句并不是一个特定于循环的构造；你可以在任何可以使用其他类型语句的地方使用它们。实际上，它们主要出现在循环体内，因为它们很少在其他地方有用。
- en: Now let’s talk about <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements.
    Both can appear only inside loops. (Actually, that’s not entirely true; a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement can also appear
    inside a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement,
    which you can implement as an extra credit feature in this chapter.) A <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement, like the one in [Listing 8-9](chapter8.xhtml#list8-9), jumps to the
    point just after the end of the loop.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一下<samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>语句。两者只能出现在循环内部。（实际上，这并不完全正确；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp>语句也可以出现在<samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>语句内部，你可以将它作为本章的附加功能来实现。）<samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp>语句，像[清单 8-9](chapter8.xhtml#list8-9)中的语句一样，跳转到循环结束后的位置。
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-9: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-9：一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>
- en: When we hit this <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement, we’ll jump to the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement after the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 语句时，我们将跳转到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句，位于 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    循环之后。
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement terminates
    only the innermost loop. For example, consider the code snippet in [Listing 8-10](chapter8.xhtml#list8-10).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 语句仅终止最内层的循环。例如，参考
    [列表 8-10](chapter8.xhtml#list8-10) 中的代码片段。
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-10: Using a</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    to break out of the inner of two nested loops</samp>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-10：使用</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句跳出两个嵌套循环中的内层循环</samp>
- en: When we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement in this listing, we’ll break out of the inner loop, but not the outer
    loop, so we’ll jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b
    * a;</samp>. Throughout this chapter, I’ll call the innermost loop that contains
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement its *enclosing loop*. (Calling this the “smallest enclosing loop” would
    be more in line with the terminology in the C standard, but that’s a bit of a
    mouthful.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达这个列表中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 语句时，我们将跳出内层循环，但不会跳出外层循环，因此我们会跳转到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b * a;</samp>。在本章中，我将把包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句的最内层循环称为它的 *封闭循环*。（如果称之为“最小封闭循环”会更符合
    C 标准中的术语，但这有点冗长。）
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement jumps
    to the point just after the last statement in the body of the enclosing loop.
    Consider the example in [Listing 8-11](chapter8.xhtml#list8-11).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句跳转到封闭循环体内最后一条语句之后的位置。参考
    [列表 8-11](chapter8.xhtml#list8-11) 中的例子。
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-11: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-11：A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>
- en: When we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement, we skip over all the statements that follow it and jump to the end
    of the loop body ❶. From there, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop executes as usual, which means it jumps back to the controlling expression.
    A <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement in a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, like the one in
    [Listing 8-12](chapter8.xhtml#list8-12), works the same way.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句时，我们将跳过所有后续的语句，直接跳转到循环体的末尾
    ❶。从那里，<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环照常执行，意味着它将跳转回控制表达式。像
    [列表 8-12](chapter8.xhtml#list8-12) 中的那种 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句也起到相同的作用。
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-12: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    inside a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-12：A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句在</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">循环内部</samp>
- en: In this listing, we still jump from the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement to the end of the loop body ❷. Then, we jump to the final expression
    ❶, as usual.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们仍然从 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句跳转到循环体的末尾
    ❷。然后，我们按常规跳转到最终表达式 ❶。
- en: If a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement appears outside of a loop, like in [Listing 8-13](chapter8.xhtml#list8-13),
    compilation should fail.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在循环外出现了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句，就像在[清单 8-13](chapter8.xhtml#list8-13)中一样，编译应该失败。
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-13: An invalid</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-13：无效的</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>
- en: It’s perfectly fine, however, for one of these statements to appear nested deep
    inside a loop, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement in [Listing 8-14](chapter8.xhtml#list8-14).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果这些语句之一嵌套在循环内部深层次的地方，像[清单 8-14](chapter8.xhtml#list8-14)中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    语句那样，也是完全合法的。
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-14: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement
    appearing a few layers deep inside a loop</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-14：一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句出现在循环内多层嵌套的情况</samp>
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement jumps
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">return 1;</samp> because that’s
    the point right after the end of the loop.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 语句跳转到 <samp class="SANS_TheSansMonoCd_W5Regular_11">return
    1;</samp>，因为那是循环结束后的下一点。
- en: It’s legal to have multiple <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements in
    one loop, like in [Listing 8-15](chapter8.xhtml#list8-15).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个循环中有多个 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句是合法的，就像在[清单 8-15](chapter8.xhtml#list8-15)中一样。
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-15: Multiple</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements
    inside a loop</samp>'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-15：多个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句在循环内部</samp>
- en: Now that we’ve covered the key things you need to know about the statements
    we’ll add in this chapter, we can get started on implementing them. The first
    step, as usual, is updating the lexer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了你需要了解的关于本章将要添加的语句的关键内容，我们可以开始实现它们了。第一步，像往常一样，是更新词法分析器（lexer）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>
- en: 'You’ll add five keywords in this chapter:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将添加五个关键字：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">do</samp>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">do</samp>
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">while</samp>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">while</samp>
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">for</samp>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">for</samp>
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">break</samp>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">break</samp>
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">continue</samp>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">continue</samp>
- en: You won’t need any other new tokens.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要其他新的标记（tokens）。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">解析器</samp>'
- en: 'Next, we’ll update the AST. We’ll add five new statements:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新抽象语法树（AST）。我们将添加五个新语句：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statements are as simple as it gets. The <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> statements are also
    relatively simple; both have a body and a controlling expression. The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    statement is the most complex: it includes an initial clause, an optional controlling
    expression, an optional final expression, and a body. The initial clause can be
    a declaration, an expression, or nothing, so we need a new AST node to describe
    it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>` 和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>`
    语句是最简单的。`<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>` 和 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">do</samp>` 语句也相对简单；它们都有一个主体和一个控制表达式。`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>` 语句是最复杂的：它包括一个初始子句、一个可选的控制表达式、一个可选的最终表达式和一个主体。初始子句可以是声明、表达式或没有任何内容，因此我们需要一个新的
    AST 节点来描述它：'
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Putting it all together gives us the latest AST definition, shown in [Listing
    8-16](chapter8.xhtml#list8-16).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起，我们得到了最新的 AST 定义，如 [示例 8-16](chapter8.xhtml#list8-16) 所示。
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-16: The abstract
    syntax tree with loops and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 8-16：包含循环的抽象语法树和</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>
- en: 'Updating the AST in this chapter involves one complication. The loop labeling
    pass will annotate every <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>, and loop statement
    in the program with a label (we’ll use these labels to associate each <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement with
    its enclosing loop). That means you’ll need some way to attach these labels to
    the new statements in the AST. There are a few different options. One is to include
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp> argument for each
    new constructor, like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本章更新 AST 涉及一个复杂的问题。循环标注阶段会为程序中的每个 `<samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>`、`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>` 和循环语句加上标签（我们将使用这些标签将每个
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>` 和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>`
    语句与其包含的循环关联起来）。这意味着你需要一种方法将这些标签附加到 AST 中的新语句上。这里有几种不同的选择。一种方法是在每个新构造函数中包含一个 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">label</samp>` 参数，像这样：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you go with this option, you may need to use dummy labels during parsing,
    then replace them with real labels in the loop labeling pass. Another option is
    to define two AST data structures: one without annotations to use before loop
    labeling and one with annotations to use afterward. The right approach depends
    on what language you’re writing your compiler in (and on your personal taste).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择这种方法，你可能需要在解析过程中使用虚拟标签，然后在循环标注阶段将它们替换为真实标签。另一种方法是定义两个 AST 数据结构：一个在循环标注前使用，没有注释，另一个在循环标注后使用，带有注释。正确的方法取决于你使用的编译语言（以及你的个人偏好）。
- en: After updating the AST, we’ll make the corresponding changes to the grammar,
    as shown in [Listing 8-17](chapter8.xhtml#list8-17).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 AST 后，我们将对语法进行相应的修改，如 [示例 8-17](chapter8.xhtml#list8-17) 所示。
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-17: The grammar with
    loops and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 8-17：包含循环的语法和</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>
- en: I recommend writing a helper function to parse optional expressions. You can
    use this helper function to parse the two optional expressions in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop header, plus expression statements and null statements. The helper function
    should let you specify which token marks the end of the optional expression; most
    of the optional expressions in the grammar are followed by a semicolon, but the
    third clause in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    header is followed by a closing parenthesis.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议编写一个辅助函数来解析可选的表达式。你可以使用这个辅助函数来解析`for`循环头部中的两个可选表达式，以及表达式语句和空语句。这个辅助函数应该让你指定哪个标记表示可选表达式的结束；语法中的大多数可选表达式后面跟着一个分号，但`for`循环头部的第三个子句后面跟着一个右括号。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp>
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">语义分析</samp>
- en: 'The semantic analysis stage of your compiler currently performs one task: it
    resolves variable names. In this chapter, it will take on a completely new task:
    loop labeling. The loop labeling pass associates each <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement with
    its enclosing loop. More concretely, this pass assigns every loop statement a
    unique ID and annotates each <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement with
    the ID of its enclosing loop. If it finds a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement outside
    of a loop, it will throw an error. During TACKY generation, we’ll use these annotations
    to convert each <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement into a
    jump to the correct spot relative to its enclosing loop.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 目前编译器的语义分析阶段执行一个任务：解析变量名。在本章中，它将承担一个全新的任务：循环标记。循环标记步骤将每个`break`和`continue`语句与其所在的循环关联起来。更具体地说，这个步骤为每个循环语句分配一个唯一的ID，并为每个`break`和`continue`语句添加其所在循环的ID。如果在循环外发现`break`或`continue`语句，将抛出错误。在TACKY生成过程中，我们将使用这些注释信息，将每个`break`和`continue`语句转换为相对于其所在循环的跳转。
- en: We’ll resolve variable names and label loops in two separate passes, traversing
    the whole program each time. Let’s start by extending the variable resolution
    pass to handle this chapter’s new statements; then we’ll implement the loop labeling
    pass.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在两次遍历中分别解析变量名和标记循环，每次遍历整个程序。让我们首先扩展变量解析步骤，以处理本章的新语句；然后实现循环标记步骤。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extending Variable
    Resolution</samp>
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">扩展变量解析</samp>
- en: You’ll need to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>
    to traverse the five new statements you added in this chapter. You’ll treat <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp>
    loops just like <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements,
    processing every substatement and subexpression recursively. Resolving <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements is
    even simpler; since they don’t have any substatements or subexpressions, you don’t
    have to do anything.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要扩展<samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>，以遍历本章中添加的五个新语句。你将像处理`if`语句一样处理`while`和`do`循环，递归地处理每个子语句和子表达式。解析`break`和`continue`语句要简单得多；因为它们没有子语句或子表达式，你不需要做任何额外处理。
- en: Resolving a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is
    a tiny bit more complicated because the loop header introduces a new variable
    scope. [Listing 8-18](chapter8.xhtml#list8-18) demonstrates how to handle <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops in <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 解析一个<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环稍微复杂一些，因为循环头部引入了一个新的变量作用域。[清单
    8-18](chapter8.xhtml#list8-18)演示了如何在<samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>中处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环。
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-18: Resolving a</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-18：解析一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">循环</samp>
- en: We start by making a new copy of the variable map, just like we do at the beginning
    of a compound statement. Copying the map ensures that a variable declared in the
    loop header won’t be visible outside of the loop and that it won’t trigger a compiler
    error if it hides a variable from the outer scope.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的变量映射副本，就像在复合语句的开始时一样。复制映射可以确保在循环头部声明的变量不会在循环外部可见，并且如果它隐藏了外部作用域的变量，也不会触发编译器错误。
- en: Next, we process the initial clause with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_for_init</samp>,
    which we’ll look at in a moment. We then traverse the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop’s controlling expression, final expression, and body, all using the new variable
    map. I won’t provide pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_optional_exp</samp>,
    which handles the optional controlling expression and final expression; it just
    calls <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> if the
    expression is present and does nothing if it’s absent.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_for_init</samp>处理初始子句，稍后我们将查看这个函数。然后，我们使用新的变量映射遍历<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环的控制表达式、终止表达式和主体。我不会提供<samp
    class="SANS_TheSansMonoCd_W5Regular_11">resolve_optional_exp</samp>的伪代码，它处理可选的控制表达式和终止表达式；如果表达式存在，它会调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>，如果不存在，则不执行任何操作。
- en: '[Listing 8-19](chapter8.xhtml#list8-19) shows the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_for_init</samp>.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-19](chapter8.xhtml#list8-19)显示了<samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_for_init</samp>的伪代码。'
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-19: Resolving the
    initial clause of a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-19：解析一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">循环的初始子句</samp>
- en: We resolve an expression or declaration in the initial clause exactly the same
    way we would resolve it if it appeared elsewhere in the program. If the clause
    is a declaration, calling <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_declaration</samp>
    will add the newly declared variable to the variable map so it’s visible throughout
    the rest of the loop.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在初始子句中解析一个表达式或声明的方式与在程序其他地方解析它时完全相同。如果该子句是一个声明，调用<samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_declaration</samp>将把新声明的变量添加到变量映射中，使其在整个循环中可见。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Loop Labeling</samp>
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">循环标记</samp>
- en: After resolving variables, we’ll traverse the program again, labeling each loop,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement with an ID. Whenever we encounter a loop statement, we’ll generate a
    unique ID for it. Then, when we traverse the loop body, we’ll attach that same
    ID to any <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements we encounter.
    Let’s look at a few examples. In the next three listings, the markers ❶ and ❷
    represent IDs attached to the AST. Although the loop labeling pass annotates the
    AST rather than source files, these listings are presented as source code for
    the sake of readability.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析变量后，我们将再次遍历程序，给每个循环、<samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句标注上 ID。每当我们遇到循环语句时，我们将为其生成一个唯一的
    ID。然后，在遍历循环体时，我们将这个 ID 附加到遇到的任何 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句上。让我们来看几个例子。在接下来的三个列表中，标记
    ❶ 和 ❷ 表示附加到抽象语法树（AST）的 ID。尽管循环标注阶段是给 AST 添加注解，而不是源文件，但为了可读性，这些列表以源代码的形式呈现。
- en: '[Listing 8-20](chapter8.xhtml#list8-20) illustrates how we’ll annotate a code
    fragment that contains two loops in succession.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-20](chapter8.xhtml#list8-20) 演示了我们如何标注包含两个连续循环的代码片段。'
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-20: Annotating</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements
    and their enclosing loops</samp>'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-20: 标注</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句及其包含的循环</samp>'
- en: Each of the two loops in this listing gets its own ID. We annotate the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop with ID ❶ and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop with ID ❷. Each <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement is annotated with the ID of its enclosing loop, so we annotate the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement with ID ❶ and the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement with ID
    ❷.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本列表中的两个循环各自获得一个 ID。我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    循环标注为 ID ❶，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环标注为 ID
    ❷。每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    语句都会被标注上其所包含循环的 ID，因此我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    语句标注为 ID ❶，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句标注为
    ID ❷。
- en: If several <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements are in the
    same enclosing loop, they’re all annotated with the same ID, as [Listing 8-21](chapter8.xhtml#list8-21)
    demonstrates.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    语句位于同一个包含循环中，它们都会被标注为相同的 ID，正如 [列表 8-21](chapter8.xhtml#list8-21) 所示。
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-21: Annotating multiple</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements
    in the same loop</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-21: 标注同一循环中的多个</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>'
- en: Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop labeled
    ❶ is the enclosing loop of the two <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statements and the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement, we annotate all three of those statements with ID ❶.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标注为 ❶ 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环是两个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句和 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    语句的包含循环，我们将这三条语句都标注为 ID ❶。
- en: If a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement appears inside nested loops, we annotate it with the ID of its enclosing
    loop, which is the innermost loop. [Listing 8-22](chapter8.xhtml#list8-22) illustrates
    how to annotate nested loops.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    语句出现在嵌套循环内，我们会用其包含的最内层循环的 ID 为其注解。[列表 8-22](chapter8.xhtml#list8-22) 演示了如何注解嵌套循环。
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-22: Annotating nested
    loops</samp>'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-22：注解嵌套循环</samp>
- en: The outer <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop and
    inner <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop are labeled
    ❶ and ❷, respectively. Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement appears in the inner loop, we annotate it with ID ❷. The <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statement is in the outer loop, so we annotate it with ID ❶.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 外部的 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环和内部的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环分别被标注为 ❶ 和 ❷。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    语句出现在内部循环中，我们用 ID ❷ 为其注解。<samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    语句出现在外部循环中，因此我们用 ID ❶ 为其注解。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing Loop
    Labeling</samp>
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">实现循环标注</samp>
- en: To implement this compiler pass, we pass the current loop ID along as an argument
    when we traverse the AST, much like we pass the variable map as an argument to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>, and so on during the
    variable resolution pass. When we’re outside of a loop, the current ID is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>,
    or whatever your implementation language uses to indicate an absent value. When
    we hit a loop statement, we generate a new ID and annotate the statement with
    it. We then pass it along as the current ID when we traverse the loop body. When
    we hit a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement, we annotate it with the ID that was passed to us. The pseudocode in
    [Listing 8-23](chapter8.xhtml#list8-23) illustrates how to annotate statements
    with loop IDs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个编译器阶段，我们在遍历 AST 时将当前的循环 ID 作为参数传递，就像我们在变量解析阶段将变量映射传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> 等函数一样。当我们不在循环内时，当前的
    ID 为 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>，或者根据你的实现语言，表示缺失值的其他方式。当遇到循环语句时，我们会生成一个新的
    ID，并用它注解该语句。然后，在遍历循环体时，我们将其作为当前 ID 传递。当遇到 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句时，我们用传递给我们的
    ID 为其注解。[列表 8-23](chapter8.xhtml#list8-23) 中的伪代码演示了如何用循环 ID 注解语句。
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-23: The loop annotation
    algorithm</samp>'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 8-23：循环注解算法</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">make_label</samp> helper function
    ❸ generates unique loop IDs; you can use the same helper function here that you
    use to generate unique labels in TACKY. The <samp class="SANS_TheSansMonoCd_W5Regular_11">annotate</samp>
    helper function takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>
    AST node and a label and returns a copy of that AST node annotated with that label.
    Here, we use it to annotate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Break</samp>
    ❶, <samp class="SANS_TheSansMonoCd_W5Regular_11">Continue</samp> ❷, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">While</samp> ❹ statements. I haven’t provided
    the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">annotate</samp>
    because it will depend on how exactly you represent loop annotations in your AST.
    I’ve also omitted the pseudocode to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">DoWhile</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">For</samp>, and all the statements
    we added in earlier chapters. You can process <samp class="SANS_TheSansMonoCd_W5Regular_11">DoWhile</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">For</samp> essentially the same
    way as <samp class="SANS_TheSansMonoCd_W5Regular_11">While</samp>. To process
    any other kind of statement, call <samp class="SANS_TheSansMonoCd_W5Regular_11">label_statement</samp>
    recursively for every substatement, passing along the same value of <samp class="SANS_TheSansMonoCd_W5Regular_11">current_label</samp>.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">make_label</samp>辅助函数❸生成唯一的循环ID；你可以在此使用与生成TACKY中唯一标签相同的辅助函数。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">annotate</samp>辅助函数接受一个<samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>
    AST节点和一个标签，并返回一个带有该标签的AST节点副本。在这里，我们用它来注解<samp class="SANS_TheSansMonoCd_W5Regular_11">Break</samp>
    ❶、<samp class="SANS_TheSansMonoCd_W5Regular_11">Continue</samp> ❷和<samp class="SANS_TheSansMonoCd_W5Regular_11">While</samp>
    ❹语句。我没有提供<samp class="SANS_TheSansMonoCd_W5Regular_11">annotate</samp>的定义，因为它将依赖于你在AST中如何表示循环注解。我还省略了处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DoWhile</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">For</samp>以及我们在早期章节中添加的所有语句的伪代码。你可以像处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">While</samp>语句一样处理<samp class="SANS_TheSansMonoCd_W5Regular_11">DoWhile</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">For</samp>语句。要处理任何其他类型的语句，请递归地调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">label_statement</samp>，并传递相同的<samp class="SANS_TheSansMonoCd_W5Regular_11">current_label</samp>值给每个子语句。
- en: Once you’ve updated the loop labeling pass, you’re ready to test out the whole
    semantic analysis stage.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你更新了循环标签的传递过程，就可以测试整个语义分析阶段了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TACKY生成</samp>
- en: Next, we’ll convert each new statement to TACKY. We won’t change the TACKY IR
    in this chapter, because we can implement these statements with our existing TACKY
    instructions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把每个新语句转换为TACKY。在本章中，我们不会改变TACKY IR，因为我们可以使用现有的TACKY指令来实现这些语句。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">break and continue
    Statements</samp>
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">break 和 continue
    语句</samp>
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement unconditionally
    jumps to some other point in the program, so we implement it with a single <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> instruction. The same is true
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements.
    The only question is where to jump to. The loop annotations we added in the last
    section help us answer that question.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个<samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>语句会无条件跳转到程序中的某个点，因此我们使用单一的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>指令来实现它。<samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>语句也是如此。唯一的问题是跳转到哪里。我们在上一节添加的循环注解可以帮助我们回答这个问题。
- en: Whenever we convert a loop statement to TACKY, we’ll emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    right after the instructions for the loop body. Any <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement in that loop can be implemented as a jump to that label, which I’ll
    call the *continue label*. We’ll emit another <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    as the final instruction for the whole loop; I’ll call this the *break label*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们将一个循环语句转换为TACKY时，我们会在循环体的指令后面生成一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>。任何该循环中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>语句都可以实现为跳转到该标签，我将其称为*continue标签*。我们将生成另一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>作为整个循环的最后一条指令；我将其称为*break标签*。
- en: 'We’ll derive these labels from the IDs we added during the loop annotation
    pass. For example, if a loop is labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">loop0</samp>,
    its break and continue labels might be <samp class="SANS_TheSansMonoCd_W5Regular_11">break_loop0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue_loop0</samp>. Using
    this example naming scheme, we’d convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">Break</samp>
    AST node annotated with ID <samp class="SANS_TheSansMonoCd_W5Regular_11">loop0</samp>
    to the following TACKY instruction:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据在循环注释过程中添加的 ID 来导出这些标签。例如，如果一个循环被标记为 <samp class="SANS_TheSansMonoCd_W5Regular_11">loop0</samp>，则其
    break 和 continue 标签可能是 <samp class="SANS_TheSansMonoCd_W5Regular_11">break_loop0</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue_loop0</samp>。使用此命名方案，我们将把带有
    ID <samp class="SANS_TheSansMonoCd_W5Regular_11">loop0</samp> 注释的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Break</samp>
    AST 节点转换为以下 TACKY 指令：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We’d convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">Continue</samp>
    node with the same annotation to:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的注释将一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Continue</samp>
    节点转换为：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You don’t need to use this particular naming scheme (although your naming scheme
    must guarantee that these labels won’t conflict with any other labels in the TACKY
    program). The important point is that you can derive the same label when you convert
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement to TACKY as when you convert its enclosing loop to TACKY, because that
    statement and its enclosing loop are annotated with the same ID.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要使用这个特定的命名方案（尽管你的命名方案必须保证这些标签不会与 TACKY 程序中的其他标签冲突）。重要的是，你可以在将 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句转换为 TACKY 时，导出与转换其封闭循环时相同的标签，因为该语句及其封闭循环都使用相同的
    ID 注释。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">do Loops</samp>
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">do 循环</samp>
- en: We can execute the statement <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><body></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">while
    (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">);</samp> in three steps. First, we execute
    the loop body. Then, we evaluate the condition and compare the result to zero.
    Finally, if the result was not zero, we jump back to the beginning of the loop.
    [Listing 8-24](chapter8.xhtml#list8-24) demonstrates how to implement these steps
    in TACKY.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过三步执行语句 <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><body></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">);</samp>。首先，我们执行循环体。然后，评估条件并将结果与零进行比较。最后，如果结果不为零，我们跳回到循环的开始。[清单
    8-24](chapter8.xhtml#list8-24)演示了如何在 TACKY 中实现这些步骤。
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-24: The TACKY instructions
    for a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">do</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-24：do 循环的 TACKY 指令</samp>
- en: We also need break and continue labels. The continue label goes between the
    body and the condition, and the break label goes at the very end, after <samp
    class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>. Adding both of these
    labels gives us the complete TACKY for a <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp>
    loop, as shown in [Listing 8-25](chapter8.xhtml#list8-25).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要 break 和 continue 标签。continue 标签位于循环体和条件之间，而 break 标签位于最后，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>
    之后。添加这两个标签可以得到完整的 TACKY for <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp>
    循环，如[清单 8-25](chapter8.xhtml#list8-25)所示。
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-25: The TACKY instructions
    for a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">do</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop,
    with break and continue labels</samp>'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-25：带有 break 和 continue
    标签的 do 循环的 TACKY 指令</samp>
- en: Now any <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements
    in the loop body will jump to the continue label, and any <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statements will jump to the break label. These labels are necessary only if a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement shows up somewhere in the loop body—otherwise, they won’t be used—but
    to keep things simple, we’ll always emit them. That way, we don’t need to figure
    out whether a loop contains <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，循环体中的任何 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句将跳转到
    continue 标签，而任何 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 语句将跳转到
    break 标签。只有在循环体中出现 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句时，这些标签才是必要的——否则它们不会被使用——但为了简化，我们总是会生成这些标签。这样，我们就不需要判断循环中是否包含
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    语句。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">while Loops</samp>'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">while 循环</samp>'
- en: We’ll handle <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loops
    similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> loops, but
    in this case we’ll execute the condition before the loop body, then use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> to exit the loop if
    the condition is false. We can convert the statement <samp class="SANS_TheSansMonoCd_W5Regular_11">while
    (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><body></samp>
    to the TACKY in [Listing 8-26](chapter8.xhtml#list8-26).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像处理 <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> 循环一样处理 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环，但在这种情况下，我们将在循环体之前执行条件判断，然后使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> 来退出循环（如果条件为假）。我们可以将语句
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><body></samp>
    转换为 [清单 8-26](chapter8.xhtml#list8-26) 中的 TACKY。
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-26: The TACKY instructions
    for a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">while</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-26: while 循环的 TACKY 指令</samp>'
- en: Now let’s figure out where to put the break and continue labels. This time,
    we don’t need extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    instructions; we can reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    instructions that are already present in [Listing 8-26](chapter8.xhtml#list8-26).
    We’ll put the break label in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    instruction at the end of this listing. It will be the target for both the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> instruction and any
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statements in the loop
    body.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来决定将 break 和 continue 标签放在哪里。这次我们不需要额外的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    指令；我们可以重用 [清单 8-26](chapter8.xhtml#list8-26) 中已经存在的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    指令。我们将把 break 标签放在本清单末尾的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    指令中。它将作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> 指令和任何循环体中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 语句的目标。
- en: Likewise, we’ll put the continue label in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    instruction at the start of this listing. This has the same effect as putting
    the continue label just after the end of the loop body ❶, because the instruction
    after the loop body is an unconditional jump that immediately takes us back to
    the start of the loop. Having <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statements jump directly to the start of the loop lets them bypass that <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> instruction, which makes them
    a little bit more efficient.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将在本清单开头的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> 指令中放置
    continue 标签。这与将 continue 标签放在循环体末尾之后 ❶ 的效果相同，因为循环体之后的指令是一个无条件跳转，它会立即将我们带回循环的开始。让
    <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句直接跳转到循环开始处，可以让它们绕过那个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> 指令，从而提高一些效率。
- en: '[Listing 8-27](chapter8.xhtml#list8-27) shows where to use the break and continue
    labels when we convert <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loops to TACKY.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 8-27](chapter8.xhtml#list8-27)显示了在我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环转换为TACKY时，应该使用break和continue标签的位置。'
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-27: The TACKY instructions
    for a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">while</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">loop, with break and continue labels</samp>'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-27: 带有break和continue标签的TACKY指令，用于</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">while</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">循环</samp>'
- en: This TACKY is identical to [Listing 8-26](chapter8.xhtml#list8-26), except that
    it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">continue_</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">break_label</samp> instead of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个TACKY与[Listing 8-26](chapter8.xhtml#list8-26)完全相同，只是它使用了<samp class="SANS_TheSansMonoCd_W5Regular_11">continue_</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">label</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">break_label</samp>，而不是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">start</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">for Loops</samp>
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">for 循环</samp>
- en: Our final task is to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops to TACKY. We’ll convert the statement <samp class="SANS_TheSansMonoCd_W5Regular_11">for
    (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><init></samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><post></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><body></samp>
    into the TACKY in [Listing 8-28](chapter8.xhtml#list8-28), which includes the
    break and continue labels.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终任务是将<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环转换为TACKY。我们将把语句<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><init></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><post></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><body></samp>
    转换为[Listing 8-28](chapter8.xhtml#list8-28)中的TACKY，这包括了break和continue标签。
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-28: The TACKY instructions
    for a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-28: 带有break和continue标签的TACKY指令，用于</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">循环</samp>'
- en: First, we execute <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><init></samp>.
    Then, we execute the controlling expression, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp>,
    and check whether the result is zero. If it is, we jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(break
    _label)</samp> at the very end, without executing the loop body or the final expression.
    Otherwise, we execute the loop body followed by the final expression, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><post></samp>,
    then jump back to <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(start)</samp>
    and start another loop iteration. We won’t execute <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><init></samp>
    again, since <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(start)</samp>
    comes after <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><init></samp>.
    Note that the continue label appears at the end of the loop body, just before
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><post></samp>, and the
    break label appears at the very end of the loop, where it does double duty as
    the target of the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>
    instruction and any <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statements.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们执行<code><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><init></samp></code>。然后，我们执行控制表达式<code><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><condition></samp></code>，并检查结果是否为零。如果是，我们跳转到<code><samp
    class="SANS_TheSansMonoCd_W5Regular_11">Label(break _label)</samp></code>，跳过执行循环体和最终表达式。否则，我们执行循环体，接着是最终表达式<code><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><post></samp></code>，然后跳转回<code><samp
    class="SANS_TheSansMonoCd_W5Regular_11">Label(start)</samp></code>并开始下一轮循环。我们不会再次执行<code><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><init></samp></code>，因为<code><samp
    class="SANS_TheSansMonoCd_W5Regular_11">Label(start)</samp></code>在<code><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><init></samp></code>之后。请注意，continue标签出现在循环体的末尾，紧接在<code><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><post></samp></code>之前，而break标签则出现在循环的最末尾，起到双重作用：既是<code><samp
    class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp></code>指令的目标，也是任何<code><samp
    class="SANS_TheSansMonoCd_W5Regular_11">break</samp></code>语句的目标。
- en: Next, let’s break down how to handle each of the three clauses in the loop header.
    The first clause can be an expression, a declaration, or nothing. If it’s a declaration
    or expression, we’ll handle it the same way as a declaration or expression outside
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop. If it’s absent,
    we won’t emit any instructions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们分析如何处理循环头中的三个子句。第一个子句可以是一个表达式、一个声明，或者什么都没有。如果它是声明或表达式，我们将像处理<code>for</code>循环外的声明或表达式一样处理它。如果没有这个子句，我们将不生成任何指令。
- en: 'The second clause is the controlling expression. If this expression is present,
    we’ll convert it to TACKY exactly like the controlling expressions in <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> loops. If it’s absent,
    the C standard says that this expression is “replaced by a nonzero constant” (section
    6.8.5.3, paragraph 2). We could just use a nonzero constant in the conditional
    jump:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个子句是控制表达式。如果这个表达式存在，我们将像处理<code>while</code>和<code>do</code>循环中的控制表达式一样，转换它为TACKY。如果缺失，C标准规定这个表达式会被“替换为一个非零常量”（第6.8.5.3节，第2段）。我们可以直接在条件跳转中使用一个非零常量：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: But this instruction doesn’t do anything; <samp class="SANS_TheSansMonoCd_W5Regular_11">Const(1)</samp>
    will never equal zero, so we’ll never jump. Instead, we’ll leave out the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> instruction entirely,
    since that’s a more efficient way to produce the same behavior.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个指令实际上什么也不做；<samp class="SANS_TheSansMonoCd_W5Regular_11">Const(1)</samp>永远不可能等于零，因此我们永远不会跳转。相反，我们将完全省略<code>JumpIfZero</code>指令，因为这种方式更高效，能实现相同的行为。
- en: 'Finally, we need to handle the third clause, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><post></samp>.
    If it’s present, we’ll convert it to TACKY; if it’s absent, we won’t emit any
    instructions.  ### <samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: switch
    Statements</samp>'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要处理第三个子句，<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><post></samp>。如果存在，我们将转换它为TACKY；如果缺失，我们将不生成任何指令。###
    <samp class="SANS_Futura_Std_Bold_B_11">额外加分：switch语句</samp>
- en: You have the option of implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    statements in this chapter. To support these statements, you’ll need to make significant
    changes to the semantic analysis stage. First, you’ll need to change the loop
    annotation pass, because <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statements can break out of <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statements as well as loops. You can’t, however, use a <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement inside a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement, so this pass will need to treat <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statements differently from <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statements.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你有机会实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">case</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    语句。为了支持这些语句，你将需要对语义分析阶段进行重大修改。首先，你需要更改循环注解阶段，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    语句可以跳出 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句以及循环。你不能在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    语句，因此这个阶段需要将 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 语句区分开来。
- en: You’ll need additional analysis, probably in a separate compiler pass, to collect
    the cases that appear inside each <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement. To generate the TACKY for a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement, you’ll need a list of all the cases in that statement. However, that
    information isn’t immediately available in the AST. The cases in a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement may be nested several layers deep, or the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statement body may not include any cases at all. You’ll need to attach that information
    to the AST in a more usable form.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要额外的分析，可能是在一个单独的编译器阶段，来收集出现在每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    语句中的所有情况。为了生成一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句的
    TACKY，你需要得到该语句中所有情况的列表。然而，这些信息在 AST（抽象语法树）中并不立即可用。一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    语句中的情况可能嵌套了多层，或者 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句的主体根本没有包含任何情况。你需要以更易用的形式将这些信息附加到
    AST 上。
- en: 'Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--switch</samp> flag
    to enable the tests for <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    statements:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">--switch</samp> 标志来启用对 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 语句的测试：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Or enable every extra credit test with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    flag, as usual.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，像往常一样，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    标志来启用所有额外的学分测试。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you implemented your last set of control-flow statements. You
    added support for three different loop statements, plus <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements.
    You implemented a new semantic analysis pass to associate <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements with
    their enclosing loops, and you saw how to convert each of these complex structures
    into a list of TACKY instructions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你实现了最后一组控制流语句。你为三种不同的循环语句添加了支持，并增加了对 <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> 语句的支持。你实现了一个新的语义分析阶段，将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    语句与它们所包含的循环关联，并且你学会了如何将这些复杂的结构转换为一系列 TACKY 指令。
- en: 'Although we’re done with control-flow *statements*, you’ll add support for
    one more control-flow *expression* in the next chapter: function calls. You’ll
    learn about the calling conventions that dictate how function calls work in assembly
    and write a simple type checker. Best of all, you’ll end the chapter by compiling
    “Hello, World!”'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经完成了控制流的*语句*，但在下一章中，你将为一种新的控制流*表达式*添加支持：函数调用。你将学习关于调用约定的知识，这些约定决定了在汇编语言中函数调用的工作原理，并编写一个简单的类型检查器。最棒的是，你将通过编译“Hello,
    World!”来结束这一章。
