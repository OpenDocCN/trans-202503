- en: '**17'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**17**'
- en: FILESYSTEMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统**
- en: '*“So, you’re the UNIX guru.” At the time, Randy was still stupid enough to
    be flattered by this attention, when he should have recognized them as bone-chilling
    words.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*“所以，你是UNIX专家。”当时，兰迪仍然傻到会因为这种关注而感到受宠若惊，而他应该意识到这些话语其实是一种令人毛骨悚然的警告。*'
- en: —Neal Stephenson*, Cryptonomicon
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —尼尔·斯蒂芬森*, 《密码锁》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: This chapter teaches you how to use the stdlib’s Filesystem library to perform
    operations on filesystems, such as manipulating and inspecting files, enumerating
    directories, and interoperating with file streams.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何使用stdlib的文件系统库对文件系统执行操作，如操作和检查文件、列举目录以及与文件流互操作。
- en: The stdlib and Boost contain Filesystem libraries. The stdlib’s Filesystem library
    grew out of Boost’s, and accordingly they’re largely interchangeable. This chapter
    focuses on the stdlib implementation. If you’re interested in learning more about
    Boost, refer to the Boost Filesystem documentation. Boost and stdlib’s implementations
    are mostly identical.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: stdlib和Boost包含文件系统库。stdlib的文件系统库起源于Boost的，因此它们在很大程度上是可以互换的。本章将重点介绍stdlib的实现。如果你有兴趣了解更多关于Boost的信息，请参考Boost文件系统文档。Boost和stdlib的实现大致相同。
- en: '**NOTE**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The C++ Standard has a history of subsuming Boost libraries. This allows the
    C++ community to gain experience with new features in Boost before going through
    the more arduous process of including the features in the C++ Standard.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*C++标准有一个将Boost库纳入标准的历史。这允许C++社区在将新特性纳入C++标准之前，先通过Boost获得这些特性的使用经验。*'
- en: '**Filesystem Concepts**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文件系统概念**'
- en: Filesystems model several important concepts. The central entity is the file.
    A *file* is a filesystem object that supports input and output and holds data.
    Files exist in containers called *directories*, which can be nested within other
    directories. For simplicity, directories are considered files. The directory containing
    a file is called that file’s *parent directory*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统模型有几个重要概念。核心实体是文件。一个*文件*是一个支持输入输出并存储数据的文件系统对象。文件存在于名为*目录*的容器中，目录可以嵌套在其他目录中。为了简化，目录被视为文件。包含文件的目录称为该文件的*父目录*。
- en: A path is a string that identifies a specific file. Paths begin with an optional
    *root name*, which is an implementation-specific string, such as *C:* or *//localhost*
    on Windows followed by an optional root directory, which is another implementation-specific
    string, such as `/` on Unix-like systems. The remainder of the path is a sequence
    of directories separated by implementation-defined separators. Optionally, paths
    terminate in a non-directory file. Paths can contain the special names “`.`” and
    “`..`”, which mean current directory and parent directory, respectively.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 路径是一个字符串，用于标识特定的文件。路径以一个可选的*根名称*开始，这是一个特定于实现的字符串，例如Windows上的*C:*或*//localhost*，接着是一个可选的根目录，这是另一个特定于实现的字符串，例如类Unix系统上的`/`。路径的其余部分是由实现定义的分隔符分隔的目录序列。路径可以选择性地以非目录文件终止。路径可以包含特殊名称“`.`”和“`..`”，分别表示当前目录和父目录。
- en: A *hard link* is a directory entry that assigns a name to an existing file,
    and a *symbolic link* (or *symlink*) assigns a name to a path (which might or
    might not exist). A path whose location is specified in relation to another path
    (usually the current directory) is called a *relative path*, and a *canonical
    path* unambiguously identifies a file’s location, doesn’t contain the special
    names “**.**” and “**..**”, and doesn’t contain any symbolic links. An *absolute
    path* is any path that unambiguously identifies a file’s location. A major difference
    between a canonical path and an absolute path is that a canonical path cannot
    contain the special names “**.**” and “**..**”.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*硬链接*是一个目录条目，它为一个现有的文件分配了一个名称，*符号链接*（或*符号链接*）为一个路径（该路径可能存在，也可能不存在）分配一个名称。一个以另一个路径（通常是当前目录）为参考点的路径称为*相对路径*，而*规范路径*明确标识了文件的位置，不包含特殊名称“**.**”和“**..**”，且不包含任何符号链接。*绝对路径*是任何明确标识文件位置的路径。规范路径与绝对路径的一个主要区别是，规范路径不能包含特殊名称“**.**”和“**..**”。
- en: '**WARNING**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*The stdlib filesystem might not be available if the target platform doesn’t
    offer a hierarchical filesystem.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果目标平台不提供分层文件系统，stdlib文件系统可能不可用。*'
- en: '**std::filesystem::path**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**std::filesystem::path**'
- en: The `std::filesystem::path` is the Filesystem library’s class for modeling a
    path, and you have many options for constructing paths. Perhaps the two most common
    are the default constructor, which constructs an empty path, and the constructor
    taking a string type, which creates the path indicated by the characters in the
    string. Like all other filesystem classes and functions, the `path` class resides
    in the `<filesystem>` header.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::filesystem::path` 是文件系统库中用于建模路径的类，你有许多构造路径的选项。也许最常见的两种方式是默认构造函数，它构造一个空路径，以及接受字符串类型的构造函数，它创建由字符串中的字符表示的路径。像所有其他文件系统类和函数一样，`path`
    类位于 `<filesystem>` 头文件中。'
- en: In this section, you’ll learn how to construct a path from a `string` representation,
    decompose it into constituent parts, and modify it. In many common system- and
    application-programming contexts, you’ll need to interact with files. Because
    each operating system has a unique representation for filesystems, the stdlib’s
    Filesystem library is a welcome abstraction that allows you to write cross-platform
    code easily.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何从 `string` 表示构造路径，将其分解为组成部分，并进行修改。在许多常见的系统和应用程序编程上下文中，你需要与文件进行交互。由于每个操作系统对文件系统的表示都是独特的，stdlib
    的文件系统库提供了一个欢迎的抽象，使得你能够轻松编写跨平台代码。
- en: '***Constructing Paths***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构造路径***'
- en: The `path` class supports comparison with other `path` objects and with `string`
    objects using the `operator==`. But if you just want to check whether the `path`
    is empty, it offers an `empty` method that returns a Boolean. [Listing 17-1](ch17.xhtml#ch17ex01)
    illustrates how to construct two `path`s (one empty and one non-empty) and test
    them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`path` 类支持与其他 `path` 对象以及与 `string` 对象进行比较，使用 `operator==`。但是，如果你只是想检查 `path`
    是否为空，它提供了一个返回布尔值的 `empty` 方法。[清单 17-1](ch17.xhtml#ch17ex01)展示了如何构造两个 `path`（一个为空，一个非空）并对其进行测试。'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 17-1: Constructing `std::filesystem::path`*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-1：构造 `std::filesystem::path`*'
- en: 'You construct two paths: one with the default constructor ➊ and one referring
    to `/etc/shadow` ➋. Because you default construct it, the `empty` method of `empty_path`
    returns `true` ➌. The `shadow_path` equals a `string` containing `/etc/shadow`,
    because you construct it with the same contents ➍.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造了两个路径：一个使用默认构造函数 ➊，另一个指向 `/etc/shadow` ➋。由于你使用了默认构造函数，`empty_path` 的 `empty`
    方法返回 `true` ➌。`shadow_path` 等于一个包含 `/etc/shadow` 的 `string`，因为你使用相同的内容构造了它 ➍。
- en: '**Decomposing Paths**'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**分解路径**'
- en: 'The `path` class contains some decomposition methods that are, in effect, specialized
    string manipulators that allow you to extract components of the path, for example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`path` 类包含一些分解方法，这些方法实际上是专门的字符串处理工具，允许你提取路径的各个组成部分，例如：'
- en: '`root_name()` returns the root name.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root_name()` 返回根名称。'
- en: '`root_directory()` returns the root directory.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root_directory()` 返回根目录。'
- en: '`root_path()` returns the root path.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root_path()` 返回根路径。'
- en: '`relative_path()` returns a path relative to the root.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`relative_path()` 返回相对于根路径的路径。'
- en: '`parent_path()` returns the parent path.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent_path()` 返回父路径。'
- en: '`filename()` returns the filename component.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename()` 返回文件名部分。'
- en: '`stem()` returns the filename stripped of its extension.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stem()` 返回去除扩展名后的文件名。'
- en: '`extension()` returns the extension.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extension()` 返回扩展名。'
- en: '[Listing 17-2](ch17.xhtml#ch17ex02) provides the values returned by each of
    these methods for a path pointing to a very important Windows system library,
    `kernel32.dll`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-2](ch17.xhtml#ch17ex02)提供了这些方法返回的值，针对的是指向一个非常重要的 Windows 系统库 `kernel32.dll`
    的路径。'
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 17-2: A program printing various decompositions of a path*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-2：打印路径各种分解结果的程序*'
- en: You construct a path to kernel32 using a raw string literal to avoid having
    to escape the backslashes ➊. You extract the root name ➋, the root directory ➌,
    and the root path of kernel32 ➍ and output them to stdout. Next, you extract the
    relative path, which displays the path relative to the root `C:\` ➎. The parent
    path is the path of `kernel32.dll`’s parent, which is simply the directory containing
    it ➏. Finally, you extract the filename ➐, its stem ➑, and its extension ➒.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用原始字符串字面量构造指向 kernel32 的路径，以避免需要转义反斜杠 ➊。你提取根名称 ➋、根目录 ➌ 和 kernel32 的根路径 ➍ 并将它们输出到标准输出。接下来，你提取相对路径，它显示的是相对于根路径
    `C:\` 的路径 ➎。父路径是 `kernel32.dll` 的父路径，它只是包含该文件的目录 ➏。最后，你提取文件名 ➐、文件名主体 ➑ 和扩展名 ➒。
- en: Notice that you don’t need to run [Listing 17-2](ch17.xhtml#ch17ex02) on any
    particular operating system. None of the decomposition methods require that the
    path actually point to an existing file. You simply extract components of the
    path’s contents, not the pointed-to file. Of course, different operating systems
    will yield different results, especially with respect to the delimiters (which
    are, for example, forward slashes on Linux).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不需要在任何特定操作系统上运行[示例 17-2](ch17.xhtml#ch17ex02)。没有任何解析方法要求路径实际指向一个存在的文件。你只是提取路径内容的组成部分，而不是指向的文件。当然，不同的操作系统会产生不同的结果，特别是对于分隔符（例如，在
    Linux 上是正斜杠）。
- en: '**NOTE**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*[Listing 17-2](ch17.xhtml#ch17ex02) illustrates that `std::filesystem::path`
    has an `operator<<` that prints quotation marks at the beginning and end of its
    path. Internally, it uses `std::quoted`, a class template in the <iomanip> header
    that facilitates the insertion and extraction of quoted strings. Also, recall
    that you must escape the backslash in a string literal, which is why you see two
    rather than one in the paths embedded in the source code.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*[示例 17-2](ch17.xhtml#ch17ex02) 演示了 `std::filesystem::path` 有一个 `operator<<`，它在路径的开头和结尾打印引号。在内部，它使用了
    `<iomanip>` 头文件中的模板类 `std::quoted`，该类简化了带引号字符串的插入和提取。此外，记住在字符串字面量中必须转义反斜杠，这就是为什么你在源代码中看到路径中有两个反斜杠，而不是一个的原因。*'
- en: '***Modifying Paths***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修改路径***'
- en: 'In addition to decomposition methods, `path` offers several *modifier methods*,
    which allow you to modify various characteristics of a path:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了解析方法外，`path` 还提供了几个 *修改器方法*，允许你修改路径的各种特征：
- en: '`clear()` empties the `path`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()` 清空 `path`。'
- en: '`make_preferred()` converts all the directory separators to the implementation-preferred
    directory separator. For example, on Windows this converts the generic separator
    / to the system-preferred separator \.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make_preferred()` 将所有目录分隔符转换为实现首选的目录分隔符。例如，在 Windows 上，它将通用分隔符 `/` 转换为系统首选的反斜杠
    `\`。'
- en: '`remove_filename()` removes the filename portion of the path.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_filename()` 移除路径中的文件名部分。'
- en: '`replace_filename(p)` replaces the `path’s` filename with that of another path
    p.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace_filename(p)` 用路径 p 替换 `path` 的文件名。'
- en: '`replace_extension(p)` replaces the `path’s` extension with that of another
    path p.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace_extension(p)` 用路径 p 替换 `path` 的扩展名。'
- en: '`remove_extension()` removes the extension portion of the path.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_extension()` 移除路径中的扩展名部分。'
- en: '[Listing 17-3](ch17.xhtml#ch17ex03) illustrates how to manipulate a path using
    several modifier methods.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-3](ch17.xhtml#ch17ex03) 演示了如何使用多个修改器方法操作路径。'
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 17-3: Manipulating a path using modifier methods. (Output is from
    a Windows 10 x64 system.)*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 17-3：使用修改器方法操作路径。（输出来自 Windows 10 x64 系统。）*'
- en: As in [Listing 17-2](ch17.xhtml#ch17ex02), you construct a `path` to kernel32,
    although this one is non-`const` because you’re about to modify it ➊. Next, you
    convert all the directory separators to the system’s preferred directory separator
    using `make_preferred`. [Listing 17-3](ch17.xhtml#ch17ex03) shows output from
    a Windows 10 x64 system, so it has converted from slashes (`/`) to backslashes
    (`\`) ➋. Using `replace_file``name`, you replace the filename from `kernel32.dll`
    to `win32kfull.sys` ➌. Notice again that the file described by this path doesn’t
    need to exist on your system; you’re just manipulating the path. Finally, you
    remove the filename using the `remove_filename` method ➍ and then empty the `path`’s
    contents entirely using clear ➎.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[示例 17-2](ch17.xhtml#ch17ex02)中所示，你构造了一个指向 kernel32 的 `path`，尽管这个路径是非`const`的，因为你将要修改它
    ➊。接下来，使用 `make_preferred` 将所有目录分隔符转换为系统首选的目录分隔符。[示例 17-3](ch17.xhtml#ch17ex03)
    显示了来自 Windows 10 x64 系统的输出，因此它将斜杠 (`/`) 转换为反斜杠 (`\`) ➋。使用 `replace_filename`，你将文件名从
    `kernel32.dll` 替换为 `win32kfull.sys` ➌。再次注意，由该路径描述的文件不需要在你的系统上实际存在；你只是操作路径。最后，使用
    `remove_filename` 方法移除文件名 ➍，然后使用 `clear` 完全清空 `path` 的内容 ➎。
- en: '***Summary of Filesystem Path Methods***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件系统路径方法总结***'
- en: '[Table 17-1](ch17.xhtml#ch17tab01) contains a partial listing of the available
    methods of `path`. Note that `p`, `p1`, and `p2` are `path` objects and `s` is
    a `stream` in the table.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 17-1](ch17.xhtml#ch17tab01) 包含了 `path` 的可用方法的部分列表。注意表中 `p`、`p1` 和 `p2` 是
    `path` 对象，而 `s` 是 `stream`。'
- en: '**Table 17-1:** A Summary of `std::filestystem::path` Operations'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 17-1：** `std::filestystem::path` 操作总结'
- en: '| **Operation** | **Notes** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `path{}` | Constructs an empty path. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `path{}` | 构造一个空路径。 |'
- en: '| `Path{` s`, [`f`] }` | Constructs a path from the string type s; f is an
    optional `path::format` type that defaults to the implementation-defined pathname
    format. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `Path{` s`, [`f`] }` | 从字符串类型 s 构造路径；f 是一个可选的 `path::format` 类型，默认为实现定义的路径格式。
    |'
- en: '| `Path{` p `}`p1 `=` p2 | Copy construction/assignment. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `Path{` p `}`p1 `=` p2 | 复制构造/赋值。 |'
- en: '| `Path{ move(`p`) }`p1 `= move(`p2`)` | Move construction/assignment. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `Path{ move(`p`) }`p1 `= move(`p2`)` | 移动构造/赋值。 |'
- en: '| p`.assign(`s`)` | Assigns p to s, discarding current contents. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| p`.assign(`s`)` | 将 p 赋值给 s，丢弃当前内容。 |'
- en: '| p`.append(`s`)`p `/` s | Appends s to p, including the appropriate separator,
    `path::preferred_separator`. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| p`.append(`s`)`p `/` s | 将 s 追加到 p 后，包含适当的分隔符 `path::preferred_separator`。
    |'
- en: '| p`.concat(`s`)`p `+` s | Appends s to p without including a separator. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| p`.concat(`s`)`p `+` s | 将 s 追加到 p 后，不包括分隔符。 |'
- en: '| p`.clear()` | Erases the contents. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| p`.clear()` | 清除内容。 |'
- en: '| p`.empty()` | Returns true if p is empty. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| p`.empty()` | 如果 p 为空，则返回 true。 |'
- en: '| p`.make_preferred()` | Converts all the directory separators to the implementation-preferred
    directory separator. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| p`.make_preferred()` | 将所有目录分隔符转换为实现首选的目录分隔符。 |'
- en: '| p`.remove_filename()` | Removes the filename portion. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| p`.remove_filename()` | 移除文件名部分。 |'
- en: '| p1`.replace_filename(`p2`)` | Replaces the filename of p1 with that of p2.
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| p1`.replace_filename(`p2`)` | 将 p1 的文件名替换为 p2 的文件名。 |'
- en: '| p1`.replace_extension(`p2`)` | Replaces the extension of p1 with that of
    p2. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| p1`.replace_extension(`p2`)` | 将 p1 的扩展名替换为 p2 的扩展名。 |'
- en: '| p`.root_name()` | Returns the root name. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| p`.root_name()` | 返回根名称。 |'
- en: '| p`.root_directory()` | Returns the root directory. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| p`.root_directory()` | 返回根目录。 |'
- en: '| p`.root_path()` | Returns the root path. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| p`.root_path()` | 返回根路径。 |'
- en: '| p`.relative_path()` | Returns the relative path. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| p`.relative_path()` | 返回相对路径。 |'
- en: '| p`.parent_path()` | Returns the parent path. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| p`.parent_path()` | 返回父路径。 |'
- en: '| p`.filename()` | Returns the filename. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| p`.filename()` | 返回文件名。 |'
- en: '| p`.stem()` | Returns the stem. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| p`.stem()` | 返回 stem 部分。 |'
- en: '| p`.extension()` | Returns the extension. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| p`.extension()` | 返回扩展名。 |'
- en: '| p`.has_root_name()` | Returns true if p has a root name. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| p`.has_root_name()` | 如果 p 有根名称，则返回 true。 |'
- en: '| p`.has_root_directory()` | Returns true if p has a root directory. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| p`.has_root_directory()` | 如果 p 有根目录，则返回 true。 |'
- en: '| p`.has_root_path()` | Returns true if p has a root path. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| p`.has_root_path()` | 如果 p 有根路径，则返回 true。 |'
- en: '| p`.has_relative_path()` | Returns true if p has a relative path. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| p`.has_relative_path()` | 如果 p 有相对路径，则返回 true。 |'
- en: '| p`.has_parent_path()` | Returns true if p has a parent path. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| p`.has_parent_path()` | 如果 p 有父路径，则返回 true。 |'
- en: '| p`.has_filename()` | Returns true if p has a filename. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| p`.has_filename()` | 如果 p 有文件名，则返回 true。 |'
- en: '| p`.has_stem()` | Returns true if p has a stem. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| p`.has_stem()` | 如果 p 有 stem 部分，则返回 true。 |'
- en: '| p`.has_extension()` | Returns true if p has an extension. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| p`.has_extension()` | 如果 p 有扩展名，则返回 true。 |'
- en: '| p`.c_str()`p`.native()` |  Returns the native-string representation of p.  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| p`.c_str()`p`.native()` | 返回 p 的本地字符串表示。 |'
- en: '| p`.begin()`p`.end()` | Accesses the elements of a path sequentially as a
    half-open range. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| p`.begin()`p`.end()` | 顺序访问路径的元素，作为半开区间。 |'
- en: '| s `<<` p | Writes p into s. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| s `<<` p | 将 p 写入 s。 |'
- en: '| s `>>` p | Reads s into p. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| s `>>` p | 将 s 读入 p。 |'
- en: '| p1`.swap(`p2`)``swap(`p1`,` p2`)` | Exchanges each element of p1 with the
    elements of p2. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| p1`.swap(`p2`)``swap(`p1`,` p2`)` | 交换 p1 和 p2 中的每个元素。 |'
- en: '| p1 `==` p2p1 `!=` p2p1 `>` p2p1 `>=` p2p1 `<` p2p1 `<=` p2 | Lexicographically
    compares two paths p1 and p2. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| p1 `==` p2p1 `!=` p2p1 `>` p2p1 `>=` p2p1 `<` p2p1 `<=` p2 | 按字典顺序比较两个路径
    p1 和 p2。 |'
- en: '**Files and Directories**'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文件与目录**'
- en: The `path` class is the central element of the Filesystem library, but none
    of its methods actually interact with the filesystem. Instead, the `<filesystem>`
    header contains non-member functions to do this. Think of `path` objects as the
    way you declare which filesystem components you want to interact with and think
    of the `<filesystem>` header as containing the functions that perform work on
    those components.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`path` 类是文件系统库的核心元素，但它的任何方法都不会与文件系统直接交互。相反，`<filesystem>` 头文件包含了非成员函数来执行这些操作。可以把
    `path` 对象看作是声明你想与之交互的文件系统组件，而 `<filesystem>` 头文件则包含了执行这些操作的函数。'
- en: These functions have friendly error-handling interfaces and allow you to break
    paths into, for example, directory name, filename, and extension. Using these
    functions, you have many tools for interacting with the files in your environment
    without having to use an operating-specific application programming interface.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数具有友好的错误处理接口，允许你将路径拆分成例如目录名、文件名和扩展名等部分。使用这些函数，你可以使用许多工具与环境中的文件进行交互，而无需使用特定操作系统的应用程序编程接口。
- en: '***Error Handling***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***错误处理***'
- en: 'Interacting with the environment’s filesystem involves the potential for errors,
    such as files not found, insufficient permissions, or unsupported operations.
    Therefore, each non-member function in the Filesystem library that interacts with
    the filesystem must convey error conditions to the caller. These non-member functions
    provide two options: throw an exception or set an error variable.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与环境文件系统交互可能会导致错误，例如找不到文件、权限不足或不支持的操作。因此，文件系统库中每个与文件系统交互的非成员函数必须向调用者传达错误条件。这些非成员函数提供了两种选项：抛出异常或设置错误变量。
- en: 'Each function has two overloads: one that allows you to pass a reference to
    a `std::system_error` and one that omits this parameter. If you provide the reference,
    the function will set the `system_error` equal to an error condition, should one
    occur. If you don’t provide this reference, the function will throw a `std::filesystem::filesystem_error`
    (an exception type inheriting from `std::system_error`) instead.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数有两个重载版本：一个允许你传递一个 `std::system_error` 的引用，另一个则省略该参数。如果你提供引用，函数会将 `system_error`
    设置为一个错误条件（如果发生错误）。如果不提供引用，函数将抛出一个 `std::filesystem::filesystem_error`（继承自 `std::system_error`
    的异常类型）。
- en: '***Path-Composing Functions***'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***路径组合函数***'
- en: 'As an alternative to using the constructor of `path`, you can construct various
    kinds of paths:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用 `path` 构造函数的替代方法，你可以构造各种类型的路径：
- en: '`absolute(`p, `[`ec`])` returns an absolute path referencing the same location
    as p but where `is_absolute()` is true.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`absolute(`p, `[`ec`])` 返回一个绝对路径，指向与 p 相同的位置，但 `is_absolute()` 返回 true。'
- en: '`canonical(`p, `[`ec`])` returns a canonical path referencing the same location
    as p.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canonical(`p, `[`ec`])` 返回一个规范路径，指向与 p 相同的位置。'
- en: '`current_path([`ec`])` returns the current path.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current_path([`ec`])` 返回当前路径。'
- en: '`relative(`p, `[`base`], [`ec`])` returns a path where p is made relative to
    `base`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`relative(`p, `[`base`], [`ec`])` 返回一个相对路径，其中 p 相对于 `base`。'
- en: '`temp_directory_path([`ec`])` returns a directory for temporary files. The
    result is guaranteed to be an existing directory.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`temp_directory_path([`ec`])` 返回一个用于临时文件的目录。结果保证是一个已存在的目录。'
- en: Note that `current_path` supports an overload so you can set the current directory
    (as in cd or chdir on Posix). Simply provide a path argument, as in `current_path(`p,
    `[`ec`])`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`current_path`支持重载，因此你可以设置当前目录（类似于 Posix 系统中的 cd 或 chdir）。只需提供一个路径参数，例如
    `current_path(`p, `[`ec`])`。
- en: '[Listing 17-4](ch17.xhtml#ch17ex04) illustrates several of these functions
    in action.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-4](ch17.xhtml#ch17ex04)展示了这些函数的应用实例。'
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 17-4: A program using several path composing functions. (Output is
    from a Windows 10 x64 system.)*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-4：一个使用多个路径组合函数的程序。（输出来自 Windows 10 x64 系统。）*'
- en: 'You construct a path using `temp_directory_path`, which returns the system’s
    directory for temporary files ➊, and then use `relative` to determine its relative
    path ➋. After printing the temporary path ➌, `is_absolute` illustrates that this
    path is absolute ➍. Next, you print the current path ➎ and the temporary directory’s
    path relative to the current path ➏. Because this path is relative, `is_absolute`
    returns `false` ➐. Once you change the path to the temporary path ➑, you then
    print the current directory ➒. Of course, your output will look different from
    the output in [Listing 17-4](ch17.xhtml#ch17ex04), and you might even get an `exception`
    if your system doesn’t support certain operations ➓. (Recall the warning at the
    beginning of the chapter: the C++ Standard allows that some environments might
    not support some or all of the filesystem library.)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `temp_directory_path` 构造路径，它返回系统的临时文件目录 ➊，然后使用 `relative` 确定其相对路径 ➋。打印临时路径
    ➌ 后，`is_absolute` 说明该路径是绝对路径 ➍。接着，打印当前路径 ➎ 以及临时目录相对于当前路径的路径 ➏。由于这是相对路径，`is_absolute`
    返回 `false` ➐。一旦你将路径更改为临时路径 ➑，然后打印当前目录 ➒。当然，你的输出可能与 [清单 17-4](ch17.xhtml#ch17ex04)
    中的输出不同，如果系统不支持某些操作，甚至可能会出现 `exception` ➓。（回想一下章节开始时的警告：C++ 标准允许某些环境可能不支持文件系统库中的部分或全部功能。）
- en: '***Inspecting File Types***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查文件类型***'
- en: 'You can inspect a file’s attributes given a path by using the following functions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下函数检查文件的属性：
- en: '`is_block_file(`p, `[`ec`])` determines if p is a *block file*, a special file
    in some operating systems (for example, block devices in Linux that allow you
    to transfer randomly accessible data in fixed-size blocks).'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_block_file(`p, `[`ec`])` 用于判断 p 是否是 *块文件*，这是一种在某些操作系统中使用的特殊文件（例如，Linux
    中的块设备，允许你以固定大小的块传输随机可访问的数据）。'
- en: '`is_character_file(`p, `[`ec`])` determines if p is a *character file*, a special
    file in some operating systems (for example, character devices in Linux that allow
    you to send and receive single characters).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_character_file(`p, `[`ec`])` 用于判断 p 是否是 *字符文件*，这是一种在某些操作系统中使用的特殊文件（例如，Linux
    中的字符设备，允许你发送和接收单个字符）。'
- en: '`is_regular_file(`p, `[`ec`])` determines p is a regular file.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_regular_file(`p, `[`ec`])` 用于判断 p 是否是常规文件。'
- en: '`is_symlink(`p, `[`ec`])` determines if p is a symlink, which is a reference
    to another file or directory.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_symlink(`p, `[`ec`])` 用于判断 p 是否是符号链接，它是指向另一个文件或目录的引用。'
- en: '`is_empty(`p, `[`ec`])` determines if p is either an empty file or an empty
    directory.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_empty(`p, `[`ec`])` 用于判断 p 是否是一个空文件或空目录。'
- en: '`is_directory(`p, `[`ec`])` determines if p is a directory.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_directory(`p, `[`ec`])` 用于判断 p 是否是一个目录。'
- en: '`is_fifo(`p, `[`ec`])` determines if p is a *named pipe*, a special kind of
    interprocess communication mechanism in many operating systems.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_fifo(`p, `[`ec`])` 用于判断 p 是否是 *命名管道*，这是一种在许多操作系统中使用的特殊进程间通信机制。'
- en: '`is_socket(`p, `[`ec`])` determines if p is a *socket*, another special kind
    of interprocess communication mechanism in many operating systems.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_socket(`p, `[`ec`])` 用于判断 p 是否是 *套接字*，这也是许多操作系统中使用的另一种特殊进程间通信机制。'
- en: '`is_other(`p, `[`ec`])` determines if p is some kind of file other than a regular
    file, a directory, or a symlink.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_other(`p, `[`ec`])` 用于判断 p 是否是除常规文件、目录或符号链接之外的某种文件。'
- en: '[Listing 17-5](ch17.xhtml#ch17ex05) uses `is_directory` and `is_regular_file`
    to inspect four different paths.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 17-5](ch17.xhtml#ch17ex05) 使用 `is_directory` 和 `is_regular_file` 来检查四个不同的路径。'
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 17-5: A program inspecting four iconic Windows and Linux paths with
    `is_director``y` and `is_regular_file`.*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 17-5：一个使用 `is_directory` 和 `is_regular_file` 检查四个典型的 Windows 和 Linux
    路径的程序。*'
- en: 'On a Windows 10 x64 machine, running the program in [Listing 17-5](ch17.xhtml#ch17ex05)
    yielded the following output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在一台 Windows 10 x64 机器上，运行 [Listing 17-5](ch17.xhtml#ch17ex05) 程序输出了以下结果：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And on an Ubuntu 18.04 x64 machine, running the program in [Listing 17-5](ch17.xhtml#ch17ex05)
    yielded the following output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在一台 Ubuntu 18.04 x64 机器上，运行 [Listing 17-5](ch17.xhtml#ch17ex05) 程序输出了以下结果：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'First, you define the `describe` function, which takes a single `path` ➊. After
    printing the path, you also print whether the path is a directory ➋ or a regular
    file ➌. Within `main`, you pass four different paths to `describe`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你定义了 `describe` 函数，它接受一个单一的 `path` ➊ 参数。打印路径后，你还会打印该路径是否是一个目录 ➋ 或常规文件 ➌。在
    `main` 中，你传递了四个不同的路径给 `describe`：
- en: '`C:/Windows/System32/kernel32.dll` ➍'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:/Windows/System32/kernel32.dll` ➍'
- en: '`C:/Windows/System32/` ➎'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:/Windows/System32/` ➎'
- en: '`/bin/bash` ➏'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin/bash` ➏'
- en: '`/bin/` ➐'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin/` ➐'
- en: Note that the result is operating system specific.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结果是操作系统特定的。
- en: '***Inspecting Files and Directories***'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查文件和目录***'
- en: 'You can inspect various filesystem attributes using the following functions:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下函数检查各种文件系统属性：
- en: '`current_path([`p`], [`ec`])`, which, if p is provided, sets the program’s
    current path to p; otherwise, it returns the program’s current path.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current_path([`p`], [`ec`])`，如果提供了 p，则将程序的当前路径设置为 p；否则，它返回程序的当前路径。'
- en: '`exists(`p, `[`ec`])` returns whether a file or directory exists at p.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exists(`p, `[`ec`])` 返回文件或目录是否存在于 p。'
- en: '`equivalent(`p1, p2, `[`ec`])` returns whether p1 and p2 refer to the same
    file or directory.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equivalent(`p1, p2, `[`ec`])` 返回 p1 和 p2 是否指向同一个文件或目录。'
- en: '`file_size(`p, `[`ec`])` returns the size in bytes of the regular file at p.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_size(`p, `[`ec`])` 返回位于 p 的常规文件的字节大小。'
- en: '`hard_link_count(`p, `[`ec`])` returns the number of hard links for p.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hard_link_count(`p, `[`ec`])` 返回 p 的硬链接数量。'
- en: '`last_write_time(`p, `[`t`] [`ec`])`, which, if t`ec``t` is provided, sets
    p’s last modified time to t; otherwise, it returns the last time p was modified.
    (t is a `std::chrono::time_point`.)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last_write_time(`p, `[`t`] [`ec`])`，如果提供了 t`ec``t`，则将 p 的最后修改时间设置为 t；否则，它会返回
    p 的最后修改时间。（t 是一个 `std::chrono::time_point`。）'
- en: '`permissions(`p, prm, `[`ec`])` sets p’s permissions. prm is of type `std::filesystem::perms`,
    which is an enum class modeled after POSIX permission bits. (Refer to [fs.enum.perms].)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permissions(`p, prm, `[`ec`])` 设置 p 的权限。 prm 是 `std::filesystem::perms` 类型，这是一个基于
    POSIX 权限位模型的枚举类。（参考 [fs.enum.perms]。）'
- en: '`read_symlink(`p, `[`ec`])` returns the target of the symlink p.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read_symlink(`p, `[`ec`])` 返回符号链接 p 的目标。'
- en: '`space(`p, `[`ec`])` returns space information about the filesystem p occupies
    in the form of a `std::filesystem::space_info`. This POD contains three fields:
    capacity (the total size), `free` (the free space), and `available` (the free
    space available to a non-privileged process). All are an unsigned integer type,
    measured in bytes.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`space(`p, `[`ec`])` 返回文件系统 p 占用的空间信息，形式为 `std::filesystem::space_info`。该 POD
    包含三个字段：容量（总大小）、`free`（可用空间）和 `available`（可供非特权进程使用的可用空间）。所有字段都是无符号整数类型，以字节为单位度量。'
- en: '`status(`p, `[`ec`])` returns the type and attributes of the file or directory
    p in the form of a `std::filesystem::file_status`. This class contains a `type`
    method that accepts no parameters and returns an object of type `std::filesystem::file_type`,
    which is an enum class that takes values describing a file’s type, such as `not_found,
    regular, directory`. The `symlink file_status` class also offers a `permissions`
    method that accepts no parameters and returns an object of type `std::filesystem::perms`.
    (Refer to [fs.class.file_status] for details.)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status(`p, `[`ec`])` 返回文件或目录 p 的类型和属性，形式为 `std::filesystem::file_status`。该类包含一个
    `type` 方法，该方法不接受任何参数，返回一个 `std::filesystem::file_type` 类型的对象，这个枚举类包含描述文件类型的值，如
    `not_found`、`regular`、`directory` 等。`symlink file_status` 类还提供一个 `permissions`
    方法，不接受任何参数，返回一个 `std::filesystem::perms` 类型的对象。（详细信息参考 [fs.class.file_status]。）'
- en: '`symlink_status(`p, `[`ec`])` is like a status that won’t follow symlinks.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symlink_status(`p, `[`ec`])` 返回状态，不跟随符号链接。'
- en: If you’re familiar with Unix-like operating systems, you’ve no doubt used the
    `ls` (short for “list”) program many times to enumerate files and directories.
    On DOS-like operating systems (including Windows), you have the analogous `dir`
    command. You’ll use several of these functions later in the chapter (in [Listing
    17-7](ch17.xhtml#ch17ex07)) to build your own simple listing program.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉类似 Unix 的操作系统，肯定多次使用过 `ls`（“列出”命令）来列举文件和目录。在类似 DOS 的操作系统（包括 Windows）中，你可以使用类似的
    `dir` 命令。稍后你将在本章中（在 [Listing 17-7](ch17.xhtml#ch17ex07)）使用这些函数来构建自己的简单列出程序。
- en: Now that you know how to inspect files and directories, let’s turn to how you
    can manipulate the files and directories your paths refer to.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何检查文件和目录，让我们来看一下如何操作路径所指向的文件和目录。
- en: '***Manipulating Files and Directories***'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***操作文件和目录***'
- en: 'Additionally, the Filesystem library contains a number of methods for manipulating
    files and directories:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，文件系统库包含许多操作文件和目录的方法：
- en: '`copy(`p1, p2, `[`opt`], [`ec`])` copies files or directories from p1 to p2.
    You can provide a `std::filesystem::copy_options` `opt` to customize the behavior
    of `copy_file`. This `enum` class can take several values, including none (report
    an error if the destination already exists), `skip_existing` (to keep existing),
    `overwrite_existing` (to overwrite), and `update_existing` (to overwrite if p1
    is newer). (Refer to **[**fs.enum.copy.opts**]** for details.)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy(`p1, p2, `[`opt`], [`ec`])` 将文件或目录从 p1 复制到 p2。你可以提供一个 `std::filesystem::copy_options`
    `opt` 来自定义 `copy_file` 的行为。这个 `enum` 类可以接受多个值，包括 none（如果目标已存在则报告错误）、`skip_existing`（保留现有文件）、`overwrite_existing`（覆盖现有文件）和
    `update_existing`（如果 p1 较新则覆盖）。 （详细信息参考 **[**fs.enum.copy.opts**]**。）'
- en: '`copy_file(`p1, p2, `[`opt`], [`ec`])` is like copy except it will generate
    anerror if p1 is anything but a regular file.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy_file(`p1, p2, `[`opt`], [`ec`])` 类似于 copy，除了如果 p1 不是常规文件时，它会生成错误。'
- en: '`copy_file``(`p1`,` p2`, [`opt`], [`ec`])` is like copy except it will generate
    an error if p1 is anything but a regular file.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy_file(`p1, `p2`, [`opt`], [`ec`])` 类似于 copy，除了如果 p1 不是常规文件时，它会生成错误。'
- en: '`create_directory``(`p`, [`ec`])` creates the directory p.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_directory(`p`, [`ec`])` 创建目录 p。'
- en: '`create_directories``(`p`, [`ec`])` is like calling `create_directory` recursively,
    so if a nested path contains parents that don’t exist, use this form.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_directories(`p`, [`ec`])` 类似于递归调用 `create_directory`，因此，如果嵌套路径包含不存在的父目录，使用这种形式。'
- en: '`create_hard_link``(`tgt`,` lnk`, [`ec`])` creates a hard link to tgt at lnk.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_hard_link(`tgt, `lnk`, [`ec`])` 在 lnk 处创建指向 tgt 的硬链接。'
- en: '`create_symlink``(`tgt`,` lnk`, [`ec`])` creates a symlink to tgt at lnk.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_symlink(`tgt, `lnk`, [`ec`])` 在 lnk 处创建指向 tgt 的符号链接。'
- en: '`create_directory_symlink``(`tgt`,` lnk`, [`ec`])` should be used for directories
    instead of `create_symlink`.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_directory_symlink``(`tgt`,` lnk`, [`ec`])` 应用于目录，而不是`create_symlink`。'
- en: '`remove``(`p`, [`ec`])` removes a file or empty directory p (without following
    symlinks).'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove``(`p`, [`ec`])` 删除文件或空目录p（不跟随符号链接）。'
- en: '`remove_all``(`p`, [`ec`])` removes a file or directory recursively p (without
    following symlinks).'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_all``(`p`, [`ec`])` 递归删除文件或目录p（不跟随符号链接）。'
- en: '`rename``(`p1`,` p2`, [`ec`])` renames p1 to p2.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rename``(`p1`,` p2`, [`ec`])` 将p1重命名为p2。'
- en: '`resize_file``(`p`,` new_size`, [`ec`])` changes the size of p (if it’s a regular
    file) to new_size. If this operation grows the file, zeros fill the new space.
    Otherwise, the operation trims p from the end.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resize_file``(`p`,` new_size`, [`ec`])` 将p（如果是常规文件）调整为new_size。如果该操作增加了文件大小，新的空间将被零填充。否则，操作会从文件末尾裁剪p。'
- en: You can create a program that copies, resizes, and deletes a file using several
    of these methods. [Listing 17-6](ch17.xhtml#ch17ex06) illustrates this by defining
    a function that prints file size and modification time. In `main`, the program
    creates and modifies two `path` objects, and it invokes that function after each
    modification.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个程序，使用这些方法中的几种来复制、调整大小和删除文件。[列表 17-6](ch17.xhtml#ch17ex06) 通过定义一个打印文件大小和修改时间的函数来说明这一点。在`main`函数中，程序创建并修改了两个`path`对象，并在每次修改后调用该函数。
- en: '[PRE7]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 17-6: A program illustrating several methods for interacting with
    the filesystem. (Output is from a Windows 10 x64 system.)*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17-6：一个示例程序，展示了几种与文件系统交互的方法。（输出来自Windows 10 x64系统。）*'
- en: The `write_info` function takes a single `path` parameter. You check whether
    this path exists ➊, printing an error message and returning immediately if it
    doesn’t. If the `path` does exist, you print a message indicating its last modification
    time (in hours since epoch) and its file size ➋.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`write_info`函数接受一个`path`参数。你检查该路径是否存在 ➊，如果不存在，则打印错误信息并立即返回。如果路径存在，打印消息显示其最后的修改时间（自纪元以来的小时数）和文件大小
    ➋。'
- en: Within `main`, you create a path `win_path` to `kernel32.dll` ➌ and a path to
    a nonexistent file called `REAMDE` in the filesystem’s temporary file directory
    at `reamde_path` ➍. (Recall from [Table 17-1](ch17.xhtml#ch17tab01) that you can
    use `operator/` to concatenate two path objects.) Within a `try`-`catch` block,
    you invoke `write_info` on both paths ➎➏. (If you’re using a non-Windows machine,
    you’ll get different output. You can modify `win_path` to an existing file on
    your system to follow along.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`中，你创建了一个指向`kernel32.dll`的路径`win_path` ➌ 和一个指向文件系统临时文件目录中不存在的文件`REAMDE`的路径`reamde_path`
    ➍。（回顾[表 17-1](ch17.xhtml#ch17tab01)，你可以使用`operator/`连接两个路径对象。）在`try`-`catch`块中，你对这两个路径调用`write_info`
    ➎➏。（如果你使用的是非Windows机器，输出会有所不同。你可以将`win_path`修改为系统中存在的文件来继续操作。）
- en: Next, you copy the file at `win_path` to `reamde_path` and invoke `write_info`
    on it ➐. Notice that, as opposed to earlier ➏, the file at `reamde_path` exists
    and it has the same last write time and file size as `kernel32.dll`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将`win_path`处的文件复制到`reamde_path`，并在其上调用`write_info` ➐。注意，与之前的情况 ➏ 相比，`reamde_path`处的文件存在，且它的最后写入时间和文件大小与`kernel32.dll`相同。
- en: You then resize the file at `reamde_path` to 1024 bytes and invoke `write_info`
    ➑. Notice that the last write time increased from 3657767 to 3659294 and the file
    size decreased from 720632 to 1024.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将`reamde_path`处的文件大小调整为1024字节，并调用`write_info` ➑。注意，最后的写入时间从3657767增加到3659294，文件大小从720632减少到1024。
- en: Finally, you remove the file at `reamde_path` and invoke `write_info` ➒, which
    tells you that the file again no longer exists.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你删除`reamde_path`处的文件并调用`write_info` ➒，它告诉你该文件已经不存在。
- en: '**NOTE**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*How filesystems resize files behind the scenes varies by operating system
    and is beyond the scope of this book. But you can think of how a resize operation
    might work conceptually as the `resize` operation on a `std::vector`. All the
    data at the end of the file that doesn’t fit into the file’s new size is discarded
    by the operating system.*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件系统如何在后台调整文件大小因操作系统不同而异，超出了本书的范围。但你可以从概念上理解调整大小操作，类似于对`std::vector`的`resize`操作。操作系统会丢弃文件末尾不适合新大小的数据。*'
- en: '**Directory Iterators**'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**目录迭代器**'
- en: 'The Filesystem library provides two classes for iterating over the elements
    of a directory: `std::filesystem::directory_iterator` and `std::filesystem::recursive_directory_iterator`.
    A `directory_iterator` won’t enter subdirectories, but the `recursive_directory_iterator`
    will. This section introduces the `directory_iterator`, but the `recursive_directory_iterator`
    is a drop-in replacement and supports all the following operations.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统库提供了两个类用于迭代目录中的元素：`std::filesystem::directory_iterator`和`std::filesystem::recursive_directory_iterator`。`directory_iterator`不会进入子目录，而`recursive_directory_iterator`会。
    本节介绍了`directory_iterator`，但是`recursive_directory_iterator`是一个可以替换的实现，并支持所有以下操作。
- en: '***Constructing***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构造***'
- en: 'The default constructor of `directory_iterator` produces the end iterator.
    (Recall that an input end iterator indicates when an input range is exhausted.)
    Another constructor accepts path, which indicates the directory you want to enumerate.
    Optionally, you can provide `std::filesystem::directory_options`, which is an
    `enum` class bitmask with the following constants:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`directory_iterator`的默认构造函数会生成结束迭代器。（回忆一下，输入结束迭代器表示输入范围已经用尽。）另一个构造函数接受路径，它表示你想要枚举的目录。可选地，你可以提供`std::filesystem::directory_options`，它是一个`enum`类位掩码，包含以下常量：'
- en: '`none` directs the iterator to skip directory symlinks. If the iterator encounters
    a permission denial, it produces an error.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`指示迭代器跳过目录符号链接。如果迭代器遇到权限拒绝，则会产生错误。'
- en: '`follow_directory_symlink` follows symlinks.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`follow_directory_symlink`跟随符号链接。'
- en: '`skip_permission_denied` skips directories if the iterator encounters a permission
    denial.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip_permission_denied`如果迭代器遇到权限拒绝，会跳过目录。'
- en: Additionally, you can provide a `std::error_code`, which, like all other Filesystem
    library functions that accept an `error_code`, will set this parameter rather
    than throwing an exception if an error occurs during construction.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以提供一个`std::error_code`，像所有其他接受`error_code`的文件系统库函数一样，如果在构造过程中发生错误，它会设置此参数，而不是抛出异常。
- en: '[Table 17-2](ch17.xhtml#ch17tab02) summarizes these options for constructing
    a `directory_iterator`. Note that `p` is `path` and `d` is `directory`, `op` is
    `directory_options`, and `ec` is `error_code` in the table.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 17-2](ch17.xhtml#ch17tab02)总结了构造`directory_iterator`的这些选项。请注意，表中的`p`是`path`，`d`是`directory`，`op`是`directory_options`，`ec`是`error_code`。'
- en: '**Table 17-2:** A Summary of `std::filestystem::directory_iterator` Operations'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 17-2：** `std::filesystem::directory_iterator`操作总结'
- en: '| Operation | Notes |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 备注 |'
- en: '| --- | --- |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `directory_iterator{}` | Constructs the end iterator. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `directory_iterator{}` | 构造结束迭代器。 |'
- en: '| `directory_iterator{` p`, [`op`], [`ec`] }` | Constructs a directory iterator
    referring to the directory p. The argument op defaults to `none`. If provided,
    ec receives error conditions rather than throwing an exception. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `directory_iterator{` p`, [`op`], [`ec`] }` | 构造一个指向目录p的目录迭代器。参数op默认为`none`。如果提供，ec会接收错误条件，而不是抛出异常。
    |'
- en: '| `directory_iterator {` d `}`d1 `=` d2 | Copies construction/assignment. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `directory_iterator {` d `}`d1 `=` d2 | 复制构造/赋值。 |'
- en: '| `directory_iterator { move(`d`) }`d1 `= move(`d2`)` | Moves construction/assignment.
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `directory_iterator { move(`d`) }`d1 `= move(`d2`)` | 移动构造/赋值。 |'
- en: '**Directory Entries**'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**目录条目**'
- en: The input iterators `directory_iterator` and `recursive_directory_iterator`
    produce a `std::filesystem::directory_entry` element for each entry they encounter.
    The `directory_entry` class stores a `path`, as well as some attributes about
    that `path` exposed as methods. [Table 17-3](ch17.xhtml#ch17tab03) lists these
    methods. Note that `de` is a `directory_entry` in the table.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '输入迭代器`directory_iterator`和`recursive_directory_iterator`会为它们遇到的每个条目生成一个`std::filesystem::directory_entry`元素。`directory_entry`类存储一个`path`，以及一些关于该`path`的属性，这些属性通过方法公开。[表
    17-3](ch17.xhtml#ch17tab03)列出了这些方法。请注意，表中的`de`是一个`directory_entry`。 '
- en: '**Table 17-3:** A Summary of `std::filesystem::directory_entry` Operations'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 17-3：** `std::filesystem::directory_entry`操作总结'
- en: '| Operation | Description |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 描述 |'
- en: '| --- | --- |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| de`.path()` | Returns the referenced path. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| de`.path()` | 返回引用的路径。 |'
- en: '| de`.exists()` | Returns `true` if the referenced path exists on the filesystem.
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| de`.exists()` | 如果引用的路径在文件系统中存在，则返回`true`。 |'
- en: '| de`.is_block_file()` | Returns `true` if the referenced path is a block device.
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| de`.is_block_file()` | 如果引用的路径是块设备，则返回`true`。 |'
- en: '| de`.is_character_file()` | Returns `true` if the referenced path is a character
    device. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| de`.is_character_file()` | 如果引用的路径是字符设备，则返回`true`。 |'
- en: '| de`.is_directory()` | Returns `true` if the referenced path is a directory.
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| de`.is_directory()` | 如果引用的路径是一个目录，则返回`true`。 |'
- en: '| de`.is_fifo()` | Returns `true` if the referenced path is a named pipe. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| de`.is_fifo()` | 如果引用路径是命名管道，则返回`true`。 |'
- en: '| de`.is_regular_file()` | Returns `true` if the referenced path is a regular
    file. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| de`.is_regular_file()` | 如果引用路径是常规文件，则返回`true`。 |'
- en: '| de`.is_socket()` | Returns `true` if the referenced path is a socket. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| de`.is_socket()` | 如果引用路径是套接字，则返回`true`。 |'
- en: '| de`.is_symlink()` | Returns `true` if the referenced path is a symlink |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| de`.is_symlink()` | 如果引用路径是符号链接，则返回`true` |'
- en: '| de`.is_other()` | Returns `true` if the referenced path is something else.
    |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| de`.is_other()` | 如果引用路径是其他类型，则返回`true`。 |'
- en: '| de`.file_size()` | Returns the size of the referenced path. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| de`.file_size()` | 返回引用路径的大小。 |'
- en: '| de`.hard_link_count()` | Returns the number of hard links to the referenced
    path. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| de`.hard_link_count()` | 返回引用路径的硬链接数量。 |'
- en: '| de`.last_write_time([`t`])` | If `t` is provided, sets the last modified
    time of the referenced path; otherwise, it returns the last modified time. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| de`.last_write_time([`t`])` | 如果提供了`t`，则设置引用路径的最后修改时间；否则，返回最后修改时间。 |'
- en: '| de`.status()` de`.symlink_status()` | Returns a `std::filesystem::file_status`
    for the referenced path. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| de`.status()` de`.symlink_status()` | 返回引用路径的`std::filesystem::file_status`。
    |'
- en: You can employ `directory_iterator` and several of the operations in [Table
    17-3](ch17.xhtml#ch17tab03) to create a simple directory-listing program, as [Listing
    17-7](ch17.xhtml#ch17ex07) illustrates.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`directory_iterator`和[表17-3](ch17.xhtml#ch17tab03)中的多个操作，创建一个简单的目录列出程序，正如[Listing
    17-7](ch17.xhtml#ch17ex07)所展示的那样。
- en: '[PRE8]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 17-7: A file- and directory-listing program that uses `std::filesystem::directory_iterator`
    to enumerate a given directory. (Output is from a Windows 10 x64 system.)*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 17-7：一个使用`std::filesystem::directory_iterator`列举给定目录的文件和目录的程序。（输出来自Windows
    10 x64系统。）*'
- en: '**NOTE**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You should modify the program’s name from `listdir` to whatever value matches
    your compiler’s output.*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*你应该将程序的名称从`listdir`修改为与你的编译器输出相匹配的任何值。*'
- en: You first define a `describe` function that takes a `path` reference ➊, which
    checks whether the path is a directory ➋ and prints an asterisk for a directory
    and a corresponding size for a file. Next, you determine the entry’s last modification
    in seconds since epoch and print it along with the entry’s associated filename
    ➌. If any exception occurs, you print an error message and return ➍.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义一个`describe`函数，该函数接受一个`path`引用 ➊，用于检查路径是否为目录 ➋，并为目录打印星号，为文件打印相应的大小。接下来，确定该条目自纪元以来的最后修改时间（以秒为单位），并将其与条目关联的文件名一起打印
    ➌。如果发生任何异常，打印错误信息并返回 ➍。
- en: Within `main`, you first check that the user invoked your program with a single
    argument and return with a negative number if not ➎. Next, you construct a path
    using the single argument ➏, print some fancy headers for your output ➐, iterate
    over each `entry` in the directory ➑, and pass it to `describe` ➒.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，首先检查用户是否使用单个参数调用了程序，如果没有，则返回一个负数 ➎。接下来，使用单个参数 ➏ 构造路径，打印一些华丽的输出头部
    ➐，遍历目录中的每个`entry` ➑，并将其传递给`describe` ➒。
- en: '***Recursive Directory Iteration***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***递归目录迭代***'
- en: The `recursive_directory_iterator` is a drop-in replacement for `directory_iterator`
    in the sense that it supports all the same operations but will enumerate subdirectories.
    You can use these iterators in combination to build a program that computes the
    size and quantity of files and subdirectories for a given directory. [Listing
    17-8](ch17.xhtml#ch17ex08) illustrates how.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`recursive_directory_iterator` 是 `directory_iterator` 的替代品，支持相同的所有操作，但会列举子目录。你可以结合使用这些迭代器，构建一个计算给定目录中文件和子目录的大小和数量的程序。[Listing
    17-8](ch17.xhtml#ch17ex08) 展示了如何实现。'
- en: '[PRE9]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 17-8: A file- and directory-listing program that uses `std::filesystem::recursive_directory_iterator`
    to list the number of files and total size of a given path’s subdirectory. (Output
    is from a Windows 10 x64 system.)*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 17-8：一个使用`std::filesystem::recursive_directory_iterator`列出给定路径子目录中文件数量和总大小的程序。（输出来自Windows
    10 x64系统。）*'
- en: '**NOTE**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You should modify the program’s name from `treedir` to whatever value matches
    your compiler’s output.*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*你应该将程序的名称从`treedir`修改为与你的编译器输出相匹配的任何值。*'
- en: After declaring the `Attributes` class for storing accounting data ➊, you define
    a `print_line` function that presents an `Attributes` instance in a user-friendly
    way alongside a path string ➋. Next, you define an `explore` function that accepts
    a `directory_entry` reference and iterates over it recursively ➌. If the resulting
    `entry` is a directory, you increment the directory count ➍; otherwise, you increment
    the file count and total size ➎.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明用于存储会计数据的`Attributes`类➊后，你定义了一个`print_line`函数，它以用户友好的方式展示`Attributes`实例，并附带路径字符串➋。接下来，你定义了一个`explore`函数，它接受一个`directory_entry`引用并递归地遍历它➌。如果结果的`entry`是一个目录，你会增加目录计数器➍；否则，你会增加文件计数和总大小➎。
- en: Within `main`, you check that the program invoked with exactly two arguments.
    If not, you return with an error code -1 ➏. You employ a (non-recursive) `directory_iterator`
    to enumerate the contents of the target path referred by `sys_path` ➐. If an `entry`
    is a directory, you invoke `explore` to determine its attributes ➑, which you
    subsequently print to the console. You also increment the `n_directories` member
    of `root_attributes` to keep account. If the `entry` isn’t a directory, you add
    to the `n_files` and `size_bytes` members of `root_attributes` accordingly ➒.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，你检查程序是否确实传入了两个参数。如果没有，你会返回错误代码 -1 ➏。你使用（非递归的）`directory_iterator`枚举`sys_path`所指的目标路径中的内容➐。如果一个`entry`是目录，你会调用`explore`来确定其属性➑，然后将其打印到控制台。你还会增加`root_attributes`中的`n_directories`成员来进行统计。如果`entry`不是目录，你会相应地增加`root_attributes`中的`n_files`和`size_bytes`成员➒。
- en: Once you’ve completed iterating over all `sys_path` subelements, you print `root_attributes`
    as the final line ➓. The final line of output in [Listing 17-8](ch17.xhtml#ch17ex08),
    for example, shows that this particular Windows directory contains 110,950 files
    occupying 21,038,460,348 bytes (about 21GB) and 26,513 subdirectories.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 完成遍历所有`sys_path`子元素后，你会打印`root_attributes`作为最后一行输出➓。例如，[清单 17-8](ch17.xhtml#ch17ex08)中的最后一行输出显示该特定
    Windows 目录包含110,950个文件，占用21,038,460,348字节（约21GB）和26,513个子目录。
- en: '**fstream Interoperation**'
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**fstream 互操作性**'
- en: You can construct file streams (`basic_ifstream`, `basic_ofstream`, or `basic_``fstream`)
    using `std::filesystem::path` or `std::filesystem::directory_entry` in addition
    to string types.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字符串类型外，你还可以使用`std::filesystem::path`或`std::filesystem::directory_entry`来构造文件流（`basic_ifstream`、`basic_ofstream`
    或 `basic_fstream`）。
- en: For example, you can iterate over a directory and construct an `ifstream` to
    read each file you encounter. [Listing 17-9](ch17.xhtml#ch17ex09) illustrates
    how to check for the magic `MZ` bytes at the beginning of each Windows portable
    executable file (a *.sys*, a *.dll*, a *.exe*, and so on) and report any file
    that violates this rule.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以遍历一个目录并构造一个`ifstream`来读取你遇到的每个文件。[清单 17-9](ch17.xhtml#ch17ex09)展示了如何检查每个
    Windows 可执行文件（如 *.sys*、*.dll*、*.exe* 等）开头的魔术 `MZ` 字节，并报告任何违反此规则的文件。
- en: '[PRE10]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 17-9: Searching the Windows System32 directory for Windows portable
    executable files*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-9：搜索 Windows System32 目录中的 Windows 便携式可执行文件*'
- en: In `main`, you check for exactly two arguments and return an error code as appropriate
    ➊. You construct an `unordered_set` containing all the extensions associated with
    portable executable files ➋, which you’ll use to check file extensions. You use
    a `recursive_directory_iterator` with the `directory_options::skip_permission_denied`
    option to enumerate all the files in the specified path ➌. You iterate over each
    entry ➍, skipping over anything that’s not a regular file, and you determine whether
    the entry is a portable executable by attempting to `find` it in `pe_extensions`.
    If the entry doesn’t have such an extension, you skip over the file ➎.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，你检查是否正好传入了两个参数，并根据情况返回相应的错误代码➊。你构建了一个`unordered_set`，其中包含与便携式可执行文件相关的所有扩展名➋，这些扩展名将用于检查文件扩展名。你使用带有`directory_options::skip_permission_denied`选项的`recursive_directory_iterator`来枚举指定路径中的所有文件➌。你遍历每个条目➍，跳过所有不是常规文件的条目，并通过尝试在`pe_extensions`中`find`该条目来判断该条目是否为便携式可执行文件。如果条目没有这种扩展名，你就跳过该文件➎。
- en: To open the file, you simply pass the path of the `entry` into the constructor
    of `ifstream` ➏. You then use the resulting input file stream to read the first
    two bytes of the file into `first` and `second` ➐. If these first two characters
    aren’t `MZ`, you print a message to the console ➑. Either way, you increment a
    counter called `n_searched`. After exhausting the directory iterator, you print
    a message indicating `n_searched` to the user before returning from `main` ➒.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开文件，只需将`entry`的路径传递给`ifstream`的构造函数➏。然后使用得到的输入文件流将文件的前两个字节读入`first`和`second`➐。如果这两个字符不是`MZ`，则向控制台打印一条消息➑。无论如何，都要增加一个名为`n_searched`的计数器。在用完目录迭代器后，你需要打印一个包含`n_searched`的消息给用户，然后从`main`返回➒。
- en: '**Summary**'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned about the stdlib filesystem facilities, including
    paths, files, directories, and error handling. These facilities enable you to
    write cross-platform code that interacts with the files in your environment. The
    chapter culminated with some important operations, directory iterators, and interoperation
    with file streams.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了stdlib文件系统功能，包括路径、文件、目录和错误处理。这些功能使你能够编写与环境中文件交互的跨平台代码。本章的内容以一些重要的操作、目录迭代器和文件流的互操作性为结尾。
- en: '**EXERCISES**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题**'
- en: '**17-1.** Implement a program that takes two arguments: a path and an extension.
    The program should search the given path recursively and print any file with the
    specified extension.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**17-1.** 实现一个程序，接受两个参数：一个路径和一个扩展名。该程序应该递归地搜索给定路径，并打印任何具有指定扩展名的文件。'
- en: '**17-2.** Improve the program in [Listing 17-8](ch17.xhtml#ch17ex08) so it
    can take an optional second argument. If the first argument begins with a hyphen
    (`-`), the program reads all contiguous letters immediately following the hyphen
    and parses each letter as an option. The second argument then becomes the path
    to search. If the list of options contains an *R*, perform a recursive directory.
    Otherwise, don’t use a recursive directory iterator.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**17-2.** 改进[Listing 17-8](ch17.xhtml#ch17ex08)中的程序，使其可以接受一个可选的第二个参数。如果第一个参数以连字符（`-`）开头，程序将读取紧跟连字符后面的所有连续字母，并将每个字母解析为一个选项。第二个参数则变成搜索的路径。如果选项列表中包含*R*，则执行递归目录操作。否则，不使用递归目录迭代器。'
- en: '**17-3.** Refer to the documentation for the *dir* or *ls* command and implement
    as many of the options as possible in your new, improved version of [Listing 17-8](ch17.xhtml#ch17ex08).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**17-3.** 请参阅*dir*或*ls*命令的文档，并在你改进版的[Listing 17-8](ch17.xhtml#ch17ex08)中实现尽可能多的选项。'
- en: '**FURTHER READING**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*Windows NT File System Internals: A Developer’s Guide* by Rajeev Nagar (O’Reilly,
    1997)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Windows NT文件系统内部结构：开发者指南*，作者：Rajeev Nagar（O''Reilly，1997）'
- en: '*The Boost C++ Libraries*, 2nd Edition, by Boris Schäling (XML Press, 2014)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Boost C++库*（第二版），作者：Boris Schäling（XML Press，2014）'
- en: '*The Linux Programming Interface: A Linux and UNIX System Programming Handbook*
    by Michael Kerrisk (No Starch Press, 2010)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux编程接口：Linux和UNIX系统编程手册*，作者：Michael Kerrisk（No Starch Press，2010）'
