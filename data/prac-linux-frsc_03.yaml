- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3'
- en: EVIDENCE FROM STORAGE DEVICES AND FILESYSTEMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 来自存储设备和文件系统的**证据**
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: This chapter focuses on the forensic analysis of Linux storage, including partition
    tables, volume management and RAID, filesystems, swap partitions and hibernation,
    and drive encryption. Each of these areas have Linux-specific artifacts that we
    can analyze. You may be able to use commercial forensic tools to perform most
    of the activities shown here, but for illustrative purposes, the examples in this
    chapter use Linux tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讲解Linux存储的取证分析，包括分区表、卷管理和RAID、文件系统、交换分区和休眠、以及磁盘加密。每个领域都有Linux特有的取证痕迹，我们可以进行分析。你可能能够使用商业取证工具执行本章中展示的大部分活动，但为了说明问题，本章中的示例使用了Linux工具。
- en: When performing a forensic analysis of a computer system’s storage, the first
    step is to identify precisely what is on the drive. We must understand the layout,
    formats, versions, and configuration. After we have a high-level understanding
    of the drive contents, we can begin looking for other interesting forensic artifacts
    and data to examine or extract.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在对计算机系统的存储进行取证分析时，第一步是精确识别驱动器上的内容。我们必须理解布局、格式、版本和配置。在对驱动器内容有了高层次的了解后，我们可以开始寻找其他有趣的取证痕迹和数据进行检查或提取。
- en: The filesystem forensic analysis shown in this chapter is described at a relatively
    high level compared to academic research papers and other literature in digital
    forensics. Here, I’ll describe file and filesystem metadata and information that
    could be useful for a forensic investigation. I’ll show how to list and extract
    files, and explore the likelihood of recovering deleted files and slack. It is
    expected that the filesystems under analysis are in a (relatively) consistent
    state and that tools can parse the filesystem data structures. Corrupt, severely
    damaged, or partially wiped and overwritten filesystems require a different approach
    to analysis, which involves manually reassembling sectors or blocks into files
    for recovery and other low-level analysis techniques. That level of investigation
    is beyond the intended depth of this book. For an excellent resource on deeper
    filesystem analysis, I recommend Brian Carrier’s *File System Forensic Analysis*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所示的文件系统取证分析相较于学术研究论文和其他数字取证文献，描述的层次较高。在这里，我将描述文件和文件系统元数据以及对取证调查有用的信息。我会展示如何列出和提取文件，探讨恢复已删除文件和空白区的可能性。预计被分析的文件系统处于（相对）一致的状态，工具能够解析文件系统数据结构。损坏严重、部分擦除或被覆盖的文件系统需要不同的分析方法，这涉及手动将扇区或块重新组合成文件进行恢复以及其他低级别的分析技术。这种级别的调查超出了本书的预期深度。对于更深入的文件系统分析资源，我推荐Brian
    Carrier的《文件系统取证分析》。
- en: 'The “Filesystem Forensic Analysis" section in this chapter begins with a description
    of the structures common to all Unix-like filesystems, and it’s followed by a
    closer look at the most common filesystems used in Linux: ext4, xfs, and btrfs.
    These three filesystem sections have the following format:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的“文件系统取证分析”部分首先介绍了所有类Unix文件系统共有的结构，接着详细讲解了在Linux中最常用的文件系统：ext4、xfs 和 btrfs。这三个文件系统部分的结构如下：
- en: History, overview, and features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 历史、概述和特点
- en: How to find and identify the filesystem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何查找和识别文件系统
- en: Forensic artifacts in filesystem metadata (superblock)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统元数据中的取证痕迹（超级块）
- en: Forensic artifacts in the file metadata (inodes)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件元数据中的取证痕迹（inode）
- en: Listing and extracting files
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出和提取文件
- en: Other unique features
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他独特特点
- en: The analysis examples are shown using The Sleuth Kit (TSK), debugging and troubleshooting
    tools provided by the respective project teams, and various free and open source
    community projects. I use patched versions of TSK with btrfs and xfs support for
    some analysis examples.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 分析示例使用了The Sleuth Kit（TSK），以及各项目团队提供的调试和故障排除工具，和各种自由与开源社区项目。我使用了支持btrfs和xfs的TSK补丁版本进行一些分析示例。
- en: The examples in this chapter use the naming convention *image.raw* for full
    drive images and *partimage.raw* for images of partitions (containing filesystems).
    Examples using partition images may work on full drive images if you specify the
    partition offset. Some tools work only with devices, not forensic image files.
    In those cases, a loopback device associated with the image file is created.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例使用命名约定*image.raw*表示完整的磁盘镜像，*partimage.raw*表示分区的镜像（包含文件系统）。使用分区镜像的示例在指定了分区偏移量的情况下，也可以用于完整的磁盘镜像。某些工具仅能与设备一起使用，而不能与法医镜像文件一起使用。在这种情况下，会创建与镜像文件关联的回环设备。
- en: We are coming to the end of a “golden age” in filesystem forensics. On magnetic
    spinning disks, when deleted files are unlinked and blocks are unallocated, the
    data remains on the physical disk sectors. Forensic tools can “magically” recover
    these deleted files and fragments of partially overwritten files. However, today
    SSDs are accepting TRIM and DISCARD commands from the operating system that instruct
    the SSD firmware to erase unused blocks (for performance and efficiency reasons).
    Also, the flash translation layer (FTL) maps defective memory blocks to over-provisioned
    areas of storage that are not accessible through the standard hardware interfaces
    (SATA, SAS, or NVMe). Because of this, some traditional forensic techniques are
    becoming less effective at recovering data. Recovery techniques such as *chip-off*,
    where memory chips are de-soldered, require special equipment and training to
    perform. This chapter covers recovery of deleted files where it is still possible
    using software tools.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将结束文件系统法医学的“黄金时代”。在磁性旋转硬盘上，当删除的文件被取消链接并且块被取消分配时，数据仍然保留在物理磁盘扇区中。法医工具可以“神奇地”恢复这些已删除的文件和部分覆盖的文件碎片。然而，今天的SSD支持操作系统发送的TRIM和DISCARD命令，这些命令指示SSD固件擦除未使用的块（出于性能和效率的原因）。此外，闪存转换层（FTL）将有缺陷的内存块映射到存储的超额配置区域，这些区域无法通过标准硬件接口（SATA、SAS或NVMe）访问。因此，一些传统的法医技术在恢复数据时变得不太有效。像*chip-off*这样的恢复技术，需要将内存芯片拆焊，执行此操作需要特殊的设备和训练。本章介绍了仍然可以通过软件工具恢复已删除文件的技术。
- en: '**Analysis of Storage Layout and Volume Management**'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**存储布局与卷管理分析**'
- en: This section describes how to identify Linux partitions and volumes on storage
    media. I’ll show how to reconstruct or reassemble volumes that may contain filesystems
    and highlight traces of information interesting for an investigation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了如何识别存储介质上的Linux分区和卷。我将展示如何重建或重新组合可能包含文件系统的卷，并突出对调查有意义的信息痕迹。
- en: '***Analysis of Partition Tables***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分区表分析***'
- en: 'Typical storage media are organized using a defined partition scheme. Common
    partition schemes include:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的存储介质采用定义的分区方案进行组织。常见的分区方案包括：
- en: DOS/MBR (original PC partition scheme)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOS/MBR（原始PC分区方案）
- en: GPT
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPT
- en: BSD
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BSD
- en: Sun (vtoc)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sun (vtoc)
- en: APM (Apple Partition Map)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: APM（苹果分区图）
- en: None (the absence of a partition scheme where filesystems start at sector zero)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无（没有分区方案，文件系统从扇区零开始）
- en: DOS was the most popular partition scheme for many years, but GPT is becoming
    more common.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: DOS曾是多年来最流行的分区方案，但GPT正在变得越来越常见。
- en: 'Partitions are defined with a partition table,^([1](footnotes.xhtml#ch03foot_01))
    which provides information like the partition type, size, offset, and so on. Linux
    systems are often divided into partitions to create separate filesystems. Common
    partitions may contain the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 分区通过分区表定义，^([1](footnotes.xhtml#ch03foot_01))该表提供了诸如分区类型、大小、偏移量等信息。Linux系统通常将硬盘划分为多个分区，以创建独立的文件系统。常见的分区可能包含以下内容：
- en: '| **/** | Operating system installation and root mount |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **/** | 操作系统安装和根挂载 |'
- en: '| **ESP** | The EFI system partition (FAT) used for UEFI booting |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **ESP** | 用于UEFI引导的EFI系统分区（FAT） |'
- en: '| **swap** | Used for paging, swapping, and hibernation |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **swap** | 用于分页、交换和休眠 |'
- en: '| ***/boot/*** | Bootloader information, kernels, and initial ram disks |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| ***/boot/*** | 引导加载程序信息、内核和初始内存盘 |'
- en: '| ***/usr/*** | Sometimes used for read-only filesystem of system files |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| ***/usr/*** | 有时用于系统文件的只读文件系统 |'
- en: '| ***/var/*** | Sometimes used for variable or changing system data |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| ***/var/*** | 有时用于存储可变或更改的系统数据 |'
- en: '| ***/home/*** | User home directories |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| ***/home/*** | 用户的主目录 |'
- en: The default partition and filesystem layout differs for each Linux distro, and
    the user is given the chance to customize it during installation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的分区和文件系统布局因Linux发行版而异，用户在安装过程中有机会自定义该布局。
- en: From a digital forensics perspective, we want to identify the partition scheme,
    analyze the partition tables, and look for possible inter-partition gaps. The
    analysis of DOS and GPT^([2](footnotes.xhtml#ch03foot_02)) partition tables is
    independent of the installed operating system. All commercial forensic tools can
    analyze Linux system partition tables. We will focus here on the artifacts that
    are specific to Linux.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从数字取证的角度来看，我们需要识别分区方案，分析分区表，并寻找可能的分区间隙。对DOS和GPT^([2](footnotes.xhtml#ch03foot_02))分区表的分析与已安装的操作系统无关。所有商业取证工具都可以分析Linux系统分区表。我们将重点讨论与Linux特定的痕迹。
- en: 'A DOS partition table entry allocates one byte for the partition type. No authoritative
    standards body defines DOS partition types; however, a community effort to maintain
    a list of known partition types is located at *[https://www.win.tue.nl/~aeb/partitions/partition_types-1.html](https://www.win.tue.nl/~aeb/partitions/partition_types-1.html)*
    (the UEFI specification even links to this site). Some common Linux partition
    types you might find are:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: DOS分区表条目为分区类型分配了一个字节。没有权威的标准组织定义DOS分区类型；然而，一个社区努力维护已知分区类型的列表，网址为*[https://www.win.tue.nl/~aeb/partitions/partition_types-1.html](https://www.win.tue.nl/~aeb/partitions/partition_types-1.html)*（UEFI规范甚至链接到该网站）。你可能会发现一些常见的Linux分区类型，包括：
- en: '| **0x83** | Linux |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **0x83** | Linux |'
- en: '| **0x85** | Linux extended |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **0x85** | Linux扩展 |'
- en: '| **0x82** | Linux swap |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **0x82** | Linux swap |'
- en: '| **0x8E** | Linux LV |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **0x8E** | Linux LV |'
- en: '| **0xE8** | LUKS (Linux Unified Key Setup) |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **0xE8** | LUKS（Linux统一密钥设置） |'
- en: '| **0xFD** | Linux RAID auto |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **0xFD** | Linux RAID自动 |'
- en: The 0x prefix denotes that the partition types are in hexadecimal format. Linux
    installations typically have one or more *primary* partitions, which are traditional
    partition table entries. A single *extended* partition (type 0x05 or 0x85) may
    also exist and contain additional *logical* partitions.^([3](footnotes.xhtml#ch03foot_03))
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 0x前缀表示分区类型以十六进制格式表示。Linux安装通常有一个或多个*主分区*，这是传统的分区表条目。还可能存在一个*扩展*分区（类型为0x05或0x85），其中包含其他*逻辑*分区。^([3](footnotes.xhtml#ch03foot_03))
- en: 'A GPT partition table entry allocates 16 bytes for the partition GUID. The
    UEFI specification states: “OS vendors need to generate their own Partition Type
    GUIDs to identify their partition types.” The Linux Discoverable Partitions Specification
    (*[https://systemd.io/DISCOVERABLE_PARTITIONS/](https://systemd.io/DISCOVERABLE_PARTITIONS/)*)
    defines several Linux GUID partition types, but it is not complete. See the systemd-id128(1)
    man page about listing known GUIDs with the `systemd-id128` `show` command. Some
    Linux GPT partition types you might find for a GPT partition scheme include:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: GPT分区表条目为分区GUID分配了16个字节。UEFI规范中指出：“操作系统厂商需要生成自己的分区类型GUID来标识他们的分区类型。”Linux可发现分区规范（*[https://systemd.io/DISCOVERABLE_PARTITIONS/](https://systemd.io/DISCOVERABLE_PARTITIONS/)）定义了几种Linux
    GUID分区类型，但并不完整。有关列出已知GUID的`systemd-id128` `show`命令，请参见systemd-id128(1)手册页。你可能会在GPT分区方案中发现一些Linux
    GPT分区类型，包括：
- en: '| **Linux swap** | 0657FD6D-A4AB-43C4-84E5-0933C84B4F4F |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **Linux swap** | 0657FD6D-A4AB-43C4-84E5-0933C84B4F4F |'
- en: '| **Linux filesystem** | 0FC63DAF-8483-4772-8E79-3D69D8477DE4 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **Linux文件系统** | 0FC63DAF-8483-4772-8E79-3D69D8477DE4 |'
- en: '| **Linux root (x86-64)** | 4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **Linux根目录（x86-64）** | 4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709 |'
- en: '| **Linux RAID** | A19D880F-05FC-4D3B-A006-743F0F84911E |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **Linux RAID** | A19D880F-05FC-4D3B-A006-743F0F84911E |'
- en: '| **Linux LVM** | E6D6D379-F507-44C2-A23C-238F2A3DF928 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **Linux LVM** | E6D6D379-F507-44C2-A23C-238F2A3DF928 |'
- en: '| **Linux LUKS** | CA7D7CCB-63ED-4C53-861C-1742536059CC |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **Linux LUKS** | CA7D7CCB-63ED-4C53-861C-1742536059CC |'
- en: Don’t confuse the standard defined GUID of the partition type with the randomly
    generated GUID that is unique to a particular partition or filesystem.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将分区类型的标准定义GUID与特定分区或文件系统的随机生成的GUID混淆。
- en: During a forensic examination, DOS or GPT partition types may indicate the contents.
    But beware, users can define any partition type they want and then create a completely
    different filesystem. The partition type is used as an indicator for various tools,
    but there is no guarantee that it will be correct. If a partition type is incorrect
    and misleading, it could be an attempt to hide or obfuscate information (similar
    to trying to hide a file type by changing the file extension).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在取证检查过程中，DOS或GPT分区类型可能指示内容。但需要注意，用户可以定义任何他们想要的分区类型，然后创建一个完全不同的文件系统。分区类型作为各种工具的指示符使用，但不能保证它一定正确。如果分区类型不正确且具有误导性，可能是试图隐藏或模糊信息（类似于通过更改文件扩展名来隐藏文件类型）。
- en: On a Linux system, detected partitions appear in the */dev/* directory. This
    is a mounted pseudo-directory on a running system. In a postmortem forensic examination,
    this directory will be empty, but the device names may still be found in logs,
    referenced in configuration files, or found elsewhere in files on the filesystem.
    A brief review of storage devices (including partitions) is provided here.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux系统中，检测到的分区会出现在*/dev/*目录中。这个目录是一个挂载的伪目录，在运行中的系统中存在。在事后取证检查中，这个目录将为空，但设备名称可能仍然会在日志中、配置文件中或文件系统中的其他地方找到。这里提供了存储设备（包括分区）的简要回顾。
- en: 'The most common storage drives used with Linux are SATA, SAS, NVMe, and SD
    cards. These block devices are represented in the */dev/* directory of a running
    system as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中最常见的存储驱动器是SATA、SAS、NVMe和SD卡。这些块设备在运行中的系统的*/dev/*目录中表示如下：
- en: '*/dev/sda*, */dev/sdb*, */dev/sdc*, . . .'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/dev/sda*, */dev/sdb*, */dev/sdc*, . . .'
- en: '*/dev/nvme0n1*, */dev/nvme1n1*, . . .'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/dev/nvme0n1*, */dev/nvme1n1*, . . .'
- en: '*/dev/mmcblk0*, *mmcblk1*, . . .'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/dev/mmcblk0*, *mmcblk1*, . . .'
- en: There is one device file per drive. SATA and SAS drives are represented alphabetically
    (sda, sdb, sdc, . . .). NVMe drives are represented numerically; the first number
    is the drive, and the second *n* number is the namespace.^([4](footnotes.xhtml#ch03foot_04))
    SD cards are also represented numerically (mmcblk0, mmcblk1, . . .).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个驱动器都有一个设备文件。SATA和SAS驱动器按字母顺序表示（sda, sdb, sdc, . . .）。NVMe驱动器按数字表示；第一个数字是驱动器，第二个*n*数字是命名空间。^([4](footnotes.xhtml#ch03foot_04))
    SD卡也按数字表示（mmcblk0, mmcblk1, . . .）。
- en: 'If a Linux system detects partitions on a particular drive, additional device
    files are created to represent those partitions. The naming convention usually
    adds an additional number to the drive or the letter *p* with a number; for example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Linux系统在某个驱动器上检测到分区，将会创建额外的设备文件来表示这些分区。命名约定通常会在驱动器名后添加一个额外的数字，或者在字母后加上*p*和一个数字，例如：
- en: '*/dev/sda1*, */dev/sda2*, */dev/sda3*, . . .'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/dev/sda1*, */dev/sda2*, */dev/sda3*, . . .'
- en: '*/dev/nvme0n1p1*, */dev/nvme0n1p2*, . . .'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/dev/nvme0n1p1*, */dev/nvme0n1p2*, . . .'
- en: '*/dev/mmcblk0p1*, */dev/mmcblk0p2*, . . .'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/dev/mmcblk0p1*, */dev/mmcblk0p2*, . . .'
- en: If commercial tools are unable to properly analyze Linux partition tables or
    if you want additional analysis results, several Linux tools are available, including
    `mmls` (from TSK) and `disktype`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果商业工具无法正确分析Linux分区表，或者你需要更多的分析结果，可以使用一些Linux工具，包括`mmls`（来自TSK）和`disktype`。
- en: 'Here is an example of TSK’s `mmls` command output of a Manjaro Linux partition
    table:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是TSK的`mmls`命令输出的Manjaro Linux分区表示例：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `mmls` tool lists different “slots,” which can be partition metadata, unallocated
    areas (including inter-partition gaps), and the actual partitions. The start,
    end, and length of the partitions is shown in 512-byte sectors. This example presents
    a traditional DOS partition scheme, a Linux partition (0x83) at sector 2048, and
    a swap partition immediately following. The last 13390 sectors are not allocated
    to any partition.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`mmls`工具列出了不同的“槽”，它们可以是分区元数据、未分配的区域（包括分区间隙）和实际分区。分区的起始、结束位置和长度以512字节扇区为单位显示。这个示例呈现了一个传统的DOS分区方案，一个位于2048扇区的Linux分区（0x83），紧接着是一个交换分区。最后的13390个扇区没有分配给任何分区。'
- en: '**NOTE**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Be careful with your units. Some tools use sectors; others use bytes.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*小心使用单位。一些工具使用扇区，其他工具使用字节。*'
- en: 'Next, let’s consider an example of the `disktype` output of a Linux Mint partition
    table:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一个Linux Mint分区表的`disktype`输出示例：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this output, the GPT partition is shown ➊ with a protective MBR (`Type` `0xEE`).
    Partition 1 is the EFI FAT partition ➋, and the UUID (`GUID`) is recognized. The
    UUID of Partition 2 ➌ is not recognized by `disktype`, but it detects the filesystem
    and shows some information about it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，GPT分区显示为➊，带有保护MBR（`类型` `0xEE`）。分区1是EFI FAT分区➋，并且UUID（`GUID`）已识别。分区2的UUID➌未被`disktype`识别，但它检测到了文件系统并显示了一些相关信息。
- en: 'The format of GPT UUIDs presented by tools may vary and appear different from
    the format stored on disk. For example, here is the Linux GPT partition type `0FC63DAF-8483-4772-8E79-3D69D8477DE4`
    displayed by several different tools:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 工具呈现的GPT UUID格式可能会有所不同，显示的格式也可能与磁盘上存储的格式不同。例如，这里是Linux GPT分区类型`0FC63DAF-8483-4772-8E79-3D69D8477DE4`通过几种不同工具显示的结果：
- en: fdisk/gdisk `0FC63DAF-8483-4772-8E79-3D69D8477DE4`
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: fdisk/gdisk `0FC63DAF-8483-4772-8E79-3D69D8477DE4`
- en: disktype `AF3DC60F-8384-7247-8E79-3D69D8477DE4`
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: disktype `AF3DC60F-8384-7247-8E79-3D69D8477DE4`
- en: hexedit `AF 3D C6 0F 83 84 72 47 8E 79 3D 69 D8 47 7D E4`
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: hexedit `AF 3D C6 0F 83 84 72 47 8E 79 3D 69 D8 47 7D E4`
- en: xxd `af3d c60f 8384 7247 8e79 3d69 d847 7de4`
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: xxd `af3d c60f 8384 7247 8e79 3d69 d847 7de4`
- en: The GPT UUID has a defined structure, and parts of it are stored on disk in
    little-endian form. The UEFI specification ([Appendix A](app01.xhtml)) describes
    the EFI GUID format in detail (*[https://uefi.org/sites/default/files/resources/UEFI_Spec_2_8_final.pdf](https://uefi.org/sites/default/files/resources/UEFI_Spec_2_8_final.pdf)*).
    Some tools (`disktype` or hex dump tools, for example) may display the raw bytes
    written to disk rather than interpreting the bytes as a GPT UUID.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: GPT UUID 具有定义的结构，其中一部分以小端格式存储在磁盘上。UEFI 规范（[附录 A](app01.xhtml)）详细描述了 EFI GUID
    格式（*[https://uefi.org/sites/default/files/resources/UEFI_Spec_2_8_final.pdf](https://uefi.org/sites/default/files/resources/UEFI_Spec_2_8_final.pdf)*）。某些工具（例如
    `disktype` 或十六进制转储工具）可能会显示写入磁盘的原始字节，而不是将这些字节解释为 GPT UUID。
- en: '***Logical Volume Manager***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***逻辑卷管理器***'
- en: Modern operating systems provide volume management for organizing and managing
    groups of physical drives, allowing the flexibility to create logical (virtual)
    drives that contain partitions and filesystems. Volume management can be a separate
    subsystem like *Logical Volume Manager (LVM)* or it can be built directly into
    the filesystem as in btrfs or zfs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现代操作系统提供了卷管理功能，用于组织和管理物理驱动器的组合，允许创建包含分区和文件系统的逻辑（虚拟）驱动器的灵活性。卷管理可以是一个独立的子系统，例如
    *逻辑卷管理器（LVM）*，也可以像 btrfs 或 zfs 一样直接构建在文件系统中。
- en: The examples in this section cover a simplified LVM setup with a single physical
    storage device. This will be enough to analyze many distros that install LVM by
    default on one hard drive. More complex scenarios involving multiple drives will
    require forensic tools that support LVM volumes or a Linux forensic analysis machine
    able to access and assemble LVM volumes. You can still use forensic tools without
    LVM support if the filesystem is written as a linear sequence of sectors on a
    single disk and the starting offset of the filesystem is known.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例涵盖了一个简化的 LVM 设置，只有一个物理存储设备。这足以分析许多默认在一块硬盘上安装 LVM 的发行版。涉及多个驱动器的更复杂场景将需要支持
    LVM 卷的取证工具，或者需要能够访问和组装 LVM 卷的 Linux 取证分析机器。如果文件系统以单个磁盘上的扇区线性序列写入并且已知文件系统的起始偏移量，那么即使没有
    LVM 支持，也可以使用取证工具。
- en: The most common volume manager in Linux environments is LVM. [Figure 3-1](ch03.xhtml#ch03fig01)
    shows the high-level architecture.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 环境中最常见的卷管理器是 LVM。 [图 3-1](ch03.xhtml#ch03fig01) 显示了高层次的架构。
- en: '![Image](Images/ch03fig01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch03fig01.jpg)'
- en: '*Figure 3-1: Logical Volume Manager*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：逻辑卷管理器*'
- en: 'LVM systems have several key concepts:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: LVM 系统有几个关键概念：
- en: '**Physical volume (PV)** Physical storage device (SATA, SAS, and NVMe drives)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**物理卷（PV）** 物理存储设备（SATA、SAS 和 NVMe 驱动器）'
- en: '**Volume group (VG)** Created from a group of PVs'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**卷组（VG）** 由一组 PV 创建'
- en: '**Logical volume (LV)** Virtual storage device within a VG'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑卷（LV）** VG 内的虚拟存储设备'
- en: '**Physical extents (PEs)** Sequence of consecutive sectors in a PV'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**物理扩展（PEs）** PV 中连续扇区的序列'
- en: '**Logical extents (LEs)** Sequence of consecutive sectors in an LV'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑扩展（LEs）** LV 中连续扇区的序列'
- en: In the context of LVM, extents are similar to traditional filesystem blocks,
    and they have a fixed size defined at creation. A typical default LVM extent size
    is 8192 sectors (4MB) and is used for both PEs and LEs. LVM is also able to provide
    redundancy and stripping for logical volumes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LVM 的上下文中，扩展（extent）类似于传统文件系统的块，并且在创建时有一个固定的大小。典型的默认 LVM 扩展大小为 8192 个扇区（4MB），并且用于
    PEs 和 LEs。LVM 还可以为逻辑卷提供冗余和条带化。
- en: 'The use of partition tables is not required for LVM, and PVs can be created
    directly on the raw disk without a partition. When partitions are used, LVM has
    a partition entry type indicating that the physical drive is a PV. For a DOS partition
    scheme, the LVM partition code is `0x8E`. For GPT, the UUID of an LVM partition
    is `E6D6D379-F507-44C2-A23C-238F2A3DF928` (some tools may display the bytes in
    the order they are stored on disk: `D3 79 E6 D6 F5 07 44 C2` `3C A2 8F 23 3D 2A
    28 F9`). Here’s an example partition table:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分区表并非 LVM 所必需，PVs 可以直接在裸磁盘上创建，无需分区。当使用分区时，LVM 会有一个分区条目类型，指示物理驱动器是 PV。对于 DOS
    分区方案，LVM 分区代码是 `0x8E`。对于 GPT，LVM 分区的 UUID 是 `E6D6D379-F507-44C2-A23C-238F2A3DF928`（某些工具可能会以其在磁盘上存储的顺序显示字节：`D3
    79 E6 D6 F5 07 44 C2` `3C A2 8F 23 3D 2A 28 F9`）。以下是一个分区表示例：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, `mmls` displays a DOS partition table, and an LVM partition
    is detected at sector 2099200, taking up much of the drive.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`mmls` 显示了一个 DOS 分区表，并且在扇区 2099200 处检测到一个 LVM 分区，占用了大部分驱动器。
- en: 'Information about the PV is written to a 32-byte label header in the second
    sector of the LVM partition (sector 1). This label contains:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 PV 的信息写入到 LVM 分区第二个扇区（扇区 1）的 32 字节标签头中。此标签包含：
- en: LVM ID with the string `LABELONE` (8 bytes)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LVM ID 字符串为 `LABELONE`（8 字节）
- en: Sector in the partition where this label resides (8 bytes)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此标签所在分区的扇区（8 字节）
- en: CRC checksum of the rest of this sector (4 bytes)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此扇区其余部分的 CRC 校验和（4 字节）
- en: Byte offset of the start of content (4 bytes)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容开始的字节偏移量（4 字节）
- en: LVM type with the string `LVM2 001` (8 bytes)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LVM 类型字符串为 `LVM2 001`（8 字节）
- en: PV UUID (16 bytes)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PV UUID（16 字节）
- en: 'Here is an example hexdump of the LVM label at the start (second sector) of
    the LVM partition:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 LVM 分区的开始（第二个扇区）处 LVM 标签的十六进制转储示例：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You need the lvm2 software package to manage LVM volumes. It has a number of
    tools that can assist in performing forensic analysis of attached LVM drives,
    including the lvm(8) man page that describes the LVM system in more detail.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装 lvm2 软件包来管理 LVM 卷。它包含多个工具，可帮助执行连接 LVM 驱动器的取证分析，包括描述 LVM 系统的 lvm(8) 手册页。
- en: The LVM tools operate on devices, not plain files. To examine an LVM setup on
    a Linux forensic analysis workstation, the suspect drive must be attached with
    a write blocker or as a read-only acquired image file associated with a loop device
    (see the “Devices” subsection in [Chapter 2](ch02.xhtml)). In these examples,
    the suspect LVM drive is the */dev/sdc* device on the forensic analysis machine.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: LVM 工具在设备上操作，而不是普通文件。要在 Linux 取证分析工作站上检查 LVM 设置，嫌疑驱动器必须通过写保护器连接，或作为只读获取的镜像文件关联到一个循环设备（请参阅
    [第 2 章](ch02.xhtml) 中的“设备”小节）。在这些示例中，嫌疑 LVM 驱动器是取证分析机器上的 */dev/sdc* 设备。
- en: 'The `pvdisplay` tool provides information about the PVs. The `--foreign` flag
    includes volumes that would normally be skipped and `--readonly` reads data directly
    from the disk (ignoring the kernel device mapper driver):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`pvdisplay` 工具提供有关 PV 的信息。`--foreign` 标志包括通常会被跳过的卷，`--readonly` 直接从磁盘读取数据（忽略内核设备映射驱动程序）：'
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This output shows information about a single physical volume (`sdc2`), including
    the PE size, the number of PEs in the volume, and information about the extents.
    The LVM UUIDs are not in a standard hexadecimal format; rather, they are a randomly
    generated string with 0–9, a–z, and A–Z characters.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示有关单个物理卷（`sdc2`）的信息，包括 PE 大小、卷中 PE 的数量以及扩展的详细信息。LVM UUID 不是标准的十六进制格式；相反，它们是随机生成的字符串，包含
    0–9、a–z 和 A–Z 字符。
- en: 'You can use the `lvdisplay` tool to query for information about logical volumes.
    The `--maps` flag provides additional details about the segments and extents:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `lvdisplay` 工具查询有关逻辑卷的信息。`--maps` 标志提供有关段和扩展的附加详细信息：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Type linear` line ➋ indicates that the volume resides on the disk as a
    consecutive sequence of sectors (like an LBA). In a linear single disk configuration,
    we only need to find the offset of the start of the filesystem, and then we can
    operate on it using forensic tools that don’t support LVM. Also interesting from
    a forensics perspective is the hostname where the logical volume was created and
    the creation timestamp of the volume ➊ .
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Type linear` 这一行 ➋ 表示卷在磁盘上以连续扇区的序列存在（类似于 LBA）。在线性单磁盘配置中，我们只需要找到文件系统起始位置的偏移量，然后可以使用不支持
    LVM 的取证工具对其进行操作。从取证的角度来看，另一个有趣的方面是创建逻辑卷的主机名和卷的创建时间戳 ➊。'
- en: 'Information about extents helps us find (calculate) the first sector of the
    filesystem. The partition table above (`mmls` output) shows that the LVM partition
    starts at sector 2099200\. The first PE is 2048 sectors from the start of the
    LVM partition.^([5](footnotes.xhtml#ch03foot_05)) The `pvdisplay` output shows
    that the LVM extent size is 8192 sectors (`PE Size 4.00 MiB`), and the `lvdisplay`
    output shows that the root volume starts at extent 1024\. From all of this, we
    can determine the filesystem sector offset from the beginning of the drive:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有关扩展的信息帮助我们找到（计算）文件系统的第一个扇区。上面的分区表（`mmls` 输出）显示 LVM 分区从扇区 2099200 开始。第一个 PE
    距离 LVM 分区的起始位置 2048 个扇区。^([5](footnotes.xhtml#ch03foot_05)) `pvdisplay` 输出显示 LVM
    扩展大小为 8192 个扇区（`PE Size 4.00 MiB`），而 `lvdisplay` 输出显示根卷从第 1024 个扩展开始。通过这些信息，我们可以确定文件系统的扇区偏移量：
- en: 2099200 + 2048 + (8192 * 1024) = 10489856
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 2099200 + 2048 + (8192 * 1024) = 10489856
- en: 'For a linear single disk LVM system in which the filesystem is stored as a
    continuous sequence of sectors, we can use standard forensic tools by using this
    sector offset from the beginning of the physical drive. Here is an example with
    TSK:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于线性单磁盘 LVM 系统，其中文件系统存储为连续的扇区序列，我们可以使用标准的取证工具，通过使用来自物理驱动器开头的这个扇区偏移量。以下是一个使用
    TSK 的示例：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The TSK command `fsstat` provides information about filesystems. In this example,
    an ext4 filesystem was found at the offset calculated within the LVM partition.
    An alternative to calculating the start of the filesystem is to search for the
    start of the filesystem exhaustively (using tools like `gpart`, for example).
    You can use the `vgdisplay` and `pvs` commands with one or more `-v` flags for
    additional verbose information about volume groups and physical volumes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: TSK 命令 `fsstat` 提供有关文件系统的信息。在这个例子中，在 LVM 分区内计算出的偏移量处找到了一个 ext4 文件系统。计算文件系统起始位置的替代方法是通过工具（如
    `gpart`）彻底搜索文件系统的起始位置。你可以使用 `vgdisplay` 和 `pvs` 命令，并带有一个或多个 `-v` 标志，以获取有关卷组和物理卷的详细信息。
- en: LVM also has the ability to perform *copy-on-write (CoW)* snapshots. These can
    be interesting from a forensics perspective, as snapshots of volumes may exist
    from a previous point in time. On running systems, the volumes can be “frozen”
    in a snapshot for analysis or even acquisition.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: LVM 还具有执行 *写时复制（CoW）* 快照的能力。这从取证角度来看非常有趣，因为卷的快照可能来自以前的某个时刻。在运行的系统中，可以将卷“冻结”在快照中进行分析或甚至获取。
- en: '***Linux Software RAID***'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Linux 软件 RAID***'
- en: In the early days of enterprise computing, it was discovered that groups of
    hard disks could be configured to work in parallel for improved reliability and
    performance. This concept became known as a *redundant array of independent disks*,
    or *RAID*.^([6](footnotes.xhtml#ch03foot_06)) Several terms are used to describe
    RAID configurations. *Mirror* refers to two disks that are mirror images of each
    other. *Striped* refers to stripes of data spread across multiple disks for performance
    (multiple disks can be read from and written to simultaneously). *Parity* is a
    computer science term for an extra bit of data used for error detection and/or
    correction.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业计算的早期，人们发现可以将多组硬盘配置为并行工作，从而提高可靠性和性能。这个概念被称为 *冗余独立磁盘阵列*，或 *RAID*。^([6](footnotes.xhtml#ch03foot_06))
    用来描述 RAID 配置的术语有很多。*镜像*指的是两个互为镜像的磁盘。*条带化*指的是将数据条带分布在多个磁盘上以提高性能（可以同时从多个磁盘读取和写入）。*奇偶校验*是计算机科学中的术语，指用于错误检测和/或修正的额外数据位。
- en: 'A RAID has different levels that describe how a group of disks work together:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: RAID 有不同的级别，描述了多个磁盘如何协同工作：
- en: '**RAID** Striped for performance, no redundancy'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**RAID** 为了性能而条带化，无冗余'
- en: '**RAID1** Mirrored disks for redundancy, half the capacity but up to half of
    the disks can fail'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**RAID1** 镜像磁盘以提供冗余，容量为一半，但最多可以有一半的磁盘故障'
- en: '**RAID2,3,4,5** Variations of parity allowing a single disk to fail'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**RAID2,3,4,5** 带奇偶校验的变体，允许一个磁盘发生故障'
- en: '**RAID6** Double parity allowing up to two disks to fail'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**RAID6** 双重奇偶校验，允许最多两个磁盘发生故障'
- en: '**RAID10** Mirrored and striped (“1 + 0”) for maximum redundancy and performance'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**RAID10** 镜像和条带化（“1 + 0”），以实现最大的冗余性和性能'
- en: '**JBOD** “Just a Bunch Of Disks” concatenated, no redundancy or performance,
    maximum capacity'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**JBOD** “仅仅是磁盘的一堆” 连接的磁盘，没有冗余和性能，但最大容量'
- en: Organizations choose a RAID level based on a balance of cost, performance, and
    reliability.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 组织根据成本、性能和可靠性的平衡来选择 RAID 级别。
- en: Some commercial forensic tools may support the reassembly and analysis of Linux
    RAID systems. If not, the forensic images can be transferred to a Linux machine
    for analysis. My previous book, *Practical Forensic Imaging* (No Starch Press,
    2016), explains how to create a forensic image of various RAID systems, including
    Linux. In this section, we’ll assume that the individual drives were forensically
    acquired and available as read-only image files or directly attached to an analysis
    system with write blockers. It is important to ensure that the disks or images
    are read-only, or the analysis system may auto-detect the RAID partitions and
    attempt to reassemble, resync, or rebuild the RAID.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一些商业取证工具可能支持重新组装和分析 Linux RAID 系统。如果不支持，可以将取证镜像传输到 Linux 机器上进行分析。我的上一部书《*实用取证镜像*》（No
    Starch Press，2016）解释了如何创建各种 RAID 系统的取证镜像，包括 Linux。在本节中，我们假设各个驱动器已被取证获取，并且作为只读镜像文件提供，或直接连接到分析系统，并配有写入阻断器。确保磁盘或镜像为只读非常重要，否则分析系统可能会自动检测
    RAID 分区，并尝试重新组装、重新同步或重建 RAID。
- en: RAID capability in Linux can be provided by `md` (multiple device driver, or
    Linux Software RAID), the LVM, or built in to the filesystem (btrfs and zfs have
    integrated RAID capability, for example).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，RAID功能可以通过`md`（多设备驱动程序，或Linux软件RAID）、LVM或内建的文件系统提供（例如，btrfs和zfs具有集成的RAID功能）。
- en: The most commonly used method of RAID (and the focus of this chapter) is the
    Linux software RAID or `md`. This kernel module produces a meta device from a
    configured array of disks. You can use the `mdadm` userspace tool to configure
    and manage the RAID. The rest of this section describes forensic artifacts found
    in a typical `md` RAID system. See the md(4) man page for more information about
    `md` devices.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的RAID方法（本章重点介绍）是Linux软件RAID或`md`。这个内核模块从配置的磁盘阵列中生成一个元设备。你可以使用`mdadm`用户空间工具来配置和管理RAID。接下来的部分描述了在典型的`md`
    RAID系统中找到的取证证据。有关`md`设备的更多信息，请参见md(4)手册页。
- en: A disk used in a RAID may have a partition table with standard Linux RAID partition
    types. For GPT partition tables, the GUID for Linux RAID is `A19D880F-05FC-4D3B-A006-743F0F84911E`
    (or `0F889DA1-FC05-3B4D-A006-743F0F84911E` as bytes written on disk).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 用于RAID的磁盘可能具有标准Linux RAID分区类型的分区表。对于GPT分区表，Linux RAID的GUID是`A19D880F-05FC-4D3B-A006-743F0F84911E`（或在磁盘上写入的字节为`0F889DA1-FC05-3B4D-A006-743F0F84911E`）。
- en: For DOS/MBR partition tables, the partition type for Linux RAID is 0xFD. A forensic
    tool will find these partitions on each disk that is part of a RAID system.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DOS/MBR分区表，Linux RAID的分区类型是0xFD。取证工具将会在每个属于RAID系统的磁盘上找到这些分区。
- en: 'Each device from a Linux RAID system has a *superblock* (not to be confused
    with filesystem superblocks, which are different) that contains information about
    the device and the array. The default location of the `md` superblock on a modern
    Linux RAID device is eight sectors from the start of the partition. We can identify
    it by the magic string 0xA92B4EFC. You can examine this superblock information
    with a hex editor or the `mdadm` command, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Linux RAID系统的每个设备都有一个*超级块*（不要与文件系统超级块混淆，它们是不同的），该块包含有关设备和阵列的信息。现代Linux RAID设备上`md`超级块的默认位置是从分区开始的八个扇区。我们可以通过魔术字符串0xA92B4EFC来识别它。你可以使用十六进制编辑器或`mdadm`命令来查看这个超级块信息，方法如下：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This output contains several artifacts that may be of interest in a forensic
    examination. `Array UUID` ➊ will identify the overall RAID system, and each disk
    belonging to this RAID (including previously replaced disks) will have this same
    UUID string in its superblock. `Name` (`My Big Storage`) ➋ can be specified by
    the administrator or auto-generated. `Device UUID` ➍ uniquely identifies the individual
    disks. The creation timestamp ➌ refers to the creation date of the array (a newly
    replaced disk will inherit the original array’s creation date). `Update Time`
    ➎ refers to the last time the superblock was updated due to some filesystem event.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出包含了几个可能在取证检查中有用的证据。`Array UUID` ➊将标识整个RAID系统，每个属于此RAID的磁盘（包括以前更换的磁盘）将在其超级块中拥有相同的UUID字符串。`Name`（`My
    Big Storage`） ➋可以由管理员指定或自动生成。`Device UUID` ➍唯一标识单个磁盘。创建时间戳 ➌ 表示阵列的创建日期（新更换的磁盘将继承原始阵列的创建日期）。`Update
    Time` ➎表示由于某些文件系统事件，超级块最后一次更新的时间。
- en: 'The disks in an array might not all be identical sizes. For a forensic examination,
    this can be important. In this example, three devices are each using 15.5GB to
    produce a 31GB RAID5 array. However, the device shown here (sdc) is 123.6GB in
    size:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 阵列中的磁盘可能不是所有都具有相同的大小。在取证检查中，这可能是重要的。在这个例子中，三个设备各自使用15.5GB来生成一个31GB的RAID5阵列。然而，这里显示的设备（sdc）大小为123.6GB：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The device in this example is significantly larger than the size of the other
    members of the array, which indicates that more than 100GB of untouched data is
    on this drive. This area can be forensically examined for previously stored data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的设备比阵列中的其他成员要大得多，这表明这个驱动器上有超过100GB的未触碰数据。可以对这个区域进行取证检查，以查找以前存储的数据。
- en: 'The array device is typically in the form `/dev/md#`, `/dev/md/#`, or `/dev/md/`*NAME*,
    where the system administrator can specify `#` or *NAME* at creation. These Linux
    kernel devices will exist only on a running system, but in a postmortem forensic
    examination, they may be found in the logs; for example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 阵列设备通常呈现为`/dev/md#`、`/dev/md/#`或`/dev/md/`*NAME*的形式，系统管理员可以在创建时指定`#`或*NAME*。这些Linux内核设备仅在运行系统上存在，但在事后取证检查中，它们可能会出现在日志中；例如：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, one disk in a RAID5 system has failed, and the kernel produced a message
    that was subsequently saved in the journal. After the failed disk was replaced,
    a kernel message about the recovery was generated.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个 RAID5 系统中的硬盘出现故障，内核生成了一条信息，随后保存到了日志中。在故障硬盘被替换后，内核生成了有关恢复的消息。
- en: The kernel should automatically scan and recognize Linux RAID devices on boot.
    However, they can also be defined in separate configuration files. During an examination
    involving RAID systems, check for uncommented `DEVICE` or `ARRAY` lines in the
    */etc/mdadm.conf* file (or files in */etc/ mdadm.conf.d/*). See the mdadm.conf(5)
    man page for more information.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 内核应该在启动时自动扫描并识别 Linux RAID 设备。然而，它们也可以在单独的配置文件中定义。在检查 RAID 系统时，检查 */etc/mdadm.conf*
    文件（或 */etc/mdadm.conf.d/* 目录中的文件）中是否有未注释的 `DEVICE` 或 `ARRAY` 行。有关更多信息，请参阅 mdadm.conf(5)
    手册页。
- en: If previously failed disks can be physically located, they may still be readable.
    Failed or replaced disks contain a snapshot of data at a certain point in time
    and may be relevant to a forensic investigation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果先前故障的硬盘能够被物理定位，它们仍然可能是可读取的。故障或更换的硬盘包含了某一时刻的数据快照，并可能与取证调查相关。
- en: The future of traditional RAID in enterprise IT environments is being influenced
    by multiple factors. Large commodity disks (18TB disks are available as of this
    writing) need more time to resync and rebuild. In some cases, this could take
    days to complete depending on the size and speed of the disks. There is a shift
    toward clusters of inexpensive PCs (like a RAID of PCs) that use data replication
    for performance and redundancy. The use of SSDs instead of spinning magnetic disks
    also reduces the risk of failure (no moving mechanical parts).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 传统 RAID 在企业 IT 环境中的未来正受到多个因素的影响。大容量商品硬盘（截至目前，18TB 硬盘已经可用）需要更多时间来重新同步和重建。在某些情况下，这可能需要数天才能完成，具体取决于硬盘的大小和速度。现在，逐渐转向使用廉价
    PC 集群（类似于 PC 的 RAID）来实现性能和冗余的数据复制。使用 SSD 代替旋转磁盘也降低了故障风险（没有移动的机械部件）。
- en: '**Filesystem Forensic Analysis**'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文件系统取证分析**'
- en: This section provides an introduction to filesystem concepts common to all Unix-like
    filesystems. The analysis examples use TSK for illustration, but all of the techniques
    should be possible with popular commercial digital forensic tools. Linux supports
    dozens of filesystems, and the analysis approach shown here can be applied to
    most of them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了所有 Unix 类文件系统通用的文件系统概念。分析示例使用 TSK 进行说明，但所有技术都应该能够使用流行的商业数字取证工具进行实现。Linux
    支持数十种文件系统，本文展示的分析方法可以应用于其中大多数文件系统。
- en: '***Linux Filesystem Concepts***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Linux 文件系统概念***'
- en: The concept of filesystems is central and fundamental in Unix and Linux. When
    Ken Thompson began creating the first version of Unix, he made the filesystem
    first and developed the concept of “everything is a file.” This idea allows everything
    to be accessible through files in a filesystem tree, including hardware devices,
    processes, kernel data structures, networking, interprocess communication, and,
    of course, regular files and directories.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统的概念在 Unix 和 Linux 中是核心和基础。当 Ken Thompson 开始创建 Unix 的第一个版本时，他首先设计了文件系统，并发展出了“所有事物皆文件”的概念。这个想法使得通过文件系统树中的文件可以访问一切，包括硬件设备、进程、内核数据结构、网络、进程间通信，当然，还有常规的文件和目录。
- en: The fundamental file types described by POSIX are discussed in the next chapter
    and include regular files, directories, symbolic links, named pipes, devices,
    and sockets. When I refer to file types in this chapter, I am referring to Unix
    filesystem and POSIX file types rather than application file types like images,
    videos, or office documents.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 描述的基本文件类型将在下一章中讨论，包含常规文件、目录、符号链接、命名管道、设备和套接字。当我在本章中提到文件类型时，我指的是 Unix 文件系统和
    POSIX 文件类型，而不是应用程序文件类型，如图像、视频或办公文档。
- en: Hard disk drives and SSDs have integrated electronics that create an abstraction
    of a contiguous sequence of sectors (logical block access, or LBA). Partitions
    on a drive may contain filesystems, which are located at a known offset from sector
    zero. A filesystem uses a contiguous group of sectors to form a block (typically
    4KB in size). A collection of one or more blocks (not necessarily contiguous)
    forms the data contents of files.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘驱动器和 SSD 配备了集成电子设备，创建了一个连续扇区序列的抽象（逻辑块访问，简称 LBA）。硬盘上的分区可能包含文件系统，这些文件系统位于从零扇区开始的已知偏移位置。一个文件系统使用一组连续的扇区来形成一个块（通常为
    4KB 大小）。一个或多个块（不一定是连续的）形成文件的数据内容。
- en: Each file is assigned a number (unique within a filesystem) called an *inode*.
    The blocks allocated to each file and other metadata (permissions, timestamps,
    and so on) are stored in an *inode table*. The names of files are not defined
    in the inode, but are rather listed as entries in a *directory file*. These directory
    entries link a filename to an inode and create the illusion of a filesystem tree
    structure. The familiar full file “path” with directories (*/some/path/file.txt*)
    is not stored anywhere, but is calculated by traversing the linked directory filenames
    between the file and the root (/) directory.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件都会被分配一个编号（在文件系统中唯一），称为*inode*。分配给每个文件的块以及其他元数据（权限、时间戳等）都存储在*inode 表*中。文件名并不在
    inode 中定义，而是作为条目列在*目录文件*中。这些目录条目将文件名链接到 inode，创建了一个虚拟的文件系统树结构。熟悉的完整文件“路径”（*/some/path/file.txt*）并不存储在任何地方，而是通过遍历文件和根目录（/）之间链接的目录文件名来计算得出的。
- en: The allocation state of blocks and inodes is stored in bitmaps and updated when
    files are created or deleted. [Figure 3-2](ch03.xhtml#ch03fig02) illustrates these
    layers of abstraction.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 块和 inode 的分配状态存储在位图中，并在文件创建或删除时更新。[图 3-2](ch03.xhtml#ch03fig02)展示了这些抽象层次。
- en: '![Image](Images/ch03fig02.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch03fig02.jpg)'
- en: '*Figure 3-2: Filesystem abstractions. (This is a simplified view and doesn’t
    include block groups, redundancy, scalability, and other special features.)*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：文件系统抽象。（这是一个简化视图，不包括块组、冗余、可扩展性及其他特殊功能。）*'
- en: Traditional filesystems were designed in the days of rotating magnetic platters
    with read/write heads attached to mechanical arms. Performance optimization and
    fault tolerance was necessary, and was achieved by grouping blocks and inodes
    across a disk.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的文件系统是在旋转的磁性盘片时代设计的，当时磁头通过机械臂进行读取/写入操作。性能优化和故障容错是必要的，通常通过在磁盘上将块和 inode 分组来实现。
- en: Some of the original filesystem design decisions (for example, performance optimization
    related to mechanical spinning platters and seeking drive heads) are unnecessary
    with SSDs, but they continue to exist today. Modern filesystems have additional
    features, such as journaling, to ensure data consistency in the event of a crash,
    or they use *extents* (ranges of contiguous blocks) instead of a list of individual
    allocated blocks for a file. In addition, each filesystem may have its own unique
    features and attributes that can be interesting in a digital forensic context
    (for example, ext4 has a last mounted timestamp and path).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一些原始文件系统设计决策（例如，与机械旋转盘片和寻址驱动头相关的性能优化）在 SSD 中是多余的，但它们今天仍然存在。现代文件系统具有额外的功能，如日志记录，以确保在崩溃事件中数据的一致性，或者它们使用*扩展*（一系列连续块）来替代单个分配块的列表。此外，每个文件系统可能都有自己独特的功能和属性，这些功能和属性在数字取证环境中可能会很有意思（例如，ext4
    文件系统有最后挂载时间戳和路径）。
- en: Network filesystems (NFS, CIFS/Samba, and so on), FUSE, and pseudo-filesystems
    (*/proc/*, */sys/*, and so on) have a similar tree/file representation to other
    filesystems. However, these are outside the scope of this book as they cannot
    be analyzed postmortem like physical storage.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 网络文件系统（NFS、CIFS/Samba 等）、FUSE 和伪文件系统（*/proc/*、*/sys/* 等）具有类似于其他文件系统的树/文件表示。然而，这些内容超出了本书的范围，因为它们无法像物理存储一样进行事后分析。
- en: Most filesystems in the Unix and Linux world follow the same general design
    concepts, which makes it easier to apply the same digital forensic analysis methods
    to multiple filesystems.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 和 Linux 世界中的大多数文件系统遵循相同的一般设计概念，这使得将相同的数字取证分析方法应用于多个文件系统变得更加容易。
- en: '***Forensic Artifacts in Linux Filesystems***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Linux 文件系统中的取证痕迹***'
- en: The first step in filesystem analysis is identifying what filesystem is being
    examined. As explained earlier, the partition tables can provide some hints, but
    having correct partition types is not a requirement; thus, a more reliable method
    is needed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统分析的第一步是确定正在检查的是哪个文件系统。如前所述，分区表可以提供一些线索，但分区类型的正确性并不是一个要求；因此，需要一种更可靠的方法。
- en: Most filesystems can be identified by a few bytes at the beginning of the filesystem
    called a *magic string* or *signature*. If your forensic tools can’t automatically
    determine a filesystem, you can search for this signature manually (using TSK’s
    `sigfind` command, for example). The filesystem’s specification defines this magic
    number. You can also use other tools such as `disktype` or TSK’s `fsstat` to identify
    a filesystem. If a known magic string is located at an expected offset in a partition,
    it is a good indicator of the existence of that filesystem.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数文件系统可以通过文件系统开头的几个字节来识别，这些字节被称为 *魔术字符串* 或 *签名*。如果你的取证工具无法自动确定文件系统，你可以手动搜索这个签名（例如，使用
    TSK 的 `sigfind` 命令）。文件系统的规范定义了这个魔术数。你还可以使用其他工具，如 `disktype` 或 TSK 的 `fsstat` 来识别文件系统。如果已知的魔术字符串位于分区中的预期偏移位置，那么它是文件系统存在的良好指示。
- en: 'The *superblock* is the filesystem metadata that describes the overall filesystem.
    Depending on the filesystem, this may contain items of forensic interest, including:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*超级块* 是描述整体文件系统的文件系统元数据。根据文件系统的不同，它可能包含与取证相关的项目，包括：'
- en: Label or volume name specified by the system owner
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统所有者指定的标签或卷名称
- en: Unique identifier (UUID/GUID)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一标识符（UUID/GUID）
- en: Timestamps (filesystem creation, last mount, last write, and last checked)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳（文件系统创建、最后挂载、最后写入和最后检查）
- en: Size and number of blocks (good to identify volume slack)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块的大小和数量（有助于识别卷剩余空间）
- en: Number of mounts and last mount point
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载次数和最后的挂载点
- en: Other filesystem features and configuration
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他文件系统特性和配置
- en: Most forensic tools, including `fsstat`, will show this information. Filesystems
    typically come with debugging and troubleshooting tools that might show even more
    technical information.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数取证工具，包括 `fsstat`，都会显示这些信息。文件系统通常附带调试和故障排除工具，这些工具可能会显示更多技术信息。
- en: 'The inode structure also depends on the filesystem and defines the metadata
    that’s available for each file. This may contain items of forensic interest, including:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: inode 结构也依赖于文件系统，并定义每个文件可用的元数据。这可能包含与取证相关的项目，包括：
- en: POSIX file type
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 文件类型
- en: Permissions and ownership
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权限和所有权
- en: Multiple timestamps (the well-known MACB, maybe others)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个时间戳（众所周知的 MACB，可能还有其他）
- en: Sizes and blocks (indicates possibility of file slack)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小和块（表示文件剩余空间的可能性）
- en: Other flags and attributes
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他标志和属性
- en: The most authoritative place to find information about a filesystem’s inode
    structure is the project’s own developer documentation or the source code to the
    implementation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 查找文件系统 inode 结构信息的最权威地方是该项目本身的开发者文档或实现的源代码。
- en: 'Other forensic artifacts have to do with storage content. Understanding the
    areas of the drive that have content helps examiners with recovery and extraction.
    Some definitions and areas of forensic interest on a drive include:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 其他取证数据与存储内容有关。了解驱动器上有内容的区域可以帮助检查人员进行恢复和提取。一些驱动器上的定义和取证兴趣区域包括：
- en: '**Sector** Smallest accessible unit on a drive'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**扇区** 驱动器上最小的可访问单元'
- en: '**Block** Group of consecutive sectors and the smallest accessible unit on
    a filesystem'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**块** 一组连续的扇区，是文件系统上最小的可访问单元'
- en: '**Extent** A group of consecutive filesystem blocks (variable size)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展** 一组连续的文件系统块（大小可变）'
- en: '**Allocated blocks** Filesystem blocks that are allocated to files'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**已分配块** 已分配给文件的文件系统块'
- en: '**Unallocated blocks** Filesystem blocks that are not allocated to files (possibly
    containing data from deleted files)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**未分配块** 未分配给文件的文件系统块（可能包含已删除文件的数据）'
- en: When a file is deleted, it is unlinked and the inode and associated data blocks
    are flagged as unallocated and free to use. On magnetic disk drives, the deleted
    file’s data continues to reside on the platters until the blocks are overwritten,
    meaning data can be recovered by forensic tools. On SSDs, the operating system
    may send a command (TRIM or DISCARD) to the drive firmware, instructing it to
    erase the data in preparation for the next write.^([7](footnotes.xhtml#ch03foot_07))
    This reduces the chance of deleted data recovery from unallocated areas of SSDs.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件被删除时，它会被取消链接，inode 和关联的数据块会被标记为未分配并且可以重新使用。在磁盘驱动器上，已删除文件的数据会继续存在于盘片上，直到这些块被覆盖，这意味着数据可以通过取证工具恢复。在
    SSD 上，操作系统可能会发送一个命令（TRIM 或 DISCARD）到驱动器固件，指示它擦除数据，为下一次写入做准备。^([7](footnotes.xhtml#ch03foot_07))
    这减少了从 SSD 的未分配区域恢复已删除数据的可能性。
- en: 'The term *slack* or *slackspace* is used in forensics to describe additional
    unused areas of a drive where data could (theoretically) exist:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*间隙*或*间隙空间*是取证中用来描述驱动器上额外未使用区域的术语，这些区域理论上可以存储数据：'
- en: '**Volume slack** Area between end of filesystem and end of partition'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**卷间隙** 文件系统末尾和分区末尾之间的区域'
- en: '**File slack** Area between end of file and end of block'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件间隙** 文件末尾和块末尾之间的区域'
- en: '**RAM or memory slack** Area between end of file and end of sector'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**RAM或内存间隙** 文件末尾和扇区末尾之间的区域'
- en: '**Interpartition gaps** A region of the drive not belonging to any defined
    partition (possibly deleted partitions)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**分区间隙** 驱动器上不属于任何已定义分区的区域（可能是已删除的分区）'
- en: Today, operating systems are more careful about handling discarded data. TRIM
    and DISCARD commands are used to wipe SSD memory cells, and 4KB native sectors
    (the smallest addressable unit) are the same size as filesystem blocks. These
    factors are resulting in slackspace becoming less useful as an evidence source.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，操作系统在处理丢弃数据时更加谨慎。TRIM和DISCARD命令用于擦除SSD存储单元，4KB原生扇区（最小可寻址单元）大小与文件系统块大小相同。这些因素导致间隙空间作为证据来源的效用降低。
- en: '***List and Extract Data***'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列出并提取数据***'
- en: Part of filesystem forensic analysis is the ability to recover files (including
    deleted files) and recover file fragments (slack or unallocated areas). This is
    a normal feature of every computer forensic toolkit. Let’s look at a small cookbook
    of examples using TSK.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统取证分析的一部分是能够恢复文件（包括已删除的文件）和恢复文件片段（间隙或未分配区域）。这是每个计算机取证工具包的正常功能。让我们通过使用TSK来查看一些小例子。
- en: 'First, let’s examine the relationships between sectors, blocks, inodes, and
    filenames. These examples use basic math or TSK tools to answer the following
    questions:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检查扇区、块、inode和文件名之间的关系。这些示例使用基本的数学或TSK工具来回答以下问题：
- en: I know the drive sector. What is the filesystem block? `(sector - partitionoffset)
    * sectorsize / blocksize`
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我知道驱动器的扇区。文件系统块是什么？`(扇区 - 分区偏移) * 扇区大小 / 块大小`
- en: I know the filesystem block. At what sector is it located? `(block * blocksize
    / sectorsize) + partitionoffset`
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我知道文件系统块。它位于哪个扇区？`(块 * 块大小 / 扇区大小) + 分区偏移`
- en: Is this filesystem block (123) allocated? `blkstat partimage.raw 123`
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个文件系统块（123）是否已分配？`blkstat partimage.raw 123`
- en: I know an allocated block (456). What is the inode? `ifind -d 456 partimage.raw`
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我知道一个已分配的块（456）。它的inode是什么？`ifind -d 456 partimage.raw`
- en: 'I know a file’s inode. Show the file’s metadata (and blocks used): `istat partimage.raw
    789`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我知道一个文件的inode。显示文件的元数据（和使用的块）：`istat partimage.raw 789`
- en: I know a file’s inode. What is the filename? `ffind partimage.raw 789`
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我知道一个文件的inode。文件名是什么？`ffind partimage.raw 789`
- en: I know the filename. What is the inode? `ifind -n "hello.txt" partimage.raw`
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我知道文件名。它的inode是什么？`ifind -n "hello.txt" partimage.raw`
- en: '**NOTE**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Make sure you are using the correct units! Depending on the tool, the units
    could be bytes, sectors, or blocks.*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*确保你使用的是正确的单位！根据工具的不同，单位可以是字节、扇区或块。*'
- en: TSK has tools for analyzing drive images and filesystems. When using a tool
    for filesystem analysis, the location of the filesystem is needed. Filesystem
    forensic tools can read data from a partition device file (*/dev/sda1*) or an
    extracted partition image (*partimage.raw*), or by specifying a sector offset
    (typically by using the `-o` flag) for an attached drive or drive image file.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: TSK有用于分析驱动器镜像和文件系统的工具。在使用文件系统分析工具时，需要知道文件系统的位置。文件系统取证工具可以从分区设备文件（*/dev/sda1*）或提取的分区镜像（*partimage.raw*）读取数据，或者通过为附加驱动器或驱动器镜像文件指定扇区偏移（通常使用`-o`标志）。
- en: We can use TSK’s `fls` tool to list all known files (including deleted files)
    on a filesystem. In the following example, the `-r` flag lists files from all
    directories recursively, and `-p` displays a full path (the `-l` flag would include
    timestamps, size, and ownership).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用TSK的`fls`工具列出文件系统上所有已知的文件（包括已删除的文件）。在以下示例中，`-r`标志递归列出所有目录中的文件，`-p`显示完整路径（`-l`标志将包含时间戳、大小和所有权信息）。
- en: '[PRE10]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This command found more than 45,000 files on my test system, and I’ve picked
    a few examples to explain the output. For more information, see the TSK wiki (*[https://github.com/sleuthkit/sleuthkit/wiki/fls/](https://github.com/sleuthkit/sleuthkit/wiki/fls/)*).
    The first column (`r/r`, `d/d`, and so on) represents the file type identified
    from the directory entry and the inode. For example, */etc/hosts* is a regular
    file (`r`) and the output shows `r/r`. The first `r` is determined from the */etc/*
    directory entry, and the second `r` is determined from the */etc/hosts* metadata
    (the inode). The Linux-relevant^([8](footnotes.xhtml#ch03foot_08)) file types
    are documented on the TSK wiki and shown here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令在我的测试系统上找到了超过45,000个文件，我挑选了一些例子来解释输出。更多信息请参见TSK维基（*[https://github.com/sleuthkit/sleuthkit/wiki/fls/](https://github.com/sleuthkit/sleuthkit/wiki/fls/)*）。第一列（`r/r`，`d/d`，等等）表示从目录条目和inode中识别出的文件类型。例如，*/etc/hosts*是一个常规文件（`r`），输出显示为`r/r`。第一个`r`是从*/etc/*目录条目确定的，第二个`r`是从*/etc/hosts*元数据（inode）中确定的。与Linux相关的^([8](footnotes.xhtml#ch03foot_08))文件类型在TSK维基中有文档说明，下面展示了：
- en: '| r/r | Regular file |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| r/r | 常规文件 |'
- en: '| d/d | Directory |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| d/d | 目录 |'
- en: '| c/c | Character device |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| c/c | 字符设备 |'
- en: '| b/b | Block device |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| b/b | 块设备 |'
- en: '| l/l | Symbolic link |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| l/l | 符号链接 |'
- en: '| p/p | Named FIFO |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| p/p | 命名FIFO |'
- en: '| h/h | Socket |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| h/h | 套接字 |'
- en: A dash (`-/-`) on either side of the slash indicates an unknown file type (that
    is, it couldn’t be found in either the directory entry or the inode). The number
    following the file type represents the inode. Note how two files can share the
    same inode (*Vaduz* and *Zurich*). These are hard-linked files. An asterisk (`*`)
    indicates a deleted file. If a file was deleted and the inode number was reused
    (reallocated) for a new file, `(realloc)` will be shown (this can also happen
    when files are renamed). If a file was deleted and no filename information exists
    (only the inode data), it will be listed in a TSK *$OrphanFiles* virtual directory.
    TSK may display additional information with a file or directory type of `v/v`
    or `V/V`, but those names are virtual and don’t exist in the filesystem under
    analysis. The inode number used for the *$OrphanFiles* virtual directory is derived
    from the maximum number of inodes plus one.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 斜杠两边的破折号（`-/-`）表示未知的文件类型（即无法在目录条目或inode中找到）。文件类型后面的数字表示inode编号。注意，两个文件可能共享相同的inode（*Vaduz*和*Zurich*）。这些是硬链接文件。星号（`*`）表示已删除的文件。如果一个文件被删除并且inode编号被重新使用（重新分配）给一个新文件，则会显示`(realloc)`（这也可能发生在文件重命名时）。如果文件被删除且没有文件名信息（只有inode数据），它将在TSK的*$OrphanFiles*虚拟目录中列出。TSK可能会显示附加信息，文件或目录类型为`v/v`或`V/V`，但这些名称是虚拟的，并不存在于正在分析的文件系统中。用于*$OrphanFiles*虚拟目录的inode编号来源于最大inode数加一。
- en: 'We can also use TSK commands to extract content from the filesystem. Here are
    a few examples:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用TSK命令从文件系统中提取内容。以下是一些示例：
- en: 'Extract a file based on inode number (use `-s` to include slack): `icat partimage.raw
    1234`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于inode编号提取文件（使用`-s`包括空闲空间）：`icat partimage.raw 1234`
- en: 'Extract a file based on filename (use `-s` to include slack): `fcat hello.txt
    /dev/sda1`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于文件名提取文件（使用`-s`包括空闲空间）：`fcat hello.txt /dev/sda1`
- en: 'Extract filesystem blocks (with offset and number of blocks): `blkcat partimage.raw
    56789 1`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取文件系统块（带偏移量和块数量）：`blkcat partimage.raw 56789 1`
- en: 'Extract all unallocated filesystem blocks: `blkls partimage.raw`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取所有未分配的文件系统块：`blkls partimage.raw`
- en: 'Extract all file slackspace (from allocated blocks): `blkls -s partimage.raw`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取所有文件的空闲空间（来自已分配的块）：`blkls -s partimage.raw`
- en: 'Extract one drive sector with `dd` (increment `count` for more sectors): `dd
    if=image.raw skip=12345 count=1`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dd`提取一个驱动器扇区（增加`count`提取更多扇区）：`dd if=image.raw skip=12345 count=1`
- en: Always pipe or redirect extracted output to a program or file (with `|` or `>`)
    or you will mess up your shell/terminal or risk executing unwanted commands.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 始终将提取的输出通过管道或重定向到程序或文件（使用`|`或`>`），否则你会弄乱你的shell/终端，甚至可能执行不需要的命令。
- en: 'For easier reference, I’ve grouped all the TSK commands by analysis or extraction
    function here:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于参考，我已将所有TSK命令按分析或提取功能分组，见下表：
- en: 'Forensic images: `img_cat`, `img_stat`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 法医图像：`img_cat`，`img_stat`
- en: 'Partitions: `mmcat`, `mmls`, `mmstat`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区：`mmcat`，`mmls`，`mmstat`
- en: 'Filesystem information: `fsstat`, `pstat`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统信息：`fsstat`，`pstat`
- en: 'Filesystem blocks: `blkcalc`, `blkcat`, `blkls`, `blkstat`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统块：`blkcalc`，`blkcat`，`blkls`，`blkstat`
- en: 'Filenames: `fcat`, `ffind`, `fls`, `fiwalk`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名：`fcat`，`ffind`，`fls`，`fiwalk`
- en: 'Inodes: `icat`, `ifind`, `ils`, `istat`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: inode：`icat`，`ifind`，`ils`，`istat`
- en: 'Timelines: `mactime`, `tsk_gettimes`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间线：`mactime`，`tsk_gettimes`
- en: 'Search and sort: `sigfind`, `sorter`, `srch_strings`, `tsk_comparedir`, `tsk_loaddb`,
    `tsk_recover`, `hfind`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索和排序：`sigfind`，`sorter`，`srch_strings`，`tsk_comparedir`，`tsk_loaddb`，`tsk_recover`，`hfind`
- en: 'Filesystem journal: `jcat`, `jls`, `usnjls`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统日志：`jcat`，`jls`，`usnjls`
- en: You can find more information in the man pages. (The Debian project has some
    additional man pages not included in the TSK software package.)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 man 页中找到更多信息。（Debian 项目有一些额外的 man 页，这些并未包含在 TSK 软件包中。）
- en: Most commercial forensic tools will perform these tasks. As mentioned previously,
    an alternative for unsupported filesystems is the debugging and troubleshooting
    tools that are typically provided by the filesystem’s developers. Those will be
    used in the following sections on ext4, btrfs, and xfs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数商业取证工具都会执行这些任务。如前所述，对于不受支持的文件系统，替代方案是文件系统开发者通常提供的调试和故障排除工具。这些将在接下来的 ext4、btrfs
    和 xfs 部分中使用。
- en: '**An Analysis of ext4**'
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**ext4 分析**'
- en: One of the oldest and most popular of the Linux filesystems is the *extended
    filesystem*, or *ext*. Every modern Linux distribution supports ext4, and many
    of them specify it as the default filesystem during installation. Because of the
    popularity of ext (2, 3, and 4), many commercial forensic tools support ext4\.
    TSK (and Autopsy) support it, and many other ext4 troubleshooting, debugging,
    and data recovery tools are available.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 文件系统中最古老且最流行的之一是 *扩展文件系统*，或称 *ext*。每个现代 Linux 发行版都支持 ext4，并且许多发行版在安装过程中将其指定为默认文件系统。由于
    ext（2、3 和 4）的普及，许多商业取证工具支持 ext4。TSK（和 Autopsy）支持它，还有许多其他 ext4 故障排除、调试和数据恢复工具可用。
- en: Ext4 is a scalable filesystem, supports journaling, is extent-based, and supports
    directory-level encryption. See the ext4(5) man page for more information.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Ext4 是一个可扩展的文件系统，支持日志记录，基于扩展，并支持目录级加密。更多信息请参见 ext4(5) man 页。
- en: Compared to other popular Linux filesystems, ext4 contains more forensic artifacts
    in the superblock that could be useful in an investigation. However, it also eliminates
    more traces of information during the deletion process, making recovery of deleted
    files more difficult.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他流行的 Linux 文件系统相比，ext4 在超级块中包含更多可能在调查中有用的取证信息。然而，它也在删除过程中消除了更多的信息痕迹，这使得恢复删除文件变得更加困难。
- en: '***Filesystem Metadata: Superblock***'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件系统元数据：超级块***'
- en: 'The superblock starts at byte offset 1024 (0x400) from the start of the filesystem.
    The magic string for ext2, ext3, and ext4 is 0xEF53 (the same for all three versions).
    The location of the magic string is at byte offset 56 (0x38) in the superblock
    and, therefore, byte offset 1080 (0x438) from the beginning of the filesystem.
    It is written on disk in little-endian order:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 超级块从文件系统开始的字节偏移量 1024（0x400）处开始。ext2、ext3 和 ext4 的魔术字符串是 0xEF53（三个版本都相同）。魔术字符串的位置位于超级块的字节偏移量
    56（0x38）处，因此，它距离文件系统开始的字节偏移量为 1080（0x438）。它以小端字节序写入磁盘：
- en: '[PRE11]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The ext4 superblock has timestamps, unique identifiers, features, and descriptive
    information that can be interesting in a forensic examination. For example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ext4 超级块包含时间戳、唯一标识符、特性和描述性信息，这些在取证检查中可能非常有用。例如：
- en: Filesystem creation timestamp
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统创建时间戳
- en: Filesystem last-mounted timestamp
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统上次挂载时间戳
- en: Filesystem last-checked (`fsck`) timestamp
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统上次检查时间戳（`fsck`）
- en: Superblock last-written timestamp
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超级块上次写入时间戳
- en: User-specified volume name or label (maximum 16 characters)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户指定的卷名称或标签（最大 16 个字符）
- en: Unique volume UUID
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一的卷 UUID
- en: 'Creator OS: If this is not Linux, it could indicate another OS was involved
    (0 = Linux, 3 = FreeBSD)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建操作系统：如果不是 Linux，可能表示其他操作系统参与了（0 = Linux，3 = FreeBSD）
- en: 'Directory where last mounted: If this is not a standard location, the user
    may have manually created the mount point on a system'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上次挂载的目录：如果这不是标准位置，用户可能在系统上手动创建了挂载点
- en: 'Number of times mounted since last `fsck`: For external drives, this could
    be an indicator of how often the filesystem was used'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自上次 `fsck` 后挂载的次数：对于外部驱动器，这可能是文件系统使用频率的指示器
- en: 'Number KiB written over the lifetime of the filesystem: This provides an idea
    about how “busy” the filesystem was in the past'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统生命周期内写入的 KiB 数量：这可以提供文件系统过去“忙碌”程度的线索
- en: The number of KiB written over the lifetime of the filesystem can be interesting
    in some cases (data theft, for example) where large amounts of files are copied
    to external media. If the total number of bytes ever written is the same as the
    total size of all the files, it indicates the filesystem was not used for anything
    else. If a drive has SMART capabilities, the *Total LBAs Written* attribute can
    be used to compare the amount of data on the drive to data written over the lifetime
    of the drive itself (similar analysis may be done with the *Total LBAs Read* attribute).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下（例如数据盗窃），文件系统生命周期中写入的KiB数量可能很有趣，尤其是在大量文件被复制到外部媒体时。如果写入的总字节数与所有文件的总大小相同，则表示文件系统没有用于其他任何用途。如果驱动器具有SMART功能，可以使用*Total
    LBAs Written*属性来比较驱动器上的数据量与驱动器生命周期内写入的数据量（类似的分析也可以通过*Total LBAs Read*属性进行）。
- en: 'Commercial forensic tools should support the analysis of the ext4 superblock;
    otherwise `fsstat` can be used. The `dumpe2fs` tool (part of the `e2fsprogs` software
    package) also shows detailed information about the superblock. In this example,
    a forensic image of a partition (*partimage.raw*) is used, and the `-h` flag specifies
    that superblock’s header information:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 商业法医工具应该支持ext4超级块的分析；否则可以使用`fsstat`。`dumpe2fs`工具（`e2fsprogs`软件包的一部分）也会显示有关超级块的详细信息。在这个示例中，使用的是一个分区的法医镜像（*partimage.raw*），`-h`标志指定了超级块的头部信息：
- en: '[PRE12]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Some records have been removed from this output to highlight artifacts that
    could be useful in a forensic investigation. If the volume name (`TooManySecrets`)
    is specified by the user, it may provide a description of the contents (from the
    user’s perspective). The `Last mounted on:` record indicates the directory where
    the filesystem was last mounted. In a forensic investigation, this is especially
    interesting for external drives because it can associate the drive with a mount
    point or user on a particular Linux system. The mount point can be manually created
    by the user or temporarily created by a disk manager. In the preceding example,
    the filesystem was last mounted on */run/media/sam/TooManySecrets*, indicating
    that user Sam possibly mounted it on their desktop system with a disk manager.^([9](footnotes.xhtml#ch03foot_09))
    See *[https://www.kernel.org/doc/html/latest/filesystems/ext4/globals.html](https://www.kernel.org/doc/html/latest/filesystems/ext4/globals.html)*
    for authoritative documentation on the superblock structure.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中已删除一些记录，以突出可能在法医调查中有用的文物。如果用户指定了卷名称（`TooManySecrets`），它可能提供对内容的描述（从用户的角度来看）。`Last
    mounted on:`记录显示了文件系统最后挂载的目录。在法医调查中，这对于外部驱动器尤其有意义，因为它可以将驱动器与某个Linux系统上的挂载点或用户关联。挂载点可以由用户手动创建，或由磁盘管理器临时创建。在前面的示例中，文件系统最后挂载在*/run/media/sam/TooManySecrets*，这表明用户Sam可能通过磁盘管理器在他们的桌面系统上挂载了它。^([9](footnotes.xhtml#ch03foot_09))
    有关超级块结构的权威文档，请参见 *[https://www.kernel.org/doc/html/latest/filesystems/ext4/globals.html](https://www.kernel.org/doc/html/latest/filesystems/ext4/globals.html)*。
- en: 'TSK’s `fsstat` tool can display the superblock information, as well, but in
    less detail than `dumpe2fs`; for example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: TSK的`fsstat`工具也可以显示超级块信息，但比`dumpe2fs`的显示内容要少一些；例如：
- en: '[PRE13]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The full output will describe the block groups and allocation information. In
    many forensic examinations, the block allocation information is not needed for
    drawing investigative conclusions (but could still be provided in the appendix
    of a forensic report).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的输出将描述块组和分配信息。在许多法医检查中，块分配信息并不是得出调查结论所必需的（但仍可以在法医报告的附录中提供）。
- en: Notice how `dumpe2fs`’s `Filesystem UUID` and `fsstat`’s `Volume ID` are different
    representations of the same hexadecimal string.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`dumpe2fs`的`Filesystem UUID`和`fsstat`的`Volume ID`是同一个十六进制字符串的不同表示方式。
- en: '***File Metadata: Inodes***'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件元数据：Inodes***'
- en: The inode structure in ext4 is well documented and has many fields that are
    interesting from a digital forensics perspective.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ext4中的inode结构文档化良好，具有许多从数字取证角度来看很有趣的字段。
- en: The file size and block count are specified. These are usually not exactly the
    same unless the file size is a multiple of the block size. Any data residing beyond
    the end of the file in the last block is the file slack.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 文件大小和块数是指定的。这些通常不会完全相同，除非文件大小是块大小的整数倍。任何位于文件最后一个块末尾的超出部分数据都被称为文件松弛区。
- en: Additional flags are specified in the inode. For example, a flag of 0x80 states
    that the file access time should not be updated. A flag of 0x800 states that the
    inode blocks are encrypted.^([10](footnotes.xhtml#ch03foot_010))
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的标志被指定在inode中。例如，0x80的标志表示文件访问时间不应更新。0x800的标志表示inode块已加密。^([10](footnotes.xhtml#ch03foot_010))
- en: The file mode defines the permissions (read, write, execute for owner, group,
    and other), and special bits (SetUID, SetGID, and the sticky bit). The mode also
    specifies the file type (regular, directory, symbolic link, FIFO, socket, and
    character and block devices).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 文件模式定义了权限（所有者、组和其他的读、写、执行权限）和特殊位（SetUID、SetGID和粘滞位）。模式还指定了文件类型（常规文件、目录、符号链接、FIFO、套接字以及字符设备和块设备）。
- en: Extended attributes (ACLs, for example) are not stored in the inode, but in
    a separate data block. The inode has a pointer to this data block.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展属性（如ACL）不存储在inode中，而是存储在一个单独的数据块中。inode有指向该数据块的指针。
- en: File ownership is defined by the owner (UID) and group (GID). Originally this
    was 16 bits, allowing for a maximum of 65,535 users and groups. Two additional
    bytes each were later assigned (but stored in separate places in the inode), making
    the UID and GID 32 bits wide.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 文件所有权由所有者（UID）和组（GID）定义。最初这是16位，最多允许65,535个用户和组。后来分别为UID和GID分配了两个额外的字节（但存储在inode的不同位置），使得UID和GID变为32位。
- en: 'Five timestamps (M, A, C, B, and D) are stored in the ext4 inode:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 五个时间戳（M、A、C、B 和 D）存储在ext4的inode中：
- en: Last data modification time (`mtime`)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后数据修改时间（`mtime`）
- en: Last access time (`atime`)
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后访问时间（`atime`）
- en: Last inode change time (`ctime`)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后inode修改时间（`ctime`）
- en: Creation time (`crtime`, sometimes called the “birth” timestamp)
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建时间（`crtime`，有时称为“出生”时间戳）
- en: Deletion time
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除时间
- en: The deletion timestamp is set only when the inode is changed from allocated
    to unallocated.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 删除时间戳仅在inode从已分配变为未分配时设置。
- en: Historically, timestamps have been 32 bits long, containing the seconds between
    January 1, 1970 and January 19, 2038\. Modern systems need greater resolution
    (nanoseconds) and need to go beyond 2038\. To solve this, ext4 adds an additional
    four bytes for each timestamp. These additional 32 bits are split, with 2 bits
    providing time after 2038, and 30 bits providing higher resolution (more time
    accuracy).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，时间戳是32位长，包含从1970年1月1日到2038年1月19日之间的秒数。现代系统需要更高的分辨率（纳秒），并且需要超越2038年。为了解决这个问题，ext4为每个时间戳添加了额外的四个字节。这额外的32位被分为两部分，2位表示2038年之后的时间，30位提供更高的分辨率（更精确的时间）。
- en: 'You can view the ext4 inode information with TSK’s `istat` tool:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用TSK的`istat`工具查看ext4 inode信息：
- en: '[PRE14]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This output shows the state of the inode (`Allocated`), ownership and permissions,
    four timestamps, and which blocks are used.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出显示了inode的状态（`已分配`）、所有权和权限、四个时间戳以及使用的块。
- en: 'Alternatively, we can use `debugfs` (part of `e2fsprogs`) for more information.
    The following is an example using a deleted file. The `-R` flag refers to *request*,
    not *read-only* (it’s read-only by default), the `"stat <136939>"` parameter requests
    stat information for inode 136939, and the command operates on the forensic image
    file *partimage.raw*:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以使用`debugfs`（`e2fsprogs`的一部分）来获取更多信息。以下是使用已删除文件的示例。`-R`标志表示*请求*，而不是*只读*（默认是只读），`"stat
    <136939>"`参数请求获取inode 136939的stat信息，命令作用于取证映像文件*partimage.raw*：
- en: '[PRE15]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a deleted file’s inode and contains five timestamps, including the time
    of deletion. Notice the lack of block information after the `EXTENTS:` line. When
    a file is deleted on ext4, the blocks previously used are removed from the unused
    inode. This means that file recovery using some traditional forensic techniques
    may not be possible.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个已删除文件的inode，包含五个时间戳，包括删除时间。请注意，`EXTENTS:` 行之后没有块信息。当文件在ext4上被删除时，先前使用的块会从未使用的inode中移除。这意味着使用一些传统的取证技术可能无法恢复文件。
- en: '***List and Extract Files***'
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列出并提取文件***'
- en: 'The file listing and extraction examples used TSK on ext4 in the previous section,
    so I’ll provide an alternative method here. The `debugfs` tool can do most of
    the things TSK can do; for example:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节使用TSK在ext4上列出和提取文件的示例，因此我将在这里提供另一种方法。`debugfs`工具可以完成TSK能做的大部分事情；例如：
- en: 'List directory contents, including deleted files (not recursive): `debugfs
    -R "ls -drl" partimage.raw`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出目录内容，包括已删除的文件（非递归）：`debugfs -R "ls -drl" partimage.raw`
- en: 'Extract contents of a file by specifying the inode (similar to `icat`): `debugfs
    -R "cat <14>" partimage.raw`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定inode提取文件内容（类似于`icat`）：`debugfs -R "cat <14>" partimage.raw`
- en: 'Extract the inode metadata (similar to `istat`): `debugfs -R "stat <14>" partimage.raw`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取 i节点元数据（类似于 `istat`）：`debugfs -R "stat <14>" partimage.raw`
- en: 'Extract the inode metadata as a hex dump (similar to `istat` but raw): `debugfs
    -R "inode_dump <14>" partimage.raw`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取 i节点元数据作为十六进制转储（类似于 `istat`，但为原始数据）：`debugfs -R "inode_dump <14>" partimage.raw`
- en: 'The `<14>` notation represents an inode (14 in this example). A file path can
    also be specified:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`<14>` 符号表示一个 i节点（本示例中为 14）。也可以指定文件路径：'
- en: '[PRE16]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The output shows the file list with inodes, sizes, timestamps, and filenames.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示包含 i节点、大小、时间戳和文件名的文件列表。
- en: 'The `debugfs` output can be displayed in the terminal or redirected into a
    file on the forensic analysis machine. Here the file from the preceding example
    (`evilplan.txt`) is being displayed with `debugfs`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`debugfs` 输出可以在终端中显示，或者重定向到取证分析机器上的文件中。这里，前面示例中的文件（`evilplan.txt`）正在通过 `debugfs`
    显示：'
- en: '[PRE17]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The content of the file is sent to the terminal (`stdout`) and can be redirected
    into a file or piped into a program. The `debugfs` version string is seen on the
    terminal but not added to files or sent to programs (this is `stderr` output).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的内容被发送到终端（`stdout`），并可以重定向到文件或通过管道传送给程序。`debugfs` 版本字符串会显示在终端上，但不会添加到文件中或发送给程序（这是
    `stderr` 输出）。
- en: Another feature of ext4 that is interesting for forensic examiners is encrypted
    subdirectories. We’ll look at identification and decryption of ext4 subdirectories
    at the end of this chapter.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ext4 的另一个对取证检查员很有意思的特性是加密子目录。我们将在本章结束时探讨 ext4 子目录的识别和解密。
- en: The ext4 specification is published on the kernel documentation site at *[https://www.kernel.org/doc/html/latest/filesystems/ext4/index.html](https://www.kernel.org/doc/html/latest/filesystems/ext4/index.html)*.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ext4 规范已发布在内核文档网站上，网址为 *[https://www.kernel.org/doc/html/latest/filesystems/ext4/index.html](https://www.kernel.org/doc/html/latest/filesystems/ext4/index.html)*。
- en: 'For more information specific to digital forensics, several research papers
    on ext4 forensics have also been written:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有关数字取证的更多信息，也有多篇关于 ext4 取证的研究论文：
- en: Kevin D. Fairbanks, “An Analysis of Ext4 for Digital Forensics,” *[https://www.sciencedirect.com/science/article/pii/S1742287612000357/](https://www.sciencedirect.com/science/article/pii/S1742287612000357/)*.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kevin D. Fairbanks，"Ext4 在数字取证中的分析"， *[https://www.sciencedirect.com/science/article/pii/S1742287612000357/](https://www.sciencedirect.com/science/article/pii/S1742287612000357/)*。
- en: 'Thomas Göbel and Harald Baier, “Anti-Forensics in Ext4: On Secrecy and Usability
    of Timestamp-Based Data Hiding,” *[https://www.sciencedirect.com/science/article/pii/S174228761830046X/](https://www.sciencedirect.com/science/article/pii/S174228761830046X/)*.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thomas Göbel 和 Harald Baier，"Ext4 中的反取证：基于时间戳的数据隐藏的保密性和可用性"， *[https://www.sciencedirect.com/science/article/pii/S174228761830046X/](https://www.sciencedirect.com/science/article/pii/S174228761830046X/)*。
- en: 'Andreas Dewald and Sabine Seufert, “AFEIC: Advanced Forensic Ext4 Inode Carving,”
    *[https://dfrws.org/presentation/afeic-advanced-forensic-ext4-inode-carving/](https://dfrws.org/presentation/afeic-advanced-forensic-ext4-inode-carving/)*.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Andreas Dewald 和 Sabine Seufert，"AFEIC：高级取证 Ext4 i节点雕刻"， *[https://dfrws.org/presentation/afeic-advanced-forensic-ext4-inode-carving/](https://dfrws.org/presentation/afeic-advanced-forensic-ext4-inode-carving/)*。
- en: '**An Analysis of btrfs**'
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**btrfs 分析**'
- en: Chris Mason originally developed btrfs while working at Oracle, and it was announced
    on the Linux Kernel Mailing List (LKML) in 2007\. The Linux community was in need
    of something more than the aging ext3, and for various reasons, ReiserFS and zfs
    weren’t viable options at that time. Since then, btrfs has become part of the
    mainline Linux kernel and has grown in popularity. Today, SUSE and Fedora use
    btrfs as their default filesystem, Facebook uses it internally, and storage companies
    like Synology depend on it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Chris Mason 最初在 Oracle 工作时开发了 btrfs，并于 2007 年在 Linux 内核邮件列表（LKML）上发布。那时，Linux
    社区需要一种比逐渐老化的 ext3 更强大的文件系统，出于种种原因，ReiserFS 和 zfs 在当时并不是可行的选择。从那时起，btrfs 成为 Linux
    内核的主线部分，并逐渐获得了更广泛的应用。如今，SUSE 和 Fedora 将 btrfs 作为默认文件系统，Facebook 在内部使用它，像 Synology
    这样的存储公司也依赖它。
- en: Among the many modern features in btrfs are multiple device management, subvolumes,
    and CoW snapshots. Because of these features, btrfs doesn’t need a separate volume
    management layer like LVM. Today, btrfs is actively developed, and newly implemented
    features are listed on the btrfs homepage at *[https://btrfs.wiki.kernel.org/index.php/Main_Page](https://btrfs.wiki.kernel.org/index.php/Main_Page)*.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: btrfs 的众多现代特性之一是多设备管理、子卷和 CoW 快照。由于这些特性，btrfs 不需要像 LVM 那样的独立卷管理层。今天，btrfs 正在积极开发，新增的功能列在
    btrfs 官方主页 *[https://btrfs.wiki.kernel.org/index.php/Main_Page](https://btrfs.wiki.kernel.org/index.php/Main_Page)*。
- en: As of this writing, btrfs support among digital forensic tools is poor. Most
    of the major forensic analysis suites don’t support it, and even TSK has no support
    for btrfs at the moment. Several experimental and research implementations for
    TSK btrfs support are available on GitHub, including an older pull request for
    TSK to add support (*[https://github.com/basicmaster/sleuthkit/](https://github.com/basicmaster/sleuthkit/)*)
    and a stand-alone tool that uses TSK libraries and mimics TSK commands (*[https://github.com/shujianyang/btrForensics/](https://github.com/shujianyang/btrForensics/)*).
    These tools may or may not work for your btrfs filesystem, so use them at your
    own risk.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，数字取证工具对btrfs的支持较差。大多数主要的取证分析套件不支持btrfs，即使是TSK目前也没有对btrfs的支持。GitHub上有几个针对TSK
    btrfs支持的实验性和研究实现，包括一个较旧的TSK拉取请求以添加支持（*[https://github.com/basicmaster/sleuthkit/](https://github.com/basicmaster/sleuthkit/)*)，以及一个独立工具，它使用TSK库并模仿TSK命令（*[https://github.com/shujianyang/btrForensics/](https://github.com/shujianyang/btrForensics/)*）。这些工具可能适用于你的btrfs文件系统，也可能不适用，所以请自行承担使用风险。
- en: In this section, we’ll use a combination of tools from the btrfs project team
    (the `btrfs-progs` software package), and research from Fraunhofer FKIE presented
    at DFRWS USA in 2018 (*[https://www.sciencedirect.com/science/article/pii/S1742287618301993/](https://www.sciencedirect.com/science/article/pii/S1742287618301993/)*).
    You can download a forked version of TSK with patches for btrfs support from *[https://github.com/fkie-cad/sleuthkit/](https://github.com/fkie-cad/sleuthkit/)*.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用来自btrfs项目团队（`btrfs-progs`软件包）的工具组合，以及Fraunhofer FKIE在2018年DFRWS USA会议上发布的研究成果（*[https://www.sciencedirect.com/science/article/pii/S1742287618301993/](https://www.sciencedirect.com/science/article/pii/S1742287618301993/)*）。你可以从*[https://github.com/fkie-cad/sleuthkit/](https://github.com/fkie-cad/sleuthkit/)*下载一个带有btrfs支持补丁的TSK分支版本。
- en: 'The examples shown in this section use a variety of tools and techniques. Each
    tool may require a different form of access to a btrfs filesystem. To help avoid
    confusion, these are the device, file, and directory names used in the examples
    below:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中展示的示例使用了多种工具和技术。每个工具可能需要不同的访问方式来访问btrfs文件系统。为了避免混淆，以下是示例中使用的设备、文件和目录名称：
- en: '***image.raw*** A forensically acquired raw image file (using sector offsets
    for the filesystem)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '***image.raw*** 一份法医采集的原始镜像文件（使用文件系统的扇区偏移）'
- en: '***partimage(X).raw*** Separately extracted partition image file(s) containing
    only the filesystem'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '***partimage(X).raw*** 单独提取的分区镜像文件，仅包含文件系统'
- en: '***/dev/loopX*** A block device (in */dev/*) physically attached or using a
    loopback (`losetup`)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '***/dev/loopX*** 一个块设备（在*/dev/*中）物理连接或使用回环设备（`losetup`）'
- en: '***/evidence/*** A path to a mounted btrfs filesystem'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '***/evidence/*** 一个挂载的btrfs文件系统的路径'
- en: '***pool/* or *poolm/*** A pool directory containing one or more btrfs partition
    image files'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '***pool/* 或 *poolm/*** 一个包含一个或多个btrfs分区镜像文件的池目录'
- en: Paths to files and directories are considered to be relative to the current
    working directory.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和目录的路径被认为是相对于当前工作目录的。
- en: '***Filesystem Metadata: Superblock***'
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件系统元数据：超级块***'
- en: 'A btrfs filesystem can be identified from the magic string in the superblock.
    The primary btrfs superblock is at byte offset 65536 (0x10000) from the start
    of the filesystem. On a drive with 512 byte sectors, this would be sector 128
    from the start of the partition. The eight-byte magic string that identifies a
    btrfs filesystem is `_BHRfS_M`, and is shown here together with the hexadecimal
    representation:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过超级块中的魔术字符串来识别btrfs文件系统。主btrfs超级块位于文件系统起始位置的字节偏移量65536（0x10000）。在512字节扇区的硬盘上，这将是分区起始位置的第128个扇区。用于识别btrfs文件系统的8字节魔术字符串是`_BHRfS_M`，并且在这里展示了它的十六进制表示：
- en: '[PRE18]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This magic string is at byte offset 64 (0x40) in the superblock, which is byte
    offset 65600 (0x10040) from the start of the partition containing the filesystem.
    A search for this magic string across all sectors of the drive may reveal mirror
    copies of the superblock or other btrfs filesystems for analysis.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这个魔术字符串位于超级块的字节偏移量64（0x40），即从包含文件系统的分区起始位置的字节偏移量65600（0x10040）。在所有磁盘扇区中搜索该魔术字符串可能会揭示超级块的镜像副本或其他btrfs文件系统以供分析。
- en: 'The Fraunhofer FKIE TSK fork added several new flags to the filesystem commands.
    Forensic images of btrfs partitions are expected to be found in a pool directory
    (called `pool/` in the following examples) and specified with the `-P` flag. In
    this example, `fsstat` is used to output the superblock, which contains several
    items of forensic interest:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Fraunhofer FKIE TSK fork向文件系统命令添加了几个新的标志。预计btrfs分区的法医镜像会在一个池目录中找到（在以下示例中称为`pool/`），并通过`-P`标志指定。在这个示例中，使用`fsstat`输出超级块，其中包含几个法医关注的项目：
- en: '[PRE19]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The user can choose a label ➊ (maximum 256 characters), which may be a helpful
    artifact in an investigation. The first UUID ➋ is the unique identifier for the
    btrfs filesystem, and the second UUID ➍ is the unique identifier for the btrfs
    drive device. The drive’s total capacity ➎ is shown together with the used capacity
    ➏. These byte totals should correlate with other capacity artifacts collected
    during the examination (like the partition table, for example). The `Generation`
    ➌ is updated with new changes, so the filesystem knows which copy (out of all
    the redundant copies) of the superblock is the newest. Lastly, a list of subvolumes
    and snapshots ➐ are shown (these are described in a separate section below).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以选择一个标签➊（最多256个字符），这可能是调查中的一个有用的痕迹。第一个UUID ➋是btrfs文件系统的唯一标识符，第二个UUID ➍是btrfs驱动器设备的唯一标识符。驱动器的总容量➎与已使用的容量➏一起显示。这些字节总数应该与在检查过程中收集的其他容量痕迹相关联（例如，分区表）。`Generation`
    ➌随着新更改的更新，文件系统知道哪个副本（在所有冗余副本中）是最新的。最后，显示一个子卷和快照的列表➐（这些在下面的单独部分中有描述）。
- en: The btrfs command `btrfs inspect-internal dump-super partimage.raw` provides
    the same information plus some additional statistics and flags (which are less
    useful for most forensic investigations). The `btrfs inspect-internal` command
    can analyze a variety of low-level technical artifacts about the filesystem and
    how structures are stored on a drive. See the btrfs-inspect-internal(8) man page
    for more information. The btrfs superblock does not contain any timestamps like
    ext4.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: btrfs命令`btrfs inspect-internal dump-super partimage.raw`提供相同的信息，并且还包含一些额外的统计数据和标志（对于大多数法医调查来说，这些信息不太有用）。`btrfs
    inspect-internal`命令可以分析有关文件系统的多种低级技术特征以及如何在驱动器上存储这些结构。有关更多信息，请参见btrfs-inspect-internal(8)手册页。与ext4不同，btrfs超级块不包含任何时间戳。
- en: '***File Metadata: Inodes***'
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件元数据：Inodes***'
- en: 'The btrfs inode structure is documented on the [kernel.org](http://kernel.org)
    website (*[https://btrfs.wiki.kernel.org/index.php/Data_Structures#btrfs_inode_ref](https://btrfs.wiki.kernel.org/index.php/Data_Structures#btrfs_inode_ref)*).
    Unlike ext4 and xfs, a btrfs inode contains minimal information and pushes some
    information about files into various separate tree structures. The contents of
    a btrfs inode include the following information:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: btrfs inode结构在[ kernel.org](http://kernel.org)网站上有文档说明（* [https://btrfs.wiki.kernel.org/index.php/Data_Structures#btrfs_inode_ref](https://btrfs.wiki.kernel.org/index.php/Data_Structures#btrfs_inode_ref)
    *）。与ext4和xfs不同，btrfs inode包含最少的信息，并将一些关于文件的信息推送到不同的树形结构中。btrfs inode的内容包括以下信息：
- en: generation    Incrementing counter on changes
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: generation    变更增量计数器
- en: transid    Transaction ID
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: transid    事务ID
- en: size    Size of the file in bytes
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: size    文件大小（以字节为单位）
- en: nbytes    Size of the allocated blocks in bytes (directories are 0)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: nbytes    分配块的大小（以字节为单位）（目录为0）
- en: nlink    Number of links
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: nlink    链接数
- en: uid    File owner
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: uid    文件所有者
- en: gid    File group
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: gid    文件组
- en: mode    Permissions
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: mode    权限
- en: rdev    If inode is a device, the major/minor numbers
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: rdev    如果inode是设备，包含主设备号/次设备号
- en: flags    Inode flags (listed in the next paragraph)
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: flags    inode标志（列在下一段）
- en: sequence    For NFS compatibility (initialized to 0 and incremented each time
    the `mtime` value is changed)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: sequence    用于NFS兼容性（初始化为0，每次`mtime`值更改时递增）
- en: atime    Last access timestamp
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: atime    最后访问时间戳
- en: ctime    Last inode change timestamp
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ctime    最后inode变更时间戳
- en: mtime    Last file content change timestamp
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: mtime    最后文件内容变更时间戳
- en: otime    Inode creation timestamp (file birth)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: otime    inode创建时间戳（文件创建时间）
- en: Most of these items are familiar and can be found in other filesystems. The
    NFS compatibility sequence numbers are incremented each time the content changes
    (`mtime`). In an investigation, knowing how many (or how few) times a file was
    modified could be interesting. It could also indicate how “busy” changes were
    to a file or directory in the past or compared to other files.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项大多数是熟悉的，并且可以在其他文件系统中找到。NFS兼容性序列号在每次内容更改时递增（`mtime`）。在调查中，知道一个文件被修改了多少次（或修改得很少）可能很有趣。它还可能指示文件或目录过去的修改“忙碌”程度，或者与其他文件相比的变化情况。
- en: 'The inode flags^([11](footnotes.xhtml#ch03foot_011)) provide additional attributes
    imposed on a file. The btrfs documentation defines the following flags in the
    inode structure:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: inode标志^([11](footnotes.xhtml#ch03foot_011))提供了施加于文件的附加属性。btrfs文档在inode结构中定义了以下标志：
- en: NODATASUM    Do not perform checksum operations on this inode
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: NODATASUM    不对该inode执行校验和操作
- en: NODATACOW    Do not perform CoW for data extents on this inode when the reference
    count is 1
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: NODATACOW    当引用计数为1时，不对该inode上的数据扩展执行写时复制（CoW）
- en: READONLY    Inode is read-only regardless of Unix permissions or ownership (superseded
    by `IMMUTABLE`)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: READONLY    Inode是只读的，无论Unix权限或所有权如何（被`IMMUTABLE`所取代）
- en: NOCOMPRESS    Do not compress this inode
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: NOCOMPRESS    不压缩该inode
- en: PREALLOC    Inode contains preallocated extents
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: PREALLOC    Inode包含预分配的扩展
- en: SYNC    Operations on this inode will be performed synchronously
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: SYNC    对该inode的操作将同步执行
- en: IMMUTABLE    Inode is read-only regardless of Unix permissions or ownership
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: IMMUTABLE    Inode是只读的，无论Unix权限或所有权如何
- en: APPEND    Inode is append-only
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: APPEND    Inode为追加只用
- en: NODUMP    Inode is not a candidate for dumping using the `dump(8)` program
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: NODUMP    该inode不会成为使用`dump(8)`程序转储的候选项
- en: NOATIME    Do not update `atime` (last accessed timestamp)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: NOATIME    不更新`atime`（最后访问时间戳）
- en: DIRSYNC    Directory operations will be performed synchronously
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: DIRSYNC    目录操作将同步执行
- en: COMPRESS    Compression is enabled on this inode
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: COMPRESS    该inode启用了压缩
- en: The `NOATIME` attribute can affect forensic analysis, as the last accessed timestamp
    is no longer set by the kernel.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOATIME`属性可能会影响取证分析，因为最后访问的时间戳不再由内核设置。'
- en: 'Dumping the full inode information for a file on btrfs depends on the support
    provided by the forensics tool. For example, the Fraunhofer FKIE `istat` tool
    shows minimal information (the `-P` flag is explained in the next section):'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 转储btrfs中文件的完整inode信息取决于取证工具的支持。例如，Fraunhofer FKIE的`istat`工具显示最少的信息（`-P`标志将在下一节中解释）：
- en: '[PRE20]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This level of detail may be enough for some investigations. For more detail,
    the btrfs `inspect-internal` command provides much more information:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这种细节级别可能对某些调查来说已经足够。若需要更多详细信息，btrfs的`inspect-internal`命令提供了更多信息：
- en: '[PRE21]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This command dumps metadata for the entire filesystem. If the inode number is
    known, the command output can be searched for the inode item. Here inode 257 has
    been found and the full inode structure is shown.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令转储整个文件系统的元数据。如果已知inode号，可以搜索命令输出中的inode项。这里找到了inode 257，并显示了完整的inode结构。
- en: Depending on the file and number of objects, dumping the entire metadata with
    the btrfs `inspect-internal` command may produce a large amount of output. If
    multiple searches or more complex analysis are expected, it may be easier saving
    the output to a separate file.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文件和对象数量，使用btrfs的`inspect-internal`命令转储整个元数据可能会产生大量输出。如果预计进行多个搜索或更复杂的分析，可能会更容易将输出保存到单独的文件中。
- en: '***Multiple Devices and Subvolumes***'
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***多个设备和子卷***'
- en: 'UUIDs are used extensively in btrfs for different objects that make up the
    filesystem. GPT also uses UUIDs for various storage components. Some of these
    unique UUIDs are listed here to help explain the differences and provide clarity
    when interpreting what is being identified:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: UUID在btrfs中广泛用于组成文件系统的不同对象。GPT也使用UUID来表示各种存储组件。为了帮助解释差异并在解释标识的内容时提供清晰度，以下列出了其中一些唯一的UUID：
- en: UUID for each GPT device (a drive with a GPT partition)
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个GPT设备的UUID（具有GPT分区的驱动器）
- en: UUID for each GPT partition (PARTUUID)
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个GPT分区的UUID（PARTUUID）
- en: UUID for each btrfs filesystem
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个btrfs文件系统的UUID
- en: UUID for each btrfs device (a drive that is part of a btrfs filesystem, UUID_SUB)
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个btrfs设备的UUID（属于btrfs文件系统的驱动器，UUID_SUB）
- en: UUID for each btrfs subvolume or snapshot
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个btrfs子卷或快照的UUID
- en: These unique UUIDs can be used as identifiers when writing forensic reports
    or when correlating with other evidence sources. Understanding the UUIDs is important
    when analyzing btrfs systems with multiple devices.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这些独特的UUID可以作为写作取证报告时的标识符，或者在与其他证据来源关联时使用。了解UUID在分析包含多个设备的btrfs系统时非常重要。
- en: One of the design goals built into btrfs is volume management, and a single
    btrfs filesystem can be created across multiple physical devices. A “profile”
    defines how data and metadata are replicated across the devices (RAID levels and
    so on). See the mkfs.btrfs(8) man page for more information about creating btrfs
    filesystems.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: btrfs的设计目标之一是卷管理，一个单一的btrfs文件系统可以跨多个物理设备创建。“配置文件”定义了数据和元数据在设备之间的复制方式（如RAID级别等）。有关创建btrfs文件系统的更多信息，请参阅mkfs.btrfs(8)手册页。
- en: 'The developers of zfs use the term *pool* when describing multiple devices.
    The Fraunhofer btrfs patches for TSK use the same terminology and provide the
    `pls` command to list pool information for a collection of images saved to a pool
    directory. Other TSK commands include flags to specify a pool directory (`-P`),
    transaction/generation number (`-T`), and which subvolume to work with (`-S`).
    In this example, the *poolm/* directory on our forensic analysis machine contains
    multiple partition image files that were forensically acquired from three drives:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: zfs的开发人员在描述多个设备时使用术语*pool*。Fraunhofer btrfs补丁用于TSK时，也采用了相同的术语，并提供了`pls`命令列出保存到池目录中的镜像集合的池信息。其他TSK命令包括用于指定池目录（`-P`）、事务/生成编号（`-T`）以及操作的子卷（`-S`）的标志。在这个示例中，我们的取证分析机器上的*poolm/*目录包含了从三块硬盘中法证获取的多个分区镜像文件：
- en: '[PRE22]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This output reveals a filesystem UUID ➊, the number of devices that are part
    of the filesystem ➌, the profiles used (like `RAID1`) ➋, and the UUIDs (or GUIDs)
    of each btrfs device ➍. The device UUIDs shown here are part of the btrfs filesystem
    and are not the same as the UUIDs in the GPT partition table.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示了文件系统的UUID ➊、文件系统中设备的数量 ➌、使用的配置文件（如`RAID1`） ➋，以及每个btrfs设备的UUID（或GUID） ➍。这里显示的设备UUID是btrfs文件系统的一部分，不同于GPT分区表中的UUID。
- en: 'Subvolumes are a btrfs feature that divides the filesystem into separate logical
    parts that can have their own characteristics. Subvolumes are not segregated at
    the block/extent layer, and data blocks/extents may be shared between subvolumes.
    This is how snapshot functionality is implemented. The previous section showed
    a `fsstat` example that described the superblock. Also listed were the subvolumes
    found on the filesystem:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 子卷是btrfs的一项功能，它将文件系统划分为可以具有各自特征的独立逻辑部分。子卷在块/区段层面并没有被隔离，数据块/区段可以在子卷之间共享。这也是快照功能实现的方式。上一节展示了描述超级块的`fsstat`示例，还列出了文件系统中的子卷：
- en: '[PRE23]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Subvolumes have an ID number and their own UUIDs. At the file and directory
    level, subvolumes can be analyzed as if they were separate filesystems (files
    even have unique inodes across subvolumes). But at lower layers, files in different
    subvolumes may share blocks/extents.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 子卷有一个ID号和它们自己的UUID。在文件和目录级别，子卷可以像独立的文件系统一样进行分析（文件甚至在子卷之间具有唯一的inode）。但在更低的层次，位于不同子卷中的文件可能会共享块/区段。
- en: 'In some cases, you may want to mount the btrfs filesystem on the examination
    machine. Reasons for this may include browsing with file management tools, using
    applications (viewers and office programs), or running additional btrfs analysis
    commands that operate only on mounted directories. To illustrate, we’ll mount
    a single partition image (`pool/partimage.raw`) to an evidence directory (`/evidence/`)
    in a two-step process:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望将btrfs文件系统挂载到检查机器上。这样做的原因可能包括使用文件管理工具浏览、使用应用程序（查看器和办公程序）或运行仅在挂载目录上操作的额外btrfs分析命令。为了说明这一点，我们将通过两步过程将单个分区镜像（`pool/partimage.raw`）挂载到证据目录（`/evidence/`）：
- en: '[PRE24]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first command creates a read-only `loop0` device associated with the partition
    image file. The second command mounts the `loop0` device, read-only, on the */evidence/*
    directory. We explicitly specify the btrfs root subvolume so that no other default
    subvolumes are used. Now we are able to safely use the mounted */evidence/* directory
    for further content analysis.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令创建了一个与分区镜像文件相关联的只读`loop0`设备。第二个命令将`loop0`设备以只读模式挂载到*/evidence/*目录下。我们明确指定了btrfs根子卷，以确保不会使用其他默认子卷。现在，我们可以安全地使用挂载的*/evidence/*目录进行进一步的内容分析。
- en: 'The btrfs `subvolume` command can also list the subvolumes and snapshots found
    on a filesystem. This command uses a mounted filesystem:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: btrfs `subvolume`命令也可以列出文件系统中的子卷和快照。此命令使用的是挂载文件系统：
- en: '[PRE25]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Every subvolume is given an ID (it also appears as the inode number with `stat`
    or `ls -i`). The incrementing generation number is shown. The string `top level`
    refers to the parent subvolume’s ID, and the path here is relative to the root
    of the mounted filesystem (*/evidence/* in this case).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子卷都有一个ID（在`stat`或`ls -i`中也显示为inode号）。显示了递增的生成号。字符串`top level`指的是父子卷的ID，这里的路径是相对于挂载文件系统根目录的（在此案例中是*/evidence/*）。
- en: 'The btrfs `subvolume` command can display more information for a particular
    subvolume. This example shows metadata for the `Documents` subvolume:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: btrfs `subvolume`命令可以显示特定子卷的更多信息。此示例显示了`Documents`子卷的元数据：
- en: '[PRE26]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, the subvolume’s UUID is shown together with its creation timestamp and
    other flags. If a subvolume has any snapshots, they are also listed.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了子卷的UUID，以及其创建时间戳和其他标志。如果子卷有任何快照，它们也会被列出。
- en: 'Snapshots are one of the highlights of btrfs. They utilize CoW functionality
    to create a snapshot of a subvolume at a particular point in time. The original
    subvolume remains and continues to be available for use, and a new subvolume containing
    the snapshot is created. Snapshots can be made read-only and are typically used
    for performing backups or restoring a system to a previous point in time. They
    can also be used to freeze a filesystem for certain types of live forensic analysis
    (with btrfs this is at the file level and not the block/sector level). Snapshots
    are interesting forensically as they may contain previous versions of files. Analyzing
    files in a snapshot works the same way as in any other subvolume. For example,
    you can find the snapshot creation timestamp by using the btrfs `subvolume` command,
    as shown previously:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 快照是btrfs的一大亮点。它们利用CoW功能，在特定时间点创建子卷的快照。原始子卷保持不变，继续可用，并且创建了一个包含快照的新子卷。快照可以设置为只读，通常用于执行备份或将系统恢复到先前的时间点。它们也可以用于冻结文件系统，进行某些类型的实时取证分析（对于btrfs，这是在文件级别，而不是块/扇区级别）。快照在取证分析中很有趣，因为它们可能包含文件的历史版本。分析快照中的文件与分析任何其他子卷中的文件相同。例如，你可以使用btrfs
    `subvolume`命令找到快照创建时间戳，如前所示：
- en: '[PRE27]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Files in a snapshot that are unchanged share the same underlying blocks as the
    original subvolume from where the snapshot was taken.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 快照中未更改的文件与原始子卷共享相同的底层块，这些文件来自于快照所拍摄的原始子卷。
- en: '***List and Extract Files***'
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列出并提取文件***'
- en: A forensic tool with full btrfs support should be able to browse, examine, and
    extract files in the usual way. A major difference from other filesystems is the
    subvolumes. Each subvolume must be treated like a separate filesystem when examining
    individual files and directories (while respecting that the underlying blocks
    may be shared).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有完整btrfs支持的取证工具应该能够以常规方式浏览、检查和提取文件。与其他文件系统的主要区别是子卷。在检查单独的文件和目录时，每个子卷必须被视为一个独立的文件系统（尽管底层块可能会共享）。
- en: 'As of this writing, support for btrfs in TSK is still missing; however, the
    Fraunhofer FKIE filesystem tools have basic (experimental) support. Here are a
    few examples:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文撰写时，TSK中尚未支持btrfs；然而，Fraunhofer FKIE文件系统工具具有基本的（实验性）支持。以下是一些示例：
- en: '[PRE28]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `fls` command is used with the `-P` flag to list files from images that
    are in the btrfs *pool/* directory. The `-S` flag is used to specify the subvolume,
    including snapshots. By coincidence, the inode numbers in this example are the
    same in the different subvolumes. This is possible because each subvolume maintains
    its own inode table.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`fls`命令与`-P`标志一起使用，用于列出在btrfs *pool/*目录中的镜像文件。`-S`标志用于指定子卷，包括快照。巧合的是，在这个示例中，不同子卷中的inode号是相同的。这是因为每个子卷维护自己的inode表。'
- en: 'Files can be extracted with `icat` using the same `-P` and `-S` flags and specifying
    the inode number:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 文件可以使用`icat`提取，并使用相同的`-P`和`-S`标志，指定inode号：
- en: '[PRE29]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The extracted file from `icat` is either output to the screen or redirected
    into a file. The file contents can then be examined on the local forensic analysis
    machine.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 从`icat`提取的文件会输出到屏幕上，或重定向到文件中。然后，文件内容可以在本地取证分析机上进行检查。
- en: The `undelete-btrfs` tool (*[https://github.com/danthem/undelete-btrfs/](https://github.com/danthem/undelete-btrfs/)*)
    attempts recovery of deleted files on a btrfs filesystem. This tool is a shell
    script that uses the `btrfs restore` and `btrfs-find-root` commands to search
    for and extract deleted files. Use these at your own risk.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`undelete-btrfs` 工具 (*[https://github.com/danthem/undelete-btrfs/](https://github.com/danthem/undelete-btrfs/)*)
    尝试恢复 btrfs 文件系统上已删除的文件。这个工具是一个 shell 脚本，使用 `btrfs restore` 和 `btrfs-find-root`
    命令来搜索和提取已删除的文件。使用时请自行承担风险。'
- en: In theory, forensic analysis of btrfs filesystems could have an increased likelihood
    of recovering deleted or previously written data. The CoW philosophy avoids overwriting
    old data, preferring to create new blocks/extents and update the references to
    those disk areas, instead. Explicitly created snapshots produce a historic view
    of files and directories with previous contents and metadata. Forensic tools to
    perform such analysis will eventually arrive on the market and in the free and
    open source community. Until this time, more academic research on btrfs forensic
    analysis may be needed.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，对 btrfs 文件系统的取证分析可能会提高恢复已删除或先前写入数据的可能性。CoW（写时复制）哲学避免覆盖旧数据，倾向于创建新的块/扩展，并更新对这些磁盘区域的引用。显式创建的快照会生成包含之前内容和元数据的文件和目录的历史视图。最终，执行此类分析的取证工具将进入市场并进入自由开源社区。在此之前，可能需要更多关于
    btrfs 取证分析的学术研究。
- en: '**An Analysis of xfs**'
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**xfs 分析**'
- en: Silicon Graphics (SGI) originally developed the xfs filesystem in the early
    1990s for SGI IRIX UNIX. In 2000, SGI released xfs under the Gnu General Public
    License (GPL), and it was subsequently ported to Linux. Later, xfs was officially
    merged into the mainline kernel, and today it’s supported by every major Linux
    distribution. It is even the default filesystem on Red Hat Enterprise Linux. The
    xfs wiki is the most authoritative source of information about xfs (*[https://xfs.wiki.kernel.org/](https://xfs.wiki.kernel.org/)*).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Silicon Graphics（SGI）最初在 1990 年代初期为 SGI IRIX UNIX 开发了 xfs 文件系统。2000 年，SGI 在
    GNU 通用公共许可证（GPL）下发布了 xfs，并随后将其移植到 Linux。之后，xfs 被正式合并进主线内核，如今被每个主要的 Linux 发行版所支持。它甚至是
    Red Hat Enterprise Linux 的默认文件系统。xfs wiki 是关于 xfs 的最权威信息来源 (*[https://xfs.wiki.kernel.org/](https://xfs.wiki.kernel.org/)*)。
- en: Forensic tool support for xfs is weak compared to ext4\. AccessData Imager mentions
    support in the 4.3 release notes, and as of this writing, only X-Ways Forensics
    appears to have full support. Even TSK doesn’t support it (as of this writing),
    although several pull requests exist on GitHub for community-contributed xfs support.
    Some of the examples in this section use Andrey Labunets’s xfs TSK patches (see
    *[https://github.com/isciurus/sleuthkit.git/](https://github.com/isciurus/sleuthkit.git/)*).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ext4 相比，xfs 的取证工具支持较弱。AccessData Imager 在 4.3 版本说明中提到了对其的支持，而截至目前，只有 X-Ways
    Forensics 看起来具有完整支持。即使是 TSK（截至目前）也不支持它，尽管 GitHub 上有多个关于社区贡献的 xfs 支持的拉取请求。这个部分中的一些示例使用了
    Andrey Labunets 的 xfs TSK 补丁（见 *[https://github.com/isciurus/sleuthkit.git/](https://github.com/isciurus/sleuthkit.git/)*）。
- en: The xfs developers include tools such as `xfs_db` and `xfs_info` for debugging
    and troubleshooting an xfs filesystem, which provide much of the functionality
    needed to forensically examine an xfs filesystem. See the xfs_info(8) and xfs_db(8)
    man pages for more information.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: xfs 开发者提供了 `xfs_db` 和 `xfs_info` 等工具，用于调试和故障排除 xfs 文件系统，它们提供了进行 xfs 文件系统取证检查所需的大部分功能。有关更多信息，请参阅
    xfs_info(8) 和 xfs_db(8) 手册页。
- en: '***Filesystem Metadata: Superblock***'
  id: totrans-398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件系统元数据：超级块***'
- en: Xfs is well documented and the filesystem data structures can be analyzed for
    artifacts that could be interesting for a forensic investigation. The xfs(5) man
    page provides a good introduction to xfs mount options, layout, and various attributes.
    The data structures of xfs are defined in detail in the *XFS Algorithms & Data
    Structures* document (*[https://mirrors.edge.kernel.org/pub/linux/utils/fs/xfs/docs/xfs_filesystem_structure.pdf](https://mirrors.edge.kernel.org/pub/linux/utils/fs/xfs/docs/xfs_filesystem_structure.pdf)*).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: xfs 有着良好的文档支持，并且可以分析文件系统数据结构，寻找可能对取证调查有价值的痕迹。xfs(5) 手册页提供了 xfs 挂载选项、布局和各种属性的良好介绍。xfs
    的数据结构在 *XFS 算法与数据结构* 文档中有详细定义 (*[https://mirrors.edge.kernel.org/pub/linux/utils/fs/xfs/docs/xfs_filesystem_structure.pdf](https://mirrors.edge.kernel.org/pub/linux/utils/fs/xfs/docs/xfs_filesystem_structure.pdf)*)。
- en: 'You can identify xfs filesystems by the magic string in the superblock:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过超级块中的魔法字符串来识别 xfs 文件系统：
- en: '[PRE30]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This superblock magic string is found at the start of the first sector of the
    filesystem. There are more than 50 magic strings (or magic numbers) defined for
    different areas of the xfs filesystem (see [Chapter 7](ch07.xhtml) of *XFS Algorithms
    & Data Structures*).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这个超块魔术字符串位于文件系统第一个扇区的开始处。xfs 文件系统的不同区域定义了超过50个魔术字符串（或魔术数字）（参见 *XFS 算法与数据结构*
    第7章）。
- en: 'You can use the `xfs_db` tool to print the superblock meta information. In
    this next example, the `-r` flag ensures the operation is read-only, the two `-c`
    flags are the commands needed to print the superblock, and *partimage.raw* is
    the forensic image file:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `xfs_db` 工具来打印超块的元数据信息。在下一个示例中，`-r` 标志确保操作是只读的，两个 `-c` 标志是打印超块所需的命令，*partimage.raw*
    是取证图像文件：
- en: '[PRE31]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Most of the xfs superblock consists of flags, statistics, block counts, and
    so on; however, some artifacts are interesting from a forensics perspective. The
    block size and total blocks (`dblocks`) are interesting to compare with the size
    of the partition where the filesystem resides. `UUID` is a unique identifying
    string. The 12-character label or filesystem name (`fname`), if defined, is specified
    by the owner of the system and may be interesting in an investigation. For more
    information about various settings during the creation of xfs filesystems, see
    the mkfs.xfs(8) man page.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: xfs 超块的大部分内容由标志、统计信息、块计数等组成；然而，从取证的角度来看，某些信息是非常有趣的。块大小和总块数（`dblocks`）与文件系统所在分区的大小进行比较非常有意义。`UUID`
    是一个唯一的标识字符串。如果定义了12个字符的标签或文件系统名称（`fname`），它由系统所有者指定，并且在调查中可能具有重要意义。有关创建 xfs 文件系统时各种设置的更多信息，请参阅
    mkfs.xfs(8) 手册页。
- en: 'TSK’s `fsstat` command with xfs patches also provides a summary of the filesystem
    information in the superblock:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 xfs 补丁的 TSK 的 `fsstat` 命令还提供了超块中文件系统信息的摘要：
- en: '[PRE32]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `fsstat` output is more descriptive than the `xfs_db` output, but it provides
    the same information.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`fsstat` 输出比 `xfs_db` 输出更具描述性，但提供了相同的信息。'
- en: The xfs superblock is compact (one sector) and doesn’t have enriched information
    such as timestamps, last mount point, and so on that other filesystems may store.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: xfs 超块是紧凑的（一个扇区），不像其他文件系统那样存储时间戳、最后挂载点等详细信息。
- en: '***File Metadata: Inodes***'
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件元数据：Inodes***'
- en: The xfs filesystem has the same concept of inodes as other Unix-styled filesystems.
    The inode contains the metadata and knows the blocks (or extents) associated with
    a file on the drive. (The inode structure is defined in [Chapter 7](ch07.xhtml)
    of *XFS Algorithms & Data Structures.*)
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: xfs 文件系统与其他类 Unix 文件系统有相同的 inode 概念。inode 包含元数据，并知道与磁盘上的文件相关联的块（或范围）。(inode
    结构在 *XFS 算法与数据结构* 第7章中定义。)
- en: 'The `xfs_db` command can list the metadata given the file’s inode number. The
    parameter `"inode 133"` is in quotes in this next example because of the space
    separating the command and the inode number. The print parameter and partition
    image file is the same as the previous example:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`xfs_db` 命令可以列出给定文件 inode 编号的元数据。在下一个示例中，参数 `"inode 133"` 用引号括起来，因为命令与 inode
    编号之间有空格。打印参数和分区镜像文件与之前的示例相同：'
- en: '[PRE33]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This example output lists the metadata of a file with inode 133\. Four timestamps
    are found: last accessed ➌ (`atime`), last content modified ➍ (`mtime`), last
    metadata change ➎ (`ctime`), and the birth/creation timestamp ➏ (`crtime`, which
    was added in version 3 of xfs). File ownership ➋ (`uid`/`gid`), permissions ➊
    (`mode`), and other attributes are also shown. The UUID ➐ is a reference to the
    superblock and is not unique to the file or inode.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例输出列出了 inode 133 的文件元数据。可以找到四个时间戳：最后访问时间 ➌（`atime`），最后内容修改时间 ➍（`mtime`），最后元数据更改时间
    ➎（`ctime`），以及创建时间戳 ➏（`crtime`，在 xfs 版本 3 中新增）。文件所有权 ➋（`uid`/`gid`），权限 ➊（`mode`），以及其他属性也会显示。UUID
    ➐ 是指向超块的引用，并不是文件或 inode 的唯一标识。
- en: 'The xfs-patched TSK’s `istat` command shows similar information in a different
    format:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 xfs 补丁的 TSK 的 `istat` 命令以不同的格式显示类似的信息：
- en: '[PRE34]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Included in this formatted output is a list of allocated blocks used by the
    file.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化输出中包含了文件所使用的已分配块的列表。
- en: '***List and Extract Files***'
  id: totrans-418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列出并提取文件***'
- en: 'The examples here are identical to previous TSK examples and are included for
    completeness. The xfs-patched TSK’s `fls` command provides file listings of an
    xfs filesystem in the usual `fls` way:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的示例与之前的 TSK 示例相同，已包括在内以供参考。带有 xfs 补丁的 TSK 的 `fls` 命令以通常的 `fls` 方式提供 xfs 文件系统的文件列表：
- en: '[PRE35]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `-l` flag can also be used to list file size, ownership, and timestamps.
    The inode numbers for each file and directory are also listed.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`-l` 标志也可以用来列出文件大小、所有权和时间戳。每个文件和目录的 inode 号也会列出。'
- en: 'The inode numbers can be used to extract files from a forensic image as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 inode 号从取证镜像中提取文件，方法如下：
- en: '[PRE36]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the first example, the output is displayed in the terminal. The second example
    shows extract data being redirected to a file on the forensic analysis machine.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，输出显示在终端中。第二个示例显示提取的数据被重定向到取证分析机上的文件。
- en: 'Xfs also has a logging (journal) system. Analysis of the journal and other
    low-level analysis are beyond the scope of this book. For an additional overview
    on performing xfs forensics, see this five-part series of blog posts by Hal Pomeranz:
    *[https://righteousit.wordpress.com/2018/05/21/xfs-part-1-superblock/](https://righteousit.wordpress.com/2018/05/21/xfs-part-1-superblock/)*.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Xfs 还具有日志（journal）系统。对日志及其他低级分析的研究超出了本书的范围。如需进一步了解如何进行 xfs 取证，请参阅 Hal Pomeranz
    撰写的五部分博客文章系列： *[https://righteousit.wordpress.com/2018/05/21/xfs-part-1-superblock/](https://righteousit.wordpress.com/2018/05/21/xfs-part-1-superblock/)*。
- en: Other projects related to xfs forensics are available on GitHub such as *[https://github.com/ianka/xfs_undelete/](https://github.com/ianka/xfs_undelete/)*
    and *[https://github.com/aivanoffff/xfs_untruncate/](https://github.com/aivanoffff/xfs_untruncate/)*.
    These may or may not work with your forensic image; use at your own risk.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 其他与 xfs 取证相关的项目可在 GitHub 上找到，如 *[https://github.com/ianka/xfs_undelete/](https://github.com/ianka/xfs_undelete/)*
    和 *[https://github.com/aivanoffff/xfs_untruncate/](https://github.com/aivanoffff/xfs_untruncate/)*。这些可能与您的取证镜像兼容，也可能不兼容；使用时请自行承担风险。
- en: '**Linux Swap Analysis**'
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Linux 交换分析**'
- en: The forensic analysis of swap and hibernation falls under the domain of memory
    forensics. These topics are included here because they involve memory data that
    have been written to persistent storage and are accessible for a postmortem forensic
    examination. In this section, you’ll learn how swap areas are used, identify their
    location on the hard drive, and understand the potential forensic artifacts they
    contain.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 对交换区和休眠状态的取证分析属于内存取证的范畴。这些话题之所以出现在此，是因为它们涉及已写入持久存储并可以进行事后取证分析的内存数据。在本节中，您将了解交换区域的使用方式，识别它们在硬盘上的位置，并理解它们可能包含的取证痕迹。
- en: '***Identifying and Analyzing Swap***'
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***识别和分析交换区域***'
- en: Since the early days of computing, memory management has always been a challenge.
    Computers have a limited amount of high-speed volatile storage (RAM), and when
    that is full, the system either crashes or employs techniques to clear memory.
    One of those techniques is to save sections of memory to disk (which is much larger)
    temporarily and read it back from disk when needed. This action is managed by
    the kernel and is known as *swapping*. When memory is full, individual memory
    pages of a running system are written to special areas of disk and can be retrieved
    later. If both memory and swap are full, an out-of-memory (OOM) killer is employed
    to clear memory by selecting processes to kill based on a scoring heuristic. Unless
    the kernel is configured to dump core for each killed process (`sysctl vm.oom`
    `_dump_tasks`), nothing is saved to disk that can be forensically analyzed.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 自计算机诞生以来，内存管理一直是一个挑战。计算机具有有限的高速易失性存储（RAM），当内存满时，系统要么崩溃，要么采用一些技术来清理内存。其中一种技术是将部分内存暂时保存到磁盘（磁盘容量远大于内存）中，在需要时从磁盘中读取。这一过程由内核管理，称为
    *交换*。当内存满时，系统会将运行时的内存页面写入磁盘上的特殊区域，并在稍后重新读取。如果内存和交换空间都满了，系统会使用内存不足（OOM）杀手，根据评分启发式选择进程进行终止以释放内存。除非内核配置为对每个被终止的进程进行核心转储（`sysctl
    vm.oom_dump_tasks`），否则没有任何数据会保存到磁盘上进行取证分析。
- en: Swap area under Linux can be in the form of a dedicated partition on a disk,
    or a file on a filesystem. Most Linux distros use a separate dedicated swap partition.
    The DOS/MBR partition type for Linux swap is 0x82\. On GPT systems, the GUID for
    a Linux swap partition is 0657FD6D-A4AB-43C4-84E5-0933C84B4F4F. These partitions
    are typically greater than or equal to the amount of memory on a system.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 下，交换区域可以是磁盘上的一个专用分区，也可以是文件系统上的一个文件。大多数 Linux 发行版使用单独的专用交换分区。Linux 交换分区的
    DOS/MBR 分区类型是 0x82\。在 GPT 系统上，Linux 交换分区的 GUID 是 0657FD6D-A4AB-43C4-84E5-0933C84B4F4F。这些分区的大小通常大于或等于系统内存的大小。
- en: The kernel must be told what swap areas to use, which is typically done at boot
    time either by reading */etc/fstab* or through a systemd swap unit file. The *fstab*
    file will contain a single line for each swap partition used (normally there’s
    only one, but there can be more). The next three examples from *fstab* are used
    to configure swap.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 必须告知内核使用哪些交换区域，通常在启动时通过读取*/etc/fstab*文件或通过systemd交换单元文件来完成。*fstab*文件将包含每个使用的交换分区的单独一行（通常只有一个，但也可以有多个）。接下来的三个示例来自*fstab*，用于配置交换。
- en: '[PRE37]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first two lines show swap partitions identified by UUID and device file.
    The third example shows the use of a regular file for swap. The partitions can
    be extracted for examination or analyzed in place using a sector offset determined
    from the partition table. When a file is used for swap, that file can be copied
    or extracted from the image and analyzed.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行显示通过UUID和设备文件标识的交换分区。第三个示例显示了使用常规文件作为交换的方式。可以提取这些分区进行检查，或者使用从分区表中确定的扇区偏移量进行原地分析。当使用文件作为交换时，可以从镜像中复制或提取该文件进行分析。
- en: 'Swap partitions can also be configured using systemd. A systemd unit file ending
    in **.swap* contains information needed to set up a swap device or file, for example:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 交换分区也可以通过systemd进行配置。以**.swap**结尾的systemd单元文件包含设置交换设备或文件所需的信息，例如：
- en: '[PRE38]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This simple two-line swap unit file points to a 1GB swap file in the root directory
    called *swapfile*. This will add the file as swap when the system starts. See
    the systemd.swap(5) man page for more details.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的两行交换单元文件指向根目录中的一个1GB交换文件，名为*swapfile*。系统启动时将把该文件添加为交换文件。有关更多细节，请参见systemd.swap(5)手册页。
- en: If additional swap space is needed or if a file is preferred over a partition,
    a system administrator can create a file with the desired size and designate it
    as swap. There’s no standard naming conventions for swap files, although some
    distros and many tutorials use *swapfile* as the name. There is also no standard
    location for swap files, but the root (/) directory is typical.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要额外的交换空间，或者如果文件优先于分区，系统管理员可以创建一个具有所需大小的文件并将其指定为交换文件。交换文件没有标准的命名规范，尽管一些发行版和许多教程使用*swapfile*作为文件名。交换文件也没有标准的位置，但通常在根目录（/）下。
- en: 'You can identify a swap partition (or file) by a 10-character signature string
    located at byte offset 4086 (0xFF6):'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过位于字节偏移量4086（0xFF6）处的10个字符的签名字符串来识别交换分区（或文件）：
- en: '[PRE39]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This signature string is either `SWAPSPACE2` or `SWAP-SPACE`. It indicates that
    the partition or file has been set up for use as swap (using the `mkswap` command).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 该签名字符串为`SWAPSPACE2`或`SWAP-SPACE`，表示该分区或文件已被设置为交换使用（通过`mkswap`命令）。
- en: The Linux `file` command can also be used to identify swap files and provide
    basic information:^([12](footnotes.xhtml#ch03foot_012))
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的`file`命令也可以用来识别交换文件并提供基本信息：^([12](footnotes.xhtml#ch03foot_012))
- en: '[PRE40]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The system administrator can generate a 16-character label. The UUID is randomly
    generated and should be unique.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员可以生成一个16个字符的标签。UUID是随机生成的，应该是唯一的。
- en: To analyze the swap on a separate analysis machine, a swap partition can be
    acquired from the drive (with `dd` or an equivalent command) into a forensic image
    file and a swap file can be simply copied. The swap partition or file may contain
    fragments of memory from processes that were temporarily swapped to disk.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在单独的分析机器上分析交换，交换分区可以通过`dd`或等效命令从驱动器获取到取证镜像文件中，交换文件可以直接复制。交换分区或文件可能包含来自进程的内存碎片，这些进程曾临时被交换到磁盘。
- en: 'The scope of memory analysis in this book is limited to identification, searching,
    and carving, which can reveal many interesting artifacts. For example, carving
    for strings using `bulk_extractor` (*[https://forensicswiki.xyz/wiki/index.php?title=Bulk_extractor](https://forensicswiki.xyz/wiki/index.php?title=Bulk_extractor)*)
    will extract the following:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的内存分析范围仅限于识别、搜索和雕刻，这些操作可以揭示许多有趣的伪影。例如，使用`bulk_extractor`（*[https://forensicswiki.xyz/wiki/index.php?title=Bulk_extractor](https://forensicswiki.xyz/wiki/index.php?title=Bulk_extractor)*)进行字符串雕刻将提取以下内容：
- en: Credit card numbers and track 2 information
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信用卡号码和轨道2信息
- en: Domain names
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域名
- en: Email addresses
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件地址
- en: IP addresses
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP地址
- en: Ethernet MAC addresses
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太网MAC地址
- en: URLs
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URLs
- en: Telephone numbers
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话号码
- en: EXIF data from media files (photos and videos)
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体文件（照片和视频）的EXIF数据
- en: Custom-specified regex strings
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义指定的正则表达式字符串
- en: In addition to carving for strings, we can also carve for files. Standard carving
    tools (like `foremost`, for example) can be used to attempt extraction of files
    or file fragments from swap.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为字符串进行雕刻，我们还可以为文件进行雕刻。标准雕刻工具（例如`foremost`）可用于尝试从交换分区中提取文件或文件碎片。
- en: '***Hibernation***'
  id: totrans-457
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***休眠***'
- en: Most PCs today have the ability to suspend various hardware components or the
    entire system into power-saving modes. This is typically done using the ACPI interface
    and is controlled by various userspace tools.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数个人计算机都有能力将各种硬件组件或整个系统挂起到省电模式中。这通常通过ACPI接口完成，并由各种用户空间工具进行控制。
- en: If a swap partition or file is greater than or equal to the size of the system’s
    physical memory, the physical memory can be suspended to disk for hibernation.
    With the entire contents of memory saved to disk (in the swap partition), the
    OS can be halted and the machine powered off. When the machine powers back on,
    the bootloader is run and the kernel is started. If the kernel finds a suspended
    (hibernated) state, it will start the resume process to bring back the system’s
    last running state. There are other power-saving modes, but this one is particularly
    interesting from a forensics perspective because the entire contents of memory
    are saved to disk and can be analyzed.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果交换分区或文件的大小大于或等于系统物理内存的大小，物理内存可以被挂起到磁盘进行休眠。通过将内存的全部内容保存到磁盘（在交换分区中），操作系统可以被停止并关闭计算机电源。当计算机重新启动时，启动加载程序会运行并启动内核。如果内核发现系统处于挂起（休眠）状态，它将启动恢复过程以恢复系统的上次运行状态。还有其他省电模式，但从取证角度来看，这种模式特别有趣，因为内存的全部内容都被保存到磁盘上，并且可以进行分析。
- en: 'The bootloader can pass the `resume=` parameter to the kernel with a partition
    device like */dev/sdaX* or a UUID. The parameter tells the kernel where to look
    for a possible hibernated image. For example:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 启动加载程序可以将`resume=`参数传递给内核，并指定分区设备，如*/dev/sdaX*或UUID。该参数告诉内核去哪里查找可能的休眠映像。例如：
- en: '[PRE41]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `resume=` parameter instructs the kernel to search for a block device with
    the UUID of `327edf54-00e6-46fb-b08d-00250972d02a` and checks whether it should
    resume from hibernation.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`resume=`参数指示内核搜索UUID为`327edf54-00e6-46fb-b08d-00250972d02a`的块设备，并检查是否应从休眠状态恢复。'
- en: 'A swap partition (or file) contains a hibernation memory image if the string
    `S1SUSPEND` is found at byte offset 4086 (0xFF6):'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在字节偏移量 4086（0xFF6）处发现字符串`S1SUSPEND`，则交换分区（或文件）包含休眠内存映像：
- en: '[PRE42]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This offset is the same as the one mentioned in the previous section about regular
    swap partitions. When the system goes into hibernation, the string `SWAPSPACE2`
    (or `SWAP-SPACE`) is overwritten with `S1SUSPEND` and changed back when the system
    boots and resumes from hibernation. Basic forensic tools or a hex editor can be
    used to check for the existence of this string on an acquired image.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 该偏移量与前一节中关于常规交换分区提到的偏移量相同。当系统进入休眠状态时，字符串`SWAPSPACE2`（或`SWAP-SPACE`）将被`S1SUSPEND`覆盖，并在系统启动并从休眠状态恢复时恢复。可以使用基本的取证工具或十六进制编辑器检查获取的映像中是否存在此字符串。
- en: 'The `file` command can also be used to check the swap file or forensic image
    of the swap partition to see whether the system is in a hibernated state:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`命令也可用于检查交换文件或交换分区的取证映像，以查看系统是否处于休眠状态：'
- en: '[PRE43]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `with SWSUSP1 image` string at the end of the file output indicates that
    the file contains a hibernation image.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 文件输出末尾的`with SWSUSP1 image`字符串表示该文件包含一个休眠映像。
- en: A hibernation swap partition with a full memory dump contains a wealth of information,
    some of it sensitive (passwords, keys, and so on). In 2005, a kernel patch was
    proposed to implement encrypted hibernation (it included the compilation flag
    `SWSUSP_ENCRYPT`). The patch was removed a short time later because the decryption
    key was stored unencrypted on the disk and several kernel developers were against
    it.^([13](footnotes.xhtml#ch03foot_013)) The community recommended that `dm-crypt`-based
    encryption like the Linux Unified Key Setup (LUKS) be used, instead. Some installations
    may use LUKS to encrypt swap, and those must be decrypted before analyzing. In
    the case of LUKS, the partition is encrypted at the block layer, and decrypting
    (assuming the key is available) with `cryptsetup` on an analysis machine will
    reveal the hibernation contents. (Decrypting LUKS is described in the next section.)
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 带有完整内存转储的休眠交换分区包含大量信息，其中一些信息是敏感的（例如密码、密钥等）。2005年，提出了一个内核补丁，用于实现加密休眠（它包含了编译标志`SWSUSP_ENCRYPT`）。该补丁在不久后被删除，因为解密密钥以未加密形式存储在磁盘上，而且一些内核开发者对此表示反对。^([13](footnotes.xhtml#ch03foot_013))
    社区建议改用基于`dm-crypt`的加密方法，如Linux统一密钥设置（LUKS）。某些安装可能会使用LUKS加密交换分区，这些分区必须在分析之前先进行解密。在LUKS的情况下，分区是在块层加密的，使用`cryptsetup`在分析机器上进行解密（假设密钥可用）将揭示休眠内容。（LUKS的解密将在下一节描述）
- en: The same carving techniques described in the previous section can be used on
    the hibernation image, as well. A search for cryptographic keys may also yield
    interesting results.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中描述的相同的刻录技术也可以用于休眠镜像。搜索加密密钥也可能会产生有趣的结果。
- en: Research has been done on the use of compression in swap and hibernation images,
    which may limit what can be easily carved from the file or partition. See *[https://www.cs.uno.edu/~golden/Papers/DFRWS2014-1.pdf](https://www.cs.uno.edu/~golden/Papers/DFRWS2014-1.pdf)*
    for more information.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 研究已经针对交换和休眠镜像中压缩的使用进行了探索，这可能限制了从文件或分区中轻松提取的内容。更多信息请参见 *[https://www.cs.uno.edu/~golden/Papers/DFRWS2014-1.pdf](https://www.cs.uno.edu/~golden/Papers/DFRWS2014-1.pdf)*。
- en: '**Analyzing Filesystem Encryption**'
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分析文件系统加密**'
- en: Encryption has traditionally been the greatest challenge for the digital forensics
    community. The focus of encryption is restricting access to data, whereas the
    focus of forensics is gaining access to data. This fundamental conflict remains
    unresolved and continues to be discussed.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 加密传统上是数字取证社区面临的最大挑战。加密的重点是限制对数据的访问，而取证的重点是获取数据的访问权限。这一根本冲突仍未解决，并持续受到讨论。
- en: 'It has become common practice to encrypt stored information. This encryption
    can take place at multiple layers:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 加密存储信息已成为一种常见做法。加密可以在多个层次上进行：
- en: 'Application file encryption: protected PDF, office documents, and so on'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序文件加密：受保护的PDF、办公文档等
- en: 'Individual file containers: GPG, encrypted zip'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个文件容器：GPG，加密zip
- en: 'Directories: eCryptfs, fscrypt'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录：eCryptfs, fscrypt
- en: 'Volumes: TrueCrypt/Veracrypt'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷：TrueCrypt/Veracrypt
- en: 'Block devices: Linux LUKS, Microsoft Bitlocker, Apple FileVault'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块设备：Linux LUKS，Microsoft Bitlocker，Apple FileVault
- en: 'Drive hardware: OPAL/SED (self-encrypting drive)'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动硬件：OPAL/SED（自加密驱动）
- en: 'This section focuses on three Linux encryption technologies: LUKS, eCryptfs,
    and fscrypt (formerly ext4 directory encryption). Other file and filesystem encryption
    systems for Linux are available but aren’t covered here because they either aren’t
    specific to Linux or are too obscure and rarely used.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍三种Linux加密技术：LUKS、eCryptfs和fscrypt（前身为ext4目录加密）。Linux还有其他文件和文件系统加密系统，但由于它们要么不特定于Linux，要么过于冷门且很少使用，因此不在此讨论。
- en: 'Decrypting protected data requires a password/passphrase or a copy of the cryptographic
    key (a string or key file). The forensic challenge is to find the decryption key.
    Some methods known to be used (some are obviously not used by the forensics community)
    for password/key recovery include:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 解密受保护的数据需要密码/短语或加密密钥的副本（字符串或密钥文件）。取证挑战在于找到解密密钥。已知一些密码/密钥恢复的方法（其中一些显然不是取证社区使用的方法），包括：
- en: Brute-force with dictionary-based attacks to find simple passwords
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字典攻击进行暴力破解，寻找简单的密码
- en: Brute-force with GPU clusters for fast exhaustive password search
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GPU集群进行暴力破解，快速进行全面的密码搜索
- en: Cryptanalysis (mathematical weakness, reduce keyspace)
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码分析（数学弱点，减少密钥空间）
- en: Finding passwords saved, written, or transferred previously
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找先前保存、书写或传输的密码
- en: Password reuse across multiple accounts or devices
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个账户或设备之间重用密码
- en: Legal requirement to produce passwords in court
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 法律要求在法庭上提供密码
- en: Cooperative system owner or accomplice with the password
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合作系统所有者或密码的同伙
- en: Key backup/escrow in enterprise environments
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业环境中的密钥备份/托管
- en: Device exploit, vulnerability, or backdoor
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备漏洞、漏洞或后门
- en: Keyloggers or keyboard visibility (HD video cameras or telescope)
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘记录器或键盘可视性（高清摄像机或望远镜）
- en: 'Rainbow tables: Precomputed table of cryptographic hashes'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 彩虹表：预计算的加密哈希表
- en: 'Extract keys from memory: PCI-bus DMA attacks, hibernation'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从内存中提取密钥：PCI总线DMA攻击、休眠
- en: Man-in-the-middle attacks on network traffic
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络流量中的中间人攻击
- en: Social engineering
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社会工程学
- en: Forced or unwitting biometric identity theft
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制或无意的生物识别身份盗窃
- en: Torture, blackmail, coercion, or other malicious means (see [Figure 3-3](ch03.xhtml#ch03fig03))
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 折磨、勒索、胁迫或其他恶意手段（见[图3-3](ch03.xhtml#ch03fig03)）
- en: Linux tools that attempt technical password/key recovery include John the Ripper,
    Hashcat, and Bulk_Extractor.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试技术性密码/密钥恢复的Linux工具包括John the Ripper、Hashcat和Bulk_Extractor。
- en: '![Image](Images/ch03fig03.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch03fig03.jpg)'
- en: '*Figure 3-3: XKCD on ISO 8601 (* [https://xkcd.com/538/](https://xkcd.com/538/)*)*'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-3：XKCD关于ISO 8601（* [https://xkcd.com/538/](https://xkcd.com/538/)）*'
- en: This section explains how the encryption works, how to identify the use of encryption,
    and how to extract metadata of the encrypted volume or directory. Decryption is
    also explained, with the assumption that the key is already known.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了加密是如何工作的，如何识别加密的使用以及如何提取加密卷或目录的元数据。也解释了解密，假设密钥已知。
- en: '***LUKS Full-Disk Encryption***'
  id: totrans-503
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***LUKS全盘加密***'
- en: LUKS^([14](footnotes.xhtml#ch03foot_014)) is a standard format for encrypted
    storage. The specification is at *[https://gitlab.com/cryptsetup/cryptsetup/](https://gitlab.com/cryptsetup/cryptsetup/)*
    and the reference implementation is the `cryptsetup` software package. See the
    cryptsetup(8) man page for more information. If your commercial forensic software
    doesn’t support the analysis and decryption of LUKS volumes, you can examine a
    forensic image on a Linux analysis machine.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: LUKS^([14](footnotes.xhtml#ch03foot_014))是一种加密存储的标准格式。规范见* [https://gitlab.com/cryptsetup/cryptsetup/](https://gitlab.com/cryptsetup/cryptsetup/)*，参考实现是`cryptsetup`软件包。有关更多信息，请参见cryptsetup(8)手册。如果你的商业取证软件不支持LUKS卷的分析和解密，你可以在Linux分析机器上检查取证镜像。
- en: LUKS volumes may be created with or without a partition table on a drive. The
    DOS partition type^([15](footnotes.xhtml#ch03foot_015)) of 0xE8 and the GPT GUID
    partition type^([16](footnotes.xhtml#ch03foot_016)) of CA7D7CCB-63ED-4C53-861C-1742536059CC
    are designated for LUKS volumes. If used, these partition types may indicate the
    existence of a LUKS volume. However, be aware that not all tools recognize those
    partition types (`unknown` in `fdisk`, for example), and LUKS partitions are sometimes
    created using the standard (generic) Linux partition types.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: LUKS卷可以在有或没有分区表的驱动器上创建。DOS分区类型^([15](footnotes.xhtml#ch03foot_015))为0xE8，GPT
    GUID分区类型^([16](footnotes.xhtml#ch03foot_016))为CA7D7CCB-63ED-4C53-861C-1742536059CC，专门用于LUKS卷。如果使用这些分区类型，可能表示存在LUKS卷。但是，要注意并非所有工具都能识别这些分区类型（例如`fdisk`中显示为`unknown`），而且LUKS分区有时会使用标准（通用）Linux分区类型创建。
- en: 'On boot, Linux systems will read the */etc/crypttab* file to set up encrypted
    filesystems. This file is useful to analyze because it shows what is encrypted,
    where the password comes from, and other options. The *crypttab* file has four
    fields:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 启动时，Linux系统将读取*/etc/crypttab*文件来设置加密文件系统。分析此文件非常有用，因为它显示了加密内容、密码来源及其他选项。*crypttab*文件包含四个字段：
- en: name    The name of the block device to appear in */dev/mapper/*
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 名称    将在*/dev/mapper/*中出现的块设备名称
- en: device    A UUID or device of an encrypted volume
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 设备    加密卷的UUID或设备
- en: password    The password source, either a key file or manual entry (“`none`”
    or “`-`” indicate manual entry)
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 密码    密码源，可以是密钥文件或手动输入（“`none`”或“`-`”表示手动输入）
- en: options    Information about the crypto algorithms, configuration, and other
    behavior
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 选项    有关加密算法、配置和其他行为的信息
- en: 'The following are some example lines from */etc/crypttab* that encrypt the
    root directory and swap partition:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自*/etc/crypttab*的示例行，这些行加密了根目录和交换分区：
- en: '[PRE44]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, `swap-crypt` and `root-crypt` will be the decrypted devices in */dev/mapper/*.
    A password is requested for root (`none`) and swap is randomly generated. The
    *crypttab* file may also exist in the initramfs. Some administrators want to reboot
    servers without entering a password, so they may hide the key file somewhere.
    This file may also exist in a backup.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`swap-crypt` 和 `root-crypt` 将是 */dev/mapper/* 中的解密设备。系统会要求输入 root（`none`）的密码，交换分区密码会随机生成。*crypttab*
    文件也可能存在于 initramfs 中。一些管理员希望在不输入密码的情况下重启服务器，因此他们可能会把密钥文件隐藏在某个地方。这个文件也可能存在于备份中。
- en: 'A LUKS volume can be identified by an initial six-byte magic string and a two-byte
    version string (version 1 or 2), as follows:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 LUKS 卷可以通过一个初始的六字节魔法字符串和一个两字节的版本字符串（版本 1 或 2）来识别，如下所示：
- en: '[PRE45]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If a LUKS partition is suspected but not found in the normal partition table,
    this (magic) hex string can be used as a search pattern. A valid search hit should
    also start at the beginning of a drive sector.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 如果怀疑是 LUKS 分区，但在正常的分区表中找不到，可以使用这个（魔法）十六进制字符串作为搜索模式。有效的搜索结果应当从驱动器扇区的开头开始。
- en: 'The LUKS kernel module encrypts data at the block layer, below the filesystem.
    An encrypted LUKS partition has a header describing the algorithms used, keyslots,
    a unique identifier (UUID), a user-specified label, and other information. You
    can extract the header of a LUKS volume by using the `cryptsetup luksDump` command,
    either with an attached device (using a write blocker) or a raw forensic image
    file; for example:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: LUKS 内核模块在块层对数据进行加密，低于文件系统层。加密的 LUKS 分区有一个头部，描述了所使用的算法、密钥插槽、唯一标识符（UUID）、用户指定的标签以及其他信息。你可以通过使用
    `cryptsetup luksDump` 命令提取 LUKS 卷的头部，方法是使用附加的设备（使用写保护器）或原始取证镜像文件；例如：
- en: '[PRE46]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The LUKS header doesn’t contain any timestamps indicating creation or last used
    dates. If the label is specified, it can be interesting in an investigation. The
    label is a text field defined by the user and may contain a description of the
    encrypted contents. The key slots can also be of interest from a forensics perspective.
    A LUKS volume can have up to eight keys, which is potentially eight different
    passwords where recovery can be attempted.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: LUKS 头部不包含任何指示创建时间或最后使用时间的时间戳。如果指定了标签，在调查中可能会有用。标签是由用户定义的文本字段，可能包含加密内容的描述。密钥插槽从取证角度来看也可能很重要。一个
    LUKS 卷最多可以有八个密钥，即最多八个不同的密码，可以尝试进行恢复。
- en: Creating backup copies of the LUKS header is a recommended practice, and copies
    may exist. If different (possibly known) passwords were used at the time of the
    backup, they could provide access to encrypted LUKS data. The `cryptsetup` tool
    provides `luksHeaderBackup` and `luksHeaderRestore` subcommands that create and
    restore LUKS header backups. This backup could also be made by using `dd` because
    it simply contains a copy of the raw bytes up to the data segment offset (16,777,216
    bytes, or 32,768 sectors in this example).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 LUKS 头部的备份副本是一种推荐的做法，副本可能已经存在。如果在备份时使用了不同的（可能已知的）密码，它们可能提供访问加密 LUKS 数据的权限。`cryptsetup`
    工具提供了 `luksHeaderBackup` 和 `luksHeaderRestore` 子命令，用于创建和恢复 LUKS 头部备份。也可以使用 `dd`
    来创建此备份，因为它仅包含直到数据段偏移（在本例中为 16,777,216 字节或 32,768 个扇区）的原始字节副本。
- en: 'To decrypt a LUKS volume on a Linux analysis machine, the forensic image must
    be accessible as a block device (`cryptsetup` can’t unlock regular files). The
    `luksOpen` subcommand creates a new device with access to the decrypted volume:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Linux 分析机器上解密 LUKS 卷，取证镜像必须作为块设备访问（`cryptsetup` 不能解锁常规文件）。`luksOpen` 子命令创建一个新设备，并提供访问解密卷的权限：
- en: '[PRE47]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: A new block device */dev/mapper/evidence* is created with the decrypted LUKS
    volume contents. In this example, an ext4 filesystem is revealed. Even though
    the device should be protected with a write blocker, the `--readonly` can be included
    as a matter of diligence. The device can be removed with the `luksClose` subcommand
    (`cryptsetup luksClose evidence`).
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的块设备 */dev/mapper/evidence*，其中包含解密后的 LUKS 卷内容。在这个示例中，揭示了一个 ext4 文件系统。即使设备应该使用写保护器保护，出于谨慎考虑，也可以添加
    `--readonly`。可以使用 `luksClose` 子命令删除设备（`cryptsetup luksClose evidence`）。
- en: The password cracker John the Ripper currently supports attempting to recover
    LUKS version 1 passwords (check the latest source code at *[https://github.com/openwall/john/](https://github.com/openwall/john/)*
    to see if version 2 support has been added). Some installations may still use
    LUKS version 1.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 密码破解工具 John the Ripper 当前支持尝试恢复 LUKS 版本 1 的密码（请查看 *[https://github.com/openwall/john/](https://github.com/openwall/john/)*
    中的最新源代码，查看是否已添加对版本 2 的支持）。一些安装可能仍在使用 LUKS 版本 1。
- en: The new `systemd-homed` uses LUKS by default to encrypt home directories. As
    of this writing, `systemd-homed` is newly proposed and not widely used. The analysis
    techniques shown in this section should work on any LUKS-encrypted volume.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `systemd-homed` 默认使用 LUKS 来加密主目录。截至本文撰写时，`systemd-homed` 是新提出的并且尚未广泛使用。本节展示的分析技术应适用于任何
    LUKS 加密的卷。
- en: '***eCryptfs Encrypted Directories***'
  id: totrans-526
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***eCryptfs 加密目录***'
- en: During installation, some Linux distros offer the possibility to encrypt the
    user’s home directory or a subdirectory (instead of full-disk encryption like
    LUKS).
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，一些 Linux 发行版提供加密用户主目录或子目录的选项（而不是像 LUKS 那样进行全盘加密）。
- en: Until recently, eCryptfs was the most common directory-based encryption system,
    using a stacked filesystem implementation. Other directory-based systems include
    EncFS and cryptfs (which is based on ext4’s built-in directory encryption). This
    section covers eCryptfs. The future of eCryptfs is not clear. Some distros have
    deprecated eCryptfs, and Debian has removed it due to incompatibilities with systemd.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，eCryptfs 是最常见的基于目录的加密系统，使用堆叠文件系统实现。其他基于目录的系统包括 EncFS 和 cryptfs（基于 ext4
    的内建目录加密）。本节讨论的是 eCryptfs。eCryptfs 的未来尚不明确。一些发行版已弃用 eCryptfs，Debian 已因与 systemd
    不兼容而将其移除。
- en: 'An eCryptfs system has three main directory components: the encrypted directory
    tree (often a hidden directory named *.Private/*), the mount point for the decrypted
    directory tree, and a hidden directory for the passphrase and various state files
    (often named *.ecryptfs/* and in the same directory as *.Private/*).'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 eCryptfs 系统有三个主要的目录组件：加密目录树（通常是一个名为 *.Private/* 的隐藏目录），解密目录树的挂载点，以及一个隐藏目录用于存放密码短语和各种状态文件（通常名为
    *.ecryptfs/*，并与 *.Private/* 在同一目录下）。
- en: 'When used to encrypt entire home directories, some distros place each user’s
    *.Private/* and *.ecryptfs/* in a separate */home/.ecryptfs/* directory. The normal
    user home locations are then used as mount points for the decrypted directories.
    In this example from Linux Mint, these three directories belong to the user Sam:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于加密整个主目录时，一些发行版将每个用户的 *.Private/* 和 *.ecryptfs/* 放在单独的 */home/.ecryptfs/*
    目录中。正常的用户主目录位置随后被用作解密目录的挂载点。在这个来自 Linux Mint 的示例中，这三个目录属于用户 Sam：
- en: '[PRE48]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first directory contains user Sam’s passphrase file and other information.
    The second directory contains the encrypted files and directories of the user
    Sam. The last directory is the mount point used by the eCryptfs system, providing
    decrypted access to the user’s home directory.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个目录包含用户 Sam 的密码短语文件和其他信息。第二个目录包含用户 Sam 的加密文件和目录。最后一个目录是 eCryptfs 系统使用的挂载点，提供对用户主目录的解密访问。
- en: 'In some cases, a user may wish to encrypt only a subdirectory of their home
    directory instead of encrypting everything. The following eCryptfs directory structure
    is a typical configuration:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，用户可能希望仅加密其主目录的子目录，而不是加密整个目录。以下 eCryptfs 目录结构是一个典型配置：
- en: '[PRE49]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here again, the *.ecryptfs/* hidden directory contains the passphrase and supporting
    files, *.Private/* is a hidden directory containing the encrypted files, and *Private/*
    is the mount point where the decrypted files are found. When performing a forensic
    examination, a search for any directory called *.ecryptfs* is an indicator that
    eCryptfs was used. The *Private.mnt* file indicates the location of the decrypted
    mount point.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*.ecryptfs/* 隐藏目录包含密码短语和支持文件，*.Private/* 是一个包含加密文件的隐藏目录，而 *Private/* 是解密文件所在的挂载点。在进行取证检查时，搜索任何名为
    *.ecryptfs* 的目录可以指示 eCryptfs 已被使用。*Private.mnt* 文件指示解密挂载点的位置。
- en: 'File and directory names are also encrypted to hide information about the file
    type or contents. The following is an example of an encrypted filename (*secrets.txt*):'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和目录名也被加密，以隐藏文件类型或内容的信息。以下是一个加密文件名的示例 (*secrets.txt*)：
- en: '[PRE50]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When performing a forensic examination, a search for files prefixed with `ECRYPTFS_FNEK_ENCRYPTED.*`
    reveals that eCryptfs was used.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行取证检查时，搜索以 `ECRYPTFS_FNEK_ENCRYPTED.*` 为前缀的文件可以揭示 eCryptfs 已被使用。
- en: 'The contents and filenames are encrypted, but there is some metadata that could
    be useful for an investigation. Here we compare the stat output (information from
    the inode) for both an encrypted and decrypted file:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 内容和文件名已加密，但有一些元数据可能对调查有用。这里我们比较加密文件和解密文件的 stat 输出（来自 inode 的信息）：
- en: '[PRE51]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The encrypted files have the same timestamps ➌, permissions, and ownership ➋
    as their decrypted counterparts. The file sizes ➊ are different, and encrypted
    files will be at least 12,288 bytes in size. When mounted, the encrypted and decrypted
    files show the same inode number (even though they are on different mounted filesystems).
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 加密文件与其解密文件具有相同的时间戳 ➌、权限和所有权 ➋。文件大小 ➊ 不同，加密文件的大小至少为 12,288 字节。挂载后，加密文件和解密文件显示相同的
    inode 号（尽管它们位于不同的挂载文件系统中）。
- en: The decrypted files are available only when mounted on a running system. To
    access the decrypted content (assuming that the passphrase is known), the encrypted
    directory can be copied to an analysis system and decrypted. To do this, install
    the `ecryptfs-utils` software package, copy the three directories (*.ecryptfs/*,
    *.Private/*, and *Private/*), and run ecryptfs-mount-private. The passphrase should
    be requested, and the decryption directory (*Private/*) will be mounted. The inode
    number can be used to match corresponding encrypted and decrypted files (the `ecryptfs-find`
    tool can also do this).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 解密文件仅在运行中的系统上挂载时可用。要访问解密内容（假设已知密码短语），可以将加密目录复制到分析系统并解密。为此，安装 `ecryptfs-utils`
    软件包，复制三个目录（*.ecryptfs/*、*.Private/* 和 *Private/*），然后运行 ecryptfs-mount-private。系统会请求输入密码短语，然后将挂载解密目录（*Private/*）。可以使用
    inode 号来匹配对应的加密和解密文件（`ecryptfs-find` 工具也可以做到这一点）。
- en: To unmount (make encrypted files unavailable), run the `ecryptfs-umount` `-private`
    command. See the mount.ecryptfs_private(1) man page for alternative locations
    and ways of decrypting.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 要卸载（使加密文件不可用），运行 `ecryptfs-umount` `-private` 命令。有关解密的替代位置和方法，请参见 mount.ecryptfs_private(1)
    手册页。
- en: 'Two passwords are associated with an eCryptfs directory: a *mount passphrase*
    and a *wrapping passphrase*. By default, the mount passphrase is a randomly generated
    32-character hexadecimal string, which the user may be asked to save in case of
    emergency (if they forgot their wrapping passphrase). This mount passphrase is
    provided to the kernel to mount and decrypt the files. The wrapping passphrase
    protects the mount passphrase and is chosen by the user, who can change it without
    affecting the encrypted files. The wrapping passphrase is often the same as the
    user’s login password.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 eCryptfs 目录关联着两个密码：*挂载密码短语* 和 *包装密码短语*。默认情况下，挂载密码短语是一个随机生成的 32 字符十六进制字符串，用户可能被要求保存它以备不时之需（如果忘记了他们的包装密码短语）。该挂载密码短语被提供给内核，以便挂载和解密文件。包装密码短语保护挂载密码短语，并由用户选择，用户可以在不影响加密文件的情况下更改它。包装密码短语通常与用户的登录密码相同。
- en: In a forensic examination, a successful search for this backup passphrase may
    allow access to the encrypted files. If the mount passphrase is discovered, a
    new wrapping passphrase can be set using the `ecryptfs-wrap-passphrase` command.
    This newly set passphrase can then be used to mount the eCryptfs directory.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在法医检查中，成功找到这个备份密码短语可能允许访问加密文件。如果发现了挂载密码短语，则可以使用 `ecryptfs-wrap-passphrase` 命令设置新的包装密码短语。然后可以使用这个新设置的密码短语来挂载
    eCryptfs 目录。
- en: 'As a last resort, the password cracker John the Ripper supports attempting
    to recover eCryptfs passwords. In the following example, we first extract information
    from the eCryptfs wrapped-passphrase file and save it in a format that John the
    Ripper can understand. We then run john to crack it:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的手段，密码破解工具 John the Ripper 支持尝试恢复 eCryptfs 密码。在以下示例中，我们首先从 eCryptfs 包装密码短语文件中提取信息，并将其保存为
    John the Ripper 可以理解的格式。然后我们运行 john 进行破解：
- en: '[PRE52]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: After some number-crunching and wordlist brute-forcing, John the Ripper discovers
    the ecryptfs password is `canada`.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一番数据计算和词汇表暴力破解后，John the Ripper 发现 ecryptfs 密码是 `canada`。
- en: '***Fscrypt and Ext4 Directory Encryption***'
  id: totrans-549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Fscrypt 和 Ext4 目录加密***'
- en: 'The Linux kernel provides the ability to encrypt files and directories at the
    filesystem level (in contrast to the block level of LUKS) using fscrypt. Originally,
    this was part of ext4, but it’s been abstracted to support other filesystems (like
    F2FS, for example). This kernel API is described here: *[https://www.kernel.org/doc/html/latest/filesystems/fscrypt.html](https://www.kernel.org/doc/html/latest/filesystems/fscrypt.html)*.
    You can use userspace tools like `fscrypt` or `fscryptctl` to set up the kernel
    and lock and unlock encryption for specified directories.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核提供了在文件系统级别（与 LUKS 的块级别相对）使用 fscrypt 加密文件和目录的能力。最初，这是 ext4 的一部分，但它已被抽象化，以支持其他文件系统（例如
    F2FS）。该内核 API 如下所述： *[https://www.kernel.org/doc/html/latest/filesystems/fscrypt.html](https://www.kernel.org/doc/html/latest/filesystems/fscrypt.html)*。你可以使用像
    `fscrypt` 或 `fscryptctl` 这样的用户空间工具来设置内核并对指定目录进行加锁和解锁加密。
- en: 'Evidence of the use of fscrypt can be found in several places. The ext4 filesystem
    will show artifacts indicating that fscrypt capability is available:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在多个地方找到 fscrypt 使用的证据。ext4 文件系统会显示出指示 fscrypt 功能可用的痕迹：
- en: '[PRE53]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note the `encrypt` feature in the superblock output. Support for fscrypt is
    typically not enabled by default (mainly for backward compatibility). If this
    is enabled, it does not imply that fscrypt encryption is being used; however,
    it indicates that it was explicitly enabled, meaning that further examination
    should be done.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 注意超级块输出中的 `encrypt` 特性。fscrypt 的支持通常默认情况下不会启用（主要是为了向后兼容）。如果启用了它，这并不意味着正在使用 fscrypt
    加密；然而，它表明它已被显式启用，这意味着应进一步检查。
- en: 'Some fscrypt userspace tools may create traces on the system. For example,
    fscrypt from Google (*[https://github.com/google/fscrypt/](https://github.com/google/fscrypt/)*)
    creates a configuration file */etc/fscrypt.conf* and a hidden directory */.fscrypt/*
    in the root of the filesystem. Searching for those files indicates use of fscrypt
    functionality. Another (possible) indicator is the existence of long, cryptic
    filenames that can’t be copied. The following output is from an fscrypt directory
    in locked and unlocked states, respectively:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 fscrypt 用户空间工具可能会在系统上创建痕迹。例如，Google 的 fscrypt (*[https://github.com/google/fscrypt/](https://github.com/google/fscrypt/)*
    ) 创建了一个配置文件 */etc/fscrypt.conf* 和一个隐藏目录 */.fscrypt/*，位于文件系统的根目录中。搜索这些文件表明使用了 fscrypt
    功能。另一个（可能的）指示符是存在长且晦涩的文件名，这些文件名无法复制。以下输出分别显示了一个 fscrypt 目录的加锁和解锁状态：
- en: '[PRE54]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Unlike eCryptfs, the encrypted files can’t be copied to the analysis machine.
    The filesystem can’t access the files without the key:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 与 eCryptfs 不同，加密文件不能复制到分析机器上。没有密钥，文件系统无法访问这些文件：
- en: '[PRE55]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Decrypted access to the directory is possible only if the entire filesystem
    is accessible on the forensic analysis machine and encryption is configured in
    the kernel. The userspace tool used to encrypt the directory must also be installed
    on the analysis machine. If the passphrase is known, the encrypted directory can
    be accessed. The file */etc/fscrypt.conf* on the forensic analysis machine and
    the suspect drive should be compared, and this file may need to be copied (it
    contains configuration data).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在整个文件系统在取证分析机器上可访问且内核中已配置加密的情况下，才能解密访问该目录。用于加密目录的用户空间工具也必须安装在分析机器上。如果知道密码短语，则可以访问加密目录。应比较取证分析机器和嫌疑驱动器上的文件*/etc/fscrypt.conf*，该文件可能需要被复制（它包含配置信息）。
- en: 'The following example shows the `fscrypt` tool used to access evidence on an
    encrypted directory of an ext4 filesystem:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了使用 `fscrypt` 工具访问 ext4 文件系统中加密目录上的证据：
- en: '[PRE56]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the first line, the ext4 partition is mounted on */evidence/* (it’s still
    a normal filesystem; nothing unusual here). In the second line, the `fscrypt unlock`
    command specifies the encrypted directory and a passphrase is requested. The required
    key information is stored in the *.fscrypt/* directory in the root of the drive,
    but the passphrase is needed to decrypt it.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行中，ext4 分区挂载在 */evidence/*（这仍然是一个正常的文件系统；这里没有异常）。第二行中，`fscrypt unlock` 命令指定了加密目录并请求密码短语。所需的密钥信息存储在驱动器根目录下的
    *.fscrypt/* 目录中，但需要密码短语来解密它。
- en: The metadata is not encrypted under fscrypt. The inode information (using `stat`
    or `istat`) will be the same whether the directory is locked or unlocked. Timestamps,
    ownership, permissions, and so on are all visible even if the directory is encrypted
    (locked).
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据在 fscrypt 下是未加密的。无论目录是加锁还是解锁，inode 信息（使用 `stat` 或 `istat`）都是相同的。时间戳、所有权、权限等信息都可见，即使目录是加密的（加锁）。
- en: '**Summary**'
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, I have explained the forensic analysis of storage. You have
    learned to examine the drive layout and partition tables, RAID, and LVM. The three
    most popular Linux filesystems have been explained, with a focus on analysis and
    recovering interesting forensic artifacts. Clearly the community’s forensic tool
    development is lacking in some areas, but this is an evolving area of research
    that will mature over time.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我已经解释了存储的法医分析。你已经学会了检查磁盘布局和分区表、RAID 和 LVM。三种最流行的 Linux 文件系统已经被解释，重点是分析和恢复有价值的法医证据。显然，社区的法医工具开发在某些领域存在不足，但这是一个正在发展中的研究领域，随着时间的推移将逐渐成熟。
