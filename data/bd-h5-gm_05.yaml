- en: Chapter 4. Translating Game State Changes to the Display
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 将游戏状态变化翻译为显示效果
- en: Animation is a powerful visual cue to show players how their actions affect
    a game. Whenever a player causes the game state to change, you need to display
    the results. In this chapter, you’ll add code to detect and remove bubble groups,
    learn more about animating CSS sprites, and implement a nifty exploding effect
    in jQuery.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是一种强大的视觉提示，用于向玩家展示他们的动作如何影响游戏。每当玩家导致游戏状态发生变化时，你需要展示结果。在本章中，你将添加代码来检测并移除气泡组合，了解如何为CSS精灵添加动画，并在jQuery中实现一个漂亮的爆炸效果。
- en: At this point, players can fire bubbles at the game board, and those bubbles
    will become part of the bubble grid. Now, we need to pop groups of matching bubbles
    when a player fires the correct color at them. When `curBubble` is fired into
    another bubble and a group of three or more matching bubbles forms, all bubbles
    in that group should show a popping animation and then be removed from the display
    and the `Board` object.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，玩家可以向游戏板发射气泡，这些气泡将成为气泡网格的一部分。现在，我们需要在玩家发射正确颜色的气泡时，弹出匹配气泡的组合。当`curBubble`被发射到另一个气泡上，并且形成三个或更多匹配气泡的组合时，该组合中的所有气泡应该展示爆炸动画，然后从显示屏和`Board`对象中移除。
- en: We’ll also need to detect and handle any cascading effects caused by popping
    bubbles. For example, if sets of bubbles are disconnected from the main group
    when we pop another set, we should destroy the disconnected bubbles in a different
    way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要检测并处理气泡爆炸所引发的任何连锁反应。例如，如果当我们消除另一组气泡时，某些气泡与主组合断开连接，我们应该以不同的方式销毁这些断开的气泡。
- en: Calculating Groups
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算组合
- en: The `Board` object contains the row and column information for each bubble in
    the grid and will determine whether a fired bubble forms a group of three or more
    when it lands. We’ll add a function to *board.js* that returns all of the bubbles
    surrounding a given (row,column) position. Then we’ll group them by color and
    work out which ones to pop.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`Board`对象包含网格中每个气泡的行列信息，并且将确定发射的气泡落地时是否形成三个或更多的组合。我们将在*board.js*中添加一个函数，该函数返回给定（行，列）位置周围的所有气泡。然后，我们将按颜色对这些气泡进行分组，确定哪些气泡需要被消除。'
- en: Fetching Bubbles
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取气泡
- en: 'First, we need to retrieve the set of bubbles surrounding the specified coordinates
    from the board’s `rows` variable. Add the following methods to *board.js* after
    the `addBubble` method:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从游戏板的`rows`变量中检索围绕指定坐标的气泡集合。在`addBubble`方法后，向*board.js*中添加以下方法：
- en: '*board.js*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*board.js*'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `getBubbleAt` method ➊ takes an input row and column coordinate and returns
    the bubble at that location. If no bubble exists at that location, it returns
    `null`. The `getBubblesAround` method ➋ loops through the three relevant rows—the
    same row, the one above, and the one below—and then examines the surrounding columns,
    calling `getBubbleAt` for each position. Note that `getBubbleAt` returns `null`
    for every alternate column entry due to the half-populated row arrays. For this
    reason, we look at two entries to the left ➌ (`curCol-2`) and two to the right
    ➍ (`curCol+2`) of the current bubble. No matter whether we start on an odd or
    an even row, this method should work. We also need to check that a bubble exists
    at the coordinates we’re examining and that we don’t add the bubble that we’re
    checking around ➎.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBubbleAt`方法➊接受行列坐标作为输入，并返回该位置的气泡。如果该位置没有气泡，则返回`null`。`getBubblesAround`方法➋遍历三行相关的行——当前行、上一行和下一行——然后检查周围的列，对于每个位置调用`getBubbleAt`。请注意，由于行数组是半填充的，`getBubbleAt`会返回`null`，对于每个间隔列项都如此。因此，我们需要查看当前气泡左边的两个位置➌（`curCol-2`）和右边的两个位置➍（`curCol+2`）。无论我们是从奇数行还是偶数行开始，这个方法应该都能工作。我们还需要检查在我们检查的坐标位置上是否有气泡，并且确保不会把我们正在检查的气泡本身添加进去➎。'
- en: Any bubbles surrounding the fired bubble are pushed into the `bubbles` array
    and are returned by `getBubblesAround`. Each bubble stores its own coordinates,
    so we don’t need to sort the array or store position information separately.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所有围绕发射气泡的气泡都会被推入`bubbles`数组，并由`getBubblesAround`返回。每个气泡存储自己的坐标，因此我们不需要对数组进行排序或单独存储位置信息。
- en: Creating Matching Color Groups
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建匹配颜色组合
- en: 'Next, we’ll write a more substantial function called `getGroup` to return groups
    that are the same color as the first bubble and are connected to that bubble.
    This recursive function will accept two parameters: a bubble, which sets the starting
    coordinates and the color (type) definition, and an object, which stores bubbles
    that are part of the group. The object will store found bubbles in two arrays
    added as properties: first as a linear array and additionally in an array indexed
    by row and column. The second array allows us to easily check whether we have
    already added a bubble to the matching set to avoid adding duplicates. Both arrays
    are added as properties of an object so we can return both when we call the method.
    The flowchart in [Figure 4-1](ch04.html#grabbing_a_group_of_connected_bubbles_of
    "Figure 4-1. Grabbing a group of connected bubbles of the same color") shows an
    overview of this process.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个更为实质性的函数，名为`getGroup`，用来返回与第一个气泡颜色相同并与其相连的气泡群。这个递归函数将接受两个参数：一个气泡对象，用于设置起始坐标和颜色（类型）定义；一个对象，用于存储属于该群的气泡。该对象将通过两个数组作为属性来存储找到的气泡：首先是一个线性数组，另外是一个按行和列索引的数组。第二个数组使我们能够轻松检查是否已将气泡添加到匹配集合中，以避免重复添加。两个数组作为对象的属性，以便在调用方法时可以返回这两个数组。下图
    [图4-1](ch04.html#grabbing_a_group_of_connected_bubbles_of "图4-1：抓取与第一个气泡颜色相同并相连的气泡群")
    展示了该过程的概览。
- en: 'The function we’ll add to the `Board` class looks like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加到`Board`类中的函数如下所示：
- en: '*board.js*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*board.js*'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s break down this new function and walk through the logic. After we pass
    in the `bubble` object and `found` object, `getGroup` first checks to see if this
    bubble was already found.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个新函数并逐步讲解逻辑。在传入`bubble`对象和`found`对象后，`getGroup`首先检查这个气泡是否已经被找到。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the bubble was already found, `getGroup` should return the current unchanged
    data and stop. If the `found` object doesn’t have an entry for the current row,
    we need to create an empty array ➊. Then, if the `list` property doesn’t exist,
    it needs to be created ➋ but only on the initial call to the function. If this
    bubble was detected previously, we return the found object without adding the
    bubble again ➌. Otherwise, we track that we’ve looked in this location ➍ and store
    the bubble in the `found` list ➎.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果气泡已经被找到，`getGroup`应该返回当前未改变的数据并停止。如果`found`对象中没有当前行的条目，我们需要创建一个空数组 ➊。然后，如果`list`属性不存在，它需要在函数的首次调用时创建
    ➋。如果这个气泡之前已被检测到，我们返回已找到的对象，而不再重复添加该气泡 ➌。否则，我们标记已查看此位置 ➍，并将气泡存储在`found`列表中 ➎。
- en: Next, we retrieve the surrounding bubbles ➏.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们获取周围的气泡 ➏。
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At most, there should be six, and then we need to check each for a color match:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最多应该有六个气泡，然后我们需要检查每个气泡的颜色是否匹配：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If a bubble matches the fired bubble’s color ➐, the function calls itself; `getGroup`
    adds the checked bubble to the flat array and marks that its coordinates have
    been checked. The function calls itself again, passing in the newly found bubble
    and the current data state (with the `found` list). Whatever the result, we’ll
    return the final value of `found` ➑.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个气泡与发射的气泡颜色匹配 ➐，函数会递归调用自身；`getGroup`将检查过的气泡添加到平面数组中，并标记其坐标已被检查。函数再次调用自身，传入新找到的气泡和当前的数据状态（包括`found`列表）。无论结果如何，我们都会返回`found`的最终值
    ➑。
- en: '![Grabbing a group of connected bubbles of the same color](httpatomoreillycomsourcenostarchimages2184519.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![抓取与第一个气泡颜色相同并相连的气泡群](httpatomoreillycomsourcenostarchimages2184519.png)'
- en: Figure 4-1. Grabbing a group of connected bubbles of the same color
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1：抓取与第一个气泡颜色相同并相连的气泡群
- en: 'Now we need to call this method when the bubble is fired. In *game.js*, add
    in the `clickGameScreen` routine:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在气泡发射时调用这个方法。在 *game.js* 中，添加到`clickGameScreen`例程中：
- en: '*game.js*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When we fetch a group of bubbles with `board.getGroup` ➊, we might end up with
    a group containing fewer than three bubbles. Because we need to consider only
    groups of three or more bubbles, we’ll skip any smaller groups ➋. Now we just
    need to write the routine for popping bubbles ➌!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`board.getGroup`获取一组气泡时 ➊，我们可能得到一个包含少于三个气泡的群组。因为我们只考虑包含三个或更多气泡的群组，所以我们会跳过任何较小的群组
    ➋。现在，我们只需要编写弹出气泡的例程 ➌！
- en: Popping Bubbles
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹出气泡
- en: We need the game to determine whether a group of bubbles has three or more bubbles,
    and if so, remove those bubbles. In this section, you’ll implement the JavaScript
    functions that remove bubble groups and add a fun popping animation with CSS.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要游戏判断一组气泡是否有三颗或更多气泡，如果是，则移除这些气泡。在本节中，你将实现移除气泡组合的 JavaScript 函数，并用 CSS 添加一个有趣的破裂动画。
- en: Removing Bubble Groups with JavaScript
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JavaScript 移除气泡组合
- en: We’ll begin by calculating what the board should look like after a group has
    been popped. When that’s complete, we can update the display and remove any popped
    bubbles from view. As long as the game state is calculated correctly, you can
    add animation thereafter. Updating the game state and then writing separate code
    to display the new state is a useful approach to take throughout game development.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先计算当一组气泡被破裂后，棋盘应该是什么样子。当计算完成后，我们可以更新显示并将破裂的气泡从视图中移除。只要游戏状态计算正确，你就可以在此之后添加动画。更新游戏状态并编写单独的代码来显示新状态是游戏开发中一种非常有用的方法。
- en: 'Add a new function called `popBubbles` after `clickGameScreen`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `clickGameScreen` 后添加一个名为 `popBubbles` 的新函数：
- en: '*game.js*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `popBubbles` function loops over each `bubble` object in the array we pass
    it ➊ and tells the board to remove the bubble ➋ by calling `popBubbleAt` (which
    we’ll write next). Then it waits for `delay + 200` milliseconds to remove the
    bubble from the DOM to allow time for the animation of firing the bubble to run.
    As a result, the user can see what’s happened before the screen is updated. The
    starting value of `delay` is passed in from the fired bubble’s duration—the time
    it took to travel from its starting point—so bubbles will always disappear 200
    milliseconds after the grouping has occurred.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`popBubbles` 函数遍历我们传入的数组中的每个 `bubble` 对象 ➊，并通过调用 `popBubbleAt` 告诉棋盘移除该气泡 ➋（我们接下来将编写该函数）。然后，它等待
    `delay + 200` 毫秒后再从 DOM 中移除气泡，以便让发射气泡的动画有时间运行。结果，用户可以在屏幕更新之前看到发生了什么。`delay` 的初始值是由发射气泡的持续时间传入的——即气泡从起点到达的时间——因此气泡总是在分组发生后的
    200 毫秒后消失。'
- en: 'The final piece of code is in *board.js*, where we need to define `popBubbleAt`.
    Add the following method after the close of the `getGroup` method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段代码位于 *board.js*，我们需要定义 `popBubbleAt`。在 `getGroup` 方法结束后添加以下方法：
- en: '*board.js*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*board.js*'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `popBubbleAt` method simply removes the entry you pass it from the row/column
    array.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`popBubbleAt` 方法仅仅是从行/列数组中移除你传给它的项。'
- en: Reload the game and fire a bubble. When you make a set of three or more bubbles,
    they should disappear from view. At last, *Bubble Shooter* is starting to look
    more like a game!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载游戏并发射一个气泡。当你形成三颗或更多的气泡时，它们应该从视图中消失。最终，*Bubble Shooter* 开始看起来更像一个游戏了！
- en: Popping Animations with CSS
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CSS 的气泡破裂动画
- en: '*Moving* sprites around the screen with CSS is one type of animation, but now
    it’s time to animate sprites in a different way and change how they *look.* This
    will present players with a visually rewarding popping animation, which will use
    the other sprite frames we created at the beginning of the book.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 用 CSS *移动* 屏幕上的精灵是动画的一种形式，但现在是时候用不同的方式为精灵添加动画，并改变它们的 *外观* 了。这将为玩家呈现一个视觉上令人满意的气泡破裂动画，并使用我们在书的开头创建的其他精灵帧。
- en: The best way to animate a sprite graphic is by changing the position of its
    background image. Recall that *bubble_sprite_sheet.png* (shown again in [Figure 4-2](ch04.html#four_states_of_the_bubble_spritecomma_as
    "Figure 4-2. The four states of the bubble sprite, as contained in bubble_sprite_sheet.png")
    for convenience) contains not only the four bubble types but also four different
    states for each color.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给精灵图形添加动画，最好的方法是改变其背景图像的位置。回想一下 *bubble_sprite_sheet.png*（为了方便，图 [Figure 4-2](ch04.html#four_states_of_the_bubble_spritecomma_as
    "Figure 4-2. The four states of the bubble sprite, as contained in bubble_sprite_sheet.png")
    再次展示）不仅包含了四种气泡类型，还为每种颜色提供了四种不同的状态。
- en: '![The four states of the bubble sprite, as contained in bubble_sprite_sheet.png](httpatomoreillycomsourcenostarchimages2184521.png.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![气泡精灵的四种状态，见于 bubble_sprite_sheet.png](httpatomoreillycomsourcenostarchimages2184521.png.jpg)'
- en: Figure 4-2. The four states of the bubble sprite, as contained in *bubble_sprite_sheet.png*
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2. 气泡精灵的四种状态，见于 *bubble_sprite_sheet.png*
- en: We can display a popping animation by showing the four frames in succession,
    which we’ll do by shifting the background image to the left by 50 pixels at a
    time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过连续展示四帧来显示一个气泡破裂的动画，方法是每次将背景图像向左移动 50 像素。
- en: 'The game pops only bubbles in groups, but the popping effect won’t be nearly
    as fun to watch if all the bubbles in a group disappear at once. To make the effect
    more interesting, we’ll pop the bubbles individually rather than all together.
    Doing so will require a small change to the `popBubbles` method we just added
    to *game.js*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏仅在气泡组内进行爆炸，但如果一组气泡同时消失，爆炸效果将不会那么有趣。为了使效果更加有趣，我们将逐个爆炸气泡，而不是同时爆炸。这样做需要对我们刚刚添加到*game.js*中的`popBubbles`方法做一些小改动：
- en: '*game.js*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we call `animatePop` ➊, a new method that we’ll add to `Bubble` to change
    the bubble’s background image position. The first bubble’s popping animation should
    start as soon as the fired bubble collides with it. But subsequent pops should
    be delayed by 60 milliseconds by incrementing `delay` ➋. Add `animatePop` to *bubble.js*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们称`animatePop` ➊为一个新方法，我们将把它添加到`Bubble`中，用于更改气泡背景图像的位置。第一个气泡的爆炸动画应该在被发射的气泡与其碰撞后立即开始。但随后的爆炸应通过增加`delay`
    ➋来延迟60毫秒。将`animatePop`添加到*bubble.js*中。
- en: '*bubble.js*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*bubble.js*'
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Based on the bubble’s type, `animatePop` calculates ➊ the value representing
    the top part of the bubble’s `background-position` property. The `type` value
    tells us what color the bubble should be; we’ll use it to select the appropriate
    row of popping animation images. Next, using a basic CSS transformation, we add
    a bit of visual variation ➋ to the animation by rotating the bubble sprite at
    a random angle to prevent all the popping animations from appearing identical.
    You’ll see more examples of CSS transformations in [Chapter 5](ch05.html "Chapter 5. CSS
    Transitions and Transformations"). To stagger the start time of each popping animation,
    the function makes three delayed calls ➌ that move the `background-position` to
    the left by 50 pixels.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据气泡的类型，`animatePop`计算 ➊表示气泡`background-position`属性上方部分的值。`type`值告诉我们气泡应该是什么颜色；我们将用它来选择合适的爆炸动画图像行。接下来，使用基本的CSS变换，我们通过将气泡精灵以随机角度旋转，给动画增加一些视觉变化
    ➋，以防止所有的爆炸动画看起来一模一样。你将在[第5章](ch05.html "第5章。CSS过渡和变换")中看到更多关于CSS变换的示例。为了错开每个爆炸动画的开始时间，该函数进行了三次延迟调用
    ➌，将`background-position`向左移动50像素。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Hard-coding an animation this way is not very scalable, but* Bubble Shooter
    *has only one sprite with three frames to display. Therefore, we can avoid writing
    a generic function, which is the reason we use a sequence of `setTimeout` calls
    instead. When we implement the same animation using `canvas` rendering, you’ll
    see an example of how to code an animation that is more reusable.*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过这种方式硬编码动画并不具有很好的可扩展性，但*《泡泡射手》*只有一个精灵，且仅显示三帧。因此，我们可以避免编写一个通用函数，这也是我们选择使用一系列`setTimeout`调用的原因。当我们使用`canvas`渲染实现相同的动画时，你将看到如何编写一个更具可重用性的动画示例。*'
- en: Finally, `animatePop` removes the sprite’s DOM element ➍ when the animation
    has finished. Removing the node from the DOM helps with memory management, which
    would be even more important in a game with more onscreen objects. At approximately
    20 frames per second, the resulting animation frame rate is fairly poor. A professional
    game should have a frame rate of three times that number. But the principle of
    creating an animation by shifting a background image is the same regardless.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`animatePop`在动画完成时会移除精灵的DOM元素 ➍。从DOM中移除节点有助于内存管理，在一个有更多屏幕对象的游戏中，这一点尤其重要。大约每秒20帧的动画帧率相当低。一个专业的游戏应该具有三倍的帧率。但无论如何，通过移动背景图像来创建动画的原理是相同的。
- en: 'When you reload the page and fire a bubble to make a matching group, you should
    see a pleasing popping animation. However, after popping numerous bubbles, you
    may see a side effect of removing bubbles that we need to remedy: a popped group
    might be the only element holding a set of bubbles of varied colors onto the main
    board. Currently, these bubbles are left hanging in space and look a bit odd.
    Because the game design stipulates that these bubbles be removed as well, we’ll
    do that next.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新加载页面并发射一个气泡来形成匹配组时，你应该会看到一个令人愉快的爆炸动画。然而，在爆炸了大量气泡后，你可能会看到我们需要修复的副作用：被爆炸的组可能是唯一将一组不同颜色气泡固定在主板上的元素。目前，这些气泡悬浮在空中，看起来有点奇怪。由于游戏设计要求这些气泡也被移除，我们接下来就会处理这个问题。
- en: Orphaned Groups
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 孤立的气泡组
- en: Groups of bubbles that have been disconnected from the rest of the board are
    called *orphans*. For example, in [Figure 4-3](ch04.html#popping_the_red_bubbles_creates_four_orp
    "Figure 4-3. Popping the red bubbles creates four orphaned bubbles."), popping
    the boxed group of bubbles would leave four orphaned bubbles hanging in midair.
    Orphaned sets of bubbles need to be removed by the firing bubble as well. But
    rather than have them pop in the same way as popped groups, we’ll add a different
    animation. Orphans will fall off the screen and appear as though they were hanging
    and had their supports cut. Not only will players recognize that something different
    has happened, but we also get to experiment with a different animation type. Currently,
    detecting orphaned groups is not part of the code; so, before we can animate them,
    we need to find them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他气泡断开的气泡组被称为*孤立气泡*。例如，在[图4-3](ch04.html#popping_the_red_bubbles_creates_four_orp
    "图4-3. 弹出红色气泡会创建四个孤立气泡")中，弹出框中的气泡组会留下四个孤立气泡悬挂在空中。孤立气泡集合也需要被触发气泡移除。但不同于与其他组一起爆裂的方式，我们会添加另一种动画效果。孤立气泡将从屏幕上掉落，看起来就像被切断支撑一样悬挂着。不仅玩家会意识到发生了不同的事情，而且我们也能尝试不同的动画类型。目前，检测孤立组不是代码的一部分；因此，在我们能进行动画之前，我们需要找到它们。
- en: '![Popping the red bubbles creates four orphaned bubbles.](httpatomoreillycomsourcenostarchimages2184523.png.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![弹出红色气泡会创建四个孤立气泡。](httpatomoreillycomsourcenostarchimages2184523.png.jpg)'
- en: Figure 4-3. Popping the red bubbles creates four orphaned bubbles.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-3. 弹出红色气泡会创建四个孤立气泡。
- en: Identifying Orphaned Bubbles
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定孤立气泡
- en: We’ll check each bubble and determine whether it’s part of a group that’s connected
    to any bubbles in the top row. Because the top row is considered to be permanently
    attached, any bubble that can’t trace a route back to the top row will be identified
    as part of an orphaned group.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查每个气泡，判断它是否属于与任何位于顶行的气泡相连的组。因为顶行被认为是永久连接的，任何无法追溯到顶行的气泡将被标识为孤立组的一部分。
- en: Tracing this route might seem like a problem we haven’t encountered yet; however,
    we can actually use the already written `getGroup` method and find orphaned sets
    quite simply. [Figure 4-4](ch04.html#logic_flow_for_determining_the_set_of_or
    "Figure 4-4. The logic flow for determining the set of orphaned bubbles") shows
    the process for checking whether a group is part of an orphaned set.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪这一路线可能看起来是一个我们尚未遇到的问题；然而，我们实际上可以利用已经编写的`getGroup`方法，并相当简单地找到孤立集合。[图4-4](ch04.html#logic_flow_for_determining_the_set_of_or
    "图4-4. 确定孤立气泡集合的逻辑流程")展示了检查一个组是否属于孤立集合的过程。
- en: '![The logic flow for determining the set of orphaned bubbles](httpatomoreillycomsourcenostarchimages2184525.png.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![确定孤立气泡集合的逻辑流程](httpatomoreillycomsourcenostarchimages2184525.png.jpg)'
- en: Figure 4-4. The logic flow for determining the set of orphaned bubbles
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-4. 确定孤立气泡集合的逻辑流程
- en: Using this logic, we can reuse the `getGroup` function in step 2\. But to do
    so, we need to revise the criterion that bubbles must be the same color to form
    a group.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个逻辑，我们可以在步骤2中重用`getGroup`函数。但为了做到这一点，我们需要修改气泡必须为相同颜色才能形成组的标准。
- en: 'Let’s change `getGroup` to take a parameter that allows for the selection of
    nonmatching color groups:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`getGroup`，使其能够选择不匹配颜色的气泡组：
- en: '*board.js*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*board.js*'
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The function definition now takes an extra parameter ➊. Where `getGroup` is
    called recursively, it should ignore the type check ➋ if the value is set to `true`,
    and it passes the input parameter through the recursion chain. With these simple
    changes, a `getGroup(bubble,{},true)` call should return all bubbles that the
    passed bubble is connected to regardless of color. Calling `getGroup(bubble,{},false)`
    or just `getGroup(bubble,{})` should operate the same way as before.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，函数定义增加了一个额外的参数➊。对于递归调用`getGroup`的地方，如果值设置为`true`，它应忽略类型检查➋，并将输入参数传递通过递归链。通过这些简单的更改，调用`getGroup(bubble,{},true)`应该返回所有与传入气泡相连的气泡，无论颜色如何。调用`getGroup(bubble,{},false)`或仅仅`getGroup(bubble,{})`应与之前的操作方式相同。
- en: The `findOrphans` function will be a method in the `Board` class and will examine
    every bubble in the top row, finding the group of bubbles each one connects to.
    (Initially, every bubble on the board will be in one big group, except the bubble
    to be fired.) An array of (row,column) values will be populated with false values,
    and every time a bubble is found, the (row,column) entry will be set to true for
    that location. At the end of the process, coordinates that contain a bubble but
    have a value set to `false` in the returned array will be orphaned and removed
    from the game.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOrphans`函数将作为`Board`类中的一个方法，检查顶行中的每个气泡，找到每个气泡连接到的气泡组。（最初，棋盘上的每个气泡都将在一个大组中，除了将要发射的气泡。）一个包含(row,
    column)值的数组将用`false`值填充，每次找到气泡时，该位置的(row, column)条目会被设置为`true`。在这个过程结束时，包含气泡但返回数组中该位置值为`false`的坐标将被视为孤立气泡并从游戏中移除。'
- en: 'Add the following code to *board.js* after `popBubbleAt`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`popBubbleAt`之后，将以下代码添加到*board.js*：
- en: '*board.js*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*board.js*'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s analyze the `findOrphans` function more closely. First, we set up the
    arrays we need to find orphaned groups.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地分析`findOrphans`函数。首先，我们设置需要的数组，以便找到孤立的气泡组。
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `connected` array ➊ is a two-dimensional array of rows and columns; it marks
    the locations of connected bubbles. The `groups` array ➋ will contain a set of
    all the groups found, which will be a single group if the entire board is connected.
    Next, we examine each bubble in the top row.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`connected`数组 ➊是一个二维的行列数组；它标记了连接气泡的位置。`groups`数组 ➋将包含所有找到的组，如果整个棋盘是连接的，则会是一个组。接下来，我们检查顶行中的每个气泡。'
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, because we’re only interested in bubbles connected to the top row, we
    loop over just the top row and fetch bubbles to check. When we have a bubble,
    we can start creating groups.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，因为我们只关心与顶行相连的气泡，我们只遍历顶行并获取气泡进行检查。当我们找到一个气泡时，就可以开始创建分组。
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If a bubble is present and this space hasn’t already been marked as connected,
    we build a group. The call to `getGroup` passes `true` as the third parameter
    (`differentColor`), because we don’t want to restrict connected bubbles by color.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果气泡存在且此位置尚未标记为连接的，我们就构建一个组。调用`getGroup`时，传递`true`作为第三个参数（`differentColor`），因为我们不希望通过颜色来限制连接的气泡。
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Because the bubble being checked is connected via the first row, the entire
    group is connected; therefore, we mark each entry in the `connected` array with
    a true flag.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因为被检查的气泡通过第一行连接，整个组都是连接的；因此，我们将`connected`数组中的每个条目标记为`true`。
- en: 'After calling `findOrphans`, we should have an array of connected row and column
    entries. A list of orphaned bubbles is the final output we want, so we need to
    create another empty array to hold that list. A single-dimensional array is sufficient
    because the bubbles store their own coordinates:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`findOrphans`之后，我们应该得到一个包含连接的行列条目的数组。孤立气泡的列表是我们最终想要的输出，因此我们需要创建另一个空数组来存储该列表。一个一维数组足够了，因为气泡存储了它们自己的坐标：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using this new array, we examine all the rows and columns on the board, checking
    whether a bubble exists at each space. If a bubble exists but no entry is in the
    connected grid, it’s an orphan. We then add it to the orphaned list with the call
    to `orphaned.push(bubble)`. Finally, `findOrphans` returns the array of orphaned
    bubbles, which should be empty if no orphans exist.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新数组，我们检查棋盘上的所有行列，查看每个位置是否有气泡。如果有气泡，但在连接网格中没有条目，则该气泡是孤立的。然后，我们通过调用`orphaned.push(bubble)`将其添加到孤立气泡列表中。最后，`findOrphans`返回孤立气泡的数组，如果没有孤立气泡，该数组应为空。
- en: Dropping Orphaned Bubbles
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 丢弃孤立气泡
- en: Now that we can find the groups of bubbles that will be orphaned, we need to
    call the function and remove any identified orphaned bubbles. Rather than pop,
    we want the orphaned bubbles to drop, using an animation that occurs after the
    popping animation has completed. The internal game state will still update instantaneously,
    because we calculate the outcome as soon as the player has fired the bubble. We
    add the delay not just to provide a more dramatic effect, but also so players
    can follow the results of their actions onscreen. If we animated the falling orphaned
    groups as soon as we knew they would be orphaned, the effect might be lost. In
    addition, players might be confused as to why bubbles of different colors had
    disappeared.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以找到将被孤立的气泡组，我们需要调用函数并移除所有已识别的孤立气泡。我们不希望气泡爆炸，而是希望孤立的气泡下落，使用一种在爆炸动画完成后进行的动画效果。内部的游戏状态仍然会即时更新，因为我们会在玩家发射气泡后立即计算结果。我们添加延迟不仅是为了提供更具戏剧性的效果，也让玩家能够跟随屏幕上的动作结果。如果我们一知道气泡会被孤立就立即进行下落动画，效果可能会丧失。此外，玩家可能会困惑为何不同颜色的气泡突然消失了。
- en: In this situation, the benefits of separating game state from display state
    are apparent. We update the game state instantly, players can fire their next
    bubble almost immediately without having to wait for completed animations, and
    the game feels responsive. But in the display state, we make a big deal of this
    game state change—for effect and to communicate how the player’s actions lead
    to the final result. The animation approach is very much a game design decision
    rather than a coding one, but the way we’ve coded the game allows for flexibility.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将游戏状态与显示状态分离的好处显而易见。我们即时更新游戏状态，玩家几乎可以立刻发射下一个气泡，无需等待动画完成，游戏感觉非常响应迅速。但是在显示状态中，我们大张旗鼓地处理这一游戏状态变化——为了效果并传达玩家的操作如何导致最终结果。动画的方式更像是游戏设计的决策，而非编码决策，但我们编写的游戏代码使得这种设计具有灵活性。
- en: 'In *game.js*, add the following after the call to `popBubbles`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *game.js* 中，在调用 `popBubbles` 后添加以下内容：
- en: '*game.js*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We need to check for new orphans only if bubbles have been popped ➊, because
    that’s how orphaned groups are formed. We pop bubbles only if a matching group
    of three or more is created, so if `group.list` is greater than or equal to three,
    we need to look for orphaned bubbles. As we retrieve the orphans ➋, we calculate
    a delay ➌ timed to drop bubbles when all the popping has finished. To perform
    the animation, we need to write `dropBubbles` ➍.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在气泡被爆炸后检查新的孤立气泡➊，因为孤立的气泡组是由气泡爆炸后形成的。只有在形成三个或更多气泡的匹配组时，才会爆炸气泡，因此如果 `group.list`
    大于或等于三，我们需要查找孤立气泡。我们在获取孤立气泡时➋，计算一个延迟时间➌，以确保气泡在所有爆炸完成后掉落。为了执行动画，我们需要编写 `dropBubbles`
    ➍。
- en: 'The `dropBubbles` method will drop the bubbles off the screen. Add the following
    code after the close of the `popBubbles` function in *game.js*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropBubbles` 方法将会把气泡从屏幕上掉落。在 *game.js* 中的 `popBubbles` 函数关闭后，添加以下代码：'
- en: '*game.js*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `dropBubbles` function takes in parameters for the bubbles to drop ➊ (we’ll
    pass it the array of bubbles returned by `findOrphans`) and a delay. It removes
    the bubbles from the board ➋ and then animates them as they drop down the screen
    ➌.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropBubbles` 函数接收需要掉落的气泡数组➊（我们将传递由 `findOrphans` 返回的气泡数组）和延迟时间。它会从屏幕上移除气泡➋，然后为气泡掉落动画➌。'
- en: Refresh the game and pop a few groups of bubbles. When you form an orphan group,
    the bubbles should drop off the screen rather than popping.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新游戏并爆破几个气泡组。当你形成一个孤立的气泡组时，这些气泡应该掉落到屏幕上，而不是爆炸。
- en: Exploding Bubbles with a jQuery Plug-in
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 jQuery 插件爆炸气泡
- en: Although dropping bubbles is an animation, it’s not very dramatic. Let’s liven
    it up and create more of an explosion! We’ll write a jQuery plug-in to control
    this animation and abstract it from the game system.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管气泡掉落是一个动画，但它的戏剧性并不足够。让我们把它做得更生动，制造更具爆炸感的效果！我们将编写一个 jQuery 插件来控制这个动画，并将其从游戏系统中抽象出来。
- en: To make the orphaned bubbles animation more impressive, we’ll make the bubbles
    burst outward before dropping down the screen. We’ll do this by assigning a starting
    momentum to each bubble and then adjusting its speed with some simulated gravity.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让孤立气泡的动画更加引人注目，我们将在气泡下落到屏幕之前先让它们向外爆炸。我们通过给每个气泡赋予初始动量，然后用模拟重力调整其速度来实现这一效果。
- en: Although writing all the code to do this inline inside `dropBubbles` is possible,
    it would start to clutter the `Game` class with display logic. However, this animation
    is an ideal candidate for a jQuery plug-in, and the advantage is that we can reuse
    the code in future projects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将所有代码直接写进`dropBubbles`中也是可能的，但这样会开始让`Game`类充满显示逻辑。然而，这个动画非常适合作为jQuery插件，优点是我们可以在未来的项目中重用这段代码。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*For this example, I’ll cover only the most basic principles of writing jQuery
    plug-ins. You can explore plug-ins in more depth at* [http://learn.jquery.com/plugins/basic-plugin-creation/](http://learn.jquery.com/plugins/basic-plugin-creation/).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这个示例中，我只介绍了编写jQuery插件的最基本原则。你可以在* [http://learn.jquery.com/plugins/basic-plugin-creation/](http://learn.jquery.com/plugins/basic-plugin-creation/)
    *深入学习插件的相关内容。*'
- en: Make a new file called *jquery.kaboom.js* in the *_js* folder and add it to
    the `Modernizr.load` call. The file-naming convention informs others glancing
    in your *scripts* folder that this file is a jQuery plug-in; they don’t even need
    to look at the code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在*_js*文件夹中创建一个名为*jquery.kaboom.js*的新文件，并将其添加到`Modernizr.load`调用中。文件命名约定使得其他人一眼就能看出该文件是一个jQuery插件，他们甚至不需要查看代码。
- en: 'First, we register the method—which we’ll name `kaboom`—by using jQuery’s plug-in
    format:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过使用jQuery的插件格式来注册该方法——我们将其命名为`kaboom`：
- en: '*jquery.kaboom.js*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*jquery.kaboom.js*'
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’ll flesh out this code shortly; right now it doesn’t do anything. This function
    definition is the standard way of registering a new plug-in with jQuery. Its structure
    enables calls of the form `$(...).kaboom()`, including passing an optional settings
    parameter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快补充这段代码；目前它并没有做任何事情。这个函数定义是使用jQuery注册新插件的标准方式。它的结构允许像`$(...).kaboom()`这样的调用，包括传递一个可选的设置参数。
- en: 'The call to `kaboom` will be inside `dropBubbles`, so let’s add that call to
    `dropBubbles` and remove the `animate` calls:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`kaboom`的调用将在`dropBubbles`中，因此我们将把这个调用添加到`dropBubbles`中，并移除`animate`的调用：'
- en: '*game.js*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `kaboom` method will be called once for each object. This method will also
    only operate on jQuery objects; as a jQuery plug-in, it will have no knowledge
    of the game objects and will work only with DOM elements, making the plug-in reusable
    in future games.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`kaboom`方法将为每个对象调用一次。此方法也只会作用于jQuery对象；作为一个jQuery插件，它不会了解游戏对象，只会与DOM元素一起工作，这使得插件在未来的游戏中可以重用。'
- en: Inside `jquery.fn.kaboom`, we’ll use an array to store all the objects currently
    being exploded. Every time we call `kaboom`, we’ll add the calling object to that
    array. When the bubble has finished moving, it should remove itself from the list.
    By storing everything we want to move in an array, we can run a single `setTimeout`
    loop and update the position of all falling bubbles at the same time. Consequently,
    we’ll avoid having multiple `setTimeouts` clamoring for processing power, and
    the animation should run much more smoothly.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`jquery.fn.kaboom`中，我们将使用一个数组来存储当前正在爆炸的所有对象。每次调用`kaboom`时，我们将把调用的对象添加到这个数组中。当气泡移动完成后，它应该将自己从列表中移除。通过将所有我们想要移动的对象存储在一个数组中，我们可以运行一个单一的`setTimeout`循环，并同时更新所有下落气泡的位置。因此，我们将避免多个`setTimeout`竞争处理能力，动画也应该更加流畅。
- en: 'We’ll also add two more components: some default parameters for gravity and
    the distance we want a bubble to fall before we consider it off the screen and
    no longer part of the function.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加两个组件：一些默认的重力参数和我们希望气泡下落的距离，在此距离下我们会认为它已经不在屏幕上，不再是功能的一部分。
- en: '*jquery.kaboom.js*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*jquery.kaboom.js*'
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The default values are `gravity` and `maxY` ➊, and `toMove` ➋ will hold the
    falling jQuery objects.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值为`gravity`和`maxY` ➊，`toMove` ➋将保存下落的jQuery对象。
- en: 'At present, nothing happens when `kaboom` is called. The full `jquery.kaboom`
    plug-in follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，调用`kaboom`时不会发生任何事情。完整的`jquery.kaboom`插件如下：
- en: '*jquery.kaboom.js*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*jquery.kaboom.js*'
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Two main loops are in this plug-in: `jQuery.fn.kaboom` ➊, which adds new elements
    to the animation queue, and `moveAll` ➋, which handles the animation.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件中有两个主要的循环：`jQuery.fn.kaboom` ➊，用于将新元素添加到动画队列中，和`moveAll` ➋，用于处理动画。
- en: 'Let’s look at `jQuery.fn.kaboom` in more detail first:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先详细看看`jQuery.fn.kaboom`：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function initiates the animation process and is only called once per object
    (that is, it doesn’t run as part of an animation loop). The function then sets
    the config options ➊ for this call to `kaboom`. The syntax creates an object with
    defaults set in the parent definition (the `defaults` variable) and overrides
    these settings with any found in the object that’s been passed. It also adds any
    new name/value pairs to the object `kaboom` will act on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数启动动画过程，每个对象只会调用一次（也就是说，它不会作为动画循环的一部分运行）。然后，函数为此次`kaboom`调用设置配置选项➊。该语法创建一个对象，并在父定义中设置默认值（`defaults`变量），然后用传递的对象中的任何设置覆盖这些默认值。它还会将任何新的名称/值对添加到`kaboom`将要操作的对象中。
- en: We look in the array `toMove` and, if the array is empty ➋, set a timeout call
    that runs the animation. Next, values for the initial *x* and *y* velocities are
    set in `dx` and `dy` ➌. These values are between –5 and 5 pixels horizontally
    and between 5 and 10 pixels vertically (upward); both have units of pixels per
    second. We then add a new object to the `toMove` array ➍. The new object contains
    the jQuery element, its newly created velocity information, the current screen
    position, and the config options that were specified within this call.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看`toMove`数组，如果数组为空➋，就设置一个超时调用来运行动画。接着，在`dx`和`dy`中设置初始的*x*和*y*速度值➌。这些值在水平方向上介于–5和5像素之间，在垂直方向上（向上）介于5和10像素之间；两者的单位为每秒像素。然后，我们向`toMove`数组中添加一个新对象➍。新对象包含jQuery元素、它的新创建的速度信息、当前的屏幕位置，以及在此次调用中指定的配置选项。
- en: 'The `jQuery.fn.kaboom` function runs whenever a `$(...).kaboom` call is made.
    If at least one object is exploding, a timeout containing `moveAll` will be running.
    Let’s look at what the `moveAll` function does:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`jQuery.fn.kaboom`函数在每次调用`$(...).kaboom`时运行。如果至少有一个对象正在爆炸，包含`moveAll`的超时将持续运行。我们来看看`moveAll`函数的作用：'
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We assume that `setTimeout` is indeed running every 40 milliseconds because
    it’s the value we specify ➒; therefore, we count the frame rate as 25 per second
    ➊. If a computer is underpowered (or just busy using CPU cycles on another operation)
    and the delay between frames is much slower than 40 milliseconds, this assumption
    may result in a poor animation quality. Later, you’ll learn how to produce an
    animation at constant speed regardless of processor power, but the current solution
    provides the best compatibility in legacy browsers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设`setTimeout`每40毫秒确实运行一次，因为这是我们指定的值➒；因此，我们将帧率计算为每秒25帧➊。如果计算机性能不足（或者正在忙于使用CPU资源处理其他操作），并且帧之间的延迟远慢于40毫秒，那么这个假设可能会导致动画质量较差。稍后，你将学习如何在不受处理器性能影响的情况下保持动画速度恒定，但当前的解决方案在旧版浏览器中提供了最佳兼容性。
- en: After setting the frame rate, `moveAll` creates an empty array ➋ to store any
    objects that don’t move past the maximum value of *y* by the end of the animation
    frame. The resulting value here will become the new value for `toMove` to move
    again on the next frame.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置帧率后，`moveAll`创建一个空数组➋来存储那些在动画帧结束时没有超过最大*y*值的对象。这里得到的值将成为新的`toMove`值，用于在下一个帧继续移动。
- en: 'With the setup work done, `moveAll` loops ➌ over each element in the `toMove`
    array (that is, all the objects currently in the state of exploding; we populated
    this array in `jQuery.fn.kaboom`) and grabs a reference to each one in the `obj`
    variable, which is an object with the following properties:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 完成设置工作后，`moveAll`对`toMove`数组中的每个元素进行循环➌（即所有当前处于爆炸状态的对象；我们在`jQuery.fn.kaboom`中填充了这个数组），并获取每个元素的引用，将其存储在`obj`变量中，`obj`是一个具有以下属性的对象：
- en: '`obj.elm` pointing to the jQuery object'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj.elm`指向jQuery对象'
- en: '`dx` and `dy` velocity values'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dx`和`dy`速度值'
- en: '*x*- and *y*-coordinates storing the current position'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储当前位置信息的*x*和*y*坐标
- en: Inside the loop, we change the *x* and *y* values ➍ by a proportion of the object’s
    *x* and *y* velocities, respectively. This doesn’t affect the bubble’s screen
    position yet because we haven’t manipulated the DOM element. The function also
    adds the configured gravity setting to the object’s vertical velocity ➎. Horizontal
    velocity should remain constant throughout the explosion effect, but the object
    will accelerate downward to simulate falling. Next, we check ➏ to see if the object
    has a value of *y* that exceeds the maximum we either configured in defaults or
    overrode in the call to `kaboom`. If it doesn’t, the position of the screen element
    is set to the values stored for the current position, and we add the object to
    the `stillToMove` array. On the other hand, if the object *has* passed the maximum
    *y* and a callback function was passed as part of the original `kaboom` call,
    `moveAll` runs ➐ that function. It’s useful to pass a function into an animation
    and have that function run when the animation is complete.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，我们根据物体的*x*和*y*速度的比例分别改变*x*和*y*的值 ➍。这还不会影响气泡的屏幕位置，因为我们还没有操作DOM元素。该函数还将配置的重力设置添加到物体的垂直速度中
    ➎。水平速度应该在整个爆炸效果中保持不变，但物体会加速下落以模拟掉落。接下来，我们检查 ➏ 物体的*y*值是否超过了我们在默认设置中配置的最大值，或者在调用`kaboom`时覆盖的最大值。如果没有超过，屏幕元素的位置将设置为当前存储的位置，并将物体添加到`stillToMove`数组中。另一方面，如果物体*已经*超过了最大*y*值，并且在原始`kaboom`调用中传递了回调函数，`moveAll`会运行
    ➐ 该函数。将函数传入动画并在动画完成时运行该函数非常有用。
- en: Finally, we set the new value of `toMove` ➑ to be the contents of `stillToMove`
    (that is, all the objects that are still falling), and if the array contains at
    least one element, we set a timeout to call the same function again in another
    40 milliseconds ➒.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`toMove` ➑的新值设置为`stillToMove`的内容（也就是所有仍在下落的物体），如果数组中至少包含一个元素，我们将设置一个超时，在40毫秒后再次调用相同的函数➒。
- en: Now, when you reload the game and create an orphaned group of objects, the kaboom
    plug-in should make bubbles drop down the screen. Although it works within our
    game context, you could call it with any valid jQuery selector and produce a similar
    result. Keep the code handy so you can reuse the effect in future games!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你重新加载游戏并创建一个孤立的物体组时，kaboom插件应该会使气泡沿屏幕下落。虽然它在我们的游戏上下文中有效，但你也可以使用任何有效的jQuery选择器调用它，并产生类似的效果。保留这段代码，以便将来在其他游戏中复用这一效果！
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Quite a bit of *Bubble Shooter* is in place now. We can fire bubbles that either
    settle into the grid or pop groups, and we can detect orphaned groups and drop
    them off the screen. However, the board can get clogged with unpopped bubbles,
    and that’s a problem we still need to solve. Currently, there’s also no way to
    start another level or keep track of your score; both are important elements for
    this type of game. But before we complete some of the other game functionality,
    we’ll dive into some HTML5 and CSS implementations of the animations we’ve already
    written.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，*Bubble Shooter*的许多部分已经就绪。我们可以发射气泡，这些气泡要么会落入网格，要么会爆掉一组气泡，而且我们可以检测到孤立的气泡组并将其从屏幕上移除。然而，板块上可能会堆满未爆掉的气泡，这是我们仍然需要解决的问题。目前，游戏中也没有办法开始下一关或跟踪分数；这两个都是此类游戏中非常重要的元素。但在完成其他游戏功能之前，我们将深入探讨一些已经编写好的动画在HTML5和CSS中的实现。
- en: So far, we’ve achieved the features needed with some fairly traditional HTML,
    CSS, and JavaScript techniques. For the most part, the game should run smoothly
    on most computers. In the next chapter, we’ll improve performance by offloading
    some of the animation work from JavaScript to CSS. The shift will let us take
    advantage of hardware acceleration when possible, and we’ll even use some pure
    HTML5 features for smoother animation. We’ll also implement the entire game using
    `canvas` rendering rather than DOM and CSS, revealing the advantages and the challenges
    that result using that approach.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用一些相当传统的HTML、CSS和JavaScript技术实现了所需的功能。大部分情况下，这个游戏应该能在大多数计算机上顺利运行。在下一章，我们将通过将一些动画工作从JavaScript转移到CSS来提高性能。这一变化将让我们在可能的情况下利用硬件加速，并且我们还将使用一些纯HTML5特性来实现更流畅的动画。我们还将使用`canvas`渲染来实现整个游戏，而不是DOM和CSS，从而展示使用这种方法时的优势和挑战。
- en: Further Practice
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步练习
- en: In the exercises in [Chapter 3](ch03.html "Chapter 3. Game Logic"), you changed
    `createLayout` to generate alternative grid patterns. Test your layouts now with
    the popping and orphan-dropping code. Does the code work? How do your patterns
    affect the feel of the game?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [第3章](ch03.html "第3章 游戏逻辑")的练习中，你修改了 `createLayout` 以生成不同的网格模式。现在，使用气泡弹出和气泡掉落的代码来测试你的布局。代码是否能正常工作？你的布局模式如何影响游戏的感觉？
- en: Bubble animations currently consist of four frames. Create your own versions
    of the images and try adding more frames. Use a `for` loop to generate the extra
    `setTimeout` calls rather than copying and pasting new lines. Experiment with
    the timeout delays to speed up and slow down the animation and see which values
    produce the best effect.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前的气泡动画由四帧组成。创建你自己的图像版本，并尝试添加更多帧。使用 `for` 循环来生成额外的 `setTimeout` 调用，而不是复制粘贴新行。试验不同的超时延迟，调整动画的快慢，看看哪些值能产生最佳效果。
- en: The kaboom jQuery plug-in drops the bubbles off the bottom of the screen, but
    what would happen if you made the bubbles bounce when they hit the bottom? Amend
    *jquery.kaboom.js* so the bubbles bounce instead of drop off the screen. You’ll
    need to reverse their `dy` values and scale them down each time they bounce to
    mimic some of the bounce energy being absorbed; otherwise, they’ll just bounce
    back to the same height. The bubbles should be removed from the DOM only when
    they’ve bounced off either the left or the right edge of the screen, so you’ll
    also need to ensure that the value of `dx` isn’t close to zero, or they’ll never
    disappear.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: kaboom jQuery 插件将气泡从屏幕底部掉落，但如果你让气泡在撞到底部时反弹，会发生什么呢？修改 *jquery.kaboom.js* 代码，使气泡反弹而不是掉出屏幕。你需要反转它们的
    `dy` 值，并且在每次反弹时将它们缩小，以模拟一部分反弹能量被吸收；否则，它们会反弹回相同的高度。气泡只有在反弹到屏幕的左边或右边的边缘时才会从 DOM
    中移除，因此你还需要确保 `dx` 值不接近零，否则它们永远不会消失。
