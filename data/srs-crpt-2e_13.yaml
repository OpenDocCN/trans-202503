- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">HARD
    PROBLEMS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">难题</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Hard computational problems are the cornerstone of modern cryptography. These
    are problems for which even the best algorithm wouldn’t find a solution before
    the sun burns out.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 困难的计算问题是现代密码学的基石。这些问题即使是最好的算法，也无法在太阳燃尽之前找到解决方案。
- en: In the 1970s, the rigorous study of hard problems gave rise to a new field of
    science called *computational complexity theory*, which dramatically impacted
    cryptography and many other fields, including economics, physics, and biology.
    In this chapter, you’ll learn the conceptual tools from complexity theory necessary
    to understand the foundations of cryptographic security. I’ll also introduce the
    hard problems behind public-key schemes, such as RSA encryption and Diffie–Hellman
    key agreement. I’ll touch on some deep concepts, but I’ll minimize the technical
    details and scratch only the surface. Still, I hope you’ll see the beauty in how
    cryptography leverages computational complexity theory to maximize security assurance.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在1970年代，对困难问题的严格研究催生了一个新的科学领域——*计算复杂性理论*，它对密码学及许多其他领域（包括经济学、物理学和生物学）产生了深远影响。在本章中，你将学习理解密码学安全基础所必需的复杂性理论概念工具。我还将介绍公钥方案背后的难题，例如RSA加密和Diffie-Hellman密钥交换。我会涉及一些深奥的概念，但我会最小化技术细节，仅触及表面。尽管如此，我希望你能够看到密码学如何利用计算复杂性理论最大化安全保障的美妙之处。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Computational Hardness</samp>'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">计算困难性</samp>'
- en: A computational problem is a question that one can answer by doing enough computation—for
    example, “Is 217 a prime number?” or “How many *i*s are in *incomprehensibilities*?”
    The first question is a decision problem, because it can be answered with “yes”
    or “no,” while the second is a search problem.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 计算问题是一个通过足够的计算可以回答的问题——例如，“217是质数吗？”或“*incomprehensibilities*中有多少个*i*？”第一个问题是决策问题，因为它的答案只有“是”或“否”，而第二个问题则是搜索问题。
- en: '*Computational hardness* is the property of computational problems for which
    there is no algorithm that will run in a reasonable amount of time. Such problems
    are also called *intractable*. Computational hardness is independent of the type
    of computing device used, be it a general-purpose central processing unit (CPU),
    a graphics processing unit (GPU), an integrated circuit, or a mechanical Turing
    machine. Indeed, one of the first findings of computational complexity theory
    is that all computing models are equivalent. If one computing device can solve
    a problem efficiently, any other device can efficiently solve it by porting the
    algorithm to the other device’s language—an exception is quantum computers, which
    we’ll discuss in [Chapter 14](chapter14.xhtml). Thus, I won’t need to specify
    the underlying computing device or hardware when discussing computational hardness;
    instead, we’ll just discuss algorithms.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算困难性*是指那些没有可以在合理时间内运行的算法的计算问题。这类问题也被称为*难以处理的问题*。计算困难性与所使用的计算设备类型无关，无论是通用中央处理单元（CPU）、图形处理单元（GPU）、集成电路，还是机械图灵机。事实上，计算复杂性理论的初步发现之一是，所有计算模型都是等效的。如果某个计算设备能高效解决一个问题，任何其他设备通过将算法移植到其他设备的语言上也能高效解决该问题——量子计算机是个例外，我们将在[第14章](chapter14.xhtml)讨论它。
    因此，在讨论计算困难性时，我无需指定底层计算设备或硬件；我们只需要讨论算法。'
- en: To evaluate computational hardness, you first need a way to measure the complexity
    of an algorithm, or its running time. You then categorize running times as hard
    or easy.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估计算困难性，首先需要一种方法来衡量算法的复杂性，或者说其运行时间。然后你将运行时间分类为困难或容易。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running Time</samp>
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">运行时间</samp>
- en: The *computational complexity* of an algorithm is the approximate number of
    operations it does, as a function of its input size. You can count the size in
    bits or in the number of elements taken as input. For example, take the algorithm
    in [Listing 9-1](chapter9.xhtml#Lis9-1), written in pseudocode. It searches for
    a value, *x*, within an array of *n* elements and then returns its index position,
    or –1, if *x* isn’t found.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的*计算复杂度*是其执行的操作次数的近似值，作为输入大小的函数。你可以用比特数或作为输入的元素个数来衡量大小。例如，参考[Listing 9-1](chapter9.xhtml#Lis9-1)中的算法，它是用伪代码编写的。该算法在一个包含*n*个元素的数组中查找值*x*，并返回其索引位置，如果没有找到*x*，则返回-1。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-1: A simple search
    algorithm of complexity linear with respect to the array length</samp> <samp class="SANS_Futura_Std_Book_11">n</samp>'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-1: 一个复杂度与数组长度线性相关的简单搜索算法</samp>
    <samp class="SANS_Futura_Std_Book_11">n</samp>'
- en: This algorithm uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to find a specific value, *x*, in an array, iterating over values of the
    variable *i*, starting with 0\. It checks whether the value of position *i* in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> is equal to the value
    of *x*. If so, it returns the position *i*. Otherwise, it increments *i* and tries
    the next position until it reaches *n* – 1, the last position in the array, at
    which point it returns –1.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法使用一个<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环在数组中查找特定值*x*，它对变量*i*的值进行迭代，从0开始。它检查数组中位置*i*的值是否等于*x*。如果是，则返回位置*i*。否则，它会增加*i*并尝试下一个位置，直到达到*n*
    – 1，即数组中的最后一个位置，此时它返回-1。
- en: 'For this kind of algorithm, you count complexity as the number of iterations
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop: 1 in the
    best case (if *x* is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">array[0]</samp>),
    *n* in the worst case (if *x* is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">array[</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n -</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>]
    or if *x* isn’t found in <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>),
    and *n*/2 on average if *x* is uniformly randomly distributed in one of the *n*
    cells of the array. With an array 10 times as large, the algorithm will be 10
    times as slow. Complexity is therefore proportional to *n*, or “linear” in *n*.
    A complexity linear with respect to its input size is considered fast, as opposed
    to exponential complexities. In this example, although processing larger input
    values is slower, the computational cost won’t blow up exponentially but remains
    proportional to the table size.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种算法，你将复杂度定义为<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环的迭代次数：最好的情况为1（如果*x*等于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">array[0]</samp>），最坏的情况为*n*（如果*x*等于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">array[</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n
    -</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>]，或者如果*x*在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">array</samp>中找不到），平均情况下为*n*/2（如果*x*在*n*个数组元素中是均匀随机分布的）。对于一个大小是原数组10倍的数组，算法的速度会变慢10倍。因此，复杂度与*n*成正比，也就是*n*的“线性”复杂度。与输入大小成线性关系的复杂度被认为是快速的，不像指数级复杂度那样。虽然在这个例子中，处理更大输入值的速度变慢，但计算成本不会指数级地膨胀，而是与表格大小成正比。
- en: 'However, many useful algorithms are slower than that and have a complexity
    higher than linear. The textbook example is sorting algorithms: given a list of
    *n* values in a random order, you need in the worst case *n* × log *n* basic operations
    to sort the list, which is sometimes called *linearithmic complexity*. Since *n*
    × log *n* grows faster than *n*, sorting speed slows down faster than proportionally
    to *n*. Yet such sorting algorithms remain in the realm of *practical* computation,
    or computation that one can carry out in a reasonable amount of time.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多有用的算法比这更慢，且其复杂度高于线性。教科书中的例子是排序算法：给定一个随机顺序的*n*个值，最坏情况下你需要*n* × log *n* 次基本操作来排序该列表，这种复杂度有时被称为*线性对数复杂度*。由于*n*
    × log *n* 增长速度快于*n*，排序的速度减慢的比*n*增长得更快。然而，这种排序算法仍然属于*实用*计算的范畴，即在合理时间内可以完成的计算。
- en: 'What’s usually *not* reasonable are complexities exponential in the input size.
    At some point, you’ll hit the ceiling of what’s feasible even for relatively small
    input lengths. Take the simplest example from cryptanalysis: the brute-force search
    for a secret key. Recall from [Chapter 1](chapter1.xhtml) that given a plaintext
    *P* and a ciphertext *C* = **E**(*K*, *P*), it takes at most 2*^n* attempts to
    recover an *n*-bit symmetric key because there are 2*^n* possible keys—an example
    of a complexity that grows exponentially. A problem with *exponential complexity*
    is practically impossible to solve because as *n* grows, the effort rapidly becomes
    infeasible.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常*不*合理的是输入大小呈指数增长的复杂度。到了一定程度，即使对于相对较小的输入长度，你也会遇到不可行的上限。以密码分析中最简单的例子为例：暴力破解密钥。回想一下[第一章](chapter1.xhtml)中提到的，给定一个明文
    *P* 和密文 *C* = **E**(*K*, *P*)，恢复一个 *n* 位对称密钥最多需要 2*^n* 次尝试，因为有 2*^n* 个可能的密钥——这是一个复杂度呈指数增长的例子。一个具有*指数复杂度*的问题实际上是无法解决的，因为随着
    *n* 增长，计算量会迅速变得无法承受。
- en: 'You may object that we’re comparing oranges and apples here: in the <samp class="SANS_TheSansMonoCd_W5Regular_11">search()</samp>
    function in [Listing 9-1](chapter9.xhtml#Lis9-1), we counted the number of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if (array[i]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x)</samp> operations, whereas key
    recovery counts the number of encryptions, each thousands of times slower than
    a single <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> comparison. This
    seeming inconsistency can make a difference if you compare two algorithms with
    very similar complexities, but most of the time it won’t matter because the number
    of operations has a greater impact than the cost of an individual operation. Also,
    complexity estimates ignore *constant factors*: when we say that an algorithm
    takes time in the order of *n*³ operations (which is *cubic complexity*), it may
    actually take 41 × *n*³ operations, or even 12,345 × *n*³ operations—but again,
    as *n* grows, the constant factors lose significance to the point that you can
    ignore them. Complexity analysis is about theoretical hardness as a function of
    the input size; it doesn’t care about the exact number of CPU cycles it takes
    on your computer.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会反驳说我们这里在比较橙子和苹果：在[清单 9-1](chapter9.xhtml#Lis9-1)中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">search()</samp>
    函数中，我们计算了 <samp class="SANS_TheSansMonoCd_W5Regular_11">if (array[i]</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x)</samp>
    操作的次数，而密钥恢复计算的是加密操作的次数，每次加密的速度比单次 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    比较慢上千倍。这个看似的不一致，如果你比较两个复杂度非常相似的算法，可能会有所不同，但大多数情况下它并不重要，因为操作次数的影响比单个操作的成本更大。此外，复杂度估算忽略了*常数因子*：当我们说一个算法的时间复杂度是
    *n*³（即*立方复杂度*）时，它可能实际上需要 41 × *n*³ 次操作，甚至是 12,345 × *n*³ 次操作——但随着 *n* 增长，常数因子的影响变得不重要，甚至可以忽略。复杂度分析关注的是输入大小对理论难度的影响；它不关心你计算机上需要多少个
    CPU 周期。
- en: You can often use the *O*() notation (*big O*) to express complexities. For
    example, *O*(*n*³) means that complexity grows no faster than *n*³, ignoring potential
    constant factors. *O*() denotes the *upper bound* of an algorithm’s complexity.
    The notation *O*(1) means that an algorithm runs in *constant time* —that is,
    the running time doesn’t depend on the input length. For example, the algorithm
    that determines an integer’s parity by looking at its least significant bit (LSB)
    and returning “even” if it’s zero and “odd” otherwise will do the same thing at
    the same cost, whatever the integer’s length.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常可以使用 *O*() 符号（*大O*）来表示复杂度。例如，*O*(*n*³) 表示复杂度增长不会超过 *n*³，忽略潜在的常数因子。*O*() 表示算法复杂度的*上界*。*O*(1)
    表示一个算法运行在*常数时间*内——即运行时间与输入长度无关。例如，通过查看整数的最低有效位（LSB）并返回“偶数”如果为零，返回“奇数”否则，来确定整数的奇偶性，这个算法无论整数的长度如何，都会以相同的成本完成相同的操作。
- en: To see the difference between linear, quadratic, and exponential time complexities,
    look at how complexity grows for *O*(*n*) (linear) versus *O*(*n*²) (quadratic)
    versus *O*(2*^n*) (exponential) in [Figure 9-1](chapter9.xhtml#fig9-1).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看线性、二次和指数时间复杂度之间的差异，可以查看 [图 9-1](chapter9.xhtml#fig9-1) 中 *O*(*n*)（线性）、*O*(*n*²)（二次）和
    *O*(2*^n*)（指数）复杂度的增长情况。
- en: '![](../images/fig9-1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: The growth of exponential,
    quadratic, and linear complexities, from the fastest to the slowest growing</samp>'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-1：从最快到最慢增长的指数、二次和线性复杂度</samp>
- en: Exponential complexity means the problem is practically impossible to solve,
    and linear complexity means the solution is feasible, whereas quadratic complexity
    is somewhere between the two.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 指数复杂度意味着问题几乎不可能解决，线性复杂度意味着解决方案是可行的，而二次复杂度介于两者之间。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Polynomial vs. Superpolynomial
    Time</samp>
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">多项式时间与超多项式时间</samp>
- en: The quadratic *O*(*n*²) complexity (the middle curve in [Figure 9-1](chapter9.xhtml#fig9-1))
    is a special case of the broader class of polynomial complexities, or *O*(*n**^k*),
    where *k* is some fixed number such as 3, 2.373, 7/10, or the square root of 17\.
    Polynomial-time algorithms are eminently important in complexity theory and in
    cryptography because they’re the very definition of practically feasible. When
    an algorithm runs in *polynomial time*, or *polytime* for short, it completes
    in a decent amount of time even if the input is large. That’s why polynomial time
    is synonymous with “efficient” for complexity theorists and cryptographers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 二次 *O*(*n*²) 复杂度（[图9-1](chapter9.xhtml#fig9-1)中的中间曲线）是更广泛的多项式复杂度类 *O*(*n**^k*)
    的特例，其中 *k* 是一些固定的数值，比如 3、2.373、7/10 或者 17 的平方根。多项式时间算法在复杂度理论和密码学中非常重要，因为它们是实际可行性的定义。当一个算法在*多项式时间*内运行，简称*polytime*，即使输入很大，它也能在合理的时间内完成。这就是为什么对于复杂度理论家和密码学家来说，多项式时间就是“高效”的代名词。
- en: In contrast, you can view algorithms running in *superpolynomial time*—that
    is, in *O*(*f*(*n*)), where *f*(*n*) is any function that grows faster than any
    polynomial—as impractical. I’m saying superpolynomial, and not just exponential,
    because there are complexities in between polynomial and the well-known exponential
    complexity *O*(2*^n*), such as *O*(*n*^(log()*^n*^)), as [Figure 9-2](chapter9.xhtml#fig9-2)
    shows.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以将运行在*超多项式时间*下的算法视为不切实际的——即在*O*(*f*(*n*)), 其中 *f*(*n*) 是任何比任何多项式增长更快的函数——不切实际。我说的是超多项式时间，而不仅仅是指数时间，因为在多项式复杂度和著名的指数复杂度
    *O*(2*^n*) 之间，还有一些复杂度，例如 *O*(*n*^(log()*^n*^))，正如[图9-2](chapter9.xhtml#fig9-2)所示。
- en: '![](../images/fig9-2.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: The growth of the
    2</samp> <samp class="SANS_Futura_Std_Book_SUP_11">n</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,</samp>
    <samp class="SANS_Futura_Std_Book_11">n</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">log(</samp><samp
    class="SANS_Futura_Std_Book_SUP_11">n</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">)</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">, and</samp> <samp class="SANS_Futura_Std_Book_11">n</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">functions,
    from the fastest to the slowest growing</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-2：2</samp> <samp class="SANS_Futura_Std_Book_SUP_11">n</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">、</samp> <samp class="SANS_Futura_Std_Book_11">n</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">log(</samp><samp class="SANS_Futura_Std_Book_SUP_11">n</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">)</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">以及</samp>
    <samp class="SANS_Futura_Std_Book_11">n</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">²</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数，从最快到最慢增长</samp>
- en: '*O*(*n*²) or *O*(*n*³) may be efficient, but *O*(*n*^(99,999,999,999)) obviously
    isn’t. In other words, polytime is fast in practice as long as the exponent isn’t
    too large. Fortunately, all polynomial-time algorithms found to solve actual problems
    have small exponents. For example, *O*(*n*^(2.373)) is the time complexity of
    the best known algorithm for multiplying two *n* × *n* matrices in theory, as
    this algorithm is never used in practice. The 2002 breakthrough polytime deterministic
    algorithm for identifying *n*-bit prime numbers initially had a complexity *O*(*n*^(12)),
    but it was later improved to *O*(*n*⁶). Polynomial time thus may not be the perfect
    definition of a practical time for an algorithm, but it’s the best we have.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*O*(*n*²) 或 *O*(*n*³) 可能是高效的，但 *O*(*n*^(99,999,999,999)) 显然不是。换句话说，只要指数不太大，多项式时间在实际中是快速的。幸运的是，所有实际问题中找到的多项式时间算法都有较小的指数。例如，*O*(*n*^(2.373))
    是理论上已知的最佳 *n* × *n* 矩阵乘法算法的时间复杂度，但这个算法在实际中从未使用。2002年，突破性的多项式时间确定性算法首次用于识别 *n*
    位素数，初始复杂度为 *O*(*n*^(12))，但后来改进为 *O*(*n*⁶)。因此，多项式时间可能不是算法实际时间的完美定义，但它是我们目前最好的定义。'
- en: By extension, you can consider a problem that can’t be solved by a polynomial-time
    algorithm impractical, or *hard*. As an example, for a straightforward key search,
    there’s no way to beat the *O*(2*^n*) complexity unless the cipher is somehow
    broken.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展来看，你可以认为无法通过多项式时间算法解决的问题是不切实际的，或者是*困难*的。例如，对于一个简单的密钥搜索，除非加密算法被某种方式破解，否则无法突破
    *O*(2*^n*) 的复杂度。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Exponential complexity* O*(2*^n*) is not the worst you can get. Some complexities
    grow even faster and thus characterize algorithms even slower to compute—for example,
    the complexity* O*(*n^n*) or the* exponential factorial O*(*n*^(f()*^n *^(– 1))**),
    where for any* x*, the function* f *is here recursively defined as* f*(*x*) =*
    x*^(f()*^x *^(– 1))**. In practice, you’ll never encounter algorithms with such
    preposterous complexities.*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*指数复杂度* O*(2*^n*) 并不是你能遇到的最糟糕的复杂度。有些复杂度增长得更快，因此使得算法的计算速度更慢——例如，复杂度 O*(*n^n*)
    或 *指数阶乘 O*(*n*^(f()*^n *^(– 1))**)，其中对于任何* x*，函数* f *在此递归地定义为* f*(*x*) =* x*^(f()*^x
    *^(– 1))**。实际上，你几乎不可能遇到具有如此荒谬复杂度的算法。'
- en: You know that there’s no way to beat the *O*(2*^n*) complexity of a brute-force
    key search (as long as the cipher is secure), but you won’t always know the fastest
    way to solve a computational problem in general. A large portion of the research
    in complexity theory is about proving complexity *bounds* on the running time
    of algorithms solving a given problem. To make their job easier, complexity theorists
    have categorized computational problems in different groups, or *classes*, according
    to the effort needed to solve them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，对于一个蛮力密钥搜索算法，无法突破 *O*(2*^n*) 的复杂度（只要加密算法是安全的），但你并不总是能知道解决一般计算问题的最快方法。复杂度理论的大部分研究都集中在证明解决给定问题的算法的复杂度*界限*。为了让他们的工作更轻松，复杂度理论家将计算问题按解决它们所需的努力分成了不同的组，或者说是*类*。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Complexity Classes</samp>
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">复杂度类</samp>
- en: In mathematics, a *class* is a group of objects with some similar attribute.
    For example, all computational problems solvable in time *O*(*n*²), which complexity
    theorists simply denote **TIME**(*n*²), are one class. Likewise, **TIME**(*n*³)
    is the class of problems solvable in time *O*(*n*³), **TIME**(2*^n*) is the class
    of problems solvable in time *O*(2*^n*), and so on. For the same reason that a
    supercomputer can compute whatever a laptop can compute, any problem solvable
    in *O*(*n*²) is also solvable in *O*(*n*³). Hence, any problem in the class **TIME**(*n*²)
    also belongs to the class **TIME**(*n*³), which also both belong to the class
    **TIME**(*n*⁴), and so on. The union of all the classes **TIME**(*n**^k*), for
    all constants *k*, is **P**, which stands for polynomial time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，*类*是具有某些相似属性的一组对象。例如，所有在时间 *O*(*n*²) 内可以解决的计算问题，复杂度理论家简化地称为 **TIME**(*n*²)，就构成了一个类。同样，**TIME**(*n*³)
    是在时间 *O*(*n*³) 内可解决的问题类，**TIME**(2*^n*) 是在时间 *O*(2*^n*) 内可解决的问题类，以此类推。正如超级计算机可以计算任何笔记本电脑能计算的内容一样，任何在
    *O*(*n*²) 内可解的问题也可以在 *O*(*n*³) 内解决。因此，**TIME**(*n*²) 类中的任何问题也属于 **TIME**(*n*³)
    类，而这两个类也都属于 **TIME**(*n*⁴) 类，以此类推。所有类 **TIME**(*n**^k*), 对于所有常数 *k* 的并集是 **P**，表示多项式时间。
- en: If you’ve programmed a computer, you’ll know that seemingly fast algorithms
    may still crash your system by eating all its memory resources. When selecting
    an algorithm, you should consider not only its time complexity but also how much
    memory it uses, or its *space complexity*. This is especially important because
    a single memory access is usually orders of magnitudes slower than a basic arithmetic
    operation in a CPU.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写过计算机程序，你会知道看似快速的算法仍然可能通过耗尽所有内存资源而导致系统崩溃。在选择算法时，你不仅要考虑它的时间复杂度，还要考虑它使用的内存量，或者说它的*空间复杂度*。这尤其重要，因为一次内存访问通常比CPU中的基本算术操作慢几个数量级。
- en: Formally, you define an algorithm’s memory consumption as a function of its
    input length, *n*, in the same way you defined time complexity. The class of problems
    solvable using *f*(*n*) bits of memory is **SPACE**(*f*(*n*)). For example, **SPACE**(*n*³)
    is the class of problems solvable using of the order of *n*³ bits of memory. Just
    as you had **P** as the union of all **TIME**(*n**^k*), the union of all **SPACE**(*n**^k*)
    problems is **PSPACE**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正式地，你将算法的内存消耗定义为其输入长度*n*的函数，方法与时间复杂度的定义相同。使用*f*(*n*)位内存能够解决的问题类是**SPACE**(*f*(*n*)）。例如，**SPACE**(*n*³)是使用大约*n*³位内存可以解决的问题类。就像**P**是所有**TIME**(*n**^k*)的并集一样，所有**SPACE**(*n**^k*)问题的并集是**PSPACE**。
- en: While the lower the memory the better, a polynomial amount of memory doesn’t
    necessarily imply that an algorithm is practical. Take, for example, a brute-force
    key search, which takes negligible memory but is slow as hell. More generally,
    an algorithm can take forever, even if it uses just a few bytes of memory.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然内存越少越好，但多项式数量级的内存并不一定意味着一个算法是实用的。以暴力穷举密钥搜索为例，虽然它几乎不消耗内存，但却极其缓慢。更一般地说，即使一个算法只使用很少的内存，它也可能需要永远运行。
- en: Any problem solvable in time *f*(*n*) needs at most *f*(*n*) memory, so **TIME**(*f*(*n*))
    is included in **SPACE**(*f*(*n*)). In time *f*(*n*), you can write up to *f*(*n*)
    bits, and no more, because writing (or reading) 1 bit is assumed to take one unit
    of time; therefore, any problem in **TIME**(*f*(*n*)) can’t use more than *f*(*n*)
    space. As a consequence, **P** is a subset of **PSPACE**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 任何能够在时间*f*(*n*)内解决的问题，最多需要*f*(*n*)的内存，因此**TIME**(*f*(*n*))包含在**SPACE**(*f*(*n*)）中。在时间*f*(*n*)内，你可以写入最多*f*(*n*)位数据，不能再多，因为写入（或读取）1位被假设为需要一个单位的时间；因此，任何**TIME**(*f*(*n*))中的问题不能使用超过*f*(*n*)的空间。因此，**P**是**PSPACE**的子集。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nondeterministic
    Polynomial Time</samp>
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">非确定性多项式时间</samp>
- en: '**NP**, *nondeterministic* polynomial time, is the second most important complexity
    class, after the class **P** of all polynomial-time algorithms.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**NP**，即*非确定性*多项式时间，是第二重要的复杂度类，仅次于**P**类（所有多项式时间算法类）。'
- en: '**NP** is the class of decision problems for which you can verify a solution
    in polynomial time—that is, efficiently—even though the solution may be hard to
    find. By *verified*, I mean that given a potential solution, you can run some
    polynomial-time algorithm that checks whether you’ve found an actual solution.
    For example, the problem of deciding whether there exists a key *K* such that
    *C* = **E**(*K*, *P*) given *P* and *C* for a symmetric cryptosystem **E** is
    in **NP**. This is because given a candidate key *K*[0], you can check that *K*[0]
    is the correct key by verifying that **E**(*K*[0], *P*) equals *C*. You can’t
    find a potential key (the solution), if it exists, in polynomial time, but you
    can check whether a key is correct.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**NP**是决策问题的类，对于这些问题，你可以在多项式时间内验证一个解——也就是说，高效地验证——尽管该解可能很难找到。所谓的*验证*是指，给定一个潜在解，你可以运行某个多项式时间的算法来检查你是否找到了一个实际的解。例如，判断是否存在一个密钥*K*，使得*P*和*C*在对称加密系统**E**下满足*C*
    = **E**(*K*, *P*)的问题属于**NP**类。这是因为，给定一个候选密钥*K*[0]，你可以通过验证**E**(*K*[0], *P*)是否等于*C*来检查*K*[0]是否是正确的密钥。你不能在多项式时间内找到潜在密钥（如果存在的话），但你可以检查一个密钥是否正确。'
- en: 'Now for a counterexample: What about known-ciphertext attacks? This time, you
    get only some **E**(*K*, *P*) values for random unknown plaintext *P*s. If you
    don’t know what the *P*s are, then there’s no way to verify whether a potential
    key, *K*[0], is the right one. In other words, the key-recovery problem under
    known-ciphertext attacks is not in **NP** (let alone in **P**), as you can’t express
    it as a decision problem.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看一个反例：已知密文攻击怎么样？这次，你只能得到一些**E**(*K*, *P*)的值，其中*P*是随机的未知明文。如果你不知道*P*是什么，那么就无法验证一个潜在的密钥*K*[0]是否正确。换句话说，在已知密文攻击下，密钥恢复问题不在**NP**类中（更不用说在**P**类中了），因为你无法将其表示为一个决策问题。
- en: Another example of a problem not in **NP** is that of verifying the *absence*
    of a solution to a problem. Verifying that a solution is correct boils down to
    computing some algorithm with the candidate solution as an input and then checking
    the return value. However, to verify that *no* solution exists, you may need to
    go through all possible inputs. If there’s an exponential number of inputs, you
    won’t be able to efficiently prove that no solution exists. The absence of a solution
    is hard to show for the hardest problems in the class **NP**—the so-called **NP**-complete
    problems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不在**NP**中的问题是验证一个问题**无解**。验证一个解是否正确归结为计算某个算法，将候选解作为输入，然后检查返回值。然而，要验证**没有解**，你可能需要遍历所有可能的输入。如果输入数量是指数级的，你将无法高效地证明没有解存在。对于**NP**类中最难的问题——所谓的**NP**-完全问题来说，证明没有解是很困难的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NP-Complete Problems</samp>
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NP-完全问题</samp>
- en: '***NP****-complete* problems are the hardest decision problems in the class
    **NP**; you won’t know how to solve the worst-case instances of these problems
    in polynomial time. As complexity theorists discovered in the 1970s when they
    developed the theory of **NP**-completeness, **NP**’s hardest problems are all
    fundamentally equally hard. This was proven by showing that you can turn any efficient
    solution to any of the **NP**-complete problems into an efficient solution for
    any of the other **NP**-complete problems. In other words, if you can solve any
    **NP**-complete problem efficiently, you can solve all of them, as well as all
    problems in **NP**. How can this be?'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '***NP****-完全*问题是**NP**类中最难的决策问题；你无法在多项式时间内解决这些问题的最坏情况实例。正如复杂性理论学者在1970年代发展**NP**-完全性理论时发现的那样，**NP**中最难的问题本质上是同样困难的。通过展示你可以将任何**NP**-完全问题的有效解决方案转化为另一个**NP**-完全问题的有效解决方案，证明了这一点。换句话说，如果你能够高效地解决任何**NP**-完全问题，你就能解决所有问题，包括**NP**中的所有问题。这是怎么回事呢？'
- en: '**NP**-complete problems come in different guises, but they’re fundamentally
    similar from a mathematical perspective. In fact, you can reduce any **NP**-complete
    problem to any other **NP**-complete problem such that the capability to solve
    the second implies the capability to solve the first. Remember that **NP** contains
    decision problems, not search problems. You can efficiently transform an algorithm
    able to solve a search problem into an algorithm able to solve the corresponding
    decision problem, though the converse direction is not always possible. Fortunately,
    this is the case for NP-complete problems, which explains why people often mix
    up the two.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**NP**- 完全问题有不同的表现形式，但从数学角度来看它们本质上是相似的。实际上，你可以将任何**NP**-完全问题转化为另一个**NP**-完全问题，且解决第二个问题的能力意味着能够解决第一个问题。记住，**NP**包含的是决策问题，而不是搜索问题。你可以高效地将一个能够解决搜索问题的算法转化为能够解决相应决策问题的算法，尽管反方向并不总是可能的。幸运的是，对于NP-完全问题来说，这种转化是可行的，这也解释了为什么人们常常将这两者混淆。'
- en: 'Here are some examples of **NP**-complete problems:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些**NP**-完全问题的例子：
- en: '**The traveling salesman problem **Given a set of points on a map (such as
    cities) with the distances between each point from each other point and given
    a maximum distance *x*, decide whether there is a path that visits every point
    such that the total distance is smaller than *x*. (Note that you can find such
    a path with essentially the same complexity as the decision problem, but deciding
    whether a path is optimal is not in **NP**, because you can’t efficiently verify
    a solution’s correctness.)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**旅行商问题** 给定一组地图上的点（如城市）以及每个点之间的距离，并给定一个最大距离 *x*，决定是否存在一条路径能够访问每个点，并且总距离小于
    *x*。（注意，你可以以基本相同的复杂度找到这样一条路径，作为决策问题，但判断路径是否最优并不在**NP**中，因为你不能高效地验证一个解的正确性。）'
- en: '**The clique problem **Given a number, *x*, and a graph (a set of nodes connected
    by edges, as in [Figure 9-3](chapter9.xhtml#fig9-3)), determine whether there’s
    a set of at most *x* nodes that are all connected to each other.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**团问题** 给定一个数字 *x* 和一个图（一个由边连接的节点集合，如[图9-3](chapter9.xhtml#fig9-3)所示），判断是否存在一个最多包含
    *x* 个节点的集合，这些节点之间都是相互连接的。'
- en: '![](../images/fig9-3.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: A graph containing
    a clique of four nodes. The general problem of finding a clique (set of nodes
    all connected to each other) of a given size in a graph is</samp> <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">NP</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">-complete.</samp>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-3：包含四个节点的团体的图形。给定大小的团体（所有节点都互相连接）的查找问题是</samp>
    <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">NP</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">-完全问题。</samp>
- en: '**The knapsack problem **Given two numbers, *x* and *y*, and a set of items,
    each of a known value and weight, decide if there is a group of items such that
    the total value is at least *x* and the total weight is at most *y.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**背包问题**给定两个数字，*x*和*y*，以及一组物品，每个物品都有已知的价值和重量，决定是否存在一组物品，使得总价值至少为*x*，并且总重量不超过*y*。'
- en: You can find such **NP**-complete problems everywhere, from scheduling (given
    jobs of some priority and duration and one or more processors, assign jobs to
    the processors by respecting the priority while minimizing total execution time)
    to constraint-satisfaction (determine values that satisfy a set of mathematical
    constraints, such as logical equations). Even the task of winning certain video
    games was proven to be **NP**-hard (for famous games including *Tetris*, *Super
    Mario Bros.*, *Pokémon*, and *Candy Crush Saga*). For example, the article “Classic
    Nintendo Games are (Computationally) Hard” considers “the decision problem of
    reachability” to determine the possibility of reaching the goal point from a particular
    starting point (*[https://<wbr>arxiv<wbr>.org<wbr>/abs<wbr>/1203<wbr>.1895](https://arxiv.org/abs/1203.1895)*).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在许多地方找到这样的**NP**-完全问题，从调度问题（给定一些优先级和持续时间的任务，以及一个或多个处理器，按照优先级将任务分配给处理器，同时最小化总执行时间）到约束满足问题（确定满足一组数学约束的值，如逻辑方程）。甚至某些视频游戏的获胜任务也被证明是**NP**-难题（包括*俄罗斯方块*、*超级马里奥*、*口袋妖怪*和*糖果传奇*等著名游戏）。例如，文章《经典任天堂游戏是（计算上）困难的》探讨了“可达性决策问题”，以确定从某个特定起点到达目标点的可能性（*
    [https://<wbr>arxiv<wbr>.org<wbr>/abs<wbr>/1203<wbr>.1895](https://arxiv.org/abs/1203.1895)
    *）。
- en: Some of these video game problems are at least as hard as **NP**-complete problems
    and are called **NP**-*hard*. A (not necessarily decisional) problem is **NP**-hard
    when it’s at least as hard as **NP**-complete (decision) problems and if any method
    to solve it can be efficiently used to solve **NP**-complete problems.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些视频游戏问题至少与**NP**-完全问题一样困难，称为**NP**-*难*。当一个（不一定是可判定的）问题至少与**NP**-完全（决策）问题一样困难，并且任何解决该问题的方法都可以高效地用于解决**NP**-完全问题时，该问题被称为**NP**-难问题。
- en: '**NP**-complete problems must be decisional problems; that is, problems with
    a yes or no answer. Therefore, strictly speaking, problems of computing the “best”
    value of a solution cannot be **NP**-complete but may be **NP**-hard. For example,
    take the traveling salesman problem: the problem “Is there a path visiting all
    points with a distance less than *X*?” is **NP**-complete, whereas “Find the faster
    path visiting all points” is **NP**-hard.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**NP**-完全问题必须是可判定问题；也就是说，问题的答案必须是“是”或“否”。因此，严格来说，计算解决方案“最佳”值的问题不能是**NP**-完全问题，但可以是**NP**-难题。例如，考虑旅行商问题：问题“是否存在一条路径，经过所有点，且距离小于*X*？”是**NP**-完全问题，而“找到一条更快的路径，经过所有点”是**NP**-难题。'
- en: Note that not all *instances* of **NP**-hard problems are actually hard to solve.
    You may be able to efficiently solve some instances because they’re small or have
    a specific structure. Take, for example, the graph in [Figure 9-3](chapter9.xhtml#fig9-3).
    You can quickly spot the clique, which is the top four connected nodes—even though
    the aforementioned clique-finding problem is **NP**-hard, there’s nothing hard
    here. Being **NP**-hard doesn’t mean that all instances of a given problem are
    hard but that as the problem size grows, some of them are. This is why cryptographers
    are more interested in problems that are hard on average, not just in the worst
    case.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有**NP**-难问题的*实例*都难以解决。你可能能够高效地解决某些实例，因为它们很小或具有特定结构。例如，考虑[图9-3](chapter9.xhtml#fig9-3)中的图形。你可以快速找到其中的团体，也就是顶部的四个连接节点——尽管前述的团体查找问题是**NP**-难题，但这里并没有什么难度。**NP**-难并不意味着给定问题的所有实例都很难，而是随着问题规模的增长，其中一些实例变得更难。这就是为什么密码学家更关心那些在平均情况下很难解决的问题，而不仅仅是最坏情况下的问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The P vs. NP Problem</samp>
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">P与NP问题</samp>
- en: 'If you could solve the hardest **NP** problems in polynomial time, then you
    could solve *all* **NP** problems in polynomial time, and therefore **NP** would
    equal **P**. Such an equality sounds preposterous: Aren’t there problems for which
    a solution is easy to verify but hard to find? For example, isn’t it obvious that
    exponential-time brute force is the fastest way to recover the key of a symmetric
    cipher, and therefore that the problem can’t be in **P**?'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够在多项式时间内解决最难的**NP**问题，那么你就能够在多项式时间内解决*所有*的**NP**问题，因此**NP**将等于**P**。这样的等式听起来荒谬：难道不是有些问题，解法很容易验证，但却很难找到吗？例如，难道不显而易见，指数时间的暴力破解是恢复对称密码密钥最快的方法，因此这个问题不可能属于**P**吗？
- en: 'As crazy as it sounds, no one has proved that **P** is different from **NP**,
    despite a bounty of $1 million. The Clay Mathematics Institute will award this
    to anyone who proves that either **P** ≠ **NP** or **P** = **NP**. This problem,
    known as **P** vs. **NP**, was called “one of the deepest questions that human
    beings have ever asked” by renowned complexity theorist Scott Aaronson. Think
    about it: if **P** were equal to **NP**, then any easily checked solution would
    also be easy to find. All cryptography used in practice would be insecure because
    you could recover symmetric keys and invert hash functions efficiently.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管听起来疯狂，但至今没有人证明**P**与**NP**不同，尽管有100万美元的奖金。克雷数学研究所将奖励任何证明**P** ≠ **NP**或**P**
    = **NP**的人。这个问题，称为**P**与**NP**问题，被著名的复杂性理论学家Scott Aaronson称为“人类曾经提出的最深刻的问题之一”。想一想：如果**P**等于**NP**，那么任何容易验证的解法也会很容易找到。所有实践中使用的加密技术都将不再安全，因为你可以高效地恢复对称密钥并反转哈希函数。
- en: 'But don’t panic: most complexity theorists believe **P** isn’t equal to **NP**
    and therefore that **P** is instead a strict subset of **NP**, as [Figure 9-4](chapter9.xhtml#fig9-4)
    shows, where **NP**-complete problems are another subset of **NP** not overlapping
    with **P**. In other words, problems that look hard actually are hard. It’s just
    difficult to prove this mathematically. While proving that **P** = **NP** requires
    only a polynomial-time algorithm for an **NP**-complete problem, proving the nonexistence
    of such an algorithm is fundamentally harder. This didn’t stop mathematicians
    from coming up with simple proofs that, while usually obviously wrong, often make
    for funny reads; for an example, see “The P-versus-NP page” (*[https://<wbr>www<wbr>.win<wbr>.tue<wbr>.nl<wbr>/~wscor<wbr>/woeginger<wbr>/P<wbr>-versus<wbr>-NP<wbr>.htm](https://www.win.tue.nl/~wscor/woeginger/P-versus-NP.htm)*).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但别惊慌：大多数复杂性理论学家认为**P**不等于**NP**，因此**P**是**NP**的一个严格子集，正如[图 9-4](chapter9.xhtml#fig9-4)所示，**NP**-完全问题是**NP**的另一个子集，与**P**没有交集。换句话说，看起来困难的问题实际上确实是困难的，只是很难用数学证明这一点。虽然证明**P**
    = **NP**只需要为一个**NP**-完全问题提供一个多项式时间算法，但证明不存在这样的算法则要困难得多。尽管如此，这并没有阻止数学家们提出一些简单的证明，虽然通常显然是错误的，但却往往很有趣；例如，可以参考“P与NP页面”（*
    [https://www.win.tue.nl/~wscor/woeginger/P-versus-NP.htm](https://www.win.tue.nl/~wscor/woeginger/P-versus-NP.htm)
    *）。
- en: '![](../images/fig9-4.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4: The classes</samp>
    <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">NP</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp>
    <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">P</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and
    the set of</samp> <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">NP</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">-complete problems</samp>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-4: 类别</samp> <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">NP</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp> <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">P</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">以及</samp> <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">NP</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">-完全问题的集合</samp>'
- en: 'If we’re almost sure that hard problems exist in **NP**, what about leveraging
    them to build strong, provably secure crypto? Imagine a proof that breaking some
    cipher is **NP**-hard and therefore that the cipher is unbreakable as long as
    **P** isn’t equal to **NP**. But reality is disappointing: the search versions
    of **NP**-complete problems have proved difficult to use for crypto purposes because
    the very structure that makes them hard in the worst case can make them easy in
    specific cases that sometimes occur in crypto. Instead, cryptography often relies
    on problems that are *probably not* **NP**-hard.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们几乎可以确定**NP**中存在困难问题，那么如何利用它们来构建强大的、可证明安全的加密呢？想象一下，如果我们能证明破解某些密码是**NP**-难的，因此，只要**P**不等于**NP**，该密码就是不可破解的。但现实令人失望：**NP**-完全问题的搜索版本已证明在加密中难以使用，因为正是这种使它们在最坏情况下变得困难的结构，有时会在加密中出现特定的情况，从而使得它们变得容易。相反，密码学通常依赖于那些*可能不是***NP**-难的问题。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Factoring Problem</samp>
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">因式分解问题</samp>
- en: 'The factoring problem consists of finding the prime numbers *p* and *q* given
    a large number, *N* = *p* × *q*. The widely used RSA algorithms are based on the
    difficulty of factoring: RSA encryption and signature schemes are secure because
    factoring is a hard problem. Before we see how RSA leverages the factoring problem
    in [Chapter 10](chapter10.xhtml), I’d like to convince you that the decision version
    of this problem (“Does *N* have a factor smaller than *k* that is not equal to
    1?”) is indeed hard yet probably not **NP**-complete.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因式分解问题的任务是，给定一个大数*N* = *p* × *q*，找出质数*p*和*q*。广泛使用的RSA算法正是基于因式分解的困难：RSA加密和签名方案是安全的，因为因式分解是一个困难的问题。在我们了解RSA如何在[第10章](chapter10.xhtml)中利用因式分解问题之前，我想说服你，关于该问题的判定版本（“*N*是否有一个小于*k*且不等于1的因子？”）确实是困难的，但可能不是**NP**-完全的。
- en: First, some basic math. A *prime number* isn’t divisible by any other number
    but itself and 1\. For example, the numbers 3, 7, and 11 are prime; the numbers
    4 (that is, 2 × 2), 6 (2 × 3), and 12 (2 × 2 × 3) are not. A fundamental theorem
    of number theory says that you can write any integer number uniquely as a product
    of primes, a representation called the *factorization* of that number. For example,
    the factorization of 123,456 is 2⁶ × 3 × 643, the factorization of 1,234,567 is
    127 × 9,721, and so on. Any integer has a unique factorization, or a unique way
    to write it as a product of prime numbers. Polynomial-time primality testing algorithms
    allow us to efficiently test whether a given number is prime or a given factorization
    contains only prime numbers. Getting from a number to its prime factors, however,
    is another matter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一些基本的数学知识。*质数*不能被任何其他数字整除，除了它本身和1。例如，3、7和11是质数；而4（即2 × 2）、6（2 × 3）和12（2 ×
    2 × 3）则不是。数论的一个基本定理表明，你可以将任何整数唯一地表示为质数的乘积，这种表示方式称为该数的*因式分解*。例如，123,456的因式分解是2⁶
    × 3 × 643，1,234,567的因式分解是127 × 9,721，等等。任何整数都有一个唯一的因式分解，或者说，唯一的方式将其表示为质数的乘积。多项式时间质数测试算法使我们能够高效地测试一个给定的数字是否是质数，或者一个给定的因式分解是否仅包含质数。然而，从一个数字得到它的质因数，则是另一个问题。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Factoring Large
    Numbers</samp>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">因式分解大数</samp>'
- en: So how do you go from a number to its factorization—namely, its decomposition
    as a product of prime numbers? The most basic way to factor a number, *N*, is
    to try dividing it by all the numbers lower than it until you find a number, *x*,
    that divides *N*. Then attempt to divide *N* with the next number, *x* + 1, and
    so on. You’ll end up with a list of factors of *N*. What’s the time complexity
    of this? First, remember that we express complexities as a function of the input’s
    *length*. The bit length of the number *N* is *n* = log[2] *N*. By definition
    of the logarithm, this means that *N* = 2*^n*. Because all the numbers less than
    *N*/2 are reasonable guesses for possible factors of *N*, there are about *N/*2
    = 2*^n*/2 values to try. The complexity of our naive factoring algorithm is therefore
    *O*(2*^n*), ignoring the 1/2 coefficient in the *O*() notation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何从一个数字得到它的因式分解——也就是将它分解成质数的乘积呢？分解一个数字*N*的最基本方法是尝试用所有比它小的数字去除，直到找到一个数字*x*，它能整除*N*。然后尝试用下一个数字*x*
    + 1去除*N*，以此类推。最终你会得到*N*的因子列表。那么，这种方法的时间复杂度是多少呢？首先，记住我们将复杂度表示为输入*长度*的函数。数字*N*的比特长度是*n*
    = log[2] *N*。根据对数的定义，这意味着*N* = 2*^n*。因为所有小于*N*/2的数字都是*N*的可能因子，因此我们需要尝试大约*N*/2
    = 2*^n*/2个值。因此，我们的朴素因式分解算法的复杂度是*O*(2*^n*)，忽略了*O*()符号中的1/2系数。
- en: While many numbers are easy to factor by first finding any small factors (2,
    3, 5, and so on) and then iteratively factoring any other nonprime factors, here
    we’re interested in numbers of the form *N* = *p* × *q*, where *p* and *q* are
    large, as found in cryptography.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多数字通过首先找到任何小因子（2、3、5等）并且迭代地分解其他非质数因子很容易，但在这里我们关注的是形如*N* = *p* × *q*的数字，其中*p*和*q*较大，这在密码学中很常见。
- en: 'Let’s be a bit smarter: as we don’t need to test all numbers lower than *N*/2,
    but rather only the prime numbers, we can start by trying those smaller than the
    square root of *N*. If *N* isn’t a prime number, then it must have at least one
    factor lower than its square root √*N.* This is because if both of *N*’s factors
    *p* and *q* were greater than √*N*, then their product would be greater than √*N*
    × √*N* = *N*, which is impossible. For example, if *N* = 100, its factors *p*
    and *q* can’t both be greater than 10 because that would result in a product greater
    than 100\. Either *p* or *q* has to be less than or equal to √*N*.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更聪明一点：因为我们不需要测试所有小于*N*/2的数字，而只需要测试小于*N*平方根的质数，因此我们可以从小于*N*平方根的质数开始。如果*N*不是质数，那么它至少有一个小于它平方根√*N*的因子。这是因为如果*N*的两个因子*p*和*q*都大于√*N*，那么它们的乘积将大于√*N*
    × √*N* = *N*，这显然是不可能的。例如，如果*N* = 100，它的因子*p*和*q*不可能都大于10，因为那样它们的乘积会大于100。*p*或*q*必须小于或等于√*N*。
- en: So what’s the complexity of testing only the primes less than √*N*? The *prime
    number theorem* states that there are approximately *N*/log *N* primes smaller
    than *N*. Hence, there are approximately √*N*/log √*N* primes smaller than √*N*.
    Expressing this value in terms of *n* = log[2] *N*, we get approximately 2*^n*^(/2
    + 1)/*n* possible prime factors and therefore a complexity of *O*(2*^n*^(/2)/*n*),
    since √*N* = 2*^n*^(/2) and 1/log √*N* = 1/(*n*/2) = 2/*n*. This is faster than
    testing all prime numbers, but it’s still painfully slow—on the order of 2^(120)
    operations for a 256-bit number. That’s quite an impractical computational effort.
    But we can do much better.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，测试所有小于√*N*的质数的复杂度是多少呢？*质数定理*指出，小于*N*的质数大约有*N*/log *N*个。因此，小于√*N*的质数大约有√*N*/log
    √*N*个。将这个值用*n* = log[2] *N*表示，我们得到大约2*^n*^(/2 + 1)/*n*个可能的质因子，因此复杂度为*O*(2*^n*^(/2)/*n*)，因为√*N*
    = 2*^n*^(/2)，而1/log √*N* = 1/(*n*/2) = 2/*n*。这比测试所有质数要快，但仍然非常慢——对于一个256位的数字来说，大约需要2^(120)次操作。这是一个相当不切实际的计算量。不过，我们可以做得更好。
- en: 'The fastest factoring algorithm is the *general number field sieve (GNFS)*,
    which I won’t describe here because it requires the introduction of several advanced
    mathematical concepts. A rough estimate of GNFS’s complexity is exp(1.91 × *n*^(1/3)
    (log *n*)^(2/3)), where *n* = log[2] *N* is the bit length of *N* and exp(. .
    .) is just a different notation for the exponential function *e* *^x*, with *e*
    the exponential constant approximately equal to 2.718\. However, it’s difficult
    to get an accurate estimate of GNFS’s actual complexity for a given number size.
    Therefore, we must rely on heuristic complexity estimates, which show how security
    increases with a longer *n*. For example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最快的分解算法是*通用数域筛法（GNFS）*，我在这里不做描述，因为它需要引入几个高级数学概念。GNFS的复杂度粗略估算为exp(1.91 × *n*^(1/3)
    (log *n*)^(2/3))，其中*n* = log[2] *N*是*N*的位长，exp(. . .)只是指数函数*e* *^x*的另一种表示方式，其中*e*是大约等于2.718的指数常数。然而，确切估算GNFS在特定数字大小下的实际复杂度是困难的。因此，我们必须依赖启发式复杂度估算，显示随着*n*值的增加，安全性如何提升。例如：
- en: Factoring a **1,024-bit** number, which has two prime factors of approximately
    500 bits each, takes on the order of 2^(70) basic operations.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解一个**1,024位**的数字，该数字有两个大约为500位的素因子，需要进行大约2^(70)次基本操作。
- en: Factoring a **2,048-bit** number, which has two prime factors of approximately
    1,000 bits each, takes on the order of 2^(90) basic operations—about a million
    times slower than for a 1,024-bit number.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解一个**2,048位**的数字，该数字有两个大约为1,000位的素因子，需要进行大约2^(90)次基本操作——比分解1,024位数字慢约一百万倍。
- en: 'You can estimate that reaching 128-bit security requires at least 4,096 bits.
    Take these values with a grain of salt, as researchers don’t always agree on these
    estimates. The following experimental results reveal the actual cost of factoring:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以估算，达到128位安全性至少需要4,096位。请对这些值持保留态度，因为研究人员对这些估算并不总是达成一致。以下实验结果揭示了分解的实际成本：
- en: In 2005, after about 18 months of computation—and thanks to the power of a cluster
    of 80 processors, with a total effort equivalent to 75 years of computation on
    a single processor—a group of researchers factored a **663-bit** (200-decimal
    digit) number.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2005年，在大约18个月的计算之后——得益于一个由80个处理器组成的计算集群，总计算量相当于单个处理器上75年的计算——一组研究人员分解了一个**663位**（200位十进制数字）数字。
- en: In 2009, after about two years and using several hundred processors, with a
    total effort equivalent to about 2,000 years of computation on a single processor,
    another group of researchers factored a **768-bit** (232-decimal digit) number.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2009年，在大约两年的时间里，使用数百个处理器，总计算量相当于单个处理器上约2,000年的计算，另一个研究小组分解了一个**768位**（232位十进制数字）数字。
- en: In 2020, after a few months of computation, using tens of thousands of processors
    and a supercomputer, for a total effort equivalent to around 2,700 years of calculation
    on a single processor, another team factored an **829-bit** (250-decimal digit)
    number.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2020年，在几个月的计算之后，使用了数万个处理器和一台超级计算机，总计算量相当于单个处理器上约2,700年的计算，另一个团队分解了一个**829位**（250位十进制数字）数字。
- en: As you can see, the numbers factored by researchers are shorter than those in
    real applications, which are at least 1,024-bit and often more than 2,048-bit.
    As I write this, no one has reported the factoring of a 1,024-bit number, but
    many speculate that well-funded organizations such as the NSA can do it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，研究人员分解的数字比实际应用中的数字要短，实际应用中的数字至少是1,024位，通常超过2,048位。就我所写的内容来看，目前没有人报告过分解1,024位数字的情况，但许多人猜测像NSA这样资金充裕的组织可能已经做到了。
- en: In sum, you should view 1,024-bit RSA as insecure and use RSA with at least
    a 2,048-bit value, but preferably a 4,096-bit one to ensure higher security.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你应该将1,024位的RSA视为不安全的，并使用至少2,048位的RSA，但最好使用4,096位的RSA以确保更高的安全性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Factoring Is Probably
    Not NP-Hard</samp>
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">分解问题可能不是NP难的</samp>
- en: We don’t know how to factor large numbers efficiently, which suggests that the
    factoring problem doesn’t belong to **P**. However, the decision version of factoring
    is clearly in **NP**, because given a factorization, we can verify the solution
    by checking that all factors are prime numbers, thanks to the aforementioned primality
    testing algorithm, and that when multiplied together, the factors give the expected
    number. For example, to check that 3 × 5 is the factorization of 15, confirm that
    both 3 and 5 are prime and that 3 times 5 equals 15.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道如何高效地分解大数，这表明分解问题不属于**P**类。然而，分解问题的决策版本显然属于**NP**类，因为给定一个因式分解结果，我们可以通过检查所有因子是否为质数来验证答案，感谢前述的质数测试算法，并且当这些因子相乘时，它们的乘积等于预期的数值。例如，要检查3
    × 5是否是15的因式分解，只需确认3和5都是质数，并且3乘以5等于15。
- en: 'So we have a problem that is in **NP** and that looks hard, but is it as hard
    as the hardest **NP** problems? In other words, is the decision version of factoring
    **NP**-complete, and as a consequence, is factoring **NP**-hard? Spoiler alert:
    probably not.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有一个**NP**类中的问题，看起来很困难，但它真的有**NP**最困难的问题那么难吗？换句话说，分解问题的决策版本是否是**NP**-完全的，因此，分解问题是否是**NP**-困难的？剧透：可能不是。
- en: There’s no mathematical proof that factoring isn’t **NP**-hard, but we have
    a few pieces of soft evidence. First, all known **NP**-hard problems in **NP**
    can have one solution, more than one solution, or no solution at all. In contrast,
    factoring always has exactly one solution. Also, the factoring problem has a mathematical
    structure that allows for the GNFS algorithm to significantly outperform a naive
    algorithm, a structure that **NP**-hard problems don’t have. Factoring would be
    easy with a *quantum computer*, a computing model that exploits quantum mechanical
    phenomena to run different kinds of algorithms and that would have the capability
    to factor large numbers efficiently (not because it’d run the algorithm faster
    but because it could run a quantum algorithm dedicated to factoring large numbers).
    Such a quantum computer doesn’t exist yet, though—and might never. Regardless,
    a quantum computer is believed to be useless in tackling **NP**-hard problems
    because it’d be no faster than a classical one (see [Chapter 14](chapter14.xhtml)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有数学证明表明分解问题不是**NP**-困难的，但我们有一些间接证据。首先，所有已知的**NP**-困难问题在**NP**类中可能有一个解、多个解或没有解。而分解问题始终只有一个解。此外，分解问题具有数学结构，使得GNFS算法能够显著超越朴素算法，而**NP**-困难问题并不具备这样的结构。使用*量子计算机*解决分解问题将变得简单，量子计算机是一种利用量子力学现象运行各种算法的计算模型，具有高效分解大数的能力（不是因为它能更快地运行算法，而是因为它能运行专门用于分解大数的量子算法）。然而，这种量子计算机目前尚不存在——而且可能永远也不会存在。不管怎样，人们认为量子计算机在解决**NP**-困难问题上是无用的，因为它的速度不会比经典计算机快（见[第14章](chapter14.xhtml)）。
- en: Factoring may be slightly easier than solving **NP**-hard problems in theory,
    but as far as cryptography is concerned, it’s hard enough, and even more reliable
    than **NP**-hard problems. Indeed, it’s easier to build cryptosystems on top of
    the factoring problem than search versions of **NP**-complete problems because
    it’s difficult to know exactly how hard it is to break a cryptosystem based on
    such problems—in other words, how many bits of security you’d get. As mentioned
    earlier, this relates to the fact that **NP** concerns worst-case hardness, and
    cryptographers are looking for average-case hardness.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，分解问题可能比解决**NP**-困难问题稍微简单一些，但就密码学而言，它足够困难，而且比**NP**-困难问题更可靠。事实上，基于分解问题构建密码系统比基于**NP**-完全问题的搜索版本更容易，因为很难确切知道破解基于此类问题的密码系统到底有多难——换句话说，你能获得多少位的安全性。如前所述，这与**NP**关心最坏情况的困难度，而密码学家们关注的是平均情况的困难度相关。
- en: The factoring problem is one of several problems you can use in cryptography
    as a *hardness assumption*, which is an assumption that some problem is computationally
    hard. You can use this assumption when proving that breaking a cryptosystem’s
    security is at least as hard as solving said problem. Another problem you can
    use as a hardness assumption, the *discrete logarithm problem (DLP)*, is actually
    a family of problems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 分解问题是你可以在密码学中使用的多个*难度假设*之一，难度假设是指某个问题在计算上是困难的。你可以在证明打破密码系统安全性至少和解决该问题一样困难时使用这个假设。另一个你可以用作难度假设的问题是*离散对数问题（DLP）*，它实际上是一个问题族。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Discrete Logarithm Problem</samp>
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">离散对数问题</samp>
- en: The Discrete Logarithm Problem (DLP) predates the factoring problem in the official
    history of cryptography. Whereas RSA appeared in 1977, another cryptographic breakthrough,
    the Diffie–Hellman key agreement (see [Chapter 11](chapter11.xhtml)), came about
    a year earlier, grounding its security on the hardness of the DLP. Like the factoring
    problem, the DLP deals with large numbers, but it’s less straightforward and requires
    more math than factoring. Let’s begin by introducing the mathematical notion of
    a group in the context of discrete logarithms.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 离散对数问题（DLP）早于因数分解问题出现在密码学的官方历史中。尽管RSA算法出现在1977年，但另一个密码学突破——Diffie–Hellman密钥交换协议（见[第11章](chapter11.xhtml)）大约在一年前就已出现，其安全性依赖于DLP的难解性。与因数分解问题类似，DLP也涉及大数，但它比因数分解问题更复杂，需要更多的数学知识。让我们从在离散对数背景下引入群的数学概念开始。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Groups</samp>
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">群</samp>
- en: In a mathematical context, a *group* is a set of elements (typically, numbers)
    that relate to each other according to certain well-defined rules. An example
    of a group is the set of nonzero integers modulo a prime number *p* (that is,
    numbers between 1 and *p* – 1) with modular multiplication being the group operation.
    We note such a group as (**Z**p^*, ×), or just **Z**p^* when it’s clear that the
    group operation is multiplication.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，*群*是一个元素的集合（通常是数字），这些元素根据某些明确定义的规则相互关联。群的一个例子是非零整数模素数*p*的集合（即1到*p*–1之间的数字），其群运算是模乘法。我们将这样的群记作（**Z**p^*,
    ×），或者在群运算明确为乘法时简写为**Z**p^*。
- en: For *p* = 5, you get the group **Z**[5]^* = {1, 2, 3, 4}. In the group **Z**[5]^*,
    operations are carried out modulo 5; hence, you don’t have 3 × 4 = 12 but instead
    3 × 4 = 2, because 12 mod 5 = 2\. You can nonetheless use the same sign (×) that
    you use for normal integer multiplication. You can also use the exponent notation
    to denote a group element’s multiplication with itself mod *p*, a common operation
    in cryptography. For example, in the context of **Z**[5]^*, 2³ = 2 × 2 × 2 = 3
    rather than 8, because 8 mod 5 is equal to 3.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*p* = 5，得到群**Z**[5]^* = {1, 2, 3, 4}。在群**Z**[5]^*中，运算是模5进行的；因此，3 × 4 ≠ 12，而是3
    × 4 = 2，因为12 mod 5 = 2。你仍然可以使用常规整数乘法中使用的符号（×）。你还可以使用指数表示法来表示群元素与自身的乘法模*p*，这是密码学中常见的运算。例如，在**Z**[5]^*中，2³
    = 2 × 2 × 2 = 3，而不是8，因为8 mod 5 = 3。
- en: 'To be a group, a mathematical set and its operation must have the following
    characteristics, which are called *group axioms*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为一个群，数学集合及其运算必须具备以下特征，这些特征被称为*群公理*：
- en: '**Closure **For any two group elements *x* and *y*, *x* × *y* is in the group
    too. In **Z**[5]^*, 2 × 3 = 1 (because 6 = 1 mod 5), 2 × 4 = 3, and so on.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**封闭性 **对于任何两个群元素*x*和*y*，*x* × *y*也在该群中。在**Z**[5]^*中，2 × 3 = 1（因为6 = 1 mod
    5），2 × 4 = 3，等等。'
- en: '**Associativity **For any group elements *x*, *y*, *z*, (*x* × *y*) × *z* =
    *x* × (*y* × *z*). In **Z**[5]^*, (2 × 3) × 4 = 1 × 4 = 2 × (3 × 4) = 2 × 2 =
    4.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**结合性 **对于任何群元素*x*、*y*、*z*，(*x* × *y*) × *z* = *x* × (*y* × *z*)。在**Z**[5]^*中，(2
    × 3) × 4 = 1 × 4 = 2 × (3 × 4) = 2 × 2 = 4。'
- en: '**Identity existence **The group includes an element *e* such that *e* × *x*
    = *x* × *e* = *x*. Such an element is called the *identity*. In any **Z**p^*,
    the identity element is 1.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**单位元存在 **群中包含一个元素*e*，使得*e* × *x* = *x* × *e* = *x*。这样的元素称为*单位元*。在任何**Z**p^*中，单位元是1。'
- en: '**Inverse existence **For any *x* in the group, there’s a *y* such that *x*
    × *y* = *y* × *x* = *e*. In **Z**[5]^*, the inverse of 2 is 3, and the inverse
    of 3 is 2, while 4 is its own inverse because 4 × 4 = 16 = 1 mod 5.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**逆元存在 **对群中的任何*x*，存在一个*y*使得*x* × *y* = *y* × *x* = *e*。在**Z**[5]^*中，2的逆元是3，3的逆元是2，而4是它自身的逆元，因为4
    × 4 = 16 = 1 mod 5。'
- en: 'In addition, a group is *commutative*, or *abelian*, if *x* × *y* = *y* × *x*
    for any group elements *x* and *y*. That’s also true for any multiplicative group
    of integers **Z**p^*. In particular, **Z**[5]^* is commutative: 3 × 4 = 4 × 3,
    2 × 3 = 3 × 2, and so on.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果群是*交换的*或*阿贝尔的*，即对任何群元素*x*和*y*都有*x* × *y* = *y* × *x*，那么该群是交换群。对于任何整数乘法群**Z**p^*，这一点也成立。特别地，**Z**[5]^*是交换的：3
    × 4 = 4 × 3，2 × 3 = 3 × 2，依此类推。
- en: A group is *cyclic* if there’s at least one element *g* such that its powers
    (*g*¹, *g*², *g*³, and so on) mod *p* span all distinct group elements. The element
    *g* is then a *generator* of the group. **Z**[5]^* is cyclic and has two generators,
    2 and 3, because 2¹ = 2, 2² = 4, 2³ = 3, 2⁴ = 1, and 3¹ = 3, 3² = 4, 3³ = 2, 3⁴
    = 1.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在至少一个元素 *g*，使得它的幂次（*g*¹、*g*²、*g*³ 等）对 *p* 取模后能够覆盖所有不同的群元素，那么该群就是*循环*的。此时，元素
    *g* 被称为该群的*生成元*。**Z**[5]^* 是循环群，并且有两个生成元，2 和 3，因为 2¹ = 2，2² = 4，2³ = 3，2⁴ = 1，3¹
    = 3，3² = 4，3³ = 2，3⁴ = 1。
- en: 'Note that I’m using multiplication as a group operator, but you can also get
    groups from other operators. For example, the most straightforward group is the
    set of all integers, positive and negative, with addition as a group operation.
    Let’s check that the group axioms hold with addition, in the preceding order:
    the number *x* + *y* is an integer if *x* and *y* are integers (closure); (*x*
    + *y*) + *z* = *x* + (*y* + *z*) for any *x*, *y*, and *z* (associativity); zero
    is the identity element; and the inverse of any number *x* in the group is –*x*
    because *x* + (–*x*) = 0 for any integer *x*. A big difference, though, is that
    this group of integers is of infinite size, whereas in crypto you’ll deal with
    only *finite groups*, or groups with a finite number of elements, for implementation
    reasons. Typically, you’ll use groups **Z**p^*, where *p* is *thousands* of bits
    long (that is, groups that contain on the order of 2*^m* numbers if *p* is *m*-bit
    long).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我这里使用的是乘法作为群运算符，但你也可以使用其他运算符来构造群。例如，最简单的群是所有整数的集合，包括正整数和负整数，以加法作为群运算。让我们检查加法是否满足群公理，按以下顺序：*x*
    + *y* 是整数，如果 *x* 和 *y* 是整数（封闭性）；(*x* + *y*) + *z* = *x* + (*y* + *z*)，对任意 *x*、*y*
    和 *z* 都成立（结合性）；零是单位元素；群中任何数字 *x* 的逆元素是 –*x*，因为 *x* + (–*x*) = 0，对任何整数 *x* 都成立。然而，一个很大的不同是，这个整数群是无限大的，而在密码学中，你只会处理*有限群*，即包含有限个元素的群，这是出于实现的考虑。通常，你会使用群
    **Z**p^*，其中 *p* 是*成千上万*比特长的（也就是说，如果 *p* 是 *m* 比特长的，则该群包含大约 2*^m* 个数字）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Hard Thing</samp>
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">困难之处</samp>
- en: The discrete logarithm problem as initially used in cryptography consists of
    finding the *y* for which *g**^y* = *x*, given a generator *g* within some group
    **Z**p^*, where *p* is a prime number, and given a group element *y*. We often
    express the DLP in additive rather than multiplicative notation, as in groups
    of elliptic curves. In this case, the problem is to find the multiplicative factor
    *k* such that *k* × *P* = *Q*, where you know the points *P* and *Q*. This is
    called the *elliptic curve DLP (ECDLP)*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最初在密码学中使用的离散对数问题是寻找 *y*，使得 *g**^y* = *x*，已知生成元 *g* 位于某个群 **Z**p^* 中，其中 *p* 是素数，已知群元素
    *y*。我们通常以加法而非乘法表示 DLP，如椭圆曲线群中的情况。在这种情况下，问题是找到乘法因子 *k*，使得 *k* × *P* = *Q*，其中已知点
    *P* 和 *Q*。这被称为*椭圆曲线离散对数问题（ECDLP）*。
- en: The DLP is *discrete* because you’re dealing with countable integers as opposed
    to uncountable real numbers, and it’s a *logarithm* because you’re looking for
    the logarithm of *x* in base *g*. For example, the logarithm of 256 in base two
    is 8 because 2⁸ = 256.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: DLP 是*离散*的，因为你处理的是可数的整数，而不是不可数的实数，并且它是*对数*问题，因为你要找的是以 *g* 为底的 *x* 的对数。例如，256
    以二为底的对数是 8，因为 2⁸ = 256。
- en: Factoring is about as equally hard, thus as secure, as a discrete logarithm.
    In fact, algorithms to solve DLP bear similarities with those factoring integers,
    and you get about the same security level with *n*-bit hard-to-factor numbers
    as with discrete logarithms in an *n*-bit group. For the same reason as factoring,
    DLP isn’t **NP**-hard. (There are certain groups where the DLP is easier to solve,
    but these aren’t used in cryptography, at least not where DLP hardness is needed.)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因式分解的难度与离散对数问题差不多，因此它们的安全性也相似。事实上，解决 DLP 的算法与因式分解整数的算法有相似之处，处理 *n* 比特的难以因式分解的数字与在
    *n* 比特群中求离散对数的安全级别差不多。与因式分解一样，DLP 并不是 **NP**-困难问题。（有一些群，在这些群中，DLP 更容易解决，但它们在密码学中不会使用，至少在需要
    DLP 难度的地方不会使用。）
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">事情如何出错</samp>
- en: More than 40 years later, we still don’t know how to efficiently factor large
    numbers or solve discrete logarithms. In the absence of mathematical proof, it’s
    always possible to speculate that they’ll be broken one day. But we also don’t
    have proof that **P** ≠ **NP**, so you can speculate that **P** may be equal to
    **NP**; however, according to experts, that surprise is unlikely. Most public-key
    crypto deployed today relies on either factoring (RSA) or DLP (Diffie–Hellman,
    ElGamal, elliptic curve cryptography). Although math may not fail us, real-world
    concerns and human error can sneak in.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 40 多年后，我们仍然不知道如何有效地分解大数或解决离散对数问题。在没有数学证明的情况下，总是可以猜测它们有一天会被破解。但我们也没有证明 **P**
    ≠ **NP**，因此你可以猜测 **P** 可能等于 **NP**；然而，根据专家的看法，这个惊讶的可能性不大。目前大多数公共密钥加密系统依赖于分解（RSA）或
    DLP（迪菲-赫尔曼，ElGamal，椭圆曲线密码学）。虽然数学可能不会失败，但现实世界的问题和人为错误可能会悄悄地潜入。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">When Factoring Is
    Easy</samp>
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">当分解变得容易时</samp>
- en: 'Factoring large numbers isn’t always hard. For example, take the following
    1,024-bit number *N*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 分解大数并不总是困难的。例如，考虑以下 1,024 位的数字 *N*：
- en: '![](../images/pg191-1.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg191-1.jpg)'
- en: 'For 1,024-bit numbers in RSA encryption or signature schemes where *N* = *pq*,
    we expect the best factoring algorithms to need around 2^(70) operations, as we
    discussed earlier. But you can factor this sample number in seconds using SageMath,
    a piece of Python-based mathematical software. Using SageMath’s <samp class="SANS_TheSansMonoCd_W5Regular_11">factor()</samp>
    function on my 2023 MacBook, it took less than a second to find the following
    factorization:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在 RSA 加密或签名方案中使用的 1,024 位数字，其中 *N* = *pq*，我们预期最佳的分解算法大约需要 2^(70) 次操作，正如我们之前讨论的那样。但你可以使用
    SageMath 这个基于 Python 的数学软件，在几秒钟内分解这个示例数字。在我的 2023 年款 MacBook 上，使用 SageMath 的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">factor()</samp> 函数，不到一秒钟就找到了以下的分解：
- en: '![](../images/pg191-2.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg191-2.jpg)'
- en: Right, I cheated. This number isn’t of the form *N* = *pq* because it doesn’t
    have just two large prime factors but rather five, including very small ones,
    which makes it easy to factor. First, you identify the 2^(800) × 641 × 6,700,417
    part by trying small primes from a precomputed list of prime numbers, which leaves
    you with a 192-bit number that’s much easier to factor than a 1,024-bit number
    with two large factors.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对，我作弊了。这个数字不是 *N* = *pq* 的形式，因为它不仅有两个大素数因子，而是有五个，包括一些非常小的因子，这使得它很容易分解。首先，你通过尝试一个预先计算好的素数列表中的小素数，识别出
    2^(800) × 641 × 6,700,417 这一部分，剩下的就是一个 192 位的数字，比一个有两个大因子的 1,024 位数字更容易分解。
- en: Factoring can be easy not only when *n* has small prime factors but also when
    *N* or its factors *p* and *q* have particular forms—for example, when *N* = *pq*
    with *p* and *q* both close to some 2*^b*, when *N* = *pq* and some bits of *p*
    or *q* are known, or when *N* is of the form *N* = *p**^r**q**^s* and *r* is greater
    than log *p*. However, detailing the reasons for these weaknesses is too technical
    for this book.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 分解不仅仅在 *n* 有小素数因子的情况下容易，*N* 或其因子 *p* 和 *q* 也有特定形式时也可能容易——例如，当 *N* = *pq*，并且
    *p* 和 *q* 都接近某个 2*^b* 时，当 *N* = *pq* 且 *p* 或 *q* 的某些位已知时，或者当 *N* 的形式是 *N* = *p**^r**q**^s*
    且 *r* 大于 log *p* 时。然而，详细阐述这些弱点的原因对于本书来说过于技术化。
- en: The upshot is that the RSA encryption and signature algorithms (see [Chapter
    10](chapter10.xhtml)) need to work with a value of *N* = *pq*, where *p* and *q*
    are carefully chosen, to avoid easy factorization of *N*, which can result in
    a security disaster.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，RSA 加密和签名算法（见 [第10章](chapter10.xhtml)）需要使用 *N* = *pq* 的值，其中 *p* 和 *q* 必须精心选择，以避免
    *N* 的简单分解，这可能会导致安全灾难。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Small Hard Problems
    Aren’t Hard</samp>
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">小的难题并不难</samp>
- en: Computationally hard problems, and even exponential-time algorithms, become
    practical when they’re small enough. A symmetric cipher may be secure in the sense
    that there’s no faster attack than the 2*^n*-time brute force, but if the key
    length is *n* = 32, you’ll break the cipher in minutes. This sounds obvious, and
    you’d think that no one would be naive enough to use small keys, but in reality,
    there are plenty of reasons why this could happen. The following are two true
    stories.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 计算上困难的问题，甚至是指数时间的算法，当它们足够小的时候也能变得实用。对称加密可能在某种意义上是安全的，因为没有比 2*^n* 次暴力破解更快的攻击，但如果密钥长度是
    *n* = 32，你将在几分钟内破解这个加密。这听起来很显然，你可能会认为没有人会天真到使用小密钥，但实际上，确实有很多原因可能导致这种情况。以下是两个真实的故事。
- en: Say you’re a developer who knows nothing about crypto but has some API to encrypt
    with RSA and has been told to encrypt with 128-bit security. What RSA key size
    would you pick? I’ve seen real cases of 128-bit RSA, or RSA based on a 128-bit
    number *N* = *pq*. However, although factoring is impractically hard for an *N*
    thousands of bits long, factoring a 128-bit number is easy. Using the SageMath
    software, the commands in [Listing 9-2](chapter9.xhtml#Lis9-2) complete instantaneously.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一个对加密一无所知的开发者，但你有一些API可以用RSA进行加密，而且被要求使用128位安全性进行加密。你会选择什么样的RSA密钥大小？我见过真实案例中使用128位RSA，或者基于128位数字*N*
    = *pq*的RSA。然而，虽然对一个长度达到几千位的*N*进行因式分解几乎是不可能的，但对128位数字进行因式分解却很容易。使用SageMath软件，[列表9-2](chapter9.xhtml#Lis9-2)中的命令几乎可以瞬间完成。
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-2: Generating an
    RSA modulus by picking two random prime numbers and factoring it instantaneously</samp>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表9-2：通过选择两个随机质数生成RSA模数，并即时进行因式分解</samp>
- en: '[Listing 9-2](chapter9.xhtml#Lis9-2) shows that you can easily factor a 128-bit
    number taken randomly as the product of two 64-bit prime numbers on a typical
    laptop. However, if I chose 1,024-bit prime numbers instead by using <samp class="SANS_TheSansMonoCd_W5Regular_11">p
    = random _prime(2**1024)</samp>, the command <samp class="SANS_TheSansMonoCd_W5Regular_11">factor(p*q)</samp>
    would never complete, at least not in my lifetime.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表9-2](chapter9.xhtml#Lis9-2)显示了你可以轻松地将一个128位数字随机作为两个64位质数的乘积进行因式分解，且这一过程在典型的笔记本电脑上几乎瞬间完成。然而，如果我选择使用1,024位质数，通过命令<samp
    class="SANS_TheSansMonoCd_W5Regular_11">p = random _prime(2**1024)</samp>，则命令<samp
    class="SANS_TheSansMonoCd_W5Regular_11">factor(p*q)</samp>将永远无法完成，至少在我有生之年是如此。'
- en: To be fair, the tools available don’t help prevent the naive use of insecurely
    short parameters. For example, the OpenSSL toolkit used to let you generate RSA
    keys as short as 31 bits without any warning; such short keys are totally insecure,
    as [Listing 9-3](chapter9.xhtml#Lis9-3) shows. OpenSSL has since been fixed, and
    its version 1.1.1t (from February 2023) returns an error “key size too small”
    if you request a key shorter than 512 bits.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，现有的工具并不能有效防止天真的使用不安全的短参数。例如，OpenSSL工具包曾允许你生成短至31位的RSA密钥，且没有任何警告；这些短密钥是完全不安全的，如[列表9-3](chapter9.xhtml#Lis9-3)所示。OpenSSL后来已修复，在其2023年2月发布的版本1.1.1t中，如果你请求一个小于512位的密钥，会返回“密钥大小太小”的错误。
- en: '[PRE2]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-3: Generating an
    insecure RSA private key using an older version of the OpenSSL toolkit</samp>'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表9-3：使用旧版本的OpenSSL工具包生成不安全的RSA私钥</samp>
- en: When reviewing cryptography, you should check not only the type of algorithms
    used but also their parameters and the length of their secret values. However,
    as you’ll see in the following story, what’s secure enough today may be insecure
    tomorrow.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查密码学时，你不仅要检查所使用的算法类型，还要检查它们的参数以及它们的秘密值的长度。然而，正如你将在接下来的故事中看到的那样，今天足够安全的东西明天可能就不再安全了。
- en: In 2015, researchers discovered that many HTTPS servers and email servers supported
    an older, insecure version of the Diffie–Hellman key agreement protocol. Namely,
    the underlying TLS implementation supported Diffie–Hellman within a group, **Z**p^*,
    defined by a prime number, *p*, of only 512 bits, where the discrete logarithm
    problem was no longer practically impossible to compute.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，研究人员发现许多HTTPS服务器和邮件服务器支持一个旧版本的不安全的Diffie–Hellman密钥交换协议。具体来说，底层的TLS实现支持在一个由一个512位质数*p*定义的组**Z**p^*中使用Diffie–Hellman，其中离散对数问题已经不再是不可计算的。
- en: Not only did servers support a weak algorithm, but also attackers could force
    a benign client to use that algorithm by injecting malicious traffic within the
    client’s session. Even better for attackers, the largest part of the attack could
    be carried out once and recycled to attack multiple clients. After about a week
    of computations to attack a specific group, **Z**p^*, it took only 70 seconds
    to break individual sessions of different users.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器不仅支持了一个弱算法，攻击者还可以通过在客户端会话中注入恶意流量，迫使一个无害的客户端使用这个算法。更糟糕的是，对于攻击者来说，攻击的最大部分可以一次性执行并循环使用，以攻击多个客户端。在对特定群体进行大约一周的计算后，**Z**p^*，破解不同用户的单独会话仅需70秒。
- en: A secure protocol is worthless if it’s undermined by a weakened algorithm, and
    a reliable algorithm is useless if sabotaged by weak parameters. In cryptography,
    you should always read the fine print.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安全协议被一个弱化的算法削弱，那么它是毫无价值的；如果一个可靠的算法被弱参数破坏，那么它也是无用的。在密码学中，你应该始终注意细节。
- en: 'For more details about this story, check the research article “Imperfect Forward
    Secrecy: How Diffie–Hellman Fails in Practice” (*[https://<wbr>weakdh<wbr>.org<wbr>/imperfect<wbr>-forward<wbr>-secrecy<wbr>-ccs15<wbr>.pdf](https://weakdh.org/imperfect-forward-secrecy-ccs15.pdf)*).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此故事的更多细节，请查看研究文章《不完美的前向保密：Diffie–Hellman在实践中的失败》 (*[https://weakdh.org/imperfect-forward-secrecy-ccs15.pdf](https://weakdh.org/imperfect-forward-secrecy-ccs15.pdf)*)。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">进一步阅读</samp>
- en: I encourage you to look deeper into the foundational aspects of computation
    in the context of computability (what functions can be computed?) and complexity
    (at what cost?) and how they relate to cryptography. I’ve talked mostly about
    the classes **P** and **NP**, but there are many more classes and points of interest
    for cryptographers. I highly recommend the book *Quantum Computing Since Democritus*
    by Scott Aaronson (Cambridge University Press, 2013). It’s in large part about
    quantum computing, but its first chapters brilliantly introduce complexity theory
    and cryptography.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你深入探讨计算理论中的基础内容，尤其是在可计算性（什么函数可以计算？）和复杂性（以什么代价？）的背景下，以及它们如何与密码学相关。我主要讲解了**P**和**NP**类问题，但对于密码学家来说，还有许多其他类和有趣的研究点。我强烈推荐Scott
    Aaronson的《自德谟克里特以来的量子计算》（剑桥大学出版社，2013年）。这本书大部分内容讲的是量子计算，但其前几章巧妙地介绍了复杂性理论和密码学。
- en: 'In the cryptography research literature, you’ll find other hard computational
    problems. I’ll mention them in later chapters, but here are some examples that
    illustrate the diversity of problems leveraged by cryptographers:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学研究文献中，你会找到其他困难的计算问题。我将在后续章节中提到这些问题，但这里有一些例子，展示了密码学家利用的各种问题：
- en: The Diffie–Hellman problem (given *g**^x* and *g* *^y*, find *g**^(xy)*) is
    a variant of the discrete logarithm problem and is widely used in key agreement
    protocols.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Diffie–Hellman问题（给定 *g**^x* 和 *g* *^y*，求 *g**^(xy)*) 是离散对数问题的一种变体，广泛应用于密钥协议中。
- en: Lattice problems, such as the shortest vector problem (SVP) as well as the short
    integer solutions (SIS) and learning with errors (LWE) problems, can be **NP**-hard,
    depending on their parameters.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格问题，如最短向量问题（SVP）、短整数解问题（SIS）以及带错误学习问题（LWE），根据其参数的不同，可能是**NP**-困难的。
- en: Coding problems rely on the hardness of decoding error-correcting codes with
    insufficient information and have been studied since the late 1970s. These can
    also be **NP**-hard.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码问题依赖于解码错误纠正码的困难性，通常信息不足，并且自1970年代末以来就一直是研究的课题。这些问题也可能是**NP**-困难的。
- en: Multivariate problems are about solving nonlinear systems of equations and are
    potentially **NP**-hard, but they’ve failed to provide reliable cryptosystems
    because hard versions are too big and slow, and practical versions were found
    to be insecure.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多变量问题是指求解非线性方程组的问题，可能是**NP**-困难的，但它们未能提供可靠的密码系统，因为困难版本的规模过大且速度过慢，且实际应用的版本被发现不安全。
- en: In [Chapter 10](chapter10.xhtml), we’ll continue exploring hard problems, especially
    factoring and its main variant, the RSA problem.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](chapter10.xhtml)中，我们将继续探讨困难问题，特别是因式分解及其主要变体——RSA问题。
