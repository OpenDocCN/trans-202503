- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 10 PERSISTENCE ENUMERATOR
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10 持久化枚举器
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'In early 2014, a close friend begged me for help disinfecting his Mac. When
    I plopped myself in front of his screen, I saw obvious signs of a rampant adware
    infection: flagrant browser pop-ups, as well as a hijacked home page. Even worse,
    resetting his browser didn’t work; it reverted to its infected state upon each
    reboot, suggesting the presence of a persistent component buried somewhere deep
    within the system.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 2014 年初，一位亲密的朋友请求我帮忙清除他 Mac 上的病毒。当我坐到他屏幕前时，我看到明显的广告软件感染迹象：大量的浏览器弹窗，以及被劫持的首页。更糟糕的是，重置浏览器并不起作用；每次重启后，浏览器都会恢复到感染状态，这表明系统中有一个持久化组件深藏其中。
- en: At the time, I was an experienced Windows malware analyst just beginning my
    foray into the world of macOS. Naively, I thought I could download a tool capable
    of enumerating all persistent software installed on the system to reveal the malicious
    component. Well-known security tools, such as Microsoft’s AutoRuns,^([1](#chapter10-1))
    provided such a capability for Windows systems, but I soon discovered nothing
    similar existed for Macs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，我是一名经验丰富的 Windows 恶意软件分析师，刚刚开始涉足 macOS 的世界。天真地，我以为可以下载一个能够列出系统中所有持久化软件的工具来揭示恶意组件。像微软的
    AutoRuns 这样的知名安全工具提供了类似功能，适用于 Windows 系统，但我很快发现，Mac 上并没有类似的工具。
- en: I returned home and spent the next few days putting together a Python script
    that, while embarrassingly ugly, was capable of enumerating several types of persistent
    software. Running the script revealed an unrecognized launch agent on my friend’s
    computer that turned out to be the core persistent component of the adware. Once
    I removed it, his Mac was as good as new.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我回到家后，花了几天时间编写了一个 Python 脚本，尽管它丑得令人尴尬，但却能够列出几种类型的持久化软件。运行脚本后，我发现了一个未被识别的启动代理，最终证明它是广告软件的核心持久化组件。一旦我将其移除，他的
    Mac 就恢复如新。
- en: Realizing that my script could benefit other Mac users, I cleaned it up and
    released it under the moniker KnockKnock.^([2](#chapter10-2)) (Why KnockKnock?
    Because it tells you who’s there!) Today, KnockKnock has evolved greatly from
    its beginnings as a humble command line script. Now distributed as a native macOS
    application, it’s capable of detecting a myriad of persistently installed items
    on any macOS system. Coupled with an intuitive user interface (UI), integration
    with VirusTotal, and the ability to export its findings for ingestion into security
    information and event management (SIEM), it’s the first tool I run on any Mac
    that I suspect is infected.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 意识到我的脚本可以帮助其他 Mac 用户，我整理了一下并发布了它，命名为 KnockKnock。^([2](#chapter10-2))（为什么叫 KnockKnock？因为它告诉你“谁在那儿！”）如今，KnockKnock
    从最初的简单命令行脚本发展到了一个功能强大的工具。现在作为原生 macOS 应用程序分发，它能够检测任何 macOS 系统上持久安装的各种项目。配合直观的用户界面（UI）、与
    VirusTotal 的集成以及将结果导出用于安全信息和事件管理（SIEM）的功能，它是我在怀疑 Mac 可能感染时首先运行的工具。
- en: In this chapter, I’ll walk through KnockKnock’s design and implemen- tation
    to give you an in-depth look at the tool and expand your understand-ing of the
    persistence methods that Mac malware often does (or could) abuse. In the process,
    we’ll go beyond the detection mechanism discussed in [Chapter 5](chapter5.xhtml),
    which focused solely upon the Background Task Management database, to look at
    other ways of persisting on macOS, including browser extensions and dynamic library
    hijacks. You can find the complete source code on Objective-See’s GitHub page
    in the KnockKnock repository at [*https://<wbr>github<wbr>.com<wbr>/Objective<wbr>-see<wbr>/KnockKnock*](https://github.com/Objective-see/KnockKnock).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍 KnockKnock 的设计和实现，带你深入了解这个工具，并扩展你对 macOS 恶意软件常用（或可能使用）的持久化方法的理解。在这个过程中，我们将超越[第5章](chapter5.xhtml)中讨论的仅关注背景任务管理数据库的检测机制，探索其他在
    macOS 上持久化的方式，包括浏览器扩展和动态库劫持。你可以在 Objective-See 的 GitHub 页面上的 KnockKnock 仓库中找到完整的源代码，链接地址是
    [*https://<wbr>github<wbr>.com<wbr>/Objective<wbr>-see<wbr>/KnockKnock*](https://github.com/Objective-see/KnockKnock)。
- en: Tool Design
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具设计
- en: KnockKnock is a standard UI-based application (as shown in [Figure 10-1](chapter10.xhtml#fig10-1)),
    but users can also execute it in the terminal as a command line tool.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: KnockKnock 是一个标准的基于 UI 的应用程序（如[图 10-1](chapter10.xhtml#fig10-1)所示），但用户也可以在终端中将其作为命令行工具执行。
- en: '![](../images/Figure10-1.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-1.jpg)'
- en: 'Figure 10-1: KnockKnock’s user interface'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1：KnockKnock 的用户界面
- en: As this isn’t a book about writing UIs (thank goodness!), I won’t delve into
    the code related to KnockKnock’s UI. Instead, I focus mainly on its core components,
    such as its many plug-ins responsible for querying various aspects of the operating
    system to enumerate persistently installed items.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这不是一本关于编写用户界面的书（谢天谢地！），所以我不会深入探讨与 KnockKnock UI 相关的代码。相反，我将主要关注它的核心组件，例如负责查询操作系统各个方面的许多插件，这些插件用来枚举持久安装的项目。
- en: Command Line Options
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 命令行选项
- en: The code for any Objective-C program starts at the standard main function, and
    KnockKnock is no exception. In its main function, KnockKnock begins by checking
    its program arguments to determine whether it should display its usage information
    or perform a command line scan ([Listing 10-1](chapter10.xhtml#Lis10-1)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Objective-C 程序的代码从标准的 main 函数开始，KnockKnock 也不例外。在它的 main 函数中，KnockKnock 会首先检查其程序参数，以确定是否应该显示使用信息或执行命令行扫描（[列表
    10-1](chapter10.xhtml#Lis10-1)）。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 10-1: Parsing command line options'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-1：解析命令行选项
- en: 'You might be familiar with accessing a program’s command line arguments via
    the main function’s argv. Objective-C supports this approach, but we can also
    access the arguments via the arguments array of the processInfo property in the
    NSProcessInfo class. This technique has several advantages, most notably that
    it converts the arguments into Objective-C objects. This means, for example, that
    we can use the containsObject: method to easily determine whether the user has
    specified a certain command line argument regardless of the order of the arguments.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能熟悉通过主函数的 argv 访问程序的命令行参数。Objective-C 支持这种方法，但我们也可以通过 NSProcessInfo 类中的 processInfo
    属性的 arguments 数组来访问这些参数。这种技术有几个优点，最显著的是它将参数转换为 Objective-C 对象。这意味着，例如，我们可以使用 containsObject:
    方法轻松判断用户是否指定了某个命令行参数，而无需考虑参数的顺序。'
- en: To determine whether to run a command line scan, KnockKnock checks if the user
    specified the -whosthere command line option. If so, it invokes its cmdlineScan
    function to perform a scan of the system, printing out information about persistently
    installed items directly to the terminal.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了判断是否运行命令行扫描，KnockKnock 会检查用户是否指定了 -whosthere 命令行选项。如果是，它会调用 cmdlineScan 函数来扫描系统，并将关于持久安装项的信息直接输出到终端。
- en: Plug-ins
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 插件
- en: Because malware can persist on macOS in many ways and researchers discover new
    methods from time to time, KnockKnock’s design relies on the concept of what I’ll
    refer to as plug-ins. Each plug-in corresponds to one type of persistence and
    implements the logic to enumerate items of that persistence type. The plug-ins
    then call into other parts of KnockKnock to perform actions such as displaying
    each item in the UI. This modular approach provides a simple and efficient way
    to add support for new persistence techniques. For example, after the researcher
    Csaba Fitzl published the blog post “Beyond the Good Ol’ LaunchAgents -32- Dock
    Tile Plugins,” which detailed a new persistence strategy involving macOS Dock
    plug-ins,^([3](#chapter10-3)) I added a corresponding detection to KnockKnock
    via a new plug-in within the hour.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因为恶意软件可以通过多种方式在 macOS 上持久存在，并且研究人员时不时发现新的方法，KnockKnock 的设计依赖于我称之为插件的概念。每个插件对应一种持久性类型，并实现列举该类型持久性项目的逻辑。插件随后会调用
    KnockKnock 的其他部分来执行例如在 UI 中显示每个项目的操作。这种模块化方法提供了一种简单高效的方式来支持新的持久性技术。例如，在研究人员 Csaba
    Fitzl 发布了博客文章《Beyond the Good Ol’ LaunchAgents -32- Dock Tile Plugins》，该文章详细描述了涉及
    macOS Dock 插件的新持久性策略后，^([3](#chapter10-3)) 我在一小时内通过一个新的插件向 KnockKnock 添加了相应的检测功能。
- en: Each of KnockKnock’s plug-ins inherits from a custom plug-in base class named
    PluginBase, which declares properties common to all plug-ins, as well as base
    methods. Found in *PluginBase.h*, it includes plug-in metadata, such as a name
    and a description, and arrays that the plug-in populates as it encounters persisting
    items ([Listing 10-2](chapter10.xhtml#Lis10-2)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: KnockKnock 的每个插件都继承自一个名为 PluginBase 的自定义插件基类，该类声明了所有插件共有的属性以及基础方法。该基类位于 *PluginBase.h*
    中，包含插件元数据，如名称和描述，以及插件在遇到持久化项目时填充的数组（[列表 10-2](chapter10.xhtml#Lis10-2)）。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 10-2: The base plug-in class’s properties'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-2：基础插件类的属性
- en: The class also declares various base methods ([Listing 10-3](chapter10.xhtml#Lis10-3)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还声明了各种基础方法（[列表 10-3](chapter10.xhtml#Lis10-3)）。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 10-3: The base plug-in class’s methods'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-3：基础插件类的方法
- en: Each plug-in must implement the scan method with logic to enumerate one type
    of persistent item. For example, the Background Task Management plug-in will parse
    the Background Task Management database to extract persistent items managed by
    the Background Task Management subsystem, while the Browser Extension plug-in
    will enumerate installed browsers and, for each, extract any installed browser
    extensions. If researchers uncover a new persistence mechanism, we can trivially
    add a new plug-in with a scan method capable of enumerating items that persist
    in this new way.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个插件必须实现一个扫描方法，逻辑是枚举一种持久项类型。例如，背景任务管理插件将解析背景任务管理数据库，以提取由背景任务管理子系统管理的持久项，而浏览器扩展插件将枚举已安装的浏览器，并为每个浏览器提取已安装的浏览器扩展。如果研究人员发现了一种新的持久性机制，我们可以轻松地添加一个新的插件，并提供一个能够枚举以这种新方式持久存在的项的扫描方法。
- en: The base class’s scan method throws an exception if called directly ([Listing
    10-4](chapter10.xhtml#Lis10-4)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果直接调用，基类的扫描方法将抛出异常（[列表 10-4](chapter10.xhtml#Lis10-4)）。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 10-4: The base scan method will throw an exception if called.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-4：如果调用，基础扫描方法将抛出异常。
- en: This design allows KnockKnock to easily invoke each plug-in’s scan method without
    having to know anything about how each plug-in actually enumerates persistent
    items of its specific type. The class provides base implementations for the other
    two methods, reset and processItem:, though plug-ins can override them if needed.
    (Otherwise, the plug-in will just call the base class’s implementation.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计使得 KnockKnock 能够轻松调用每个插件的扫描方法，而无需了解每个插件如何实际枚举其特定类型的持久项。该类为其他两个方法（reset 和
    processItem:）提供了基础实现，尽管插件可以根据需要重写这些方法。（否则，插件将仅调用基类的实现。）
- en: 'Both methods affect the application’s UI. For example, when performing a UI
    scan, the reset method handles situations in which a user stops and then restarts
    a scan, while the processItem: method updates the UI as plug-ins uncover persistent
    items. During a command line scan, the processItem: method will still keep track
    of detected items and print each one to the terminal once the scan completes ([Listing
    10-5](chapter10.xhtml#Lis10-5)).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会影响应用程序的用户界面。例如，在执行 UI 扫描时，重置方法处理用户暂停后重新启动扫描的情况，而`processItem:`方法会在插件发现持久项时更新
    UI。在命令行扫描过程中，`processItem:`方法仍会跟踪检测到的项，并在扫描完成后将每个项打印到终端（[列表 10-5](chapter10.xhtml#Lis10-5)）。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 10-5: Updating a global list of persistent items'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-5：更新持久项的全局列表
- en: KnockKnock declares a static list of all plug-ins by their class name. Later,
    the code iterates over this list, instantiating each plug-in ([Listing 10-6](chapter10.xhtml#Lis10-6)).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: KnockKnock 声明了一个静态插件列表，按其类名排序。随后，代码会遍历此列表，为每个插件实例化一个对象（[列表 10-6](chapter10.xhtml#Lis10-6)）。
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 10-6: Initializing each plug-in by name'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-6：通过名称初始化每个插件
- en: 'For each plug-in class name, KnockKnock invokes the NSClassFromString API,
    which obtains a plug-in class based on the given name.^([4](#chapter10-4)) Then
    it invokes the class’s alloc method to allocate an instance of the class (in other
    words, to create an object). Next, it invokes the newly created object’s init
    method to allow the plug-in object to perform any initializations ❶. We’ll consider
    some initialization examples shortly. Although not shown here, KnockKnock will
    then invoke each of the plug-in’s scan methods.  #### Persistent Item Types'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个插件类名，KnockKnock 会调用 `NSClassFromString` API，根据给定的名称获取插件类。^([4](#chapter10-4))
    然后，它调用类的 `alloc` 方法来分配该类的实例（换句话说，就是创建一个对象）。接下来，它会调用新创建的对象的 `init` 方法，以允许插件对象执行任何初始化操作
    ❶。我们稍后将考虑一些初始化示例。虽然这里没有展示，但 KnockKnock 接着会调用每个插件的扫描方法。#### 持久项类型
- en: 'KnockKnock assigns one of three types to persistent items: file, command, or
    browser extension. Most persisted items are executable files, such as scripts
    or Mach-O binaries. However, as in the case of cron jobs, malware sometimes persists
    as a command; other times, it persists as a bundle of files and resources in the
    form of a browser extension. It’s important for KnockKnock to correctly classify
    items, as each type has unique characteristics. For example, a persistent file
    might have extractable code signing information to help us classify it. We can
    also hash such files to check for known malware.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: KnockKnock 将持久化项分为三种类型：文件、命令或浏览器扩展。大多数持久化项是可执行文件，如脚本或 Mach-O 二进制文件。然而，在 cron
    任务的情况下，恶意软件有时会以命令形式持久化；有时它则以浏览器扩展的形式持久化，包含一组文件和资源。正确分类项目对 KnockKnock 来说非常重要，因为每种类型都有其独特的特性。例如，持久化文件可能具有可提取的代码签名信息，帮助我们进行分类。我们也可以对这些文件进行哈希处理，以检查是否为已知恶意软件。
- en: The three item types are subclasses of a custom ItemBase class, shown in [Listing
    10-7](chapter10.xhtml#Lis10-7).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种项目类型是自定义 `ItemBase` 类的子类，如[示例 10-7](chapter10.xhtml#Lis10-7)所示。
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 10-7: The interface for the ItemBase class'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-7：`ItemBase` 类的接口
- en: This base class declares various properties, such as the plug-in that discovered
    the item, the item’s name, and its path. Not all item types set every property.
    For example, commands don’t have paths, whereas files and extensions do. The ItemBase
    class also implements base methods to initialize an item, return its path to show
    it in the Finder app, and convert it to JSON. Although objects that inherit from
    this base class can reimplement each method if they need to, the base class’s
    implementation may suffice.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基类声明了多个属性，如发现该项的插件、项目的名称和路径，并且并非所有项目类型都会设置每个属性。例如，命令没有路径，而文件和扩展则有。`ItemBase`
    类还实现了用于初始化项目、返回其路径以在 Finder 应用中显示以及将其转换为 JSON 的基本方法。虽然继承自该基类的对象可以根据需要重新实现每个方法，但基类的实现可能已经足够。
- en: Once a plug-in’s scan method completes, it stores any discovered items in a
    plug-in property called allItems. In a command line scan, KnockKnock converts
    each persistent item to JSON and appends it to a string that it prints out ([Listing
    10-8](chapter10.xhtml#Lis10-8)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦插件的扫描方法完成，它会将任何发现的项目存储在一个名为 `allItems` 的插件属性中。在命令行扫描中，KnockKnock 将每个持久化项转换为
    JSON，并将其附加到一个打印出来的字符串中（见[示例 10-8](chapter10.xhtml#Lis10-8)）。
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 10-8: Converting persistent items to JSON'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-8：将持久化项目转换为 JSON
- en: Each item type implements its own logic to convert the information collected
    about a persistent item to JSON. Let’s take a look at the implementation of the
    toJSON method for items whose type is File ([Listing 10-9](chapter10.xhtml#Lis10-9)).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每种项目类型都实现了自己的逻辑，将收集到的持久化项信息转换为 JSON。我们来看一下文件类型项目的 `toJSON` 方法的实现（见[示例 10-9](chapter10.xhtml#Lis10-9)）。
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 10-9: Converting File object properties to JSON'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-9：将文件对象属性转换为 JSON
- en: 'First, the code makes use of the NSJSONSerialization class’s dataWithJSONObject:options:error:
    method to convert various dictionaries into JSON. These dictionaries include the
    item’s code signing information ❶ and hashes ❷. The method also converts numeric
    values from VirusTotal scan results ([Listing 10-10](chapter10.xhtml#Lis10-10)).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码使用 `NSJSONSerialization` 类的 `dataWithJSONObject:options:error:` 方法将各种字典转换为
    JSON。这些字典包括项目的代码签名信息 ❶ 和哈希值 ❷。该方法还将 VirusTotal 扫描结果中的数值转换为 JSON（见[示例 10-10](chapter10.xhtml#Lis10-10)）。
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 10-10: Computing a detection ratio based on scan results from VirusTotal'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-10：基于 VirusTotal 扫描结果计算检测比率
- en: Technically, KnockKnock itself doesn’t include logic to detect malicious code;
    it merely enumerates persistently installed items. This is by design, as it allows
    KnockKnock to detect new persistent malware even with no direct a priori knowledge
    of it. However, KnockKnock’s integration with VirusTotal allows it to flag already
    known malware by submitting a POST request with a hash of each persistent item
    to a VirusTotal query API. This API returns basic detection information, such
    as how many antivirus engines scanned the items and how many of those engines
    flagged it as malicious. KnockKnock converts this data into a string ratio of
    the form *positive detections*/*antivirus engines* and then displays this result
    in the UI or command line output.^([5](#chapter10-5))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，KnockKnock 本身不包含检测恶意代码的逻辑；它仅仅是枚举持久安装的项目。这是设计使然，因为它允许 KnockKnock 即使没有事先了解新恶意软件，也能检测到新的持久化恶意软件。然而，KnockKnock
    与 VirusTotal 的集成使它能够通过向 VirusTotal 查询 API 提交每个持久化项目的哈希值，标记已知的恶意软件。该 API 返回基本的检测信息，例如有多少病毒扫描引擎扫描了这些项目，并且有多少引擎将其标记为恶意。KnockKnock
    将这些数据转换为字符串比率，格式为 *正面检测*/*病毒扫描引擎*，然后将结果显示在用户界面或命令行输出中。^([5](#chapter10-5))
- en: The toJSON method finishes by building a single string object that combines
    the converted dictionaries, formatted numerical values, and all other properties
    of the item object ([Listing 10-11](chapter10.xhtml#Lis10-11)).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: toJSON 方法最终构建一个单一的字符串对象，将转换后的字典、格式化的数值以及项目对象的所有其他属性组合在一起（[列表 10-11](chapter10.xhtml#Lis10-11)）。
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 10-11: Building a JSON-ified string'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-11：构建一个 JSON 字符串
- en: 'It returns this string to the caller to print out. For example, on a system
    infected with the persistent DazzleSpy malware, KnockKnock would display the following
    JSON in the terminal:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它将这个字符串返回给调用者进行打印。例如，在一个被持久化的 DazzleSpy 恶意软件感染的系统上，KnockKnock 会在终端显示以下 JSON：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The output shows several red flags pointing to the fact that this item is likely
    malicious. For example, it’s running from a hidden directory (*.local*), and while
    it claims to be an Apple software updater, its signature status is -67062, which
    maps to the errSecCSUnsigned constant. What conclusively identifies this item
    as malware, though, is the VirusTotal detection ratio, which shows that roughly
    half of the antivirus engines on the site flagged it as malicious.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了几个红旗，表明这个项目很可能是恶意的。例如，它运行于一个隐藏的目录（*.local*），虽然它声称是一个 Apple 软件更新程序，但它的签名状态为
    -67062，这与 errSecCSUnsigned 常量对应。然而，最能确认为恶意软件的标志是 VirusTotal 的检测比率，显示大约一半的病毒扫描引擎将其标记为恶意。
- en: Exploring the Plug-ins
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索插件
- en: KnockKnock has approximately 20 plug-ins to detect a myriad of persistent items,
    including items stored in Background Task Management, browser extensions, cron
    jobs, dynamic library inserts and proxies, kernel extensions, launch items, login
    items, Spotlight importers, system extensions, and many more. Although I won’t
    cover every plug-in here, I’ll dive into a few of them and provide examples of
    the malware they can detect.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: KnockKnock 约有 20 个插件，用于检测各种持久化项目，包括存储在后台任务管理中的项目、浏览器扩展、cron 作业、动态库插入和代理、内核扩展、启动项、登录项、Spotlight
    导入器、系统扩展等。尽管我不会在这里覆盖每个插件，但我会深入探讨其中的一些，并提供它们能检测到的恶意软件示例。
- en: '#### Background Task Management'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 后台任务管理'
- en: In [Chapter 5](chapter5.xhtml), we explored the undocumented Background Task
    Manage-ment subsystem, which macOS leverages to govern and track persistent items
    such as launch agents, daemons, and login items. Through reverse engineering,
    I showed you how to deserialize the items managed by the subsystem, which could
    include persistently installed malware. We then created an open source library
    that I dubbed *DumpBTM*, which is available on GitHub ([*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/DumpBTM*](https://github.com/objective-see/DumpBTM)).
    To enumerate persistently installed launch and login items, KnockKnock leverages
    this library.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](chapter5.xhtml)中，我们探讨了未文档化的后台任务管理子系统，该子系统被 macOS 用于管理和跟踪持久化项目，如启动代理、守护进程和登录项。通过逆向工程，我向你展示了如何反序列化由该子系统管理的项目，这些项目可能包括持久安装的恶意软件。随后，我们创建了一个开源库，名为*DumpBTM*，它可以在
    GitHub 上找到（[*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/DumpBTM*](https://github.com/objective-see/DumpBTM)）。为了枚举持久安装的启动项和登录项，KnockKnock
    利用了这个库。
- en: NOTE
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*In Xcode, you can link in a library under your project’s Build Phases tab.
    There, expand Link Binary With Libraries, click* **+***, and then browse to the
    library.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 Xcode 中，你可以在项目的 Build Phases 标签下链接一个库。在那里，展开 Link Binary With Libraries，点击**+**，然后浏览到该库。*'
- en: After linking in the *DumpBTM* library, KnockKnock’s Background Task Management
    plug-in can directly invoke its exported APIs, such as its parseBTM function.
    The function takes a path to a Background Task Management file (or nil, to default
    to the system’s file) and returns a dictionary containing deserialized metadata
    about each persistent item managed by Background Task Management. [Listing 10-12](chapter10.xhtml#Lis10-12)
    shows a snippet of the code in the plug-in’s scan method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接了 *DumpBTM* 库之后，KnockKnock 的后台任务管理插件可以直接调用其导出的 API，例如 parseBTM 函数。该函数接受一个后台任务管理文件的路径（或者为
    nil，默认使用系统文件），并返回一个包含关于每个持久项的反序列化元数据的字典。[列表 10-12](chapter10.xhtml#Lis10-12) 显示了插件扫描方法中代码的一个片段。
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 10-12: Calling into the DumpBTM library'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-12：调用 DumpBTM 库
- en: 'This code makes use of the @available Objective-C keyword to ensure that the
    plug-in executes only on versions 13 and newer of macOS (as the Background Task
    Management subsystem doesn’t exist on earlier versions). KnockKnock then iterates
    over the metadata for each persistent item returned by the *DumpBTM* library’s
    parseBTM function and, for each, instantiates a File item object. It does this
    by invoking the File class’s initWithParams: method, which accepts a dictionary
    of values for the object, including a path and, for launch items, the property
    list.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码使用了 @available Objective-C 关键字，确保插件仅在 macOS 13 及更新版本上执行（因为早期版本没有后台任务管理子系统）。然后，KnockKnock
    会遍历 *DumpBTM* 库的 parseBTM 函数返回的每个持久项的元数据，并为每一个持久项实例化一个 File 项对象。它通过调用 File 类的
    initWithParams: 方法来完成这一操作，该方法接受一个包含对象值的字典，包括路径，以及对于启动项的属性列表。'
- en: Note that the code explicitly checks for a property list, as some persistent
    items in the Background Task Management database, such as login items, won’t contain
    one ([Listing 10-13](chapter10.xhtml#Lis10-13)). This is an important check, as
    inserting a nonexistent (nil) item into a dictionary will cause your program to
    crash.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码明确检查了属性列表，因为某些持久项（如登录项）在后台任务管理数据库中可能不包含此列表（[列表 10-13](chapter10.xhtml#Lis10-13)）。这是一个重要检查，因为将不存在（nil）的项插入字典会导致程序崩溃。
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 10-13: Creating a dictionary of parameters to initialize a File object'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-13：创建一个字典参数来初始化 File 对象
- en: 'With an initialized File object in hand, KnockKnock’s Background Task Management
    plug-in can now invoke the base plug-in class’s processItem: method to trigger
    a refresh of the UI or, in a command line scan, add the item to the list of items
    persistently installed on the system.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '在初始化一个 File 对象后，KnockKnock 的后台任务管理插件可以调用基类插件的 processItem: 方法，触发 UI 刷新，或者在命令行扫描中将该项添加到系统上持久安装的项列表中。'
- en: 'Using the *DumpBTM* library, KnockKnock can easily enumerate all persistent
    items managed by the subsystem. In the following output, you can see the tool
    displaying details of the cyber-espionage implant WindTail, which persists an
    app named *Final_Presentation.app* as a login item:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*DumpBTM*库，KnockKnock 可以轻松枚举子系统管理的所有持久项。在以下输出中，你可以看到该工具显示了网络间谍植入程序 WindTail
    的详细信息，该程序将一个名为*Final_Presentation.app*的应用程序作为登录项持久化：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Many antivirus engines on VirusTotal now flag the malware, and a check of its
    signature returns -2147409652, which maps to the “certificate revoked” constant,
    CSSMERR_TP_CERT_REVOKED. However, KnockKnock would have shown the presence of
    the persistent item even before the antivirus engines on VirusTotal developed
    signatures for it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，许多病毒扫描引擎在 VirusTotal 上已经标记出该恶意软件，并且检查其签名返回-2147409652，这与“证书被吊销”常量 CSSMERR_TP_CERT_REVOKED
    对应。然而，即使 VirusTotal 上的病毒引擎还未为其开发签名，KnockKnock 也早已显示出该持久项的存在。
- en: Unfortunately, no external library can enumerate many of KnockKnock’s other
    classes of persistence, so we’ll have to write more code ourselves. One example
    is the browser extension plug-in, which we’ll look at now.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有外部库可以枚举 KnockKnock 的其他类型的持久性，因此我们需要自己编写更多的代码。一个例子是浏览器扩展插件，我们现在来看一下这个。
- en: Browser Extension
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 浏览器扩展
- en: Most macOS adware installs a malicious browser extension to hijack search results,
    display ads, or even intercept browser traffic. Common examples of such adware
    include Genieo, Yontoo, and Shlayer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 macOS 广告软件会安装一个恶意浏览器扩展来劫持搜索结果、显示广告，甚至拦截浏览器流量。常见的此类广告软件包括 Genieo、Yontoo 和
    Shlayer。
- en: Because no macOS APIs can enumerate installed browser extensions, KnockKnock
    must do so itself. Worse, as each browser manages its extensions in its own way,
    KnockKnock must implement specific enumeration code for each. Currently, the tool
    supports extension enumeration for Safari, Chrome, Firefox, and Opera browsers.
    In this section, we’ll cover the code specific to Safari.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有macOS API可以列举已安装的浏览器扩展，KnockKnock必须自己实现这一功能。更糟糕的是，由于每个浏览器以不同的方式管理其扩展，KnockKnock必须为每个浏览器实现特定的列举代码。目前，该工具支持Safari、Chrome、Firefox和Opera浏览器的扩展列举。在本节中，我们将讨论特定于Safari的代码。
- en: To list the installed browsers, KnockKnock uses relatively unknown Launch Services
    APIs ([Listing 10-14](chapter10.xhtml#Lis10-14)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了列出已安装的浏览器，KnockKnock使用了相对不为人知的Launch Services API（[清单 10-14](chapter10.xhtml#Lis10-14)）。
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 10-14: Obtaining a list of installed browsers using Launch Services
    APIs'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-14：使用Launch Services API获取已安装浏览器的列表
- en: The code invokes the LSCopyAllHandlersForURLScheme API with the URL scheme https
    ❶, which returns an array containing the bundle IDs of applications capable of
    handling that scheme. The code then invokes the LSFindApplicationForInfo API to
    map each ID to an application path ❷, saving these into an array that it returns
    to the caller.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码调用LSCopyAllHandlersForURLScheme API，传入URL协议https ❶，该API返回一个包含能够处理该协议的应用程序bundle
    ID的数组。然后代码调用LSFindApplicationForInfo API，将每个ID映射到一个应用程序路径 ❷，并将这些路径保存到一个数组中，返回给调用者。
- en: 'In macOS 12, Apple added the URLsForApplicationsToOpenURL: method to the NSWorkspace
    class to return all applications capable of opening a specified URL. Invoking
    this method with a URL to a web page will return a list of all installed browsers.
    For newer versions of macOS, KnockKnock makes use of this API ([Listing 10-15](chapter10.xhtml#Lis10-15)).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS 12中，苹果将URLsForApplicationsToOpenURL:方法添加到了NSWorkspace类中，用以返回所有能够打开指定URL的应用程序。调用这个方法并传入一个网页的URL时，将返回所有已安装浏览器的列表。对于较新版本的macOS，KnockKnock使用了这个API（[清单
    10-15](chapter10.xhtml#Lis10-15)）。
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 10-15: Obtaining a list of installed browsers with the URLsForApplicationsToOpenURL:
    method'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-15：使用URLsForApplicationsToOpenURL:方法获取已安装浏览器的列表
- en: 'You can find the code to enumerate Safari browser extensions in the scanExtensionsSafari:
    method of KnockKnock’s browser extension plug-in. In [Listing 10-16](chapter10.xhtml#Lis10-16),
    the code invokes this method with Safari’s location, found using the previous
    code.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在KnockKnock的浏览器扩展插件的scanExtensionsSafari:方法中找到列举Safari浏览器扩展的代码。在[清单 10-16](chapter10.xhtml#Lis10-16)中，这段代码使用之前的代码找到Safari的位置，然后调用这个方法。
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 10-16: Invoking Safari-specific logic to enumerate its extensions'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-16：调用Safari特定逻辑列举其扩展
- en: 'The location of Safari’s browser extensions has changed over the years; you
    could find them in the *~/Library/Safari/Extensions* directory until Apple decided
    to move them into the keychain. Older versions of KnockKnock tried to keep up
    with these changes, but now, it uses a simpler method: executing the macOS pluginkit
    utility ([Listing 10-17](chapter10.xhtml#Lis10-17)).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Safari浏览器扩展的位置随着时间的推移发生了变化；直到苹果决定将其移入钥匙串之前，你可以在*~/Library/Safari/Extensions*目录中找到它们。KnockKnock的早期版本曾尝试跟踪这些变化，但现在，它使用了一个更简单的方法：执行macOS的pluginkit工具（[清单
    10-17](chapter10.xhtml#Lis10-17)）。
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 10-17: Enumerating installed Safari extensions'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-17：列举已安装的Safari扩展
- en: The -m argument finds all plug-ins that match the search criteria specified
    in the -p argument; the -A argument returns all versions of the installed plug-ins,
    rather than just the highest version; and -vv returns verbose output that includes
    the display name and parent bundle. For the -p argument, we first use com.apple.Safari.extension,
    then com.apple.Safari.content-blocker. This ensures that we enumerate both traditional
    extensions and content blocker extensions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: -m参数用于查找所有符合-p参数指定的搜索条件的插件；-A参数返回所有已安装插件的版本，而不仅仅是最新版本；-vv参数返回详细的输出，包括显示名称和父包信息。对于-p参数，我们首先使用com.apple.Safari.extension，然后使用com.apple.Safari.content-blocker。这样可以确保我们列举出传统扩展和内容拦截扩展。
- en: 'We execute pluginkit in a helper function we’ve named execTask (discussed in
    [Chapter 1](chapter1.xhtml)), which simply launches the specified program along
    with any specified arguments and returns the output to the caller. Try running
    pluginkit yourself to enumerate the Safari extensions installed on your Mac. In
    the following output, you can see that I’ve installed an ad blocker:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在名为 execTask 的辅助函数中执行 pluginkit（在[第1章](chapter1.xhtml)中讨论过），该函数简单地启动指定的程序及其指定的任何参数，并将输出返回给调用者。你可以尝试自行运行
    pluginkit，以列举你 Mac 上安装的 Safari 扩展。在以下输出中，你可以看到我安装了一个广告拦截器：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Leveraging this external binary has the downside of introducing a dependency
    and the need to parse its output, but it’s still the most reliable option. There
    are many ways to parse any output. In [Listing 10-18](chapter10.xhtml#Lis10-18),
    KnockKnock takes the approach of extracting each extension’s name, path, and UUID.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这个外部二进制文件有一个缺点，即会引入依赖关系并需要解析其输出，但它仍然是最可靠的选择。有许多方法可以解析任何输出。在[列表 10-18](chapter10.xhtml#Lis10-18)中，KnockKnock
    采用了提取每个扩展名、路径和 UUID 的方法。
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 10-18: Parsing output containing installed Safari extensions'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-18：解析包含已安装 Safari 扩展的输出
- en: The parsing code separates the output line by line, then splits each line into
    key-value pairs using an equal sign (*=*) as a delimiter. This will, for example,
    split the line Path = /Applications/Adblock Plus.app/Contents/PlugIns/Adblock
    Plus Toolbar.appex into the key Path and a value containing the path to the installed
    ad blocker extension. The code then extracts key-value pairs of interest, such
    as the path, name, and UUID.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 解析代码按行分隔输出，然后使用等号（*=*）作为分隔符将每一行拆分为键值对。例如，这会将行 Path = /Applications/Adblock Plus.app/Contents/PlugIns/Adblock
    Plus Toolbar.appex 拆分为键 Path 和包含已安装广告拦截器扩展路径的值。然后，代码提取感兴趣的键值对，如路径、名称和 UUID。
- en: Using the path to the extension, we load its *Info.plist* file and extract a
    description of the extension from the NSHumanReadableDescription key ([Listing
    10-19](chapter10.xhtml#Lis10-19)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展的路径，我们加载其*Info.plist*文件，并从 NSHumanReadableDescription 键中提取扩展的描述信息（[列表 10-19](chapter10.xhtml#Lis10-19)）。
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 10-19: Initializing an Extension object for each extension'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-19：为每个扩展初始化一个扩展对象
- en: 'Finally, we create a KnockKnock browser Extension item object with the collected
    extension metadata.  #### Dynamic Library Insertion'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个 KnockKnock 浏览器扩展项对象，并使用收集到的扩展元数据。#### 动态库注入
- en: A malware sample known as Flashback shattered the notion that Apple’s operating
    system was immune to malware.^([6](#chapter10-6)) Flashback exploited an unpatched
    vulnerability capable of automatically infecting users who browsed to a malicious
    website. Discovered in 2012, it amassed more than half a million victims, making
    it the most successful Mac malware at the time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 Flashback 的恶意软件粉碎了 Apple 操作系统免疫于恶意软件的概念。^[6](#chapter10-6) Flashback 利用了一个未修补的漏洞，能够自动感染浏览到恶意网站的用户。2012年被发现，它感染了超过50万名受害者，使其成为当时最成功的
    Mac 恶意软件。
- en: 'Flashback also persisted in a novel and stealthy manner. On an infected system,
    the malware gained user-assisted persistence by subverting Safari’s *Info.plist*
    file and inserting the following dictionary under a key named LSEnvironment:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Flashback 还以一种新颖且隐蔽的方式保持持久性。在感染的系统上，恶意软件通过破坏 Safari 的 *Info.plist* 文件，并在名为 LSEnvironment
    的键下插入以下字典，从而获得用户协助的持久性。
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The dictionary’s DYLD_INSERT_LIBRARIES key contains a string pointing to the
    malicious library *UnHackMeBuild*. Safari will load this library into the browser
    when launched, where the malware could stealthily execute.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的 DYLD_INSERT_LIBRARIES 键包含一个指向恶意库 *UnHackMeBuild* 的字符串。当 Safari 启动时，它会将这个库加载到浏览器中，恶意软件便可以悄悄执行。
- en: Today, Apple has mostly mitigated dylib insertions via the DYLD_INSERT_LIBRARIES
    environment variable and other approaches. The dynamic loader now ignores these
    variables in a wide range of cases, such as for platform binaries or for applications
    compiled with the hardened runtime.^([7](#chapter10-7)) However, programs supporting
    third-party plug-ins, especially on older versions of macOS, may still be at risk.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，Apple 已经通过 DYLD_INSERT_LIBRARIES 环境变量和其他方法大大减轻了 dylib 注入的风险。动态加载器现在会忽略在多种情况下的这些变量，例如对于平台二进制文件或使用硬化运行时编译的应用程序。（^[7](#chapter10-7)）然而，支持第三方插件的程序，尤其是旧版本
    macOS 上的程序，可能仍然面临风险。
- en: As such, KnockKnock contains a plug-in to detect this type of subversion. It
    scans launch items and applications, checking for the presence of a DYLD_INSERT_LIBRARIES
    entry. For launch items, this entry lives under the EnvironmentVariables key in
    their property list file, and for applications, you can find it under a key named
    LSEnvironment in the app’s *Info.plist* file, as we saw with Flashback. Because
    legitimate items rarely make use of persistent DYLD_INSERT_LIBRARIES insertions,
    you should closely examine any that you uncover.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，KnockKnock 包含一个插件来检测这种类型的子版本。它扫描启动项和应用程序，检查是否存在 DYLD_INSERT_LIBRARIES 条目。对于启动项，这个条目位于其属性列表文件中的
    EnvironmentVariables 键下，对于应用程序，你可以在应用的 *Info.plist* 文件中找到名为 LSEnvironment 的键，就像我们在
    Flashback 中看到的那样。因为合法项很少使用持久的 DYLD_INSERT_LIBRARIES 插入，所以你应该仔细检查任何你发现的条目。
- en: Other plug-ins require a similar list of all launch items and applications,
    so KnockKnock produces this list in a global enumerator. Let’s briefly look at
    how KnockKnock tackles such enumeration, focusing on the case of installed apps,
    as there are multiple ways to list these items on a Mac. The least recommended
    is to manually enumerate bundles found in the common application directories (such
    as */Applications*), as you’d have to take into account subdirectories such as
    */Applications/Utilities/*, as well as user- specific applications. Plus, applications
    could be installed in other locations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 其他插件需要类似的所有启动项和应用程序的列表，因此 KnockKnock 在全局枚举器中生成这个列表。我们来简要看看 KnockKnock 是如何处理这种枚举的，重点讲解已安装应用程序的情况，因为在
    Mac 上列出这些项目有多种方法。最不推荐的方法是手动枚举常见应用程序目录中的捆绑包（例如 */Applications*），因为你需要考虑诸如 */Applications/Utilities/*
    这样的子目录，以及用户特定的应用程序。而且，应用程序可能安装在其他位置。
- en: A Stack Overflow post suggests better options.^([8](#chapter10-8)) These include
    leveraging the lsregister utility to list all applications that have been registered
    with Launch Services, using the mdfind utility or related Spotlight APIs to list
    all applications indexed by macOS, or making use of the macOS system_profiler
    utility to obtain a list of applications known to the operating system’s software
    configuration.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一篇 Stack Overflow 的帖子建议了更好的选项。^([8](#chapter10-8)) 这些选项包括利用 lsregister 工具列出所有已注册到
    Launch Services 的应用程序，使用 mdfind 工具或相关的 Spotlight API 列出所有由 macOS 索引的应用程序，或者使用
    macOS 的 system_profiler 工具获取操作系统软件配置中已知的应用程序列表。
- en: 'KnockKnock opts for the system_profiler approach. The tool can output XML or
    JSON, which is easy to programmatically ingest and parse. Here is an example of
    XML output, along with the metadata for an instance of KnockKnock installed on
    my computer:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: KnockKnock 选择使用 system_profiler 方法。该工具可以输出 XML 或 JSON，便于程序化地获取和解析。以下是 XML 输出的示例，以及安装在我电脑上的
    KnockKnock 实例的元数据：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: KnockKnock executes system_profiler via the execTask helper function discussed
    earlier in this chapter ([Listing 10-20](chapter10.xhtml#Lis10-20)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: KnockKnock 通过前面在本章中讨论的 execTask 辅助函数执行 system_profiler ([列表 10-20](chapter10.xhtml#Lis10-20))。
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 10-20: Installed applications enumerated via system_profiler'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-20：通过 system_profiler 枚举的已安装应用程序
- en: Once this helper function returns ❶, KnockKnock serializes the XML output into
    an Objective-C object ❷, then saves the list of applications found under the _items
    key into an instance variable aptly named applications ❸.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个辅助函数返回 ❶，KnockKnock 会将 XML 输出序列化为 Objective-C 对象 ❷，然后将找到的应用程序列表保存在一个名为 applications
    的实例变量中，位于 _items 键下 ❸。
- en: Now that KnockKnock’s global enumerator has obtained a list of applications
    (and launch items, although I didn’t show this logic here), the dylib insertion
    plug-in can scan each, looking for the addition of the DYLD_INSERT_LIBRARIES environment
    variable. [Listing 10-21](chapter10.xhtml#Lis10-21) shows this implementation
    in a method called scanApplications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，KnockKnock 的全局枚举器已经获得了应用程序（以及启动项的列表，尽管我在这里没有展示这一逻辑），dylib 插入插件可以扫描每个应用程序，寻找
    DYLD_INSERT_LIBRARIES 环境变量的添加。 [列表 10-21](chapter10.xhtml#Lis10-21) 显示了这个在名为 scanApplications
    的方法中的实现。
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 10-21: Enumerating applications containing an inserted environment
    variable'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-21：枚举包含插入环境变量的应用程序
- en: 'The code iterates over all apps found by the global enumerator ❶. For each,
    it uses the application’s path to load the application’s bundle ❷, which has useful
    metadata about the application. This includes the contents of the app’s *Info.plist*
    file, which we can access through the bundle object’s infoDictionary property.
    After extracting the path to the *Info.plist* file ❸, it uses the key LSEnvironment
    to extract the dictionary containing specific environment variables ❹. Of course,
    most apps won’t set any environment variables, so the code skips these. However,
    for those that have the DYLD_INSERT_LIBRARIES key set, the code extracts its value:
    a path to the library inserted each time the application is run ❺. In Flashback,
    which subverted Safari, recall that the key-value pair looks like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 代码遍历全局枚举器❶找到的所有应用程序。对于每个应用，它使用应用程序的路径加载应用程序的捆绑包❷，该捆绑包包含关于应用程序的有用元数据。这包括应用程序的
    *Info.plist* 文件的内容，我们可以通过捆绑包对象的 infoDictionary 属性访问该文件。提取到 *Info.plist* 文件的路径❸后，它使用键
    LSEnvironment 提取包含特定环境变量的字典❹。当然，大多数应用不会设置任何环境变量，因此代码会跳过这些。然而，对于那些设置了 DYLD_INSERT_LIBRARIES
    键的应用，代码会提取它的值：即每次运行应用时插入的库的路径❺。在 Flashback 中，它入侵了 Safari，请记住，键值对看起来像这样：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, the code in the plug-in creates and processes a File item object representing
    the inserted library, saving it to the list of persistent items uncovered by KnockKnock
    to then print to the terminal or display in the UI.  #### Dynamic Library Proxying
    and Hijacking'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，插件中的代码创建并处理一个表示插入库的文件项对象，将其保存到 KnockKnock 揭示的持久性项目列表中，然后将其打印到终端或显示在用户界面中。####
    动态库代理与劫持
- en: The last plug-in I’ll cover in this chapter detects two other persistence mechanisms
    that make use of dynamic libraries. *Dylib proxying* replaces a library on which
    a target process depends with a malicious library. Whenever the target application
    starts, the malicious dynamic library loads and runs as well. To keep the application
    from losing legitimate functionality, it proxies requests to and from the original
    library.^([9](#chapter10-9))
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我将介绍的最后一个插件检测到两种利用动态库的其他持久性机制。*Dylib 代理* 替换目标进程依赖的库为恶意库。每当目标应用启动时，恶意动态库也会加载并运行。为了避免应用丧失合法功能，它会代理请求到原始库并返回。^([9](#chapter10-9))
- en: Closely related to dylib proxying is *dylib hijacking*, which exploits the fact
    that the loader may look for dependencies in multiple locations. Malware could
    take advantage of this behavior by tricking the loader into using a malicious
    dependency instead of a legitimate one. Although malware doesn’t commonly abuse
    this technique, the post-exploitation agent EmPyre supports it as a persistence
    mechanism.^([10](#chapter10-10)) Dynamic libraries that perform such hijacking
    also proxy requests to keep from breaking legitimate functionality.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与 dylib 代理密切相关的是 *dylib 劫持*，它利用加载器可能在多个位置查找依赖项的事实。恶意软件可以通过欺骗加载器使用恶意依赖项而不是合法的依赖项来利用这一行为。尽管恶意软件并不常滥用这种技术，但后期利用代理
    EmPyre 支持它作为持久性机制。^([10](#chapter10-10)) 执行此类劫持的动态库还会代理请求，以避免破坏合法功能。
- en: To detect either technique, KnockKnock generates a list of dynamic libraries,
    then checks each for an LC_REEXPORT_DYLIB load command that loads and proxies
    requests to the original library. While this load command is legitimate, benign
    libraries rarely use it, so we should closely examine any that do.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测这两种技术，KnockKnock 生成动态库列表，然后检查每个库是否具有 LC_REEXPORT_DYLIB 加载命令，该命令会加载并代理到原始库的请求。尽管此加载命令是合法的，但良性库很少使用它，因此我们应该仔细检查所有使用该命令的库。
- en: Unfortunately, there isn’t a simple way to list all dynamic libraries installed
    on a macOS system, so KnockKnock focuses on those that are currently open or loaded
    by running processes. This approach isn’t as comprehensive as a scan of the entire
    system, but then again, any persisted malware is probably running somewhere.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，macOS 系统上没有简单的方法列出所有已安装的动态库，因此 KnockKnock 侧重于那些当前由运行中的进程打开或加载的库。这种方法不像扫描整个系统那样全面，但话说回来，任何持久化的恶意软件可能都在某处运行。
- en: To build a list of loaded libraries, KnockKnock runs the lsof utility to list
    all open files on the system, then filters out everything but executables. If
    a dynamic library has been loaded somewhere, there should be an open file handle
    to it, which lsof can enumerate.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建加载的库列表，KnockKnock 运行 lsof 工具列出系统上所有打开的文件，然后过滤掉除了可执行文件之外的所有内容。如果某个动态库已被加载，那么应该会有一个打开的文件句柄指向它，而
    lsof 可以枚举这些句柄。
- en: 'While getting a list of open files is fairly simple, determining whether a
    file is executable isn’t as easy as you might expect. You can’t just look for
    files whose extension is *.dylib* because that list wouldn’t include frameworks,
    which are technically libraries but don’t normally end in *.dylib*. For example,
    take a look at the *Electron* framework. The file command reports that it is indeed
    a dynamic library, though its extension isn’t *.dylib*:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然获取打开的文件列表相对简单，但确定文件是否可执行并不像你想的那么容易。你不能仅仅通过查找扩展名为*.dylib*的文件，因为这个列表不会包括框架，虽然框架在技术上是库，但通常不会以*.dylib*结尾。例如，看看*Electron*框架。`file`命令报告它确实是一个动态库，尽管它的扩展名不是*.dylib*：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Another strategy might be to check which of the open files are binaries by
    checking the file’s executable bit, but this would include scripts and other random
    files on macOS, such as certain archives (which, as we can see here, have the
    executable bit, x, set):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略可能是通过检查文件的可执行位来判断哪些打开的文件是二进制文件，但这将包括脚本和macOS上的其他随机文件，如某些归档文件（正如我们在这里看到的，它们设置了可执行位x）：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: While you could manually parse each file, looking for a universal or Mach-O
    magic value, it turns out an Apple-provided API can do this for you. The relatively
    unknown CFBundleCopyExecutableArchitecturesForURL API extracts the executable
    architecture of a file, returning NULL or an empty array for nonbinary files.^([11](#chapter10-11))
    KnockKnock, which makes use of this API, also checks for binaries of supported
    architectures ([Listing 10-22](chapter10.xhtml#Lis10-22)).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以手动解析每个文件，寻找通用或Mach-O魔法值，但事实证明，苹果提供的API可以为你完成此操作。相对鲜为人知的`CFBundleCopyExecutableArchitecturesForURL`
    API提取文件的可执行架构，对于非二进制文件，它返回NULL或空数组。^([11](#chapter10-11)) KnockKnock利用该API，还检查受支持架构的二进制文件（[Listing
    10-22](chapter10.xhtml#Lis10-22)）。
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 10-22: Determining whether an item is a binary'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 10-22：确定项目是否为二进制文件
- en: The isBinary function builds an array of architectures with values for both
    32 and 64 Intel in a dispatch_once to ensure that the initialization only occurs
    once, as we’ll invoke this function for every file any process has open ❶. Also,
    the code makes use of the @available Objective-C keyword to only add the ARM64
    architecture on versions of macOS that support it ❷.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`isBinary`函数构建了一个架构数组，包含32位和64位Intel架构的值，并在`dispatch_once`中确保初始化只执行一次，因为我们将为每个打开的文件调用此函数
    ❶。此外，代码利用`@available`关键字，仅在支持的macOS版本上添加ARM64架构 ❷。'
- en: 'Next, we extract the executable architecture of the passed-in file ❸, using
    the firstObjectCommonWithArray: method to check for any of the supported architectures
    ❹. If we find them, we can be sure that the open file is indeed a binary capable
    of executing on the macOS system. We add these binaries to a list of dynamic libraries
    that KnockKnock will shortly check for proxying capabilities.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提取传入文件的可执行架构 ❸，使用`firstObjectCommonWithArray:`方法检查是否包含任何受支持的架构 ❹。如果我们找到了这些架构，就可以确定打开的文件确实是一个能够在macOS系统上执行的二进制文件。我们将这些二进制文件添加到一个动态库列表中，KnockKnock将很快检查这些库的代理能力。
- en: KnockKnock also enumerates all running processes to extract the dependencies
    of the process’s main binary. Each of these dependencies is added to the list
    of libraries to check ([Listing 10-23](chapter10.xhtml#Lis10-23)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: KnockKnock还枚举所有正在运行的进程，以提取进程主二进制文件的依赖项。每个依赖项都会被添加到检查的库列表中（[Listing 10-23](chapter10.xhtml#Lis10-23)）。
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 10-23: Enumerating the dependencies of all running processes'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 10-23：枚举所有运行进程的依赖项
- en: To enumerate all running processes, the plug-in makes use of the proc _listallpids
    API discussed in [Chapter 1](chapter1.xhtml). Then, to extract each process’s
    dependencies, it invokes a method named enumLinkedDylibs, which iterates over
    each loaded process ❶, parses it using a Mach-O class I wrote based on code in
    [Chapter 2](chapter2.xhtml) ❷, and saves both strong and weak dependencies ❸.
    Finally, the function returns a list containing all dependencies found in all
    running processes ❹.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了枚举所有正在运行的进程，插件利用了在[第1章](chapter1.xhtml)中讨论的`proc_listallpids` API。然后，为了提取每个进程的依赖项，它调用了名为`enumLinkedDylibs`的方法，该方法遍历每个已加载的进程
    ❶，使用我基于[第2章](chapter2.xhtml)中的代码编写的Mach-O类对其进行解析 ❷，并保存强依赖和弱依赖 ❸。最后，函数返回一个包含所有运行进程中找到的依赖项的列表
    ❹。
- en: Next, we scan the list of libraries enumerated via lsof and via the running
    processes ([Listing 10-24](chapter10.xhtml#Lis10-24)).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们扫描通过`lsof`和正在运行的进程枚举的库列表（[Listing 10-24](chapter10.xhtml#Lis10-24)）。
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 10-24: Checking whether a binary is a dynamic library that (likely)
    performs proxying'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-24：检查一个二进制文件是否为动态库（可能）执行代理功能
- en: For each library to scan, the code snippet parses it via the Mach-O class ❶.
    Specifically, it checks the type of binary, ignoring any that aren’t explicitly
    dynamic libraries (identified by the MH_DYLIB type) ❷. For dynamic libraries,
    it checks and saves the library if it has a load command of type LC_REEXPORT_DYLIB
    ❸.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个要扫描的库，代码片段通过 Mach-O 类 ❶ 解析它。具体来说，它检查二进制文件的类型，忽略任何不是显式动态库的文件（通过 MH_DYLIB
    类型标识）❷。对于动态库，它检查并保存具有 LC_REEXPORT_DYLIB 类型加载命令的库 ❸。
- en: The method returns a list of any proxy libraries it finds so KnockKnock can
    display them to the user, either in the terminal or in the UI.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回它找到的任何代理库列表，以便 KnockKnock 可以将其显示给用户，无论是在终端还是用户界面中。
- en: Conclusion
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: Most Mac malware persists, so a tool that can enumerate persistently installed
    items can uncover even sophisticated or never-before-seen threats. In this chapter,
    we examined KnockKnock, a tool that provides this capability, leaving persistent
    Mac malware with almost no hope of remaining undetected. In the next chapter,
    we’ll explore persistence further and cover a tool capable of detecting persistent
    Mac malware in real time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Mac 恶意软件会持久化存在，因此能够列举持久安装项的工具可以发现即使是复杂的或从未见过的威胁。在本章中，我们研究了 KnockKnock，一个提供此功能的工具，它几乎没有给持久化的
    Mac 恶意软件留下未被检测到的机会。在下一章中，我们将进一步探讨持久化，并介绍一个能够实时检测持久化 Mac 恶意软件的工具。
- en: Notes
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: '[  1](#chapter10_1).  See [*https://<wbr>learn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/sysinternals<wbr>/downloads<wbr>/autoruns*](https://learn.microsoft.com/en-us/sysinternals/downloads/autoruns).'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  1](#chapter10_1)。  请参阅 [*https://<wbr>learn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/sysinternals<wbr>/downloads<wbr>/autoruns*](https://learn.microsoft.com/en-us/sysinternals/downloads/autoruns)。'
- en: '[  2](#chapter10_2).  See [*https://<wbr>web<wbr>.archive<wbr>.org<wbr>/web<wbr>/20180117193229<wbr>/https:<wbr>/<wbr>/github<wbr>.com<wbr>/synack<wbr>/knockknock*](https://web.archive.org/web/20180117193229/https://github.com/synack/knockknock).'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  2](#chapter10_2)。  请参阅 [*https://<wbr>web<wbr>.archive<wbr>.org<wbr>/web<wbr>/20180117193229<wbr>/https:<wbr>/<wbr>/github<wbr>.com<wbr>/synack<wbr>/knockknock*](https://web.archive.org/web/20180117193229/https://github.com/synack/knockknock)。'
- en: '[  3](#chapter10_3).  Csaba Fitzl, “Beyond the Good Ol’ LaunchAgents -32- Dock
    Tile Plugins,” *Theevilbit Blog*, September 28, 2023, [*https://<wbr>theevilbit<wbr>.github<wbr>.io<wbr>/beyond<wbr>/beyond<wbr>_0032<wbr>/*](https://theevilbit.github.io/beyond/beyond_0032/).'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  3](#chapter10_3)。  Csaba Fitzl, “超越传统的 LaunchAgents -32- Dock Tile 插件”，*Theevilbit
    博客*，2023年9月28日，[*https://<wbr>theevilbit<wbr>.github<wbr>.io<wbr>/beyond<wbr>/beyond<wbr>_0032<wbr>/*](https://theevilbit.github.io/beyond/beyond_0032/)。'
- en: '[  4](#chapter10_4).  “NSClassFromString(_:),” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/foundation<wbr>/1395135<wbr>-nsclassfromstring*](https://developer.apple.com/documentation/foundation/1395135-nsclassfromstring).'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  4](#chapter10_4)。  “NSClassFromString(_:),” Apple 开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/foundation<wbr>/1395135<wbr>-nsclassfromstring*](https://developer.apple.com/documentation/foundation/1395135-nsclassfromstring)。'
- en: '[  5](#chapter10_5).  You can read more about programmatic integration with
    VirusTotal in the service’s developer documentation at [*https://<wbr>docs<wbr>.virustotal<wbr>.com<wbr>/reference<wbr>/overview*](https://docs.virustotal.com/reference/overview).'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  5](#chapter10_5)。  你可以在服务的开发者文档中阅读更多关于与 VirusTotal 的编程集成，网址为 [*https://<wbr>docs<wbr>.virustotal<wbr>.com<wbr>/reference<wbr>/overview*](https://docs.virustotal.com/reference/overview)。'
- en: '[  6](#chapter10_6).  Patrick Wardle, “Methods of Malware Persistence on Mac
    OS X,” VirusBulletin, September 24, 2014, [*https://<wbr>www<wbr>.virusbulletin<wbr>.com<wbr>/uploads<wbr>/pdf<wbr>/conference<wbr>/vb2014<wbr>/VB2014<wbr>-Wardle<wbr>.pdf*](https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf).'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  6](#chapter10_6)。  Patrick Wardle, “Mac OS X 上恶意软件的持久化方法”，VirusBulletin，2014年9月24日，[*https://<wbr>www<wbr>.virusbulletin<wbr>.com<wbr>/uploads<wbr>/pdf<wbr>/conference<wbr>/vb2014<wbr>/VB2014<wbr>-Wardle<wbr>.pdf*](https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf)。'
- en: '[  7](#chapter10_7).  Patrick Wardle, *The Art of Mac Malware: The Guide to
    Analyzing Malicious Software*, Volume 1 (San Francisco: No Starch Press, 2022),
    36.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  7](#chapter10_7)。  Patrick Wardle, *Mac 恶意软件的艺术：分析恶意软件指南*，第一卷（旧金山：No Starch
    Press，2022年），第36页。'
- en: '[  8](#chapter10_8).  “Enumerate All Installed Applications on OS X,” Stack
    Overflow, [*https://<wbr>stackoverflow<wbr>.com<wbr>/questions<wbr>/15164132<wbr>/enumerate<wbr>-all<wbr>-installed<wbr>-applications<wbr>-on<wbr>-os<wbr>-x*](https://stackoverflow.com/questions/15164132/enumerate-all-installed-applications-on-os-x).'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  8](#chapter10_8).  “在OS X上枚举所有已安装的应用程序,” Stack Overflow, [*https://<wbr>stackoverflow<wbr>.com<wbr>/questions<wbr>/15164132<wbr>/enumerate<wbr>-all<wbr>-installed<wbr>-applications<wbr>-on<wbr>-os<wbr>-x*](https://stackoverflow.com/questions/15164132/enumerate-all-installed-applications-on-os-x)。'
- en: '[  9](#chapter10_9).  Wardle, *The Art of Mac Malware*, 1:36–37.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  9](#chapter10_9).  Wardle, *Mac恶意软件的艺术*, 1:36–37。'
- en: '[10](#chapter10_10).  See [*https://<wbr>github<wbr>.com<wbr>/EmpireProject<wbr>/EmPyre<wbr>/blob<wbr>/master<wbr>/lib<wbr>/modules<wbr>/persistence<wbr>/osx<wbr>/CreateHijacker<wbr>.py*](https://github.com/EmpireProject/EmPyre/blob/master/lib/modules/persistence/osx/CreateHijacker.py).'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[10](#chapter10_10).  参见 [*https://<wbr>github<wbr>.com<wbr>/EmpireProject<wbr>/EmPyre<wbr>/blob<wbr>/master<wbr>/lib<wbr>/modules<wbr>/persistence<wbr>/osx<wbr>/CreateHijacker<wbr>.py*](https://github.com/EmpireProject/EmPyre/blob/master/lib/modules/persistence/osx/CreateHijacker.py)。'
- en: '[11](#chapter10_11).  “CFBundleCopyExecutableArchitecturesForURL,” Apple Developer
    Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/corefoundation<wbr>/1537108<wbr>-cfbundlecopyexecutablearchitectu<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/corefoundation/1537108-cfbundlecopyexecutablearchitectu?language=objc).'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[11](#chapter10_11).  “CFBundleCopyExecutableArchitecturesForURL,” Apple开发者文档,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/corefoundation<wbr>/1537108<wbr>-cfbundlecopyexecutablearchitectu<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/corefoundation/1537108-cfbundlecopyexecutablearchitectu?language=objc)。'
