- en: Chapter 10. Device Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 设备安全
- en: Until now, we’ve focused on how Android implements sandboxing and privilege
    separation in order to isolate applications from one another and the core OS.
    In this chapter, we look at how Android ensures OS integrity and protects device
    data from attackers that have physical access to a device. We start with a brief
    description of Android’s bootloader and recovery OS, then discuss Android’s verified
    boot feature, which guarantees that the *system* partition is not modified by
    malicious programs. Next we look at how Android encrypts the *userdata* partition,
    which hosts OS configuration files and application data. This guarantees that
    the device can’t be booted without the decryption password and that user data
    can’t be extracted even by direct access to the device’s flash memory. We then
    show how Android’s screen locking functionality is implemented, and how unlock
    patterns, PINs, and passphrases are hashed and stored on the device.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经集中讨论了 Android 如何实现沙箱机制和权限隔离，以便将应用程序彼此隔离，并与核心操作系统分开。在本章中，我们将探讨 Android
    如何确保操作系统的完整性，并保护设备数据免受具有物理访问权限的攻击者的威胁。我们将从简要介绍 Android 的引导加载程序和恢复操作系统开始，然后讨论 Android
    的验证启动功能，它确保*系统*分区不会被恶意程序修改。接下来，我们将介绍 Android 如何加密*userdata*分区，该分区存储操作系统配置文件和应用程序数据。这确保了设备在没有解密密码的情况下无法启动，而且即使通过直接访问设备的闪存，也无法提取用户数据。然后，我们将展示
    Android 如何实现屏幕锁定功能，以及如何将解锁图案、PIN 码和密码短语进行哈希处理并存储在设备上。
- en: We’ll also discuss secure USB debugging, which authenticates hosts that connect
    to the *Android Debug Bridge (ADB)* daemon over USB and requires users to explicitly
    allow access for each host. Because ADB access over USB allows execution of privileged
    operations such as application installation, full backup, and filesystem access
    (including full access to external storage), this feature helps prevent unauthorized
    access to device data and applications on devices that have ADB debugging enabled.
    Finally, we describe the implementation and archive encryption format of Android’s
    full backup feature.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论安全的 USB 调试，它通过 USB 验证连接到*Android 调试桥 (ADB)* 守护进程的主机，并要求用户显式允许每个主机的访问权限。由于通过
    USB 进行 ADB 访问可以执行特权操作，如应用程序安装、完整备份和文件系统访问（包括对外部存储的完全访问），此功能有助于防止对启用了 ADB 调试的设备上的数据和应用程序进行未经授权的访问。最后，我们将描述
    Android 完整备份功能的实现以及存档加密格式。
- en: Controlling OS Boot-Up and Installation
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制操作系统启动和安装
- en: Given physical access to a device, an attacker can access or modify user and
    system data not only via higher-level OS constructs such as files and directories,
    but also by accessing memory or raw disk storage directly. Such direct access
    can be achieved by physically interfacing with the device’s electronic components
    by, for example, disassembling the device and connecting to hidden hardware debug
    interfaces or desoldering flash memory and reading the contents with a specialized
    device.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设备的物理访问权限，攻击者不仅可以通过更高级别的操作系统结构（如文件和目录）访问或修改用户和系统数据，还可以通过直接访问内存或原始磁盘存储来实现这一点。此类直接访问可以通过物理接口与设备的电子组件进行交互来实现，例如，拆解设备并连接到隐藏的硬件调试接口，或者将闪存拆焊下来并使用专用设备读取内容。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: '*Such hardware attacks are beyond the scope of this book; see [Chapter 10](ch10.html
    "Chapter 10. Device Security") of the* Android Hacker’s Handbook *(Wiley, 2014)
    for an introduction to this topic.*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*此类硬件攻击超出了本书的讨论范围；有关此主题的介绍，请参见《Android 黑客手册》（Wiley，2014）中的[第10章](ch10.html
    "第10章. 设备安全")。*'
- en: A less intrusive, but still powerful way to gain access to this data is to use
    the device update mechanism to modify system files and remove access restrictions,
    or boot an alternative operating system that allows direct access to storage devices.
    Most consumer Android devices are locked down by default so that those techniques
    are either not possible or require possession of a code signing key, typically
    available only to the device manufacturer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一种不太具侵入性，但仍然强大的获取数据访问权限的方法是使用设备更新机制修改系统文件并移除访问限制，或引导一个允许直接访问存储设备的替代操作系统。大多数消费级
    Android 设备默认是锁定的，因此这些技术要么不可行，要么需要持有代码签名密钥，通常只有设备制造商才能获得该密钥。
- en: In the next sections, we briefly discuss how Android’s bootloader and recovery
    OS regulate access to boot images and device update mechanisms. (We’ll explore
    bootloader and recovery functionality in more detail in [Chapter 13](ch13.html
    "Chapter 13. System Updates and Root Access").)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们简要讨论了Android的引导加载程序和恢复操作系统如何调控对引导镜像和设备更新机制的访问。（我们将在[第13章](ch13.html
    "第13章. 系统更新和root访问")中更详细地探讨引导加载程序和恢复功能。）
- en: Bootloader
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导加载程序
- en: A *bootloader* is a specialized, hardware-specific program that executes when
    a device is first powered on (coming out of reset for ARM devices). Its purpose
    is to initialize device hardware, optionally provide a minimal device configuration
    interface, and then find and start the operating system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*引导加载程序*是一个专门的、硬件特定的程序，在设备首次开机时执行（对于ARM设备，是从复位状态启动）。它的目的是初始化设备硬件，选择性地提供一个最小的设备配置接口，然后找到并启动操作系统。'
- en: Booting a device typically requires going through different stages, which may
    involve a separate bootloader for each stage—but we’ll refer to a single, aggregate
    bootloader that includes all boot stages, for the sake of simplicity. Android
    bootloaders are typically proprietary and specific to the system on a chip (SoC)
    that the device is built upon. Device and SoC manufacturers provide different
    functionality and levels of protection in their bootloaders, but most bootloaders
    support a *fastboot*, or more generally, *download mode*, which allows for the
    writing (usually called *flashing*) of raw partition images to the device’s persistent
    storage, as well as booting transient system images (without flashing them to
    the device). Fastboot mode is enabled by a special hardware key combination applied
    while the device is booting, or by sending the *reboot bootloader* command via
    ADB.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 启动设备通常需要经过不同的阶段，这可能涉及为每个阶段使用一个单独的引导加载程序——但为了简便起见，我们将统一称为一个包含所有引导阶段的整体引导加载程序。Android引导加载程序通常是专有的，并且针对设备所使用的芯片系统（SoC）特定。设备和SoC制造商在其引导加载程序中提供不同的功能和保护级别，但大多数引导加载程序支持*fastboot*，或者更一般来说，*下载模式*，它允许将原始分区镜像写入设备的持久存储，以及启动临时系统镜像（而不将其刷写到设备中）。fastboot模式通过在设备启动时按下特定的硬件键组合来启用，或者通过ADB发送*reboot
    bootloader*命令来启用。
- en: In order to ensure device integrity, consumer devices are shipped with locked
    bootloaders, which either disallow flashing and booting system images completely
    or allow it only for images that have been signed by the device manufacturer.
    Most consumer devices allow for unlocking the boot-loader, which removes fastboot
    restrictions and image signature checks. Unlocking the bootloader typically requires
    formatting the *userdata* partition, thus ensuring that a malicious OS image cannot
    get access to existing user data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保设备的完整性，消费类设备出厂时都会有锁定的引导加载程序，这会完全禁止刷写和启动系统镜像，或者仅允许启动经过设备制造商签名的镜像。大多数消费类设备支持解锁引导加载程序，这样可以去除fastboot限制和镜像签名检查。解锁引导加载程序通常需要格式化*userdata*分区，从而确保恶意的操作系统镜像无法访问现有的用户数据。
- en: On some devices, unlocking the bootloader is an irreversible procedure, but
    most devices provide a way to relock the bootloader and return it to its original
    state. This is typically implemented by storing a bootloader state flag on a dedicated
    system partition (typically called `param` or `misc`) that hosts various device
    metatdata. Relocking the bootloader simply resets the value of this flag.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些设备上，解锁引导加载程序是不可逆的过程，但大多数设备提供了一种重新锁定引导加载程序并恢复到原始状态的方法。这通常通过在一个专用的系统分区（通常叫做`param`或`misc`）上存储引导加载程序状态标志来实现，该分区托管着各种设备元数据。重新锁定引导加载程序只是简单地重置该标志的值。
- en: Recovery
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复
- en: A more flexible way to update a device is via its recovery OS. The *recovery
    OS*, or simply *recovery*, is a minimal Linux-based OS that includes a kernel,
    RAM disk with various low-level tools, and a minimal UI that is typically operated
    using the device’s hardware buttons. The recovery is used to apply post-ship updates,
    generally delivered in the form of over-the-air (OTA) update packages. OTA packages
    include the new versions (or a binary patch) of updated system files and a script
    that applies the update. As we learned in [Chapter 3](ch03.html "Chapter 3. Package
    Management"), OTA files are also code signed with the private key of the device
    manufacturer. The recovery includes the public part of that key and verifies OTA
    files before applying them. This ensures that only OTA files that originate from
    a trusted party can modify the device OS.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 更新设备的一个更灵活的方式是通过其恢复操作系统。*恢复操作系统*，简称*恢复*，是一个基于 Linux 的最小操作系统，包括一个内核、带有各种低级工具的
    RAM 磁盘和一个最小的用户界面，通常使用设备的硬件按钮操作。恢复操作系统用于应用出厂后更新，通常以无线（OTA）更新包的形式交付。OTA 包包含更新的系统文件的新版本（或二进制补丁）以及一个应用更新的脚本。正如我们在[第
    3 章](ch03.html "第 3 章 包管理")中了解到的那样，OTA 文件也经过设备制造商私钥的代码签名。恢复操作系统包含该密钥的公钥部分，并在应用
    OTA 文件之前对其进行验证。这确保只有来自受信任方的 OTA 文件才能修改设备操作系统。
- en: The recovery OS is stored on a dedicated partition, just like the main Android
    OS. Therefore, it can be replaced by putting the bootloader into download mode
    and flashing a custom recovery image, which replaces the embedded public key,
    or does not verify OTA signatures at all. Such a recovery OS allows the main OS
    to be completely replaced with a build produced by a third party. A custom recovery
    OS can also allow unrestricted root access via ADB, as well as raw partition data
    acquisition. While the *userdata* partition could be encrypted (see “[Disk Encryption](ch10.html#disk_encryption
    "Disk Encryption")”), making direct data access impossible, it is trivial to install
    a malicious program (rootkit) on the *system* partition while in recovery mode.
    The rootkit can then enable remote access to the device when the main OS is booted
    and thus allow access to user data that is transparently decrypted when the main
    OS boots. Verified boot (discussed in the next section) can prevent this, but
    only if the device verifies the *boot* partition using an unmodifiable verification
    key, stored in hardware.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复操作系统存储在一个专用分区上，类似于主 Android 操作系统。因此，可以通过将引导加载程序置于下载模式并刷入自定义恢复镜像来替换它，从而替换嵌入的公钥，或者根本不验证
    OTA 签名。这样的恢复操作系统允许将主操作系统完全替换为第三方生成的构建。自定义恢复操作系统还可以通过 ADB 允许无限制的 root 访问，以及获取原始分区数据。虽然*userdata*分区可以被加密（参见“[磁盘加密](ch10.html#disk_encryption
    "磁盘加密")”），使直接数据访问变得不可能，但在恢复模式下安装恶意程序（rootkit）到*system*分区是很简单的。然后，rootkit 可以在主操作系统启动时启用远程访问，从而允许访问用户数据，这些数据在主操作系统启动时会透明解密。验证启动（在下一节讨论）可以防止这种情况，但前提是设备使用存储在硬件中的不可修改的验证密钥验证*boot*分区。
- en: An unlocked bootloader allows booting or flashing custom system images and direct
    access to system partitions. While Android security features such as verified
    boot and disk encryption can limit the damage that a malicious system image flashed
    via an unlocked bootloader can do, controlling access to the bootloader is integral
    to protecting an Android device. Therefore the bootloader should only be unlocked
    on test or development devices, or relocked and returned to its original state
    immediately after modifying the system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 解锁的引导加载程序允许启动或刷入自定义系统镜像，并直接访问系统分区。虽然像验证启动和磁盘加密等 Android 安全功能可以限制通过解锁的引导加载程序刷入的恶意系统镜像所造成的损害，但控制对引导加载程序的访问对于保护
    Android 设备至关重要。因此，只有在测试或开发设备上才应解锁引导加载程序，或者在修改系统后立即将其重新锁定并恢复到原始状态。
- en: Verified Boot
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证启动
- en: Android’s verified boot implementation is based on the dm-verity device-mapper
    block integrity checking target.^([[100](#ftn.ch10fn01)]) *Device-mapper*^([[101](#ftn.ch10fn02)])
    is a Linux kernel framework that provides a generic way to implement virtual block
    devices. It’s the basis of Linux’s Logical Volume Manager (LVM), and it’s used
    to implement full-disk encryption (using the dm-crypt target), RAID arrays, and
    even distributed replicated storage.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的验证启动实现基于 dm-verity 设备映射器块完整性检查目标。^([[100](#ftn.ch10fn01)]) *设备映射器*^([[101](#ftn.ch10fn02)])
    是 Linux 内核框架，提供了一种实现虚拟块设备的通用方式。它是 Linux 逻辑卷管理器（LVM）的基础，且用于实现全盘加密（使用 dm-crypt 目标）、RAID
    阵列，甚至分布式复制存储。
- en: Device-mapper works by essentially mapping a virtual block device to one or
    more physical block devices and optionally modifying transferred data in transit.
    For example, dm-crypt (which is also the basis of Android’s *userdata* partition
    encryption, as discussed in “[Disk Encryption](ch10.html#disk_encryption "Disk
    Encryption")”) decrypts read physical blocks and encrypts written blocks before
    committing them to disk. Thus, disk encryption is transparent to users of the
    virtual dm-crypt block device. Device-mapper targets can be stacked on top of
    each other, making it possible to implement complex data transformations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Device-mapper 的工作原理本质上是将一个虚拟块设备映射到一个或多个物理块设备，并在数据传输过程中选择性地修改传输的数据。例如，dm-crypt（它也是
    Android 的*userdata* 分区加密的基础，如 “[磁盘加密](ch10.html#disk_encryption "Disk Encryption")”中讨论的）在将读取的物理块写入磁盘前会先解密，并对写入的块进行加密。因此，磁盘加密对虚拟
    dm-crypt 块设备的用户是透明的。Device-mapper 目标可以叠加使用，使得实现复杂的数据转换成为可能。
- en: dm-verity Overview
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dm-verity 概述
- en: Because dm-verity is a block integrity checking target, it transparently verifies
    the integrity of each device block as it’s being read from disk. If the block
    checks out, the read succeeds; if not, the read generates an I/O error as if the
    block were physically corrupted.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 dm-verity 是一个块完整性检查工具，它在从磁盘读取每个设备块时会透明地验证该块的完整性。如果块完整性检查通过，则读取成功；如果不通过，则读取会产生
    I/O 错误，仿佛该块已被物理损坏。
- en: Under the hood, dm-verity is implemented using a precalculated hash tree (also
    called a *Merkle tree*) that includes the hashes of all device blocks. The leaf
    nodes of the tree include hashes of physical device blocks, while intermediate
    nodes are hashes of their child nodes (hashes of hashes). The root node is called
    the *root hash* and is based on all hashes in lower levels, as shown in [Figure 10-1](ch10.html#dm-verity_hash_tree
    "Figure 10-1. dm-verity hash tree"). Thus, a change even in a single device block
    will result in a change of the root hash, and in order to verify that a hash tree
    is genuine we only need to verify its root hash.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层实现中，dm-verity 使用预先计算的哈希树（也叫*Merkle 树*），其中包含了所有设备块的哈希值。树的叶子节点包括物理设备块的哈希值，而中间节点则是它们子节点的哈希值（哈希的哈希）。根节点被称为*根哈希*，它基于所有下层节点的哈希值，如[图
    10-1](ch10.html#dm-verity_hash_tree "图 10-1. dm-verity 哈希树")所示。因此，即使是单个设备块的变化，也会导致根哈希的变化。为了验证哈希树的真实性，我们只需要验证其根哈希。
- en: At runtime, dm-verity calculates the hash of each block when it’s read and verifies
    it by traversing the precalculated hash tree. Because reading data from a physical
    device is already a time-consuming operation, the latency added by hashing and
    verification is relatively low. Furthermore, once verified, disk blocks are cached,
    and subsequent reads of the same block do not trigger integrity verification.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，dm-verity 会在读取每个块时计算哈希，并通过遍历预先计算的哈希树进行验证。由于从物理设备读取数据本身就是一项耗时操作，因此哈希计算和验证带来的延迟相对较低。此外，一旦验证通过，磁盘块会被缓存，之后对同一块的读取将不再触发完整性验证。
- en: '![dm-verity hash tree](figs/web/10fig01.png.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![dm-verity 哈希树](figs/web/10fig01.png.jpg)'
- en: Figure 10-1. dm-verity hash tree
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1. dm-verity 哈希树
- en: Because dm-verity depends on a precalculated hash tree over all blocks of a
    device, the underlying device must be mounted read-only in order for verification
    to be possible. Most filesystems record mount times and other metadata in their
    superblock, so even if no files are changed at runtime, block integrity checks
    will fail if the underlying block device is mounted read-write. Even though this
    can be seen as a limitation, it works well for devices or partitions that hold
    system files, which are only changed by OS updates. Any other change indicates
    either OS or disk corruption, or that a malicious program is trying to modify
    the OS or masquerade as a system file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 dm-verity 依赖于一个覆盖设备所有块的预计算哈希树，因此底层设备必须以只读方式挂载，才能进行验证。大多数文件系统会在其超级块中记录挂载时间和其他元数据，因此即使在运行时没有更改任何文件，如果底层块设备以可读写方式挂载，块完整性检查也会失败。尽管这可以视为一种限制，但它对于存储系统文件的设备或分区而言效果很好，因为系统文件只会在操作系统更新时发生变化。任何其他变化都可能意味着操作系统或磁盘损坏，或是恶意程序试图修改操作系统或伪装成系统文件。
- en: Ultimately, dm-verity’s read-only requirement fits well with Android’s security
    model, which hosts only application data on a read-write partition and keeps OS
    files on the read-only *system* partition.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，dm-verity 的只读要求非常符合 Android 的安全模型，该模型仅将应用数据保存在可读写分区上，并将操作系统文件保存在只读的*system*
    分区中。
- en: Android Implementation
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 实现
- en: The dm-verity device-mapper target was originally developed in order to implement
    verified boot in Chrome OS and was integrated into the mainline Linux kernel in
    version 3.4\. It’s enabled with the `CONFIG_DM_VERITY` kernel configuration item.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: dm-verity设备映射器目标最初是为实现Chrome OS的已验证启动而开发的，并在Linux内核3.4版本中集成。通过`CONFIG_DM_VERITY`内核配置项启用。
- en: Like Chrome OS, Android 4.4 also uses the dm-verity target, but the cryptographic
    verification of the root hash and mounting of verified partitions are implemented
    differently. The RSA public key used for verification is embedded in the boot
    partition under the *verity_key* filename and is used to verify the dm-verity
    mapping table, which holds the locations of the target device and the offset of
    the hash table, as well as the root hash and salt.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 像Chrome OS一样，Android 4.4也使用dm-verity目标，但根哈希的加密验证和已验证分区的挂载实现方式有所不同。用于验证的RSA公钥嵌入在启动分区下的*verity_key*文件名中，并用于验证dm-verity映射表，该表保存目标设备的位置和哈希表的偏移量，以及根哈希和盐值。
- en: The mapping table and its signature are part of the verity metadata block, which
    is written to disk directly after the last filesystem block of the target device.
    A partition is marked as verifiable by adding the `verify` flag to the Android-specific
    *fs_mgr_flags* field of the device’s *fstab* file. When Android’s filesystem manager
    encounters the `verify` flag in *fstab*, it loads the verity metadata from the
    block device specified in *fstab* and verifies its signature using the included
    verity key. If the signature check succeeds, the filesystem manager parses the
    dm-verity mapping table and passes it to the Linux device-mapper, which uses the
    information contained in the mapping table in order to create a virtual dm-verity
    block device. This virtual block device is then mounted at the mount point specified
    in *fstab* in place of the corresponding physical device. As a result, all reads
    from the underlying physical device are transparently verified against the pre-generated
    hash tree. Modifying or adding files, or even remounting the partition as read-write
    results in an integrity verification and an I/O error.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 映射表及其签名是verity元数据块的一部分，该元数据块在目标设备的最后一个文件系统块后直接写入磁盘。通过将`verify`标志添加到设备的*fstab*文件中的Android特定*fs_mgr_flags*字段，可以将分区标记为可验证。当Android的文件系统管理器在*fstab*中遇到`verify`标志时，它会从*fstab*中指定的块设备加载verity元数据，并使用包含的verity密钥验证其签名。如果签名检查成功，文件系统管理器会解析dm-verity映射表，并将其传递给Linux设备映射器，后者使用映射表中的信息创建一个虚拟的dm-verity块设备。然后，这个虚拟块设备会被挂载到*fstab*中指定的挂载点，替代相应的物理设备。因此，对底层物理设备的所有读取操作都会透明地与预生成的哈希树进行验证。修改或添加文件，甚至重新挂载分区为读写模式，会导致完整性验证失败并发生I/O错误。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Because dm-verity is a kernel feature, in order for its integrity protection
    to be effective, the kernel that the device boots needs to be trusted. On Android,
    this requires verifying the boot partition, which also contains the root filesystem
    RAM disk (*initrd*) and the verity public key. Kernel or boot image verification
    is a device-specific process, which is typically implemented in the device bootloader
    and relies on an unmodifiable signature verification key stored in hardware.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于dm-verity是内核功能，因此为了使其完整性保护有效，设备启动时使用的内核需要是可信的。在Android上，这要求验证启动分区，其中还包含根文件系统RAM磁盘（*initrd*）和verity公钥。内核或启动镜像验证是设备特定的过程，通常由设备的引导加载程序实现，并依赖于存储在硬件中的不可修改的签名验证密钥。*'
- en: Enabling Verified Boot
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用已验证的启动
- en: The official Android documentation describes the procedure required to enable
    verified boot on Android as a multi-step process, which involves generating a
    hash tree, creating a dm-verity mapping table for the hash tree, signing the table,
    and generating and writing a verity metadata block to the target device.^([[102](#ftn.ch10fn03)])
    In this section, we briefly describe the key steps of this process.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 官方Android文档描述了启用Android已验证启动所需的过程，这是一个多步骤的过程，包括生成哈希树、为哈希树创建dm-verity映射表、签署该表，并生成并写入verity元数据块到目标设备。^([[102](#ftn.ch10fn03)])
    在本节中，我们简要描述了这个过程的关键步骤。
- en: A dm-verity hash tree is generated with the `veritysetup` program, which is
    part of the *cryptsetup* cryptographic volume management tools package. The `veritysetup`
    program can operate directly on block devices or generate a hash tree using a
    filesystem image, and write the hash table to a file. Android’s dm-verity implementation
    expects that the hash tree data to be stored on the same device as the target
    filesystem, so an explicit hash offset that points to a location after the verity
    metadata block must be specified when invoking `veritysetup`. [Figure 10-2](ch10.html#layout_of_a_disk_partition_prepared_for
    "Figure 10-2. Layout of a disk partition prepared for dm-verity verification")
    shows the layout of a disk partition prepared for use with dm-verity.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: dm-verity 哈希树是通过 `veritysetup` 程序生成的，该程序是 *cryptsetup* 加密卷管理工具包的一部分。`veritysetup`
    程序可以直接在块设备上操作，或者使用文件系统镜像生成哈希树，并将哈希表写入文件。Android 的 dm-verity 实现要求哈希树数据存储在与目标文件系统相同的设备上，因此在调用
    `veritysetup` 时必须指定一个明确的哈希偏移量，该偏移量指向 verity 元数据块之后的位置。[图 10-2](ch10.html#layout_of_a_disk_partition_prepared_for
    "图 10-2. 为 dm-verity 验证准备的磁盘分区布局") 显示了为 dm-verity 验证准备的磁盘分区布局。
- en: '![Layout of a disk partition prepared for dm-verity verification](figs/web/10fig02.png.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![为 dm-verity 验证准备的磁盘分区布局](figs/web/10fig02.png.jpg)'
- en: Figure 10-2. Layout of a disk partition prepared for dm-verity verification
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-2. 为 dm-verity 验证准备的磁盘分区布局
- en: Generating the hash tree produces the root hash, which is used to build the
    dm-verity mapping table for the target device. A sample mapping table is shown
    in [Example 10-1](ch10.html#android_dm-verity_device_mapping_table "Example 10-1. Android
    dm-verity device mapping table").
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 生成哈希树会产生根哈希，该根哈希用于构建目标设备的 dm-verity 映射表。一个示例映射表显示在 [示例 10-1](ch10.html#android_dm-verity_device_mapping_table
    "示例 10-1. Android dm-verity 设备映射表") 中。
- en: Example 10-1. Android dm-verity device mapping table
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-1. Android dm-verity 设备映射表
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As shown in the listing, the table is a single line (split across multiple lines
    for readability) that, besides the root hash ➒, contains the dm-verity version
    ➊, name of the underlying data and hash device (➋ and ➌), data and hash block
    sizes (➍ and ➎), data and hash disk offsets (➏ and ➐), hash algorithm ➑, and salt
    ➓.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表所示，该表格为一行（为了可读性而分为多行），除了根哈希 ➒ 外，还包含了 dm-verity 版本 ➊、底层数据和哈希设备的名称（➋ 和 ➌）、数据和哈希块大小（➍
    和 ➎）、数据和哈希磁盘偏移量（➏ 和 ➐）、哈希算法 ➑，以及盐值 ➓。
- en: The mapping table is signed using a 2048-bit RSA key, and along with the resulting
    PKCS#1 v1.5 signature, is used to form the 32 KB verity metadata block. [Table 10-1](ch10.html#verity_metadata_block_contents
    "Table 10-1. Verity Metadata Block Contents") shows the contents and size of each
    field of the metadata block.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 映射表使用 2048 位 RSA 密钥进行签名，并与生成的 PKCS#1 v1.5 签名一起，用于形成 32 KB 的 verity 元数据块。[表 10-1](ch10.html#verity_metadata_block_contents
    "表 10-1. Verity 元数据块内容") 显示了元数据块每个字段的内容和大小。
- en: Table 10-1. Verity Metadata Block Contents
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-1. Verity 元数据块内容
- en: '| Field | Description | Size | Value |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 描述 | 大小 | 值 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Magic number | Used by fs_mgr as a sanity check | 4 bytes | 0xb001b001 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 魔数 | fs_mgr 用于完整性检查 | 4 字节 | 0xb001b001 |'
- en: '| Version | Metadata block version | 4 bytes | Currently 0 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 元数据块版本 | 4 字节 | 当前为 0 |'
- en: '| Signature | Mapping table signature (PKCS#1 v1.5) | 256 bytes |   |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 签名 | 映射表签名（PKCS#1 v1.5） | 256 字节 |   |'
- en: '| Mapping table length | Mapping table length in bytes | 4 bytes |   |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 映射表长度 | 映射表的字节长度 | 4 字节 |   |'
- en: '| Mapping table | dm-verity mapping table | variable |   |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 映射表 | dm-verity 映射表 | 可变 |   |'
- en: '| Padding | Zero-byte padding to 32k byte length | variable |   |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 填充 | 填充为 32k 字节长度的零字节 | 可变 |   |'
- en: The RSA public key used for verification needs to be in mincrypt format (a minimalistic
    cryptographic library, also used by the stock recovery when verifying OTA file
    signatures), which is a serialization of mincrypt’s `RSAPublicKey` structure.
    The interesting thing about this structure is that it doesn’t simply include the
    key’s modulus and public exponent values, but contains pre-computed values used
    by mincrypt’s RSA implementation (based on Montgomery reduction). The public key
    is included in the root of the boot image under the *verity_key* filename.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 用于验证的 RSA 公钥需要采用 mincrypt 格式（一个简化的加密库，也在 stock recovery 中用于验证 OTA 文件签名），该格式是
    mincrypt 的 `RSAPublicKey` 结构的序列化版本。这个结构的有趣之处在于，它不仅包含公钥的模数和公有指数值，还包含了 mincrypt
    RSA 实现（基于 Montgomery 减法）所使用的预计算值。公钥包含在启动镜像的根目录下，文件名为 *verity_key*。
- en: The last step needed to enable verified boot is to modify the device’s *fstab*
    file in order to enable block integrity verification for the *system* partition.
    This is simply a matter of adding the `verify` flag, as shown in [Example 10-2](ch10.html#fstab_entry_for_a_dm-verity-formatted_pa
    "Example 10-2. fstab entry for a dm-verity-formatted partition verified") (example
    *fstab* file for Nexus 4).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 启用验证启动的最后一步是修改设备的 *fstab* 文件，以启用 *system* 分区的块完整性验证。这只是简单地添加 `verify` 标志，如 [示例
    10-2](ch10.html#fstab_entry_for_a_dm-verity-formatted_pa "示例 10-2. dm-verity 格式化分区的
    fstab 条目已验证")（Nexus 4 的示例 *fstab* 文件）所示。
- en: Example 10-2. fstab entry for a dm-verity-formatted partition verified
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-2. 已验证的 dm-verity 格式化分区的 fstab 条目
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the device boots, Android automatically creates a virtual dm-verity device
    based on the *fstab* entry and the information in the mapping table (contained
    in the metadata block), and mounts it at */system* as shown in [Example 10-3](ch10.html#dm-verity_virutal_block_device_mounted_a
    "Example 10-3. dm-verity virutal block device mounted at /system").
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备启动时，Android 会根据 *fstab* 条目和映射表（包含在元数据块中）的信息自动创建一个虚拟的 dm-verity 设备，并将其挂载到
    */system*，如 [示例 10-3](ch10.html#dm-verity_virutal_block_device_mounted_a "示例 10-3.
    dm-verity 虚拟块设备挂载到 /system") 所示。
- en: Example 10-3. dm-verity virutal block device mounted at /system
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-3. dm-verity 虚拟块设备挂载到 /system
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, any modifications to the system partition will result in read errors when
    reading the corresponding file(s). Unfortunately, system modifications by file-based
    OTA updates, which modify file blocks without updating verity metadata, also invalidate
    the hash tree. As mentioned in the official documentation, in order to be compatible
    with dm-verity-based verified boot, OTA updates should operate at the block level,
    ensuring that both file blocks and the hash tree and metadata are updated. This
    requires changing the current OTA update infrastructure, which is probably one
    of the reasons verified boot has yet to be deployed to production devices.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何对系统分区的修改都会导致读取相应文件时出现读取错误。不幸的是，通过基于文件的 OTA 更新进行的系统修改会修改文件块而不更新 verity 元数据，这也会使哈希树无效。正如官方文档中所提到的，为了与基于
    dm-verity 的验证启动兼容，OTA 更新应在块级别操作，确保同时更新文件块、哈希树和元数据。这需要更改当前的 OTA 更新基础设施，这可能是验证启动尚未部署到生产设备的原因之一。
- en: Disk Encryption
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 磁盘加密
- en: Android 3.0 introduced disk encryption along with device administrator policies
    (see [Chapter 9](ch09.html "Chapter 9. Enterprise Security") for details) that
    can enforce mandatory device encryption as one of the several “enhancements for
    the enterprise” included in that release. Disk encryption has been available in
    all subsequent versions with relatively few changes until version 4.4, which introduced
    a new key derivation function (scrypt). This section describes how Android implements
    disk encryption and how encryption keys and meta-data are stored and managed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Android 3.0 引入了磁盘加密以及设备管理员策略（详细信息请参见 [第 9 章](ch09.html "第 9 章. 企业安全")），可以强制执行设备加密，作为该版本中包含的若干“企业增强功能”之一。磁盘加密在随后的所有版本中都有提供，直到
    4.4 版本，才引入了一种新的密钥衍生函数（scrypt）。本节描述了 Android 如何实现磁盘加密，以及如何存储和管理加密密钥和元数据。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The Android Compatibility Definition requires that “IF the device has lockscreen,
    the device MUST support full-disk encryption.”*^([[103](#ftn.ch10fn04)])'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*Android 兼容性定义要求“如果设备具有锁屏功能，则设备必须支持全盘加密。”*^([[103](#ftn.ch10fn04)])'
- en: '*Disk encryption* uses an encryption algorithm to convert every bit of data
    that goes to disk to ciphertext, ensuring that data cannot be read from the disk
    without the decryption key. *Full-disk encryption (FDE)* promises that everything
    on disk is encrypted, including operating system files, cache, and temporary files.
    In practice, a small part of the OS, or a separate OS loader, must be kept unencrypted
    so that it can obtain the decryption key and then decrypt and mount the disk volume(s)
    used by the main OS. The disk decryption key is usually stored encrypted and requires
    an additional key encryption key (KEK) in order to be decrypted. The KEK can either
    be stored in a hardware module, such as a smart card or a TPM, or derived from
    a passphrase obtained from the user on each boot. When stored in a hardware module,
    the KEK can also be protected by a user-supplied PIN or password.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*磁盘加密*使用加密算法将写入磁盘的每一位数据转换为密文，确保没有解密密钥就无法从磁盘读取数据。*全盘加密（FDE）*承诺将磁盘上的所有内容加密，包括操作系统文件、缓存和临时文件。实际上，操作系统的一个小部分或单独的操作系统加载器必须保持未加密，以便它能够获取解密密钥，然后解密并挂载主操作系统使用的磁盘卷。磁盘解密密钥通常是加密存储的，并且需要额外的密钥加密密钥（KEK）才能解密。KEK可以存储在硬件模块中，例如智能卡或TPM，或者从用户在每次启动时提供的口令中派生。当存储在硬件模块中时，KEK还可以通过用户提供的PIN或密码进行保护。'
- en: Android’s FDE implementation encrypts only the *userdata* partition, which stores
    system configuration files and application data. The *boot* and *system* partitions,
    which store the kernel and OS files, are not encrypted, but *system* can optionally
    be verified using the dm-verity device-mapper target as described earlier in “[Verified
    Boot](ch10.html#verified_boot-id00021 "Verified Boot")”. Android’s disk encryption
    is not enabled by default, and the disk encryption process must be triggered either
    by the user or by a device policy on managed devices. We examine Android’s disk
    encryption implementation in the following sections.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Android的FDE实现仅加密*userdata*分区，该分区存储系统配置文件和应用数据。*boot*和*system*分区存储内核和操作系统文件，这些分区不加密，但*system*可以选择性地使用dm-verity设备映射目标进行验证，正如我们在“[验证启动](ch10.html#verified_boot-id00021
    "验证启动")”中所描述的那样。Android的磁盘加密默认未启用，必须通过用户或托管设备上的设备策略触发加密过程。我们将在以下部分中讨论Android的磁盘加密实现。
- en: Cipher Mode
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码模式
- en: Android’s disk encryption uses dm-crypt,^([[104](#ftn.ch10fn05)]) currently
    the standard disk encryption subsystem in the Linux kernel. Like dm-verity, dm-crypt
    is a device-mapper target that maps an encrypted physical block device to a virtual
    device-mapper device. All data access to the virtual device is decrypted (for
    reads) or encrypted (for writes) transparently.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Android的磁盘加密使用dm-crypt，^([[104](#ftn.ch10fn05)])目前是Linux内核中的标准磁盘加密子系统。与dm-verity类似，dm-crypt是一个设备映射目标，将加密的物理块设备映射到虚拟设备映射设备。所有对虚拟设备的访问都被透明地解密（读取）或加密（写入）。
- en: The encryption mechanism employed in Android uses a randomly generated 128-bit
    key together with AES in CBC mode. As we learned in [Chapter 5](ch05.html "Chapter 5. Cryptographic
    Providers"), CBC mode requires an initialization vector (IV) that needs to be
    both random and unpredictable in order for encryption to be secure. This presents
    a problem when encrypting block devices, because blocks are accessed non-sequentially,
    and therefore each sector (or device block) requires a separate IV.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Android中使用的加密机制采用随机生成的128位密钥，并结合AES的CBC模式。如我们在[第5章](ch05.html "第5章：加密提供者")中所学，CBC模式需要一个初始化向量（IV），这个向量必须既随机又不可预测，才能确保加密的安全性。当加密块设备时，这就成了一个问题，因为块设备是非顺序访问的，因此每个扇区（或设备块）都需要一个单独的IV。
- en: Android uses the encrypted salt-sector initialization vector (ESSIV) method
    with the SHA-256 hash algorithm (ESSIV:SHA256) in order to generate per-sector
    IVs. ESSIV employs a hash algorithm to derive a secondary key *s* from the disk
    encryption key *K*, called a *salt*. It then uses the salt as an encryption key
    and encrypts the sector number *SN* of each sector to produce a per-sector IV.
    In other words, *IV(SN) = AES[s](SN)*, where *s = SHA256(K)*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Android使用加密盐扇区初始化向量（ESSIV）方法，并结合SHA-256哈希算法（ESSIV:SHA256）来生成每个扇区的IV。ESSIV利用哈希算法从磁盘加密密钥*K*中派生出一个次级密钥*s*，称为*盐*。然后，使用盐作为加密密钥，并加密每个扇区的扇区号*SN*，生成每个扇区的IV。换句话说，*IV(SN)
    = AES[s](SN)*，其中*s = SHA256(K)*。
- en: Because the IV of each sector depends on a secret piece of information (the
    disk encryption key), per-sector IVs cannot be deduced by an attacker. However,
    ESSIV does not change CBC’s malleability property and does not ensure the integrity
    of encrypted blocks. In fact, it’s been demonstrated that an attacker who knows
    the original plaintext stored on disk can manipulate stored data and even inject
    a backdoor on volumes that use CBC for disk encryption.^([[105](#ftn.ch10fn06)])
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个扇区的初始化向量（IV）依赖于一个秘密信息（磁盘加密密钥），攻击者无法推断出每个扇区的 IV。然而，ESSIV 并没有改变 CBC 的可变性特性，也没有确保加密块的完整性。事实上，已经证明，如果攻击者知道原始的明文存储在磁盘上，便可以操纵存储的数据，甚至在使用
    CBC 进行磁盘加密的卷上注入后门。^([[105](#ftn.ch10fn06)])
- en: 'Alternative Ciper Modes: XTS'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 替代密码模式：XTS
- en: This particular attack against the ESSIV mode can be avoided by switching to
    a tweakable encryption cipher mode such as XTS (XEX-based tweaked-codebook mode
    with ciphertext stealing), which uses a combination of the sector address and
    index of the cipher block inside the sector to derive a unique “tweak” (variable
    parameter) for each sector.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 针对 ESSIV 模式的这一特定攻击可以通过切换到一种可变加密密码模式来避免，例如 XTS（基于 XEX 的带有密文偷取的变动代码簿模式），该模式使用扇区地址和扇区内加密块的索引的组合来派生每个扇区的唯一“变动值”（变量参数）。
- en: 'Using a distinct tweak for each sector has the same effect as encrypting each
    sector with a unique key: the same plaintext will result in different ciphertext
    when stored in different sectors, but has much better performance than deriving
    a separate key (or IV) for each sector. However, while better than the CBC ESSIV
    mode, XTS is still susceptible to data manipulation in some cases and does not
    provide ciphertext authentication.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个扇区使用不同的变动值与为每个扇区加密一个唯一的密钥效果相同：相同的明文在不同扇区存储时会生成不同的密文，但比为每个扇区派生独立的密钥（或 IV）要具有更好的性能。然而，尽管比
    CBC ESSIV 模式更好，XTS 在某些情况下仍然容易受到数据篡改的攻击，并且没有提供密文认证。
- en: As of this writing, Android does not support the XTS mode for disk encryption.
    However, the underlying dm-crypt device-mapper target supports XTS, and it can
    easily be enabled with some modifications to Android’s volume daemon (*vold*)
    implementation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，Android 不支持用于磁盘加密的 XTS 模式。然而，底层的 dm-crypt 设备映射器目标支持 XTS，并且可以通过对 Android
    卷守护进程（*vold*）实现进行一些修改轻松启用。
- en: Key Derivation
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密钥派生
- en: The disk encryption key (called the “master key” in Android source code) is
    encrypted with another 128-bit AES key (KEK), derived from a user-supplied password.
    In Android versions 3.0 to 4.3, the key derivation function used was PBKDF2 with
    2,000 iterations and a 128-bit random salt value. The resulting encrypted master
    key and the salt are stored, along with other metadata like the number of failed
    decryption attempts, in a footer structure occupying the last 16 KB of the encrypted
    partition, called a *crypto footer*. Storing an encrypted key on disk instead
    of using a key derived from the user-supplied password directly allows for changing
    the decryption password quickly, because the only thing that needs to be re-encrypted
    with the key derived from the new password is the master key (16 bytes).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘加密密钥（在 Android 源代码中称为“主密钥”）使用另一个 128 位 AES 密钥（KEK）加密，该密钥由用户提供的密码派生。在 Android
    3.0 至 4.3 版本中，使用的密钥派生函数是 PBKDF2，迭代次数为 2,000 次，且随机盐值为 128 位。加密后的主密钥和盐值与其他元数据（例如失败的解密尝试次数）一起存储在加密分区的最后
    16 KB 中的页脚结构中，称为 *crypto footer*。将加密密钥存储在磁盘上，而不是直接使用从用户提供的密码派生的密钥，可以快速更改解密密码，因为唯一需要使用新密码派生的密钥重新加密的是主密钥（16
    字节）。
- en: While using a random salt makes it impossible to use precomputed tables to speed
    up key cracking, the number of iterations (2,000) used for PBKDF2 is not sufficiently
    large by today’s standards. (The keystore key derivation process uses 8,192 iterations
    as discussed in [Chapter 7](ch07.html "Chapter 7. Credential Storage"). Backup
    encryption uses 10,000 iterations, as discussed later in “[Android Backup](ch10.html#android_backup
    "Android Backup")”.) Additionally, PBKDF2 is an iterative algorithm, based on
    standard and relatively easy to implement hash functions, which makes it possible
    for PBKDF2 key derivation to be parallelized, taking full advantage of the processing
    power of multi-core devices such as GPUs. This allows even fairly complex alphanumeric
    passphrases to be brute-forced in a matter of days, or even hours.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用随机盐值使得无法使用预计算表来加速密钥破解，但PBKDF2使用的迭代次数（2000次）在今天的标准下已经不够大。（密钥库密钥派生过程使用了8192次迭代，详细内容见[第7章](ch07.html
    "第7章。凭据存储")。备份加密使用了10000次迭代，稍后会在“[Android备份](ch10.html#android_backup "Android备份")”中讨论。）此外，PBKDF2是一种迭代算法，基于标准且相对容易实现的哈希函数，这使得PBKDF2的密钥派生可以并行化，充分利用多核设备如GPU的处理能力。这使得即便是相当复杂的字母数字密码，也能够在几天甚至几小时内被暴力破解。
- en: In order to make it harder to brute-force disk encryption passwords, Android
    4.4 introduced support for a new key derivation function called *scrypt*.^([[106](#ftn.ch10fn07)])
    Scrypt employs a key derivation algorithm specifically designed to require large
    amounts of memory, as well as multiple iterations (such an algorithm is called
    *memory hard*). This makes it harder to mount brute-force attacks on specialized
    hardware such as ASICs or GPUs, which typically operate with a limited amount
    of memory.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使暴力破解磁盘加密密码变得更加困难，Android 4.4引入了对一种新的密钥派生函数——*scrypt*的支持。^([[106](#ftn.ch10fn07)])
    Scrypt采用一种专门设计的密钥派生算法，旨在需要大量内存以及多次迭代（这种算法被称为*memory hard*）。这使得针对专用硬件如ASIC或GPU的暴力攻击变得更加困难，因为这些硬件通常具有有限的内存。
- en: Scrypt can be tuned by specifying the variable parameters *N*, *r*, and *p*,
    which influence the required CPU resources, memory amount, and parallelization
    cost, respectively. The values used in Android by default are *N* = 32768 (2^(15)),
    *r* = 8, and *p* = 2\. They can be changed by setting the value of the *ro.crypto.scrypt_params*
    system property using the *N_factor:r_factor:p_factor* format; for example, *15:3:1*
    (the default). The value of each parameter is computed by raising 2 to the power
    of the respective factor. Android 4.4 devices automatically update the key derivation
    algorithm in the crypto footer from PBKDF2 to scrypt and re-encrypt the master
    key using a scrypt-derived encryption key. When the encrypted master key is updated,
    the *N, r*, and *p* parameters that were used for KEK derivation are written to
    the crypto footer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Scrypt可以通过指定变量参数*N*、*r*和*p*来调整，这些参数分别影响所需的CPU资源、内存量和并行化成本。Android默认使用的值是*N*
    = 32768 (2^(15))，*r* = 8，*p* = 2。可以通过使用*N_factor:r_factor:p_factor*格式设置*ro.crypto.scrypt_params*系统属性的值来更改这些参数；例如，*15:3:1*（默认值）。每个参数的值通过将2提升到相应因子的幂来计算。Android
    4.4设备会自动更新加密页脚中的密钥派生算法，从PBKDF2更新为scrypt，并使用scrypt派生的加密密钥重新加密主密钥。当加密的主密钥被更新时，用于KEK派生的*N*、*r*和*p*参数会写入加密页脚中。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*On the same desktop machine, brute-forcing a 4-digit PIN (using a naive, single-threaded
    algorithm that generates all possible PINs starting from 0000) takes about 5 milliseconds
    per PIN when using PBKDF2, and about 230 milliseconds per PIN when using scrypt
    as the KEK derivation function. In other words, brute-forcing PBKDF2 is almost
    50 times cheaper (that is, faster) compared to scrypt.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*在同一台桌面机器上，使用PBKDF2暴力破解4位PIN码（使用一个简单的单线程算法，从0000开始生成所有可能的PIN）时，每个PIN约需要5毫秒，而使用scrypt作为KEK派生函数时，每个PIN大约需要230毫秒。换句话说，暴力破解PBKDF2比scrypt几乎便宜50倍（即更快）。*'
- en: Disk Encryption Password
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 磁盘加密密码
- en: As discussed in the previous section, the KEK used to encrypt the disk encryption
    key is derived from a user-supplied password. When you first start the device
    encryption process, you’re asked to either confirm your device unlock PIN or password,
    or set one if you haven’t already or you’re using the pattern screen lock (see
    [Figure 10-3](ch10.html#device_encryption_screen "Figure 10-3. Device encryption
    screen")). The entered password or PIN is then used to derive the master key encryption
    key, and you’re required to enter the password or PIN each time you boot the device,
    and then once more to unlock the screen after it starts.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，用于加密磁盘加密密钥的KEK源自用户提供的密码。当你第一次启动设备加密过程时，系统会要求你确认设备解锁PIN码或密码，或者如果你还没有设置，或使用图案锁屏，则需要设置一个（参见[图
    10-3](ch10.html#device_encryption_screen "图 10-3. 设备加密屏幕")）。输入的密码或PIN码随后用于推导主密钥加密密钥，你需要在每次启动设备时输入密码或PIN码，然后在设备启动后再次输入密码或PIN码以解锁屏幕。
- en: 'Android doesn’t have a dedicated setting to manage the encryption password
    after the device is encrypted, and changing the screen lock password or PIN will
    also silently change the device encryption password. This is most probably a usability-driven
    decision: most users would be confused by having to remember and enter two different
    passwords at different times and would probably quickly forget the less frequently
    used, and possibly more complex, disk encryption password. While this design is
    good for usability, it effectively forces users to use a simple disk encryption
    password, because they have to enter it each time they unlock the device, usually
    dozens of times a day. No one wants to enter a complex password that many times,
    and thus most users opt for a simple numeric PIN (unless a device policy requires
    otherwise). Additionally, passwords are limited to 16 characters (a limit that
    is hardwired in the framework and not configurable), so using a passphrase is
    not an option.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Android没有专门的设置来管理设备加密密码，在设备加密后，更改屏幕锁密码或PIN码也会悄悄更改设备加密密码。这很可能是基于可用性驱动的决策：大多数用户会对需要记住并在不同时间输入两个不同密码感到困惑，并且很可能很快忘记那个不常用的、可能更复杂的磁盘加密密码。虽然这种设计对可用性有好处，但它实际上迫使用户使用简单的磁盘加密密码，因为他们每次解锁设备时都必须输入它，通常每天要输入几十次。没有人想要输入那么多次复杂密码，因此大多数用户选择使用简单的数字PIN码（除非设备政策要求不同）。此外，密码限制为16个字符（这是框架中硬编码的限制，无法配置），所以使用密码短语并不是一个选项。
- en: '![Device encryption screen](figs/web/10fig03.png.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![设备加密屏幕](figs/web/10fig03.png.jpg)'
- en: Figure 10-3. Device encryption screen
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-3. 设备加密屏幕
- en: 'What’s the problem with using the same password for both disk encryption and
    the lockscreen? After all, to get to the data on the phone you need to guess the
    lockscreen password anyway, so why bother with a separate one for disk encryption?
    The reason is that the two passwords protect your phone against two different
    types of attack. Most screen lock attacks would be online, brute-force ones: essentially
    someone trying out different passwords on a running device when they get brief
    access to it. After a few unsuccessful attempts, Android will lock the screen
    for 30 seconds (rate limiting), and even wipe the device if there are more failed
    unlock attempts (if required by device policy). Thus, even a relatively short
    screen-lock PIN offers adequate protection against online attacks in most cases
    (see “[Brute-Force Attack Protection](ch10.html#brute-force_attack_protection
    "Brute-Force Attack Protection")” for details).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同密码来同时保护磁盘加密和锁屏有什么问题呢？毕竟，要访问手机上的数据，你反正需要猜测锁屏密码，那为什么还要为磁盘加密设置一个单独的密码呢？原因在于，这两个密码保护你的手机免受两种不同类型的攻击。大多数屏幕锁攻击是在线的暴力破解攻击：本质上是有人在短暂接触设备时，尝试不同的密码。经过几次失败后，Android会将屏幕锁定30秒（速率限制），如果解锁尝试失败次数过多（如果设备政策要求的话），还会擦除设备。因此，在大多数情况下，即使是相对简短的屏幕锁PIN码也能有效防止在线攻击（有关详细信息，请参见“[暴力破解攻击保护](ch10.html#brute-force_attack_protection
    "暴力破解攻击保护")”）。
- en: 'Of course, if someone has physical access to the device or a disk image of
    it, they can extract password hashes and crack them offline without worrying about
    rate-limiting or device wiping. This, in fact, is the scenario that full disk
    encryption is designed to protect against: when a device is stolen or confiscated,
    the attacker can either brute-force the actual device, or copy its data and analyze
    it even after the device is returned or disposed of. As mentioned earlier in “[Key
    Derivation](ch10.html#key_derivation "Key Derivation")”, the encrypted master
    key is stored on disk, and if the password used to derive its encryption key is
    based on a short numeric PIN, it can be brute-forced in minutes^([[107](#ftn.ch10fn08)])
    (or even seconds on pre-4.4 devices that use PBKDF2 for key derivation). A remote
    wipe solution could prevent this attack by deleting the master key, which only
    takes a moment and renders the device useless, but this is often not an option
    because the device might be offline or turned off.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果有人能够物理访问该设备或设备的磁盘镜像，他们可以提取密码哈希并离线破解，而无需担心速率限制或设备擦除。事实上，这正是全盘加密所设计来防范的场景：当设备被盗或没收时，攻击者可以通过暴力破解设备，或者即使设备被归还或处理后，也可以复制其数据并进行分析。如前所述，在“[密钥推导](ch10.html#key_derivation
    "Key Derivation")”中，加密的主密钥存储在磁盘上，如果用于推导其加密密钥的密码是基于一个短数字PIN，它可以在几分钟内被暴力破解^([[107](#ftn.ch10fn08)])（甚至在使用PBKDF2进行密钥推导的4.4版本之前的设备上，可能只需几秒钟）。远程擦除解决方案可以通过删除主密钥来防止此类攻击，这只需要片刻时间，并使设备变得无用，但这通常不是一个可行的选项，因为设备可能处于离线状态或关闭状态。
- en: Changing the Disk Encryption Password
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改磁盘加密密码
- en: The user-level part of disk encryption is implemented in the *cryptfs* module
    of Android’s volume management daemon (*vold*). *crypfs* has commands for both
    creating and mounting an encrypted volume, and for verifying and changing the
    master key encryption password. Android system services communicate with *cryptfs*
    by sending commands to *vold* through a local socket (also named *vold*), and
    *vold* sets system properties that describe the current state of the encryption
    or mount process based on the received command. (This results in a fairly complex
    boot procedure, described in detail in “[Enabling Encryption](ch10.html#enabling_encryption
    "Enabling Encryption")” below and “[Booting an Encrypted Device](ch10.html#booting_an_encrypted_device
    "Booting an Encrypted Device")”.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘加密的用户级部分是通过Android的卷管理守护进程（*vold*）中的*cryptfs*模块来实现的。*cryptfs*有用于创建和挂载加密卷的命令，还可以用来验证和更改主密钥加密密码。Android系统服务通过本地套接字（也命名为*vold*）向*vold*发送命令，与*cryptfs*进行通信，*vold*根据接收到的命令设置描述加密或挂载过程当前状态的系统属性。（这导致了一个相当复杂的启动过程，详细描述见下面的“[启用加密](ch10.html#enabling_encryption
    "Enabling Encryption")”以及“[启动加密设备](ch10.html#booting_an_encrypted_device "Booting
    an Encrypted Device")”。）
- en: Android does not provide a UI to change only the disk encryption password, but
    one can do so by communicating directly with the *vold* daemon using the `vdc`
    command-line utility. However, access to the *vold* control socket is limited
    to the root user and members of the *mount* group, and furthermore, *cryptfs*
    commands are only available to the *root* and *system* users. If you’re using
    an engineering build, or your device provides root access via a “superuser” app
    (see [Chapter 13](ch13.html "Chapter 13. System Updates and Root Access")), you
    can send the *cryptfs* command shown in [Example 10-4](ch10.html#changing_the_disk_encryption_password_us
    "Example 10-4. Changing the disk encryption password using vdc") to *vold* in
    order to change the disk encryption password.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Android并不提供一个界面来单独更改磁盘加密密码，但可以通过直接与*vold*守护进程通信，使用`vdc`命令行工具来做到这一点。然而，*vold*控制套接字的访问权限仅限于root用户和*mount*组的成员，此外，*cryptfs*命令仅对*root*和*system*用户可用。如果你使用的是工程版本，或者你的设备通过“超级用户”应用提供root访问（参见[第13章](ch13.html
    "Chapter 13. System Updates and Root Access")），你可以发送[示例10-4](ch10.html#changing_the_disk_encryption_password_us
    "Example 10-4. Changing the disk encryption password using vdc")中显示的*cryptfs*命令给*vold*，以更改磁盘加密密码。
- en: Example 10-4. Changing the disk encryption password using `vdc`
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 示例10-4. 使用`vdc`更改磁盘加密密码
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you change your lockscreen password, the disk encryption password will
    be changed automatically. (This does not apply to secondary users on multi-user
    devices.)*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你更改了锁屏密码，磁盘加密密码将自动更改。（这不适用于多用户设备上的次要用户。）*'
- en: Enabling Encryption
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用加密
- en: As mentioned in the previous section, the user-level part of Android’s disk
    encryption is implemented by a dedicated *cryptfs* module of the *vold* daemon.
    *cryptfs* provides the `checkpw`, `restart`, `cryptocomplete`, `enablecrypto`,
    `changepw`, `verifypw`, `getfield`, and `setfield` commands, which the framework
    sends at various points of the encryption or encrypted volume mount process. In
    addition to the permissions set on the *vold* local socket, *crypfs* explicitly
    checks the identity of the command sender, and only allows access to the *root*
    and *system* users.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，Android 的磁盘加密的用户级部分是由 *vold* 守护进程的专用 *cryptfs* 模块实现的。*cryptfs* 提供了 `checkpw`、`restart`、`cryptocomplete`、`enablecrypto`、`changepw`、`verifypw`、`getfield`
    和 `setfield` 等命令，框架会在加密或加密卷挂载的不同阶段发送这些命令。除了对 *vold* 本地套接字的权限设置外，*cryptfs* 还明确检查命令发送者的身份，只允许
    *root* 和 *system* 用户访问。
- en: Controlling Device Encryption Using System Properties
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用系统属性控制设备加密
- en: The *vold* daemon sets a number of system properties in order to trigger the
    various stages of device encryption or mounting and to communicate the current
    encryption state to framework services. The *ro.crypto.state* property holds the
    current encryption state, which is set to *encrypted* when the data partition
    has been successfully encrypted, and to *unencrypted* when it has not yet been
    encrypted. The property can also be set to *unsupported* if the device does not
    support disk encryption. The *vold* daemon also sets various predefined values
    to the *vold.decrypt* property in order to signal the current state of device
    encryption or mounting. The *vold.encrypt_progress* property holds the current
    encryption progress (from 0 to 100), or an error string if an error occurred during
    device encryption or mounting.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*vold* 守护进程设置了多个系统属性，以触发设备加密或挂载的各个阶段，并向框架服务传达当前的加密状态。*ro.crypto.state* 属性保存当前的加密状态，当数据分区成功加密时，它的值为
    *encrypted*，如果尚未加密，则为 *unencrypted*。如果设备不支持磁盘加密，该属性也可以设置为 *unsupported*。*vold*
    守护进程还设置了 *vold.decrypt* 属性的多个预定义值，以便指示设备加密或挂载的当前状态。*vold.encrypt_progress* 属性保存当前的加密进度（从
    0 到 100），如果在设备加密或挂载过程中发生错误，则为错误字符串。'
- en: The *ro.crypto.fs_crypto_blkdev* system property contains the name of the virtual
    device allocated by the device mapper. After successfully decrypting the disk
    encryption key, this virtual device is mounted at */data* in place of the underlying
    physical volume, as shown in [Example 10-5](ch10.html#encrypted_virtual_block_device_mounted_a
    "Example 10-5. Encrypted virtual block device mounted at /data") (with output
    split for readability).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*ro.crypto.fs_crypto_blkdev* 系统属性包含由设备映射器分配的虚拟设备的名称。在成功解密磁盘加密密钥后，这个虚拟设备将挂载在
    */data* 上，替代底层的物理卷，如 [示例 10-5](ch10.html#encrypted_virtual_block_device_mounted_a
    "示例 10-5. 加密的虚拟块设备挂载在 /data") 所示（输出已拆分以便于阅读）。'
- en: Example 10-5. Encrypted virtual block device mounted at /data
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-5. 加密的虚拟块设备挂载在 /data
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Unmounting /data
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卸载 /data
- en: The Android framework expects */data* to be available, but it needs to be unmounted
    in order to be encrypted. This creates a catch-22 situation, which Android solves
    by unmounting the physical *userdata* partition and mounting an on-memory filesystem
    (tempfs) in its place while performing encryption. Switching partitions at runtime
    in turn requires stopping and restarting certain system services, which *vold*
    triggers by setting the value of the *vold.decrypt* system property to *trigger_restart_framework*,
    *trigger_restart_min_framework*, or *trigger_shutdown_framework*. These values
    trigger different parts of *init.rc*, as shown in [Example 10-6](ch10.html#volddotdecrypt_triggers_in_initdotrc
    "Example 10-6. vold.decrypt triggers in init.rc").
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Android 框架期望 */data* 可用，但需要先卸载才能进行加密。这造成了一个进退两难的局面，Android 通过卸载物理 *userdata*
    分区并在其位置挂载一个内存文件系统（tempfs）来解决这个问题，同时执行加密。运行时切换分区反过来又需要停止并重启某些系统服务，*vold* 通过将 *vold.decrypt*
    系统属性的值设置为 *trigger_restart_framework*、*trigger_restart_min_framework* 或 *trigger_shutdown_framework*
    来触发这些服务的停止与重启。这些值触发 *init.rc* 中的不同部分，如 [示例 10-6](ch10.html#volddotdecrypt_triggers_in_initdotrc
    "示例 10-6. vold.decrypt 在 init.rc 中触发") 所示。
- en: Example 10-6. vold.decrypt triggers in init.rc
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-6. 在 init.rc 中触发 vold.decrypt
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Triggering the Encryption Process
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触发加密过程
- en: When the user starts the encryption process via the system Settings UI with
    Security▸Encrypt phone, the Settings app calls `MountService`, which in turn sends
    the `cryptfs enablecrypto inplace` *`password`* command to *vold*, where *`password`*
    is the lockscreen password. In turn, *vold* unmounts the *userdata* partition
    and sets *vold.decrypt* to *trigger_shutdown_framework* (➏ in [Example 10-6](ch10.html#volddotdecrypt_triggers_in_initdotrc
    "Example 10-6. vold.decrypt triggers in init.rc")), which shuts down most system
    services except for those that are part of the *core* service class. The *vold*
    daemon then unmounts */data,* mounts a tempfs file-system in its place, and then
    sets *vold.encrypt_progress* to 0 and *vold.decrypt* to *trigger_restart_min_framework*
    (➍ in [Example 10-6](ch10.html#volddotdecrypt_triggers_in_initdotrc "Example 10-6. vold.decrypt
    triggers in init.rc")). This starts a few more system services (in the *main*
    class) that are required for showing the encryption progress UI.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户通过系统设置界面启动加密过程，选择“安全性▸加密手机”时，设置应用会调用`MountService`，进而向*vold*发送`cryptfs enablecrypto
    inplace` *`password`*命令，其中*`password`*是锁屏密码。接着，*vold* 卸载*userdata*分区并将*vold.decrypt*设置为*trigger_shutdown_framework*（➏，见[示例10-6](ch10.html#volddotdecrypt_triggers_in_initdotrc
    "示例10-6. vold.decrypt在init.rc中的触发")），这将关闭大部分系统服务，除了属于*core*服务类的服务。然后，*vold*守护进程卸载*/data*，在其位置挂载一个tempfs文件系统，并将*vold.encrypt_progress*设置为0，将*vold.decrypt*设置为*trigger_restart_min_framework*（➍，见[示例10-6](ch10.html#volddotdecrypt_triggers_in_initdotrc
    "示例10-6. vold.decrypt在init.rc中的触发")）。这将启动一些更多系统服务（在*main*类中），这些服务是显示加密进度UI所必需的。
- en: Updating the Crypto Footer and Encrypting Data
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新加密页脚和加密数据
- en: Next, *vold* sets up the virtual dm-crypt device and writes the crypto footer.
    The footer can be written to the end of the *userdata* partition or to a dedicated
    partition or file, and its location is specified in the *fstab* file as the value
    of the `encryptable` flag. For example, on the Nexus 5 the crypto footer is written
    to the dedicated partition *metadata*, as shown in [Example 10-7](ch10.html#encryptable_fstab_flag_specifies_the_loc
    "Example 10-7. The encryptable fstab flag specifies the location of the crypto
    footer") as ➊ (with the single line broken for readability). When the crypto footer
    is written at the end of the encrypted partition, the `encryptable` flag is set
    to the string *footer*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，*vold*设置虚拟的dm-crypt设备并写入加密页脚。页脚可以写入到*userdata*分区的末尾，或者写入到专用的分区或文件，其位置在*fstab*文件中作为`encryptable`标志的值指定。例如，在Nexus
    5上，加密页脚被写入到专用分区*metadata*，如[示例10-7](ch10.html#encryptable_fstab_flag_specifies_the_loc
    "示例10-7. encryptable fstab标志指定加密页脚的位置")所示为➊（为了可读性，单行被拆分）。当加密页脚写入到加密分区的末尾时，`encryptable`标志被设置为字符串*footer*。
- en: Example 10-7. The `encryptable` fstab flag specifies the location of the crypto
    footer
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 示例10-7. `encryptable` fstab标志指定加密页脚的位置
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The crypto footer contains the encrypted disk encryption key (master key), the
    salt used for KEK derivation, and other key derivation parameters and metadata.
    Its *flags* field is set to `CRYPT_ENCRYPTION_IN_PROGRESS` (0x2) to signal that
    device encryption has started but not been completed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 加密页脚包含加密的磁盘加密密钥（主密钥）、用于KEK推导的盐值以及其他密钥推导参数和元数据。其*flags*字段设置为`CRYPT_ENCRYPTION_IN_PROGRESS`（0x2），表示设备加密已启动但尚未完成。
- en: Finally, each block is read from the physical *userdata* partition and written
    to the virtual dm-crypt device, which encrypts read blocks and writes them to
    disk, thus encrypting the *userdata* partition in place. If encryption completes
    without errors, *vold* clears the `CRYPT_ENCRYPTION_IN_PROGRESS` flag and reboots
    the device.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从物理*userdata*分区读取每个数据块，并将其写入虚拟的dm-crypt设备，设备对读取的数据块进行加密并写入磁盘，从而实现对*userdata*分区的就地加密。如果加密过程没有错误，*vold*会清除`CRYPT_ENCRYPTION_IN_PROGRESS`标志并重新启动设备。
- en: Booting an Encrypted Device
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动加密设备
- en: Booting an encrypted device requires asking the user for the disk encryption
    password. Rather then use a specialized bootloader UI, Android sets the *vold.
    decrypt* system property to 1 and then starts a minimal set of system services
    in order to show a standard Android UI. As with device encryption, this again
    requires mounting a tmpfs filesystem at */data* in order to allow core system
    services to start. When the core framework is up, Android detects that *vold.
    decrypt* is set to 1 and starts the *userdata* partition mount process.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 启动加密设备需要向用户询问磁盘加密密码。与其使用专门的引导加载程序用户界面，Android将*vold.decrypt*系统属性设置为1，然后启动一组最小的系统服务以显示标准的Android用户界面。与设备加密类似，这同样需要在*/data*挂载一个tmpfs文件系统，以便核心系统服务能够启动。当核心框架启动后，Android会检测到*vold.decrypt*被设置为1，并启动*userdata*分区的挂载过程。
- en: '![Device encryption password input UI](figs/web/10fig04.png.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![设备加密密码输入用户界面](figs/web/10fig04.png.jpg)'
- en: Figure 10-4. Device encryption password input UI
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-4 设备加密密码输入用户界面
- en: '![UI shown if device encryption fails](figs/web/10fig05.png.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![设备加密失败时显示的UI](figs/web/10fig05.png.jpg)'
- en: Figure 10-5. UI shown if device encryption fails
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-5 设备加密失败时显示的UI
- en: Obtaining the Disk Encryption Password
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取磁盘加密密码
- en: The first step in this process is to check whether the partition has been successfully
    encrypted by sending the `cryptfs cryptocomplete` command to *vold*, which in
    turn checks whether the crypto footer is properly formatted and that the `CRYPT_ENCRYPTION_IN_PROGRESS`
    flag is not set. If the partition is found to be successfully encrypted, the framework
    launches the password entry UI shown in [Figure 10-4](ch10.html#device_encryption_password_input_ui
    "Figure 10-4. Device encryption password input UI") provided by `CryptKeeper`,
    part of the system Settings app. This activity acts as a home screen (launcher),
    and because it has higher priority than the default launcher, it’s started first
    after the device boots.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的第一步是通过向*vold*发送`cryptfs cryptocomplete`命令，检查分区是否已成功加密，后者会检查加密页脚是否正确格式化，并且`CRYPT_ENCRYPTION_IN_PROGRESS`标志未被设置。如果发现分区已成功加密，框架将启动由`CryptKeeper`提供的密码输入用户界面，如[图10-4](ch10.html#device_encryption_password_input_ui
    "图10-4 设备加密密码输入用户界面")所示，`CryptKeeper`是系统设置应用的一部分。此活动作为主屏幕（启动器）启动，并且由于其优先级高于默认启动器，因此在设备启动后首先启动。
- en: If the device is unencrypted, `CryptKeeper` disables itself and finishes, which
    causes the system activity manager to launch the default home screen application.
    If the device is encrypted or in the process of being encrypted (that is, the
    *vold.crypt* property is not empty or set to *trigger_restart_framework*), the
    `CryptKeeper` activity starts and hides the status and system bars. In addition,
    `CryptKeeper` ignores hardware back button presses, thus disallowing navigation
    away from the password input UI.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备未加密，`CryptKeeper`会禁用自身并完成，从而导致系统活动管理器启动默认的主屏幕应用程序。如果设备已加密或正在加密过程中（即*vold.crypt*属性不为空或未设置为*trigger_restart_framework*），`CryptKeeper`活动会启动并隐藏状态栏和系统栏。此外，`CryptKeeper`会忽略硬件返回按钮的按压，从而禁止用户离开密码输入用户界面。
- en: If the encrypted device is corrupted, or the encryption process interrupted
    and the *userdata* partition left only partially encrypted, the device cannot
    be booted. In this case, `CryptKeeper` displays the UI shown in [Figure 10-5](ch10.html#ui_shown_if_device_encryption_fails
    "Figure 10-5. UI shown if device encryption fails"), allowing the user to trigger
    a factory reset, which reformats the *userdata* partition.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加密设备损坏，或者加密过程被中断，导致*userdata*分区仅部分加密，设备将无法启动。在这种情况下，`CryptKeeper`会显示[图10-5](ch10.html#ui_shown_if_device_encryption_fails
    "图10-5 设备加密失败时显示的UI")中所示的UI，允许用户触发恢复出厂设置，这将重新格式化*userdata*分区。
- en: Decrypting and Mounting /data
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解密并挂载/data
- en: When the user enters their password, `CryptKeeper` sends the `cryptfs checkpw`
    command to *vold* by calling the `decryptStorage()` method of the system `MountService`.
    This instructs *vold* to check whether the entered password is correct by trying
    to mount the encrypted partition at a temporary mount point and then unmounting
    it. If the procedure succeeds, *vold* sets the name of the virtual block device
    allocated by the device-mapper as the value of *ro.crypto.fs_crypto_blkdev* property
    and returns control to `MountService`, which in turn sends the `cryptfs restart`
    command, instructing *vold* to restart all system services in the *main* class
    (➋ in [Example 10-6](ch10.html#volddotdecrypt_triggers_in_initdotrc "Example 10-6. vold.decrypt
    triggers in init.rc")). This allows the tempfs filesystem to be unmounted, and
    the newly allocated virtual dm-crypt block device to be mounted at */data*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入密码时，`CryptKeeper`通过调用系统`MountService`的`decryptStorage()`方法，将`cryptfs checkpw`命令发送给*vold*。这指示*vold*检查输入的密码是否正确，方法是尝试将加密分区挂载到临时挂载点，然后再卸载。如果该过程成功，*vold*将设备映射器分配的虚拟块设备的名称设置为*ro.crypto.fs_crypto_blkdev*属性的值，并将控制权返回给`MountService`，后者进一步发送`cryptfs
    restart`命令，指示*vold*重启*main*类中的所有系统服务（➋见[示例10-6](ch10.html#volddotdecrypt_triggers_in_initdotrc
    "示例10-6. vold.decrypt触发器在init.rc中")）。这使得tempfs文件系统得以卸载，并且新分配的虚拟dm-crypt块设备被挂载到*/data*。
- en: Starting All System Services
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动所有系统服务
- en: After the encrypted partition is mounted and prepared, *vold* sets *vold.decrypt*
    to *trigger_post_fs_data* (➌ in [Example 10-6](ch10.html#volddotdecrypt_triggers_in_initdotrc
    "Example 10-6. vold.decrypt triggers in init.rc")), thus triggering the *post-fs-data*
    ➊ section of *init.rc*. The commands in this section set up file and directory
    permissions, restore SELinux contexts, and create required directories under */data*
    if necessary.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密分区挂载并准备好后，*vold*将*vold.decrypt*设置为*trigger_post_fs_data*（➌见[示例10-6](ch10.html#volddotdecrypt_triggers_in_initdotrc
    "示例10-6. vold.decrypt触发器在init.rc中")），从而触发*init.rc*的*post-fs-data* ➊部分。本部分的命令设置文件和目录权限，恢复SELinux上下文，并在必要时在*/data*下创建所需的目录。
- en: Finally, *post-fs-data* sets the *vold.post_fs_data_done property* to 1, which
    *vold* polls periodically. When *vold* detects a value of 1, it sets the *vold.decrypt*
    property to *trigger_restart_framework* (➎ in [Example 10-6](ch10.html#volddotdecrypt_triggers_in_initdotrc
    "Example 10-6. vold.decrypt triggers in init.rc")), which restarts all services
    in the *main* class, and starts all delayed services (class *late_start*). At
    this point, the framework is fully initialized and the device boots using the
    decrypted view of the *userdata* partition mounted at */data*. From this point
    on, all data written by applications or the system is automatically encrypted
    before being committed to disk.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*post-fs-data*将*vold.post_fs_data_done*属性设置为1，*vold*会定期轮询该属性。当*vold*检测到值为1时，它将*vold.decrypt*属性设置为*trigger_restart_framework*（➎见[示例10-6](ch10.html#volddotdecrypt_triggers_in_initdotrc
    "示例10-6. vold.decrypt触发器在init.rc中")），从而重启*main*类中的所有服务，并启动所有延迟启动的服务（类*late_start*）。此时，框架已完全初始化，设备开始使用解密后的*userdata*分区的视图进行引导，该视图被挂载在*/data*。从此以后，所有由应用程序或系统写入的数据在提交到磁盘之前都会自动加密。
- en: Limitations of Disk Encryption
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘加密的限制
- en: Disk encryption only protects data at rest; that is, when the device is turned
    off. Because disk encryption is transparent and implemented at the kernel level,
    after an encrypted volume is mounted, it is indistinguishable from a plaintext
    volume to user-level processes. Therefore disk encryption does not protect data
    from malicious programs running on the device. Applications that deal with sensitive
    data should not rely solely on full-disk encryption, but should implement their
    own, file-based encryption instead. The file encryption key should be encrypted
    with a KEK derived from a user-supplied password, or some unchangeable hardware
    property if the data needs to be bound to the device. To ensure file integrity,
    encrypted data must be authenticated using either an authenticated encryption
    scheme like GCM, or an additional authentication function such as HMAC.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘加密仅保护静态数据；也就是说，当设备关闭时。由于磁盘加密是透明的，并且在内核级别实现，在加密卷被挂载后，它对于用户级进程来说与明文卷没有区别。因此，磁盘加密并不能保护数据免受在设备上运行的恶意程序的攻击。处理敏感数据的应用程序不应仅依赖于全盘加密，而应实现自己的基于文件的加密。文件加密密钥应使用从用户提供的密码派生的KEK加密，或者如果数据需要与设备绑定，则可以使用不可更改的硬件属性加密。为了确保文件完整性，必须使用经过认证的加密方案（如GCM）或附加认证功能（如HMAC）对加密数据进行认证。
- en: Screen Security
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕安全性
- en: One way to control access to an Android device is by requiring user authentication
    in order to access the system UI and applications. User authentication is implemented
    by showing a *lockscreen* each time the device boots or its screen is turned on.
    The lockscreen on a single-user device, configured to require a numeric PIN to
    unlock, might look like [Figure 10-6](ch10.html#pin_lockscreen "Figure 10-6. PIN
    lockscreen").
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 控制Android设备访问的一种方式是要求用户身份验证才能访问系统UI和应用程序。用户身份验证通过在设备每次启动或屏幕打开时显示*锁屏界面*来实现。配置为需要数字PIN码解锁的单用户设备上的锁屏界面可能类似于[图10-6](ch10.html#pin_lockscreen
    "图10-6. PIN锁屏界面")。
- en: In early Android versions, the lock-screen was only designed to protect access
    to the device’s UI. As the platform evolved, the lockscreen has been extended
    with features that display widgets that show up-to-date device or application
    state, allow switching between users on multi-user devices, and the ability to
    unlock the system keystore. Similarly, the screen unlock PIN or password is now
    used to derive the credential storage encryption key (for software implementations),
    as well as the disk encryption key KEK.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的Android版本中，锁屏仅用于保护对设备UI的访问。随着平台的发展，锁屏被扩展了许多功能，包括显示最新设备或应用程序状态的小部件，允许在多用户设备之间切换，并支持解锁系统密钥存储。同样，屏幕解锁的PIN码或密码现在用于派生凭证存储加密密钥（用于软件实现），以及磁盘加密密钥KEK。
- en: '![PIN lockscreen](figs/web/10fig06.png.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![PIN锁屏界面](figs/web/10fig06.png.jpg)'
- en: Figure 10-6. PIN lockscreen
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-6. PIN锁屏界面
- en: Lockscreen Implementation
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁屏实现
- en: 'Android’s lockscreen (or *keyguard*) is implemented like regular Android applications:
    with widgets laid out on a window. It’s special because its window lives on a
    high window layer that other applications cannot draw on top of or control. Additionally,
    the keyguard intercepts the normal navigation buttons, which makes it impossible
    to bypass and thus “locks” the device.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Android的锁屏（或*键盘保护*）实现方式与普通的Android应用程序类似：窗口上布局了小部件。它的特殊之处在于，它的窗口位于一个高层窗口中，其他应用程序无法在其上方绘制或控制。此外，键盘保护拦截了普通的导航按钮，使得无法绕过它，从而实现“锁定”设备。
- en: The keyguard window layer is not the highest layer, however; dialogs originating
    from the keyguard itself, and the status bar, are drawn over the keyguard. You
    can see a list of the currently shown windows using the Hierarchy Viewer tool
    available with the ADT. When the screen is locked, the active window is the Keyguard
    window, as shown in [Figure 10-7](ch10.html#keyguard_window_position_in_androidapost
    "Figure 10-7. Keyguard window position in Android’s window stack").
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘保护窗口层并不是最高层，然而，源自键盘保护本身的对话框和状态栏会绘制在键盘保护之上。你可以使用AD工具包中的层次查看器工具查看当前显示的窗口列表。当屏幕被锁定时，活动窗口是键盘保护窗口，如[图10-7](ch10.html#keyguard_window_position_in_androidapost
    "图10-7. 键盘保护窗口在Android窗口堆栈中的位置")所示。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Prior to Android 4.0, third-party applications could show windows in the keyguard
    layer, which allowed applications to intercept the Home button and implement “kiosk”-style
    applications. However, because this functionality was abused by certain malware
    applications, since Android 4.0 adding windows to the keyguard layer requires
    the `INTERNAL_SYSTEM_WINDOW` signature permission, which is available only to
    system applications.*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*在Android 4.0之前，第三方应用程序可以在键盘保护层中显示窗口，这允许应用程序拦截Home键并实现“自助终端”风格的应用程序。然而，由于某些恶意软件滥用了这一功能，因此自Android
    4.0以来，向键盘保护层添加窗口需要`INTERNAL_SYSTEM_WINDOW`签名权限，而该权限仅限系统应用程序使用。*'
- en: '![Keyguard window position in Android’s window stack](figs/web/10fig07.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![键盘保护窗口在Android窗口堆栈中的位置](figs/web/10fig07.png)'
- en: Figure 10-7. Keyguard window position in Android’s window stack
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-7. 键盘保护窗口在Android窗口堆栈中的位置
- en: For a long time, the keyguard was an implementation detail of Android’s window
    system and was not separated into a dedicated component. With the introduction
    of lockscreen widgets, dreams (that is, screensavers), and support for multiple
    users, the keyguard gained quite a lot of new functionality and was eventually
    extracted in a dedicated system application, `Keyguard`, in Android 4.4\. The
    `Keyguard` app lives in the *com.android.systemui* process, along with the core
    Android UI implementation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，键盘保护是Android窗口系统的一个实现细节，并没有被拆分成独立的组件。随着锁屏小部件、屏幕保护程序（即屏保）和多用户支持的引入，键盘保护获得了大量的新功能，最终在Android
    4.4中被提取成一个独立的系统应用程序`Keyguard`。`Keyguard`应用程序位于*com.android.systemui*进程中，与核心的Android
    UI实现一起运行。
- en: The UI for each unlock method (discussed next) is implemented as a specialized
    view component. This component is hosted by a dedicated view container class called
    `KeyguardHostView`, along with keyguard widgets and other helper UI components.
    For example, the PIN unlock view shown in [Figure 10-6](ch10.html#pin_lockscreen
    "Figure 10-6. PIN lockscreen") is implemented in the `KeyguardPINView` class,
    and password unlock is implemented by the `KeyguardPasswordView` class. The `KeyguardHostView`
    class automatically selects and displays the appropriate keyguard view for the
    currently configured unlock method and device state. Unlock views delegate password
    checks to the `LockPatternUtils` class, which is responsible for comparing user
    input to saved unlock credentials, as well as for persisting password changes
    to disk and updating authentication-related metadata.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每种解锁方法的用户界面（稍后讨论）都实现为一个专用的视图组件。这个组件由一个名为`KeyguardHostView`的专用视图容器类承载，并包含关键guard小部件和其他辅助UI组件。例如，在[图10-6](ch10.html#pin_lockscreen
    "图10-6. PIN锁屏")中展示的PIN码解锁视图是由`KeyguardPINView`类实现的，而密码解锁是由`KeyguardPasswordView`类实现的。`KeyguardHostView`类会自动选择并显示当前配置的解锁方法和设备状态的适当解锁视图。解锁视图将密码检查委托给`LockPatternUtils`类，该类负责将用户输入与保存的解锁凭据进行比较，并将密码更改持久化到磁盘，并更新与身份验证相关的元数据。
- en: Besides the implementations of keyguard unlock views, the `Keyguard` system
    application includes the exported `KeyguardService` service, which exposes a remote
    AIDL interface, `IKeyguardService`. This service allows its clients to check the
    current state of the keyguard, set the current user, launch the camera, and hide
    or disable the keyguard. Operations that change the state of the keyguard are
    protected by a system signature permission, `CONTROL_KEYGUARD`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关键guard解锁视图的实现之外，`Keyguard`系统应用程序还包括导出的`KeyguardService`服务，该服务公开了远程AIDL接口`IKeyguardService`。该服务允许客户端检查当前的关键guard状态，设置当前用户，启动相机，并隐藏或禁用关键guard。更改关键guard状态的操作受到系统签名权限`CONTROL_KEYGUARD`的保护。
- en: Keyguard Unlock Methods
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键guard解锁方法
- en: 'Stock Android provides several keyguard unlock methods (also called *security
    modes* in Android’s source code). Of these, five can be directly selected in the
    Choose screen lockscreen: Slide, Face Unlock, Pattern, PIN, and Password, as shown
    in [Figure 10-8](ch10.html#directly_selectable_keyguard_unlock_meth "Figure 10-8. Directly
    selectable keyguard unlock methods").'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 原生安卓提供了几种关键guard解锁方法（在安卓源代码中也称为*安全模式*）。其中，五种方法可以直接在选择屏幕锁定界面中选择：滑动、面部解锁、图案、PIN码和密码，如[图10-8](ch10.html#directly_selectable_keyguard_unlock_meth
    "图10-8. 可直接选择的关键guard解锁方法")所示。
- en: The Slide unlock method requires no user authentication and its security level
    is therefore equivalent to selecting None. Both states are represented internally
    by setting the current security mode to the `KeyguardSecurityModel.SecurityMode.None`
    enum value. As of this writing, Face Unlock is the only implementation of the
    `SecurityMode.Biometric` security mode and is internally referred to as “weak
    biometric” (a “strong bio-metric” could be implemented with fingerprint or iris
    recognition in a future version). Unlock methods that are not compatible with
    the current device security policy (the top three in [Figure 10-8](ch10.html#directly_selectable_keyguard_unlock_meth
    "Figure 10-8. Directly selectable keyguard unlock methods")) are disabled and
    cannot be selected. The security policy can be set either explicitly by a device
    administrator, or implicitly by enabling a security-related OS feature such as
    credential storage or full-disk encryption.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动解锁方法不需要用户身份验证，因此其安全级别相当于选择“无”。这两种状态在内部通过将当前安全模式设置为`KeyguardSecurityModel.SecurityMode.None`枚举值来表示。截至目前，面部解锁是`SecurityMode.Biometric`安全模式的唯一实现，并且在内部被称为“弱生物特征”（未来版本可能会使用指纹或虹膜识别实现“强生物特征”）。与当前设备安全策略不兼容的解锁方法（如[图10-8](ch10.html#directly_selectable_keyguard_unlock_meth
    "图10-8. 可直接选择的关键guard解锁方法")中列出的前三种方法）会被禁用，无法选择。安全策略可以由设备管理员显式设置，或者通过启用与安全相关的操作系统功能（如凭据存储或全盘加密）隐式设置。
- en: The Pattern unlock method (`SecurityMode.Pattern`) is Android-specific and requires
    drawing a predefined pattern on a 3×3 grid to unlock the device, as shown in [Figure 10-9](ch10.html#configuring_the_pattern_unlock_method
    "Figure 10-9. Configuring the Pattern unlock method").
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图案解锁方法（`SecurityMode.Pattern`）是安卓特有的，要求用户在3×3网格上绘制预定义的图案以解锁设备，如[图10-9](ch10.html#configuring_the_pattern_unlock_method
    "图10-9. 配置图案解锁方法")所示。
- en: '![Directly selectable keyguard unlock methods](figs/web/10fig08.png.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![可直接选择的锁屏解锁方法](figs/web/10fig08.png.jpg)'
- en: Figure 10-8. Directly selectable keyguard unlock methods
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-8. 可直接选择的锁屏解锁方法
- en: '![Configuring the Pattern unlock method](figs/web/10fig09.png.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![配置图案解锁方法](figs/web/10fig09.png.jpg)'
- en: Figure 10-9. Configuring the Pattern unlock method
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-9. 配置图案解锁方法
- en: 'The PIN (`SecurityMode.PIN`) and Password (`SecurityMode.Password`) unlock
    methods are implemented similarly, but differ by the scope of allowed characters:
    only numeric (0-9) for the PIN, or alphanumeric for Password are allowed.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: PIN (`SecurityMode.PIN`) 和密码 (`SecurityMode.Password`) 解锁方法的实现类似，但在允许的字符范围上有所不同：PIN
    只允许数字（0-9），而密码则允许字母数字字符。
- en: 'The `SecurityMode` enum defines three more unlock methods that are not directly
    selectable in the Choose screen lockscreen: `SecurityMode.Account`, `SecurityMode.SimPin`,
    and `SecurityMode.SimPuk`. The `SecurityMode.Account` method is available only
    on devices that support Google accounts (Google experience devices) and is not
    an independent unlock method. It can only be used as a fallback method for another
    security mode. Similarly, `SecurityMode.SimPin` and `SecurityMode.SimPuk` are
    not lockscreen unlock methods per se; they’re only available if the device’s SIM
    card requires a PIN before use. Because the SIM card remembers the PIN authentication
    status, the PIN or PUK must be entered only once—when the device boots (or if
    the SIM card state is otherwise reset). We’ll delve deeper into the implementation
    of each lockscreen security mode in the next sections.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecurityMode` 枚举定义了三种不能在选择屏幕锁屏界面直接选择的解锁方法：`SecurityMode.Account`、`SecurityMode.SimPin`
    和 `SecurityMode.SimPuk`。`SecurityMode.Account` 方法仅在支持 Google 帐号（Google 体验设备）的设备上可用，并非独立的解锁方法。它只能作为其他安全模式的后备方法使用。类似地，`SecurityMode.SimPin`
    和 `SecurityMode.SimPuk` 本身并不是锁屏解锁方法；它们仅在设备的 SIM 卡需要 PIN 码才能使用时可用。由于 SIM 卡会记住 PIN
    验证状态，因此 PIN 或 PUK 只需输入一次——在设备启动时（或者如果 SIM 卡状态被重置）。我们将在接下来的章节中深入探讨每种锁屏安全模式的实现。'
- en: Face Unlock
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面部解锁
- en: Face Unlock is a relatively new unlock method introduced in Android 4.0\. It
    uses the device’s front-facing camera to register an image of the owner’s face
    (see [Figure 10-10](ch10.html#face_unlock_setup_screen "Figure 10-10. Face Unlock
    setup screen")) and relies on image recognition technology to recognize the face
    captured when unlocking the device. Although improvements to Face Unlock’s accuracy
    have been made since its introduction, it’s considered the least secure of all
    unlock methods, and even the setup screen warns users that “someone who looks
    similar to you could unlock your phone.” In addition, Face Unlock requires a backup
    unlock method—either a pattern or a PIN, to handle situations when face recognition
    is not possible (such as poor lighting, camera malfunction, and so on). The Face
    Unlock implementation is based on facial recognition technology developed by the
    PittPatt (Pittsburgh Pattern Recognition) company, which Google acquired in 2011\.
    The code remains proprietary and no details are available about the format of
    the stored data or the recognition algorithms employed. As of this writing, the
    implementation of Face Unlock resides in the `com.android.facelock` package.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 面部解锁是一种相对较新的解锁方法，首次在 Android 4.0 中引入。它利用设备的前置摄像头注册用户面部的图像（见[图 10-10](ch10.html#face_unlock_setup_screen
    "图 10-10. 面部解锁设置屏幕")），并依靠图像识别技术来识别解锁时捕捉到的面部图像。尽管自面部解锁推出以来，已经对其准确性进行了改进，但它仍被认为是所有解锁方法中最不安全的，甚至设置屏幕上也警告用户“看起来像你的人可能解锁你的手机。”此外，面部解锁还需要备用解锁方法——图案或
    PIN 码，以应对面部识别无法进行的情况（例如光线不足、摄像头故障等）。面部解锁的实现基于 PittPatt（Pittsburgh Pattern Recognition）公司开发的面部识别技术，该公司于
    2011 年被 Google 收购。该技术的代码仍为专有代码，关于存储数据格式或所采用的识别算法没有详细信息。截至本文撰写时，面部解锁的实现位于 `com.android.facelock`
    包中。
- en: '![Face Unlock setup screen](figs/web/10fig10.png.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![面部解锁设置屏幕](figs/web/10fig10.png.jpg)'
- en: Figure 10-10. Face Unlock setup screen
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-10. 面部解锁设置屏幕
- en: Pattern Unlock
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图案解锁
- en: As shown in [Figure 10-9](ch10.html#configuring_the_pattern_unlock_method "Figure 10-9. Configuring
    the Pattern unlock method"), the code for pattern unlock is entered by joining
    at least four points on a 3×3 matrix. Each point can be used only once (crossed
    points are disregarded) and the maximum number of points is nine. Internally,
    the pattern is stored as a byte sequence, with each point represented by its index,
    where 0 is top left and 8 is bottom right. Thus the pattern is similar to a PIN
    with a minimum of four and maximum of nine digits, which uses only nine distinct
    digits (0 to 8). However, because points cannot be repeated, the number of variations
    in an unlock pattern is considerably lower compared to those of a nine-digit PIN.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图10-9](ch10.html#configuring_the_pattern_unlock_method "图10-9. 配置图案解锁方法")所示，图案解锁的代码是通过在3×3矩阵中至少连接四个点来输入的。每个点只能使用一次（交叉的点会被忽略），最大点数为九。内部上，图案以字节序列的形式存储，每个点通过其索引来表示，其中0是左上角，8是右下角。因此，图案类似于一个最小为四位、最大为九位的PIN码，且只使用九个不同的数字（0到8）。然而，由于点不能重复，解锁图案的变化数远低于九位PIN码的变化数。
- en: The hash for the pattern lock is stored in */data/system/gesture.key* (*/data/
    system/users/<user ID>/gesture.key* on multi-user devices) as an unsalted SHA-1
    value. By simply dumping this file, we can easily see that the contents of the
    *gesture.key* file for the pattern in [Figure 10-9](ch10.html#configuring_the_pattern_unlock_method
    "Figure 10-9. Configuring the Pattern unlock method") (represented as *00010204060708*
    in hexadecimal) shown in [Example 10-8](ch10.html#contents_of_the_solidusdatasolidussystem
    "Example 10-8. Contents of the /data/system/gesture.key file") matches the SHA-1
    hash of the pattern byte sequence, which is *6a062b9b3452e366407181a1bf92ea73e9ed4c48*
    for this example.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图案锁的哈希值存储在*/data/system/gesture.key*（在多用户设备上为*/data/system/users/<用户ID>/gesture.key*）中，作为一个无盐的SHA-1值。通过简单地导出此文件，我们可以很容易地看到[图10-9](ch10.html#configuring_the_pattern_unlock_method
    "图10-9. 配置图案解锁方法")所示的图案（在十六进制中表示为*00010204060708*）在[示例10-8](ch10.html#contents_of_the_solidusdatasolidussystem
    "示例 10-8. /data/system/gesture.key 文件的内容")中的*gesture.key*文件内容与图案字节序列的SHA-1哈希值相匹配，对于此示例来说，该哈希值为*6a062b9b3452e366407181a1bf92ea73e9ed4c48*。
- en: Example 10-8. Contents of the /data/system/gesture.key file
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-8. /data/system/gesture.key 文件的内容
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because a random salt value isn’t used when calculating the hash, each pattern
    is always hashed to the same value, which makes it relatively easy to generate
    a precomputed table of all possible patterns and their respective hashes. (Such
    tables are readily available online.) This allows for instant recovery of the
    pattern once the *gesture.key* file is obtained. However, the file is owned by
    the *system* user and its permissions are set to 0600, so recovery is not usually
    possible on production devices. The entered pattern is checked against the saved
    hash using the `checkPattern()` method of the `LockScreenUtils` class, and the
    pattern hash is calculated and persisted using the `saveLockPattern()` method
    of that class. Saving the pattern also sets the current password quality value
    to `DevicePolicyManager.PASSWORD_QUALITY_SOMETHING`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在计算哈希时没有使用随机盐值，因此每个图案总是会被哈希为相同的值，这使得生成一个预计算的所有可能图案及其相应哈希值的表格相对容易。（此类表格在网上随处可见。）这使得一旦获取到*gesture.key*文件，就能立即恢复图案。然而，该文件由*system*用户拥有，且其权限设置为0600，因此通常无法在生产设备上恢复。输入的图案会使用`LockScreenUtils`类的`checkPattern()`方法与保存的哈希值进行对比，而图案哈希会通过该类的`saveLockPattern()`方法进行计算并持久化保存。保存图案时，还会将当前密码强度值设置为`DevicePolicyManager.PASSWORD_QUALITY_SOMETHING`。
- en: Another unfortunate property of the pattern unlock method is that because capacitive
    touch screens are operated directly using a finger (not with a stylus or a similar
    tool), drawing the unlock pattern multiple times leaves a distinct trace on a
    touch screen, making it vulnerable to the so called “smudge attack.” Using appropriate
    lighting and cameras, finger smudges on the screen can be detected, and the unlock
    pattern can be inferred with a very high probability. For these reasons, the pattern
    unlock method’s security level is considered very low. In addition, because the
    number of combinations is limited, the unlock pattern is a poor source of entropy
    and is disallowed when the user’s unlock credential is used to derive an encryption
    key, such as those used for system’s keystore and device encryption.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图案解锁方法的另一个不幸特点是，由于电容式触摸屏是直接用手指操作（而非使用触控笔或类似工具），多次绘制解锁图案会在触摸屏上留下明显的痕迹，从而容易受到所谓的“污迹攻击”。通过适当的光线和相机，屏幕上的指纹污迹可以被检测到，从而以很高的概率推测出解锁图案。因此，图案解锁方法的安全性被认为非常低。此外，由于组合数量有限，解锁图案是一个糟糕的熵源，在用户的解锁凭证用于推导加密密钥时（例如，用于系统密钥库和设备加密的密钥），该方法是不被允许的。
- en: Like Face Unlock, the pattern unlock method supports a backup unlock mechanism
    that is only made available after the user enters an invalid pattern more than
    five times. Backup authentication must be manually activated by pressing the Forgot
    Pattern button shown at the bottom of the lock-screen. After the button is pressed,
    the device goes into the `SecurityMode.Account` security mode and displays the
    screen shown in [Figure 10-11](ch10.html#google_account_unlock_mode "Figure 10-11. Google
    account unlock mode").
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与面部解锁类似，图案解锁方法支持备份解锁机制，该机制只有在用户输入无效图案超过五次后才会启用。备份认证必须通过按下锁屏底部显示的“忘记图案”按钮手动激活。按下按钮后，设备进入`SecurityMode.Account`安全模式，并显示[图10-11](ch10.html#google_account_unlock_mode
    "图10-11. Google账户解锁模式")所示的屏幕。
- en: The user can enter the credentials of any Google account registered on the device
    to unlock it, and then reset or change the unlock method. Therefore, having a
    Google account with an easy to guess (or shared) password registered on the device
    could be a potential backdoor to the device’s lockscreen.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以输入设备上任何已注册Google账户的凭据来解锁设备，然后重置或更改解锁方法。因此，在设备上注册一个易于猜测（或共享）的密码的Google账户，可能成为设备锁屏的潜在后门。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*As of this writing, Google accounts that have been configured to require two-factor
    authentication cannot be used to unlock the device.*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*截至本文写作时，已配置为要求两步验证的Google账户无法用于解锁设备。*'
- en: '![Google account unlock mode](figs/web/10fig11.png.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![Google账户解锁模式](figs/web/10fig11.png.jpg)'
- en: Figure 10-11. Google account unlock mode
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-11. Google账户解锁模式
- en: PIN and Password Unlock
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PIN和密码解锁
- en: 'The PIN and password methods are essentially equivalent: they compare the hash
    of the user’s input to a salted hash stored on the device and unlock it if the
    values match. The hash of the PIN or password is a combination of the SHA-1 and
    MD5 hash values of the user input, salted with a 64-bit random value. The calculated
    hash is stored in the */data/misc/password.key* (/*data/system/users/<user ID>/password.key*
    on multi-user devices) file as a hexadecimal string and may look like [Example 10-9](ch10.html#contents_of_the_solidusdatasolidusmiscso
    "Example 10-9. Contents of the /data/misc/password.key file").'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: PIN和密码方法本质上是等价的：它们将用户输入的哈希值与设备上存储的加盐哈希值进行比较，并在值匹配时解锁设备。PIN或密码的哈希值是用户输入的SHA-1和MD5哈希值的组合，并使用64位随机值加盐。计算出的哈希值以十六进制字符串的形式存储在*/data/misc/password.key*（在多用户设备上为/*data/system/users/<user
    ID>/password.key*）文件中，可能类似于[示例10-9](ch10.html#contents_of_the_solidusdatasolidusmiscso
    "示例10-9. /data/misc/password.key文件的内容")。
- en: Example 10-9. Contents of the /data/misc/password.key file
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 示例10-9. /data/misc/password.key文件的内容
- en: '[PRE8]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The salt used for calculating the hash values was saved in the `secure` table
    of the system’s `SettingsProvider` content provider under the *lockscreen.password_salt*
    key in Android versions prior to 4.2, but was moved to a dedicated database, along
    with other lockscreen-related metadata in order to support multiple users per
    device. As of Android 4.4, the database is located in */data/system/locksettings.db*
    and is accessed via the `ILockSettings` AIDL interface of the `LockSettingsService`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算哈希值的盐值被保存在系统 `SettingsProvider` 内容提供者的 `secure` 表中，Android 4.2 之前的版本中使用
    *lockscreen.password_salt* 键，但为了支持每个设备的多个用户，它被移动到一个专用的数据库中，数据库还包含其他与锁屏相关的元数据。从
    Android 4.4 开始，数据库位于 */data/system/locksettings.db*，并通过 `LockSettingsService`
    的 `ILockSettings` AIDL 接口进行访问。
- en: Accessing the service requires the `ACCESS_KEYGUARD_SECURE_STORAGE` signature
    permission, which is only allowed to system applications. The *locksettings.db*
    database has a single table, also called `locksettings`, which may contain data
    like [Example 10-10](ch10.html#contents_of_solidusdatasolidussy-id00023 "Example 10-10. Contents
    of /data/system/locksettings.db for the owner user") for a particular user (the
    `user` column contains the Android user ID).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 访问该服务需要 `ACCESS_KEYGUARD_SECURE_STORAGE` 签名权限，仅允许系统应用程序使用。*locksettings.db*
    数据库有一个名为 `locksettings` 的表，其中可能包含像 [示例 10-10](ch10.html#contents_of_solidusdatasolidussy-id00023
    "示例 10-10。/data/system/locksettings.db 中的所有者用户内容") 中为特定用户（`user` 列包含 Android 用户
    ID）提供的数据。
- en: Example 10-10. Contents of /data/system/locksettings.db for the owner user
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-10。/data/system/locksettings.db 中的所有者用户内容
- en: '[PRE9]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the *lockscreen.password_salt* setting ➊ stores the 64-bit (represented
    as a Java `long` type) salt value, and the *lockscreen.password_type_alternate*
    setting ➋ contains the type of the backup (also called alternate) unlock method
    type (0 means none) for the current unlock method. *lockscreen.password_type*
    ➌ stores the currently selected password type, represented by the value of the
    corresponding `PASSWORD_QUALITY` constant defined in the `DevicePolicyManager`
    class. In this example, 131072 (0x00020000 in hexadecimal) corresponds to the
    `PASSWORD_QUALITY_NUMERIC` constant, which is the password quality provided by
    a numeric PIN. Finally, *lockscreen.passwordhistory* ➍ contains the password history,
    saved as a sequence of previous PIN or password hashes, separated by commas. The
    history is only saved if the history length has been set to a value greater than
    zero using one of the `setPasswordHistoryLength()` methods of the `DevicePolicyManager`
    class. When password history is available, entering a new password that is the
    same as any password in the history is forbidden.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*lockscreen.password_salt* 设置 ➊ 存储了 64 位（表示为 Java `long` 类型）盐值，*lockscreen.password_type_alternate*
    设置 ➋ 包含当前解锁方法的备份（也叫备用）解锁方法类型（0 表示无）。*lockscreen.password_type* ➌ 存储了当前选定的密码类型，由
    `DevicePolicyManager` 类中定义的相应 `PASSWORD_QUALITY` 常量的值表示。在这个示例中，131072（十六进制为 0x00020000）对应
    `PASSWORD_QUALITY_NUMERIC` 常量，这是数字 PIN 提供的密码质量。最后，*lockscreen.passwordhistory*
    ➍ 存储了密码历史记录，保存为以前的 PIN 或密码哈希值的序列，用逗号分隔。只有当通过 `DevicePolicyManager` 类中的 `setPasswordHistoryLength()`
    方法将历史记录长度设置为大于零的值时，历史记录才会被保存。当密码历史记录可用时，输入与历史记录中任何密码相同的新密码是禁止的。
- en: The password hash can be easily calculated by concatenating the password or
    PIN string (*1234* for this example) with the salt value formatted as a hexadecimal
    string (*5fe37a926983d657* for this example) and calculating the SHA-1 and MD5
    hashes of the resulting string, as shown in [Example 10-11](ch10.html#calculating_a_pin_or_password_hash_using
    "Example 10-11. Calculating a PIN or password hash using sha1sum and md5sum").
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 密码哈希可以通过将密码或 PIN 字符串（在本例中为 *1234*）与盐值（在本例中为 *5fe37a926983d657*，格式为十六进制字符串）连接起来，然后计算结果字符串的
    SHA-1 和 MD5 哈希值，轻松计算出来，如 [示例 10-11](ch10.html#calculating_a_pin_or_password_hash_using
    "示例 10-11。使用 sha1sum 和 md5sum 计算 PIN 或密码的哈希值") 所示。
- en: Example 10-11. Calculating a PIN or password hash using sha1sum and md5sum
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-11。使用 sha1sum 和 md5sum 计算 PIN 或密码的哈希值
- en: '[PRE10]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example the hashes are calculated using the `sha1sum` ➊ and `md5sum`
    ➋ commands. When concatenated ➌, the output of the two commands produces the string
    contained in the *password.key* file shown in [Example 10-9](ch10.html#contents_of_the_solidusdatasolidusmiscso
    "Example 10-9. Contents of the /data/misc/password.key file").
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，哈希值是通过使用 `sha1sum` ➊ 和 `md5sum` ➋ 命令计算的。当这两个命令的输出结果 ➌ 被连接时，它会生成一个字符串，该字符串包含在
    [示例 10-9](ch10.html#contents_of_the_solidusdatasolidusmiscso "示例 10-9。/data/misc/password.key
    文件的内容") 中所示的 *password.key* 文件。
- en: Note that while using a random hash makes it impossible to use a single precalculated
    table for brute-forcing the PIN or password of any device, calculating the password
    or hash requires a single hash invocation, so generating a targeted hash table
    for a particular device (assuming the salt value is also available) is still relatively
    cheap. Additionally, while Android calculates both the SHA-1 and MD5 hashes of
    the PIN or password, this provides no security value, as it is sufficient to target
    the shorter hash (MD5) in order to uncover the PIN or password.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然使用随机哈希使得无法使用单一的预计算表来暴力破解任何设备的PIN码或密码，但计算密码或哈希仍然需要一次哈希调用，因此为特定设备生成目标哈希表（假设盐值也可用）仍然相对便宜。此外，尽管Android计算了PIN码或密码的SHA-1和MD5哈希值，但这并没有提供额外的安全性，因为只需针对较短的哈希（MD5）即可破解PIN码或密码。
- en: The entered password is checked against the stored hash using the `LockPatternUtils.checkPassword()`
    method, and the hash of a user-supplied password is calculated and persisted using
    the one of the `saveLockPassword()` methods of that class. Calling `saveLockPassword()`
    updates the *password.key* file for the target (or current) user. Like *gesture.key*,
    this file is owned by the *system* user and has permissions 0600\. In addition
    to updating the password hash, `saveLockPassword()` calculates the complexity
    of the entered password and updates the `value` column corresponding to the *lockscreen.password_type*
    key (➌ in [Example 10-10](ch10.html#contents_of_solidusdatasolidussy-id00023 "Example 10-10. Contents
    of /data/system/locksettings.db for the owner user")) in *locksettings.db* with
    the calculated complexity value. If password history is enabled, `saveLockPassword()`
    also adds the PIN or password hash to the `locksettings` table (➍ in [Example 10-11](ch10.html#calculating_a_pin_or_password_hash_using
    "Example 10-11. Calculating a PIN or password hash using sha1sum and md5sum")).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的密码将通过`LockPatternUtils.checkPassword()`方法与存储的哈希值进行比对，并且使用该类中的`saveLockPassword()`方法之一计算并保存用户提供的密码的哈希值。调用`saveLockPassword()`会更新目标（或当前）用户的*password.key*文件。像*gesture.key*一样，这个文件属于*system*用户，并具有0600权限。除了更新密码哈希外，`saveLockPassword()`还会计算输入密码的复杂度，并使用计算出的复杂度值更新`locksettings.db`中与*lockscreen.password_type*键对应的`value`列（➌，见[示例10-10](ch10.html#contents_of_solidusdatasolidussy-id00023
    "示例10-10：/data/system/locksettings.db的内容")）。如果启用了密码历史功能，`saveLockPassword()`还会将PIN码或密码的哈希值添加到`locksettings`表中（➍，见[示例10-11](ch10.html#calculating_a_pin_or_password_hash_using
    "示例10-11：使用sha1sum和md5sum计算PIN或密码哈希")）。
- en: Recall that when the device is encrypted, the PIN or password is used to derive
    a KEK that encrypts the disk encryption key. Therefore, changing the PIN or password
    of the owner user also re-encrypts the disk encryption key by calling the `changeEncryptionPassword()`
    method of the system’s `MountService`. (Changing the PIN or password of a secondary
    user does not affect the disk encryption key.)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当设备被加密时，PIN码或密码用于推导出一个KEK，KEK用于加密磁盘加密密钥。因此，修改拥有者用户的PIN码或密码也会通过调用系统的`MountService`中的`changeEncryptionPassword()`方法重新加密磁盘加密密钥。（修改二级用户的PIN码或密码不会影响磁盘加密密钥。）
- en: PIN and PUK Unlock
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PIN码和PUK解锁
- en: The PIN and PUK security modes are not lockscreen unlock methods per se because
    they depend on the state of the device’s SIM card and are only shown if the SIM
    card is in a locked state. A SIM card can require users to enter a preconfigured
    PIN code in order to unlock the card and get access to any network authentication
    keys stored inside, which are required to register with the mobile network and
    place non-emergency calls.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: PIN码和PUK安全模式本身并不是锁屏解锁方法，因为它们依赖于设备SIM卡的状态，只有在SIM卡处于锁定状态时才会显示。SIM卡可能要求用户输入预配置的PIN码才能解锁卡片，并访问存储在其中的任何网络认证密钥，这些密钥用于与移动网络注册和拨打非紧急电话。
- en: Because a SIM card retains its unlock state until reset, the PIN code typically
    must be entered only when the device first boots. If an incorrect code is entered
    more than three times, the SIM card locks and requires the user to enter a separate
    code to unlock it called the *PIN unlock key (PUK)*, or *personal unblocking code
    (PUC)*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SIM卡在重置之前保持解锁状态，因此PIN码通常只在设备首次启动时需要输入。如果输入错误的代码超过三次，SIM卡会被锁定，用户需要输入一个单独的代码来解锁它，这个代码称为*PIN解锁密钥（PUK）*，或*个人解锁码（PUC）*。
- en: When the lockscreen is shown, Android checks the state of the SIM card, and
    if it’s `State.PIN_REQUIRED` (defined in the `IccCardConstants` class), it shows
    the SIM unlock keyguard view shown in [Figure 10-12](ch10.html#sim_unlock_screen
    "Figure 10-12. SIM unlock screen"). When the user enters a SIM unlock PIN, it’s
    passed to the `supplyPinReportResult()` method of the `ITelephony` interface (implemented
    in the `TeleService` system application), which in turn passes it to the device’s
    baseband processor (the device component that implements mobile network communication,
    also sometimes referred to as the *modem* or *radio*) via the radio interface
    daemon (*rild*). Finally, the baseband processor, which is directly connected
    to the SIM, sends the PIN to the SIM card and receives a status code in exchange.
    The status code is passed back to the unlock view via the same route. If the status
    code indicates that the SIM card accepted the PIN and no screen lock is configured,
    the home screen (launcher) is displayed next. If, on the other hand, a screen
    lock has been configured, it’s shown after unlocking the SIM card, and the user
    must enter their credentials in order to unlock the device.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当锁屏显示时，Android会检查SIM卡的状态，如果是`State.PIN_REQUIRED`（在`IccCardConstants`类中定义），则显示[图10-12](ch10.html#sim_unlock_screen
    "图10-12. SIM解锁屏幕")所示的SIM解锁键盘视图。当用户输入SIM解锁PIN时，该PIN会传递给`ITelephony`接口的`supplyPinReportResult()`方法（在`TeleService`系统应用程序中实现），然后通过无线接口守护进程（*rild*）将其传递给设备的基带处理器（实现移动网络通信的设备组件，有时也称为*调制解调器*或*无线*）。最后，基带处理器直接与SIM卡连接，将PIN发送到SIM卡，并接收一个状态码作为响应。状态码通过相同的路径返回到解锁视图。如果状态码表明SIM卡接受了PIN且未配置屏幕锁定，则会显示主屏幕（启动器）。另一方面，如果已配置屏幕锁定，则在解锁SIM卡后会显示屏幕锁定，用户必须输入凭据才能解锁设备。
- en: '![SIM unlock screen](figs/web/10fig12.png.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![SIM解锁屏幕](figs/web/10fig12.png.jpg)'
- en: Figure 10-12. SIM unlock screen
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-12. SIM解锁屏幕
- en: If the SIM card is locked (that is, in the `PUK_REQUIRED` state), Android shows
    a PUK entry screen and allows the user to set up a new PIN after they unlock the
    card. The PUK and new PIN are passed to the `supplyPukReportResult()` method of
    the `ITelephony` interface, which delivers them to the SIM card. If a screen lock
    is configured, it is shown when the PUK is validated and the new PIN configured.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SIM卡被锁定（即处于`PUK_REQUIRED`状态），Android会显示PUK输入屏幕，并在解锁卡后允许用户设置新的PIN。PUK和新PIN会传递给`ITelephony`接口的`supplyPukReportResult()`方法，该方法将其传递到SIM卡。如果已配置屏幕锁定，则在验证PUK并配置新PIN后，屏幕锁定会显示出来。
- en: The `Keyguard` system application monitors SIM state changes by registering
    for the `TelephonyIntents.ACTION_SIM_ STATE_CHANGED` broadcast and shows the lockscreen
    if the card becomes locked or permanently disabled. Users can toggle the SIM card’s
    PIN protection by navigating to **Settings**▸**Security**▸ **Set up SIM card lock**
    and using the **Lock SIM card** checkbox.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Keyguard`系统应用程序通过注册`TelephonyIntents.ACTION_SIM_STATE_CHANGED`广播来监视SIM卡状态的变化，并在卡被锁定或永久禁用时显示锁屏。如果用户想要切换SIM卡的PIN保护，可以通过进入**设置**▸**安全性**▸**设置SIM卡锁**，并勾选**锁定SIM卡**复选框来操作。'
- en: '![Rate limiting after five subsequent failed authentication attempts](figs/web/10fig13.png.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![五次连续身份验证失败后的速率限制](figs/web/10fig13.png.jpg)'
- en: Figure 10-13. Rate limiting after five subsequent failed authentication attempts
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-13. 五次连续身份验证失败后的速率限制
- en: Brute-Force Attack Protection
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴力破解攻击防护
- en: Because complex passwords can be tricky to input on a touch screen keyboard,
    users typically use relatively short unlock credentials, which can easily be guessed
    or brute-forced. Android protects against brute-force attacks executed directly
    on the device (online attacks) by requiring users to wait 30 seconds after each
    five subsequent failed authentication attempts, as shown in [Figure 10-13](ch10.html#rate_limiting_after_five_subsequent_fail
    "Figure 10-13. Rate limiting after five subsequent failed authentication attempts").
    This technique is referred to as *rate limiting*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于复杂的密码在触摸屏键盘上输入起来比较麻烦，用户通常使用相对较短的解锁凭据，这些凭据容易被猜测或通过暴力破解获取。Android通过要求用户在每五次连续的身份验证失败后等待30秒，来防止直接在设备上进行的暴力破解攻击（在线攻击），如[图10-13](ch10.html#rate_limiting_after_five_subsequent_fail
    "图10-13. 五次连续身份验证失败后的速率限制")所示。这种技术称为*速率限制*。
- en: To further deter brute-force attacks, password complexity, expiration, and history
    rules can be set and enforced using the `DevicePolicyManager` API, as discussed
    in [Chapter 9](ch09.html "Chapter 9. Enterprise Security"). If the device stores
    or allows access to sensitive corporate data, device administrators can also set
    a threshold for the allowed failed authentication attempts using the `DevicePolicyManager.setMaximumFailedPasswordsForWipe()`
    method. When the threshold is reached, all user data on the device is automatically
    deleted, preventing attackers from gaining unauthorized access to it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步防止暴力破解攻击，可以通过 `DevicePolicyManager` API 设置并强制执行密码复杂性、过期时间和历史规则，正如在[第 9
    章](ch09.html "第 9 章. 企业安全")中讨论的那样。如果设备存储或允许访问敏感的企业数据，设备管理员还可以使用 `DevicePolicyManager.setMaximumFailedPasswordsForWipe()`
    方法设置允许的失败认证尝试阈值。当达到阈值时，设备上的所有用户数据将被自动删除，防止攻击者未经授权访问设备。
- en: Secure USB Debugging
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全的 USB 调试
- en: One reason for Android’s success is the low entry barrier to application development;
    apps can be developed on any OS, in a high-level language, without the need to
    invest in developer tools or hardware (when using the Android emulator). Developing
    software for embedded or other dedicated devices has traditionally been difficult,
    because it’s usually hard (or in some cases impossible) to inspect a program’s
    internal state or otherwise interact with the device in order to debug programs.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Android 成功的一个原因是其应用开发的低门槛；应用可以在任何操作系统上使用高级语言开发，无需投资开发工具或硬件（使用 Android 模拟器时）。为嵌入式或其他专用设备开发软件传统上一直很困难，因为通常很难（或者在某些情况下不可能）检查程序的内部状态或以其他方式与设备进行交互，从而调试程序。
- en: Since its earliest versions, Android has included a powerful device interaction
    toolkit that allows interactive debugging and inspecting device state, called
    the *Android Debug Bridge (ADB)*. ADB is typically turned off on consumer devices,
    but can be turned on via the system UI in order to enable app development and
    debugging on the device. Because ADB provides privileged access to the device’s
    filesystem and applications, it can be used to obtain unauthorized access to data.
    In the following sections, we’ll discuss ADB’s architecture, then discuss the
    steps recent Android versions have taken to restrict access to ADB.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Android 最早版本以来，Android 就包含了一个强大的设备交互工具包，允许进行交互式调试和检查设备状态，称为 *Android 调试桥（ADB）*。ADB
    通常在消费类设备上处于关闭状态，但可以通过系统 UI 打开，以启用设备上的应用开发和调试。由于 ADB 提供了对设备文件系统和应用程序的特权访问，它可以被用来获取未经授权的数据访问权限。在接下来的章节中，我们将讨论
    ADB 的架构，然后讨论近期 Android 版本采取的限制 ADB 访问的措施。
- en: ADB Overview
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADB 概述
- en: 'ADB keeps track of all devices (or emulators) connected to a host, and offers
    various services to its clients (command line clients, IDEs, and so on). It consists
    of three main components: the ADB server, the ADB daemon (*adbd),* and the default
    command-line client (`adb`). The ADB server runs on the host machine as a background
    process and decouples clients from the actual devices or emulators. It monitors
    device connectivity and sets their state appropriately (`CS_CONNECTED`, `CS_OFFLINE`,
    `CS_RECOVERY`, and so on).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ADB 跟踪所有连接到主机的设备（或模拟器），并为其客户端（命令行客户端、IDE 等）提供各种服务。它由三个主要组件组成：ADB 服务器、ADB 守护进程
    (*adbd*) 和默认的命令行客户端（`adb`）。ADB 服务器作为后台进程在主机上运行，将客户端与实际设备或模拟器解耦。它监控设备的连接状态，并根据情况设置其状态（`CS_CONNECTED`、`CS_OFFLINE`、`CS_RECOVERY`
    等）。
- en: The ADB daemon runs on an Android device (or emulator) and provides the actual
    services client use. It connects to the ADB server through USB or TCP/IP, and
    receives and processes commands from it. The `adb` command-line client lets you
    send commands to a particular device. In practice, it is implemented in the same
    binary as the ADB server and thus shares much of its code. [Figure 10-14](ch10.html#adb_architecture
    "Figure 10-14. ADB architecture") shows an overview of ADB’s architecture.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ADB 守护进程运行在 Android 设备（或模拟器）上，并提供客户端实际使用的服务。它通过 USB 或 TCP/IP 连接到 ADB 服务器，并接收和处理来自服务器的命令。`adb`
    命令行客户端允许你向特定设备发送命令。在实践中，它与 ADB 服务器实现于同一个二进制文件中，因此共享大量的代码。[图 10-14](ch10.html#adb_architecture
    "图 10-14. ADB 架构") 显示了 ADB 架构的概览。
- en: '![ADB architecture](figs/web/10fig14.png.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![ADB 架构](figs/web/10fig14.png.jpg)'
- en: Figure 10-14. ADB architecture
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-14. ADB 架构
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In addition to the native implementation in the `adb` command and the Java-based
    one in the Android Development Tools (ADT) Eclipse plugin, various third-party
    implementations of the ADB protocol are also available, including a Python client*^([[108](#ftn.ch10fn09)])
    *and an ADB server implemented in JavaScript,*^([[109](#ftn.ch10fn10)]) *which
    can be embedded in the Chrome browser as an extension.*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*除了在 `adb` 命令中的本地实现和在 Android 开发工具（ADT）Eclipse 插件中的基于 Java 的实现外，还可以使用各种第三方的
    ADB 协议实现，包括一个 Python 客户端*^([[108](#ftn.ch10fn09)]) *和一个用 JavaScript 实现的 ADB 服务器，*^([[109](#ftn.ch10fn10)])
    *可以作为扩展嵌入 Chrome 浏览器中。*'
- en: The client talks to the local ADB server via TCP (typically via *localhost:5037*)
    using text-based commands, and receives *OK* or *FAIL* responses in return. Some
    commands, like enumerating devices, port forwarding, or daemon restart are handled
    by the local daemon, while others (like shell or log access) require a connection
    to the target Android device. Device access is generally accomplished by forwarding
    input and output streams to/from the host. The transport layer that implements
    this uses simple messages with a 24-byte header, which contains a command identifier,
    two arguments, the length and CRC32 of the optional payload that follows, and
    a magic value, which simply flips all bits of the command. The message structure
    is defined in *system/core/adb/adb.h* and is shown in [Example 10-12](ch10.html#adb_message_structure
    "Example 10-12. ADB message structure") for reference. Messages are in turn encapsulated
    in packets, which are sent over the USB or TCP link to the ADB server running
    on the device.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通过 TCP（通常是 *localhost:5037*）与本地 ADB 服务器通信，使用基于文本的命令，并返回 *OK* 或 *FAIL* 响应。一些命令，比如列举设备、端口转发或守护进程重启，由本地守护进程处理，而其他命令（如
    shell 或日志访问）则需要与目标 Android 设备建立连接。设备访问通常通过将输入输出流转发到/从主机来实现。实现这一功能的传输层使用简单的消息，具有一个
    24 字节的头部，其中包含命令标识符、两个参数、可选负载的长度和 CRC32 校验码，以及一个魔数，该魔数仅仅是将命令的所有位翻转。消息结构在 *system/core/adb/adb.h*
    中定义，并在 [示例 10-12](ch10.html#adb_message_structure "示例 10-12。ADB 消息结构") 中提供参考。消息进一步封装在数据包中，通过
    USB 或 TCP 链接发送到运行在设备上的 ADB 服务器。
- en: Example 10-12. ADB message structure
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-12。ADB 消息结构
- en: '[PRE11]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We won’t discuss the ADB protocol in more detail other than to note the authentication
    commands added to the protocol in order to implement secure USB debugging. (For
    more details on ADB, see the protocol description in the *system/core/adb/protocol.txt*
    file in Android’s source tree.)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细讨论 ADB 协议，除了提到为了实现安全的 USB 调试，协议中添加了身份验证命令。（有关 ADB 的更多详细信息，请参阅 Android
    源代码树中的*system/core/adb/protocol.txt* 文件中的协议描述。）
- en: Note
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can enable trace logs for all ADB services by setting the `ADB_TRACE`
    environment variable to 1 on the host and the `persist.adb.trace_mask` system
    property on the device. Selected services can be traced by setting the value of
    `ADB_TRACE` or `persist.adb.trace_mask` to a comma- or space-separated (columns
    or semi-columns as a separator are also supported) list of service tags. See*
    system/core/adb/adb.c *for the full list of supported tags.*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以通过在主机上设置 `ADB_TRACE` 环境变量为 1，以及在设备上设置 `persist.adb.trace_mask` 系统属性，来启用所有
    ADB 服务的跟踪日志。通过将 `ADB_TRACE` 或 `persist.adb.trace_mask` 的值设置为以逗号或空格分隔的（列或分号作为分隔符也支持）服务标签列表，可以选择性地跟踪某些服务。有关支持的标签的完整列表，请参见*
    system/core/adb/adb.c *。*'
- en: The Need for Secure ADB
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全 ADB 的必要性
- en: If you’ve done any development, you know that “debugging” is usually the exact
    opposite of “secure.” Debugging typically involves inspecting (and sometimes even
    changing) internal program state, dumping encrypted communication data to log
    files, universal root access, and other scary but necessary activities. Debugging
    is hard enough without having to bother with security, so why further complicate
    things by adding additional security layers? Android debugging, as provided by
    the ADB, is quite versatile and gives you almost complete control over a device
    when enabled. This feature is, of course, very welcome when developing or testing
    an application (or the OS itself), but it can also be used for other purposes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做过开发，你就会知道，“调试”通常与“安全”是完全相反的。调试通常涉及检查（有时甚至修改）程序的内部状态，向日志文件中转储加密的通信数据，通用的
    root 权限访问，以及其他一些既可怕又必要的活动。调试本身就已经够难的了，如果还要考虑安全问题，那岂不是雪上加霜？所以，为什么要通过增加额外的安全层来进一步复杂化事情呢？通过
    ADB 提供的 Android 调试非常灵活，当启用时，它几乎可以让你完全控制设备。当然，这个功能在开发或测试应用程序（或操作系统本身）时非常受欢迎，但它也可以用于其他目的。
- en: 'Here’s a selective list of things ADB lets you do:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 ADB 让你可以做的一些选择性操作：
- en: Copy files to and from the device
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件复制到设备或从设备复制文件
- en: Debug apps running on the device (using JWDP or `gdbserver`)
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试设备上运行的应用（使用 JWDP 或 `gdbserver`）
- en: Execute shell commands on the device
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设备上执行 shell 命令
- en: Get the system and apps logs
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取系统和应用日志
- en: Install and remove apps
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和卸载应用
- en: If debugging is enabled on a device, you can do all of the above and more (for
    example, inject touch events or input text in the UI) simply by connecting the
    device to a computer with a USB cable. Because ADB does not depend on the device’s
    screen lock, you don’t have to unlock the device in order to execute ADB commands,
    and on most devices that provide root access, connecting via ADB allows you to
    access and change every file, including system files and password databases. Worse,
    you don’t actually need a computer with development tools in order to access an
    Android device via ADB; another Android device and a USB On-The-Go (OTG) cable
    are sufficient. Android tools that can extract as much data as possible from another
    device in a very short time are readily available.^([[110](#ftn.ch10fn11)]) If
    the device is rooted, such tools can extract all of your credentials, disable
    or brute-force the screen lock, and even log into your Google account. But even
    without root, anything on external storage, most notably photos, is accessible,
    as are your contacts and text messages.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备启用了调试功能，你只需通过 USB 电缆将设备连接到计算机，就可以做上述所有操作以及更多操作（例如，注入触摸事件或在 UI 中输入文本）。因为
    ADB 不依赖于设备的屏幕锁定，你不需要解锁设备就可以执行 ADB 命令，在大多数提供 root 访问权限的设备上，通过 ADB 连接可以访问和更改所有文件，包括系统文件和密码数据库。更糟的是，你实际上不需要一台具有开发工具的计算机就可以通过
    ADB 访问 Android 设备；另一台 Android 设备和一根 USB On-The-Go (OTG) 数据线就足够了。现在有许多 Android
    工具可以在短时间内从另一个设备提取尽可能多的数据^([[110](#ftn.ch10fn11)])。如果设备已经 root，这些工具可以提取你的所有凭据、禁用或暴力破解屏幕锁甚至登录你的
    Google 账户。但即使没有 root，外部存储中的任何东西，尤其是照片，也能被访问，包括你的联系人和短信。
- en: Securing ADB
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加固 ADB
- en: Android 4.2 was the first version to try to make ADB access harder by hiding
    the Developer options settings screen, requiring you to use a “secret knock” (tapping
    the build number seven times) in order to enable it. While not a very effective
    access protection method, it makes sure that most users don’t accidentally enable
    ADB access. This is, of course, only a stop-gap measure, and as soon as you manage
    to turn USB debugging on, your device is once again vulnerable.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.2 是第一个尝试通过隐藏开发者选项设置屏幕来使 ADB 访问更加困难的版本，它要求你使用“秘密敲击”（连续点击构建号七次）才能启用该选项。尽管这并不是一种非常有效的访问保护方法，但它可以确保大多数用户不会不小心启用
    ADB 访问。当然，这仅仅是一个权宜之计，一旦你成功开启了 USB 调试功能，设备再次处于易受攻击的状态。
- en: '![USB debugging authorization dialog](figs/web/10fig15.png.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![USB 调试授权对话框](figs/web/10fig15.png.jpg)'
- en: Figure 10-15. USB debugging authorization dialog
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-15. USB 调试授权对话框
- en: Android 4.2.2 introduced a proper solution with the so-called secure USB debugging
    feature. “Secure” here refers to the fact that only hosts that are explicitly
    authorized by the user can now connect to the *adbd* daemon on the device and
    execute debugging commands. Thus if someone tries to connect a device to another
    one via USB in order to access ADB, they must first unlock the target device and
    authorize access from the debug host by clicking OK in the confirmation dialog
    shown in [Figure 10-15](ch10.html#usb_debugging_authorization_dialog "Figure 10-15. USB
    debugging authorization dialog").
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.2.2 引入了一种正式的解决方案，称为安全 USB 调试功能。这里的“安全”指的是，只有用户明确授权的主机才能连接到设备上的 *adbd*
    守护进程并执行调试命令。因此，如果有人试图通过 USB 将设备连接到另一台设备以访问 ADB，他们必须先解锁目标设备，并通过点击确认对话框中的 OK 按钮授权调试主机的访问，[如图
    10-15](ch10.html#usb_debugging_authorization_dialog "图 10-15. USB 调试授权对话框")所示。
- en: You can make your decision persistent by checking the **Always allow from this
    computer** checkbox and debugging will work just as before, as long as you’re
    on the same machine.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过勾选**始终允许此计算机连接**复选框来使你的决策保持持久，并且只要你在同一台机器上，调试就会像以前一样正常工作。
- en: Naturally, this secure USB debugging is only effective if you have a reasonably
    secure lockscreen password in place.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，这种安全的 USB 调试功能只有在你设置了足够安全的锁屏密码的情况下才有效。
- en: Note
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*On tablets with multi-user support, the confirmation dialog is only shown
    to the primary (owner) user.*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*在支持多用户的平板电脑上，确认对话框仅会显示给主用户（所有者）。*'
- en: Secure ADB Implementation
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全 ADB 实现
- en: 'The ADB host authentication functionality is enabled by default when the *ro.adb.secure*
    system property is set to 1, and there is no way to disable it via the system
    interface. When a device connects to a host, it is initially in the `CS_UNAUTHORIZED`
    state and only goes into the `CS_DEVICE` state after the host has authenticated.
    Hosts use RSA keys in order to authenticate to the ADB daemon on the device, typically
    following this three-step process:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当*ro.adb.secure*系统属性设置为1时，启用ADB主机认证功能，并且无法通过系统接口禁用它。当设备连接到主机时，它最初处于`CS_UNAUTHORIZED`状态，只有在主机完成认证后才会进入`CS_DEVICE`状态。主机使用RSA密钥进行认证，以便向设备上的ADB守护进程进行身份验证，通常遵循以下三步过程：
- en: When a host tries to connect, the device sends an `A_AUTH` message with an argument
    of type `ADB_AUTH_TOKEN` that includes a 20-byte random value (read from */dev/urandom/*).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当主机尝试连接时，设备会发送`A_AUTH`消息，并带有`ADB_AUTH_TOKEN`类型的参数，其中包含一个20字节的随机值（从*/dev/urandom/*读取）。
- en: The host responds with an `A_AUTH` message with an argument of type `ADB_AUTH_SIGNATURE`,
    which includes a *SHA1withRSA* signature of the random token with one of the host’s
    private keys.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主机通过发送`A_AUTH`消息并带有`ADB_AUTH_SIGNATURE`类型的参数进行响应，该参数包括使用主机私钥之一对随机令牌的*SHA1withRSA*签名。
- en: The device tries to verify the received signature, and if signature verification
    succeeds, it responds with an `A_CNXN` packet and goes into the `CS_DEVICE` state.
    If verification fails, either because the signature value doesn’t match, or because
    there is no corresponding public key to verify with, the device sends another
    `ADB_AUTH_TOKEN` with a new random value so that the host can try authenticating
    again (slowing down if the number of failures goes over a certain threshold).
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备尝试验证收到的签名，如果签名验证成功，它会响应一个`A_CNXN`数据包并进入`CS_DEVICE`状态。如果验证失败，无论是因为签名值不匹配，还是因为没有对应的公钥来进行验证，设备将发送另一个`ADB_AUTH_TOKEN`并带有新的随机值，以便主机可以重新进行认证（如果失败次数超过某个阈值，速度会变慢）。
- en: Signature verification typically fails the first time you connect the device
    to a new host because it doesn’t yet have the host’s key. In that case the host
    sends its public key in an `A_AUTH` message with an `ADB_AUTH_RSAPUBLICKEY` argument.
    The device takes the MD5 hash of that key and displays it in the *Allow USB debugging
    confirmation* dialog shown in [Figure 10-15](ch10.html#usb_debugging_authorization_dialog
    "Figure 10-15. USB debugging authorization dialog"). Since *adbd* is a native
    daemon, the key must be passed to the main Android OS in order for its hash to
    be displayed on screen. This is accomplished by simply writing the key to a local
    socket (also named *adbd*), which the *adbd* daemon monitors.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 签名验证通常在第一次将设备连接到新主机时失败，因为设备尚未获取主机的公钥。在这种情况下，主机通过`A_AUTH`消息并带有`ADB_AUTH_RSAPUBLICKEY`参数发送其公钥。设备对该公钥进行MD5哈希并在*允许USB调试确认*对话框中显示该哈希，见[图
    10-15](ch10.html#usb_debugging_authorization_dialog "图 10-15. USB调试授权对话框")。由于*adbd*是本地守护进程，因此必须将密钥传递给主Android操作系统，以便其哈希值可以在屏幕上显示。这是通过将密钥写入一个本地套接字（也命名为*adbd*）来完成的，该套接字由*adbd*守护进程监控。
- en: When you enable ADB debugging from the developer settings screen, a thread that
    listens to that *adbd* socket is started. When the thread receives a message starting
    with *PK*, it treats it as a public key, parses it, calculates the MD5 hash and
    displays the confirmation dialog (implemented in a dedicated activity, `UsbDebuggingActivity`,
    part of the SystemUI package). If you tap OK, the activity sends a simple *OK*
    response to *adbd*, which uses the key to verify the authentication message. If
    you check the Always allow from this computer checkbox, the public key is written
    to disk and automatically used for signature verification the next time you connect
    to the same host.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在开发者设置屏幕上启用ADB调试时，会启动一个线程来监听该*adbd*套接字。当线程收到以*PK*开头的消息时，它将其视为公钥，解析该公钥，计算MD5哈希并显示确认对话框（该对话框实现于一个专用的活动`UsbDebuggingActivity`，是SystemUI包的一部分）。如果你点击“确定”，该活动会向*adbd*发送一个简单的*OK*响应，*adbd*使用该公钥验证认证消息。如果你勾选了“始终允许来自此计算机的连接”复选框，该公钥将被写入磁盘，并在下次连接同一主机时自动用于签名验证。
- en: Note
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*As of version 4.3, Android allows you to clear all saved host authentication
    keys. This functionality can be triggered by selecting Settings*▸*Developer options*▸*Revoke
    USB debugging authorizations.*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*从4.3版本开始，Android允许你清除所有已保存的主机认证密钥。你可以通过选择“设置”▸“开发者选项”▸“撤销USB调试授权”来触发此功能。*'
- en: The `UsbDeviceManager` class provides public methods for allowing and denying
    USB debugging, clearing cached authentication keys, as well as for starting and
    stopping the *adbd* daemon. Those methods are made available to other applications
    via the `IUsbManager` AIDL interface of the system `UsbService`. Calling `IUsbManager`
    methods that modify device state requires the `MANAGE_USB` system signature permission.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`UsbDeviceManager` 类提供了公开的方法，允许和拒绝 USB 调试、清除缓存的认证密钥，以及启动和停止 *adbd* 守护进程。这些方法通过系统
    `UsbService` 的 `IUsbManager` AIDL 接口提供给其他应用程序。调用修改设备状态的 `IUsbManager` 方法需要 `MANAGE_USB`
    系统签名权限。'
- en: ADB Authentication Keys
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADB 认证密钥
- en: 'Although we described the ADB authentication protocol above, we haven’t said
    much about the actual keys used in the process: 2048-bit RSA keys generated by
    the local ADB server. These keys are typically stored in *$HOME/.android* (*%USERPOFILE%\.android*
    on Windows) as *adbkey* (private key) and *adbkey.pub* (public key). The default
    key directory can be overridden by setting the `ANDROID_SDK_HOME` environment
    variable. If the `ADB_VENDOR_KEYS` environment variable is set, the directory
    it points to is also searched for keys. If no keys are found in any of the above
    locations, a new key pair is generated and saved.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经描述了 ADB 认证协议，但尚未详细介绍过程中使用的实际密钥：由本地 ADB 服务器生成的 2048 位 RSA 密钥。这些密钥通常存储在
    *$HOME/.android*（在 Windows 上为 *%USERPROFILE%\.android*）中，分别为 *adbkey*（私钥）和 *adbkey.pub*（公钥）。可以通过设置
    `ANDROID_SDK_HOME` 环境变量来覆盖默认的密钥目录。如果设置了 `ADB_VENDOR_KEYS` 环境变量，则会搜索它指向的目录中的密钥。如果在上述任何位置都没有找到密钥，则会生成并保存一对新的密钥。
- en: The private key file (*adbkey*), which is only stored on the host, is in standard
    OpenSSL PEM format. The public key file (*adbkey.pub*) contains the Base 64–encoded
    mincrypt-compatible representation of the public key, which is basically a serialization
    of mincrypt’s `RSAPublicKey` structure (see “[Enabling Verified Boot](ch10.html#enabling_verified_boot
    "Enabling Verified Boot")”), followed by a *user@host* user identifier, separated
    by space. The user identifier doesn’t seem to be used as of this writing and is
    only meaningful on Unix-based OSes; on Windows, it is always *unknown@unknown*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥文件（*adbkey*）仅存储在主机上，采用标准的 OpenSSL PEM 格式。公钥文件（*adbkey.pub*）包含公钥的 Base 64 编码的
    mincrypt 兼容表示形式，基本上是 mincrypt 的 `RSAPublicKey` 结构的序列化（参见 “[启用验证引导](ch10.html#enabling_verified_boot
    "启用验证引导")”），后跟一个 *user@host* 用户标识符，二者以空格分隔。根据目前的情况，用户标识符似乎未被使用，仅在基于 Unix 的操作系统中有意义；在
    Windows 上，它始终是 *unknown@unknown*。
- en: Keys are stored on the device in the */data/misc/adb/adb_keys/* file, and new
    authorized keys are appended to the same file as you accept them. Read-only “vendor
    keys” are stored in the */adb_keys* file, but it doesn’t seem to exist on current
    Nexus devices. Public keys are in the same format as on the host, making it easy
    to load in libmincrypt, which *adbd* links statically. [Example 10-13](ch10.html#contents_of_the_adbunderscorekeys_file
    "Example 10-13. Contents of the adb_keys file") shows some sample *adb_keys*.
    The file is owned by the *system* user, its group is set to *shell*, and its permissions
    to 0640.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥存储在设备上的 */data/misc/adb/adb_keys/* 文件中，接受新授权的密钥时会附加到同一文件中。只读的“厂商密钥”存储在 */adb_keys*
    文件中，但目前似乎在 Nexus 设备上不存在。公钥与主机上的格式相同，这使得它能够轻松加载到 libmincrypt 中，而 *adbd* 静态链接该库。[示例
    10-13](ch10.html#contents_of_the_adbunderscorekeys_file "示例 10-13. adb_keys 文件的内容")
    显示了一些示例 *adb_keys*。该文件归 *system* 用户所有，组设置为 *shell*，权限为 0640。
- en: Example 10-13. Contents of the adb_keys file
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-13. adb_keys 文件的内容
- en: '[PRE12]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Verifying the Host Key Fingerprint
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证主机密钥指纹
- en: While the USB debugging confirmation dialog helpfully displays a key fingerprint
    to let you verify that you’re connected to the expected host, the `adb` client
    doesn’t have a handy command to print the fingerprint of the host key. Although
    it may seem that there’s little room for confusion (after all, there is only one
    cable plugged in to a single machine) when running a couple of VMs, things can
    get a little fuzzy. [Example 10-14](ch10.html#displaying_the_host_keyapostrophes_finge
    "Example 10-14. Displaying the host key’s fingerprint") shows one way to display
    the host key’s fingerprint in the same format used by the confirmation dialog
    shown in [Figure 10-15](ch10.html#usb_debugging_authorization_dialog "Figure 10-15. USB
    debugging authorization dialog") (run in *$HOME/.android* or specify the full
    path to the public key file).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 USB 调试确认对话框会显示一个密钥指纹，帮助你验证是否连接到预期的主机，但 `adb` 客户端没有一个方便的命令来打印主机密钥的指纹。虽然在运行几个虚拟机时看起来似乎不容易混淆（毕竟只有一根电缆插入到一台机器上），但事情可能会变得有些模糊。[示例
    10-14](ch10.html#displaying_the_host_keyapostrophes_finge "示例 10-14. 显示主机密钥的指纹")展示了一种显示主机密钥指纹的方式，格式与在[图
    10-15](ch10.html#usb_debugging_authorization_dialog "图 10-15. USB 调试授权对话框")中显示的确认对话框相同（运行在
    *$HOME/.android* 目录下，或者指定公钥文件的完整路径）。
- en: Example 10-14. Displaying the host key’s fingerprint
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-14. 显示主机密钥的指纹
- en: '[PRE13]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Android Backup
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 备份
- en: Android includes a backup framework that allows application data to be backed
    up to Google’s cloud storage and supports full backup of installed APK files,
    application data, and external storage files to a host machine connected via USB.
    While device backup is not exactly a security feature, backups allow application
    data to be extracted from the device, which can present a security issue.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Android 包含一个备份框架，允许应用程序数据备份到 Google 的云存储，并支持将已安装的 APK 文件、应用程序数据和外部存储文件通过 USB
    连接到主机的方式进行完全备份。虽然设备备份不完全是一个安全功能，但备份允许从设备中提取应用程序数据，这可能会带来安全问题。
- en: Android Backup Overview
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 备份概述
- en: Android’s backup framework was publicly announced in Android 2.2, but it was
    probably available internally earlier. The framework lets applications declare
    special components called *backup agents*, which are called by the system when
    creating a backup for an application and when restoring its data. While the backup
    framework did support pluggable backup transports internally, initially the only
    transport that was usable in practice was a proprietary one that stores application
    data in Google’s cloud storage.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的备份框架在 Android 2.2 中公开宣布，但它可能在内部更早就已经可用。该框架让应用程序声明一种特殊的组件，称为 *备份代理*，在为应用程序创建备份和恢复数据时，系统会调用这些代理。尽管备份框架内部支持可插拔的备份传输，但最初唯一可以实际使用的传输方式是一个专有的传输方式，它将应用程序数据存储在
    Google 的云存储中。
- en: Cloud Backup
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云备份
- en: Because backups are associated with a user’s Google account, when they install
    an application that has a backup agent on a new device, the application’s data
    can be automatically restored if the user has registered the same Google account
    as the one used when the backup was created. Backup and restore is managed by
    the system and cannot typically be triggered or controlled by users (though developer
    commands that trigger cloud backup are accessible via the Android shell). By default,
    backups are triggered periodically, and restore only when an app is first installed
    on a device.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于备份与用户的 Google 账户相关联，当用户在新设备上安装带有备份代理的应用程序时，如果用户注册了与备份创建时相同的 Google 账户，应用程序的数据可以自动恢复。备份和恢复由系统管理，通常无法由用户触发或控制（尽管可以通过
    Android shell 使用开发者命令触发云备份）。默认情况下，备份会定期触发，恢复仅在应用首次安装到设备时进行。
- en: Local Backup
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地备份
- en: Android 4.0 added a new, local backup transport that lets users save backups
    to a file on their desktop computer as well. Local backup (also called full backup)
    requires ADB debugging to be enabled and authorized because backup data is streamed
    to the host computer using the same method that ADB (via `adb pull`) employs to
    transfer device files to a host.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.0 添加了一种新的本地备份传输方式，允许用户将备份保存到桌面计算机上的文件中。本地备份（也称为完全备份）需要启用并授权 ADB 调试，因为备份数据是通过与
    ADB（通过 `adb pull`）传输设备文件到主机的相同方式流式传输到主机计算机的。
- en: '![Backup confirmation dialog](figs/web/10fig16.png.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![备份确认对话框](figs/web/10fig16.png.jpg)'
- en: Figure 10-16. Backup confirmation dialog
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-16. 备份确认对话框
- en: Full backup is started by executing the `adb backup` command in a shell. This
    command starts a new Java process on the device, which binds to the system’s `BackupManagerService`
    and requests a backup with the parameters specified to `adb backup`. The `BackupManagerService`
    in turn starts a confirmation activity like the one shown in [Figure 10-16](ch10.html#backup_confirmation_dialog
    "Figure 10-16. Backup confirmation dialog"), prompting the user to authorize the
    backup and specify a backup encryption password if desired. If the device is already
    encrypted, the user must enter the device encryption password to proceed. This
    password will be used to encrypt the backup as well, because using a dedicated
    backup encryption password is not supported. The full backup process is started
    when the user presses the Back up my data button.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 完整备份通过在终端执行`adb backup`命令启动。该命令在设备上启动一个新的Java进程，该进程绑定到系统的`BackupManagerService`并请求进行备份，使用传递给`adb
    backup`的参数。`BackupManagerService`随后会启动一个确认活动，如[图10-16](ch10.html#backup_confirmation_dialog
    "图10-16. 备份确认对话框")所示，提示用户授权备份并在需要时指定备份加密密码。如果设备已加密，用户必须输入设备加密密码才能继续。该密码还将用于加密备份，因为不支持使用专用的备份加密密码。当用户按下“备份我的数据”按钮时，完整备份过程开始。
- en: Full backup calls the backup agent of each target package in order to obtain
    a copy of its data. If a backup agent is not defined, the `BackupManagerService`
    uses an internal `FullBackupAgent` class, which copies all of the package’s files.
    Full backup honors the `allowBackup` attribute of the `<application>` tag in the
    package’s *AndroidManifest.xml* file, and will not extract package data if `allowBackup`
    is set to `false`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 完整备份会调用每个目标包的备份代理，以获取其数据副本。如果未定义备份代理，`BackupManagerService`将使用内部的`FullBackupAgent`类，该类会复制包的所有文件。完整备份会遵循包中`<application>`标签的`allowBackup`属性，如果`allowBackup`设置为`false`，则不会提取包数据。
- en: 'In addition to application data, full backup can include user-installed and
    system application APK files, as well as external storage contents, with some
    limitations: full backup doesn’t back up protected (with DRM) apps, and skips
    some system settings such as mobile network APNs and Wi-Fi access points’ connection
    details.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 除了应用数据外，完整备份还可以包括用户安装的和系统应用的APK文件，以及外部存储内容，但有一些限制：完整备份不会备份受保护（带有DRM）的应用，并且会跳过一些系统设置，如移动网络APN和Wi-Fi接入点的连接详情。
- en: Backups are restored using the `adb restore` command. Backup restore is quite
    limited and doesn’t allow any options to be specified, as it can only perform
    a full restore.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 备份通过`adb restore`命令恢复。备份恢复功能非常有限，并且不允许指定任何选项，因为它只能执行完全恢复。
- en: Backup File Format
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份文件格式
- en: Android backup files start with a few lines of text, followed by binary data.
    These lines are the backup header and they specify the backup format and encryption
    parameters (if a backup password was specified) used to create the backup. The
    header of an unencrypted backup is shown in [Example 10-15](ch10.html#unencrypted_backup_header
    "Example 10-15. Unencrypted backup header").
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Android备份文件以几行文本开头，后面是二进制数据。这些行是备份头，指定了用于创建备份的备份格式和加密参数（如果指定了备份密码）。未加密备份的头部如[示例10-15](ch10.html#unencrypted_backup_header
    "示例10-15. 未加密备份头")所示。
- en: Example 10-15. Unencrypted backup header
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 示例10-15. 未加密备份头
- en: '[PRE14]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first line ➊ is the file magic (format identifier), the second ➋ is the
    backup format version (1 up till Android 4.4.2, 2 in later versions; version 2
    denotes a change in the key derivation method, which now takes into account multibyte
    password characters), the third ➌ is a compression flag (1 if compressed), and
    the last ➍ is the encryption algorithm used (*none* or *AES-256*).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行 ➊ 是文件魔术（格式标识符），第二行 ➋ 是备份格式版本（Android 4.4.2及以前为版本1，之后版本为2；版本2表示密钥派生方法发生了变化，现在考虑了多字节密码字符），第三行
    ➌ 是压缩标志（如果压缩，则为1），最后一行 ➍ 是所使用的加密算法（*none* 或 *AES-256*）。
- en: The actual backup data is a compressed and optionally encrypted tar file that
    includes a backup manifest file, followed by the application APK (if any), and
    app data (files, databases, and shared preferences). The data is compressed using
    the deflate algorithm and can be decompressed using OpenSSL’s `zlib` command,
    as shown in [Example 10-16](ch10.html#uncompressing_an_android_backup_using_op
    "Example 10-16. Uncompressing an Android backup using OpenSSL").
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的备份数据是一个压缩的、可选加密的 tar 文件，其中包含一个备份清单文件，接着是应用 APK（如果有的话），以及应用数据（文件、数据库和共享偏好设置）。数据使用
    deflate 算法进行压缩，可以通过 OpenSSL 的 `zlib` 命令解压缩，如 [示例 10-16](ch10.html#uncompressing_an_android_backup_using_op
    "示例 10-16：使用 OpenSSL 解压 Android 备份") 中所示。
- en: Example 10-16. Uncompressing an Android backup using OpenSSL
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-16：使用 OpenSSL 解压 Android 备份
- en: '[PRE15]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After the backup is uncompressed, you can view its contents or extract it with
    the standard `tar` command, as shown in [Example 10-17](ch10.html#viewing_the_contents_of_an_uncompressed
    "Example 10-17. Viewing the contents of an uncompressed backup using tar").
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在备份解压后，您可以使用标准的 `tar` 命令查看其内容或提取内容，如 [示例 10-17](ch10.html#viewing_the_contents_of_an_uncompressed
    "示例 10-17：使用 tar 查看未压缩备份的内容") 中所示。
- en: Example 10-17. Viewing the contents of an uncompressed backup using `tar`
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-17：使用 `tar` 查看未压缩备份的内容
- en: '[PRE16]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Inside the tar file, app data is stored in the *apps/* directory, which contains
    a subdirectory for each backed-up package. Each package directory includes a *_manifest*
    file ➊ in its root, the APK file (if requested) in *a/* ➋, app files in *f/* ➌,
    databases in *db/* ➍, and shared preferences in *sp/* ➎. The manifest contains
    the app’s package name and version code, the platform’s version code, a flag indicating
    whether the archive contains the app APK, and the app’s signing certificate.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 tar 文件内部，应用数据存储在 *apps/* 目录中，该目录为每个备份的包提供一个子目录。每个包目录的根目录中包含一个 *_manifest*
    文件 ➊，APK 文件（如果有请求）存放在 *a/* ➋，应用文件存放在 *f/* ➌，数据库存放在 *db/* ➍，共享偏好设置存放在 *sp/* ➎。清单文件包含应用的包名和版本号、平台的版本号、一个标志，指示存档是否包含应用的
    APK，以及应用的签名证书。
- en: The `BackupManagerService` uses this information when restoring an app in order
    to check whether it’s been signed with the same certificate as the currently installed
    one. If the certificates don’t match, it will skip installing the APK, except
    for system packages, which might be signed with a different (manufacturer-owned)
    certificate on different devices. Additionally, `BackupManagerService` expects
    the files to be in the order shown in [Example 10-17](ch10.html#viewing_the_contents_of_an_uncompressed
    "Example 10-17. Viewing the contents of an uncompressed backup using tar") and
    restore will fail if they are out for order. For example, if the manifest states
    that the backup includes an APK, the `BackupManagerService` will try to read and
    install the APK first, before restoring the app’s files. This restore order is
    required because you cannot restore files for an app you don’t have installed.
    However, `BackupManagerService` will not search for the APK in the archive, and
    if it is not right after the manifest, all other files will be skipped.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`BackupManagerService` 在恢复应用时使用这些信息，以检查它是否与当前安装的应用使用相同的证书进行签名。如果证书不匹配，它将跳过安装
    APK，系统包除外，因为它们可能在不同设备上使用不同的（制造商拥有的）证书进行签名。此外，`BackupManagerService` 期望文件按 [示例
    10-17](ch10.html#viewing_the_contents_of_an_uncompressed "示例 10-17：使用 tar 查看未压缩备份的内容")
    中所示的顺序排列，如果顺序不对，恢复将失败。例如，如果清单文件声明备份包含 APK，`BackupManagerService` 会先尝试读取并安装 APK，然后再恢复应用的其他文件。此恢复顺序是必需的，因为无法恢复未安装的应用文件。然而，`BackupManagerService`
    不会在存档中搜索 APK，如果 APK 不紧跟在清单文件之后，所有其他文件将被跳过。'
- en: If the user requested external storage backup (by passing the `-shared` option
    to `adb backup`), there will also be a *shared/* directory in the archive, containing
    external storage files.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户请求了外部存储备份（通过将 `-shared` 选项传递给 `adb backup`），存档中还会包含一个 *shared/* 目录，包含外部存储文件。
- en: Backup Encryption
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份加密
- en: If the user supplied an encryption password when requesting the backup, the
    backup file is encrypted with a key derived from the password. The password is
    used to generate a 256-bit AES key using 10,000 rounds of PBKDF2 with a randomly
    generated 512-bit salt. This key is then used to encrypt another, randomly generated
    256-bit AES bit master key, which is in turn used to encrypt the actual archive
    data in CBC mode (using the *AES/CBC/PKCS5Padding* `Cipher` transformation). A
    master key checksum is also calculated and saved in the backup file header. In
    order to generate the checksum, the generated raw master key is converted to a
    Java character array by casting each byte to `char`, with the result treated as
    a password string, and run through the PBKDF2 function to effectively generate
    another AES key, whose bytes are used as the checksum.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在请求备份时提供了加密密码，则备份文件会使用从密码派生的密钥进行加密。该密码用于通过10,000轮PBKDF2算法与随机生成的512位盐值一起生成256位的AES密钥。这个密钥接着用来加密另一个随机生成的256位AES主密钥，该主密钥随后用于在CBC模式下加密实际的归档数据（使用*AES/CBC/PKCS5Padding*
    `Cipher` 转换）。还会计算并保存主密钥的校验和到备份文件头部。为了生成校验和，生成的原始主密钥会通过将每个字节转换为`char`的方式转化为Java字符数组，结果作为密码字符串，并通过PBKDF2函数生成另一个AES密钥，之后其字节将作为校验和。
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Because an AES key is essentially a random byte sequence, the raw key usually
    contains several bytes that don’t map to printable characters. Because PKCS#5
    does not specify the actual encoding of a password string, Android’s encryption
    checksum generation method produces implementation and version-dependent results.*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于AES密钥本质上是随机字节序列，因此原始密钥通常包含几个无法映射到可打印字符的字节。由于PKCS#5未指定密码字符串的实际编码方式，Android的加密校验和生成方法会产生依赖于实现和版本的结果。*'
- en: The checksum is used to verify whether the user-supplied decryption password
    is correct before actually decrypting the backup data. When the master key is
    decrypted, its checksum is calculated using the method described above and then
    compared to the checksum in the archive header. If the checksums don’t match,
    the password is considered incorrect, and the restore process is aborted. [Example 10-18](ch10.html#encrypted_backup_header
    "Example 10-18. Encrypted backup header") shows an example backup header for an
    encrypted archive.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和用于在实际解密备份数据之前验证用户提供的解密密码是否正确。当主密钥被解密时，会使用上述方法计算其校验和，并与归档头中的校验和进行比较。如果校验和不匹配，则认为密码不正确，恢复过程将被中止。[示例
    10-18](ch10.html#encrypted_backup_header "示例 10-18. 加密备份头")展示了加密归档文件的示例备份头。
- en: Example 10-18. Encrypted backup header
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-18. 加密备份头
- en: '[PRE17]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, *AES-256* ➊ is the backup encryption algorithm used, the next line ➋ is
    the user password salt as a hexadecimal string, followed by the master key checksum
    salt ➌, the number of PBKDF2 rounds used to derive a key ➍, and the user key IV
    ➎. The final line ➏ is the master key blob, which contains the archive data encryption
    IV, the actual master key and its checksum, all encrypted with the key derived
    from the user-supplied password. [Example 10-19](ch10.html#master_key_blob_format
    "Example 10-19. Master key blob format") shows the detailed format of the master
    key blob.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*AES-256* ➊ 是使用的备份加密算法，接下来一行 ➋ 是用户密码盐的十六进制字符串，随后是主密钥校验和盐 ➌、用于派生密钥的PBKDF2轮数
    ➍，以及用户密钥IV ➎。最后一行 ➏ 是主密钥数据块，包含归档数据加密IV、实际主密钥及其校验和，所有这些都使用从用户提供的密码派生的密钥进行加密。[示例
    10-19](ch10.html#master_key_blob_format "示例 10-19. 主密钥数据块格式")展示了主密钥数据块的详细格式。
- en: Example 10-19. Master key blob format
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-19. 主密钥数据块格式
- en: '[PRE18]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first field ➊ is the IV length, followed by the IV value ➋, the master key
    (MK) length ➌, and the actual master key ➍. The last two fields store the master
    key checksum hash length ➎, and the master key checksum hash itself ➏.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段 ➊ 是IV长度，接着是IV值 ➋、主密钥（MK）长度 ➌ 和实际主密钥 ➍。最后两个字段存储主密钥校验和哈希长度 ➎ 和主密钥校验和哈希本身
    ➏。
- en: Controlling Backup Scope
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制备份范围
- en: Android’s security model guarantees that each application runs within its own
    sandbox and that its files cannot be accessed by other applications or the device
    user, unless the application explicitly allows access. Therefore, most applications
    do not encrypt their data before storing it to disk. However, both legitimate
    users and attackers that have somehow obtained the device unlock password can
    easily extract applications data using Android’s full backup feature. For this
    reason, applications that store sensitive data should either encrypt it or provide
    an explicit backup agent that limits exportable data in order to guarantee that
    sensitive data cannot be easily extracted via backup.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的安全模型保证每个应用程序都在其自己的沙箱中运行，并且其文件无法被其他应用程序或设备用户访问，除非应用程序显式允许访问。因此，大多数应用程序在将数据存储到磁盘之前并不加密数据。然而，无论是合法用户还是通过某种方式获得设备解锁密码的攻击者，都可以轻松地通过
    Android 的完整备份功能提取应用程序数据。因此，存储敏感数据的应用程序应当对其进行加密，或提供一个明确的备份代理，限制可导出的数据，以确保敏感数据无法通过备份轻易提取。
- en: As mentioned in “[Android Backup Overview](ch10.html#android_backup_overview
    "Android Backup Overview")”, if application data backup isn’t needed or desirable,
    applications can disallow it completely by setting their `allowBackup` attribute
    to `false` in *AndroidManifest.xml*, as shown in [Example 10-20](ch10.html#disallowing_application_data_backup_in_a
    "Example 10-20. Disallowing application data backup in AndroidManifest.xml").
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如在“[Android 备份概述](ch10.html#android_backup_overview "Android 备份概述")”中所提到的，如果不需要或不希望备份应用数据，应用程序可以通过在
    *AndroidManifest.xml* 中将 `allowBackup` 属性设置为 `false` 来完全禁止备份，如[示例 10-20](ch10.html#disallowing_application_data_backup_in_a
    "示例 10-20. 禁止在 AndroidManifest.xml 中备份应用数据")所示。
- en: Example 10-20. Disallowing application data backup in AndroidManifest.xml
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-20. 禁止在 AndroidManifest.xml 中备份应用数据
- en: '[PRE19]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Android employs various measures in order to protect user data and applications,
    and ensure the integrity of the operating system. On production devices, the bootloader
    is locked, and the recovery OS only allows OTA updates signed by the device manufacturer
    to be installed, thus ensuring that only authorized OS builds can be booted or
    flashed to a device. When enabled, dm-verity-based verified boot guarantees that
    the *system* partition is not modified by checking the hash value of each device
    block against a trusted hash tree, which prevents the installation of malicious
    programs such as rootkits on the *system* partition. Android can also encrypt
    the *userdata* partition, making it harder to extract applications data by directly
    accessing storage devices.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Android 采取各种措施来保护用户数据和应用程序，并确保操作系统的完整性。在生产设备上，引导加载程序被锁定，恢复操作系统仅允许安装设备制造商签名的
    OTA 更新，从而确保只有经过授权的操作系统构建可以启动或闪存到设备上。当启用时，基于 dm-verity 的验证启动确保 *系统* 分区未被修改，通过检查每个设备块的哈希值与受信任的哈希树进行比对，从而防止恶意程序（如
    rootkit）在 *系统* 分区上安装。Android 还可以加密 *userdata* 分区，使得直接访问存储设备时更难提取应用程序数据。
- en: Android supports various screen lock methods and applies rate limiting to unsuccessful
    authentication attempts, thus deterring online attacks against a booted device.
    The type and complexity of the unlock PIN or password can be specified and enforced
    by device administrator applications. A device policy that wipes the device after
    too many unsuccessful authentication attempts is also supported. Secure USB debugging
    requires debug hosts to be explicitly authorized by the user and added to a whitelist,
    thus preventing information extraction via USB.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Android 支持各种屏幕锁定方法，并对不成功的身份验证尝试应用速率限制，从而有效防止针对已启动设备的在线攻击。解锁 PIN 码或密码的类型和复杂性可以由设备管理员应用程序指定并强制执行。也支持一种设备策略，即在多次失败的身份验证尝试后清除设备数据。安全的
    USB 调试要求调试主机必须得到用户明确授权并添加到白名单中，从而防止通过 USB 提取信息。
- en: Finally, full device backups can be encrypted with a key derived from a user-supplied
    password, making it harder to access device data that has been extracted into
    a backup. To achieve a higher level of device security, all supported security
    measures should be enabled and configured accordingly.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，完整设备备份可以通过由用户提供的密码派生的密钥进行加密，从而使得访问已提取到备份中的设备数据变得更加困难。为了实现更高水平的设备安全性，应启用并根据需要配置所有支持的安全措施。
- en: '* * *'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[100](#ch10fn01)]) Milan Broz, “dm-verity: device-mapper block integrity
    checking target,” *[https://code.google.com/p/cryptsetup/wiki/DMVerity](https://code.google.com/p/cryptsetup/wiki/DMVerity)*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[100](#ch10fn01)]) Milan Broz, “dm-verity：设备映射块完整性检查目标”， *[https://code.google.com/p/cryptsetup/wiki/DMVerity](https://code.google.com/p/cryptsetup/wiki/DMVerity)*
- en: ^([[101](#ch10fn02)]) Red Hat, Inc., “Device-Mapper Resource Page,” *[https://www.sourceware.org/dm/](https://www.sourceware.org/dm/)*
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[101](#ch10fn02)]) Red Hat, Inc.，“设备映射资源页面”， *[https://www.sourceware.org/dm/](https://www.sourceware.org/dm/)*
- en: ^([[102](#ch10fn03)]) Google, “dm-verity on boot,” *[https://source.android.com/devices/tech/security/dm-verity.html](https://source.android.com/devices/tech/security/dm-verity.html)*
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[102](#ch10fn03)]) Google, “dm-verity启动时”， *[https://source.android.com/devices/tech/security/dm-verity.html](https://source.android.com/devices/tech/security/dm-verity.html)*
- en: ^([[103](#ch10fn04)]) Google, *Android 4.4 Compatibility Definition*, “9.9\.
    Full-Disk Encryption,” *[https://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf](https://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf)*
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[103](#ch10fn04)]) Google, *Android 4.4 兼容性定义*，“9.9\. 全盘加密”， *[https://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf](https://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf)*
- en: '^([[104](#ch10fn05)]) Milan Broz, “dm-crypt: Linux kernel device-mapper crypto
    target,” *[https://code.google.com/p/cryptsetup/wiki/DMCrypt](https://code.google.com/p/cryptsetup/wiki/DMCrypt)*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[104](#ch10fn05)]) Milan Broz, “dm-crypt：Linux内核设备映射加密目标”， *[https://code.google.com/p/cryptsetup/wiki/DMCrypt](https://code.google.com/p/cryptsetup/wiki/DMCrypt)*
- en: ^([[105](#ch10fn06)]) Jakob Lell, “Practical malleability attack against CBC-Encrypted
    LUKS partitions,” *[http://www.jakoblell.com/blog/2013/12/22/practical-malleability-attack-against-cbc-encrypted-luks-partitions/](http://www.jakoblell.com/blog/2013/12/22/practical-malleability-attack-against-cbc-encrypted-luks-partitions/)*
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[105](#ch10fn06)]) Jakob Lell, “针对CBC加密LUKS分区的实用可塑性攻击”， *[http://www.jakoblell.com/blog/2013/12/22/practical-malleability-attack-against-cbc-encrypted-luks-partitions/](http://www.jakoblell.com/blog/2013/12/22/practical-malleability-attack-against-cbc-encrypted-luks-partitions/)*
- en: ^([[106](#ch10fn07)]) C. Percival and S. Josefsson, *The scrypt Password-Based
    Key Derivation Function*, *[http://tools.ietf.org/html/draft-josefsson-scrypt-kdf-01/](http://tools.ietf.org/html/draft-josefsson-scrypt-kdf-01/)*
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[106](#ch10fn07)]) C. Percival 和 S. Josefsson, *The scrypt 基于密码的密钥派生函数*，
    *[http://tools.ietf.org/html/draft-josefsson-scrypt-kdf-01/](http://tools.ietf.org/html/draft-josefsson-scrypt-kdf-01/)*
- en: ^([[107](#ch10fn08)]) Demonstrated by viaForensics in the “Into The Droid” talk,
    presented at DEF CON 20\. Slides are available at *[https://www.defcon.org/images/defcon-20/dc-20-presentations/Cannon/DEFCON-20-Cannon-Into-The-Droid.pdf](https://www.defcon.org/images/defcon-20/dc-20-presentations/Cannon/DEFCON-20-Cannon-Into-The-Droid.pdf)*
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[107](#ch10fn08)]) 由viaForensics在DEF CON 20的“Into The Droid”演讲中演示。演示幻灯片可在
    *[https://www.defcon.org/images/defcon-20/dc-20-presentations/Cannon/DEFCON-20-Cannon-Into-The-Droid.pdf](https://www.defcon.org/images/defcon-20/dc-20-presentations/Cannon/DEFCON-20-Cannon-Into-The-Droid.pdf)*
    获取
- en: '^([[108](#ch10fn09)]) Anthony King, “PyAdb: basic ADB core for python using
    TCP,” *[https://github.com/cybojenix/PyAdb/](https://github.com/cybojenix/PyAdb/)*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[108](#ch10fn09)]) Anthony King, “PyAdb：使用TCP的Python基础ADB核心”， *[https://github.com/cybojenix/PyAdb/](https://github.com/cybojenix/PyAdb/)*
- en: '^([[109](#ch10fn10)]) Kenny Root, “adb-on-chrome: ADB (Android Debug Bridge)
    server as a Chrome extension,” *[https://github.com/kruton/adb-on-chrome/](https://github.com/kruton/adb-on-chrome/)*'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '^([[109](#ch10fn10)]) Kenny Root, “adb-on-chrome: ADB（Android调试桥）服务器作为Chrome扩展”，
    *[https://github.com/kruton/adb-on-chrome/](https://github.com/kruton/adb-on-chrome/)*'
- en: ^([[110](#ch10fn11)]) Kyle Osborn, “p2p-adb Framework,” *[https://github.com/kosborn/p2p-adb/](https://github.com/kosborn/p2p-adb/)*
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[110](#ch10fn11)]) Kyle Osborn, “p2p-adb框架”， *[https://github.com/kosborn/p2p-adb/](https://github.com/kosborn/p2p-adb/)*
