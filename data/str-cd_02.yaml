- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1'
- en: A CHERRY-PICKED REVIEW OF PROGRAMMING LANGUAGES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 精选编程语言回顾
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: This book’s primary goal is to explore new ways to think about coding. Doing
    so will help you become a better coder, regardless of what language you are using.
    To that end, it makes sense to review existing programming languages, especially
    the languages that first introduced a particular coding paradigm or strongly influenced
    later languages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的主要目标是探索思考编码的新方式。做到这一点，将帮助你成为一名更好的程序员，无论你使用的是哪种语言。为了这个目标，回顾现有的编程语言是有意义的，特别是那些首次引入某种特定编码范式或对后来的语言产生了深远影响的语言。
- en: The languages discussed in this chapter are not esolangs. Instead, they are
    serious approaches to the process of coding, meaning the process of translating
    thought into something a computer can use to solve a problem. Some of these languages
    are still in use. Others flowered briefly and then died. Still others evolved
    into something new. All of these languages have things to teach us, in addition
    to being fun to learn about and work with.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的语言不是伪语言（esolangs）。相反，它们是对编码过程的严肃探索，即将思维转化为计算机可以用来解决问题的东西的过程。我们讨论的其中一些语言至今仍在使用，另一些语言曾一度繁荣，后来消亡。还有一些语言演变成了新的形态。这些语言除了有趣并值得学习和实践外，还能教给我们很多东西。
- en: We’ll begin the chapter with a bit of programming language paleontology. Following
    that, we’ll consider the first programming languages. Even if you are still relatively
    new to coding, you already have a conception of what coding is and how to do it.
    That wasn’t always the case—the very idea of coding had to come from somewhere.
    It’s worth our time to take a look.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从一点编程语言古生物学开始。接下来，我们将考虑第一批编程语言。即使你仍然是编程的新手，你也已经对编程有了基本的理解，并知道如何进行编码。但这并非一直如此——编程的概念是从某个地方产生出来的。值得我们花时间去了解这一过程。
- en: The remainder of the chapter is a series of vignettes, in roughly chronological
    order, that introduce us to a collection of programming languages we should keep
    in the back of our minds as we move through the book. We’ll spend the next few
    chapters exploring select languages in still more detail before diving into esolangs
    proper.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分是按大致时间顺序排列的一系列小故事，介绍了一些编程语言，随着我们推进本书，它们应该始终存在于我们的脑海中。在接下来的几章中，我们将更详细地探讨一些精选语言，然后再深入研究真正的伪语言。
- en: There are thousands of programming languages (see *[http://www.info.univ-angers.fr/~gh/hilapr/langlist/langlist.htm](http://www.info.univ-angers.fr/~gh/hilapr/langlist/langlist.htm)*),
    so why this particular set? I selected languages that were important to the development
    of future languages and, as such, often represent a new conception of programming,
    or languages that were novel in some way that will help us when we get to esolangs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言有成千上万种（见 *[http://www.info.univ-angers.fr/~gh/hilapr/langlist/langlist.htm](http://www.info.univ-angers.fr/~gh/hilapr/langlist/langlist.htm)*），那么为什么是这组语言呢？我选择了那些对未来编程语言的发展至关重要的语言，因此，这些语言通常代表了编程的新观念，或者在某些方面具有新颖性，能帮助我们理解伪语言。
- en: 'All of the languages presented in this chapter were invented before the year
    2000\. Of course, that’s not to say programming language development stopped with
    Y2K. There are a plethora of new languages: Rust, Scala, Julia, Go, Kotlin, and
    Swift are all examples of languages developed after 2000\. There will be no end
    to developing new programming languages. However, the current trend in language
    design leans toward multi-paradigm languages that take the best of what came before
    and mix it in some way with the hope of creating synergy. In other words, something
    greater than the sum of its parts. This trend validates our review of older languages
    with novel ideas as that is precisely what new languages are doing.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的所有编程语言都在2000年之前发明。当然，这并不意味着编程语言的发展在千年虫事件（Y2K）后就停止了。事实上，涌现出了大量新的编程语言：Rust、Scala、Julia、Go、Kotlin
    和 Swift 等都是2000年后开发的语言。开发新编程语言的浪潮不会停止。然而，目前语言设计的趋势是向多范式语言倾斜，这些语言融合了前人最佳的部分，并以某种方式进行混合，希望能创造出协同效应。换句话说，产生比各部分之和更强大的效果。这一趋势验证了我们对早期语言进行回顾的意义，因为新语言正是通过这种方式进行创新的。
- en: Let’s begin.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: '**Programming Language Paleontology**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程语言古生物学**'
- en: Paleontology, literally the study of ancient being, is concerned with the history
    of life on Earth as well as the equally important diversity of life, that is,
    the number and kind of species. An important event studied by paleontologists
    is the *Cambrian explosion*, which was the sudden appearance of a huge assortment
    of animals in the fossil record.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 古生物学，字面意思是对古代生命的研究，关注地球上生命的历史以及同样重要的生命多样性，即物种的数量和种类。古生物学家研究的一个重要事件是*寒武纪大爆发*，即在化石记录中突然出现大量各种动物。
- en: The best-known fossil site related to the Cambrian explosion, from a time just
    after it, is the Burgess Shale of western Canada. The Burgess Shale is a priceless
    fossil site, half a billion years old, where the soft body parts of a myriad of
    animals, most unlike any living today, are preserved.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与寒武纪大爆发相关的最著名化石遗址是位于加拿大西部的伯吉斯页岩（Burgess Shale）。伯吉斯页岩是一个无价的化石遗址，已有五亿年历史，保存了大量与现存生物完全不同的软体部分。
- en: Burgess Shale fauna, entirely marine, has familiar representatives, like trilobites,
    which are favorites of fossil collectors. But the real stars of the Burgess Shale
    are weird animals like *anomalocaris*, a large predator so unusual that its various
    body parts were originally classified as separate animals, or the five-eyed Opabinia,
    with its single, trunk-like arm and claw. Then there is Hallucigenia, a spiny,
    worm-like creature initially described upside down as if it were walking the sea
    floor on its spines.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 伯吉斯页岩的生物群完全是海洋生物，拥有一些我们熟悉的代表性生物，如三叶虫，它是化石收藏者的最爱。但伯吉斯页岩的真正明星是一些奇异的动物，比如*奇异虾*（anomalocaris），一种大型捕食者，其各个身体部位最初被误认为是不同的动物，或者是五眼的奥帕比尼亚（Opabinia），它有一只类似象鼻的臂和一只爪子。还有幻影虫（Hallucigenia），一种带刺的、像虫子的生物，最初被描述时是倒过来的，好像它是在用背上的刺在海底行走。
- en: Later life, which for us means more mainstream life, is definitely more familiar,
    if less diverse. Fish dominated the later Paleozoic seas and eventually wandered
    out of the water onto land to become the first tetrapods, a body plan that land-dwelling
    vertebrates from crocodiles to pterosaurs, dinosaurs, elephants, and humans have
    maintained virtually unchanged ever since.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 后来的生命，对我们来说是更为主流的生命，尽管多样性较低，但绝对更为熟悉。鱼类主宰了晚期古生代的海洋，最终从水中走出，登上陆地，成为第一批四足动物，这一身体结构一直延续至今，陆生脊椎动物如鳄鱼、翼龙、恐龙、大象和人类几乎没有发生变化。
- en: '![Image](Images/01fig01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/01fig01.jpg)'
- en: '*Figure 1-1: A geologic time scale of programming languages*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-1：编程语言的地质时间尺度*'
- en: '[Figure 1-1](ch01.xhtml#ch01fig1) shows a time scale of geologic history with
    programming languages marked at various places.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-1](ch01.xhtml#ch01fig1)展示了一个地质历史的时间尺度，其中标出了各个时期的编程语言。'
- en: The silhouettes in [Figure 1-1](ch01.xhtml#ch01fig1) indicate the type of life
    dominant at the time. What is important for us is not so much the time scale,
    but the diversity of life. Modern life, signified by the mammals during the Cenozoic
    era, such as Smilodon, the famed sabre-toothed cat, and the mighty mammoth, are
    related to newer languages like Python, Java, and C#. These languages are familiar
    and not at all surprising to us.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-1](ch01.xhtml#ch01fig1)中的剪影显示了当时主导的生命类型。对我们来说，重要的不是时间尺度，而是生命的多样性。现代生命，由新生代时期的哺乳动物所代表，如著名的剑齿虎（Smilodon）和强大的猛犸象，与像Python、Java和C#这样的新兴编程语言有关。这些语言对我们来说非常熟悉，完全不令人惊讶。'
- en: For the Mesozoic we have dinosaurs, including Alectrosaurus, a hunter who terrorized
    the late Cretaceous. Also present are a living tank, Edmontonia, and Achelousaurus,
    the prehistoric equivalent of a buffalo, but with fearsome horns. Although different
    in some ways, and perhaps a bit old, dinosaurs are familiar, so I’ve placed C
    and C++ in their company. Lest you think I’m slighting C and C++, do remember
    that the dinosaurs ruled the land for more than 100 million years and continue
    to rule the air even now, for birds are dinosaurs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于中生代，我们有恐龙，包括猎食者阿雷克特龙（Alectrosaurus），它在白垩纪晚期肆虐。还有活着的坦克——埃德蒙托尼亚（Edmontonia）和类似水牛的史前恐龙——阿赫洛索龙（Achelousaurus），但它们有着可怕的角。尽管在某些方面有所不同，且可能显得有些古老，恐龙仍然很熟悉，因此我将C和C++与它们放在一起。别以为我在贬低C和C++，请记住，恐龙统治了地球超过1亿年，直到今天，它们依然统治着天空，因为鸟类就是恐龙。
- en: The later Paleozoic era, the Age of Fishes, seems a good place for unusual,
    but still not entirely alien, programming languages like Forth, SNOBOL, and CLIPS,
    all three of which we’ll explore in this book. The fish silhouettes from the time
    are Eusthenopteron, the lobe-finned Sarcopterygii, and the jawless and armored
    Ostracoderm.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 后期古生代，鱼类的时代，似乎是一些不寻常但仍不完全陌生的编程语言（如 Forth、SNOBOL 和 CLIPS）的合适背景，我们将在本书中探索这三种语言。那个时代的鱼类轮廓包括鱼鳍类（Eusthenopteron）、有鳍肢的硬骨鱼（Sarcopterygii）以及无颚的装甲鱼（Ostracoderm）。
- en: The Burgess Shale, the time of Anomalocaris, Opabinia, and Hallucigenia, is
    also marked. The diversity and unusual body plans of the Burgess Shale seem a
    perfect analogy for esolangs—experimental, perhaps evolutionary dead ends, but
    important all the same because they pushed the boundaries of what could be, before
    natural selection’s heavy hand decided who continued and who didn’t.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔吉斯页岩，那个有异常大眼怪鱼（Anomalocaris）、奥帕比尼亚（Opabinia）和幻觉螳螂（Hallucigenia）的时代，也是标志性的。布尔吉斯页岩的多样性和独特的身体结构似乎是
    esolang 的完美类比——实验性的，或许是进化的死胡同，但同样重要，因为它们推动了可能性边界，在自然选择的重压下，决定了哪些能延续，哪些不能。
- en: To me, esolangs are like the weirdly wonderful animals of the Burgess Shale.
    Like those animals, esolangs are experiments, forays into what could be, existing
    and thriving even if not destined to endure. The animals of the Burgess Shale
    made paleontologists rethink and reevaluate how they approached ancient life.
    Similarly, esolangs, if we let them, make us rethink and reevaluate how we approach
    programming.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，esolang（另类编程语言）就像布尔吉斯页岩中那些奇异而美妙的动物。像那些动物一样，esolang 是实验，是对可能性的尝试，它们的存在和繁荣虽然可能注定无法持续，但仍然在某种程度上意义重大。布尔吉斯页岩中的动物让古生物学家重新思考并评估他们如何看待古代生命。同样地，如果我们愿意，esolang
    也能让我们重新思考并评估我们如何看待编程。
- en: Esolangs are weird, often very strange and alien, but that’s the point. Like
    the beautifully bizarre animals of the Burgess Shale, esolangs explore niches
    in novel, unusual ways that might not be practical, but are definitely interesting
    and, most of all, fun.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Esolang 很奇怪，往往非常陌生且外星般，但这正是其意义所在。就像布尔吉斯页岩中那些美丽而奇特的动物一样，esolang 探索了以新颖、不寻常的方式填补的空白，这些方式或许不实用，但肯定有趣，最重要的是，充满乐趣。
- en: 'There you have it: geology and computer science living together, sans mass
    hysteria. Hopefully, [Figure 1-1](ch01.xhtml#ch01fig1) provides some food for
    thought, or at least an alternative viewpoint. We’ll refer to [Figure 1-1](ch01.xhtml#ch01fig1)
    from time to time throughout the book, but for now, let’s move on and explore
    the first programming languages.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，这里有地质学和计算机科学的结合，没有大规模的恐慌。希望[图 1-1](ch01.xhtml#ch01fig1)能提供一些思考的材料，或者至少是一种替代的观点。我们会不时地引用[图
    1-1](ch01.xhtml#ch01fig1)，但现在，让我们继续前进，探索第一个编程语言。
- en: '**The First Programming Languages**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**第一个编程语言**'
- en: 'What was the first programming language? That’s a difficult question to answer
    without defining *programming language*. We’ll define what we mean by a programming
    language in [Chapter 2](ch02.xhtml#ch02). For now, we’ll use an intuitive definition:
    a programming language is a means by which an algorithm can be encoded to control
    a machine, specifically a computer.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个编程语言是什么？没有定义*编程语言*，这是一个很难回答的问题。我们将在[第二章](ch02.xhtml#ch02)中定义我们对编程语言的理解。目前，我们用一个直观的定义：编程语言是将算法编码以控制机器，特别是计算机的工具。
- en: '***Programming Before Computers***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算机之前的编程***'
- en: The idea of a programmable machine predates the idea of a programmable computer.
    The *Jacquard loom*, a loom that used punch cards for control, was introduced
    in 1804\. The pattern of dots on the card controlled the movement of threads in
    the loom to specify the pattern woven. There is a language there, something that
    can be varied to produce a different output. Change the pattern of holes on the
    card and a new pattern emerges from the machine. The rolls for a player piano
    work in much the same way.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可编程机器的概念早于可编程计算机的概念。*贾卡尔织机*（Jacquard loom），一种使用打孔卡片控制的织布机，于1804年问世。卡片上的点阵控制着织机中的线的运动，从而指定了编织的图案。这里有一种语言，可以变化以产生不同的输出。改变卡片上的孔洞图案，机器便会出现新的图案。自鸣琴的卷轴工作方式也差不多。
- en: In fact, the first “modern” computer design, Charles Babbage’s *Analytical Engine*,
    was influenced by the Jacquard loom. Although the Analytical Engine was never
    built, the engine had all the key components found in a modern computer and was
    programmable using punch cards. In 1843, while translating a set of lecture notes
    on the Analytical Engine from French to English, Ada Lovelace, Babbage’s long-time
    friend and daughter of the famous poet Lord Byron, wrote about the capabilities
    and potential uses of the Analytical Engine. She envisioned using the Analytical
    Engine for computation, but went further, imagining that the engine could be used
    for composing music and would release scientists from tedious computation, thereby
    freeing them for more advanced thinking. Ada was correct on both counts.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，第一个“现代”计算机设计，查尔斯·巴贝奇的*分析引擎*，受到了雅克布·织布机的影响。尽管分析引擎从未建成，但该引擎具备了现代计算机的所有关键组件，并且可以使用打孔卡进行编程。1843年，在将分析引擎的一套讲座笔记从法语翻译为英语时，Ada·洛芙莱斯，巴贝奇的长期朋友和著名诗人拜伦勋爵的女儿，写道关于分析引擎的能力和潜在用途。她设想使用分析引擎进行计算，但更进一步，想象引擎可以用于作曲，并释放科学家们从繁琐的计算中解放出来，从而使他们能够进行更高级的思考。在这两个方面，Ada都是正确的。
- en: The translation, and more importantly, Ada’s insightful and brilliant notes,
    are in “Sketch of the Analytical Engine” in volume III of *Taylor’s Scientific
    Memoirs* (1843, pp. 666–731). An online search will quickly locate a PDF version.
    I highly recommend reading through Ada’s notes, at least Note A. However, Ada’s
    Note G is most important to us. There, she applied an algorithm to the engine
    to compute Bernoulli numbers to demonstrate how the engine would compute the result.
    Bernoulli numbers are used in different areas of mathematics, but how they are
    used is unimportant to us. What matters is that Ada took an algorithm and structured
    it for the Analytical Engine—that is, she wrote a program for a general-purpose
    computer. It then seems fair to claim that Ada wrote the world’s first computer
    program in 1843\. The programming language she used was the *diagram of development*
    notation she introduced in Note D.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译，更重要的是，Ada深刻而聪明的笔记，包含在《泰勒科学回忆录》第三卷的《分析引擎素描》中（1843年，第666-731页）。在线搜索可以快速找到PDF版本。我强烈推荐阅读Ada的笔记，至少阅读A注。然而，对我们来说最重要的是Ada的G注。在那里，她应用算法到引擎上计算伯努利数，以展示引擎如何计算结果。伯努利数在数学的不同领域中使用，但它们的使用方式对我们不重要。重要的是Ada拿出一个算法，并为分析引擎编写了一个通用计算机的程序。因此，可以说Ada在1843年写了世界上第一个计算机程序。她使用的编程语言是她在D注中介绍的*发展图*符号。
- en: '[Figure 1-2](ch01.xhtml#ch01fig2) presents Ada’s program. It details the sequence
    of steps, the variables involved, and how they change during the computation.
    Various people have translated her program into modern programming languages.
    Of particular interest is that she seems to have made an error, the world’s first
    computer bug.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-2](ch01.xhtml#ch01fig2)展示了Ada的程序。详细描述了计算过程中涉及的步骤、变量以及它们在计算过程中的变化。许多人已经将她的程序翻译成现代编程语言。特别值得注意的是，她似乎犯了一个错误，这是世界上第一个计算机错误。'
- en: '![Image](Images/01fig02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig02.jpg)'
- en: '*Figure 1-2: Ada Lovelace’s Analytical Engine program to calculate the eighth
    Bernoulli number (1843)*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-2：Ada Lovelace的分析引擎程序，用于计算第八个伯努利数（1843年）*'
- en: 'Step 4 of [Figure 1-2](ch01.xhtml#ch01fig2) calculates `v5 / v4`; however,
    the correct calculation is `v4 / v5`. With that modification, translations into
    modern languages produce the correct result: *–* 1/30\. Translations into C and
    Python are available on the internet. To learn more about Ada’s life, I recommend
    *Ada’s Algorithm*, by James Essinger (Melville House, 2015). She was ahead of
    her time, even though her own life was so short.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-2的第4步计算`v5 / v4`；然而，正确的计算是`v4 / v5`。通过这种修改，可以将其翻译成现代语言，得到正确的结果：*–* 1/30。在互联网上可以找到C语言和Python的翻译版本。要了解更多关于Ada生活的信息，我推荐詹姆斯·埃辛格（James
    Essinger）的《Ada's Algorithm》（Melville House，2015）。尽管她的生命如此短暂，她却走在了时代的前列。
- en: '***The First Modern Programming Languages***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***第一批现代编程语言***'
- en: 'The first programming language in the modern sense was *Plankalk**ü**l*, developed
    by Konrad Zuse around 1943, 100 years after Ada’s first program. Plankalkül is
    German for “plan calculus” or “plan calculation.” Zuse used Plankalkül as a high-level
    programming language, though it was not implemented for any of his “Z” series
    computers. The language supported structured programming with `for` and `while`
    loops, floating-point arithmetic, arrays, and other features found in modern programming
    languages. Interestingly, the syntax of Plankalkül is 2D, with symbols written
    above other symbols. Zuse’s word for a program was “rechenplan,” which means “arithmetic”
    or “computation” plan. A good summary of Plankalkül can be found in “The Plankalkül
    of Konrad Zuse: A Forerunner of Today’s Programming Languages,” by Bauer and Wössner,
    Communications of the ACM 15, no. 7 (1972).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个现代意义上的编程语言是 *Plankalk**ü**l*，由 Konrad Zuse 在大约 1943 年开发，比 Ada 的首个程序晚了100年。Plankalkül
    是德文，意为“计划演算”或“计划计算”。Zuse 将 Plankalkül 作为高级编程语言使用，尽管它没有被实现在他的“Z”系列计算机上。该语言支持结构化编程，包括
    `for` 和 `while` 循环，浮点运算，数组以及其他现代编程语言中的特性。有趣的是，Plankalkül 的语法是二维的，符号写在其他符号的上方。Zuse
    对程序的称呼是“rechenplan”，意为“算术”或“计算”计划。关于 Plankalkül 的良好总结可参见 Bauer 和 Wössner 的文章《Konrad
    Zuse 的 Plankalkül：今天编程语言的前身》，发表于《ACM通讯》1972年第15卷第7期。
- en: Lovelace and Zuse, respectively, deserve credit for the first program and the
    first programming language. But neither program nor language worked on actual,
    physical computers. The first programming language for a working computer is likely
    up for much debate. Early computers like ENIAC were programmed by rewiring. The
    Manchester Baby, circa 1948, was the first stored-program computer, so in that
    sense, it had a programming language—the instructions stored in its memory. We
    call the low-level instructions understood by a processor *machine language* or
    *machine code*. Machine code is a programming language, as are the assemblers
    that generate the machine code from *assembly language*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 分别应该给予 Lovelace 和 Zuse 信用，作为第一个程序和第一个编程语言的发明者。但是，他们的程序和语言并未在实际的物理计算机上运行。第一个应用于工作计算机的编程语言可能会引发很多争议。早期计算机如
    ENIAC 是通过重连线编程的。约于 1948 年的曼彻斯特 Baby 是第一个存储程序计算机，因此从这个意义上说，它拥有一种编程语言——存储在内存中的指令。我们称处理器理解的低级指令为
    *机器语言* 或 *机器码*。机器码是一种编程语言，就像汇编语言生成机器码一样。
- en: Machine code and assembly aside, the first programming language used on an actual
    computer is probably *Short Code*, developed by John Mauchly in 1949 and implemented
    by William Schmitt for the UNIVAC I in 1950\. Short Code supported arithmetic,
    including branching and a set of library functions like square root and absolute
    value. Expressions were transliterated from algebra to code and then manually
    packed into six 2-byte groups to fit the 12-byte words of the UNIVAC. Short Code
    was interpreted and parsed the meaning of an instruction from a tokenized representation
    of the program. In other words, Short Code worked much like the BASIC that interpreters
    built into early home computers of the 1980s. Running on a computer from the 1950s,
    interpreted Short Code must have been exceedingly slow to execute.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了机器码和汇编语言外，第一个应用于实际计算机的编程语言可能是由 John Mauchly 在 1949 年开发的 *Short Code*，并由 William
    Schmitt 于 1950 年为 UNIVAC I 实现。Short Code 支持算术运算，包括分支和一组库函数，如平方根和绝对值。表达式从代数转写成代码，然后手动打包成六个2字节的组，以适应UNIVAC的12字节字长。Short
    Code 是解释型的，从程序的标记表示中解析出指令的含义。换句话说，Short Code 的运行方式与上世纪80年代早期家用计算机内置的BASIC非常相似。在20世纪50年代的计算机上运行，解释型的Short
    Code执行速度肯定极其缓慢。
- en: The first proper compiler, at least as credited by Knuth and Pardo in “The Early
    Development of Programming Languages” in *A History of Computing in the Twentieth
    Century* (Academic Press, 1980) is *AUTOCODE* by Alick E. Glennie at the University
    of Manchester, circa 1950–52\. Unlike Short Code, AUTOCODE was compiled, meaning
    it was translated into equivalent machine code instructions. Visually, AUTOCODE
    looks a bit like machine code with text thrown in here and there.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个真正的编译器，至少根据 Knuth 和 Pardo 在《二十世纪计算的早期发展》（Academic Press，1980）中的描述，是 Alick
    E. Glennie 在曼彻斯特大学开发的 *AUTOCODE*，大约在 1950–52 年间。与 Short Code 不同，AUTOCODE 是编译型的，意味着它被翻译成了等效的机器码指令。在视觉上，AUTOCODE
    看起来有点像是机器码，只是偶尔会插入文本。
- en: 'While AUTOCODE and its successors were under development in the UK, in the
    US, Grace Hopper, Margaret H. Harper, and Richard K. Ridgeway were working on
    their compilers for the UNIVAC: A-0 to A-2\. In 1954, John Backus defined “The
    IBM Mathematical FORmula TRANslating system, FORTRAN,” and by 1957, the first
    *FORTRAN* compiler was released.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在英国AUTOCODE及其后继者开发的同时，在美国，格雷斯·霍普（Grace Hopper）、玛格丽特·H·哈珀（Margaret H. Harper）和理查德·K·里奇韦（Richard
    K. Ridgeway）正在为UNIVAC工作编译器：A-0到A-2。1954年，约翰·巴库斯（John Backus）定义了“IBM数学公式翻译系统，FORTRAN”，并且到1957年，首个*FORTRAN*编译器发布。
- en: The development of FORTRAN was a watershed moment. Programming language design
    kicked into high gear in the late 1950s. Most notable of the languages defined
    in the later 1950s, besides FORTRAN, is John McCarthy’s *Lisp* in 1958\. It is
    truly impressive that both FORTRAN and Lisp are still in widespread use today.
    High-performance computing (HPC) makes frequent use of FORTRAN. Later in the book,
    we’ll use a version of Lisp to implement a *FRACTRAN* interpreter. We’ll focus
    on FRACTRAN, perhaps the most unusual of esolangs, in [Chapter 8](ch08.xhtml#ch08).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: FORTRAN的开发是一个分水岭时刻。到了1950年代末，编程语言设计进入了高速发展期。除了FORTRAN之外，1950年代后期定义的最著名的语言之一是约翰·麦卡锡（John
    McCarthy）于1958年推出的*Lisp*。令人印象深刻的是，FORTRAN和Lisp至今仍在广泛使用。高性能计算（HPC）常常使用FORTRAN。书中的后续章节，我们将使用一个版本的Lisp来实现一个*FRACTRAN*解释器。我们将专注于FRACTRAN，它可能是最不寻常的异构语言之一，详细内容见[第8章](ch08.xhtml#ch08)。
- en: 'The last pre-1960 programming language of note is *COBOL*. It was designed
    by a committee in 1959, with the first version appearing a year later. Rightly
    or wrongly, COBOL is still in use today. Unlike FORTRAN, a language for research
    scientists, and Lisp, a language for computer scientists, COBOL was a language
    intended for business use. COBOL programs are highly structured, rigid, and verbose.
    For example, consider this snippet from the COBOL 60 report defining the language:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种值得注意的1960年前编程语言是*COBOL*。它由一个委员会于1959年设计，第一版在一年后发布。无论对与错，COBOL至今仍在使用。与为研究科学家设计的FORTRAN和为计算机科学家设计的Lisp不同，COBOL是一种为商业用途设计的语言。COBOL程序结构高度规范，严格且冗长。例如，以下是COBOL
    60报告中定义语言的一个片段：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The early years of programming language development resulted in the basic form
    and concept of a general-purpose programming language. The three critical languages
    to come out of this era are FORTRAN, Lisp, and COBOL. All three are still in use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言发展的初期，形成了通用编程语言的基本形式和概念。从这个时期产生的三种关键语言是FORTRAN、Lisp和COBOL，这三种语言至今仍在使用。
- en: 'FORTRAN was a natural choice for what is still a primary use of computers:
    number crunching. COBOL is an early example recognizing that commercial use of
    computers was something apart from their scientific use. Lisp was far in advance
    of its time, but slow, resource-limited computers made it difficult for Lisp to
    live up to its potential.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: FORTRAN是处理计算机当前主要用途——数字计算的自然选择。COBOL是一个早期的例子，认识到计算机的商业用途不同于科学用途。Lisp远远领先于其时代，但慢速、资源受限的计算机使得Lisp未能实现其潜力。
- en: Let’s now examine 10 different programming languages. These languages represent
    major transitions in the evolution of programming languages because of what they
    introduced or how they grew in popularity or opened the arcane art of coding to
    a larger population.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看10种不同的编程语言。这些语言代表了编程语言发展的重大转折点，因为它们引入了新的概念，或者因其流行度的增长，或使编程这一神秘的艺术能够为更多的人所掌握。
- en: '**ALGOL**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**ALGOL**'
- en: The first language we’ll consider, *ALGOL*, gave rise to entire generations
    of programming languages and still influences programming languages today. ALGOL,
    like COBOL, was designed by committee.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考虑的第一种语言，*ALGOL*，催生了整整一代编程语言，并且至今仍然影响着编程语言的发展。ALGOL像COBOL一样，是由一个委员会设计的。
- en: 'ALGOL is a compiled, structured, imperative programming language, meaning it
    looks familiar to modern programmers. Subsequent programming languages inspired
    by ALGOL include Simula, PL/I, and Pascal, all mentioned later. ALGOL captured
    the essentials of what *imperative programming* is: a structured way to give step-by-step
    instructions to the computer.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ALGOL是一种编译型、结构化、命令式编程语言，这意味着它对现代程序员来说看起来很熟悉。受到ALGOL启发的后续编程语言包括Simula、PL/I和Pascal，稍后会提到。ALGOL捕捉了*命令式编程*的本质：一种结构化的方式，按步骤向计算机发出指令。
- en: '[Listing 1-1](ch01.xhtml#ch01list1) is a simple program to compare two integers.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 1-1](ch01.xhtml#ch01list1)是一个简单的程序，用来比较两个整数。'
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 1-1: Comparing numbers in ALGOL 68*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-1：在ALGOL 68中比较数字*'
- en: Even without knowing the language, the form should be familiar to you if you
    know any modern structured programming language. Notice that the program begins
    with `(` and ends with `)` instead of `BEGIN` and `END`. The latter works as well
    and is what users of Pascal or Modula-2 expect to see, but ALGOL’s free-form approach
    allows parentheses to denote code blocks.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不懂这门语言，如果你了解任何现代结构化编程语言，应该对这种形式很熟悉。注意，程序以`(`开始，以`)`结束，而不是`BEGIN`和`END`。后者同样有效，并且是Pascal或Modula-2用户所期望的，但ALGOL的自由格式方法允许使用括号来表示代码块。
- en: If you’re interested in trying ALGOL, you should look to Marcel van der Veer’s
    “Algol 68 Genie” implementation (see *[https://jmvdveer.home.xs4all.nl/en.algol-68-genie.html](https://jmvdveer.home.xs4all.nl/en.algol-68-genie.html)*),
    which runs on Linux and Windows. You’ll find extensive documentation on his site,
    all you need to learn the language. The Ubuntu package is `algol68g`. [Listing
    1-1](ch01.xhtml#ch01list1) is in *bigger.a68*. To run it, enter
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣尝试ALGOL，可以参考Marcel van der Veer的“Algol 68 Genie”实现（请见* [https://jmvdveer.home.xs4all.nl/en.algol-68-genie.html](https://jmvdveer.home.xs4all.nl/en.algol-68-genie.html)*），该实现支持Linux和Windows系统。你可以在他的网站上找到详尽的文档，那里有学习这门语言所需的一切。Ubuntu包名是`algol68g`。[列表1-1](ch01.xhtml#ch01list1)位于*bigger.a68*文件中。要运行它，只需输入
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Figure 1-3](ch01.xhtml#ch01fig3) shows ALGOL’s descendants.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-3](ch01.xhtml#ch01fig3)展示了ALGOL的后代。'
- en: '![Image](Images/01fig03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/01fig03.jpg)'
- en: '*Figure 1-3: The ALGOL family tree*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-3：ALGOL家族树*'
- en: Naturally, programming languages can have multiple influences, but this tree
    seems quite reasonable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，编程语言可以有多种影响因素，但这棵树似乎非常合理。
- en: '**APL**'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**APL**'
- en: In 1962, Kenneth E. Iverson published *A Programming Language*, detailing a
    new programming language designed with arrays in mind that, in a show of boundless
    creativity, came to be called *APL*. One of the defining characteristics of APL
    is its nonstandard character set. That fact sometimes turns off would-be learners.
    For us, Iverson’s use of alternative characters is an excellent reason to include
    APL in our list of programming languages. However, the real reason to include
    APL is that it was the first *array-processing language*. Array-processing is
    a paradigm we’ll encounter in a later chapter, but, in a nutshell, it involves
    wholesale operations on arrays in a compact way. For a modern comparison, consider
    Matlab or Python with NumPy.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 1962年，Kenneth E. Iverson 发布了*《编程语言》*，详细介绍了一种以数组为核心设计的新编程语言，凭借着无限的创意，这种语言被命名为*APL*。APL的一个显著特点是其非标准字符集，这一点有时会让一些潜在的学习者却步。对我们来说，Iverson使用替代字符的做法，是将APL列入我们编程语言名单的一个绝佳理由。然而，真正将APL纳入的原因是，它是第一种*数组处理语言*。数组处理是一种我们将在后续章节遇到的范式，但简而言之，它以紧凑的方式对数组进行整体操作。作为现代的比较，可以考虑Matlab或Python与NumPy。
- en: APL sessions are typically interactive. [Listing 1-2](ch01.xhtml#ch01list2)
    shows GNU APL in action. The user’s input is indented and the system’s responses
    are not.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: APL会话通常是交互式的。[列表1-2](ch01.xhtml#ch01list2)展示了GNU APL的实际操作。用户的输入会缩进，而系统的响应则没有。
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 1-2: APL in action*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表1-2：APL示例*'
- en: The first line of [Listing 1-2](ch01.xhtml#ch01list2) assigns (←) whatever *ι*100
    returns to the variable, *x*. APL’s many operators each have two modes. If used
    in a unary fashion (that is, on a single operand), then the use is *monadic*.
    If used in a binary fashion (on two operands), then the use is *dyadic*. In this
    case, the monadic use of *ι* returns the vector 1 2 3 4 5 6 7 8 9 10, which is
    exactly how it would be entered manually. Thus, the first line is equivalent to
    `x = np.arange(1,11)` in Python using NumPy. The second line in [Listing 1-2](ch01.xhtml#ch01list2)
    multiplies each element of *x* by 10.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表1-2](ch01.xhtml#ch01list2)的第一行将*ι*100返回的结果赋值给变量*x*（←）。APL的许多操作符都有两种模式。如果是单目使用（即作用于单个操作数），则为*单目*；如果是双目使用（即作用于两个操作数），则为*双目*。在这种情况下，*ι*的单目使用返回向量1
    2 3 4 5 6 7 8 9 10，这正是手动输入时的表现。因此，第一行相当于Python中使用NumPy的`x = np.arange(1,11)`。[列表1-2](ch01.xhtml#ch01list2)中的第二行将*x*的每个元素乘以10。'
- en: 'The dyadic form of *ι* searches for its second argument in the first. For example,
    consider the following APL code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*ι*的双目形式会在第一个参数中搜索第二个参数。例如，考虑以下APL代码：'
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here we use the dyadic form of `?` to set *x* to a 10-element vector of random
    integers from 1 to 10, without repeats. Next, the dyadic form of *ι* searches
    *x* for the number 10 and returns its index, 5\. APL indexes from 1, not 0\. If
    the dyadic form of `?` returns vectors of random integers between 1 and some upper
    limit, what might the monadic form of `?` do? If you guessed return a random integer,
    you are correct: `?`*n* returns a random integer in [1, *n*].'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`?`的双目形式将*x*设置为一个由1到10之间的随机整数（不重复）组成的10元素向量。接下来，*ι*的双目形式在*x*中搜索数字10并返回其索引值5。APL的索引从1开始，而不是从0开始。如果`?`的双目形式返回1到某个上限之间的随机整数，那么`?`的单目形式会做什么呢？如果你猜测返回一个随机整数，那么你是对的：`?`*n*返回一个在[1,
    *n*]之间的随机整数。
- en: The second assignment in [Figure 1-2](ch01.xhtml#ch01fig2) sets *y* to a 4 ×
    4 matrix of random integers in [1, 100]. We use `?` to ask for 16 numbers, and
    then use *ρ* (rho) to reshape the 16-element vector into a 4 × 4 matrix before
    assigning it to *y*. To index a vector or array, use ![Image](Images/f0012-01.jpg)
    (vertical rectangle) as in 3 ![Image](Images/f0012-01.jpg) *x* to access the third
    element of vector *x* or 2 3 ![Image](Images/f0012-01.jpg) *y* to access *y*[23]
    of matrix *y*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-2](ch01.xhtml#ch01fig2)中的第二个赋值将*y*设置为一个4 × 4的随机整数矩阵，整数范围在[1, 100]之间。我们使用`?`请求16个数字，然后使用*ρ*（rho）将16元素的向量重塑为4
    × 4的矩阵，并将其赋值给*y*。要索引向量或数组，使用![Image](Images/f0012-01.jpg)（竖直矩形）进行索引，例如3 ![Image](Images/f0012-01.jpg)
    *x*来访问向量*x*的第三个元素，或者2 3 ![Image](Images/f0012-01.jpg) *y*来访问矩阵*y*的*y*[23]。'
- en: One quirk of APL is that expressions are evaluated from right to left, with
    no operator precedence rules. As a consequence, parentheses must be used to enforce
    desired behavior. For example, according to APL, the first of the two expressions
    below is completely correct.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: APL的一个特点是表达式从右到左进行评估，没有运算符优先级规则。因此，必须使用括号来强制执行期望的行为。例如，根据APL，下面两个表达式中的第一个是完全正确的。
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Virtually every other programming language will tell you that both expressions
    equal 20 because multiplication is performed before addition. However, APL parses
    the first expression as “add 2 and 6 to get 8, then multiply by 3 to get 24.”
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有其他编程语言都会告诉你，这两个表达式的结果都是20，因为乘法会在加法之前执行。然而，APL将第一个表达式解析为“先加上2和6得到8，再乘以3得到24。”
- en: APL is compact and powerful but also cryptic, and thus comes with a high learning
    curve. This, to say nothing of the early difficulties in using its alternative
    character set, has limited its use. Perhaps because of these difficulties, Iverson
    and Roger Hui developed *J*, an ASCII version of APL in the early 1990s (*[https://www.jsoftware.com/](https://www.jsoftware.com/)*).
    J retains the power of APL and expands on its capabilities to be more useful on
    modern computer systems. However, like APL, J has a high learning curve, creating
    the potential for high reward in learning a new way to think about what it means
    to code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: APL紧凑且功能强大，但也非常晦涩，因此具有较高的学习曲线。更不用说早期使用其替代字符集的困难，这限制了它的使用。也许正因为这些困难，Iverson和Roger
    Hui在1990年代初开发了*J*，一种基于ASCII的APL版本（*[https://www.jsoftware.com/](https://www.jsoftware.com/)*）。J保留了APL的强大功能，并扩展了其能力，使其在现代计算机系统上更具实用性。然而，像APL一样，J也有较高的学习曲线，学习它能够为编程带来新的思维方式，从而产生高回报的潜力。
- en: '**BASIC**'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**BASIC**'
- en: Almost everyone who used a microcomputer in the 1980s is at least somewhat familiar
    with *BASIC*. The “Beginner’s All-purpose Symbolic Instruction Code” was developed
    at Dartmouth College in 1964 by John G. Kemeny and Thomas E. Kurtz. BASIC was
    originally an unstructured programming language, meaning it used gotos to control
    program flow, and was intended for students and non-professionals. In the late
    1970s, when the microcomputer revolution took off, most computers included BASIC,
    usually in ROM. The first programming language many current software engineers
    learned was unstructured BASIC on a personal computer from the 1980s. As a result,
    BASIC’s impact on software development is significant and continues to this day.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有在1980年代使用过微型计算机的人至少对*BASIC*有所了解。BASIC（“初学者通用符号指令代码”）由约翰·G·凯门尼（John G. Kemeny）和托马斯·E·库尔茨（Thomas
    E. Kurtz）于1964年在达特茅斯学院开发。BASIC最初是一种非结构化的编程语言，意味着它使用goto语句来控制程序流程，旨在面向学生和非专业人士。在1970年代末，当微型计算机革命兴起时，大多数计算机都包括了BASIC，通常是以ROM的形式。许多当前的软件工程师学习的第一种编程语言就是1980年代个人计算机上的非结构化BASIC。因此，BASIC对软件开发的影响深远，至今仍在继续。
- en: BASIC was interpreted and often stored in memory as tokens, much like Short
    Code, described above. BASIC lives on as *Visual Basic*, which uses structured
    programming and is fully object-oriented. Visual Basic is still one of the most
    widely used programming languages.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: BASIC 是解释执行的，且通常将其存储在内存中作为令牌，类似于上文描述的 Short Code。BASIC 作为 *Visual Basic* 存续至今，后者采用结构化编程并且完全面向对象。Visual
    Basic 仍然是最广泛使用的编程语言之一。
- en: '[Listing 1-3](ch01.xhtml#ch01list3) shows a simple BASIC program for the Apple
    II to simulate coin flips.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 1-3](ch01.xhtml#ch01list3) 显示了一个简单的 Apple II BASIC 程序，用于模拟抛硬币。'
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 1-3: An Applesoft BASIC program to simulate coin flips*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-3：一个模拟抛硬币的 Applesoft BASIC 程序*'
- en: BASIC used line numbers, required for every line, to provide targets for `GOTO`
    statements. Different dialects of BASIC provided various commands, but all had
    `GOTO` and many had `ON-GOTO` to provide a simple computed goto construct. BASIC
    also supported subroutines via `GOSUB`, though most did not support recursion.
    Although perhaps scoffed at by many more serious programmers back in the 1960s
    and onward, the fact that BASIC continues today validates its utility.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: BASIC 使用行号，必须为每一行提供一个行号，用于 `GOTO` 语句的跳转。不同方言的 BASIC 提供了各种命令，但所有方言都有 `GOTO`，许多方言也有
    `ON-GOTO`，用于提供一个简单的计算跳转结构。BASIC 还支持通过 `GOSUB` 调用子程序，尽管大多数方言不支持递归。虽然在 1960 年代及以后，许多更严肃的程序员可能对
    BASIC 嗤之以鼻，但 BASIC 至今仍在使用，证明了它的实用性。
- en: '**PL/I**'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**PL/I**'
- en: '*PL/I (Programming Language 1*) was developed by IBM in the mid-1960s as a
    general-purpose programming language for all uses, scientific to business. As
    such, it competed directly with FORTRAN and COBOL. IBM has maintained PL/I and
    it’s currently available for IBM mainframe computers. The language itself is structured
    and imperative, and borrowed concepts from ALGOL, FORTRAN, and COBOL, as one might
    expect from a jack-of-all-trades language of the time. PL/I was in steady use
    from the late 1970s through the mid-1990s and represents one of the first languages
    intended to meet all programming needs.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*PL/I（编程语言 1）* 是 IBM 在 1960 年代中期开发的通用编程语言，旨在满足所有用途，从科学到商业。因此，它与 FORTRAN 和 COBOL
    直接竞争。IBM 一直在维护 PL/I，并且它目前可用于 IBM 大型主机计算机。该语言本身结构化且命令式，并从 ALGOL、FORTRAN 和 COBOL
    中借用了概念，正如人们所期望的那样，这是当时一种万金油式的编程语言。PL/I 从 1970 年代末期到 1990 年代中期一直在稳定使用，代表了旨在满足所有编程需求的首批语言之一。'
- en: Even though PL/I survives on IBM mainframes, its use elsewhere is negligible.
    New development in PL/I is likely equally insignificant. As an example of the
    language, [Listing 1-4](ch01.xhtml#ch01list4) shows a simple loop that outputs
    “Hello, world!” repeatedly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 PL/I 在 IBM 大型主机上得以延续，但在其他地方的使用几乎可以忽略不计。PL/I 的新开发也可能同样微不足道。作为语言的一个例子， [清单
    1-4](ch01.xhtml#ch01list4) 显示了一个简单的循环，重复输出“Hello, world!”。
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 1-4: A PL/I greeting*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-4：一个 PL/I 问候程序*'
- en: This example is quite readable, even now, though wordy, requiring four words
    to declare a simple integer variable. The influence of FORTRAN and ALGOL is evident
    via FORTRAN’s `DO` loop and ALGOL’s `END`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 即便是现在，这个例子依然相当易读，尽管有些啰嗦，需要四个单词来声明一个简单的整数变量。FORTRAN 和 ALGOL 的影响显而易见，通过 FORTRAN
    的 `DO` 循环和 ALGOL 的 `END`。
- en: '**Logo**'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Logo**'
- en: In 1967, Wally Feurzeig, Seymour Papert, and Cynthia Solomon gifted generations
    of students with *Logo*, a “simplified” version of Lisp intended to teach programming
    concepts. Logo, which means “word” or “thought” in Greek, is intended to foster
    thinking about programming, especially thinking about how the Logo turtle will
    behave given the commands the students enter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 1967 年，Wally Feurzeig、Seymour Papert 和 Cynthia Solomon 将 *Logo* 赠送给几代学生，这是一个旨在教授编程概念的简化版
    Lisp。Logo 在希腊语中意味着“单词”或“思想”，旨在促进学生思考编程，特别是思考给定命令后 Logo 海龟将如何表现。
- en: '[Figure 1-4](ch01.xhtml#ch01fig4) shows a simple Logo session. The user enters
    commands at the bottom of the screen, and the triangular “turtle” responds.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-4](ch01.xhtml#ch01fig4) 显示了一个简单的 Logo 会话。用户在屏幕底部输入命令，三角形的“海龟”会做出响应。'
- en: '![Image](Images/01fig04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig04.jpg)'
- en: '*Figure 1-4: Drawing with the Logo turtle*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-4：使用 Logo 海龟绘图*'
- en: Most commands are easy to understand, even if you’ve never seen Logo before.
    The commands in [Figure 1-4](ch01.xhtml#ch01fig4) are, with comments
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数命令都很容易理解，即使你以前从未接触过 Logo。 [图 1-4](ch01.xhtml#ch01fig4) 中的命令也一样，带有注释
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The inner `repeat` command draws a square with the turtle ending where it began.
    The 22.5 degree right turn tilts the turtle to draw another square. Since 16 ×
    22*.*5 = 360, 16 repetitions completes the pattern. The final instructions move
    the turtle off the pattern. Note that this particular Logo example is for Berkeley
    Logo. The exact form of the commands might be slightly different for another implementation.
    Logo is still used to teach programming concepts to children; see “Turtle Academy”
    (*[https://turtleacademy.com/](https://turtleacademy.com/)*). As Logo represents
    one of the first attempts to develop a programming language designed for teaching
    children, it deserves a place in our pantheon of languages.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 内部的`repeat`命令绘制一个正方形，海龟从起点结束。22.5度的右转使海龟倾斜以绘制另一个正方形。由于16 × 22*.*5 = 360，16次重复完成了该模式。最后的指令将海龟移出图案。请注意，这个Logo示例是为伯克利Logo设计的，其他实现可能会有稍微不同的命令形式。Logo至今仍用于教导儿童编程概念；请见“海龟学院”
    (*[https://turtleacademy.com/](https://turtleacademy.com/)*）。由于Logo是最早尝试为儿童设计编程语言之一，它在我们的语言殿堂中占有一席之地。
- en: '**Simula**'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Simula**'
- en: The first object-oriented language was *Simula*, developed by Kristen Nygaard
    and Ole-Johan Dahl. As the name suggests, Simula was first used for discrete-time
    simulations and evolved into a general-purpose language by 1967 (Simula 67). Simula
    brought the world classes, objects, and inheritance. The description that follows
    is specific to Simula 67\. I tested the examples with the GNU cim compiler (*[https://www.gnu.org/software/cim/](https://www.gnu.org/software/cim/)*),
    which is a bit tricky to build (at least version 5.1 is, which is the latest version
    available as of this writing). The cim compiler translates Simula to C before
    calling the standard gcc compiler to build the final executable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一款面向对象语言是*Simula*，由Kristen Nygaard和Ole-Johan Dahl开发。如其名所示，Simula最初用于离散时间模拟，并在1967年演变为一种通用语言（Simula
    67）。Simula为世界带来了类、对象和继承。以下描述特指Simula 67。我使用GNU cim编译器进行测试（*[https://www.gnu.org/software/cim/](https://www.gnu.org/software/cim/)*），该编译器的构建有些棘手（至少5.1版本比较麻烦，这是截至本文撰写时的最新版本）。cim编译器在调用标准gcc编译器构建最终可执行文件之前，会将Simula代码转换为C代码。
- en: The “Hello, world!” program in Simula isn’t particularly impressive.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Simula中的“Hello, world!”程序并不特别引人注目。
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It’s immediately clear that `OutText` prints something, and it’s reasonable
    to guess that `OutImage` acts like a newline, which it does. Structurally, Simula
    is part of the ALGOL family, with blocks denoted by `Begin` and `End` and semicolons
    to separate statements. Simula isn’t case sensitive, so `Begin` and `BEGIN` are
    equivalent. Comments begin with `comment` or an exclamation point and end with
    a semicolon, like other statements. If you’re familiar with Modula-2 or Pascal,
    then Simula syntax should look familiar.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`OutText`打印某些内容，而`OutImage`显然充当了换行符的角色，正如它所做的那样。从结构上看，Simula属于ALGOL家族，代码块由`Begin`和`End`表示，语句之间用分号分隔。Simula对大小写不敏感，因此`Begin`和`BEGIN`是等效的。注释以`comment`或感叹号开始，并以分号结束，就像其他语句一样。如果你熟悉Modula-2或Pascal，Simula的语法应该很熟悉。
- en: Simula is a structured language, like ALGOL, so both `for` and `while` control
    structures are present. Simula’s `for` is more flexible than in most other languages.
    For example, `for` iterates over a list of values, some of which may specify ranges.
    Consider the program
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Simula是一种结构化语言，像ALGOL一样，支持`for`和`while`控制结构。Simula的`for`循环比大多数其他语言更为灵活。例如，`for`可以遍历一组值，其中一些值可能指定范围。考虑以下程序：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'which outputs a table of squares and cubes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它输出一个平方和立方表：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `r` is 1 for the first two iterations of the loop, then runs from 3 through
    18 by threes, and ends with –12.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`r`在循环的前两次迭代中为1，然后以3为步长运行，直到18，最后是-12。
- en: However, if this were all Simula offered, it wouldn’t be worth discussing. Simula’s
    true gift to the world is object-oriented programming ([Listing 1-5](ch01.xhtml#ch01list5)),
    for which both Nygaard and Dahl received the Turing Award in 2001.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果这就是Simula所提供的全部，它也不值得讨论。Simula给予世界的真正贡献是面向对象编程（[示例 1-5](ch01.xhtml#ch01list5)），为此Nygaard和Dahl于2001年获得了图灵奖。
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 1-5: Using classes in Simula 67*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1-5：在Simula 67中使用类*'
- en: '[Listing 1-5](ch01.xhtml#ch01list5) shows us how to define and use classes.
    We define two classes, `Person` and `Pal`, a subclass of `Person`. `Person` uses
    the familiar `class` keyword and then defines `first` and `last` names as type
    `text`, a string object, along with `age`, an integer. `Person` defines one method,
    `Print`, to print the person’s full name and age.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 1-5](ch01.xhtml#ch01list5)展示了我们如何定义和使用类。我们定义了两个类，`Person`和`Pal`，后者是`Person`的子类。`Person`使用熟悉的`class`关键字，然后定义了`first`和`last`两个名称作为`text`类型的字符串对象，以及`age`作为整数类型。`Person`定义了一个方法`Print`，用来打印一个人的全名和年龄。'
- en: '`Pal` is a subclass of `Person`. It adds `nickname` and overrides `Print` to
    output the nickname before throwing in the strange line'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pal`是`Person`的一个子类。它添加了`nickname`并重写了`Print`方法，使得在抛出奇怪的行之前输出昵称。'
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: which is a way to call the `Print` method of the superclass, `Person`. The phrase
    `This Pal` is a reference to the object itself. It returns a reference to the
    current object much like `this` in C++. The phrase `Qua Person.Print` interprets
    the reference returned by `This Pal` as a `Person` object so the proper `Print`
    method is called. (“Qua” is derived from Latin and means “in the capacity of”
    or “as.”)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调用父类`Person`的`Print`方法的一种方式。短语`This Pal`是对当前对象的引用。它返回对当前对象的引用，类似于C++中的`this`。短语`Qua
    Person.Print`将`This Pal`返回的引用解释为一个`Person`对象，因此调用了正确的`Print`方法。（“Qua”源自拉丁语，意思是“以...的身份”或“作为...”）
- en: To use instances of these classes, we must create reference variables and then
    use `new` to assign the references to the actual instances. The `:-` operator
    assigns objects created on the heap to references. The `:=` operator assigns values
    to variables. Simula includes automatic garbage collection, so there is no need
    to delete objects when no longer needed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些类的实例，我们必须创建引用变量，然后使用`new`将引用分配给实际实例。`:-`运算符将堆上创建的对象分配给引用，而`:=`运算符将值分配给变量。Simula包括自动垃圾回收，因此不再需要在不再需要对象时手动删除它们。
- en: To populate the objects, we use both `:-` and `:=`. Strings are objects, so
    `:-` assigns them to the `text` objects, whereas `:=` is used to assign `age`
    as it is an integer. First we populate the two instances of the parent class,
    `Fred` and `Barney`, with names and ages. Then we populate the two `Pal` subclass
    instances, `Wilma` and `Betty`, in much the same way, this time including nicknames.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充对象，我们使用了`:-`和`:=`。字符串是对象，因此`:-`将它们分配给`text`对象，而`:=`用于分配`age`，因为它是一个整数。首先，我们将父类的两个实例`Fred`和`Barney`用名字和年龄进行填充。接着，我们以类似的方式填充了两个`Pal`子类实例`Wilma`和`Betty`，这次还包括了昵称。
- en: The goal of all of [Listing 1-5](ch01.xhtml#ch01list5) is to call the `Print`
    methods of the now populated objects, which produces
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 1-5](ch01.xhtml#ch01list5)的目标是调用已填充对象的`Print`方法，产生以下输出：'
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that the proper `Print` method is called on each object to produce the
    desired output string.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在每个对象上调用了正确的`Print`方法，以生成期望的输出字符串。
- en: Simula was well ahead of its time. Object-oriented programming took well over
    a decade after Simula 67 to catch on and, arguably, 20 years to become widely
    employed in the commercial software world. Simula’s strong association with simulation
    hurt the adoption of the language. As we’ve seen here, Simula is much more than
    a simulation language and even now fits into what we expect an object-oriented
    language to be.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Simula走在时代的前沿。面向对象编程在Simula 67发布后的十多年才开始流行，可以说，花了20年时间才在商业软件领域得到广泛应用。Simula与仿真紧密相关，这影响了该语言的采纳。正如我们在这里所看到的，Simula远远不止是一个仿真语言，甚至现在它也完全符合我们对面向对象语言的期望。
- en: '**Pascal**'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Pascal**'
- en: Niklaus Wirth released Pascal in 1970\. It is a direct descendant of ALGOL and
    was widely used into the 1980s, primarily to teach structured programming concepts.
    After unstructured BASIC, many software engineers learned Pascal as their first
    “serious” programming language. Early versions of the Macintosh operating system
    were written, at least partially, in Pascal. UCSD Pascal, followed by commercial
    products like Turbo Pascal, brought the language to microcomputers. As with BASIC
    above, Pascal has strongly influenced a generation of developers, to say nothing
    of programming language development as a whole, so it deserves a place in the
    pantheon as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Niklaus Wirth于1970年发布了Pascal语言。它是ALGOL的直接后代，并在1980年代广泛使用，主要用于教授结构化编程概念。在非结构化的BASIC之后，许多软件工程师将Pascal作为他们的第一个“严肃的”编程语言学习。早期版本的Macintosh操作系统部分使用Pascal编写。UCSD
    Pascal，随后是像Turbo Pascal这样的商业产品，使得Pascal语言进入了微型计算机领域。与上面提到的BASIC一样，Pascal对一代开发者产生了深远的影响，更不用说对整个编程语言发展的影响，因此它理应在编程语言的殿堂中占有一席之地。
- en: Look again at [Figure 1-3](ch01.xhtml#ch01fig3). There are two main branches
    of the ALGOL family of languages, one based on C and the other on Pascal. The
    Pascal branch leads to Modula-2, which overcame Pascal’s shortcomings but was
    never particularly popular, at least in North America. Ada was created by the
    US Department of Defense (DoD) as a standard for all development in the 1980s
    (Ada is named after Ada Lovelace). The DoD required the use of Ada for projects
    from 1991 to 1997\. At present, Pascal has fallen into obscurity, and Modula-2
    and its descendants, along with Ada, are even less popular. However, Pascal lives
    on as Delphi/Object Pascal. As a straightforward, structured programming language
    without object-oriented abilities, there was little reason to select Pascal after
    the rise of C and C++.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 再看一下 [图 1-3](ch01.xhtml#ch01fig3)。ALGOL 系列语言有两个主要分支，一个基于 C，另一个基于 Pascal。Pascal
    分支导致了 Modula-2，Modula-2 克服了 Pascal 的缺点，但从未特别流行，至少在北美是如此。Ada 是美国国防部（DoD）在 1980
    年代为所有开发项目创建的标准（Ada 以 Ada Lovelace 的名字命名）。DoD 要求在 1991 年至 1997 年间的项目中使用 Ada。目前，Pascal
    已经逐渐被遗忘，Modula-2 及其后代语言，包括 Ada，也变得更加冷门。然而，Pascal 作为 Delphi/Object Pascal 继续存在。作为一种简明的结构化编程语言，尽管不具备面向对象的能力，在
    C 和 C++ 崛起后，选择 Pascal 的理由已经不多。
- en: '[Listing 1-6](ch01.xhtml#ch01list6) gives us a feel for the language.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 1-6](ch01.xhtml#ch01list6) 给我们带来了对语言的感受。'
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 1-6: Generating the sequence of nonsquare integers*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-6：生成非平方数整数的序列*'
- en: Pascal looks quite similar to ALGOL and Simula. This particular program produces
    a table of 120 numbers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal 看起来与 ALGOL 和 Simula 非常相似。这个程序生成了一个包含 120 个数字的表格。
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Look carefully at the table; do you see what isn’t there? The table contains
    every integer less than 132 *except* for all the perfect squares: 4, 9, 16, 25,
    36, 49, 64, 81, 100, and 121\. The program implements the sequence'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看一下表格，你能发现缺少了什么吗？表格包含了所有小于 132 的整数，*除了*所有完全平方数：4、9、16、25、36、49、64、81、100 和
    121。程序实现了这个序列。
- en: '![Image](Images/f0020.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0020.jpg)'
- en: which has the remarkable property of bypassing all perfect squares, as *n* is
    incremented from one.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有一个显著的特点，即绕过所有完全平方数，因为 *n* 从 1 开始递增。
- en: Pascal programs begin with `program` followed by a variable declaration section
    beginning with `var`. Here we define one integer variable, `n`. The body of the
    program is between `begin` at the beginning and `end.` at the end. Note that the
    period is required for the final `end`. Blocks of code are also enclosed within
    `begin` and `end`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal 程序以 `program` 开头，后面是以 `var` 开头的变量声明部分。在这里，我们定义了一个整数变量 `n`。程序的主体位于 `begin`
    和 `end.` 之间。请注意，`end` 后面的句号是必需的。代码块也需要被 `begin` 和 `end` 包围。
- en: The body of this program is a single `for` loop running from 1 to 120\. The
    body of the loop is a `write` statement, which does not move to the next line
    when done. The number output is the equation above for the current value of *n*.
    The argument `:4` tells Pascal to right-justify the output in four spaces. The
    code also tells the program to move to the next line if `n` is a multiple of 10.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的主体是一个从 1 到 120 的单一 `for` 循环。循环体是一个 `write` 语句，执行完毕后不会换行。输出的数字是上面方程式中当前 *n*
    值的结果。参数 `:4` 告诉 Pascal 将输出右对齐并占据四个空间。代码还要求程序在 `n` 是 10 的倍数时换行。
- en: Pascal was intended for teaching and wasn’t suitable for system-level programming
    without nonstandard extensions. Wirth enhanced Pascal to make Modula-2, which
    was suitable for system-level programming. However, Modula-2 never reached its
    full potential in the commercial world. Regardless, Wirth’s Pascal, and subsequent
    languages, rightfully earned him the Turing Award in 1984.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal 原本是为了教学而设计的，没有非标准扩展的话并不适合系统级编程。Wirth 对 Pascal 进行了增强，开发出了适合系统级编程的 Modula-2。然而，Modula-2
    在商业领域从未发挥出其全部潜力。尽管如此，Wirth 的 Pascal 及其后来的编程语言，理所当然地使他获得了 1984 年的图灵奖。
- en: '**Prolog**'
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Prolog**'
- en: Most programming languages are imperative. That is, programs are a recipe, a
    series of “do this” followed by “now do that.” However, in *Prolog*, things are
    different. Prolog is a *declarative language*. Relationships are encoded as rules,
    and it’s up to the Prolog engine to figure out how to accomplish the goal of answering
    a user query. Prolog was created in 1972 by Alain Colmerauer and Robert Kowalski
    and is still in limited use today.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都是命令式的。也就是说，程序就像食谱一样，一系列的“做这个”接着是“现在做那个”。然而，在 *Prolog* 中，情况有所不同。Prolog
    是一种 *声明式语言*。关系通过规则编码，Prolog 引擎负责弄清楚如何实现回答用户查询的目标。Prolog 由 Alain Colmerauer 和 Robert
    Kowalski 于 1972 年创建，至今仍在有限使用中。
- en: A Prolog program is a series of *facts*, *rules*, and *queries*. We’ll learn
    what these are in a bit. Thinking in Prolog is quite different from thinking in
    most languages. Imperative languages are natural, and object-oriented languages
    build on that. Even APL makes sense once you understand the odd characters. But
    Prolog is an entirely different beast. We’ll only scratch the surface of it here.
    Later in the book, we devote an entire chapter to CLIPS, which is somewhat like
    Prolog, so we’ll struggle with this mode of thinking then.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Prolog程序由*事实*、*规则*和*查询*组成。稍后我们会了解它们是什么。用Prolog思考与用大多数语言思考截然不同。命令式语言比较自然，面向对象语言是在此基础上进行扩展的。即使是APL，一旦你理解了它的特殊字符，也能理解其逻辑。但Prolog则是一个完全不同的领域。我们这里只是触及它的皮毛。书中的后面章节会专门讨论CLIPS，它与Prolog有些相似，届时我们会深入探讨这种思维模式。
- en: 'This section presents two small Prolog examples. I used SWI-Prolog (*[https://www.swi-prolog.org/](https://www.swi-prolog.org/)*),
    which is most easily installed on Ubuntu by typing the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了两个小型Prolog示例。我使用的是SWI-Prolog（* [https://www.swi-prolog.org/](https://www.swi-prolog.org/)
    *），可以通过在Ubuntu上输入以下命令轻松安装：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Please see the Prolog website for the macOS and Windows versions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅Prolog官方网站，获取macOS和Windows版本。
- en: '***Modeling Family Relationships***'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***建模家庭关系***'
- en: The canonical Prolog example involves family relationships. Our example is in
    *family.pl*, with the most important parts shown in [Listing 1-7](ch01.xhtml#ch01list7).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的Prolog示例涉及家庭关系。我们的例子位于*family.pl*文件中，最重要的部分展示在[清单1-7](ch01.xhtml#ch01list7)中。
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 1-7: Family relationships in Prolog*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单1-7：Prolog中的家庭关系*'
- en: Let’s walk through the code in [Listing 1-7](ch01.xhtml#ch01list7) before exploring
    what Prolog can do with it. The first portion of the code builds a knowledge base,
    which is a listing of facts. The code presents facts about the relationships between
    the classic Greek gods. For example, according to mythology, the parents of Cronus
    are Gaia and Uranus, so the knowledge base uses the lines `parent(uranus, cronus).`
    and `parent(gaia, cronus).` to state this.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索Prolog能做什么之前，先来看一下[清单1-7](ch01.xhtml#ch01list7)中的代码。代码的第一部分构建了一个知识库，这是一个事实列表。代码展示了经典希腊神话中众神之间的关系。例如，根据神话，克洛诺斯的父母是盖亚和乌拉诺斯，因此知识库使用`parent(uranus,
    cronus).`和`parent(gaia, cronus).`来表达这一点。
- en: Note that Prolog doesn’t have a `parent` function’ thus, the statements are
    facts relating two *atoms*. Atoms are generic names, a collection of characters
    treated as a symbol and acting as a single unit. There is a relationship called
    `parent` and `gaia` and `cronus` share it. We read the fact as “Gaia is the parent
    of Cronus.” Similarly, the knowledge base also labels the sex of the gods. Read
    `female(hera).` as “Hera is female.” Notice that facts, and later rules and queries,
    end with a period. The knowledge base identifies the sex, parents, and whether
    or not two gods were considered married. Again, these are the facts that Prolog
    will work with. To do anything interesting, we need some rules to go with the
    facts. That’s the second part of [Listing 1-7](ch01.xhtml#ch01list7).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Prolog没有`parent`函数，因此这些语句是关联两个*原子*的事实。原子是通用名称，由一串字符构成，作为符号处理并作为一个单元存在。这里有一个名为`parent`的关系，`gaia`和`cronus`共享这一关系。我们可以将事实理解为“盖亚是克洛诺斯的父母。”类似地，知识库还标记了神祇的性别。`female(hera).`的意思是“赫拉是女性。”注意，事实、规则和查询都以句号结束。知识库确定了性别、父母关系以及两个神是否被认为结婚。这些就是Prolog将要处理的事实。为了做一些有趣的事情，我们需要为这些事实配上规则。这是[清单1-7](ch01.xhtml#ch01list7)的第二部分。
- en: Using family relationships helps because we are all so familiar with them. For
    example, we define a rule to decide if `X` is the father of `Y`, where atoms beginning
    with a capital letter are logical variables. Prolog will try to satisfy rules
    by locating values for these variables. The rule defines the relationship as “If
    *X* is the parent of *Y* and *X* is male, then *X* is the father of *Y*.”
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用家庭关系作为例子有助于我们理解，因为我们每个人都对它们非常熟悉。例如，我们定义了一个规则来判断`X`是否是`Y`的父亲，其中以大写字母开头的原子是逻辑变量。Prolog会尝试通过为这些变量找到值来满足规则。该规则定义的关系是：“如果*X*是*Y*的父母并且*X*是男性，那么*X*就是*Y*的父亲。”
- en: The left-hand side of `father(X,Y)` is true *if* the right-hand side is true.
    The right-hand side is true *if* `parent(X,Y)` is true *and* (comma) `male(X)`
    is true. Prolog uses a comma for “and” and a semicolon for “or.” With just this
    bit of knowledge, we can read the rest of the rules. A mother is a parent and
    female. Someone, `X`, is the child of `Y` if `Y` is the parent of `X`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`father(X,Y)` 的左侧为真 *当且仅当* 右侧为真。右侧为真 *当且仅当* `parent(X,Y)` 为真 *并且*（逗号）`male(X)`
    为真。Prolog 使用逗号表示“和”，使用分号表示“或”。有了这一点知识，我们就能理解其余的规则。母亲是父母且为女性。某人 `X` 是 `Y` 的孩子，如果
    `Y` 是 `X` 的父母。'
- en: The rule for `sibling` says two people are siblings if they share a parent.
    That much makes sense. The last part of the rule is `dif(X,Y)`. It adds “and *X*
    and *Y* are not the same” to the rule. This is there because we don’t normally
    think of ourselves as our own siblings.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`sibling` 的规则表示，如果两人有共同的父母，则他们是兄妹。这一点很容易理解。规则的最后部分是 `dif(X,Y)`，它添加了“*X* 和 *Y*
    不是同一个人”这一条件。这是因为我们通常不会认为自己是自己的兄弟姐妹。'
- en: The rule for `wife` uses parentheses and a semicolon for “or.” `X` is a wife
    if she is female and married to `Y`. Prolog doesn’t intuitively know that the
    rule `married(X,Y)` implies `married(Y,X)`, so either case is checked.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`wife` 的规则使用了括号和分号表示“或”。`X` 是妻子，如果她是女性且嫁给了 `Y`。Prolog 并不直观地知道规则 `married(X,Y)`
    隐含着 `married(Y,X)`，因此会检查两种情况。'
- en: The final rule is `paramour`, because, after all, we’re talking about ancient
    Greek gods. Here, `X` is a paramour of `Y` if `A` is a child of both `X` and `Y`,
    `X` and `Y` are not married (`\+` is like “not”), and `X` and `Y` are different.
    Read through the rules in [Listing 1-7](ch01.xhtml#ch01list7) until you feel comfortable
    with what they express.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最终规则是 `paramour`，因为毕竟我们谈论的是古希腊的神祇。这里，`X` 是 `Y` 的情人，条件是 `A` 是 `X` 和 `Y` 的孩子，`X`
    和 `Y` 没有结婚（`\+` 表示“不是”），并且 `X` 和 `Y` 是不同的。阅读 [清单 1-7](ch01.xhtml#ch01list7) 中的规则，直到你对它们表达的内容感到熟悉为止。
- en: Prolog programs are not loaded, but are rather *consulted*. The line
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Prolog 程序不是被加载的，而是被 *咨询* 的。该行
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: consults *family.pl*, after which Prolog presents its prompt and waits patiently
    for user input. Let’s ask Prolog some questions about the gods and see if it can
    answer them based on the facts and rules we fed it (see [Listing 1-8](ch01.xhtml#ch01list8)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 查询 *family.pl*，然后 Prolog 会展示其提示符并耐心等待用户输入。我们来问 Prolog 一些关于神祇的问题，看看它是否能根据我们提供的事实和规则做出回答（参见
    [清单 1-8](ch01.xhtml#ch01list8)）。
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 1-8: Exploring family relationships*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-8：探索家庭关系*'
- en: '[Listing 1-8](ch01.xhtml#ch01list8) shows a Prolog session where *family.pl*
    has been consulted. User input is in bold with Prolog’s replies following. First,
    we ask Prolog if Zeus and Hera are married. Prolog replies `true`, as this is
    simply a fact in its knowledge base.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 1-8](ch01.xhtml#ch01list8) 展示了一个 Prolog 会话，其中 *family.pl* 已被加载。用户输入以粗体显示，Prolog
    的回复跟随其后。首先，我们询问 Prolog 宙斯和赫拉是否结婚。Prolog 回复 `true`，因为这只是其知识库中的一个事实。'
- en: 'Next, we ask Prolog to find an `X` such that `X` is the wife of Zeus. Notice
    that the rule is defined such that `X` is the wife of `Y` so the query is `wife(X,zeus)`
    and not `wife(zeus,X)` which would be asking the question “who is Zeus the wife
    of?” Prolog finds one match, one binding for `X` that makes the query true: Hera.
    The user then enters the bold semicolon. After Prolog finds a solution, if it
    can’t decide that there are no other solutions to the query on its own, it pauses
    and waits for the user to enter a semicolon to tell Prolog to search for more
    solutions. The final `false` is Prolog telling the user that no more solutions
    were found.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们让 Prolog 找到一个 `X`，使得 `X` 是宙斯的妻子。注意，规则是这样定义的：`X` 是 `Y` 的妻子，因此查询是 `wife(X,zeus)`，而不是
    `wife(zeus,X)`，后者会提出问题“宙斯的妻子是谁？”Prolog 找到一个匹配项，一个使得查询为真的 `X` 绑定：赫拉。用户接着输入粗体分号。Prolog
    找到解决方案后，如果无法自行确定查询没有其他解，它会暂停并等待用户输入分号，指示 Prolog 继续寻找更多解决方案。最终的 `false` 是 Prolog
    告诉用户没有找到更多解决方案。
- en: Then we ask Prolog, “Hera is the mother of who?” and we’re correctly told Ares,
    Hephaestus, and Eris. Next we ask, “Who is the mother of Hera?” and, again correctly,
    Prolog answers Rhea. The following query tells us that Rhea is also Zeus’s mother.
    The ancient gods certainly had complex family relationships.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们问 Prolog，“赫拉是誰的母亲？”Prolog 正确回答了阿瑞斯、赫淮斯托斯和厄里斯。接着我们问，“赫拉的母亲是谁？”Prolog 又正确回答了瑞亚。接下来的查询告诉我们瑞亚也是宙斯的母亲。古代神祇的家庭关系确实非常复杂。
- en: We next ask Prolog to identify the children of Zeus. Specifically, we ask, “Zeus
    is the father of who?” and are correctly told he is the father of eight other
    gods, much to the annoyance of Hera.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们让 Prolog 确定宙斯的孩子。具体来说，我们问：“宙斯的孩子是谁？”并且正确地告诉我们他是另外八个神的父亲，这让赫拉非常恼火。
- en: A few more examples will drive home how Prolog works. [Listing 1-9](ch01.xhtml#ch01list9)
    shows Prolog’s response to the query “Who are Zeus’s paramours?”
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的示例将帮助我们更好地理解 Prolog 的工作原理。[列表 1-9](ch01.xhtml#ch01list9)展示了 Prolog 对查询“宙斯的情人是谁？”的回应。
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 1-9: More family relationships*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-9：更多的家庭关系*'
- en: Notice that Leto is listed twice. The rule for paramour is
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到丽托被列出了两次。情人的规则是：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: meaning that `X` and `Y` are paramours if they are not married and have a child
    together. In mythology, Zeus and Leto have twins, Apollo and Artemis. There-fore,
    Prolog finds that Leto and Zeus are paramours in two different ways, once for
    Apollo and again for Artemis. There are ways to capture responses and return only
    unique solutions, but using them here would only cloud the example. The final
    two queries in [Listing 1-9](ch01.xhtml#ch01list9) illustrate that Prolog can
    resolve queries involving grandparents and great-grandparents.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果 `X` 和 `Y` 不是夫妻关系并且有一个共同的孩子，那么他们就是情人。在神话中，宙斯和丽托有一对双胞胎，阿波罗和阿尔忒弥斯。因此，Prolog
    发现丽托和宙斯通过两种不同的方式是情人，一次是阿波罗，另一次是阿尔忒弥斯。有一些方法可以捕捉响应并仅返回唯一的解决方案，但在这里使用它们会使示例变得更加混乱。[列表
    1-9](ch01.xhtml#ch01list9)中的最后两个查询说明了 Prolog 如何解决涉及祖父母和曾祖父母的查询。
- en: '***Implementing the Fibonacci Sequence***'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现斐波那契数列***'
- en: Our last Prolog example shows how it works with numeric data and its support
    for recursion. Specifically, we’ll implement the Fibonacci sequence,
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的 Prolog 示例展示了它如何处理数值数据以及对递归的支持。具体来说，我们将实现斐波那契数列，
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'which is expressible recursively by saying that the next number is the sum
    of the previous two:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则可以通过递归的方式表示，即下一个数字是前两个数字的和：
- en: '*F[n]* = *F[n–]*[1] + *F[n–]*[2], *F*[1] = 1, *F*[2] = 1'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*F[n]* = *F[n–]*[1] + *F[n–]*[2]，*F*[1] = 1，*F*[2] = 1'
- en: We’ll discuss the Fibonacci sequence in more detail in [Chapter 13](ch13.xhtml#ch13).
    It’s an easy target for esolang examples. For now, we’ll use a recursive Python
    implementation as a guide for a Prolog version. In Python, the equation above
    can be implemented as
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第13章](ch13.xhtml#ch13)中更详细地讨论斐波那契数列。它是编程语言示例中的一个常见目标。目前，我们将使用一个递归的 Python
    实现作为 Prolog 版本的指南。在 Python 中，上面的公式可以实现为：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The *n*th Fibonacci number is the sum of the previous two, or if *n* is less
    than or equal to two, just one. This function tells us that *F*[11] = 89, which
    is correct. So how can we express the rule for the Fibonacci sequence in Prolog?
    To do so, we first need two facts that act as the base cases, *F*[1] = 1 and *F*[2]
    = 1\. Then we need to express the recursive relationship. [Listing 1-10](ch01.xhtml#ch01list10)
    has what we need.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*th 斐波那契数是前两个数的和，或者如果 *n* 小于或等于 2，则为 1。这个函数告诉我们，*F*[11] = 89，这是正确的。那么，如何在
    Prolog 中表示斐波那契数列的规则呢？为此，我们首先需要两个事实作为基准情况，*F*[1] = 1 和 *F*[2] = 1。然后，我们需要表达递归关系。[列表
    1-10](ch01.xhtml#ch01list10)给出了我们需要的内容。'
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 1-10: Recursive Fibonacci numbers*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-10：递归斐波那契数*'
- en: The two base cases are facts. The first Fibonacci number is 1, and the second
    is 1\. When Prolog is eventually trying to satisfy `fib(2,1)`, it will find the
    fact. The “return value” is the second number. The query to find the 11th Fibonacci
    number is `fib(11,F).` or “What F value makes `fib(11,F)` true?” That’s the 11th
    Fibonacci number.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个基准案例是事实。第一个斐波那契数是 1，第二个是 1。当 Prolog 最终尝试满足 `fib(2,1)` 时，它会找到这个事实。“返回值”是第二个数字。查询
    11th 斐波那契数是 `fib(11,F).` 或者“哪个 F 值使 `fib(11,F)` 为真？”那就是第 11 个斐波那契数。
- en: The general rule is `fib(N,F)`. The body is the conjunction (that is, clauses
    linked by “and”) of several things. First, is it true that `N > 2`? Next come
    two “assignments,” which are true when `N1` is *n –* 1 and `N2` is *n –* 2\. So
    far, the statements make sense and are elements of the Python definition.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一般规则是 `fib(N,F)`。其主体是多个条件的合取（即通过“和”连接的子句）。首先，`N > 2` 是否成立？接下来是两个“赋值”，当 `N1`
    是 *n –* 1 且 `N2` 是 *n –* 2 时成立。到目前为止，这些语句是有道理的，并且是 Python 定义中的元素。
- en: The next two lines, `fib(N1,F1)` and `fib(N2,F2)`, are strange at first. These
    are the recursive calls, as it were. The first seeks to find *F*[*n–*1] by finding
    an `F1` such that `fib(N1,F1)` is true. Likewise, the second does the same for
    *F*[*n–*2]. If these are found, then `F1` and `F2` have meaningful values, and
    the last line says that `F`, the actual number we’ve been looking for, is the
    sum of `F1` and `F2`, which must be the previous two Fibonacci numbers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行，`fib(N1,F1)`和`fib(N2,F2)`，一开始显得有些奇怪。这些就是递归调用。第一个尝试通过查找`fib(N1,F1)`使其为真，来找到*F*[*n–*1]。同样，第二个也对*F*[*n–*2]做相同操作。如果找到这些，那么`F1`和`F2`有了意义，最后一行说`F`，我们实际寻找的数字，是`F1`和`F2`的和，必须是前两个斐波那契数。
- en: 'The code for [Listing 1-10](ch01.xhtml#ch01list10) is in *fib.pl*. Let’s start
    Prolog, consulting *fib.pl*, and ask it for the 11th Fibonacci number:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-10](ch01.xhtml#ch01list10)的代码在*fib.pl*中。我们开始Prolog，咨询*fib.pl*，并请求第11个斐波那契数：'
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We see that our example works, as it gives us the same answer as the Python
    version. Now, ask for `fib(26,F)` and see how long it takes Prolog to answer.
    On my machine, Python answers immediately with 121,393\. Prolog also answers with
    121,393 but takes 29 seconds to do so. The double recursive call makes this Fibonacci
    implementation inefficient. However, Prolog’s exceedingly slow response validates
    a common criticism of the language: its performance. Moreover, the Unix utility,
    `top`, reported that during the search, Prolog used 0.5 percent of system memory,
    or about 42MB, which seems excessive for such a simple task.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们的示例有效，它给出了与Python版本相同的答案。现在，查询`fib(26,F)`并查看Prolog需要多长时间来回答。在我的机器上，Python立即返回121,393。Prolog也返回121,393，但需要29秒。双重递归调用使得这个斐波那契实现效率低下。然而，Prolog极其缓慢的响应验证了对语言的一个常见批评：性能。此外，Unix工具`top`报告在搜索过程中，Prolog使用了0.5%的系统内存，大约42MB，这对于如此简单的任务来说似乎过高。
- en: Tracing lets us watch Prolog work through a query. For example, here’s the output
    tracing the query `fib(3,F)`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪让我们看到Prolog如何处理查询。例如，以下是跟踪查询`fib(3,F)`的输出。
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'First, we activate `trace` and enter the query: `fib(3,F)`. At each step, Prolog
    pauses, waiting for a command. Pressing ENTER moves to the next step and displays
    `creep`. Therefore, each line above represents entering or exiting a subgoal of
    the rule. Temporary variables have names like `_4072`.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们激活`trace`并输入查询：`fib(3,F)`。在每一步，Prolog会暂停，等待命令。按ENTER键进入下一步，并显示`creep`。因此，上面每一行表示进入或退出规则的子目标。临时变量的名称像`_4072`。
- en: The first line of the trace is the query with a temporary name for `F`. The
    `8` is similar to a call depth indicator, as it increases as the query is evaluated
    and decreases back to its initial value when the query is satisfied.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪的第一行是查询，`F`有一个临时名称。`8`类似于一个调用深度指示器，因为它在查询被评估时增加，在查询满足时返回到初始值。
- en: If you walk through the trace, you’ll see that each step works to satisfy the
    particular subgoal, that is, a part of the right-hand side of the rule. The first
    pair, for example, indicates that 3 > 2 is true. The second pair says that 2 =
    3 + (*–*1), which is also true. Interestingly, Prolog adds a –1 instead of subtracting
    1.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟踪过程，你会看到每一步都在满足特定的子目标，也就是规则右侧的一部分。例如，第一个对表示3 > 2为真。第二个对表示2 = 3 + (*–*1)，这也为真。有趣的是，Prolog加了一个-1，而不是减去1。
- en: The first recursive call ➊ is immediately satisfied because `fib(2,1)` is a
    known fact, one of the base cases of the recursion. The second recursive call
    ➋ is similarly satisfied because `fib(1,1)` is also a fact.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次递归调用 ➊ 立即得到满足，因为`fib(2,1)`是已知的事实，是递归的基本情况之一。第二次递归调用 ➋ 也同样满足，因为`fib(1,1)`也是一个事实。
- en: With the recursive calls satisfied, the final subgoal, `F is F1 + F2`, can be
    satisfied with `F=2`. Thus, the query, `fib(3,2)`, is now satisfied and Prolog
    returns `F = 2`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 递归调用被满足后，最终的子目标`F is F1 + F2`可以通过`F=2`来满足。因此，查询`fib(3,2)`现在被满足，Prolog返回`F =
    2`。
- en: The trace for `fib(3,F)` produced 14 lines of output and the trace for `fib(26,F)`,
    which took nearly 30 seconds to return, produced 1,456,706 lines, reaching a maximum
    depth 24 above the base depth.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`fib(3,F)`的跟踪产生了14行输出，而`fib(26,F)`的跟踪，花了近30秒返回，产生了1,456,706行，达到了基深度之上的最大深度24。'
- en: We’ve been a bit unfair to Prolog. The double recursive Fibonacci algorithm
    is inefficient because it is not *tail recursive*. A tail-recursive call is one
    in which the last invocation is the recursive part. Tail-recursive functions can
    be implemented without storing the current call’s stack frame. The recursion becomes
    essentially a jump to the beginning of the function without involving the call
    stack.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 Prolog 有些不公平。双重递归的斐波那契算法效率低下，因为它不是*尾递归*。尾递归调用是指最后一次调用是递归部分。尾递归函数可以在不存储当前调用栈帧的情况下实现。递归本质上是跳转到函数的开始，而不涉及调用栈。
- en: '[Listing 1-11](ch01.xhtml#ch01list11) is a tail-recursive version of the Fibonacci
    program. You’ll find it in the file *fib_tail.pl*.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-11](ch01.xhtml#ch01list11)是斐波那契程序的尾递归版本。你可以在文件*fib_tail.pl*中找到它。'
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 1-11: Fibonacci numbers using tail recursion*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1-11：使用尾递归计算斐波那契数*'
- en: 'This version of the code uses two additional variables as accumulators: the
    second and third arguments. The base case is any call matching `fib(1,A,F,F)`,
    with `F` being the desired number, and `A` being any other value. Notice that
    the rule `fib(N,A,B,F)` has a recursive call as the final subgoal, unlike [Listing
    1-10](ch01.xhtml#ch01list10), which has two recursive calls, neither of which
    is the final subgoal. Prolog can use tail recursion here because there is nothing
    in the body to come back to.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的代码使用了两个额外的变量作为累加器：第二个和第三个参数。基本情况是任何匹配`fib(1,A,F,F)`的调用，其中`F`是所需的数字，`A`是任何其他值。请注意，规则`fib(N,A,B,F)`的最后子目标是递归调用，这与[示例
    1-10](ch01.xhtml#ch01list10)不同，后者有两个递归调用，但都不是最后的子目标。Prolog在这里可以使用尾递归，因为在主体中没有内容需要返回。
- en: Run [Listing 1-11](ch01.xhtml#ch01list11) as `fib(26,0,1,F)` to find the 26th
    Fibonacci number. This time, Prolog will respond immediately with 121,383\. Then
    try `fib(266,0,1,F)` to see that Prolog supports arbitrary precision integers.
    The `trace` command will show you how the accumulators are used to ultimately
    arrive at a call matching `fib(1,A,F,F)`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 运行[示例 1-11](ch01.xhtml#ch01list11)作为`fib(26,0,1,F)`来计算第26个斐波那契数。这次，Prolog 会立即返回
    121,383。然后尝试`fib(266,0,1,F)`，看看 Prolog 如何支持任意精度整数。`trace`命令将展示累加器是如何被使用的，最终匹配到`fib(1,A,F,F)`的调用。
- en: If our goal is to learn to think outside the box in terms of what it means to
    code, and it is, then Prolog promotes such thinking. Keep Prolog in the back of
    your mind. We’ll see a similar approach later when we discuss CLIPS in [Chapter
    6](ch06.xhtml#ch06).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的目标是学会跳出框架思考编码的含义，那么Prolog能够促进这种思维方式。把Prolog放在你的脑海中。稍后我们会看到类似的方法，当我们在[第6章](ch06.xhtml#ch06)中讨论CLIPS时。
- en: '**Smalltalk**'
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Smalltalk**'
- en: Smalltalk came to be in the early 1970s, a product of the Learning Research
    Group at Xerox PARC. It was designed by Alan Kay, Dan Ingalls, and Adele Goldberg
    as a teaching language, much like Logo. Smalltalk is an object-oriented language.
    In fact, it is a *pure object-oriented language*, meaning that everything, even
    numbers, is an object. Pure object-oriented languages stand in contrast to impure
    languages like C++. In C++, *primitives*, such as integers, are not objects. Smalltalk
    objects communicate with each other by sending messages. If an object knows how
    to reply to a message, then that object is a valid receiver of the message.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Smalltalk出现在1970年代初，是Xerox PARC学习研究小组的产物。它由Alan Kay、Dan Ingalls和Adele Goldberg设计，作为一种教学语言，类似于Logo。Smalltalk是一种面向对象的语言。实际上，它是一种*纯面向对象语言*，意味着一切，甚至数字，都是对象。纯面向对象语言与像C++这样的非纯语言形成对比。在C++中，*原始类型*（如整数）不是对象。Smalltalk对象通过发送消息相互通信。如果一个对象知道如何回复一个消息，那么这个对象就是该消息的有效接收者。
- en: Smalltalk classes support *duck typing* and may be extended at will. Duck typing
    allows any object that supports a particular method to be used where that method
    is expected. In other words, if it walks like a duck and quacks like a duck, it’s
    a duck.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Smalltalk 类支持*鸭子类型*，并且可以随意扩展。鸭子类型允许任何支持特定方法的对象在预期该方法的地方使用。换句话说，如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子。
- en: Even without knowing the syntax, we can understand that `MyClass` in the following
    example defines a method, `A`, to square its argument.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不了解语法，我们也能理解，下面的示例中，`MyClass`定义了一个方法`A`来对它的参数进行平方操作。
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At any later time, even if objects of `MyClass` already exist, a new method
    to calculate cubes may be added.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，即使`MyClass`的对象已经存在，仍然可以添加一个新的方法来计算立方。
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `MyClass` class, including any existing objects, now knows how to use the
    method `B`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyClass` 类，包括任何现有对象，现在知道如何使用方法`B`。'
- en: Many Smalltalk systems include an extensive graphical interface. This includes
    Smalltalk-80, the version we’ll explore here. Modern Smalltalk systems, like Squeak
    (*[https://squeak.org/](https://squeak.org/)*) or Pharo (*[https://pharo.org/](https://pharo.org/)*),
    follow this tradition. If Smalltalk piques your curiosity, do take a look at one
    or both of these systems. However, the essence of the Smalltalk language is our
    focus, not its graphics abilities. Therefore, we’ll work with GNU Smalltalk, which
    is graphics-free.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Smalltalk 系统都包括了一个广泛的图形界面。这包括了 Smalltalk-80，这是我们将在此探讨的版本。现代 Smalltalk 系统，如
    Squeak (*[https://squeak.org/](https://squeak.org/)* ) 或 Pharo (*[https://pharo.org/](https://pharo.org/)*
    )，都延续了这一传统。如果 Smalltalk 引发了你的兴趣，不妨看看这两个系统之一或两个系统。然而，我们的重点是 Smalltalk 语言的本质，而不是它的图形功能。因此，我们将使用不带图形功能的
    GNU Smalltalk。
- en: If you want to follow along yourself, install GNU Smalltalk by typing
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想自己跟着做，安装 GNU Smalltalk 的方法是输入：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: On macOS, you can install Smalltalk by typing
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，你可以通过输入以下命令安装 Smalltalk：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For Windows users, I recommend a Linux virtual machine, Windows Subsystem for
    Linux, or, barring that, Cygwin.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 用户，我推荐使用 Linux 虚拟机、Windows 子系统 for Linux，或者如果不行的话，使用 Cygwin。
- en: Smalltalk supports integers, floating-point numbers, strings, and fractions
    (rationals). Smalltalk has 1D arrays, dictionaries, and many other container objects.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Smalltalk 支持整数、浮动小数、字符串和分数（有理数）。Smalltalk 有一维数组、字典和许多其他容器对象。
- en: 'Our goal in this vignette is to learn what makes Smalltalk unique and a good
    addition to our collection of novel programming languages. First comes a brief
    discussion of what Smalltalk brings to the table. Then we’ll work through a complete
    Smalltalk program to understand, at least superficially, how classes are defined
    and subclassed. Specifically, we simulate a race between four different animals,
    each its own Smalltalk class: bird, wolf, frog, and snail.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本篇小节的目标是学习 Smalltalk 的独特之处，以及它为什么是我们编程语言收藏中的一项有益补充。首先简要讨论一下 Smalltalk 所带来的特色。然后，我们将通过一个完整的
    Smalltalk 程序来理解，至少是表面上，类是如何定义和继承的。具体来说，我们模拟了四种不同动物之间的竞赛，每种动物都有自己的 Smalltalk 类：鸟、狼、青蛙和蜗牛。
- en: '***Basic Smalltalk Features***'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基本的 Smalltalk 特性***'
- en: 'GNU Smalltalk is intended for scripting, just like Python or Perl. For example,
    this code shows our first example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: GNU Smalltalk 旨在用于脚本编写，就像 Python 或 Perl 一样。例如，以下代码展示了我们的第一个例子：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first line is not standard Smalltalk. It’s the comment line used by Unix
    systems to make a script executable by pointing to its interpreter. Double quotes
    surround comments in Smalltalk, while single quotes surround strings.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行不是标准的 Smalltalk。这是 Unix 系统用来通过指向解释器使脚本可执行的注释行。Smalltalk 中的注释用双引号括起来，而字符串则用单引号括起来。
- en: 'The general syntax for calling a method on an object is <object> <method> or
    <object> <method>: <argument>. Everything’s an object, including strings (even
    empty ones). Each line in the example above defines a string and then calls the
    `displayNl` method to print it. Notice the period at the end of each line. Smalltalk
    uses periods as statement separators. On a Unix-like system, `chmod a+x hello.st`
    makes *hello.st* executable. The GNU Smalltalk interpreter itself is `gst`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '调用对象方法的一般语法是 <object> <method> 或 <object> <method>: <argument>。一切皆是对象，包括字符串（即使是空字符串）。上面例子中的每一行都定义了一个字符串，然后调用
    `displayNl` 方法打印它。注意每一行末尾的句号。Smalltalk 使用句号作为语句分隔符。在类 Unix 系统中，`chmod a+x hello.st`
    使 *hello.st* 可执行。GNU Smalltalk 解释器本身是 `gst`：'
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can exit the interpreter with CTRL-D.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过按 CTRL-D 退出解释器。
- en: The expressions above should give you pause. Smalltalk evaluates from left to
    right without respect to operator precedence. Therefore, the first expression
    is interpreted as `2+3*6 = 5*6 = 30`. Recall that APL is similar but evaluates
    from right to left. In Smalltalk, use parentheses on expressions to enforce the
    desired evaluation ordering.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式应该引起你的注意。Smalltalk 是从左到右进行计算的，不考虑运算符优先级。因此，第一个表达式被解释为 `2+3*6 = 5*6 = 30`。回想一下，APL
    是类似的，但它是从右到左进行计算的。在 Smalltalk 中，你可以使用括号来明确表达式的计算顺序。
- en: Smalltalk syntax is simple but leads to verbose statements. To define and make
    basic use of an array, use
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Smalltalk 的语法简单，但会导致冗长的语句。要定义并基本使用数组，使用：
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Smalltalk uses `:=` for assignment, so the first line declares `x` to be an
    array of five elements. Smalltalk variables default to `nil`. The second line
    is `x[0]=3` in most other languages. The method name is `at` and it accepts one
    argument, the index, and a keyword argument, `put`. Smalltalk arrays hold any
    object, as the remaining lines above demonstrate. Smalltalk indexes arrays from
    one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Smalltalk 使用 `:=` 来进行赋值，因此第一行声明 `x` 为一个包含五个元素的数组。Smalltalk 中的变量默认值为 `nil`。第二行的
    `x[0]=3` 在大多数其他语言中是相同的。方法名是 `at`，它接受一个参数，即索引，并有一个关键字参数 `put`。Smalltalk 数组可以存储任何对象，正如上面剩余的代码所示。Smalltalk
    数组的索引从 1 开始。
- en: 'It’s possible Smalltalk would win first prize for the longest method name in
    a standard library. Consider the following, which counts how many times a substring
    appears in another string:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Smalltalk 可能会赢得标准库中最长方法名称的第一奖。考虑以下代码，它用来计算一个子字符串在另一个字符串中出现的次数：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Graphical Smalltalk systems have a transcript window where messages are displayed.
    GNU Smalltalk uses this for normal output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图形化 Smalltalk 系统有一个转录窗口，消息会显示在其中。GNU Smalltalk 使用这个窗口来显示普通输出：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This little example illustrates several Smalltalk features. First, `Transcript`
    is the name of a class, so we’re using class-level methods, not instance methods.
    Second, Smalltalk uses a semicolon to call methods using the most recent class
    or object, which in this case is `Transcript`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例展示了几个 Smalltalk 特性。首先，`Transcript` 是一个类的名称，因此我们使用的是类级别的方法，而不是实例方法。其次，Smalltalk
    使用分号来调用当前类或对象的方法，在这个例子中就是 `Transcript`。
- en: '**Blocks**'
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**块**'
- en: An important concept in Smalltalk is the *block*, which is code between square
    brackets. Blocks are similar to unnamed functions, as they can be assigned to
    variables and later executed. They also form the body of Smalltalk’s control structures,
    which are nothing more than method calls on objects, like everything else in Smalltalk.
    Consider the following example.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Smalltalk 中的一个重要概念是 *块*（block），它是位于方括号之间的代码。块类似于无名函数，因为它们可以被赋值给变量并在之后执行。它们还构成了
    Smalltalk 控制结构的主体，这些控制结构不过是对对象的方法调用，就像 Smalltalk 中的其他一切一样。考虑以下示例。
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We define `b` to be a block. The block contains one statement to print a string.
    To execute the block, we call `value`, which prints the string. The second string
    in quotes is the value of the block, the last statement in it, which is the string
    here. In a running program, the second string would not be shown.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `b` 定义为一个块。块中包含一个打印字符串的语句。为了执行块，我们调用 `value`，它会打印该字符串。引号中的第二个字符串是块的值，即块中的最后一条语句，这里是字符串。在正在运行的程序中，第二个字符串不会显示出来。
- en: Blocks accept arguments and support local variables.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 块可以接受参数并支持局部变量。
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It’s important to understand this example. First, we have `x`, defined outside
    of a block and set to a string. Next, we define block `b`. It accepts an argument,
    `i` (the colon is necessary), and defines a local variable, `y`. Local variables
    are listed between vertical bars (pipes). The body of the block sets `y` to the
    argument, `i`, then uses `y` to assign to `x` and `z`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这个示例非常重要。首先，我们有 `x`，它在块外定义并被设置为一个字符串。接下来，我们定义了块 `b`。它接受一个参数 `i`（冒号是必须的），并定义了一个局部变量
    `y`。局部变量在竖线（管道符）之间列出。块的主体将 `y` 设置为参数 `i`，然后使用 `y` 为 `x` 和 `z` 赋值。
- en: 'The block is executed with 42 as the argument. Then we look at the value of
    `x`, `z`, and `y`. What happened? The block updated `x`, which already existed
    outside of the block. It also defined `z` *outside* the block. We didn’t declare
    `z` to be local to the block, so it was defined globally. We did declare `y` to
    be local to the block, so it has no value outside of the block, hence `nil`. The
    moral of the story is: if you want what happens in the block to stay in the block,
    only use local variables. As an exercise, try this example in Python, defining
    a function called `b(i)` in place of the block. Variables defined in the function
    do not alter variables defined globally unless you use `global` explicitly. Smalltalk
    blocks allow unintended consequences, so care is necessary.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块使用 42 作为参数被执行。然后我们查看 `x`、`z` 和 `y` 的值。发生了什么？块更新了 `x`，而 `x` 在块外已经存在。它还定义了
    `z` *在块外*。我们没有将 `z` 声明为块的局部变量，因此它被定义为全局变量。我们将 `y` 声明为块的局部变量，因此它在块外没有值，因此为 `nil`。这个故事的教训是：如果你希望块中的操作仅限于块内，应该只使用局部变量。作为练习，尝试在
    Python 中实现这个示例，定义一个名为 `b(i)` 的函数来代替块。函数中定义的变量不会修改全局定义的变量，除非你显式使用 `global`。Smalltalk
    块可能导致意外结果，因此需要小心使用。
- en: '**Control Structures**'
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**控制结构**'
- en: Smalltalk has the expected control structures, but their syntax is unusual because
    they are really methods. Let’s look quickly at conditional statements, `while`
    loops, and iterated loops. We can’t cover all combinations, especially with iteration,
    but you’ll get the gist of what’s going on.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Smalltalk具有预期的控制结构，但由于它们实际上是方法，因此它们的语法比较特殊。让我们快速看一下条件语句、`while`循环和迭代循环。我们无法涵盖所有组合，特别是在迭代方面，但你会大致了解发生了什么。
- en: 'Examine this short program:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个简短的程序：
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It asks the user for an integer by reading the next line from standard input
    and interpreting the resulting string as an integer before assigning it to `v`.
    Next, the code checks to see if `v` is less than 0, 0, or greater than 0 and sets
    the value of `a` accordingly.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过从标准输入读取下一行并将结果字符串解析为整数，然后将其赋值给`v`，来要求用户输入一个整数。接下来，代码检查`v`是否小于0、等于0或大于0，并相应地设置`a`的值。
- en: 'The code above looks like an `if-then-else` construct, and it acts like one,
    but it isn’t one. It’s normal Smalltalk <object> <method>: <argument> syntax.
    The `ifTrue` method is applied to the Boolean returned by `(v < 0)`. If the Boolean
    is true, execute the block that sets `a` to –1\. Similarly, `ifFalse` fires if
    the Boolean value is not true. Nesting within the block is perfectly fine, so
    the first `ifFalse` block has its own pair of `ifTrue` and `ifFalse` method calls.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '上面的代码看起来像一个`if-then-else`结构，实际上它也像一个，但它并不是一个。这是典型的Smalltalk语法`<object> <method>:
    <argument>`。`ifTrue`方法应用于`(v < 0)`返回的布尔值。如果布尔值为真，则执行将`a`设置为-1的块。同样，如果布尔值不为真，则会触发`ifFalse`。在块中嵌套是完全可以的，因此第一个`ifFalse`块有自己的`ifTrue`和`ifFalse`方法调用。'
- en: In Smalltalk, `while` loops act similarly. Consider
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在Smalltalk中，`while`循环的行为类似。考虑一下：
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: where, unlike `ifTrue`, `whileTrue` is applied to a block, `[i < 10]`. As expected,
    this code snippet displays the numbers 1 through 9\. The same output is generated
    by
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，不同于`ifTrue`，`whileTrue`应用于一个块`[i < 10]`。如预期的那样，这段代码会显示数字1到9。相同的输出也可以通过下面的代码实现：
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: which loops for as long as the code block returns `false`. Note that `while`
    loops are applied to a block, so the block need not be just a simple Boolean expression,
    but need only return a Boolean value. The following is a perfectly valid loop
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 它会在代码块返回`false`时继续循环。请注意，`while`循环应用于一个块，因此这个块不仅仅是一个简单的布尔表达式，而是只需要返回一个布尔值。以下是一个完全有效的循环：
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: with the side effect of defining `x` and setting it to 100.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 其副作用是定义`x`并将其设置为100。
- en: A basic `for` loop in Smalltalk is
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Smalltalk中的基本`for`循环是
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As with `if` and `while`, the loop isn’t a construct; it’s a message `to` sends
    to the integer object, 1\. The first part creates an `Interval` object, which
    is the entity that understands the `do` message. For example, the following code
    produces the same output as the previous.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 与`if`和`while`一样，循环不是一种结构；它是一个发送给整数对象1的消息`to`。第一部分创建一个`Interval`对象，这个对象理解`do`消息。例如，下面的代码产生与之前相同的输出。
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Notice that the argument to `do` is a block, with `i` being the argument that
    becomes the loop control variable. Therefore, we can do something like the following
    if we wish:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，传递给`do`的参数是一个块，其中`i`是变成循环控制变量的参数。因此，如果我们希望，可以像下面这样做：
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The first line defines `j` as an `Interval` object, the second defines `b` as
    a block (really a `BlockClosure` object), and the third uses `do` to apply the
    block to the interval.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义`j`为一个`Interval`对象，第二行定义`b`为一个块（实际上是一个`BlockClosure`对象），第三行使用`do`将块应用于该区间。
- en: We’ve hit the essentials of Smalltalk, though honestly we’ve barely put our
    little toe in the water. Smalltalk has a simple syntax and an extensive class
    library that we’ve ignored. However, we must press on. Smalltalk is all about
    objects and classes. Let’s see how by going to the races.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经触及到了Smalltalk的核心内容，虽然说实话我们几乎只是沾了点皮毛。Smalltalk具有简单的语法和丰富的类库，但我们忽略了这些。不过，我们必须继续前进。Smalltalk全都是关于对象和类的。让我们通过“赛马”来看看是如何运作的。
- en: '***Going to the Races***'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***赛马***'
- en: 'We’ll create a small class hierarchy and use it to race four animals against
    each other. Our plan is this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个小的类层次结构，并用它来让四个动物进行比赛。我们的计划是这样的：
- en: Define a base class, `Animal`, that responds to messages common to all the animals.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个基类`Animal`，该类响应所有动物共有的消息。
- en: 'Define four subclasses: `Bird`, `Wolf`, `Frog`, and `Snail`. The subclasses
    respond to messages based on how the animals move: `fly`, `run`, `hop`, and `crawl`,
    respectively. The class ignores messages that it doesn’t understand.'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义四个子类：`Bird`、`Wolf`、`Frog`和`Snail`。这些子类根据动物的移动方式响应消息：分别是`fly`、`run`、`hop`和`crawl`。该类会忽略它不理解的消息。
- en: Create an instance of each animal and send randomly selected messages to them.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建每个动物的实例，并向它们发送随机选择的消息。
- en: Display the distance each animal has moved and declare a winner.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示每个动物移动的距离，并宣布获胜者。
- en: The complete source code is in *race.st*. We’ll present it in pieces as we walk
    through it. Please read through the full source code file first before proceeding.
    If you do, the discussion will be easier to follow. Recall that the first line
    of the file is not standard Smalltalk; it’s Unix-speak to run the file as a script.
    The `-g` option disables the occasional garbage collection message.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码在*race.st*文件中。我们将分段展示源代码，逐步解析。请先通读完整的源代码文件再继续，这样讨论会更容易理解。记住，文件的第一行不是标准的Smalltalk代码，它是Unix命令，用于将文件作为脚本运行。`-g`选项禁用偶尔的垃圾回收消息。
- en: 'We begin with the base class, `Animal`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从基类`Animal`开始：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'All Smalltalk classes are subclasses of something. The top of the object hierarchy
    is the class `Object`, so `Animal` subclasses from it. There are three member
    variables: `increment`, `distance`, and `letter`. There are three methods: `init`,
    `getDistance`, and `print`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Smalltalk类都是某个类的子类。对象层次结构的顶部是`Object`类，因此`Animal`是从它继承的。该类有三个成员变量：`increment`（增量）、`distance`（距离）和`letter`（字母）。有三个方法：`init`、`getDistance`和`print`。
- en: The `init` method accepts `inc` as an argument along with `letter`, a keyword
    argument. In Smalltalk, instances of a class are usually created with `new` and
    initialized later; however, this process is flexible. We’ll call `init` to set
    up our class instances. In this case, initialization sets the distance traveled
    to zero, the letter associated with the animal when printing, and how far the
    animal moves each time it does move.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`方法接受`inc`作为参数，同时接受`letter`这个关键字参数。在Smalltalk中，类的实例通常通过`new`创建，初始化在后进行；然而，这个过程是灵活的。我们将调用`init`来设置类实例。在这个例子中，初始化将旅行的距离设置为零，设置打印时与动物相关的字母，以及每次动物移动的距离。'
- en: The next method is `getDistance`. It returns the current value of `distance`.
    Smalltalk does not have a return statement; rather, it precedes the value to return
    with a carat (`^`).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是`getDistance`。它返回当前的`distance`值。Smalltalk没有`return`语句；相反，它通过插入插入符号（`^`）来返回值。
- en: The final method, `print`, displays the animal’s distance traveled as a sequence
    of dashes ending with the animal’s letter. It uses `timesRepeat`, a message sent
    to an integer to repeat a code block a set number of times.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法`print`将显示动物的旅行距离，显示为一串破折号，最后是动物的字母。它使用`timesRepeat`，这是发送给整数的消息，用于重复执行代码块指定的次数。
- en: '`Animal` defines the base class. The specific animal classes come next:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`Animal`定义了基类，具体的动物类接下来会定义：'
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Each class defines `init`, which calls `init` of the superclass, `Animal`, passing
    in the increment and letter associated with the animal. For `Bird`, the increment
    is `6` and the letter is `'B'`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都定义了`init`，它调用了父类`Animal`的`init`，并传入与动物相关的增量和字母。对于`Bird`（鸟类）来说，增量是`6`，字母是`'B'`。
- en: Each subclass defines a method based on how the animal moves. For `Bird`, it’s
    `fly`. The move method adds the increment to the distance. The last method in
    each subclass is `doesNotUnderstand`. This method is called by Smalltalk when
    an object receives a message it has no method for. For example, if we pass the
    `fly` method to a `Wolf` object, `doesNotUnderstand` is be called. We want to
    ignore unknown messages, so the body of the method is empty.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子类根据动物如何移动来定义一个方法。对于`Bird`（鸟类）来说，就是`fly`。`move`方法将增量加到距离上。每个子类中的最后一个方法是`doesNotUnderstand`。当一个对象接收到它没有方法的消息时，Smalltalk会调用此方法。例如，如果我们将`fly`方法传递给`Wolf`（狼类）对象，`doesNotUnderstand`将被调用。我们希望忽略未知的消息，所以该方法的主体是空的。
- en: The classes are defined, but no instances have been created. Let’s create an
    instance of each and store the objects in an array.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 类已经定义，但尚未创建实例。让我们为每个类创建一个实例，并将对象存储在数组中。
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Each element of the array `animals` is set to the object returned by calling
    `new`. Doing this creates the objects, but they are not yet initialized. The final
    line loops over the array, calling each object’s `init` method.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 数组`animals`的每个元素都被设置为调用`new`返回的对象。这样创建了对象，但它们还没有初始化。最后一行遍历数组，调用每个对象的`init`方法。
- en: The animals are ready, so let’s run the race.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 动物们已经准备好了，让我们开始比赛吧。
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There are four movement methods: `fly`, `run`, `hop`, and `crawl`. We want
    to select one of them at random and send it to each animal. If the animal knows
    how to respond to the message, it does; otherwise, it quietly ignores it.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种移动方式：`fly`、`run`、`hop` 和 `crawl`。我们希望随机选择其中一种并发送给每个动物。如果动物知道如何响应该消息，它会做出回应；否则，它会默默忽略。
- en: 'First, `moves` is set to an array of the method names. This syntax is a shortcut
    for the `at:put:` syntax used above. The `timesRepeat` loop sets the number of
    moves that will happen. The interval, `(1 to: 4)`, is sent `atRandom` to return
    a random integer in [1,4]. This is the index in `moves` to set `m` to a randomly
    selected method string. The `do` loop sends the message in `m` to each animal
    by first converting the string to a symbol representing the method before passing
    it to the object itself via `perform`. Because each animal only responds to one
    of the move messages, only one animal will move during each pass through the `timesRepeat`
    loop.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，`moves` 被设置为方法名称的数组。这种语法是上面 `at:put:` 语法的简写。`timesRepeat` 循环设置将发生的移动次数。区间
    `(1 to: 4)` 被发送 `atRandom` 以返回 [1,4] 范围内的随机整数。这是 `moves` 中的索引，用于将 `m` 设置为随机选择的方法字符串。`do`
    循环通过先将字符串转换为表示方法的符号，再通过 `perform` 传递给对象本身来发送 `m` 中的消息。因为每个动物只响应一种移动消息，所以每次通过 `timesRepeat`
    循环时，只有一个动物会移动。'
- en: 'The race is now over. To see how the animals did, we use the code below to
    call the `print` method of each animal:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 比赛现在结束。为了查看动物们的表现，我们使用以下代码调用每个动物的 `print` 方法：
- en: '[PRE51]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To declare a winner, we need to find which of the four moved the farthest. For
    that, we’ll use a `Dictionary`,
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了宣告获胜者，我们需要找出四个动物中移动最远的。为此，我们将使用 `Dictionary`。
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: where the keys are the object instances and the values are the distance each
    animal moved. To declare a winner we find the maximum distance.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，键是对象实例，值是每个动物移动的距离。为了宣告获胜者，我们找到最大的移动距离。
- en: '[PRE53]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To loop over a dictionary, use `associationsDo`, which passes a key-value pair
    to the body of the loop. The `value` of the pair is the distance that animal traveled
    and the `key` is a reference to the object. The phrase `class displayString` converts
    the name of the object class to a string for display.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历字典，可以使用 `associationsDo`，它将一个键值对传递给循环体。该对的 `value` 是动物移动的距离，`key` 是对象的引用。短语
    `class displayString` 将对象类的名称转换为字符串以供显示。
- en: 'The output of *race.st* looks like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*race.st* 的输出结果如下：'
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The bird will win most often as it flies the farthest each time it moves. The
    wolf wins next most often and the snail least often. The file *run.py* runs 10,000
    races tracking how often each animal wins. For example, one run produced
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 鸟类将最常获胜，因为它每次移动时飞得最远。狼次之，蜗牛最少。文件 *run.py* 运行了 10,000 场比赛，跟踪每个动物获胜的次数。例如，一次运行的结果是
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The bird won nearly 64 percent of the races, followed by the wolf, who won 28
    percent. The poor snail only won about one race in two hundred.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 鸟类赢得了近 64% 的比赛，其次是狼，赢得了 28%。可怜的蜗牛每 200 场比赛只赢一次。
- en: '**Standard ML**'
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**标准 ML**'
- en: Our final language is *Standard ML* (SML), an early functional language based
    on ML. *Functional languages* use composition of functions—that is, functions
    applied to the output of other functions—to implement algorithms. We’ll get to
    what makes SML a functional language in a later chapter when discussing programming
    language paradigms.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终语言是 *标准 ML*（SML），一种基于 ML 的早期函数式语言。*函数式语言* 使用函数的组合——即将函数应用于其他函数的输出——来实现算法。我们将在后面的章节中讨论编程语言范式时介绍
    SML 是如何成为一种函数式语言的。
- en: The version of SML we’ll work with, SML-NJ (NJ stands for “New Jersey”) largely
    conforms to the language standard promulgated in 1997 (*[https://smlfamily.github.io/sml97-defn.pdf](https://smlfamily.github.io/sml97-defn.pdf)*).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的 SML 版本是 SML-NJ（NJ 代表“新泽西”），它基本上符合 1997 年发布的语言标准 (*[https://smlfamily.github.io/sml97-defn.pdf](https://smlfamily.github.io/sml97-defn.pdf)*).
- en: To follow along, install SML on Ubuntu using the command
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟着做，可以在 Ubuntu 上使用以下命令安装 SML。
- en: '[PRE56]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Versions for macOS and Windows are available at *[http://www.smlnj.org/dist/working/110.99/index.html](http://www.smlnj.org/dist/working/110.99/index.html)*.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: macOS 和 Windows 版本可以在 *[http://www.smlnj.org/dist/working/110.99/index.html](http://www.smlnj.org/dist/working/110.99/index.html)*
    下载。
- en: Run sml to start the interpreter. As with Smalltalk, use CTRL-D to exit.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 sml 启动解释器。像 Smalltalk 一样，使用 CTRL-D 退出。
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Ensure that the version number is at least that shown here. The interpreter
    is waiting for us to type something; try `"scary movie";`. The interpreter responds
    with
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 确保版本号至少是此处显示的版本。解释器在等待我们输入某些内容；尝试 `"scary movie";`。解释器回应：
- en: '[PRE58]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This tells us that `"scary movie"` is of type `string`. Moreover, the interpreter
    has defined the variable `it` and assigned the string to `it`. SML statements
    end with a semicolon and SML is a typed language; however, one of its strengths
    is that it infers types in most cases.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们 `"scary movie"` 是 `string` 类型。此外，解释器已经定义了变量 `it` 并将字符串赋值给 `it`。SML 语句以分号结尾，且
    SML 是强类型语言；然而，它的一个优势是，在大多数情况下，能够推断类型。
- en: 'One characteristic of functional languages like SML is *referential transparency*,
    meaning that a function returns the same value for the same input regardless of
    the state of the system as a whole. For example, consider the following Python
    session:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 SML 这样的函数式语言的一个特征是 *引用透明性*，意味着一个函数对于相同的输入总是返回相同的值，无论系统的整体状态如何。例如，考虑以下 Python
    会话：
- en: '[PRE59]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The value returned by `f(y)` depends on the current value of the variable `x`.
    Now consider the equivalent in SML.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`f(y)` 返回的值取决于变量 `x` 的当前值。现在考虑 SML 中的等价写法。'
- en: '[PRE60]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this case, the function uses the value of `x` as it was when the function
    was defined. Changing `x` later does not affect the function value. SML is referentially
    transparent, but Python is not. SML functions are defined with `fun`, followed
    by the function name and argument list in parentheses. At least they can be defined
    that way. We’ll encounter other ways below.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，函数使用的是定义时 `x` 的值。之后改变 `x` 不会影响函数的值。SML 是引用透明的，但 Python 不是。SML 函数是用 `fun`
    定义的，后跟函数名称和括号中的参数列表。至少可以这样定义。我们将在下面遇到其他定义方式。
- en: 'SML supports the common primitive data types: integers, reals, and strings.
    It also supports lists and tuples, along with more advanced user-defined data
    structures resembling classes. Every member of an SML list must be of the same
    data type. Tuples may mix data types; however, SML functions consider tuples to
    be a compound type rather than a collection of the same type.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: SML 支持常见的原始数据类型：整数、实数和字符串。它还支持列表和元组，以及更高级的用户定义数据结构，类似于类。每个 SML 列表中的成员必须是相同数据类型。元组可以混合数据类型；然而，SML
    函数认为元组是一种复合类型，而不是相同类型的集合。
- en: SML is perhaps the only language that requires you to write threatening code.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: SML 可能是唯一要求你编写威胁性代码的语言。
- en: '[PRE61]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: SML uses `orelse` where most other languages use `or`. So to check if one or
    the other conditional expression is true, you use `orelse`. Similarly, `andalso`
    replaces `and`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: SML 使用 `orelse`，而大多数其他语言使用 `or`。因此，要检查其中一个或另一个条件表达式是否为真，使用 `orelse`。类似地，`andalso`
    替代了 `and`。
- en: SML supports *unnamed functions*, or *lambda functions* as they are sometimes
    called. For example, the following code defines an unnamed function to add 1 to
    its argument and then immediately applies it to the number 11.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: SML 支持 *无名函数*，或称为 *lambda 函数*。例如，下面的代码定义了一个无名函数，将 1 加到其参数上，然后立即将其应用于数字 11。
- en: '[PRE62]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: SML treats functions as *first-class objects*. This means they can be assigned
    to variables and returned from functions. One use of this ability is to return
    a partially evaluated function in which some of the arguments are bound but others
    are not. This is known as *currying*, after Haskell Curry, an American mathematician
    who worked in logic. The Haskell programming language is named after him.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: SML 将函数视为 *一等公民*。这意味着它们可以赋值给变量并从函数中返回。此能力的一种应用是返回一个部分求值的函数，其中一些参数被绑定，另一些则未绑定。这被称为
    *柯里化*，以逻辑学家 Haskell Curry 的名字命名。Haskell 编程语言也以他命名。
- en: 'Before we see currying in action, consider the following two function definitions:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到柯里化（currying）如何工作的之前，先考虑以下两个函数定义：
- en: '[PRE63]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We define `add` twice with the second definition replacing the first. Both definitions
    take two arguments and add them together, so `add(11,22)` produces the same output
    as `add 11 22`. Look carefully at what SML returned after each function definition.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用第二个定义两次定义了 `add`，第二个定义替代了第一个定义。两个定义都接受两个参数并将它们相加，因此 `add(11,22)` 的输出与 `add
    11 22` 相同。仔细观察 SML 在每个函数定义后返回的内容。
- en: The first definition produced
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个定义产生了
- en: '[PRE64]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: which means that `add` is a function that accepts two integers and returns an
    integer. The second definition produced
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `add` 是一个接受两个整数并返回一个整数的函数。第二个定义产生了
- en: '[PRE65]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'meaning that `add` is now a function that accepts an integer and produces *a
    function* that accepts an integer and returns an integer. Defined in this form,
    `add` enables currying. Consider:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`add`现在是一个接受整数并返回*一个函数*的函数，这个返回的函数接受一个整数并返回一个整数。以这种形式定义，`add`支持柯里化。请考虑：
- en: '[PRE66]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We define `add` as above and apply it to 11 to return a function that we then
    apply to 22 to get 33.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如上所定义`add`，并将其应用于11，返回一个函数，然后再将该函数应用于22，得到33。
- en: Currying allows us to fix the first argument, the `x`, and bind the returned
    function, now expecting only the `y`, to a variable. The new function, `add11`,
    accepts an integer argument and returns that argument plus 11\. Lastly, we see
    that `add11` is indeed a function mapping an integer to an integer.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化允许我们固定第一个参数`x`，并将返回的函数（现在只期待`y`）绑定到一个变量上。这个新函数`add11`接受一个整数参数并返回该参数加上11。最后，我们看到`add11`确实是一个将整数映射到整数的函数。
- en: 'SML functions can use patterns, much like Prolog. For example, consider these
    definitions:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: SML函数可以使用模式，像Prolog一样。例如，考虑以下定义：
- en: '[PRE67]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This example is in the file *hello.sml*. You can load it with sml hello.sml
    or by entering use "hello.sml"; if you’re already in the interpreter. Either way,
    you’ll see SML’s output as to the functions and their types.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在文件*hello.sml*中。你可以通过`sml hello.sml`或在解释器中输入`use "hello.sml";`来加载它。不管哪种方式，你都能看到SML的输出，显示函数及其类型。
- en: '[PRE68]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The first function, `hello`, accepts no arguments and returns nothing. In SML,
    nothing is represented by `unit`. The `hello` function is used solely for its
    side effect of printing “Hello, world!” Therefore, `hello` accepts `unit` and
    returns `unit`. Both `greetA` and `greetB` accept an integer and return nothing,
    hence `unit`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`hello`不接受任何参数并且不返回任何值。在SML中，“无”被表示为`unit`。`hello`函数仅用于其副作用——打印“Hello,
    world!”因此，`hello`接受`unit`并返回`unit`。`greetA`和`greetB`都接受一个整数并且不返回任何值，因此返回值为`unit`。
- en: Look at the definition of `greetA`. It uses a recursive call to `greetA` to
    print “Hello, world!” repeatedly. If the argument is 1, call `hello` and return.
    Otherwise, call `hello` then call `greetA` again after subtracting 1 from the
    argument.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`greetA`的定义。它使用递归调用`greetA`来反复打印“Hello, world!”。如果参数是1，则调用`hello`并返回。否则，先调用`hello`，然后在将参数减1后再次调用`greetA`。
- en: Now look at `greetB`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看`greetB`。
- en: '[PRE69]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This function uses a pattern. The first pattern is `greetB 1`, meaning that
    if the argument is one, the pattern matches, so call `hello`. The pipe (`|`) marks
    the beginning of the next pattern. This pattern is checked if the previous pattern
    fails to match. Here, the pattern is any `n` that isn’t 1\. In that case, call
    `hello` and then call `greetB` again with `n-1`. This second pattern will repeatedly
    match until the first pattern matches. The first pattern returns nothing, so the
    return value of all recursive calls is nothing. This is why SML tells us that
    `greetB` maps an integer to `unit`. As an exercise, try implementing the recursive
    factorial function using a pattern.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用了模式。第一个模式是`greetB 1`，意思是如果参数是1，模式匹配成功，调用`hello`。管道符号（`|`）标记了下一个模式的开始。如果前一个模式匹配失败，就会检查这个模式。这里的模式是任何不等于1的`n`。在这种情况下，调用`hello`，然后再用`n-1`调用`greetB`。这个第二个模式会反复匹配，直到第一个模式匹配成功。第一个模式没有返回值，因此所有递归调用的返回值都是空的。这就是为什么SML告诉我们`greetB`将一个整数映射到`unit`。作为练习，试着使用模式实现递归的阶乘函数。
- en: 'The final piece of Standard ML we’ll consider is *higher-order functions*.
    Higher-order functions are functions that accept functions as arguments. The most
    common higher-order function is `map`, which applies a function to every element
    of a list. Consider these examples:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考虑的SML的最后一个概念是*高阶函数*。高阶函数是接受函数作为参数的函数。最常见的高阶函数是`map`，它将一个函数应用于列表的每个元素。考虑以下示例：
- en: '[PRE70]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The first two definitions use currying to define `add3`, a function that adds
    3 to its argument. The next line uses `map` to apply `add3` to each element of
    the list `[0,1,2,3,4]`, producing `[3,4,5,6,7]`. The final example applies an
    unnamed function to prefix a list of strings using `^` , which concatenates two
    strings.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个定义使用柯里化来定义`add3`，这是一个将3加到其参数上的函数。接下来的一行使用`map`将`add3`应用到列表`[0,1,2,3,4]`的每个元素上，产生`[3,4,5,6,7]`。最后一个例子应用一个匿名函数，使用`^`将字符串列表连接前缀，这个符号将两个字符串连接在一起。
- en: The function `map` is straightforward to understand. Let’s now look at two more
    higher-order functions supplied by SML. They go by the names `foldl` and `foldr`.
    Review the following and try to work out what they do.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`map`很容易理解。现在让我们来看两个SML提供的更高阶的函数，它们分别叫做`foldl`和`foldr`。请回顾以下内容，尝试推测它们的功能。
- en: '[PRE71]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The first line shows yet another way to define a function by assigning an unnamed
    function to a variable. The function `f` accepts two arguments and returns the
    first prepended by the second. Note the flip between `x` and `y`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行展示了通过将一个未命名函数赋值给一个变量来定义函数的另一种方法。函数`f`接受两个参数，并返回第二个参数附加到第一个参数前的结果。注意`x`和`y`之间的交换。
- en: 'The next line calls `foldr` with `f` and two arguments: the string `"a "` and
    a list of strings. The result is a string. The following statement uses `foldl`
    in place of `foldr`. It also produces a string, but the order of the strings in
    the list is reversed from the `foldr` example. Do you see the pattern?'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行调用`foldr`，并使用`f`和两个参数：字符串`"a "`和一个字符串列表。结果是一个字符串。接下来的语句使用`foldl`替换`foldr`。它同样产生一个字符串，但是字符串列表的顺序与`foldr`示例相反。你看到规律了吗？
- en: The `foldl` function traverses the list from left to right, so the `foldl` call
    is equivalent to
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`foldl`函数从左到右遍历列表，因此`foldl`调用等价于'
- en: '[PRE72]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: whereas `foldr` traverses from right to left
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 而`foldr`从右向左遍历
- en: '[PRE73]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The fold higher-order functions are useful numerically as well.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶折叠函数在数值上也非常有用。
- en: '[PRE74]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The notation `op+` refers to the binary addition operator, so the first line
    sums a list of integers. Likewise, `op*` is multiplication, meaning the second
    line calculates the product of a list of integers.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 符号`op+`指的是二元加法运算符，因此第一行对整数列表求和。同样，`op*`是乘法，所以第二行计算整数列表的乘积。
- en: There is much more to Standard ML, including an extensive library of data types.
    However, we’ve reviewed enough to get a feel for the language.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Standard ML 还有很多内容，包括广泛的数据类型库。然而，我们已经回顾了足够多的内容，以了解这种语言的特性。
- en: '**Summary**'
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we compared programming languages to paleontology, a metaphor
    we’ll return to throughout the book. Then, we briefly explored 10 programming
    languages to understand how they approach the idea of coding. The selected languages
    either introduced fundamental concepts or programming paradigms, like object-oriented
    programming, or were novel simply because they were first. In some cases, the
    language was foundational to a collection of future languages, like ALGOL. Reviewing
    what was and is helps us see where we might go and puts us in a frame of mind
    conducive to what esolangs have to offer.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编程语言比作古生物学，这是本书中我们将一再回到的隐喻。然后，我们简要探讨了10种编程语言，以了解它们如何处理编码的概念。所选语言要么引入了基本概念或编程范式，如面向对象编程，要么仅仅因为它们是第一种而显得新颖。在某些情况下，这种语言对未来语言集合具有基础性作用，比如ALGOL。回顾过去和现在帮助我们看到可能的发展方向，并让我们进入有利于esolangs提供的框架思维状态。
- en: The vignettes in this chapter are superficial, but necessarily so. Let’s step
    back a bit now and consider what it means to be a programming language, to grasp
    at their essence.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的插图是肤浅的，但必要的。现在让我们稍作停顿，考虑一下什么是编程语言，以及把握它们本质的含义。
