- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">OTHER
    ACCESS CHECKING USE CASES</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">其他访问检查使用案例</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: Access checks determine what access a caller should have when opening a kernel
    resource. However, we sometimes perform them for other reasons, as they can serve
    as additional security checks. This chapter details some examples of using access
    checks as a secondary security mechanism.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 访问检查决定了调用者在打开内核资源时应具有的访问权限。然而，我们有时出于其他原因进行这些检查，因为它们可以作为额外的安全检查。本章详细介绍了将访问检查作为二级安全机制的一些示例。
- en: We’ll start by looking at traversal checking, which determines whether a caller
    has access to a hierarchy of resources. Next, we’ll discuss how access checks
    are used when a handle is duplicated. We’ll also consider how an access check
    can limit access to kernel information, such as process listings, from sandboxed
    applications. Finally, I’ll describe some additional PowerShell commands that
    automate the access checking of resources.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从遍历检查开始，遍历检查决定了调用者是否有权访问一组资源。接下来，我们将讨论在句柄被复制时访问检查的使用。我们还将考虑访问检查如何限制沙箱应用程序访问内核信息，如进程列表。最后，我将介绍一些额外的PowerShell命令，它们可以自动化资源的访问检查。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Traversal Checking</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">遍历检查</samp>
- en: When accessing a hierarchical set of resources, such as an object directory
    tree, the user must traverse the hierarchy until they reach the target resource.
    For every directory or container in the hierarchy, the system performs an access
    check to determine whether the caller can proceed to the next container. This
    check is called a *traversal check*, and it’s performed whenever code looks up
    a path inside the I/O manager or object manager. For example, [Figure 8-1](chapter8.xhtml#fig8-1)
    shows the traversal checks needed to access an OMNS object using the path *ABC\QRS\XYZ\OBJ*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问一组层次化的资源时，例如一个对象目录树，用户必须遍历该层次结构，直到他们到达目标资源。对于层次结构中的每个目录或容器，系统都会执行一个访问检查，以确定调用者是否可以继续访问下一个容器。这个检查被称为*遍历检查*，每当代码在I/O管理器或对象管理器中查找路径时，都会执行此检查。例如，[图
    8-1](chapter8.xhtml#fig8-1)显示了使用路径*ABC\QRS\XYZ\OBJ*访问OMNS对象所需的遍历检查。
- en: '![](../images/Figure8-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: Traversal checks
    required to access</samp> <samp class="SANS_Futura_Std_Book_11">OBJ</samp>'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-1：访问</samp> <samp class="SANS_Futura_Std_Book_11">OBJ</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">所需的遍历检查</samp>
- en: As you can see, three access checks must be performed before we can access *OBJ*.
    Each access check extracts the security descriptor from the container and then
    checks the type-specific access to see if traversal is allowed. Both the OMNS
    and file directories can grant or deny <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp>
    access. If, for example, *QRS* denied <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp>
    access to the caller, the traversal check would fail, as shown in [Figure 8-2](chapter8.xhtml#fig8-2).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在我们能够访问*OBJ*之前，必须执行三个访问检查。每个访问检查从容器中提取安全描述符，然后检查特定类型的访问权限，看看是否允许遍历。OMNS和文件目录都可以授予或拒绝
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp> 访问权限。例如，如果*QRS*拒绝调用者的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp> 访问权限，则遍历检查将失败，如[图
    8-2](chapter8.xhtml#fig8-2)所示。
- en: '![](../images/Figure8-2.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: Traversal checks
    blocked at</samp> <samp class="SANS_Futura_Std_Book_11">QRS</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-2：遍历检查在</samp> <samp class="SANS_Futura_Std_Book_11">QRS</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">处被阻止</samp>
- en: Even if the caller would pass the access checks for *XYZ* and *OBJ*, because
    *QRS* now denies access via the traversal check, it’s no longer possible for them
    to access *OBJ* using the *ABC\QRS\XYZ\OBJ* path.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 即使调用者能够通过*XYZ*和*OBJ*的访问检查，因为*QRS*现在通过遍历检查拒绝了访问，因此他们无法再使用*ABC\QRS\XYZ\OBJ*路径访问*OBJ*。
- en: The traversal check prevents a user from accessing their resources if any parent
    container denies <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp>
    access. This is unexpected behavior—why shouldn’t a user be able to access their
    own resources? It also introduces a performance concern. If a user must have access
    to every parent container to access their files, then the kernel must expend time
    and effort performing an access check for each container, when all that matters
    security-wise is whether the user has access to the resource they want to open.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历检查会阻止用户访问其资源，如果任何父容器拒绝了<samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp>访问权限。这是意料之外的行为——为什么用户不能访问自己的资源呢？它还带来了性能问题。如果用户必须对每个父容器都有访问权限才能访问文件，那么内核就必须花费时间和精力对每个容器执行访问检查，而安全上真正关心的只是用户是否有权访问他们想要打开的资源。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The SeChangeNotifyPrivilege
    Privilege</samp>
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">SeChangeNotifyPrivilege
    权限</samp>
- en: To make the traversal check behavior closer to how you might expect it to work
    and reduce the performance impact, the SRM defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    privilege, which almost every <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object has enabled by default. When this privilege is enabled, the system bypasses
    the entire traversal check and lets users access resources that an inaccessible
    parent would otherwise block. In [Listing 8-1](chapter8.xhtml#Lis8-1), we verify
    the privilege’s behavior using OMNS directory objects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使遍历检查行为更符合预期并减少性能影响，SRM定义了<samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>权限，几乎每个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象默认都会启用。当此权限启用时，系统会绕过整个遍历检查，并允许用户访问父容器无法访问的资源。在[清单8-1](chapter8.xhtml#Lis8-1)中，我们使用OMNS目录对象验证该权限的行为。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 8-1: Testing SeChangeNotifyPrivilege to bypass traversal checks'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 清单8-1：测试SeChangeNotifyPrivilege以绕过遍历检查
- en: We first create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object and all its parent directories, automating the directory creation by using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDirectories</samp> property
    ❶. We ensure the privilege is enabled ❷ and then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtObject</samp>
    command to check whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object can be opened. In the output, we can see we’re able to open the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>对象及其所有父目录，通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateDirectories</samp>属性自动化目录创建 ❶。我们确保权限已启用
    ❷，然后使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtObject</samp>命令检查是否可以打开<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>对象。在输出中，我们可以看到能够打开<samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>对象。
- en: We then set a security descriptor with an empty DACL on the *QRS* directory
    ❸. This should block all access to the directory object, including <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp>
    access. But when we check our access again, we see that we can still access the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object because we
    have the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    privilege enabled ❹.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为*QRS*目录设置了一个空的DACL ❸。这应该会阻止对该目录对象的所有访问，包括<samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp>访问。但是当我们再次检查访问权限时，我们发现仍然可以访问<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>对象，因为我们启用了<samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>权限
    ❹。
- en: We now disable the privilege and try again to open the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object ❺. This time, the directory traversal fails. Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    privilege or access to the *QRS* directory, we can no longer open the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object. However, our final check demonstrates that if we have access to a parent
    after *QRS*, such as *XYZ*, we can access the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object via a relative open by using the directory as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Root</samp>
    parameter ❻.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在禁用该特权，并尝试再次打开<samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>对象❺。这次，目录遍历失败。如果没有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>特权或无法访问*QRS*目录，我们将无法再打开<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>对象。然而，我们的最终检查表明，如果我们可以访问*QRS*之后的父目录，例如*XYZ*，我们仍然可以通过相对打开，使用目录作为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Root</samp>参数❻来访问<samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>对象。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Limited Checks</samp>
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">有限检查</samp>
- en: The kernel contains an additional performance improvement for traversal checks.
    If the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    privilege is disabled, the kernel will call the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeFastTraverseCheck</samp>
    function, which performs a more limited check instead of a full access check.
    For completeness, I have reimplemented the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeFastTraverseCheck</samp>
    function in PowerShell so that we can explore its behavior in more detail. [Listing
    8-2](chapter8.xhtml#Lis8-2) shows the implementation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 内核包含一个额外的性能提升，用于遍历检查。如果<samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>特权被禁用，内核将调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeFastTraverseCheck</samp>函数，该函数执行更有限的检查，而不是完整的访问检查。为完整性起见，我已在PowerShell中重新实现了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeFastTraverseCheck</samp>函数，以便我们可以更详细地探索其行为。[Listing
    8-2](chapter8.xhtml#Lis8-2)展示了其实现。
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 8-2: A PowerShell implementation of SeFastTraverseCheck'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-2: SeFastTraverseCheck的PowerShell实现'
- en: 'First, we define the three parameters the function takes: the token’s flags,
    a directory object’s security descriptor, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp>
    access rights to check ❶. We specify the access rights because the object manager
    and the I/O manager use this function for <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> objects, and the
    value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp> access
    right differs between the two object types; specifying the access as a parameter
    allows the check function to handle both cases.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义函数所需的三个参数：令牌的标志、目录对象的安全描述符和需要检查的<samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp>访问权限❶。我们指定访问权限，因为对象管理器和I/O管理器使用该函数处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>对象，并且<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp>访问权限在这两种对象类型之间有所不同；将访问权限作为参数指定，可以使检查函数同时处理这两种情况。
- en: Next, we check whether the security descriptor’s DACL is NULL, granting access
    if it is ❷. We follow this with a check on two token flags ❸. If the flags indicate
    that the token is filtered or restricted, then the fast check fails. The kernel
    copies these flags from the caller’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object. We can get the flags from user mode using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp>
    property on a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object,
    as shown in [Listing 8-3](chapter8.xhtml#Lis8-3).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查安全描述符的DACL是否为NULL，如果是，则授予访问权限❷。然后，我们检查两个令牌标志❸。如果标志表明令牌被过滤或限制，则快速检查失败。内核从调用者的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象复制这些标志。我们可以通过用户模式中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>对象的<samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp>属性获取这些标志，如[Listing
    8-3](chapter8.xhtml#Lis8-3)所示。
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 8-3: Querying token flags'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-3: 查询令牌标志'
- en: Notice that the flags include <samp class="SANS_TheSansMonoCd_W5Regular_11">IsFiltered</samp>.
    If you’re not running in a restricted token sandbox, why would this flag be set?
    Querying the token elevation type shows that it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Limited</samp>,
    which means it’s the default token for a UAC administrator. To convert the full
    administrator token to the default token, LSASS uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>
    system, which will set the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsFiltered</samp>
    flag but not <samp class="SANS_TheSansMonoCd_W5Regular_11">IsRestricted</samp>,
    as it’s only removing groups, not adding restricted SIDs. This means that while
    a UAC admin running code as the default user can never pass the fast traversal
    check, a normal user could. This behavior doesn’t have any security implication,
    but it does mean that if <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    is disabled, resource lookup performance will suffer.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，标志包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">IsFiltered</samp>。如果你不是在受限的令牌沙盒中运行，为什么会设置这个标志呢？查询令牌的提升类型显示它是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Limited</samp>，这意味着它是UAC管理员的默认令牌。为了将完整的管理员令牌转换为默认令牌，LSASS
    使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp> 系统，它会设置
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IsFiltered</samp> 标志，但不会设置 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IsRestricted</samp>，因为它只是在移除组，而不是添加受限
    SID。这意味着，虽然以默认用户身份运行代码的 UAC 管理员永远无法通过快速遍历检查，但普通用户是可以通过的。这个行为没有任何安全隐患，但意味着如果禁用了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>，资源查找性能将受到影响。
- en: The final check in [Listing 8-3](chapter8.xhtml#Lis8-3) consists of enumerating
    the DACL’s ACEs. If the ACE is inherit-only or doesn’t contain the required <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp> access mask, it’s skipped
    ❹. If it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp> ACE,
    the fast traverse check fails ❺, and the ACE’s SID is not checked at all. Finally,
    if the ACE is an <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp>
    ACE and the SID equals the *Everyone* group’s SID, the fast check succeeds ❻.
    If there are no more ACEs, the check fails ❼.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-3](chapter8.xhtml#Lis8-3) 中的最终检查包括枚举 DACL 的 ACE。如果 ACE 仅继承或不包含所需的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp> 访问掩码，它将被跳过 ❹。如果它是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp> ACE，快速遍历检查将失败 ❺，并且该 ACE
    的 SID 完全不被检查。最后，如果 ACE 是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp>
    ACE 且 SID 等于 *Everyone* 组的 SID，则快速检查成功 ❻。如果没有更多的 ACE，检查将失败 ❼。'
- en: Note that this fast check doesn’t consider whether the caller’s token has the
    *Everyone* group enabled. This is because typically the only way to remove the
    *Everyone* group would be to filter the token. The big exception to this is the
    anonymous token, which doesn’t have any groups but is also not filtered in any
    way.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个快速检查并不考虑调用者的令牌是否启用了 *Everyone* 组。这是因为通常唯一移除 *Everyone* 组的方法是过滤令牌。这个规则的一个大例外是匿名令牌，它没有任何组，但也没有以任何方式被过滤。
- en: 'Now let’s turn to another use for the access check: considering the granted
    access when assigning a duplicated handle.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看访问检查的另一个用途：在分配复制句柄时考虑授予的访问权限。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Handle Duplication Access Checks</samp>
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">处理句柄重复访问检查</samp>
- en: The system always performs an access check when creating or opening a kernel
    resource that returns a handle. But what about when that handle is duplicated?
    In the simplest case, when the new handle has the same granted access mask as
    the original one, the system won’t perform any checks. It’s also possible to drop
    some parts of the granted access mask, and doing so won’t trigger an additional
    access check either. However, if you want to add additional access rights to the
    duplicated handle, the kernel will query the security descriptor from the object
    and perform a new access check to determine whether to allow the access.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 系统在创建或打开返回句柄的内核资源时总是执行访问检查。但是，如果该句柄被复制呢？在最简单的情况下，当新句柄的授予访问掩码与原始句柄相同，系统将不会执行任何检查。也可以删除授予访问掩码的某些部分，执行此操作也不会触发额外的访问检查。然而，如果你想为复制的句柄添加额外的访问权限，内核将从对象中查询安全描述符，并执行新的访问检查，以确定是否允许访问。
- en: When you duplicate a handle, you must specify both the source and destination
    process handles, and the access check occurs in the context of the destination
    process. This means the access check considers the destination process’s primary
    token, not the source process’s, which could be an issue if a privileged process
    tried to duplicate a handle to a less privileged process with additional access.
    Such an operation would fail with <samp class="SANS_TheSansMonoCd_W5Regular_11">Access
    Denied</samp>.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你复制一个句柄时，必须同时指定源进程句柄和目标进程句柄，访问检查会在目标进程的上下文中进行。这意味着访问检查会考虑目标进程的主令牌，而不是源进程的主令牌，如果一个具有特权的进程试图将句柄复制到具有额外访问权限的低特权进程，这可能会成为一个问题。此类操作会因<samp
    class="SANS_TheSansMonoCd_W5Regular_11">访问被拒绝</samp>而失败。
- en: '[Listing 8-4](chapter8.xhtml#Lis8-4) demonstrates this handle duplication access
    check behavior.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-4](chapter8.xhtml#Lis8-4)演示了此句柄复制访问检查行为。'
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 8-4: Testing the handle duplication access check behavior'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-4：测试句柄复制访问检查行为
- en: We first create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object with an empty DACL and request only <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> access on
    the handle ❶. This will block all users from accessing the object, except for
    the owner, who can be granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> access thanks
    to the owner check described in the previous chapter. We test the duplication
    by requesting the same access, which the new handle returns ❷.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的<samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>对象，并且设置一个空的DACL，且仅请求对句柄
    ❶ 的<samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>访问权限。这将阻止所有用户访问该对象，只有所有者可以获得<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>权限，这是通过上一章中描述的所有者检查来实现的。我们通过请求相同的访问权限来测试句柄复制，新的句柄返回
    ❷。
- en: Next, we request <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>
    access only ❸. As the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>’s
    DACL is empty, this access right wouldn’t be granted during an access check, and
    because we get <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>
    on the new handle, we know that no access check took place. Finally, we try to
    increase our access by requesting <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>
    access ❹. An access check must now take place, as we’re requesting greater access
    rights than the handle currently has. This check results in an <samp class="SANS_TheSansMonoCd_W5Regular_11">Access
    Denied</samp> error.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们仅请求<samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>访问权限
    ❸。由于<samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>的DACL为空，因此在访问检查时不会授予此访问权限，而由于我们在新句柄上获得了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>权限，我们知道没有进行访问检查。最后，我们尝试通过请求<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>访问权限来增加我们的访问权限 ❹。现在必须进行访问检查，因为我们请求的权限大于句柄当前的权限。此检查将导致<samp
    class="SANS_TheSansMonoCd_W5Regular_11">访问被拒绝</samp>错误。
- en: If we hadn’t set a security descriptor when creating the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>,
    there would be no security associated with the object, and this last check would
    have succeeded, granting <samp class="SANS_TheSansMonoCd_W5Regular_11">Full Access</samp>.
    As mentioned in [Chapter 2](chapter2.xhtml), you need to be careful when duplicating
    unnamed handles to less privileged processes if you’re dropping access; the destination
    process might be able to reduplicate the handle to one with more access. In [Listing
    8-5](chapter8.xhtml#Lis8-5), we test the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateObject
    NoRightsUpgrade</samp> flag to see how it affects handle duplication access checking.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在创建<samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>时没有设置安全描述符，那么该对象将没有关联的安全性，最后的检查将会成功，并授予<samp
    class="SANS_TheSansMonoCd_W5Regular_11">完全访问</samp>权限。如[第 2 章](chapter2.xhtml)所述，当将未命名的句柄复制到低特权进程时需要小心，如果你正在降低访问权限；目标进程可能能够将句柄重新复制为一个具有更多权限的句柄。在[列表
    8-5](chapter8.xhtml#Lis8-5)中，我们测试了<samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateObject
    NoRightsUpgrade</samp>标志，看看它如何影响句柄复制访问检查。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 8-5: Testing the NtDuplicateObject NoRightsUpgrade flag'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-5：测试 NtDuplicateObject NoRightsUpgrade 标志
- en: We start by creating an unnamed <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object, which will have no associated security descriptor. We request the initial
    handle with <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp> access
    only. However, our attempt to duplicate a new handle with <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>
    access succeeds, granting us complete access.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个无名的<samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>对象，它将没有关联的安全描述符。我们仅请求具有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>访问权限的初始句柄。然而，我们尝试用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>访问权限复制一个新句柄，结果成功了，这使我们获得了完全的访问权限。
- en: Now we test the <samp class="SANS_TheSansMonoCd_W5Regular_11">NoRightsUpgrade</samp>
    flag. Because we don’t specify any access mask, the handle will be duplicated
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp> access.
    With the new handle, we then perform another duplication, this time requesting
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> access. We can
    observe that the handle duplication fails. This isn’t due to an access check;
    instead, it’s because of a flag set on the handle entry in the kernel indicating
    that any request for more access should fail immediately. This prevents the handle
    from being used to gain additional access rights.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们测试<samp class="SANS_TheSansMonoCd_W5Regular_11">NoRightsUpgrade</samp>标志。因为我们没有指定任何访问掩码，句柄将会使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>访问权限被复制。使用新句柄后，我们再进行一次复制，这次请求<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>访问权限。我们可以观察到句柄复制失败。这不是由于访问检查，而是因为内核中设置了一个标志，指示任何对更多访问的请求应该立即失败。这防止了该句柄被用来获得额外的访问权限。
- en: The incorrect handling of duplicate handles can lead to vulnerabilities; for
    example, CVE-2019-0943, an issue I discovered in a privileged service responsible
    for caching the details of font files on Windows. The service duplicated a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object handle to a sandbox
    process with read-only access. However, the sandbox process could convert the
    handle back to a writable section handle, and the section could be mapped into
    memory as writable. This allowed the sandbox process to modify the state of the
    privileged service and escape the sandbox. Windows fixed the vulnerability by
    duplicating the handle using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NoRightsUpgrade</samp>
    flag.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 错误地处理重复的句柄可能会导致漏洞；例如，CVE-2019-0943，这是我在一个负责缓存 Windows 上字体文件详细信息的特权服务中发现的一个问题。该服务将一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象句柄复制到了一个具有只读访问权限的沙箱进程中。然而，沙箱进程可以将该句柄转换回可写的节句柄，并且该节可以被映射到内存中作为可写。这使得沙箱进程能够修改特权服务的状态并突破沙箱。Windows通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NoRightsUpgrade</samp>标志来修复这个漏洞。
- en: The access checks that occur during traversal checking and handle duplication
    are typically hidden from view, but both relate to the security of an individual
    resource. Next, we’ll discuss how access checks limit the information we can extract
    and the operations we can perform for a group of resources. These restrictions
    occur based on the caller’s token, regardless of the individual access set for
    those resources.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历检查和句柄复制过程中发生的访问检查通常是隐藏的，但两者都与单个资源的安全性有关。接下来，我们将讨论访问检查如何限制我们可以提取的信息以及可以执行的操作，这些限制是基于调用者的令牌，而不管这些资源的单独访问设置。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Sandbox Token Checks</samp>
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">沙箱令牌检查</samp>
- en: Beginning in Windows 8, Microsoft has tried to make it harder to compromise
    the system by escaping sandbox token restrictions. This is especially important
    for software such as web browsers and document readers, which process untrusted
    content from the internet.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Windows 8 开始，微软尝试通过防止沙箱令牌限制逃逸，来使得攻击系统变得更加困难。这对于处理来自互联网的不可信内容的软件尤为重要，比如网页浏览器和文档阅读器。
- en: 'The kernel implements two APIs that use an access check to determine whether
    the caller is in a sandbox: <samp class="SANS_TheSansMonoCd_W5Regular_11">ExIsRestrictedCaller</samp>,
    introduced in Windows 8, and <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlIsSandboxToken</samp>,
    introduced in Windows 10\. These APIs produce equivalent results; the difference
    between them is that <samp class="SANS_TheSansMonoCd_W5Regular_11">ExIsRestrictedCaller</samp>
    checks the token of the caller, while <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlIsSandboxToken</samp>
    checks a specified <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object that doesn’t have to be the caller’s.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 内核实现了两个使用访问检查来确定调用者是否在沙箱中的 API：<samp class="SANS_TheSansMonoCd_W5Regular_11">ExIsRestrictedCaller</samp>（引入于
    Windows 8）和 <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlIsSandboxToken</samp>（引入于
    Windows 10）。这两个 API 产生等效的结果；它们之间的区别在于，<samp class="SANS_TheSansMonoCd_W5Regular_11">ExIsRestrictedCaller</samp>
    检查的是调用者的令牌，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlIsSandboxToken</samp>
    检查的是指定的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> 对象，这个对象不一定是调用者的。
- en: Internally, these APIs perform an access check for the token and grant access
    only if the token is not in a sandbox. [Listing 8-6](chapter8.xhtml#Lis8-6) shows
    a reimplementation of this access check in PowerShell.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，这些 API 会对令牌执行访问检查，并且仅在令牌不在沙箱中时才授予访问权限。[列表 8-6](chapter8.xhtml#Lis8-6) 展示了在
    PowerShell 中重新实现此访问检查的方法。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 8-6: An access check for a sandbox token'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-6：沙箱令牌的访问检查
- en: First, we need to define a dummy kernel object type using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtType</samp>
    command. This allows us to specify the generic mapping for the access check. We
    specify only the <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> values, as
    write and execute access are not important in this context. Note that the new
    type is local to PowerShell; the kernel doesn’t know anything about it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtType</samp> 命令定义一个虚拟内核对象类型。这允许我们为访问检查指定通用映射。我们只指定
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>
    值，因为在这个上下文中，写入和执行权限并不重要。请注意，这种新类型是 PowerShell 本地的；内核对它一无所知。
- en: We then define a security descriptor with a NULL DACL and the owner and group
    SIDs set to the *SYSTEM* user. The use of a NULL DACL will deny access to lowbox
    tokens, as described in the previous chapter, but not to any other sandbox token
    type, such as restricted tokens.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义了一个具有 NULL DACL（访问控制列表）的安全描述符，并将所有者和组 SID 设置为*SYSTEM*用户。使用 NULL DACL 会拒绝低权限令牌的访问，如前一章所述，但不会拒绝其他类型的沙箱令牌，如受限令牌。
- en: To handle other token types, we add a <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    mandatory label ACE with a <samp class="SANS_TheSansMonoCd_W5Regular_11">NoReadUp</samp>
    policy. As a result, any token with an integrity level lower than <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    will be denied access to the mask specified in the generic mapping’s <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    field. Lowbox tokens ignore the <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    mandatory label, but we’ve covered these tokens using the NULL DACL. Note that
    this security descriptor doesn’t consider restricted tokens with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    integrity level to be sandbox tokens. It’s not clear if this is an intentional
    oversight or a bug in the implementation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理其他令牌类型，我们添加了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    强制标签 ACE，政策为 <samp class="SANS_TheSansMonoCd_W5Regular_11">NoReadUp</samp>。因此，任何低于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> 完整性级别的令牌将被拒绝访问通用映射的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> 字段中指定的掩码。低权限令牌会忽略
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> 强制标签，但我们已经使用 NULL
    DACL 覆盖了这些令牌。请注意，这个安全描述符并不认为完整性级别为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    的受限令牌是沙箱令牌。目前尚不清楚这是故意的疏忽，还是实现中的一个 bug。
- en: We can now perform an access check with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    command, using the current, non-sandboxed token. The access check succeeds, granting
    us <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> access. If
    we repeat the check with a token that has a <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>
    integrity level, the system denies us access, indicating that the token is sandboxed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`Get-NtGrantedAccess`命令，在当前非沙箱令牌下执行访问检查。访问检查成功，授予我们`GenericRead`访问权限。如果我们使用一个具有`Low`完整性级别的令牌重复检查，系统会拒绝我们访问，表明该令牌处于沙箱中。
- en: Behind the scenes, the kernel APIs call the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp>
    API, which will return an error if the caller has an Identification-level impersonation
    token. Therefore, the kernel will consider some impersonation tokens to be sandboxed
    even if the implementation in [Listing 8-6](chapter8.xhtml#Lis8-6) would indicate
    otherwise.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，内核API调用`SeAccessCheck` API，如果调用者拥有标识级别的模拟令牌，API将返回错误。因此，内核会认为某些模拟令牌处于沙箱中，即使[列表
    8-6](chapter8.xhtml#Lis8-6)中的实现表明相反。
- en: 'When either API indicates that the caller is sandboxed, the kernel changes
    its behavior to do the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何一个API指示调用者处于沙箱中时，内核会改变其行为，执行以下操作：
- en: List only processes and threads that can be directly accessed.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅列出可以直接访问的进程和线程。
- en: Block access to loaded kernel modules.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻止访问已加载的内核模块。
- en: Enumerate open handles and their kernel object addresses.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举打开的句柄及其内核对象地址。
- en: Create arbitrary file and object manager symbolic links.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建任意的文件和对象管理符号链接。
- en: Create a new restricted token with more access.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个具有更多访问权限的新受限令牌。
- en: For example, in [Listing 8-7](chapter8.xhtml#Lis8-7), we query for handles while
    impersonating a <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> integrity
    level token and are denied access.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[列表 8-7](chapter8.xhtml#Lis8-7)中，我们在模拟低完整性级别令牌时查询句柄并被拒绝访问。
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 8-7: Querying for handle information while impersonating a Low integrity
    level token'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-7：在模拟低完整性级别令牌时查询句柄信息
- en: While only kernel-mode code can access <samp class="SANS_TheSansMonoCd_W5Regular_11">ExIsRestrictedCaller</samp>,
    you can access <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlIsSandboxToken</samp>
    in user mode, as it’s also exported in *NTDLL*. This allows you to query the kernel
    using a token handle to find out whether the kernel thinks it is a sandbox token.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlIsSandboxToken</samp> API
    exposes its result in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">IsSandbox</samp> property,
    as shown in [Listing 8-8](chapter8.xhtml#Lis8-8).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然只有内核模式代码可以访问`ExIsRestrictedCaller`，但你可以在用户模式下访问`RtlIsSandboxToken`，因为它也在*NTDLL*中导出。这使得你可以使用令牌句柄查询内核，以了解内核是否认为它是一个沙箱令牌。`RtlIsSandboxToken`
    API将其结果暴露在`Token`对象的`IsSandbox`属性中，如[列表 8-8](chapter8.xhtml#Lis8-8)所示。
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 8-8: Checking the sandbox status of tokens'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-8：检查令牌的沙箱状态
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> object returned
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp> has an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IsSandboxToken</samp> property. Internally,
    this property opens the process’s token and calls <samp class="SANS_TheSansMonoCd_W5Regular_11">IsSandbox</samp>.
    We can use this property to easily discover which processes are sandboxed, by
    using the script in [Listing 8-9](chapter8.xhtml#Lis8-9), for example.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由`Get-NtProcess`返回的`Process`对象具有`IsSandboxToken`属性。内部上，该属性会打开进程的令牌并调用`IsSandbox`。我们可以通过使用[列表
    8-9](chapter8.xhtml#Lis8-9)中的脚本轻松发现哪些进程处于沙箱中。
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 8-9: Enumerating all sandboxed processes for the current user'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-9：枚举当前用户的所有沙箱进程
- en: These sandbox checks are an important feature for limiting information disclosure
    and restricting dangerous functionality such as symbolic links, which improve
    an attacker’s chances of escaping the sandbox and gaining additional privileges.
    For example, blocking access to the handle table prevents the disclosure of kernel
    object addresses that could be used to exploit kernel memory corruption vulnerabilities.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些沙盒检查是限制信息泄露和限制危险功能（如符号链接）的重要功能，符号链接能够增加攻击者逃脱沙盒并获取额外权限的机会。例如，阻止访问句柄表可以防止泄露内核对象地址，这些地址可能被用来利用内核内存损坏漏洞。
- en: We’ve now covered three uses of the access check for purposes not related to
    opening a resource. We’ll finish this chapter by describing some commands that
    simplify access checking over a range of individual resources.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了访问检查的三种用途，这些用途与打开资源无关。我们将通过描述一些简化对一系列个体资源进行访问检查的命令来结束本章。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Automating Access Checks</samp>
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">自动化访问检查</samp>
- en: The previous chapter provided a worked example that used <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    to determine the granted access for a collection of kernel objects. If you want
    to check a different type of resource, such as files, you’ll need to modify that
    script to use file commands.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章提供了一个示例，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    来确定一组内核对象的授予访问权限。如果你想检查不同类型的资源，比如文件，你需要修改脚本以使用文件命令。
- en: Because checking for the granted access across a range of resources is such
    a useful operation, the PowerShell module comes with several commands to automate
    the process. The commands are designed to allow you to quickly assess the security
    attack surface of available resources on a Windows system. They all start with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Accessible</samp>, and you can
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Command</samp> to list them,
    as shown in [Listing 8-10](chapter8.xhtml#Lis8-10).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因为跨多个资源检查授予访问权限是一个非常有用的操作，所以 PowerShell 模块提供了几个命令来自动化此过程。这些命令旨在帮助你快速评估 Windows
    系统上可用资源的安全攻击面。它们的命令名都以 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Accessible</samp>
    开头，你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Command</samp> 来列出它们，如
    [列表 8-10](chapter8.xhtml#Lis8-10) 所示。
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 8-10: Listing the Get-Accessible* commands'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-10：列出 Get-Accessible* 命令
- en: We’ll come back to some of these commands in later chapters. Here, we’ll focus
    on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>
    command, which we can use to automate access checking over the entire OMNS. The
    command lets you specify an OMNS path to check, then enumerates the OMNS and reports
    either the maximum granted access or whether a specific access mask can be granted.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中回到其中一些命令。这里，我们将重点介绍 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>
    命令，使用该命令可以自动化对整个 OMNS 的访问检查。该命令允许你指定要检查的 OMNS 路径，然后枚举 OMNS 并报告最大授予访问权限或是否可以授予特定的访问掩码。
- en: 'You can also specify what tokens to use for the access check. The command can
    source tokens from the following list:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以指定用于访问检查的令牌。命令可以从以下列表中获取令牌：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> objects
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> 对象
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> objects
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> 对象
- en: Process names
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理进程名称
- en: Process IDs
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理进程 ID
- en: Process command lines
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理命令行
- en: If you specify no options when running the command, it will use the current
    primary token. It will then enumerate all objects based on an OMNS path and perform
    an access check for every token specified. If the access check succeeds, then
    the command generates a structured object containing the details of the result.
    [Listing 8-11](chapter8.xhtml#Lis8-11) shows an example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行命令时没有指定选项，它将使用当前的主令牌。然后，它会基于 OMNS 路径枚举所有对象，并对每个指定的令牌执行访问检查。如果访问检查成功，命令将生成一个包含结果详细信息的结构化对象。[列表
    8-11](chapter8.xhtml#Lis8-11) 显示了一个示例。
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 8-11: Getting accessible objects from the OMNS root'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-11：从 OMNS 根目录获取可访问对象
- en: 'Here, we run the command against the root of the OMNS, and we receive three
    columns in the output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们对 OMNS 的根目录执行命令，并在输出中接收三列数据：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">TokenId  </samp>The unique identifier
    of the token used for the access check
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">TokenId  </samp>用于访问检查的令牌的唯一标识符
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Access  </samp>The granted access,
    mapped to generic access rights
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">访问</samp> 授予的访问权限，映射到通用访问权限
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Name  </samp>The name of the checked
    resource
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">名称</samp> 被检查资源的名称
- en: We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">TokenId</samp>
    to distinguish the results for the different tokens specified to the command.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">TokenId</samp>` 来区分为命令指定的不同令牌的结果。
- en: This output is only a subset of the result produced by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>
    command. You can extract the rest of the information using commands like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp>. You can also display
    the copy of the security descriptor used to perform the access check with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtSecurityDescriptor</samp>
    PowerShell command, as shown in [Listing 8-12](chapter8.xhtml#Lis8-12).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出只是由 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>`
    命令生成的结果的一个子集。你可以使用像 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp>`
    这样的命令提取其余的信息。你还可以使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtSecurityDescriptor</samp>`
    PowerShell 命令显示用于执行访问检查的安全描述符副本，如 [Listing 8-12](chapter8.xhtml#Lis8-12) 所示。
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 8-12: Displaying the security descriptor used for the access check'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-12: 显示用于访问检查的安全描述符'
- en: As we’ve run the command against a directory here, you might wonder if it will
    also list the objects contained within the directory. By default, no; the command
    opens the path as an object and does an access check. If you want to recursively
    check all objects in the directory, you need to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Recurse</samp>
    parameter. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>
    command also accepts a <samp class="SANS_TheSansMonoCd_W5Regular_11">Depth</samp>
    parameter you can use to specify the maximum recursive depth. If you run a recursive
    check as a non-administrator user, you might see a lot of warnings, as in [Listing
    8-13](chapter8.xhtml#Lis8-13).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里对一个目录执行了命令，你可能会想知道它是否也会列出目录中的对象。默认情况下，不会；该命令将路径作为对象打开并进行访问检查。如果你想递归检查目录中的所有对象，你需要指定
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">Recurse</samp>` 参数。`<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>`
    命令还接受一个 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Depth</samp>` 参数，你可以使用它来指定最大递归深度。如果你以非管理员用户身份运行递归检查，你可能会看到很多警告，如
    [Listing 8-13](chapter8.xhtml#Lis8-13) 所示。
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 8-13: Warnings when recursively enumerating objects'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-13: 递归枚举对象时的警告'
- en: You can turn off the warnings by setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">WarningAction</samp>
    parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">Ignore</samp>, but
    keep in mind that they’re trying to tell you something. For the command to work,
    it needs to open each object and query its security descriptor. From user mode,
    this requires passing the access check during the opening; if you don’t have permission
    to open an object for <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    access, the command can’t perform an access check. For better results, you can
    run the command as an administrator, and for the best results, run it as the *SYSTEM*
    user by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Win32ChildProcess</samp>
    command to start a *SYSTEM* PowerShell shell.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将 `<samp class="SANS_TheSansMonoCd_W5Regular_11">WarningAction</samp>`
    参数设置为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Ignore</samp>` 来关闭警告，但请记住，它们是想告诉你一些事情。为了让命令工作，它需要打开每个对象并查询其安全描述符。从用户模式运行时，这需要在打开时通过访问检查；如果你没有权限以
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>` 访问对象，则命令无法执行访问检查。为了获得更好的结果，你可以以管理员身份运行该命令，或者为了最好的结果，通过使用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Win32ChildProcess</samp>`
    命令以 *SYSTEM* 用户身份启动一个 *SYSTEM* PowerShell shell。
- en: 'By default, the command will perform the access check using the caller’s token.
    But if you’re running the command as an administrator, you probably won’t want
    this behavior, as almost all resources will allow administrators full access.
    Instead, consider specifying arbitrary tokens to check against the resource. For
    example, when run as a UAC administrator, the following command recursively opens
    the resources using the administrator token but performs the access check with
    the non-administrator token from the Explorer process:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，命令将使用调用者的令牌执行访问检查。但如果你以管理员身份运行命令，你可能不希望这样做，因为几乎所有资源都会允许管理员完全访问。相反，考虑指定任意令牌来检查资源。例如，当作为UAC管理员运行时，以下命令使用管理员令牌递归地打开资源，但使用Explorer进程中的非管理员令牌执行访问检查：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It’s common to want to filter the list of objects to check. You could run the
    access check against all the objects and then filter the list afterward, but this
    would require a lot of work that you’ll then just throw away. To save you some
    time, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>
    command supports multiple filter parameters:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望筛选检查的对象列表。你可以对所有对象执行访问检查，然后在之后进行筛选，但这会要求你做很多工作，而这些工作最终可能都被丢弃。为了节省时间，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>命令支持多个筛选器参数：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">TypeFilter  </samp>A list of NT
    type names to check
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">类型筛选器  </samp>用于检查的NT类型名称列表
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Filter  </samp>A name filter used
    to restrict which objects are opened; can contain wildcards
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">筛选器  </samp>用于限制打开哪些对象的名称过滤器；可以包含通配符
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Include  </samp>A name filter used
    to determine which results to include in the output
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">包含  </samp>用于确定哪些结果应包含在输出中的名称过滤器
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Exclude  </samp>A name filter used
    to determine which results to exclude from the output
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">排除  </samp>用于确定哪些结果应从输出中排除的名称过滤器
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Access  </samp>An access mask used
    to limit the output to only objects with specific granted access
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">访问  </samp>用于限制输出为仅包含具有特定授予访问权限的对象的访问掩码
- en: 'For example, the following command will find all the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    objects that can be opened with <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>
    access:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下命令将找到所有可以使用<sup class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</sup>访问权限打开的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Mutant</sup>对象：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By default, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp>
    parameter requires that all access be granted before outputting a result. You
    can modify this by specifying <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowPartialAccess</samp>,
    which will output any result that partially matches the specified access. If you
    want to see all results regardless of the granted access, specify <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowEmptyAccess</samp>.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，<samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp>参数要求在输出结果之前授予所有访问权限。你可以通过指定<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AllowPartialAccess</samp>来修改这一点，这样将输出与指定访问部分匹配的任何结果。如果你希望查看所有结果，而不管授予的访问权限，指定<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AllowEmptyAccess</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">示例演示</samp>
- en: Let’s wrap up with some worked examples that use the commands you’ve learned
    about in this chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些使用你在本章中学到的命令的示例来总结一下。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Simplifying an Access
    Check for an Object</samp>
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">简化对象的访问检查</samp>
- en: In the previous chapter, we used the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    command to automate an access check against kernel objects and determine their
    maximum granted access. To accomplish this, we first needed to query for an object’s
    security descriptor. We then passed this value to the command along with the type
    of kernel object to check.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>命令自动对内核对象进行访问检查，并确定它们的最大授予访问权限。为了实现这一点，我们首先需要查询对象的安全描述符。然后，我们将此值与要检查的内核对象类型一起传递给命令。
- en: If you have a handle to an object, you can simplify the call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    command by specifying the object with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp>
    parameter, as shown in [Listing 8-14](chapter8.xhtml#Lis8-14).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有一个对象的句柄，可以通过使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp>参数简化对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>命令的调用，具体如[列表
    8-14](chapter8.xhtml#Lis8-14)所示。
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 8-14: Running an access check on an object'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-14：对对象执行访问检查
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp> parameter
    eliminates the need to manually extract the security descriptor from the object
    and will automatically select the correct generic mapping structure for the kernel
    object type. This reduces the risk that you’ll make mistakes when performing an
    object access check.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp>参数消除了手动提取对象安全描述符的需要，并会自动为内核对象类型选择正确的通用映射结构。这降低了你在执行对象访问检查时犯错的风险。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Writable
    Section Objects</samp>
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">查找可写的 Section 对象</samp>
- en: The system uses <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    objects to share memory between processes. If a privileged process sets a weak
    security descriptor, it might be possible for a less privileged process to open
    and modify the contents of the section. This can lead to security issues if that
    section contains trusted parameters that can trick the privileged process into
    performing privileged operations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 系统使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象在进程之间共享内存。如果一个特权进程设置了弱安全描述符，可能会导致权限较低的进程打开并修改该部分的内容。如果该部分包含可以诱使特权进程执行特权操作的可信参数，这可能会引发安全问题。
- en: I identified a vulnerability of this class, CVE-2014-6349, in Internet Explorer’s
    sandbox configuration. The configuration incorrectly secured a shared <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object, allowing sandboxed Internet Explorer processes to open it and disable
    the sandbox entirely. I discovered this issue by performing an access check for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> access on all named
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> objects. Once I had
    identified all sections with this access right, I manually determined whether
    any of them were exploitable from the sandbox. In [Listing 8-15](chapter8.xhtml#Lis8-15),
    we automate the discovery of writable sections using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>
    command.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 Internet Explorer 的沙箱配置中发现了这个类的漏洞，CVE-2014-6349。该配置错误地保护了一个共享的<samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象，允许沙箱内的
    Internet Explorer 进程打开它并完全禁用沙箱。我通过对所有命名的<samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象执行对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>访问的访问检查，发现了这个问题。一旦我确定了所有具有此访问权限的部分，我会手动确定它们是否可以从沙箱中被利用。在[列表
    8-15](chapter8.xhtml#Lis8-15)中，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>命令自动发现可写的部分。
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 8-15: Enumerating writable Section objects for a Low integrity level
    token'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-15：枚举低完整性级别令牌可写的 Section 对象
- en: We start by calculating the access mask for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>
    access and converting it into a generic access enumeration ❶. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>
    command takes only generic access, as it doesn’t know ahead of time what objects
    you’re likely to want to check for. We then duplicate the current user’s token
    and set its integrity level to <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>,
    producing a simple sandbox ❷.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算<samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>访问的访问掩码，并将其转换为通用访问枚举
    ❶。<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>命令只接受通用访问，因为它无法预先知道你可能要检查哪些对象。然后我们复制当前用户的令牌，并将其完整性级别设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>，从而产生一个简单的沙箱 ❷。
- en: We pass the token and access mask to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>,
    performing a recursive check in the user’s *BaseNamedObjects* directory by specifying
    a single path separator to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp>
    parameter ❸. The results returned from the command should contain only sections
    that can be opened for <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>
    access.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将令牌和访问掩码传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>，通过指定单一的路径分隔符给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp>参数❸，在用户的*BaseNamedObjects*目录中执行递归检查。命令返回的结果应仅包含可以打开以进行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>访问的部分。
- en: Finally, we enumerate the list of discovered sections, displaying their names
    and the initial contents of any discovered writable <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object ❹. We open each named section, map up to the first 4,096 bytes into memory,
    and then output the contents as a hex dump. We map the section as writable, as
    it’s possible the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object’s security descriptor grants <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>
    access but that the section was created read-only. In this case, mapping <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp> will fail with an error.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们列出了已发现的各个部分，显示它们的名称和任何已发现的可写<samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象的初始内容❹。我们打开每个命名的部分，将最多4,096字节映射到内存中，然后将内容输出为十六进制转储。我们将该部分映射为可写，因为可能<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>对象的安全描述符授予了<samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>访问权限，但该部分是以只读方式创建的。在这种情况下，映射<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>将会因错误而失败。
- en: You can use this script as is to find noteworthy writable sections. You don’t
    have to use a sandbox token; it can be interesting to see the sections available
    for a normal user that are owned by privileged processes. You can also use this
    as a template for performing the same check for any other kernel object type.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接使用这个脚本来查找值得注意的可写部分。你不需要使用沙箱令牌；查看由特权进程拥有并且对普通用户可用的部分也是很有趣的。你还可以使用它作为模板，对任何其他内核对象类型执行相同的检查。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, we looked at some examples of the uses of access checking outside
    of opening a resource. We first considered traversal checks, which are used to
    determine if a user can traverse a hierarchical list of containers, such as object
    directories. Then we discussed how access checks are used when handles are duplicated
    between processes, including how this can create security issues if the object
    has no name or security descriptor configured.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们查看了访问检查在打开资源之外的应用示例。我们首先考虑了遍历检查，用于确定用户是否能够遍历容器的层次列表，例如对象目录。然后我们讨论了在进程之间复制句柄时，访问检查如何被使用，包括在对象没有名称或安全描述符时，这可能会导致安全问题。
- en: Next, we explored how an access check can be used to determine if a caller’s
    token is sandboxed. The kernel does this to limit access to information or certain
    operations, to make it more difficult to exploit specific classes of security
    vulnerabilities. Finally, we saw how to automate access checks for various resource
    types with <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Accessible</samp>
    commands. We looked at the basic parameters common to all commands and how to
    use them to enumerate accessible named kernel objects.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了如何使用访问检查来确定调用者的令牌是否被沙箱化。内核通过这样做来限制对信息或某些操作的访问，从而使利用特定类别的安全漏洞变得更加困难。最后，我们了解了如何通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-Accessible</samp>命令自动执行对各种资源类型的访问检查。我们查看了所有命令的基本参数，以及如何使用它们列举可访问的命名内核对象。
- en: 'That’s the end of our examination of the access check process. In the next
    chapter, we’ll cover the last remaining responsibility of the SRM: security auditing.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对访问检查过程的全部分析。在下一章中，我们将讨论SRM的最后一个责任：安全审计。
