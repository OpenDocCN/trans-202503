- en: Chapter 23. Timers and Sleeping
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第23章 定时器和睡眠
- en: 'A timer allows a process to schedule a notification for itself to occur at
    some time in the future. Sleeping allows a process (or thread) to suspend execution
    for a period of time. This chapter describes the interfaces used for setting timers
    and for sleeping. It covers the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器允许进程安排在未来某个时间发生的通知。睡眠允许进程（或线程）暂停执行一段时间。本章描述了用于设置定时器和睡眠的接口。它包括以下主题：
- en: the classical UNIX APIs for setting interval timers (*setitimer()* and *alarm()*)
    to notify a process when a certain amount of time has passed;
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于设置间隔定时器的经典UNIX API（*setitimer()*和*alarm()*），用于在指定时间过后通知进程；
- en: the APIs that allow a process to sleep for a specified interval;
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许进程在指定间隔内休眠的API；
- en: the POSIX.1b clocks and timers APIs; and
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX.1b时钟和定时器API；以及
- en: the Linux-specific *timerfd* facility, which allows the creation of timers whose
    expirations can be read from a file descriptor.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux特有的*timerfd*设施，允许创建定时器，其到期可以从文件描述符读取。
- en: Interval Timers
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 间隔定时器
- en: The *setitimer()* system call establishes an *interval timer*, which is a timer
    that expires at a future point in time and (optionally) at regular intervals after
    that.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*setitimer()*系统调用建立一个*interval timer*，即一个在未来某个时刻到期，并（可选）在此后定期到期的定时器。'
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: 'Using *setitimer()*, a process can establish three different types of timers,
    by specifying *which* as one of the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*setitimer()*，进程可以通过将*which*指定为以下之一来建立三种不同类型的定时器：
- en: '`ITIMER_REAL`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`ITIMER_REAL`'
- en: Create a timer that counts down in real (i.e., wall clock) time. When the timer
    expires, a `SIGALRM` signal is generated for the process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个以实时时间（即墙钟时间）倒计时的定时器。当定时器到期时，会为进程生成一个`SIGALRM`信号。
- en: '`ITIMER_VIRTUAL`'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`ITIMER_VIRTUAL`'
- en: Create a timer that counts down in process virtual time (i.e., user-mode CPU
    time). When the timer expires, a `SIGVTALRM` signal is generated for the process.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个以进程虚拟时间（即用户模式CPU时间）倒计时的定时器。当定时器到期时，会为进程生成一个`SIGVTALRM`信号。
- en: '`ITIMER_PROF`'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`ITIMER_PROF`'
- en: Create a *profiling* timer. A profiling timer counts in process time (i.e.,
    the sum of both user-mode and kernel-mode CPU time). When the timer expires, a
    `SIGPROF` signal is generated for the process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个*profiling*定时器。一个profiling定时器以进程时间（即用户模式和内核模式的CPU时间之和）倒计时。当定时器到期时，会为进程生成一个`SIGPROF`信号。
- en: The default disposition of all of the timer signals is to terminate the process.
    Unless this is the desired result, we must establish a handler for the signal
    delivered by the timer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有定时器信号的默认处置是终止进程。除非这是期望的结果，否则我们必须为定时器发送的信号建立一个处理程序。
- en: 'The *new_value* and *old_value* arguments are pointers to *itimerval* structures,
    defined as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*new_value*和*old_value*参数是指向*itimerval*结构的指针，定义如下：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each of the fields in the *itimerval* structure is in turn a structure of type
    *timeval*, containing seconds and microseconds fields:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*itimerval*结构中的每个字段又是一个*timeval*类型的结构，包含秒和微秒字段：'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The *it_value* substructure of the *new_value* argument specifies the delay
    until the timer is to expire. The *it_interval* substructure specifies whether
    this is to be a periodic timer. If both fields of *it_interval* are set to 0,
    then the timer expires just once, at the time given by *it_value*. If one or both
    of the *it_interval* fields are nonzero, then, after each expiration of the timer,
    the timer will be reset to expire again at the specified interval.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*it_value*子结构的*new_value*参数指定定时器到期的延迟时间。*it_interval*子结构指定这是否是一个周期性定时器。如果*it_interval*的两个字段都设置为0，那么定时器只会到期一次，在*it_value*指定的时间到期。如果*it_interval*的一个或两个字段为非零，则每次定时器到期后，定时器会重置，并在指定的时间间隔后再次到期。'
- en: A process has only one of each of the three types of timers. If we call *setitimer()*
    a second time, it will change the characteristics of any existing timer corresponding
    to *which*. If we call *setitimer()* with both fields of *new_value.it_value*
    set to 0, then any existing timer is disabled.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程只能有三种定时器中的一种。如果我们第二次调用*setitimer()*，它将改变与*which*对应的任何现有定时器的特性。如果我们调用*setitimer()*时，*new_value.it_value*的两个字段都设置为0，那么任何现有定时器将被禁用。
- en: If *old_value* is not `NULL`, then it points to an *itimerval* structure that
    is used to return the previous value of the timer. If both fields of *old_value.it_value*
    are 0, then the timer was previously disabled. If both fields of *old_value.it_interval*
    are 0, then the previous timer was set to expire just once, at the time given
    by *old_value.it_value*. Retrieving the previous settings of the timer can be
    useful if we want to restore the settings after the new timer has expired. If
    we are not interested in the previous value of the timer, we can specify *old_value*
    as `NULL`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*old_value*不是`NULL`，则它指向一个*itimerval*结构，用于返回定时器的上一个值。如果*old_value.it_value*的两个字段都为0，则定时器之前已被禁用。如果*old_value.it_interval*的两个字段都为0，则之前的定时器设置为仅在*old_value.it_value*指定的时间到达时过期一次。检索定时器的先前设置在我们希望在新定时器过期后恢复设置时非常有用。如果我们不关心定时器的先前值，可以将*old_value*指定为`NULL`。
- en: As a timer progresses, it counts down from the initial value (*it_value*) toward
    0\. When the timer reaches 0, the corresponding signal is sent to the process,
    and then, if the interval (*it_interval*) is nonzero, the timer value (*it_value*)
    is reloaded, and counting down toward 0 recommences.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着定时器的推进，它会从初始值(*it_value*)倒计时直到0。当定时器达到0时，相应的信号会发送到进程，然后，如果间隔(*it_interval*)非零，定时器值(*it_value*)会重新加载，并重新开始倒计时直到0。
- en: At any time, we can use *getitimer()* to retrieve the current state of the timer
    in order to see how much time is left before it next expires.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，我们都可以使用*getitimer()*来检索定时器的当前状态，以查看距离下次过期还剩多少时间。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 成功返回0，出错返回-1
- en: The *getitimer()* system call returns the current state of the timer specified
    by *which*, in the buffer pointed to by *curr_value*. This is exactly the same
    information as is returned via the *old_value* argument of *setitimer()*, with
    the difference that we don’t need to change the timer settings in order to retrieve
    the information. The *curr_value.it_value* substructure returns the amount of
    time remaining until the timer next expires. This value changes as the timer counts
    down, and is reset on timer expiration if a nonzero *it_interval* value was specified
    when the timer was set. The *curr_value.it_interval* substructure returns the
    interval for this timer; this value remains unchanged until a subsequent call
    to *setitimer()*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*getitimer()*系统调用返回由*which*指定的定时器的当前状态，存储在*curr_value*指向的缓冲区中。这与通过*setitimer()*的*old_value*参数返回的信息完全相同，区别在于我们无需更改定时器设置就可以检索信息。*curr_value.it_value*子结构返回定时器下次过期前剩余的时间。随着定时器倒计时，这个值会发生变化，如果在设置定时器时指定了非零的*it_interval*值，当定时器过期时该值会被重置。*curr_value.it_interval*子结构返回此定时器的间隔；此值保持不变，直到后续调用*setitimer()*。'
- en: Timers established using *setitimer()* (and *alarm()*, which we discuss shortly)
    are preserved across *exec()*, but are not inherited by a child created by *fork()*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*setitimer()*（以及稍后讨论的*alarm()*）建立的定时器在*exec()*调用后会被保留，但不会被*fork()*创建的子进程继承。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv4 marks *getitimer()* and *setitimer()* obsolete, noting that the POSIX
    timers API ([POSIX Interval Timers](ch23.html#posix_interval_timers "POSIX Interval
    Timers")) is preferred.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv4标记*getitimer()*和*setitimer()*为过时，指出首选使用POSIX定时器API（[POSIX间隔定时器](ch23.html#posix_interval_timers
    "POSIX Interval Timers")）。
- en: Example program
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 23-1](ch23.html#using_a_real-time_timer "Example 23-1. Using a real-time
    timer") demonstrates the use of *setitimer()* and *getitimer()*. This program
    performs the following steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 23-1](ch23.html#using_a_real-time_timer "示例 23-1. 使用实时定时器")演示了*setitimer()*和*getitimer()*的使用。该程序执行以下步骤：'
- en: Establish a handler for the `SIGALRM` signal ![](figs/web/U003.png).
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`SIGALRM`信号建立处理程序 ![](figs/web/U003.png)。
- en: Set the value and interval fields for a real (`ITIMER_REAL`) timer using the
    values supplied in its command-line arguments ![](figs/web/U004.png). If these
    arguments are absent, the program sets a timer that expires just once, after 2
    seconds.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行参数中提供的值设置一个实时（`ITIMER_REAL`）定时器的值和间隔字段 ![](figs/web/U004.png)。如果这些参数缺失，程序将设置一个仅在2秒后过期一次的定时器。
- en: Execute a continuous loop ![](figs/web/U005.png), consuming CPU time and periodically
    calling the function *displayTimes()* ![](figs/web/U001.png), which displays the
    elapsed real time since the program began, as well as the current state of the
    `ITIMER_REAL` timer.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个连续的循环 ![](figs/web/U005.png)，消耗CPU时间，并定期调用函数*displayTimes()* ![](figs/web/U001.png)，该函数显示程序开始以来的经过实际时间以及当前`ITIMER_REAL`定时器的状态。
- en: Each time the timer expires, the `SIGALRM` handler is invoked, and it sets a
    global flag, *gotAlarm* ![](figs/web/U002.png). Whenever this flag is set, the
    loop in the main program calls *displayTimes()* in order to show when the handler
    was called and the state of the timer ![](figs/web/U006.png). (We designed the
    signal handler in this manner to avoid calling non-async-signal-functions from
    within the handler, for the reasons described in [Reentrant and Async-Signal-Safe
    Functions](ch21.html#reentrant_and_async-signal-safe_function "Reentrant and Async-Signal-Safe
    Functions").) If the timer has a zero interval, then the program exits on delivery
    of the first signal; otherwise, it catches up to three signals before terminating
    ![](figs/web/U007.png).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每次定时器到期时，`SIGALRM` 处理程序会被调用，并设置一个全局标志 *gotAlarm* ![](figs/web/U002.png)。每当此标志被设置时，主程序中的循环会调用
    *displayTimes()* 以显示处理程序何时被调用以及定时器的状态 ![](figs/web/U006.png)。 （我们设计信号处理程序时这样做是为了避免在处理程序中调用非异步信号安全函数，原因请参见
    [可重入与异步信号安全函数](ch21.html#reentrant_and_async-signal-safe_function "可重入与异步信号安全函数")）。如果定时器的间隔为零，则程序在收到第一个信号时退出；否则，它会在终止之前捕获最多三个信号
    ![](figs/web/U007.png)。
- en: 'When we run the program in [Example 23-1](ch23.html#using_a_real-time_timer
    "Example 23-1. Using a real-time timer"), we see the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 [示例 23-1](ch23.html#using_a_real-time_timer "示例 23-1. 使用实时定时器") 中的程序时，我们会看到以下内容：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Example 23-1. Using a real-time timer
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 23-1. 使用实时定时器
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A simpler timer interface: *alarm()*'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个更简单的定时器接口：*alarm()*
- en: The *alarm()* system call provides a simple interface for establishing a real-time
    timer that expires once, with no repeating interval. (Historically, *alarm()*
    was the original UNIX API for setting a timer.)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*alarm()* 系统调用提供了一个简单的接口，用于建立一个只会到期一次、不重复的实时定时器。（历史上，*alarm()* 是 UNIX 原始的定时器设置
    API。）'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Always succeeds, returning number of seconds remaining on any previously set
    timer, or 0 if no timer previously was set
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 总是成功，返回任何先前设置的定时器剩余的秒数，如果没有设置定时器则返回 0
- en: The *seconds* argument specifies the number of seconds in the future when the
    timer is to expire. At that time, a `SIGALRM` signal is delivered to the calling
    process.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*seconds* 参数指定定时器到期的未来秒数。在那个时间点，`SIGALRM` 信号会被发送给调用进程。'
- en: Setting a timer with *alarm()* overrides any previously set timer. We can disable
    an existing timer using the call *alarm(0)*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *alarm()* 设置定时器会覆盖任何之前设置的定时器。我们可以通过调用 *alarm(0)* 来禁用现有的定时器。
- en: As its return value, *alarm()* gives us the number of seconds remaining until
    the expiration of any previously set timer, or 0 if no timer was set.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*alarm()* 的返回值给出我们任何先前设置的定时器到期前剩余的秒数，如果没有设置定时器，则返回 0。'
- en: An example of the use of *alarm()* is shown in Section 23.3.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 23.3 节中展示了使用 *alarm()* 的一个示例。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In some later example programs in this book, we use *alarm()* to start a timer
    without establishing a corresponding `SIGALRM` handler, as a technique for ensuring
    that a process is killed if it is not otherwise terminated.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的某些后续示例程序中，我们使用 *alarm()* 启动定时器，而不设置相应的 `SIGALRM` 处理程序，这是一种确保进程被终止的技术，前提是进程没有被其他方式终止。
- en: Interactions between *setitimer()* and *alarm()*
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*setitimer()* 和 *alarm()* 之间的交互'
- en: 'On Linux, *alarm()* and *setitimer()* share the same per-process real-time
    timer, which means that setting a timer with one of these functions changes any
    timer previously set by either of the functions. This may not be the case on other
    UNIX implementations (i.e., these functions could control independent timers).
    SUSv3 explicitly leaves unspecified the interactions between *setitimer()* and
    *alarm()*, as well as the interactions of these functions with the *sleep()* function
    described in [Low-Resolution Sleeping: *sleep()*](ch23.html#low-resolution_sleeping_colon_sleep_open
    "Low-Resolution Sleeping: sleep()"). For maximum portability, we should ensure
    that our applications use only one of *setitimer()* and *alarm()* for setting
    real-time timers.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，*alarm()* 和 *setitimer()* 共享同一个每进程的实时定时器，这意味着使用这些函数之一设置定时器会改变之前由任何一个函数设置的定时器。在其他
    UNIX 实现中可能并非如此（即，这些函数可能控制独立的定时器）。SUSv3 明确没有指定 *setitimer()* 和 *alarm()* 之间的交互，以及这些函数与
    [低分辨率睡眠：*sleep()*](ch23.html#low-resolution_sleeping_colon_sleep_open "低分辨率睡眠：sleep()")
    函数之间的交互。为了最大限度地提高可移植性，我们应确保我们的应用程序仅使用 *setitimer()* 或 *alarm()* 中的一个来设置实时定时器。
- en: Scheduling and Accuracy of Timers
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定时器的调度和准确性
- en: Depending on system load and the scheduling of processes, a process may not
    be scheduled to run until some short time (i.e., usually some small fraction of
    a second) after actual expiration of the timer. Notwithstanding this, the expiration
    of a periodic timer established by *setitimer()*, or the other interfaces described
    later in this chapter, will remain regular. For example, if a real-time timer
    is set to expire every 2 seconds, then the delivery of individual timer events
    may be subject to the delays just described, but the scheduling of subsequent
    expirations will nevertheless be at exactly the next 2-second interval. In other
    words, interval timers are not subject to creeping errors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 根据系统负载和进程调度的情况，某个进程可能要等到定时器实际到期后一小段时间（通常是几秒的一小部分）才会被调度执行。尽管如此，由*setitimer()*建立的周期定时器，或本章后续描述的其他接口，仍将保持规律。例如，如果一个实时定时器被设置为每2秒到期，那么尽管个别定时器事件的触发可能会受到上述延迟的影响，但后续定时器到期的调度仍将严格在下一个2秒的间隔内进行。换句话说，间隔定时器不会出现累积误差。
- en: Although the *timeval* structure used by *setitimer()* allows for microsecond
    precision, the accuracy of a timer has traditionally been limited by the frequency
    of the software clock ([The Software Clock (Jiffies)](ch10.html#the_software_clock_open_parenthesis_jiff
    "The Software Clock (Jiffies)")). If a timer value does not exactly match a multiple
    of the granularity of the software clock, then the timer value is rounded up.
    This means that if, for example, we specified an interval timer to go off each
    19,100 microseconds (i.e., just over 19 milliseconds), then, assuming a jiffy
    value of 4 milliseconds, we would actually get a timer that expired every 20 milliseconds.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*setitimer()*使用的*timeval*结构支持微秒级精度，但定时器的精度传统上受到软件时钟频率的限制（参见[软件时钟（Jiffies）](ch10.html#the_software_clock_open_parenthesis_jiff
    "软件时钟（Jiffies）")）。如果定时器值与软件时钟的粒度没有完全匹配，定时器值将被四舍五入。例如，如果我们指定一个间隔定时器，每19,100微秒触发一次（即大约19毫秒），假设时钟粒度为4毫秒，那么实际的定时器将每20毫秒触发一次。
- en: High-resolution timers
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 高分辨率定时器
- en: On modern Linux kernels, the preceding statement that timer resolution is limited
    by the frequency of the software clock no longer holds true. Since kernel 2.6.21,
    Linux optionally supports high-resolution timers. If this support is enabled (via
    the `CONFIG_HIGH_RES_TIMERS` kernel configuration option), then the accuracy of
    the various timer and sleep interfaces that we describe in this chapter is no
    longer constrained by the size of the kernel jiffy. Instead, these calls can be
    as accurate as the underlying hardware allows. On modern hardware, accuracy down
    to a microsecond is typical.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Linux内核中，之前关于定时器分辨率受限于软件时钟频率的说法不再成立。从2.6.21内核版本开始，Linux可选地支持高分辨率定时器。如果启用了此支持（通过`CONFIG_HIGH_RES_TIMERS`内核配置选项），那么我们在本章中描述的各种定时器和睡眠接口的精度将不再受内核时钟的大小限制。相反，这些调用的精度可以达到底层硬件所允许的程度。在现代硬件上，精度通常可达到微秒级。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The availability of high-resolution timers can be determined by examining the
    clock resolution returned by *clock_getres()*, described in [Retrieving the Value
    of a Clock: *clock_gettime()*](ch23.html#retrieving_the_value_of_a_clock_colon_cl
    "Retrieving the Value of a Clock: clock_gettime()").'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过检查*clock_getres()*返回的时钟分辨率来确定高分辨率定时器的可用性，相关内容可以参见[获取时钟值：*clock_gettime()*](ch23.html#retrieving_the_value_of_a_clock_colon_cl
    "获取时钟值：clock_gettime()")。
- en: Setting Timeouts on Blocking Operations
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置阻塞操作的超时
- en: 'One use of real-time timers is to place an upper limit on the time for which
    a blocking system call can remain blocked. For example, we may wish to cancel
    a *read()* from a terminal if the user has not entered a line of input within
    a certain time. We can do this as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 实时定时器的一个用途是对阻塞系统调用的最大阻塞时间设定上限。例如，我们可能希望在用户在一定时间内没有输入一行内容的情况下取消从终端的*read()*调用。我们可以按如下方式实现：
- en: Call *sigaction()* to establish a handler for `SIGALRM`, omitting the `SA_RESTART`
    flag, so that system calls are not restarted (refer to [Interruption and Restarting
    of System Calls](ch21.html#interruption_and_restarting_of_system_ca "Interruption
    and Restarting of System Calls")).
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用*sigaction()*建立`SIGALRM`的处理程序，省略`SA_RESTART`标志，这样系统调用就不会被重新启动（参见[系统调用的中断与重启](ch21.html#interruption_and_restarting_of_system_ca
    "系统调用的中断与重启")）。
- en: Call *alarm()* or *setitimer()* to establish a timer specifying the upper limit
    of time for which we wish the system call to block.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用*alarm()*或*setitimer()*来设置一个定时器，指定我们希望系统调用阻塞的最大时间限制。
- en: Make the blocking system call.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行阻塞的系统调用。
- en: After the system call returns, call *alarm()* or *setitimer()* once more to
    disable the timer (in case the system call completed before the timer expired).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统调用返回后，再次调用*alarm()*或*setitimer()*来禁用定时器（以防系统调用在定时器过期之前完成）。
- en: Check to see whether the blocking system call failed with *errno* set to `EINTR`
    (interrupted system call).
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查阻塞系统调用是否失败，并将*errno*设置为`EINTR`（被中断的系统调用）。
- en: '[Example 23-2](ch23.html#performing_a_read_open_parenthesis_close "Example 23-2. Performing
    a read() with timeout") demonstrates this technique for *read()*, using *alarm()*
    to establish the timer.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 23-2](ch23.html#performing_a_read_open_parenthesis_close "示例 23-2. 执行带超时的read()")演示了使用*alarm()*来设置定时器的*read()*技术。'
- en: Example 23-2. Performing a *read()* with timeout
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 23-2. 执行带超时的*read()*
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that there is a theoretical race condition in the program in [Example 23-2](ch23.html#performing_a_read_open_parenthesis_close
    "Example 23-2. Performing a read() with timeout"). If the timer expires after
    the call to *alarm()*, but before the *read()* call is started, then the *read()*
    call won’t be interrupted by the signal handler. Since the timeout value used
    in scenarios like this is normally relatively large (at least several seconds)
    this is highly unlikely to occur, so that, in practice, this is a viable technique.
    [Stevens & Rago, 2005] proposes an alternative technique using *longjmp()*. A
    further alternative when dealing with I/O system calls is to use the timeout feature
    of the *select()* or *poll()* system calls ([Chapter 63](ch63.html "Chapter 63. Alternative
    I/O Models")), which also have the advantage of allowing us to simultaneously
    wait for I/O on multiple descriptors.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[示例 23-2](ch23.html#performing_a_read_open_parenthesis_close "示例 23-2. 执行带超时的read()")中的程序存在一个理论上的竞态条件。如果定时器在调用*alarm()*之后，但在*read()*调用开始之前过期，则*read()*调用不会被信号处理程序中断。由于在这种情况下使用的超时值通常较大（至少几秒钟），因此这种情况发生的可能性很小，因此在实际操作中，这是一种可行的技术。[Stevens
    & Rago, 2005]提出了一种使用*longjmp()*的替代技术。处理I/O系统调用的另一种替代方案是使用*select()*或*poll()*系统调用的超时功能（[第63章](ch63.html
    "第63章。替代I/O模型")），它们还有一个优点，就是能够同时等待多个描述符的I/O。
- en: Suspending Execution for a Fixed Interval (Sleeping)
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为固定时间间隔挂起执行（睡眠）
- en: Sometimes, we want to suspend execution of a process for a fixed amount of time.
    While it is possible to do this using a combination of *sigsuspend()* and the
    timer functions already described, it is easier to use one of the sleep functions
    instead.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望将进程执行挂起一定的固定时间。虽然可以通过组合使用*sigsuspend()*和前面描述的定时器函数来实现，但使用其中一个睡眠函数会更为简单。
- en: 'Low-Resolution Sleeping: *sleep()*'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 低分辨率睡眠：*sleep()*
- en: The *sleep()* function suspends execution of the calling process for the number
    of seconds specified in the *seconds* argument or until a signal is caught (thus
    interrupting the call).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*sleep()*函数将调用进程的执行挂起，直到指定的*seconds*参数秒数或者信号被捕获（从而中断调用）。'
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on normal completion, or number of unslept seconds if prematurely
    terminated
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正常完成时返回0，或者在被提前终止时返回未睡眠的秒数
- en: If the sleep completes, *sleep()* returns 0\. If the sleep is interrupted by
    a signal, *sleep()* returns the number of remaining (unslept) seconds. As with
    timers set by *alarm()* and *setitimer()*, system load may mean that the process
    is rescheduled only at some (normally short) time after the completion of the
    *sleep()* call.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果睡眠完成，*sleep()*返回0。如果睡眠被信号中断，*sleep()*返回剩余的（未睡眠的）秒数。与*alarm()*和*setitimer()*设置的定时器一样，系统负载可能意味着进程只有在*sleep()*调用完成后的某个（通常较短的）时间才会被重新调度。
- en: 'SUSv3 leaves possible interactions of *sleep()* with *alarm()* and *setitimer()*
    unspecified. On Linux, *sleep()* is implemented as a call to *nanosleep()* ([High-Resolution
    Sleeping: *nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep "High-Resolution
    Sleeping: nanosleep()")), with the consequence that there is no interaction between
    *sleep()* and the timer functions. However, on many implementations, especially
    older ones, *sleep()* is implemented using *alarm()* and a handler for the `SIGALRM`
    signal. For portability, we should avoid mixing the use of *sleep()* with *alarm()*
    and *setitimer()*.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3未明确规定*sleep()*与*alarm()*和*setitimer()*的可能交互。在Linux上，*sleep()*是通过调用*nanosleep()*来实现的（[高分辨率睡眠：*nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep
    "高分辨率睡眠：nanosleep()")），因此，*sleep()*与定时器函数之间没有交互。然而，在许多实现中，特别是较老的实现中，*sleep()*是通过*alarm()*和`SIGALRM`信号的处理程序来实现的。为了可移植性，我们应该避免将*sleep()*与*alarm()*和*setitimer()*混合使用。
- en: 'High-Resolution Sleeping: *nanosleep()*'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高分辨率睡眠：*nanosleep()*
- en: The *nanosleep()* function performs a similar task to *sleep()*, but provides
    a number of advantages, including finer resolution when specifying the sleep interval.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*nanosleep()*函数执行的任务与*sleep()*类似，但提供了许多优点，包括在指定睡眠间隔时具有更精细的分辨率。'
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on successfully completed sleep, or -1 on error or interrupted sleep
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 成功完成睡眠时返回0，发生错误或睡眠被中断时返回-1。
- en: 'The *request* argument specifies the duration of the sleep interval and is
    a pointer to a structure of the following form:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*request*参数指定睡眠间隔的持续时间，并且是指向如下结构的指针：'
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The *tv_nsec* field specifies a nanoseconds value. It must be a number in the
    range 0 to 999,999,999.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*tv_nsec*字段指定纳秒值。它必须是0到999,999,999之间的数字。'
- en: A further advantage of *nanosleep()* is that SUSv3 explicitly specifies that
    it should not be implemented using signals. This means that, unlike the situation
    with *sleep()*, we can portably mix calls to *nanosleep()* with calls to *alarm()*
    or *setitimer()*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*nanosleep()*的另一个优点是SUSv3明确规定它不应通过信号来实现。这意味着，与*sleep()*的情况不同，我们可以在可移植性方面，将*nanosleep()*与*alarm()*或*setitimer()*的调用混合使用。'
- en: 'Although it is not implemented using signals, *nanosleep()* may still be interrupted
    by a signal handler. In this case, *nanosleep()* returns -1, with *errno* set
    to the usual `EINTR` and, if the argument *remain* is not `NULL`, the buffer it
    points to returns the remaining unslept time. If desired, we can use the returned
    value to restart the system call and complete the sleep. This is demonstrated
    in [Example 23-3](ch23.html#using_nanosleep_open_parenthesis_close_p "Example 23-3. Using
    nanosleep()"). As command-line arguments, this program expects seconds and nanosecond
    values for *nanosleep()*. The program loops repeatedly, executing *nanosleep()*
    until the total sleep interval is passed. If *nanosleep()* is interrupted by the
    handler for `SIGINT` (generated by typing *Control-C*), then the call is restarted
    using the value returned in *remain*. When we run this program, we see the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*nanosleep()*的实现并未使用信号，但它仍可能被信号处理程序中断。在这种情况下，*nanosleep()*返回-1，并将*errno*设置为常见的`EINTR`，如果参数*remain*不为`NULL`，则指向的缓冲区返回剩余的未睡眠时间。如果需要，我们可以使用返回的值重新启动系统调用以完成睡眠。这在[示例23-3](ch23.html#using_nanosleep_open_parenthesis_close_p
    "示例23-3. 使用nanosleep()")中有所演示。作为命令行参数，该程序期望为*nanosleep()*提供秒和纳秒值。程序会反复循环，执行*nanosleep()*直到总睡眠时间过去。如果*nanosleep()*被`SIGINT`（由输入*Control-C*生成）信号的处理程序中断，则使用*remain*中返回的值重新启动调用。当我们运行该程序时，看到如下输出：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Although *nanosleep()* allows nanosecond precision when specifying the sleep
    interval, the accuracy of the sleep interval is limited to the granularity of
    the software clock ([The Software Clock (Jiffies)](ch10.html#the_software_clock_open_parenthesis_jiff
    "The Software Clock (Jiffies)")). If we specify an interval that is not a multiple
    of the software clock, then the interval is rounded up.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*nanosleep()*在指定睡眠间隔时允许纳秒级精度，但睡眠间隔的准确性仍然受到软件时钟粒度的限制（[软件时钟（Jiffies）](ch10.html#the_software_clock_open_parenthesis_jiff
    "软件时钟（Jiffies）")）。如果我们指定的间隔不是软件时钟的倍数，则该间隔会被向上舍入。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As noted earlier, on systems that support high-resolution timers, the accuracy
    of the sleep interval can be much finer than the granularity of the software clock.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在支持高分辨率定时器的系统上，睡眠间隔的精度可以比软件时钟的粒度更细。
- en: 'This rounding behavior means that if signals are received at a high rate, then
    there is a problem with the approach employed in the program in [Example 23-3](ch23.html#using_nanosleep_open_parenthesis_close_p
    "Example 23-3. Using nanosleep()"). The problem is that each restart of *nanosleep()*
    will be subject to rounding errors, since the returned *remain* time is unlikely
    to be an exact multiple of the granularity of the software clock. Consequently,
    each restarted *nanosleep()* will sleep longer than the value returned in *remain*
    by the previous call. In the case of an extremely high rate of signal delivery
    (i.e., as or more frequent than the software clock granularity), the process may
    never be able to complete its sleep. On Linux 2.6, this problem can be avoided
    by making use of *clock_nanosleep()* with the `TIMER_ABSTIME` option. We describe
    *clock_nanosleep()* in [Improved High-Resolution Sleeping: *clock_nanosleep()*](ch23.html#improved_high-resolution_sleeping_colon
    "Improved High-Resolution Sleeping: clock_nanosleep()").'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种舍入行为意味着，如果信号接收频率很高，那么在[示例 23-3](ch23.html#using_nanosleep_open_parenthesis_close_p
    "示例 23-3. 使用 nanosleep()")中的方法就会出现问题。问题在于，每次重新启动 *nanosleep()* 都会受到舍入误差的影响，因为返回的
    *remain* 时间不太可能是软件时钟粒度的整数倍。因此，每次重新启动的 *nanosleep()* 会比前一次调用返回的 *remain* 时间更长。在信号传递频率极高（即与或更频繁于软件时钟粒度）时，进程可能永远无法完成其睡眠。在
    Linux 2.6 中，可以通过使用带 `TIMER_ABSTIME` 选项的 *clock_nanosleep()* 来避免此问题。我们在[改进的高分辨率睡眠：*clock_nanosleep()*](ch23.html#improved_high-resolution_sleeping_colon
    "改进的高分辨率睡眠：clock_nanosleep()")中描述了 *clock_nanosleep()*。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Linux 2.4 and earlier, there is an eccentricity in the implementation of
    *nanosleep()*. Suppose that a process performing a *nanosleep()* call is stopped
    by a signal. When the process is later resumed via delivery of `SIGCONT`, then
    the *nanosleep()* call fails with the error `EINTR`, as expected. However, if
    the program subsequently restarts the *nanosleep()* call, then the time that the
    process has spent in the stopped state is *not* counted against the sleep interval,
    so that the process will sleep longer than expected. This eccentricity is eliminated
    in Linux 2.6, where the *nanosleep()* call automatically resumes on delivery of
    the `SIGCONT` signal, and the time spent in the sleep state is counted against
    the sleep interval.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 2.4 及更早版本中，*nanosleep()* 的实现存在一个异常。假设一个进程正在执行 *nanosleep()* 调用，并被信号暂停。当该进程通过发送
    `SIGCONT` 信号恢复时，*nanosleep()* 调用会按预期失败，并返回错误 `EINTR`。然而，如果程序随后重新启动 *nanosleep()*
    调用，则进程在暂停状态下的时间*不会*被计算在睡眠间隔内，这样进程将比预期睡得更久。这个异常在 Linux 2.6 中被消除，在该版本中，*nanosleep()*
    调用会在收到 `SIGCONT` 信号时自动恢复，并且睡眠状态的时间会被计算在睡眠间隔内。
- en: Example 23-3. Using *nanosleep()*
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 23-3：使用 *nanosleep()*
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: POSIX Clocks
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POSIX 时钟
- en: 'POSIX clocks (originally defined in POSIX.1b) provide an API for accessing
    clocks that measure time with nanosecond precision. Nanosecond time values are
    represented using the same *timespec* structure as is used by *nanosleep()* ([High-Resolution
    Sleeping: *nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep "High-Resolution
    Sleeping: nanosleep()")).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 时钟（最初定义在 POSIX.1b 中）提供了一个 API，用于访问具有纳秒精度的时钟。纳秒时间值使用与 *nanosleep()* 相同的
    *timespec* 结构表示（参见[高分辨率睡眠：*nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep
    "高分辨率睡眠：nanosleep()")）。
- en: On Linux, programs using this API must be compiled with the *-lrt* option, in
    order to link against the *librt* (realtime) library.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，使用此 API 的程序必须使用 *-lrt* 选项编译，以便链接 *librt*（实时）库。
- en: The main system calls in the POSIX clocks API are *clock_gettime()*, which retrieves
    the current value of a clock; *clock_getres()*, which returns the resolution of
    a clock; and *clock_settime()*, which updates a clock.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 时钟 API 的主要系统调用有 *clock_gettime()*，用于检索时钟的当前值；*clock_getres()*，用于返回时钟的分辨率；以及
    *clock_settime()*，用于更新时钟。
- en: 'Retrieving the Value of a Clock: *clock_gettime()*'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取时钟值：*clock_gettime()*
- en: The *clock_gettime()* system call returns the time according to the clock specified
    in *clockid*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*clock_gettime()* 系统调用根据 *clockid* 指定的时钟返回时间。'
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 两者成功时返回 0，出错时返回 -1。
- en: The time value is returned in the timespec structure pointed to by *tp*. Although
    the *timespec* structure affords nanosecond precision, the granularity of the
    time value returned by *clock_gettime()* may be coarser than this. The *clock_getres()*
    system call returns a pointer to a *timespec* structure containing the resolution
    of the clock specified in *clockid*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 时间值以 *tp* 所指向的 timespec 结构返回。尽管 *timespec* 结构提供纳秒级精度，但 *clock_gettime()* 返回的时间值的粒度可能比这更粗。*clock_getres()*
    系统调用返回指向一个 *timespec* 结构的指针，该结构包含所指定的 *clockid* 时钟的分辨率。
- en: The *clockid_t* data type is a type specified by SUSv3 for representing a clock
    identifier. The first column of [Table 23-1](ch23.html#posix.1b_clock_types "Table 23-1. POSIX.1b
    clock types") lists the values that can be specified for *clockid*
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*clockid_t* 数据类型是由 SUSv3 指定的，用于表示时钟标识符。[表格 23-1](ch23.html#posix.1b_clock_types
    "表格 23-1. POSIX.1b 时钟类型") 的第一列列出了可以为 *clockid* 指定的值。'
- en: Table 23-1. POSIX.1b clock types
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 23-1. POSIX.1b 时钟类型
- en: '| Clock ID | Description |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 时钟 ID | 描述 |'
- en: '| --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CLOCK_REALTIME` | Settable system-wide real-time clock |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `CLOCK_REALTIME` | 可设置的全系统实时时钟 |'
- en: '| `CLOCK_MONOTONIC` | Nonsettable monotonic clock |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `CLOCK_MONOTONIC` | 不可设置的单调时钟 |'
- en: '| `CLOCK_PROCESS_CPUTIME_ID` | Per-process CPU-time clock (since Linux 2.6.12)
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `CLOCK_PROCESS_CPUTIME_ID` | 每进程的 CPU 时间时钟（自 Linux 2.6.12 起） |'
- en: '| `CLOCK_THREAD_CPUTIME_ID` | Per-thread CPU-time clock (since Linux 2.6.12)
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `CLOCK_THREAD_CPUTIME_ID` | 每线程的 CPU 时间时钟（自 Linux 2.6.12 起） |'
- en: The `CLOCK_REALTIME` clock is a system-wide clock that measures wall-clock time.
    By contrast with the `CLOCK_MONOTONIC` clock, the setting of this clock can be
    changed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLOCK_REALTIME` 时钟是一个全系统的时钟，测量挂钟时间。与 `CLOCK_MONOTONIC` 时钟相比，该时钟的设置可以被更改。'
- en: SUSv3 specifies that the `CLOCK_MONOTONIC` clock measures time since some “unspecified
    point in the past” that doesn’t change after system startup. This clock is useful
    for applications that must not be affected by discontinuous changes to the system
    clock (e.g., a manual change to the system time). On Linux, this clock measures
    the time since system startup.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 规定，`CLOCK_MONOTONIC` 时钟测量自某个“未指定的过去时间点”以来的时间，该时间点在系统启动后不会改变。该时钟适用于不能受系统时钟的不连续变更影响的应用程序（例如，手动更改系统时间）。在
    Linux 上，该时钟测量自系统启动以来的时间。
- en: '`The CLOCK_PROCESS_CPUTIME_ID` clock measures the user and system CPU time
    consumed by the calling process. The `CLOCK_THREAD_CPUTIME_ID` clock performs
    the analogous task for an individual thread within a process.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLOCK_PROCESS_CPUTIME_ID` 时钟测量调用进程消耗的用户和系统 CPU 时间。`CLOCK_THREAD_CPUTIME_ID`
    时钟对进程中的单个线程执行类似任务。'
- en: All of the clocks in [Table 23-1](ch23.html#posix.1b_clock_types "Table 23-1. POSIX.1b
    clock types") are specified in SUSv3, but only `CLOCK_REALTIME` is mandatory and
    widely supported on UNIX implementations.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 23-1](ch23.html#posix.1b_clock_types "表格 23-1. POSIX.1b 时钟类型") 中的所有时钟都由
    SUSv3 规定，但只有 `CLOCK_REALTIME` 是强制性的，并且在 UNIX 实现中得到广泛支持。'
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Linux 2.6.28 adds a new clock type, `CLOCK_MONOTONIC_RAW`, to those listed in
    [Table 23-1](ch23.html#posix.1b_clock_types "Table 23-1. POSIX.1b clock types").
    This is a nonsettable clock that is similar to `CLOCK_MONOTONIC`, but it gives
    access to a pure hardware-based time that is unaffected by NTP adjustments. This
    nonstandard clock is intended for use in specialized clock-synchronization applications.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 2.6.28 在 [表格 23-1](ch23.html#posix.1b_clock_types "表格 23-1. POSIX.1b 时钟类型")
    列出的时钟之外，新增了一种时钟类型 `CLOCK_MONOTONIC_RAW`。这是一种不可设置的时钟，类似于 `CLOCK_MONOTONIC`，但它提供对纯硬件时间的访问，且不受
    NTP 调整的影响。该非标准时钟用于特定的时钟同步应用程序。
- en: 'Linux 2.6.32 adds two more new clocks to those listed in [Table 23-1](ch23.html#posix.1b_clock_types
    "Table 23-1. POSIX.1b clock types"): `CLOCK_REALTIME_COARSE` and `CLOCK_MONOTIC_COARSE`.
    These clocks are similar to `CLOCK_REALTIME` and `CLOCK_MONOTONIC`, but intended
    for applications that want to obtain lower-resolution timestamps at minimal cost.
    These nonstandard clocks don’t cause any access to the hardware clock (which can
    be expensive for some hardware clock sources), and the resolution of the returned
    value is the jiffy ([The Software Clock (Jiffies)](ch10.html#the_software_clock_open_parenthesis_jiff
    "The Software Clock (Jiffies)")).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 2.6.32 在 [表格 23-1](ch23.html#posix.1b_clock_types "表格 23-1. POSIX.1b 时钟类型")
    列出的时钟之外，新增了两个时钟：`CLOCK_REALTIME_COARSE` 和 `CLOCK_MONOTONIC_COARSE`。这些时钟与 `CLOCK_REALTIME`
    和 `CLOCK_MONOTONIC` 类似，但用于需要以最小成本获得低分辨率时间戳的应用程序。这些非标准时钟不会访问硬件时钟（某些硬件时钟源的访问可能非常昂贵），返回值的分辨率是
    jiffy（[软件时钟（Jiffies）](ch10.html#the_software_clock_open_parenthesis_jiff "软件时钟（Jiffies）")）。
- en: 'Setting the Value of a Clock: *clock_settime()*'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置时钟值：*clock_settime()*
- en: The *clock_settime()* system call sets the clock specified by *clockid* to the
    time supplied in the buffer pointed to by *tp*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*clock_settime()*系统调用将*clockid*指定的时钟设置为*tp*指向的缓冲区中的时间。'
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: If the time specified by *tp* is not a multiple of the clock resolution as returned
    by *clock_getres()*, the time is rounded downward.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*tp*指定的时间不是*clock_getres()*返回的时钟分辨率的倍数，时间将向下舍入。
- en: A privileged (`CAP_SYS_TIME`) process may set the `CLOCK_REALTIME` clock. The
    initial value of this clock is typically the time since the Epoch. None of the
    other clocks in [Table 23-1](ch23.html#posix.1b_clock_types "Table 23-1. POSIX.1b
    clock types") are modifiable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 具有特权的（`CAP_SYS_TIME`）进程可以设置`CLOCK_REALTIME`时钟。该时钟的初始值通常是自纪元以来的时间。[表23-1](ch23.html#posix.1b_clock_types
    "表23-1. POSIX.1b 时钟类型")中列出的其他时钟不可修改。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: According to SUSv3, an implementation may allow the `CLOCK_PROCESS_CPUTIME_ID`
    and `CLOCK_THREAD_CPUTIME_ID` clocks to be settable. At the time of writing, these
    clocks are read-only on Linux.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 根据SUSv3规范，某些实现可能允许设置`CLOCK_PROCESS_CPUTIME_ID`和`CLOCK_THREAD_CPUTIME_ID`时钟。截至写作时，这些时钟在Linux上是只读的。
- en: Obtaining the Clock ID of a Specific Process or Thread
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取特定进程或线程的时钟ID
- en: The functions described in this section allow us to obtain the ID of a clock
    that measures the CPU time consumed by a particular process or thread. We can
    use the returned clock ID in a call to *clock_gettime()* in order to find out
    the CPU time consumed by the process or thread.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述的函数允许我们获取测量特定进程或线程CPU时间的时钟ID。我们可以将返回的时钟ID用于调用*clock_gettime()*，以便了解进程或线程消耗的CPU时间。
- en: The *clock_getcpuclockid()* function returns the identifier of the CPU-time
    clock of the process whose ID is *pid*, in the buffer pointed to by *clockid*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*clock_getcpuclockid()*函数返回指定*pid*进程的CPU时间时钟的标识符，该标识符保存在*clockid*指向的缓冲区中。'
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回正数错误码
- en: If *pid* is 0, *clock_getcpuclockid()* returns the ID of the CPU-time clock
    of the calling process.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*pid*为0，*clock_getcpuclockid()*返回调用进程的CPU时间时钟的ID。
- en: The *pthread_getcpuclockid()* function is the POSIX threads analog of the *clock_getcpuclockid()*
    function. It returns the identifier of the clock measuring the CPU time consumed
    by a specific thread of the calling process.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_getcpuclockid()*函数是POSIX线程的*clock_getcpuclockid()*函数的对应函数。它返回测量调用进程中特定线程CPU时间的时钟标识符。'
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回正数错误码
- en: The *thread* argument is a POSIX thread ID that identifies the thread whose
    CPU-time clock ID we want to obtain. The clock ID is returned in the buffer pointed
    to by *clockid*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*thread*参数是一个POSIX线程ID，表示我们想要获取其CPU时间时钟ID的线程。时钟ID将保存在*clockid*指向的缓冲区中。'
- en: 'Improved High-Resolution Sleeping: *clock_nanosleep()*'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进的高分辨率睡眠：*clock_nanosleep()*
- en: Like *nanosleep()*, the Linux-specific *clock_nanosleep()* system call suspends
    the calling process until either a specified interval of time has passed or a
    signal arrives. In this section, we describe the features that distinguish *clock_nanosleep()*
    from *nanosleep()*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与*nanosleep()*类似，Linux特有的*clock_nanosleep()*系统调用会暂停调用进程，直到指定的时间间隔过去或收到信号。在本节中，我们描述了将*clock_nanosleep()*与*nanosleep()*区分开来的特点。
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on successfully completed sleep, or a positive error number on error
    or interrupted sleep
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 成功完成睡眠时返回0，出错或被中断时返回正数错误码
- en: The *request* and *remain* arguments serve similar purposes to the analogous
    arguments for *nanosleep()*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*request*和*remain*参数的作用与*nanosleep()*的相应参数类似。'
- en: By default (i.e., if *flags* is 0), the sleep interval specified in *request*
    is relative (like *nanosleep()*). However, if we specify `TIMER_ABSTIME` in *flags*
    (see the example in [Example 23-4](ch23.html#using_clock_underscore_nanosleep_open_pa
    "Example 23-4. Using clock_nanosleep()")), then *request* specifies an absolute
    time as measured by the clock identified by *clockid*. This feature is essential
    in applications that need to sleep accurately until a specific time. If we instead
    try retrieving the current time, calculating the difference until the desired
    target time, and doing a relative sleep, then there is a possibility that the
    process may be preempted in the middle of these steps, and consequently sleep
    for longer than desired.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下（即*flags*为0时），*request*中指定的睡眠间隔是相对的（如同*nanosleep()*）。然而，如果我们在*flags*中指定了`TIMER_ABSTIME`（请参见[示例
    23-4](ch23.html#using_clock_underscore_nanosleep_open_pa "示例 23-4. 使用 clock_nanosleep()")中的示例），则*request*指定了一个由*clockid*所标识的时钟测量的绝对时间。这个特性在需要精确睡眠直到特定时间的应用中至关重要。如果我们试图获取当前时间，计算与目标时间的差值，并进行相对睡眠，那么可能会发生进程在这些步骤的中间被抢占，导致睡眠时间比预期的更长。
- en: 'As described in [High-Resolution Sleeping: *nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep
    "High-Resolution Sleeping: nanosleep()"), this “oversleeping” problem is particularly
    marked for a process that uses a loop to restart a sleep that is interrupted by
    a signal handler. If signals are delivered at a high rate, then a relative sleep
    (of the type performed by *nanosleep()*) can lead to large inaccuracies in the
    time a process spends sleeping. We can avoid the oversleeping problem by making
    an initial call to *clock_gettime()* to retrieve the time, adding the desired
    amount to that time, and then calling *clock_nanosleep()* with the `TIMER_ABSTIME`
    flag (and restarting the system call if it is interrupted by a signal handler).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[高分辨率睡眠：*nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep
    "高分辨率睡眠：nanosleep()")中所描述的，当一个进程使用循环来重新启动被信号处理程序中断的睡眠时，这种“过度睡眠”问题尤其明显。如果信号以较高的频率传递，那么由*nanosleep()*执行的相对睡眠可能会导致进程睡眠时间出现较大误差。我们可以通过首先调用*clock_gettime()*来获取当前时间，将所需的时间加到该时间上，然后使用`TIMER_ABSTIME`标志调用*clock_nanosleep()*（如果被信号处理程序中断，重新启动系统调用）来避免过度睡眠问题。
- en: When the `TIMER_ABSTIME` flag is specified, the *remain* argument is unused
    (it is unnecessary). If the *clock_nanosleep()* call is interrupted by a signal
    handler, then the sleep can be restarted by repeating the call with the same *request*
    argument.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定了`TIMER_ABSTIME`标志时，*remain*参数将不被使用（它是多余的）。如果*clock_nanosleep()*调用被信号处理程序中断，则可以通过重复相同的*request*参数重新启动睡眠。
- en: 'Another feature that distinguishes *clock_nanosleep()* from *nanosleep()* is
    that we can choose the clock that is used to measure the sleep interval. We specify
    the desired clock in *clockid*: `CLOCK_REALTIME`, `CLOCK_MONOTONIC`, or `CLOCK_PROCESS_CPUTIME_ID`.
    See [Table 23-1](ch23.html#posix.1b_clock_types "Table 23-1. POSIX.1b clock types")
    for a description of these clocks.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使*clock_nanosleep()*与*nanosleep()*不同的特性是，我们可以选择用于测量睡眠间隔的时钟。我们在*clockid*中指定所需的时钟：`CLOCK_REALTIME`、`CLOCK_MONOTONIC`或`CLOCK_PROCESS_CPUTIME_ID`。有关这些时钟的描述，请参见[表
    23-1](ch23.html#posix.1b_clock_types "表 23-1. POSIX.1b 时钟类型")。
- en: '[Example 23-4](ch23.html#using_clock_underscore_nanosleep_open_pa "Example 23-4. Using
    clock_nanosleep()") demonstrates the use of *clock_nanosleep()* to sleep for 20
    seconds against the `CLOCK_REALTIME` clock using an absolute time value.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 23-4](ch23.html#using_clock_underscore_nanosleep_open_pa "示例 23-4. 使用 clock_nanosleep()")
    演示了如何使用*clock_nanosleep()*通过绝对时间值以`CLOCK_REALTIME`时钟来睡眠20秒。'
- en: Example 23-4. Using *clock_nanosleep()*
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 23-4. 使用*clock_nanosleep()*
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: POSIX Interval Timers
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POSIX间隔计时器
- en: 'The classical UNIX interval timers set by *setitimer()* suffer a number of
    limitations:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由*setitimer()*设置的经典UNIX间隔计时器存在若干限制：
- en: We can set only one timer of each of the three types, `ITIMER_REAL`, `ITIMER_VIRTUAL`,
    and `ITIMER_PROF`.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只能设置每种类型的计时器一次，分别是`ITIMER_REAL`、`ITIMER_VIRTUAL`和`ITIMER_PROF`。
- en: The only way of being notified of timer expiration is via delivery of a signal.
    Furthermore, we can’t change the signal that is generated when the timer expires.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一通知计时器到期的方式是通过信号传递。而且，我们不能更改计时器到期时生成的信号。
- en: If an interval timer expires multiple times while the corresponding signal is
    blocked, then the signal handler is called only once. In other words, we have
    no way of knowing whether there was a *timeroverrun*.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果间隔定时器在相应的信号被阻塞时多次到期，则信号处理程序仅被调用一次。换句话说，我们无法知道是否发生了 *timeroverrun*。
- en: Timers are limited to microsecond resolution. However, some systems have hardware
    clocks that provide finer resolution than this, and, on such systems, it is desirable
    to have software access to this greater resolution.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器的精度限制为微秒。然而，一些系统具有提供比这更高精度的硬件时钟，在这些系统上，能够访问这种更高精度的时间就显得尤为重要。
- en: POSIX.1b defined an API to address these limitations, and this API is implemented
    in Linux 2.6.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX.1b 定义了一个 API 来解决这些限制，这个 API 在 Linux 2.6 中得到了实现。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On older Linux systems, an incomplete version of this API was provided via a
    threads-based implementation in *glibc*. However, this user-space implementation
    doesn’t provide all of the features described here.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在较老的 Linux 系统中，通过基于线程的 *glibc* 实现提供了此 API 的不完整版本。然而，这种用户空间实现并未提供此处描述的所有功能。
- en: 'The POSIX timer API divides the life of a timer into the following steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 定时器 API 将定时器的生命周期分为以下几个步骤：
- en: The *timer_create()* system call creates a new timer and defines the method
    by which it will notify the process when it expires.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*timer_create()* 系统调用创建一个新的定时器，并定义当定时器到期时如何通知进程。'
- en: The *timer_settime()* system call arms (starts) or disarms (stops) a timer.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*timer_settime()* 系统调用启动（开始）或停止（停止）定时器。'
- en: The *timer_delete()* system call deletes a timer that is no longer required.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*timer_delete()* 系统调用删除不再需要的定时器。'
- en: POSIX timers are not inherited by a child created by *fork()*. They are disarmed
    and deleted during an *exec()* or on process termination.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 定时器不会被 *fork()* 创建的子进程继承。它们会在 *exec()* 或进程终止时被禁用并删除。
- en: On Linux, programs using the POSIX timer API must be compiled with the *-lrt*
    option, in order to link against the *librt* (realtime) library.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，使用 POSIX 定时器 API 的程序必须使用 *-lrt* 选项进行编译，以便链接到 *librt*（实时）库。
- en: 'Creating a Timer: *timer_create()*'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建定时器：*timer_create()*
- en: The *timer_create()* function creates a new timer that measures time using the
    clock specified by *clockid*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*timer_create()* 函数创建一个新的定时器，该定时器使用由 *clockid* 指定的时钟来计时。'
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: The *clockid* can specify any of the values shown in [Table 23-1](ch23.html#posix.1b_clock_types
    "Table 23-1. POSIX.1b clock types"), or the *clockid* value returned by *clock_getcpuclockid()*
    or *pthread_getcpuclockid()*. The *timerid* argument points to a buffer that returns
    a handle used to refer to the timer in later system calls. This buffer is typed
    as *timer_t*, which is a data type specified by SUSv3 for representing a timer
    identifier.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*clockid* 可以指定 [表 23-1](ch23.html#posix.1b_clock_types "表 23-1. POSIX.1b 时钟类型")
    中显示的任何值，或者由 *clock_getcpuclockid()* 或 *pthread_getcpuclockid()* 返回的 *clockid*
    值。*timerid* 参数指向一个缓冲区，该缓冲区返回一个句柄，用于在后续系统调用中引用定时器。这个缓冲区的类型是 *timer_t*，它是 SUSv3
    为表示定时器标识符而指定的数据类型。'
- en: 'The *evp* argument determines how the program is to be notified when the timer
    expires. It points to a structure of type *sigevent*, defined as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*evp* 参数决定了当定时器到期时，程序如何被通知。它指向一个类型为 *sigevent* 的结构，定义如下：'
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The *sigev_notify* field of this structure is set to one of the values shown
    in [Table 23-2](ch23.html#values_for_the_sigev_underscore_notify_f "Table 23-2. Values
    for the sigev_notify field of the sigevent structure").
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构的 *sigev_notify* 字段被设置为 [表 23-2](ch23.html#values_for_the_sigev_underscore_notify_f
    "表 23-2. sigev_notify 字段的值") 中所示的一个值。
- en: Table 23-2. Values for the *sigev_notify* field of the *sigevent* structure
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 表 23-2. *sigev_notify* 字段的值，用于 *sigevent* 结构
- en: '| *sigev_notify* value | Notification method | SUSv3 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| *sigev_notify* 值 | 通知方式 | SUSv3 |'
- en: '| --- | --- | --- |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `SIGEV_NONE` | No notification; monitor timer using *timer_gettime()* | •
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `SIGEV_NONE` | 不通知；使用 *timer_gettime()* 监控定时器 | • |'
- en: '| `SIGEV_SIGNAL` | Send signal *sigev_signo* to process | • |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `SIGEV_SIGNAL` | 向进程发送信号 *sigev_signo* | • |'
- en: '| `SIGEV_THREAD` | Call *sigev_notify_function* as start function of new thread
    | • |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `SIGEV_THREAD` | 调用 *sigev_notify_function* 作为新线程的启动函数 | • |'
- en: '| `SIGEV_THREAD_ID` | Send signal *sigev_signo* to thread *sigev_notify_thread_id*
    |   |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `SIGEV_THREAD_ID` | 向线程 *sigev_notify_thread_id* 发送信号 *sigev_signo* |   |'
- en: 'Further details on the *sigev_notify* field constants, and the fields in the
    *sigval* structure that are associated with each constant value, are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有关*sigev_notify*字段常量的更多详细信息，以及与每个常量值相关的*sigval*结构中的字段，详见以下内容：
- en: '`SIGEV_NONE`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGEV_NONE`'
- en: Don’t provide notification of timer expiration. The process can still monitor
    the progress of the timer using *timer_gettime()*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不提供计时器到期的通知。进程仍然可以使用*timer_gettime()*监控计时器的进度。
- en: '`SIGEV_SIGNAL`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGEV_SIGNAL`'
- en: When the timer expires, generate the signal specified in the *sigev_signo* field
    for the process. The *sigev_value* field specifies data (an integer or a pointer)
    to accompany the signal ([Limits on the number of queued realtime signals](ch22.html#limits_on_the_number_of_queued_real-id1
    "Limits on the number of queued realtime signals")). This data can be retrieved
    via the *si_value* field of the *siginfo_t* structure that is passed to the handler
    for this signal or returned by a call to *sigwaitinfo()* or *sigtimedwait()*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当计时器到期时，为进程生成在*sigev_signo*字段中指定的信号。*sigev_value*字段指定与信号一起传递的数据（一个整数或一个指针）（[实时信号队列数的限制](ch22.html#limits_on_the_number_of_queued_real-id1
    "Limits on the number of queued realtime signals")）。可以通过传递给该信号处理程序的*siginfo_t*结构的*si_value*字段或通过调用*sigwaitinfo()*或*sigtimedwait()*获取此数据。
- en: '`SIGEV_THREAD`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGEV_THREAD`'
- en: When the timer expires, call the function specified in the *sigev_notify_function*
    field. This function is invoked *as if* it were the start function in a new thread.
    The “as if ” wording is from SUSv3, and allows an implementation to generate the
    notifications for a periodic timer either by having each notification delivered
    to a new unique thread or by having the notifications delivered in series to a
    single new thread. The *sigev_notify_attributes* field can be specified as `NULL`
    or as a pointer to a *pthread_attr_t* structure that defines attributes for the
    thread ([Thread Attributes](ch29.html#thread_attributes "Thread Attributes")).
    The union *sigval* value specified in *sigev_value* is passed as the sole argument
    of the function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当计时器到期时，调用在*sigev_notify_function*字段中指定的函数。该函数的调用方式*就像*它是在一个新的线程中的启动函数一样。 “就像”这种表述来源于SUSv3，并允许实现通过将每次通知发送到一个新的唯一线程或将通知按顺序发送到单一的新线程来生成周期性计时器的通知。*sigev_notify_attributes*字段可以指定为`NULL`，或者指定为一个指向*pthread_attr_t*结构的指针，该结构定义了线程的属性（[线程属性](ch29.html#thread_attributes
    "Thread Attributes")）。*sigev_value*字段中指定的联合*sigval*值作为该函数的唯一参数传递。
- en: '`SIGEV_THREAD_ID`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGEV_THREAD_ID`'
- en: This is similar to `SIGEV_SIGNAL`, but the signal is sent to the thread whose
    thread ID matches *sigev_notify_thread_id*. This thread must be in the same process
    as the calling thread. (With `SIGEV_SIGNAL` notification, a signal is queued to
    the process as a whole, and, if there are multiple threads in the process, the
    signal will be delivered to an arbitrarily selected thread in the process.) The
    *sigev_notify_thread_id* field can be set to the value returned by *clone()* or
    the value returned by *gettid()*. The `SIGEV_THREAD_ID` flag is intended for use
    by threading libraries. (It requires a threading implementation that employs the
    `CLONE_THREAD` option, described in [Example program](ch28.html#example_program-id39
    "Example program"). The modern NPTL threading implementation employs `CLONE_THREAD`,
    but the older LinuxThreads threading implementation does not.)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`SIGEV_SIGNAL`类似，但信号被发送到线程ID与*sigev_notify_thread_id*匹配的线程。此线程必须与调用线程位于同一进程中。（使用`SIGEV_SIGNAL`通知时，信号会排队到整个进程，如果进程中有多个线程，则信号将被发送到该进程中任意选择的线程。）*sigev_notify_thread_id*字段可以设置为*clone()*返回的值或*gettid()*返回的值。`SIGEV_THREAD_ID`标志是为线程库使用而设计的。（它需要使用`CLONE_THREAD`选项的线程实现，详见[示例程序](ch28.html#example_program-id39
    "Example program")。现代的NPTL线程实现使用`CLONE_THREAD`，但较旧的LinuxThreads线程实现不使用。）
- en: All of the above constants are specified in SUSv3, except for `SIGEV_THREAD_ID`,
    which is Linux-specific.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 上述所有常量都在SUSv3中定义，除了`SIGEV_THREAD_ID`，它是Linux特有的。
- en: The *evp* argument may be specified as `NULL`, which is equivalent to specifying
    *sigev_notify* as `SIGEV_SIGNAL`, *sigev_signo* as `SIGALRM` (this may be different
    on other systems, since SUSv3 merely says “a default signal number”), and *sigev_value.sival_int*
    as the timer ID.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*evp*参数可以指定为`NULL`，这相当于将*sigev_notify*指定为`SIGEV_SIGNAL`，将*sigev_signo*指定为`SIGALRM`（这在其他系统上可能不同，因为SUSv3仅说“一个默认信号号”），并将*sigev_value.sival_int*指定为计时器ID。'
- en: As currently implemented, the kernel preallocates one queued realtime signal
    structure for each POSIX timer that is created using *timer_create()*. The intent
    of this preallocation is to ensure that at least one such structure is available
    for queuing a signal when the timer expires. This means that the number of POSIX
    timers that may be created is subject to the limitations on the number of realtime
    signals that can be queued (refer to [Realtime Signals](ch22.html#realtime_signals
    "Realtime Signals")).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当前实现中，内核为每个使用*timer_create()*创建的POSIX定时器预分配一个排队的实时信号结构。此预分配的目的是确保至少有一个这样的结构可用于在定时器过期时排队信号。这意味着可以创建的POSIX定时器的数量受限于可排队的实时信号数量（请参阅[实时信号](ch22.html#realtime_signals
    "Realtime Signals")）。
- en: 'Arming and Disarming a Timer: *timer_settime()*'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动和关闭定时器：*timer_settime()*
- en: Once we have created a timer, we can arm (start) or disarm (stop) it using *timer_settime()*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了定时器，就可以使用*timer_settime()*来启动（开始）或关闭（停止）它。
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 成功返回0，失败返回-1。
- en: The *timerid* argument of *timer_settime()* is a timer handle returned by a
    previous call to *timer_create()*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*timer_settime()*的*timerid*参数是之前调用*timer_create()*返回的定时器句柄。'
- en: 'The *value* and *old_value* arguments are analogous to the *setitimer()* arguments
    of the same name: *value* specifies the new settings for the timer, and *old_value*
    is used to return the previous timer settings (see the description of *timer_gettime()*
    below). If we are not interested in the previous settings, we can specify *old_value*
    as `NULL`. The *value* and *old_value* arguments are pointers to *itimerspec*
    structures, defined as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*value*和*old_value*参数类似于同名的*setitimer()*参数：*value*指定定时器的新设置，而*old_value*用于返回之前的定时器设置（请参阅下面关于*timer_gettime()*的描述）。如果我们不关心之前的设置，可以将*old_value*指定为`NULL`。*value*和*old_value*参数是指向*itimerspec*结构的指针，定义如下：'
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Each of the fields of the *itimerspec* structure is in turn a structure of
    type *timespec*, which specifies time values as a number of seconds and nanoseconds:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*itimerspec*结构的每个字段本身都是一个*timespec*类型的结构，指定时间值，单位为秒和纳秒：'
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The *it_value* field specifies when the timer will first expire. If either subfield
    of *it_interval* is nonzero, then this is a periodic timer that, after the initial
    expiry specified by *it_value*, will expire with the frequency specified in these
    subfields. If both subfields of *it_interval* are 0, this timer expires just once.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*it_value*字段指定定时器第一次过期的时间。如果*it_interval*的任一子字段非零，则这是一个周期性定时器，在*it_value*指定的初始过期后，将按照这些子字段中指定的频率过期。如果*it_interval*的两个子字段都为0，则该定时器只会过期一次。'
- en: If *flags* is specified as 0, then *value.it_value* is interpreted relative
    to the clock value at the time of the call to *timer_settime()* (i.e., like *setitimer()*).
    If *flags* is specified as `TIMER_ABSTIME`, then *value.it_value* is interpreted
    as an absolute time (i.e., measured from the clock’s zero point). If that time
    has already passed on the clock, the timer expires immediately.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*flags*指定为0，则*value.it_value*相对于调用*timer_settime()*时的时钟值进行解释（即类似于*setitimer()*）。如果*flags*指定为`TIMER_ABSTIME`，则*value.it_value*被解释为绝对时间（即从时钟的零点开始测量）。如果该时间已经过去，定时器将立即过期。
- en: To arm a timer, we make a call to *timer_settime()* in which either or both
    of the subfields of *value.it_value* are nonzero. If the timer was previously
    armed, *timer_settime()* replaces the previous settings.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动定时器，我们需要调用*timer_settime()*，其中*value.it_value*的一个或两个子字段为非零。如果定时器之前已被启动，*timer_settime()*将替换之前的设置。
- en: If the timer value and interval are not multiples of the resolution of the corresponding
    clock (as returned by *clock_getres()*), these values are rounded up to the next
    multiple of the resolution.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定时器的值和间隔不是相应时钟分辨率的整数倍（由*clock_getres()*返回），这些值会被四舍五入到下一个分辨率的整数倍。
- en: On each expiration of the timer, the process is notified using the method defined
    in the *timer_create()* call that created this timer. If the *it_interval* structure
    contains nonzero values, these values are used to reload the *it_value* structure.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每次定时器过期时，进程会使用在创建此定时器时定义的*timer_create()*调用中的方法进行通知。如果*it_interval*结构包含非零值，这些值将用于重新加载*it_value*结构。
- en: To disarm a timer, we make a call to *timer_settime()* specifying both fields
    of *value.it_value* as 0.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭定时器，我们需要调用*timer_settime()*，将*value.it_value*的两个字段都指定为0。
- en: 'Retrieving the Current Value of a Timer: *timer_gettime()*'
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取定时器的当前值：*timer_gettime()*
- en: The *timer_gettime()* system call returns the interval and remaining time for
    the POSIX timer identified by *timerid*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*timer_gettime()*系统调用返回由*timerid*标识的POSIX定时器的间隔和剩余时间。'
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: The interval and the time until the next expiration of the timer are returned
    in the *itimerspec* structure pointed to by *curr_value*. The *curr_value.it_value*
    field returns the time until next timer expiration, even if this timer was established
    as an absolute timer using `TIMER_ABSTIME`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器的间隔以及下次定时器过期之前的时间将以*itimerspec*结构的形式返回，该结构由*curr_value*指向。即使该定时器是使用`TIMER_ABSTIME`作为绝对定时器创建的，*curr_value.it_value*字段也会返回下次定时器过期之前的时间。
- en: If both fields of the returned *curr_value.it_value* structure are 0, then the
    timer is currently disarmed. If both fields of the returned *curr_value.it_interval*
    structure are 0, then the timer expires just once, at the time given in *curr_value.it_value*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回的*curr_value.it_value*结构的两个字段均为0，则说明定时器当前处于解除状态。如果返回的*curr_value.it_interval*结构的两个字段均为0，则说明定时器只会在*curr_value.it_value*中给定的时间点过期一次。
- en: 'Deleting a Timer: *timer_delete()*'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除定时器：*timer_delete()*
- en: Each POSIX timer consumes a small amount of system resources. Therefore, when
    we have finished using a timer, we should free these resources by using *timer_delete()*
    to remove the timer.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 每个POSIX定时器消耗少量系统资源。因此，当我们使用完定时器后，应通过使用*timer_delete()*来释放这些资源，从而移除定时器。
- en: '[PRE25]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: The *timerid* argument is a handle returned by a previous call to *timer_create()*.
    If the timer was armed, then it is automatically disarmed before removal. If there
    is already a pending signal from an expiration of this timer, that signal remains
    pending. (SUSv3 leaves this point unspecified, so other UNIX implementations may
    behave differently.) Timers are deleted automatically when a process terminates.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*timerid*参数是通过先前调用*timer_create()*返回的句柄。如果定时器已被启用，则在删除之前会自动解除启用。如果该定时器的过期信号尚未处理，则该信号仍处于挂起状态。（SUSv3未指定此行为，因此其他UNIX实现可能表现不同。）定时器在进程终止时会自动删除。'
- en: Notification via a Signal
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过信号通知
- en: 'If we elect to receive timer notifications via a signal, then we can accept
    the signal via a signal handler, or by calling *sigwaitinfo()* or *sigtimedwait()*.
    Both mechanisms allow the receiving process to obtain a *siginfo_t* structure
    ([The `SA_SIGINFO` Flag](ch21.html#the_sa_underscore_siginfo_flag "The SA_SIGINFO
    Flag")) that provides further information about the signal. (To take advantage
    of this feature in a signal handler, we specify the `SA_SIGINFO` flag when establishing
    the handler.) The following fields are set in the *siginfo_t* structure:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择通过信号接收定时器通知，则可以通过信号处理程序接受该信号，或者通过调用*sigwaitinfo()*或*sigtimedwait()*来接收信号。这两种机制都允许接收进程获取一个*siginfo_t*结构（[`SA_SIGINFO`
    标志](ch21.html#the_sa_underscore_siginfo_flag "SA_SIGINFO 标志")），该结构提供了有关信号的更多信息。（要在信号处理程序中利用此功能，我们在建立处理程序时指定`SA_SIGINFO`标志。）以下字段会在*siginfo_t*结构中设置：
- en: '*si_signo*: This field contains the signal generated by this timer.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*si_signo*：此字段包含由该定时器生成的信号。'
- en: '*si_code*: This field is set to `SI_TIMER`, indicating that this signal was
    generated because of the expiration of a POSIX timer.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*si_code*：此字段设置为`SI_TIMER`，表示此信号是由于POSIX定时器过期生成的。'
- en: '*si_value*: This field is set to the value that was supplied in *evp.sigev_value*
    when the timer was created using *timer_create()*. Specifying different *evp.sigev_value*
    values provides a means of distinguishing expirations of multiple timers that
    deliver the same signal.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*si_value*：此字段设置为在使用*timer_create()*创建定时器时，*evp.sigev_value*中提供的值。指定不同的*evp.sigev_value*值可以区分多个定时器的过期情况，这些定时器可能会发送相同的信号。'
- en: When calling *timer_create()*, *evp.sigev_value.sival_ptr* is typically assigned
    the address of the *timerid* argument given in the same call (see [Example 23-5](ch23.html#posix_timer_notification_using_a_signal
    "Example 23-5. POSIX timer notification using a signal")). This allows the signal
    handler (or the *sigwaitinfo()* call) to obtain the ID of the timer that generated
    the signal. (Alternatively, *evp.sigev_value.sival_ptr* may be assigned the address
    of a structure that contains the *timerid* given to *timer_create()*.)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用*timer_create()*时，*evp.sigev_value.sival_ptr*通常会被赋值为同一调用中提供的*timerid*参数的地址（见[示例23-5](ch23.html#posix_timer_notification_using_a_signal
    "示例23-5. 使用信号进行POSIX定时器通知")）。这允许信号处理程序（或*sigwaitinfo()*调用）获取生成该信号的定时器的ID。（或者，*evp.sigev_value.sival_ptr*也可以被赋值为包含*timerid*的结构的地址，该*timerid*是传递给*timer_create()*的。）
- en: 'Linux also supplies the following nonstandard field in the *siginfo_t* structure:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 还在 *siginfo_t* 结构中提供了以下非标准字段：
- en: '*si_overrun*: This field contains the overrun count for this timer (described
    in [Timer Overruns](ch23.html#timer_overruns "Timer Overruns")).'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*si_overrun*: 该字段包含此定时器的超限计数（请参见 [定时器超限](ch23.html#timer_overruns "定时器超限")）。'
- en: Note
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Linux also supplies another nonstandard field: *si_timerid*. This field contains
    an identifier that is used internally by the system to identify the timer (it
    is not the same as the ID returned by *timer_create()*). It is not useful to applications.'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Linux 还提供了另一个非标准字段：*si_timerid*。此字段包含一个标识符，系统内部使用它来标识定时器（与 *timer_create()*
    返回的 ID 不同）。它对应用程序无用。
- en: '[Example 23-5](ch23.html#posix_timer_notification_using_a_signal "Example 23-5. POSIX
    timer notification using a signal") demonstrates the use of signals as the notification
    mechanism for a POSIX timer.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 23-5](ch23.html#posix_timer_notification_using_a_signal "示例 23-5. 使用信号进行
    POSIX 定时器通知") 演示了使用信号作为 POSIX 定时器的通知机制。'
- en: Example 23-5. POSIX timer notification using a signal
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 23-5. 使用信号进行 POSIX 定时器通知
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Each of the command-line arguments of the program in [Example 23-5](ch23.html#posix_timer_notification_using_a_signal
    "Example 23-5. POSIX timer notification using a signal") specifies the initial
    value and interval for a timer. The syntax of these arguments is described in
    the program’s “usage” message and demonstrated in the shell session below. This
    program performs the following steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 23-5](ch23.html#posix_timer_notification_using_a_signal "示例 23-5. 使用信号进行
    POSIX 定时器通知") 中程序的每个命令行参数指定了定时器的初始值和间隔。这些参数的语法在程序的“使用”消息中进行了描述，并在下面的 shell 会话中进行了演示。此程序执行以下步骤：'
- en: Establish a handler for the signal that is used for timer notifications ![](figs/web/U002.png).
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用于定时器通知的信号建立一个处理程序 ![](figs/web/U002.png)。
- en: For each command-line argument, create ![](figs/web/U004.png) and arm ![](figs/web/U005.png)
    a POSIX timer that uses the `SIGEV_SIGNAL` notification mechanism. The *itimerspecFromStr()*
    function that we use to convert ![](figs/web/U003.png)the command-line arguments
    to *itimerspec* structures is shown in [Example 23-6](ch23.html#converting_time-plus-interval_string_to
    "Example 23-6. Converting time-plus-interval string to an itimerspec value").
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个命令行参数，创建 ![](figs/web/U004.png) 并启动 ![](figs/web/U005.png) 一个使用 `SIGEV_SIGNAL`
    通知机制的 POSIX 定时器。我们用来将命令行参数转换为 *itimerspec* 结构的 *itimerspecFromStr()* 函数在 [示例 23-6](ch23.html#converting_time-plus-interval_string_to
    "示例 23-6. 将时间加间隔字符串转换为 itimerspec 值") 中展示。
- en: On each timer expiration, the signal specified in *sev.sigev_signo* will be
    delivered to the process. The handler for this signal displays the value that
    was supplied in *sev.sigev_value.sival_ptr* (i.e., the timer ID, *tidlist[j]*)
    and the overrun value for the timer ![](figs/web/U001.png).
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次定时器到期时，*sev.sigev_signo* 中指定的信号将发送到进程。该信号的处理程序显示在 *sev.sigev_value.sival_ptr*
    中提供的值（即定时器 ID，*tidlist[j]*）和定时器的超限值 ![](figs/web/U001.png)。
- en: Having created and armed the timers, wait for timer expirations by executing
    a loop that repeatedly calls *pause()*![](figs/web/U006.png).
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并启动定时器后，通过执行一个反复调用 *pause()* 的循环来等待定时器到期！[](figs/web/U006.png)。
- en: '[Example 23-6](ch23.html#converting_time-plus-interval_string_to "Example 23-6. Converting
    time-plus-interval string to an itimerspec value") shows the function that converts
    each of the command-line arguments for the program in [Example 23-5](ch23.html#posix_timer_notification_using_a_signal
    "Example 23-5. POSIX timer notification using a signal") into a corresponding
    *itimerspec* structure. The format of the string arguments interpreted by this
    function is shown in a comment at the top of the listing (and demonstrated in
    the shell session below).'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 23-6](ch23.html#converting_time-plus-interval_string_to "示例 23-6. 将时间加间隔字符串转换为
    itimerspec 值") 展示了将 [示例 23-5](ch23.html#posix_timer_notification_using_a_signal
    "示例 23-5. 使用信号进行 POSIX 定时器通知") 中的每个命令行参数转换为相应的 *itimerspec* 结构的函数。此函数解释的字符串参数格式在列表顶部的注释中显示（并在下面的
    shell 会话中进行了演示）。'
- en: Example 23-6. Converting time-plus-interval string to an *itimerspec* value
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 23-6. 将时间加间隔字符串转换为 *itimerspec* 值
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We demonstrate the use of the program in [Example 23-5](ch23.html#posix_timer_notification_using_a_signal
    "Example 23-5. POSIX timer notification using a signal") in the following shell
    session, creating a single timer with an initial timer expiry of 2 seconds and
    an interval of 5 seconds.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[示例 23-5](ch23.html#posix_timer_notification_using_a_signal "示例 23-5. 使用信号的POSIX定时器通知")中的以下Shell会话中演示了该程序的使用，创建了一个初始定时器过期时间为2秒、间隔为5秒的单一定时器。
- en: '[PRE28]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After suspending the program, we pause for a few seconds, allowing several
    timer expirations to occur before we resume the program:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在暂停程序后，我们暂停几秒钟，允许几个定时器过期事件发生，然后再恢复程序：
- en: '[PRE29]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The last line of program output shows that five timer overruns occurred, meaning
    that six timer expirations occurred since the previous signal delivery.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 程序输出的最后一行显示发生了五次定时器溢出，意味着自上次信号传递以来，定时器已过期六次。
- en: Timer Overruns
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定时器溢出
- en: Suppose that we have chosen to receive notification of timer expiration via
    delivery of a signal (i.e., *sigev_notify* is `SIGEV_SIGNAL`). Suppose further
    that the timer expires multiple times before the associated signal is caught or
    accepted. This could occur as the result of a delay before the process is next
    scheduled. Alternatively, it could occur because delivery of the associated signal
    was blocked, either explicitly via *sigprocmask()*, or implicitly during the execution
    of the handler for the signal. How do we know that such *timer overruns* have
    happened?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们选择通过发送信号来接收定时器过期的通知（即，*sigev_notify* 设置为 `SIGEV_SIGNAL`）。进一步假设，在关联的信号被捕获或接收之前，定时器已经过期多次。这可能是因为进程在下一次调度之前有延迟。或者，可能是由于信号的传递被阻塞，阻塞可能是通过
    *sigprocmask()* 显式进行的，也可能是在执行信号处理程序时隐式发生的。那么，我们怎么知道这些 *定时器溢出* 已经发生呢？
- en: 'We might suppose that using a realtime signal would help solve this problem,
    since multiple instances of a realtime signal are queued. However, this approach
    turns out to be unworkable, because there are limits on the number of realtime
    signals that can be queued. Therefore, the POSIX.1b committee decided on a different
    approach: if we choose to receive timer notification via a signal, then multiple
    instances of the signal are never queued, even if we use a realtime signal. Instead,
    after receiving the signal (either via a signal handler or by using *sigwaitinfo()*),
    we can fetch the *timer overrun count*, which is the number of extra timer expirations
    that occurred between the time the signal was generated and the time it was received.
    For example, if the timer has expired three times since the last signal was received,
    then the overrun count is 2.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能认为使用实时信号有助于解决这个问题，因为多个实时信号实例会排队。然而，这种方法最终证明是行不通的，因为有对可排队的实时信号数量的限制。因此，POSIX.1b委员会决定采用不同的方法：如果我们选择通过信号接收定时器通知，那么即使使用实时信号，也永远不会排队多个信号实例。相反，在接收到信号后（无论是通过信号处理程序还是使用
    *sigwaitinfo()*），我们可以获取 *定时器溢出计数*，即在信号生成和接收之间发生的额外定时器过期次数。例如，如果定时器自上次接收到信号以来已经过期三次，那么溢出计数为2。
- en: 'After receiving a timer signal, we can obtain the timer overrun count in two
    ways:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到定时器信号后，我们可以通过两种方式获取定时器溢出计数：
- en: Call *timer_getoverrun()*, which we describe below. This is the SUSv3-specified
    way of obtaining the overrun count.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 *timer_getoverrun()*，我们将在下文中进行说明。这是SUSv3规范的获取溢出计数的方法。
- en: Use the value in the *si_overrun* field of the *siginfo_t* structure returned
    with the signal. This approach saves the overhead of the *timer_getoverrun()*
    system call, but is a nonportable Linux extension.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信号返回的 *siginfo_t* 结构中的 *si_overrun* 字段的值。这种方法节省了 *timer_getoverrun()* 系统调用的开销，但它是一个非移植的Linux扩展。
- en: The timer overrun count is reset each time we receive the timer signal. If the
    timer expired just once since the timer signal was handled or accepted, then the
    overrun count will be 0 (i.e., there were no overruns).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 每次接收到定时器信号时，定时器溢出计数会被重置。如果定时器自上次信号处理或接收以来仅过期了一次，则溢出计数为0（即，没有溢出）。
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns timer overrun count on success, or -1 on error
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回定时器溢出计数，出错时返回-1
- en: The *timer_getoverrun()* function returns the overrun count for the timer specified
    by its *timerid* argument.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*timer_getoverrun()* 函数返回由其 *timerid* 参数指定的定时器的溢出计数。'
- en: The *timer_getoverrun()* function is one of those specified as being async-signal-safe
    in SUSv3 ([Table 21-1](ch21.html#functions_required_to_be_async-signal-sa "Table 21-1. Functions
    required to be async-signal-safe by POSIX.1-1990, SUSv2, and SUSv3"), in [Use
    of *errno* inside signal handlers](ch21.html#use_of_errno_inside_signal_handlers
    "Use of errno inside signal handlers")), so it is safe to call it from within
    a signal handler.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*timer_getoverrun()*函数是SUSv3中规定的异步信号安全函数之一（见[表21-1](ch21.html#functions_required_to_be_async-signal-sa
    "表21-1。POSIX.1-1990、SUSv2和SUSv3中要求具有异步信号安全的函数"), 以及[信号处理程序中的*errno*使用](ch21.html#use_of_errno_inside_signal_handlers
    "信号处理程序中的*errno*使用")），因此可以在信号处理程序中安全地调用。'
- en: Notification via a Thread
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过线程进行通知
- en: 'The `SIGEV_THREAD` flag allows a program to obtain notification of timer expiration
    via the invocation of a function in a separate thread. Understanding this flag
    requires knowledge of POSIX threads that we present later, in [Chapter 29](ch29.html
    "Chapter 29. Threads: Introduction") and [Chapter 30](ch30.html "Chapter 30. Threads:
    Thread Synchronization"). Readers unfamiliar with POSIX threads may want to read
    those chapters before examining the example program that we present in this section.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGEV_THREAD`标志允许程序通过在单独的线程中调用函数来获取定时器到期的通知。理解此标志需要了解POSIX线程，我们将在稍后的[第29章](ch29.html
    "第29章。线程：概述")和[第30章](ch30.html "第30章。线程：线程同步")中介绍这些内容。对于不熟悉POSIX线程的读者，建议在查看本节中的示例程序之前阅读这两章。'
- en: '[Example 23-7](ch23.html#posix_timer_notification_using_a_thread "Example 23-7. POSIX
    timer notification using a thread function") demonstrates the use of `SIGEV_THREAD`.
    This program takes the same command-line arguments as the program in [Example 23-5](ch23.html#posix_timer_notification_using_a_signal
    "Example 23-5. POSIX timer notification using a signal"). The program performs
    the following steps:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例23-7](ch23.html#posix_timer_notification_using_a_thread "示例23-7。使用线程函数的POSIX定时器通知")演示了如何使用`SIGEV_THREAD`。该程序与[示例23-5](ch23.html#posix_timer_notification_using_a_signal
    "示例23-5。使用信号的POSIX定时器通知")中的程序使用相同的命令行参数。该程序执行以下步骤：'
- en: For each command-line argument, the program creates ![](figs/web/U006.png) and
    arms ![](figs/web/U007.png) a POSIX timer that uses the `SIGEV_THREAD` notification
    mechanism ![](figs/web/U003.png).
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个命令行参数，程序会创建![](figs/web/U006.png)，并启用![](figs/web/U007.png)一个使用`SIGEV_THREAD`通知机制的POSIX定时器![](figs/web/U003.png)。
- en: Each time this timer expires, the function specified by *sev.sigev_notify_function*
    ![](figs/web/U004.png) will be invoked in a separate thread. When this function
    is invoked, it receives the value specified in *sev.sigev_value.sival_ptr* as
    an argument. We assign the address of the timer ID (*tidlist[j]*) to this field
    ![](figs/web/U005.png) so that the notification function can obtain the ID of
    the timer that caused its invocation.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当该定时器到期时，*sev.sigev_notify_function*![](figs/web/U004.png)指定的函数将在一个单独的线程中被调用。当该函数被调用时，它将接收*sev.sigev_value.sival_ptr*中指定的值作为参数。我们将定时器ID的地址(*tidlist[j]*)分配给此字段![](figs/web/U005.png)，这样通知函数就可以获取导致其调用的定时器的ID。
- en: Having created and armed all of the timers, the main program enters a loop that
    waits for timer expirations ![](figs/web/U008.png). Each time through the loop,
    the program uses *pthread_cond_wait()* to wait for a condition variable (*cond*)
    to be signaled by the thread that is handling a timer notification.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建并启用所有定时器后，主程序进入一个循环，等待定时器到期![](figs/web/U008.png)。每次循环时，程序使用*pthread_cond_wait()*等待由处理定时器通知的线程发送的条件变量(*cond*)信号。
- en: The *threadFunc()* function is invoked on each timer expiration ![](figs/web/U001.png).
    After printing a message, it increments the value of the global variable *expireCnt*.
    To allow for the possibility of timer overruns, the value returned by *timer_getoverrun()*
    is also added to *expireCnt*. (We explained timer overruns in [Timer Overruns](ch23.html#timer_overruns
    "Timer Overruns") in relation to the `SIGEV_SIGNAL` notification mechanism. Timer
    overruns can also come into play with the `SIGEV_THREAD` mechanism, because a
    timer might expire multiple times before the notification function is invoked.)
    The notification function also signals the condition variable *cond* so that the
    main program knows to check that a timer has expired ![](figs/web/U002.png).
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当定时器到期时，*threadFunc()* 函数会被调用 ![](figs/web/U001.png)。在打印一条消息后，它会增加全局变量 *expireCnt*
    的值。为了考虑定时器溢出的可能性，*timer_getoverrun()* 返回的值也会被加到 *expireCnt* 中。（我们在 [定时器溢出](ch23.html#timer_overruns
    "定时器溢出") 中解释了定时器溢出的概念，并讨论了 `SIGEV_SIGNAL` 通知机制。定时器溢出也可能影响 `SIGEV_THREAD` 机制，因为一个定时器可能在通知函数被调用之前多次到期。）通知函数还会信号条件变量
    *cond*，以便主程序知道该检查定时器是否到期 ![](figs/web/U002.png)。
- en: 'The following shell session log demonstrates the use of the program in [Example 23-7](ch23.html#posix_timer_notification_using_a_thread
    "Example 23-7. POSIX timer notification using a thread function"). In this example,
    the program creates two timers: one with an initial expiry of 5 seconds and an
    interval of 5 seconds, and the other with an initial expiration of 10 seconds
    and an interval of 10 seconds.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shell 会话日志演示了 [示例 23-7](ch23.html#posix_timer_notification_using_a_thread
    "示例 23-7. 使用线程函数进行 POSIX 定时器通知") 中程序的使用。在此示例中，程序创建了两个定时器：一个初始到期时间为 5 秒，间隔为 5 秒；另一个初始到期时间为
    10 秒，间隔为 10 秒。
- en: '[PRE31]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Example 23-7. POSIX timer notification using a thread function
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 23-7. 使用线程函数进行 POSIX 定时器通知
- en: '[PRE32]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Timers That Notify via File Descriptors: The *timerfd* API'
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过文件描述符进行通知的定时器：*timerfd* API
- en: Starting with kernel 2.6.25, Linux provides another API for creating timers.
    The Linux-specific *timerfd* API creates a timer whose expiration notifications
    can be read from a file descriptor. This is useful because the file descriptor
    can be monitored along with other descriptors using *select()*, *poll()*, and
    *epoll* (described in [Chapter 63](ch63.html "Chapter 63. Alternative I/O Models")).
    (With the other timer APIs discussed in this chapter, it requires some effort
    to be able to simultaneously monitor one or more timers along with a set of file
    descriptors.)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核版本 2.6.25 开始，Linux 提供了另一种创建定时器的 API。Linux 特有的 *timerfd* API 创建一个定时器，其到期通知可以从文件描述符中读取。这是有用的，因为可以通过
    *select()*、*poll()* 和 *epoll*（参见 [第 63 章](ch63.html "第 63 章。替代 I/O 模型")）监控该文件描述符与其他描述符一起使用。（对于本章讨论的其他定时器
    API，需要一些额外的工作才能同时监控一个或多个定时器以及一组文件描述符。）
- en: The operation of the three new system calls in this API is analogous to the
    operation of the *timer_create()*, *timer_settime()*, and *timer_gettime()* system
    calls described in Section 23.6.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 该 API 中三个新系统调用的操作类似于第 23.6 节中描述的 *timer_create()*、*timer_settime()* 和 *timer_gettime()*
    系统调用的操作。
- en: The first of the new system calls is *timerfd_create()*, which creates a new
    timer object and returns a file descriptor referring to that object.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 新系统调用中的第一个是 *timerfd_create()*，它创建一个新的定时器对象并返回一个指向该对象的文件描述符。
- en: '[PRE33]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns file descriptor on success, or -1 on error
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回文件描述符，出错时返回-1
- en: The value of *clockid* can be either `CLOCK_REALTIME` or `CLOCK_MONOTONIC` (see
    [Table 23-1](ch23.html#posix.1b_clock_types "Table 23-1. POSIX.1b clock types")).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*clockid* 的值可以是 `CLOCK_REALTIME` 或 `CLOCK_MONOTONIC`（参见 [表 23-1](ch23.html#posix.1b_clock_types
    "表 23-1. POSIX.1b 时钟类型")）。'
- en: 'In the initial implementation of *timerfd_create()*, the *flags* argument was
    reserved for future use and had to be specified as 0\. However, since Linux 2.6.27,
    two flags are supported:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *timerfd_create()* 的初始实现中，*flags* 参数预留供将来使用，必须指定为 0。然而，从 Linux 2.6.27 开始，支持两个标志：
- en: '`TFD_CLOEXEC`'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`TFD_CLOEXEC`'
- en: Set the close-on-exec flag (`FD_CLOEXEC`) for the new file descriptor. This
    flag is useful for the same reasons as the *open()* `O_CLOEXEC` flag described
    in [File descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()").
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为新的文件描述符设置关闭执行标志（`FD_CLOEXEC`）。此标志的作用与[文件描述符号由 *open()* 返回](ch04.html#file_descriptor_number_returned_by-id1
    "文件描述符号由 open() 返回")中描述的 *open()* `O_CLOEXEC` 标志相同。
- en: '`TFD_NONBLOCK`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`TFD_NONBLOCK`'
- en: Set the `O_NONBLOCK` flag on the underlying open file description, so that future
    reads will be nonblocking. This saves additional calls to *fcntl()* to achieve
    the same result.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 设置底层打开文件描述符的 `O_NONBLOCK` 标志，使得未来的读取操作为非阻塞模式。这避免了为实现相同结果而额外调用 *fcntl()*。
- en: When we have finished using a timer created by *timerfd_create()*, we should
    *close()* the associated file descriptor, so that the kernel can free the resources
    associated with the timer.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用完通过 *timerfd_create()* 创建的定时器后，应当 *close()* 关联的文件描述符，以便内核可以释放与定时器相关的资源。
- en: The *timerfd_settime()* system call arms (starts) or disarms (stops) the timer
    referred to by the file descriptor *fd*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*timerfd_settime()* 系统调用启动（开始）或停止（停止）由文件描述符 *fd* 引用的定时器。'
- en: '[PRE34]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1
- en: 'The *new_value* argument specifies the new settings for the timer. The *old_value*
    argument can be used to return the previous settings of the timer (see the description
    of *timerfd_gettime()* below for details). If we are not interested in the previous
    settings, we can specify *old_value* as `NULL`. Both of these arguments are *itimerspec*
    structures that are used in the same way as for *timer_settime()* (see [Arming
    and Disarming a Timer: *timer_settime()*](ch23.html#arming_and_disarming_a_timer_colon_timer
    "Arming and Disarming a Timer: timer_settime()")).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*new_value* 参数指定定时器的新设置。*old_value* 参数可以用于返回定时器的先前设置（详细信息见下面的 *timerfd_gettime()*
    描述）。如果我们不关心先前的设置，可以将 *old_value* 指定为 `NULL`。这两个参数都是 *itimerspec* 结构体，使用方式与 *timer_settime()*
    相同（详见 [定时器的启动和停止：*timer_settime()*](ch23.html#arming_and_disarming_a_timer_colon_timer
    "Arming and Disarming a Timer: timer_settime()")）。'
- en: The *flags* argument is similar to the corresponding argument for *timer_settime()*.
    It may either be 0, meaning that *new_value.it_value* is interpreted relative
    to the time of the call to *timerfd_settime()*, or it can be `TFD_TIMER_ABSTIME`,
    meaning that *new_value.it_value* is interpreted as an absolute time (i.e., measured
    from the clock’s zero point).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*flags* 参数类似于 *timer_settime()* 的对应参数。它可以为 0，表示 *new_value.it_value* 相对于调用
    *timerfd_settime()* 的时间进行解释，或者可以为 `TFD_TIMER_ABSTIME`，表示 *new_value.it_value*
    被解释为绝对时间（即从时钟的零点开始计算）。'
- en: The *timerfd_gettime()* system call returns the interval and remaining time
    for the timer identified by the file descriptor *fd*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*timerfd_gettime()* 系统调用返回由文件描述符 *fd* 标识的定时器的间隔和剩余时间。'
- en: '[PRE35]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1
- en: As with *timer_gettime()*, the interval and the time until the next expiration
    of the timer are returned in the *itimerspec* structure pointed to by *curr_value*.
    The *curr_value.it_value* field returns the time until the next timer expiration,
    even if this timer was established as an absolute timer using `TFD_TIMER_ABSTIME`.
    If both fields of the returned *curr_value.it_value* structure are 0, then the
    timer is currently disarmed. If both fields of the returned *curr_value.it_interval*
    structure are 0, then the timer expires just once, at the time given in *curr_value.it_value*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *timer_gettime()* 一样，定时器的间隔和下次过期时间会返回在 *itimerspec* 结构体中，该结构体由 *curr_value*
    指向。*curr_value.it_value* 字段返回下次定时器过期的时间，即使该定时器是通过 `TFD_TIMER_ABSTIME` 作为绝对定时器建立的。如果返回的
    *curr_value.it_value* 结构体的两个字段都为 0，则表示定时器当前已被解除。如果返回的 *curr_value.it_interval*
    结构体的两个字段都为 0，则定时器只会过期一次，时间为 *curr_value.it_value* 中给定的时间。
- en: Interactions of *timerfd* with *fork()* and *exec()*
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*timerfd* 与 *fork()* 和 *exec()* 的交互'
- en: During a *fork()*, a child process inherits copies of file descriptors created
    by *timerfd_create()*. These file descriptors refer to the same timer objects
    as the corresponding descriptors in the parent, and timer expirations can be read
    in either process.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *fork()* 过程中，子进程会继承 *timerfd_create()* 创建的文件描述符的副本。这些文件描述符指向与父进程中相应描述符相同的定时器对象，并且定时器过期事件可以在任一进程中读取。
- en: File descriptors created by *timerfd_create()* are preserved across an *exec()*
    (unless the descriptors are marked close-on-exec, as described in [File Descriptors
    and *exec()*](ch27.html#file_descriptors_and_exec_open_parenthes "File Descriptors
    and exec()")), and armed timers will continue to generate timer expirations after
    the *exec()*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由 *timerfd_create()* 创建的文件描述符在 *exec()* 跨进程调用时会被保留（除非描述符被标记为 close-on-exec，如
    [文件描述符和 *exec()*](ch27.html#file_descriptors_and_exec_open_parenthes "File Descriptors
    and exec()") 中所述），并且定时器在 *exec()* 后仍会继续生成定时器过期事件。
- en: Reading from the *timerfd* file descriptor
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从 *timerfd* 文件描述符读取
- en: Once we have armed a timer with *timerfd_settime()*, we can use *read()* to
    read information about timer expirations from the associated file descriptor.
    For this purpose, the buffer given to *read()* must be large enough to hold an
    unsigned 8-byte integer (*uint64_t*).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用*timerfd_settime()*启动了定时器，我们可以使用*read()*从关联的文件描述符中读取定时器过期事件的信息。为此，传递给*read()*的缓冲区必须足够大，以容纳一个无符号的8字节整数（*uint64_t*）。
- en: If one or more expirations have occurred since the timer settings were last
    modified using *timerfd_settime()* or the last *read()* was performed, then *read()*
    returns immediately, and the returned buffer contains the number of expirations
    that have occurred. If no timer expirations have occurred, then *read()* blocks
    until the next expiration occurs. It is also possible to use the *fcntl()* `F_SETFL`
    operation ([Open File Status Flags](ch05.html#open_file_status_flags "Open File
    Status Flags")) to set the `O_NONBLOCK` flag for the file descriptor, so that
    reads are nonblocking, and will fail with the error `EAGAIN` if no timer expirations
    have occurred.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自从使用*timerfd_settime()*最后一次修改定时器设置或最后一次执行*read()*以来发生了一个或多个过期事件，那么*read()*会立即返回，返回的缓冲区包含已经发生的过期事件数。如果没有定时器过期事件发生，*read()*则会阻塞，直到下一次过期事件发生。也可以使用*fcntl()*的`F_SETFL`操作（[打开文件状态标志](ch05.html#open_file_status_flags
    "打开文件状态标志")）为文件描述符设置`O_NONBLOCK`标志，这样读取操作就变为非阻塞模式，并在没有定时器过期事件时返回`EAGAIN`错误。
- en: As stated earlier, a *timerfd* file descriptor can be monitored using *select()*,
    *poll()*, and *epoll*. If the timer has expired, then the file descriptor indicates
    as being readable.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，*timerfd*文件描述符可以通过*select()*、*poll()*和*epoll*进行监控。如果定时器已过期，则文件描述符会被标记为可读。
- en: Example program
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 23-8](ch23.html#using_the_timerfd_api "Example 23-8. Using the timerfd
    API") demonstrates the use of the *timerfd* API. This program takes two command-line
    arguments. The first argument is mandatory, and specifies the initial time and
    interval for a timer. (This argument is interpreted using the *itimerspecFromStr()*
    function shown in [Example 23-6](ch23.html#converting_time-plus-interval_string_to
    "Example 23-6. Converting time-plus-interval string to an itimerspec value").)
    The second argument, which is optional, specifies the maximum number of expirations
    of the timer that the program should wait for before terminating; the default
    for this argument is 1.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 23-8](ch23.html#using_the_timerfd_api "示例 23-8. 使用timerfd API")演示了如何使用*timerfd*
    API。这个程序接受两个命令行参数。第一个参数是必需的，指定定时器的初始时间和间隔。（该参数通过[示例 23-6](ch23.html#converting_time-plus-interval_string_to
    "示例 23-6. 将时间加间隔字符串转换为itimerspec值")中展示的*itimerspecFromStr()*函数进行解释。）第二个参数是可选的，指定程序在终止之前应等待的定时器最大过期次数；该参数的默认值是1。'
- en: The program creates a timer using *timerfd_create()*, and arms it using *timerfd_settime()*.
    It then loops, reading expiration notifications from the file descriptor until
    the specified number of expirations has been reached. After each *read()*, the
    program displays the time elapsed since the timer was started, the number of expirations
    read, and the total number of expirations so far.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用*timerfd_create()*创建一个定时器，并使用*timerfd_settime()*进行启动。然后，它进入循环，从文件描述符中读取过期通知，直到达到指定的过期次数。在每次*read()*之后，程序会显示自定时器启动以来经过的时间、已读取的过期次数以及到目前为止的总过期次数。
- en: In the following shell session log, the command-line arguments specify a timer
    with a 1-second initial value and 1-second interval, and a maximum of 100 expirations.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下的shell会话日志中，命令行参数指定了一个初始值为1秒、间隔为1秒且最大过期次数为100的定时器。
- en: '[PRE36]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: From the above output, we can see that multiple timer expirations occurred while
    the program was suspended in the background, and all of these expirations were
    returned on the first *read()* after the program resumed execution.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的输出可以看出，当程序在后台挂起时，发生了多个定时器过期事件，并且这些过期事件在程序恢复执行后的第一次*read()*中全部返回。
- en: Example 23-8. Using the *timerfd* API
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 23-8. 使用*timerfd* API
- en: '[PRE37]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: A process can use *setitimer()* or *alarm()* to set a timer, so that it receives
    a signal after the passage of a specified amount of real or process time. One
    use of timers is to set an upper limit on the time for which a system call can
    block.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以使用*setitimer()*或*alarm()*设置定时器，以便在经过指定的真实时间或进程时间后接收到信号。定时器的一种用途是设置系统调用的阻塞时间上限。
- en: Applications that need to suspend execution for a specified interval of real
    time can use a variety of sleep functions for this purpose.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在指定的实际时间间隔内暂停执行的应用程序可以使用多种休眠函数来实现这一目的。
- en: 'Linux 2.6 implements the POSIX.1b extensions that define an API for high-precision
    clocks and timers. POSIX.1b timers provide a number of advantages over traditional
    (*setitimer()*) UNIX timers. We can: create multiple timers; choose the signal
    that is delivered on timer expiration; retrieve the timer overrun count in order
    to determine if a timer has expired multiple times since the last expiration notification;
    and choose to receive timer notifications via execution of a thread function instead
    of delivery of a signal.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 2.6 实现了 POSIX.1b 扩展，定义了一个用于高精度时钟和定时器的 API。POSIX.1b 定时器相比传统的 (*setitimer()*)
    UNIX 定时器提供了许多优点。我们可以：创建多个定时器；选择定时器过期时发送的信号；获取定时器溢出次数，以确定定时器是否自上次过期通知以来已过期多次；并选择通过执行线程函数而不是发送信号来接收定时器通知。
- en: The Linux-specific *timerfd* API provides a set of interfaces for creating timers
    that is similar to the POSIX timers API, but allows timer notifications to be
    read via a file descriptor. This file descriptor can be monitored using *select()*,
    *poll()*, and *epoll*.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 特定的 *timerfd* API 提供了一组用于创建定时器的接口，这些接口类似于 POSIX 定时器 API，但允许通过文件描述符读取定时器通知。可以使用
    *select()*、*poll()* 和 *epoll* 来监视该文件描述符。
- en: Further information
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步的信息
- en: Under the rationale for individual functions, SUSv3 provides useful notes on
    the (standard) timer and sleep interface described in this chapter. [Gallmeister,
    1995] discusses POSIX.1b clocks and timers.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 根据各个函数的原理，SUSv3 提供了关于本章描述的（标准）定时器和休眠接口的有用说明。[Gallmeister, 1995] 讨论了 POSIX.1b
    时钟和定时器。
- en: Exercises
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Although *alarm()* is implemented as a system call within the Linux kernel,
    this is redundant. Implement *alarm()* using *setitimer()*.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管 *alarm()* 是作为 Linux 内核中的系统调用实现的，但这是多余的。使用 *setitimer()* 来实现 *alarm()*。
- en: 'Try running the program in [Example 23-3](ch23.html#using_nanosleep_open_parenthesis_close_p
    "Example 23-3. Using nanosleep()") (`t_nanosleep.c`) in the background with a
    60-second sleep interval, while using the following command to send as many `SIGINT`
    signals as possible to the background process:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在后台运行程序 [Example 23-3](ch23.html#using_nanosleep_open_parenthesis_close_p
    "Example 23-3. 使用 nanosleep()") (`t_nanosleep.c`)，并使用以下命令向后台进程发送尽可能多的 `SIGINT`
    信号，同时设置 60 秒的休眠间隔：
- en: '[PRE38]; done`'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE38]; done`'
- en: '```'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '```'
- en: You should observe that the program sleeps rather longer than expected. Replace
    the use of *nanosleep()* with the use of *clock_gettime()* (use a `CLOCK_REALTIME`
    clock) and *clock_nanosleep()* with the `TIMER_ABSTIME` flag. (This exercise requires
    Linux 2.6.) Repeat the test with the modified program and explain the difference.
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该观察到程序的休眠时间比预期的要长。将 *nanosleep()* 替换为 *clock_gettime()*（使用 `CLOCK_REALTIME`
    时钟）和 *clock_nanosleep()*（使用 `TIMER_ABSTIME` 标志）。(此练习需要 Linux 2.6。) 使用修改后的程序重复测试，并解释差异。
- en: Write a program to show that if the *evp* argument to *timer_create()* is specified
    as `NULL`, then this is equivalent to specifying *evp* as a pointer to a *sigevent*
    structure with *sigev_notify* set to `SIGEV_SIGNAL`, *sigev_signo* set to `SIGALRM`,
    and *si_value.sival_int* set to the timer ID.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，展示如果 *timer_create()* 的 *evp* 参数指定为 `NULL`，则等同于指定 *evp* 为指向一个 *sigevent*
    结构体的指针，其中 *sigev_notify* 设置为 `SIGEV_SIGNAL`，*sigev_signo* 设置为 `SIGALRM`，并且 *si_value.sival_int*
    设置为定时器 ID。
- en: Modify the program in [Example 23-5](ch23.html#posix_timer_notification_using_a_signal
    "Example 23-5. POSIX timer notification using a signal") (`ptmr_sigev_signal.c`)
    to use *sigwaitinfo()* instead of a signal handler.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改程序 [Example 23-5](ch23.html#posix_timer_notification_using_a_signal "Example
    23-5. 使用信号进行 POSIX 定时器通知") (`ptmr_sigev_signal.c`)，使用 *sigwaitinfo()* 代替信号处理程序。
