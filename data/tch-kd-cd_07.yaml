- en: 'Chapter 7. Functions: There’s a Name for That'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：函数——有个名字
- en: We’ve made use of a number of *functions* so far— everything from `print()`
    to `input()` to `turtle.forward()`. But all of these functions have been either
    built-in or imported from Python modules and libraries. In this chapter, we’ll
    write our *own* functions to do anything we want, including responding to user
    actions like mouse-clicking and keypresses.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了许多*函数*——从`print()`到`input()`，再到`turtle.forward()`。但这些函数都是内置的或者从Python模块和库中导入的。在本章中，我们将编写自己的*函数*，做任何我们想做的事情，包括响应用户操作，比如鼠标点击和按键。
- en: 'Functions are helpful because they give us the ability to organize pieces of
    reusable code, then refer to those pieces later in our programs by a single short
    name or command. Take `input()` as an example: it prints a text prompt to ask
    a user for input, collects what the user types, and passes it to our program as
    a string that we can store in a variable. We reuse the `input()` function anytime
    we want to know something more from the user. If we didn’t have this function,
    we might have to do all that work ourselves every time we wanted to ask the user
    for information.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数很有用，因为它们赋予我们组织可重用代码片段的能力，然后通过一个简短的名称或命令在程序中引用这些片段。以`input()`为例：它打印一个文本提示，询问用户输入，收集用户输入的内容，并将其作为字符串传递给我们的程序，我们可以将其存储在一个变量中。每次我们想从用户那里获取更多信息时，都可以重复使用`input()`函数。如果没有这个函数，每次我们想询问用户信息时，可能都需要自己做这些工作。
- en: 'The `turtle.forward()` function is another great visual example: every time
    we move the turtle forward to draw one of the sides of our spirals, Python draws
    one pixel at a time in the direction our turtle is currently heading on the screen,
    to the exact length we ask for. If we didn’t have the `turtle.forward()` function,
    we would have to figure out how to color pixels on the screen, keep track of locations
    and angles, and do some fairly complex math to draw a certain distance every time.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`turtle.forward()`函数是另一个很好的视觉示例：每当我们将乌龟向前移动以绘制螺旋的某一边时，Python会在屏幕上按我们要求的精确长度，逐个像素地绘制，并朝着我们当前设置的方向前进。如果没有`turtle.forward()`函数，我们就需要搞清楚如何在屏幕上着色像素，跟踪位置和角度，并进行一些相当复杂的数学运算来绘制每次所需的距离。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188945.png.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![没有说明的图片](httpatomoreillycomsourcenostarchimages2188945.png.jpg)'
- en: Without these functions, our programs would be longer, harder to read, and harder
    to write. Functions let us take advantage of the previous programming work of
    lots of fellow coders. The good news is that we can also write our own functions
    to make our code shorter, easier to read, and more reusable.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这些函数，我们的程序将变得更长、更难以阅读，也更难编写。函数让我们能够利用许多其他程序员之前的编程工作。好消息是，我们也可以编写自己的函数，使我们的代码更简短、更易读且更具可重用性。
- en: 'In [Chapter 6](ch06.html "Chapter 6. Random Fun and Games: Go Ahead, Take a
    Chance!"), we built programs that drew random spirals and a kaleidoscope pattern.
    We can use functions to make the code in these programs easier to read and to
    make parts of the code more reusable.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章：随机趣味与游戏：大胆尝试！")中，我们编写了绘制随机螺旋和万花筒图案的程序。我们可以使用函数来使这些程序中的代码更易读，并使代码的某些部分更具可重用性。
- en: Putting Things Together with Functions
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数将内容组合起来
- en: Look back at [RandomSpirals.py](ch06.html#randomspiralsdotpy "RandomSpirals.py").
    Everything in the first `for` loop is the code to create just one random spiral.
    The `for` loop uses that code to draw 50 spirals of random color, size, and location.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下[RandomSpirals.py](ch06.html#randomspiralsdotpy "RandomSpirals.py")。第一个`for`循环中的所有代码都是用来创建一个随机螺旋的。这个`for`循环利用这些代码绘制了50个随机颜色、大小和位置的螺旋。
- en: Say we want to use that random spiral code in another program, like a game or
    a screensaver app. In *RandomSpirals.py*, it’s not easy to tell where the actual
    spiral drawing starts or stops, and we just wrote that code a few pages ago. Imagine
    coming back to this program in three months! We would have a hard time figuring
    out what the app is supposed to do and which lines we need to copy over into a
    new program if we want to draw random spirals again.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在另一个程序中使用那个随机螺旋代码，比如一个游戏或者屏幕保护程序。在*RandomSpirals.py*中，我们很难看出实际的螺旋绘制是从哪里开始或结束的，而我们几页前才写了那段代码。想象一下三个月后再回到这个程序！我们会很难弄清楚这个应用程序的功能是什么，以及如果我们想再次绘制随机螺旋，哪些代码行需要复制到新程序中。
- en: To make a piece of code reusable later, or just easier to read now, we can *define
    a function* and give it an easy-to-understand name, just like `input()` or `turtle.forward()`.
    Defining a function is also called [*declaring*](apd.html#gloss01_016) the function,
    and it just means that we’re telling the computer what we want the function to
    do. Let’s create a function to draw a random spiral on the screen; we’ll call
    it `random_spiral()`. We can reuse this function anytime we want to draw random
    spirals, in any program.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一段代码以后可以重用，或者让它现在更容易阅读，我们可以*定义一个函数*并给它一个易于理解的名字，就像`input()`或`turtle.forward()`一样。定义一个函数也叫做[*声明*](apd.html#gloss01_016)函数，它意味着我们告诉计算机我们希望函数做什么。让我们创建一个在屏幕上绘制随机螺旋的函数；我们称它为`random_spiral()`。我们可以在任何程序中随时重用这个函数来绘制随机螺旋。
- en: Defining Random_Spiral()
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 Random_Spiral()
- en: 'Open *RandomSpirals.py* ([Chapter 6](ch06.html "Chapter 6. Random Fun and Games:
    Go Ahead, Take a Chance!")), save it as a new file called *RandomSpiralsFunction.py*,
    and begin this function definition *after* setting up the turtle’s pen, speed,
    and colors but *before* the `for` loop. (You can refer to the final program in
    [RandomSpiralsFunction.py](ch07.html#randomspiralsfunctiondotpy "RandomSpiralsFunction.py")
    to see how this should look.) Our definition of `random_spiral()` should go after
    the turtle setup because the function will need to use the turtle pen `t` and
    the list of colors. The definition should go before the `for` loop because we’ll
    be using `random_spiral()` in the `for` loop, and you have to define a function
    before you can use it. Now that we’ve found the right place in our program, let’s
    start defining the `random_spiral()` function.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*RandomSpirals.py*（[第6章](ch06.html "第6章. 随机趣味与游戏：去吧，冒个险！")），将其另存为一个名为*RandomSpiralsFunction.py*的新文件，并在设置海龟的笔、速度和颜色之后但在`for`循环之前开始定义这个函数。（你可以参考最终的程序[RandomSpiralsFunction.py](ch07.html#randomspiralsfunctiondotpy
    "RandomSpiralsFunction.py")，看看它应该是什么样子的。）我们将`random_spiral()`的定义放在海龟设置之后，因为这个函数需要使用海龟笔`t`和颜色列表。定义应该放在`for`循环之前，因为我们将在`for`循环中使用`random_spiral()`，你必须先定义函数才能使用它。现在我们已经找到了程序中的正确位置，让我们开始定义`random_spiral()`函数吧。
- en: 'We define a function in Python using the keyword `def` (short for *definition*),
    followed by the name of the function, parentheses `()`, and a colon (`:`). Here’s
    the first line of the `random_spiral()` function we’ll build:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用关键字`def`（即*定义*的缩写）来定义一个函数，后面跟着函数的名称、括号`()`和冒号（`:`）。这是我们将要构建的`random_spiral()`函数的第一行：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The rest of the function definition will be one or more statements, indented
    from the left, just like when we grouped statements in our `for` loops. To draw
    a random spiral, we need to set a random color, a random size, and a random (*x*,
    *y*) location on the screen, and then move the pen there and draw the spiral.
    Here’s the code to complete our `random_spiral()` function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的函数定义将是一个或多个语句，从左侧缩进，就像我们在`for`循环中分组语句一样。为了绘制一个随机螺旋，我们需要设置一个随机颜色、随机大小和一个随机的(*x*,
    *y*)位置，然后将笔移动到那里并绘制螺旋。下面是完成我们`random_spiral()`函数的代码：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the computer doesn’t actually *run* the code when the function is
    being defined. If we type the function definition into IDLE, we won’t get a spiral—yet.
    To actually draw a spiral, we need to call the `random_spiral()` function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当函数被定义时，计算机并不会*运行*这段代码。如果我们在IDLE中输入函数定义，我们不会得到螺旋图形——还没有。要实际绘制螺旋，我们需要调用`random_spiral()`函数。
- en: Calling Random_Spiral()
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用 Random_Spiral()
- en: 'A function definition tells the computer what we want to do when someone actually
    calls the function. After defining a function, we *call* it in our program using
    the function’s name followed by parentheses:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义告诉计算机当有人实际调用函数时我们希望做什么。在定义了一个函数后，我们可以在程序中使用函数名后面跟上括号来*调用*它：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ve got to remember the parentheses, because that tells the computer you
    want to run the function. Now that we’ve defined `random_spiral()` as a function,
    when we call `random_spiral()` like this in our program, we’ll get a random spiral
    drawn on a turtle screen.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须记住括号，因为它告诉计算机你想要运行这个函数。现在我们已经将`random_spiral()`定义为一个函数，当我们在程序中像这样调用`random_spiral()`时，计算机将在海龟屏幕上绘制一个随机的螺旋。
- en: 'Now, to draw 50 random spirals, instead of using all the code in *RandomSpirals.py*,
    we can shorten our `for` loop to this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了绘制50个随机螺旋，我们可以简化`for`循环，而不是使用*RandomSpirals.py*中的所有代码：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This loop is easier to read, thanks to our use of a function that we built all
    by ourselves. We’ve made our code easier to understand, and we can easily move
    the random spiral code over into another program by copying and pasting the function
    definition.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了自己构建的函数，这个循环更容易阅读。我们让代码更易于理解，并且通过复制和粘贴函数定义，可以轻松地将随机螺旋代码移到另一个程序中。
- en: Here’s the whole program together; type this into IDLE and save it as *RandomSpiralsFunction.py*
    or download it from *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的程序；将其输入到 IDLE 中并保存为 *RandomSpiralsFunction.py*，或者从 *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    下载。
- en: RandomSpiralsFunction.py
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RandomSpiralsFunction.py
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In addition to a more readable program, we also get a reusable `random_spiral()`
    function that we can copy, modify, and easily use in other programs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更易读的程序，我们还得到了一个可重用的 `random_spiral()` 函数，我们可以将其复制、修改并轻松地在其他程序中使用。
- en: If you find yourself reusing a chunk of code again and again, convert it into
    a function like we did with `random_spiral()` using `def`, and you’ll find it
    much easier to *port* the code—that is, carry it over and reuse it—into new applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己一次又一次地重复使用一段代码，将其转换成一个函数，就像我们用 `def` 定义的 `random_spiral()` 函数那样，你会发现将代码*移植*（即携带并在新应用中重用）到其他应用程序会更容易。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can even create your own module full of functions and import your module
    just like we’ve imported `turtle` and `random` in our programs (see Appendix C
    on how to create a module in Python). That way you can share your code with friends.*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*你甚至可以创建自己的模块，里面充满了函数，并像我们在程序中导入 `turtle` 和 `random` 一样导入你的模块（有关如何在 Python
    中创建模块，请参见附录 C）。这样，你可以与朋友分享你的代码。*'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188947.png.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188947.png.jpg)'
- en: 'Parameters: Feeding Your Function'
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数：为你的函数提供信息
- en: When creating a function, we can define [*parameters*](apd.html#gloss01_037)
    for that function. Parameters allow us to send information to the function by
    passing values to it as *arguments* inside its parentheses. We’ve been passing
    arguments to functions since our first `print()` statement. When we code `print("Hello")`,
    `"Hello"` is an argument representing the string value that we want printed to
    the screen. When we call the turtle function `t.left(90)`, we’re passing the value
    `90` as the number of degrees we want our turtle to turn left.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建函数时，我们可以为该函数定义 [*参数*](apd.html#gloss01_037)。参数允许我们通过将值作为 *参数* 传递给函数的括号，将信息传递给函数。从我们第一次使用
    `print()` 语句开始，我们就一直在给函数传递参数。当我们编写 `print("Hello")` 时，`"Hello"` 是一个代表我们希望在屏幕上打印的字符串值的参数。当我们调用海龟函数
    `t.left(90)` 时，我们传递了值 `90`，表示我们希望海龟向左转 90 度。
- en: The `random_spiral()` function didn’t need parameters. All the information it
    needed was in the code inside the function. But if we want, functions that we
    build can take information in the form of parameters. Let’s define a function,
    `draw_smiley()`, to draw a smiley face at a random location on the screen. This
    function will take a pair of random coordinates and draw the smiley face at those
    coordinates. We’ll define and call `draw_smiley()` in a program called *RandomSmileys.py*.
    The complete program is shown in [Putting it all together](ch07.html#putting_it_all_together-id00013
    "Putting it all together")— but let’s build it step by step.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`random_spiral()` 函数不需要参数。它所需的所有信息都在函数内部的代码中。但如果我们愿意，可以让我们构建的函数接受参数形式的信息。让我们定义一个函数
    `draw_smiley()`，它将在屏幕上的随机位置画一个笑脸。这个函数将接受一对随机坐标，并在这些坐标处绘制笑脸。我们将在一个名为 *RandomSmileys.py*
    的程序中定义并调用 `draw_smiley()`。完整程序见 [Putting it all together](ch07.html#putting_it_all_together-id00013
    "Putting it all together") —— 但让我们一步步构建它。'
- en: Smileys at Random Locations
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机位置的笑脸
- en: 'We want to write a program that, rather than drawing random spirals, draws
    smiley faces. It’ll take a bit more planning to draw a smiley face than it did
    to randomly pick a color and size and draw a spiral. Let’s go back to our friend
    from [Chapter 6](ch06.html "Chapter 6. Random Fun and Games: Go Ahead, Take a
    Chance!"), a piece of graph paper. Because we haven’t drawn something as complicated
    as a smiley face in our programs before, it’s best to draw this on paper first
    and then translate it into code, one part at a time. [Figure 7-1](ch07.html#weapostrophere_planning_our_program_by_d
    "Figure 7-1. We’re planning our program by drawing a smiley face on graph paper
    first.") shows a smiley face on a graph-paper grid that we can use to plan our
    drawing.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想编写一个程序，它不仅仅是画随机的螺旋，而是画笑脸。画笑脸比随机选一个颜色和大小然后画螺旋要多一些规划。让我们回到[第6章](ch06.html "第6章.
    随机的乐趣与游戏：大胆一试！")，一张图表纸。因为我们以前的程序没有画过像笑脸这样复杂的东西，最好先在纸上画出来，然后再逐步转化为代码。[图7-1](ch07.html#weapostrophere_planning_our_program_by_d
    "图7-1. 我们首先通过在图表纸上画一个笑脸来规划我们的程序。")展示了一个笑脸的图表纸网格，我们可以用它来规划我们的绘图。
- en: Our program will draw smileys like this one all over the screen at random (*x*,
    *y*) coordinates. The function definition for `draw_smiley()` will take two parameters,
    `x` and `y`, for the location where the smiley is to be drawn. As shown in [Figure 7-1](ch07.html#weapostrophere_planning_our_program_by_d
    "Figure 7-1. We’re planning our program by drawing a smiley face on graph paper
    first."), we will draw the smiley face as if it were sitting on the (*x*, *y*)
    location, so picture moving this smiley face template around by placing its origin
    (0, 0) over any other point (*x*, *y*) on the screen. Let’s figure out how to
    draw each smiley face starting from a given point.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序将像这样在屏幕上的随机(*x*, *y*)坐标处画笑脸。`draw_smiley()`的函数定义将接受两个参数，`x`和`y`，表示笑脸要画在的位置。如[图7-1](ch07.html#weapostrophere_planning_our_program_by_d
    "图7-1. 我们首先通过在图表纸上画一个笑脸来规划我们的程序。")所示，我们将把笑脸画得仿佛它坐落在(*x*, *y*)的位置，所以可以想象将这个笑脸模板移动到屏幕上的任何其他点(*x*,
    *y*)，将它的原点(0, 0)放置在那个点上。让我们从给定的点开始，逐步弄清楚如何画出每个笑脸。
- en: '![We’re planning our program by drawing a smiley face on graph paper first.](httpatomoreillycomsourcenostarchimages2188949.png.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![我们首先通过在图表纸上画一个笑脸来规划我们的程序。](httpatomoreillycomsourcenostarchimages2188949.png.jpg)'
- en: Figure 7-1. We’re planning our program by drawing a smiley face on graph paper
    first.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-1. 我们首先通过在图表纸上画一个笑脸来规划我们的程序。
- en: Drawing a head
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 画一个头部
- en: Each smiley face has a yellow circle for the head, two small blue circles for
    eyes, and some black lines for the mouth. Given a point on the screen, our `draw_smiley()`
    function will need to draw a head, eyes, and a mouth at the correct positions
    relative to the given point. To figure out the code that will go in our function
    definition, let’s plan the head, eyes, and mouth separately, starting with the
    head. We’ll draw the head first so that it doesn’t cover the eyes and mouth we’ll
    draw next.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个笑脸的头部是一个黄色的圆圈，眼睛是两个小蓝色圆圈，嘴巴是一些黑色的线条。给定屏幕上的一个点，我们的`draw_smiley()`函数需要在相对于给定点的正确位置画出头部、眼睛和嘴巴。为了弄清楚放入函数定义中的代码，让我们先单独规划头部、眼睛和嘴巴，从头部开始。我们先画头部，这样它就不会遮挡接下来要画的眼睛和嘴巴。
- en: We’ll count each grid line in [Figure 7-1](ch07.html#weapostrophere_planning_our_program_by_d
    "Figure 7-1. We’re planning our program by drawing a smiley face on graph paper
    first.") as 10 pixels, so the smiley we’ve drawn would measure 100 pixels tall;
    that will equal around an inch, give or take, on most computer screens. Since
    the *diameter*, or height and width, of the circle is 100 pixels, that means it
    has a *radius* (one-half the diameter) of 50 pixels. We need the radius because
    the `turtle` module’s `circle()` command takes the radius as its parameter. The
    command to draw a circle with a radius of 50 (which makes a diameter of 100) is
    `t.circle(50)`. The `circle()` function draws a circle directly above the turtle’s
    current (*x*, *y*) location. We’ll need to know this to correctly place the eyes
    and mouth, so I’ve drawn my smiley face with the bottom edge resting on the origin,
    (0, 0). We can figure out where we need to draw everything else by adding the
    coordinates of each part to that starting (*x*, *y*) location of (0, 0).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将图中的每条网格线视为10像素，因此我们绘制的笑脸的高度将是100像素；在大多数计算机屏幕上，这大约等于一英寸。由于圆形的*直径*，即高度和宽度，都是100像素，这意味着它的*半径*（直径的一半）是50像素。我们需要半径，因为`Turtle`模块的`circle()`命令需要半径作为参数。绘制半径为50（即直径为100）的圆形的命令是`t.circle(50)`。`circle()`函数会在海龟当前的(*x*,
    *y*)位置正上方绘制一个圆形。我们需要知道这一点，以便正确地放置眼睛和嘴巴，因此我将我的笑脸画在底边与原点(0, 0)对齐的位置。我们可以通过将每个部分的坐标加到起始(*x*,
    *y*)位置(0, 0)来确定其他部分的位置。
- en: 'To draw the big yellow head, we’ll make the pen color yellow, make the fill
    color yellow, turn on the paint fill for our shape, draw the circle (which gets
    filled with yellow because we turned on the paint fill), and turn off the paint
    fill when we’re done. Assuming we have a turtle pen named `t` defined earlier
    in the program, the code to draw the yellow circle as the head of our smiley face
    at the current (*x*, *y*) location looks like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了画出大黄头，我们将画笔颜色设置为黄色，填充颜色也设置为黄色，启用图形的油漆填充功能，画出圆形（由于启用了油漆填充，圆形会被填充为黄色），完成后关闭油漆填充功能。假设我们在程序中已经定义了一个名为`t`的海龟画笔，绘制笑脸的黄色圆头的代码看起来是这样的：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To fill the circle with yellow, we add four lines of code around our `t.circle(50)`
    command. First, we set the pen color to yellow with `t.pencolor("yellow")`. Second,
    we set the fill color with `t.fillcolor("yellow")`. Third, before we call the
    `t.circle(50)` command to draw the face of our smiley, we tell the computer that
    we want to fill the circle we’re drawing. We do this with the `t.begin_ fill()`
    function. Finally, after we draw our circle, we call the `t.end_fill()` function
    to tell the computer that we’re done with the shape that we want to fill with
    color.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了用黄色填充圆形，我们在`t.circle(50)`命令周围加上四行代码。首先，我们使用`t.pencolor("yellow")`设置画笔颜色为黄色。其次，我们用`t.fillcolor("yellow")`设置填充颜色。接着，在调用`t.circle(50)`命令绘制笑脸的圆形之前，我们告诉计算机我们希望填充所绘制的圆形。我们通过`t.begin_fill()`函数来实现。最后，绘制圆形后，我们调用`t.end_fill()`函数，告诉计算机我们已经完成了填充的形状。
- en: Drawing eyes
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制眼睛
- en: First, we need to figure out where to position the turtle to draw the left eye
    in the correct place, then set the fill color to blue, and finally draw a circle
    of the correct size. The eyes are about 20 pixels (two grid lines) tall, and we
    know that a diameter of 20 means that we need a radius of half that amount, or
    10, so we’ll use the `t.circle(10)` command to draw each eye. The tricky part
    is deciding where to draw them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确定海龟的位置，以便在正确的位置绘制左眼，然后将填充颜色设置为蓝色，最后绘制正确大小的圆形。眼睛大约是20像素（两条网格线）高，我们知道直径为20意味着半径是直径的一半，即10，因此我们将使用`t.circle(10)`命令绘制每只眼睛。难点是确定它们应该画在什么位置。
- en: Our (*x*, *y*) starting point will be the local origin of each smiley face,
    and you can locate the left eye in [Figure 7-1](ch07.html#weapostrophere_planning_our_program_by_d
    "Figure 7-1. We’re planning our program by drawing a smiley face on graph paper
    first."). It looks like it starts about 6 grid lines above the origin (60 pixels
    up, in the positive y-direction), and it’s sitting about 1.5 grid lines to the
    left of the y-axis (or about 15 pixels left, in the negative x-direction).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的（*x*, *y*）起点将是每个笑脸的局部原点，你可以在[图7-1](ch07.html#weapostrophere_planning_our_program_by_d
    "图7-1. 我们通过先在图表纸上绘制笑脸来规划我们的程序。")中找到左眼的位置。它看起来大约从原点上方6个网格线开始（即向上60个像素，沿y轴正方向），并且它位于y轴的左侧1.5个网格线处（或约15个像素，沿x轴负方向）。
- en: 'To tell our program how to get to the right place to draw the left eye, starting
    from the bottom of the big yellow circle at a given (*x*, *y*) passed to our function
    as a pair of arguments, we need to start at *x* and move left 15 pixels, start
    at *y* and move up 60 pixels, or move to `(x-15, y+60)`. So, calling `t.setpos(x-15,
    y+60)` should put the turtle where we need to start drawing our left eye. Here’s
    the code for the left eye:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉我们的程序如何到达正确的位置以绘制左眼，从大黄色圆圈的底部开始，给定的（*x*, *y*）作为一对参数传递给我们的函数，我们需要从*x*开始，向左移动15个像素，向上移动60个像素，或者移动到`(x-15,
    y+60)`。因此，调用`t.setpos(x-15, y+60)`应该会将乌龟放到我们需要开始绘制左眼的位置。以下是左眼的代码：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An easy mistake might be writing the `setpos` command with just (–15, 60) as
    arguments, but remember that we want to draw lots of smiley faces at various (*x*,
    *y*) positions on the screen; not all the faces will begin at (0, 0). The command
    `t.setpos(x-15, y+60)` will make sure that wherever our yellow face is being drawn,
    our left eye will be in the upper left of that face.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是将`setpos`命令写成仅用（–15, 60）作为参数，但请记住，我们希望在屏幕上的不同（*x*, *y*）位置绘制多个笑脸；并不是所有的笑脸都会从（0,
    0）开始。命令`t.setpos(x-15, y+60)`可以确保无论我们在绘制哪个黄色的笑脸，我们的左眼都会出现在那个笑脸的左上方。
- en: 'The code to draw the right eye is almost identical to the code for drawing
    the left eye. We can see that the right eye is 15 pixels (1.5 grid lines) to the
    right of our (*x*, *y*) location, and still 60 pixels up. The command `t.setpos(x+15,
    y+60)` should place the eye symmetrically. Here’s the code for the right eye:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制右眼的代码几乎与绘制左眼的代码相同。我们可以看到，右眼距离我们的位置（*x*, *y*）向右偏移了15个像素（1.5个网格线），并且仍然是向上偏移了60个像素。命令`t.setpos(x+15,
    y+60)`应该能使右眼对称地放置。以下是右眼的代码：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The fill color is still blue from the left eye, so we just have to set the turtle
    to the correct position `(x+15, y+60)`, turn the fill on, draw the eye, and finish
    filling it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 填充颜色仍然是左眼的蓝色，所以我们只需将乌龟移动到正确的位置`(x+15, y+60)`，打开填充，绘制眼睛，并完成填充。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188951.png.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188951.png.jpg)'
- en: Drawing a mouth
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制嘴巴
- en: 'Now let’s plan the most important part of the smiley face: the smile. To make
    the smile simpler, we’re going to draw the mouth with just three thick, black
    lines. The left side of the mouth looks like it starts about 2.5 grid lines to
    the left of and 4 grid lines above our point (*x*, *y*), so we’ll position the
    turtle at `(x-25, y+40)` to start drawing the smile. We’ll set the pen color to
    black and the width to 10 so that the smile is thick and easy to see. From the
    upper-left corner of the smile, we need to go to `(x-10, y+20)`, then to `(x+10,
    y+20)`, and finally to the upper-right corner of the smile at `(x+25, y+40)`.
    Notice that these pairs of points are mirror images of one another across the
    y-axis; this makes our smiley face nice and even.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们规划笑脸上最重要的部分：微笑。为了简化微笑的绘制，我们将用三条粗黑线来绘制嘴巴。嘴巴的左边看起来大约从距离我们点（*x*, *y*）左侧2.5个网格线并上方4个网格线的地方开始，所以我们会把乌龟放置在`(x-25,
    y+40)`位置开始绘制微笑。我们将把笔的颜色设置为黑色，宽度设置为10，这样微笑就会很粗且容易看见。从微笑的左上角，我们需要移动到`(x-10, y+20)`，然后到`(x+10,
    y+20)`，最后到微笑的右上角`(x+25, y+40)`。注意，这些点对是以y轴为对称轴的镜像关系；这使得我们的笑脸看起来非常均衡。
- en: 'Here’s the code for the mouth:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是嘴巴的代码：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After we set the turtle at the upper-left corner of the mouth, we change the
    pen color to black and the width to 10\. We start drawing by telling the turtle
    to go to each of the other three points of the smile. The `turtle` module’s `goto()`
    function does the same thing as `setpos()`: it moves the turtle to a given point.
    I’m using it here just so you can see there’s an alternative to `setpos()`. Finally,
    at ➊, `t.width(1)` sets the pen width back down to 1 so that our shapes aren’t
    too thick when the next face is drawn.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将海龟定位在嘴巴的左上角后，我们将画笔颜色更改为黑色，并将宽度设置为10。我们开始绘制，通过告诉海龟前往笑容的其他三个点。`turtle`模块的`goto()`函数和`setpos()`做的事情一样：它将海龟移动到给定的点。我在这里使用它是为了让你看到`setpos()`的替代方法。最后，在➊处，`t.width(1)`将画笔宽度恢复为1，这样在绘制下一个笑脸时，我们的形状就不会太厚。
- en: Defining and Calling Draw_Smiley()
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义和调用`Draw_Smiley()`
- en: All that remains is to define the `draw_smiley()` function with all the code
    to draw a smiley face, set up a loop to generate 50 random (*x*, *y*) locations
    on the screen, and call the `draw_smiley(x,y)` function to draw smileys at all
    50 locations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是定义`draw_smiley()`函数，包含所有绘制笑脸的代码，设置一个循环来生成屏幕上50个随机的(*x*, *y*)位置，并调用`draw_smiley(x,y)`函数，在这50个位置绘制笑脸。
- en: The function definition for `draw_smiley()` will need to take two parameters,
    `x` and `y`, for the location where the smiley is to be drawn, and it will need
    to lift the turtle’s pen, move the turtle to that (*x*, *y*) position, and then
    put the pen back down to get ready to draw. After that, we just need to add our
    code snippets for drawing the big yellow face, the left and right eyes, and the
    mouth.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw_smiley()`函数的定义需要接受两个参数，`x`和`y`，用于指定笑脸绘制的位置，并且需要抬起海龟的画笔，将海龟移动到(*x*, *y*)位置，然后再将画笔放下准备绘制。之后，我们只需添加绘制大黄色脸、左右眼睛和嘴巴的代码片段。'
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The final piece will be our `for` loop to generate 50 random locations for
    the smiley faces and call the `draw_smiley()` function to draw each face. It will
    look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的部分将是我们的`for`循环，用于生成50个随机位置的笑脸，并调用`draw_smiley()`函数绘制每个笑脸。它看起来是这样的：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our random x- and y-coordinate values are just like those we saw in [Chapter 6](ch06.html
    "Chapter 6. Random Fun and Games: Go Ahead, Take a Chance!"), generating random
    points from the left half to the right half of the screen, and from the bottom
    half to the top half. With `draw_smiley(x,y)`, we’re passing these random coordinates
    as arguments to the `draw_smiley()` function, which will draw a smiley at that
    random spot.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的随机x和y坐标值就像在[第6章](ch06.html "第6章。随机乐趣与游戏：去吧，冒险一下！")中看到的一样，从屏幕的左半部分到右半部分，从下半部分到上半部分生成随机点。通过`draw_smiley(x,y)`，我们将这些随机坐标作为参数传递给`draw_smiley()`函数，它将在该随机位置绘制一个笑脸。
- en: Putting it all together
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容组合起来
- en: 'Put the program together, and it looks something like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序组合起来，它大致看起来是这样的：
- en: RandomSmileys.py
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RandomSmileys.py
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As usual, we import the modules we need and set up our turtle, setting its speed
    to `0` (the fastest). We use `hideturtle()` so the turtle itself doesn’t show
    up on the screen; this speeds up drawing too.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们导入所需的模块并设置海龟，将它的速度设置为`0`（最快）。我们使用`hideturtle()`使海龟本身不出现在屏幕上，这样也可以加快绘制速度。
- en: At ➊, we define our `draw_smiley()` function so that its job is to draw the
    smiley’s face, left eye, right eye, and smile, using all that code we wrote before.
    All it needs to do its job is an x-coordinate and a y-coordinate.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊部分，我们定义了`draw_smiley()`函数，使其任务是绘制笑脸的脸、左眼、右眼和微笑，使用我们之前写的所有代码。它只需要做这项工作的是一个x坐标和一个y坐标。
- en: In our `for` loop at ➋, a random `x` and `y` are chosen and passed to `draw_smiley()`,
    which then draws a smiley with all features in the correct locations relative
    to that random point.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们`for`循环的➋部分，随机选择一个`x`和`y`值，并传递给`draw_smiley()`，然后它会在该随机点相对位置绘制一个带有所有特征的笑脸。
- en: The *RandomSmileys.py* program will draw 50 smiley faces at random positions
    on the drawing screen, as shown in [Figure 7-2](ch07.html#randomsmileysdotpy_program_produces_a_ha
    "Figure 7-2. The RandomSmileys.py program produces a happy result.").
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*RandomSmileys.py*程序将在绘图屏幕上随机位置绘制50个笑脸，正如[图7-2](ch07.html#randomsmileysdotpy_program_produces_a_ha
    "图7-2。RandomSmileys.py程序产生了一个快乐的结果。")所示。'
- en: You can customize the program to draw just about any shape you want, as long
    as you design a function to draw that shape starting from any (*x*, *y*) location.
    Start with graph paper like we did in this example to make it easier to find the
    important points. If it bothers you that some of the smiley faces are halfway
    off the screen on the left and right, or almost all the way off the screen at
    the top, you can use a bit of math in the `x` and `y randrange()` statements to
    keep your smileys completely on the screen. Go to *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    for a sample answer to this challenge.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自定义程序来绘制几乎任何形状，只要你设计一个函数，从任何(*x*, *y*)位置开始绘制该形状。像我们在这个示例中那样从图纸开始，可以更容易地找到重要的点。如果你觉得一些笑脸半挂在屏幕的左右两侧，或者几乎挂到屏幕顶部，你可以在
    `x` 和 `y randrange()` 语句中使用一些数学运算，确保笑脸完全留在屏幕上。可以访问 *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    获取这个挑战的示例答案。
- en: '![The RandomSmileys.py program produces a happy result.](httpatomoreillycomsourcenostarchimages2188953.png.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![The RandomSmileys.py program produces a happy result.](httpatomoreillycomsourcenostarchimages2188953.png.jpg)'
- en: Figure 7-2. The *RandomSmileys.py* program produces a happy result.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2. *RandomSmileys.py* 程序产生了一个愉快的结果。
- en: 'Return: It’s What You Give Back That Counts'
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回：你所给的才是最重要的
- en: We can send information to a function using arguments, but what if we want to
    *receive* information back *from* a function? For example, what if we build a
    function to convert inches to centimeters, and we want to store the converted
    number to use in further calculations, rather than just printing it directly to
    the screen? To pass information from a function back to the rest of our program,
    we use a `return` statement.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过参数将信息传递给函数，但如果我们想从函数中*接收*信息呢？例如，假设我们构建了一个将英寸转换为厘米的函数，并且我们希望将转换后的数字存储起来用于进一步的计算，而不是直接将其打印到屏幕上？为了将信息从函数传递回我们的程序，我们使用
    `return` 语句。
- en: Returning a Value from a Function
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从函数返回值
- en: 'There are lots of times when we want to get information back from a function.
    For example, let’s actually build the function to convert inches to centimeters
    and call it `convert_in2cm()`. We can imagine the parameter that we might want
    to accept in the function: a measurement in inches. But this function is a perfect
    candidate for giving information back to the rest of our program—namely, the converted
    measurement in centimeters.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多时候我们需要从函数中获取信息。例如，假设我们实际构建了一个将英寸转换为厘米的函数，并将其命名为 `convert_in2cm()`。我们可以设想这个函数可能需要接受的参数：一个英寸的测量值。但是这个函数完全可以返回信息给程序的其他部分——即转换后的厘米值。
- en: 'To convert a length in inches to its equivalent in centimeters, we multiply
    the number of inches by 2.54—the approximate number of centimeters in an inch.
    To pass that calculation back to the rest of the program, we would use a `return`
    statement. The value after the keyword `return` will be passed back to the program
    as the function’s *return value*, or result. Let’s define our function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将英寸长度转换为等效的厘米长度，我们将英寸数乘以 2.54——这是每英寸大约对应的厘米数。为了将该计算的结果传递回程序，我们将使用 `return`
    语句。`return` 关键字后面的值将作为函数的 *返回值* 或结果返回给程序。让我们定义我们的函数：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you type these two lines into the Python shell and then type `convert_in2cm(72)`
    and press ENTER, Python will respond with `182.88`. There are about 182.88 centimeters
    in 72 inches (or 6 feet—my height). The value 182.88 is returned by the function,
    and in the command line shell, we see the return value printed on the next line
    after we call a function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这两行代码输入到 Python shell 中，然后输入`convert_in2cm(72)`并按下 ENTER，Python 会返回 `182.88`。72
    英寸（或 6 英尺——我的身高）大约等于 182.88 厘米。函数返回的值是 182.88，在命令行中，当我们调用函数时，返回值会在下一行打印出来。
- en: 'We could also perform another useful conversion: pounds to kilograms. To convert
    pounds to kilograms, we divide the weight in pounds by 2.2, the approximate number
    of pounds in 1 kilogram. Let’s create a function called `convert_lb2kg()` that
    will take a value in pounds as its parameter and return the converted value in
    kilograms:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以进行另一个有用的转换：英镑转公斤。要将英镑转换为公斤，我们将英镑的重量除以 2.2，这是 1 公斤大约等于多少英镑的近似值。我们来创建一个叫做
    `convert_lb2kg()` 的函数，它将以英镑为参数，并返回转换后的公斤值：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188955.png.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages2188955.png.jpg)'
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `return` statement is sort of like using parameters in reverse, except that
    we can return only *one* value, not a set of values like the parameters we take
    in. (That one value can be a list, however, so with some work you can pass multiple
    values back in a single return variable.)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句有点像是反向使用参数，只不过我们只能返回*一个*值，而不是像我们传入的参数那样返回一组值。（不过，这个值可以是一个列表，所以通过一些操作，你可以在一个返回变量中传回多个值。）'
- en: Using Return Values in a Program
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在程序中使用返回值
- en: 'Using these two conversion functions, let’s build a silly application: a Ping-Pong-ball
    height and weight calculator. This program will answer the questions “How many
    Ping-Pong balls tall am I?” and “What is my weight in Ping-Pong balls?”'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个转换函数，我们来构建一个有趣的应用程序：乒乓球的身高和体重计算器。这个程序将回答“我有多少个乒乓球高？”和“我的体重大约相当于多少个乒乓球？”
- en: 'An official Ping-Pong ball weighs 2.7 grams (0.095 ounces) and measures 40
    millimeters (4 centimeters, or 1.57 inches) in diameter. To calculate how many
    Ping-Pong balls it would take to match our height and weight, we need to divide
    our height in centimeters by 4 and divide our weight in grams by 2.7\. But not
    everyone knows their weight in grams or height in centimeters: in the United States,
    we usually measure our weight in pounds and our height in feet and inches. Fortunately,
    the two conversion functions we just developed will help us convert those measurements
    to their equivalents in the metric system. We can then use these numbers to perform
    the conversion to Ping-Pong-ball units.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个官方的乒乓球重2.7克（0.095盎司），直径为40毫米（4厘米，或1.57英寸）。为了计算与我们的身高和体重相等的乒乓球数量，我们需要将身高（单位：厘米）除以4，并将体重（单位：克）除以2.7。但是并不是每个人都知道自己的体重（以克为单位）或身高（以厘米为单位）：在美国，我们通常以磅为单位测量体重，以英尺和英寸为单位测量身高。幸运的是，我们刚刚开发的两个转换函数将帮助我们将这些测量值转换为公制单位。然后我们可以使用这些数字进行乒乓球单位的转换。
- en: 'Our program will define the two conversion functions `convert_in2cm()` and
    `convert_lb2kg()`. Then it will ask the user for their height and weight, calculate
    the user’s height and weight in Ping-Pong balls, and display the calculations
    on the screen. Type and run the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序将定义两个转换函数`convert_in2cm()`和`convert_lb2kg()`。然后，它将请求用户输入身高和体重，计算出用户的身高和体重对应的乒乓球数量，并将计算结果显示在屏幕上。请键入并运行以下代码：
- en: PingPongCalculator.py
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PingPongCalculator.py
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At ➊, we enter the two conversion formulas we developed. Both functions take
    an input parameter (`inches` and `pounds`), and each function returns a value.
    At ➋, we ask the user for a height and weight and store those values in `height_in`
    and `weight_lb`. At ➌, we call the `convert_in2cm()` function, passing `height_in`
    as the value we want to convert, and we store the converted answer in the variable
    `height_cm`. We perform another conversion calculation at ➍ using the `convert_lb2kg()`
    function to convert the person’s weight in pounds (abbreviated as *lbs*) into
    the equivalent in kilograms (*kg*).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们输入我们开发的两个转换公式。两个函数都接受一个输入参数（`inches`和`pounds`），并且每个函数都返回一个值。在➋处，我们请求用户输入身高和体重，并将这些值存储在`height_in`和`weight_lb`中。在➌处，我们调用`convert_in2cm()`函数，将`height_in`作为我们要转换的值，并将转换结果存储在变量`height_cm`中。在➍处，我们使用`convert_lb2kg()`函数进行另一项转换计算，将人的体重（以*磅*为单位）转换为等效的*千克*（kg）。
- en: 'The equation at ➎ does two things: first, it divides the user’s height in centimeters
    by 4 to find their height in Ping-Pong balls; then, it rounds that answer to the
    nearest whole number with the `round()` function and stores the result in the
    variable `ping_pong_tall`. At ➏, we do something similar by converting the user’s
    weight in kilograms to grams by multiplying by 1,000 and then dividing that amount
    by 2.7—the mass in grams of a standard Ping-Pong ball. That number is rounded
    to the nearest whole number and stored in the variable `ping_pong_heavy`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ➎处的公式做了两件事：首先，它将用户的身高（单位为厘米）除以4，得出以乒乓球为单位的身高；然后，它使用`round()`函数将这个结果四舍五入到最接近的整数，并将结果存储在变量`ping_pong_tall`中。到达➏时，我们做了类似的操作，将用户的体重（单位为千克）转换为克，通过乘以1000，再除以2.7——这就是一个标准乒乓球的质量（单位：克）。这个数字被四舍五入到最接近的整数，并存储在变量`ping_pong_heavy`中。
- en: At ➐ and ➑, we do just a little more math by figuring out the person’s height
    in feet and inches. As I mentioned previously, this is normally how we express
    our height in the United States, and it will be a nice finishing touch as well
    as a way for the person to check that they entered the correct information. The
    `//` operator does integer division, so 66 inches, or 5.5 feet, would result in
    just `5` being stored in the variable `feet`, and the `%` operator (modulo) would
    store the remainder, `6` inches. The `print` statements at ➒ print out the user’s
    height and weight, both in standard units and in Ping-Pong balls.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在➐和➑处，我们通过计算一个人的身高（以英尺和英寸为单位）进行稍微多一点的数学运算。正如我之前提到的，这通常是我们在美国表达身高的方式，它不仅是一个不错的收尾，而且也是一个让人检查自己是否输入了正确信息的方式。`//`运算符执行整数除法，因此66英寸，或者5.5英尺，将导致只将`5`存储在变量`feet`中，而`%`运算符（取余）则存储余数，`6`英寸。➒处的`print`语句会打印出用户的身高和体重，分别以标准单位和乒乓球的数量表示。
- en: Here are the results from a few sample runs of the Ping-Pong calculator program,
    with Ping-Pong-ball measurements for my sons, Max and Alex, and me. (The only
    downside is that now my kids want to get 31,000 Ping-Pong balls.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是乒乓球计算器程序的一些示例运行结果，包括我儿子Max、Alex和我自己的乒乓球数量（唯一的缺点是，现在我的孩子们想要31,000个乒乓球）。
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Any function we create can return a value, just like any function that we define
    can take parameters as input. Depending on what you want your function to do,
    use one or both of these features to write exactly the code for the function you
    need.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的任何函数都可以返回一个值，就像我们定义的任何函数都可以接受参数作为输入一样。根据你希望函数执行的操作，使用这些功能之一或两者来编写你所需的函数代码。
- en: A Touch of Interaction
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一点交互
- en: 'We’ve coded some nice-looking graphical apps, but we’re still a step or two
    away from building the next video game or mobile app. One of the remaining skills
    we need to learn is coding for user interaction: making our programs respond to
    mouse clicks, keypresses, and so on.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了一些好看的图形化应用程序，但距离构建下一个视频游戏或移动应用程序还有一两步的距离。我们需要学习的一个剩余技能是用户交互编程：让我们的程序对鼠标点击、按键等作出响应。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188957.png.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188957.png.jpg)'
- en: Most apps are *interactive*—they allow the user to touch, click, drag, press
    buttons, and feel in control of the program. We call these *event-driven* apps
    because they wait for the user to perform an action, or [*event*](apd.html#gloss01_018).
    The code that responds to a user event, like opening a window when the user clicks
    an icon or starting a game when they touch a button, is referred to as an *event
    handler* because it handles or responds to an event from the user. It’s also called
    an event *listener* because it’s as if the computer is sitting patiently, listening
    for the user to tell it what to do. We’re going to learn to handle user events
    and make our programs even more engaging and interactive.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序是*交互式*的——它们允许用户触摸、点击、拖动、按下按钮，并感觉自己在控制程序。我们称这些应用程序为*事件驱动*应用程序，因为它们等待用户执行某个动作，或者[*事件*](apd.html#gloss01_018)。响应用户事件的代码，比如当用户点击图标时打开一个窗口，或者当他们点击按钮时启动游戏，称为*事件处理程序*，因为它处理或响应来自用户的事件。它也被称为事件*监听器*，因为就像计算机在耐心等待，倾听用户告诉它该做什么一样。我们将学习如何处理用户事件，使我们的程序更加引人入胜和互动。
- en: 'Handling Events: TurtleDraw'
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理：TurtleDraw
- en: There are lots of ways to make apps handle user events. Python’s `turtle` module
    includes some functions for handling user events, including mouse clicks and keypresses.
    The first one we’ll try is the `turtle.onscreenclick()` function. As the name
    suggests, this function allows us to handle events created by the user clicking
    on the turtle’s screen.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让应用程序处理用户事件有很多种方式。Python的`turtle`模块包括一些处理用户事件的函数，包括鼠标点击和按键。我们将尝试的第一个函数是`turtle.onscreenclick()`。顾名思义，这个函数允许我们处理用户点击海龟屏幕时产生的事件。
- en: 'There’s a difference between this function and the ones we’ve used and built
    before: the argument that we send to `turtle.onscreenclick()` isn’t a value—it’s
    the name of another function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与我们之前使用和构建的函数有所不同：我们传递给`turtle.onscreenclick()`的参数不是一个值——它是另一个函数的名字：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Remember the `setpos()` function that we’ve used to move the mouse to a certain
    (*x*, *y*) location on the screen? Now we’re telling the computer that when the
    turtle screen gets a mouse click, it should set the turtle to the position of
    that click on the screen. A function we pass as an argument to another function
    is sometimes called a *callback* function (because it gets *called back* by the
    other function). Notice that when we send a function as an argument to another
    function, the inside function doesn’t need the parentheses after its name.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们用过的`setpos()`函数吗？它可以将鼠标移动到屏幕上的某个(*x*, *y*)位置。现在，我们告诉计算机，当海龟屏幕接收到鼠标点击时，应该将海龟的位置设置为点击的屏幕位置。我们传递给另一个函数的函数有时被称为*回调*函数（因为它会被另一个函数“回调”）。注意，当我们将一个函数的名称作为参数传递给另一个函数时，内部函数不需要在名称后加括号。
- en: 'By sending the function name `t.setpos` to `turtle.onscreenclick()`, we’re
    telling the computer what we want screen clicks to do: we want to set the position
    of the turtle to wherever the user clicked. Let’s try it in a short program:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将函数名`t.setpos`传递给`turtle.onscreenclick()`，我们告诉计算机我们希望屏幕点击事件执行什么操作：我们希望将海龟的位置设置为用户点击的位置。让我们在一个简单的程序中尝试一下：
- en: TurtleDraw.py
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TurtleDraw.py
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Type these four lines into IDLE, run the program, and then click different places
    around the screen. You just created a drawing program in four lines of code! [Figure 7-3](ch07.html#turtledrawdotpy_sketch_left_parenthesist
    "Figure 7-3. A TurtleDraw.py sketch (there’s a reason I’m an author and not an
    artist)") shows a sample sketch I drew.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 输入这四行代码到IDLE中，运行程序，然后点击屏幕上不同的位置。你刚刚用四行代码创建了一个绘图程序！[图7-3](ch07.html#turtledrawdotpy_sketch_left_parenthesist
    "图7-3. 一个TurtleDraw.py草图（我之所以是作者而不是艺术家是有原因的）")展示了我绘制的一个示例草图。
- en: '![A TurtleDraw.py sketch (there’s a reason I’m an author and not an artist)](httpatomoreillycomsourcenostarchimages2188959.png.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![一个TurtleDraw.py草图（我之所以是作者而不是艺术家是有原因的）](httpatomoreillycomsourcenostarchimages2188959.png.jpg)'
- en: Figure 7-3. A *TurtleDraw.py* sketch (there’s a reason I’m an author and not
    an artist)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-3. 一个*TurtleDraw.py*草图（我之所以是作者而不是艺术家是有原因的）
- en: 'The reason this works is that we’ve told the computer to do something when
    the user clicks the mouse on the screen: set the position of the turtle to that
    location. The turtle’s pen is down by default, so when the user clicks on the
    drawing window, the turtle moves there and draws a line from its old location
    to the location where the user clicked.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以能这样工作，是因为我们告诉计算机，当用户点击屏幕时，海龟的当前位置应该被设置为鼠标点击的位置。海龟的画笔默认是落下的，所以当用户点击绘图窗口时，海龟会移动到点击位置，并从旧位置绘制一条线到用户点击的位置。
- en: 'You can customize *TurtleDraw.py* by changing the background color of the screen,
    the turtle’s pen color, the width of the pen, and more. Check out the version
    my four-year-old son created (with some help from his dad):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过修改屏幕的背景颜色、海龟的画笔颜色、画笔的宽度等来定制*TurtleDraw.py*。看看我四岁儿子制作的版本（在爸爸的帮助下）：
- en: TurtleDrawMax.py
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TurtleDrawMax.py
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Max liked the drawing program (a lot), but he wanted the screen to be blue and
    the pen to be green and really thick, so we set the `bgcolor()`, `pencolor()`,
    and `width()` to `blue`, `green`, and `99`, respectively. We made an arbitrary
    choice to set these *after* we told the computer what to do with mouse clicks
    on the screen (`t.setpos`).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Max喜欢这个绘图程序（非常喜欢），但他希望屏幕是蓝色的，画笔是绿色的，而且要非常粗，所以我们将`bgcolor()`、`pencolor()`和`width()`分别设置为`blue`、`green`和`99`。我们任意选择在告诉计算机处理鼠标点击事件后设置这些。
- en: This is fine, because the program keeps running even while it’s listening for
    mouse clicks, so by the time the user clicks for the first time, the screen and
    pen are correctly colored and sized, as shown in [Figure 7-4](ch07.html#drawing_i_produced_by_clicking_a_few_tim
    "Figure 7-4. A drawing I produced by clicking a few times with TurtleDrawMax.py").
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这没问题，因为程序会持续运行，即使它在监听鼠标点击，因此在用户第一次点击时，屏幕和画笔已经正确地着色和调整大小，如[图7-4](ch07.html#drawing_i_produced_by_clicking_a_few_tim
    "图7-4. 我通过多次点击使用TurtleDrawMax.py绘制的图像")所示。
- en: '![A drawing I produced by clicking a few times with TurtleDrawMax.py](httpatomoreillycomsourcenostarchimages2188961.png.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![我通过多次点击使用TurtleDrawMax.py绘制的图像](httpatomoreillycomsourcenostarchimages2188961.png.jpg)'
- en: Figure 7-4. A drawing I produced by clicking a few times with *TurtleDrawMax.py*
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-4. 我通过多次点击使用*TurtleDrawMax.py*绘制的图像
- en: Using the `setpos()` function as the callback for `turtle.onscreenclick()`,
    we’ve built a fun paint program that interacts with the user when they click the
    mouse by drawing lines to wherever they click. Try customizing the app with different
    colors, widths, or anything else you can think of to make it your own.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setpos()`函数作为` turtle.onscreenclick()`的回调，我们已经构建了一个有趣的画图程序，当用户点击鼠标时，程序会通过画线与用户互动，画出用户点击的位置。尝试使用不同的颜色、线宽或任何你能想到的方式来自定义这个应用，使它更具个性。
- en: 'Listening for Keyboard Events: ArrowDraw'
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听键盘事件：ArrowDraw
- en: With our turtle drawing program, we saw how listening for mouse clicks can make
    the user feel like they’re more in control of the program. In this section, we’ll
    learn to use keyboard interaction to give the user even more options. We’ll also
    define our own functions to use as event handlers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的乌龟绘图程序中，我们看到监听鼠标点击如何使用户感觉自己对程序有更多控制权。在本节中，我们将学习如何使用键盘交互给用户更多的选择。我们还将定义自己的函数，作为事件处理程序使用。
- en: In the *TurtleDraw.py* program, we passed `t.setpos` as the callback function
    to tell the computer what to do when an `onscreenclick()` event happened; we wanted
    to set the turtle’s position to the location of that mouse click on the screen.
    The `setpos()` function is already given to us in the `turtle` module, but what
    if we want to create our own functions to handle events? Say we want to build
    a program that lets the user move the turtle on their screen by pressing the arrow
    keys instead of clicking the mouse button. How would we do that?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在*TurtleDraw.py*程序中，我们将`t.setpos`作为回调函数，告诉计算机在发生`onscreenclick()`事件时该做什么；我们希望将乌龟的位置设置为鼠标点击屏幕的位置。`setpos()`函数已经在`turtle`模块中提供了，但如果我们想创建自己的函数来处理事件呢？假设我们想构建一个程序，允许用户通过按下箭头键来移动屏幕上的乌龟，而不是点击鼠标按钮。我们该怎么做呢？
- en: First, we have to build functions for moving the turtle for each arrow keypress
    on the keyboard, and then we have to tell the computer to listen for those keys
    to be pressed. Let’s write a program that will listen for the up (↑), left (←),
    and right (→) keyboard arrow keys and let the user move the turtle forward or
    turn left or right with those keys.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为每个箭头键的按下事件构建相应的函数来移动乌龟，然后告诉计算机监听这些键的按下事件。我们来写一个程序，监听上（↑）、左（←）和右（→）箭头键，让用户通过这些键来控制乌龟向前移动或左右转动。
- en: 'Let’s define some functions—`up()`, `left()`, and `right()`—that will move
    and turn the turtle:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义几个函数——`up()`、`left()`和`right()`——来移动和转动乌龟：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our first function, `up()`, moves the turtle forward 50 pixels. The second,
    `left()`, turns the turtle left 90 degrees. Finally, `right()` turns the turtle
    right 90 degrees.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个函数`up()`将乌龟向前移动50个像素。第二个函数`left()`将乌龟向左转90度。最后，`right()`将乌龟向右转90度。
- en: 'To run each of these functions when the user presses the correct arrow key,
    we have to tell the computer which function goes with which key and tell it to
    start listening for keypresses. To set the callback function for a keypress event,
    we use `turtle.onkeypress()`. This function usually takes two parameters: the
    name of the callback function (the event handler functions we created) and the
    specific key to listen for. To connect each of the three functions to its corresponding
    arrow key, we would write:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在用户按下正确的箭头键时运行这些函数，我们需要告诉计算机哪个函数与哪个键对应，并让计算机开始监听按键事件。为了设置键盘事件的回调函数，我们使用` turtle.onkeypress()`。这个函数通常需要两个参数：回调函数的名称（我们创建的事件处理函数）和要监听的特定键。为了将每个函数与相应的箭头键关联起来，我们可以这样写：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The first line sets the `up()` function as the event handler for `"Up"` arrow
    keypresses; the function (`up`) goes first, and `"Up"` is the name of the up arrow
    key, ↑. The same goes for the left and right arrow keypresses. The final step
    is telling the computer to begin listening for keypresses, which we do with this
    command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将`up()`函数设置为“上”箭头键按下事件的处理函数；函数(`up`)在前，`"Up"`是上箭头键的名称，↑。左箭头和右箭头的键按事件也是如此。最后一步是告诉计算机开始监听按键事件，这一步我们通过这个命令来实现：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We need this last line for a couple of reasons. First, unlike with mouse clicks,
    simply pressing a key doesn’t ensure that our turtle window will receive the keypress.
    When you click a window on your desktop, that window moves to the front and receives
    the *focus*, meaning that window will receive input from the user. When you click
    the mouse on the turtle window, it automatically makes that window the focus of
    the screen and of any mouse events that follow. With the keyboard, though, just
    pressing keys doesn’t make a window receive those keypresses; the `turtle.listen()`
    command makes sure our turtle’s window is the focus of the desktop so that it
    will be able to hear keypresses. Second, the `listen()` command tells the computer
    to start handling keypress events for all keys that we connected to functions
    with the `onkeypress()` function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这一行代码有几个原因。首先，与鼠标点击不同，单纯按下一个键并不能确保我们的乌龟窗口接收到按键。当你点击桌面上的一个窗口时，该窗口会移到前面并获得*焦点*，意味着该窗口将接收来自用户的输入。点击乌龟窗口时，它会自动将该窗口设为焦点，接收后续的鼠标事件。但对于键盘，单纯按键并不会让某个窗口接收这些按键输入；`turtle.listen()`
    命令确保了我们的乌龟窗口成为桌面的焦点，从而能够接收按键事件。其次，`listen()` 命令告诉计算机开始处理所有与 `onkeypress()` 函数关联的按键事件。
- en: 'Here’s the complete *ArrowDraw.py* program:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的 *ArrowDraw.py* 程序：
- en: ArrowDraw.py
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ArrowDraw.py
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: At ➊, the only new line in *ArrowDraw.py*, we make the turtle arrow twice as
    big, and give it a thicker outline with `t.turtlesize(2,2,2)`. The three parameters
    are the horizontal stretch (`2` means to make it twice as wide), the vertical
    stretch (`2` times as tall), and the outline thickness (`2` pixels thick). [Figure 7-5](ch07.html#arrowdrawdotpy_program_lets_the_user_dra
    "Figure 7-5. The ArrowDraw.py program lets the user draw using the up, right,
    and left arrow keys. The larger turtle arrow makes it easier to see where the
    turtle is headed.") shows the result.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊位置，*ArrowDraw.py* 中唯一新增的一行代码，我们将乌龟箭头的大小增大了两倍，并使用 `t.turtlesize(2,2,2)` 给它加上了更粗的轮廓。三个参数分别是水平拉伸（`2`
    表示宽度是原来的两倍），垂直拉伸（`2` 表示高度是原来的两倍）和轮廓厚度（`2` 像素）。[图 7-5](ch07.html#arrowdrawdotpy_program_lets_the_user_dra
    "图 7-5. ArrowDraw.py 程序允许用户使用上、右和左箭头键进行绘图。更大的乌龟箭头使得更容易看出乌龟的移动方向。") 显示了结果。
- en: '![The ArrowDraw.py program lets the user draw using the up, right, and left
    arrow keys. The larger turtle arrow makes it easier to see where the turtle is
    headed.](httpatomoreillycomsourcenostarchimages2188963.png.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![ArrowDraw.py 程序允许用户使用上、右和左箭头键进行绘图。更大的乌龟箭头使得更容易看出乌龟的移动方向。](httpatomoreillycomsourcenostarchimages2188963.png.jpg)'
- en: Figure 7-5. The *ArrowDraw.py* program lets the user draw using the up, right,
    and left arrow keys. The larger turtle arrow makes it easier to see where the
    turtle is headed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-5. *ArrowDraw.py* 程序允许用户使用上、右和左箭头键进行绘图。更大的乌龟箭头使得更容易看出乌龟的移动方向。
- en: 'This app is a bit like the old Etch-A-Sketch toy: you can draw fun shapes using
    just those three arrow keys, and you can retrace your steps. Feel free to customize
    the app with your own colors, pen width, and any other features you’d like to
    add. One extra feature you could add, which is included as a challenge at the
    end of this chapter, is the ability to click to move the turtle to a new location.
    Dream up new features and give them a try—that’s the best way to learn something
    new!'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序有点像旧款的 Etch-A-Sketch 玩具：你只需要使用这三个箭头键就可以绘制有趣的形状，并且可以重绘你的步骤。随意定制这个应用程序，可以修改颜色、笔宽以及任何你想添加的其他功能。你可以加入一个额外的功能，这个功能作为本章结尾的挑战，允许点击来移动乌龟到一个新的位置。发挥创意，设计新功能并进行尝试——这是学习新事物的最佳方式！
- en: 'Handling Events with Parameters: Clickspiral'
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理带参数的事件：Clickspiral
- en: In *TurtleDraw.py*, we let the user click to draw by telling the `turtle.onscreenclick()`
    listener to call the `t.setpos` function anytime the user clicked the screen.
    Let’s build a new program named *ClickSpiral.py* that will draw spirals wherever
    the user clicks, as shown in [Figure 7-6](ch07.html#smiley_face_drawn_using_the_clickspirald
    "Figure 7-6. A smiley face drawn using the ClickSpiral.py app").
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *TurtleDraw.py* 中，我们通过告诉 `turtle.onscreenclick()` 监听器在用户点击屏幕时调用 `t.setpos`
    函数来让用户点击进行绘图。现在，让我们编写一个新的程序 *ClickSpiral.py*，它将在用户点击的地方绘制螺旋线，如 [图 7-6](ch07.html#smiley_face_drawn_using_the_clickspirald
    "图 7-6. 使用 ClickSpiral.py 应用绘制的笑脸") 所示。
- en: The `onscreenclick()` listener passes the x- and y-coordinates of every mouse
    click as arguments to the callback function we specify. When we want to handle
    mouse click events with a function of our own, we simply write a function that
    accepts those values—the x- and y-coordinates of the mouse click—as a pair of
    parameters.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`onscreenclick()` 监听器将每次鼠标点击的 x 和 y 坐标作为参数传递给我们指定的回调函数。当我们想要用自己的函数处理鼠标点击事件时，只需编写一个接受这些值（鼠标点击的
    x 和 y 坐标）作为一对参数的函数。'
- en: '![A smiley face drawn using the ClickSpiral.py app](httpatomoreillycomsourcenostarchimages2188965.png.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![使用 ClickSpiral.py 应用程序绘制的笑脸](httpatomoreillycomsourcenostarchimages2188965.png.jpg)'
- en: Figure 7-6. A smiley face drawn using the *ClickSpiral.py* app
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-6. 使用 *ClickSpiral.py* 应用程序绘制的笑脸
- en: '*RandomSpiralsFunction.py* ([RandomSpiralsFunction.py](ch07.html#randomspiralsfunctiondotpy
    "RandomSpiralsFunction.py")) contained a function called `random_spiral()` that
    drew colorful spirals in random places on the screen. Now, however, instead of
    spirals at random locations, we want a spiral to appear where the user clicks
    the mouse. To do this, we can rewrite the `random_spiral()` function to take two
    parameters, `x` and `y`, from the `turtle.onscreenclick()` listener. We’ll rename
    the function `spiral(x,y)`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*RandomSpiralsFunction.py* ([RandomSpiralsFunction.py](ch07.html#randomspiralsfunctiondotpy
    "RandomSpiralsFunction.py")) 包含一个名为 `random_spiral()` 的函数，用于在屏幕上的随机位置绘制彩色螺旋。现在，我们不再希望在随机位置绘制螺旋，而是希望在用户点击鼠标的位置显示螺旋。为此，我们可以重写
    `random_spiral()` 函数，接受来自 `turtle.onscreenclick()` 监听器的两个参数 `x` 和 `y`。我们将函数重命名为
    `spiral(x,y)`：'
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this new version, we change the function’s definition to reflect the new
    name and the two parameters that we will receive to draw at chosen positions on
    the screen as `spiral(x,y)`. We still choose a random color and size for each
    spiral, but we have removed the two lines that generate a random `x` and `y`,
    because we will get the `x` and `y` as arguments from the `onscreenclick()` listener.
    Just as with the `random_spiral()` function, we move the pen to the correct (*x*,
    *y*) position and then draw the spiral.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新版本中，我们修改了函数的定义，以反映新的名称和我们将接收的两个参数，用于在屏幕上选择的位置绘制为 `spiral(x,y)`。我们仍然为每个螺旋选择一个随机的颜色和大小，但我们已经去除了生成随机
    `x` 和 `y` 的两行代码，因为我们将从 `onscreenclick()` 监听器中获取 `x` 和 `y` 作为参数。与 `random_spiral()`
    函数一样，我们将笔移动到正确的 (*x*, *y*) 位置，然后绘制螺旋。
- en: 'The only step left is to set up our turtle window and the list of colors, and
    then tell our `turtle.onscreenclick()` listener to call the spiral function whenever
    the user clicks the mouse button over the drawing window. Here’s the complete
    program:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一步骤是设置我们的海龟窗口和颜色列表，然后告诉 `turtle.onscreenclick()` 监听器在用户点击绘图窗口的鼠标按钮时调用螺旋函数。以下是完整的程序：
- en: ClickSpiral.py
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ClickSpiral.py
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As in *TurtleDraw.py*, we leave out the parentheses and parameters for our
    callback function ➊: `turtle.onscreenclick(spiral)` tells our program that it
    should call our `spiral(x,y)` function every time the user clicks the mouse on
    the screen, and the event listener automatically sends two arguments—the x-position
    and y-position of that click—to the `spiral` callback function. The same thing
    happened in *TurtleDraw.py* with the `t.setpos` callback, but this time, we created
    our own function to draw a spiral of a random color and size at the location of
    the mouse button click.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *TurtleDraw.py* 中一样，我们省略了回调函数的括号和参数 ➊：`turtle.onscreenclick(spiral)` 告诉我们的程序每次用户在屏幕上点击鼠标时都应该调用
    `spiral(x,y)` 函数，并且事件监听器会自动将两个参数——鼠标点击的 x 坐标和 y 坐标——传递给 `spiral` 回调函数。在 *TurtleDraw.py*
    中，发生了类似的事情，使用的是 `t.setpos` 回调，但这一次，我们创建了自己的函数，在鼠标点击的位置绘制一个随机颜色和大小的螺旋。
- en: 'Taking It One Step Further: Clickandsmile'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更进一步：Clickandsmile
- en: Let’s extend this interactive app by making one more change. Instead of drawing
    a spiral, say we want to draw a smiley face wherever the user clicks the mouse
    on the drawing screen. The code will look a lot like our *RandomSmileys.py* program
    from [Putting it all together](ch07.html#putting_it_all_together-id00013 "Putting
    it all together"), but instead of a loop that draws 50 smiley faces at random
    locations on the screen, this program will handle the mouse click event by drawing
    a smiley at the location the user chooses, as many or as few times as the user
    wishes to click.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过做一个小小的改变来扩展这个互动应用。假设我们不再绘制螺旋线，而是希望在用户点击绘图屏幕时绘制一个微笑脸。代码将与我们在[《综合应用》](ch07.html#putting_it_all_together-id00013
    "Putting it all together")中使用的*RandomSmileys.py*程序非常相似，但不同的是，这个程序会处理鼠标点击事件，在用户选择的位置绘制一个微笑脸，用户点击多少次就绘制多少次。
- en: In fact, because our `draw_smiley()` function already takes two parameters (the
    x- and y-coordinates of the location where we wish to draw the smiley face), the
    code for *ClickAndSmile.py* is identical to *RandomSmileys.py*, except for the
    last section. Just replace the `for` loop that draws 50 random smileys with a
    call to `turtle.onscreenclick(draw_smiley)`. Remember how the `turtle.onscreenclick()`
    function allows us to pass the name of a function (like `setpos`) as the event
    handler for mouse clicks? We can pass it `draw_smiley` so that when the user clicks,
    our `draw_smiley()` function will do its work at the location of the click. We
    do not include `draw_smiley`’s parentheses, or any arguments, inside the parentheses
    for `turtle.onscreenclick()`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，因为我们的`draw_smiley()`函数已经接受两个参数（我们希望绘制微笑脸的x和y坐标），所以*ClickAndSmile.py*的代码与*RandomSmileys.py*完全相同，唯一的区别是最后一部分。只需将绘制50个随机微笑脸的`for`循环替换为调用`turtle.onscreenclick(draw_smiley)`。记得`turtle.onscreenclick()`函数如何让我们将一个函数的名字（如`setpos`）作为鼠标点击事件的处理程序吗？我们可以传递`draw_smiley`，这样当用户点击时，`draw_smiley()`函数就会在点击的位置执行它的工作。在`turtle.onscreenclick()`的括号中，我们不需要包含`draw_smiley`的括号或任何参数。
- en: ClickAndSmile.py
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ClickAndSmile.py
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, instead of drawing random smiley faces all over the screen, the user can
    draw a smiley face wherever they click the mouse; they can even draw a big smiley
    face out of little smiley faces, as shown in [Figure 7-7](ch07.html#weapostropheve_made_our_smiley_program_m
    "Figure 7-7. We’ve made our smiley program more interactive, drawing wherever
    the user clicks.").
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户可以在屏幕上点击的任何地方绘制微笑脸，而不再是随机地绘制微笑脸；他们甚至可以用小的微笑脸绘制一个大的微笑脸，正如在[图 7-7](ch07.html#weapostropheve_made_our_smiley_program_m
    "Figure 7-7. We’ve made our smiley program more interactive, drawing wherever
    the user clicks.")中所示。
- en: '![We’ve made our smiley program more interactive, drawing wherever the user
    clicks.](httpatomoreillycomsourcenostarchimages2188967.png.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![我们让微笑程序变得更加互动，可以在用户点击的地方绘制。](httpatomoreillycomsourcenostarchimages2188967.png.jpg)'
- en: Figure 7-7. We’ve made our smiley program more interactive, drawing wherever
    the user clicks.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-7. 我们让微笑程序变得更加互动，可以在用户点击的地方绘制。
- en: 'Whatever kinds of apps you want to build, you’re probably going to rely on
    user interaction to drive the experience. Think of the games or other apps that
    you spend the most time playing: what they all have in common is that you have
    some kind of control over what happens and when. Whether you’re moving a paddle
    to hit a ball; pressing the mouse button or touching and dragging to fire something
    through the air; or clicking, swiping, and tapping to clear a screen, you’re generating
    user events—and the programs you love handle those events by doing something cool.
    Let’s build one more interactive app for practice, and then we’ll build even more
    of the kinds of apps we play with every day.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你想构建什么样的应用程序，你可能都会依赖用户交互来驱动体验。想一想那些你花最多时间玩的游戏或其他应用程序：它们的共同点是你可以控制发生什么以及何时发生。不管是移动球拍来击打球；按下鼠标按钮或触摸并拖动来发射某物；还是点击、滑动和轻触来清除屏幕，你都在生成用户事件——而你喜欢的程序会通过做一些很酷的事情来处理这些事件。让我们再构建一个互动应用来练习一下，之后我们将构建更多我们每天玩的应用程序。
- en: ClickKaleidoscope
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ClickKaleidoscope
- en: Let’s combine our ability to create functions and our ability to handle interactive
    clicks to create an interactive kaleidoscope. The user will be able to click anywhere
    on the screen, and four reflected spirals of a random shape and color will be
    drawn starting from the point where the user clicked. The result will look like
    our *Kaleidoscope.py* program from [Kaleidoscope.py](ch06.html#kaleidoscopedotpy
    "Kaleidoscope.py"), but the user will be able to create their own unique patterns
    using this kaleidoscope.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将创建函数的能力和处理互动点击的能力结合起来，创造一个互动的万花筒。用户可以在屏幕上的任何位置点击，然后从用户点击的位置开始绘制四个反射的随机形状和颜色的螺旋线。最终效果将类似于我们在
    [Kaleidoscope.py](ch06.html#kaleidoscopedotpy "Kaleidoscope.py") 程序中的展示，但用户将能够使用这个万花筒创造出他们自己的独特图案。
- en: The Draw_Kaleido() Function
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Draw_Kaleido() 函数
- en: Let’s talk about the challenges in building a customized kaleidoscope program.
    We know we want to allow the user to click the screen to begin the drawing process,
    so we’ll use the `turtle.onscreenclick()` function from the previous section.
    We know that this function will give us an (*x*, *y*) location on the screen that
    we can use in our callback function. And we can look back at our original kaleidoscope
    program to see that all we have to do is draw a spiral at each of the four points
    (*x*, *y*), (*–x*, *y*), (*–x*, *–y*), and (*x*, *–y*) to achieve the desired
    reflection effect.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈构建定制化万花筒程序的挑战。我们知道我们想让用户点击屏幕以开始绘图过程，因此我们将使用前一节中的 `turtle.onscreenclick()`
    函数。我们知道这个函数将给我们一个 (*x*, *y*) 的位置，我们可以在回调函数中使用这个位置。我们还可以回顾原始的万花筒程序，看到我们只需要在四个位置
    (*x*, *y*), (*–x*, *y*), (*–x*, *–y*), 和 (*x*, *–y*) 绘制螺旋线，就能实现所需的反射效果。
- en: 'Each of our four reflected spirals should be the same color and size to create
    the mirror illusion. We will call our function `draw_ kaleido()` and define it
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的四个反射螺旋线应该具有相同的颜色和大小，以创造镜像效果。我们将调用函数 `draw_kaleido()` 并将其定义如下：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: At ➊, we name our function `draw_kaleido`, and we allow it to take the two parameters,
    `x` and `y`, from the `turtle.onscreenclick()` event handler so that our four
    reflected spirals will start at the (*x*, *y*) location where the user clicked
    the mouse. Then, at ➋, we randomly choose a pen color for all four reflected spirals
    in a set from our usual list of colors, `colors`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将函数命名为 `draw_kaleido`，并允许它从 `turtle.onscreenclick()` 事件处理器中获取两个参数 `x`
    和 `y`，这样四个反射的螺旋线就会从用户点击的 (*x*, *y*) 位置开始。接着，在 ➋ 处，我们随机选择一个颜色作为四个反射螺旋线的颜色，从我们常用的颜色列表
    `colors` 中挑选。
- en: At ➌, we pick a random size for all four reflected spirals and store it in `size`.
    Finally, we draw all of the four spirals at their (*x*, *y*), (*–x*, *y*), (*–x*,
    *–y*), and (*x*, *–y*) locations with a new function we’ve yet to actually write,
    called `draw_spiral()`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，我们为四个反射的螺旋线选择一个随机大小，并将其存储在 `size` 中。最后，我们通过一个尚未实际编写的新函数 `draw_spiral()`，在它们的
    (*x*, *y*), (*–x*, *y*), (*–x*, *–y*), 和 (*x*, *–y*) 位置绘制这四个螺旋线。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188969.png.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![没有说明文字的图片](httpatomoreillycomsourcenostarchimages2188969.png.jpg)'
- en: The Draw_Spiral() Function
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Draw_Spiral() 函数
- en: 'Our `draw_spiral()` function will need to draw a spiral starting at a custom
    (*x*, *y*) location on the screen. Python’s turtle pen will remember the color
    once it’s set, so we don’t have to pass that information as a parameter to our
    `draw_spiral()` function, but we do need the (*x*, *y*) location and the `size`
    of the spiral that we want to draw. So we’ll define our `draw_spiral()` function
    to take three parameters:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `draw_spiral()` 函数需要从屏幕上一个自定义的 (*x*, *y*) 位置开始绘制螺旋。Python 的海龟笔一旦设置了颜色，就会记住这个颜色，因此我们不需要将颜色作为参数传递给
    `draw_spiral()` 函数，但我们确实需要传递螺旋的 (*x*, *y*) 位置和 `size`。因此，我们将定义 `draw_spiral()`
    函数，接受三个参数：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This function takes the parameters `x` and `y` for the location to start drawing
    each spiral, and the parameter `size` to tell us how big to make the spiral. Inside
    the function, we lift the turtle’s pen so that we can move without leaving a trail,
    we move the pen to the given (*x*, *y*) location, and we put the pen back down
    to prepare for the spiral. Our `for` loop will iterate `m` over the values from
    `0` to `size`, drawing a square spiral up to that side length.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受参数 `x` 和 `y`，用于确定每个螺旋线的起始位置，以及 `size` 参数来指定螺旋线的大小。在函数内部，我们先抬起海龟的笔，使其可以在不留下痕迹的情况下移动，然后将笔移到给定的
    (*x*, *y*) 位置，并重新放下笔准备绘制螺旋。我们的 `for` 循环将从 `0` 到 `size` 遍历 `m`，绘制一个边长为 `size` 的方形螺旋。
- en: All we’ll have to do in our program, besides importing `random` and `turtle`
    and setting up our screen and list of colors, is tell the computer to listen for
    clicks on the turtle screen and call the `draw_ kaleido()` function whenever a
    click event happens. We can do that with the command `turtle.onscreenclick(draw_kaleido)`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，除了导入`random`和`turtle`模块并设置屏幕和颜色列表外，我们只需要告诉计算机监听海龟屏幕上的点击，并在每次点击事件发生时调用`draw_kaleido()`函数。我们可以通过命令`turtle.onscreenclick(draw_kaleido)`来实现这一点。
- en: Putting It All Together
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: Here’s the full *ClickKaleidoscope.py* program. Type it in IDLE or download
    it from *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    and run it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的*ClickKaleidoscope.py*程序。你可以在 IDLE 中输入它，或者从 *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    下载并运行。
- en: ClickKaleidoscope.py
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ClickKaleidoscope.py
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We begin with our normal `import` statements and then set up our turtle environment
    and list of colors. Next, we define our `draw_spiral()` function, followed by
    `draw_kaleido()`, and we finish by telling the computer to listen for clicks on
    the turtle screen and call `draw_kaleido()` when click events occur. Now, whenever
    the user clicks a location on the drawing window, a spiral will be drawn there
    and reflected across the x- and y-axes for a total of four spirals of the same
    random shape and size.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从正常的`import`语句开始，然后设置我们的海龟环境和颜色列表。接着，我们定义了`draw_spiral()`函数，然后是`draw_kaleido()`函数，最后我们告诉计算机监听海龟屏幕上的点击事件，并在发生点击事件时调用`draw_kaleido()`。现在，每当用户在绘图窗口中点击一个位置时，那里就会绘制一个螺旋图案，并且沿着
    x 轴和 y 轴反射，总共生成四个相同的随机形状和大小的螺旋图案。
- en: The result is a fully interactive version of our spiral kaleidoscope program
    that allows the user to control the reflected pattern by clicking only in parts
    of the screen where they want spirals to appear. [Figure 7-8](ch07.html#with_our_interactive_kaleidoscope_progra
    "Figure 7-8. With our interactive kaleidoscope program, you can create any reflected
    pattern you wish!") shows a sample run of the program with reflected patterns
    made of spirals.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是我们螺旋万花筒程序的一个完全互动版本，允许用户通过点击屏幕的特定区域来控制反射图案，从而只在他们希望螺旋出现的地方生成图案。[Figure 7-8](ch07.html#with_our_interactive_kaleidoscope_progra
    "图 7-8. 使用我们的互动万花筒程序，你可以创建任何你想要的反射图案！") 显示了程序运行时，螺旋构成的反射图案的样本。
- en: '![With our interactive kaleidoscope program, you can create any reflected pattern
    you wish!](httpatomoreillycomsourcenostarchimages2188971.png.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![使用我们的互动万花筒程序，你可以创建任何你想要的反射图案！](httpatomoreillycomsourcenostarchimages2188971.png.jpg)'
- en: Figure 7-8. With our interactive kaleidoscope program, you can create any reflected
    pattern you wish!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-8. 使用我们的互动万花筒程序，你可以创建任何你想要的反射图案！
- en: 'Try your own patterns (like your first initial!) and take a screenshot of your
    results (in Windows, hold down the ALT and PRINT SCREEN keys to copy the turtle
    window and then paste into Word or your favorite drawing program; on a Mac, press
    and hold the COMMAND [![](httpatomoreillycomsourcenostarchimages2188973.png.jpg)],
    SHIFT, and 4 keys, then press the spacebar, and then click the turtle drawing
    window to save a copy of the picture to your desktop as *Screenshot <date and
    time>.png*). Tweet your best screenshots to me at @brysonpayne on Twitter with
    the hashtag #kidscodebook, and I’ll do my best to respond!'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '尝试你自己的图案（比如你的首字母！），并截图保存结果（在 Windows 中，按住 ALT 和 PRINT SCREEN 键将海龟窗口复制到剪贴板，然后粘贴到
    Word 或你最喜欢的绘图程序中；在 Mac 上，按住 COMMAND、SHIFT 和 4 键，然后按空格键，再点击海龟绘图窗口，将图片保存到桌面，文件名为
    *Screenshot <日期和时间>.png*）。在 Twitter 上用标签 #kidscodebook 将你最棒的截图发给我，@brysonpayne，我会尽力回复！'
- en: What You Learned
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: In this chapter, you learned how to organize chunks of reusable code into functions,
    call your own functions from anywhere in your programs, pass information as parameters
    to those functions, and get information back from functions as return values.
    We wrote our first event-driven programs by telling the computer to listen for
    mouse clicks and keypresses, and you learned how to write your own callback functions
    to respond to user events.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将可重用的代码块组织成函数，如何从程序的任何地方调用自己的函数，如何将信息作为参数传递给这些函数，以及如何通过返回值从函数中获取信息。我们通过告诉计算机监听鼠标点击和键盘按键，编写了第一个事件驱动的程序，并且你学会了如何编写自己的回调函数来响应用户事件。
- en: We’ve developed our first fully interactive programs. Using the skills you’ve
    gained in this chapter, you’re ready to begin writing even more advanced apps.
    The apps we frequently enjoy give users the experience of being in control of
    the program by responding to clicks, touches, keypresses, and more.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开发了第一个完全互动的程序。运用你在本章中学到的技能，你已经准备好开始编写更先进的应用程序了。我们常用的应用程序通过响应点击、触摸、按键等方式，让用户体验到掌控程序的感觉。
- en: 'After mastering the concepts in this chapter, you should be able to do the
    following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握本章概念后，你应该能够完成以下任务：
- en: Make code more reusable using functions.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数使代码更加可重用。
- en: Organize and group code into functions.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码组织和分组到函数中。
- en: Define functions in Python using the `def` keyword.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`def`关键字在Python中定义函数。
- en: Call your own functions from programs that you write.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你编写的程序中调用你自己的函数。
- en: Define and use functions that accept parameters as input values.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义并使用接受参数作为输入值的函数。
- en: Write functions that return values when called.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写函数，当调用时返回值。
- en: Convert a mathematical formula into a function that returns the function’s value.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数学公式转换为一个返回公式值的函数。
- en: Explain some features of event-driven programs.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释事件驱动程序的一些特性。
- en: Write a basic event-driven app that uses an event handler.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个基本的事件驱动应用程序，使用事件处理程序。
- en: Write an app that accepts mouse clicks and draws on the screen.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个接受鼠标点击并在屏幕上绘图的应用程序。
- en: Code event handlers for keyboard events.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写键盘事件的事件处理程序。
- en: Program event handler functions that take parameters.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写接受参数的事件处理程序函数。
- en: Use x- and y-coordinates on the screen to draw specific patterns, such as kaleidoscopes.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用屏幕上的x和y坐标绘制特定的图案，例如万花筒。
- en: Programming Challenges
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 编程挑战
- en: Here are three challenges to extend what you learned in this chapter. For sample
    answers to these challenges, go to *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个挑战，旨在扩展你在本章中学到的内容。对于这些挑战的示例答案，请访问*[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*。
- en: '**#1: Mirrored Smileys**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1: 镜像笑脸**'
- en: Create a mashup of the programs *ClickAndSmile.py* and *ClickKaleidoscope.py*
    to draw a smiley face in four mirrored corners of the screen when you click, just
    like the kaleidoscope program did with spirals. If you’d like an advanced challenge,
    draw two of the smiley faces flipped upside down so that they really look mirrored
    across the x-axis.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将*ClickAndSmile.py*和*ClickKaleidoscope.py*程序合并，在屏幕的四个镜像角落绘制笑脸，当你点击时，就像万花筒程序用螺旋图案那样。如果你想挑战更高难度，绘制两个翻转过来的笑脸，使它们真正看起来像是沿x轴镜像的。
- en: '**#2: More Ping-Pong Calculations**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**#2: 更多乒乓球计算**'
- en: Modify the Ping-Pong calculator so it asks the user for a number of Ping-Pong
    balls as input. Have it tell the user both how tall those Ping-Pong balls would
    be if stacked on top of one another and how much that number of Ping-Pong balls
    would weigh.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 修改乒乓球计算器，使其要求用户输入乒乓球的数量。并告诉用户这些乒乓球如果堆叠在一起会有多高，以及这些乒乓球的重量是多少。
- en: '**#3: A Better Drawing Program**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**#3: 更好的绘图程序**'
- en: Change the *ArrowDraw.py* program to allow the user to turn the turtle in smaller
    increments—say 45 degrees (or even 30 or 15)—to give them finer control of the
    turtle. Then, add more key options, like allowing the user to press the greater-than
    symbol (>) to make the drawing length longer, the less-than symbol (<) to shorten
    the drawing length, the W key to make the pen wider, and the T key to make the
    pen thinner. To make it a great drawing program, add feedback in the form of drawing
    a string on the screen to show the pen width, segment length, and turtle’s direction
    after every change.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 修改*ArrowDraw.py*程序，允许用户以更小的增量旋转海龟——例如45度（甚至30度或15度）——以便更精细地控制海龟。然后，添加更多的键盘选项，比如允许用户按下大于符号（>）使绘图长度变长，按下小于符号（<）缩短绘图长度，按下W键使画笔变宽，按下T键使画笔变细。为了让它成为一个出色的绘图程序，可以通过在屏幕上绘制一条字符串，展示笔宽、段长度和海龟的方向来提供反馈，每次变化后都显示这些信息。
- en: 'For a finishing touch, add the ability to click to reposition the turtle. (Hint:
    create a function that accepts two parameters (*x*, *y*), lifts the turtle’s pen,
    moves to (*x*, *y*), then puts the pen back down. Then, pass the name of this
    function to `turtle.onscreenclick()` to complete the app.)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为程序添加一个功能，允许点击重新定位海龟。（提示：创建一个接受两个参数（*x*，*y*）的函数，抬起海龟的笔，移动到（*x*，*y*）位置，然后放下笔。然后，将这个函数的名字传递给`turtle.onscreenclick()`，完成应用程序。）
