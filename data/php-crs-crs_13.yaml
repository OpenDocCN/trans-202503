- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 10 CLIENT/SERVER COMMUNICATION AND WEB DEVELOPMENT BASICS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10 客户端/服务器通信与网页开发基础
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: As a language of the internet, PHP is closely connected to the communications
    between web *clients* and web *servers*. In this chapter, we’ll look at how clients
    and servers work, and we’ll examine the messages that pass between them. We’ll
    also see how to efficiently embed PHP statements in static HTML code to construct
    a full HTML text file that a web browser client can understand and render onscreen
    as a web page. Finally, we’ll discuss how a typical PHP web application is structured,
    including a first look at the model-view-controller (MVC) architecture.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 作为互联网语言，PHP与网页*客户端*和网页*服务器*之间的通信紧密相关。在本章中，我们将了解客户端和服务器如何工作，检查它们之间传递的消息。我们还将学习如何有效地将PHP语句嵌入静态HTML代码中，以构建一个完整的HTML文本文件，网页浏览器客户端可以理解并在屏幕上呈现为网页。最后，我们将讨论典型的PHP网页应用程序的结构，包括对模型-视图-控制器（MVC）架构的初步了解。
- en: Whether you realize it or not, you probably use clients and servers every day.
    When you check your email or social media accounts, you’re using a client application
    to communicate with a server to request updates. These kinds of apps are continually
    making requests to servers; for example, your email app requests from servers
    such as Google Gmail or Apple iCloud in order to download any new email and update
    the messages and folders on your phone to mirror any changes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不管你是否意识到，你可能每天都会使用客户端和服务器。当你检查你的电子邮件或社交媒体账户时，你正在使用一个客户端应用程序与服务器进行通信，请求更新。这类应用程序不断地向服务器发送请求；例如，你的电子邮件应用程序会向像Google
    Gmail或Apple iCloud这样的服务器请求，以便下载任何新邮件并更新手机上的信息和文件夹，确保与服务器上的变化保持同步。
- en: 'You can run a web server application in two places: locally on your own computer
    or publicly on an internet-accessible computer. As a PHP programmer, you’ll do
    a lot of your software development locally on your own machine. Then, when you
    think a project is ready, you’ll test it on a public server, and finally publish
    the website live when all testing is complete.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在两个地方运行网页服务器应用程序：本地计算机上，或者是一个可以公开访问的互联网计算机上。作为PHP程序员，你会在自己的机器上进行大量本地开发。当你觉得一个项目准备好了，你会在公共服务器上测试它，最后，在所有测试完成后将网站发布到线上。
- en: The HTTP Request-Response Cycle
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 请求-响应周期
- en: At the heart of web-based client/server communications is the *http request-response
    cycle*. At a high level, a client sends a *request* to the server, and the server
    returns a *response* to the client. The response itself may be an error code,
    or it could be a message whose body is text, an image file, a binary executable,
    or other content. [Figure 10-1](#fig10-1) illustrates a simple request-response
    cycle.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于网页的客户端/服务器通信的核心是*HTTP 请求-响应周期*。从高层次来看，客户端向服务器发送*请求*，然后服务器向客户端返回*响应*。响应本身可以是一个错误代码，或者是一个包含文本、图像文件、二进制可执行文件或其他内容的消息。[图
    10-1](#fig10-1)展示了一个简单的请求-响应周期。
- en: '![](../images/figure10-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure10-1.jpg)'
- en: 'Figure 10-1: A simple HTTP request-response cycle'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1：一个简单的HTTP请求-响应周期
- en: The client, a web browser, sends a request asking for the *index.xhtml* file
    ❶. The server receives and decodes the request, then searches for and successfully
    finds the requested resource (file) ❷. The server then creates and returns a response,
    whose body is the HTML text of *index.xhtml* ❸. Finally, the web browser reads
    through the received HTML and displays the web page contents nicely to the user
    in the browser window ❹.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端，即一个网页浏览器，发送请求，要求获取*index.xhtml*文件❶。服务器接收到并解码请求，然后搜索并成功找到请求的资源（文件）❷。服务器接着创建并返回一个响应，其主体是*index.xhtml*的HTML文本❸。最后，网页浏览器读取收到的HTML，并在浏览器窗口中漂亮地显示网页内容给用户❹。
- en: 'Clients can send different types of requests. The two most common request methods
    are GET and POST. The HTTP GET method is simpler and, when using a web browser
    client, displays much of what’s being sent in the web browser URL address bar.
    For example, if you use the Google search engine to search for the phrase *cheese
    cake*, you’ll see those words appear at the end of the URL when you send the query
    to Google: *https://www.google.com/search?q=cheese+cake*. In fact, anytime you
    type a URL into the web browser address bar and hit ENTER, you’re sending a GET
    request.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以发送不同类型的请求。两种最常见的请求方法是 GET 和 POST。HTTP GET 方法更简单，在使用 Web 浏览器客户端时，显示许多发送的内容在
    Web 浏览器的 URL 地址栏中。例如，如果你使用 Google 搜索引擎搜索 *cheese cake* 这个短语，你会看到这些词出现在 URL 的末尾，发送查询给
    Google 时是这样的：*https://www.google.com/search?q=cheese+cake*。实际上，每当你在浏览器地址栏中输入一个
    URL 并按下回车键时，你就是在发送 GET 请求。
- en: The POST method, on the other hand, can hide much of what’s being sent in the
    body of the request message. Therefore, it’s often used for more private website
    operations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: POST 方法可以隐藏请求消息体中发送的许多内容。因此，它通常用于更私密的网站操作。
- en: In addition to GET and POST, the original HTTP 1.0 defined a third method, HEAD.
    It asks for a response with no body, just the headers, which contain general information
    about the response. Since the introduction of HTTP 1.1, five other methods are
    permitted (OPTIONS, PUT, DELETE, TRACE, and CONNECT). These aren’t needed for
    the level of web development in this book, although they can be useful for sophisticated
    web applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 GET 和 POST，原始的 HTTP 1.0 定义了第三种方法 HEAD。它请求一个没有消息体的响应，只有头部，其中包含关于响应的一般信息。自从引入
    HTTP 1.1 后，还允许使用其他五种方法（OPTIONS、PUT、DELETE、TRACE 和 CONNECT）。这些方法对于本书中讨论的 Web 开发层级并不需要，尽管它们对于复杂的
    Web 应用程序来说是有用的。
- en: Response Status Codes
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 响应状态码
- en: At the beginning of every HTTP response returned by the server is a three-digit
    HTTP *status code* that tells the client the status of the server’s attempt to
    process and fulfill the request. All HTTP-compliant servers must use a set of
    standard codes, and on top of that, custom codes are used by different servers.
    The most common codes are 200 OK to indicate that a request has been successfully
    fulfilled and 404 Not Found to indicate that the server was unable to find the
    requested resource.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个由服务器返回的 HTTP 响应开头都有一个三位数的 HTTP *状态码*，告诉客户端服务器尝试处理并完成请求的状态。所有符合 HTTP 标准的服务器必须使用一套标准代码，此外，不同的服务器还会使用自定义代码。最常见的代码是
    200 OK，表示请求已成功完成，以及 404 Not Found，表示服务器无法找到请求的资源。
- en: 'The first digit of the code indicates the general status of the server’s interpretation
    and processing of the request. Here’s a summary of what the first-digit prefixes
    signify:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码的第一位数字表示服务器对请求的解释和处理的总体状态。以下是第一位数字的含义概述：
- en: 1nn **(information)**   The request headers were received and understood, and
    further processing is needed. In other words, “So far so good, but not finished
    yet.” These status codes are fairly uncommon. They’re informational and used when
    the server needs to communicate some information, but not a full response, back
    to the client.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 1nn **(信息性状态码)**   请求头已经接收并理解，进一步处理需要进行。换句话说，“到目前为止一切顺利，但还没有完成。”这些状态码相对不常见，它们是信息性状态码，用于当服务器需要向客户端传达某些信息，但不是完整的响应时。
- en: 2nn **(success)**   The request was received, understood, and accepted (for
    example, 200 OK).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 2nn **(成功)**   请求已接收、理解并接受（例如，200 OK）。
- en: 3nn **(redirection)**   The request was understood, but the client must take
    further action, such as choosing from options (300 Multiple Choices) or following
    a new URL if the resource has permanently moved (301 Moved Permanently).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 3nn **(重定向)**   请求已理解，但客户端必须采取进一步行动，例如从选项中选择（300 多重选择）或如果资源已永久移动，按照新 URL 访问（301
    永久移动）。
- en: 4nn **(client error)**   Either the request is invalid (such as 400 Bad Request),
    or the server can’t fulfill the request because of client error (such as 404 Not
    Found or 403 Forbidden).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 4nn **(客户端错误)**   请求无效（如 400 错误请求），或者由于客户端错误，服务器无法完成请求（如 404 未找到或 403 禁止访问）。
- en: 5nn **(server error)**   The server has experienced an error or is unable to
    complete the request for other reasons. Examples include 500 Server Error and
    502 Service Unavailable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 5nn **(服务器错误)**   服务器遇到错误或因其他原因无法完成请求。例子包括 500 服务器错误和 502 服务不可用。
- en: 'You can learn more about HTTP and its status codes at Todd Fredrich’s free
    online REST API tutorial: *[https://www.restapitutorial.com](https://www.restapitutorial.com)*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Todd Fredrich的免费在线REST API教程中了解更多关于HTTP及其状态码的内容：*[https://www.restapitutorial.com](https://www.restapitutorial.com)*。
- en: '#### An Example GET Request'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 一个GET请求的例子'
- en: Let’s look at a simple example of the request-response cycle by examining what
    happens behind the scenes when we visit the No Starch Press website. First, you
    need to display the browser request-response inspection tools. In Google Chrome,
    these tools are usually accessible as a menu item named Developer Tools. Once
    the developer tools are open, you’ll see a window like that at the bottom of [Figure
    10-2](#fig10-2).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看访问No Starch Press网站时发生的幕后情况，来看一个简单的请求-响应周期的例子。首先，你需要显示浏览器的请求-响应检查工具。在Google
    Chrome中，这些工具通常可以通过名为开发者工具的菜单项访问。打开开发者工具后，你会看到一个窗口，类似于[图10-2](#fig10-2)底部的样子。
- en: '![](../images/figure10-2.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure10-2.jpg)'
- en: 'Figure 10-2: A GET request to the No Starch Press home page'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-2：GET请求No Starch Press主页
- en: Click the **Network** tab, and you’re ready to record and examine the HTTP request-response
    cycle. Type **nostarch.com** in the browser URL address bar. When you press ENTER,
    you should see the home page appear. Find the Name column on the left of the developer
    window, locate the first file, which should be *nostarch.com*, and click it. Click
    **Headers** to see the HTTP headers summary, shown in [Figure 10-3](#fig10-3).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**网络**标签，你就可以开始记录和查看HTTP请求-响应周期了。在浏览器地址栏中输入**nostarch.com**。当你按下ENTER键时，你应该能看到主页出现。在开发者窗口的左侧找到“名称”列，定位到第一个文件，它应该是*nostarch.com*，然后点击它。点击**头部**以查看HTTP头部的总结，显示在[图10-3](#fig10-3)中。
- en: This summary indicates that the HTTP request is for the URL *[https://nostarch.com](https://nostarch.com)*
    and that the request method is GET (since we just entered a URL in the address
    bar). The most important part of the HTTP response header is the success status
    code of 200.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个总结表示，HTTP请求的目标是网址*[https://nostarch.com](https://nostarch.com)*，请求方法为GET（因为我们刚在地址栏中输入了网址）。HTTP响应头中最重要的部分是200的成功状态码。
- en: Scroll farther down the HTTP headers contents and you’ll see full details of
    both the HTTP request and HTTP response headers. Under the Request Headers section,
    you can see the list of file types that the web client is willing to accept, such
    as HTML, XML, images, and so on. You can also see which human language the content
    is available in (for example, EN for English). Correspondingly, the response headers
    indicate the actual content type in the body of the response, such as text/html,
    the date the file was last modified, and so on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动HTTP头部内容，你将看到HTTP请求和HTTP响应头部的详细信息。在请求头部部分，你可以看到网页客户端愿意接受的文件类型列表，如HTML、XML、图像等。你还可以看到内容可用的语言（例如，EN代表英语）。对应地，响应头部则指示响应体中的实际内容类型，如text/html、文件的最后修改日期等。
- en: NOTE
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The majority of modern websites now use HyperText Transfer Protocol Secure
    (HTTPS), which enables the client and server to exchange certificates allowing
    HTTP messages to be securely encrypted. This is why the No Starch Press URL begins
    with* https://*. HTTPS is built into many PHP web servers, so we won’t go into
    it at this point.*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*现代大多数网站现在使用超文本传输协议安全（HTTPS），它使客户端和服务器能够交换证书，从而确保HTTP消息的加密传输。这就是为什么No Starch
    Press的网址以* https://*开头的原因。HTTPS已集成在许多PHP网页服务器中，因此我们此时不再深入讨论它。*'
- en: Now click the **Response** tab to see the content of the response’s body, shown
    in [Figure 10-3](#fig10-3). This is the HTML text that the web browser receives
    and then renders to make an attractive-looking graphical web page for you to see
    and interact with.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击**响应**标签查看响应体的内容，如[图10-3](#fig10-3)所示。这是网页浏览器接收到的HTML文本，然后它会渲染成一个吸引人的图形网页，供你查看和交互。
- en: '![](../images/figure10-3.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure10-3.jpg)'
- en: 'Figure 10-3: HTML text content in the HTTP response body'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-3：HTTP响应体中的HTML文本内容
- en: At the bottom of the HTML code, you’ll see a list of CSS links. When processing
    the received HTML, the web client (browser) looks for any additional content files
    needed for the web page, like CSS stylesheets, image files, and JavaScript files.
    The browser quickly (we rarely notice this with modern network speeds) makes additional
    HTTP requests to the server for each of these files, and as the corresponding
    HTTP responses arrive, the browser renders the web page. These extra files received
    from the web server can be seen in the Name column in [Figure 10-2](#fig10-2),
    beneath the original request to *nostarch.com*. They have names like *css_lQaZ*
    and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 代码的底部，你会看到一列 CSS 链接。当处理收到的 HTML 时，Web 客户端（浏览器）会寻找页面所需的其他内容文件，如 CSS 样式表、图像文件和
    JavaScript 文件。浏览器会快速地（在现代网络速度下我们很少注意到这一点）向服务器发起额外的 HTTP 请求来获取这些文件，并且随着相应的 HTTP
    响应到达，浏览器会渲染网页。这些从 Web 服务器收到的额外文件可以在 [图 10-2](#fig10-2) 的名称列中看到，位于原始请求 *nostarch.com*
    下面，它们的名称像 *css_lQaZ* 等等。
- en: It’s important to underscore that not every HTTP request has to be initiated
    by a human user entering a URL, clicking a link, or submitting a form. The web
    browser can, behind the scenes (asynchronously), make additional requests for
    required resources such as images, CSS files, and JavaScript files. These additional
    requests may be to the same web server that delivered the HTML the browser is
    processing, or to other web servers (perhaps to download a free Google font, for
    example, or the Bootstrap CSS and JavaScript).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，并非每个 HTTP 请求都必须由用户通过输入 URL、点击链接或提交表单来发起。Web 浏览器可以在后台（异步地）发起额外的请求，以获取所需的资源，例如图像、CSS
    文件和 JavaScript 文件。这些额外的请求可能会发送到与浏览器正在处理的 HTML 相同的 Web 服务器，或者发送到其他 Web 服务器（例如，下载免费的
    Google 字体或 Bootstrap CSS 和 JavaScript）。
- en: NOTE
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*JavaScript code can also make additional HTTP requests, such as retrieving
    data from remote websites. This is known as* asynchronous JavaScript and XML (AJAX)*,
    although many types of data files may be retrieved, such as JSON and plaintext,
    so such HTTP requests aren’t limited to retrieving only XML data. This topic is
    beyond the scope of this PHP book.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript 代码也可以发起额外的 HTTP 请求，例如从远程网站获取数据。这被称为* 异步 JavaScript 和 XML (AJAX)*，虽然许多类型的数据文件可以被检索，例如
    JSON 和纯文本，因此这样的 HTTP 请求并不限于仅检索 XML 数据。这个话题超出了本 PHP 书的范围。*'
- en: How Servers Operate
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器的运作方式
- en: We’ve discussed at a high level how clients and servers communicate through
    HTTP requests and responses. Now let’s take a closer look at how web servers function.
    We’ll also begin to see how PHP can play a role in the server’s operations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在较高层次上讨论了客户端和服务器如何通过 HTTP 请求和响应进行通信。现在，让我们更仔细地看看 Web 服务器的工作原理。我们还将开始了解 PHP
    如何在服务器的操作中发挥作用。
- en: Simple Web Servers for File Retrieval
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用于文件检索的简单 Web 服务器
- en: The task of a simple web server is to listen for requests for resources and,
    when a request is received, to identify the resource requested and return either
    a message containing the resource or an error message if it can’t be found. A
    simple web server is basically a file server that’s able to understand HTTP requests
    and send HTTP responses. [Figure 10-4](#fig10-4) illustrates a simple web server.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 简单 Web 服务器的任务是监听资源请求，并在收到请求时，识别请求的资源并返回包含资源的消息，或者如果找不到该资源，则返回错误消息。简单的 Web 服务器本质上是一个能够理解
    HTTP 请求并发送 HTTP 响应的文件服务器。[图 10-4](#fig10-4) 展示了一个简单的 Web 服务器。
- en: '![](../images/figure10-4.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure10-4.jpg)'
- en: 'Figure 10-4: A simple web server communication with a web client'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-4：简单的 Web 服务器与 Web 客户端的通信
- en: Typically, the client sends a GET request ❶, requesting a file such as *index.xhtml*,
    *style.css*, or *logo.png*. The server receives and interprets the request, then
    searches for the requested resource (file) ❷. If the file can’t be found, the
    server creates and returns a 404 Not Found error. If the file is found, the server
    retrieves its contents ❸. Finally, the server creates and returns a response to
    the client ❹. The response body is the content of the requested file, and its
    header includes the 200 OK status code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，客户端发送一个 GET 请求 ❶，请求一个文件，如 *index.xhtml*、*style.css* 或 *logo.png*。服务器接收并解释该请求，然后搜索请求的资源（文件）
    ❷。如果文件找不到，服务器会创建并返回一个 404 Not Found 错误。如果文件找到，服务器将检索其内容 ❸。最后，服务器会创建并返回一个响应给客户端
    ❹。响应体是请求文件的内容，其头部包括 200 OK 状态码。
- en: 'A good analogy for this process is that a simple web server functions like
    a librarian in a library: the librarian goes off to locate a requested book and
    returns with either the book or a message saying the book can’t be located.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '这个过程的一个很好的类比是，一个简单的网页服务器就像图书馆中的图书管理员：图书管理员会去找到请求的书籍，并带回书籍或一条信息，说明书籍无法找到。  '
- en: Simple web servers are sufficient for hypertext or hypermedia browsing of an
    unchanging set of HTML pages, such as a set of frequently asked questions (FAQ)
    and answer paragraphs or reference materials that rarely need to be updated, like
    a user manual. Simple web servers are *stateless*, meaning the same request will
    always get the same file returned. Different clients will also get the same file
    returned. This is often termed *static* content to indicate that it’s unchanging.
    Returning to the librarian analogy, you wouldn’t expect a librarian to change
    the content of a book as they’re retrieving it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '简单的网页服务器足以支持超文本或超媒体浏览不变的HTML页面集，例如常见问题解答（FAQ）及其回答段落，或者是很少需要更新的参考资料，如用户手册。简单的网页服务器是*无状态的*，这意味着相同的请求总是返回相同的文件。不同的客户端也会收到相同的文件。这通常被称为*静态*内容，表示它是固定不变的。回到图书管理员的类比，你不会期望图书管理员在取书时改变书的内容。  '
- en: 'We can summarize the behavior of simple stateless web servers as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以总结简单的无状态网页服务器的行为如下：  '
- en: Never changes
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '永不改变  '
- en: The same regardless of whether the user has visited before
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '无论用户是否曾经访问过，都一样  '
- en: The same for every user
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对每个用户都相同  '
- en: Most web activity is more interactive than simply clicking links to specific
    static documents. The majority of modern web projects require *dynamic interactivity*,
    in which the system responds differently according to user inputs. Dynamic interactivity
    encompasses tasks like processing web forms, managing shopping carts, customizing
    content based on recent browsing history, and more. Most PHP web applications
    are *dynamic* web servers, which we’ll explore next.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '大多数网页活动比仅仅点击链接获取特定的静态文档要更加互动。大多数现代网页项目需要*动态交互性*，即系统根据用户输入做出不同的响应。动态交互性包括处理网页表单、管理购物车、根据最近的浏览历史定制内容等任务。大多数PHP网页应用程序是*动态*网页服务器，接下来我们将深入探讨。  '
- en: Dynamic Web Servers for Processing Data
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '处理数据的动态网页服务器  '
- en: 'For a web-based system to be interactive beyond static resource retrieval,
    further technologies are required beyond basic content markup and hypertext linking.
    These capabilities include the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '对于一个基于网页的系统，要实现超越静态资源获取的交互性，除了基本的内容标记和超文本链接外，还需要其他技术。这些能力包括以下内容：  '
- en: Support for user input methods, like inputting text, clicking buttons, and choosing
    from menus
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '支持用户输入方法，如输入文本、点击按钮和从菜单中选择  '
- en: Short code scripts that can process and respond in different ways to different
    user inputs
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '可以根据不同的用户输入以不同方式处理和响应的简短代码脚本  '
- en: Methods for the browser to send user inputs or data to the server programs that
    will process the data and generate interactive responses
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '浏览器将用户输入或数据发送到服务器程序，以便处理数据并生成交互式响应的方法  '
- en: Dynamic servers with capabilities such as these handle many typical modern internet
    activities, like entering keywords into a search engine and being presented with
    a tailor-made page of prioritized links, logging into your personal email system
    and retrieving your own email in your inbox, and browsing catalogs of products
    online and making a purchase using a credit card.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '具备这些功能的动态服务器处理许多现代互联网活动，如在搜索引擎中输入关键词并呈现一个定制的、优先排序的链接页面，登录到个人电子邮件系统并查看自己的收件箱中的邮件，在线浏览商品目录并使用信用卡完成购买。  '
- en: In this book, we’re most interested in dynamic web servers that understand and
    can run PHP scripts. [Figure 10-5](#fig10-5) illustrates client communication
    with one such dynamic web server.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '在本书中，我们最关注的是理解并能运行PHP脚本的动态网页服务器。[图10-5](#fig10-5)展示了客户端与这样一个动态网页服务器的通信。  '
- en: '![](../images/figure10-5.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure10-5.jpg)  '
- en: 'Figure 10-5: A dynamic web server communication with a web client'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-5：动态网页服务器与网页客户端的通信
- en: In this model, the client sends an HTTP request to the server ❶. Then the server
    program interprets the request and identifies which PHP server script should be
    executed ❷. The script is executed ❸ and generates output, such as HTML text.
    Running a PHP script can also trigger other actions on the web server, such as
    communication with a database, which is something we’ll explore in [Part VI](part6.xhtml).
    Next, the web server application receives the output ❹. Finally, the output is
    packaged up in the body of an HTTP response message and returned with appropriate
    headers to the client that originally made the request ❺.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模型中，客户端向服务器发送 HTTP 请求 ❶。然后，服务器程序解析请求并识别应执行哪个 PHP 服务器脚本 ❷。脚本执行 ❸ 并生成输出，例如 HTML
    文本。运行 PHP 脚本还可能触发 Web 服务器上的其他操作，例如与数据库的通信，这是我们将在[第六部分](part6.xhtml)中探讨的内容。接下来，Web
    服务器应用程序接收输出 ❹。最后，输出被打包到 HTTP 响应消息的主体中，并带着适当的头信息返回给最初发出请求的客户端 ❺。
- en: The Routing Process
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 路由过程
- en: '*Routing* is the process the web server uses in deciding what to do to respond
    appropriately to the HTTP request it has received; the server examines the request
    and determines what action it believes the client is requesting, such as asking
    for a file, trying to log in with username and password data included in the request,
    deleting an item from a database, and so on. In the simplest scenario, the request
    contains a valid path for a specific resource file, like */images/logo.jpg* or
    */styles/homepage.css*. In this case, the web server acts like a file server and
    returns an HTTP response message containing the contents of the file with appropriate
    header information.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*路由*是 Web 服务器用来决定如何响应所收到的 HTTP 请求的过程；服务器检查请求并确定它认为客户端请求的操作，如请求文件、尝试使用包含在请求中的用户名和密码数据登录、从数据库中删除项等。在最简单的情况下，请求包含特定资源文件的有效路径，如*/images/logo.jpg*或*/styles/homepage.css*。在这种情况下，Web
    服务器充当文件服务器，返回包含文件内容并带有适当头信息的 HTTP 响应消息。'
- en: If a valid path to a publicly available.*php* file is requested, such as */about.php*,
    that PHP script will be interpreted and executed to build the HTTP response that’s
    returned to the client. If no specific file is requested, almost all web servers
    have *default routing* defined, which will often route to a home page file, usually
    named *index*. Simple static web servers will look for *index.xhtml* to return
    as the default home page, whereas PHP web servers will usually look first for
    *index.php* and perhaps then look for *index.xhtml* if no default PHP file is
    found. If no file is requested and no index file is found, the server will return
    a 404 Not Found response.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求了有效的公开可用的*php*文件路径，如*/about.php*，则该 PHP 脚本将被解释并执行，以构建返回给客户端的 HTTP 响应。如果没有请求特定的文件，几乎所有
    Web 服务器都有定义的*默认路由*，通常会路由到主页文件，通常为*index*。简单的静态 Web 服务器会查找*index.xhtml*作为默认主页返回，而
    PHP Web 服务器通常会首先查找*index.php*，如果没有找到默认的 PHP 文件，则可能会查找*index.xhtml*。如果没有请求文件且未找到索引文件，服务器将返回
    404 Not Found 响应。
- en: Sophisticated PHP web applications will use logic encoded inside the default
    *index.php* script to examine the contents and pattern of the URL path requested
    and from there decide how to respond to the request. An *index.php* file that
    uses logic like this to manage the complexity of a many-featured website is known
    as a *front controller*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的 PHP Web 应用程序将使用编码在默认*index.php*脚本中的逻辑来检查请求的 URL 路径的内容和模式，从而决定如何响应请求。使用这种逻辑来管理多功能网站复杂性的*index.php*
    文件被称为*前端控制器*。
- en: 'Here are some examples of the types of URLs that web browsers use to make requests
    to web servers, with explanations of what they mean:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Web 浏览器用来向 Web 服务器发出请求的一些 URL 示例，并附有解释其含义：
- en: '***tudublin.ie***   No path is indicated beyond the domain name, so the web
    server will execute the default home page script (*index.php* if it’s a PHP web
    server). The TU Dublin home page HTML content is returned to the client.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '***tudublin.ie***   在域名后没有指定路径，因此 Web 服务器将执行默认的主页脚本（如果是 PHP Web 服务器，则为*index.php*）。TU
    Dublin 主页的 HTML 内容会返回给客户端。'
- en: '***bbc.com/travel/columns/discovery***   The path contains text separated by
    forward slashes, so the home page script executes with logic to search the site’s
    database for today’s content relating to the main topic *travel* and the subtopic
    *discovery*.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '***bbc.com/travel/columns/discovery***   该路径包含通过斜杠分隔的文本，因此主页脚本执行逻辑，搜索站点数据库中与主要话题*旅行*和子话题*发现*相关的内容。'
- en: '***nostarch.com/sites/all/themes/nostarch/logo.png***   The path includes a
    static resource file, so the web server locates and returns the contents of the
    *logo.png* image file.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '***nostarch.com/sites/all/themes/nostarch/logo.png***   路径包含一个静态资源文件，因此Web服务器会定位并返回*logo.png*图像文件的内容。'
- en: '***google.com/search?q=cheese+cake***   The path contains text indicating a
    search after the forward slash (*search*) and then the search text (*cheese cake*)
    in a variable (*q*) assigned after a question mark character (*?*). So the Google
    home page script executes with logic to search for web pages relating to *cheese
    cake*. In [Chapter 11](chapter11.xhtml), you’ll learn all about passing data through
    variables in URLs like this one.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '***google.com/search?q=cheese+cake***   路径包含指示搜索的文本，在正斜杠后面（*search*），然后是搜索文本（*cheese
    cake*），这是一个在问号字符（*?*）后面赋值的变量（*q*）。因此，Google主页脚本会执行逻辑，搜索与*cheese cake*相关的网页。在[第11章](chapter11.xhtml)中，你将学习如何通过变量在URL中传递数据。'
- en: In [Chapter 13](chapter13.xhtml), we’ll look at how to write PHP front-controller
    logic to perform routing decisions such as the ones summarized here.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](chapter13.xhtml)中，我们将研究如何编写PHP前端控制器逻辑来执行路由决策，类似于这里总结的内容。
- en: Templating
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板
- en: Almost all PHP applications are designed to run websites. For most HTTP requests,
    the content of the response is some sort of text, like an HTML, JavaScript, or
    CSS file, or perhaps data encoded as JSON or XML. PHP consequently was designed
    to facilitate outputting text (with, for example, the print and echo commands).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有PHP应用程序都设计用来运行网站。对于大多数HTTP请求，响应的内容是某种文本，如HTML、JavaScript或CSS文件，或者可能是编码为JSON或XML的数据。因此，PHP的设计是为了方便输出文本（例如，使用print和echo命令）。
- en: 'Further, as was hinted in [Chapter 1](chapter1.xhtml), the language also makes
    it easy to mix prewritten text such as HTML with text created on the fly by executing
    PHP code. This feature is what makes PHP a *templating language*: it can insert
    dynamically generated values into static templates of HTML or other text. PHP-driven
    websites benefit from this sort of dynamic output, which may result from database
    interactions or communication between various data sources like Google Maps, weather
    APIs, and so on.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如[第1章](chapter1.xhtml)中所暗示的，语言还使得将预写文本（如HTML）与通过执行PHP代码动态生成的文本混合变得容易。这个特性使得PHP成为*模板语言*：它可以将动态生成的值插入到HTML或其他文本的静态模板中。基于PHP的网站受益于这种动态输出，可能是通过数据库交互或与各种数据源（如Google
    Maps、天气API等）的通信来实现的。
- en: In the previous chapters, we’ve been writing pure PHP programs, which are scripts
    that contain only PHP code. Once we start using PHP as a templating language,
    mixing PHP statements with other template text (often HTML) becomes more common.
    This allows us to write the unchanging HTML for web pages as just HTML; any parts
    that need to change dynamically can be output from the logic we write in PHP statements.
    Conveniently, the HTML in many website pages contains much of the same content,
    such as a header, a navigation bar (which might change only by highlighting the
    particular page being visited), and page layout HTML code (for example, a hierarchy
    of div, header, and footer elements). All this nonchanging, static content is
    perfect for PHP templating.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们编写了纯PHP程序，这些程序仅包含PHP代码。一旦我们开始使用PHP作为模板语言，混合PHP语句和其他模板文本（通常是HTML）变得更加常见。这使得我们可以将不变的HTML网页部分直接写为HTML；任何需要动态变化的部分都可以通过我们在PHP语句中编写的逻辑来输出。方便的是，许多网页中的HTML包含大量相同的内容，例如页头、导航栏（可能仅通过突出显示访问的特定页面而发生变化）和页面布局HTML代码（例如，div、header和footer元素的层次结构）。所有这些不变的静态内容都非常适合用于PHP模板。
- en: It’s theoretically possible to make a pure PHP script output HTML by writing
    lots of print statements, but this approach results in code that’s long and hard
    to read. Take a look at [Listing 10-1](#lis10-1), which outputs HTML by using
    pure PHP print statements.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，通过编写大量的print语句，可以让纯PHP脚本输出HTML，但这种方法会导致代码冗长且难以阅读。请查看[清单10-1](#lis10-1)，它通过使用纯PHP
    print语句来输出HTML。
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 10-1: Outputting HTML through print statements'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 清单10-1：通过print语句输出HTML
- en: The only real PHP logic we’re using here is calling the date() function to get
    the current date as a string in the form *Month day, year* (for example, *January
    1, 2025*) ❶. All other lines are print statements that output unchanging HTML,
    and these print statements aren’t necessary. We can make the code more compact
    and readable by using PHP only where it’s needed, inserting it into an HTML template.
    That’s what we do in [Listing 10-2](#lis10-2), where the unchanging HTML is written
    just as it will appear in the final HTML text file to be sent to the client.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的唯一真正的 PHP 逻辑是调用 `date()` 函数，以字符串形式获取当前日期，格式为 *月 日, 年*（例如，*2025年1月1日*）❶。其他所有行都是输出不变的
    HTML 的打印语句，这些打印语句并不是必需的。通过仅在需要的地方使用 PHP，并将其插入到 HTML 模板中，我们可以使代码更加简洁和可读。这正是我们在[示例
    10-2](#lis10-2)中所做的，在那里不变的 HTML 被直接写入，正如它最终将出现在发送给客户端的 HTML 文本文件中。
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 10-2: Mixing HTML template text with a PHP code block'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-2：将 HTML 模板文本与 PHP 代码块混合
- en: We use opening ❶ and closing ❷ PHP tags to surround just the print statement
    where we call the date() function, since this is the only place where PHP code
    is needed to dynamically generate content. Meanwhile, we’ve written everything
    else as regular HTML; no prints, quotes, or semicolons are needed. [Figure 10-6](#fig10-6)
    shows how PHP sees and processes the script content.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用开头的 ❶ 和结尾的 ❷ PHP 标签将调用 `date()` 函数的打印语句包围起来，因为这是唯一需要 PHP 代码来动态生成内容的地方。与此同时，我们将其他所有内容编写为常规
    HTML；不需要打印语句、引号或分号。[图 10-6](#fig10-6)显示了 PHP 如何查看并处理脚本内容。
- en: '![](../images/figure10-6.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure10-6.jpg)'
- en: 'Figure 10-6: How PHP processes mixed template text and dynamic code'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-6：PHP 如何处理混合模板文本和动态代码
- en: First, a block of template text needs to be copied verbatim into the text output.
    Next, a block of PHP code (between <?php and ?>) needs to be interpreted and executed
    before the result is added to the script’s text output. Finally, another block
    of template text needs to be copied verbatim to the output text. The temporary
    store for the text being output by the multiple parts of a PHP script is referred
    to as the *output buffer*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要将一块模板文本逐字复制到文本输出中。接下来，需要解释和执行一块 PHP 代码（位于 <?php 和 ?> 之间），然后将结果添加到脚本的文本输出中。最后，需要将另一块模板文本逐字复制到输出文本中。PHP
    脚本的多个部分输出的文本的临时存储区被称为 *输出缓冲区*。
- en: Imagine for a moment that the script in [Listing 10-2](#lis10-2) is part of
    an HTTP request from a web browser. When all PHP execution in the script is completed,
    the text in the output buffer will be wrapped up into an HTTP response by adding
    headers and then sent back to the browser web client. The browser will then render
    (draw) the web page for the user to see, interpreting the HTML it received in
    the body text of the HTTP response, resulting in the simple page shown at the
    bottom of [Figure 10-6](#fig10-6).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设[示例 10-2](#lis10-2)中的脚本是来自 web 浏览器的 HTTP 请求的一部分。当脚本中的所有 PHP 执行完成后，输出缓冲区中的文本将通过添加头部信息被封装成一个
    HTTP 响应，并发送回浏览器客户端。然后，浏览器将渲染（绘制）网页以供用户查看，解释它在 HTTP 响应的主体文本中收到的 HTML，从而显示[图 10-6](#fig10-6)底部所示的简单页面。
- en: PHP Tags
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PHP 标签
- en: As you’ve just seen, when you embed PHP code in template text, it’s important
    to use both the opening <?php tag and the closing ?> tag to delimit the code.
    By contrast, when writing PHP scripts that contain *just* code without any template
    text, the script should start with an opening <?php tag, but you shouldn’t include
    the closing ?> tag at the end of the file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚才看到的，当你在模板文本中嵌入 PHP 代码时，重要的是使用开头的 <?php 标签和结尾的 ?> 标签来界定代码。相比之下，当编写仅包含代码的
    PHP 脚本时，脚本应以开头的 <?php 标签开始，但不应在文件末尾包含结尾的 ?> 标签。
- en: You leave off the closing tag for two reasons. First, you don’t need it, since
    the code has no template text to be separated from the PHP statements. Second,
    if you did include the closing PHP tag, any (unintentional and invisible) whitespace
    that occurs after the closing tag, including spaces, tabs, or newline characters,
    will be interpreted as template text and could prematurely begin creating the
    output buffer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你省略结尾标签有两个原因。首先，你不需要它，因为代码没有模板文本需要与 PHP 语句分隔开。其次，如果你包括了结尾的 PHP 标签，任何（无意的且不可见的）空白字符，如空格、制表符或换行符，都会在结尾标签后出现，并被解释为模板文本，可能会过早开始创建输出缓冲区。
- en: Short Echo Tags
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 短 echo 标签
- en: We’ve so far focused on PHP’s main <?php tag, but the language also provides
    a *short echo tag*, denoted with the <?= symbol, that further simplifies templating.
    This tag allows you to avoid writing lengthy commands when all you want to do
    is output the result of an expression as text. This might be to display the contents
    of a variable, or the result of a complex calculation or series of string concatenations.
    For example, instead of writing something like <?php print $someVariable; ?> to
    output the value of $someVariable, you can simply write <?= $someVariable ?> with
    the short echo tag.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直关注 PHP 的主要 `<?php` 标签，但该语言还提供了一个*简短回显标签*，用 `<?=` 符号表示，它进一步简化了模板编写。这个标签可以让你避免编写冗长的命令，当你只想将表达式的结果输出为文本时。比如，显示一个变量的内容，或者是复杂计算或字符串连接的结果。例如，你可以用简短的回显标签
    `<?= $someVariable ?>` 代替写 `<?php print $someVariable; ?>` 来输出 `$someVariable`
    的值。
- en: The short echo tag calls for less typing since it omits print (or echo) and
    doesn’t require an ending semicolon. Also, any experienced PHP programmer who
    encounters the short echo tag can immediately recognize that the only logic is
    to output a string. Overall, the key advantage of the short echo tag is that it
    doesn’t distract the reader (or writer) with extraneous PHP code-block syntax
    when a script mostly contains HTML template text. The dynamically generated PHP
    code values blend in better with the surrounding HTML, as [Listing 10-3](#lis10-3)
    illustrates.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 简短回显标签减少了输入，因为它省略了 print（或 echo），并且不需要结尾的分号。此外，任何有经验的 PHP 程序员看到简短回显标签时，能立刻识别出唯一的逻辑就是输出一个字符串。总体来说，简短回显标签的主要优势在于，当脚本主要包含
    HTML 模板文本时，它不会让读者（或编写者）被多余的 PHP 代码块语法分心。动态生成的 PHP 代码值与周围的 HTML 更好地融合，正如[清单 10-3](#lis10-3)所示。
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 10-3: Simplifying code with the PHP short echo tag'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-3：使用 PHP 简短回显标签简化代码
- en: In a full PHP code block surrounded by ordinary PHP tags, we create a $dateString
    variable containing our formatted date string ❶. This frees us up to simply write
    <?= $dateString ?>, using the short echo tag at the spot in the template where
    we want the string to be output ❷. There’s no need for a print statement or semicolon.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完整的 PHP 代码块中，包围在普通 PHP 标签之间，我们创建了一个包含格式化日期字符串的 `$dateString` 变量 ❶。这让我们可以简单地在模板中希望输出字符串的位置写
    `<?= $dateString ?>`，使用简短回显标签 ❷。无需编写 print 语句或分号。
- en: The Model-View-Controller Architecture
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型-视图-控制器架构
- en: Almost all large-scale web applications delegate different responsibilities
    to different system components. Most do this by implementing some form of the
    *model-view-controller (MVC)* architecture. This is a software design pattern
    that distinguishes between the data underlying the software (the *model*), the
    way that data is displayed to the user (the *view*), and the decisions about what
    data to display when (the *controller*).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的大型 Web 应用程序都会将不同的责任委派给不同的系统组件。大多数应用通过实现某种形式的*模型-视图-控制器（MVC）*架构来做到这一点。这是一种软件设计模式，用于区分软件的基础数据（*模型*）、数据如何显示给用户（*视图*）以及何时显示哪些数据的决策（*控制器*）。
- en: We’ve already touched on aspects of the MVC architecture in this chapter. We’ve
    noted how PHP applications can make routing decisions based on incoming HTTP requests
    (a controller task) and how we can use PHP for templating by injecting dynamically
    generated values into static HTML text (a view task). Now let’s fill in a few
    more gaps to see how the MVC pattern fits into the request-response cycle. [Figure
    10-7](#fig10-7) illustrates a typical interpretation of the MVC architecture for
    a web application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们已经涉及了 MVC 架构的一些方面。我们提到过 PHP 应用程序如何根据传入的 HTTP 请求做路由决策（控制器任务），以及如何通过将动态生成的值注入静态
    HTML 文本来使用 PHP 进行模板化（视图任务）。现在让我们再填补一些空白，看看 MVC 模式如何适应请求-响应周期。[图 10-7](#fig10-7)
    展示了 Web 应用程序中 MVC 架构的典型解释。
- en: '![](../images/figure10-7.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure10-7.jpg)'
- en: 'Figure 10-7: The MVC architecture common for web applications'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-7：Web 应用程序常见的 MVC 架构
- en: First, the web client sends an HTTP request ❶. Then the controller (the main
    application logic) interprets the request and decides what to do ❷. This may involve
    checking any stored security credentials and other data (such as shopping-cart
    contents) and deciding the appropriate actions to take in response to the received
    request. Often the controller needs to read the contents of a data store, such
    as a database system, file store, or even an API running on another server. This
    data is the model component of the MVC pattern. If the received request contains
    data submitted from a form, the controller may need to update or delete some of
    the model data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Web客户端发送一个HTTP请求❶。然后，控制器（主要应用逻辑）解析该请求并决定采取什么操作❷。这可能涉及检查任何存储的安全凭证和其他数据（如购物车内容），并决定在收到请求后采取的适当行动。通常，控制器需要读取数据存储的内容，如数据库系统、文件存储，甚至是运行在另一个服务器上的API。这些数据就是MVC模式中的模型组件。如果收到的请求包含来自表单的数据，控制器可能需要更新或删除某些模型数据。
- en: Then the controller invokes the view component ❸, such as a template file, to
    create the contents of the response to be returned to the user. If appropriate,
    the controller passes along data collected from the model when it invokes the
    view component. Finally, the controller sends the response that it has created
    back to the web client (adding any appropriate headers, response codes, and the
    like) ❹.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，控制器调用视图组件❸，例如模板文件，以创建响应内容并返回给用户。如果需要，控制器在调用视图组件时会传递从模型中收集的数据。最后，控制器将其创建的响应返回给Web客户端（并添加任何适当的头信息、响应代码等）❹。
- en: We’ll revisit the MVC pattern throughout this book as we delve further into
    structuring PHP web applications. As mentioned, in [Chapter 13](chapter13.xhtml),
    we’ll look at how to create a front-controller script to manage the controller
    portion of the architecture. In [Chapter 21](chapter21.xhtml), we’ll introduce
    the Twig library, which simplifies templating for the view portion of the architecture.
    Finally, in [Part VI](part6.xhtml), starting with [Chapter 27](chapter27.xhtml),
    we’ll investigate how to integrate a PHP application with a database to handle
    the model portion of the architecture.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们将多次回顾MVC模式，并进一步探讨如何构建PHP Web应用程序。如前所述，在[第13章](chapter13.xhtml)中，我们将研究如何创建一个前端控制器脚本来管理架构中的控制器部分。在[第21章](chapter21.xhtml)中，我们将介绍Twig库，它简化了架构中视图部分的模板化。最后，在[第六部分](part6.xhtml)，从[第27章](chapter27.xhtml)开始，我们将探讨如何将PHP应用程序与数据库集成，以处理架构中的模型部分。
- en: Structuring a PHP Web Development Project
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP Web开发项目的结构
- en: As we discussed in [Chapter 1](chapter1.xhtml), the PHP engine comes with a
    built-in web server for testing purposes that you can run at the command line
    by using the php -S localhost:8000 command. By default, this command makes every
    file and folder that lives in the directory that the command line is currently
    pointing to publicly available through the web server. For example, if your command
    line was navigated to the root of your main hard disk (such as *C:\* on a Windows
    computer) and you executed the PHP web server command, you’d be making everything
    on the hard disk available to be requested! This probably isn’t a good idea from
    a security point of view.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](chapter1.xhtml)中讨论的那样，PHP引擎自带一个内置的Web服务器，供测试使用，你可以通过命令行使用php -S localhost:8000命令运行它。默认情况下，这个命令会使当前命令行所在目录中的所有文件和文件夹通过Web服务器公开。例如，如果你的命令行导航到了主硬盘的根目录（例如Windows计算机上的*C:\*），然后执行了PHP
    Web服务器命令，那么你就会将硬盘上的所有内容都暴露出来！从安全角度来看，这可能并不是一个好主意。
- en: Even within a specific PHP project folder, you may have files or other content
    that you wouldn’t want to publish publicly, such as code containing username and
    password credentials for data access or scripts that should be accessed only by
    authorized users. Therefore, it’s customary (and highly recommended) to create
    a *public* folder within the overall folder for any PHP web development project.
    This *public* folder (and its subfolders, if any) should contain only those files
    that are to be made publicly accessible via the web server, including any images,
    sound files, video files, CSS stylesheets, JavaScript text files, and the like
    that are needed for the website. Any PHP scripts that are to be executed in direct
    response to incoming HTTP requests from web clients should also be located in
    the *public* folder, while other content that shouldn’t be publicly accessible
    should be located elsewhere in the project’s directory structure.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是在特定的 PHP 项目文件夹内，你也可能有一些文件或内容不希望公开发布，例如包含用户名和密码凭证的代码，用于数据访问的脚本，或仅应由授权用户访问的脚本。因此，在进行
    PHP 网络开发项目时，通常（并强烈建议）在整个文件夹中创建一个*public*文件夹。该*public*文件夹（及其子文件夹，如果有的话）应只包含那些通过
    web 服务器公开访问的文件，包括任何图片、音频文件、视频文件、CSS 样式表、JavaScript 文本文件以及网站所需的其他内容。任何响应来自 web
    客户端的 HTTP 请求并需要执行的 PHP 脚本也应位于*public*文件夹中，而不应公开访问的其他内容应存放在项目目录结构中的其他位置。
- en: 'The usual way to organize a secure web application is to have just one PHP
    script named *index.php* in the project’s *public* folder. This script (the front
    controller we’ll discuss further in [Chapter 13](chapter13.xhtml)) then decides
    which other nonpublic scripts should be executed based on the properties of the
    incoming HTTP requests and other stored data. A typical PHP project folder therefore
    looks as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 组织一个安全的 web 应用程序的通常方法是，在项目的*public*文件夹中仅有一个名为*index.php*的 PHP 脚本。这个脚本（我们将在[第
    13 章](chapter13.xhtml)进一步讨论的前控制器）然后根据传入的 HTTP 请求和其他存储的数据，决定应该执行哪些其他非公开脚本。因此，一个典型的
    PHP 项目文件夹结构如下所示：
- en: '![](../images/pg191.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg191.jpg)'
- en: 'Generally, it’s best to do any command line work from the root folder of a
    project rather than from the *public* folder. Since this practice is so common,
    the built-in PHP web server offers the -t command line option for specifying a
    subfolder from which to serve web pages. With your command line interface navigated
    to the root project directory, you can therefore enter the following command to
    serve only files in the *public* folder via port 8000:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好从项目的根文件夹而非*public*文件夹中进行命令行操作。由于这种做法非常常见，内置的 PHP 网络服务器提供了 -t 命令行选项，用于指定从哪个子文件夹提供网页。因此，在命令行界面导航到根项目目录后，你可以输入以下命令，仅通过端口
    8000 提供*public*文件夹中的文件：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s test these two ways to run the built-in PHP web server: with and without
    the -t option. First, create a new empty folder named *[chapter 10](chapter10.xhtml)*,
    and in this folder create an *index.php* file containing the code shown in [Listing
    10-4](#lis10-4).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试这两种运行内置 PHP 网络服务器的方式：带和不带 -t 选项。首先，创建一个名为* [第 10 章](chapter10.xhtml)*的新空文件夹，并在该文件夹中创建一个名为*index.php*的文件，文件内容为[列表
    10-4](#lis10-4)中显示的代码。
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 10-4: A simple index.php file'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-4：一个简单的 index.php 文件
- en: 'This script contains only two PHP statements: within full PHP tags, we set
    the $total variable to the result of evaluating the mathematical expression 2
    + 2 ❶, and with the short echo tag we output the contents of this variable ❷.
    To make sure this script works, navigate your command line interface to the *chapter10*
    folder (use the cd command to change directories if you aren’t there already),
    and then run the built-in PHP web server at port 8000 without specifying a folder
    to serve:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本仅包含两条 PHP 语句：在完整的 PHP 标签内，我们将 $total 变量设置为评估数学表达式 2 + 2 ❶ 的结果，并使用简短的 echo
    标签输出该变量的内容 ❷。为了确保这个脚本能够正常工作，请将命令行界面导航到*chapter10*文件夹（如果你还没在该文件夹中，使用 cd 命令切换目录），然后运行内置
    PHP 网络服务器，在不指定文件夹的情况下通过端口 8000 提供服务：
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Open a web browser to *localhost:8000* and you should see a web page showing
    the result of the PHP output statement: total = 4.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 web 浏览器并访问*localhost:8000*，你应该能看到一个显示 PHP 输出语句结果的网页：total = 4。
- en: Now let’s see why publishing the entire contents of a project folder is a bad
    idea. In your *chapter10* folder, also create a text file called *password.txt*
    containing the text password=mysecret. Then visit *localhost:8000/password.txt*
    in your web browser to see that this text file is also publicly accessible from
    the web server, just like the *index.php* script (see [Figure 10-8](#fig10-8)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看为什么发布项目文件夹的全部内容是一个坏主意。在你的*chapter10*文件夹中，还创建一个名为*password.txt*的文本文件，内容是password=mysecret。然后在Web浏览器中访问*localhost:8000/password.txt*，你会发现这个文本文件也像*index.php*脚本一样可以公开访问（参见[图10-8](#fig10-8)）。
- en: '![](../images/figure10-8.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure10-8.jpg)'
- en: 'Figure 10-8: The web server publishing a secret password'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-8：Web服务器发布秘密密码
- en: 'Let’s make this file more secure by creating a subfolder named *public* and
    moving the *index.php* script into this subfolder, while keeping *password.tx*t
    in the main *chapter10* folder. Once you’ve made this change, press CTRL-C to
    kill the old web server process and then run the web server again, this time restricting
    it to only the content of the *public* subfolder:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个名为*public*的子文件夹，并将*index.php*脚本移动到这个子文件夹中，同时将*password.txt*保留在主*chapter10*文件夹中，从而让这个文件更加安全。一旦完成此更改，按CTRL-C终止旧的Web服务器进程，然后重新启动Web服务器，这次限制它只访问*public*子文件夹中的内容：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Try visiting both *localhost:8000* and *localhost:8000/password.txt* in your
    browser again. You should still be able to see the index page since it’s located
    in the *public* folder, but you should get a 404 error when you try to access
    the *password.txt* file since it isn’t in the *public* folder. We’ll follow this
    structure of using a *public* folder to isolate just the resources that should
    be publicly accessible throughout the book.  ### Summary'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试在浏览器中访问*localhost:8000*和*localhost:8000/password.txt*。你应该仍然能够看到首页，因为它位于*public*文件夹中，但当你尝试访问*password.txt*文件时，应该会收到404错误，因为它不在*public*文件夹中。我们将在本书中遵循使用*public*文件夹来隔离仅应公开访问的资源的结构。
- en: In this chapter, we explored concepts fundamental to PHP web development. We
    considered the HTTP messages that form the basis for web client/server communications
    and began to discuss the concept of routing, which is how web servers evaluate
    the content of the HTTP request’s path and decide what files to return or which
    server scripts to execute. We also looked at PHP as a templating language that
    enables us to mix dynamic PHP statements with unchanging template text. We saw
    a tidy way to mix PHP output with HTML template text using the short echo tag.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了PHP Web开发的基本概念。我们考虑了形成Web客户端/服务器通信基础的HTTP消息，并开始讨论路由的概念，即Web服务器如何评估HTTP请求路径的内容并决定返回哪些文件或执行哪些服务器脚本。我们还看到了PHP作为模板语言的应用，它使我们能够将动态的PHP语句与不变的模板文本混合。我们展示了一种使用短echo标签将PHP输出与HTML模板文本整洁地结合在一起的方法。
- en: We had our first look at the MVC architecture, a powerful way of dividing and
    organizing the tasks and data that drive a web application. Finally, we looked
    at the typical structure of a PHP web development project. In particular, we discussed
    the need for a *public* subfolder containing any resources that should be publicly
    accessible; any files or scripts that shouldn’t be publicly accessible must be
    located outside this subfolder.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首次了解了MVC架构，这是分割和组织驱动Web应用程序的任务和数据的一种强大方式。最后，我们查看了PHP Web开发项目的典型结构。特别地，我们讨论了需要一个包含所有应公开访问资源的*public*子文件夹的必要性；任何不应公开访问的文件或脚本必须位于此子文件夹之外。
- en: Exercises
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 1.   Open the developer tools for your web browser and visit a favorite website.
    Examine the headers of your HTTP GET request and the body of the HTTP response
    message that’s returned to the browser.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   打开Web浏览器的开发者工具并访问一个你喜欢的网站。检查你HTTP GET请求的头部以及返回给浏览器的HTTP响应消息的正文。
- en: 2.   With the developer tools for your web browser open, visit a web page that
    offers a form. Complete the form and, when you submit it, view the HTTP request
    body. You should see the name or value variables that were sent to the web server
    via the POST HTTP method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   打开Web浏览器的开发者工具，访问一个提供表单的网页。填写表单并提交时，查看HTTP请求体。你应该能够看到通过POST HTTP方法发送到Web服务器的名称或值变量。
- en: '3.   Write a “pure” PHP script, all in a single PHP block of code, to do the
    following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   编写一个“纯”PHP脚本，全部写在一个PHP代码块中，完成以下任务：
- en: a.   Define a PHP $pageTitle variable containing the string 'Home Page'.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: a.   定义一个PHP $pageTitle变量，包含字符串 'Home Page'。
- en: b.   Output <!doctype html><html><head><title>.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: b.   输出 <!doctype html><html><head><title>。
- en: c.   Output the value inside the $pageTitle variable.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: c.   输出$pageTitle变量中的值。
- en: d.   Output </title></head>.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: d.   输出</title></head>。
- en: 4.   Rewrite your answer for Exercise 3, using template text instead of PHP
    code where possible. Use complete code blocks with <?php and ?> tags for the PHP
    code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   重新编写第3题的答案，尽可能使用模板文本代替PHP代码。对于PHP代码，使用完整的代码块，包含<?php和?>标签。
- en: 5.   Rewrite your answer for Exercise 4 to use the short echo tag to output
    the value inside the $pageTitle variable.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   重新编写第4题的答案，使用短回显标签输出$pageTitle变量中的值。
