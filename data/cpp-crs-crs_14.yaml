- en: '**11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11**'
- en: SMART POINTERS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针**
- en: '*If you want to do a few small things right, do them yourself. If you want
    to do great things and make a big impact, learn to delegate.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想做好一些小事，就自己做。如果你想做伟大的事情并产生巨大影响，就学会委派。  '
- en: —John C. Maxwell*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —约翰·C·麦克斯韦尔*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In this chapter, you’ll explore stdlib and Boost libraries. These libraries
    contain a collection of smart pointers, which manage dynamic objects with the
    RAII paradigm you learned in [Chapter 4](ch04.xhtml#ch04). They also facilitate
    the most powerful resource management model in any programming language. Because
    some smart pointers use *allocators* to customize dynamic memory allocation, the
    chapter also outlines how to provide a user-defined allocator.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将探索 stdlib 和 Boost 库。这些库包含了一组智能指针，它们使用你在[第4章](ch04.xhtml#ch04)中学到的 RAII
    范式来管理动态对象。它们还促进了任何编程语言中最强大的资源管理模型。由于一些智能指针使用*分配器*来定制动态内存分配，本章还概述了如何提供用户定义的分配器。
- en: '**Smart Pointers**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**智能指针**'
- en: Dynamic objects have the most flexible lifetimes. With great flexibility comes
    great responsibility, so you must make sure each dynamic object gets destructed
    *exactly* once. This might not look daunting with small programs, but looks can
    be deceiving. Just consider how exceptions factor into dynamic memory management.
    Each time an error or an exception could occur, you need to keep track of which
    allocations you’ve made successfully and be sure to release them in the correct
    order.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 动态对象具有最灵活的生命周期。灵活性带来了巨大的责任，因此你必须确保每个动态对象只会被析构*一次*。在小型程序中，这看起来可能不太可怕，但外表常常是欺骗性的。想想异常如何影响动态内存管理吧。每次出现错误或异常时，你都需要追踪已成功分配的内存，并确保按照正确的顺序释放它们。
- en: Fortunately, you can use RAII to handle such tedium. By acquiring dynamic storage
    in the constructor of the RAII object and releasing dynamic storage in the destructor,
    it’s relatively difficult to leak (or double free) dynamic memory. This enables
    you to manage dynamic object lifetimes using move and copy semantics.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以使用 RAII 来处理这种繁琐的事情。通过在 RAII 对象的构造函数中获取动态存储，在析构函数中释放动态存储，泄漏（或双重释放）动态内存变得相对困难。这使得你能够通过移动和拷贝语义来管理动态对象的生命周期。
- en: You could write these RAII objects yourself, but you can also use some excellent
    prewritten implementations called *smart pointers*. Smart pointers are class templates
    that behave like pointers and implement RAII for dynamic objects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己编写这些 RAII 对象，但你也可以使用一些优秀的预先编写好的实现，称为*智能指针*。智能指针是行为类似指针并实现 RAII 的类模板，用于动态对象。
- en: 'This section delves into five available options included in stdlib and Boost:
    scoped, unique, shared, weak, and intrusive pointers. Their ownership models differentiate
    these five smart pointer categories.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节深入探讨了 stdlib 和 Boost 中提供的五种选项：作用域指针、唯一指针、共享指针、弱指针和侵入式指针。它们的所有权模型区分了这五种智能指针类别。
- en: '**Smart Pointer Ownership**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**智能指针所有权**'
- en: Every smart pointer has an *ownership* model that specifies its relationship
    with a dynamically allocated object. When a smart pointer owns an object, the
    smart pointer’s lifetime is guaranteed to be at least as long as the object’s.
    Put another way, when you use a smart pointer, you can rest assured that the pointed-to
    object is alive and that the pointed-to object won’t leak. The smart pointer manages
    the object it owns, so you can’t forget to destroy it thanks to RAII.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个智能指针都有一个*所有权*模型，指定它与动态分配对象的关系。当智能指针拥有一个对象时，智能指针的生命周期保证至少与该对象的生命周期一样长。换句话说，当你使用智能指针时，你可以放心地知道被指向的对象是活的，并且不会泄漏。智能指针管理它所拥有的对象，因此你不会忘记销毁它，因为
    RAII 已经为你处理了。
- en: When considering which smart pointer to use, your ownership requirements drive
    your choice.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择使用哪种智能指针时，你的所有权需求决定了你的选择。
- en: '**Scoped Pointers**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**作用域指针**'
- en: A *scoped pointer* expresses *non-transferable*, *exclusive ownership* over
    a single dynamic object. Non-transferable means that the scoped pointers cannot
    be moved from one scope to another. Exclusive ownership means that they can’t
    be copied, so no other smart pointers can have ownership of a scoped pointer’s
    dynamic object. (Recall from “Memory Management” on [page 90](ch04.xhtml#page_90)
    that an object’s scope is where it’s visible to the program.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*作用域指针*表示对单个动态对象的*不可转移*、*独占拥有权*。不可转移意味着作用域指针不能从一个作用域转移到另一个作用域。独占拥有权意味着它们不能被复制，因此没有其他智能指针可以拥有作用域指针的动态对象。（回想一下在《内存管理》章节中提到的，关于对象的作用域，它是对象在程序中的可见范围，见[第
    90 页](ch04.xhtml#page_90)）。'
- en: The `boost::scoped_ptr` is defined in the `<boost/smart_ptr/scoped_ptr.hpp>`
    header.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::scoped_ptr` 在 `<boost/smart_ptr/scoped_ptr.hpp>` 头文件中定义。'
- en: '**NOTE**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There is no stdlib scoped pointer.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*没有标准库作用域指针。*'
- en: '***Constructing***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构造***'
- en: The `boost::scoped_ptr` takes a single template parameter corresponding to the
    pointed-to type, as in `boost::scoped_ptr<int>` for a “scoped pointer to `int`”
    type.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::scoped_ptr` 接受一个模板参数，该参数对应于被指向的类型，例如 `boost::scoped_ptr<int>` 表示“指向
    `int` 的作用域指针”类型。'
- en: 'All smart pointers, including scoped pointers, have two modes: *empty* and
    *full*. An empty smart pointer owns no object and is roughly analogous to a `nullptr`.
    When a smart pointer is default constructed, it begins life empty.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有智能指针，包括作用域指针，都有两种模式：*空* 和 *满*。空智能指针不拥有任何对象，类似于 `nullptr`。当智能指针被默认构造时，它开始时是空的。
- en: 'The scoped pointer provides a constructor taking a raw pointer. (The pointed-to
    type must match the template parameter.) This creates a full-scoped pointer. The
    usual idiom is to create a dynamic object with `new` and pass the result to the
    constructor, like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域指针提供了一个构造函数，接受一个原始指针。（被指向的类型必须与模板参数匹配。）这将创建一个满作用域指针。通常的惯用法是使用 `new` 创建一个动态对象并将结果传递给构造函数，如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This line dynamically allocates a `PointedToType` and passes its pointer to
    the scoped pointer constructor.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行动态分配了一个 `PointedToType`，并将其指针传递给作用域指针构造函数。
- en: '***Bring in the Oath Breakers***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***引入誓言破坏者***'
- en: To explore scoped pointers, let’s create a Catch unit-test suite and a `DeadMenOfDunharrow`
    class that keeps track of how many objects are alive, as shown in [Listing 11-1](ch11.xhtml#ch11ex01).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索作用域指针，让我们创建一个 Catch 单元测试套件和一个 `DeadMenOfDunharrow` 类，用于跟踪有多少对象仍然存活，如[示例
    11-1](ch11.xhtml#ch11ex01)所示。
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 11-1: Setting up a Catch unit-test suite with a `DeadMenOfDunharrow`
    class to investigate scoped pointers*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-1：设置一个带有 `DeadMenOfDunharrow` 类的 Catch 单元测试套件，用于研究作用域指针*'
- en: First, you declare `CATCH_CONFIG_MAIN` so Catch will provide an entry point
    ➊ and include the Catch header ➋ and then the Boost scoped pointer’s header ➌.
    Next, you declare the `DeadMenOfDunharrow` class ➍,which takes an optional null-terminated
    string that you save into the `message` field ➎. The `static int` field called
    `oaths_to_fulfill` tracks how many `DeadMenOfDunharrow` objects have been constructed.
    Accordingly, you increment in the constructor ➏, and you decrement in the destructor
    ➐. Finally, you declare the `ScopedOathbreakers` type alias for convenience ➑.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你声明 `CATCH_CONFIG_MAIN`，这样 Catch 会提供一个入口点 ➊，并包含 Catch 头文件 ➋，然后是 Boost 作用域指针的头文件
    ➌。接下来，你声明 `DeadMenOfDunharrow` 类 ➍，它接受一个可选的空终止字符串并将其保存到 `message` 字段 ➎。一个名为 `oaths_to_fulfill`
    的 `static int` 字段用于跟踪已经构造的 `DeadMenOfDunharrow` 对象的数量。因此，你在构造函数中递增 ➏，在析构函数中递减
    ➐。最后，你声明 `ScopedOathbreakers` 类型别名以便于使用 ➑。
- en: '**CATCH LISTINGS**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**CATCH 示例**'
- en: 'You’ll use Catch unit tests in most listings from now on. For conciseness,
    the listings omit the following Catch ceremony:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，你将在大多数示例中使用 Catch 单元测试。为了简洁起见，示例省略了以下 Catch 流程：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All listings containing `TEST_CASE` require this preamble.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有包含 `TEST_CASE` 的示例都需要这个前言。
- en: Also, every test case in each listing passes unless a comment indicates otherwise.
    Again, for conciseness, the listings omit the All tests pass output from the listings.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个示例中的所有测试用例都通过，除非有注释指示相反。为了简洁起见，示例省略了“所有测试通过”这一输出。
- en: Finally, tests that employ user-defined types, functions, and variables from
    a previous listing will omit them for brevity.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用先前示例中的自定义类型、函数和变量的测试将省略它们，以简化代码。
- en: '***Implicit bool Conversion Based on Ownership***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基于所有权的隐式布尔转换***'
- en: 'Sometimes you need to determine whether a scoped pointer owns an object or
    whether it’s empty. Conveniently, `scoped_ptr` casts implicitly to `bool` depending
    on its ownership status: `true` if it owns an object; `false` otherwise. [Listing
    11-2](ch11.xhtml#ch11ex02) illustrates how this implicit casting behavior works.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要判断一个 `scoped_ptr` 是否拥有一个对象，或者它是否为空。方便的是，`scoped_ptr` 会根据其所有权状态隐式转换为 `bool`：如果它拥有一个对象则为
    `true`，否则为 `false`。[清单 11-2](ch11.xhtml#ch11ex02) 展示了这种隐式转换行为是如何工作的。
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 11-2: The boost::scoped_ptr casts implicitly to `bool`.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-2：boost::scoped_ptr 隐式转换为 `bool`。*'
- en: When you use the constructor taking a pointer ➊, the `scoped_ptr` converts to
    `true` ➋. When you use the default constructor ➌, the `scoped_ptr` converts to
    `false➍`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用带指针的构造函数 ➊ 时，`scoped_ptr` 会转换为 `true` ➋。当你使用默认构造函数 ➌ 时，`scoped_ptr` 会转换为
    `false` ➍。
- en: '***RAII Wrapper***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***RAII 包装器***'
- en: When a `scoped_ptr` owns a dynamic object, it ensures proper dynamic object
    management. In the `scoped_ptr` destructor, it checks whether it owns an object.
    If it does, the `scoped_ptr` destructor deletes the dynamic object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当`scoped_ptr`拥有一个动态对象时，它确保正确的动态对象管理。在`scoped_ptr`的析构函数中，它会检查是否拥有一个对象。如果拥有，`scoped_ptr`的析构函数会删除该动态对象。
- en: '[Listing 11-3](ch11.xhtml#ch11ex03) illustrates this behavior by investigating
    the static `oaths_to_fulfill` variable between scoped pointer initializations.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-3](ch11.xhtml#ch11ex03) 通过在 `scoped_ptr` 初始化之间检查静态变量 `oaths_to_fulfill`，展示了这种行为。'
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 11-3: The `boost::scoped_ptr` is an RAII wrapper.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-3：`boost::scoped_ptr` 是一个 RAII 包装器。*'
- en: At the beginning of the test, `oaths_to_fulfill` is 0 because you haven’t constructed
    any `DeadMenOfDunharrow` yet ➊. You construct the scoped pointer `aragorn` and
    pass in a pointer to the dynamic `DeadMenOfDunharrow` object ➋. This increments
    the `oaths_to_fulfill` to 1 ➌. Within a nested scope, you declare another scoped
    pointer `legolas` ➍. Because `aragorn` is still alive, `oaths_to_fulfill` is now
    2 ➎. Once the inner scope closes, `legolas` falls out of scope and destructs,
    taking a `DeadMenOfDunharrow` with it ➏. This decrements `DeadMenOfDunharrow`
    to 1 ➐.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试开始时，`oaths_to_fulfill` 为 0，因为你还没有构造任何 `DeadMenOfDunharrow` 对象 ➊。你构造了 `scoped_ptr`
    `aragorn` 并传入指向动态 `DeadMenOfDunharrow` 对象的指针 ➋。这使得 `oaths_to_fulfill` 增加到 1 ➌。接着在一个嵌套作用域中，你声明了另一个
    `scoped_ptr` `legolas` ➍。由于 `aragorn` 仍然存在，`oaths_to_fulfill` 此时为 2 ➎。等到内层作用域结束，`legolas`
    超出作用域并析构，带走了一个 `DeadMenOfDunharrow` ➏。这使得 `DeadMenOfDunharrow` 减少到 1 ➐。
- en: '***Pointer Semantics***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***指针语义***'
- en: For convenience, `scoped_ptr` implements the dereference `operator*` and the
    member dereference `operator->`, which simply delegate the calls to the owned
    dynamic object. You can even extract a raw pointer from a `scoped_ptr` with the
    `get` method, as demonstrated in [Listing 11-4](ch11.xhtml#ch11ex04).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，`scoped_ptr` 实现了解引用运算符 `operator*` 和成员解引用运算符 `operator->`，这些运算符仅仅将调用委托给被拥有的动态对象。你甚至可以通过
    `get` 方法从 `scoped_ptr` 中提取出原始指针，正如 [清单 11-4](ch11.xhtml#ch11ex04) 所演示的那样。
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 11-4: The boost::scoped_ptr supports pointer semantics.*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-4：boost::scoped_ptr 支持指针语义。*'
- en: You construct the scoped pointer `aragorn` with a `message` of `The way is`
    `shut` ➊, which you use in three separate scenarios to test pointer semantics.
    First, you can use `operator*` to dereference the underlying, pointed-to dynamic
    object. In the example, you dereference `aragorn` and extract the `message` to
    verify that it matches ➋. You can also use `operator->` to perform member dereference
    ➌. Finally, if you want a raw pointer to the dynamic object, you can use the `get`
    method to extract it ➍.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造了 `scoped_ptr` `aragorn` 并将 `message` 设置为 `The way is` `shut` ➊，你在三个不同的场景中测试指针语义。首先，你可以使用
    `operator*` 来解引用底层指向的动态对象。在这个例子中，你解引用 `aragorn` 并提取 `message` 来验证它是否匹配 ➋。你也可以使用
    `operator->` 来执行成员解引用 ➌。最后，如果你想获取指向动态对象的原始指针，可以使用 `get` 方法来提取它 ➍。
- en: '***Comparison with nullptr***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***与 nullptr 的比较***'
- en: The `scoped_ptr` class template implements the comparison operators `operator==`
    and `operator!=`, which are only defined when comparing a `scoped_ptr` with a
    `nullptr`. Functionally, this is essentially identical to implicit `bool` conversion,
    as [Listing 11-5](ch11.xhtml#ch11ex05) illustrates.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoped_ptr` 类模板实现了比较运算符 `operator==` 和 `operator!=`，这些运算符仅在比较 `scoped_ptr`
    与 `nullptr` 时才有定义。从功能上讲，这与隐式的 `bool` 转换基本相同，正如 [清单 11-5](ch11.xhtml#ch11ex05)
    所展示的那样。'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 11-5: The `boost::scoped_ptr` supports comparison with `nullptr`.*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-5：`boost::scoped_ptr` 支持与 `nullptr` 的比较。*'
- en: An empty scoped pointer equals (`==`) `nullptr` ➊, whereas a full scoped pointer
    doesn’t equal (`!=`) `nullptr` ➋.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 空的 scoped 指针等于（`==`） `nullptr` ➊，而非空的 scoped 指针不等于（`!=`） `nullptr` ➋。
- en: '***Swapping***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***交换***'
- en: Sometimes you want to switch the dynamic object owned by a `scoped_ptr` with
    the dynamic object owned by another `scoped_ptr`. This is called an *object swap*,
    and `scoped_ptr` contains a `swap` method that implements this behavior, as shown
    in [Listing 11-6.](ch11.xhtml#ch11ex06)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你希望交换一个 `scoped_ptr` 所拥有的动态对象与另一个 `scoped_ptr` 所拥有的动态对象。这被称为 *对象交换*，`scoped_ptr`
    包含一个 `swap` 方法来实现这一行为，如 [清单 11-6](ch11.xhtml#ch11ex06) 所示。
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 11-6: The boost::scoped_ptr supports `swap`.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-6：boost::scoped_ptr 支持 `swap`。*'
- en: You construct two `scoped_ptr` objects, `aragorn` ➊ and `legolas` ➋, each with
    a different message. After you perform a swap between `aragorn` and `legolas`
    ➌, they exchange dynamic objects. When you pull out their messages after the swap,
    you find that they’ve switched ➍ ➎.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造了两个 `scoped_ptr` 对象，`aragorn` ➊ 和 `legolas` ➋，每个对象都有不同的消息。在你执行 `aragorn`
    和 `legolas` 之间的交换 ➌ 后，它们交换了动态对象。当你交换后获取它们的消息时，你会发现它们已经交换了 ➍ ➎。
- en: '***Resetting and Replacing a scoped_ptr***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重置与替换 scoped_ptr***'
- en: Rarely do you want to destruct an object owned by `scoped_ptr` before the `scoped_ptr`
    dies. For example, you might want to replace its owned object with a new dynamic
    object. You can handle both of these tasks with the overloaded `reset` method
    of `scoped_ptr`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常不希望在 `scoped_ptr` 对象销毁之前析构它所拥有的对象。例如，你可能希望用一个新的动态对象替换它所拥有的对象。你可以使用 `scoped_ptr`
    的重载 `reset` 方法来处理这两项任务。
- en: If you provide no argument, `reset` simply destroys the owned object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不提供任何参数，`reset` 只会销毁所拥有的对象。
- en: If you instead provide a new dynamic object as a parameter, `reset` will first
    destroy the currently owned object and then gain ownership of the parameter. [Listing
    11-7](ch11.xhtml#ch11ex07) illustrates such behavior with one test for each scenario.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提供一个新的动态对象作为参数，`reset` 将首先销毁当前拥有的对象，然后获取该参数的所有权。[清单 11-7](ch11.xhtml#ch11ex07)
    通过为每种情况提供一个测试，展示了这种行为。
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 11-7: The boost::scoped_ptr supports `reset`.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-7：boost::scoped_ptr 支持 `reset`。*'
- en: The first step in both tests is to construct the scoped pointer `aragorn` owning
    a `DeadMenOfDunharrow` ➊. In the first test, you call `reset` without an argument
    ➋. This causes the scoped pointer to destruct its owned object, and `oaths_to_fulfill`
    decrements to 0 ➌.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 两个测试的第一步都是构造一个 `scoped_ptr` 指针 `aragorn`，它拥有一个 `DeadMenOfDunharrow` ➊。在第一个测试中，你不带参数地调用
    `reset` ➋。这会导致 `scoped_ptr` 析构它所拥有的对象，`oaths_to_fulfill` 减少到 0 ➌。
- en: 'In the second test, you create the new, dynamically allocated `new_dead_men`
    with a custom `message` ➍. This increases the `oaths_to_fill` to 2, because `ara``gorn`
    is also still alive ➎. Next, you invoke `reset` with `new_dead_men` as the argument
    ➏, which does two things:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个测试中，你创建了新的、动态分配的 `new_dead_men`，并附加了自定义的 `message` ➍。这将使 `oaths_to_fill`
    增加到 2，因为 `aragorn` 依然存活 ➎。接下来，你调用 `reset`，并以 `new_dead_men` 作为参数 ➏，这会做两件事：
- en: It causes the original `DeadMenOfDunharrow` owned by `aragorn` to get destructed,
    which decrements `oaths_to_fulfill` to 1 ➐.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它导致原本由 `aragorn` 所拥有的 `DeadMenOfDunharrow` 被析构，这使得 `oaths_to_fulfill` 减少到 1
    ➐。
- en: It emplaces `new_dead_men` as the dynamically allocated object owned by `aragorn`.
    When you dereference the `message` field, notice that it matches the `message`
    held by `new_dead_men` ➑. (Equivalently, `aragorn.get()` yields `new_dead_men`
    ➒.)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将 `new_dead_men` 作为由 `aragorn` 所拥有的动态分配对象。当你解引用 `message` 字段时，会发现它与 `new_dead_men`
    所持有的 `message` 匹配 ➑。（等效地，`aragorn.get()` 返回 `new_dead_men` ➒。）
- en: '***Non-transferability***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***不可转移性***'
- en: You cannot move or copy a `scoped_ptr`, making it non-transferable. [Listing
    11-8](ch11.xhtml#ch11ex08) illustrates how attempting to move or copy a `scoped_ptr`
    results in an invalid program.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能移动或复制 `scoped_ptr`，使其成为不可转移的。[清单 11-8](ch11.xhtml#ch11ex08) 展示了尝试移动或复制 `scoped_ptr`
    会导致无效程序。
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 11-8: The `boost::scoped_ptr` is non-transferable. (This code doesn’t
    compile.)*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-8：`boost::scoped_ptr` 是不可转移的。（此代码无法编译。）*'
- en: First, you declare dummy functions that take a `scoped_ptr` by reference ➊ and
    by value ➋. You can still pass a `scoped_ptr` by reference ➌, but attempting to
    pass one by value will fail to compile ➍. Also, attempting to use the `scoped_ptr`
    copy constructor or a copy assignment operator ➎ will fail to compile. In addition,
    if you try to move a `scoped_ptr` with `std::move`, your code won’t compile ➏➐.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你声明接受`scoped_ptr`引用 ➊ 和值 ➋ 的虚拟函数。你仍然可以通过引用 ➌ 传递`scoped_ptr`，但是尝试通过值传递将无法编译
    ➍。此外，尝试使用`scoped_ptr`的复制构造函数或复制赋值操作符 ➎ 也将无法编译。如果你尝试使用`std::move`移动一个`scoped_ptr`，你的代码也将无法编译
    ➏➐。
- en: '**NOTE**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Generally, using a boost::scoped_ptr incurs no overhead compared with using
    a raw pointer.*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*通常，使用`boost::scoped_ptr`不会比使用原始指针产生额外的开销。*'
- en: '***boost::scoped_array***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***boost::scoped_array***'
- en: The `boost::scoped_array` is a scoped pointer for dynamic arrays. It supports
    the same usages as a `boost::scoped_ptr`, but it also implements an `operator[]`
    so you can interact with elements of the scoped array in the same way as you can
    with a raw array. [Listing 11-9](ch11.xhtml#ch11ex09) illustrates this additional
    feature.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::scoped_array`是一个用于动态数组的作用域指针。它支持与`boost::scoped_ptr`相同的用法，但它还实现了`operator[]`，因此你可以像操作原始数组一样与作用域数组的元素进行交互。[清单
    11-9](ch11.xhtml#ch11ex09)说明了这一附加功能。'
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 11-9: The `boost::scoped_array` implements `operator[]`.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-9：`boost::scoped_array`实现了`operator[]`。*'
- en: You declare a `scoped_array` the same way you declare a `scoped_ptr`, by using
    a single template parameter ➊. In the case of `scoped_array`, the template parameter
    is the type contained by the array ➋, not the type of the array. You pass in a
    dynamic array to the constructor of `squares`, making the dynamic array `squares`
    the array’s owner. You can use `operator[]` to write ➌ and read ➍ elements.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明`scoped_array`的方式与声明`scoped_ptr`相同，使用单一的模板参数 ➊。对于`scoped_array`，模板参数是数组中包含的类型
    ➋，而不是数组的类型。你将一个动态数组传递给`squares`的构造函数，使得动态数组`squares`成为该数组的所有者。你可以使用`operator[]`来写入
    ➌ 和读取 ➍ 元素。
- en: '***A Partial List of Supported Operations***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***支持的部分操作列表***'
- en: So far, you’ve learned about the major features of scoped pointers. For reference,
    [Table 11-1](ch11.xhtml#ch11tab01) enumerates all the operators discussed, plus
    a few that haven’t been covered yet. In the table, `ptr` is a raw pointer and
    `s_ptr` is a scoped pointer. See the Boost documentation for more information.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了作用域指针的主要特性。作为参考，[表 11-1](ch11.xhtml#ch11tab01)列出了所有已讨论的运算符，以及一些尚未覆盖的运算符。在表格中，`ptr`是一个原始指针，而`s_ptr`是一个作用域指针。有关更多信息，请参阅Boost文档。
- en: '**Table 11-1:** All of the Supported `boost::scoped_ptr` Operations'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 11-1：** 所有支持的`boost::scoped_ptr`操作'
- en: '| **Operation** | **Notes** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **说明** |'
- en: '| `scoped_ptr<...>{ }` or `scoped_ptr <...>{ nullptr }` | Creates an empty
    scoped pointer. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `scoped_ptr<...>{ }` 或 `scoped_ptr <...>{ nullptr }` | 创建一个空的作用域指针。 |'
- en: '| `scoped_ptr <...>{` ptr `}` | Creates a scoped pointer owning the dynamic
    object pointed to by ptr. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `scoped_ptr <...>{` ptr `}` | 创建一个作用域指针，拥有由ptr指向的动态对象。 |'
- en: '| `~scoped_ptr<...>()` | Calls `delete` on the owned object if full. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `~scoped_ptr<...>()` | 如果已满，则对拥有的对象调用`delete`。 |'
- en: '| s_ptr1`.swap(`s_ptr2`)` | Exchanges owned objects between s_ptr1 and s_ptr2.
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| s_ptr1`.swap(`s_ptr2`)` | 交换s_ptr1和s_ptr2之间的拥有对象。 |'
- en: '| `swap(`s_ptr1, s_ptr2`)` | A free function identical to the `swap` method.
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `swap(`s_ptr1, s_ptr2`)` | 与`swap`方法相同的自由函数。 |'
- en: '| s_ptr`.reset()` | If full, calls `delete` on object owned by s_ptr. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| s_ptr`.reset()` | 如果已满，则对`s_ptr`拥有的对象调用`delete`。 |'
- en: '| s_ptr`.reset(`ptr`)` | Deletes currently owned object and then takes ownership
    of ptr. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| s_ptr`.reset(`ptr`)` | 删除当前拥有的对象，然后获取ptr的所有权。 |'
- en: '| ptr `=` s_ptr`.get()` | Returns the raw pointer `ptr`; `s_ptr` retains ownership.
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| ptr `=` s_ptr`.get()` | 返回原始指针`ptr`；`s_ptr`保持所有权。 |'
- en: '| `*`s_ptr | Dereferences operator on owned object. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `*`s_ptr | 对拥有对象的解引用操作符。 |'
- en: '| s_ptr`->` | Member dereferences operator on owned object. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| s_ptr`->` | 对拥有对象的成员解引用操作符。 |'
- en: '| `bool{` s_ptr `}` | `bool` conversion: `true` if full, `false` if empty.
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `bool{` s_ptr `}` | `bool`转换：如果已满则为`true`，如果为空则为`false`。 |'
- en: '**Unique Pointers**'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**唯一指针**'
- en: A *unique pointer* has transferable, exclusive ownership over a single dynamic
    object. You *can* move unique pointers, which makes them transferable. They also
    have exclusive ownership, so they *cannot* be copied. The stdlib has a `unique_ptr`
    available in the `<memory>` header.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*唯一指针*对单一动态对象拥有可转移的独占所有权。你*可以*移动唯一指针，这使得它们具有可转移性。它们也拥有独占所有权，因此*不能*被复制。标准库提供了一个在`<memory>`头文件中的`unique_ptr`。
- en: '**NOTE**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost doesn’t offer a unique pointer.*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost并不提供独占指针。*'
- en: '***Constructing***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构造***'
- en: The `std::unique_ptr` takes a single template parameter corresponding to the
    pointed-to type, as in `std::unique_ptr<int>` for a “unique pointer to `int`”
    type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_ptr`接受一个模板参数，对应于所指向的类型，例如`std::unique_ptr<int>`表示“指向`int`类型的独占指针”。'
- en: 'As with a scoped pointer, the unique pointer has a default constructor that
    initializes the unique pointer to empty. It also provides a constructor taking
    a raw pointer that takes ownership of the pointed-to dynamic object. One construction
    method is to create a dynamic object with `new` and pass the result to the constructor,
    like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与作用域指针类似，独占指针具有一个默认构造函数，将独占指针初始化为空。它还提供一个接受原始指针的构造函数，该构造函数获取所指向的动态对象的所有权。一个构造方法是使用`new`创建一个动态对象，并将结果传递给构造函数，像这样：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Another method is to use the `std::make_unique` function. The `make_unique`
    function is a template that takes all the arguments and forwards them to the appropriate
    constructor of the template parameter. This obviates the need for `new`. Using
    `std::make_unique`, you could rewrite the preceding object initialization as:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`std::make_unique`函数。`make_unique`是一个模板函数，它接受所有参数并将它们转发到模板参数的适当构造函数中。这避免了使用`new`的需要。通过使用`std::make_unique`，你可以将前面的对象初始化重写为：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `make_unique` function was created to avoid some devilishly subtle memory
    leaks that used to occur when you used `new` with previous versions of C++. However,
    in the latest version of C++, these memory leaks no longer occur. Which constructor
    you use mainly depends on your preference.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_unique`函数是为了避免在使用C++旧版本的`new`时出现一些微妙的内存泄漏问题而创建的。然而，在C++的最新版本中，这些内存泄漏问题已经不再发生。你选择使用哪种构造函数主要取决于你的偏好。'
- en: '***Supported Operations***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***支持的操作***'
- en: 'The `std::unique_ptr` function supports every operation that `boost::scoped_ptr`
    supports. For example, you can use the following type alias as a drop-in replacement
    for `ScopedOathbreakers` in [Listings 11-1](ch11.xhtml#ch11ex01) to [11-7](ch11.xhtml#ch11ex07):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_ptr`函数支持`boost::scoped_ptr`支持的所有操作。例如，你可以使用以下类型别名作为[清单 11-1](ch11.xhtml#ch11ex01)到[11-7](ch11.xhtml#ch11ex07)中的`ScopedOathbreakers`的替代：'
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: One of the major differences between unique and scoped pointers is that you
    can move unique pointers because they’re *transferable*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 独占指针和作用域指针的主要区别之一是，你可以移动独占指针，因为它们是*可转移的*。
- en: '***Transferable, Exclusive Ownership***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可转移的、独占的所有权***'
- en: Not only are unique pointers transferable, but they have exclusive ownership
    (you *cannot* copy them). [Listing 11-10](ch11.xhtml#ch11ex10) illustrates how
    you can use the move semantics of `unique_ptr`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅独占指针是可转移的，而且它们具有独占所有权（你*不能*复制它们）。[清单 11-10](ch11.xhtml#ch11ex10)演示了如何使用`unique_ptr`的移动语义。
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 11-10: The `std::unique_ptr` supports move semantics for transferring
    ownership.*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-10：`std::unique_ptr`支持用于转移所有权的移动语义。*'
- en: This listing creates a `unique_ptr` called `aragorn` ➊ that you use in two separate
    tests.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单创建了一个名为`aragorn`的`unique_ptr` ➊，你将在两个不同的测试中使用它。
- en: In the first test, you move `aragorn` with `std::move` into the move constructor
    of `son_of_arathorn` ➋. Because `aragorn` transfers ownership of its `DeadMenOfDunharrow`
    to `son_of_arathorn`, the `oaths_to_fulfill` object still only has value 1 ➌.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次测试中，你将`aragorn`通过`std::move`移动到`son_of_arathorn`的移动构造函数中 ➋。因为`aragorn`将其`DeadMenOfDunharrow`的所有权转移给了`son_of_arathorn`，所以`oaths_to_fulfill`对象的值仍然是1
    ➌。
- en: The second test constructs `son_of_arathorn` via `make_unique` ➍, which pushes
    the `oaths_to_fulfill` to 2 ➎. Next, you use the move assignment operator to move
    `aragorn` into `son_of_arathorn` ➏. Again, `aragorn` transfers ownership to `son_of_aragorn`.
    Because `son_of_aragorn` can own only one dynamic object at a time, the move assignment
    operator destroys the currently owned object before emptying the dynamic object
    of `aragorn`. This results in `oaths_to_fulfill` decrementing to 1 ➐.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次测试通过`make_unique`构造`son_of_arathorn` ➍，这将`oaths_to_fulfill`的值推至2 ➎。接下来，你使用移动赋值操作符将`aragorn`移入`son_of_arathorn`
    ➏。同样，`aragorn`将所有权转移给`son_of_aragorn`。由于`son_of_aragorn`一次只能拥有一个动态对象，因此移动赋值操作符会销毁当前拥有的对象，然后清空`aragorn`的动态对象。这导致`oaths_to_fulfill`的值减小至1
    ➐。
- en: '***Unique Arrays***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***独占数组***'
- en: Unlike `boost::scoped_ptr`, `std::unique_ptr` has built-in dynamic array support.
    You just use the array type as the template parameter in the unique pointer’s
    type, as in `std::unique_ptr<int[]>`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与`boost::scoped_ptr`不同，`std::unique_ptr`内置了对动态数组的支持。你只需将数组类型作为模板参数，像这样使用独占指针的类型：`std::unique_ptr<int[]>`。
- en: It’s *very important* that you don’t initialize a `std::unique_ptr<T>` with
    a dynamic array `T[]`. Doing so will cause undefined behavior, because you’ll
    be causing a `delete` of an array (rather than `delete[]`). The compiler cannot
    save you, because `operator new[]` returns a pointer that is indistinguishable
    from the kind returned by `operator new`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*非常重要*的是，你不要使用动态数组 `T[]` 来初始化 `std::unique_ptr<T>`。这样做会导致未定义的行为，因为你会导致对数组执行
    `delete`（而不是 `delete[]`）。编译器无法拯救你，因为 `operator new[]` 返回的指针与 `operator new` 返回的指针是无法区分的。'
- en: Like `scoped_array`, a `unique_ptr` to array type offers `operator[]` for accessing
    elements. [Listing 11-11](ch11.xhtml#ch11ex11) demonstrates this concept.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 和 `scoped_array` 类似，`unique_ptr` 到数组类型提供了 `operator[]` 来访问元素。[清单 11-11](ch11.xhtml#ch11ex11)
    演示了这一概念。
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 11-11: The `std::unique_ptr` to an array type supports `operator[]`.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-11：`std::unique_ptr` 到数组类型支持 `operator[]`。*'
- en: The template parameter `int[]` ➊ indicates to `std::unique_ptr` that it owns
    a dynamic array. You pass in a newly minted dynamic array ➋ and then use `operator[]`
    to set the first element ➌; then you use `operator[]` to retrieve elements ➍.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数 `int[]` ➊ 指示 `std::unique_ptr` 拥有一个动态数组。你传入一个新创建的动态数组 ➋，然后使用 `operator[]`
    来设置第一个元素 ➌；接着你使用 `operator[]` 来检索元素 ➍。
- en: '***Deleters***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***删除器***'
- en: The `std::unique_ptr` has a second, optional template parameter called its deleter
    type. A unique pointer’s *deleter* is what gets called when the unique pointer
    needs to destroy its owned object.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_ptr` 有第二个可选模板参数，称为删除器类型。unique pointer 的 *删除器* 是在 unique pointer
    需要销毁其拥有的对象时调用的内容。'
- en: 'A `unique_ptr` instantiation contains the following template parameters:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr` 实例化包含以下模板参数：'
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The two template parameters are `T`, the type of the owned dynamic object, and
    `Deleter`, the type of the object responsible for freeing an owned object. By
    default, `Deleter` is `std::default_delete<T>`, which calls `delete` or `delete[]`
    on the dynamic object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个模板参数分别是 `T`，表示拥有的动态对象类型，以及 `Deleter`，表示负责释放拥有对象的对象类型。默认情况下，`Deleter` 是 `std::default_delete<T>`，它调用
    `delete` 或 `delete[]` 来删除动态对象。
- en: To write a custom deleter, all you need is a function-like object that is invokable
    with a `T*`. (The unique pointer will ignore the deleter’s return value.) You
    pass this deleter as the second parameter to the unique pointer’s constructor,
    as shown in [Listing 11-12](ch11.xhtml#ch11ex12).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写自定义删除器，所需的只是一个可调用的类似函数的对象，该对象可以使用 `T*` 来调用。（unique pointer 会忽略删除器的返回值。）你将此删除器作为第二个参数传递给
    unique pointer 的构造函数，如 [清单 11-12](ch11.xhtml#ch11ex12) 所示。
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 11-12: Passing a custom deleter to a unique pointer*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-12：将自定义删除器传递给 unique pointer*'
- en: The owned object type is `int` ➋, so you declare a `my_deleter` function object
    that takes an `int*` ➊. You use `decltype` to set the deleter template parameter
    ➌.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有的对象类型是 `int` ➋，所以你声明了一个 `my_deleter` 函数对象，它接受一个 `int*` ➊。你使用 `decltype` 来设置删除器模板参数
    ➌。
- en: '***Custom Deleters and System Programming***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自定义删除器和系统编程***'
- en: You use a custom deleter whenever `delete` doesn’t provide the resource-releasing
    behavior you require. In some settings, you’ll never need a custom deleter. In
    others, like system programming, you might find them quite useful. Consider a
    simple example where you manage a file using the low-level APIs `fopen`, `fprintf`,
    and `fclose` in the `<cstdio>` header.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `delete` 不提供你需要的资源释放行为时，你会使用自定义删除器。在某些环境下，你可能永远不需要自定义删除器，而在其他情况下，例如系统编程，你可能会发现它们非常有用。考虑一个简单的例子，使用
    `<cstdio>` 头文件中的底层 API `fopen`、`fprintf` 和 `fclose` 管理文件。
- en: 'The `fopen` function opens a file and has the following signature:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`fopen` 函数打开一个文件，其签名如下：'
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: On success, `fopen` returns a non-`nullptr`-valued `FILE*` ➊. On failure, `fopen`
    returns `nullptr` and it sets the static `int` variable `errno` equal to an error
    code, like access denied (`EACCES` `= 13`) or no such file (`ENOENT` `= 2`).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，`fopen` 返回一个非 `nullptr` 值的 `FILE*` ➊。失败时，`fopen` 返回 `nullptr` 并将静态 `int`
    变量 `errno` 设置为一个错误代码，例如访问被拒绝（`EACCES` `= 13`）或没有此文件（`ENOENT` `= 2`）。
- en: '**NOTE**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*See the errno.h header for a listing of all error conditions and their corresponding
    int values.*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅 errno.h 头文件，以查看所有错误条件及其对应的整数值。*'
- en: 'The `FILE*` file handle is a reference to a file the operating system manages.
    A *handle* is an opaque, abstract reference to some resource in an operating system.
    The `fopen` function takes two arguments: `filename` ➋ is the path to the file
    you want to open, and `mode` ➌ is one of the six options shown in [Table 11-2](ch11.xhtml#ch11tab02).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`FILE*`文件句柄是操作系统管理的文件的引用。*句柄*是操作系统中某些资源的一个不透明、抽象的引用。`fopen`函数接受两个参数：`filename`
    ➋是你想要打开的文件路径，`mode` ➌是[表11-2](ch11.xhtml#ch11tab02)中列出的六个选项之一。'
- en: '**Table 11-2:** All Six `mode` Options for `fopen`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**表11-2：**`fopen`的六种`mode`选项'
- en: '| **String** | **Operations** | **File exists:** | **File doesn’t exist:**
    | **Notes** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **字符串** | **操作** | **文件存在：** | **文件不存在：** | **备注** |'
- en: '| `r` | Read |  | `fopen` fails |  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `r` | 读 |  | `fopen`失败 |  |'
- en: '| `w` | Write | Overwrite | Create it | If the file exists, all contents are
    discarded. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `w` | 写 | 覆盖 | 创建 | 如果文件存在，所有内容会被丢弃。 |'
- en: '| `a` | Append |  | Create it | Always write to the end of the file. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 附加 |  | 创建 | 总是写入文件末尾。 |'
- en: '| `r+` | Read/Write |  | `fopen` fails |  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `r+` | 读/写 |  | `fopen`失败 |  |'
- en: '| `w+` | Read/Write | Overwrite | Create it | If the file exists, all contents
    are discarded. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `w+` | 读/写 | 覆盖 | 创建 | 如果文件存在，所有内容会被丢弃。 |'
- en: '| `a+` | Read/Write |  | Create it | Always write to the end of the file. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `a+` | 读/写 |  | 创建 | 总是写入文件末尾。 |'
- en: 'You must close the file manually with `fclose` once you’re done using it. Failure
    to close file handles is a common source of resource leakages, like so:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用完文件，你必须手动用`fclose`关闭它。未关闭文件句柄是资源泄漏的常见来源，如下所示：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To write to a file, you can use the `fprintf` function, which is like a `printf`
    that prints to a file instead of the console. The `fprintf` function has identical
    usage to `printf` except you provide a file handle as the first argument before
    the format string:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入文件，可以使用`fprintf`函数，它类似于将内容打印到控制台的`printf`，但`fprintf`将内容打印到文件中。`fprintf`函数的使用方法与`printf`完全相同，只不过你需要在格式字符串之前提供文件句柄作为第一个参数：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: On success, `fprintf` returns the number of characters ➊ written to the open
    file ➋. The `format_string` is the same as the format string for `printf` ➌, as
    are the variadic arguments ➍.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，`fprintf`返回写入打开文件的字符数 ➊ ➋。`format_string`与`printf`的格式字符串相同 ➌，变参也是一样的 ➍。
- en: You can use a `std::unique_ptr` to a `FILE`. Obviously, you don’t want to call
    `delete` on the `FILE*` file handle when you’re ready to close the file. Instead,
    you need to close with `fclose`. Because `fclose` is a function-like object accepting
    a `FILE*`, it’s a suitable deleter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`std::unique_ptr`管理`FILE`。显然，当你准备关闭文件时，你不希望调用`delete`来释放`FILE*`文件句柄。相反，你需要使用`fclose`来关闭。因为`fclose`是一个类似函数的对象，接受`FILE*`作为参数，所以它是一个合适的删除器。
- en: The program in [Listing 11-13](ch11.xhtml#ch11ex13) writes the string `HELLO,
    DAVE.` to the file `HAL9000` and uses a unique pointer to perform resource management
    over the open file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单11-13](ch11.xhtml#ch11ex13)中的程序将字符串`HELLO, DAVE.`写入文件`HAL9000`，并使用唯一指针来执行打开文件的资源管理。'
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 11-13: A program using a `std::unique_ptr` and a custom deleter to
    manage a file handle*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单11-13：使用`std::unique_ptr`和自定义删除器管理文件句柄的程序*'
- en: This listing makes the `FileGuard` type alias ➊ for brevity. (Notice the deleter
    type matches the type of `fclose`.) Next is a `say_hello` function that takes
    a `FileGuard` by value ➋. Within `say_hello`, you `fprintf HELLO DAVE` to the
    `file` ➌. Because the lifetime of `file` is bound to `say_hello`, the file gets
    closed once `say_hello` returns. Within `main`, you open the file `HAL9000` in
    `w` mode, which will create or overwrite the file, and you save the raw `FILE*`
    file handle into `file` ➍. You check whether `file` is `nullptr`, indicating an
    error occurred, and return with `errno` if `HAL9000` couldn’t be opened ➎. Next,
    you construct a `FileGuard` by passing the file handle `file` and the custom deleter
    `fclose` ➏. At this point, the file is open, and thanks to its custom deleter,
    `file_guard` manages the file’s lifetime automatically.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表将`FileGuard`类型别名简化为➊（注意，删除器类型与`fclose`的类型匹配）。接下来是一个`sa_hello`函数，它按值接受`FileGuard`
    ➋。在`sa_hello`内，你用`fprintf HELLO DAVE`将内容写入`file` ➌。由于`file`的生命周期与`sa_hello`绑定，文件会在`sa_hello`返回时被关闭。在`main`函数中，你以`w`模式打开文件`HAL9000`，这会创建或覆盖该文件，并将原始`FILE*`文件句柄保存到`file`
    ➍。你检查`file`是否为`nullptr`，表示打开文件时发生错误，如果`HAL9000`无法打开，则返回`errno` ➎。接着，你通过传递文件句柄`file`和自定义删除器`fclose`来构造一个`FileGuard`
    ➏。此时，文件已打开，并且由于自定义删除器，`file_guard`会自动管理文件的生命周期。
- en: To call `say_hello`, you need to transfer ownership into that function (because
    it takes a `FileGuard` by value) ➐. Recall from “Value Categories” on [page 124](ch04.xhtml#page_124)
    that variables like `file_guard` are lvalues. This means you must move it into
    `say_hello` with `std::move`, which writes `HELLO DAVE` to the file. If you omit
    `std::move`, the compiler would attempt to copy it into `say_hello`. Because `unique_ptr`
    has a deleted copy constructor, this would generate a compiler error.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用`say_hello`，需要将所有权传递到该函数中（因为它按值接受`FileGuard`）➐。回想一下在“值类别”中提到的内容（见[第124页](ch04.xhtml#page_124)），像`file_guard`这样的变量是左值。这意味着你必须通过`std::move`将它转移到`say_hello`中，这样就会将`HELLO
    DAVE`写入文件。如果省略了`std::move`，编译器会尝试将其复制到`say_hello`中。由于`unique_ptr`有一个删除的拷贝构造函数，这将导致编译错误。
    |
- en: When `say_hello` returns, its `FileGuard` argument destructs and the custom
    deleter calls `fclose` on the file handle. Basically, it’s impossible to leak
    the file handle. You’ve tied it to the lifetime of `FileGuard`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当`say_hello`返回时，它的`FileGuard`参数会被销毁，且自定义删除器会在文件句柄上调用`fclose`。基本上，不可能泄漏文件句柄。你已经将其绑定到了`FileGuard`的生命周期上。
    |
- en: '***A Partial List of Supported Operations***'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***支持的操作的部分列表***'
- en: '[Table 11-3](ch11.xhtml#ch11tab03) enumerates all the supported `std::unique_ptr`
    operations. In this table, `ptr` is a raw pointer, `u_ptr` is a unique pointer,
    and `del` is a deleter.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[表11-3](ch11.xhtml#ch11tab03)列出了所有支持的`std::unique_ptr`操作。在此表中，`ptr`是一个原始指针，`u_ptr`是一个独占指针，`del`是一个删除器。
    |'
- en: '**Table 11-3:** All of the Supported `std::unique_ptr` Operations'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**表11-3：** 所有支持的`std::unique_ptr`操作'
- en: '| **Operation** | **Notes** |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **说明** |'
- en: '| `unique_ptr<...>{ }` or `unique_ptr<...>{ nullptr }` | Creates an empty unique
    pointer with a `std::default_delete<...>` deleter. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `unique_ptr<...>{ }` 或 `unique_ptr<...>{ nullptr }` | 创建一个空的独占指针，使用`std::default_delete<...>`删除器。
    |'
- en: '| `unique_ptr<...>{` ptr `}` | Creates a unique pointer owning the dynamic
    object pointed to by ptr. Uses a `std::default_delete<...>` deleter. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `unique_ptr<...>{` ptr `}` | 创建一个拥有`ptr`指向的动态对象的独占指针。使用`std::default_delete<...>`删除器。
    |'
- en: '| `unique_ptr<...>{` ptr, del `}` | Creates a unique pointer owning the dynamic
    object pointed to by ptr. Uses del as deleter. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `unique_ptr<...>{` ptr, del `}` | 创建一个拥有`ptr`指向的动态对象的独占指针。使用del作为删除器。 |'
- en: '| `unique_ptr<...>{ move(`u_ptr`) }` | Creates a unique pointer owning the
    dynamic object pointed to by the unique pointer u_ptr. Transfers ownership from
    u_ptr to the newly created unique pointer. Also moves the deleter of u_ptr. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `unique_ptr<...>{ move(`u_ptr`) }` | 创建一个拥有`u_ptr`指向的动态对象的独占指针。将所有权从u_ptr转移到新创建的独占指针。还会移动u_ptr的删除器。
    |'
- en: '| `~unique_ptr<...>()` | Calls deleter on the owned object if full. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `~unique_ptr<...>()` | 如果已满，则对拥有的对象调用删除器。 |'
- en: '| u_ptr1 `= move(`u_ptr2`)` | Transfers ownership of owned object and deleter
    from u_ptr2 to u_ptr1. Destroys currently owned object if full. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| u_ptr1 `= move(`u_ptr2`)` | 将u_ptr2的拥有对象和删除器的所有权转移到u_ptr1。如果已经有对象，则销毁当前拥有的对象。
    |'
- en: '| u_ptr1.`swap(`u_ptr2`)` | Exchanges owned objects and deleters between u_ptr1
    and u_ptr2. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| u_ptr1.`swap(`u_ptr2`)` | 在u_ptr1和u_ptr2之间交换拥有的对象和删除器。 |'
- en: '| `swap(`u_ptr1`,` u_ptr2`)` | A free function identical to the `swap` method.
    |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `swap(`u_ptr1`,` u_ptr2`)` | 一个与`swap`方法相同的自由函数。 |'
- en: '| u_ptr`.reset()` | If full, calls deleter on object owned by u_ptr. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| u_ptr`.reset()` | 如果已满，则对u_ptr拥有的对象调用删除器。 |'
- en: '| u_ptr`.reset(`ptr`)` | Deletes currently owned object; then takes ownership
    of ptr. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| u_ptr`.reset(`ptr`)` | 删除当前拥有的对象；然后获得ptr的所有权。 |'
- en: '| ptr `=` u_ptr`.release()` | Returns the raw pointer ptr; u_ptr becomes empty.
    Deleter *is not* called. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| ptr `=` u_ptr`.release()` | 返回原始指针ptr；u_ptr变为空。删除器*不会*被调用。 |'
- en: '| ptr `=` u_ptr`.get()` | Returns the raw pointer ptr; u_ptr retains ownership.
    |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| ptr `=` u_ptr`.get()` | 返回原始指针ptr；u_ptr保持所有权。 |'
- en: '| `*`u_ptr | Dereference operator on owned object. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `*`u_ptr | 对拥有的对象执行解引用操作符。 |'
- en: '| u_ptr`->` | Member dereference operator on owned object. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| u_ptr`->` | 对拥有的对象执行成员解引用操作符。 |'
- en: '| u_ptr`[`index`]` | References the element at index (arrays only). |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| u_ptr`[`index`]` | 引用索引处的元素（仅限数组）。 |'
- en: '| `bool{` u_ptr `}` | `bool` conversion: `true` if full, `false` if empty.
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `bool{` u_ptr `}` | `bool`转换：如果已满则为`true`，如果为空则为`false`。 |'
- en: '| u_ptr1 `==` u_ptr2u_ptr1 `!=` u_ptr2u_ptr1 `>` u_ptr2u_ptr1 `>=` u_ptr2u_ptr1
    `<` u_ptr2u_ptr1 `<=` u_ptr2 | Comparison operators; equivalent to evaluating
    comparison operators on raw pointers. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| u_ptr1 `==` u_ptr2u_ptr1 `!=` u_ptr2u_ptr1 `>` u_ptr2u_ptr1 `>=` u_ptr2u_ptr1
    `<` u_ptr2u_ptr1 `<=` u_ptr2 | 比较操作符；相当于对原始指针执行比较操作符。 |'
- en: '| u_ptr`.get_deleter()` | Returns a reference to the deleter. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| u_ptr`.get_deleter()` | 返回对删除器的引用。 |'
- en: '**Shared Pointers**'
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**共享指针**'
- en: A *shared pointer* has transferable, non-exclusive ownership over a single dynamic
    object. You can move shared pointers, which makes them transferable, and you *can*
    copy them, which makes their ownership non-exclusive.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*共享指针*对单个动态对象拥有可转移、非独占的所有权。你可以移动共享指针，这使得它们是可转移的，而且你*可以*复制它们，这使得它们的所有权是非独占的。'
- en: Non-exclusive ownership means that a `shared_ptr` checks whether any other `shared_ptr`
    objects also own the object before destroying it. This way, the last owner is
    the one to release the owned object.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 非独占所有权意味着`shared_ptr`会检查是否有其他`shared_ptr`对象也拥有该对象，在销毁它之前。这样，最后一个拥有者将是释放该对象的对象。
- en: The stdlib has a `std::shared_ptr` available in the `<memory>` header, and Boost
    has a `boost::shared_ptr` available in the `<boost/smart_ptr/shared_ptr.hpp>`
    header. You’ll use the stdlib version here.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中在`<memory>`头文件中提供了`std::shared_ptr`，而Boost则在`<boost/smart_ptr/shared_ptr.hpp>`头文件中提供了`boost::shared_ptr`。这里我们使用标准库版本。
- en: '**NOTE**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Both the stdlib and Boost `shared_ptr` are essentially identical, with the
    notable exception that Boost’s shared pointer doesn’t support arrays and requires
    you to use the `boost::shared_array` class in `<boost/smart_ptr/shared_array.hpp>`.
    Boost offers a shared pointer for legacy reasons, but you should use the stdlib
    shared pointer.*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*标准库和Boost的`shared_ptr`基本相同，唯一的显著区别是Boost的shared pointer不支持数组，并且需要使用`boost::shared_array`类（位于`<boost/smart_ptr/shared_array.hpp>`中）。Boost提供了一个共享指针是为了向后兼容，但你应该使用标准库的共享指针。*'
- en: '***Constructing***'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构造***'
- en: 'The `std::shared_ptr` pointer supports all the same constructors as `std::unique_ptr`.
    The default constructor yields an empty shared pointer. To instead establish ownership
    over a dynamic object, you can pass a pointer to the `shared_ptr` constructor,
    like so:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::shared_ptr`指针支持与`std::unique_ptr`相同的所有构造函数。默认构造函数会生成一个空的共享指针。若要建立对动态对象的所有权，你可以将一个指针传递给`shared_ptr`构造函数，如下所示：'
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You also have a corollary `std::make_shared` template function that forwards
    arguments to the pointed-to type’s constructor:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用一个推导参数的`std::make_shared`模板函数，将参数传递给所指向类型的构造函数：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You should generally use `make_shared`. Shared pointers require a *control block*,
    which keeps track of several quantities, including the number of shared owners.
    When you use `make_shared`, you can allocate the control block and the owned dynamic
    object simultaneously. If you first use `operator new` and then allocate a shared
    pointer, you’re making two allocations instead of one.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你应该使用`make_shared`。共享指针需要一个*控制块*，它跟踪多个量，包括共享所有者的数量。当你使用`make_shared`时，你可以同时分配控制块和被拥有的动态对象。如果你先使用`operator
    new`，然后再分配一个共享指针，那你就是进行了两次分配，而不是一次。
- en: '**NOTE**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Sometimes you might want to avoid using `make_shared`. For example, if you’ll
    be using a `weak_ptr`, you’ll still need the control block even if you can deallocate
    the object. In such a situation, you might prefer to have two allocations.*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*有时你可能不想使用`make_shared`。例如，如果你要使用`weak_ptr`，即使你能释放对象，你仍然需要控制块。在这种情况下，你可能会更倾向于使用两个分配。*'
- en: Because a control block is a dynamic object, `shared_ptr` objects sometimes
    need to allocate dynamic objects. If you wanted to take control over how `shared_ptr`
    allocates, you could override `operator new`. But this is shooting a sparrow with
    a cannon. A more tailored approach is to provide an optional template parameter
    called an *allocator type*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于控制块是一个动态对象，`shared_ptr`对象有时需要分配动态对象。如果你想控制`shared_ptr`的分配方式，可以重载`operator
    new`。但这就像用大炮打麻雀一样。一个更合适的方法是提供一个可选的模板参数，称为*分配器类型*。
- en: '***Specifying an Allocator***'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***指定分配器***'
- en: The allocator is responsible for allocating, creating, destroying, and deallocating
    objects. The default allocator, `std::allocator`, is a template class defined
    in the `<memory>` header. The default allocator allocates memory from dynamic
    storage and takes a template parameter. (You’ll learn about customizing this behavior
    with a user-defined allocator in “Allocators” on [page 365](ch11.xhtml#page_365)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 分配器负责分配、创建、销毁和释放对象。默认分配器`std::allocator`是一个在`<memory>`头文件中定义的模板类。默认分配器从动态存储区分配内存，并接受一个模板参数。（你将在“分配器”一章中了解如何使用用户自定义分配器来定制这一行为，见[第365页](ch11.xhtml#page_365)）。
- en: 'Both the `shared_ptr` constructor and `make_shared` have an allocator type
    template parameter, making three total template parameters: the pointed-to type,
    the deleter type, and the allocator type. For complicated reasons, you only ever
    need to declare the *pointed-to type* parameter. You can think of the other parameter
    types as being deduced from the pointed-to type.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr` 构造函数和 `make_shared` 都有一个分配器类型模板参数，总共包含三个模板参数：指向的类型、删除器类型和分配器类型。由于复杂的原因，你只需要声明*指向的类型*参数。你可以将其他参数类型视为从指向的类型中推导出来的。'
- en: 'For example, here’s a fully adorned `make_shared` invocation including a constructor
    argument, a custom deleter, and an explicit `std::allocator`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一个完整的 `make_shared` 调用，包含一个构造函数参数、一个自定义删除器和一个显式的 `std::allocator`：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, you specify a single template parameter, `int`, for the pointed-to type
    ➊. In the first argument, you allocate and initialize an `int` ➋. Next is a custom
    deleter ➌, and as a third argument you pass a `std::allocator` ➍.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你为指向的类型 ➊ 指定了一个单一的模板参数 `int`。在第一个参数中，你为 `int` 分配并初始化内存 ➋。接下来是一个自定义删除器 ➌，作为第三个参数，你传递一个
    `std::allocator` ➍。
- en: 'For technical reasons, you can’t use a custom deleter or custom allocator with
    `make_shared`. If you want a custom allocator, you can use the sister function
    of `make_shared`, which is `std::allocate_shared`. The `std::allocate _``shared`
    function takes an allocator as the first argument and forwards the remainder of
    the arguments to the owned object’s constructor:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 出于技术原因，你无法在 `make_shared` 中使用自定义删除器或自定义分配器。如果你需要自定义分配器，可以使用 `make_shared` 的姐妹函数，即
    `std::allocate_shared`。`std::allocate_shared` 函数将分配器作为第一个参数，并将其余的参数转发给拥有对象的构造函数：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As with `make_shared`, you specify the owned type as a template parameter ➊,
    but you pass an allocator as the first argument ➋. The rest of the arguments forward
    to the constructor of `int` ➌.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `make_shared` 一样，你将拥有的类型指定为模板参数 ➊，但是将分配器作为第一个参数 ➋。其余的参数会转发给 `int` 的构造函数 ➌。
- en: '**NOTE**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For the curious, here are two reasons why you can’t use a custom deleter with
    `make_``shared`. First, `make_shared` uses `new` to allocate space for the owned
    object and the control block. The appropriate deleter for `new` is `delete`, so
    generally a custom deleter wouldn’t be appropriate. Second, the custom deleter
    can’t generally know how to deal with the control block, only with the owned object.*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于好奇的人，以下是不能使用自定义删除器与 `make_shared` 的两个原因。首先，`make_shared` 使用 `new` 来为拥有的对象和控制块分配空间。适合
    `new` 的删除器是 `delete`，因此通常自定义删除器不合适。其次，自定义删除器通常无法知道如何处理控制块，只能处理拥有的对象。*'
- en: It isn’t possible to specify a custom deleter with either `make_shared` or `allocate_shared`.
    If you want to use a custom deleter with shared pointers, you must use one of
    the appropriate `shared_ptr` constructors directly.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 无法使用 `make_shared` 或 `allocate_shared` 指定自定义删除器。如果你想在共享指针中使用自定义删除器，必须直接使用适当的
    `shared_ptr` 构造函数之一。
- en: '***Supported Operations***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***支持的操作***'
- en: 'The `std::shared_ptr` supports every operation that `std::unique_ptr` and `boost::scoped_ptr`
    support. You could use the following type alias as a drop-in replacement for `ScopedOathbreakers`
    in [Listings 11-1](ch11.xhtml#ch11ex01) to [11-7](ch11.xhtml#ch11ex07) and `UniqueOathbreakers`
    from [Listings 11-10](ch11.xhtml#ch11ex10) to [11-13](ch11.xhtml#ch11ex13):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::shared_ptr` 支持 `std::unique_ptr` 和 `boost::scoped_ptr` 支持的所有操作。你可以使用以下类型别名来替代
    [Listings 11-1](ch11.xhtml#ch11ex01) 到 [11-7](ch11.xhtml#ch11ex07) 中的 `ScopedOathbreakers`
    和 [Listings 11-10](ch11.xhtml#ch11ex10) 到 [11-13](ch11.xhtml#ch11ex13) 中的 `UniqueOathbreakers`：'
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The major functional difference between a shared pointer and a unique pointer
    is that you can copy shared pointers.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 共享指针和独占指针之间的主要功能差异在于，你可以复制共享指针。
- en: '***Transferable, Non-Exclusive Ownership***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可转移的、非独占所有权***'
- en: Shared pointers are transferable (you *can* move them), and they have non-exclusive
    ownership (you *can* copy them). [Listing 11-10](ch11.xhtml#ch11ex10), which illustrates
    a unique pointer’s move semantics, works the same for a shared pointer. [Listing
    11-14](ch11.xhtml#ch11ex14) demonstrates that shared pointers also support copy
    semantics.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 共享指针是可转移的（你*可以*移动它们），并且具有非独占所有权（你*可以*复制它们）。[Listing 11-10](ch11.xhtml#ch11ex10)，展示了独占指针的移动语义，对于共享指针也是一样的。
    [Listing 11-14](ch11.xhtml#ch11ex14) 证明共享指针也支持复制语义。
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 11-14: The `std::shared_ptr` supports copy.*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-14: `std::shared_ptr` 支持复制。*'
- en: After constructing the shared pointer `aragorn`, you have three tests. The first
    test illustrates that the copy constructor that you use to build `son_``of_arathorn`
    ➊ shares ownership over the same `DeadMenOfDunharrow` ➋.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造共享指针`aragorn`之后，您有三个测试。第一个测试说明，您用来构建`son_``of_arathorn` ➊的复制构造函数共享同一个`DeadMenOfDunharrow`
    ➋。
- en: In the second test, you construct an empty shared pointer `son_of _ara``thorn`
    ➌ and then show that copy assignment ➍ also doesn’t change the number of `DeadMenOfDunharrow`
    ➎.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个测试中，您构造了一个空的共享指针`son_of _ara``thorn` ➌，然后展示复制赋值 ➍ 也不会改变`DeadMenOfDunharrow`的数量
    ➎。
- en: The third test illustrates that when you construct the full shared pointer `son_of_arathorn`
    ➏, the number of `DeadMenOfDunharrow` increases to 2 ➐. When you copy assign `aragorn`
    to `son_of_arathorn` ➑, the `son_of_arathorn` deletes its `DeadMenOfDunharrow`
    because it has sole ownership. It then increments the reference count of the `DeadMenOfDunharrow`
    owned by `aragorn`. Because both shared pointers own the same `DeadMenOfDunharrow`,
    the `oaths_to_fulfill` decrements from 2 to 1 ➒.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个测试说明，当您构造完整的共享指针`son_of_arathorn` ➏时，`DeadMenOfDunharrow`的数量增加到2 ➐。当您将`aragorn`复制赋值给`son_of_arathorn`
    ➑时，`son_of_arathorn`删除了其`DeadMenOfDunharrow`，因为它拥有唯一所有权。然后增加了`aragorn`拥有的`DeadMenOfDunharrow`的引用计数。因为两个共享指针拥有同一个`DeadMenOfDunharrow`，所以`oaths_to_fulfill`从2减少到1
    ➒。
- en: '***Shared Arrays***'
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***共享数组***'
- en: A `shared array` is a shared pointer that owns a dynamic array and supports
    `operator[]`. It works just like a unique array except it has non-exclusive ownership.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared array`是拥有动态数组并支持`operator[]`的共享指针。它的工作方式与唯一数组相同，只是它具有非排他性所有权。'
- en: '***Deleters***'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***删除器***'
- en: 'Deleters work the same way for shared pointers as they do for unique pointers
    except you don’t need to provide a template parameter with the deleter’s type.
    Simply pass the deleter as the second constructor argument. For example, to convert
    [Listing 11-12](ch11.xhtml#ch11ex12) to use a shared pointer, you simply drop
    in the following type alias:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于共享指针而言，删除器的工作方式与对唯一指针的工作方式相同，只是您无需提供删除器类型的模板参数。只需将删除器作为第二个构造函数参数传递即可。例如，要将[清单
    11-12](ch11.xhtml#ch11ex12)转换为使用共享指针，您只需插入以下类型别名：
- en: '[PRE28]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, you’re managing `FILE*` file handles with shared ownership.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您正在管理具有共享所有权的`FILE*`文件句柄。
- en: '***A Partial List of Supported Operations***'
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***支持操作的部分列表***'
- en: '[Table 11-4](ch11.xhtml#ch11tab04) provides a mostly complete listing of the
    supported constructors of `shared_ptr`. In this table, `ptr` is a raw pointer,
    `sh_ptr` is a shared pointer, `u_ptr` is a unique pointer, `del` is a deleter,
    and `alc` is an allocator.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11-4](ch11.xhtml#ch11tab04)提供了支持的`shared_ptr`构造函数的大部分完整列表。在本表中，`ptr`是原始指针，`sh_ptr`是共享指针，`u_ptr`是唯一指针，`del`是删除器，`alc`是分配器。'
- en: '**Table 11-4:** All of the Supported `std::shared_ptr` Constructors'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 11-4:** 所有支持的`std::shared_ptr`构造函数'
- en: '| **Operation** | **Notes** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **注释** |'
- en: '| `shared_ptr<...>{ }` or `shared_ptr<...>{ nullptr }` | Creates an empty shared
    pointer with a `std::default_delete<T>` and a `std::allocator<T>`. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `shared_ptr<...>{ }` or `shared_ptr<...>{ nullptr }` | 创建一个空的共享指针，使用`std::default_delete<T>`和`std::allocator<T>`。'
- en: '| `shared_ptr<...>{` ptr, [del], [alc] `}` | Creates a shared pointer owning
    the dynamic object pointed to by ptr. Uses a `std::default_delete<T>` and a `std::allocator<T>`
    by default; otherwise, del as deleter, alc as allocator if supplied. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `shared_ptr<...>{` ptr, [del], [alc] `}` | 创建一个共享指针，拥有由ptr指向的动态对象。默认情况下使用`std::default_delete<T>`和`std::allocator<T>`；否则，使用del作为删除器，alc作为分配器（如果提供）。'
- en: '| `shared_ptr<...>{` sh_ptr `}` | Creates a shared pointer owning the dynamic
    object pointed to by the shared pointer sh_ptr. Copies ownership from sh_ptr to
    the newly created shared pointer. Also copies the deleter and allocator of sh_ptr.
    |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `shared_ptr<...>{` sh_ptr `}` | 创建一个共享指针，拥有由共享指针`sh_ptr`指向的动态对象。从`sh_ptr`复制所有权到新创建的共享指针。还复制了`sh_ptr`的删除器和分配器。'
- en: '| `shared_ptr<...>{` sh_ptr , ptr `}` | An *aliasing constructor*: the resulting
    shared pointer holds an unmanaged reference to ptr but participates in sh_ptr
    reference counting. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `shared_ptr<...>{` sh_ptr , ptr `}` | 一个*别名构造函数*：生成的共享指针持有对ptr的未管理引用，但参与sh_ptr的引用计数。'
- en: '| `shared_ptr<...>{ move(`sh_ptr`) }` | Creates a shared pointer owning the
    dynamic object pointed to by the shared pointer sh_ptr. Transfers ownership from
    sh_ptr to the newly created shared pointer. Also moves the deleter of sh_ptr.
    |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `shared_ptr<...>{ move(`sh_ptr`) }` | 创建一个共享指针，拥有由共享指针`sh_ptr`指向的动态对象。将所有权从`sh_ptr`转移到新创建的共享指针。还移动了`sh_ptr`的删除器。'
- en: '| `shared_ptr<...>{ move(`u_ptr`) }` | Creates a shared pointer owning the
    dynamic object pointed to by the unique pointer u_ptr. Transfers ownership from
    u_ptr to the newly created shared pointer. Also moves the deleter of u_ptr. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `shared_ptr<...>{ move(`u_ptr`) }` | 创建一个共享指针，拥有由独占指针u_ptr指向的动态对象。将所有权从u_ptr转移到新创建的共享指针，并移动u_ptr的删除器。
    |'
- en: '[Table 11-5](ch11.xhtml#ch11tab05) provides a listing of most of the supported
    operations of `std::shared_ptr`. In this table, `ptr` is a raw pointer, `sh_ptr`
    is a shared pointer, `u_ptr` is a unique pointer, `del` is a deleter, and `alc`
    is an allocator.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11-5](ch11.xhtml#ch11tab05)列出了大多数支持的`std::shared_ptr`操作。在此表中，`ptr`是原始指针，`sh_ptr`是共享指针，`u_ptr`是独占指针，`del`是删除器，`alc`是分配器。'
- en: '**Table 11-5:** Most of the Supported `std::shared_ptr` Operations'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 11-5:** 大多数支持的`std::shared_ptr`操作'
- en: '| **Operation** | **Notes** |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `~shared_ptr<...>()` | Calls deleter on the owned object if no other owners
    exist. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `~shared_ptr<...>()` | 如果没有其他拥有者，则调用删除器删除拥有的对象。 |'
- en: '| sh_ptr1 `=` sh_ptr2 | Copies ownership of owned object and deleter from sh_ptr2
    to sh_ptr1. Increments number of owners by 1\. Destroys currently owned object
    if no other owners exist. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| sh_ptr1 `=` sh_ptr2 | 将sh_ptr2的拥有权和删除器复制到sh_ptr1，拥有者数量加1。如果没有其他拥有者，则销毁当前拥有的对象。
    |'
- en: '| sh_ptr `= move(`u_ptr`)` | Transfers ownership of owned object and deleter
    from u_ptr to sh_ptr. Destroys currently owned object if no other owners exist.
    |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| sh_ptr `= move(`u_ptr`)` | 将拥有的对象和删除器的所有权从u_ptr转移到sh_ptr。如果没有其他拥有者，则销毁当前拥有的对象。
    |'
- en: '| sh_ptr1 `= move(`sh_ptr2`)` | Transfers ownership of owned object and deleter
    from sh_ptr2 to sh_ptr1. Destroys currently owned object if no other owners exist.
    |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| sh_ptr1 `= move(`sh_ptr2`)` | 将拥有的对象和删除器的所有权从sh_ptr2转移到sh_ptr1。如果没有其他拥有者，则销毁当前拥有的对象。
    |'
- en: '| sh_ptr1`.swap(`sh_ptr2`)` | Exchanges owned objects and deleters between
    sh_ptr1 and sh_ptr2. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| sh_ptr1`.swap(`sh_ptr2`)` | 在sh_ptr1和sh_ptr2之间交换拥有的对象和删除器。 |'
- en: '| `swap(`sh_ptr1`,` sh_ptr2`)` | A free function identical to the `swap` method.
    |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `swap(`sh_ptr1`,` sh_ptr2`)` | 一个与`swap`方法相同的自由函数。 |'
- en: '| sh_ptr`.reset()` | If full, calls deleter on object owned by sh_ptr if no
    other owners exist. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| sh_ptr`.reset()` | 如果满了，并且没有其他拥有者，则调用删除器删除sh_ptr拥有的对象。 |'
- en: '| sh_ptr`.reset(`ptr`,` [del]`,` [alc]`)` | Deletes currently owned object
    if no other owners exist; then takes ownership of ptr. Can optionally provide
    deleter del and allocator alc. These default to `std::default_delete<T>` and `std::allocator<T>`.
    |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| sh_ptr`.reset(`ptr`,` [del]`,` [alc]`)` | 如果没有其他拥有者，则删除当前拥有的对象；然后接管ptr的拥有权。可以选择提供删除器del和分配器alc，默认为`std::default_delete<T>`和`std::allocator<T>`。
    |'
- en: '| ptr `=` sh_ptr`.get()` | Returns the raw pointer ptr; sh_ptr retains ownership.
    |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| ptr `=` sh_ptr`.get()` | 返回原始指针ptr；sh_ptr保留拥有权。 |'
- en: '| `*`sh_ptr | Dereference operator on owned object. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `*`sh_ptr | 对拥有对象的解引用操作符。 |'
- en: '| sh_ptr`->` | Member dereference operator on owned object. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| sh_ptr`->` | 对拥有对象的成员解引用操作符。 |'
- en: '| sh_ptr`.use_count()` | References the total number of shared pointers owning
    the owned object; zero if empty. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| sh_ptr`.use_count()` | 引用拥有当前对象的共享指针总数；如果为空则为零。 |'
- en: '| sh_ptr`[`index`]` | Returns the element at index (arrays only). |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| sh_ptr`[`index`]` | 返回索引处的元素（仅适用于数组）。 |'
- en: '| `bool{` sh_ptr `}` | `bool` conversion: `true` if full, `false` if empty.
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `bool{` sh_ptr `}` | `bool`转换：如果满了返回`true`，如果为空返回`false`。 |'
- en: '| sh_ptr1 `==` sh_ptr2sh_ptr1 `!=` sh_ptr2sh_ptr1 `>` sh_ptr2sh_ptr1 `>=` sh_ptr2sh_ptr1
    `<` sh_ptr2sh_ptr1 `<=` sh_ptr2 | Comparison operators; equivalent to evaluating
    comparison operators on raw pointers. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| sh_ptr1 `==` sh_ptr2sh_ptr1 `!=` sh_ptr2sh_ptr1 `>` sh_ptr2sh_ptr1 `>=` sh_ptr2sh_ptr1
    `<` sh_ptr2sh_ptr1 `<=` sh_ptr2 | 比较操作符；等价于在原始指针上评估比较操作符。 |'
- en: '| sh_ptr`.get_deleter()` | Returns a reference to the deleter. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| sh_ptr`.get_deleter()` | 返回删除器的引用。 |'
- en: '**Weak Pointers**'
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**弱指针**'
- en: A *weak pointer* is a special kind of smart pointer that has no ownership over
    the object to which it refers. Weak pointers allow you to track an object and
    to convert the weak pointer into a shared pointer *only if the tracked object
    still exists*. This allows you to generate temporary ownership over an object.
    Like shared pointers, weak pointers are movable and copyable.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*弱指针*是一种特殊的智能指针，它不拥有所引用对象的所有权。弱指针允许你跟踪一个对象，并且*仅在被跟踪的对象仍然存在时*才能将弱指针转换为共享指针。这允许你对对象生成临时拥有权。像共享指针一样，弱指针是可移动和可复制的。'
- en: A common usage for weak pointers is *caches*. In software engineering, a cache
    is a data structure that stores data temporarily so it can be retrieved faster.
    A cache could keep weak pointers to objects so they destruct once all other owners
    release them. Periodically, the cache can scan its stored weak pointers and trim
    those with no other owners.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 弱指针的一个常见用途是*缓存*。在软件工程中，缓存是一个临时存储数据的数据结构，目的是加速数据的读取。缓存可以保持指向对象的弱指针，这样一旦所有其他所有者释放它们，缓存中的对象就会被销毁。定期，缓存可以扫描其存储的弱指针，并修剪掉那些没有其他所有者的指针。
- en: The stdlib has a `std::weak_ptr`, and Boost has a `boost::weak_ptr`. These are
    essentially identical and are only meant to be used with their respective shared
    pointers, `std::shared_ptr` and `boost::shared_ptr`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了`std::weak_ptr`，而Boost库提供了`boost::weak_ptr`。这两者本质上是相同的，仅供与各自的共享指针`std::shared_ptr`和`boost::shared_ptr`一起使用。
- en: '***Constructing***'
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构造***'
- en: Weak pointer constructors are completely different from scoped, unique, and
    shared pointers because weak pointers don’t directly own dynamic objects. The
    default constructor constructs an empty weak pointer. To construct a weak pointer
    that tracks a dynamic object, you must construct it using either a shared pointer
    or another weak pointer.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 弱指针的构造函数与作用域指针、唯一指针和共享指针完全不同，因为弱指针并不直接拥有动态对象。默认构造函数会构造一个空的弱指针。要构造一个跟踪动态对象的弱指针，必须使用共享指针或另一个弱指针来构造。
- en: 'For example, the following passes a shared pointer into the weak pointer’s
    constructor:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将一个共享指针传递给弱指针的构造函数：
- en: '[PRE29]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now the weak pointer `wp` will track the object owned by the shared pointer
    `sp`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，弱指针`wp`将跟踪由共享指针`sp`拥有的对象。
- en: '***Obtaining Temporary Ownership***'
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***获取暂时所有权***'
- en: Weak pointers invoke their `lock` method to get temporary ownership of their
    tracked object. The lock method always creates a shared pointer. If the tracked
    object is alive, the returned shared pointer owns the tracked object. If the tracked
    object is no longer alive, the returned shared pointer is empty. Consider the
    example in [Listing 11-15](ch11.xhtml#ch11ex15).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 弱指针通过调用其`lock`方法来暂时拥有它所跟踪的对象。`lock`方法总是创建一个共享指针。如果被跟踪的对象仍然存活，返回的共享指针会拥有该对象。如果被跟踪的对象已不再存活，返回的共享指针则为空。参考[示例
    11-15](ch11.xhtml#ch11ex15)。
- en: '[PRE30]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 11-15: The `std::weak_ptr` exposes a `lock` method for obtaining temporary
    ownership.*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-15：`std::weak_ptr`暴露了一个`lock`方法，用于获取暂时的所有权。*'
- en: In the first test, you create the shared pointer `aragorn` ➊ with a message.
    Next, you construct a weak pointer `legolas` using `aragorn` ➋. This sets up `legolas`
    to track the dynamic object owned by `aragorn`. When you call `lock` on the weak
    pointer ➌, `aragorn` is still alive, so you obtain the shared pointer `sh_ptr`,
    which also owns the same `DeadMenOfDunharrow`. You confirm this by asserting that
    the `message` is the same ➍ and that the *use count* is 2 ➎.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次测试中，你创建了一个共享指针`aragorn` ➊，并赋予它一个消息。接着，使用`aragorn` ➋构造一个弱指针`legolas`。这样，`legolas`就开始跟踪由`aragorn`拥有的动态对象。当你调用弱指针的`lock`方法
    ➌ 时，`aragorn`仍然存活，因此你获得了共享指针`sh_ptr`，它也拥有同样的`DeadMenOfDunharrow`对象。你通过断言`message`相同
    ➍，并且*使用计数*为2 ➎来确认这一点。
- en: In the second test, you also create an `aragorn` shared pointer ➏, but this
    time you use the assignment operator ➐, so the previously empty weak pointer `legolas`
    now tracks the dynamic object owned by `aragorn`. Next, `ara``gorn` falls out
    of block scope and dies. This leaves `legolas` tracking a dead object. When you
    call `lock` at this point ➑, you obtain an empty shared pointer ➒.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次测试中，你也创建了一个`aragorn`共享指针 ➏，但这次你使用了赋值运算符 ➐，因此之前为空的弱指针`legolas`现在开始跟踪由`aragorn`拥有的动态对象。接下来，`aragorn`超出作用域并死亡。此时，`legolas`继续跟踪一个已死的对象。当你此时调用`lock`方法
    ➑ 时，得到的是一个空的共享指针 ➒。
- en: '***Advanced Patterns***'
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***高级模式***'
- en: In some advanced usages of shared pointers, you might want to create a class
    that allows instances to create shared pointers referring to themselves. The `std::enable_shared_from_this`
    class template implements this behavior. All that’s required from a user perspective
    is to inherit from `enable_shared _``from_this` in the class definition. This
    exposes the `shared_from_this` and `weak_from_this` methods, which produce either
    a `shared_ptr` or a `weak_ptr` referring to the current object. This is a niche
    case, but if you want to see more details, refer to [util.smartptr.enab].
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些共享指针的高级用法中，你可能需要创建一个类，使得实例能够创建指向自身的共享指针。`std::enable_shared_from_this`类模板实现了这种行为。从用户的角度来看，唯一需要做的就是在类定义中继承`enable_shared_from_this`。这将暴露出`shared_from_this`和`weak_from_this`方法，它们分别生成指向当前对象的`shared_ptr`或`weak_ptr`。这是一个小众情况，但如果你想查看更多细节，请参考[util.smartptr.enab]。
- en: '***Supported Operations***'
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***支持的操作***'
- en: '[Table 11-6](ch11.xhtml#ch11tab06) lists most of the supported weak pointer
    operations. In this table, `w_ptr` is a weak pointer, and `sh_ptr` is a shared
    pointer.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11-6](ch11.xhtml#ch11tab06)列出了大多数支持的弱指针操作。在该表中，`w_ptr`是一个弱指针，`sh_ptr`是一个共享指针。'
- en: '**Table 11-6:** Most of the Supported `std::shared_ptr` Operations'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 11-6：** 大多数支持的`std::shared_ptr`操作'
- en: '| **Operation** | **Notes** |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **说明** |'
- en: '| `weak_ptr<...>{ }` | Creates an empty weak pointer. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `weak_ptr<...>{ }` | 创建一个空的弱指针。 |'
- en: '| `weak_ptr<...>{` w_ptr `}` or `weak_ptr<...>{` sh_ptr `}` | Tracks the object
    referred to by weak pointer w_ptr or shared pointer sh_ptr. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `weak_ptr<...>{` w_ptr `}` 或 `weak_ptr<...>{` sh_ptr `}` | 跟踪弱指针w_ptr或共享指针sh_ptr所指向的对象。
    |'
- en: '| `weak_ptr<...>{ move(`w_ptr`) }` | Tracks the object referred to by w_ptr;
    then empties w_ptr. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `weak_ptr<...>{ move(`w_ptr`) }` | 跟踪w_ptr所指向的对象；然后清空w_ptr。 |'
- en: '| `~weak_ptr<...>()` | Has no effect on the tracked object. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `~weak_ptr<...>()` | 对跟踪的对象没有影响。 |'
- en: '| w_ptr1 `=` sh_ptr or w_ptr1 `=` w_ptr2 | Replaces currently tracked object
    with the object owned by sh_ptr or tracked by w_ptr2. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| w_ptr1 `=` sh_ptr 或 w_ptr1 `=` w_ptr2 | 用sh_ptr所拥有的对象或w_ptr2所跟踪的对象替换当前跟踪的对象。
    |'
- en: '| w_ptr1 `= move(`w_ptr2`)` | Replaces currently tracked object with object
    tracked by w_ptr2. Empties w_ptr2. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| w_ptr1 `= move(`w_ptr2`)` | 用w_ptr2所跟踪的对象替换当前跟踪的对象，并清空w_ptr2。 |'
- en: '| sh_ptr `=` w_ptr.`lock()` | Creates the shared pointer sh_ptr owning the
    object tracked by w_ptr. If the tracked object has expired, sh_ptr is empty. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| sh_ptr `=` w_ptr.`lock()` | 创建共享指针sh_ptr，拥有w_ptr所跟踪的对象。如果跟踪的对象已过期，则sh_ptr为空。
    |'
- en: '| w_ptr1`.swap(`w_ptr2`)` | Exchanges tracked objects between w_ptr1 and w_ptr2.
    |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| w_ptr1`.swap(`w_ptr2`)` | 交换w_ptr1和w_ptr2之间的跟踪对象。 |'
- en: '| `swap(`w_ptr1`,` w_ptr2`)` | A free function identical to the `swap` method.
    |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `swap(`w_ptr1`,` w_ptr2`)` | 与`swap`方法相同的自由函数。 |'
- en: '| w_ptr`.reset()` | Empties the weak pointer. |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| w_ptr`.reset()` | 清空弱指针。 |'
- en: '| w_ptr`.use_count()` | Returns the number of shared pointers owning the tracked
    object. |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| w_ptr`.use_count()` | 返回拥有跟踪对象的共享指针数量。 |'
- en: '| w_ptr`.expired()` | Returns `true` if the tracked object has expired, `false`
    if it hasn’t. |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| w_ptr`.expired()` | 如果跟踪的对象已过期，则返回`true`，否则返回`false`。 |'
- en: '| sh_ptr`.use_count()` | Returns the total number of shared pointers owning
    the owned object; zero if empty. |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| sh_ptr`.use_count()` | 返回拥有所拥有对象的共享指针的总数；如果为空则为零。 |'
- en: '**Intrusive Pointers**'
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**侵入式指针**'
- en: An *intrusive pointer* is a shared pointer to an object with an embedded reference
    count. Because shared pointers usually keep reference counts, they’re not suitable
    for owning such objects. Boost provides an implementation called `boost::intrusive_ptr`
    in the `<boost/smart_ptr/intrusive_ptr.hpp>` header.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*侵入式指针*是指向具有嵌入式引用计数的对象的共享指针。因为共享指针通常保持引用计数，所以它们不适合拥有此类对象。Boost提供了一种实现，称为`boost::intrusive_ptr`，在`<boost/smart_ptr/intrusive_ptr.hpp>`头文件中定义。'
- en: 'It’s rare that a situation calls for an intrusive pointer. But sometimes you’ll
    use an operating system or a framework that contains embedded references. For
    example, in Windows COM programming an intrusive pointer can be very useful: COM
    objects that inherit from the `IUnknown` interface have an `AddRef` and a `Release`
    method, which increment and decrement an embedded reference count (respectively).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 很少会遇到需要使用侵入式指针的情况。但有时你会使用包含嵌入式引用的操作系统或框架。例如，在Windows COM编程中，侵入式指针非常有用：继承自`IUnknown`接口的COM对象具有`AddRef`和`Release`方法，分别用于增加和减少嵌入式引用计数。
- en: Each time an `intrusive_ptr` is created, it calls the function `intrusive_ptr_add_ref`.
    When an `intrusive_ptr` is destroyed, it calls the `intrusive_ptr_release` free
    function. You’re responsible for freeing appropriate resources in `intrusive_ptr_release`
    when the reference count falls to zero. To use `intrusive_ptr`, you must provide
    a suitable implementation of these functions.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建一个`intrusive_ptr`时，都会调用`intrusive_ptr_add_ref`函数。当`intrusive_ptr`被销毁时，它会调用`intrusive_ptr_release`自由函数。当引用计数降到零时，你负责在`intrusive_ptr_release`中释放适当的资源。要使用`intrusive_ptr`，你必须提供这些函数的合适实现。
- en: '[Listing 11-16](ch11.xhtml#ch11ex16) demonstrates intrusive pointers using
    the `DeadMenOfDunharrow` class. Consider the implementations of `intrusive_ptr_add_ref`
    and `intrusive_ptr_release` in this listing.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-16](ch11.xhtml#ch11ex16) 演示了使用 `DeadMenOfDunharrow` 类的侵入式指针。请参考该清单中的
    `intrusive_ptr_add_ref` 和 `intrusive_ptr_release` 的实现。'
- en: '[PRE31]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 11-16: Implementations of `intrusive_ptr_add_ref` and `intrusive_ptr_release`*'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-16: `intrusive_ptr_add_ref` 和 `intrusive_ptr_release` 的实现*'
- en: Using the type alias `IntrusivePtr` saves some typing ➊. Next, you declare a
    `ref_count` with static storage duration ➋. This variable keeps track of the number
    of living intrusive pointers. In `intrusive_ptr_add_ref`, you increment `ref_count`
    ➌. In `intrusive_ptr_release`, you decrement `ref_count` ➍. When `ref _count`
    drops to zero, you delete the `DeadMenOfDunharrow` argument ➎.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型别名`IntrusivePtr`可以减少一些输入量 ➊。接下来，你声明了一个具有静态存储期的`ref_count` ➋。这个变量跟踪活动侵入式指针的数量。在`intrusive_ptr_add_ref`中，你会增加`ref_count`
    ➌。在`intrusive_ptr_release`中，你会减少`ref_count` ➍。当`ref_count`降至零时，你删除`DeadMenOfDunharrow`对象
    ➎。
- en: '**NOTE**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It’s absolutely critical that you use only a single `DeadMenOfDunharrow` dynamic
    object with intrusive pointers when using the setup in [Listing 11-16](ch11.xhtml#ch11ex16).
    The `ref_count` approach will correctly track only a single object. If you have
    multiple dynamic objects owned by different intrusive pointers, the `ref_count`
    will become invalid, and you’ll get incorrect `delete` behavior ➎.*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*在使用[清单 11-16](ch11.xhtml#ch11ex16)中的设置时，务必确保只使用一个动态的 `DeadMenOfDunharrow`
    对象与侵入式指针。`ref_count` 方法只能正确追踪一个对象。如果你有多个由不同侵入式指针拥有的动态对象，`ref_count` 将变得无效，导致错误的
    `delete` 行为 ➎。*'
- en: '[Listing 11-17](ch11.xhtml#ch11ex17) shows how to use the setup in [Listing
    11-16](ch11.xhtml#ch11ex16) with intrusive pointers.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-17](ch11.xhtml#ch11ex17)展示了如何在[清单 11-16](ch11.xhtml#ch11ex16)的设置中使用侵入式指针。'
- en: '[PRE32]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 11-17: Using a `boost::intrusive_ptr`*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-17: 使用 `boost::intrusive_ptr`*'
- en: This test begins by checking that `ref_count` is zero ➊. Next, you construct
    an intrusive pointer by passing a dynamically allocated `DeadMenOfDunharrow` ➋.
    This increases `ref_count` to 1, because creating an intrusive pointer invokes
    `intrusive_ptr_add_ref` ➌. Within a block scope, you construct another intrusive
    pointer `legolas` that shares ownership with `aragorn` ➍. This increases the `ref_count`
    to 2 ➎, because creating an intrusive pointer invokes `intrusive_ptr_add_ref`.
    When `legolas` falls out of block scope, it destructs, causing `intrusive_ptr_release`
    to invoke. This decrements `ref_``count` to 1 but doesn’t cause the owned object
    to delete ➏.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试首先检查`ref_count`是否为零 ➊。接下来，通过传递动态分配的`DeadMenOfDunharrow`对象 ➋ 来构造一个侵入式指针。这会将`ref_count`增加到1，因为创建侵入式指针会调用`intrusive_ptr_add_ref`
    ➌。在一个块作用域内，你构造了另一个侵入式指针`legolas`，它与`aragorn`共享所有权 ➍。这将`ref_count`增加到2 ➎，因为创建侵入式指针会调用`intrusive_ptr_add_ref`。当`legolas`超出块作用域时，它会被析构，从而调用`intrusive_ptr_release`。这会将`ref_count`减少到1，但不会导致删除所拥有的对象
    ➏。
- en: '**Summary of Smart Pointer Options**'
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**智能指针选项总结**'
- en: '[Table 11-7](ch11.xhtml#ch11tab07) summarizes all the smart pointer options
    available to use in stdlib and Boost.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11-7](ch11.xhtml#ch11tab07) 总结了可在 stdlib 和 Boost 中使用的所有智能指针选项。'
- en: '**Table 11-7:** Smart Pointers in stdlib and Boost'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 11-7:** stdlib 和 Boost 中的智能指针'
- en: '| **Type name** | **stdlib header** | **Boost header** | **Movable/transferable
    ownership** | **Copyable/non-exclusive ownership** |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| **类型名称** | **stdlib 头文件** | **Boost 头文件** | **可移动/可转移所有权** | **可复制/非独占所有权**
    |'
- en: '| `scoped_ptr` |  | `<boost/smart_ptr/scoped_ptr.hpp>` |  |  |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `scoped_ptr` |  | `<boost/smart_ptr/scoped_ptr.hpp>` |  |  |'
- en: '| `scoped_array` |  | `<boost/smart_ptr/scoped_array.hpp>` |  |  |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `scoped_array` |  | `<boost/smart_ptr/scoped_array.hpp>` |  |  |'
- en: '| `unique_ptr` | `<memory>` |  | ✓ |  |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `unique_ptr` | `<memory>` |  | ✓ |  |'
- en: '| `shared_ptr` | `<memory>` | `<boost/smart_ptr/shared_ptr.hpp>` | ✓ | ✓ |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `shared_ptr` | `<memory>` | `<boost/smart_ptr/shared_ptr.hpp>` | ✓ | ✓ |'
- en: '| `shared_array` |  | `<boost/smart_ptr/shared_array.hpp>` | ✓ | ✓ |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `shared_array` |  | `<boost/smart_ptr/shared_array.hpp>` | ✓ | ✓ |'
- en: '| `weak_ptr` | `<memory>` | `<boost/smart_ptr/weak_ptr.hpp>` | ✓ | ✓ |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `weak_ptr` | `<memory>` | `<boost/smart_ptr/weak_ptr.hpp>` | ✓ | ✓ |'
- en: '| `intrusive_ptr` |  | `<boost/smart_ptr/intrusive_ptr.hpp>` | ✓ | ✓ |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `intrusive_ptr` |  | `<boost/smart_ptr/intrusive_ptr.hpp>` | ✓ | ✓ |'
- en: '**Allocators**'
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分配器**'
- en: Allocators are low-level objects that service requests for memory. The stdlib
    and Boost libraries enable you to provide allocators to customize how a library
    allocates dynamic memory.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 分配器是低级对象，负责处理内存请求。stdlib和Boost库使你能够提供分配器，定制库如何分配动态内存。
- en: In the majority of cases, the default allocator `std::allocate` is totally sufficient.
    It allocates memory using `operator new(size_t)`, which allocates raw memory from
    the free store, also known as the heap. It deallocates memory using `operator
    delete(void*)`, which deallocates the raw memory from the free store. (Recall
    from “Overloading Operator `new`” on [page 189](ch07.xhtml#page_189) that `operator
    new` and `operator delete` are defined in the `<new>` header.)
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，默认分配器`std::allocate`完全足够。它使用`operator new(size_t)`分配内存，该操作从自由存储区（即堆）中分配原始内存。它使用`operator
    delete(void*)`释放内存，该操作从自由存储区中释放原始内存。（请回顾《重载`new`操作符》中的内容，在[第189页](ch07.xhtml#page_189)中提到，`operator
    new`和`operator delete`是在`<new>`头文件中定义的。）
- en: In some settings, such as gaming, high-frequency trading, scientific analyses,
    and embedded applications, the memory and computational overhead associated with
    the default free store operations is unacceptable. In such settings, it’s relatively
    easy to implement your own allocator. Note that you really shouldn’t implement
    a custom allocator unless you’ve conducted some performance testing that indicates
    that the default allocator is a bottleneck. The idea behind a custom allocator
    is that you know a lot more about your specific program than the designers of
    the default allocator model, so you can make improvements that will increase allocation
    performance.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，比如游戏、高频交易、科学分析和嵌入式应用，默认自由存储操作所带来的内存和计算开销是不可接受的。在这些场景中，实现自定义分配器相对容易。请注意，除非你进行了一些性能测试，表明默认分配器是瓶颈，否则你真的不应该实现自定义分配器。自定义分配器的背后理念是，你对自己特定程序的了解远超过默认分配器模型的设计者，因此你可以做出改进，提升分配性能。
- en: 'At a minimum, you need to provide a template class with the following characteristics
    for it to work as an allocator:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，你需要提供一个具有以下特征的模板类，才能使其作为分配器工作：
- en: An appropriate default constructor
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个合适的默认构造函数
- en: A `value_type` member corresponding to the template parameter
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对应模板参数的`value_type`成员
- en: A template constructor that can copy an allocator’s internal state while dealing
    with a change in `value_type`
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模板构造函数，可以在处理`value_type`变化时复制分配器的内部状态
- en: An `allocate` method
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`allocate`方法
- en: A `deallocate` method
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`deallocate`方法
- en: An `operator==` and an `operator!=`
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`operator==`和一个`operator!=`
- en: The `MyAllocator` class in [Listing 11-18](ch11.xhtml#ch11ex18) implements a
    simple, pedagogical variant of `std::allocate` that keeps track of how many allocations
    and deallocations you’ve made.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表11-18](ch11.xhtml#ch11ex18)中的`MyAllocator`类实现了一个简单的教学版本的`std::allocate`，用于跟踪你进行了多少次分配和释放。'
- en: '[PRE33]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 11-18: A `MyAllocator` class modeled after `std::allocate`*'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-18：一个基于`std::allocate`的`MyAllocator`类*'
- en: First, you declare the `value_type` type alias for `T`, one of the requirements
    for implementing an allocator ➊. Next is a default constructor ➋ and a template
    constructor ➌. Both of these are empty because the allocator doesn’t have state
    to pass on.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你声明`value_type`类型别名为`T`，这是实现分配器的要求之一➊。接下来是默认构造函数➋和模板构造函数➌。这两个构造函数都是空的，因为分配器没有状态可以传递。
- en: The `allocate` method ➍ models `std::allocate` by allocating the requisite number
    of bytes, `sizeof(T) * n`, using `operator new`. Next, it increments the static
    variable `n_allocated` so you can keep track of the number of allocations for
    testing purposes. The `allocate` method then returns a pointer to the newly allocated
    memory after casting `void*` to the relevant pointer type.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`allocate`方法➍通过使用`operator new`分配所需字节数`sizeof(T) * n`来模拟`std::allocate`。接下来，它增加了静态变量`n_allocated`，这样你就可以跟踪分配次数以进行测试。`allocate`方法随后返回指向新分配内存的指针，在返回之前将`void*`转换为相关的指针类型。'
- en: The `deallocate` method ➎ also models `std::allocate` by calling `operator`
    `delete`. As an analogy to `allocate`, it increments the `n_deallocated` static
    variable for testing and returns.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`deallocate`方法➎通过调用`operator delete`来模拟`std::allocate`。类似于`allocate`，它增加了用于测试的`n_deallocated`静态变量，并返回。'
- en: The final task is to implement an `operator==` and an `operator!=` taking the
    new class template. Because the allocator has no state, any instance is the same
    as any other instance, so `operator==` returns `true` ➏ and `operator!``=` returns
    `true` ➐.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的任务是实现一个`operator==`和一个`operator!=`，接受新的类模板。因为分配器没有状态，任何实例都与其他实例相同，因此`operator==`返回`true`
    ➏，而`operator!=`返回`true` ➐。
- en: '**NOTE**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*[Listing 11-18](ch11.xhtml#ch11ex18) is a teaching tool and doesn’t actually
    make allocations any more efficient. It simply wraps the call to `new` and `delete`*.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*[示例11-18](ch11.xhtml#ch11ex18)是一个教学工具，实际上并没有提高分配效率。它只是包装了`new`和`delete`的调用*。'
- en: So far, the only class you know about that uses an allocator is `std::shared
    _ptr`. Consider how [Listing 11-19](ch11.xhtml#ch11ex19) uses `MyAllocator` with
    `std::allocate` shared.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，唯一你知道使用分配器的类是`std::shared_ptr`。考虑一下[示例11-19](ch11.xhtml#ch11ex19)如何将`MyAllocator`与`std::allocate`共享一起使用。
- en: '[PRE34]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 11-19: Using `MyAllocator` with `std::shared_ptr`*'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例11-19：使用`MyAllocator`与`std::shared_ptr`*'
- en: You create a `MyAllocator` instance called `alloc` ➊. Within a block, you pass
    `alloc` as the first argument to `allocate_shared` ➋, which creates the shared
    pointer `aragorn` containing a custom `message` ➌. Next, you confirm that `aragorn`
    contains the correct `message` ➍, `n_allocated` is 1 ➎, and `n_deallocated` is
    0 ➏.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个名为`alloc`的`MyAllocator`实例 ➊。在一个块内，你将`alloc`作为第一个参数传递给`allocate_shared`
    ➋，它创建了一个包含自定义`message`的共享指针`aragorn` ➌。接着，你确认`aragorn`包含正确的`message` ➍，`n_allocated`为1
    ➎，`n_deallocated`为0 ➏。
- en: After `aragorn` falls out of block scope and destructs, you verify that `n_allocated`
    is still 1 ➐ and `n_deallocated` is now 1 ➑.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在`aragorn`超出块作用域并被销毁后，你可以验证`n_allocated`仍为1 ➐，而`n_deallocated`现在为1 ➑。
- en: '**NOTE**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because allocators handle low-level details, you can really get down into
    the weeds when specifying their behavior. See [allocator.requirements] in the
    ISO C++ 17 Standard for a thorough treatment.*'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '*因为分配器处理底层细节，你可以深入到非常细微的地方来指定它们的行为。参见ISO C++ 17标准中的[allocator.requirements]，以获取详细的说明。*'
- en: '**Summary**'
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Smart pointers manage dynamic objects via RAII, and you can provide allocators
    to customize dynamic memory allocation. Depending on which smart pointer you choose,
    you can encode different ownership patterns onto the dynamic object.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针通过RAII管理动态对象，你可以提供分配器来定制动态内存分配。根据你选择的智能指针，你可以将不同的所有权模式编码到动态对象中。
- en: '**EXERCISES**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '**11-1.** Reimplement [Listing 11-13](ch11.xhtml#ch11ex12) to use a `std::shared_ptr`
    rather than a `std::unique_ptr`. Notice that although you’ve relaxed the ownership
    requirements from exclusive to non-exclusive, you’re still transferring ownership
    to the `say_hello` function.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**11-1.** 重新实现[示例11-13](ch11.xhtml#ch11ex12)，使用`std::shared_ptr`而不是`std::unique_ptr`。注意，尽管你将所有权要求从独占变为非独占，但你仍然将所有权转移给了`call_hello`函数。'
- en: '**11-2.** Remove the `std::move` from the call to `say_hello`. Then make an
    additional call to `say_hello`. Notice that the ownership of `file_guard` is no
    longer `transferred` to `say_hello`. This permits multiple calls.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**11-2.** 从调用`say_hello`中移除`std::move`。然后再调用一次`say_hello`。注意，`file_guard`的所有权不再被`转移`到`say_hello`函数中。这允许多次调用。'
- en: '**11-3.** Implement a `Hal` class that accepts a `std::shared_ptr<FILE>` in
    its constructor. In Hal’s destructor, write the phrase `Stop, Dave.` to the file
    handle held by your shared pointer. Implement a `write_status` function that writes
    the phrase `I''m completely operational.` to the file handle. Here’s a class declaration
    you can work from:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**11-3.** 实现一个`Hal`类，在其构造函数中接受一个`std::shared_ptr<FILE>`。在Hal的析构函数中，将短语`Stop,
    Dave.`写入共享指针持有的文件句柄。实现一个`write_status`函数，将短语`I''m completely operational.`写入文件句柄。以下是你可以使用的类声明：'
- en: '[PRE35]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**11-4.** Create several `Hal` instances and invoke `write_status` on them.
    Notice that you don’t need to keep track of how many `Hal` instances are open:
    file management gets handled via the shared pointer’s shared ownership model.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**11-4.** 创建多个`Hal`实例并调用`write_status`。注意，你不需要跟踪有多少`Hal`实例是打开的：文件管理通过共享指针的共享所有权模型来处理。'
- en: '**FURTHER READING**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*ISO International Standard ISO/IEC (2017) — Programming Language C++* (International
    Organization for Standardization; Geneva, Switzerland; *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*)'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ISO国际标准ISO/IEC (2017) — C++编程语言*（国际标准化组织；瑞士日内瓦；*[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*）'
- en: '*The C++ Programming Language*, 4th Edition, by Bjarne Stroustrup (Pearson
    Education, 2013)'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《C++程序设计语言》*（第4版），作者：比雅尼·斯特劳斯特鲁普（Pearson Education，2013年）'
- en: '*The Boost C++ Libraries*, 2nd Edition, by Boris Schäling (XML Press, 2014)'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Boost C++库》*（第2版），作者：博里斯·舍林（XML Press，2014年）'
- en: '*The C++ Standard Library: A Tutorial and Reference*, 2nd Edition, by Nicolai
    M. Josuttis (Addison-Wesley Professional, 2012)'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《C++标准库：教程与参考》*（第2版），作者：尼古拉·M·乔苏蒂斯（Addison-Wesley Professional，2012年）'
