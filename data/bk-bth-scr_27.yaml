- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 24 TEXT STRING SEARCHES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 24 文本字符串搜索
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: In previous chapters, you’ve seen a number of searches, such as for files, directories,
    and even lost disk space. In this chapter, I’ll discuss the many ways of searching
    for text strings and possible applications for text searches. You’ll see searches
    for a single word, searches for one out of multiple possible words, and searches
    for a literal string containing multiple words. Another search flavor will look
    for a list of words and considers the search a success only if each and every
    word is found. I’ll show how to perform these searches against a file, multiple
    files, and other strings.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你已经看到了多种搜索方法，例如查找文件、目录，甚至是丢失的磁盘空间。在本章中，我将讨论多种文本字符串搜索方式以及这些搜索的应用场景。你将看到单个单词的搜索、从多个可能单词中选择一个的搜索、以及包含多个单词的文字字符串搜索。另一种搜索方式将查找一个单词列表，并且只有当每个单词都被找到时，搜索才算成功。我将演示如何对文件、多个文件以及其他字符串执行这些搜索。
- en: For performing these searches, I’ll compare and contrast two very different
    techniques. One is far more flexible, and the other executes much faster, so they’re
    both extremely useful. I’ll also discuss regular expressions and how you can use
    them to build some very impressive Batch searches.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这些搜索，我将比较并对比两种非常不同的技术。一种更加灵活，另一种执行速度更快，因此它们各自都有极高的实用价值。我还将讨论正则表达式，并展示如何利用它们构建一些非常强大的
    Batch 搜索。
- en: Searching within a File
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在文件中搜索
- en: To demonstrate how to search each record in a file for a string, the first requirement
    is a file to search. In the real world, you might have a logfile containing tens
    of thousands of records with many clients interspersed; searching for a client
    name can extract all relevant entries for a more targeted report. Daily report
    files might each have totals at the end; a search on the Totals text can extract
    each of those trailer records from all of the report files in a certain directory.
    Better yet, you can search all files satisfying a file mask, maybe targeting files
    from the prior month or year.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何在文件中搜索字符串，第一个要求是有一个文件可供搜索。在实际应用中，你可能会有一个包含成千上万条记录的日志文件，其中夹杂着许多客户端信息；搜索客户端名称可以提取出所有相关条目，从而生成一个更有针对性的报告。每日报告文件的结尾可能每个都有总计；在这些报告文件中搜索
    Totals 文本可以提取出每个报告文件中的所有尾部记录。更好的是，你还可以搜索满足文件掩码的所有文件，也许是针对上个月或去年的文件。
- en: 'For this demonstration, I’ll use a much smaller (and I hope more interesting)
    input file, a file called *12Movies.txt* containing a not-so-random list of a
    dozen movies spanning three decades, organized by release date. Look closely for
    any commonalities with the titles. Here are its complete contents:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次演示中，我将使用一个更小的（也希望更有趣的）输入文件，一个名为 *12Movies.txt* 的文件，里面包含了一份跨越三十年的电影名单，按照上映日期排列。仔细观察这些标题，看是否能发现任何共同点。以下是该文件的完整内容：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Some are great movies, some not so great, and some I’ve never seen, but we’ll
    be using this file in many examples throughout this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些是很棒的电影，有些则一般，还有一些我从未看过，但我们将在本章的多个示例中使用这个文件。
- en: A Simple String
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个简单的字符串
- en: 'The findstr command is the primary Batch tool for finding a text string inside
    one or more files. Despite the abbreviation, coders refer to it as the *find string*
    command. You’ll soon see how versatile this command is, but I’ll start with a
    simple optionless command that searches for the word Little in the input file.
    The first argument is the search string, and the second argument is the file to
    be searched:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`findstr` 命令是 Batch 中查找一个或多个文件内文本字符串的主要工具。尽管命令名较为简短，但程序员通常称其为 *find string*
    命令。你将很快看到这个命令的多功能性，但我将从一个没有选项的简单命令开始，该命令搜索输入文件中的 Little 一词。第一个参数是搜索字符串，第二个参数是要搜索的文件：'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command writes every record from the file containing the six consecutive
    letters in the search string to stdout:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会将包含六个连续字母的每一条记录从文件中写入 stdout：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that the interpreter returns the first title even though it contains
    the search word appended with an s; the command isn’t searching for whole words.
    Also, this particular command sets the pseudo-environment variable errorlevel
    to 0, indicating that it found at least one instance of the search string. If
    it finds no matches, errorlevel takes on the value of 1.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管返回的第一个标题包含了搜索词后缀的字母 "s"，但解释器仍然返回了该标题；这个命令并不是在搜索完整的单词。此外，这个特定的命令会将伪环境变量
    errorlevel 设置为 0，表示它找到了至少一个匹配的搜索字符串。如果没有找到任何匹配项，errorlevel 的值会变成 1。
- en: Typically, coders handle the output from this command in one of three ways.
    If you simply want to know whether one or more records exist, you need only interrogate
    errorlevel and move on. In other instances, you can redirect the list of returned
    records written to stdout to the console or an output file for later use or viewing.
    The last use is to programmatically process every returned record, which you can
    do by using a findstr command as input to a for /F command. For most of the upcoming
    examples, I’ll describe what’s written to stdout, but understand that the output
    has many different uses.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编码人员会以三种方式处理此命令的输出。如果你仅仅想知道是否存在一个或多个记录，你只需要检查 errorlevel 并继续。其他情况下，你可以将写入标准输出的返回记录列表重定向到控制台或输出文件，以供后续使用或查看。最后一种用法是通过程序化方式处理每一个返回的记录，你可以通过将
    findstr 命令作为输入传递给 for /F 命令来实现。在接下来的大部分示例中，我会描述写入标准输出的内容，但请理解，这些输出有许多不同的用途。
- en: 'Now let’s make a subtle change to the prior command and make the search string
    entirely lowercase:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对之前的命令做一个微小的修改，将搜索字符串全部改为小写：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This returns nothing because the findstr command performs case-sensitive searches,
    by default anyway, and every instance of the word in the file starts with an uppercase
    L. The other interesting result is that because the command returned nothing,
    1 is the value of errorlevel. Often, a case-sensitive search is exactly what you
    want; many other times, that’s exactly what you don’t want.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令没有返回任何结果，因为 findstr 命令默认是区分大小写的，而且文件中每个单词的实例都以大写字母 L 开头。另一个有趣的结果是，由于命令没有返回任何内容，errorlevel
    的值为 1。通常，区分大小写的搜索正是你想要的；但很多时候，正是你不想要的。
- en: Customizations
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自定义选项
- en: Fortunately, this command has a large number of options to customize each search.
    I’ll discuss many of them in this chapter, starting with a few options that change
    the behavior of the findstr command in simple yet powerful ways.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个命令有许多选项可以自定义每次搜索。我将在本章中讨论其中的许多选项，从一些改变 findstr 命令行为的简单但强大的选项开始。
- en: 'Just as the /i option invokes case-insensitivity of the if command, the same
    option works for the findstr command. (As mentioned in [Chapter 4](chapter4.xhtml),
    I use lowercase for this one option, but /I also works.) Notice the option and
    the odd capitalization of tHE:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 /i 选项启用 if 命令的不区分大小写功能一样，同样的选项也适用于 findstr 命令。（如[第 4 章](chapter4.xhtml)中所提到的，我使用小写字母表示此选项，但
    /I 也有效。）注意该选项和奇怪的大写方式 tHE：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'I’m not recommending a capitalization scheme such as this, but I do it here
    to unambiguously demonstrate the fact that the interpreter returns all four titles
    containing these three letters in this order, regardless of the case, as you can
    see in the output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是推荐这种大写规则，但我这样做是为了清楚地展示解释器返回的四个标题，包含这三个字母，并按此顺序出现，不论大小写，正如你在输出中看到的：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Another useful option is /E. With it, the command returns only the records
    it finds where the search string is at the *end* of the record. Consider this
    command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的选项是 /E。使用它时，命令只返回搜索字符串位于记录*末尾*的记录。考虑这个命令：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The only title returned is *Stuart Little*. Also notice this command uses multiple
    options for further customization; with the /i and /E options, it performs a case-insensitive
    search for records ending with the search string.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一返回的标题是*Stuart Little*。另外，请注意此命令使用了多个选项进行进一步的自定义；通过 /i 和 /E 选项，它进行不区分大小写的搜索，查找以搜索字符串结尾的记录。
- en: 'Similarly, the /B option returns only the records it finds where the search
    string is at the *beginning* of the record. You can team up this option with /i
    as well as the /N option, which prepends the *line number* to the returned record,
    delimited by a colon:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，/B 选项仅返回搜索字符串位于记录*开头*的记录。你还可以将此选项与 /i 以及 /N 选项组合使用，/N 选项会将*行号*添加到返回的记录前，行号与记录之间用冒号分隔：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This findstr command returns the following four titles, all starting with big,
    case-insensitive, prepended with their corresponding line numbers:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 findstr 命令返回以下四个标题，所有标题都以大写字母开头，不区分大小写，并在前面加上相应的行号：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another useful option is /V, which negates the search logic. The following
    command is identical to the previous one, except it includes the /V option:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的选项是 /V，它会否定搜索逻辑。以下命令与之前的命令相同，除了包含了 /V 选项：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The four records that were returned previously are now missing from the output,
    replaced with the other eight records not satisfying the search criteria. The
    line numbers are still at the front of each record because of the /N option, but
    the /V option alters the logic so that the output consists of all records *not*
    starting with big, case-insensitive:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 之前返回的四条记录现在已从输出中消失，取而代之的是不符合搜索标准的另外八条记录。行号仍然显示在每条记录的前面，因为使用了/N选项，但/V选项改变了逻辑，使得输出仅包含所有*不*以“big”开头的记录，大小写不敏感：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Rounding out these options is /X, which finds only records that match the search
    string in their entirety:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项中的最后一个是/X，它只查找完全匹配搜索字符串的记录：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command returns a single title, the Tom Hanks film *Big*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令返回一个标题，即汤姆·汉克斯的电影*Big*。
- en: The one-character codes in the /i, /B, /E, and /N options are representative
    of their function, but /V, /X, and some others aren’t as obvious. Plan to make
    ample use of the help when working with the findstr command.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: /i、/B、/E和/N选项中的单字符代码代表它们的功能，但/V、/X等选项的功能则不那么明显。在使用findstr命令时，计划充分利用帮助功能。
- en: Multiple Words
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多个词
- en: There are multiple variants of a two-word search (when the search string has
    an embedded space). We can search for all records that have either word, both
    words, or a literal string of the two words separated by that space (or spaces).
    The findstr command handles all of them, although the variant searching for both
    words requires a little extra work. We can extrapolate these solutions to searches
    of more than two words.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 两个词的搜索有多种变体（当搜索字符串包含嵌入的空格时）。我们可以搜索包含任意一个词、两个词都包含，或者这两个词按空格（或空格）分隔的字面字符串的所有记录。findstr命令可以处理所有这些变体，尽管搜索两个词都存在的变体需要做一些额外的工作。我们可以将这些解决方案推展到搜索多个词的情况。
- en: Any Words in a List
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表中的任何词
- en: 'Instead of a one-word search string, the following findstr command has two
    words encased in double quotes. If you haven’t seen something like this before,
    you’re probably expecting it to return all titles with the word the followed by
    the word big, but that’s not the case:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与单词搜索字符串不同，以下的findstr命令将两个词放在双引号中。如果你以前没见过这种情况，你可能期待它返回所有包含“the”后跟“big”的标题，但事实并非如此：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In actuality, the double quotes encase the set of space-delimited search strings.
    The interpreter searches each record in the file for each word in the set of search
    strings, returning all records with at least one match. This command returns nine
    titles; all but three movies in the list contain either the word the or the word
    big, or both.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，双引号将一组以空格分隔的搜索字符串括起来。解释器会在文件中的每条记录中搜索该搜索字符串集合中的每个词，返回至少匹配一个的所有记录。此命令返回九个标题；该列表中的所有电影除三部外，包含了单词“the”或“big”，或者两者都有。
- en: 'Adding three specific words to the set of search strings returns all 12 titles:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 向搜索字符串集合中添加三个特定的词将返回所有12个标题：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The three additional words in the set of search strings are part of the words
    *Stuart*, *Shop*, and *Sunshine*, respectively, and each of those words is in
    one of the previously missing titles. Although, if you haven’t noticed yet, the
    two-word set of search strings, "big little", returns every record in the file
    more efficiently.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索字符串集合中的另外三个词分别是*Stuart*、*Shop*和*Sunshine*，而每个词都出现在之前缺失的标题中。尽管如此，如果你还没有注意到，双词搜索字符串集“big
    little”能更高效地返回文件中的每条记录。
- en: A Literal String
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一个字面值字符串
- en: 'With a simple modification, you can alter the command searching for either
    of two words to search for a single string: the, followed by a space and big.
    The /C option defines a literal search string, and you must use it when the search
    string includes at least one space.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单修改，你可以将搜索命令从查找两个词之一，改为查找单一字符串：the，后跟一个空格和big。/C选项定义了一个字面值搜索字符串，当搜索字符串包含至少一个空格时，必须使用此选项。
- en: 'You’ve already seen a case-insensitive search of *12Movies.txt*. In this example,
    I’ve inserted the /C: option in front of what’s now a literal search string encased
    in double quotes:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前已经看到过对*12Movies.txt*的大小写不敏感的搜索。在这个例子中，我在现在被双引号括起来的字面搜索字符串前插入了/C:选项：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This findstr command returns just these two titles:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该findstr命令仅返回这两个标题：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Both of these titles happen to start with the text, but a record with this literal
    string later in the title would’ve also been part of the output.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个标题恰好以该文本开头，但如果该字面字符串出现在标题后面，记录也会出现在输出中。
- en: The literal search string doesn’t have to contain entire words. The following
    command
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 字面搜索字符串不必包含完整的单词。以下命令
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: returns the title *My Big Fat Greek Wedding*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的标题是*My Big Fat Greek Wedding*。
- en: All Words in a List
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表中的所有单词
- en: 'There’s just one movie title in the *12Movies.txt* file that contains two particular
    words of interest, Big and Little. Unfortunately, the findstr command cannot perform
    a single search to find all records containing both words, but with some ingenuity,
    you can meld two findstr commands together to get the job done:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在*12Movies.txt*文件中，只有一个电影标题包含了两个特定的词，Big和Little。不幸的是，findstr命令无法通过单次搜索同时找到包含这两个词的所有记录，但凭借一些巧妙的技巧，你可以将两个findstr命令结合起来完成任务：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This pipes the output of one findstr command—via the pipe character—to another
    findstr command (another application of the piping technique introduced in [Chapter
    12](chapter12.xhtml)). The first findstr command performs a case-insensitive search
    for the word big using the *12Movies.txt* file as its input. As you have seen
    by now, this command by itself writes seven titles to stdout.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过管道字符将一个findstr命令的输出传递给另一个findstr命令（这是在[第12章](chapter12.xhtml)中介绍的管道技术的另一个应用）。第一个findstr命令使用*12Movies.txt*文件作为输入，执行不区分大小写的“big”字搜索。正如你现在已经看到的，这个命令本身会将七个标题写入标准输出。
- en: 'But this isn’t a simple command. The interpreter writes the output, those seven
    records, to an unnamed temporary file and pipes, or feeds, it into the second
    findstr command, which is doing a case-insensitive search for the word little.
    Notice that I’m not defining an input file in the second command. It doesn’t need
    one, because its input is the output from the first findstr command. As the following
    output shows, of the seven titles that contain the word big, only one also contains
    the word little:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是一个简单的命令。解释器将输出（那七条记录）写入一个无名的临时文件，并将其通过管道传递到第二个findstr命令，该命令执行不区分大小写的“小”字搜索。请注意，在第二个命令中我没有定义输入文件。它不需要，因为它的输入是第一个findstr命令的输出。如下所示的输出表明，在包含“big”这个词的七个标题中，只有一个也包含了“little”这个词：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The upshot is a search that returns only records containing both strings.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是一个只返回包含两个字符串的记录的搜索。
- en: 'The intermediate file is lost, but if you desire an audit trail of what transpired,
    you can redirect the output into a file. Then you can pipe a type command of that
    file into the second findstr command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 中间文件丢失了，但如果你希望保留事件的审计轨迹，可以将输出重定向到一个文件中。然后你可以将该文件的类型命令通过管道传递到第二个findstr命令：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The two commands find the same title, but now *BigMovies.txt* contains the seven
    records found with the first search string.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令找到了相同的标题，但现在*BigMovies.txt*包含了第一次搜索字符串找到的七条记录。
- en: 'You can use this technique with any number of search strings. The following
    command again finds the one title, because it contains all four of the search
    strings, even if the third word is only a portion of a word in the title:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这种技术与任意数量的搜索字符串。以下命令再次找到唯一的标题，因为它包含了所有四个搜索字符串，即使第三个词只是标题中一个单词的一部分：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The trickiest part of this technique is making it readable. In this example,
    I’ve lined up all of the search strings, other than the first, by continuing the
    command on multiple lines with the trailing carets.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术最难的部分是使其可读。在这个例子中，我将除了第一个之外的所有搜索字符串通过在多行上继续命令并使用尾部的插入符号来排列。
- en: Searching Multiple Files
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索多个文件
- en: 'Up to this point, I’ve performed the findstr command using a single input file,
    but you can search any number of files with a single invocation. The command accepts
    multiple files to search as additional arguments, and it also accepts file masks.
    The following command is looking for the miss text, regardless of the case, in
    the file we’ve been using and in any file that satisfies either of the two file
    masks:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经使用单一的输入文件执行了findstr命令，但你可以通过一次调用搜索多个文件。该命令接受多个文件作为额外的参数，并且也支持文件掩码。以下命令将在我们一直使用的文件中以及满足两个文件掩码之一的任何文件中查找不区分大小写的miss文本：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This example raises an issue of concern about the output because prior invocations
    have simply written each record found to stdout. That worked great when searching
    a single file, but when searching multiple files, this output would leave you
    no way of knowing the file of origin for each output record. The interpreter smartly
    detects the difference and outputs the path and filename with the record found:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子引发了一个关于输出的问题，因为之前的调用只是将每个找到的记录写入标准输出。当搜索单一文件时，这种方法很好用，但当搜索多个文件时，这样的输出会让你无法知道每条输出记录的来源文件。解释器聪明地检测到这种差异，并在找到的记录中输出路径和文件名：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The command found *Little Miss Sunshine* in the *12Movies.txt* file as expected,
    and it also found the text in two records belonging to a file satisfying the trailing
    file mask, resulting in the last two lines of the output. The formatting leaves
    much to be desired. It’s hard to see where the filename ends and the record starts
    despite the colon delimiter. When writing the output to the console, the /A option
    highlights the path and filename to a color scheme of your choosing, but that
    obviously does nothing when you redirect the output to a file or pipe it to another
    command.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 命令如预期一样在 *12Movies.txt* 文件中找到了 *Little Miss Sunshine*，它还在两个符合尾部文件掩码的文件的记录中找到了该文本，从而得到了输出的最后两行。格式化效果不尽如人意。尽管有冒号分隔符，但很难看清文件名的结尾和记录的开始。当将输出写入控制台时，/A
    选项会以你选择的颜色方案突出显示路径和文件名，但当你将输出重定向到文件或管道到另一个命令时，这显然不会有任何作用。
- en: The colon itself is an unfortunate choice for the delimiter because it’s often
    part of the path after the drive letter, as it is in this instance. If you want
    to parse this data, you could use a findstr command as input to a for /F command
    and delimit the output on the colon. But given this output, the path and filename
    would span the first two tokens with the actual record in the third. A delimiter
    that can’t be in a path or filename, such as a pipe, would’ve been a better idea,
    but you can still parse this with a little extra work.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号作为分隔符是一个不太理想的选择，因为它通常是驱动器字母后路径的一部分，就像在这个实例中一样。如果你想解析这些数据，可以将 findstr 命令的输出作为输入传递给
    for /F 命令，并以冒号为分隔符。但鉴于此输出，路径和文件名会跨越前两个标记，实际记录位于第三个标记。一个不能出现在路径或文件名中的分隔符，例如管道符，会是一个更好的选择，但你仍然可以通过稍作额外工作来解析这些数据。
- en: 'The /S option expands the search to include subdirectories. I often use it
    with wildcards to search all files in a directory tree or all files of a certain
    extension in a directory tree, but in the following example, I’m using an explicit
    filename:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: /S 选项将搜索范围扩展到包括子目录。我经常与通配符一起使用它来搜索目录树中的所有文件或目录树中某种扩展名的所有文件，但在下面的示例中，我使用了一个显式的文件名：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The interpreter searches *C:\Batch\* and all of its subfolders for files named
    *12Movies.txt*. Then it searches each file found for records containing the search
    string.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器在 *C:\Batch\* 及其所有子文件夹中搜索名为 *12Movies.txt* 的文件。然后，它会在每个找到的文件中搜索包含搜索字符串的记录。
- en: 'Also, notice that I reintroduced the /N option mentioned previously. The output
    now contains the path and filename, the line number (delimited on either side
    with a colon), and the full record containing the search string:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我重新引入了之前提到的 /N 选项。现在输出包含路径和文件名、行号（两侧用冒号分隔），以及包含搜索字符串的完整记录：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Two files in two directories have the same name, but the result of this command
    shows that their contents are quite different.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 两个目录中的两个文件有相同的名称，但该命令的结果表明它们的内容截然不同。
- en: WARNING
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '*When the findstr command doesn’t find any files that fit a file mask, it writes
    an error message to stderr saying it Cannot open the specific mask. If you have
    redirected both stdout and stderr to a trace file, the command intermingles the
    message with the desired output. If a mask might not be valid, suppressing stderr
    with the 2> nul syntax anticipates the possibility of the batveat and cleans up
    the output:*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*当 findstr 命令未找到符合文件掩码的文件时，它会向 stderr 输出错误信息，说明无法打开特定掩码。如果你已将 stdout 和 stderr
    都重定向到跟踪文件中，命令会将错误信息与期望的输出混合。如果掩码可能无效，使用 2> nul 语法抑制 stderr 预期了 batveat 的可能性，并清理了输出：*'
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*The interpreter returns any records it finds in the valid file, but it sends
    the error message concerning the nonexistent directory to the nul file. This technique
    even works inside a routine or bat file with its stderr already redirected.*'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*解释器返回它在有效文件中找到的所有记录，但它会将关于不存在目录的错误信息发送到 nul 文件中。此技巧甚至适用于已将 stderr 重定向的例程或
    bat 文件中。*'
- en: Auxiliary Search Files
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 辅助搜索文件
- en: When your searches start to get more complex, you can more easily manage them
    with two auxiliary files, one that contains a list of search strings and another
    that contains a list of files to search.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的搜索变得更加复杂时，可以通过两个辅助文件更容易地管理它们，一个包含搜索字符串列表，另一个包含要搜索的文件列表。
- en: File of Search Strings
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 搜索字符串文件
- en: 'I mentioned earlier how you can search for any of the strings in a list by
    encasing multiple space-delimited search strings in double quotes. That works
    great for a handful of strings, but when the list gets long enough to make a mess
    of the command, you can use the findstr command with a file containing the list
    of search strings. You define this file by entering it after the /G option, delimited
    by a colon. The following example performs case-sensitive searches for Little
    and four of its synonyms, and you can easily add many more:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，你可以通过将多个以空格分隔的搜索字符串括在双引号中来搜索列表中的任何字符串。这对于少数几个字符串非常有效，但当列表足够长，导致命令变得杂乱时，你可以使用findstr命令并通过一个包含搜索字符串列表的文件来执行。你可以通过在/G选项后输入文件名来定义此文件，文件名与选项之间用冒号分隔。以下示例执行区分大小写的搜索，查找“小”和它的四个同义词，你可以很容易地添加更多：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: I’m building the temporary file with hardcoded strings, but they could easily
    be variables or even come from user input, and because it’s a temporary file,
    I’m deleting it when I’m done with it. The output consists of all records containing
    at least one of these five strings, which in this case includes the six titles
    containing Little, plus *The Big Short*, with nothing found for the other three
    search strings.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在构建一个包含硬编码字符串的临时文件，但它们可以很容易地是变量，甚至可以来自用户输入，而且因为这是一个临时文件，我在完成后会将其删除。输出结果包含所有至少包含其中一个这五个字符串的记录，在这个例子中包括六个包含“小”的标题，再加上*《大空头》*，而其他三个搜索字符串没有找到任何内容。
- en: This technique is also helpful when the search criteria changes from execution
    to execution. You can generate a file dynamically in the code, or even update
    it manually, and you can run the same code with differing results.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在搜索标准每次执行时都可能变化时特别有用。你可以在代码中动态生成一个文件，甚至手动更新它，然后可以运行相同的代码并得到不同的结果。
- en: File of Files to Search
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 待搜索的文件列表
- en: 'Taking this a step further, I’ll use the file just created containing the list
    of the search strings in tandem with another file containing the list of files
    to be searched. This *file of files (FOF)* is defined by the findstr command with
    the /F option. Similar to the /G option, the file comes after the option, delimited
    by a colon:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，我将使用刚刚创建的文件，里面包含搜索字符串的列表，并与另一个包含待搜索文件列表的文件一起使用。这个*文件列表（FOF）*是通过findstr命令和/F选项来定义的。类似于/G选项，文件在选项之后，使用冒号分隔：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Oddly, you can use the /F option only when using the /G option.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，只有在使用/G选项时，才能使用/F选项。
- en: If the list of files to search will be known only at the time of execution,
    you can build this FOF dynamically at runtime. This technique is also useful when
    you can’t easily define a set of files with a file mask. For instance, these options
    are ideal if you plan to search one of multiple sets of files, perhaps production
    or test sets of files partially named with a datestamp. You can also create the
    file of search strings with data entered by the user, perhaps a list of client
    names. If, however, the list of files to search is more consistent, you can use
    a static file instead.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要搜索的文件列表只有在执行时才知道，你可以在运行时动态构建这个FOF文件。当你无法轻松定义一个文件掩码时，这种技术也非常有用。例如，如果你计划搜索多个文件集（可能是生产文件集或测试文件集，其中部分文件名带有日期戳），这些选项是理想的选择。你还可以使用用户输入的数据来创建搜索字符串文件，可能是一个客户名称的列表。然而，如果待搜索的文件列表比较固定，你也可以使用一个静态文件。
- en: Searching a String
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索字符串
- en: Most compiled languages include a method that returns a boolean indicating whether
    a string is contained in part or in whole inside another string, because the need
    arises often in very disparate situations. In Batch, you can search a variable
    holding a path for a specific node or server name, or you might examine the path
    variable to see whether it holds a particular directory. You can even use this
    technique to validate user input, verifying that the response contains at least
    one word on a list.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编译语言都包含一种方法，返回一个布尔值，指示一个字符串是否在另一个字符串中部分或完全包含，因为这种需求在各种不同的情况下经常出现。在批处理文件中，你可以搜索包含路径的变量，以查找特定的节点或服务器名称，或者检查路径变量，看看它是否包含某个特定的目录。你甚至可以使用这种技术来验证用户输入，确认响应中至少包含列表中的一个单词。
- en: There are two very different methods of finding out if a string contains another
    string. The makers of Batch designed the findstr command to search files, but
    the first method manipulates it to search a string. The second method is based
    on the text replacement syntax from [Chapter 5](chapter5.xhtml), and they each
    have significant advantages over the other.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 查找一个字符串是否包含另一个字符串有两种非常不同的方法。Batch的开发者设计了findstr命令用于搜索文件，但第一种方法将其调整为搜索字符串。第二种方法基于[第五章](chapter5.xhtml)中的文本替换语法，每种方法都有其显著的优势。
- en: '**The **findstr** Method**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**findstr 方法**'
- en: 'Finding love can be difficult, but with the findstr command, finding the love
    string requires only a few lines of code. For this exercise, I’ll set the aString
    variable to one of two similar text strings giving advice to anyone planning a
    winter trip to one of two neighboring countries on the Adriatic Sea:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找爱情可能很困难，但使用findstr命令，寻找“love”字符串只需要几行代码。在这个练习中，我将aString变量设置为两个相似的文本字符串之一，这些字符串是给计划前往亚得里亚海两个邻国的冬季旅行者的建议：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I’ll step through a couple of upcoming code listings twice, with the variable
    set to each of these strings to demonstrate very different behaviors.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过接下来的几个代码示例进行两次演示，变量分别设置为这些字符串，以展示完全不同的行为。
- en: 'Can you find love in either string? The findstr command can:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你能在这两个字符串中找到“love”吗？findstr命令可以：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To search aString for the love text, I employ the same piping technique used
    earlier, with the only difference being that instead of piping a multirecord file
    to the findstr command via a type command, I’m piping a variable via an echo command.
    In essence, I’m treating the contents of the variable as a single-record input
    file to the findstr command. The end result is that the command searches the string
    for the text.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要在aString中搜索“love”文本，我使用了之前介绍的管道技术，唯一的区别是，我不是通过type命令将一个多记录的文件管道传输到findstr命令，而是通过echo命令将一个变量传输。实际上，我将变量的内容当作一个单记录的输入文件传递给findstr命令。最终的结果是，命令在字符串中搜索文本。
- en: Remember that the findstr command sets errorlevel to 0 when it finds the search
    string; otherwise, 1 is the value. If it’s 0, the code sets the bLove boolean
    to true; if not, the result is false.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当findstr命令找到搜索字符串时，会将errorlevel设置为0；否则，值为1。如果是0，代码将bLove布尔值设置为true；如果不是，结果为false。
- en: First envision this logic with aString set to the Croatian string. The love
    text isn’t in the string, so the command returns 1, and we set the boolean to
    false. Now do the same with the string set to the Slovenian text. The love text
    is embedded in three different words in the short string—Bring g**love**s and
    a pul**love**r to S**love**nia. One or more matches sets errorlevel to 0, so we
    set the boolean to true.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，设想这个逻辑：aString设置为克罗地亚的字符串。该字符串中没有“love”文本，所以命令返回1，我们将布尔值设置为false。现在，使用斯洛文尼亚的字符串进行相同的操作。该字符串中的“love”文本嵌入在三个不同的单词中——Bring
    g**love**s 和 a pul**love**r 到 S**love**nia。一个或多个匹配项将errorlevel设置为0，因此我们将布尔值设置为true。
- en: 'Also notice how easily we can convert this to a case-insensitive search:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，我们如何轻松地将其转换为不区分大小写的搜索：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Much of the flexibility present when searching a file is still available when
    searching a string. The options for targeting the beginning or ending of the string,
    negating the logic, and others work perfectly well in this context.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索文件时所具有的灵活性，在搜索字符串时仍然适用。可以针对字符串的开头或结尾、否定逻辑等进行操作，这些选项在这种情况下都能完美工作。
- en: '**The Text Replacement Method**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本替换方法**'
- en: 'The idea behind the text replacement method is as straightforward as its execution.
    The technique compares a resolved variable to itself with the search string removed.
    If they differ, we’ve found the search string; if they’re equal, we haven’t found
    the text. The following code uses this method to determine whether a string contains
    another string, in this case love, setting the same boolean from the prior example
    to true or false:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 文本替换方法背后的思想与其执行方式一样直接。该技术将已解析的变量与去除搜索字符串后的变量进行比较。如果它们不同，则找到了搜索字符串；如果它们相同，则没有找到文本。以下代码使用此方法来确定一个字符串是否包含另一个字符串，在这个例子中是“love”，并将前一个示例中的布尔值设置为true或false：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The left side of the inequality is pedestrian by now, a resolved variable in
    double quotes. The if command compares it to "%aString:love=%", the same resolved
    variable, but with all instances of the love text replaced with null; notice that
    nothing comes between the equal sign and the terminating percent sign. The upshot
    is that if aString contains at least one instance of the love string, these two
    values differ, and we set the bLove boolean to true; if the search string isn’t
    inside the string we’re searching, the two values are identical, and we set bLove
    to false.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不等式的左侧现在已经很基础了，已经是一个用双引号括起来的解析过的变量。if 命令将其与 "%aString:love=%" 进行比较，这是同样解析过的变量，但其中所有的
    love 字符串都被替换为空值；注意，在等号和终止的百分号之间没有任何内容。结果是，如果 aString 包含至少一个 love 字符串的实例，这两个值就会不同，我们将
    bLove 布尔值设置为 true；如果搜索字符串不在我们要搜索的字符串内，那么这两个值是相同的，我们将 bLove 设置为 false。
- en: 'Let’s execute this code with both possible values of aString. Assuming that
    it contains the Croatian text, the two values are identical because the love string
    isn’t to be found, and we set bLove to false. However, the text replacement syntax
    alters the Slovenian text by removing each of the three instances of the love
    string, resulting in this mess on the right side of the inequality: "Bring gs
    and a pulr to Snia." This clearly doesn’t equal the original text, so we set bLove
    to the value of true.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 aString 的两种可能值来执行这段代码。假设它包含克罗地亚文本，那么这两个值是相同的，因为没有找到 love 字符串，我们将 bLove
    设置为 false。然而，文本替换语法通过删除 love 字符串的三个实例来改变斯洛文尼亚文本，结果是这样的混乱： "Bring gs and a pulr
    to Snia." 显然，这不等于原始文本，因此我们将 bLove 设置为 true。
- en: 'Delayed expansion makes this technique more generic, allowing you to use variables
    for both the search string and the string to search:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟扩展使得这一技术更具通用性，允许你使用变量来表示搜索字符串和待搜索的字符串：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now the search string and the string to search are variables, allowing you to
    determine both in the Batch code prior to performing this search.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，搜索字符串和待搜索字符串是变量，这使你可以在执行搜索之前，在批处理代码中确定这两个值。
- en: When searching a string, both methods have a definitive place in the Batch universe.
    The biggest advantage of the findstr method is its flexibility, primarily its
    ability to perform case-sensitive searches, and you can use those options discussed
    earlier to easily customize any search. In contrast, the text replacement method
    is intrinsically case-insensitive because you can’t easily change the fact that
    the interpreter ignores the case of the text being changed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索字符串时，这两种方法在批处理的应用中各有其明确的作用。findstr 方法的最大优势是其灵活性，主要体现在它能够执行区分大小写的搜索，并且你可以使用前面讨论过的选项来轻松定制任何搜索。相比之下，文本替换方法本质上是大小写不敏感的，因为你无法轻易改变解释器忽略被更改文本的大小写这一事实。
- en: The text replacement method has advantages of its own. First, I consider it
    a bit simpler to use. Neither method is complex, but an if command, even with
    delayed expansion, is even more straightforward than an echo piped to a findstr.
    But by far its primary advantage is performance.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 文本替换方法也有它自身的优势。首先，我认为它稍微简单一些。两种方法都不复杂，但即使是带有延迟扩展的 if 命令也比通过 echo 管道传递给 findstr
    更加直接。不过，它最大的优势是性能。
- en: When you call the findstr command, you’re actually calling a program, *findstr.exe*,
    and any program invocation involves more overhead than a simple comparison of
    two variables. They both happen in a fraction of a second, but the text replacement
    method happens in a much smaller fraction. You wouldn’t notice the distinction
    performing a handful of searches, but I tested both methods extensively and found
    the text replacement method to be more than 200 times faster than the findstr
    method. There are many variables to consider when testing performance and my testing
    is far from definitive, but it’s safe to say that a major advantage of the text
    replacement method is that it’s much faster.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 findstr 命令时，实际上是在调用一个程序，*findstr.exe*，而任何程序调用都会比简单的两个变量比较涉及更多的开销。它们都会在瞬间完成，但文本替换方法发生的时间要小得多。你可能在进行少量搜索时无法察觉到这一点，但我对两种方法进行了广泛的测试，发现文本替换方法比
    findstr 方法快了超过 200 倍。测试性能时需要考虑许多变量，我的测试结果也远非最终结论，但可以肯定地说，文本替换方法的一个主要优势就是速度更快。
- en: In the final analysis, if your code is to perform a search repeatedly, say in
    a loop with possibly hundreds or even thousands of invocations, the replacement
    text method is the better choice. However, if efficiency isn’t a big concern or
    if you need a more complex search, even just a case-sensitive search, the findstr
    method is the better choice.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最终分析来看，如果你的代码需要重复执行搜索，例如在一个可能包含数百甚至数千次调用的循环中，替换文本方法是更好的选择。然而，如果效率不是一个大问题，或者你需要更复杂的搜索，即便是区分大小写的搜索，findstr
    方法则是更好的选择。
- en: Regular Expressions
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正则表达式
- en: 'Throughout this book I’ve more than hinted that Batch syntax can be esoteric
    and counterintuitive, even for someone who has coded in the language for many
    years. But somewhere out there someone of a contrarian bent is saying, “It isn’t
    that bad” or “Who among us hasn’t memorized all the options of the findstr command?”
    To this person I have two words: *regular expressions*, or *regex*.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我已经多次暗示，批处理语法可能是深奥且反直觉的，即使是对于那些已经编写多年代码的人来说。但在某个地方，某个持不同意见的人可能会说，“其实没那么糟”或者“我们中谁没有记住
    findstr 命令的所有选项？”对这个人，我只有两个词：“*正则表达式*”或“*regex*”。
- en: Regular expressions are not unique to Batch. Many languages and editors use
    them as an incredibly powerful tool for searches. With regex, you can search for
    numeric values, non-numeric values, and very intricate patterns and ranges of
    characters. The /B and /E options of the findstr command allow you to search for
    text at the beginning or ending of a record, but regex allows you to do both in
    one command—that is, search for one string at the beginning and another string
    at the end of a record. Let’s see regex in action with a couple of examples.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式不仅限于批处理（Batch）。许多编程语言和编辑器都将它们作为一个强大的搜索工具。通过正则表达式，你可以搜索数字值、非数字值以及非常复杂的字符模式和范围。findstr
    命令的 /B 和 /E 选项允许你搜索记录的开头或结尾的文本，但正则表达式让你在一个命令中同时完成这两项工作——即，搜索一个字符串位于记录开头，另一个字符串位于记录结尾。让我们通过一些例子来看看正则表达式的实际应用。
- en: Searching for Any Number
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 搜索任何数字
- en: 'The following findstr command using the regex option, denoted appropriately
    enough by /R, searches the *12Movies.txt* file to find all movies with at least
    one number in the title:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下使用正则表达式选项的 findstr 命令（通过 /R 标记）搜索 *12Movies.txt* 文件，查找标题中至少有一个数字的所有电影：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The regular expression [0-9] denotes all characters from 0 to 9, inclusive.
    Given the input file that we’ve been using throughout this chapter, the command
    returns just one title:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式 [0-9] 表示所有从 0 到 9 的字符，包括两端。根据我们在本章中使用的输入文件，命令返回一个标题：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we were working with a more complete list of movies, the titles returned
    might include *2001: A Space Odyssey*, *12 Angry Men*, *The 12th Man*, and *Ocean’s
    11*, but not the remake *Ocean’s Eleven*.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们处理的是一个更完整的电影列表，返回的标题可能包括 *2001: 太空漫游*、*十二怒汉*、*第12人* 和 *海洋的十一*，但不会包括重拍版的
    *海洋的十一*。'
- en: 'Regular expressions also are effective when searching a string as opposed to
    a file. Consider the following example that uses negated logic (/V) for a regex
    (/R) search:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式在搜索字符串而非文件时也非常有效。考虑以下示例，该示例使用否定逻辑（/V）与正则表达式（/R）进行搜索：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The code prompts the user for a movie title without a number anywhere in the
    title. If they enter a typical movie sequel or a title such as *28 Days Later*,
    this logic prompts them to enter a different title until they finally abide by
    the instructions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码提示用户输入一个标题中没有数字的电影标题。如果他们输入一个典型的续集电影标题或像 *28天后* 这样的标题，程序会提示他们输入不同的标题，直到他们最终按照指示操作。
- en: Searching with Complex Criteria
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用复杂条件进行搜索
- en: 'For a search that would be far more difficult without regex, consider the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有正则表达式的话，搜索会变得更加困难，可以考虑以下内容：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The leading caret isn’t an escape character in this context, but part of a string
    encased in double quotes. The caret is a regex indicator noting that the text
    after it is anchored to the beginning of the string, and the trailing dollar sign
    indicates the text before it is anchored to the end of the string. The 11 dots
    are wildcards, and the asterisk indicates that the wildcard just before it can
    be of any length, zero and up.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，前导插入符号（caret）不是转义字符，而是双引号包围的字符串的一部分。插入符号是一个正则表达式指示符，表示它后面的文本被固定在字符串的开头，而结尾的美元符号则表示它前面的文本被固定在字符串的结尾。11个点是通配符，星号表示它前面的通配符可以是任意长度，包括零。
- en: Putting this all together in a language that a non-regex-coder can understand,
    the search is looking for all records that start with The and end in Man, case-sensitive,
    with at least 10 characters, spaces included, between them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些内容整合在一个非正则表达式程序员能理解的语言中，搜索的目的是查找所有以“The”开头并以“Man”结尾的记录，区分大小写，且两者之间至少有10个字符（包括空格）。
- en: If you execute this command using a file containing a more complete list of
    movies, it might return the title *The Invisible Man* and even *The Amazing Spider-Man*.
    However, *The Amazing Spider-Man 2*, *The Music Man*, and the aforementioned *The
    12th Man* are out of the mix. (The first has a number appended to the title, and
    the other two are too short.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行这个命令，使用一个包含更完整电影列表的文件，它可能会返回标题为*隐形人*和*神奇蜘蛛侠*的记录。然而，*神奇蜘蛛侠2*、*音乐之人*和前述的*第12个人*却不会出现在结果中。（第一个标题附加了数字，而其他两个标题太短。）
- en: To perform this same search without regex, you could pipe one findstr command
    using the /B option into another findstr command using the /E option, but you’d
    still need to filter out all of the titles with fewer than 10 characters between
    the two words; it’s possible, but oh so messy. Many other difficult to nearly
    impossible searches are more than possible with regular expressions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用正则表达式，你可以将一个findstr命令（使用/B选项）通过管道传递给另一个findstr命令（使用/E选项），但你仍然需要过滤掉所有标题中两个词之间少于10个字符的记录；这虽然可行，但非常混乱。许多其他复杂到几乎不可能的搜索，使用正则表达式会变得更加容易。
- en: The topic of regular expressions commands its own book. I’ve demonstrated a
    couple of examples useful in Batch, but the next time one of your searches starts
    to get overly complex, look up the regex syntax for your problem in a book or
    on the internet, and give it a try with the findstr command and the /R option.
    Even experienced coders sometimes shy away from regex because of the complexity,
    but the power illustrated in these relatively simple examples is a window into
    other applications.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的主题足以写一本书。我展示了几个在Batch中有用的示例，但下次当你的搜索变得过于复杂时，查阅书籍或在网上查找你问题的正则表达式语法，尝试使用findstr命令和/R选项。即使是经验丰富的程序员，有时也会因正则表达式的复杂性而避开它，但在这些相对简单的示例中所展示的强大功能，实际上为其他应用打开了一扇窗。
- en: To make things a little more intriguing, Batch supports only a subset of the
    common regex functionality, so some regular expressions that work elsewhere don’t
    work in Batch. To state the obvious, rigorous testing is a must, with both positive
    and negative cases.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情更加有趣，Batch只支持常见正则表达式功能的子集，因此一些在其他地方有效的正则表达式在Batch中不起作用。显而易见，进行严格测试是必须的，既要考虑正向案例，也要考虑负向案例。
- en: Finding the Record Count of a File
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找文件的记录数
- en: 'Hoarding may be a vice, but nothing ever gets truly thrown out in Batch. The
    copy command is useful for creating an empty file even though the xcopy and robocopy
    commands have long since superseded it for all copy-related functionality. Likewise,
    the find command is pretty much useless when compared to the findstr command,
    so I’ll forgo the discussion of how you would use it to perform a search. It does
    have one useful feature, however: getting the record count of a file. Consider
    the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 收集或许是一种恶习，但在Batch中，什么都不会真正被丢弃。虽然xcopy和robocopy命令早已取代了copy命令处理所有与复制相关的功能，但copy命令仍然有用，可以用来创建一个空文件。同样，find命令与findstr命令相比几乎没有用处，因此我将跳过关于如何使用它进行搜索的讨论。然而，它确实有一个有用的功能：获取文件的记录数。请看以下内容：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This command performs a search for the null string between the double quotes,
    using *12Movies.txt* as its input. The /V option negates the search logic just
    as it does with the findstr command. It returns all records not containing the
    null string, which in effect returns every record in the file. The /C option gives
    the *count* of records returned, which is the number of records in the file since
    every record is returned, but what it writes to stdout is a bit more verbose than
    what we need:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令在双引号之间执行对空字符串的搜索，以*12Movies.txt*作为输入文件。/V选项与findstr命令一样，否定了搜索逻辑。它返回所有不包含空字符串的记录，这实际上返回了文件中的每一条记录。/C选项提供了返回的记录的*数量*，即文件中所有记录的数量，因为每一条记录都会返回，但它写入标准输出的内容比我们需要的要详细一些：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Conveniently, and also oddly, the find command behaves differently when we
    pipe the input file into it via the type command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 方便且奇怪的是，当我们通过type命令将输入文件传递给find命令时，它的行为有所不同：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This command succinctly writes the count, 12 in this instance, to stdout.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令简洁地将记录数（本例中为12）写入标准输出。
- en: 'To capture that value in a variable, we can execute the two piped commands
    as input to a for /F command, but we must escape the pipe before the find command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将该值捕获到变量中，我们可以执行两个通过管道传递的命令作为 `for /F` 命令的输入，但在 `find` 命令之前，我们必须转义管道符：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: (Notice the usebackq keyword and the back quotes encasing the input component
    of the for /F command, a combination that clearly shows command input.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: （注意使用 `usebackq` 关键字和反引号将 `for /F` 命令的输入组件包围，这种组合清晰地展示了命令输入。）
- en: This might seem like an awfully long walk to get a record count. Yes, with the
    use of escaping we are piping the output of one command (type) into a second command
    (find) and using its output as input to a third command (for) that has a code
    block containing a fourth command (set) that actually sets the variable. Phew.
    But it works and is elegant in its own special way.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能是获取记录数的漫长过程。是的，通过使用转义，我们将一个命令（`type`）的输出通过管道传递到第二个命令（`find`），并将其输出作为输入传递给第三个命令（`for`），这个命令包含一个包含第四个命令（`set`）的代码块，第四个命令实际上设置了变量。呼。尽管如此，它仍然有效，而且以其独特的方式非常优雅。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I discussed many facets of Batch text searches. You learned
    how to perform searches for many different types of strings, how to search each
    record of a file, and how to search for one string inside another string.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我讨论了批处理文本搜索的多个方面。你学会了如何执行多种类型的字符串搜索，如何搜索文件中的每一条记录，以及如何在一个字符串中查找另一个字符串。
- en: I also compared and contrasted two different techniques for performing text
    searches. The findstr method is extremely powerful and flexible, and the text
    replacement method is easy, efficient, and lightning fast. You now know when to
    use each. I introduced regular expressions and demonstrated how immensely useful
    they are in complex searches. You even learned how to determine how many records
    are in a file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我还比较和对比了两种不同的文本搜索技术。`findstr` 方法功能强大且灵活，而文本替换方法简单、高效且速度极快。你现在知道在何时使用每种方法。我介绍了正则表达式，并演示了它们在复杂搜索中的巨大实用性。你甚至学会了如何确定文件中有多少条记录。
- en: In the next chapter, I’ll introduce another fascinating and useful topic—code
    that writes code, specifically bat files that create other bat files.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将介绍另一个迷人且实用的话题——生成代码的代码，特别是创建其他 bat 文件的 bat 文件。
