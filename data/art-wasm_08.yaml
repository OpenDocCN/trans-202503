- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Working with the Canvas
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Canvas
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter, you’ll learn how to use WebAssembly with the HTML canvas element
    to create fast and efficient animations in a web application. We’ll manipulate
    pixel data inside the WebAssembly linear memory, and then transfer that pixel
    data in linear memory directly onto the HTML canvas. We’ll continue with our random
    collider objects example (Listing 6-16) by generating the objects in JavaScript
    linear memory and then using WebAssembly to move these objects, detect collisions,
    and render them. Because the number of possible collisions grows exponentially
    with the number of objects, this kind of graphical collision detection is an excellent
    test of WebAssembly’s capabilities. By the end of this chapter, we’ll have an
    application that can test collisions between thousands of different colliders
    dozens of times per second. In this case, our objects will be squares drawn in
    green if there is no collision and red if a collision occurs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用 WebAssembly 与 HTML canvas 元素配合，在 Web 应用程序中创建快速高效的动画。我们将操作 WebAssembly
    线性内存中的像素数据，然后将这些像素数据直接转移到 HTML canvas 上。我们将继续使用我们的随机碰撞体对象示例（列表 6-16），通过在 JavaScript
    线性内存中生成对象，然后使用 WebAssembly 来移动这些对象、检测碰撞并进行渲染。由于可能发生碰撞的数量随着对象数量的增加呈指数增长，这种图形碰撞检测是测试
    WebAssembly 功能的一个极好案例。到本章结束时，我们将有一个能够每秒测试数千个不同碰撞体之间碰撞的应用程序。在这个例子中，如果没有发生碰撞，我们的对象将绘制成绿色，如果发生碰撞，则绘制成红色。
- en: 'As discussed earlier, web browsers were originally designed for displaying
    simple online documents, meaning any changes to the position of any of the document’s
    elements frequently resulted in the entire page being rerendered. That is a performance
    nightmare for any application that requires high-frame-rate graphical effects
    (such as games). Since then browsers have evolved into sophisticated application-hosting
    environments, necessitating the development of a more sophisticated rendering
    model: the *canvas*. The canvas element was introduced in 2004 by Apple for its
    Safari web browser and adopted as a part of the HTML standard in 2006\. Within
    the bounds of the canvas element, web developers can render 2D images and animations
    with significantly better performance than could be done by manipulating the DOM,
    as had been done previously. Using the canvas with WebAssembly can help us render
    animations to the browser with lightning speed.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，网页浏览器最初是为展示简单的在线文档而设计的，这意味着对文档中任何元素位置的修改通常会导致整个页面被重新渲染。这对于任何需要高帧率图形效果的应用程序（如游戏）来说，都是一个性能噩梦。此后，浏览器已发展成复杂的应用托管环境，因此需要开发一种更为复杂的渲染模型：*canvas*。canvas
    元素由苹果公司在 2004 年为其 Safari 浏览器推出，并在 2006 年作为 HTML 标准的一部分被采纳。在 canvas 元素的范围内，Web
    开发人员可以渲染 2D 图像和动画，性能比之前通过操作 DOM 所能实现的要好得多。使用 canvas 与 WebAssembly 可以帮助我们以极快的速度将动画渲染到浏览器中。
- en: Rendering to the Canvas
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染到 Canvas
- en: Entire books have been written on the HTML canvas API, so we’ll only touch on
    a few of the features needed for this WebAssembly demonstration. As with the DOM,
    WebAssembly cannot interact directly with the canvas. Instead, we must render
    pixel data directly from linear memory onto the canvas element. That allows us
    to write a canvas application with minimal JavaScript code. Before writing the
    WebAssembly code, we’ll write the HTML and JavaScript portion. To see what the
    finished app looks like, browse to [https://wasmbook.com/collide.html](https://wasmbook.com/collide.html).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 HTML canvas API 已经写了整本书，因此我们这里只触及 WebAssembly 演示所需的一些特性。与 DOM 一样，WebAssembly
    不能直接与 canvas 交互。相反，我们必须将像素数据直接从线性内存渲染到 canvas 元素上。这使我们能够用最少的 JavaScript 代码编写 canvas
    应用程序。在编写 WebAssembly 代码之前，我们将先编写 HTML 和 JavaScript 部分。要查看完成后的应用程序效果，可以浏览 [https://wasmbook.com/collide.html](https://wasmbook.com/collide.html)。
- en: Defining the Canvas in HTML
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 HTML 中定义 Canvas
- en: As usual, we’ll break the HTML file into sections and examine it a piece at
    a time. This first piece defines the canvas, which is the area in the web page
    where animations are rendered. Create a file named *collide.html* and add the
    code in [Listing 8-1](#listing8-1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将把 HTML 文件分成几个部分，并逐个分析。这第一部分定义了 canvas，这是网页中渲染动画的区域。创建一个名为 *collide.html*
    的文件，并添加 [列表 8-1](#listing8-1) 中的代码。
- en: '**collide.html (part 1 of 5)**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.html（第 1 部分，共 5 部分）**'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 8-1: HTML to define the canvas'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-1：HTML 定义 canvas
- en: The element you need to pay attention to here is the `canvas` 1 element. We
    give the `canvas` element an `id` of `cnvs` 2 so that later we can use a call
    to `document.getElementById` to retrieve the canvas element. We set the `width`
    3 and `height` 4 to `512`, chosen because 512 is 2⁹ or hexadecimal 0x200\. This
    choice makes it easy to work with the width and height using binary logic, which
    can help improve the app’s performance if we design our code properly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要关注的元素是`canvas` 1元素。我们给`canvas`元素赋予`id`为`cnvs` 2，以便稍后使用`document.getElementById`来获取canvas元素。我们将`width`
    3和`height` 4设置为`512`，选择512是因为512是2⁹或者十六进制0x200。这个选择使得通过二进制逻辑处理宽度和高度更加方便，这有助于在我们合理设计代码的情况下提升应用程序的性能。
- en: Defining JavaScript Constants in HTML
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在HTML中定义JavaScript常量
- en: At the beginning of our JavaScript, we’ll add constant values for configuring
    some top level settings in the WebAssembly module. The values will be shared between
    the JavaScript and the WebAssembly. Defining these values inside the JavaScript
    makes it simpler to update the configuration. We begin the code with some canvas-related
    constants that set parameters for interaction between the WebAssembly and the
    HTML `canvas` element. We also have a cluster of constants related to the organization
    of the data in linear memory that define our base address, stride, and offset
    for the objects we’re rendering. In addition, we must define a new `ImageData`
    object that sets aside a section of the linear memory buffer as an object that
    the app can directly draw to the canvas. Add the code in [Listing 8-2](#listing8-2)
    to your HTML file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的JavaScript代码开头，我们将添加常量值，用于配置WebAssembly模块中的一些顶层设置。这些值将在JavaScript和WebAssembly之间共享。将这些值定义在JavaScript中可以更简便地更新配置。我们从一些与canvas相关的常量开始，这些常量设置了WebAssembly与HTML
    `canvas`元素之间交互的参数。我们还定义了一组常量，用于定义我们在线性内存中组织数据的基本地址、步长和偏移量，这些常量决定了我们正在渲染的对象。此外，我们必须定义一个新的`ImageData`对象，该对象将线性内存缓冲区的一部分划分为一个应用程序可以直接绘制到canvas的对象。将[清单8-2](#listing8-2)中的代码添加到你的HTML文件中。
- en: '**collide.html (part 2 of 5)**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.html（第2部分，共5部分）**'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 8-2: Configuring image data in JavaScript'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 清单8-2：在JavaScript中配置图像数据
- en: We have a single `cnvs_size` 1 constant that holds the height and width of the
    `canvas` element because they’re the same. We then have two constants that define
    hexadecimal color values. The first, `no_hit_color` 2, defines the color an object
    will be when it doesn’t collide with another object. The second, `hit_color`,
    defines the color an object will be when it collides with another object. The
    meaning of these hexadecimal numbers is covered in more detail in “Bitmap Image
    Data” on page 162\. Then we define the `pixel_count` 3, which we can get by squaring
    the `canvas_size` because we have a square canvas.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`cnvs_size` 1的常量，保存`canvas`元素的高度和宽度，因为它们是相同的。接下来，我们定义了两个常量，用于定义十六进制颜色值。第一个，`no_hit_color`
    2，定义了当对象没有与其他对象发生碰撞时的颜色。第二个，`hit_color`，定义了当对象与其他对象发生碰撞时的颜色。这些十六进制数字的含义在“位图图像数据”第162页中有更详细的说明。接着我们定义了`pixel_count`
    3，通过将`canvas_size`平方得到，因为我们有一个正方形的canvas。
- en: Next, we deal with the Canvas API interface, the *drawing context*, which allows
    JavaScript to interact with the `canvas`. There are a few options for working
    with the HTML `canvas`. We’ll work with the `"2d"` canvas context because it’s
    relatively simple. Here we create a `canvas` 4 element constant with a call to
    `document.getElementById` to retrieve a context from the HTML canvas. We then
    call the function `getContext` 5 on that `canvas` constant to create a constant
    containing the context interface, which we’ve named `ctx`. We’ll use this `ctx`
    object to render a bitmap generated in WebAssembly to the `canvas` element.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们处理Canvas API接口，即*绘图上下文*，它允许JavaScript与`canvas`进行交互。处理HTML `canvas`时有几种选择。我们将使用`"2d"`
    canvas上下文，因为它相对简单。在这里，我们通过调用`document.getElementById`来获取HTML canvas中的上下文，从而创建一个`canvas`
    4元素常量。然后，我们在该`canvas`常量上调用`getContext` 5函数，以创建一个包含上下文接口的常量，我们将其命名为`ctx`。我们将使用这个`ctx`对象将WebAssembly生成的位图渲染到`canvas`元素上。
- en: Following the canvas-related constants is a group of linear memory object-related
    constants. These constants begin with the `obj_start` 6 constant and follow the
    base, stride, and offset format we discussed in Chapter 6. The base address in
    `obj_start` must show an address that follows all of our pixel data at the beginning
    of linear memory. We set `obj_start` to `pixel_count * 4` because each pixel takes
    up four bytes of data, and the object data immediately follows a section of that
    size. In this area, we use some constants to define our stride size and the offsets
    for each of the object attributes. We define the linear memory 7 with an initial
    size of 80 pages, enough to fit all the objects and pixel data we require. Then
    we create an 8-bit and a 32-bit view of that data object. All the constants we’ve
    created so far must be passed into the WebAssembly module using the `importObject`
    8.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在与画布相关的常量之后，紧接着是一组与线性内存对象相关的常量。这些常量以`obj_start` 6常量开头，并遵循我们在第6章中讨论的基址、步长和偏移格式。`obj_start`中的基地址必须指示一个地址，该地址紧随我们线性内存开始处的所有像素数据之后。我们将`obj_start`设置为`pixel_count
    * 4`，因为每个像素占用四个字节的数据，且对象数据紧跟在这一大小的区域之后。在这个区域中，我们使用一些常量来定义步长大小和每个对象属性的偏移量。我们定义了初始大小为80页的线性内存7，足以容纳我们所需的所有对象和像素数据。然后，我们创建了该数据对象的8位和32位视图。到目前为止，我们创建的所有常量必须通过`importObject`
    8传入WebAssembly模块。
- en: Lastly, we create a new `ImageData` 9 object, which is a JavaScript interface
    that we can use to access the underlying pixel data in our canvas element. The
    `Memory` 7 object that we created in [Listing 8-2](#listing8-2) has an attribute
    called `buffer`, which is a typed array containing the data in linear memory.
    The `buffer`attribute is a data buffer that can represent the pixel data displayed
    on a canvas. To create a new `ImageData` object, the `memory.buffer` object must
    be passed into the `ImageData` object as a `Uint8ClampedArray` along with the
    width and height of the canvas.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个新的`ImageData` 9对象，这是一个JavaScript接口，我们可以通过它访问画布元素中底层的像素数据。我们在[清单 8-2](#listing8-2)中创建的`Memory`
    7对象有一个名为`buffer`的属性，这是一个包含线性内存中数据的类型化数组。`buffer`属性是一个数据缓冲区，可以表示画布上显示的像素数据。要创建一个新的`ImageData`对象，必须将`memory.buffer`对象作为`Uint8ClampedArray`传递给`ImageData`对象，同时传入画布的宽度和高度。
- en: Creating Random Objects
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建随机对象
- en: 'Next, we’ll create the random objects, similar to how we did so previously
    in the book. We continue to use random data because it allows us to focus on the
    WebAssembly rather than the data. However, WebAssembly doesn’t have a random number
    function, so creating our randomized objects inside JavaScript is much simpler.
    The objects have four attributes: an x- and y-coordinate (position), as well as
    an x and y velocity (motion). We use a 32-bit integer to represent the value of
    each of these attributes. [Listing 8-3](#listing8-3) shows the code that loops
    to create data for several objects represented by the `object_cnt` constant we
    defined earlier.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建随机对象，类似于我们在本书中之前所做的那样。我们继续使用随机数据，因为它使我们能够专注于WebAssembly，而不是数据本身。然而，WebAssembly没有随机数功能，因此在JavaScript中创建我们的随机对象要简单得多。对象有四个属性：x
    和 y 坐标（位置），以及 x 和 y 速度（运动）。我们使用32位整数来表示这些属性的值。[清单 8-3](#listing8-3)展示了创建多个对象数据的循环代码，这些对象由我们之前定义的`object_cnt`常量表示。
- en: '**collide.html (part 3 of 5)**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.html（第 3 部分，共 5 部分）**'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 8-3: Setting linear memory data'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-3：设置线性内存数据
- en: The code in this loop accesses the data in linear memory through the 32-bit
    integer view in `mem_i32`. Because the loop is working with 32-bit numbers, we
    create a 32-bit version of `stride_bytes`, which we call `stride_i32` 1. We set
    it to the value `stride_bytes / 4`, because there are four bytes per `i32`. The
    `for` loop loops until index `i` is equal to the number of objects set in `obj_count`
    multiplied by the number of 32-bit integers in our stride defined by `stride_i32`
    2. This creates the circle data structure in linear memory.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该循环中的代码通过`mem_i32`中的32位整数视图访问线性内存中的数据。由于循环使用的是32位数字，我们创建了一个32位版本的`stride_bytes`，我们称之为`stride_i32`
    1。我们将其设置为`stride_bytes / 4`，因为每个`i32`占用四个字节。`for`循环会一直执行，直到索引`i`等于`obj_count`中设置的对象数量乘以由`stride_i32`
    2定义的步长中的32位整数数量。这就在线性内存中创建了圆形数据结构。
- en: Inside the loop, we set four 32-bit integers to random numbers that will represent
    the position and velocity of each object. First, we set the position attributes.
    We get a random number between 0 and the canvas width 3 held in `cnvs_size` and
    store it in the location of the `x` position attribute 4 in linear memory. Next,
    a random number between 0 and the canvas height 5 is generated and stored in the
    `y` attribute 6 location in linear memory. Then we set the velocity attributes
    by generating a number between –2 and 2 7, storing it in the location of the `x`
    velocity 8 attribute, and do the same 9 for the `y` velocity a attribute.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，我们将四个32位整数设置为随机数，这些随机数将表示每个物体的位置和速度。首先，我们设置位置属性。我们从`cnvs_size`中获取一个介于0和画布宽度3之间的随机数，并将其存储在线性内存中`x`位置属性4的位置。接下来，生成一个介于0和画布高度5之间的随机数，并将其存储在线性内存中`y`属性6的位置。然后，我们通过生成一个介于-2和2之间的数字7来设置速度属性，将其存储在`x`速度8属性的位置，并对`y`速度a属性做同样的操作9。
- en: Bitmap Image Data
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位图图像数据
- en: 'We can render bitmap image data directly to the HTML `canvas` element using
    the `putImageData` function, passing in the `ImageData` object we defined earlier.
    The HTML canvas is a grid of pixels; each of which can be represented by three
    bytes with one byte dedicated to each of the three colors: red, green, and blue.
    In the bitmap format, a pixel is represented with a single 32-bit integer where
    each byte of the integer represents one of the colors. The fourth byte of the
    integer represents the *alpha value*,which isused for pixel opacity. When the
    alpha byte is 0, the pixel is fully transparent, and when it’s 255, it’s fully
    opaque. In WebAssembly linear memory, we’ll create an array of 32-bit integers
    that represents an array of pixel data. This type of array makes WebAssembly a
    very convenient tool for manipulating data to be rendered to the HTML canvas.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接将位图图像数据渲染到HTML `canvas`元素中，使用`putImageData`函数，传入我们之前定义的`ImageData`对象。HTML画布是一个像素网格；每个像素可以通过三个字节表示，其中每个字节代表一种颜色：红色、绿色和蓝色。在位图格式中，一个像素由一个32位整数表示，其中整数的每个字节表示一种颜色。整数的第四个字节表示*alpha值*，用于像素的不透明度。当alpha字节为0时，像素完全透明；当其值为255时，像素完全不透明。在WebAssembly线性内存中，我们将创建一个32位整数数组，表示像素数据的数组。这种类型的数组使WebAssembly成为操作渲染到HTML画布的非常便捷的工具。
- en: In the `script` tag, we’ll store the WebAssembly module function that generates
    this bitmap data in the variable `animation_wasm`. We also need a JavaScript function
    that calls that WebAssembly function. Then we call `ctx.putImageData` to render
    that image data to the `canvas` element. [Listing 8-4](#listing8-4) contains the
    next chunk of JavaScript code you need to add to the HTML file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`script`标签中，我们将存储生成该位图数据的WebAssembly模块函数，并将其保存在变量`animation_wasm`中。我们还需要一个JavaScript函数来调用该WebAssembly函数。然后，我们调用`ctx.putImageData`将图像数据渲染到`canvas`元素中。[Listing
    8-4](#listing8-4)包含了你需要添加到HTML文件中的下一段JavaScript代码。
- en: '**collide.html (part 4 of 5)**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.html（第4部分，共5部分）**'
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 8-4: The JavaScript `animate` function renders the animation frame.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-4：JavaScript `animate`函数渲染动画帧。
- en: The `animation_wasm` 1 variable holds the WebAssembly function that generates
    the image data. The `animate` 2 function that follows calls the WebAssembly module’s
    `animation_wasm` 3 function, which generates the `image_data` for the next frame
    in the animation. The `image_data` object is then passed into a call to `ctx.putImageData`
    4, which renders the image generated by WebAssembly in the `canvas` element. The
    last function, `requestAnimationFrame` 5, is a little more complicated, so we’ll
    examine it in more detail in the next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`animation_wasm` 1 变量保存生成图像数据的WebAssembly函数。接下来的`animate` 2函数调用WebAssembly模块的`animation_wasm`
    3函数，该函数生成动画的下一帧`image_data`。然后将`image_data`对象传递到对`ctx.putImageData` 4的调用中，该函数将WebAssembly生成的图像渲染到`canvas`元素中。最后一个函数`requestAnimationFrame`
    5稍微复杂一些，我们将在下一节更详细地探讨它。'
- en: The requestAnimationFrame Function
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: requestAnimationFrame函数
- en: 'Animation is an optical illusion: a series of still images displayed in rapid
    sequence tricks the eye into believing there is motion. Every television screen,
    computer monitor, and film you’ve ever watched works this way. JavaScript provides
    the handy `requestAnimationFrame` function: when you call `requestAnimationFrame`,
    the function passed to `requestAnimationFrame` is called the next time a frame
    is rendered. To `requestAnimationFrame`, we pass the function we want to call
    the next time our computer is ready to render a frame of animation.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是一种视觉错觉：一系列静止图像快速显示使眼睛误以为有运动发生。你曾观看过的每台电视机、电脑显示器和电影都是这样运作的。JavaScript 提供了方便的`requestAnimationFrame`函数：当你调用`requestAnimationFrame`时，传递给`requestAnimationFrame`的函数会在下一帧渲染时调用。为了`requestAnimationFrame`，我们传递了我们希望在计算机准备渲染动画帧时调用的函数。
- en: We call this function at the end of the JavaScript, passing in the `animate`
    function that we defined in [Listing 8-4](#listing8-4). We call `requestAnimationFrame`
    a second time from the end of the `animate` function to register the function
    as a callback on the frame render that follows. That second call must be made
    because the `requestAnimationFrame` function doesn’t register a function to be
    called every time a frame is rendered; it’s only registered for the next frame
    render. The `animate` function needs to call the WebAssembly module, which performs
    the collision detection and object move computations. WebAssembly calculates the
    image data placed on the canvas. However, it’s unable to render that data to the
    canvas directly. That’s why we must call `putImageData` from our JavaScript animation
    function to render the pixel data to the canvas. The call to `putImageData` moves
    the chunk of linear memory we set aside to represent pixel data over to the `canvas`
    element.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在JavaScript的结尾调用此函数，并传递了我们在[第8-4节](#listing8-4)中定义的`animate`函数。我们从`animate`函数的末尾第二次调用`requestAnimationFrame`，以在后续的帧渲染中将该函数注册为回调函数。必须进行第二次调用，因为`requestAnimationFrame`函数不会注册一个函数以在每次帧渲染时调用；它只在下一帧渲染时注册。`animate`函数需要调用WebAssembly模块，该模块执行碰撞检测和对象移动计算。WebAssembly计算放置在画布上的图像数据。然而，它无法直接将该数据渲染到画布上。这就是为什么我们必须从我们的JavaScript动画函数中调用`putImageData`以将像素数据渲染到画布上。对`putImageData`的调用将我们设置的线性内存块移动到`canvas`元素上表示像素数据的区域。
- en: The first time we call `requestAnimationFrame` is immediately after instantiating
    the WebAssembly module in the last line of the code. [Listing 8-5](#listing8-5)
    shows the final portion of the HTML code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`requestAnimationFrame`是在代码的最后一行实例化WebAssembly模块之后立即进行的。[第8-5节](#listing8-5)显示了HTML代码的最后部分。
- en: '**collide.html (part 5 of 5)**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.html (第5部分/共5部分)**'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 8-5: Instantiate the WebAssembly module and call `requestAnimationFrame`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第8-5节：实例化WebAssembly模块并调用`requestAnimationFrame`。
- en: Inside the asynchronous IIFE we begin by calling the `instantiateStreaming`
    1 function. We set the `animation_wasm` 2 variable we defined in [Listing 8-4](#listing8-4)
    to an exported function in the WebAssembly module named `main`. Recall that we
    called the `animation_wasm` function from the `animate` function. Finally, a call
    to `requestAnimationFrame` 3 passes in the `animate` 4 function defined earlier.
    Because `animate` also calls `requestAnimationFrame` on itself, the browser calls
    `animate` every time it refreshes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步IIFE内部，我们首先调用`instantiateStreaming` 1函数。我们将在[第8-4节](#listing8-4)中定义的`animation_wasm`
    2变量设置为WebAssembly模块中名为`main`的导出函数。回想一下，我们从`animate`函数中调用了`animation_wasm`函数。最后，调用`requestAnimationFrame`
    3传递了之前定义的`animate` 4函数。因为`animate`也在自身上调用`requestAnimationFrame`，所以浏览器每次刷新时都会调用`animate`。
- en: The WAT Module
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WAT模块
- en: Now that we’ve defined the HTML, we need to write the WebAssembly module in
    WAT, which will manage the object movement, collision detection, and bitmap image
    data. Create a file named *collide.wat*. We’ll write the collision code and canvas
    rendering code as straightforwardly as possible. To accomplish this, we’ll write
    it with many functions, some of which might result in less than ideal performance.
    In the next chapter, we’ll revisit this code in an attempt to optimize it. But
    in this chapter, we’ll focus on clarity and simplicity over high performance.
    The module will define global variables that import values from the JavaScript.
    We’ll need to define a series of functions that clear the canvas, calculate the
    absolute value of an integer, set individual pixels, and draw the collider objects.
    Then we’ll need to define the `main` function that will use a double loop to move
    each collider object and test to see whether it collides with another object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经定义了 HTML，需要在 WAT 中编写 WebAssembly 模块，该模块将管理对象移动、碰撞检测和位图图像数据。创建名为 *collide.wat*
    的文件。我们将尽可能简单地编写碰撞代码和画布渲染代码。为此，我们将编写多个函数，其中一些可能导致性能不佳。在下一章中，我们将尝试优化此代码。但在本章中，我们将专注于清晰和简单，而不是高性能。该模块将定义从
    JavaScript 导入值的全局变量。我们需要定义一系列函数，用于清除画布、计算整数的绝对值、设置单个像素以及绘制碰撞器对象。然后，我们需要定义 `main`
    函数，该函数将使用双循环移动每个碰撞器对象，并测试其是否与另一个对象发生碰撞。
- en: Imported Values
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入的数值
- en: The beginning of the module, as shown in [Listing 8-6](#listing8-6), imports
    the constants passed into the module through the `importObject` we defined in
    our JavaScript. These values include our memory buffer, the canvas size, object
    colors, and the base, offset, and stride values we can use to access objects in
    linear memory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的开头，如 [Listing 8-6](#listing8-6) 中所示，通过我们在 JavaScript 中定义的 `importObject`
    导入了传递给模块的常量。这些值包括我们的内存缓冲区、画布大小、对象颜色以及我们可以用来访问线性内存中对象的基础、偏移和步进值。
- en: '**collide.wat (part 1 of 12)**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.wat (第 1 部分，共 12 部分)**'
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 8-6: Declaring the imported global variables and memory buffer'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-6: 声明导入的全局变量和内存缓冲区'
- en: We first import the global variable `$cnvs_size` 1, defined as `512` in the
    JavaScript, which represents the width and height of the canvas. Next are two
    color values, `$no_hit_color` 2, representing the 32-bit color of a noncolliding
    object, and `$hit_color`, representing the color of a colliding object. Remember
    that we defined them as the hexadecimal value for green and red.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入全局变量 `$cnvs_size` 1，它在 JavaScript 中定义为 `512`，表示画布的宽度和高度。接下来是两个颜色值，`$no_hit_color`
    2，表示非碰撞对象的32位颜色，以及 `$hit_color`，表示碰撞对象的颜色。请记住，我们将它们定义为绿色和红色的十六进制值。
- en: Then we have an `$obj_start` 3 variable that contains the base location for
    the object data. The `$obj_size` 4 variable is the width and height of the objects
    in pixels, which will be square. The `$obj_cnt` 5 variable contains the number
    of objects the application will render and checks for collisions. Next is the
    offset for the two coordinates, `$x_offset` 6 and `$y_offset`, and the two attributes
    for the velocity values 7, `$xv_offset` and `$yv_offset`. The final `import` 8
    in this code block imports the `memory` `buffer` that we defined in JavaScript.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个 `$obj_start` 3 变量，其中包含对象数据的基本位置。`$obj_size` 4 变量是对象的宽度和高度（像素），将是正方形。`$obj_cnt`
    5 变量包含应用程序将渲染并检查碰撞的对象数量。接下来是两个坐标的偏移量，`$x_offset` 6 和 `$y_offset`，以及速度值的两个属性 7，`$xv_offset`
    和 `$yv_offset`。此代码块中的最后一个 `import` 8 导入了我们在 JavaScript 中定义的 `memory` `buffer`。
- en: Clearing the Canvas
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清除画布
- en: Next, we’ll define a function that clears the entire bitmap image buffer. If
    the canvas isn’t cleared every time the frame is rendered, the old impression
    of each object will remain in memory and the objects will smear across the screen.
    The `$clear_canvas` function sets every color value to `0xff_00_00_00`, representing
    black with full opacity. [Listing 8-7](#listing8-7) shows the code for the `$clear_canvas`
    function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个函数，用于清除整个位图图像缓冲区。如果在每次渲染帧时不清除画布，则每个对象的旧印象将保留在内存中，并且对象将在屏幕上涂抹。`$clear_canvas`
    函数将每个颜色值设置为 `0xff_00_00_00`，表示黑色且完全不透明。[Listing 8-7](#listing8-7) 显示了 `$clear_canvas`
    函数的代码。
- en: '**collide.wat (part 2 of 12)**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.wat (第 2 部分，共 12 部分)**'
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 8-7: The `$clear_canvas` function definition'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-7: `$clear_canvas` 函数定义'
- en: The `$clear_canvas` function calculates the number of pixel bytes by squaring
    the canvas size (because we chose a square canvas) and then multiplying by `4`
    because four bytes are used for each pixel. Next, we store this value, which is
    the number of bytes dedicated to pixel memory, in the local variable `$pixel_bytes`
    1. The function then loops 2 over each pixel, storing a hexadecimal value `0xff_00_00_00`
    3, where all the pixel colors are `0` with `0xff` (full opacity) used for the
    alpha value. The function increments the index stored in `$i` by `4` 4 because
    four bytes are in an `i32` integer. The code checks whether the `$i` index is
    less than the number of pixel bytes 5 and if it is, branches back to the top of
    the `loop` 6, because if `$i` is less than the number of pixels, it means there
    are objects that need to be cleared.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`$clear_canvas` 函数通过将画布大小平方（因为我们选择了一个正方形画布）来计算像素字节数，然后再乘以 `4`，因为每个像素使用四个字节。接下来，我们将这个值存储在局部变量
    `$pixel_bytes` 中，这就是分配给像素内存的字节数。然后，函数遍历每个像素，存储一个十六进制值 `0xff_00_00_00`，其中所有像素颜色为
    `0`，而 `0xff`（完全不透明）用于 alpha 值。函数接着将存储在 `$i` 中的索引增加 `4`，因为每个 `i32` 整数占四个字节。代码检查
    `$i` 索引是否小于像素字节数，如果是，则跳回 `loop` 的顶部，因为如果 `$i` 小于像素数，意味着仍然有对象需要被清除。'
- en: Absolute Value Function
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绝对值函数
- en: In this app, we’ll use the box collision detection strategy, as opposed to the
    circle collision detection we used earlier in the book, because our objects are
    square. We’ll need to switch to the rectangle collision detection algorithm, which
    requires the code to find the absolute value of a signed integer. In [Listing
    8-8](#listing8-8), we’ll write a small `$abs` function that can take a signed
    integer and look to see whether the parameter passed in is negative, and if so,
    make it a positive number to give us that absolute value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们将使用盒子碰撞检测策略，而不是本书之前使用的圆形碰撞检测，因为我们的对象是正方形的。我们需要切换到矩形碰撞检测算法，这要求代码找到一个有符号整数的绝对值。在
    [清单 8-8](#listing8-8) 中，我们将编写一个小的 `$abs` 函数，它可以接受一个有符号整数，并查看传入的参数是否为负数，如果是，就将其转换为正数，以获得绝对值。
- en: '**collide.wat (part 3 of 12)**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.wat（第 3 部分，共 12 部分）**'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 8-8: The absolute value function `$abs`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-8：绝对值函数 `$abs`
- en: The `$abs` function first looks at the value passed in and checks whether the
    signed value of that integer is less than `0` 1. If it is less than `0` 2, the
    function subtracts 3 that number from 0, negating it and returning the positive
    number 4. If the number wasn’t negative, the function returns the original number
    5.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`$abs` 函数首先查看传入的值，并检查该整数的符号值是否小于 `0`。如果小于 `0`，函数就会将这个数减去 `0`，将其取反并返回正数。如果这个数不是负数，函数将返回原始数值。'
- en: Setting a Pixel Color
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置像素颜色
- en: To draw the object to the canvas, we need to be able to set a pixel’s color
    in linear memory given an x- and y-coordinate and the color value. That function
    will need a bounds check because we’re writing to an area of linear memory set
    aside to represent the area of the canvas. Without this check, if we try to write
    to a memory location that isn’t on the canvas, the function will be writing to
    an area of linear memory that we might be using for some other purpose.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将对象绘制到画布上，我们需要能够在给定 x 和 y 坐标以及颜色值的情况下，在线性内存中设置像素的颜色。这个函数需要进行边界检查，因为我们正在写入一块被分配出来的线性内存区域来表示画布的区域。如果没有这个检查，如果我们尝试写入一个不在画布上的内存位置，函数就会向我们可能用于其他用途的内存区域写入数据。
- en: The function tests coordinates against the bounds of the canvas and returns
    if those coordinates are out of bounds. This determines where, in linear memory,
    it needs to update the pixel data. Before we look at the code, let’s quickly examine
    how coordinates on the canvas translate into linear memory.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 函数会将坐标与画布的边界进行比较，如果这些坐标超出了边界，则返回。这决定了在何处（在线性内存中）需要更新像素数据。在查看代码之前，让我们快速了解一下画布上的坐标如何转换为线性内存。
- en: The canvas is a 2D surface with rows and columns. [Figure 8-1](#figure8-1) shows
    a simple canvas four pixels high and four pixels wide.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 画布是一个具有行和列的二维表面。[图 8-1](#figure8-1) 显示了一个简单的画布，四个像素高，四个像素宽。
- en: '![f08001](Images/f08001.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![f08001](Images/f08001.png)'
- en: 'Figure 8-1: A 4 × 4 canvas'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1：一个 4 × 4 的画布
- en: Each row in the canvas has been textured differently for reasons that will become
    clear shortly. The canvas has x- and y-coordinates, where the x-coordinate of
    the first column is 0 and increments from left to right; the y-coordinate also
    begins at 0 and increments from top to bottom. [Figure 8-2](#figure8-2) illustrates
    our 4 × 4 canvas with x- and y-coordinates.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行在画布上的纹理不同，原因将在稍后解释。画布有x和y坐标，其中第一列的x坐标为0，并从左到右递增；y坐标也从0开始，并从上到下递增。[图8-2](#figure8-2)展示了我们的4
    × 4画布及其x和y坐标。
- en: '![f08002](Images/f08002.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![f08002](Images/f08002.png)'
- en: 'Figure 8-2: The 4 × 4 canvas in x- and y-coordinates'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-2：4 × 4画布的x和y坐标
- en: This is how the canvas is arranged on a computer monitor, but computer memory
    isn’t arranged in rows and columns. Memory is one dimensional with a single address
    representing each pixel. For this reason, our pixel data is arranged in memory
    as shown in [Figure 8-3](#figure8-3).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是画布在计算机显示器上的排列方式，但计算机内存并不是按行列排列的。内存是一维的，每个像素都有一个唯一的地址。因此，我们的像素数据在内存中按[图8-3](#figure8-3)所示的方式排列。
- en: '![f08003](Images/f08003.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![f08003](Images/f08003.png)'
- en: 'Figure 8-3: The 16 pixels of the canvas in linear memory'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-3：画布在线性内存中的16个像素
- en: The rows are arranged one after the other in a 16-pixel data array. If you look
    at how the linear memory has arranged the pixels from the perspective of the x-
    and y-coordinates, it looks like [Figure 8-4](#figure8-4).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行是按顺序排列的，组成一个16个像素的数据数组。如果从x和y坐标的角度来看线性内存如何排列这些像素，它看起来像是[图8-4](#figure8-4)所示。
- en: '![f08004](Images/f08004.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![f08004](Images/f08004.png)'
- en: 'Figure 8-4: The x- and y-coordinates in linear memory'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-4：线性内存中的x和y坐标
- en: Our `$set_pixel` function already has the x- and y-coordinates, and needs to
    find the memory address. We do this using the equation `$y * 4 + $x`, which gives
    us the linear memory values in [Figure 8-5](#figure8-5).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`$set_pixel`函数已经有了x和y坐标，并且需要找到内存地址。我们通过公式`$y * 4 + $x`来计算，这样可以得到线性内存中的值，如[图8-5](#figure8-5)所示。
- en: '![f08005](Images/f08005.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![f08005](Images/f08005.png)'
- en: 'Figure 8-5: The formula for translating from x-, y-coordinates to linear memory'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-5：从x、y坐标到线性内存的转换公式
- en: Once we have the memory location, we can update linear memory using `i32.store`
    to set the value at that address to the color value in the parameter `$c`. [Listing
    8-9](#listing8-9) shows the source code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取到内存位置，我们就可以使用`i32.store`更新线性内存，将该地址处的值设置为参数`$c`的颜色值。[代码清单8-9](#listing8-9)展示了源代码。
- en: '**collide.wat (part 4 of 12)**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.wat（第4部分，共12部分）**'
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 8-9: The function that sets an individual pixel to a given color'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 代码清单8-9：设置单个像素为给定颜色的函数
- en: This function first does a bounds check so the user can’t try to set the color
    of a pixel that isn’t on our canvas. To verify that the x-coordinate is in the
    bounds of the canvas, we check whether `$x` is greater than `$cnvs_size` 1, and
    if it is, return the function without updating memory. We do the same with the
    y-coordinate 2.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先进行边界检查，以防用户尝试设置不在画布上的像素颜色。为了验证x坐标是否在画布的范围内，我们检查`$x`是否大于`$cnvs_size` 1，如果是，则返回函数并不更新内存。我们对y坐标
    2也做相同的检查。
- en: After the bounds check, we need to retrieve the location in integers of the
    target pixel. We get this by multiplying `$y` by `$cnvs_size` 3 to get the number
    of pixels in memory that are in the rows before the pixel and adding 4 `$x` to
    that value. Because the location value is in 32-bit integers (four bytes per pixel),
    we need to multiply that number by `4` 5 to get the byte location of our pixel
    in linear memory. This memory location is where we store `$c` using a call to
    the `i32.store` 6 statement.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行边界检查后，我们需要以整数形式获取目标像素的位置。我们通过将`$y`乘以`$cnvs_size` 3来得到像素前面行的内存中像素的数量，然后再加上`4`乘以`$x`的值。因为位置值是以32位整数（每个像素四个字节）表示的，我们需要将该值乘以`4`
    5，才能得到我们像素在线性内存中的字节位置。这个内存位置就是我们通过调用`i32.store` 6语句存储`$c`的地方。
- en: Drawing the Object
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制对象
- en: The collider objects are green squares if they don’t collide with another object
    and red if they do. We set the size of these squares to `4` in the JavaScript
    code’s constant section, so each is four pixels wide and four pixels high. We
    draw these pixels using a loop that increments the `x` value until it reaches
    the position of the object plus width. Doing so draws the first row of pixels.
    Once the x-coordinate value has exceeded the maximum `x`, the code increments
    the y-coordinate value. We then draw the second row of pixels and repeat until
    it exceeds the maximum `y` value of a pixel in this object. The code then breaks
    out of the loop. We end up with an object of 4 × 4 pixels. Let’s add the code
    for this function to our WAT file, as shown in [Listing 8-10](#listing8-10).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果碰撞体对象与其他对象没有碰撞，它们将显示为绿色方块；如果发生碰撞，则显示为红色方块。我们在 JavaScript 代码的常量部分设置了这些方块的大小为
    `4`，因此每个方块的宽度和高度都是四个像素。我们使用一个循环绘制这些像素，该循环会递增 `x` 值，直到它达到对象的位置加上宽度。这样就绘制了第一行像素。当
    x 坐标值超过最大 `x` 时，代码会递增 y 坐标值。接着，我们绘制第二行像素，并重复此过程，直到超过该对象像素的最大 `y` 值。然后代码跳出循环。最终我们得到一个
    4 × 4 像素的对象。让我们将此函数的代码添加到我们的 WAT 文件中，如 [Listing 8-10](#listing8-10) 所示。
- en: '**collide.wat (part 5 of 12)**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.wat（第 5 部分，共 12 部分）**'
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 8-10: The `$draw_obj` function draws a square of pixels calling the
    `$set_pixel` function.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-10: `$draw_obj` 函数通过调用 `$set_pixel` 函数绘制一个像素方块。'
- en: The `$draw_obj` function takes as parameters the x- and y-coordinates, and color
    in the form of `param` `i32` variables `$x`, `$y`, and `$c`. It draws pixels starting
    at the `$x` position for the x-coordinate and `$y` for the y-coordinate. It needs
    to loop over each pixel until it reaches a `$max_x` and `$max_y` position for
    the x- and y-coordinates. The function begins by using `local.tee` 1 to set the
    value of `$xi` to the value passed to the function as `$x`. It then adds the object’s
    size (`$obj_size`) to find the `$max_x` 2 value. Thereafter, the function finds
    `$max_y` 3 in the same way.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`$draw_obj` 函数以 `param` `i32` 变量 `$x`、`$y` 和 `$c` 的形式接收参数，分别表示 x 坐标、y 坐标和颜色。该函数从
    `$x` 位置开始绘制像素点，x 坐标为 `$x`，y 坐标为 `$y`。它需要循环遍历每个像素，直到达到 `$max_x` 和 `$max_y` 的 x
    坐标和 y 坐标。函数首先通过使用 `local.tee` 1 将 `$xi` 的值设置为传递给函数的 `$x` 值。然后，它将对象的大小（`$obj_size`）加到此值中，以找到
    `$max_x` 2 的值。之后，函数以相同的方式找到 `$max_y` 3。'
- en: We find the starting and ending x-coordinates, and then do the same task for
    the y-axis 4. I chose 512 as the width and height of the canvas because I assumed
    this kind of mask would offer better performance than using an `i32.rem_u` for
    a canvas bounds check. In Chapter 9, we’ll test this hypothesis to see whether
    this was a valid assumption or a premature optimization. Chapter 4 went into detail
    as to how bit masking works.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先找出起始和结束的 x 坐标，然后对 y 轴 4 做相同的操作。我选择了 512 作为画布的宽度和高度，因为我假设这种掩码比使用 `i32.rem_u`
    来进行画布边界检查具有更好的性能。在第 9 章中，我们将测试这个假设，看看这是一个有效的假设，还是一个过早的优化。第 4 章详细讲解了位掩码的工作原理。
- en: The minimum and maximum `x` and `y` values enter a loop that draws each pixel
    using a `call` `$set_pixel` expression 5. The loop increments `$xi` 6 and compares
    it with `$max_x`, resetting `$xi` to `$x` and incrementing `$yi` 9 if `$xi` is
    greater than or equal to `$max_x` 7. Then, when `$yi` has exceeded `$max_y`, the
    object is fully drawn and the code exits the loop.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值和最大值的 `x` 和 `y` 进入一个循环，使用 `call` `$set_pixel` 表达式 5 来绘制每个像素。循环增加 `$xi` 6，并将其与
    `$max_x` 进行比较，如果 `$xi` 大于或等于 `$max_x` 7，则将 `$xi` 重置为 `$x`，并将 `$yi` 9 增加 1。然后，当
    `$yi` 超过 `$max_y` 时，物体完全绘制完毕，代码退出循环。
- en: Setting and Getting Object Attributes
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置和获取对象属性
- en: Let’s create a few helper functions to set and get object attribute values inside
    linear memory. These functions take in an object number and an attribute offset
    and return the value from linear memory. In the case of `$set_obj_attr`, the function
    also takes a value and sets the object attribute to that value. In the case of
    `$get_obj_attr`, the function returns the value in linear memory for that object
    and attribute. Add the code in [Listing 8-11](#listing8-11) for `$set_obj_attr`
    to your WAT module.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些辅助函数，用于在线性内存中设置和获取对象属性值。这些函数接收一个对象编号和一个属性偏移，并返回该对象在内存中的属性值。在 `$set_obj_attr`
    函数中，它还接收一个值，并将该值设置为对象属性。在 `$get_obj_attr` 函数中，它返回该对象和属性在内存中的值。将 [Listing 8-11](#listing8-11)
    中的 `$set_obj_attr` 代码添加到您的 WAT 模块中。
- en: '**collide.wat (part 6 of 12)**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.wat（第 6 部分，共 12 部分）**'
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 8-11: Setting an object in memory based on a stride value of 16'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-11: 基于步幅值为 16 在内存中设置一个对象'
- en: Most of the code in this function calculates the address in linear memory where
    the attribute for the specific object is stored. Recall from Chapter 6 that we
    calculated the memory location of our attribute using a base address (`$obj_start`
    in this function), a stride of `16`, an object number (`$obj_number`), and an
    attribute offset (`$attr_offset`). This function uses the formula `$obj_number`*`16`
    1 + `$obj_start` 2 + `$attr_offset` 3 to determine the memory location of the
    attribute we want to modify. It then calls the `i32.store` 4 statement to store
    that value in memory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中的大部分代码计算了存储特定对象属性的线性内存地址。回顾第 6 章，我们通过基址（本函数中的 `$obj_start`）、步幅值 `16`、对象编号（`$obj_number`）和属性偏移量（`$attr_offset`）计算了属性的内存位置。该函数使用公式
    `$obj_number`*`16` 1 + `$obj_start` 2 + `$attr_offset` 3 来确定我们想要修改的属性的内存位置。然后它调用
    `i32.store` 4 语句将该值存储到内存中。
- en: Next, we’ll create the corresponding `$get_obj_attr`, which needs to calculate
    the address of the attribute value. You might be familiar with the software development
    principle *Don’t Repeat Yourself (DRY)*. DRY code is an excellent way to write
    maintainable code that is easy for other developers to read and update. Unfortunately,
    there are times when DRY code can reduce performance. In this example, we’ll redo
    some of the calculations we did in the previous function. When we venture into
    the performance optimization chapter, we’ll make our code even less DRY (sometimes
    called *wet code*) than it was in this chapter. Some techniques that produce DRY
    code can add layers of abstraction that require additional computing cycles. For
    example, a function call requires additional cycles to push values onto the stack
    and jump to new locations in the code. Optimizing compilers can frequently mitigate
    the impact of abstractions used in the code, but it can be helpful to understand
    how they do this and why DRY code isn’t always the most efficient during execution.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建相应的 `$get_obj_attr`，它需要计算属性值的地址。你可能已经熟悉软件开发原则 *不要重复自己 (DRY)*。DRY 代码是一种编写可维护代码的优秀方法，易于其他开发者阅读和更新。不幸的是，有时候
    DRY 代码可能会降低性能。在这个示例中，我们将重新做一些在前一个函数中做过的计算。当我们进入性能优化章节时，我们将使代码变得比本章更不 DRY（有时称为
    *湿代码*）。一些能产生 DRY 代码的技术可能会增加需要额外计算周期的抽象层。例如，函数调用需要额外的周期来将值推送到栈上并跳转到代码中的新位置。优化编译器通常能够减轻代码中使用的抽象的影响，但理解它们如何做到这一点以及为什么
    DRY 代码在执行时不总是最有效的，仍然是有帮助的。
- en: In other assembly languages, macros are a great way to maintain performance
    while keeping your code relatively DRY. Unfortunately, `wat2wasm` doesn’t currently
    support macros. [Listing 8-12](#listing8-12) shows the code for the `$get_obj_attr`
    function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他汇编语言中，宏是保持性能的同时保持代码相对 DRY 的好方法。不幸的是，`wat2wasm` 当前不支持宏。 [Listing 8-12](#listing8-12)
    展示了 `$get_obj_attr` 函数的代码。
- en: '**collide.wat (part 7 of 12)**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.wat（第 7 部分，共 12 部分）**'
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 8-12: Gets an object in memory based on a stride value of 16'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-12：根据步幅值 16 获取内存中的对象
- en: To get the offset bytes for an object, we start by multiplying `$obj_number`
    by the stride value of `16` 1. Then we add 2 the base address, which is stored
    in the global variable `$obj_start`. That’s followed by adding the offset, stored
    in `$attr_offset` 3. At this point, the top of the stack has the location in memory
    of the attribute we want to retrieve, so calling the expression `i32.load` 4 pushes
    that value onto the stack.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取一个对象的偏移字节，我们首先将 `$obj_number` 乘以 `16` 的步幅值 1。然后我们加上 2 基址，该基址存储在全局变量 `$obj_start`
    中。接着，添加偏移量，该偏移量存储在 `$attr_offset` 3 中。此时，栈顶包含了我们想要获取的属性在内存中的位置，因此调用表达式 `i32.load`
    4 会将该值推送到栈上。
- en: The $main Function
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: $main 函数
- en: The `$main` function will be called from the JavaScript code once per frame
    render. Its job is to move every object based on that object’s velocity, detect
    a collision between objects, and then render the object in red if it collides
    with another object and green if it doesn’t. The `$main` function is very long,
    so we’ll break it into several parts.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`$main` 函数将在每一帧渲染时从 JavaScript 代码中被调用。它的任务是根据对象的速度移动每个对象，检测对象之间的碰撞，如果对象与其他对象发生碰撞，则将其渲染为红色，如果没有，则渲染为绿色。由于
    `$main` 函数非常长，因此我们将其分为几个部分。'
- en: Defining Local Variables
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义本地变量
- en: The first part of the `$main` function, shown in [Listing 8-13](#listing8-13),
    defines all the local variables and calls the `$clear_canvas` function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`$main` 函数的第一部分，如 [Listing 8-13](#listing8-13) 所示，定义了所有本地变量并调用 `$clear_canvas`
    函数。'
- en: '**collide.wat (part 8 of 12)**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.wat（第 8 部分，共 12 部分）**'
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 8-13: The beginning of the `$main` function declares the local variables
    and clears the canvas.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-13：`$main` 函数的开头声明了局部变量并清除了画布。
- en: This function has a double loop that compares every object with every other
    object. To do this, we define two loop variables, `$i` 1 and `$j`, which will
    be loop counters for our outer and inner loops, respectively. We need to loop
    over every object using the `$i` variable and compare it to every other object
    using the `$j` variable. Then we use two pointer variables, `$outer_ptr` 2 and
    `$inner_ptr`, that point to the linear memory location for those two collider
    objects.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数包含一个双重循环，用于将每个对象与其他所有对象进行比较。为此，我们定义了两个循环变量，分别是 `$i` 和 `$j`，它们将作为外层和内层循环的计数器。我们需要使用
    `$i` 变量循环遍历每个对象，并用 `$j` 变量与其他每个对象进行比较。然后，我们使用两个指针变量，`$outer_ptr` 和 `$inner_ptr`，分别指向这两个碰撞对象的线性内存位置。
- en: 'The next four local variables are the x- and y-coordinates 3 for the inner
    and outer loop objects. The distance between the x- and y-coordinates of the two
    objects are stored in the `$xdist` 4 and `$ydist` local variables. The `$i_hit`
    5 local variable is a boolean flag that is set to `1` if the `$i` object collides
    with another object and `0` if it doesn’t. Two variables, `$xv` 6 and `$yv`, store
    the velocity of the `$i` object. After the local variables are declared, the function
    performs the first action: clear all the canvas pixels to black using the statement
    `(call` `$clear_canvas)`7.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个局部变量是内层和外层循环对象的 `x` 和 `y` 坐标。两个对象的 `x` 和 `y` 坐标之间的距离存储在 `$xdist` 和 `$ydist`
    局部变量中。`$i_hit` 局部变量是一个布尔标志，如果 `$i` 对象与其他对象发生碰撞，则设置为 `1`，否则设置为 `0`。两个变量 `$xv` 和
    `$yv` 存储 `$i` 对象的速度。声明了这些局部变量后，函数执行第一个操作：使用语句 `(call` `$clear_canvas)` 将画布的所有像素清除为黑色。
- en: The $move_loop
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: $move_loop
- en: The next part of the `$main` function defines a loop that moves every object
    in linear memory each frame. This part of the function will retrieve the `$x`,
    `$y`, `$xv`, and `$yv` attributes for the `$i` object. The `$xv` and `$yv` variables
    are the `x` and `y` velocity variables, and they’re used to move the object by
    changing the `$x` and `$y` coordinate values. The code also forces the `x` and
    `y` values to stay within the bounds of the canvas. Immediately after the move
    loop, the `$i` variable is reset to `0`. Add the code in [Listing 8-14](#listing8-14)
    to the WAT module.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`$main` 函数的下一部分定义了一个循环，每一帧都将线性内存中的每个对象移动。这部分代码将获取 `$i` 对象的 `$x`、`$y`、`$xv`
    和 `$yv` 属性。`$xv` 和 `$yv` 变量分别是 `x` 和 `y` 速度变量，用于通过改变 `$x` 和 `$y` 坐标值来移动对象。代码还强制
    `x` 和 `y` 值保持在画布的边界内。移动循环之后，`$i` 变量会被重置为 `0`。将代码添加到 [Listing 8-14](#listing8-14)
    中的 WAT 模块。'
- en: '**collide.wat (part 9 of 12)**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.wat（第 9 部分，共 12 部分）**'
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 8-14: Loop to move each object'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-14：移动每个对象的循环
- en: The code in [Listing 8-14](#listing8-14) loops through all of our objects, changing
    the x- and y-coordinates based on the `x` and `y` velocities. The first few lines
    of the loop 1 call `$get_obj_attr` for the `x` position, `y` position, `x` velocity,
    and ``y velocity attributes, passing in the loop index and the offset of the attribute
    to be set. Doing this pushes the value of the attribute onto the stack. The expression
    `local.set` is then used to set a local variable we’ll use in the `loop`.``
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 8-14](#listing8-14) 中的代码遍历所有对象，基于 `x` 和 `y` 速度改变它们的 `x` 和 `y` 坐标。循环的前几行调用
    `$get_obj_attr` 来获取 `x` 位置、`y` 位置、`x` 速度和 `y` 速度属性，并传入循环索引和需要设置的属性偏移量。这样做会将属性值推送到栈上。接着，使用
    `local.set` 表达式来设置我们将在 `loop` 中使用的局部变量。'
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
