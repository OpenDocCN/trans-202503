- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: GRAPHS AND BREADTH-FIRST SEARCH
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图形与广度优先搜索
- en: '![Image](../images/common1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common1.jpg)'
- en: In this chapter, we’ll study three problems in which we’re asked to solve puzzles
    in the minimum number of moves. How quickly can a knight catch a pawn? How quickly
    can a student climb a rope in gym class? How cheaply can we translate a book written
    in one language to other target languages? Breadth-first search (BFS) is the unifying
    algorithm here. BFS dispatches these problems, and it applies more generally whenever
    we want to solve a puzzle with the minimum number of moves. Along the way, we’ll
    learn about graphs, a powerful way to model and solve problems that involve objects
    and connections between those objects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究三种问题，要求我们用最少的步数解决谜题。骑士多快能追上兵？学生在体育课上爬绳子多快？我们能以多低的成本将一本书从一种语言翻译成其他目标语言？广度优先搜索（BFS）是解决这些问题的统一算法。BFS解决了这些问题，并且更广泛地应用于我们想要以最少步数解决谜题的场景。在此过程中，我们将学习图形，这是建模和解决涉及物体及物体间连接问题的强大工具。
- en: 'Problem 1: Knight Chase'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题1：骑士追击
- en: This is DMOJ problem `ccc99s4`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题`ccc99s4`。
- en: '*The Problem*'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题描述*'
- en: 'This problem concerns two players, a pawn and a knight, playing a board game.
    (Don’t worry: you don’t need to know anything about chess.)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题涉及两个玩家，一个是兵，一个是骑士，在棋盘上进行对弈。（别担心：你不需要了解任何关于国际象棋的知识。）
- en: The board has *r* rows, with row 1 at the bottom and row *r* at the top. The
    board has *c* columns, with column 1 at the left and column *c* at the right.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘有*r*行，第一行在底部，*r*行在顶部。棋盘有*c*列，第一列在左侧，*c*列在右侧。
- en: 'The pawn and knight each start on their own square of the board. The pawn moves
    first, then the knight moves, then the pawn, then the knight, and so on, until
    the game ends. For each turn, a move must be made: remaining at the current square
    is not an option.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 兵和骑士各自从棋盘上的一个方格开始。兵先移动，然后骑士移动，然后是兵，再是骑士，依此类推，直到游戏结束。每轮必须进行移动：不能停留在当前方格。
- en: 'The pawn has no choice on what move to make: for each of its turns, it moves
    up one square.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 兵无法选择要怎么移动：每轮它都会向上一格移动。
- en: 'The knight, by contrast, has up to eight choices for each move:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，骑士每次移动都有最多八个选择：
- en: Up 1, right 2
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上 1，向右 2
- en: Up 1, left 2
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上 1，向左 2
- en: Down 1, right 2
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下 1，向右 2
- en: Down 1, left 2
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下 1，向左 2
- en: Up 2, right 1
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上 2，向右 1
- en: Up 2, left 1
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上 2，向左 1
- en: Down 2, right 1
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下 2，向右 1
- en: Down 2, left 1
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下 2，向左 1
- en: I say “up to eight choices,” not “exactly eight choices,” because moves that
    bring the knight outside of the board are not allowed. For example, if the board
    has 10 columns and the knight is in column 9, then no move that takes the knight
    two columns to the right is allowed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我说“最多八个选择”，而不是“恰好八个选择”，因为任何让骑士超出棋盘的移动都是不允许的。例如，如果棋盘有10列，骑士在第9列，那么任何让骑士向右移动两列的行为都是不允许的。
- en: 'The following diagram shows the knight’s available moves:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示显示了骑士的可用移动：
- en: '|   |   |   |   |   |   |   |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |   |'
- en: '|  |  | f |  | e |  |  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  |  | f |  | e |  |  |'
- en: '|  | b |  |  |  | a |  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  | b |  |  |  | a |  |'
- en: '|  |  |  | K |  |  |  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | K |  |  |  |'
- en: '|  | d |  |  |  | c |  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|  | d |  |  |  | c |  |'
- en: '|  |  | h |  | 9 |  |  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|  |  | h |  | 9 |  |  |'
- en: '|   |   |   |   |   |   |   |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |   |'
- en: Here, the knight is represented as `K`, and each letter from `a` to `h` represents
    one of its possible moves.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，骑士用`K`表示，从`a`到`h`的每个字母代表其可能的移动。
- en: 'The game ends when one of three things happens: the knight wins, the game is
    a stalemate (that is, a tie), or the knight loses.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束时会发生以下三种情况：骑士获胜，游戏和棋（即平局），或骑士失败。
- en: '**Win**   The knight wins if the knight makes a move and lands on the same
    square as the pawn before the pawn reaches the top row. To win, the knight has
    to be the one to make the move; if the pawn makes a move and lands on the knight,
    this doesn’t count as the knight winning.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**胜利** 如果骑士移动并停在与兵相同的方格上，而兵还未到达顶排，骑士就获胜。为了获胜，必须是骑士做出这个移动；如果是兵移动并停在骑士上，这不算骑士获胜。'
- en: '**Stalemate**   The game is a stalemate if the knight makes a move and lands
    on the square above the pawn before the pawn reaches the top row. Again, the knight
    has to be the one to make this move; the only exception is that the game can start
    as a stalemate if the knight starts one square above the pawn.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**和棋** 游戏是和棋如果骑士移动并停在兵前方的方格上，而兵还没有到达顶排。同样，必须是骑士做出这个移动；唯一的例外是，如果骑士从兵上方一格开始，游戏可以一开始就为和棋。'
- en: '**Loss**   The knight loses if the pawn reaches the top row before the game
    otherwise ends. That is, if the pawn gets to the top row before the knight lands
    on the pawn or lands on the square above it, then the knight loses. Once the pawn
    reaches the top row, the knight is not allowed to move anymore.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**Loss**   如果兵在游戏结束之前到达了顶部行，骑士就输了。也就是说，如果兵在骑士踏上兵或站在兵上方的格子之前到达顶部行，那么骑士就输了。一旦兵到达顶部行，骑士将不再被允许移动。'
- en: The goal is to determine the best-case outcome for the knight and the number
    of knight moves required to produce that outcome.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是确定骑士的最佳结果及达到该结果所需的骑士步数。
- en: Input
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The first line of input gives the number of test cases that will follow. Each
    test case consists of six lines:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的第一行给出将要处理的测试用例数量。每个测试用例由六行组成：
- en: The number of rows in the board, between 3 and 99
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 棋盘的行数，范围在 3 到 99 行之间
- en: The number of columns in the board, between 2 and 99
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 棋盘的列数，范围在 2 到 99 列之间
- en: The starting row of the pawn
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兵的起始行
- en: The starting column of the pawn
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兵的起始列
- en: The starting row of the knight
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 骑士的起始行
- en: The starting column of the knight
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 骑士的起始列
- en: It’s guaranteed that the pawn and knight will have different starting positions
    and that the knight starts at a position where it has at least one available move.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 可以保证兵和骑士有不同的起始位置，并且骑士起始位置至少有一个可用的移动。
- en: Output
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: 'For each test case, output a line with one of three messages:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例，输出一行，内容为以下三条消息之一：
- en: If the knight can win, output `Win in *m* knight move(s).`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果骑士可以获胜，输出`Win in *m* knight move(s).`
- en: If the knight cannot win but can cause a stalemate, output `Stalemate in *m*
    knight move(s).`
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果骑士无法获胜，但能导致僵局，输出`Stalemate in *m* knight move(s).`
- en: If the knight cannot win or cause a stalemate, output `Loss in *m* knight move(s).`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果骑士无法获胜或导致僵局，输出`Loss in *m* knight move(s).`
- en: Here, m is the minimum number of moves made by the knight.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，m 是骑士所需的最少步数。
- en: The time limit for solving the test cases is one second.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制为一秒。
- en: '*Moving Optimally*'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*最优移动*'
- en: A true two-player game, such as tic-tac-toe or chess, gives each player a choice
    of what move to make next. However, here, only the knight has a choice. The pawn’s
    moves are all fixed, and we’ll know exactly where the pawn is at all times. It’s
    a good thing, too, because this problem would be significantly more difficult
    if both players had choices.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真正的两人游戏，比如井字棋或象棋，给每个玩家选择下一步的机会。然而，在这里，只有骑士有选择权。兵的移动是固定的，我们随时都知道兵的位置。幸运的是，因为如果两方都有选择权，这个问题将会变得更加复杂。
- en: There may be various ways for the knight to win or cause a stalemate. Suppose
    that the knight can win. Each way that the knight can win requires some number
    of moves; we want to identify the minimum number of moves.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 骑士可能有多种方式获胜或导致僵局。假设骑士能够获胜。每种骑士获胜的方式需要一定的步数；我们想要确定最少的步数。
- en: Exploring the Board
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 探索棋盘
- en: 'Let’s explore a little through this input:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这个输入稍微探索一下：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The board for this test case has seven rows and seven columns. The pawn starts
    at row 1, column 1, and the knight starts at row 4, column 6.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该测试用例的棋盘有七行七列。兵从第 1 行第 1 列开始，骑士从第 4 行第 6 列开始。
- en: 'Moving optimally, the knight can win here in three moves. The following diagram
    shows how the knight can do this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在最优移动下，骑士可以在三步内获胜。下面的图示展示了骑士如何实现这一点：
- en: '| **7** |  |  |  |  |  |  |  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **7** |  |  |  |  |  |  |  |'
- en: '| **6** |  | K2 |  |  |  |  |  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **6** |  | K2 |  |  |  |  |  |'
- en: '| **5** |  |  |  | K1 |  |  |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **5** |  |  |  | K1 |  |  |  |'
- en: '| **4** | K3 P3 |  |  |  |  | K |  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **4** | K3 P3 |  |  |  |  | K |  |'
- en: '| **3** | P2 |  |  |  |  |  |  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **3** | P2 |  |  |  |  |  |  |'
- en: '| **2** | P1 |  |  |  |  |  |  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **2** | P1 |  |  |  |  |  |  |'
- en: '| **1** | P |  |  |  |  |  |  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **1** | P |  |  |  |  |  |  |'
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
- en: Here, `K` is used for the knight’s starting position and `P` for the pawn’s
    starting position. `K1`, `K2`, and `K3` give the location of the knight after
    move 1, move 2, and move 3, respectively; `P1`, `P2`, and `P3` do likewise for
    the pawn.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`K` 用来表示骑士的起始位置，`P` 用来表示兵的起始位置。`K1`、`K2` 和 `K3` 分别表示骑士在第 1 步、第 2 步和第 3 步后的位置；`P1`、`P2`
    和 `P3` 也同样表示兵的移动位置。
- en: 'The coordinates (*x*, *y*) refer to row *x*, column *y*. As expected, the pawn
    simply marches up its column, from (1, 1), to (2, 1), to (3, 1), and finally to
    (4, 1). The knight, however, moves as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标（*x*，*y*）指的是第 *x* 行，第 *y* 列。如预期的那样，兵只是沿着自己的列向上移动，从（1，1）到（2，1），到（3，1），最终到达（4，1）。然而，骑士的移动方式如下：
- en: Starting at (4, 6), it moves up one and left two to (5, 4). The pawn is at (2,
    1).
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从（4，6）开始，它向上移动一步并向左移两步到达（5，4）。兵的位置在（2，1）。
- en: From (5, 4), it moves up one and left two to (6, 2). The pawn is at (3, 1).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从（5，4）开始，它向上移动一步并向左移两步到达（6，2）。兵的位置在（3，1）。
- en: From (6, 2), it moves down two and left one to (4, 1). That’s where the pawn
    is!
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从（6，2）开始，它向下移动两步并向左移一步到达（4，1）。兵就在这个位置！
- en: 'There are other ways for the knight to win. For example, here’s what can happen
    if the knight goofs off a little:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 骑士获胜的方式还有其他几种。例如，如果骑士有些放松，它也可能会这样：
- en: '| **7** |  |  |  |  |  |  |  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **7** |  |  |  |  |  |  |  |'
- en: '| **6** |  | K2 |  |  |  |  |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **6** |  | K2 |  |  |  |  |  |'
- en: '| **5** | K4 P4 |  |  | K1 |  |  |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **5** | K4 P4 |  |  | K1 |  |  |  |'
- en: '| **4** | P3 |  | K3 |  |  | K |  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **4** | P3 |  | K3 |  |  | K |  |'
- en: '| **3** | P2 |  |  |  |  |  |  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **3** | P2 |  |  |  |  |  |  |'
- en: '| **2** | P1 |  |  |  |  |  |  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **2** | P1 |  |  |  |  |  |  |'
- en: '| **1** | P |  |  |  |  |  |  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **1** | P |  |  |  |  |  |  |'
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
- en: The knight catches the pawn after four moves, not three. Though the knight still
    wins, this is *not* the fastest way that it can do so. We need to report a minimum
    of three moves here, not four.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 骑士在四步后才会吃掉兵，而不是三步。虽然骑士最终获胜，但这*并不是*它能做到的最快方式。我们这里需要报告最少三步，而不是四步。
- en: Suppose that we had an algorithm to determine the minimum number of moves that
    the knight can take from its starting point to some destination. We could then
    determine the number of knight moves required to get to each pawn location; if
    the knight can get there at the same time as the pawn, then the knight wins. If
    the knight cannot win, then we could do similarly for stalemates. That is, we
    could determine the number of knight moves required to get to the square above
    each pawn location; if at any point the knight can land on the square above the
    pawn, we have a stalemate.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个算法来确定骑士从起点到某个目标的最少移动步数。我们可以通过这个算法确定骑士到达每个兵的位置所需的步数；如果骑士能够与兵同时到达，那么骑士获胜。如果骑士无法获胜，那么我们可以以类似的方式处理和棋的情况。也就是说，我们可以确定骑士到达每个兵上方位置所需的步数；如果在某一点，骑士能够到达兵上方的格子，我们就达成了和棋。
- en: 'To design such an algorithm, we can explore the board from the knight’s starting
    point. There’s only one square on the board that is reachable in zero moves: the
    knight’s starting point itself. From there, we can discover those squares that
    are reachable in one move. From those squares that are one move away, we can discover
    those squares that are reachable in two moves. We can use those squares reachable
    in two moves to find those reachable in three moves, and so on. We stop when we
    find the desired destination; at that point, we’ll know the minimum number of
    moves that it takes to get there.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计这样的算法，我们可以从骑士的起点开始探索棋盘。棋盘上只有一个方格是可以在零步内到达的，那就是骑士的起点。从这里开始，我们可以发现那些在一步内可达的方格。从那些一步内可达的方格，我们可以发现那些在两步内可达的方格。我们可以用这些两步内可达的方格来找到三步内可达的方格，以此类推。直到我们找到目标位置为止；此时，我们就知道到达那里所需的最小步数。
- en: 'Let’s demonstrate this procedure using the same test case as before: seven
    rows and seven columns, with the knight starting at (4, 6). (We’ll ignore the
    pawn for now.) To confirm our answer of three moves that we arrived at by hand,
    we’ll calculate the minimum number of moves for the knight to get from (4, 6)
    to (4, 1).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用之前相同的测试用例演示这一过程：七行七列，骑士从（4，6）开始。（我们暂时忽略兵。）为了验证我们手动得出的三步结果，我们将计算骑士从（4，6）到（4，1）所需的最小步数。
- en: 'In the following diagrams, numbers in the squares indicate the minimum distance
    from the knight’s starting point. As mentioned above, the only square reachable
    in zero moves is the knight’s starting point itself, (4, 6). We’ll call this round
    0 of the exploration:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，方格内的数字表示骑士从起点到该位置的最小距离。如上所述，唯一可以在零步内到达的方格是骑士的起点（4, 6）。我们将这视为探索的第0轮：
- en: '| **7** |  |  |  |  |  |  |  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **7** |  |  |  |  |  |  |  |'
- en: '| **6** |  |  |  |  |  |  |  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **6** |  |  |  |  |  |  |  |'
- en: '| **5** |  |  |  |  |  |  |  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **5** |  |  |  |  |  |  |  |'
- en: '| **4** |  |  |  |  |  | 0 |  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **4** |  |  |  |  |  | 0 |  |'
- en: '| **3** |  |  |  |  |  |  |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **3** |  |  |  |  |  |  |  |'
- en: '| **2** |  |  |  |  |  |  |  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **2** |  |  |  |  |  |  |  |'
- en: '| **1** |  |  |  |  |  |  |  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **1** |  |  |  |  |  |  |  |'
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
- en: 'From (4, 6), we try all eight possible moves to identify the squares reachable
    in one move. We can’t move up one and right two or down one and right two, because
    those would take us beyond the right edge of the board. That leaves six squares
    that are one move away. This is round 1:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从（4，6）开始，我们尝试所有八个可能的移动，来识别一步之遥的方格。我们不能上移1并右移2，也不能下移1并右移2，因为那样会越过棋盘的右边界。这就留下了六个距离一步之遥的方格。这是第一轮：
- en: '| **7** |  |  |  |  |  |  |  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **7** |  |  |  |  |  |  |  |'
- en: '| **6** |  |  |  |  | 1 |  | 1 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **6** |  |  |  |  | 1 |  | 1 |'
- en: '| **5** |  |  |  | 1 |  |  |  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **5** |  |  |  | 1 |  |  |  |'
- en: '| **4** |  |  |  |  |  | 0 |  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **4** |  |  |  |  |  | 0 |  |'
- en: '| **3** |  |  |  | 1 |  |  |  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **3** |  |  |  | 1 |  |  |  |'
- en: '| **2** |  |  |  |  | 1 |  | 1 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **2** |  |  |  |  | 1 |  | 1 |'
- en: '| **1** |  |  |  |  |  |  |  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **1** |  |  |  |  |  |  |  |'
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
- en: 'We haven’t found (4, 1) yet, so we keep going. We explore from each of those
    six new squares that we discovered in round 1; that will yield the squares that
    are two moves away. For example, consider square (6, 5); the squares reachable
    from there are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有找到（4，1），所以继续前进。我们从第一轮中发现的六个新方格出发进行探索，这将产生距离两步之遥的方格。例如，考虑方格（6，5）；从那里可以到达的方格如下：
- en: 'Up 1, right 2: (7, 7)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上移1，右移2：（7，7）
- en: 'Up 1, left 2: (7, 3)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上移1，左移2：（7，3）
- en: 'Down 1, right 2: (5, 7)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下移1，右移2：（5，7）
- en: 'Down 1, left 2: (5, 3)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下移1，左移2：（5，3）
- en: 'Up 2, right 1: (which is not valid)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上移2，右移1：（无效）
- en: 'Up 2, left 1: (which is not valid)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上移2，左移1：（无效）
- en: 'Down 2, right 1: (4, 6)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下移2，右移1：（4，6）
- en: 'Down 2, left 1: (4, 4)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下移2，左移1：（4，4）
- en: These squares are two moves away from the starting point—except for (4, 6),
    whose value (0) we filled in before! Looking at all valid moves from all squares
    that are one move away brings us to round 2, the squares that are two moves away.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方格距离起点两步之遥——除了（4，6），我们之前已经填入了它的值（0）！查看所有从一步之遥的方格出发的有效移动，将我们带到第二轮，即距离两步之遥的方格。
- en: '| **7** |  |  | 2 |  | 2 |  | 2 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **7** |  |  | 2 |  | 2 |  | 2 |'
- en: '| **6** |  | 2 |  |  | 1 | 2 | 1 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **6** |  | 2 |  |  | 1 | 2 | 1 |'
- en: '| **5** |  |  | 2 | 1 | 2 |  | 2 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **5** |  |  | 2 | 1 | 2 |  | 2 |'
- en: '| **4** |  | 2 |  | 2 |  | 0 |  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **4** |  | 2 |  | 2 |  | 0 |  |'
- en: '| **3** |  |  | 2 | 1 | 2 |  | 2 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **3** |  |  | 2 | 1 | 2 |  | 2 |'
- en: '| **2** |  | 2 |  |  | 1 | 2 | 1 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **2** |  | 2 |  |  | 1 | 2 | 1 |'
- en: '| **1** |  |  | 2 |  | 2 |  | 2 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **1** |  |  | 2 |  | 2 |  | 2 |'
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
- en: Notice that there cannot be any other squares that are two moves away. Every
    square that is two moves away must emanate from a square that is one move away,
    and we explored all possible moves from all possible squares that are one move
    away.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到没有其他方格距离起点两步之遥。所有距离两步之遥的方格都必须来自距离起点一步之遥的方格，我们已经探索了所有可能的一步之遥的方格。
- en: 'There is still no (4, 1), so we keep going. Exploring from all squares that
    are two moves away gives us round 3, the squares that are three moves away:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然没有（4，1），所以继续前进。从所有距离两步之遥的方格出发进行探索，我们得到了第三轮，距离三步之遥的方格：
- en: '| **7** |  | 3 | 2 | 3 | 2 | 3 | 2 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **7** |  | 3 | 2 | 3 | 2 | 3 | 2 |'
- en: '| **6** | 3 | 2 | 3 |  | 1 | 2 | 1 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **6** | 3 | 2 | 3 |  | 1 | 2 | 1 |'
- en: '| **5** |  | 3 | 2 | 1 | 2 | 3 | 2 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **5** |  | 3 | 2 | 1 | 2 | 3 | 2 |'
- en: '| **4** | 3 | 2 | 3 | 2 | 3 | 0 | 3 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **4** | 3 | 2 | 3 | 2 | 3 | 0 | 3 |'
- en: '| **3** |  | 3 | 2 | 1 | 2 | 3 | 2 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **3** |  | 3 | 2 | 1 | 2 | 3 | 2 |'
- en: '| **2** | 3 | 2 | 3 |  | 1 | 2 | 1 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 3 | 2 | 3 |  | 1 | 2 | 1 |'
- en: '| **1** |  | 3 | 2 | 3 | 2 | 3 | 2 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **1** |  | 3 | 2 | 3 | 2 | 3 | 2 |'
- en: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|  | **1** | **2** | **3** | **4** | **5** | **6** | **7** |'
- en: 'There we have it: square (4, 1) is filled in with a value of 3\. It therefore
    takes a minimum of three moves to get from (4, 6) to (4, 1). Had we not found
    (4, 1) here, we’d continue: we could proceed to find squares that are four moves
    away, then five moves away, and so on.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样：方格（4，1）被填上了值3。因此，从（4，6）到（4，1）至少需要三步。如果我们没有在这里找到（4，1），我们将继续：我们可以继续寻找四步之遥的方格，五步之遥的方格，以此类推。
- en: This technique—finding all squares that are zero moves away, then one move away,
    then two moves away, and so on—is called *breadth-first search*, or BFS for short.
    The word *breadth* refers to a full range. BFS is so named because we explore
    the full range of what is reachable from each square before moving on to other
    squares. BFS is fast, memory efficient, and clean to implement. It’s an absolute
    power move to invoke BFS whenever you want the minimum distance from one location
    to another location. Let’s go for it!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术——首先找到所有与目标零步之遥的格子，然后是一步之遥、两步之遥，依此类推——称为*广度优先搜索*，简称BFS。*广度*指的是完整的范围。BFS之所以这样命名，是因为我们从每个格子开始，首先探索所有可达的格子，再继续向其他格子扩展。BFS非常快速，内存高效，而且实现起来很简洁。每当你想要找出从一个位置到另一个位置的最短距离时，调用BFS绝对是个强力的选择。让我们开始吧！
- en: Implementing Breadth-First Search
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现广度优先搜索
- en: 'Let’s start with a couple of type definitions that clean up our code a little.
    First, each board position is composed of a row and a column, so let’s package
    those together using a struct:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义几个类型，以便稍微清理一下代码。每个棋盘位置由一行和一列组成，因此我们将这两个元素使用结构体打包在一起：
- en: '[PRE1]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A board is a two-dimensional array, and we can make a type definition for that
    too. We’ll let it hold integers, which will correspond to numbers of moves. We
    have a maximum of 99 rows and 99 columns, but we allocate one extra row and column
    so we can start indexing rows and columns at `1`, not `0`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘是一个二维数组，我们也可以为它定义一个类型。我们将让它保存整数，这些整数表示移动次数。棋盘最多有99行和99列，但我们额外分配了一行和一列，这样我们就可以从`1`开始索引行和列，而不是从`0`：
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, let’s make an array type for holding the positions that we discover
    during the BFS. We’ll make it big enough that it can hold every possible square
    on the board:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们为保存BFS过程中发现的位置创建一个数组类型。我们将使它足够大，以便能够容纳棋盘上所有可能的格子：
- en: '[PRE3]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we’re ready for the BFS itself. We need a function to determine the minimum
    number of knight moves to get from its starting point to some destination that
    we specify. (Recall that our plan is to find the minimum number of moves needed
    to catch the pawn at each pawn location.) Here’s the signature for the function
    we’ll implement:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始广度优先搜索（BFS）了。我们需要一个函数来确定骑士从起始点到指定目标的最小移动次数。（回想一下我们的计划是找到每个棋子位置所需的最小移动次数。）这是我们将要实现的函数的签名：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The parameters `knight_row` and `knight_col` give the starting location of the
    knight, and `dest_row` and `dest_col` give the desired destination. The parameters
    `num_rows` and `num_cols` give, respectively, the number of rows and columns in
    the board; we’ll need those to determine whether a move is valid. The function
    returns the minimum number of moves for the knight to go from its starting location
    to the destination. If there’s no way for the knight to get to the destination,
    then we return `-1`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`knight_row`和`knight_col`给出了骑士的起始位置，`dest_row`和`dest_col`给出了目标位置。参数`num_rows`和`num_cols`分别给出了棋盘的行数和列数；我们需要这些来判断一个移动是否有效。该函数返回骑士从起始位置到目标位置的最小移动次数。如果骑士无法到达目标位置，则返回`-1`。
- en: 'There are two key arrays that drive the BFS:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个关键数组驱动BFS：
- en: cur_positions   This array holds the positions discovered from the current round
    of BFS. For example, it might be all of the positions discovered in round 3.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: cur_positions   这个数组保存了当前轮BFS中发现的位置。例如，它可能保存的是第3轮发现的所有位置。
- en: new_positions   This array holds the positions discovered in the next round
    of BFS. For example, if `cur_positions` holds the positions discovered in round
    3, then `new_positions` will hold those positions discovered in round 4.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: new_positions   这个数组保存了在下一轮广度优先搜索（BFS）中发现的位置。例如，如果`cur_positions`保存的是第3轮发现的位置，那么`new_positions`将保存第4轮发现的位置。
- en: The code is given in [Listing 5-1](ch05.xhtml#ch05ex01).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 代码见[清单 5-1](ch05.xhtml#ch05ex01)。
- en: '[PRE5]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5-1: The minimum number of knight moves using BFS*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-1：使用BFS计算骑士最小移动次数*'
- en: The first thing we do is clear out the `min_moves` array by setting all values
    to `-1`; this means that we have not yet computed the number of moves. The only
    square for which we know the minimum number of moves is the knight’s starting
    square, so we initialize that to `0` ➊. That starting square is also the square
    that jump-starts the BFS ➋. The `while` loop then runs as long as the most-recent
    round of BFS has discovered at least one new square ➌. Inside the `while` loop,
    we look at each such square. If we discover the destination square ➍, then we
    return its minimum number of moves. Otherwise, we keep exploring.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的第一件事是清空`min_moves`数组，将所有值设置为`-1`；这意味着我们还没有计算出移动次数。唯一我们知道最小移动次数的方格是骑士的起始方格，因此我们将其初始化为`0`
    ➊。这个起始方格也是启动BFS的方格 ➋。然后，`while`循环会继续执行，只要最近一轮BFS发现至少一个新方格 ➌。在`while`循环中，我们检查每个这样的方格。如果我们发现了目标方格
    ➍，我们就返回它的最小移动次数。否则，我们继续探索。
- en: 'Exploring all eight moves from a given square is accomplished by eight calls
    to a helper function called `add_position`, which adds new squares to `new_positions`
    and updates `num_new_positions` accordingly. Focus on the first four arguments:
    those give the current row and column and the new row and column resulting from
    one of the eight moves. For example, the first call ➎ is for the move that goes
    up two and right one. We’ll look at the code for `add_position` shortly.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从给定的方格探索所有八个移动是通过八次调用一个名为`add_position`的辅助函数来完成的，该函数将新的方格添加到`new_positions`并相应地更新`num_new_positions`。重点是前四个参数：它们提供当前的行和列，以及通过其中一个八个移动得出的新行和新列。例如，第一个调用
    ➎ 是向上移动两步并向右移动一步。我们稍后会查看`add_position`的代码。
- en: We’ve gone through each square in `cur_positions` and found new squares that
    are one more move away. That completes one round of BFS. To prepare for the next
    round, we keep track of the number of new squares ➏ and copy all of the new squares
    from `new_positions` to `cur_positions`. That way, the next iteration of the `while`
    loop uses those new squares and finds further new squares from there.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遍历了`cur_positions`中的每个方格，并找到了距离一个移动距离的新方格。这完成了BFS的一个回合。为了准备下一轮，我们跟踪新方格的数量
    ➏ 并将所有新方格从`new_positions`复制到`cur_positions`。这样，`while`循环的下一次迭代将使用这些新方格，并从这些方格中找到进一步的新方格。
- en: If we reach the bottom of the code and haven’t found the destination square,
    then we return `-1`—that destination square is not reachable from the knight’s
    starting location.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行到代码末尾，仍然没有找到目标方格，那么我们返回`-1`——目标方格无法从骑士的起始位置到达。
- en: Now for that `add_position` helper function; see [Listing 5-2](ch05.xhtml#ch05ex02).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看一下那个`add_position`辅助函数；请参见[清单 5-2](ch05.xhtml#ch05ex02)。
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 5-2: Adding a position*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-2：添加位置*'
- en: 'The `if` statement has five conditions, all of which must be true for `to_row`
    and `to_col` to be a valid position: the row must be at least one, the column
    must be at least one, the row must be at most the number of rows, the column must
    be at most the number of columns, and . . . hmm, that last one, `min_moves[to_row][to_col]
    == -1`, what’s that doing?'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句有五个条件，只有当所有条件都为真时，`to_row`和`to_col`才是一个有效的位置：行必须至少为1，列必须至少为1，行不能超过行数，列不能超过列数，最后一个条件是`min_moves[to_row][to_col]
    == -1`，这是什么意思呢？'
- en: That final condition is there to determine whether we’ve already seen this square.
    If we haven’t, then it will have a value of `-1` and we can go ahead and set its
    number of moves now. If it already has some other value, then it must have been
    discovered in an *earlier* round of BFS, and therefore it already has a smaller
    number of moves than what we could give it now. That is, a value other than `-1`
    means that the minimum number of moves is already set, and we shouldn’t mess with
    it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最终条件是用来判断我们是否已经遇到过这个方格。如果没有遇到过，那么它的值将为`-1`，我们可以立即为它设置移动次数。如果它已经有其他值，那么它一定是在BFS的*早期*回合中被发现的，因此它已经有了一个比现在能给它的值更小的移动次数。也就是说，任何非`-1`的值都意味着最小的移动次数已经设置好，我们不应更改它。
- en: If all five conditions pass, then we’ve discovered a new square. We discovered
    (`from_row`, `from_col`) in the previous round of BFS and `(to_row`, `to_col`)
    in the current round. Therefore, the minimum number of moves to (`to_row`, `to_col`)
    is one more than the minimum moves to (`from_row`, `from_col`) ➊. By virtue of
    (`from_row`, `from_col`) coming from the previous round of BFS, we already have
    its value stored in `min_moves`, and so we can simply look up its value without
    recalculating it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有五个条件都通过了，那么我们就发现了一个新方格。我们在上一次BFS中发现了（`from_row`, `from_col`）的位置，并在当前轮次发现了（`to_row`,
    `to_col`）。因此，最少步数到达（`to_row`, `to_col`）是到达（`from_row`, `from_col`）的最少步数加一 ➊。由于（`from_row`,
    `from_col`）是从上一次BFS中得来的，我们已经将其值存储在`min_moves`中，因此我们可以直接查找其值，而无需重新计算。
- en: 'You may see shades of memoization and dynamic programming here. It’s true:
    BFS uses the same trick of looking stuff up rather than recomputing it. However,
    there’s not really a notion of maximizing or minimizing a solution based on subproblem
    solutions or combining smaller solutions to form a larger solution. Algorithm
    developers therefore generally don’t refer to BFS as a dynamic-programming algorithm,
    instead classifying it as a search or exploration algorithm.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在这里看到备忘录化和动态规划的影子。没错：广度优先搜索（BFS）使用了相同的技巧，即查找已计算的结果，而不是重新计算。然而，BFS中并没有真正的基于子问题解来最大化或最小化解，或者通过合并更小的解来形成更大的解。因此，算法开发者通常不会把BFS称为动态规划算法，而是将其归类为搜索或探索算法。
- en: '*Best Knight Outcome*'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*骑士的最佳结果*'
- en: 'We’ve got BFS bottled up nicely as the `find_distance` function. Now let’s
    count the number of moves as the pawn marches up its column and use `find_distance`
    to determine whether the knight can ever land on the pawn. For example, if the
    pawn takes three moves to get somewhere, and the knight can take exactly three
    moves to get there too, then the knight wins in three moves. If the knight can’t
    win, then we can try a similar technique for stalemates: let the pawn march up
    its column again, this time checking whether the knight can cause a stalemate.
    If no stalemates are possible, well, then the knight loses. I’ve got this logic
    coded up in [Listing 5-3](ch05.xhtml#ch05ex03). The function `solve` takes six
    parameters: the starting row and column of the pawn, the starting row and column
    of the knight, and the numbers of rows and columns in the board. It prints one
    line of output corresponding to whether the knight wins, stalemates, or loses.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经把BFS封装成了`find_distance`函数。现在，让我们计算棋子沿着列向上移动时的步数，并使用`find_distance`来判断骑士是否能够赶到棋子的位置。例如，如果棋子需要三步才能到达某个地方，而骑士也正好需要三步才能到达，那么骑士就会在三步内获胜。如果骑士无法获胜，我们可以尝试一种类似的技术来应对僵局：让棋子再次向上走，检查骑士是否能导致僵局。如果没有可能的僵局，那么骑士就输了。我已经在[列表
    5-3](ch05.xhtml#ch05ex03)中实现了这个逻辑。`solve`函数有六个参数：棋子的起始行和列、骑士的起始行和列，以及棋盘的行数和列数。它会打印出一行输出，表示骑士是否获胜、僵局或失败。
- en: '[PRE7]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 5-3: The best outcome for the knight (bugged!)*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-3：骑士的最佳结果（有错误！）*'
- en: Let’s get a grip on this code by studying it in three chunks.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过分成三部分来研究这段代码，先抓住它的整体框架。
- en: The first chunk is the code that checks whether the knight can win. We begin
    by saving the pawn’s row in a new variable ➊—we’ll mess with the pawn’s row to
    move the pawn up the board, so we need to remember the row in which it originally
    started. The `while` loop keeps going as long as the pawn hasn’t reached the top
    row. On each iteration, we calculate the number of moves that the knight needs
    to get to the same location as the pawn. If the knight can get there at the same
    time as the pawn ➋, then the knight can win. If the knight can’t win, then the
    pawn will reach the top of the board and we’ll continue below the `while` loop.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是检查骑士是否能获胜的代码。我们首先将棋子的行保存到一个新变量中 ➊——我们将移动棋子的行，因此需要记住它最初所在的行。`while`循环会一直执行，直到棋子到达最上面的一行。每次循环时，我们都会计算骑士需要多少步才能到达与棋子相同的位置。如果骑士能在棋子到达时同时到达
    ➋，那么骑士就可以获胜。如果骑士无法获胜，棋子将到达棋盘顶部，我们将继续执行`while`循环之后的部分。
- en: That’s where the second chunk of code begins ➌. Its task is to determine whether
    the knight can cause a stalemate. The code is the same as the first chunk, except
    that in the `while` loop it checks the number of moves required for the knight
    to land on the row above the pawn rather than the row of the pawn.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是第二段代码开始的地方 ➌。它的任务是判断骑士是否能造成和棋。该段代码与第一段相同，只是在`while`循环中检查骑士到达兵上方行的位置所需的步数，而不是兵的行位置。
- en: The third chunk is a single line ➍, and it only executes if the knight cannot
    win or stalemate. This chunk simply outputs the loss message.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第三段是一个单独的代码行 ➍，只有在骑士无法获胜或和棋时才会执行。这段代码只是输出失败信息。
- en: That’s how we process a single test case. To read and process all of the test
    cases, we need a little `main` function; it’s as simple as [Listing 5-4](ch05.xhtml#ch05ex04).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们处理单个测试用例的方式。为了读取和处理所有测试用例，我们需要一个简单的`main`函数；它和[列表 5-4](ch05.xhtml#ch05ex04)一样简单。
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 5-4: The* main *function*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-4：* 主 *函数*'
- en: Feeling good? We’ve now got a complete solution. We’re using BFS to optimize
    the number of moves taken by the knight. We’re checking for knight wins, stalemates,
    and losses. Now submit this solution to the judge. Are you still feeling good?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 感觉不错吧？我们现在有了完整的解决方案。我们使用广度优先搜索（BFS）来优化骑士所需的移动次数。我们在检查骑士的胜利、和棋和失败情况。现在把这个解决方案提交给评审。你还感觉不错吗？
- en: '*The Knight Flip-Flop*'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*骑士反转*'
- en: 'In earlier chapters, I hit you with some solutions that were correct but too
    slow to pass the test cases. In contrast, what I’ve provided here for the Knight
    Chase problem is *incorrect*: there are test cases for which we produce the wrong
    output. Our code happens to be unnecessarily slow, too.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我曾给你提供一些正确但速度太慢的解决方案，无法通过测试用例。相反，我在这里为骑士追逐问题提供的解法是*错误的*：有些测试用例会输出错误结果。我们的代码也恰好过于缓慢。
- en: Let’s fix it all!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来修复这个问题！
- en: Making Our Code Correct
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使我们的代码正确
- en: Our code is incorrect because it does not consider that the knight can sometimes
    be too fast! That is, it can get to a pawn’s location before the pawn gets there.
    Testing for exactly the same number of pawn and knight moves is therefore too
    stringent.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码是错误的，因为它没有考虑到骑士有时会太快！也就是说，骑士可以在兵到达之前就到达兵的位置。因此，要求骑士和兵的移动次数完全相同的测试是过于严格的。
- en: 'A test case will clear this up:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试用例可以澄清这一点：
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is a board with five rows and three columns; the pawn starts at row 1,
    column 1 and the knight starts at row 3, column 1\. Here’s what our current code
    outputs for this test case:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个五行三列的棋盘；兵从第1行第1列开始，骑士从第3行第1列开始。以下是我们当前代码对此测试用例的输出：
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: (The output is `3`, not `4`, because the knight is not allowed to move once
    the pawn reaches the top row.) This means that there is no win or stalemate location
    for which the minimum number of knight moves is the same as the number of pawn
    moves. That, at least, is true. However, it’s still possible for the knight to
    win here and to do so in two moves. Take some time to try to identify how the
    knight can do this!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: （输出是`3`，而不是`4`，因为当兵到达顶行时，骑士不允许再移动。）这意味着不存在一个胜利或和棋位置，在该位置骑士的最少移动次数与兵的移动次数相同。至少这是事实。不过，骑士仍然可以在这里获胜，并且可以在两步内做到这一点。花点时间尝试找出骑士如何做到这一点吧！
- en: 'There’s no way for the knight to win in one move if the pawn is at (2, 1).
    However, after two moves, the pawn is at (3, 1), and it’s possible for the knight
    to land on (3, 1) after two moves, too. Here’s what the knight can do:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果兵在（2, 1）的位置，骑士不可能在一步内获胜。然而，经过两步之后，兵会到达（3, 1），此时骑士也有可能在两步后到达（3, 1）。以下是骑士可以采取的动作：
- en: 'Move 1: go from (3, 1) to (5, 2).'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1步：从（3, 1）到（5, 2）。
- en: 'Move 2: go from (5, 2) back to (3, 1).'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2步：从（5, 2）回到（3, 1）。
- en: The minimum number of moves for the knight to get to (3, 1) is zero— it’s the
    knight’s starting point, after all. By going to some other square and returning,
    the knight can land on (3, 1) not only after zero moves but after two moves as
    well.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 骑士到达（3, 1）的最少步数是零——毕竟这是骑士的起始位置。通过先去其他地方再返回，骑士不仅可以在零步内到达（3, 1），也可以在两步内到达。
- en: 'Here’s a self-check: change the knight’s starting point from (3, 1) to (5,
    3). Can you figure out how the knight can win now in three moves?'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自检：将骑士的起始位置从（3, 1）改为（5, 3）。你能弄明白骑士如何在三步内获胜吗？
- en: Generalizing, we can say that if the knight can get to a square in a minimum
    of *m* moves, then it can also get to that square in *m* + 2 moves, or *m* + 4
    moves, and so on. All it has to do is keep going to some other square and returning.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 概括来说，我们可以说，如果骑士能够在最少的*m*步内到达某个方格，那么它也可以在*m* + 2步、*m* + 4步等步数内到达该方格。它所要做的只是不断去其他方格再返回。
- en: 'What this means for our solution is that, at each step, there are two ways
    for the knight to win or stalemate: it can do so because its minimum number of
    moves matches the number of pawn moves or because its minimum number of moves
    is an even number larger than the number of pawn moves.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们的解决方案意味着，在每一步，骑士有两种方式可以获胜或和棋：一种是因为它的最少步数与兵的步数相同，另一种是因为它的最少步数是一个大于兵步数的偶数。
- en: 'That is, instead of:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，之前是：
- en: '[PRE11]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'we need this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是：
- en: '[PRE12]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we’re testing whether the difference between the number of pawn moves
    and the number of knight moves is a multiple of two.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在测试的是，兵的移动次数与骑士的移动次数之间的差是否是二的倍数。
- en: There are two instances of the incorrect code in [Listing 5-3](ch05.xhtml#ch05ex03);
    changing both yields the (correct!) code in [Listing 5-5](ch05.xhtml#ch05ex05).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-3](ch05.xhtml#ch05ex03)中有两个不正确的代码实例；更改这两个后，得到[列表 5-5](ch05.xhtml#ch05ex05)中的（正确的！）代码。'
- en: '[PRE13]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 5-5: The best outcome for the knight*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：骑士的最佳结果*'
- en: As promised, all we’ve done is change two conditions ➊ ➋. Now the code passes
    the judge.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的那样，我们所做的只是更改了两个条件 ➊ ➋。现在代码通过了判定。
- en: A Correctness Argument
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一个正确性论证
- en: If you’re suitably convinced of correctness, feel free to skip this section.
    Otherwise, I’d now like to address a possible concern that you may have at this
    point.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确信正确性，可以跳过这一部分。否则，我现在想解决一个你可能有的疑虑。
- en: Suppose that the knight gets to a square an even number of moves ahead of the
    pawn and that this takes *m* moves. Also suppose that the knight leaves and revisits
    this square as many times as it likes, returning to this square after *m* + 2
    moves, *m* + 4 moves, and so on, eventually catching the pawn here. It would be
    scary if the knight could use some other sequence of moves to catch the pawn in
    *m* + 1 moves, or *m* + 3 moves, and so on, because then adding an odd number
    of moves could provide us a better minimum than adding an even number of moves.
    Fortunately, that can’t happen.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 假设骑士用*m*步到达了一个方格，且这个方格比兵的移动提前了偶数步。还假设骑士可以随意离开并重新访问这个方格，每次都会在*m* + 2步、*m* + 4步等步数后回到该方格，最终在这里追上兵。如果骑士能用其他移动顺序，在*m*
    + 1步，或者*m* + 3步等奇数步后追上兵，那就很可怕了，因为那样加上奇数步可能会提供比加偶数步更小的最短步数。幸运的是，这种情况不会发生。
- en: 'Try this little experiment: choose a starting point and destination for the
    knight, and find the minimum number of moves that it takes for the knight to move
    from the starting point to the destination. That number of moves is *m*. Now try
    to find a way for the knight to get from that same starting point to that same
    destination using exactly one more move, or three more moves, and so on. For example,
    if the fastest way takes two moves, try to find a way to take three moves. You
    won’t be able to do so.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 试试这个小实验：选择一个起始点和目的地，找出骑士从起始点到目的地所需的最少步数。这个步数就是*m*。现在试着找到一种方法，让骑士从同样的起始点到同样的目的地，恰好用一步更多的步数，或者三步更多的步数，依此类推。例如，如果最快的方式需要两步，试着找到一个需要三步的方式。你是做不到的。
- en: Each knight move changes the row or column number by two and the other by one.
    For example, it might change the row number from six to four and the column number
    from four to five. Changing a number by two does not change whether that number
    is even or odd, but changing a number by one *does* change that number from even
    to odd or vice versa. That is, in terms of being even or odd, each move leaves
    one of the two numbers (row or column) alone, and it changes the other one. When
    a number changes from even to odd or vice versa, we say that its *parity* changes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每次骑士移动都会让行号或列号变化两个单位，另一个变化一个单位。例如，它可能把行号从六变成四，把列号从四变成五。改变一个数字两个单位不会改变该数字是偶数还是奇数，但改变一个数字一个单位*会*让该数字从偶数变为奇数，反之亦然。也就是说，就偶数或奇数而言，每次移动都会保持其中一个数字（行号或列号）不变，改变另一个数字。当一个数字从偶数变为奇数或反之时，我们说它的*奇偶性*发生了变化。
- en: Let *k* be an odd integer. Now we’re ready to see why the knight can’t take
    both *m* moves and *m* + *k* moves to get to the same destination. Suppose that
    the knight can take *m* moves to get to square *s*, that *m*[1] of those moves
    change whether the row is even or odd, and that *m*[2] of those moves change whether
    the column is even or odd.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 设*k*为奇数。现在我们准备来看为什么骑士不能用*m*步和*m* + *k*步到达同一目的地。假设骑士可以用*m*步到达格子*s*，其中*m*[1]步改变行的奇偶性，*m*[2]步改变列的奇偶性。
- en: 'Let’s say that *m*[1] and *m*[2] are both even. As such, the moves don’t change
    the parity of the row or column: if we start with some number and flip its parity
    an even number of times, its parity doesn’t change. If we make some other sequence
    of moves, and it flips the parity of the row an odd number of times or flips the
    parity of the column an odd number of times, then that sequence cannot land at
    *s*, because it will land on a square with different row or column parity than
    *s*.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*m*[1]和*m*[2]都是偶数。如此一来，这些步伐不会改变行或列的奇偶性：如果我们从某个数字开始，并将其奇偶性翻转偶数次，那么它的奇偶性不会改变。如果我们进行其他一系列的移动，且它改变了行的奇偶性奇数次或改变了列的奇偶性奇数次，那么该序列不能到达*s*，因为它将落在一个与*s*具有不同行或列奇偶性的格子上。
- en: 'Now, *m*, the total number of moves *m*[1] + *m*[2], is even: adding two even
    numbers gives an even number. But, *m* + *k* is odd, because it’s the sum of an
    even number and an odd number. And, since *m* + *k* is odd, it cannot be built
    from an even number of moves that change the row and an even number of moves that
    change the column; at least one of them must be odd and therefore change the parity
    of the row or column. This is why these *m* + *k* moves cannot result in the knight
    landing on *s*! (There are three other cases—*m*[1] even and *m*[2] odd, *m*[1]
    odd and *m*[2] even, and *m*[1] odd and *m*[2] odd—but I’ll skip those. Their
    analysis is similar.)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，*m*是总步数，*m*[1] + *m*[2]是偶数：两个偶数相加得偶数。但是，*m* + *k*是奇数，因为它是一个偶数和一个奇数的和。由于*m*
    + *k*是奇数，它不能由改变行奇偶性的偶数步和改变列奇偶性的偶数步构成；至少有一个必须是奇数，从而改变行或列的奇偶性。这就是为什么这些*m* + *k*步不能让骑士落在*s*的原因！（还有三种其他情况——*m*[1]偶数，*m*[2]奇数；*m*[1]奇数，*m*[2]偶数；*m*[1]奇数，*m*[2]奇数——但我跳过了这些。它们的分析是类似的。）
- en: '*A Time Optimization*'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*时间优化*'
- en: Our current solution ([Listing 5-5](ch05.xhtml#ch05ex05)) can make a lot of
    BFS calls. Each time the pawn moves up a row, we use BFS (by calling `find_distance`)
    to determine whether it can be caught there by the knight.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的解决方案（[示例 5-5](ch05.xhtml#ch05ex05)）可能会进行很多BFS调用。每当兵向上一行移动时，我们就使用BFS（通过调用`find_distance`）来判断骑士是否能在该位置抓住兵。
- en: Suppose that the pawn starts at (1, 1). We run a BFS from the knight’s starting
    point to (1, 1), and that explores some of the squares. Suppose that the knight
    can’t catch the pawn here. We then have to run a BFS from the knight’s starting
    point to (2, 1). This explores some of the squares, too. However, (1, 1) and (2,
    1) are very close together, to the point that the second BFS probably re-explores
    many of the squares whose shortest distances were discovered in the first BFS
    call. Unfortunately, each of our BFS calls is independent, so that second BFS
    call redoes a lot of the work that the first BFS call did. The third call then
    duplicates a lot of what the prior two BFS calls did, and on and on.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 假设兵从（1，1）位置开始。我们从骑士的起始点运行BFS到（1，1），并探索了一些格子。假设骑士在这里无法抓住兵。接着，我们需要从骑士的起始点运行BFS到（2，1）。这也会探索一些格子。然而，（1，1）和（2，1）非常接近，以至于第二次BFS可能会重新探索很多在第一次BFS调用中已发现的最短距离。不幸的是，我们每次的BFS调用是独立的，所以第二次BFS会重新做很多第一次BFS已完成的工作。第三次调用又会重复前两次BFS做的工作，如此循环。
- en: It’s true that BFS is fast, and I’ll give more details on why in the next section.
    Still, it pays to try to reduce the number of invocations of BFS.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，广度优先搜索（BFS）很快，我将在下一节中详细解释原因。不过，减少BFS调用的次数是值得尝试的。
- en: 'I have good news: we can reduce the number of BFS calls to just . . . one!
    Recall our BFS code in [Listing 5-1](ch05.xhtml#ch05ex01). We had code ➍ to cut
    our BFS short if we found the target position. However, if this code is removed,
    then the BFS will explore the entire board, calculating the shortest distance
    to each square. Making that change means that we can make one call to BFS and
    then be done with it. From then on, we just look up what we need in the `min_moves`
    array.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我有个好消息：我们可以将BFS调用的次数减少到仅仅一次！回想一下我们在[列表5-1](ch05.xhtml#ch05ex01)中的BFS代码。我们曾使用代码➍来缩短BFS过程，如果找到了目标位置就停止。但是，如果去掉这段代码，BFS将遍历整个棋盘，计算每个方格的最短距离。做出这个改变后，我们只需要调用一次BFS，然后就可以结束。从那时起，我们只需查看`min_moves`数组中的数据。
- en: Do it! Make the required changes to the code so that BFS is called only one
    time.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 去做吧！对代码进行必要的更改，使得BFS仅被调用一次。
- en: The code we worked through together takes 0.1 seconds when I submit to the judge.
    With the “only one invocation of BFS” optimization, the code takes only 0.02 seconds,
    a speedup of 500 percent. More importantly, this optimization shows that BFS can
    be used not only to find the shortest distance from a starting position to some
    other position, but also to find the distance from the starting position to *all*
    other positions. I’ll discuss BFS a little more in the next section. And keep
    reading after that, because I think the flexibility of BFS is going to surprise
    you.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一起讨论的代码在提交给判题系统时需要0.1秒。经过“仅调用一次BFS”的优化后，代码只需0.02秒，速度提升了500%。更重要的是，这项优化展示了BFS不仅可以用来找到从起始位置到其他某个位置的最短距离，还可以用来找到从起始位置到*所有*其他位置的距离。我将在下一节中稍微多谈一些BFS，之后继续阅读下去，因为我认为BFS的灵活性会让你感到惊讶。
- en: Graphs and BFS
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图与广度优先搜索（BFS）
- en: BFS is a powerful search algorithm, as we saw in the solution to the Knight
    Chase problem. To run a BFS, we need what’s called a *graph*. We didn’t think
    about graphs when solving the Knight Chase problem—or perhaps didn’t know what
    they were!—but there was indeed a graph underlying the BFS.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: BFS是一个强大的搜索算法，正如我们在解决骑士追逐问题时看到的那样。要运行BFS，我们需要所谓的*图*。在解决骑士追逐问题时，我们并没有考虑图的概念——或者说，我们可能不知道它是什么！——但实际上，BFS背后确实存在一个图。
- en: '*What Are Graphs?*'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*什么是图？*'
- en: '[Figure 5-1](ch05.xhtml#ch05fig01) is our first example of a graph.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-1](ch05.xhtml#ch05fig01)是我们的第一个图的例子。'
- en: '![Image](../images/ch05fig01.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/ch05fig01.jpg)'
- en: '*Figure 5-1: A graph of knight moves*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-1：骑士移动的图*'
- en: Like a tree, a graph consists of *nodes* (the boxes) and *edges* between nodes
    (the lines). In this graph, the edges represent valid knight moves. For example,
    from the (5, 1) node, the knight can move on an edge to (4, 3) or on an edge to
    (3, 2). There are no other edges involving (5, 1), so there are no other knight
    moves from there.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 像树一样，图由*节点*（框框）和节点之间的*边*（线条）组成。在这个图中，边表示有效的骑士移动。例如，从(5, 1)节点，骑士可以沿着一条边移动到(4,
    3)，或者沿着另一条边移动到(3, 2)。(5, 1)没有其他的边，因此从这个位置没有其他骑士的移动。
- en: 'Now I can explain how we implicitly used a graph to solve the Knight Chase
    problem. Suppose that (5, 1) is the knight’s starting position. Our BFS tries
    all eight moves from there, but six of them lead to a position that is outside
    of the board; in graph terminology, six of them are not edges from (5, 1). The
    BFS discovers the two nodes that *are* reachable on an edge from (5, 1): (4, 3)
    and (3, 2). The exploration then continues with the nodes reachable from each
    of these two nodes, and so on.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以解释我们是如何隐式地使用图来解决骑士追逐问题的。假设(5, 1)是骑士的起始位置。我们的BFS尝试从那里进行八个移动，但其中六个会导致位置超出棋盘；用图论术语来说，这六个不算是(5,
    1)的边。BFS发现从(5, 1)出发，只有两个节点*是*可以通过边到达的： (4, 3)和(3, 2)。接下来，探索将继续进行，查找从这两个节点可以到达的其他节点，以此类推。
- en: I laid the graph out as a grid to reflect the underlying board, but the way
    that a graph is drawn carries no meaning. All that matters are the nodes and edges.
    I could have drawn the graph with the nodes chaotically spread around, and it
    would have conveyed the same meaning. However, when the graph is rooted in some
    underlying geometry, it makes sense to display the graph in a corresponding way
    for easier interpretation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我将图形布局为网格，以反映底层棋盘，但图形的绘制方式并没有实际意义。真正重要的是节点和边。即使我将节点杂乱无章地分布开来，图形仍能传达相同的含义。然而，当图形基于某些底层几何结构时，以对应的方式展示图形就显得更为直观，便于理解。
- en: To solve the Knight Chase problem, we didn’t need to explicitly represent the
    graph in code, because we figured out the available moves (edges) from each node
    as we explored the board. Sometimes, though, we do need to represent a graph explicitly
    in code, along the lines of our tree representations in [Chapter 2](ch02.xhtml).
    We’ll see how to do that in Problem 3.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决骑士追逐问题，我们并不需要在代码中显式地表示图，因为在我们探索棋盘时，我们已经弄清楚了从每个节点出发的可用移动（边）。然而，有时我们确实需要在代码中显式表示一个图，类似于我们在[第二章](ch02.xhtml)中对树的表示。我们将在问题
    3 中看到如何做。
- en: '*Graphs vs. Trees*'
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*图与树*'
- en: Graphs and trees have a lot in common. They’re both used to represent relationships
    between nodes. In fact, every tree is a graph, but there are graphs that are not
    trees. Graphs are more general, and they can express more than what trees can
    express.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图和树有很多相似之处。它们都用于表示节点之间的关系。事实上，每一棵树都是一个图，但也有一些图不是树。图更一般化，可以表示树无法表示的内容。
- en: 'First, graphs (but not trees) allow cycles. We have a *cycle* in a graph if
    we can start from a node and get back to it without using any repeated edges or
    nodes. (The first and last nodes in the cycle are the only ones that repeat.)
    Look back at [Figure 5-1](ch05.xhtml#ch05fig01). Here’s a cycle in that graph:
    (5, 3) → (4, 5) → (3, 3) → (4, 1) → (5, 3).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，图（但不是树）允许循环。如果一个图中我们可以从一个节点出发，经过一些边返回到这个节点，并且没有使用任何重复的边或节点，那么这个图中就有一个*循环*。（循环中的第一个和最后一个节点是唯一重复的。）回顾[图
    5-1](ch05.xhtml#ch05fig01)，在这个图中有一个循环：(5, 3) → (4, 5) → (3, 3) → (4, 1) → (5,
    3)。
- en: Second, graphs (but not trees) can be *directed*. The trees and graph we’ve
    seen so far are *undirected*, meaning that if two nodes *a* and *b* are connected
    by an edge, then we can travel both from *a* to *b* and from *b* to *a*. The graph
    in [Figure 5-1](ch05.xhtml#ch05fig01) is undirected; for example, we can move
    from (5, 3) on an edge to (4, 5) and use that same edge to move from (4, 5) to
    (5, 3). Sometimes, though, we want to allow travel in only one direction, not
    the other. A *directed* graph is a graph in which each edge indicates the allowed
    direction of travel. [Figure 5-2](ch05.xhtml#ch05fig02) depicts a directed graph.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，图（但不是树）可以是*有向的*。我们到目前为止看到的树和图都是*无向的*，这意味着如果两个节点*a*和*b*通过一条边连接，那么我们既可以从*a*到*b*，也可以从*b*到*a*。
    [图 5-1](ch05.xhtml#ch05fig01)中的图是无向的；例如，我们可以沿着一条边从(5, 3)到(4, 5)，并用同一条边从(4, 5)回到(5,
    3)。然而，有时我们只想允许单向旅行，而不允许反向。*有向图*是指每条边表示允许的旅行方向。[图 5-2](ch05.xhtml#ch05fig02)展示了一个有向图。
- en: '![Image](../images/ch05fig02.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch05fig02.jpg)'
- en: '*Figure 5-2: A directed graph*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：有向图*'
- en: Note, in [Figure 5-2](ch05.xhtml#ch05fig02), how it’s possible to move from
    E to each of the other nodes, but it is not possible to move from any of those
    nodes to E. The edges are one-way edges.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[图 5-2](ch05.xhtml#ch05fig02)中，如何可以从E节点移动到其他每一个节点，但无法从这些节点中的任何一个移动到E节点。边是单向的。
- en: Directed graphs are useful whenever an undirected graph would lead to loss of
    information. In my Computer Science department, each course has one or more prerequisite
    courses. For example, we have a C Programming course, which requires that students
    have already taken our Software Design course. A directed edge Software Design
    → C Programming captures this relationship. Had we used an undirected edge, we’d
    still know that the courses were related, but we wouldn’t know the order in which
    the courses must be taken. [Figure 5-3](ch05.xhtml#ch05fig03) shows a small prerequisite
    graph.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有向图在无向图可能导致信息丢失的情况下非常有用。在我的计算机科学系，每个课程都有一个或多个先修课程。例如，我们有一门C编程课程，要求学生已经学习过我们的软件设计课程。一个有向边“软件设计
    → C 编程”表示了这个关系。如果我们使用无向边，虽然我们仍然知道这些课程之间有关系，但我们就无法知道课程必须按照什么顺序来修。 [图 5-3](ch05.xhtml#ch05fig03)展示了一个小的先修课程图。
- en: '![Image](../images/ch05fig03.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch05fig03.jpg)'
- en: '*Figure 5-3: A graph of course prerequisites*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：课程先修图*'
- en: The third thing that makes graphs more general than trees is that graphs can
    be *disconnected*. All trees and graphs we have seen to this point are *connected*,
    which means that you can get from any node to any other node. Now check out the
    disconnected graph in [Figure 5-4](ch05.xhtml#ch05fig04).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图表比树更一般化的第三个特点是图可以是*不连通的*。到目前为止我们看到的所有树和图都是*连通的*，这意味着你可以从任意一个节点到达任何其他节点。现在看看[图
    5-4](ch05.xhtml#ch05fig04)中的不连通图。
- en: '![Image](../images/ch05fig04.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch05fig04.jpg)'
- en: '*Figure 5-4: A graph of disconnected course prerequisites*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：不连通的课程先修图*'
- en: It’s disconnected because, for example, you can’t follow a path from *Intro
    to Programming* to *World Prehistory*. Disconnected graphs are useful whenever
    a graph is naturally composed of separate pieces.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 它是断开的，因为例如，你不能从*编程入门*跳到*世界史前*。当一个图自然由多个独立部分组成时，断开图是非常有用的。
- en: '*BFS on Graphs*'
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*图上的BFS*'
- en: 'We can run BFS on an undirected graph (as we did for the Knight Chase problem)
    or a directed graph. The algorithm is the same: we go through the possible moves
    from the current node and explore them. BFS is known as a *shortest-path* algorithm:
    among all paths between a starting node and some other node, BFS gives us the
    shortest one in terms of the number of edges. As long as what we care about is
    minimizing the number of edges, it solves the *single-source shortest-paths* problem,
    since it finds shortest paths from a single source (or starting) node.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在无向图（正如我们在“骑士追逐问题”中所做的那样）或有向图上运行广度优先搜索（BFS）。算法是相同的：我们从当前节点开始，遍历可能的移动并探索它们。BFS被称为*最短路径*算法：在从起始节点到其他节点的所有路径中，BFS会给我们返回最短的一条（以边数为标准）。只要我们关心的是最小化边数，它就能解决*单源最短路径*问题，因为它找到的是从单一源（或起始）节点到其他节点的最短路径。
- en: 'What we need to control to make BFS fast is not whether the graph is undirected
    or directed, but the number of times we invoke BFS and the number of edges in
    the graph. The runtime of a BFS call is proportional to the number of edges reachable
    from the starting node. That’s because BFS looks at each edge once to determine
    whether it leads to the discovery of a new node. We call BFS a linear-time algorithm,
    since it does work linear in the number of edges: if 5 edges takes 5 steps for
    BFS to explore it, then 10 edges will take 10 steps. We’ll use the number of edges
    to estimate the number of steps performed by BFS.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让BFS运行更快，我们需要控制的不是图是有向图还是无向图，而是我们调用BFS的次数和图中的边数。BFS调用的运行时间与从起始节点可达的边数成正比。这是因为BFS每次检查每条边，判断它是否会发现一个新的节点。我们称BFS为线性时间算法，因为它的工作量是与边数成线性关系的：如果5条边需要5步来探索，那么10条边需要10步。我们将使用边的数量来估算BFS执行的步数。
- en: 'In the Knight Chase problem, we had a board with *r* rows and *c* columns.
    Each node has at most eight edges, so the board has at most 8*rc* edges in total.
    Therefore, running one BFS takes 8*rc* steps. For the biggest board, 99×99, this
    is fewer than 80,000 steps. If we call BFS on the order of *r* times, as can happen
    in [Listing 5-5](ch05.xhtml#ch05ex05), then we’re looking at 8*r*²*c* steps. Now
    the 99×99 board isn’t looking so good: it could take over 7 million steps. This
    is why it helps so much to reduce the number of calls of BFS!'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在“骑士追逐问题”中，我们有一个*r*行和*c*列的棋盘。每个节点最多有八条边，因此棋盘总共有最多8*rc*条边。因此，运行一次BFS需要8*rc*步。对于最大的棋盘99×99，这还不到80,000步。如果我们像在[清单5-5](ch05.xhtml#ch05ex05)中那样调用BFS
    *r*次，那么我们就需要进行8*r*²*c*步。现在99×99的棋盘看起来就不那么理想了：可能需要超过700万步。这就是为什么减少BFS调用次数会有如此大的帮助！
- en: Any time a problem involves a set of objects (board locations, courses, people,
    websites, and so on) and relationships between those objects, it’s a good bet
    that modeling the problem as a graph will help. Once you model a problem as a
    graph, you can take advantage of a huge number of fast algorithms on graphs. BFS
    is one of those algorithms.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个问题涉及一组对象（如棋盘位置、课程、人员、网站等）以及这些对象之间的关系时，将该问题建模为图通常是一个好方法。一旦将问题建模为图，你就可以利用图论中大量的快速算法。BFS就是其中之一。
- en: '*Graphs vs. Dynamic Programming*'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*图论与动态规划*'
- en: 'Sometimes it can be difficult to determine whether to use dynamic programming
    or a graph to solve a problem. The giveaway is often the presence of a cycle:
    if you have a cycle, then you need a graph.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候很难判断是使用动态规划还是图论来解决一个问题。一个明显的标志通常是是否存在循环：如果有循环，那么你需要使用图论。
- en: None of the problems that we solved in [Chapter 3](ch03.xhtml) or [Chapter 4](ch04.xhtml)
    had a cycle. In Burger Fervor we recursed with fewer minutes. In Moneygrubbers
    we recursed with fewer needed apples. In Hockey Rivalry we recursed with fewer
    games. We always go down—there’s no way to loop back to a higher number of minutes
    or apples or games to cause a cycle.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](ch03.xhtml)和[第4章](ch04.xhtml)中解决的所有问题都没有循环。在《汉堡热潮》中，我们使用了更少的时间递归。在《贪婪的商人》中，我们使用了更少的苹果进行递归。在《冰球对决》中，我们使用了更少的比赛进行递归。我们总是向下走——没有办法回到更高的时间、苹果或比赛数值，从而形成循环。
- en: It’s trickier to see that this is true for The Jumper in [Chapter 4](ch04.xhtml),
    but it is. Think back to our forward formulation. If we jump to the right, then
    we recurse with a bigger jump distance. If we jump to the left, then we recurse
    with the same jump distance but a smaller-numbered square. There’s no way to start
    at a given subproblem and get back to it using these jumps. You might try to do
    that by making some jumps to the left and then making a jump to the right—but
    your jump to the right will have increased the jump distance by one and there’s
    no way to decrease it by one ever again.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结论对于 [第4章](ch04.xhtml)中的跳跃者来说更难以察觉，但它确实成立。回想我们之前的前向推导。如果我们向右跳，那么我们就会递归地增加跳跃距离。如果我们向左跳，那么我们会以相同的跳跃距离递归，但方格编号会更小。没有办法从某个子问题开始，然后通过这些跳跃回到原点。你可能尝试先向左跳，再向右跳，但向右跳时，跳跃距离会增加一个单位，而你永远无法再减少它。
- en: No cycle!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 没有循环！
- en: 'Problem 2: Rope Climb'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题2：爬绳
- en: In the Knight Chase problem, we were explicitly given a board on which a game
    takes place. Here, we won’t be given the board directly, so we’ll have to work
    it out. Again, the strategy will be to model valid moves using BFS.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在骑士追逐问题中，我们明确给出了一个棋盘，游戏将在其上进行。在这里，我们不会直接给出棋盘，所以我们需要自己推导出来。策略仍然是使用 BFS 模拟有效的移动。
- en: This is DMOJ problem `wc18c1s3`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `wc18c1s3`。
- en: '*The Problem*'
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: Bob is asked to climb a rope in gym class. The rope is infinitely long, but
    Bob is being asked to get only to a height of at least *h* meters.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Bob 被要求在体育课上爬一根绳子。绳子是无限长的，但 Bob 被要求至少达到 *h* 米的高度。
- en: 'Bob starts at a height of 0\. He knows how to jump up by exactly *j* meters,
    but that’s the only jump he knows how to do—so if *j* is `5`, then he can’t jump
    up four or six meters or any other number of meters except five. In addition,
    Bob knows how to fall, and he can fall down any number of meters: one, two, three,
    and so on.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Bob 从 0 米的高度开始。他知道如何跳升恰好 *j* 米，但这就是他唯一能做的跳跃——所以如果 *j* 是 `5`，他就不能跳升四米、六米或其他任意的米数。另外，Bob
    知道如何下落，他可以下落任何米数：一米、两米、三米，以此类推。
- en: Each jump or fall counts as one move. For example, if Bob jumps up five meters,
    falls down two meters, jumps up five meters, and falls down eight meters, then
    Bob will have made four moves.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 每一次跳跃或下落都算作一次移动。例如，如果 Bob 跳升五米，下落两米，再跳升五米，然后下落八米，那么 Bob 将做出四次移动。
- en: 'Now, here’s the fun part: Alice has spread itching powder on some segments
    of the rope. If such a segment goes from height *a* to height *b*, then the entire
    segment from *a* to *b*, including the endpoints *a* and *b*, has itching powder.
    The effect that the itching powder has on Bob’s moves is as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这就是有趣的部分：Alice 在绳索的某些段落上撒了痒粉。如果某段绳索的高度从 *a* 变化到 *b*，那么从 *a* 到 *b* 的整个段落，包括端点
    *a* 和 *b*，都会有痒粉。痒粉对 Bob 移动的影响如下：
- en: Bob cannot jump up *j* meters if that would land him on itching powder.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果跳跃 *j* 米会让 Bob 落到痒粉上，那么 Bob 不能跳跃。
- en: Bob cannot fall down a given number of meters if that would land him on itching
    powder.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果跳跃会让 Bob 落到痒粉上，那么 Bob 就不能下落特定的米数。
- en: The goal is to determine the minimum number of moves needed for Bob to get to
    height *h* or higher.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是确定 Bob 到达高度 *h* 或更高所需的最少移动次数。
- en: Input
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input contains one test case, consisting of the following lines:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含一个测试用例，包含以下行：
- en: 'A line containing three integers: *h*, *j*, and *n*. *h* tells us the minimum
    height that Bob must reach, *j* is the distance that Bob can jump up, and *n*
    is the number of segments on which Alice has spread itching powder. Each integer
    is at most 1,000,000, and *j* is at most *h*.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含三个整数：*h*、*j* 和 *n*。*h* 告诉我们 Bob 必须达到的最低高度，*j* 是 Bob 每次能跳跃的距离，*n* 是 Alice
    撒上痒粉的段数。每个整数最大为 1,000,000，且 *j* 不超过 *h*。
- en: '*n* lines, each of which contains two integers. The first integer gives the
    starting height for a segment of rope with itching powder; the second gives the
    ending height. Each integer is at most *h* – 1.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行包含两个整数。第一个整数给出一段有痒粉的绳索的起始高度，第二个整数给出结束高度。每个整数最大为 *h* - 1。'
- en: Output
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: Output the minimum number of moves needed for Bob to reach height *h* or higher.
    If there is no way for Bob to reach height *h* or higher, output `-1`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 输出 Bob 达到高度 *h* 或更高所需的最少移动次数。如果 Bob 无法达到高度 *h* 或更高，则输出 `-1`。
- en: The time limit for solving the test case is 1.8 seconds.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制为 1.8 秒。
- en: '*Solution 1: Finding the Moves*'
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解法1：寻找移动次数*'
- en: Let’s start by making direct comparisons to the Knight Chase problem. Notice
    in both cases that our goal is to minimize the number of moves. Whether it’s a
    knight on a board or Bob on a rope, the goal is the same. It’s true that the knight
    was moving around a two-dimensional board and Bob is moving around a one-dimensional
    rope, but that just changes how we’ll refer to each position. BFS won’t otherwise
    care about the change from two dimensions to one. If anything, dropping one dimension
    simplifies things a little!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过直接与骑士追逐问题进行比较来开始。注意，在这两种情况下，我们的目标都是最小化移动的次数。无论是棋盘上的骑士，还是绳子上的鲍勃，目标都是一样的。虽然骑士在二维棋盘上移动，而鲍勃在一维绳子上移动，但这只是改变了我们如何描述每个位置。BFS（广度优先搜索）不会在意从二维到一维的变化。如果有什么不同的话，减少一个维度反而让事情变得简单了一些！
- en: 'How about the number of possible moves from each position? The knight had at
    most eight of those. In contrast, the number of possible moves Bob can make increases
    with his position. For example, if Bob is at a height of 4, and he can jump up
    by 5, then he has five possible moves: jump up by 5, fall down by 1, fall down
    by 2, fall down by 3, or fall down by 4\. If Bob is at a height of 1,000, then
    he has 1,001 possible moves! So we’ll have to take Bob’s current position into
    account when determining the number of available moves.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 那么每个位置的可能移动次数呢？骑士最多有八种移动方式。相对而言，鲍勃的可移动次数随着他的当前位置而增加。例如，如果鲍勃处于高度4，并且他能跳升5个单位，那么他有五种可能的移动方式：跳升5，降下1，降下2，降下3，或降下4。如果鲍勃在高度1000，那么他有1001种可能的移动方式！因此，我们在确定可用的移动次数时，必须考虑鲍勃的当前位置。
- en: 'What about the itching powder? Knight Chase doesn’t have anything resembling
    that. Let’s look at a test case to see what we’re up against here:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 那痒粉呢？骑士追逐问题中并没有类似的东西。让我们通过一个测试案例来看看我们遇到的情况：
- en: '[PRE14]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Bob has to get to a height of 10 or higher. He can jump up by four. So, if there
    were no itching powder, he’d be able to jump from a height of 0 to 4, then to
    8, and then to 12\. That’s three moves.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃必须达到10或更高的高度。他可以跳升4个单位。因此，如果没有痒粉，他就能从高度0跳到4，再跳到8，最后跳到12。这是三次移动。
- en: Bob can’t do that, though! He isn’t allowed to jump from 4 to 8, because there’s
    itching powder at a height of 8 (as the itching powder goes from 8 to 9). The
    solution, by factoring in the itching powder, is four moves. For example, Bob
    can jump from 0 to 4, then fall to 3, then jump to 7, and then jump to 11\. That
    jump from 7 to 11 breezes right past the itching powder.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，鲍勃不能这样做！他不能从4跳到8，因为8处有痒粉（痒粉从8到9）。考虑到痒粉的影响，解决方案是四次移动。例如，鲍勃可以从0跳到4，然后降到3，再跳到7，最后跳到11。那从7到11的跳跃轻松避开了痒粉。
- en: 'The move from 4 to 8 seems available based on Bob’s ability to jump up by four,
    but it is actually not available because of the itching powder. This isn’t so
    different than a knight move being unavailable because it would take the knight
    outside of the board. For those invalid knight moves, we detected them in the
    BFS and didn’t add them to the next round of positions. We’ll handle itching powder
    similarly: any move that would cause Bob to land on itching powder will be disallowed
    in our BFS code.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 从4到8的移动似乎是可行的，因为鲍勃能够跳升4个单位，但实际上它不可行，因为有痒粉。这与骑士的某些不可行的移动类似，后者是因为该移动会导致骑士超出棋盘范围。对于这些无效的骑士移动，我们在BFS中进行了检测，并没有将它们添加到下一轮的位置中。我们将以类似的方式处理痒粉：任何导致鲍勃落到痒粉上的移动都会在我们的BFS代码中被禁止。
- en: Speaking of those invalid knight moves that take the knight outside of the board,
    do we have to worry about that kind of thing here? The rope is infinitely long,
    so we won’t break any rules by letting Bob climb higher and higher. However, at
    some point we really do have to stop; otherwise, the BFS will forever be finding
    and exploring new positions. I’ll invoke the insight from Moneygrubbers in [Chapter
    3](ch03.xhtml) that helped us out of a very similar bind when buying apples. We
    said there that if we’re asked to buy 50 apples, then we should consider buying
    at most 149 apples, because each pricing scheme gives us at most 100 apples. Here,
    remember from the problem description that *j*, the distance that Bob jumps up,
    is at most *h*, the minimum target height. We shouldn’t let Bob get to height
    2*h* or higher. Think about what it would mean the first time we got Bob to height
    2*h* or higher. One move prior, Bob would have been at height 2*h* – *j* ≥ *h*,
    and that would have taken one move less than getting Bob to height 2*h*! Thus,
    getting Bob to height 2*h* or higher can’t be the fastest way to get him to at
    least height *h*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 说到那些无效的骑士移动，它们会让骑士超出棋盘范围，我们在这里需要担心这种情况吗？绳子是无限长的，所以我们不会通过让Bob不断攀爬而违反任何规则。然而，某个时刻我们确实需要停止；否则，BFS将永远在寻找并探索新位置。我将引用《Moneygrubbers》第3章中的洞察力，这帮助我们在购买苹果时解决了一个非常相似的困境。我们曾说过，如果要求我们购买50个苹果，那么我们应该考虑最多购买149个苹果，因为每种定价方案最多给我们100个苹果。在这里，请记住从问题描述中得知，*j*，Bob的跳跃距离，最多为*h*，目标最小高度。因此，我们不应该让Bob的高度达到2*h*或更高。想一想，当我们第一次让Bob达到高度2*h*或更高时会发生什么。在前一次移动中，Bob的高度是2*h*
    – *j* ≥ *h*，那样就比将Bob移到高度2*h*少了一步！因此，让Bob达到2*h*或更高的高度不能是将他至少带到高度*h*的最快方式。
- en: Implementing Breadth-First Search
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现广度优先搜索
- en: 'We’ll very closely follow what we did for the Knight Chase problem, making
    changes only when necessary. Back then, each knight position consisted of both
    a row and a column, so we created a struct to hold both of those pieces of information.
    Now, a position on a rope is just an integer, so we don’t need a struct for that.
    We’ll make type definitions for the “board” and the positions discovered by BFS:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将紧密跟随当时在骑士追击问题中所做的工作，只在必要时进行修改。那时，每个骑士的位置由行和列组成，因此我们创建了一个结构体来保存这两个信息。而现在，绳上的位置只是一个整数，因此我们不需要结构体。我们将为“棋盘”和BFS发现的位置创建类型定义：
- en: '[PRE15]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It may seem a little weird to call a rope a board, I suppose, but it serves
    the same purpose as the corresponding type definition in the Knight Chase problem,
    so let’s stick with it.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我想，称绳子为棋盘可能有点奇怪，但它和骑士追击问题中相应类型定义的作用是一样的，所以我们还是使用这个词吧。
- en: We’re eventually going to make a single call of BFS, and that call is going
    to calculate the minimum number of moves for Bob to get from a height of zero
    to each valid position. The code for the BFS is given in [Listing 5-6](ch05.xhtml#ch05ex06)—compare
    this to the `find_distance` code in [Listing 5-1](ch05.xhtml#ch05ex01). (Especially,
    compare it to the code I hope you wrote after reading “A Time Optimization” on
    [page 168](ch05.xhtml#sec69).)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终将进行一次BFS调用，这个调用将计算Bob从零高度到达每个有效位置的最小移动次数。BFS的代码在[列表 5-6](ch05.xhtml#ch05ex06)中给出——可以与[列表
    5-1](ch05.xhtml#ch05ex01)中的`find_distance`代码进行对比。（特别是，将其与我希望你在阅读《时间优化》一节后编写的代码进行比较，参见[第168页](ch05.xhtml#sec69)。）
- en: '[PRE16]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 5-6: Minimum number of moves for Bob using BFS*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-6：Bob使用BFS的最小移动次数*'
- en: 'There are four parameters for this `find_distances` function:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`find_distances`函数有四个参数：
- en: target_height   The minimum height that Bob must reach. It’s the *h* value from
    the test case.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: target_height   Bob必须达到的最小高度。它是测试用例中的*h*值。
- en: jump_distance   The distance that Bob can jump up. It’s the *j* value from the
    test case.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: jump_distance   Bob可以跳跃的距离。它是测试用例中的*j*值。
- en: 'itching   An array that indicates where itching powder is present. If `itching[i]`   is
    `0`, then there’s no itching powder at height `i`; otherwise, there is. (Looking
    ahead, we’ll have to build this array from the segments of itchy rope given in
    the test case. But we’ll be able to do that, and then we won’t have to worry about
    the particular segments themselves: we can just index this array.)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: itching   一个数组，用于指示哪里有痒粉。如果`itching[i]`为`0`，则在高度`i`处没有痒粉；否则，表示有痒粉。（展望未来，我们需要根据测试用例中给出的痒绳段来构建这个数组。但我们能够做到这一点，这样就不需要担心具体的绳段本身了：我们只需索引这个数组即可。）
- en: min_moves   The board in which we’ll store the minimum number of moves to get
    to each position.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: min_moves   存储到达每个位置的最少移动次数的棋盘。
- en: As in [Listing 5-1](ch05.xhtml#ch05ex01) for Knight Chase, we initialize each
    position of the board to `-1` ➊, which means that BFS hasn’t found this position
    yet. That initialization, as with any other manipulation of `board` here, indexes
    a one-dimensional (not two-dimensional!) array. Other than that, the structure
    is quite similar to the BFS code for Knight Chase.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[列表 5-1](ch05.xhtml#ch05ex01)中为骑士追逐初始化，我们将棋盘上的每个位置初始化为`-1` ➊，这意味着 BFS 尚未找到该位置。与这里对`board`的其他操作一样，这种初始化操作索引的是一维（而非二维！）数组。除此之外，结构与骑士追逐的
    BFS 代码非常相似。
- en: 'There is, however, an interesting structural change to the code that adds positions.
    Bob has exactly one jump distance, so there’s only one jump move to consider ➋:
    Bob starts at `from_height` and ends up, if it’s a valid position, at `from_height
    + jump_distance`. We can use `target_height * 2 - 1` to get the maximum height
    that Bob is allowed to reach. For falling down, we cannot hard-code Bob’s available
    moves; those moves depend on Bob’s current height. To handle that, we use a loop
    ➌ to consider all destination heights from 0 (the ground) up to but not including
    `from_height` (Bob’s current height). This loop is the only significant change
    from the Knight Chase BFS.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码中有一个有趣的结构变化，增加了位置的处理。Bob 只有一个跳跃距离，因此只有一个跳跃动作需要考虑 ➋：Bob 从`from_height`开始，如果是有效位置，最终到达`from_height
    + jump_distance`。我们可以使用`target_height * 2 - 1`来获得 Bob 允许达到的最大高度。对于下落，我们不能硬编码 Bob
    可用的跳跃；这些跳跃取决于 Bob 当前的高度。为了解决这个问题，我们使用一个循环 ➌ 来考虑所有从 0（地面）到不包括`from_height`（Bob
    当前高度）的目标高度。这个循环是与骑士追逐 BFS 唯一显著的不同。
- en: To wrap up our BFS code, we need to implement the `add_position` helper function.
    That code is given in [Listing 5-7](ch05.xhtml#ch05ex07).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的 BFS 代码，我们需要实现 `add_position` 辅助函数。该代码在[列表 5-7](ch05.xhtml#ch05ex07)中给出。
- en: '[PRE17]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 5-7: Adding a position*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-7：添加一个位置*'
- en: 'Bob wants to move from `from_height` to `to_height`. This move is allowed if
    it passes three tests. First, Bob can’t be jumping above the maximum allowed height.
    Second, he can’t be jumping somewhere that has itching powder. Third, the `min_moves`
    board better not have already recorded a number of moves for `to_height`: if a
    value is already in there, then it has a faster way to get to `to_height`. If
    we passed these tests, then we’ve found a new, valid position; we set the number
    of moves to get there and then store this as a position for the next round of
    BFS.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Bob 想从`from_height`移动到`to_height`。如果通过三个测试，这个移动是允许的。首先，Bob 不能跳跃超过最大允许高度。其次，他不能跳到有痒粉的位置。第三，`min_moves`棋盘上最好不要已经为`to_height`记录了移动次数：如果其中已经有一个值，则意味着有更快速的方式到达`to_height`。如果通过了这些测试，那么我们找到了一个新的有效位置；我们设置到达那里所需的移动次数，然后将其作为下次
    BFS 的位置。
- en: Finding the Best Height
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 寻找最佳高度
- en: There are many possibilities for Bob’s final position. It could be the target
    height *h* from the test case. However, depending on *j* and the itching powder,
    it could be higher than that. We know for each position the minimum number of
    moves to get there. What we have to do now is check all of the candidate positions,
    choosing the one that minimizes the number of moves. That code is given in [Listing
    5-8](ch05.xhtml#ch05ex08).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Bob 最终可能达到的目标位置有很多种。它可能是测试用例中的目标高度 *h*。然而，取决于 *j* 和痒粉的影响，它可能会更高。我们知道每个位置达到所需的最少移动次数。现在我们要做的是检查所有候选位置，选择那个最小化移动次数的位置。该代码在[列表
    5-8](ch05.xhtml#ch05ex08)中给出。
- en: '[PRE18]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 5-8: The minimum number of moves*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-8：最少移动次数*'
- en: It’s possible that Bob can’t get to his target height, so we start `best` off
    with a value of `-1` ➊. For each candidate height, we then check whether it’s
    possible for Bob to land there. If he can, and doing so is faster than our current
    minimum number of moves `best` ➋, then we update `best` accordingly.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能 Bob 无法到达目标高度，因此我们将`best`初始化为`-1` ➊。对于每个候选高度，我们检查 Bob 是否能够到达。如果可以，并且这样做比当前的最少移动次数
    `best` ➋ 更快，那么我们相应地更新 `best`。
- en: We’ve now got all the code to process a test case and output the result. All
    that’s left is to read the input. The `main` function in [Listing 5-9](ch05.xhtml#ch05ex09)
    does that.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了处理测试用例并输出结果的所有代码。剩下的就是读取输入了。[列表 5-9](ch05.xhtml#ch05ex09)中的`main`函数完成了这一部分。
- en: '[PRE19]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 5-9: The* main *function*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-9：主* 函数'
- en: As is typical for large arrays, we have made `itching` and `min_moves` static.
    The elements of `itching` are initialized to `0`, which means that there is no
    itching powder yet on the rope. For each segment where there is itching powder
    on the rope, we loop through each integer in the range ➊ and set the corresponding
    element of `itching` to `1` ➋. Once we’re done looping through the itchy segments,
    each index of `itching` tells us if the rope does (value `1`) or does not (value
    `0`) have itching powder there. We no longer care about the individual itchy segments
    themselves—we have all that we need in `itching`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如大数组的常见做法，我们将 `itching` 和 `min_moves` 设置为静态。`itching` 数组的元素初始化为 `0`，这意味着绳索上还没有痒粉。对于绳索上有痒粉的每一段，我们遍历范围
    ➊ 中的每个整数，并将对应的 `itching` 元素设置为 `1` ➋。一旦完成对痒段的遍历，`itching` 数组的每个索引告诉我们该位置的绳索上是否有痒粉（值为
    `1`）或没有（值为 `0`）。我们不再关心单独的痒段本身——我们已经在 `itching` 中得到了所需的全部信息。
- en: That’s it. We’ve got a solution that uses a single call of BFS. It’s time to
    submit to the judge. As some might say, Bob’s your uncle . . .
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们得到了一个使用单次 BFS 调用的解决方案。是时候提交给评测系统了。正如有人说的那样，**Bob’s your uncle**……
- en: Or, hopefully he will be, but he’s not yet. Because you should receive a “Time-Limit
    Exceeded” error with this code.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，希望他会，但他还没准备好。因为你应该会收到一个 “超时” 错误，代码会出错。
- en: '*Solution 2: A Remodel*'
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决方案 2：重构*'
- en: 'Let’s run test cases of increasing size to get a sense of how our runtime is
    growing. To simplify things, we won’t use any itching powder. Here’s the first
    test case:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行逐渐增大的测试用例，以了解我们的运行时间如何增长。为了简化，我们将不使用任何痒粉。以下是第一个测试用例：
- en: '[PRE20]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That’s a target height of at least 30,000, with a jump distance of 5\. On my
    laptop, that takes about eight seconds. Now let’s double the target height:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个至少目标高度为 30,000，跳跃距离为 5 的问题。在我的笔记本上，这大约需要 8 秒。现在让我们将目标高度再翻倍：
- en: '[PRE21]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'I’m looking at about 30 seconds here. That’s nearly four times longer than
    in the previous case. We’ve long blown past the 1.8-second time limit, but let’s
    do this one more time, doubling the target height again:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我估计这里需要大约 30 秒。这几乎是之前情况的四倍时间。我们早已超过了 1.8 秒的时间限制，但我们再做一次，目标高度再翻倍：
- en: '[PRE22]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That gives a glacially slow 130 seconds, approximately another fourfold increase
    from the previous test case. That is, it seems that doubling the input size leads
    to the runtime being multiplied by four. This isn’t as catastrophic as what we
    saw in “Solution 2: Memoization” when solving Burger Fervor in [Chapter 3](ch03.xhtml),
    but it’s clearly too slow.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得运行时间极其缓慢，达到了 130 秒，几乎是上一个测试用例的四倍增长。也就是说，看起来输入大小翻倍会导致运行时间乘以四。这并不像我们在 [第 3
    章](ch03.xhtml) 中解决“汉堡狂热问题”的“解决方案 2：记忆化”时看到的那样灾难性，但显然还是太慢了。
- en: Too Many Fall Edges
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 太多的下降边
- en: 'In “BFS on Graphs” on [page 172](ch05.xhtml#sec72), I warned that we need to
    keep two things in check when using BFS: the number of times we call BFS and the
    number of edges in the graph. We’re doing as well as possible with the number
    of BFS calls, as we only call BFS once. To further pursue a solution based on
    BFS, then, we need a way to reduce the number of edges in the graph.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在 “图上的 BFS” 这一节中，[第 172 页](ch05.xhtml#sec72)，我曾警告过使用 BFS 时需要控制两件事：调用 BFS 的次数和图中边的数量。对于
    BFS 调用次数，我们已经做到最好，因为我们只调用了一次 BFS。为了进一步基于 BFS 寻找解决方案，我们需要减少图中边的数量。
- en: Let’s take a look at the graph for a small example shown in [Figure 5-5](ch05.xhtml#ch05fig05).
    We’ll then be able to extrapolate to larger examples and see why our code churrs
    and churrs.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下 [图 5-5](ch05.xhtml#ch05fig05) 中的小例子图。然后我们可以推测更大的例子，并看到为什么我们的代码会如此缓慢。
- en: '![Image](../images/ch05fig05.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch05fig05.jpg)'
- en: '*Figure 5-5: A graph of Bob’s moves*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：Bob 的移动图*'
- en: The graph shows the available moves from a height of 0 to a height of 7, if
    we assume that Bob can jump up by 3\. This is an example of a directed graph;
    notice, for example, that there is a move from 6 to 5 but not one from 5 to 6.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了从高度 0 到高度 7 可用的移动，如果我们假设 Bob 可以跳跃 3 个单位。这是一个有向图的例子；例如，请注意，存在从 6 到 5 的移动，但没有从
    5 到 6 的移动。
- en: The graph contains jump edges that encode Bob’s possible jumps and fall edges
    that encode Bob’s possible falls. The jump edges go from the bottom to the top
    and the fall edges go from the top to the bottom. For example, the edge from a
    height of 0 to a height of 3 is a jump edge; the aforementioned edge from 6 to
    5 is a fall edge.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图中包含了跳跃边（jump edges）和跌落边（fall edges），跳跃边表示 Bob 可能的跳跃，跌落边表示 Bob 可能的跌落。跳跃边从底部到顶部，而跌落边则从顶部到底部。例如，从高度
    0 跳到高度 3 是一条跳跃边；上述从 6 到 5 的边是跌落边。
- en: The number of jump edges isn’t worrisome at all. We have at most one jump edge
    per node. If we have *n* nodes, then we have at most *n* jump edges. If we decide
    to model up to a height of 8 instead of 7, then we’d add only one new jump edge.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 跳跃边的数量根本不值得担心。我们每个节点最多只有一条跳跃边。如果我们有 *n* 个节点，那么我们最多有 *n* 条跳跃边。如果我们决定将高度限制提高到
    8，而不是 7，那么我们只需添加一条新的跳跃边。
- en: However, the fall edges proliferate at a much faster rate. Notice that there
    is one fall edge from a height of 1, two fall edges from 2, three fall edges from
    3, and so on. That is, for a rope of height *h*, we have a total of 1 + 2 + 3
    + . . . + *h* fall edges. If we want to know how many fall edges there are for
    a given rope height, we could add up the integers from 1 to that height. There
    is, however, a convenient formula that we can use instead to get the answer much
    faster. It’s *h*(*h* + 1)/2\. For a rope height of 50, for example, we’d have
    50(51)/2 = 1, 275 fall edges. For a rope height of two million, we’d have over
    two trillion fall edges.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，跌落边的数量增长速度要快得多。请注意，从高度 1 有一条跌落边，从高度 2 有两条跌落边，从高度 3 有三条跌落边，依此类推。也就是说，对于高度为
    *h* 的绳索，我们总共有 1 + 2 + 3 + ... + *h* 条跌落边。如果我们想知道给定绳索高度的跌落边数量，我们可以将 1 到该高度的整数加起来。然而，有一个更方便的公式可以让我们更快速地得到答案。它是
    *h*(*h* + 1)/2。例如，对于高度为 50 的绳索，我们有 50(51)/2 = 1,275 条跌落边。对于高度为两百万的绳索，我们将有超过两万亿条跌落边。
- en: Back in [Chapter 1](ch01.xhtml), we saw a very similar formula in “Diagnosing
    the Problem” on [page 9](ch01.xhtml#ch01lev1), when we were counting pairs of
    snowflakes. Like that one, our formula here is quadratic, being *O*(*h*²), and
    it’s this quadratic growth in fall edges that bests our algorithm.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第1章](ch01.xhtml)，我们在“诊断问题”部分（[第9页](ch01.xhtml#ch01lev1)）看到了一个非常相似的公式，当时我们在计算雪花对的数量。和那个公式一样，我们这里的公式是二次的，即
    *O*(*h*²)，正是这种在跌落边上的二次增长影响了我们的算法。
- en: Changing the Moves
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 改变动作
- en: If we’re going to reduce the number of edges in the graph, then we’re going
    to have to change the available moves that the graph encodes. We can’t change
    the rules of the actual game that Bob plays in gym class, but we *can* change
    the moves in our graph model of the game. Of course, we are only able to change
    the graph if a BFS on the new graph produces the same answer as a BFS on the old
    graph.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要减少图中的边数，那么我们必须改变图中编码的可用动作。我们不能改变 Bob 在体育课上玩的实际游戏规则，但我们*可以*改变我们图中模型的游戏动作。当然，只有当在新图上进行
    BFS 搜索得到的结果与旧图一致时，我们才可以改变图。
- en: There’s an important lesson here. It’s tempting to map the available moves,
    one for one, from the real-world problem to the graph. We did that for Knight
    Chase and succeeded in solving the problem. While this might be tempting, it’s
    not a requirement. We can produce a different graph, one with a more desirable
    number of nodes or edges, as long as that graph can still give us the answer to
    the original problem.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的教训。将现实世界问题中的可用动作逐一映射到图中是非常诱人的。我们在骑士追逐问题中就是这么做的，并且成功地解决了问题。虽然这可能很诱人，但并不是必须的。我们可以构造一个不同的图，拥有更理想的节点或边的数量，只要该图仍然能给出原问题的答案。
- en: Suppose that we want to fall some distance from a height of five meters. One
    possibility might be to fall four meters. Indeed, solving the problem as in Solution
    1, there would be a fall edge from a height of 5 down to 1\. However, another
    way to think of this fall is as four falls of one meter each. That is, we can
    think of Bob falling from 5 to 4, then falling to 3, then falling to 2, and then
    falling finally to 1\. That is, I’m imagining that every fall edge would be exactly
    one meter long. No more fall edges like those from a height of 5 to 3, or 5 to
    2, or 5 to 1, or 5 to 0\. There would be just one fall edge from each node, bringing
    us one meter lower. This should drastically cut down on the number of fall edges!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想从五米的高度下落一段距离。一种可能是下落四米。实际上，按照方案1解决问题的话，会有一条从高度5到1的下落边。然而，另一种看待这个下落的方式是把它看作是四次每次下落一米。也就是说，我们可以想象Bob从5米掉到4米，再掉到3米，接着掉到2米，最后掉到1米。也就是说，我设想每一条下落边的长度恰好为一米。没有从5米到3米，或从5米到2米，或者从5米到1米，甚至从5米到0米的那些下落边。每个节点只会有一条下落边，让我们下降一米。这应该大大减少下落边的数量！
- en: We have to be careful, though. We can’t let each of these mini, one-meter falls
    count as a move. If Bob falls four meters, using four one-meter-fall edges, then
    we still have to count it as a single move, not four moves.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 不过我们得小心。不能把每一个一米的小跌落都算作一次动作。如果Bob掉落了四米，使用了四次一米的跌落边，那么我们仍然应该把它算作一次动作，而不是四次动作。
- en: Imagine that we have two ropes (0 and 1), not one. Rope 0 is the rope that we’ve
    always had. Alice set it up. It might have itching powder. Rope 1 is new, devised
    by us, for the purposes of modeling. It has no itching powder. In addition, when
    Bob is on Rope 1, he’s not allowed to move upward.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两条绳子（0和1），而不是一条。绳子0是我们一直有的那条，Alice布置的，可能上面有痒粉。绳子1是我们新设的，目的是建模。它没有痒粉。而且，当Bob在绳子1上时，他不能向上移动。
- en: 'When Bob wants to make a fall move, he will move from Rope 0 to Rope 1\. He’ll
    stick with Rope 1, falling, for as long as he wants to fall. Then, at any point
    where there isn’t itching powder on Rope 0, he can end his fall by moving back
    to Rope 0\. Specifically, we have the following moves now:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当Bob想要进行一个下降动作时，他将从绳子0移动到绳子1\。他会一直保持在绳子1上，尽情下降，直到他想停止为止。然后，在绳子0上没有痒粉的地方，他可以通过回到绳子0来结束他的下降动作\。具体来说，现在我们有以下几种动作：
- en: 'When Bob is on Rope 0, he has two possible moves: jump up by *j* meters or
    move over to Rope 1\. Each costs one move.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Bob在绳子0上时，他有两种可能的动作：跳升*j*米，或者移动到绳子1\。每个动作都需要消耗一次移动。
- en: 'When Bob is on Rope 1, he has two possible moves: fall by one meter or move
    over to Rope 0\. Each costs 0 moves. That’s right: these moves are free!'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Bob在绳子1上时，他有两种可能的动作：下落一米，或者移动到绳子0\。每个动作都不算移动。没错，这些动作是免费的！
- en: Bob jumps up as before, using Rope 0\. When he wants to fall, he moves to Rope
    1 (that costs him one move), falls down Rope 1 as much as he likes (that’s free),
    and then moves back to Rope 0 (that’s free, too). The whole fall, then, costs
    Bob just one move. Perfect—this is just as before! No one will know that we’re
    using two ropes instead of one.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Bob像以前一样使用绳子0跳升。当他想要下落时，他移动到绳子1（这花费他一次移动），在绳子1上自由下落（这不花费任何移动），然后再回到绳子0（这也不花费移动）。整个下落过程对Bob来说只消耗了一次移动。完美——这和之前一样！没有人会知道我们使用了两条绳子而不是一条。
- en: Compare [Figure 5-5](ch05.xhtml#ch05fig05), with its mass of edges, to [Figure
    5-6](ch05.xhtml#ch05fig06), which depicts the two-ropes maneuver.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 将[图5-5](ch05.xhtml#ch05fig05)与其大量的边进行对比，看看[图5-6](ch05.xhtml#ch05fig06)，后者描绘了双绳操作。
- en: '![Image](../images/ch05fig06.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch05fig06.jpg)'
- en: '*Figure 5-6: A graph of Bob’s moves using two ropes*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-6：使用两条绳子的Bob动作图*'
- en: 'It’s true that we’ve doubled the number of nodes, but that’s okay: what we
    care about for BFS is not the number of nodes but the number of edges. On that
    front, we’re laughing. We have, at most, two edges leaving each node: on Rope
    0, we have a jump edge and a move to Rope 1; on Rope 1, we have a fall edge and
    a move to Rope 0\. That is, for height *h*, we have about 4*h* edges. That’s linear!
    We’ve avoided that messy quadratic *h*² business.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们确实是把节点数加倍了，但这没关系：对于BFS来说，我们关心的不是节点数，而是边的数量。在这一方面，我们就轻松多了。每个节点最多有两条边：在绳子0上，我们有一条跳跃边和一条移到绳子1的边；在绳子1上，我们有一条下落边和一条移到绳子0的边。也就是说，对于高度*h*，我们大约有4*h*条边。这个是线性的！我们避免了那种复杂的二次*h*²的情况。
- en: I’ve annotated each edge here with whether it costs a move (1) or doesn’t (0).
    This is our first example of a *weighted* graph, where each edge is given a weight
    or cost.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我在每条边上标注了是否需要消耗一步（1）或者不需要（0）。这是我们第一次遇到*加权*图，每条边都有一个权重或代价。
- en: Adding Positions
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加位置
- en: We’ve meandered our way back to a two-dimensional board. (Hello, Knight Chase!)
    We need one dimension for Bob’s height and the second for the rope that Bob is
    on. The standard terminology for that second dimension is a *state*. When Bob
    is on Rope 0, we’ll say he’s in state 0, and when Bob is on Rope 1, we’ll say
    he’s in state 1\. Let’s use “state” from now on instead of “rope.”
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经绕回到一个二维的棋盘。（你好，骑士追逐！）我们需要一个维度来表示Bob的高度，第二个维度表示Bob所在的绳索。对于第二个维度，标准术语是*状态*。当Bob在绳索0上时，我们说他处于状态0；当Bob在绳索1上时，我们说他处于状态1。从现在开始，我们将使用“状态”而不是“绳索”。
- en: 'Here are the new `typedef`s:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是新的`typedef`定义：
- en: '[PRE23]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Rather than start with `find_distances`, as we have been doing in this chapter,
    we’ll start with the `add_position` functions. Yes: functions, plural, because
    we’re going to encode each type of move as its own function. There are four types
    of moves: a jump up, a fall down, a move from State 0 to State 1, and a move from
    State 1 to State 0\. Hence we’ll need four `add_position` functions.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再从`find_distances`开始（像本章之前那样），而是从`add_position`函数开始。没错，是函数的复数形式，因为我们将把每种类型的移动编码成各自的函数。移动有四种类型：跳跃向上、下落、从状态0到状态1的移动，以及从状态1到状态0的移动。因此，我们需要四个`add_position`函数。
- en: Jumping Up
  id: totrans-341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 跳跃向上
- en: The code for following a jump edge is given in [Listing 5-10](ch05.xhtml#ch05ex010).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪跳跃边的代码见[示例 5-10](ch05.xhtml#ch05ex010)。
- en: '[PRE24]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 5-10: Adding a position: jumping up*'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-10：添加一个位置：向上跳跃*'
- en: This function involves jumping up from `from_height` to `to_height`. This kind
    of move is allowed only in state 0; whenever we index `min_moves`, we’ll therefore
    use `0` as the second index.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数涉及从`from_height`跳跃到`to_height`。这种移动仅在状态0中允许；因此，每当我们索引`min_moves`时，第二个索引将使用`0`。
- en: The code is similar to [Listing 5-7](ch05.xhtml#ch05ex07), but with a few important
    changes. First, I’ve changed the name of `new_positions` to `pos` and `num_new_positions`
    to `num_pos`. We’ll talk about the reason for this change to more generic parameter
    names after we’ve gone through the four functions.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与[示例 5-7](ch05.xhtml#ch05ex07)类似，但做了一些重要的修改。首先，我将`new_positions`改为`pos`，并将`num_new_positions`改为`num_pos`。我们将在讲解完四个函数后，讨论为什么要将这些参数名改为更通用的名称。
- en: Second, to facilitate comparison between the four functions, I’ve added a `distance`
    variable ➊ that indicates the number of moves it takes to get to `to_height` by
    using `from_height`. Here, it’s one more move than the minimum number of moves
    to `from_height`, because we pay one move for this jump.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，为了方便比较四个函数，我添加了一个`distance`变量 ➊，表示通过`from_height`到达`to_height`所需的步数。这里，它比到`from_height`的最小步数多一步，因为我们为这次跳跃付出了一次移动。
- en: Third and finally, I’ve changed the part of the if condition that checks whether
    we’ve found a new position ➋. This is because a position might be discovered by
    an edge that counts as one move, but it could later be rediscovered by an edge
    that doesn’t count as a move. We want to allow for the possibility that the minimum
    number of moves is updated and improved by one of those no-cost edges. (Jumping
    up is not a no-cost edge, so we don’t need this change here; but I’ve kept it
    in for consistency across the four functions.)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我修改了if条件中检查是否找到了新位置的部分 ➋。这是因为一个位置可能通过一个算作一步的边被发现，但它也可能稍后通过一条不算作移动的边被重新发现。我们希望允许最小步数通过那些不消耗代价的边进行更新和改进。（跳跃向上不是一条不消耗代价的边，因此我们在这里不需要这个修改；但为了在四个函数之间保持一致性，我仍然保留了这个改动。）
- en: Falling Down
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 下落
- en: Let’s now take a look at the code for falling down given in [Listing 5-11](ch05.xhtml#ch05ex011).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下[示例 5-11](ch05.xhtml#ch05ex011)中给出的下落代码。
- en: '[PRE25]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 5-11: Adding a position: falling down*'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-11：添加一个位置：下落*'
- en: Falling down can only happen in state 1; that’s why the second index is `1`
    whenever we access `min_moves`. Also, there’s nothing to do with itching powder
    here. Bob can fall as much as he likes in State 1 and not have to worry about
    the itching powder. Finally, a crucial point about the calculated distance is
    that there’s no `+ 1` added ➊!
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 下落只能发生在状态1中；这就是为什么每当我们访问`min_moves`时，第二个索引是`1`。另外，这里没有使用痒粉的情节。Bob可以在状态1中随意下落，不必担心痒粉。最后，关于计算距离的一个关键点是，距离中没有加上`+
    1` ➊！
- en: 'Remember: this doesn’t count as a move.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：这不算作一步移动。
- en: Switching States
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 切换状态
- en: There are two more functions to go. First we have the function to move from
    State 0 to State 1 in [Listing 5-12](ch05.xhtml#ch05ex012).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个函数。首先是[列表 5-12](ch05.xhtml#ch05ex012)中的从状态0移动到状态1的函数。
- en: '[PRE26]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 5-12: Adding a position: moving from state 0 to state 1*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-12：添加位置：从状态0移动到状态1*'
- en: Then we have the function to move from state 1 to state 0, shown in [Listing
    5-13](ch05.xhtml#ch05ex013).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 接着是从状态1移动到状态0的函数，见[列表 5-13](ch05.xhtml#ch05ex013)。
- en: '[PRE27]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 5-13: Adding a position: moving from state 1 to state 0*'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-13：添加位置：从状态1移动到状态0*'
- en: Moving from State 0 to State 1 costs one move, but moving from State 1 to State
    0 does not. Also notice we’re only allowed to move from State 1 to State 0 if
    there’s no itching powder at that height. Without that check, we’d be allowed
    to stop a fall on a segment of the rope with itching powder, and that would be
    breaking the rules.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 从状态0移动到状态1需要一步，但从状态1移动到状态0则不需要。同样需要注意的是，只有在该高度没有痒粉时，我们才允许从状态1移动到状态0。如果没有这个检查，我们就有可能在有痒粉的绳索段上停下来，这就违反了规则。
- en: 0-1 BFS
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 0-1 BFS
- en: Now it’s time to incorporate the state into the `find_distances` code from [Listing
    5-6](ch05.xhtml#ch05ex06). However, we had better be careful, lest we miscount
    the moves.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将状态纳入到来自[列表 5-6](ch05.xhtml#ch05ex06)的`find_distances`代码中了。不过，我们最好小心一些，以免误算步数。
- en: Here’s an example. I’ll use (*h*, *s*) to refer to Bob being at height *h* in
    state *s*. Suppose that Bob can jump up by three. Bob starts at (0, 0), and it
    takes zero moves to get there. Exploring from (0, 0), we will identify (0, 1)
    as a new position, and record that it takes one move to get there. It’ll be added
    to the positions for the next round of BFS. We’ll also find (3, 0) and similarly
    record that it takes one move to get there. That’s another position for the next
    round of BFS. That’s all standard BFS fare.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例。我将用(*h*, *s*)来表示Bob在高度*h*的状态*s*下。假设Bob可以跳跃三步。Bob从(0, 0)开始，并且到达那里不需要任何移动。从(0,
    0)开始探索时，我们会找到(0, 1)作为一个新位置，并记录到达那里需要一步。这将被加入到下一轮BFS的位置中。我们还会发现(3, 0)，并同样记录到达那里需要一步。这也是下一轮BFS的位置。这就是标准的BFS操作。
- en: When exploring out of (3, 0), we’ll find the new positions (3, 1) and (6, 0).
    Both will be added to the next round of BFS, and both will be reachable in a minimum
    of two moves.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 从(3, 0)开始探索时，我们会发现新的位置(3, 1)和(6, 0)。这两个位置都会被加入到下一轮BFS中，并且都能在最少两步内到达。
- en: However, we need to be careful with position (3, 1). We know that (2, 1) is
    reachable from here, so it’s tempting to add it to the next round of BFS. If we
    did that, though, then we wouldn’t be doing BFS anymore. We are supposed to put
    positions in the next round of the BFS when they are exactly one move away from
    those in the current round. Is (2, 1) one more move away from (3, 1)? No! They
    are the same number of moves from (0, 0), because falling in State 1 is free.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要小心位置(3, 1)。我们知道(2, 1)可以从这里到达，因此很容易把它加到下一轮的BFS中。但是如果这么做，我们就不再做BFS了。我们应该把那些距离当前轮中位置只有一步之遥的位置放入下一轮BFS中。那么，(2,
    1)离(3, 1)多一步吗？不！它们到(0, 0)的步数是相同的，因为在状态1中掉落是免费的。
- en: That is, (2, 1) doesn’t go in the next round of BFS. It goes in the *current*
    round of BFS, right along with (3, 1) and everything else whose minimum moves
    is two.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，(2, 1)不会进入下一轮的BFS。它会进入*当前*轮的BFS，就像(3, 1)以及所有最小移动数为二的其他位置一样。
- en: In summary, whenever we move along an edge that costs us a move, we add the
    new position to the next round of BFS. That’s what we’ve always done. However,
    when we move along an edge that is free, then we add it to the current round of
    BFS so that it can be processed along with the other positions whose distance
    is the same. This is why we moved away from `new_positions` and `num_new_positions`
    in the `add_position` functions in “Adding Positions” on [page 182](ch05.xhtml#ch05lev1z).
    Two of the functions will indeed add moves to the new positions, but the other
    two will add moves to the current positions.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，每当我们沿着一条需要花费一步的边移动时，我们会将新位置添加到下一轮BFS中。这就是我们一直以来的做法。然而，当我们沿着一条免费边移动时，我们则将其添加到当前轮的BFS中，以便它能与其他距离相同的位置信息一起处理。这就是我们在“添加位置”部分中移开`new_positions`和`num_new_positions`的原因，参见[第182页](ch05.xhtml#ch05lev1z)。有两个函数确实会将步数加到新位置，但另外两个会将步数加到当前的位置。
- en: This variant of BFS is called *0-1 BFS*, because it works on graphs whose edges
    cost zero moves or one move.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 BFS 的变种被称为 *0-1 BFS*，因为它适用于边的移动费用为零或一的图。
- en: At last, it’s time for the BFS. Check it out in [Listing 5-14](ch05.xhtml#ch05ex014).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候进行 BFS 了。可以在 [列表 5-14](ch05.xhtml#ch05ex014) 中查看。
- en: '[PRE28]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 5-14: The minimum number of moves for Bob using 0-1 BFS*'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-14：使用 0-1 BFS 计算 Bob 的最小移动次数*'
- en: The new code checks whether the current position is in State 0 or State 1 ➊.
    In each case, there are two moves to consider. In State 0, the new positions (those
    for the next round of BFS) are used; in State 1, the current positions are used.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码检查当前位置是否处于状态 0 或状态 1 ➊。每种情况下，都有两种移动需要考虑。在状态 0 中，使用的是新位置（即下一轮 BFS 的位置）；在状态
    1 中，使用的是当前的位置。
- en: What about the `main` and `solve` functions? For `main`, we can use the same
    function from Solution 1\. For `solve`, we just need to add State 0 whenever we
    index `min_moves`. If you make those changes and submit to the judge, you’ll see
    that we pass all tests with plenty of time to spare.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 和 `solve` 函数怎么办？对于 `main`，我们可以使用解决方案 1 中的相同函数。对于 `solve`，我们只需要在每次索引
    `min_moves` 时添加状态 0。如果您进行这些更改并提交给判题系统，您将看到所有测试都能通过，且时间充裕。'
- en: 'Problem 3: Book Translation'
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题 3：书籍翻译
- en: In the Knight Chase and Rope Climb problems, there was no explicit graph to
    read from the input; the BFS incrementally produced the graph as it explored.
    We’ll now see a problem where the graph is presented to us up front.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在骑士追逐和绳索攀爬问题中，输入中没有显式的图需要读取；BFS 在探索过程中逐步生成图。现在，我们将看到一个问题，其中图已经提前呈现给我们。
- en: This is DMOJ problem `ecna16d`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `ecna16d`。
- en: '*The Problem*'
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: You have written a new book in English, and you want to get the book translated
    into *n* other target languages. You’ve found *m* translators. Each translator
    knows how to translate between exactly two languages and will do the translation
    at a given cost. For example, a translator may know how to translate between Spanish
    and Bengali at a cost of $1,800; this means that you could ask this translator
    to translate from Spanish to Bengali for $1,800 or Bengali to Spanish for $1,800.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经用英语写了一本新书，并且希望将这本书翻译成 *n* 种其他目标语言。您找到 *m* 名翻译员。每个翻译员知道如何翻译两种语言之间的内容，并且会按给定的费用进行翻译。例如，某个翻译员可能知道如何以
    1,800 美元的费用翻译西班牙语和孟加拉语之间的内容；这意味着您可以要求该翻译员以 1,800 美元将西班牙语翻译成孟加拉语，或将孟加拉语翻译成西班牙语。
- en: To reach a given target language may require multiple translations. For example,
    you may want to translate your book from English to Bengali but have no translator
    between these two languages. You might instead have to translate from English
    to Spanish and then Spanish to Bengali.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要到达一个给定的目标语言，可能需要多次翻译。例如，您可能希望将您的书从英语翻译成孟加拉语，但两种语言之间没有翻译员。您可能需要先将书从英语翻译成西班牙语，然后再从西班牙语翻译成孟加拉语。
- en: To reduce the number of translation errors, you will minimize the number of
    translations needed to reach each target language. If there are multiple ways
    to achieve a minimum number of translations to a target language, then you will
    choose the cheapest one. Your goal is to minimize the number of translations to
    each target language; if there are multiple ways to do this, choose the one with
    minimum total cost.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少翻译错误，您将最小化达到每种目标语言所需的翻译次数。如果有多种方式可以以最小的翻译次数达到某个目标语言，则选择成本最小的一种。您的目标是最小化每种目标语言的翻译次数；如果有多种方式可以实现此目标，则选择总成本最小的一种。
- en: Input
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input contains one test case, consisting of the following lines:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含一个测试用例，由以下几行组成：
- en: A line containing two integers *n* and *m*. *n* is the number of target languages;
    *m* is the number of translators. There are at most 100 target languages and at
    most 4,500 translators.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含两个整数 *n* 和 *m*。*n* 是目标语言的数量；*m* 是翻译员的数量。最多有 100 种目标语言和最多 4,500 名翻译员。
- en: A line containing *n* strings, each naming a target language. `English` will
    not be a target language.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *n* 个字符串，每个字符串表示一种目标语言。`English` 不是目标语言。
- en: '*m* lines, each giving information for one translator. Each of these lines
    contains three space-separated tokens: a language, a second language, and the
    positive integer cost to translate between them. There is at most one translator
    per pair of languages.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*m* 行，每行给出一个翻译员的信息。每行包含三个由空格分隔的标记：一种语言、第二种语言和它们之间的正整数翻译费用。每对语言最多有一个翻译员。'
- en: Output
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: Output the minimum monetary cost to translate the book into all of the target
    languages, while minimizing the number of translations to each target language.
    If there is no way to translate the book into all of the target languages, output
    `Impossible`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将书籍翻译成所有目标语言的最小货币成本，同时最小化到每种目标语言的翻译次数。如果无法将书籍翻译成所有目标语言，输出 `Impossible`。
- en: The time limit for solving the test case is 0.6 seconds.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 解这个测试用例的时间限制是 0.6 秒。
- en: '*Reading the Language Names*'
  id: totrans-391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*阅读语言名称*'
- en: Rather than use language names directly—English, Spanish, and so on—I’ll associate
    each language with an integer. English will be language 0, and each target language
    will be given a unique integer greater than 0\. We can then work with integers
    from here on out, as we did for the other problems in this chapter.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不直接使用语言名称——英语、西班牙语等——而是将每种语言与一个整数关联。英语将是语言 0，其他目标语言将分配一个大于 0 的唯一整数。然后我们可以继续使用整数，就像我们在本章的其他问题中所做的那样。
- en: 'There’s one annoyance here: the problem description does not tell us the maximum
    length of a language name. We therefore cannot hardcode some maximum language
    name length like 16 or even 100, because we have no control over the input. We
    therefore use a `read_word` helper function; see [Listing 5-15](ch05.xhtml#ch05ex015).'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题：问题描述没有告诉我们语言名称的最大长度。因此，我们无法硬编码一个最大语言名称长度，比如 16 或者 100，因为我们无法控制输入。为了应对这种情况，我们使用了一个
    `read_word` 辅助函数；见[清单 5-15](ch05.xhtml#ch05ex015)。
- en: '[PRE29]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 5-15: Reading a word*'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-15：读取单词*'
- en: The `read_word` function takes an initial size that we hope suffices for most
    or all of the language names. When we call the function, we will give an initial
    size of 16, because that covers most language names we’re likely to see. We can
    use `read_word` to read characters ➊ up until the array reaches its maximum length;
    if the array fills up and the language name still isn’t over, it then uses `realloc`
    to double the array’s length ➋, thereby creating more space to read more characters.
    We’re careful to terminate `str` with a null character ➌; otherwise, it wouldn’t
    be a valid string!
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_word` 函数接受一个初始大小，我们希望它能满足大部分或所有语言名称的需求。当我们调用该函数时，我们会提供一个初始大小为 16，因为这涵盖了我们可能看到的大多数语言名称。我们可以使用
    `read_word` 来读取字符➊，直到数组达到最大长度；如果数组已满但语言名称仍未结束，它将使用 `realloc` 来将数组长度加倍➋，从而创建更多空间以读取更多字符。我们小心地用空字符来终止
    `str`➌；否则它就不是一个有效的字符串！'
- en: '*Building the Graph*'
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*构建图*'
- en: Now let’s turn to building a graph from the input. This will help us explore
    the allowable translations from each language.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来构建一个图，来自输入数据。这将帮助我们探索每种语言之间允许的翻译。
- en: 'Let’s work with a small test case:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来处理一个小的测试用例：
- en: '[PRE30]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Can you construct the graph? What are the nodes and what are the edges? Is it
    undirected or directed? Is it unweighted or weighted?
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 你能构建出这个图吗？哪些是节点，哪些是边？它是无向图还是有向图？是加权图还是无权图？
- en: As always, the edges encode the allowed moves; here, a move corresponds to a
    translation between two languages. The nodes, then, are the languages. An edge
    going from language *a* to language *b* means that there is a translator between
    these two languages. The translator can translate from *a* to *b* or vice versa—so
    the graph is undirected. It’s also weighted, because each edge (a translation)
    has a weight (the translation cost). The graph is shown in [Figure 5-7](ch05.xhtml#ch05fig07).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，边表示允许的移动；在这里，一个移动对应于两种语言之间的翻译。因此，节点就是语言。一个从语言 *a* 到语言 *b* 的边意味着这两种语言之间有翻译者。翻译者可以从
    *a* 翻译到 *b* 或反之——所以图是无向的。它也是加权的，因为每条边（即翻译）都有一个权重（翻译成本）。该图如[图 5-7](ch05.xhtml#ch05fig07)所示。
- en: '![Image](../images/ch05fig07.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch05fig07.jpg)'
- en: '*Figure 5-7: A graph of translations*'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-7：翻译图*'
- en: 'The total translation cost for us to reach all of the target languages is $500
    for English to Spanish, plus $1,000 for English to Italian, plus $1,800 for Spanish
    to Bengali. That’s $3,300 in all. Don’t be taken in by that alluring $250 Spanish–Italian
    translation: using that would result in a distance of two from English to Italian,
    but remember that we need the minimum distances, even when that leads to spending
    more money. Indeed, the reason we’ll be able to use BFS here is precisely because
    we care first about the minimum number of edges for each target language, not
    its minimum cost overall. For the latter, we’d need more powerful tools, and these
    will be introduced in [Chapter 6](ch06.xhtml).'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 为了到达所有目标语言的总翻译成本是：英语到西班牙语是500美元，英语到意大利语是1000美元，西班牙语到孟加拉语是1800美元。总共是3300美元。不要被那个迷人的250美元的西班牙语–意大利语翻译所吸引：使用它将导致英语到意大利语的距离为2，但记住我们需要的是最短的距离，即使这意味着需要花费更多的钱。事实上，我们之所以能够在这里使用BFS，正是因为我们首先关注的是每个目标语言的最小边数，而不是总体最小成本。对于后者，我们需要更强大的工具，这些将在[第6章](ch06.xhtml)中介绍。
- en: To store the graph, I’ll use what’s called an *adjacency list*. (Node *b* is
    said to be *adjacent* to Node *a* if there is an edge from *a* to *b*; that’s
    where the name “adjacency list” comes from.) This is just an array with one index
    per node, where each index stores a linked list of the edges involving that node.
    We use linked lists of edges, rather than arrays of edges, because we don’t know
    in advance the number of edges that involve a given node.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储图，我将使用所谓的*邻接列表*。（如果从*a*到*b*有一条边，那么说节点*b*是节点*a*的*邻接*节点；这就是“邻接列表”名称的来源。）这只是一个数组，每个节点有一个索引，数组中的每个索引存储一个包含该节点的边的链表。我们使用边的链表而不是边的数组，因为我们无法提前知道涉及给定节点的边的数量。
- en: 'Here are the constants and `typedef`s:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是常量和`typedef`：
- en: '[PRE31]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: An `edge` has a `to_lang` and a `cost`—that makes sense. However, it doesn’t
    have a `from_lang`, and that’s because we’ll already know the `from_lang` based
    on which index of the adjacency list the edge is in.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`edge`有一个`to_lang`和一个`cost`—这很合理。然而，它没有`from_lang`，因为我们已经能够根据邻接列表中边的位置推断出`from_lang`。
- en: In [Chapter 2](ch02.xhtml), when storing trees, we used a `struct node` rather
    than a `struct edge`. The reason for the node-centric focus in [Chapter 2](ch02.xhtml)
    is that the nodes are the entities associated with information, such as candy
    values and numbers of descendants. In the present problem, we have an edge-centric
    focus, with the `struct edge`, because it’s the edges (not the nodes) that are
    associated with information (the translation costs).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.xhtml)中，当存储树时，我们使用的是`struct node`，而不是`struct edge`。在[第2章](ch02.xhtml)中专注于节点的原因是，节点是与信息相关的实体，比如糖果值和后代数量。在当前问题中，我们专注于边的实现，使用`struct
    edge`，因为正是这些边（而不是节点）与信息（如翻译成本）相关。
- en: It’s easiest to add to a linked list at its beginning. One side effect of this
    choice is that the edges for a node end up in the linked list in the opposite
    order in which we read them. For example, if we read an edge from Node 1 to Node
    2 and then read an edge from Node 1 to Node 3, then in our linked list we will
    find that the edge to Node 3 shows up *before* the edge to Node 2\. Don’t let
    this catch you off guard when tracing through the code.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在链表的开头添加元素是最简单的。这种选择的一个副作用是，节点的边将以我们读取它们的相反顺序出现在链表中。例如，如果我们从节点1读取到节点2的边，然后从节点1读取到节点3的边，那么在我们的链表中，我们会发现指向节点3的边会出现在指向节点2的边*之前*。在追踪代码时不要因此而感到意外。
- en: Now we’re ready to see how the graph is built. It’s in the `main` function given
    in [Listing 5-16](ch05.xhtml#ch05ex016).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好查看图是如何构建的。它在[列表5-16](ch05.xhtml#ch05ex016)中给出的`main`函数中。
- en: '[PRE32]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 5-16: The* main *function for building the graph*'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-16：* 构建图的*主*函数'
- en: The `lang_names` array maps integers (the array indices) to language names.
    We give `English` the number 0, as promised ➊. We then map each integer 1, 2,
    . . . , to language names as we read them ➋.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`lang_names`数组将整数（数组索引）映射到语言名称。我们为`英语`赋值为0，正如承诺的那样 ➊。然后我们将每个整数1、2、…，映射到我们读取的语言名称
    ➋。'
- en: 'Remember that the graph is undirected: if we add an edge from *a* to *b*, then
    we had better add the edge from *b* to *a*, too. As such, for each translator,
    we add two edges to the graph: one from `from_index` to `to_index` ➌ and one from
    `to_index` to `from_index` ➍. Those `from_index` and `to_index` indices are produced
    by `find_lang`, which searches for a language name; see [Listing 5-17](ch05.xhtml#ch05ex017).'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 记住图是无向的：如果我们从*a*到*b*添加一条边，那么我们也必须添加从*b*到*a*的边。因此，对于每个翻译者，我们将图中添加两条边：一条从`from_index`到`to_index`
    ➌，一条从`to_index`到`from_index` ➍。这些`from_index`和`to_index`索引是由`find_lang`生成的，该函数用于查找语言名称；见[列表
    5-17](ch05.xhtml#ch05ex017)。
- en: In the calls to the helper functions at the bottom, we use `num_targets + 1`
    rather than `num_targets` because `num_targets` gives the number of target languages;
    the `+ 1` lets us include English in the count of total languages being processed.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部对辅助函数的调用中，我们使用`num_targets + 1`而不是`num_targets`，因为`num_targets`表示目标语言的数量；`+
    1`让我们在处理的语言总数中包括英语。
- en: '[PRE33]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 5-17: Finding a language*'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-17：查找语言*'
- en: '*The BFS*'
  id: totrans-420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*BFS*'
- en: The code for `add_position` in [Listing 5-18](ch05.xhtml#ch05ex018) is similar
    to the other `add_position` functions we’ve studied earlier in this chapter.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-18](ch05.xhtml#ch05ex018)中的`add_position`代码与我们在本章早些时候学习的其他`add_position`函数类似。'
- en: '[PRE34]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 5-18: Adding a position*'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-18：添加位置*'
- en: Now we’re ready for the BFS itself; see [Listing 5-19](ch05.xhtml#ch05ex019).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好进行BFS了；见[列表 5-19](ch05.xhtml#ch05ex019)。
- en: '[PRE35]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 5-19: Minimum cost of translations using BFS*'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-19：使用BFS的翻译最小成本*'
- en: For each language, we’ll use `min_costs` to store the minimum-cost edge that
    could have been used to discover that language. Referring back to [Figure 5-7](ch05.xhtml#ch05fig07),
    we’d store 500 for Spanish, 1,000 for Italian, and 1,800 for Bengali. In a different
    function, described soon, we’ll add up all of these numbers to get the total cost
    for all of the translations.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种语言，我们将使用`min_costs`存储可能用于发现该语言的最小成本边。回顾[图 5-7](ch05.xhtml#ch05fig07)，我们将为西班牙语存储500，为意大利语存储1000，为孟加拉语存储1800。在另一个函数中，我们将把这些数字加起来，得到所有翻译的总成本。
- en: The minimum number of moves is of interest only to this function, not the outside
    world, so we declare it as a local variable ➊. All the outside world cares about
    is `min_costs`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的移动次数只对这个函数有意义，而对外部世界没有影响，所以我们将其声明为局部变量 ➊。外部世界关心的只是`min_costs`。
- en: Trying each possible move amounts to traversing the linked list of edges for
    the current node ➋. That gives us all of the `new_positions`. Now we know which
    languages are discovered in the next round of the BFS, but we don’t yet know the
    cost of adding each of those languages. The thing is, there could be multiple
    edges from `cur_positions` that reach the same node in `new_positions`. Consult
    [Figure 5-7](ch05.xhtml#ch05fig07) again. Bengali takes two translations, so it’s
    discovered in round 2 of the BFS—but the edge we need is the one from Spanish,
    not the one from Italian.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试每个可能的移动相当于遍历当前节点的边的链表 ➋。这为我们提供了所有`new_positions`。现在我们知道了下一轮BFS中发现的语言，但我们还不知道添加每种语言的成本。问题是，从`cur_positions`到`new_positions`可能有多条边。再次参考[图
    5-7](ch05.xhtml#ch05fig07)。孟加拉语需要两次翻译，所以它在BFS的第二轮中被发现——但我们需要的边是西班牙语的，而不是意大利语的。
- en: We therefore have a new `for` loop ➌, one whose role we haven’t seen yet in
    this chapter. The variable `added_lang` tracks each of the new positions (that
    is, the positions for the next round of BFS). We find the cheapest edge between
    `added_lang` and any node discovered in the current round of BFS. Each such language
    will have a distance of one less than `added_lang`, which explains the first condition
    in the `if` statement ➍.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了一个新的`for`循环 ➌，这是我们在本章中尚未见过的。变量`added_lang`跟踪每个新位置（即下一轮BFS的语言位置）。我们找到`added_lang`与当前BFS轮次中任何已发现节点之间的最便宜边。每种语言的距离将比`added_lang`少一，这解释了`if`语句中第一个条件
    ➍。
- en: '*The Total Cost*'
  id: totrans-431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*总成本*'
- en: Once we’ve got the costs stored, all we do is add them up to get the total cost
    of translating to all target languages. The code is given in [Listing 5-20](ch05.xhtml#ch05ex020).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将成本存储起来，接下来要做的就是将它们加起来，以得到翻译成所有目标语言的总成本。代码见[列表 5-20](ch05.xhtml#ch05ex020)。
- en: '[PRE36]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 5-20: The minimum total cost*'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-20：最小总成本*'
- en: The task is impossible if any of the target languages is not reachable ➊. Otherwise,
    we print the total cost that we accumulated ➋.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何目标语言不可达，任务就无法完成 ➊。否则，我们将打印出累积的总成本 ➋。
- en: Now you’re ready to submit to the judge. Sabasa!
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好提交给评审了。Sabasa!
- en: Summary
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: We wrote gobs of code in this chapter. Of course, I hope that the code offers
    you a starting point for solving your own graph problems. In the long term, though,
    what I hope you remember is the importance of modeling as an early step in the
    problem-solving process. Couching a problem in terms of BFS collapses the domains
    of knights and ropes and translations into the single domain of graphs. Searching
    Google for “how to climb a rope” will get you nowhere (except perhaps up a real
    rope). Searching for “breadth-first search” will instead offer as many code samples
    and explanations and examples as you’re willing to read. If you read comments
    left by programmers on the judges’ websites, you’ll see that they communicate
    on the level of algorithms, not on the level of problem-specific aspects. Often,
    they’ll just say “BFS Problem” to get their point across. You’re learning this
    language of modeling and how to go from the model to working code. There’s more
    graph-modeling coming up in the next chapter, where we tackle weighted graphs
    in their full generality.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们写了大量的代码。当然，我希望这些代码能为你解决自己图形问题提供一个起点。不过，从长远来看，我希望你记住的是，建模作为解决问题过程中的早期步骤的重要性。将问题用广度优先搜索（BFS）来表述，把骑士、绳索和翻译这些领域统一为图形这一单一领域。通过
    Google 搜索“如何爬绳子”是不会得到有用结果的（除非你真的爬上了一根绳子）。而搜索“广度优先搜索”则会提供你愿意阅读的代码示例、解释和案例。如果你阅读程序员在评测网站上留下的评论，你会发现他们讨论的是算法层面的内容，而非问题的特定方面。通常，他们会简洁地说“BFS问题”来表达观点。你正在学习这种建模语言，以及如何从模型转化为可工作的代码。在下一章，我们将继续介绍图形建模，重点讲解加权图的完整概念。
- en: Notes
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Knight Chase is originally from the 1999 Canadian Computing Competition. Rope
    Climb is originally from the 2018 Woburn Challenge, Online Round 1, Senior Division.
    Book Translation is originally from the 2016 East Central North America Regional
    Programming Contest.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 《骑士追逐》最初来自 1999 年加拿大计算机竞赛。《绳索攀爬》最初来自 2018 年 Woburn 挑战赛在线第一轮高级组。《书籍翻译》最初来自 2016
    年东中北美地区编程竞赛。
- en: 'There’s a trick that we can use to cut down the code we have to write when
    considering multiple, similar moves in a BFS. Feel free to check out how that
    works in “Knight Chase: Encoding Moves” in [Appendix B](app02.xhtml).'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑广度优先搜索中的多个相似操作时，我们可以使用一种技巧来减少需要编写的代码。你可以在 [附录 B](app02.xhtml) 的《骑士追逐：编码移动》中查看这一技巧的实现。
- en: 'We learned all about BFS in this chapter, but if you continue with graph algorithms
    you might like to study *depth-first search* (DFS) as well. I recommend *Algorithms
    Illuminated (Part 2): Graph Algorithms and Data Structures* by Tim Roughgarden
    (2018) for more on BFS, DFS, and other graph algorithms.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们学习了广度优先搜索，但如果你继续学习图形算法，可能也会想研究*深度优先搜索*（DFS）。我推荐 Tim Roughgarden（2018）编写的《Algorithms
    Illuminated (Part 2): Graph Algorithms and Data Structures》一书，进一步了解广度优先搜索、深度优先搜索和其他图形算法。'
