- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    CANVAS ELEMENT</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">画布元素</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.png)'
- en: 'One of the more interactive elements in HTML is the canvas element. This element
    acts like a painter’s canvas: it provides space for you to draw images within
    the browser window using JavaScript. What’s more, by repeatedly erasing old images
    and drawing new ones, you can create animations on the canvas. In this sense,
    the canvas element is more like the screen at a movie theater, where the image
    is updated many times every second to create the appearance of motion.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: HTML中更具交互性的元素之一就是画布元素。这个元素像画家的画布一样：它为你提供了在浏览器窗口中使用JavaScript绘制图像的空间。而且，通过反复擦除旧图像并绘制新图像，你可以在画布上创建动画。从这个意义上说，画布元素更像电影院中的屏幕，图像每秒被更新多次，从而产生运动的效果。
- en: In this chapter you’ll learn how to create canvas elements and how to use the
    Canvas API, which gives you a way to manipulate the canvas via JavaScript. You’ll
    write JavaScript to draw static images to the canvas. Then you’ll build a simple
    interactive drawing application. Finally, you’ll learn the basics of creating
    2D animations on the canvas.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你将学习如何创建画布元素以及如何使用Canvas API，后者让你能够通过JavaScript操控画布。你将编写JavaScript代码，将静态图像绘制到画布上。接着，你将构建一个简单的互动绘图应用。最后，你将学习如何在画布上创建二维动画的基础知识。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating a Canvas</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">创建画布</samp>
- en: To include a canvas element on a web page, you add it to the body element in
    the page’s *index.html* file. All you need are the opening and closing HTML tags,
    <canvas></canvas>, as the canvas element doesn’t have any required attributes.
    However, it’s a good idea to give the canvas an id, so you can easily access it
    using JavaScript. It’s also common to set the element’s width and height attributes
    so you can establish the size of the canvas.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要在网页中包含画布元素，只需将其添加到页面的*index.html*文件中的body元素中。你只需要使用开闭的HTML标签<canvas></canvas>即可，因为画布元素没有必需的属性。然而，最好给画布指定一个id，以便你可以通过JavaScript轻松访问它。通常也会设置元素的宽度和高度属性，以便确定画布的大小。
- en: Images that appear in the canvas are generated using JavaScript, not HTML. Any
    HTML between the opening and closing tags will appear only if the browser doesn’t
    support the canvas element, so this can be used as a fallback for older or text-only
    browsers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在画布中的图像是通过JavaScript生成的，而不是HTML。在开闭标签之间的任何HTML内容只有在浏览器不支持画布元素时才会显示，因此可以作为老旧或仅支持文本的浏览器的备用方案。
- en: Let’s create an HTML file that includes a canvas element. We’ll also include
    a script element linking to a JavaScript file, where we’ll write code to generate
    images on the canvas. We’ll use the same HTML file throughout the chapter to draw
    different kinds of images. Create a new directory called *chapter9*, and make
    a new file in that directory called *index.html*. Enter the content shown in [Listing
    9-1](#Lis9-1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含画布元素的HTML文件。我们还将包含一个script元素，链接到一个JavaScript文件，在其中编写代码来在画布上生成图像。在本章中，我们将使用相同的HTML文件绘制不同种类的图像。创建一个名为*chapter9*的新目录，并在该目录中创建一个名为*index.html*的新文件。输入[示例9-1](#Lis9-1)所示的内容。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-1: An</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    with a canvas element</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例9-1：带有画布元素的</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件</samp>
- en: This is our familiar HTML template, similar to the *index.html* files we’ve
    created in previous chapters, but with a canvas element instead of an h1 element.
    The width and height attributes specify the size of the canvas in pixels. By default,
    the canvas is transparent, so you won’t actually see anything yet if you load
    the page.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们熟悉的HTML模板，类似于我们在之前章节中创建的*index.html*文件，但这里使用的是画布元素而不是h1元素。宽度和高度属性指定了画布的像素大小。默认情况下，画布是透明的，因此如果你加载页面时不会看到任何内容。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Making Static Drawings</samp>
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">制作静态图像</samp>
- en: Now that we have a canvas element, we’re ready to draw on it using JavaScript
    and the Canvas API. We’ll start by drawing a solid rectangle. Then we’ll look
    at how to create other static drawings. Create a new file called *script.js* in
    the *chapter9* directory, and enter the code shown in [Listing 9-2](#Lis9-2).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个canvas元素，可以使用JavaScript和Canvas API在其上绘制图形。我们将首先绘制一个实心矩形。接下来，我们将看看如何创建其他静态图形。创建一个名为*script.js*的新文件，放在*chapter9*目录中，并输入[清单
    9-2](#Lis9-2)中显示的代码。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-2: Drawing a rectangle
    in</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-2：在</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp>
    中绘制矩形
- en: First, we get a reference to the canvas element using the document .querySelector
    method. The canvas element has a method called getContext, which we use to get
    the canvas’s *drawing context*. The drawing context is an object that provides
    the entire Canvas API as a set of methods and properties (like fillRect and fillStyle,
    respectively, both used in [Listing 9-2](#Lis9-2)). These methods and properties
    are what we’ll use to draw images on the canvas. In this case, we pass the string
    "2d" to the getContext method to request the two-dimensional drawing context.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用document.querySelector方法获取对canvas元素的引用。canvas元素有一个名为getContext的方法，我们用它来获取canvas的*绘图上下文*。绘图上下文是一个对象，它提供了整个Canvas
    API，作为一组方法和属性（例如[清单 9-2](#Lis9-2)中使用的fillRect和fillStyle）。这些方法和属性是我们用来在canvas上绘制图形的工具。在这个例子中，我们将字符串"2d"传递给getContext方法，请求二维绘图上下文。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*You can draw 3D graphics on the canvas by passing the string "webgl" or "webgpu"
    to the getContext method instead of "2d", but both of those are much more complicated
    than 2D graphics and are outside the scope of this book.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以通过将字符串"webgl"或"webgpu"传递给getContext方法来在canvas上绘制3D图形，而不是"2d"，但这两者比2D图形复杂得多，并且超出了本书的范围。*'
- en: 'Next, we tell the drawing context that we want the fill color for new elements
    to be blue, using the fillStyle property. Finally, we draw a filled rectangle
    using the current fill color with the fillRect method. This method takes four
    arguments: the x- and y-coordinates of the top-left corner of the rectangle, and
    the width and height of the rectangle in pixels. The coordinates work the same
    way as the coordinates for the whole browser window: x values increase as you
    move from left to right across the canvas, and y values increase from top to bottom,
    with (0, 0) representing the top-left corner of the canvas.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们告诉绘图上下文我们希望新元素的填充颜色为蓝色，使用fillStyle属性。最后，我们使用当前的填充颜色通过fillRect方法绘制一个填充矩形。此方法接受四个参数：矩形左上角的x和y坐标，以及矩形的宽度和高度（以像素为单位）。坐标的工作方式与整个浏览器窗口的坐标相同：x值从左到右增加，y值从上到下增加，其中(0,
    0)表示canvas的左上角。
- en: Open *index.html* in your browser. You should see a solid blue rectangle, as
    shown in [Figure 9-1](chapter9.xhtml#fig9-1).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开*index.html*。你应该能看到一个实心蓝色矩形，如[图 9-1](chapter9.xhtml#fig9-1)所示。
- en: '![](../images/Figure_9-1.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_9-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: The blue rectangle</samp>'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-1：蓝色矩形</samp>
- en: Any subsequent calls to fillRect will use the same fillStyle, so they’ll also
    produce blue rectangles (until you set a new fillStyle, that is). You can confirm
    this by drawing some more rectangles to the canvas.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 任何后续调用fillRect方法都会使用相同的fillStyle，因此它们也会生成蓝色矩形（直到你设置一个新的fillStyle）。你可以通过绘制一些更多的矩形来确认这一点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Drawing Outlined
    Rectangles</samp>
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">绘制带描边的矩形</samp>
- en: As well as fillRect for making a rectangle filled with a color, the Canvas API
    provides the strokeRect method for outlining (*stroking*) a rectangle. To try
    it out, modify *script.js* as shown in [Listing 9-3](#Lis9-3).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于填充颜色的fillRect方法，Canvas API还提供了strokeRect方法，用于勾画（*描边*）矩形。要尝试这个方法，请按照[清单 9-3](#Lis9-3)所示修改*script.js*。
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-3: Using</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">strokeRect to outline a rectangle</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-3：使用</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">strokeRect勾画矩形</samp>
- en: 'First we specify the width of the outline with the lineWidth property, setting
    it to 2 pixels wide. Then we use strokeStyle and strokeRect, rather than fillStyle
    and fillRect, to create an outlined rectangle with no fill color. The strokeRect
    method takes the same arguments as fillRect: the x- and y-coordinates of the top-left
    corner, and the width and height of the rectangle.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 lineWidth 属性指定轮廓的宽度，将其设置为 2 像素宽。然后，我们使用 strokeStyle 和 strokeRect，而不是
    fillStyle 和 fillRect，来创建一个没有填充色的轮廓矩形。strokeRect 方法的参数与 fillRect 相同：左上角的 x 和 y
    坐标，以及矩形的宽度和高度。
- en: When you reload *index.html*, you should see the rectangle is now outlined in
    red, with no fill, as shown in [Figure 9-2](chapter9.xhtml#fig9-2).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新加载 *index.html* 时，应该会看到矩形现在用红色轮廓描边，但没有填充，如[图 9-2](chapter9.xhtml#fig9-2)所示。
- en: '![](../images/Figure_9-2.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_9-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: A red-outlined
    rectangle</samp>'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-2：一个红色轮廓的矩形</samp>
- en: When you set styles on the drawing context, such as the line width or line color,
    those settings apply only to subsequent additions to the canvas. That is, they
    don’t retroactively affect anything that’s already been drawn. In this sense,
    the canvas really is very much like a physical canvas, where the current style
    is determined by the color of paint and type of brush you’re using at the moment.
    To demonstrate, we’ll draw several rectangles with different colors. Add the code
    in [Listing 9-4](#Lis9-4) to the end of *script.js*, after the code for drawing
    the red rectangle.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在绘图上下文中设置样式，如线条宽度或线条颜色时，这些设置只会影响后续添加到画布上的内容。也就是说，它们不会对已经绘制的内容产生回溯影响。从这个意义上讲，画布确实像一个物理画布，你当前使用的油漆颜色和画笔类型决定了样式。为了演示，我们将绘制几个不同颜色的矩形。在
    *script.js* 结尾添加[清单 9-4](#Lis9-4)中的代码，紧跟在绘制红色矩形的代码之后。
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-4: Drawing more rectangles</samp>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-4：绘制更多矩形</samp>
- en: This code draws a series of nested rectangles, each offset by 10 pixels from
    the previous one and each 20 pixels smaller than the previous one. Before we draw
    each successive rectangle, we change the color of the outline by updating the
    strokeStyle property.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码绘制了一系列嵌套的矩形，每个矩形都比前一个矩形偏移了 10 像素，且比前一个矩形小 20 像素。在绘制每个后续矩形之前，我们通过更新 strokeStyle
    属性来改变轮廓的颜色。
- en: Refresh *index.html*, and you should see something like the image in [Figure
    9-3](chapter9.xhtml#fig9-3).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新 *index.html*，你应该会看到类似于[图 9-3](chapter9.xhtml#fig9-3)中的图像。
- en: '![](../images/Figure_9-3.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_9-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: Concentric rectangles</samp>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-3：同心矩形</samp>
- en: Each rectangle is a different color, indicating that the style changes didn’t
    impact anything that had already been drawn.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每个矩形的颜色都不同，表明样式的变化并没有影响到已经绘制的部分。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Drawing Other Shapes
    Using Paths</samp>
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用路径绘制其他形状</samp>
- en: All other shapes besides rectangles are drawn on the canvas as *paths*. A path
    is a series of points connected by straight or curved lines, and then either stroked
    with an outline or filled in with a color. As an example, we’ll draw a path between
    three different points and then fill it in to make a red triangle. Replace the
    contents of *script.js* with the code in [Listing 9-5](#Lis9-5).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了矩形之外的所有其他形状都是作为 *路径* 绘制的。路径是由直线或曲线连接的一系列点，然后用轮廓描边或填充颜色。举个例子，我们将绘制一个通过三点连接的路径，并填充它，形成一个红色的三角形。将
    *script.js* 的内容替换为[清单 9-5](#Lis9-5)中的代码。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-5: Drawing a triangle
    with path methods</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-5：使用路径方法绘制三角形</samp>
- en: Drawing a path takes three steps. First, you declare that you want to start
    drawing a new path with beginPath. Then, you use various methods to define where
    the path will be. Finally, you use fill or stroke to fill or stroke the path.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制路径分为三个步骤。首先，使用 beginPath 声明开始绘制新路径。接下来，使用各种方法定义路径的位置。最后，使用 fill 或 stroke 填充或描边路径。
- en: 'In this case, we use two different methods to define the path: moveTo and lineTo.
    The moveTo method moves an imaginary pen to a particular point on the canvas defined
    by x- and y-coordinates, without drawing a line. We use this method to define
    the starting point of our path, (100, 100), which will be the bottom-left corner
    of the triangle. The lineTo method does the same as moveTo, but it draws a line
    as it moves. Thus, lineTo(150, 15) draws a line from (100, 100) to (150, 15),
    and so on. Finally, we fill the shape with the fill method. When you refresh the
    page, you should see a red triangle, as shown in [Figure 9-4](chapter9.xhtml#fig9-4).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了两种不同的方法来定义路径：moveTo 和 lineTo。moveTo 方法将虚拟的笔移动到画布上的某个点，这个点由 x 和 y
    坐标定义，但不会画出线条。我们用这个方法定义路径的起点（100，100），它将是三角形的左下角。lineTo 方法与 moveTo 类似，但它在移动时会绘制一条线。所以，lineTo(150,
    15) 会从（100，100）绘制一条线到（150，15），依此类推。最后，我们使用 fill 方法填充形状。当你刷新页面时，你应该能看到一个红色的三角形，如
    [Figure 9-4](chapter9.xhtml#fig9-4) 所示。
- en: '![](../images/Figure_9-4.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_9-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4: Drawing a filled
    triangle</samp>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4：绘制一个填充的三角形</samp>
- en: Drawing circles follows a similar pattern, but uses a method called arc instead
    of moveTo and lineTo. The arc method draws an *arc*, a section of the circumference
    of a circle. You can produce any length of arc with the arc method, but here we’ll
    use it to produce an entire circle.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制圆形的过程遵循类似的模式，但使用一种叫做 arc 的方法，而不是 moveTo 和 lineTo。arc 方法绘制一个 *弧形*，即圆周的一部分。你可以用
    arc 方法绘制任何长度的弧形，但在这里我们用它绘制一个完整的圆形。
- en: Update *script.js* with the code in [Listing 9-6](#Lis9-6). The first and third
    steps of the path drawing code are the same, but we replace the second step with
    the code for drawing a circle rather than a triangle.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [Listing 9-6](#Lis9-6) 中的代码更新 *script.js*。路径绘制代码的第一步和第三步相同，但我们将第二步的代码替换为绘制圆形的代码，而不是三角形。
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-6: Drawing a circle
    with path methods</samp>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-6：使用路径方法绘制圆形</samp>
- en: 'The arc method takes a whopping six arguments. The first two are the x- and
    y-coordinates of the center of the circle. In this case we’re centering the circle
    at the coordinates (150, 100). The third argument is the circle’s radius in pixels,
    which we set to 50. The next two arguments give the starting and ending angles
    of the arc in radians: we provide 0 for the starting angle and Math.PI * 2 for
    the ending angle to produce a full circle. The final argument specifies whether
    the arc should be drawn clockwise (false) or counterclockwise (true) from the
    starting angle to the ending angle. In this case, we pick clockwise, but since
    we’re drawing a full circle, the direction is irrelevant.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: arc 方法接受六个参数。前两个参数是圆心的 x 和 y 坐标。在这个例子中，我们将圆心设定在坐标（150，100）。第三个参数是圆的半径（以像素为单位），我们将其设置为
    50。接下来的两个参数给出弧形的起始和结束角度（以弧度为单位）：我们为起始角度提供 0，为结束角度提供 Math.PI * 2，以画出一个完整的圆。最后一个参数指定弧形是顺时针（false）还是逆时针（true）绘制。从起始角度到结束角度。在这个例子中，我们选择顺时针方向，但由于我们画的是一个完整的圆，方向就不重要了。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: Radians *are a way of measuring angles. In degrees, a full revolution of a circle
    goes from 0 to 360\. In radians, a revolution goes from 0 to 2π.*
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 弧度 *是衡量角度的一种方式。在度数中，一个圆的完整旋转从 0 到 360°。在弧度中，完整旋转从 0 到 2π*。
- en: When you refresh the page now, you should see a red circle, as shown in [Figure
    9-5](chapter9.xhtml#fig9-5).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在刷新页面后，你应该能看到一个红色的圆形，如 [Figure 9-5](chapter9.xhtml#fig9-5) 所示。
- en: '![](../images/Figure_9-5.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_9-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-5: Drawing a filled
    circle</samp>'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-5：绘制一个填充的圆形</samp>
- en: You can use the same technique to draw a stroked circle instead by using the
    stroke method rather than the fill method. What’s more, you can make compound
    shapes like rounded rectangles by combining calls to the lineTo and arc methods.
    The Canvas API also allows for drawing more complex curves with the quadraticCurveTo
    and bezierCurveTo methods. Search the Mozilla Developer Network (MDN) Web Docs
    ([*https://<wbr>developer<wbr>.mozilla<wbr>.org*](https://developer.mozilla.org))
    for more details about these other methods.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的技巧来绘制一个带有描边的圆圈，方法是使用 stroke 方法而不是 fill 方法。而且，你可以通过结合调用 lineTo 和 arc
    方法来创建复合形状，如圆角矩形。Canvas API 还允许使用 quadraticCurveTo 和 bezierCurveTo 方法绘制更复杂的曲线。可以在
    Mozilla 开发者网络（MDN）Web 文档中（[*https://<wbr>developer<wbr>.mozilla<wbr>.org*](https://developer.mozilla.org)）查找有关这些其他方法的更多详细信息。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Interacting with the Canvas</samp>
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">与 Canvas 的交互</samp>
- en: The canvas gets a lot more interesting when the user can interact with it. The
    canvas element itself doesn’t have any notion of interactivity built in. However,
    we can add that interactivity with JavaScript by writing event handlers that listen
    for certain user actions and trigger Canvas API methods that update the canvas
    in response.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户能够与 canvas 进行交互时，canvas 变得更加有趣。canvas 元素本身没有内置任何交互功能。然而，我们可以通过编写事件处理程序来为其添加交互性，这些事件处理程序监听特定的用户操作，并触发
    Canvas API 方法，以便根据响应更新 canvas。
- en: In this section, we’ll build a very basic drawing application using a canvas
    element with a click handler. The handler will listen for clicks on the canvas,
    and call a method that draws a circle at the position where the click happened.
    We’ll also create a slider so the user can set the opacity of the circles, and
    a button to clear the canvas.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用带有点击处理程序的 canvas 元素构建一个非常基本的绘图应用。该处理程序将监听 canvas 上的点击事件，并调用一个方法，在点击发生的位置绘制一个圆圈。我们还将创建一个滑块，让用户设置圆圈的透明度，并添加一个按钮来清除
    canvas。
- en: First, let’s add the necessary HTML elements to create a slider and a button.
    Make the modifications shown in [Listing 9-7](#Lis9-7) to *index.html*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加必要的 HTML 元素来创建一个滑块和一个按钮。按照[清单 9-7](#Lis9-7)中的修改对 *index.html* 进行修改。
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-7: Adding some additional
    elements to</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-7：向</samp> <samp class="SANS_Futura_Std_Book_11">index.html
    添加一些额外元素</samp>
- en: Here we add a new div element containing three other HTML elements. The div
    element is there to group the elements inside it together and to position them
    below the canvas (without the div they’d appear to the right of the canvas).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个新的 div 元素，其中包含另外三个 HTML 元素。div 元素用于将其内部的元素组合在一起，并将它们定位在 canvas 下面（如果没有
    div，它们将出现在 canvas 右侧）。
- en: The first element inside the div is a button element. It creates a clickable
    button. Any content between the opening and closing tags will appear as text on
    the button, so our button will have the text *Clear*. Later, we’ll write a JavaScript
    function that clears any circles on the canvas when the user clicks the button.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: div 内的第一个元素是一个按钮元素。它创建了一个可点击的按钮。开闭标签之间的任何内容将显示为按钮上的文本，因此我们的按钮上将显示文本 *清除*。稍后，我们将编写一个
    JavaScript 函数，当用户点击按钮时，它将清除 canvas 上的所有圆圈。
- en: 'Next inside the div is an input element, which is used for taking values from
    the user. The input element doesn’t allow any child elements, so it doesn’t need
    a closing tag. In this case the input is of type range, which means it will display
    as a slider. This slider will be used to set the opacity of new circles drawn
    on the canvas. It has several attributes defining its functionality: min defines
    the minimum value the slider will produce, max defines the maximum value, value
    defines the initial value the slider is set to, and step is the size of each movement
    (enabling you to control the number of allowed values). This slider is set to
    range from 0 to 1 in steps of 0.1, and it starts at 1, which corresponds to full
    opacity.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 div 内是一个 input 元素，用于获取用户的值。input 元素不允许任何子元素，因此不需要闭合标签。在本例中，input 元素的类型是
    range，这意味着它将显示为一个滑块。这个滑块将用于设置在 canvas 上绘制的新圆圈的透明度。它有几个属性定义其功能：min 定义滑块将产生的最小值，max
    定义最大值，value 定义滑块的初始值，step 是每次移动的大小（使你能够控制允许的值的数量）。此滑块设置为从 0 到 1，步长为 0.1，初始值为 1，表示完全不透明。
- en: The last element in the div is a label element, which applies a label to another
    element. The for attribute of the label determines which element the label should
    be applied to; its value has to match the id of another element. In this case,
    we assign the label to the slider by specifying opacity as the target id. This
    will cause the slider to be labeled *Opacity*, which is the text content of the
    label element. Thanks to the label element’s for attribute, the browser understands
    that the label and input elements are related, and certain actions performed on
    the label will apply to the input. For example, if you hover over the label, the
    input will display as hovered, and if you click the label, the input will get
    keyboard focus (in this case, pressing the left or right arrow key will decrease
    or increase the value of the slider, respectively).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: div 中的最后一个元素是 label 元素，它为另一个元素应用标签。label 的 for 属性决定了该标签应用于哪个元素；它的值必须与另一个元素的
    id 匹配。在这种情况下，我们通过指定 opacity 作为目标 id，将标签应用于滑块。这将导致滑块被标记为 *Opacity*，这就是 label 元素的文本内容。由于
    label 元素的 for 属性，浏览器会理解标签和输入元素是相关的，并且对标签执行的某些操作将应用于输入元素。例如，如果你将鼠标悬停在标签上，输入框会显示为悬停状态；如果你点击标签，输入框将获得键盘焦点（在这种情况下，按左箭头或右箭头键分别会减少或增加滑块的值）。
- en: Load *index.html* in your browser, and you should see something similar to [Figure
    9-6](chapter9.xhtml#fig9-6) (the exact appearance of these elements may vary depending
    on your browser and operating system).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中加载 *index.html*，你应该会看到类似于[图 9-6](chapter9.xhtml#fig9-6)的内容（这些元素的具体外观可能会根据你的浏览器和操作系统有所不同）。
- en: '![](../images/Figure_9-6.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_9-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-6: The new button
    and input elements</samp>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-6：新的按钮和输入元素</samp>
- en: Now that we have the HTML elements, we can write the JavaScript that will make
    this application interactive. First, we’ll add some general declarations and the
    code for drawing circles when the user clicks on the canvas. Update *script.js*
    with the code shown in [Listing 9-8](#Lis9-8).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 HTML 元素，可以编写 JavaScript 代码来使这个应用程序具备交互性。首先，我们将添加一些通用声明和在用户点击画布时绘制圆形的代码。请更新
    *script.js* 文件，加入[清单 9-8](#Lis9-8)中的代码。
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-8: Drawing a circle
    on click</samp>'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-8：点击时绘制一个圆形</samp>
- en: First we store the width and height of the canvas element in two variables,
    width and height. We’ll need these variables later, in our function for clearing
    the canvas. The width and height properties of the JavaScript canvas object come
    straight from the HTML canvas element’s width and height properties (which are
    both set to 300 in *index.html*). We also initialize the variable opacity to 1.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将画布元素的宽度和高度存储在两个变量 width 和 height 中。稍后我们在清除画布的函数中会用到这些变量。JavaScript 画布对象的宽度和高度属性直接来自
    HTML 画布元素的宽度和高度属性（在 *index.html* 中这两个属性都设置为 300）。我们还将变量 opacity 初始化为 1。
- en: Next, we create a helper function called drawCircle. This function takes an
    x- and a y-coordinate and draws a filled circle at that location. We use the same
    path drawing methods demonstrated in [Listing 9-6](#Lis9-6) to draw the circle.
    The x and y parameters determine the circle’s center, and we set its radius to
    10 pixels.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为 drawCircle 的辅助函数。这个函数接受一个 x 坐标和一个 y 坐标，并在该位置绘制一个填充的圆形。我们使用与[清单
    9-6](#Lis9-6)中演示的相同路径绘制方法来绘制圆形。x 和 y 参数确定圆形的中心，我们将其半径设置为 10 像素。
- en: One key difference from the previous drawing examples is that we’re setting
    fillStyle to an *RGBA* color instead of a named color like "red" or "blue" ❶.
    RGBA is a way of defining colors using four numbers corresponding to the red,
    green, blue, and alpha channels. The first three indicate the amount of each primary
    color of light. Their values can range from 0 to 255, and they can be combined
    to produce any color you might want. Setting all three to 0 produces black, and
    setting all three to 255 produces white. *Alpha* is another word for opacity,
    and it defines how opaque or transparent the color should be, ranging from 0 (completely
    transparent) to 1 (completely opaque).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的绘图示例的一个关键区别是，我们将 fillStyle 设置为 *RGBA* 颜色，而不是像 "red" 或 "blue" 这样的命名颜色 ❶。RGBA
    是一种使用四个数字定义颜色的方法，分别对应红色、绿色、蓝色和 alpha 通道。前三个数字表示每种基本光的颜色强度，数值范围从 0 到 255，可以通过组合这些值来生成任何你想要的颜色。将三个数值都设置为
    0 会生成黑色，将三个数值都设置为 255 会生成白色。*Alpha* 是不透明度的另一个说法，它定义了颜色应该有多不透明或透明，范围从 0（完全透明）到
    1（完全不透明）。
- en: In the Canvas API, you set RGBA colors using the string "rgba(…)" with the four
    values in the parentheses, separated by commas. For example, setting fillStyle
    to the string "rgba(0, 255, 0, 0.9)" would make bright green circles that are
    slightly transparent. In our case, we wrap the RGBA string in backticks so we
    can use a placeholder for the alpha value to allow the user to change the opacity
    with the slider.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Canvas API 中，你可以使用字符串 "rgba(…)" 设置 RGBA 颜色，括号中的四个值用逗号分隔。例如，将 fillStyle 设置为字符串
    "rgba(0, 255, 0, 0.9)" 将使得绘制的绿色圆圈稍微透明。在我们的例子中，我们将 RGBA 字符串放在反引号中，以便使用占位符替代 alpha
    值，从而允许用户通过滑块来改变透明度。
- en: Lastly, we add a click event handler to the canvas element using add EventListener.
    The handler calls the drawCircle function we just created, passing the offsetX
    and offsetY properties of the click event as the function’s parameters. The offsetX
    and offsetY properties give the distance of the click event from the top-left
    corner of the clicked element itself (rather than from the top-left corner of
    the whole browser window), so they’re ideal for determining exactly where on the
    canvas the click happened.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为画布元素添加了一个点击事件处理程序，使用 addEventListener。该处理程序调用我们刚刚创建的 drawCircle 函数，并将点击事件的
    offsetX 和 offsetY 属性作为函数的参数。offsetX 和 offsetY 属性给出了点击事件距离点击元素的左上角的距离（而不是整个浏览器窗口的左上角），因此它们非常适合确定点击发生在画布上的确切位置。
- en: Reload *index.html* in your browser and try clicking on the canvas. Wherever
    you click, a small green circle should appear, as shown in [Figure 9-7](chapter9.xhtml#fig9-7).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中重新加载 *index.html*，并尝试点击画布。无论点击在哪里，都应该会出现一个小的绿色圆圈，如 [图 9-7](chapter9.xhtml#fig9-7)
    所示。
- en: '![](../images/Figure_9-7.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_9-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-7: Drawing green circles
    with mouse clicks</samp>'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-7：使用鼠标点击绘制绿色圆圈</samp>
- en: To complete the drawing application, we need to wire up the Clear button and
    the Opacity slider. Add the code in [Listing 9-9](#Lis9-9) to the end of *script.js*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成绘图应用程序，我们需要连接“清除”按钮和“透明度”滑块。将 [Listing 9-9](#Lis9-9) 中的代码添加到 *script.js*
    的末尾。
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-9: Wiring up the
    Clear and Opacity controls</samp>'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-9：连接“清除”和“透明度”控制</samp>
- en: First we add a click event handler to the Clear button. This calls a Canvas
    API method called clearRect, which clears a rectangular section of the canvas.
    Just like when drawing a rectangle, you define the rectangle to be cleared using
    the x- and y-coordinates of its top-left corner, followed by its width and height.
    Here we use (0, 0, width, height) to specify that we want to clear a rectangle
    that starts at the top-left corner of the canvas and is as wide and high as the
    canvas itself. Thus, ctx.clearRect(0, 0, width, height); clears the entire canvas.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为“清除”按钮添加点击事件处理程序。此操作调用了一个名为 clearRect 的 Canvas API 方法，用于清除画布的矩形区域。就像绘制矩形一样，你通过指定矩形的左上角的
    x 和 y 坐标，以及矩形的宽度和高度来定义要清除的区域。在这里，我们使用 (0, 0, width, height) 来指定我们要清除的矩形区域从画布的左上角开始，并且宽度和高度与画布本身一样。因此，ctx.clearRect(0,
    0, width, height); 会清除整个画布。
- en: Next, we add a change event handler to the Opacity slider. The change event
    is triggered on input elements when their value changes, so this handler will
    be called whenever the slider is set to a new position. We get the input element
    with e.target and get the element’s current value with .value. Then we update
    the opacity variable with this value. Because the drawCircle function uses the
    value of opacity as the alpha component of the RGBA color, any new circles will
    use the latest value set with the Opacity slider.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为“透明度”滑块添加了一个 change 事件处理程序。当输入元素的值发生变化时，change 事件会被触发，因此当滑块设置到新位置时，该处理程序会被调用。我们通过
    e.target 获取输入元素，通过 .value 获取该元素的当前值。然后，我们使用这个值更新透明度变量。因为 drawCircle 函数使用透明度作为
    RGBA 颜色的 alpha 分量，所以任何新绘制的圆圈都会使用通过透明度滑块设置的最新值。
- en: Now when you reload *index.html* in your browser, you should have a fully functioning
    (if basic) drawing application! You can use the Opacity slider to change the opacity
    of new circles and the Clear button to clear the canvas and start drawing again.
    Try drawing overlapping circles with the Opacity slider set halfway to see how
    they overlay.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你在浏览器中重新加载 *index.html* 时，你应该有一个完全正常工作的（虽然是基础的）绘图应用程序！你可以使用透明度滑块来改变新圆圈的透明度，使用“清除”按钮来清空画布并重新开始绘图。尝试将透明度滑块设置为中间位置，绘制重叠的圆圈，看看它们如何叠加。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Animating the Canvas</samp>
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">动画化画布</samp>
- en: As noted at the beginning of this chapter, you can animate the canvas by drawing
    on it and updating the image multiple times per second. In this section, we’ll
    code a very simple animation to show the basics of how this works.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头所提到的，你可以通过在画布上绘制并每秒多次更新图像来动画化画布。在本节中，我们将编写一个非常简单的动画代码，展示这一工作的基本原理。
- en: 'Animating the canvas generally follows this basic pattern:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 动画画布通常遵循以下基本模式：
- en: 1.  Update state
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  更新状态
- en: 2.  Clear canvas
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  清除画布
- en: 3.  Draw image
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  绘制图像
- en: 4.  Wait a short time
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  等待短暂时间
- en: 5.  Repeat
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  重复
- en: '*State* here means some variable(s) storing information about the current frame
    of the animation. This could be the current location of an object in motion, the
    direction the object is moving in, and so on. In our example, the state will be
    the x- and y-coordinates of a circle. When it’s time to update the state, we’ll
    increment the x- and y-coordinates by 1, meaning that the circle’s position will
    gradually move diagonally down and to the right. Drawing the image will entail
    drawing a small circle centered at the updated x- and y-coordinates. We clear
    the canvas before drawing the circle to ensure that the image from the previous
    cycle is removed. We’ll tackle the last two steps (waiting and repeating) by using
    the setInterval function to call our code every 100 ms, or 10 times a second.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*状态* 在这里指的是存储动画当前帧信息的变量。它可以是一个运动物体的当前位置、物体的运动方向等。在我们的例子中，状态将是圆的 x 和 y 坐标。当需要更新状态时，我们将
    x 和 y 坐标各自增加 1，意味着圆的位置将逐渐向右下角移动。绘制图像将包括在更新后的 x 和 y 坐标处绘制一个小圆。在绘制圆之前，我们会清除画布，以确保移除上一个循环中的图像。我们将通过使用
    setInterval 函数每 100 毫秒调用一次代码，或者每秒调用 10 次，来处理最后两个步骤（等待和重复）。'
- en: We can continue to work with the same HTML and JavaScript files. The only change
    to make to *index.html* is to remove the div and its nested elements that we added
    in [Listing 9-7](#Lis9-7), as they’re not needed anymore. After removing those
    elements, update *script.js* based on the code in [Listing 9-10](#Lis9-10).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续使用相同的 HTML 和 JavaScript 文件。对 *index.html* 进行的唯一修改是移除我们在 [清单 9-7](#Lis9-7)
    中添加的 div 及其嵌套元素，因为它们不再需要。移除这些元素后，按照 [清单 9-10](#Lis9-10) 中的代码更新 *script.js*。
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-10: Creating an animation</samp>'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-10：创建动画</samp>
- en: We create two new variables, x and y, representing the location of the circle
    that we’ll animate. These variables store the current state of the animation and
    will be updated at regular intervals. The drawCircle function itself is mostly
    unchanged, although the fillStyle is different. Now that we’re not setting an
    opacity, we can use the simpler rgb(…)-format string for setting the red, green,
    and blue values. With "rgb(…)", the opacity of the color is always 100 percent.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个新的变量，x 和 y，表示我们将要动画化的圆的位置。这些变量存储动画的当前状态，并将在固定间隔内更新。drawCircle 函数本身大致不变，虽然
    fillStyle 有所不同。现在我们不再设置透明度，可以使用更简单的 rgb(…)-格式字符串来设置红色、绿色和蓝色的值。使用 "rgb(…)" 时，颜色的透明度始终是
    100%。
- en: After drawCircle we declare the update function, where we update the x and y
    variables, incrementing each by 1. Next we declare the draw function, which clears
    the canvas and then calls drawCircle to draw a circle at the current x- and y-coordinates.
    Finally, we call setInterval to orchestrate the animation. You may recall from
    [Chapter 5](chapter5.xhtml) that setInterval takes a function and a time interval
    in milliseconds, and repeatedly calls that function once every time interval.
    Here we’re calling an anonymous function every 100 ms. The anonymous function
    itself calls update and draw to create each frame of the animation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 drawCircle 之后，我们声明了 update 函数，在该函数中我们更新了 x 和 y 变量，将它们各自增加 1。接下来，我们声明了 draw
    函数，它会清除画布，然后调用 drawCircle 在当前的 x 和 y 坐标处绘制圆形。最后，我们调用 setInterval 来协调整个动画。你可能还记得
    [第 5 章](chapter5.xhtml) 中提到，setInterval 接受一个函数和一个时间间隔（以毫秒为单位），并在每个时间间隔后重复调用该函数。这里，我们每
    100 毫秒调用一次匿名函数。这个匿名函数本身会调用 update 和 draw，生成每一帧的动画。
- en: Reload *index.html* in your browser, and you should see a small circle gradually
    move across the canvas from the top-left to the bottom-right corner. Even after
    the circle leaves the canvas, the x- and y-coordinates will keep increasing, but
    the canvas ignores anything drawn outside of its bounds.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中重新加载 *index.html*，你应该会看到一个小圆圈逐渐从左上角移动到右下角。即使圆圈离开了 canvas，x 和 y 坐标会继续增加，但
    canvas 会忽略任何超出其边界的绘制内容。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you learned the basics of drawing on the canvas element, as
    well as some techniques for creating interactive applications and animations using
    the canvas. We’ll build on some of these techniques later in this book as we learn
    how to make a canvas-based game.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了在 canvas 元素上绘图的基础知识，以及使用 canvas 创建互动应用和动画的一些技巧。稍后在本书中，我们将基于这些技巧，学习如何制作一个基于
    canvas 的游戏。
